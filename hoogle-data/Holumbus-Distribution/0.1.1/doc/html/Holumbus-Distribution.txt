-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | intra- and inter-program communication
--   
--   Holumbus-Distribution offers distributed data structures like Chan,
--   MVar or functions. These datatype can be used between different
--   programs on different computers to exchange data. With the help of
--   this library it is possible to build Erlang-Style mailboxes for an
--   easy implementation of distributed systems in Haskell.
@package Holumbus-Distribution
@version 0.1.1


-- | Version : 0.1
--   
--   In this part of the Holumbus-Framework, we use hslogging. With this,
--   we are able to activate and deactivate some nice debugging-Output.
--   This is the global configuration for the logging-output. Of cource, if
--   you want to use this output, you have to invoke initializeLogging.
module Holumbus.Common.Logging

-- | configures the logging-parameters for the Holumbus-Framework
initializeLogging :: [(String, Priority)] -> IO ()

-- | configures the logging-parameters for the Holumbus-Framework
initializeFileLogging :: FilePath -> [(String, Priority)] -> IO ()


-- | Version : 0.1
--   
--   Some nice helper functions for strict file writing, appending and
--   reading. All read-functions are strict, in the sense that the whole
--   file is read at once and the content is stored into memory. So you
--   won't have any semi-closed handles which might bring you in trouble
--   from time to time. The files are immedialty closed after the reading.
--   This Module can handle four filetypes: XML-Files, List-Files,
--   Binary-Files and Text-Files.
--   
--   XML-Files: Normal textfiles, but the content is stored as a
--   xml-representation. For the pickling, we use the HXT-Library (see
--   http://www.fh-wedel.de/~si/HXmlToolbox/)
--   
--   List-Files: Binary-Files, which store a list of data-objects. The main
--   difference between Binary-Files and List-Files is, that you can append
--   data to a List-File which will be automatically concatenated to the
--   existing list. If you try this with a normal Binary-File, you'll get
--   only the original list and the appended data will be lost.
--   
--   Binary-Files: Normal binary files, for the encoding and decoding, we
--   use the Haskell binary-package.
--   
--   Text-Files: Normal text files.
module Holumbus.Common.FileHandling

-- | Loads an XML-File and parses the content to a specified datatype.
loadFromXmlFile :: (XmlPickler a) => FilePath -> IO a

-- | Converts a dataset to XML and saves the XML-string into a file.
saveToXmlFile :: (XmlPickler a) => FilePath -> a -> IO ()

-- | Writes data to a list file.
writeToListFile :: (Binary a) => FilePath -> [a] -> IO ()

-- | Appends data to a list file.
appendToListFile :: (Binary a) => FilePath -> [a] -> IO ()

-- | reads from a list file.
readFromListFile :: (NFData a, Binary a) => FilePath -> IO [a]
parseByteStringToList :: (Binary a) => ByteString -> [a]
listToByteString :: (Binary a) => [a] -> ByteString

-- | Write data to a binary file.
writeToBinFile :: FilePath -> ByteString -> IO ()

-- | Append data to a binary file, this doesn't mean, that the contents are
--   really concatenated when you read the file.
appendToBinFile :: FilePath -> ByteString -> IO ()

-- | Reads the data from a binary file as a bytestring.
readFromBinFile :: FilePath -> IO ByteString

-- | Writes a sting to a text file.
writeToTextFile :: FilePath -> String -> IO ()

-- | Appends a string to a text file.
appendToTextFile :: FilePath -> String -> IO ()

-- | Strict file reading by Simon Marlow. found on
--   http://users.aber.ac.uk/afc/stricthaskell.html
readFromTextFile :: FilePath -> IO String


-- | Version : 0.1
--   
--   Some nice functions, needed everywhere.
module Holumbus.Common.Utils

-- | parses something from a maybe bytestring, if Nothing, then Nothing
decodeMaybe :: (Binary a) => Maybe ByteString -> Maybe a
filterEmptyList :: Maybe [k] -> [k]
setEmptyList :: [k] -> Maybe [k]

-- | For the nice output of key-value-pairs
prettyRecordLine :: (Show b, Show a) => Int -> a -> b -> String
handleAll :: (SomeException -> IO a) -> IO a -> IO a


-- | Version : 0.1
--   
--   This module provides an interface to start a server listeing on a tcp
--   socket. ( Module is based on simple tcp server found here
--   http:<i></i>sequence.complete.org<i>node</i>258 )
--   
--   You have to implement 2 functions type ServerAction a = a -&gt; Client
--   a -&gt; [Client a] -&gt; IO [Client a]
--   
--   and
--   
--   type LineConverter a = String -&gt; a
--   
--   to start a server use the doWithServer :: (Show a) =&gt; Int -&gt;
--   ServerAction a -&gt; LineConverter a -&gt; String -&gt; IO ()
--   function.
module Holumbus.Network.DoWithServer

-- | the connecting client type
data Client a
Client :: (TChan a) -> Handle -> HostName -> PortNumber -> Client a

-- | type for call back function that is executed within server cycle
type ServerAction a = a -> Client a -> [Client a] -> IO [Client a]

-- | converts the string read by hGetLine to your datatype
type LineConverter a = String -> a

-- | execute a ServerAction wrapped by the tcp server
doWithServer :: (Show a) => Int -> ServerAction a -> LineConverter a -> String -> IO ()
instance Ord (Client a)
instance Eq (Client a)
instance Show (Client a)


-- | Version : 0.1
--   
--   The Server-Module for the Holumbus framework.
--   
--   It contains the lowlevel functions, like the socket handling (opening,
--   reading, writing, ...).
module Holumbus.Distribution.DNode.Network
data SocketServer
getSocketServerName :: SocketServer -> HostName
getSocketServerPort :: SocketServer -> PortNumber
type HandlerFunction a = Handle -> IO a

-- | Creates a new (unix-)socket and starts the listener in its own thread.
--   You'll get a reference to the listener Thread, so you can kill it with
--   stopSocketServer. It is also possible to give a range of PortNumbers
--   on which the socket will be opened. The first portnumber available
--   will be taken.
startSocketServer :: HandlerFunction () -> Int -> Int -> IO (Maybe SocketServer)

-- | Stops a socker server by its internal thread id.
stopSocketServer :: SocketServer -> IO ()
performUnsafeSendRequest :: HandlerFunction a -> HostName -> PortNumber -> IO a
performSafeSendRequest :: HandlerFunction a -> a -> HostName -> PortNumber -> IO a
performMaybeSendRequest :: HandlerFunction a -> HostName -> PortNumber -> IO (Maybe a)

-- | Puts a bytestring to a handle. But to make the reading easier, we
--   write the length of the data as a message-header to the handle, too.
putByteStringMessage :: ByteString -> Handle -> IO ()

-- | Reads data from a stream. We define, that the first line of the
--   message is the message header which tells us how much bytes we have to
--   read.
getByteStringMessage :: Handle -> IO (ByteString)
instance Typeable SocketServerException
instance Show SocketServer
instance Show SocketServerException
instance Exception SocketServerException


-- | Version : 0.1
--   
--   The main module for the implementation of the distributed data
--   structures. It contains the DNode-datatype which is needed to register
--   new local and remote resources. The main datatypes (Ids, Handlers,
--   etc.) are also defined here.
--   
--   The module should only be used from within this library. User
--   applications should refer to Holumbus.Distribution.DNode.
module Holumbus.Distribution.DNode.Base

-- | The exception type, used by distributed communication
data DistributedException
DistributedException :: String -> String -> String -> DistributedException

-- | the message of the exception
distEx_msg :: DistributedException -> String

-- | the function in which the exception was thrown
distEx_fct :: DistributedException -> String

-- | the module in which the exception was thrown
distEx_mod :: DistributedException -> String

-- | The configuration of a DNode. You need it to create a DNode and you
--   can use this data type it to alter its properties. This type is public
--   to allow users to create their own configuration.
data DNodeConfig
DNodeConfig :: String -> Int -> Int -> Int -> Int -> DNodeConfig
dnc_Name :: DNodeConfig -> String
dnc_MinPort :: DNodeConfig -> Int
dnc_MaxPort :: DNodeConfig -> Int
dnc_AccessDelay :: DNodeConfig -> Int
dnc_PingDelay :: DNodeConfig -> Int

-- | A good default configuration. To create an unnamed node, just leave
--   the string empty.
defaultDNodeConfig :: String -> DNodeConfig

-- | The DNode identifier. Every DNode has an Id, this could be named or
--   randomly created. The id could not be used to address a DNode directly
--   over a Network connection because the physical references are missing.
--   The DNodeId is meant to create a declarative reference which could be
--   used to lookup purposes. Think of the DNodeId as a domain name,
--   without a DNS-Server to resolve the physical address, it is worthless
--   to establish a communication.
data DNodeId

-- | Use this to make a new DNodeId from a String
mkDNodeId :: String -> DNodeId

-- | The DNode address.
data DNodeAddress

-- | use this to make a new DNodeAddress
mkDNodeAddress :: String -> HostName -> Int -> DNodeAddress

-- | The Id of a handler, is needed to stop the handler from further
--   execution.
data DHandlerId

-- | The ressouce type, it is used to separate between different kinds of
--   resources. The resource type is generated by the programmer of a
--   resource
data DResourceType
mkDResourceType :: String -> DResourceType

-- | The DResource Id.
data DResourceId

-- | The DResource address
data DResourceAddress
mkDResourceAddress :: DResourceType -> String -> String -> DResourceAddress

-- | The DResource callback functions
type DResourceDispatcher = DNodeId -> Handle -> IO ()

-- | The container for the DResources
data DResourceEntry
DResourceEntry :: DResourceDispatcher -> DResourceEntry
dre_Dispatcher :: DResourceEntry -> DResourceDispatcher

-- | Initializes the DNode of the program. You have to call this function
--   once BEFORE you can use other functions.
initDNode :: DNodeConfig -> IO DNodeId

-- | deinitializes a DNode
deinitDNode :: IO ()

-- | Add a foreign DNode to the list of known DNodes. Only DNodes in this
--   list could be reached by the local node.
addForeignDNode :: DNodeAddress -> IO ()

-- | removes a foreign DNode entry. You should clean up the foreign DNode
--   entries.
delForeignDNode :: DNodeId -> IO ()

-- | Manually Checks, if another DNode is reachable. Returns true if this
--   is the case, otherwise false. Always returns, does not throw an
--   exception caused by network failures.
checkForeignDNode :: DNodeId -> IO (Bool)

-- | Adds a handler function which periodically checks the existences (or
--   non-existence) of other DNodes. The first parameter indicates the type
--   of the handler. If you want to install a handler which is fired when a
--   Node becomes reachable (positive trigger), it needs to be true. If you
--   want to monitor the event when a specific node disappears, pass false.
addForeignDNodeHandler :: Bool -> DNodeId -> DHandlerFunction -> IO (Maybe DHandlerId)

-- | Adds a handler function which periodically checks the existences (or
--   non-existence) of resources on other DNodes. The first parameter
--   indicates the type of the handler. If you want to install a handler
--   which is fired when a Node becomes reachable (positive trigger), it
--   needs to be true. If you want to monitor the event when a specific
--   node disappears, pass false.
addForeignDResourceHandler :: Bool -> DResourceAddress -> DHandlerFunction -> IO (Maybe DHandlerId)

-- | Deletes a Handler from the system, will not be called anymore.
delForeignHandler :: DHandlerId -> IO ()
genLocalResourceAddress :: DResourceType -> String -> IO DResourceAddress
addLocalResource :: DResourceAddress -> DResourceEntry -> IO ()
delLocalResource :: DResourceAddress -> IO ()
delForeignResource :: DResourceAddress -> IO ()
safeAccessForeignResource :: DResourceAddress -> (Handle -> IO a) -> IO a
unsafeAccessForeignResource :: DResourceAddress -> (Handle -> IO a) -> IO a

-- | Reads data from a stream. We define, that the first line of the
--   message is the message header which tells us how much bytes we have to
--   read.
getByteStringMessage :: Handle -> IO (ByteString)

-- | Puts a bytestring to a handle. But to make the reading easier, we
--   write the length of the data as a message-header to the handle, too.
putByteStringMessage :: ByteString -> Handle -> IO ()
getDNodeData :: IO (DNodeData)
instance Typeable DistributedException
instance Show DNodeResponseMessage
instance Show DNodeRequest
instance Show DNodeRequestMessage
instance Show DNodeData
instance Show DResourceAddress
instance Eq DResourceAddress
instance Ord DResourceAddress
instance Show DResourceId
instance Eq DResourceId
instance Ord DResourceId
instance Show DResourceType
instance Eq DResourceType
instance Ord DResourceType
instance Eq DHandlerId
instance Ord DHandlerId
instance Show DNodeAddress
instance Eq DNodeAddress
instance Ord DNodeAddress
instance Show DNodeId
instance Eq DNodeId
instance Ord DNodeId
instance Show DNodeConfig
instance Show DId
instance Eq DId
instance Ord DId
instance Show DistributedException
instance Binary DNodeResponseMessage
instance Binary DNodeRequest
instance Binary DNodeRequestMessage
instance Show DResourceEntry
instance Binary DResourceAddress
instance Binary DResourceId
instance Binary DResourceType
instance Show DNodeEntry
instance Binary DNodeAddress
instance Binary DNodeId
instance Binary DId
instance Exception DistributedException


-- | Version : 0.1
--   
--   Public interface of the DNode datatype. See
--   Holumbus.Distribution.DNode.Base for further documentation.
module Holumbus.Distribution.DNode

-- | The exception type, used by distributed communication
data DistributedException
DistributedException :: String -> String -> String -> DistributedException

-- | the message of the exception
distEx_msg :: DistributedException -> String

-- | the function in which the exception was thrown
distEx_fct :: DistributedException -> String

-- | the module in which the exception was thrown
distEx_mod :: DistributedException -> String

-- | The configuration of a DNode. You need it to create a DNode and you
--   can use this data type it to alter its properties. This type is public
--   to allow users to create their own configuration.
data DNodeConfig
DNodeConfig :: String -> Int -> Int -> Int -> Int -> DNodeConfig
dnc_Name :: DNodeConfig -> String
dnc_MinPort :: DNodeConfig -> Int
dnc_MaxPort :: DNodeConfig -> Int
dnc_AccessDelay :: DNodeConfig -> Int
dnc_PingDelay :: DNodeConfig -> Int

-- | A good default configuration. To create an unnamed node, just leave
--   the string empty.
defaultDNodeConfig :: String -> DNodeConfig

-- | The DNode identifier. Every DNode has an Id, this could be named or
--   randomly created. The id could not be used to address a DNode directly
--   over a Network connection because the physical references are missing.
--   The DNodeId is meant to create a declarative reference which could be
--   used to lookup purposes. Think of the DNodeId as a domain name,
--   without a DNS-Server to resolve the physical address, it is worthless
--   to establish a communication.
data DNodeId

-- | Use this to make a new DNodeId from a String
mkDNodeId :: String -> DNodeId

-- | The DNode address.
data DNodeAddress

-- | use this to make a new DNodeAddress
mkDNodeAddress :: String -> HostName -> Int -> DNodeAddress

-- | The Id of a handler, is needed to stop the handler from further
--   execution.
data DHandlerId

-- | Initializes the DNode of the program. You have to call this function
--   once BEFORE you can use other functions.
initDNode :: DNodeConfig -> IO DNodeId

-- | deinitializes a DNode
deinitDNode :: IO ()

-- | Add a foreign DNode to the list of known DNodes. Only DNodes in this
--   list could be reached by the local node.
addForeignDNode :: DNodeAddress -> IO ()

-- | removes a foreign DNode entry. You should clean up the foreign DNode
--   entries.
delForeignDNode :: DNodeId -> IO ()

-- | Manually Checks, if another DNode is reachable. Returns true if this
--   is the case, otherwise false. Always returns, does not throw an
--   exception caused by network failures.
checkForeignDNode :: DNodeId -> IO (Bool)

-- | Adds a handler function which periodically checks the existences (or
--   non-existence) of other DNodes. The first parameter indicates the type
--   of the handler. If you want to install a handler which is fired when a
--   Node becomes reachable (positive trigger), it needs to be true. If you
--   want to monitor the event when a specific node disappears, pass false.
addForeignDNodeHandler :: Bool -> DNodeId -> DHandlerFunction -> IO (Maybe DHandlerId)

-- | Adds a handler function which periodically checks the existences (or
--   non-existence) of resources on other DNodes. The first parameter
--   indicates the type of the handler. If you want to install a handler
--   which is fired when a Node becomes reachable (positive trigger), it
--   needs to be true. If you want to monitor the event when a specific
--   node disappears, pass false.
addForeignDResourceHandler :: Bool -> DResourceAddress -> DHandlerFunction -> IO (Maybe DHandlerId)

-- | Deletes a Handler from the system, will not be called anymore.
delForeignHandler :: DHandlerId -> IO ()
getDNodeData :: IO (DNodeData)


-- | Version : 0.1
--   
--   This module offers a distributed channel datatype (DChan).
--   
--   It is similar to Control.Concurrent.Chan, except that you can use it
--   between multiple processes on different computers. You can access a
--   DChan (reading and writing) from your local process as well as from
--   another one.
module Holumbus.Distribution.DChan

-- | The DChan datatype. Notice that this datatype implements the
--   Data.Binary typeclass. That means that you can pass a DChan, so that
--   another computer can access the channel.
data DChan a

-- | Creates a new DChan on the local computer. The first parameter is the
--   name of the Channel which could be used in other processes to access
--   this stream. If you leave it empty, a random Id will be created.
newDChan :: (Binary a) => String -> IO (DChan a)

-- | Creates a reference to a DChan which was created in a different
--   process. The first parameter is the name of the resource and the
--   second one the name of the node.
newRemoteDChan :: String -> String -> IO (DChan a)

-- | Closes a DChan object, could not be used anymore after this call.
closeDChan :: (DChan a) -> IO ()

-- | Writes data to a DChan.
writeDChan :: (Binary a) => DChan a -> a -> IO ()

-- | Reads data from a DChan, blocks if DChan is empty.
readDChan :: (Binary a) => DChan a -> IO a

-- | Tries to read data from a DChan, if the DChan is empty, the function
--   return with Nothing.
tryReadDChan :: (Binary a) => DChan a -> IO (Maybe a)

-- | Reads data from a DChan. If the channel is empty, it waits for a given
--   time (in microseconds) an returns immediately when new data arrives,
--   otherwise it return Nothing.
tryWaitReadDChan :: (Binary a) => DChan a -> Int -> IO (Maybe a)

-- | Tests, if a DChan is empty.
isEmptyDChan :: DChan a -> IO Bool
instance Show DChanResponseMessage
instance Show DChanRequestMessage
instance Binary (DChan a)
instance Binary DChanResponseMessage
instance Binary DChanRequestMessage


-- | Version : 0.1
--   
--   This module offers distributed streams and ports.
--   
--   Because a DChan allows external read access, the idea came up to split
--   a DChan into two parts: a stream and a port. A stream only allows you
--   to read data from it. The read-access is limited to the local process
--   which created the stream. To send data to a stream, you need a port.
--   This can be used on forgein nodes to send data to your local stream.
module Holumbus.Distribution.DStreamPort
data DStream a
data DPort a

-- | Message Datatype. We are sending additional information, to do
--   debugging
data (Binary a) => StreamPortMessage a
StreamPortMessage :: !a -> !Maybe ByteString -> StreamPortMessage a

-- | the data
spm_Data :: StreamPortMessage a -> !a

-- | some generic data -- could be another port
spm_Generic :: StreamPortMessage a -> !Maybe ByteString

-- | Creates a new local stream.
newDStream :: (Binary a) => String -> IO (DStream a)

-- | Closes a stream.
closeDStream :: DStream a -> IO ()

-- | Tests, if a stream has no more data to read.
isEmptyDStream :: DStream a -> IO Bool

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will block until a new message arrives.
receive :: (Binary a) => DStream a -> IO a

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will block until a new message
--   arrives.
receiveMsg :: (Binary a) => DStream a -> IO (StreamPortMessage a)

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will immediately return with Nothing.
tryReceive :: (Binary a) => DStream a -> IO (Maybe a)

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will immediately return with
--   Nothing.
tryReceiveMsg :: (Binary a) => DStream a -> IO (Maybe (StreamPortMessage a))

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will wait for new messages until the time is up
--   and if no message has arrived, return with Nothing.
tryWaitReceive :: (Binary a) => DStream a -> Int -> IO (Maybe a)

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will wait for new messages until the
--   time is up and if no message has arrived, return with Nothing.
tryWaitReceiveMsg :: (Binary a) => DStream a -> Int -> IO (Maybe (StreamPortMessage a))

-- | Encapsulates a stream. A new stream is created, then some user-action
--   is done an after that the stream is closed.
withStream :: (Binary a) => (DStream a -> IO b) -> IO b

-- | Creates a new Port, which is bound to a stream.
newDPortFromStream :: DStream a -> IO (DPort a)

-- | Creates a new port from a streamname and its socketId. The first
--   parameter is the name of the resource and the second one the name of
--   the node.
newDPort :: String -> String -> IO (DPort a)

-- | Send data to the stream of the port. The data is send via network, if
--   the stream is located on an external processor
send :: (Binary a) => DPort a -> a -> IO ()

-- | Like <a>send</a>, but here we can give some generic data (e.g. a port
--   for reply messages).
sendWithGeneric :: (Binary a) => DPort a -> a -> ByteString -> IO ()

-- | Like <a>sendWithGeneric</a>, but the generic data is optional
sendWithMaybeGeneric :: (Binary a) => DPort a -> a -> Maybe ByteString -> IO ()
instance (Binary a) => Binary (DPort a)
instance (Binary a) => Binary (StreamPortMessage a)


-- | Version : 0.1
--   
--   This module offers distributed functions.
--   
--   This idea behind this is to implement RPC based on DNodes. You specify
--   a function which could be called from other programs and register this
--   as a resource in your local DNode. Then the foreign DNodes can create
--   a link to this function an execute it. The function parameters will be
--   serialized and send to the local DNode. There the parameters are
--   deserialized and the function will be called. After this the
--   return-value will be send back to the calling node.
module Holumbus.Distribution.DFunction

-- | The DFunction datatype. This is more like a reference to a function
--   located on a different node. You can call this function via the
--   accessDFunction function.
data DFunction a

-- | Binary function typeclass. You can only use functions whose parameters
--   and return value are serializable. The idea of this typeclass comes
--   from the haxr library by Bjorn Bringert
--   (http:<i></i>www.haskell.org<i>haskellwiki</i>HaXR)
class BinaryFunction a

-- | Creates a new distributed function. Only functions which are
--   registered at the local node can be called from the outside. The
--   string parameter specifies the name of the function which could the
--   used by other nodes to call it. If you leave it empty, a random name
--   will be generated.
newDFunction :: (BinaryFunction a) => String -> a -> IO (DFunction a)

-- | Created a reference to a function on a remote node. The first
--   parameter is the name of the function, the second parameter is the
--   name of the node.
newRemoteDFunction :: (BinaryFunction a) => String -> String -> IO (DFunction a)

-- | Closes a DFunction reference.
closeDFunction :: DFunction a -> IO ()

-- | Transforms a DFunction object to a normal function which could be
--   called and passed around. Because you have network tranfer everytime
--   you call the function, this might throw a DistributedException when
--   the foreign node becomes unreachable.
accessDFunction :: (BinaryFunction a) => DFunction a -> a
instance Show DFunctionRequestMessage
instance Binary (DFunction a)
instance Binary DFunctionResponseMessage
instance Binary DFunctionRequestMessage
instance (Binary a, BinaryFunction b) => BinaryFunction (a -> b)
instance (Binary a) => BinaryFunction (IO a)


-- | Version : 0.1
--   
--   This module offers the distributed MVar datatype.
--   
--   The datatype behaves just like a normal MVar, but the content of the
--   variable may be stored on a different DNode. When accessing the DMVar,
--   the content will be fetched from the external node and written back.
--   
--   It is guaranteed, that only one node at a time can take the content of
--   the DMVar. Just like normal DMVars, you can produce deadlocks.
--   
--   When a node dies which holds the content of a DMVar, the node which
--   created the variable will reset its value to the last known value.
--   
--   If the owner dies, the other nodes cannot access the content of the
--   DMVar any more.
module Holumbus.Distribution.DMVar

-- | The DMVar datatype.
data DMVar a

-- | Creates a new local DMVar with a start value. The string parameter
--   specifies the name of the variable. If you leave it empty, a random
--   value will be generated.
newDMVar :: (Binary a) => String -> a -> IO (DMVar a)

-- | Creates a new empty local DMVar. The string parameter specifies the
--   name of the variable. If you leave it empty, a random value will be
--   generated.
newEmptyDMVar :: (Binary a) => String -> IO (DMVar a)

-- | Creates a reference to an external DMVar. The first parameter is the
--   name of the resource and the second one the name of the node.
newRemoteDMVar :: String -> String -> IO (DMVar a)

-- | Closes a DMVar
closeDMVar :: (DMVar a) -> IO ()

-- | Reads the content of a DMVar. Blocks if the Variable is empty. This
--   may throw an exception if the owner of the variable is unreachable.
readDMVar :: (Binary a) => DMVar a -> IO a

-- | Takes the content of a DMVar. Blocks if the Variable is empty. This
--   may throw an exception if the owner of the variable is unreachable.
takeDMVar :: (Binary a) => DMVar a -> IO a

-- | Writes a value to the DMvar. Blocks if the Variable is not empty. This
--   may throw an exception if the owner of the variable is unreachable.
putDMVar :: (Binary a) => DMVar a -> a -> IO ()
instance Show DMVarResponseMessage
instance Show DMVarRequestMessage
instance Binary (DMVar a)
instance Binary DMVarResponseMessage
instance Binary DMVarRequestMessage


-- | Version : 0.1
--   
--   This module offers the distrubted value datatype.
--   
--   A DValue is like a distributed MVar, but is can only be set once on
--   the local node. If the value is set, it cannot be changed any more.
--   
--   I don't know if this is useful at all, so the implementation is not
--   quite finished an some things could be improved.
module Holumbus.Distribution.DValue
data DValue a

-- | Creates new DValue on the local DNode. The first parameter is the name
--   of the value which could be used in other processes to access this
--   stream. If you leave it empty, a random Id will be created.
newDValue :: (Binary a) => String -> a -> IO (DValue a)

-- | Creates a new DValue. The first parameter is the name of the resource
--   and the second one the name of the node.
newRemoteDValue :: String -> String -> IO (DValue a)

-- | Closes a DValue.
closeDValue :: (DValue a) -> IO ()

-- | Gets value. It will only access the network on the first time and my
--   throw an exception. It returns always (Just a) but this may change in
--   the future, so the type sticks to (Maybe a)
getDValue :: (Binary a) => DValue a -> IO (Maybe a)


-- | Version : 0.1
--   
--   This module provides a tiny and nice implementation of a little
--   command shell. It can be feed with individual commands and provides a
--   simple but powerful way to interact with your program. The following
--   functions are implemented by default: exit - exit the console loop
--   help - print a nice help
--   
--   There was a little <a>bug</a> with the System.Console.Readline
--   package. When we use this option, we make a foreign call... and the
--   Haskell library documentation say this about concurrency and GHC:
--   
--   <a>If you don't use the -threaded option, then the runtime does not
--   make use of multiple OS threads. Foreign calls will block all other
--   running Haskell threads until the call returns. The System.IO library
--   still does multiplexing, so there can be multiple threads doing IO,
--   and this is handled internally by the runtime using select.</a>
--   
--   We make a foreign call, which is not in the System.IO library, so we
--   have to work with -threaded when we want a fancy command history.
module Holumbus.Console.Console

-- | Map which contains all commands that the user can execute
type ConsoleData a = Map String (ConsoleCommand a)

-- | gets the next option from the command line as string
nextOption :: [String] -> IO (Maybe String, [String])

-- | Simple <a>parser</a> for the commandline...
parseOption :: (Read a) => [String] -> IO (Maybe a, [String])

-- | Creates a new console datatype
initializeConsole :: ConsoleData a

-- | Adds a new console command to the function, an existing command with
--   the same name will be overwritten
addConsoleCommand :: String -> ConsoleFunction a -> String -> ConsoleData a -> ConsoleData a

-- | The main loop. You know... read stdin, parse the input, execute
--   command. You can quit it by the exit-command.
handleUserInput :: ConsoleData a -> a -> IO ()


-- | Version : 0.1
--   
--   This module provides a tiny and nice implementation of a little
--   command shell with communcation over a socket.
--   
--   It is basically a copy of Holumbus.Console.Console with some changes
--   to fit network communication.
module Holumbus.Console.ServerConsole

-- | Map which contains all commands that the user can execute
type ConsoleData a = Map String (ConsoleCommand a)

-- | gets the next option from the command line as string
nextOption :: [String] -> IO (Maybe String, [String])

-- | Simple <a>parser</a> for the commandline...
parseOption :: (Read a) => [String] -> IO (Maybe a, [String])

-- | Creates a new console datatype
initializeConsole :: ConsoleData a

-- | Adds a new console command to the function, an existing command with
--   the same name will be overwritten
addConsoleCommand :: String -> ConsoleFunction a -> String -> ConsoleData a -> ConsoleData a

-- | Starts the server listening
startServerConsole :: ConsoleData a -> a -> Int -> String -> IO ()

-- | This defaultimplementaion can be used if a simple INput -&gt; Process
--   command -&gt; output patern is used
defaultaction :: ConsoleData a -> a -> String -> ServerAction String

-- | default string to a converter. Converts the input lines into desired
--   format. Here String
defaultconverter :: LineConverter String


-- | Version : 0.1
--   
--   The Server-Module for the Holumbus framework.
--   
--   It contains the lowlevel functions, like the socket handling (opening,
--   reading, writing, ...).
module Holumbus.Network.Core

-- | All data, that is needed to address a socket. Contains the hostname
--   and the portNumber.
data SocketId
SocketId :: HostName -> PortNumber -> SocketId

-- | Creates a new (unix-)socket and starts the listener in its own thread.
--   You'll get the threadId of the listener Thread, so you can kill it. It
--   is also possible to give a range of PortNumbers on which the socket
--   will be opened. The first portnumber available will be taken.
startSocket :: ServerDispatcher -> PortNumber -> PortNumber -> IO (Maybe (ThreadId, HostName, PortNumber))

-- | Send the query to a server and merge the result with the global
--   result.
sendRequest :: (Handle -> IO a) -> HostName -> PortNumber -> IO a
performUnsafeSendRequest :: (Handle -> IO a) -> HostName -> PortNumber -> IO a
performSafeSendRequest :: (Handle -> IO a) -> a -> HostName -> PortNumber -> IO a
performMaybeSendRequest :: (Handle -> IO a) -> HostName -> PortNumber -> IO (Maybe a)

-- | Puts a bytestring to a handle. But to make the reading easier, we
--   write the length of the data as a message-header to the handle, too.
putMessage :: ByteString -> Handle -> IO ()

-- | Reads data from a stream. We define, that the first line of the
--   message is the message header which tells us how much bytes we have to
--   read.
getMessage :: Handle -> IO (ByteString)
data ThreadIdException
ThreadIdException :: ThreadId -> ThreadIdException
instance Typeable ThreadIdException
instance Show SocketId
instance Eq SocketId
instance Show ThreadIdException
instance XmlPickler SocketId
instance Binary SocketId
instance Exception ThreadIdException


-- | Version : 0.1
--   
--   The typeclass for the PortRegistry. Contains all PortRegistry
--   functions which can accessed remotely by the clients.
module Holumbus.Network.PortRegistry

-- | The Interface of the PortRegistry.
class PortRegistry pr
registerPort :: (PortRegistry pr) => String -> SocketId -> pr -> IO ()
unregisterPort :: (PortRegistry pr) => String -> pr -> IO ()
lookupPort :: (PortRegistry pr) => String -> pr -> IO (Maybe SocketId)
getPorts :: (PortRegistry pr) => pr -> IO [(String, SocketId)]

-- | The generic registry object. This is a wrapper around an
--   PortRegistryData or PortRegistryPort object. With this additional
--   indirection, we eliminate the distinction between the port or the data
--   object in the datatypes using the PortRegistry. Therefore it is easier
--   to get access to the registry and the code gets more readable. This
--   might be a good example of hiding network-access. To the caller it
--   makes no difference, if the PortRegistry is in the same address space
--   of on another computer in the network.
data GenericRegistry

-- | Creates a new generic PortRegistry.
mkGenericRegistry :: (PortRegistry r) => r -> GenericRegistry
instance PortRegistry GenericRegistry


-- | Version : 0.1
--   
--   Just a little Id to help us to decide if two thread are running in the
--   same program or just on the same machine or on differen machines.
module Holumbus.Network.Site

-- | The datatype of the SiteId, it contains the hostname and a processid,
--   so it is possible to decide if two site ids belong to the same process
--   or the the same computer or are on distinct computers.
data SiteId

-- | Just a little Map to hold the SiteIds an to get the neighbout Ids.
type SiteMap = Map HostName (Set SiteId)

-- | Gets the SiteId for the calling program.
getSiteId :: IO (SiteId)

-- | Extracts the Hostname from the SiteId.
getSiteHost :: SiteId -> HostName

-- | Extracts the ProcessID from the SiteId.
getSiteProcess :: SiteId -> ProcessID

-- | Test, if the two Ids are located on the same host.
isSameHost :: SiteId -> SiteId -> Bool

-- | Test, if the two Ids are located on the same host an in the same
--   process.
isSameProcess :: SiteId -> SiteId -> Bool

-- | Gets the nearest item from an Id-list compared to a given Id.
nearestId :: SiteId -> [SiteId] -> Maybe SiteId

-- | Empty SiteId-Map.
emptySiteMap :: SiteMap

-- | Adds an id to the map.
addIdToMap :: SiteId -> SiteMap -> SiteMap

-- | Deletes an id from the map.
deleteIdFromMap :: SiteId -> SiteMap -> SiteMap

-- | Delete a hostname an all its ids from the map.
deleteHostFromMap :: HostName -> SiteMap -> SiteMap

-- | Test, if the site id is already in the list.
isSiteIdMember :: SiteId -> SiteMap -> Bool

-- | Gets all ids which are on the same host, but not the original siteid
--   itself.
getNeighbourSiteIds :: SiteId -> SiteMap -> Set SiteId
instance Show SiteId
instance Eq SiteId
instance Ord SiteId
instance XmlPickler SiteId
instance Binary SiteId


-- | Version : 0.1
--   
--   Operations to start and stop threads which will not be killed when a
--   regular exception occurs. In this case, the thread will continue
--   working. Such a thread can only be killed by the stop-method. This
--   whole thing is a wrapper around the normal lightweight thread
--   functions.
--   
--   The created threads execute a function in an infinite loop. This is
--   the normal usecase for message dispatcher threads.
module Holumbus.Common.Threading

-- | The thread datatype
type Thread = MVar ThreadData

-- | Creates a new thread object. The thread will not be running.
newThread :: IO Thread

-- | Sets the delay between two loop cycles. Default value: no delay.
setThreadDelay :: Int -> Thread -> IO ()

-- | Sets the action function, which will be executed in each cycle
setThreadAction :: (IO ()) -> Thread -> IO ()

-- | Sets the error handler. It is activated, when the action function will
--   raise an exception.
setThreadErrorHandler :: (IO ()) -> Thread -> IO ()

-- | Starts the thread.
startThread :: Thread -> IO ()

-- | Stops the thread. If the thread itself wants to stop from within the
--   action function, the current cycle will be executed till the end. So
--   statements after this function will still be executed.
stopThread :: Thread -> IO ()


-- | Version : 0.1
--   
--   A typeclass for printing debug output.
module Holumbus.Common.Debug
class Debug m
printDebug :: (Debug m) => m -> IO ()
getDebug :: (Debug m) => m -> IO String


-- | Version : 0.1
--   
--   This module provides a MultiMap, that means a Map, which can hold
--   multiple values for one key, but every distinct value is only stores
--   once. So adding the same key-value-pair twice will only create one new
--   entry in the map.
--   
--   This Map is helpfull to examine how many different key-values-pairs
--   you have in your application.
--   
--   Most of the functions are borrowed from Data.Map
module Holumbus.Data.MultiMap

-- | A MultiMap, it can hold more (different!!!) Elements for one key.
data MultiMap k a

-- | The empty MultiMap.
empty :: (Ord k, Ord a) => MultiMap k a

-- | Test, if the MultiMap is empty.
null :: (Ord k, Ord a) => MultiMap k a -> Bool

-- | Inserts an element in the MultiMap.
insert :: (Ord k, Ord a) => k -> a -> MultiMap k a -> MultiMap k a

-- | Inserts multiple elements in a set to the MultiMap.
insertSet :: (Ord k, Ord a) => k -> Set a -> MultiMap k a -> MultiMap k a

-- | Inserts multiple keys with the same values.
insertKeys :: (Ord k, Ord a) => [k] -> Set a -> MultiMap k a -> MultiMap k a

-- | Gets all different elements for one key or an empty set.
lookup :: (Ord k, Ord a) => k -> MultiMap k a -> Set a

-- | Get all different keys from the map.
keys :: (Ord k, Ord a) => MultiMap k a -> Set k

-- | Get all different values in the map without regarding their keys.
elems :: (Ord k, Ord a) => MultiMap k a -> Set a

-- | Like lookup keys, but an empty input list will give all elements back,
--   not the empty set.
filterElements :: (Ord k, Ord a) => [k] -> MultiMap k a -> Set a

-- | Test, if a key is in the Map.
member :: (Ord k, Ord a) => k -> MultiMap k a -> Bool

-- | Deletes an Element from the Map, if the data in Nothing, the whole key
--   is deleted.
delete :: (Ord k, Ord a) => k -> Maybe a -> MultiMap k a -> MultiMap k a

-- | Deletes a whole key from the map.
deleteKey :: (Ord k, Ord a) => k -> MultiMap k a -> MultiMap k a

-- | Deletes a single Element from the map.
deleteElem :: (Ord k, Ord a) => k -> a -> MultiMap k a -> MultiMap k a

-- | Deletes all Elements (*,a) (slow!!!).
deleteAllElems :: (Ord k, Ord a) => a -> MultiMap k a -> MultiMap k a

-- | Creates a MultiMap from a list of pairs (key,set value).
fromList :: (Ord k, Ord a) => [(k, Set a)] -> MultiMap k a

-- | Creates a MultiMap from a list of tuples.
fromTupleList :: (Ord k, Ord a) => [(k, a)] -> MultiMap k a

-- | Transforms a MultiMap to a list of pairs (key,set value).
toList :: (Ord k, Ord a) => MultiMap k a -> [(k, Set a)]

-- | The same as toList, but the keys are in ascending order.
toAscList :: (Ord k, Ord a) => MultiMap k a -> [(k, Set a)]
instance (Show k, Show a) => Show (MultiMap k a)
instance (Eq k, Eq a) => Eq (MultiMap k a)
instance (Ord k, Ord a) => Ord (MultiMap k a)


-- | Version : 0.1
--   
--   Stream and Port datatype for internal an external process
--   communication. Useful for communikation of distributed systems.
module Holumbus.Network.Port

-- | One second
time1 :: Int

-- | 10 seconds
time10 :: Int

-- | 30 seconds
time30 :: Int

-- | 60 seconds
time60 :: Int

-- | 120 seconds
time120 :: Int

-- | Wait how long it takes
timeIndefinitely :: Int

-- | All data, that is needed to address a socket. Contains the hostname
--   and the portNumber.
data SocketId
SocketId :: HostName -> PortNumber -> SocketId

-- | Message Type Is it an internal Message or does it come from an
--   external Node?
data MessageType

-- | Message Datatype. We are sending additional information, to do
--   debugging
data (Show a, Binary a) => Message a

-- | The name of a stream.
type StreamName = String

-- | The stream type, determines the accessibility of a stream
data StreamType
STGlobal :: StreamType
STLocal :: StreamType
STPrivate :: StreamType

-- | The stream datatype
data Stream a

-- | The port datatype.
data Port a
Port :: StreamName -> Maybe SocketId -> Port a

-- | the name of the destination stream
p_StreamName :: Port a -> StreamName
p_SocketId :: Port a -> Maybe SocketId

-- | Gets the type of a message.
getMessageType :: (Show a, Binary a) => Message a -> MessageType

-- | Gets the data of a message.
getMessageData :: (Show a, Binary a) => Message a -> a

-- | Gets the generic data (usually the return port) of a message.
getGenericData :: (Show a, Binary a) => Message a -> (Maybe ByteString)

-- | Sets the link to the PortRegistry in the stream controller
setPortRegistry :: (PortRegistry r) => r -> IO ()

-- | Creates a new global stream.
newGlobalStream :: (Show a, Binary a) => StreamName -> IO (Stream a)

-- | Creates a new local stream.
newLocalStream :: (Show a, Binary a) => Maybe StreamName -> IO (Stream a)

-- | Creates a new private stream.
newPrivateStream :: (Show a, Binary a) => Maybe StreamName -> IO (Stream a)

-- | General function for creating a new stream.
newStream :: (Show a, Binary a) => StreamType -> Maybe StreamName -> Maybe PortNumber -> IO (Stream a)

-- | Closes a stream.
closeStream :: (Show a, Binary a) => Stream a -> IO ()

-- | Test, if the stream contains new messages.
isEmptyStream :: Stream a -> IO Bool

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will block until a new message arrives.
readStream :: (Show a, Binary a) => Stream a -> IO a

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will block until a new message
--   arrives.
readStreamMsg :: (Show a, Binary a) => Stream a -> IO (Message a)

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will immediately return with Nothing.
tryReadStream :: (Show a, Binary a) => Stream a -> IO (Maybe a)

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will immediately return with
--   Nothing.
tryReadStreamMsg :: (Show a, Binary a) => Stream a -> IO (Maybe (Message a))

-- | Reads the data packet of the next message from a stream. If stream is
--   empty, this function will wait for new messages until the time is up
--   and if no message has arrived, return with Nothing.
tryWaitReadStream :: (Show a, Binary a) => Stream a -> Int -> IO (Maybe a)

-- | Reads the next message from a stream (data packet + message header).
--   If stream is empty, this function will wait for new messages until the
--   time is up and if no message has arrived, return with Nothing.
tryWaitReadStreamMsg :: (Show a, Binary a) => Stream a -> Int -> IO (Maybe (Message a))

-- | Encapsulates a stream. A new stream is created, then some user-action
--   is done an after that the stream is closed.
withStream :: (Show a, Binary a) => (Stream a -> IO b) -> IO b

-- | Creates a new Port, which is bound to a stream.
newPortFromStream :: Stream a -> IO (Port a)

-- | Creates a new port from a streamname and its socketId.
newPort :: StreamName -> Maybe SocketId -> IO (Port a)

-- | Creates a new port to a global stream, only its name is needed.
newGlobalPort :: StreamName -> IO (Port a)

-- | Test, if a port is local.
isPortLocal :: Port a -> IO Bool

-- | Send data to the stream of the port. The data is send via network, if
--   the stream is located on an external processor
send :: (Show a, Binary a) => Port a -> a -> IO ()

-- | Like <a>send</a>, but here we can give some generic data (e.g. a port
--   for reply messages).
sendWithGeneric :: (Show a, Binary a) => Port a -> a -> ByteString -> IO ()

-- | Like <a>sendWithGeneric</a>, but the generic data is optional
sendWithMaybeGeneric :: (Show a, Binary a) => Port a -> a -> Maybe ByteString -> IO ()

-- | Writes a port-description to a file. Quite useful fpr sharing ports
--   between programs
writePortToFile :: (Show a, Binary a) => Port a -> FilePath -> IO ()

-- | Reads a port-description from a file. Quite useful fpr sharing ports
--   between programs
readPortFromFile :: (Show a, Binary a) => FilePath -> IO (Port a)

-- | Prints the internal data of the stream controller to stdout, useful
--   for debugging.
printStreamController :: IO ()
instance Show StreamType
instance Eq StreamType
instance Ord StreamType
instance Show (Port a)
instance Eq (Port a)
instance (Show a, Binary a) => Show (Message a)
instance Show MessageType
instance Show StreamControllerData
instance (Show a, Binary a) => Show (Stream a)
instance (Show a, Binary a) => XmlPickler (Port a)
instance (Show a, Binary a) => Binary (Port a)
instance (Show a, Binary a) => Binary (Message a)
instance Binary MessageType


-- | Version : 0.1
--   
--   General functions for the transmission of messages over the
--   Holumbus-Ports. You don't need these functions, but they make your
--   life much easier.
--   
--   The mailbox concept doesn't deal with the request and response scheme
--   very well, but with this module, all the boring stuff is solved. The
--   function performPortAction will do everything for you. If you find it
--   boring to write a seperate listener-thread for every mailbox you want
--   to read from, you might look at the startRequestDispatcher and
--   stopRequestDispatcher functions.
module Holumbus.Network.Messages

-- | The typeclass for the response messages. We want to react if an error
--   message is received an this interface helps us to detect and create
--   such a message. The unknown message will be send back, if the server
--   doesn't understand our request.
class RspMsg m
isError :: (RspMsg m) => m -> Bool
getErrorMsg :: (RspMsg m) => m -> String
isUnknown :: (RspMsg m) => m -> Bool
mkErrorMsg :: (RspMsg m) => String -> m

-- | Sends a request to the server (stream) and handles the response and
--   all error cases. Very helpful when simulating a request response
--   scheme with the mailboxes.
performPortAction :: (Show a, Binary a, Show b, Binary b, RspMsg b) => Port a -> Stream b -> Int -> a -> (b -> IO (Maybe c)) -> IO c

-- | The server-side request dispatcher handles all incomming responses.
--   The dispatcher runs in its own thread and should not be killed by any
--   exceptions which will be raised in the handling process.
startRequestDispatcher :: (Binary a, Show a, Show b, Binary b, RspMsg b) => Thread -> Stream a -> (a -> Port b -> IO ()) -> IO ()

-- | Stops the request dispatcher.
stopRequestDispatcher :: Thread -> IO ()

-- | Execute a function and send its result to the specified port.
handleRequest :: (Show b, Binary b, RspMsg b) => Port b -> IO c -> (c -> b) -> IO ()
instance Typeable MessageException
instance Show MessageException
instance Exception MessageException


-- | Version : 0.1
--   
--   This module implements an abstract client server model. The clients
--   register at the server and check from time to time if the server still
--   exists. If not, the client searches for a new server. The server on
--   the other hand, keeps a list with all clients and checks, if each
--   client is reachable. If not, the client is deleted from the list.
--   
--   This abstract network model helps us to implement a basic distrubuted
--   system with a central server and many attached clients which get
--   little tasks from the server. Because this model alone would be very
--   unfunctional, the user is able to define his own functions which will
--   be handled by the server or the client.
module Holumbus.Network.Communication

-- | The name of a stream.
type StreamName = String

-- | All data, that is needed to address a socket. Contains the hostname
--   and the portNumber.
data SocketId
data PortNumber :: *

-- | 30 seconds
time30 :: Int

-- | 60 seconds
time60 :: Int

-- | Wait how long it takes
timeIndefinitely :: Int

-- | The type of the client id.
type IdType = Int
data ClientInfo
ClientInfo :: Int -> SiteId -> ClientPort -> Thread -> Int -> ClientInfo
ci_Id :: ClientInfo -> Int

-- | SiteId (Hostname,PID) of the client process
ci_Site :: ClientInfo -> SiteId

-- | the port of the client
ci_Port :: ClientInfo -> ClientPort

-- | the threadId of the ping-Process (needed to stop it)
ci_PingThreadId :: ClientInfo -> Thread
ci_LifeValue :: ClientInfo -> Int

-- | The server.
data Server

-- | Creates a new server.
newServer :: (Binary a, Binary b) => StreamName -> Maybe PortNumber -> (a -> IO (Maybe b)) -> Maybe RegistrationAction -> Maybe RegistrationAction -> IO Server

-- | Closes the server.
closeServer :: Server -> IO ()

-- | The ServerPort is only a wrapper for a Port-Datatype.
data ServerPort

-- | Creates a new ServerPort.
newServerPort :: StreamName -> Maybe SocketId -> IO ServerPort

-- | Sends a request from the client to the server an handles the response
--   or invokes a user-defined handler.
sendRequestToServer :: (Show a, Binary a, Binary b) => ServerPort -> Int -> a -> (b -> IO (Maybe c)) -> IO c

-- | Gets the ClientPort from a ClientId (on the Server).
getClientInfo :: IdType -> Server -> IO (Maybe ClientInfo)

-- | Gets a list with all registered clients (on the Server).
getAllClientInfos :: Server -> IO [ClientInfo]

-- | The request-functions a client has to implement.
class ClientClass c
pingClient :: (ClientClass c) => IdType -> c -> IO Bool
getClientId :: (ClientClass c) => c -> IO (Maybe IdType)
getServerPort :: (ClientClass c) => c -> IO (ServerPort)

-- | Client datatype.
data ClientData
ClientData :: Thread -> Thread -> Maybe IdType -> Int -> SiteId -> Stream ClientRequestMessage -> Port ClientRequestMessage -> ServerPort -> ClientData
cd_ServerThreadId :: ClientData -> Thread
cd_PingThreadId :: ClientData -> Thread
cd_Id :: ClientData -> Maybe IdType
cd_LifeValue :: ClientData -> Int
cd_SiteId :: ClientData -> SiteId
cd_OwnStream :: ClientData -> Stream ClientRequestMessage
cd_OwnPort :: ClientData -> Port ClientRequestMessage
cd_ServerPort :: ClientData -> ServerPort

-- | Only a wrapper around an MVar.
data Client
Client :: (MVar ClientData) -> Client

-- | Creates a new client, it needs the StreamName and optional the
--   SocketId of the server.
newClient :: (Binary a, Binary b) => StreamName -> Maybe SocketId -> (a -> IO (Maybe b)) -> IO Client

-- | Closes the client.
closeClient :: Client -> IO ()

-- | Just a wrapper around a port.
data ClientPort
ClientPort :: (Port ClientRequestMessage) -> ClientPort

-- | Sends a request from the server to the client an handles the response
--   or invokes a user-defined handler.
sendRequestToClient :: (Show a, Binary a, Binary b) => ClientPort -> Int -> a -> (b -> IO (Maybe c)) -> IO c
instance Show ClientPort
instance Eq ClientPort
instance Show ClientResponseMessage
instance Show ClientRequestMessage
instance Show ServerPort
instance Show ServerResponseMessage
instance Show ServerRequestMessage
instance ClientClass ClientPort
instance Binary ClientPort
instance Ord ClientPort
instance Debug Client
instance ClientClass Client
instance RspMsg ClientResponseMessage
instance Binary ClientResponseMessage
instance Binary ClientRequestMessage
instance ServerClass ServerPort
instance Binary ServerPort
instance Debug Server
instance ServerClass Server
instance Show ClientInfo
instance RspMsg ServerResponseMessage
instance Binary ServerResponseMessage
instance Binary ServerRequestMessage


-- | Version : 0.1
--   
--   This modules defines the messages from and to the PortRegistry.
module Holumbus.Network.PortRegistry.Messages

-- | The Stream for the messages TO the PortRegistry.
type PortRegistryRequestStream = Stream PortRegistryRequestMessage

-- | The Port for the messages TO the PortRegistry.
type PortRegistryRequestPort = Port PortRegistryRequestMessage

-- | The Stream for the messages FROM the PortRegistry.
type PortRegistryResponseStream = Stream PortRegistryResponseMessage

-- | The Port for the messages FROM the PortRegistry.
type PortRegistryResponsePort = Port PortRegistryResponseMessage

-- | The messages TO the PortRegistry.
data PortRegistryRequestMessage
PRReqRegister :: StreamName -> SocketId -> PortRegistryRequestMessage
PRReqUnregister :: StreamName -> PortRegistryRequestMessage
PRReqLookup :: StreamName -> PortRegistryRequestMessage
PRReqGetPorts :: PortRegistryRequestMessage
PRReqUnknown :: PortRegistryRequestMessage

-- | The messages FROM the PortRegistry.
data PortRegistryResponseMessage
PRRspSuccess :: PortRegistryResponseMessage
PRRspLookup :: (Maybe SocketId) -> PortRegistryResponseMessage
PRRspGetPorts :: [(String, SocketId)] -> PortRegistryResponseMessage
PRRspError :: String -> PortRegistryResponseMessage
PRRspUnknown :: PortRegistryResponseMessage
instance Show PortRegistryResponseMessage
instance Show PortRegistryRequestMessage
instance RspMsg PortRegistryResponseMessage
instance Binary PortRegistryResponseMessage
instance Binary PortRegistryRequestMessage


-- | Version : 0.1
--   
--   This module contains the main datatype for the PortRegistry.
module Holumbus.Network.PortRegistry.PortRegistryData

-- | The data needed by the PortRegistry
data PortRegistryData

-- | Creates a new PortRegistry.
newPortRegistryData :: StreamName -> Maybe PortNumber -> IO PortRegistryData

-- | Closes the PortRegistry with its streams and threads.
closePortRegistryData :: PortRegistryData -> IO ()

-- | Get the RequestPort of the PortRegistry. It can be used to give access
--   to the PortRegistry, eg. you can serialize this information and
--   transfer it over the network to grant access to the clients.
getPortRegistryRequestPort :: PortRegistryData -> IO PortRegistryRequestPort

-- | Sets the link to the PortRegistry in the stream controller
setPortRegistry :: (PortRegistry r) => r -> IO ()
instance PortRegistry PortRegistryData


-- | Version : 0.1
--   
--   This module contains the Interface for external access to the
--   PortRegistry.
module Holumbus.Network.PortRegistry.PortRegistryPort

-- | The datatype for the PortRegistry remote interface.
data PortRegistryPort

-- | Creates a new PortRegistryPort from a port-object.
newPortRegistryPort :: PortRegistryRequestPort -> PortRegistryPort

-- | Creates a new PortRegistryPort from the StreamName and SocketId.
newPortRegistryFromData :: StreamName -> SocketId -> IO PortRegistryPort

-- | Creates a new PortRegistryPort from a XML-File.
newPortRegistryFromXmlFile :: FilePath -> IO PortRegistryPort

-- | Sets the link to the PortRegistry in the stream controller
setPortRegistry :: (PortRegistry r) => r -> IO ()
instance Show PortRegistryPort
instance PortRegistry PortRegistryPort


-- | Version : 0.1
--   
--   The KeyMap is derived from the Data.Map type. The keys of the Map are
--   strings and the values can be arbitrary data objects. But you don't
--   have to specify the keys because every value-object is able to create
--   it's own key via the <a>Key</a> typeclass.
--   
--   From the functionality, the KeyMap stands between a set and a Map. If
--   you want to insert an element to the map, it behaves like a set. You
--   don't need an additionnal key and it makes no different if you insert
--   an object multiple times. If you want to access the objects in the
--   KeyMap, you can lookup them via the key, so in this case this
--   container behaves like an ordinary map.
--   
--   The functions for this container are named after the standard Map and
--   Set functions.
module Holumbus.Data.KeyMap

-- | The KeyMap datatype.
data KeyMap a

-- | Every element of this map has to implement a key-function. which gives
--   us the key of the element
class Key n
getKey :: (Key n) => n -> String

-- | The empty KeyMap.
empty :: KeyMap a

-- | Test, if the MultiMap is empty.
null :: (Key a) => KeyMap a -> Bool

-- | Inserts an element in the KeyMap.
insert :: (Key a) => a -> KeyMap a -> KeyMap a

-- | Gets all different elements for one key or an empty set.
lookup :: (Key a, Monad m) => String -> KeyMap a -> m a

-- | Get all different keys from the map.
keys :: (Key a) => KeyMap a -> [String]

-- | Get all different values in the map without regarding their keys.
elems :: (Key a) => KeyMap a -> [a]

-- | Test, if a key is in the KeyMap.
memberKey :: (Key a) => String -> KeyMap a -> Bool

-- | Test, if a data object is in the KeyMap.
memberElem :: (Key a) => a -> KeyMap a -> Bool

-- | Deletes a whole key from the KeyMap.
deleteKey :: (Key a) => String -> KeyMap a -> KeyMap a

-- | Deletes a single elemet from the KeyMap.
deleteElem :: (Key a) => a -> KeyMap a -> KeyMap a

-- | Creates a KeyMap from a list of keys.
fromList :: (Key a) => [a] -> KeyMap a

-- | Transforms a KeyMap to a list of keys.
toList :: (Key a) => KeyMap a -> [a]

-- | The same as toList, but the keys are in ascending order.
toAscList :: (Key a) => KeyMap a -> [a]
instance (Show a) => Show (KeyMap a)
instance (Eq a) => Eq (KeyMap a)
instance (Ord a) => Ord (KeyMap a)


-- | Version : 0.1
--   
--   A map of key-value-pairs. The values are hold in a list, so adding the
--   same key-value-pair twice to the map, will result in storing the value
--   twice. Even the sequence of adding the values will be saved.
--   
--   The name AccuMap is from accumulation map. You can use this map to
--   easily storing all you key-value-pairs. After that you can all
--   values-lists by key. Unlike the MultiMap, you don't lose the
--   information of identical values and their order of adding.
--   
--   Most functions are inspired by the Data.Map type.
module Holumbus.Data.AccuMap

-- | the AccuMap datatype
data AccuMap k a

-- | Creates an empty AccuMap.
empty :: (Ord k) => AccuMap k a

-- | Test, if AccuMap is empty.
null :: (Ord k) => AccuMap k a -> Bool

-- | Insert a key-value-pair to the AccuMap.
insert :: (Ord k) => k -> a -> AccuMap k a -> AccuMap k a

-- | Insert a key and a list of values to the AccuMap. Faster than adding
--   all pair one by one.
insertList :: (Ord k) => k -> [a] -> AccuMap k a -> AccuMap k a

-- | Get the list of values for one key. If the key doesn't exists, an
--   empty list is returned.
lookup :: (Ord k) => k -> AccuMap k a -> [a]

-- | Test, if the key is in the AccuMap.
member :: (Ord k, Eq a) => k -> AccuMap k a -> Bool

-- | Deletes a key and all its values from the AccuMap.
deleteKey :: (Ord k) => k -> AccuMap k a -> AccuMap k a

-- | Combines two AccuMaps, the ordering of the two maps is significant for
--   the order of the values-elements.
union :: (Ord k) => AccuMap k a -> AccuMap k a -> AccuMap k a

-- | Creates an AccuMap from a list.
fromList :: (Ord k) => [(k, [a])] -> AccuMap k a

-- | Creates an AccuMap from a tuple list.
fromTupleList :: (Ord k) => [(k, a)] -> AccuMap k a

-- | Transforms an AccuMap to a list.
toList :: (Ord k) => AccuMap k a -> [(k, [a])]
instance (Eq k, Eq a) => Eq (AccuMap k a)
instance (Ord k, Ord a) => Ord (AccuMap k a)
instance (Show k, Show a) => Show (AccuMap k a)
