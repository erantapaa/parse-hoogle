-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Processing HTTP Content-Type and Accept headers
--   
@package http-media
@version 0.6.2


-- | Defines the <a>RenderHeader</a> type class, with the
--   <a>renderHeader</a> method. <a>renderHeader</a> can be used to render
--   basic header values (acting as identity on <a>ByteString</a>s), but it
--   will also work on lists of quality values, which provides the
--   necessary interface for rendering the full possibilities of Accept
--   headers.
module Network.HTTP.Media.RenderHeader

-- | A class for header values, so they may be rendered to their
--   <a>ByteString</a> representation. Lists of header values and
--   quality-marked header values will render appropriately.
class RenderHeader h
renderHeader :: RenderHeader h => h -> ByteString
instance RenderHeader h => RenderHeader [h]
instance RenderHeader ByteString


-- | Defines the <a>Accept</a> type class, designed to unify types on the
--   matching functions in the Media module.
module Network.HTTP.Media.Accept

-- | Defines methods for a type whose values can be matched against each
--   other in terms of an HTTP Accept-* header.
--   
--   This allows functions to work on both the standard Accept header and
--   others such as Accept-Language that still may use quality values.
class Show a => Accept a where hasExtensionParameters _ = False
parseAccept :: Accept a => ByteString -> Maybe a
matches :: Accept a => a -> a -> Bool
moreSpecificThan :: Accept a => a -> a -> Bool
hasExtensionParameters :: Accept a => Proxy a -> Bool

-- | Evaluates to whichever argument is more specific. Left biased.
mostSpecific :: Accept a => a -> a -> a

-- | Serves the same purpose as the Proxy type in base, but redefined here
--   in a basic form for older versions of base that do not include it.
data Proxy a
Proxy :: Proxy a
instance Accept ByteString


-- | Defines the <a>Language</a> accept header with an <tt>Accept</tt>
--   instance for use in language negotiation.
module Network.HTTP.Media.Language

-- | Suitable for HTTP language-ranges as defined in <a>RFC2616</a>.
--   
--   Specifically:
--   
--   <pre>
--   language-range = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
--   </pre>
data Language

-- | Converts <a>Language</a> to a list of its language parts. The wildcard
--   produces an empty list.
toParts :: Language -> [CI ByteString]


-- | Defines the <a>MediaType</a> accept header with an <tt>Accept</tt>
--   instance for use in content-type negotiation.
module Network.HTTP.Media.MediaType

-- | An HTTP media type, consisting of the type, subtype, and parameters.
data MediaType

-- | <a>MediaType</a> parameters.
type Parameters = Map (CI ByteString) (CI ByteString)

-- | Builds a <a>MediaType</a> without parameters. Can produce an error if
--   either type is invalid.
(//) :: ByteString -> ByteString -> MediaType

-- | Adds a parameter to a <a>MediaType</a>. Can produce an error if either
--   string is invalid.
(/:) :: MediaType -> (ByteString, ByteString) -> MediaType

-- | Retrieves the main type of a <a>MediaType</a>.
mainType :: MediaType -> CI ByteString

-- | Retrieves the sub type of a <a>MediaType</a>.
subType :: MediaType -> CI ByteString

-- | Retrieves the parameters of a <a>MediaType</a>.
parameters :: MediaType -> Parameters

-- | Evaluates if a <a>MediaType</a> has a parameter of the given name.
(/?) :: MediaType -> ByteString -> Bool

-- | Retrieves a parameter from a <a>MediaType</a>.
(/.) :: MediaType -> ByteString -> Maybe (CI ByteString)


-- | A framework for parsing HTTP media type headers.
module Network.HTTP.Media

-- | An HTTP media type, consisting of the type, subtype, and parameters.
data MediaType

-- | Builds a <a>MediaType</a> without parameters. Can produce an error if
--   either type is invalid.
(//) :: ByteString -> ByteString -> MediaType

-- | Adds a parameter to a <a>MediaType</a>. Can produce an error if either
--   string is invalid.
(/:) :: MediaType -> (ByteString, ByteString) -> MediaType

-- | Retrieves the main type of a <a>MediaType</a>.
mainType :: MediaType -> CI ByteString

-- | Retrieves the sub type of a <a>MediaType</a>.
subType :: MediaType -> CI ByteString

-- | Retrieves the parameters of a <a>MediaType</a>.
parameters :: MediaType -> Parameters

-- | Evaluates if a <a>MediaType</a> has a parameter of the given name.
(/?) :: MediaType -> ByteString -> Bool

-- | Retrieves a parameter from a <a>MediaType</a>.
(/.) :: MediaType -> ByteString -> Maybe (CI ByteString)

-- | Suitable for HTTP language-ranges as defined in <a>RFC2616</a>.
--   
--   Specifically:
--   
--   <pre>
--   language-range = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
--   </pre>
data Language

-- | Converts <a>Language</a> to a list of its language parts. The wildcard
--   produces an empty list.
toParts :: Language -> [CI ByteString]

-- | Matches a list of server-side resource options against a
--   quality-marked list of client-side preferences. A result of
--   <a>Nothing</a> means that nothing matched (which should indicate a 406
--   error). If two or more results arise with the same quality level and
--   specificity, then the first one in the server list is chosen.
--   
--   The use of the <a>Accept</a> type class allows the application of
--   either <a>MediaType</a> for the standard Accept header or
--   <a>ByteString</a> for any other Accept header which can be marked with
--   a quality value.
--   
--   <pre>
--   matchAccept ["text/html", "application/json"] &lt;$&gt; getHeader
--   </pre>
--   
--   For more information on the matching process see RFC 2616, section
--   14.1-4.
matchAccept :: Accept a => [a] -> ByteString -> Maybe a

-- | The equivalent of <a>matchAccept</a> above, except the resulting
--   choice is mapped to another value. Convenient for specifying how to
--   translate the resource into each of its available formats.
--   
--   <pre>
--   getHeader &gt;&gt;= maybe render406Error renderResource . mapAccept
--       [ ("text" // "html",        asHtml)
--       , ("application" // "json", asJson)
--       ]
--   </pre>
mapAccept :: Accept a => [(a, b)] -> ByteString -> Maybe b

-- | A specialisation of <a>mapAccept</a> that only takes <a>MediaType</a>
--   as its input, to avoid ambiguous-type errors when using string literal
--   overloading.
--   
--   <pre>
--   getHeader &gt;&gt;= maybe render406Error renderResource . mapAcceptMedia
--       [ ("text/html",        asHtml)
--       , ("application/json", asJson)
--       ]
--   </pre>
mapAcceptMedia :: [(MediaType, b)] -> ByteString -> Maybe b

-- | A specialisation of <a>mapAccept</a> that only takes <a>Language</a>
--   as its input, to avoid ambiguous-type errors when using string literal
--   overloading.
--   
--   <pre>
--   getHeader &gt;&gt;= maybe render406Error renderResource . mapAcceptLanguage
--       [ ("text/html",        asHtml)
--       , ("application/json", asJson)
--       ]
--   </pre>
mapAcceptLanguage :: [(Language, b)] -> ByteString -> Maybe b

-- | A specialisation of <a>mapAccept</a> that only takes <a>ByteString</a>
--   as its input, to avoid ambiguous-type errors when using string literal
--   overloading.
--   
--   <pre>
--   getHeader &gt;&gt;= maybe render406Error encodeResourceWith . mapAcceptBytes
--       [ ("compress", compress)
--       , ("gzip",     gzip)
--       ]
--   </pre>
mapAcceptBytes :: [(ByteString, b)] -> ByteString -> Maybe b

-- | Matches a list of server-side parsing options against a the
--   client-side content value. A result of <a>Nothing</a> means that
--   nothing matched (which should indicate a 415 error).
--   
--   <pre>
--   matchContent ["application/json", "text/plain"] &lt;$&gt; getContentType
--   </pre>
--   
--   For more information on the matching process see RFC 2616, section
--   14.17.
matchContent :: Accept a => [a] -> ByteString -> Maybe a

-- | The equivalent of <a>matchContent</a> above, except the resulting
--   choice is mapped to another value.
--   
--   <pre>
--   getContentType &gt;&gt;= maybe send415Error readRequestBodyWith . mapContent
--       [ ("application" // "json", parseJson)
--       , ("text" // "plain",       parseText)
--       ]
--   </pre>
mapContent :: Accept a => [(a, b)] -> ByteString -> Maybe b

-- | A specialisation of <a>mapContent</a> that only takes <a>MediaType</a>
--   as its input, to avoid ambiguous-type errors when using string literal
--   overloading.
--   
--   <pre>
--   getContentType &gt;&gt;=
--       maybe send415Error readRequestBodyWith . mapContentMedia
--           [ ("application/json", parseJson)
--           , ("text/plain",       parseText)
--           ]
--   </pre>
mapContentMedia :: [(MediaType, b)] -> ByteString -> Maybe b

-- | A specialisation of <a>mapContent</a> that only takes <a>Language</a>
--   as its input, to avoid ambiguous-type errors when using string literal
--   overloading.
--   
--   <pre>
--   getContentType &gt;&gt;=
--       maybe send415Error readRequestBodyWith . mapContentLanguage
--           [ ("application/json", parseJson)
--           , ("text/plain",       parseText)
--           ]
--   </pre>
mapContentLanguage :: [(Language, b)] -> ByteString -> Maybe b

-- | Attaches a quality value to data.
data Quality a

-- | Parses a full Accept header into a list of quality-valued media types.
parseQuality :: Accept a => ByteString -> Maybe [Quality a]

-- | Matches a list of server-side resource options against a pre-parsed
--   quality-marked list of client-side preferences. A result of
--   <a>Nothing</a> means that nothing matched (which should indicate a 406
--   error). If two or more results arise with the same quality level and
--   specificity, then the first one in the server list is chosen.
--   
--   The use of the <a>Accept</a> type class allows the application of
--   either <a>MediaType</a> for the standard Accept header or
--   <a>ByteString</a> for any other Accept header which can be marked with
--   a quality value.
--   
--   <pre>
--   matchQuality ["text/html", "application/json"] &lt;$&gt; parseQuality header
--   </pre>
--   
--   For more information on the matching process see RFC 2616, section
--   14.1-4.
matchQuality :: Accept a => [a] -> [Quality a] -> Maybe a

-- | The equivalent of <a>matchQuality</a> above, except the resulting
--   choice is mapped to another value. Convenient for specifying how to
--   translate the resource into each of its available formats.
--   
--   <pre>
--   parseQuality header &gt;&gt;= maybe render406Error renderResource . mapQuality
--       [ ("text" // "html",        asHtml)
--       , ("application" // "json", asJson)
--       ]
--   </pre>
mapQuality :: Accept a => [(a, b)] -> [Quality a] -> Maybe b

-- | Defines methods for a type whose values can be matched against each
--   other in terms of an HTTP Accept-* header.
--   
--   This allows functions to work on both the standard Accept header and
--   others such as Accept-Language that still may use quality values.
class Show a => Accept a where hasExtensionParameters _ = False
parseAccept :: Accept a => ByteString -> Maybe a
matches :: Accept a => a -> a -> Bool
moreSpecificThan :: Accept a => a -> a -> Bool
hasExtensionParameters :: Accept a => Proxy a -> Bool

-- | A class for header values, so they may be rendered to their
--   <a>ByteString</a> representation. Lists of header values and
--   quality-marked header values will render appropriately.
class RenderHeader h
renderHeader :: RenderHeader h => h -> ByteString
