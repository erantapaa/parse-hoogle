-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient consistent hashing.
--   
--   An efficient implementation of consistent hashing. See the
--   documentation for <tt>Data.HashRing</tt> for more info.
@package hashring
@version 0.0.0


-- | An efficient implementation of consistent hashing, as described in
--   
--   <ul>
--   <li>David Karger et al., "<i>Consistent hashing and random trees:
--   distributed caching protocols for relieving hot spots on the World
--   Wide Web</i>", 29th Annual ACM Symposium on Theory,
--   <a>http://dl.acm.org/citation.cfm?id=258660</a></li>
--   </ul>
--   
--   In distributed computing applications, it's usually necessary route
--   messages to some group of N nodes in the network. Message locality,
--   wherein messages of the same kind are routed to the same node, is
--   often desirable. "Normal" hashing, where a message's node is
--   determined by some hash function modulo N, has the undesirable
--   property that adding or removing a node from the network causes the
--   key sets of all other nodes to change drastically. In contrast,
--   consistent hashing has the property that small changes to the size of
--   the node set cause only small changes to key sets of the nodes.
--   
--   This implementation is built on top of <a>IntMap</a> and <a>Set</a>.
--   It provides <i>O(1)</i> lookup functions as well as <i>O(min(log n,
--   R))</i> insertion and deletion functions, where <i>R</i> is the number
--   of replica nodes used in the ring (see <a>empty</a>).
--   
--   The key space of the ring is the full range of <a>Int</a> values. To
--   insert a node, we generate (<i>R &gt; 0</i>) keys by hashing the node
--   with <i>R</i> successive salts, and the node is referenced by those
--   keys in the ring. To get a node for a message, we hash the message to
--   an <a>Int</a> value <i>k</i> and find the smallest key <i>k'</i> in
--   the ring such that <i>k &lt;= k'</i>. The node is the value referenced
--   by <i>k'</i>. Higher values of <i>R</i> give a more even distribution
--   of keys to nodes but slow down insertions and deletions of nodes.
--   <i>R</i> is specified when constructing a <a>HashRing</a> with
--   <a>empty</a>, <a>singleton</a>, or <a>fromList</a> and retrievable
--   with <a>replicas</a>.
--   
--   The ability of <a>HashRing</a> to fairly distribute messages among
--   nodes relies on the implementations of <a>hashWithSalt</a> for the
--   message and node types. For example, the default implementation for
--   <a>ByteString</a> is non-uniform on short inputs, and so it's
--   unsuitable for use with <a>HashRing</a>. Reimplementing
--   <a>hashWithSalt</a> for your message and node types with a
--   cryptographic hash function (like MD5 or SHA1 from the
--   <tt>cryptohash</tt> package) will give better results.
module Data.HashRing

-- | The constructor for this data type is not exported. See <a>empty</a>,
--   <a>singleton</a>, or <a>fromList</a>.
--   
--   Note that <a>HashRing</a> is parameterized by the node type and not by
--   the message type. As made clear by the type signatures for <a>!</a>,
--   <a>find</a>, and <a>lookup</a>, any <a>Hashable</a> type can be used
--   as a message.
data HashRing a

-- | Construct an empty ring with a specific <i>R</i> value.
empty :: Int -> HashRing a

-- | Construct a single-node ring with a specific <i>R</i> value.
singleton :: (Ord a, Hashable a) => Int -> a -> HashRing a

-- | Get the node in the ring corresponding to a message, or error if the
--   ring is empty.
(!) :: Hashable b => HashRing a -> b -> a

-- | <tt>True</tt> if the ring is empty, <tt>False</tt> otherwise.
null :: HashRing a -> Bool

-- | Number of nodes in the ring.
size :: HashRing a -> Int

-- | Number of replica nodes (<i>R</i>) in the ring for each real node.
replicas :: HashRing a -> Int

-- | <tt>True</tt> if the node is in the ring, <tt>False</tt> otherwise.
member :: Ord a => a -> HashRing a -> Bool

-- | Get the node in the ring corresponding to a message, or
--   <tt>Nothing</tt> if the ring is empty.
lookup :: Hashable b => b -> HashRing a -> Maybe a

-- | Get the node in the ring corresponding to a message, or error if the
--   ring is empty.
find :: Hashable b => b -> HashRing a -> a

-- | Add a node to the ring.
insert :: (Ord a, Hashable a) => a -> HashRing a -> HashRing a

-- | Remove a node from the ring.
delete :: (Ord a, Hashable a) => a -> HashRing a -> HashRing a

-- | Construct a ring from an <i>R</i> value and a list of nodes.
fromList :: (Ord a, Hashable a) => Int -> [a] -> HashRing a

-- | Construct a list containing the nodes in the ring.
toList :: HashRing a -> [a]
instance Eq a => Eq (HashRing a)
instance (Read a, Ord a, Hashable a) => Read (HashRing a)
instance Show a => Show (HashRing a)
