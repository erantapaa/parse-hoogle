-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities used by other packages.
--   
@package toolshed
@version 0.15.0.1


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   <ul>
--   <li>Facilities testing of custom implementations of <a>Read</a> &amp;
--   <a>Show</a>.</li>
--   <li>CAVEAT: it doesn't actually do any IO.</li>
--   </ul>
module ToolShed.Test.ReversibleIO

-- | Checks that composing <a>read</a> &amp; <a>show</a> is equivalent to
--   the identity.
isReversible :: (Eq r, Read r, Show r) => r -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Facilities testing of custom
--   implementations of <a>Enum</a>.</li>
--   </ul>
module ToolShed.Test.ReversibleEnum

-- | Checks that composing <a>toEnum</a> &amp; <a>fromEnum</a> is
--   equivalent to the identity.
isReversible :: (Eq r, Enum r) => r -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Facilities testing of custom
--   implementations of <a>Enum</a>.</li>
--   </ul>
module ToolShed.Test.ReversibleBoundedEnum

-- | Checks that composing <a>pred</a> &amp; <a>succ</a> is equivalent to
--   the identity.
isReversible :: (Bounded r, Eq r, Enum r) => r -> Bool


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Implements <a>Arbitrary</a> for
--   <a>Set</a>.</li>
--   <li><i><tt>EXAMPLE</tt></i> <tt>Test.QuickCheck.sample
--   (Test.QuickCheck.arbitrary :: Test.QuickCheck.Gen.Gen (Data.Set.Set
--   Int))</tt></li>
--   </ul>
module ToolShed.Test.QuickCheck.Arbitrary.Set
instance (Ord k, Arbitrary k) => Arbitrary (Set k)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Implements <a>Arbitrary</a> for
--   <a>Map</a>.</li>
--   <li><i><tt>EXAMPLE</tt></i> <tt>Test.QuickCheck.sample
--   (Test.QuickCheck.arbitrary :: Test.QuickCheck.Gen.Gen (Data.Map.Map
--   Char Int))</tt></li>
--   </ul>
module ToolShed.Test.QuickCheck.Arbitrary.Map
instance (Ord k, Arbitrary k, Arbitrary v) => Arbitrary (Map k v)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
--   
--   Implements <a>Arbitrary</a> for <a>Array</a>, where the array-index is
--   required to be a <i>bounded enumerable</i> type.
--   
--   <ul>
--   <li><i><tt>EXAMPLE</tt></i> <tt>Test.QuickCheck.sample
--   (Test.QuickCheck.arbitrary :: Test.QuickCheck.Gen.Gen
--   (Data.Array.IArray.Array Data.Int.Int8 Int))</tt></li>
--   </ul>
module ToolShed.Test.QuickCheck.Arbitrary.ArrayElem
instance (Bounded i, Ix i, Enum i, Arbitrary e) => Arbitrary (Array i e)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Implements <a>Arbitrary</a> for
--   <a>Array</a>.</li>
--   <li><i><tt>EXAMPLE</tt></i> <tt>Test.QuickCheck.sample
--   (Test.QuickCheck.arbitrary :: Test.QuickCheck.Gen.Gen
--   (Data.Array.IArray.Array Char Int))</tt></li>
--   <li><i><tt>CAVEAT</tt></i> An array with arbitrary indices isn't very
--   useful.</li>
--   </ul>
module ToolShed.Test.QuickCheck.Arbitrary.Array
instance (Ix i, Enum i, Arbitrary i, Arbitrary e) => Arbitrary (Array i e)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Determines the CPU-time, required to
--   evaluate the specified pure expression.</li>
--   </ul>
module ToolShed.System.TimePure

-- | <ul>
--   <li>Time the specified pure expression, returning the required number
--   of CPU-seconds and the result, as a <tt>Pair</tt>.</li>
--   <li>CAVEAT: as a side-effect, the expression is <i>deep</i>
--   evaluated.</li>
--   </ul>
getCPUSeconds :: (Fractional seconds, NFData expression) => expression -> IO (seconds, expression)

-- | <ul>
--   <li>Print the time required by the specified pure expression.</li>
--   <li>CAVEAT: as a side-effect, the expression is <i>deep</i>
--   evaluated.</li>
--   </ul>
printCPUSeconds :: NFData expression => expression -> IO expression


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Determines the CPU-time, required to
--   evaluate the specified IO-action.</li>
--   </ul>
module ToolShed.System.TimeAction

-- | Time the specified IO-action, returning the required number of
--   CPU-seconds and the result, as a <tt>Pair</tt>.
getCPUSeconds :: Fractional seconds => IO result -> IO (seconds, result)

-- | Print the time required by the specified IO-action.
printCPUSeconds :: IO result -> IO result


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Utilities related to
--   random-numbers.</li>
--   </ul>
module ToolShed.System.Random

-- | Constructs an infinite list of independent random-generators.
randomGens :: RandomGen randomGen => randomGen -> [randomGen]

-- | <ul>
--   <li>Shuffles the specified finite list, using the <i>Fisher-Yates</i>
--   algorithm;
--   <a>http://en.wikipedia.org/wiki/Fisher-Yates_shuffle</a>.</li>
--   <li>The resulting list has the same length and constituents as the
--   original; only the order has changed.</li>
--   <li>The input list is traversed, but the items aren't evaluated.</li>
--   </ul>
shuffle :: RandomGen randomGen => randomGen -> [a] -> [a]

-- | <ul>
--   <li>Generate an infinite list of items, each independently randomly
--   selected from the specified finite list.</li>
--   <li>CAVEAT: because the selections are made non-destructively,
--   duplicates may be returned; cf. <a>shuffle</a>.</li>
--   </ul>
generateSelection :: RandomGen randomGen => randomGen -> [a] -> [a]

-- | <ul>
--   <li>Generate an infinite list of data, each independently selected
--   random instances of the specified <i>bounded</i> type.</li>
--   <li>E.g. <tt> (generateSelectionFromBounded <a>fmap</a>
--   System.Random.getStdGen) :: IO [Bool] </tt>.</li>
--   </ul>
generateSelectionFromBounded :: (RandomGen randomGen, Bounded a, Random a) => randomGen -> [a]

-- | Return a randomly selected element from the specified list.
select :: RandomGen randomGen => randomGen -> [a] -> a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> File-operations.</li>
--   </ul>
module ToolShed.System.File

-- | The ordered sequence of directories, searched for a file.
type SearchPath = [FilePath]

-- | A file-path, and the contents read from it.
type LocatedData a = (FilePath, a)

-- | <ul>
--   <li>When supplied with an <i>absolute</i> file-path, the
--   <i>search-path</i> is ignored and an exception is thrown if either the
--   file-path is invalid or the file doesn't exist.</li>
--   <li>If the specified file-name is <i>relative</i>, all matching
--   instances on the specified <i>search-path</i> are returned.</li>
--   <li>CAVEAT: doesn't perform file-globbing.</li>
--   </ul>
locate :: FilePath -> SearchPath -> IO [FilePath]

-- | Traverse the <i>search-path</i>, looking for matching instances of the
--   specified file-name, and either throw an exception, or return a pair
--   composed from the path to the first matching file, together with its
--   contents.
getFile :: FilePath -> SearchPath -> IO (LocatedData String)

-- | <ul>
--   <li>Returns the polymorphic data, read from the first matching file on
--   the <i>search-path</i>, along with the path from which it was
--   read.</li>
--   <li>Returns an error on failure to parse the contents of the first
--   matching file found on the <i>search-path</i>.</li>
--   </ul>
fromFile :: Read a => FilePath -> SearchPath -> IO (LocatedData a)

-- | Accessor.
getFilePath :: LocatedData a -> FilePath

-- | Accessor.
getData :: LocatedData a -> a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> A class to define the simple
--   interface, to which data which can self-validation, should
--   conform.</li>
--   </ul>
module ToolShed.SelfValidate

-- | The interface to which data which can self-validate should conform.
class SelfValidator v where isValid = null . getErrors
getErrors :: SelfValidator v => v -> [String]
isValid :: SelfValidator v => v -> Bool

-- | Returns the first error only (so only call on failure of
--   <a>isValid</a>), since subsequent tests may be based on invalid data.
getFirstError :: SelfValidator v => v -> String

-- | Extracts the failed tests from those specified.
extractErrors :: [(Bool, String)] -> [String]
instance (Ix index, SelfValidator element) => SelfValidator (Array index element)
instance SelfValidator v => SelfValidator (Map k v)
instance SelfValidator v => SelfValidator (Set v)
instance SelfValidator v => SelfValidator [v]
instance (SelfValidator a, SelfValidator b, SelfValidator c) => SelfValidator (a, b, c)
instance (SelfValidator a, SelfValidator b) => SelfValidator (a, b)
instance SelfValidator v => SelfValidator (Maybe v)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> A simple interface which data-types
--   with a default-value can implement.</li>
--   </ul>
module ToolShed.Defaultable

-- | An interface to which data which have a default-value can adhere.
class Defaultable a
defaultValue :: Defaultable a => a
instance (Defaultable a, Defaultable b, Defaultable c) => Defaultable (a, b, c)
instance (Defaultable a, Defaultable b) => Defaultable (a, b)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Defines a standard interface to which
--   various options-related data can conform.</li>
--   </ul>
module ToolShed.Options

-- | Similar to the class <a>RegexOptions</a>.
class Defaultable a => Options a
blankValue :: Options a => a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous operations on
--   triples.</li>
--   <li><i><tt>CAVEAT</tt></i> Import fully qualified, since some
--   identifiers clash with <a>Quadruple</a>.</li>
--   </ul>
module ToolShed.Data.Triple

-- | Extends the concept of <a>curry</a>.
curry3 :: ((a, b, c) -> result) -> a -> b -> c -> result

-- | Extends the concept of <a>uncurry</a>.
uncurry3 :: (a -> b -> c -> result) -> (a, b, c) -> result

-- | Access the first datum from the specified triple.
getFirst :: (a, b, c) -> a

-- | Access the second datum from the specified triple.
getSecond :: (a, b, c) -> b

-- | Access the third datum from the specified triple.
getThird :: (a, b, c) -> c


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous operations on
--   quadruples.</li>
--   <li><i><tt>CAVEAT</tt></i> Import fully qualified, since some
--   identifiers clash with <a>Triple</a>.</li>
--   </ul>
module ToolShed.Data.Quadruple

-- | Extends the concept of <a>curry</a>.
curry4 :: ((a, b, c, d) -> result) -> a -> b -> c -> d -> result

-- | Extends the concept of <a>uncurry</a>.
uncurry4 :: (a -> b -> c -> d -> result) -> (a, b, c, d) -> result

-- | Access the first datum from the specified quadruple.
getFirst :: (a, b, c, d) -> a

-- | Access the second datum from the specified quadruple.
getSecond :: (a, b, c, d) -> b

-- | Access the third datum from the specified quadruple.
getThird :: (a, b, c, d) -> c

-- | Access the fourth datum from the specified quadruple.
getFourth :: (a, b, c, d) -> d


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous operations on
--   Pairs.</li>
--   </ul>
module ToolShed.Data.Pair

-- | <ul>
--   <li>Apply the same transformation to both halves of a
--   <i>Pair</i>.</li>
--   <li>CAVEAT: even though the function may be polymorphic, the pair is
--   required to have identical types.</li>
--   </ul>
mirror :: (a -> b) -> (a, a) -> (b, b)


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i></li>
--   </ul>
module ToolShed.Data.List.Splits

-- | <ul>
--   <li>Create the set of all <a>Split</a>s, migrating left from the
--   specified location.</li>
--   <li>CAVEAT: <a>init</a> fails when <a>fst</a> has been reduced to
--   null.</li>
--   </ul>
splitsLeftFrom :: Int -> [a] -> [Split a]

-- | <ul>
--   <li>Create the set of all <a>Split</a>s, migrating right from the
--   specified location.</li>
--   <li>CAVEAT: pattern-match against <tt> : </tt> fails, when <a>snd</a>
--   has been reduced to <a>null</a>.</li>
--   </ul>
splitsRightFrom :: Int -> [a] -> [Split a]


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Run-length encoder and decoder.</li>
--   </ul>
module ToolShed.Data.List.Runlength

-- | Describes the number of consecutive equal items in a list.
type Code a = (Int, a)

-- | <i>Run-length</i> encodes the specified list.
encode :: Eq a => [a] -> [Code a]

-- | Performs <i>run-length</i> decoding to retrieve the original unencoded
--   list.
decode :: [Code a] -> [a]

-- | Accessor.
getLength :: Code a -> Int

-- | Accessor.
getDatum :: Code a -> a


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous polymorphic
--   list-operations.</li>
--   </ul>
module ToolShed.Data.List

-- | The length of the chunks into which a list is split.
type ChunkLength = Int

-- | The type of function required by <a>findConvergenceBy</a>,
--   <a>permutationsBy</a>.
type Matches a = a -> a -> Bool

-- | <ul>
--   <li>Splits a list into chunks of the specified length.</li>
--   <li>The last chunk will be shorter, if the chunk-length isn't an
--   aliquot part of the input list-length.</li>
--   <li>If the chunk-length is zero, the resulting list will be an
--   infinite sequence of null lists.</li>
--   <li>CAVEAT: a similar function is available in the module
--   <i>Data.List.Split</i>, though this one checks for <tt>(chunkLength
--   &lt; 0)</tt>.</li>
--   </ul>
chunk :: ChunkLength -> [a] -> [[a]]

-- | Remove the single indexed element from the list.
excise :: Int -> [a] -> [a]

-- | A convenient way to compose the <a>Matches</a>-function required by
--   <a>findConvergenceBy</a> &amp; <a>permutationsBy</a>.
equalityBy :: Eq b => (a -> b) -> Matches a

-- | A specific instance of <a>findConvergenceBy</a>.
findConvergence :: Eq a => [a] -> a

-- | Take the first element from the (potentially infinite) list, which
--   matches the subsequent element, according to the specified function.
findConvergenceBy :: Matches a -> [a] -> a

-- | Converts a list of <i>Pairs</i>, into a narrower list.
linearise :: [(a, a)] -> [a]

-- | A specific instance of <a>mergeBy</a>.
merge :: Ord a => [a] -> [a] -> [a]

-- | <ul>
--   <li>Merge two sorted lists, according to the specified order, to
--   product a single sorted list.</li>
--   <li>The merge-process is <i>stable</i>, in that where items from each
--   list are equal, they remain in the original order.</li>
--   <li>CAVEAT: duplicates are preserved.</li>
--   </ul>
mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]

-- | <ul>
--   <li>A strict version of <a>nub</a> with better time-complexity.</li>
--   <li>CAVEAT: the specified list must be finite, since the entire set is
--   constructed before streaming to a list.</li>
--   <li>CAVEAT: it sorts the output as a side-effect, &amp; consequently
--   it requires a type which implements <a>Ord</a>.</li>
--   </ul>
nub' :: Ord a => [a] -> [a]

-- | <ul>
--   <li>The list of all permutations, generated by selecting any one datum
--   from each sub-list in turn, from the specified list of lists.</li>
--   <li>A specific instance of <a>permutationsBy</a>, in which no
--   filtering of subsequent lists is performed after each item is
--   selected.</li>
--   <li>NB: differs from <a>permutations</a>, which selects items from a
--   single input list.</li>
--   </ul>
permutations :: [[a]] -> [[a]]

-- | <ul>
--   <li>The list of all permutations, generated by selecting any one datum
--   from each sub-list in turn, from the specified list of lists.</li>
--   <li>As each item is selected, the remaining lists are filtered
--   according to the specified <a>Matches</a>-function.</li>
--   <li>Thus <a>/=</a> could be used to select a different item from each
--   list.</li>
--   </ul>
permutationsBy :: Matches a -> [[a]] -> [[a]]

-- | <ul>
--   <li>Take until the specified predicate is satisfied; <i>including</i>
--   the item which satisfied it.</li>
--   <li>NB: <tt>takeWhile (not . test)</tt> would return one fewer
--   item.</li>
--   </ul>
takeUntil :: (a -> Bool) -> [a] -> [a]

-- | Show a list, delimited by the specified tokens.
showListWith :: (Show token, Show element) => (token, token, token) -> [element] -> ShowS


-- | <ul>
--   <li><i><tt>AUTHOR</tt></i> Dr. Alistair Ward</li>
--   <li><i><tt>DESCRIPTION</tt></i> Miscellaneous polymorphic operations
--   on <a>Foldable</a> types.</li>
--   </ul>
module ToolShed.Data.Foldable

-- | A specific instance of <a>gatherBy</a>.
gather :: (Foldable f, Ord a) => f a -> [[a]]

-- | <ul>
--   <li>Group equal (though not necessarily adjacent; cf. <a>groupBy</a>)
--   elements, according to the specified comparator.</li>
--   <li>The groups are returned in ascending order, whilst their elements
--   remain in their original order.</li>
--   </ul>
gatherBy :: (Foldable f, Ord b) => (a -> b) -> f a -> [[a]]

-- | Whether the specified collection contains any equal items.
hasDuplicates :: (Foldable f, Ord a) => f a -> Bool
