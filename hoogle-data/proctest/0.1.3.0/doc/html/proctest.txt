-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An IO library for testing interactive command line programs
--   
--   An IO library for testing interactive command line programs
--   
--   Proctest aims to simplify interacting with and testing terminal
--   programs, providing convenience functions for starting programs and
--   reading their output.
--   
--   All blocking operations support timeouts so that misbehaving programs
--   cannot block your test pipeline.
--   
--   Find more examples and contribute at
--   <a>https://github.com/nh2/proctest</a>.
@package proctest
@version 0.1.3.0


-- | An IO library for testing interactive command line programs.
--   
--   Read this first:
--   
--   <ul>
--   <li>Tests using Proctests need to be compiled with <tt>-threaded</tt>
--   for not blocking on process spawns.</li>
--   <li>Beware that the Haskell GC closes process <a>Handle</a>s after
--   their last use. If you don't want to be surprised by this, use
--   <a>hClose</a> where you want them to be closed (convenience:
--   <a>closeHandles</a>). Really do this for EVERY process you create, the
--   behaviour of a program writing to a closed handle is undefined. For
--   example, <a>getProcessExitCode</a> run on such a program somtimes
--   seems to always return <a>ExitSuccess</a>, no matter what the program
--   actually does.</li>
--   <li>Make sure handle buffering is set appropriately. <a>run</a> sets
--   <a>LineBuffering</a> by default. Change it with <a>setBuffering</a> or
--   <a>hSetBuffering</a>.</li>
--   <li>Do not run the program in a shell (e.g.
--   <a>runInteractiveCommand</a>) if you want to be able to terminate it
--   reliably (<a>terminateProcess</a>). Use processes without shells
--   (<a>runInteractiveProcess</a>) instead.</li>
--   </ul>
--   
--   Example:
--   
--   Let's say you want to test an interactive command line program like
--   <tt>cat</tt>, and integrate your test into a test framework like
--   <a>Test.HSpec</a>, using <a>Test.HSpec.HUnit</a> for the IO parts
--   (remember that Proctest <i>is</i> stateful IO).
--   
--   <pre>
--   main = hspec $ describe "cat" $ do
--   
--     it "prints out what we put in" $ do
--   
--       -- Start up the program to test
--       (hIn, hOut, hErr, p) &lt;- run "cat" []
--   
--       -- Make sure buffering doesn't prevent us from reading what we expect
--       -- ('run' sets LineBuffering by default)
--       setBuffering NoBuffering [hIn, hOut]
--   
--       -- Communicate with the program
--       hPutStrLn hIn "hello world"
--   
--       -- Define a convenient wrapper around 'waitOutput'.
--       --
--       -- It specifies how long we have to wait
--       -- (malfunctioning programs shall not block automated testing for too long)
--       -- and how many bytes we are sure the expected response fits into
--       -- (malfunctioning programs shall not flood us with garbage either).
--       let catWait h = asUtf8Str &lt;$&gt; waitOutput (seconds 0.01) 1000 h -- Wait max 10 ms, 1000 bytes
--   
--       -- Wait a little to allow `cat` processing the input
--       sleep (seconds 0.00001)
--   
--       -- Read the response
--       response &lt;- catWait hOut
--   
--       -- Test if it is what we want (here using HUnit's 'expectEqual')
--       response @?= "hello world\n"
--   </pre>
module Test.Proctest

-- | Treats a <a>ByteString</a> as UTF-8 decoded <a>Text</a>.
asUtf8 :: ByteString -> Text

-- | Treats a <a>ByteString</a> as UTF-8 decoded <a>String</a>.
asUtf8Str :: ByteString -> String

-- | Short cut. ALWAYS use the order stdin, stdout, stderr, process handle.
type ProcessHandles = (Handle, Handle, Handle, ProcessHandle)

-- | Runs a program with the given arguemtns.
--   
--   Returns <tt>(stdout, stderr, stdin, process)</tt>. See
--   <a>runInteractiveProcess</a>.
--   
--   Directly runs the process, does not use a shell.
--   
--   Sets the 'BufferMode to <a>LineBuffering</a> if successful.
--   
--   Throws <a>CommandNotFound</a> if the command doesn't exist. Due to
--   <a>createProcess</a> not throwing an exception
--   (<a>http://www.haskell.org/pipermail/haskell-cafe/2012-August/102824.html</a>),
--   this is currently implemented by checking if the program returns early
--   with error code 127.
run :: FilePath -> [String] -> IO (Handle, Handle, Handle, ProcessHandle)

-- | Exception to be thrown when a program could not be started.
data RunException
CommandNotFound :: String -> RunException

-- | Tells whether the given process is still running.
isRunning :: ProcessHandle -> IO Bool

-- | Terminates all processes in the list.
terminateProcesses :: [ProcessHandle] -> IO ()

-- | Closes all handles in the list.
closeHandles :: [Handle] -> IO ()

-- | Closes all file handles to all given handle-process-tuples.
--   
--   Use this to make sure that handles are not closed due to garbage
--   collection (see <a>System.IO</a>) while your processes are still
--   running.
--   
--   It is safe to call this on processes which have already exited.
closeProcessHandles :: [ProcessHandles] -> IO ()

-- | A microsecond timeout, or <a>NoTimeout</a>.
data Timeout
NoTimeout :: Timeout

-- | An error to be thrown if something is to be converted into
--   <a>Timeout</a> that does not fit into <a>Int</a>.
data InvalidTimeoutError

-- | Turns the given number of microseconds into a <a>Timeout</a>.
--   
--   Throws an exception on <a>Int</a> overflow.
mkTimeoutUs :: Integer -> Timeout

-- | Turns the given number of milliseconds into a <a>Timeout</a>.
--   
--   Throws an exception on <a>Int</a> overflow.
mkTimeoutMs :: Integral a => a -> Timeout

-- | Turns the given number of seconds into a <a>Timeout</a>.
--   
--   Throws an exception on <a>Int</a> overflow.
mkTimeoutS :: Integral a => a -> Timeout

-- | Turns floating seconds into a <a>Timeout</a>.
--   
--   Throws an exception on <a>Int</a> overflow.
--   
--   Example: <tt>(seconds 0.2)</tt> are roughly <tt>Micros 200000</tt>.
seconds :: Double -> Timeout

-- | Exception to be thrown when a program did not terminate within the
--   expected time.
data TimeoutException

-- | Converts a <a>Timeout</a> milliseconds suitable to be passed into
--   <tt>timeout</tt>.
timeoutToSystemTimeoutArg :: Timeout -> Int

-- | Overflow-safe version of <a>timeout</a>, using <a>Timeout</a>.
withTimeout :: Timeout -> IO a -> IO (Maybe a)

-- | Blocking wait for output on the given handle.
--   
--   Throws a <a>TimeoutException</a> if the timeout is exceeded.
--   
--   Based on <a>waitOutputNoEx</a>.
waitOutput :: Timeout -> Int -> Handle -> IO ByteString

-- | Blocking wait for output on the given handle.
--   
--   Returns <a>Nothing</a> timeout is exceeded.
waitOutputNoEx :: Timeout -> Int -> Handle -> IO (Maybe ByteString)

-- | Sets the buffering of the all given handles to the given
--   <a>BufferMode</a>.
setBuffering :: BufferMode -> [Handle] -> IO ()

-- | Suspends execution for the given timeout; uses <a>threadDelay</a>
--   internally. For <a>NoTimeout</a>, threadDelay will not be called.
sleep :: Timeout -> IO ()
instance Typeable RunException
instance Typeable InvalidTimeoutError
instance Typeable TimeoutException
instance Show RunException
instance Eq Timeout
instance Ord Timeout
instance Show Timeout
instance Show InvalidTimeoutError
instance Show TimeoutException
instance Exception TimeoutException
instance Exception InvalidTimeoutError
instance Exception RunException


-- | Helpers for asserting certain things for programs, using HUnit.
--   
--   All of the assertions in this module throw HUnit exceptions on failure
--   using <a>assertFailure</a>.
module Test.Proctest.Assertions

-- | Runs the given program with <a>run</a> and asserts that it is still
--   running after the given timeout.
--   
--   Don't choose the timeout too high as this function will block for it.
--   
--   If the timeout is exceeded, a HUnit <a>assertFailure</a> exception is
--   thrown, showing the command line to be invoked, the exit code, and the
--   standard error output of the program.
runAssert :: Timeout -> FilePath -> [String] -> IO (Handle, Handle, Handle, ProcessHandle)

-- | Asserts that the given process has shut down.
--   
--   You might need to <a>sleep</a> before to give the process time to
--   exit. It is usually better to use <a>assertExitedTimeout</a> in those
--   cases.
--   
--   If the process is still running, a HUnit <a>assertFailure</a>
--   exception is thrown.
assertExited :: ProcessHandle -> IO ()

-- | How often to poll in waiting functions with maximum timeout.
_PROCTEST_POLL_TIMEOUT :: Timeout

-- | Asserts that the given process has shut down in *at most* the given
--   timeout.
--   
--   Periodically polling with <a>_PROCTEST_POLL_TIMEOUT</a>, returns as
--   soon as the application has terminated or the timeout is exceeded.
--   
--   Use this to write faster tests than with manual <a>sleep</a>ing: For
--   most tests, the application will actually finish way before the
--   timeout.
--   
--   If the process is still running, a HUnit <a>assertFailure</a>
--   exception is thrown.
assertExitedTimeout :: Timeout -> ProcessHandle -> IO ExitCode
