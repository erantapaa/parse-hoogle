-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An extensible mysql effect using extensible-effects and mysql-simple
--   
--   Any help (especially documentation) is very welcome,
@package mysql-effect
@version 0.2.0.3


-- | A thin MySQL effect.
--   
--   See the documentation of 'mysql-simple' for details regarding the
--   various functions.
module Control.Eff.MySQL
type MySQL = Reader Connection

-- | See <a>query</a> for details.
query :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryResults a, QueryParams p) => Query -> p -> Eff r [a]

-- | See <a>query_</a> for details.
query_ :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryResults a) => Query -> Eff r [a]

-- | See <a>execute</a> for details.
execute :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryParams p) => Query -> p -> Eff r Int64

-- | See <a>execute_</a> for details.
execute_ :: (SetMember Lift (Lift IO) r, Member MySQL r) => Query -> Eff r Int64

-- | See <a>executeMany</a> for details.
executeMany :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryParams p) => Query -> [p] -> Eff r Int64

-- | See 'M.insertID ' for details.
insertID :: (SetMember Lift (Lift IO) r, Member MySQL r) => Eff r Word64

-- | See 'M.autocommit ' for details.
autocommit :: (SetMember Lift (Lift IO) r, Member MySQL r) => Bool -> Eff r ()

-- | See 'M.commit ' for details.
commit :: (SetMember Lift (Lift IO) r, Member MySQL r) => Eff r ()

-- | See 'M.rollback ' for details.
rollback :: (SetMember Lift (Lift IO) r, Member MySQL r) => Eff r ()

-- | See <a>formatMany</a> for details.
formatMany :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryParams p) => Query -> [p] -> Eff r ByteString

-- | See <a>formatQuery</a> for details.
formatQuery :: (SetMember Lift (Lift IO) r, Member MySQL r, QueryParams p) => Query -> p -> Eff r ByteString

-- | Run the MySQL effect. In case of exceptions it will not close the
--   connection. (That will still be done by the GC at one point.)
runMySQL :: SetMember Lift (Lift IO) r => Eff (MySQL :> r) a -> ConnectInfo -> Eff r a

-- | Run the MySQL effect with a given <a>Connection</a>.
runMySQLWithConnection :: Eff (MySQL :> r) a -> Connection -> Eff r a
data ConnectInfo :: *
ConnectInfo :: String -> Word16 -> String -> String -> String -> [Option] -> FilePath -> Maybe SSLInfo -> ConnectInfo
connectHost :: ConnectInfo -> String
connectPort :: ConnectInfo -> Word16
connectUser :: ConnectInfo -> String
connectPassword :: ConnectInfo -> String
connectDatabase :: ConnectInfo -> String
connectOptions :: ConnectInfo -> [Option]
connectPath :: ConnectInfo -> FilePath
connectSSL :: ConnectInfo -> Maybe SSLInfo

-- | Wrap a list of values for use in an <tt>IN</tt> clause. Replaces a
--   single "<tt>?</tt>" character with a parenthesized list of rendered
--   values.
--   
--   Example:
--   
--   <pre>
--   query c "select * from whatever where id in ?" (In [3,4,5])
--   </pre>
newtype In a :: * -> *
In :: a -> In a

-- | A single-value "collection".
--   
--   This is useful if you need to supply a single parameter to a SQL
--   query, or extract a single column from a SQL result.
--   
--   Parameter example:
--   
--   <pre>
--   query c "select x from scores where x &gt; ?" (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result example:
--   
--   <pre>
--   xs &lt;- query_ c "select id from users"
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a :: * -> *
Only :: a -> Only a
fromOnly :: Only a -> a

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.MySQL.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <a>ByteString</a>, and literal Haskell
--   strings that contain Unicode characters will be correctly transformed
--   to UTF-8.
data Query :: *

-- | A collection type that can be turned into a list of rendering
--   <a>Action</a>s.
--   
--   Instances should use the <a>render</a> method of the <a>Param</a>
--   class to perform conversion of each element of the collection.
class QueryParams a
renderParams :: QueryParams a => a -> [Action]

-- | A collection type that can be converted from a list of strings.
--   
--   Instances should use the <a>convert</a> method of the <a>Result</a>
--   class to perform conversion of each element of the collection.
--   
--   This example instance demonstrates how to convert a two-column row
--   into a Haskell pair. Each field in the metadata is paired up with each
--   value from the row, and the two are passed to <a>convert</a>.
--   
--   <pre>
--   instance (<a>Result</a> a, <a>Result</a> b) =&gt; <a>QueryResults</a> (a,b) where
--       <a>convertResults</a> [fa,fb] [va,vb] = (a,b)
--           where !a = <a>convert</a> fa va
--                 !b = <a>convert</a> fb vb
--       <a>convertResults</a> fs vs  = <a>convertError</a> fs vs 2
--   </pre>
--   
--   Notice that this instance evaluates each element to WHNF before
--   constructing the pair. By doing this, we guarantee two important
--   properties:
--   
--   <ul>
--   <li>Keep resource usage under control by preventing the construction
--   of potentially long-lived thunks.</li>
--   <li>Ensure that any <a>ResultError</a> that might arise is thrown
--   immediately, rather than some place later in application code that
--   cannot handle it.</li>
--   </ul>
--   
--   You can also declare Haskell types of your own to be instances of
--   <a>QueryResults</a>.
--   
--   <pre>
--   data User = User { firstName :: String, lastName :: String }
--   
--   instance <a>QueryResults</a> User where
--       <a>convertResults</a> [fa,fb] [va,vb] = User <a>$</a> a <a>*</a> b
--           where !a = <a>convert</a> fa va
--                 !b = <a>convert</a> fb vb
--       <a>convertResults</a> fs vs  = <a>convertError</a> fs vs 2
--   </pre>
class QueryResults a
convertResults :: QueryResults a => [Field] -> [Maybe ByteString] -> a

-- | Default information for setting up a connection.
--   
--   Defaults are as follows:
--   
--   <ul>
--   <li>Server on <tt>localhost</tt></li>
--   <li>User <tt>root</tt></li>
--   <li>No password</li>
--   <li>Database <tt>test</tt></li>
--   <li>Character set <tt>utf8</tt></li>
--   </ul>
--   
--   Use as in the following example:
--   
--   <pre>
--   connect defaultConnectInfo { connectHost = "db.example.com" }
--   </pre>
defaultConnectInfo :: ConnectInfo
