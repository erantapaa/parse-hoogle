-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cursor Library for A Structured Editor
--   
--   A library to aid the development of structured editors that require a
--   zipper-like interface to the language being edited.
@package CLASE
@version 2009.2.11

module Data.Cursor.CLASE.Gen.Adapters
adapterGen :: [String] -> Name -> [Name] -> String -> Q [Dec]

module Data.Cursor.CLASE.Gen.Persistence
persistenceGen :: [String] -> Name -> [Name] -> String -> Q [Dec]

module Data.Cursor.CLASE.Gen.Language
languageGen :: [String] -> Name -> [Name] -> Q [Dec]

module Data.Cursor.CLASE.Util
data Exists a
Exists :: a b -> Exists a
data TyEq a b
Eq :: TyEq a a
data Id a
Id :: a -> Id a
if' :: Bool -> a -> a -> a

module Data.Cursor.CLASE.Language
data Up
data Down
data DirectionT a
UpT :: DirectionT Up
DownT :: DirectionT Down
class Reify l a
reify :: Reify l a => a -> TypeRep l a
data ExistsR l r :: (* -> *)
ExistsR :: r a -> ExistsR l r
class Language l where { data family Context l :: * -> * -> *; data family Movement l :: * -> * -> * -> *; data family TypeRep l :: * -> *; }
buildOne :: Language l => Context l a b -> a -> b
unbuildOne :: Language l => Movement l Down a b -> a -> Maybe (Context l b a, b)
invertMovement :: Language l => Movement l d a b -> Movement l (Invert d) b a
movementEq :: Language l => Movement l d a b -> Movement l d a c -> Maybe (TyEq b c)
reifyDirection :: Language l => Movement l d a b -> DirectionT d
contextToMovement :: Language l => Context l a b -> Movement l Up a b
downMoves :: Language l => TypeRep l a -> [ExistsR l (Movement l Down a)]
moveLeft :: Language l => Movement l Down a x -> Maybe (ExistsR l (Movement l Down a))
moveRight :: Language l => Movement l Down a x -> Maybe (ExistsR l (Movement l Down a))
contextMovementEq :: Language l => Context l a b -> Movement l Up a c -> Maybe (TyEq b c)
data Path l r a b
Stop :: Path l r a a
Step :: r a b -> Path l r b c -> Path l r a c
foldPath :: (forall from to. Reify l to => r from to -> from -> to) -> start -> Path l r start finish -> finish
data Cursor l x a
Cursor :: a -> Path l (Context l) a l -> Route l a x -> Cursor l x a
it :: Cursor l x a -> a
ctx :: Cursor l x a -> Path l (Context l) a l
log :: Cursor l x a -> Route l a x
data CursorWithMovement l d x from
CWM :: Cursor l x to -> Movement l d from to -> CursorWithMovement l d x from
rebuild :: Language l => Cursor l x a -> l
applyMovement :: (Language l, Reify l a, Reify l b) => Movement l d a b -> Cursor l x a -> Maybe (Cursor l x b)
genericMoveUp :: Language l => Cursor l x a -> Maybe (CursorWithMovement l Up x a)
genericMoveDown :: Language l => Cursor l x a -> Maybe (CursorWithMovement l Down x a)
genericMoveLeft :: Language l => Cursor l x a -> Maybe (ExistsR l (Cursor l x))
genericMoveRight :: Language l => Cursor l x a -> Maybe (ExistsR l (Cursor l x))
genericMoveSideways :: Language l => (forall a z. Movement l Down a z -> Maybe (ExistsR l (Movement l Down a))) -> Cursor l x a -> Maybe (ExistsR l (Cursor l x))
moveToRoot :: Language l => Cursor l x a -> Cursor l x l
data Route l from to
Route :: Path l (Movement l Up) from mid -> Path l (Movement l Down) mid to -> Route l from to
route_invariant :: Language l => Route l from to -> Bool
updateRoute :: (Language l, Reify l a, Reify l b) => Movement l d a b -> Route l a c -> Route l b c
resetLog :: Cursor l x a -> Cursor l a a
appendRoute :: (Language l, Reify l a, Reify l b, Reify l c) => Route l a b -> Route l b c -> Route l a c
followRoute :: Language l => Cursor l x a -> Route l a c -> Maybe (Cursor l x c)

module Data.Cursor.CLASE.Bound
class Language l => Bound l t
bindingHook :: Bound l t => Context l from to -> t -> t
inBindingScope :: Bound l t => (a -> t) -> Cursor l x a -> t

module Data.Cursor.CLASE.Persistence
showCursor :: Persistable l => Cursor l x a -> String
showRoute :: Persistable l => Route l from to -> String
parseCursor :: Persistable l => String -> Maybe (RestoredCursor l)
parseRoute :: (Persistable l, Reify l from) => Bool -> String -> Maybe (RestoredRoute l from)
class (Language l, PersistenceAdapter l, Reify l l) => Persistable l
showMovement :: Persistable l => (Movement l d from to) -> String
movementParser :: (Persistable l, Reify l a) => DirectionT d -> Parser ((ExistsR l (Movement l d a)))
showTypeRep :: Persistable l => TypeRep l a -> String
typeRepParser :: Persistable l => Parser (Exists (TypeRep l))
typeRepEq :: Persistable l => TypeRep l a -> TypeRep l b -> Maybe (TyEq a b)
class PersistenceAdapter l
showL :: PersistenceAdapter l => l -> String
parseL :: PersistenceAdapter l => Parser l
data RestoredCursor l
RestoredCursor :: Cursor l x a -> RestoredCursor l
data RestoredRoute l from
RestoredRoute :: Route l from to -> RestoredRoute l from
data RestoredPath l r a
RestoredPath :: Path l r a b -> RestoredPath l r a
readParser :: (Show a, Read a) => Bool -> Parser a

module Data.Cursor.CLASE.Traversal
class Bound l t => Traversal l t
visitStep :: (Traversal l t, Reify l a) => a -> (forall b. Reify l b => Movement l Down a b -> t) -> t
visitPartial :: Traversal l t => Context l a b -> b -> t -> (forall c. Reify l c => Movement l Down b c -> t) -> t
cursor :: Traversal l t => l -> t -> t
completeTraversal :: Traversal l t => Cursor l x a -> t
