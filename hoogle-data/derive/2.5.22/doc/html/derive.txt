-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A program and library to derive instances for data types
--   
--   Data.Derive is a library and a tool for deriving instances for Haskell
--   programs. It is designed to work with custom derivations, SYB and
--   Template Haskell mechanisms. The tool requires GHC, but the generated
--   code is portable to all compilers. We see this tool as a competitor to
--   DrIFT.
@package derive
@version 2.5.22


-- | Compatibility definitions to paper over differences between 6.10 and
--   6.12.
module Language.Haskell.TH.Compat
fromTyVar :: TyVarBndr -> Name
dataDefinitionTypeArgs :: Dec -> [Name]
typeToPred :: Type -> Pred


-- | The core module of the Data.Derive system. This module contains the
--   data types used for communication between the extractors and the
--   derivors.
module Language.Haskell.TH.Data
type DataDef = Dec
type CtorDef = Con
dataName :: DataDef -> String
qualifiedDataName :: DataDef -> Name
dataArity :: DataDef -> Int
dataArgs :: DataDef -> [Name]
dataCtors :: DataDef -> [CtorDef]
ctorName :: CtorDef -> String
qualifiedCtorName :: CtorDef -> Name
ctorArity :: CtorDef -> Int
ctorStrictTypes :: CtorDef -> [StrictType]
ctorTypes :: CtorDef -> [Type]
ctorFields :: CtorDef -> [String]
dropModule :: String -> String
dropNumber :: String -> String
normData :: DataDef -> DataDef
unqualifiedName :: Name -> String
typeApp :: Type -> (Type, [Type])
eqConT :: String -> Type -> Bool
isTupleT :: Type -> Bool


-- | Expand type synonyms in data declarations.
--   
--   This is needed for some type based derivations.
module Language.Haskell.TH.ExpandSynonym

-- | Expand type synonyms in a data declaration
expandData :: DataDef -> Q DataDef

module Language.Haskell.TH.FixedPpr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
noPrec :: Precedence
opPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
showNameRaw :: Name -> String
isPrefixName :: Name -> Bool
pprName_ :: Bool -> Name -> Doc
pprint :: Ppr a => a -> String
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: (Ppr a1, Ppr a) => a -> a1 -> Doc
pprFixity :: Name -> Fixity -> Doc
pprExpInfix :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
deQualLhsHead :: Dec -> Dec
deQualName :: Name -> Name
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
split :: Type -> (Type, [Type])
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
instance Ppr Pred
instance Ppr TyVarBndr
instance Ppr Range
instance Ppr Type
instance Ppr Con
instance Ppr Clause
instance Ppr Foreign
instance Ppr FunDep
instance Ppr Dec
instance Ppr Pat
instance Ppr Lit
instance Ppr Body
instance Ppr Match
instance Ppr Stmt
instance Ppr Exp
instance Ppr Info
instance Ppr Name
instance Ppr a => Ppr [a]


-- | These small short-named functions are intended to make the
--   construction of abstranct syntax trees less tedious.
module Language.Haskell.TH.Helper
applyWith :: Exp -> [Exp] -> Exp
foldr1With :: Exp -> [Exp] -> Exp
foldl1With :: Exp -> [Exp] -> Exp

-- | A simple clause, without where or guards.
sclause :: [Pat] -> Exp -> Clause

-- | A default clause with N arguments.
defclause :: Int -> Exp -> Clause

-- | A simple Val clause
sval :: Pat -> Exp -> Dec
case' :: Exp -> [(Pat, Exp)] -> Exp
(->:) :: String -> Exp -> Exp

-- | We provide 3 standard instance constructors instance_default requires
--   C for each free type variable instance_none requires no context
--   instance_context requires a given context
instance_none :: String -> DataDef -> [Dec] -> Dec
instance_default :: String -> DataDef -> [Dec] -> Dec
instance_context :: [String] -> String -> DataDef -> [Dec] -> Dec

-- | Build an instance of a class for a data type, using the heuristic that
--   the type is itself required on all type arguments.
simple_instance :: String -> DataDef -> [Dec] -> [Dec]

-- | Build an instance of a class for a data type, using the class at the
--   given types
generic_instance :: String -> DataDef -> [Type] -> [Dec] -> [Dec]

-- | Build a type signature declaration with a string name
sigN :: String -> Type -> Dec

-- | Build a fundecl with a string name
funN :: String -> [Clause] -> Dec
class Eq nm => NameLike nm
toName :: NameLike nm => nm -> Name

-- | The class used to overload lifting operations. To reduce code
--   duplication, we overload the wrapped constructors (and everything
--   else, but that's irrelevant) to work in patterns, expressions, and
--   types.
class Valcon a
lK :: (Valcon a, NameLike nm) => nm -> [a] -> a
vr :: (Valcon a, NameLike nm) => nm -> a
raw_lit :: Valcon a => Lit -> a
tup :: Valcon a => [a] -> a
lst :: Valcon a => [a] -> a

-- | Build an application node without a given head
app :: Exp -> [Exp] -> Exp

-- | This class is used to overload literal construction based on the type
--   of the literal.
class LitC a
lit :: (LitC a, Valcon p) => a -> p
dataVars :: DataDef -> [Type]

-- | Common pattern: list of a familiy of variables
vars :: Valcon a => Char -> Int -> [a]

-- | Variable based on a letter + number
vrn :: Valcon a => Char -> Int -> a

-- | Make a list of variables, one for each argument to a constructor
ctv :: Valcon a => CtorDef -> Char -> [a]

-- | Make a simple pattern to bind a constructor
ctp :: Valcon a => CtorDef -> Char -> a

-- | Reference the constructor itself
ctc :: Valcon a => CtorDef -> a
l0 :: (NameLike nm, Valcon a) => nm -> a
l1 :: (NameLike nm, Valcon a) => nm -> a -> a
l2 :: (NameLike nm, Valcon a) => nm -> a -> a -> a
true :: Valcon a => a
nil :: Valcon a => a
false :: Valcon a => a
hNil' :: Type
hZero' :: Type
unit :: Exp
id' :: Exp
cons :: Valcon a => a -> a -> a
box :: Valcon a => a -> a
return' :: Exp -> Exp
const' :: Exp -> Exp
hSucc' :: Type -> Type
(==:) :: Exp -> Exp -> Exp
(>:) :: Exp -> Exp -> Exp
ap' :: Exp -> Exp -> Exp
(.:) :: Exp -> Exp -> Exp
(>>:) :: Exp -> Exp -> Exp
(>>=:) :: Exp -> Exp -> Exp
(++:) :: Exp -> Exp -> Exp
(&&:) :: Exp -> Exp -> Exp
hCons' :: Type -> Type -> Type

-- | Build a chain of expressions, with an appropriate terminal sequence__
--   does not require a unit at the end (all others are optimised
--   automatically)
(&&::) :: [Exp] -> Exp

-- | Build a chain of expressions, with an appropriate terminal sequence__
--   does not require a unit at the end (all others are optimised
--   automatically)
(.::) :: [Exp] -> Exp

-- | Build a chain of expressions, with an appropriate terminal sequence__
--   does not require a unit at the end (all others are optimised
--   automatically)
sequence__ :: [Exp] -> Exp

-- | Build a chain of expressions, with an appropriate terminal sequence__
--   does not require a unit at the end (all others are optimised
--   automatically)
(>>::) :: [Exp] -> Exp

-- | Build a chain of expressions, with an appropriate terminal sequence__
--   does not require a unit at the end (all others are optimised
--   automatically)
(++::) :: [Exp] -> Exp

-- | K-way liftM
liftmk :: Exp -> [Exp] -> Exp
instance LitC ()
instance (LitC a, LitC b, LitC c) => LitC (a, b, c)
instance (LitC a, LitC b) => LitC (a, b)
instance LitC a => LitC [a]
instance LitC Char
instance LitC Integer
instance Valcon Type
instance Valcon Pat
instance Valcon Exp
instance NameLike String
instance NameLike Name

module Language.Haskell.TH.Peephole
peephole :: Data a => a -> a
replaceVar :: Name -> Exp -> Exp -> Exp
replaceVars :: [(Name, Exp)] -> Exp -> Exp

module Data.Derive.Class.Default
class Default a
def :: Default a => a

module Data.Derive.Class.Arities
class Arities a
arities :: Arities a => a -> [Int]

module Data.Derive.Instance.Arities
instance Data d_type => Arities d_type

module Language.Haskell
(?) :: Bool -> a -> a -> a
foralls :: Type -> Type
tyApps :: Type -> [Type] -> Type
fromTyApps :: Type -> (Type, [Type])
fromTyTuple :: Type -> [Type]
fromTyParen :: Type -> Type
fromTyParens :: Type -> Type
tyRoot :: Type -> String
isTyFun :: Type -> Bool
isTyParen :: Type -> Bool
fromTyList :: Type -> Maybe Type
(~=) :: Pretty a => a -> String -> Bool
appP :: Exp -> Exp -> Exp
simplify :: Data a => a -> a
isGuardFalse :: Match -> Bool
rename :: QName -> QName
isAtom :: Exp -> Bool
paren :: Exp -> Exp
sl :: SrcLoc
noSl :: Data from => from -> from
isIdent :: [Char] -> Bool
title :: [Char] -> [Char]
qname :: String -> QName
var :: String -> Exp
con :: String -> Exp
tyVar :: String -> Type
tyVarBind :: String -> TyVarBind
tyCon :: String -> Type
pVar :: String -> Pat
qvop :: String -> QOp
dataDeclType :: DataDecl -> Type
dataDeclFields :: DataDecl -> [String]
type DataDecl = Decl
type CtorDecl = Either QualConDecl GadtDecl
type FieldDecl = [(String, Type)]
type FullDataDecl = (ModuleName, DataDecl)
moduleName :: Module -> ModuleName
moduleDecls :: Module -> [Decl]
moduleImports :: Module -> [ImportDecl]
modulePragmas :: Module -> [ModulePragma]
showDecls :: Pretty a => [a] -> String
tyApp :: Type -> [Type] -> Type
tyFun :: [Type] -> Type
apps :: Exp -> [Exp] -> Exp
bind :: String -> [Pat] -> Exp -> Decl
binds :: String -> [([Pat], Exp)] -> Decl
isDataDecl :: Decl -> Bool
dataDeclSrcLoc :: DataDecl -> SrcLoc
dataDeclContext :: DataDecl -> Context
dataDeclName :: DataDecl -> String
dataDeclVars :: DataDecl -> [String]
dataDeclVarsStar :: DataDecl -> [String]
dataDeclArity :: DataDecl -> Int
dataDeclCtors :: DataDecl -> [CtorDecl]
ctorDeclName :: CtorDecl -> String
ctorDeclName' :: CtorDecl -> Name
ctorDeclFields :: CtorDecl -> FieldDecl
ctorDeclArity :: CtorDecl -> Int
declName :: Decl -> String

module Language.Haskell.Convert
class (Typeable a, Typeable b, Show a, Show b) => Convert a b
convert :: Convert a b => a -> b
instance Convert Kind Kind
instance Convert TyVarBind TyVarBndr
instance Convert Asst Pred
instance Convert Pred Asst
instance Convert Kind Kind
instance Convert TyVarBndr TyVarBind
instance Convert TyVarBind Name
instance Convert FieldUpdate FieldExp
instance Convert QualStmt Stmt
instance Convert Stmt Stmt
instance Convert Alt Match
instance Convert QOp Exp
instance Convert PatField FieldPat
instance Convert QName Name
instance Convert Literal Lit
instance Convert Pat Pat
instance Convert Binds [Dec]
instance Convert GuardedRhs (Guard, Exp)
instance Convert Exp Exp
instance Convert Rhs Body
instance Convert Match Clause
instance Convert Name Name
instance Convert Type Type
instance Convert Asst Type
instance Convert ([Name], Type) [VarStrictType]
instance Convert Type StrictType
instance Convert ConDecl Con
instance Convert QualConDecl Con
instance Convert Decl Dec
instance Convert Type Asst
instance Convert Type Type
instance Convert StrictType Type
instance Convert Con ConDecl
instance Convert Con QualConDecl
instance Convert Name QName
instance Convert Name Name
instance Convert Name TyVarBind
instance Convert Dec Decl
instance Convert a b => Convert [a] [b]

module Data.Derive.DSL.HSE
sample :: Input
outEq :: Out -> Out -> Bool
showOut :: Pretty a => [a] -> String
type Input = DataDecl
type Ctor = CtorDecl
dataName :: DataDecl -> String
dataVars :: DataDecl -> Int
dataCtors :: DataDecl -> [CtorDecl]
ctorName :: CtorDecl -> String
ctorArity :: CtorDecl -> Integer
ctorIndex :: Input -> Ctor -> Integer
toInput :: DataDecl -> Input
type Out = [Decl]
data Output
OString :: String -> Output
OInt :: Integer -> Output
OApp :: String -> [Output] -> Output
OList :: [Output] -> Output
OIgnore :: Output
OCustom :: String -> Output
toOutput :: Data a => a -> Output
fromOutput :: Data a => Output -> a
coerce :: (Typeable * a1, Typeable * a) => a1 -> a
readCon :: DataType -> [Char] -> Constr
out :: Data a => a -> Output
fromState :: State a x -> x
instance Typeable Output
instance Eq Output
instance Show Output
instance Data Output

module Data.Derive.DSL.DSL
data DSL
App :: String -> DSL -> DSL
Concat :: DSL -> DSL
Reverse :: DSL -> DSL
String :: String -> DSL
ShowInt :: DSL -> DSL
Int :: Integer -> DSL
List :: [DSL] -> DSL
MapField :: DSL -> DSL
MapCtor :: DSL -> DSL
DataName :: DSL
CtorName :: DSL
CtorIndex :: DSL
CtorArity :: DSL
FieldIndex :: DSL
Fold :: DSL -> DSL -> DSL
Head :: DSL
Tail :: DSL
Instance :: [String] -> String -> DSL -> DSL
Application :: DSL -> DSL
box :: DSL -> DSL
nil :: DSL
append :: DSL -> DSL -> DSL
fromOut :: Output -> DSL
simplifyDSL :: DSL -> DSL
prettyTex :: DSL -> String
instance Typeable DSL
instance Data DSL
instance Show DSL

module Data.Derive.DSL.Apply
apply :: DSL -> Input -> Out
applyEnv :: DSL -> Env -> Output
env :: Env
data Env
Env :: Input -> Ctor -> Integer -> (Output, Output) -> Env
envInput :: Env -> Input
envCtor :: Env -> Ctor
envField :: Env -> Integer
envFold :: Env -> (Output, Output)

module Data.Derive.DSL.Derive
derive :: Out -> [DSL]
instance Show Guess

module Data.Derive.DSL.SYB
dslSYB :: DSL -> Maybe Out

module Data.DeriveDSL
data DSL
deriveDSL :: [Decl] -> Maybe DSL
applyDSL :: DSL -> DataDecl -> Either String [Decl]
dynamicDSL :: DSL -> Maybe [Decl]

module Language.Haskell.TH.All

-- | The type of ways to derive classes. Should not really be in this
--   module!
data Derivation
Derivation :: (DataDef -> Q [Dec]) -> String -> Derivation

-- | The derivation function proper
derivationDeriver :: Derivation -> DataDef -> Q [Dec]

-- | The name of the derivation
derivationName :: Derivation -> String
derivation :: (DataDef -> [Dec]) -> String -> Derivation
derivationQ :: (DataDef -> Q [Dec]) -> String -> Derivation

module Data.Derive.Internal.Derivation
data Derivation
Derivation :: String -> (Type -> (String -> Decl) -> FullDataDecl -> Either String [Decl]) -> Derivation
derivationName :: Derivation -> String
derivationOp :: Derivation -> Type -> (String -> Decl) -> FullDataDecl -> Either String [Decl]
derivationParams :: String -> ([Type] -> (String -> Decl) -> FullDataDecl -> Either String [Decl]) -> Derivation
derivationCustom :: String -> (FullDataDecl -> Either String [Decl]) -> Derivation
derivationDSL :: String -> DSL -> Derivation
derivationCustomDSL :: String -> (FullDataDecl -> [Decl] -> [Decl]) -> DSL -> Derivation
customSplice :: (FullDataDecl -> Exp -> Exp) -> (FullDataDecl -> [Decl] -> [Decl])
customContext :: (FullDataDecl -> Context -> Context) -> (FullDataDecl -> [Decl] -> [Decl])

module Data.Derive.Arbitrary
makeArbitrary :: Derivation

module Data.Derive.ArbitraryOld
makeArbitraryOld :: Derivation
dslArbitraryOld :: DSL

module Data.Derive.Arities
makeArities :: Derivation
dslArities :: DSL

module Data.Derive.Binary
makeBinary :: Derivation
dslBinary :: DSL

module Data.Derive.BinaryDefer
makeBinaryDefer :: Derivation
dslBinaryDefer :: DSL

module Data.Derive.Bounded
makeBounded :: Derivation
dslBounded :: DSL

module Data.Derive.Data
makeData :: Derivation


-- | For deriving Data on abstract data types.
module Data.Derive.DataAbstract
makeDataAbstract :: Derivation

module Data.Derive.Default
makeDefault :: Derivation
dslDefault :: DSL

module Data.Derive.Enum
makeEnum :: Derivation
dslEnum :: DSL

module Data.Derive.EnumCyclic
makeEnumCyclic :: Derivation
dslEnumCyclic :: DSL

module Data.Derive.Eq
makeEq :: Derivation
dslEq :: DSL


-- | A pseudo derivation. Derive a (non-recursive) fold function for the
--   type which takes one function per alternative constructor. Each
--   function takes the same arguments as the constructor and returns a
--   value. When applied to a value the fold function applies the function
--   for the matching constructor to the constructor fields. This provides
--   a first-class alternative to pattern matching to deconstruct the data
--   type.
module Data.Derive.Fold
makeFold :: Derivation


-- | A pseudo derivation. For each constructor in the data type, deriving
--   <tt>From</tt> generates <tt>from</tt><i>CtorName</i> which extracts
--   the components if given the appropriate constructor, and crashes
--   otherwise. Unlike the DrIFT <tt>"From"</tt> derivation, our version
--   works for all constructors - zero-arity constructors always return
--   <tt>()</tt>, arity-one constructors return the contained value, and
--   all others return a tuple with all the components.
module Data.Derive.From
makeFrom :: Derivation


-- | Has is a pseudo derivation. For each field of any constructor of the
--   data type, Has generates <tt>has</tt><i>FieldName</i> which returns
--   <a>True</a> if given the the given field is a member of the
--   constructor of the passed object, and <a>False</a> otherwise.
module Data.Derive.Has
makeHas :: Derivation

module Data.Derive.Is
makeIs :: Derivation


-- | Derive <a>JSON</a> instances.
--   
--   Unlike Text.JSON.Generics, single constructor types are <i>not</i>
--   handled specially. Every value is encoded as an object with a single
--   field, with the constructor name as key and the values as its
--   contents.
--   
--   If the constructor is a record, the contents is an Object with the
--   field names as keys. Otherwise, the contents is an array.
module Data.Derive.JSON

-- | <a>Derivation</a> for <tt>JSON</tt>
makeJSON :: Derivation


-- | A pseudo derivation. For each field in the data type, deriving
--   <tt>LazySet</tt> generates a function like a record updator, but lazy
--   where possible. This is very useful in certain situations to improve
--   laziness properties. A setter is only lazy if that field is present in
--   one constructor.
module Data.Derive.LazySet
makeLazySet :: Derivation


-- | A pseudo derivation. For each field in the data type, deriving
--   <tt>Lens</tt> generates <tt>lens</tt><i>FieldName</i><tt> = lens
--   </tt><i>fieldName</i><tt> ( x v -&gt; v { </tt><i>fieldName</i><tt> =
--   x })</tt>.
--   
--   This works with the <tt>data-lens</tt> package.
module Data.Derive.Lens
makeLens :: Derivation


-- | Derives an instance of <tt>Monoid</tt>. It uses the product
--   construction of monoids. <tt>mappend</tt> on two different
--   constructors is undefined.
module Data.Derive.Monoid
makeMonoid :: Derivation

module Data.Derive.NFData
makeNFData :: Derivation
dslNFData :: DSL

module Data.Derive.Ord
makeOrd :: Derivation
dslOrd :: DSL


-- | Derives <tt>Read</tt>. This is as defined by the Haskell report,
--   except there is no support for infix constructors. If you attempt to
--   derive <tt>Read</tt> for a data type with infix constructors, the
--   constructors are handled as if they were prefix constructors, using
--   the <tt>(</tt><i>consym</i><tt>)</tt> syntax.
module Data.Derive.Read
makeRead :: Derivation


-- | A pseudo derivation. For each field in the data type, deriving
--   <tt>Ref</tt> generates <tt>ref</tt><i>FieldName</i><tt> = Ref { select
--   = </tt><i>fieldName</i><tt> , update = f v -&gt; v {
--   </tt><i>fieldName</i><tt> = f (</tt><i>fieldName</i><tt> v) } }</tt>.
--   
--   This is intended for use with the compositional functional references
--   described in
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2007-June/026477.html</a>.
module Data.Derive.Ref
makeRef :: Derivation

module Data.Derive.Serial
makeSerial :: Derivation
dslSerial :: DSL

module Data.Derive.Serialize
makeSerialize :: Derivation
dslSerialize :: DSL


-- | A pseudo derivation. For each field in the data type, deriving
--   <tt>Set</tt> generates <tt>set</tt><i>FieldName</i><tt> v x =
--   x{</tt><i>fieldName</i><tt> = v}</tt>. This derivation is intended to
--   work around the fact that in Haskell assigning to a field is not a
--   first class object (although extracting from a field is).
module Data.Derive.Set
makeSet :: Derivation


-- | Derives <tt>Show</tt>. This is as defined by the Haskell report,
--   except there is no support for infix constructors. If you attempt to
--   derive <tt>Show</tt> for a data type with infix constructors, the
--   constructors are handled as if they were prefix constructors, using
--   the <tt>(</tt><i>consym</i><tt>)</tt> syntax.
module Data.Derive.Show
makeShow :: Derivation


-- | Derivation for the <tt>Typeable</tt> class, as described in the Scrap
--   Your Boilerplate papers. This derivation generates instances for all
--   kinds of TypeableK classes; as such we do NOT require the GHC-specific
--   generic downkinding instances to provide lower kind instances.
--   
--   Also creates a <tt>typename_&lt;the type name&gt;</tt> value to hold
--   the <tt>TypeRep</tt>.
module Data.Derive.Typeable
makeTypeable :: Derivation


-- | Derive Uniplate and Biplate using the Direct combinators. You must
--   request monomorphic instances, i.e:
--   
--   <pre>
--   data Foo a = Foo a (Bool, a)
--   
--   {-!
--   deriving instance UniplateDirect (Foo Int)
--   deriving instance UniplateDirect (Bool, Int) Int
--   deriving instance UniplateDirect (Foo Int) Int
--   !-}
--   </pre>
--   
--   This will generate the instances <tt>Uniplate (Foo Int)</tt>,
--   <tt>Biplate (Bool, Int) Int</tt> and <tt>Biplate (Foo Int) Int</tt>.
--   Generally, start with the instance you are after (e.g.
--   <tt>UniplateDirect (Foo Int)</tt>), try to compile and add further
--   instances as necessary. <tt>UniplateDirect</tt> with one argument
--   derives Uniplate, and with two arguments derives Biplate.
--   
--   <tt>deriving UniplateDirect</tt> on a data type with no arguments
--   derives Uniplate with all type parameters defaulting to <tt>()</tt>.
module Data.Derive.UniplateDirect
makeUniplateDirect :: Derivation
instance Eq Ans
instance Show Ans

module Data.Derive.UniplateTypeable
makeUniplateTypeable :: Derivation
custom :: (t, DataDecl) -> [Decl] -> [Decl]


-- | A Pseudo derivation. For every label, creates a function foo_u and
--   foo_s which updates and sets the label respectively, e.g. 'foo_u (+1)
--   bar' or 'foo_s 10 baz'
module Data.Derive.Update
makeUpdate :: Derivation

module Data.Derive.Foldable
makeFoldable :: Derivation
makeFoldableN :: Int -> Derivation


-- | Derives <a>Functor</a>, as discussed on the Haskell-prime mailing
--   list:
--   <a>http://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html</a>.
module Data.Derive.Functor
makeFunctor :: Derivation
makeFunctorN :: Int -> Derivation

module Data.Derive.Traversable
makeTraversable :: Derivation
makeTraversableN :: Int -> Derivation


-- | This module provides convenience re-exports of all the standard
--   Data.Derive derivations.
module Data.Derive.All
data Derivation
derivations :: [Derivation]


-- | The main TH driver module. It is intended that this need be the only
--   module imported by user code; it takes care of all data threading
--   issues such that all one needs to do is:
--   
--   <pre>
--   data Foo = Foo ; $( derive makeEq ''Foo )
--   </pre>
module Data.DeriveTH

-- | Derive an instance of some class. <tt>derive</tt> only derives
--   instances for the type of the argument.
derive :: Derivation -> Name -> Q [Dec]
derives :: [Derivation] -> [Name] -> Q [Dec]

-- | Derive an instance of some class. <tt>deriveFromDec</tt> only derives
--   instances for the type of the argument.
deriveFromDec :: Derivation -> Dec -> Q [Dec]


-- | Use this module to create your own derive program, supporting custom
--   derivations. As an example:
--   
--   <pre>
--   import <a>Data.DeriveMain</a>        (<a>deriveMain</a>)
--   import <a>Data.Derive.All</a>        (<a>derivations</a>)
--   import MyProject.MyDerivation (myDerivation)
--   </pre>
--   
--   <pre>
--   main :: IO
--   main = <a>deriveMain</a> $ [myDerivation] ++ <a>derivations</a>
--   </pre>
module Data.DeriveMain
deriveMain :: [Derivation] -> IO ()
