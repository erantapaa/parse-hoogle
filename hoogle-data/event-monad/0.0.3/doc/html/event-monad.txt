-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Event-graph simulation monad transformer
--   
--   An interface for and simple implementation of an event-graph
--   simulation system as a monad transformer, as well as a version using
--   mutable state references for performance and for concurrency support.
@package event-monad
@version 0.0.3

module Control.Monad.Event.Classes

-- | A type-class for monads with a concept of time. That concept need not
--   necessarily meet any prior conditions - not even an Eq instance.
class Monad m => MonadTime m t | m -> t
getCurrentTime :: MonadTime m t => m t

-- | A monad in which there is a concept of running and not-running and
--   unrestricted operations for switching between them.
class Monad m => MonadSimControl m
resumeSimulation :: MonadSimControl m => m ()
pauseSimulation :: MonadSimControl m => m ()
isSimulationRunning :: MonadSimControl m => m Bool

-- | A monad in which there is a concept of an "event" - an action with a
--   sort of a special status, which can be described for humans and can be
--   otherwise manipulated in monads implementing the classes to follow.
class (Monad m, Typeable e) => MonadEvent m e | e -> m
describeEvent :: MonadEvent m e => e -> m Doc
runEvent :: MonadEvent m e => e -> m ()

-- | A monad which can schedule events for later execution. For obvious
--   reasons, such a monad must also have a concept of events (covering the
--   event that the user is trying to schedule) and a concept of time.
class (MonadEvent m e, MonadTime m t) => ScheduleEvent m t e | m -> t
scheduleEventAt :: ScheduleEvent m t e => t -> e -> m EventID
doNext :: ScheduleEvent m t e => e -> m ()

-- | schedule an event at an absolute time (see <a>scheduleEventIn</a>)
scheduleEventIn :: (ScheduleEvent m t e, Num t) => t -> e -> m EventID

-- | A monad in which an event (presumably one previously scheduled) can be
--   canceled.
class MonadTime m t => CancelEvent m t | m -> t
cancelEvent :: CancelEvent m t => EventID -> m (Maybe (EventDescriptor m t))

-- | A monad in which an <a>EventDescriptor</a> for the currently-executing
--   event, if any, can be obtained.
class MonadTime m t => GetCurrentEvent m t | m -> t
getCurrentEvent :: GetCurrentEvent m t => m (Maybe (EventDescriptor m t))

-- | A monad in which the currently executing event can be rescheduled.
--   Note that calling <a>retryEventAt</a> does not terminate the currently
--   executing event - although perhaps it should. Until a more permanent
--   decision is made, it's probably best to make <a>retryEventAt</a> the
--   last action of an event when it is used, to minimize impact of future
--   changes.
class MonadTime m t => RetryEvent m t | m -> t
retryEventAt :: RetryEvent m t => t -> m EventID

-- | retry the currently-executing event at an absolute time (see
--   <a>retryEventIn</a>)
retryEventIn :: (RetryEvent m t, Num t) => t -> m EventID

-- | A monad in which information about the event queue can be retrieved.
class MonadTime m t => MonadEventQueueInfo m t | m -> t
eventQueueSize :: MonadEventQueueInfo m t => m Int
eventQueueContents :: MonadEventQueueInfo m t => m [EventDescriptor m t]

module Control.Monad.EventM
type EventM = EventIO Double
data EventIO t a

-- | Run an <tt>EventT</tt> wrapped action. This is a "raw" action - there
--   is no interaction with the state (including event graph) except
--   whatever the action itself does.
runEventIO :: EventIO t a -> EventIOState t -> IO a

-- | Initialize the event queue and other stuff, run the provided "start
--   event", and run the queue until it's empty or until the simulation is
--   paused.
runEventGraph :: (MonadEvent (EventIO t) e, Ord t, Num t, Show t, Typeable t) => e -> IO (EventIOState t)

-- | Repeatedly pull and run the next event in the queue until it's empty
--   or until the simulation is paused using <a>pauseSimulation</a> or
--   something equivalent.
runEventGraphWithState :: (Ord t, Show t, Typeable t) => EventIOState t -> IO ()
data EventIOState t
newEventIOState :: Ord t => t -> IO (EventIOState t)
type HandlerAccessor t a b = EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) a b)
onClockChanged :: EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) (t, t) ())
onEventDispatch :: EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) (EventDescriptor (EventIO t) t) ())
onEventComplete :: EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) (EventDescriptor (EventIO t) t) ())
onEventSchedule :: EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) (EventDescriptor (EventIO t) t) ())
onEventCancel :: EventIOHandlers t -> Ref IO (HandlerSet (EventIO t) (Either EventID (EventDescriptor (EventIO t) t)) ())

-- | Add an event handler to be called when the specified event happens.
addHandler :: HandlerAccessor t a b -> (a -> EventIO t b) -> EventIO t HandlerID

-- | Remove an event handler given its ID, and return it if it was in the
--   set.
removeHandler :: HandlerAccessor t a b -> HandlerID -> EventIO t (Maybe (a -> EventIO t b))
instance Typeable2 EventIO
instance Functor (EventIO t)
instance Monad (EventIO t)
instance MonadIO (EventIO t)
instance MonadFix (EventIO t)
instance NewRef (Ref (EventIO t) a) IO a
instance ModifyRef (Ref IO a) (EventIO t) a
instance WriteRef (Ref IO a) (EventIO t) a
instance ReadRef (Ref IO a) (EventIO t) a
instance NewRef (Ref IO a) (EventIO t) a
instance HasRef (EventIO t)
instance MonadEventQueueInfo (EventIO t) t
instance RetryEvent (EventIO t) t
instance GetCurrentEvent (EventIO t) t
instance CancelEvent (EventIO t) t
instance MonadEvent (EventIO t) e => ScheduleEvent (EventIO t) t e
instance (Typeable t, Show t) => MonadEvent (EventIO t) (EventDescriptor (EventIO t) t)
instance (Typeable a, Typeable t) => MonadEvent (EventIO t) (IO a)
instance (Typeable a, Typeable t) => MonadEvent (EventIO t) (EventIO t a)
instance MonadSimControl (EventIO t)
instance MonadTime (EventIO t) t

module Control.Monad.EventT

-- | A monad transformer which adds an event queue and related operations
--   to an underlying monad. The "t" parameter specifies the type of the
--   simulation time.
--   
--   Several hooks are provided to allow special handling of various
--   events, such as the progression of time, the scheduling or canceling
--   or dispatch of an event, etc.
data EventT t m a

-- | Run an <a>EventT</a> wrapped action. This is a "raw" action - there is
--   no interaction with the state (including event graph) except whatever
--   the action itself does.
runEventT :: Monad m => EventT t m a -> EventT_RState t m -> EventT_RWState t m -> m (a, EventT_RWState t m)

-- | Initialize the event queue and other stuff, enqueue the provided
--   "start event", and run the queue until it's empty or until the
--   simulation is paused.
runEventGraph :: (Monad m, MonadEvent (EventT t m) e, Ord t, Num t, Show t, Typeable t, Typeable1 m) => e -> m (EventT_RState t m, EventT_RWState t m)

-- | Repeatedly pull and run the next event in the queue until it's empty
--   or until the simulation is paused using <a>pauseSimulation</a> or
--   something equivalent.
runEventGraphWithState :: (Monad m, Ord t, Show t, Typeable t, Typeable1 m) => EventT_RState t m -> EventT_RWState t m -> m (EventT_RWState t m)
data EventT_RState t m
data EventT_RWState t m

-- | A new instance of the read-only portion of the <a>EventT</a> internal
--   state.
newEventT_RState :: EventT_RState t m

-- | A new instance of the read/write portion of the <a>EventT</a> internal
--   state. The parameter is the initial time value.
newEventT_RWState :: (Monad m, Ord t) => t -> EventT_RWState t m
type HandlerAccessor t m a b = (EventTHandlers t m -> HandlerSet (EventT t m) a b, HandlerSet (EventT t m) a b -> EventTHandlers t m -> EventTHandlers t m)

-- | Fires whenever the clock changes, and is passed a tuple containing
--   (old time, new time)
onClockChanged :: HandlerAccessor t m (t, t) ()

-- | Fires just before an event is dispatched. Is passed an
--   <a>EventDescriptor</a> describing the event about to be run.
onEventDispatch :: HandlerAccessor t m (EventDescriptor (EventT t m) t) ()

-- | Fires after an event returns. Is passed an <a>EventDescriptor</a> for
--   the event that just finished.
onEventComplete :: HandlerAccessor t m (EventDescriptor (EventT t m) t) ()

-- | Fires after an event is scheduled. Is passed an <a>EventDescriptor</a>
--   for the event.
onEventSchedule :: HandlerAccessor t m (EventDescriptor (EventT t m) t) ()

-- | Fires after an event is canceled. Is passed either an <a>EventID</a>
--   (if the cancellation failed) or an <a>EventDescriptor</a> for the
--   event that was canceled.
onEventCancel :: HandlerAccessor t m (Either EventID (EventDescriptor (EventT t m) t)) ()

-- | Add an event handler to be called when the specified event happens.
addHandler :: Monad m => HandlerAccessor t m a b -> (a -> EventT t m b) -> EventT t m HandlerID

-- | Remove an event handler given its ID, and return it if it was in the
--   set.
removeHandler :: Monad m => HandlerAccessor t m a b -> HandlerID -> EventT t m (Maybe (a -> EventT t m b))
instance Show DebugHandlerOptions
instance Functor m => Functor (EventT t m)
instance Monad m => Monad (EventT t m)
instance MonadIO m => MonadIO (EventT t m)
instance MonadFix m => MonadFix (EventT t m)
instance MonadCont m => MonadCont (EventT t m)
instance MonadPlus m => MonadPlus (EventT t m)
instance MonadError e m => MonadError e (EventT t m)
instance MonadState s m => MonadState s (EventT t m)
instance MonadWriter w m => MonadWriter w (EventT t m)
instance MonadReader r m => MonadReader r (EventT t m)
instance MonadTrans (EventT t)
instance (Typeable t, Typeable1 m) => Typeable1 (EventT t m)
instance (Monad m, Ord t) => MonadEventQueueInfo (EventT t m) t
instance Monad m => RetryEvent (EventT t m) t
instance Monad m => GetCurrentEvent (EventT t m) t
instance (Monad m, Ord t) => CancelEvent (EventT t m) t
instance (Monad m, Ord t, MonadEvent (EventT t m) e) => ScheduleEvent (EventT t m) t e
instance (Monad m, Show t, Typeable t, Typeable1 m) => MonadEvent (EventT t m) (EventDescriptor (EventT t m) t)
instance (Monad m, Typeable (EventT t m a)) => MonadEvent (EventT t m) (EventT t m a)
instance Monad m => MonadSimControl (EventT t m)
instance Monad m => MonadTime (EventT t m) t

module Control.Monad.Event.BasicEvents
data SimControl m :: (* -> *)
StopSim :: SimControl
StartSim :: SimControl

-- | An event with description and effect supplied at run time
data AdHocEvent m
AdHocEvent :: (m Doc) -> (m ()) -> AdHocEvent m

-- | An infix operator to construct an event from a description and an
--   action
(?:) :: (Monad m, Pretty desc) => desc -> m a -> AdHocEvent m

-- | Same thing, but use an action to generate the description
(?::) :: Monad m => m Doc -> m a -> AdHocEvent m

-- | An infix operator for sequential composition of events
(&) :: (MonadEvent m e1, MonadEvent m e2) => e1 -> e2 -> AdHocEvent m

-- | A version of <a>&amp;</a> that preserves distinctness of events at the
--   expense of being able to guarantee "proper" interleaving with other
--   events scheduled at the same time. For example, suppose a composite
--   event e1 &amp;- e2 of this type is scheduled, then a third event e3 is
--   scheduled for the same time. The "expected" order of execution is e1;
--   e2; e3. What actually happens is e1; e3; e2 - because (e1 &amp;- e2)
--   runs, having the effect of running e1 and scheduling e2, then e3 runs
--   (because it's next in the queue), then e2 finally runs. This situation
--   could be solved by changing the semantics for <a>doNext</a> as
--   proposed there.
--   
--   This is primarily useful for separating an initial
--   <tt>SetDebugHandlers</tt> event from the other event(s) being fired at
--   the start of the simulation, so that they will be "seen" by the newly
--   installed handlers.
(&-) :: (ScheduleEvent m t e2, MonadEvent m e1, Typeable1 m) => e1 -> e2 -> AdHocEvent m

-- | An infix operator for defining a "delayed" event - or rather a new
--   event that schedules its payload at a later time
(@:) :: (ScheduleEvent m t e, Pretty t, Num t) => e -> t -> AdHocEvent m
instance Eq (SimControl m)
instance Show (SimControl m)
instance (Monad m, Typeable1 m) => MonadEvent m (AdHocEvent m)
instance Typeable1 m => Typeable (AdHocEvent m)
instance (MonadSimControl m, Typeable1 m) => MonadEvent m (SimControl m)
instance Pretty (SimControl m)
instance Typeable1 m => Typeable (SimControl m)

module Control.Monad.Event

-- | A monad transformer which adds an event queue and related operations
--   to an underlying monad. The "t" parameter specifies the type of the
--   simulation time.
--   
--   Several hooks are provided to allow special handling of various
--   events, such as the progression of time, the scheduling or canceling
--   or dispatch of an event, etc.
data EventT t m a
type EventM = EventIO Double

-- | An existential wrapper containing an event which can be executed in
--   the monad <tt>m</tt>.
--   
--   I would like to existentially quantify the time parameter too, since
--   it's uniquely determined according to the functional dependencies of
--   <a>MonadTime</a>, but GHC doesn't unify it with its actual type in
--   pattern matches - I was not able to use it as a <a>PrintfArg</a> in:
--   
--   <pre>
--   instance MonadEvent (EventT Double IO) (EventDescriptor (EventT Double IO))
--   </pre>
data EventDescriptor m :: (* -> *) t
EventDescriptor :: EventID -> t -> e -> EventDescriptor t
eventId :: EventDescriptor t -> EventID
eventTime :: EventDescriptor t -> t
event :: EventDescriptor t -> e

-- | An opaque identifier for events.
newtype EventID
EventID :: Int -> EventID
