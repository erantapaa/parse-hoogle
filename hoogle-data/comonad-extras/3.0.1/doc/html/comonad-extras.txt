-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Comonad transformers requiring extensions to Haskell 98
--   
--   Comonads and comonad transformers that require extensions to Haskell
--   98
@package comonad-extras
@version 3.0.1


-- | The array-backed store (state-in-context/costate) comonad transformer
--   is subject to the laws:
--   
--   <pre>
--   x = seek (pos x) x
--   y = pos (seek y x)
--   seek y x = seek y (seek z x)
--   </pre>
--   
--   Thanks go to Russell O'Connor and Daniel Peebles for their help
--   formulating and proving the laws for this comonad transformer.
--   
--   This basic version of this transformer first appeared on Dan Piponi's
--   blog at <a>http://blog.sigfpe.com/2008/03/comonadic-arrays.html</a>.
--   
--   Since this module relies on the non-Haskell 98 <tt>arrays</tt>
--   package, it is located here instead of in comonad-transformers.
--   
--   NB: attempting to seek or peek out of bounds will yield an error.
module Control.Comonad.Store.Pointer
type Pointer i = PointerT i Identity
pointer :: Array i a -> i -> Pointer i a
runPointer :: Pointer i a -> (Array i a, i)
data PointerT i w a
PointerT :: (w (Array i a)) -> i -> PointerT i w a
runPointerT :: PointerT i w a -> (w (Array i a), i)

-- | Extract the bounds of the currently focused array
pointerBounds :: (Comonad w, Ix i) => PointerT i w a -> (i, i)
instance (ComonadEnv m w, Ix i) => ComonadEnv m (PointerT i w)
instance (ComonadTraced m w, Ix i) => ComonadTraced m (PointerT i w)
instance (Comonad w, Ix i) => ComonadStore i (PointerT i w)
instance Ix i => ComonadHoist (PointerT i)
instance Ix i => ComonadTrans (PointerT i)
instance (Comonad w, Ix i) => Comonad (PointerT i w)
instance (Comonad w, Ix i) => Extend (PointerT i w)
instance (Functor w, Ix i) => Functor (PointerT i w)
instance (Typeable i, Typeable1 w, Typeable a) => Typeable (PointerT i w a)
instance (Typeable i, Typeable1 w) => Typeable1 (PointerT i w)


module Control.Comonad.Store.Zipper
data Zipper t a
zipper :: Traversable t => t a -> Maybe (Zipper t a)
zipper1 :: Traversable1 t => t a -> Zipper t a
unzipper :: Zipper t a -> t a
size :: Zipper t a -> Int
instance Comonad (Zipper t)
instance Extend (Zipper t)
instance Traversable (Zipper t)
instance Foldable (Zipper t)
instance Functor (Zipper t)
instance ComonadStore Int (Zipper t)
