-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concurrent over the network execution library
--   
--   net-concurrent is a simple haskell library for doing parallel
--   computation on several computers using the network. There is a single
--   master process and many slave processes. Communication is between the
--   master and the slaves, for simplicity slaves never communicate with
--   each other. Communication is done using NVars, network variables. The
--   NVar api is very similar to MVar. These are stored in the master
--   process and shared between all processes in the system. Slave nodes
--   can read and write these NVar variables which results in network
--   transactions with the master.
@package net-concurrent
@version 0.1.0


-- | The master process doesn't do any work except managing the slaves. The
--   master process is handled entirely by the library in
--   <a>initMaster</a>.
module Control.Concurrent.Network.Master

-- | The master process. Only returns when all slaves have closed
--   connection.
initMaster :: Int -> PortID -> IO ()


-- | Slave processes have a single connection towards the master for
--   simplicity. Communication is done by using <tt>NVar</tt> variables
--   similar to <a>MVar</a> in Concurrent.
module Control.Concurrent.Network.Slave

-- | the NC Context
data NCContext
NCC :: MVar Handle -> NCContext
hdl :: NCContext -> MVar Handle

-- | Initialises a slave process returning the NC context.
initSlave :: HostName -> PortID -> IO NCContext

-- | Returns the slave ID of the caller
slaveID :: NCContext -> IO Int

-- | Number of slaves
numSlaves :: NCContext -> IO Int

-- | Prints a message on master
printMsg :: NCContext -> String -> IO ()


-- | General idea is having one dedicated master process and an arbitrary
--   number of slave processes.
module Control.Concurrent.Network.Process

-- | Convinience function. It calls either <a>initMaster</a> or
--   <a>initSlave</a> depending on whether we have -m on the command line
--   or not. If -m is specified the following argument should be the number
--   of slaves to wait for.
--   
--   Returns in the slave processes with the NC context. Does not return in
--   the master process.
initProcess :: IO NCContext


-- | Network variables. Communication is done by using <tt>NVar</tt>
--   variables similar to <a>MVar</a> in Concurrent.
--   
--   Every read and every write results in network transaction with the
--   master process, so handle with care.
--   
--   This is done with a push style implementation so <a>putNVar</a>
--   propagets the value to the master process, but other slaves won't get
--   automatically notified about the change. The next <a>takeNVar</a> will
--   result in the updated value.
--   
--   To save network bandwith and load on the master, it is possible to
--   wait for an <tt>NVar</tt> to change value using <a>pollWithOp</a>.
module Control.Concurrent.Network.NVar

-- | Creates a new empty <tt>NVar</tt> on the master. Doesn't block the
--   caller.
newNVar :: NCContext -> String -> IO ()

-- | Puts a value into <tt>NVar</tt> specified by the name. If the
--   <tt>NVar</tt> doesn't exist this blocks the caller until it's created
--   potentially by an other slave.
--   
--   If the <tt>NVar</tt> already has a value this blocks the caller until
--   an other slave calls <a>takeNVar</a>.
--   
--   If the <tt>NVar</tt> is empty this returns immediately after the
--   network transactions.
putNVar :: Binary a => NCContext -> String -> a -> IO ()

-- | Takes the latest value of <tt>NVar</tt> from the master. If the
--   <tt>NVar</tt> doesn't exist this blocks the caller until it's created
--   potentially by an other slave.
--   
--   If the <tt>NVar</tt> is empty this blocks the caller until an other
--   slave calls <a>putNVar</a>.
--   
--   If the <tt>NVar</tt> has a value this returns immediately after the
--   network transactions.
takeNVar :: Binary a => NCContext -> String -> IO a

-- | Tries to put a value into <tt>NVar</tt> specified by the name. If the
--   <tt>NVar</tt> doesn't exist returns <a>IO</a> <a>False</a>.
--   
--   If the <tt>NVar</tt> already has a value returns <a>IO</a>
--   <a>False</a> and leaves the value untouched.
--   
--   If the <tt>NVar</tt> is empty this sets it to the specified value and
--   returns <a>IO</a> <a>True</a>.
tryPutNVar :: Binary a => NCContext -> String -> a -> IO Bool

-- | Takes the latest value of <tt>NVar</tt> from the master. If the
--   <tt>NVar</tt> doesn't exist this blocks the caller until it's created
--   potentially by an other slave.
--   
--   If the <tt>NVar</tt> is empty this blocks the caller until an other
--   slave calls <a>putNVar</a>.
--   
--   If the <tt>NVar</tt> has a value this returns immediately after the
--   network transactions.
tryTakeNVar :: Binary a => NCContext -> String -> IO (Maybe a)

-- | Like with <a>MVar</a>s this takes an <tt>NVar</tt> put's the taken
--   value back, and returns it.
readNVar :: Binary a => NCContext -> String -> IO a

-- | Polls while the given condition is true for <tt>NVar</tt> called
--   <tt>name</tt>. As this call doesn't return while the condition is
--   true, it's much more efficient than busy waiting in the slave
--   generating network traffic.
pollWithOp :: Binary a => NCContext -> String -> Equality -> a -> IO ()
