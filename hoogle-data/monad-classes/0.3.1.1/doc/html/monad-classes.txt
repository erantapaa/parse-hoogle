-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | more flexible mtl
--   
@package monad-classes
@version 0.3.1.1


-- | <a>Proxied</a> monad. <tt><a>Proxied</a> x</tt> is a monad transformer
--   that has a global configuration parameter of type <tt>x</tt>
--   associated with it.
--   
--   It is used to implement things like <tt>ZoomT</tt>/<tt>runZoom</tt>
--   and <tt>CustromWriterT</tt>/<tt>evalWriterWith</tt>.
--   
--   Most of the time you don't need to use this directly. It is exported
--   for two purposes:
--   
--   <ul>
--   <li>you can use it to define new monad transformers</li>
--   <li>you can define instances for <tt><a>Proxied</a> x</tt> and
--   transformers that are based on it</li>
--   </ul>
module Control.Monad.Classes.Proxied
newtype Proxied x m a
Proxied :: (forall (q :: *). Reifies q x => Proxy# q -> m a) -> Proxied x m a
fromProxy# :: Proxy# a -> Proxy a
toProxy# :: Proxy a -> Proxy# a
reify :: a -> (forall (q :: *). Reifies q a => Proxy# q -> r) -> r
reflect :: Reifies q a => Proxy# q -> a
class Reifies (s :: k) a | s -> a

-- | The type constructor <tt>Proxy#</tt> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <tt>Proxy#</tt> is
--   not only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# :: k -> (#)

-- | Witness for an unboxed <tt>Proxy#</tt> value, which has no runtime
--   representation.
proxy# :: Proxy# k a
instance MonadTransControl (Proxied x)
instance MonadBase b m => MonadBase b (Proxied x m)
instance MonadIO m => MonadIO (Proxied x m)
instance MonadTrans (Proxied x)
instance MonadPlus m => MonadPlus (Proxied x m)
instance Alternative m => Alternative (Proxied x m)
instance Monad m => Monad (Proxied x m)
instance Applicative m => Applicative (Proxied x m)
instance Functor m => Functor (Proxied x m)


-- | Functions to run outer layers of monadic stacks.
--   
--   These are provided for convenience only; you can use the running
--   functions (like <a>runState</a>) from the transformers' modules
--   directly.
--   
--   Note that reader and state runners have their arguments swapped
--   around; this makes it convenient to chain them.
module Control.Monad.Classes.Run
run :: Identity a -> a
runReader :: r -> ReaderT r m a -> m a
runStateLazy :: s -> StateT s m a -> m (a, s)
runStateStrict :: s -> StateT s m a -> m (a, s)
evalStateLazy :: Monad m => s -> StateT s m a -> m a
evalStateStrict :: Monad m => s -> StateT s m a -> m a
execStateLazy :: Monad m => s -> StateT s m a -> m s
execStateStrict :: Monad m => s -> StateT s m a -> m s
runWriterLazy :: (Monad m, Monoid w) => WriterT w m a -> m (a, w)
runWriterStrict :: (Monad m, Monoid w) => StateT w m a -> m (a, w)
evalWriterLazy :: (Monad m, Monoid w) => WriterT w m a -> m a
evalWriterStrict :: (Monad m, Monoid w) => StateT w m a -> m a
execWriterLazy :: (Monad m, Monoid w) => WriterT w m a -> m w
execWriterStrict :: (Monad m, Monoid w) => StateT w m a -> m w
evalWriterWith :: (w -> m ()) -> CustomWriterT w m a -> m a

-- | Transform all writer requests with a given function
mapWriter :: MonadWriter w2 m => (w1 -> w2) -> CustomWriterT w1 m a -> m a
newtype CustomWriterT' w n m a
CustomWriterT :: (Proxied (w -> n ()) m a) -> CustomWriterT' w n m a
type CustomWriterT w m a = CustomWriterT' w m m a
runExcept :: ExceptT e m a -> m (Either e a)
runMaybe :: MaybeT m a -> m (Maybe a)
runZoom :: (forall f. Functor f => (small -> f small) -> big -> f big) -> ZoomT big small m a -> m a
newtype ZoomT big small m a
ZoomT :: (Proxied (VLLens big small) m a) -> ZoomT big small m a

module Control.Monad.Classes

-- | The <tt><a>MonadState</a> s m</tt> constraint asserts that <tt>m</tt>
--   is a monad stack that supports state operations on type <tt>s</tt>
type MonadState s m = MonadStateN (Find (EffState s) m) s m

-- | Construct a state monad computation from a function
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Fetch the current value of the state within the monad
get :: MonadState a m => m a

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>
put :: MonadState s m => s -> m ()

-- | Maps an old state to a new state inside a state monad layer
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state
modify' :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | The <tt><a>MonadReader</a> r m</tt> constraint asserts that <tt>m</tt>
--   is a monad stack that supports a fixed environment of type <tt>r</tt>
type MonadReader e m = MonadReaderN (Find (EffReader e) m) e m

-- | The <tt><a>MonadLocal</a> r m</tt> constraint asserts that <tt>m</tt>
--   is a monad stack that supports a fixed environment of type <tt>r</tt>
--   that can be changed externally to the monad
type MonadLocal e m = MonadLocalN (Find (EffLocal e) m) e m

-- | Fetch the environment passed through the reader monad
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadLocal r m => (r -> r) -> m a -> m a

-- | The <tt><a>MonadWriter</a> w m</tt> constraint asserts that <tt>m</tt>
--   is a monad stack that supports outputting values of type <tt>w</tt>
type MonadWriter w m = MonadWriterN (Find (EffWriter w) m) w m

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>
tell :: MonadWriter w m => w -> m ()

-- | The <tt><a>MonadExcept</a> e m</tt> constraint asserts that <tt>m</tt>
--   is a monad stack that supports throwing exceptions of type <tt>e</tt>
type MonadExcept e m = MonadExceptN (Find (EffExcept e) m) e m

-- | Throw an exception
throw :: MonadExcept e m => e -> m a
type MonadExec w m = MonadExecN (Find (EffExec w) m) w m

-- | Lift an <a>IO</a> action
exec :: MonadExec w m => w a -> m a
class MonadLiftN (n :: Peano) m where type family Down n m :: * -> *
liftN :: MonadLiftN n m => Proxy# n -> Down n m a -> m a

-- | Writer effect
data EffWriter (w :: *)

-- | Reader effect
data EffReader (e :: *)

-- | Local state change effect
data EffLocal (e :: *)

-- | State effect
data EffState (s :: *)

-- | Arbitrary monadic effect
data EffExec (w :: * -> *)

-- | Except effect
data EffExcept (e :: *)
data Peano :: *
Zero :: Peano
Succ :: Peano -> Peano
class Monad m => MonadStateN (n :: Peano) s m
stateN :: MonadStateN n s m => Proxy# n -> ((s -> (a, s)) -> m a)
class Monad m => MonadReaderN (n :: Peano) r m
askN :: MonadReaderN n r m => Proxy# n -> m r
class Monad m => MonadLocalN (n :: Peano) r m
localN :: MonadLocalN n r m => Proxy# n -> ((r -> r) -> m a -> m a)
class Monad m => MonadWriterN (n :: Peano) w m
tellN :: MonadWriterN n w m => Proxy# n -> (w -> m ())
class Monad m => MonadExceptN (n :: Peano) e m
throwN :: MonadExceptN n e m => Proxy# n -> (e -> m a)
class Monad m => MonadExecN (n :: Peano) w m
execN :: MonadExecN n w m => Proxy# n -> (w a -> m a)

-- | <tt><a>Find</a> eff m</tt> finds the first transformer in a monad
--   transformer stack that can handle the effect <tt>eff</tt>
type Find eff (m :: * -> *) = FindTrue (MapCanDo eff m)

-- | <tt><a>FindTrue</a> bs</tt> returns a (type-level) index of the first
--   occurrence of <a>True</a> in a list of booleans

-- | <tt><a>MapCanDo</a> eff stack</tt> maps the type-level function <tt>(m
--   -&gt; <a>CanDo</a> m eff)</tt> over all layers that a monad
--   transformer stack <tt>stack</tt> consists of

-- | <tt><a>CanDo</a> m eff</tt> describes whether the given effect can be
--   performed in the monad <tt>m</tt> (without any additional lifting)
