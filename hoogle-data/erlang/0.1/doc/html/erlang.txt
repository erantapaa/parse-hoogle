-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FFI interface to Erlang.
--   
--   Speaks the Erlang network protocol and impersonates an Erlang node on
--   the network. Fully capable of bi-directional communication with
--   Erlang. Erlang types are, as far as reasonable, mapped to Haskell
--   types. Messages to Erlang are just function calls in Haskell, and
--   messages from Erlang are delivered to MVars.
@package erlang
@version 0.1


-- | Speaks the Erlang network protocol and impersonates an Erlang node on
--   the network. Fully capable of bi-directional communication with
--   Erlang. Erlang types are, as far as reasonable, mapped to Haskell
--   types. Messages to Erlang are just function calls in Haskell, and
--   messages from Erlang are delivered to MVars.
module Foreign.Erlang

-- | Return the names and addresses of all registered Erlang nodes.
epmdGetNames :: IO [String]

-- | Return the port address of a named Erlang node.
epmdGetPort :: String -> IO Int

-- | Returns (port, nodeType, protocol, vsnMax, vsnMin, name, extra)
epmdGetPortR4 :: String -> IO (Int, Int, Int, Int, Int, String, String)
type ErlRecv = IO (Maybe ErlType, Maybe ErlType)
type ErlSend = (Maybe ErlType, Maybe ErlType) -> IO ()
erlConnect :: String -> String -> IO (ErlSend, ErlRecv)
toNetwork :: Int -> Integer -> [Word8]

-- | gen_server:call(Pid, Msg)
genCall :: Erlang a => MBox -> Node -> Pid -> a -> IO ErlType

-- | gen_server:cast(Pid, Msg)
genCast :: Erlang a => MBox -> Node -> Pid -> a -> IO ()

-- | rpc:call(Node, Module, Function, Arguments)
rpcCall :: MBox -> Node -> String -> String -> [ErlType] -> IO ErlType

-- | rpc:cast(Node, Module, Function, Arguments)
rpcCast :: MBox -> Node -> String -> String -> [ErlType] -> IO ()
backup :: MBox -> String -> String -> IO ErlType
dirtyAllKeys :: MBox -> String -> String -> IO ErlType
dirtyFirst :: MBox -> String -> String -> IO ErlType
dirtyNext :: MBox -> String -> String -> ErlType -> IO ErlType
dirtyLast :: MBox -> String -> String -> IO ErlType
dirtyPrev :: MBox -> String -> String -> ErlType -> IO ErlType
dirtyMatchObject :: MBox -> String -> ErlType -> IO ErlType
dirtyRead :: MBox -> String -> String -> ErlType -> IO ErlType
dirtySelect :: MBox -> String -> String -> ErlType -> IO ErlType

-- | Represents a Haskell node. There should be one of these per process.
data Self

-- | Instantiate a Haskell node. This initializes the FFI.
createSelf :: String -> IO Self

-- | Haskell threads don't natively have Erlang process IDs. Instead, we
--   use a mailbox abstraction that we can assign PIDs to for communication
--   with Erlang.
data MBox

-- | Create a new process on the Haskell side. Usually corresponds to a
--   thread but doesn't need to.
createMBox :: Self -> IO MBox

-- | Return a new unique object reference.
mboxRef :: MBox -> IO ErlType

-- | Return the PID of the given mailbox.
mboxSelf :: MBox -> ErlType

-- | The name of an Erlang node on the network.
type Node = String

-- | Represents a foreign (Erlang) process. A process can be identified
--   either by its low-level ID (Left pid) or by its registered name (Right
--   name).
type Pid = Either ErlType String

-- | Receive the next message addressed to this mailbox.
mboxRecv :: MBox -> IO ErlType

-- | Receive a reply message. That is, looks for the next message
--   identified by the given reference.
mboxRecv' :: MBox -> ErlType -> IO ErlType

-- | {Node, Pid} ! Msg.
mboxSend :: Erlang a => MBox -> Node -> Pid -> a -> IO ()
data ErlType
ErlNull :: ErlType
ErlInt :: Int -> ErlType
ErlBigInt :: Integer -> ErlType
ErlString :: String -> ErlType
ErlAtom :: String -> ErlType
ErlBinary :: [Word8] -> ErlType
ErlList :: [ErlType] -> ErlType
ErlTuple :: [ErlType] -> ErlType
ErlPid :: ErlType -> Int -> Int -> Int -> ErlType
ErlPort :: ErlType -> Int -> Int -> ErlType
ErlRef :: ErlType -> Int -> Int -> ErlType
ErlNewRef :: ErlType -> Int -> [Word8] -> ErlType
class Erlang a
toErlang :: Erlang a => a -> ErlType
fromErlang :: Erlang a => ErlType -> a
nth :: Erlang a => Int -> ErlType -> a
getA :: Int -> Get [Char]
getC :: Get Int
getErl :: Get ErlType
getN :: Get Int
geta :: Int -> Get [Word8]
getn :: Get Int
putA :: String -> Put
putC :: Int -> Put
putErl :: ErlType -> PutM ()
putN :: Int -> Put
puta :: [Word8] -> Put
putn :: Int -> Put
tag :: Char -> Put

-- | Convert a tuple (from erlang:now()) to seconds from Jan 1, 1970.
erlangTimeToSeconds :: Integral a => ErlType -> a

-- | Convert seconds to an Erlang tuple representing time.
secondsToErlangTime :: Integral a => a -> ErlType
