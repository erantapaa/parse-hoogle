-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes and monads for unchecked extensible exceptions.
--   
@package exception-transformers
@version 0.4.0.1


module Control.Monad.Exception

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
class Monad m => MonadException m where act `finally` sequel = do { a <- act `onException` sequel; _ <- sequel; return a }
throw :: (MonadException m, Exception e) => e -> m a
catch :: (MonadException m, Exception e) => m a -> (e -> m a) -> m a
finally :: MonadException m => m a -> m b -> m a

-- | If an exception is raised by the computation, then perform a final
--   action and re-raise the exception.
onException :: MonadException m => m a -> m b -> m a
class (MonadIO m, MonadException m) => MonadAsyncException m
mask :: MonadAsyncException m => ((forall a. m a -> m a) -> m b) -> m b

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
bracket :: MonadAsyncException m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: MonadAsyncException m => m a -> m b -> m c -> m c
newtype ExceptionT m a
ExceptionT :: m (Either SomeException a) -> ExceptionT m a
runExceptionT :: ExceptionT m a -> m (Either SomeException a)
mapExceptionT :: (m (Either SomeException a) -> n (Either SomeException b)) -> ExceptionT m a -> ExceptionT n b

-- | Lift the result of running a computation in a monad transformed by
--   <a>ExceptionT</a> into another monad that supports exceptions.
liftException :: MonadException m => Either SomeException a -> m a
instance (Monoid w, MonadAsyncException m) => MonadAsyncException (WriterT w m)
instance (Monoid w, MonadAsyncException m) => MonadAsyncException (WriterT w m)
instance MonadAsyncException m => MonadAsyncException (StateT s m)
instance MonadAsyncException m => MonadAsyncException (StateT s m)
instance MonadAsyncException m => MonadAsyncException (ReaderT r m)
instance (Monoid w, MonadAsyncException m) => MonadAsyncException (RWST r w s m)
instance (Monoid w, MonadAsyncException m) => MonadAsyncException (RWST r w s m)
instance MonadAsyncException m => MonadAsyncException (MaybeT m)
instance MonadAsyncException m => MonadAsyncException (ListT m)
instance MonadAsyncException m => MonadAsyncException (IdentityT m)
instance MonadAsyncException m => MonadAsyncException (ExceptT e' m)
instance (MonadAsyncException m, Error e) => MonadAsyncException (ErrorT e m)
instance (Monoid w, MonadException m) => MonadException (WriterT w m)
instance (Monoid w, MonadException m) => MonadException (WriterT w m)
instance MonadException m => MonadException (StateT s m)
instance MonadException m => MonadException (StateT s m)
instance MonadException m => MonadException (ReaderT r m)
instance (Monoid w, MonadException m) => MonadException (RWST r w s m)
instance (Monoid w, MonadException m) => MonadException (RWST r w s m)
instance MonadException m => MonadException (MaybeT m)
instance MonadException m => MonadException (ListT m)
instance MonadException m => MonadException (IdentityT m)
instance MonadException m => MonadException (ExceptT e' m)
instance (MonadException m, Error e) => MonadException (ErrorT e m)
instance MonadException STM
instance MonadAsyncException IO
instance MonadException IO
instance MonadAsyncException m => MonadAsyncException (ExceptionT m)
instance MonadIO m => MonadIO (ExceptionT m)
instance Monad m => MonadException (ExceptionT m)
instance MonadFix m => MonadFix (ExceptionT m)
instance (Functor m, Monad m) => Alternative (ExceptionT m)
instance (Functor m, Monad m) => Applicative (ExceptionT m)
instance Monad m => MonadPlus (ExceptionT m)
instance Monad m => Monad (ExceptionT m)
instance Functor m => Functor (ExceptionT m)
instance MonadTrans ExceptionT
