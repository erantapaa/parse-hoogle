-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Command-Query Responsibility Segregation
--   
--   Haskell implementation of the CQRS architectural pattern.
@package cqrs
@version 0.9.0

module Data.CQRS.GUID


-- | Memory-based event store backend. Used primarily for testing.
module Data.CQRS.EventStore.Backend.Memory

-- | Memory-based event store backend.
data MemoryEventStoreBackend

-- | Pool of memory event store backends.
createBackendPool :: Int -> IO (Pool MemoryEventStoreBackend)
instance EventStoreBackend MemoryEventStoreBackend

module Data.CQRS.Serializable


-- | Module to import for the <a>Command</a> side of the application.
module Data.CQRS.Command

-- | Type class for aggregates.
class Serializable a => Aggregate a

-- | Aggregate root reference.
data AggregateRef a e

-- | Type class for applying events to aggregates.
class Eventable a e | a -> e
applyEvent :: Eventable a e => Maybe a -> e -> Maybe a

-- | Event stores are the backend used for reading and storing all the
--   information about recorded events.
class EventStoreBackend esb

-- | A Globally Unique IDentifier.
data GUID :: *

-- | Create a new random GUID.
newGUID :: IO GUID

-- | Repository consisting of an event store and an event bus.
data Repository e b

-- | UnitOfWork monad transformer.
data UnitOfWorkT e m a

-- | Add aggregate root. The aggregate root will be created upon
--   transaction commit.
createAggregate :: (Serializable e, Typeable a, Typeable e, Aggregate a, Eventable a e) => GUID -> UnitOfWorkT e IO (AggregateRef a e)

-- | Create or load aggregate. The aggregate root will be created (if
--   necessary) upon transaction commit.
createOrLoadAggregate :: (Serializable e, Typeable a, Typeable e, Aggregate a, Eventable a e) => GUID -> UnitOfWorkT e IO (AggregateRef a e)

-- | Find aggregate root.
findAggregate :: (Serializable e, Typeable a, Typeable e, Aggregate a, Eventable a e) => GUID -> UnitOfWorkT e IO (Maybe (AggregateRef a e, a))

-- | Load aggregate root. The aggregate root must exist.
loadAggregate :: (Serializable e, Typeable a, Typeable e, Aggregate a, Eventable a e) => GUID -> UnitOfWorkT e IO (AggregateRef a e, a)

-- | Publish event for an aggregate root.
publishEvent :: (MonadIO m, Serializable e, Typeable a, Typeable e, Aggregate a, Eventable a e, NFData a, NFData e) => AggregateRef a e -> e -> UnitOfWorkT e m ()

-- | Run transaction against an event store.
runUnitOfWorkT :: (Typeable e, Serializable e, EventStoreBackend b) => Repository e b -> UnitOfWorkT e IO c -> IO c

module Data.CQRS.Repository

-- | Repository consisting of an event store and an event bus.
data Repository e b

-- | Create a repository from a pool of event store backends.
newRepository :: (EventStoreBackend b, Show e, NFData e) => Settings -> Pool b -> IO (Repository e b)

-- | Repository settings
data Settings
settingsSnapshotFrequency :: Settings -> Maybe Int

-- | Default repository settings.
defaultSettings :: Settings

module Data.CQRS.Query

-- | Persisted Event.
data PersistedEvent e :: * -> *
PersistedEvent :: !GUID -> !e -> !Int -> PersistedEvent e

-- | GUID of the aggregate.
peAggregateGUID :: PersistedEvent e -> !GUID

-- | Event.
peEvent :: PersistedEvent e -> !e

-- | Sequence number within the aggregate.
peSequenceNumber :: PersistedEvent e -> !Int

-- | Event stores are the backend used for reading and storing all the
--   information about recorded events.
class EventStoreBackend esb

-- | A Globally Unique IDentifier.
data GUID :: *

-- | Repository consisting of an event store and an event bus.
data Repository e b

-- | Enumerate all events which satisfy criteria and stream all new events
--   from repository. All events which arrive while enumerating are
--   buffered until enumeration completes.
enumerateAndStreamEvents :: (Show e, Serializable e, EventStoreBackend b) => Repository e b -> Source (ResourceT IO) [PersistedEvent e]

-- | Enumerate all events which satisfy certain criteria from event store
--   associated with repository.
enumerateEventStore :: (Serializable e, EventStoreBackend b) => Repository e b -> Source (ResourceT IO) [PersistedEvent e]
