-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementationg of Attribute Grammars using Functional Zippers
--   
--   An implementationg of Attribute Grammars using Functional Zippers
@package ZipperAG
@version 0.9

module Language.Grammars.ZipperAG.Examples.HTMLTableFormatter
data R
RootR :: Table -> R
data Table
RootTable :: Rows -> Table
data Rows
NoRow :: Rows
ConsRow :: Row -> Rows -> Rows
data Row
OneRow :: Elems -> Row
data Elems
NoElem :: Elems
ConsElem :: Elem -> Elems -> Elems
data Elem
TableText :: String -> Elem
NestedTable :: Table -> Elem
constructor :: Zipper R -> String
(.$) :: Zipper a -> Int -> Zipper a
(.|) :: Zipper a -> Int -> Bool
parent :: Zipper a -> Zipper a
value :: Zipper a -> String
(.#.) :: Data a => (t -> a) -> t -> Zipper a
n_Syn :: Zipper R -> Int
ns_Syn :: Zipper R -> [Int]
ane_Inh :: Zipper R -> Int
r2 :: Zipper R -> R
r2_table :: Zipper R -> Table
r2_rows :: Zipper R -> Rows
r2_row :: Zipper R -> Row
r2_elems :: Zipper R -> Elems
r2_elem :: Zipper R -> Elem
mh_Syn :: (Num a, Ord a) => Zipper R -> a
mw_Syn :: Zipper R -> Int
mws_Syn :: Zipper R -> [Int]
lmw_Local :: Zipper R -> Int
ah_Inh :: (Num a, Ord a) => Zipper R -> a
aws_Inh :: Zipper R -> [Int]
aw_Inh :: Zipper R -> Int
lines_Syn :: Zipper R -> [String]
sumList :: [Int] -> Int
lengthList :: [a] -> Int
eq_zeros :: [a]
eq_zipwith_max :: [Int] -> [Int] -> [Int]
maxList :: [Int] -> Int
headList :: [Int] -> Int
tailList :: [a] -> [a]
eq_zipwith_cat :: [String] -> [String] -> [String]
add_border_line :: [String] -> [String]
addglue :: Int -> Int -> Int -> Int -> [String] -> String -> [String]
glue_horizontal :: Int -> Int -> [String] -> String -> [String]
add_hor :: String -> Int -> String -> String
hor_spaces :: Int -> String
glue_vertical_new :: Int -> [String] -> [String]
add_vertical :: Int -> [String]
add_sepline :: Int -> [String]
add_sep_line :: Int -> [String] -> [String] -> [String]
add_elems :: Int -> Elems
repeatChar :: Char -> Int -> String
nestedtable :: Table
elem1 :: Elem
elem2 :: Elem
row1 :: Rows
elem3 :: Elems
table :: R
printTable :: [String] -> String
ata :: Zipper R -> Zipper R
semantics :: R -> IO ()
instance Typeable Elem
instance Typeable Table
instance Typeable Rows
instance Typeable Row
instance Typeable Elems
instance Typeable R
instance Show Elem
instance Data Elem
instance Show Table
instance Data Table
instance Show Rows
instance Data Rows
instance Show Row
instance Data Row
instance Show Elems
instance Data Elems
instance Show R
instance Data R


-- | Zipper-based AG supporting functions
module Language.Grammars.ZipperAG

-- | Gives the n'th child
(.$) :: Zipper a -> Int -> Zipper a

-- | parent
parent :: Zipper a -> Zipper a

-- | Tests if z is the n'th sibling
(.|) :: Zipper a -> Int -> Bool

module Language.Grammars.ZipperAG.Examples.Algol68
data Root
Root :: Its -> Root
data Its
ConsIts :: It -> Its -> Its
NilIts :: Its
data It
Decl :: String -> It
Use :: String -> It
Block :: Its -> It
constructor :: Typeable a => Zipper a -> String
value :: Zipper a -> String
dclo :: Zipper Root -> [(String, Int)]
errs :: Zipper Root -> [String]
dcli :: Zipper Root -> [(String, Int)]
lev :: Zipper Root -> Int
env :: Zipper Root -> [(String, Int)]
block :: It
program :: Its
mBIn :: Eq a => a -> [(a, t)] -> [a]
mNBIn :: (Eq a, Eq b) => (a, b) -> [(a, b)] -> [a]
semantics :: Its -> [String]
instance Typeable It
instance Typeable Its
instance Typeable Root
instance Show It
instance Data It
instance Show Its
instance Data Its
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.BreadthFirst
data Root
Root :: Tree -> Root
data Tree
Fork :: Int -> Tree -> Tree -> Tree
Empty :: Tree
constructor :: Typeable a => Zipper a -> String
slist :: Zipper Root -> [Int]
replace :: Zipper Root -> Tree
ilist :: Zipper Root -> [Int]
tree :: Tree
semantics :: Tree
instance Typeable Tree
instance Typeable Root
instance Show Tree
instance Data Tree
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.RepMin
data Root
Root :: Tree -> Root
data Tree
Leaf :: Int -> Tree
Fork :: Tree -> Tree -> Tree
tree :: Root
constructor :: Zipper Root -> String
lexeme :: Zipper Root -> Int
globmin :: Zipper Root -> Int
locmin :: Zipper Root -> Int
replace :: Zipper Root -> Tree
semantics :: Root -> Tree
instance Typeable Tree
instance Typeable Root
instance Eq Tree
instance Ord Tree
instance Show Tree
instance Data Tree
instance Eq Root
instance Ord Root
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.SmartParentesis
data Root
Root :: Exp -> Root
data Exp
Add :: Exp -> Exp -> Exp
Mul :: Exp -> Exp -> Exp
Div :: Exp -> Exp -> Exp
Sub :: Exp -> Exp -> Exp
Lit :: Int -> Exp
constructor :: Zipper Root -> String
lexeme :: Zipper Root -> Int
enclosingOpPrecedence :: Zipper Root -> Int
leftOrRight :: Zipper Root -> String
bpp :: Zipper Root -> String
wrapInParens :: (Eq a1, Ord a) => a -> a -> a1 -> a1 -> Bool
exp2str :: Exp -> String
expr :: Root
semantics :: Root -> String
instance Typeable Exp
instance Typeable Root
instance Eq Exp
instance Ord Exp
instance Show Exp
instance Data Exp
instance Eq Root
instance Ord Root
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.DESK.DESK_circular
data Root
Root :: Program -> Root
data Program
PRINT :: Expression -> ConstPart -> Program
data Expression
Add :: Expression -> Factor -> Expression
Fact :: Factor -> Expression
data Factor
Name :: ConstName -> Factor
Number :: Int -> Factor
data ConstName
Id :: String -> ConstName
data ConstPart
EmptyConstPart :: ConstPart
WHERE :: ConstDefList -> ConstPart
data ConstDefList
Comma :: ConstDefList -> ConstDef -> ConstDefList
Def :: ConstDef -> ConstDefList
data ConstDef
EqualInt :: ConstName -> Int -> ConstDef
EqualString :: ConstName -> String -> ConstDef
envi :: Zipper Root -> Zipper Root_HO
code :: Zipper Root -> String
value :: Zipper Root -> Int
ok :: Zipper Root -> Bool
name :: Zipper Root -> String
envs :: Zipper Root -> SymbolTable
extract :: Zipper Root -> Tuple
data Root_HO
Root_HO :: SymbolTable -> Root_HO
data SymbolTable
NilST :: SymbolTable
ConsST :: Tuple -> SymbolTable -> SymbolTable
data Tuple
TupleInt :: String -> Int -> Tuple
TupleString :: String -> String -> Tuple
isInST :: String -> Zipper Root_HO -> Bool
getValue :: String -> Zipper Root_HO -> Int
solve :: Zipper Root_HO -> Zipper Root_HO
auxSolve :: Zipper Root_HO -> SymbolTable
check :: Zipper Root_HO -> Tuple
apply :: [(String, Int)] -> Tuple -> Tuple
solvedSymbols :: Zipper Root_HO -> [(String, Int)]
auxSolvedSymbols :: Zipper Root_HO -> [(String, Int)]
isSolved :: Zipper Root_HO -> Bool
auxIsSolved :: Zipper Root_HO -> Bool
expr :: Expression
deflst :: ConstPart
program :: Root
semantics :: Root -> IO ()
constructor :: Typeable a => Zipper a -> String
lexeme_Id :: Zipper a -> String
lexeme_Number :: Zipper a -> Int
lexeme_Equal_Int :: Zipper a -> Int
lexeme_Equal_String :: Zipper a -> String
constructor_HO :: Typeable a => Zipper a -> String
lexeme_Root :: Zipper a -> SymbolTable
lexeme_Tuple_name :: Zipper a -> String
lexeme_Tuple_Int :: Zipper a -> Tuple
lexeme_Tuple_String :: Zipper a -> Tuple
lexeme_Tuple_Int_Value :: Zipper a -> Int
lexeme_Tuple_String_Value :: Zipper a -> String
instance Typeable ConstName
instance Typeable Factor
instance Typeable Expression
instance Typeable ConstDef
instance Typeable ConstDefList
instance Typeable ConstPart
instance Typeable Program
instance Typeable Root
instance Typeable Tuple
instance Typeable SymbolTable
instance Typeable Root_HO
instance Show ConstName
instance Data ConstName
instance Show Factor
instance Data Factor
instance Show Expression
instance Data Expression
instance Show ConstDef
instance Data ConstDef
instance Show ConstDefList
instance Data ConstDefList
instance Show ConstPart
instance Data ConstPart
instance Show Program
instance Data Program
instance Show Root
instance Data Root
instance Show Tuple
instance Data Tuple
instance Show SymbolTable
instance Data SymbolTable
instance Data Root_HO
instance Show Root_HO

module Language.Grammars.ZipperAG.Examples.DESK.DESK_HighOrder
data Root
Root :: Program -> Root
data Program
PRINT :: Expression -> ConstPart -> Program
data Expression
Add :: Expression -> Factor -> Expression
Fact :: Factor -> Expression
data Factor
Name :: ConstName -> Factor
Number :: String -> Factor
data ConstName
Id :: String -> ConstName
data ConstPart
EmptyConstPart :: ConstPart
WHERE :: ConstDefList -> ConstPart
data ConstDefList
Comma :: ConstDefList -> ConstDef -> ConstDefList
Def :: ConstDef -> ConstDefList
data ConstDef
Equal :: ConstName -> String -> ConstDef
data SymbolTable
NilST :: SymbolTable
ConsST :: Tuple -> SymbolTable -> SymbolTable
data Tuple
Tuple :: String -> String -> Tuple
constructor :: Zipper Root -> String
constructor_HO :: Zipper Root_HO -> String
lexeme :: Zipper Root -> String
envi :: Zipper Root -> SymbolTable
code :: Zipper Root -> String
value :: Zipper Root -> String
ok :: Zipper Root -> Bool
name :: Zipper Root -> String
envs :: Zipper Root -> SymbolTable
data Root_HO
Root_HO :: SymbolTable -> Root_HO
lexeme_Tuple_name :: Zipper Root_HO -> String
lexeme_Tuple_value :: Zipper Root_HO -> String
isInST :: String -> Zipper Root_HO -> Bool
getValue :: String -> Zipper Root_HO -> String
expr :: Expression
deflst :: ConstPart
program :: Root
semantics :: Root -> IO ()
instance Typeable ConstName
instance Typeable Factor
instance Typeable Expression
instance Typeable ConstDef
instance Typeable ConstDefList
instance Typeable ConstPart
instance Typeable Program
instance Typeable Root
instance Typeable Tuple
instance Typeable SymbolTable
instance Typeable Root_HO
instance Show ConstName
instance Data ConstName
instance Show Factor
instance Data Factor
instance Show Expression
instance Data Expression
instance Show ConstDef
instance Data ConstDef
instance Show ConstDefList
instance Data ConstDefList
instance Show ConstPart
instance Data ConstPart
instance Show Program
instance Data Program
instance Show Root
instance Data Root
instance Show Tuple
instance Data Tuple
instance Show SymbolTable
instance Data SymbolTable
instance Data Root_HO
instance Show Root_HO

module Language.Grammars.ZipperAG.Examples.DESK.DESK_references
data Root
Root :: Program -> Root
data Program
PRINT :: Expression -> ConstPart -> Program
data Expression
Add :: Expression -> Factor -> Expression
Fact :: Factor -> Expression
data Factor
Name :: ConstName -> Factor
Number :: String -> Factor
data ConstName
Id :: String -> ConstName
data ConstPart
EmptyConstPart :: ConstPart
WHERE :: ConstDefList -> ConstPart
data ConstDefList
Comma :: ConstDefList -> ConstDef -> ConstDefList
Def :: ConstDef -> ConstDefList
data ConstDef
Equal :: ConstName -> String -> ConstDef
type SymbolTable = [(String, Zipper Root)]
constructor :: Zipper Root -> String
lexeme :: Zipper Root -> String
envi :: Zipper Root -> SymbolTable
code :: Zipper Root -> String
value :: Zipper Root -> String
ok :: Zipper Root -> Bool
name :: Zipper Root -> String
envs :: Zipper Root -> SymbolTable
isInST :: String -> SymbolTable -> Bool
getValue :: String -> SymbolTable -> String
expr :: Expression
deflst :: ConstPart
program :: Root
semantics :: Root -> IO ()
instance Typeable ConstName
instance Typeable Factor
instance Typeable Expression
instance Typeable ConstDef
instance Typeable ConstDefList
instance Typeable ConstPart
instance Typeable Program
instance Typeable Root
instance Show ConstName
instance Data ConstName
instance Show Factor
instance Data Factor
instance Show Expression
instance Data Expression
instance Show ConstDef
instance Data ConstDef
instance Show ConstDefList
instance Data ConstDefList
instance Show ConstPart
instance Data ConstPart
instance Show Program
instance Data Program
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.DESK.DESK
data Root
Root :: Program -> Root
data Program
PRINT :: Expression -> ConstPart -> Program
data Expression
Add :: Expression -> Factor -> Expression
Fact :: Factor -> Expression
data Factor
Name :: ConstName -> Factor
Number :: String -> Factor
data ConstName
Id :: String -> ConstName
data ConstPart
EmptyConstPart :: ConstPart
WHERE :: ConstDefList -> ConstPart
data ConstDefList
Comma :: ConstDefList -> ConstDef -> ConstDefList
Def :: ConstDef -> ConstDefList
data ConstDef
Equal :: ConstName -> String -> ConstDef
type SymbolTable = [(String, String)]
constructor :: Zipper Root -> String
lexeme :: Zipper Root -> String
envi :: Zipper Root -> SymbolTable
code :: Zipper Root -> String
value :: Zipper Root -> String
ok :: Zipper Root -> Bool
name :: Zipper Root -> String
envs :: Zipper Root -> SymbolTable
isInST :: String -> SymbolTable -> Bool
getValue :: String -> SymbolTable -> String
expr :: Expression
deflst :: ConstPart
program :: Root
semantics :: Root -> IO ()
instance Typeable ConstName
instance Typeable Factor
instance Typeable Expression
instance Typeable ConstDef
instance Typeable ConstDefList
instance Typeable ConstPart
instance Typeable Program
instance Typeable Root
instance Show ConstName
instance Data ConstName
instance Show Factor
instance Data Factor
instance Show Expression
instance Data Expression
instance Show ConstDef
instance Data ConstDef
instance Show ConstDefList
instance Data ConstDefList
instance Show ConstPart
instance Data ConstPart
instance Show Program
instance Data Program
instance Show Root
instance Data Root

module Language.Grammars.ZipperAG.Examples.LET.Let_DataTypes_Boilerplate
data Link
IsRootC :: RootC -> Link
IsLetC :: LetC -> Link
IsInC :: InC -> Link
IsListC :: ListC -> Link
IsE :: E -> Link
IsT :: T -> Link
IsF :: F -> Link
Empty :: Link
createLink :: Zipper a -> Link
getLink :: Zipper a -> Link
data RootC
RootC :: LetC -> RootC
data LetC
LetC :: ListC -> InC -> LetC
data InC
InC :: E -> InC
data ListC
ConsLetC :: String -> LetC -> ListC -> ListC
ConsAssignC :: String -> E -> ListC -> ListC
EmptyListC :: ListC
data E
Add :: E -> T -> E
Sub :: E -> T -> E
Et :: T -> E
data T
Mul :: T -> F -> T
Div :: T -> F -> T
Tf :: F -> T
data F
Nest :: E -> F
Neg :: F -> F
Var :: String -> F
Const :: Int -> F
data RootA
RootA :: LetA -> Link -> RootA
data LetA
LetA :: ListA -> InA -> Link -> LetA
data InA
InA :: A -> Link -> InA
data ListA
ConsLetA :: String -> LetA -> ListA -> Link -> ListA
ConsAssignA :: String -> A -> ListA -> Link -> ListA
EmptyListA :: Link -> ListA
data A
Plus :: A -> A -> Link -> A
Minus :: A -> A -> Link -> A
Time :: A -> A -> Link -> A
Divide :: A -> A -> Link -> A
Variable :: String -> Link -> A
Constant :: Int -> Link -> A
lexeme_ConsAssignC :: Zipper a -> String
lexme_LetA_2 :: Zipper a -> InA
lexeme_InA :: Zipper a -> A
lexeme_ConsLetC :: Zipper a -> String
lexeme_Var :: Zipper a -> String
lexeme_Const :: Zipper a -> Int
lexeme_ConsAssignA_1 :: Zipper a -> String
lexeme_ConsAssignA_2 :: Zipper a -> A
lexeme_ConsLetA_1 :: Zipper a -> String
lexeme_ConsLetA_2 :: Zipper a -> LetA
lexeme_Variable :: Zipper a -> String
lexeme_Constant :: Zipper a -> Int
constructor :: Zipper a -> String
instance Typeable F
instance Typeable E
instance Typeable T
instance Typeable InC
instance Typeable LetC
instance Typeable ListC
instance Typeable RootC
instance Typeable Link
instance Typeable A
instance Typeable InA
instance Typeable LetA
instance Typeable ListA
instance Typeable RootA
instance Show F
instance Data F
instance Show E
instance Data E
instance Show T
instance Data T
instance Show InC
instance Data InC
instance Show LetC
instance Data LetC
instance Show ListC
instance Data ListC
instance Show RootC
instance Data RootC
instance Show Link
instance Data Link
instance Show A
instance Data A
instance Show InA
instance Data InA
instance Show LetA
instance Data LetA
instance Show ListA
instance Data ListA
instance Show RootA
instance Data RootA

module Language.Grammars.ZipperAG.Examples.LET.Let_Bidi
getRootC_RootA :: Zipper a -> RootA
getLetC_LetA :: Zipper a -> LetA
getInC_IntA :: Zipper a -> InA
getListC_ListA :: Zipper a -> ListA
getE_A :: Zipper a -> A
getT_A :: Zipper a -> A
getF_A :: Zipper a -> A
putRootA_RootC :: Zipper a -> RootC
putLetA_LetC :: Zipper a -> LetC
putInA_IntC :: Zipper a -> InC
putListA_ListC :: Zipper a -> ListC
putA_E :: Zipper a -> E
putA_T :: Zipper a -> T
putA_F :: Zipper a -> F

module Language.Grammars.ZipperAG.Examples.LET.Let_No_Blocks
dclo :: Zipper RootA -> [String]
errs :: Zipper RootA -> [String]
dcli :: Zipper RootA -> [String]
env :: Zipper RootA -> [String]
mBIn :: String -> [String] -> [String]
mNBIn :: String -> [String] -> [String]
test_scope_no_block_rules :: Data a => a -> [String]

module Language.Grammars.ZipperAG.Examples.LET.Let_Scope
dclo :: Zipper RootA -> [(String, Zipper RootA)]
errs :: Zipper RootA -> [String]
dcli :: Zipper RootA -> [(String, Zipper RootA)]
env :: Zipper RootA -> [(String, Zipper RootA)]
lev :: Zipper RootA -> Int
mBIn :: String -> [(String, Zipper RootA)] -> [String]
mNBIn :: (String, Zipper RootA) -> [(String, Zipper RootA)] -> [String]
test_scope_block_rules :: Data a => a -> [String]

module Language.Grammars.ZipperAG.Examples.LET.Let_Circular_Flatening
data VarList
VarList :: String -> VarList -> VarList
NoVar :: VarList
pointFree :: Zipper a -> (Zipper a -> Bool) -> (Zipper a -> b) -> (Zipper a -> Zipper a) -> b
solve :: Zipper RootA -> Zipper RootA
isSolved :: Zipper RootA -> Bool
isSolvable :: Zipper RootA -> Bool
flatAG :: Zipper RootA -> RootA
flatLetAG :: Zipper RootA -> LetA
flatListAG :: Zipper RootA -> ListA
isConstant :: Zipper RootA -> Bool
calculate :: Zipper RootA -> Int
getVarValue :: String -> Zipper RootA -> Int
auxGetVarValue :: String -> Zipper RootA -> Int
oneUpGetVarValue :: String -> Zipper RootA -> Int
isVarSolved :: String -> Zipper RootA -> Bool
auxIsVarSolved :: String -> Zipper RootA -> Bool
oneUpIsVarSolved :: String -> Zipper RootA -> Bool
flatten_Let :: Data a => a -> Zipper RootA

module Language.Grammars.ZipperAG.Examples.LET.Let_Meaning_HO_NestedST_Circ
solve :: Zipper RootA -> Int
pointFree :: Zipper a -> (Zipper a -> Bool) -> (Zipper a -> b) -> (Zipper a -> Zipper a) -> b
solveSTRoot :: Zipper RootHO -> Zipper RootHO
solveST :: Zipper RootHO -> ListHO
calculate :: Zipper RootHO -> Int
getVarValue :: String -> Zipper RootHO -> Int
auxGetVarValue :: String -> Zipper RootHO -> Int
oneUpGetVarValue :: String -> Zipper RootHO -> Int
isSolved :: Zipper RootHO -> Bool
isVarSolved :: String -> Zipper RootHO -> Bool
auxIsVarSolved :: String -> Zipper RootHO -> Bool
oneUpIsVarSolved :: String -> Zipper RootHO -> Bool
createSTRoot :: Zipper RootA -> RootHO
createST :: Zipper RootA -> ListHO
data RootHO
RootHO :: ListHO -> A -> RootHO
data ListHO
ConsVarHO :: String -> IsSolved -> A -> ListHO -> ListHO
ConsLetHO :: String -> IsSolved -> ListHO -> ListHO -> ListHO
NestedListHO :: ListHO -> A -> ListHO
EmptyListHO :: ListHO
data IsSolved
IsSolved :: Int -> IsSolved
NotSolved :: IsSolved
lexeme_IsSolved :: Zipper a -> Int
lexeme_RootHO :: Zipper a -> A
lexeme_ConsVarHO_Var :: Zipper a -> String
lexeme_ConsVarHO_isSolved :: Zipper a -> IsSolved
lexeme_ConsVarHO_A :: Zipper a -> A
lexeme_ConsLetHO_Var :: Zipper a -> String
lexeme_ConsLetHO_isSolved :: Zipper a -> IsSolved
lexeme_ConsLetHO_NestedST :: Zipper a -> ListHO
lexeme_NestedListHO :: Zipper a -> A
constructorHO :: Zipper a -> String
solve_ho_plus_circularity :: Data a => a -> Int
instance Typeable IsSolved
instance Typeable ListHO
instance Typeable RootHO
instance Show IsSolved
instance Data IsSolved
instance Show ListHO
instance Data ListHO
instance Show RootHO
instance Data RootHO

module Language.Grammars.ZipperAG.Examples.LET.ExampleLet
a1 :: Integer
a :: RootC
b1 :: Integer
b :: RootC
c1 :: Integer
c :: RootC
d1 :: Integer
d :: RootC
e1 :: Integer
e :: RootC
f1 :: Integer
f :: RootC
scope_no_blocks :: Data a => a -> [String]
scope_with_blocks :: Data a => a -> [String]
flatten :: Data a => a -> Maybe RootA
solve_after_flattening :: Data a => a -> Int
solve_circ_plus_ho :: Data a => a -> Int
