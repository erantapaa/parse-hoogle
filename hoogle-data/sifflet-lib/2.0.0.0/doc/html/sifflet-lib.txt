-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library of modules shared by sifflet and its
tests and its exporters.
--   
--   Supporting modules for the Sifflet visual, functional programming
--   language (Hackage <a>sifflet</a> package). Version 2.0.0.0 adds
--   partial support for higher-order functions, like map and filter.
@package sifflet-lib
@version 2.0.0.0

module Text.Sifflet.Pretty

-- | The class of types that can be pretty-printed. (Unfortunately this is
--   not very useful, because and Expr can be pretty Haskell or pretty
--   Python or pretty Scheme, leading to overlapping instance
--   declarations.)
--   
--   pretty x is a pretty String representation of x. prettyList prefix
--   infix postfix xs is a pretty String representation of the list xs,
--   with prefix, infix, and postfix specifying the punctuation. For
--   example, if (pretty x) =&gt; <a>x</a>, then prettyList <a>[</a> <a>,
--   </a> <a>]</a> [x, x, x] =&gt; <a>[x, x, x]</a>.
--   
--   Minimal complete implementation: define pretty.
class Pretty a where prettyList pre tween post xs = pre ++ intercalate tween (map pretty xs) ++ post
pretty :: Pretty a => a -> String
prettyList :: Pretty a => String -> String -> String -> [a] -> String

-- | Indent a single line n spaces.
indentLine :: Int -> String -> String

-- | sepLines is like unlines, but omits the n at the end of the last line.
sepLines :: [String] -> String

-- | sepLines2 is like sepLines, but adds an extra n between each pair of
--   lines so they are <a>double spaced.</a>
sepLines2 :: [String] -> String

-- | Separate strings by commas and nothing else (<a>,</a>)
sepComma :: [String] -> String

-- | Separate strings by commas and spaces (<a>, </a>)
sepCommaSp :: [String] -> String

-- | Separate strings by just spaces (<a> </a>)
sepSpace :: [String] -> String


-- | Provides a function to set the cursor to a specified shape.
--   Generalized from an example in email Re: [Gtk2hs-users] Changing the
--   mouse cursor shape From: Chris Mears <a>chris@cm...</a> - 2007-05-22
--   07:48 found on
--   https:<i></i>sourceforge.net<i>mailarchive</i>forum.php?thread_name=87ps50ie9o.fsf%40loki.cmears.id.au&amp;forum_name=gtk2hs-users
--   and modified by removing the definition of data Cursor since that is
--   now part of gtk2hs/gtk although the enum values are not :-(
module Graphics.UI.Sifflet.GtkForeign

-- | Set the X Window cursor for a window to a specified type
setCursor :: Window -> CursorType -> IO ()


-- | The purpose of this module is simply to re-export the Gtk functions
--   and types that I use, and avoid those that I don't, particularly those
--   that conflict with names in Sifflet, like Layout. Just hiding these is
--   not enough, because Graphics.UI.Gtk keeps changing what it exports.
--   For example, in 0.10.5 it no longer exports Function, fill, function.
module Graphics.UI.Sifflet.LittleGtk

-- | A set or update operation on an attribute.
data AttrOp o :: * -> *

-- | Assign a value to an attribute.
(:=) :: ReadWriteAttr o a b -> b -> AttrOp o

-- | Apply an update function to an attribute.
(:~) :: ReadWriteAttr o a b -> (a -> b) -> AttrOp o

-- | Assign the result of an IO action to an attribute.
(:=>) :: ReadWriteAttr o a b -> IO b -> AttrOp o

-- | Apply a IO update function to an attribute.
(:~>) :: ReadWriteAttr o a b -> (a -> IO b) -> AttrOp o

-- | Assign a value to an attribute with the object as an argument.
(::=) :: ReadWriteAttr o a b -> (o -> b) -> AttrOp o

-- | Apply an update function to an attribute with the object as an
--   argument.
(::~) :: ReadWriteAttr o a b -> (o -> a -> b) -> AttrOp o

-- | Get an Attr of an object.
get :: o -> ReadWriteAttr o a b -> IO a

-- | Set a number of properties for some object.
set :: o -> [AttrOp o] -> IO ()

-- | Creates a new <a>Adjustment</a>.
--   
--   The creation function take every value that is contained in the
--   object: <tt>value</tt> is the initial value and should be between the
--   <tt>upper</tt> and <tt>lower</tt> bounds of the slider. Clicking on
--   the arrows increases this value by <tt>stepIncrement</tt>. Clicking in
--   the slider advances by <tt>pageIncrement</tt>. The <tt>pageSize</tt>
--   is needed to determine if the end of the slider is still in the range.
adjustmentNew :: Double -> Double -> Double -> Double -> Double -> Double -> IO Adjustment

-- | Adds the <tt>child</tt> widget to the box, packed with reference to
--   the end of the box. The <tt>child</tt> is packed after (away from end
--   of) any other child packed with reference to the end of the box.
--   
--   Note that for <a>boxPackEnd</a> the <a>PackNatural</a> option will
--   move a child to the right in an <a>HBox</a> or to the bottom in an
--   <a>VBox</a> if there is more space availble.
boxPackEnd :: (BoxClass self, WidgetClass child) => self -> child -> Packing -> Int -> IO ()

-- | Adds the <tt>child</tt> widget to the box, packed with reference to
--   the start of the box. The <tt>child</tt> is packed after any other
--   child packed with reference to the start of the box.
boxPackStart :: (BoxClass self, WidgetClass child) => self -> child -> Packing -> Int -> IO ()

-- | Like <a>boxPackStart</a> but uses the default parameters
--   <a>PackRepel</a> and 0 for padding.
boxPackStartDefaults :: (BoxClass self, WidgetClass widget) => self -> widget -> IO ()
data Button :: *

-- | Creates a <a>Button</a> widget with a <a>Label</a> child containing
--   the given text.
buttonNewWithLabel :: String -> IO Button

-- | A mouse button has been depressed while the mouse pointer was within
--   the widget area. Sets the widget's <a>ButtonPressMask</a> flag.
buttonPressEvent :: WidgetClass self => Signal self (EventM EButton Bool)

-- | Specify what buttons this dialog should show.
--   
--   <ul>
--   <li>Prebuilt sets of buttons for the dialog. If none of these choices
--   are appropriate, simply use <a>ButtonsNone</a> then call
--   <tt>dialogAddButtons</tt>.</li>
--   </ul>
data ButtonsType :: *
ButtonsNone :: ButtonsType
ButtonsOk :: ButtonsType
ButtonsClose :: ButtonsType
ButtonsCancel :: ButtonsType
ButtonsYesNo :: ButtonsType
ButtonsOkCancel :: ButtonsType
class WidgetClass o => ContainerClass o
castToContainer :: GObjectClass obj => obj -> Container

-- | Adds <tt>widget</tt> to the container. Typically used for simple
--   containers such as <a>Window</a>, <a>Frame</a>, or <a>Button</a>; for
--   more complicated layout containers such as <a>Box</a> or <a>Table</a>,
--   this function will pick default packing parameters that may not be
--   correct. So consider functions such as <tt>boxPackStart</tt> and
--   <tt>tableAttach</tt> as an alternative to <a>containerAdd</a> in those
--   cases. A widget may be added to only one container at a time; you
--   can't place the same widget inside two different containers.
containerAdd :: (ContainerClass self, WidgetClass widget) => self -> widget -> IO ()

-- | Can be used to add a new child to the container.
containerChild :: (ContainerClass self, WidgetClass widget) => WriteAttr self widget

-- | Maps <tt>callback</tt> over each non-internal child of
--   <tt>container</tt>. See <a>containerForall</a> for details on what
--   constitutes an "internal" child. Most applications should use
--   <a>containerForeach</a>, rather than <a>containerForall</a>.
containerForeach :: ContainerClass self => self -> ContainerForeachCB -> IO ()

-- | Returns the container's non-internal children. See
--   <a>containerForall</a> for details on what constitutes an "internal"
--   child.
containerGetChildren :: ContainerClass self => self -> IO [Widget]

-- | Cursor types.
data CursorType :: *
XCursor :: CursorType
Arrow :: CursorType
BasedArrowDown :: CursorType
BasedArrowUp :: CursorType
Boat :: CursorType
Bogosity :: CursorType
BottomLeftCorner :: CursorType
BottomRightCorner :: CursorType
BottomSide :: CursorType
BottomTee :: CursorType
BoxSpiral :: CursorType
CenterPtr :: CursorType
Circle :: CursorType
Clock :: CursorType
CoffeeMug :: CursorType
Cross :: CursorType
CrossReverse :: CursorType
Crosshair :: CursorType
DiamondCross :: CursorType
Dot :: CursorType
Dotbox :: CursorType
DoubleArrow :: CursorType
DraftLarge :: CursorType
DraftSmall :: CursorType
DrapedBox :: CursorType
Exchange :: CursorType
Fleur :: CursorType
Gobbler :: CursorType
Gumby :: CursorType
Hand1 :: CursorType
Hand2 :: CursorType
Heart :: CursorType
Icon :: CursorType
IronCross :: CursorType
LeftPtr :: CursorType
LeftSide :: CursorType
LeftTee :: CursorType
Leftbutton :: CursorType
LlAngle :: CursorType
LrAngle :: CursorType
Man :: CursorType
Middlebutton :: CursorType
Mouse :: CursorType
Pencil :: CursorType
Pirate :: CursorType
Plus :: CursorType
QuestionArrow :: CursorType
RightPtr :: CursorType
RightSide :: CursorType
RightTee :: CursorType
Rightbutton :: CursorType
RtlLogo :: CursorType
Sailboat :: CursorType
SbDownArrow :: CursorType
SbHDoubleArrow :: CursorType
SbLeftArrow :: CursorType
SbRightArrow :: CursorType
SbUpArrow :: CursorType
SbVDoubleArrow :: CursorType
Shuttle :: CursorType
Sizing :: CursorType
Spider :: CursorType
Spraycan :: CursorType
Star :: CursorType
Target :: CursorType
Tcross :: CursorType
TopLeftArrow :: CursorType
TopLeftCorner :: CursorType
TopRightCorner :: CursorType
TopSide :: CursorType
TopTee :: CursorType
Trek :: CursorType
UlAngle :: CursorType
Umbrella :: CursorType
UrAngle :: CursorType
Watch :: CursorType
Xterm :: CursorType
LastCursor :: CursorType
BlankCursor :: CursorType
CursorIsPixmap :: CursorType

-- | Set or update a column mapping. This function should be used before
--   the model is installed into a widget since the number of defined
--   columns are only checked once by widgets.
customStoreSetColumn :: TypedTreeModelClass model => model row -> ColumnId row ty -> (row -> ty) -> IO ()
data Dialog :: *

-- | Creates a new dialog box. Widgets should not be packed into this
--   <a>Window</a> directly, but into the "upper" and "action area", which
--   are obtained using <a>dialogGetUpper</a> and
--   <a>dialogGetActionArea</a>.
dialogNew :: IO Dialog

-- | Adds a button with the given text (or a stock button, if
--   <tt>buttonText</tt> is a stock ID) and sets things up so that clicking
--   the button will emit the "response" signal with the given
--   <tt>responseId</tt>. The button is appended to the end of the dialog's
--   action area. The button widget is returned, but usually you don't need
--   it.
dialogAddButton :: DialogClass self => self -> String -> ResponseId -> IO Button

-- | Extract the action area of a dialog box.
--   
--   <ul>
--   <li>This is useful to add some special widgets that cannot be added
--   with dialogAddActionWidget.</li>
--   </ul>
dialogGetActionArea :: DialogClass dc => dc -> IO HBox

-- | Get the upper part of a dialog.
--   
--   <ul>
--   <li>The upper part of a dialog window consists of a <a>VBox</a>. Add
--   the required widgets into this box.</li>
--   </ul>
dialogGetUpper :: DialogClass dc => dc -> IO VBox

-- | Blocks in a recursive main loop until the dialog either emits the
--   response signal, or is destroyed. If the dialog is destroyed during
--   the call to <a>dialogRun</a>, it returns <a>ResponseNone</a>.
--   Otherwise, it returns the response ID from the "response" signal
--   emission. Before entering the recursive main loop, <a>dialogRun</a>
--   calls <tt>widgetShow</tt> on the dialog for you. Note that you still
--   need to show any children of the dialog yourself.
--   
--   During <a>dialogRun</a>, the default behavior of "delete_event" is
--   disabled; if the dialog receives "delete_event", it will not be
--   destroyed as windows usually are, and <a>dialogRun</a> will return
--   <a>ResponseDeleteEvent</a>. Also, during <a>dialogRun</a> the dialog
--   will be modal. You can force <a>dialogRun</a> to return at any time by
--   calling <a>dialogResponse</a> to emit the "response" signal.
--   Destroying the dialog during <a>dialogRun</a> is a very bad idea,
--   because your post-run code won't know whether the dialog was destroyed
--   or not. Hence, you should not call <a>widgetDestroy</a> before
--   <a>dialogRun</a> has returned.
--   
--   After <a>dialogRun</a> returns, you are responsible for hiding or
--   destroying the dialog if you wish to do so.
--   
--   Note that even though the recursive main loop gives the effect of a
--   modal dialog (it prevents the user from interacting with other windows
--   while the dialog is run), callbacks such as timeouts, IO channel
--   watches, DND drops, etc, <i>will</i> be triggered during a
--   <a>dialogRun</a> call.
dialogRun :: DialogClass self => self -> IO ResponseId

-- | Sets the last widget in the dialog's action area with the given
--   <a>ResponseId</a> as the default widget for the dialog. Pressing
--   "Enter" normally activates the default widget.
--   
--   <ul>
--   <li>The default response is reset once it is triggered. Hence, if you
--   hide the dialog (rather than closing it) and re-display it later, you
--   need to call this function again.</li>
--   </ul>
dialogSetDefaultResponse :: DialogClass self => self -> ResponseId -> IO ()
toDialog :: DialogClass o => o -> Dialog
data DrawWindow :: *

-- | A convenience wrapper around <a>drawWindowInvalidateRegion</a> which
--   invalidates a rectangular region. See
--   <a>drawWindowInvalidateRegion</a> for details.
drawWindowInvalidateRect :: DrawWindowClass self => self -> Rectangle -> Bool -> IO ()

-- | Requests a prefix insertion.
--   
--   <ul>
--   <li>Available since Gtk+ version 2.6</li>
--   </ul>
entryCompletionInsertPrefix :: EntryCompletion -> IO ()

-- | The model to find matches in.
entryCompletionModel :: TreeModelClass model => ReadWriteAttr EntryCompletion (Maybe TreeModel) (Maybe model)

-- | Creates a new <a>EntryCompletion</a> object.
entryCompletionNew :: IO EntryCompletion

-- | Convenience function for setting up the most used case of this code: a
--   completion list with just strings. This function will set up
--   <tt>completion</tt> to have a list displaying all (and just) strings
--   in the completion list, and to get those strings from <tt>column</tt>
--   in the model of <tt>completion</tt>.
--   
--   This functions creates and adds a <a>CellRendererText</a> for the
--   selected column.
entryCompletionSetTextColumn :: EntryCompletion -> ColumnId row String -> IO ()
data Entry :: *

-- | Retrieves the contents of the entry widget. See also
--   <a>editableGetChars</a>.
entryGetText :: EntryClass self => self -> IO String

-- | Returns the auxiliary completion object currently in use by the entry.
--   
--   <ul>
--   <li>Available since Gtk version 2.4</li>
--   </ul>
entryGetCompletion :: EntryClass self => self -> IO EntryCompletion

-- | Creates a new <a>Entry</a> widget.
entryNew :: IO Entry

-- | Sets the auxiliary completion object to use with the entry. All
--   further configuration of the completion mechanism is done on
--   completion using the <a>EntryCompletion</a> API.
--   
--   <ul>
--   <li>Available since Gtk version 2.4</li>
--   </ul>
entrySetCompletion :: EntryClass self => self -> EntryCompletion -> IO ()

-- | Sets the text in the widget to the given value, replacing the current
--   contents.
entrySetText :: EntryClass self => self -> String -> IO ()

-- | Specify which events a widget will emit signals on.
data EventMask :: *
ExposureMask :: EventMask
PointerMotionMask :: EventMask
PointerMotionHintMask :: EventMask
ButtonMotionMask :: EventMask
Button1MotionMask :: EventMask
Button2MotionMask :: EventMask
Button3MotionMask :: EventMask
ButtonPressMask :: EventMask
ButtonReleaseMask :: EventMask
KeyPressMask :: EventMask
KeyReleaseMask :: EventMask
EnterNotifyMask :: EventMask
LeaveNotifyMask :: EventMask
FocusChangeMask :: EventMask
StructureMask :: EventMask
PropertyChangeMask :: EventMask
VisibilityNotifyMask :: EventMask
ProximityInMask :: EventMask
ProximityOutMask :: EventMask
SubstructureMask :: EventMask
ScrollMask :: EventMask
AllEventsMask :: EventMask

-- | Creates a new <a>EventBox</a>.
eventBoxNew :: IO EventBox
data Expander :: *

-- | Creates a new expander using the given string as the text of the
--   label.
expanderNew :: String -> IO Expander

-- | Sets the state of the expander. Set to <tt>True</tt>, if you want the
--   child widget to be revealed, and <tt>False</tt> if you want the child
--   widget to be hidden.
expanderSetExpanded :: Expander -> Bool -> IO ()

-- | Instructs the widget to redraw.
--   
--   <ul>
--   <li>The <a>DrawWindow</a> that needs to be redrawn is available via
--   <tt>eventWindow</tt>.</li>
--   <li>The part that needs to be redrawn is available via
--   <a>eventArea</a> and <a>eventRegion</a>. The options are, in order of
--   efficiency: (a) redraw the entire window, (b) ask for the
--   <a>eventArea</a> and redraw that rectangle, (c) ask for the
--   <a>eventRegion</a> and redraw each of those rectangles.</li>
--   </ul>
--   
--   Only the exposed region will be updated; see also
--   <tt>drawWindowBeginPaintRegion</tt>.
exposeEvent :: WidgetClass self => Signal self (EventM EExpose Bool)

-- | Creates a new <a>FileChooserDialog</a>.
fileChooserDialogNew :: Maybe String -> Maybe Window -> FileChooserAction -> [(String, ResponseId)] -> IO FileChooserDialog

-- | Gets the filename for the currently selected file in the file
--   selector. If multiple files are selected, one of the filenames will be
--   returned at random.
--   
--   If the file chooser is in folder mode, this function returns the
--   selected folder.
fileChooserGetFilename :: FileChooserClass self => self -> IO (Maybe FilePath)

-- | Describes whether a <a>FileChooser</a> is being used to open existing
--   files or to save to a possibly new file.
data FileChooserAction :: *
FileChooserActionOpen :: FileChooserAction
FileChooserActionSave :: FileChooserAction
FileChooserActionSelectFolder :: FileChooserAction
FileChooserActionCreateFolder :: FileChooserAction

-- | Creates a new <a>Frame</a> without a label.
--   
--   <ul>
--   <li>A label can later be set by calling <a>frameSetLabel</a>.</li>
--   </ul>
frameNew :: IO Frame

-- | Sets the text of the label.
frameSetLabel :: FrameClass self => self -> String -> IO ()

-- | add a grab widget
grabAdd :: WidgetClass wd => wd -> IO ()

-- | remove a grab widget
grabRemove :: WidgetClass w => w -> IO ()
data HBox :: *

-- | Creates a new <a>HBox</a>.
hBoxNew :: Bool -> Int -> IO HBox

-- | A key has been depressed. Sets the widget's <a>KeyPressMask</a> flag.
keyPressEvent :: WidgetClass self => Signal self (EventM EKey Bool)
data Label :: *

-- | Creates a new label with the given text inside it. You can pass
--   <tt>Nothing</tt> to get an empty label widget.
labelNew :: Maybe String -> IO Label

-- | Sets the text within the <a>Label</a> widget. It overwrites any text
--   that was there before.
--   
--   This will also clear any previously set mnemonic accelerators.
labelSetText :: LabelClass self => self -> String -> IO ()
data Layout :: *

-- | Retrieves the <a>Drawable</a> part.
layoutGetDrawWindow :: Layout -> IO DrawWindow

-- | Creates a new <a>Layout</a>. Unless you have a specific adjustment
--   you'd like the layout to use for scrolling, pass <tt>Nothing</tt> for
--   <tt>hadjustment</tt> and <tt>vadjustment</tt>.
layoutNew :: Maybe Adjustment -> Maybe Adjustment -> IO Layout

-- | Adds <tt>childWidget</tt> to <tt>layout</tt>, at position
--   <tt>(x,y)</tt>. <tt>layout</tt> becomes the new parent container of
--   <tt>childWidget</tt>.
layoutPut :: (LayoutClass self, WidgetClass childWidget) => self -> childWidget -> Int -> Int -> IO ()

-- | Sets the size of the scrollable area of the layout.
layoutSetSize :: LayoutClass self => self -> Int -> Int -> IO ()

-- | Create a new <a>TreeModel</a> that contains a list of elements.
listStoreNew :: [a] -> IO (ListStore a)

-- | Create a <a>ColumnId</a> to extract an string.
makeColumnIdString :: Int -> ColumnId row String

-- | Popup a context menu where a button press occurred.
--   
--   <ul>
--   <li>This function must be called in response to a button click. It
--   opens the given menu at a place determined by the last emitted event
--   (hence the requirement that this function is called as response to a
--   button press signal).</li>
--   </ul>
menuPopup :: MenuClass self => self -> Maybe (MouseButton, TimeStamp) -> IO ()
data MessageType :: *
MessageInfo :: MessageType
MessageWarning :: MessageType
MessageQuestion :: MessageType
MessageError :: MessageType
MessageOther :: MessageType

-- | Create a new message dialog, which is a simple dialog with an icon
--   indicating the dialog type (error, warning, etc.) and some text the
--   user may want to see. When the user clicks a button a "response"
--   signal is emitted with response IDs from <tt>ResponseType</tt>. See
--   <a>Dialog</a> for more details.
messageDialogNew :: Maybe Window -> [DialogFlags] -> MessageType -> ButtonsType -> String -> IO MessageDialog

-- | Perform an action in response to a signal.
--   
--   Use it like this:
--   
--   <pre>
--   on obj sig $ do
--   ...
--   </pre>
--   
--   or if the signal handler takes any arguments:
--   
--   <pre>
--   on obj sig $ \args -&gt; do
--   ...
--   </pre>
on :: object -> Signal object callback -> callback -> IO (ConnectId object)

-- | The widget will be destroyed.
--   
--   <ul>
--   <li>This is the last signal this widget will receive.</li>
--   </ul>
onDestroy :: WidgetClass w => w -> IO () -> IO (ConnectId w)

-- | Query the widget for the size it likes to have.
--   
--   <ul>
--   <li>A parent container emits this signal to its child to query the
--   needed height and width of the child. There is not guarantee that the
--   widget will actually get this area.</li>
--   </ul>
onSizeRequest :: WidgetClass w => w -> IO Requisition -> IO (ConnectId w)

-- | Packing parameters of a widget
--   
--   <ul>
--   <li>The <a>Packing</a> parameter determines how the child behaves in
--   the horizontal or vertical way in an <a>HBox</a> or <a>VBox</a>,
--   respectively. <a>PackNatural</a> means the child is as big as it
--   reqests. It will stay at the start of the end of a <a>Box</a> if there
--   is more space available. All children packed with <a>PackRepel</a>
--   will be padded on both sides with additional space. <a>PackGrow</a>
--   will increase the size of a widget so that it covers the available
--   space. A menu bar, for instance, should always stay at the top of a
--   window and should only occupy as little space as possible. Hence it
--   should be packed at the start of a <a>VBox</a> with the packing option
--   <a>PackNatural</a>. The working area of a window (e.g. the text area
--   in an editor) should expand when the window is resized. Here the
--   packing option <a>PackGrow</a> is the right choice and it is
--   irrelevant whether the main area is inserted at the start or the end
--   of a box. Finally <a>PackRepel</a> is most useful in a window where no
--   widget can make use of excess space. Examples include a dialog box
--   without list boxes or text fields.</li>
--   </ul>
data Packing :: *
PackRepel :: Packing
PackGrow :: Packing
PackNatural :: Packing
data PolicyType :: *
PolicyAutomatic :: PolicyType

-- | Rectangle
--   
--   <ul>
--   <li>Specifies x, y, width and height</li>
--   </ul>
data Rectangle :: *
Rectangle :: Int -> Int -> Int -> Int -> Rectangle

-- | Creates a Cairo context for drawing to a <a>Drawable</a>.
renderWithDrawable :: DrawableClass drawable => drawable -> Render a -> IO a

-- | Requisition
--   
--   <ul>
--   <li>For <a>widgetSizeRequest</a>. The values represent the desired
--   width and height of the widget.</li>
--   </ul>
data Requisition :: *
Requisition :: Int -> Int -> Requisition

-- | Some constructors that can be used as response numbers for dialogs.
data ResponseId :: *

-- | GTK returns this if a response widget has no <tt>response_id</tt>, or
--   if the dialog gets programmatically hidden or destroyed.
ResponseNone :: ResponseId

-- | GTK won't return these unless you pass them in as the response for an
--   action widget. They are for your convenience.
ResponseReject :: ResponseId

-- | (as above)
ResponseAccept :: ResponseId

-- | If the dialog is deleted.
ResponseDeleteEvent :: ResponseId

-- | "Ok" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "Ok" stock dialog button.</li>
--   </ul>
ResponseOk :: ResponseId

-- | "Cancel" was pressed.
--   
--   <ul>
--   <li>These value is returned from the "Cancel" stock dialog
--   button.</li>
--   </ul>
ResponseCancel :: ResponseId

-- | "Close" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "Close" stock dialog button.</li>
--   </ul>
ResponseClose :: ResponseId

-- | "Yes" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "Yes" stock dialog button.</li>
--   </ul>
ResponseYes :: ResponseId

-- | "No" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "No" stock dialog button.</li>
--   </ul>
ResponseNo :: ResponseId

-- | "Apply" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "Apply" stock dialog button.</li>
--   </ul>
ResponseApply :: ResponseId

-- | "Help" was pressed.
--   
--   <ul>
--   <li>This value is returned from the "Help" stock dialog button.</li>
--   </ul>
ResponseHelp :: ResponseId

-- | A user-defined response
--   
--   <ul>
--   <li>This value is returned from a user defined button</li>
--   </ul>
ResponseUser :: Int -> ResponseId
data ScrolledWindow :: *

-- | Creates a new scrolled window. The two arguments are the scrolled
--   window's adjustments; these will be shared with the scrollbars and the
--   child widget to keep the bars in sync with the child. Usually you want
--   to pass <tt>Nothing</tt> for the adjustments, which will cause the
--   scrolled window to create them for you.
scrolledWindowNew :: Maybe Adjustment -> Maybe Adjustment -> IO ScrolledWindow

-- | Sets the scrollbar policy for the horizontal and vertical scrollbars.
--   The policy determines when the scrollbar should appear; it is a value
--   from the <a>PolicyType</a> enumeration. If <a>PolicyAlways</a>, the
--   scrollbar is always present; if <a>PolicyNever</a>, the scrollbar is
--   never present; if <a>PolicyAutomatic</a>, the scrollbar is present
--   only if needed (that is, if the slider part of the bar would be
--   smaller than the trough - the display is larger than the page size).
scrolledWindowSetPolicy :: ScrolledWindowClass self => self -> PolicyType -> PolicyType -> IO ()
data Statusbar :: *

-- | Returns a new context identifier, given a description of the actual
--   context. This id can be used to later remove entries form the
--   Statusbar.
statusbarGetContextId :: StatusbarClass self => self -> String -> IO ContextId

-- | Creates a new <a>Statusbar</a> ready for messages.
statusbarNew :: IO Statusbar

-- | Removes the topmost message that has the correct context.
statusbarPop :: StatusbarClass self => self -> ContextId -> IO ()

-- | Pushes a new message onto the Statusbar's stack. It will be displayed
--   as long as it is on top of the stack.
statusbarPush :: StatusbarClass self => self -> ContextId -> String -> IO MessageId
data Table :: *

-- | Used to create a new table widget. An initial size must be given by
--   specifying how many rows and columns the table should have, although
--   this can be changed later with <a>tableResize</a>. <tt>rows</tt> and
--   <tt>columns</tt> must both be in the range 0 .. 65535.
tableNew :: Int -> Int -> Bool -> IO Table

-- | As there are many options associated with <a>tableAttach</a>, this
--   convenience function provides the programmer with a means to add
--   children to a table with identical padding and expansion options. The
--   values used for the <a>AttachOptions</a> are <tt>[<a>Expand</a>,
--   <a>Fill</a>]</tt>, and the padding is set to 0.
tableAttachDefaults :: (TableClass self, WidgetClass widget) => self -> widget -> Int -> Int -> Int -> Int -> IO ()
data VBox :: *

-- | Creates a new <a>VBox</a>.
vBoxNew :: Bool -> Int -> IO VBox
class ObjectClass o => WidgetClass o

-- | Enable event signals.
--   
--   <ul>
--   <li>See <a>widgetDelEvents</a>.</li>
--   </ul>
widgetAddEvents :: WidgetClass self => self -> [EventMask] -> IO ()

-- | Same as <a>widgetPath</a>, but always uses the name of a widget's
--   type, never uses a custom name set with <a>widgetSetName</a>.
widgetClassPath :: WidgetClass self => self -> IO (Int, String, String)

-- | Destroys a widget. Equivalent to <a>objectDestroy</a>.
--   
--   When a widget is destroyed it will be removed from the screen and
--   unrealized. When a widget is destroyed, it will break any references
--   it holds to other objects.If the widget is inside a container, the
--   widget will be removed from the container. The widget will be garbage
--   collected (finalized) time after your last reference to the widget
--   dissapears.
--   
--   In most cases, only toplevel widgets (windows) require explicit
--   destruction, because when you destroy a toplevel its children will be
--   destroyed as well.
widgetDestroy :: WidgetClass self => self -> IO ()

-- | Causes <tt>widget</tt> to have the keyboard focus for the
--   <a>Window</a> it's inside. <tt>widget</tt> must be a focusable widget,
--   such as a <a>Entry</a>; something like <a>Frame</a> won't work. (More
--   precisely, it must have the <a>widgetCanFocus</a> flag set.)
widgetGrabFocus :: WidgetClass self => self -> IO ()

-- | Set if this widget can receive keyboard input.
--   
--   <ul>
--   <li>To use the <tt>keyPress</tt> event, the widget must be allowed to
--   get the input focus. Once it has the input focus all keyboard input is
--   directed to this widget.</li>
--   </ul>
widgetSetCanFocus :: WidgetClass self => self -> Bool -> IO ()

-- | Widgets are double buffered by default; you can use this function to
--   turn off the buffering. "Double buffered" simply means that
--   <a>drawWindowBeginPaintRegion</a> and <a>drawWindowEndPaint</a> are
--   called automatically around expose events sent to the widget.
--   <a>drawWindowBeginPaintRegion</a> diverts all drawing to a widget's
--   window to an offscreen buffer, and <a>drawWindowEndPaint</a> draws the
--   buffer to the screen. The result is that users see the window update
--   in one smooth step, and don't see individual graphics primitives being
--   rendered.
--   
--   In very simple terms, double buffered widgets don't flicker, so you
--   would only use this function to turn off double buffering if you had
--   special needs and really knew what you were doing.
--   
--   Note: if you turn off double-buffering, you have to handle expose
--   events, since even the clearing to the background color or pixmap will
--   not happen automatically (as it is done in
--   <a>drawWindowBeginPaint</a>).
widgetSetDoubleBuffered :: WidgetClass self => self -> Bool -> IO ()

-- | Widgets can be named, which allows you to refer to them from a gtkrc
--   file. You can apply a style to widgets with a particular name in the
--   gtkrc file. See the documentation for gtkrc files.
--   
--   Note that widget names are separated by periods in paths (see
--   <a>widgetPath</a>), so names with embedded periods may cause
--   confusion.
widgetSetName :: WidgetClass self => self -> String -> IO ()

-- | Sets the minimum size of a widget; that is, the widget's size request
--   will be <tt>width</tt> by <tt>height</tt>. You can use this function
--   to force a widget to be either larger or smaller than it normally
--   would be.
--   
--   In most cases, <a>windowSetDefaultSize</a> is a better choice for
--   toplevel windows than this function; setting the default size will
--   still allow users to shrink the window. Setting the size request will
--   force them to leave the window at least as large as the size request.
--   When dealing with window sizes, <a>windowSetGeometryHints</a> can be a
--   useful function as well.
--   
--   Note the inherent danger of setting any fixed size - themes,
--   translations into other languages, different fonts, and user action
--   can all change the appropriate size for a given widget. So, it's
--   basically impossible to hardcode a size that will always be correct.
--   
--   The size request of a widget is the smallest size a widget can accept
--   while still functioning well and drawing itself correctly. However in
--   some strange cases a widget may be allocated less than its requested
--   size, and in many cases a widget may be allocated more space than it
--   requested.
--   
--   If the size request in a given direction is -1 (unset), then the
--   "natural" size request of the widget will be used instead.
--   
--   Widgets can't actually be allocated a size less than 1 by 1, but you
--   can pass 0,0 to this function to mean "as small as possible."
widgetSetSizeRequest :: WidgetClass self => self -> Int -> Int -> IO ()

-- | Flags a widget to be displayed. Any widget that isn't shown will not
--   appear on the screen. If you want to show all the widgets in a
--   container, it's easier to call <a>widgetShowAll</a> on the container,
--   instead of individually showing the widgets.
--   
--   Remember that you have to show the containers containing a widget, in
--   addition to the widget itself, before it will appear onscreen.
--   
--   When a toplevel container is shown, it is immediately realized and
--   mapped; other shown widgets are realized and mapped when their
--   toplevel container is realized and mapped.
widgetShow :: WidgetClass self => self -> IO ()

-- | Recursively shows a widget, and any child widgets (if the widget is a
--   container).
widgetShowAll :: WidgetClass self => self -> IO ()

-- | This function is typically used when implementing a <a>Container</a>
--   subclass. Obtains the preferred size of a widget. The container uses
--   this information to arrange its child widgets and decide what size
--   allocations to give them with <a>widgetSizeAllocate</a>.
--   
--   You can also call this function from an application, with some
--   caveats. Most notably, getting a size request requires the widget to
--   be associated with a screen, because font information may be needed.
--   Multihead-aware applications should keep this in mind.
--   
--   Also remember that the size request is not necessarily the size a
--   widget will actually be allocated.
widgetSizeRequest :: WidgetClass self => self -> IO Requisition

-- | Whether the widget is visible.
--   
--   Default value: <tt>False</tt>
widgetVisible :: WidgetClass self => Attr self Bool
data Window :: *

-- | Whether the window frame should have a close button.
--   
--   Default values: <tt>True</tt>
--   
--   <ul>
--   <li>Available since Gtk+ version 2.10</li>
--   </ul>
windowDeletable :: WindowClass self => Attr self Bool

-- | Asks the window manager to move <tt>window</tt> to the given position.
--   Window managers are free to ignore this; most window managers ignore
--   requests for initial window positions (instead using a user-defined
--   placement algorithm) and honor requests after the window has already
--   been shown.
--   
--   Note: the position is the position of the gravity-determined reference
--   point for the window. The gravity determines two things: first, the
--   location of the reference point in root window coordinates; and
--   second, which point on the window is positioned at the reference
--   point.
--   
--   By default the gravity is <a>GravityNorthWest</a>, so the reference
--   point is simply the <tt>x</tt>, <tt>y</tt> supplied to
--   <a>windowMove</a>. The top-left corner of the window decorations (aka
--   window frame or border) will be placed at <tt>x</tt>, <tt>y</tt>.
--   Therefore, to position a window at the top left of the screen, you
--   want to use the default gravity (which is <a>GravityNorthWest</a>) and
--   move the window to 0,0.
--   
--   To position a window at the bottom right corner of the screen, you
--   would set <a>GravitySouthEast</a>, which means that the reference
--   point is at <tt>x</tt> + the window width and <tt>y</tt> + the window
--   height, and the bottom-right corner of the window border will be
--   placed at that reference point. So, to place a window in the bottom
--   right corner you would first set gravity to south east, then write:
--   <tt>gtk_window_move (window, gdk_screen_width() - window_width,
--   gdk_screen_height() - window_height)</tt>.
--   
--   The Extended Window Manager Hints specification at
--   http://www.freedesktop.org/Standards/wm-spec has a nice table of
--   gravities in the "implementation notes" section.
--   
--   The <a>windowGetPosition</a> documentation may also be relevant.
windowMove :: WindowClass self => self -> Int -> Int -> IO ()

-- | Create a new top level window.
windowNew :: IO Window

-- | Presents a window to the user. This may mean raising the window in the
--   stacking order, deiconifying it, moving it to the current desktop,
--   and/or giving it the keyboard focus, possibly dependent on the user's
--   platform, window manager, and preferences.
--   
--   If <tt>window</tt> is hidden, this function calls <tt>widgetShow</tt>
--   as well.
--   
--   This function should be used when the user tries to open a window
--   that's already open. Say for example the preferences dialog is
--   currently open, and the user chooses Preferences from the menu a
--   second time; use <a>windowPresent</a> to move the already-open dialog
--   where the user can see it.
--   
--   If you are calling this function in response to a user interaction, it
--   is preferable to use <a>windowPresentWithTime</a>.
windowPresent :: WindowClass self => self -> IO ()

-- | Sets the default size of a window. If the window's "natural" size (its
--   size request) is larger than the default, the default will be ignored.
--   More generally, if the default size does not obey the geometry hints
--   for the window (<a>windowSetGeometryHints</a> can be used to set these
--   explicitly), the default size will be clamped to the nearest permitted
--   size.
--   
--   Unlike <tt>widgetSetSizeRequest</tt>, which sets a size request for a
--   widget and thus would keep users from shrinking the window, this
--   function only sets the initial size, just as if the user had resized
--   the window themselves. Users can still shrink the window again as they
--   normally would. Setting a default size of -1 means to use the
--   "natural" default size (the size request of the window).
--   
--   For more control over a window's initial size and how resizing works,
--   investigate <a>windowSetGeometryHints</a>.
--   
--   For some uses, <a>windowResize</a> is a more appropriate function.
--   <a>windowResize</a> changes the current size of the window, rather
--   than the size to be used on initial display. <a>windowResize</a>
--   always affects the window itself, not the geometry widget.
--   
--   The default size of a window only affects the first time a window is
--   shown; if a window is hidden and re-shown, it will remember the size
--   it had prior to hiding, rather than using the default size.
--   
--   Windows can't actually be 0x0 in size, they must be at least 1x1, but
--   passing 0 for <tt>width</tt> and <tt>height</tt> is OK, resulting in a
--   1x1 default size.
windowSetDefaultSize :: WindowClass self => self -> Int -> Int -> IO ()

-- | Sets a position constraint for this window. If the old or new
--   constraint is <a>WinPosCenterAlways</a>, this will also cause the
--   window to be repositioned to satisfy the new constraint.
windowSetPosition :: WindowClass self => self -> WindowPosition -> IO ()

-- | Sets the title of the <a>Window</a>. The title of a window will be
--   displayed in its title bar; on the X Window System, the title bar is
--   rendered by the window manager, so exactly how the title appears to
--   users may vary according to a user's exact configuration. The title
--   should help a user distinguish this window from other windows they may
--   have open. A good title might include the application name and current
--   document filename, for example.
windowSetTitle :: WindowClass self => self -> String -> IO ()

-- | The title of the window.
windowTitle :: WindowClass self => Attr self String

-- | Window position types
data WindowPosition :: *
WinPosNone :: WindowPosition
WinPosCenter :: WindowPosition
WinPosMouse :: WindowPosition
WinPosCenterAlways :: WindowPosition
WinPosCenterOnParent :: WindowPosition

-- | Initialize the GUI.
--   
--   This must be called before any other function in the Gtk2Hs library.
--   
--   This function initializes the GUI toolkit and parses all Gtk specific
--   arguments. The remaining arguments are returned. If the initialization
--   of the toolkit fails for whatever reason, an exception is thrown.
--   
--   <ul>
--   <li>Throws: <tt>error "Cannot initialize GUI."</tt></li>
--   <li>If you want to use Gtk2Hs and in a multi-threaded application then
--   it is your obligation to ensure that all calls to Gtk+ happen in a
--   single OS thread. If you want to make calls to Gtk2Hs functions from a
--   Haskell thread other than the one that calls this functions and
--   <a>mainGUI</a> then you will have to 'post' your GUI actions to the
--   main GUI thread. You can do this using <a>postGUISync</a> or
--   <a>postGUIAsync</a>. See also <a>threadsEnter</a>.</li>
--   </ul>
initGUI :: IO [String]

-- | Run the Gtk+ main event loop.
mainGUI :: IO ()

-- | Exit the main event loop.
mainQuit :: IO ()
type GtkFrame = Frame
type GtkLayout = Layout

module Language.Sifflet.Util
data SuccFail a
Succ :: a -> SuccFail a
Fail :: String -> SuccFail a
parsef :: Read a => String -> String -> String -> SuccFail a
parseInt :: String -> String -> SuccFail Int
parseDouble :: String -> String -> SuccFail Double
parseVerbatim :: String -> String -> SuccFail String

-- | Enclose in parentheses, like a Lisp function call. Example: par
--   <a>foo</a> [<a>x</a>, <a>y</a>] = <a>(foo x y)</a>
par :: String -> [String] -> String

-- | Write a list of words, separated by spaces
putCatsLn :: [String] -> IO ()

-- | Write a list of words, not separated by spaces
putCatLn :: [String] -> IO ()
info :: Show t => t -> IO ()
fake :: String -> IO ()
stub :: String -> IO ()

-- | Signal an error using a list of strings to be concatenated
errcat :: [String] -> a

-- | Signal an error using a list of strings to be concatenated with spaces
--   between (unwords).
errcats :: [String] -> a

-- | Generalization of map to lists of lists
map2 :: (a -> b) -> [[a]] -> [[b]]

-- | Generalization of mapM to lists of lists
mapM2 :: Monad m => (a -> m b) -> [[a]] -> m [[b]]

-- | Update a value at a given key by applying a function. Similar to
--   Data.Map.adjust.
adjustAList :: Eq k => k -> (v -> v) -> [(k, v)] -> [(k, v)]

-- | Monadic generalization of adjustAList
adjustAListM :: (Eq k, Monad m) => k -> (v -> m v) -> [(k, v)] -> m [(k, v)]

-- | Insert an item into a list of lists of items, making it the last
--   element in the last sublist
insertLastLast :: [[a]] -> a -> [[a]]

-- | Insert an item in a list of items, making it the last element
insertLast :: [a] -> a -> [a]
instance Eq a => Eq (SuccFail a)
instance Read a => Read (SuccFail a)
instance Show a => Show (SuccFail a)
instance Monad SuccFail


-- | <a>Rowed Panel.</a> Expandable framed panel with a two-dimensional
--   layout (rows of widgets, but not with aligned columns like in a
--   table).
module Graphics.UI.Sifflet.RPanel
data RPanel
newRPanel :: String -> Int -> Int -> Int -> IO RPanel
rpanelId :: RPanel -> String
rpanelRoot :: RPanel -> GtkFrame
rpanelContent :: RPanel -> [[String]]

-- | Add a single named widget to the RPanel
rpanelAddWidget :: WidgetClass widget => RPanel -> String -> widget -> IO RPanel

-- | Given a list of (name, widget) pairs, add each of the widgets and its
--   name to the rpanel
rpanelAddWidgets :: WidgetClass widget => RPanel -> [(String, widget)] -> IO RPanel

-- | Force the RPanel to begin a new row
rpanelNewRow :: RPanel -> IO RPanel

-- | Given a list of lists, each sublist representing a row of widgets, add
--   the widgets to the RPanel, preserving the row structure as much as
--   possible. (Row structure will be broken if any intended row is too
--   wide.)
rpanelAddRows :: WidgetClass widget => RPanel -> [[(String, widget)]] -> IO RPanel

module Graphics.UI.Sifflet.GtkUtil
suppressScimBridge :: IO ()

-- | Show a message and a set of choices; run the action corresponding to
--   the selected choice; you might want to include a <a>Cancel</a> option
--   with the action return (). There *should* be as many actions as there
--   are options.
showChoicesDialog :: String -> String -> [String] -> [IO a] -> IO a

-- | Where to put a dialog window. Possible values are WinPosNone
--   WinPosCenter WinPosMouse WinPosCenterAlways WinPosCenterOnParent
defaultDialogPosition :: WindowPosition
runDialogM :: Dialog -> a -> (a -> IO (Maybe b)) -> IO (Maybe b)

-- | Customizable framework for running a dialog
runDialogS :: Dialog -> a -> (a -> IO (SuccFail b)) -> IO (Maybe b)
showInputErrorMessage :: String -> IO ()
showErrorMessage :: String -> IO ()
showInfoMessage :: String -> String -> IO ()
showMessage :: Maybe String -> MessageType -> ButtonsType -> String -> IO ()
data EntryDialog a
type Reader a b = a -> SuccFail b
createEntryDialog :: String -> [String] -> [String] -> (Reader [String] a) -> Int -> IO (EntryDialog a)
runEntryDialog :: Show a => EntryDialog a -> IO (Maybe a)

-- | Add a labeled text entry to the vbox.
addEntryWithLabel :: VBox -> (String, Entry, String) -> IO ()

module Data.Sifflet.Geometry
data Position
Position :: Double -> Double -> Position
posX :: Position -> Double
posY :: Position -> Double
positionDelta :: Position -> Position -> (Double, Double)
positionDistance :: Position -> Position -> Double
positionDistanceSquared :: Position -> Position -> Double
positionCloseEnough :: Position -> Position -> Double -> Bool
data Circle
Circle :: Position -> Double -> Circle
circleCenter :: Circle -> Position
circleRadius :: Circle -> Double
pointInCircle :: Position -> Circle -> Bool
data Size
Size :: Double -> Double -> Size
sizeW :: Size -> Double
sizeH :: Size -> Double

-- | BBox x y width height; (x, y) is the top left corner
data BBox
BBox :: Double -> Double -> Double -> Double -> BBox

-- | BBox accessors and utilities
bbX, bbHeight, bbWidth, bbY :: BBox -> Double
bbSetWidth :: BBox -> Double -> BBox
bbPosition :: BBox -> Position
bbSize :: BBox -> Size
bbToRect :: BBox -> Rectangle
bbFromRect :: Rectangle -> BBox
bbCenter :: BBox -> Position
bbLeft, bbRight, bbXCenter :: BBox -> Double
bbTop, bbBottom, bbYCenter :: BBox -> Double

-- | Form a new BBox which encloses two bboxes
bbMerge :: BBox -> BBox -> BBox
bbMergeList :: [BBox] -> BBox
pointInBB :: Position -> BBox -> Bool
class Widen a
widen :: Widen a => a -> Double -> a

-- | A Translate is a thing that can be repositioned by delta x and delta y
class Translate a
translate :: Translate a => Double -> Double -> a -> a
instance Eq Position
instance Read Position
instance Show Position
instance Eq Circle
instance Read Circle
instance Show Circle
instance Eq Size
instance Read Size
instance Show Size
instance Eq BBox
instance Read BBox
instance Show BBox
instance Translate Circle
instance Translate Position
instance Translate BBox
instance Translate e => Translate (Tree e)
instance Translate e => Translate [e]
instance Widen BBox


-- | This module provides the Sifflet Number type and many operations upon
--   it. Most of the operations are provided by making Number an instance
--   of the classes Num, Real, Enum, Integral, Fractional, Floating, and
--   RealFrac. These are, I think, all of the normal Haskell numeric type
--   classes *except* RealFloat. There are also a few functions defined in
--   addition to the class methods.
--   
--   The *primary* purpose of this module is to be the library module used
--   by Sifflet programs exported to Haskell. The *secondary* purpose
--   (maybe no less important, but realized after the first) is to
--   implement the Sifflet number Values (previously done with the VInt and
--   VFloat constructors).
module Data.Number.Sifflet

-- | A Number represents a real number, which can be exact (Integer) or
--   inexact (Double).
data Number
Exact :: Integer -> Number
Inexact :: Double -> Number

-- | Tell whether a Number is exact
isExact :: Number -> Bool

-- | Take a number, which may be exact or inexact, and produce the inexact
--   number which equals it. Note that there is no inverse function
--   toExact, because some inexact numbers like 3.5 are not equal to any
--   exact number. The class RealFrac provides methods round, ceiling,
--   floor, truncate for converting to exact numbers.
toInexact :: Number -> Number
add1 :: Number -> Number
sub1 :: Number -> Number
eqZero :: Number -> Bool
gtZero :: Number -> Bool
ltZero :: Number -> Bool
instance Eq Number
instance Read Number
instance RealFrac Number
instance Floating Number
instance Fractional Number
instance Integral Number
instance Enum Number
instance Real Number
instance Num Number
instance Ord Number
instance Show Number

module Text.Sifflet.Repr

-- | class Repr: representable by a String or a list of Strings
--   
--   repr x is a String representation of x. reprl x is a [String]
--   representation of x, where the first element should be the same as
--   repr x, and the rest provide auxiliary information that you want to be
--   shown with x. reprs x is a reduction of reprl x to a single String.
--   reprList prefix infix postfix xs is the representation of a list of xs
--   
--   Minimal complete implementation: define repr, or define reprl. The
--   normal way is to define repr. Define reprl instead, if for some reason
--   you want to include additional information such as the value of an
--   expression in an expression node.
--   
--   Examples: - (3 :: Int) has repr =&gt; <a>3</a>, reprl =&gt;
--   [<a>3</a>], reprs =&gt; <a>3</a> - In Language.Sifflet.Expr, (ENode
--   (NSymbol <a>x</a>) (EvalOk (3 :: Int) has reprl =&gt; [<a>x</a>,
--   <a>3</a>], reprs =&gt; <a>x 3</a>, and repr =&gt; <a>x</a>. - reprList
--   <a>(</a> <a> </a> <a>)</a> [3 :: Int, 4, 5] =&gt; <a>(3 4 5)</a>
class Repr a where repr = head . reprl reprl x = [repr x] reprs = unwords . reprl reprList pre tween post xs = pre ++ intercalate tween (map repr xs) ++ post
repr :: Repr a => a -> String
reprl :: Repr a => a -> [String]
reprs :: Repr a => a -> String
reprList :: Repr a => String -> String -> String -> [a] -> String
newtype Name
Name :: String -> Name
instance Eq Name
instance Read Name
instance Show Name
instance Repr Name
instance Repr Double
instance Repr Float
instance Repr Number
instance Repr Integer
instance Repr Int
instance Repr Char
instance Repr Bool

module Data.Sifflet.Tree

-- | Multi-way trees, also known as <i>rose trees</i>.
data Tree a :: * -> *
Node :: a -> Forest a -> Tree a

-- | label value
rootLabel :: Tree a -> a

-- | zero or more child trees
subForest :: Tree a -> Forest a
tree :: e -> Forest e -> Tree e
leaf :: e -> Tree e
isLeaf :: Tree e -> Bool
treeSize :: Tree e -> Int
treeDepth :: Tree e -> Int

-- | class Repr: representable by a String or a list of Strings
--   
--   repr x is a String representation of x. reprl x is a [String]
--   representation of x, where the first element should be the same as
--   repr x, and the rest provide auxiliary information that you want to be
--   shown with x. reprs x is a reduction of reprl x to a single String.
--   reprList prefix infix postfix xs is the representation of a list of xs
--   
--   Minimal complete implementation: define repr, or define reprl. The
--   normal way is to define repr. Define reprl instead, if for some reason
--   you want to include additional information such as the value of an
--   expression in an expression node.
--   
--   Examples: - (3 :: Int) has repr =&gt; <a>3</a>, reprl =&gt;
--   [<a>3</a>], reprs =&gt; <a>3</a> - In Language.Sifflet.Expr, (ENode
--   (NSymbol <a>x</a>) (EvalOk (3 :: Int) has reprl =&gt; [<a>x</a>,
--   <a>3</a>], reprs =&gt; <a>x 3</a>, and repr =&gt; <a>x</a>. - reprList
--   <a>(</a> <a> </a> <a>)</a> [3 :: Int, 4, 5] =&gt; <a>(3 4 5)</a>
class Repr a where repr = head . reprl reprl x = [repr x] reprs = unwords . reprl reprList pre tween post xs = pre ++ intercalate tween (map repr xs) ++ post
repr :: Repr a => a -> String
reprl :: Repr a => a -> [String]
reprs :: Repr a => a -> String
reprList :: Repr a => String -> String -> String -> [a] -> String
newtype Name
Name :: String -> Name
nameTree :: Tree String -> Tree Name
putTree :: Show e => Tree e -> IO ()
putTreeR :: Repr e => Tree e -> IO ()
putTreeRs :: Repr e => Tree e -> IO ()
putTreeS :: Show e => Tree e -> IO ()
drawTreeShow :: Show e => Tree e -> String

module Data.Sifflet.TreeLayout
data VColor
ColorRGB :: Double -> Double -> Double -> VColor
ColorRGBA :: Double -> Double -> Double -> Double -> VColor
black, lightBlueGreen, lightBlue, cream, white :: VColor
lightGray, darkGray, mediumGray :: VColor
yellow, blueGreen, darkBlueGreen :: VColor
data Style
Style :: VFont -> Double -> Double -> Double -> Double -> Double -> (Double, Double) -> Double -> VColor -> VColor -> VColor -> VColor -> VColor -> VColor -> VColor -> VColor -> VColor -> VColor -> Position -> VColor -> VFont -> Double -> Bool -> Bool -> Style
styleFont :: Style -> VFont
lineWidth :: Style -> Double
textMargin :: Style -> Double
hpad :: Style -> Double
vpad :: Style -> Double
exomargin :: Style -> Double
vtinypad :: Style -> (Double, Double)
styleFramePad :: Style -> Double
styleNormalTextColor :: Style -> VColor
styleNormalFillColor :: Style -> VColor
styleNormalEdgeColor :: Style -> VColor
styleActiveTextColor :: Style -> VColor
styleActiveFillColor :: Style -> VColor
styleActiveEdgeColor :: Style -> VColor
styleSelectedTextColor :: Style -> VColor
styleSelectedFillColor :: Style -> VColor
styleSelectedEdgeColor :: Style -> VColor
styleTetherColor :: Style -> VColor
styleAuxOffset :: Style -> Position
styleAuxColor :: Style -> VColor
styleAuxFont :: Style -> VFont
styleIoletRadius :: Style -> Double
styleShowNodeBoxes :: Style -> Bool
styleShowNodePorts :: Style -> Bool
data VFont
VFont :: String -> FontSlant -> FontWeight -> Double -> VFont
vfontFace :: VFont -> String
vfontSlant :: VFont -> FontSlant
vfontWeight :: VFont -> FontWeight
vfontSize :: VFont -> Double
style0, defaultStyle, style3, style2, style1 :: Style
wstyle :: Style
styleIncreasePadding :: Style -> Double -> Style
data FontTextExtents
FontTextExtents :: Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> FontTextExtents
fontAscent :: FontTextExtents -> Double
fontDescent :: FontTextExtents -> Double
fontHeight :: FontTextExtents -> Double
fontMaxXadvance :: FontTextExtents -> Double
fontMaxYadvance :: FontTextExtents -> Double
textXbearing :: FontTextExtents -> Double
textYbearing :: FontTextExtents -> Double
extTextWidth :: FontTextExtents -> Double
extTextHeight :: FontTextExtents -> Double
textXadvance :: FontTextExtents -> Double
textYadvance :: FontTextExtents -> Double
setFont :: VFont -> Render ()
measureText :: Style -> String -> Size
styleTextExtents :: Style -> String -> FontTextExtents

-- | ftExtents: used for what?
ftExtents :: String -> Render FontTextExtents
data TextBox
TextBox :: String -> BBox -> BBox -> TextBox
tbText :: TextBox -> String
tbTextBB :: TextBox -> BBox
tbBoxBB :: TextBox -> BBox
makeTextBox :: Style -> String -> TextBox
tbWidth :: TextBox -> Double
tbHeight :: TextBox -> Double
tbBottom :: TextBox -> Double
tbCenter :: TextBox -> Position
tbTextCenter :: TextBox -> Position
tbBoxCenter :: TextBox -> Position
offsetTextBoxCenters :: Position -> TextBox -> TextBox -> TextBox
tbSetWidth :: TextBox -> Double -> TextBox
treeSizes :: Style -> Tree (GNode e) -> Tree Size
data GNode e
GNode :: e -> [TextBox] -> BBox -> [Iolet] -> [Iolet] -> GNode e
gnodeValue :: GNode e -> e
gnodeTextBoxes :: GNode e -> [TextBox]
gnodeNodeBB :: GNode e -> BBox
gnodeInlets :: GNode e -> [Iolet]
gnodeOutlets :: GNode e -> [Iolet]
treeGNodes :: Repr e => Style -> IoletCounter e -> Tree e -> Tree (GNode e)
gnodeText :: GNode e -> String
gnodeTextBB :: GNode e -> BBox

-- | An Iolet is a circular port. Other shapes could be added.
newtype Iolet
Iolet :: Circle -> Iolet
ioletCenter :: Iolet -> Position
makeIolets :: Style -> BBox -> (Int, Int) -> ([Iolet], [Iolet])
makeIoletsRow :: Style -> Double -> Double -> Int -> [Iolet]
pointInIolet :: Position -> Iolet -> Bool
type IoletCounter e = e -> (Int, Int)
zeroIoletCounter :: IoletCounter e
makeGNode :: Repr e => Style -> IoletCounter e -> e -> GNode e
type TreeLayout e = Tree (LayoutNode e)
data LayoutNode e
LayoutNode :: GNode e -> BBox -> LayoutNode e
nodeGNode :: LayoutNode e -> GNode e
nodeTreeBB :: LayoutNode e -> BBox
layoutNodeSource :: LayoutNode e -> e
layoutRootBB :: TreeLayout e -> BBox
layoutTreeBB :: TreeLayout e -> BBox
treeLayout :: Repr e => Style -> IoletCounter e -> Tree e -> TreeLayout e
treeLayoutPaddedSize :: Style -> TreeLayout e -> Size
treeLayoutSize :: TreeLayout e -> Size
treeLayoutWidth :: TreeLayout e -> Double
layoutTreeMoveCenterTo :: Double -> Double -> TreeLayout e -> TreeLayout e
pointInLayoutNode :: Position -> LayoutNode e -> Bool
pointInGNode :: Position -> GNode e -> Bool
findRect :: Position -> TreeLayout e -> Maybe Rectangle
treeLayoutWiden :: TreeLayout e -> Double -> TreeLayout e
instance Eq FontTextExtents
instance Read FontTextExtents
instance Show FontTextExtents
instance Eq TextBox
instance Read TextBox
instance Show TextBox
instance Eq Iolet
instance Read Iolet
instance Show Iolet
instance Eq e => Eq (GNode e)
instance Eq e => Eq (LayoutNode e)
instance Widen (LayoutNode e)
instance Translate (LayoutNode e)
instance Show e => Show (LayoutNode e)
instance Translate Iolet
instance Translate (GNode e)
instance Show e => Show (GNode e)
instance Translate TextBox
instance Widen TextBox

module Language.Sifflet.Expr
data ArgSpec
ArgSpec :: String -> Int -> ArgSpec
argName :: ArgSpec -> String
argInlets :: ArgSpec -> Int

-- | Try to find the number of inlets for an argument from a list of
--   ArgSpec
aspecsLookup :: String -> [ArgSpec] -> Maybe Int
type EvalResult = EvalRes Value
data EvalRes e
EvalOk :: e -> EvalRes e
EvalError :: String -> EvalRes e
EvalUntried :: EvalRes e

-- | The value of an expression in the base environment.
exprToValue :: Expr -> SuccFail Value
valueToLiteral :: Value -> SuccFail Expr
valueToLiteral' :: Value -> Expr
newtype Symbol
Symbol :: String -> Symbol
type OStr = String
type OBool = Bool
type OChar = Char

-- | A more highly <a>parsed</a> type of expression
--   
--   Function calls have two kinds: 1. ECall: restricted to the case where
--   the function expression is just a symbol, since otherwise it will be
--   hard to visualize. 2. EApp: allows any expression to be the function,
--   but is applied to only one argument. For now, the type checker will
--   convert ECall expressions to EApp expressions. Ultimately, the two
--   variants ought to be unified.
--   
--   The constructors EOp and EGroup are not used in Sifflet itself, but
--   they are needed for export to Python, Haskell, and similar languages;
--   they allow a distinction between operators and functions, and wrapping
--   expressions in parentheses. EGroup e represents parentheses used for
--   grouping: (e); it is not used for other cases of parentheses, e.g.,
--   around the argument list in a function call.]
data Expr
EUndefined :: Expr
ESymbol :: Symbol -> Expr
EBool :: Bool -> Expr
EChar :: Char -> Expr
ENumber :: Number -> Expr
EString :: String -> Expr

-- | if test branch1 branch2
EIf :: Expr -> Expr -> Expr -> Expr
EList :: [Expr] -> Expr
ELambda :: Symbol -> Expr -> Expr

-- | apply function to argument
EApp :: Expr -> Expr -> Expr

-- | function name, arglist
ECall :: Symbol -> [Expr] -> Expr

-- | binary operator application
EOp :: Operator -> Expr -> Expr -> Expr

-- | grouping parentheses
EGroup :: Expr -> Expr
eSymbol, eSym :: String -> Expr
eInt :: Integer -> Expr
eString :: OStr -> Expr
eChar :: OChar -> Expr
eFloat :: Double -> Expr

-- | Try to convert the arguments and body of a function to a lambda
--   expression. Fails if there are no arguments, since a lambda expression
--   requires one. If there are multiple arguments, then we get a nested
--   lambda expression.
toLambdaExpr :: [String] -> Expr -> SuccFail Expr

-- | Convert an ECall expression to an EApp expression
callToApp :: Expr -> Expr

-- | Helper for callToApp, but may have other uses. Creates an EApp
--   expression representing a function call with possibly many arguments.
mapply :: Expr -> [Expr] -> Expr

-- | Convert an EApp expression to an ECall expression
appToCall :: Expr -> Expr

-- | Helper for appToCall, but may have other uses. Creates an ECall
--   expression.
mcall :: Expr -> [Expr] -> Expr

-- | Is an expression atomic? Atomic expressions do not need parentheses in
--   any reasonable language, because there is nothing to be grouped
--   (symbols, literals) or in the case of lists, they already have
--   brackets which separate them from their neighbors.
--   
--   All lists are atomic, even if they are not literals, because (for
--   example) we can remove parentheses from ([a + b, 7])
exprIsAtomic :: Expr -> Bool

-- | Compound = non-atomic
exprIsCompound :: Expr -> Bool
eBool :: Bool -> Expr
eFalse, eTrue :: Expr
eIf :: Expr -> Expr -> Expr -> Expr
eList :: [Expr] -> Expr

-- | Example: ePlus_2_3 = eCall <a>+</a> [eInt 2, eInt 3]
eCall :: String -> [Expr] -> Expr

-- | Is an Expr a literal? A literal is a boolean, character, number,
--   string, or list of literals. We (should) only allow user input
--   expressions to be literal expressions.
exprIsLiteral :: Expr -> Bool

-- | Given an expression, return the list of names of variables occurring
--   in the expression
exprSymbols :: Expr -> [Symbol]

-- | exprVarNames expr returns the names of variables in expr that are
--   UNBOUND in the base environment. This may not be ideal, but it's a
--   start.
exprVarNames :: Expr -> [String]

-- | An operator, such as * or + An operator is associative, like +, if (a
--   + b) + c == a + (b + c). Its grouping is left to right if (a op b op
--   c) means (a op b) op c; right to left if (a op b op c) means a op (b
--   op c). Most operators group left to right.
data Operator
Operator :: String -> Precedence -> Bool -> OperatorGrouping -> Operator
opName :: Operator -> String
opPrec :: Operator -> Precedence

-- | associative?
opAssoc :: Operator -> Bool
opGrouping :: Operator -> OperatorGrouping

-- | Operator priority, normally is &gt; 0 or &gt;= 0, but does that really
--   matter? I think not.
type Precedence = Int

-- | Operator grouping: left to right or right to left, or perhaps not at
--   all
data OperatorGrouping
GroupLtoR :: OperatorGrouping
GroupRtoL :: OperatorGrouping
GroupNone :: OperatorGrouping
data Value
VBool :: OBool -> Value
VChar :: OChar -> Value
VNumber :: Number -> Value
VString :: OStr -> Value
VFun :: Function -> Value
VList :: [Value] -> Value
valueFunction :: Value -> Function

-- | A collection of functions, typically to be saved or exported or read
--   from a file
newtype Functions
Functions :: [Function] -> Functions

-- | A function may have a name and always has an implementation
data Function
Function :: (Maybe String) -> [Type] -> Type -> FunctionImpl -> Function
functionName :: Function -> String
functionNArgs :: Function -> Int
functionArgSpecs :: Function -> [ArgSpec]
functionArgTypes :: Function -> [Type]
functionResultType :: Function -> Type

-- | Type type of a function, a tuple of (arg types, result type)
functionArgResultTypes :: Function -> ([Type], Type)

-- | The type of a function, where (a -&gt; b) is represented as TypeCons
--   <a>Function</a> [a, b]
functionType :: Function -> Type
functionArgNames :: Function -> [String]
functionBody :: Function -> Expr
functionImplementation :: Function -> FunctionImpl
type FunctionDefTuple = (String, [String], [Type], Type, Expr)
functionToDef :: Function -> FunctionDefTuple
functionFromDef :: FunctionDefTuple -> Function
data FunctionImpl
Primitive :: ([Value] -> EvalResult) -> FunctionImpl
Compound :: [String] -> Expr -> FunctionImpl

-- | Type variable name
type TypeVarName = String

-- | Type constructor name
type TypeConsName = String

-- | A Type is either a type variable or a constructed type with a
--   constructor and a list of type parameters
data Type
TypeVar :: TypeVarName -> Type
TypeCons :: TypeConsName -> [Type] -> Type
typeBool, typeString, typeNum, typeChar :: Type
typeList :: Type -> Type

-- | The type of a function, from its argument types and result type, where
--   (a -&gt; b) is represented as TypeCons <a>Function</a> [a, b]. Note
--   that for n-ary functions, n &gt; 2 implies nested function types: (a
--   -&gt; b -&gt; c) is represented as TypeCons <a>Function</a> [a,
--   TypeCons <a>Function</a> [b, c]], etc.
typeFunction :: [Type] -> Type -> Type
type Env = [EnvFrame]
emptyEnv :: Env
makeEnv :: [String] -> [Value] -> Env
extendEnv :: [String] -> [Value] -> Env -> Env

-- | Insert names and values from lists into an environment
envInsertL :: Env -> [String] -> [Value] -> Env

-- | Return to the environment prior to an extendEnv
envPop :: Env -> Env
envIns :: Env -> String -> Value -> Env
envSet :: Env -> String -> Value -> Env

-- | Get the value of a variable from an environment
envGet :: Env -> String -> Value
envGetFunction :: Env -> String -> Function
envLookup :: Env -> String -> Maybe Value
envLookupFunction :: Env -> String -> Maybe Function

-- | List of all symbols bound in the environment
envSymbols :: Env -> [String]

-- | List of all symbols bound to functions in the environment
envFunctionSymbols :: Env -> [String]

-- | All the functions in the environment
envFunctions :: Env -> Functions
eval :: Expr -> Env -> EvalResult
evalWithLimit :: Expr -> Env -> Int -> EvalResult
stackSize :: Int

-- | Apply a function fvalue to a list of actual arguments args in an
--   environment env and with a limited stack size stacksize
apply :: Value -> [Value] -> Env -> Int -> EvalResult
newUndefinedFunction :: String -> [String] -> Function
ePlus :: Expr -> Expr -> Expr
eTimes :: Expr -> Expr -> Expr
eMinus, eMod, eDiv :: Expr -> Expr -> Expr
eAdd1, eSub1 :: Expr -> Expr
eEq, eLe, eLt, eGe, eGt, eNe :: Expr -> Expr -> Expr
eZerop, eNegativep, ePositivep :: Expr -> Expr
baseEnv :: Env
instance Eq Symbol
instance Read Symbol
instance Show Symbol
instance Eq OperatorGrouping
instance Show OperatorGrouping
instance Eq Operator
instance Show Operator
instance Eq Expr
instance Show Expr
instance Eq e => Eq (EvalRes e)
instance Show e => Show (EvalRes e)
instance Eq Type
instance Eq ArgSpec
instance Show ArgSpec
instance Eq Value
instance Show Value
instance Show Function
instance Eq Functions
instance Show Functions
instance Eq Function
instance Repr Function
instance Read FunctionImpl
instance Show FunctionImpl
instance Show Type
instance Monad EvalRes
instance Repr Value
instance Pretty Operator
instance Repr Expr
instance Repr Symbol
instance Pretty Symbol

module Language.Sifflet.Export.Exporter

-- | The type of a function to export (user) functions to a file.
type Exporter = Functions -> FilePath -> IO ()

-- | Simplify an expression by applying rules top-down throughout the
--   expression tree and repeatedly until there is no change. This is
--   intended for removing extra parentheses, but could be used for other
--   forms of simplification.
--   
--   Should each rule also know the level in the original expr tree, with 0
--   = top level (root)? That would require additional arguments.
simplifyExpr :: [Expr -> Expr] -> Expr -> Expr

-- | Common rules for simplifying parentheses.
--   
--   Remove ()'s around a higher precedence operator: e.g., (a * b) + c
--   ==&gt; a * b + c a + (b * c) ==&gt; a + b * c
commonRuleHigherPrec :: Expr -> Expr

-- | Remove ()'s around an atomic expression -- a variable, literal, or
--   list
commonRuleAtomic :: Expr -> Expr

-- | Remove ()'s in the case of (a op1 b) op2 c, if op1 and op2 have the
--   same precedence, and both group left to right, since left to right
--   evaluation makes them unnecessary.
commonRuleLeftToRight :: Expr -> Expr
commonRuleAssocRight :: Expr -> Expr
commonRuleFuncOp :: Expr -> Expr

-- | A list of common rules for simplifying expressions. Does *not* include
--   ruleIfRight, since that works for Haskell but not Python.
commonRulesForSimplifyingExprs :: [Expr -> Expr]
ruleIfRight :: Expr -> Expr

-- | Remove ()'s in the case of a op (b op c) if op groups right to left,
--   and note that it is the same operator op in both places (though I
--   don't know if that restriction is necessary). This applies to (:) in
--   Haskell, for example: x : y : zs == x : (y : zs)
ruleRightToLeft :: Expr -> Expr

-- | Try the first rule in a list to see if it changes an expression,
--   returning the new expression if it does; otherwise, try the next rule,
--   and so on; if no rule changes the expression, then return the
--   expression. (Note that (applyFirstMatch rules) is itself a rule.)
applyFirstMatch :: [Expr -> Expr] -> Expr -> Expr

-- | Repeatedly apply a function to an object until there is no change,
--   that is, until reaching a fixed point of the function, a point where f
--   x == x.
findFixed :: Eq a => (a -> a) -> a -> a

module Language.Sifflet.Examples
exampleFunctions :: [Function]
exampleFunctionNames :: [String]
exampleEnv :: Env

-- | foo a b = 2 * a + b
foo :: Function

-- | An expression representing a call to foo
eFoo :: Expr -> Expr -> Expr

-- | An expression representing a call to max
eMax :: Expr -> Expr -> Expr

-- | An expression representing a call to fact
eFact :: Expr -> Expr

-- | This function will be in error if the function name is not found in
--   exampleEnv.
getExampleFunction :: String -> Function


-- | Abstract syntax tree and pretty-printing for Haskell 98. This is only
--   a small subset of the Haskell 98 syntax, so we do not need to pull in
--   haskell-src and all its complexity. Moreover, haskell-src gives too
--   little control over the format of pretty-printed text output.
module Language.Sifflet.Export.Haskell
class HsPretty a where hsPrettyList pre tween post xs = pre ++ intercalate tween (map hsPretty xs) ++ post
hsPretty :: HsPretty a => a -> String
hsPrettyList :: HsPretty a => String -> String -> String -> [a] -> String

-- | A Haskell module; moduleDecls are functions and variables.
data Module
Module :: String -> Maybe ExportSpec -> ImportDecl -> [Decl] -> Module
moduleName :: Module -> String
moduleExports :: Module -> Maybe ExportSpec
moduleImports :: Module -> ImportDecl
moduleDecls :: Module -> [Decl]

-- | A Haskell module's export spec: a list of function and variable
--   identifiers
newtype ExportSpec
ExportSpec :: [String] -> ExportSpec

-- | A Haskell modules import decls: a list of module identifiers. No
--   support for <a>qualified</a> or <a>as</a> or for selecting only some
--   identifiers from the imported modules.
newtype ImportDecl
ImportDecl :: [String] -> ImportDecl

-- | A Haskell function or variable declaration. An explicit type
--   declaration is optional. Thus we have just enough for name :: type
--   name [args] = expr. Of course [args] would be empty if it's just a
--   variable.
data Decl
Decl :: String -> Maybe [String] -> [String] -> Expr -> Decl
declIdent :: Decl -> String
declType :: Decl -> Maybe [String]
declParams :: Decl -> [String]
declExpr :: Decl -> Expr

-- | The Haskell operators. Now what about the associativity of (:)? It
--   really doesn't even make sense to ask if (:) is associative in the
--   usual sense, since (x1 : x2) : xs == x1 : (x2 : xs) is not only
--   untrue, but the left-hand side is a type error, except maybe in some
--   very special cases (and then the right-hand side would probably be a
--   type error). Is (:) what is called a <a>right-associative</a>
--   operator? And do I need to expand my Operator type to include this?
--   And then what about (-) and (/)??? Does this affect their relationship
--   with (+) and (-)?
operatorTable :: Map String Operator
instance Eq ExportSpec
instance Show ExportSpec
instance Eq ImportDecl
instance Show ImportDecl
instance Eq Decl
instance Show Decl
instance Eq Module
instance Show Module
instance HsPretty Expr
instance HsPretty Decl
instance HsPretty ImportDecl
instance HsPretty ExportSpec
instance HsPretty Module
instance HsPretty Operator
instance HsPretty Symbol


-- | Exports Sifflet to Haskell Requires haskell-src package.
module Language.Sifflet.Export.ToHaskell

-- | User configurable options for export to Haskell. Currently these
--   options are unused. The line width options should probably go
--   somewhere else, maybe as PrettyOptions.
data HaskellOptions
HaskellOptions :: Int -> Int -> HaskellOptions
optionsSoftMaxLineWidth :: HaskellOptions -> Int
optionsHardMaxLineWidth :: HaskellOptions -> Int

-- | The default options for export to Haskell.
defaultHaskellOptions :: HaskellOptions

-- | Export functions with specified options to a file
exportHaskell :: HaskellOptions -> Exporter

-- | Converting Sifflet to Haskell syntax tree
--   
--   Create a module from a module name and Functions.
functionsToHsModule :: String -> Functions -> Module

-- | Create a declaration from a Function. Needs work: infer and declare
--   the type of the function. Minimally parenthesized.
functionToHsDecl :: Function -> Decl

-- | Converts a Sifflet Expr to a fully parenthesized Haskell Expr
exprToHsExpr :: Expr -> Expr
instance Eq HaskellOptions
instance Show HaskellOptions


-- | Abstract syntax tree and pretty-printing for Python. Works for Python
--   2 and 3. A lot of the data structures are inspired by the
--   language-python package; I have chosen not to have language-python as
--   a dependency of sifflet-lib, however, because it would be overkill and
--   still allows to little control over pretty-printing of Python
--   expressionsw.
module Language.Sifflet.Export.Python
class PyPretty a where pyPrettyList pre tween post xs = pre ++ intercalate tween (map pyPretty xs) ++ post
pyPretty :: PyPretty a => a -> String
pyPrettyList :: PyPretty a => String -> String -> String -> [a] -> String

-- | Python module -- essentially a list of statements; should it also have
--   a name?
newtype PModule
PModule :: [PStatement] -> PModule

-- | Python statement
data PStatement
PReturn :: Expr -> PStatement

-- | import statement
PImport :: String -> PStatement

-- | if condition action alt-action
PCondS :: Expr -> PStatement -> PStatement -> PStatement

-- | function name, formal parameters, body
PFun :: Symbol -> [Symbol] -> PStatement -> PStatement
alterParens :: (Expr -> Expr) -> PStatement -> PStatement

-- | Python return statement
ret :: Expr -> PStatement

-- | Python if STATEMENT
condS :: Expr -> Expr -> Expr -> PStatement

-- | Python variable
var :: String -> Expr

-- | Python identifier
ident :: String -> Symbol

-- | Python character expression = string expression with one character
char :: Char -> Expr

-- | Defines function definition
fun :: String -> [String] -> Expr -> PStatement

-- | Binary operators Precedence levels are rather *informally* described
--   in The Python Language Reference,
--   http:<i></i>docs.python.org<i>reference</i>. I am adopting the infixr
--   levels from Haskell, which seem to be consistent with Python, at least
--   for the operators that Sifflet uses.
--   
--   | Operator information Arithmetic operators: + and - have lower
--   precedence than *, <i>, </i>/, % | Comparison operators have
--   precedence lower than any arithmetic operator. Here, I've specified
--   associative = False, because association doesn't even make sense
--   (well, it does in Python but not in other languages); (a == b) == c is
--   in general not well typed.
operatorTable :: Map String Operator
instance Eq PStatement
instance Show PStatement
instance Eq PModule
instance Show PModule
instance PyPretty Expr
instance PyPretty PStatement
instance PyPretty PModule
instance PyPretty Operator
instance PyPretty Symbol


-- | Sifflet to abstract syntax tree for Python. Use Python module's
--   pyPretty to pretty-print the result.
module Language.Sifflet.Export.ToPython

-- | Options for Python export. Should probably include choices like
--   Python2 or Python3; if statement or if expression. Right now, just a
--   placeholder.
data PythonOptions
PythonOptions :: PythonOptions
defaultPythonOptions :: PythonOptions
exprToPExpr :: Expr -> Expr

-- | Convert Sifflet name (of a function) to Python operator (Left) or
--   function name (Right)
nameToPython :: String -> Either Operator String

-- | Remove characters that are not valid in a Python identifier, and in
--   some cases, insert other characters to show what's missing
fixIdentifierChars :: String -> String

-- | Create a Python def statement from a Sifflet function. Minimally
--   parenthesized.
functionToPyDef :: Function -> PStatement
defToPy :: FunctionDefTuple -> PStatement
functionsToPyModule :: Functions -> PModule
functionsToPrettyPy :: Functions -> String
exportPython :: PythonOptions -> Exporter
instance Eq PythonOptions
instance Show PythonOptions

module Language.Sifflet.ExprTree

-- | EXPRESSION TREES For pure Sifflet, so not defined for extended
--   expressions.
type ExprTree = Tree ExprNode
data ExprNode
ENode :: ExprNodeLabel -> EvalResult -> ExprNode
data ExprNodeLabel
NUndefined :: ExprNodeLabel
NSymbol :: Symbol -> ExprNodeLabel
NBool :: Bool -> ExprNodeLabel
NChar :: Char -> ExprNodeLabel
NNumber :: Number -> ExprNodeLabel
NString :: String -> ExprNodeLabel
NList :: [Expr] -> ExprNodeLabel

-- | Counts the number of inlets and outlets for an ExprNode
exprNodeIoletCounter :: Env -> [ArgSpec] -> IoletCounter ExprNode
exprToTree :: Expr -> ExprTree

-- | Convert an expression tree (back) to an expression It will not give
--   back the *same* expression in the case of an EList.
treeToExpr :: ExprTree -> SuccFail Expr
exprToReprTree :: Expr -> Tree String
evalTree :: ExprTree -> Env -> ExprTree
unevalTree :: ExprTree -> ExprTree
instance Eq ExprNodeLabel
instance Show ExprNodeLabel
instance Eq ExprNode
instance Show ExprNode
instance Repr ExprNode

module Data.Sifflet.Functoid

-- | A Functoid is either a FunctoidParts, representing a partially defined
--   function, or a (completely defined) Function. A FunctoidParts
--   represents an incompletely defined function, which has a function
--   name, argument names, and a list of graph nodes representing the
--   function body which might not yet form a complete expression tree,
--   e.g., nodes might be unconnected.
data Functoid
FunctoidParts :: String -> [String] -> [Node] -> Functoid
fpName :: Functoid -> String
fpArgs :: Functoid -> [String]
fpNodes :: Functoid -> [Node]
FunctoidFunc :: Function -> Functoid
fpFunc :: Functoid -> Function
functoidName :: Functoid -> String
functoidArgNames :: Functoid -> [String]
functoidHeader :: Functoid -> String

-- | What is a FunctoidLayout? You can think of it as a tree layout for a
--   Frame, or for a Functoid, or as a Forest of Tree Layouts! For an Edit
--   frame, it must be a forest, since the nodes are not yet necessarily
--   connected into a tree. For a call frame, it will be a single
--   TreeLayout (singleton list).
data FunctoidLayout
FLayoutTree :: (TreeLayout ExprNode) -> FunctoidLayout
FLayoutForest :: [TreeLayout ExprNode] -> BBox -> FunctoidLayout

-- | Graphically lay out the Functoid. mvalues: Nothing implies an uncalled
--   frame, Just values implies a called frame, even with 0 arguments.
flayout :: Style -> Functoid -> Env -> Maybe [Value] -> FunctoidLayout
flayoutBBox :: FunctoidLayout -> BBox
flayoutSize :: FunctoidLayout -> Size
flayoutWidth :: FunctoidLayout -> Double
flayoutBottom :: FunctoidLayout -> Double
flayoutWiden :: FunctoidLayout -> Double -> FunctoidLayout
instance Show Functoid
instance Translate FunctoidLayout

module Graphics.Rendering.Sifflet.Draw
class Draw a
draw :: Draw a => Style -> DrawMode -> a -> Render ()
data DrawMode
DrawNormal :: DrawMode
DrawActive :: DrawMode
DrawSelectedNode :: DrawMode
DrawSelectedInlet :: Int -> DrawMode
DrawSelectedOutlet :: Int -> DrawMode
drawBox :: Maybe VColor -> Maybe VColor -> BBox -> Render ()
drawTextBox :: Maybe VFont -> Maybe VColor -> Maybe VColor -> VColor -> TextBox -> Render ()
modeTextCol :: DrawMode -> (Style -> VColor)
modeEdgeCol :: DrawMode -> (Style -> VColor)
modeFillCol :: DrawMode -> (Style -> VColor)
setColor :: VColor -> Render ()
instance Eq DrawMode
instance Draw Circle
instance Draw Iolet
instance Draw Position
instance Draw BBox
instance Draw TextBox
instance Draw (GNode e)
instance Draw (LayoutNode e)
instance Draw e => Draw (Tree e)
instance Draw e => Draw [e]
instance Draw FunctoidLayout

module Data.Sifflet.WGraph

-- | Two kinds of WNodes: A WSimple node represents a node in an expression
--   tree, e.g., <a>if</a>, <a>+</a> A WFrame node represents a panel or
--   frame that displays an expression tree, function call, or something
--   similar.
data WNode
WSimple :: (LayoutNode ExprNode) -> WNode
WFrame :: Node -> WNode
newtype WEdge
WEdge :: Int -> WEdge

-- | A WGraph consists of WNodes with (sort of) Int-labled edges; the edge
--   labels serve to order the children of a node.
type WGraph = Gr WNode WEdge
type WContext = Context WNode WEdge
wgraphNew :: WGraph
isWSimple :: WNode -> Bool
isWFrame :: WNode -> Bool

-- | Insert new node with given label into graph, without any new edges;
--   return the new graph and the new node (number)
grInsertNode :: DynGraph g => g n e -> n -> (g n e, Node)

-- | Remove a node from the graph; return the updated graph.
grRemoveNode :: DynGraph g => g n e -> Node -> (g n e)
connectToFrame :: Node -> Node -> WGraph -> WGraph

-- | Connect parent to child, using inlet as the order of the child (0, 1,
--   ...). outlet is ignored, since there is only outlet 0. As rendered,
--   the parent's inlet-th inlet will have a line to the child's outlet-th
--   outlet. This is achieved by inserting a labeled edge (parent, child,
--   inlet) and clearing any incompatible edge. The incompatibles are: a.
--   from same parent on same inlet to a different child. b. from the same
--   parent on a different inlet to the same child. c. from same child (on
--   same outlet) to a different parent.
--   
--   NOTE: This is confusing, because, from the data flow perspective, data
--   flows OUT of the child INTO the parent, but from the <a>tree in
--   graph</a> perspective, links are directed OUT of the parent INTO the
--   child. So beware!
grConnect :: WGraph -> Node -> WEdge -> Node -> WEdge -> WGraph

-- | Removes a link between parent and child where the edge was labeled
--   inlet (order of child). Ignores outlet, which should always be 0. If
--   child is not the inlet-th child of parent, well, this is an error, but
--   grDisconnect ignores it. If toFrameP is true, the child node is
--   reconnected as a child to its frame
grDisconnect :: WGraph -> Node -> WEdge -> Node -> WEdge -> Bool -> WGraph
grAddGraph :: DynGraph g => g n e -> g n e -> g n e

-- | Extract from a graph the expression with root node n, returning a Tree
--   of ExprNode. Use only the WSimple nodes of the graph (and n had better
--   be one).
grExtractExprTree :: WGraph -> Node -> Tree ExprNode

-- | Extract just the single tree layout node of the given graph node
grExtractLayoutNode :: WGraph -> Node -> LayoutNode ExprNode

-- | Extract the tree layout (tree) descended from the given root node
grExtractLayoutTree :: WGraph -> Node -> TreeLayout ExprNode

-- | Finding characteristics of the WNodes in a graph It is an implicit
--   error if there is no label for the node
--   
--   wlab is like lab with no Maybe: the node *must* have a label
wlab :: WGraph -> Node -> WNode

-- | llab is the tree layout node of a WSimple node
llab :: WGraph -> Node -> LayoutNode ExprNode

-- | The ExprNode represented by the graph node
nodeExprNode :: WGraph -> Node -> ExprNode

-- | The repr of the node's value
nodeText :: WGraph -> Node -> String

-- | The result of an evaluated node in an expression tree
nodeValue :: WGraph -> Node -> EvalResult

-- | The node's BBox
nodeBBox :: WGraph -> Node -> BBox
nodePosition :: WGraph -> Node -> Position
nodeInputValues :: WGraph -> Node -> EvalResult

-- | Find all parentless nodes in a graph
graphOrphans :: Graph graph => graph a b -> [Node]

-- | Connect the given children to a new parent
adoptChildren :: WGraph -> Node -> [Node] -> WGraph

-- | Finding the children (nodes, numbers) of a node in a graph : all
--   children, only WSimple-labeled children, only WFrame-labeled children
--   When constructing the graph, ordered children of a tree node get graph
--   node numbers in ascending order; therefore, sorting the graph nodes
--   gives back the original order of children in the tree (plus WFrames
--   that are added later, and those should always be after the simple
--   children)
nodeAllChildren :: WGraph -> Node -> [Node]
nodeSimpleChildren :: WGraph -> Node -> [Node]

-- | All (proper and improper) descendants of a node in a graph
allDescendants :: Graph graph => graph a b -> Node -> [Node]
nodeFrameChildren :: WGraph -> Node -> [Node]
nodeAllSimpleDescendants :: WGraph -> Node -> [Node]
nodeProperSimpleDescendants :: WGraph -> Node -> [Node]
nodeIsSimple :: WGraph -> Node -> Bool

-- | An open node has a WFrame-labeled child
nodeIsOpen :: WGraph -> Node -> Bool

-- | The graph node of the frame that contains the given node
nodeContainerFrameNode :: WGraph -> Node -> Node

-- | The parent (if any) of a node
nodeParent :: WGraph -> Node -> Maybe Node
grUpdateFLayout :: WGraph -> [Node] -> FunctoidLayout -> WGraph

-- | Replace the tree embedded in graph g with root n, with a new tree.
grUpdateTreeLayout :: WGraph -> Node -> TreeLayout ExprNode -> WGraph

-- | Print a description of the WGraph
printWGraph :: WGraph -> IO ()
translateNodes :: Double -> Double -> WGraph -> [Node] -> WGraph
translateNode :: Double -> Double -> WGraph -> Node -> WGraph

-- | Replace the label of a node in a graph
grRelabelNode :: DynGraph g => g a b -> Node -> a -> g a b

-- | Translate the nodes forming a tree with the given root
translateTree :: Double -> Double -> WGraph -> Node -> WGraph

-- | Get the parts of a Functoid. See note on functionToParts (just below).
--   Seems to be unused ***
functoidParts :: Functoid -> WGraph -> Node -> Functoid

-- | Convert a function to its parts. COULDN'T THIS BE DONE USING the
--   function's implementation, and not need to use the graph? Then this
--   could go in Functoid.hs without circular import between it and WGraph
functionToParts :: Function -> WGraph -> Node -> Functoid

-- | Filter the nodes of a graph
nfilter :: (Node -> Bool) -> Gr v e -> Gr v e
instance Eq WEdge
instance Read WEdge
instance Show WEdge
instance Eq WNode
instance Show WNode
instance Repr WNode
instance Ord WEdge

module Graphics.UI.Sifflet.Frame

-- | A CanvFrame represents (indirectly, through cfRoot, and we access to
--   the graph which is provided by the VCanvas) a <a>subgraph</a> such as
--   the expression tree of a function which is being edited or called.
data CanvFrame
CanvFrame :: TextBox -> TextBox -> [String] -> Maybe Node -> Node -> Env -> BBox -> Double -> Functoid -> FrameType -> CanvFrame

-- | top area of the frame
cfHeader :: CanvFrame -> TextBox

-- | bottom area
cfFooter :: CanvFrame -> TextBox

-- | variable (parameter) names
cfVarNames :: CanvFrame -> [String]

-- | the node opened to make this frame
cfParent :: CanvFrame -> Maybe Node

-- | this frame as a node in the graph; also serves as the ID of the frame.
cfFrameNode :: CanvFrame -> Node

-- | environment for evaluation
cfEnv :: CanvFrame -> Env

-- | box of the whole frame (header, tree, and footer)
cfBox :: CanvFrame -> BBox

-- | 0 = bottom level, 1 = next higher, etc.
cfLevel :: CanvFrame -> Double

-- | includes tlo for an edit frame
cfFunctoid :: CanvFrame -> Functoid

-- | edit or call frame
frameType :: CanvFrame -> FrameType
data FrameType
EditFrame :: FrameType
CallFrame :: FrameType

-- | argIoletCounter returns (no. of inlets, no. of outlets) derived from
--   the argument list of a function still being defined
argIoletCounter :: [String] -> ExprNode -> (Int, Int)
atLeastSizeFrame :: Size -> CanvFrame -> CanvFrame

-- | A frame is <a>eval ready</a> -- that is, okay to run the Eval Frame
--   dialog -- if it is a call frame with no parent
cfEvalReady :: CanvFrame -> Bool
cfPointInHeader :: CanvFrame -> Double -> Double -> Bool
cfPointInFooter :: CanvFrame -> Double -> Double -> Bool

-- | The root of the tree displayed in the frame
cfRoot :: CanvFrame -> Node

-- | Figure out the frame layout for a function. Returns the layout and
--   frame. Currently, the frame is marked as a <a>call frame</a>; if you
--   want to edit it, call (editFrame? editFunction?)
frameNewWithLayout :: Style -> Position -> Double -> Functoid -> Maybe [Value] -> FrameType -> Node -> Env -> Maybe Node -> (CanvFrame, FunctoidLayout)
frameBodyBox :: CanvFrame -> BBox
frameNodeAt :: CanvFrame -> WGraph -> Position -> Maybe Node

-- | Where to position a new frame that is grown out of an old frame? This
--   is a very rough draft of frameOffset
frameOffset :: Style -> CanvFrame -> Position

-- | Use levelOrder for sorting frames before drawing them
levelOrder :: CanvFrame -> CanvFrame -> Ordering
nodeCompoundFunction :: WGraph -> CanvFrame -> Node -> Maybe Function
pointIolet :: Position -> Int -> [Iolet] -> Maybe Int
resizeFrame :: CanvFrame -> Double -> Double -> CanvFrame
translateFrame :: CanvFrame -> Double -> Double -> CanvFrame
grTranslateFrameNodes :: WGraph -> CanvFrame -> Double -> Double -> WGraph
instance Eq FrameType
instance Read FrameType
instance Show FrameType
instance Show CanvFrame
instance Eq CanvFrame

module Graphics.UI.Sifflet.Types

-- | VPUI: Sifflet (formerly VisiProg) User Interface The initialEnv is apt
--   to contain <a>builtin</a> functions; it's preserved here so that when
--   writing to a file, we can skip the functions that were in the initial
--   env.
data VPUI
VPUI :: Map WinId VPUIWindow -> [(String, VPToolkit)] -> Maybe FilePath -> Style -> Env -> Env -> Env -> Bool -> VPUI

-- | all the windows of the program
vpuiWindows :: VPUI -> Map WinId VPUIWindow

-- | ordered association list, collections of tools
vpuiToolkits :: VPUI -> [(String, VPToolkit)]

-- | the file opened or to save
vpuiFilePath :: VPUI -> Maybe FilePath

-- | for windows, canvases, editors
vpuiStyle :: VPUI -> Style

-- | initial value of global environment
vpuiInitialEnv :: VPUI -> Env

-- | the global environment
vpuiGlobalEnv :: VPUI -> Env

-- | global env as of last file open or save, used to detect unsaved
--   changes
vpuiFileEnv :: VPUI -> Env

-- | include debug commands in context menu?
vpuiDebugging :: VPUI -> Bool
type WinId = String
data VPUIWindow
VPUIWorkWin :: Workspace -> Window -> VPUIWindow
FunctionPadWindow :: Window -> [(String, RPanel)] -> VPUIWindow

-- | Tell whether the global environmkent has changed since the last file
--   open or save
vpuiFileChanged :: VPUI -> Bool

-- | Extract from the environment the part defined by the user But you
--   probably want to use Graphics.UI.Sifflet.Window.UserFunctions instead
--   of this.
vpuiUserEnvAList :: VPUI -> [(String, Value)]

-- | Insert a window in the window map
vpuiInsertWindow :: VPUI -> WinId -> VPUIWindow -> VPUI

-- | Try to get the VPUIWindow with the given window ID, return Just result
--   or Nothing
vpuiTryGetWindow :: VPUI -> WinId -> Maybe VPUIWindow

-- | Get the VPUIWindow with the given window ID; it is an error if this
--   fails.
vpuiGetWindow :: VPUI -> WinId -> VPUIWindow

-- | Apply an update function to a VPUIWindow with given window ID; it is
--   an error if this fails.
vpuiUpdateWindow :: VPUI -> WinId -> (VPUIWindow -> VPUIWindow) -> VPUI

-- | Replace a VPUIWindow with given window ID; it is an error if this
--   fails.
vpuiReplaceWindow :: VPUI -> WinId -> VPUIWindow -> VPUI

-- | Apply an update IO action to a VPUIWindow with given window ID; it is
--   an error if this fails.
vpuiUpdateWindowIO :: WinId -> (VPUIWindow -> IO VPUIWindow) -> VPUI -> IO VPUI

-- | Remove a window from the windows map; it has already been destroyed in
--   the GUI
vpuiRemoveVPUIWindow :: WinId -> VPUI -> VPUI

-- | Try to find canvas; fail gracefully
vpuiWindowLookupCanvas :: VPUIWindow -> Maybe VCanvas

-- | Find canvas or fail dramatically
vpuiWindowGetCanvas :: VPUIWindow -> VCanvas
vpuiWindowSetCanvas :: VPUIWindow -> VCanvas -> VPUIWindow
vpuiWindowModCanvas :: VPUIWindow -> (VCanvas -> VCanvas) -> VPUIWindow
vpuiWindowModCanvasIO :: VPUIWindow -> (VCanvas -> IO VCanvas) -> IO VPUIWindow

-- | Update the canvas of the specified window, without IO
vpuiModCanvas :: VPUI -> WinId -> (VCanvas -> VCanvas) -> VPUI

-- | Update the canvas of the specified window, with IO
vpuiModCanvasIO :: VPUI -> WinId -> (VCanvas -> IO VCanvas) -> IO VPUI
vpuiWindowWindow :: VPUIWindow -> Window

-- | Toolkit functions are organized in groups (rows) for presentation in a
--   toolbox
data VPToolkit
VPToolkit :: String -> Int -> [[Tool]] -> VPToolkit
toolkitName :: VPToolkit -> String
toolkitWidth :: VPToolkit -> Int
toolkitRows :: VPToolkit -> [[Tool]]

-- | A Toolbox is a framed VBox with a set of Toolbars attached
data Toolbox
Toolbox :: GtkFrame -> VBox -> Toolbox
toolboxFrame :: Toolbox -> GtkFrame
toolboxVBox :: Toolbox -> VBox
data Tool
Tool :: String -> (VCanvas -> IO VCanvas) -> ToolOp -> Tool
toolName :: Tool -> String
toolActivated :: Tool -> VCanvas -> IO VCanvas
toolOp :: Tool -> ToolOp

-- | ToolContext: The way a tool should be applied depends on where it is
--   being used
data ToolContext
TCWorkspace :: ToolContext
TCCallFrame :: CanvFrame -> ToolContext
TCEditFrame :: CanvFrame -> ToolContext
TCExprNode :: ToolContext
type CanvasToolOp = VCanvas -> ToolContext -> [Modifier] -> Double -> Double -> IO VCanvas

-- | ToolOp a is intended for a = VPUIWindow or VCanvas type ToolOp a =
--   VPUI -&gt; a -&gt; ToolContext -&gt; [Modifier] -&gt; Double -&gt;
--   Double -&gt; IO a
type ToolOp = VPUI -> WinId -> ToolContext -> [Modifier] -> Double -> Double -> IO VPUI

-- | A helper for making toolOps from actions on VCanvas
toToolOpVW :: CanvasToolOp -> ToolOp
data Workspace
Workspace :: VBox -> VCanvas -> HBox -> Statusbar -> [ArgSpec] -> Workspace

-- | container of the rest
wsRootWidget :: Workspace -> VBox

-- | the canvas
wsCanvas :: Workspace -> VCanvas
wsButtonBar :: Workspace -> HBox
wsStatusbar :: Workspace -> Statusbar

-- | none if not editing
wsArgToolSpecs :: Workspace -> [ArgSpec]

-- | A canvas that can display multiple boxes representing expressions or
--   function definitions or calls
data VCanvas
VCanvas :: GtkLayout -> Style -> WGraph -> [CanvFrame] -> Size -> (Double, Double) -> Maybe Tool -> Maybe Node -> Maybe Selection -> Maybe Dragging -> VCanvas
vcLayout :: VCanvas -> GtkLayout
vcStyle :: VCanvas -> Style
vcGraph :: VCanvas -> WGraph
vcFrames :: VCanvas -> [CanvFrame]
vcSize :: VCanvas -> Size
vcMousePos :: VCanvas -> (Double, Double)
vcTool :: VCanvas -> Maybe Tool
vcActive :: VCanvas -> Maybe Node
vcSelected :: VCanvas -> Maybe Selection
vcDragging :: VCanvas -> Maybe Dragging
data Selection
SelectionNode :: Node -> Selection
selNode :: Selection -> Node
SelectionInlet :: Node -> WEdge -> Selection
selNode :: Selection -> Node
selInEdge :: Selection -> WEdge
SelectionOutlet :: Node -> WEdge -> Selection
selNode :: Selection -> Node
selOutEdge :: Selection -> WEdge

-- | A Dragging keeps track of the object (node) being dragged and the
--   current mouse position.
data Dragging
Dragging :: Node -> Position -> Dragging
draggingNode :: Dragging -> Node
draggingPosition :: Dragging -> Position
instance Eq Selection
instance Read Selection
instance Show Selection
instance Eq Dragging
instance Read Dragging
instance Show Dragging

module Graphics.UI.Sifflet.Callback

-- | The CBMgr (Callback manager) encapsulates (in an enclosure, no less!)
--   an IORef VPUI. It is used *solely* to set up callbacks and similar
--   stuff in Gtk, where the callback needs access to the IORef. By passing
--   a CBMgr to a function, we can avoid passing the IORef directly, and
--   all the harm and confusion that could result.
--   
--   We only need *one* CBMgr for the application; however, two CBMgrs with
--   the same IORef are logically equivalent, so there would be no harm in
--   having two as long as they share one IORef.
type CBMgr = CBMgrCmd -> IO ()
type CBMgrAction = IORef VPUI -> IO ()

-- | Commands for the CBMgr
data CBMgrCmd
OnWindowConfigure :: Window -> (IORef VPUI -> EventM EConfigure Bool) -> CBMgrCmd
OnWindowDestroy :: Window -> CBMgrAction -> CBMgrCmd
AfterWindowKeyPress :: Window -> (IORef VPUI -> EventM EKey Bool) -> CBMgrCmd
OnLayoutExpose :: Layout -> (IORef VPUI -> EventM EExpose Bool) -> CBMgrCmd
OnLayoutMouseMove :: Layout -> (IORef VPUI -> EventM EMotion Bool) -> CBMgrCmd
OnLayoutButtonPress :: Layout -> (IORef VPUI -> EventM EButton Bool) -> CBMgrCmd
OnLayoutButtonRelease :: Layout -> (IORef VPUI -> EventM EButton Bool) -> CBMgrCmd
OnMenuItemActivateLeaf :: MenuItem -> (VPUI -> IO VPUI) -> CBMgrCmd
OnEntryActivate :: Entry -> CBMgrAction -> CBMgrCmd
AfterButtonClicked :: Button -> CBMgrAction -> CBMgrCmd
WithUIRef :: CBMgrAction -> CBMgrCmd
UMTest :: CBMgrCmd

-- | Create the CBMgr
mkCBMgr :: IORef VPUI -> CBMgr
data MenuSpec
MenuSpec :: String -> [MenuItemSpec] -> MenuSpec
data MenuItemSpec
MenuItem :: String -> MenuItemAction -> MenuItemSpec
SubMenu :: MenuSpec -> MenuItemSpec
type MenuItemAction = VPUI -> IO VPUI
createMenuBar :: [MenuSpec] -> CBMgr -> IO MenuBar
addMenu :: MenuBar -> CBMgr -> MenuSpec -> IO ()
createMenu :: MenuSpec -> CBMgr -> IO Menu
createMenuItem :: Menu -> CBMgr -> MenuItemSpec -> IO ()

-- | Read an IORef, update with IO, and write the updated value. This is
--   like (flip modifyIORef), but the type of the first argument is (a
--   -&gt; IO a) instead of (a -&gt; a). Note that if a = VPUI, then
--   updateIO :: VPUI -&gt; IO VPUI and consequently modifyIORefIO updateIO
--   :: CBMgrAction.
modifyIORefIO :: (a -> IO a) -> IORef a -> IO ()


-- | A <a>panel</a> to be shown on the Function Editor, for adjusting the
--   arguments of the function being edited -- adding and deleting
--   arguments, or modifying their <a>kind</a> (number of inlets, needed
--   for higher order functions)
module Graphics.UI.Sifflet.EditArgsPanel
type ArgSpecAction = [ArgSpec] -> IO ()
data EditArgsPanel

-- | Create an EditArgsPanel It currently returns a EditArgsPanel object,
--   and you can put the root of it into a container, e.g., set window
--   [containerChild := editArgsPanelRoot panel]
--   
--   Frame | | +------------------------------+ | | | VBox | | | |
--   +--------------------------+ | | | | | Table (n+2 rows)x(3 cols)| | |
--   | | | +----------------------+ | | | | | | | | | | | | | | |
--   (arguments) | | | | | | | +----------------------+ | | | | | | | | | |
--   | | HButtonBox | | | | | | +----------------------+ | | | | | | |
--   (buttons) | | | | | | | +----------------------+ | | | | | | | | | | |
--   | Label | | | | | | +----------------------+ | | | | | | | (status
--   messages) | | | | | | | +----------------------+ | | | | |
--   +--------------------------+ | | | +------------------------------+ |
--   +----------------------------------+
makeEditArgsPanel :: CBMgr -> [ArgSpec] -> ArgSpecAction -> IO EditArgsPanel
editArgsPanelRoot :: EditArgsPanel -> PanelRoot

-- | Resize a widget to be at least as big as a(nother) widget. Normally
--   the widget being resized is one that contains the other.
expandToFit :: (WidgetClass v, WidgetClass w) => v -> w -> IO ()
instance Show Model

module Language.Sifflet.TypeCheck

-- | Determine the type of a value. May result in a type variable.
valueType :: Value -> SuccFail Type

-- | Check whether the values agree with the types (which may be abstract)
--   
--   This is *probably* too lenient in the case of type variables: it can
--   pass a mixed-type list.
typeCheckValues :: [String] -> [Type] -> [Value] -> SuccFail [Value]
typeVarsIn :: Type -> [TypeVarName]

-- | The type of a substitution function, which maps type variables to
--   types
type Subst = TypeVarName -> Type

-- | Apply a substitution function to a type (possibly a type with
--   variables)
subst :: Subst -> Type -> Type

-- | Composing two substitutions
substComp :: Subst -> Subst -> Subst

-- | Identity substitution
idSubst :: Subst

-- | A delta substitution is one that affects just a single variable.
deltaSubst :: TypeVarName -> Type -> Subst

-- | Try to extend a substitution by adding a single variable-value pair
extend :: Subst -> TypeVarName -> Type -> SuccFail Subst
unify :: Subst -> (Type, Type) -> SuccFail Subst

-- | A TypeScheme (TypeScheme schematicVariables typeExpression) is a sort
--   of type template, in which schematic variables (i.e., type parameters
--   or <a>generics</a>) are made explicit; any other type variables in the
--   type expression are unknowns
data TypeScheme
TypeScheme :: [TypeVarName] -> Type -> TypeScheme
schematicsTS :: TypeScheme -> [TypeVarName]
unknownsTS :: TypeScheme -> [TypeVarName]

-- | Apply a substitution to a type scheme, taking care to affect only the
--   unknowns, not the schematic variables
substTS :: Subst -> TypeScheme -> TypeScheme

-- | A type environment maps type variable names to type schemes. Oh, is it
--   really type variable names, or just names? It seems to me that in
--   envToTypeEnv, it's function names, instead of type variable names.
type TypeEnv = Map TypeVarName TypeScheme
emptyTypeEnv :: TypeEnv

-- | Insert a new type variable and its type scheme value
install :: TypeEnv -> TypeVarName -> TypeScheme -> TypeEnv

-- | The unknowns of a type environment
unknownsTE :: TypeEnv -> [TypeVarName]
substTE :: Subst -> TypeEnv -> TypeEnv

-- | A source of variable names
data NameSupply
NameSupply :: TypeVarName -> Int -> NameSupply

-- | Creates a name supply
newNameSupply :: TypeVarName -> NameSupply

-- | Produces next variable from a name supply
nameSupplyNext :: NameSupply -> (TypeVarName, NameSupply)

-- | Produces next several variables from a name supply
nameSupplyTake :: NameSupply -> Int -> ([TypeVarName], NameSupply)

-- | Type check an expression
tcExpr :: TypeEnv -> NameSupply -> Expr -> SuccFail (Subst, Type, NameSupply)
tcExprs :: TypeEnv -> NameSupply -> [Expr] -> SuccFail (Subst, [Type], NameSupply)

-- | Type check a variable (actually the variable name). Find the type
--   scheme associated with the variable in the type environment. Return a
--   <a>new instance</a> of the type scheme, in which its schematic
--   variables are replaced by new variables, and the unknowns are left as
--   they are.
tcVar :: TypeEnv -> NameSupply -> String -> SuccFail (Subst, Type, NameSupply)
newInstance :: NameSupply -> TypeScheme -> (Type, NameSupply)
arrow :: Type -> Type -> Type

-- | Create a TypeEnv from an Env Bindings on the left replace bindings of
--   the same name on the right, if any.
envToTypeEnv :: Env -> TypeEnv

-- | The base type environment, derived from the base environment of the
--   Sifflet language (built-in functions)
baseTypeEnv :: TypeEnv
fromLambdaType :: Type -> SuccFail ([Type], Type)

-- | Decide the type of a function -- called by the function editor when
--   the Apply button is clicked. decideTypes tries to find the argument
--   types and return type of an expression considered as the body of a
--   function, at the same time checking for consistency of inputs and
--   outputs between the parts of the expression. It returns Succ
--   (argtypes, returntype) if successful; Fail errormessage otherwise.
decideTypes :: String -> Expr -> [String] -> Env -> SuccFail ([Type], Type)
instance Eq TypeScheme
instance Show TypeScheme
instance Eq NameSupply
instance Show NameSupply

module Data.Sifflet.TreeGraph
type LayoutGraph n e = Gr (LayoutNode n) e
flayoutToGraph :: FunctoidLayout -> WGraph
treeLayoutToGraph :: TreeLayout ExprNode -> WGraph
orderedTreeToGraph :: Tree e -> Gr e WEdge
treeGraphNodesTree :: Tree e -> Tree Node
graphToTreeOriginal :: Gr e () -> Node -> Tree e
graphToTreeStructure :: Gr n e -> Node -> Tree Node
flayoutToGraphRoots :: FunctoidLayout -> [Node]
graphToOrderedTree :: Gr e WEdge -> Tree e
graphToOrderedTreeFrom :: Gr e WEdge -> Node -> Tree e

-- | List of the nodes children, ordered by edge number
orderedChildren :: Gr e WEdge -> Node -> [Node]
adjCompareEdge :: (Node, WEdge) -> (Node, WEdge) -> Ordering
nextNodes :: [e] -> Node -> ([Node], Node)
grTranslateNode :: Node -> Double -> Double -> LayoutGraph n e -> LayoutGraph n e
grTranslateSubtree :: Node -> Double -> Double -> LayoutGraph n e -> LayoutGraph n e
grTranslateGraph :: Double -> Double -> LayoutGraph n e -> LayoutGraph n e
functoidToFunction :: Functoid -> WGraph -> Node -> Env -> SuccFail Function
graphToExprTree :: WGraph -> Node -> Tree ExprNode


-- | Tree graph rendering
module Graphics.Rendering.Sifflet.DrawTreeGraph
graphQuickView :: (Graph g, Show a, Show b) => g a b -> IO ()
graphWriteImageFile :: Repr n => Style -> Maybe Node -> Maybe Node -> Double -> Double -> LayoutGraph n e -> String -> IO String
graphRender :: Repr n => Style -> Maybe Node -> Maybe Node -> LayoutGraph n e -> Render ()
treeRender :: Repr e => Style -> TreeLayout e -> Render ()
treeWriteImageFile :: Repr e => Style -> IoletCounter e -> Tree e -> String -> IO String
gtkShowTree :: (Repr e, Show e) => Style -> IoletCounter e -> Tree e -> IO ()


-- | A parser for Sifflet input values. This is not a parser for all
--   Sifflet expressions, but just those that might be input in textual
--   form through the function call dialog that asks for the argument
--   values. So, it is limited (deliberately) to <a>data</a> types of
--   expressions: that is, Exprs using the constructors: ELit EList That
--   means excluding Exprs constructed with EUndefined, ESymbol, EIf,
--   ELambda, and ECall.
module Language.Sifflet.Parser

-- | Parse a Sifflet data literal (number, string, char, bool, or list),
--   returning an Expr
parseExpr :: String -> SuccFail Expr

-- | Parse a Sifflet literal expression and return its Value
parseValue :: String -> SuccFail Value
parseLiteral :: String -> SuccFail Expr

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
parseSuccFail :: Parser a -> String -> SuccFail a

-- | Try to parse an input value of a specific type
parseTypedInput2 :: (String, Type) -> SuccFail Value

-- | Try to parse input values of specific types
parseTypedInputs2 :: [String] -> [Type] -> SuccFail [Value]

-- | Try to parse an input value for a named variable of a specific type
parseTypedInput3 :: (String, String, Type) -> SuccFail Value

-- | Try to parse input values for named variables of specific types
parseTypedInputs3 :: [String] -> [String] -> [Type] -> SuccFail [Value]

-- | 'nothingBut p is like <tt>p</tt>, but consumes the entire input, so
--   there must be no extraneous characters (except space) after whatever
--   <tt>p</tt> parses.
nothingBut :: Parser a -> Parser a

-- | Parse a Sifflet data expression -- actually only a literal or a list
--   of literals.
expr :: Parser Expr
list :: Parser a -> Parser [a]

-- | Parser for a Value of any primitive or (concrete) list type
value :: Parser Value

-- | Parser for a value with a specific primitive or concrete list type
--   expected.
typedValue :: Type -> Parser Value
bool :: Parser Bool
qchar :: Parser Char
qstring :: Parser String
integer :: Parser Integer
double :: Parser Double
number :: Parser Number

module Graphics.UI.Sifflet.Canvas

-- | Return a canvas of at least the specified size and otherwise like the
--   given canvas.
atLeastSize :: Size -> VCanvas -> VCanvas
cfContext :: CanvFrame -> ToolContext

-- | Connect nodes
connect :: VCanvas -> Node -> WEdge -> Node -> WEdge -> IO VCanvas
defaultFileSaveClipBox :: VCanvas -> BBox

-- | Disconnect nodes
disconnect :: VCanvas -> Node -> WEdge -> Node -> WEdge -> IO VCanvas

-- | Draw the canvas in its window, on screen
drawCanvas :: VCanvas -> Rectangle -> IO ()

-- | editFunction: reverse of defineFunction: replace the call frame by an
--   edit frame; does not change the VPUI (global env.), just the canvas..
editFunction :: VCanvas -> CanvFrame -> IO VCanvas
frameChanged :: VCanvas -> WGraph -> CanvFrame -> WGraph -> CanvFrame -> IO ()
nodeContainerFrame :: VCanvas -> WGraph -> Node -> CanvFrame

-- | What is selected (if anything) at a point
pointSelection :: WGraph -> CanvFrame -> Position -> Maybe Selection

-- | Render the canvas in Cairo (use with renderWith to provide an
--   alternate surface, such as an SVG file).
renderCanvas :: VCanvas -> BBox -> Bool -> Render ()

-- | Add a frame representing a functoid to the canvas.
--   
--   Use mvalues = Nothing if you do not want the frame to be evaluated as
--   a function call, otherwise mvalues = Just values.
--   
--   prevEnv is *supposed* to be the previous environment, i.e., that of
--   the <a>parent</a> frame or the canvas, not of the new frame, because
--   vcAddFrame itself will extend the environment with the new (vars,
--   values). But this is odd, because openNode calls vcAddFrame apparently
--   with the *new* environment as prevEnv, and yet it works correctly.
--   
--   Caution: I think it is necessary for the canvas to have been realized
--   before calling this function!
vcAddFrame :: VCanvas -> Functoid -> Maybe [Value] -> FrameType -> Env -> Double -> Double -> Double -> Maybe Node -> IO VCanvas

-- | Make nothing be selected
vcClearSelection :: VCanvas -> IO VCanvas

-- | vcClearFrame - clear a frame in a canvas; not yet implemented What
--   does this mean?
vcClearFrame :: VCanvas -> CanvFrame -> IO VCanvas

-- | Close a frame and any subframes of it
vcCloseFrame :: VCanvas -> CanvFrame -> IO VCanvas
vcEvalDialog :: VCanvas -> CanvFrame -> IO VCanvas
vcFrameAddFunctoidNode :: VCanvas -> CanvFrame -> Functoid -> Double -> Double -> IO VCanvas
vcFrameAddNode :: VCanvas -> CanvFrame -> ExprNode -> [String] -> Double -> Double -> IO VCanvas
vcFrameDeleteNode :: VCanvas -> CanvFrame -> Node -> IO VCanvas

-- | Remove the (sub)tree rooted at the given node. Removes it from the
--   graph of the canvas and from the FunctoidParts of the frame.
vcFrameDeleteTree :: VCanvas -> CanvFrame -> Node -> IO VCanvas

-- | Find a frame's subframes, i.e., those that were expanded to trace the
--   execution of a function call. Cannot be in an edit frame.
vcFrameSubframes :: VCanvas -> CanvFrame -> [CanvFrame]
vcGetFrame :: VCanvas -> WGraph -> Node -> CanvFrame
vcInvalidateFrameWithParent :: VCanvas -> WGraph -> CanvFrame -> IO ()
vcInvalidateBox :: VCanvas -> BBox -> IO ()

-- | Ask the vcanvas to update the frame and install a new graph. Frames
--   are identified by their frame nodes, so the new frame must have the
--   same frame node as the old. It is an unreported error if there is not
--   exactly one match.
vcUpdateFrameAndGraph :: VCanvas -> CanvFrame -> WGraph -> VCanvas
vcanvasNew :: Style -> Double -> Double -> IO VCanvas

-- | Find the node, if any, at a given position on the canvas.
vcanvasNodeAt :: VCanvas -> Position -> Maybe Node
vcanvasNodeRect :: VCanvas -> Node -> Rectangle
whichFrame :: VCanvas -> Double -> Double -> Maybe CanvFrame

-- | Find the frames that are calling the named function
callFrames :: VCanvas -> String -> [CanvFrame]

module Graphics.UI.Sifflet.Tool
data ToolId
ToolConnect :: ToolId
ToolDisconnect :: ToolId
ToolIf :: ToolId
ToolMove :: ToolId
ToolDelete :: ToolId

-- | function name
ToolFunction :: String -> ToolId
ToolLiteral :: Expr -> ToolId

-- | argument name, no. of inputs
ToolArg :: String -> Int -> ToolId

-- | Check that all required modifiers are in found
checkMods :: [Modifier] -> [Modifier] -> Bool
functionArgToolSpecs :: Function -> [ArgSpec]
functionTool :: String -> Tool
functionToolsFromLists :: [[String]] -> [[Tool]]
makeConnectTool :: Tool
makeCopyTool :: Tool
makeDeleteTool :: Tool
makeDisconnectTool :: Tool
makeIfTool :: Tool
makeMoveTool :: Tool

-- | Open an entry for user input of function name to select a function
--   tool. Returns unaltered VPUI, for convenience in menus and key
--   callbacks.
showFunctionEntry :: WinId -> CBMgr -> VPUI -> IO VPUI

-- | Show an entry for input of a literal value. Returns unaltered VPUI,
--   for convenience in menus and key callbacks.
showLiteralEntry :: WinId -> CBMgr -> VPUI -> IO VPUI
vpuiSetTool :: ToolId -> WinId -> VPUI -> IO VPUI
vpuiWindowSetTool :: Tool -> VPUIWindow -> IO VPUIWindow

-- | Add a frame representing a functoid to the canvas of a VPUIWindow
--   (which ought to have a canvas, of course). Otherwise like vcAddFrame.
vwAddFrame :: VPUIWindow -> Functoid -> Maybe [Value] -> FrameType -> Env -> Double -> Double -> Double -> Maybe Node -> IO VPUIWindow

-- | Add a frame representing a functoid to the canvas of a particular
--   window, specified by its window id (title).
vpuiAddFrame :: VPUI -> WinId -> Functoid -> Maybe [Value] -> FrameType -> Env -> Double -> Double -> Double -> Maybe Node -> IO VPUI
wsPopStatusbar :: Workspace -> IO ()
wsPushStatusbar :: Workspace -> String -> IO ()

-- | For debugging (frame context menu command)
dumpFrame :: VPUI -> WinId -> CanvFrame -> IO ()

-- | For debugging (frame context menu command)
dumpGraph :: VPUI -> WinId -> IO ()

-- | For debugging the window's widget children
dumpWorkWin :: VPUI -> WinId -> IO ()

-- | Clear frame indicated by mouse location
clearFrame :: WinId -> CanvFrame -> VPUI -> IO VPUI

-- | Close frame (context menu command)
closeFrame :: VPUI -> WinId -> CanvFrame -> IO VPUI
instance Eq ToolId
instance Show ToolId

module Graphics.UI.Sifflet.Workspace

-- | Create a new VPUI. This used to set up the basic <a>q to quit</a> and
--   <a>on exposed</a> callbacks, but now does not even do that. The
--   <a>init</a> function argument may perform additional initialization;
--   if there is none, simply use <a>return</a>.
vpuiNew :: Style -> Env -> Bool -> IO VPUI

-- | Create a new <a>main</a> workspace window, with a given style. The
--   second argument should set up a menu bar and place it on the vbox, or
--   do nothing if no menu is wanted.
workspaceNewDefault :: Style -> (VBox -> IO ()) -> IO Workspace
workspaceNewEditing :: Style -> Env -> Function -> IO Workspace
addFedWinButtons :: CBMgr -> WinId -> VPUI -> IO ()

-- | Context menu command to apply the function definition of an EditFrame.
--   
--   <a>Execute</a> the definition currently represented in the frame,
--   i.e., bind the function name in the global environment to the function
--   definition found in the frame.
defineFunction :: WinId -> CanvFrame -> VPUI -> IO VPUI
workspaceId :: String
openNode :: VPUIWindow -> Node -> IO VPUIWindow

-- | This function is called either when a window *has been* destroyed,
--   with destroy = False, or when you *want to* destroy a window, with
--   destroy = True.
--   
--   removeWindow actually *closes* the window if destroy = True, as well
--   as removing it from the vpui's windows map.
removeWindow :: VPUI -> Bool -> WinId -> IO VPUI
vpuiQuit :: VPUI -> IO VPUI

-- | Perform action on all windows (actually (WinId, VPUIWindow) pairs.
--   Returns updated VPUI (in case any windows are changed).
forallWindowsIO :: (VPUIWindow -> IO VPUIWindow) -> VPUI -> IO VPUI
baseFunctionsRows :: [[String]]

module Language.Sifflet.Export.ToScheme
data SExpr
SAtom :: Atom -> SExpr
SList :: [SExpr] -> SExpr
data Atom
SFloat :: Double -> Atom
SInt :: Integer -> Atom
SSymbol :: String -> Atom
SString :: String -> Atom
SChar :: Char -> Atom
SBool :: Bool -> Atom
SFunction :: Function -> Atom
type Indent = Int

-- | The type of a function to export (user) functions to a file.
type Exporter = Functions -> FilePath -> IO ()
data SchemeOptions
SchemeOptions :: Bool -> SchemeOptions

-- | use explicit lambda in function definitions, (define f (lambda (a b)
--   ...)
defineWithLambda :: SchemeOptions -> Bool
defaultSchemeOptions :: SchemeOptions
exprToSExpr :: Expr -> SExpr
functionNameToSchemeName :: String -> String
valueToSExpr :: Value -> SExpr
exprToSchemeRepr :: Expr -> String
exprToSchemePretty :: Expr -> String
exprToScheme :: Expr -> String

-- | Newline and indent
inl :: Int -> String

-- | sepLines2 is like sepLines, but adds an extra n between each pair of
--   lines so they are <a>double spaced.</a>
sepLines2 :: [String] -> String

-- | Convert Sifflet Functions to Scheme SExprs
functionsToSExprs :: SchemeOptions -> Functions -> [SExpr]

-- | Convert Sifflet Functions to pretty Scheme
functionsToPrettyScheme :: SchemeOptions -> Functions -> String

-- | Convert a FunctionDefTuple to a Scheme SExpr. Use the form (define
--   (name . args) body) except when there are zero arguments, which
--   becomes a Scheme constant rather than a function, use (define name
--   expr).
defToSExpr :: SchemeOptions -> FunctionDefTuple -> SExpr

-- | Export functions to a Scheme file.
exportScheme :: SchemeOptions -> Exporter
instance Eq Atom
instance Show Atom
instance Eq SExpr
instance Show SExpr
instance Eq SchemeOptions
instance Show SchemeOptions
instance Pretty SExpr
instance Repr SExpr


-- | SiffML : Sifflet Markup Language. An XML application for storing and
--   retrieving Sifflet programs and libraries.
module Language.Sifflet.SiffML
class ToXml a
toXml :: ToXml a => a -> XMLProducer
produceSiffMLFile :: ToXml a => a -> FilePath -> IO ()
consumeSiffMLFile :: XMLConsumer XmlTree a -> FilePath -> IO [a]
xmlToFunctions :: XMLConsumer XmlTree Functions

-- | testFromXml :: (ToXml a, Show a) =&gt; a -&gt; XMLConsumer XmlTree a
--   -&gt; IO () VVV This type generalization (a, a to a, b) is for
--   debugging, undo it later:
testFromXml :: (ToXml a, Show b) => Int -> a -> XMLConsumer XmlTree b -> IO ()
instance ToXml Functions
instance ToXml Function
instance ToXml Type
instance ToXml Value
instance ToXml Expr
instance ToXml Symbol

module Graphics.UI.Sifflet.Window

-- | Like showWindow, except that making the window visible is optional
getOrCreateWindow :: WinId -> CBMgr -> (VPUI -> Window -> IO VPUIWindow) -> (VPUI -> WinId -> CBMgr -> IO ()) -> Bool -> VPUI -> IO (VPUI, VPUIWindow, Bool)

-- | Finding, creating, and initializing windows (VPUIWindow)
--   
--   Find and show a window, if it exists. If not, create the window, put
--   it in the vpui's window map, and initialize it and any auxiliary
--   objects using the initWin function. The 3rd argument of initWin will
--   be the window's title. Always presents the window (shows and raises).
--   Returns a 3-tuple: the VPUIWindow contains the Window, and the Bool
--   value is True if the Window is new (and therefore might need some
--   further initialization). The third tuple element is an IORef to the
--   VPUIWindow; it may be useful for setting up signal and event handling.
showWindow :: WinId -> CBMgr -> (VPUI -> Window -> IO VPUIWindow) -> (VPUI -> WinId -> CBMgr -> IO ()) -> VPUI -> IO (VPUI, VPUIWindow, Bool)
newWindowTitled :: String -> IO Window

-- | Show a workspace window, with a given title, _not_ editing a function
showWorkWin :: VPUI -> WinId -> CBMgr -> IO VPUI

-- | Show a workspace window with a given title and maybe function to edit
showWorkspaceWindow :: WinId -> CBMgr -> Maybe Function -> VPUI -> IO (VPUI, VPUIWindow, Bool)

-- | Show a function editor window = a workspace window editing a given
--   function. Use argNames for a new function; ignore them if funcName is
--   bound.
showFedWin :: CBMgr -> String -> [String] -> VPUI -> IO VPUI
fedWindowTitle :: String -> WinId

-- | Create the function pad window if it doesn't exist
getOrCreateFunctionPadWindow :: CBMgr -> Bool -> VPUI -> IO VPUI

-- | Show the function pad window; create it if needed
showFunctionPadWindow :: CBMgr -> VPUI -> IO VPUI

-- | Ask user for new function name and arguments, then begin editing the
--   function.
newFunctionDialog :: WinId -> CBMgr -> VPUI -> IO VPUI

-- | Now that we have a file path, go ahead and open it, loading the
--   function definitions into Sifflet and adding buttons to the function
--   pad <a>My Functions</a> area.
openFilePath :: CBMgr -> FilePath -> VPUI -> IO VPUI
setWSCanvasCallbacks :: VPUI -> WinId -> CBMgr -> IO ()

-- | Help text built from key bindings
keyBindingsHelpText :: String

module Graphics.UI.Sifflet
