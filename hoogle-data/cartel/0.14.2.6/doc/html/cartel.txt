-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Specify Cabal files in Haskell
--   
@package cartel
@version 0.14.2.6


-- | The current version for the Cartel library. Having this in a separate
--   module allows for the <a>Cartel.GenCartelCabal</a> module to exist.
--   Without this module, I'd have to rely on the <tt>Paths_cartel</tt>
--   module to exist, which introduces some nasty bootstrapping issues for
--   <a>Cartel.GenCartelCabal</a> or, alternatively, some nasty circular
--   dependency issues if this value were included directly into
--   <a>Cartel.GenCartelCabal</a>.
module Cartel.Version
version :: [Word]

module Cartel.Types

-- | A non-empty string. This string should never be empty. It is used
--   where, for example, a field in a Cabal file is required to have a
--   value and that value cannot be empty. In contrast, Cartel uses an
--   ordinary <a>String</a> for values that can be empty.
--   
--   This is only a type synonym, so nothing in the type system enforces
--   that these strings must be non-empty. Typically though, Cabal will
--   give you grief about the file that Cartel generates if you used an
--   empty value for a <a>NonEmptyString</a>.
type NonEmptyString = String


-- | Internal workings of <a>Betsy</a>, the Cartel flag maker. Use of this
--   module may break <a>Betsy</a> invariants.
module Cartel.Betsy.Internal

-- | Errors that may result from running a <a>Betsy</a> computation.
data Error

-- | The user requested creation of a duplicate flag.
DuplicateFlag :: FlagName -> Error

-- | <a>fail</a> was invoked.
Failed :: String -> Error

-- | The user requested creation of a flag with an empty name.
EmptyFlagName :: Error
renderError :: Error -> String

-- | Computations that can create and use Cabal flags. Use of this type,
--   along with the <a>defaultMain</a> function ensures that any
--   <a>FlagName</a> you use has been properly set up by using
--   <a>makeFlag</a>. That way, you don't use flags in a <a>flag</a>
--   without actually declaring the flag. When <a>defaultMain</a> creates
--   your Cabal file, it will print the necessary <tt>Flag</tt> sections.
--   
--   <a>Betsy</a> is parameterized on a type, <tt>m</tt>. When this type is
--   a monad, <a>Betsy</a> is also a monad, allowing you to use use the
--   usual monad combinators and <tt>do</tt> notation. <a>Betsy</a> is also
--   a monad transformer.
newtype Betsy m a
Betsy :: ([Flag] -> m (Either Error (a, [Flag]))) -> Betsy m a

-- | The name of a flag, paired with its options.
data Flag
Flag :: FlagName -> FlagOpts -> Flag

-- | Options for flags, except for the flag's name.
data FlagOpts
FlagOpts :: String -> Bool -> Bool -> FlagOpts

-- | A one-line description of what the flag does; this is optional.
flagDescription :: FlagOpts -> String

-- | Is this flag on or off by default?
flagDefault :: FlagOpts -> Bool

-- | If a flag is manual, Cabal will not change its value. If a flag is not
--   manual, Cabal will change its value automatically to attempt to
--   satisfy the package's dependencies.
flagManual :: FlagOpts -> Bool

-- | The name of a flag. Only <a>makeFlag</a> creates flags; it will return
--   a <a>FlagName</a> to you. You can then use that <a>FlagName</a> in a
--   conditional using <a>flag</a>.
data FlagName
FlagName :: Char -> String -> FlagName
flagNameHead :: FlagName -> Char
flagNameTail :: FlagName -> String

-- | Creates new flags.
makeFlag :: Applicative m => NonEmptyString -> FlagOpts -> Betsy m FlagName
runBetsy :: Functor m => Betsy m a -> m (Either Error (a, [Flag]))

-- | Returns a list of all flags made so far.
currentFlags :: Applicative f => Betsy f [Flag]
instance Eq FlagOpts
instance Ord FlagOpts
instance Show FlagOpts
instance Eq FlagName
instance Ord FlagName
instance Show FlagName
instance Eq Flag
instance Ord Flag
instance Show Flag
instance Eq Error
instance Ord Error
instance Show Error
instance MonadIO m => MonadIO (Betsy m)
instance MonadTrans Betsy
instance (Monad m, Functor m) => Applicative (Betsy m)
instance Functor m => Functor (Betsy m)
instance Monad m => Monad (Betsy m)


-- | Public interface for <a>Betsy</a>, the Cartel flag maker. Simply
--   re-exports safe bindings from <a>Cartel.Betsy.Internal</a>.
module Cartel.Betsy

-- | The name of a flag. Only <a>makeFlag</a> creates flags; it will return
--   a <a>FlagName</a> to you. You can then use that <a>FlagName</a> in a
--   conditional using <a>flag</a>.
data FlagName
flagNameHead :: FlagName -> Char
flagNameTail :: FlagName -> String

-- | Options for flags, except for the flag's name.
data FlagOpts
FlagOpts :: String -> Bool -> Bool -> FlagOpts

-- | A one-line description of what the flag does; this is optional.
flagDescription :: FlagOpts -> String

-- | Is this flag on or off by default?
flagDefault :: FlagOpts -> Bool

-- | If a flag is manual, Cabal will not change its value. If a flag is not
--   manual, Cabal will change its value automatically to attempt to
--   satisfy the package's dependencies.
flagManual :: FlagOpts -> Bool

-- | The name of a flag, paired with its options.
data Flag
Flag :: FlagName -> FlagOpts -> Flag

-- | Computations that can create and use Cabal flags. Use of this type,
--   along with the <a>defaultMain</a> function ensures that any
--   <a>FlagName</a> you use has been properly set up by using
--   <a>makeFlag</a>. That way, you don't use flags in a <a>flag</a>
--   without actually declaring the flag. When <a>defaultMain</a> creates
--   your Cabal file, it will print the necessary <tt>Flag</tt> sections.
--   
--   <a>Betsy</a> is parameterized on a type, <tt>m</tt>. When this type is
--   a monad, <a>Betsy</a> is also a monad, allowing you to use use the
--   usual monad combinators and <tt>do</tt> notation. <a>Betsy</a> is also
--   a monad transformer.
data Betsy m a

-- | Errors that may result from running a <a>Betsy</a> computation.
data Error

-- | The user requested creation of a duplicate flag.
DuplicateFlag :: FlagName -> Error

-- | <a>fail</a> was invoked.
Failed :: String -> Error

-- | The user requested creation of a flag with an empty name.
EmptyFlagName :: Error
runBetsy :: Functor m => Betsy m a -> m (Either Error (a, [Flag]))

-- | Creates new flags.
makeFlag :: Applicative m => NonEmptyString -> FlagOpts -> Betsy m FlagName

-- | Returns a list of all flags made so far.
currentFlags :: Applicative f => Betsy f [Flag]


-- | The Cartel abstract syntax tree
--   
--   Use this module if you want access to the data constructors in the
--   AST; the functions and values exported through <a>Cartel</a> should be
--   enough for most uses. Use of this module will not violate any
--   invariants; this stuff is in a separate module merely for the sake of
--   tidiness of the documentation in <a>Cartel</a>.
--   
--   Cabal already has an AST that it uses. Cartel could, perhaps, have
--   re-used these structures. Cartel does not do this for three reasons.
--   First, the Cabal API is a bit untidy, partially because it has to do
--   things that Cartel doesn't have to worry about, but also because the
--   comments in the Cabal modules themselves indicate that the whole thing
--   could use a refactoring. Second, the Cabal developers make no
--   commitment to keep that API stable. Third, the Cartel API tries only
--   to replicate format of the plain-text Cabal file, which will be much
--   more stable than the Cabal API.
module Cartel.Ast

-- | Typeclass for things that can be blank. More specifically, <tt>blank
--   a</tt> results in an item that, when rendered in a Cabal file, is the
--   null string. <a>blank</a> can be useful to indicate that you have no
--   options, and you can also use it in combination with record syntax
--   when you want to specify just a few options.
class Blank a
blank :: Blank a => a

-- | What kind of VCS repository is this?
data RepoKind

-- | The latest development branch of the repository
Head :: RepoKind

-- | The sources for this release of this package.
This :: RepoKind
repoHead :: RepoKind
repoThis :: RepoKind

-- | Version control systems.
data Vcs
Darcs :: Vcs
Git :: Vcs
Svn :: Vcs

-- | The argument <a>String</a> is the named module
Cvs :: NonEmptyString -> Vcs
Mercurial :: Vcs
Bazaar :: Vcs
ArchVcs :: Vcs
Monotone :: Vcs
darcs :: Vcs
monotone :: Vcs
archVcs :: Vcs
bazaar :: Vcs
mercurial :: Vcs
svn :: Vcs
git :: Vcs
cvs :: NonEmptyString -> Vcs

-- | A single <tt>repository</tt> section.
data Repository
Repository :: Maybe Vcs -> Maybe RepoKind -> String -> NonEmptyString -> String -> String -> Repository

-- | What kind of <a>Vcs</a> this is. This is required.
repoVcs :: Repository -> Maybe Vcs

-- | The kind of repository (<a>repoHead</a> or <a>repoThis</a>). Required.
repoKind :: Repository -> Maybe RepoKind

-- | Repository tag. This is required for the <a>repoThis</a> repository
--   kind and is optional for the <a>repoHead</a> repository kind.
repoTag :: Repository -> String

-- | URL for the location of the repository--for example, for a
--   <tt>darcs</tt> repo this might be
--   <tt>http://code.haskell.org/foo/</tt>; for git, this might be
--   <tt>git://github.com/foo/bar.git</tt>.
repoLocation :: Repository -> NonEmptyString

-- | The repository branch.
repoBranch :: Repository -> String

-- | The repository subdirectory.
repoSubdir :: Repository -> String

-- | Creates a <a>Section</a> that is a <a>Repository</a> for a Github
--   head. For example, for Cartel, use <tt>githubHead "massysett"
--   "cartel"</tt>.
githubHead :: NonEmptyString -> NonEmptyString -> Section

-- | Creates a <a>Section</a> for a repository.
repository :: Repository -> Section

-- | Condition; for use in a <tt>CondTree</tt> and ultimately in a
--   <a>CondBlock</a>, which implements Cabal's <tt>if-then-else</tt>
--   feature.
data CondLeaf

-- | Tests if the current operating system is the given name,
--   case-insensitive
OS :: NonEmptyString -> CondLeaf

-- | Tests if the current architecture is the given name, case-insensitive
Arch :: NonEmptyString -> CondLeaf

-- | Tests for the configured Haskell implementation
Impl :: Compiler -> Constraint -> CondLeaf

-- | Evalutes to the current assignment of the flag of the given name. To
--   get a flag, use <a>makeFlag</a>.
CFlag :: FlagName -> CondLeaf

-- | Always True
CTrue :: CondLeaf

-- | Always False
CFalse :: CondLeaf

-- | For use in a <tt>CondTree</tt> or <a>ConstrTree</a>.
data Logical
Or :: Logical
And :: Logical

-- | Whether <tt>or equal to</tt> comparisions are also true.
newtype OrEqualTo
OrEqualTo :: Bool -> OrEqualTo

-- | Expresses comparisons between versions.
data VersionComp
LessThan :: OrEqualTo -> VersionComp
GreaterThan :: OrEqualTo -> VersionComp
EqualTo :: VersionComp

-- | Expresses a tree of constraints. This is how you represent more
--   complex dependency relationships.
data ConstrTree
Leaf :: VersionComp -> Version -> ConstrTree
Branch :: Logical -> ConstrTree -> ConstrTree -> ConstrTree

-- | Expresses any version constraint, including no version constraint.
data Constraint
AnyVersion :: Constraint
Constrained :: ConstrTree -> Constraint

-- | Conditions. Ultimately these are used in a <a>CondBlock</a>.
data Condition
CLeaf :: CondLeaf -> Condition
CBranch :: Logical -> Condition -> Condition -> Condition
CNegate :: Condition -> Condition

-- | Like <a>not</a>, which is what I would have named it but for the
--   conflict. Only <a>Condition</a>s have this sort of operation; Cabal
--   does not have a (documented, at least) way to express this for package
--   constraints.
invert :: Condition -> Condition

-- | Conditional blocks. These implement the <tt>if-then-else</tt> feature
--   of Cabal files. You must have at least one thing to do if the
--   condition is True; the if-false block is optional.
data CondBlock a
CondBlock :: Condition -> (a, [a]) -> [a] -> CondBlock a

-- | If this condition is true . . .
condIf :: CondBlock a -> Condition

-- | . . . then do this . . .
ifTrue :: CondBlock a -> (a, [a])

-- | . . . or if it's false, do this instead.
ifFalse :: CondBlock a -> [a]
class LogicTree a
(&&&) :: LogicTree a => a -> a -> a
(|||) :: LogicTree a => a -> a -> a

-- | Less than
lt :: Version -> Constraint

-- | Greater than
gt :: Version -> Constraint

-- | Equal to
eq :: Version -> Constraint

-- | Less than or equal to
ltEq :: Version -> Constraint

-- | Greater than or equal to
gtEq :: Version -> Constraint

-- | Matches any version at all (in a Cabal file, this is represented as an
--   empty string).
anyVersion :: Constraint

-- | Creates a package interval that is closed on the left, open on the
--   right. Useful for the common case under the PVP to specify that you
--   depend on a version that is at least a particular version, but less
--   than another version.
--   
--   <pre>
--   closedOpen "bytestring" [0,17] [0,19] ==&gt; bytestring &gt;= 0.17 &amp;&amp; &lt; 0.19
--   </pre>
closedOpen :: NonEmptyString -> Version -> Version -> Package

-- | Specifies a particular API version. Useful to lock your package
--   dependencies down to a particular API version.
--   
--   <pre>
--   apiVersion "base" [1] ==&gt; base &gt;= 1 &amp;&amp; &lt; 2
--   apiVersion "base" [1,2] ==&gt; base &gt;= 1.2 &amp;&amp; &lt; 1.3
--   apiVersion "base" [1,2,3] ==&gt; base &gt;= 1.2.3 &amp;&amp; &lt; 1.2.4
--   </pre>
apiVersion :: NonEmptyString -> Version -> Package

-- | Depends on the version given, up to the next breaking API change.
--   
--   <pre>
--   nextBreaking "base" [4] ==&gt; base &gt;= 4 &amp;&amp; &lt; 4.1
--   nextBreaking "base" [4,1] ==&gt; base &gt;= 4.1 &amp;&amp; &lt; 4.2
--   nextBreaking "base" [4,7,0,0] ==&gt; base &gt;= 4.7.0.0 &amp;&amp; &lt; 4.8
--   </pre>
nextBreaking :: NonEmptyString -> Version -> Package

-- | Depends on the version given, up to the next time the first digit
--   increments. Useful for <tt>base</tt>.
--   
--   <pre>
--   nextBreaking "base" [4] ==&gt; base &gt;= 4 &amp;&amp; &lt; 5
--   </pre>
nextMajor :: NonEmptyString -> Version -> Package

-- | Depends on exactly this version only.
--   
--   <pre>
--   exactly "base" [4,5,0,0] ==&gt; base ==4.5.0.0
--   </pre>
exactly :: NonEmptyString -> Version -> Package

-- | Allows any version of a package.
unconstrained :: NonEmptyString -> Package

-- | Builds <tt>if</tt> statements. For example:
--   
--   <pre>
--   condition (flag "buildExe") (buildable True, []) [buildable False]
--   </pre>
--   
--   A little more complicated:
--   
--   <pre>
--   condition (flag "buildExe" &amp;&amp;&amp; system "windows")
--     (buildable True, []) [buildable False]
--   </pre>
condBlock :: HasBuildInfo a => Condition -> (a, [a]) -> [a] -> a

-- | Operating system; tested against <tt>System.Info.os</tt> on the target
--   system.
system :: NonEmptyString -> Condition

-- | Argument is matched against <tt>System.Info.arch</tt> on the target
--   system.
arch :: NonEmptyString -> Condition

-- | Tests for the configured Haskell implementation.
impl :: Compiler -> Constraint -> Condition

-- | Evaluates to the current assignment of the flag of the given name.
--   Flag names are case insensitive. Testing for flags that have not been
--   introduced with a flag section is an error.
flag :: FlagName -> Condition

-- | Always true.
true :: Condition

-- | Always false.
false :: Condition

-- | A version number. The Cabal documentation says this "usually" consists
--   of a sequence of natural numbers separated by dots. Though this
--   suggests that a version number could contain something other than
--   natural numbers, in fact the types in the Cabal library do not allow
--   anything other than numbers and you will get a parse error if you try
--   to use anything else.
--   
--   Therefore Cartel's <a>Version</a> type only allows a list of
--   <a>Word</a>, as each number cannot be negative. In addition, this list
--   should never be empty. However, this is just a type synonym for a list
--   of <a>Word</a>, so the type system does not enforce the requirement
--   that this list be non-empty.
type Version = [Word]

-- | A single package, consisting of a package name and an optional set of
--   constraints. Used when specifying <a>buildDepends</a>,
--   <a>buildTools</a>, and <a>pkgConfigDepends</a>.
--   
--   Some functions exist to ease the creation of a <a>Package</a>. For a
--   package with no version constrains, simply do something like
--   <tt><a>unconstrained</a> "QuickCheck"</tt>. Common use cases are
--   covered in the functions in the "Package Helpers" section below. For
--   something more complicated, use the functions in the "Logicals"
--   sections above, along with the <a>&amp;&amp;&amp;</a> and <a>|||</a>
--   combinators, to create your own <a>Constraint</a> and then use it with
--   the <a>package</a> function.
data Package
Package :: NonEmptyString -> Constraint -> Package

-- | Builds a <a>Package</a>.
package :: NonEmptyString -> Constraint -> Package

-- | Default language. Currently not documented, see
--   
--   <a>https://github.com/haskell/cabal/issues/1894</a>
data DefaultLanguage
Haskell98 :: DefaultLanguage
Haskell2010 :: DefaultLanguage

-- | Sets Haskell 98 as the <tt>default-language</tt>.
--   
--   Currently not documented in Cabal, see
--   
--   <a>https://github.com/haskell/cabal/issues/1894</a>
haskell98 :: HasBuildInfo a => a

-- | Sets Haskell 2010 as the <tt>default-language</tt>.
--   
--   Currently not documented in Cabal, see
--   
--   <a>https://github.com/haskell/cabal/issues/1894</a>
haskell2010 :: HasBuildInfo a => a

-- | A single field of build information. This can appear in a
--   <tt>Library</tt>, <a>Executable</a>, <a>TestSuite</a>, or
--   <a>Benchmark</a>.
data BuildInfoField

-- | A list of packages needed to build this component
BuildDepends :: [Package] -> BuildInfoField

-- | Modules used but not exposed. For libraries, these are hidden modules;
--   for executable, these are auxiliary modules to be linked with the file
--   in the <tt>main-is</tt> field.
--   
--   <a>modules</a> can help greatly with maintenance of this field.
OtherModules :: [NonEmptyString] -> BuildInfoField

-- | Root directories for the module hierarchy
HsSourceDirs :: [NonEmptyString] -> BuildInfoField
Extensions :: [NonEmptyString] -> BuildInfoField
DefaultExtensions :: [NonEmptyString] -> BuildInfoField
OtherExtensions :: [NonEmptyString] -> BuildInfoField

-- | Programs needed to build this package, such as c2hs.
BuildTools :: [Package] -> BuildInfoField

-- | Is this component buildable?
Buildable :: Bool -> BuildInfoField
GHCOptions :: [NonEmptyString] -> BuildInfoField
GHCProfOptions :: [NonEmptyString] -> BuildInfoField
GHCSharedOptions :: [NonEmptyString] -> BuildInfoField
HugsOptions :: [NonEmptyString] -> BuildInfoField
Nhc98Options :: [NonEmptyString] -> BuildInfoField

-- | Header files to be included in any compilations via C. Applies to both
--   header files that are already installed on the system and to those
--   coming with the package to be installed.
Includes :: [NonEmptyString] -> BuildInfoField

-- | Header files to be installed into <tt>$libdir/includes</tt> when the
--   package is installed. These files should be found in relative to the
--   top of the source tree or relative to one of the directories listed in
--   <tt>include-dirs</tt>.
InstallIncludes :: [NonEmptyString] -> BuildInfoField

-- | List of diretories to search for header files when dealing with C
--   compilations.
IncludeDirs :: [NonEmptyString] -> BuildInfoField

-- | C sources to be compiled and lined with the Haskell files.
CSources :: [NonEmptyString] -> BuildInfoField

-- | Extra libraries to link with.
ExtraLibraries :: [NonEmptyString] -> BuildInfoField

-- | Directories to search for libraries.
ExtraLibDirs :: [NonEmptyString] -> BuildInfoField

-- | C Compiler options.
CCOptions :: [NonEmptyString] -> BuildInfoField

-- | C Preprocessor options. Undocumented, see
--   <a>https://github.com/haskell/cabal/issues/646</a>
CPPOptions :: [NonEmptyString] -> BuildInfoField

-- | Linker options.
LDOptions :: [NonEmptyString] -> BuildInfoField

-- | List of pkg-config packages needed to build this component.
PkgConfigDepends :: [Package] -> BuildInfoField

-- | OS X frameworks.
Frameworks :: [NonEmptyString] -> BuildInfoField
DefaultLanguage :: DefaultLanguage -> BuildInfoField

-- | A field in the <tt>Library</tt> section of the Cabal file. A
--   <tt>Library</tt> section can have multiple fields.
data LibraryField

-- | Exposed modules. <a>modules</a> can help you generate this, without
--   you having to manually list each module and keep the list up to date.
ExposedModules :: [NonEmptyString] -> LibraryField

-- | Is the library exposed? GHC can hide libraries.
Exposed :: Bool -> LibraryField

-- | The <tt>Library</tt> section can contain conditional blocks.
LibConditional :: (CondBlock LibraryField) -> LibraryField

-- | The <tt>Library</tt> section can contain build information.
LibInfo :: BuildInfoField -> LibraryField

-- | Whether a library is exposed. GHC can hide libraries.
exposed :: Bool -> LibraryField

-- | A library's exposed modules. <a>modules</a> can help you generate
--   this, without you having to manually list each module and keep the
--   list up to date.
exposedModules :: [NonEmptyString] -> LibraryField

-- | A single field in an <a>Executable</a> section. An <a>Executable</a>
--   section may have multiple fields.
data ExecutableField

-- | An <a>Executable</a> section can contain conditional blocks.
ExeConditional :: (CondBlock ExecutableField) -> ExecutableField

-- | An <a>Executable</a> section can contain one or more build information
--   fields.
ExeInfo :: BuildInfoField -> ExecutableField

-- | The name of the <tt>.hs</tt> or <tt>.lhs</tt> file containing the
--   <tt>Main</tt> module. Note that it is the <tt>.hs</tt> filename that
--   must be listed, even if that file is generated using a preprocessor.
--   The source file must be relative to one of the directories listed in
--   <a>hsSourceDirs</a>.
ExeMainIs :: NonEmptyString -> ExecutableField

-- | An entire <tt>Executable</tt> section.
data Executable
Executable :: NonEmptyString -> [ExecutableField] -> Executable

-- | The name of the executable that Cabal will build.
exeName :: Executable -> NonEmptyString

-- | An executable can contain zero or more <a>ExecutableField</a>s.
exeFields :: Executable -> [ExecutableField]

-- | Builds a <a>Section</a> for executable files.
executable :: NonEmptyString -> [ExecutableField] -> Section

-- | What kind of test suite is this?
data TestSuiteType

-- | An <tt>exitcode-stdio-1.0</tt> test. The <tt>String</tt> is the name
--   of the file containing the executable code. In this case, the
--   <tt>test-main-is</tt> field is required.
ExitcodeStdio :: TestSuiteType

-- | The <tt>detailed-0.9</tt> test. In this case, the <tt>test-module</tt>
--   field is required.
Detailed :: TestSuiteType
detailed :: TestSuiteField

-- | A single field value in a <a>TestSuite</a> section. A single test
--   suite section may contain mulitple fields.
data TestSuiteField

-- | The <a>TestSuite</a> may contain zero or more conditional blocks.
TestConditional :: (CondBlock TestSuiteField) -> TestSuiteField

-- | The <a>TestSuite</a> may contain zero or more build information
--   fields.
TestInfo :: BuildInfoField -> TestSuiteField

-- | The name of the <tt>.hs</tt> or <tt>.lhs</tt> file containing the
--   <tt>Main</tt> module. Note that it is the <tt>.hs</tt> filename that
--   must be listed, even if that file is generated using a preprocessor.
--   The source file must be relative to one of the directories listed in
--   <a>hsSourceDirs</a>.
--   
--   This is required when using <a>ExitcodeStdio</a> and disallowed when
--   using <a>Detailed</a>.
TestMainIs :: NonEmptyString -> TestSuiteField
TestSuiteType :: TestSuiteType -> TestSuiteField

-- | The module exporting the <tt>tests</tt> symbol. This is required when
--   using <a>Detailed</a> and disallowed when using <a>ExitcodeStdio</a>.
TestModule :: NonEmptyString -> TestSuiteField

-- | The module exporting the <tt>tests</tt> symbol. This is required when
--   using <a>Detailed</a> and disallowed when using <a>ExitcodeStdio</a>.
testModule :: NonEmptyString -> TestSuiteField

-- | An entire <tt>test-suite</tt> section.
data TestSuite
TestSuite :: NonEmptyString -> [TestSuiteField] -> TestSuite

-- | The executable name for the resulting test suite
testSuiteName :: TestSuite -> NonEmptyString

-- | Zero or more <a>TestSuiteField</a>s.
testSuiteFields :: TestSuite -> [TestSuiteField]

-- | Builds a <a>Section</a> for test suites.
testSuite :: NonEmptyString -> [TestSuiteField] -> Section
data BenchmarkType

-- | <tt>exitcode-stdio-1.0</tt>, currently the only supported benchmark
--   interface.
BenchExitCode :: BenchmarkType

-- | A single field in a <tt>Benchmark</tt> section.
data BenchmarkField
BenchmarkConditional :: (CondBlock BenchmarkField) -> BenchmarkField
BenchmarkInfo :: BuildInfoField -> BenchmarkField
BenchmarkType :: BenchmarkType -> BenchmarkField

-- | The name of the <tt>.hs</tt> or <tt>.lhs</tt> file containing the
--   <tt>Main</tt> module. Note that it is the <tt>.hs</tt> filename that
--   must be listed, even if that file is generated using a preprocessor.
--   The source file must be relative to one of the directories listed in
--   <a>hsSourceDirs</a>.
BenchmarkMainIs :: NonEmptyString -> BenchmarkField

-- | An entire <tt>Benchmark</tt> section.
data Benchmark
Benchmark :: NonEmptyString -> [BenchmarkField] -> Benchmark

-- | The name of the executable file that will be the benchmark
benchmarkName :: Benchmark -> NonEmptyString

-- | Zero or more benchmark fields.
benchmarkFields :: Benchmark -> [BenchmarkField]

-- | Builds a <a>Section</a> for benchmarks.
benchmark :: NonEmptyString -> [BenchmarkField] -> Section

-- | Things that can be an item in a build information field in a Cabal
--   file.
class HasBuildInfo a
conditional :: HasBuildInfo a => CondBlock a -> a
buildInfo :: HasBuildInfo a => BuildInfoField -> a

-- | A list of packages needed to build this component
buildDepends :: HasBuildInfo a => [Package] -> a

-- | Modules used but not exposed. For libraries, these are hidden modules;
--   for executable, these are auxiliary modules to be linked with the file
--   in the <tt>main-is</tt> field.
--   
--   <a>modules</a> can help greatly with maintenance of this field.
otherModules :: HasBuildInfo a => [NonEmptyString] -> a

-- | Root directories for the module hierarchy
hsSourceDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | Haskell extensions used by every module. With version 1.22 of the
--   Cabal library, using this field might get you this warning:
--   
--   <pre>
--   Warning: For packages using 'cabal-version: &gt;= 1.10' the
--   'extensions' field is deprecated. The new 'default-extensions'
--   field lists extensions that are used in all modules in the
--   component, while the 'other-extensions' field lists extensions
--   that are used in some modules, e.g. via the {-# LANGUAGE #-}
--   pragma.
--   </pre>
extensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Default extensions. See <a>extensions</a> for details. Currently
--   undocumented, see <a>https://github.com/haskell/cabal/issues/1517</a>
defaultExtensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Other extensions. See <a>extensions</a> for details. Currently
--   undocumented, see <a>https://github.com/haskell/cabal/issues/1517</a>
otherExtensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Programs needed to build this package, such as c2hs.
buildTools :: HasBuildInfo a => [Package] -> a

-- | Is this component buildable?
buildable :: HasBuildInfo a => Bool -> a
ghcOptions :: HasBuildInfo a => [NonEmptyString] -> a
ghcProfOptions :: HasBuildInfo a => [NonEmptyString] -> a
ghcSharedOptions :: HasBuildInfo a => [NonEmptyString] -> a
hugsOptions :: HasBuildInfo a => [NonEmptyString] -> a
nhc98Options :: HasBuildInfo a => [NonEmptyString] -> a

-- | Header files to be included in any compilations via C. Applies to both
--   header files that are already installed on the system and to those
--   coming with the package to be installed.
includes :: HasBuildInfo a => [NonEmptyString] -> a

-- | Header files to be installed into <tt>$libdir/includes</tt> when the
--   package is installed. These files should be found in relative to the
--   top of the source tree or relative to one of the directories listed in
--   <tt>include-dirs</tt>.
installIncludes :: HasBuildInfo a => [NonEmptyString] -> a

-- | List of diretories to search for header files when dealing with C
--   compilations.
includeDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | C sources to be compiled and lined with the Haskell files.
cSources :: HasBuildInfo a => [NonEmptyString] -> a

-- | Extra libraries to link with.
extraLibraries :: HasBuildInfo a => [NonEmptyString] -> a

-- | Directories to search for libraries.
extraLibDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | C Compiler options.
ccOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | C Preprocessor options. Undocumented, see
--   <a>https://github.com/haskell/cabal/issues/646</a>
cppOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Linker options.
ldOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | List of pkg-config packages needed to build this component.
pkgConfigDepends :: HasBuildInfo a => [Package] -> a

-- | OS X frameworks.
frameworks :: HasBuildInfo a => [NonEmptyString] -> a

-- | Sections that build executables. These are the <a>Executable</a>,
--   <a>Benchmark</a>, and <a>TestSuite</a> sections.
class BuildsExe a
mainIs :: BuildsExe a => NonEmptyString -> a

-- | Sections that build executables that can be
--   <tt>exitcode-stdio-1.0</tt>. These are the <a>Benchmark</a> and
--   <a>TestSuite</a> sections.
class BuildsExitcode a
exitcodeStdio :: BuildsExitcode a => a

-- | Builds two fields. The first indicates that this is an
--   <tt>exitcode-stdio-1.0</tt> executable; the second is the appropriate
--   <tt>main-is</tt> field.
exitcodeFields :: (BuildsExitcode a, BuildsExe a) => NonEmptyString -> [a]

-- | Gets all Haskell modules in a given directory tree. Allows you to
--   specify what extensions you are interested in. For this to work best,
--   you will want to keep all your library modules in their own directory,
--   such as <tt>lib/</tt>. You can also separate executables and test
--   suites this way. <a>hsSourceDirs</a> will then tell Cabal to use these
--   directories.
modulesWithExtensions :: MonadIO m => [NonEmptyString] -> FilePath -> Betsy m [NonEmptyString]

-- | Same as
--   
--   <pre>
--   <a>modulesWithExtensions</a> <a>fileExtensions</a>
--   </pre>
modules :: MonadIO m => FilePath -> Betsy m [NonEmptyString]

-- | Common extensions of Haskell files and files that are preprocessed
--   into Haskell files. Includes:
--   
--   <ul>
--   <li>hs (Haskell)</li>
--   <li>lhs (literate Haskell)</li>
--   <li>gc (greencard)</li>
--   <li>chs (c2hs)</li>
--   <li>hsc (hsc2hs)</li>
--   <li>y and ly (happy)</li>
--   <li>x (alex)</li>
--   <li>cpphs</li>
--   </ul>
fileExtensions :: [String]
interestingFile :: [String] -> FilePath -> Bool
interestingDir :: FilePath -> Bool

-- | Gets all Haskell modules in a given directory tree. Only files with
--   one of the extensions listed in <a>fileExtensions</a> are returned.
--   Files and directories that do not begin with an uppercase letter are
--   ignored. (This also ignores files that start with a dot.) Directories
--   with a dot anywhere in the name are ignored.
modulesIO :: FilePath -> IO [String]

-- | Gets all Haskell modules in a given directory tree. Allows you to
--   specify what extensions you are interested in.
modulesWithExtensionsIO :: [String] -> FilePath -> IO [String]
sorter :: [String] -> [String] -> Ordering
modulesInDir :: [String] -> FilePath -> [FilePath] -> IO [[String]]
processFile :: [String] -> FilePath -> [FilePath] -> FilePath -> IO [[String]]

-- | A single section in a Cabal file; this may be a source repository,
--   executable, test suite, or benchmark. You build a <a>Section</a> with
--   the <a>repository</a>, <a>executable</a>, <a>testSuite</a>, and
--   <a>benchmark</a> functions.
data Section
SecRepo :: Repository -> Section
SecExe :: Executable -> Section
SecTest :: TestSuite -> Section
SecBench :: Benchmark -> Section
data BuildType
Simple :: BuildType
Configure :: BuildType
Make :: BuildType
Custom :: BuildType
simple :: BuildType
custom :: BuildType
make :: BuildType
configure :: BuildType
data License
GPL :: License
AGPL :: License
LGPL :: License
BSD2 :: License
BSD3 :: License
BSD4 :: License
MIT :: License
MPL :: License
Apache :: License
PublicDomain :: License
AllRightsReserved :: License
OtherLicense :: License
gpl :: License
otherLicense :: License
allRightsReserved :: License
publicDomain :: License
apache :: License
mpl :: License
mit :: License
bsd4 :: License
bsd3 :: License
bsd2 :: License
lgpl :: License
agpl :: License
data Compiler
GHC :: Compiler
NHC :: Compiler
YHC :: Compiler
Hugs :: Compiler
Helium :: Compiler
JHC :: Compiler
LHC :: Compiler
ghc :: Compiler
lhc :: Compiler
jhc :: Compiler
helium :: Compiler
hugs :: Compiler
yhc :: Compiler
nhc :: Compiler

-- | Global package properties.
data Properties
Properties :: String -> Version -> Maybe (Word, Word) -> Maybe BuildType -> Maybe License -> String -> [NonEmptyString] -> String -> String -> String -> String -> String -> String -> String -> String -> [String] -> String -> [(Compiler, Constraint)] -> [NonEmptyString] -> String -> [NonEmptyString] -> [NonEmptyString] -> [NonEmptyString] -> Properties
name :: Properties -> String
version :: Properties -> Version
cabalVersion :: Properties -> Maybe (Word, Word)
buildType :: Properties -> Maybe BuildType
license :: Properties -> Maybe License
licenseFile :: Properties -> String
licenseFiles :: Properties -> [NonEmptyString]
copyright :: Properties -> String
author :: Properties -> String
maintainer :: Properties -> String
stability :: Properties -> String
homepage :: Properties -> String
bugReports :: Properties -> String
packageUrl :: Properties -> String
synopsis :: Properties -> String
description :: Properties -> [String]

-- | According to the "Developing Cabal Packages" document, this should
--   simply be an email address.
category :: Properties -> String
testedWith :: Properties -> [(Compiler, Constraint)]
dataFiles :: Properties -> [NonEmptyString]
dataDir :: Properties -> String
extraSourceFiles :: Properties -> [NonEmptyString]
extraDocFiles :: Properties -> [NonEmptyString]
extraTmpFiles :: Properties -> [NonEmptyString]

-- | Represents an entire Cabal file.
data Cabal
Cabal :: Properties -> [LibraryField] -> [Section] -> [Flag] -> Cabal
properties :: Cabal -> Properties
library :: Cabal -> [LibraryField]
sections :: Cabal -> [Section]
flags :: Cabal -> [Flag]
instance Eq RepoKind
instance Ord RepoKind
instance Show RepoKind
instance Eq Vcs
instance Ord Vcs
instance Show Vcs
instance Eq Repository
instance Ord Repository
instance Show Repository
instance Eq Logical
instance Ord Logical
instance Show Logical
instance Eq OrEqualTo
instance Ord OrEqualTo
instance Show OrEqualTo
instance Eq VersionComp
instance Ord VersionComp
instance Show VersionComp
instance Eq ConstrTree
instance Ord ConstrTree
instance Show ConstrTree
instance Eq Constraint
instance Ord Constraint
instance Show Constraint
instance Eq Package
instance Ord Package
instance Show Package
instance Eq DefaultLanguage
instance Ord DefaultLanguage
instance Show DefaultLanguage
instance Eq BuildInfoField
instance Ord BuildInfoField
instance Show BuildInfoField
instance Eq TestSuiteType
instance Ord TestSuiteType
instance Show TestSuiteType
instance Eq BenchmarkType
instance Ord BenchmarkType
instance Show BenchmarkType
instance Eq BuildType
instance Ord BuildType
instance Show BuildType
instance Eq License
instance Ord License
instance Show License
instance Eq Compiler
instance Ord Compiler
instance Show Compiler
instance Eq CondLeaf
instance Ord CondLeaf
instance Show CondLeaf
instance Eq Condition
instance Ord Condition
instance Show Condition
instance Eq a => Eq (CondBlock a)
instance Ord a => Ord (CondBlock a)
instance Show a => Show (CondBlock a)
instance Eq BenchmarkField
instance Ord BenchmarkField
instance Show BenchmarkField
instance Eq Benchmark
instance Ord Benchmark
instance Show Benchmark
instance Eq TestSuiteField
instance Ord TestSuiteField
instance Show TestSuiteField
instance Eq TestSuite
instance Ord TestSuite
instance Show TestSuite
instance Eq ExecutableField
instance Ord ExecutableField
instance Show ExecutableField
instance Eq Executable
instance Ord Executable
instance Show Executable
instance Eq Section
instance Ord Section
instance Show Section
instance Eq LibraryField
instance Ord LibraryField
instance Show LibraryField
instance Eq Properties
instance Ord Properties
instance Show Properties
instance Eq Cabal
instance Ord Cabal
instance Show Cabal
instance Blank Cabal
instance Blank Properties
instance BuildsExitcode BenchmarkField
instance BuildsExitcode TestSuiteField
instance BuildsExe BenchmarkField
instance BuildsExe TestSuiteField
instance BuildsExe ExecutableField
instance HasBuildInfo BenchmarkField
instance HasBuildInfo TestSuiteField
instance HasBuildInfo ExecutableField
instance HasBuildInfo LibraryField
instance LogicTree Condition
instance LogicTree ConstrTree
instance LogicTree Constraint
instance Functor CondBlock
instance Blank Repository


-- | Reducing a Cartel AST to flat Cabal text; essentially a
--   pretty-printer.
module Cartel.Render

-- | Separate two strings with a space, but only if both strings are not
--   empty.
(<+>) :: String -> String -> String

-- | Concatenate several vertically. Unlike <a>unlines</a>, does not add a
--   newline when an item is <a>null</a> or when the accumulator is
--   <a>null</a>.
vsep :: [String] -> String
indentAmt :: Int
labeled :: String -> String -> String
labeledIndented :: String -> String -> Reader Level String

-- | Indentation level
type Level = Int
addLevel :: Reader Level a -> Reader Level a
indent :: String -> Reader Level String

-- | Adds comma separators to a list.
commaSeparated :: [String] -> [String]

-- | Indents list, adds newlines, and concats.
indentConcat :: [String] -> Reader Level String
labeledList :: String -> [String] -> Reader Level String

-- | Renders a string using <a>show</a>, but only if it is both non-empty
--   and contains characters that might be problematic. For now, "might be
--   problematic" simply means any character that is either above Unicode
--   code point 7F or is not a letter, digit, hyphen, period, or
--   underscore.
--   
--   If the string is empty, or if it contains only non-problematic
--   characters, returns the string as-is.
escaper :: String -> String

-- | Render an item. The rendered text must contain a newline at the end of
--   each line and must end with a newline. The leftmost line of the
--   rendered text shall be indented by the given number of indentation
--   levels (the number of spaces in each level is set by
--   <a>indentAmt</a>).
--   
--   If there are no lines to indent, return an empty string.
class RenderableIndented a
renderIndented :: RenderableIndented a => a -> Reader Level String
renderNoIndent :: RenderableIndented a => a -> String

-- | Render an item. The rendered text shall contain no newlines.
class Renderable a
render :: Renderable a => a -> String
data CabalVersion
CabalVersion :: Word -> Word -> CabalVersion
newtype Flags
Flags :: [Flag] -> Flags

-- | Contains many lists of items. Items that might contain spaces or other
--   troublesome characters are rendered quoted. In particular, this
--   includes filenames. Items that are highly unlikely to contain
--   troublesome characters (such as compiler options) are not quoted.
renLibrary :: [LibraryField] -> Reader Level String
instance Eq CabalVersion
instance Ord CabalVersion
instance Show CabalVersion
instance Eq Flags
instance Ord Flags
instance Show Flags
instance RenderableIndented Cabal
instance RenderableIndented Section
instance RenderableIndented Properties
instance RenderableIndented Benchmark
instance RenderableIndented BenchmarkField
instance Renderable BenchmarkType
instance RenderableIndented TestSuite
instance RenderableIndented TestSuiteField
instance Renderable TestSuiteType
instance RenderableIndented Executable
instance RenderableIndented ExecutableField
instance RenderableIndented LibraryField
instance RenderableIndented a => RenderableIndented (CondBlock a)
instance Renderable Condition
instance RenderableIndented BuildInfoField
instance Renderable DefaultLanguage
instance Renderable Bool
instance Renderable Package
instance RenderableIndented Repository
instance Renderable Vcs
instance Renderable RepoKind
instance Renderable CondLeaf
instance RenderableIndented Flags
instance RenderableIndented Flag
instance RenderableIndented FlagOpts
instance Renderable FlagName
instance Renderable (Compiler, Constraint)
instance Renderable CabalVersion
instance Renderable ConstrTree
instance Renderable Logical
instance Renderable Constraint
instance Renderable Version
instance Renderable VersionComp
instance Renderable Compiler
instance Renderable License
instance Renderable BuildType
instance RenderableIndented Error
instance Renderable a => Renderable (Maybe a)


-- | Cartel - a library to specify Cabal files in Haskell
--   
--   The Cabal file format works very well for small projects. However, in
--   big projects with a library, many executables, and test suites, some
--   irritations emerge. You need to specify dependencies in multiple
--   places, leading to redundancy. You also have to manually add in new
--   modules, make sure you list all modules (a real pain with executables,
--   as problems may arise only after you build a distribution tarball),
--   and update your module lists when you refactor.
--   
--   Specifying your Cabal files in Haskell rather than in a plain-text
--   file format helps deal with a lot of these problems. You have the full
--   power of Haskell to make definitions in one place and then reuse them.
--   You can also dynamically read a tree of modules and use the result,
--   thus avoiding the need to manually update your module lists.
--   
--   A disadvantage to Cartel is that is more verbose than a vanilla Cabal
--   file. In addition, you also have to remember to generate the new Cabal
--   file whenever you change the script that generates your Cabal file.
--   
--   To the extent possible, Cartel uses the Haskell type system to prevent
--   you from making mistakes in your Cabal file. For example, the
--   <a>Betsy</a> type prevents you from using <a>flag</a>s that you have
--   not declared, and you can't put an <a>exposedModules</a> field in
--   anything but a library. However, Cartel does not prevent against all
--   errors. For example, Cartel does nothing to prevent you from applying
--   a function that calls for a <a>NonEmptyString</a> to a string that is,
--   in fact, empty. Another example is that Cabal requires executables to
--   have a <tt>main-is</tt> field, but Cartel does not force you to
--   include one. Ultimately your Cabal file might still have errors that
--   you have to fix by changing the program that generates the file.
--   
--   Everything you usually need is in this module. Other Cartel modules
--   contain implementation details. <i>See first</i> the
--   <a>NonEmptyString</a> type synonym, which has important details on how
--   to regard <a>String</a>s and <a>NonEmptyString</a>s as you read the
--   documentation. Also, examine <a>Cartel.GenCartelCabal</a>, which
--   generates Cartel's own Cabal file using Cartel.
--   
--   Hopefully this module's documentation is organized so that
--   top-to-bottom reading will make sense.
module Cartel

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word :: *

-- | A non-empty string. This string should never be empty. It is used
--   where, for example, a field in a Cabal file is required to have a
--   value and that value cannot be empty. In contrast, Cartel uses an
--   ordinary <a>String</a> for values that can be empty.
--   
--   This is only a type synonym, so nothing in the type system enforces
--   that these strings must be non-empty. Typically though, Cabal will
--   give you grief about the file that Cartel generates if you used an
--   empty value for a <a>NonEmptyString</a>.
type NonEmptyString = String

-- | Typeclass for things that can be blank. More specifically, <tt>blank
--   a</tt> results in an item that, when rendered in a Cabal file, is the
--   null string. <a>blank</a> can be useful to indicate that you have no
--   options, and you can also use it in combination with record syntax
--   when you want to specify just a few options.
class Blank a
blank :: Blank a => a

-- | A version number. The Cabal documentation says this "usually" consists
--   of a sequence of natural numbers separated by dots. Though this
--   suggests that a version number could contain something other than
--   natural numbers, in fact the types in the Cabal library do not allow
--   anything other than numbers and you will get a parse error if you try
--   to use anything else.
--   
--   Therefore Cartel's <a>Version</a> type only allows a list of
--   <a>Word</a>, as each number cannot be negative. In addition, this list
--   should never be empty. However, this is just a type synonym for a list
--   of <a>Word</a>, so the type system does not enforce the requirement
--   that this list be non-empty.
type Version = [Word]

-- | A single section in a Cabal file; this may be a source repository,
--   executable, test suite, or benchmark. You build a <a>Section</a> with
--   the <a>repository</a>, <a>executable</a>, <a>testSuite</a>, and
--   <a>benchmark</a> functions.
data Section

-- | Version control systems.
data Vcs
darcs :: Vcs
git :: Vcs
svn :: Vcs
mercurial :: Vcs
bazaar :: Vcs
archVcs :: Vcs
monotone :: Vcs
cvs :: NonEmptyString -> Vcs

-- | What kind of VCS repository is this?
data RepoKind
repoHead :: RepoKind
repoThis :: RepoKind

-- | A single <tt>repository</tt> section.
data Repository
Repository :: Maybe Vcs -> Maybe RepoKind -> String -> NonEmptyString -> String -> String -> Repository

-- | What kind of <a>Vcs</a> this is. This is required.
repoVcs :: Repository -> Maybe Vcs

-- | The kind of repository (<a>repoHead</a> or <a>repoThis</a>). Required.
repoKind :: Repository -> Maybe RepoKind

-- | Repository tag. This is required for the <a>repoThis</a> repository
--   kind and is optional for the <a>repoHead</a> repository kind.
repoTag :: Repository -> String

-- | URL for the location of the repository--for example, for a
--   <tt>darcs</tt> repo this might be
--   <tt>http://code.haskell.org/foo/</tt>; for git, this might be
--   <tt>git://github.com/foo/bar.git</tt>.
repoLocation :: Repository -> NonEmptyString

-- | The repository branch.
repoBranch :: Repository -> String

-- | The repository subdirectory.
repoSubdir :: Repository -> String

-- | Creates a <a>Section</a> that is a <a>Repository</a> for a Github
--   head. For example, for Cartel, use <tt>githubHead "massysett"
--   "cartel"</tt>.
githubHead :: NonEmptyString -> NonEmptyString -> Section

-- | Creates a <a>Section</a> for a repository.
repository :: Repository -> Section
class LogicTree a
(&&&) :: LogicTree a => a -> a -> a
(|||) :: LogicTree a => a -> a -> a

-- | Like <a>not</a>, which is what I would have named it but for the
--   conflict. Only <a>Condition</a>s have this sort of operation; Cabal
--   does not have a (documented, at least) way to express this for package
--   constraints.
invert :: Condition -> Condition

-- | Expresses any version constraint, including no version constraint.
data Constraint

-- | Less than
lt :: Version -> Constraint

-- | Greater than
gt :: Version -> Constraint

-- | Equal to
eq :: Version -> Constraint

-- | Less than or equal to
ltEq :: Version -> Constraint

-- | Greater than or equal to
gtEq :: Version -> Constraint

-- | Matches any version at all (in a Cabal file, this is represented as an
--   empty string).
anyVersion :: Constraint
data Compiler
ghc :: Compiler
nhc :: Compiler
yhc :: Compiler
hugs :: Compiler
helium :: Compiler
jhc :: Compiler
lhc :: Compiler

-- | Conditions. Ultimately these are used in a <a>CondBlock</a>.
data Condition

-- | Operating system; tested against <tt>System.Info.os</tt> on the target
--   system.
system :: NonEmptyString -> Condition

-- | Argument is matched against <tt>System.Info.arch</tt> on the target
--   system.
arch :: NonEmptyString -> Condition

-- | Tests for the configured Haskell implementation.
impl :: Compiler -> Constraint -> Condition

-- | Evaluates to the current assignment of the flag of the given name.
--   Flag names are case insensitive. Testing for flags that have not been
--   introduced with a flag section is an error.
flag :: FlagName -> Condition

-- | Always true.
true :: Condition

-- | Always false.
false :: Condition

-- | Builds <tt>if</tt> statements. For example:
--   
--   <pre>
--   condition (flag "buildExe") (buildable True, []) [buildable False]
--   </pre>
--   
--   A little more complicated:
--   
--   <pre>
--   condition (flag "buildExe" &amp;&amp;&amp; system "windows")
--     (buildable True, []) [buildable False]
--   </pre>
condBlock :: HasBuildInfo a => Condition -> (a, [a]) -> [a] -> a

-- | A single package, consisting of a package name and an optional set of
--   constraints. Used when specifying <a>buildDepends</a>,
--   <a>buildTools</a>, and <a>pkgConfigDepends</a>.
--   
--   Some functions exist to ease the creation of a <a>Package</a>. For a
--   package with no version constrains, simply do something like
--   <tt><a>unconstrained</a> "QuickCheck"</tt>. Common use cases are
--   covered in the functions in the "Package Helpers" section below. For
--   something more complicated, use the functions in the "Logicals"
--   sections above, along with the <a>&amp;&amp;&amp;</a> and <a>|||</a>
--   combinators, to create your own <a>Constraint</a> and then use it with
--   the <a>package</a> function.
data Package

-- | Builds a <a>Package</a>.
package :: NonEmptyString -> Constraint -> Package

-- | Creates a package interval that is closed on the left, open on the
--   right. Useful for the common case under the PVP to specify that you
--   depend on a version that is at least a particular version, but less
--   than another version.
--   
--   <pre>
--   closedOpen "bytestring" [0,17] [0,19] ==&gt; bytestring &gt;= 0.17 &amp;&amp; &lt; 0.19
--   </pre>
closedOpen :: NonEmptyString -> Version -> Version -> Package

-- | Specifies a particular API version. Useful to lock your package
--   dependencies down to a particular API version.
--   
--   <pre>
--   apiVersion "base" [1] ==&gt; base &gt;= 1 &amp;&amp; &lt; 2
--   apiVersion "base" [1,2] ==&gt; base &gt;= 1.2 &amp;&amp; &lt; 1.3
--   apiVersion "base" [1,2,3] ==&gt; base &gt;= 1.2.3 &amp;&amp; &lt; 1.2.4
--   </pre>
apiVersion :: NonEmptyString -> Version -> Package

-- | Depends on the version given, up to the next breaking API change.
--   
--   <pre>
--   nextBreaking "base" [4] ==&gt; base &gt;= 4 &amp;&amp; &lt; 4.1
--   nextBreaking "base" [4,1] ==&gt; base &gt;= 4.1 &amp;&amp; &lt; 4.2
--   nextBreaking "base" [4,7,0,0] ==&gt; base &gt;= 4.7.0.0 &amp;&amp; &lt; 4.8
--   </pre>
nextBreaking :: NonEmptyString -> Version -> Package

-- | Depends on the version given, up to the next time the first digit
--   increments. Useful for <tt>base</tt>.
--   
--   <pre>
--   nextBreaking "base" [4] ==&gt; base &gt;= 4 &amp;&amp; &lt; 5
--   </pre>
nextMajor :: NonEmptyString -> Version -> Package

-- | Depends on exactly this version only.
--   
--   <pre>
--   exactly "base" [4,5,0,0] ==&gt; base ==4.5.0.0
--   </pre>
exactly :: NonEmptyString -> Version -> Package

-- | Allows any version of a package.
unconstrained :: NonEmptyString -> Package

-- | A single field of build information. This can appear in a
--   <tt>Library</tt>, <a>Executable</a>, <a>TestSuite</a>, or
--   <a>Benchmark</a>.
data BuildInfoField

-- | Things that can be an item in a build information field in a Cabal
--   file.
class HasBuildInfo a

-- | Sets Haskell 98 as the <tt>default-language</tt>.
--   
--   Currently not documented in Cabal, see
--   
--   <a>https://github.com/haskell/cabal/issues/1894</a>
haskell98 :: HasBuildInfo a => a

-- | Sets Haskell 2010 as the <tt>default-language</tt>.
--   
--   Currently not documented in Cabal, see
--   
--   <a>https://github.com/haskell/cabal/issues/1894</a>
haskell2010 :: HasBuildInfo a => a

-- | A list of packages needed to build this component
buildDepends :: HasBuildInfo a => [Package] -> a

-- | Modules used but not exposed. For libraries, these are hidden modules;
--   for executable, these are auxiliary modules to be linked with the file
--   in the <tt>main-is</tt> field.
--   
--   <a>modules</a> can help greatly with maintenance of this field.
otherModules :: HasBuildInfo a => [NonEmptyString] -> a

-- | Root directories for the module hierarchy
hsSourceDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | Haskell extensions used by every module. With version 1.22 of the
--   Cabal library, using this field might get you this warning:
--   
--   <pre>
--   Warning: For packages using 'cabal-version: &gt;= 1.10' the
--   'extensions' field is deprecated. The new 'default-extensions'
--   field lists extensions that are used in all modules in the
--   component, while the 'other-extensions' field lists extensions
--   that are used in some modules, e.g. via the {-# LANGUAGE #-}
--   pragma.
--   </pre>
extensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Default extensions. See <a>extensions</a> for details. Currently
--   undocumented, see <a>https://github.com/haskell/cabal/issues/1517</a>
defaultExtensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Other extensions. See <a>extensions</a> for details. Currently
--   undocumented, see <a>https://github.com/haskell/cabal/issues/1517</a>
otherExtensions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Programs needed to build this package, such as c2hs.
buildTools :: HasBuildInfo a => [Package] -> a

-- | Is this component buildable?
buildable :: HasBuildInfo a => Bool -> a
ghcOptions :: HasBuildInfo a => [NonEmptyString] -> a
ghcProfOptions :: HasBuildInfo a => [NonEmptyString] -> a
ghcSharedOptions :: HasBuildInfo a => [NonEmptyString] -> a
hugsOptions :: HasBuildInfo a => [NonEmptyString] -> a
nhc98Options :: HasBuildInfo a => [NonEmptyString] -> a

-- | Header files to be included in any compilations via C. Applies to both
--   header files that are already installed on the system and to those
--   coming with the package to be installed.
includes :: HasBuildInfo a => [NonEmptyString] -> a

-- | Header files to be installed into <tt>$libdir/includes</tt> when the
--   package is installed. These files should be found in relative to the
--   top of the source tree or relative to one of the directories listed in
--   <tt>include-dirs</tt>.
installIncludes :: HasBuildInfo a => [NonEmptyString] -> a

-- | List of diretories to search for header files when dealing with C
--   compilations.
includeDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | C sources to be compiled and lined with the Haskell files.
cSources :: HasBuildInfo a => [NonEmptyString] -> a

-- | Extra libraries to link with.
extraLibraries :: HasBuildInfo a => [NonEmptyString] -> a

-- | Directories to search for libraries.
extraLibDirs :: HasBuildInfo a => [NonEmptyString] -> a

-- | C Compiler options.
ccOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | C Preprocessor options. Undocumented, see
--   <a>https://github.com/haskell/cabal/issues/646</a>
cppOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | Linker options.
ldOptions :: HasBuildInfo a => [NonEmptyString] -> a

-- | List of pkg-config packages needed to build this component.
pkgConfigDepends :: HasBuildInfo a => [Package] -> a

-- | OS X frameworks.
frameworks :: HasBuildInfo a => [NonEmptyString] -> a

-- | Sections that build executables. These are the <a>Executable</a>,
--   <a>Benchmark</a>, and <a>TestSuite</a> sections.
class BuildsExe a
mainIs :: BuildsExe a => NonEmptyString -> a

-- | Sections that build executables that can be
--   <tt>exitcode-stdio-1.0</tt>. These are the <a>Benchmark</a> and
--   <a>TestSuite</a> sections.
class BuildsExitcode a
exitcodeStdio :: BuildsExitcode a => a

-- | Builds two fields. The first indicates that this is an
--   <tt>exitcode-stdio-1.0</tt> executable; the second is the appropriate
--   <tt>main-is</tt> field.
exitcodeFields :: (BuildsExitcode a, BuildsExe a) => NonEmptyString -> [a]

-- | Computations that can create and use Cabal flags. Use of this type,
--   along with the <a>defaultMain</a> function ensures that any
--   <a>FlagName</a> you use has been properly set up by using
--   <a>makeFlag</a>. That way, you don't use flags in a <a>flag</a>
--   without actually declaring the flag. When <a>defaultMain</a> creates
--   your Cabal file, it will print the necessary <tt>Flag</tt> sections.
--   
--   <a>Betsy</a> is parameterized on a type, <tt>m</tt>. When this type is
--   a monad, <a>Betsy</a> is also a monad, allowing you to use use the
--   usual monad combinators and <tt>do</tt> notation. <a>Betsy</a> is also
--   a monad transformer.
data Betsy m a

-- | The name of a flag. Only <a>makeFlag</a> creates flags; it will return
--   a <a>FlagName</a> to you. You can then use that <a>FlagName</a> in a
--   conditional using <a>flag</a>.
data FlagName

-- | Options for flags, except for the flag's name.
data FlagOpts
FlagOpts :: String -> Bool -> Bool -> FlagOpts

-- | A one-line description of what the flag does; this is optional.
flagDescription :: FlagOpts -> String

-- | Is this flag on or off by default?
flagDefault :: FlagOpts -> Bool

-- | If a flag is manual, Cabal will not change its value. If a flag is not
--   manual, Cabal will change its value automatically to attempt to
--   satisfy the package's dependencies.
flagManual :: FlagOpts -> Bool

-- | The name of a flag, paired with its options.
data Flag
Flag :: FlagName -> FlagOpts -> Flag

-- | Creates new flags.
makeFlag :: Applicative m => NonEmptyString -> FlagOpts -> Betsy m FlagName

-- | Returns a list of all flags made so far.
currentFlags :: Applicative f => Betsy f [Flag]

-- | A field in the <tt>Library</tt> section of the Cabal file. A
--   <tt>Library</tt> section can have multiple fields.
data LibraryField

-- | Whether a library is exposed. GHC can hide libraries.
exposed :: Bool -> LibraryField

-- | A library's exposed modules. <a>modules</a> can help you generate
--   this, without you having to manually list each module and keep the
--   list up to date.
exposedModules :: [NonEmptyString] -> LibraryField

-- | A single field in an <a>Executable</a> section. An <a>Executable</a>
--   section may have multiple fields.
data ExecutableField

-- | Builds a <a>Section</a> for executable files.
executable :: NonEmptyString -> [ExecutableField] -> Section
detailed :: TestSuiteField

-- | A single field value in a <a>TestSuite</a> section. A single test
--   suite section may contain mulitple fields.
data TestSuiteField

-- | The module exporting the <tt>tests</tt> symbol. This is required when
--   using <a>Detailed</a> and disallowed when using <a>ExitcodeStdio</a>.
testModule :: NonEmptyString -> TestSuiteField

-- | Builds a <a>Section</a> for test suites.
testSuite :: NonEmptyString -> [TestSuiteField] -> Section

-- | A single field in a <tt>Benchmark</tt> section.
data BenchmarkField

-- | Builds a <a>Section</a> for benchmarks.
benchmark :: NonEmptyString -> [BenchmarkField] -> Section

-- | Common extensions of Haskell files and files that are preprocessed
--   into Haskell files. Includes:
--   
--   <ul>
--   <li>hs (Haskell)</li>
--   <li>lhs (literate Haskell)</li>
--   <li>gc (greencard)</li>
--   <li>chs (c2hs)</li>
--   <li>hsc (hsc2hs)</li>
--   <li>y and ly (happy)</li>
--   <li>x (alex)</li>
--   <li>cpphs</li>
--   </ul>
fileExtensions :: [String]

-- | Gets all Haskell modules in a given directory tree. Allows you to
--   specify what extensions you are interested in. For this to work best,
--   you will want to keep all your library modules in their own directory,
--   such as <tt>lib/</tt>. You can also separate executables and test
--   suites this way. <a>hsSourceDirs</a> will then tell Cabal to use these
--   directories.
modulesWithExtensions :: MonadIO m => [NonEmptyString] -> FilePath -> Betsy m [NonEmptyString]

-- | Same as
--   
--   <pre>
--   <a>modulesWithExtensions</a> <a>fileExtensions</a>
--   </pre>
modules :: MonadIO m => FilePath -> Betsy m [NonEmptyString]
data BuildType
simple :: BuildType
configure :: BuildType
make :: BuildType
custom :: BuildType
data License
gpl :: License
agpl :: License
lgpl :: License
bsd2 :: License
bsd3 :: License
bsd4 :: License
mit :: License
mpl :: License
apache :: License
publicDomain :: License
allRightsReserved :: License
otherLicense :: License

-- | Global package properties.
data Properties
Properties :: String -> Version -> Maybe (Word, Word) -> Maybe BuildType -> Maybe License -> String -> [NonEmptyString] -> String -> String -> String -> String -> String -> String -> String -> String -> [String] -> String -> [(Compiler, Constraint)] -> [NonEmptyString] -> String -> [NonEmptyString] -> [NonEmptyString] -> [NonEmptyString] -> Properties
name :: Properties -> String
version :: Properties -> Version
cabalVersion :: Properties -> Maybe (Word, Word)
buildType :: Properties -> Maybe BuildType
license :: Properties -> Maybe License
licenseFile :: Properties -> String
licenseFiles :: Properties -> [NonEmptyString]
copyright :: Properties -> String
author :: Properties -> String
maintainer :: Properties -> String
stability :: Properties -> String
homepage :: Properties -> String
bugReports :: Properties -> String
packageUrl :: Properties -> String
synopsis :: Properties -> String
description :: Properties -> [String]

-- | According to the "Developing Cabal Packages" document, this should
--   simply be an email address.
category :: Properties -> String
testedWith :: Properties -> [(Compiler, Constraint)]
dataFiles :: Properties -> [NonEmptyString]
dataDir :: Properties -> String
extraSourceFiles :: Properties -> [NonEmptyString]
extraDocFiles :: Properties -> [NonEmptyString]
extraTmpFiles :: Properties -> [NonEmptyString]

-- | Generates a Cabal file. If you have no library, just leave the list of
--   <a>LibraryField</a> empty. Include any and all executables, test
--   suites, benchmarks, and repositories in the list of <a>Section</a>.
--   Ensures that the generated Cabal file also includes any flags you made
--   with <a>makeFlag</a>. If there is an error (such as a duplicate flag)
--   an error message is printed to standard error and the program invokes
--   <a>exitFailure</a>; otherwise, the generated Cabal file is printed to
--   standard output and the program invokes <a>exitSuccess</a>. Output
--   will always be UTF-8, consistent with Cabal's requirements.
--   
--   Includes a header showing that the Cabal file was auto-generated and
--   the program name that generated the Cabal file, along with when it was
--   generated. This gives a clue to readers who see a Cabal file in the
--   distributed tarball but who would get confused when there isn't one in
--   the version controlled sources. To omit the header, use
--   <a>defaultMainWithHeader</a>.
defaultMain :: Betsy IO (Properties, [LibraryField], [Section]) -> IO ()

-- | Like <a>defaultMain</a> but allows you to specify what header to
--   prepend to the output (if any).
defaultMainWithHeader :: (Cabal -> IO String) -> Betsy IO (Properties, [LibraryField], [Section]) -> IO ()


-- | This program generates Cartel's own Cabal file. It's included here in
--   the library to provide a live, type-checked, compilable example. You
--   will want to look at the source code itself, as the Haddocks won't
--   show you much.
module Cartel.GenCartelCabal
base :: Package
directory :: Package
filepath :: Package
time :: Package
quickcheck :: Package
tasty :: Package
tastyQuickcheck :: Package
tastyTh :: Package
random :: Package
transformers :: Package
multiarg :: Package
libDepends :: [Package]
testDepends :: [Package]
commonOptions :: HasBuildInfo a => [a]
testOptions :: HasBuildInfo a => [a]
main :: IO ()
