-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Khovanov homology computations
--   
@package knots
@version 0.1.0.1

module Knots.Prelude
type Ab a = (Default a, AbelianGroup a)
type AbDef a = (Default a, AbelianGroup a)
type AbEq a = (Eq a, AbelianGroup a)

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a
type DefEq a = (Eq a, Default a)
data F2

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Should be in scope when using the GHC extension RebindableSyntax
ifThenElse :: Bool -> a -> a -> a

-- | A map of integers to values <tt>a</tt>.
data IntMap a :: * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Like the <a>Ratio</a> from the base package, but with a custom Show
--   instance, and with some algebraic instances
data Ratio a
(:%) :: !a -> !a -> Ratio a
type Rational = Ratio Integer
type RingDef a = (Default a, Ring a)
type RingEq a = (Default a, Eq a, Ring a)

-- | A set of values <tt>a</tt>.
data Set a :: * -> *

-- | Like Data.Foldable.sum, but for any instance of AbelianGroup
sum :: AbelianGroup a => [a] -> a

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | Boxed vectors, supporting efficient slicing.
data Vector a :: * -> *
xor :: Bool -> Bool -> Bool
instance Eq F2
instance NFData F2
instance Field F2
instance Ring F2
instance AbelianGroup F2
instance Default F2
instance Show F2
instance EuclideanDomain a => Default (Ratio a)
instance (EuclideanDomain a, Eq a, Show a) => Show (Ratio a)
instance (Ord a, EuclideanDomain a) => Ord (Ratio a)
instance (Eq a, EuclideanDomain a) => Eq (Ratio a)
instance EuclideanDomain a => Field (Ratio a)
instance EuclideanDomain a => Ring (Ratio a)
instance EuclideanDomain a => AbelianGroup (Ratio a)

module Knots.Util

-- | <tt>choose n k</tt> computes all cardinality-<tt>k</tt> subsets of {
--   0, 1, ..., n-1 }.
choose :: Int -> Int -> Vector (Set Int)

-- | <tt>choose' s k</tt> computes all cardinality-<tt>k</tt> subsets of
--   the set <tt>s</tt>.
choose' :: Ord a => Set a -> Int -> [Set a]
choose'' :: Int -> Int -> Set (Set Int)
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
map3 :: (Functor f, Functor g, Functor h) => (a -> b) -> f (g (h a)) -> f (g (h b))
map'i :: (Functor (f i), Functor (g i)) => (forall x k. f k x -> g k x) -> f i (f j a) -> g i (g j a)
map' :: (Functor f, Functor g) => (forall x. f x -> g x) -> f (f a) -> g (g a)
groupMap :: (Ord k, Ord l) => (k -> a -> l) -> Map k a -> Map l (Map k a)
convertMap1 :: (Ord k1, Ord k2) => Map k1 (Map k2 a) -> Map (k1, k2) a
convertMap2 :: (Ord k1, Ord k2) => Map (k1, k2) a -> Map k1 (Map k2 a)
convertMap3 :: (Ord k1, Ord k2) => Map k1 (Map k2 a) -> Map k2 (Map k1 a)
convertMap4 :: Ord k => [Map k a] -> Map k [Maybe a]
prod :: (Monoid a, Ord a) => Set a -> Set a -> Set a
prod' :: (Ord a, Ord b) => Set a -> Set b -> Set (a, b)

-- | List of subsets of a given set.
power :: Ord a => Set a -> [Set a]

-- | Scalar multiplication
(.*) :: (Ring r, Functor f) => r -> f r -> f r

-- | Strict, unpacked pair of two <tt>Int</tt> values.
data IntPair
IntPair :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> IntPair
replace :: Eq a => a -> a -> a -> a
instance Eq IntPair
instance Ord IntPair
instance Read IntPair
instance Show IntPair
instance NFData IntPair

module Knots.PD
data Node a
N :: a -> a -> a -> a -> Node a
type PD a = [Node a]
indices :: Ord a => PD a -> Set a
trefoil :: PD Int

-- | ElMo is short for Elementary Morphism, for the building blocks of our
--   matrices.
data ElMo
Mult :: Int -> Int -> Int -> ElMo
Comult :: Int -> Int -> Int -> ElMo
Neg :: (ElMo) -> ElMo
resolve_set :: Ord a => PD a -> Set (Set a)
resolve_one_set :: Ord a => Node a -> Set (Set a) -> Set (Set a)
mergeParts :: Ord a => a -> a -> Set (Set a) -> Set (Set a)
mirror :: PD a -> PD a
switch :: Node a -> Node a
switch' :: Set Int -> PD a -> PD a
replaceBySeveral :: Eq a => a -> [a] -> PD a -> PD a
replaceFirst :: Eq a => a -> a -> PD a -> PD a
addHopfy :: Ord a => a -> a -> a -> a -> a -> PD a -> PD a
instance Eq a => Eq (Node a)
instance Show a => Show (Node a)
instance Read a => Read (Node a)
instance Foldable Node
instance Functor Node
instance Eq ElMo
instance Show ElMo

module Knots.Table

-- | List of valid indices for the Rolfsen <a>knot</a> table.
table :: [(Int, Int)]

-- | Rolfsen table of knots.
knot :: Int -> Int -> PD Int

module Knots.Torus

-- | Positive T(m,n) torus link
torusLink :: Int -> Int -> PD (Either Int Int)

-- | Positive turn as a braid. Pass a negative argument to get a negative
--   turn.
turn :: Int -> PD (Either Int Int)

-- | <tt>close m k</tt> closes the braid after <tt>k</tt> many
--   <tt>m</tt>-<a>turn</a>s.
close :: (Ord a, Num a, Functor f) => a -> a -> [f (Either a b)] -> [f (Either a b)]

module Knots.Graded
data Graded a
Graded :: Int -> Map Int a -> Graded a
grade :: Graded a -> Int
components :: Graded a -> Map Int a
graded :: Int -> [(Int, a)] -> Graded a

-- | This is practically multiplication of polynomials in one variable, if
--   we interpret the keys of the <a>components</a> map as exponents. If we
--   write <tt>r[X]</tt> for the ring of polynomials over <tt>r</tt>, then
--   the <a>grade</a> can be interpreted as the degree of the variable X.
--   This should justify how the instance is defined.
instance Eq a => Eq (Graded a)
instance Show a => Show (Graded a)
instance Read a => Read (Graded a)
instance Functor Graded
instance Foldable Graded
instance (Monoid a, AbelianGroup a) => Monoid (Graded a)
instance Ring r => Ring (Graded r)
instance AbelianGroup a => AbelianGroup (Graded a)
instance Default (Graded a)

module Knots.Free
type Basis b = Ord b

-- | Free vector space with basis <tt>b</tt> and coefficient ring
--   <tt>r</tt>.
newtype Free b r
F :: Map b r -> Free b r
unF :: Free b r -> Map b r
liftF :: (Map b r -> Map b' r') -> Free b r -> Free b' r'

-- | Monomial.
(.#) :: r -> b -> Free b r
mapBasis :: (Basis b, Basis c) => (b -> c) -> Free b r -> Free c r

-- | Point-wise addition

-- | A sort of Kronecker (tensor) product

-- | Encoding of a linear map from `Free b r' to `Free c r'. The choice of
--   encoding is limited to such linear maps <tt>f</tt> where `f(x)'
--   vanishes for all but finitely many basis elements <tt>x</tt> in
--   <tt>b</tt>.
--   
--   Speaking matrix-wise, the intended interpretation is column-major
--   format; use <a>dual</a> to convert from row-major format.
data Lin b c r
Lin :: Set b -> Set c -> Free b (Free c r) -> Lin b c r
dom :: Lin b c r -> Set b
cod :: Lin b c r -> Set c
matrix :: Lin b c r -> Free b (Free c r)
columns :: Lin i j a -> Map i (Map j a)
onMatrix :: (Free b (Free c r) -> Free b (Free c r)) -> Lin b c r -> Lin b c r

-- | (Partial) ring instance for certain endomorphisms, implementing tensor
--   product.
--   
--   BEWARE: This is the tensor product; it is *not* composition of
--   morphisms.
plus :: (Basis b, AbEq r) => [(b, r)] -> Free b r
coeff :: (Basis b, AbelianGroup r) => Free b r -> b -> r
monomials :: Free b r -> [(b, r)]
lin :: (Basis b, Basis c, AbelianGroup r, Eq r) => [b] -> [c] -> Free b (Free c r) -> Lin b c r
transpose :: (Basis b, Basis c, AbEq r) => Free c (Free b r) -> Free b (Free c r)

-- | Transposition.
dual :: (Basis a, Basis b, AbEq r) => Lin a b r -> Lin b a r

-- | Composition of linear maps.
o :: (Basis a, Basis b, Basis c, RingEq r) => Lin b c r -> Lin a b r -> Lin a c r

-- | Matrix-vector-multiplication.
apply :: (Basis a, Basis b, RingEq r) => Free a (Free b r) -> Free a r -> Free b r

-- | Outer tensor product. Works also for linear maps, but for
--   endomorphisms, <tt>*</tt> is preferred.
tensor :: (Basis b, Basis c, Ring r, Eq r) => Free b r -> Free c r -> Free (b, c) r

-- | Checks whether the linear map maps everything to <a>def</a>.
isNullMatrix :: AbEq r => Lin a b r -> Bool
isNullVector :: AbEq r => Free b r -> Bool
join_free :: (Basis b, Basis c, AbelianGroup r) => Free b (Free c r) -> Free (b, c) r
unions :: (Basis a, Foldable f) => f (Set a) -> Set a
mapToPairs :: (Basis k, Basis a) => Map k (Set a) -> Set (k, a)
join_codomains :: (Basis b, Basis b', Basis c, Basis c', AbEq r) => Lin b c (Lin b' c' r) -> Set (c, c')
join_domains :: (Basis b, Basis b', Basis c, Basis c', AbEq r) => Lin b c (Lin b' c' r) -> Set (b, b')
join_lin :: (Basis a, Basis b, Basis c, Basis d, AbEq r) => Lin a c (Lin b d r) -> Lin (a, b) (c, d) r

-- | Reduce the entries of a matrix to weak head normal form.
seqMatrix :: Free c (Free b r) -> x -> x

-- | Apply <a>seqMatrix</a> to the argument before applying the function to
--   it.
($!!!) :: (Free c (Free b r) -> x) -> Free c (Free b r) -> x

-- | Applies elementary column transformations until column echelon form is
--   achieved.
gauss :: (Basis b, Basis c, Field r, Eq r, NFData b, NFData c, NFData r) => Lin b c r -> Lin b c r
rank :: (Basis b, Basis c, Field r, Eq r, NFData b, NFData c, NFData r) => Lin b c r -> Int
adjust :: Basis b => (r -> r) -> b -> Free b r -> Free b r
exchange :: Basis b => b -> b -> Free b r -> Free b r
findIndices :: (r -> Bool) -> Free b r -> [b]
(#) :: (Basis b, Basis c, AbelianGroup r) => Free c (Free b r) -> (c, b) -> r
instance (Eq b, Eq r) => Eq (Free b r)
instance (Ord b, Read b, Read r) => Read (Free b r)
instance Functor (Free b)
instance Foldable (Free b)
instance (NFData b, NFData r) => NFData (Free b r)
instance (Eq b, Eq c, Eq r) => Eq (Lin b c r)
instance (Show b, Show c, Show r) => Show (Lin b c r)
instance (Ord b, Ord c, Read b, Read c, Read r) => Read (Lin b c r)
instance Functor (Lin b c)
instance (NFData b, NFData c, NFData r) => NFData (Lin b c r)
instance (Ring r, Eq r, Monoid b, Basis b) => Ring (Lin b b r)
instance (Basis b, Basis c, AbelianGroup r) => AbelianGroup (Lin b c r)
instance Foldable (Lin b c)
instance (Basis b, Monoid b, Ring r, Eq r) => Ring (Free b r)
instance (AbelianGroup r, Basis b) => AbelianGroup (Free b r)
instance Basis b => Default (Free b r)
instance (Show b, Show r) => Show (Free b r)

module Knots.Morphism
type Morphism b r = Graded (Lin b b r)
oo :: (Default b, Ord b, RingEq r) => Morphism b r -> Morphism b r -> Morphism b r
data B
B1 :: B
Bx :: B
degreeB :: B -> Int
degree :: [B] -> Int
isB1 :: B -> Bool
basis :: Int -> [[B]]
b1 :: [B]
bx :: [B]
b11 :: [B]
bxx :: [B]
bx1 :: [B]
b1x :: [B]
b111 :: [B]
bxxx :: [B]
bxx1 :: [B]
bx1x :: [B]
bx11 :: [B]
b1xx :: [B]
b1x1 :: [B]
b11x :: [B]
mult :: RingEq r => Morphism [B] r
idB1 :: RingEq r => Morphism [B] r
idA :: RingEq r => Morphism [B] r
permReduced :: RingEq r => Morphism [B] r
perm :: RingEq r => Morphism [B] r
comultReducedRight :: RingEq r => Morphism [B] r
comultReducedLeft :: RingEq r => Morphism [B] r
comult :: RingEq r => Morphism [B] r
multReducedRight :: RingEq r => Morphism [B] r
multReducedLeft :: RingEq r => Morphism [B] r
backPermute :: RingEq r => Morphism [B] r -> Morphism [B] r -> Int -> Morphism [B] r
forwardPermute :: RingEq r => Morphism [B] r -> Morphism [B] r -> Int -> Morphism [B] r
type Complex' r = Map Int (Morphism (Set Int, [B]) r)
convert :: (Ord i, Ord b, Ord c, AbelianGroup r) => Lin b c (Map i r) -> Map i (Lin b c r)
toMatrix :: (Ord a, Ord b, AbelianGroup r) => Lin a b r -> ((Int, Int), [[r]])
toMatrices :: AbelianGroup r => Complex' r -> Map (Int, Int) ((Int, Int), [[r]])
isNullComplex' :: AbEq r => Complex' r -> Bool
isNullMorphism :: AbEq r => Morphism b r -> Bool
homology' :: Graded (Int, Int, Int) -> Graded (Int, Int, Int) -> Graded Int
homology :: Map Int (Graded (Int, Int, Int)) -> Map Int (Graded Int)
computeDims :: (Field r, Eq r, NFData r) => Complex' r -> Map Int (Graded (Int, Int, Int))
shiftGraded :: Graded a -> Graded a
instance Eq B
instance Show B
instance Read B
instance Ord B
instance NFData B

module Knots.Khovanov
data PartitionComparison a
Split :: (Set (Set a)) -> (Set a) -> (Set (Set a)) -> (Set a) -> (Set (Set a)) -> PartitionComparison a
Merge :: (Set (Set a)) -> (Set a) -> (Set (Set a)) -> (Set a) -> (Set (Set a)) -> PartitionComparison a
data ComparisonType
TypeSplit :: ComparisonType
TypeMerge :: ComparisonType
split3 :: Ord a => Set a -> a -> a -> (Set a, Set a, Set a)
partitionComparison :: Ord a => Set (Set a) -> Set (Set a) -> PartitionComparison a
data MarkPosition
None :: MarkPosition
MarkLeft :: Int -> MarkPosition
ReducedLeft :: MarkPosition
MarkMiddle :: Int -> MarkPosition
ReducedRight :: MarkPosition
MarkRight :: Int -> MarkPosition
markPosition :: Ord a => a -> PartitionComparison a -> MarkPosition
markPosition' :: Ord a => a -> Set (Set a) -> Set a -> Set (Set a) -> Set a -> Set (Set a) -> MarkPosition
toElMo :: Ord a => PartitionComparison a -> ElMo
morphism :: Ord a => Set Int -> Set Int -> Set (Set a) -> Set (Set a) -> ElMo
morphism_ :: Ord a => a -> Set Int -> Set Int -> Set (Set a) -> Set (Set a) -> (ElMo, MarkPosition)
toMorphism :: RingEq r => ElMo -> MarkPosition -> Morphism [B] r
padMorphism :: RingEq r => ComparisonType -> Int -> Int -> Int -> MarkPosition -> Morphism [B] r
khovanov :: Ord a => Maybe a -> PD a -> Map (Set Int, Set Int) (ElMo, MarkPosition)
khovanovLine :: [[[Int]]] -> [ElMo]
instance Eq a => Eq (PartitionComparison a)
instance Show a => Show (PartitionComparison a)
instance Eq MarkPosition
instance Show MarkPosition
instance Read MarkPosition

module Knots.Complex
type Complex b r = [Lin b b r]
type GradedComplex b r = Map Int (Complex b r)

-- | Compute cohomology ranks of a complex
cohomology :: (NFData b, NFData r, Basis b, Field r, Eq r) => Complex b r -> [Int]

-- | Compute cohomology ranks of a graded complex
cohomologyGraded :: (NFData b, NFData r, Basis b, Field r, Eq r) => GradedComplex b r -> Map Int [Int]
mx :: (Ring c, Ring b, AbelianGroup r, Ord c, Ord b, Eq r, Enum c, Enum b) => c -> b -> [[r]] -> Lin b c r
indexify :: (Ring b', AbelianGroup r', Ord b', Eq r', Enum b') => [r'] -> Free b' r'
purify :: (AbelianGroup r', Eq r') => Free b' r' -> Free b' r'
purifyLin :: (AbelianGroup r, Ord c, Eq r) => Lin b c r -> Lin b c r
sampleComplex :: Complex Int Rational

-- | Check whether the differential squares to zero
isComplex :: (Basis b, RingEq r) => Complex b r -> Bool

-- | The basis vectors in the domain that actually occur. In other words,
--   the basis vectors that correspond to (potentially) non-zero columns.
--   
--   Assuming the morphism to be given in column echelon form, this counts
--   steps.
steps :: Lin k a b -> [a]
omit :: Basis b => [b] -> Free b r -> Free b r
omitColumns :: Basis b => [b] -> Lin b c r -> Lin b c r

-- | Elementary column transformations, stepping through the complex from
--   left to right. The resulting complex has the same cohomology and has
--   all matrices in column echelon form.
gaussComplex :: (NFData b, NFData r, Basis b, Field r, Eq r) => Complex b r -> Complex b r
type C r = Graded (Complex [B] r)
ooo :: RingEq r => C r -> C r -> C r
oooo :: (Ring r, Default r, Ord b, Ord a, Ord c, Eq r) => [Lin b c r] -> [Lin a b r] -> [Lin a c r]
khCx_Q :: Ord a => Maybe a -> PD a -> GradedComplex IntPair Rational
khCx_Z :: Ord a => Maybe a -> PD a -> GradedComplex IntPair Integer
khCx_F2 :: Ord a => Maybe a -> PD a -> GradedComplex IntPair F2
groupByKeySize :: [Int] -> Map (Set a1) a -> [Map (Set a1) a]

-- | Example: Compute rational Khovanov homology and print ungraded
--   results.
example :: Ord a => PD a -> [Int]
khCx :: (Ring r, Default r, Ord a, Eq r) => Maybe a -> [Node a] -> GradedComplex IntPair r
conv :: (Ring r, Default r, Eq r) => [ElMo] -> Map Int [Lin [B] [B] r]
hash :: (Set Int, [B]) -> IntPair
bitfield :: (Ring b, Integral b1, Foldable t) => t b1 -> b
hashInComplex :: GradedComplex (Set Int, [B]) r -> GradedComplex IntPair r
instance Ring a => Ring [a]
instance AbelianGroup a => AbelianGroup [a]

module Knots.Braid
data Braid
Braid :: Int -> [Int] -> Braid
braidWidth :: Braid -> Int
braidWord :: Braid -> [Int]
data N a
Z :: a -> N a
S :: (N a) -> N a
the :: N a -> a
fromBraid :: Braid -> PD (N Int)
fromBraid' :: Int -> [Int] -> ([N Int], PD (N Int))
renameShift :: Int -> N Int -> N Int
torusBraid :: Int -> Int -> Braid
mirrorBraid :: Braid -> Braid
torusTurn :: Int -> [Int]
instance Eq Braid
instance Show Braid
instance Read Braid
instance Eq a => Eq (N a)
instance Show a => Show (N a)
instance Read a => Read (N a)
instance Ord a => Ord (N a)

module Knots
cohomBraidPar :: Int -> Braid -> [(Int, [Int])]
