-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | WAI request predicates
--   
@package wai-predicates
@version 0.8.3

module Network.Wai.Predicate.Utility
readValues :: FromByteString a => [ByteString] -> Either ByteString a
(&) :: a -> (a -> b) -> b

module Network.Wai.Predicate.Request
data Req
class HasMethod a
method :: HasMethod a => a -> Method
class HasHeaders a
headers :: HasHeaders a => a -> RequestHeaders
class HasCookies a
cookies :: HasCookies a => a -> Cookies
class HasQuery a
queryItems :: HasQuery a => a -> Query
class HasPath a
segments :: HasPath a => a -> Vector ByteString
class HasRequest a
getRequest :: HasRequest a => a -> Request
class HasVault a
requestVault :: HasVault a => a -> Vault
fromRequest :: Request -> Req
lookupHeader :: HasHeaders r => HeaderName -> r -> [ByteString]
lookupQuery :: HasQuery r => ByteString -> r -> [ByteString]
lookupCookie :: HasCookies r => ByteString -> r -> [ByteString]
lookupSegment :: HasPath r => Word -> r -> Maybe ByteString
instance HasVault Req
instance HasPath Req
instance HasCookies Req
instance HasQuery Request
instance HasQuery Req
instance HasHeaders Request
instance HasHeaders Req
instance HasMethod Request
instance HasMethod Req
instance HasRequest Req

module Network.Wai.Predicate.Error

-- | The error type used as meta-data for <tt>Fail</tt> in all WAI
--   predicates.
data Error
data Reason
NotAvailable :: Reason
TypeError :: Reason
err :: Status -> Error
e400 :: Error
e405 :: Error
e406 :: Error
e415 :: Error
e500 :: Error

-- | HTTP status code
status :: Error -> Status

-- | optional status message
message :: Error -> Maybe ByteString

-- | optional reason for this error
reason :: Error -> Maybe Reason

-- | optional source of this erro
source :: Error -> Maybe ByteString

-- | optional free-text labels
labels :: Error -> [ByteString]
setStatus :: Status -> Error -> Error
setMessage :: ByteString -> Error -> Error
setReason :: Reason -> Error -> Error
setSource :: ByteString -> Error -> Error
addLabel :: ByteString -> Error -> Error
isReasonOf :: Reason -> Error -> Bool
instance Eq Reason
instance Show Reason
instance Eq Error
instance Show Error

module Network.Wai.Predicate.MediaType
data Media (t :: Symbol) (s :: Symbol)
Media :: !ByteString -> !ByteString -> !Double -> ![(ByteString, ByteString)] -> Media
rawType :: Media -> !ByteString
rawSubTypes :: Media -> !ByteString
mediaQuality :: Media -> !Double
mediaParams :: Media -> ![(ByteString, ByteString)]
mediaType :: SingI t => Media t s -> ByteString
mediaSubType :: SingI s => Media t s -> ByteString
instance Eq (Media t s)
instance Show (Media t s)

module Data.Predicate

-- | A predicate is a function of some value of type <tt>a</tt> to a
--   <a>Result</a>, i.e. a <a>Bool</a>-like value with <a>Okay</a> as
--   <a>True</a> and <a>Fail</a> as <a>False</a>, which carries additional
--   data in each branch.
type Predicate a f t = a -> Result f t

-- | A predicate which always returns <tt>Okay</tt> with the given value as
--   metadata.
constant :: t -> Predicate a f t

-- | A predicate which always returns <tt>Fail</tt> with the given value as
--   metadata.
failure :: f -> Predicate a f t
true :: Predicate a f ()
false :: Predicate a () t

-- | A predicate corresponding to the logical AND connective of two
--   predicate.
and :: Predicate a f t -> Predicate a f t' -> Predicate a f (t ::: t')

-- | A predicate corresponding to the logical OR connective of two
--   predicates. It requires the metadata of each <tt>Okay</tt> branch to
--   be of the same type.
--   
--   If both arguments evaluate to <tt>Okay</tt> the one with the smaller
--   "delta" will be preferred, or--if equal--the left-hand argument.
or :: Predicate a f t -> Predicate a f t -> Predicate a f t

-- | A predicate corresponding to the logical OR connective of two
--   predicates. The metadata of each <tt>Okay</tt> branch can be of
--   different types.
--   
--   If both arguments evaluate to <tt>Okay</tt> the one with the smaller
--   "delta" will be preferred, or--if equal--the left-hand argument.
orElse :: Predicate a f t -> Predicate a f t' -> Predicate a f (Either t t')

-- | Alias of <a>and</a>.
(.&.) :: Predicate a f t -> Predicate a f t' -> Predicate a f (t ::: t')

-- | Alias of <a>or</a>.
(.|.) :: Predicate a f t -> Predicate a f t -> Predicate a f t

-- | Alias of <a>orElse</a>.
(|||) :: Predicate a f t -> Predicate a f t' -> Predicate a f (Either t t')
exec :: Predicate a f t -> a -> (f -> b) -> (t -> b) -> b

-- | A <a>Bool</a>-like type where each branch--<tt>Fail</tt> and
--   <tt>Okay</tt>--carries some metadata.
data Result f t
Fail :: f -> Result f t
Okay :: !Double -> t -> Result f t
result :: (f -> a) -> (Double -> t -> a) -> Result f t -> a
fromEither :: Either f t -> Result f t
toEither :: Result f t -> Either f t
newtype ResultT f m t
ResultT :: m (Result f t) -> ResultT f m t
runResultT :: ResultT f m t -> m (Result f t)
resultT :: Monad m => (f -> m a) -> (Double -> t -> m a) -> ResultT f m t -> m a
resultT' :: Monad m => (f -> m a) -> (t -> m a) -> ResultT f m t -> m a
mapResultT :: (m (Result f t) -> n (Result f' t')) -> ResultT f m t -> ResultT f' n t'
hoistResult :: Monad m => Result f t -> ResultT f m t
okay :: Monad m => Double -> t -> ResultT f m t
throwF :: Monad m => f -> ResultT f m t

-- | A data-type for combining results of predicate evaluations.
data (:::) a b
(:::) :: a -> b -> (:::) a b

-- | <tt>flip ($)</tt> - useful in combination with indexed access, e.g.
--   <tt>(<tt>x</tt> ::: True ::: False)#_2</tt> yields <tt>True</tt>.
(#) :: a -> (a -> b) -> b
hd :: a ::: b -> a
tl :: a ::: b -> b
_1 :: a ::: b -> a
_2 :: a ::: (b ::: c) -> b
_3 :: a ::: (b ::: (c ::: d)) -> c
_4 :: a ::: (b ::: (c ::: (d ::: e))) -> d
_5 :: a ::: (b ::: (c ::: (d ::: (e ::: f)))) -> e
_6 :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: g))))) -> f
_7 :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: (g ::: h)))))) -> g
_8 :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: (g ::: (h ::: i))))))) -> h
_9 :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: (g ::: (h ::: (i ::: j)))))))) -> i
_1' :: a ::: b -> a
_2' :: a ::: b -> b
_3' :: a ::: (b ::: c) -> c
_4' :: a ::: (b ::: (c ::: d)) -> d
_5' :: a ::: (b ::: (c ::: (d ::: e))) -> e
_6' :: a ::: (b ::: (c ::: (d ::: (e ::: f)))) -> f
_7' :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: g))))) -> g
_8' :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: (g ::: h)))))) -> h
_9' :: a ::: (b ::: (c ::: (d ::: (e ::: (f ::: (g ::: (h ::: i))))))) -> i

module Network.Wai.Predicate
request :: HasRequest r => Predicate r f Request
def :: a -> Predicate r Error a -> Predicate r Error a
opt :: Predicate r Error a -> Predicate r Error (Maybe a)
query :: (HasQuery r, FromByteString a) => ByteString -> Predicate r Error a
hasQuery :: HasQuery r => ByteString -> Predicate r Error ()
header :: (HasHeaders r, FromByteString a) => HeaderName -> Predicate r Error a
hasHeader :: HasHeaders r => HeaderName -> Predicate r Error ()
segment :: (HasPath r, FromByteString a) => Word -> Predicate r Error a
hasSegment :: HasPath r => Word -> Predicate r Error ()
cookie :: (HasCookies r, FromByteString a) => ByteString -> Predicate r Error a
hasCookie :: HasCookies r => ByteString -> Predicate r Error ()
accept :: HasHeaders r => ByteString -> ByteString -> Predicate r Error (Media (t :: Symbol) (s :: Symbol))
contentType :: HasHeaders r => ByteString -> ByteString -> Predicate r Error (Media (t :: Symbol) (s :: Symbol))
fromVault :: HasVault r => Key a -> Predicate r Error a
