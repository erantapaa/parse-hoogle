-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic deriving of TypeableN instances with Template Haskell
--   
--   This package provides template haskell functions for deriving
--   TypeableN instances for types of every kind, selecting the best N that
--   is possible.
@package typeable-th
@version 0.1.5

module Data.Typeable.TH

-- | Derive the <a>best</a> typeable instance for a given data type.
makeTypeable :: Name -> Q [Dec]

-- | Derive the given TypeableN instance for a data type. Using N=0
--   generates a plain Typeable instance. Note that this function may fail
--   if it's not possible to derive the requested TypeableN instance.
makeTypeableN :: Name -> Int -> Q [Dec]

-- | <tt>dropEnd n l</tt> drops <tt>n</tt> items from the end of the list
--   <tt>l</tt>. This function is implemented the naive way, it might not
--   be the fastest.
dropEnd :: Int -> [a] -> [a]

-- | Calculate the maximum N for which a TypeableN instance is generatable
--   for a given kind. How this works is explained in the description at
--   the top of this module.
bestTypeable :: Kind -> Int

-- | Generate the typeOfN function of TypeableN, tell'ing all instance
--   context predicates and declarations we need. We also update a state to
--   have a counter for generating unique names for data types we declare.
typeableBody :: Name -> Kind -> Int -> [Name] -> WriterT ([Dec], [Pred]) (StateT Integer Q) Exp

-- | Returns the expression to get the TypeRep of a given type variable
--   with a given kind.
typeRepOf :: Name -> Kind -> WriterT ([Dec], [Pred]) (StateT Integer Q) Exp

-- | Split the part in front of the arrow from a kind, and return the rest
--   (if there is any rest). Example: splitKind (* -&gt; *) -&gt; * -&gt; *
--   will return ((* -&gt; *),Just * -&gt; *). This is used to implement
--   <a>params</a>.
splitKind :: Kind -> (Kind, Maybe Kind)

-- | Split a kind into a list of kinds, where each list element is a kind
--   of the parameter of the orginal kind. The list is ordered, a parameter
--   which comes first comes first in the list too.
params :: Kind -> [Kind]

-- | Generate a data type with the given kind that has no constructor and
--   return the name of it. The state is used for generating unqiue names
--   for the data type.
typeOfKind :: Kind -> StateT Integer Q (Name, [Dec])

-- | A helper function that makes sure the info is a TyConI, and throws an
--   error otherwise.
expectTyCon :: String -> Info -> Q Dec
