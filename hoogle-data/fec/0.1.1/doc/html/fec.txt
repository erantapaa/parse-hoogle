-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Forward error correction of ByteStrings
--   
--   This code, based on zfec by Zooko, based on code by Luigi Rizzo
--   implements an erasure code, or forward error correction code. The most
--   widely known example of an erasure code is the RAID-5 algorithm which
--   makes it so that in the event of the loss of any one hard drive, the
--   stored data can be completely recovered. The algorithm in the zfec
--   package has a similar effect, but instead of recovering from the loss
--   of only a single element, it can be parameterized to choose in advance
--   the number of elements whose loss it can tolerate.
@package fec
@version 0.1.1


-- | The module provides k of n encoding - a way to generate (n - k)
--   secondary blocks of data from k primary blocks such that any k blocks
--   (primary or secondary) are sufficient to regenerate all blocks.
--   
--   All blocks must be the same length and you need to keep track of which
--   blocks you have in order to tell decode. By convention, the blocks are
--   numbered 0..(n - 1) and blocks numbered &lt; k are the primary blocks.
module Codec.FEC
data FECParams

-- | Return a FEC with the given parameters.
fec :: Int -> Int -> FECParams

-- | Generate the secondary blocks from a list of the primary blocks. The
--   primary blocks must be in order and all of the same size. There must
--   be <tt>k</tt> primary blocks.
encode :: FECParams -> [ByteString] -> [ByteString]

-- | Recover the primary blocks from a list of <tt>k</tt> blocks. Each
--   block must be tagged with its number (see the module comments about
--   block numbering)
decode :: FECParams -> [(Int, ByteString)] -> [ByteString]

-- | Break a ByteString into <tt>n</tt> parts, equal in length to the
--   original, such that all <tt>n</tt> are required to reconstruct the
--   original, but having less than <tt>n</tt> parts reveals no information
--   about the orginal.
--   
--   This code works in IO monad because it needs a source of random bytes,
--   which it gets from <i>dev</i>urandom. If this file doesn't exist an
--   exception results
--   
--   Not terribly fast - probably best to do it with short inputs (e.g. an
--   encryption key)
secureDivide :: Int -> ByteString -> IO [ByteString]

-- | Reverse the operation of secureDivide. The order of the inputs doesn't
--   matter, but they must all be the same length
secureCombine :: [ByteString] -> ByteString

-- | A utility function which takes an arbitary input and FEC encodes it
--   into a number of blocks. The order the resulting blocks doesn't matter
--   so long as you have enough to present to <tt>deFEC</tt>.
enFEC :: Int -> Int -> ByteString -> [ByteString]

-- | Reverses the operation of <tt>enFEC</tt>.
deFEC :: Int -> Int -> [ByteString] -> ByteString
instance Show FECParams
