-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Useful standard collections types and related functions.
--   
--   This package provides a common API, through a consistent set of
--   classes, to the various standard container types. list, array, set,
--   map, bytestring, etc. are supported.
@package collections-base-instances
@version 1.0.0.0

module Data.Collections.BaseInstances

-- | General-purpose finite sequences.
data Seq a :: * -> *

-- | A map of integers to values <tt>a</tt>.
data IntMap a :: * -> *

-- | A set of integers.
data IntSet :: *
type StdSet = Set
type StdMap = Map
instance Map IntSet Int ()
instance Set IntSet Int
instance Collection IntSet Int
instance Unfoldable IntSet Int
instance Foldable IntSet Int
instance Ord a => SortingCollection (Set a) a
instance Ord a => Map (Set a) a ()
instance Ord a => Set (Set a) a
instance Ord a => Collection (Set a) a
instance Ord a => Unfoldable (Set a) a
instance Foldable (Set a) a
instance Map (IntMap a) Int a
instance Indexed (IntMap a) Int a
instance Collection (IntMap a) (Int, a)
instance Unfoldable (IntMap a) (Int, a)
instance Foldable (IntMap a) (Int, a)
instance Ord k => SortingCollection (Map k a) (k, a)
instance Ord k => Map (Map k a) k a
instance Ord k => Indexed (Map k a) k a
instance Ord k => Collection (Map k a) (k, a)
instance Ord k => Unfoldable (Map k a) (k, a)
instance Foldable (Map k a) (k, a)
instance Ix i => Array (Array i e) i e
instance Ix i => Indexed (Array i e) i e
instance Indexed ByteString Int Word8
instance Sequence ByteString Word8
instance Collection ByteString Word8
instance Unfoldable ByteString Word8
instance Foldable ByteString Word8
instance Indexed ByteString Int Word8
instance Sequence ByteString Word8
instance Collection ByteString Word8
instance Unfoldable ByteString Word8
instance Foldable ByteString Word8
instance Indexed (Seq a) Int a
instance Sequence (Seq a) a
instance Collection (Seq a) a
instance Foldable (Seq a) a
instance Unfoldable (Seq a) a
instance Indexed [a] Int a
instance Sequence [a] a
instance Collection [a] a
instance Unfoldable [a] a

module Data.Map.List

-- | View a list (actually any <a>Sequence</a>) of <tt>(key,value)</tt>
--   pairs as a <a>Map</a> collection.
--   
--   This allows to feed sequences into algorithms that require a map
--   without building a full-fledged map. Most of the time this will be
--   used only when the parameter list is known to be very small, such that
--   conversion to a Map would be to costly.
newtype AssocList s k v
AssocList :: s -> AssocList s k v
instance (Ord k, Sequence c (k, v), Monoid (AssocList c k v)) => Map (AssocList c k v) k v
instance (Ord k, Sequence c (k, v)) => Monoid (AssocList c k v)
instance (Ord k, Sequence c (k, v)) => Indexed (AssocList c k v) k v
instance (Ord k, Sequence c (k, v)) => Unfoldable (AssocList c k v) (k, v)
instance (Ord k, Sequence c (k, v)) => Collection (AssocList c k v) (k, v)
instance Sequence c (k, v) => Foldable (AssocList c k v) (k, v)
instance Show l => Show (AssocList l k v)
instance (Eq c, Eq k, Eq v, Foldable c (k, v)) => Eq (AssocList c k v)
instance Typeable3 AssocList

module Data.Set.List

-- | View a list of as a <a>Set</a> collection.
--   
--   This allows to feed sequences into algorithms that require a Set
--   without building a full-fledged Set. Most of the time this will be
--   used only when the parameter list is known to be very small, such that
--   conversion to a Set would be to costly.
newtype SetList s
SetList :: s -> SetList s
fromSetList :: SetList s -> s
instance Eq a => Map (SetList [a]) a ()
instance Eq a => Collection (SetList [a]) a
instance Eq a => Unfoldable (SetList [a]) a
instance Eq a => Monoid (SetList [a])
instance Eq a => Set (SetList [a]) a
instance Foldable (SetList [a]) a
instance Show l => Show (SetList l)
instance Typeable1 SetList
instance (Eq s, Eq a, Foldable s a) => Eq (SetList s)
