-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple Reactive library.
--   
--   A simple Reactive library.
@package definitive-reactive
@version 1.0

module Data.TimeVal

-- | A type wrapper that adds a Bounded instance for types that don't
--   possess one.
data TimeVal t
Always :: TimeVal t
Since :: t -> TimeVal t
Never :: TimeVal t
instance Show t => Show (TimeVal t)
instance Eq t => Eq (TimeVal t)
instance Ord t => Ord (TimeVal t)
instance Bounded (TimeVal t)
instance Traversable TimeVal
instance Foldable TimeVal
instance Monad TimeVal
instance Applicative TimeVal
instance Unit TimeVal
instance Functor TimeVal

module IO.Time

-- | A type wrappers for timestamps that can be compared unambiguously
data Time t

-- | A Time's pure value. Reduction to normal form may block.
timeVal :: Time t -> TimeVal t
freezed :: a
type Seconds = Double

-- | Constructs a Time representing the time by which the argument
--   terminates.
--   
--   Warning: This function executes its argument, ignoring its value.
--   Thus, it would be wise to use it on idempotent blocking actions, such
--   as <tt>readMVar</tt>.
timeIO :: IO a -> IO (Time Seconds)
waitTill :: Seconds -> IO ()
currentTime :: IO Seconds
timeOrigin :: (?birthTime :: Seconds => IO a) -> IO a
ms :: Seconds -> Seconds
mus :: Seconds -> Seconds
ns :: Seconds -> Seconds
minutes :: Seconds -> Seconds
hours :: Seconds -> Seconds
days :: Seconds -> Seconds
instance Typeable Freezed
instance Show Freezed
instance Unit Time
instance Bounded (Time t)
instance Ord t => Orderable (Time t)
instance Ord t => Ring (Time t)
instance Ord t => Semiring (Time t)
instance Ord t => Monoid (Time t)
instance Ord t => Semigroup (Time t)
instance Ord t => Ord (Time t)
instance Ord t => Eq (Time t)
instance (Eq t, Show t) => Show (Time t)
instance Exception Freezed

module Data.Reactive

-- | An event (a list of time-value pairs of increasing times)
data Event t a
i'event :: Iso (Event t a) (Event t' b) (EventRep t a) (EventRep t' b)
headE :: Event t a -> a

-- | A reactive variable, consisting of an initial value and an Event of
--   changes
data Reactive t a
Reactive :: a -> (Event t a) -> Reactive t a
atTimes :: [t] -> Event t ()
mkEvent :: [(t, a)] -> Event t a
withTime :: Ord t => Event t a -> Event t (Time t, a)
times :: Ord t => Event t a -> Event t (Time t)
times' :: (Ord t, Monoid t) => Event t a -> Event t t
mapFutures :: (Future t a -> Future t' b) -> Event t a -> Event t' b

-- | The 'splice' operator. Occurs when <tt>a</tt> occurs.
--   
--   <pre>
--   by t: a // b = (a,before t: b)
--   </pre>
(//) :: Ord t => Event t a -> Event t b -> Event t (a, Event t b)
(<|*>) :: Ord t => Reactive t (a -> b) -> Event t a -> Event t b

-- | The 'over' operator. Occurs only when <tt>a</tt> occurs.
--   
--   <pre>
--   by t: a &lt;|*&gt; (bi,b) = a &lt;*&gt; (minBound,bi):b
--   </pre>
(<*|>) :: Ord t => Event t (a -> b) -> Reactive t a -> Event t b

-- | Group the occurences of an event by equality. Occurs when the first
--   occurence of a group occurs.
groupE :: (Eq a, Ord t) => Event t a -> Event t (Event t a)
mask :: Ord t => Event t Bool -> Event t a -> Event t a

-- | Sinks an action event into the Real World. Actions are evaluated as
--   closely to their specified time as possible. However, they are all
--   executed in order, even if it means delaying the next action further
--   than its required time. For real-time realization of events, see the
--   <a>realizeRT</a> function
realize :: Event Seconds (IO ()) -> IO ()

-- | Creates a real-time action event (an event that skips <a>frames</a> as
--   needed) from an ordinary event.
realtime :: Event Seconds (IO ()) -> Event Seconds (IO ())

-- | Sinks a frame event into the real-world, skipping frames if they come
--   too late, thus always performing the frame closest to the current
--   time.
realizeRT :: Event Seconds (IO ()) -> IO ()
eventMay :: IO (Maybe a) -> IO (Event Seconds a)
event :: IO a -> IO (Event Seconds a)
react :: IO a -> (Event Seconds a -> IO (Event Seconds (IO ()))) -> IO ()
react2 :: IO a -> IO b -> (Event Seconds a -> Event Seconds b -> IO (Event Seconds (IO ()))) -> IO ()
react3 :: IO a -> IO b -> IO c -> (Event Seconds a -> Event Seconds b -> Event Seconds c -> IO (Event Seconds (IO ()))) -> IO ()

-- | A Future value (a value with a timestamp)
data Future t a
i'future :: Iso (Future t a) (Future t' b) (Time t, a) (Time t', b)
l'time :: Lens (Time t) (Time t') (Future t a) (Future t' a)
l'value :: Lens a b (Future t a) (Future t b)
futureIO :: IO a -> IO (Future Seconds a)
instance Show a => Show (Many a)
instance Eq a => Eq (Many a)
instance Ord a => Ord (Many a)
instance (Eq t, Show t, Show a) => Show (Future t a)
instance Functor (Future t)
instance Ord t => Unit (Future t)
instance Ord t => Applicative (Future t)
instance Traversable (Future t)
instance Foldable (Future t)
instance Ord t => Monad (Future t)
instance (Ord t, Semigroup a) => Semigroup (Future t a)
instance (Ord t, Monoid a) => Monoid (Future t a)
instance Ord t => Unit (Event t)
instance Functor (Event t)
instance Ord t => Orderable (Future t a)
instance Ord t => Bounded (Future t a)
instance Ord t => Ord (Future t a)
instance Ord t => Eq (Future t a)
instance Ord t => Monad (Event t)
instance Ord t => Applicative (Event t)
instance Ord t => Monoid (Event t a)
instance Ord t => Semigroup (Event t a)
instance (Ord t, Show t, Show a) => Show (Event t a)
instance Stream (Future t a) (Event t a)
instance Ord t => Applicative (Reactive t)
instance Functor (Reactive t)
instance Ord t => Unit (Reactive t)
instance Ord t => Traversable (Event t)
instance Ord t => Foldable (Event t)
instance Lens1 a a (Many a) (Many a)
instance Stream a (Many a)
instance Functor Many
instance Unit Many
