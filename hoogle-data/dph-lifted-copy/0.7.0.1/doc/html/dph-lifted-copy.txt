-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data Parallel Haskell lifted array combinators. (deprecated version)
--   
--   Using this package can cause the vectorised program to have worse
--   asymptotic complexity than the original. Use dph-lifted-vseg instead.
--   This package provides the following: nested arrays and the primitive
--   operators that work on them (PA functions); the lifted array
--   combinators that the vectoriser introduces (PP functions); the user
--   facing library functions that work on [::] style arrays (P functions).
--   Deprecated implementation that performs deep copying replicate.
@package dph-lifted-copy
@version 0.7.0.1


-- | Parallel Arrays.
module Data.Array.Parallel.PArray

-- | Lifted/bulk parallel arrays This contains the array length, along with
--   the element data.
data PArray a

-- | A PA dictionary contains the functions that we use to convert a
--   representable type to and from its generic representation. The
--   conversion methods should all be O(1).
class PR (PRepr a) => PA a
class Random a
randoms :: (Random a, RandomGen g) => Int -> g -> PArray a
randomRs :: (Random a, RandomGen g) => Int -> (a, a) -> g -> PArray a

-- | Ensure an array is fully evaluated.
nf :: PA a => PArray a -> ()

-- | O(1). An empty array, with no elements.
empty :: PA a => PArray a

-- | O(1). Produce an array containing a single element.
singleton :: PA a => a -> PArray a

-- | O(n). Produce an array containing copies of a given element.
replicate :: PA a => Int -> a -> PArray a

-- | Append two arrays
(+:+) :: PA a => PArray a -> PArray a -> PArray a

-- | Concatenate an array of arrays into a single array.
concat :: PA a => PArray (PArray a) -> PArray a

-- | O(1). Create a nested array.
nestUSegd :: Segd -> PArray a -> PArray (PArray a)

-- | O(1). Yield the length of an array.
length :: PA a => PArray a -> Int

-- | O(1). Retrieve a numbered element from an array.
(!:) :: PA a => PArray a -> Int -> a

-- | Extract a subrange of elements from an array. The first argument is
--   the starting index, while the second is the length of the slice.
slice :: PA a => Int -> Int -> PArray a -> PArray a

-- | Copy the source array in the destination, using new values for the
--   given indices.
update :: PA a => PArray a -> PArray (Int, a) -> PArray a

-- | Select the elements of an array that have their tag set as True.
--   
--   <pre>
--   packPA [12, 24, 42, 93] [True, False, False, True]
--    = [24, 42]
--   </pre>
pack :: PA a => PArray a -> PArray Bool -> PArray a

-- | O(n). Backwards permutation of array elements.
--   
--   <pre>
--   bpermute [50, 60, 20, 30] [0, 3, 2]  = [50, 30, 20]
--   </pre>
bpermute :: PA a => PArray a -> PArray Int -> PArray a

-- | O(n). Generate a range of <tt>Int</tt>s.
enumFromTo :: Int -> Int -> PArray Int

-- | O(n). Tag each element of an array with its index.
--   
--   <pre>
--   indexed [42, 93, 13] = [(0, 42), (1, 93), (2, 13)]
--   </pre>
indexed :: PA a => PArray a -> PArray (Int, a)

-- | O(1). Takes two arrays and returns an array of corresponding pairs. If
--   one array is short, excess elements of the longer array are discarded.
zip :: (PA a, PA b) => PArray a -> PArray b -> PArray (a, b)

-- | O(1). Transform an array into an array of the first components, and an
--   array of the second components.
unzip :: (PA a, PA b) => PArray (a, b) -> (PArray a, PArray b)

-- | Create a <a>PArray</a> from a list.
fromList :: PA a => [a] -> PArray a

-- | Create a list from a <a>PArray</a>.
toList :: PA a => PArray a -> [a]

-- | Create a PArray out of a scalar U.Array, the first argument is the
--   array length.
--   
--   TODO: ditch this version, just use fromUArrPA'
fromUArray :: Scalar a => Array a -> PArray a

-- | Convert a PArray back to a plain U.Array.
toUArray :: Scalar a => PArray a -> Array a

-- | Convert an U.Array of pairs to a PArray.
fromUArray2 :: (Scalar a, Scalar b) => Array (a, b) -> PArray (a, b)

-- | Convert a U.Array of triples to a PArray.
fromUArray3 :: (Scalar a, Scalar b, Scalar c) => Array ((a, b), c) -> PArray (a, b, c)
instance Random Double
instance Random Int
instance (PA a, Show a) => Show (PArray a)

module Data.Array.Parallel.Lifted

-- | Lifted/bulk parallel arrays This contains the array length, along with
--   the element data.
data PArray a
PArray :: Int# -> (PData a) -> PArray a

-- | Parallel Data. This is the family of types that store parallel array
--   data.
--   
--   PData takes the type of an element and produces the type we use to
--   store an array of those elements. The instances for PData use an
--   efficient representation that depends on the type of elements being
--   stored. For example, an array of pairs is stored as two separate
--   arrays, one for each element type. This lets us avoid storing the
--   intermediate Pair/Tuple constructors and the pointers to the elements.
--   
--   Most of the instances are defined in
--   <a>Data.Array.Parallel.PArray.Instances</a>, though the instances for
--   function closures are defined in their own module,
--   <a>Data.Array.Parallel.Lifted.Closure</a>.
--   
--   Note that PData is just a flat chunk of memory containing elements,
--   and doesn't include a field giving the length of the array. We use
--   PArray when we want to pass around the array data along with its
--   length.

-- | A PA dictionary contains the functions that we use to convert a
--   representable type to and from its generic representation. The
--   conversion methods should all be O(1).
class PR (PRepr a) => PA a
toPRepr :: PA a => a -> PRepr a
fromPRepr :: PA a => PRepr a -> a
toArrPRepr :: PA a => PData a -> PData (PRepr a)
fromArrPRepr :: PA a => PData (PRepr a) -> PData a
toArrPReprs :: PA a => PDatas a -> PDatas (PRepr a)
fromArrPReprs :: PA a => PDatas (PRepr a) -> PDatas a

-- | Take the length field of a PArray.
lengthPA# :: PArray a -> Int#

-- | Take the data field of a PArray.
dataPA# :: PArray a -> PData a
replicatePA# :: PA a => Int# -> a -> PArray a
replicatelPA# :: PA a => Segd -> PArray a -> PArray a
repeatPA# :: PA a => Int# -> PArray a -> PArray a
emptyPA :: PA a => PArray a
indexPA# :: PA a => PArray a -> Int# -> a
extractPA# :: PA a => PArray a -> Int# -> Int# -> PArray a
bpermutePA# :: PA a => PArray a -> Int# -> Array Int -> PArray a
appPA# :: PA a => PArray a -> PArray a -> PArray a
applPA# :: PA a => Segd -> Segd -> PArray a -> Segd -> PArray a -> PArray a
packByTagPA# :: PA a => PArray a -> Int# -> Array Tag -> Int# -> PArray a
combine2PA# :: PA a => Int# -> Sel2 -> PArray a -> PArray a -> PArray a
updatePA# :: PA a => PArray a -> Array Int -> PArray a -> PArray a
fromListPA# :: PA a => Int# -> [a] -> PArray a
fromListPA :: PA a => [a] -> PArray a
nfPA :: PA a => PArray a -> ()
replicatePD :: PA a => T_replicatePR a
replicatelPD :: PA a => T_replicatelPR a
repeatPD :: PA a => T_repeatPR a
emptyPD :: PA a => T_emptyPR a
indexPD :: PA a => T_indexPR a
extractPD :: PA a => T_extractPR a
bpermutePD :: PA a => T_bpermutePR a
appPD :: PA a => T_appPR a
applPD :: PA a => T_applPR a
packByTagPD :: PA a => T_packByTagPR a
combine2PD :: PA a => T_combine2PR a
updatePD :: PA a => T_updatePR a
fromListPD :: PA a => T_fromListPR a
nfPD :: PA a => T_nfPR a

-- | Representable types.
--   
--   The family of types that we know how to represent generically. PRepr
--   takes an arbitrary type and produces the generic type we use to
--   represent it.
--   
--   Instances for simple types are defined in
--   Data.Array.Parallel.Lifted.Instances. For algebraic types, it's up to
--   the vectoriser/client module to create a suitable instance.

-- | A PR dictionary contains the primitive functions that operate directly
--   on parallel array data.
--   
--   It's called PR because the functions work on our internal, efficient
--   Representation of the user-level array.
class PR a
emptyPR :: PR a => T_emptyPR a
replicatePR :: PR a => T_replicatePR a
replicatelPR :: PR a => T_replicatelPR a
repeatPR :: PR a => T_repeatPR a
indexPR :: PR a => T_indexPR a
extractPR :: PR a => T_extractPR a
bpermutePR :: PR a => T_bpermutePR a
appPR :: PR a => T_appPR a
applPR :: PR a => T_applPR a
packByTagPR :: PR a => T_packByTagPR a
combine2PR :: PR a => T_combine2PR a
updatePR :: PR a => T_updatePR a
fromListPR :: PR a => T_fromListPR a
nfPR :: PR a => T_nfPR a

-- | Class of scalar types. Scalar types are the ones that we can store in
--   our underlying U.Arrays (which are currently implemented as
--   Data.Vectors).
--   
--   To perform an operation on a PData array of scalar elements, we coerce
--   it to the underling U.Array and use the corresponding U.Array
--   operators.
class Elt a => Scalar a
fromScalarPData :: Scalar a => PData a -> Array a
toScalarPData :: Scalar a => Array a -> PData a
replicatePRScalar :: Scalar a => T_replicatePR a
replicatelPRScalar :: Scalar a => T_replicatelPR a
repeatPRScalar :: Scalar a => T_repeatPR a
emptyPRScalar :: Scalar a => T_emptyPR a
indexPRScalar :: Scalar a => T_indexPR a
extractPRScalar :: Scalar a => T_extractPR a
bpermutePRScalar :: Scalar a => T_bpermutePR a
appPRScalar :: Scalar a => T_appPR a
applPRScalar :: Scalar a => T_applPR a
packByTagPRScalar :: Scalar a => T_packByTagPR a
combine2PRScalar :: Scalar a => T_combine2PR a
updatePRScalar :: Scalar a => T_updatePR a
fromListPRScalar :: Scalar a => T_fromListPR a
nfPRScalar :: Scalar a => T_nfPR a

-- | The type of closures. This bundles up: 1) the vectorised version of
--   the function that takes an explicit environment 2) the lifted version,
--   that works on arrays. the first parameter of this function is the
--   'lifting context' that gives the length of the array. 3) the
--   environment of the closure.
--   
--   The vectoriser closure-converts the source program so that all
--   functions types are expressed in this form.
data (:->) a b

-- | Apply a closure to its argument.
($:) :: (a :-> b) -> a -> b

-- | Lifted closure application
($:^) :: PArray (a :-> b) -> PArray a -> PArray b
fromPArrayPA :: PA a => PArray a :-> PArray a
toPArrayPA :: PA a => PArray a :-> PArray a
fromNestedPArrayPA :: PA a => (PArray (PArray a) :-> PArray (PArray a))

module Data.Array.Parallel.Prelude.Bool
data Bool :: *
False :: Bool
True :: Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool

-- | Boolean "not"
not :: Bool -> Bool
andP :: PArr Bool -> Bool
orP :: PArr Bool -> Bool
fromBool :: Bool -> Int
toBool :: Int -> Bool

module Data.Array.Parallel.Prelude.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *
(==) :: Int -> Int -> Bool
(/=) :: Int -> Int -> Bool
(<) :: Int -> Int -> Bool
(<=) :: Int -> Int -> Bool
(>) :: Int -> Int -> Bool
(>=) :: Int -> Int -> Bool
min :: Int -> Int -> Int
max :: Int -> Int -> Int
minimumP :: PArr Int -> Int
maximumP :: PArr Int -> Int
minIndexP :: PArr Int -> Int
maxIndexP :: PArr Int -> Int
(+) :: Int -> Int -> Int
(-) :: Int -> Int -> Int
(*) :: Int -> Int -> Int
negate :: Int -> Int
abs :: Int -> Int
sumP :: PArr Int -> Int
productP :: PArr Int -> Int
div :: Int -> Int -> Int
mod :: Int -> Int -> Int
sqrt :: Int -> Int
enumFromToP :: Int -> Int -> PArr Int

module Data.Array.Parallel.Prelude.Word8

-- | 8-bit unsigned integer type
data Word8 :: *
(==) :: Word8 -> Word8 -> Bool
(/=) :: Word8 -> Word8 -> Bool
(<) :: Word8 -> Word8 -> Bool
(<=) :: Word8 -> Word8 -> Bool
(>) :: Word8 -> Word8 -> Bool
(>=) :: Word8 -> Word8 -> Bool
min :: Word8 -> Word8 -> Word8
max :: Word8 -> Word8 -> Word8
minimumP :: PArr Word8 -> Word8
maximumP :: PArr Word8 -> Word8
minIndexP :: PArr Word8 -> Int
maxIndexP :: PArr Word8 -> Int
(+) :: Word8 -> Word8 -> Word8
(-) :: Word8 -> Word8 -> Word8
(*) :: Word8 -> Word8 -> Word8
negate :: Word8 -> Word8
abs :: Word8 -> Word8
sumP :: PArr Word8 -> Word8
productP :: PArr Word8 -> Word8
div :: Word8 -> Word8 -> Word8
mod :: Word8 -> Word8 -> Word8
sqrt :: Word8 -> Word8
toInt :: Word8 -> Int
fromInt :: Int -> Word8

module Data.Array.Parallel.Prelude.Float

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *
(==) :: Float -> Float -> Bool
(/=) :: Float -> Float -> Bool
(<) :: Float -> Float -> Bool
(<=) :: Float -> Float -> Bool
(>) :: Float -> Float -> Bool
(>=) :: Float -> Float -> Bool
min :: Float -> Float -> Float
max :: Float -> Float -> Float
minimumP :: PArr Float -> Float
maximumP :: PArr Float -> Float
minIndexP :: PArr Float -> Int
maxIndexP :: PArr Float -> Int
(+) :: Float -> Float -> Float
(-) :: Float -> Float -> Float
(*) :: Float -> Float -> Float
negate :: Float -> Float
abs :: Float -> Float
sumP :: PArr Float -> Float
productP :: PArr Float -> Float
(/) :: Float -> Float -> Float
recip :: Float -> Float
pi :: Float
exp :: Float -> Float
sqrt :: Float -> Float
log :: Float -> Float
(**) :: Float -> Float -> Float
logBase :: Float -> Float -> Float
sin :: Float -> Float
tan :: Float -> Float
cos :: Float -> Float
asin :: Float -> Float
atan :: Float -> Float
acos :: Float -> Float
sinh :: Float -> Float
tanh :: Float -> Float
cosh :: Float -> Float
asinh :: Float -> Float
atanh :: Float -> Float
acosh :: Float -> Float
fromInt :: Int -> Float
truncate :: Float -> Int
round :: Float -> Int
ceiling :: Float -> Int
floor :: Float -> Int

module Data.Array.Parallel.Prelude.Double

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
(==) :: Double -> Double -> Bool
(/=) :: Double -> Double -> Bool
(<) :: Double -> Double -> Bool
(<=) :: Double -> Double -> Bool
(>) :: Double -> Double -> Bool
(>=) :: Double -> Double -> Bool
min :: Double -> Double -> Double
max :: Double -> Double -> Double
minimumP :: PArr Double -> Double
maximumP :: PArr Double -> Double
minIndexP :: PArr Double -> Int
maxIndexP :: PArr Double -> Int
(+) :: Double -> Double -> Double
(-) :: Double -> Double -> Double
(*) :: Double -> Double -> Double
negate :: Double -> Double
abs :: Double -> Double
sumP :: PArr Double -> Double
productP :: PArr Double -> Double
(/) :: Double -> Double -> Double
recip :: Double -> Double
pi :: Double
exp :: Double -> Double
sqrt :: Double -> Double
log :: Double -> Double
(**) :: Double -> Double -> Double
logBase :: Double -> Double -> Double
sin :: Double -> Double
tan :: Double -> Double
cos :: Double -> Double
asin :: Double -> Double
atan :: Double -> Double
acos :: Double -> Double
sinh :: Double -> Double
tanh :: Double -> Double
cosh :: Double -> Double
asinh :: Double -> Double
atanh :: Double -> Double
acosh :: Double -> Double
fromInt :: Int -> Double
truncate :: Double -> Int
round :: Double -> Int
ceiling :: Double -> Int
floor :: Double -> Int


-- | This modules bundles all vectorised versions of Prelude definitions.
--   
--   <i>This module should not be explicitly imported in user code
--   anymore.</i> User code should only import <a>Parallel</a> and, until
--   the vectoriser supports type classes, the type-specific modules
--   <a>*</a>.
module Data.Array.Parallel.Prelude
type PArr = [::]
data Bool :: *

-- | 8-bit unsigned integer type
data Word8 :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *


-- | User level interface of parallel arrays.
--   
--   This library is deprecated. Using it can result in the vectorised
--   program having asymptotically worse complexity than the original. Your
--   program could be 10000x slower than it should be with this library.
--   
--   Use the <tt>dph-lifted-vseg</tt> package instead.
module Data.Array.Parallel
emptyP :: [:a:]
singletonP :: a -> [:a:]
replicateP :: Int -> a -> [:a:]
lengthP :: [:a:] -> Int
(!:) :: [:a:] -> Int -> a
(+:+) :: [:a:] -> [:a:] -> [:a:]
concatP :: [:[:a:]:] -> [:a:]
mapP :: (a -> b) -> [:a:] -> [:b:]
filterP :: (a -> Bool) -> [:a:] -> [:a:]
combineP :: [:a:] -> [:a:] -> [:Int:] -> [:a:]
zipP :: [:a:] -> [:b:] -> [:(a, b):]
zip3P :: [:a:] -> [:b:] -> [:c:] -> [:(a, b, c):]
unzipP :: [:(a, b):] -> ([:a:], [:b:])
unzip3P :: [:(a, b, c):] -> ([:a:], [:b:], [:c:])
zipWithP :: (a -> b -> c) -> [:a:] -> [:b:] -> [:c:]
zipWith3P :: (a -> b -> c -> d) -> [:a:] -> [:b:] -> [:c:] -> [:d:]
bpermuteP :: [:a:] -> [:Int:] -> [:a:]
updateP :: [:a:] -> [:(Int, a):] -> [:a:]
indexedP :: [:a:] -> [:(Int, a):]
sliceP :: Int -> Int -> [:e:] -> [:e:]
crossMapP :: [:a:] -> (a -> [:b:]) -> [:(a, b):]

-- | Lifted/bulk parallel arrays This contains the array length, along with
--   the element data.
data PArray a
fromPArrayP :: PArray a -> [:a:]
toPArrayP :: [:a:] -> PArray a
fromNestedPArrayP :: PArray (PArray a) -> [:[:a:]:]
