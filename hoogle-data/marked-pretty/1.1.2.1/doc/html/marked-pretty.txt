-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty-printing library, with scoping, based on pretty.
--   
@package marked-pretty
@version 1.1.2.1


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   Originally designed by John Hughes's and Simon Peyton Jones's.
--   
--   Marking added by Andy Gill, Oct 08.
--   
--   For more information you can refer to the <a>original paper</a> that
--   serves as the basis for this libraries design: <i>The Design -- of a
--   Pretty-printing Library</i> by John Hughes, in Advanced Functional
--   Programming, 1995
module Text.PrettyPrint.MarkedHughesPJ
type Doc = MDoc ()

-- | The abstract type of documents. An MDoc represents a *set* of layouts.
--   A MDoc with no occurrences of Union or NoDoc represents just one
--   layout.
data MDoc a

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails a

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails a

-- | A whole String fragment
Str :: String -> TextDetails a

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails a
Mark :: a -> TextDetails a

-- | A document of height and width 1, containing a literal character.
char :: Char -> MDoc a

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> MDoc a

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> MDoc a

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> MDoc a

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> MDoc a
int :: Int -> MDoc a
integer :: Integer -> MDoc a
float :: Float -> MDoc a
double :: Double -> MDoc a
rational :: Rational -> MDoc a
semi :: MDoc a
comma :: MDoc a
colon :: MDoc a
space :: MDoc a
equals :: MDoc a
lparen :: MDoc a
rparen :: MDoc a
lbrack :: MDoc a
rbrack :: MDoc a
lbrace :: MDoc a
rbrace :: MDoc a
parens :: MDoc a -> MDoc a
brackets :: MDoc a -> MDoc a
braces :: MDoc a -> MDoc a
quotes :: MDoc a -> MDoc a
doubleQuotes :: MDoc a -> MDoc a

-- | Apply <a>parens</a> to <a>MDoc</a> if boolean is true.
maybeParens :: Bool -> MDoc a -> MDoc a

-- | Apply <a>brackets</a> to <a>MDoc</a> if boolean is true.
maybeBrackets :: Bool -> MDoc a -> MDoc a

-- | Apply <a>braces</a> to <a>MDoc</a> if boolean is true.
maybeBraces :: Bool -> MDoc a -> MDoc a

-- | Apply <a>quotes</a> to <a>MDoc</a> if boolean is true.
maybeQuotes :: Bool -> MDoc a -> MDoc a

-- | Apply <a>doubleQuotes</a> to <a>MDoc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> MDoc a -> MDoc a

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: MDoc a

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: MDoc a -> MDoc a -> MDoc a

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: MDoc a -> MDoc a -> MDoc a

-- | List version of <a>&lt;&gt;</a>.
hcat :: [MDoc a] -> MDoc a

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [MDoc a] -> MDoc a

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: MDoc a -> MDoc a -> MDoc a

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: MDoc a -> MDoc a -> MDoc a

-- | List version of <a>$$</a>.
vcat :: [MDoc a] -> MDoc a

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [MDoc a] -> MDoc a

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [MDoc a] -> MDoc a

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [MDoc a] -> MDoc a

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [MDoc a] -> MDoc a

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> MDoc a -> MDoc a

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: MDoc a -> Int -> MDoc a -> MDoc a

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: MDoc a -> [MDoc a] -> [MDoc a]

-- | Returns <a>True</a> if the document is empty
isEmpty :: MDoc a -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: MDoc a -> MDoc a -> MDoc a

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: MDoc a -> RDoc a

-- | Render the <tt>MDoc</tt> to a String using the default <tt>Style</tt>.
render :: MDoc a -> String

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
mode :: Style -> Mode

-- | Length of line, in chars
lineLength :: Style -> Int

-- | Ratio of line length to ribbon length
ribbonsPerLine :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>MDoc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> MDoc a -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails b -> a -> a) -> a -> MDoc b -> a

-- | mark inserts a zero width mark into the output document
mark :: a -> MDoc a
instance [safe] Show a => Show (TextDetails a)
instance [safe] Eq a => Eq (TextDetails a)
instance [safe] Generic (TextDetails a)
instance [safe] Generic (MDoc a)
instance [safe] Show Mode
instance [safe] Eq Mode
instance [safe] Generic Mode
instance [safe] Show Style
instance [safe] Eq Style
instance [safe] Generic Style
instance [safe] Datatype D1TextDetails
instance [safe] Constructor C1_0TextDetails
instance [safe] Constructor C1_1TextDetails
instance [safe] Constructor C1_2TextDetails
instance [safe] Constructor C1_3TextDetails
instance [safe] Datatype D1MDoc
instance [safe] Constructor C1_0MDoc
instance [safe] Constructor C1_1MDoc
instance [safe] Constructor C1_2MDoc
instance [safe] Constructor C1_3MDoc
instance [safe] Constructor C1_4MDoc
instance [safe] Constructor C1_5MDoc
instance [safe] Constructor C1_6MDoc
instance [safe] Constructor C1_7MDoc
instance [safe] Datatype D1Mode
instance [safe] Constructor C1_0Mode
instance [safe] Constructor C1_1Mode
instance [safe] Constructor C1_2Mode
instance [safe] Constructor C1_3Mode
instance [safe] Datatype D1Style
instance [safe] Constructor C1_0Style
instance [safe] Selector S1_0_0Style
instance [safe] Selector S1_0_1Style
instance [safe] Selector S1_0_2Style
instance [safe] NFData a => NFData (TextDetails a)
instance [safe] NFData a => NFData (MDoc a)
instance [safe] Eq (MDoc a)
instance [safe] Show (MDoc a)
instance [safe] IsString (MDoc a)
instance [safe] Monoid (MDoc a)


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.MarkedHughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a where pPrintPrec _ _ = pPrint pPrint = pPrintPrec prettyNormal 0 pPrintList l = brackets . fsep . punctuate comma . map (pPrintPrec l 0)
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> MDoc b
pPrint :: Pretty a => a -> MDoc b
pPrintList :: Pretty a => PrettyLevel -> [a] -> MDoc b

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> MDoc a -> MDoc a
instance [safe] Eq PrettyLevel
instance [safe] Ord PrettyLevel
instance [safe] Show PrettyLevel
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h) => Pretty (a, b, c, d, e, f, g, h)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g) => Pretty (a, b, c, d, e, f, g)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f) => Pretty (a, b, c, d, e, f)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance [safe] (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance [safe] (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance [safe] (Pretty a, Pretty b) => Pretty (a, b)
instance [safe] Pretty a => Pretty [a]
instance [safe] (Pretty a, Pretty b) => Pretty (Either a b)
instance [safe] Pretty a => Pretty (Maybe a)
instance [safe] Pretty Char
instance [safe] Pretty Ordering
instance [safe] Pretty Bool
instance [safe] Pretty ()
instance [safe] Pretty Double
instance [safe] Pretty Float
instance [safe] Pretty Integer
instance [safe] Pretty Int
