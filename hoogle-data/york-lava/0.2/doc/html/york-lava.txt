-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for digital circuit description.
--   
--   York Lava is library for describing digital circuits. Descriptions can
--   be simulated in Hugs or GHC, and converted to VHDL compatible with
--   XST, the Xilinx Synthesis Tool. It is similar to Chalmers Lava, but
--   omits some features and offers a few new ones. See the top-level
--   module <a>Lava</a> for pointers to futher information.
@package york-lava
@version 0.2


-- | A very modest library for join-lists, also known as conc-lists.
module Lava.JList
data JList a
Zero :: JList a
One :: a -> JList a
(:+:) :: JList a -> JList a -> JList a
fromList :: [a] -> JList a
toList :: JList a -> [a]
map :: (a -> b) -> JList a -> JList b
mapM :: Monad m => (a -> m b) -> JList a -> m (JList b)
concat :: JList (JList a) -> JList a
zipWith :: (a -> b -> c) -> JList a -> JList b -> JList c
lazyZipWith :: (a -> b -> c) -> JList a -> JList b -> JList c
instance Show a => Show (JList a)
instance Eq a => Eq (JList a)
instance Monad JList
instance Functor JList

module Lava.Binary
binToNat :: Integral a => [Bool] -> a
natToBin :: Integral a => a -> [Bool]
binToHex :: [Bool] -> String
natToHex :: Integral a => a -> String
hex :: Integral a => Int -> a -> String
ext :: Int -> a -> [a] -> [a]
natToSizedBin :: Integral a => a -> Int -> [Bool]
twosComplement :: [Bool] -> [Bool]
boolAdd :: Bool -> [Bool] -> [Bool]
intToBin :: Integral a => a -> [Bool]
intToSizedBin :: Integral a => a -> Int -> [Bool]
binToInt :: Integral a => [Bool] -> a
log2 :: Integral a => a -> a
rol :: [a] -> Int -> [a]
ror :: [a] -> Int -> [a]


-- | Modest library for statically-typed sized vectors, inspired by Oleg
--   Kiselyov's "Number-Parameterized Types", The Monad.Reader, Issue 5.
--   Type synonyms <a>N0</a> to <a>N255</a> exported along with zero
--   (<a>Z</a>) and successor (<a>S</a>). Values <a>n0</a> to <a>n255</a>
--   with types <a>N0</a> to <a>N255</a> are also exported.
module Lava.Vector
vempty :: Vec Z a
(+>) :: a -> Vec n a -> Vec (S n) a
(<+) :: Vec n a -> a -> Vec (S n) a
velems :: Vec n a -> [a]
vsize :: Vec n a -> n
sized :: N n => (Int -> Vec n a) -> Vec n a
vec :: N n => [a] -> Vec n a
vecOf :: N n => a -> Vec n a
ofSize :: Vec n a -> n -> Vec n a
sameSize :: Vec n a -> Vec n a -> Vec n a
vecn :: N n => n -> [a] -> Vec n a
vextend :: N m => a -> Vec n a -> Vec m a
vsingle :: a -> Vec N1 a
vhead :: Vec (S n) a -> a
vtail :: Vec (S n) a -> Vec n a
vlast :: Vec (S n) a -> a
vinit :: Vec (S n) a -> Vec n a
vlength :: Vec n a -> Int
vmap :: (a -> b) -> Vec n a -> Vec n b
vzipWith :: (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
vreverse :: Vec n a -> Vec n a
vfoldl :: (a -> b -> a) -> a -> Vec n b -> a
vfoldr :: (a -> b -> b) -> b -> Vec n a -> b
vmapAccumL :: (a -> b -> (a, c)) -> a -> Vec n b -> (a, Vec n c)
vmapAccumR :: (a -> b -> (a, c)) -> a -> Vec n b -> (a, Vec n c)
(<++>) :: Add n m o => Vec n a -> Vec m a -> Vec o a
vconcat :: Mul n m o => Vec n (Vec m a) -> Vec o a
vat :: (N n, Less n m) => Vec m a -> n -> a
vtake :: N n => n -> Vec m a -> Vec n a
vdrop :: (N n, Add n o m) => n -> Vec m a -> Vec o a
vsplitAt :: (N m, Add m n o) => m -> Vec o a -> (Vec m a, Vec n a)
vgroup :: (N n, Mul n o m) => n -> Vec m a -> Vec o (Vec n a)
vtranspose :: Vec n (Vec m a) -> Vec m (Vec n a)
vshr :: a -> Vec n a -> Vec n a
vshl :: Vec n a -> a -> Vec n a
vreplicate :: N n => n -> a -> Vec n a
vrepeat :: N n => a -> Vec n a
vsequence :: Monad m => Vec n (m a) -> m (Vec n a)
vrigid :: N n => Vec n a -> Vec n a
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
type N11 = S N10
type N12 = S N11
type N13 = S N12
type N14 = S N13
type N15 = S N14
type N16 = S N15
type N17 = S N16
type N18 = S N17
type N19 = S N18
type N20 = S N19
type N21 = S N20
type N22 = S N21
type N23 = S N22
type N24 = S N23
type N25 = S N24
type N26 = S N25
type N27 = S N26
type N28 = S N27
type N29 = S N28
type N30 = S N29
type N31 = S N30
type N32 = S N31
type N33 = S N32
type N34 = S N33
type N35 = S N34
type N36 = S N35
type N37 = S N36
type N38 = S N37
type N39 = S N38
type N40 = S N39
type N41 = S N40
type N42 = S N41
type N43 = S N42
type N44 = S N43
type N45 = S N44
type N46 = S N45
type N47 = S N46
type N48 = S N47
type N49 = S N48
type N50 = S N49
type N51 = S N50
type N52 = S N51
type N53 = S N52
type N54 = S N53
type N55 = S N54
type N56 = S N55
type N57 = S N56
type N58 = S N57
type N59 = S N58
type N60 = S N59
type N61 = S N60
type N62 = S N61
type N63 = S N62
type N64 = S N63
type N65 = S N64
type N66 = S N65
type N67 = S N66
type N68 = S N67
type N69 = S N68
type N70 = S N69
type N71 = S N70
type N72 = S N71
type N73 = S N72
type N74 = S N73
type N75 = S N74
type N76 = S N75
type N77 = S N76
type N78 = S N77
type N79 = S N78
type N80 = S N79
type N81 = S N80
type N82 = S N81
type N83 = S N82
type N84 = S N83
type N85 = S N84
type N86 = S N85
type N87 = S N86
type N88 = S N87
type N89 = S N88
type N90 = S N89
type N91 = S N90
type N92 = S N91
type N93 = S N92
type N94 = S N93
type N95 = S N94
type N96 = S N95
type N97 = S N96
type N98 = S N97
type N99 = S N98
type N100 = S N99
type N101 = S N100
type N102 = S N101
type N103 = S N102
type N104 = S N103
type N105 = S N104
type N106 = S N105
type N107 = S N106
type N108 = S N107
type N109 = S N108
type N110 = S N109
type N111 = S N110
type N112 = S N111
type N113 = S N112
type N114 = S N113
type N115 = S N114
type N116 = S N115
type N117 = S N116
type N118 = S N117
type N119 = S N118
type N120 = S N119
type N121 = S N120
type N122 = S N121
type N123 = S N122
type N124 = S N123
type N125 = S N124
type N126 = S N125
type N127 = S N126
type N128 = S N127
type N129 = S N128
type N130 = S N129
type N131 = S N130
type N132 = S N131
type N133 = S N132
type N134 = S N133
type N135 = S N134
type N136 = S N135
type N137 = S N136
type N138 = S N137
type N139 = S N138
type N140 = S N139
type N141 = S N140
type N142 = S N141
type N143 = S N142
type N144 = S N143
type N145 = S N144
type N146 = S N145
type N147 = S N146
type N148 = S N147
type N149 = S N148
type N150 = S N149
type N151 = S N150
type N152 = S N151
type N153 = S N152
type N154 = S N153
type N155 = S N154
type N156 = S N155
type N157 = S N156
type N158 = S N157
type N159 = S N158
type N160 = S N159
type N161 = S N160
type N162 = S N161
type N163 = S N162
type N164 = S N163
type N165 = S N164
type N166 = S N165
type N167 = S N166
type N168 = S N167
type N169 = S N168
type N170 = S N169
type N171 = S N170
type N172 = S N171
type N173 = S N172
type N174 = S N173
type N175 = S N174
type N176 = S N175
type N177 = S N176
type N178 = S N177
type N179 = S N178
type N180 = S N179
type N181 = S N180
type N182 = S N181
type N183 = S N182
type N184 = S N183
type N185 = S N184
type N186 = S N185
type N187 = S N186
type N188 = S N187
type N189 = S N188
type N190 = S N189
type N191 = S N190
type N192 = S N191
type N193 = S N192
type N194 = S N193
type N195 = S N194
type N196 = S N195
type N197 = S N196
type N198 = S N197
type N199 = S N198
type N200 = S N199
type N201 = S N200
type N202 = S N201
type N203 = S N202
type N204 = S N203
type N205 = S N204
type N206 = S N205
type N207 = S N206
type N208 = S N207
type N209 = S N208
type N210 = S N209
type N211 = S N210
type N212 = S N211
type N213 = S N212
type N214 = S N213
type N215 = S N214
type N216 = S N215
type N217 = S N216
type N218 = S N217
type N219 = S N218
type N220 = S N219
type N221 = S N220
type N222 = S N221
type N223 = S N222
type N224 = S N223
type N225 = S N224
type N226 = S N225
type N227 = S N226
type N228 = S N227
type N229 = S N228
type N230 = S N229
type N231 = S N230
type N232 = S N231
type N233 = S N232
type N234 = S N233
type N235 = S N234
type N236 = S N235
type N237 = S N236
type N238 = S N237
type N239 = S N238
type N240 = S N239
type N241 = S N240
type N242 = S N241
type N243 = S N242
type N244 = S N243
type N245 = S N244
type N246 = S N245
type N247 = S N246
type N248 = S N247
type N249 = S N248
type N250 = S N249
type N251 = S N250
type N252 = S N251
type N253 = S N252
type N254 = S N253
type N255 = S N254
n0 :: N0
n1 :: N1
n2 :: N2
n3 :: N3
n4 :: N4
n5 :: N5
n6 :: N6
n7 :: N7
n8 :: N8
n9 :: N9
n10 :: N10
n11 :: N11
n12 :: N12
n13 :: N13
n14 :: N14
n15 :: N15
n16 :: N16
n17 :: N17
n18 :: N18
n19 :: N19
n20 :: N20
n21 :: N21
n22 :: N22
n23 :: N23
n24 :: N24
n25 :: N25
n26 :: N26
n27 :: N27
n28 :: N28
n29 :: N29
n30 :: N30
n31 :: N31
n32 :: N32
n33 :: N33
n34 :: N34
n35 :: N35
n36 :: N36
n37 :: N37
n38 :: N38
n39 :: N39
n40 :: N40
n41 :: N41
n42 :: N42
n43 :: N43
n44 :: N44
n45 :: N45
n46 :: N46
n47 :: N47
n48 :: N48
n49 :: N49
n50 :: N50
n51 :: N51
n52 :: N52
n53 :: N53
n54 :: N54
n55 :: N55
n56 :: N56
n57 :: N57
n58 :: N58
n59 :: N59
n60 :: N60
n61 :: N61
n62 :: N62
n63 :: N63
n64 :: N64
n65 :: N65
n66 :: N66
n67 :: N67
n68 :: N68
n69 :: N69
n70 :: N70
n71 :: N71
n72 :: N72
n73 :: N73
n74 :: N74
n75 :: N75
n76 :: N76
n77 :: N77
n78 :: N78
n79 :: N79
n80 :: N80
n81 :: N81
n82 :: N82
n83 :: N83
n84 :: N84
n85 :: N85
n86 :: N86
n87 :: N87
n88 :: N88
n89 :: N89
n90 :: N90
n91 :: N91
n92 :: N92
n93 :: N93
n94 :: N94
n95 :: N95
n96 :: N96
n97 :: N97
n98 :: N98
n99 :: N99
n100 :: N100
n101 :: N101
n102 :: N102
n103 :: N103
n104 :: N104
n105 :: N105
n106 :: N106
n107 :: N107
n108 :: N108
n109 :: N109
n110 :: N110
n111 :: N111
n112 :: N112
n113 :: N113
n114 :: N114
n115 :: N115
n116 :: N116
n117 :: N117
n118 :: N118
n119 :: N119
n120 :: N120
n121 :: N121
n122 :: N122
n123 :: N123
n124 :: N124
n125 :: N125
n126 :: N126
n127 :: N127
n128 :: N128
n129 :: N129
n130 :: N130
n131 :: N131
n132 :: N132
n133 :: N133
n134 :: N134
n135 :: N135
n136 :: N136
n137 :: N137
n138 :: N138
n139 :: N139
n140 :: N140
n141 :: N141
n142 :: N142
n143 :: N143
n144 :: N144
n145 :: N145
n146 :: N146
n147 :: N147
n148 :: N148
n149 :: N149
n150 :: N150
n151 :: N151
n152 :: N152
n153 :: N153
n154 :: N154
n155 :: N155
n156 :: N156
n157 :: N157
n158 :: N158
n159 :: N159
n160 :: N160
n161 :: N161
n162 :: N162
n163 :: N163
n164 :: N164
n165 :: N165
n166 :: N166
n167 :: N167
n168 :: N168
n169 :: N169
n170 :: N170
n171 :: N171
n172 :: N172
n173 :: N173
n174 :: N174
n175 :: N175
n176 :: N176
n177 :: N177
n178 :: N178
n179 :: N179
n180 :: N180
n181 :: N181
n182 :: N182
n183 :: N183
n184 :: N184
n185 :: N185
n186 :: N186
n187 :: N187
n188 :: N188
n189 :: N189
n190 :: N190
n191 :: N191
n192 :: N192
n193 :: N193
n194 :: N194
n195 :: N195
n196 :: N196
n197 :: N197
n198 :: N198
n199 :: N199
n200 :: N200
n201 :: N201
n202 :: N202
n203 :: N203
n204 :: N204
n205 :: N205
n206 :: N206
n207 :: N207
n208 :: N208
n209 :: N209
n210 :: N210
n211 :: N211
n212 :: N212
n213 :: N213
n214 :: N214
n215 :: N215
n216 :: N216
n217 :: N217
n218 :: N218
n219 :: N219
n220 :: N220
n221 :: N221
n222 :: N222
n223 :: N223
n224 :: N224
n225 :: N225
n226 :: N226
n227 :: N227
n228 :: N228
n229 :: N229
n230 :: N230
n231 :: N231
n232 :: N232
n233 :: N233
n234 :: N234
n235 :: N235
n236 :: N236
n237 :: N237
n238 :: N238
n239 :: N239
n240 :: N240
n241 :: N241
n242 :: N242
n243 :: N243
n244 :: N244
n245 :: N245
n246 :: N246
n247 :: N247
n248 :: N248
n249 :: N249
n250 :: N250
n251 :: N251
n252 :: N252
n253 :: N253
n254 :: N254
n255 :: N255
data Z
data S a
newtype Vec n a
Vec :: [a] -> Vec n a
class N a
value :: N a => a -> Int
class Add a b c | a b -> c
class Mul a b c | a b -> c
class Less a b
instance Show a => Show (Vec n a)
instance Functor (Vec n)
instance (Mul a b x, Add x b c) => Mul (S a) b c
instance Mul Z b Z
instance Add a b c => Add (S a) b (S c)
instance Add Z b b
instance Less a b => Less (S a) (S b)
instance Less Z (S a)
instance N a => N (S a)
instance N Z


-- | Defines what a <a>Bit</a> is, the central abstract data type of the
--   whole library, along with lots of things you might like to do with
--   bits.
--   
--   See <tt>REDUCERON MEMO 23</tt> - included in the package and available
--   at <a>http://www.cs.york.ac.uk/fp/reduceron/</a> - for a tutorial.
module Lava.Bit

-- | The central ADT of Lava.
data Bit

-- | Logic '0'.
low :: Bit

-- | Logic '1'.
high :: Bit

-- | Inverter.
inv :: Bit -> Bit

-- | D-type flip-flop, with initialiser (first argument).
delayBit :: Bit -> Bit -> Bit

-- | D-type flip-flop with input-enable (first argument).
delayBitEn :: Bit -> Bit -> Bit -> Bit

-- | AND gate.
and2 :: (Bit, Bit) -> Bit
(<&>) :: Bit -> Bit -> Bit

-- | OR gate.
or2 :: (Bit, Bit) -> Bit
(<|>) :: Bit -> Bit -> Bit

-- | XOR gate.
xor2 :: (Bit, Bit) -> Bit
(<#>) :: Bit -> Bit -> Bit

-- | XOR gate, specifically a <i>Xilinx Carry Logic</i> XOR gate.
xorcy :: (Bit, Bit) -> Bit

-- | EQ gate.
eq2 :: (Bit, Bit) -> Bit
(<=>) :: Bit -> Bit -> Bit

-- | Bit multiplexer.
muxBit :: Bit -> Bit -> Bit -> Bit

-- | Bit multiplexer - specifically a <i>Xilinx Carry Logic</i> bit
--   multiplexer.
muxcy :: Bit -> (Bit, Bit) -> Bit

-- | Named input - for synthesis.
name :: String -> Bit

-- | Block RAM inputs; data-bus and address-bus can be of any width! Use
--   <tt>Lava.Prelude.RamInputs</tt> for stronger type-safety.
data RamInps
RamInps :: [Bit] -> [Bit] -> Bit -> RamInps
dataBus :: RamInps -> [Bit]
addressBus :: RamInps -> [Bit]
writeEnable :: RamInps -> Bit

-- | How should the RAM be built? Used by the Xilinx Core Generator - see
--   Xilinx docs for details.
data RamAlgorithm
MinArea :: RamAlgorithm
Width1 :: RamAlgorithm
Width2 :: RamAlgorithm
Width4 :: RamAlgorithm
Width9 :: RamAlgorithm
Width18 :: RamAlgorithm
Width36 :: RamAlgorithm

-- | Single-port RAM with initialiser. Use <tt>Lava.Prelude.ram</tt> for
--   stronger type-safety.
primRam :: [Integer] -> RamAlgorithm -> RamInps -> [Bit]

-- | Dual-port RAM with initialiser. Use <tt>Lava.Prelude.dualRam</tt> for
--   stronger type-safety.
primDualRam :: [Integer] -> RamAlgorithm -> (RamInps, RamInps) -> ([Bit], [Bit])

-- | Generic structures of bits
class Generic a
generic :: Generic a => a -> BitContainer a

-- | Basic idea pinched from Uniplate. To use generics, you really don't
--   need to know the internals of this type as we provide <a>cons</a> and
--   <a>&gt;&lt;</a>. For example:
--   
--   <pre>
--   instance Generic a =&gt; Generic [a] where
--      generic [] = cons []
--      generic (a:as) = cons (:) &gt;&lt; a &gt;&lt; as
--   </pre>
type BitContainer a = (JList Bit, JList Bit -> a)
cons :: a -> BitContainer a
(><) :: Generic a => BitContainer (a -> b) -> a -> BitContainer b

-- | Extract a join-list of bits from any structure of bits.
structure :: Generic a => a -> JList Bit

-- | Extract a list of bits from any structure of bits.
bits :: Generic a => a -> [Bit]

-- | Map a function over bits across any structure of bits.
mapG :: Generic a => (Bit -> Bit) -> a -> a

-- | Zip a function over bits across any two structures of bits. Assumes
--   that the two structures have the same shape.
zipWithG :: Generic a => (Bit -> Bit -> Bit) -> a -> a -> a

-- | A lazier but less-defined version of <a>zipWithG</a>.
lazyZipWithG :: Generic a => (Bit -> Bit -> Bit) -> a -> a -> a

-- | Convert <a>False</a> to <a>low</a> and <a>True</a> to <a>high</a>.
boolToBit :: Bool -> Bit

-- | Simulate a circuit, giving the output on each clock-cycle. Returns an
--   infinite list.
simulate :: Generic a => a -> [a]

-- | Simulate a circuit for N clock-cycles.
simulateN :: Generic a => Int -> a -> [a]

-- | Simulate a circuit with a constant waveform specified as input.
simulateSeq :: (Generic a, Generic b) => (a -> b) -> [a] -> [b]

-- | Simulate a circuit returning a single bit, and convert result to a
--   boolean.
bitToBool :: Bit -> Bool
data Net
Net :: String -> [Parameter] -> InstanceId -> Int -> [Wire] -> Net
netName :: Net -> String
netParams :: Net -> [Parameter]
netId :: Net -> InstanceId
netNumOuts :: Net -> Int
netInputs :: Net -> [Wire]
data Netlist
Netlist :: [(String, Wire)] -> [Net] -> Netlist
namedOutputs :: Netlist -> [(String, Wire)]
nets :: Netlist -> [Net]

-- | Turn any circuit into a netlist.
netlist :: Generic a => a -> a -> IO Netlist

-- | The programmer's interface to creating new primitive components. See
--   definition of <a>and2</a> for an example.
makeComponent :: String -> [Bit] -> Int -> ([Signal] -> [Signal]) -> [Parameter] -> ([Bit] -> a) -> a

-- | A time-varying binary signal is clasically a list of booleans.
type Signal = [Bool]

-- | Every primitive component instance has a unique number.
type InstanceId = Int

-- | Each output from a primitive component is numbered.
type OutputNumber = Int

-- | A wire is uniquely identified by a instance id and an output number.
type Wire = (InstanceId, OutputNumber)

-- | Components may have compile-time parameters, for example whether a
--   flip-flop initialises to high or low. A parameter has a name and a
--   value, both represented as strings.
data Parameter
(:->) :: String -> String -> Parameter
lookupParam :: [Parameter] -> String -> String
instance Show Netlist
instance Show Net
instance Show Parameter
instance Show Bit
instance (Generic a, Generic b, Generic c, Generic d, Generic e, Generic f, Generic g, Generic h) => Generic (a, b, c, d, e, f, g, h)
instance (Generic a, Generic b, Generic c, Generic d, Generic e, Generic f, Generic g) => Generic (a, b, c, d, e, f, g)
instance (Generic a, Generic b, Generic c, Generic d, Generic e, Generic f) => Generic (a, b, c, d, e, f)
instance (Generic a, Generic b, Generic c, Generic d, Generic e) => Generic (a, b, c, d, e)
instance (Generic a, Generic b, Generic c, Generic d) => Generic (a, b, c, d)
instance (Generic a, Generic b, Generic c) => Generic (a, b, c)
instance (Generic a, Generic b) => Generic (a, b)
instance (Generic a, Generic b) => Generic (Either a b)
instance Generic a => Generic [a]
instance Generic a => Generic (Maybe a)
instance Generic Bit
instance Generic ()

module Lava.Vhdl

-- | For example, the function
--   
--   <pre>
--   halfAdd :: Bit -&gt; Bit -&gt; (Bit, Bit)
--   halfAdd a b = (sum, carry)
--     where
--       sum   = a &lt;#&gt; b
--       carry = a &lt;&amp;&gt; b
--   </pre>
--   
--   can be converted to a VHDL entity with inputs named <tt>a</tt> and
--   <tt>b</tt> and outputs named <tt>sum</tt> and <tt>carry</tt>.
--   
--   <pre>
--   synthesiseHalfAdd :: IO ()
--   synthesiseHalfAdd =
--     writeVhdl "HalfAdd"
--               (halfAdd (name "a") (name "b"))
--               (name "sum", name "carry")
--   </pre>
--   
--   The function <a>writeVhdl</a> assumes that the part (FPGA chip) you
--   are targetting is the <tt>Virtex-5-110t-ff1136-1</tt>, because that is
--   what sits at my desk. This is <i>only</i> important if your design
--   contains RAMs. If your design does contain RAMs, and you wish to
--   target a different part, then use the <a>writeVhdlForPart</a>
--   function. Xilinx's fault!
writeVhdl :: Generic a => String -> a -> a -> IO ()

-- | Like <a>writeVhdl</a>, but allows the target part (FPGA chip) to be
--   specified.
writeVhdlForPart :: Generic a => Part -> String -> a -> a -> IO ()

-- | For example:
--   
--   <pre>
--   v5110t :: Part
--   v5110t =
--     Part {
--       partName       = "xc5vlx110t"
--     , partFamily     = "virtex5"
--     , partPackage    = "ff1136"
--     , partSpeedGrade = "-1"
--     }
--   </pre>
data Part
Part :: String -> String -> String -> String -> Part
partName :: Part -> String
partFamily :: Part -> String
partPackage :: Part -> String
partSpeedGrade :: Part -> String
v5110t :: Part


-- | The beginnings of a Prelude of commonly-used circuits. By no means
--   exhaustive, but a useful start.
module Lava.Prelude

-- | Notably, an instance of the Num class.
type Word n = Vec n Bit

-- | Logical AND of all bits in a structure.
andG :: Generic a => a -> Bit

-- | Logical OR of all bits in a structure.
orG :: Generic a => a -> Bit

-- | Generic register, with initialiser.
delay :: Generic a => a -> a -> a

-- | Generic register, with initialiser, with input-enable.
delayEn :: Generic a => a -> Bit -> a -> a

-- | Generic two-way multiplexer.
(?) :: Generic a => Bit -> (a, a) -> a

-- | Returns a list of N named bits with a given prefix.
nameList :: Int -> String -> [Bit]

-- | Returns a vector of N named bits with a given prefix.
nameWord :: N n => String -> Word n

-- | N-way multiplexer, with one-hot address.
select :: [Bit] -> [[Bit]] -> [Bit]

-- | Generic <a>select</a>.
selectG :: Generic a => [Bit] -> [a] -> a

-- | Like <a>select</a>, but with zipped arguments.
pick :: [(Bit, [Bit])] -> [Bit]

-- | Generic <a>pick</a>.
pickG :: Generic a => [(Bit, a)] -> a

-- | Binary to one-hot decoder.
decode :: [Bit] -> [Bit]

-- | Two's complement version of <a>decode</a>.
decodeTwos :: [Bit] -> [Bit]

-- | One-hot to binary encoder.
encode :: [Bit] -> [Bit]

-- | Binary to tally converter.
tally :: [Bit] -> [Bit]

-- | Convert a Haskell <tt>Int</tt> to a one-hot bit-vector.
oneHot :: N n => Int -> Word n

-- | One-hot to tally converter.
tal :: [Bit] -> [Bit]

-- | Like <a>tal</a>; specifically <tt>tal' n = tal (n+1)</tt>.
tal' :: [Bit] -> [Bit]

-- | Rotate <tt>b</tt> by <tt>a</tt> places to the right; <tt>a</tt> is a
--   one-hot number.
rotr :: [Bit] -> [Bit] -> [Bit]

-- | Like <a>rotr</a>, but lifted to a list of bit-lists.
rotateRight :: [Bit] -> [[Bit]] -> [[Bit]]

-- | Like <a>rotr</a>, except rotation is to the left.
rotl :: [Bit] -> [Bit] -> [Bit]

-- | Like <a>rotateRight</a> except rotation is to the left.
rotateLeft :: [Bit] -> [[Bit]] -> [[Bit]]

-- | Dot product over bit-lists.
dot :: [Bit] -> [Bit] -> Bit
data RamInputs n m
RamInputs :: Word n -> Word m -> Bit -> RamInputs n m
ramData :: RamInputs n m -> Word n
ramAddress :: RamInputs n m -> Word m
ramWrite :: RamInputs n m -> Bit

-- | RAM of any width and size, with intialiser.
ram :: (N n, N m) => [Integer] -> RamAlgorithm -> RamInputs n m -> Word n

-- | Dual-port RAM of any width and size, with intialiser.
dualRam :: (N n, N m) => [Integer] -> RamAlgorithm -> (RamInputs n m, RamInputs n m) -> (Word n, Word n)

-- | Unsigned bit-vectors.
type Unsigned n = Word n

-- | Signed bit-vectors.
newtype Signed n
Signed :: (Vec n Bit) -> Signed n

-- | Subtracts <tt>b</tt> from <tt>a</tt>, but if <tt>b</tt> is larger than
--   <tt>a</tt> then result is <tt>0</tt>.
natSub :: N n => Word n -> Word n -> Word n

-- | Two's complement of a bit-list.
complement :: [Bit] -> [Bit]

-- | Addition of a single bit to a bit-list.
bitPlus :: Bit -> [Bit] -> [Bit]

-- | Convert bit-vector to an integer.
wordToInt :: Integral a => Word n -> a

-- | Sign-extend a bit-vector.
extend :: N n => Vec (S m) c -> Vec n c

-- | Generic equality.
(===) :: Generic a => a -> a -> Bit

-- | Generic diseqaulity.
(=/=) :: Generic a => a -> a -> Bit
class Ordered a
(|<=|) :: Ordered a => a -> a -> Bit
(|<|) :: Ordered a => a -> a -> Bit
(|>=|) :: Ordered a => a -> a -> Bit
(|>|) :: Ordered a => a -> a -> Bit

-- | Parallel reduce for a commutative an associative operator. Input list
--   must be non-empty.
tree1 :: (a -> a -> a) -> [a] -> a

-- | Like <a>tree1</a>, but input list may be empty, in which case the zero
--   element is returned.
tree :: (a -> a -> a) -> a -> [a] -> a

-- | Split a list into sub-lists of maximum length N.
groupN :: Int -> [a] -> [[a]]

-- | Split a list in two.
halve :: [a] -> ([a], [a])
instance Show (Signed n)
instance Num Bit
instance Eq Bit
instance Ordered (Signed n)
instance N n => Num (Signed n)
instance Eq (Signed n)
instance Generic (Signed n)
instance Ordered (Vec n Bit)
instance N n => Num (Vec n Bit)
instance Eq (Vec n Bit)
instance Generic a => Generic (Vec n a)


-- | York Lava is library for describing digital circuits. Descriptions can
--   be simulated in Hugs or GHC, and converted to VHDL compatible with
--   XST, the Xilinx Synthesis Tool. It is largely compatible with Chalmers
--   Lava, but omits some features and offers a few new ones.
--   
--   New features include:
--   
--   <ul>
--   <li>Behavioural description, using <a>Recipe</a>.</li>
--   <li>Easy addition of new primitive components
--   (<a>makeComponent</a>).</li>
--   <li>Primitives components with multiple outputs.</li>
--   <li>New primitive components, including RAMs and dual-port RAMs
--   (<a>ram</a> and <a>dualRam</a>). Can be of any size and width; when
--   synthesised, Xilinx Core Generator (.xco) files are produced.</li>
--   <li>Provides an explicit <a>Netlist</a> data structure, allowing
--   custom backends to be added.</li>
--   <li>Sized vectors (<a>Lava.Vector</a>). For example, bit-vectors
--   (<a>Word</a>) are an instance of the <i>Num</i> class.</li>
--   <li>A <a>Lava.Prelude</a> of commonly-used circuits.</li>
--   <li>Testing via QuickCheck and SmallCheck.</li>
--   <li>Smallish, self-contained code base.</li>
--   </ul>
--   
--   Limitations include:
--   
--   <ul>
--   <li>No model-checking backend; Chalmers Lava has many.</li>
--   <li>Long-running simulations consume memory rather quickly! Note
--   however that you can also simulate circuits using the Xilinx
--   simulator, via the VHDL backend.</li>
--   </ul>
--   
--   See <tt>REDUCERON MEMO 23</tt> - included in the package and available
--   at <a>http://www.cs.york.ac.uk/fp/reduceron/</a> - for a tutorial.
module Lava


-- | A library for writing behavioural descriptions in York Lava, inspired
--   by Page and Luk's "Compiling Occam into Field-Programmable Gate
--   Arrays", Oxford Workshop on Field Programmable Logic and Applications,
--   1991. Features explicit clocking, signals as well as registers, shared
--   procedure calls, and an optimiser. The implementation is short and
--   sweet! Used in the implementation of the Reduceron, a graph reduction
--   machine for Xilinx FPGAs.
--   
--   To illustrate, consider the implementation of a sequential multiplier
--   using the shift-and-add algorithm.
--   
--   <pre>
--   import Lava
--   import Recipe
--   </pre>
--   
--   We define a state type containing three registers: the two inputs to
--   multiply, and the result of the multiplication.
--   
--   <pre>
--   data Mult n = Mult { a, b, result :: Reg n }
--   </pre>
--   
--   A value of type <tt>Mult n</tt> is created by <tt>newMult</tt>.
--   
--   <pre>
--   newMult :: N n =&gt; New (Mult n)
--   newMult = return Mult `ap` newReg `ap` newReg `ap` newReg
--   </pre>
--   
--   The shift-and-add recipe operates over a value of type <tt>Mult
--   n</tt>.
--   
--   <pre>
--   shiftAndAdd s =
--     While (s!b!val =/= 0) $
--       Seq [ s!a &lt;== s!a!val!shr
--           , s!b &lt;== s!b!val!shl
--           , s!b!val!vhead |&gt;
--               s!result &lt;== s!result!val + s!a!val
--           , Tick
--           ]
--   </pre>
--   
--   <pre>
--   shr x = low +&gt; vinit x
--   </pre>
--   
--   <pre>
--   shl x = vtail x &lt;+ low
--   </pre>
--   
--   Three remarks are in order:
--   
--   <ol>
--   <li>The <tt>!</tt> operator is flipped application with a high
--   precedence.</li>
--   </ol>
--   
--   <pre>
--   infixl 9 !
--   (!) :: a -&gt; (a -&gt; b) -&gt; b
--   x!f = f x
--   </pre>
--   
--   This gives descriptions an appropriate object-oriented flavour.
--   
--   <ol>
--   <li>The value of a variable is obtained using the function</li>
--   </ol>
--   
--   <pre>
--   val :: Var v =&gt; v n -&gt; Word n
--   </pre>
--   
--   Registers (of type <a>Reg</a>) are an instance of the <a>Var</a>
--   class.
--   
--   <ol>
--   <li>The functions <tt>+&gt;</tt> and <tt>&lt;+</tt> perform cons and
--   snoc operations on vectors, <tt>vhead</tt> takes the head of a vector,
--   and <tt>=/=</tt> is generic disequality.</li>
--   </ol>
--   
--   To actually perform a multiplication, the input variables need to be
--   initialised.
--   
--   <pre>
--   multiply x y s =
--     Seq [ s!a &lt;== x, s!b &lt;== y, s!result &lt;== 0, Tick, s!shiftAndAdd ]
--   </pre>
--   
--   <pre>
--   example :: Mult N8 -&gt; Recipe
--   example s = s!multiply 5 25
--   </pre>
--   
--   <pre>
--   simExample = simRecipe newMult example result
--   </pre>
--   
--   Evaluating <tt>simExample</tt> yields <tt>25 :: Word N8</tt>.
--   
--   See <tt>REDUCERON MEMO 23</tt> - included in the package and available
--   at <a>http://www.cs.york.ac.uk/fp/reduceron/</a> - for further details
--   and examples.
module Recipe
data Recipe

-- | The most basic recipe; does nothing.
Skip :: Recipe

-- | Does nothing, but takes one clock-cycle to do it.
Tick :: Recipe

-- | Sequential composition of recipes.
Seq :: [Recipe] -> Recipe

-- | Fork-Join parallel composition of recipes.
Par :: [Recipe] -> Recipe

-- | Run a recipe while a condition holds.
While :: Bit -> Recipe -> Recipe

-- | Like <a>While</a>, but condition is checked at the end of each
--   iteration.
Do :: Recipe -> Bit -> Recipe

-- | Run a recipe only if a condition holds.
(|>) :: Bit -> Recipe -> Recipe

-- | Call a procedure.
call :: Proc -> Recipe

-- | Mutable variables; named locations that can be read from and assigned
--   to.
class Var v
val :: Var v => v n -> Word n
(<==) :: Var v => v n -> Word n -> Recipe

-- | Reverse function application.
(!) :: a -> (a -> b) -> b

-- | Infix constructor for pairs.
(-->) :: a -> b -> (a, b)

-- | It's a monad; that's all you need to know.
type New a = RWS Schedule (Bit, Recipe) VarId a

-- | <i>Register variables</i>: assignments to a register come into effect
--   in the clock-cycle <i>after</i> the assignment is performed; the
--   initial value of a register is zero unless otherwise specified.
data Reg n
newReg :: N n => New (Reg n)
newRegInit :: N n => Word n -> New (Reg n)

-- | <i>Signal variables</i>: assignments to a signal come into effect in
--   the current clock-cycle, but last only for the duration of that
--   clock-cycle; if a signal not assigned to in a clock-cycle then its
--   value will be its <i>default</i> value which is zero unless otherwise
--   specified.
data Sig n
newSig :: N n => New (Sig n)
newSigDef :: N n => Word n -> New (Sig n)
data Proc

-- | Capture a recipe as shared procedure that can be called whenever
--   desired; needless to say, the programmer should avoid parallel calls
--   to the same shared procedure!
newProc :: Recipe -> New Proc
recipe :: New a -> (a -> Recipe) -> Bit -> (a, Bit)
simRecipe :: Generic b => New a -> (a -> Recipe) -> (a -> b) -> b
instance Monad (RWS r w s)
instance Var Reg
instance Var Sig
instance Show (Reg n)
instance Generic (Reg n)
instance Show (Sig n)
instance Generic (Sig n)
