-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A static website compiler library
--   
@package hakyll
@version 4.7.1.0


-- | Provides utilities to manipulate HTML pages
module Hakyll.Web.Html

-- | Map over all tags in the document
withTags :: (Tag String -> Tag String) -> String -> String

-- | Map every <tt>h1</tt> to an <tt>h2</tt>, <tt>h2</tt> to <tt>h3</tt>,
--   etc.
demoteHeaders :: String -> String
getUrls :: [Tag String] -> [String]

-- | Apply a function to each URL on a webpage
withUrls :: (String -> String) -> String -> String

-- | Convert a filepath to an URL starting from the site root
--   
--   Example:
--   
--   <pre>
--   toUrl "foo/bar.html"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   "/foo/bar.html"
--   </pre>
--   
--   This also sanitizes the URL, e.g. converting spaces into '%20'
toUrl :: FilePath -> String

-- | Get the relative url to the site root, for a given (absolute) url
toSiteRoot :: String -> String

-- | Check if an URL links to an external HTTP(S) source
isExternal :: String -> Bool

-- | Strip all HTML tags from a string
--   
--   Example:
--   
--   <pre>
--   stripTags "&lt;p&gt;foo&lt;/p&gt;"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   "foo"
--   </pre>
--   
--   This also works for incomplete tags
--   
--   Example:
--   
--   <pre>
--   stripTags "&lt;p&gt;foo&lt;/p"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   "foo"
--   </pre>
stripTags :: String -> String

-- | HTML-escape a string
--   
--   Example:
--   
--   <pre>
--   escapeHtml "Me &amp; Dean"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   "Me &amp;amp; Dean"
--   </pre>
escapeHtml :: String -> String


-- | Miscellaneous string manipulation functions.
module Hakyll.Core.Util.String

-- | Trim a string (drop spaces, tabs and newlines at both sides).
trim :: String -> String

-- | A simple (but inefficient) regex replace funcion
replaceAll :: String -> (String -> String) -> String -> String

-- | A simple regex split function. The resulting list will contain no
--   empty strings.
splitAll :: String -> String -> [String]

-- | Find the first instance of needle (must be non-empty) in haystack. We
--   return the prefix of haystack before needle is matched.
--   
--   Examples:
--   
--   <pre>
--   needlePrefix "cd" "abcde" = "ab"
--   </pre>
--   
--   <pre>
--   needlePrefix "ab" "abc" = ""
--   </pre>
--   
--   <pre>
--   needlePrefix "ab" "xxab" = "xx"
--   </pre>
--   
--   <pre>
--   needlePrefix "a" "xx" = "xx"
--   </pre>
needlePrefix :: String -> String -> Maybe String


-- | An identifier is a type used to uniquely identify an item. An
--   identifier is conceptually similar to a file path. Examples of
--   identifiers are:
--   
--   <ul>
--   <li><pre>posts/foo.markdown</pre></li>
--   <li><pre>index</pre></li>
--   <li><pre>error/404</pre></li>
--   </ul>
module Hakyll.Core.Identifier
data Identifier

-- | Parse an identifier from a string
fromFilePath :: String -> Identifier

-- | Convert an identifier to a relative <a>FilePath</a>
toFilePath :: Identifier -> FilePath
identifierVersion :: Identifier -> Maybe String
setVersion :: Maybe String -> Identifier -> Identifier
instance Typeable Identifier
instance Eq Identifier
instance Ord Identifier
instance Show Identifier
instance NFData Identifier
instance IsString Identifier
instance Binary Identifier


-- | As <a>Identifier</a> is used to specify a single item, a
--   <a>Pattern</a> is used to specify a list of items.
--   
--   In most cases, globs are used for patterns.
--   
--   A very simple pattern of such a pattern is <tt>"foo/bar"</tt>. This
--   pattern will only match the exact <tt>foo/bar</tt> identifier.
--   
--   To match more than one identifier, there are different captures that
--   one can use:
--   
--   <ul>
--   <li><tt>"*"</tt>: matches at most one element of an identifier;</li>
--   <li><tt>"**"</tt>: matches one or more elements of an identifier.</li>
--   </ul>
--   
--   Some examples:
--   
--   <ul>
--   <li><tt>"foo/*"</tt> will match <tt>"foo/bar"</tt> and
--   <tt>"foo/foo"</tt>, but not <tt>"foo/bar/qux"</tt>;</li>
--   <li><tt>"**"</tt> will match any identifier;</li>
--   <li><tt>"foo/**"</tt> will match <tt>"foo/bar"</tt> and
--   <tt>"foo/bar/qux"</tt>, but not <tt>"bar/foo"</tt>;</li>
--   <li><tt>"foo/*.html"</tt> will match all HTML files in the
--   <tt>"foo/"</tt> directory.</li>
--   </ul>
--   
--   The <a>capture</a> function allows the user to get access to the
--   elements captured by the capture elements in the pattern.
module Hakyll.Core.Identifier.Pattern

-- | Type that allows matching on identifiers
data Pattern

-- | Parse a pattern from a string
fromGlob :: String -> Pattern

-- | Create a <a>Pattern</a> from a list of <a>Identifier</a>s it should
--   match.
--   
--   <i>Warning</i>: use this carefully with <a>hasNoVersion</a> and
--   <a>hasVersion</a>. The <a>Identifier</a>s in the list <i>already</i>
--   have versions assigned, and the pattern will then only match the
--   intersection of both versions.
--   
--   A more concrete example,
--   
--   <pre>
--   fromList ["foo.markdown"] .&amp;&amp;. hasVersion "pdf"
--   </pre>
--   
--   will not match anything! The <tt>"foo.markdown"</tt> <a>Identifier</a>
--   has no version assigned, so the LHS of <a>.&amp;&amp;.</a> will only
--   match this <a>Identifier</a> with no version. The RHS only matches
--   <a>Identifier</a>s with version set to <tt>"pdf"</tt> -- hence, this
--   pattern matches nothing.
--   
--   The correct way to use this is:
--   
--   <pre>
--   fromList $ map (setVersion $ Just "pdf") ["foo.markdown"]
--   </pre>
fromList :: [Identifier] -> Pattern

-- | Create a <a>Pattern</a> from a regex
--   
--   Example:
--   
--   <pre>
--   regex "^foo/[^x]*$
--   </pre>
fromRegex :: String -> Pattern

-- | Create a pattern which matches all items with the given version.
fromVersion :: Maybe String -> Pattern

-- | Specify a version, e.g.
--   
--   <pre>
--   "foo/*.markdown" .&amp;&amp;. hasVersion "pdf"
--   </pre>
hasVersion :: String -> Pattern

-- | Match only if the identifier has no version set, e.g.
--   
--   <pre>
--   "foo/*.markdown" .&amp;&amp;. hasNoVersion
--   </pre>
hasNoVersion :: Pattern

-- | <a>&amp;&amp;</a> for patterns: the given identifier must match both
--   subterms
(.&&.) :: Pattern -> Pattern -> Pattern

-- | <a>||</a> for patterns: the given identifier must match any subterm
(.||.) :: Pattern -> Pattern -> Pattern

-- | Inverts a pattern, e.g.
--   
--   <pre>
--   complement "foo/bar.html"
--   </pre>
--   
--   will match <i>anything</i> except <tt>"foo/bar.html"</tt>
complement :: Pattern -> Pattern

-- | Check if an identifier matches a pattern
matches :: Pattern -> Identifier -> Bool

-- | Given a list of identifiers, retain only those who match the given
--   pattern
filterMatches :: Pattern -> [Identifier] -> [Identifier]

-- | Match a glob against a pattern, generating a list of captures
capture :: Pattern -> Identifier -> Maybe [String]

-- | Create an identifier from a pattern by filling in the captures with a
--   given string
--   
--   Example:
--   
--   <pre>
--   fromCapture (fromGlob "tags/*") "foo"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   "tags/foo"
--   </pre>
fromCapture :: Pattern -> String -> Identifier

-- | Create an identifier from a pattern by filling in the captures with
--   the given list of strings
fromCaptures :: Pattern -> [String] -> Identifier
instance Eq GlobComponent
instance Show GlobComponent
instance Show Pattern
instance Monoid Pattern
instance IsString Pattern
instance Binary Pattern
instance Binary GlobComponent

module Hakyll.Core.Dependencies
data Dependency
PatternDependency :: Pattern -> (Set Identifier) -> Dependency
IdentifierDependency :: Identifier -> Dependency
type DependencyFacts = Map Identifier [Dependency]
outOfDate :: [Identifier] -> Set Identifier -> DependencyFacts -> (Set Identifier, DependencyFacts, [String])
instance Typeable Dependency
instance Show Dependency
instance Show DependencyState
instance Binary Dependency

module Hakyll.Core.Metadata
type Metadata = Map String String
class Monad m => MonadMetadata m where getAllMetadata pattern = do { matches' <- getMatches pattern; forM matches' $ \ id' -> do { metadata <- getMetadata id'; return (id', metadata) } }
getMetadata :: MonadMetadata m => Identifier -> m Metadata
getMatches :: MonadMetadata m => Pattern -> m [Identifier]
getAllMetadata :: MonadMetadata m => Pattern -> m [(Identifier, Metadata)]
getMetadataField :: MonadMetadata m => Identifier -> String -> m (Maybe String)

-- | Version of <a>getMetadataField</a> which throws an error if the field
--   does not exist.
getMetadataField' :: MonadMetadata m => Identifier -> String -> m String
makePatternDependency :: MonadMetadata m => Pattern -> m Dependency


-- | Once a target is compiled, the user usually wants to save it to the
--   disk. This is where the <a>Routes</a> type comes in; it determines
--   where a certain target should be written.
--   
--   Suppose we have an item <tt>foo/bar.markdown</tt>. We can render this
--   to <tt>foo/bar.html</tt> using:
--   
--   <pre>
--   route "foo/bar.markdown" (setExtension ".html")
--   </pre>
--   
--   If we do not want to change the extension, we can use <a>idRoute</a>,
--   the simplest route available:
--   
--   <pre>
--   route "foo/bar.markdown" idRoute
--   </pre>
--   
--   That will route <tt>foo/bar.markdown</tt> to
--   <tt>foo/bar.markdown</tt>.
--   
--   Note that the extension says nothing about the content! If you set the
--   extension to <tt>.html</tt>, it is your own responsibility to ensure
--   that the content is indeed HTML.
--   
--   Finally, some special cases:
--   
--   <ul>
--   <li>If there is no route for an item, this item will not be routed, so
--   it will not appear in your site directory.</li>
--   <li>If an item matches multiple routes, the first rule will be
--   chosen.</li>
--   </ul>
module Hakyll.Core.Routes

-- | When you ran a route, it's useful to know whether or not this used
--   metadata. This allows us to do more granular dependency analysis.
type UsedMetadata = Bool

-- | Type used for a route
data Routes

-- | Apply a route to an identifier
runRoutes :: Routes -> Provider -> Identifier -> IO (Maybe FilePath, UsedMetadata)

-- | A route that uses the identifier as filepath. For example, the target
--   with ID <tt>foo/bar</tt> will be written to the file <tt>foo/bar</tt>.
idRoute :: Routes

-- | Set (or replace) the extension of a route.
--   
--   Example:
--   
--   <pre>
--   runRoutes (setExtension "html") "foo/bar"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   Just "foo/bar.html"
--   </pre>
--   
--   Example:
--   
--   <pre>
--   runRoutes (setExtension "html") "posts/the-art-of-trolling.markdown"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   Just "posts/the-art-of-trolling.html"
--   </pre>
setExtension :: String -> Routes

-- | Apply the route if the identifier matches the given pattern, fail
--   otherwise
matchRoute :: Pattern -> Routes -> Routes

-- | Create a custom route. This should almost always be used with
--   <a>matchRoute</a>
customRoute :: (Identifier -> FilePath) -> Routes

-- | A route that always gives the same result. Obviously, you should only
--   use this for a single compilation rule.
constRoute :: FilePath -> Routes

-- | Create a gsub route
--   
--   Example:
--   
--   <pre>
--   runRoutes (gsubRoute "rss/" (const "")) "tags/rss/bar.xml"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   Just "tags/bar.xml"
--   </pre>
gsubRoute :: String -> (String -> String) -> Routes

-- | Get access to the metadata in order to determine the route
metadataRoute :: (Metadata -> Routes) -> Routes

-- | Compose routes so that <tt>f `composeRoutes` g</tt> is more or less
--   equivalent with <tt>g . f</tt>.
--   
--   Example:
--   
--   <pre>
--   let routes = gsubRoute "rss/" (const "") `composeRoutes` setExtension "xml"
--   in runRoutes routes "tags/rss/bar"
--   </pre>
--   
--   Result:
--   
--   <pre>
--   Just "tags/bar.xml"
--   </pre>
--   
--   If the first route given fails, Hakyll will not apply the second
--   route.
composeRoutes :: Routes -> Routes -> Routes
instance Monoid Routes


-- | Exports a datastructure for the top-level hakyll configuration
module Hakyll.Core.Configuration
data Configuration
Configuration :: FilePath -> FilePath -> FilePath -> FilePath -> (FilePath -> Bool) -> String -> (Configuration -> IO ExitCode) -> Bool -> String -> Int -> Configuration

-- | Directory in which the output written
destinationDirectory :: Configuration -> FilePath

-- | Directory where hakyll's internal store is kept
storeDirectory :: Configuration -> FilePath

-- | Directory in which some temporary files will be kept
tmpDirectory :: Configuration -> FilePath

-- | Directory where hakyll finds the files to compile. This is <tt>.</tt>
--   by default.
providerDirectory :: Configuration -> FilePath

-- | Function to determine ignored files
--   
--   In <a>defaultConfiguration</a>, the following files are ignored:
--   
--   <ul>
--   <li>files starting with a <tt>.</tt></li>
--   <li>files starting with a <tt>#</tt></li>
--   <li>files ending with a <tt>~</tt></li>
--   <li>files ending with <tt>.swp</tt></li>
--   </ul>
--   
--   Note that the files in <a>destinationDirectory</a> and
--   <a>storeDirectory</a> will also be ignored. Note that this is the
--   configuration parameter, if you want to use the test, you should use
--   <a>shouldIgnoreFile</a>.
ignoreFile :: Configuration -> FilePath -> Bool

-- | Here, you can plug in a system command to upload/deploy your site.
--   
--   Example:
--   
--   <pre>
--   rsync -ave 'ssh -p 2217' _site jaspervdj@jaspervdj.be:hakyll
--   </pre>
--   
--   You can execute this by using
--   
--   <pre>
--   ./site deploy
--   </pre>
deployCommand :: Configuration -> String

-- | Function to deploy the site from Haskell.
--   
--   By default, this command executes the shell command stored in
--   <a>deployCommand</a>. If you override it, <a>deployCommand</a> will
--   not be used implicitely.
--   
--   The <a>Configuration</a> object is passed as a parameter to this
--   function.
deploySite :: Configuration -> Configuration -> IO ExitCode

-- | Use an in-memory cache for items. This is faster but uses more memory.
inMemoryCache :: Configuration -> Bool

-- | Override default host for preview server. Default is "127.0.0.1",
--   which binds only on the loopback address. One can also override the
--   host as a command line argument: ./site preview -h "0.0.0.0"
previewHost :: Configuration -> String

-- | Override default port for preview server. Default is 8000. One can
--   also override the port as a command line argument: ./site preview -p
--   1234
previewPort :: Configuration -> Int

-- | Check if a file should be ignored
shouldIgnoreFile :: Configuration -> FilePath -> IO Bool

-- | Default configuration for a hakyll application
defaultConfiguration :: Configuration
instance Default Configuration


-- | An item is a combination of some content and its <a>Identifier</a>.
--   This way, we can still use the <a>Identifier</a> to access metadata.
module Hakyll.Core.Item
data Item a
Item :: Identifier -> a -> Item a
itemIdentifier :: Item a -> Identifier
itemBody :: Item a -> a
itemSetBody :: a -> Item b -> Item a

-- | Perform a compiler action on the item body. This is the same as
--   <a>traverse</a>, but looks less intimidating.
--   
--   <pre>
--   withItemBody = traverse
--   </pre>
withItemBody :: (a -> Compiler b) -> Item a -> Compiler (Item b)
instance Typeable Item
instance Show a => Show (Item a)
instance Binary a => Binary (Item a)
instance Traversable Item
instance Foldable Item
instance Functor Item


-- | Describes writable items; items that can be saved to the disk
module Hakyll.Core.Writable

-- | Describes an item that can be saved to the disk
class Writable a
write :: Writable a => FilePath -> Item a -> IO ()
instance Writable Html
instance Writable [Word8]
instance Writable ByteString
instance Writable ByteString
instance Writable [Char]
instance Writable ()


-- | A module dealing with pandoc file extensions and associated file types
module Hakyll.Web.Pandoc.FileType

-- | Datatype to represent the different file types Hakyll can deal with by
--   default
data FileType
Binary :: FileType
Css :: FileType
DocBook :: FileType
Html :: FileType
LaTeX :: FileType
LiterateHaskell :: FileType -> FileType
Markdown :: FileType
MediaWiki :: FileType
OrgMode :: FileType
PlainText :: FileType
Rst :: FileType
Textile :: FileType

-- | Get the file type for a certain file. The type is determined by
--   extension.
fileType :: FilePath -> FileType

-- | Get the file type for the current file
itemFileType :: Item a -> FileType
instance Eq FileType
instance Ord FileType
instance Show FileType
instance Read FileType


-- | This module provides a declarative DSL in which the user can specify
--   the different rules used to run the compilers.
--   
--   The convention is to just list all items in the <a>Rules</a> monad,
--   routes and compilation rules.
--   
--   A typical usage example would be:
--   
--   <pre>
--   main = hakyll $ do
--       match "posts/*" $ do
--           route   (setExtension "html")
--           compile someCompiler
--       match "css/*" $ do
--           route   idRoute
--           compile compressCssCompiler
--   </pre>
module Hakyll.Core.Rules

-- | The monad used to compose rules
data Rules a
match :: Pattern -> Rules () -> Rules ()
matchMetadata :: Pattern -> (Metadata -> Bool) -> Rules () -> Rules ()
create :: [Identifier] -> Rules () -> Rules ()
version :: String -> Rules () -> Rules ()

-- | Add a compilation rule to the rules.
--   
--   This instructs all resources to be compiled using the given compiler.
compile :: (Binary a, Typeable a, Writable a) => Compiler (Item a) -> Rules ()

-- | Add a route.
--   
--   This adds a route for all items matching the current pattern.
route :: Routes -> Rules ()

-- | Execute an <a>IO</a> action immediately while the rules are being
--   evaluated. This should be avoided if possible, but occasionally comes
--   in useful.
preprocess :: IO a -> Rules a
data Dependency
PatternDependency :: Pattern -> (Set Identifier) -> Dependency
IdentifierDependency :: Identifier -> Dependency

-- | Advanced usage: add extra dependencies to compilers. Basically this is
--   needed when you're doing unsafe tricky stuff in the rules monad, but
--   you still want correct builds.
--   
--   A useful utility for this purpose is <a>makePatternDependency</a>.
rulesExtraDependencies :: [Dependency] -> Rules a -> Rules a


-- | Module providing the main hakyll function and command-line argument
--   parsing
module Hakyll.Main

-- | This usualy is the function with which the user runs the hakyll
--   compiler
hakyll :: Rules a -> IO ()

-- | A variant of <a>hakyll</a> which allows the user to specify a custom
--   configuration
hakyllWith :: Configuration -> Rules a -> IO ()
hakyllWithExitCode :: Configuration -> Rules a -> IO ExitCode
instance Typeable HakyllArgs
instance Data HakyllArgs
instance Show HakyllArgs

module Hakyll.Core.Compiler

-- | A monad which lets you compile items and takes care of dependency
--   tracking for you.
data Compiler a

-- | Get the underlying identifier.
getUnderlying :: Compiler Identifier

-- | Get the extension of the underlying identifier. Returns something like
--   <tt>".html"</tt>
getUnderlyingExtension :: Compiler String
makeItem :: a -> Compiler (Item a)

-- | Get the route for a specified item
getRoute :: Identifier -> Compiler (Maybe FilePath)

-- | Get the body of the underlying resource
getResourceBody :: Compiler (Item String)

-- | Get the resource we are compiling as a string
getResourceString :: Compiler (Item String)

-- | Get the resource we are compiling as a lazy bytestring
getResourceLBS :: Compiler (Item ByteString)

-- | Get the file path of the resource we are compiling
getResourceFilePath :: Compiler FilePath

-- | Whilst compiling an item, it possible to save multiple snapshots of
--   it, and not just the final result.
type Snapshot = String

-- | Save a snapshot of the item. This function returns the same item,
--   which convenient for building <a>&gt;&gt;=</a> chains.
saveSnapshot :: (Binary a, Typeable a) => Snapshot -> Item a -> Compiler (Item a)

-- | Load an item compiled elsewhere. If the required item is not yet
--   compiled, the build system will take care of that automatically.
load :: (Binary a, Typeable a) => Identifier -> Compiler (Item a)

-- | Require a specific snapshot of an item.
loadSnapshot :: (Binary a, Typeable a) => Identifier -> Snapshot -> Compiler (Item a)

-- | A shortcut for only requiring the body of an item.
--   
--   <pre>
--   loadBody = fmap itemBody . load
--   </pre>
loadBody :: (Binary a, Typeable a) => Identifier -> Compiler a
loadSnapshotBody :: (Binary a, Typeable a) => Identifier -> Snapshot -> Compiler a

-- | This function allows you to <a>load</a> a dynamic list of items
loadAll :: (Binary a, Typeable a) => Pattern -> Compiler [Item a]
loadAllSnapshots :: (Binary a, Typeable a) => Pattern -> Snapshot -> Compiler [Item a]
cached :: (Binary a, Typeable a) => String -> Compiler a -> Compiler a
unsafeCompiler :: IO a -> Compiler a

-- | Compiler for debugging purposes
debugCompiler :: String -> Compiler ()


-- | Exports simple compilers to just copy files
module Hakyll.Core.File

-- | This will copy any file directly by using a system call
newtype CopyFile
CopyFile :: FilePath -> CopyFile
copyFileCompiler :: Compiler (Item CopyFile)
newtype TmpFile
TmpFile :: FilePath -> TmpFile

-- | Create a tmp file
newTmpFile :: String -> Compiler TmpFile
instance Typeable CopyFile
instance Typeable TmpFile
instance Binary CopyFile
instance Eq CopyFile
instance Ord CopyFile
instance Show CopyFile
instance Writable TmpFile
instance Binary TmpFile
instance Writable CopyFile


-- | A Compiler that supports unix filters.
module Hakyll.Core.UnixFilter

-- | Use a unix filter as compiler. For example, we could use the
--   <tt>rev</tt> program as a compiler.
--   
--   <pre>
--   rev :: Compiler String
--   rev = getResourceString &gt;&gt;= withItemBody (unixFilter "rev" [])
--   </pre>
--   
--   A more realistic example: one can use this to call, for example, the
--   sass compiler on CSS files. More information about sass can be found
--   here:
--   
--   <a>http://sass-lang.com/</a>
--   
--   The code is fairly straightforward, given that we use <tt>.scss</tt>
--   for sass:
--   
--   <pre>
--   match "style.scss" $ do
--       route   $ setExtension "css"
--       compile $ getResourceString &gt;&gt;=
--           withItemBody (unixFilter "sass" ["-s", "--scss"]) &gt;&gt;=
--           return . fmap compressCss
--   </pre>
unixFilter :: String -> [String] -> String -> Compiler String

-- | Variant of <a>unixFilter</a> that should be used for binary files
--   
--   <pre>
--   match "music.wav" $ do
--       route   $ setExtension "ogg"
--       compile $ getResourceLBS &gt;&gt;= withItemBody (unixFilterLBS "oggenc" ["-"])
--   </pre>
unixFilterLBS :: String -> [String] -> ByteString -> Compiler ByteString


-- | Module used for CSS compression. The compression is currently in a
--   simple state, but would typically reduce the number of bytes by about
--   25%.
module Hakyll.Web.CompressCss

-- | Compiler form of <a>compressCss</a>
compressCssCompiler :: Compiler (Item String)

-- | Compress CSS to speed up your site.
compressCss :: String -> String


-- | This module exposes a function which can relativize URL's on a
--   webpage.
--   
--   This means that one can deploy the resulting site on
--   <tt>http://example.com/</tt>, but also on
--   <tt>http://example.com/some-folder/</tt> without having to change
--   anything (simply copy over the files).
--   
--   To use it, you should use absolute URL's from the site root
--   everywhere. For example, use
--   
--   <pre>
--   &lt;img src="/images/lolcat.png" alt="Funny zomgroflcopter" /&gt;
--   </pre>
--   
--   in a blogpost. When running this through the relativize URL's module,
--   this will result in (suppose your blogpost is located at
--   <tt>/posts/foo.html</tt>:
--   
--   <pre>
--   &lt;img src="../images/lolcat.png" alt="Funny zomgroflcopter" /&gt;
--   </pre>
module Hakyll.Web.Html.RelativizeUrls

-- | Compiler form of <a>relativizeUrls</a> which automatically picks the
--   right root path
relativizeUrls :: Item String -> Compiler (Item String)

-- | Relativize URL's in HTML
relativizeUrlsWith :: String -> String -> String


-- | Module exporting convenient pandoc bindings
module Hakyll.Web.Pandoc

-- | Read a string using pandoc, with the default options
readPandoc :: Item String -> Compiler (Item Pandoc)

-- | Read a string using pandoc, with the supplied options
readPandocWith :: ReaderOptions -> Item String -> Compiler (Item Pandoc)

-- | Write a document (as HTML) using pandoc, with the default options
writePandoc :: Item Pandoc -> Item String

-- | Write a document (as HTML) using pandoc, with the supplied options
writePandocWith :: WriterOptions -> Item Pandoc -> Item String

-- | Render the resource using pandoc
renderPandoc :: Item String -> Compiler (Item String)

-- | Render the resource using pandoc
renderPandocWith :: ReaderOptions -> WriterOptions -> Item String -> Compiler (Item String)

-- | Read a page render using pandoc
pandocCompiler :: Compiler (Item String)

-- | A version of <a>pandocCompiler</a> which allows you to specify your
--   own pandoc options
pandocCompilerWith :: ReaderOptions -> WriterOptions -> Compiler (Item String)

-- | An extension of <a>pandocCompilerWith</a> which allows you to specify
--   a custom pandoc transformation for the content
pandocCompilerWithTransform :: ReaderOptions -> WriterOptions -> (Pandoc -> Pandoc) -> Compiler (Item String)

-- | Similar to <a>pandocCompilerWithTransform</a>, but the transformation
--   function is monadic. This is useful when you want the pandoc
--   transformation to use the <a>Compiler</a> information such as routes,
--   metadata, etc
pandocCompilerWithTransformM :: ReaderOptions -> WriterOptions -> (Pandoc -> Compiler Pandoc) -> Compiler (Item String)

-- | The default reader options for pandoc parsing in hakyll
defaultHakyllReaderOptions :: ReaderOptions

-- | The default writer options for pandoc rendering in hakyll
defaultHakyllWriterOptions :: WriterOptions


-- | Wraps pandocs bibiliography handling
--   
--   In order to add a bibliography, you will need a bibliography file
--   (e.g. <tt>.bib</tt>) and a CSL file (<tt>.csl</tt>). Both need to be
--   compiled with their respective compilers (<a>biblioCompiler</a> and
--   <a>cslCompiler</a>). Then, you can refer to these files when you use
--   <a>readPandocBiblio</a>. This function also takes the reader options
--   for completeness -- you can use <a>defaultHakyllReaderOptions</a> if
--   you're unsure. <a>pandocBiblioCompiler</a> is a convenience wrapper
--   which works like <a>pandocCompiler</a>, but also takes paths to
--   compiled bibliography and csl files.
module Hakyll.Web.Pandoc.Biblio
data CSL
cslCompiler :: Compiler (Item CSL)
newtype Biblio
Biblio :: [Reference] -> Biblio
biblioCompiler :: Compiler (Item Biblio)
readPandocBiblio :: ReaderOptions -> Item CSL -> Item Biblio -> (Item String) -> Compiler (Item Pandoc)
pandocBiblioCompiler :: String -> String -> Compiler (Item String)
instance Typeable CSL
instance Typeable Biblio
instance Show CSL
instance Show Biblio
instance Writable Biblio
instance Binary Biblio
instance Writable CSL
instance Binary CSL

module Hakyll.Web.Template.Context

-- | Mostly for internal usage
data ContextField
StringField :: String -> ContextField
ListField :: (Context a) -> [Item a] -> ContextField

-- | The <a>Context</a> monoid. Please note that the order in which you
--   compose the items is important. For example in
--   
--   <pre>
--   field "A" f1 &lt;&gt; field "A" f2
--   </pre>
--   
--   the first context will overwrite the second. This is especially
--   important when something is being composed with <a>metadataField</a>
--   (or <a>defaultContext</a>). If you want your context to be overwritten
--   by the metadata fields, compose it from the right:
--   
--   <pre>
--   <a>metadataField</a> &lt;&gt; field "date" fDate
--   </pre>
newtype Context a
Context :: (String -> [String] -> Item a -> Compiler ContextField) -> Context a
unContext :: Context a -> String -> [String] -> Item a -> Compiler ContextField

-- | Constructs a new field in the 'Context.'
field :: String -> (Item a -> Compiler String) -> Context a

-- | Creates a <a>field</a> to use with the <tt>$if()$</tt> template macro.
boolField :: String -> (Item a -> Bool) -> Context a

-- | Creates a <a>field</a> that does not depend on the <a>Item</a>
constField :: String -> String -> Context a
listField :: String -> Context a -> Compiler [Item a] -> Context b
listFieldWith :: String -> Context a -> (Item b -> Compiler [Item a]) -> Context b
functionField :: String -> ([String] -> Item a -> Compiler String) -> Context a
mapContext :: (String -> String) -> Context a -> Context a

-- | A context that contains (in that order)
--   
--   <ol>
--   <li>A <tt>$body$</tt> field<ol><li>Metadata fields</li><li>A
--   <tt>$url$</tt> <a>urlField</a></li><li>A <tt>$path$</tt>
--   <a>pathField</a></li><li>A <tt>$title$</tt>
--   <a>titleField</a></li></ol></li>
--   </ol>
defaultContext :: Context String

-- | Constructs a <a>field</a> that contains the body of the item.
bodyField :: String -> Context String

-- | Map any field to its metadata value, if present
metadataField :: Context a

-- | Absolute url to the resulting item
urlField :: String -> Context a

-- | Filepath of the underlying file of the item
pathField :: String -> Context a

-- | This title <a>field</a> takes the basename of the underlying file by
--   default
titleField :: String -> Context a

-- | When the metadata has a field called <tt>published</tt> in one of the
--   following formats then this function can render the date.
--   
--   <ul>
--   <li><pre>Mon, 06 Sep 2010 00:01:00 +0000</pre></li>
--   <li><pre>Mon, 06 Sep 2010 00:01:00 UTC</pre></li>
--   <li><pre>Mon, 06 Sep 2010 00:01:00</pre></li>
--   <li><pre>2010-09-06T00:01:00+0000</pre></li>
--   <li><pre>2010-09-06T00:01:00Z</pre></li>
--   <li><pre>2010-09-06T00:01:00</pre></li>
--   <li><pre>2010-09-06 00:01:00+0000</pre></li>
--   <li><pre>2010-09-06 00:01:00</pre></li>
--   <li><pre>September 06, 2010 00:01 AM</pre></li>
--   </ul>
--   
--   Following date-only formats are supported too (<tt>00:00:00</tt> for
--   time is assumed)
--   
--   <ul>
--   <li><pre>2010-09-06</pre></li>
--   <li><pre>September 06, 2010</pre></li>
--   </ul>
--   
--   Alternatively, when the metadata has a field called <tt>path</tt> in a
--   <tt>folder/yyyy-mm-dd-title.extension</tt> format (the convention for
--   pages) and no <tt>published</tt> metadata field set, this function can
--   render the date. This pattern matches the file name or directory names
--   that begins with <tt>yyyy-mm-dd</tt> . For example:
--   <tt>folder/<i>yyyy-mm-dd-title</i><i>dist</i>/main.extension</tt> . In
--   case of multiple matches, the rightmost one is used.
dateField :: String -> String -> Context a

-- | This is an extended version of <a>dateField</a> that allows you to
--   specify a time locale that is used for outputting the date. For more
--   details, see <a>dateField</a>.
dateFieldWith :: TimeLocale -> String -> String -> Context a

-- | Parser to try to extract and parse the time from the
--   <tt>published</tt> field or from the filename. See <a>dateField</a>
--   for more information. Exported for user convenience.
getItemUTC :: MonadMetadata m => TimeLocale -> Identifier -> m UTCTime
modificationTimeField :: String -> String -> Context a
modificationTimeFieldWith :: TimeLocale -> String -> String -> Context a

-- | A context with "teaser" key which contain a teaser of the item. The
--   item is loaded from the given snapshot (which should be saved in the
--   user code before any templates are applied).
teaserField :: String -> Snapshot -> Context String

-- | A context with "teaser" key which contain a teaser of the item,
--   defined as the snapshot content before the teaser separator. The item
--   is loaded from the given snapshot (which should be saved in the user
--   code before any templates are applied).
teaserFieldWithSeparator :: String -> String -> Snapshot -> Context String
missingField :: Context a
instance Monoid (Context a)


-- | This module containing some specialized functions to deal with tags.
--   It assumes you follow some conventions.
--   
--   We support two types of tags: tags and categories.
--   
--   To use default tags, use <a>buildTags</a>. Tags are placed in a
--   comma-separated metadata field like this:
--   
--   <pre>
--   ---
--   author: Philip K. Dick
--   title: Do androids dream of electric sheep?
--   tags: future, science fiction, humanoid
--   ---
--   The novel is set in a post-apocalyptic near future, where the Earth and
--   its populations have been damaged greatly by Nuclear...
--   </pre>
--   
--   To use categories, use the <a>buildCategories</a> function. Categories
--   are determined by the directory a page is in, for example, the post
--   
--   <pre>
--   posts/coding/2010-01-28-hakyll-categories.markdown
--   </pre>
--   
--   will receive the <tt>coding</tt> category.
--   
--   Advanced users may implement custom systems using <a>buildTagsWith</a>
--   if desired.
--   
--   In the above example, we would want to create a page which lists all
--   pages in the <tt>coding</tt> category, for example, with the
--   <a>Identifier</a>:
--   
--   <pre>
--   tags/coding.html
--   </pre>
--   
--   This is where the first parameter of <a>buildTags</a> and
--   <a>buildCategories</a> comes in. In the above case, we used the
--   function:
--   
--   <pre>
--   fromCapture "tags/*.html" :: String -&gt; Identifier
--   </pre>
--   
--   The <a>tagsRules</a> function lets you generate such a page for each
--   tag in the <a>Rules</a> monad.
module Hakyll.Web.Tags

-- | Data about tags
data Tags
Tags :: [(String, [Identifier])] -> (String -> Identifier) -> Dependency -> Tags
tagsMap :: Tags -> [(String, [Identifier])]
tagsMakeId :: Tags -> String -> Identifier
tagsDependency :: Tags -> Dependency

-- | Obtain tags from a page in the default way: parse them from the
--   <tt>tags</tt> metadata field.
getTags :: MonadMetadata m => Identifier -> m [String]

-- | Higher-order function to read tags
buildTagsWith :: MonadMetadata m => (Identifier -> m [String]) -> Pattern -> (String -> Identifier) -> m Tags
buildTags :: MonadMetadata m => Pattern -> (String -> Identifier) -> m Tags
buildCategories :: MonadMetadata m => Pattern -> (String -> Identifier) -> m Tags
tagsRules :: Tags -> (String -> Pattern -> Rules ()) -> Rules ()

-- | Render tags in HTML (the flexible higher-order function)
renderTags :: (String -> String -> Int -> Int -> Int -> String) -> ([String] -> String) -> Tags -> Compiler String

-- | Render a tag cloud in HTML
renderTagCloud :: Double -> Double -> Tags -> Compiler String

-- | Render a tag cloud in HTML
renderTagCloudWith :: (Double -> Double -> String -> String -> Int -> Int -> Int -> String) -> ([String] -> String) -> Double -> Double -> Tags -> Compiler String

-- | Render a tag cloud in HTML as a context
tagCloudField :: String -> Double -> Double -> Tags -> Context a

-- | Render a tag cloud in HTML as a context
tagCloudFieldWith :: String -> (Double -> Double -> String -> String -> Int -> Int -> Int -> String) -> ([String] -> String) -> Double -> Double -> Tags -> Context a

-- | Render a simple tag list in HTML, with the tag count next to the item
--   TODO: Maybe produce a Context here
renderTagList :: Tags -> Compiler (String)

-- | Render tags with links
tagsField :: String -> Tags -> Context a

-- | Render tags with links with custom functions to get tags and to render
--   links
tagsFieldWith :: (Identifier -> Compiler [String]) -> (String -> (Maybe FilePath) -> Maybe Html) -> ([Html] -> Html) -> String -> Tags -> Context a

-- | Render the category in a link
categoryField :: String -> Tags -> Context a

-- | Sort tags using supplied function. First element of the tuple passed
--   to the comparing function is the actual tag name.
sortTagsBy :: ((String, [Identifier]) -> (String, [Identifier]) -> Ordering) -> Tags -> Tags

-- | Sample sorting function that compares tags case insensitively.
caseInsensitiveTags :: (String, [Identifier]) -> (String, [Identifier]) -> Ordering
instance Show Tags

module Hakyll.Web.Paginate
type PageNumber = Int

-- | Data about paginators
data Paginate
Paginate :: Map PageNumber [Identifier] -> (PageNumber -> Identifier) -> Dependency -> Paginate
paginateMap :: Paginate -> Map PageNumber [Identifier]
paginateMakeId :: Paginate -> PageNumber -> Identifier
paginateDependency :: Paginate -> Dependency
buildPaginateWith :: MonadMetadata m => ([Identifier] -> m [[Identifier]]) -> Pattern -> (PageNumber -> Identifier) -> m Paginate
paginateEvery :: Int -> [a] -> [[a]]
paginateRules :: Paginate -> (PageNumber -> Pattern -> Rules ()) -> Rules ()

-- | A default paginate context which provides the following keys:
paginateContext :: Paginate -> PageNumber -> Context a
instance Show Paginate


-- | This module provides means for reading and applying <a>Template</a>s.
--   
--   Templates are tools to convert items into a string. They are perfectly
--   suited for laying out your site.
--   
--   Let's look at an example template:
--   
--   <pre>
--   &lt;html&gt;
--       &lt;head&gt;
--           &lt;title&gt;My crazy homepage - $title$&lt;/title&gt;
--       &lt;/head&gt;
--       &lt;body&gt;
--           &lt;div id="header"&gt;
--               &lt;h1&gt;My crazy homepage - $title$&lt;/h1&gt;
--           &lt;/div&gt;
--           &lt;div id="content"&gt;
--               $body$
--           &lt;/div&gt;
--           &lt;div id="footer"&gt;
--               By reading this you agree that I now own your soul
--           &lt;/div&gt;
--       &lt;/body&gt;
--   &lt;/html&gt;
--   </pre>
--   
--   As you can see, the format is very simple -- <tt>$key$</tt> is used to
--   render the <tt>$key$</tt> field from the page, everything else is
--   literally copied. If you want to literally insert <tt>"$key$"</tt>
--   into your page (for example, when you're writing a Hakyll tutorial)
--   you can use
--   
--   <pre>
--   &lt;p&gt;
--       A literal $$key$$.
--   &lt;/p&gt;
--   </pre>
--   
--   Because of it's simplicity, these templates can be used for more than
--   HTML: you could make, for example, CSS or JS templates as well.
--   
--   Apart from interpolating <tt>$key$</tt>s from the <a>Context</a> you
--   can also use the following macros:
--   
--   <ul>
--   <li><pre>$if(key)$</pre></li>
--   </ul>
--   
--   <pre>
--   $if(key)$
--    &lt;b&gt; Defined &lt;/b&gt;
--   $else$
--    &lt;b&gt; Non-defined &lt;/b&gt;
--   $endif$
--   </pre>
--   
--   This example will print <tt>Defined</tt> if <tt>key</tt> is defined in
--   the context and <tt>Non-defined</tt> otherwise. The <tt>$else$</tt>
--   clause is optional.
--   
--   <ul>
--   <li><pre>$for(key)$</pre></li>
--   </ul>
--   
--   The <tt>for</tt> macro is used for enumerating <a>Context</a> elements
--   that are lists, i.e. constructed using the <a>listField</a> function.
--   Assume that in a context we have an element <tt>listField "key" c
--   itms</tt>. Then the snippet
--   
--   <pre>
--   $for(key)$
--     $x$
--   $sep$,
--   $endfor$
--   </pre>
--   
--   would, for each item <tt>i</tt> in <tt>itms</tt>, lookup <tt>$x$</tt>
--   in the context <tt>c</tt> with item <tt>i</tt>, interpolate it, and
--   join the resulting list with <tt>,</tt>.
--   
--   Another concrete example one may consider is the following. Given the
--   context
--   
--   <pre>
--   listField "things" (field "thing" (return . itemBody))
--      (sequence [makeItem "fruits", makeItem "vegetables"])
--   </pre>
--   
--   and a template
--   
--   <pre>
--   I like
--   $for(things)$
--     fresh $thing$$sep$, and 
--   $endfor$
--   </pre>
--   
--   the resulting page would look like
--   
--   <pre>
--   &lt;p&gt;
--    I like
--   
--     fresh fruits, and 
--   
--     fresh vegetables
--   &lt;/p&gt;
--   </pre>
--   
--   The <tt>$sep$</tt> part can be omitted. Usually, you can get by using
--   the <tt>applyListTemplate</tt> and <tt>applyJoinListTemplate</tt>
--   functions.
--   
--   <ul>
--   <li><pre>$partial(path)$</pre></li>
--   </ul>
--   
--   Loads a template located in a separate file and interpolates it under
--   the current context.
--   
--   Assuming that the file <tt>test.html</tt> contains
--   
--   <pre>
--   &lt;b&gt;$key$&lt;/b&gt;
--   </pre>
--   
--   The result of rendering
--   
--   <pre>
--   &lt;p&gt;
--     $partial("test.html")$
--   &lt;/p&gt;
--   </pre>
--   
--   is the same as the result of rendering
--   
--   <pre>
--   &lt;p&gt;
--     &lt;b&gt;$key$&lt;/b&gt;
--   &lt;/p&gt;
--   </pre>
--   
--   That is, calling <tt>$partial$</tt> is equivalent to just copying and
--   pasting template code.
module Hakyll.Web.Template

-- | Datatype used for template substitutions.
data Template

-- | Read a template.
templateCompiler :: Compiler (Item Template)
applyTemplate :: Template -> Context a -> Item a -> Compiler (Item String)

-- | The following pattern is so common:
--   
--   <pre>
--   tpl &lt;- loadBody "templates/foo.html"
--   someCompiler
--       &gt;&gt;= applyTemplate tpl context
--   </pre>
--   
--   That we have a single function which does this:
--   
--   <pre>
--   someCompiler
--       &gt;&gt;= loadAndApplyTemplate "templates/foo.html" context
--   </pre>
loadAndApplyTemplate :: Identifier -> Context a -> Item a -> Compiler (Item String)

-- | It is also possible that you want to substitute <tt>$key$</tt>s within
--   the body of an item. This function does that by interpreting the item
--   body as a template, and then applying it to itself.
applyAsTemplate :: Context String -> Item String -> Compiler (Item String)
readTemplate :: String -> Template


-- | Provides an easy way to combine several items in a list. The
--   applications are obvious:
--   
--   <ul>
--   <li>A post list on a blog</li>
--   <li>An image list in a gallery</li>
--   <li>A sitemap</li>
--   </ul>
module Hakyll.Web.Template.List

-- | Generate a string of a listing of pages, after applying a template to
--   each page.
applyTemplateList :: Template -> Context a -> [Item a] -> Compiler String

-- | Join a listing of pages with a string in between, after applying a
--   template to each page.
applyJoinTemplateList :: String -> Template -> Context a -> [Item a] -> Compiler String

-- | Sort pages chronologically. Uses the same method as <a>dateField</a>
--   for extracting the date.
chronological :: MonadMetadata m => [Item a] -> m [Item a]

-- | The reverse of <a>chronological</a>
recentFirst :: MonadMetadata m => [Item a] -> m [Item a]

-- | Version of <a>chronological</a> which doesn't need the actual items.
sortChronological :: MonadMetadata m => [Identifier] -> m [Identifier]

-- | Version of <a>recentFirst</a> which doesn't need the actual items.
sortRecentFirst :: MonadMetadata m => [Identifier] -> m [Identifier]


-- | A Module that allows easy rendering of RSS feeds.
--   
--   The main rendering functions (<tt>renderRss</tt>, <tt>renderAtom</tt>)
--   all assume that you pass the list of items so that the most recent
--   entry in the feed is the first item in the list.
--   
--   Also note that the context should have (at least) the following fields
--   to produce a correct feed:
--   
--   <ul>
--   <li><tt>$title$</tt>: Title of the item</li>
--   <li><tt>$description$</tt>: Description to appear in the feed</li>
--   <li><tt>$url$</tt>: URL to the item - this is usually set
--   automatically.</li>
--   </ul>
--   
--   In addition, the posts should be named according to the rules for
--   <a>dateField</a>
module Hakyll.Web.Feed

-- | This is a data structure to keep the configuration of a feed.
data FeedConfiguration
FeedConfiguration :: String -> String -> String -> String -> String -> FeedConfiguration

-- | Title of the feed.
feedTitle :: FeedConfiguration -> String

-- | Description of the feed.
feedDescription :: FeedConfiguration -> String

-- | Name of the feed author.
feedAuthorName :: FeedConfiguration -> String

-- | Email of the feed author.
feedAuthorEmail :: FeedConfiguration -> String

-- | Absolute root URL of the feed site (e.g.
--   <tt><a>http://jaspervdj.be</a></tt>)
feedRoot :: FeedConfiguration -> String

-- | Render an RSS feed with a number of items.
renderRss :: FeedConfiguration -> Context String -> [Item String] -> Compiler (Item String)

-- | Render an Atom feed with a number of items.
renderAtom :: FeedConfiguration -> Context String -> [Item String] -> Compiler (Item String)
instance Show FeedConfiguration
instance Eq FeedConfiguration


-- | Top-level module exporting all modules that are interesting for the
--   user
module Hakyll

-- | Given a path to a file, try to make the path writable by making all
--   directories on the path.
makeDirectories :: FilePath -> IO ()

-- | Get all contents of a directory.
getRecursiveContents :: (FilePath -> IO Bool) -> FilePath -> IO [FilePath]
removeDirectory :: FilePath -> IO ()
