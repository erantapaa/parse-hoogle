-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe binary serialization
--   
@package binary-typed
@version 0.2.1.0


-- | Internals, exposed mostly for potential use by testsuites and
--   benchmarks.
--   
--   <b>Not recommended to be used from within other independent
--   libraries.</b>
module Data.Binary.Typed.Internal

-- | A value suitable to be typechecked using the contained extra type
--   information.
data Typed a

-- | Using this data constructor directly is unsafe, as it allows
--   construction of ill-typed <a>Typed</a> data. Use the <a>typed</a>
--   smart constructor unless you really need <a>Typed</a>.
Typed :: TypeInformation -> a -> Typed a

-- | Type information stored alongside a value to be serialized, so that
--   the recipient can do consistency checks. See <a>TypeFormat</a> for
--   more detailed information on the fields.
data TypeInformation
Untyped' :: TypeInformation
Hashed32' :: Hash32 -> TypeInformation
Hashed64' :: Hash64 -> TypeInformation
Shown' :: Hash32 -> String -> TypeInformation
Full' :: TypeRep -> TypeInformation
Cached' :: ByteString -> TypeInformation

-- | A hash value of a <a>TypeRep</a>. Currently a 32-bit value created
--   using the MurmurHash2 algorithm.
newtype Hash32
Hash32 :: Word32 -> Hash32

-- | A hash value of a <a>TypeRep</a>. Currently a 64-bit value created
--   using the MurmurHash2 algorithm.
newtype Hash64
Hash64 :: Word64 -> Hash64

-- | Construct a <a>Typed</a> value using the chosen type format.
--   
--   Example:
--   
--   <pre>
--   value = <a>typed</a> <a>Full</a> ("hello", 1 :: <a>Int</a>, 2.34 :: <a>Double</a>)
--   encded = <a>encode</a> value
--   </pre>
--   
--   The decode site can now verify whether decoding happens with the right
--   type.
typed :: Typeable a => TypeFormat -> a -> Typed a

-- | Create the <a>TypeInformation</a> to be stored inside a <a>Typed</a>
--   value from a <a>TypeRep</a>.
makeTypeInformation :: TypeFormat -> TypeRep -> TypeInformation

-- | Different ways of including/verifying type information of serialized
--   messages.
data TypeFormat

-- | Include no type information.
--   
--   <ul>
--   <li>Requires one byte more compared to using <a>Binary</a> directly
--   (to tag the data as untyped, required for the decoding step).</li>
--   <li>Encoding and decoding require negligible amount of additional
--   computational cost compared to direct (intrinsically untyped)
--   <a>Binary</a>.</li>
--   </ul>
Untyped :: TypeFormat

-- | Compare types by their hash values (using the MurmurHash2 algorithm).
--   
--   <ul>
--   <li>Requires five bytes more compared to using <a>Binary</a> directly
--   for the type information (one to tag as <a>Hashed32</a>, four for the
--   hash value)</li>
--   <li>Subject to false positive due to hash collisions, although in
--   practice this should almost never happen.</li>
--   <li>Type errors cannot tell the provided type ("Expected X, received
--   type with hash H")</li>
--   <li>Computational cost similar to <a>Hashed64</a>.</li>
--   </ul>
Hashed32 :: TypeFormat

-- | Like <a>Hashed32</a>, but uses a 64-bit hash value.
--   
--   <ul>
--   <li>Requires nine bytes more compared to using <a>Binary</a>.</li>
--   <li>Hash collisions are even less likely to occur than with
--   <a>Hashed32</a>.</li>
--   <li>Computational cost similar to <a>Hashed32</a>.</li>
--   </ul>
Hashed64 :: TypeFormat

-- | Compare <a>String</a> representation of types, obtained by calling
--   <a>show</a> on the <a>TypeRep</a>, and also include a hash value (like
--   <a>Hashed32</a>). The former is mostly for readable error messages,
--   the latter provides better collision resistance.
--   
--   <ul>
--   <li>Data size larger than <a>Hashed32</a>, but usually smaller than
--   <a>Full</a>.</li>
--   <li>Both the hash and the shown type must match to satisfy the
--   typechecker.</li>
--   <li>Useful type errors ("expected X, received Y"). All types are shown
--   unqualified though, making <tt>Foo.X</tt> and <tt>Bar.X</tt> look
--   identical in error messages. Remember this when you get a seemingly
--   silly error "expected Foo, but given Foo".</li>
--   </ul>
Shown :: TypeFormat

-- | Compare the full representation of a data type.
--   
--   <ul>
--   <li>More verbose than <tt>Hashed</tt> and <a>Shown</a>. As a rule of
--   thumb, transmitted data is roughly the same as <a>Shown</a>, but all
--   names are fully qualified (package, module, type name).</li>
--   <li>Correct comparison (no false positives). An semi-exception here is
--   when types change between package versions: <tt>package-1.0 Foo.X</tt>
--   and <tt>package-1.1 Foo.X</tt> count as the same type.</li>
--   <li>Useful type errors ("expected X, received Y"). All types are shown
--   unqualified though, making <tt>Foo.X</tt> and <tt>Bar.X</tt> look
--   identical in error messages. Remember this when you get a seemingly
--   silly error "expected Foo, but given Foo".</li>
--   </ul>
Full :: TypeFormat

-- | Extract which <a>TypeFormat</a> was used to create a certain
--   <a>TypeInformation</a>.
--   
--   If the type is <a>Cached'</a>, then the contained information is
--   assumed well-formed. In the public API, this is safe to do, since only
--   well-typed <a>Typed</a> values can be created in the first place.
getFormat :: TypeInformation -> TypeFormat

-- | Typecheck a <a>Typed</a>. Returns the (well-typed) input, or an error
--   message if the types don't work out.
typecheck :: Typeable a => Typed a -> Either String (Typed a)

-- | Extract the value of a <a>Typed</a>, i.e. strip off the explicit type
--   information.
--   
--   This function is safe to use for all <a>Typed</a> values created by
--   the public API, since all construction sites ensure the actual type
--   matches the contained type description.
--   
--   <pre>
--   <a>erase</a> (<a>typed</a> format x) == x
--   </pre>
erase :: Typed a -> a

-- | Sometimes it can be beneficial to serialize the type information in
--   advance, so that the maybe costly serialization step does not have to
--   be repeated on every invocation of <a>encode</a>. Preserialization
--   comes at a price though, as the directly contained <a>ByteString</a>
--   requires its length to be included in the final serialization,
--   yielding a 8-byte overhead for the required <a>Int64</a>, and one for
--   the tag of what was serialized ("shown or full?").
--   
--   This function calculates the serialized version of
--   <a>TypeInformation</a> in cases where the required 9 bytes are
--   negligible (determined by an arbitrary threshold, currently 10*9
--   bytes).
--   
--   Used to make <a>encodeTyped</a> more efficient; the source there also
--   makes a good usage example.
preserialize :: TypeInformation -> TypeInformation

-- | <a>TypeRep</a> without the (internal) fingerprint.
data TypeRep
TypeRep :: TyCon -> [TypeRep] -> TypeRep

-- | Strip a <a>TypeRep</a> off the fingerprint. Inverse of
--   <a>unStripTypeRep</a>.
stripTypeRep :: TypeRep -> TypeRep

-- | Add a fingerprint to a <a>TypeRep</a>. Inverse of <a>stripTypeRep</a>.
unStripTypeRep :: TypeRep -> TypeRep

-- | Hash a <a>TypeRep</a> to a 32-bit digest.
hashType32 :: TypeRep -> Hash32

-- | Hash a <a>TypeRep</a> to a 64-bit digest.
hashType64 :: TypeRep -> Hash64

-- | <a>TyCon</a> without the (internal) fingerprint.
data TyCon

-- | Package, module, constructor name
TyCon :: String -> String -> String -> TyCon

-- | Strip a <a>TyCon</a> off the fingerprint. Inverse of
--   <a>unStripTyCon</a>.
stripTyCon :: TyCon -> TyCon

-- | Add a fingerprint to a <a>TyCon</a>. Inverse of <a>stripTyCon</a>.
unStripTyCon :: TyCon -> TyCon
instance Eq Hash32
instance Ord Hash32
instance Show Hash32
instance Generic Hash32
instance Eq Hash64
instance Ord Hash64
instance Show Hash64
instance Generic Hash64
instance Eq TypeFormat
instance Ord TypeFormat
instance Show TypeFormat
instance Eq TyCon
instance Ord TyCon
instance Generic TyCon
instance Eq TypeRep
instance Ord TypeRep
instance Generic TypeRep
instance Eq TypeInformation
instance Ord TypeInformation
instance Show TypeInformation
instance Generic TypeInformation
instance Datatype D1Hash32
instance Constructor C1_0Hash32
instance Datatype D1Hash64
instance Constructor C1_0Hash64
instance Datatype D1TyCon
instance Constructor C1_0TyCon
instance Datatype D1TypeRep
instance Constructor C1_0TypeRep
instance Datatype D1TypeInformation
instance Constructor C1_0TypeInformation
instance Constructor C1_1TypeInformation
instance Constructor C1_2TypeInformation
instance Constructor C1_3TypeInformation
instance Constructor C1_4TypeInformation
instance Constructor C1_5TypeInformation
instance Hashable64 TyCon
instance Hashable32 TyCon
instance Show TyCon
instance Binary TyCon
instance Hashable64 TypeRep
instance Hashable32 TypeRep
instance Show TypeRep
instance Binary TypeRep
instance (Binary a, Typeable a) => Binary (Typed a)
instance Show a => Show (Typed a)
instance Binary Hash64
instance Binary Hash32
instance Binary TypeInformation


-- | Defines a type-safe <a>Binary</a> instance to ensure data is decoded
--   with the type it was serialized from.
--   
--   For usage information, see the <a>Data.Binary.Typed.Tutorial</a>
--   module.
module Data.Binary.Typed

-- | A value suitable to be typechecked using the contained extra type
--   information.
data Typed a

-- | Construct a <a>Typed</a> value using the chosen type format.
--   
--   Example:
--   
--   <pre>
--   value = <a>typed</a> <a>Full</a> ("hello", 1 :: <a>Int</a>, 2.34 :: <a>Double</a>)
--   encded = <a>encode</a> value
--   </pre>
--   
--   The decode site can now verify whether decoding happens with the right
--   type.
typed :: Typeable a => TypeFormat -> a -> Typed a

-- | Different ways of including/verifying type information of serialized
--   messages.
data TypeFormat

-- | Include no type information.
--   
--   <ul>
--   <li>Requires one byte more compared to using <a>Binary</a> directly
--   (to tag the data as untyped, required for the decoding step).</li>
--   <li>Encoding and decoding require negligible amount of additional
--   computational cost compared to direct (intrinsically untyped)
--   <a>Binary</a>.</li>
--   </ul>
Untyped :: TypeFormat

-- | Compare types by their hash values (using the MurmurHash2 algorithm).
--   
--   <ul>
--   <li>Requires five bytes more compared to using <a>Binary</a> directly
--   for the type information (one to tag as <a>Hashed32</a>, four for the
--   hash value)</li>
--   <li>Subject to false positive due to hash collisions, although in
--   practice this should almost never happen.</li>
--   <li>Type errors cannot tell the provided type ("Expected X, received
--   type with hash H")</li>
--   <li>Computational cost similar to <a>Hashed64</a>.</li>
--   </ul>
Hashed32 :: TypeFormat

-- | Like <a>Hashed32</a>, but uses a 64-bit hash value.
--   
--   <ul>
--   <li>Requires nine bytes more compared to using <a>Binary</a>.</li>
--   <li>Hash collisions are even less likely to occur than with
--   <a>Hashed32</a>.</li>
--   <li>Computational cost similar to <a>Hashed32</a>.</li>
--   </ul>
Hashed64 :: TypeFormat

-- | Compare <a>String</a> representation of types, obtained by calling
--   <a>show</a> on the <a>TypeRep</a>, and also include a hash value (like
--   <a>Hashed32</a>). The former is mostly for readable error messages,
--   the latter provides better collision resistance.
--   
--   <ul>
--   <li>Data size larger than <a>Hashed32</a>, but usually smaller than
--   <a>Full</a>.</li>
--   <li>Both the hash and the shown type must match to satisfy the
--   typechecker.</li>
--   <li>Useful type errors ("expected X, received Y"). All types are shown
--   unqualified though, making <tt>Foo.X</tt> and <tt>Bar.X</tt> look
--   identical in error messages. Remember this when you get a seemingly
--   silly error "expected Foo, but given Foo".</li>
--   </ul>
Shown :: TypeFormat

-- | Compare the full representation of a data type.
--   
--   <ul>
--   <li>More verbose than <tt>Hashed</tt> and <a>Shown</a>. As a rule of
--   thumb, transmitted data is roughly the same as <a>Shown</a>, but all
--   names are fully qualified (package, module, type name).</li>
--   <li>Correct comparison (no false positives). An semi-exception here is
--   when types change between package versions: <tt>package-1.0 Foo.X</tt>
--   and <tt>package-1.1 Foo.X</tt> count as the same type.</li>
--   <li>Useful type errors ("expected X, received Y"). All types are shown
--   unqualified though, making <tt>Foo.X</tt> and <tt>Bar.X</tt> look
--   identical in error messages. Remember this when you get a seemingly
--   silly error "expected Foo, but given Foo".</li>
--   </ul>
Full :: TypeFormat

-- | Extract the value of a <a>Typed</a>, i.e. strip off the explicit type
--   information.
--   
--   This function is safe to use for all <a>Typed</a> values created by
--   the public API, since all construction sites ensure the actual type
--   matches the contained type description.
--   
--   <pre>
--   <a>erase</a> (<a>typed</a> format x) == x
--   </pre>
erase :: Typed a -> a

-- | Modify the value contained in a <a>Typed</a>, keeping the same sort of
--   type representation. In other words, calling <a>mapTyped</a> on
--   something that is typed using <tt>Hashed</tt> will yield a
--   <tt>Hashed</tt> value again.
--   
--   Note: this destroys <tt>precache</tt>d information, so that values
--   have to be <tt>precache</tt>d again if desired. As a consequence,
--   <tt><a>mapTyped</a> <a>id</a></tt> can be used to un-<tt>precache</tt>
--   values.
mapTyped :: Typeable b => (a -> b) -> Typed a -> Typed b

-- | Change the value contained in a <a>Typed</a>, leaving the type
--   representation unchanged. This can be useful to avoid recomputation of
--   the included type information, and can improve performance
--   significantly if many individual messages are serialized.
--   
--   Can be seen as a more efficient <a>mapTyped</a> in case <tt>f</tt> is
--   an endomorphism (i.e. has type <tt>a -&gt; a</tt>).
reValue :: (a -> a) -> Typed a -> Typed a

-- | Change the way a type is represented inside a <a>Typed</a> value.
--   
--   <pre>
--   <a>reType</a> format x = <a>typed</a> format (<a>erase</a> x)
--   </pre>
reType :: Typeable a => TypeFormat -> Typed a -> Typed a

-- | Sometimes it can be beneficial to serialize the type information in
--   advance, so that the maybe costly serialization step does not have to
--   be repeated on every invocation of <a>encode</a>. Preserialization
--   comes at a price though, as the directly contained <a>ByteString</a>
--   requires its length to be included in the final serialization,
--   yielding a 8-byte overhead for the required <a>Int64</a>, and one for
--   the tag of what was serialized ("shown or full?").
--   
--   This function calculates the serialized version of
--   <a>TypeInformation</a> in cases where the required 9 bytes are
--   negligible (determined by an arbitrary threshold, currently 10*9
--   bytes).
--   
--   Used to make <a>encodeTyped</a> more efficient; the source there also
--   makes a good usage example.
preserialize :: TypeInformation -> TypeInformation

-- | Encode a <a>Typeable</a> value to <a>ByteString</a> that includes type
--   information. This function is useful to create specialized typed
--   encoding functions, because the type information is cached and does
--   not need to be recalculated on every serialization.
--   
--   Observationally, <tt><a>encodeTyped</a> format value</tt> is
--   equivalent to <tt><a>encode</a> (<a>typed</a> format value)</tt>.
--   However, <a>encodeTyped</a> does the type information related
--   calculations in advance and shares the results between future
--   invocations of it, making it much more efficient to serialize many
--   values of the same type.
encodeTyped :: (Typeable a, Binary a) => TypeFormat -> a -> ByteString

-- | <i>Deprecated: <a>encodeTyped</a> now caches automatically for all
--   types. Will be removed in 0.3.</i>
encodeTypedLike :: (Typeable a, Binary a) => Typed a -> a -> ByteString

-- | Safely decode data, yielding <a>Either</a> an error <a>String</a> or
--   the value. Equivalent to <a>decodeTypedOrFail</a> stripped of the
--   non-essential data.
--   
--   <pre>
--   encoded = <a>encodeTyped</a> <a>Full</a> ("hello", 1 :: <a>Int</a>, 2.34 :: <a>Double</a>)
--   
--   -- Right &lt;value&gt;:
--   <a>decodeTyped</a> encoded :: <a>Either</a> <a>String</a> (<a>String</a>, <a>Int</a>, <a>Double</a>)
--   
--   -- Left "Type error: expected (Char, Int, Double), got (String, Int, Double)"
--   <a>decodeTyped</a> encoded :: <a>Either</a> <a>String</a> (<a>Char</a>, <a>Int</a>, <a>Double</a>)
--   </pre>
decodeTyped :: (Typeable a, Binary a) => ByteString -> Either String a

-- | Safely decode data, yielding <a>Either</a> an error <a>String</a> or
--   the value, along with meta-information of the consumed binary data.
--   
--   <ul>
--   <li>Typed cousin of <a>decodeOrFail</a>.</li>
--   <li>Like <a>decodeTyped</a>, but with additional data.</li>
--   </ul>
decodeTypedOrFail :: (Typeable a, Binary a) => ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Decode a typed value, throwing an error at runtime on failure. Typed
--   cousin of <a>decode</a>.
--   
--   <pre>
--   encoded = <a>encodeTyped</a> <a>Full</a> ("hello", 1 :: <a>Int</a>, 2.34 :: <a>Double</a>)
--   
--   -- &lt;value&gt;
--   <a>unsafeDecodeTyped</a> encoded :: (<a>String</a>, <a>Int</a>, <a>Double</a>)
--   
--   -- (Descriptive) runtime error
--   <a>unsafeDecodeTyped</a> encoded :: (<a>Char</a>, <a>Int</a>, <a>Double</a>)
--   </pre>
unsafeDecodeTyped :: (Typeable a, Binary a) => ByteString -> a


-- | This meta-module exists only for documentational purposes; the library
--   functionality is found in <a>Data.Binary.Typed</a>.
module Data.Binary.Typed.Tutorial
