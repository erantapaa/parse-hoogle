-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lenses with a southern twang
--   
--   Why yet <i>another</i> lens library? First, none of the existing
--   libraries for Lenses were adequate for my needs (specifically for my
--   use of lenses in <a>pez</a>). And anyway, why not try to create
--   something novel and better?
--   
--   Distinguishing features:
--   
--   <ul>
--   <li>Lenses are parameterized over two Monads (by convention <tt>m</tt>
--   and <tt>w</tt>), and look like <tt>a -&gt; m (b -&gt; w a, b)</tt>.
--   this lets us define lenses for sum types, that perform validation,
--   that do IO (e.g. persist data to disk), etc., etc.</li>
--   <li>a module <a>Data.Yall.Iso</a> that complements <tt>Lens</tt>
--   powerfully</li>
--   <li>a rich set of category-level class instances (for now from
--   <a>categories</a>) for <a>Lens</a> and <a>Iso</a>. These along with
--   the pre-defined primitive lenses and combinators give an interface
--   comparable to Arrow</li>
--   </ul>
--   
--   You should import either <a>Data.Yall</a> or <a>Data.Yall.Lens</a>,
--   and optionally <a>Data.Yall.Iso</a>. <a>Data.Yall</a> is a simplified,
--   but mostly-compatible, version of a subset of <a>Data.Yall.Lens</a>.
--   
--   <i>TODOs</i>:
--   
--   <ul>
--   <li>a module providing template haskell deriving of Lenses</li>
--   <li>pre-define lenses for prelude types, State</li>
--   </ul>
--   
--   <i>CHANGES</i>:
--   
--   <ul>
--   <li>remove <a>setEmpty</a> variants only useful on lenses better
--   expressed in Iso</li>
--   <li>create a class for lens operations, supporting...</li>
--   <li>use newtype wrappers for different monadic lifting schemes</li>
--   <li>better ordering for set, allowing let-floating for partial
--   application</li>
--   </ul>
@package yall
@version 0.2.0.1

module Data.Yall.Iso

-- | An Isomorphism or one-to-one mapping between types. These are very
--   similar to a <tt>Lens</tt>, but are not dependent on context, making
--   them more flexible. The functions also alow a Monadic context,
--   supporting partial isomorphisms, and other interesting functionality.
data Iso w m a b
Iso :: (a -> m b) -> (b -> w a) -> Iso w m a b
apply :: Iso w m a b -> a -> m b
unapply :: Iso w m a b -> b -> w a

-- | See also an Iso wrapped in <tt>Dual</tt>
inverseI :: (Monad m, Monad w) => Iso w m a b -> Iso m w b a

-- | pure Iso
type :<-> a b = Iso Identity Identity a b
iso :: (Monad m, Monad w) => (a -> b) -> (b -> a) -> Iso w m a b

-- | apply the forward function
--   
--   <pre>
--   i $- a = runIdentity $ apply i a
--   </pre>
($-) :: (a :<-> b) -> a -> b

-- | apply the backward function
--   
--   <pre>
--   i -$ b = runIdentity $ unapply i b
--   </pre>
(-$) :: (a :<-> b) -> b -> a

-- | A wrapper for a more <tt>(-&gt;)</tt>-like Functor instances
newtype IsoPure a b
IsoPure :: Iso Identity Identity a b -> IsoPure a b
isoPure :: IsoPure a b -> Iso Identity Identity a b

-- | A more categorical <a>fmap</a>, with wrapping / unwrapping for
--   convenience. See also the <a>Functor</a> instances for <a>Iso</a>.
--   
--   <pre>
--   ifmap = fromPure . C.fmap . IsoPure
--   </pre>
ifmap :: (Monad w, Monad m, Functor f IsoPure IsoPure) => Iso Identity Identity a b -> Iso w m (f a) (f b)

-- | Unwrap and make polymorphic an <a>IsoPure</a>
fromPure :: (Monad w, Monad m) => IsoPure a b -> Iso w m a b
wordsI :: (Monad m, Monad w) => Iso w m String [String]
showI :: (Read s, Show s, Monad w, Monad m) => Iso w m s String
linesI :: (Monad m, Monad w) => Iso w m String [String]
curryI :: (Monad m, Monad w) => Iso w m ((a, b) -> c) (a -> b -> c)
enumI :: (Enum a, Monad m, Monad w) => Iso w m Int a
integerI :: (Integral a, Monad m, Monad w) => Iso w m a Integer
rationalI :: (Real a, Fractional a, Monad m, Monad w) => Iso w m a Rational
zipI :: (Monad m, Monad w) => Iso w m ([a], [b]) [(a, b)]
incrementI :: (Monad m, Monad w, Num a) => Iso w m a a
incrementByI :: (Monad m, Monad w, Num a) => a -> Iso w m a a

-- | Calls <a>fail</a> on the empty list.
consI :: (Monad m, Monad w) => Iso w m (a, [a]) [a]
distributeI :: (Monad m, Monad w) => Iso w m (a, Either b c) (Either (a, b) (a, c))
factorI :: (Monad m, Monad w) => Iso w m (Either (a, b) (a, c)) (a, Either b c)

-- | a partial Isomorphism
type :<~> a b = Iso Maybe Maybe a b
instance Category IsoPure
instance (Monad m, Monad w) => Comonoidal (Iso w m) (,)
instance (Monad m, Monad w) => Monoidal (Iso w m) (,)
instance (Monad m, Monad w) => Symmetric (Iso w m) Either
instance (Monad m, Monad w) => Symmetric (Iso w m) (,)
instance (Monad m, Monad w) => Braided (Iso w m) Either
instance (Monad m, Monad w) => Braided (Iso w m) (,)
instance (Monad m, Monad w) => Disassociative (Iso w m) Either
instance (Monad m, Monad w) => Disassociative (Iso w m) (,)
instance (Monad m, Monad w) => Associative (Iso w m) Either
instance (Monad m, Monad w) => Associative (Iso w m) (,)
instance (Monad m, Monad w) => Bifunctor Either (Iso w m) (Iso w m) (Iso w m)
instance (Monad m, Monad w) => QFunctor Either (Iso w m) (Iso w m)
instance (Monad m, Monad w) => PFunctor Either (Iso w m) (Iso w m)
instance (Monad m, Monad w) => Bifunctor (,) (Iso w m) (Iso w m) (Iso w m)
instance (Monad m, Monad w) => QFunctor (,) (Iso w m) (Iso w m)
instance (Monad m, Monad w) => PFunctor (,) (Iso w m) (Iso w m)
instance Monad m => Functor m (Iso m m) (Iso Identity Identity)
instance Functor f => Functor f IsoPure IsoPure
instance Comonoidal IsoPure (,)
instance Monoidal IsoPure (,)
instance Symmetric IsoPure (,)
instance Symmetric IsoPure Either
instance Braided IsoPure Either
instance Braided IsoPure (,)
instance Disassociative IsoPure Either
instance Disassociative IsoPure (,)
instance Associative IsoPure Either
instance Associative IsoPure (,)
instance Bifunctor Either IsoPure IsoPure IsoPure
instance QFunctor Either IsoPure IsoPure
instance PFunctor Either IsoPure IsoPure
instance Bifunctor (,) IsoPure IsoPure IsoPure
instance QFunctor (,) IsoPure IsoPure
instance PFunctor (,) IsoPure IsoPure
instance (Monad m, Monad w) => Category (Iso w m)

module Data.Yall.Lens
newtype Lens w m a b
Lens :: (a -> m (b -> w a, b)) -> Lens w m a b
runLens :: Lens w m a b -> a -> m (b -> w a, b)

-- | a simple lens, suitable for single-constructor types
type :-> = LensM Identity

-- | Create a pure Lens from a getter and setter
--   
--   <pre>
--   lens g = lensM (fmap return g) . fmap (fmap return)
--   </pre>
lens :: (a -> b) -> (a -> b -> a) -> (a :-> b)

-- | Run the getter function of a pure lens
--   
--   <pre>
--   get l = runIdentity . getM l
--   </pre>
get :: Lens w Identity a b -> a -> b

-- | Run the getter function of a pure lens
--   
--   <pre>
--   set l b = runIdentity . setM l a
--   </pre>
set :: (a :-> b) -> a -> b -> a
modify :: (a :-> b) -> (b -> b) -> a -> a

-- | a lens that can fail in the Maybe monad on the outer type. Suitable
--   for a normal lens on a multi-constructor type. The more general
--   <a>setM</a>, <a>getM</a>, etc. can be used with this type.
type :~> = LensM Maybe

-- | A class for our basic (monadic) lens operations. Minimal complete
--   definition is <a>getM</a> and <a>setM</a>
class Monad m => Lenses l m where modifyM l f a = getM l a >>= setM l a . f
getM :: Lenses l m => l m a b -> a -> m b
setM :: Lenses l m => l m a b -> a -> b -> m a
modifyM :: Lenses l m => l m a b -> (b -> b) -> a -> m a

-- | A lens in which the setter returns its result in the trivial
--   <a>Identity</a> monad. This is appropriate e.g. for traditional
--   partial lenses on sum types, where there is a potential that the lens
--   could fail only on the <i>outer</i> constructor.
type LensM = Lens Identity

-- | Create a monadic lens from a getter and setter
lensM :: Monad m => (a -> m b) -> (a -> m (b -> a)) -> LensM m a b

-- | Create a monadic Lens from a setter and getter.
--   
--   <pre>
--   lensMW g s = Lens $ \a-&gt; liftM2 (,) (s a) (g a)
--   </pre>
lensMW :: Monad m => (a -> m b) -> (a -> m (b -> w a)) -> Lens w m a b

-- | lenses in which set/get should <a>lift</a> the inner monad <tt>w</tt>
--   to <tt>m</tt>
newtype LensLift w m a b
LLift :: (Lens w m a b) -> LensLift w m a b

-- | lenses in which <tt>m</tt> == <tt>w</tt> and we would like to
--   <a>join</a> the two in get/set
newtype LensJoin m a b
LJoin :: (Lens m m a b) -> LensJoin m a b

-- | lenses in which only the setter <tt>w</tt> is monadic
newtype LensW w a b
LW :: (Lens w Identity a b) -> LensW w a b
fstL :: (Monad m, Monad w) => Lens w m (a, b) a
sndL :: (Monad m, Monad w) => Lens w m (a, b) b

-- | codiag from Cartesian
--   
--   <pre>
--   eitherL = id ||| id
--   </pre>
eitherL :: (Monad m, Monad w) => Lens w m (Either a a) a
(|||) :: (Monad m, Monad w) => Lens w m a c -> Lens w m b c -> Lens w m (Either a b) c
factorL :: (Monad m, Monad w) => Lens w m (Either (a, b) (a, c)) (a, Either b c)
distributeL :: (Monad m, Monad w) => Lens w m (a, Either b c) (Either (a, b) (a, c))

-- | Convert an isomorphism <tt>i</tt> to a <a>Lens</a>. When <tt>apply i .
--   unapply i = unapply i . apply i = id</tt>, the resulting lens will be
--   well-behaved.
isoL :: (Monad m, Monad w) => Iso m w a b -> Lens m w a b

-- | Convert to a Lens an isomorphism between a value <tt>a</tt> and a
--   tuple of a value <tt>b</tt> with some "residual" value <tt>r</tt>.
residualL :: (Monad m, Monad w) => Iso m w a (b, r) -> Lens m w a b

-- | <pre>
--   (^$) = get
--   </pre>
(^$) :: Lens w Identity a b -> a -> b

-- | <pre>
--   ma ^&gt;&gt;= l = ma &gt;&gt;= getM l
--   </pre>
(^>>=) :: Lenses l m => m a -> l m a b -> m b
instance (Monad w, Monad m) => Comonoidal (Lens w m) (,)
instance (Monad w, Monad m) => Monoidal (Lens w m) (,)
instance (Monad w, Monad m) => Symmetric (Lens w m) (,)
instance (Monad w, Monad m) => Braided (Lens w m) (,)
instance (Monad w, Monad m) => Disassociative (Lens w m) (,)
instance (Monad w, Monad m) => Associative (Lens w m) (,)
instance (Monad w, Monad m) => HasTerminalObject (Lens w m)
instance Monad m => Functor m (Lens m m) (Lens Identity Identity)
instance (Monad w, Monad m) => Bifunctor (,) (Lens w m) (Lens w m) (Lens w m)
instance (Monad w, Monad m) => QFunctor (,) (Lens w m) (Lens w m)
instance (Monad w, Monad m) => PFunctor (,) (Lens w m) (Lens w m)
instance (Monad w, Monad m) => Category (Lens w m)
instance Monad w => Lenses LensW w
instance Monad m => Lenses LensJoin m
instance (MonadTrans t, Monad (t w), Monad w) => Lenses (LensLift w) (t w)
instance Monad m => Lenses (Lens Identity) m

module Data.Yall

-- | a simple lens, suitable for single-constructor types
type :-> = LensM Identity

-- | Create a pure Lens from a getter and setter
--   
--   <pre>
--   lens g = lensM (fmap return g) . fmap (fmap return)
--   </pre>
lens :: (a -> b) -> (a -> b -> a) -> (a :-> b)

-- | Run the getter function of a pure lens
get :: (a :-> b) -> a -> b

-- | Run the getter function of a pure lens
--   
--   <pre>
--   set l b = runIdentity . setM l a
--   </pre>
set :: (a :-> b) -> a -> b -> a
modify :: (a :-> b) -> (b -> b) -> a -> a

-- | a lens that can fail in the Maybe monad on the outer type. Suitable
--   for a normal lens on a multi-constructor type. The more general
--   <a>setM</a>, <a>getM</a>, etc. can be used with this type.
type :~> = LensM Maybe

-- | Create a partial lens from a getter and setter
lensM :: (a -> Maybe b) -> (a -> Maybe (b -> a)) -> (a :~> b)

-- | Try to run the getter function on a value
getM :: (a :~> b) -> a -> Maybe b

-- | try to run the setter function on an outer and new inner value
setM :: (a :~> b) -> a -> b -> Maybe a

-- | try to modify the inner type of a value
modifyM :: (a :~> b) -> (b -> b) -> a -> Maybe a
