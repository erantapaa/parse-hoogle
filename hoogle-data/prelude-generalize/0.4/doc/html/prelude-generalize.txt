-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Another kind of alternate Prelude file
--   
--   . This is a prelude file with some additional functions and more
--   generalize of some functions, including list operation, monad
--   operation, numbers, bitwise, and a few more compositions. It also
--   imports some other modules.
@package prelude-generalize
@version 0.4

module Prelude.Generalize
bool :: x -> x -> Bool -> x
(<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a
(!!) :: (Copeanoid i, Foldable t) => t x -> i -> x
tail :: MonadLogic m => m x -> m x
length :: (Peanoid i, Foldable t) => t x -> i
filter :: MonadPlus m => (x -> Bool) -> m x -> m x
consA :: Alternative f => x -> f x -> f x
snocA :: Alternative f => x -> f x -> f x
liftPair :: Applicative f => (f x, f y) -> f (x, y)
class Peanoid x
zeroP :: Peanoid x => x
succP :: Peanoid x => x -> x
class Copeanoid x
predP :: Copeanoid x => x -> Maybe x
fair :: MonadLogic m => m (m x) -> m x
(++) :: MonadPlus m => m a -> m a -> m a
iterate :: Alternative f => (x -> x) -> x -> f x
church :: Copeanoid i => i -> (x -> x) -> x -> x
unfoldr :: Alternative f => (b -> Maybe (a, b)) -> b -> f a
convList :: (Alternative f, Foldable t) => t x -> f x
head :: Foldable t => t x -> x
drop :: (Copeanoid i, MonadLogic m) => i -> m x -> m x
take :: (Copeanoid i, MonadLogic m) => i -> m x -> m x
find :: (Alternative f, Foldable t) => (a -> Bool) -> t a -> f a
takeWhile :: MonadLogic m => (x -> Bool) -> m x -> m x
dropWhile :: MonadLogic m => (x -> Bool) -> m x -> m x
tails :: MonadLogic m => m x -> m (m x)
findIndex :: (Peanoid i, Alternative f, Foldable t) => (a -> Bool) -> t a -> f i
option :: Alternative f => x -> f x -> f x
cycle :: Alternative f => f x -> f x
mcycle :: Monoid x => x -> x
repeat :: Alternative f => x -> f x
replicate :: (Copeanoid i, Alternative f) => i -> x -> f x
count :: (Copeanoid i, Applicative f, Alternative g, Traversable g) => i -> f x -> f (g x)
choice :: (Foldable t, Alternative f) => t (f x) -> f x
mreplicate :: (Copeanoid i, Monoid x) => i -> x -> x
(>>==) :: (Functor m, MonadPlus m, Foldable f) => m x -> (x -> f y) -> m y
groupBy :: (Foldable t, Alternative f, Alternative g) => (a -> a -> Bool) -> t a -> f (g a)

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements All
--   the <a>Left</a> elements are extracted in order.
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements
--   All the <a>Right</a> elements are extracted in order.
rights :: [Either a b] -> [b]

-- | Partitions a list of <a>Either</a> into two lists All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
partitionEithers :: [Either a b] -> ([a], [b])
null :: Foldable t => t x -> Bool
unnull :: Foldable t => t x -> Bool
class Swap f
swap :: Swap f => f x y -> f y x
data Peano
atLeast :: Copeanoid i => i -> Peano -> Bool
(.:) :: (Category cat, Functor f) => cat b c -> f (cat a b) -> f (cat a c)
(.::) :: (Category cat, Functor f, Functor g) => cat b c -> f (g (cat a b)) -> f (g (cat a c))
(.:::) :: (Category cat, Functor f, Functor g, Functor h) => cat b c -> f (g (h (cat a b))) -> f (g (h (cat a c)))
bind2 :: Monad m => (x -> y -> m a) -> m x -> m y -> m a
bind3 :: Monad m => (x -> y -> z -> m a) -> m x -> m y -> m z -> m a
(!!!) :: (Copeanoid i, Foldable t, Alternative f) => t x -> i -> f x
transEnum :: (Enum t, Enum u) => t -> u
transInt :: (Integral t, Integral u) => t -> u
low8bits :: (Integral t, Bits t) => t -> Word8
modifyBit :: Bits a => Bool -> a -> Int -> a
getBits :: (Bits t, Integral t, Integral u) => Int -> Int -> t -> u
transPeano :: (Copeanoid i, Peanoid o) => i -> o
class Part1 x where type family Part1T x :: *
get1 :: Part1 x => x -> Part1T x
map1 :: Part1 x => (Part1T x -> y) -> x -> Part1M x y
class Part1 x => Part2 x where type family Part2T x :: *
get2 :: Part2 x => x -> Part2T x
map2 :: Part2 x => (Part2T x -> y) -> x -> Part2M x y
class Part2 x => Part3 x where type family Part3T x :: *
get3 :: Part3 x => x -> Part3T x
map3 :: Part3 x => (Part3T x -> y) -> x -> Part3M x y
class Part3 x => Part4 x where type family Part4T x :: *
get4 :: Part4 x => x -> Part4T x
map4 :: Part4 x => (Part4T x -> y) -> x -> Part4M x y
class Part4 x => Part5 x where type family Part5T x :: *
get5 :: Part5 x => x -> Part5T x
map5 :: Part5 x => (Part5T x -> y) -> x -> Part5M x y
class Part5 x => Part6 x where type family Part6T x :: *
get6 :: Part6 x => x -> Part6T x
map6 :: Part6 x => (Part6T x -> y) -> x -> Part6M x y
class QuestionMarkOp x y z | x y -> z, x z -> y
(?) :: QuestionMarkOp x y z => x -> y -> z
idQMO :: (QuestionMarkOp x y z, x ~ z) => y
selectItems :: [x] -> [Bool] -> [x]
selectBits :: (Bits x, Integral x) => x -> x -> x
hGetByte :: Handle -> IO Word8
hPutByte :: Handle -> Word8 -> IO ()
(>>=||) :: Monad m => m (a, b) -> (a -> b -> m z) -> m z
(>>=|||) :: Monad m => m (a, b, c) -> (a -> b -> c -> m z) -> m z
(>>=|\/) :: Monad m => m (a, b, c, d) -> (a -> b -> c -> d -> m z) -> m z
(>>=\/) :: Monad m => m (a, b, c, d, e) -> (a -> b -> c -> d -> e -> m z) -> m z
azero :: (Applicative f, Monoid x) => f x
aplus :: (Applicative f, Monoid x) => f x -> f x -> f x
concat :: (MonadPlus m, Foldable f) => m (f x) -> m x

-- | <tt>(*) `on` f = \x y -&gt; f x * f y</tt>.
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><tt>(*) `on` <a>id</a> = (*)</tt> (if <tt>(*) ∉ {⊥, <a>const</a>
--   ⊥}</tt>)</li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]
intersperse :: MonadLogic m => x -> m x -> m x
intersperse' :: MonadLogic m => x -> m x -> m x
intercalate :: MonadLogic m => m x -> m (m x) -> m x

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   stripPrefix "foo" "foobar" == Just "bar"
--   stripPrefix "foo" "foo" == Just ""
--   stripPrefix "foo" "barfoo" == Nothing
--   stripPrefix "foo" "barfoobaz" == Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
stripPrefixBy :: (a -> a -> Bool) -> [a] -> [a] -> Maybe [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. Both lists must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool
(\\) :: (MonadLogic m, Foldable t, Eq b) => m b -> t b -> m b

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
nub :: Eq a => [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> [a] -> [a]
deleteF :: MonadLogic m => (x -> Bool) -> m x -> m x
delete :: (Eq x, MonadLogic m) => x -> m x -> m x
group :: (Alternative g, Alternative f, Foldable t, Eq a) => t a -> f (g a)

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the last position where it is still less than
--   or equal to the next element. In particular, if the list is sorted
--   before the call, the result will also be sorted. It is a special case
--   of <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
insert :: Ord a => a -> [a] -> [a]

-- | The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   "dog" `union` "cow" == "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
lcomp :: (Foldable t, Category c) => t (c x x) -> c x x
rcomp :: (Foldable t, Category c) => t (c x x) -> c x x
loeb :: (Function a (f b) b, Functor f) => f a -> f b
class Function f i o | f -> i o
($) :: Function f i o => f -> i -> o
spanList :: ([a] -> Bool) -> [a] -> ([a], [a])
breakList :: ([a] -> Bool) -> [a] -> ([a], [a])
split :: (Alternative f, Eq a) => [a] -> [a] -> f [a]
replace :: Eq a => [a] -> [a] -> [a] -> [a]
subIndex :: (Peanoid i, Alternative f, Eq a) => [a] -> [a] -> f i
instance Eq Peano
instance QuestionMarkOp (Identity x) (x -> a) a
instance QuestionMarkOp (x, y, z) (x -> y -> z -> a) a
instance QuestionMarkOp (x, y) (x -> y -> a) a
instance QuestionMarkOp [x] (a, x -> [x] -> a) a
instance QuestionMarkOp Ordering (a, a, a) a
instance QuestionMarkOp (Maybe x) (a, x -> a) a
instance QuestionMarkOp (Either l r) (l -> a, r -> a) a
instance QuestionMarkOp Bool (a, a) a
instance Part5 (a, b, c, d, e)
instance Part4 (a, b, c, d, e)
instance Part3 (a, b, c, d, e)
instance Part2 (a, b, c, d, e)
instance Part1 (a, b, c, d, e)
instance Part4 (a, b, c, d)
instance Part3 (a, b, c, d)
instance Part2 (a, b, c, d)
instance Part1 (a, b, c, d)
instance Part3 (a, b, c)
instance Part2 (a, b, c)
instance Part1 (a, b, c)
instance Part2 (x, y)
instance Part1 (x, y)
instance Swap Either
instance Swap ((,,,) a b)
instance Swap ((,,) a)
instance Swap (,)
instance (Function f1 i1 o, Function f2 i2 o) => Function (Either f1 f2) (i1, i2) o
instance (Function f1 i1 o1, Function f2 i2 o2, Function f3 i3 o3) => Function (f1, f2, f3) (i1, i2, i3) (o1, o2, o3)
instance (Function f1 i1 o1, Function f2 i2 o2) => Function (f1, f2) (i1, i2) (o1, o2)
instance Function (Kleisli m i o) i (m o)
instance Function f i o => Function [f] [i] [o]
instance Function (i -> o) i o
instance Copeanoid x => Copeanoid (Maybe x)
instance Peanoid x => Peanoid (Maybe x)
instance Copeanoid Peano
instance Peanoid Peano
instance Copeanoid [x]
instance Peanoid x => Peanoid [x]
instance Peanoid ()
instance Peanoid Bool
instance Copeanoid Word32
instance Peanoid Word32
instance Copeanoid Word16
instance Peanoid Word16
instance Copeanoid Word8
instance Peanoid Word8
instance Copeanoid Int64
instance Peanoid Int64
instance Copeanoid Int32
instance Peanoid Int32
instance Copeanoid Int16
instance Peanoid Int16
instance Copeanoid Int
instance Peanoid Int
instance Copeanoid Integer
instance Peanoid Integer
instance Ord Peano
