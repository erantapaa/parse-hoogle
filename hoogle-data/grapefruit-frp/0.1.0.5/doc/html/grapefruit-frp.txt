-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional Reactive Programming core
--   
--   Grapefruit is a library for Functional Reactive Programming (FRP) with
--   a focus on user interfaces. FRP makes it possible to implement
--   reactive and interactive systems in a declarative style. To learn more
--   about FRP, have a look at
--   <a>http://haskell.org/haskellwiki/Functional_Reactive_Programming</a>.
--   
--   This package contains general support for Functional Reactive
--   Programming.
@package grapefruit-frp
@version 0.1.0.5


-- | A setup describes how to initialize and finalize a reactive system.
module FRP.Grapefruit.Setup

-- | A setup describes the initialization and finalization of a reactive
--   system. It is equivalent to an action of type <tt>IO (IO ())</tt>
--   which initializes the system and returns a finalization action.
--   
--   The <a>mempty</a> method of the <a>Monoid</a> instance denotes a setup
--   which does no initialization and no finalization. The <a>mappend</a>
--   method sequences initialization and finalization actions.
data Setup

-- | Converts an I/O action into a setup.
setup :: IO (IO ()) -> Setup

-- | Forms an initialization-only setup from an I/O action.
fromIO :: IO () -> Setup

-- | Converts a setup into an I/O action.
run :: Setup -> IO (IO ())
instance Monoid Setup


-- | This module provides circuits which are descriptions of reactive
--   systems.
module FRP.Grapefruit.Circuit

-- | A circuit describes a reactive system.
--   
--   The <tt>era</tt> parameter denotes the time interval during which the
--   circuit is in existence. It is completely analogous to the era
--   parameters of signal types which are described in the documentation of
--   <a>FRP.Grapefruit.Signal</a>.
--   
--   Input and output of a circuit are typically signals, tuples of signals
--   (with <tt>()</tt> as the corner case) or records of signals as
--   provided by the package grapefruit-records. The era parameters of
--   these signals usually match the <tt>era</tt> parameter of the circuit.
--   
--   A circuit consumes only one input value and produces only one output
--   value. This happens when the circuit is constructed. So the temporal
--   behavior does not come from turning multiple inputs into multiple
--   outputs but from using signals as inputs and outputs.
--   
--   A circuit has the ability to interact with the outside world (that is,
--   perform I/O).
--   
--   The <a>ArrowApply</a> instance of <tt>Circuit era</tt> is currently
--   needed for implementing other parts of Grapefruit. However, it should
--   not be taken for granted that it will remain in future versions. So it
--   is better to not use it outside Grapefruit.
data Circuit era i o

-- | This circuit takes an I/O action when it is constructed, performs this
--   action immediately and outputs its result.
act :: Circuit era (IO output) output

-- | A circuit which triggers initialization and finalization according to
--   a given setup.
putSetup :: Circuit era Setup ()

-- | Creates a circuit.
--   
--   The second argument of <tt>create</tt> is fed into the circuit as its
--   input and the circuit is constructed then. After that, the
--   initialization actions of all setups inserted by <a>putSetup</a> are
--   run. The finalization actions of the setups are chained and returned
--   by <tt>create</tt> together with the output of the circuit.
--   
--   Note that initialization is done completely after circuit creation.
--   This allows outputs of circuits to be generated before they are used
--   for forming circuit inputs. This is important to avoid circular
--   dependencies when <a>loop</a> is used.
create :: (forall era. Circuit era i o) -> i -> IO (o, IO ())


-- | Signals are the key concept of Functional Reactive Programming. They
--   describe behavior over time. This module provides general support for
--   signals. Individual kinds of signals are provided by the submodules
--   <a>FRP.Grapefruit.Signal.Disrete</a>,
--   <a>FRP.Grapefruit.Signal.Segmented</a> and
--   <a>FRP.Grapefruit.Signal.Continuous</a>.
--   
--   A signal type has kind <tt>* -&gt; * -&gt; *</tt>. Its first parameter
--   denotes the time interval in which the signal is alive. This is called
--   the <i>era</i> of the signal. An era is left-closed (contains a
--   starting time) but right-open or right-unbounded (does not contain an
--   ending time).
--   
--   The era type parameter is not intended to be instantiated with
--   concrete types. Instead, it is used to force equality of eras or
--   independence of eras at compile time. Its use is very similar to that
--   of the first type parameter of <a>ST</a> and the first parameter of
--   <a>STRef</a>.
module FRP.Grapefruit.Signal

-- | The class of all signal types.
class Signal signal

-- | This function generates a signal whose behavior switches between that
--   of different other signals over time.
--   
--   Since the result type <tt><a>SignalFun</a> era shape</tt> is
--   isomorphic to an n-ary function type, we can see <tt>switch</tt> as a
--   function which takes a first argument, called the function signal, and
--   <i>n</i> further arguments, called the argument signals, and yields a
--   signal, called the result signal.
--   
--   The result signal is composed of different sections. There is one
--   section for each segment of the function signal. Such a section is
--   formed as follows: For each argument signal, the part which
--   corresponds to the time intervall of the functions signal’s segment is
--   cut out of the argument signal. The value of the function signal is
--   applied to the resulting <i>n</i> signal parts. The result of this
--   application is the desired section of the result signal.
--   
--   The signal functions which are applied to the parts of the argument
--   signals use an universally quantified era parameter. This ensures that
--   the results of these functions do not depend on signals from the
--   outside but only on the parts of the argument signals. This is
--   important since operations on signals require that their argument and
--   result signals are of the same era. The usage of universial
--   quantification in the type of <tt>switch</tt> corresponds to the usage
--   of rank 2 polymorphism in the type of <a>runST</a>.
switch :: SSignal era (forall era'. SignalFun era' shape) -> SignalFun era shape
polySwitch :: SSignal era (PolySignalFun shape) -> SignalFun era shape

-- | A signal function is a function which maps a certain number of signals
--   to one signal whereby all argument signals and the result signal have
--   the same era.
--   
--   The <tt>era</tt> parameter of <tt>SignalFun</tt> denotes the era of
--   all argument signals and the result signal. The <tt>shape</tt>
--   parameter is a phantom parameter which specifies the number of
--   argument signals as well as the types of the argument signals and the
--   result signal without their era parameters. It has the following form:
--   
--   <pre>
--   <i>signal_1</i> `<a>Of</a>` <i>val_1</i> :-&gt; ... :-&gt; <i>signal_n</i> `<a>Of</a>` <i>val_n</i> :-&gt; <i>signal'</i> `<a>Of</a>` <i>val'</i>
--   </pre>
--   
--   The data constructors <a>OSF</a> and <a>SSF</a> construct signal
--   functions of zero and non-zero arity, respectively. (The <tt>O</tt>
--   stands for “zero” and the <tt>S</tt> stands for “successor”.) A signal
--   function is typically formed by an expression like
--   
--   <pre>
--   <a>SSF</a> $ \<i>signal_1</i> -&gt;
--   ...
--   <a>SSF</a> $ \<i>signal_n</i> -&gt;
--   <a>OSF</a> $ <i>signal'</i>
--   </pre>
--   
--   where <tt><i>signal'</i></tt> is an expression that might use
--   <tt><i>signal_1</i></tt> to <tt><i>signal_n</i></tt>. Signal functions
--   are usually applied like this:
--   
--   <pre>
--   <a>unOSF</a> $ <i>signalFun</i> `<a>sfApp</a>` <i>signal_1</i> `<a>sfApp</a>` ... `<a>sfApp</a>` <i>signal_n</i>
--   </pre>
data SignalFun era shape
OSF :: signal era val -> SignalFun era (signal Of val)
SSF :: (signal era val -> SignalFun era shape) -> SignalFun era ((signal Of val) :-> shape)

-- | Converts a nullary signal function into its corresponding signal.
unOSF :: SignalFun era (signal Of val) -> signal era val

-- | Converts a signal function of non-zero arity into a true function.
unSSF :: SignalFun era ((signal Of val) :-> shape) -> (signal era val -> SignalFun era shape)

-- | Applies a signal function to a signal.
--   
--   <tt>sfApp</tt> is equivalent to <a>unSSF</a>.
sfApp :: SignalFun era ((signal Of val) :-> shape) -> signal era val -> SignalFun era shape

-- | The <tt>:-&gt;</tt> operator is used to form signal function shapes
--   for <a>SignalFun</a>. The shape <tt><i>argShape</i> :-&gt;
--   <i>resultShape</i></tt> stands for functions which map signals of
--   shape <tt><i>argShape</i></tt> to signal functions of shape
--   <tt><i>resultShape</i></tt>.
data (:->) argShape resultShape
newtype PolySignalFun shape
PolySignalFun :: (forall era. SignalFun era shape) -> PolySignalFun shape

-- | <tt>Of</tt> is used to form signal shapes. Signal shapes are used as
--   phantom types and denote a signal type except its era parameter.
--   
--   A signal shape <tt><i>signal</i> `Of` <i>val</i></tt> stands for a
--   signal of type <tt><i>signal</i> <i>era</i> <i>val</i></tt> where the
--   era parameter is provided by an external source. Signal shapes are
--   used as signal function shapes of nullary functions and as argument
--   shapes for <tt>:-&gt;</tt>. In this case, the era parameter is the era
--   parameter of <a>SignalFun</a>. Signal shapes are also used in records
--   as defined by the module <tt>FRP.Grapefruit.Record</tt> of package
--   grapefruit-records.
data Of (signal :: * -> * -> *) val

-- | The class of all signals which can be seen as discrete sequences of
--   values. Such signals can be used to sample signals of class
--   <a>Samplee</a>.
class Sampler sampler

-- | The class of all signals which assign a value to each time of their
--   era. Such signals can be sampled by signals of class <a>Sampler</a>.
class Samplee samplee

-- | Sampling of signals.
--   
--   A signal <tt><i>sampler</i> &lt;#&gt; <i>samplee</i></tt> has a value
--   at each time where <tt><i>sampler</i></tt> has a value. The value of
--   <tt><i>sampler</i> &lt;#&gt; <i>samplee</i></tt> is formed by applying
--   the value of <tt><i>sampler</i></tt> to the value,
--   <tt><i>samplee</i></tt> has at this time.
--   
--   This function has similarities with <a>&lt;*&gt;</a>.
(<#>) :: (Sampler sampler, Samplee samplee) => sampler era (val -> val') -> samplee era val -> sampler era val'

-- | Sampling of signals where the values of the sampler are ignored.
--   
--   The following equation holds:
--   
--   <pre>
--   <i>sampler</i> #&gt; <i>samplee</i> = id <a>&lt;$</a> <i>sampler</i> <a>&lt;#&gt;</a> <i>samplee</i>
--   </pre>
--   
--   This function has similarities with <a>*&gt;</a>.
(#>) :: (Sampler sampler, Samplee samplee) => sampler era dummy -> samplee era val -> sampler era val

-- | Sampling of signals where the values of the samplee are ignored.
--   
--   The following equation holds:
--   
--   <pre>
--   <i>sampler</i> &lt;# <i>samplee</i> = const <a>&lt;$&gt;</a> <i>sampler</i> <a>&lt;#&gt;</a> <i>samplee</i>
--   </pre>
--   
--   This function has similarities with <a>&lt;*</a>.
(<#) :: (Sampler sampler, Samplee samplee) => sampler era val -> samplee era dummy -> sampler era val

-- | A consumer says what to do with a given signal.
newtype Consumer signal val

-- | A consumer, represented by a circuit that consumes a signal.
Consumer :: (forall era. Circuit era (signal era val) ()) -> Consumer signal val

-- | Yields a circuit which consumes a signal.
consume :: Consumer signal val -> Circuit era (signal era val) ()

-- | A producer says how to produce a certain signal.
newtype Producer signal val

-- | A producer, represented by a circuit that produces a signal.
Producer :: (forall era. Circuit era () (signal era val)) -> Producer signal val

-- | Yields a circuit which produces a signal.
produce :: Producer signal val -> Circuit era () (signal era val)


-- | This module is about continuous signals.
--   
--   For a general introduction to signals, see the documentation of
--   <a>FRP.Grapefruit.Signal</a>.
module FRP.Grapefruit.Signal.Continuous

-- | The type of continuous signals.
--   
--   A continuous signal denotes a mapping from times to values. You can
--   think of <tt>CSignal <i>era</i> <i>val</i></tt> as being equivalent to
--   <tt>Time <i>era</i> -&gt; <i>val</i></tt> where <tt>Time
--   <i>era</i></tt> is the type of all times of the given era.
--   
--   Continuous signals are used to describe continuously changing values.
--   They are also used for values changing at discrete times if there is
--   no possibility of being notified about such changes. If there is a
--   notification mechanism then segemented signals, provided by
--   <a>FRP.Grapefruit.Signal.Segmented</a>, should be used.
data CSignal era val

-- | Converts a segmented signal into a continous signal, dropping the
--   information about update points.
fromSSignal :: SSignal era val -> CSignal era val

-- | Converts a value read action into a continuous signal producer.
--   
--   The producer <tt>producer <i>readVal</i></tt> produces a continuous
--   signal whose current value is determined by executing
--   <tt><i>readVal</i></tt>.
producer :: IO val -> Producer CSignal val
instance Samplee CSignal
instance Signal CSignal
instance Applicative (CSignal era)
instance Functor (CSignal era)


-- | This module is about segmented signals.
--   
--   For a general introduction to signals, see the documentation of
--   <a>FRP.Grapefruit.Signal</a>.
module FRP.Grapefruit.Signal.Segmented

-- | The type of segmented signals.
--   
--   A segmented signal maps times to values like a continuous signal.
--   However, it also comprises a set of discrete times, called <i>update
--   points</i>. The signal can only change its value at its update points.
--   As a special case, the starting time of the era is always considered
--   an update point. So a segmented signal is composed of constant
--   segments which are either bounded by adjacent update points or
--   left-bounded by a last update point and right-unbounded. Note that
--   value updates already take effect at the update point so that the
--   segments are left-closed.
--   
--   It follows that a segmented signal is completely determined by the
--   update points and the values assigned to them. Therefore, a segmented
--   signal can also be seen as a kind of discrete signal with occurences
--   at the update points. The only difference to a discrete signal is that
--   a segmented signal always has an occurence at the starting time of the
--   era whereas a discrete signal never has one.
--   
--   The dual nature of segmented signals is reflected by the class
--   instances of <tt>SSignal</tt>. <tt>SSignal</tt> is an instance of
--   <a>Samplee</a> as well as of <a>Sampler</a>. The first means that it
--   can be sampled and therefore has a continuous aspect. The second means
--   that it can be used to sample a signal and therefore has a discrete
--   aspect.
data SSignal era val

-- | Constructs a segmented signal from an initial value and a series of
--   updates.
--   
--   A signal <tt>construct <i>init</i> <i>upd</i></tt> has initially the
--   value <tt><i>init</i></tt>. At each occurence in <tt><i>upd</i></tt>,
--   it has an update point and changes its value to the value occuring in
--   <tt><i>upd</i></tt>. If the segmented signal is interpreted as a kind
--   of discrete signal, <tt>fromInitAndUpdate</tt> just adds an initial
--   occurence of <tt><i>init</i></tt> to the signal <tt><i>upd</i></tt>.
construct :: val -> DSignal era val -> SSignal era val

-- | Same as <a>construct</a>.

-- | <i>Deprecated: fromInitAndUpdate is replaced by construct. </i>
fromInitAndUpdate :: val -> DSignal era val -> SSignal era val

-- | Applies the second argument to the initial value of the first
--   argument.
--   
--   Using <tt>withInit</tt>, it is possible to create a signal which is
--   dependent on the initial value of a segmented signal but it is not
--   possible to extract the initial value itself. The reason for this
--   restriction is that the initial value may depend on values of
--   continuous signals and therefore its calculation might involve doing
--   I/O to read external continuous sources.
withInit :: Signal signal => SSignal era val -> (val -> signal era val') -> signal era val'

-- | Yields the sequence of updates of a segmented signal.
--   
--   If the segmented signal is interpreted as a discrete signal with an
--   additional occurence at the start then <tt>update</tt> just drops this
--   occurence.
updates :: SSignal era val -> DSignal era val

-- | Accumulates the values of a discrete signal.
--   
--   Applying <tt>scan <i>init</i> <i>fun</i></tt> to a discrete signal
--   replaces its occurence values <tt><i>val_1</i></tt>,
--   <tt><i>val_2</i></tt> and so on by the values <tt><i>init</i>
--   `<i>fun</i>` <i>val_1</i></tt>, <tt>(<i>init</i> `<i>fun</i>`
--   <i>val_1</i>) `<i>fun</i>` <i>val_2</i></tt> and so on and adds an
--   occurence of the value <tt><i>init</i></tt> at the beginning.
scan :: accu -> (accu -> val -> accu) -> (DSignal era val -> SSignal era accu)

-- | Converts an event handler into a segmented signal consumer.
--   
--   If a segmented signal is consumed with such a consumer, the handler is
--   called at the starting time of the era and at each update with the
--   current value of the signal as its argument. If the segmented signal
--   is seen as a discrete signal with an additional occurence at the start
--   then <tt>consumer</tt> behaves analogous to the <a>consumer</a>
--   function of <a>FRP.Grapefruit.Signal.Discrete</a>.
consumer :: (val -> IO ()) -> Consumer SSignal val

-- | Converts a value read action and a change event handler registration
--   into a segmented signal producer.
producer :: IO val -> (IO () -> Setup) -> Producer SSignal val


-- | This module is about discrete signals.
--   
--   For a general introduction to signals, see the documentation of
--   <a>FRP.Grapefruit.Signal</a>.
module FRP.Grapefruit.Signal.Discrete

-- | The type of discrete signals.
--   
--   A discrete signal is a sequence of values assigned to discrete times.
--   A pair of a time and a corresponding value is called an occurrence.
--   You can think of <tt>DSignal <i>era</i> <i>val</i></tt> as being
--   equivalent to <tt><a>Map</a> (Time <i>era</i>) <i>val</i></tt> where
--   <tt>Time <i>era</i></tt> is the type of all times of the given era.
--   However, an occurence at the starting time of the era is not possible.
--   In contrast to <a>Map</a>, a discrete signal may cover infinitely many
--   values.
--   
--   Discrete signals can describe sequences of events. For example, the
--   sequence of all key presses could be described by a discrete signal of
--   characters. Discrete signals are also used in conjunction with
--   sampling.
--   
--   The discrete signal instances of <a>Functor</a> and <a>Monoid</a>
--   provide the following method definitions:
--   
--   <pre>
--   <a>fmap</a>    = <a>map</a>
--   <a>mempty</a>  = <a>empty</a>
--   <a>mappend</a> = <a>union</a>
--   <a>mconcat</a> = <a>unions</a>
--   </pre>
data DSignal era val

-- | A signal with no occurrences.
empty :: DSignal era val

-- | Constructs the left-biased union of two discrete signals.
--   
--   <tt>union</tt> is equivalent to <tt><a>unionWith</a> const</tt>.
union :: DSignal era val -> DSignal era val -> DSignal era val

-- | Constructs the union of two discrete signals, combining simultaneously
--   occuring values via a combining function.
--   
--   <tt>unionWith</tt> is equivalent to <tt><a>transUnion</a> id id</tt>.
unionWith :: (val -> val -> val) -> (DSignal era val -> DSignal era val -> DSignal era val)

-- | Union with conversion and combination.
--   
--   At each time, a signal <tt><i>dSignal1</i></tt> or a signal
--   <tt><i>dSignal2</i></tt> has an occurence, the signal
--   
--   <pre>
--   transUnion <i>conv1</i> <i>conv2</i> <i>comb</i> <i>dSignal1</i> <i>dSignal2</i>
--   </pre>
--   
--   has an occurence, too. The value of this occurence is formed as
--   follows:
--   
--   <ul>
--   <li><i><tt><i>conv1</i> <i>val1</i></tt></i> if
--   <tt><i>dSignal1</i></tt> has an occurence of value
--   <tt><i>val1</i></tt> and <tt><i>dSignal2</i></tt> has no
--   occurence</li>
--   <li><i><tt><i>conv2</i> <i>val2</i></tt></i> if
--   <tt><i>dSignal2</i></tt> has an occurence of value
--   <tt><i>val2</i></tt> and <tt><i>dSignal1</i></tt> has no
--   occurence</li>
--   <li><i><tt><i>comb</i> <i>val1</i> <i>val2</i></tt></i> if
--   <tt><i>dSignal1</i></tt> has an occurence of value
--   <tt><i>val1</i></tt> and <tt><i>dSignal2</i></tt> has an occurence of
--   value <tt><i>val2</i></tt></li>
--   </ul>
transUnion :: (val1 -> val') -> (val2 -> val') -> (val1 -> val2 -> val') -> (DSignal era val1 -> DSignal era val2 -> DSignal era val')

-- | Repeated left-biased union.
--   
--   <tt>unions</tt> is equivalent to <tt>foldl <a>union</a>
--   <a>empty</a></tt> and <tt><a>unionsWith</a> const</tt>.
unions :: [DSignal era val] -> DSignal era val

-- | Repeated union with a combining function.
--   
--   <tt>unionsWith <i>comb</i></tt> is equivalent to <tt>foldl
--   (<a>unionWith</a> <i>comb</i>) <a>empty</a></tt>.
unionsWith :: (val -> val -> val) -> [DSignal era val] -> DSignal era val

-- | Constructs the difference of two discrete signals.
--   
--   <tt>difference</tt> is equivalent to <tt><a>differenceWith</a> (\_ _
--   -&gt; Nothing)</tt>.
difference :: DSignal era val1 -> DSignal era val2 -> DSignal era val1

-- | Constructs a kind of difference of two discrete signals where
--   occurences may be modified instead of being dropped.
--   
--   At each time, a signal <tt><i>dSignal1</i></tt> has an occurence of a
--   value <tt><i>val1</i></tt>, the signal <tt>differenceWith <i>comb</i>
--   <i>dSignal1</i> <i>dSignal</i></tt> has
--   
--   <ul>
--   <li><i>an occurence of <tt><i>val1</i></tt></i> if
--   <tt><i>dSignal2</i></tt> has no occurence</li>
--   <li><i>an occurence of <tt><i>val'</i></tt></i> if
--   <tt><i>dSignal2</i></tt> has an occurence of a value
--   <tt><i>val2</i></tt> and <tt><i>comb</i> <i>val1</i> <i>val2</i> =
--   Just <i>val'</i></tt></li>
--   <li><i>no occurence</i> if <tt><i>dSignal2</i></tt> has an occurence
--   of a value <tt><i>val2</i></tt> and <tt><i>comb</i> <i>val1</i>
--   <i>val2</i> = Nothing</tt></li>
--   </ul>
differenceWith :: (val1 -> val2 -> Maybe val1) -> (DSignal era val1 -> DSignal era val2 -> DSignal era val1)

-- | Constructs the left-biased intersection of two discrete signals.
--   
--   <tt>intersection</tt> is equivalent to <tt><a>intersectionWith</a>
--   const</tt>.
intersection :: DSignal era val1 -> DSignal era val2 -> DSignal era val1

-- | Constructs the intersection of two discrete signals, combining values
--   via a combining function.
intersectionWith :: (val1 -> val2 -> val') -> (DSignal era val1 -> DSignal era val2 -> DSignal era val')

-- | Converts each value occuring in a discrete signal by applying a
--   function to it.
map :: (val -> val') -> (DSignal era val -> DSignal era val')

-- | Drops all occurence of a discrete signal whose values do not fulfill a
--   given predicate.
filter :: (val -> Bool) -> (DSignal era val -> DSignal era val)

-- | Converts all occurences with values of the form <tt>Just
--   <i>val</i></tt> into occurences with value <tt><i>val</i></tt> and
--   drops all occurences with value <tt>Nothing</tt>.
catMaybes :: DSignal era (Maybe val) -> DSignal era val

-- | The combination of <a>map</a> and <a>catMaybes</a>.
--   
--   <tt>mapMaybe <i>fun</i></tt> is equivalent to <tt><a>catMaybes</a> .
--   <a>map</a> <i>fun</i></tt>.
mapMaybe :: (val -> Maybe val') -> (DSignal era val -> DSignal era val')

-- | Accumulates the values of a discrete signal, starting with a given
--   initial value.
--   
--   Applying <tt>scan <i>init</i> <i>fun</i></tt> to a discrete signal
--   replaces its occurence values <tt><i>val_1</i></tt>,
--   <tt><i>val_2</i></tt> and so on by the values <tt><i>init</i>
--   `<i>fun</i>` <i>val_1</i></tt>, <tt>(<i>init</i> `<i>fun</i>`
--   <i>val_1</i>) `<i>fun</i>` <i>val_2</i></tt> and so on.
scan :: accu -> (accu -> val -> accu) -> (DSignal era val -> DSignal era accu)

-- | Accumulates the values of a discrete signal, starting with the first
--   occuring value.
--   
--   Applying <tt>scan1 <i>init</i> <i>fun</i></tt> to a discrete signal
--   replaces its occurence values <tt><i>val_1</i></tt>,
--   <tt><i>val_2</i></tt>, <tt><i>val_3</i></tt> and so on by the values
--   <tt><i>val_1</i></tt>, <tt><i>val_1</i> `<i>fun</i>`
--   <i>val_2</i></tt>, <tt>(<i>val_1</i> `<i>fun</i>` <i>val_2</i>)
--   `<i>fun</i>` <i>val_3</i></tt> and so on.
scan1 :: (val -> val -> val) -> (DSignal era val -> DSignal era val)

-- | Constructs a discrete signal by repeatedly applying state
--   transformers.
--   
--   Applying <tt>stateful <i>init</i></tt> to a discrete signal replaces
--   its occurence values <tt><i>trans_1</i></tt>, <tt><i>trans_2</i></tt>,
--   <tt><i>trans_3</i></tt> and so on by the values <tt>fst .
--   <i>trans_1</i> $ <i>init</i></tt>, <tt>fst . <i>trans_2</i> $ snd .
--   <i>trans_1</i> $ <i>init</i></tt>, <tt>fst . <i>trans_3</i> $ snd .
--   <i>trans_2</i> $ snd . <i>trans_1</i> $ <i>init</i></tt> and so on.
stateful :: state -> DSignal era (state -> (val, state)) -> DSignal era val

-- | Converts an event handler into a discrete signal consumer.
--   
--   If a discrete signal is consumed with such a consumer, the handler is
--   called at each occurence with the occuring value as its argument.
consumer :: (val -> IO ()) -> Consumer DSignal val

-- | Converts an event handler registration into a discrete signal
--   producer.
--   
--   Applying the argument of <tt>producer</tt> to an event handler has to
--   yield a setup which makes the handler be called with a certain value
--   everytime the produced signal shall have an occurence of this value.
producer :: ((val -> IO ()) -> Setup) -> Producer DSignal val

module FRP.Grapefruit.Signal.Incremental
data ISignal era val
class Semigroup (Diff val) => Incremental val where data family Diff val :: * type family ValidationState val :: *
patch :: Incremental val => val -> Diff val -> val
validationInit :: Incremental val => val -> ValidationState val
validationStep :: Incremental val => Diff val -> ValidationState val -> Maybe (ValidationState val)
newtype Monolithic val
Monolithic :: val -> Monolithic val
construct :: Incremental val => val -> DSignal era (Diff val) -> ISignal era val
withInit :: Signal signal => ISignal era val -> (val -> signal era val') -> signal era val'
updates :: ISignal era val -> DSignal era (Diff val)
toSSignal :: Incremental val => ISignal era val -> SSignal era val
monolithicFromSSignal :: SSignal era val -> ISignal era (Monolithic val)
monolithicToSSignal :: ISignal era (Monolithic val) -> SSignal era val
const :: Incremental val => val -> ISignal era val
map :: (Incremental val, Incremental val') => (val -> (val', state)) -> (Diff val -> state -> (Diff val', state)) -> (ISignal era val -> ISignal era val')
combine :: (Incremental val1, Incremental val2, Incremental val') => (val1 -> val2 -> (val', state)) -> (Diff val1 -> state -> (Diff val', state)) -> (Diff val2 -> state -> (Diff val', state)) -> (ISignal era val1 -> ISignal era val2 -> ISignal era val')
consumer :: (val -> IO ()) -> (Diff val -> IO ()) -> Consumer ISignal val
instance Incremental (Monolithic val)
instance Semigroup (Diff (Monolithic val))

module FRP.Grapefruit.Signal.Incremental.Sequence
data AtomicDiff el
Insertion :: Int -> (Seq el) -> AtomicDiff el
Deletion :: Int -> Int -> AtomicDiff el
Shift :: Int -> Int -> Int -> AtomicDiff el
Update :: Int -> (Seq el) -> AtomicDiff el
insertion :: Int -> Seq el -> Diff (Seq el)
deletion :: Int -> Int -> Diff (Seq el)
shift :: Int -> Int -> Int -> Diff (Seq el)
update :: Int -> Seq el -> Diff (Seq el)
elementInsertion :: Int -> el -> Diff (Seq el)
elementDeletion :: Int -> Diff (Seq el)
elementShift :: Int -> Int -> Diff (Seq el)
elementUpdate :: Int -> el -> Diff (Seq el)
empty :: ISignal era (Seq a)
singleton :: SSignal era el -> ISignal era (Seq el)
(<|) :: SSignal era el -> ISignal era (Seq el) -> ISignal era (Seq el)
(|>) :: ISignal era (Seq el) -> SSignal era el -> ISignal era (Seq el)
(><) :: ISignal era (Seq el) -> ISignal era (Seq el) -> ISignal era (Seq el)
null :: ISignal era (Seq el) -> SSignal era Bool
length :: ISignal era (Seq el) -> SSignal era Int
map :: SSignal era (el -> el') -> ISignal era (Seq el) -> ISignal era (Seq el')
staticMap :: (el -> el') -> ISignal era (Seq el) -> ISignal era (Seq el')
filter :: SSignal era (el -> Bool) -> ISignal era (Seq el) -> ISignal era (Seq el)
staticFilter :: (el -> Bool) -> ISignal era (Seq el) -> ISignal era (Seq el)
reverse :: ISignal era (Seq el) -> ISignal era (Seq el)
instance Monoid (Diff (Seq el))
instance Semigroup (Diff (Seq el))
instance Incremental (Seq el)

module FRP.Grapefruit.Signal.Incremental.Set
insertion :: Ord el => Set el -> Diff (Set el)
deletion :: Ord el => Set el -> Diff (Set el)
elementInsertion :: el -> Diff (Set el)
elementDeletion :: el -> Diff (Set el)
empty :: Ord el => ISignal era (Set el)
singleton :: Ord el => SSignal era el -> ISignal era (Set el)
toSeqs :: Ord el => ISignal era (Set el) -> ISignal era (Seq el)
toAscSeqs :: Ord el => ISignal era (Set el) -> ISignal era (Seq el)
union :: Ord el => ISignal era (Set el) -> ISignal era (Set el) -> ISignal era (Set el)
difference :: Ord el => ISignal era (Set el) -> ISignal era (Set el) -> ISignal era (Set el)
intersection :: Ord el => ISignal era (Set el) -> ISignal era (Set el) -> ISignal era (Set el)
null :: Ord el => ISignal era (Set el) -> SSignal era Bool
size :: Ord el => ISignal era (Set el) -> SSignal era Int
member :: Ord el => SSignal era el -> ISignal era (Set el) -> SSignal era Bool
staticMember :: Ord el => el -> ISignal era (Set el) -> SSignal era Bool
notMember :: Ord el => SSignal era el -> ISignal era (Set el) -> SSignal era Bool
staticNotMember :: Ord el => el -> ISignal era (Set el) -> SSignal era Bool
instance Ord el => Monoid (Diff (Set el))
instance Ord el => Semigroup (Diff (Set el))
instance Ord el => Incremental (Set el)
