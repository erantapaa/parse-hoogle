-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Modular type class machinery for monad transformer stacks.
--   
--   The <tt>layers</tt> package provides the type class machinery needed
--   to make monads built out of stacks of monad transformers easy to use.
--   It introduces the concept of monad layers, which are a generalisation
--   of monad transformers. The type class machinery provided by and the
--   design patterns suggested by <tt>layers</tt> allow for much more
--   modularity than is possible with the existing type class machinery and
--   design patterns. With <tt>layers</tt> it is possible to use arbitrary
--   monad interfaces (monad interfaces are what we call the sort of type
--   classes that you see in the <tt>mtl</tt> and similar packages) with
--   arbtirary monad transformers (by monad transformers here, we are
--   specifically to monad constructors, such as the ones defined in
--   <tt>transformers</tt>), without ever having to explicitly define how
--   to lift specific interfaces through specific transformers.
--   
--   <tt>layers</tt> improves upon and/or replaces, in part or in whole,
--   the following list of packages: <tt>transformers</tt>, <tt>mtl</tt>,
--   <tt>mmtl</tt>, <tt>transformers-base</tt>, <tt>monad-control</tt>,
--   <tt>lifted-base</tt>, <tt>monad-peel</tt>,
--   <tt>MonadCatchIO-transformers</tt>, <tt>MonadCatchIO-mtl</tt>,
--   <tt>exception-transformers</tt>, <tt>monad-abort-fd</tt> and probably
--   more too. There have been many attempts to either improve upoin or
--   work around the deficiencies of the existing type class machinery for
--   monad transformer stacks, but we believe <tt>layers</tt> is the most
--   complete of any of these so far.
--   
--   A comprehensive overview of the motivation behind <tt>layers</tt> and
--   an explanation of the design decisions taken is given in
--   <a>Documentation.Layers.Overview</a>. It is <i>highly recommended</i>
--   that you read this if you are considering using this package. The core
--   type classes of the package are defined in <a>Control.Monad.Layer</a>
--   (this can be thought of as equivalent to or a replacement of
--   <a>Control.Monad.Trans.Class</a> from <tt>transformers</tt>). The rest
--   of the modules in this package export monad interfaces, in the
--   <a>Control.Monad.Interface</a> hierarchy, including replacements for
--   all of the monad interfaces of the <tt>mtl</tt> package.
@package layers
@version 0.1


-- | This module is the core of the <tt>layers</tt> package. It exports:
--   
--   <ol>
--   <li>The type classes <a>MonadLayer</a>, <a>MonadLayerFunctor</a> and
--   <a>MonadLayerControl</a> and instances of these classes for the
--   transformers in the <tt>transformers</tt> package.</li>
--   <li>The type classes <a>MonadTrans</a>, <a>MonadTransFunctor</a> and
--   <a>MonadTransControl</a> and instances of these classes for the
--   transformers in the <tt>transformers</tt> package.</li>
--   <li>The type classes <a>MonadLift</a>, <a>MonadLiftFunctor</a> and
--   <a>MonadLiftControl</a>.</li>
--   <li>Two sets of helper functions inspired by similarly named functions
--   in the <tt>monad-control</tt> package: one for instances of
--   <tt>MonadLayerControl</tt> and the other for instances of
--   <tt>MonadLiftControl</tt>. These operations are: <a>controlLayer</a>,
--   <a>layerOp</a>, <a>layerOp_</a> and <a>layerDiscard</a> and
--   <a>control</a>, <a>liftOp</a>, <a>liftOp_</a> and <a>liftDiscard</a>
--   respectively.</li>
--   </ol>
module Control.Monad.Layer

-- | A monad <tt>m</tt> can be an instance of <a>MonadLayer</a> if it is
--   built ("layered") on top of some inner monad (<tt><a>Inner</a> m</tt>)
--   and can provide the operations <a>layer</a> and <a>layerInvmap</a>.
--   
--   Monad layers are a generalisation of monad transformers, with the
--   difference being that monad layers are not necessarily parametric in
--   their inner monad. For more details, read the the in-depth
--   documentation provided in <a>Documentation.Layers.Overview</a>.
class (Monad m, Monad (Inner m)) => MonadLayer m where type family Inner m :: * -> *
layer :: MonadLayer m => Inner m a -> m a
layerInvmap :: MonadLayer m => (forall b. Inner m b -> Inner m b) -> (forall b. Inner m b -> Inner m b) -> m a -> m a

-- | The type class <a>MonadLayerFunctor</a> represents is the subclass of
--   monad layers that support the <a>layerMap</a> operation, which is more
--   powerful than the <a>layerInvmap</a> operation of the
--   <a>MonadLayer</a> type class.
class MonadLayer m => MonadLayerFunctor m
layerMap :: MonadLayerFunctor m => (forall b. Inner m b -> Inner m b) -> m a -> m a

-- | <a>MonadLayerControl</a> represents the class of monad layers through
--   which it is possible to lift control operations. See
--   <a>Documentation.Layers.Overview</a> for a more complete discussion.
class MonadLayerFunctor m => MonadLayerControl m where data family LayerState m :: * -> * zero _ = False
zero :: MonadLayerControl m => LayerState m a -> Bool
restore :: MonadLayerControl m => LayerState m a -> m a
layerControl :: MonadLayerControl m => ((forall b. m b -> Inner m (LayerState m b)) -> Inner m a) -> m a

-- | Monad transformers are a subclass of monad layers which are parametric
--   in their inner monad.
class (MonadLayer m, m ~ Outer m (Inner m)) => MonadTrans m where type family Outer m :: (* -> *) -> * -> *
transInvmap :: (MonadTrans m, MonadTrans n, Outer n ~ Outer m) => (forall b. Inner m b -> Inner n b) -> (forall b. Inner n b -> Inner m b) -> m a -> n a

-- | The type class <a>MonadTransFunctor</a> represents is the subclass of
--   monad layers that support the <a>transMap</a> operation, which is more
--   powerful than the <a>transInvmap</a> operation of the
--   <a>MonadTrans</a> type class.
class (MonadLayerFunctor m, MonadTrans m) => MonadTransFunctor m
transMap :: (MonadTransFunctor m, MonadTrans n, Outer n ~ Outer m) => (forall b. Inner m b -> Inner n b) -> m a -> n a

-- | <a>MonadTransControl</a> is a variant of <a>MonadLayerControl</a> for
--   monad transformers, i.e., monad layers polymorphic in their inner
--   monad. This extra polymorphism allows us to specify more type safety
--   in the <tt>run</tt> operation of <a>transControl</a>, but in practice
--   there is no reason to ever use this over <tt>MonadLayerControl</tt>.
--   See <a>Documentation.Layers.Overview</a> for a discussion of why this
--   class is included despite not being strictly necessary.
class (MonadLayerControl m, MonadTransFunctor m) => MonadTransControl m
transControl :: MonadTransControl m => (forall n. (MonadTrans n, Outer n ~ Outer m) => (forall b. n b -> Inner n (LayerState n b)) -> Inner n a) -> m a

-- | <a>MonadLift</a> is a multi-parameter type class parameterised by two
--   monads <tt>i</tt> and <tt>m</tt>. If the constraint <tt>MonadLift i
--   m</tt> is satisfied, this means that <tt>m</tt> supports lifting
--   operations from <tt>i</tt>. If <tt>m</tt> is a monad built from a
--   monad transformer stack, then it supports lifting operations from any
--   monad <tt>i</tt> anywhere in the stack. We call such a relationship
--   between <tt>i</tt> and <tt>m</tt> a "monad lift". For a more details,
--   read the in-depth documentation provided in
--   <a>Documentation.Layers.Overview</a>.
class (Monad i, Monad m) => MonadLift i m
lift :: MonadLift i m => i a -> m a
liftInvmap :: MonadLift i m => (forall b. i b -> i b) -> (forall b. i b -> i b) -> m a -> m a

-- | The type class <a>MonadLiftFunctor</a> represents is the subclass of
--   monad lifts that support the <a>liftMap</a> operation, which is more
--   powerful than the <a>liftInvmap</a> operation of the <a>MonadLift</a>
--   type class.
class MonadLift i m => MonadLiftFunctor i m
liftMap :: MonadLiftFunctor i m => (forall b. i b -> i b) -> m a -> m a

-- | <a>MonadLiftControl</a> represents the class of monad lifts that
--   support lifting control operations. See
--   <a>Documentation.Layers.Overview</a> for a more complete discussion.
class MonadLiftFunctor i m => MonadLiftControl i m
liftControl :: MonadLiftControl i m => ((forall b. m b -> i (m b)) -> i a) -> m a

-- | An often used composition: <tt><a>controlLayer</a> f =
--   <a>layerControl</a> f &gt;&gt;= <a>restore</a></tt>
controlLayer :: MonadLayerControl m => ((forall b. m b -> Inner m (LayerState m b)) -> Inner m (LayerState m a)) -> m a

-- | <tt>layerOp</tt> is a particular application of <a>layerControl</a>
--   that allows layering control operations of type: <tt>(a -&gt;
--   <a>Inner</a> m b) -&gt; <a>Inner</a> m b</tt> to
--   <tt><a>MonadLayerControl</a> m =&gt; (a -&gt; m b) -&gt; m b</tt>.
--   
--   For example:
--   
--   <pre>
--   layerOp . withMVar :: (<a>MonadLayerControl</a> m, <a>Inner</a> m ~ <a>IO</a>)
--        =&gt; MVar a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
layerOp :: MonadLayerControl m => ((a -> Inner m (LayerState m b)) -> Inner m (LayerState m c)) -> (a -> m b) -> m c

-- | <tt>layerOp_</tt> is a particular application of <a>layerControl</a>
--   that allows layering control operations of type: <tt><a>Inner</a> m a
--   -&gt; <a>Inner</a> m b</tt> to <tt><a>MonadLayerControl</a> m =&gt; m
--   a -&gt; m b</tt>.
--   
--   For example:
--   
--   <pre>
--   layerOp_ mask_ :: (<a>MonadLayerControl</a> m, <a>Inner</a> m ~ <a>IO</a>) =&gt; m a -&gt; m a
--   </pre>
layerOp_ :: MonadLayerControl m => (Inner m (LayerState m a) -> Inner m (LayerState m b)) -> m a -> m b

-- | <tt>layerDiscard</tt> is a particular application of
--   <a>layerControl</a> that allows layering control operations of type:
--   <tt><a>Inner</a> m () -&gt; <a>Inner</a> m a</tt> to
--   <tt><a>MonadLayerControl</a> m =&gt; m () -&gt; m a</tt>.
--   
--   Note that, while the argument computation <tt>m ()</tt> has access to
--   the captured state, all its side-effects in <tt>m</tt> are discarded.
--   It is run only for its side-effects in the inner monad
--   <tt><a>Inner</a> m</tt>.
--   
--   For example:
--   
--   <pre>
--   layerDiscard forkIO :: (<a>MonadLayerControl</a> m, <a>Inner</a> m ~ <a>IO</a>)
--        =&gt; m () -&gt; m ThreadId
--   </pre>
layerDiscard :: MonadLayerControl m => (Inner m () -> Inner m a) -> m () -> m a

-- | An often used composition: <tt><a>control</a> f = join .
--   <a>liftControl</a> f</tt>
control :: MonadLiftControl i m => ((forall b. m b -> i (m b)) -> i (m a)) -> m a

-- | <tt>liftOp</tt> is a particular application of <a>liftControl</a> that
--   allows lifting control operations of type: <tt>(a -&gt; i b) -&gt; i
--   b</tt> to <tt><a>MonadLiftControl</a> i m =&gt; (a -&gt; m b) -&gt; m
--   b</tt>.
--   
--   For example:
--   
--   <pre>
--   liftOp . withMVar :: <a>MonadLiftControl</a> <a>IO</a> m =&gt; MVar a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
liftOp :: MonadLiftControl i m => ((a -> i (m b)) -> i (m c)) -> (a -> m b) -> m c

-- | <tt>liftOp_</tt> is a particular application of <a>liftControl</a>
--   that allows lifting control operations of type: <tt>i a -&gt; i b</tt>
--   to <tt><a>MonadLiftControl</a> i m =&gt; m a -&gt; m b</tt>.
--   
--   For example:
--   
--   <pre>
--   liftOp_ mask_ :: <a>MonadLiftControl</a> <a>IO</a> m =&gt; m a -&gt; m a
--   </pre>
liftOp_ :: MonadLiftControl i m => (i (m a) -> i (m b)) -> m a -> m b

-- | <tt>liftDiscard</tt> is a particular application of <a>liftControl</a>
--   that allows lifting control operations of type: <tt>i () -&gt; i
--   a</tt> to <tt><a>MonadLiftControl</a> i m =&gt; m () -&gt; m a</tt>.
--   
--   Note that, while the argument computation <tt>m ()</tt> has access to
--   the captured state, all its side-effects in <tt>m</tt> are discarded.
--   It is run only for its side-effects in the inner monad <tt>i</tt>.
--   
--   For example:
--   
--   <pre>
--   liftDiscard forkIO :: <a>MonadLiftControl</a> <a>IO</a> m =&gt; m () -&gt; m ThreadId
--   </pre>
liftDiscard :: MonadLiftControl i m => (i () -> i a) -> m () -> m a
instance [overlap ok] (MonadLayerControl m, MonadLiftControl i (Inner m)) => MonadLiftControl i m
instance [overlap ok] Monad m => MonadLiftControl m m
instance [overlap ok] (MonadLayerFunctor m, MonadLiftFunctor i (Inner m)) => MonadLiftFunctor i m
instance [overlap ok] Monad m => MonadLiftFunctor m m
instance [overlap ok] (MonadLayer m, MonadLift i (Inner m)) => MonadLift i m
instance [overlap ok] Monad m => MonadLift m m
instance [overlap ok] (Monad m, Monoid w) => MonadTransControl (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransFunctor (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadTrans (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerControl (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerFunctor (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayer (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransControl (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransFunctor (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadTrans (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerControl (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerFunctor (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayer (WriterT w m)
instance [overlap ok] Monad m => MonadTransControl (StateT s m)
instance [overlap ok] Monad m => MonadTransFunctor (StateT s m)
instance [overlap ok] Monad m => MonadTrans (StateT s m)
instance [overlap ok] Monad m => MonadLayerControl (StateT s m)
instance [overlap ok] Monad m => MonadLayerFunctor (StateT s m)
instance [overlap ok] Monad m => MonadLayer (StateT s m)
instance [overlap ok] Monad m => MonadTransControl (StateT s m)
instance [overlap ok] Monad m => MonadTransFunctor (StateT s m)
instance [overlap ok] Monad m => MonadTrans (StateT s m)
instance [overlap ok] Monad m => MonadLayerControl (StateT s m)
instance [overlap ok] Monad m => MonadLayerFunctor (StateT s m)
instance [overlap ok] Monad m => MonadLayer (StateT s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransControl (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransFunctor (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTrans (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerControl (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerFunctor (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayer (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransFunctor (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTrans (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadTransControl (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerControl (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayerFunctor (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadLayer (RWST r w s m)
instance [overlap ok] Monad m => MonadTransControl (ReaderT r m)
instance [overlap ok] Monad m => MonadTransFunctor (ReaderT r m)
instance [overlap ok] Monad m => MonadTrans (ReaderT r m)
instance [overlap ok] Monad m => MonadLayerControl (ReaderT r m)
instance [overlap ok] Monad m => MonadLayerFunctor (ReaderT r m)
instance [overlap ok] Monad m => MonadLayer (ReaderT r m)
instance [overlap ok] Monad m => MonadTransControl (MaybeT m)
instance [overlap ok] Monad m => MonadTransFunctor (MaybeT m)
instance [overlap ok] Monad m => MonadTrans (MaybeT m)
instance [overlap ok] Monad m => MonadLayerControl (MaybeT m)
instance [overlap ok] Monad m => MonadLayerFunctor (MaybeT m)
instance [overlap ok] Monad m => MonadLayer (MaybeT m)
instance [overlap ok] Monad m => MonadTransControl (ListT m)
instance [overlap ok] Monad m => MonadTransFunctor (ListT m)
instance [overlap ok] Monad m => MonadTrans (ListT m)
instance [overlap ok] Monad m => MonadLayerControl (ListT m)
instance [overlap ok] Monad m => MonadLayerFunctor (ListT m)
instance [overlap ok] Monad m => MonadLayer (ListT m)
instance [overlap ok] Monad m => MonadTransControl (IdentityT m)
instance [overlap ok] Monad m => MonadTransFunctor (IdentityT m)
instance [overlap ok] Monad m => MonadTrans (IdentityT m)
instance [overlap ok] Monad m => MonadLayerControl (IdentityT m)
instance [overlap ok] Monad m => MonadLayerFunctor (IdentityT m)
instance [overlap ok] Monad m => MonadLayer (IdentityT m)
instance [overlap ok] (Error e, Monad m) => MonadTransControl (ErrorT e m)
instance [overlap ok] (Error e, Monad m) => MonadTransFunctor (ErrorT e m)
instance [overlap ok] (Error e, Monad m) => MonadTrans (ErrorT e m)
instance [overlap ok] (Error e, Monad m) => MonadLayerControl (ErrorT e m)
instance [overlap ok] (Error e, Monad m) => MonadLayerFunctor (ErrorT e m)
instance [overlap ok] (Error e, Monad m) => MonadLayer (ErrorT e m)
instance [overlap ok] Monad m => MonadTrans (ContT r m)
instance [overlap ok] Monad m => MonadLayer (ContT r m)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadCont</a> type class and its operation
--   <a>callCC</a>.</li>
--   <li>An instance of <a>MonadCont</a> for the <a>ContT</a> monad
--   transformer from the <tt>transformers</tt> package.</li>
--   <li>A universal pass-through instance of <a>MonadCont</a> for any
--   existing <tt>MonadCont</tt> wrapped by a
--   <a>MonadLayerControl</a>.</li>
--   </ol>
module Control.Monad.Interface.Cont

-- | The <a>MonadCont</a> interface represents computations in
--   continuation-passing style (CPS). In continuation-passing style
--   function result is not returned, but instead is passed to another
--   function, received as a parameter (continuation). Computations are
--   built up from sequences of nested continuations, terminated by a final
--   continuation (often id) which produces the final result. Since
--   continuations are functions which represent the future of a
--   computation, manipulation of the continuation functions can achieve
--   complex manipulations of the future of the computation, such as
--   interrupting a computation in the middle, aborting a portion of a
--   computation, restarting a computation, and interleaving execution of
--   computations. The <tt>MonadCont</tt> interface adapts CPS to the
--   structure of a monad.
--   
--   Before using the <tt>MonadCont</tt> interface, be sure that you have a
--   firm understanding of continuation-passing style and that
--   continuations represent the best solution to your particular design
--   problem. Many algorithms which require continuations in other
--   languages do not require them in Haskell, due to Haskell's lazy
--   semantics. Abuse of the <tt>MonadCont</tt> interface can produce code
--   that is impossible to understand and maintain.
class Monad m => MonadCont m
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
instance [overlap ok] (MonadLayerControl m, MonadCont (Inner m)) => MonadCont m
instance [overlap ok] Monad m => MonadCont (ContT r m)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadException</a> type class and its operations
--   <a>throw</a> and <a>catch</a>.</li>
--   <li>Instances of <a>MonadException</a> for <a>IO</a>, <a>Either</a>,
--   <a>STM</a> and the <a>ErrorT</a> monad transformer from the
--   <tt>transformers</tt> package.</li>
--   <li>An orphan instance of <a>Error</a> for the <a>SomeException</a>
--   type: this is a necessary hack in order to make <a>ErrorT</a> an
--   instance of <a>MonadException</a>.</li>
--   <li>A universal pass-through instance of <a>MonadException</a> for any
--   existing <tt>MonadException</tt> wrapped by a
--   <a>MonadLayerControl</a>.</li>
--   <li>The utility operations <a>catches</a>, <a>catchJust</a>,
--   <a>handle</a>, <a>handleJust</a>, <a>try</a> and <a>tryJust</a>.</li>
--   </ol>
module Control.Monad.Interface.Exception

-- | The <a>MonadException</a> type class represents the class of monads
--   which can <a>throw</a> and <a>catch</a> exceptions. This includes
--   <a>IO</a>-based monads as well as <a>Either</a>-like monads.
--   
--   Minimal complete definition: <a>throw</a>, <a>catch</a>.
class Monad m => MonadException m
throw :: (MonadException m, Exception e) => e -> m a
catch :: (MonadException m, Exception e) => m a -> (e -> m a) -> m a

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \(ex :: ArithException) -&gt; handleArith ex
--            `catch` \(ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: MonadException m => m a -> [Handler m a] -> m a

-- | You need this when using <a>catches</a>.
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e)
--                 then Just ()
--                 else Nothing)
--             (readFile f)
--             (\_ -&gt; do
--                 hPutStrLn stderr ("No such file: " ++ show f)
--                 return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: (MonadException m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: (MonadException m, Exception e) => (e -> m a) -> m a -> m a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: (MonadException m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: (MonadException m, Exception e) => m a -> m (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: (MonadException m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
instance [overlap ok] Error SomeException
instance [overlap ok] (MonadLayerControl m, MonadException (Inner m)) => MonadException m
instance [overlap ok] (MonadException f, MonadException g) => MonadException (Product f g)
instance [overlap ok] (e ~ SomeException, Monad m) => MonadException (ErrorT e m)
instance [overlap ok] MonadException STM
instance [overlap ok] MonadException IO
instance [overlap ok] e ~ SomeException => MonadException (Either e)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadMask</a> type class and its operations
--   <a>getMaskingState</a> and <a>setMaskingState</a>.</li>
--   <li>Instances of <a>MonadMask</a> for all the base monads in the
--   <tt>base</tt> and <tt>transformers</tt> packages.</li>
--   <li>A universal pass-through instance of <a>MonadMask</a> for any
--   existing <tt>MonadMask</tt> wrapped by a <a>MonadLayer</a>.</li>
--   <li>The utility operations <a>mask</a>, <a>mask_</a>,
--   <a>uninterruptibleMask</a>, <a>uninterruptibleMask_</a>.</li>
--   </ol>
module Control.Monad.Interface.Mask

-- | The <a>MonadMask</a> type class is for dealing with asynchronous
--   exceptions. It contains the <a>getMaskingState</a> and
--   <a>setMaskingState</a> operations for getting and setting the
--   <a>MaskingState</a> of the current thread. However, you should never
--   need to use these operations: in particular, using
--   <tt>setMaskingState</tt> can violate some invariants which are assumed
--   internally by this library. The only reason these functions are
--   exposed at all is that they are necessary to implement <a>mask</a>
--   (which is what you should use instead), and unlike <a>mask</a>, their
--   simpler type signature allows us to define a universal pass-through
--   instance of <tt>MonadMask</tt> through any <a>MonadLayer</a>, while
--   <tt>mask</tt> would require <a>MonadLayerControl</a>.
--   
--   <i>Every</i> monad should be an instance of <tt>MonadMask</tt>, and we
--   have provided instances for every base monad in the <tt>base</tt> and
--   <tt>transformers</tt> packages. <tt>getMaskingState</tt> and
--   <tt>setMaskingState</tt> have default definitions that only need to be
--   overridden in the case of <a>IO</a> and monads layered on top of
--   <tt>IO</tt> (which we have already done), so it costs nothing to add
--   an instance of <tt>MonadMask</tt> to a monad. (<tt>MonadMask</tt> is a
--   prerequisite for implementing <a>MonadTry</a>, which provides the
--   <a>bracket</a> family of functions, which is perhaps more interesting
--   than <tt>MonadMask</tt> on its own.)
--   
--   Minimal complete definition: instance head only.
class Monad m => MonadMask m where getMaskingState = return MaskedInterruptible setMaskingState = const id
getMaskingState :: MonadMask m => m MaskingState
setMaskingState :: MonadMask m => MaskingState -> m a -> m a

-- | Executes a computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `finally` release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <tt>bracket</tt> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <tt>mask</tt> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <tt>mask</tt> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>fork</a> inherit the masked state from the
--   parent; that is, to start a thread in blocked mode, use <tt>mask_ $
--   fork ...</tt>. This is particularly useful if you need to establish an
--   exception handler in the forked thread before any asynchronous
--   exceptions are received.
mask :: MonadMask m => ((forall a n. MonadMask n => n a -> n a) -> m b) -> m b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: MonadMask m => m a -> m a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: MonadMask m => ((forall a n. MonadMask n => n a -> n a) -> m b) -> m b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: MonadMask m => m a -> m a
instance [overlap ok] (MonadLayer m, MonadMask (Inner m)) => MonadMask m
instance [overlap ok] MonadMask IO
instance [overlap ok] MonadMask STM
instance [overlap ok] MonadMask (ST s)
instance [overlap ok] MonadMask (ST s)
instance [overlap ok] MonadMask ((->) r)
instance [overlap ok] MonadMask []
instance [overlap ok] MonadMask (Either e)
instance [overlap ok] MonadMask Maybe
instance [overlap ok] (MonadMask f, MonadMask g) => MonadMask (Product f g)
instance [overlap ok] MonadMask Identity


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadFork</a> type class and its operations <a>fork</a> and
--   <a>forkOn</a>.</li>
--   <li>An instance of <a>MonadFork</a> for the <a>IO</a> monad.</li>
--   <li>A universal pass-through instance of <a>MonadFork</a> for any
--   existing <tt>MonadFork</tt> wrapped by a
--   <a>MonadLayerControl</a>.</li>
--   <li>The utility operations <a>forkWithUnmask</a> and
--   <a>forkOnWithUnmask</a>.</li>
--   </ol>
module Control.Monad.Interface.Fork

-- | The <a>MonadFork</a> type class, for monads which support a fork
--   operation.
--   
--   An example of a monad which has a MonadFork instance that is not
--   simply a lifted form of <tt>forkIO</tt> is the <tt>ResourceT</tt>
--   monad from the <tt>resourcet</tt> package, which defines an operation
--   <tt>resourceForkIO</tt>.
class MonadMask m => MonadFork m
fork :: MonadFork m => m () -> m ThreadId
forkOn :: MonadFork m => Int -> m () -> m ThreadId

-- | Like <a>fork</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the <tt>unmask</tt> function passed to the child thread
--   should only be used in that thread; the behaviour is undefined if it
--   is invoked in a different thread.
forkWithUnmask :: MonadFork m => ((forall a n. MonadMask n => n a -> n a) -> m ()) -> m ThreadId

-- | Like <a>forkWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: MonadFork m => Int -> ((forall a n. MonadMask n => n a -> n a) -> m ()) -> m ThreadId
instance [overlap ok] (MonadLayerControl m, MonadFork (Inner m)) => MonadFork m
instance [overlap ok] (MonadFork f, MonadFork g) => MonadFork (Product f g)
instance [overlap ok] MonadFork IO


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadMutVar</a> type class and its operations
--   <a>newRef</a>, <a>readRef</a>, <a>writeRef</a> and
--   <a>atomicModifyRef</a>.</li>
--   <li>Instances of <a>MonadMutVar</a> for <a>IO</a>, <a>STM</a>, strict
--   <a>ST</a> and lazy <a>ST</a>.</li>
--   <li>A universal pass-through instance of <a>MonadMutVar</a> for any
--   existing <tt>MonadMutVar</tt> wrapped by a <a>MonadLayer</a>.</li>
--   <li>The utility operations <a>atomicModifyRef'</a>,
--   <a>atomicWriteRef</a>, <a>modifyRef</a> and <a>modifyRef'</a>.</li>
--   </ol>
module Control.Monad.Interface.MutVar

-- | The type class <a>MonadMutVar</a> represents the class of monads which
--   support mutable variables. The <tt>ref</tt> parameter is the type of
--   the mutable variable; e.g., for <a>IO</a>, <tt>ref</tt> is
--   <a>IORef</a>.
--   
--   Minimal complete definition: <a>newRef</a>, <a>readRef</a>,
--   <a>writeRef</a>.
class Monad m => MonadMutVar ref m | m -> ref where atomicModifyRef ref f = do { a <- readRef ref; let (a', b) = f a; writeRef ref a'; return b }
newRef :: MonadMutVar ref m => a -> m (ref a)
readRef :: MonadMutVar ref m => ref a -> m a
writeRef :: MonadMutVar ref m => ref a -> a -> m ()
atomicModifyRef :: MonadMutVar ref m => ref a -> (a -> (a, b)) -> m b

-- | Strict version of <a>atomicModifyRef</a>. This forces both the value
--   stored in the mutable variable as well as the value returned.
atomicModifyRef' :: MonadMutVar ref m => ref a -> (a -> (a, b)) -> m b

-- | Variant of <a>writeRef</a> with the "barrier to reordering" property
--   that <a>atomicModifyRef</a> has.
atomicWriteRef :: MonadMutVar ref m => ref a -> a -> m ()

-- | Mutate the contents of a mutable variable.
--   
--   Be warned that <a>modifyRef</a> does not apply the function strictly.
--   This means if the program calls <tt>modifyRef</tt> many times, but
--   seldomly uses the value, thunks will pile up in memory resulting in a
--   space leak. This is a common mistake made when using a mutable varible
--   as a counter. For example, the following will likely produce a stack
--   overflow:
--   
--   <pre>
--   ref &lt;- newRef 0
--   replicateM_ 1000000 $ modifyRef ref (+1)
--   readRef ref &gt;&gt;= print
--   </pre>
--   
--   To avoid this problem, use <a>modifyRef'</a> instead.
modifyRef :: MonadMutVar ref m => ref a -> (a -> a) -> m ()

-- | Strict version of <a>modifyRef</a>.
modifyRef' :: MonadMutVar ref m => ref a -> (a -> a) -> m ()
instance [overlap ok] (MonadLayer m, MonadMutVar ref (Inner m)) => MonadMutVar ref m
instance [overlap ok] (MonadMutVar ref f, MonadMutVar ref g) => MonadMutVar ref (Product f g)
instance [overlap ok] MonadMutVar TVar STM
instance [overlap ok] MonadMutVar (STRef s) (ST s)
instance [overlap ok] MonadMutVar (STRef s) (ST s)
instance [overlap ok] MonadMutVar IORef IO


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadReader</a> type class and its operations
--   <a>reader</a>, <a>ask</a> and <a>local</a>.</li>
--   <li>An instance of <a>MonadReader</a> for the <tt>-&gt;</tt>
--   type.</li>
--   <li>Instances of <a>MonadReader</a> for the relevant monad
--   transformers from the <tt>transformers</tt> package (ReaderT', lazy
--   <a>RWST</a> and strict <a>RWST</a>).</li>
--   <li>A universal pass-through instance of <a>MonadReader</a> for any
--   existing <tt>MonadReader</tt> wrapped by a <a>MonadLayer</a>.</li>
--   <li>The utility operations <a>asks</a>.</li>
--   </ol>
module Control.Monad.Interface.Reader

-- | The 'MonadReader interface monad represents computations which can
--   read values from a shared environment, pass values from function to
--   function and execute sub-computations in a modified environment. Using
--   the <tt>MonadReader</tt> interface for such computations is often
--   clearer and easier than using the <a>MonadState</a> interface.
--   
--   Minimal complete definition: <a>local</a> and one of either
--   <a>reader</a> or <a>ask</a>.
class Monad m => MonadReader r m | m -> r where reader f = liftM f ask ask = reader id
reader :: MonadReader r m => (r -> a) -> m a
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a
instance [overlap ok] (MonadLayer m, MonadReader r (Inner m)) => MonadReader r m
instance [overlap ok] (MonadReader r f, MonadReader r g) => MonadReader r (Product f g)
instance [overlap ok] (Monad m, Monoid w) => MonadReader r (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadReader r (RWST r w s m)
instance [overlap ok] Monad m => MonadReader r (ReaderT r m)
instance [overlap ok] MonadReader r ((->) r)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadState</a> type class and its operations <a>state</a>,
--   <a>get</a> and <a>put</a>.</li>
--   <li>Instances of <a>MonadState</a> for the relevant monad transformers
--   from the <tt>transformers</tt> package (lazy <a>StateT</a>, strict
--   <a>StateT</a>, lazy <a>RWST</a> and strict <a>RWST</a>).</li>
--   <li>A universal pass-through instance of <a>MonadState</a> for any
--   existing <tt>MonadState</tt> wrapped by a <a>MonadLayer</a>.</li>
--   <li>The utility operations <a>modify</a> and <a>gets</a>.</li>
--   </ol>
module Control.Monad.Interface.State

-- | A pure functional language cannot update values in place because it
--   violates referential transparency. A common idiom to simulate such
--   stateful computations is to "thread" a state parameter through a
--   sequence of functions:
--   
--   This approach works, but such code can be error-prone, messy and
--   difficult to maintain. The <a>MonadState</a> interface hides the
--   threading of the state parameter inside the binding operation,
--   simultaneously making the code easier to write, easier to read and
--   easier to modify.
--   
--   Minimal complete definition: <a>state</a> or both <a>get</a> and
--   <a>put</a>.
class Monad m => MonadState s m | m -> s where state f = do { s <- get; let ~(a, s') = f s; put s'; return a } get = state (\ s -> (s, s)) put s = state (\ _ -> ((), s))
state :: MonadState s m => (s -> (a, s)) -> m a
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   &gt;&gt;&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any <a>Monad</a> that is
--   a member of the <a>MonadState</a> class with an <a>Int</a> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a
instance [overlap ok] (MonadLayer m, MonadState s (Inner m)) => MonadState s m
instance [overlap ok] (MonadState s f, MonadState s g) => MonadState s (Product f g)
instance [overlap ok] (Monad m, Monoid w) => MonadState s (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadState s (RWST r w s m)
instance [overlap ok] Monad m => MonadState s (StateT s m)
instance [overlap ok] Monad m => MonadState s (StateT s m)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadWriter</a> type class and its operations
--   <a>writer</a>, <a>tell</a>, <a>listen</a> and <a>pass</a>.</li>
--   <li>Instances of <a>MonadWriter</a> for the relevant monad
--   transformers from the <tt>transformers</tt> package (lazy
--   <a>WriterT</a>, strict <a>WriterT</a>, lazy <a>RWST</a> and strict
--   <a>RWST</a>).</li>
--   <li>A universal pass-through instance of <a>MonadWriter</a> for any
--   existing <tt>MonadWriter</tt> wrapped by a <a>MonadLayer</a>.</li>
--   <li>The utility operations <a>listens</a> and <a>censor</a>.</li>
--   </ol>
module Control.Monad.Interface.Writer

-- | It is often desirable for a computation to generate output "on the
--   side". Logging and tracing are the most common examples in which data
--   is generated during a computation that we want to retain but is not
--   the primary result of the computation.
--   
--   Explicitly managing the logging or tracing data can clutter up the
--   code and invite subtle bugs such as missed log entries. The
--   <a>MonadWriter</a> interface provides a cleaner way to manage the
--   output without cluttering the main computation.
--   
--   Minimal complete definition: <a>listen</a>, <a>pass</a> and one of
--   either <a>writer</a> or <a>tell</a>.
class (Monad m, Monoid w) => MonadWriter w m | m -> w where writer ~(a, w) = tell w >> return a tell w = writer ((), w)
writer :: MonadWriter w m => (a, w) -> m a
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (a, w)
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <pre>
--   listens f m = liftM (\(~(a, w)) -&gt; (a, f w)) (listen m)
--   </pre>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <pre>
--   censor f m = pass (liftM (\a -&gt; (a,f)) m)
--   </pre>
censor :: MonadWriter w m => (w -> w) -> m a -> m a
instance [overlap ok] (MonadLayer m, MonadWriter w (Inner m)) => MonadWriter w m
instance [overlap ok] (MonadWriter w f, MonadWriter w g) => MonadWriter w (Product f g)
instance [overlap ok] (Monad m, Monoid w) => MonadWriter w (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadWriter w (RWST r w s m)
instance [overlap ok] (Monad m, Monoid w) => MonadWriter w (WriterT w m)
instance [overlap ok] (Monad m, Monoid w) => MonadWriter w (WriterT w m)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadRWS</a> interface.</li>
--   <li>The <a>Control.Monad.Interface.Reader</a> module.</li>
--   <li>The <a>Control.Monad.Interface.State</a> module.</li>
--   <li>The <a>Control.Monad.Interface.Writer</a> module.</li>
--   </ol>
module Control.Monad.Interface.RWS

-- | The <a>MonadRWS</a> interface is defined as a type synonym (using the
--   <tt>ConstraintKinds</tt> extension) for the combination of
--   <a>MonadReader</a>, <a>MonadState</a> and <a>MonadWriter</a>.
type MonadRWS r w s m = (MonadReader r m, MonadWriter w m, MonadState s m)


-- | This module exports:
--   
--   <ol>
--   <li>The <a>MonadTry</a> type class and its operation <a>mtry</a>.</li>
--   <li>Instances of <a>MonadTry</a> for all the base monads in the
--   <tt>base</tt> and <tt>transformers</tt> packages.</li>
--   <li>A universal pass-through instance of <a>MonadMask</a> for any
--   existing <tt>MonadMask</tt> wrapped by a
--   <a>MonadLayerControl</a>.</li>
--   <li>The utility operations <a>bracket</a>, <a>bracket_</a>,
--   <a>bracketOnError</a>, <a>finally</a> and <a>onException</a>.</li>
--   </ol>
module Control.Monad.Interface.Try

-- | The <a>MonadTry</a> type class provides a single operation
--   <a>mtry</a>, which is a way to observe short-circuiting in monads. The
--   name refers to the fact that <tt>mtry</tt> is a generalised version of
--   <a>try</a>: whereas <tt>try</tt> guards against the specific case of a
--   <a>MonadException</a> short-circuiting due to an exception being
--   thrown, it can still short-circuit in other ways: e.g., if a
--   <tt><a>MaybeT</a> <a>IO</a></tt> returns <a>mzero</a>
--   (<a>Nothing</a>). The action returned by <a>mtry</a> is guaranteed to
--   never short-circuit.
--   
--   Nearly every monad should have an instance of <tt>MonadTry</tt>, with
--   the exception of CPS-style monads whose (possible) short-circuiting is
--   impossible to observe. Instances for every base monad in the
--   <tt>base</tt> and <tt>transformers</tt> packages. <tt>mtry</tt> has a
--   default definition that only needs to be overridden for monads which
--   actually short-circuit, so it costs very little to add an instance of
--   <tt>MonadTry</tt> to a monad.
--   
--   Minimal complete definition: instance head only.
class MonadMask m => MonadTry m where mtry = liftM Right
mtry :: MonadTry m => m a -> m (Either (m a) a)

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <tt>bracket</tt> will install the necessary handler to release the
--   resource in the event that the monad short circuits during the
--   computation. If the monad short-circuits, then <tt>bracket</tt> will
--   re-return the monad in its short-circuited state (after performing the
--   release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <tt>bracket</tt> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: MonadTry m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: MonadTry m => m a -> m b -> m c -> m c

-- | Like <a>bracket</a>, but only performs the final action if the monad
--   short-circuited during the in-between computation.
bracketOnError :: MonadTry m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: MonadTry m => m a -> m b -> m a

-- | Like <a>finally</a>, but only performs the final action if the monad
--   short-circuited during the computation.
onException :: MonadTry m => m a -> m b -> m a
instance [overlap ok] (MonadLayerControl m, MonadTry (Inner m)) => MonadTry m
instance [overlap ok] MonadTry STM
instance [overlap ok] MonadTry (ST s)
instance [overlap ok] MonadTry (ST s)
instance [overlap ok] MonadTry IO
instance [overlap ok] MonadTry ((->) r)
instance [overlap ok] MonadTry []
instance [overlap ok] MonadTry (Either e)
instance [overlap ok] MonadTry Maybe
instance [overlap ok] (MonadTry f, MonadTry g) => MonadTry (Product f g)
instance [overlap ok] MonadTry Identity


-- | This document discusses extensively the motivation behind the
--   <tt>layers</tt> package and explains the design decisions taken in its
--   construction.

-- | <i>Warning: This module exports no types, functions, classes or
--   instances. It exists solely for the Haddock documentation it produces.
--   You should not ever need to import it. </i>
module Documentation.Layers.Overview
