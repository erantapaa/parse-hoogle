-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast JSON parsing and encoding
--   
@package aeson
@version 0.9.0.1


-- | Types for working with JSON data.
module Data.Aeson.Types

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | The empty array.
emptyArray :: Value

-- | A key/value pair for an <a>Object</a>.
type Pair = (Text, Value)

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | The empty object.
emptyObject :: Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <tt>System.DateTime</tt>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime
fromDotNetTime :: DotNetTime -> UTCTime

-- | Fail parsing due to a type mismatch, with a descriptive message.
typeMismatch :: String -> Value -> Parser a

-- | A continuation-based parser type.
data Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a where parseJSON = genericParseJSON defaultOptions
parseJSON :: FromJSON a => Value -> Parser a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: FromJSON a => Value -> Result a

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | Run a <a>Parser</a> with an <a>Either</a> result type.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a where toJSON = genericToJSON defaultOptions
toJSON :: ToJSON a => a -> Value

-- | If the inner <tt>Parser</tt> failed, modify the failure message using
--   the provided function. This allows you to create more descriptive
--   error messages. For example:
--   
--   <pre>
--   parseJSON (Object o) = modifyFailure
--       ("Parsing of the Foo value failed: " ++)
--       (Foo &lt;$&gt; o .: "someField")
--   </pre>
--   
--   Since 0.6.2.0
modifyFailure :: (String -> String) -> Parser a -> Parser a

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted from JSON.
class GFromJSON f
gParseJSON :: GFromJSON f => Options -> Value -> Parser (f a)

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to JSON.
class GToJSON f
gToJSON :: GToJSON f => Options -> f a -> Value

-- | A configurable generic JSON encoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericToJSON :: (Generic a, GToJSON (Rep a)) => Options -> a -> Value

-- | A configurable generic JSON decoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>parseJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericParseJSON :: (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a

-- | <tt>withObject expected f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <tt>Object</tt> and fails
--   using <tt><a>typeMismatch</a> expected</tt> otherwise.
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | <tt>withText expected f value</tt> applies <tt>f</tt> to the
--   <a>Text</a> when <tt>value</tt> is a <tt>String</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withText :: String -> (Text -> Parser a) -> Value -> Parser a

-- | <tt>withArray expected f value</tt> applies <tt>f</tt> to the
--   <a>Array</a> when <tt>value</tt> is an <tt>Array</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withArray :: String -> (Array -> Parser a) -> Value -> Parser a

-- | <tt>withNumber expected f value</tt> applies <tt>f</tt> to the
--   <a>Number</a> when <tt>value</tt> is a <a>Number</a>. and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.

-- | <i>Deprecated: Use withScientific instead</i>
withNumber :: String -> (Number -> Parser a) -> Value -> Parser a

-- | <tt>withScientific expected f value</tt> applies <tt>f</tt> to the
--   <a>Scientific</a> number when <tt>value</tt> is a <a>Number</a>. and
--   fails using <tt><a>typeMismatch</a> expected</tt> otherwise.
withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a

-- | <tt>withBool expected f value</tt> applies <tt>f</tt> to the
--   <a>Bool</a> when <tt>value</tt> is a <tt>Bool</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withBool :: String -> (Bool -> Parser a) -> Value -> Parser a

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Options that specify how to encode/decode your datatype to/from JSON.
data Options
Options :: (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> Options

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
fieldLabelModifier :: Options -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
constructorTagModifier :: Options -> String -> String

-- | If <a>True</a> the constructors of a datatype, with <i>all</i> nullary
--   constructors, will be encoded to just a string with the constructor
--   tag. If <a>False</a> the encoding will always follow the
--   <a>sumEncoding</a>.
allNullaryToStringTag :: Options -> Bool

-- | If <a>True</a> record fields with a <a>Nothing</a> value will be
--   omitted from the resulting object. If <a>False</a> the resulting
--   object will include those fields mapping to <tt>null</tt>.
omitNothingFields :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
sumEncoding :: Options -> SumEncoding

-- | Specifies how to encode constructors of a sum datatype.
data SumEncoding

-- | A constructor will be encoded to an object with a field
--   <a>tagFieldName</a> which specifies the constructor tag (modified by
--   the <a>constructorTagModifier</a>). If the constructor is a record the
--   encoded record fields will be unpacked into this object. So make sure
--   that your record doesn't have a field with the same label as the
--   <a>tagFieldName</a>. Otherwise the tag gets overwritten by the encoded
--   value of that field! If the constructor is not a record the encoded
--   constructor contents will be stored under the <a>contentsFieldName</a>
--   field.
TaggedObject :: String -> String -> SumEncoding
tagFieldName :: SumEncoding -> String
contentsFieldName :: SumEncoding -> String

-- | A constructor will be encoded to an object with a single field named
--   after the constructor tag (modified by the
--   <a>constructorTagModifier</a>) which maps to the encoded contents of
--   the constructor.
ObjectWithSingleField :: SumEncoding

-- | A constructor will be encoded to a 2-element array where the first
--   element is the tag of the constructor (modified by the
--   <a>constructorTagModifier</a>) and the second element the encoded
--   contents of the constructor.
TwoElemArray :: SumEncoding

-- | Converts from CamelCase to another lower case, interspersing the
--   character between all capital letters and their previous entries,
--   except those capital letters that appear together, like <tt>API</tt>.
--   
--   For use by Aeson template haskell calls.
--   
--   <pre>
--   camelTo '_' 'CamelCaseAPI' == "camel_case_api"
--   </pre>
camelTo :: Char -> String -> String

-- | Default encoding <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>fieldLabelModifier</a>      = id
--   , <a>constructorTagModifier</a>  = id
--   , <a>allNullaryToStringTag</a>   = True
--   , <a>omitNothingFields</a>       = False
--   , <a>sumEncoding</a>             = <a>defaultTaggedObject</a>
--   }
--   </pre>
defaultOptions :: Options

-- | Default <a>TaggedObject</a> <a>SumEncoding</a> options:
--   
--   <pre>
--   defaultTaggedObject = <a>TaggedObject</a>
--                         { <a>tagFieldName</a>      = "tag"
--                         , <a>contentsFieldName</a> = "contents"
--                         }
--   </pre>
defaultTaggedObject :: SumEncoding


-- | Efficiently and correctly parse a JSON string. The string must be
--   encoded as UTF-8.
--   
--   It can be useful to think of parsing as occurring in two phases:
--   
--   <ul>
--   <li>Identification of the textual boundaries of a JSON value. This is
--   always strict, so that an invalid JSON document can be rejected as
--   soon as possible.</li>
--   <li>Conversion of a JSON value to a Haskell value. This may be either
--   immediate (strict) or deferred (lazy); see below for details.</li>
--   </ul>
--   
--   The question of whether to choose a lazy or strict parser is subtle,
--   but it can have significant performance implications, resulting in
--   changes in CPU use and memory footprint of 30% to 50%, or occasionally
--   more. Measure the performance of your application with each!
module Data.Aeson.Parser

-- | Parse a top-level JSON value.
--   
--   The conversion of a parsed value to a Haskell value is deferred until
--   the Haskell value is needed. This may improve performance if only a
--   subset of the results of conversions are needed, but at a cost in
--   thunk allocation.
--   
--   This function is an alias for <a>value</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json :: Parser Value

-- | Parse any JSON value. You should usually <a>json</a> in preference to
--   this function, as this function relaxes the object-or-array
--   requirement of RFC 4627.
--   
--   In particular, be careful in using this function if you think your
--   code might interoperate with Javascript. A naïve Javascript library
--   that parses JSON data using <tt>eval</tt> is vulnerable to attack
--   unless the encoded data represents an object or an array. JSON
--   implementations in other languages conform to that same restriction to
--   preserve interoperability and security.
value :: Parser Value

-- | Parse a quoted JSON string.
jstring :: Parser Text

-- | Parse a top-level JSON value.
--   
--   This is a strict version of <a>json</a> which avoids building up
--   thunks during parsing; it performs all conversions immediately. Prefer
--   this version if most of the JSON data needs to be accessed.
--   
--   This function is an alias for <a>value'</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json' :: Parser Value

-- | Strict version of <a>value</a>. See also <a>json'</a>.
value' :: Parser Value


-- | Efficiently serialize a JSON value.
--   
--   Most frequently, you'll probably want to encode straight to UTF-8 (the
--   standard JSON encoding) using <a>encode</a>.
--   
--   You can use the conversions to <a>Builder</a>s when embedding JSON
--   messages as parts of a protocol.
module Data.Aeson.Encode

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
encode :: ToJSON a => a -> ByteString

-- | Encode a JSON value to a ByteString <a>Builder</a>. Use this function
--   if you must prepend or append further bytes to the encoded JSON value.
encodeToBuilder :: Value -> Builder

-- | This function is an alias for <a>encodeToBuilder</a>.

-- | <i>Deprecated: Use encodeToBuilder instead.</i>
encodeToByteStringBuilder :: Value -> Builder

-- | Encode a JSON <a>Value</a> to a <a>Data.Text</a> <a>Builder</a>, which
--   can be embedded efficiently in a text-based protocol.
encodeToTextBuilder :: Value -> Builder

-- | <i>Deprecated: Use <a>encodeToTextBuilder</a> instead</i>
fromValue :: Value -> Builder


-- | JSON handling using <a>Generics</a>.
--   
--   This is based on the <a>Generic</a> package originally written by
--   Lennart Augustsson.

-- | <i>Deprecated: This module will be <i>REMOVED</i> in version 0.7.0.0.
--   Please switch to GHC generics or Data.Aeson.TH instead. These
--   alternatives are less buggy, faster, and more configurable.</i>
module Data.Aeson.Generic

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   This function parses immediately, but defers conversion. See
--   <a>json</a> for details.
decode :: Data a => ByteString -> Maybe a

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   This function parses and performs conversion immediately. See
--   <a>json'</a> for details.
decode' :: Data a => ByteString -> Maybe a

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
encode :: Data a => a -> ByteString
fromJSON :: Data a => Value -> Result a
toJSON :: Data a => a -> Value


-- | Types and functions for working efficiently with JSON data.
--   
--   (A note on naming: in Greek mythology, Aeson was the father of Jason.)
module Data.Aeson

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses immediately, but defers conversion. See
--   <a>json</a> for details.
decode :: FromJSON a => ByteString -> Maybe a

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace. This restriction is necessary to ensure
--   that if data is being lazily read from a file handle, the file handle
--   will be closed in a timely fashion once the document has been parsed.
--   
--   This function parses and performs conversion immediately. See
--   <a>json'</a> for details.
decode' :: FromJSON a => ByteString -> Maybe a

-- | Like <a>decode</a> but returns an error message when decoding fails.
eitherDecode :: FromJSON a => ByteString -> Either String a

-- | Like <a>decode'</a> but returns an error message when decoding fails.
eitherDecode' :: FromJSON a => ByteString -> Either String a

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
encode :: ToJSON a => a -> ByteString

-- | Efficiently deserialize a JSON value from a strict <a>ByteString</a>.
--   If this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses immediately, but defers conversion. See
--   <a>json</a> for details.
decodeStrict :: FromJSON a => ByteString -> Maybe a

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses and performs conversion immediately. See
--   <a>json'</a> for details.
decodeStrict' :: FromJSON a => ByteString -> Maybe a

-- | Like <a>decodeStrict</a> but returns an error message when decoding
--   fails.
eitherDecodeStrict :: FromJSON a => ByteString -> Either String a

-- | Like <a>decodeStrict'</a> but returns an error message when decoding
--   fails.
eitherDecodeStrict' :: FromJSON a => ByteString -> Either String a

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <tt>System.DateTime</tt>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime
fromDotNetTime :: DotNetTime -> UTCTime

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a where parseJSON = genericParseJSON defaultOptions
parseJSON :: FromJSON a => Value -> Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: FromJSON a => Value -> Result a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a where toJSON = genericToJSON defaultOptions
toJSON :: ToJSON a => a -> Value

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted from JSON.
class GFromJSON f
gParseJSON :: GFromJSON f => Options -> Value -> Parser (f a)

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to JSON.
class GToJSON f
gToJSON :: GToJSON f => Options -> f a -> Value

-- | A configurable generic JSON encoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericToJSON :: (Generic a, GToJSON (Rep a)) => Options -> a -> Value

-- | A configurable generic JSON decoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>parseJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericParseJSON :: (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a

-- | <tt>withObject expected f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <tt>Object</tt> and fails
--   using <tt><a>typeMismatch</a> expected</tt> otherwise.
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | <tt>withText expected f value</tt> applies <tt>f</tt> to the
--   <a>Text</a> when <tt>value</tt> is a <tt>String</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withText :: String -> (Text -> Parser a) -> Value -> Parser a

-- | <tt>withArray expected f value</tt> applies <tt>f</tt> to the
--   <a>Array</a> when <tt>value</tt> is an <tt>Array</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withArray :: String -> (Array -> Parser a) -> Value -> Parser a

-- | <tt>withNumber expected f value</tt> applies <tt>f</tt> to the
--   <a>Number</a> when <tt>value</tt> is a <a>Number</a>. and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.

-- | <i>Deprecated: Use withScientific instead</i>
withNumber :: String -> (Number -> Parser a) -> Value -> Parser a

-- | <tt>withScientific expected f value</tt> applies <tt>f</tt> to the
--   <a>Scientific</a> number when <tt>value</tt> is a <a>Number</a>. and
--   fails using <tt><a>typeMismatch</a> expected</tt> otherwise.
withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a

-- | <tt>withBool expected f value</tt> applies <tt>f</tt> to the
--   <a>Bool</a> when <tt>value</tt> is a <tt>Bool</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withBool :: String -> (Bool -> Parser a) -> Value -> Parser a

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Parse a top-level JSON value.
--   
--   The conversion of a parsed value to a Haskell value is deferred until
--   the Haskell value is needed. This may improve performance if only a
--   subset of the results of conversions are needed, but at a cost in
--   thunk allocation.
--   
--   This function is an alias for <a>value</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json :: Parser Value

-- | Parse a top-level JSON value.
--   
--   This is a strict version of <a>json</a> which avoids building up
--   thunks during parsing; it performs all conversions immediately. Prefer
--   this version if most of the JSON data needs to be accessed.
--   
--   This function is an alias for <a>value'</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json' :: Parser Value


-- | Functions to mechanically derive <a>ToJSON</a> and <a>FromJSON</a>
--   instances. Note that you need to enable the <tt>TemplateHaskell</tt>
--   language extension in order to use this module.
--   
--   An example shows how instances are generated for arbitrary data types.
--   First we define a data type:
--   
--   <pre>
--   data D a = Nullary
--            | Unary Int
--            | Product String Char a
--            | Record { testOne   :: Double
--                     , testTwo   :: Bool
--                     , testThree :: D a
--                     } deriving Eq
--   </pre>
--   
--   Next we derive the necessary instances. Note that we make use of the
--   feature to change record field names. In this case we drop the first 4
--   characters of every field name. We also modify constructor names by
--   lower-casing them:
--   
--   <pre>
--   $(<a>deriveJSON</a> <a>defaultOptions</a>{<a>fieldLabelModifier</a> = <tt>drop</tt> 4, <a>constructorTagModifier</a> = map toLower} ''D)
--   </pre>
--   
--   Now we can use the newly created instances.
--   
--   <pre>
--   d :: D <a>Int</a>
--   d = Record { testOne = 3.14159
--              , testTwo = <a>True</a>
--              , testThree = Product "test" 'A' 123
--              }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromJSON (toJSON d) == Success d
--   &gt; True
--   </pre>
--   
--   Please note that you can derive instances for tuples using the
--   following syntax:
--   
--   <pre>
--   -- FromJSON and ToJSON instances for 4-tuples.
--   $(<a>deriveJSON</a> <a>defaultOptions</a> ''(,,,))
--   </pre>
module Data.Aeson.TH

-- | Options that specify how to encode/decode your datatype to/from JSON.
data Options
Options :: (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> Options

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
fieldLabelModifier :: Options -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
constructorTagModifier :: Options -> String -> String

-- | If <a>True</a> the constructors of a datatype, with <i>all</i> nullary
--   constructors, will be encoded to just a string with the constructor
--   tag. If <a>False</a> the encoding will always follow the
--   <a>sumEncoding</a>.
allNullaryToStringTag :: Options -> Bool

-- | If <a>True</a> record fields with a <a>Nothing</a> value will be
--   omitted from the resulting object. If <a>False</a> the resulting
--   object will include those fields mapping to <tt>null</tt>.
omitNothingFields :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
sumEncoding :: Options -> SumEncoding

-- | Specifies how to encode constructors of a sum datatype.
data SumEncoding

-- | A constructor will be encoded to an object with a field
--   <a>tagFieldName</a> which specifies the constructor tag (modified by
--   the <a>constructorTagModifier</a>). If the constructor is a record the
--   encoded record fields will be unpacked into this object. So make sure
--   that your record doesn't have a field with the same label as the
--   <a>tagFieldName</a>. Otherwise the tag gets overwritten by the encoded
--   value of that field! If the constructor is not a record the encoded
--   constructor contents will be stored under the <a>contentsFieldName</a>
--   field.
TaggedObject :: String -> String -> SumEncoding
tagFieldName :: SumEncoding -> String
contentsFieldName :: SumEncoding -> String

-- | A constructor will be encoded to an object with a single field named
--   after the constructor tag (modified by the
--   <a>constructorTagModifier</a>) which maps to the encoded contents of
--   the constructor.
ObjectWithSingleField :: SumEncoding

-- | A constructor will be encoded to a 2-element array where the first
--   element is the tag of the constructor (modified by the
--   <a>constructorTagModifier</a>) and the second element the encoded
--   contents of the constructor.
TwoElemArray :: SumEncoding

-- | Default encoding <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>fieldLabelModifier</a>      = id
--   , <a>constructorTagModifier</a>  = id
--   , <a>allNullaryToStringTag</a>   = True
--   , <a>omitNothingFields</a>       = False
--   , <a>sumEncoding</a>             = <a>defaultTaggedObject</a>
--   }
--   </pre>
defaultOptions :: Options

-- | Default <a>TaggedObject</a> <a>SumEncoding</a> options:
--   
--   <pre>
--   defaultTaggedObject = <a>TaggedObject</a>
--                         { <a>tagFieldName</a>      = "tag"
--                         , <a>contentsFieldName</a> = "contents"
--                         }
--   </pre>
defaultTaggedObject :: SumEncoding

-- | Generates both <a>ToJSON</a> and <a>FromJSON</a> instance declarations
--   for the given data type.
--   
--   This is a convienience function which is equivalent to calling both
--   <a>deriveToJSON</a> and <a>deriveFromJSON</a>.
deriveJSON :: Options -> Name -> Q [Dec]

-- | Generates a <a>ToJSON</a> instance declaration for the given data
--   type.
deriveToJSON :: Options -> Name -> Q [Dec]

-- | Generates a <a>FromJSON</a> instance declaration for the given data
--   type.
deriveFromJSON :: Options -> Name -> Q [Dec]

-- | Generates a lambda expression which encodes the given data type as
--   JSON.
mkToJSON :: Options -> Name -> Q Exp

-- | Generates a lambda expression which parses the JSON encoding of the
--   given data type.
mkParseJSON :: Options -> Name -> Q Exp
instance [incoherent] FromJSON a => LookupField (Maybe a)
instance [incoherent] FromJSON a => LookupField a
