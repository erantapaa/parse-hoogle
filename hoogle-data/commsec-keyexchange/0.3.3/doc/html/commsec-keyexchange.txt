-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Key agreement for commsec.
--   
@package commsec-keyexchange
@version 0.3.3


-- | This module provides an authenticated key exchange using the station
--   to station protocol and RSA signatures for authentication.
module Network.CommSec.KeyExchange.Internal

-- | <pre>
--   keyExchangeInit sock pubKeys me
--   </pre>
--   
--   Act as the initiator in an authenticated key exchange using the socket
--   <tt>sock</tt> as the communications channel, the public keys
--   <tt>pubKeys</tt> to verify the end point and the private key
--   <tt>me</tt> to prove ourself.
--   
--   If the responder uses one of the assocated public keys for
--   authentication, it will return the tuple of the public key used and
--   the contexts created. If the responder does not use one of these keys
--   then <tt>Nothing</tt> is returned.
--   
--   The current design assumes the responder accepts our signature - the
--   responder could reject our signature silently and this funcition would
--   complete successfully.
keyExchangeInit :: Socket -> [PublicKey] -> PrivateKey -> IO (Maybe (PublicKey, OutContext, InContext))

-- | <pre>
--   keyExchangeResp sock pubKeys me
--   </pre>
--   
--   Act as the responder in an authenticated key exchange using the socket
--   <tt>sock</tt> as the communications channel, the public keys
--   <tt>pubKeys</tt> to verify the end point and the private key
--   <tt>me</tt> to prove ourself.
--   
--   If the initiator uses one of the assocated public keys for
--   authentication, it will return the tuple of the public key used and
--   the contexts created. If the initiator does not use one of these keys
--   then <tt>Nothing</tt> is returned.
keyExchangeResp :: Socket -> [PublicKey] -> PrivateKey -> IO (Maybe (PublicKey, OutContext, InContext))
instance Serialize PublicKey

module Network.CommSec.KeyExchange.Socket
connect :: Socket -> SockAddr -> [PublicKey] -> PrivateKey -> IO (Maybe (PublicKey, Connection))
accept :: Socket -> [PublicKey] -> PrivateKey -> IO (Maybe (PublicKey, Connection))

-- | Listen for connections made to the socket. The second argument
--   specifies the maximum number of queued connections and should be at
--   least 1; the maximum value is system-dependent (usually 5).
listen :: Socket -> Int -> IO ()

-- | Bind the socket to an address. The socket must not already be bound.
--   The <a>Family</a> passed to <tt>bind</tt> must be the same as that
--   passed to <a>socket</a>. If the special port number <a>aNY_PORT</a> is
--   passed then the system assigns the next available use port.
bind :: Socket -> SockAddr -> IO ()

-- | Create a new socket using the given address family, socket type and
--   protocol number. The address family is usually <a>AF_INET</a>,
--   <a>AF_INET6</a>, or <a>AF_UNIX</a>. The socket type is usually
--   <a>Stream</a> or <a>Datagram</a>. The protocol number is usually
--   <a>defaultProtocol</a>. If <a>AF_INET6</a> is used, the
--   <a>IPv6Only</a> socket option is set to 0 so that both IPv4 and IPv6
--   can be handled with one socket.
socket :: Family -> SocketType -> ProtocolNumber -> IO Socket

-- | Send a datagram, first encrypting it, using the given secure
--   connection.
send :: Connection -> ByteString -> IO ()
recv :: Connection -> IO ByteString

-- | A connection is a secure bidirectional communication channel.
data Connection :: *

-- | Close a connection
close :: Connection -> IO ()


-- | This module provides an authenticated key exchange using the station
--   to station protocol and RSA signatures for authentication.
--   
--   For example, after presharing ssh keys generated using ssh-keygen:
--   
--   <pre>
--   import Crypto.PubKey.OpenSsh
--   import qualified Data.ByteString as B
--   import Network.CommSec.KeyExchange
--   
--   main = do
--       -- Step 1: (not shown) get file paths, host, and port somehow.
--       -- Step 2: Read in the keys
--       OpenSshPrivateKeyRsa priv <a>(either error id . (x -</a> decodePrivate x)) <a>fmap</a> B.readFile myPrivateKeyFile
--       OpenSshPublicKeyRsa them _ &lt;- (either error id . decodePublic) <a>fmap</a> B.readFile theirPublicKeyFile
--   
--       -- Step 3: Listen for and accept a connection (or connect to the listener)
--       if listener
--           then accept host port them priv
--           else connect host port them priv
--   </pre>
module Network.CommSec.KeyExchange

-- | Connect to the specified host and port, establishing a secure,
--   authenticated connection with a party holding the public key.
connect :: HostName -> PortNumber -> [PublicKey] -> PrivateKey -> IO (PublicKey, Connection)

-- | Listen for and accept a connection on the host and port, establishing
--   a secure, authenticated connection with a party holding the specified
--   public key.
accept :: PortNumber -> [PublicKey] -> PrivateKey -> Maybe HostName -> IO (PublicKey, Connection)

-- | Send a datagram, first encrypting it, using the given secure
--   connection.
send :: Connection -> ByteString -> IO ()
recv :: Connection -> IO ByteString

-- | A connection is a secure bidirectional communication channel.
data Connection :: *
Conn :: MVar InContext -> MVar OutContext -> Socket -> SockAddr -> Connection
inCtx :: Connection -> MVar InContext
outCtx :: Connection -> MVar OutContext
socket :: Connection -> Socket

-- | address of remote
socketAddr :: Connection -> SockAddr

-- | Close a connection
close :: Connection -> IO ()

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String
data PortNumber :: *
