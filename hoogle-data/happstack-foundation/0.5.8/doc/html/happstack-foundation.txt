-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Glue code for using Happstack with acid-state, web-routes, reform, and HSP
--   
@package happstack-foundation
@version 0.5.8


-- | <tt>happstack-foundation</tt> provides a type-safe environment for
--   Haskell web development. It builds on top of:
--   
--   <ul>
--   <li>happstack-server - an HTTP server</li>
--   <li>HSP - HTML Templating</li>
--   <li>web-routes - type-safe URL routing</li>
--   <li>reform - type-safe form composition and validation</li>
--   <li>acid-state - native Haskell persistent database</li>
--   </ul>
--   
--   An example application can be found here:
--   
--   
--   <a>http://patch-tag.com/r/mae/happstack/snapshot/current/content/pretty/happstack-foundation/examples/ControlV/Main.hs</a>
--   
--   A screencast can be found here:
--   
--   <a>http://www.youtube.com/watch?v=7Wmszk4wZxQ</a>
--   
--   <tt>happstack-foundation</tt> itself is not yet documented in the
--   Happstack Crash Course. However, all of the components that it uses
--   are:
--   
--   <a>http://www.happstack.com/docs/crashcourse/index.html</a>
module Happstack.Foundation

-- | configuration information for our acid-state database
data AcidConfig st
AcidLocal :: Maybe FilePath -> st -> AcidConfig (AcidState st)
AcidUsing :: st -> AcidConfig st

-- | configuration for server
data FoundationConf
FoundationConf :: Conf -> BodyPolicy -> FoundationConf
httpConf :: FoundationConf -> Conf
bodyPolicy :: FoundationConf -> BodyPolicy

-- | configuration
defaultConf :: FoundationConf

-- | the <a>FoundationT</a> monad
--   
--   <ul>
--   <li><tt>url</tt> - the type-safe URL route type</li>
--   <li><tt>acidState</tt> - the type of the state value stored in
--   acid-state</li>
--   <li><tt>requestState</tt> - a per-request state value that the
--   developer can get<i>set</i>modify</li>
--   <li><tt>m</tt> - inner monad</li>
--   </ul>
--   
--   see also: <a>whereami</a>, <a>getRequestState</a>,
--   <a>setRequestState</a>, <a>modifyRequestState</a>, <a>simpleApp</a>
type FoundationT url acidState requestState m = XMLGenT (FoundationT' url acidState requestState m)

-- | similar to the <a>FoundationT'</a> type alias, but without the
--   <a>XMLGenT</a> wrapper. This variant is most often used in class
--   constraints.
type FoundationT' url acidState requestState m = RouteT url (StateT (AppState url acidState requestState) (ServerPartT m))

-- | <a>FoundationForm</a> is an alias for working with reform based Forms
type FoundationForm url acidState requestState m = Form (FoundationT url acidState requestState m) [Input] AppError [FoundationT url acidState requestState m XML] ()

-- | returns the decoded <tt>url</tt> from the <a>Request</a>
whereami :: (Functor m, Monad m) => FoundationT url acidState requestState m url

-- | get the <tt>requestState</tt> value
getRequestState :: (Functor m, MonadState (AppState url acidState requestState) m) => m requestState

-- | set the <tt>requestState</tt> value
setRequestState :: (Functor m, MonadState (AppState url acidState requestState) m) => requestState -> m ()

-- | set the <tt>requestState</tt> value
modifyRequestState :: MonadState (AppState url acidState requestState) m => (requestState -> requestState) -> m ()

-- | default page template
defaultTemplate :: (Functor m, Monad m, XMLGenerator (FoundationT' url acidState requestState m), EmbedAsChild (FoundationT' url acidState requestState m) body, EmbedAsChild (FoundationT' url acidState requestState m) headers, XMLType (FoundationT' url acidState requestState m) ~ XML) => Text -> headers -> body -> FoundationT url acidState requestState m XML

-- | <a>HasAcidState</a> provides a single method <a>getAcidState</a> which
--   can be used to retrieve an <a>AcidState</a> handle from the current
--   monad.
class HasAcidState m st
getAcidState :: HasAcidState m st => m (AcidState st)

-- | wrapper around query from acid-state
--   
--   This variant automatically gets the <a>AcidState</a> handle from the
--   monad
query :: (Functor m, MonadIO m, QueryEvent event, HasAcidState m (EventState event)) => event -> m (EventResult event)

-- | wrapper around update from acid-state
--   
--   This variant automatically gets the <a>AcidState</a> handle from the
--   monad
update :: (Functor m, MonadIO m, UpdateEvent event, HasAcidState m (EventState event)) => event -> m (EventResult event)
getAcidSt :: (Functor m, MonadState (AppState url acidState requestState) m) => m acidState

-- | run the application
--   
--   starts the database, listens for requests, etc.
simpleApp :: (ToMessage a, PathInfo url, Monad m) => (forall r. m r -> IO r) -> FoundationConf -> AcidConfig acidState -> requestState -> url -> Text -> (url -> FoundationT url acidState requestState m a) -> IO ()

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable * a => Data a
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
toConstr :: Data a => a -> Constr
dataTypeOf :: Data a => a -> DataType
dataCast1 :: (Data a, Typeable (* -> *) t) => (forall d. Data d => c (t d)) -> Maybe (c a)
dataCast2 :: (Data a, Typeable (* -> * -> *) t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | an error type used with reform forms
data AppError
AppCFE :: (CommonFormError [Input]) -> AppError
TextError :: Text -> AppError
instance (Functor m, Monad m) => EmbedAsChild (FoundationT' url acidState requestState m) AppError
instance FormError AppError
instance IsString AppError
instance (Functor m, Monad m) => HasAcidState (FoundationT url (AcidState acidState) requestState m) acidState
instance HasAcidState (FoundationT' url acid reqSt m) acidSt => HasAcidState (XMLGenT (FoundationT' url acid reqSt m)) acidSt
