-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Query SQL databases using Nested Relational Calculus embedded in Haskell.
--   
--   Narc is an embedded language for querying SQL databases, which permits
--   using the ``nested relational'' model, a more flexible model than the
--   traditional relational model of SQL databases. In spite of this richer
--   data model, queries are transformed into SQL to run against standard
--   databases.
--   
--   To use the language, express a query using the combinators like
--   <tt>foreach</tt>, <tt>table</tt>, <tt>having</tt>, <tt>singleton</tt>
--   and so on. Wrap this in a call to <tt>narcToSQLString</tt> to get a
--   string that can be sent to a SQL database.
--   
--   To send a query directly to an HDBC connection, import the module
--   <tt>Database.Narc.HDBC</tt> and use its <tt>run</tt> function, passing
--   it an HDBC connection and a Narc query. The result is an IO action
--   that returns a 2-D list of result values in HDBC's usual format.
@package narc
@version 0.1.3

module Database.Narc.Type
type TyVar = Int
data Type
TBool :: Type
TNum :: Type
TString :: Type
TUnit :: Type
TList :: Type -> Type
TArr :: Type -> Type -> Type
TRecord :: [(String, Type)] -> Type
TVar :: TyVar -> Type
type QType = ([TyVar], Type)
type TySubst = [(Int, Type)]
type TyEnv = [(VarName, QType)]
emptyTySubst :: TySubst

-- | ftvs: free type variables
--   
--   ftvsSubst: the free type variables of a type substitution--that is,
--   the type variables free in the types in the range of the substitution.
--   
--   occurs x ty: does variable x appear in type ty? (Note there are no
--   type-variable binders).
applyTySubst :: TySubst -> Type -> Type

-- | normalizeType: Renumber all the type variables in a normal way to
--   allow comparing types.
normalizeType :: Type -> State (Int, [(Int, Int)]) Type
instanceOf :: Type -> Type -> Failure ()
unify :: Type -> Type -> Failure (TySubst)
unifyAll :: [Type] -> Failure TySubst
composeTySubst :: [TySubst] -> Failure TySubst
disjoinSubst :: TySubst -> TySubst -> TySubst
instance Eq Type
instance Show Type
instance Arbitrary Type

module Database.Narc.HDBC

-- | Run a Narc query directly against an HDBC connection.
run :: IConnection conn => Term a -> conn -> IO [[SqlValue]]

module Database.Narc.Test
normalizerTests :: Test
unitTests :: Test
runUnitTests :: IO Counts

-- | Assertion that well-typed terms compile without throwing.
prop_compile_safe :: Property
prop_typedTermGen_tyCheck :: Property
main :: IO ()


-- | Query SQL databases using Nested Relational Calculus embedded in
--   Haskell.
--   
--   The primed functions in this module are in fact the syntactic forms of
--   the embedded language. Use them as, for example:
--   
--   <pre>
--   let employeesSchema = [("name", TString), ("salary", TNum)] in
--   let employeesTable = table "employees" employeesSchema in
--   foreach employeesTable $ \emp -&gt; 
--     having (primApp "&lt;" [cnst 20000, project emp "salary"]) $
--     singleton (record [("name", project emp "name")])
--   </pre>
module Database.Narc

-- | Translate a Narc term to an SQL query.
narcToSQL :: NarcTerm -> Query

-- | Translate a Narc term to an SQL query string--perhaps the central |
--   function of the interface.
narcToSQLString :: NarcTerm -> String

-- | Serialize a <tt>Query</tt> to its ASCII SQL serialization. Dies on
--   those <tt>Query</tt>s that don't represent valid SQL queries.
serialize :: Query -> String

-- | A dummy value, or zero-width record.
unit :: NarcTerm

-- | A reference to a named database table; second argument is its schema
--   type.
table :: Tabname -> [(Field, Type)] -> NarcTerm

-- | Lift a constant value into a query. <tt>Constable</tt> types currently
--   include <tt>Bool</tt> and <tt>Integer</tt>.
cnst :: Constable a => a -> NarcTerm

-- | Apply some primitive function, such as <tt>(+)</tt> or <tt>avg</tt>,
--   to a list of arguments.
primApp :: String -> [NarcTerm] -> NarcTerm

-- | Create a functional abstraction.
abs :: (String -> NarcTerm) -> NarcTerm

-- | Apply a functional term to an argument.
app :: NarcTerm -> NarcTerm -> NarcTerm

-- | A condition between two terms, as determined by the boolean value of
--   the first term.
ifthenelse :: NarcTerm -> NarcTerm -> NarcTerm -> NarcTerm

-- | A singleton collection of one item.
singleton :: NarcTerm -> NarcTerm

-- | An empty collection.
nil :: NarcTerm

-- | The union of two collections
union :: NarcTerm -> NarcTerm -> NarcTerm

-- | Construct a record (name-value pairs) out of other terms; usually
--   used, with base values for the record elements, as the final result of
--   a query, corresponding to the <tt>select</tt> clause of a SQL query,
--   but can also be used with nested results internally in a query.
record :: [(String, NarcTerm)] -> NarcTerm

-- | Project a field out of a record value.
project :: NarcTerm -> String -> NarcTerm

-- | For each item in the collection resulting from the first argument,
--   give it to the function which is the second argument and
--   evaluate--this corresponds to a loop, or two one part of a cross in
--   traditional SQL queries.
foreach :: NarcTerm -> (NarcTerm -> NarcTerm) -> NarcTerm

-- | Filter the current iteration as per the condition in the first
--   argument. Corresponds to a <tt>where</tt> clause in a SQL query.
having :: NarcTerm -> NarcTerm -> NarcTerm

-- | A shortcut for giving the typical bottom of a ``FLWOR-style''
--   comprehension:
--   
--   <pre>
--   foreach t $ \row -&gt;
--   having (project x "a" &gt; 2) $ 
--   result [("result", project x "b")]
--   </pre>
result :: [(String, NarcTerm)] -> NarcTerm
data Type
TBool :: Type
TNum :: Type
TString :: Type
TUnit :: Type
TList :: Type -> Type
TArr :: Type -> Type -> Type
TRecord :: [(String, Type)] -> Type
TVar :: TyVar -> Type
instance Constable String
instance Constable Integer
instance Constable Bool
