-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algorithms for the order maintenance problem with a safe
interface
--   
@package order-maintenance
@version 0.0.1.0

module Control.Monad.Trans.Order.Raw
type RawOrder a s = STRef s (OrderCell a s)
type RawElement a s = STRef s (ElementCell a s)
data RawAlgorithm a s
RawAlgorithm :: ST s (RawOrder a s) -> (RawOrder a s -> RawElement a s -> RawElement a s -> ST s Ordering) -> (RawOrder a s -> ST s (RawElement a s)) -> (RawOrder a s -> ST s (RawElement a s)) -> (RawOrder a s -> RawElement a s -> ST s (RawElement a s)) -> (RawOrder a s -> RawElement a s -> ST s (RawElement a s)) -> (RawOrder a s -> RawElement a s -> ST s ()) -> RawAlgorithm a s
newOrder :: RawAlgorithm a s -> ST s (RawOrder a s)
compareElements :: RawAlgorithm a s -> RawOrder a s -> RawElement a s -> RawElement a s -> ST s Ordering
newMinimum :: RawAlgorithm a s -> RawOrder a s -> ST s (RawElement a s)
newMaximum :: RawAlgorithm a s -> RawOrder a s -> ST s (RawElement a s)
newAfter :: RawAlgorithm a s -> RawOrder a s -> RawElement a s -> ST s (RawElement a s)
newBefore :: RawAlgorithm a s -> RawOrder a s -> RawElement a s -> ST s (RawElement a s)
delete :: RawAlgorithm a s -> RawOrder a s -> RawElement a s -> ST s ()

module Control.Monad.Trans.Order.Algorithm
data Algorithm
defaultAlgorithm :: Algorithm
withRawAlgorithm :: Algorithm -> (forall a. RawAlgorithm a s -> ST s r) -> ST s r
dumb :: Algorithm
dietzSleatorAmortizedLog :: Algorithm
dietzSleatorAmortizedLogWithSize :: Int -> Algorithm

module Control.Monad.Trans.Order.Lazy
type Order o = OrderT o Identity
evalOrder :: (forall o. Order o a) -> a
evalOrderWith :: Algorithm -> (forall o. Order o a) -> a
data OrderT o m a
evalOrderT :: Monad m => (forall o. OrderT o m a) -> m a
force :: Monad m => OrderT o m ()
data Element o
newMinimum :: Monad m => OrderT o m (Element o)
newMaximum :: Monad m => OrderT o m (Element o)
newAfter :: Monad m => Element o -> OrderT o m (Element o)
newBefore :: Monad m => Element o -> OrderT o m (Element o)
instance Ord (Element o)
instance Eq (Element o)

module Control.Monad.Trans.Order.Strict
type Order o = OrderT o Identity
evalOrder :: (forall o. Order o a) -> a
evalOrderWith :: Algorithm -> (forall o. Order o a) -> a
data OrderT o m a
evalOrderT :: Monad m => (forall o. OrderT o m a) -> m a
force :: Monad m => OrderT o m ()
data Element o
newMinimum :: Monad m => OrderT o m (Element o)
newMaximum :: Monad m => OrderT o m (Element o)
newAfter :: Monad m => Element o -> OrderT o m (Element o)
newBefore :: Monad m => Element o -> OrderT o m (Element o)
lazyToStrictOrderT :: OrderT o m a -> OrderT o m a
strictToLazyOrderT :: OrderT o m a -> OrderT o m a
instance Functor m => Functor (OrderT o m)
instance (Monad m, Functor m) => Applicative (OrderT o m)
instance (Functor m, MonadPlus m) => Alternative (OrderT o m)
instance Monad m => Monad (OrderT o m)
instance MonadPlus m => MonadPlus (OrderT o m)
instance MonadTrans (OrderT o)
instance MonadIO m => MonadIO (OrderT o m)

module Control.Monad.Trans.Order
