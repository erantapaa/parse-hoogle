-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient parsing and serialisation of S-Expressions.
--   
@package atto-lisp
@version 0.2.2


-- | Efficient parsing and serialisation of S-Expressions (as used by
--   Lisp).
--   
--   This module is intended to be imported qualified, e.g.:
--   
--   <pre>
--   import qualified Data.AttoLisp as L
--   </pre>
module Data.AttoLisp

-- | A Lisp expression (S-expression).
--   
--   Symbols are case-sensitive.
--   
--   NOTE: The <a>Number</a> type is deprecated in "attoparsec", so a
--   future version of "atto-lisp" will switch to the <tt>Scientific</tt>
--   type from the "scientific" package.
data Lisp

-- | A symbol (including keyword)
Symbol :: Text -> Lisp

-- | A string.
String :: Text -> Lisp

-- | A number
Number :: Number -> Lisp

-- | A proper list: <tt>(foo x 42)</tt>
List :: [Lisp] -> Lisp

-- | A list with a non-nil tail: <tt>(foo x . 42)</tt>. The list argument
--   must be non-empty and the tail must be non-<a>nil</a>.
DotList :: [Lisp] -> Lisp -> Lisp

-- | The empty list.
nil :: Lisp

-- | Returns <a>True</a> if the expression is <tt>nil</tt> or the empty
--   list.
isNull :: Lisp -> Bool

-- | A type that can be converted from an S-expression, with the
--   possibility of failure.
--   
--   When writing an instance, use <a>mzero</a> or <a>fail</a> to make a
--   conversion fail, e.g. the value is of the wrong type.
--   
--   An example type and instance:
--   
--   @data Coord { x :: Double, y :: Double }
--   
--   instance FromLisp Coord where parseLisp (<a>DotList</a> [x] y) = pure
--   (Coord x y) -- A non-DotList value is of the wrong shape, so use mzero
--   to fail. parseLisp _ = <a>mzero</a> @
--   
--   The above instance expects that <tt>Coord 4 5</tt> is encoded as
--   <tt>(4 . 5)</tt>. This makes sense for a few special types, but most
--   of the time the standard encoding should be used: <tt>(coord 4
--   5)</tt>. The <a>struct</a> combinator provides special support for
--   this use case:
--   
--   <pre>
--   instance FromLisp Coord where
--      parseLisp = <a>struct</a> "coord" Coord
--   </pre>
--   
--   It uses some special type class magic to figure out the arity of its
--   second argument.
class FromLisp a
parseLisp :: FromLisp a => Lisp -> Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a
fromLisp :: FromLisp a => Lisp -> Result a

-- | Failure continuation.
type Failure f r = String -> f r

-- | Success continuation.
type Success a f r = a -> f r

-- | A continuation-based parser type.
data Parser a

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | Run a <a>Parser</a> with an <a>Either</a> result type.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Fail parsing due to a type mismatch, with a descriptive message.
typeMismatch :: String -> Lisp -> Parser a

-- | A type that can be converted to an S-expression.
--   
--   An example type and instance:
--   
--   @data Coord { x :: Double, y :: Double }
--   
--   instance ToLisp Coord where toLisp (Coord x y) = <a>struct</a> "coord"
--   [toLisp x, toLisp y] @
class ToLisp a
toLisp :: ToLisp a => a -> Lisp

-- | Create a Lisp struct in a standardised format.
--   
--   Fields in a struct are accessed by position.
mkStruct :: Text -> [Lisp] -> Lisp

-- | Decode structure serialised with <a>mkStruct</a>.
--   
--   The second argument should be a function, usually a constructor. The
--   resulting parser automatically figures out the arity of the function.
--   For example:
--   
--   @data Foo = Foo Int deriving (Eq, Show)
--   
--   parseFoo :: Lisp -&gt; <a>Parser</a> Foo parseFoo = struct "foo" Foo
--   
--   test = <a>parseMaybe</a> parseFoo val == Just (Foo 23) where val =
--   <a>List</a> [<a>Symbol</a> "foo", <a>Number</a> 23] @
struct :: ParseList f a => Text -> f -> Lisp -> Parser a
encode :: ToLisp a => a -> ByteString
fromLispExpr :: Lisp -> Builder

-- | Parse an arbitrary lisp expression.
lisp :: Parser Lisp

-- | Parse a symbol or a number. Symbols are expected to be utf8.
atom :: Parser Lisp
instance [overlap ok] Typeable Lisp
instance [overlap ok] Typeable Result
instance [overlap ok] Eq Lisp
instance [overlap ok] Ord Lisp
instance [overlap ok] Data Lisp
instance [overlap ok] Eq a => Eq (Result a)
instance [overlap ok] Show a => Show (Result a)
instance [overlap ok] (Ord a, FromLisp a, FromLisp b) => FromLisp (Map a b)
instance [overlap ok] (ToLisp a, ToLisp b) => ToLisp (Map a b)
instance [overlap ok] (FromLisp a, FromLisp b, FromLisp c) => FromLisp (a, b, c)
instance [overlap ok] (ToLisp a, ToLisp b, ToLisp c) => ToLisp (a, b, c)
instance [overlap ok] (FromLisp a, FromLisp b) => FromLisp (a, b)
instance [overlap ok] (ToLisp a, ToLisp b) => ToLisp (a, b)
instance [overlap ok] FromLisp a => FromLisp [a]
instance [overlap ok] ToLisp a => ToLisp [a]
instance [overlap ok] FromLisp Word64
instance [overlap ok] ToLisp Word64
instance [overlap ok] FromLisp Word32
instance [overlap ok] ToLisp Word32
instance [overlap ok] FromLisp Word16
instance [overlap ok] ToLisp Word16
instance [overlap ok] FromLisp Word8
instance [overlap ok] ToLisp Word8
instance [overlap ok] FromLisp Word
instance [overlap ok] ToLisp Word
instance [overlap ok] FromLisp Int64
instance [overlap ok] ToLisp Int64
instance [overlap ok] FromLisp Int32
instance [overlap ok] ToLisp Int32
instance [overlap ok] FromLisp Int16
instance [overlap ok] ToLisp Int16
instance [overlap ok] FromLisp Int8
instance [overlap ok] ToLisp Int8
instance [overlap ok] FromLisp (Ratio Integer)
instance [overlap ok] ToLisp (Ratio Integer)
instance [overlap ok] FromLisp Number
instance [overlap ok] ToLisp Number
instance [overlap ok] FromLisp Float
instance [overlap ok] ToLisp Float
instance [overlap ok] FromLisp Double
instance [overlap ok] ToLisp Double
instance [overlap ok] FromLisp [Char]
instance [overlap ok] ToLisp [Char]
instance [overlap ok] (FromLisp a, FromLisp b) => FromLisp (Either a b)
instance [overlap ok] (ToLisp a, ToLisp b) => ToLisp (Either a b)
instance [overlap ok] FromLisp a => FromLisp (Maybe a)
instance [overlap ok] ToLisp a => ToLisp (Maybe a)
instance [overlap ok] FromLisp ()
instance [overlap ok] ToLisp ()
instance [overlap ok] FromLisp Text
instance [overlap ok] ToLisp Text
instance [overlap ok] FromLisp Int
instance [overlap ok] ToLisp Int
instance [overlap ok] FromLisp Integer
instance [overlap ok] ToLisp Integer
instance [overlap ok] FromLisp Char
instance [overlap ok] ToLisp Char
instance [overlap ok] FromLisp Bool
instance [overlap ok] ToLisp Bool
instance [overlap ok] FromLisp Lisp
instance [overlap ok] ToLisp Lisp
instance [overlap ok] TypeCast'' () a a
instance [overlap ok] TypeCast'' t a b => TypeCast' t a b
instance [overlap ok] TypeCast' () a b => TypeCast a b
instance [overlap ok] TypeCast f HFalse => IsFunction a f
instance [overlap ok] TypeCast f HTrue => IsFunction (x -> y) f
instance [overlap ok] ParseList' HFalse a a
instance [overlap ok] (FromLisp a, IsFunction b f, ParseList' f b c, ParseList b c) => ParseList' HTrue (a -> b) c
instance [overlap ok] (IsFunction a f, ParseList' f a b) => ParseList a b
instance [overlap ok] Monoid (Result a)
instance [overlap ok] Alternative Result
instance [overlap ok] MonadPlus Result
instance [overlap ok] Applicative Result
instance [overlap ok] Monad Result
instance [overlap ok] Functor Result
instance [overlap ok] NFData a => NFData (Result a)
instance [overlap ok] Monoid (Parser a)
instance [overlap ok] MonadPlus Parser
instance [overlap ok] Alternative Parser
instance [overlap ok] Applicative Parser
instance [overlap ok] Functor Parser
instance [overlap ok] Monad Parser
instance [overlap ok] NFData Lisp
instance [overlap ok] IsString Lisp
instance [overlap ok] Show Lisp
