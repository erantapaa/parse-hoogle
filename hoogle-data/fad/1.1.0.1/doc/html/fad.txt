-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Forward Automatic Differentiation.
--   
--   Forward Automatic Differentiation via overloading to perform
--   nonstandard interpretation that replaces original numeric type with
--   corresponding generalized dual number type. Existential type
--   "branding" is used to prevent perturbation confusion. **Note: In
--   general we recommend using the ad package maintained by Edward Kmett
--   instead of this package.**
@package fad
@version 1.1.0.1


-- | Forward Automatic Differentiation via overloading to perform
--   nonstandard interpretation that replaces original numeric type with
--   corresponding generalized dual number type.
--   
--   Credits:
--   
--   Authors: Copyright 2008, Barak A. Pearlmutter
--   (<a>barak@cs.nuim.ie</a>) &amp; Jeffrey Mark Siskind
--   (<a>qobi@purdue.edu</a>)
--   
--   Work started as stripped-down version of higher-order tower code
--   published by Jerzy Karczmarczuk
--   (<a>jerzy.karczmarczuk@info.unicaen.fr</a>) which used a non-standard
--   standard prelude.
--   
--   Initial perturbation-confusing code is a modified version of
--   <a>http://cdsmith.wordpress.com/2007/11/29/some-playing-with-derivatives/</a>
--   
--   Tag trick, called "branding" in the Haskell community, from Bj√∂rn
--   Buckwalter (<a>bjorn.buckwalter@gmail.com</a>)
--   <a>http://thread.gmane.org/gmane.comp.lang.haskell.cafe/22308/</a>
--   
--   Notes:
--   
--   Each invocation of the differentiation function introduces a distinct
--   perturbation, which requires a distinct derivative-carrying number
--   type. In order to prevent these from being confused, tagging, called
--   branding in the Haskell community, is used. This seems to prevent
--   perturbation confusion, although it would be nice to have an actual
--   proof of this. The technique does require adding invocations of lift
--   at appropriate places when nesting is present, and degrades modularity
--   by exposing <a>forall</a> types in type signatures.
module Numeric.FAD

-- | The <a>Tower</a> type is a concrete representation of a higher-order
--   Dual number, meaning a number augmented with a tower of derivatives.
--   These generalize the Dual numbers of Clifford (1873), which hold only
--   a first derivative. They can be converted to formal power series via
--   division by the sequence of factorials.
data Tower tag a

-- | The <a>lift</a> function injects a primal number into the domain of
--   derivative towers, with a zero tower. If generalized dual numbers were
--   a monad, <a>lift</a> would be <a>return</a>.
lift :: (Eq a, Num a) => a -> Tower tag a

-- | The <a>primal</a> function finds the primal value from a derivative |
--   tower. The inverse of <a>lift</a>.
primal :: (Eq a, Num a) => Tower tag a -> a

-- | The <a>diffUU</a> function calculates the first derivative of a
--   scalar-to-scalar function.
diffUU :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> b

-- | The <a>diffUF</a> function calculates the first derivative of
--   scalar-to-nonscalar function.
diffUF :: (Eq a, Num a, Eq b, Num b, Functor f) => (forall tag. Tower tag a -> f (Tower tag b)) -> a -> f b

-- | The <a>diffMU</a> function calculate the product of the Jacobian of a
--   nonscalar-to-scalar function with a given vector. Aka: directional
--   derivative.
diffMU :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> Tower tag b) -> [a] -> [a] -> b

-- | The <a>diffMF</a> function calculates the product of the Jacobian of a
--   nonscalar-to-nonscalar function with a given vector. Aka: directional
--   derivative.
diffMF :: (Eq a, Num a, Eq b, Num b, Functor f) => (forall tag. [Tower tag a] -> f (Tower tag b)) -> [a] -> [a] -> f b

-- | The <a>diff2UU</a> function calculates the value and derivative, as a
--   pair, of a scalar-to-scalar function.
diff2UU :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> (b, b)

-- | The <tt>diffUF2</tt> function calculates the value and derivative, as
--   a pair, of a scalar-to-nonscalar function.
diff2UF :: (Eq a, Num a, Eq b, Num b, Functor f) => (forall tag. Tower tag a -> f (Tower tag b)) -> a -> (f b, f b)

-- | The <tt>diffMU2</tt> function calculates the value and directional
--   derivative, as a pair, of a nonscalar-to-scalar function.
diff2MU :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> Tower tag b) -> [a] -> [a] -> (b, b)

-- | The <tt>diffMF2</tt> function calculates the value and directional
--   derivative, as a pair, of a nonscalar-to-nonscalar function.
diff2MF :: (Eq a, Num a, Eq b, Num b, Functor f) => (forall tag. [Tower tag a] -> f (Tower tag b)) -> [a] -> [a] -> (f b, f b)

-- | The <a>diffsUU</a> function calculates a list of derivatives of a
--   scalar-to-scalar function. The 0-th element of the list is the primal
--   value, the 1-st element is the first derivative, etc.
diffsUU :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> [b]

-- | The <a>diffsUF</a> function calculates an infinite list of derivatives
--   of a scalar-to-nonscalar function. The 0-th element of the list is the
--   primal value, the 1-st element is the first derivative, etc.
diffsUF :: (Eq a, Num a, Eq b, Num b, Functor f, Foldable f) => (forall tag. Tower tag a -> f (Tower tag b)) -> a -> [f b]

-- | The <a>diffsMU</a> function calculates an infinite list of derivatives
--   of a nonscalar-to-scalar function. The 0-th element of the list is the
--   primal value, the 1-st element is the first derivative, etc. The input
--   is a (possibly truncated) list of the primal, first derivative, etc,
--   of the input.
diffsMU :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> Tower tag b) -> [[a]] -> [b]

-- | The <a>diffsMF</a> function calculates an infinite list of derivatives
--   of a nonscalar-to-nonscalar function. The 0-th element of the list is
--   the primal value, the 1-st element is the first derivative, etc. The
--   input is a (possibly truncated) list of the primal, first derivative,
--   etc, of the input.
diffsMF :: (Eq a, Num a, Eq b, Num b, Functor f, Foldable f) => (forall tag. [Tower tag a] -> f (Tower tag b)) -> [[a]] -> [f b]

-- | The <a>diffs0UU</a> function is like <a>diffsUU</a> except the output
--   is zero padded.
diffs0UU :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> [b]

-- | The <a>diffs0UF</a> function is like <a>diffsUF</a> except the output
--   is zero padded.
diffs0UF :: (Eq a, Num a, Eq b, Num b, Functor f, Foldable f) => (forall tag. Tower tag a -> f (Tower tag b)) -> a -> [f b]

-- | The <a>diffs0MU</a> function is like <a>diffsMU</a> except the output
--   is zero padded.
diffs0MU :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> Tower tag b) -> [[a]] -> [b]

-- | The <a>diffs0MF</a> function is like <a>diffsMF</a> except the output
--   is zero padded.
diffs0MF :: (Eq a, Num a, Eq b, Num b, Functor f, Foldable f) => (forall tag. [Tower tag a] -> f (Tower tag b)) -> [[a]] -> [f b]

-- | The <a>diff</a> function is a synonym for <a>diffUU</a>.
diff :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> b

-- | The <a>diff2</a> function is a synonym for <a>diff2UU</a>.
diff2 :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> (b, b)

-- | The <a>diffs</a> function is a synonym for <a>diffsUU</a>.
diffs :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> [b]

-- | The <a>diffs0</a> function is a synonym for <a>diffs0UU</a>.
diffs0 :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> [b]

-- | The <a>grad</a> function calculates the gradient of a
--   nonscalar-to-scalar function, using n invocations of forward AD, where
--   n is the input dimmensionality. NOTE: this is O(n) inefficient as
--   compared to reverse AD.
grad :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> Tower tag b) -> [a] -> [b]

-- | The <a>jacobian</a> function calcualtes the Jacobian of a
--   nonscalar-to-nonscalar function, using n invocations of forward AD,
--   where n is the input dimmensionality.
jacobian :: (Eq a, Num a, Eq b, Num b) => (forall tag. [Tower tag a] -> [Tower tag b]) -> [a] -> [[b]]

-- | The <a>zeroNewton</a> function finds a zero of a scalar function using
--   Newton's method; its output is a stream of increasingly accurate
--   results. (Modulo the usual caveats.)
--   
--   TEST CASE: <tt>take 10 $ zeroNewton (\x-&gt;x^2-4) 1 -- converge to
--   2.0</tt>
--   
--   TEST CASE :module Data.Complex Numeric.FAD <tt>take 10 $ zeroNewton
--   ((+1).(^2)) (1 :+ 1) -- converge to (0 :+ 1)</tt>
zeroNewton :: (Eq a, Fractional a) => (forall tag. Tower tag a -> Tower tag a) -> a -> [a]

-- | The <a>inverseNewton</a> function inverts a scalar function using
--   Newton's method; its output is a stream of increasingly accurate
--   results. (Modulo the usual caveats.)
--   
--   TEST CASE: <tt>take 10 $ inverseNewton sqrt 1 (sqrt 10) -- converge to
--   10</tt>
inverseNewton :: (Eq a, Fractional a) => (forall tag. Tower tag a -> Tower tag a) -> a -> a -> [a]

-- | The <a>fixedPointNewton</a> function find a fixedpoint of a scalar
--   function using Newton's method; its output is a stream of increasingly
--   accurate results. (Modulo the usual caveats.)
fixedPointNewton :: (Eq a, Fractional a) => (forall tag. Tower tag a -> Tower tag a) -> a -> [a]

-- | The <a>extremumNewton</a> function finds an extremum of a scalar
--   function using Newton's method; produces a stream of increasingly
--   accurate results. (Modulo the usual caveats.)
extremumNewton :: (Eq a, Fractional a) => (forall tag tag1. Tower tag1 (Tower tag a) -> Tower tag1 (Tower tag a)) -> a -> [a]

-- | The <a>argminNaiveGradient</a> function performs a multivariate
--   optimization, based on the naive-gradient-descent in the file
--   <tt>stalingrad/examples/flow-tests/pre-saddle-1a.vlad</tt> from the
--   VLAD compiler Stalingrad sources. Its output is a stream of
--   increasingly accurate results. (Modulo the usual caveats.) The
--   gradient is calculated using Forward AD, which is O(n) inefficient as
--   compared to Reverse AD, where n is the input dimensionality.
argminNaiveGradient :: (Eq a, Fractional a, Ord a) => (forall tag. [Tower tag a] -> Tower tag a) -> [a] -> [[a]]

-- | The <a>primalUU</a> function lowers a function over dual numbers to a
--   function in the primal domain, where the function is scalar-to-scalar.
primalUU :: (Eq a, Num a, Eq b, Num b) => (forall tag. Tower tag a -> Tower tag b) -> a -> b

-- | The <a>primalUF</a> function lowers a function over dual numbers to a
--   function over primals, where the function is scalar-to-nonscalar.
primalUF :: (Eq a, Num a, Eq b, Num b, Functor fb) => (forall tag. Tower tag a -> fb (Tower tag b)) -> a -> (fb b)

-- | The <a>primalFU</a> function lowers a function over dual numbers to a
--   function over primals where the function is nonscalar-to-scalar.
primalFU :: (Eq a, Num a, Eq b, Num b, Functor fa) => (forall tag. fa (Tower tag a) -> Tower tag b) -> (fa a) -> b

-- | The <a>primalFF</a> function lowers a function over dual numbers to a
--   function over primals where the function is nonscalar-to-nonscalar.
primalFF :: (Eq a, Num a, Eq b, Num b, Functor fa, Functor fb) => (forall tag. fa (Tower tag a) -> fb (Tower tag b)) -> (fa a) -> (fb b)

-- | The <a>taylor</a> function evaluate a Taylor series of the given
--   function around the given point with the given delta. It returns a
--   list of increasingly higher-order approximations.
--   
--   EXAMPLE: <tt>taylor exp 0 1</tt>
taylor :: (Eq a, Fractional a) => (forall tag. Tower tag a -> Tower tag a) -> a -> a -> [a]

-- | The <a>taylor2</a> function evaluates a two-dimensional Taylor series
--   of the given function. This is calculated by nested application of the
--   <a>taylor</a> function, and the exported signature reflects this.
taylor2 :: (Eq a, Fractional a) => (forall tag0 tag. Tower tag0 (Tower tag a) -> Tower tag0 (Tower tag a) -> Tower tag0 (Tower tag a)) -> a -> a -> a -> a -> [[a]]
instance Show a => Show (Tower tag a)
instance Integral a => Integral (Tower tag a)
instance (Enum a, Eq a, Num a, Ord a) => Enum (Tower tag a)
instance (Ord a, Eq a, Num a) => Ord (Tower tag a)
instance (Eq a, Num a) => Eq (Tower tag a)
instance Real a => Real (Tower tag a)
instance RealFrac a => RealFrac (Tower tag a)
instance (RealFloat a, RealFrac a) => RealFloat (Tower tag a)
instance (Eq a, Floating a) => Floating (Tower tag a)
instance (Eq a, Fractional a) => Fractional (Tower tag a)
instance (Eq a, Num a) => Num (Tower tag a)
