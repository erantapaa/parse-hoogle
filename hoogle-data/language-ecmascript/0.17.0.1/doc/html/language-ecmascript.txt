-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JavaScript parser and pretty-printer library
--   
@package language-ecmascript
@version 0.17.0.1


-- | This isn't a lexer in the sense that it provides a JavaScript
--   token-stream. This module provides character-parsers for various
--   JavaScript tokens.
module Language.ECMAScript3.Lexer
lexeme :: Stream s Identity Char => Parser s a -> Parser s a
identifier :: Stream s Identity Char => Parser s String
reserved :: Stream s Identity Char => String -> Parser s ()
operator :: Stream s Identity Char => Parser s String
reservedOp :: Stream s Identity Char => String -> Parser s ()
charLiteral :: Stream s Identity Char => Parser s Char
stringLiteral :: Stream s Identity Char => Parser s String
symbol :: Stream s Identity Char => String -> Parser s String
whiteSpace :: Stream s Identity Char => Parser s ()
parens :: Stream s Identity Char => Parser s a -> Parser s a
braces :: Stream s Identity Char => Parser s a -> Parser s a
brackets :: Stream s Identity Char => Parser s a -> Parser s a
squares :: Stream s Identity Char => Parser s a -> Parser s a
semi :: Stream s Identity Char => Parser s String
comma :: Stream s Identity Char => Parser s String
colon :: Stream s Identity Char => Parser s String
dot :: Stream s Identity Char => Parser s String
identifierStart :: Stream s Identity Char => Parser s Char
hexIntLit :: Stream s Identity Char => Parser s String
decIntLit :: Stream s Identity Char => Parser s String
decDigits :: Stream s Identity Char => Parser s String
decDigitsOpt :: Stream s Identity Char => Parser s String
exponentPart :: Stream s Identity Char => Parser s String

-- | returns (s, True) if the number is an integer, an (s, False) otherwise
decLit :: Stream s Identity Char => Parser s (String, Bool)


-- | ECMAScript 3 syntax. <i>Spec</i> refers to the ECMA-262 specification,
--   3rd edition.
module Language.ECMAScript3.Syntax
data JavaScript a

-- | A script in &lt;script&gt; ... &lt;/script&gt; tags.
Script :: a -> [Statement a] -> JavaScript a

-- | extracts statements from a JavaScript type
unJavaScript :: JavaScript a -> [Statement a]

-- | Statements, spec 12.
data Statement a

-- | <tt>{stmts}</tt>, spec 12.1
BlockStmt :: a -> [Statement a] -> Statement a

-- | <tt>;</tt>, spec 12.3
EmptyStmt :: a -> Statement a

-- | <tt>expr;</tt>, spec 12.4
ExprStmt :: a -> (Expression a) -> Statement a

-- | <tt>if (e) stmt</tt>, spec 12.5
IfStmt :: a -> (Expression a) -> (Statement a) -> (Statement a) -> Statement a

-- | <tt>if (e) stmt1 else stmt2</tt>, spec 12.5
IfSingleStmt :: a -> (Expression a) -> (Statement a) -> Statement a

-- | <tt>switch (e) clauses</tt>, spec 12.11
SwitchStmt :: a -> (Expression a) -> [CaseClause a] -> Statement a

-- | <tt>while (e) do stmt</tt>, spec 12.6
WhileStmt :: a -> (Expression a) -> (Statement a) -> Statement a

-- | <tt>do stmt while (e);</tt>, spec 12.6
DoWhileStmt :: a -> (Statement a) -> (Expression a) -> Statement a

-- | <tt>break lab;</tt>, spec 12.8
BreakStmt :: a -> (Maybe (Id a)) -> Statement a

-- | <tt>continue lab;</tt>, spec 12.7
ContinueStmt :: a -> (Maybe (Id a)) -> Statement a

-- | <tt>lab: stmt</tt>, spec 12.12
LabelledStmt :: a -> (Id a) -> (Statement a) -> Statement a

-- | <tt>for (x in o) stmt</tt>, spec 12.6
ForInStmt :: a -> (ForInInit a) -> (Expression a) -> (Statement a) -> Statement a

-- | <tt>ForStmt a init test increment body</tt>, <tt>for (init; test,
--   increment) body</tt>, spec 12.6
ForStmt :: a -> (ForInit a) -> (Maybe (Expression a)) -> (Maybe (Expression a)) -> (Statement a) -> Statement a

-- | <tt>try stmt catch(x) stmt finally stmt</tt>, spec 12.14
TryStmt :: a -> (Statement a) -> (Maybe (CatchClause a)) -> (Maybe (Statement a)) -> Statement a

-- | <tt>throw expr;</tt>, spec 12.13
ThrowStmt :: a -> (Expression a) -> Statement a

-- | <tt>return expr;</tt>, spec 12.9
ReturnStmt :: a -> (Maybe (Expression a)) -> Statement a

-- | <tt>with (o) stmt</tt>, spec 12.10
WithStmt :: a -> (Expression a) -> (Statement a) -> Statement a

-- | <tt>var x, y=42;</tt>, spec 12.2
VarDeclStmt :: a -> [VarDecl a] -> Statement a

-- | <tt>function f(x, y, z) {...}</tt>, spec 13
FunctionStmt :: a -> (Id a) -> [Id a] -> [Statement a] -> Statement a

-- | Returns <a>True</a> if the statement is an <i>IterationStatement</i>
--   according to spec 12.6.
isIterationStmt :: Statement a -> Bool

-- | Case clauses, spec 12.11
data CaseClause a

-- | <pre>
--   case e: stmts;
--   </pre>
CaseClause :: a -> (Expression a) -> [Statement a] -> CaseClause a

-- | <pre>
--   default: stmts;
--   </pre>
CaseDefault :: a -> [Statement a] -> CaseClause a

-- | Catch clause, spec 12.14
data CatchClause a

-- | <pre>
--   catch (x) {...}
--   </pre>
CatchClause :: a -> (Id a) -> (Statement a) -> CatchClause a

-- | for initializer, spec 12.6
data ForInit a

-- | empty
NoInit :: ForInit a

-- | <pre>
--   var x, y=42
--   </pre>
VarInit :: [VarDecl a] -> ForInit a

-- | <pre>
--   expr
--   </pre>
ExprInit :: (Expression a) -> ForInit a

-- | for..in initializer, spec 12.6
data ForInInit a

-- | <pre>
--   var x
--   </pre>
ForInVar :: (Id a) -> ForInInit a

-- | <tt>foo.baz</tt>, <tt>foo[bar]</tt>, <tt>z</tt>
ForInLVal :: (LValue a) -> ForInInit a

-- | A variable declaration, spec 12.2
data VarDecl a

-- | <pre>
--   var x = e;
--   </pre>
VarDecl :: a -> (Id a) -> (Maybe (Expression a)) -> VarDecl a

-- | Expressions, see spec 11
data Expression a

-- | <tt>"foo"</tt>, spec 11.1.3, 7.8
StringLit :: a -> String -> Expression a

-- | <tt>RegexpLit a regexp global? case_insensitive?</tt> -- regular
--   expression, see spec 11.1.3, 7.8
RegexpLit :: a -> String -> Bool -> Bool -> Expression a

-- | <tt>41.99999</tt>, spec 11.1.3, 7.8
NumLit :: a -> Double -> Expression a

-- | <tt>42</tt>, spec 11.1.3, 7.8
IntLit :: a -> Int -> Expression a

-- | <tt>true</tt>, spec 11.1.3, 7.8
BoolLit :: a -> Bool -> Expression a

-- | <tt>null</tt>, spec 11.1.3, 7.8
NullLit :: a -> Expression a

-- | <tt>[1,2,3]</tt>, spec 11.1.4
ArrayLit :: a -> [Expression a] -> Expression a

-- | <tt>{foo:"bar", baz: 42}</tt>, spec 11.1.5
ObjectLit :: a -> [(Prop a, Expression a)] -> Expression a

-- | <tt>this</tt>, spec 11.1.1
ThisRef :: a -> Expression a

-- | <tt>foo</tt>, spec 11.1.2
VarRef :: a -> (Id a) -> Expression a

-- | <tt>foo.bar</tt>, spec 11.2.1
DotRef :: a -> (Expression a) -> (Id a) -> Expression a

-- | <tt>foo[bar</tt>, spec 11.2.1
BracketRef :: a -> (Expression a) -> (Expression a) -> Expression a

-- | <tt>new foo(bar)</tt>, spec 11.2.2
NewExpr :: a -> (Expression a) -> [Expression a] -> Expression a

-- | <tt>@e</tt>, spec 11.4 (excluding 11.4.4, 111.4.5)
PrefixExpr :: a -> PrefixOp -> (Expression a) -> Expression a

-- | <tt>++x</tt>, <tt>x--</tt> etc., spec 11.3, 11.4.4, 11.4.5
UnaryAssignExpr :: a -> UnaryAssignOp -> (LValue a) -> Expression a

-- | <tt>e1@e2</tt>, spec 11.5, 11.6, 11.7, 11.8, 11.9, 11.10, 11.11
InfixExpr :: a -> InfixOp -> (Expression a) -> (Expression a) -> Expression a

-- | <tt>e1 ? e2 : e3</tt>, spec 11.12
CondExpr :: a -> (Expression a) -> (Expression a) -> (Expression a) -> Expression a

-- | <tt>e1 @=e2</tt>, spec 11.13
AssignExpr :: a -> AssignOp -> (LValue a) -> (Expression a) -> Expression a

-- | <tt>e1, e2</tt>, spec 11.14
ListExpr :: a -> [Expression a] -> Expression a

-- | <tt>f(x,y,z)</tt>, spec 11.2.3 funcexprs are optionally named
CallExpr :: a -> (Expression a) -> [Expression a] -> Expression a

-- | <tt>function f (x,y,z) {...}</tt>, spec 11.2.5, 13
FuncExpr :: a -> (Maybe (Id a)) -> [Id a] -> [Statement a] -> Expression a

-- | Infix operators: see spec 11.5-11.11
data InfixOp

-- | <pre>
--   &lt;
--   </pre>
OpLT :: InfixOp

-- | <pre>
--   &lt;=
--   </pre>
OpLEq :: InfixOp

-- | <pre>
--   &gt;
--   </pre>
OpGT :: InfixOp

-- | <pre>
--   &gt;=
--   </pre>
OpGEq :: InfixOp

-- | <pre>
--   in
--   </pre>
OpIn :: InfixOp

-- | <pre>
--   instanceof
--   </pre>
OpInstanceof :: InfixOp

-- | <pre>
--   ==
--   </pre>
OpEq :: InfixOp

-- | <pre>
--   !=
--   </pre>
OpNEq :: InfixOp

-- | <pre>
--   ===
--   </pre>
OpStrictEq :: InfixOp

-- | <pre>
--   !===
--   </pre>
OpStrictNEq :: InfixOp

-- | <pre>
--   &amp;&amp;
--   </pre>
OpLAnd :: InfixOp

-- | <pre>
--   ||
--   </pre>
OpLOr :: InfixOp

-- | <pre>
--   *
--   </pre>
OpMul :: InfixOp

-- | <pre>
--   /
--   </pre>
OpDiv :: InfixOp

-- | <pre>
--   %
--   </pre>
OpMod :: InfixOp

-- | <pre>
--   -
--   </pre>
OpSub :: InfixOp

-- | <pre>
--   &lt;&lt;
--   </pre>
OpLShift :: InfixOp

-- | <pre>
--   &gt;&gt;
--   </pre>
OpSpRShift :: InfixOp

-- | <pre>
--   &gt;&gt;&gt;
--   </pre>
OpZfRShift :: InfixOp

-- | <pre>
--   &amp;
--   </pre>
OpBAnd :: InfixOp

-- | <pre>
--   ^
--   </pre>
OpBXor :: InfixOp

-- | <pre>
--   |
--   </pre>
OpBOr :: InfixOp

-- | <pre>
--   +
--   </pre>
OpAdd :: InfixOp

-- | Assignment operators: see spec 11.13
data AssignOp

-- | simple assignment, <tt>=</tt>
OpAssign :: AssignOp

-- | <pre>
--   +=
--   </pre>
OpAssignAdd :: AssignOp

-- | <pre>
--   -=
--   </pre>
OpAssignSub :: AssignOp

-- | <pre>
--   *=
--   </pre>
OpAssignMul :: AssignOp

-- | <pre>
--   /=
--   </pre>
OpAssignDiv :: AssignOp

-- | <pre>
--   %=
--   </pre>
OpAssignMod :: AssignOp

-- | <pre>
--   &lt;&lt;=
--   </pre>
OpAssignLShift :: AssignOp

-- | <pre>
--   &gt;&gt;=
--   </pre>
OpAssignSpRShift :: AssignOp

-- | <pre>
--   &gt;&gt;&gt;=
--   </pre>
OpAssignZfRShift :: AssignOp

-- | <pre>
--   &amp;=
--   </pre>
OpAssignBAnd :: AssignOp

-- | <pre>
--   ^=
--   </pre>
OpAssignBXor :: AssignOp

-- | <pre>
--   |=
--   </pre>
OpAssignBOr :: AssignOp
data Id a
Id :: a -> String -> Id a
unId :: Id a -> String

-- | Prefix operators: see spec 11.4 (excluding 11.4.4, 11.4.5)
data PrefixOp

-- | <pre>
--   !
--   </pre>
PrefixLNot :: PrefixOp

-- | <pre>
--   ~
--   </pre>
PrefixBNot :: PrefixOp

-- | <pre>
--   +
--   </pre>
PrefixPlus :: PrefixOp

-- | <pre>
--   -
--   </pre>
PrefixMinus :: PrefixOp

-- | <pre>
--   typeof
--   </pre>
PrefixTypeof :: PrefixOp

-- | <pre>
--   void
--   </pre>
PrefixVoid :: PrefixOp

-- | <pre>
--   delete
--   </pre>
PrefixDelete :: PrefixOp

-- | Property names in an object initializer: see spec 11.1.5
data Prop a

-- | property name is an identifier, <tt>foo</tt>
PropId :: a -> (Id a) -> Prop a

-- | property name is a string, <tt>"foo"</tt>
PropString :: a -> String -> Prop a

-- | property name is an integer, <tt>42</tt>
PropNum :: a -> Integer -> Prop a

-- | Unary assignment operators: see spec 11.3, 11.4.4, 11.4.5
data UnaryAssignOp

-- | <pre>
--   ++x
--   </pre>
PrefixInc :: UnaryAssignOp

-- | <pre>
--   --x
--   </pre>
PrefixDec :: UnaryAssignOp

-- | <pre>
--   x++
--   </pre>
PostfixInc :: UnaryAssignOp

-- | <pre>
--   x--
--   </pre>
PostfixDec :: UnaryAssignOp

-- | Left-hand side expressions: see spec 11.2
data LValue a

-- | variable reference, <tt>foo</tt>
LVar :: a -> String -> LValue a

-- | <pre>
--   foo.bar
--   </pre>
LDot :: a -> (Expression a) -> String -> LValue a

-- | <pre>
--   foo[bar]
--   </pre>
LBracket :: a -> (Expression a) -> (Expression a) -> LValue a

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos :: *

-- | The ECMAScript standard defines certain syntactic restrictions on
--   programs (or, more precisely, statements) that aren't easily enforced
--   in the AST datatype. These restrictions have to do with labeled
--   statements and break/continue statement, as well as identifier names.
--   Thus, it is possible to manually generate AST's that correspond to
--   syntactically incorrect programs. Use this predicate to check if an
--   <a>JavaScript</a> AST corresponds to a syntactically correct
--   ECMAScript program.
isValid :: (Data a, Typeable a) => JavaScript a -> Bool

-- | Checks if an identifier name is valid according to the spec
isValidIdentifier :: Id a -> Bool

-- | Checks if the <a>String</a> represents a valid identifier name
isValidIdentifierName :: String -> Bool

-- | Checks if a string is in the list of reserved ECMAScript words
isReservedWord :: String -> Bool

-- | Checks if a character is valid at the start of an identifier
isValidIdStart :: Char -> Bool

-- | Checks if a character is valid in an identifier part
isValidIdPart :: Char -> Bool
data EnclosingStatement

-- | The enclosing statement is an iteration statement
EnclosingIter :: [Label] -> EnclosingStatement

-- | The enclosing statement is a switch statement
EnclosingSwitch :: [Label] -> EnclosingStatement

-- | The enclosing statement is some other statement. Note,
--   <a>EnclosingOther</a> is never pushed if the current <tt>labelSet</tt>
--   is empty, so the list of labels in this constructor should always be
--   non-empty
EnclosingOther :: [Label] -> EnclosingStatement
pushLabel :: Monad m => Id b -> StateT ([Label], [EnclosingStatement]) m a -> StateT ([Label], [EnclosingStatement]) m a
pushEnclosing :: Monad m => ([Label] -> EnclosingStatement) -> StateT ([Label], [EnclosingStatement]) m a -> StateT ([Label], [EnclosingStatement]) m a
class HasLabelSet a
getLabelSet :: HasLabelSet a => a -> [Label]
setLabelSet :: HasLabelSet a => [Label] -> a -> a
isIter :: EnclosingStatement -> Bool
isIterSwitch :: EnclosingStatement -> Bool
instance Typeable Id
instance Typeable InfixOp
instance Typeable AssignOp
instance Typeable UnaryAssignOp
instance Typeable PrefixOp
instance Typeable Prop
instance Typeable Statement
instance Typeable ForInInit
instance Typeable LValue
instance Typeable Expression
instance Typeable ForInit
instance Typeable VarDecl
instance Typeable CatchClause
instance Typeable CaseClause
instance Typeable JavaScript
instance Show a => Show (Id a)
instance Eq a => Eq (Id a)
instance Ord a => Ord (Id a)
instance Data a => Data (Id a)
instance Functor Id
instance Foldable Id
instance Traversable Id
instance Show InfixOp
instance Data InfixOp
instance Eq InfixOp
instance Ord InfixOp
instance Enum InfixOp
instance Show AssignOp
instance Data AssignOp
instance Eq AssignOp
instance Ord AssignOp
instance Show UnaryAssignOp
instance Data UnaryAssignOp
instance Eq UnaryAssignOp
instance Ord UnaryAssignOp
instance Show PrefixOp
instance Data PrefixOp
instance Eq PrefixOp
instance Ord PrefixOp
instance Show a => Show (Prop a)
instance Data a => Data (Prop a)
instance Eq a => Eq (Prop a)
instance Ord a => Ord (Prop a)
instance Functor Prop
instance Foldable Prop
instance Traversable Prop
instance Show a => Show (Statement a)
instance Data a => Data (Statement a)
instance Eq a => Eq (Statement a)
instance Ord a => Ord (Statement a)
instance Functor Statement
instance Foldable Statement
instance Traversable Statement
instance Show a => Show (ForInInit a)
instance Data a => Data (ForInInit a)
instance Eq a => Eq (ForInInit a)
instance Ord a => Ord (ForInInit a)
instance Functor ForInInit
instance Foldable ForInInit
instance Traversable ForInInit
instance Show a => Show (LValue a)
instance Eq a => Eq (LValue a)
instance Ord a => Ord (LValue a)
instance Data a => Data (LValue a)
instance Functor LValue
instance Foldable LValue
instance Traversable LValue
instance Show a => Show (Expression a)
instance Data a => Data (Expression a)
instance Eq a => Eq (Expression a)
instance Ord a => Ord (Expression a)
instance Functor Expression
instance Foldable Expression
instance Traversable Expression
instance Show a => Show (ForInit a)
instance Data a => Data (ForInit a)
instance Eq a => Eq (ForInit a)
instance Ord a => Ord (ForInit a)
instance Functor ForInit
instance Foldable ForInit
instance Traversable ForInit
instance Show a => Show (VarDecl a)
instance Data a => Data (VarDecl a)
instance Eq a => Eq (VarDecl a)
instance Ord a => Ord (VarDecl a)
instance Functor VarDecl
instance Foldable VarDecl
instance Traversable VarDecl
instance Show a => Show (CatchClause a)
instance Data a => Data (CatchClause a)
instance Eq a => Eq (CatchClause a)
instance Ord a => Ord (CatchClause a)
instance Functor CatchClause
instance Foldable CatchClause
instance Traversable CatchClause
instance Show a => Show (CaseClause a)
instance Data a => Data (CaseClause a)
instance Eq a => Eq (CaseClause a)
instance Ord a => Ord (CaseClause a)
instance Functor CaseClause
instance Foldable CaseClause
instance Traversable CaseClause
instance Show a => Show (JavaScript a)
instance Data a => Data (JavaScript a)
instance Eq a => Eq (JavaScript a)
instance Ord a => Ord (JavaScript a)
instance Functor JavaScript
instance Foldable JavaScript
instance Traversable JavaScript
instance HasLabelSet EnclosingStatement
instance Show EnclosingStatement
instance Default SourcePos
instance Default a => Default (JavaScript a)


-- | Pretty-printing JavaScript.
module Language.ECMAScript3.PrettyPrint

-- | A class of pretty-printable ECMAScript AST nodes. Will pretty-print
--   correct JavaScript given that the <a>isValid</a> predicate holds for
--   the AST.
class Pretty a
prettyPrint :: Pretty a => a -> Doc

-- | DEPRECATED: Use <a>prettyPrint</a> instead! Renders a JavaScript
--   program as a document, the show instance of <a>Doc</a> will
--   pretty-print it automatically

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
javaScript :: JavaScript a -> Doc

-- | DEPRECATED: Use <a>prettyPrint</a> instead! Renders a list of
--   statements as a <a>String</a>

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
renderStatements :: [Statement a] -> String

-- | DEPRECATED: Use <a>prettyPrint</a> instead! Renders a list of
--   statements as a <a>String</a>

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
renderExpression :: Expression a -> String

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
class PP a
pp :: PP a => a -> Doc

-- | A predicate to tell if the expression --when pretty-printed-- will
--   begin with "function" or '{' and be thus unsafe to use in an
--   expression statement without wrapping it in '()'.
unsafeInExprStmt :: Expression a -> Bool
instance Pretty a => PP a
instance Pretty (Id a)
instance Pretty (Prop a)
instance Pretty PrefixOp
instance Pretty AssignOp
instance Pretty InfixOp
instance Pretty (CaseClause a)
instance Pretty (VarDecl a)
instance Pretty (LValue a)
instance Pretty (ForInInit a)
instance Pretty (ForInit a)
instance Pretty (CatchClause a)
instance Pretty (Statement a)
instance Pretty (Expression a)
instance Pretty [Statement a]
instance Pretty (JavaScript a)


-- | A few helpers to work with the AST annotations
module Language.ECMAScript3.Syntax.Annotations

-- | Removes annotations from a tree
removeAnnotations :: Traversable t => t a -> t ()

-- | Changes all the labels in the tree to another one, given by a
--   function.
reannotate :: Traversable t => (a -> b) -> t a -> t b

-- | add an extra field to the AST labels (the label would look like <tt>
--   (a, b) </tt>)
addExtraAnnotationField :: Traversable t => b -> t a -> t (a, b)

-- | remove an extra field
removeExtraAnnotationField :: Traversable t => t (a, b) -> t a

-- | Assigns unique numeric (Int) ids to each node in the AST. Returns a
--   pair: the tree annotated with UID's and the last ID that was assigned.
assignUniqueIds :: Traversable t => Int -> t a -> (t (a, Int), Int)

-- | Things that have annotations -- for example, nodes in a syntax tree
class HasAnnotation a
getAnnotation :: HasAnnotation a => a b -> b
setAnnotation :: HasAnnotation a => b -> a b -> a b

-- | Modify the annotation of the root node of the syntax tree
withAnnotation :: HasAnnotation a => (b -> b) -> a b -> a b
instance HasAnnotation Id
instance HasAnnotation CatchClause
instance HasAnnotation CaseClause
instance HasAnnotation Prop
instance HasAnnotation VarDecl
instance HasAnnotation LValue
instance HasAnnotation Statement
instance HasAnnotation Expression


-- | Parser for ECMAScript 3.
module Language.ECMAScript3.Parser

-- | Parse from a stream given a parser, same as <a>parse</a> in Parsec. We
--   can use this to parse expressions or statements alone, not just whole
--   programs.
parse :: Stream s Identity Char => Parser s a -> SourceName -> s -> Either ParseError a

-- | The parser type, parametrised by the stream type <tt>s</tt> and the
--   return value <tt>a</tt>
type Parser s a = ParsecT s ParserState Identity a

-- | A parser that parses ECMAScript expressions
expression :: Stream s Identity Char => Parser s (Expression SourcePos)

-- | The parser that parses a single ECMAScript statement
statement :: Stream s Identity Char => Parser s (Statement SourcePos)

-- | A parser that parses an ECMAScript program.
program :: Stream s Identity Char => Parser s (JavaScript SourcePos)

-- | A convenience function that takes a <a>String</a> and tries to parse
--   it as an ECMAScript program:
--   
--   <pre>
--   parseFromString = parse program ""
--   </pre>
parseFromString :: String -> Either ParseError (JavaScript SourcePos)

-- | A convenience function that takes a filename and tries to parse the
--   file contents an ECMAScript program, it fails with an error message if
--   it can't.
parseFromFile :: (Error e, MonadIO m, MonadError e m) => String -> m (JavaScript SourcePos)

-- | Parse a JavaScript program from a string

-- | <i>Deprecated: Use <a>parseFromString</a> instead</i>
parseScriptFromString :: String -> String -> Either ParseError (JavaScript SourcePos)

-- | Read a JavaScript program from file an parse it into a list of
--   statements

-- | <i>Deprecated: Use <a>parseFromFile</a> instead</i>
parseJavaScriptFromFile :: MonadIO m => String -> m [Statement SourcePos]

-- | <i>Deprecated: Use <a>program</a> instead</i>
parseScript :: Stream s Identity Char => Parser s (JavaScript SourcePos)

-- | <i>Deprecated: Use <a>expression</a> instead</i>
parseExpression :: Stream s Identity Char => ExpressionParser s

-- | Parse a JavaScript source string into a list of statements

-- | <i>Deprecated: Use <a>parseFromString</a> instead</i>
parseString :: String -> [Statement SourcePos]

-- | <i>Deprecated: These type aliases will be hidden in the next
--   version</i>
type ParsedStatement = Statement SourcePos

-- | <i>Deprecated: These type aliases will be hidden in the next
--   version</i>
type ParsedExpression = Expression SourcePos

-- | <i>Deprecated: These parsers will be hidden in the next version</i>
parseSimpleExpr' :: Stream s Identity Char => ExpressionParser s

-- | <i>Deprecated: These parsers will be hidden in the next version</i>
parseBlockStmt :: Stream s Identity Char => StatementParser s

-- | <i>Deprecated: Use <a>statement</a> instead</i>
parseStatement :: Stream s Identity Char => StatementParser s

-- | <i>Deprecated: These type aliases will be hidden in the next
--   version</i>
type StatementParser s = Parser s ParsedStatement

-- | <i>Deprecated: These type aliases will be hidden in the next
--   version</i>
type ExpressionParser s = Parser s ParsedExpression

-- | <i>Deprecated: Use <a>expression</a> instead</i>
assignExpr :: Stream s Identity Char => ExpressionParser s

-- | <i>Deprecated: These parsers will be hidden in the next version</i>
parseObjectLit :: Stream s Identity Char => ExpressionParser s


-- | QuickCheck $Arbitrary$ instances for ECMAScript 3 abstract syntax.
module Language.ECMAScript3.Syntax.Arbitrary
cshrink :: Arbitrary a => [a] -> [a]
emptyStmtShrink :: Arbitrary a => a -> [Statement a]
type LabelSubst = Map (Id ()) (Id ())
emptyConstantPool :: Map k a

-- | A class of AST elements that need fixup after generation
class Fixable a
fixUp :: Fixable a => a -> Gen a
fixLValue :: LValue a -> LValue a
fixUpFunExpr :: Data a => Expression a -> Gen (Expression a)
fixUpFunStmt :: Data a => Statement a -> Gen (Statement a)
identifierFixup :: Id a -> Id a

-- | Renames empty identifiers, as well as identifiers that are keywords or
--   future reserved words by prepending a '_' to them. Also substitutes
--   illegal characters with a "_" as well.
identifierNameFixup :: String -> String

-- | Fixes an incorrect nesting of break/continue, making the program abide
--   by the ECMAScript spec (page 92): any continue without a label should
--   be nested within an iteration stmt, any continue with a label should
--   be nested in a labeled statement (not necessarily with the same
--   label); any break statement without a label should be nested in an
--   iteration or switch stmt, any break statement with a label should be
--   nested in a labeled statement (not necessarily with the same label).
--   This is done by either assigning a label (from the set of labels in
--   current scope) to a break/continue statement that doesn't have one (or
--   has a label that's not present in the current scope). Additionally, it
--   removes nested labelled statements with duplicate labels (also a
--   requirement imposed by the spec).
fixBreakContinue :: Data a => [Statement a] -> Gen [Statement a]

-- | choose n elements from a list randomly
rChooseElem :: [a] -> Int -> Gen [a]

-- | Selects a random element of the list
selectRandomElement :: [a] -> Gen a
isSwitchStmt :: Statement a -> Bool
instance Data a => Fixable (LValue a)
instance Data a => Fixable (Prop a)
instance Fixable (Id a)
instance Data a => Fixable (VarDecl a)
instance Data a => Fixable (ForInInit a)
instance Data a => Fixable (ForInit a)
instance Data a => Fixable (CatchClause a)
instance Data a => Fixable (CaseClause a)
instance Data a => Fixable (Statement a)
instance Data a => Fixable (Expression a)
instance Data a => Fixable (JavaScript a)
instance (Data a, Arbitrary a, Enumerable a) => Arbitrary (JavaScript a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (Statement a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (VarDecl a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (CatchClause a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (ForInit a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (ForInInit a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (Expression a)
instance (Data a, Enumerable a, Arbitrary a) => Arbitrary (LValue a)
instance (Enumerable a, Arbitrary a) => Arbitrary (Prop a)
instance (Enumerable a, Arbitrary a, Data a) => Arbitrary (CaseClause a)
instance (Enumerable a, Arbitrary a) => Arbitrary (Id a)
instance Arbitrary PrefixOp
instance Arbitrary UnaryAssignOp
instance Arbitrary InfixOp
instance Arbitrary AssignOp
instance Enumerable a0 => Enumerable (JavaScript a0)
instance Enumerable a0 => Enumerable (Statement a0)
instance Enumerable a0 => Enumerable (Expression a0)
instance Enumerable a0 => Enumerable (VarDecl a0)
instance Enumerable a0 => Enumerable (ForInInit a0)
instance Enumerable a0 => Enumerable (ForInit a0)
instance Enumerable a0 => Enumerable (LValue a0)
instance Enumerable a0 => Enumerable (Prop a0)
instance Enumerable a0 => Enumerable (CatchClause a0)
instance Enumerable a0 => Enumerable (CaseClause a0)
instance Enumerable a0 => Enumerable (Id a0)
instance Enumerable PrefixOp
instance Enumerable UnaryAssignOp
instance Enumerable InfixOp
instance Enumerable AssignOp


-- | Utility combinator functions for simplifying writing programmatic
--   generation of ECMAScript code. Recommended to use together with the
--   -XOverloadedStrings GHC extension.
module Language.ECMAScript3.Syntax.CodeGen
script :: Default a => [Statement a] -> JavaScript a
ident :: Default a => String -> Id a
propId :: Default a => Id a -> Prop a
propS :: Default a => String -> Prop a
propN :: Default a => Integer -> Prop a
lvar :: Default a => String -> LValue a
ldot :: Default a => Expression a -> String -> LValue a
lbrack :: Default a => Expression a -> Expression a -> LValue a
string :: Default a => String -> Expression a
regexp :: Default a => String -> Bool -> Bool -> Expression a
number :: Default a => Double -> Expression a
bool :: Default a => Bool -> Expression a
int :: Default a => Int -> Expression a
null_ :: Default a => Expression a
array :: Default a => [Expression a] -> Expression a
object :: Default a => [(Prop a, Expression a)] -> Expression a
this :: Default a => Expression a
var :: Default a => Id a -> Expression a
dot :: Default a => Expression a -> Id a -> Expression a
brack :: Default a => Expression a -> Expression a -> Expression a
new :: Default a => Expression a -> [Expression a] -> Expression a
prefix :: Default a => PrefixOp -> Expression a -> Expression a
lnot :: Default a => Expression a -> Expression a
bnot :: Default a => Expression a -> Expression a
plus :: Default a => Expression a -> Expression a
minus :: Default a => Expression a -> Expression a
typeof :: Default a => Expression a -> Expression a
void :: Default a => Expression a -> Expression a
delete :: Default a => Expression a -> Expression a
uassign :: Default a => UnaryAssignOp -> LValue a -> Expression a
preinc :: Default a => LValue a -> Expression a
predec :: Default a => LValue a -> Expression a
postinc :: Default a => LValue a -> Expression a
postdec :: Default a => LValue a -> Expression a
infixe :: Default a => InfixOp -> Expression a -> Expression a -> Expression a
lt :: Default a => Expression a -> Expression a -> Expression a
le :: Default a => Expression a -> Expression a -> Expression a
gt :: Default a => Expression a -> Expression a -> Expression a
ge :: Default a => Expression a -> Expression a -> Expression a
in_ :: Default a => Expression a -> Expression a -> Expression a
instanceof :: Default a => Expression a -> Expression a -> Expression a
eq :: Default a => Expression a -> Expression a -> Expression a
neq :: Default a => Expression a -> Expression a -> Expression a
steq :: Default a => Expression a -> Expression a -> Expression a
stneq :: Default a => Expression a -> Expression a -> Expression a
land :: Default a => Expression a -> Expression a -> Expression a
lor :: Default a => Expression a -> Expression a -> Expression a
mul :: Default a => Expression a -> Expression a -> Expression a
div :: Default a => Expression a -> Expression a -> Expression a
mod :: Default a => Expression a -> Expression a -> Expression a
sub :: Default a => Expression a -> Expression a -> Expression a
lshift :: Default a => Expression a -> Expression a -> Expression a
srshift :: Default a => Expression a -> Expression a -> Expression a
zrshift :: Default a => Expression a -> Expression a -> Expression a
band :: Default a => Expression a -> Expression a -> Expression a
bor :: Default a => Expression a -> Expression a -> Expression a
xor :: Default a => Expression a -> Expression a -> Expression a
add :: Default a => Expression a -> Expression a -> Expression a
cond :: Default a => Expression a -> Expression a -> Expression a -> Expression a
assignop :: Default a => AssignOp -> LValue a -> Expression a -> Expression a
assign :: Default a => LValue a -> Expression a -> Expression a
assignadd :: Default a => LValue a -> Expression a -> Expression a
assignsub :: Default a => LValue a -> Expression a -> Expression a
assignmul :: Default a => LValue a -> Expression a -> Expression a
assigndiv :: Default a => LValue a -> Expression a -> Expression a
assignmod :: Default a => LValue a -> Expression a -> Expression a
assignlshift :: Default a => LValue a -> Expression a -> Expression a
assignsrshift :: Default a => LValue a -> Expression a -> Expression a
assignzrshift :: Default a => LValue a -> Expression a -> Expression a
assignband :: Default a => LValue a -> Expression a -> Expression a
assignxor :: Default a => LValue a -> Expression a -> Expression a
assignbor :: Default a => LValue a -> Expression a -> Expression a
list :: Default a => [Expression a] -> Expression a
call :: Default a => Expression a -> [Expression a] -> Expression a
func :: Default a => Id a -> [Id a] -> [Statement a] -> Expression a
lambda :: Default a => [Id a] -> [Statement a] -> Expression a
casee :: Default a => Expression a -> [Statement a] -> CaseClause a
defaultc :: Default a => [Statement a] -> CaseClause a
catch :: Default a => Id a -> Statement a -> CatchClause a
vardecl :: Default a => Id a -> VarDecl a
varinit :: Default a => Id a -> Expression a -> VarDecl a
block :: Default a => [Statement a] -> Statement a
empty :: Default a => Statement a
expr :: Default a => Expression a -> Statement a
ifte :: Default a => Expression a -> Statement a -> Statement a -> Statement a
ift :: Default a => Expression a -> Statement a -> Statement a
switch :: Default a => Expression a -> [CaseClause a] -> Statement a
while :: Default a => Expression a -> Statement a -> Statement a
dowhile :: Default a => Statement a -> Expression a -> Statement a
break :: Default a => Maybe (Id a) -> Statement a
continue :: Default a => Maybe (Id a) -> Statement a
label :: Default a => Id a -> Statement a -> Statement a
forin :: Default a => ForInInit a -> Expression a -> Statement a -> Statement a
for :: Default a => ForInit a -> Maybe (Expression a) -> Maybe (Expression a) -> Statement a -> Statement a
try :: Default a => Statement a -> Statement a
trycatch :: Default a => Statement a -> CatchClause a -> Maybe (Statement a) -> Statement a
tryfinally :: Default a => Statement a -> Statement a -> Statement a
trycatchfinally :: Default a => Statement a -> CatchClause a -> Statement a -> Statement a
throw :: Default a => Expression a -> Statement a
returns :: Default a => Expression a -> Statement a
ret :: Default a => Statement a
with :: Default a => Expression a -> Statement a -> Statement a
vardecls :: Default a => [VarDecl a] -> Statement a
function :: Default a => Id a -> [Id a] -> [Statement a] -> Statement a

-- | Convert an identifier to a String literal
id2string :: Id a -> Expression a

-- | Helper function to convert LValues to expressions
lv2e :: LValue a -> Expression a

-- | Convert an expression to an l-value. May fail with an error
e2lv :: Expression a -> LValue a
forInInit2lv :: ForInInit a -> LValue a
instance Default a => IsString (Expression a)
instance Default a => IsString (LValue a)
instance Default a => IsString (Prop a)
instance Default a => IsString (Id a)


-- | Experimental and very simple quasi-quotation of ECMAScript in Haskell.
--   Doesn't support anti-quotation as of now.
module Language.ECMAScript3.Syntax.QuasiQuote
js :: QuasiQuoter
jsexpr :: QuasiQuoter
jsstmt :: QuasiQuoter


-- | A lexical environment analysis of ECMAScript programs

-- | <i>Deprecated: Use <a>LexicalEnvironment</a> from package
--   'language-ecmascript-analysis'</i>
module Language.ECMAScript3.Analysis.Environment
env :: Map String SourcePos -> [Statement SourcePos] -> (EnvTree, Map String SourcePos)
localVars :: [Statement SourcePos] -> [(String, SourcePos)]

-- | The statically-determinate lexical structure of a JavaScript program.
data EnvTree
EnvTree :: (Map String SourcePos) -> [EnvTree] -> EnvTree


-- | Label-set analysis which annotates all the statements in the script
--   with their label sets according to ECMAScript specification, section
--   12.12. The result of this analysis are useful for building
--   control-flow graphs.

-- | <i>Deprecated: Use <a>LabelSet</a> from package
--   'language-ecmascript-analysis'</i>
module Language.ECMAScript3.Analysis.LabelSets

-- | Annotates statements with their label sets; example use:
--   
--   <pre>
--   &gt;&gt;&gt; let jsa = reannotate (\a -&gt; (a, Set.empty))
--   
--   &gt;&gt;&gt; in  annotateLabelSets jsa snd (\labs (a, ls) -&gt; (a, labs `Set.union` ls))
--   </pre>
annotateLabelSets :: Data a => (a -> Set Label) -> (Set Label -> a -> a) -> JavaScript a -> JavaScript a

-- | Labels are either strings (identifiers) or <i>empty</i> (see 12.12 of
--   the spec)
data Label
Label :: String -> Label
EmptyLabel :: Label
instance Typeable Label
instance Ord Label
instance Eq Label
instance Show Label
instance Data Label


-- | Simple textual diffing of JavaScript programs for inspecting test
--   failures
module Language.ECMAScript3.SourceDiff
jsDiff :: JavaScript a -> JavaScript a -> String


-- | Re-exports commonly used modules.
module Language.ECMAScript3

-- | DEPRECATED: Use <a>prettyPrint</a> instead! Renders a list of
--   statements as a <a>String</a>

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
renderStatements :: [Statement a] -> String

-- | DEPRECATED: Use <a>prettyPrint</a> instead! Renders a list of
--   statements as a <a>String</a>

-- | <i>Deprecated: These interfaces are outdated and would be
--   removed/hidden in version 1.0. Use the Pretty class instead.</i>
renderExpression :: Expression a -> String
