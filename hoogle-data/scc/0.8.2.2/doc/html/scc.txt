-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streaming component combinators
--   
@package scc
@version 0.8.2.2


-- | This module defines <a>Source</a> and <a>Sink</a> types and
--   <a>pipe</a> functions that create them. The method <a>get</a> on
--   <a>Source</a> abstracts away <a>await</a>, and the method <a>put</a>
--   on <a>Sink</a> is a higher-level abstraction of <a>yield</a>. With
--   this arrangement, a single coroutine can yield values to multiple
--   sinks and await values from multiple sources with no need to change
--   the <a>Coroutine</a> functor. The only requirement is that each
--   functor of the sources and sinks the coroutine uses must be an
--   <a>AncestorFunctor</a> of the coroutine's own functor. For example, a
--   coroutine that takes two sources and one sink might be declared like
--   this:
--   
--   <pre>
--   zip :: forall m a1 a2 a3 d x y. (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d)
--          =&gt; Source m a1 [x] -&gt; Source m a2 [y] -&gt; Sink m a3 [(x, y)] -&gt; Coroutine d m ()
--   </pre>
--   
--   Sources, sinks, and coroutines communicating through them are all
--   created using the <a>pipe</a> function or one of its variants. They
--   effectively split the current coroutine into a producer-consumer
--   coroutine pair. The producer gets a new <a>Sink</a> to write to and
--   the consumer a new <a>Source</a> to read from, in addition to all the
--   streams they inherit from the current coroutine. The following
--   function, for example, uses the <i>zip</i> coroutine declard above to
--   add together the pairs of values from two Integer sources:
--   
--   <pre>
--   add :: forall m a1 a2 a3 d. (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d)
--          =&gt; Source m a1 [Integer] -&gt; Source m a2 [Integer] -&gt; Sink m a3 [Integer] -&gt; Coroutine d m ()
--   add source1 source2 sink = do pipe
--                                    (pairSink-&gt; zip source1 source2 pairSink)                         -- producer
--                                    (pairSource-&gt; mapStream (List.map $ uncurry (+)) pairSource sink) -- consumer
--                                 return ()
--   </pre>
module Control.Concurrent.SCC.Streams

-- | A <a>Sink</a> can be used to yield output from any nested
--   <a>Coroutine</a> computation whose functor provably descends from the
--   functor <i>a</i>. It's the write-only end of a communication channel
--   created by <a>pipe</a>.
data Sink (m :: * -> *) a x

-- | A <a>Source</a> can be used to read input into any nested
--   <a>Coroutine</a> computation whose functor provably descends from the
--   functor <i>a</i>. It's the read-only end of a communication channel
--   created by <a>pipe</a>.
data Source (m :: * -> *) a x
type SinkFunctor a x = Sum a (Request x x)
type SourceFunctor a x = Sum a (ReadRequest x)

-- | Class of functors that can be lifted.
class (Functor a, Functor d) => AncestorFunctor (a :: * -> *) (d :: * -> *)

-- | The <a>pipe</a> function splits the computation into two concurrent
--   parts, <i>producer</i> and <i>consumer</i>. The <i>producer</i> is
--   given a <a>Sink</a> to put values into, and <i>consumer</i> a
--   <a>Source</a> to get those values from. Once producer and consumer
--   both complete, <a>pipe</a> returns their paired results.
pipe :: (Monad m, Monoid x, Functor a, a1 ~ SinkFunctor a x, a2 ~ SourceFunctor a x) => (Sink m a1 x -> Coroutine a1 m r1) -> (Source m a2 x -> Coroutine a2 m r2) -> Coroutine a m (r1, r2)

-- | The <a>pipeP</a> function is equivalent to <a>pipe</a>, except it runs
--   the <i>producer</i> and the <i>consumer</i> in parallel.
pipeP :: (MonadParallel m, Monoid x, Functor a, a1 ~ SinkFunctor a x, a2 ~ SourceFunctor a x) => (Sink m a1 x -> Coroutine a1 m r1) -> (Source m a2 x -> Coroutine a2 m r2) -> Coroutine a m (r1, r2)

-- | A generic version of <a>pipe</a>. The first argument is used to
--   combine two computation steps.
pipeG :: (Monad m, Monoid x, Functor a, a1 ~ SinkFunctor a x, a2 ~ SourceFunctor a x) => PairBinder m -> (Sink m a1 x -> Coroutine a1 m r1) -> (Source m a2 x -> Coroutine a2 m r2) -> Coroutine a m (r1, r2)

-- | A disconnected sink that consumes and ignores all data <a>put</a> into
--   it.
nullSink :: (Monad m, Monoid x) => Sink m a x

-- | Function <a>get</a> tries to get a single value from the given
--   <a>Source</a> argument. The intervening <a>Coroutine</a> computations
--   suspend all the way to the <a>pipe</a> function invocation that
--   created the source. The function returns <a>Nothing</a> if the
--   argument source is empty.
get :: (Monad m, AncestorFunctor a d) => Source m a [x] -> Coroutine d m (Maybe x)

-- | Invokes its first argument with the value it gets from the source, if
--   there is any to get.
getWith :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => Source m a x -> (x -> Coroutine d m ()) -> Coroutine d m ()

-- | Tries to get a minimal, <i>i.e.</i>, prime, prefix from the given
--   <a>Source</a> argument. The intervening <a>Coroutine</a> computations
--   suspend all the way to the <a>pipe</a> function invocation that
--   created the source. The function returns <a>mempty</a> if the argument
--   source is empty.
getPrime :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => Source m a x -> Coroutine d m x

-- | Function <a>peek</a> acts the same way as <a>get</a>, but doesn't
--   actually consume the value from the source; sequential calls to
--   <a>peek</a> will always return the same value.
peek :: (Monad m, AncestorFunctor a d) => Source m a [x] -> Coroutine d m (Maybe x)

-- | This function puts a value into the given <a>Sink</a>. The intervening
--   <a>Coroutine</a> computations suspend up to the <a>pipe</a> invocation
--   that has created the argument sink.
put :: (Monad m, AncestorFunctor a d) => Sink m a [x] -> x -> Coroutine d m ()

-- | Like <a>put</a>, but returns a Bool that determines if the sink is
--   still active.
tryPut :: (Monad m, AncestorFunctor a d) => Sink m a [x] -> x -> Coroutine d m Bool

-- | Converts a <a>Sink</a> on the ancestor functor <i>a</i> into a sink on
--   the descendant functor <i>d</i>.
liftSink :: (Monad m, AncestorFunctor a d) => Sink m a x -> Sink m d x

-- | Converts a <a>Source</a> on the ancestor functor <i>a</i> into a
--   source on the descendant functor <i>d</i>.
liftSource :: (Monad m, AncestorFunctor a d) => Source m a x -> Source m d x

-- | Copies all data from the <i>source</i> argument into the <i>sink</i>
--   argument. The result indicates if there was any chunk to copy.
pour :: (Monad m, Monoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => Source m a1 x -> Sink m a2 x -> Coroutine d m Bool

-- | Copies all data from the <i>source</i> argument into the <i>sink</i>
--   argument, like <a>pour</a> but ignoring the result.
pour_ :: (Monad m, Monoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => Source m a1 x -> Sink m a2 x -> Coroutine d m ()

-- | <a>tee</a> is similar to <a>pour</a> except it distributes every input
--   value from its source argument into its both sink arguments.
tee :: (Monad m, Monoid x, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d) => Source m a1 x -> Sink m a2 x -> Sink m a3 x -> Coroutine d m ()

-- | Every value <a>put</a> into a <a>teeSink</a> result sink goes into its
--   both argument sinks: <tt>put (teeSink s1 s2) x</tt> is equivalent to
--   <tt>put s1 x &gt;&gt; put s2 x</tt>. The <a>putChunk</a> method
--   returns the list of values that couldn't fit into the second sink.
teeSink :: (Monad m, AncestorFunctor a1 a3, AncestorFunctor a2 a3) => Sink m a1 x -> Sink m a2 x -> Sink m a3 x

-- | <a>getAll</a> consumes and returns all data generated by the source.
getAll :: (Monad m, Monoid x, AncestorFunctor a d) => Source m a x -> Coroutine d m x

-- | <a>putAll</a> puts an entire list into its <i>sink</i> argument. If
--   the coroutine fed by the <i>sink</i> dies, the remainder of the
--   argument list is returned.
putAll :: (Monad m, MonoidNull x, AncestorFunctor a d) => x -> Sink m a x -> Coroutine d m x

-- | This method puts a portion of the producer's output into the
--   <a>Sink</a>. The intervening <a>Coroutine</a> computations suspend up
--   to the <a>pipe</a> invocation that has created the argument sink. The
--   method returns the suffix of the argument that could not make it into
--   the sink because of the sibling coroutine's death.
putChunk :: Sink m a x -> forall d. AncestorFunctor a d => x -> Coroutine d m x

-- | Consumes inputs from the <i>source</i> as long as the <i>parser</i>
--   accepts it.
getParsed :: (Monad m, Monoid x, Monoid y, AncestorFunctor a d) => Parser p x y -> Source m a x -> Coroutine d m y

-- | Consumes input from the <i>source</i> as long as the <i>reader</i>
--   accepts it.
getRead :: (Monad m, Monoid x, AncestorFunctor a d) => Reader x (y -> y) y -> Source m a x -> Coroutine d m y

-- | Consumes values from the <i>source</i> as long as each satisfies the
--   predicate, then returns their list.
getWhile :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => (x -> Bool) -> Source m a x -> Coroutine d m x

-- | Consumes values from the <i>source</i> until one of them satisfies the
--   predicate or the source is emptied, then returns the pair of the list
--   of preceding values and maybe the one value that satisfied the
--   predicate. The latter is not consumed.
getUntil :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => (x -> Bool) -> Source m a x -> Coroutine d m (x, Maybe x)

-- | Like <a>pour</a>, copies data from the <i>source</i> to the
--   <i>sink</i>, but only as long as it satisfies the predicate.
pourRead :: (Monad m, MonoidNull x, MonoidNull y, AncestorFunctor a1 d, AncestorFunctor a2 d) => Reader x y y -> Source m a1 x -> Sink m a2 y -> Coroutine d m ()

-- | Parses the input data using the given parser and copies the results to
--   output.
pourParsed :: (Monad m, MonoidNull x, MonoidNull y, AncestorFunctor a1 d, AncestorFunctor a2 d) => Parser p x y -> Source m a1 x -> Sink m a2 y -> Coroutine d m ()

-- | Like <a>pour</a>, copies data from the <i>source</i> to the
--   <i>sink</i>, but only as long as it satisfies the predicate.
pourWhile :: (Monad m, FactorialMonoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> Bool) -> Source m a1 x -> Sink m a2 x -> Coroutine d m ()

-- | Like <a>pour</a>, copies data from the <i>source</i> to the
--   <i>sink</i>, but only until one value satisfies the predicate. That
--   value is returned rather than copied.
pourUntil :: (Monad m, FactorialMonoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> Bool) -> Source m a1 x -> Sink m a2 x -> Coroutine d m (Maybe x)
type Reader x py y = x -> Reading x py y
data Reading x py y :: * -> * -> * -> *

-- | Final result chunk with the unconsumed portion of the input
Final :: x -> y -> Reading x py y

-- | A part of the result with the reader of more input and the EOF
Advance :: Reader x py y -> y -> py -> Reading x py y

-- | Reader of more input, plus the result if there isn't any.
Deferred :: Reader x py y -> y -> Reading x py y
data ReadingResult x py y :: * -> * -> * -> *

-- | A part of the result with the reader of more input
ResultPart :: py -> Reader x py y -> ReadingResult x py y

-- | Final result chunk
FinalResult :: y -> ReadingResult x py y

-- | A sink mark-down transformation: the marks get removed off each chunk.
markDown :: (Monad m, MonoidNull x) => Sink m a x -> Sink m a [(x, mark)]

-- | A sink mark-up transformation: every chunk going into the sink is
--   accompanied by the given value.
markUpWith :: (Monad m, Monoid x) => mark -> Sink m a [(x, mark)] -> Sink m a x

-- | An equivalent of <a>map</a> that works on a <a>Sink</a> instead of a
--   list. The argument function is applied to every value vefore it's
--   written to the sink argument.
mapSink :: Monad m => (x -> y) -> Sink m a [y] -> Sink m a [x]

-- | <a>mapStream</a> is like <a>pour</a> that applies the function
--   <i>f</i> to each argument before passing it into the <i>sink</i>.
mapStream :: (Monad m, FactorialMonoid x, Monoid y, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> y) -> Source m a1 x -> Sink m a2 y -> Coroutine d m ()

-- | <a>mapMaybeStream</a> is to <a>mapStream</a> like <a>mapMaybe</a> is
--   to <a>map</a>.
mapMaybeStream :: (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> Maybe y) -> Source m a1 [x] -> Sink m a2 [y] -> Coroutine d m ()

-- | <a>concatMapStream</a> is to <a>mapStream</a> like <a>concatMap</a> is
--   to <a>map</a>.
concatMapStream :: (Monad m, Monoid y, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> y) -> Source m a1 [x] -> Sink m a2 y -> Coroutine d m ()

-- | Like <a>mapStream</a> except it runs the argument function on whole
--   chunks read from the input.
mapStreamChunks :: (Monad m, Monoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> y) -> Source m a1 x -> Sink m a2 y -> Coroutine d m ()

-- | Like <a>mapAccumStream</a> except it runs the argument function on
--   whole chunks read from the input.
mapAccumStreamChunks :: (Monad m, Monoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => (acc -> x -> (acc, y)) -> acc -> Source m a1 x -> Sink m a2 y -> Coroutine d m acc

-- | Similar to <a>foldl</a>, but reads the values from a <a>Source</a>
--   instead of a list.
foldStream :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => (acc -> x -> acc) -> acc -> Source m a x -> Coroutine d m acc

-- | <a>mapAccumStream</a> is similar to <a>mapAccumL</a> except it reads
--   the values from a <a>Source</a> instead of a list and writes the
--   mapped values into a <a>Sink</a> instead of returning another list.
mapAccumStream :: (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d) => (acc -> x -> (acc, y)) -> acc -> Source m a1 [x] -> Sink m a2 [y] -> Coroutine d m acc

-- | <a>concatMapAccumStream</a> is a love child of <a>concatMapStream</a>
--   and <a>mapAccumStream</a>: it threads the accumulator like the latter,
--   but its argument function returns not a single value, but a list of
--   values to write into the sink.
concatMapAccumStream :: (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d) => (acc -> x -> (acc, [y])) -> acc -> Source m a1 [x] -> Sink m a2 [y] -> Coroutine d m acc

-- | Equivalent to <a>partition</a>. Takes a <a>Source</a> instead of a
--   list argument and partitions its contents into the two <a>Sink</a>
--   arguments.
partitionStream :: (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d) => (x -> Bool) -> Source m a1 [x] -> Sink m a2 [x] -> Sink m a3 [x] -> Coroutine d m ()

-- | <a>mapMStream</a> is similar to <a>mapM</a>. It draws the values from
--   a <a>Source</a> instead of a list, writes the mapped values to a
--   <a>Sink</a>, and returns a <a>Coroutine</a>.
mapMStream :: (Monad m, FactorialMonoid x, Monoid y, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> Coroutine d m y) -> Source m a1 x -> Sink m a2 y -> Coroutine d m ()

-- | <a>mapMStream_</a> is similar to <a>mapM_</a> except it draws the
--   values from a <a>Source</a> instead of a list and works with
--   <a>Coroutine</a> instead of an arbitrary monad.
mapMStream_ :: (Monad m, FactorialMonoid x, AncestorFunctor a d) => (x -> Coroutine d m r) -> Source m a x -> Coroutine d m ()

-- | Like <a>mapMStream_</a> except it runs the argument function on whole
--   chunks read from the input.
mapMStreamChunks_ :: (Monad m, Monoid x, AncestorFunctor a d) => (x -> Coroutine d m r) -> Source m a x -> Coroutine d m ()

-- | An equivalent of <a>filterM</a>. Draws the values from a <a>Source</a>
--   instead of a list, writes the filtered values to a <a>Sink</a>, and
--   returns a <a>Coroutine</a>.
filterMStream :: (Monad m, FactorialMonoid x, AncestorFunctor a1 d, AncestorFunctor a2 d) => (x -> Coroutine d m Bool) -> Source m a1 x -> Sink m a2 x -> Coroutine d m ()

-- | <a>foldMStream</a> is similar to <a>foldM</a> except it draws the
--   values from a <a>Source</a> instead of a list and works with
--   <a>Coroutine</a> instead of an arbitrary monad.
foldMStream :: (Monad m, AncestorFunctor a d) => (acc -> x -> Coroutine d m acc) -> acc -> Source m a [x] -> Coroutine d m acc

-- | A variant of <a>foldMStream</a> that discards the final result value.
foldMStream_ :: (Monad m, AncestorFunctor a d) => (acc -> x -> Coroutine d m acc) -> acc -> Source m a [x] -> Coroutine d m ()

-- | <a>unfoldMStream</a> is a version of <a>unfoldr</a> that writes the
--   generated values into a <a>Sink</a> instead of returning a list.
unfoldMStream :: (Monad m, AncestorFunctor a d) => (acc -> Coroutine d m (Maybe (x, acc))) -> acc -> Sink m a [x] -> Coroutine d m acc

-- | <a>unmapMStream_</a> is opposite of <a>mapMStream_</a>; it takes a
--   <a>Sink</a> instead of a <a>Source</a> argument and writes the
--   generated values into it.
unmapMStream_ :: (Monad m, AncestorFunctor a d) => Coroutine d m (Maybe x) -> Sink m a [x] -> Coroutine d m ()

-- | Like <a>unmapMStream_</a> but writing whole chunks of generated data
--   into the argument sink.
unmapMStreamChunks_ :: (Monad m, MonoidNull x, AncestorFunctor a d) => Coroutine d m x -> Sink m a x -> Coroutine d m ()

-- | <a>zipWithMStream</a> is similar to <a>zipWithM</a> except it draws
--   the values from two <a>Source</a> arguments instead of two lists,
--   sends the results into a <a>Sink</a>, and works with <a>Coroutine</a>
--   instead of an arbitrary monad.
zipWithMStream :: (Monad m, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d) => (x -> y -> Coroutine d m z) -> Source m a1 [x] -> Source m a2 [y] -> Sink m a3 [z] -> Coroutine d m ()

-- | <a>parZipWithMStream</a> is equivalent to <a>zipWithMStream</a>, but
--   it consumes the two sources in parallel.
parZipWithMStream :: (MonadParallel m, AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d) => (x -> y -> Coroutine d m z) -> Source m a1 [x] -> Source m a2 [y] -> Sink m a3 [z] -> Coroutine d m ()


-- | This module defines various <a>Coroutine</a> types that operate on
--   <a>Sink</a> and <a>Source</a> values. The simplest of the bunch are
--   <a>Consumer</a> and <a>Producer</a> types, which respectively operate
--   on a single source or sink. A <a>Transducer</a> has access both to a
--   <a>Source</a> to read from and a <a>Sink</a> to write into. Finally, a
--   <a>Splitter</a> reads from a single source and writes all of the
--   input, without any modifications, into two sinks of the same type.
module Control.Concurrent.SCC.Types

-- | A coroutine that has no inputs nor outputs - and therefore may not
--   suspend at all, which means it's not really a <i>co</i>routine.
newtype Performer m r
Performer :: m r -> Performer m r
perform :: Performer m r -> m r
type OpenConsumer m a d x r = (AncestorFunctor a d, Monoid x) => Source m a x -> Coroutine d m r

-- | A coroutine that consumes values from a <a>Source</a>.
newtype Consumer m x r
Consumer :: (forall a d. OpenConsumer m a d x r) -> Consumer m x r
consume :: Consumer m x r -> forall a d. OpenConsumer m a d x r
type OpenProducer m a d x r = (AncestorFunctor a d, Monoid x) => Sink m a x -> Coroutine d m r

-- | A coroutine that produces values and puts them into a <a>Sink</a>.
newtype Producer m x r
Producer :: (forall a d. OpenProducer m a d x r) -> Producer m x r
produce :: Producer m x r -> forall a d. OpenProducer m a d x r
type OpenTransducer m a1 a2 d x y r = (AncestorFunctor a1 d, AncestorFunctor a2 d, Monoid x, Monoid y) => Source m a1 x -> Sink m a2 y -> Coroutine d m r

-- | The <a>Transducer</a> type represents coroutines that transform a data
--   stream. Execution of <a>transduce</a> must continue consuming the
--   given <a>Source</a> and feeding the <a>Sink</a> as long as there is
--   any data in the source.
newtype Transducer m x y
Transducer :: (forall a1 a2 d. OpenTransducer m a1 a2 d x y ()) -> Transducer m x y
transduce :: Transducer m x y -> forall a1 a2 d. OpenTransducer m a1 a2 d x y ()
type OpenSplitter m a1 a2 a3 d x r = (AncestorFunctor a1 d, AncestorFunctor a2 d, AncestorFunctor a3 d, Monoid x) => Source m a1 x -> Sink m a2 x -> Sink m a3 x -> Coroutine d m r

-- | The <a>Splitter</a> type represents coroutines that distribute the
--   input stream acording to some criteria. A splitter should distribute
--   only the original input data, and feed it into the sinks in the same
--   order it has been read from the source. Furthermore, the input source
--   should be entirely consumed and fed into the two sinks.
--   
--   A splitter can be used in two ways: as a predicate to determine which
--   portions of its input stream satisfy a certain property, or as a
--   chunker to divide the input stream into chunks. In the former case,
--   the predicate is considered true for exactly those parts of the input
--   that are written to its <i>true</i> sink. In the latter case, a chunk
--   is a contiguous section of the input stream that is written
--   exclusively to one sink, either true or false. A <a>mempty</a> value
--   written to either of the two sinks can also terminate the chunk
--   written to the other sink.
newtype Splitter m x
Splitter :: (forall a1 a2 a3 d. OpenSplitter m a1 a2 a3 d x ()) -> Splitter m x
split :: Splitter m x -> forall a1 a2 a3 d. OpenSplitter m a1 a2 a3 d x ()

-- | A <a>Boundary</a> value is produced to mark either a <a>Start</a> and
--   <a>End</a> of a region of data, or an arbitrary <a>Point</a> in data.
--   A <a>Point</a> is semantically equivalent to a <a>Start</a>
--   immediately followed by <a>End</a>.
data Boundary y
Start :: y -> Boundary y
End :: y -> Boundary y
Point :: y -> Boundary y

-- | Type of values in a markup-up stream. The <a>Content</a> constructor
--   wraps the actual data.
data Markup y x
Content :: x -> Markup y x
Markup :: (Boundary y) -> Markup y x

-- | A parser is a transducer that marks up its input.
type Parser m x b = Transducer m x [Markup b x]

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
class PipeableComponentPair (m :: * -> *) w c1 c2 c3 | c1 c2 -> c3, c1 c3 -> c2, c2 c3 -> c2, c1 -> m w, c2 -> m w, c3 -> m
compose :: PipeableComponentPair m w c1 c2 c3 => PairBinder m -> c1 -> c2 -> c3

-- | <a>Branching</a> is a type class representing all types that can act
--   as consumers, namely <a>Consumer</a>, <a>Transducer</a>, and
--   <a>Splitter</a>.
class Branching c (m :: * -> *) x r | c -> m x
combineBranches :: Branching c m x r => (forall d. PairBinder m -> (forall a d'. AncestorFunctor d d' => OpenConsumer m a d' x r) -> (forall a d'. AncestorFunctor d d' => OpenConsumer m a d' x r) -> (forall a. OpenConsumer m a d x r)) -> PairBinder m -> c -> c -> c

-- | Creates a proper <a>Consumer</a> from a function that is, but can't be
--   proven to be, an <a>OpenConsumer</a>.
isolateConsumer :: (Monad m, Monoid x) => (forall d. Functor d => Source m d x -> Coroutine d m r) -> Consumer m x r

-- | Creates a proper <a>Producer</a> from a function that is, but can't be
--   proven to be, an <a>OpenProducer</a>.
isolateProducer :: (Monad m, Monoid x) => (forall d. Functor d => Sink m d x -> Coroutine d m r) -> Producer m x r

-- | Creates a proper <a>Transducer</a> from a function that is, but can't
--   be proven to be, an <a>OpenTransducer</a>.
isolateTransducer :: (Monad m, Monoid x) => (forall d. Functor d => Source m d x -> Sink m d y -> Coroutine d m ()) -> Transducer m x y

-- | Creates a proper <a>Splitter</a> from a function that is, but can't be
--   proven to be, an <a>OpenSplitter</a>.
isolateSplitter :: (Monad m, Monoid x) => (forall d. Functor d => Source m d x -> Sink m d x -> Sink m d x -> Coroutine d m ()) -> Splitter m x

-- | Function <a>oneToOneTransducer</a> takes a function that maps one
--   input value to one output value each, and lifts it into a
--   <a>Transducer</a>.
oneToOneTransducer :: (Monad m, FactorialMonoid x, Monoid y) => (x -> y) -> Transducer m x y

-- | Function <a>statelessTransducer</a> takes a function that maps one
--   input value into a list of output values, and lifts it into a
--   <a>Transducer</a>.
statelessTransducer :: Monad m => (x -> y) -> Transducer m [x] y

-- | Function <a>statelessTransducer</a> takes a function that maps one
--   input value into a list of output values, and lifts it into a
--   <a>Transducer</a>.
statelessChunkTransducer :: Monad m => (x -> y) -> Transducer m x y

-- | Function <a>statefulTransducer</a> constructs a <a>Transducer</a> from
--   a state-transition function and the initial state. The transition
--   function may produce arbitrary output at any transition step.
statefulTransducer :: (Monad m, MonoidNull y) => (state -> x -> (state, y)) -> state -> Transducer m [x] y

-- | Function <a>statelessSplitter</a> takes a function that assigns a
--   Boolean value to each input item and lifts it into a <a>Splitter</a>.
statelessSplitter :: Monad m => (x -> Bool) -> Splitter m [x]

-- | Function <a>statefulSplitter</a> takes a state-converting function
--   that also assigns a Boolean value to each input item and lifts it into
--   a <a>Splitter</a>.
statefulSplitter :: Monad m => (state -> x -> (state, Bool)) -> state -> Splitter m [x]
instance [overlap ok] Eq y => Eq (Boundary y)
instance [overlap ok] Show y => Show (Boundary y)
instance [overlap ok] (Eq y, Eq x) => Eq (Markup y x)
instance [overlap ok] Monad m => Branching (Splitter m x) m x ()
instance [overlap ok] Monad m => Branching (Transducer m x y) m x ()
instance [overlap ok] Monad m => Branching (Consumer m x r) m x r
instance [overlap ok] (Monad m, Monoid x, Monoid y, Monoid z) => PipeableComponentPair m y (Transducer m x y) (Transducer m y z) (Transducer m x z)
instance [overlap ok] (Monad m, Monoid x, Monoid y) => PipeableComponentPair m x (Producer m x r) (Transducer m x y) (Producer m y r)
instance [overlap ok] (Monad m, Monoid x, Monoid y) => PipeableComponentPair m y (Transducer m x y) (Consumer m y r) (Consumer m x r)
instance [overlap ok] (Monad m, Monoid x) => PipeableComponentPair m x (Producer m x r) (Consumer m x ()) (Performer m r)
instance [overlap ok] (Monad m, Monoid x) => PipeableComponentPair m x (Producer m x ()) (Consumer m x r) (Performer m r)
instance [overlap ok] (Monad m, Monoid x) => PipeableComponentPair m x (Producer m x ()) (Consumer m x ()) (Performer m ())
instance [overlap ok] (Show x, Show y) => Show (Markup y x)
instance [overlap ok] Functor (Markup y)
instance [overlap ok] Functor Boundary


-- | This module exports the entire SCC library except for low-level
--   modules <a>Control.Concurrent.SCC.Streams</a> and
--   <a>Control.Concurrent.SCC.Types</a>. The exported combinators can be
--   configured to run their components sequentially or in parallel
--   depending on the available resources.
module Control.Concurrent.SCC.Configurable

-- | A component that performs a computation with no inputs nor outputs is
--   a <a>PerformerComponent</a>.
type PerformerComponent m r = Component (Performer m r)

-- | A component that consumes values from a <a>Source</a> is called
--   <a>ConsumerComponent</a>.
type ConsumerComponent m x r = Component (Consumer m x r)

-- | A component that produces values and puts them into a <a>Sink</a> is
--   called <a>ProducerComponent</a>.
type ProducerComponent m x r = Component (Producer m x r)

-- | The <a>TransducerComponent</a> type represents computations that
--   transform a data stream.
type TransducerComponent m x y = Component (Transducer m x y)

-- | The <a>SplitterComponent</a> type represents computations that
--   distribute data acording to some criteria. A splitter should
--   distribute only the original input data, and feed it into the sinks in
--   the same order it has been read from the source. If the two 'Sink c x'
--   arguments of a splitter are the same, the splitter must act as an
--   identity transform.
type SplitterComponent m x = Component (Splitter m x)

-- | The constant cost of each I/O-performing component.
ioCost :: Int

-- | A <a>TransducerComponent</a> that converts a stream of one type to
--   another.
coerce :: (Monad m, Coercible x y) => TransducerComponent m x y

-- | Adjusts the argument consumer to consume the stream of a data type
--   coercible to the type it was meant to consume.
adaptConsumer :: (Monad m, Monoid x, Monoid y, Coercible x y) => ConsumerComponent m y r -> ConsumerComponent m x r

-- | Adjusts the argument producer to produce the stream of a data type
--   coercible from the type it was meant to produce.
adaptProducer :: (Monad m, Monoid x, Monoid y, Coercible x y) => ProducerComponent m x r -> ProducerComponent m y r

-- | Adjusts the argument splitter to split the stream of a data type
--   isomorphic to the type it was meant to split.
adaptSplitter :: (Monad m, Monoid x, Monoid y, Coercible x y, Coercible y x) => SplitterComponent m x -> SplitterComponent m y

-- | ProducerComponent <a>fromStdIn</a> feeds the given sink from the
--   standard input.
fromStdIn :: ProducerComponent IO Text ()

-- | ProducerComponent <a>fromFile</a> opens the named file and feeds the
--   given sink from its contents.
fromFile :: String -> ProducerComponent IO Text ()

-- | ProducerComponent <a>fromHandle</a> feeds the given sink from the open
--   file <i>handle</i>.
fromHandle :: Handle -> ProducerComponent IO Text ()

-- | ConsumerComponent <a>toStdOut</a> copies the given source into the
--   standard output.
toStdOut :: ConsumerComponent IO Text ()

-- | ConsumerComponent <a>toFile</a> opens the named file and copies the
--   given source into it.
toFile :: String -> ConsumerComponent IO Text ()

-- | ConsumerComponent <a>appendFile</a> opens the name file and appends
--   the given source to it.
appendFile :: String -> ConsumerComponent IO Text ()

-- | ConsumerComponent <a>toHandle</a> copies the given source into the
--   open file <i>handle</i>.
toHandle :: Handle -> ConsumerComponent IO Text ()

-- | <a>produceFrom</a> produces the contents of the given argument.
produceFrom :: (Monad m, MonoidNull x) => x -> ProducerComponent m x ()

-- | ConsumerComponent <a>consumeInto</a> collects the given source into
--   the return value.
consumeInto :: (Monad m, Monoid x) => ConsumerComponent m x x

-- | The <a>suppress</a> consumer suppresses all input it receives. It is
--   equivalent to <a>substitute</a> []
suppress :: Monad m => ConsumerComponent m x ()

-- | The <a>erroneous</a> consumer reports an error if any input reaches
--   it.
erroneous :: (Monad m, MonoidNull x) => String -> ConsumerComponent m x ()

-- | TransducerComponent <a>id</a> passes its input through unmodified.
id :: (Monad m, Monoid x) => TransducerComponent m x x

-- | TransducerComponent <a>unparse</a> removes all markup from its input
--   and passes the content through.
unparse :: (Monad m, Monoid x) => TransducerComponent m [Markup b x] x

-- | TransducerComponent <a>parse</a> prepares input content for subsequent
--   parsing.
parse :: (Monad m, Monoid x) => ParserComponent m x y

-- | The <a>lowercase</a> transforms all uppercase letters in the input to
--   lowercase, leaving the rest unchanged.
lowercase :: Monad m => TransducerComponent m String String

-- | The <a>uppercase</a> transforms all lowercase letters in the input to
--   uppercase, leaving the rest unchanged.
uppercase :: Monad m => TransducerComponent m String String

-- | The <a>count</a> transducer counts all its input values and outputs
--   the final tally.
count :: (Monad m, FactorialMonoid x) => TransducerComponent m x [Integer]

-- | Converts each input value <tt>x</tt> to <tt>show x</tt>.
toString :: (Monad m, Show x) => TransducerComponent m [x] [String]

-- | Performs the same task as the <a>substring</a> splitter, but instead
--   of splitting it outputs the input as <tt><a>Markup</a> x
--   <a>OccurenceTag</a></tt> in order to distinguish overlapping strings.
parseSubstring :: (Monad m, Eq x, LeftCancellativeMonoid x, FactorialMonoid x) => x -> ParserComponent m x OccurenceTag

-- | TransducerComponent <a>group</a> collects all its input into a single
--   list item.
group :: (Monad m, Monoid x) => TransducerComponent m x [x]

-- | TransducerComponent <a>concatenate</a> flattens the input stream of
--   lists of values into the output stream of values.
concatenate :: (Monad m, Monoid x) => TransducerComponent m [x] x

-- | Same as <a>concatenate</a> except it inserts the given separator list
--   between every two input lists.
concatSeparate :: (Monad m, MonoidNull x) => x -> TransducerComponent m [x] x

-- | SplitterComponent <a>everything</a> feeds its entire input into its
--   <i>true</i> sink.
everything :: Monad m => SplitterComponent m x

-- | SplitterComponent <a>nothing</a> feeds its entire input into its
--   <i>false</i> sink.
nothing :: (Monad m, Monoid x) => SplitterComponent m x

-- | SplitterComponent <a>marked</a> passes all marked-up input sections to
--   its <i>true</i> sink, and all unmarked input to its <i>false</i> sink.
marked :: (Monad m, Eq y) => SplitterComponent m [Markup y x]

-- | SplitterComponent <a>markedContent</a> passes the content of all
--   marked-up input sections to its <i>true</i> sink, while the outermost
--   tags and all unmarked input go to its <i>false</i> sink.
markedContent :: (Monad m, Eq y) => SplitterComponent m [Markup y x]

-- | SplitterComponent <a>markedWith</a> passes input sections marked-up
--   with the appropriate tag to its <i>true</i> sink, and the rest of the
--   input to its <i>false</i> sink. The argument <i>select</i> determines
--   if the tag is appropriate.
markedWith :: (Monad m, Eq y) => (y -> Bool) -> SplitterComponent m [Markup y x]

-- | SplitterComponent <a>contentMarkedWith</a> passes the content of input
--   sections marked-up with the appropriate tag to its <i>true</i> sink,
--   and the rest of the input to its <i>false</i> sink. The argument
--   <i>select</i> determines if the tag is appropriate.
contentMarkedWith :: (Monad m, Eq y) => (y -> Bool) -> SplitterComponent m [Markup y x]

-- | SplitterComponent <a>one</a> feeds all input values to its <i>true</i>
--   sink, treating every value as a separate section.
one :: (Monad m, FactorialMonoid x) => SplitterComponent m x

-- | SplitterComponent <a>substring</a> feeds to its <i>true</i> sink all
--   input parts that match the contents of the given list argument. If two
--   overlapping parts of the input both match the argument, both are sent
--   to <i>true</i> and each is preceded by an empty chunk on <i>false</i>.
substring :: (Monad m, Eq x, LeftCancellativeMonoid x, FactorialMonoid x) => x -> SplitterComponent m x

-- | SplitterComponent <a>whitespace</a> feeds all white-space characters
--   into its <i>true</i> sink, all others into <i>false</i>.
whitespace :: Monad m => SplitterComponent m String

-- | SplitterComponent <a>letters</a> feeds all alphabetical characters
--   into its <i>true</i> sink, all other characters into | <i>false</i>.
letters :: Monad m => SplitterComponent m String

-- | SplitterComponent <a>digits</a> feeds all digits into its <i>true</i>
--   sink, all other characters into <i>false</i>.
digits :: Monad m => SplitterComponent m String

-- | SplitterComponent <a>nonEmptyLine</a> feeds line-ends into its
--   <i>false</i> sink, and all other characters into <i>true</i>.
nonEmptyLine :: Monad m => SplitterComponent m String

-- | The sectioning splitter <a>line</a> feeds line-ends into its
--   <i>false</i> sink, and line contents into <i>true</i>. A single
--   line-end can be formed by any of the character sequences "\n", "\r",
--   "\r\n", or "\n\r".
line :: Monad m => SplitterComponent m String

-- | Converts a <a>ConsumerComponent</a> into a <a>TransducerComponent</a>
--   with no output.
consumeBy :: Monad m => ConsumerComponent m x r -> TransducerComponent m x y

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
(>->) :: (MonadParallel m, PipeableComponentPair m w c1 c2 c3) => Component c1 -> Component c2 -> Component c3

-- | Class <tt>JoinableComponentPair</tt> applies to any two components
--   that can be combined into a third component with the following
--   properties:
--   
--   <ul>
--   <li>if both argument components consume input, the input of the
--   combined component gets distributed to both components in
--   parallel,<ul><li>if both argument components produce output, the
--   output of the combined component is a concatenation of the complete
--   output from the first component followed by the complete output of the
--   second component, and</li></ul></li>
--   </ul>
--   
--   The <a>join</a> combinator may apply the components in any order.
join :: (MonadParallel m, JoinableComponentPair t1 t2 t3 m x y c1 c2 c3) => Component c1 -> Component c2 -> Component c3

-- | The <a>sequence</a> combinator makes sure its first argument has
--   completed before using the second one.
sequence :: JoinableComponentPair t1 t2 t3 m x y c1 c2 c3 => Component c1 -> Component c2 -> Component c3

-- | Combinator <a>prepend</a> converts the given producer to transducer
--   that passes all its input through unmodified, except | for prepending
--   the output of the argument producer to it. | <a>prepend</a>
--   <i>prefix</i> = <a>join</a> (<a>substitute</a> <i>prefix</i>)
--   <tt>asis</tt>
prepend :: Monad m => ProducerComponent m x r -> TransducerComponent m x x

-- | Combinator <a>append</a> converts the given producer to transducer
--   that passes all its input through unmodified, finally | appending to
--   it the output of the argument producer. | <a>append</a> <i>suffix</i>
--   = <a>join</a> <tt>asis</tt> (<a>substitute</a> <i>suffix</i>)
append :: Monad m => ProducerComponent m x r -> TransducerComponent m x x

-- | The <a>substitute</a> combinator converts its argument producer to a
--   transducer that produces the same output, while | consuming its entire
--   input and ignoring it.
substitute :: (Monad m, Monoid x) => ProducerComponent m y r -> TransducerComponent m x y

-- | The <a>snot</a> (streaming not) combinator simply reverses the outputs
--   of the argument splitter. In other words, data that the argument
--   splitter sends to its <i>true</i> sink goes to the <i>false</i> sink
--   of the result, and vice versa.
snot :: (Monad m, Monoid x) => SplitterComponent m x -> SplitterComponent m x

-- | The <a>&gt;&amp;</a> combinator sends the <i>true</i> sink output of
--   its left operand to the input of its right operand for further
--   splitting. Both operands' <i>false</i> sinks are connected to the
--   <i>false</i> sink of the combined splitter, but any input value to
--   reach the <i>true</i> sink of the combined component data must be
--   deemed true by both splitters.
(>&) :: (MonadParallel m, Monoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | A <a>&gt;|</a> combinator's input value can reach its <i>false</i>
--   sink only by going through both argument splitters' <i>false</i>
--   sinks.
(>|) :: (MonadParallel m, Monoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | Combinator <a>&amp;&amp;</a> is a pairwise logical conjunction of two
--   splitters run in parallel on the same input.
(&&) :: (MonadParallel m, FactorialMonoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | Combinator <a>||</a> is a pairwise logical disjunction of two
--   splitters run in parallel on the same input.
(||) :: (MonadParallel m, FactorialMonoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | The recursive combinator <a>while</a> feeds the true sink of the
--   argument splitter back to itself, modified by the argument transducer.
--   Data fed to the splitter's false sink is passed on unmodified.
while :: (MonadParallel m, MonoidNull x) => TransducerComponent m x x -> SplitterComponent m x -> TransducerComponent m x x

-- | The recursive combinator <a>nestedIn</a> combines two splitters into a
--   mutually recursive loop acting as a single splitter. The true sink of
--   one of the argument splitters and false sink of the other become the
--   true and false sinks of the loop. The other two sinks are bound to the
--   other splitter's source. The use of <a>nestedIn</a> makes sense only
--   on hierarchically structured streams. If we gave it some input
--   containing a flat sequence of values, and assuming both component
--   splitters are deterministic and stateless, an input value would either
--   not loop at all or it would loop forever.
nestedIn :: (MonadParallel m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | The <a>foreach</a> combinator is similar to the combinator <a>ifs</a>
--   in that it combines a splitter and two transducers into another
--   transducer. However, in this case the transducers are re-instantiated
--   for each consecutive portion of the input as the splitter chunks it
--   up. Each contiguous portion of the input that the splitter sends to
--   one of its two sinks gets transducered through the appropriate
--   argument transducer as that transducer's whole input. As soon as the
--   contiguous portion is finished, the transducer gets terminated.
foreach :: (MonadParallel m, MonoidNull x, Branching c m x ()) => SplitterComponent m x -> Component c -> Component c -> Component c

-- | The <a>having</a> combinator combines two pure splitters into a pure
--   splitter. One splitter is used to chunk the input into contiguous
--   portions. Its <i>false</i> sink is routed directly to the <i>false</i>
--   sink of the combined splitter. The second splitter is instantiated and
--   run on each portion of the input that goes to first splitter's
--   <i>true</i> sink. If the second splitter sends any output at all to
--   its <i>true</i> sink, the whole input portion is passed on to the
--   <i>true</i> sink of the combined splitter, otherwise it goes to its
--   <i>false</i> sink.
having :: (MonadParallel m, MonoidNull x, MonoidNull y, Coercible x y) => SplitterComponent m x -> SplitterComponent m y -> SplitterComponent m x

-- | The <a>havingOnly</a> combinator is analogous to the <a>having</a>
--   combinator, but it succeeds and passes each chunk of the input to its
--   <i>true</i> sink only if the second splitter sends no part of it to
--   its <i>false</i> sink.
havingOnly :: (MonadParallel m, MonoidNull x, MonoidNull y, Coercible x y) => SplitterComponent m x -> SplitterComponent m y -> SplitterComponent m x

-- | Combinator <a>followedBy</a> treats its argument
--   <a>SplitterComponent</a>s as patterns components and returns a
--   <a>SplitterComponent</a> that matches their concatenation. A section
--   of input is considered <i>true</i> by the result iff its prefix is
--   considered <i>true</i> by argument <i>s1</i> and the rest of the
--   section is considered <i>true</i> by <i>s2</i>. The splitter <i>s2</i>
--   is started anew after every section split to <i>true</i> sink by
--   <i>s1</i>.
followedBy :: (MonadParallel m, FactorialMonoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | The <a>even</a> combinator takes every input section that its argument
--   <i>splitter</i> deems <i>true</i>, and feeds even ones into its
--   <i>true</i> sink. The odd sections and parts of input that are
--   <i>false</i> according to its argument splitter are fed to <a>even</a>
--   splitter's <i>false</i> sink.
even :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The result of combinator <a>first</a> behaves the same as the argument
--   splitter up to and including the first portion of the input which goes
--   into the argument's <i>true</i> sink. All input following the first
--   true portion goes into the <i>false</i> sink.
first :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The result of combinator <a>uptoFirst</a> takes all input up to and
--   including the first portion of the input which goes into the
--   argument's <i>true</i> sink and feeds it to the result splitter's
--   <i>true</i> sink. All the rest of the input goes into the <i>false</i>
--   sink. The only difference between <a>first</a> and <a>uptoFirst</a>
--   combinators is in where they direct the <i>false</i> portion of the
--   input preceding the first <i>true</i> part.
uptoFirst :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The <a>prefix</a> combinator feeds its <i>true</i> sink only the
--   prefix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
prefix :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The result of the combinator <a>last</a> is a splitter which directs
--   all input to its <i>false</i> sink, up to the last portion of the
--   input which goes to its argument's <i>true</i> sink. That portion of
--   the input is the only one that goes to the resulting component's
--   <i>true</i> sink. The splitter returned by the combinator <a>last</a>
--   has to buffer the previous two portions of its input, because it
--   cannot know if a true portion of the input is the last one until it
--   sees the end of the input or another portion succeeding the previous
--   one.
last :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The result of the combinator <a>lastAndAfter</a> is a splitter which
--   directs all input to its <i>false</i> sink, up to the last portion of
--   the input which goes to its argument's <i>true</i> sink. That portion
--   and the remainder of the input is fed to the resulting component's
--   <i>true</i> sink. The difference between <a>last</a> and
--   <a>lastAndAfter</a> combinators is where they feed the <i>false</i>
--   portion of the input, if any, remaining after the last <i>true</i>
--   part.
lastAndAfter :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | The <a>suffix</a> combinator feeds its <i>true</i> sink only the
--   suffix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
suffix :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | SplitterComponent <a>startOf</a> issues an empty <i>true</i> section
--   at the beginning of every section considered <i>true</i> by its
--   argument splitter, otherwise the entire input goes into its
--   <i>false</i> sink.
startOf :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | SplitterComponent <a>endOf</a> issues an empty <i>true</i> section at
--   the end of every section considered <i>true</i> by its argument
--   splitter, otherwise the entire input goes into its <i>false</i> sink.
endOf :: (Monad m, MonoidNull x) => SplitterComponent m x -> SplitterComponent m x

-- | Combinator <a>...</a> tracks the running balance of difference between
--   the number of preceding starts of sections considered <i>true</i>
--   according to its first argument and the ones according to its second
--   argument. The combinator passes to <i>true</i> all input values for
--   which the difference balance is positive. This combinator is typically
--   used with <a>startOf</a> and <a>endOf</a> in order to count entire
--   input sections and ignore their lengths.
(...) :: (MonadParallel m, FactorialMonoid x) => SplitterComponent m x -> SplitterComponent m x -> SplitterComponent m x

-- | Converts a splitter into a parser.
parseRegions :: (Monad m, MonoidNull x) => SplitterComponent m x -> ParserComponent m x ()

-- | This splitter splits XML markup from data content. It is used by
--   <tt>parseXMLTokens</tt>.
xmlTokens :: Monad m => SplitterComponent m Text

-- | The XML token parser. This parser converts plain text to parsed text,
--   which is a precondition for using the remaining XML components.
xmlParseTokens :: MonadParallel m => TransducerComponent m Text [Markup XMLToken Text]

-- | Splits all top-level elements with all their content to <i>true</i>,
--   all other input to <i>false</i>.
xmlElement :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | Splits the content of all top-level elements to <i>true</i>, their
--   tags and intervening input to <i>false</i>.
xmlElementContent :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | Similiar to <tt>(<a>having</a> <tt>element</tt>)</tt>, except it runs
--   the argument splitter only on each element's start tag, not on the
--   entire element with its content.
xmlElementHavingTagWith :: MonadParallel m => SplitterComponent m [Markup XMLToken Text] -> SplitterComponent m [Markup XMLToken Text]

-- | Splits every attribute specification to <i>true</i>, everything else
--   to <i>false</i>.
xmlAttribute :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | Splits every element name, including the names of nested elements and
--   names in end tags, to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlElementName :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | Splits every attribute name to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlAttributeName :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | Splits every attribute value, excluding the quote delimiters, to
--   <i>true</i>, all the rest of input to <i>false</i>.
xmlAttributeValue :: Monad m => SplitterComponent m [Markup XMLToken Text]

-- | A <a>Component</a> carries a value and metadata about the value. It
--   can be configured to use a specific number of threads.
data Component c
Component :: String -> [AnyComponent] -> Int -> (Int -> Component c) -> Int -> Int -> c -> Component c

-- | Readable component name.
name :: Component c -> String

-- | Returns the list of all children components.
subComponents :: Component c -> [AnyComponent]

-- | Returns the maximum number of threads that can be used by the
--   component.
maxUsableThreads :: Component c -> Int

-- | Configures the component to use the specified number of threads. This
--   function affects <a>usedThreads</a>, <a>cost</a>, and
--   <a>subComponents</a> methods of the result, while <a>name</a> and
--   <a>maxUsableThreads</a> remain the same.
usingThreads :: Component c -> Int -> Component c

-- | The number of threads that the component is configured to use. The
--   default number is usually 1.
usedThreads :: Component c -> Int

-- | The cost of using the component as configured. The cost is a rough
--   approximation of time it would take to do the job given the
--   <a>usedThreads</a>.
cost :: Component c -> Int

-- | The content.
with :: Component c -> c

-- | Show details of the given component's configuration.
showComponentTree :: Component c -> String

-- | Function <a>atomic</a> takes the component name and its cost creates a
--   single-threaded component with no subcomponents.
atomic :: String -> Int -> c -> Component c

-- | Applies a unary <i>combinator</i> to the component payload. The
--   resulting component has the original one as its <a>subComponents</a>,
--   and its <a>cost</a> is the sum of the original component's cost and
--   the <i>combinator cost</i>.
lift :: Int -> String -> (c1 -> c2) -> Component c1 -> Component c2

-- | Combines two components into one, applying <i>combinator</i> to their
--   contents. The <i>combinator</i> takes a flag denoting if its arguments
--   should run in parallel. The <a>cost</a> and <a>usingThreads</a> of the
--   result assume the parallel execution of the argument components.
liftParallelPair :: String -> (Bool -> c1 -> c2 -> c3) -> Component c1 -> Component c2 -> Component c3

-- | Combines two components into one, applying <i>combinator</i> to their
--   contents. The <a>cost</a> and <a>usingThreads</a> of the result assume
--   the sequential execution of the argument components.
liftSequentialPair :: String -> (c1 -> c2 -> c3) -> Component c1 -> Component c2 -> Component c3

-- | Combines three components into one. The first component runs in
--   parallel with the latter two, which are considered alternative to each
--   other.
parallelRouterAndBranches :: String -> (Bool -> c1 -> c2 -> c3 -> c4) -> Component c1 -> Component c2 -> Component c3 -> Component c4

-- | Builds a tree of recursive components. The combinator takes a list of
--   pairs of a boolean flag denoting whether the level should be run in
--   parallel and the value.
recursiveComponentTree :: String -> (Bool -> c1 -> c2 -> c2) -> Component c1 -> Component c2

-- | Converts an XML entity name into the text value it represents:
--   <tt>expandXMLEntity "lt" = "&lt;"</tt>.
expandXMLEntity :: String -> String
instance CompatibleSignature (Transducer m x y) TransducerType m [x] [y]
instance AnyListOrUnit y => CompatibleSignature (Producer m x r) (ProducerType r) m y [x]
instance AnyListOrUnit y => CompatibleSignature (Consumer m x r) (ConsumerType r) m [x] y
instance (AnyListOrUnit x, AnyListOrUnit y) => CompatibleSignature (Performer m r) (PerformerType r) m x y
instance AnyListOrUnit ()
instance AnyListOrUnit [x]


-- | This module exports the entire SCC library except for low-level
--   modules <a>Control.Concurrent.SCC.Streams</a> and
--   <a>Control.Concurrent.SCC.Types</a>. The exported combinators run
--   their components in parallel.
module Control.Concurrent.SCC.Parallel

-- | Two streams of <a>Coercible</a> types can be unambigously converted
--   one to another.
class Coercible x y where adaptConsumer consumer = isolateConsumer $ \ source -> liftM snd $ pipe (transduce coerce source) (consume consumer) adaptProducer producer = isolateProducer $ \ sink -> liftM fst $ pipe (produce producer) (flip (transduce coerce) sink)
coerce :: (Coercible x y, Monad m) => Transducer m x y
adaptConsumer :: (Coercible x y, Monad m, Monoid x, Monoid y) => Consumer m y r -> Consumer m x r
adaptProducer :: (Coercible x y, Monad m, Monoid x, Monoid y) => Producer m x r -> Producer m y r

-- | Adjusts the argument splitter to split the stream of a data type
--   <tt>Isomorphic</tt> to the type it was meant to split.
adaptSplitter :: (Monad m, Monoid x, Monoid y, Coercible x y, Coercible y x) => Splitter m x -> Splitter m y

-- | Reads the named file and feeds the given sink from its contents.
fromFile :: String -> Producer IO Text ()

-- | Feeds the given sink from the open text file <i>handle</i>.
fromHandle :: Handle -> Producer IO Text ()

-- | Producer <a>fromStdIn</a> feeds the given sink from the standard
--   input.
fromStdIn :: Producer IO Text ()

-- | Feeds the given sink from the open binary file <i>handle</i>. The
--   argument <i>chunkSize</i> determines the size of the chunks read from
--   the handle.
fromBinaryHandle :: Handle -> Int -> Producer IO ByteString ()

-- | Appends the given source to the named text file.
appendFile :: String -> Consumer IO Text ()

-- | Creates the named text file and writes the entire given source to it.
toFile :: String -> Consumer IO Text ()

-- | Copies the given source into the open text file <i>handle</i>.
toHandle :: Handle -> Consumer IO Text ()

-- | Consumer <a>toStdOut</a> copies the given source into the standard
--   output.
toStdOut :: Consumer IO Text ()

-- | Copies the given source into the open binary file <i>handle</i>.
toBinaryHandle :: Handle -> Consumer IO ByteString ()

-- | Produces the contents of the given argument.
produceFrom :: (Monad m, MonoidNull x) => x -> Producer m x ()

-- | The <a>suppress</a> consumer suppresses all input it receives. It is
--   equivalent to <tt>substitute</tt> []
suppress :: Monad m => Consumer m x ()

-- | The <a>erroneous</a> consumer reports an error if any input reaches
--   it.
erroneous :: (Monad m, MonoidNull x) => String -> Consumer m x ()

-- | Collects the entire input source into the return value.
consumeInto :: (Monad m, Monoid x) => Consumer m x x

-- | Transducer <a>parse</a> prepares input content for subsequent parsing.
parse :: (Monad m, Monoid x) => Parser m x y

-- | Transducer <a>unparse</a> removes all markup from its input and passes
--   the content through.
unparse :: (Monad m, Monoid x) => Transducer m [Markup b x] x

-- | Performs the same task as the <a>substring</a> splitter, but instead
--   of splitting it outputs the input as <tt><a>Markup</a> x
--   <a>OccurenceTag</a></tt> in order to distinguish overlapping strings.
parseSubstring :: (Monad m, Eq x, LeftReductiveMonoid x, FactorialMonoid x) => x -> Parser m x OccurenceTag

-- | Used by <a>parseSubstring</a> to distinguish between overlapping
--   substrings.
data OccurenceTag

-- | The <a>count</a> transducer counts all its input values and outputs
--   the final tally.
count :: (Monad m, FactorialMonoid x) => Transducer m x [Integer]

-- | Converts each input value <tt>x</tt> to <tt>show x</tt>.
toString :: (Monad m, Show x) => Transducer m [x] [String]

-- | Transducer <a>group</a> collects all its input into a single list
--   item.
group :: (Monad m, Monoid x) => Transducer m x [x]

-- | Transducer <a>concatenate</a> flattens the input stream of lists of
--   values into the output stream of values.
concatenate :: (Monad m, Monoid x) => Transducer m [x] x

-- | Same as <a>concatenate</a> except it inserts the given separator list
--   between every two input lists.
concatSeparate :: (Monad m, MonoidNull x) => x -> Transducer m [x] x

-- | Splitter <a>everything</a> feeds its entire input into its <i>true</i>
--   sink.
everything :: Monad m => Splitter m x

-- | Splitter <a>nothing</a> feeds its entire input into its <i>false</i>
--   sink.
nothing :: (Monad m, Monoid x) => Splitter m x

-- | Splitter <a>marked</a> passes all marked-up input sections to its
--   <i>true</i> sink, and all unmarked input to its <i>false</i> sink.
marked :: (Monad m, Eq y) => Splitter m [Markup y x]

-- | Splitter <a>markedContent</a> passes the content of all marked-up
--   input sections to its <i>true</i> sink, takeWhile the outermost tags
--   and all unmarked input go to its <i>false</i> sink.
markedContent :: (Monad m, Eq y) => Splitter m [Markup y x]

-- | Splitter <a>markedWith</a> passes input sections marked-up with the
--   appropriate tag to its <i>true</i> sink, and the rest of the input to
--   its <i>false</i> sink. The argument <i>select</i> determines if the
--   tag is appropriate.
markedWith :: (Monad m, Eq y) => (y -> Bool) -> Splitter m [Markup y x]

-- | Splitter <a>contentMarkedWith</a> passes the content of input sections
--   marked-up with the appropriate tag to its <i>true</i> sink, and the
--   rest of the input to its <i>false</i> sink. The argument <i>select</i>
--   determines if the tag is appropriate.
contentMarkedWith :: (Monad m, Eq y) => (y -> Bool) -> Splitter m [Markup y x]

-- | Splitter <a>one</a> feeds all input values to its <i>true</i> sink,
--   treating every value as a separate section.
one :: (Monad m, FactorialMonoid x) => Splitter m x

-- | Splitter <a>substring</a> feeds to its <i>true</i> sink all input
--   parts that match the contents of the given list argument. If two
--   overlapping parts of the input both match the argument, both are sent
--   to <i>true</i> and each is preceded by an empty chunk on <i>false</i>.
substring :: (Monad m, Eq x, LeftReductiveMonoid x, FactorialMonoid x) => x -> Splitter m x

-- | The <a>lowercase</a> transforms all uppercase letters in the input to
--   lowercase, leaving the rest unchanged.
lowercase :: Monad m => Transducer m String String

-- | The <a>uppercase</a> transforms all lowercase letters in the input to
--   uppercase, leaving the rest unchanged.
uppercase :: Monad m => Transducer m String String

-- | Splitter <a>whitespace</a> feeds all white-space characters into its
--   <i>true</i> sink, all others into <i>false</i>.
whitespace :: Monad m => Splitter m String

-- | Splitter <a>letters</a> feeds all alphabetical characters into its
--   <i>true</i> sink, all other characters into | <i>false</i>.
letters :: Monad m => Splitter m String

-- | Splitter <a>digits</a> feeds all digits into its <i>true</i> sink, all
--   other characters into <i>false</i>.
digits :: Monad m => Splitter m String

-- | The sectioning splitter <a>line</a> feeds line-ends into its
--   <i>false</i> sink, and line contents into <i>true</i>. A single
--   line-end can be formed by any of the character sequences "\n", "\r",
--   "\r\n", or "\n\r".
line :: Monad m => Splitter m String

-- | Splitter <a>nonEmptyLine</a> feeds line-ends into its <i>false</i>
--   sink, and all other characters into <i>true</i>.
nonEmptyLine :: Monad m => Splitter m String

-- | Converts a <a>Consumer</a> into a <a>Transducer</a> with no output.
consumeBy :: Monad m => Consumer m x r -> Transducer m x y

-- | Combinator <a>prepend</a> converts the given producer to a
--   <a>Transducer</a> that passes all its input through unmodified, except
--   for prepending the output of the argument producer to it. The
--   following law holds: <tt> <a>prepend</a> <i>prefix</i> = <a>join</a>
--   (<a>substitute</a> <i>prefix</i>) <a>id</a> </tt>
prepend :: Monad m => Producer m x r -> Transducer m x x

-- | Combinator <a>append</a> converts the given producer to a
--   <a>Transducer</a> that passes all its input through unmodified,
--   finally appending the output of the argument producer to it. The
--   following law holds: <tt> <a>append</a> <i>suffix</i> = <a>join</a>
--   <a>id</a> (<a>substitute</a> <i>suffix</i>) </tt>
append :: Monad m => Producer m x r -> Transducer m x x

-- | The <a>substitute</a> combinator converts its argument producer to a
--   <a>Transducer</a> that produces the same output, while consuming its
--   entire input and ignoring it.
substitute :: (Monad m, Monoid x) => Producer m y r -> Transducer m x y

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
class PipeableComponentPair (m :: * -> *) w c1 c2 c3 | c1 c2 -> c3, c1 c3 -> c2, c2 c3 -> c2, c1 -> m w, c2 -> m w, c3 -> m

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
(>->) :: (MonadParallel m, PipeableComponentPair m w c1 c2 c3) => c1 -> c2 -> c3

-- | Class <a>JoinableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>if both argument components consume input, the input of the
--   combined component gets distributed to both components in parallel,
--   and<ul><li>if both argument components produce output, the output of
--   the combined component is a concatenation of the complete output from
--   the first component followed by the complete output of the second
--   component.</li></ul></li>
--   </ul>
class (Monad m, CompatibleSignature c1 t1 m x y, CompatibleSignature c2 t2 m x y, CompatibleSignature c3 t3 m x y) => JoinableComponentPair t1 t2 t3 m x y c1 c2 c3 | c1 c2 -> c3, c1 -> t1 m, c2 -> t2 m, c3 -> t3 m x y, t1 m x y -> c1, t2 m x y -> c2, t3 m x y -> c3 where join = const sequence
sequence :: JoinableComponentPair t1 t2 t3 m x y c1 c2 c3 => c1 -> c2 -> c3

-- | The <a>join</a> combinator may apply the components in any order.
join :: (MonadParallel m, JoinableComponentPair t1 t2 t3 m x y c1 c2 c3) => c1 -> c2 -> c3

-- | The <a>sNot</a> (streaming not) combinator simply reverses the outputs
--   of the argument splitter. In other words, data that the argument
--   splitter sends to its <i>true</i> sink goes to the <i>false</i> sink
--   of the result, and vice versa.
sNot :: (Monad m, Monoid x) => Splitter m x -> Splitter m x

-- | The <a>&gt;&amp;</a> combinator sends the <i>true</i> sink output of
--   its left operand to the input of its right operand for further
--   splitting. Both operands' <i>false</i> sinks are connected to the
--   <i>false</i> sink of the combined splitter, but any input value to
--   reach the <i>true</i> sink of the combined component data must be
--   deemed true by both splitters.
(>&) :: (MonadParallel m, Monoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | A <a>&gt;|</a> combinator's input value can reach its <i>false</i>
--   sink only by going through both argument splitters' <i>false</i>
--   sinks.
(>|) :: (MonadParallel m, Monoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | Combinator <a>&amp;&amp;</a> is a pairwise logical conjunction of two
--   splitters run in parallel on the same input.
(&&) :: (MonadParallel m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | Combinator <a>||</a> is a pairwise logical disjunction of two
--   splitters run in parallel on the same input.
(||) :: (MonadParallel m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x
ifs :: (MonadParallel m, Monoid x, Branching c m x ()) => Splitter m x -> c -> c -> c
wherever :: (MonadParallel m, Monoid x) => Transducer m x x -> Splitter m x -> Transducer m x x
unless :: (MonadParallel m, Monoid x) => Transducer m x x -> Splitter m x -> Transducer m x x
select :: (Monad m, Monoid x) => Splitter m x -> Transducer m x x

-- | The recursive combinator <a>while</a> feeds the true sink of the
--   argument splitter back to itself, modified by the argument transducer.
--   Data fed to the splitter's false sink is passed on unmodified.
while :: (MonadParallel m, MonoidNull x) => Transducer m x x -> Splitter m x -> Transducer m x x

-- | The recursive combinator <a>nestedIn</a> combines two splitters into a
--   mutually recursive loop acting as a single splitter. The true sink of
--   one of the argument splitters and false sink of the other become the
--   true and false sinks of the loop. The other two sinks are bound to the
--   other splitter's source. The use of <a>nestedIn</a> makes sense only
--   on hierarchically structured streams. If we gave it some input
--   containing a flat sequence of values, and assuming both component
--   splitters are deterministic and stateless, an input value would either
--   not loop at all or it would loop forever.
nestedIn :: (MonadParallel m, MonoidNull x) => Splitter m x -> Splitter m x -> Splitter m x

-- | The <a>foreach</a> combinator is similar to the combinator <a>ifs</a>
--   in that it combines a splitter and two transducers into another
--   transducer. However, in this case the transducers are re-instantiated
--   for each consecutive portion of the input as the splitter chunks it
--   up. Each contiguous portion of the input that the splitter sends to
--   one of its two sinks gets transducered through the appropriate
--   argument transducer as that transducer's whole input. As soon as the
--   contiguous portion is finished, the transducer gets terminated.
foreach :: (MonadParallel m, MonoidNull x, Branching c m x ()) => Splitter m x -> c -> c -> c

-- | The <a>having</a> combinator combines two pure splitters into a pure
--   splitter. One splitter is used to chunk the input into contiguous
--   portions. Its <i>false</i> sink is routed directly to the <i>false</i>
--   sink of the combined splitter. The second splitter is instantiated and
--   run on each portion of the input that goes to first splitter's
--   <i>true</i> sink. If the second splitter sends any output at all to
--   its <i>true</i> sink, the whole input portion is passed on to the
--   <i>true</i> sink of the combined splitter, otherwise it goes to its
--   <i>false</i> sink.
having :: (MonadParallel m, MonoidNull x, MonoidNull y, Coercible x y) => Splitter m x -> Splitter m y -> Splitter m x

-- | The <a>havingOnly</a> combinator is analogous to the <a>having</a>
--   combinator, but it succeeds and passes each chunk of the input to its
--   <i>true</i> sink only if the second splitter sends no part of it to
--   its <i>false</i> sink.
havingOnly :: (MonadParallel m, MonoidNull x, MonoidNull y, Coercible x y) => Splitter m x -> Splitter m y -> Splitter m x

-- | Combinator <a>followedBy</a> treats its argument <a>Splitter</a>s as
--   patterns components and returns a <a>Splitter</a> that matches their
--   concatenation. A section of input is considered <i>true</i> by the
--   result iff its prefix is considered <i>true</i> by argument <i>s1</i>
--   and the rest of the section is considered <i>true</i> by <i>s2</i>.
--   The splitter <i>s2</i> is started anew after every section split to
--   <i>true</i> sink by <i>s1</i>.
followedBy :: (MonadParallel m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | The <a>even</a> combinator takes every input section that its argument
--   <i>splitter</i> deems <i>true</i>, and feeds even ones into its
--   <i>true</i> sink. The odd sections and parts of input that are
--   <i>false</i> according to its argument splitter are fed to <a>even</a>
--   splitter's <i>false</i> sink.
even :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of combinator <a>first</a> behaves the same as the argument
--   splitter up to and including the first portion of the input which goes
--   into the argument's <i>true</i> sink. All input following the first
--   true portion goes into the <i>false</i> sink.
first :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of combinator <a>uptoFirst</a> takes all input up to and
--   including the first portion of the input which goes into the
--   argument's <i>true</i> sink and feeds it to the result splitter's
--   <i>true</i> sink. All the rest of the input goes into the <i>false</i>
--   sink. The only difference between <a>first</a> and <a>uptoFirst</a>
--   combinators is in where they direct the <i>false</i> portion of the
--   input preceding the first <i>true</i> part.
uptoFirst :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The <a>prefix</a> combinator feeds its <i>true</i> sink only the
--   prefix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
prefix :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of the combinator <a>last</a> is a splitter which directs
--   all input to its <i>false</i> sink, up to the last portion of the
--   input which goes to its argument's <i>true</i> sink. That portion of
--   the input is the only one that goes to the resulting component's
--   <i>true</i> sink. The splitter returned by the combinator <a>last</a>
--   has to buffer the previous two portions of its input, because it
--   cannot know if a true portion of the input is the last one until it
--   sees the end of the input or another portion succeeding the previous
--   one.
last :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of the combinator <a>lastAndAfter</a> is a splitter which
--   directs all input to its <i>false</i> sink, up to the last portion of
--   the input which goes to its argument's <i>true</i> sink. That portion
--   and the remainder of the input is fed to the resulting component's
--   <i>true</i> sink. The difference between <a>last</a> and
--   <a>lastAndAfter</a> combinators is where they feed the <i>false</i>
--   portion of the input, if any, remaining after the last <i>true</i>
--   part.
lastAndAfter :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The <a>suffix</a> combinator feeds its <i>true</i> sink only the
--   suffix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
suffix :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Splitter <a>startOf</a> issues an empty <i>true</i> section at the
--   beginning of every section considered <i>true</i> by its argument
--   splitter, otherwise the entire input goes into its <i>false</i> sink.
startOf :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Splitter <a>endOf</a> issues an empty <i>true</i> section at the end
--   of every section considered <i>true</i> by its argument splitter,
--   otherwise the entire input goes into its <i>false</i> sink.
endOf :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Combinator <a>...</a> tracks the running balance of difference between
--   the number of preceding starts of sections considered <i>true</i>
--   according to its first argument and the ones according to its second
--   argument. The combinator passes to <i>true</i> all input values for
--   which the difference balance is positive. This combinator is typically
--   used with <tt>startOf</tt> and <tt>endOf</tt> in order to count entire
--   input sections and ignore their lengths.
(...) :: (MonadParallel m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x
splitterToMarker :: (Monad m, MonoidNull x) => Splitter m x -> Transducer m x [(x, Bool)]

-- | Converts a splitter into a parser.
parseRegions :: (Monad m, MonoidNull x) => Splitter m x -> Parser m x ()

-- | XML markup splitter wrapping <a>parseXMLTokens</a>.
xmlTokens :: Monad m => Splitter m Text

-- | The XML token parser. This parser converts plain text to parsed text,
--   which is a precondition for using the remaining XML components.
parseXMLTokens :: Monad m => Transducer m Text [Markup XMLToken Text]

-- | Converts an XML entity name into the text value it represents:
--   <tt>expandXMLEntity "lt" = "&lt;"</tt>.
expandXMLEntity :: String -> String
data XMLToken
StartTag :: XMLToken
EndTag :: XMLToken
EmptyTag :: XMLToken
ElementName :: XMLToken
AttributeName :: XMLToken
AttributeValue :: XMLToken
EntityReference :: XMLToken
EntityName :: XMLToken
ProcessingInstruction :: XMLToken
ProcessingInstructionText :: XMLToken
Comment :: XMLToken
CommentText :: XMLToken
StartMarkedSectionCDATA :: XMLToken
EndMarkedSection :: XMLToken
DoctypeDeclaration :: XMLToken
ErrorToken :: String -> XMLToken

-- | Splits all top-level elements with all their content to <i>true</i>,
--   all other input to <i>false</i>.
xmlElement :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits the content of all top-level elements to <i>true</i>, their
--   tags and intervening input to <i>false</i>.
xmlElementContent :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every element name, including the names of nested elements and
--   names in end tags, to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlElementName :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute specification to <i>true</i>, everything else
--   to <i>false</i>.
xmlAttribute :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute name to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlAttributeName :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute value, excluding the quote delimiters, to
--   <i>true</i>, all the rest of input to <i>false</i>.
xmlAttributeValue :: Monad m => Splitter m [Markup XMLToken Text]

-- | Similiar to <tt>(<a>having</a> <tt>element</tt>)</tt>, except it runs
--   the argument splitter only on each element's start tag, not on the
--   entire element with its content.
xmlElementHavingTagWith :: Monad m => Splitter m [Markup XMLToken Text] -> Splitter m [Markup XMLToken Text]


-- | This module exports the entire SCC library except for low-level
--   modules <a>Control.Concurrent.SCC.Streams</a> and
--   <a>Control.Concurrent.SCC.Types</a>. The exported combinators run
--   their components by sequentially interleaving them.
module Control.Concurrent.SCC.Sequential

-- | Two streams of <a>Coercible</a> types can be unambigously converted
--   one to another.
class Coercible x y where adaptConsumer consumer = isolateConsumer $ \ source -> liftM snd $ pipe (transduce coerce source) (consume consumer) adaptProducer producer = isolateProducer $ \ sink -> liftM fst $ pipe (produce producer) (flip (transduce coerce) sink)
coerce :: (Coercible x y, Monad m) => Transducer m x y
adaptConsumer :: (Coercible x y, Monad m, Monoid x, Monoid y) => Consumer m y r -> Consumer m x r
adaptProducer :: (Coercible x y, Monad m, Monoid x, Monoid y) => Producer m x r -> Producer m y r

-- | Adjusts the argument splitter to split the stream of a data type
--   <tt>Isomorphic</tt> to the type it was meant to split.
adaptSplitter :: (Monad m, Monoid x, Monoid y, Coercible x y, Coercible y x) => Splitter m x -> Splitter m y

-- | Reads the named file and feeds the given sink from its contents.
fromFile :: String -> Producer IO Text ()

-- | Feeds the given sink from the open text file <i>handle</i>.
fromHandle :: Handle -> Producer IO Text ()

-- | Producer <a>fromStdIn</a> feeds the given sink from the standard
--   input.
fromStdIn :: Producer IO Text ()

-- | Feeds the given sink from the open binary file <i>handle</i>. The
--   argument <i>chunkSize</i> determines the size of the chunks read from
--   the handle.
fromBinaryHandle :: Handle -> Int -> Producer IO ByteString ()

-- | Appends the given source to the named text file.
appendFile :: String -> Consumer IO Text ()

-- | Creates the named text file and writes the entire given source to it.
toFile :: String -> Consumer IO Text ()

-- | Copies the given source into the open text file <i>handle</i>.
toHandle :: Handle -> Consumer IO Text ()

-- | Consumer <a>toStdOut</a> copies the given source into the standard
--   output.
toStdOut :: Consumer IO Text ()

-- | Copies the given source into the open binary file <i>handle</i>.
toBinaryHandle :: Handle -> Consumer IO ByteString ()

-- | Produces the contents of the given argument.
produceFrom :: (Monad m, MonoidNull x) => x -> Producer m x ()

-- | The <a>suppress</a> consumer suppresses all input it receives. It is
--   equivalent to <tt>substitute</tt> []
suppress :: Monad m => Consumer m x ()

-- | The <a>erroneous</a> consumer reports an error if any input reaches
--   it.
erroneous :: (Monad m, MonoidNull x) => String -> Consumer m x ()

-- | Collects the entire input source into the return value.
consumeInto :: (Monad m, Monoid x) => Consumer m x x

-- | Transducer <a>parse</a> prepares input content for subsequent parsing.
parse :: (Monad m, Monoid x) => Parser m x y

-- | Transducer <a>unparse</a> removes all markup from its input and passes
--   the content through.
unparse :: (Monad m, Monoid x) => Transducer m [Markup b x] x

-- | Performs the same task as the <a>substring</a> splitter, but instead
--   of splitting it outputs the input as <tt><a>Markup</a> x
--   <a>OccurenceTag</a></tt> in order to distinguish overlapping strings.
parseSubstring :: (Monad m, Eq x, LeftReductiveMonoid x, FactorialMonoid x) => x -> Parser m x OccurenceTag

-- | Used by <a>parseSubstring</a> to distinguish between overlapping
--   substrings.
data OccurenceTag

-- | The <a>count</a> transducer counts all its input values and outputs
--   the final tally.
count :: (Monad m, FactorialMonoid x) => Transducer m x [Integer]

-- | Converts each input value <tt>x</tt> to <tt>show x</tt>.
toString :: (Monad m, Show x) => Transducer m [x] [String]

-- | Transducer <a>group</a> collects all its input into a single list
--   item.
group :: (Monad m, Monoid x) => Transducer m x [x]

-- | Transducer <a>concatenate</a> flattens the input stream of lists of
--   values into the output stream of values.
concatenate :: (Monad m, Monoid x) => Transducer m [x] x

-- | Same as <a>concatenate</a> except it inserts the given separator list
--   between every two input lists.
concatSeparate :: (Monad m, MonoidNull x) => x -> Transducer m [x] x

-- | Splitter <a>everything</a> feeds its entire input into its <i>true</i>
--   sink.
everything :: Monad m => Splitter m x

-- | Splitter <a>nothing</a> feeds its entire input into its <i>false</i>
--   sink.
nothing :: (Monad m, Monoid x) => Splitter m x

-- | Splitter <a>marked</a> passes all marked-up input sections to its
--   <i>true</i> sink, and all unmarked input to its <i>false</i> sink.
marked :: (Monad m, Eq y) => Splitter m [Markup y x]

-- | Splitter <a>markedContent</a> passes the content of all marked-up
--   input sections to its <i>true</i> sink, takeWhile the outermost tags
--   and all unmarked input go to its <i>false</i> sink.
markedContent :: (Monad m, Eq y) => Splitter m [Markup y x]

-- | Splitter <a>markedWith</a> passes input sections marked-up with the
--   appropriate tag to its <i>true</i> sink, and the rest of the input to
--   its <i>false</i> sink. The argument <i>select</i> determines if the
--   tag is appropriate.
markedWith :: (Monad m, Eq y) => (y -> Bool) -> Splitter m [Markup y x]

-- | Splitter <a>contentMarkedWith</a> passes the content of input sections
--   marked-up with the appropriate tag to its <i>true</i> sink, and the
--   rest of the input to its <i>false</i> sink. The argument <i>select</i>
--   determines if the tag is appropriate.
contentMarkedWith :: (Monad m, Eq y) => (y -> Bool) -> Splitter m [Markup y x]

-- | Splitter <a>one</a> feeds all input values to its <i>true</i> sink,
--   treating every value as a separate section.
one :: (Monad m, FactorialMonoid x) => Splitter m x

-- | Splitter <a>substring</a> feeds to its <i>true</i> sink all input
--   parts that match the contents of the given list argument. If two
--   overlapping parts of the input both match the argument, both are sent
--   to <i>true</i> and each is preceded by an empty chunk on <i>false</i>.
substring :: (Monad m, Eq x, LeftReductiveMonoid x, FactorialMonoid x) => x -> Splitter m x

-- | The <a>lowercase</a> transforms all uppercase letters in the input to
--   lowercase, leaving the rest unchanged.
lowercase :: Monad m => Transducer m String String

-- | The <a>uppercase</a> transforms all lowercase letters in the input to
--   uppercase, leaving the rest unchanged.
uppercase :: Monad m => Transducer m String String

-- | Splitter <a>whitespace</a> feeds all white-space characters into its
--   <i>true</i> sink, all others into <i>false</i>.
whitespace :: Monad m => Splitter m String

-- | Splitter <a>letters</a> feeds all alphabetical characters into its
--   <i>true</i> sink, all other characters into | <i>false</i>.
letters :: Monad m => Splitter m String

-- | Splitter <a>digits</a> feeds all digits into its <i>true</i> sink, all
--   other characters into <i>false</i>.
digits :: Monad m => Splitter m String

-- | The sectioning splitter <a>line</a> feeds line-ends into its
--   <i>false</i> sink, and line contents into <i>true</i>. A single
--   line-end can be formed by any of the character sequences "\n", "\r",
--   "\r\n", or "\n\r".
line :: Monad m => Splitter m String

-- | Splitter <a>nonEmptyLine</a> feeds line-ends into its <i>false</i>
--   sink, and all other characters into <i>true</i>.
nonEmptyLine :: Monad m => Splitter m String

-- | Converts a <a>Consumer</a> into a <a>Transducer</a> with no output.
consumeBy :: Monad m => Consumer m x r -> Transducer m x y

-- | Combinator <a>prepend</a> converts the given producer to a
--   <a>Transducer</a> that passes all its input through unmodified, except
--   for prepending the output of the argument producer to it. The
--   following law holds: <tt> <a>prepend</a> <i>prefix</i> = <a>join</a>
--   (<a>substitute</a> <i>prefix</i>) <a>id</a> </tt>
prepend :: Monad m => Producer m x r -> Transducer m x x

-- | Combinator <a>append</a> converts the given producer to a
--   <a>Transducer</a> that passes all its input through unmodified,
--   finally appending the output of the argument producer to it. The
--   following law holds: <tt> <a>append</a> <i>suffix</i> = <a>join</a>
--   <a>id</a> (<a>substitute</a> <i>suffix</i>) </tt>
append :: Monad m => Producer m x r -> Transducer m x x

-- | The <a>substitute</a> combinator converts its argument producer to a
--   <a>Transducer</a> that produces the same output, while consuming its
--   entire input and ignoring it.
substitute :: (Monad m, Monoid x) => Producer m y r -> Transducer m x y

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
class PipeableComponentPair (m :: * -> *) w c1 c2 c3 | c1 c2 -> c3, c1 c3 -> c2, c2 c3 -> c2, c1 -> m w, c2 -> m w, c3 -> m

-- | Class <a>PipeableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>The input of the result, if any, becomes the input of the first
--   component.<ul><li>The output produced by the first child component is
--   consumed by the second child component.</li><li>The result output, if
--   any, is the output of the second component.</li></ul></li>
--   </ul>
(>->) :: (Monad m, PipeableComponentPair m w c1 c2 c3) => c1 -> c2 -> c3

-- | Class <a>JoinableComponentPair</a> applies to any two components that
--   can be combined into a third component with the following properties:
--   
--   <ul>
--   <li>if both argument components consume input, the input of the
--   combined component gets distributed to both components in parallel,
--   and<ul><li>if both argument components produce output, the output of
--   the combined component is a concatenation of the complete output from
--   the first component followed by the complete output of the second
--   component.</li></ul></li>
--   </ul>
class (Monad m, CompatibleSignature c1 t1 m x y, CompatibleSignature c2 t2 m x y, CompatibleSignature c3 t3 m x y) => JoinableComponentPair t1 t2 t3 m x y c1 c2 c3 | c1 c2 -> c3, c1 -> t1 m, c2 -> t2 m, c3 -> t3 m x y, t1 m x y -> c1, t2 m x y -> c2, t3 m x y -> c3 where join = const sequence
sequence :: JoinableComponentPair t1 t2 t3 m x y c1 c2 c3 => c1 -> c2 -> c3

-- | The <a>join</a> combinator may apply the components in any order.
join :: (Monad m, JoinableComponentPair t1 t2 t3 m x y c1 c2 c3) => c1 -> c2 -> c3

-- | The <a>sNot</a> (streaming not) combinator simply reverses the outputs
--   of the argument splitter. In other words, data that the argument
--   splitter sends to its <i>true</i> sink goes to the <i>false</i> sink
--   of the result, and vice versa.
sNot :: (Monad m, Monoid x) => Splitter m x -> Splitter m x

-- | The <a>&gt;&amp;</a> combinator sends the <i>true</i> sink output of
--   its left operand to the input of its right operand for further
--   splitting. Both operands' <i>false</i> sinks are connected to the
--   <i>false</i> sink of the combined splitter, but any input value to
--   reach the <i>true</i> sink of the combined component data must be
--   deemed true by both splitters.
(>&) :: (Monad m, Monoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | A <a>&gt;|</a> combinator's input value can reach its <i>false</i>
--   sink only by going through both argument splitters' <i>false</i>
--   sinks.
(>|) :: (Monad m, Monoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | Combinator <a>&amp;&amp;</a> is a pairwise logical conjunction of two
--   splitters run in parallel on the same input.
(&&) :: (Monad m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | Combinator <a>||</a> is a pairwise logical disjunction of two
--   splitters run in parallel on the same input.
(||) :: (Monad m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x
ifs :: (Monad m, Monoid x, Branching c m x ()) => Splitter m x -> c -> c -> c
wherever :: (Monad m, Monoid x) => Transducer m x x -> Splitter m x -> Transducer m x x
unless :: (Monad m, Monoid x) => Transducer m x x -> Splitter m x -> Transducer m x x
select :: (Monad m, Monoid x) => Splitter m x -> Transducer m x x

-- | The recursive combinator <a>while</a> feeds the true sink of the
--   argument splitter back to itself, modified by the argument transducer.
--   Data fed to the splitter's false sink is passed on unmodified.
while :: (Monad m, MonoidNull x) => Transducer m x x -> Splitter m x -> Transducer m x x

-- | The recursive combinator <a>nestedIn</a> combines two splitters into a
--   mutually recursive loop acting as a single splitter. The true sink of
--   one of the argument splitters and false sink of the other become the
--   true and false sinks of the loop. The other two sinks are bound to the
--   other splitter's source. The use of <a>nestedIn</a> makes sense only
--   on hierarchically structured streams. If we gave it some input
--   containing a flat sequence of values, and assuming both component
--   splitters are deterministic and stateless, an input value would either
--   not loop at all or it would loop forever.
nestedIn :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x -> Splitter m x

-- | The <a>foreach</a> combinator is similar to the combinator <a>ifs</a>
--   in that it combines a splitter and two transducers into another
--   transducer. However, in this case the transducers are re-instantiated
--   for each consecutive portion of the input as the splitter chunks it
--   up. Each contiguous portion of the input that the splitter sends to
--   one of its two sinks gets transducered through the appropriate
--   argument transducer as that transducer's whole input. As soon as the
--   contiguous portion is finished, the transducer gets terminated.
foreach :: (Monad m, MonoidNull x, Branching c m x ()) => Splitter m x -> c -> c -> c

-- | The <a>having</a> combinator combines two pure splitters into a pure
--   splitter. One splitter is used to chunk the input into contiguous
--   portions. Its <i>false</i> sink is routed directly to the <i>false</i>
--   sink of the combined splitter. The second splitter is instantiated and
--   run on each portion of the input that goes to first splitter's
--   <i>true</i> sink. If the second splitter sends any output at all to
--   its <i>true</i> sink, the whole input portion is passed on to the
--   <i>true</i> sink of the combined splitter, otherwise it goes to its
--   <i>false</i> sink.
having :: (Monad m, MonoidNull x, MonoidNull y, Coercible x y) => Splitter m x -> Splitter m y -> Splitter m x

-- | The <a>havingOnly</a> combinator is analogous to the <a>having</a>
--   combinator, but it succeeds and passes each chunk of the input to its
--   <i>true</i> sink only if the second splitter sends no part of it to
--   its <i>false</i> sink.
havingOnly :: (Monad m, MonoidNull x, MonoidNull y, Coercible x y) => Splitter m x -> Splitter m y -> Splitter m x

-- | Combinator <a>followedBy</a> treats its argument <a>Splitter</a>s as
--   patterns components and returns a <a>Splitter</a> that matches their
--   concatenation. A section of input is considered <i>true</i> by the
--   result iff its prefix is considered <i>true</i> by argument <i>s1</i>
--   and the rest of the section is considered <i>true</i> by <i>s2</i>.
--   The splitter <i>s2</i> is started anew after every section split to
--   <i>true</i> sink by <i>s1</i>.
followedBy :: (Monad m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x

-- | The <a>even</a> combinator takes every input section that its argument
--   <i>splitter</i> deems <i>true</i>, and feeds even ones into its
--   <i>true</i> sink. The odd sections and parts of input that are
--   <i>false</i> according to its argument splitter are fed to <a>even</a>
--   splitter's <i>false</i> sink.
even :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of combinator <a>first</a> behaves the same as the argument
--   splitter up to and including the first portion of the input which goes
--   into the argument's <i>true</i> sink. All input following the first
--   true portion goes into the <i>false</i> sink.
first :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of combinator <a>uptoFirst</a> takes all input up to and
--   including the first portion of the input which goes into the
--   argument's <i>true</i> sink and feeds it to the result splitter's
--   <i>true</i> sink. All the rest of the input goes into the <i>false</i>
--   sink. The only difference between <a>first</a> and <a>uptoFirst</a>
--   combinators is in where they direct the <i>false</i> portion of the
--   input preceding the first <i>true</i> part.
uptoFirst :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The <a>prefix</a> combinator feeds its <i>true</i> sink only the
--   prefix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
prefix :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of the combinator <a>last</a> is a splitter which directs
--   all input to its <i>false</i> sink, up to the last portion of the
--   input which goes to its argument's <i>true</i> sink. That portion of
--   the input is the only one that goes to the resulting component's
--   <i>true</i> sink. The splitter returned by the combinator <a>last</a>
--   has to buffer the previous two portions of its input, because it
--   cannot know if a true portion of the input is the last one until it
--   sees the end of the input or another portion succeeding the previous
--   one.
last :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The result of the combinator <a>lastAndAfter</a> is a splitter which
--   directs all input to its <i>false</i> sink, up to the last portion of
--   the input which goes to its argument's <i>true</i> sink. That portion
--   and the remainder of the input is fed to the resulting component's
--   <i>true</i> sink. The difference between <a>last</a> and
--   <a>lastAndAfter</a> combinators is where they feed the <i>false</i>
--   portion of the input, if any, remaining after the last <i>true</i>
--   part.
lastAndAfter :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | The <a>suffix</a> combinator feeds its <i>true</i> sink only the
--   suffix of the input that its argument feeds to its <i>true</i> sink.
--   All the rest of the input is dumped into the <i>false</i> sink of the
--   result.
suffix :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Splitter <a>startOf</a> issues an empty <i>true</i> section at the
--   beginning of every section considered <i>true</i> by its argument
--   splitter, otherwise the entire input goes into its <i>false</i> sink.
startOf :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Splitter <a>endOf</a> issues an empty <i>true</i> section at the end
--   of every section considered <i>true</i> by its argument splitter,
--   otherwise the entire input goes into its <i>false</i> sink.
endOf :: (Monad m, MonoidNull x) => Splitter m x -> Splitter m x

-- | Combinator <a>...</a> tracks the running balance of difference between
--   the number of preceding starts of sections considered <i>true</i>
--   according to its first argument and the ones according to its second
--   argument. The combinator passes to <i>true</i> all input values for
--   which the difference balance is positive. This combinator is typically
--   used with <tt>startOf</tt> and <tt>endOf</tt> in order to count entire
--   input sections and ignore their lengths.
(...) :: (Monad m, FactorialMonoid x) => Splitter m x -> Splitter m x -> Splitter m x
splitterToMarker :: (Monad m, MonoidNull x) => Splitter m x -> Transducer m x [(x, Bool)]

-- | Converts a splitter into a parser.
parseRegions :: (Monad m, MonoidNull x) => Splitter m x -> Parser m x ()

-- | XML markup splitter wrapping <a>parseXMLTokens</a>.
xmlTokens :: Monad m => Splitter m Text

-- | The XML token parser. This parser converts plain text to parsed text,
--   which is a precondition for using the remaining XML components.
parseXMLTokens :: Monad m => Transducer m Text [Markup XMLToken Text]

-- | Converts an XML entity name into the text value it represents:
--   <tt>expandXMLEntity "lt" = "&lt;"</tt>.
expandXMLEntity :: String -> String
data XMLToken
StartTag :: XMLToken
EndTag :: XMLToken
EmptyTag :: XMLToken
ElementName :: XMLToken
AttributeName :: XMLToken
AttributeValue :: XMLToken
EntityReference :: XMLToken
EntityName :: XMLToken
ProcessingInstruction :: XMLToken
ProcessingInstructionText :: XMLToken
Comment :: XMLToken
CommentText :: XMLToken
StartMarkedSectionCDATA :: XMLToken
EndMarkedSection :: XMLToken
DoctypeDeclaration :: XMLToken
ErrorToken :: String -> XMLToken

-- | Splits all top-level elements with all their content to <i>true</i>,
--   all other input to <i>false</i>.
xmlElement :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits the content of all top-level elements to <i>true</i>, their
--   tags and intervening input to <i>false</i>.
xmlElementContent :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every element name, including the names of nested elements and
--   names in end tags, to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlElementName :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute specification to <i>true</i>, everything else
--   to <i>false</i>.
xmlAttribute :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute name to <i>true</i>, all the rest of input to
--   <i>false</i>.
xmlAttributeName :: Monad m => Splitter m [Markup XMLToken Text]

-- | Splits every attribute value, excluding the quote delimiters, to
--   <i>true</i>, all the rest of input to <i>false</i>.
xmlAttributeValue :: Monad m => Splitter m [Markup XMLToken Text]

-- | Similiar to <tt>(<a>having</a> <tt>element</tt>)</tt>, except it runs
--   the argument splitter only on each element's start tag, not on the
--   entire element with its content.
xmlElementHavingTagWith :: Monad m => Splitter m [Markup XMLToken Text] -> Splitter m [Markup XMLToken Text]
