-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Encoding character data
--   
@package Encode
@version 1.3.7


-- | This module provides the <i>Parsek</i> library developed by Koen
--   Claessen in his functional pearl article <i>Parallel Parsing
--   Processes</i>, Journal of Functional Programming, 14(6), 741757,
--   Cambridge University Press, 2004:
--   
--   
--   <a>http://www.cse.chalmers.se/edu/course/afp/Papers/parser-claessen.pdf</a>
--   
--   Copyright (C) 2003 Koen Claessen
--   
--   This program is free software; you can redistribute it and/or modify
--   it under the terms of the GNU General Public License as published by
--   the Free Software Foundation; either version 2 of the License, or (at
--   your option) any later version.
--   
--   This program is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   General Public License for more details.
--   
--   You should have received a copy of the GNU General Public License
--   along with this program; if not, write to the Free Software
--   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
--   02110-1301 USA.
--   
--   <a>PureFP.Parsers.Stream</a>
module Parsek
data Parser s a
type Expect = [String]
type Unexpect = [String]
satisfy :: Show s => (s -> Bool) -> Parser s s
look :: Parser s [s]
succeeds :: Parser s a -> Parser s (Maybe a)
string :: (Eq s, Show s) => [s] -> Parser s [s]
char :: (Show t, Eq t) => t -> Parser t t
noneOf :: (Show a, Eq a) => [a] -> Parser a a
oneOf :: (Show a, Eq a) => [a] -> Parser a a
spaces :: Parser Char ()
space :: Parser Char Char
newline :: Parser Char Char
tab :: Parser Char Char
upper :: Parser Char Char
lower :: Parser Char Char
alphaNum :: Parser Char Char
letter :: Parser Char Char
digit :: Parser Char Char
hexDigit :: Parser Char Char
octDigit :: Parser Char Char
anyChar :: Parser s s
anySymbol :: Parser s s
munch :: (s -> Bool) -> Parser s [s]
munch1 :: Show s => (s -> Bool) -> Parser s [s]
label :: Parser s a -> String -> Parser s a
(<?>) :: Parser s a -> String -> Parser s a
pzero :: Parser s a
(<|>) :: Parser s a -> Parser s a -> Parser s a
(<<|>) :: Parser s a -> Parser s a -> Parser s a
try :: Parser s a -> Parser s a
choice :: [Parser s a] -> Parser s a
option :: a -> Parser s a -> Parser s a
optional :: Parser s a -> Parser s ()
between :: Parser s open -> Parser s close -> Parser s a -> Parser s a
count :: Int -> Parser s a -> Parser s [a]
chainl1 :: Parser s a -> Parser s (a -> a -> a) -> Parser s a
chainl :: Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a
chainr1 :: Parser s a -> Parser s (a -> a -> a) -> Parser s a
chainr :: Parser s a -> Parser s (a -> a -> a) -> a -> Parser s a
skipMany1 :: Parser s a -> Parser s ()
skipMany :: Parser s a -> Parser s ()
many1 :: Parser s a -> Parser s [a]
many :: Parser s a -> Parser s [a]
sepBy1 :: Parser s a -> Parser s sep -> Parser s [a]
sepBy :: Parser s a -> Parser s sep -> Parser s [a]
type ParseMethod s a e r = P s a -> [s] -> ParseResult e r
type ParseResult e r = Either (e, Expect, Unexpect) r
parseFromFile :: Parser Char a -> ParseMethod Char a e r -> FilePath -> IO (ParseResult e r)
parse :: Parser s a -> ParseMethod s a e r -> [s] -> ParseResult e r
shortestResult :: ParseMethod s a (Maybe s) a
longestResult :: ParseMethod s a (Maybe s) a
longestResults :: ParseMethod s a (Maybe s) [a]
allResults :: ParseMethod s a (Maybe s) [a]
allResultsStaged :: ParseMethod s a (Maybe s) [[a]]
completeResults :: ParseMethod s a (Maybe s) [a]
shortestResultWithLeftover :: ParseMethod s a (Maybe s) (a, [s])
longestResultWithLeftover :: ParseMethod s a (Maybe s) (a, [s])
longestResultsWithLeftover :: ParseMethod s a (Maybe s) ([a], Maybe [s])
allResultsWithLeftover :: ParseMethod s a (Maybe s) [(a, [s])]
completeResultsWithLine :: ParseMethod Char a Int [a]
instance MonadPlus (Parser s)
instance Monad (Parser s)
instance Functor (Parser s)


-- | Chapter 1 and Appendix A of /Pure Functional Parsing  an advanced
--   tutorial/ by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
module PureFP.OrdSet
class OrdSet m where xs <++> ys = fst (plusMinus xs ys) xs <\\> ys = snd (plusMinus xs ys) plusMinus xs ys = (xs <++> ys, xs <\\> ys) union [] = emptySet union [xs] = xs union xyss = union xss <++> union yss where (xss, yss) = split xyss split (x : y : xyss) = let (xs, ys) = split xyss in (x : xs, y : ys) split xs = (xs, []) makeSet xs = union (map unitSet xs) limit more start = limit' (start, start) where limit' (old, new) | isEmpty new' = old | otherwise = limit' (plusMinus new' old) where new' = union (map more (elems new))
emptySet :: (OrdSet m, Ord a) => m a
unitSet :: (OrdSet m, Ord a) => a -> m a
isEmpty :: (OrdSet m, Ord a) => m a -> Bool
elemSet :: (OrdSet m, Ord a) => a -> m a -> Bool
(<++>) :: (OrdSet m, Ord a) => m a -> m a -> m a
(<\\>) :: (OrdSet m, Ord a) => m a -> m a -> m a
plusMinus :: (OrdSet m, Ord a) => m a -> m a -> (m a, m a)
union :: (OrdSet m, Ord a) => [m a] -> m a
makeSet :: (OrdSet m, Ord a) => [a] -> m a
elems :: (OrdSet m, Ord a) => m a -> [a]
ordSet :: (OrdSet m, Ord a) => [a] -> m a
limit :: (OrdSet m, Ord a) => (a -> m a) -> m a -> m a
data Set a
instance OrdSet Set
instance Show a => Show (Set a)
instance Ord a => Ord (Set a)
instance Eq a => Eq (Set a)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.Parser
class Parser m s | m -> s where parseFull p inp = [a | ([], a) <- parse p inp]
parse :: Parser m s => m a -> [s] -> [([s], a)]
parseFull :: Parser m s => m a -> [s] -> [a]
class Monoid m where anyof = foldr (<+>) zero
zero :: Monoid m => m a
(<+>) :: Monoid m => m a -> m a -> m a
anyof :: Monoid m => [m a] -> m a
class (Monad m, Functor m) => Sequence m where p <*> q = p >>= \ f -> fmap f q p *> q = fmap (\ x y -> y) p <*> q
(<*>) :: Sequence m => m (a -> b) -> m a -> m b
(*>) :: Sequence m => m a -> m b -> m b
class Eq s => Symbol m s | m -> s where sym s = sat (s ==) skip = sat (\ x -> True)
sym :: Symbol m s => s -> m s
sat :: Symbol m s => (s -> Bool) -> m s
skip :: Symbol m s => m s
class Ord s => InputSymbol s
minSym, maxSym :: InputSymbol s => s
symbols :: InputSymbol s => [s]
class Eq s => SymbolCont m s | m -> s
satCont :: SymbolCont m s => (s -> Bool) -> (s -> m a) -> m a
class Lookahead m s | m -> s
lookahead :: Lookahead m s => ([s] -> m a) -> m a
success :: Monad m => m ()
many0 :: (Monoid m, Sequence m) => m a -> m ()
syms0 :: (Sequence m, Symbol m s) => [s] -> m ()
(<:>) :: Sequence m => m a -> m [a] -> m [a]
many :: (Monoid m, Sequence m) => m a -> m [a]
syms :: (Sequence m, Symbol m s) => [s] -> m [s]
instance InputSymbol Int
instance InputSymbol Char


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.Standard
newtype Standard s a
Std :: ([s] -> [([s], a)]) -> Standard s a
instance Lookahead (Standard s) s
instance Parser (Standard s) s
instance Eq s => SymbolCont (Standard s) s
instance Eq s => Symbol (Standard s) s
instance Sequence (Standard s)
instance Functor (Standard s)
instance Monad (Standard s)
instance Monoid (Standard s)
instance MonadState [s] (Standard s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
--   
--   <a>Parsek</a>
module PureFP.Parsers.Stream
data Stream s a
instance Parser (Stream s) s
instance Eq s => SymbolCont (Stream s) s
instance Eq s => Symbol (Stream s) s
instance Sequence (Stream s)
instance Functor (Stream s)
instance Monad (Stream s)
instance Monoid (Stream s)


-- | Chapter 1 and Appendix A of /Pure Functional Parsing  an advanced
--   tutorial/ by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
module PureFP.OrdMap
class OrdMap m where lookupWith z m s = case m ? s of { Just a -> a Nothing -> z } unionMapWith join = union where union [] = emptyMap union [xs] = xs union xyss = mergeWith join (union xss) (union yss) where (xss, yss) = split xyss split (x : y : xyss) = let (xs, ys) = split xyss in (x : xs, y : ys) split xs = (xs, [])
emptyMap :: (OrdMap m, Ord s) => m s a
(|->) :: (OrdMap m, Ord s) => s -> a -> m s a
isEmptyMap :: (OrdMap m, Ord s) => m s a -> Bool
(?) :: (OrdMap m, Ord s) => m s a -> s -> Maybe a
lookupWith :: (OrdMap m, Ord s) => a -> m s a -> s -> a
mergeWith :: (OrdMap m, Ord s) => (a -> a -> a) -> m s a -> m s a -> m s a
unionMapWith :: (OrdMap m, Ord s) => (a -> a -> a) -> [m s a] -> m s a
assocs :: (OrdMap m, Ord s) => m s a -> [(s, a)]
ordMap :: (OrdMap m, Ord s) => [(s, a)] -> m s a
mapMap :: (OrdMap m, Ord s) => (a -> b) -> m s a -> m s b
data Map s a
makeMapWith :: (Ord s, OrdMap m) => (a -> a -> a) -> [(s, a)] -> m s a
mapMapWithKey :: (s -> t -> a) -> Map s t -> Map s a
instance OrdMap Map
instance (Show s, Show a) => Show (Map s a)
instance (Eq s, Eq a) => Eq (Map s a)


-- | <a>Encode.Extend</a>
module Encode.ExPlus
class ExtEnv e
initEnv :: ExtEnv e => e i
type Extend e s = StateT [e s] (Standard s)
inspectIList :: Extend e s [s]
returnIList :: [s] -> Extend e s [s]
inspectEList :: Extend e s [e s]
returnEList :: [e s] -> Extend e s [e s]
inspectEnv :: Extend e s (e s)
resetEnv :: (a -> e s -> e s) -> a -> Extend e s (e s)
oneof :: (Ord s, Symbol m s) => [Map s a] -> m s
lower :: Ord s => [s] -> [s] -> Extend e s [s]
upper :: (OrdMap m, Ord s) => [s] -> [m s [c]] -> Extend e d ([c] -> [c])
upperWith :: (s -> m -> e d -> [[c]]) -> [s] -> m -> Extend e d ([c] -> [c])
oneof' :: (Ord [s], Symbol m [s], Eq s, Monad m) => s -> [Map [s] a] -> m [s]
(<|>) :: Extend e s a -> Extend e s a -> Extend e s a
again :: Extend e s a -> Extend e s [a]
lookupList :: (OrdMap m, Ord s) => s -> [m s a] -> [a]
instance ExtEnv e => Parser (Extend e s) s
instance Eq s => Symbol (Extend e s) s
instance Sequence (Extend e s)
instance Monoid (Extend e s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.Trie
data Trie s a
instance Ord s => Parser (Trie s) s
instance InputSymbol s => Symbol (Trie s) s
instance Ord s => Sequence (Trie s)
instance Ord s => Functor (Trie s)
instance Ord s => Monad (Trie s)
instance Ord s => Monoid (Trie s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.AmbTrie
data AmbTrie s a
(:&:) :: [a] -> Map s (AmbTrie s a) -> AmbTrie s a
instance Ord s => Parser (AmbTrie s) s
instance InputSymbol s => Symbol (AmbTrie s) s
instance Ord s => Sequence (AmbTrie s)
instance Ord s => Functor (AmbTrie s)
instance Ord s => Monad (AmbTrie s)
instance Ord s => Monoid (AmbTrie s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.ExTrie
data ExTrie s a
instance Ord s => Parser (ExTrie s) s
instance InputSymbol s => Symbol (ExTrie s) s
instance Ord s => Sequence (ExTrie s)
instance Ord s => Functor (ExTrie s)
instance Ord s => Monad (ExTrie s)
instance Ord s => Monoid (ExTrie s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.AmbExTrie
data AmbExTrie s a
(:&:) :: [a] -> Map s (AmbExTrie s a) -> AmbExTrie s a
FMap :: (b -> a) -> (AmbExTrie s b) -> AmbExTrie s a
unfold :: Ord s => (a -> b) -> AmbExTrie s a -> AmbExTrie s b
instance Ord s => Parser (AmbExTrie s) s
instance InputSymbol s => Symbol (AmbExTrie s) s
instance Ord s => Sequence (AmbExTrie s)
instance Ord s => Functor (AmbExTrie s)
instance Ord s => Monad (AmbExTrie s)
instance Ord s => Monoid (AmbExTrie s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
module PureFP.Parsers.PairTrie
data PairTrie m s a
data ParserTrie s a
instance Ord s => Parser (ParserTrie s) s
instance Ord s => Functor (ParserTrie s)
instance Ord s => Monoid (ParserTrie s)
instance (Ord s, Parser m s) => Parser (PairTrie m s) s
instance (InputSymbol s, Monoid m, Symbol m s, Lookahead m s) => Symbol (PairTrie m s) s
instance (Ord s, Monoid m, Sequence m, Lookahead m s) => Sequence (PairTrie m s)
instance (Ord s, Functor m) => Functor (PairTrie m s)
instance (Ord s, Monad m) => Monad (PairTrie m s)
instance (Ord s, Monoid m, Lookahead m s) => Monoid (PairTrie m s)


-- | Chapters 3 and 4 of <i>Pure Functional Parsing  an advanced
--   tutorial</i> by Peter Ljunglöf
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
--   
--   With this limited distribution, you can create only some of the
--   parsers described in the thesis. These include in particular:
--   
--   <ul>
--   <li><i><a>Standard</a> <tt>s</tt></i> <a>PureFP.Parsers.Standard</a>,
--   the standard parser, sec. 3.2</li>
--   <li><i><a>Stream</a> <tt>s</tt></i> <a>PureFP.Parsers.Stream</a>, the
--   stream processor parser, sec. 3.5.2</li>
--   <li><i><a>Trie</a> <tt>s</tt></i> <a>PureFP.Parsers.Trie</a>, the trie
--   parser, sec. 4.2.1</li>
--   <li><i><a>AmbTrie</a> <tt>s</tt></i> <a>PureFP.Parsers.AmbTrie</a>,
--   the ambiguous trie parser, sec. 4.2.2</li>
--   <li><i><a>ExTrie</a> <tt>s</tt></i> <a>PureFP.Parsers.ExTrie</a>, the
--   extended trie parser, sec. 4.3.3</li>
--   <li><i><a>AmbExTrie</a> <tt>s</tt></i>
--   <a>PureFP.Parsers.AmbExTrie</a>, the ambiguous extended trie parser,
--   sec. 4.3.4</li>
--   <li><i><a>PairTrie</a> <a>Standard</a> <tt>s</tt></i>
--   <a>PureFP.Parsers.PairTrie</a>, together with
--   <a>PureFP.Parsers.Standard</a>, the paired trie parser, sec. 4.4</li>
--   </ul>
--   
--   <a>PureFP.OrdMap</a> <a>PureFP.Parsers.Parser</a>
module PureFP.Parsers


-- | This library is an edited excerpt from the <i>Functional Parsing</i>
--   library developed by Peter Ljunglöf in his licenciate thesis /Pure
--   Functional Parsing  an advanced tutorial/, Göteborg University and
--   Chalmers University of Technology, April 2002:
--   
--   <a>http://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf</a>
--   
--   <a>http://www.ling.gu.se/~peb/software.html</a>
--   
--   <a>http://www.ling.gu.se/~peb/software/functional-parsing/</a>
--   
--   Copyright (C) 2002 Peter Ljunglof (C) 2005-2011 Otakar Smrz
--   
--   This program is free software; you can redistribute it and/or modify
--   it under the terms of the GNU General Public License as published by
--   the Free Software Foundation; either version 2 of the License, or (at
--   your option) any later version.
--   
--   This program is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   General Public License for more details.
--   
--   You should have received a copy of the GNU General Public License
--   along with this program; if not, write to the Free Software
--   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
--   02110-1301 USA.
--   
--   <a>PureFP.OrdMap</a> <a>PureFP.OrdSet</a> <a>PureFP.Parsers</a>
module PureFP


-- | <a>Encode.Arabic.ArabTeX</a> <a>Encode.Arabic.ArabTeX.ZDMG</a>
module Encode.Extend
class ExtEnv e
initEnv :: ExtEnv e => e i
newtype Extend e s a
Ext :: (InE s e -> [(InE s e, a)]) -> Extend e s a
inspectIList :: Extend e s [s]
returnIList :: [s] -> Extend e s [s]
inspectEList :: Extend e s [e s]
returnEList :: [e s] -> Extend e s [e s]
inspectEnv :: Extend e s (e s)
resetEnv :: (a -> e s -> e s) -> a -> Extend e s (e s)
oneof :: (Ord s, Symbol m s) => [Map s a] -> m s
lower :: Ord s => [s] -> [s] -> Extend e s [s]
upper :: (OrdMap m, Ord s) => [s] -> [m s [c]] -> Extend e d ([c] -> [c])
upperWith :: (s -> m -> e d -> [[c]]) -> [s] -> m -> Extend e d ([c] -> [c])
oneof' :: (Ord [s], Symbol m [s], Eq s, Monad m) => s -> [Map [s] a] -> m [s]
(<|>) :: Extend e s a -> Extend e s a -> Extend e s a
again :: Extend e s a -> Extend e s [a]
lookupList :: (OrdMap m, Ord s) => s -> [m s a] -> [a]
instance Lookahead (Extend e s) s
instance ExtEnv e => Parser (Extend e s) s
instance Eq s => SymbolCont (Extend e s) s
instance Eq s => Symbol (Extend e s) s
instance Sequence (Extend e s)
instance Functor (Extend e s)
instance Monad (Extend e s)
instance Monoid (Extend e s)


-- | The Haskell version of <i>Encode::Mapper</i> originally written in
--   Perl: <a>http://search.cpan.org/dist/Encode-Mapper/</a>
--   
--   <a>Encode.Arabic.ArabTeX</a> <a>Encode.Arabic.ArabTeX.ZDMG</a>
module Encode.Mapper
data Mapper s a
type Quit s a = ([s], a)
parseLongest :: (Ord s, Eq a, Show a) => Mapper s (Quit s a) -> [s] -> [a]
parseLongestWith :: (Ord s, Eq b, Show b) => ([[[a]]] -> [b]) -> Mapper s (Quit s a) -> [s] -> [b]
parseLongestCheck :: (Ord s, Eq a, Show a) => Mapper s (Quit s a) -> [s] -> [a]
parseLongestCheckWith :: (Ord s, Eq b, Show b) => ([[[a]]] -> [b]) -> Mapper s (Quit s a) -> [s] -> [b]
parseLongestWide :: Ord s => Mapper s (Quit s a) -> [s] -> [a]
parseLongestWideWith :: Ord s => ([[[a]]] -> [b]) -> Mapper s (Quit s a) -> [s] -> [b]
parseWide :: Ord s => Mapper s (Quit s a) -> [ParseWide s a] -> [s] -> [ParseWide s a]
unParseWide :: Ord s => Mapper s (Quit s a) -> [ParseWide s a] -> [[[a]]]
initPW :: Ord s => Mapper s (Quit s a) -> ([a] -> [a]) -> ParseWide s a
lastPW :: Ord s => [ParseWide s a] -> ParseWide s a -> [ParseWide s a]
parseLongestDeep :: Ord s => Mapper s (Quit s a) -> [s] -> [a]
parseLongestDeepWith :: Ord s => ([[[a]]] -> [b]) -> Mapper s (Quit s a) -> [s] -> [b]
parseDeep :: Ord s => Mapper s (Quit s a) -> [ParseDeep s a] -> [s] -> [ParseDeep s a]
unParseDeep :: Ord s => Mapper s (Quit s a) -> [ParseDeep s a] -> [[[a]]]
initPD :: Ord s => Mapper s (Quit s a) -> ([a] -> [a]) -> ParseDeep s a
lastPD :: Ord s => [ParseDeep s a] -> ParseDeep s a -> [ParseDeep s a]
(|:|) :: InputSymbol s => (a -> Mapper s (Quit s a)) -> a -> Mapper s (Quit s a)
(|-|) :: InputSymbol s => [s] -> [s] -> a -> Mapper s (Quit s a)
(|.|) :: InputSymbol s => [s] -> a -> Mapper s (Quit s a)
(|+|) :: InputSymbol s => Mapper s a -> Mapper s a -> Mapper s a
others :: Ord s => Mapper s a -> (s -> Maybe (Mapper s a)) -> Mapper s a
some :: (Monoid m, Sequence m) => m a -> m [a]
anySymbol :: (Monoid m, Symbol m a) => [a] -> m a
(<->) :: (Monoid m, Sequence m) => m a -> b -> m ([c], b)
(<.>) :: (Monoid m, Sequence m) => m a -> m b -> m b
instance Ord s => Parser (Mapper s) s
instance InputSymbol s => Symbol (Mapper s) s
instance Ord s => Sequence (Mapper s)
instance Ord s => Functor (Mapper s)
instance Ord s => Monad (Mapper s)
instance Ord s => Monoid (Mapper s)
instance OrdMap m => OrdMap (Next m)


-- | Exports the <a>version</a> of the <a>Encode</a> library and provides
--   support for working with the SVN/CVS revision keyword. The
--   <a>revised</a> method parses the '$Revision ... $' string supplied to
--   it. Results have the type <a>Version</a> of the <a>Data.Version</a>
--   module, which is exported, too.
module Encode.Version
showPretty :: Version -> String
revised :: String -> Version
version :: Version


-- | The Haskell analogy to the <i>Encode</i> module in Perl:
--   <a>http://search.cpan.org/dist/Encode/</a>
--   
--   <a>Encode.Arabic</a> <a>Encode.Mapper</a> <a>Encode.Unicode</a>
module Encode

-- | Encodings are represented as distinct datatypes of the <a>Encoding</a>
--   class, which defines two essential methods:
--   
--   <ul>
--   <li><i><a>encode</a></i> turning a list of 'internal code points' into
--   a <tt>String</tt>, and</li>
--   <li><i><a>decode</a></i> converting the lists in the opposite
--   direction.</li>
--   </ul>
--   
--   Developing a new encoding means to write a new module with a structure
--   similar to this:
--   
--   <pre>
--      module <i>MyEncModule</i> (<i>MyEncType</i> (..)) where
--   <i>  </i>
--      import <a>Encode</a>
--   <i>  </i>
--      data <i>MyEncType</i> = <i>MyEncName | MyEncAlias deriving (Enum, Show)</i>
--   <i>  </i>
--      instance <a>Encoding</a> <i>MyEncType</i> where
--   <i>  </i>
--          <a>encode</a> <i>enc data</i> = <i>show data</i>         <i>-- your choices ...</i>
--   <i>  </i>
--          <a>decode</a> <i>enc data</i> = <i>map (toEnum . fromEnum) data</i>
--   </pre>
--   
--   <a>Encode.Unicode.UTF8</a> is one concrete implementation that
--   realizes and illustrates this template.
--   <a>Encode.Arabic.Buckwalter</a> implements symmetric recoding using
--   finite maps, and <a>Encode.Arabic.ArabTeX</a> makes use of monadic
--   parsing and the <a>PureFP</a> library.
class Encoding e where encode _ = map (toEnum . fromEnum) decode _ = map (toEnum . fromEnum)
encode :: Encoding e => e -> [UPoint] -> [Char]
decode :: Encoding e => e -> [Char] -> [UPoint]

-- | The datatype introduced for the internal representation of Unicode
--   code points is currently defined as <tt>newtype <a>UPoint</a> = UPoint
--   CSpace</tt>. The shift to code points <tt>UPoint</tt> from characters
--   <tt>Char</tt> is intentional, as Unicode support in Haskell is not yet
--   fully implemented, and code points are, anyway, different entities.
--   Since the <a>UPoint</a> type is an instance of the <tt>Enum</tt>
--   class, the type's constructor and destructor functions are available
--   as <a>toEnum</a> and <a>fromEnum</a>, respectively.
--   
--   The <a>UPoint</a> datatype should be the transfer point on the way
--   from one encoding into another. It should not be the terminal stop,
--   though. The <a>encode</a> method should be used systematically, and
--   not <tt>show</tt>, even if it might temporarily produce somehow
--   appealing results.
data UPoint

-- | The <a>CSpace</a> type denotes the code space, and it is a synonym to
--   <a>Word</a>.
type CSpace = Word
instance Eq UPoint
instance Ord UPoint
instance Enum UPoint
instance Show UPoint


-- | <i>Encode::Arabic::ArabTeX</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/ArabTeX.pm</a>
--   
--   <a>Encode.Extend</a> <a>Encode.Mapper</a>
module Encode.Arabic.ArabTeX
data ArabTeX
ArabTeX :: ArabTeX
Lagally :: ArabTeX
TeX :: ArabTeX
tokens :: String -> [String]
events :: String -> [[String]]
instance Enum ArabTeX
instance Show ArabTeX
instance Eq Mode
instance Ord Mode
instance ExtEnv Env
instance Encoding ArabTeX


-- | <i>Encode::Arabic::ArabTeX::ZDMG</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/ArabTeX/ZDMG.pm</a>
--   
--   <a>Encode.Extend</a> <a>Encode.Mapper</a>
module Encode.Arabic.ArabTeX.ZDMG
data ZDMG
ZDMG :: ZDMG
ArabTeX_ZDMG :: ZDMG
instance Enum ZDMG
instance Show ZDMG
instance Eq Mode
instance Ord Mode
instance ExtEnv Env
instance Encoding ZDMG


-- | Tim Buckwalter's notation is a one-to-one transliteration of the
--   graphemes of the Arabic script using lower ASCII characters only. This
--   system is very popular in Natural Language Processing, however, there
--   are limits to its applicability due to numerous non-alphabetic
--   characters involved.
--   
--   The XML-friendly variant of the notation replaces codes <tt>&gt;</tt>,
--   <tt>&amp;</tt>, <tt>&lt;</tt> with <tt>O</tt>, <tt>W</tt>, <tt>I</tt>,
--   respectively. In this implementation, the <a>decode</a> function
--   considers both of these conventions and converts from them, while the
--   <a>encode</a> function produces the XML-friendly notation only.
--   
--   <i>Encode::Arabic::Buckwalter</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Buckwalter.pm</a>
module Encode.Arabic.Buckwalter
data Buckwalter
Buckwalter :: Buckwalter
Tim :: Buckwalter
instance Enum Buckwalter
instance Show Buckwalter
instance Encoding Buckwalter


-- | Dil Parkinson's notation is a one-to-one transliteration of the
--   graphemes of the Arabic script using lower ASCII characters only.
--   
--   <i>Encode::Arabic::Parkinson</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Parkinson.pm</a>
module Encode.Arabic.Parkinson
data Parkinson
Parkinson :: Parkinson
Dil :: Parkinson
instance Enum Parkinson
instance Show Parkinson
instance Encoding Parkinson


-- | Habash-Soudi-Buckwalter notation is a one-to-one transliteration of
--   the graphemes of the Arabic script into various symbols of Unicode
--   defined in
--   <a>http://scholar.google.com/scholar?q=habash+soudi+buckwalter</a>.
--   
--   <i>Encode::Arabic::Habash</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Habash.pm</a>
module Encode.Arabic.Habash
data Habash
Habash :: Habash
Soudi :: Habash
HSB :: Habash
instance Enum Habash
instance Show Habash
instance Encoding Habash


-- | <i>Encode::Byte</i> in Perl:
--   <a>http://search.cpan.org/dist/Encode/Byte/Byte.pm</a>
--   
--   <a>http://search.cpan.org/dist/Encode/lib/Encode/Supported.pod</a>
--   
--   <a>http://129.69.218.213/arabtex/doc/arabdoc.pdf</a>
module Encode.Arabic.Byte
data WinArabic
WinArabic :: WinArabic
CP1256 :: WinArabic
Windows_1256 :: WinArabic
data ISOArabic
ISOArabic :: ISOArabic
ISO_8859_6 :: ISOArabic
data MacArabic
MacArabic :: MacArabic
data MacFarsi
MacFarsi :: MacFarsi
data DOSArabic
DOSArabic :: DOSArabic
CP864 :: DOSArabic
data DOSFarsi
DOSFarsi :: DOSFarsi
CP1006 :: DOSFarsi
data ASMO449
ASMO449 :: ASMO449
data ISIRI3342
ISIRI3342 :: ISIRI3342
instance Enum WinArabic
instance Show WinArabic
instance Enum ISOArabic
instance Show ISOArabic
instance Enum MacArabic
instance Show MacArabic
instance Enum MacFarsi
instance Show MacFarsi
instance Enum DOSArabic
instance Show DOSArabic
instance Enum DOSFarsi
instance Show DOSFarsi
instance Enum ASMO449
instance Show ASMO449
instance Enum ISIRI3342
instance Show ISIRI3342
instance Encoding ISIRI3342
instance Encoding ASMO449
instance Encoding DOSFarsi
instance Encoding DOSArabic
instance Encoding MacFarsi
instance Encoding MacArabic
instance Encoding ISOArabic
instance Encoding WinArabic


-- | Modified version of John Meacham's
--   <a>http://repetae.net/repos/jhc/UTF8.hs</a>
module Encode.Unicode.UTF8
data UTF8
UTF8 :: UTF8
UTF :: UTF8
instance Enum UTF8
instance Show UTF8
instance Encoding UTF8


-- | The Haskell analogy to the <i>Encode::Unicode</i> module in Perl:
--   <a>http://search.cpan.org/dist/Encode/</a>
--   
--   <a>Encode.Unicode.UTF8</a>
module Encode.Unicode
data Unicode
Unicode :: Unicode
UCS :: Unicode
instance Enum Unicode
instance Show Unicode
instance Encoding Unicode


-- | The Haskell version of <i>Encode::Arabic</i> originally written in
--   Perl: <a>http://search.cpan.org/dist/Encode-Arabic/</a>
--   
--   <a>Encode.Arabic.ArabTeX</a> <a>Encode.Arabic.ArabTeX.ZDMG</a>
--   <a>Encode.Arabic.Buckwalter</a> <a>Encode.Arabic.Parkinson</a>
--   <a>Encode.Arabic.Habash</a> <a>Encode.Arabic.Byte</a>
module Encode.Arabic
