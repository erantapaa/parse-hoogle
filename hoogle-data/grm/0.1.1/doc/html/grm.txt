-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | grm grammar converter
--   
--   Grm takes a grammar specification and generates Haskell bindings.
--   Given a grammar the tool produces an abstract syntax implementation, a
--   Happy parser generator file, and a pretty-printer.
@package grm
@version 0.1.1

module Grm.Prims
data Terminator
Terminator :: Terminator
Separator :: Terminator
data Horiz
Vert :: Horiz
Horiz :: Horiz
data Empty
Empty :: Empty
NonEmpty :: Empty
data Point
Point :: Loc -> Loc -> Point
beginLoc :: Point -> Loc
endLoc :: Point -> Loc
data Loc
Loc :: FilePath -> Int -> Int -> Loc
locFilePath :: Loc -> FilePath
locLine :: Loc -> Int
locColumn :: Loc -> Int
class HasMeta t
meta :: HasMeta t => t a -> a
ppString :: String -> Doc
ppInteger :: Integer -> Doc
type Number = String
ppNumber :: Number -> Doc
readNumber :: (Num a, Read a) => Number -> a
readBinary :: String -> Integer
ppChar :: Char -> Doc
isFloat :: String -> Bool
isBinary :: String -> Bool
isOctal :: String -> Bool
ppDouble :: Double -> Doc
ppList :: (a -> Doc) -> Terminator -> String -> Horiz -> [a] -> Doc
nubSort :: Ord a => [a] -> [a]
ppLident :: String -> Doc
ppMlcode :: String -> Doc
ppUident :: String -> Doc
ppUsym :: String -> Doc
singleton :: a -> [a]
ppErr :: Loc -> String -> String
ppLoc :: Loc -> String
startLoc :: HasMeta m => m Point -> Loc
stopLoc :: HasMeta m => m Point -> Loc
noLoc :: Loc
noPoint :: Point
initLoc :: FilePath -> Loc
point :: HasMeta m => m Point -> Point
lrPoint :: [Point] -> Point
lrPointList :: HasMeta m => [m Point] -> Point
type Uident = String
type Lident = String
type Mlcode = String
type Usym = String
ppShow :: Pretty a => a -> String
unreachable :: a
unused :: a
panic :: String -> a
lowercase :: String -> String
freshNm :: IO String
commaSep :: [String] -> String
mySystem :: String -> IO ()
bitsToEncode :: Integer -> Integer
uId :: a -> String -> String
writeFileBinary :: FilePath -> String -> IO ()
findFile :: [FilePath] -> FilePath -> IO (Maybe FilePath)
instance Typeable Loc
instance Typeable Point
instance Show Terminator
instance Eq Terminator
instance Show Horiz
instance Eq Horiz
instance Show Empty
instance Eq Empty
instance Show Loc
instance Eq Loc
instance Ord Loc
instance Data Loc
instance Show Point
instance Ord Point
instance Eq Point
instance Data Point

module Grm.Lex
data Token a
TWhitespace :: a -> String -> Token a
TSLComment :: a -> String -> Token a
TMLComment :: a -> String -> Token a
TString :: a -> String -> Token a
TChar :: a -> Char -> Token a
TNumber :: a -> String -> Token a
TSymbol :: a -> String -> Token a
TUsym :: a -> String -> Token a
TUident :: a -> String -> Token a
TLident :: a -> String -> Token a
data Point
Point :: Loc -> Loc -> Point
beginLoc :: Point -> Loc
endLoc :: Point -> Loc
lexFilePath :: [String] -> FilePath -> IO [Token Point]
lexContents :: [String] -> FilePath -> String -> IO [Token Point]
ppToken :: Token a -> Doc
ppTokenList :: [Token a] -> Doc
happyError :: [Token Point] -> a
notWSToken :: Token t -> Bool
unTWhitespace :: Token t -> String
unTSLComment :: Token t -> String
unTMLComment :: Token t -> String
unTString :: Token t -> String
unTChar :: Token t -> Char
unTNumber :: Token t -> String
unTSymbol :: Token t -> String
unTUsym :: Token t -> String
unTUident :: Token t -> String
unTLident :: Token t -> String
instance Show a => Show (Token a)
instance Show St
instance Monad M
instance HasMeta Token
instance Eq (Token a)

module Grm.Layout
layout :: [Token Point] -> [Token Point]
