-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Comonads
--   
@package comonad
@version 4.2.6

module Data.Functor.Composition

-- | We often need to distinguish between various forms of Functor-like
--   composition in Haskell in order to please the type system. This lets
--   us work with these representations uniformly.
class Composition o
decompose :: Composition o => o f g x -> f (g x)
compose :: Composition o => f (g x) -> o f g x
instance Composition Compose


module Control.Comonad.Trans.Identity

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
newtype IdentityT (f :: * -> *) a :: (* -> *) -> * -> *
IdentityT :: f a -> IdentityT a
runIdentityT :: IdentityT a -> f a


module Control.Comonad

-- | There are two ways to define a comonad:
--   
--   I. Provide definitions for <a>extract</a> and <a>extend</a> satisfying
--   these laws:
--   
--   <pre>
--   <a>extend</a> <a>extract</a>      = <a>id</a>
--   <a>extract</a> . <a>extend</a> f  = f
--   <a>extend</a> f . <a>extend</a> g = <a>extend</a> (f . <a>extend</a> g)
--   </pre>
--   
--   In this case, you may simply set <a>fmap</a> = <a>liftW</a>.
--   
--   These laws are directly analogous to the laws for monads and perhaps
--   can be made clearer by viewing them as laws stating that Cokleisli
--   composition must be associative, and has extract for a unit:
--   
--   <pre>
--   f <a>=&gt;=</a> <a>extract</a>   = f
--   <a>extract</a> <a>=&gt;=</a> f   = f
--   (f <a>=&gt;=</a> g) <a>=&gt;=</a> h = f <a>=&gt;=</a> (g <a>=&gt;=</a> h)
--   </pre>
--   
--   II. Alternately, you may choose to provide definitions for
--   <a>fmap</a>, <a>extract</a>, and <a>duplicate</a> satisfying these
--   laws:
--   
--   <pre>
--   <a>extract</a> . <a>duplicate</a>      = <a>id</a>
--   <a>fmap</a> <a>extract</a> . <a>duplicate</a> = <a>id</a>
--   <a>duplicate</a> . <a>duplicate</a>    = <a>fmap</a> <a>duplicate</a> . <a>duplicate</a>
--   </pre>
--   
--   In this case you may not rely on the ability to define <a>fmap</a> in
--   terms of <a>liftW</a>.
--   
--   You may of course, choose to define both <a>duplicate</a> <i>and</i>
--   <a>extend</a>. In that case you must also satisfy these laws:
--   
--   <pre>
--   <a>extend</a> f  = <a>fmap</a> f . <a>duplicate</a>
--   <a>duplicate</a> = <a>extend</a> id
--   <a>fmap</a> f    = <a>extend</a> (f . <a>extract</a>)
--   </pre>
--   
--   These are the default definitions of <a>extend</a> and
--   <a>duplicate</a> and the definition of <a>liftW</a> respectively.
class Functor w => Comonad w where duplicate = extend id extend f = fmap f . duplicate
extract :: Comonad w => w a -> a
duplicate :: Comonad w => w a -> w (w a)
extend :: Comonad w => (w a -> b) -> w a -> w b

-- | A suitable default definition for <a>fmap</a> for a <a>Comonad</a>.
--   Promotes a function to a comonad.
--   
--   You can only safely use to define <a>fmap</a> if your <a>Comonad</a>
--   defined <a>extend</a>, not just <a>duplicate</a>, since defining
--   <a>extend</a> in terms of duplicate uses <a>fmap</a>!
--   
--   <pre>
--   <a>fmap</a> f = <a>liftW</a> f = <a>extend</a> (f . <a>extract</a>)
--   </pre>
liftW :: Comonad w => (a -> b) -> w a -> w b

-- | Comonadic fixed point à la David Menendez
wfix :: Comonad w => w (w a -> a) -> a

-- | Comonadic fixed point à la Dominic Orchard
cfix :: Comonad w => (w a -> a) -> w a

-- | Comonadic fixed point à la Kenneth Foner:
--   
--   This is the <tt>evaluate</tt> function from his <a>"Getting a Quick
--   Fix on Comonads"</a> talk.
kfix :: ComonadApply w => w (w a -> a) -> w a

-- | Left-to-right <a>Cokleisli</a> composition
(=>=) :: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c

-- | Right-to-left <a>Cokleisli</a> composition
(=<=) :: Comonad w => (w b -> c) -> (w a -> b) -> w a -> c

-- | <a>extend</a> in operator form
(<<=) :: Comonad w => (w a -> b) -> w a -> w b

-- | <a>extend</a> with the arguments swapped. Dual to <a>&gt;&gt;=</a> for
--   a <a>Monad</a>.
(=>>) :: Comonad w => w a -> (w a -> b) -> w b

-- | <tt>ComonadApply</tt> is to <tt>Comonad</tt> like <tt>Applicative</tt>
--   is to <tt>Monad</tt>.
--   
--   Mathematically, it is a strong lax symmetric semi-monoidal comonad on
--   the category <tt>Hask</tt> of Haskell types. That it to say that
--   <tt>w</tt> is a strong lax symmetric semi-monoidal functor on Hask,
--   where both <a>extract</a> and <a>duplicate</a> are symmetric monoidal
--   natural transformations.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;@&gt;</a> v <a>&lt;@&gt;</a> w = u <a>&lt;@&gt;</a> (v <a>&lt;@&gt;</a> w)
--   <a>extract</a> (p <a>&lt;@&gt;</a> q) = <a>extract</a> p (<a>extract</a> q)
--   <a>duplicate</a> (p <a>&lt;@&gt;</a> q) = (<a>&lt;@&gt;</a>) <a>&lt;$&gt;</a> <a>duplicate</a> p <a>&lt;@&gt;</a> <a>duplicate</a> q
--   </pre>
--   
--   If our type is both a <a>ComonadApply</a> and <a>Applicative</a> we
--   further require
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = (<a>&lt;@&gt;</a>)
--   </pre>
--   
--   Finally, if you choose to define (<a>&lt;@</a>) and (<a>@&gt;</a>),
--   the results of your definitions should match the following laws:
--   
--   <pre>
--   a <a>@&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;@&gt;</a> b
--   a <a>&lt;@</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;@&gt;</a> b
--   </pre>
class Comonad w => ComonadApply w where (<@>) = (<*>) a @> b = const id <$> a <@> b a <@ b = const <$> a <@> b
(<@>) :: ComonadApply w => w (a -> b) -> w a -> w b
(@>) :: ComonadApply w => w a -> w b -> w b
(<@) :: ComonadApply w => w a -> w b -> w a

-- | A variant of <a>&lt;@&gt;</a> with the arguments reversed.
(<@@>) :: ComonadApply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a <a>Comonad</a> with zipping
liftW2 :: ComonadApply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a <a>Comonad</a> with zipping
liftW3 :: ComonadApply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | The <a>Cokleisli</a> <a>Arrow</a>s of a given <a>Comonad</a>
newtype Cokleisli w a b
Cokleisli :: (w a -> b) -> Cokleisli w a b
runCokleisli :: Cokleisli w a b -> w a -> b

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <i>Since: 4.7.0.0</i>
($>) :: Functor f => f a -> b -> f b
instance [safe] Typeable Cokleisli
instance [safe] Monad (Cokleisli w a)
instance [safe] Applicative (Cokleisli w a)
instance [safe] Functor (Cokleisli w a)
instance [safe] ComonadApply w => ArrowLoop (Cokleisli w)
instance [safe] Comonad w => ArrowChoice (Cokleisli w)
instance [safe] Comonad w => ArrowApply (Cokleisli w)
instance [safe] Comonad w => Arrow (Cokleisli w)
instance [safe] Comonad w => Category (Cokleisli w)
instance [safe] ComonadApply Tree
instance [safe] ComonadApply w => ComonadApply (IdentityT w)
instance [safe] ComonadApply Identity
instance [safe] Monoid m => ComonadApply ((->) m)
instance [safe] ComonadApply NonEmpty
instance [safe] Semigroup m => ComonadApply ((,) m)
instance [safe] Comonad NonEmpty
instance [safe] Comonad Tree
instance [safe] Comonad w => Comonad (IdentityT w)
instance [safe] Comonad (Tagged s)
instance [safe] Comonad Identity
instance [safe] Monoid m => Comonad ((->) m)
instance [safe] Comonad (Arg e)
instance [safe] Comonad ((,) e)


module Control.Comonad.Trans.Class
class ComonadTrans t
lower :: (ComonadTrans t, Comonad w) => t w a -> w a
instance [safe] ComonadTrans IdentityT


module Control.Comonad.Hoist.Class
class ComonadHoist t
cohoist :: (ComonadHoist t, Comonad w, Comonad v) => (forall x. w x -> v x) -> t w a -> t v a
instance ComonadHoist IdentityT


-- | The environment comonad holds a value along with some retrievable
--   context.
--   
--   This module specifies the environment comonad transformer (aka
--   coreader), which is left adjoint to the reader comonad.
--   
--   The following sets up an experiment that retains its initial value in
--   the background:
--   
--   <pre>
--   &gt;&gt;&gt; let initial = env 0 0
--   </pre>
--   
--   Extract simply retrieves the value:
--   
--   <pre>
--   &gt;&gt;&gt; extract initial
--   0
--   </pre>
--   
--   Play around with the value, in our case producing a negative value:
--   
--   <pre>
--   &gt;&gt;&gt; let experiment = fmap (+ 10) initial
--   
--   &gt;&gt;&gt; extract experiment
--   10
--   </pre>
--   
--   Oh noes, something went wrong, 10 isn't very negative! Better restore
--   the initial value using the default:
--   
--   <pre>
--   &gt;&gt;&gt; let initialRestored = experiment =&gt;&gt; ask
--   
--   &gt;&gt;&gt; extract initialRestored
--   0
--   </pre>
module Control.Comonad.Trans.Env
type Env e = EnvT e Identity

-- | Create an Env using an environment and a value
env :: e -> a -> Env e a
runEnv :: Env e a -> (e, a)
data EnvT e w a
EnvT :: e -> (w a) -> EnvT e w a
runEnvT :: EnvT e w a -> (e, w a)

-- | Gets rid of the environment. This differs from <a>extract</a> in that
--   it will not continue extracting the value from the contained comonad.
lowerEnvT :: EnvT e w a -> w a

-- | Retrieves the environment.
ask :: EnvT e w a -> e

-- | Like <a>ask</a>, but modifies the resulting value with a function.
--   
--   <pre>
--   asks = f . ask
--   </pre>
asks :: (e -> f) -> EnvT e w a -> f

-- | Modifies the environment using the specified function.
local :: (e -> e') -> EnvT e w a -> EnvT e' w a
instance [safe] Typeable EnvT
instance [safe] Traversable w => Traversable (EnvT e w)
instance [safe] Foldable w => Foldable (EnvT e w)
instance [safe] (Semigroup e, ComonadApply w) => ComonadApply (EnvT e w)
instance [safe] ComonadHoist (EnvT e)
instance [safe] ComonadTrans (EnvT e)
instance [safe] Comonad w => Comonad (EnvT e w)
instance [safe] Functor w => Functor (EnvT e w)
instance [safe] (Data e, Typeable w, Data (w a), Data a) => Data (EnvT e w a)


-- | The store comonad holds a constant value along with a modifiable
--   <i>accessor</i> function, which maps the <i>stored value</i> to the
--   <i>focus</i>.
--   
--   This module defines the strict store (aka state-in-context/costate)
--   comonad transformer.
--   
--   <tt>stored value = (1, 5)</tt>, <tt>accessor = fst</tt>, <tt>resulting
--   focus = 1</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    let
--      storeTuple :: Store (Int, Int) Int
--      storeTuple = store fst (1, 5)
--   :}
--   </pre>
--   
--   Add something to the focus:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    let
--      addToFocus :: Int -&gt; Store (Int, Int) Int -&gt; Int
--      addToFocus x wa = x + extract wa
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     let
--       added3 :: Store (Int, Int) Int
--       added3 = extend (addToFocus 3) storeTuple
--   :}
--   </pre>
--   
--   The focus of added3 is now <tt>1 + 3 = 4</tt>. However, this action
--   changed only the accessor function and therefore the focus but not the
--   stored value:
--   
--   <pre>
--   &gt;&gt;&gt; pos added3
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract added3
--   4
--   </pre>
--   
--   The strict store (state-in-context/costate) comonad transformer is
--   subject to the laws:
--   
--   <pre>
--   x = seek (pos x) x
--   y = pos (seek y x)
--   seek y x = seek y (seek z x)
--   </pre>
--   
--   Thanks go to Russell O'Connor and Daniel Peebles for their help
--   formulating and proving the laws for this comonad transformer.
module Control.Comonad.Trans.Store
type Store s = StoreT s Identity

-- | Create a Store using an accessor function and a stored value
store :: (s -> a) -> s -> Store s a
runStore :: Store s a -> (s -> a, s)
data StoreT s w a
StoreT :: (w (s -> a)) -> s -> StoreT s w a
runStoreT :: StoreT s w a -> (w (s -> a), s)

-- | Read the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos $ store fst (1,5)
--   (1,5)
--   </pre>
pos :: StoreT s w a -> s

-- | Set the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos . seek (3,7) $ store fst (1,5)
--   (3,7)
--   </pre>
--   
--   Seek satisfies the law
--   
--   <pre>
--   seek s = peek s . duplicate
--   </pre>
seek :: s -> StoreT s w a -> StoreT s w a

-- | Modify the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos . seeks swap $ store fst (1,5)
--   (5,1)
--   </pre>
--   
--   Seeks satisfies the law
--   
--   <pre>
--   seeks f = peeks f . duplicate
--   </pre>
seeks :: (s -> s) -> StoreT s w a -> StoreT s w a

-- | Peek at what the current focus would be for a different stored value
--   
--   Peek satisfies the law
--   
--   <pre>
--   peek x . extend (peek y) = peek y
--   </pre>
peek :: Comonad w => s -> StoreT s w a -> a

-- | Peek at what the current focus would be if the stored value was
--   modified by some function
peeks :: Comonad w => (s -> s) -> StoreT s w a -> a

-- | Applies a functor-valued function to the stored value, and then uses
--   the new accessor to read the resulting focus.
--   
--   <pre>
--   &gt;&gt;&gt; let f x = if x &gt; 0 then Just (x^2) else Nothing
--   
--   &gt;&gt;&gt; experiment f $ store (+1) 2
--   Just 5
--   
--   &gt;&gt;&gt; experiment f $ store (+1) (-2)
--   Nothing
--   </pre>
experiment :: (Comonad w, Functor f) => (s -> f s) -> StoreT s w a -> f a
instance [safe] Typeable StoreT
instance [safe] ComonadHoist (StoreT s)
instance [safe] ComonadTrans (StoreT s)
instance [safe] Comonad w => Comonad (StoreT s w)
instance [safe] (Applicative w, Monoid s) => Applicative (StoreT s w)
instance [safe] (ComonadApply w, Semigroup s) => ComonadApply (StoreT s w)
instance [safe] Functor w => Functor (StoreT s w)


-- | The trace comonad builds up a result by prepending monoidal values to
--   each other.
--   
--   This module specifies the traced comonad transformer (aka the cowriter
--   or exponential comonad transformer).
module Control.Comonad.Trans.Traced
type Traced m = TracedT m Identity
traced :: (m -> a) -> Traced m a
runTraced :: Traced m a -> m -> a
newtype TracedT m w a
TracedT :: w (m -> a) -> TracedT m w a
runTracedT :: TracedT m w a -> w (m -> a)
trace :: Comonad w => m -> TracedT m w a -> a
listen :: Functor w => TracedT m w a -> TracedT m w (a, m)
listens :: Functor w => (m -> b) -> TracedT m w a -> TracedT m w (a, b)
censor :: Functor w => (m -> m) -> TracedT m w a -> TracedT m w a
instance [safe] Typeable TracedT
instance [safe] Distributive w => Distributive (TracedT m w)
instance [safe] Monoid m => ComonadHoist (TracedT m)
instance [safe] Monoid m => ComonadTrans (TracedT m)
instance [safe] (Comonad w, Monoid m) => Comonad (TracedT m w)
instance [safe] Applicative w => Applicative (TracedT m w)
instance [safe] (ComonadApply w, Monoid m) => ComonadApply (TracedT m w)
instance [safe] Functor w => Functor (TracedT m w)


module Control.Comonad.Env.Class
class Comonad w => ComonadEnv e w | w -> e
ask :: ComonadEnv e w => w a -> e
asks :: ComonadEnv e w => (e -> e') -> w a -> e'
instance [safe] (ComonadEnv e w, Monoid m) => ComonadEnv e (TracedT m w)
instance [safe] ComonadEnv e w => ComonadEnv e (IdentityT w)
instance [safe] ComonadEnv e w => ComonadEnv e (StoreT t w)
instance [safe] ComonadEnv e (Arg e)
instance [safe] ComonadEnv e ((,) e)
instance [safe] Comonad w => ComonadEnv e (EnvT e w)


-- | The Env comonad (aka the Coreader, Environment, or Product comonad)
--   
--   A co-Kleisli arrow in the Env comonad is isomorphic to a Kleisli arrow
--   in the reader monad.
--   
--   (a -&gt; e -&gt; m) ~ (a, e) -&gt; m ~ Env e a -&gt; m
module Control.Comonad.Env
class Comonad w => ComonadEnv e w | w -> e
ask :: ComonadEnv e w => w a -> e
asks :: ComonadEnv e w => (e -> e') -> w a -> e'

-- | Modifies the environment using the specified function.
local :: (e -> e') -> EnvT e w a -> EnvT e' w a
type Env e = EnvT e Identity

-- | Create an Env using an environment and a value
env :: e -> a -> Env e a
runEnv :: Env e a -> (e, a)
data EnvT e w a
EnvT :: e -> (w a) -> EnvT e w a
runEnvT :: EnvT e w a -> (e, w a)


module Control.Comonad.Identity


module Control.Comonad.Store.Class
class Comonad w => ComonadStore s w | w -> s where peeks f w = peek (f (pos w)) w seek s = peek s . duplicate seeks f = peeks f . duplicate experiment f w = fmap (`peek` w) (f (pos w))
pos :: ComonadStore s w => w a -> s
peek :: ComonadStore s w => s -> w a -> a
peeks :: ComonadStore s w => (s -> s) -> w a -> a
seek :: ComonadStore s w => s -> w a -> w a
seeks :: ComonadStore s w => (s -> s) -> w a -> w a
experiment :: (ComonadStore s w, Functor f) => (s -> f s) -> w a -> f a
lowerPos :: (ComonadTrans t, ComonadStore s w) => t w a -> s
lowerPeek :: (ComonadTrans t, ComonadStore s w) => s -> t w a -> a
instance [safe] (ComonadStore s w, Monoid m) => ComonadStore s (TracedT m w)
instance [safe] ComonadStore s w => ComonadStore s (EnvT e w)
instance [safe] ComonadStore s w => ComonadStore s (IdentityT w)
instance [safe] Comonad w => ComonadStore s (StoreT s w)


module Control.Comonad.Store
class Comonad w => ComonadStore s w | w -> s where peeks f w = peek (f (pos w)) w seek s = peek s . duplicate seeks f = peeks f . duplicate experiment f w = fmap (`peek` w) (f (pos w))
pos :: ComonadStore s w => w a -> s
peek :: ComonadStore s w => s -> w a -> a
peeks :: ComonadStore s w => (s -> s) -> w a -> a
seek :: ComonadStore s w => s -> w a -> w a
seeks :: ComonadStore s w => (s -> s) -> w a -> w a
experiment :: (ComonadStore s w, Functor f) => (s -> f s) -> w a -> f a
type Store s = StoreT s Identity

-- | Create a Store using an accessor function and a stored value
store :: (s -> a) -> s -> Store s a
runStore :: Store s a -> (s -> a, s)
data StoreT s w a
StoreT :: (w (s -> a)) -> s -> StoreT s w a
runStoreT :: StoreT s w a -> (w (s -> a), s)


module Control.Comonad.Traced.Class
class Comonad w => ComonadTraced m w | w -> m
trace :: ComonadTraced m w => m -> w a -> a
traces :: ComonadTraced m w => (a -> m) -> w a -> a
instance [safe] ComonadTraced m w => ComonadTraced m (StoreT s w)
instance [safe] ComonadTraced m w => ComonadTraced m (EnvT e w)
instance [safe] ComonadTraced m w => ComonadTraced m (IdentityT w)
instance [safe] Monoid m => ComonadTraced m ((->) m)
instance [safe] (Comonad w, Monoid m) => ComonadTraced m (TracedT m w)


module Control.Comonad.Traced
class Comonad w => ComonadTraced m w | w -> m
trace :: ComonadTraced m w => m -> w a -> a
traces :: ComonadTraced m w => (a -> m) -> w a -> a
type Traced m = TracedT m Identity
traced :: (m -> a) -> Traced m a
runTraced :: Traced m a -> m -> a
newtype TracedT m w a
TracedT :: w (m -> a) -> TracedT m w a
runTracedT :: TracedT m w a -> w (m -> a)


module Data.Functor.Coproduct
newtype Coproduct f g a
Coproduct :: Either (f a) (g a) -> Coproduct f g a
getCoproduct :: Coproduct f g a -> Either (f a) (g a)
left :: f a -> Coproduct f g a
right :: g a -> Coproduct f g a
coproduct :: (f a -> b) -> (g a -> b) -> Coproduct f g a -> b
instance [safe] (Eq (f a), Eq (g a)) => Eq (Coproduct f g a)
instance [safe] (Ord (f a), Ord (g a)) => Ord (Coproduct f g a)
instance [safe] (Read (f a), Read (g a)) => Read (Coproduct f g a)
instance [safe] (Show (f a), Show (g a)) => Show (Coproduct f g a)
instance [safe] (Contravariant f, Contravariant g) => Contravariant (Coproduct f g)
instance [safe] (Comonad f, Comonad g) => Comonad (Coproduct f g)
instance [safe] (Traversable f, Traversable g) => Traversable (Coproduct f g)
instance [safe] (Foldable f, Foldable g) => Foldable (Coproduct f g)
instance [safe] (Functor f, Functor g) => Functor (Coproduct f g)
