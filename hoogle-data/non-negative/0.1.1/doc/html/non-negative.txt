-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-negative numbers
--   
--   Provides a class for non-negative numbers, a wrapper which can turn
--   any ordered numeric type into a member of that class, and a lazy
--   number type for non-negative numbers (a generalization of Peano
--   numbers). This library is used by the <tt>event-list</tt> package.
@package non-negative
@version 0.1.1


-- | A type class for non-negative numbers. Prominent instances are
--   <a>T</a>, peano numbers and types from <a>Data.Word</a>. However,
--   there is Monoid class for Word types. Maybe Word is not a candidate,
--   since it has wrap-around semantics. This class cannot do any checks,
--   but it let you show to the user what arguments your function expects.
--   Thus you must define class instances with care. In fact many standard
--   functions (<a>take</a>, '(!!)', ...) should have this type class
--   constraint.
module Numeric.NonNegative.Class

-- | Instances of this class must ensure non-negative values. We cannot
--   enforce this by types, but the type class constraint
--   <tt>NonNegative.C</tt> avoids accidental usage of types which allow
--   for negative numbers.
--   
--   The Monoid superclass contributes a zero and an addition.
class (Ord a, Monoid a) => C a
split :: C a => a -> a -> (a, (Bool, a))

-- | Default implementation for wrapped types of <a>Ord</a> and <a>Num</a>
--   class.
splitDefault :: (Ord b, Num b) => (a -> b) -> (b -> a) -> a -> a -> (a, (Bool, a))

-- | <pre>
--   x -| y == max 0 (x-y)
--   </pre>
--   
--   The default implementation is not efficient, because it compares the
--   values and then subtracts, again, if safe. <tt>max 0 (x-y)</tt> is
--   more elegant and efficient but not possible in the general case, since
--   <tt>x-y</tt> may already yield a negative number.
(-|) :: C a => a -> a -> a
zero :: C a => a
add :: C a => a -> a -> a
sum :: C a => [a] -> a

-- | Left biased maximum of a list of numbers that can also be empty. It
--   holds
--   
--   <pre>
--   maximum [] == zero
--   </pre>
maximum :: C a => [a] -> a

-- | In <tt>switchDifferenceNegative x y branchXminusY branchYminusX</tt>
--   the function <tt>branchXminusY</tt> is applied to <tt>x-y</tt> if this
--   difference is non-negative, otherwise <tt>branchYminusX</tt> is
--   applied to <tt>y-x</tt>.
switchDifferenceNegative :: C a => a -> a -> (a -> b) -> (a -> b) -> b

-- | In <tt>switchDifferenceOrdering x y branchZero branchXminusY
--   branchYminusX</tt>
switchDifferenceOrdering :: C a => a -> a -> b -> (a -> b) -> (a -> b) -> b


-- | A type for non-negative numbers. It performs a run-time check at
--   construction time (i.e. at run-time) and is a member of the
--   non-negative number type class <a>C</a>.
module Numeric.NonNegative.Wrapper
data T a

-- | Convert a number to a non-negative number. If a negative number is
--   given, an error is raised.
fromNumber :: (Ord a, Num a) => a -> T a
fromNumberMsg :: (Ord a, Num a) => String -> a -> T a

-- | Convert a number to a non-negative number. A negative number will be
--   replaced by zero. Use this function with care since it may hide bugs.
fromNumberClip :: (Ord a, Num a) => a -> T a

-- | Wrap a number into a non-negative number without doing checks. This
--   routine exists entirely for efficiency reasons and must be used only
--   in cases where you are absolutely sure, that the input number is
--   non-negative.
fromNumberUnsafe :: a -> T a
toNumber :: T a -> a
type Int = T Int
type Integer = T Integer
type Float = T Float
type Double = T Double
type Ratio a = T (Ratio a)
type Rational = T Rational
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance (Num a, Arbitrary a) => Arbitrary (T a)
instance (Ord a, Floating a) => Floating (T a)
instance RealFrac a => RealFrac (T a)
instance (Ord a, Fractional a) => Fractional (T a)
instance Integral a => Integral (T a)
instance (Ord a, Num a, Bounded a) => Bounded (T a)
instance (Ord a, Num a, Enum a) => Enum (T a)
instance Real a => Real (T a)
instance (Ord a, Num a) => Num (T a)
instance (Ord a, Num a) => C (T a)
instance Num a => Monoid (T a)
instance Show a => Show (T a)


-- | A lazy number type, which is a generalization of lazy Peano numbers.
--   Comparisons can be made lazy and thus computations are possible which
--   are impossible with strict number types, e.g. you can compute <tt>let
--   y = min (1+y) 2 in y</tt>. You can even work with infinite values.
--   However, depending on the granularity, the memory consumption is
--   higher than that for strict number types. This number type is of
--   interest for the merge operation of event lists, which allows for
--   co-recursive merges.
module Numeric.NonNegative.Chunky

-- | A chunky non-negative number is a list of non-negative numbers. It
--   represents the sum of the list elements. It is possible to represent a
--   finite number with infinitely many chunks by using an infinite number
--   of zeros.
--   
--   Note the following problems:
--   
--   Addition is commutative only for finite representations. E.g. <tt>let
--   y = min (1+y) 2 in y</tt> is defined, <tt>let y = min (y+1) 2 in
--   y</tt> is not.
data T a
fromChunks :: C a => [a] -> T a
fromNumber :: C a => a -> T a

-- | This routine exposes the inner structure of the lazy number.
toChunks :: T a -> [a]
toNumber :: C a => T a -> a
zero :: T a

-- | Remove zero chunks.
normalize :: C a => T a -> T a
isNull :: C a => T a -> Bool
isPositive :: C a => T a -> Bool
divModStrict :: (Integral a, C a) => T a -> a -> (T a, a)
