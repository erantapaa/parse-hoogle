-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some utility functions for JYU projects
--   
--   List, function and monad utility functions. Includes an old variant of
--   MonadRandom that is used in CV-package. Pretty much the only reason to
--   ever use this is to compile CV-package, and that is also just due
--   legacy reasons.
@package JYU-Utils
@version 0.1.1.2

module Utils.Exception

module Utils.Stream

-- | Stream of monadic values
data Stream m a
Terminated :: Stream m a
Value :: (m (a, Stream m a)) -> Stream m a

-- | Attaching side effects
sideEffect :: Monad m => (a -> m ()) -> Stream m a -> Stream m a

-- | Repeating stream
--   
--   Create a stream by iterating a monadic action
--   
--   Pure and monadic left fold over a stream
--   
--   Merge two (time)streams
data LRB a b c
L :: a -> LRB a b c
B :: b -> LRB a b c
R :: c -> LRB a b c
sequenceS :: Monad m => Stream m (m a) -> (Stream m a)
mapMS :: Monad m => (a -> m b) -> Stream m a -> Stream m b

-- | Drop elements from the stream. Due to stream structure, this operation
--   cannot fail gracefully when dropping more elements than what is found
--   in the stream
dropS :: Monad m => Int -> Stream m a -> Stream m a
takeS :: Monad m => Int -> Stream m a -> Stream m a
pairS :: Monad m => Stream m a -> Stream m (a, a)
terminateOn :: Monad m => (a -> Bool) -> Stream m a -> Stream m a
instance (Show a, Show b, Show c) => Show (LRB a b c)
instance Monad m => Applicative (Stream m)
instance Monad m => Functor (Stream m)

module Utils.ShuffleMWC
shuffle :: [t] -> [Int] -> [t]
doShuffle :: (Functor m, PrimMonad m) => Gen (PrimState m) -> [t] -> m [t]
instance Show a => Show (Tree a)

module Utils.Point
type Pt a = (a, a)
norm2 :: Num a => Pt a -> a
instance Num a => Num (Pt a)

module Utils.Rectangle
newtype Rectangle a
Rectangle :: ((a, a), (a, a)) -> Rectangle a

-- | Create rectangle around point (x,y)
prop_Corners :: (Int, Int) -> (Int, Int) -> Bool
instance Eq a => Eq (Rectangle a)
instance Show a => Show (Rectangle a)
instance (Num a, Ord a, Serial a) => Serial (Rectangle a)
instance NFData a => NFData (Rectangle a)

module Utils.BinaryInstances
instance Binary a => Binary (Rectangle a)

module Utils.Table
type Table row col c = Map (row, col) c
type Stripe a b = Map a b
intersectionWith :: (Ord row, Ord col) => (a -> b -> c) -> Table row col a -> Table row col b -> Table row col c
row :: (Ord a, Ord b) => a -> Table a b c -> Stripe b c
column :: (Ord a, Ord b) => b -> Table a b c -> Stripe a c
rows :: (Ord a, Ord b) => Table a b c -> Map a (Stripe b c)
columns :: (Ord a, Ord b) => Table a b c -> Map b (Stripe a c)
rowNames :: (Ord a, Ord b) => Table a b c -> [a]
colNames :: (Ord a, Ord b) => Table a b c -> [b]
fromRows :: (Ord a, Ord b) => Map a (Stripe b c) -> Table a b c
fromCols :: (Ord a, Ord b) => Map a (Stripe b c) -> Table b a c

module Utils.File

-- | Cache results of operation op under name <tt>fn</tt>. if correct file
--   is found, its contents are used, otherwise <tt>op</tt> is performed
--   and it's results are saved to the filed and returned from the call.
class Cacheable a
writeCache :: Cacheable a => FilePath -> a -> IO ()
readCache :: Cacheable a => FilePath -> IO a
cached :: Cacheable a => FilePath -> IO a -> IO a
inDirectory :: FilePath -> IO a -> IO a
instance Binary a => Cacheable a

module Utils.Monad
sequenceWithParM :: Monad m => a -> [a -> m a] -> m a
doWhile :: Monad m => (a -> m (Maybe a)) -> a -> m a
untilM :: Monad m => (a -> Bool) -> (m a) -> m a

module Utils.Parallel
data TaskRunnerStrategy
Persistent :: TaskRunnerStrategy
Failing :: TaskRunnerStrategy
taskRunner :: TaskRunnerStrategy -> TVar Bool -> TVar [IO ()] -> IO ()
parRun :: TaskRunnerStrategy -> Int -> [IO ()] -> IO ()
parRunWithMonitor :: TaskRunnerStrategy -> Int -> (TVar [IO ()] -> [TVar Bool] -> IO ()) -> [IO ()] -> IO ()
fork1 :: (a -> IO b) -> a -> IO (MVar b)
fork :: (a -> IO b) -> [a] -> IO [MVar b]
joinMVars :: [MVar b] -> IO [b]
forkAndJoin :: (a -> IO b) -> [a] -> IO [b]
instance Eq TaskRunnerStrategy
instance Show TaskRunnerStrategy

module Utils.DynMap
newtype PropertyMap
PM :: (Map String (String, Dynamic)) -> PropertyMap
emptyD :: PropertyMap
(=:) :: (Show a, Typeable a) => String -> a -> State PropertyMap ()
instance Show PropertyMap

module Utils.String
columns :: [(String, String)] -> String
columnS :: Show a => [(String, a)] -> String

module Utils.List

-- | Group list into indevidual pairs: [1,2,3,4] =&gt; [(1,2),(3,4)].
--   Works only with even number of elements
--   
--   Undo pairs function
--   
--   Group list into pairs: [1,2,3] =&gt; [(1,2),(2,3)]. Works with non
--   null lists
--   
--   Undo pairs1 function
clusterBy :: Ord b => (a -> b) -> [a] -> [[a]]
schwartzianTransform :: (Ord a, Ord b) => (a -> b) -> [a] -> [a]
splitBy :: (a -> Bool) -> [a] -> [[a]]
applyMapM :: Monad m => a -> [a -> m b] -> m [b]
changesM :: Monad m => [a -> m b] -> a -> m [b]

module Utils.Vector
type Vector = [Double]
stdDev :: [Vector] -> Double
showVector :: Int -> Vector -> String
showMatrix1 :: Int -> [Vector] -> String
showMatrix :: Int -> [Vector] -> String
snap :: Double -> Double -> Double

module Utils.SemanticEditors

module Utils.MonadRandom
class Monad m => MonadRandom m
getRandom :: (MonadRandom m, Random a) => m a
getRandomR :: (MonadRandom m, Random a) => (a, a) -> m a
uniformRandomVector :: (Random a, MonadRandom m) => Int -> m [a]
uniformRandomVectorRS :: (Random b, MonadRandom m) => [(b, b)] -> m [b]
gaussianVector :: (Floating b, Random b, MonadRandom m) => b -> Int -> m [b]
gaussianPerturbation :: (Floating c, Random c, MonadRandom m) => c -> [c] -> m [c]
gaussianPerturbationR :: (Floating c, Random c, MonadRandom m) => [c] -> [c] -> m [c]
gaussianRand :: (MonadRandom m, Random a, Floating a) => m [a]
normRand :: (Floating b, Random b, MonadRandom m) => b -> b -> m b
cauchyR :: MonadRandom m => Double -> Double -> m Double
evalRandomT :: (RandomGen g, Monad m) => RandomT g m a -> g -> m a
runRandomT :: RandomGen s => RandomT s m a -> s -> m (a, s)
evalRandomIO :: MonadIO m => RandomT StdGen m b -> m b
evalRand :: RandomGen g => Rand g a -> g -> a
fromList :: MonadRandom m => [(a, Rational)] -> m a
fromNonWeightedList :: MonadRandom m => [b] -> m b
chooseAtRandom :: MonadRandom m => (b, b) -> m b
randomList :: MonadRandom m => [a] -> Int -> m [a]
randomRoll :: MonadRandom m => [a] -> m [a]
withRandomPair :: MonadRandom m => (t -> t -> m b) -> [t] -> m b
withRandomThree :: MonadRandom m => (t -> t -> t -> m b) -> [t] -> m b
withProbability :: MonadRandom m => Double -> m a -> m a -> m a
data Rand g a
data RandomGen g => RandomT g m a
instance Functor m => Functor (RandomT g m)
instance Monad m => Monad (RandomT g m)
instance MonadTrans (RandomT g)
instance MonadIO m => MonadIO (RandomT g m)
instance Functor (Rand g)
instance Monad (Rand g)
instance RandomGen g => MonadRandom (Rand g)
instance (Monad m, RandomGen g) => MonadRandom (RandomT g m)

module Utils.Shuffle
shuffle :: [t] -> [Int] -> [t]
doShuffle :: MonadRandom m => [t] -> m [t]
instance Show a => Show (Tree a)

module Utils.Sampling
sus :: [(Double, a)] -> Int -> Double -> [a]

module Utils.Numeric
widths :: Num a => [(a, a)] -> [a]

module Utils.Function
minBy :: (a -> a -> Ordering) -> a -> a -> a
maxBy :: (a -> a -> Ordering) -> a -> a -> a

module Utils.Darcs
