-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Minimal ini like configuration library with a few extras
--   
--   The module exported provides the ability to manage a configuration
--   file in the users home directory (or the Windows equivalent). Where
--   the configuration takes the form of key=value, without sections, that
--   for example an '.ini' would have.
--   
--   The library simplifies serilization/deserialization of the
--   configuration into a structure similar in behavior to a <a>Map</a>, as
--   well as an interactive way to fill in values for simple cases.
--   
--   Consider the following example, where a user would run the application
--   for the first time, it would ask him for his name; however on a
--   followup run it would just print a greeting with his name.
--   
--   <pre>
--   import System.Config.File
--   
--   main = withConfiguration ".apprc" $ \conf -&gt; do
--       let name = getV conf "name"
--       case name of Just n  -&gt; putStrLn $ "hello " ++ n
--                    Nothing -&gt; do conf' &lt;- fillInteractively conf [("name", acceptNonBlank)]
--                                  saveConfiguration conf'
--   </pre>
@package minimal-configuration
@version 0.1


-- | IMPORTANT NOTE: this module works with the user's home directory, and
--   that is the place where the configuration will be read from and
--   persisted.
module System.Config.File
type Key = String
type Value = String

-- | While the internal representation is not exposed directly, an
--   implementation of the <a>Show</a> instance is provided in order to
--   dump the configuration when that may be aidful in debugging. However,
--   you will only see the key values stored inside the <a>Map</a>
data Configuration

-- | However if you like to stack software ala <tt> withSocketsDo $ withX $
--   withY </tt> this might not be your preferred approach. You could go
--   with the following approach, which was excluded for library
--   portability:
--   
--   <pre>
--   {-# LANGUAGE ImplicitParams, RankNTypes #-}
--   import System.Config.File
--   
--   withConfigurationImplicit :: String -&gt; ((?configuration :: Configuration) =&gt; IO b) -&gt; IO b
--   withConfigurationImplicit filename f = withConfiguration filename (\c -&gt; let ?configuration = c in f)
--   
--   main = withConfigurationImplicit ".apprc" $ do
--      print $ hasV "name" ?configuration
--      print $ getV "name" ?configuration
--   </pre>
withConfiguration :: String -> (Configuration -> IO b) -> IO b
loadConfiguration :: String -> IO Configuration

-- | The configuration will be saved into the same file it was read from,
--   obviously
saveConfiguration :: Configuration -> IO ()
hasV :: Configuration -> Key -> Bool
getV :: Configuration -> Key -> Maybe Value
removeV :: Configuration -> Key -> Configuration
replaceV :: Configuration -> Key -> Value -> Configuration

-- | Via the <a>Left</a> data constructor we are able to pass the message
--   necessary to notify the user that the inputed data is not valid
type InteractiveValidator = Value -> IO (Either String Value)
acceptNonBlank :: InteractiveValidator
acceptAnything :: InteractiveValidator

-- | Request user input for the set of (Key, InteractiveValidator). For
--   keys that are already set in the <a>Configuration</a>, values will be
--   overwritten
fillInteractively :: Configuration -> [(Key, InteractiveValidator)] -> IO Configuration

-- | Execution dependent on a predicate
fillInteractivelyWhen :: (Configuration -> Bool) -> Configuration -> [(Key, InteractiveValidator)] -> IO Configuration

-- | Has this configuration just been created?
newC :: Configuration -> Bool

-- | Configuration doesn't contain any values?
emptyC :: Configuration -> Bool
instance Show Configuration
