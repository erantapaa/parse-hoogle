-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility library for the tamarin prover.
--   
--   This is an internal library of the Tamarin prover for security
--   protocol verification
--   (<a>hackage.haskell.org/package/tamarin-prover</a>).
@package tamarin-prover-utils
@version 0.8.5.1

module Utils.Misc

-- | <tt>envIsSet k</tt> returns <tt>True</tt> if there is a v such
--   <tt>k=v</tt> is in the environment and <tt>False</tt> otherwise.
envIsSet :: String -> Bool

-- | <tt>getEnvMaybe k</tt> returns <tt>Just v</tt> if <tt>k=v</tt> is in
--   the environment and <tt>Nothing</tt> otherwise
getEnvMaybe :: String -> Maybe String

-- | <tt>subsetOf xs ys</tt> return <tt>True</tt> if <tt>set xs</tt> is a
--   subset of <tt>set ys</tt>
subsetOf :: Ord a => [a] -> [a] -> Bool

-- | <tt>noDuplicates xs</tt> returns <tt>True</tt> if the list <tt>xs</tt>
--   contains no duplicates
noDuplicates :: Ord a => [a] -> Bool

-- | Compute the equality classes given wrto a partial function.
equivClasses :: (Ord a, Ord b) => [(a, b)] -> Map b (Set a)

-- | <tt>whileTrue m</tt> iterates m until it returns <tt>False</tt>.
--   Returns the number of iterations <tt>m</tt> was run. <tt>0</tt> means
--   <tt>m</tt> never returned <tt>True</tt>.
whileTrue :: Monad m => m Bool -> m Int

-- | The SHA-256 hash of a string in base64 notation.
stringSHA256 :: String -> String
setAny :: (a -> Bool) -> Set a -> Bool

-- | Inverts a bijective Map.
invertMap :: (Ord k, Ord v) => Map k v -> Map v k
unsafeEq :: a -> a -> Bool


-- | Module that can be imported to ignore calls to <tt>trace</tt>.
module Debug.Trace.Ignore

-- | <tt>trace a b</tt> returns the second argument.
trace :: a -> b -> b


-- | A simple module for timing IO action.
module System.Timing

-- | Execute an IO action and return its result plus the time it took to
--   execute it.
timed :: IO a -> IO (a, NominalDiffTime)

-- | Execute an IO action and return the time it took to execute it.
timed_ :: IO a -> IO NominalDiffTime


-- | Support functions for exploiting Unicode characters.
module Text.Unicode

-- | Convert a subscriptable character to its subsript.
subscriptChar :: Char -> Char

-- | Convert all subscriptable characters to subscripts.
subscript :: String -> String


-- | This module provides a simple interface for building .dot graph files,
--   for input into the dot and graphviz tools. It includes a monadic
--   interface for building graphs.
module Text.Dot
data Dot a

-- | <a>node</a> takes a list of attributes, generates a new node, and
--   gives a <a>NodeId</a>. Multi-line labels are fixed such that they use
--   non-breaking spaces and are terminated with a new-line.
node :: [(String, String)] -> Dot NodeId
data NodeId

-- | <a>userNodeId</a> allows a user to use their own (Int-based) node
--   id's, without needing to remap them.
userNodeId :: Int -> NodeId

-- | <a>userNode</a> takes a NodeId, and adds some attributes to that node.
userNode :: NodeId -> [(String, String)] -> Dot ()

-- | <a>edge</a> generates an edge between two <a>NodeId</a>s, with
--   attributes.
edge :: NodeId -> NodeId -> [(String, String)] -> Dot ()
showDot :: Dot a -> String

-- | <a>scope</a> groups a subgraph together; in dot these are the
--   subgraphs inside <a>{</a> and <a>}</a>.
scope :: Dot a -> Dot a

-- | <a>attribute</a> gives a attribute to the current scope.
attribute :: (String, String) -> Dot ()

-- | <a>nodeAttributes</a> sets attributes for all the following nodes in
--   the scope.
nodeAttributes :: [(String, String)] -> Dot ()

-- | <a>edgeAttributes</a> sets attributes for all the following edges in
--   the scope.
edgeAttributes :: [(String, String)] -> Dot ()

-- | <a>graphAttributes</a> sets attributes for current graph.
graphAttributes :: [(String, String)] -> Dot ()

-- | <a>share</a> is when a set of nodes share specific attributes. Usually
--   used for layout tweaking.
share :: [(String, String)] -> [NodeId] -> Dot ()

-- | <a>same</a> provides a combinator for a common pattern; a set of
--   <a>NodeId</a>s with the same rank.
same :: [NodeId] -> Dot ()

-- | <a>cluster</a> builds an explicit, internally named subgraph (called
--   cluster).
cluster :: Dot a -> Dot (NodeId, a)

-- | Specifies the construction of a record; i.e., mentions all fields
--   possibly together with ports and their horizontal and vertical
--   nesting. (see: record shapes in the DOT documentation.)
data Record a

-- | A simple field of a record.
field :: String -> Record a

-- | A field together with a port which can be used to create direct edges
--   to this field. Note that you can use any type to identify the ports.
--   When creating a record node you will get back an association list
--   between your record identifiers and their concrete node ids.
portField :: a -> String -> Record a

-- | Concatenate records horizontally.
hcat :: [Record a] -> Record a

-- | Concatenate a list strings interpreted as simple fields horizontally.
hcat' :: [String] -> Record a

-- | Concatenate records vertically.
vcat :: [Record a] -> Record a

-- | Concatenate a list strings interpreted as simple fields vertically.
vcat' :: [String] -> Record a

-- | Create a record node with the given attributes. It returns the node-id
--   of the created node together with an association list mapping the port
--   idenfiers given in the record to their corresponding node-ids. This
--   list is ordered according to a left-to-rigth traversal of the record
--   description.
record :: Record a -> [(String, String)] -> Dot (NodeId, [(a, NodeId)])

-- | A variant of <a>record</a> ignoring the port identifiers.
record' :: Record a -> [(String, String)] -> Dot (NodeId, [NodeId])

-- | A variant of <a>record</a> ignoring the port to node-id association
--   list.
record_ :: Record a -> [(String, String)] -> Dot NodeId

-- | Like <a>record</a>, but creates record nodes with rounded corners;
--   i.e. uses the "Mrecord" shape instead of the "record" shape.
mrecord :: Record a -> [(String, String)] -> Dot (NodeId, [(a, NodeId)])

-- | A variant of <a>mrecord</a> ignoring the port identifiers.
mrecord' :: Record a -> [(String, String)] -> Dot (NodeId, [NodeId])

-- | A variant of <a>mrecord</a> ignoring the port to node-id association
--   list.
mrecord_ :: Record a -> [(String, String)] -> Dot NodeId
instance Eq a => Eq (Record a)
instance Ord a => Ord (Record a)
instance Show a => Show (Record a)
instance Monad Dot
instance Applicative Dot
instance Functor Dot
instance Show NodeId


-- | Provided NFData instance for ByteString (with bytestring &lt; 0.10)
module Extension.Data.ByteString


-- | Monoids for bounded types.
module Extension.Data.Bounded

-- | A newtype wrapper for a monoid of the maximum of a bounded type.
newtype BoundedMax a
BoundedMax :: a -> BoundedMax a
getBoundedMax :: BoundedMax a -> a

-- | A newtype wrapper for a monoid of the minimum of a bounded type.
newtype BoundedMin a
BoundedMin :: a -> BoundedMin a
getBoundedMin :: BoundedMin a -> a
instance Eq a => Eq (BoundedMax a)
instance Ord a => Ord (BoundedMax a)
instance Show a => Show (BoundedMax a)
instance Eq a => Eq (BoundedMin a)
instance Ord a => Ord (BoundedMin a)
instance Show a => Show (BoundedMin a)
instance (Ord a, Bounded a) => Monoid (BoundedMin a)
instance (Ord a, Bounded a) => Monoid (BoundedMax a)


-- | A variant of <a>Data.Monoid</a> that also exports '(<a></a>)' for
--   <a>mappend</a>.
module Extension.Data.Monoid

-- | A newtype wrapper around <a>Maybe</a> that returns a tuple of the
--   minimum and maximum value encountered, if there was any.
newtype MinMax a
MinMax :: Maybe (a, a) -> MinMax a
getMinMax :: MinMax a -> Maybe (a, a)

-- | Construct a <a>MinMax</a> value from a singleton value.
minMaxSingleton :: a -> MinMax a
instance Ord a => Monoid (MinMax a)


-- | Extensions to the first-class labels (fclabels) package.
module Extension.Data.Label

-- | Lens for the nth element of the list.
nthL :: Int -> ([a] :-> a)

-- | Lens for the element at a given position of a map.
imageL :: Ord k => k -> (Map k v :-> v)

-- | Lens for the first element of a tuple.
fstL :: (a, b) :-> a

-- | Lens for the second element of a tuple.
sndL :: (a, b) :-> b

-- | Lift a label into an applicative functor.
liftLA :: Applicative f => (a :-> b) -> (f a :-> f b)

-- | Effectful modification of a labeled value.
modA :: Applicative f => (a :-> b) -> (b -> f b) -> a -> f a

-- | Get part of the state from a reader.
askM :: MonadReader r m => (r :-> a) -> m a

-- | Set some part of the state.
setM :: MonadState s m => (s :-> a) -> a -> m ()

-- | Get some part of the state.
getM :: MonadState s m => (s :-> a) -> m a

-- | Modify some part of the state.
modM :: MonadState s m => (s :-> a) -> (a -> a) -> m ()

-- | Alias for <a>puts</a> that reads like an assignment.
(=:) :: MonadState s m => :-> s a -> a -> m ()


-- | A simple color module for handling RGB and HSV representations of
--   colors.
module Data.Color
data RGB a
RGB :: !a -> !a -> !a -> RGB a
rgbR :: RGB a -> !a
rgbG :: RGB a -> !a
rgbB :: RGB a -> !a
data HSV a
HSV :: !a -> !a -> !a -> HSV a
hsvH :: HSV a -> !a
hsvS :: HSV a -> !a
hsvV :: HSV a -> !a

-- | Hexadecimal representation of an RGB value
rgbToHex :: RealFrac t => RGB t -> String

-- | Hexadecimal representation of an HSV value; i.e., of its corresponding
--   RGB value.
hsvToHex :: RealFrac t => HSV t -> [Char]
red :: Fractional t => RGB t
green :: Fractional t => RGB t
blue :: Fractional t => RGB t
rgbToGray :: Ord t => RGB t -> t
hsvToGray :: Num t => HSV t -> HSV t

-- | RGB to HSV conversion. Pre: 0 &lt;= r,g,b &lt;= 1 (Source:
--   http:<i></i>de.wikipedia.org<i>wiki</i>HSV-Farbraum)
rgbToHSV :: (Fractional t, Ord t) => RGB t -> HSV t

-- | HSV to RGB conversion. Pre: 0 &lt;= h &lt;= 360 and 0 &lt;= s,v &lt;=
--   1 (Source: http:<i></i>de.wikipedia.org<i>wiki</i>HSV-Farbraum)
hsvToRGB :: RealFrac t => HSV t -> RGB t

-- | Build color groups according to the list of group sizes using the
--   default <a>colorGroupStyle</a> for the function <a>genColorGroups</a>.
colorGroups :: Double -> [Int] -> [((Int, Int), HSV Double)]

-- | Build color groups according to the list of group sizes using the
--   default light <a>lightColorGroupStyle</a> for the function
--   <a>genColorGroups</a>.
lightColorGroups :: Double -> [Int] -> [((Int, Int), HSV Double)]
instance Eq a => Eq (RGB a)
instance Ord a => Ord (RGB a)
instance Eq a => Eq (HSV a)
instance Ord a => Ord (HSV a)
instance Eq t => Eq (ColorParams t)
instance Ord t => Ord (ColorParams t)
instance Show t => Show (ColorParams t)
instance Functor HSV
instance Show a => Show (HSV a)
instance Functor RGB
instance Show a => Show (RGB a)


-- | Re-export basic control structures for easier imports.
module Control.Basics


-- | A monad transformer for passing a fast fresh name supply through a
--   computation. It uses an <a>Integer</a> counter to determine the next
--   free name.
--   
--   Modeled after the mtl-2.0 library.
module Control.Monad.Trans.FastFresh
type Fresh = FreshT Identity

-- | Run a computation with a fresh name supply.
runFresh :: Fresh a -> FreshState -> (a, FreshState)

-- | Evaluate a computation with a fresh name supply.
evalFresh :: Fresh a -> FreshState -> a

-- | Execute a computation with a fresh name supply.
execFresh :: Fresh a -> FreshState -> FreshState

-- | A computation that can generate fresh variables from name hints.
newtype FreshT m a
FreshT :: StateT FreshState m a -> FreshT m a
unFreshT :: FreshT m a -> StateT FreshState m a

-- | Construct a <a>FreshT</a> action from a <a>FreshState</a>
--   modification.
freshT :: (FreshState -> m (a, FreshState)) -> FreshT m a

-- | Run a computation with a fresh name supply.
runFreshT :: FreshT m a -> FreshState -> m (a, FreshState)

-- | Evaluate a computation with a fresh name supply.
evalFreshT :: Monad m => FreshT m a -> FreshState -> m a

-- | Execute a computation with a fresh name supply.
execFreshT :: Monad m => FreshT m a -> FreshState -> m FreshState

-- | The state of the name supply: the first unused sequence number of
--   every name.
type FreshState = Integer

-- | The empty fresh state.
nothingUsed :: FreshState

-- | Get <tt>k</tt> fresh identifiers.
freshIdents :: Monad m => Integer -> FreshT m Integer

-- | Restrict the scope of the freshness requests.
scopeFreshness :: Monad m => FreshT m a -> FreshT m a
instance Functor m => Functor (FreshT m)
instance (Monad m, Functor m) => Applicative (FreshT m)
instance (Functor m, MonadPlus m) => Alternative (FreshT m)
instance Monad m => Monad (FreshT m)
instance MonadPlus m => MonadPlus (FreshT m)
instance MonadTrans FreshT
instance MonadState s m => MonadState s (FreshT m)
instance MonadReader r m => MonadReader r (FreshT m)
instance MonadError e m => MonadError e (FreshT m)


-- | A monad transformer for passing a fresh name supply through a
--   computation. The name supply is precise in the sense that every
--   <a>String</a> has its own supply of indices for the next fresh name.
--   
--   Modeled after the mtl-2.0 library.
module Control.Monad.Trans.PreciseFresh
type Fresh = FreshT Identity

-- | Run a computation with a fresh name supply.
runFresh :: Fresh a -> FreshState -> (a, FreshState)

-- | Evaluate a computation with a fresh name supply.
evalFresh :: Fresh a -> FreshState -> a

-- | Execute a computation with a fresh name supply.
execFresh :: Fresh a -> FreshState -> FreshState

-- | A computation that can generate fresh variables from name hints.
newtype FreshT m a
FreshT :: StateT FreshState m a -> FreshT m a
unFreshT :: FreshT m a -> StateT FreshState m a

-- | Construct a <a>FreshT</a> action from a <a>FreshState</a>
--   modification.
freshT :: (FreshState -> m (a, FreshState)) -> FreshT m a

-- | Run a computation with a fresh name supply.
runFreshT :: FreshT m a -> FreshState -> m (a, FreshState)
evalFreshT :: Monad m => FreshT m a -> FreshState -> m a

-- | Execute a computation with a fresh name supply.
execFreshT :: Monad m => FreshT m a -> FreshState -> m FreshState

-- | The state of the name supply: the first unused sequence number of
--   every name.
type FreshState = Map String Integer

-- | The empty fresh state.
nothingUsed :: FreshState

-- | <i>O(log(n))</i>. Get a fresh identifier for the given name.
freshIdent :: Monad m => String -> FreshT m Integer

-- | <i>O(n)</i>. Get <tt>k</tt> fresh identifiers.
freshIdents :: Monad m => Integer -> FreshT m Integer

-- | Restrict the scope of the freshness requests.
scopeFreshness :: Monad m => FreshT m a -> FreshT m a
instance Functor m => Functor (FreshT m)
instance (Monad m, Functor m) => Applicative (FreshT m)
instance (Functor m, MonadPlus m) => Alternative (FreshT m)
instance Monad m => Monad (FreshT m)
instance MonadPlus m => MonadPlus (FreshT m)
instance MonadTrans FreshT
instance MonadState s m => MonadState s (FreshT m)
instance MonadReader r m => MonadReader r (FreshT m)
instance MonadError e m => MonadError e (FreshT m)


-- | Computations that need a fresh name supply.
module Control.Monad.Fresh
class (Applicative m, Monad m) => MonadFresh m
freshIdent :: MonadFresh m => String -> m Integer
freshIdents :: MonadFresh m => Integer -> m Integer
scopeFreshness :: MonadFresh m => m a -> m a
type Fresh = FreshT Identity

-- | Run a computation with a fresh name supply.
runFresh :: Fresh a -> FreshState -> (a, FreshState)

-- | Evaluate a computation with a fresh name supply.
evalFresh :: Fresh a -> FreshState -> a

-- | Execute a computation with a fresh name supply.
execFresh :: Fresh a -> FreshState -> FreshState

-- | A computation that can generate fresh variables from name hints.
newtype FreshT m a
FreshT :: StateT FreshState m a -> FreshT m a
unFreshT :: FreshT m a -> StateT FreshState m a

-- | Construct a <a>FreshT</a> action from a <a>FreshState</a>
--   modification.
freshT :: (FreshState -> m (a, FreshState)) -> FreshT m a

-- | Run a computation with a fresh name supply.
runFreshT :: FreshT m a -> FreshState -> m (a, FreshState)

-- | Evaluate a computation with a fresh name supply.
evalFreshT :: Monad m => FreshT m a -> FreshState -> m a

-- | Execute a computation with a fresh name supply.
execFreshT :: Monad m => FreshT m a -> FreshState -> m FreshState

-- | The state of the name supply: the first unused sequence number of
--   every name.
type FreshState = Integer

-- | The empty fresh state.
nothingUsed :: FreshState


-- | Computations that need perform case distinctions.
module Control.Monad.Disj
class Monad m => MonadDisj m
contradictoryBecause :: MonadDisj m => Maybe String -> m a
disjunction :: MonadDisj m => m a -> m a -> m a

-- | <tt>contradictory</tt> denotes the logical false.
contradictory :: MonadDisj m => m a

-- | <tt>contradictoryIf b</tt> is logically equivalent to <tt>not b</tt>
contradictoryIf :: MonadDisj m => Bool -> m ()

-- | <tt>contradiction reason</tt> denotes the logical false, but also
--   provides the <tt>reason</tt> as meta-information.
contradiction :: MonadDisj m => String -> m a

-- | <tt>contradictionIf b reason</tt> is logically equivalent to <tt>not
--   b</tt>, but also provides the <tt>reason</tt> as meta-information.
contradictionIf :: MonadDisj m => Bool -> String -> m ()

-- | <tt>disjunctions ds</tt> builds the disjunction of all the <tt>ds</tt>
--   values.
disjunctions :: MonadDisj m => [m a] -> m a

-- | <tt>disjunctionOfList xs</tt> build the disjunction of the values in
--   list <tt>xs</tt>.
disjunctionOfList :: MonadDisj m => [a] -> m a

-- | A disjunction of atoms of type a.
newtype DisjT m a
DisjT :: ListT m a -> DisjT m a
unDisjT :: DisjT m a -> ListT m a

-- | Construct a <a>DisjT</a> action.
disjT :: m [a] -> DisjT m a

-- | Run a <a>DisjT</a> action.
runDisjT :: DisjT m a -> m [a]


-- | Shallow monad transformer for dealing with bindings.
module Control.Monad.Bind

-- | Type constructor for the state of the binding store.
type Bindings = Map

-- | The empty binding store.
noBindings :: Bindings v k
class MonadState (Bindings k v) m => MonadBind k v m

-- | Managing just bindings.
type Bind k v = State (Bindings k v)

-- | Run a computation with bindings.
runBind :: Bind k v a -> Bindings k v -> (a, Bindings k v)

-- | Evaluate a binding context computation.
evalBind :: Bind k v a -> Bindings k v -> a

-- | Execute a binding context computation.
execBind :: Bind k v a -> Bindings k v -> Bindings k v

-- | Managing bindings on top of another monad.
type BindT k v = StateT (Bindings k v)

-- | Run a computation with bindings.
runBindT :: BindT k v m a -> Bindings k v -> m (a, Bindings k v)

-- | Evaluate a binding context computation.
evalBindT :: Monad m => BindT k v m a -> Bindings k v -> m a

-- | Execute a binding context computation.
execBindT :: Monad m => BindT k v m a -> Bindings k v -> m (Bindings k v)

-- | Lookup a stored binding.
lookupBinding :: (MonadBind k v m, Ord k) => k -> m (Maybe v)

-- | <tt>insertBinding k v</tt> inserts the binding of <tt>k</tt> to
--   <tt>v</tt>, possibly overwriting the existing binding of <tt>k</tt>.
insertBinding :: (MonadBind k v m, Ord k) => k -> v -> m ()

-- | <tt>importBinding mkR d n</tt> checks if there is already a binding
--   registered for the value <tt>d</tt> and if not it generates a fresh
--   identifier using the name <tt>n</tt> as a hint and converting name and
--   identifier to a value using $mkR$.
importBinding :: (MonadBind k v m, MonadFresh m, Show v, Show k, Ord k) => (String -> Integer -> v) -> k -> String -> m v
instance MonadBind k v m => MonadBind k v (FreshT m)
instance MonadBind k v m => MonadBind k v (FreshT m)
instance Monad m => MonadBind k v (StateT (Bindings k v) m)


-- | Simple vertice list based representation of DAGs and some common
--   operations on it.
module Data.DAG.Simple

-- | A relation represented as a list of tuples.
type Relation a = [(a, a)]

-- | The inverse of a <a>Relation</a>.
inverse :: Relation a -> Relation a

-- | The image of an element under a <a>Relation</a>.
image :: Eq a => a -> Relation a -> [a]

-- | Compute the set of nodes reachable from the given set of nodes.
reachableSet :: Ord a => [a] -> [(a, a)] -> Set a

-- | Restrict a relation to elements satisfying a predicate.
restrict :: Eq a => (a -> Bool) -> Relation a -> Relation a

-- | Compute a minimal set of loop-breakers using a greedy DFS strategy. A
--   set of loop-breakers is a set of nodes such that removing them ensures
--   the acyclicity of the relation. It is minimal, if no node can be
--   removed from the set.
dfsLoopBreakers :: Ord a => [(a, a)] -> [a]

-- | Is the relation cyclic.
cyclic :: Ord a => [(a, a)] -> Bool

-- | Produce a topological sorting of the given relation. If the relation
--   is cyclic, then the result is at least some permutation of all
--   elements of the given relation.
toposort :: Ord a => [(a, a)] -> [a]


-- | Functions that could/should have made it into the Prelude or one of
--   the base libraries
module Extension.Prelude
implies :: Bool -> Bool -> Bool
singleton :: a -> [a]

-- | check whether the given list contains no duplicates
unique :: Eq a => [a] -> Bool

-- | Sort list and remove duplicates. O(n*log n)
sortednub :: Ord a => [a] -> [a]

-- | Sort a list according to a user-defined comparison function and remove
--   duplicates.
sortednubBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | <i></i>O(n*log n).<i></i> Sort list and remove duplicates with respect
--   to a projection.
sortednubOn :: Ord b => (a -> b) -> [a] -> [a]

-- | Keep only the first element of elements having the same projected
--   value
nubOn :: Eq b => (a -> b) -> [a] -> [a]

-- | <i></i>O(n).<i></i> Group on a projection of the data to group
groupOn :: Eq b => (a -> b) -> [a] -> [[a]]

-- | sort on a projection of the data to sort
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | sort on a projection of the data to sort, memorizing the results of
--   the projection in order to avoid recomputation.
sortOnMemo :: Ord b => (a -> b) -> [a] -> [a]

-- | sort and group on a projection
groupSortOn :: Ord b => (a -> b) -> [a] -> [[a]]

-- | partition the given set into equality classes with respect to the
--   representative given by the projection function
eqClasses :: (Eq b, Ord b) => (a -> b) -> [a] -> [[a]]
eqClassesBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> [[a]]

-- | split a list into sublists whenever the predicate identifies an
--   element as a separator. Note that the separator is not retained and a
--   separator at the very end is ignored.
splitBy :: (a -> Bool) -> [a] -> [[a]]

-- | the list of all permutations of a given list permutations :: [a] -&gt;
--   [[a]] permutations [] = [[]] permutations zs = aux zs [] where aux []
--   _ = [] aux (x:xs) ys = [x:p | p &lt;- permutations (xs++ys)] ++ aux xs
--   (x:ys)
--   
--   the list of all combinations of n elements of a list. E.g. choose 2
--   [1,2,3] = [[1,2],[1,3],[2,3]]
choose :: Int -> [a] -> [[a]]

-- | build the list of lists each leaving another element out. (From left
--   to right)
leaveOneOut :: [a] -> [[a]]

-- | An element masks another element if the predicate is true. This
--   function keeps only the elements not masked by a previous element in
--   the list.
keepFirst :: (a -> a -> Bool) -> [a] -> [a]

-- | These functions were inspired by the ML library accompanying the
--   Isabelle theorem prover (<a>http://isabelle.in.tum.de/</a>)
--   
--   swap the elements of a pair
swap :: (a, b) -> (b, a)

-- | sort the elements of a pair
sortPair :: Ord a => (a, a) -> (a, a)
isRight :: Either a b -> Bool
isLeft :: Either a b -> Bool

-- | Name values of a given type
type Named a = (String, a)

-- | Extend a list with the given separators to be flushed right.
flushRightBy :: [a] -> Int -> [a] -> [a]

-- | Extend a string with spaces to be flushed right.
flushRight :: Int -> String -> String

-- | Extend a list with the given separators to be flushed left.
flushLeftBy :: [a] -> Int -> [a] -> [a]

-- | Extend a string with spaces to be flushed left.
flushLeft :: Int -> String -> String

-- | marks a string as being a warning
warning :: String -> String

-- | abbreviation to print to stderr
putErr :: String -> IO ()

-- | abbreviation to println to stderr
putErrLn :: String -> IO ()

-- | Inject the elements of a list as alternatives.
oneOfList :: Alternative f => [a] -> f a

-- | Inject the elements of a set as alternatives.
oneOfSet :: Alternative f => Set a -> f a

-- | Inject the elements of a map as alternatives.
oneOfMap :: Alternative f => Map k v -> f (k, v)

-- | A monadic if statement
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | Gather all error free computations.
errorFree :: MonadPlus m => [m a] -> m [a]

-- | Gather all error free computations and ensure that at least one was
--   error free.
errorFree1 :: MonadPlus m => [m a] -> m [a]

-- | Mark a part of the code as unreachable.
unreachable :: String -> a


-- | <a>Document</a> class allowing to have different interpretations of
--   the HughesPJ pretty-printing combinators.
module Text.PrettyPrint.Class
data Doc :: *
class (Monoid d, NFData d) => Document d
char :: Document d => Char -> d
text :: Document d => String -> d
zeroWidthText :: Document d => String -> d
(<->) :: Document d => d -> d -> d
hcat :: Document d => [d] -> d
hsep :: Document d => [d] -> d
($$) :: Document d => d -> d -> d
($-$) :: Document d => d -> d -> d
vcat :: Document d => [d] -> d
sep :: Document d => [d] -> d
cat :: Document d => [d] -> d
fsep :: Document d => [d] -> d
fcat :: Document d => [d] -> d
nest :: Document d => Int -> d -> d
caseEmptyDoc :: Document d => d -> d -> d -> d
isEmpty :: Doc -> Bool
render :: Doc -> String
renderStyle :: Style -> Doc -> String

-- | The default <a>Style</a>.
defaultStyle :: Style
data Style :: *
Style :: Mode -> Int -> Float -> Style
mode :: Style -> Mode
lineLength :: Style -> Int
ribbonsPerLine :: Style -> Float
data Mode :: *
PageMode :: Mode
ZigZagMode :: Mode
LeftMode :: Mode
OneLineMode :: Mode

-- | Vertical concatentation of two documents with an empty line in
--   between.
($--$) :: Document d => d -> d -> d

-- | The empty document.
emptyDoc :: Document d => d
(<>) :: Monoid m => m -> m -> m
semi :: Document d => d
colon :: Document d => d
comma :: Document d => d
space :: Document d => d
equals :: Document d => d
lparen :: Document d => d
rparen :: Document d => d
lbrack :: Document d => d
rbrack :: Document d => d
lbrace :: Document d => d
rbrace :: Document d => d
int :: Document d => Int -> d
integer :: Document d => Integer -> d
float :: Document d => Float -> d
double :: Document d => Double -> d
rational :: Document d => Rational -> d
quotes :: Document d => d -> d
doubleQuotes :: Document d => d -> d
parens :: Document d => d -> d
brackets :: Document d => d -> d
braces :: Document d => d -> d
hang :: Document d => d -> Int -> d -> d
punctuate :: Document d => d -> [d] -> [d]

-- | Nest a document surrounded by a leading and a finishing document
--   breaking lead, body, and finish onto separate lines, if they don't fit
--   on a single line.
nestBetween :: Document d => Int -> d -> d -> d -> d

-- | Nest a document surrounded by a leading and a finishing document with
--   an non-compulsory break between lead and body.
nestShort :: Document d => Int -> d -> d -> d -> d

-- | Nest document between two strings and indent body by <tt>length lead +
--   1</tt>.
nestShort' :: Document d => String -> String -> d -> d

-- | Like <a>nestShort</a> but doesn't print the lead and finish, if the
--   document is empty.
nestShortNonEmpty :: Document d => Int -> d -> d -> d -> d

-- | Like <a>nestShort'</a> but doesn't print the lead and finish, if the
--   document is empty.
nestShortNonEmpty' :: Document d => String -> String -> d -> d

-- | Output text with a fixed width: if it is smaller then nothing happens,
--   otherwise care is taken to make the text appear having the given
--   width.
fixedWidthText :: Document d => Int -> String -> d

-- | Print string as symbol having width 1.
symbol :: Document d => String -> d

-- | Number a list of documents that are vertically separated by the given
--   separator.
numbered :: Document d => d -> [d] -> d

-- | Number a list of documents with numbers terminated by <a>.</a> and
--   vertically separate using an empty line.
numbered' :: Document d => [d] -> d
instance Document Doc
instance NFData Doc


-- | Pretty-printing with support for highlighting keywords and comments.
--   Currently this module is not functional on itself, but geared towards
--   its use in Text.PrettyPrint.Html.
module Text.PrettyPrint.Highlight

-- | Currently we support only keywords, operators, and comments.
data HighlightStyle
Keyword :: HighlightStyle
Comment :: HighlightStyle
Operator :: HighlightStyle
class Document d => HighlightDocument d
highlight :: HighlightDocument d => HighlightStyle -> d -> d
comment :: HighlightDocument d => d -> d
keyword :: HighlightDocument d => d -> d
operator :: HighlightDocument d => d -> d
comment_ :: HighlightDocument d => String -> d
keyword_ :: HighlightDocument d => String -> d
operator_ :: HighlightDocument d => String -> d
opParens :: HighlightDocument d => d -> d
instance Eq HighlightStyle
instance Ord HighlightStyle
instance Show HighlightStyle
instance HighlightDocument Doc


-- | Pretty-printing with support for HTML markup and proper HTML escaping.
module Text.PrettyPrint.Html
class HighlightDocument d => HtmlDocument d
unescapedText :: HtmlDocument d => String -> d
unescapedZeroWidthText :: HtmlDocument d => String -> d

-- | <tt>withTag tag attrs inner</tt> adds the tag <tt>tag</tt> with the
--   attributes <tt>attrs</tt> around the <tt>inner</tt> document.
withTag :: HtmlDocument d => String -> [(String, String)] -> d -> d

-- | <tt>withTagNonEmpty tag attrs inner</tt> adds the tag <tt>tag</tt>
--   with the attributes <tt>attrs</tt> around the <tt>inner</tt> document
--   iff <tt>inner</tt> is a non-empty document.
withTagNonEmpty :: HtmlDocument d => String -> [(String, String)] -> d -> d

-- | <tt>closedTag tag attrs</tt> builds the closed tag <tt>tag</tt> with
--   the attributes <tt>attrs</tt>; e.g.,
--   
--   <pre>
--   closedTag "img" "href" "here" = HtmlDoc (text "&lt;img href=\"here\"/&gt;)
--   </pre>
closedTag :: HtmlDocument d => String -> [(String, String)] -> d

-- | A <a>Document</a> transformer that adds proper HTML escaping.
data HtmlDoc d

-- | Wrap a document such that HTML markup can be added without disturbing
--   the layout.
htmlDoc :: d -> HtmlDoc d
getHtmlDoc :: HtmlDoc d -> d

-- | <tt>postprocessHtmlDoc cs</tt> converts the line-breaks of <tt>cs</tt>
--   to <tt><a>br</a></tt> tags and the prefixed spaces in every line of
--   <tt>cs</tt> by non-breaing HTML spaces <tt>&amp;nbsp;</tt>.
postprocessHtmlDoc :: String -> String

-- | <pre>
--   renderHtmlDoc = <a>postprocessHtmlDoc</a> . <a>render</a> . <a>getHtmlDoc</a>
--   </pre>
renderHtmlDoc :: HtmlDoc Doc -> String

-- | Wrap a document such that all <a>HtmlDocument</a> specific methods are
--   ignored.
noHtmlDoc :: d -> NoHtmlDoc d

-- | Extract the wrapped document.
getNoHtmlDoc :: NoHtmlDoc d -> d
instance Monoid d => Monoid (HtmlDoc d)
instance Functor NoHtmlDoc
instance Applicative NoHtmlDoc
instance Document d => HighlightDocument (NoHtmlDoc d)
instance Document d => HtmlDocument (NoHtmlDoc d)
instance Document d => Document (NoHtmlDoc d)
instance Monoid d => Monoid (NoHtmlDoc d)
instance NFData d => NFData (NoHtmlDoc d)
instance Document d => HighlightDocument (HtmlDoc d)
instance Document d => HtmlDocument (HtmlDoc d)
instance Document d => Document (HtmlDoc d)
instance NFData d => NFData (HtmlDoc d)


-- | Types and instances to handle series of disjunctions and conjunctions.
module Logic.Connectives

-- | A conjunction of atoms of type a.
newtype Conj a
Conj :: [a] -> Conj a
getConj :: Conj a -> [a]

-- | A disjunction of atoms of type a.
newtype Disj a
Disj :: [a] -> Disj a
getDisj :: Disj a -> [a]
instance Typeable1 Conj
instance Typeable1 Disj
instance Monoid (Conj a)
instance Foldable Conj
instance Traversable Conj
instance Eq a => Eq (Conj a)
instance Ord a => Ord (Conj a)
instance Show a => Show (Conj a)
instance Binary a => Binary (Conj a)
instance Functor Conj
instance Applicative Conj
instance Monad Conj
instance MonadPlus Conj
instance Data a => Data (Conj a)
instance NFData a => NFData (Conj a)
instance Monoid (Disj a)
instance Foldable Disj
instance Traversable Disj
instance Eq a => Eq (Disj a)
instance Ord a => Ord (Disj a)
instance Show a => Show (Disj a)
instance Binary a => Binary (Disj a)
instance Functor Disj
instance Applicative Disj
instance Monad Disj
instance MonadPlus Disj
instance Data a => Data (Disj a)
instance NFData a => NFData (Disj a)
instance MonadDisj Disj
