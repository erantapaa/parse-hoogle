-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stream Editor in Haskell
--   
--   A version of sed editor in Haskell based on POSIX <a>The Open Group
--   Base Specifications Issue 7</a> IEEE Std 1003.1-2008.
--   
--   For the library usage check Hsed.Sed module and for the program usage
--   take a look in the attached README file
@package Hsed
@version 0.2.2


module Hsed.SedRegex
type Pattern = ByteString

-- | Replaces every occurance of the given regexp with the replacement
--   string. Modification of the subRegex function from regex-posix
--   package.
sedSubRegex :: ByteString -> ByteString -> ByteString -> Int -> (ByteString, Bool)


-- | The main types used in the program
module Hsed.Ast

-- | Editing commands
data SedCmd
SedCmd :: Address -> SedFun -> SedCmd

-- | Functions represents a single-character command verb
data SedFun

-- | { - group of the sed commands
Group :: [SedCmd] -> SedFun

-- | = - write to standard output the current line number
LineNum :: SedFun

-- | a - append text following each line matched by address
Append :: Text -> SedFun

-- | b - transfer control to Label
Branch :: (Maybe Label) -> SedFun

-- | c - replace the lines selected by the address with Text
Change :: Text -> SedFun

-- | d - delete line(s) from pattern space
DeleteLine :: SedFun

-- | D - delete (up to newline) of multiline pattern space
DeletePat :: SedFun

-- | g - copy hold space into the pattern space
ReplacePat :: SedFun

-- | G - add newline followed by hold space into the pattern space
AppendPat :: SedFun

-- | h - copy pattern space into hold space
ReplaceHold :: SedFun

-- | H - add newline followed by pattern space into the hold space
AppendHold :: SedFun

-- | i - insert Text before each line matched by address
Insert :: Text -> SedFun

-- | l - list the pattern space, showing non-printing chars in ASCII
List :: SedFun

-- | n - read next line of input into pattern space
NextLine :: SedFun

-- | N - add next input line and newline into pattern space
AppendLinePat :: SedFun

-- | p - print the addressed line(s)
PrintPat :: SedFun

-- | P - print (up to newline) of multiline pattern space
WriteUpPat :: SedFun

-- | q - quit when address is encounterd
Quit :: SedFun

-- | r - add contents of file to the pattern space
ReadFile :: FilePath -> SedFun

-- | s - substitute Replacement for Pattern
Substitute :: Pattern -> Replacement -> Flags -> SedFun

-- | t - branch to line marked by :label if substitution was made
Test :: (Maybe Label) -> SedFun

-- | w - write the line to file if a replacement was done
WriteFile :: FilePath -> SedFun

-- | x - exchange pattern space with hold space
Exchange :: SedFun

-- | y - transform each char by position in Text to Text
Transform :: Text -> Text -> SedFun

-- | : - label a line in the scipt for transfering by b or t.
Label :: Label -> SedFun

-- | n" in the first line
Comment :: SedFun

-- | <ul>
--   <li>ignore spaces</li>
--   </ul>
EmptyCmd :: SedFun

-- | An address is either a decimal number that counts input lines
--   cumulatively across files, a <a>$</a> character that addresses the
--   last line of input, or a context address as BRE
data Addr
LineNumber :: Int -> Addr
LastLine :: Addr
Pat :: Pattern -> Addr

-- | A permissable address is representing by zero, one or two addresses
data Address
Address :: (Maybe Addr) -> (Maybe Addr) -> Invert -> Address

-- | Used in the replacement string. An appersand (<tt>&amp;</tt>) will be
--   replaced by the string matched the BRE. The characters <a>n</a>, where
--   n is a digit will be replaced by the corresponding back-reference
--   expression.
data Occurrence
Replace :: Int -> Occurrence
ReplaceAll :: Occurrence

-- | The flag to control the pattern space output in the substitute
--   function
type OutputPat = Bool

-- | The allowed sequence of the Occurrence and OutputPat flags in the
--   substitute function
data OccurrencePrint
OccurrencePrint :: (Maybe Occurrence) -> OutputPat -> OccurrencePrint
PrintOccurrence :: OutputPat -> (Maybe Occurrence) -> OccurrencePrint

-- | Flags used in the substitute command
data Flags
Flags :: (Maybe OccurrencePrint) -> (Maybe FilePath) -> Flags
type Replacement = ByteString
type Invert = Bool
type Text = ByteString
type Label = ByteString
instance Show Addr
instance Show Occurrence
instance Show OccurrencePrint
instance Show Flags
instance Show Address
instance Show SedFun
instance Show SedCmd


-- | Sed commands parser. See <a>The Open Group Base Specifications Issue
--   7</a> for parsing requirements. The current version of the Haskell Sed
--   doesn't supports the back-references in the RE.
module Hsed.Parsec

-- | If an RE is empty last RE used in the last command applied
data ParserState
ParserState :: Pattern -> ParserState
lastRE :: ParserState -> Pattern
type SedParser = GenParser Char ParserState
type Stream = String
parseSed :: SedParser a -> Stream -> Either ParseError a
parseRE :: String -> SedParser Pattern
address :: SedParser Address
sedCmds :: SedParser [SedCmd]
sedCmd :: SedParser SedCmd
sedFun :: SedParser SedFun
bareFun :: Char -> SedFun -> SedParser SedFun
textFun :: Char -> (Text -> SedFun) -> SedParser SedFun
fileFun :: Char -> (FilePath -> SedFun) -> SedParser SedFun
argFun :: Char -> (ByteString -> SedFun) -> SedParser SedFun
gotoFun :: Char -> (Maybe Label -> SedFun) -> SedParser SedFun


-- | The state of the program
module Hsed.SedState
data Env
Env :: [SedCmd] -> !Bool -> !Int -> !Int -> !Bool -> !ByteString -> !ByteString -> [ByteString] -> !ByteString -> !Bool -> !Bool -> [(FilePath, Handle)] -> !Bool -> (Handle, Bool) -> Env

-- | Parsed Sed commands
ast_ :: Env -> [SedCmd]

-- | Suppress the default output
defOutput_ :: Env -> !Bool

-- | The last line index
lastLine_ :: Env -> !Int

-- | The current line index
curLine_ :: Env -> !Int

-- | Is pattern space matches the address range
inRange_ :: Env -> !Bool

-- | The buffer to keep the selected line(s)
patternSpace_ :: Env -> !ByteString

-- | The buffer to keep the line(s) temporarily
holdSpace_ :: Env -> !ByteString

-- | The buffer to keep the append lines
appendSpace_ :: Env -> [ByteString]

-- | Store the output in the memory
memorySpace_ :: Env -> !ByteString

-- | If True the Sed output is stored in the memory buffer
useMemSpace_ :: Env -> !Bool

-- | Exit the stream editor
exit_ :: Env -> !Bool

-- | Write (w command) files handles
fileout_ :: Env -> [(FilePath, Handle)]

-- | The result of the last substitution
subst_ :: Env -> !Bool

-- | Current input file handle
curFile_ :: Env -> (Handle, Bool)
curFile :: T Env (Handle, Bool)
subst :: T Env Bool
fileout :: T Env [(FilePath, Handle)]
exit :: T Env Bool
useMemSpace :: T Env Bool
memorySpace :: T Env ByteString
appendSpace :: T Env [ByteString]
holdSpace :: T Env ByteString
patternSpace :: T Env ByteString
inRange :: T Env Bool
curLine :: T Env Int
lastLine :: T Env Int
defOutput :: T Env Bool
ast :: T Env [SedCmd]
type SedState = StateT Env IO
initEnv :: Env
set :: T Env a -> a -> SedState ()
get :: T Env a -> SedState a
modify :: T Env a -> (a -> a) -> SedState ()
instance Show Env


-- | The Sed runtime engine
module Hsed.StreamEd
type SedEngine a = GotoT a (StateT Env IO) a
data Status
EOF :: Status
Cont :: Status
data FlowControl

-- | Apply the next sed command from the script to the pattern space
Next :: FlowControl

-- | Read the new line to the pattern space and apply sed script
Break :: FlowControl

-- | Reapply the sed script to the current pattern space
Continue :: FlowControl

-- | Jump to the marked sed command and apply it to the pattern space
Goto :: (Maybe ByteString) -> FlowControl

-- | Quit
Exit :: FlowControl

-- | Compile and execute the sed script
runSed :: [FilePath] -> String -> Env -> IO Env

-- | Parse the Sed commands
compile :: String -> SedState ()

-- | Execute the parsed Sed commands against input data
execute :: [FilePath] -> SedEngine ()

-- | Process the input text files
processFiles :: [FilePath] -> SedEngine ()

-- | Process the next input line from the file
nextLine :: SedEngine ()

-- | Execute sed script
execCmds :: [SedCmd] -> SedEngine ()

-- | Transfer control to the command marked with the label
jump :: [SedCmd] -> Maybe Label -> [SedCmd]

-- | Read an input line
line :: SedState (Status, ByteString)

-- | Execute the Sed function if the address is matched
execCmd :: SedCmd -> SedState FlowControl

-- | Check if the address interval is matched
matchAddress :: Address -> SedState Bool

-- | Execute the Sed function
runCmd :: SedFun -> SedState FlowControl

-- | '{cmd...}' Groups subcommands enclosed in {} (braces)
group :: [SedCmd] -> SedState FlowControl

-- | '=' Writes the current line number to standard output as a line
lineNum :: SedState FlowControl

-- | 'a\\ntext' Places the text variable in output before reading the next
--   input line
append :: ByteString -> SedState FlowControl

-- | 'b label' Transfer control to :label elsewhere in script
branch :: Maybe Label -> SedState FlowControl

-- | 'c\\ntext' Replace the lines with the text variable
change :: ByteString -> SedState FlowControl

-- | <tt>d</tt> Delete line(s) from pattern space
deleteLine :: SedState FlowControl

-- | <tt>D</tt> Delete first part (up to embedded newline) of multiline
--   pattern space
deletePat :: SedState FlowControl

-- | <tt>g</tt> Copy contents of hold space into the pattern space
replacePat :: SedState FlowControl

-- | <tt>G</tt> Append newline followed by contents of hold space to
--   contents of the pattern space.
appendPat :: SedState FlowControl

-- | <tt>h</tt> Copy pattern space into hold space
replaceHold :: SedState FlowControl

-- | <tt>H</tt> Append newline and contents of pattern space to contents of
--   the hold space
appendHold :: SedState FlowControl

-- | 'i\\ntext' Writes the text variable to standard output before reading
--   the next line into the pattern space.
insert :: ByteString -> SedState FlowControl

-- | 't label' Jump to line if successful substitutions have been made
test :: Maybe Label -> SedState FlowControl

-- | 's<i>pattern</i>replacement/[flags]' Substitute replacement for
--   pattern
substitute :: ByteString -> ByteString -> Flags -> SedState FlowControl

-- | <tt>n</tt> Read next line of input into pattern space.
next :: SedState FlowControl

-- | <tt>l</tt> List the contents of the pattern space, showing nonprinting
--   characters as ASCII codes
list :: SedState FlowControl

-- | <tt>x</tt> Exchange contents of the pattern space with the contents of
--   the hold space
exchange :: SedState FlowControl

-- | <tt>N</tt> Append next input line to contents of pattern space
appendLinePat :: SedState FlowControl

-- | <tt>p</tt> Print the lines
printPat :: SedState FlowControl

-- | <tt>P</tt> Print first part (up to embedded newline) of multiline
--   pattern space
writeUpPat :: SedState FlowControl

-- | <tt>q</tt> Quit
quit :: SedState FlowControl

-- | 'y/abc/xyz' Transform each character by position in string abc to its
--   equivalent in string xyz
transform :: ByteString -> ByteString -> SedState FlowControl

-- | 'w file' Append contents of pattern space to file
writeF :: FilePath -> SedState FlowControl

-- | <tt>r</tt> Read contents of file and append after the contents of the
--   pattern space
readF :: FilePath -> SedState FlowControl

-- | Skip label, comment and empty command
--   
--   Print the pattern space to the standard output
printPatSpace :: SedState ()

-- | Check if the current line in the pattern space is the last line
isLastLine :: SedState Bool

-- | Writes the string to the standard output or save the string in the
--   memory buffer
prnStr :: ByteString -> SedState ()

-- | The same as prnStr, but adds a newline character
prnStrLn :: ByteString -> SedState ()

-- | The same as prnStr, but for char
prnChar :: Char -> SedState ()

-- | Print the character as three-digit octal number
prnPrintf :: Char -> SedState ()
instance Eq Status
instance Show Status
instance Eq FlowControl
instance Show FlowControl


-- | This module provides functions to execute the sed script. See
--   <a>execScript</a> below for an example
module Hsed.Sed

-- | Execute the sed script and print the output to ByteString. Example.
--   Suppose the ..<i>tests</i>Transform.in file contains the line 'Hello
--   world!'. execScript ["..<i>tests</i>Transform.in"]
--   "y<i>abcdefghijklmnopqrstuvwxyz</i>ABCDEFGHIJKLMNOPQRSTUVWXYZ/" will
--   produce 'HELLO WORLD!' bytestring.
execScript :: [FilePath] -> SedScript -> IO ByteString

-- | Execute the sed script and print the result to stdout
execScript_ :: [FilePath] -> SedScript -> IO ()
type SedScript = String
