-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient half-integer type.
--   
--   This Haskell library is a simple implementation of
--   <i>half-integers</i>. That is, it provides a type that can represent
--   both normal integers and integers plus a half. Changes: * Fixed
--   documentation glitches. * Added Integral contexts to some functions.
@package AC-HalfInteger
@version 1.2.1


-- | This module provides efficient <i>half-integers</i>. That is, normal
--   integers and integers plus or minus 1/2. These are sometimes useful
--   for when a value can be an integer, or midway between two integers.
module Data.HalfInteger

-- | The type of half-integers. The bounds are determined by the type
--   variable. For example, <tt>HalfInteger Int</tt> has a range half as
--   large as <tt>Int</tt> itself. (The <tt>Bounded</tt> instance correctly
--   reflects this.) Note that <tt>HalfInteger Integer</tt> is unbounded,
--   like <tt>Integer</tt> itself.
--   
--   <tt>HalfInteger</tt> values can be constructed as numeric literals
--   (e.g., <tt>5 :: HalfInteger Int</tt>), by conversions such as
--   <tt>fromInteger</tt> or <tt>fromIntegral</tt>, or by several functions
--   in this module. Another common pattern is to write (say) <tt>5 +
--   half</tt> to represent 5 1/2. Indeed, the <tt>Show</tt> instance
--   represents values in this way.
--   
--   Beware: The half-integers are <i>not</i> closed under multiplication!
--   For example, <tt>half * half</tt> should yield 1/4, which is not a
--   valid <tt>HalfInteger</tt>. (Currently it yields zero.) Addition and
--   subtraction, however, <i>are</i> closed, and thus yield exact results.
data HalfInteger i

-- | Represents 1/2 as a <tt>HalfInteger</tt>. You can add this to integral
--   <tt>HalfInteger</tt> values created in various ways to get the
--   half-part in.
half :: Integral i => HalfInteger i

-- | Take an integer and halve its value, yielding a <tt>HalfInteger</tt>.
--   This conversion is always exact, and <tt>halve . double == id</tt>.
halve :: Integral i => i -> HalfInteger i

-- | Take a <tt>HalfInteger</tt> and double its value, yielding a normal
--   integer. This conversion is always exact, and <tt>double . halve ==
--   id</tt>.
double :: HalfInteger i -> i

-- | Convert any number into a <tt>HalfInteger</tt>. The rounding is
--   somewhat unpredictable, but any value exactly representable as a half
--   integer will be converted exactly.
toHalfInteger :: (RealFrac x, Integral i) => x -> HalfInteger i

-- | Convert a <tt>HalfInteger</tt> into some other kind of number. This
--   conversion is always exact.
fromHalfInteger :: (Integral i, Fractional x) => HalfInteger i -> x

-- | Returns <tt>True</tt> if this <tt>HalfInteger</tt> can be exactly
--   represented as an ordinary integer, and <tt>False</tt> if there is a
--   half offset.
isInteger :: Integral i => HalfInteger i -> Bool
instance Integral i => Num (HalfInteger i)
instance Integral i => Show (HalfInteger i)
instance Bounded i => Bounded (HalfInteger i)
instance Ord i => Ord (HalfInteger i)
instance Eq i => Eq (HalfInteger i)
