-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Painless 2D vector graphics, animations and simulations.
--   
@package gloss
@version 1.9.2.1


-- | Geometric functions concerning angles. If not otherwise specified, all
--   angles are in radians.
module Graphics.Gloss.Geometry.Angle

-- | Convert degrees to radians
degToRad :: Float -> Float

-- | Convert radians to degrees
radToDeg :: Float -> Float

-- | Normalize an angle to be between 0 and 2*pi radians
normalizeAngle :: Float -> Float

module Graphics.Gloss.Data.Display

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen with a drawing area of the given size.
FullScreen :: (Int, Int) -> Display
instance Eq Display
instance Read Display
instance Show Display


-- | Functions to load bitmap data from various places.
module Graphics.Gloss.Data.Bitmap

-- | Abstract 32-bit RGBA bitmap data.
data BitmapData :: *

-- | O(1). Use a <a>ForeignPtr</a> of RGBA data as a bitmap with the given
--   width and height.
bitmapOfForeignPtr :: Int -> Int -> ForeignPtr Word8 -> Bool -> Picture

-- | O(size). Copy a <a>ByteString</a> of RGBA data into a bitmap with the
--   given width and height.
--   
--   The boolean flag controls whether Gloss should cache the data between
--   frames for speed. If you are programatically generating the image for
--   each frame then use <a>False</a>. If you have loaded it from a file
--   then use <a>True</a>.
bitmapOfByteString :: Int -> Int -> ByteString -> Bool -> Picture

-- | O(size). Copy a <a>BMP</a> file into a bitmap.
bitmapOfBMP :: BMP -> Picture

-- | Load an uncompressed 24 or 32bit RGBA BMP file as a bitmap.
loadBMP :: FilePath -> IO Picture


-- | Predefined and custom colors.
module Graphics.Gloss.Data.Color

-- | An abstract color value. We keep the type abstract so we can be sure
--   that the components are in the required range. To make a custom color
--   use <a>makeColor</a>.
data Color :: *

-- | Make a custom color. All components are clamped to the range [0..1].
makeColor :: Float -> Float -> Float -> Float -> Color

-- | Make a custom color. All components are clamped to the range [0..255].
makeColorI :: Int -> Int -> Int -> Int -> Color

-- | Take the RGBA components of a color.
rgbaOfColor :: Color -> (Float, Float, Float, Float)

-- | Mix two colors with the given ratios.
mixColors :: Float -> Float -> Color -> Color -> Color

-- | Add RGB components of a color component-wise, then normalise them to
--   the highest resulting one. The alpha components are averaged.
addColors :: Color -> Color -> Color

-- | Make a dimmer version of a color, scaling towards black.
dim :: Color -> Color

-- | Make a brighter version of a color, scaling towards white.
bright :: Color -> Color

-- | Lighten a color, adding white.
light :: Color -> Color

-- | Darken a color, adding black.
dark :: Color -> Color

-- | A greyness of a given order.
greyN :: Float -> Color
black :: Color
white :: Color
red :: Color
green :: Color
blue :: Color
yellow :: Color
cyan :: Color
magenta :: Color
rose :: Color
violet :: Color
azure :: Color
aquamarine :: Color
chartreuse :: Color
orange :: Color

module Graphics.Gloss.Data.Picture

-- | A 2D picture
data Picture :: *

-- | A blank picture, with nothing in it.
Blank :: Picture

-- | A convex polygon filled with a solid color.
Polygon :: Path -> Picture

-- | A line along an arbitrary path.
Line :: Path -> Picture

-- | A circle with the given radius.
Circle :: Float -> Picture

-- | A circle with the given thickness and radius. If the thickness is 0
--   then this is equivalent to <a>Circle</a>.
ThickCircle :: Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in degrees)
--   at the given radius.
Arc :: Float -> Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in
--   degrees), with the given radius and thickness. If the thickness is 0
--   then this is equivalent to <a>Arc</a>.
ThickArc :: Float -> Float -> Float -> Float -> Picture

-- | Some text to draw with a vector font.
Text :: String -> Picture

-- | A bitmap image with a width, height and some 32-bit RGBA bitmap data.
--   
--   The boolean flag controls whether Gloss should cache the data between
--   frames for speed. If you are programatically generating the image for
--   each frame then use <a>False</a>. If you have loaded it from a file
--   then use <a>True</a>.
Bitmap :: Int -> Int -> BitmapData -> Bool -> Picture

-- | A picture drawn with this color.
Color :: Color -> Picture -> Picture

-- | A picture translated by the given x and y coordinates.
Translate :: Float -> Float -> Picture -> Picture

-- | A picture rotated clockwise by the given angle (in degrees).
Rotate :: Float -> Picture -> Picture

-- | A picture scaled by the given x and y factors.
Scale :: Float -> Float -> Picture -> Picture

-- | A picture consisting of several others.
Pictures :: [Picture] -> Picture

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | A vector can be treated as a point, and vis-versa.
type Vector = Point

-- | A path through the x-y plane.
type Path = [Point]

-- | A blank picture, with nothing in it.
blank :: Picture

-- | A convex polygon filled with a solid color.
polygon :: Path -> Picture

-- | A line along an arbitrary path.
line :: Path -> Picture

-- | A circle with the given radius.
circle :: Float -> Picture

-- | A circle with the given thickness and radius. If the thickness is 0
--   then this is equivalent to <a>Circle</a>.
thickCircle :: Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in degrees)
--   at the given radius.
arc :: Float -> Float -> Float -> Picture

-- | A circular arc drawn counter-clockwise between two angles (in
--   degrees), with the given radius and thickness. If the thickness is 0
--   then this is equivalent to <a>Arc</a>.
thickArc :: Float -> Float -> Float -> Float -> Picture

-- | Some text to draw with a vector font.
text :: String -> Picture

-- | A bitmap image with a width, height and a Vector holding the 32-bit
--   RGBA bitmap data.
--   
--   The boolean flag controls whether Gloss should cache the data between
--   frames for speed. If you are programatically generating the image for
--   each frame then use <a>False</a>. If you have loaded it from a file
--   then use <a>True</a>.
bitmap :: Int -> Int -> BitmapData -> Bool -> Picture

-- | A picture drawn with this color.
color :: Color -> Picture -> Picture

-- | A picture translated by the given x and y coordinates.
translate :: Float -> Float -> Picture -> Picture

-- | A picture rotated clockwise by the given angle (in degrees).
rotate :: Float -> Picture -> Picture

-- | A picture scaled by the given x and y factors.
scale :: Float -> Float -> Picture -> Picture

-- | A picture consisting of several others.
pictures :: [Picture] -> Picture

-- | A closed loop along a path.
lineLoop :: Path -> Picture

-- | A solid circle with the given radius.
circleSolid :: Float -> Picture

-- | A solid arc, drawn counter-clockwise between two angles at the given
--   radius.
arcSolid :: Float -> Float -> Float -> Picture

-- | A wireframe sector of a circle. An arc is draw counter-clockwise from
--   the first to the second angle at the given radius. Lines are drawn
--   from the origin to the ends of the arc.
sectorWire :: Float -> Float -> Float -> Picture

-- | A path representing a rectangle centered about the origin
rectanglePath :: Float -> Float -> Path

-- | A wireframe rectangle centered about the origin.
rectangleWire :: Float -> Float -> Picture

-- | A solid rectangle centered about the origin.
rectangleSolid :: Float -> Float -> Picture

-- | A path representing a rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperPath :: Float -> Float -> Path

-- | A wireframe rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperWire :: Float -> Float -> Picture

-- | A solid rectangle in the y &gt; 0 half of the x-y plane.
rectangleUpperSolid :: Float -> Float -> Picture

module Graphics.Gloss.Data.Point

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | A path through the x-y plane.
type Path = [Point]

-- | Test whether a point lies within a rectangular box that is oriented on
--   the x-y plane. The points P1-P2 are opposing points of the box, but
--   need not be in a particular order.
--   
--   <pre>
--   P2 +-------+
--      |       |
--      | + P0  |
--      |       |
--      +-------+ P1
--   </pre>
pointInBox :: Point -> Point -> Point -> Bool


-- | Geometric functions concerning vectors.
module Graphics.Gloss.Data.Vector

-- | A vector can be treated as a point, and vis-versa.
type Vector = Point

-- | The magnitude of a vector.
magV :: Vector -> Float

-- | The angle of this vector, relative to the +ve x-axis.
argV :: Vector -> Float

-- | The dot product of two vectors.
dotV :: Vector -> Vector -> Float

-- | The determinant of two vectors.
detV :: Vector -> Vector -> Float

-- | Multiply a vector by a scalar.
mulSV :: Float -> Vector -> Vector

-- | Rotate a vector by an angle (in radians). +ve angle is
--   counter-clockwise.
rotateV :: Float -> Vector -> Vector

-- | Compute the inner angle (in radians) between two vectors.
angleVV :: Vector -> Vector -> Float

-- | Normalise a vector, so it has a magnitude of 1.
normalizeV :: Vector -> Vector

-- | Produce a unit vector at a given angle relative to the +ve x-axis. The
--   provided angle is in radians.
unitVectorAtAngle :: Float -> Vector


-- | Geometric functions concerning lines and segments.
--   
--   A <tt>Line</tt> is taken to be infinite in length, while a
--   <tt>Seg</tt> is finite length line segment represented by its two
--   endpoints.
module Graphics.Gloss.Geometry.Line

-- | Check if line segment (P1-P2) clears a box (P3-P4) by being well
--   outside it.
segClearsBox :: Point -> Point -> Point -> Point -> Bool

-- | Given an infinite line which intersects <tt>P1</tt> and <tt>P1</tt>,
--   return the point on that line that is closest to <tt>P3</tt>
closestPointOnLine :: Point -> Point -> Point -> Point

-- | Given an infinite line which intersects P1 and P2, let P4 be the point
--   on the line that is closest to P3.
--   
--   Return an indication of where on the line P4 is relative to P1 and P2.
--   
--   <pre>
--   if P4 == P1 then 0
--   if P4 == P2 then 1
--   if P4 is halfway between P1 and P2 then 0.5
--   </pre>
--   
--   <pre>
--      |
--     P1
--      | 
--   P4 +---- P3      
--      |
--     P2
--      |
--   </pre>
closestPointOnLineParam :: Point -> Point -> Point -> Float

-- | Given four points specifying two lines, get the point where the two
--   lines cross, if any. Note that the lines extend off to infinity, so
--   the intersection point might not line between either of the two pairs
--   of points.
--   
--   <pre>
--   \      /
--    P1  P4
--     \ /
--      +
--     / \
--    P3  P2
--   /     \
--   </pre>
intersectLineLine :: Point -> Point -> Point -> Point -> Maybe Point

-- | Get the point where a segment <tt>P1-P2</tt> crosses an infinite line
--   <tt>P3-P4</tt>, if any.
intersectSegLine :: Point -> Point -> Point -> Point -> Maybe Point

-- | Get the point where a segment crosses a horizontal line, if any.
--   
--   <pre>
--            + P1
--           /
--   -------+---------
--         /        y0
--     P2 +
--   </pre>
intersectSegHorzLine :: Point -> Point -> Float -> Maybe Point

-- | Get the point where a segment crosses a vertical line, if any.
--   
--   <pre>
--          |
--          |   + P1
--          | /
--          +
--        / |
--   P2 +   |
--          | x0
--   </pre>
intersectSegVertLine :: Point -> Point -> Float -> Maybe Point

-- | Get the point where a segment <tt>P1-P2</tt> crosses another segement
--   <tt>P3-P4</tt>, if any.
intersectSegSeg :: Point -> Point -> Point -> Point -> Maybe Point

-- | Check if an arbitrary segment intersects a horizontal segment.
--   
--   <pre>
--                   + P2
--                  /
--   (xa, y3)  +---+----+ (xb, y3)
--                /
--            P1 +
--   </pre>
intersectSegHorzSeg :: Point -> Point -> Float -> Float -> Float -> Maybe Point

-- | Check if an arbitrary segment intersects a vertical segment.
--   
--   <pre>
--   (x3, yb) +
--            |   + P1
--            | /
--            +
--          / |
--     P2 +   |
--            + (x3, ya)
--   </pre>
intersectSegVertSeg :: Point -> Point -> Float -> Float -> Float -> Maybe Point

module Graphics.Gloss.Data.ViewPort

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
viewPortTranslate :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
viewPortRotate :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
viewPortScale :: ViewPort -> !Float

-- | The initial state of the viewport.
viewPortInit :: ViewPort

-- | Translates, rotates, and scales an image according to the
--   <a>ViewPort</a>.
applyViewPortToPicture :: ViewPort -> Picture -> Picture

-- | Takes a point using screen coordinates, and uses the <a>ViewPort</a>
--   to convert it to Picture coordinates. This is the inverse of
--   <a>applyViewPortToPicture</a> for points.
invertViewPort :: ViewPort -> Point -> Point

module Graphics.Gloss.Data.ViewState

-- | The commands suported by the view controller.
data Command
CRestore :: Command
CTranslate :: Command
CRotate :: Command
CBumpZoomOut :: Command
CBumpZoomIn :: Command
CBumpLeft :: Command
CBumpRight :: Command
CBumpUp :: Command
CBumpDown :: Command
CBumpClockwise :: Command
CBumpCClockwise :: Command
type CommandConfig = [(Command, [(Key, Maybe Modifiers)])]

-- | The default commands. Left click pans, wheel zooms, right click
--   rotates, "r" key resets.
defaultCommandConfig :: CommandConfig

-- | State for controlling the viewport. These are used by the viewport
--   control component.
data ViewState
ViewState :: !(Map Command [(Key, Maybe Modifiers)]) -> !Float -> !Float -> !(Maybe (Float, Float)) -> !(Maybe (Float, Float)) -> ViewPort -> ViewState

-- | The command list for the viewport controller. These can be safely
--   overwridden at any time by deleting or adding entries to the list.
--   Entries at the front of the list take precedence.
viewStateCommands :: ViewState -> !(Map Command [(Key, Maybe Modifiers)])

-- | How much to scale the world by for each step of the mouse wheel.
viewStateScaleStep :: ViewState -> !Float

-- | How many degrees to rotate the world by for each pixel of x motion.
viewStateRotateFactor :: ViewState -> !Float

-- | During viewport translation, where the mouse was clicked on the
--   window.
viewStateTranslateMark :: ViewState -> !(Maybe (Float, Float))

-- | During viewport rotation, where the mouse was clicked on the window
viewStateRotateMark :: ViewState -> !(Maybe (Float, Float))
viewStateViewPort :: ViewState -> ViewPort

-- | The initial view state.
viewStateInit :: ViewState

-- | Initial view state, with user defined config.
viewStateInitWithConfig :: CommandConfig -> ViewState

-- | Apply an event to a <a>ViewState</a>.
updateViewStateWithEvent :: Event -> ViewState -> ViewState

-- | Like <a>updateViewStateWithEvent</a>, but returns <a>Nothing</a> if no
--   update was needed.
updateViewStateWithEventMaybe :: Event -> ViewState -> Maybe ViewState
instance Show Command
instance Eq Command
instance Ord Command


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.Pure.Display

-- | Open a new window and display the given picture.
--   
--   Use the following commands once the window is open:
--   
--   <ul>
--   <li>Quit - esc-key.</li>
--   <li>Move Viewport - left-click drag, arrow keys.</li>
--   <li>Rotate Viewport - right-click drag, control-left-click drag, or
--   home/end-keys.</li>
--   <li>Zoom Viewport - mouse wheel, or page up/down-keys.</li>
--   </ul>
display :: Display -> Color -> Picture -> IO ()


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.Pure.Animate

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animate :: Display -> Color -> (Float -> Picture) -> IO ()


-- | Simulate mode is for producing an animation of some model who's
--   picture changes over finite time steps. The behavior of the model can
--   also depent on the current <a>ViewPort</a>.
module Graphics.Gloss.Interface.Pure.Simulate

-- | Run a finite-time-step simulation in a window. You decide how the
--   model is represented, how to convert the model to a picture, and how
--   to advance the model for each unit of time. This function does the
--   rest.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
simulate :: Display -> Color -> Int -> model -> (model -> Picture) -> (ViewPort -> Float -> model -> model) -> IO ()

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
viewPortTranslate :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
viewPortRotate :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
viewPortScale :: ViewPort -> !Float


-- | This game mode lets you manage your own input. Pressing ESC will still
--   abort the program, but you don't get automatic pan and zoom controls
--   like with <tt>displayInWindow</tt>.
module Graphics.Gloss.Interface.Pure.Game

-- | Play a game in a window. Like <tt>simulate</tt>, but you manage your
--   own input events.
play :: Display -> Color -> Int -> world -> (world -> Picture) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()

-- | Possible input events.
data Event
EventKey :: Key -> KeyState -> Modifiers -> (Float, Float) -> Event
EventMotion :: (Float, Float) -> Event
EventResize :: (Int, Int) -> Event
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key
data SpecialKey
KeyUnknown :: SpecialKey
KeySpace :: SpecialKey
KeyEsc :: SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyF13 :: SpecialKey
KeyF14 :: SpecialKey
KeyF15 :: SpecialKey
KeyF16 :: SpecialKey
KeyF17 :: SpecialKey
KeyF18 :: SpecialKey
KeyF19 :: SpecialKey
KeyF20 :: SpecialKey
KeyF21 :: SpecialKey
KeyF22 :: SpecialKey
KeyF23 :: SpecialKey
KeyF24 :: SpecialKey
KeyF25 :: SpecialKey
KeyUp :: SpecialKey
KeyDown :: SpecialKey
KeyLeft :: SpecialKey
KeyRight :: SpecialKey
KeyTab :: SpecialKey
KeyEnter :: SpecialKey
KeyBackspace :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey
KeyPad0 :: SpecialKey
KeyPad1 :: SpecialKey
KeyPad2 :: SpecialKey
KeyPad3 :: SpecialKey
KeyPad4 :: SpecialKey
KeyPad5 :: SpecialKey
KeyPad6 :: SpecialKey
KeyPad7 :: SpecialKey
KeyPad8 :: SpecialKey
KeyPad9 :: SpecialKey
KeyPadDivide :: SpecialKey
KeyPadMultiply :: SpecialKey
KeyPadSubtract :: SpecialKey
KeyPadAdd :: SpecialKey
KeyPadDecimal :: SpecialKey
KeyPadEqual :: SpecialKey
KeyPadEnter :: SpecialKey
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton
data KeyState
Down :: KeyState
Up :: KeyState
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
shift :: Modifiers -> KeyState
ctrl :: Modifiers -> KeyState
alt :: Modifiers -> KeyState


-- | Display mode is for drawing a static picture.
module Graphics.Gloss.Interface.IO.Animate

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animateIO :: Display -> Color -> (Float -> IO Picture) -> IO ()

-- | Like <a>animateIO</a> but don't allow the display to be panned around.
animateFixedIO :: Display -> Color -> (Float -> IO Picture) -> IO ()


-- | Simulate mode is for producing an animation of some model who's
--   picture changes over finite time steps. The behavior of the model can
--   also depent on the current <a>ViewPort</a>.
module Graphics.Gloss.Interface.IO.Simulate
simulateIO :: Display -> Color -> Int -> model -> (model -> IO Picture) -> (ViewPort -> Float -> model -> IO model) -> IO ()

-- | The <a>ViewPort</a> represents the global transformation applied to
--   the displayed picture. When the user pans, zooms, or rotates the
--   display then this changes the <a>ViewPort</a>.
data ViewPort
ViewPort :: !(Float, Float) -> !Float -> !Float -> ViewPort

-- | Global translation.
viewPortTranslate :: ViewPort -> !(Float, Float)

-- | Global rotation (in degrees).
viewPortRotate :: ViewPort -> !Float

-- | Global scaling (of both x and y coordinates).
viewPortScale :: ViewPort -> !Float


-- | This game mode lets you manage your own input. Pressing ESC will not
--   abort the program. You also don't get automatic pan and zoom controls
--   like with <tt>displayInWindow</tt>.
module Graphics.Gloss.Interface.IO.Game

-- | Play a game in a window, using IO actions to build the pictures.
playIO :: Display -> Color -> Int -> world -> (world -> IO Picture) -> (Event -> world -> IO world) -> (Float -> world -> IO world) -> IO ()

-- | Possible input events.
data Event
EventKey :: Key -> KeyState -> Modifiers -> (Float, Float) -> Event
EventMotion :: (Float, Float) -> Event
EventResize :: (Int, Int) -> Event
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key
data SpecialKey
KeyUnknown :: SpecialKey
KeySpace :: SpecialKey
KeyEsc :: SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyF13 :: SpecialKey
KeyF14 :: SpecialKey
KeyF15 :: SpecialKey
KeyF16 :: SpecialKey
KeyF17 :: SpecialKey
KeyF18 :: SpecialKey
KeyF19 :: SpecialKey
KeyF20 :: SpecialKey
KeyF21 :: SpecialKey
KeyF22 :: SpecialKey
KeyF23 :: SpecialKey
KeyF24 :: SpecialKey
KeyF25 :: SpecialKey
KeyUp :: SpecialKey
KeyDown :: SpecialKey
KeyLeft :: SpecialKey
KeyRight :: SpecialKey
KeyTab :: SpecialKey
KeyEnter :: SpecialKey
KeyBackspace :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey
KeyPad0 :: SpecialKey
KeyPad1 :: SpecialKey
KeyPad2 :: SpecialKey
KeyPad3 :: SpecialKey
KeyPad4 :: SpecialKey
KeyPad5 :: SpecialKey
KeyPad6 :: SpecialKey
KeyPad7 :: SpecialKey
KeyPad8 :: SpecialKey
KeyPad9 :: SpecialKey
KeyPadDivide :: SpecialKey
KeyPadMultiply :: SpecialKey
KeyPadSubtract :: SpecialKey
KeyPadAdd :: SpecialKey
KeyPadDecimal :: SpecialKey
KeyPadEqual :: SpecialKey
KeyPadEnter :: SpecialKey
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton
data KeyState
Down :: KeyState
Up :: KeyState
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
shift :: Modifiers -> KeyState
ctrl :: Modifiers -> KeyState
alt :: Modifiers -> KeyState


-- | Gloss hides the pain of drawing simple vector graphics behind a nice
--   data type and a few display functions.
--   
--   Getting something on the screen is as easy as:
--   
--   <pre>
--   import Graphics.Gloss
--   main = <a>display</a> (InWindow "Nice Window" (200, 200) (10, 10)) <a>white</a> (<a>Circle</a> 80)
--   
--   </pre>
--   
--   Once the window is open you can use the following:
--   
--   <ul>
--   <li>Quit - esc-key.</li>
--   <li>Move Viewport - left-click drag, arrow keys.</li>
--   <li>Rotate Viewport - right-click drag, control-left-click drag, or
--   home/end-keys.</li>
--   <li>Zoom Viewport - mouse wheel, or page up/down-keys.</li>
--   </ul>
--   
--   Animations can be constructed similarly using the <a>animate</a>.
--   
--   If you want to run a simulation based around finite time steps then
--   try <a>simulate</a>.
--   
--   If you want to manage your own key/mouse events then use <a>play</a>.
--   
--   Gloss uses OpenGL under the hood, but you don't have to worry about
--   any of that.
--   
--   Gloss programs should be compiled with <tt>-threaded</tt>, otherwise
--   the GHC runtime will limit the frame-rate to around 20Hz.
--   
--   To build gloss using the GLFW window manager instead of GLUT use
--   <tt>cabal install gloss --flags="GLFW -GLUT"</tt>
--   
--   <pre>
--   Release Notes:
--   
--   For 1.9:
--    Thanks to Elise Huard
--     * Split rendering code into gloss-rendering package.
--   
--   For 1.8
--    Thanks to Francesco Mazzoli
--     * Factored out ViewPort and ViewState handling into user visible modules.
--   
--   For 1.7:
--     * Tweaked circle level-of-detail reduction code.
--     * Increased frame rate cap to 100hz.
--     Thanks to Doug Burke
--     * Primitives for drawing arcs and sectors.
--     Thanks to Thomas DuBuisson
--     * IO versions of animate, simulate and play.
--   
--   For 1.6:
--     Thanks to Anthony Cowley
--     * Full screen display mode.
--   
--   For 1.5:
--     * O(1) Conversion of ForeignPtrs to bitmaps.
--     * An extra flag on the Bitmap constructor allows bitmaps to be cached
--       in texture memory between frames.
--   </pre>
--   
--   For more information, check out <a>http://gloss.ouroborus.net</a>.
module Graphics.Gloss

-- | Describes how Gloss should display its output.
data Display

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen with a drawing area of the given size.
FullScreen :: (Int, Int) -> Display

-- | Open a new window and display the given picture.
--   
--   Use the following commands once the window is open:
--   
--   <ul>
--   <li>Quit - esc-key.</li>
--   <li>Move Viewport - left-click drag, arrow keys.</li>
--   <li>Rotate Viewport - right-click drag, control-left-click drag, or
--   home/end-keys.</li>
--   <li>Zoom Viewport - mouse wheel, or page up/down-keys.</li>
--   </ul>
display :: Display -> Color -> Picture -> IO ()

-- | Open a new window and display the given animation.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
animate :: Display -> Color -> (Float -> Picture) -> IO ()

-- | Run a finite-time-step simulation in a window. You decide how the
--   model is represented, how to convert the model to a picture, and how
--   to advance the model for each unit of time. This function does the
--   rest.
--   
--   Once the window is open you can use the same commands as with
--   <tt>display</tt>.
simulate :: Display -> Color -> Int -> model -> (model -> Picture) -> (ViewPort -> Float -> model -> model) -> IO ()

-- | Play a game in a window. Like <tt>simulate</tt>, but you manage your
--   own input events.
play :: Display -> Color -> Int -> world -> (world -> Picture) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()
