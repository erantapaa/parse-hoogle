-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad transformer library with type indexes,
providing 'free' copies.
--   
--   A monad transformer library with type indexes, which allows the
--   programmer to get a distinct copy of one of the monads without
--   reproducing definitions and instances. It currently supports
--   IdentityX, ReaderX, StateX, WriterX, RWSX, and ErrorX monads (and
--   their transformer versions). All these copies can be combined into a
--   transformer stack, including any of the original mtl monads. Inspired
--   by the original mtl. That library was inspired by the paper
--   /Functional Programming with Overloading and Higher-Order
--   Polymorphism/, by Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>), Advanced
--   School of Functional Programming, 1995. See the Examples.hs file for
--   usage.
@package mtlx
@version 0.1.5

module Control.Monad.Index
class Index ix
getVal :: Index ix => ix

module Control.Monad.IdentityX
newtype IdentityX ix a
IdentityX :: a -> IdentityX ix a
runIdentityX' :: IdentityX ix a -> a
runIdentityX :: Index ix => ix -> IdentityX ix a -> a
mkIdentityX :: Index ix => ix -> a -> IdentityX ix a
instance [overlap ok] Index ix => MonadFix (IdentityX ix)
instance [overlap ok] Index ix => Monad (IdentityX ix)
instance [overlap ok] Index ix => Functor (IdentityX ix)


module Control.Monad.ReaderX.Class
class (Monad m, Index ix) => MonadReaderX ix r m | ix m -> r
askx :: MonadReaderX ix r m => ix -> m r
localx :: MonadReaderX ix r m => ix -> (r -> r) -> m a -> m a
asksx :: MonadReaderX ix r m => ix -> (r -> a) -> m a


module Control.Monad.StateX.Class
class (Monad m, Index ix) => MonadStateX ix s m | ix m -> s
getx :: MonadStateX ix s m => ix -> m s
putx :: MonadStateX ix s m => ix -> s -> m ()
modifyx :: MonadStateX ix s m => ix -> (s -> s) -> m ()
getsx :: MonadStateX ix s m => ix -> (s -> a) -> m a
instance [overlap ok] (Monoid w2, Monad m, Index ix1, MonadStateX ix1 s1 m) => MonadStateX ix1 s1 (RWST r2 w2 s2 m)
instance [overlap ok] (Index ix, MonadStateX ix s m, Monoid w) => MonadStateX ix s (WriterT w m)
instance [overlap ok] (Index ix, MonadStateX ix s m) => MonadStateX ix s (ReaderT r m)
instance [overlap ok] (MonadStateX ix s1 m, Index ix) => MonadStateX ix s1 (StateT s2 m)
instance [overlap ok] (Error e, MonadStateX ix s m) => MonadStateX ix s (ErrorT e m)


module Control.Monad.WriterX.Class
class (Monoid w, Monad m, Index ix) => MonadWriterX ix w m | ix m -> w
tellx :: MonadWriterX ix w m => ix -> w -> m ()
listenx :: MonadWriterX ix w m => ix -> m a -> m (a, w)
passx :: MonadWriterX ix w m => ix -> m (a, w -> w) -> m a
listensx :: (MonadWriterX ix w m, Index ix) => ix -> (w -> b) -> m a -> m (a, b)
censorx :: (MonadWriterX ix w m, Index ix) => ix -> (w -> w) -> m a -> m a


module Control.Monad.ErrorX.Class
class Index ix => ErrorX ix a
noMsgx :: ErrorX ix a => ix -> a
strMsgx :: ErrorX ix a => ix -> String -> a
class (Monad m, ErrorX ix e, Index ix) => MonadErrorX ix e m | ix m -> e
throwErrorx :: MonadErrorX ix e m => ix -> e -> m a
catchErrorx :: MonadErrorX ix e m => ix -> m a -> (e -> m a) -> m a
instance [overlap ok] Index ix => ErrorX ix IOError
instance [overlap ok] Index ix => ErrorX ix String


-- | Error monads.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.ErrorX
newtype ErrorTX ix e m a
ErrorTX :: m (Either e a) -> ErrorTX ix e m a
runErrorTX' :: ErrorTX ix e m a -> m (Either e a)
runErrorTX :: Index ix => ix -> ErrorTX ix e m a -> m (Either e a)
mapErrorTX :: Index ix => ix -> (m (Either e a) -> n (Either e' b)) -> ErrorTX ix e m a -> ErrorTX ix e' n b
instance [overlap ok] (ErrorX ixe e, Index ixw, MonadWriterX ixw w m, Index ixe) => MonadWriterX ixw w (ErrorTX ixe e m)
instance [overlap ok] (ErrorX ixe e, Index ixs, MonadStateX ixs s m, Index ixe) => MonadStateX ixs s (ErrorTX ixe e m)
instance [overlap ok] (ErrorX ixe e, MonadReaderX ixr r m, Index ixr, Index ixe) => MonadReaderX ixr r (ErrorTX ixe e m)
instance [overlap ok] (ErrorX ix e, MonadWriter w m, Index ix) => MonadWriter w (ErrorTX ix e m)
instance [overlap ok] (ErrorX ix e, MonadState s m, Index ix) => MonadState s (ErrorTX ix e m)
instance [overlap ok] (ErrorX ix e, MonadReader r m, Index ix) => MonadReader r (ErrorTX ix e m)
instance [overlap ok] (Monoid w, MonadErrorX ixe e m, Index ixe) => MonadErrorX ixe e (RWST r w s m)
instance [overlap ok] (ErrorX ix e, MonadRWS r w s m, Index ix) => MonadRWS r w s (ErrorTX ix e m)
instance [overlap ok] (ErrorX ix e, MonadCont m, Index ix) => MonadCont (ErrorTX ix e m)
instance [overlap ok] (ErrorX ix e, MonadIO m, Index ix) => MonadIO (ErrorTX ix e m)
instance [overlap ok] (ErrorX ix e, Index ix) => MonadTrans (ErrorTX ix e)
instance [overlap ok] (Monad m, ErrorX ix1 e1, ErrorX ix2 e2, Index ix1, Index ix2, MonadErrorX ix1 e1 m) => MonadErrorX ix1 e1 (ErrorTX ix2 e2 m)
instance [overlap ok] (Monad m, ErrorX ix e, Index ix) => MonadErrorX ix e (ErrorTX ix e m)
instance [overlap ok] (MonadFix m, ErrorX ix e, Index ix) => MonadFix (ErrorTX ix e m)
instance [overlap ok] (Monad m, ErrorX ix e, Index ix) => MonadPlus (ErrorTX ix e m)
instance [overlap ok] (Monad m, ErrorX ix e, Index ix) => Monad (ErrorTX ix e m)
instance [overlap ok] (Monad m, Index ix) => Functor (ErrorTX ix e m)
instance [overlap ok] Index ix => MonadErrorX ix IOError IO


module Control.Monad.ReaderX
newtype ReaderX ix r a
ReaderX :: (r -> a) -> ReaderX ix r a
runReaderX' :: ReaderX ix r a -> r -> a
mkReaderX :: Index ix => ix -> (r -> a) -> ReaderX ix r a
runReaderX :: Index ix => ix -> ReaderX ix r a -> (r -> a)
mapReaderx :: Index ix => ix -> (a -> b) -> ReaderX ix r a -> ReaderX ix r b

-- | A more general version of <a>local</a>.
withReaderx :: Index ix => ix -> (r' -> r) -> ReaderX ix r a -> ReaderX ix r' a
newtype ReaderTX ix r m a
ReaderTX :: (r -> m a) -> ReaderTX ix r m a
runReaderTX' :: ReaderTX ix r m a -> r -> m a
mkReaderTX :: Index ix => ix -> (r -> m a) -> ReaderTX ix r m a
runReaderTX :: Index ix => ix -> ReaderTX ix r m a -> r -> m a
mapReaderTX :: Index ix => ix -> (m a -> n b) -> ReaderTX ix w m a -> ReaderTX ix w n b
withReaderTX :: Index ix => ix -> (r' -> r) -> ReaderTX ix r m a -> ReaderTX ix r' m a
instance [overlap ok] (Monoid w2, Monad m, Index ix1, MonadReaderX ix1 r1 m) => MonadReaderX ix1 r1 (RWST r2 w2 s2 m)
instance [overlap ok] (Monoid w, Index ix2, MonadReader r m, MonadState s m, MonadWriter w m) => MonadRWS r w s (ReaderTX ix2 r2 m)
instance [overlap ok] (Index ixr, MonadWriterX ixw w m) => MonadWriterX ixw w (ReaderTX ixr r m)
instance [overlap ok] (Index ix, MonadReaderX ix r m, Monoid w) => MonadReaderX ix r (WriterT w m)
instance [overlap ok] (Index ix, MonadWriter w m) => MonadWriter w (ReaderTX ix r m)
instance [overlap ok] (Index ixr, Index ixs, MonadStateX ixs s m) => MonadStateX ixs s (ReaderTX ixr r m)
instance [overlap ok] (Index ix, MonadReaderX ix r m) => MonadReaderX ix r (StateT s m)
instance [overlap ok] (Index ix, MonadState s m) => MonadState s (ReaderTX ix r m)
instance [overlap ok] (Index ix1, Index ix2, MonadReaderX ix1 r1 m) => MonadReaderX ix1 r1 (ReaderTX ix2 r2 m)
instance [overlap ok] (Monad m, MonadReaderX ix r1 m, Index ix) => MonadReaderX ix r1 (ReaderT r2 m)
instance [overlap ok] (MonadReader r m, Index ix) => MonadReader r (ReaderTX ix r2 m)
instance [overlap ok] (MonadErrorX ixe e m, Index ixe, Index ixr) => MonadErrorX ixe e (ReaderTX ixr r m)
instance [overlap ok] (Index ix, Error e, MonadReaderX ix r m) => MonadReaderX ix r (ErrorT e m)
instance [overlap ok] (MonadError e m, Index ix) => MonadError e (ReaderTX ix r m)
instance [overlap ok] (MonadCont m, Index ix) => MonadCont (ReaderTX ix r m)
instance [overlap ok] (MonadIO m, Index ix) => MonadIO (ReaderTX ix r m)
instance [overlap ok] Index ix => MonadTrans (ReaderTX ix r)
instance [overlap ok] (Monad m, Index ix) => MonadReaderX ix r (ReaderTX ix r m)
instance [overlap ok] (MonadFix m, Index ix) => MonadFix (ReaderTX ix r m)
instance [overlap ok] (MonadPlus m, Index ix) => MonadPlus (ReaderTX ix r m)
instance [overlap ok] (Monad m, Index ix) => Monad (ReaderTX ix r m)
instance [overlap ok] (Monad m, Index ix) => Functor (ReaderTX ix r m)
instance [overlap ok] Index ix => MonadReaderX ix r (ReaderX ix r)
instance [overlap ok] Index ix => MonadFix (ReaderX ix r)
instance [overlap ok] Index ix => Monad (ReaderX ix r)
instance [overlap ok] Index ix => Functor (ReaderX ix r)
instance [overlap ok] Index ix => MonadReaderX ix r ((->) r)


-- | Lazy state monads.
module Control.Monad.StateX.Lazy
newtype StateX ix s a
StateX :: (s -> (a, s)) -> StateX ix s a
runStateX' :: StateX ix s a -> s -> (a, s)
mkStateX :: Index ix => ix -> (s -> (a, s)) -> StateX ix s a
runStateX :: Index ix => ix -> StateX ix s a -> (s -> (a, s))
evalStatex :: Index ix => ix -> StateX ix s a -> s -> a
execStatex :: Index ix => ix -> StateX ix s a -> s -> s
mapStatex :: Index ix => ix -> ((a, s) -> (b, s)) -> StateX ix s a -> StateX ix s b
withStatex :: Index ix => ix -> (s -> s) -> StateX ix s a -> StateX ix s a
newtype StateTX ix s m a
StateTX :: (s -> m (a, s)) -> StateTX ix s m a
runStateTX' :: StateTX ix s m a -> s -> m (a, s)
mkStateTX :: Index ix => ix -> (s -> m (a, s)) -> StateTX ix s m a
runStateTX :: Index ix => ix -> StateTX ix s m a -> s -> m (a, s)
evalStateTX :: (Monad m, Index ix) => ix -> StateTX ix s m a -> s -> m a
execStateTX :: (Monad m, Index ix) => ix -> StateTX ix s m a -> s -> m s
mapStateTX :: Index ix => ix -> (m (a, s) -> n (b, s)) -> StateTX ix s m a -> StateTX ix s n b
withStateTX :: Index ix => ix -> (s -> s) -> StateTX ix s m a -> StateTX ix s m a
instance [overlap ok] (Monoid w, Index ix2, MonadReader r m, MonadState s m, MonadWriter w m) => MonadRWS r w s (StateTX ix2 s2 m)
instance [overlap ok] (Index ixs, MonadWriterX ixw w m) => MonadWriterX ixw w (StateTX ixs s m)
instance [overlap ok] (Index ix, MonadWriter w m) => MonadWriter w (StateTX ix s m)
instance [overlap ok] (Index ixs, MonadReaderX ixr r m) => MonadReaderX ixr r (StateTX ixs st m)
instance [overlap ok] (Index ix, MonadReader r m) => MonadReader r (StateTX ix st m)
instance [overlap ok] (Index ix1, Index ix2, MonadStateX ix1 s1 m) => MonadStateX ix1 s1 (StateTX ix2 s2 m)
instance [overlap ok] (MonadState s1 m, Index ix) => MonadState s1 (StateTX ix s2 m)
instance [overlap ok] (MonadErrorX ixe e m, Index ixs) => MonadErrorX ixe e (StateTX ixs s m)
instance [overlap ok] (MonadError e m, Index ix) => MonadError e (StateTX ix s m)
instance [overlap ok] (MonadCont m, Index ix) => MonadCont (StateTX ix s m)
instance [overlap ok] (MonadIO m, Index ix) => MonadIO (StateTX ix s m)
instance [overlap ok] Index ix => MonadTrans (StateTX ix s)
instance [overlap ok] (Monad m, Index ix) => MonadStateX ix s (StateTX ix s m)
instance [overlap ok] (MonadFix m, Index ix) => MonadFix (StateTX ix s m)
instance [overlap ok] (MonadPlus m, Index ix) => MonadPlus (StateTX ix s m)
instance [overlap ok] (Monad m, Index ix) => Monad (StateTX ix s m)
instance [overlap ok] (Monad m, Index ix) => Functor (StateTX ix s m)
instance [overlap ok] Index ix => MonadStateX ix s (StateX ix s)
instance [overlap ok] Index ix => MonadFix (StateX ix s)
instance [overlap ok] Index ix => Monad (StateX ix s)
instance [overlap ok] Index ix => Functor (StateX ix s)


-- | State monads.
--   
--   This module is inspired by the paper /Functional Programming with
--   Overloading and Higher-Order Polymorphism/, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.StateX


-- | Strict state monads.
module Control.Monad.StateX.Strict
newtype StateX ix s a
StateX :: (s -> (a, s)) -> StateX ix s a
runStateX' :: StateX ix s a -> s -> (a, s)
mkStateX :: Index ix => ix -> (s -> (a, s)) -> StateX ix s a
runStateX :: Index ix => ix -> StateX ix s a -> (s -> (a, s))
evalStatex :: Index ix => ix -> StateX ix s a -> s -> a
execStatex :: Index ix => ix -> StateX ix s a -> s -> s
mapStatex :: Index ix => ix -> ((a, s) -> (b, s)) -> StateX ix s a -> StateX ix s b
withStatex :: Index ix => ix -> (s -> s) -> StateX ix s a -> StateX ix s a
newtype StateTX ix s m a
StateTX :: (s -> m (a, s)) -> StateTX ix s m a
runStateTX' :: StateTX ix s m a -> s -> m (a, s)
mkStateTX :: Index ix => ix -> (s -> m (a, s)) -> StateTX ix s m a
runStateTX :: Index ix => ix -> StateTX ix s m a -> s -> m (a, s)
evalStateTX :: (Monad m, Index ix) => ix -> StateTX ix s m a -> s -> m a
execStateTX :: (Monad m, Index ix) => ix -> StateTX ix s m a -> s -> m s
mapStateTX :: Index ix => ix -> (m (a, s) -> n (b, s)) -> StateTX ix s m a -> StateTX ix s n b
withStateTX :: Index ix => ix -> (s -> s) -> StateTX ix s m a -> StateTX ix s m a
instance [overlap ok] (Monoid w, Index ix2, MonadReader r m, MonadState s m, MonadWriter w m) => MonadRWS r w s (StateTX ix2 s2 m)
instance [overlap ok] (Index ixs, MonadWriterX ixw w m) => MonadWriterX ixw w (StateTX ixs s m)
instance [overlap ok] (Index ix, MonadWriter w m) => MonadWriter w (StateTX ix s m)
instance [overlap ok] (Index ixs, MonadReaderX ixr r m) => MonadReaderX ixr r (StateTX ixs st m)
instance [overlap ok] (Index ix, MonadReader r m) => MonadReader r (StateTX ix st m)
instance [overlap ok] (Index ix1, Index ix2, MonadStateX ix1 s1 m) => MonadStateX ix1 s1 (StateTX ix2 s2 m)
instance [overlap ok] (MonadState s1 m, Index ix) => MonadState s1 (StateTX ix s2 m)
instance [overlap ok] (MonadErrorX ixe e m, Index ixs) => MonadErrorX ixe e (StateTX ixs s m)
instance [overlap ok] (MonadError e m, Index ix) => MonadError e (StateTX ix s m)
instance [overlap ok] (MonadCont m, Index ix) => MonadCont (StateTX ix s m)
instance [overlap ok] (MonadIO m, Index ix) => MonadIO (StateTX ix s m)
instance [overlap ok] Index ix => MonadTrans (StateTX ix s)
instance [overlap ok] (Monad m, Index ix) => MonadStateX ix s (StateTX ix s m)
instance [overlap ok] (MonadFix m, Index ix) => MonadFix (StateTX ix s m)
instance [overlap ok] (MonadPlus m, Index ix) => MonadPlus (StateTX ix s m)
instance [overlap ok] (Monad m, Index ix) => Monad (StateTX ix s m)
instance [overlap ok] (Monad m, Index ix) => Functor (StateTX ix s m)
instance [overlap ok] Index ix => MonadStateX ix s (StateX ix s)
instance [overlap ok] Index ix => MonadFix (StateX ix s)
instance [overlap ok] Index ix => Monad (StateX ix s)
instance [overlap ok] Index ix => Functor (StateX ix s)

module Control.Monad.WriterX.Lazy
newtype WriterX ix w a
WriterX :: (a, w) -> WriterX ix w a
runWriterX' :: WriterX ix w a -> (a, w)
mkWriterX :: Index ix => ix -> (a, w) -> WriterX ix w a
runWriterX :: Index ix => ix -> WriterX ix w a -> (a, w)
execWriterX :: Index ix => ix -> WriterX ix w a -> w
mapWriterX :: Index ix => ix -> ((a, w) -> (b, w')) -> WriterX ix w a -> WriterX ix w' b
newtype WriterTX ix w m a
WriterTX :: m (a, w) -> WriterTX ix w m a
runWriterTX' :: WriterTX ix w m a -> m (a, w)
mkWriterTX :: Index ix => ix -> m (a, w) -> WriterTX ix w m a
runWriterTX :: Index ix => ix -> WriterTX ix w m a -> m (a, w)
execWriterTX :: (Index ix, Monad m) => ix -> WriterTX ix w m a -> m w
mapWriterTX :: Index ix => ix -> (m (a, w) -> n (b, w')) -> WriterTX ix w m a -> WriterTX ix w' n b
instance [overlap ok] (Monoid w1, Monoid w2, Monad m, Index ix1, MonadWriterX ix1 w1 m) => MonadWriterX ix1 w1 (RWST r2 w2 s2 m)
instance [overlap ok] (Monoid w1, Monoid w2, Index ix2, MonadReader r m, MonadState s m, MonadWriter w1 m) => MonadRWS r w1 s (WriterTX ix2 w2 m)
instance [overlap ok] (Index ixw1, Index ixw2, Monoid w1, Monoid w2, MonadWriterX ixw1 w1 m) => MonadWriterX ixw1 w1 (WriterTX ixw2 w2 m)
instance [overlap ok] (Index ixw2, Monoid w, Monoid s, MonadWriter w m) => MonadWriter w (WriterTX ixw2 s m)
instance [overlap ok] (Monoid w, Index ixw, MonadStateX ixs s m) => MonadStateX ixs s (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadState s m, Index ixw) => MonadState s (WriterTX ixw w m)
instance [overlap ok] (Monoid w, Index ixr, Index ixw, MonadReaderX ixr r m) => MonadReaderX ixr r (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadReader r m, Index ixw) => MonadReader r (WriterTX ixw w m)
instance [overlap ok] (Monoid w, Index ixe, Index ixw, MonadErrorX ixe e m) => MonadErrorX ixe e (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadError e m, Index ix) => MonadError e (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadCont m, Index ix) => MonadCont (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadIO m, Index ix) => MonadIO (WriterTX ix w m)
instance [overlap ok] (Monoid w, Index ix) => MonadTrans (WriterTX ix w)
instance [overlap ok] (Monoid w, Monad m, Index ix) => MonadWriterX ix w (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadFix m, Index ix) => MonadFix (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadPlus m, Index ix) => MonadPlus (WriterTX ix w m)
instance [overlap ok] (Monoid w, Monad m, Index ix) => Monad (WriterTX ix w m)
instance [overlap ok] (Monad m, Index ix) => Functor (WriterTX ix w m)
instance [overlap ok] (Monoid w, Index ix) => MonadWriterX ix w (WriterX ix w)
instance [overlap ok] (Monoid w, Index ix) => MonadFix (WriterX ix w)
instance [overlap ok] (Monoid w, Index ix) => Monad (WriterX ix w)
instance [overlap ok] Index ix => Functor (WriterX ix w)


module Control.Monad.WriterX
instance [overlap ok] (Index ixw, MonadWriterX ixw w m) => MonadWriterX ixw w (ReaderT r m)
instance [overlap ok] (MonadWriterX ixw w m, Index ixw) => MonadWriterX ixw w (StateT s m)
instance [overlap ok] (MonadWriterX ixw w m, Index ixw, Monoid w2) => MonadWriterX ixw w (WriterT w2 m)
instance [overlap ok] (Error e, MonadWriterX ix w m, Index ix) => MonadWriterX ix w (ErrorT e m)

module Control.Monad.RWSX.Class
class (Monoid w, Index ix, MonadReaderX ix r m, MonadWriterX ix w m, MonadStateX ix s m) => MonadRWSX ix r w s m | ix m -> r, ix m -> w, ix m -> s
instance [overlap ok] (Monoid w1, Monoid w2, Index ix1, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (RWST r2 w2 s2 m)
instance [overlap ok] (Monoid w1, Index ix1, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (StateT s2 m)
instance [overlap ok] (Monoid w1, Monoid w2, Index ix1, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (WriterT w2 m)
instance [overlap ok] (Monoid w1, Index ix1, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (ReaderT r2 m)

module Control.Monad.RWSX.Lazy
newtype RWSX ix r w s a
RWSX :: (r -> s -> (a, s, w)) -> RWSX ix r w s a
runRWSX' :: RWSX ix r w s a -> r -> s -> (a, s, w)
mkRWSX :: Index ix => ix -> (r -> s -> (a, s, w)) -> RWSX ix r w s a
runRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (a, s, w)
evalRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (a, w)
execRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (s, w)
mapRWSX :: Index ix => ix -> ((a, s, w) -> (b, s, w')) -> RWSX ix r w s a -> RWSX ix r w' s b
withRWSX :: Index ix => ix -> (r' -> s -> (r, s)) -> RWSX ix r w s a -> RWSX ix r' w s a
newtype RWSTX ix r w s m a
RWSTX :: (r -> s -> m (a, s, w)) -> RWSTX ix r w s m a
runRWSTX' :: RWSTX ix r w s m a -> r -> s -> m (a, s, w)
mkRWSTX :: Index ix => ix -> (r -> s -> m (a, s, w)) -> RWSTX ix r w s m a
runRWSTX :: Index ix => ix -> RWSTX ix r w s m a -> (r -> s -> m (a, s, w))
evalRWSTX :: (Monad m, Index ix) => ix -> RWSTX ix r w s m a -> r -> s -> m (a, w)
execRWSTX :: (Monad m, Index ix) => ix -> RWSTX ix r w s m a -> r -> s -> m (s, w)
mapRWSTX :: Index ix => ix -> (m (a, s, w) -> n (b, s, w')) -> RWSTX ix r w s m a -> RWSTX ix r w' s n b
withRWSTX :: Index ix => ix -> (r' -> s -> (r, s)) -> RWSTX ix r w s m a -> RWSTX ix r' w s m a
instance [incoherent] (Monoid w1, Monoid w2, Monad m, Index ix1, Index ix2, MonadWriterX ix1 w1 m) => MonadWriterX ix1 w1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix1, Index ix2, MonadStateX ix1 s1 m) => MonadStateX ix1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix1, Index ix2, MonadReaderX ix1 r1 m) => MonadReaderX ix1 r1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Index ix1, Index ix2, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Index ix2, MonadRWS r1 w1 s1 m) => MonadRWS r1 w1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix2, MonadState s1 m) => MonadState s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Monad m, Index ix2, MonadWriter w1 m) => MonadWriter w1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix2, MonadReader r1 m) => MonadReader r1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w, MonadErrorX ixe e m, Index ix, Index ixe) => MonadErrorX ixe e (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadError e m, Index ix) => MonadError e (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadCont m, Index ix) => MonadCont (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadIO m, Index ix) => MonadIO (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Index ix) => MonadTrans (RWSTX ix r w s)
instance [incoherent] (r1 ~ r2, s1 ~ s2, w1 ~ w2, Monad m, Monoid w1, Monoid w2, Index ix) => MonadRWSX ix r1 w1 s1 (RWSTX ix r2 w2 s2 m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadStateX ix s (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadWriterX ix w (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadReaderX ix r (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadFix m, Index ix) => MonadFix (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadPlus m, Index ix) => MonadPlus (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => Monad (RWSTX ix r w s m)
instance [incoherent] (Monad m, Index ix) => Functor (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Index ix) => MonadRWSX ix r w s (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadStateX ix s (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadWriterX ix w (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadReaderX ix r (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadFix (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => Monad (RWSX ix r w s)
instance [incoherent] Index ix => Functor (RWSX ix r w s)

module Control.Monad.RWSX

module Control.Monad.RWSX.Strict
newtype RWSX ix r w s a
RWSX :: (r -> s -> (a, s, w)) -> RWSX ix r w s a
runRWSX' :: RWSX ix r w s a -> r -> s -> (a, s, w)
mkRWSX :: Index ix => ix -> (r -> s -> (a, s, w)) -> RWSX ix r w s a
runRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (a, s, w)
evalRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (a, w)
execRWSX :: Index ix => ix -> RWSX ix r w s a -> r -> s -> (s, w)
mapRWSX :: Index ix => ix -> ((a, s, w) -> (b, s, w')) -> RWSX ix r w s a -> RWSX ix r w' s b
withRWSX :: Index ix => ix -> (r' -> s -> (r, s)) -> RWSX ix r w s a -> RWSX ix r' w s a
newtype RWSTX ix r w s m a
RWSTX :: (r -> s -> m (a, s, w)) -> RWSTX ix r w s m a
runRWSTX' :: RWSTX ix r w s m a -> r -> s -> m (a, s, w)
mkRWSTX :: Index ix => ix -> (r -> s -> m (a, s, w)) -> RWSTX ix r w s m a
runRWSTX :: Index ix => ix -> RWSTX ix r w s m a -> (r -> s -> m (a, s, w))
evalRWSTX :: (Monad m, Index ix) => ix -> RWSTX ix r w s m a -> r -> s -> m (a, w)
execRWSTX :: (Monad m, Index ix) => ix -> RWSTX ix r w s m a -> r -> s -> m (s, w)
mapRWSTX :: Index ix => ix -> (m (a, s, w) -> n (b, s, w')) -> RWSTX ix r w s m a -> RWSTX ix r w' s n b
withRWSTX :: Index ix => ix -> (r' -> s -> (r, s)) -> RWSTX ix r w s m a -> RWSTX ix r' w s m a
instance [incoherent] (Monoid w1, Monoid w2, Monad m, Index ix1, Index ix2, MonadWriterX ix1 w1 m) => MonadWriterX ix1 w1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix1, Index ix2, MonadStateX ix1 s1 m) => MonadStateX ix1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix1, Index ix2, MonadReaderX ix1 r1 m) => MonadReaderX ix1 r1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Index ix1, Index ix2, MonadRWSX ix1 r1 w1 s1 m) => MonadRWSX ix1 r1 w1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Index ix2, MonadRWS r1 w1 s1 m) => MonadRWS r1 w1 s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix2, MonadState s1 m) => MonadState s1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w1, Monoid w2, Monad m, Index ix2, MonadWriter w1 m) => MonadWriter w1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w2, Monad m, Index ix2, MonadReader r1 m) => MonadReader r1 (RWSTX ix2 r2 w2 s2 m)
instance [incoherent] (Monoid w, MonadErrorX ixe e m, Index ix, Index ixe) => MonadErrorX ixe e (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadError e m, Index ix) => MonadError e (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadCont m, Index ix) => MonadCont (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadIO m, Index ix) => MonadIO (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Index ix) => MonadTrans (RWSTX ix r w s)
instance [incoherent] (r1 ~ r2, s1 ~ s2, w1 ~ w2, Monad m, Monoid w1, Monoid w2, Index ix) => MonadRWSX ix r1 w1 s1 (RWSTX ix r2 w2 s2 m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadStateX ix s (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadWriterX ix w (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => MonadReaderX ix r (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadFix m, Index ix) => MonadFix (RWSTX ix r w s m)
instance [incoherent] (Monoid w, MonadPlus m, Index ix) => MonadPlus (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Monad m, Index ix) => Monad (RWSTX ix r w s m)
instance [incoherent] (Monad m, Index ix) => Functor (RWSTX ix r w s m)
instance [incoherent] (Monoid w, Index ix) => MonadRWSX ix r w s (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadStateX ix s (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadWriterX ix w (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadReaderX ix r (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => MonadFix (RWSX ix r w s)
instance [incoherent] (Monoid w, Index ix) => Monad (RWSX ix r w s)
instance [incoherent] Index ix => Functor (RWSX ix r w s)

module Control.Monad.WriterX.Strict
newtype WriterX ix w a
WriterX :: (a, w) -> WriterX ix w a
runWriterX' :: WriterX ix w a -> (a, w)
mkWriterX :: Index ix => ix -> (a, w) -> WriterX ix w a
runWriterX :: Index ix => ix -> WriterX ix w a -> (a, w)
execWriterX :: Index ix => ix -> WriterX ix w a -> w
mapWriterX :: Index ix => ix -> ((a, w) -> (b, w')) -> WriterX ix w a -> WriterX ix w' b
newtype WriterTX ix w m a
WriterTX :: m (a, w) -> WriterTX ix w m a
runWriterTX' :: WriterTX ix w m a -> m (a, w)
mkWriterTX :: Index ix => ix -> m (a, w) -> WriterTX ix w m a
runWriterTX :: Index ix => ix -> WriterTX ix w m a -> m (a, w)
execWriterTX :: (Index ix, Monad m) => ix -> WriterTX ix w m a -> m w
mapWriterTX :: Index ix => ix -> (m (a, w) -> n (b, w')) -> WriterTX ix w m a -> WriterTX ix w' n b
instance [overlap ok] (Monoid w1, Monoid w2, Monad m, Index ix1, MonadWriterX ix1 w1 m) => MonadWriterX ix1 w1 (RWST r2 w2 s2 m)
instance [overlap ok] (Monoid w1, Monoid w2, Index ix2, MonadReader r m, MonadState s m, MonadWriter w1 m) => MonadRWS r w1 s (WriterTX ix2 w2 m)
instance [overlap ok] (Index ixw1, Index ixw2, Monoid w1, Monoid w2, MonadWriterX ixw1 w1 m) => MonadWriterX ixw1 w1 (WriterTX ixw2 w2 m)
instance [overlap ok] (Index ixw2, Monoid w, Monoid s, MonadWriter w m) => MonadWriter w (WriterTX ixw2 s m)
instance [overlap ok] (Monoid w, Index ixw, MonadStateX ixs s m) => MonadStateX ixs s (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadState s m, Index ixw) => MonadState s (WriterTX ixw w m)
instance [overlap ok] (Monoid w, Index ixr, Index ixw, MonadReaderX ixr r m) => MonadReaderX ixr r (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadReader r m, Index ixw) => MonadReader r (WriterTX ixw w m)
instance [overlap ok] (Monoid w, Index ixe, Index ixw, MonadErrorX ixe e m) => MonadErrorX ixe e (WriterTX ixw w m)
instance [overlap ok] (Monoid w, MonadError e m, Index ix) => MonadError e (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadCont m, Index ix) => MonadCont (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadIO m, Index ix) => MonadIO (WriterTX ix w m)
instance [overlap ok] (Monoid w, Index ix) => MonadTrans (WriterTX ix w)
instance [overlap ok] (Monoid w, Monad m, Index ix) => MonadWriterX ix w (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadFix m, Index ix) => MonadFix (WriterTX ix w m)
instance [overlap ok] (Monoid w, MonadPlus m, Index ix) => MonadPlus (WriterTX ix w m)
instance [overlap ok] (Monoid w, Monad m, Index ix) => Monad (WriterTX ix w m)
instance [overlap ok] (Monad m, Index ix) => Functor (WriterTX ix w m)
instance [overlap ok] (Monoid w, Index ix) => MonadWriterX ix w (WriterX ix w)
instance [overlap ok] (Monoid w, Index ix) => MonadFix (WriterX ix w)
instance [overlap ok] (Monoid w, Index ix) => Monad (WriterX ix w)
instance [overlap ok] Index ix => Functor (WriterX ix w)
