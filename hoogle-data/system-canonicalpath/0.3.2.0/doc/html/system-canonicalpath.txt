-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstract data type for canonical paths with some utilities
--   
@package system-canonicalpath
@version 0.3.2.0


-- | <a>FilePath</a> is very deceptive, because it's just a synonym for
--   <a>String</a>, so actually it can be anything - your mothers name or
--   path to file you want to edit. Just look at the type signature of
--   function <a>readFile</a>:
--   
--   <pre>
--   readFile :: FilePath -&gt; IO String
--   </pre>
--   
--   You can translate it as follows:
--   
--   <pre>
--   readFile :: String -&gt; IO String
--   </pre>
--   
--   Well, it is known that <tt>IO</tt> actions are dangerous by
--   themselves. And here comes another problem - you need to be sure that
--   the path you pass to function is at least well constructed. For this
--   purpose you can use well known <a>FilePath</a> data type. It solves a
--   lot of problems and comes beefed with multiple cool utilities. And
--   also it is build around <a>Text</a> instead of <a>String</a>. Awesome!
--   
--   So why do we need yet another path library? The answer is simple - we
--   want to use paths like <tt>$HOME/.app.cfg</tt>, <tt>~/.zshrc</tt> or
--   <tt>/full/path/to/existing/file/or/dir</tt> in our code without any
--   additional overhead. <a>CanonicalPath</a> is named so because it tries
--   to canonicalize given path (<a>FilePath</a> or <a>Text</a>) using
--   <a>canonicalizePath</a> function. It also will extract any variables
--   it finds in path (like <tt>$VARNAME</tt>, <tt>%VARNAME%</tt> and
--   special <tt>~/</tt>). But these steps both may fail. Thats why this
--   library provides functions that return <tt><a>Maybe</a>
--   <a>CanonicalPath</a></tt> or <tt><a>Either</a> <a>Text</a>
--   <a>CanonicalPath</a></tt>.
--   
--   <a>CanonicalPath</a> also comes with additional useful property. When
--   it is created, it points to real file or directory. Honestly, it can't
--   guarantee that this path will refer to existing file or directory
--   always (someone can remove or move it to another path - and it's
--   almost impossible to be aware of such cruelty), but you can always
--   reconstruct <a>CanonicalPath</a>.
--   
--   One more thing about path canonicalization. As I mentioned before,
--   under the hood it uses <a>canonicalizePath</a> function. So here are
--   two warnings. Firstly, it behaves differently on different platforms.
--   Sometime too damn differently. So you better watch your steps.
--   Secondly, it's impossible to guarantee that the implication <tt>same
--   file/dir &lt;=&gt; same canonicalizedPath</tt> holds in either
--   direction: this function can make only a best-effort attempt.
--   
--   Happy Haskell Hacking!
module Filesystem.CanonicalPath
data CanonicalPath

-- | Unsafe constructor of <a>CanonicalPath</a>. In case of any problems it
--   will <a>error</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPath "$HOME"
--   CanonicalPath "/Users/your-user-name"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPath "unknown"
--   *** Exception: Path does not exist (no such file or directory): unknown
--   </pre>
--   
--   <i>Since 0.1.0.0</i>
canonicalPath :: MonadIO m => FilePath -> m CanonicalPath

-- | Version of <a>canonicalPath</a> that takes <a>Text</a> instead of
--   <a>FilePath</a>.
--   
--   <i>Since 0.2.1.0</i>
canonicalPath' :: MonadIO m => Text -> m CanonicalPath

-- | Constructs <tt><a>Maybe</a> <a>CanonicalPath</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPathM "~"
--   Just CanonicalPath "Users/your-user-name"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPathM "unknown"
--   Nothing
--   </pre>
--   
--   <i>Since 0.1.0.0</i>
canonicalPathM :: MonadIO m => FilePath -> m (Maybe CanonicalPath)

-- | Version of <a>canonicalPathM</a> that takes <a>Text</a> instead of
--   <a>FilePath</a>.
--   
--   <i>Since 0.2.1.0</i>
canonicalPathM' :: MonadIO m => Text -> m (Maybe CanonicalPath)

-- | Constructs <a>Either</a> <a>Text</a> <a>CanonicalPath</a>.
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPathE "~/"
--   Right CanonicalPath "/Users/your-user-name"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canonicalPathE "$HOME/this-folder-does-not-exist"
--   Left "Path does not exist (no such file or directory): /Users/your-user-name/this-folder-does-not-exist"
--   </pre>
--   
--   <i>Since 0.1.0.0</i>
canonicalPathE :: MonadIO m => FilePath -> m (Either Text CanonicalPath)

-- | Version of <a>canonicalPathE</a> that takes <a>Text</a> instead of
--   <a>FilePath</a>.
--   
--   <i>Since 0.2.1.0</i>
canonicalPathE' :: MonadIO m => Text -> m (Either Text CanonicalPath)

-- | Convert <a>CanonicalPath</a> to <tt>Filesystem.FilePath</tt>.
--   
--   <i>Since 0.1.0.0</i>
unsafePath :: CanonicalPath -> FilePath

-- | <tt>readFile file</tt> function reads a <i>file</i> and returns the
--   contents of the <i>file</i> as a <a>Text</a>. The <i>file</i> is read
--   lazily, on demand, as with getContents.
--   
--   <i>Since 0.1.1.0</i>
readFile :: MonadIO m => CanonicalPath -> m Text

-- | <tt>writeFile file txt</tt> writes <i>txt</i> to the <i>file</i>.
--   
--   <i>Since 0.1.1.0</i>
writeFile :: MonadIO m => CanonicalPath -> Text -> m ()

-- | <tt>writeFile' dir file txt</tt> writes <i>txt</i> to the
--   <i>dir/file</i>. Useful, when the file isn't created yet or you don't
--   sure if it exists.
--   
--   <i>Since 0.1.2.0</i>
writeFile' :: MonadIO m => CanonicalPath -> FilePath -> Text -> m ()

-- | <tt>appendFile file txt</tt> appends <i>txt</i> to the <i>file</i>.
--   
--   <i>Since 0.1.1.0</i>
appendFile :: MonadIO m => CanonicalPath -> Text -> m ()

-- | Convert human‐readable text into a <a>FilePath</a>.
--   
--   This function ignores the user’s locale, and assumes all file paths
--   are encoded in UTF8. If you need to create file paths with an unusual
--   or obscure encoding, encode them manually and then use <a>decode</a>.
--   
--   Since: 0.2
fromText :: Text -> FilePath

-- | Attempt to convert a <a>FilePath</a> to human‐readable text.
--   
--   If the path is decoded successfully, the result is a <a>Right</a>
--   containing the decoded text. Successfully decoded text can be
--   converted back to the original path using <a>fromText</a>.
--   
--   If the path cannot be decoded, the result is a <a>Left</a> containing
--   an approximation of the original path. If displayed to the user, this
--   value should be accompanied by some warning that the path has an
--   invalid encoding. Approximated text cannot be converted back to the
--   original path.
--   
--   This function ignores the user’s locale, and assumes all file paths
--   are encoded in UTF8. If you need to display file paths with an unusual
--   or obscure encoding, use <a>encode</a> and then decode them manually.
--   
--   Since: 0.2
toText :: FilePath -> Either Text Text

-- | <tt>toText' path</tt> converts <a>CanonicalPath</a> to <a>Text</a>.
--   
--   <i>Since 0.3.0.0</i>
toText' :: CanonicalPath -> Text

-- | <tt>fromPrelude fp</tt> converts <a>FilePath</a> to <a>toText</a>.
--   
--   <i>Since 0.1.0.0</i>
fromPrelude :: FilePath -> FilePath

-- | <tt>toPrelude up</tt> converts <a>FilePath</a> to <a>FilePath</a>.
--   
--   <i>Since 0.1.0.0</i>
toPrelude :: FilePath -> FilePath


-- | Redefinition of some functions from <tt>System.Directory</tt> module.
--   Some of them have different signature, because they need to work with
--   <tt><a>CanonicalPath</a></tt>. For example, we can't create functions
--   <tt>createDirectory :: <a>CanonicalPath</a> -&gt; IO ()</tt>, because
--   it has no sense. How can we create directory that already exists?
--   Instead we have function <tt>createDirectory :: <a>CanonicalPath</a>
--   -&gt; <a>FilePath</a> -&gt; IO <a>CanonicalPath</a></tt>, that creates
--   new directory in base existing directory with provided name. And also
--   it returns <tt><a>CanonicalPath</a></tt> of newly created directory.
--   Isn't it nice?
--   
--   A lot of functions come in two variants: one that returns resulting
--   @<a>CanonicalPath</a> and second that ignores result (they end with
--   '_' symbol).
--   
--   Happy Haskell Hacking!
module Filesystem.CanonicalPath.Directory

-- | <tt><a>createDirectory</a> base dir</tt> creates new directory
--   <tt>dir</tt> in existing <tt>base</tt> directory and returns
--   <tt><a>CanonicalPath</a></tt> of created directory.
--   
--   For more information look for documentation of
--   <tt><a>createDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
createDirectory :: MonadIO m => CanonicalPath -> FilePath -> m CanonicalPath

-- | Variant of <tt><a>createDirectory</a> that ignores resulting
--   </tt><a>CanonicalPath</a>.
--   
--   <i>Since 0.2.2.0</i>
createDirectory_ :: MonadIO m => CanonicalPath -> FilePath -> m ()

-- | <tt><a>createDirectoryIfMissing</a> parents dir</tt> creates a new
--   directory <tt>dir</tt> in <tt>base</tt> directory. If the first
--   argument is <a>True</a> the function will also create all parent
--   directories if they are missing. Function returns
--   <tt><a>CanonicalPath</a></tt> of created directory.
--   
--   For more information look for documentation of
--   <tt><a>createDirectoryIfMissing</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
createDirectoryIfMissing :: MonadIO m => Bool -> CanonicalPath -> FilePath -> m CanonicalPath

-- | Variant of <tt><a>createDirectoryIfMissing</a> that ignores resulting
--   </tt><a>CanonicalPath</a>.
--   
--   <i>Since 0.2.2.0</i>
createDirectoryIfMissing_ :: MonadIO m => Bool -> CanonicalPath -> FilePath -> m ()

-- | <tt><a>removeDirectory</a> dir</tt> removes an existing directory
--   <i>dir</i>.
--   
--   For more information look for documentation of
--   <tt><a>removeDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
removeDirectory :: MonadIO m => CanonicalPath -> m ()

-- | <tt><a>removeDirectoryRecursive</a> dir</tt> removes an existing
--   directory <i>dir</i> together with its content and all subdirectories.
--   Be careful, if the directory contains symlinks, the function will
--   follow them.
--   
--   For more information look for documentation of
--   <tt><a>removeDirectoryRecursive</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
removeDirectoryRecursive :: MonadIO m => CanonicalPath -> m ()

-- | <tt><a>renameDirectory</a> old new</tt> changes the name of an
--   existing directory from <i>old</i> to <i>new</i> and returns
--   <tt><a>CanonicalPath</a></tt> of new directory.
--   
--   For more information look for documentation of
--   <tt><a>renameDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
renameDirectory :: MonadIO m => CanonicalPath -> FilePath -> m CanonicalPath

-- | Variant of <tt><a>renameDirectory</a> that ignores resulting
--   </tt><a>CanonicalPath</a>.
--   
--   <i>Since 0.2.2.0</i>
renameDirectory_ :: MonadIO m => CanonicalPath -> FilePath -> m ()

-- | <tt><a>getDirectoryContents</a> dir</tt> returns a list of <i>all</i>
--   entries in <i>dir</i>. If you want to have list of
--   <tt><a>CanonicalPath</a></tt> instead use function
--   <tt><a>getDirectoryContents'</a></tt>.
--   
--   For more information look for documentation of
--   <tt><a>getDirectoryContents</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getDirectoryContents :: MonadIO m => CanonicalPath -> m [FilePath]

-- | The same as <tt><a>getDirectoryContents</a></tt>, but returns list of
--   <tt><a>CanonicalPath</a></tt> instead of <tt><a>FilePath</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getDirectoryContents' :: MonadIO m => CanonicalPath -> m [CanonicalPath]

-- | The same as <tt><a>getDirectoryContents</a></tt>, but returns list of
--   <tt><a>Text</a></tt> instead of <tt><a>FilePath</a></tt>.
--   
--   <i>Since 0.2.2.0</i>
getDirectoryContents'' :: MonadIO m => CanonicalPath -> m [Text]

-- | If the operating system has a notion of current directories,
--   <a>getCurrentDirectory</a> returns an <tt><a>CanonicalPath</a></tt> to
--   the current directory of the calling process.
--   
--   For more information look for documentation of
--   <tt><a>getCurrentDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getCurrentDirectory :: MonadIO m => m CanonicalPath

-- | If the operating system has a notion of current directories,
--   <tt><a>setCurrentDirectory</a> dir</tt> changes the current directory
--   of the calling process to <i>dir</i>.
--   
--   For more information look for documentation of
--   <tt><a>setCurrentDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
setCurrentDirectory :: MonadIO m => CanonicalPath -> m ()

-- | Returns the current user's home directory.
--   
--   For more information look for documentation of
--   <tt><a>getHomeDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getHomeDirectory :: MonadIO m => m CanonicalPath

-- | Returns the <tt><a>CanonicalPath</a></tt> of a directory in which
--   application-specific data for the current user can be stored. The
--   result of <a>getAppUserDataDirectory</a> for a given application is
--   specific to the current user.
--   
--   For more information look for documentation of
--   <tt><a>getAppUserDataDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getAppUserDataDirectory :: MonadIO m => Text -> m FilePath

-- | Returns the current user's document directory.
--   
--   For more information look for documentation of
--   <tt><a>getUserDocumentsDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getUserDocumentsDirectory :: MonadIO m => m CanonicalPath

-- | Returns the current directory for temporary files.
--   
--   For more information look for documentation of
--   <tt><a>getUserDocumentsDirectorygetTemporaryDirectory</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
getTemporaryDirectory :: MonadIO m => m FilePath

-- | <a>removeFile</a> <i>file</i> removes the directory entry for an
--   existing file <i>file</i>, where <i>file</i> is not itself a
--   directory.
--   
--   For more information look for documentation of
--   <tt><a>removeFile</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
removeFile :: MonadIO m => CanonicalPath -> m ()

-- | <tt><a>renameFile</a> old new</tt> changes the name of an existing
--   file system object from <i>old</i> to <i>new</i>.
--   
--   For more information look for documentation of
--   <tt><a>renameFile</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
renameFile :: MonadIO m => CanonicalPath -> FilePath -> m CanonicalPath

-- | Variant of <tt><a>renameFile</a> that ignores resulting
--   </tt><a>CanonicalPath</a>.
--   
--   <i>Since 0.2.2.0</i>
renameFile_ :: MonadIO m => CanonicalPath -> FilePath -> m ()

-- | <tt><a>copyFile</a> old new</tt> copies the existing file from
--   <i>old</i> to <i>new</i>. If the <i>new</i> file already exists, it is
--   atomically replaced by the <i>old</i> file. Neither path may refer to
--   an existing directory. The permissions of <i>old</i> are copied to
--   <i>new</i>, if possible.
--   
--   For more information look for documentation of
--   <tt><a>copyFile</a></tt>.
--   
--   <i>Since 0.1.1.0</i>
copyFile :: MonadIO m => CanonicalPath -> FilePath -> m CanonicalPath
copyFile_ :: MonadIO m => CanonicalPath -> FilePath -> m ()
