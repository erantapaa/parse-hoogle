-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic parser combinators
--   
--   Parsec is designed from scratch as an industrial-strength parser
--   library. It is simple, safe, well documented (on the package
--   homepage), has extensive libraries and good error messages, and is
--   also fast.
--   
--   This package is a maintained fork of version 2.1 of the parsec
--   package, intended to preserve its simplicity and portability.
@package parsec2
@version 1.0.0


-- | Textual source positions.
module Text.ParserCombinators.Parsec.Pos
type SourceName = String
type Line = Int
type Column = Int

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, line number
--   and column number.
newPos :: SourceName -> Line -> Column -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, and line
--   number and column number set to 1, the upper left.
initialPos :: SourceName -> SourcePos
updatePosChar :: SourcePos -> Char -> SourcePos

-- | The expression <tt>updatePosString pos s</tt> updates the source
--   position <tt>pos</tt> by calling <a>updatePosChar</a> on every
--   character in <tt>s</tt>, ie. <tt>foldl updatePosChar pos string</tt>.
updatePosString :: SourcePos -> String -> SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos


-- | Parse errors
module Text.ParserCombinators.Parsec.Error

-- | This abstract data type represents parse error messages. There are
--   four kinds of messages:
--   
--   <pre>
--   data Message = SysUnExpect String
--                | UnExpect String
--                | Expect String
--                | Message String
--   </pre>
--   
--   The fine distinction between different kinds of parse errors allows
--   the system to generate quite good error messages for the user. It also
--   allows error messages that are formatted in different languages. Each
--   kind of message is generated by different combinators:
--   
--   <ul>
--   <li>A <a>SysUnExpect</a> message is automatically generated by the
--   <tt>Text.Parsec.Combinator.satisfy</tt> combinator. The argument is
--   the unexpected input.</li>
--   <li>A <a>UnExpect</a> message is generated by the
--   <tt>Text.Parsec.Prim.unexpected</tt> combinator. The argument
--   describes the unexpected item.</li>
--   <li>A <a>Expect</a> message is generated by the
--   <tt>Text.Parsec.Prim.&lt;?&gt;</tt> combinator. The argument describes
--   the expected item.</li>
--   <li>A <a>Message</a> message is generated by the <a>fail</a>
--   combinator. The argument is some general parser message.</li>
--   </ul>
data Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
Expect :: !String -> Message
Message :: !String -> Message

-- | Extract the message string from an error message
messageString :: Message -> String
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <tt>Text.Parsec.Prim.parse</tt>.
--   <tt>ParseError</tt> is an instance of the <a>Show</a> class.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | Extracts the list of error messages from the parse error
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool

-- | Language independent show function
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError
instance Show ParseError


-- | The primitive parser combinators.
module Text.ParserCombinators.Parsec.Prim

-- | The parser <tt>p <a>?</a> msg</tt> behaves as parser <tt>p</tt>, but
--   whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces expect error messages with the expect error
--   message <tt>msg</tt>.
--   
--   This is normally used at the end of a set alternatives where we want
--   to return an error message in terms of a higher level construct rather
--   than returning all possible characters. For example, if the
--   <tt>expr</tt> parser from the <a>try</a> example would fail, the error
--   message is: '...: expecting expression'. Without the
--   <tt>(&lt;?&gt;)</tt> combinator, the message would be like '...:
--   expecting "let" or letter', which is less friendly.
(<?>) :: GenParser tok st a -> String -> GenParser tok st a

-- | This combinator implements choice. The parser <tt>p &lt;|&gt; q</tt>
--   first applies <tt>p</tt>. If it succeeds, the value of <tt>p</tt> is
--   returned. If <tt>p</tt> fails <i>without consuming any input</i>,
--   parser <tt>q</tt> is tried. This combinator is defined equal to the
--   <a>mplus</a> member of the <a>MonadPlus</a> class and the
--   (<tt>Control.Applicative.&lt;|&gt;</tt>) member of
--   <tt>Control.Applicative.Alternative</tt>.
--   
--   The parser is called <i>predictive</i> since <tt>q</tt> is only tried
--   when parser <tt>p</tt> didn't consume any input (i.e.. the look ahead
--   is 1). This non-backtracking behaviour allows for both an efficient
--   implementation of the parser combinators and the generation of good
--   error messages.
(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
type Parser a = GenParser Char () a
data GenParser tok st a

-- | The most general way to run a parser. <tt>runParser p state filePath
--   input</tt> runs parser <tt>p</tt> on the input list of tokens
--   <tt>input</tt>, obtained from source <tt>filePath</tt> with the
--   initial user state <tt>st</tt>. The <tt>filePath</tt> is only used in
--   error messages and may be the empty string. Returns either a
--   <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p fname
--     = do{ input &lt;- readFile fname
--         ; return (runParser p () fname input)
--         }
--   </pre>
runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a

-- | <tt>parse p filePath input</tt> runs a parser <tt>p</tt> without user
--   state. The <tt>filePath</tt> is only used in error messages and may be
--   the empty string. Returns either a <a>ParseError</a> (<a>Left</a>) or
--   a value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = case (parse numbers "" "11, 2, 43") of
--              Left err  -&gt; print err
--              Right xs  -&gt; print (sum xs)
--   
--   numbers = commaSep integer
--   </pre>
parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()

-- | The parser <tt>token showTok posFromTok testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The source position of the <tt>t</tt>
--   should be returned by <tt>posFromTok t</tt> and the token can be shown
--   using <tt>showTok t</tt>.
--   
--   This combinator is expressed in terms of <a>tokenPrim</a>. It is used
--   to accept user defined token streams. For example, suppose that we
--   have a stream of basic tokens tupled with source positions. We can
--   than define a parser that accepts single tokens as:
--   
--   <pre>
--   mytoken x
--     = token showTok posFromTok testTok
--     where
--       showTok (pos,t)     = show t
--       posFromTok (pos,t)  = pos
--       testTok (pos,t)     = if x == t then Just t else Nothing
--   </pre>
token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]

-- | The parser <tt>token showTok nextPos testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The token can be shown using
--   <tt>showTok t</tt>. The position of the <i>next</i> token should be
--   returned when <tt>nextPos</tt> is called with the current source
--   position <tt>pos</tt>, the current token <tt>t</tt> and the rest of
--   the tokens <tt>toks</tt>, <tt>nextPos pos t toks</tt>.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <tt>Text.Parsec.Char.char</tt> parser could be
--   implemented as:
--   
--   <pre>
--   char c
--     = tokenPrim showChar nextPos testChar
--     where
--       showChar x        = "'" ++ x ++ "'"
--       testChar x        = if x == c then Just x else Nothing
--       nextPos pos x xs  = updatePosChar pos x
--   </pre>
tokenPrim :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a

-- | The most primitive token recogniser. The expression <tt>tokenPrimEx
--   show nextpos mbnextstate test</tt>, recognises tokens when
--   <tt>test</tt> returns <tt>Just x</tt> (and returns the value
--   <tt>x</tt>). Tokens are shown in error messages using <tt>show</tt>.
--   The position is calculated using <tt>nextpos</tt>, and finally,
--   <tt>mbnextstate</tt>, can hold a function that updates the user state
--   on every token recognised (nice to count tokens :-). The function is
--   packed into a <a>Maybe</a> type for performance reasons.
tokenPrimEx :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st a

-- | The parser <tt>try p</tt> behaves like parser <tt>p</tt>, except that
--   it pretends that it hasn't consumed any input when an error occurs.
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   when the first parser failed while consuming input.
--   
--   The <tt>try</tt> combinator can for example be used to distinguish
--   identifiers and reserved words. Both reserved words and identifiers
--   are a sequence of letters. Whenever we expect a certain reserved word
--   where we can also expect an identifier we have to use the <tt>try</tt>
--   combinator. Suppose we write:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ string "let"; ... }
--   identifier  = many1 letter
--   </pre>
--   
--   If the user writes "lexical", the parser fails with: <tt>unexpected
--   'x', expecting 't' in "let"</tt>. Indeed, since the (<a>&lt;|&gt;</a>)
--   combinator only tries alternatives when the first alternative hasn't
--   consumed input, the <tt>identifier</tt> parser is never tried (because
--   the prefix "le" of the <tt>string "let"</tt> parser is already
--   consumed). The right behaviour can be obtained by adding the
--   <tt>try</tt> combinator:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ try (string "let"); ... }
--   identifier  = many1 letter
--   </pre>
try :: GenParser tok st a -> GenParser tok st a
label :: GenParser tok st a -> String -> GenParser tok st a
labels :: GenParser tok st a -> [String] -> GenParser tok st a

-- | The parser <tt>unexpected msg</tt> always fails with an unexpected
--   error message <tt>msg</tt> without consuming any input.
--   
--   The parsers <a>fail</a>, (<a>&lt;?&gt;</a>) and <tt>unexpected</tt>
--   are the three parsers used to generate error messages. Of these, only
--   (<a>&lt;?&gt;</a>) is commonly used. For an example of the use of
--   <tt>unexpected</tt>, see the definition of
--   <tt>Text.Parsec.Combinator.notFollowedBy</tt>.
unexpected :: String -> GenParser tok st a
pzero :: GenParser tok st a

-- | <tt>many p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   identifier  = do{ c  &lt;- letter
--                   ; cs &lt;- many (alphaNum &lt;|&gt; char '_')
--                   ; return (c:cs)
--                   }
--   </pre>
many :: GenParser tok st a -> GenParser tok st [a]

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
--   
--   <pre>
--   spaces  = skipMany space
--   </pre>
skipMany :: GenParser tok st a -> GenParser tok st ()

-- | Returns the current user state.
getState :: GenParser tok st st

-- | <tt>setState st</tt> set the user state to <tt>st</tt>.
setState :: st -> GenParser tok st ()

-- | <tt>updateState f</tt> applies function <tt>f</tt> to the user state.
--   Suppose that we want to count identifiers in a source, we could use
--   the user state as:
--   
--   <pre>
--   expr  = do{ x &lt;- identifier
--             ; updateState (+1)
--             ; return (Id x)
--             }
--   </pre>
updateState :: (st -> st) -> GenParser tok st ()

-- | Returns the current source position. See also <a>SourcePos</a>.
getPosition :: GenParser tok st SourcePos

-- | <tt>setPosition pos</tt> sets the current source position to
--   <tt>pos</tt>.
setPosition :: SourcePos -> GenParser tok st ()

-- | Returns the current input
getInput :: GenParser tok st [tok]

-- | <tt>setInput input</tt> continues parsing with <tt>input</tt>.
setInput :: [tok] -> GenParser tok st ()
data State tok st
State :: [tok] -> !SourcePos -> !st -> State tok st
stateInput :: State tok st -> [tok]
statePos :: State tok st -> !SourcePos
stateUser :: State tok st -> !st

-- | Returns the full parser state as a <a>State</a> record.
getParserState :: GenParser tok st (State tok st)

-- | <tt>setParserState st</tt> set the full parser state to <tt>st</tt>.
setParserState :: State tok st -> GenParser tok st (State tok st)
instance MonadPlus (GenParser tok st)
instance Monad (GenParser tok st)
instance Functor (GenParser tok st)


-- | Commonly used character parsers.
module Text.ParserCombinators.Parsec.Char
type CharParser st a = GenParser Char st a

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: CharParser st ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: CharParser st Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: CharParser st Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: CharParser st Char

-- | Parses an upper case letter (a character between 'A' and 'Z'). Returns
--   the parsed character.
upper :: CharParser st Char

-- | Parses a lower case character (a character between 'a' and 'z').
--   Returns the parsed character.
lower :: CharParser st Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: CharParser st Char

-- | Parses a letter (an upper case or lower case character). Returns the
--   parsed character.
letter :: CharParser st Char

-- | Parses a digit. Returns the parsed character.
digit :: CharParser st Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: CharParser st Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: CharParser st Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <pre>
--   semiColon  = char ';'
--   </pre>
char :: Char -> CharParser st Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div"
--               &lt;|&gt; string "mod"
--   </pre>
string :: String -> CharParser st String

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: CharParser st Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: [Char] -> CharParser st Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: [Char] -> CharParser st Char

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
--   
--   <pre>
--   digit     = satisfy isDigit
--   oneOf cs  = satisfy (\c -&gt; c `elem` cs)
--   </pre>
satisfy :: (Char -> Bool) -> CharParser st Char


-- | Commonly used generic combinators
module Text.ParserCombinators.Parsec.Combinator

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: [GenParser tok st a] -> GenParser tok st a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Int -> GenParser tok st a -> GenParser tok st [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (do{ d &lt;- digit
--                           ; return (digitToInt d)
--                           })
--   </pre>
option :: a -> GenParser tok st a -> GenParser tok st a

-- | <tt>optionMaybe p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it return <a>Nothing</a>, otherwise it
--   returns <a>Just</a> the value returned by <tt>p</tt>.
optionMaybe :: GenParser tok st a -> GenParser tok st (Maybe a)

-- | <tt>optional p</tt> tries to apply parser <tt>p</tt>. It will parse
--   <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>.
optional :: GenParser tok st a -> GenParser tok st ()

-- | <tt>skipMany1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipMany1 :: GenParser tok st a -> GenParser tok st ()

-- | <tt>many1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: GenParser tok st a -> GenParser tok st [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]

-- | <tt>chainl p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a

-- | <tt>chainl1 p op x</tt> parser <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. . This parser can
--   for example be used to eliminate left recursion which typically occurs
--   in expression grammars.
--   
--   <pre>
--   expr    = term   `chainl1` addop
--   term    = factor `chainl1` mulop
--   factor  = parens expr &lt;|&gt; integer
--   
--   mulop   =   do{ symbol "*"; return (*)   }
--           &lt;|&gt; do{ symbol "/"; return (div) }
--   
--   addop   =   do{ symbol "+"; return (+) }
--           &lt;|&gt; do{ symbol "-"; return (-) }
--   </pre>
chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a

-- | <tt>chainr p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a

-- | <tt>chainr1 p op x</tt> parser <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: Show tok => GenParser tok st ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "&lt;!--"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
lookAhead :: GenParser tok st a -> GenParser tok st a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: Show tok => GenParser tok st tok


-- | A helper module to parse "expressions". Builds a parser given a table
--   of operators and associativities.
module Text.ParserCombinators.Parsec.Expr

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc

-- | This data type specifies operators that work on values of type
--   <tt>a</tt>. An operator is either binary infix or unary prefix or
--   postfix. A binary operator has also an associated associativity.
data Operator t st a
Infix :: (GenParser t st (a -> a -> a)) -> Assoc -> Operator t st a
Prefix :: (GenParser t st (a -> a)) -> Operator t st a
Postfix :: (GenParser t st (a -> a)) -> Operator t st a

-- | An <tt>OperatorTable s u m a</tt> is a list of <tt>Operator s u m
--   a</tt> lists. The list is ordered in descending precedence. All
--   operators in one list have the same precedence (but may have a
--   different associativity).
type OperatorTable t st a = [[Operator t st a]]

-- | <tt>buildExpressionParser table term</tt> builds an expression parser
--   for terms <tt>term</tt> with operators from <tt>table</tt>, taking the
--   associativity and precedence specified in <tt>table</tt> into account.
--   Prefix and postfix operators of the same precedence can only occur
--   once (i.e. <tt>--2</tt> is not allowed if <tt>-</tt> is prefix
--   negate). Prefix and postfix operators of the same precedence associate
--   to the left (i.e. if <tt>++</tt> is postfix increment, than
--   <tt>-2++</tt> equals <tt>-1</tt>, not <tt>-3</tt>).
--   
--   The <tt>buildExpressionParser</tt> takes care of all the complexity
--   involved in building expression parser. Here is an example of an
--   expression parser that handles prefix signs, postfix increment and
--   basic arithmetic.
--   
--   <pre>
--   expr    = buildExpressionParser table term
--           &lt;?&gt; "expression"
--   
--   term    =  parens expr
--           &lt;|&gt; natural
--           &lt;?&gt; "simple expression"
--   
--   table   = [ [prefix "-" negate, prefix "+" id ]
--             , [postfix "++" (+1)]
--             , [binary "*" (*) AssocLeft, binary "/" (div) AssocLeft ]
--             , [binary "+" (+) AssocLeft, binary "-" (-)   AssocLeft ]
--             ]
--   
--   binary  name fun assoc = Infix (do{ reservedOp name; return fun }) assoc
--   prefix  name fun       = Prefix (do{ reservedOp name; return fun })
--   postfix name fun       = Postfix (do{ reservedOp name; return fun })
--   </pre>
buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a


-- | Parsec, the Fast Monadic Parser combinator library, see
--   <a>http://www.cs.uu.nl/people/daan/parsec.html</a>.
--   
--   Inspired by:
--   
--   <ul>
--   <li>Graham Hutton and Erik Meijer: Monadic Parser Combinators.
--   Technical report NOTTCS-TR-96-4. Department of Computer Science,
--   University of Nottingham, 1996.
--   <a>http://www.cs.nott.ac.uk/~gmh/monparsing.ps</a></li>
--   <li>Andrew Partridge, David Wright: Predictive parser combinators need
--   four values to report errors. Journal of Functional Programming 6(2):
--   355-364, 1996</li>
--   </ul>
--   
--   This helper module exports elements from the basic libraries.
module Text.ParserCombinators.Parsec

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <tt>Text.Parsec.Prim.parse</tt>.
--   <tt>ParseError</tt> is an instance of the <a>Show</a> class.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos
type SourceName = String
type Line = Int
type Column = Int

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos


-- | A helper module to parse lexical elements (tokens).
module Text.ParserCombinators.Parsec.Token

-- | The <tt>LanguageDef</tt> type is a record that contains all
--   parameterizable features of the
--   <tt>Text.ParserCombinators.Parsec.Token</tt> module. The module
--   <tt>Text.ParserCombinators.Parsec.Language</tt> contains some default
--   definitions.
data LanguageDef st
LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [String] -> Bool -> LanguageDef st

-- | Describes the start of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "/*".
commentStart :: LanguageDef st -> String

-- | Describes the end of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "*/".
commentEnd :: LanguageDef st -> String

-- | Describes the start of a line comment. Use the empty string if the
--   language doesn't support line comments. For example "//".
commentLine :: LanguageDef st -> String

-- | Set to <a>True</a> if the language supports nested block comments.
nestedComments :: LanguageDef st -> Bool

-- | This parser should accept any start characters of identifiers. For
--   example <tt>letter &lt;|&gt; char "_"</tt>.
identStart :: LanguageDef st -> CharParser st Char

-- | This parser should accept any legal tail characters of identifiers.
--   For example <tt>alphaNum &lt;|&gt; char "_"</tt>.
identLetter :: LanguageDef st -> CharParser st Char

-- | This parser should accept any start characters of operators. For
--   example <tt>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</tt>
opStart :: LanguageDef st -> CharParser st Char

-- | This parser should accept any legal tail characters of operators. Note
--   that this parser should even be defined if the language doesn't
--   support user-defined operators, or otherwise the <a>reservedOp</a>
--   parser won't work correctly.
opLetter :: LanguageDef st -> CharParser st Char

-- | The list of reserved identifiers.
reservedNames :: LanguageDef st -> [String]

-- | The list of reserved operators.
reservedOpNames :: LanguageDef st -> [String]

-- | Set to <a>True</a> if the language is case sensitive.
caseSensitive :: LanguageDef st -> Bool

-- | The type of the record that holds lexical parsers.
data TokenParser st
TokenParser :: CharParser st String -> (String -> CharParser st ()) -> CharParser st String -> (String -> CharParser st ()) -> CharParser st Char -> CharParser st String -> CharParser st Integer -> CharParser st Integer -> CharParser st Double -> CharParser st (Either Integer Double) -> CharParser st Integer -> CharParser st Integer -> CharParser st Integer -> (String -> CharParser st String) -> (forall a. CharParser st a -> CharParser st a) -> CharParser st () -> (forall a. CharParser st a -> CharParser st a) -> (forall a. CharParser st a -> CharParser st a) -> (forall a. CharParser st a -> CharParser st a) -> (forall a. CharParser st a -> CharParser st a) -> (forall a. CharParser st a -> CharParser st a) -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st String -> (forall a. CharParser st a -> CharParser st [a]) -> (forall a. CharParser st a -> CharParser st [a]) -> (forall a. CharParser st a -> CharParser st [a]) -> (forall a. CharParser st a -> CharParser st [a]) -> TokenParser st

-- | This lexeme parser parses a legal identifier. Returns the identifier
--   string. This parser will fail on identifiers that are reserved words.
--   Legal identifier (start) characters and reserved words are defined in
--   the <a>LanguageDef</a> that is passed to <a>makeTokenParser</a>. An
--   <tt>identifier</tt> is treated as a single token using <a>try</a>.
identifier :: TokenParser st -> CharParser st String

-- | The lexeme parser <tt>reserved name</tt> parses <tt>symbol name</tt>,
--   but it also checks that the <tt>name</tt> is not a prefix of a valid
--   identifier. A <tt>reserved</tt> word is treated as a single token
--   using <a>try</a>.
reserved :: TokenParser st -> String -> CharParser st ()

-- | This lexeme parser parses a legal operator. Returns the name of the
--   operator. This parser will fail on any operators that are reserved
--   operators. Legal operator (start) characters and reserved operators
--   are defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>. An <tt>operator</tt> is treated as a single
--   token using <a>try</a>.
operator :: TokenParser st -> CharParser st String

-- | The lexeme parser <tt>reservedOp name</tt> parses <tt>symbol
--   name</tt>, but it also checks that the <tt>name</tt> is not a prefix
--   of a valid operator. A <tt>reservedOp</tt> is treated as a single
--   token using <a>try</a>.
reservedOp :: TokenParser st -> String -> CharParser st ()

-- | This lexeme parser parses a single literal character. Returns the
--   literal character value. This parsers deals correctly with escape
--   sequences. The literal character is parsed according to the grammar
--   rules defined in the Haskell report (which matches most programming
--   languages quite closely).
charLiteral :: TokenParser st -> CharParser st Char

-- | This lexeme parser parses a literal string. Returns the literal string
--   value. This parsers deals correctly with escape sequences and gaps.
--   The literal string is parsed according to the grammar rules defined in
--   the Haskell report (which matches most programming languages quite
--   closely).
stringLiteral :: TokenParser st -> CharParser st String

-- | This lexeme parser parses a natural number (a positive whole number).
--   Returns the value of the number. The number can be specified in
--   <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
natural :: TokenParser st -> CharParser st Integer

-- | This lexeme parser parses an integer (a whole number). This parser is
--   like <a>natural</a> except that it can be prefixed with sign (i.e. '-'
--   or '+'). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
integer :: TokenParser st -> CharParser st Integer

-- | This lexeme parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
float :: TokenParser st -> CharParser st Double

-- | This lexeme parser parses either <a>natural</a> or a <a>float</a>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
naturalOrFloat :: TokenParser st -> CharParser st (Either Integer Double)

-- | Parses a positive whole number in the decimal system. Returns the
--   value of the number.
decimal :: TokenParser st -> CharParser st Integer

-- | Parses a positive whole number in the hexadecimal system. The number
--   should be prefixed with "0x" or "0X". Returns the value of the number.
hexadecimal :: TokenParser st -> CharParser st Integer

-- | Parses a positive whole number in the octal system. The number should
--   be prefixed with "0o" or "0O". Returns the value of the number.
octal :: TokenParser st -> CharParser st Integer

-- | Lexeme parser <tt>symbol s</tt> parses <a>string</a> <tt>s</tt> and
--   skips trailing white space.
symbol :: TokenParser st -> String -> CharParser st String

-- | <tt>lexeme p</tt> first applies parser <tt>p</tt> and than the
--   <a>whiteSpace</a> parser, returning the value of <tt>p</tt>. Every
--   lexical token (lexeme) is defined using <tt>lexeme</tt>, this way
--   every parse starts at a point without white space. Parsers that use
--   <tt>lexeme</tt> are called <i>lexeme</i> parsers in this document.
--   
--   The only point where the <a>whiteSpace</a> parser should be called
--   explicitly is the start of the main parser in order to skip any
--   leading white space.
--   
--   <pre>
--   mainParser  = do{ whiteSpace
--                    ; ds &lt;- many (lexeme digit)
--                    ; eof
--                    ; return (sum ds)
--                    }
--   </pre>
lexeme :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | Parses any white space. White space consists of <i>zero</i> or more
--   occurrences of a <a>space</a>, a line comment or a block (multi line)
--   comment. Block comments may be nested. How comments are started and
--   ended is defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>.
whiteSpace :: TokenParser st -> CharParser st ()

-- | Lexeme parser <tt>parens p</tt> parses <tt>p</tt> enclosed in
--   parenthesis, returning the value of <tt>p</tt>.
parens :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | Lexeme parser <tt>braces p</tt> parses <tt>p</tt> enclosed in braces
--   ('{' and '}'), returning the value of <tt>p</tt>.
braces :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | Lexeme parser <tt>angles p</tt> parses <tt>p</tt> enclosed in angle
--   brackets ('&lt;' and '&gt;'), returning the value of <tt>p</tt>.
angles :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | Lexeme parser <tt>brackets p</tt> parses <tt>p</tt> enclosed in
--   brackets ('[' and ']'), returning the value of <tt>p</tt>.
brackets :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | DEPRECATED: Use <a>brackets</a>.
squares :: TokenParser st -> forall a. CharParser st a -> CharParser st a

-- | Lexeme parser |semi| parses the character ';' and skips any trailing
--   white space. Returns the string ";".
semi :: TokenParser st -> CharParser st String

-- | Lexeme parser <tt>comma</tt> parses the character ',' and skips any
--   trailing white space. Returns the string ",".
comma :: TokenParser st -> CharParser st String

-- | Lexeme parser <tt>colon</tt> parses the character ':' and skips any
--   trailing white space. Returns the string ":".
colon :: TokenParser st -> CharParser st String

-- | Lexeme parser <tt>dot</tt> parses the character '.' and skips any
--   trailing white space. Returns the string ".".
dot :: TokenParser st -> CharParser st String

-- | Lexeme parser <tt>semiSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
semiSep :: TokenParser st -> forall a. CharParser st a -> CharParser st [a]

-- | Lexeme parser <tt>semiSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
semiSep1 :: TokenParser st -> forall a. CharParser st a -> CharParser st [a]

-- | Lexeme parser <tt>commaSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep :: TokenParser st -> forall a. CharParser st a -> CharParser st [a]

-- | Lexeme parser <tt>commaSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep1 :: TokenParser st -> forall a. CharParser st a -> CharParser st [a]

-- | The expression <tt>makeTokenParser language</tt> creates a
--   <a>TokenParser</a> record that contains lexical parsers that are
--   defined using the definitions in the <tt>language</tt> record.
--   
--   The use of this function is quite stylized - one imports the
--   appropiate language definition and selects the lexical parsers that
--   are needed from the resulting <a>TokenParser</a>.
--   
--   <pre>
--   module Main where
--   
--   import Text.ParserCombinators.Parsec
--   import qualified Text.ParserCombinators.Parsec.Token as P
--   import Text.ParserCombinators.Parsec.Language (haskellDef)
--   
--   -- The parser
--   ...
--   
--   expr  =   parens expr
--         &lt;|&gt; identifier
--         &lt;|&gt; ...
--   
--   
--   -- The lexer
--   lexer       = P.makeTokenParser haskellDef
--   
--   parens      = P.parens lexer
--   braces      = P.braces lexer
--   identifier  = P.identifier lexer
--   reserved    = P.reserved lexer
--   ...
--   </pre>
makeTokenParser :: LanguageDef st -> TokenParser st


-- | A helper module that defines some language definitions that can be
--   used to instantiate a token parser (see
--   <a>Text.ParserCombinators.Parsec.Token</a>).
module Text.ParserCombinators.Parsec.Language

-- | The language definition for the Haskell language.
haskellDef :: LanguageDef st

-- | A lexer for the haskell language.
haskell :: TokenParser st

-- | The language definition for the language Mondrian.
mondrianDef :: LanguageDef st

-- | A lexer for the mondrian language.
mondrian :: TokenParser st
emptyDef :: LanguageDef st

-- | This is a minimal token definition for Haskell style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
haskellStyle :: LanguageDef st

-- | This is a minimal token definition for Java style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
javaStyle :: LanguageDef st

-- | The <tt>LanguageDef</tt> type is a record that contains all
--   parameterizable features of the
--   <tt>Text.ParserCombinators.Parsec.Token</tt> module. The module
--   <tt>Text.ParserCombinators.Parsec.Language</tt> contains some default
--   definitions.
data LanguageDef st
LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [String] -> Bool -> LanguageDef st

-- | Describes the start of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "/*".
commentStart :: LanguageDef st -> String

-- | Describes the end of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "*/".
commentEnd :: LanguageDef st -> String

-- | Describes the start of a line comment. Use the empty string if the
--   language doesn't support line comments. For example "//".
commentLine :: LanguageDef st -> String

-- | Set to <a>True</a> if the language supports nested block comments.
nestedComments :: LanguageDef st -> Bool

-- | This parser should accept any start characters of identifiers. For
--   example <tt>letter &lt;|&gt; char "_"</tt>.
identStart :: LanguageDef st -> CharParser st Char

-- | This parser should accept any legal tail characters of identifiers.
--   For example <tt>alphaNum &lt;|&gt; char "_"</tt>.
identLetter :: LanguageDef st -> CharParser st Char

-- | This parser should accept any start characters of operators. For
--   example <tt>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</tt>
opStart :: LanguageDef st -> CharParser st Char

-- | This parser should accept any legal tail characters of operators. Note
--   that this parser should even be defined if the language doesn't
--   support user-defined operators, or otherwise the <a>reservedOp</a>
--   parser won't work correctly.
opLetter :: LanguageDef st -> CharParser st Char

-- | The list of reserved identifiers.
reservedNames :: LanguageDef st -> [String]

-- | The list of reserved operators.
reservedOpNames :: LanguageDef st -> [String]

-- | Set to <a>True</a> if the language is case sensitive.
caseSensitive :: LanguageDef st -> Bool


-- | This module implements permutation parsers. The algorithm used is
--   fairly complex since we push the type system to its limits :-) The
--   algorithm is described in:
--   
--   <i>Parsing Permutation Phrases,</i> by Arthur Baars, Andres Loh and
--   Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
module Text.ParserCombinators.Parsec.Perm

-- | The type <tt>PermParser tok st a</tt> denotes a permutation parser
--   that, when converted by the <a>permute</a> function, parses
--   <tt>tok</tt> tokens with user state <tt>st</tt> and returns a value of
--   type <tt>a</tt> on success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>permute</a>.
data PermParser tok st a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",many1 (char 'a'))
--                          &lt;||&gt; char 'b'
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: PermParser tok st a -> GenParser tok st a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
