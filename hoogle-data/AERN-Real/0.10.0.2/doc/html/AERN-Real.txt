-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | arbitrary precision interval arithmetic for approximating exact real numbers
--   
--   Datatypes and abstractions for approximating exact real numbers and a
--   basic arithmetic over such approximations. The main datatype is
--   interval with arbitrary precision endpoints supported by safely
--   rounding field and elementary operations whose precision can be
--   increased arbitrarily, so that they all converge to the exact
--   operations.
--   
--   The design of the library is inspired to some degree by Mueller's
--   iRRAM and Lambov's RealLib (both are C++ libraries for exact real
--   arithmetic).
--   
--   For an architectural overview, see module <a>Data.Number.ER.Real</a>.
--   
--   Simple examples of usage can be found in folder <tt>examples</tt>.
--   
--   There is a built-in test suite and it can be evoked using the module
--   in the folder <tt>tests</tt>.
@package AERN-Real
@version 0.10.0.2


module Data.Number.ER.ShowHTML

-- | Render HTML is a way that can be inlined in Javascript strings etc.
showHTML :: (HTML t) => t -> String
renderHtmlNoHeader :: Html -> String
toHtmlDefault :: (Show a) => a -> Html
instance (HTML a) => HTML (Maybe a)


-- | Miscelaneous utilities related to concurrency.
module Data.Number.ER.Misc.STM


-- | A mini enumeration to represent the sign of different numbers and
--   approximations.
module Data.Number.ER.BasicTypes.PlusMinus
data PlusMinus
Minus :: PlusMinus
Plus :: PlusMinus
instance Typeable PlusMinus
instance Eq PlusMinus
instance Ord PlusMinus
instance Data PlusMinus
instance Binary PlusMinus
instance Show PlusMinus


-- | Miscelaneous utilities (eg related to Ordering, pairs, booleans,
--   strings)
module Data.Number.ER.Misc

-- | Compose as when defining the lexicographical ordering.
compareCompose :: Ordering -> Ordering -> Ordering

-- | Compose as when defining the lexicographical ordering.
compareComposeMany :: [Ordering] -> Ordering

-- | The lexicographical ordering.
compareLex :: (Ord a) => [a] -> [a] -> Ordering
compareListsWith :: (a -> a -> Ordering) -> [a] -> [a] -> Ordering
mapFst :: (a1 -> a2) -> (a1, b) -> (a2, b)
mapSnd :: (b1 -> b2) -> (a, b1) -> (a, b2)
mapPair :: (a1 -> a2, b1 -> b2) -> (a1, b1) -> (a2, b2)
mapPairHomog :: (a1 -> a2) -> (a1, a1) -> (a2, a2)
unpair :: [(a, a)] -> [a]
bool2maybe :: Bool -> Maybe ()
dropLast :: Int -> [a] -> [a]

-- | eg
--   
--   <pre>
--   concatWith "," ["a","b"] = "a,b"
--   </pre>
concatWith :: String -> [String] -> String

-- | eg
--   
--   <pre>
--   replicateSeveral [(2,"a"),(1,"b")] = "aab"
--   </pre>
replicateSeveral :: [(Int, a)] -> [a]

-- | eg
--   
--   <pre>
--   countDuplicates "aaba" = [(2,"a"),(1,"b"),(1,"a")]
--   </pre>
countDuplicates :: (Eq a) => [a] -> [(Int, a)]

-- | eg
--   
--   <pre>
--   allCombinations 
--       [
--        (1,['a']), 
--        (2,['b','c']), 
--        (3,['d','e','f'])
--       ] =
--           [
--            [(1,'a'),(2,'b'),(3,'d')], 
--            [(1,'a'),(2,'b'),(3,'e')],
--            [(1,'a'),(2,'b'),(3,'f')],
--            [(1,'a'),(2,'c'),(3,'d')], 
--            [(1,'a'),(2,'c'),(3,'e')],
--            [(1,'a'),(2,'c'),(3,'f')]
--           ]
--   </pre>
allCombinations :: [(k, [v])] -> [[(k, v)]]
allPairsCombinations :: [(k, (v, v))] -> [[(k, v)]]

-- | eg
--   
--   <pre>
--   allPairsCombinationsEvenOdd 
--       [
--        (1,('a0','a1'), 
--        (2,('b0','b1'), 
--        (3,('c0','c1')
--       ] =
--          ([
--            [(1,'a0'),(2,'b0'),(3,'c0')], 
--            [(1,'a0'),(2,'b1'),(3,'c1')], 
--            [(1,'a1'),(2,'b1'),(3,'c0')], 
--            [(1,'a1'),(2,'b0'),(3,'c1')] 
--           ]
--          ,[
--            [(1,'a0'),(2,'b0'),(3,'c1')], 
--            [(1,'a0'),(2,'b1'),(3,'c0')], 
--            [(1,'a1'),(2,'b0'),(3,'c0')], 
--            [(1,'a1'),(2,'b1'),(3,'c1')] 
--           ]
--          )
--   </pre>
allPairsCombinationsEvenOdd :: [(k, (v, v))] -> ([[(k, v)]], [[(k, v)]])
intLog :: (Num n1, Num n2, Ord n1, Integral n2) => n1 -> n1 -> (n2, n2)

-- | Directionally rounded versions of <tt>+,*,sum,prod</tt>.
plusDown :: (Num t) => t -> t -> t
timesUp :: (Num t) => t -> t -> t
timesDown :: (Num t) => t -> t -> t
plusUp :: (Num t) => t -> t -> t
divideDown :: (Fractional t) => t -> t -> t
divideUp :: (Fractional t) => t -> t -> t
sumDown :: (Num t) => [t] -> t
productDown :: (Num t) => [t] -> t
productUp :: (Num t) => [t] -> t
sumUp :: (Num t) => [t] -> t
readMaybe :: (Read a) => String -> Maybe a
showFirstLastLines :: (Show a) => Int -> Int -> a -> String
listUpdate :: Int -> a -> [a] -> [a]
listHasMatch :: (a -> Bool) -> [a] -> Bool


-- | Miscelaneous utilities related to testing.
module Data.Number.ER.Misc.Tests
instance Show TestResult


-- | An arbitrary sized integer type with additional +infinity and
--   -infinity.
--   
--   To be imported qualified, usually with prefix EI.
module Data.Number.ER.BasicTypes.ExtendedInteger
data ExtendedInteger
MinusInfinity :: ExtendedInteger
Finite :: Integer -> ExtendedInteger
PlusInfinity :: ExtendedInteger
isInfinite :: ExtendedInteger -> Bool

-- | the smallest integer i for which 2^i &lt;= abs n
binaryLog :: ExtendedInteger -> ExtendedInteger
take :: ExtendedInteger -> [a] -> [a]
instance Eq ExtendedInteger
instance Integral ExtendedInteger
instance Real ExtendedInteger
instance Enum ExtendedInteger
instance Num ExtendedInteger
instance Ord ExtendedInteger
instance Show ExtendedInteger


-- | auxiliary types for exact real number processing
module Data.Number.ER.BasicTypes

-- | Precision represents an upper bound on the measure of an approximation
--   viewed as a set; not to be confused with the precision of an
--   <tt>Data.Number.ER.Real.Base.Float.ERFloat</tt> and similar.
--   
--   In an approximation comprising a number of instances of
--   <tt>Data.Number.ER.Real.Base.ERRealBase</tt>, we will refer to the
--   bit-precision of these base components as the <a>Granularity</a> of
--   the approximation.
type Precision = ExtendedInteger

-- | The bit size of the floating point numbers (or similar) used
--   internally in real number and function approximations.
type Granularity = Int
prec2gran :: Precision -> Granularity

-- | This type synonym should be used for funciton parameter(s) that guide
--   the convergence of the function's result to a perfect (exact) result.
--   
--   The name should remind us that there is no universally valid
--   relationship between this integer the quality (precision) of the
--   result. The only condition usually assumed is that in the limit when
--   the effort index rises to infinity, the result should be exact.
type EffortIndex = Integer
effIx2gran :: EffortIndex -> Granularity
effIx2prec :: EffortIndex -> Precision
effIx2int :: EffortIndex -> Int
int2effIx :: Int -> EffortIndex
prec2effIx :: Precision -> EffortIndex
gran2effIx :: Granularity -> EffortIndex


-- | Abstractions of the <tt>Box</tt> datatype, often used to represent
--   sections of multi-dimensional function domains.
--   
--   To be imported qualified, usually with prefix DBox.
--   
--   VariableID(..) and DomainBox are usually imported separately and not
--   qualified.
module Data.Number.ER.BasicTypes.DomainBox

-- | A class abstracting a type of variable identifiers for axes in
--   function domains, polynomials etc.
class (Ord varid) => VariableID varid
newVarID :: (VariableID varid) => Set varid -> varid
defaultVar :: (VariableID varid) => varid
showVar :: (VariableID varid) => varid -> String
getNVars :: (VariableID varid) => Int -> [varid]

-- | A class abstracting a type of many-dimensional points, intervals or
--   anything indexed by a subset of dimensions.
--   
--   More generally, this class abstracts most of <tt>Data.Map.Map</tt>.
class (VariableID varid) => DomainBox box varid val | box -> varid val, varid val -> box
noinfo :: (DomainBox box varid val) => box
isNoinfo :: (DomainBox box varid val) => box -> Bool
size :: (DomainBox box varid val) => box -> Int
unary :: (DomainBox box varid val) => val -> box
singleton :: (DomainBox box varid val) => varid -> val -> box
toList :: (DomainBox box varid val) => box -> [(varid, val)]
fromList :: (DomainBox box varid val) => [(varid, val)] -> box
toAscList :: (DomainBox box varid val) => box -> [(varid, val)]
fromAscList :: (DomainBox box varid val) => [(varid, val)] -> box
compare :: (DomainBox box varid val) => (val -> val -> Ordering) -> box -> box -> Ordering
adjust :: (DomainBox box varid val) => (val -> val) -> varid -> box -> box
insert :: (DomainBox box varid val) => varid -> val -> box -> box
insertWith :: (DomainBox box varid val) => (val -> val -> val) -> varid -> val -> box -> box
delete :: (DomainBox box varid val) => varid -> box -> box
member :: (DomainBox box varid val) => varid -> box -> Bool
notMember :: (DomainBox box varid val) => varid -> box -> Bool
union :: (DomainBox box varid val) => box -> box -> box
unionWith :: (DomainBox box varid val) => (val -> val -> val) -> box -> box -> box
keys :: (DomainBox box varid val) => box -> [varid]
elems :: (DomainBox box varid val) => box -> [val]
filter :: (DomainBox box varid val) => (val -> Bool) -> box -> box
fold :: (DomainBox box varid val) => (val -> a -> a) -> a -> box -> a
foldWithKey :: (DomainBox box varid val) => (varid -> val -> a -> a) -> a -> box -> a
zipWith :: (DomainBox box varid val) => (val -> val -> a) -> box -> box -> [(varid, a)]
zipWithDefault :: (DomainBox box varid val) => val -> (val -> val -> a) -> box -> box -> [(varid, a)]
zipWithDefaultSecond :: (DomainBox box varid val) => val -> (val -> val -> a) -> box -> box -> [(varid, a)]
findWithDefault :: (DomainBox box varid val) => val -> varid -> box -> val
lookup :: (DomainBox box varid val) => String -> varid -> box -> val

-- | A class linking two domain box types that share the index type so that
--   boxes of the two types can be converted etc.
class (DomainBox box1 varid val1, DomainBox box2 varid val2) => DomainBoxMappable box1 box2 varid val1 val2
map :: (DomainBoxMappable box1 box2 varid val1 val2) => (val1 -> val2) -> box1 -> box2
mapWithKey :: (DomainBoxMappable box1 box2 varid val1 val2) => (varid -> val1 -> val2) -> box1 -> box2
intersectionWith :: (DomainBoxMappable box1 box2 varid val1 val2) => (val1 -> val2 -> val1) -> box1 -> box2 -> box1
difference :: (DomainBoxMappable box1 box2 varid val1 val2) => box1 -> box2 -> box1

-- | A class abstracting a type of many-dimensional intervals.
class (DomainBox box varid ira) => DomainIntBox box varid ira | box -> varid ira, varid ira -> box
compatible :: (DomainIntBox box varid ira) => box -> box -> Bool
unify :: (DomainIntBox box varid ira) => String -> box -> box -> box
bestSplit :: (DomainIntBox box varid ira) => box -> (varid, (ira, ira))
split :: (DomainIntBox box varid ira) => box -> varid -> Maybe ira -> (box, box)
classifyPosition :: (DomainIntBox box varid ira) => box -> box -> (Bool, Bool, Bool, Bool)


-- | Definitions of classes that describe what is required from arbitrary
--   precision approximations of exact real numbers.
--   
--   We introduce two levels of abstraction for these approximations:
--   
--   <ul>
--   <li><a>ERApprox</a> = Approximating a real number by a *set* of real
--   numbers that includes the approximated number. Precision is measured
--   using some fixed measure on the sets. Operations are <a>safe</a> wrt
--   inclusion. The sets can sometimes be <a>anti-consistent</a> - being
--   smaller than the empty set in the inclusion order.</li>
--   <li><a>ERInnerOuterApprox</a> = Like <a>ERApprox</a> with the addition
--   of operations that are <a>inner rounded</a> in the sense that each
--   element of the rounded result set can be obtained by the same
--   operation performed on some elements of the arument set(s).</li>
--   <li><a>ERIntApprox</a> = Like ERApprox but assuming that the sets are
--   *intervals* of real numbers with finitely representable
--   endpoints.</li>
--   </ul>
--   
--   To be imported qualified, usually with the synonym RA.
module Data.Number.ER.Real.Approx

-- | A type whose elements represent sets that can be used to approximate a
--   single extended real number with arbitrary precision.
--   
--   Operations are <a>safe</a> with respect to inclusion, which means that
--   for any numbers admitted by the operand approximations the result of
--   the operation is admitted by the result approximation.
--   
--   The sets can sometimes be <a>anti-consistent</a> - being smaller than
--   the empty set in the inclusion order. This can be understood as
--   indicating that not only there is no correct real number approximated
--   here, but some numbers (ie those in interior of the set) are excluded
--   more strongly than the others. Prime examples of such sets are
--   directed <a>inverted</a> intervals such as [2,1]. Such sets arise
--   naturally from <a>inner rounded</a> operations - see
--   <a>ERInnerOuterApprox</a>.
class (Fractional ra) => ERApprox ra
initialiseBaseArithmetic :: (ERApprox ra) => ra -> IO ()
getPrecision :: (ERApprox ra) => ra -> Precision
getGranularity :: (ERApprox ra) => ra -> Granularity
setGranularityOuter :: (ERApprox ra) => Granularity -> ra -> ra
setMinGranularityOuter :: (ERApprox ra) => Granularity -> ra -> ra
isBottom :: (ERApprox ra) => ra -> Bool
bottomApprox :: (ERApprox ra) => ra
isExact :: (ERApprox ra) => ra -> Bool
isConsistent :: (ERApprox ra) => ra -> Bool
isAnticonsistent :: (ERApprox ra) => ra -> Bool
toggleConsistency :: (ERApprox ra) => ra -> ra
isTop :: (ERApprox ra) => ra -> Bool
topApprox :: (ERApprox ra) => ra
isDisjoint :: (ERApprox ra) => ra -> ra -> Bool
isInteriorDisjoint :: (ERApprox ra) => ra -> ra -> Bool
isBounded :: (ERApprox ra) => ra -> Bool
plusInfinity :: (ERApprox ra) => ra
refines :: (ERApprox ra) => ra -> ra -> Bool
maybeRefines :: (ERApprox ra) => ra -> ra -> Maybe Bool
(/\) :: (ERApprox ra) => ra -> ra -> ra
intersectMeasureImprovement :: (ERApprox ra) => EffortIndex -> ra -> ra -> (ra, ra)
equalReals :: (ERApprox ra) => ra -> ra -> Maybe Bool
compareReals :: (ERApprox ra) => ra -> ra -> Maybe Ordering
leqReals :: (ERApprox ra) => ra -> ra -> Maybe Bool
equalApprox :: (ERApprox ra) => ra -> ra -> Bool
compareApprox :: (ERApprox ra) => ra -> ra -> Ordering
double2ra :: (ERApprox ra) => Double -> ra
showApprox :: (ERApprox ra) => Int -> Bool -> Bool -> ra -> String

-- | Assuming the arguments are singletons, equality is decidable.
eqSingletons :: (ERApprox ra) => ra -> ra -> Bool

-- | Assuming the arguments are singletons, <tt>&lt;=</tt> is decidable.
leqSingletons :: (ERApprox ra) => ra -> ra -> Bool

-- | Assuming the arguments are singletons, <tt>&lt;</tt> is decidable.
ltSingletons :: (ERApprox ra) => ra -> ra -> Bool

-- | This function converts an effort index to a real number approximation.
--   
--   Useful when an effort index is used in a formula mixed with real
--   approximations.
effIx2ra :: (ERApprox ra) => EffortIndex -> ra

-- | A type whose elements represent some kind of nominal sets of real
--   numbers over which one can perform two kinds of arithmetic:
--   
--   <ul>
--   <li><a>outer rounded</a>: arithmetic that approximates maximal
--   extensions from outside (ie the <a>ERApprox</a> arithmetic)</li>
--   <li><a>inner rounded</a>: arithmetic that approximates maximal
--   extensions from inside, potentially leading to anti-consistent set
--   specifications (eg intervals whose endpoints are not in the usual
--   order)</li>
--   </ul>
--   
--   Another explanation of the difference:
--   
--   <ul>
--   <li><tt>outer</tt>: the approximation contains all the number(s) of
--   interest * <tt>inner</tt>: all numbers eligible for the approximation
--   are numbers of interest</li>
--   </ul>
--   
--   Ie inner rounded operations have the property that each real number
--   admitted by the result can be obtained as the exact result of the same
--   operation performed on some real numbers admitted by the operand
--   approximations.
--   
--   While in <a>outer rounded</a> operations it is desirable to make the
--   result set as small as possible in order to reduce the amount of bogus
--   result numbers, in <a>inner rounded</a> operations it is desirable to
--   make the result set as large as possible to lose less of the genuinely
--   feasible result numbers.
--   
--   Inner rounded arithmetic is useful eg for proving/disproving
--   inclusions <a>f(x) subset g(x)</a> where f and g are expressions using
--   arithmetic extended to sets. For proving the inclusion, we need an
--   inner rounded approximation of g(x) and for disproving the inclusion
--   we need an inner rounded approximation of f(x).
--   
--   This is an abstraction of Kaucher's extended interval arithmetic
--   [Kaucher, E.: Interval Analysis in the Extended Interval Space IR,
--   Computing, Suppl. 2, 1980, pp. 33-49].
class (ERApprox xra) => ERInnerOuterApprox xra
(+:) :: (ERInnerOuterApprox xra) => xra -> xra -> xra
(-:) :: (ERInnerOuterApprox xra) => xra -> xra -> xra
(*:) :: (ERInnerOuterApprox xra) => xra -> xra -> xra
(/:) :: (ERInnerOuterApprox xra) => xra -> xra -> xra
setGranularityInner :: (ERInnerOuterApprox xra) => Granularity -> xra -> xra
setMinGranularityInner :: (ERInnerOuterApprox xra) => Granularity -> xra -> xra

-- | A type whose elements represent sets that can be used to approximate a
--   recursive set of closed extended real number intervals with arbitrary
--   precision.
--   
--   A type whose elements represent real *intervals* that can be used to
--   approximate a single extended real number with arbitrary precision.
--   
--   Sometimes, these types can be used to approximate a closed extended
--   real number interval with arbitrary precision. Nevetheless, this is
--   not guaranteed.
class (ERApprox ira) => ERIntApprox ira
doubleBounds :: (ERIntApprox ira) => ira -> (Double, Double)
floatBounds :: (ERIntApprox ira) => ira -> (Float, Float)
integerBounds :: (ERIntApprox ira) => ira -> (ExtendedInteger, ExtendedInteger)
bisectDomain :: (ERIntApprox ira) => Maybe ira -> ira -> (ira, ira)
defaultBisectPt :: (ERIntApprox ira) => ira -> ira
bounds :: (ERIntApprox ira) => ira -> (ira, ira)
fromBounds :: (ERIntApprox ira) => (ira, ira) -> ira
(\/) :: (ERIntApprox ira) => ira -> ira -> ira

-- | Split an interval to a sequence of intervals whose union is the
--   original interval using a given sequence of cut points. The cut points
--   are expected to be in increasing order and contained in the given
--   interval. Violations of this rule are tolerated.
splitIRA :: (ERIntApprox ira) => ira -> [ira] -> [ira]

-- | Return true if and only if the two intervals have equal endpoints.
equalIntervals :: (ERIntApprox ira) => ira -> ira -> Bool

-- | <ul>
--   <li>Return the endpoints of the interval as well as the exact
--   midpoint.</li>
--   <li>To be able to do this, there may be a need to increase
--   granularity.</li>
--   <li>All three singleton intervals are set to the same new
--   granularity.</li>
--   </ul>
exactMiddle :: (ERIntApprox ira) => ira -> (ira, ira, ira, Granularity)

-- | This produces a function that computes the maximal extension of the
--   given function. A maximal extension function has the property: f(I) =
--   { f(x) | x in I }. Here we get this property only for the limit
--   function for its <a>EffortIndex</a> tending to infinity. For finite
--   effor indices the function may add *outer* rounding but it should be
--   reasonably small.
maxExtensionR2R :: (ERIntApprox ira) => (EffortIndex -> ira -> [ira]) -> (EffortIndex -> ira -> ira) -> (EffortIndex -> ira -> ira)

-- | This produces a function that computes the maximal extension of the
--   given function. A maximal extension function has the property: f(I) =
--   { f(x) | x in I }. Here we get this property only for the limit
--   function for its <a>EffortIndex</a> tending to infinity. For finite
--   effor indices the function may include *inner* rounding but it should
--   be reasonably small.
maxExtensionInnerR2R :: (ERIntApprox ira) => (EffortIndex -> ira -> [ira]) -> (EffortIndex -> ira -> ira) -> (EffortIndex -> ira -> ira)

-- | A type whose elements are thought of as sets of approximations of real
--   numbers.
--   
--   Eg intervals of intervals, eg [[0,3],[1,2]] containing all intervals
--   whose left endpoint is between 0 and 1 and the right endpoint is
--   between 2 and 3. The upper bound interval can sometimes be
--   anti-consistent, eg [[0,3],[2,1]] containing all intervals (consistent
--   as well as anti-consistent) with a left endpoint between [0,2] and the
--   right endpoint between [1,3].
class ERApproxApprox xra
safeIncludes :: (ERApproxApprox xra) => xra -> xra -> Bool
safeNotIncludes :: (ERApproxApprox xra) => xra -> xra -> Bool
includes :: (ERApproxApprox xra) => xra -> xra -> Maybe Bool


-- | A simple implementation of the <a>VariableID</a> and <a>DomainBox</a>
--   classes.
module Data.Number.ER.BasicTypes.DomainBox.IntMap
type VarID = Int
type Box ira = IntMap ira
instance (ERIntApprox ira) => DomainIntBox (Box ira) VarID ira
instance (Show val1, Show val2) => DomainBoxMappable (Box val1) (Box val2) VarID val1 val2
instance (Show val) => DomainBox (Box val) VarID val
instance VariableID VarID


-- | This module offers a transformation of a safely rounded real
--   approximation type into a type that approximates these approximations
--   from outside as well as *inside*.
module Data.Number.ER.Real.Approx.OI

-- | A pair of approximations that form an <a>interval</a> in the lattice
--   of approximations.
--   
--   Eg outer = [1,4] inner = [3,2] can be thought of as the set of all
--   generalised intervals where the left endpoint is between 1 and 3 and
--   the right endpoint is between 2 and 4 (eg [1,4], [3,4], [3,2], [3,3]).
data ERApproxOI ra
ERApproxOI :: ra -> ra -> ERApproxOI ra
eroiOuter :: ERApproxOI ra -> ra
eroiInner :: ERApproxOI ra -> ra
instance (Eq ra) => Eq (ERApproxOI ra)
instance (Ord ra) => Ord (ERApproxOI ra)
instance (ERApprox ra) => ERApprox (ERApproxOI ra)
instance (ERApprox ra) => Fractional (ERApproxOI ra)
instance (ERApprox ra) => Num (ERApproxOI ra)
instance (ERApprox ra) => ERApproxApprox (ERApproxOI ra)
instance (ERApprox ra) => Show (ERApproxOI ra)

module Data.Number.ER.Real.Approx.Tests.Reporting
unsafeERTestReport :: (Show tId, Show sId, ERIntApprox ira) => String -> (tId, sId, ira, ira) -> a -> a
getOverestimation :: (ERIntApprox ira) => ira -> ira -> (Double, (ira, ira))
produceSummary :: String -> IO ()


-- | Instances of Arbitrary so that values can be randomly generated for
--   use in QuickCheck tests.
module Data.Number.ER.BasicTypes.Tests.Generate
data Nat10
Nat10 :: Int -> Nat10
data Nat100
Nat100 :: Int -> Nat100
data Ix10
Ix10 :: EffortIndex -> Ix10
data Ix20
Ix20 :: EffortIndex -> Ix20
data Gran100
Gran100 :: Granularity -> Gran100
data Gran1000
Gran1000 :: Granularity -> Gran1000
data SmallRatio
SmallRatio :: Int -> Int -> SmallRatio
instance Show SmallRatio
instance Show Gran1000
instance Show Gran100
instance Show Ix20
instance Show Ix10
instance Show Nat100
instance Show Nat10
instance Arbitrary SmallRatio
instance Arbitrary PlusMinus
instance Arbitrary Ix10
instance Arbitrary Ix20
instance Arbitrary Nat100
instance Arbitrary Nat10


-- | Types and methods related to explicit convergent sequences of real
--   number approximations.
module Data.Number.ER.Real.Approx.Sequence

-- | A converging sequence of real number approximations.
--   
--   <ul>
--   <li>Every finite subsequence has a non-empty intersection.</li>
--   <li>The limit should be a singleton.</li>
--   </ul>
data ConvergRealSeq ra
ConvergRealSeq :: (EffortIndex -> ra) -> ConvergRealSeq ra

-- | Turn an arbitrary convergent sequence into one with a guaranteed
--   convergence rate - the precision (as defined by
--   <tt>RA.ERApprox.RA.getPrecision</tt>) of x_ix is at least ix.
makeFastConvergRealSeq :: (ERApprox ra) => (ConvergRealSeq ra) -> (ConvergRealSeq ra)

-- | Using this operator, a unary funtion working over approximations can
--   be converted to one that works over exact numbers represented through
--   a sequence of approximations.
convertFuncRA2Seq :: (EffortIndex -> ra -> ra) -> (ConvergRealSeq ra) -> (ConvergRealSeq ra)

-- | The same as above, where f is binary
convertBinFuncRA2Seq :: (EffortIndex -> ra -> ra -> ra) -> (ConvergRealSeq ra) -> (ConvergRealSeq ra) -> (ConvergRealSeq ra)
convergRealSeqElem :: (ConvergRealSeq ra) -> EffortIndex -> ra

-- | Show function for ConvergRealSeq's with full arguments.
showConvergRealSeq :: (ERApprox ra) => Int -> Bool -> Bool -> Precision -> (ConvergRealSeq ra) -> String

-- | Show function for ConvergRealSeq's with all parameters fixed except
--   for number of digits
showConvergRealSeqAuto :: (ERApprox ra) => Int -> (ConvergRealSeq ra) -> String
instance (ERApprox ra) => Fractional (ConvergRealSeq ra)
instance (ERApprox ra) => Num (ConvergRealSeq ra)
instance (ERApprox ra) => Ord (ConvergRealSeq ra)
instance (ERApprox ra) => Eq (ConvergRealSeq ra)
instance (ERApprox ra) => Show (ConvergRealSeq ra)


-- | Taylor series related functions.
module Data.Number.ER.Real.Arithmetic.Taylor
erTaylor_R :: (ERIntApprox ira) => EffortIndex -> (Int -> ira) -> (Int -> ira) -> ira -> ira -> ira
erTaylor_R_FullArgs :: (ERIntApprox ira) => (Int -> ira) -> (Int -> ira) -> Int -> ira -> Granularity -> ira -> ira

-- | A Taylor series for exponentiation.
erExp_Tay_Opt_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira

-- | A Taylor series for sine.
erSine_Tay_Opt_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira

-- | A Taylor series for cosine.
erCosine_Tay_Opt_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira


-- | Interval Newton's method for root finding.
--   
--   To be used for obtaining functions out of their inverse(s) over
--   various intervals.
module Data.Number.ER.Real.Arithmetic.Newton
erNewton_FullArgs :: (ERIntApprox ira) => (EffortIndex -> ira -> ira, EffortIndex -> ira -> ira) -> ira -> ira -> Int -> EffortIndex -> ira

-- | Modified Newton Method Notes:
--   
--   <ol>
--   <li>It has a cubic convergence speed, as opposed to the original
--   Newton's square convergence speed.</li>
--   <li>It does not deal with multiple roots.</li>
--   <li>Per iteration, it makes two queries on the derivative, so it best
--   suits the cases where computation of the derivative is at most as
--   expensive as the function itself.</li>
--   </ol>
erNewton_mdfd_FullArgs :: (ERIntApprox ira) => (EffortIndex -> ira -> ira, EffortIndex -> ira -> ira) -> ira -> ira -> Int -> EffortIndex -> ira


-- | Abstraction over various fixed and floating point types as well as
--   rational numbers.
--   
--   This module should be included qualified as is often given the local
--   synonym B.
module Data.Number.ER.Real.Base

-- | This class is an abstraction of a subset of real numbers with *upwards
--   rounded* operations.
class (RealFrac rb, Ord rb) => ERRealBase rb
typeName :: (ERRealBase rb) => rb -> String
initialiseBaseArithmetic :: (ERRealBase rb) => rb -> IO ()
defaultGranularity :: (ERRealBase rb) => rb -> Granularity
getApproxBinaryLog :: (ERRealBase rb) => rb -> ExtendedInteger
getGranularity :: (ERRealBase rb) => rb -> Granularity
setMinGranularity :: (ERRealBase rb) => Granularity -> rb -> rb
setGranularity :: (ERRealBase rb) => Granularity -> rb -> rb
getMaxRounding :: (ERRealBase rb) => rb -> rb
isERNaN :: (ERRealBase rb) => rb -> Bool
erNaN :: (ERRealBase rb) => rb
isPlusInfinity :: (ERRealBase rb) => rb -> Bool
isMinusInfinity :: (ERRealBase rb) => rb -> Bool
plusInfinity :: (ERRealBase rb) => rb
minusInfinity :: (ERRealBase rb) => rb
fromIntegerUp :: (ERRealBase rb) => Integer -> rb
fromIntegerDown :: (ERRealBase rb) => Integer -> rb
fromDouble :: (ERRealBase rb) => Double -> rb
toDouble :: (ERRealBase rb) => rb -> Double
fromFloat :: (ERRealBase rb) => Float -> rb
toFloat :: (ERRealBase rb) => rb -> Float
showDiGrCmp :: (ERRealBase rb) => Int -> Bool -> Bool -> rb -> String


-- | Make <a>Double</a> an instance of <a>ERRealBase</a> as much as
--   possible.
module Data.Number.ER.Real.Base.MachineDouble

-- | Set machine floating point unit to the upwards-directed rounding mode.
--   
--   This procedure has to be executed before using <a>Double</a> as a
--   basis for interval and polynomial arithmetic defined in this package.
initMachineDouble :: IO ()
instance ERRealBase Double


-- | Make Ales Bizjak's Haskell interface to MPFR an instance of
--   <a>ERRealBase</a>.
--   
--   If compiled without USE_MPFR, this module is empty.
module Data.Number.ER.Real.Base.MPFR


-- | Unlimited size rational numbers extended with signed infinities and
--   NaN.
--   
--   These can serve as endpoints of
--   <tt>Data.Number.ER.Real.Approx.Interval.ERInterval</tt>.
--   
--   To be imported qualified, usually with prefix ERAT.
module Data.Number.ER.Real.Base.Rational
data ExtendedRational
NaN :: ExtendedRational
Infinity :: PlusMinus -> ExtendedRational
Finite :: Rational -> ExtendedRational
instance Typeable ExtendedRational
instance Data ExtendedRational
instance ERRealBase ExtendedRational
instance RealFrac ExtendedRational
instance Real ExtendedRational
instance Fractional ExtendedRational
instance Num ExtendedRational
instance Ord ExtendedRational
instance Eq ExtendedRational
instance Show ExtendedRational
instance Binary ExtendedRational


-- | Some important elementary functions for real approximations and their
--   maximal extensions for interval approximations.
module Data.Number.ER.Real.Arithmetic.Elementary
erSqr_R :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erSqr_IR :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erPow_R :: (ERIntApprox ira, Ord ira) => EffortIndex -> Integer -> ira -> ira
erPow_IR :: (ERIntApprox ira, Ord ira) => EffortIndex -> Integer -> ira -> ira
erSqrt_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erSqrt_IR :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erSqrt_IR_Inner :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erRoot_R :: (ERIntApprox ira, Ord ira) => EffortIndex -> Integer -> ira -> ira
erRoot_IR :: (ERIntApprox ira, Ord ira) => EffortIndex -> Integer -> ira -> ira
erRoot_IR_Inner :: (ERIntApprox ira, Ord ira) => EffortIndex -> Integer -> ira -> ira
erExp_R :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erExp_IR :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erExp_IR_Inner :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erLog_R :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erLog_IR :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erLog_IR_Inner :: (ERIntApprox ira, Ord ira) => EffortIndex -> ira -> ira
erSine_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erSine_IR :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erSine_IR_Inner :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erCosine_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erCosine_IR :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erCosine_IR_Inner :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erATan_R :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erATan_IR :: (ERIntApprox ira) => EffortIndex -> ira -> ira
erATan_IR_Inner :: (ERIntApprox ira) => EffortIndex -> ira -> ira

-- | pi using Bellard's formula
--   
--   Convergence properties:
--   
--   <ul>
--   <li>shrinking sequence</li>
--   <li>rate at least 2^(-i).</li>
--   </ul>
erPi_R :: (ERIntApprox ira) => EffortIndex -> ira


-- | To be imported qualified, usually with the synonym RAEL.
module Data.Number.ER.Real.Approx.Elementary

-- | A class defining various common real number operations in a
--   approximation-aware fashion, ie introducing effort indices.
--   
--   All operations here have default implementations based on
--   <a>Data.Number.ER.Real.Arithmetic.Elementary</a>.
class (ERIntApprox ra, Ord ra) => ERApproxElementary ra
abs :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
min :: (ERApproxElementary ra) => EffortIndex -> ra -> ra -> ra
max :: (ERApproxElementary ra) => EffortIndex -> ra -> ra -> ra
sqrt :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
exp :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
log :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
(**) :: (ERApproxElementary ra) => EffortIndex -> ra -> ra -> ra
pi :: (ERApproxElementary ra) => EffortIndex -> ra
sin :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
cos :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
tan :: (ERApproxElementary ra) => EffortIndex -> ra -> ra
atan :: (ERApproxElementary ra) => EffortIndex -> ra -> ra

-- | A class defining various common real number operations in a
--   approximation-aware fashion, ie introducing effort indices.
--   
--   All operations here have default implementations based on
--   <a>Data.Number.ER.Real.Arithmetic.Elementary</a>.
class (ERIntApprox ra, ERInnerOuterApprox ra, Ord ra) => ERInnerOuterApproxElementary ra
absInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
minInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra -> ra
maxInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra -> ra
sqrtInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
expInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
logInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
(**:) :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra -> ra
sinInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
cosInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
tanInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra
atanInner :: (ERInnerOuterApproxElementary ra) => EffortIndex -> ra -> ra


-- | Simple integration methods for Haskell functions operating on real
--   number approximations.
module Data.Number.ER.Real.Arithmetic.Integration
integrateCont :: (ERIntApprox ira) => (EffortIndex -> ira -> ira) -> (ConvergRealSeq ira) -> (ConvergRealSeq ira) -> (ConvergRealSeq ira)

-- | naive integration, using a partition of 2 * prec equally sized
--   intervals
integrateCont_R :: (ERIntApprox ira) => (EffortIndex -> ira -> ira) -> EffortIndex -> (ira) -> (ira) -> (ira)

-- | integration using divide and conquer adaptive partitioning
integrateContAdapt_R :: (ERIntApprox ira) => (EffortIndex -> ira -> ira) -> EffortIndex -> (ira) -> (ira) -> (ira)


-- | This module defines an arbitrary precision interval type and most of
--   its interval arithmetic operations.
module Data.Number.ER.Real.Approx.Interval

-- | Type for arbitrary precision interval arithmetic.
data ERInterval base
ERInterval :: !base -> !base -> ERInterval base
erintv_left :: ERInterval base -> !base
erintv_right :: ERInterval base -> !base

-- | convert to a normal form, ie:
--   
--   <ul>
--   <li>no NaNs as endpoints</li>
--   </ul>
--   
--   Note that inverted intervals are fully supported using Warmus-Kaucher
--   arithmetic. This version interprets NaN's as bottomApprox.
normaliseERIntervalOuter :: (ERRealBase b) => ERInterval b -> ERInterval b

-- | convert to a normal form, ie:
--   
--   <ul>
--   <li>no NaNs as endpoints</li>
--   </ul>
--   
--   Note that inverted intervals are fully supported using Warmus-Kaucher
--   arithmetic. This version interprets NaN's as topApprox.
normaliseERIntervalInner :: (ERRealBase b) => ERInterval b -> ERInterval b
instance Typeable1 ERInterval
instance (Data base) => Data (ERInterval base)
instance (ERRealBase b) => ERInnerOuterApproxElementary (ERInterval b)
instance (ERRealBase b) => ERApproxElementary (ERInterval b)
instance (ERRealBase b) => ERIntApprox (ERInterval b)
instance (ERRealBase b) => ERApprox (ERInterval b)
instance (ERRealBase b) => ERInnerOuterApprox (ERInterval b)
instance (ERRealBase b) => Fractional (ERInterval b)
instance (ERRealBase b) => Num (ERInterval b)
instance (ERRealBase b, HTML b) => HTML (ERInterval b)
instance (ERRealBase b) => Show (ERInterval b)
instance (ERRealBase b) => Ord (ERInterval b)
instance (ERRealBase b) => Eq (ERInterval b)
instance (Binary a) => Binary (ERInterval a)


-- | Generic instances of <a>Arbitrary</a> class for generating (almost)
--   random instances.
module Data.Number.ER.Real.Approx.Tests.Generate
newtype RAThin ira
RAThin :: ira -> RAThin ira
newtype RAConsistent ira
RAConsistent :: ira -> RAConsistent ira
newtype RADirected ira
RADirected :: ira -> RADirected ira
constructThinRA :: (ERIntApprox ra) => Granularity -> Int -> (Double, Double, Double) -> Int -> ra
instance (Show ira) => Show (RADirected ira)
instance (Show ira) => Show (RAConsistent ira)
instance (Show ira) => Show (RAThin ira)
instance (ERIntApprox ira) => Arbitrary (RADirected ira)
instance (ERIntApprox ira) => Arbitrary (RAConsistent ira)
instance (ERIntApprox ira) => Arbitrary (RAThin ira)


-- | Properties of real approximations we want to check in tests.
module Data.Number.ER.Real.Approx.Tests.Properties
type RAPropTupleUnary ira = ira -> String -> ((Ix20, RAThin ira) -> Bool, (Ix20, RAConsistent ira) -> Bool, (Ix20, RAThin ira) -> Bool, (Ix20, RAConsistent ira) -> Bool, (Ix20, RADirected ira) -> Bool)
props_ra_AMinusA_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_ADivA_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_AddCommut_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_MultCommut_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_AddAssoc_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_MultAssoc_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_Distr_eq_oi :: (ERIntApprox ira, ERInnerOuterApprox ira) => RAPropTupleUnary ira
props_ra_SinCos_eq_oi :: (ERInnerOuterApproxElementary ira, ERApproxElementary ira) => RAPropTupleUnary ira
props_ra_TanATan_eq_oi :: (ERInnerOuterApproxElementary ira, ERApproxElementary ira) => RAPropTupleUnary ira
props_ra_LogExp_eq_oi :: (ERInnerOuterApproxElementary ira, ERApproxElementary ira) => RAPropTupleUnary ira


-- | Support for running all function enclosure base tests in a batch.
module Data.Number.ER.Real.Approx.Tests.Run
runRATests :: (ERApproxElementary ra, ERInnerOuterApproxElementary ra, Ord ra) => String -> ra -> IO () -> IO ()


-- | A simple validated solver for systems of linear equations with
--   interval coefficients. It uses a naive splitting approach and is
--   therefore very slow.
module Data.Number.ER.Real.Arithmetic.LinearSolver
linearSolver :: (ERIntApprox ira, DomainIntBox box varid ira, DomainBoxMappable box box varid ira ira) => [(box, ira)] -> box -> ira -> Maybe box


-- | This module defines an arbitrary precision floating point type and its
--   operations. It should be viewed more abstractly as an instance of
--   <a>ERRealBase</a> when used as interval endpoints.
module Data.Number.ER.Real.Base.Float

-- | A floating point number with a given but arbitrary precision
--   represented by its <a>Granularity</a>.
--   
--   <ul>
--   <li>base: 2.</li>
--   <li>granularity specifies the bit-size of both the significand and the
--   exponent</li>
--   <li>special values: NaN, signed Infinity and signed Zero</li>
--   <li>no denormalised numbers</li>
--   <li>operations unify the granularity of their operands to the maximum
--   <a>Granularity</a></li>
--   <li>Rounding is always towards +Infinity. For field operations, the
--   rounded result is as close as possible to the exact result.</li>
--   </ul>
data ERFloat
instance Typeable ERFloat
instance Data ERFloat
instance ERRealBase ERFloat
instance RealFrac ERFloat
instance Real ERFloat
instance Fractional ERFloat
instance Num ERFloat
instance Ord ERFloat
instance Eq ERFloat
instance Show ERFloat
instance Binary ERFloat


-- | Arbitrary precision floating point numbers that use machine double up
--   to its precision. When a higher granularity is required, it
--   automatically switches to another floating point type.
module Data.Number.ER.Real.Base.CombinedMachineAP
data ERMachineAP b
doubleDigits :: Int
instance Typeable1 ERMachineAP
instance (Data b) => Data (ERMachineAP b)
instance (ERRealBase b) => ERRealBase (ERMachineAP b)
instance (ERRealBase b, RealFrac b) => RealFrac (ERMachineAP b)
instance (ERRealBase b, Real b) => Real (ERMachineAP b)
instance (ERRealBase b) => Fractional (ERMachineAP b)
instance (ERRealBase b) => Num (ERMachineAP b)
instance (ERRealBase b) => Ord (ERMachineAP b)
instance (ERRealBase b) => Eq (ERMachineAP b)
instance (ERRealBase b) => Show (ERMachineAP b)
instance (Binary b) => Binary (ERMachineAP b)


-- | This module supplies default instances for the real number classes
--   defined in <a>Data.Number.ER.Real.Approx</a>.
--   
--   These classes express loosely coupled abstraction layers. To preserve
--   the intended loose coupling, please use these definitions only in
--   functions that do not import or export any real numbers or real
--   functions.
module Data.Number.ER.Real.DefaultRepr

-- | the default base type
type B = BMAP

-- | Limited granularity, but sometimes up to 100x faster than ERFloat!
--   
--   !!! to be safe, one has to run <a>initMachineDouble</a>
type BM = Double
type BAP = ERFloat

-- | Use machine <a>Double</a> while the granularity is up to its
--   significant bit length and when the granularity grows beyond that, use
--   <a>ERFloat</a>.
--   
--   !!! to be safe, one has to run <a>initMachineDouble</a>
type BMAP = ERMachineAP BAP

-- | very inefficient
type BR = ExtendedRational

-- | the default instance of <tt>Data.Number.ER.Real.Approx.ERApprox</tt>
type RA b = ERInterval b

-- | the default instance of
--   <tt>Data.Number.ER.Real.Approx.ERIntApprox</tt>
type IRA b = ERInterval b


-- | Generic instances of <a>Arbitrary</a> class for generating (almost)
--   random instances according to different distributions.
module Data.Number.ER.Real.Base.Tests.Generate
newtype BGran20 b
BGran20 :: b -> BGran20 b
newtype BGran100 b
BGran100 :: b -> BGran100 b
newtype BGran1000 b
BGran1000 :: b -> BGran1000 b
constructB :: (ERRealBase b) => Granularity -> (Double, Double, Double) -> Int -> b
instance (Show b) => Show (BGran1000 b)
instance (Show b) => Show (BGran100 b)
instance (Show b) => Show (BGran20 b)
instance (ERRealBase b) => Arbitrary (BGran1000 b)
instance (ERRealBase b) => Arbitrary (BGran100 b)
instance (ERRealBase b) => Arbitrary (BGran20 b)


-- | This module bundles some of the most important functionality of the
--   AERN-Real package. It is intended to be imported *qualified*.
--   
--   AERN-Real provides datatypes and abstractions for approximating exact
--   real numbers and a basic arithmetic over such approximations. The
--   approach is inspired to some degree by Mueller's iRRAM and Lambov's
--   RealLib (both are C++ libraries for exact real arithmetic).
--   
--   Abstractions are provided via 4 type classes:
--   
--   <ul>
--   <li><a>ERRealBase</a>: generalises floating point numbers (not
--   exported here, used only internally)</li>
--   <li><a>ERApprox</a>: generalises measurable subsets of real
--   numbers</li>
--   <li><a>ERIntApprox</a>: generalises interval neighbourhoods of real
--   numbers</li>
--   <li><a>ERApproxElementary</a>: generalises real number approximations
--   that support elementary operations</li>
--   </ul>
--   
--   For ERRealBase we give several implementations. The default is an
--   arbitrary precision floating point type that uses Double for lower
--   precisions and an Integer-based simulation for higher precisions.
--   Rational numbers can be used as one of the alternatives. Augustsson's
--   Data.Number.BigFloat can be easily wrapped as an instance of
--   ERRealBase except that it uses a different method to control
--   precision. Optionally, one can also have MPFR floating point numbers
--   via package hmpfr if compiled with USE_MPFR.
--   
--   ERIntApprox is implemented via outwards-rounded arbitrary precision
--   interval arithmetic. Any instance of ERRealBase can be used for the
--   endpoints of the intervals.
--   
--   ERApproxElementary is implemented generically for any implementation
--   of ERIntApprox. This way some of the most common elementary operations
--   are provided, notably: sqrt, exp, log, sin, cos, atan. These
--   operations converge to an arbitrary precision and also work well over
--   larger intervals without excessive wrapping.
--   
--   There is also some support for generic Taylor series, interval Newton
--   method and simple numerical integration.
module Data.Number.ER.Real


-- | This namespace is the root for the AERN family of packages. AERN
--   stands for Approximated Exact Real Numbers. All AERN packages build on
--   the package AERN-Real.
--   
--   Module <a>Data.Number.ER.Real</a> contains an overview of the
--   AERN-Real package.
module Data.Number.ER
