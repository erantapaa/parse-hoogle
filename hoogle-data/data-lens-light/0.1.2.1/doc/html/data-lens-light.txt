-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple lenses, minimum dependencies
--   
@package data-lens-light
@version 0.1.2.1

module Data.Lens.Light

-- | Simple lens data type
newtype Lens a b
Lens :: (a -> (b -> a, b)) -> Lens a b
runLens :: Lens a b -> a -> (b -> a, b)

-- | Build a lens out of a getter and setter
lens :: (a -> b) -> (b -> a -> a) -> Lens a b

-- | Build a lens out of an isomorphism
iso :: (a -> b) -> (b -> a) -> Lens a b

-- | Get the getter function from a lens
getL :: Lens a b -> a -> b

-- | Get the setter function from a lens
setL :: Lens a b -> b -> a -> a

-- | Get the modifier function from a lens
modL :: Lens a b -> (b -> b) -> a -> a

-- | Get the modifier function from a lens. Forces function application.
modL' :: Lens a b -> (b -> b) -> a -> a

-- | Infix version of <a>getL</a> (with the reverse order of the arguments)
(^.) :: b -> Lens b c -> c

-- | Convert a lens to its van Laarhoven representation
vanLaarhoven :: Functor f => Lens a b -> (b -> f b) -> (a -> f a)

-- | <tt>nameMakeLens n f</tt> where <tt>n</tt> is the name of a data type
--   declared with <tt>data</tt> and <tt>f</tt> is a function from names of
--   fields in that data type to the name of the corresponding accessor. If
--   <tt>f</tt> returns <tt>Nothing</tt>, then no accessor is generated for
--   that field.
nameMakeLens :: Name -> (String -> Maybe String) -> Q [Dec]

-- | <tt>makeLenses n</tt> where <tt>n</tt> is the name of a data type
--   declared with <tt>data</tt> looks through all the declared fields of
--   the data type, and for each field beginning with an underscore
--   generates an accessor of the same name without the underscore.
--   
--   It is "nameMakeLens" n f where <tt>f</tt> satisfies
--   
--   <pre>
--   f ('_' : s) = Just s
--   f x = Nothing -- otherwise
--   </pre>
--   
--   For example, given the data type:
--   
--   <pre>
--   data Score = Score { 
--     _p1Score :: Int
--   , _p2Score :: Int
--   , rounds :: Int
--   }
--   </pre>
--   
--   <tt>makeLenses</tt> will generate the following objects:
--   
--   <pre>
--   p1Score :: Lens Score Int
--   p1Score = lens _p1Score (\x s -&gt; s { _p1Score = x })
--   p2Score :: Lens Score Int
--   p2Score = lens _p2Score (\x s -&gt; s { _p2Score = x })
--   </pre>
--   
--   It is used with Template Haskell syntax like:
--   
--   <pre>
--   $( makeLenses [''TypeName] )
--   </pre>
--   
--   And will generate accessors when TypeName was declared using
--   <tt>data</tt> or <tt>newtype</tt>.
makeLenses :: [Name] -> Q [Dec]

-- | <pre>
--   makeLens a = makeLenses [a]
--   </pre>
--   
--   <pre>
--   $( makeLens ''TypeName )
--   </pre>
makeLens :: Name -> Q [Dec]

-- | Get the value of a lens into state
access :: MonadState a m => Lens a b -> m b

-- | Set a value using a lens into state
(~=) :: MonadState a m => Lens a b -> b -> m ()

-- | Set a value using a lens into state. Forces both the value and the
--   whole state.
(!=) :: MonadState a m => Lens a b -> b -> m ()

-- | Infix modification of a value through a lens into state
(%=) :: MonadState a m => Lens a b -> (b -> b) -> m ()

-- | Infix modification of a value through a lens into state. Forces both
--   the function application and the whole state.
(!%=) :: MonadState a m => Lens a b -> (b -> b) -> m ()

-- | Run a stateful computation with a smaller state inside another
--   computation with a bigger state.
zoom :: (MonadStateT stateT, MonadState s (stateT s m), MonadTrans (stateT s), Monad m) => Lens s s' -> stateT s' m a -> stateT s m a

-- | The purpose of this class is to abstract the difference between the
--   lazy and strict state monads, so that <a>zoom</a> can work with either
--   of them.
class MonadStateT t
