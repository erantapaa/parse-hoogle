-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | an experiment management framework
--   
--   Laborantin is a framework and DSL to run and manage results from
--   scientific experiments. Good targets for Laborantin are experiments
--   that you can run <i>offline</i> such as benchmark and batch analytics.
--   
--   Writing experiments with Laborantin has at least two advantages over
--   rolling your own scripts. First, Laborantin standardizes the workflow
--   of your experimentations. There is one way to describe what a project
--   can do, what experiments were already run, how to delete files
--   corresponding to a specific experiment, etc. Second, Laborantin builds
--   on years of experience running experiments. Using Laborantin should
--   alleviate common pain points such as querying for experiments,
--   managing dependencies between results, etc.
--   
--   Laborantin's DSL lets you express experiment parameters, setup,
--   teardown, and recovery hooks in a systematic way. In addition, the DSL
--   lets you express dependencies on your experiments so that you can run
--   prior experiments or data analyses.
--   
--   Laborantin comes with a default backend that stores experiment results
--   in a filesystem-hierarchy. Laborantin also comes with a default
--   command-line that let you specify which experiments to run, analyze,
--   or delete.
--   
--   <pre>
--   ping :: ScenarioDescription EnvIO
--   ping = scenario "ping" $ do
--     describe "ping to a remote server"
--     parameter "destination" $ do
--       describe "a destination server (host or ip)"
--       values [str "example.com", str "probecraft.net"]
--     parameter "packet-size" $ do
--       describe "packet size in bytes"
--       values [num 50, num 1500]
--     run $ do
--       (StringParam srv) &lt;- param "destination"
--       (StringParam ps) &lt;- param "packet-size"
--       liftIO (executePingCommand srv ps) &gt;&gt;= writeResult "raw-result"
--       where executePingCommand :: Text -&gt; Rational -&gt; IO (Text)
--             executePingCommand host packetSize = ...
--   
--   main :: IO ()
--   main = defaultMain [ping]
--   </pre>
@package laborantin-hs
@version 0.1.5.2

module Laborantin.Types

-- | A Scenario description carries all information to run an experiment.
data ScenarioDescription m
SDesc :: Text -> Text -> ParameterSpace -> Map Text (Action m) -> Maybe (ExecutionError -> Action m) -> [Dependency m] -> TExpr Bool -> ScenarioDescription m
sName :: ScenarioDescription m -> Text
sDesc :: ScenarioDescription m -> Text
sParams :: ScenarioDescription m -> ParameterSpace
sHooks :: ScenarioDescription m -> Map Text (Action m)
sRecoveryAction :: ScenarioDescription m -> Maybe (ExecutionError -> Action m)
sDeps :: ScenarioDescription m -> [Dependency m]
sQuery :: ScenarioDescription m -> TExpr Bool

-- | A ParameterDescription description carries information for a single
--   parameter.
data ParameterDescription
PDesc :: Text -> Text -> [ParameterValue] -> ParameterDescription
pName :: ParameterDescription -> Text
pDesc :: ParameterDescription -> Text
pValues :: ParameterDescription -> [ParameterValue]

-- | Two parameter values type should be enough for command-line demands:
--   text and numbers.
--   
--   However, we provide two other constructors (Array and Range) for the
--   ParameterDescriptions in the DSL.
--   
--   Executions should use text and numbers only.
data ParameterValue
StringParam :: Text -> ParameterValue
NumberParam :: Rational -> ParameterValue
Array :: [ParameterValue] -> ParameterValue
Range :: Rational -> Rational -> Rational -> ParameterValue

-- | A ParameterSpace maps parameter names to their descriptions.
type ParameterSpace = Map Text ParameterDescription

-- | A ParameterSet (slightly different from a ParameterSpace) is a mapping
--   between parameter names and a single ParameterValue.
--   
--   You can see a ParameterSet as a datapoint within a (multidimensional)
--   ParameterSpace.
--   
--   Thus, to keep things clearer, we recommend that executions use only
--   text and numbers as ParameterValues.
type ParameterSet = Map Text ParameterValue
emptyScenario :: ScenarioDescription m
emptyParameter :: ParameterDescription

-- | Returns an exhaustive list of ParameterSet (i.e., all data points) to
--   cover a (multidimensional) ParameterSpace.
--   
--   Basically a Cartesian product.
paramSets :: ParameterSpace -> [ParameterSet]

-- | Merges two ParameterSpace by extending all dimensions.
mergeParamSpaces :: ParameterSpace -> ParameterSpace -> ParameterSpace

-- | Updates a single dimension of the ParameterSpace to be the list of
--   ParameterValue s in 3rd parameter.
updateParam :: ParameterSpace -> Text -> [ParameterValue] -> ParameterSpace

-- | Expands a ParameterValue to a list of ParameterValues. Mainly flattens
--   ranges.
expandValue :: ParameterValue -> [ParameterValue]

-- | Backends must generate results that are easy to operate. They
--   represent files with read<i>write</i>append operations as execution
--   steps.
--   
--   Note that Backend might not implement all three of read, write, append
--   operations.
data Result m
Result :: FilePath -> Step m Text -> (Text -> Step m ()) -> (Text -> Step m ()) -> Result m
pPath :: Result m -> FilePath
pRead :: Result m -> Step m Text
pAppend :: Result m -> Text -> Step m ()
pWrite :: Result m -> Text -> Step m ()

-- | A Backend captures all functions that an object must provide to run
--   Laborantin experiments.
--   
--   Such functions give ways to prepare, run, analyze, and finalize
--   executions. As well as provide support for logging info, storing,
--   finding, and deleting prior results.
--   
--   We prefer such a design over a typeclass to simplify overall design
--   and unclutter type definitions everywhere.
data Backend m
Backend :: Text -> (ScenarioDescription m -> ParameterSet -> m (Execution m, Finalizer m)) -> (Execution m -> Finalizer m -> m ()) -> (Execution m -> Step m ()) -> (Execution m -> Step m ()) -> (Execution m -> Step m ()) -> (Execution m -> Step m ()) -> (ExecutionError -> Execution m -> Step m ()) -> (Execution m -> FilePath -> Step m (Result m)) -> ([ScenarioDescription m] -> TExpr Bool -> m [Execution m]) -> (Execution m -> Step m (LogHandler m)) -> (Execution m -> m ()) -> Backend m
bName :: Backend m -> Text
bPrepareExecution :: Backend m -> ScenarioDescription m -> ParameterSet -> m (Execution m, Finalizer m)
bFinalizeExecution :: Backend m -> Execution m -> Finalizer m -> m ()
bSetup :: Backend m -> Execution m -> Step m ()
bRun :: Backend m -> Execution m -> Step m ()
bTeardown :: Backend m -> Execution m -> Step m ()
bAnalyze :: Backend m -> Execution m -> Step m ()
bRecover :: Backend m -> ExecutionError -> Execution m -> Step m ()
bResult :: Backend m -> Execution m -> FilePath -> Step m (Result m)
bLoad :: Backend m -> [ScenarioDescription m] -> TExpr Bool -> m [Execution m]
bLogger :: Backend m -> Execution m -> Step m (LogHandler m)
bRemove :: Backend m -> Execution m -> m ()

-- | An Execution represents an ongoing or past experiment result.
data Execution m
Exec :: ScenarioDescription m -> ParameterSet -> FilePath -> ExecutionStatus -> [Execution m] -> (UTCTime, UTCTime) -> Execution m
eScenario :: Execution m -> ScenarioDescription m
eParamSet :: Execution m -> ParameterSet
ePath :: Execution m -> FilePath
eStatus :: Execution m -> ExecutionStatus
eAncestors :: Execution m -> [Execution m]
eTimeStamps :: Execution m -> (UTCTime, UTCTime)

-- | An StoredExecution is a stripped-down version of an Execution.
--   
--   As it represents an experiment stored on disk, it does not need to
--   carry the ScenarioDescription object (otherwise it would become harder
--   to create instances such as FromJSON for Executions).
data StoredExecution
Stored :: ParameterSet -> FilePath -> ExecutionStatus -> [(FilePath, Text)] -> (UTCTime, UTCTime) -> StoredExecution
seParamSet :: StoredExecution -> ParameterSet
sePath :: StoredExecution -> FilePath
seStatus :: StoredExecution -> ExecutionStatus
seAncestors :: StoredExecution -> [(FilePath, Text)]
seTimeStamps :: StoredExecution -> (UTCTime, UTCTime)
data ExecutionError
ExecutionError :: String -> ExecutionError
data AnalysisError
AnalysisError :: String -> AnalysisError
data ExecutionStatus
Running :: ExecutionStatus
Success :: ExecutionStatus
Failure :: ExecutionStatus
type Finalizer m = Execution m -> m ()
newtype LogHandler m
LogHandler :: (Text -> Step m ()) -> LogHandler m
lLog :: LogHandler m -> Text -> Step m ()

-- | A step is a stateful operation for a Scenario phase. It carries a
--   modifiable DynEnv between hooks and handle ExecutionErrors. In
--   addition, you can read (but not modify) the Backend and the Execution.
type Step m a = ErrorT ExecutionError (StateT DynEnv (ReaderT (Backend m, Execution m) m)) a

-- | An Action wraps a monadic computation inside a step.
newtype Action m
Action :: Step m () -> Action m
unAction :: Action m -> Step m ()

-- | DynEnv is a map between Text keys and Dynamic values.
type DynEnv = Map Text Dynamic
emptyEnv :: DynEnv
data TExpr :: * -> *
N :: Rational -> TExpr Rational
B :: Bool -> TExpr Bool
S :: Text -> TExpr Text
L :: [TExpr a] -> TExpr [a]
T :: UTCTime -> TExpr UTCTime
Plus :: TExpr Rational -> TExpr Rational -> TExpr Rational
Times :: TExpr Rational -> TExpr Rational -> TExpr Rational
And :: TExpr Bool -> TExpr Bool -> TExpr Bool
Or :: TExpr Bool -> TExpr Bool -> TExpr Bool
Not :: TExpr Bool -> TExpr Bool
Contains :: TExpr a -> TExpr [a] -> TExpr Bool
Eq :: TExpr a -> TExpr a -> TExpr Bool
Gt :: TExpr a -> TExpr a -> TExpr Bool
ScName :: TExpr Text
ScStatus :: TExpr Text
ScParam :: Text -> TExpr (Text, Maybe ParameterValue)
ScTimestamp :: TExpr UTCTime
SCoerce :: TExpr (Text, Maybe ParameterValue) -> TExpr Text
NCoerce :: TExpr (Text, Maybe ParameterValue) -> TExpr Rational
SilentSCoerce :: TExpr (Text, Maybe ParameterValue) -> TExpr Text
SilentNCoerce :: TExpr (Text, Maybe ParameterValue) -> TExpr Rational
TBind :: String -> (a -> TExpr b) -> TExpr a -> TExpr b
data UExpr
UN :: Rational -> UExpr
UB :: Bool -> UExpr
US :: Text -> UExpr
UL :: [UExpr] -> UExpr
UT :: UTCTime -> UExpr
UPlus :: UExpr -> UExpr -> UExpr
UMinus :: UExpr -> UExpr -> UExpr
UTimes :: UExpr -> UExpr -> UExpr
UDiv :: UExpr -> UExpr -> UExpr
UAnd :: UExpr -> UExpr -> UExpr
UOr :: UExpr -> UExpr -> UExpr
UContains :: UExpr -> UExpr -> UExpr
UEq :: UExpr -> UExpr -> UExpr
UGt :: UExpr -> UExpr -> UExpr
UGte :: UExpr -> UExpr -> UExpr
ULte :: UExpr -> UExpr -> UExpr
ULt :: UExpr -> UExpr -> UExpr
UNot :: UExpr -> UExpr
UScName :: UExpr
UScStatus :: UExpr
UScTimestamp :: UExpr
UScParam :: Text -> UExpr

-- | A Dependency is a lose but flexible way of expressing dependencies for
--   experiments.
--   
--   Dependencies can check whether they are fullfilled, and try to solve.
--   The main goal for the design of Dependency dCheck and dSolve hooks is
--   to let a Dependency run experiments and add them as ancestors *before*
--   starting any Step. Types may slightly vary in the future.
--   
--   Dependencies can do anything that a ScenarioDescription allows (hence
--   they are parametrized with the same monad as the ScenarioDescription
--   owning a Dependency). However, Dependency check and Dependency
--   resolution do not live in a Step m . That is they do not have access
--   to, and cannot modify, the DynEnv. Thus, this limits the possibility
--   to read execution parameters from within the dCheck and dSolve.
--   
--   To compensate for this limitation, the dCheck hook accepts the
--   Execution as parameter and the dSolve hook accepts both the Execution
--   and the Backend as parameter, and get a chance to return a modified
--   Execution object.
data Dependency m
Dep :: Text -> Text -> (Execution m -> m Bool) -> ((Execution m, Backend m) -> m (Execution m)) -> Dependency m
dName :: Dependency m -> Text
dDesc :: Dependency m -> Text
dCheck :: Dependency m -> Execution m -> m Bool
dSolve :: Dependency m -> (Execution m, Backend m) -> m (Execution m)
instance Show ExecutionError
instance Show AnalysisError
instance Show ParameterValue
instance Eq ParameterValue
instance Ord ParameterValue
instance Show ParameterDescription
instance Eq ParameterDescription
instance Ord ParameterDescription
instance Show ExecutionStatus
instance Read ExecutionStatus
instance Eq ExecutionStatus
instance Show StoredExecution
instance Show (ScenarioDescription m)
instance Show (Execution m)
instance Show UExpr
instance Show (TExpr a)
instance Show (Dependency m)
instance Eq (Dependency m)
instance Show (ExecutionError -> Action m)
instance Show (Action m)
instance Error AnalysisError
instance Error ExecutionError

module Laborantin.Query
matchTExpr :: TExpr Bool -> Execution m -> Bool
matchTExpr' :: TExpr Bool -> ScenarioDescription m -> ParameterSet -> Bool
simplifyOneBoolLevel :: TExpr Bool -> TExpr Bool

-- | Expands a ParameterSpace to all values that could match a TExpr Bool.
--   
--   Currently only supports countably finite expansions of parameters.
--   That is TExpr Bool such as (<tt>sc.param <a>param</a> &gt; 32) are
--   ignored. Instead (</tt>sc.param <a>param</a> in [<a>foo</a>,
--   <a>bar</a>]) gets expanded to (<a>param</a>, [StringParam <a>foo</a>,
--   StringParam <a>bar</a>]) Supported expensions are And <i> Or </i> Eq /
--   Contains.
--   
--   The idea is that you can generate a list of Execution to run by first
--   expanding all possible points in the ParameterSpace modified by the
--   TExpr, and then filter these possible points using a same TExpr.
expandParamSpace :: ParameterSpace -> TExpr Bool -> ParameterSpace
instance Show EvalError

module Laborantin.Implementation

-- | Default monad for <a>defaultBackend</a>. EnvIO carries a <a>DynEnv</a>
--   in a state and allows you to perform IO actions.
type EnvIO = IO

-- | Execute an EnvIO action in IO.
runEnvIO :: IO a -> IO a

-- | Default backend for the <a>EnvIO</a> monad. This backend uses the
--   filesystem as storage and UUIDs for scenario instances (supposes that
--   UUID collision cannot happen).
--   
--   Parameters, logfiles, and result data all are stored in a unique
--   directory named .<i>&lt;scenario-name&gt;</i><a>uuid</a>
--   
--   Results are individual files in this directory. There is no
--   namespacing hence avoid the following names: 'execution.json',
--   'execution-log.txt', and 'execution-log.xml'. These three files are
--   the scenario execution metadata and logs.
defaultBackend :: Backend EnvIO

-- | Default result handler for the <a>EnvIO</a> monad (see
--   <a>defaultBackend</a>).
defaultResult :: Execution m -> FilePath -> Result EnvIO

-- | Default logger for the <a>EnvIO</a> monad (see <a>defaultBackend</a>).
defaultLog :: Execution m -> LogHandler EnvIO

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
instance FromJSON StoredExecution
instance FromJSON ExecutionStatus
instance FromJSON ParameterValue
instance ToJSON (Execution a)
instance ToJSON ExecutionStatus
instance ToJSON ParameterValue

module Laborantin

-- | Prepare a list of execution actions for a given (scenario,
--   parameter-query, existing) ancestors.
--   
--   This function returns one action per ParameterSet which is required by
--   the parameter-query and not yet present in the existing list of
--   executions.
--   
--   For instance, if the scenario has one parameter <tt>foo</tt>; the
--   query wants <tt>foo</tt> in [1,2,3,4]; and there is one execution with
--   <tt>foo</tt> == 2; then this function returns 3 actions (for
--   parameters 1, 3, and 4).
--   
--   A user can then run these actions in sequence (or concurrently if it
--   makes sense).
prepare :: MonadIO m => Backend m -> TExpr Bool -> [Execution m] -> ScenarioDescription m -> [m (Execution m)]

-- | Loads executions of given ScenarioDescription and matching a given
--   query using a specific backend.
load :: MonadIO m => Backend m -> [ScenarioDescription m] -> TExpr Bool -> m [Execution m]

-- | Remove an execution using a specific backend.
remove :: MonadIO m => Backend m -> Execution m -> m ()

-- | Runs the analysis hooks.
runAnalyze :: (MonadIO m, Functor m) => Backend m -> Execution m -> m (Either AnalysisError ())

-- | Like matchingParameterSets but also remove existing ParameterSet given
--   as third parameter.
missingParameterSets :: ScenarioDescription m -> TExpr Bool -> [ParameterSet] -> [ParameterSet]

-- | Expands parameters given a TExpr and a ScenarioDescription into a list
--   of parameter spaces (sort of cartesian product of all possible params)
expandParameterSets :: ScenarioDescription m -> TExpr Bool -> [ParameterSet]

module Laborantin.DSL

-- | DSL entry point to build a <a>ScenarioDescription</a>.
scenario :: Monad m => Text -> State (ScenarioDescription m) () -> ScenarioDescription m

-- | Attach a description to the <tt>Parameter</tt> / <tt>Scnario</tt>
describe :: Describable a => Text -> State a ()

-- | DSL entry point to build a <a>ParameterDescription</a> within a
--   scenario.
parameter :: Text -> State ParameterDescription () -> State (ScenarioDescription m) ()

-- | Defines the TExpr Bool to load ancestor
require :: (MonadIO m, Monad m) => ScenarioDescription m -> Text -> State (ScenarioDescription m) ()

-- | Defines the TExpr Bool to load ancestor
requireTExpr :: (MonadIO m, Monad m) => ScenarioDescription m -> TExpr Bool -> State (ScenarioDescription m) ()

-- | DSL entry point to build a 'Dependency a' within a scenario.
dependency :: Monad m => Text -> State (Dependency m) () -> State (ScenarioDescription m) ()

-- | Set verification action for the dependency
check :: (Execution m -> m Bool) -> State (Dependency m) ()

-- | Set resolution action for the dependency
resolve :: ((Execution m, Backend m) -> m (Execution m)) -> State (Dependency m) ()

-- | Set default values for the paramater
values :: [ParameterValue] -> State ParameterDescription ()

-- | Encapsulate a Text as a <a>ParameterValue</a>
str :: Text -> ParameterValue

-- | Encapsulate an integer value as a <a>ParameterValue</a>
num :: Integer -> ParameterValue

-- | Encapsulate a range as a <a>ParameterValue</a>
range :: Rational -> Rational -> Rational -> ParameterValue

-- | Encapsulate an array of <a>str</a> or <a>num</a> values as a
--   <a>ParameterValue</a>
arr :: [ParameterValue] -> ParameterValue

-- | Define the setup hook for this scenario
setup :: Step m () -> State (ScenarioDescription m) ()

-- | Define the teardown hook for this scenario
teardown :: Step m () -> State (ScenarioDescription m) ()

-- | Define the main run hook for this scenario
run :: Step m () -> State (ScenarioDescription m) ()

-- | Returns current execution
self :: Monad m => Step m (Execution m)

-- | Returns current backend
backend :: Monad m => Step m (Backend m)

-- | Get the parameter with given name. Throw an error if the parameter is
--   missing.
param :: Monad m => Text -> Step m ParameterValue

-- | Get all ancestors for a given scenario name.
ancestors :: Monad m => Text -> Step m [Execution m]

-- | Get all ancestors for a given scenario name and matching a query
--   expressed as a string. Current implementation silences errors.
ancestorsMatching :: Monad m => Text -> Text -> Step m [Execution m]

-- | Get all ancestors for a given scenario name and matching a TExpr Bool
--   query.
ancestorsMatchingTExpr :: Monad m => Text -> TExpr Bool -> Step m [Execution m]

-- | Get an execution variable and tries to cast it from it's Dynamic
--   representation.
--   
--   Returns <a>Nothing</a> if the variable is missing or if it could not
--   be cast to the wanted type.
getVar :: (Typeable v, Functor m, MonadState DynEnv m) => Text -> m (Maybe v)

-- | Set an execution variable.
setVar :: (Typeable v, MonadState DynEnv m) => Text -> v -> m ()

-- | Define the recovery hook for this scenario
recover :: (ExecutionError -> Step m ()) -> State (ScenarioDescription m) ()

-- | Define the offline analysis hook for this scenario
analyze :: Step m () -> State (ScenarioDescription m) ()

-- | Returns a <a>Result</a> object for the given name.
--   
--   Implementations will return their specific results.
result :: Monad m => FilePath -> Step m (Result m)

-- | Write (overwrite) the result in its entirety.
--   
--   Implementations will return their specific results.
writeResult :: Monad m => FilePath -> Text -> Step m ()

-- | Appends a chunk of data to the result.
--   
--   Implementations will return their specific results.
appendResult :: Monad m => FilePath -> Text -> Step m ()

-- | Return a <a>LogHandler</a> object for this scenario.
logger :: Monad m => Step m (LogHandler m)

-- | Sends a line of data to the logger (debug mode)
dbg :: Monad m => Text -> Step m ()

-- | Interrupts the scenario by throwing an error
err :: Monad m => String -> Step m ()
instance Describable (Dependency a)
instance Describable ParameterDescription
instance Describable (ScenarioDescription a)

module Laborantin.CLI
defaultMain :: [ScenarioDescription EnvIO] -> IO ()
instance Typeable Labor
instance Data Labor
instance Show Labor
instance Eq Labor
instance Show DescriptionTExpr
instance RecordCommand Labor
instance Attributes Labor
