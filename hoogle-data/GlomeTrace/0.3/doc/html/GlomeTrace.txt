-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Ray Tracing Library
--   
--   A ray tracing library with acceleration structure and many supported
--   primitives.
@package GlomeTrace
@version 0.3

module Data.Glome.Clr
type CFlt = Double
data Color
Color :: !CFlt -> !CFlt -> !CFlt -> Color
data ColorA
ColorA :: !CFlt -> !CFlt -> !CFlt -> !CFlt -> ColorA
c_black :: Color
c_white :: Color
c_red :: Color
c_green :: Color
c_blue :: Color
ca_black :: ColorA
ca_white :: ColorA
ca_red :: ColorA
ca_green :: ColorA
ca_blue :: ColorA
ca_transparent :: ColorA
cadd :: Color -> Color -> Color
caadd :: ColorA -> ColorA -> ColorA
canorm :: ColorA -> ColorA
cdiv :: Color -> CFlt -> Color
cadiv :: ColorA -> CFlt -> ColorA
cscale :: Color -> CFlt -> Color
cascale :: ColorA -> CFlt -> ColorA
cmul :: Color -> Color -> Color
cavg :: Color -> Color -> Color
cscaleadd :: Color -> Color -> CFlt -> Color
cclamp :: Color -> Color
color :: CFlt -> CFlt -> CFlt -> Color
colora :: CFlt -> CFlt -> CFlt -> CFlt -> ColorA
liftcolor :: Color -> ColorA
aclamp :: CFlt -> CFlt
alphas :: [ColorA] -> CFlt
caweight :: ColorA -> ColorA -> CFlt -> ColorA
casum :: [ColorA] -> ColorA
cafold :: ColorA -> ColorA -> ColorA
instance Show Color

module Data.Glome.Solid

-- | Ray intersection type. If we hit, we store the distance from the ray
--   origin, the position, the normal, the transformed ray, UV coordinates
--   (plus a 3rd coordinate we'll call W) and the texture and tag stacks
--   attached to the object.
data Rayint tag mat
RayHit :: !Flt -> !Vec -> !Vec -> !Ray -> !Vec -> [Texture tag mat] -> [tag] -> Rayint tag mat
ridepth' :: Rayint tag mat -> !Flt
ripos :: Rayint tag mat -> !Vec
rinorm :: Rayint tag mat -> !Vec
riray :: Rayint tag mat -> !Ray
riuvw :: Rayint tag mat -> !Vec
ritex :: Rayint tag mat -> [Texture tag mat]
ritag :: Rayint tag mat -> [tag]
RayMiss :: Rayint tag mat
raymiss :: Rayint tag mat
ridepth :: Rayint tag mat -> Flt

-- | Pick the closest of two Rayints
nearest :: Rayint tag mat -> Rayint tag mat -> Rayint tag mat

-- | Pick the furthest of two Rayints
furthest :: Rayint tag mat -> Rayint tag mat -> Rayint tag mat

-- | Test if a Rayint is a hit or a miss
hit :: Rayint tag mat -> Bool

-- | Extract a distance from a Rayint, with infinity for a miss
dist :: Rayint tag mat -> Flt

-- | Sometimes, it's more efficient to trace multiple rays against an
--   acceleration structure at the same time, provided the rays are almost
--   identical. A PacketResult is the result of tracing 4 rays at once.
data PacketResult tag mat
PacketResult :: (Rayint tag mat) -> (Rayint tag mat) -> (Rayint tag mat) -> (Rayint tag mat) -> PacketResult tag mat
packetmiss :: PacketResult tag mat
nearest_packetresult :: PacketResult tag mat -> PacketResult tag mat -> PacketResult tag mat

-- | Move a ray forward and test the new ray against an object. Fix the
--   depth of the result. Useful in CSG
rayint_advance :: SolidItem tag mat -> Ray -> Flt -> [Texture tag mat] -> [tag] -> Flt -> Rayint tag mat

-- | A texture is a function that takes a Rayint and returns a material. A
--   material will later be rendered by a shader (which in turn can append
--   more tags).
type Texture tag mat = Ray -> Rayint tag mat -> mat
newtype Pcount
Pcount :: (Int, Int, Int) -> Pcount
pcadd :: Pcount -> Pcount -> Pcount
asbound :: Pcount -> Pcount
pcsinglexfm :: Pcount
pcsingleprim :: Pcount
pcsinglebound :: Pcount
pcnone :: Pcount
debug_wrap :: (Rayint tag mat, Int) -> Int -> (Rayint tag mat, Int)
nearest_debug :: (Rayint tag mat, Int) -> (Rayint tag mat, Int) -> (Rayint tag mat, Int)

-- | A solid is something we can test a ray against or do inside/outside
--   tests. Some of these are simple solids like Sphere or Triangle, but
--   others are composite solids than have other solids as children.
class Show s => Solid s t m | s -> t, s -> m where rayint_debug s !r !d t tags = ((rayint s r d t tags), 0) packetint s !r1 !r2 !r3 !r4 !d t tags = PacketResult (rayint s r1 d t tags) (rayint s r2 d t tags) (rayint s r3 d t tags) (rayint s r4 d t tags) shadow s !r !d = case (rayint s r d undefined []) of { RayHit _ _ _ _ _ _ _ -> True RayMiss -> False } tolist s = [SolidItem s] transform s xfm = SolidItem $ Instance (SolidItem s) (compose xfm) transform_leaf = transform flatten_transform = tolist primcount s = pcsingleprim get_metainfo s v = ([], [])
rayint :: Solid s t m => s -> Ray -> Flt -> [Texture t m] -> [t] -> Rayint t m
rayint_debug :: Solid s t m => s -> Ray -> Flt -> [Texture t m] -> [t] -> (Rayint t m, Int)
packetint :: Solid s t m => s -> Ray -> Ray -> Ray -> Ray -> Flt -> [Texture t m] -> [t] -> PacketResult t m
shadow :: Solid s t m => s -> Ray -> Flt -> Bool
inside :: Solid s t m => s -> Vec -> Bool
bound :: Solid s t m => s -> Bbox
tolist :: Solid s t m => s -> [SolidItem t m]
transform :: Solid s t m => s -> [Xfm] -> SolidItem t m
transform_leaf :: Solid s t m => s -> [Xfm] -> SolidItem t m
flatten_transform :: Solid s t m => s -> [SolidItem t m]
primcount :: Solid s t m => s -> Pcount
get_metainfo :: Solid s t m => s -> Vec -> ([Texture t m], [t])

-- | We create an existential type for solids so we can emded them in
--   composite types without know what kind of solid it is.
--   http:<i></i>notes-on-haskell.blogspot.com<i>2007</i>01/proxies-and-delegation-vs-existential.html
data SolidItem t m
SolidItem :: s -> SolidItem t m

-- | A group is just a list of objects. Sometimes its convenient to be able
--   to treat a group as if it were a single object, and that is exactly
--   what we do here. The ray intersection routine tests the ray against
--   each object in turn. Not very efficient for large groups, but this is
--   a useful building block for constructing the leaves of acceleration
--   structures. (See the bih module.)
group :: [SolidItem t m] -> SolidItem t m

-- | Smash a group of groups into a single group, so we can build an
--   efficient bounding heirarchy
flatten_group :: [SolidItem t m] -> [SolidItem t m]
paircat :: ([a], [b]) -> ([a], [b]) -> ([a], [b])

-- | A Void is a non-object, that we treat as if it were one. This is
--   functionally equivalent to an empty Group. (Originally I called this
--   <a>Nothing</a>, but that conflicted with the prelude maybe type, so I
--   call it <a>Void</a> instead)
data Void t m
Void :: Void t m
nothing :: SolidItem t m

-- | An instance is a primitive that has been modified by a transformation
--   (i.e. some combination of translation, rotation, and scaling). This is
--   a reasonably space-efficient way of making multiple copies of a
--   complex object.
--   
--   Usually, the application doesn't need to create an instance directly,
--   but should use <a>transform</a> on an existing object.
--   
--   It's unfortunate that <a>instance</a> is also a reserved word.
--   <a>instance Solid Instance where...</a> is a little confusing.
--   
--   This would be better in its own module, but we need <a>Instance</a> to
--   be defined here so we can define the default implementation of
--   <a>transform</a> in terms on Instance. (Mutually recursive modules
--   would be useful, if I could get them to work.)
--   
--   Another good reason to include Instance in Solid.hs is that it's
--   referenced from Cone.hs
data Instance t m
Instance :: (SolidItem t m) -> Xfm -> Instance t m
rayint_instance :: Instance tag mat -> Ray -> Flt -> [Texture tag mat] -> [tag] -> Rayint tag mat
packetint_instance :: Instance tag mat -> Ray -> Ray -> Ray -> Ray -> Flt -> [Texture tag mat] -> [tag] -> PacketResult tag mat
rayint_debug_instance :: Instance tag mat -> Ray -> Flt -> [Texture tag mat] -> [tag] -> (Rayint tag mat, Int)
shadow_instance :: Instance tag mat -> Ray -> Flt -> Bool
inside_instance :: Instance tag mat -> Vec -> Bool
bound_instance :: Instance tag mat -> Bbox
transform_instance :: Instance tag mat -> [Xfm] -> SolidItem tag mat
transform_leaf_instance :: Instance tag mat -> [Xfm] -> SolidItem tag mat
flatten_transform_instance :: Instance tag mat -> [SolidItem tag mat]
primcount_instance :: Instance tag mat -> Pcount
get_metainfo_instance :: Instance tag mat -> Vec -> ([Texture tag mat], [tag])
instance Show tag => Show (Rayint tag mat)
instance Show Pcount
instance Show (Void t m)
instance Show (Instance t m)
instance Solid (Instance t m) t m
instance Solid (Void t m) t m
instance Solid [SolidItem t m] t m
instance Show (SolidItem t m)
instance Solid (SolidItem t m) t m
instance Show (Texture t m)

module Data.Glome.Sphere

-- | Construct a sphere given a center location and a radius.
sphere :: Vec -> Flt -> SolidItem t m
instance Show (Sphere t m)
instance Solid (Sphere t m) t m

module Data.Glome.Triangle

-- | Create a simple triangle from its 3 corners. The normals are computed
--   automatically.
triangle :: Vec -> Vec -> Vec -> SolidItem t m

-- | Create a triangle fan from a list of verticies.
triangles :: [Vec] -> [SolidItem t m]

-- | Create a triangle from a list of verticies, and a list of normal
--   vectors (one for each vertex).
trianglenorm :: Vec -> Vec -> Vec -> Vec -> Vec -> Vec -> SolidItem t m

-- | Create a triangle fan from a list of verticies and normals.
trianglesnorms :: [(Vec, Vec)] -> [SolidItem t m]
instance Show (Triangle t m)
instance Show (TriangleNorm t m)
instance Solid (TriangleNorm t m) t m
instance Solid (Triangle t m) t m

module Data.Glome.Bih

-- | The bih constructor creates a Bounding Interval Heirarchy from a list
--   of primitives. BIH is a type of data structure that groups primitives
--   into a heirarchy of bounding objects, so that a ray need not be tested
--   against every single primitive. This can make the difference betweeen
--   a rendering job that takes days or seconds. BIH usually performs a
--   little worse than a SAH-based KD-tree, but construction time is much
--   better.
--   
--   See http:<i></i>en.wikipedia.org<i>wiki</i>Bounding_interval_hierarchy
bih :: [SolidItem t m] -> SolidItem t m
instance Show (BihNode t m)
instance Show (Bih t m)
instance Solid (Bih t m) t m

module Data.Glome.Csg

-- | Create a new object based on the subtraction of the second item from
--   the first. This only works if the items have a well-defined inside and
--   outside. Triangles and discs, for instance, have no volume, so
--   subtracting them from anything won't do anything.
--   
--   If you use the <a>retexture</a> constructor, the surface hollowed out
--   by B will be rendered with B's texture,
difference :: SolidItem t m -> SolidItem t m -> SolidItem t m

-- | Create a new item from the boolean intersection of a list of solids. A
--   point is inside the object iff it is inside every primitive. We can
--   construct polyhedra from intersections of planes, but this isn't the
--   most efficient way to do that.
intersection :: [SolidItem tag mat] -> SolidItem tag mat
instance Show (Difference t m)
instance Show (Intersection t m)
instance Solid (Intersection t m) t m
instance Solid (Difference t m) t m

module Data.Glome.Plane

-- | Construct a plane (or, more accurately, a half-space) by specifying a
--   point on the plane and a normal. The normal points towards the outside
--   of the plane. Planes are often useful within CSG objects.
plane :: Vec -> Vec -> SolidItem t m
plane_offset :: Vec -> Flt -> SolidItem t m
instance Show (Plane t m)
instance Solid (Plane t m) t m

module Data.Glome.Box
box :: Vec -> Vec -> SolidItem t m
instance Show (Box t m)
instance Solid (Box t m) t m

module Data.Glome.Bound

-- | Use the first object as a bounding volume for the second object. If a
--   ray misses the first object, it is assumed to miss the second object.
--   Used primarily to improve performance. In general, bih will usually
--   perform better than manually-constructed bounds, though.
bound_object :: SolidItem t m -> SolidItem t m -> SolidItem t m
instance Show (Bound t m)
instance Solid (Bound t m) t m

module Data.Glome.Cone

-- | Create a disc. These are used as the end-caps on cones and cylinders,
--   but they can be constructed by themselves as well.
disc :: Vec -> Vec -> Flt -> SolidItem t m

-- | Construct a cone from p1 to p2. R1 and r2 are the radii at each end. A
--   cone need not come to a point at either end.
cone :: Vec -> Flt -> Vec -> Flt -> SolidItem t m

-- | Construct a general cylinder from p1 to p2 with radius r.
cylinder :: Vec -> Vec -> Flt -> SolidItem t m
instance Show (Disc t m)
instance Show (Cylinder t m)
instance Show (Cone t m)
instance Solid (Cone t m) t m
instance Solid (Cylinder t m) t m
instance Solid (Disc t m) t m

module Data.Glome.Tex

-- | Associate a texture with an object. For composite objects, the shader
--   uses the innermost texture.
tex :: SolidItem tag mat -> Texture tag mat -> SolidItem tag mat
tag :: SolidItem tag mat -> tag -> SolidItem tag mat
instance Show (Tex tag mat)
instance Solid (Tex t m) t m
instance Solid (Tag t m) t m
instance Show (Tag tag mat)

module Data.Glome.Scene
data Camera
Camera :: !Vec -> !Vec -> !Vec -> !Vec -> Camera

-- | Construct a camera, given a position, a forward vector, a point that
--   the camera should be pointed towards, an up vector, and a right
--   vector. The up and right vectors don't have to be normalized or
--   perfectly orthogonal.
camera :: Vec -> Vec -> Vec -> Flt -> Camera
instance Show Camera

module Data.Glome.Trace
data Shader t m ctxa ctxb
Shader :: (ctxa -> Ray -> SolidItem t m -> Rayint t m -> ctxb) -> (ctxa -> ctxb -> m -> Ray -> SolidItem t m -> Rayint t m -> Int -> (ColorA, [t])) -> (ctxa -> Ray -> SolidItem t m -> (ColorA, [t])) -> Shader t m ctxa ctxb
preshade :: Shader t m ctxa ctxb -> ctxa -> Ray -> SolidItem t m -> Rayint t m -> ctxb
postshade :: Shader t m ctxa ctxb -> ctxa -> ctxb -> m -> Ray -> SolidItem t m -> Rayint t m -> Int -> (ColorA, [t])
missshade :: Shader t m ctxa ctxb -> ctxa -> Ray -> SolidItem t m -> (ColorA, [t])

-- | Result of tracing a packet of 4 rays at once.
data PacketColor
PacketColor :: !Color -> !Color -> !Color -> !Color -> PacketColor
opaque :: ColorA -> Bool

-- | Given a scene, a shader, a ray, a maximum distance, and a maximum
--   recursion depth, test the ray for intersection against the object
--   within the scene, then pass the ray intersection to the shade routine
--   (which may trace secondary rays of its own), which returns a color.
--   For most applications, this is the entry point into the ray tracer.
trace :: ctxa -> Shader t m ctxa ctxb -> SolidItem t m -> Ray -> Flt -> Int -> (ColorA, [t], Rayint t m)

module Data.Glome.Shader
data Light
Light :: !Vec -> !Color -> (Flt -> Flt) -> !Flt -> !Bool -> Light
litpos :: Light -> !Vec
litcol :: Light -> !Color
litfalloff :: Light -> Flt -> Flt
litrad :: Light -> !Flt
litshadow :: Light -> !Bool

-- | Construct a light given a center location and a color.
light :: Vec -> Color -> Light

-- | Surface properties at a point on an object's surface. Much of this is
--   standard whitted-style illumination. Plain diffuse/specular suraces
--   can be defined with Surface.
--   
--   Reflection and Refraction have their own constructors. AdditiveLayers
--   is a way of stacking textures such that the colors are added together.
--   
--   Blend takes two textures and returns the result of cobining them.
--   
--   Warp is a little stranger; it takes a ray and re-casts into a separate
--   scene (or the same one, if you so choose).
data Material t
Surface :: Color -> Flt -> Flt -> Flt -> Flt -> Flt -> Bool -> Material t
Reflect :: Flt -> Material t
Refract :: Flt -> Flt -> Material t
Warp :: (SolidItem t (Material t)) -> (SolidItem t (Material t)) -> [Light] -> (Ray -> Rayint t (Material t) -> Ray) -> Material t
AdditiveLayers :: [Material t] -> Material t
Blend :: (Material t) -> (Material t) -> Flt -> Material t

-- | Uniform texture
t_uniform :: Material t -> Texture t (Material t)

-- | Calculate light intensity and direction at the current ray
--   intersection. We do this up front so we don't have to re-do the shadow
--   tests when we evaluate multiple layered textures.
mpreshade :: [Light] -> Ray -> SolidItem t (Material t) -> Rayint t (Material t) -> [(Color, Vec)]
mpostshade :: [Light] -> [(Color, Vec)] -> Material t -> Ray -> SolidItem t (Material t) -> Rayint t (Material t) -> Int -> (ColorA, [t])
mmissshade :: [Light] -> Ray -> SolidItem t (Material t) -> (ColorA, [t])
materialShader :: Shader t (Material t) [Light] [(Color, Vec)]

module Data.Glome.Spd
lexignore :: [Char] -> [(String, String)]
lexcr :: String -> [(String, String)]
type SI = SolidItem () (Material ())
data BgColor
BgColor :: (Color) -> BgColor
readsSpdVec :: ReadS Vec
readsSpdVecNorm :: ReadS (Vec, Vec)
readsSpdVecs :: ReadS [Vec]
readsSpdVecsNorms :: ReadS [(Vec, Vec)]
readsSpdCam :: ReadS Camera
readsSpdClr :: ReadS Color
readsSpdBackground :: ReadS BgColor
readsSpdLight :: ReadS Light
readsSpdFill :: ReadS (Texture () (Material ()))
readsSpdSolid :: ReadS SI
readsSpdPrims :: ReadS [SI]
readsSpdTextureGroup :: ReadS SI
accum_rss :: [Camera] -> [Light] -> [SI] -> [BgColor] -> String -> ([Camera], [Light], [SI], [BgColor], String)
data SPD
SPD :: SI -> [Light] -> Camera -> Color -> SPD
geom :: SPD -> SI
lights :: SPD -> [Light]
cam :: SPD -> Camera
bground :: SPD -> Color
readsSpdScene :: ReadS SPD
instance Read SPD
instance Read SI
instance Read [SI]
instance Read (Texture () (Material ()))
instance Read Light
instance Read BgColor
instance Read Color
instance Read Camera
instance Read [(Vec, Vec)]
instance Read [Vec]
instance Read (Vec, Vec)
instance Read Vec
