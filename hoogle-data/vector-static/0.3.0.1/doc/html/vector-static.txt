-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Statically checked sizes on Data.Vector
--   
--   Very unstable! Many interfaces are still incomplete or even empty. Nat
--   and Fin will be moving to a separate package eventually. This package
--   is not currently maintained.
@package vector-static
@version 0.3.0.1

module Data.Vector.Storable.Mutable.Static

module Data.Vector.Unboxed.Mutable.Static

module Data.Vector.Mutable.Static

module Data.Nat
newtype I x
I :: x -> I x
unI :: I x -> x
newtype K x y
K :: x -> K x y
unK :: K x y -> x
data Z
data S n
newtype Nat n
Nat :: Int -> Nat n
z :: Nat Z
s :: Nat n -> Nat (S n)
natToInt :: Nat n -> Int
data Reifiable n
Proof :: Reifiable n
data Exists
Ex :: !Reifiable n -> Exists
reifiable :: Nat n -> Reifiable n
class Reify n
witnessNat :: Reify n => Nat n
addNat :: Nat a -> Nat b -> Nat (a :+: b)
mulNat :: Nat a -> Nat b -> Nat (a :*: b)
data NatView n
Zero :: NatView Z
Succ :: Nat n -> NatView (S n)
view :: Nat n -> NatView n
instance Reify n => Reify (S n)
instance Reify Z
instance Show (Nat n)

module Data.Fin
newtype Fin n
Fin :: Int -> Fin n
zero :: Fin (S n)
succ :: Fin n -> Fin (S n)
pred :: Fin n -> Fin n
addFin :: Fin x -> Fin y -> Fin (x :+: y)
mulFin :: Fin x -> Fin y -> Fin (x :*: y)
mulNatFin :: Reify x => Fin (S y) -> Fin (S (x :*: y))
raise :: Fin n -> Fin (n :+: k)
intToFin :: Reify n => Int -> Maybe (Fin n)
finToInt :: Fin n -> Int
natToFin :: Reify n => Fin (S n)
instance Show (Fin n)
instance Eq (Fin n)
instance Ord (Fin n)

module Data.Vector.Unboxed.Fin
instance Unbox (Fin n)
instance MVector v Int => MVector v (Fin n)
instance Vector v Int => Vector v (Fin n)

module Data.Vector.Generic.Static
newtype Vec n v a
Vec :: v a -> Vec n v a
unVec :: Vec n v a -> v a
length :: Reify n => Vec n v a -> Nat n
null :: Reify n => Vec n v a -> Bool
empty :: Vector v a => Vec Z v a
singleton :: Vector v a => a -> Vec (S Z) v a
cons :: Vector v a => a -> Vec n v a -> Vec (S n) v a
snoc :: Vector v a => Vec n v a -> a -> Vec (S n) v a
replicate :: (Vector v a, Reify n) => a -> Vec n v a
generate :: (Vector v a, Reify n) => (Fin n -> a) -> Vec n v a
(++) :: Vector v a => Vec m v a -> Vec n v a -> Vec (m :+: n) v a
copy :: Vector v a => Vec n v a -> Vec n v a
(!) :: Vector v a => Vec n v a -> Fin n -> a
head :: Vector v a => Vec (S n) v a -> a
last :: Vector v a => Vec (S n) v a -> a
indexM :: (Vector v a, Monad m) => Vec n v a -> Fin n -> m a
headM :: (Vector v a, Monad m) => Vec (S n) v a -> m a
lastM :: (Vector v a, Monad m) => Vec (S n) v a -> m a
slice :: (Vector v a, Reify k) => Fin n -> Vec (n :+: k) v a -> Vec k v a
init :: Vector v a => Vec (S n) v a -> Vec n v a
tail :: Vector v a => Vec (S n) v a -> Vec n v a
take :: (Vector v a, Reify k) => Vec (n :+: k) v a -> Vec k v a
drop :: (Vector v a, Reify k) => Vec (n :+: k) v a -> Vec n v a
backpermute :: (Vector v a, Vector v Int) => Vec m v a -> Vec n v (Fin m) -> Vec n v a
reverse :: Vector v a => Vec n v a -> Vec n v a
map :: (Vector v a, Vector v b) => (a -> b) -> Vec n v a -> Vec n v b
imap :: (Vector v a, Vector v b) => (Fin n -> a -> b) -> Vec n v a -> Vec n v b
concatMap :: (Vector v a, Vector v b) => (a -> Vec n v b) -> Vec m v a -> Vec (m :*: n) v b
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Vec n v a -> Vec n v b -> Vec n v c
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v f -> Vec n v g
izipWith :: (Vector v a, Vector v b, Vector v c) => (Fin n -> a -> b -> c) -> Vec n v a -> Vec n v b -> Vec n v c
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Fin n -> a -> b -> c -> d) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (Fin n -> a -> b -> c -> d -> e) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (Fin n -> a -> b -> c -> d -> e -> f) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (Fin n -> a -> b -> c -> d -> e -> f -> g) -> Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v f -> Vec n v g
zip :: (Vector v a, Vector v b, Vector v (a, b)) => Vec n v a -> Vec n v b -> Vec n v (a, b)
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Vec n v a -> Vec n v b -> Vec n v c -> Vec n v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Vec n v a -> Vec n v b -> Vec n v c -> Vec n v d -> Vec n v e -> Vec n v f -> Vec n v (a, b, c, d, e, f)
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => Vec n v (a, b) -> (Vec n v a, Vec n v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Vec n v (a, b, c) -> (Vec n v a, Vec n v b, Vec n v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Vec n v (a, b, c, d) -> (Vec n v a, Vec n v b, Vec n v c, Vec n v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Vec n v (a, b, c, d, e) -> (Vec n v a, Vec n v b, Vec n v c, Vec n v d, Vec n v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Vec n v (a, b, c, d, e, f) -> (Vec n v a, Vec n v b, Vec n v c, Vec n v d, Vec n v e, Vec n v f)
elem :: (Vector v a, Eq a) => a -> Vec n v a -> Bool
notElem :: (Vector v a, Eq a) => a -> Vec n v a -> Bool
find :: (Vector v a, Eq a) => (a -> Bool) -> Vec n v a -> Maybe a
findIndex :: Vector v a => (a -> Bool) -> Vec n v a -> Maybe (Fin n)
elemIndex :: Vector v a => Eq a => a -> Vec n v a -> Maybe (Fin n)
foldl :: Vector v b => (a -> b -> a) -> a -> Vec n v b -> a
foldl1 :: Vector v a => (a -> a -> a) -> Vec (S n) v a -> a
foldl' :: Vector v b => (a -> b -> a) -> a -> Vec n v b -> a
foldl1' :: Vector v a => (a -> a -> a) -> Vec (S n) v a -> a
foldr :: Vector v a => (a -> b -> b) -> b -> Vec n v a -> b
foldr1 :: Vector v a => (a -> a -> a) -> Vec (S n) v a -> a
foldr' :: Vector v a => (a -> b -> b) -> b -> Vec n v a -> b
foldr1' :: Vector v a => (a -> a -> a) -> Vec (S n) v a -> a
ifoldl :: Vector v b => (a -> Fin n -> b -> a) -> a -> Vec n v b -> a
ifoldl' :: Vector v b => (a -> Fin n -> b -> a) -> a -> Vec n v b -> a
ifoldr :: Vector v a => (Fin n -> a -> b -> b) -> b -> Vec n v a -> b
ifoldr' :: Vector v a => (Fin n -> a -> b -> b) -> b -> Vec n v a -> b
all :: Vector v a => (a -> Bool) -> Vec n v a -> Bool
any :: Vector v a => (a -> Bool) -> Vec n v a -> Bool
and :: Vector v Bool => Vec n v Bool -> Bool
or :: Vector v Bool => Vec n v Bool -> Bool
sum :: (Vector v a, Num a) => Vec n v a -> a
product :: (Vector v a, Num a) => Vec n v a -> a
minimum :: (Ord a, Vector v a) => Vec (S n) v a -> a
minimumBy :: Vector v a => (a -> a -> Ordering) -> Vec (S n) v a -> a
minIndex :: (Ord a, Vector v a) => Vec (S n) v a -> Fin (S n)
minIndexBy :: Vector v a => (a -> a -> Ordering) -> Vec (S n) v a -> Fin (S n)
maximum :: (Ord a, Vector v a) => Vec (S n) v a -> a
maximumBy :: Vector v a => (a -> a -> Ordering) -> Vec (S n) v a -> a
maxIndex :: (Ord a, Vector v a) => Vec (S n) v a -> Fin (S n)
maxIndexBy :: Vector v a => (a -> a -> Ordering) -> Vec (S n) v a -> Fin (S n)
unfoldr :: Vector v a => (b -> Maybe (a, b)) -> b -> (forall n. Vec n v a -> r) -> r
enumFromN :: (Vector v a, Num a, Reify n) => a -> Vec n v a
enumFromStepN :: (Vector v a, Num a, Reify n) => a -> a -> Vec n v a
toList :: Vector v a => Vec n v a -> [a]
fromList :: Vector v a => [a] -> (forall n. Vec n v a -> r) -> r
stream :: Vector v a => Vec n v a -> Stream a
unstream :: Vector v a => Stream a -> (forall n. Vec n v a -> r) -> r
streamR :: Vector v a => Vec n v a -> Stream a
unstreamR :: Vector v a => Stream a -> (forall n. Vec n v a -> r) -> r
new :: Vector v a => New a -> (forall n. Vec n v a -> r) -> r
allFin :: (Vector v (Fin n), Reify n) => Vec n v (Fin n)
indexed :: (Vector v a, Vector v (Fin n, a)) => Vec n v a -> Vec n v (Fin n, a)
instance Show (v a) => Show (Vec n v a)
instance Eq (v a) => Eq (Vec n v a)
instance Ord (v a) => Ord (Vec n v a)

module Data.Vector.Generic.Mutable.Static
newtype MVec n v s a
MVec :: v s a -> MVec n v s a
unVec :: MVec n v s a -> v s a
overlaps :: MVector v a => MVec n v s a -> MVec n v s a -> Bool
new :: (PrimMonad m, MVector v a, Reify n) => m (MVec n v (PrimState m) a)
newWith :: (PrimMonad m, MVector v a, Reify n) => a -> m (MVec n v (PrimState m) a)
read :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> Fin n -> m a
write :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> Fin n -> a -> m ()
swap :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> Fin n -> Fin n -> m ()
clear :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> m ()
set :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> a -> m ()
copy :: (PrimMonad m, MVector v a) => MVec n v (PrimState m) a -> MVec n v (PrimState m) a -> m ()
grow :: (PrimMonad m, MVector v a, Reify k) => MVec n v (PrimState m) a -> m (MVec (n :+: k) v (PrimState m) a)
slice :: (MVector v a, Reify k) => Fin n -> MVec (n :+: k) v s a -> MVec k v s a
take :: (MVector v a, Reify k) => MVec (n :+: k) v s a -> MVec k v s a
drop :: (MVector v a, Reify n) => MVec (n :+: k) v s a -> MVec n v s a
init :: MVector v a => MVec (S n) v s a -> MVec n v s a
tail :: MVector v a => MVec (S n) v s a -> MVec n v s a
instance Show (v s a) => Show (MVec n v s a)
instance Eq (v s a) => Eq (MVec n v s a)

module Data.Vector.Static
newtype Vec n a
Vec :: Vec n Vector a -> Vec n a
unVec :: Vec n a -> Vec n Vector a
diagonal :: Reify n => Vec n (Vec n a) -> Vec n a
length :: Reify n => Vec n a -> Nat n
null :: Reify n => Vec n a -> Bool
empty :: Vec Z a
singleton :: a -> Vec (S Z) a
cons :: a -> Vec n a -> Vec (S n) a
snoc :: Vec n a -> a -> Vec (S n) a
replicate :: Reify n => a -> Vec n a
generate :: Reify n => (Fin n -> a) -> Vec n a
(++) :: Vec m a -> Vec n a -> Vec (m :+: n) a
copy :: Vec n a -> Vec n a
(!) :: Vec n a -> Fin n -> a
head :: Vec (S n) a -> a
last :: Vec (S n) a -> a
indexM :: Monad m => Vec n a -> Fin n -> m a
headM :: Monad m => Vec (S n) a -> m a
lastM :: Monad m => Vec (S n) a -> m a
slice :: Reify k => Fin n -> Vec (n :+: k) a -> Vec k a
init :: Vec (S n) a -> Vec n a
tail :: Vec (S n) a -> Vec n a
backpermute :: Vec m a -> Vec n (Fin m) -> Vec n a
reverse :: Vec n a -> Vec n a
map :: (a -> b) -> Vec n a -> Vec n b
imap :: (Fin n -> a -> b) -> Vec n a -> Vec n b
concatMap :: (a -> Vec n b) -> Vec m a -> Vec (m :*: n) b
zipWith :: (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
zipWith3 :: (a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
zipWith4 :: (a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
izipWith :: (Fin n -> a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
izipWith3 :: (Fin n -> a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
izipWith4 :: (Fin n -> a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
izipWith5 :: (Fin n -> a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
izipWith6 :: (Fin n -> a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
zip :: Vec n a -> Vec n b -> Vec n (a, b)
zip3 :: Vec n a -> Vec n b -> Vec n c -> Vec n (a, b, c)
zip4 :: Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n (a, b, c, d)
zip5 :: Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n (a, b, c, d, e)
zip6 :: Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n (a, b, c, d, e, f)
unzip :: Vec n (a, b) -> (Vec n a, Vec n b)
unzip3 :: Vec n (a, b, c) -> (Vec n a, Vec n b, Vec n c)
unzip4 :: Vec n (a, b, c, d) -> (Vec n a, Vec n b, Vec n c, Vec n d)
unzip5 :: Vec n (a, b, c, d, e) -> (Vec n a, Vec n b, Vec n c, Vec n d, Vec n e)
unzip6 :: Vec n (a, b, c, d, e, f) -> (Vec n a, Vec n b, Vec n c, Vec n d, Vec n e, Vec n f)
elem :: Eq a => a -> Vec n a -> Bool
notElem :: Eq a => a -> Vec n a -> Bool
find :: Eq a => (a -> Bool) -> Vec n a -> Maybe a
findIndex :: (a -> Bool) -> Vec n a -> Maybe (Fin n)
elemIndex :: Eq a => a -> Vec n a -> Maybe (Fin n)
foldl :: (a -> b -> a) -> a -> Vec n b -> a
foldl1 :: (a -> a -> a) -> Vec (S n) a -> a
foldl' :: (a -> b -> a) -> a -> Vec n b -> a
foldl1' :: (a -> a -> a) -> Vec (S n) a -> a
foldr :: (a -> b -> b) -> b -> Vec n a -> b
foldr1 :: (a -> a -> a) -> Vec (S n) a -> a
foldr' :: (a -> b -> b) -> b -> Vec n a -> b
foldr1' :: (a -> a -> a) -> Vec (S n) a -> a
ifoldl :: (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldl' :: (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldr :: (Fin n -> a -> b -> b) -> b -> Vec n a -> b
ifoldr' :: (Fin n -> a -> b -> b) -> b -> Vec n a -> b
all :: (a -> Bool) -> Vec n a -> Bool
any :: (a -> Bool) -> Vec n a -> Bool
and :: Vec n Bool -> Bool
or :: Vec n Bool -> Bool
sum :: Num a => Vec n a -> a
product :: Num a => Vec n a -> a
minimum :: Ord a => Vec (S n) a -> a
minimumBy :: (a -> a -> Ordering) -> Vec (S n) a -> a
minIndex :: Ord a => Vec (S n) a -> Fin (S n)
minIndexBy :: (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
maximum :: Ord a => Vec (S n) a -> a
maximumBy :: (a -> a -> Ordering) -> Vec (S n) a -> a
maxIndex :: Ord a => Vec (S n) a -> Fin (S n)
maxIndexBy :: (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
unfoldr :: (b -> Maybe (a, b)) -> b -> (forall n. Vec n a -> r) -> r
enumFromN :: (Num a, Reify n) => a -> Vec n a
enumFromStepN :: (Num a, Reify n) => a -> a -> Vec n a
toList :: Vec n a -> [a]
fromList :: [a] -> (forall n. Vec n a -> r) -> r
stream :: Vec n a -> Stream a
unstream :: Stream a -> (forall n. Vec n a -> r) -> r
streamR :: Vec n a -> Stream a
unstreamR :: Stream a -> (forall n. Vec n a -> r) -> r
new :: New a -> (forall n. Vec n a -> r) -> r
allFin :: Reify n => Vec n (Fin n)
instance Eq a => Eq (Vec n a)
instance Ord a => Ord (Vec n a)
instance Show a => Show (Vec n a)
instance (Reify n, Floating a) => Floating (Vec n a)
instance (Reify n, Fractional a) => Fractional (Vec n a)
instance (Reify n, Num a) => Num (Vec n a)
instance (Reify n, Bounded a) => Bounded (Vec n a)
instance (Reify n, Monoid a) => Monoid (Vec n a)
instance Foldable (Vec n)
instance Reify n => Monad (Vec n)
instance Reify n => Applicative (Vec n)
instance Functor (Vec n)

module Data.Vector.Unboxed.Static
newtype Vec n a
Vec :: Vec n Vector a -> Vec n a
unVec :: Vec n a -> Vec n Vector a
length :: Reify n => Vec n a -> Nat n
null :: Reify n => Vec n a -> Bool
empty :: Unbox a => Vec Z a
singleton :: Unbox a => a -> Vec (S Z) a
cons :: Unbox a => a -> Vec n a -> Vec (S n) a
snoc :: Unbox a => Vec n a -> a -> Vec (S n) a
replicate :: (Unbox a, Reify n) => a -> Vec n a
generate :: (Reify n, Unbox a) => (Fin n -> a) -> Vec n a
(++) :: Unbox a => Vec m a -> Vec n a -> Vec (m :+: n) a
copy :: Unbox a => Vec n a -> Vec n a
(!) :: Unbox a => Vec n a -> Fin n -> a
head :: Unbox a => Vec (S n) a -> a
last :: Unbox a => Vec (S n) a -> a
indexM :: (Monad m, Unbox a) => Vec n a -> Fin n -> m a
headM :: (Unbox a, Monad m) => Vec (S n) a -> m a
lastM :: (Unbox a, Monad m) => Vec (S n) a -> m a
slice :: (Reify k, Unbox a) => Fin n -> Vec (n :+: k) a -> Vec k a
init :: Unbox a => Vec (S n) a -> Vec n a
tail :: Unbox a => Vec (S n) a -> Vec n a
backpermute :: Unbox a => Vec m a -> Vec n (Fin m) -> Vec n a
reverse :: Unbox a => Vec n a -> Vec n a
map :: (Unbox a, Unbox b) => (a -> b) -> Vec n a -> Vec n b
imap :: (Unbox a, Unbox b) => (Fin n -> a -> b) -> Vec n a -> Vec n b
concatMap :: (Unbox a, Unbox b) => (a -> Vec n b) -> Vec m a -> Vec (m :*: n) b
zipWith :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
zipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
zipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
zipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
zipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
izipWith :: (Unbox a, Unbox b, Unbox c) => (Fin n -> a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
izipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (Fin n -> a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
izipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (Fin n -> a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
izipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (Fin n -> a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
izipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (Fin n -> a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
zip :: (Unbox a, Unbox b) => Vec n a -> Vec n b -> Vec n (a, b)
zip3 :: (Unbox a, Unbox b, Unbox c) => Vec n a -> Vec n b -> Vec n c -> Vec n (a, b, c)
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n (a, b, c, d)
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n (a, b, c, d, e)
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n (a, b, c, d, e, f)
unzip :: (Unbox a, Unbox b) => Vec n (a, b) -> (Vec n a, Vec n b)
unzip3 :: (Unbox a, Unbox b, Unbox c) => Vec n (a, b, c) -> (Vec n a, Vec n b, Vec n c)
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vec n (a, b, c, d) -> (Vec n a, Vec n b, Vec n c, Vec n d)
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vec n (a, b, c, d, e) -> (Vec n a, Vec n b, Vec n c, Vec n d, Vec n e)
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vec n (a, b, c, d, e, f) -> (Vec n a, Vec n b, Vec n c, Vec n d, Vec n e, Vec n f)
elem :: (Unbox a, Eq a) => a -> Vec n a -> Bool
notElem :: (Unbox a, Eq a) => a -> Vec n a -> Bool
find :: (Unbox a, Eq a) => (a -> Bool) -> Vec n a -> Maybe a
findIndex :: Unbox a => (a -> Bool) -> Vec n a -> Maybe (Fin n)
elemIndex :: (Unbox a, Eq a) => a -> Vec n a -> Maybe (Fin n)
foldl :: Unbox b => (a -> b -> a) -> a -> Vec n b -> a
foldl1 :: Unbox a => (a -> a -> a) -> Vec (S n) a -> a
foldl' :: Unbox b => (a -> b -> a) -> a -> Vec n b -> a
foldl1' :: Unbox a => (a -> a -> a) -> Vec (S n) a -> a
foldr :: Unbox a => (a -> b -> b) -> b -> Vec n a -> b
foldr1 :: Unbox a => (a -> a -> a) -> Vec (S n) a -> a
foldr' :: Unbox a => (a -> b -> b) -> b -> Vec n a -> b
foldr1' :: Unbox a => (a -> a -> a) -> Vec (S n) a -> a
ifoldl :: Unbox b => (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldl' :: Unbox b => (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldr :: Unbox a => (Fin n -> a -> b -> b) -> b -> Vec n a -> b
ifoldr' :: Unbox a => (Fin n -> a -> b -> b) -> b -> Vec n a -> b
all :: Unbox a => (a -> Bool) -> Vec n a -> Bool
any :: Unbox a => (a -> Bool) -> Vec n a -> Bool
and :: Vec n Bool -> Bool
or :: Vec n Bool -> Bool
sum :: (Unbox a, Num a) => Vec n a -> a
product :: (Unbox a, Num a) => Vec n a -> a
minimum :: (Unbox a, Ord a) => Vec (S n) a -> a
minimumBy :: Unbox a => (a -> a -> Ordering) -> Vec (S n) a -> a
minIndex :: (Unbox a, Ord a) => Vec (S n) a -> Fin (S n)
minIndexBy :: Unbox a => (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
maximum :: (Unbox a, Ord a) => Vec (S n) a -> a
maximumBy :: Unbox a => (a -> a -> Ordering) -> Vec (S n) a -> a
maxIndex :: (Unbox a, Ord a) => Vec (S n) a -> Fin (S n)
maxIndexBy :: Unbox a => (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
unfoldr :: Unbox a => (b -> Maybe (a, b)) -> b -> (forall n. Vec n a -> r) -> r
enumFromN :: (Unbox a, Num a, Reify n) => a -> Vec n a
enumFromStepN :: (Unbox a, Num a, Reify n) => a -> a -> Vec n a
toList :: Unbox a => Vec n a -> [a]
fromList :: Unbox a => [a] -> (forall n. Vec n a -> r) -> r
stream :: Unbox a => Vec n a -> Stream a
unstream :: Unbox a => Stream a -> (forall n. Vec n a -> r) -> r
streamR :: Unbox a => Vec n a -> Stream a
unstreamR :: Unbox a => Stream a -> (forall n. Vec n a -> r) -> r
new :: Unbox a => New a -> (forall n. Vec n a -> r) -> r
allFin :: Reify n => Vec n (Fin n)
instance (Eq a, Unbox a) => Eq (Vec n a)
instance (Ord a, Unbox a) => Ord (Vec n a)
instance (Show a, Unbox a) => Show (Vec n a)
instance (Reify n, Floating a, Unbox a) => Floating (Vec n a)
instance (Reify n, Fractional a, Unbox a) => Fractional (Vec n a)
instance (Reify n, Num a, Unbox a) => Num (Vec n a)
instance (Reify n, Bounded a, Unbox a) => Bounded (Vec n a)
instance (Reify n, Monoid a, Unbox a) => Monoid (Vec n a)
instance (Unbox a, Reify n) => Vector Vector (Vec n a)
instance (Reify n, Unbox a) => MVector MVector (Vec n a)
instance (Unbox a, Reify n) => Unbox (Vec n a)

module Data.Vector.Storable.Static
newtype Vec n a
Vec :: Vec n Vector a -> Vec n a
unVec :: Vec n a -> Vec n Vector a
length :: Reify n => Vec n a -> Nat n
null :: Reify n => Vec n a -> Bool
empty :: Storable a => Vec Z a
singleton :: Storable a => a -> Vec (S Z) a
cons :: Storable a => a -> Vec n a -> Vec (S n) a
snoc :: Storable a => Vec n a -> a -> Vec (S n) a
replicate :: (Storable a, Reify n) => a -> Vec n a
generate :: (Reify n, Storable a) => (Fin n -> a) -> Vec n a
(++) :: Storable a => Vec m a -> Vec n a -> Vec (m :+: n) a
copy :: Storable a => Vec n a -> Vec n a
(!) :: Storable a => Vec n a -> Fin n -> a
head :: Storable a => Vec (S n) a -> a
last :: Storable a => Vec (S n) a -> a
indexM :: (Storable a, Monad m) => Vec n a -> Fin n -> m a
headM :: (Storable a, Monad m) => Vec (S n) a -> m a
lastM :: (Storable a, Monad m) => Vec (S n) a -> m a
slice :: (Reify k, Storable a) => Fin n -> Vec (n :+: k) a -> Vec k a
init :: Storable a => Vec (S n) a -> Vec n a
tail :: Storable a => Vec (S n) a -> Vec n a
backpermute :: Storable a => Vec m a -> Vec n (Fin m) -> Vec n a
reverse :: Storable a => Vec n a -> Vec n a
map :: (Storable a, Storable b) => (a -> b) -> Vec n a -> Vec n b
imap :: (Storable a, Storable b) => (Fin n -> a -> b) -> Vec n a -> Vec n b
concatMap :: (Storable a, Storable b) => (a -> Vec n b) -> Vec m a -> Vec (m :*: n) b
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
zipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
zipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
izipWith :: (Storable a, Storable b, Storable c) => (Fin n -> a -> b -> c) -> Vec n a -> Vec n b -> Vec n c
izipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (Fin n -> a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d
izipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (Fin n -> a -> b -> c -> d -> e) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e
izipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (Fin n -> a -> b -> c -> d -> e -> f) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f
izipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (Fin n -> a -> b -> c -> d -> e -> f -> g) -> Vec n a -> Vec n b -> Vec n c -> Vec n d -> Vec n e -> Vec n f -> Vec n g
elem :: (Storable a, Eq a) => a -> Vec n a -> Bool
notElem :: (Storable a, Eq a) => a -> Vec n a -> Bool
find :: (Storable a, Eq a) => (a -> Bool) -> Vec n a -> Maybe a
findIndex :: Storable a => (a -> Bool) -> Vec n a -> Maybe (Fin n)
elemIndex :: (Storable a, Eq a) => a -> Vec n a -> Maybe (Fin n)
foldl :: Storable b => (a -> b -> a) -> a -> Vec n b -> a
foldl1 :: Storable a => (a -> a -> a) -> Vec (S n) a -> a
foldl' :: Storable b => (a -> b -> a) -> a -> Vec n b -> a
foldl1' :: Storable a => (a -> a -> a) -> Vec (S n) a -> a
foldr :: Storable a => (a -> b -> b) -> b -> Vec n a -> b
foldr1 :: Storable a => (a -> a -> a) -> Vec (S n) a -> a
foldr' :: Storable a => (a -> b -> b) -> b -> Vec n a -> b
foldr1' :: Storable a => (a -> a -> a) -> Vec (S n) a -> a
ifoldl :: Storable b => (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldl' :: Storable b => (a -> Fin n -> b -> a) -> a -> Vec n b -> a
ifoldr :: Storable a => (Fin n -> a -> b -> b) -> b -> Vec n a -> b
ifoldr' :: Storable a => (Fin n -> a -> b -> b) -> b -> Vec n a -> b
all :: Storable a => (a -> Bool) -> Vec n a -> Bool
any :: Storable a => (a -> Bool) -> Vec n a -> Bool
and :: Vec n Bool -> Bool
or :: Vec n Bool -> Bool
sum :: (Storable a, Num a) => Vec n a -> a
product :: (Storable a, Num a) => Vec n a -> a
minimum :: (Storable a, Ord a) => Vec (S n) a -> a
minimumBy :: Storable a => (a -> a -> Ordering) -> Vec (S n) a -> a
minIndex :: (Storable a, Ord a) => Vec (S n) a -> Fin (S n)
minIndexBy :: Storable a => (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
maximum :: (Storable a, Ord a) => Vec (S n) a -> a
maximumBy :: Storable a => (a -> a -> Ordering) -> Vec (S n) a -> a
maxIndex :: (Storable a, Ord a) => Vec (S n) a -> Fin (S n)
maxIndexBy :: Storable a => (a -> a -> Ordering) -> Vec (S n) a -> Fin (S n)
unfoldr :: Storable a => (b -> Maybe (a, b)) -> b -> (forall n. Vec n a -> r) -> r
enumFromN :: (Storable a, Num a, Reify n) => a -> Vec n a
enumFromStepN :: (Storable a, Num a, Reify n) => a -> a -> Vec n a
toList :: Storable a => Vec n a -> [a]
fromList :: Storable a => [a] -> (forall n. Vec n a -> r) -> r
stream :: Storable a => Vec n a -> Stream a
unstream :: Storable a => Stream a -> (forall n. Vec n a -> r) -> r
streamR :: Storable a => Vec n a -> Stream a
unstreamR :: Storable a => Stream a -> (forall n. Vec n a -> r) -> r
new :: Storable a => New a -> (forall n. Vec n a -> r) -> r
