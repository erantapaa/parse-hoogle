-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Object-oriented programming with duck typing and
singleton classes.
--   
--   This package aims to combine the merit of Haskell's open, strong type
--   system with flexible Object-oriented programming found in
--   dynamically-typed languages such as python or ruby.
--   
--   <tt>Object</tt>s are implemented as <tt>Map</tt>s from method keys to
--   values. Each key specifies its own value types. You can add new
--   members at runtime, for any instances of the object (singleton class).
--   At the same time, you have typed and runtime-error-free access to the
--   members (duck typing).
--   
--   See <tt>Data.Object.Dynamic.Examples.PointParticle</tt> for examples.
@package dynamic-object
@version 0.2.1

module Data.Object.Dynamic.Type

-- | The <a>Object</a> type, where <tt>u</tt> carrying the information of
--   its underlying types.
newtype Object u
Object :: Table -> Object u
unObject :: Object u -> Table

-- | The <a>Table</a> within an <a>Object</a> that carries all the member
--   data.
newtype Table
Table :: TableMap -> Table
unTable :: Table -> TableMap

-- | The <a>Map</a> type within the table.
type TableMap = Map TypeRep Dynamic

-- | <tt>o</tt> is an <a>Objective</a> if given its type information, there
--   is an equivalence between <tt>o</tt> and the <a>Table</a>.
class Objective o where tableMap = table . (iso unTable Table)
table :: Objective o => Simple Iso o Table
tableMap :: Objective o => Simple Iso o (Map TypeRep Dynamic)

-- | This means that <tt>memb</tt> is one of the member labels of
--   <tt>o</tt>. The <a>ValType</a> of the member depends both on the label
--   and (the underlying types of) the object.
class (Objective o, Typeable memb, Typeable (ValType o memb)) => Member o memb where type family ValType o memb :: * memberLens = mkMemberLens memberLookup = mkMemberLookup
memberLens :: Member o memb => memb -> MemberLens o memb
memberLookup :: Member o memb => memb -> Acyclic o (ValType o memb)

-- | The lens for accessing the <a>Member</a> of the <a>Object</a>.
type MemberLens o memb = Member o memb => Simple Traversal o (ValType o memb)

-- | A utility function for defining a <a>MemberLens</a> .
mkMemberLens :: Member o memb => memb -> MemberLens o memb

-- | A utility function for defining a <tt>MemberLookup</tt>, with a
--   default computation for the case the member is missing.
mkMemberLookupDef :: Member o memb => memb -> Acyclic o (ValType o memb) -> Acyclic o (ValType o memb)

-- | Defining a <tt>MemberLookup</tt>, without default.
mkMemberLookup :: Member o memb => memb -> Acyclic o (ValType o memb)

-- | Given a pair of <a>Member</a> label and a value, create the data field
--   for the member and inserts the value.
insert :: (Objective o, Member o memb, ValType o memb ~ val, Typeable memb, Typeable val) => memb -> val -> o -> o

-- | Acyclic monad is used to lookup a member of the object with
--   infinite-loop detection.
type Acyclic o a = RWST o () (Set TypeRep) Maybe a
its :: Member o memb => memb -> Acyclic o (ValType o memb)
acyclically :: Member o memb => Acyclic o (ValType o memb) -> memb -> Acyclic o (ValType o memb)
instance Objective (Object u)

module Data.Object.Dynamic.Underlying

-- | The declaration of <tt>instance</tt> <a>Objective</a> <tt>obj</tt> ,
--   <tt>instance</tt> <a>UseReal</a> <tt>obj</tt> means that the
--   <tt>obj</tt> is an <a>Object</a> and is ready to tell the
--   <a>Member</a>s which type to use to represent the real numbers.
class Typeable (UnderlyingReal a) => UseReal a where type family UnderlyingReal a :: *

-- | Underlying integer types.
class Typeable (UnderlyingInteger a) => UseInteger a where type family UnderlyingInteger a :: *

-- | Underlying string types.
class Typeable (UnderlyingString a) => UseString a where type family UnderlyingString a :: *
instance UseString u => UseString (Object u)
instance UseInteger u => UseInteger (Object u)
instance UseReal u => UseReal (Object u)


-- | This module provides two presets for the <tt>Object</tt>: <a>DIT</a>
--   for daily use, and <a>Precise</a> for arbitrary precision
--   calculations.
module Data.Object.Dynamic.Presets

-- | <tt>Object</tt> <a>DIT</a> uses <a>Double</a> for real numbers,
--   <a>Int</a> for integers and <a>Text</a> for strings.
--   
--   <pre>
--   &gt;&gt;&gt; typechecks :: (UnderlyingReal (Object DIT) ~ Double) =&gt; Bool
--   True
--   
--   &gt;&gt;&gt; typechecks :: (UnderlyingInteger (Object DIT) ~ Int) =&gt; Bool
--   True
--   
--   &gt;&gt;&gt; typechecks :: (UnderlyingString (Object DIT) ~ Data.Text.Text) =&gt; Bool
--   True
--   </pre>
data DIT

-- | <tt>Object</tt> <a>Precise</a> uses <a>Double</a> for real numbers,
--   <a>Int</a> for integers and <a>Text</a> for strings.
--   
--   <pre>
--   &gt;&gt;&gt; typechecks :: (UnderlyingReal (Object Precise) ~ Rational) =&gt; Bool
--   True
--   
--   &gt;&gt;&gt; typechecks :: (UnderlyingInteger (Object Precise) ~ Integer) =&gt; Bool
--   True
--   
--   &gt;&gt;&gt; typechecks :: (UnderlyingString (Object Precise) ~ Data.Text.Text) =&gt; Bool
--   True
--   </pre>
data Precise
instance UseString Precise
instance UseInteger Precise
instance UseReal Precise
instance UseString DIT
instance UseInteger DIT
instance UseReal DIT


-- | This module re-exports things needed to use <a>Object</a>s, and adds a
--   few utility functions.
module Data.Object.Dynamic

-- | The <a>Object</a> type, where <tt>u</tt> carrying the information of
--   its underlying types.
data Object u

-- | An empty object.
empty :: Objective o => o

-- | Given a pair of <a>Member</a> label and a value, create the data field
--   for the member and inserts the value.
insert :: (Objective o, Member o memb, ValType o memb ~ val, Typeable memb, Typeable val) => memb -> val -> o -> o

-- | The lens for accessing the <a>Member</a> of the <a>Object</a>.
type MemberLens o memb = Member o memb => Simple Traversal o (ValType o memb)


-- | Here we use <tt>dynamic-object</tt> to descibe the concept of
--   point-like particles from classical mechanics. Also read the HSpec
--   tests :
--   <a>https://github.com/nushio3/dynamic-object/blob/master/test/ObjectSpec.hs</a>
--   for more details.
module Data.Object.Dynamic.Examples.PointParticle

-- | First, let us create a tiny two-dimensional vector class. We make it
--   an instance of <a>Arbitrary</a> to use them later for tests.
data Vec a
Vec :: a -> a -> Vec a

-- | Now, let us introduce the concepts of <a>Mass</a>, <a>Velocity</a>,
--   <a>Momentum</a> and <a>KineticEnergy</a>. Any such concepts are
--   described in terms of <a>Member</a> labels.
data Mass
Mass :: Mass

-- | To define a member with compound types like vector of real numbers, we
--   use <a>UnderlyingReal</a> to ask the object which real value it
--   prefers, then put the response into the type constructors.
--   
--   We also give a fallback accessor here. If the <a>velocity</a> field is
--   missing, we attempt to re-calculate it from the <a>mass</a> and
--   <a>momentum</a>. Here is how we can do that.
data Velocity
Velocity :: Velocity

-- | If the <a>momentum</a> field is missing, we re-calculate it from the
--   <a>mass</a> and <a>velocity</a>.
data Momentum
Momentum :: Momentum

-- | <a>kineticEnergy</a>, unless given explicitly, is defined in terms of
--   <a>mass</a> and <a>velocity</a> .
data KineticEnergy
KineticEnergy :: KineticEnergy

-- | Now we define the lenses.
mass :: MemberLens o Mass
velocity :: MemberLens o Velocity
momentum :: (UseReal o, Fractional (UnderlyingReal o)) => MemberLens o Momentum
kineticEnergy :: (UseReal o, Fractional (UnderlyingReal o)) => MemberLens o KineticEnergy

-- | We can write functions that would construct a point particle from its
--   mass and velocity. And we can make the function polymorphic over the
--   representation of the real numbers the objects prefer.
fromMassVelocity :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => real -> Vec real -> o

-- | We can also construct a point particle from its mass and momentum.
fromMassMomentum :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => real -> Vec real -> o

-- | We define an instance of point-like particle. And again, we can keep
--   it polymorphic, so that anyone can choose its concrete type later,
--   according to their purpose. Thus we will achieve the polymorphic
--   encoding of the knowledge of this world, in Haskell.
--   
--   <pre>
--   &gt;&gt;&gt; (laserBeam :: Object DIT) ^? kineticEnergy
--   Just 1631.25
--   
--   &gt;&gt;&gt; (laserBeam :: Object Precise) ^? kineticEnergy
--   Just (6525 % 4)
--   </pre>
--   
--   Moreover, we can ask Ichiro to sign the ball. Usually, we needed to
--   create a new data-type to add a new field. But with 'dynamic-object'
--   we can do so without changing the type of the ball. So, we can put our
--   precious, one-of-a-kind ball into toybox together with less uncommon
--   balls, and with various other toys. And still, we can safely access
--   the contents of the toybox without runtime errors, and e.g. see which
--   toy is the heaviest.
--   
--   <pre>
--   &gt;&gt;&gt; let (mySpecialBall :: Object DIT) = laserBeam &amp; insert Autograph "Ichiro Suzuki"
--   
--   &gt;&gt;&gt; let toybox = [laserBeam, mySpecialBall]
--   
--   &gt;&gt;&gt; let toybox2 = toybox ++ [duck, lens, banana, envelope, ghost]
--   
--   &gt;&gt;&gt; maximum $ mapMaybe (^?mass) toybox2
--   5.2
--   </pre>
laserBeam :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => o
duck :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => o
lens :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => o
banana :: (Objective o, UseReal o, Fractional real, real ~ (UnderlyingReal o)) => o
envelope :: (Objective o, UseReal o, UseString o, Fractional (UnderlyingReal o), IsString (UnderlyingString o)) => o
ghost :: Objective o => o
instance Typeable1 Vec
instance Typeable Mass
instance Typeable Velocity
instance Typeable Momentum
instance Typeable KineticEnergy
instance Typeable Autograph
instance Eq a => Eq (Vec a)
instance Show a => Show (Vec a)
instance Ord a => Ord (Vec a)
instance (Objective o, UseString o) => Member o Autograph
instance (Objective o, UseReal o, Fractional (UnderlyingReal o)) => Member o KineticEnergy
instance (Objective o, UseReal o, Fractional (UnderlyingReal o)) => Member o Momentum
instance (Objective o, UseReal o, Fractional (UnderlyingReal o)) => Member o Velocity
instance (Objective o, UseReal o) => Member o Mass
instance Arbitrary a => Arbitrary (Vec a)
