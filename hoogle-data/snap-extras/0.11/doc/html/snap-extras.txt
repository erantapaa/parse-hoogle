-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of useful helpers and utilities for Snap web applications.
--   
@package snap-extras
@version 0.11

module Snap.Extras.NavTrails
data NavTrail b
NavTrail :: SnapletLens b SessionManager -> NavTrail b

-- | A session manager for the base
ntSes :: NavTrail b -> SnapletLens b SessionManager
initNavTrail :: SnapletLens b SessionManager -> Maybe (Snaplet (Heist b)) -> SnapletInit b (NavTrail b)
setFocus :: Handler b (NavTrail b) ()
setFocus' :: ByteString -> Handler b (NavTrail b) ()
setFocusToRef :: Handler b (NavTrail b) ()
getFocus :: Handler b (NavTrail b) (Maybe Text)
getFocusDef :: Text -> Handler b (NavTrail b) Text
redirBack :: MonadSnap m => m a
redirFocus :: ByteString -> Handler b (NavTrail b) a
backSplice :: MonadSnap m => HeistT m m Template
backCSplice :: Splice (Handler b v)
focusSplice :: SnapletLens (Snaplet v) (NavTrail b) -> Splice (Handler b v)
focusCSplice :: SnapletLens (Snaplet v) (NavTrail b) -> Splice (Handler b v)
addNavTrailSplices :: Snaplet (Heist b) -> Initializer b (NavTrail b) ()

module Snap.Extras.SpliceUtils.Interpreted

-- | Gets the value of a request parameter. Example use:
--   
--   <a>name="username"/</a>
paramSplice :: MonadSnap m => Splice m

-- | A list of splices offered in this module
utilSplices :: Splices (SnapletISplice b)

-- | Splice helper for when you're rendering a select element
selectSplice :: Monad m => Text -> Text -> [(Text, Text)] -> Maybe Text -> Splice m

-- | Assume text area contains the name of a splice as Text.
--   
--   This is helpful when you pass a default value to digestive-functors by
--   putting the name of a splice as the value of a textarea tag.
--   
--   <pre>
--   heistLocal runTextAreas $ render "joo/index"
--   </pre>
runTextAreas :: Monad m => HeistState m -> HeistState m

-- | Searches a directory on disk and all its subdirectories for all files
--   with names that don't begin with an underscore and end with a .js
--   extension. It then returns script tags for each of these files.
--   
--   You can use this function to create a splice:
--   
--   <pre>
--   ("staticscripts", scriptsSplice "static/js" "/")
--   </pre>
--   
--   Then when you use the <tt>&lt;staticscripts/&gt;</tt> tag in your
--   templates, it will automatically include all the javascript code in
--   the <tt>static/js</tt> directory.
scriptsSplice :: MonadIO m => FilePath -> String -> m [Node]

-- | Check to see if the boolean flag named by the "ref" attribute is
--   present and set to true in snaplet user config file. If so, run what's
--   inside this splice, if not, simply omit that part.
--   
--   Example:
--   
--   <pre>
--   &lt;flag ref="beta-functions-enabled"&gt;
--   stuff...
--   &lt;/flag&gt;
--   </pre>
--   
--   This will look for an entry inside your .cfg file:
--   
--   <pre>
--   beta-functions-enabled = true
--   </pre>
ifFlagSplice :: SnapletISplice b
refererSplice :: MonadSnap m => Splice m

module Snap.Extras.SpliceUtils.Compiled
utilSplices :: MonadSnap m => Splices (Splice m)
refererCSplice :: MonadSnap m => Splice m

-- | Gets the value of a request parameter. Example use:
--   
--   <a>name="username"/</a>
paramSplice :: MonadSnap m => Splice m

-- | Searches a directory on disk and all its subdirectories for all files
--   with names that don't begin with an underscore and end with a .js
--   extension. It then returns script tags for each of these files.
--   
--   You can use this function to create a splice:
--   
--   <pre>
--   ("staticscripts", scriptsSplice "static/js" "/")
--   </pre>
--   
--   Then when you use the <tt>&lt;staticscripts/&gt;</tt> tag in your
--   templates, it will automatically include all the javascript code in
--   the <tt>static/js</tt> directory.
scriptsSplice :: MonadIO m => FilePath -> String -> Splice m

-- | Sometimes in a loop you don't always want the same behavior for every
--   item. If you have a comma separated list, you usually don't want a
--   comma after the last item. If you have a list surrounded by
--   parentheses, you might not want the parentheses to show up if the list
--   is empty. Dealing with these situations can be a pain with the stock
--   looping splices, so we've provided this helper that solves all of
--   these problems.
--   
--   This function is similar to manyWithSplices, but it binds three
--   additional splices: "prelude", "interlude", and "postlude". The
--   children of the prelude and postlude splices only show up before the
--   beginning of the list and after the end of the list if the list is
--   non-empty. The children of the interlude splice are used as a
--   separator between each list element. If the list has only one element,
--   then the separator does not appear. These splices have this behavior
--   regardless of where they appear in the parent tag.
fancyLoopSplice :: Monad n => Splices (RuntimeSplice n a -> Splice n) -> RuntimeSplice n [a] -> Splice n

module Snap.Extras.TextUtils
readT :: Read a => Text -> a
showT :: Show a => a -> Text
readBS :: Read a => ByteString -> a
showBS :: Show a => a -> ByteString
titleCase :: Text -> Text


-- | Purpose of this module is to provide a simple, functional way to
--   define tabs in Snap applications.
module Snap.Extras.Tabs
initTabs :: HasHeist b => Snaplet (Heist b) -> Initializer b v ()
tabsSplice :: MonadSnap m => Splice m

-- | Compiled splice for tabs.
tabsCSplice :: MonadSnap m => Splice m

-- | How do we decide "active" for tab state?
data TabActiveMode

-- | Current url has to match exactly
TAMExactMatch :: TabActiveMode

-- | Only the prefix needs to match current url
TAMPrefixMatch :: TabActiveMode

-- | A sub-set of the current url has to match
TAMInfixMatch :: TabActiveMode
TAMDontMatch :: TabActiveMode

-- | A tab is a <a>Node</a> generator upon receiving a current URL context.
type Tab = Text -> Node

-- | Make tabs from tab definitions. Use the <a>tab</a> combinator to
--   define individual options.
mkTabs :: MonadSnap m => Text -> [Tab] -> Splice m

-- | Tab item constructor to be used with <a>mkTabs</a>. Just supply the
--   given arguments here and it will create a <a>Tab</a> ready to be used
--   in <a>mkTabs</a>.
--   
--   If the tab is currently active, the li tag will get a class of
--   'active'.
--   
--   Make sure to provide a trailing / when indicating URLs as snap context
--   paths contain it and active tab checks will be confused without it.
tab :: Text -> Text -> [(Text, Text)] -> TabActiveMode -> Tab

module Snap.Extras.MethodOverride

-- | Wrap a handler with method override support. This means that if (and
--   only if) the request is a POST, _method param is passed, and it is a
--   parsable method name, it will change the request method to the
--   supplied one. This works around some browser limitations with forms.
--   If you use a different parameter name than _method, use
--   handleMethodOverride'
handleMethodOverride :: MonadSnap m => m a -> m a
handleMethodOverride' :: MonadSnap m => ByteString -> m a -> m a

module Snap.Extras.FormUtils

-- | Transform to Nothing if field is empty string
maybeTrans :: (Eq a, IsString a) => a -> Result v (Maybe a)

-- | Maybe read into target value
readMayTrans :: Read a => Text -> Result v (Maybe a)

-- | Read into target value
readTrans :: (Read a, IsString v) => Text -> Result v a

-- | Constructs a generalized edit form splice that looks up an ID param
--   specified by the <tt>by</tt> attribute. You might use this splice as
--   follows:
--   
--   <pre>
--   &lt;editFormSplice by="id"&gt;
--   </pre>
--   
--   If you don't specify the <tt>by</tt> attribute, the default is
--   <tt>by="id"</tt>.
editFormSplice :: (Monad m, MonadSnap n) => (n (Maybe a) -> HeistT n m b) -> (ByteString -> n (Maybe a)) -> HeistT n m b

module Snap.Extras.FlashNotice

-- | Initialize the flash notice system. All you have to do now is to add
--   some flash tags in your application template. See <a>flashSplice</a>
--   for examples.
initFlashNotice :: HasHeist b => Snaplet (Heist b) -> SnapletLens b SessionManager -> Initializer b v ()

-- | Display an info message on next load of a page
flashInfo :: SnapletLens b SessionManager -> Text -> Handler b b ()

-- | Display an warning message on next load of a page
flashWarning :: SnapletLens b SessionManager -> Text -> Handler b b ()

-- | Display a success message on next load of a page
flashSuccess :: SnapletLens b SessionManager -> Text -> Handler b b ()

-- | Display an error message on next load of a page
flashError :: SnapletLens b SessionManager -> Text -> Handler b b ()

-- | A splice for rendering a given flash notice dirctive.
--   
--   Ex: <a>type='warning'/</a> Ex: <a>type='success'/</a>
flashSplice :: SnapletLens b SessionManager -> SnapletISplice b

-- | A compiled splice for rendering a given flash notice dirctive.
--   
--   Ex: <a>type='warning'/</a> Ex: <a>type='success'/</a>
flashCSplice :: SnapletLens b SessionManager -> SnapletCSplice b

module Snap.Extras.CoreUtils

-- | Discard anything after this and return given status code to HTTP
--   client immediately.
finishEarly :: MonadSnap m => Int -> ByteString -> m b

-- | Finish early with error code 400
badReq :: MonadSnap m => ByteString -> m b

-- | Finish early with error code 404
notFound :: MonadSnap m => ByteString -> m b

-- | Finish early with error code 500
serverError :: MonadSnap m => ByteString -> m b

-- | Mark response as 'text/plain'
plainResponse :: MonadSnap m => m ()

-- | Mark response as 'application/json'
jsonResponse :: MonadSnap m => m ()

-- | Mark response as 'application/javascript'
jsResponse :: MonadSnap m => m ()

-- | Easier debug logging into error log. First argument is a
--   category/namespace and the second argument is anything that has a
--   <a>Show</a> instance.
easyLog :: (Show t, MonadSnap m) => String -> t -> m ()

-- | Alternate version of getParam that considers empty string Nothing
getParam' :: MonadSnap m => ByteString -> m (Maybe ByteString)

-- | Require that a parameter is present or terminate early.
reqParam :: MonadSnap m => ByteString -> m ByteString

-- | Read a parameter from request. Be sure it is readable if it's there,
--   or else this will raise an error.
readParam :: (MonadSnap m, Read a) => ByteString -> m (Maybe a)

-- | Try to read a parameter from request. Computation may fail because the
--   param is not there, or because it can't be read.
readMayParam :: (MonadSnap m, Read a) => ByteString -> m (Maybe a)

-- | Redirects back to the refering page. If there is no Referer header,
--   then redirect to /.
redirectReferer :: MonadSnap m => m b

-- | Redirects back to the refering page. If there is no Referer header,
--   then redirect to /.
redirectRefererFunc :: MonadSnap m => (Maybe ByteString -> ByteString) -> m b

-- | If the current rqURI does not have a trailing slash, then redirect to
--   the same page with a slash added.
dirify :: MonadSnap m => m ()

-- | If the current rqURI has a trailing slash, then redirect to the same
--   page with no trailing slash.
undirify :: MonadSnap m => m ()
maybeBadReq :: MonadSnap m => ByteString -> m (Maybe a) -> m a

-- | Evaluates an action that returns a Maybe and
fromMaybeM :: Monad m => m a -> m (Maybe a) -> m a

-- | Concatenates two URL segments with a <a>/</a> between them. To prevent
--   double slashes, all trailing slashes are removed from the first path
--   and all leading slashes are removed from the second path.
(-/-) :: ByteString -> ByteString -> ByteString

module Snap.Extras.JSON

-- | Parse request body into JSON or return an error string.
getBoundedJSON :: (MonadSnap m, FromJSON a) => Int64 -> m (Either String a)

-- | Try to parse request body as JSON with a default max size of 50000.
getJSON :: (MonadSnap m, FromJSON a) => m (Either String a)

-- | Demand the presence of JSON in the body with a size up to N bytes. If
--   parsing fails for any reson, request is terminated early and a server
--   error is returned.
reqBoundedJSON :: (MonadSnap m, FromJSON a) => Int64 -> m a

-- | Demand the presence of JSON in the body assuming it is not larger than
--   50000 bytes.
reqJSON :: (MonadSnap m, FromJSON b) => m b

-- | Get JSON data from the given Param field
getJSONField :: (MonadSnap m, FromJSON a) => ByteString -> m (Either String a)

-- | Force the JSON value from field. Similar to <a>getJSONField</a>
reqJSONField :: (MonadSnap m, FromJSON a) => ByteString -> m a

-- | Set MIME to 'application/json' and write given object into
--   <a>Response</a> body.
writeJSON :: (MonadSnap m, ToJSON a) => a -> m ()

module Snap.Extras.CSRF

-- | A splice that makes the CSRF token available to templates. Typically
--   we use it by binding a splice and using the CSRF token provided by the
--   session snaplet as follows:
--   
--   <pre>
--   ("csrfToken", csrfTokenSplice $ with session <a>csrfToken</a>)
--   </pre>
--   
--   Where <tt>session</tt> is a lens to the session snaplet. Then you can
--   make it available to javascript code by putting a meta tag at the top
--   of every page like this:
--   
--   <pre>
--   &lt;meta name="csrf-token" content="${csrfToken}"&gt;
--   </pre>
csrfTokenSplice :: Monad m => m Text -> Splice m

-- | Adds a hidden _csrf input field as the first child of the bound tag.
--   For full site protection against CSRF, you should bind this splice to
--   the form tag, and then make sure your app checks all POST requests for
--   the presence of this CSRF token and that the token is randomly
--   generated and secure on a per session basis.
secureForm :: MonadIO m => m Text -> Splice m

-- | Use this function to wrap your whole site with CSRF protection. Due to
--   security considerations, the way Snap parses file uploads means that
--   the CSRF token cannot be checked before the file uploads have been
--   handled. This function protects your whole site except for handlers of
--   multipart/form-data forms (forms with file uploads). To protect those
--   handlers, you have to call handleCSRF explicitly after the file has
--   been processed.
blanketCSRF :: SnapletLens v SessionManager -> Handler b v () -> Handler b v () -> Handler b v ()

-- | If a request is a POST, check the CSRF token and fail with the
--   specified handler if the check fails. If if the token is correct or if
--   it's not a POST request, then control passes through as a no-op.
handleCSRF :: SnapletLens v SessionManager -> Handler b v () -> Handler b v () -> Handler b v ()

-- | A version of <a>handleCSRF</a> that works as an imperative filter.
--   It's a NOOP when successful, redirs to oblivion under failure.
handleCSRF' :: SnapletLens v SessionManager -> Handler b v () -> Handler b v ()


-- | Simple combinators to work with AJAX requests.
module Snap.Extras.Ajax

-- | Replace innerHTML of given selector with given conntent.
replaceWith :: MonadSnap m => Text -> ByteString -> m ()

-- | Replace the inner HTML element of a given selector with the contents
--   of the rendered Heist template.
--   
--   Currently expect you to have jQuery loaded. TODO: Make this jQuery
--   independent
replaceWithTemplate :: HasHeist b => ByteString -> Text -> Handler b v ()

-- | Possible reponse types we support at the moment. Can be expanded for
--   more use cases like JSON, CSV and XML.
data ResponseType
Html :: ResponseType
Ajax :: ResponseType

-- | The multi-mime dispatcher. It will inspect the <tt>Accept</tt> header
--   and determine what type of a request this is. If AJAX, make sure to
--   set the Accept header to 'application/javascript'.
respond :: MonadSnap m => (ResponseType -> m b) -> m b

-- | Dispatch on all response types
responds :: MonadSnap m => [(ResponseType, m b)] -> m b

-- | Classic pattern of responding to a static HTML or an alternative AJAX
--   request.
htmlOrAjax :: MonadSnap m => m b -> m b -> m b
instance Eq ResponseType
instance Show ResponseType
instance Read ResponseType
instance Ord ResponseType


-- | This module provides infrastructure for polling the status of
--   processes that run longer than a single request-response lifecycle. To
--   do this, we issue AJAX calls at regular intervals to a route that
--   updates the status on the page. There are two main components
--   necessary to use this library: splices and a handler.
--   
--   The handler is a simple <a>jobStatusHandler</a> function. Typically
--   you'll add it to your site's list of routes like this:
--   
--   <pre>
--   route [ ...
--         , ("myJobStatus", jobStatusHandler "statusTemplate" ".statusDiv")
--         , ...
--         ]
--   </pre>
--   
--   The first argument to jobsHandler is the template that will be
--   rendered for status update requests. It will typically be not much
--   more than a <tt>&lt;myJobStatus&gt;</tt> tag enclosing the custom
--   markup for displaying your job status. Here's an example using a
--   bootstrap progress bar:
--   
--   <pre>
--   &lt;myJobStatus interval="300"&gt;
--     &lt;ifRunning&gt;
--       &lt;elapsedSeconds/&gt; seconds elapsed
--   
--       &lt;div class="progress"&gt;
--         &lt;div class="progress-bar progress-bar-striped active"  role="progressbar"
--              aria-valuenow="${amountCompleted}" aria-valuemin="0"
--              aria-valuemax="${amountTotal}" style="width: ${percentCompleted}%"&gt;
--           &lt;percentCompleted/&gt;%
--         &lt;/div&gt;
--       &lt;/div&gt;
--   
--     &lt;/ifRunning&gt;
--     &lt;ifFinished&gt;
--       &lt;div class="progress"&gt;
--         &lt;div class="progress-bar progress-bar-striped"  role="progressbar"
--              aria-valuenow="${amountCompleted}" aria-valuemin="0"
--              aria-valuemax="${amountTotal}" style="width: ${percentCompleted}%"&gt;
--           &lt;percentCompleted/&gt;%
--         &lt;/div&gt;
--       &lt;/div&gt;
--     &lt;/ifFinished&gt;
--   &lt;/myJobStatus&gt;
--   </pre>
--   
--   This will poll for updates every 300 milliseconds. See the
--   documentation for <a>statusSplice</a> for more details.
--   
--   To get the above code working, you would have the myJobStatusPage
--   handler return markup that contains something like this:
--   
--   <pre>
--   &lt;h1&gt;Status&lt;/h1&gt;
--   &lt;div class="statusdiv col-md-4"&gt;
--     &lt;apply template="statusTemplate"/&gt;
--   &lt;/div&gt;
--   </pre>
--   
--   You will also need to bind the main splice provided by this module.
--   
--   <pre>
--   splices = do
--       ...
--       "myJobStatus" ## statusSplice splices getUrl getMyJobStatus isFinished
--   </pre>
--   
--   You need to bind this splice once for each type of action that you are
--   polling, each with its own splice name and function for getting the
--   job status.
module Snap.Extras.PollStatus

-- | Top-level handler that handles the job polling infrastructure.
jobStatusHandler :: HasHeist b => ByteString -> Text -> Handler b v ()

-- | Function to generate a status splice. This splice makes the following
--   splices available to its children:
--   
--   Conditional splices: ifPending, ifRunning, ifNotFinished, ifFinished,
--   ifFinishedSuccess, ifFinishedFailure
--   
--   Data splices: elapsedSeconds, startTime, endTime, jobState, messages,
--   percentCompleted, amountCompleted, amountTotal
statusSplice :: Monad n => Splices (RuntimeSplice n status -> Splice n) -> n (Maybe Text) -> n (Maybe status) -> (status -> Bool) -> Splice n

-- | Enumeration of the states a job can be in.
data JobState
Pending :: JobState
Running :: JobState
FinishedSuccess :: JobState
FinishedFailure :: JobState

-- | Returns a bool indicating whether the job is finished.
jobFinished :: JobState -> Bool

-- | Returns a bool indicating whether the job is finished.
statusFinished :: Status -> Bool

-- | The complete status of a job.
data Status
Status :: Maybe UTCTime -> UTCTime -> JobState -> [Text] -> Double -> Double -> Status
statusStartTime :: Status -> Maybe UTCTime
statusTimestamp :: Status -> UTCTime
statusJobState :: Status -> JobState
statusMessages :: Status -> [Text]
statusAmountCompleted :: Status -> Double
statusAmountTotal :: Status -> Double

-- | Calculates the percent completed as an Int.
statusPercentCompleted :: Status -> Int
statusElapsed :: Status -> Maybe Int

-- | The status splices
statusSplices :: Monad n => Splices (RuntimeSplice n Status -> Splice n)
instance Eq JobState
instance Show JobState
instance Read JobState
instance Enum JobState
instance Eq Status
instance Show Status

module Snap.Extras

-- | Initialize all the <a>Extras</a> functionality in your Snap app.
--   Currently, we don't need to keep any state and simply return ().
initExtras :: HasHeist b => Snaplet (Heist b) -> SnapletLens b SessionManager -> SnapletInit b ()
