-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fixed-size wrapper for StorableArray, providing a
Storable instance. Deprecated - use storable-static-array
instead.
--   
--   Uses type-level numeric literals to wrap <tt>StorableArray</tt> in a
--   type that statically fixes its size. The wrapper has a
--   <tt>Storable</tt> instance, for easy integration with fixed-size
--   native arrays.
--   
--   Deprecated - use storable-static-array instead.
@package fixed-storable-array
@version 0.3.1.1


-- | Deprecated - use storable-static-array instead.
--   
--   This module defines <a>FixedStorableArray</a>, a simple wrapper around
--   <a>StorableArray</a> with its dimensions encoded in the type.
--   <a>FixedStorableArray</a> provides a <a>Storable</a> instance that
--   uses the type-level dimensions, and significantly eases writing FFI
--   bindings to fixed-size native arrays. For example,
--   <tt><a>FixedStorableArray</a> 10 CInt</tt> has a <a>Storable</a>
--   instance that is directly compatible with <tt>int foo[10]</tt> in
--   native code.
--   
--   Multidimensional native arrays are also supported.
--   <tt><a>FixedStorableArray</a> '(10,20,100) CUChar</tt> is compatible
--   with <tt>unsigned char foo[10][20][100]</tt>. Note the leading
--   <tt>'</tt> before the tuple containing the dimensions. It marks it as
--   a <tt>DataKinds</tt> lifted tuple, necessary to store the dimensions.
--   
--   To operate on the contents of a <a>FixedStorableArray</a>, use
--   <a>toStorableArray</a>. <a>toStorableArray</a> returns a
--   <a>StorableArray</a> with the correct type and index values already in
--   place. For example, the result of <a>toStorableArray</a> on a
--   <tt><a>FixedStorableArray</a> '(10,20,100) CUChar</tt> is a
--   <tt><a>StorableArray</a> (Int, Int, Int) CUChar</tt> with its bounds
--   set to <tt>((0,0,0),(9,19,99))</tt>.
module Foreign.Marshal.FixedStorableArray

-- | A minimal wrapper for <a>StorableArray</a> that encodes the full
--   dimensions of the array in the type. Intended for interfacing with
--   (possibly-)multidimensional arrays of fixed size in native code.
data FixedStorableArray dimensions e

-- | Create a <a>FixedStorableArray</a> and populate it with copies of the
--   element passed in. Dimensions will be determined from the return type.
newFixedStorableArray :: (HasBounds d, Ix (Bound d), Storable e) => e -> IO (FixedStorableArray d e)

-- | Create a <a>FixedStorableArray</a> and don't populate it with anything
--   in particular. Contents may or may not be initialized to anything at
--   all. Dimensions will be determined from the return type.
newFixedStorableArray_ :: (HasBounds d, Ix (Bound d), Storable e) => IO (FixedStorableArray d e)

-- | Returns the backing <a>StorableArray</a> of this
--   <a>FixedStorableArray</a>. The backing array is shared such that
--   modifications to it will be seen across all uses of this
--   <a>FixedStorableArray</a>.
toStorableArray :: FixedStorableArray dimensions e -> StorableArray (Bound dimensions) e

-- | This class connects dimension description types with
--   <a>StorableArray</a> index types and values. Instances are provided
--   for up to 13 dimensions. More can be added if there's any need.
class HasBounds d where type family Bound d :: *
bounds :: HasBounds d => FixedStorableArray d e -> (Bound d, Bound d)

-- | A conversion function for converting type-level naturals to
--   value-level. This is being exposed to aid in the creation of
--   additional <a>HasBounds</a> instances for those who might desire to do
--   so.
--   
--   Haddock is currently eating the important qualification that the type
--   variable <tt>n</tt> must have the kind <a>Nat</a>. The <a>SingI</a>
--   instance is automatically fulfilled for all types of kind <a>Nat</a>.
--   Its explicit presence in the signature is an artifact of how GHC
--   implements dictionary passing and type erasure.
fromNat :: SingI n => proxy n -> Int
instance (SingI Nat n, HasBounds [Nat] ((':) Nat n2 ns)) => HasBounds [Nat] ((':) Nat n ((':) Nat n2 ns))
instance SingI Nat n => HasBounds [Nat] ((':) Nat n ('[] Nat))
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h, SingI Nat i, SingI Nat j, SingI Nat k, SingI Nat l, SingI Nat m) => HasBounds ((,,,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h i j k l m)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h, SingI Nat i, SingI Nat j, SingI Nat k, SingI Nat l) => HasBounds ((,,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h i j k l)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h, SingI Nat i, SingI Nat j, SingI Nat k) => HasBounds ((,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h i j k)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h, SingI Nat i, SingI Nat j) => HasBounds ((,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h i j)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h, SingI Nat i) => HasBounds ((,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h i)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g, SingI Nat h) => HasBounds ((,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,,) Nat Nat Nat Nat Nat Nat Nat Nat a b c d e f g h)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f, SingI Nat g) => HasBounds ((,,,,,,) Nat Nat Nat Nat Nat Nat Nat) ('(,,,,,,) Nat Nat Nat Nat Nat Nat Nat a b c d e f g)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e, SingI Nat f) => HasBounds ((,,,,,) Nat Nat Nat Nat Nat Nat) ('(,,,,,) Nat Nat Nat Nat Nat Nat a b c d e f)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d, SingI Nat e) => HasBounds ((,,,,) Nat Nat Nat Nat Nat) ('(,,,,) Nat Nat Nat Nat Nat a b c d e)
instance (SingI Nat a, SingI Nat b, SingI Nat c, SingI Nat d) => HasBounds ((,,,) Nat Nat Nat Nat) ('(,,,) Nat Nat Nat Nat a b c d)
instance (SingI Nat a, SingI Nat b, SingI Nat c) => HasBounds ((,,) Nat Nat Nat) ('(,,) Nat Nat Nat a b c)
instance (SingI Nat a, SingI Nat b) => HasBounds ((,) Nat Nat) ('(,) Nat Nat a b)
instance SingI Nat a => HasBounds Nat a
instance (HasBounds k d, Ix (Bound k d), Storable e) => Storable (FixedStorableArray k d e)
