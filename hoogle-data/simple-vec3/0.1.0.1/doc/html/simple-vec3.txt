-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Three-dimensional vectors of doubles with basic operations
--   
--   A class of 3-vectors with a set of basic methods for geometry
--   operations on vectors and an associated matrix type. Several instances
--   are provided for use with <a>Data.Vector.Unboxed</a> and
--   <a>Data.Vector.Storable</a> as container types.
@package simple-vec3
@version 0.1.0.1

module Data.Vec3.Class

-- | Three-dimensional vector, with an associated matrix type.
class Vec3 v where data family Matrix v origin = fromXYZ (0, 0, 0) zipWith f v1 v2 = fromXYZ (f x1 x2, f y1 y2, f z1 z2) where (x1, y1, z1) = toXYZ v1 (x2, y2, z2) = toXYZ v2 <+> v1 v2 = zipWith (+) v1 v2 <-> v1 v2 = zipWith (-) v1 v2 >< v1 v2 = fromXYZ (y1 * z2 - y2 * z1, x2 * z1 - x1 * z2, x1 * y2 - x2 * y1) where (x1, y1, z1) = toXYZ v1 (x2, y2, z2) = toXYZ v2 .^ v s = fromXYZ (x * s, y * s, z * s) where (x, y, z) = toXYZ v .* v1 v2 = x + y + z where (x, y, z) = toXYZ $ zipWith (*) v1 v2 norm v = sqrt (v .* v) normalize v = v .^ (1 / norm v) distance v1 v2 = norm (v1 <-> v2) invert v = origin <-> v dotM v1 v2 m = v1 .* (m `mxv` v2) mxv m v = fromXYZ (r1 .* v, r2 .* v, r3 .* v) where (r1, r2, r3) = toRows m diag d = fromRows (fromXYZ (d, 0, 0), fromXYZ (0, d, 0), fromXYZ (0, 0, d)) vxv v1 v2 = fromRows (v2 .^ v11, v2 .^ v12, v2 .^ v13) where (v11, v12, v13) = toXYZ v1 addM m1 m2 = fromRows (r11 <+> r21, r12 <+> r22, r13 <+> r23) where (r11, r12, r13) = toRows m1 (r21, r22, r23) = toRows m2
origin :: Vec3 v => v
fromXYZ :: Vec3 v => (Double, Double, Double) -> v
toXYZ :: Vec3 v => v -> (Double, Double, Double)
zipWith :: Vec3 v => (Double -> Double -> Double) -> v -> v -> v
(<+>) :: Vec3 v => v -> v -> v
(<->) :: Vec3 v => v -> v -> v
(><) :: Vec3 v => v -> v -> v
(.^) :: Vec3 v => v -> Double -> v
(.*) :: Vec3 v => v -> v -> Double
norm :: Vec3 v => v -> Double
normalize :: Vec3 v => v -> v
distance :: Vec3 v => v -> v -> Double
invert :: Vec3 v => v -> v
fromRows :: Vec3 v => (v, v, v) -> Matrix v
toRows :: Vec3 v => Matrix v -> (v, v, v)
dotM :: Vec3 v => v -> v -> Matrix v -> Double
mxv :: Vec3 v => Matrix v -> v -> v
diag :: Vec3 v => Double -> Matrix v
vxv :: Vec3 v => v -> v -> Matrix v
addM :: Vec3 v => Matrix v -> Matrix v -> Matrix v

module Data.Vec3.Storable

-- | <a>Vec3</a> implementation with <a>Storable</a> instance, suitable for
--   use with <a>Data.Vector.Storable</a>.
data SVec3
SVec3 :: !CDouble -> !CDouble -> !CDouble -> SVec3
instance Eq SVec3
instance Show SVec3
instance Vec3 SVec3
instance Storable SVec3

module Data.Vec3.TUnboxed

-- | <a>Vec3</a> implementation with <a>Unbox</a> instance based on tuples,
--   suitable for use with <a>Data.Vector.Unboxed</a>.
--   
--   This represents 3-vector as a triple of doubles, using the default
--   Unbox instance for tuples as provided by <a>Data.Vector.Unboxed</a>,
--   which wraps a vector of tuples as a tuple of vectors.
--   
--   <pre>
--   interface:  [d1 (x, y, z); d2 (x, y, z) ...], length = N
--                    |  |  |       |  |  |
--   storage(x): [d1x-+  |  | ; d2x-+  |  |  ...], length = N
--   storage(y): [d1y----+  | ; d2y----+  |  ...], length = N
--   storage(z): [d1z-------+ ; d2z-------+  ...], length = N
--   </pre>
newtype TUVec3
TUVec3 :: (Double, Double, Double) -> TUVec3
instance Eq TUVec3
instance Show TUVec3
instance Vector Vector TUVec3
instance MVector MVector TUVec3
instance Unbox TUVec3
instance Eq (Matrix TUVec3)
instance Show (Matrix TUVec3)
instance Vector Vector (Matrix TUVec3)
instance MVector MVector (Matrix TUVec3)
instance Unbox (Matrix TUVec3)
instance Vec3 TUVec3

module Data.Vec3.Unboxed

-- | <a>Vec3</a> implementation with <a>Unbox</a> instance based on a
--   single contiguous array storage scheme, suitable for use with
--   <a>Data.Vector.Unboxed</a>.
--   
--   <a>Unbox</a> instance provides the required index transformations.
--   
--   <pre>
--   interface: [d1 x   y   z  ; d2 x   y   z  ...], length = N = M / 3
--                  |   |   |       |   |   |
--   storage:   [  d1x d2y d2z ;   d2x d2y d2z ...], length = M
--   </pre>
--   
--   Thanks to dense packing scheme the performance of this implementation
--   should generally be on par with <tt>Storable</tt>-based <a>SVec3</a>.
data UVec3
UVec3 :: !Double -> !Double -> !Double -> UVec3
instance Eq UVec3
instance Show UVec3
instance Unbox UVec3
instance Vector Vector UVec3
instance MVector MVector UVec3
instance Vec3 UVec3

module Data.Vec3

-- | Three-dimensional vector, with an associated matrix type.
class Vec3 v where data family Matrix v origin = fromXYZ (0, 0, 0) zipWith f v1 v2 = fromXYZ (f x1 x2, f y1 y2, f z1 z2) where (x1, y1, z1) = toXYZ v1 (x2, y2, z2) = toXYZ v2 <+> v1 v2 = zipWith (+) v1 v2 <-> v1 v2 = zipWith (-) v1 v2 >< v1 v2 = fromXYZ (y1 * z2 - y2 * z1, x2 * z1 - x1 * z2, x1 * y2 - x2 * y1) where (x1, y1, z1) = toXYZ v1 (x2, y2, z2) = toXYZ v2 .^ v s = fromXYZ (x * s, y * s, z * s) where (x, y, z) = toXYZ v .* v1 v2 = x + y + z where (x, y, z) = toXYZ $ zipWith (*) v1 v2 norm v = sqrt (v .* v) normalize v = v .^ (1 / norm v) distance v1 v2 = norm (v1 <-> v2) invert v = origin <-> v dotM v1 v2 m = v1 .* (m `mxv` v2) mxv m v = fromXYZ (r1 .* v, r2 .* v, r3 .* v) where (r1, r2, r3) = toRows m diag d = fromRows (fromXYZ (d, 0, 0), fromXYZ (0, d, 0), fromXYZ (0, 0, d)) vxv v1 v2 = fromRows (v2 .^ v11, v2 .^ v12, v2 .^ v13) where (v11, v12, v13) = toXYZ v1 addM m1 m2 = fromRows (r11 <+> r21, r12 <+> r22, r13 <+> r23) where (r11, r12, r13) = toRows m1 (r21, r22, r23) = toRows m2
origin :: Vec3 v => v
fromXYZ :: Vec3 v => (Double, Double, Double) -> v
toXYZ :: Vec3 v => v -> (Double, Double, Double)
zipWith :: Vec3 v => (Double -> Double -> Double) -> v -> v -> v
(<+>) :: Vec3 v => v -> v -> v
(<->) :: Vec3 v => v -> v -> v
(><) :: Vec3 v => v -> v -> v
(.^) :: Vec3 v => v -> Double -> v
(.*) :: Vec3 v => v -> v -> Double
norm :: Vec3 v => v -> Double
normalize :: Vec3 v => v -> v
distance :: Vec3 v => v -> v -> Double
invert :: Vec3 v => v -> v
fromRows :: Vec3 v => (v, v, v) -> Matrix v
toRows :: Vec3 v => Matrix v -> (v, v, v)
dotM :: Vec3 v => v -> v -> Matrix v -> Double
mxv :: Vec3 v => Matrix v -> v -> v
diag :: Vec3 v => Double -> Matrix v
vxv :: Vec3 v => v -> v -> Matrix v
addM :: Vec3 v => Matrix v -> Matrix v -> Matrix v

-- | <a>Vec3</a> implementation with <a>Unbox</a> instance based on a
--   single contiguous array storage scheme, suitable for use with
--   <a>Data.Vector.Unboxed</a>.
--   
--   <a>Unbox</a> instance provides the required index transformations.
--   
--   <pre>
--   interface: [d1 x   y   z  ; d2 x   y   z  ...], length = N = M / 3
--                  |   |   |       |   |   |
--   storage:   [  d1x d2y d2z ;   d2x d2y d2z ...], length = M
--   </pre>
--   
--   Thanks to dense packing scheme the performance of this implementation
--   should generally be on par with <tt>Storable</tt>-based <a>SVec3</a>.
data UVec3
UVec3 :: !Double -> !Double -> !Double -> UVec3

-- | <a>Vec3</a> implementation with <a>Storable</a> instance, suitable for
--   use with <a>Data.Vector.Storable</a>.
data SVec3
SVec3 :: !CDouble -> !CDouble -> !CDouble -> SVec3

-- | <a>Vec3</a> implementation with <a>Unbox</a> instance based on tuples,
--   suitable for use with <a>Data.Vector.Unboxed</a>.
--   
--   This represents 3-vector as a triple of doubles, using the default
--   Unbox instance for tuples as provided by <a>Data.Vector.Unboxed</a>,
--   which wraps a vector of tuples as a tuple of vectors.
--   
--   <pre>
--   interface:  [d1 (x, y, z); d2 (x, y, z) ...], length = N
--                    |  |  |       |  |  |
--   storage(x): [d1x-+  |  | ; d2x-+  |  |  ...], length = N
--   storage(y): [d1y----+  | ; d2y----+  |  ...], length = N
--   storage(z): [d1z-------+ ; d2z-------+  ...], length = N
--   </pre>
newtype TUVec3
TUVec3 :: (Double, Double, Double) -> TUVec3
