-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Random number generation
--   
--   Random number generation based on modeling random variables in two
--   complementary ways: first, by the parameters of standard mathematical
--   distributions and, second, by an abstract type (<a>RVar</a>) which can
--   be composed and manipulated monadically and sampled in either monadic
--   or "pure" styles.
--   
--   The primary purpose of this library is to support defining and
--   sampling a wide variety of high quality random variables. Quality is
--   prioritized over speed, but performance is an important goal too.
--   
--   In my testing, I have found it capable of speed comparable to other
--   Haskell libraries, but still a fair bit slower than straight C
--   implementations of the same algorithms.
@package random-fu
@version 0.2.6.2

module Data.Random.Internal.Find
findMax :: (Fractional a, Ord a) => (a -> Bool) -> a

-- | Given an upward-closed predicate on an ordered Fractional type, find
--   the smallest value satisfying the predicate.
findMin :: (Fractional a, Ord a) => (a -> Bool) -> a

-- | Given an upward-closed predicate on an ordered Fractional type, find
--   the smallest value satisfying the predicate. Starts at the specified
--   point with the specified stepsize, performs an exponential search out
--   from there until it finds an interval bracketing the change-point of
--   the predicate, and then performs a bisection search to isolate the
--   change point. Note that infinitely-divisible domains such as
--   <a>Rational</a> cannot be searched by this function because it does
--   not terminate until it reaches a point where further subdivision of
--   the interval has no effect.
findMinFrom :: (Fractional a, Ord a) => a -> a -> (a -> Bool) -> a

module Data.Random.Internal.Fixed
resolutionOf :: HasResolution r => f r -> Integer
resolutionOf2 :: HasResolution r => f (g r) -> Integer

-- | The <a>Fixed</a> type doesn't expose its constructors, but I need a
--   way to convert them to and from their raw representation in order to
--   sample them. As long as <a>Fixed</a> is a newtype wrapping
--   <a>Integer</a>, <a>mkFixed</a> and <a>unMkFixed</a> as defined here
--   will work. Both are implemented using <a>unsafeCoerce</a>.
mkFixed :: Integer -> Fixed r
unMkFixed :: Fixed r -> Integer


-- | Template Haskell utility code to replicate instance declarations to
--   cover large numbers of types. I'm doing that rather than using class
--   contexts because most Distribution instances need to cover multiple
--   classes (such as Enum, Integral and Fractional) and that can't be done
--   easily because of overlap.
--   
--   I experimented a bit with a convoluted type-level classification
--   scheme, but I think this is simpler and easier to understand. It makes
--   the haddock docs more cluttered because of the combinatorial explosion
--   of instances, but overall I think it's just more sane than anything
--   else I've come up with yet.
module Data.Random.Internal.TH

-- | <tt>replicateInstances standin types decls</tt> will take the
--   template-haskell <a>Dec</a>s in <tt>decls</tt> and substitute every
--   instance of the <a>Name</a> <tt>standin</tt> with each <a>Name</a> in
--   <tt>types</tt>, producing one copy of the <a>Dec</a>s in
--   <tt>decls</tt> for every <a>Name</a> in <tt>types</tt>.
--   
--   For example, <a>Uniform</a> has the following bit of TH code:
--   
--   <pre>
--   $( replicateInstances ''Int integralTypes [d|
--   </pre>
--   
--   <pre>
--   instance Distribution Uniform Int   where rvar (Uniform a b) = integralUniform a b
--   </pre>
--   
--   <pre>
--   instance CDF Uniform Int            where cdf  (Uniform a b) = integralUniformCDF a b
--   </pre>
--   
--   <pre>
--   |])
--   </pre>
--   
--   This code takes those 2 instance declarations and creates identical
--   ones for every type named in <a>integralTypes</a>.
replicateInstances :: (Monad m, Data t) => Name -> [Name] -> m [t] -> m [t]

-- | Names of standard <a>Integral</a> types
integralTypes :: [Name]

-- | Names of standard <a>RealFloat</a> types
realFloatTypes :: [Name]

module Data.Random.Lift

-- | A class for "liftable" data structures. Conceptually an extension of
--   <a>MonadTrans</a> to allow deep lifting, but lifting need not be done
--   between monads only. Eg lifting between <tt>Applicative</tt>s is
--   allowed.
--   
--   For instances where <tt>m</tt> and <tt>n</tt> have 'return'/'pure'
--   defined, these instances must satisfy <tt>lift (return x) == return
--   x</tt>.
--   
--   This form of <a>lift</a> has an extremely general type and is used
--   primarily to support <tt>sample</tt>. Its excessive generality is the
--   main reason it's not exported from <a>Data.Random</a>. <a>RVarT</a>
--   is, however, an instance of <a>MonadTrans</a>, which in most cases is
--   the preferred way to do the lifting.
class Lift m n
lift :: Lift m n => m a -> n a

-- | This instance is incoherent with the others. However, by the law
--   <tt>lift (return x) == return x</tt>, the results must always be the
--   same.

-- | This instance is again incoherent with the others, but provides a
--   more-specific instance to resolve the overlap between the <tt>Lift m
--   (t m)</tt> and <tt>Lift Identity m</tt> instances.
instance [incoherent] MonadTrans t => Lift Identity (t Identity)
instance [incoherent] Lift (RVarT Identity) (RVarT m)
instance [incoherent] Monad m => Lift Identity m
instance [incoherent] Lift m m
instance [incoherent] (Monad m, MonadTrans t) => Lift m (t m)

module Data.Random.RVar

-- | An opaque type modeling a "random variable" - a value which depends on
--   the outcome of some random event. <a>RVar</a>s can be conveniently
--   defined by an imperative-looking style:
--   
--   <pre>
--   normalPair =  do
--       u &lt;- stdUniform
--       t &lt;- stdUniform
--       let r = sqrt (-2 * log u)
--           theta = (2 * pi) * t
--           
--           x = r * cos theta
--           y = r * sin theta
--       return (x,y)
--   </pre>
--   
--   OR by a more applicative style:
--   
--   <pre>
--   logNormal = exp &lt;$&gt; stdNormal
--   </pre>
--   
--   Once defined (in any style), there are several ways to sample
--   <a>RVar</a>s:
--   
--   <ul>
--   <li>In a monad, using a <a>RandomSource</a>:</li>
--   </ul>
--   
--   <pre>
--   runRVar (uniform 1 100) DevRandom :: IO Int
--   </pre>
--   
--   <ul>
--   <li>In a monad, using a <a>MonadRandom</a> instance:</li>
--   </ul>
--   
--   <pre>
--   sampleRVar (uniform 1 100) :: State PureMT Int
--   </pre>
--   
--   <ul>
--   <li>As a pure function transforming a functional RNG:</li>
--   </ul>
--   
--   <pre>
--   sampleState (uniform 1 100) :: StdGen -&gt; (Int, StdGen)
--   </pre>
--   
--   (where <tt>sampleState = runState . sampleRVar</tt>)
type RVar = RVarT Identity

-- | "Run" an <a>RVar</a> - samples the random variable from the provided
--   source of entropy.
runRVar :: RandomSource m s => RVar a -> s -> m a

-- | A random variable with access to operations in an underlying monad.
--   Useful examples include any form of state for implementing random
--   processes with hysteresis, or writer monads for implementing tracing
--   of complicated algorithms.
--   
--   For example, a simple random walk can be implemented as an
--   <a>RVarT</a> <a>IO</a> value:
--   
--   <pre>
--   rwalkIO :: IO (RVarT IO Double)
--   rwalkIO d = do
--       lastVal &lt;- newIORef 0
--       
--       let x = do
--               prev    &lt;- lift (readIORef lastVal)
--               change  &lt;- rvarT StdNormal
--               
--               let new = prev + change
--               lift (writeIORef lastVal new)
--               return new
--           
--       return x
--   </pre>
--   
--   To run the random walk it must first be initialized, after which it
--   can be sampled as usual:
--   
--   <pre>
--   do
--       rw &lt;- rwalkIO
--       x &lt;- sampleRVarT rw
--       y &lt;- sampleRVarT rw
--       ...
--   </pre>
--   
--   The same random-walk process as above can be implemented using MTL
--   types as follows (using <tt>import Control.Monad.Trans as MTL</tt>):
--   
--   <pre>
--   rwalkState :: RVarT (State Double) Double
--   rwalkState = do
--       prev &lt;- MTL.lift get
--       change  &lt;- rvarT StdNormal
--       
--       let new = prev + change
--       MTL.lift (put new)
--       return new
--   </pre>
--   
--   Invocation is straightforward (although a bit noisy) if you're used to
--   MTL:
--   
--   <pre>
--   rwalk :: Int -&gt; Double -&gt; StdGen -&gt; ([Double], StdGen)
--   rwalk count start gen = 
--       flip evalState start .
--           flip runStateT gen .
--               sampleRVarTWith MTL.lift $
--                   replicateM count rwalkState
--   </pre>
data RVarT (m :: * -> *) a :: (* -> *) -> * -> *

-- | Like <a>runRVarTWith</a>, but using an implicit lifting (provided by
--   the <a>Lift</a> class)
runRVarT :: (Lift n m, RandomSource m s) => RVarT n a -> s -> m a

-- | "Runs" an <a>RVarT</a>, sampling the random variable it defines.
--   
--   The first argument lifts the base monad into the sampling monad. This
--   operation must obey the "monad transformer" laws:
--   
--   <pre>
--   lift . return = return
--   lift (x &gt;&gt;= f) = (lift x) &gt;&gt;= (lift . f)
--   </pre>
--   
--   One example of a useful non-standard lifting would be one that takes
--   <tt>State s</tt> to another monad with a different state
--   representation (such as <tt>IO</tt> with the state mapped to an
--   <tt>IORef</tt>):
--   
--   <pre>
--   embedState :: (Monad m) =&gt; m s -&gt; (s -&gt; m ()) -&gt; State s a -&gt; m a
--   embedState get put = \m -&gt; do
--       s &lt;- get
--       (res,s) &lt;- return (runState m s)
--       put s
--       return res
--   </pre>
--   
--   The ability to lift is very important - without it, every <a>RVar</a>
--   would have to either be given access to the full capability of the
--   monad in which it will eventually be sampled (which, incidentally,
--   would also have to be monomorphic so you couldn't sample one
--   <a>RVar</a> in more than one monad) or functions manipulating
--   <a>RVar</a>s would have to use higher-ranked types to enforce the same
--   kind of isolation and polymorphism.
runRVarTWith :: RandomSource m s => (forall t. n t -> m t) -> RVarT n a -> s -> m a

module Data.Random.Distribution

-- | A <a>Distribution</a> is a data representation of a random variable's
--   probability structure. For example, in
--   <a>Data.Random.Distribution.Normal</a>, the <tt>Normal</tt>
--   distribution is defined as:
--   
--   <pre>
--   data Normal a
--       = StdNormal
--       | Normal a a
--   </pre>
--   
--   Where the two parameters of the <tt>Normal</tt> data constructor are
--   the mean and standard deviation of the random variable, respectively.
--   To make use of the <tt>Normal</tt> type, one can convert it to an
--   <a>rvar</a> and manipulate it or sample it directly:
--   
--   <pre>
--   x &lt;- sample (rvar (Normal 10 2))
--   x &lt;- sample (Normal 10 2)
--   </pre>
--   
--   A <a>Distribution</a> is typically more transparent than an
--   <a>RVar</a> but less composable (precisely because of that
--   transparency). There are several practical uses for types implementing
--   <a>Distribution</a>:
--   
--   <ul>
--   <li>Typically, a <a>Distribution</a> will expose several parameters of
--   a standard mathematical model of a probability distribution, such as
--   mean and std deviation for the normal distribution. Thus, they can be
--   manipulated analytically using mathematical insights about the
--   distributions they represent. For example, a collection of bernoulli
--   variables could be simplified into a (hopefully) smaller collection of
--   binomial variables.</li>
--   <li>Because they are generally just containers for parameters, they
--   can be easily serialized to persistent storage or read from
--   user-supplied configurations (eg, initialization data for a
--   simulation).</li>
--   <li>If a type additionally implements the <a>CDF</a> subclass, which
--   extends <a>Distribution</a> with a cumulative density function, an
--   arbitrary random variable <tt>x</tt> can be tested against the
--   distribution by testing <tt>fmap (cdf dist) x</tt> for
--   uniformity.</li>
--   </ul>
--   
--   On the other hand, most <a>Distribution</a>s will not be closed under
--   all the same operations as <a>RVar</a> (which, being a monad, has a
--   fully turing-complete internal computational model). The sum of two
--   uniformly-distributed variables, for example, is not uniformly
--   distributed. To support general composition, the <a>Distribution</a>
--   class defines a function <a>rvar</a> to construct the more-abstract
--   and more-composable <a>RVar</a> representation of a random variable.
class Distribution d t where rvar = rvarT rvarT d = lift (rvar d)
rvar :: Distribution d t => d t -> RVar t
rvarT :: Distribution d t => d t -> RVarT n t
class Distribution d t => PDF d t where pdf d = exp . logPdf d logPdf d = log . pdf d
pdf :: PDF d t => d t -> t -> Double
logPdf :: PDF d t => d t -> t -> Double
class Distribution d t => CDF d t
cdf :: CDF d t => d t -> t -> Double

module Data.Random.Distribution.Uniform

-- | A definition of a uniform distribution over the type <tt>t</tt>. See
--   also <a>uniform</a>.
data Uniform t

-- | A uniform distribution defined by a lower and upper range bound. For
--   <a>Integral</a> and <a>Enum</a> types, the range is inclusive. For
--   <a>Fractional</a> types the range includes the lower bound but not the
--   upper.
Uniform :: !t -> !t -> Uniform t
uniform :: Distribution Uniform a => a -> a -> RVar a
uniformT :: Distribution Uniform a => a -> a -> RVarT m a

-- | A name for the "standard" uniform distribution over the type
--   <tt>t</tt>, if one exists. See also <a>stdUniform</a>.
--   
--   For <a>Integral</a> and <a>Enum</a> types that are also
--   <a>Bounded</a>, this is the uniform distribution over the full range
--   of the type. For un-<a>Bounded</a> <a>Integral</a> types this is not
--   defined. For <a>Fractional</a> types this is a random variable in the
--   range [0,1) (that is, 0 to 1 including 0 but not including 1).
data StdUniform t
StdUniform :: StdUniform t

-- | Get a "standard" uniformly distributed variable. For integral types,
--   this means uniformly distributed over the full range of the type
--   (there is no support for <a>Integer</a>). For fractional types, this
--   means uniformly distributed on the interval [0,1).
stdUniform :: Distribution StdUniform a => RVar a

-- | Get a "standard" uniformly distributed process. For integral types,
--   this means uniformly distributed over the full range of the type
--   (there is no support for <a>Integer</a>). For fractional types, this
--   means uniformly distributed on the interval [0,1).
stdUniformT :: Distribution StdUniform a => RVarT m a

-- | Like <a>stdUniform</a> but only returns positive values.
stdUniformPos :: (Distribution StdUniform a, Num a, Eq a) => RVar a

-- | Like <a>stdUniform</a> but only returns positive values.
stdUniformPosT :: (Distribution StdUniform a, Num a, Eq a) => RVarT m a

-- | Compute a random <a>Integral</a> value between the 2 values provided
--   (inclusive).
integralUniform :: Integral a => a -> a -> RVarT m a

-- | <tt>realFloatUniform a b</tt> computes a uniform random value in the
--   range [a,b) for any <a>RealFloat</a> type
realFloatUniform :: RealFloat a => a -> a -> RVarT m a

-- | <tt>floatUniform a b</tt> computes a uniform random <a>Float</a> value
--   in the range [a,b)
floatUniform :: Float -> Float -> RVarT m Float

-- | <tt>doubleUniform a b</tt> computes a uniform random <a>Double</a>
--   value in the range [a,b)
doubleUniform :: Double -> Double -> RVarT m Double

-- | <tt>fixedUniform a b</tt> computes a uniform random <a>Fixed</a> value
--   in the range [a,b), with any desired precision.
fixedUniform :: HasResolution r => Fixed r -> Fixed r -> RVarT m (Fixed r)

-- | <tt>realFloatUniform a b</tt> computes a uniform random value in the
--   range [a,b) for any <a>Enum</a> type
enumUniform :: Enum a => a -> a -> RVarT m a

-- | Compute a random value for a <a>Bounded</a> type, between
--   <a>minBound</a> and <a>maxBound</a> (inclusive for <a>Integral</a> or
--   <a>Enum</a> types, in [<a>minBound</a>, <a>maxBound</a>) for
--   Fractional types.)
boundedStdUniform :: (Distribution Uniform a, Bounded a) => RVar a

-- | Compute a random value for a <a>Bounded</a> <a>Enum</a> type, between
--   <a>minBound</a> and <a>maxBound</a> (inclusive)
boundedEnumStdUniform :: (Enum a, Bounded a) => RVarT m a

-- | Compute a uniform random value in the range [0,1) for any
--   <a>RealFloat</a> type
realFloatStdUniform :: RealFloat a => RVarT m a

-- | Compute a uniform random <a>Fixed</a> value in the range [0,1), with
--   any desired precision.
fixedStdUniform :: HasResolution r => RVarT m (Fixed r)

-- | Compute a uniform random <a>Float</a> value in the range [0,1)
floatStdUniform :: RVarT m Float

-- | Compute a uniform random <a>Double</a> value in the range [0,1)
doubleStdUniform :: RVarT m Double
boundedStdUniformCDF :: (CDF Uniform a, Bounded a) => a -> Double

-- | The CDF of the random variable <a>realFloatStdUniform</a>.
realStdUniformCDF :: Real a => a -> Double

-- | <tt>realUniformCDF a b</tt> is the CDF of the random variable
--   <tt>realFloatUniform a b</tt>.
realUniformCDF :: RealFrac a => a -> a -> a -> Double
enumUniformCDF :: (Enum a, Ord a) => a -> a -> a -> Double
instance CDF StdUniform Ordering
instance Distribution StdUniform Ordering
instance CDF StdUniform Char
instance Distribution StdUniform Char
instance CDF StdUniform Bool
instance Distribution StdUniform Bool
instance CDF StdUniform ()
instance Distribution StdUniform ()
instance CDF Uniform Ordering
instance Distribution Uniform Ordering
instance CDF Uniform Bool
instance Distribution Uniform Bool
instance CDF Uniform Char
instance Distribution Uniform Char
instance CDF Uniform ()
instance Distribution Uniform ()
instance HasResolution r => CDF StdUniform (Fixed r)
instance HasResolution r => Distribution StdUniform (Fixed r)
instance HasResolution r => CDF Uniform (Fixed r)
instance HasResolution r => Distribution Uniform (Fixed r)
instance PDF StdUniform Double
instance PDF StdUniform Float
instance CDF StdUniform Double
instance CDF StdUniform Float
instance Distribution StdUniform Double
instance Distribution StdUniform Float
instance CDF Uniform Double
instance CDF Uniform Float
instance Distribution Uniform Double
instance Distribution Uniform Float
instance CDF StdUniform Int
instance CDF StdUniform Int64
instance CDF StdUniform Int32
instance CDF StdUniform Int16
instance CDF StdUniform Int8
instance CDF StdUniform Word
instance CDF StdUniform Word64
instance CDF StdUniform Word32
instance CDF StdUniform Word16
instance CDF StdUniform Word8
instance Distribution StdUniform Word
instance Distribution StdUniform Int
instance Distribution StdUniform Int64
instance Distribution StdUniform Int32
instance Distribution StdUniform Int16
instance Distribution StdUniform Int8
instance Distribution StdUniform Word64
instance Distribution StdUniform Word32
instance Distribution StdUniform Word16
instance Distribution StdUniform Word8
instance CDF Uniform Word64
instance Distribution Uniform Word64
instance CDF Uniform Word32
instance Distribution Uniform Word32
instance CDF Uniform Word16
instance Distribution Uniform Word16
instance CDF Uniform Word8
instance Distribution Uniform Word8
instance CDF Uniform Word
instance Distribution Uniform Word
instance CDF Uniform Int64
instance Distribution Uniform Int64
instance CDF Uniform Int32
instance Distribution Uniform Int32
instance CDF Uniform Int16
instance Distribution Uniform Int16
instance CDF Uniform Int8
instance Distribution Uniform Int8
instance CDF Uniform Int
instance Distribution Uniform Int
instance CDF Uniform Integer
instance Distribution Uniform Integer

module Data.Random.List

-- | A random variable returning an arbitrary element of the given list.
--   Every element has equal probability of being chosen. Because it is a
--   pure <a>RVar</a> it has no memory - that is, it "draws with
--   replacement."
randomElement :: [a] -> RVar a
randomElementT :: [a] -> RVarT m a

-- | A random variable that returns the given list in an arbitrary shuffled
--   order. Every ordering of the list has equal probability.
shuffle :: [a] -> RVar [a]
shuffleT :: [a] -> RVarT m [a]

-- | A random variable that shuffles a list of a known length (or a list
--   prefix of the specified length). Useful for shuffling large lists when
--   the length is known in advance. Avoids needing to traverse the list to
--   discover its length. Each ordering has equal probability.
shuffleN :: Int -> [a] -> RVar [a]
shuffleNT :: Int -> [a] -> RVarT m [a]

-- | A random variable that selects N arbitrary elements of a list of known
--   length M.
shuffleNofM :: Int -> Int -> [a] -> RVar [a]
shuffleNofMT :: Int -> Int -> [a] -> RVarT m [a]

module Data.Random.Vector

-- | Take a random element of a vector.
randomElement :: Vector a -> RVar a

module Data.Random.Distribution.Bernoulli

-- | Generate a Bernoulli variate with the given probability. For
--   <tt>Bool</tt> results, <tt>bernoulli p</tt> will return True (p*100)%
--   of the time and False otherwise. For numerical types, True is replaced
--   by 1 and False by 0.
bernoulli :: Distribution (Bernoulli b) a => b -> RVar a

-- | Generate a Bernoulli process with the given probability. For
--   <tt>Bool</tt> results, <tt>bernoulli p</tt> will return True (p*100)%
--   of the time and False otherwise. For numerical types, True is replaced
--   by 1 and False by 0.
bernoulliT :: Distribution (Bernoulli b) a => b -> RVarT m a

-- | A random variable whose value is <a>True</a> the given fraction of the
--   time and <a>False</a> the rest.
boolBernoulli :: (Fractional a, Ord a, Distribution StdUniform a) => a -> RVarT m Bool
boolBernoulliCDF :: Real a => a -> Bool -> Double

-- | <tt>generalBernoulli t f p</tt> generates a random variable whose
--   value is <tt>t</tt> with probability <tt>p</tt> and <tt>f</tt> with
--   probability <tt>1-p</tt>.
generalBernoulli :: Distribution (Bernoulli b) Bool => a -> a -> b -> RVarT m a
generalBernoulliCDF :: CDF (Bernoulli b) Bool => (a -> a -> Bool) -> a -> a -> b -> a -> Double
newtype Bernoulli b a
Bernoulli :: b -> Bernoulli b a
instance (CDF (Bernoulli b) Bool, RealFloat a) => CDF (Bernoulli b) (Complex a)
instance (Distribution (Bernoulli b) Bool, RealFloat a) => Distribution (Bernoulli b) (Complex a)
instance (CDF (Bernoulli b) Bool, Integral a) => CDF (Bernoulli b) (Ratio a)
instance (Distribution (Bernoulli b) Bool, Integral a) => Distribution (Bernoulli b) (Ratio a)
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Double
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Double
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Float
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Float
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Word64
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Word64
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Word32
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Word32
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Word16
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Word16
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Word8
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Word8
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Word
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Word
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Int64
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Int64
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Int32
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Int32
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Int16
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Int16
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Int8
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Int8
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Int
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Int
instance CDF (Bernoulli b0) Bool => CDF (Bernoulli b0) Integer
instance Distribution (Bernoulli b0) Bool => Distribution (Bernoulli b0) Integer
instance (Distribution (Bernoulli b) Bool, Real b) => CDF (Bernoulli b) Bool
instance (Fractional b, Ord b, Distribution StdUniform b) => Distribution (Bernoulli b) Bool

module Data.Random.Distribution.Categorical

-- | Categorical distribution; a list of events with corresponding
--   probabilities. The sum of the probabilities must be 1, and no event
--   should have a zero or negative probability (at least, at time of
--   sampling; very clever users can do what they want with the numbers
--   before sampling, just make sure that if you're one of those clever
--   ones, you at least eliminate negative weights before sampling).
data Categorical p a

-- | Construct a <a>Categorical</a> random variable from a list of
--   probabilities and categories, where the probabilities all sum to 1.
categorical :: (Num p, Distribution (Categorical p) a) => [(p, a)] -> RVar a

-- | Construct a <a>Categorical</a> random process from a list of
--   probabilities and categories, where the probabilities all sum to 1.
categoricalT :: (Num p, Distribution (Categorical p) a) => [(p, a)] -> RVarT m a

-- | Construct a <a>Categorical</a> random variable from a list of
--   probabilities and categories, where the probabilities all sum to 1.
weightedCategorical :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p, a)] -> RVar a

-- | Construct a <a>Categorical</a> random process from a list of
--   probabilities and categories, where the probabilities all sum to 1.
weightedCategoricalT :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p, a)] -> RVarT m a

-- | Construct a <a>Categorical</a> distribution from a list of weighted
--   categories.
fromList :: Num p => [(p, a)] -> Categorical p a
toList :: Num p => Categorical p a -> [(p, a)]
totalWeight :: Num p => Categorical p a -> p
numEvents :: Categorical p a -> Int

-- | Construct a <a>Categorical</a> distribution from a list of weighted
--   categories, where the weights do not necessarily sum to 1.
fromWeightedList :: (Fractional p, Eq p) => [(p, a)] -> Categorical p a

-- | Construct a <a>Categorical</a> distribution from a list of observed
--   outcomes. Equivalent events will be grouped and counted, and the
--   probabilities of each event in the returned distribution will be
--   proportional to the number of occurrences of that event.
fromObservations :: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a

-- | Like <a>fmap</a>, but for the probabilities of a categorical
--   distribution.
mapCategoricalPs :: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e

-- | Adjust all the weights of a categorical distribution so that they sum
--   to unity and remove all events whose probability is zero.
normalizeCategoricalPs :: (Fractional p, Eq p) => Categorical p e -> Categorical p e

-- | Simplify a categorical distribution by combining equivalent events
--   (the new event will have a probability equal to the sum of all the
--   originals).
collectEvents :: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e

-- | Simplify a categorical distribution by combining equivalent events
--   (the new event will have a weight equal to the sum of all the
--   originals). The comparator function is used to identify events to
--   combine. Once chosen, the events and their weights are combined by the
--   provided probability and event aggregation function.
collectEventsBy :: Num p => (e -> e -> Ordering) -> ([(p, e)] -> (p, e)) -> Categorical p e -> Categorical p e
instance (Eq p, Eq a) => Eq (Categorical p a)
instance Fractional p => Applicative (Categorical p)
instance Fractional p => Monad (Categorical p)
instance Traversable (Categorical p)
instance Foldable (Categorical p)
instance Functor (Categorical p)
instance (Fractional p, Ord p, Distribution Uniform p) => Distribution (Categorical p) a
instance (Num p, Read p, Read a) => Read (Categorical p a)
instance (Num p, Show p, Show a) => Show (Categorical p a)

module Data.Random.Distribution.Exponential
newtype Exponential a
Exp :: a -> Exponential a
floatingExponential :: (Floating a, Distribution StdUniform a) => a -> RVarT m a
floatingExponentialCDF :: Real a => a -> a -> Double
exponential :: Distribution Exponential a => a -> RVar a
exponentialT :: Distribution Exponential a => a -> RVarT m a
instance (Real a, Distribution Exponential a) => CDF Exponential a
instance (Floating a, Distribution StdUniform a) => Distribution Exponential a

module Data.Random.Distribution.StretchedExponential
newtype StretchedExponential a
StretchedExp :: (a, a) -> StretchedExponential a
floatingStretchedExponential :: (Floating a, Distribution StdUniform a) => a -> a -> RVarT m a
floatingStretchedExponentialCDF :: Real a => a -> a -> a -> Double
stretchedExponential :: Distribution StretchedExponential a => a -> a -> RVar a
stretchedExponentialT :: Distribution StretchedExponential a => a -> a -> RVarT m a
instance (Real a, Distribution StretchedExponential a) => CDF StretchedExponential a
instance (Floating a, Distribution StdUniform a) => Distribution StretchedExponential a


-- | A generic "ziggurat algorithm" implementation. Fairly rough right now.
--   
--   There is a lot of room for improvement in <a>findBin0</a> especially.
--   It needs a fair amount of cleanup and elimination of redundant
--   calculation, as well as either a justification for using the simple
--   <a>findMinFrom</a> or a proper root-finding algorithm.
--   
--   It would also be nice to add (preferably by pulling in an external
--   package) support for numerical integration and differentiation, so
--   that tables can be derived from only a PDF (if the end user is willing
--   to take the performance and accuracy hit for the convenience).
module Data.Random.Distribution.Ziggurat

-- | A data structure containing all the data that is needed to implement
--   Marsaglia &amp; Tang's "ziggurat" algorithm for sampling certain kinds
--   of random distributions.
--   
--   The documentation here is probably not sufficient to tell a user
--   exactly how to build one of these from scratch, but it is not really
--   intended to be. There are several helper functions that will build
--   <a>Ziggurat</a>s. The pathologically curious may wish to read the
--   <a>runZiggurat</a> source. That is the ultimate specification of the
--   semantics of all these fields.
data Ziggurat v t
Ziggurat :: !(v t) -> !(v t) -> !(v t) -> !(forall m. RVarT m (Int, t)) -> (forall m. RVarT m t) -> !(forall m. t -> t -> RVarT m t) -> !(t -> t) -> !Bool -> Ziggurat v t

-- | The X locations of each bin in the distribution. Bin 0 is the
--   <tt>infinite</tt> one.
--   
--   In the case of bin 0, the value given is sort of magical - x[0] is
--   defined to be V/f(R). It's not actually the location of any bin, but a
--   value computed to make the algorithm more concise and slightly faster
--   by not needing to specially-handle bin 0 quite as often. If you really
--   need to know why it works, see the <a>runZiggurat</a> source or "the
--   literature" - it's a fairly standard setup.
zTable_xs :: Ziggurat v t -> !(v t)

-- | The ratio of each bin's Y value to the next bin's Y value
zTable_y_ratios :: Ziggurat v t -> !(v t)

-- | The Y value (zFunc x) of each bin
zTable_ys :: Ziggurat v t -> !(v t)

-- | An RVar providing a random tuple consisting of:
--   
--   <ul>
--   <li>a bin index, uniform over [0,c) :: Int (where <tt>c</tt> is the
--   number of bins in the tables)</li>
--   <li>a uniformly distributed fractional value, from -1 to 1 if not
--   mirrored, from 0 to 1 otherwise.</li>
--   </ul>
--   
--   This is provided as a single <a>RVar</a> because it can be implemented
--   more efficiently than naively sampling 2 separate values - a single
--   random word (64 bits) can be efficiently converted to a double (using
--   52 bits) and a bin number (using up to 12 bits), for example.
zGetIU :: Ziggurat v t -> !(forall m. RVarT m (Int, t))

-- | The distribution for the final "virtual" bin (the ziggurat algorithm
--   does not handle distributions that wander off to infinity, so another
--   distribution is needed to handle the last "bin" that stretches to
--   infinity)
zTailDist :: Ziggurat v t -> (forall m. RVarT m t)

-- | A copy of the uniform RVar generator for the base type, so that
--   <tt>Distribution Uniform t</tt> is not needed when sampling from a
--   Ziggurat (makes it a bit more self-contained).
zUniform :: Ziggurat v t -> !(forall m. t -> t -> RVarT m t)

-- | The (one-sided antitone) PDF, not necessarily normalized
zFunc :: Ziggurat v t -> !(t -> t)

-- | A flag indicating whether the distribution should be mirrored about
--   the origin (the ziggurat algorithm in its native form only samples
--   from one-sided distributions. By mirroring, we can extend it to
--   symmetric distributions such as the normal distribution)
zMirror :: Ziggurat v t -> !Bool

-- | Build a lazy recursive ziggurat. Uses a lazily-constructed ziggurat as
--   its tail distribution (with another as its tail, ad nauseam).
--   
--   Arguments:
--   
--   <ul>
--   <li>flag indicating whether to mirror the distribution</li>
--   <li>the (one-sided antitone) PDF, not necessarily normalized</li>
--   <li>the inverse of the PDF</li>
--   <li>the integral of the PDF (definite, from 0)</li>
--   <li>the estimated volume under the PDF (from 0 to +infinity)</li>
--   <li>the chunk size (number of bins in each layer). 64 seems to perform
--   well in practice.</li>
--   <li>an RVar providing the <a>zGetIU</a> random tuple</li>
--   </ul>
mkZigguratRec :: (RealFloat t, Vector v t, Distribution Uniform t) => Bool -> (t -> t) -> (t -> t) -> (t -> t) -> t -> Int -> (forall m. RVarT m (Int, t)) -> Ziggurat v t

-- | Build the tables to implement the "ziggurat algorithm" devised by
--   Marsaglia &amp; Tang, attempting to automatically compute the R and V
--   values.
--   
--   Arguments are the same as for <a>mkZigguratRec</a>, with an additional
--   argument for the tail distribution as a function of the selected R
--   value.
mkZiggurat :: (RealFloat t, Vector v t, Distribution Uniform t) => Bool -> (t -> t) -> (t -> t) -> (t -> t) -> t -> Int -> (forall m. RVarT m (Int, t)) -> (forall m. t -> RVarT m t) -> Ziggurat v t

-- | Build the tables to implement the "ziggurat algorithm" devised by
--   Marsaglia &amp; Tang, attempting to automatically compute the R and V
--   values.
--   
--   Arguments:
--   
--   <ul>
--   <li>flag indicating whether to mirror the distribution</li>
--   <li>the (one-sided antitone) PDF, not necessarily normalized</li>
--   <li>the inverse of the PDF</li>
--   <li>the number of bins</li>
--   <li>R, the x value of the first bin</li>
--   <li>V, the volume of each bin</li>
--   <li>an RVar providing the <a>zGetIU</a> random tuple</li>
--   <li>an RVar sampling from the tail (the region where x &gt; R)</li>
--   </ul>
mkZiggurat_ :: (RealFloat t, Vector v t, Distribution Uniform t) => Bool -> (t -> t) -> (t -> t) -> Int -> t -> t -> (forall m. RVarT m (Int, t)) -> (forall m. RVarT m t) -> Ziggurat v t

-- | I suspect this isn't completely right, but it works well so far.
--   Search the distribution for an appropriate R and V.
--   
--   Arguments:
--   
--   <ul>
--   <li>Number of bins</li>
--   <li>target function (one-sided antitone PDF, not necessarily
--   normalized)</li>
--   <li>function inverse</li>
--   <li>function definite integral (from 0 to _)</li>
--   <li>estimate of total volume under function (integral from 0 to
--   infinity)</li>
--   </ul>
--   
--   Result: (R,V)
findBin0 :: RealFloat b => Int -> (b -> b) -> (b -> b) -> (b -> b) -> b -> (b, b)

-- | Sample from the distribution encoded in a <a>Ziggurat</a> data
--   structure.
runZiggurat :: (Num a, Ord a, Vector v a) => Ziggurat v a -> RVarT m a
instance (Num t, Ord t, Vector v t) => Distribution (Ziggurat v) t

module Data.Random.Distribution.Normal

-- | A specification of a normal distribution over the type <tt>a</tt>.
data Normal a

-- | The "standard" normal distribution - mean 0, stddev 1
StdNormal :: Normal a

-- | <tt>Normal m s</tt> is a normal distribution with mean <tt>m</tt> and
--   stddev <tt>sd</tt>.
Normal :: a -> a -> Normal a

-- | <tt>normal m s</tt> is a random variable with distribution
--   <tt><a>Normal</a> m s</tt>.
normal :: Distribution Normal a => a -> a -> RVar a

-- | <tt>normalT m s</tt> is a random process with distribution
--   <tt><a>Normal</a> m s</tt>.
normalT :: Distribution Normal a => a -> a -> RVarT m a

-- | <a>stdNormal</a> is a normal variable with distribution
--   <a>StdNormal</a>.
stdNormal :: Distribution Normal a => RVar a

-- | <a>stdNormalT</a> is a normal process with distribution
--   <a>StdNormal</a>.
stdNormalT :: Distribution Normal a => RVarT m a

-- | A random variable sampling from the standard normal distribution over
--   the <a>Double</a> type.
doubleStdNormal :: RVarT m Double

-- | A random variable sampling from the standard normal distribution over
--   the <a>Float</a> type.
floatStdNormal :: RVarT m Float

-- | A random variable sampling from the standard normal distribution over
--   any <a>RealFloat</a> type (subject to the rest of the constraints - it
--   builds and uses a <a>Ziggurat</a> internally, which requires the
--   <a>Erf</a> class).
--   
--   Because it computes a <a>Ziggurat</a>, it is very expensive to use for
--   just one evaluation, or even for multiple evaluations if not used and
--   reused monomorphically (to enable the ziggurat table to be let-floated
--   out). If you don't know whether your use case fits this description
--   then you're probably better off using a different algorithm, such as
--   <a>boxMullerNormalPair</a> or <a>knuthPolarNormalPair</a>. And of
--   course if you don't need the full generality of this definition then
--   you're much better off using <a>doubleStdNormal</a> or
--   <a>floatStdNormal</a>.
--   
--   As far as I know, this should be safe to use in any monomorphic
--   <tt>Distribution Normal</tt> instance declaration.
realFloatStdNormal :: (RealFloat a, Erf a, Distribution Uniform a) => RVarT m a

-- | Draw from the tail of a normal distribution (the region beyond the
--   provided value)
normalTail :: (Distribution StdUniform a, Floating a, Ord a) => a -> RVarT m a

-- | A random variable that produces a pair of independent
--   normally-distributed values.
normalPair :: (Floating a, Distribution StdUniform a) => RVar (a, a)

-- | A random variable that produces a pair of independent
--   normally-distributed values, computed using the Box-Muller method.
--   This algorithm is slightly slower than Knuth's method but using a
--   constant amount of entropy (Knuth's method is a rejection method). It
--   is also slightly more general (Knuth's method require an <a>Ord</a>
--   instance).
boxMullerNormalPair :: (Floating a, Distribution StdUniform a) => RVar (a, a)

-- | A random variable that produces a pair of independent
--   normally-distributed values, computed using Knuth's polar method.
--   Slightly faster than <a>boxMullerNormalPair</a> when it accepts on the
--   first try, but does not always do so.
knuthPolarNormalPair :: (Floating a, Ord a, Distribution Uniform a) => RVar (a, a)
instance (Real a, Floating a, Distribution Normal a) => PDF Normal a
instance (Real a, Distribution Normal a) => CDF Normal a
instance Distribution Normal Float
instance Distribution Normal Double

module Data.Random.Distribution.Gamma
data Gamma a
Gamma :: a -> a -> Gamma a
gamma :: Distribution Gamma a => a -> a -> RVar a
gammaT :: Distribution Gamma a => a -> a -> RVarT m a
newtype Erlang a b
Erlang :: a -> Erlang a b
erlang :: Distribution (Erlang a) b => a -> RVar b
erlangT :: Distribution (Erlang a) b => a -> RVarT m b

-- | derived from Marsaglia &amp; Tang, "A Simple Method for generating
--   gamma variables", ACM Transactions on Mathematical Software, Vol 26,
--   No 3 (2000), p363-372.
mtGamma :: (Floating a, Ord a, Distribution StdUniform a, Distribution Normal a) => a -> a -> RVarT m a
instance (Integral a, Real b, Distribution (Erlang a) b) => CDF (Erlang a) b
instance (Integral a, Floating b, Ord b, Distribution Normal b, Distribution StdUniform b) => Distribution (Erlang a) b
instance (Real a, Distribution Gamma a) => CDF Gamma a
instance (Floating a, Ord a, Distribution Normal a, Distribution StdUniform a) => Distribution Gamma a

module Data.Random.Distribution.Beta
fractionalBeta :: (Fractional a, Eq a, Distribution Gamma a, Distribution StdUniform a) => a -> a -> RVarT m a
beta :: Distribution Beta a => a -> a -> RVar a
betaT :: Distribution Beta a => a -> a -> RVarT m a
data Beta a
Beta :: a -> a -> Beta a
logBetaPdf :: Double -> Double -> Double -> Double
instance Distribution Beta Double
instance Distribution Beta Float
instance PDF Beta Float
instance PDF Beta Double

module Data.Random.Distribution.Binomial
integralBinomial :: (Integral a, Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => a -> b -> RVarT m a
integralBinomialCDF :: (Integral a, Real b) => a -> b -> a -> Double
integralBinomialPDF :: (Integral a, Real b) => a -> b -> a -> Double
integralBinomialLogPdf :: (Integral a, Real b) => a -> b -> a -> Double
floatingBinomial :: (RealFrac a, Distribution (Binomial b) Integer) => a -> b -> RVar a
floatingBinomialCDF :: (CDF (Binomial b) Integer, RealFrac a) => a -> b -> a -> Double
floatingBinomialPDF :: (PDF (Binomial b) Integer, RealFrac a) => a -> b -> a -> Double
floatingBinomialLogPDF :: (PDF (Binomial b) Integer, RealFrac a) => a -> b -> a -> Double
binomial :: Distribution (Binomial b) a => a -> b -> RVar a
binomialT :: Distribution (Binomial b) a => a -> b -> RVarT m a
data Binomial b a
Binomial :: a -> b -> Binomial b a
instance PDF (Binomial b0) Integer => PDF (Binomial b0) Double
instance CDF (Binomial b0) Integer => CDF (Binomial b0) Double
instance Distribution (Binomial b0) Integer => Distribution (Binomial b0) Double
instance PDF (Binomial b0) Integer => PDF (Binomial b0) Float
instance CDF (Binomial b0) Integer => CDF (Binomial b0) Float
instance Distribution (Binomial b0) Integer => Distribution (Binomial b0) Float
instance (Real b0, Distribution (Binomial b0) Word64) => PDF (Binomial b0) Word64
instance (Real b0, Distribution (Binomial b0) Word64) => CDF (Binomial b0) Word64
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Word64
instance (Real b0, Distribution (Binomial b0) Word32) => PDF (Binomial b0) Word32
instance (Real b0, Distribution (Binomial b0) Word32) => CDF (Binomial b0) Word32
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Word32
instance (Real b0, Distribution (Binomial b0) Word16) => PDF (Binomial b0) Word16
instance (Real b0, Distribution (Binomial b0) Word16) => CDF (Binomial b0) Word16
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Word16
instance (Real b0, Distribution (Binomial b0) Word8) => PDF (Binomial b0) Word8
instance (Real b0, Distribution (Binomial b0) Word8) => CDF (Binomial b0) Word8
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Word8
instance (Real b0, Distribution (Binomial b0) Word) => PDF (Binomial b0) Word
instance (Real b0, Distribution (Binomial b0) Word) => CDF (Binomial b0) Word
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Word
instance (Real b0, Distribution (Binomial b0) Int64) => PDF (Binomial b0) Int64
instance (Real b0, Distribution (Binomial b0) Int64) => CDF (Binomial b0) Int64
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Int64
instance (Real b0, Distribution (Binomial b0) Int32) => PDF (Binomial b0) Int32
instance (Real b0, Distribution (Binomial b0) Int32) => CDF (Binomial b0) Int32
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Int32
instance (Real b0, Distribution (Binomial b0) Int16) => PDF (Binomial b0) Int16
instance (Real b0, Distribution (Binomial b0) Int16) => CDF (Binomial b0) Int16
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Int16
instance (Real b0, Distribution (Binomial b0) Int8) => PDF (Binomial b0) Int8
instance (Real b0, Distribution (Binomial b0) Int8) => CDF (Binomial b0) Int8
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Int8
instance (Real b0, Distribution (Binomial b0) Int) => PDF (Binomial b0) Int
instance (Real b0, Distribution (Binomial b0) Int) => CDF (Binomial b0) Int
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Int
instance (Real b0, Distribution (Binomial b0) Integer) => PDF (Binomial b0) Integer
instance (Real b0, Distribution (Binomial b0) Integer) => CDF (Binomial b0) Integer
instance (Floating b0, Ord b0, Distribution Beta b0, Distribution StdUniform b0) => Distribution (Binomial b0) Integer

module Data.Random.Distribution.Multinomial
multinomial :: Distribution (Multinomial p) [a] => [p] -> a -> RVar [a]
multinomialT :: Distribution (Multinomial p) [a] => [p] -> a -> RVarT m [a]
data Multinomial p a
Multinomial :: [p] -> a -> Multinomial p [a]
instance (Num a, Eq a, Fractional p, Distribution (Binomial p) a) => Distribution (Multinomial p) [a]

module Data.Random.Distribution.ChiSquare
chiSquare :: Distribution ChiSquare t => Integer -> RVar t
chiSquareT :: Distribution ChiSquare t => Integer -> RVarT m t
newtype ChiSquare b
ChiSquare :: Integer -> ChiSquare b
instance (Real t, Distribution ChiSquare t) => CDF ChiSquare t
instance (Fractional t, Distribution Gamma t) => Distribution ChiSquare t

module Data.Random.Distribution.Dirichlet
fractionalDirichlet :: (Fractional a, Distribution Gamma a) => [a] -> RVarT m [a]
dirichlet :: Distribution Dirichlet [a] => [a] -> RVar [a]
dirichletT :: Distribution Dirichlet [a] => [a] -> RVarT m [a]
newtype Dirichlet a
Dirichlet :: a -> Dirichlet a
instance Eq a => Eq (Dirichlet a)
instance Show a => Show (Dirichlet a)
instance (Fractional a, Distribution Gamma a) => Distribution Dirichlet [a]

module Data.Random.Distribution.Poisson
integralPoisson :: (Integral a, RealFloat b, Distribution StdUniform b, Distribution (Erlang a) b, Distribution (Binomial b) a) => b -> RVarT m a
integralPoissonCDF :: (Integral a, Real b) => b -> a -> Double
fractionalPoisson :: (Num a, Distribution (Poisson b) Integer) => b -> RVarT m a
fractionalPoissonCDF :: (CDF (Poisson b) Integer, RealFrac a) => b -> a -> Double
poisson :: Distribution (Poisson b) a => b -> RVar a
poissonT :: Distribution (Poisson b) a => b -> RVarT m a
newtype Poisson b a
Poisson :: b -> Poisson b a
instance CDF (Poisson b0) Integer => CDF (Poisson b0) Double
instance Distribution (Poisson b0) Integer => Distribution (Poisson b0) Double
instance CDF (Poisson b0) Integer => CDF (Poisson b0) Float
instance Distribution (Poisson b0) Integer => Distribution (Poisson b0) Float
instance (Real b0, Distribution (Poisson b0) Word64) => CDF (Poisson b0) Word64
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Word64) b0, Distribution (Binomial b0) Word64) => Distribution (Poisson b0) Word64
instance (Real b0, Distribution (Poisson b0) Word32) => CDF (Poisson b0) Word32
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Word32) b0, Distribution (Binomial b0) Word32) => Distribution (Poisson b0) Word32
instance (Real b0, Distribution (Poisson b0) Word16) => CDF (Poisson b0) Word16
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Word16) b0, Distribution (Binomial b0) Word16) => Distribution (Poisson b0) Word16
instance (Real b0, Distribution (Poisson b0) Word8) => CDF (Poisson b0) Word8
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Word8) b0, Distribution (Binomial b0) Word8) => Distribution (Poisson b0) Word8
instance (Real b0, Distribution (Poisson b0) Word) => CDF (Poisson b0) Word
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Word) b0, Distribution (Binomial b0) Word) => Distribution (Poisson b0) Word
instance (Real b0, Distribution (Poisson b0) Int64) => CDF (Poisson b0) Int64
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Int64) b0, Distribution (Binomial b0) Int64) => Distribution (Poisson b0) Int64
instance (Real b0, Distribution (Poisson b0) Int32) => CDF (Poisson b0) Int32
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Int32) b0, Distribution (Binomial b0) Int32) => Distribution (Poisson b0) Int32
instance (Real b0, Distribution (Poisson b0) Int16) => CDF (Poisson b0) Int16
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Int16) b0, Distribution (Binomial b0) Int16) => Distribution (Poisson b0) Int16
instance (Real b0, Distribution (Poisson b0) Int8) => CDF (Poisson b0) Int8
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Int8) b0, Distribution (Binomial b0) Int8) => Distribution (Poisson b0) Int8
instance (Real b0, Distribution (Poisson b0) Int) => CDF (Poisson b0) Int
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Int) b0, Distribution (Binomial b0) Int) => Distribution (Poisson b0) Int
instance (Real b0, Distribution (Poisson b0) Integer) => CDF (Poisson b0) Integer
instance (RealFloat b0, Distribution StdUniform b0, Distribution (Erlang Integer) b0, Distribution (Binomial b0) Integer) => Distribution (Poisson b0) Integer

module Data.Random.Distribution.Rayleigh
floatingRayleigh :: (Floating a, Eq a, Distribution StdUniform a) => a -> RVarT m a

-- | The rayleigh distribution with a specified mode ("sigma") parameter.
--   Its mean will be <tt>sigma*sqrt(pi/2)</tt> and its variance will be
--   <tt>sigma^2*(4-pi)/2</tt>
--   
--   (therefore if you want one with a particular mean <tt>m</tt>,
--   <tt>sigma</tt> should be <tt>m*sqrt(2/pi)</tt>)
newtype Rayleigh a
Rayleigh :: a -> Rayleigh a
rayleigh :: Distribution Rayleigh a => a -> RVar a
rayleighT :: Distribution Rayleigh a => a -> RVarT m a
rayleighCDF :: Real a => a -> a -> Double
instance (Real a, Distribution Rayleigh a) => CDF Rayleigh a
instance (RealFloat a, Distribution StdUniform a) => Distribution Rayleigh a

module Data.Random.Distribution.T
t :: Distribution T a => Integer -> RVar a
tT :: Distribution T a => Integer -> RVarT m a
newtype T a
T :: Integer -> T a
instance Eq (T a)
instance Ord (T a)
instance Show (T a)
instance (Real a, Distribution T a) => CDF T a
instance (Floating a, Distribution Normal a, Distribution ChiSquare a) => Distribution T a

module Data.Random.Distribution.Triangular

-- | A description of a triangular distribution - a distribution whose PDF
--   is a triangle ramping up from a lower bound to a specified midpoint
--   and back down to the upper bound. This is a very simple distribution
--   that does not generally occur naturally but is used sometimes as an
--   estimate of a true distribution when only the range of the values and
--   an approximate mode of the true distribution are known.
data Triangular a
Triangular :: a -> a -> a -> Triangular a

-- | The lower bound of the triangle in the PDF (the smallest number the
--   distribution can generate)
triLower :: Triangular a -> a

-- | The midpoint of the triangle (also the mode of the distribution)
triMid :: Triangular a -> a

-- | The upper bound of the triangle (and the largest number the
--   distribution can generate)
triUpper :: Triangular a -> a

-- | Compute a triangular distribution for a <a>Floating</a> type.
floatingTriangular :: (Floating a, Ord a, Distribution StdUniform a) => a -> a -> a -> RVarT m a

-- | <tt>triangularCDF a b c</tt> is the CDF of <tt>realFloatTriangular a b
--   c</tt>.
triangularCDF :: RealFrac a => a -> a -> a -> a -> Double
instance Eq a => Eq (Triangular a)
instance Show a => Show (Triangular a)
instance (RealFrac a, Distribution Triangular a) => CDF Triangular a
instance (RealFloat a, Ord a, Distribution StdUniform a) => Distribution Triangular a

module Data.Random.Distribution.Weibull
data Weibull a
Weibull :: !a -> !a -> Weibull a
weibullLambda :: Weibull a -> !a
weibullK :: Weibull a -> !a
instance Eq a => Eq (Weibull a)
instance Show a => Show (Weibull a)
instance (Real a, Distribution Weibull a) => CDF Weibull a
instance (Floating a, Distribution StdUniform a) => Distribution Weibull a

module Data.Random.Sample

-- | A typeclass allowing <a>Distribution</a>s and <a>RVar</a>s to be
--   sampled. Both may also be sampled via <a>runRVar</a> or
--   <a>runRVarT</a>, but I find it psychologically pleasing to be able to
--   sample both using this function, as they are two separate abstractions
--   for one base concept: a random variable.
class Sampleable d m t
sampleFrom :: (Sampleable d m t, RandomSource m s) => s -> d t -> m t

-- | Sample a random variable using the default source of entropy for the
--   monad in which the sampling occurs.
sample :: (Sampleable d m t, MonadRandom m) => d t -> m t

-- | Sample a random variable in a "functional" style. Typical
--   instantiations of <tt>s</tt> are <tt>System.Random.StdGen</tt> or
--   <tt>System.Random.Mersenne.Pure64.PureMT</tt>.
sampleState :: (Sampleable d (State s) t, MonadRandom (State s)) => d t -> s -> (t, s)

-- | Sample a random variable in a "semi-functional" style. Typical
--   instantiations of <tt>s</tt> are <tt>System.Random.StdGen</tt> or
--   <tt>System.Random.Mersenne.Pure64.PureMT</tt>.
sampleStateT :: (Sampleable d (StateT s m) t, MonadRandom (StateT s m)) => d t -> s -> m (t, s)
instance [incoherent] Lift m n => Sampleable (RVarT m) n t
instance [incoherent] Distribution d t => Sampleable d m t


-- | Flexible modeling and sampling of random variables.
--   
--   The central abstraction in this library is the concept of a random
--   variable. It is not fully formalized in the standard measure-theoretic
--   language, but rather is informally defined as a "thing you can get
--   random values out of". Different random variables may have different
--   types of values they can return or the same types but different
--   probabilities for each value they can return. The random values you
--   get out of them are traditionally called "random variates".
--   
--   Most imperative-language random number libraries are all about
--   obtaining and manipulating random variates. This one is about
--   defining, manipulating and sampling random variables. Computationally,
--   the distinction is small and mostly just a matter of perspective, but
--   from a program design perspective it provides both a powerfully
--   composable abstraction and a very useful separation of concerns.
--   
--   Abstract random variables as implemented by <a>RVar</a> are
--   composable. They can be defined in a monadic / "imperative" style that
--   amounts to manipulating variates, but with strict type-level
--   isolation. Concrete random variables are also provided, but they do
--   not compose as generically. The <a>Distribution</a> type class allows
--   concrete random variables to "forget" their concreteness so that they
--   can be composed. For examples of both, see the documentation for
--   <a>RVar</a> and <a>Distribution</a>, as well as the code for any of
--   the concrete distributions such as <a>Uniform</a>, <a>Gamma</a>, etc.
--   
--   Both abstract and concrete random variables can be sampled (despite
--   the types GHCi may list for the functions) by the functions in
--   <a>Data.Random.Sample</a>.
--   
--   Random variable sampling is done with regard to a generic basis of
--   primitive random variables defined in
--   <a>Data.Random.Internal.Primitives</a>. This basis is very low-level
--   and the actual set of primitives is still fairly experimental, which
--   is why it is in the "Internal" sub-heirarchy. User-defined variables
--   should use the existing high-level variables such as <a>Uniform</a>
--   and <a>Normal</a> rather than these basis variables.
--   <a>Data.Random.Source</a> defines classes for entropy sources that
--   provide implementations of these primitive variables. Several
--   implementations are available in the Data.Random.Source.* modules.
module Data.Random

-- | An opaque type modeling a "random variable" - a value which depends on
--   the outcome of some random event. <a>RVar</a>s can be conveniently
--   defined by an imperative-looking style:
--   
--   <pre>
--   normalPair =  do
--       u &lt;- stdUniform
--       t &lt;- stdUniform
--       let r = sqrt (-2 * log u)
--           theta = (2 * pi) * t
--           
--           x = r * cos theta
--           y = r * sin theta
--       return (x,y)
--   </pre>
--   
--   OR by a more applicative style:
--   
--   <pre>
--   logNormal = exp &lt;$&gt; stdNormal
--   </pre>
--   
--   Once defined (in any style), there are several ways to sample
--   <a>RVar</a>s:
--   
--   <ul>
--   <li>In a monad, using a <a>RandomSource</a>:</li>
--   </ul>
--   
--   <pre>
--   runRVar (uniform 1 100) DevRandom :: IO Int
--   </pre>
--   
--   <ul>
--   <li>In a monad, using a <a>MonadRandom</a> instance:</li>
--   </ul>
--   
--   <pre>
--   sampleRVar (uniform 1 100) :: State PureMT Int
--   </pre>
--   
--   <ul>
--   <li>As a pure function transforming a functional RNG:</li>
--   </ul>
--   
--   <pre>
--   sampleState (uniform 1 100) :: StdGen -&gt; (Int, StdGen)
--   </pre>
--   
--   (where <tt>sampleState = runState . sampleRVar</tt>)
type RVar = RVarT Identity

-- | A random variable with access to operations in an underlying monad.
--   Useful examples include any form of state for implementing random
--   processes with hysteresis, or writer monads for implementing tracing
--   of complicated algorithms.
--   
--   For example, a simple random walk can be implemented as an
--   <a>RVarT</a> <a>IO</a> value:
--   
--   <pre>
--   rwalkIO :: IO (RVarT IO Double)
--   rwalkIO d = do
--       lastVal &lt;- newIORef 0
--       
--       let x = do
--               prev    &lt;- lift (readIORef lastVal)
--               change  &lt;- rvarT StdNormal
--               
--               let new = prev + change
--               lift (writeIORef lastVal new)
--               return new
--           
--       return x
--   </pre>
--   
--   To run the random walk it must first be initialized, after which it
--   can be sampled as usual:
--   
--   <pre>
--   do
--       rw &lt;- rwalkIO
--       x &lt;- sampleRVarT rw
--       y &lt;- sampleRVarT rw
--       ...
--   </pre>
--   
--   The same random-walk process as above can be implemented using MTL
--   types as follows (using <tt>import Control.Monad.Trans as MTL</tt>):
--   
--   <pre>
--   rwalkState :: RVarT (State Double) Double
--   rwalkState = do
--       prev &lt;- MTL.lift get
--       change  &lt;- rvarT StdNormal
--       
--       let new = prev + change
--       MTL.lift (put new)
--       return new
--   </pre>
--   
--   Invocation is straightforward (although a bit noisy) if you're used to
--   MTL:
--   
--   <pre>
--   rwalk :: Int -&gt; Double -&gt; StdGen -&gt; ([Double], StdGen)
--   rwalk count start gen = 
--       flip evalState start .
--           flip runStateT gen .
--               sampleRVarTWith MTL.lift $
--                   replicateM count rwalkState
--   </pre>
data RVarT (m :: * -> *) a :: (* -> *) -> * -> *

-- | "Run" an <a>RVar</a> - samples the random variable from the provided
--   source of entropy.
runRVar :: RandomSource m s => RVar a -> s -> m a

-- | Like <a>runRVarTWith</a>, but using an implicit lifting (provided by
--   the <a>Lift</a> class)
runRVarT :: (Lift n m, RandomSource m s) => RVarT n a -> s -> m a

-- | "Runs" an <a>RVarT</a>, sampling the random variable it defines.
--   
--   The first argument lifts the base monad into the sampling monad. This
--   operation must obey the "monad transformer" laws:
--   
--   <pre>
--   lift . return = return
--   lift (x &gt;&gt;= f) = (lift x) &gt;&gt;= (lift . f)
--   </pre>
--   
--   One example of a useful non-standard lifting would be one that takes
--   <tt>State s</tt> to another monad with a different state
--   representation (such as <tt>IO</tt> with the state mapped to an
--   <tt>IORef</tt>):
--   
--   <pre>
--   embedState :: (Monad m) =&gt; m s -&gt; (s -&gt; m ()) -&gt; State s a -&gt; m a
--   embedState get put = \m -&gt; do
--       s &lt;- get
--       (res,s) &lt;- return (runState m s)
--       put s
--       return res
--   </pre>
--   
--   The ability to lift is very important - without it, every <a>RVar</a>
--   would have to either be given access to the full capability of the
--   monad in which it will eventually be sampled (which, incidentally,
--   would also have to be monomorphic so you couldn't sample one
--   <a>RVar</a> in more than one monad) or functions manipulating
--   <a>RVar</a>s would have to use higher-ranked types to enforce the same
--   kind of isolation and polymorphism.
runRVarTWith :: RandomSource m s => (forall t. n t -> m t) -> RVarT n a -> s -> m a

-- | A <a>Distribution</a> is a data representation of a random variable's
--   probability structure. For example, in
--   <a>Data.Random.Distribution.Normal</a>, the <tt>Normal</tt>
--   distribution is defined as:
--   
--   <pre>
--   data Normal a
--       = StdNormal
--       | Normal a a
--   </pre>
--   
--   Where the two parameters of the <tt>Normal</tt> data constructor are
--   the mean and standard deviation of the random variable, respectively.
--   To make use of the <tt>Normal</tt> type, one can convert it to an
--   <a>rvar</a> and manipulate it or sample it directly:
--   
--   <pre>
--   x &lt;- sample (rvar (Normal 10 2))
--   x &lt;- sample (Normal 10 2)
--   </pre>
--   
--   A <a>Distribution</a> is typically more transparent than an
--   <a>RVar</a> but less composable (precisely because of that
--   transparency). There are several practical uses for types implementing
--   <a>Distribution</a>:
--   
--   <ul>
--   <li>Typically, a <a>Distribution</a> will expose several parameters of
--   a standard mathematical model of a probability distribution, such as
--   mean and std deviation for the normal distribution. Thus, they can be
--   manipulated analytically using mathematical insights about the
--   distributions they represent. For example, a collection of bernoulli
--   variables could be simplified into a (hopefully) smaller collection of
--   binomial variables.</li>
--   <li>Because they are generally just containers for parameters, they
--   can be easily serialized to persistent storage or read from
--   user-supplied configurations (eg, initialization data for a
--   simulation).</li>
--   <li>If a type additionally implements the <a>CDF</a> subclass, which
--   extends <a>Distribution</a> with a cumulative density function, an
--   arbitrary random variable <tt>x</tt> can be tested against the
--   distribution by testing <tt>fmap (cdf dist) x</tt> for
--   uniformity.</li>
--   </ul>
--   
--   On the other hand, most <a>Distribution</a>s will not be closed under
--   all the same operations as <a>RVar</a> (which, being a monad, has a
--   fully turing-complete internal computational model). The sum of two
--   uniformly-distributed variables, for example, is not uniformly
--   distributed. To support general composition, the <a>Distribution</a>
--   class defines a function <a>rvar</a> to construct the more-abstract
--   and more-composable <a>RVar</a> representation of a random variable.
class Distribution d t where rvar = rvarT rvarT d = lift (rvar d)
rvar :: Distribution d t => d t -> RVar t
rvarT :: Distribution d t => d t -> RVarT n t
class Distribution d t => CDF d t
cdf :: CDF d t => d t -> t -> Double
class Distribution d t => PDF d t where pdf d = exp . logPdf d logPdf d = log . pdf d
pdf :: PDF d t => d t -> t -> Double
logPdf :: PDF d t => d t -> t -> Double

-- | A typeclass allowing <a>Distribution</a>s and <a>RVar</a>s to be
--   sampled. Both may also be sampled via <a>runRVar</a> or
--   <a>runRVarT</a>, but I find it psychologically pleasing to be able to
--   sample both using this function, as they are two separate abstractions
--   for one base concept: a random variable.
class Sampleable d m t
sampleFrom :: (Sampleable d m t, RandomSource m s) => s -> d t -> m t

-- | Sample a random variable using the default source of entropy for the
--   monad in which the sampling occurs.
sample :: (Sampleable d m t, MonadRandom m) => d t -> m t

-- | Sample a random variable in a "functional" style. Typical
--   instantiations of <tt>s</tt> are <tt>System.Random.StdGen</tt> or
--   <tt>System.Random.Mersenne.Pure64.PureMT</tt>.
sampleState :: (Sampleable d (State s) t, MonadRandom (State s)) => d t -> s -> (t, s)

-- | Sample a random variable in a "semi-functional" style. Typical
--   instantiations of <tt>s</tt> are <tt>System.Random.StdGen</tt> or
--   <tt>System.Random.Mersenne.Pure64.PureMT</tt>.
sampleStateT :: (Sampleable d (StateT s m) t, MonadRandom (StateT s m)) => d t -> s -> m (t, s)

-- | A definition of a uniform distribution over the type <tt>t</tt>. See
--   also <a>uniform</a>.
data Uniform t

-- | A uniform distribution defined by a lower and upper range bound. For
--   <a>Integral</a> and <a>Enum</a> types, the range is inclusive. For
--   <a>Fractional</a> types the range includes the lower bound but not the
--   upper.
Uniform :: !t -> !t -> Uniform t
uniform :: Distribution Uniform a => a -> a -> RVar a
uniformT :: Distribution Uniform a => a -> a -> RVarT m a

-- | A name for the "standard" uniform distribution over the type
--   <tt>t</tt>, if one exists. See also <a>stdUniform</a>.
--   
--   For <a>Integral</a> and <a>Enum</a> types that are also
--   <a>Bounded</a>, this is the uniform distribution over the full range
--   of the type. For un-<a>Bounded</a> <a>Integral</a> types this is not
--   defined. For <a>Fractional</a> types this is a random variable in the
--   range [0,1) (that is, 0 to 1 including 0 but not including 1).
data StdUniform t
StdUniform :: StdUniform t

-- | Get a "standard" uniformly distributed variable. For integral types,
--   this means uniformly distributed over the full range of the type
--   (there is no support for <a>Integer</a>). For fractional types, this
--   means uniformly distributed on the interval [0,1).
stdUniform :: Distribution StdUniform a => RVar a

-- | Get a "standard" uniformly distributed process. For integral types,
--   this means uniformly distributed over the full range of the type
--   (there is no support for <a>Integer</a>). For fractional types, this
--   means uniformly distributed on the interval [0,1).
stdUniformT :: Distribution StdUniform a => RVarT m a

-- | A specification of a normal distribution over the type <tt>a</tt>.
data Normal a

-- | The "standard" normal distribution - mean 0, stddev 1
StdNormal :: Normal a

-- | <tt>Normal m s</tt> is a normal distribution with mean <tt>m</tt> and
--   stddev <tt>sd</tt>.
Normal :: a -> a -> Normal a

-- | <tt>normal m s</tt> is a random variable with distribution
--   <tt><a>Normal</a> m s</tt>.
normal :: Distribution Normal a => a -> a -> RVar a

-- | <a>stdNormal</a> is a normal variable with distribution
--   <a>StdNormal</a>.
stdNormal :: Distribution Normal a => RVar a

-- | <tt>normalT m s</tt> is a random process with distribution
--   <tt><a>Normal</a> m s</tt>.
normalT :: Distribution Normal a => a -> a -> RVarT m a

-- | <a>stdNormalT</a> is a normal process with distribution
--   <a>StdNormal</a>.
stdNormalT :: Distribution Normal a => RVarT m a
data Gamma a
Gamma :: a -> a -> Gamma a
gamma :: Distribution Gamma a => a -> a -> RVar a
gammaT :: Distribution Gamma a => a -> a -> RVarT m a

-- | A typeclass for monads with a chosen source of entropy. For example,
--   <tt>RVar</tt> is such a monad - the source from which it is
--   (eventually) sampled is the only source from which a random variable
--   is permitted to draw, so when directly requesting entropy for a random
--   variable these functions are used.
--   
--   Minimum implementation is either the internal <a>getRandomPrim</a> or
--   all other functions. Additionally, this class's interface is subject
--   to extension at any time, so it is very, very strongly recommended
--   that the <tt>monadRandom</tt> Template Haskell function be used to
--   implement this function rather than directly implementing it. That
--   function takes care of choosing default implementations for any
--   missing functions; as long as at least one function is implemented, it
--   will derive sensible implementations of all others.
--   
--   To use <tt>monadRandom</tt>, just wrap your instance declaration as
--   follows (and enable the TemplateHaskell and GADTs language
--   extensions):
--   
--   <pre>
--   $(monadRandom [d|
--           instance MonadRandom FooM where
--               getRandomDouble = return pi
--               getRandomWord16 = return 4
--               {- etc... -}
--       |])
--   </pre>
class Monad m => MonadRandom (m :: * -> *)

-- | A source of entropy which can be used in the given monad.
--   
--   See also <a>MonadRandom</a>.
--   
--   Minimum implementation is either the internal <a>getRandomPrimFrom</a>
--   or all other functions. Additionally, this class's interface is
--   subject to extension at any time, so it is very, very strongly
--   recommended that the <tt>randomSource</tt> Template Haskell function
--   be used to implement this function rather than directly implementing
--   it. That function takes care of choosing default implementations for
--   any missing functions; as long as at least one function is
--   implemented, it will derive sensible implementations of all others.
--   
--   To use <tt>randomSource</tt>, just wrap your instance declaration as
--   follows (and enable the TemplateHaskell, MultiParamTypeClasses and
--   GADTs language extensions, as well as any others required by your
--   instances, such as FlexibleInstances):
--   
--   <pre>
--   $(randomSource [d|
--           instance RandomSource FooM Bar where
--               {- at least one RandomSource function... -}
--       |])
--   </pre>
class Monad m => RandomSource (m :: * -> *) s

-- | A token representing the "standard" entropy source in a
--   <a>MonadRandom</a> monad. Its sole purpose is to make the following
--   true (when the types check):
--   
--   <pre>
--   runRVar x StdRandom === sampleRVar
--   </pre>
data StdRandom :: *
StdRandom :: StdRandom

-- | A random variable returning an arbitrary element of the given list.
--   Every element has equal probability of being chosen. Because it is a
--   pure <a>RVar</a> it has no memory - that is, it "draws with
--   replacement."
randomElement :: [a] -> RVar a

-- | A random variable that returns the given list in an arbitrary shuffled
--   order. Every ordering of the list has equal probability.
shuffle :: [a] -> RVar [a]

-- | A random variable that shuffles a list of a known length (or a list
--   prefix of the specified length). Useful for shuffling large lists when
--   the length is known in advance. Avoids needing to traverse the list to
--   discover its length. Each ordering has equal probability.
shuffleN :: Int -> [a] -> RVar [a]

-- | A random variable that selects N arbitrary elements of a list of known
--   length M.
shuffleNofM :: Int -> Int -> [a] -> RVar [a]

module Data.Random.Distribution.Pareto
pareto :: Distribution Pareto a => a -> a -> RVar a
paretoT :: Distribution Pareto a => a -> a -> RVarT m a
data Pareto a
Pareto :: !a -> !a -> Pareto a
instance (Real a, Distribution Pareto a) => CDF Pareto a
instance (Floating a, Distribution StdUniform a) => Distribution Pareto a
