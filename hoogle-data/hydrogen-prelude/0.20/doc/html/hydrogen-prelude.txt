-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydrogen Prelude
--   
@package hydrogen-prelude
@version 0.20

module Hydrogen.Prelude
(.&) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
(.|) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
(.^) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)

-- | This is the pure functional matching operator. If the target cannot be
--   produced then some empty result will be returned. If there is an error
--   in processing, then <a>error</a> will be called.
(=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target

-- | This is the monadic matching operator. If a single match fails, then
--   <a>fail</a> will be called.
(=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target

-- | <pre>
--   flip (<a>$</a>)
--   </pre>
(|>) :: a -> (a -> b) -> b
($$) :: (a -> b -> z) -> (a, b) -> z
($$$) :: (a -> b -> c -> z) -> (a, b, c) -> z
($$$$) :: (a -> b -> c -> d -> z) -> (a, b, c, d) -> z
($$$$$) :: (a -> b -> c -> d -> e -> z) -> (a, b, c, d, e) -> z
(<$$>) :: Functor f => (a -> b -> z) -> f (a, b) -> f z
(<$$$>) :: Functor f => (a -> b -> c -> z) -> f (a, b, c) -> f z
(<$$$$>) :: Functor f => (a -> b -> c -> d -> z) -> f (a, b, c, d) -> f z
(<$$$$$>) :: Functor f => (a -> b -> c -> d -> e -> z) -> f (a, b, c, d, e) -> f z
uuidFromString :: String -> Maybe UUID

-- | Produces a random V4 UUID (alias for <a>nextRandom</a>).
randomUUID :: IO UUID

-- | Returns the head of the list or the default value.
safeHead :: a -> [a] -> a
safeHeadAndTail :: a -> [a] -> (a, [a])
safeHeadAndTail2 :: a -> a -> [a] -> (a, a, [a])

-- | Applies a bunch of functions on a given value, returns the first
--   result that is not Nothing (or <a>Nothing</a> if no <a>Just</a> value
--   was produced).
firstJust :: [a -> Maybe b] -> a -> Maybe b
uncurry3 :: (a -> b -> c -> z) -> (a, b, c) -> z
uncurry4 :: (a -> b -> c -> d -> z) -> (a, b, c, d) -> z
uncurry5 :: (a -> b -> c -> d -> e -> z) -> (a, b, c, d, e) -> z

-- | map as it should be: <a>fmap</a>.
map :: Functor f => (a -> b) -> f a -> f b

-- | The UUID type. A <a>Random</a> instance is provided which produces
--   version 4 UUIDs as specified in RFC 4122. The <a>Storable</a> and
--   <a>Binary</a> instances are compatible with RFC 4122, storing the
--   fields in network order as 16 bytes.
data UUID :: *

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString :: *
type LazyByteString = ByteString

-- | If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (<tt>ghc &gt;=
--   7.2.1</tt>), the <a>put</a> and <a>get</a> methods will have default
--   generic implementations.
--   
--   To use this option, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>Serialize</a> instance for it
--   without giving a definition for <a>put</a> and <a>get</a>.
class Serialize t

-- | Encode a value using binary serialization to a strict ByteString.
encode :: Serialize a => a -> ByteString

-- | Encode a value using binary serialization to a lazy ByteString.
encodeLazy :: Serialize a => a -> LazyByteString

-- | Decode a value from a strict ByteString, reconstructing the original
--   structure.
decode :: Serialize a => ByteString -> Either String a

-- | Decode a value from a lazy ByteString, reconstructing the original
--   structure.
decodeLazy :: Serialize a => LazyByteString -> Either String a

-- | The <a>Binary</a> class provides <a>put</a> and <a>get</a>, methods to
--   encode and decode a Haskell value to a lazy <a>ByteString</a>. It
--   mirrors the <a>Read</a> and <a>Show</a> classes for textual
--   representation of Haskell types, and is suitable for serialising
--   Haskell values to disk, over the network.
--   
--   For decoding and generating simple external binary formats (e.g. C
--   structures), Binary may be used, but in general is not suitable for
--   complex protocols. Instead use the <a>Put</a> and <a>Get</a>
--   primitives directly.
--   
--   Instances of Binary should satisfy the following property:
--   
--   <pre>
--   decode . encode == id
--   </pre>
--   
--   That is, the <a>get</a> and <a>put</a> methods should be the inverse
--   of each other. A range of instances are provided for basic Haskell
--   types.
class Binary t

-- | Encode a value using binary serialisation to a lazy ByteString.
binaryEncode :: Binary a => a -> LazyByteString

-- | Decode a value from a lazy ByteString, reconstructing the original
--   structure.
binaryDecode :: Binary a => LazyByteString -> a

-- | Lazily serialise a value to a file.
binaryEncodeFile :: Binary a => FilePath -> a -> IO ()

-- | Decode a value from a file. In case of errors, error will be called
--   with the error message.
binaryDecodeFile :: Binary a => FilePath -> IO a

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a
type List a = [a]

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *
data MultiMap k v :: * -> * -> *

-- | General-purpose finite sequences.
data Seq a :: * -> *

-- | A set of values <tt>a</tt>.
data Set a :: * -> *
data ShowBox
class TMap a where type family Component x type family Transform x
tmap :: TMap a => (Component a -> b) -> a -> Transform ((Component a -> b) -> a)
class Has a where type family HasKey a type family HasValue a
(!) :: Has a => a -> HasKey a -> HasValue a
class Container a where type family Contained a
(?) :: Container a => a -> Contained a -> Bool
class Default a
def :: Default a => a

-- | A shorthand for <a>undefined</a>.
__ :: a
instance Generic ZonedTime
instance Generic UniversalTime
instance Generic TimeOfDay
instance Generic TimeZone
instance Generic LocalTime
instance Generic Day
instance Eq ZonedTime
instance Datatype D1ZonedTime
instance Constructor C1_0ZonedTime
instance Selector S1_0_0ZonedTime
instance Selector S1_0_1ZonedTime
instance Datatype D1UniversalTime
instance Constructor C1_0UniversalTime
instance Selector S1_0_0UniversalTime
instance Datatype D1TimeOfDay
instance Constructor C1_0TimeOfDay
instance Selector S1_0_0TimeOfDay
instance Selector S1_0_1TimeOfDay
instance Selector S1_0_2TimeOfDay
instance Datatype D1TimeZone
instance Constructor C1_0TimeZone
instance Selector S1_0_0TimeZone
instance Selector S1_0_1TimeZone
instance Selector S1_0_2TimeZone
instance Datatype D1LocalTime
instance Constructor C1_0LocalTime
instance Selector S1_0_0LocalTime
instance Selector S1_0_1LocalTime
instance Datatype D1Day
instance Constructor C1_0Day
instance Selector S1_0_0Day
instance Default (Maybe a)
instance Default [a]
instance Default Bool
instance Default Integer
instance Default Word64
instance Default Word32
instance Default Word16
instance Default Word8
instance Default Int64
instance Default Int32
instance Default Int16
instance Default Int8
instance Default Int
instance Ord k => Container (MultiMap k v)
instance Ord k => Container (Map k v)
instance Eq a => Container (Seq a)
instance Eq a => Container [a]
instance Ord a => Container (Set a)
instance Ord k => Has (MultiMap k v)
instance Ix i => Has (Array i e)
instance Eq k => Has [(k, v)]
instance Ord k => Has (Map k v)
instance TMap (Seq a)
instance TMap (MultiMap k v)
instance TMap (Map k v)
instance TMap [a]
instance TMap (a, a, a, a)
instance TMap (a, a, a)
instance TMap (a, a)
instance Show ShowBox
instance Serialize UUID
instance Binary (Fixed E12)
instance Serialize (Fixed E12)
instance Binary ZonedTime
instance Serialize ZonedTime
instance Binary TimeOfDay
instance Serialize TimeOfDay
instance Binary LocalTime
instance Serialize LocalTime
instance Binary Version
instance Serialize Version
instance Binary UniversalTime
instance Serialize UniversalTime
instance Binary TimeZone
instance Serialize TimeZone
instance Binary Day
instance Serialize Day

module Hydrogen.Prelude.IO
hGetContents' :: Handle -> IO String
getContents' :: IO String
readFile' :: FilePath -> IO String
interact' :: (String -> String) -> IO ()

module Hydrogen.Prelude.Network

module Hydrogen.Prelude.System
findFilesRecursively :: (FilePath -> IO Bool) -> FilePath -> IO [FilePath]
findFilesRecursivelyWithContext :: (c -> FilePath -> [FilePath] -> IO c) -> (FilePath -> IO Bool) -> c -> FilePath -> IO [(FilePath, c)]
escapeFileName :: String -> String
unescapeFileName :: String -> Maybe String
