-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package socket-io
@version 1.3.3

module Network.SocketIO

-- | This computation initializes a Socket.IO server and <i>returns</i> a
--   computation that you should call whenever a request comes in to the
--   <tt><i>socket.io</i></tt> path. For example, in a Snap application,
--   you might do:
--   
--   <pre>
--   handler &lt;- initialize snapAPI mkRoutes
--   quickHttpServe $ route [("/socket.io", handler)]
--   </pre>
--   
--   The second argument to this function is an action to build up the
--   routing table, which determines what happens when clients emit events.
--   It is also an action that is called every time a client connects, so
--   you can mutate state by taking advantage of the <a>MonadIO</a>
--   instance. You can build a routing table by using the convenience
--   <a>on</a> family of functions.
initialize :: MonadIO m => ServerAPI m -> StateT RoutingTable (ReaderT Socket m) a -> IO (m ())

-- | A per-connection routing table. This table determines what actions to
--   invoke when events are received.
data RoutingTable

-- | When an event with a given name is received, and its argument can be
--   decoded by a <a>FromJSON</a> instance, run the associated function
--   after decoding the event argument. Expects exactly one event argument.
on :: (MonadState RoutingTable m, OnArgs f (EventHandler a)) => Text -> f -> m ()

-- | When an event is received with a given name and no arguments, run the
--   associated <a>EventHandler</a>.

-- | <i>Deprecated: Use Network.SocketIO.on instead</i>
on_ :: MonadState RoutingTable m => Text -> EventHandler a -> m ()

-- | When an event with a given name is received, call the associated
--   function with the array of JSON arguments.
onJSON :: MonadState RoutingTable m => Text -> (Array -> EventHandler a) -> m ()

-- | Run the given IO action when a client disconnects, along with any
--   other previously register disconnect handlers.
appendDisconnectHandler :: MonadState RoutingTable m => EventHandler () -> m ()
type EventHandler a = ReaderT Socket IO a

-- | Emit an event and argument data to a <a>Socket</a>. If called from
--   within <a>on</a>, this will be the client that emitted the original
--   event.
emit :: (ToJSON a, MonadReader Socket m, MonadIO m) => Text -> a -> m ()

-- | Emit an event with a specific array of <tt>JSON</tt> arguments.
emitJSON :: (MonadReader Socket m, MonadIO m) => Text -> Array -> m ()

-- | Emit an event to specific <a>Socket</a>.
emitTo :: (ToJSON a, MonadIO m) => Socket -> Text -> a -> m ()

-- | Emit an event with a specific array of <tt>JSON</tt> arguments to a
--   specific <a>Socket</a>.
emitJSONTo :: MonadIO m => Socket -> Text -> Array -> m ()

-- | Broadcast an event to all <i>other</i> <a>Socket</a>s.
broadcast :: (ToJSON a, MonadReader Socket m, MonadIO m) => Text -> a -> m ()

-- | Broadcast an event with an array of JSON arguments to all <i>other</i>
--   <a>Socket</a>s.
broadcastJSON :: (MonadReader Socket m, MonadIO m) => Text -> Array -> m ()

-- | A Socket.IO socket (not to be confused with an Engine.IO
--   <a>Socket</a>).
data Socket

-- | Retrieve the Engine.IO <a>SocketId</a> for a <a>Socket</a>.
socketId :: Socket -> SocketId

-- | Retrieve the Engine.IO <a>Socket</a> that underlies this Socket.IO
--   socket. This is a fairly low-level operation - you should take care
--   when reading or writing directly to this socket, as it is possible to
--   break invariants that Socket.io is expecting.
engineIOSocket :: Socket -> Socket
data PacketType
Connect :: PacketType
Disconnect :: PacketType
Event :: PacketType
Ack :: PacketType
Error :: PacketType
BinaryEvent :: PacketType
BinaryAck :: PacketType
parsePacketType :: Parser PacketType
encodePacketType :: PacketType -> Builder
data Packet
Packet :: !PacketType -> !(Maybe Int) -> !Text -> !(Maybe Int) -> !(Maybe Value) -> Packet
parsePacket :: Parser Packet
encodePacket :: Packet -> Builder
instance Bounded PacketType
instance Enum PacketType
instance Eq PacketType
instance Read PacketType
instance Show PacketType
instance Eq Packet
instance Show Packet
instance (FromJSON a, OnArgs b r) => OnArgs (a -> b) r
instance OnArgs a a
instance Ord Socket
instance Eq Socket
