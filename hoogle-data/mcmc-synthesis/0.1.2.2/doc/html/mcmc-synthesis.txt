-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | MCMC applied to probabilistic program synthesis
--   
--   A simple implementation of the ideas from <a>Stochastic
--   Superoptimization</a> which uses a variant of Markov Chain Monte Carlo
--   (MCMC) to synthesize programs based on a set of test cases.
--   <a>Stochastic Superoptimization</a>:
--   <a>http://cs.stanford.edu/people/eschkufz/research/asplos291-schkufza.pdf</a>
@package mcmc-synthesis
@version 0.1.2.2

module Language.Synthesis.Distribution

-- | Represents a discrete probability distribution.
data Distr a
Distr :: (forall g. RandomGen g => Rand g a) -> (a -> Double) -> Distr a

-- | Sample a random item from the distribution.
sample :: Distr a -> forall g. RandomGen g => Rand g a

-- | Compute the log probability of a given value.
logProbability :: Distr a -> a -> Double

-- | Negative infinity, the log of 0 probability.
negativeInfinity :: Double

-- | Computes (log . sum . map exp), with more numeric precision.
sumByLogs :: [Double] -> Double

-- | A distribution from an (item, weight) list.
categorical :: Eq a => [(a, Double)] -> Distr a

-- | Uniform distribution.
uniform :: Eq a => [a] -> Distr a

-- | A distribution over some integral type, inclusively between the 2
--   values.
randInt :: (Integral i, Random i) => (i, i) -> Distr i

-- | Generate n independent draws from a distribution.
replicate :: Int -> Distr a -> Distr [a]

-- | Given (distribution, weight) pairs, mix the distributions.
mix :: [(Distr a, Double)] -> Distr a

-- | A distribution containing a single item.
constant :: a -> Distr a

module Language.Synthesis.MCMC

-- | Use the Metropolis-Hastings algorithm to sample a list of values.
mhList :: RandomGen g => a -> (a -> (b, Double)) -> (a -> Distr a) -> Rand g [(a, b, Double)]

module Language.Synthesis.Mutations

-- | Given a distribution over instructions, mutates a random instruction.
mutateInstruction :: Eq a => Distr a -> Mutation [a]
mutateInstructionAt :: Eq a => Distr a -> Int -> [a] -> Distr [a]
mutateInstructionsAt :: Eq a => Distr a -> [Int] -> [a] -> Distr [a]

-- | Swaps 2 random instructions.
swapInstructions :: Eq a => Mutation [a]

-- | Given (mutation, weight) list, mixes the mutations.
mix :: [(Mutation a, Double)] -> Mutation a
type Mutation a = a -> Distr a

module Language.Synthesis.Synthesis

-- | A score is anything that can be mapped to a double.
class Score a
toScore :: Score a => a -> Double
type Mutation a = a -> Distr a

-- | Given a prior distribution, score function, mutation distribution,
--   generate a list of (program, score) values through MH sampling.
synthesizeMhList :: (Score s, RandomGen gen) => Problem p s -> Rand gen [(p, s)]

-- | Given (value, score) pairs, return a running list of the best pair so
--   far.
runningBest :: Ord s => [(a, s)] -> [(a, s)]

-- | This type specifies which program to synthesize. It comes with a
--   specification, which is a program that already works, some inputs and
--   a distance function.
data Problem p s
Problem :: (p -> s) -> Distr p -> Mutation p -> Problem p s
score :: Problem p s -> p -> s
prior :: Problem p s -> Distr p
jump :: Problem p s -> Mutation p
instance Score Double
