-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Comprehensive GLPK linear programming bindings
--   
--   Friendly interface to GLPK's linear programming and mixed integer
--   programming features. Intended for easy extensibility, with a general,
--   pure-Haskell representation of linear programs. Also includes usefully
--   general algebraic structures. To design a linear programming problem,
--   use <a>Control.Monad.LPMonad</a> to construct the constraints and
--   specifications. Linear functions are essentially specified as
--   <tt>Data.Map</tt>s from variables to their coefficients, and functions
--   for manipulating them are available in
--   <a>Data.LinearProgram.LinExpr</a>. Then <a>Data.LinearProgram.GLPK</a>
--   provides facilities for using the GLPK solver system on your problem,
--   with a sizable number of options available.
@package glpk-hs
@version 0.3.4

module Control.Monad.LPMonad.Supply.Class

-- | A class implemented by monads that can supply values of type
--   <tt>s</tt>. Minimal implementation: <a>supplyNew</a> or
--   <a>supplyN</a>.
class Monad m => MonadSupply s m | m -> s where supplyNew = liftM head (supplyN 1) supplyN n = replicateM n supplyNew
supplyNew :: MonadSupply s m => m s
supplyN :: MonadSupply s m => Int -> m [s]
instance MonadSupply x m => MonadSupply x (StateT s m)
instance MonadSupply x m => MonadSupply x (ContT r m)
instance (MonadSupply x m, Monoid w) => MonadSupply x (WriterT w m)
instance (MonadSupply x m, Monoid w) => MonadSupply x (WriterT w m)
instance (Error e, MonadSupply x m) => MonadSupply x (ErrorT e m)
instance MonadSupply x m => MonadSupply x (ReaderT r m)
instance MonadSupply x m => MonadSupply x (StateT s m)

module Control.Monad.LPMonad.Supply

-- | A type suitable for use as a linear program variable.
newtype Var
Var :: Int -> Var
varId :: Var -> Int

-- | A monad capable of supplying unique variables.
type VSupply = VSupplyT Identity

-- | A monad transformer capable of supplying unique variables.
data VSupplyT m a
runVSupply :: VSupply a -> a
runVSupplyT :: Monad m => VSupplyT m a -> m a
instance Eq Var
instance Ord Var
instance Enum Var
instance Functor m => Functor (VSupplyT m)
instance Monad m => Monad (VSupplyT m)
instance MonadPlus m => MonadPlus (VSupplyT m)
instance MonadTrans VSupplyT
instance MonadReader r m => MonadReader r (VSupplyT m)
instance MonadWriter w m => MonadWriter w (VSupplyT m)
instance MonadCont m => MonadCont (VSupplyT m)
instance MonadIO m => MonadIO (VSupplyT m)
instance MonadFix m => MonadFix (VSupplyT m)
instance MonadError e m => MonadError e (VSupplyT m)
instance Monad m => MonadSupply Var (VSupplyT m)
instance MonadState s m => MonadState s (VSupplyT m)
instance Read Var
instance Show Var


-- | Common library for algebraic structures. Has the advantage of
--   automatically inferring lots of useful structure, especially in the
--   writing of linear programs. For example, here are several ways of
--   writing <tt>3 x - 4 y + z</tt>:
--   
--   <pre>
--   gsum [3 *&amp; x, (-4) *^ var y, var z]
--   linCombination [(3, x), (-4, y), (1, z)]
--   3 *&amp; x ^-^ 4 *&amp; y ^+^ var z
--   </pre>
--   
--   In addition, if we have two functions <tt>f</tt> and <tt>g</tt>, we
--   can construct linear combinations of those functions, using exactly
--   the same syntax. Moreover, we can multiply functions with
--   <a>Double</a> coefficients by <a>Rational</a> values successfully.
--   This module is intended to offer as much generality as possible
--   without getting in your way.
module Data.Algebra

-- | The algebraic structure of a group. Written additively. Required
--   functions: <a>zero</a> and (<a>^-^</a> or (<a>^+^</a> and
--   <a>neg</a>)).
class Group g where a ^+^ b = a ^-^ neg b a ^-^ b = a ^+^ neg b neg a = zero ^-^ a
zero :: Group g => g
(^+^) :: Group g => g -> g -> g
(^-^) :: Group g => g -> g -> g
neg :: Group g => g -> g

-- | The algebraic structure of a unital ring. Assumes that the additive
--   operation forms an abelian group, that the multiplication operation
--   forms a group, and that multiplication distributes.
class Group r => Ring r
one :: Ring r => r
(*#) :: Ring r => r -> r -> r
class Ring f => Field f where inv x = one /# x a /# b = a *# inv b
inv :: Field f => f -> f
(/#) :: Field f => f -> f -> f

-- | The algebraic structure of a module. A vector space is a module with
--   coefficients in a field.
class (Ring r, Group m) => Module r m
(*^) :: Module r m => r -> m -> m
class (Module f v, Field f) => VectorSpace f v
type Poly = []

-- | Returns the polynomial <tt>p(x) = x</tt>.
varPoly :: Ring r => Poly r

-- | A way of forming a ring from functions. See
--   <a>http://en.wikipedia.org/wiki/Group_ring</a>.
type GroupRing r g = Map g r

-- | <tt><a>LinFunc</a> v c</tt> is a linear combination of variables of
--   type <tt>v</tt> with coefficients from <tt>c</tt>. Formally, this is
--   the free <tt>c</tt>-module on <tt>v</tt>.
type LinFunc = Map

-- | Does a summation over the elements of a group.
gsum :: Group g => [g] -> g

-- | Given a collection of vectors and scaling coefficients, returns this
--   linear combination.
combination :: Module r m => [(r, m)] -> m

-- | Substitution into a polynomial.
evalPoly :: (Module r m, Ring m) => Poly r -> m -> m

-- | Given a variable <tt>v</tt>, returns the function equivalent to
--   <tt>v</tt>.
var :: (Ord v, Ring c) => v -> LinFunc v c

-- | Equivalent to <tt><tt>vsum</tt> . <a>map</a> <a>var</a></tt>.
varSum :: (Ord v, Ring c) => [v] -> LinFunc v c

-- | <tt>c <a>*&amp;</a> v</tt> is equivalent to <tt>c <a>*^</a> <a>var</a>
--   v</tt>.
(*&) :: (Ord v, Ring c) => c -> v -> LinFunc v c

-- | Given a set of basic variables and coefficients, returns the linear
--   combination obtained by summing.
linCombination :: (Ord v, Num r) => [(r, v)] -> LinFunc v r

module Data.LinearProgram.LinExpr
data LinExpr v c
LinExpr :: (LinFunc v c) -> c -> LinExpr v c
solve :: (Ord v, Eq c, VectorSpace c c) => [(LinFunc v c, c)] -> Maybe (Map v (LinExpr v c))
substituteExpr :: (Ord v, Module c c) => v -> LinExpr v c -> LinExpr v c -> LinExpr v c
simplifyExpr :: (Ord v, Module c c) => LinExpr v c -> Map v (LinExpr v c) -> LinExpr v c
constTerm :: LinExpr v c -> c
coeffTerm :: LinExpr v c -> LinFunc v c
funcToExpr :: Group c => LinFunc v c -> LinExpr v c
instance (Eq v, Eq c) => Eq (LinExpr v c)
instance (Ord v, Read v, Read c) => Read (LinExpr v c)
instance (Show v, Show c) => Show (LinExpr v c)
instance (Ord v, Module r c) => Module r (LinExpr v c)
instance (Ord v, Group c) => Group (LinExpr v c)


-- | Contains sufficient tools to represent linear programming problems in
--   Haskell. In the future, if linkings to other linear programming
--   libraries are made, this will be common to them all.
module Data.LinearProgram.Common

-- | Representation of a linear constraint on the variables, possibly
--   labeled. The function may be bounded both above and below.
data Constraint v c
Constr :: (Maybe String) -> (LinFunc v c) -> (Bounds c) -> Constraint v c

-- | A mapping from variables to their types. Variables not mentioned are
--   assumed to be continuous,
type VarTypes v = Map v VarKind

-- | An objective function for a linear program.
type ObjectiveFunc = LinFunc

-- | A mapping from variables to their boundaries. Variables not mentioned
--   are assumed to be free.
type VarBounds v c = Map v (Bounds c)

-- | The specification of a linear programming problem with variables in
--   <tt>v</tt> and coefficients/constants in <tt>c</tt>. Note: the
--   <a>Read</a> and <a>Show</a> implementations do not correspond to any
--   particular linear program specification format.
data LP v c
LP :: Direction -> ObjectiveFunc v c -> [Constraint v c] -> VarBounds v c -> VarTypes v -> LP v c
direction :: LP v c -> Direction
objective :: LP v c -> ObjectiveFunc v c
constraints :: LP v c -> [Constraint v c]
varBounds :: LP v c -> VarBounds v c
varTypes :: LP v c -> VarTypes v

-- | Applies the specified function to the variables in the linear program.
--   If multiple variables in the original program are mapped to the same
--   variable in the new program, in general, we set those variables to all
--   be equal, as follows.
--   
--   <ul>
--   <li>In linear functions, including the objective function and the
--   constraints, coefficients will be added together. For instance, if
--   <tt>v1,v2</tt> are mapped to the same variable <tt>v'</tt>, then a
--   linear function of the form <tt>c1 *&amp; v1 ^+^ c2 *&amp; v2</tt>
--   will be mapped to <tt>(c1 ^+^ c2) *&amp; v'</tt>.</li>
--   <li>In variable bounds, bounds will be combined. An error will be
--   thrown if the bounds are mutually contradictory.</li>
--   <li>In variable kinds, the most restrictive kind will be
--   retained.</li>
--   </ul>
mapVars :: (Ord v', Ord c, Group c) => (v -> v') -> LP v c -> LP v' c

-- | Applies the specified function to the constants in the linear program.
--   This is only safe for a monotonic function.
mapVals :: (c -> c') -> LP v c -> LP v c'
allVars :: Ord v => LP v c -> Map v ()
data VarKind
ContVar :: VarKind
IntVar :: VarKind
BinVar :: VarKind
data Direction
Min :: Direction
Max :: Direction
data Bounds a
Free :: Bounds a
LBound :: !a -> Bounds a
UBound :: !a -> Bounds a
Equ :: !a -> Bounds a
Bound :: !a -> !a -> Bounds a


-- | Interface between the Haskell representation of a linear programming
--   problem, a value of type <a>LP</a>, and the GLPK solver. The options
--   available to the solver correspond naturally with GLPK's available
--   options, so to find the meaning of any particular option, consult the
--   GLPK documentation.
--   
--   The option of which solver to use -- the general LP solver, which
--   solves a problem over the reals, or the MIP solver, which allows
--   variables to be restricted to integers -- can be made by choosing the
--   appropriate constructor for <a>GLPOpts</a>.
--   
--   The marshalling from Haskell to C is specialized for <a>Int</a>s and
--   <a>Double</a>s, so using those types in your linear program is
--   recommended.
module Data.LinearProgram.GLPK.Solver

-- | Options available for customizing GLPK operations. This also
--   determines which kind of solving is performed -- relaxed LP, or MIP.
data GLPOpts
SimplexOpts :: MsgLev -> !Int -> Bool -> GLPOpts
msgLev :: GLPOpts -> MsgLev
tmLim :: GLPOpts -> !Int
presolve :: GLPOpts -> Bool
MipOpts :: MsgLev -> !Int -> Bool -> BranchingTechnique -> BacktrackTechnique -> Preprocessing -> Bool -> [Cuts] -> !Double -> GLPOpts
msgLev :: GLPOpts -> MsgLev
tmLim :: GLPOpts -> !Int
presolve :: GLPOpts -> Bool
brTech :: GLPOpts -> BranchingTechnique
btTech :: GLPOpts -> BacktrackTechnique
ppTech :: GLPOpts -> Preprocessing
fpHeur :: GLPOpts -> Bool
cuts :: GLPOpts -> [Cuts]
mipGap :: GLPOpts -> !Double
simplexDefaults :: GLPOpts
mipDefaults :: GLPOpts

-- | Solves the linear or mixed integer programming problem. Returns the
--   value of the objective function, and the values of the variables.
glpSolveVars :: (Ord v, Real c) => GLPOpts -> LP v c -> IO (ReturnCode, Maybe (Double, Map v Double))
data RowValue v c
RowVal :: !(Constraint v c) -> !Double -> RowValue v c
row :: RowValue v c -> !(Constraint v c)
rowVal :: RowValue v c -> !Double

-- | Solves the linear or mixed integer programming problem. Returns the
--   value of the objective function, the values of the variables, and the
--   values of any labeled rows.
glpSolveAll :: (Ord v, Real c) => GLPOpts -> LP v c -> IO (ReturnCode, Maybe (Double, Map v Double, [RowValue v c]))
data ReturnCode
Success :: ReturnCode
InvalidBasis :: ReturnCode
SingularMatrix :: ReturnCode
IllConditionedMatrix :: ReturnCode
InvalidBounds :: ReturnCode
SolverFailed :: ReturnCode
ObjLowerLimReached :: ReturnCode
ObjUpperLimReached :: ReturnCode
IterLimReached :: ReturnCode
TimeLimReached :: ReturnCode
NoPrimalFeasible :: ReturnCode
NoDualFeasible :: ReturnCode
RootLPOptMissing :: ReturnCode
SearchTerminated :: ReturnCode
MipGapTolReached :: ReturnCode
NoPrimDualFeasSolution :: ReturnCode
NoConvergence :: ReturnCode
NumericalInstability :: ReturnCode
InvalidData :: ReturnCode
ResultOutOfRange :: ReturnCode
data MsgLev
MsgOff :: MsgLev
MsgErr :: MsgLev
MsgOn :: MsgLev
MsgAll :: MsgLev
data BranchingTechnique
FirstFrac :: BranchingTechnique
LastFrac :: BranchingTechnique
MostFrac :: BranchingTechnique
DrTom :: BranchingTechnique
HybridP :: BranchingTechnique
data BacktrackTechnique
DepthFirst :: BacktrackTechnique
BreadthFirst :: BacktrackTechnique
LocBound :: BacktrackTechnique
ProjHeur :: BacktrackTechnique
data Preprocessing
NoPre :: Preprocessing
RootPre :: Preprocessing
AllPre :: Preprocessing
data Cuts
GMI :: Cuts
MIR :: Cuts
Cov :: Cuts
Clq :: Cuts


-- | Bindings to the file I/O functions from GLPK, on the CPLEX LP file
--   format.
module Data.LinearProgram.GLPK.IO

-- | Read a linear program from a file in CPLEX LP format. Warning: this
--   will not necessarily succeed on all files generated by <a>writeLP</a>,
--   as variable names may be changed.
readLP :: (Ord v, Read v, Fractional c) => FilePath -> IO (LP v c)

-- | Read a linear program from a file in CPLEX LP format.
readLP' :: FilePath -> IO (LP String Double)

-- | Write a linear program to a file in CPLEX LP format.
writeLP :: (Ord v, Show v, Real c) => FilePath -> LP v c -> IO ()

module Data.LinearProgram.GLPK


-- | A collection of operations that can be used to specify linear
--   programming in a simple, monadic way. It is not too difficult to
--   construct <a>LP</a> values explicitly, but this module may help
--   simplify and modularize the construction of the linear program, for
--   example separating different families of constraints in the problem
--   specification.
--   
--   Many of these functions should be executed in either the
--   <tt><a>LPM</a> v c</tt> or the <tt><a>LPT</a> v c <a>IO</a></tt>
--   monad. If you wish to generate new variables on an ad-hoc basis,
--   rather than supplying your own variable type, use the <a>VSupply</a>
--   or <a>VSupplyT</a> monads in your transformer stack, as in
--   <tt><a>LPT</a> <a>Var</a> c <a>VSupply</a></tt> or <tt><a>LPT</a>
--   <a>Var</a> c (<a>VSupplyT</a> <a>IO</a>)</tt>. To generate new
--   variables, use <a>supplyNew</a> or <a>supplyN</a>.
module Control.Monad.LPMonad

-- | A simple monad for constructing linear programs. This library is
--   intended to be able to link to a variety of different linear
--   programming implementations.
type LPM v c = LPT v c Identity

-- | A simple monad transformer for constructing linear programs in an
--   arbitrary monad.
type LPT v c = StateT (LP v c)
runLPM :: (Ord v, Group c) => LPM v c a -> (a, LP v c)
runLPT :: (Ord v, Group c) => LPT v c m a -> m (a, LP v c)

-- | Constructs a linear programming problem.
execLPM :: (Ord v, Group c) => LPM v c a -> LP v c

-- | Constructs a linear programming problem in the specified monad.
execLPT :: (Ord v, Group c, Monad m) => LPT v c m a -> m (LP v c)

-- | Runs the specified operation in the linear programming monad.
evalLPM :: (Ord v, Group c) => LPM v c a -> a

-- | Runs the specified operation in the linear programming monad
--   transformer.
evalLPT :: (Ord v, Group c, Monad m) => LPT v c m a -> m a

-- | Sets the optimization direction of the linear program: maximization or
--   minimization.
setDirection :: MonadState (LP v c) m => Direction -> m ()

-- | Sets the objective function, overwriting the previous objective
--   function.
setObjective :: MonadState (LP v c) m => LinFunc v c -> m ()

-- | Adds this function to the objective function.
addObjective :: (Ord v, Group c, MonadState (LP v c) m) => LinFunc v c -> m ()

-- | Adds this function to the objective function, with the specified
--   weight. Equivalent to <tt><a>addObjective</a> (wt <a>*^</a> obj)</tt>.
addWeightedObjective :: (Ord v, Module r c, MonadState (LP v c) m) => r -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables. So,
--   for example,
--   
--   <pre>
--   equal (f ^+^ g) h
--   </pre>
--   
--   constrains the value of <tt>h</tt> to be equal to the value of
--   <tt>f</tt> plus the value of <tt>g</tt>.
leq :: (Ord v, Group c, MonadState (LP v c) m) => LinFunc v c -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables. So,
--   for example,
--   
--   <pre>
--   equal (f ^+^ g) h
--   </pre>
--   
--   constrains the value of <tt>h</tt> to be equal to the value of
--   <tt>f</tt> plus the value of <tt>g</tt>.
equal :: (Ord v, Group c, MonadState (LP v c) m) => LinFunc v c -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables. So,
--   for example,
--   
--   <pre>
--   equal (f ^+^ g) h
--   </pre>
--   
--   constrains the value of <tt>h</tt> to be equal to the value of
--   <tt>f</tt> plus the value of <tt>g</tt>.
geq :: (Ord v, Group c, MonadState (LP v c) m) => LinFunc v c -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables,
--   with a label on the constraint.
leq' :: (Ord v, Group c, MonadState (LP v c) m) => String -> LinFunc v c -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables,
--   with a label on the constraint.
equal' :: (Ord v, Group c, MonadState (LP v c) m) => String -> LinFunc v c -> LinFunc v c -> m ()

-- | Specifies the relationship between two functions in the variables,
--   with a label on the constraint.
geq' :: (Ord v, Group c, MonadState (LP v c) m) => String -> LinFunc v c -> LinFunc v c -> m ()

-- | Sets a constraint on a linear function in the variables.
leqTo :: MonadState (LP v c) m => LinFunc v c -> c -> m ()

-- | Sets a constraint on a linear function in the variables.
equalTo :: MonadState (LP v c) m => LinFunc v c -> c -> m ()

-- | Sets a constraint on a linear function in the variables.
geqTo :: MonadState (LP v c) m => LinFunc v c -> c -> m ()

-- | The most general form of an unlabeled constraint.
constrain :: MonadState (LP v c) m => LinFunc v c -> Bounds c -> m ()

-- | Sets a labeled constraint on a linear function in the variables.
leqTo' :: MonadState (LP v c) m => String -> LinFunc v c -> c -> m ()

-- | Sets a labeled constraint on a linear function in the variables.
equalTo' :: MonadState (LP v c) m => String -> LinFunc v c -> c -> m ()

-- | Sets a labeled constraint on a linear function in the variables.
geqTo' :: MonadState (LP v c) m => String -> LinFunc v c -> c -> m ()

-- | The most general form of a labeled constraint.
constrain' :: MonadState (LP v c) m => String -> LinFunc v c -> Bounds c -> m ()

-- | Sets a constraint on the value of a variable. If you constrain a
--   variable more than once, the constraints will be combined. If the
--   constraints are mutually contradictory, an error will be generated.
--   This is more efficient than adding an equivalent function constraint.
varLeq :: (Ord v, Ord c, MonadState (LP v c) m) => v -> c -> m ()

-- | Sets a constraint on the value of a variable. If you constrain a
--   variable more than once, the constraints will be combined. If the
--   constraints are mutually contradictory, an error will be generated.
--   This is more efficient than adding an equivalent function constraint.
varEq :: (Ord v, Ord c, MonadState (LP v c) m) => v -> c -> m ()

-- | Sets a constraint on the value of a variable. If you constrain a
--   variable more than once, the constraints will be combined. If the
--   constraints are mutually contradictory, an error will be generated.
--   This is more efficient than adding an equivalent function constraint.
varGeq :: (Ord v, Ord c, MonadState (LP v c) m) => v -> c -> m ()

-- | Bounds the value of a variable on both sides. If you constrain a
--   variable more than once, the constraints will be combined. If the
--   constraints are mutually contradictory, an error will be generated.
--   This is more efficient than adding an equivalent function constraint.
varBds :: (Ord v, Ord c, MonadState (LP v c) m) => v -> c -> c -> m ()

-- | The most general way to set constraints on a variable. If you
--   constrain a variable more than once, the constraints will be combined.
--   If you combine mutually contradictory constraints, an error will be
--   generated. This is more efficient than creating an equivalent function
--   constraint.
setVarBounds :: (Ord v, Ord c, MonadState (LP v c) m) => v -> Bounds c -> m ()

-- | Sets the kind ('type') of a variable. See <a>VarKind</a>.
setVarKind :: (Ord v, MonadState (LP v c) m) => v -> VarKind -> m ()

-- | Solves the linear program with the default settings in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value and the settings of each variable.
quickSolveMIP :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => m (ReturnCode, Maybe (Double, Map v Double))

-- | Solves the linear program with the default settings in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value and the settings of each variable.
quickSolveLP :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => m (ReturnCode, Maybe (Double, Map v Double))

-- | Solves the linear program with the specified options in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value and the settings of each variable.
glpSolve :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => GLPOpts -> m (ReturnCode, Maybe (Double, Map v Double))

-- | Solves the linear program with the default settings in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value, the settings of each variable, and the value of each
--   constraint/row.
quickSolveMIP' :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => m (ReturnCode, Maybe (Double, Map v Double, [RowValue v c]))

-- | Solves the linear program with the default settings in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value, the settings of each variable, and the value of each
--   constraint/row.
quickSolveLP' :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => m (ReturnCode, Maybe (Double, Map v Double, [RowValue v c]))

-- | Solves the linear program with the specified options in GLPK. Returns
--   the return code, and if the solver was successful, the objective
--   function value, the settings of each variable, and the value of each
--   constraint/row.
glpSolve' :: (Ord v, Real c, MonadState (LP v c) m, MonadIO m) => GLPOpts -> m (ReturnCode, Maybe (Double, Map v Double, [RowValue v c]))

-- | Writes the current linear program to the specified file in CPLEX LP
--   format. (This is a binding to GLPK, not a Haskell implementation of
--   CPLEX.)
writeLPToFile :: (Ord v, Show v, Real c, MonadState (LP v c) m, MonadIO m) => FilePath -> m ()

-- | Reads a linear program from the specified file in CPLEX LP format,
--   overwriting the current linear program. Uses <a>read</a> and
--   <a>realToFrac</a> to translate to the specified type. Warning: this
--   may not work on all files written using <a>writeLPToFile</a>, since
--   variable names may be changed. (This is a binding to GLPK, not a
--   Haskell implementation of CPLEX.)
readLPFromFile :: (Ord v, Read v, Fractional c, MonadState (LP v c) m, MonadIO m) => FilePath -> m ()

-- | Reads a linear program from the specified file in CPLEX LP format,
--   overwriting the current linear program. (This is a binding to GLPK,
--   not a Haskell implementation of CPLEX.)
readLPFromFile' :: (MonadState (LP String Double) m, MonadIO m) => FilePath -> m ()

module Data.LinearProgram
