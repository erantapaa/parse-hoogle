-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Open Sound Control JSON Serialisation
--   
--   hosc-json
@package hosc-json
@version 0.15

module Sound.OSC.Type.JSON.Math
in_range :: (Integral r, Integral n) => r -> r -> n -> Bool
in_int8 :: Integral a => a -> Bool
in_int16 :: Integral a => a -> Bool
in_int32 :: Integral a => a -> Bool
in_int64 :: Integral a => a -> Bool

-- | Is <i>n</i> integral, ie. is <a>denominator</a> <tt>1</tt>.
ratio_is_integral :: Integral n => Ratio n -> Bool

-- | Is <i>n</i> integral, and <a>&lt;=</a> to <i>m</i>.
ratio_is_bounded_integral :: Integral n => n -> Ratio n -> Bool

-- | Is <i>n</i> integral and in range for <a>Int</a>.
ratio_is_int :: Integral n => Ratio n -> Bool

-- | Is <i>n</i> integral and in range for <a>Word8</a>.
ratio_is_word8 :: Integral n => Ratio n -> Bool


-- | Encoding and decoding of OSC types as JSON values.
module Sound.OSC.Type.JSON.Aeson

-- | Encode <a>Value</a> to <a>ByteString</a>.
encode_json :: Value -> ByteString

-- | Decode <a>Value</a> from <a>ByteString</a>.
decode_json :: ByteString -> Maybe Value

-- | All <a>Integral</a> values are packed to <a>Integer</a>.
encode_integer :: Integer -> Value

-- | All <a>Floating</a> values are packed to <a>Double</a>.
encode_double :: Double -> Value

-- | Pack <a>String</a>.
encode_string :: String -> Value

-- | Pack <tt>(key,value)</tt> pair to <tt>JSObject</tt>.
--   
--   <pre>
--   encode_assoc ("a",encode_int 0)
--   </pre>
encode_assoc :: (String, Value) -> Value
encode_list :: [Value] -> Value
decode_str :: Value -> Maybe String
decode_list :: Value -> Maybe [Value]
decode_assoc :: Value -> Maybe (String, Value)
result_maybe :: Result a -> Maybe a
decode_integer :: Value -> Maybe Integer
decode_double :: Value -> Maybe Double
decode_number :: Value -> Maybe (Either Integer Double)
decode_double_err :: Value -> Double
decode_number_err :: Value -> Either Integer Double
decode_word8 :: Value -> Maybe Word8
decode_datum :: Value -> Maybe Datum


-- | Encoding and decoding of OSC types as JSON values.
module Sound.OSC.Type.JSON

-- | The JSON value type.
type Value = Value

-- | <a>String</a> variant of <a>encode_json</a>.
encode_json_str :: Value -> String

-- | <a>String</a> variant of <a>decode_json</a>.
--   
--   <pre>
--   import Sound.OSC.Type.JSON
--   let j = decode_json_str "[\"/n_set\",-1,\"c1\",66]"
--   fmap decode_message j
--   </pre>
decode_json_str :: String -> Maybe Value

-- | JSON numbers are <a>Either</a> <a>Integer</a> or <a>Double</a>.
type Number = Either Integer Double

-- | Encode <a>Number</a>.
encode_number :: Number -> Value

-- | Encode <a>TimeStamp</a> data (<a>Time</a>), ie. the <tt>hosc</tt>
--   real-valued <tt>NRT</tt> representation.
encode_timestamp :: Time -> Value
encode_integral :: Integral n => n -> Value
encode_floating :: (Real n, Floating n) => n -> Value

-- | Encode <a>Blob</a> data (<a>ByteString</a>).
encode_blob :: ByteString -> Value

-- | Encode <a>Midi</a> data (<tt>Word8</tt> tuple).
encode_midi :: MIDI -> Value

-- | <a>Datum</a> encoder. The encoding is shallow, <a>Int</a>,
--   <a>Float</a> and <a>Double</a> are all sent to <a>Number</a>.
--   <a>Blob</a>, <a>TimeStamp</a> and <a>Midi</a> are tagged.
--   
--   <pre>
--   let {t = [(int32 0,"0")
--            ,(int64 0,"0")
--            ,(float 0.0,"0.0")
--            ,(double 0.1,"0.1")
--            ,(string "s","\"s\"")
--            ,(Blob (Data.ByteString.Lazy.pack [0,1]),"{\"blob\":[0,1]}")
--            ,(TimeStamp 0.0,"{\"timestamp\":0.0}")
--            ,(midi (0,1,2,3),"{\"midi\":[0,1,2,3]}")]
--       ;r = map (\(d,s) -&gt; encode_json_str (encode_datum d) == s) t}
--   in all id r == True
--   </pre>
encode_datum :: Datum -> Value

-- | <a>Message</a> encoder, the representation is a flat array of
--   <tt>address</tt> and then arguments.
--   
--   <pre>
--   let m = message "/m" [Int32 0,Float 1,string "s"]
--   in encode_json_str (encode_message m)
--   </pre>
--   
--   <pre>
--   import Sound.SC3
--   encode_json_str (encode_message (n_free [0])) == "[\"/n_free\",0]"
--   </pre>
encode_message :: Message -> Value

-- | <a>Bundle</a> encoder, the representation is a flat array of
--   <tt>#bundle</tt> tag, <a>TimeStamp</a> and then message arrays.
--   
--   <pre>
--   let b = bundle 0 [message "/m" []]
--   in encode_json_str (encode_bundle b)
--   </pre>
--   
--   <pre>
--   let {b = bundle 0 [c_set1 3 4,n_free [0]]
--       ;r = "[\"#bundle\",{\"timestamp\":0.0}" ++
--            ",[\"/c_set\",3,4.0],[\"/n_free\",0]]"}
--   in encode_json_str (encode_bundle b) == r
--   </pre>
encode_bundle :: Bundle -> Value

-- | <a>Packet</a> encoder.
encode_packet :: Packet -> Value

-- | Decode <a>Message</a>.
--   
--   <pre>
--   let m = message "/m" [Int32 1,Float 1]
--   in decode_message (encode_message m) == Just m
--   </pre>
decode_message :: Value -> Maybe Message

-- | Decode <a>Bundle</a>.
--   
--   <pre>
--   let b = bundle 0.0 [message "/m" [Int32 1,Float 1]]
--   in decode_bundle (encode_bundle b) == Just b
--   </pre>
--   
--   <pre>
--   let {b = bundle 0 [c_set1 3 4,n_free [0]]
--       ;j = encode_bundle b}
--   in (b,decode_bundle j)
--   </pre>
decode_bundle :: Value -> Maybe Bundle

-- | Decode <a>Packet</a>.
decode_packet :: Value -> Maybe Packet
