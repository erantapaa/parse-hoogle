-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | app container types and tools
--   
@package appc
@version 0.0.6

module Data.AppContainer.TH

-- | Generates both <a>ToJSON</a> and <a>FromJSON</a> instance declarations
--   for the given data type.
--   
--   This is a convienience function which is equivalent to calling both
--   <a>deriveToJSON</a> and <a>deriveFromJSON</a>.
deriveJSON :: Options -> Name -> Q [Dec]

-- | Generates a <a>ToJSON</a> instance declaration for the given data
--   type.
deriveToJSON :: Options -> Name -> Q [Dec]
deriveJSONOptions :: String -> Options

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where parseJSON (<a>Object</a> v) = Coord
--   <tt>&lt;$&gt;</tt> v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt> v <tt>.:</tt>
--   "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use
--   <tt>mzero</tt> to fail. parseJSON _ = <tt>mzero</tt> @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

module Data.AppContainer.Types
data ImageManifest
ImageManifest :: !Text -> !Version -> ![Label] -> !(Maybe App) -> ![Dependency] -> ImageManifest
imName :: ImageManifest -> !Text
imVersion :: ImageManifest -> !Version
imLabels :: ImageManifest -> ![Label]
imApp :: ImageManifest -> !(Maybe App)
imDependencies :: ImageManifest -> ![Dependency]
data ContainerRuntimeManifest
ContainerRuntimeManifest :: !UUID -> !Version -> ![Image] -> ![Volume] -> ContainerRuntimeManifest
crmUUID :: ContainerRuntimeManifest -> !UUID
crmVersion :: ContainerRuntimeManifest -> !Version
crmImages :: ContainerRuntimeManifest -> ![Image]
crmVolumes :: ContainerRuntimeManifest -> ![Volume]
data App
App :: ![Text] -> !Text -> !Text -> ![EventHandler] -> !(Map Text Text) -> ![MountPoint] -> ![Port] -> !Text -> App
appExec :: App -> ![Text]
appUser :: App -> !Text
appGroup :: App -> !Text
appEventHandlers :: App -> ![EventHandler]
appEnvironment :: App -> !(Map Text Text)
appMountPoints :: App -> ![MountPoint]
appPorts :: App -> ![Port]
appWorkingDirectory :: App -> !Text
data Dependency
Dependency :: !Text -> ![Label] -> !Text -> !Text -> Dependency
depName :: Dependency -> !Text
depLabels :: Dependency -> ![Label]
depHash :: Dependency -> !Text
depRoot :: Dependency -> !Text
data EventHandler
EventHandler :: !Text -> ![Text] -> EventHandler
ehName :: EventHandler -> !Text
ehExec :: EventHandler -> ![Text]
data Image
Image :: !Text -> !Text -> Image
imageApp :: Image -> !Text
imageImageID :: Image -> !Text
data Label
Label :: !Text -> !Text -> Label
labelName :: Label -> !Text
labelVal :: Label -> !Text
data MountPoint
MountPoint :: !Text -> !Text -> !Bool -> MountPoint
mpName :: MountPoint -> !Text
mpPath :: MountPoint -> !Text
mpReadOnly :: MountPoint -> !Bool
data Port
Port :: !Text -> !Text -> !Int -> !Bool -> Port
portName :: Port -> !Text
portProtocol :: Port -> !Text
portPort :: Port -> !Int
portSocketActivated :: Port -> !Bool
data Volume
Volume :: ![Text] -> !VolumeSource -> Volume
volFulfills :: Volume -> ![Text]
volSource :: Volume -> !VolumeSource
data VolumeSource
EmptyVolumeSource :: VolumeSource
HostVolumeSource :: HostVolume -> VolumeSource
data HostVolume
HostVolume :: !Text -> !Bool -> HostVolume
hvSource :: HostVolume -> !Text
hvReadOnly :: HostVolume -> !Bool
instance FromJSON Image
instance ToJSON Image
instance ToJSON Port
instance ToJSON MountPoint
instance FromJSON Label
instance ToJSON Label
instance FromJSON EventHandler
instance ToJSON EventHandler
instance FromJSON Dependency
instance ToJSON Dependency
instance ToJSON App
instance Show Label
instance Eq Label
instance Show Image
instance Eq Image
instance Show EventHandler
instance Eq EventHandler
instance Show MountPoint
instance Eq MountPoint
instance Show HostVolume
instance Eq HostVolume
instance Show VolumeSource
instance Eq VolumeSource
instance Show Volume
instance Eq Volume
instance Show ContainerRuntimeManifest
instance Eq ContainerRuntimeManifest
instance Show Port
instance Eq Port
instance Show App
instance Eq App
instance Show Dependency
instance Eq Dependency
instance Show ImageManifest
instance Eq ImageManifest
instance FromJSON UUID
instance ToJSON UUID
instance FromJSON Port
instance FromJSON HostVolume
instance FromJSON VolumeSource
instance ToJSON Volume
instance FromJSON Volume
instance FromJSON MountPoint
instance FromJSON App
instance ToJSON ContainerRuntimeManifest
instance FromJSON ContainerRuntimeManifest
instance ToJSON ImageManifest
instance FromJSON ImageManifest

module Data.AppContainer
verifyImageManifest :: String -> IO Bool
verifyContainerRuntimeManifest :: String -> IO Bool
buildImage :: String -> String -> IO ()
