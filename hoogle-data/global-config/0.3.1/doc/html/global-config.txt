-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Global mutable configuration
--   
--   <tt>Data.Global.Config</tt> provides brain-free pattern to work with
--   global configurations. Use wisely.
@package global-config
@version 0.3.1


-- | Main problem in haskell is "creepy" enviroment variables passed to all
--   functions. It's safe but tedious.
--   
--   <a>GlobalConfig</a> trying to solve this problem and propose common
--   pattern to work with configurations. It has been tested and proved to
--   be very useful in production.
--   
--   <pre>
--   {-# LANGUAGE DeriveDataTypeable #-}
--   
--   module Main (main) where
--   
--   import Data.Typeable (Typeable)
--   import Data.Default
--   import Data.Global.Config
--   
--   data Config = Config { configInt :: Int, configBool :: Bool }
--      deriving (Show, Typeable)
--   
--   instance Default Config
--      def = Config 0 False
--   
--   instance GlobalConfig Config where
--      onSetConfig = print
--      
--   main :: IO ()
--   main = do
--      -- try to read unitialized config
--      c1 &lt;- getConfig 
--      -- Config {configInt=0, configBool=False}
--      
--      -- set config and read it
--      setConfig $ Config 1 True
--      -- Config {configInt=1, configBool=True}
--      c2 &lt;- getConfig
--      print (c1 :: Config)
--      -- Config {configInt=1, configBool=True}
--   </pre>
module Data.Global.Config

-- | Global configuration class
class (Default a, Typeable a) => GlobalConfig a where setConfig e = do { liftIO $ stubConfig `writeIORef` e; onSetConfig e } onSetConfig _ = return () getConfig = liftIO $ readIORef stubConfig stubConfig = declareIORef "" def
setConfig :: (GlobalConfig a, MonadIO m) => a -> m ()
onSetConfig :: (GlobalConfig a, MonadIO m) => a -> m ()
getConfig :: (GlobalConfig a, MonadIO m) => m a
