-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An IDL compiler for Haskell
--   
--   HaskellDirect is an IDL compiler for Haskell, which offers a helping
--   hand to the Haskell programmer that wants to better interact with and
--   reuse external code.
--   
--   Interfacing Haskell code to external code involves the conversion of
--   values between the Haskell world and the outside, as data
--   representations and details of how memory is managed, are worlds apart
--   at times. Manually writing the boilerplate code that takes care of
--   this conversion is about as exciting as watching grass grow and, as a
--   result, error prone.
--   
--   Using an Interface Definition Language (IDL) as basis, HaskellDirect
--   automates the generation of such impedance matching code, generating
--   all the necessary marshaling code for you.
--   
--   With IDL, the functionality provided by a programming interface is
--   specified in a programming language neutral framework. The
--   HaskellDirect IDL compiler converts this specification into a set of
--   method stubs. Depending on how the compiler is invoked, these stubs
--   can be used to:
--   
--   <ul>
--   <li>Call upon external functions from within Haskell, HaskellDirect
--   creates bindings to external (C-callable) libraries.</li>
--   <li>Let external code call upon Haskell functions, HaskellDirect
--   creates foreign/external language interfaces to Haskell
--   libraries.</li>
--   <li>Call COM (Microsoft's Component Object Model) methods from
--   Haskell, HaskellDirect helps you use Microsoft COM components from
--   within Haskell. The generated stubs can be used with Hugs98 or
--   GHC.</li>
--   <li>Create COM method wrappers, HaskellDirect packages up Haskell code
--   as COM components.</li>
--   </ul>
--   
--   The HaskellDirect IDL compiler currently groks both the OSF DCE
--   dialect of IDL (including the various extensions introduced by the
--   Microsoft IDL compiler) and the OMG IIOP/CORBA dialect. (Only the
--   former can be used for describing COM interfaces.)
@package hdirect
@version 0.21.0

module FiniteMap
data FiniteMap key elt
emptyFM :: FiniteMap key elt
unitFM :: key -> elt -> FiniteMap key elt
listToFM :: Ord key => [(key, elt)] -> FiniteMap key elt
addToFM :: Ord key => FiniteMap key elt -> key -> elt -> FiniteMap key elt
addToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> key -> elt -> FiniteMap key elt
addListToFM :: Ord key => FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
addListToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
delFromFM :: Ord key => FiniteMap key elt -> key -> FiniteMap key elt
delListFromFM :: Ord key => FiniteMap key elt -> [key] -> FiniteMap key elt
plusFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
plusFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
minusFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
foldFM :: (key -> elt -> a -> a) -> a -> FiniteMap key elt -> a
intersectFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
intersectFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
mapFM :: (key -> elt1 -> elt2) -> FiniteMap key elt1 -> FiniteMap key elt2
filterFM :: Ord key => (key -> elt -> Bool) -> FiniteMap key elt -> FiniteMap key elt
mapMaybeFM :: Ord key => (key -> elt1 -> Maybe elt2) -> FiniteMap key elt1 -> FiniteMap key elt2
sizeFM :: FiniteMap key elt -> Int
isEmptyFM :: FiniteMap key elt -> Bool
elemFM :: Ord key => key -> FiniteMap key elt -> Bool
lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt -> key -> elt
fmToList :: FiniteMap key elt -> [(key, elt)]
keysFM :: FiniteMap key elt -> [key]
eltsFM :: FiniteMap key elt -> [elt]
instance (Eq key, Eq elt) => Eq (FiniteMap key elt)

module SymbolTable
data SymbolTable elt
mkSymbolTable :: [(String, tok)] -> SymbolTable tok
newContext :: SymbolTable tok -> SymbolTable tok
lookupSymbol :: SymbolTable tok -> String -> Maybe tok
lookupType :: SymbolTable tok -> String -> Maybe tok
addType :: SymbolTable tok -> String -> tok -> SymbolTable tok
addKeyword :: SymbolTable tok -> String -> tok -> SymbolTable tok
combineSyms :: SymbolTable tok -> SymbolTable tok -> SymbolTable tok

module NameSupply
data NSM a
getNewName :: NSM String
withNewName :: String -> NSM a -> NSM a
getNewNames :: Int -> NSM [String]
mapNSM :: (a -> b) -> NSM a -> NSM b
runNS :: NSM a -> [String] -> a
instance Monad NSM

module NativeInfo
fLOAT_SIZE :: Int
fLOAT_ALIGN_MODULUS :: Int
dOUBLE_SIZE :: Int
dOUBLE_ALIGN_MODULUS :: Int
sHORT_SIZE :: Int
sHORT_ALIGN_MODULUS :: Int
lONG_SIZE :: Int
lONG_ALIGN_MODULUS :: Int
lONGLONG_SIZE :: Int
lONGLONG_ALIGN_MODULUS :: Int
uSHORT_SIZE :: Int
uSHORT_ALIGN_MODULUS :: Int
uLONG_SIZE :: Int
uLONG_ALIGN_MODULUS :: Int
uLONGLONG_SIZE :: Int
uLONGLONG_ALIGN_MODULUS :: Int
uCHAR_SIZE :: Int
uCHAR_ALIGN_MODULUS :: Int
sCHAR_SIZE :: Int
sCHAR_ALIGN_MODULUS :: Int
dATA_PTR_SIZE :: Int
dATA_PTR_ALIGN_MODULUS :: Int
bSTR_SIZE :: Int
bSTR_ALIGN_MODULUS :: Int
sAFEARRAY_SIZE :: Int
sAFEARRAY_ALIGN_MODULUS :: Int
sTRUCT_ALIGN_MODULUS :: Int

module Digraph
stronglyConnComp :: Ord key => [(node, key, [key])] -> [SCC node]
stronglyConnCompR :: Ord key => [(node, key, [key])] -> [SCC (node, key, [key])]
data SCC vertex
AcyclicSCC :: vertex -> SCC vertex
CyclicSCC :: [vertex] -> SCC vertex
type Graph = Table [Vertex]
type Vertex = Int
graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
buildG :: Bounds -> [Edge] -> Graph
transposeG :: Graph -> Graph
reverseE :: Graph -> [Edge]
outdegree :: Graph -> Table Int
indegree :: Graph -> Table Int
data Tree a
Node :: a -> (Forest a) -> Tree a
type Forest a = [Tree a]
showTree :: Show a => Tree a -> String
showForest :: Show a => Forest a -> String
dfs :: Graph -> [Vertex] -> Forest Vertex
dff :: Graph -> Forest Vertex
topSort :: Graph -> [Vertex]
components :: Graph -> Forest Vertex
scc :: Graph -> Forest Vertex
back :: Graph -> Table Int -> Graph
cross :: Graph -> Table Int -> Table Int -> Graph
forward :: Graph -> Graph -> Table Int -> Graph
reachable :: Graph -> Vertex -> [Vertex]
path :: Graph -> Vertex -> Vertex -> Bool
bcc :: Graph -> Forest [Vertex]
instance Show a => Show (Tree a)

module Env
type Env a b = FiniteMap a b
newEnv :: Env a b
addToEnv :: Ord a => Env a b -> a -> b -> Env a b
addToEnv_C :: Ord a => (b -> b -> b) -> Env a b -> a -> b -> Env a b
replaceElt :: Ord a => Env a b -> a -> b -> Env a b
delFromEnv :: Ord a => Env a b -> a -> Env a b
addListToEnv :: Ord a => Env a b -> [(a, b)] -> Env a b
addListToEnv_C :: Ord a => (b -> b -> b) -> Env a b -> [(a, b)] -> Env a b
lookupEnv :: Ord a => Env a b -> a -> Maybe b
envToList :: Env a b -> [(a, b)]
mapEnv :: (a -> b -> c) -> Env a b -> Env a c
mapMaybeEnv :: Ord a => (a -> b -> Maybe c) -> Env a b -> Env a c
unionEnvs :: Ord a => [Env a b] -> Env a b

module PP
type PPDoc a = a -> Doc
showPPDoc :: PPDoc a -> a -> String
getPPEnv :: (a -> PPDoc a) -> PPDoc a
setPPEnv :: a -> PPDoc a -> PPDoc b
vsep :: [PPDoc a] -> PPDoc a
joinedBy :: [PPDoc a] -> (PPDoc a -> PPDoc a -> PPDoc a) -> PPDoc a
ppDecls :: [PPDoc a] -> PPDoc a
withSemi :: PPDoc a -> PPDoc a
ppTuple :: [PPDoc a] -> PPDoc a
ppTupleVert :: [PPDoc a] -> PPDoc a
ppList :: [PPDoc a] -> PPDoc a
ppListVert :: [PPDoc a] -> PPDoc a
empty :: PPDoc a
isEmpty :: PPDoc a -> Bool
nest :: Int -> PPDoc a -> PPDoc a
text :: String -> PPDoc a
ptext :: String -> PPDoc a
char :: Char -> PPDoc a
int :: Int -> PPDoc a
integer :: Integer -> PPDoc a
float :: Float -> PPDoc a
double :: Double -> PPDoc a
rational :: Rational -> PPDoc a
parens :: PPDoc a -> PPDoc a
brackets :: PPDoc a -> PPDoc a
braces :: PPDoc a -> PPDoc a
quotes :: PPDoc a -> PPDoc a
doubleQuotes :: PPDoc a -> PPDoc a
semi :: PPDoc a
comma :: PPDoc a
colon :: PPDoc a
space :: PPDoc a
equals :: PPDoc a
lparen :: PPDoc a
rparen :: PPDoc a
lbrack :: PPDoc a
rbrack :: PPDoc a
lbrace :: PPDoc a
rbrace :: PPDoc a
(<>) :: PPDoc a -> PPDoc a -> PPDoc a
(<+>) :: PPDoc a -> PPDoc a -> PPDoc a
hcat :: [PPDoc a] -> PPDoc a
hsep :: [PPDoc a] -> PPDoc a
($$) :: PPDoc a -> PPDoc a -> PPDoc a
($+$) :: PPDoc a -> PPDoc a -> PPDoc a
vcat :: [PPDoc a] -> PPDoc a
sep :: [PPDoc a] -> PPDoc a
cat :: [PPDoc a] -> PPDoc a
fsep :: [PPDoc a] -> PPDoc a
fcat :: [PPDoc a] -> PPDoc a
hang :: PPDoc a -> Int -> PPDoc a -> PPDoc a
punctuate :: PPDoc a -> [PPDoc a] -> [PPDoc a]
render :: PPDoc a -> a -> String

module SrcLoc
data SrcLoc
mkSrcLoc :: String -> Int -> SrcLoc
modSrcLoc :: SrcLoc -> String
dummySrcLoc :: SrcLoc
incSrcLineNo :: SrcLoc -> SrcLoc
ppSrcLoc :: SrcLoc -> PPDoc a
instance Show SrcLoc

module Bag
data Bag a
emptyBag :: Bag a
unitBag :: a -> Bag a
unionBags :: Bag a -> Bag a -> Bag a
unionManyBags :: [Bag a] -> Bag a
mapBag :: (a -> b) -> Bag a -> Bag b
elemBag :: Eq a => a -> Bag a -> Bool
filterBag :: (a -> Bool) -> Bag a -> Bag a
partitionBag :: (a -> Bool) -> Bag a -> (Bag a, Bag a)
concatBag :: Bag (Bag a) -> Bag a
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
isEmptyBag :: Bag a -> Bool
consBag :: a -> Bag a -> Bag a
snocBag :: Bag a -> a -> Bag a
listToBag :: [a] -> Bag a
bagToList :: Bag a -> [a]

module Utils
showOct :: Integral a => a -> ShowS
showHex :: Integral a => a -> ShowS
mapFromMb :: b -> (a -> b) -> Maybe a -> b
mapMb :: (a -> b) -> Maybe a -> Maybe b
mapMbM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
concMaybe :: Maybe a -> Maybe a -> Maybe a
toMaybe :: (a -> Bool) -> a -> Maybe a
split :: Eq a => a -> [a] -> [[a]]
splitLast :: Eq a => [a] -> [a] -> ([a], [a])
splitLastBy :: ([a] -> Bool) -> ([a] -> [a]) -> [a] -> ([a], [a])
prefix :: Eq a => [a] -> [a] -> Maybe [a]
traceIf :: Bool -> String -> a -> a
elemBy :: (a -> Bool) -> [a] -> Bool
mapUnzip :: (a -> (b, c)) -> [a] -> ([b], [c])
diff :: Num a => [a] -> [a]
deEscapeString :: String -> String
(#) :: a -> (a -> b) -> b
dropSuffix :: String -> String

-- | When called, <a>trace</a> outputs the string in its first argument,
--   before returning the second argument as its result. The <a>trace</a>
--   function is not referentially transparent, and should only be used for
--   debugging, or for monitoring execution. Some implementations of
--   <a>trace</a> may decorate the string that's output to indicate that
--   you're tracing. The function is implemented on top of
--   <a>putTraceMsg</a>.
trace :: String -> a -> a
tryOpen :: Bool -> [FilePath] -> [String] -> FilePath -> IO (Maybe FilePath)
basename :: String -> String
splitdir :: String -> (String, String)
prefixDir :: String -> String -> String
hdirect_root :: String
bailIf :: Bool -> a -> a -> a
decons :: [a] -> ([a], a)
safe_init :: [a] -> [a]
snoc :: [a] -> a -> [a]
mapAccumLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])
notNull :: [a] -> Bool

module GetOpt
data Opt a b
Opt :: ([String] -> a -> Maybe ([String], a, b)) -> Opt a b
pushArg :: String -> Opt a ()
updState :: (a -> a) -> Opt a ()
failed :: Opt a b
catchOpt :: Opt a b -> Opt a b -> Opt a b
prefixMatch :: String -> Opt a String
prefixed :: String -> Opt a b -> Opt a b
matches :: (String -> Bool) -> (String -> Opt a b) -> Opt a b
flag :: String -> (a -> a) -> Opt a ()
flags :: [(String, a -> a)] -> Opt a ()
opts :: [Opt a b] -> Opt a b
orOpt :: Opt a b -> Opt a b -> Opt a b
thenOpt :: Opt a b -> Opt a b -> Opt a b
toggle :: String -> String -> String -> (Bool -> a -> a) -> Opt a ()
toggles :: String -> String -> [(String, Bool -> a -> a)] -> Opt a ()
prefixArg :: String -> (String -> a -> a) -> Opt a ()
optionArg :: String -> (String -> Opt a b) -> Opt a b
optionWithOptArg :: String -> Opt a b -> Opt a b
string :: String -> Opt a ()
(-=) :: String -> a -> Opt [a] ()
(-==) :: String -> (String -> a) -> Opt [a] ()
(-===) :: String -> (String -> a) -> Opt [a] ()
(-====) :: String -> (Maybe String -> a) -> Opt [a] ()
(-?) :: (String -> Bool) -> (String -> a) -> Opt [a] ()
getOpts :: Opt a b -> a -> [String] -> ([String], a)
instance MonadPlus (Opt s)
instance Functor (Opt s)
instance Monad (Opt s)

module Version
pkg_name :: String
pkg_version :: String

module Opts
ihc_opts :: [Option]
the_ihc_opts :: IORef [String]
theOpts :: [String]
expandDerivedArgs :: [String] -> [String]
defaultArgs :: [String]
derivedArgs :: [(String, [String])]
autoOptions :: [String]
registryOptions :: [(String, [String])]
set_ihc_opts :: [String] -> IO ()
dumpDesugar :: Bool
dumpRenamer :: Bool
dumpAbstractH :: Bool
dumpIDL :: Bool
optTargetGhc :: Bool
optCpp :: Bool
optNoOutput :: Bool
optGreenCard :: Bool
optHelp :: Bool
optDebug :: Bool
optVerbose :: Bool
optGenHeader :: Bool
optVersion :: Bool
optNoExportList :: Bool
optNoModuleHeader :: Bool
optExportListWithTySig :: Bool
optCoalesceIsomorphicMethods :: Bool
optExpandInheritedInterface :: Bool
optNoDllName :: Bool
optUseDispIDs :: Bool
optIntsEverywhere :: Bool
optIntAsWord :: Bool
optKeepHRESULT :: Bool
optConvertImportLibs :: Bool
optSortDefns :: Bool
optWinnowDefns :: Bool
optShowPasses :: Bool
optDon'tGenBinaryComInterfaces :: Bool
optOnlyRemoveDefns :: Bool
optQualInstanceMethods :: Bool
optOutPointersAreRefs :: Bool
optNoDerefRefs :: Bool
optIgnoreSourceIfaces :: Bool
optNoEnumMagic :: Bool
optEnumsAsFlags :: Bool
optIntIsInt :: Bool
optGenNumInstance :: Bool
optGenBitsInstance :: Bool
optNukeEmptyStructs :: Bool
optShortHeader :: Bool
optIntCoercesInPrelude :: Bool
optLongLongIsInteger :: Bool
optOneModulePerInterface :: Bool
optShowIDLInComments :: Bool
optServer :: Bool
optUnparamedInterfacePointers :: Bool
optSubtypedInterfacePointers :: Bool
optNoImports :: Bool
optNoQualNames :: Bool
optNoImportLists :: Bool
optNoLibIds :: Bool
optNoDependentArgs :: Bool
optAppendIfaceName :: Bool
optDeepMarshall :: Bool
optPrefixIfaceName :: Bool
optExportAbstractly :: Bool
optNoMangleIfaceNames :: Bool
optDualVtbl :: Bool
optCompilingDceIDL :: Bool
optIgnoreDispInterfaces :: Bool
optCompilingOmgIDL :: Bool
optCompilingMsIDL :: Bool
optIgnoreHelpstring :: Bool
optTlb :: Bool
optHaskellToC :: Bool
optHugs :: Bool
optSkel :: Bool
optUnsafeCalls :: Bool
optIgnoreImpLibs :: Bool
optIgnoreHiddenMeths :: Bool
optIgnoreRestrictedMeths :: Bool
optH1_4 :: Bool
optNoVariantInstance :: Bool
optVariantInstance :: Bool
optOptionalAsMaybe :: Bool
optPatternAsLambda :: Bool
optClassicNameMangling :: Bool
optOutputTlb :: Bool
optOverloadVariant :: Bool
optNoOverloadVariant :: Bool
optGenDefs :: Bool
optExplicitIPointer :: Bool
optAnonTLB :: Bool
optGenCStubs :: Bool
optJNI :: Bool
optCorba :: Bool
optUnwrapSingletonStructs :: Bool
optInlineTypes :: Bool
optCharPtrIsString :: Bool
optExcludeSysIncludes :: Bool
optIncludeAsImport :: Bool
optNoWarnMissingMode :: Bool
optVoidTydefIsAbstract :: Bool
optSmartEnums :: Bool
optNoShareFIDs :: Bool
optUseStdDispatch :: Bool
optUseIIDIs :: Bool
optDon'tTidyDefns :: Bool
optNoWideStrings :: Bool
optCom :: Bool
optIgnoreMethsUpto :: Maybe String
optPointerDefault :: Maybe String
optOutputDumpTo :: Maybe String
optOutputModules :: [String]
optOutputHTo :: [String]
optOutputTlbTo :: [String]
optFiles :: [String]
optAsfs :: [String]
optUseAsfs :: Bool
optOFiles :: [String]
optODirs :: [String]
optincludedirs :: [String]
optinclude_cppdirs :: [String]
optcpp_defines :: [String]
optIncludeCHeaders :: [String]
optIncludeHeaders :: [String]
version :: String
name :: String
version_msg :: String
usage_msg :: String -> String
options :: Opt [Option] ()
data Option
DumpVersion :: Option
DumpHelp :: Option
DumpDebug :: Option
DumpVerbose :: Option
DumpDesugar :: Option
DumpRenamer :: Option
DumpIDL :: Option
DumpAbsH :: Option
OptNoOutput :: Option
OptCpp :: Option
OptGreenCard :: Option
OptHugs :: Option
OptH1_4 :: Option
OptTargetGhc :: Option
OptGenHeader :: Option
OptSkel :: Option
OptExportTySig :: Option
OptNoExportList :: Option
OptEnumsAsFlags :: Option
OptNoModuleHeader :: Option
OptNoExpandInherit :: Option
OptNoDllName :: Option
OptCoalesceIsomorphicMethods :: Option
OptShowIDLInComments :: Option
OptKeepHResult :: Option
OptUseDispIDs :: Option
OptServer :: Option
OptOneModulePerInterface :: Option
OptUnParam'dIPointers :: Option
OptSubTypedInterfacePointers :: Option
OptNoImportLists :: Option
OptNoImports :: Option
OptNoQualNames :: Option
OptNoDependentArgs :: Option
OptNoLibraryIds :: Option
OptPrefixIfaceName :: Option
OptAppendIfaceName :: Option
OptShallowMarshall :: Option
OptNoMangleIfaceNames :: Option
OptExportAbstractly :: Option
OptIgnoreDispInterfaces :: Option
OptDualVtbl :: Option
OptCompilingDceIDL :: Option
OptCompilingMsIDL :: Option
OptCompilingOmgIDL :: Option
OptHaskellToC :: Option
OptUseInts :: Option
OptIgnore :: Option
OptIntAsWord :: Option
OptShowPasses :: Option
OptConvertImportLibs :: Option
OptIgnoreHelpstring :: Option
OptSortDefns :: Option
OptWinnowDefns :: Option
OptOnlyRemoveDefns :: Option
OptDon'tGenBinaryComInterfaces :: Option
OptOutPointersAreNotRefs :: Option
OptNoDerefRefs :: Option
OptQualInstanceMethods :: Option
OptTLB :: Option
OptUnsafeCalls :: Option
OptOutputTlb :: Option
OptIgnoreHiddenMeths :: Option
OptIgnoreRestrictedMeths :: Option
OptIgnoreImpLibs :: Option
OptOptionalAsMaybe :: Option
OptNoVariantInstance :: Option
OptVariantInstance :: Option
OptPatternAsLambda :: Option
OptGenDefs :: Option
OptGenCStubs :: Option
OptOverloadVariant :: Option
OptNoOverloadVariant :: Option
OptExpIPointer :: Option
OptAnonTLB :: Option
OptIntIsInt :: Option
OptIntCoercesInPrelude :: Option
OptNoEnumMagic :: Option
OptGenBitsInstance :: Option
OptGenNumInstance :: Option
OptLongLongIsInteger :: Option
OptUnwrapSingletonStructs :: Option
OptIgnoreSourceIfaces :: Option
OptNukeEmptyStructs :: Option
OptShortHeader :: Option
OptJNI :: Option
OptCorba :: Option
OptCharPtrIsString :: Option
OptInlineTypes :: Option
OptPointerDefault :: String -> Option
OptOutputDump :: String -> Option
OptIncludeAsImport :: Option
OptExcludeSysIncludes :: Option
OptVoidTydefIsAbstract :: Option
OptNoWarnMissingMode :: Option
OptDon'tTidyDefns :: Option
OptNoShareFIDs :: Option
OptSmartEnums :: Option
OptUseStdDispatch :: Option
OptUseIIDIs :: Option
OptNoWideStrings :: Option
OptIgnoreMethsUpto :: String -> Option
OptOutputModule :: String -> Option
OptClassicNameMangling :: Option
OptOutputTlbTo :: String -> Option
OptOutputHTo :: String -> Option
OptCppDefine :: String -> Option
OptIncludeDirs :: String -> Option
OptIncludeHeader :: String -> Option
OptIncludeCHeader :: String -> Option
OptIncludeCppDirs :: String -> Option
OptOutputFile :: String -> Option
OptOutputDir :: String -> Option
OptAsf :: String -> Option
OptFile :: String -> Option
instance Eq Option

module Literal
data Literal
IntegerLit :: IntegerLit -> Literal
StringLit :: String -> Literal
TypeConst :: String -> Literal
WStringLit :: String -> Literal
CharLit :: Char -> Literal
WCharLit :: Char -> Literal
FixedPtLit :: Rational -> Literal
FloatingLit :: (String, Double) -> Literal
BooleanLit :: Bool -> Literal
NullLit :: Literal
GuidLit :: [String] -> Literal
LitLit :: String -> Literal
data IntegerLit
ILit :: Int -> Integer -> IntegerLit
iLit :: Integral a => a -> Literal
iLitToIntegral :: Integral a => IntegerLit -> a
iLitToInteger :: IntegerLit -> Integer
ppLit :: Literal -> PPDoc a
ppILit :: IntegerLit -> PPDoc a
litToString :: Literal -> String
instance Show IntegerLit
instance Eq IntegerLit
instance Show Literal
instance Eq Literal

module BasicTypes
type Name = String
data QualName
qName :: QualName -> Name
qOrigName :: QualName -> Name
qModule :: QualName -> Maybe Name
qDefModule :: QualName -> Maybe Name
mkQualName :: Maybe String -> String -> QualName
toQualName :: String -> QualName
prefixQName :: String -> QualName -> QualName
prefixAppQName :: String -> QualName -> QualName
setOrigQName :: Name -> QualName -> QualName
type ScopedName = [String]
type Inherit = [Name]
type GUID = [String]
data Size
Short :: Size
Natural :: Size
Long :: Size
LongLong :: Size
data CallConv
Stdcall :: CallConv
Pascal :: CallConv
Cdecl :: CallConv
Fastcall :: CallConv
data BinaryOp
Xor :: BinaryOp
Or :: BinaryOp
And :: BinaryOp
Shift :: ShiftDir -> BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Div :: BinaryOp
Mod :: BinaryOp
Mul :: BinaryOp
LogAnd :: BinaryOp
LogOr :: BinaryOp
Gt :: BinaryOp
Ge :: BinaryOp
Eq :: BinaryOp
Le :: BinaryOp
Lt :: BinaryOp
Ne :: BinaryOp
data UnaryOp
Minus :: UnaryOp
Plus :: UnaryOp
Not :: UnaryOp
Negate :: UnaryOp
Deref :: UnaryOp
data ShiftDir
L :: ShiftDir
R :: ShiftDir
data Qualifier
Const :: Qualifier
Volatile :: Qualifier
data PointerType
Ptr :: PointerType
Ref :: PointerType
Unique :: PointerType
data ParamDir
In :: ParamDir
Out :: ParamDir
InOut :: ParamDir
isInOut :: ParamDir -> Bool
ppBinaryOp :: BinaryOp -> PPDoc a
ppUnaryOp :: UnaryOp -> PPDoc a
ppQualifier :: Qualifier -> PPDoc a
ppSize :: Size -> PPDoc a
ppCallConv :: Bool -> CallConv -> PPDoc a
ppName :: Name -> PPDoc a
ppQualName :: QualName -> PPDoc a
ppDirection :: ParamDir -> PPDoc a
strToCallConv :: String -> Maybe CallConv
data EnumKind
EnumProgression :: Int -> Int -> EnumKind
EnumFlags :: Int -> EnumKind
Unclassified :: EnumKind
classifyProgression :: [Int32] -> EnumKind
instance Show EnumKind
instance Eq EnumKind
instance Eq ParamDir
instance Show ParamDir
instance Eq PointerType
instance Show PointerType
instance Show Qualifier
instance Eq Qualifier
instance Eq ShiftDir
instance Show ShiftDir
instance Eq UnaryOp
instance Show UnaryOp
instance Eq BinaryOp
instance Show BinaryOp
instance Eq CallConv
instance Show CallConv
instance Show Size
instance Eq Size
instance Eq QualName
instance Show QualName

module AbstractH
data HTopDecl
HMod :: HModule -> HTopDecl
HInclude :: String -> HTopDecl
HLit :: String -> HTopDecl
CLit :: String -> HTopDecl
data HModule
HModule :: Name -> Bool -> [HExport] -> [HImport] -> HDecl -> HModule
data HExport
HExport :: HIEEntity -> (Maybe String) -> HExport
data HIEEntity
IEModule :: Name -> HIEEntity
IEVal :: Name -> HIEEntity
IEClass :: Name -> HIEEntity
IEType :: Name -> Bool -> HIEEntity
data HImport
HImport :: Bool -> (Maybe Name) -> Name -> (Maybe [HIEEntity]) -> HImport
data HDecl
AndDecl :: HDecl -> HDecl -> HDecl
TypeSig :: Name -> (Maybe Context) -> Type -> HDecl
ValDecl :: QualName -> [Pat] -> [GuardedExpr] -> HDecl
Primitive :: Bool -> CallConv -> LocSpec -> Name -> Type -> Bool -> [(Bool, String)] -> (Bool, String) -> HDecl
PrimCast :: CallConv -> Name -> Type -> Bool -> [(Bool, String)] -> (Bool, String) -> HDecl
Entry :: CallConv -> Name -> Name -> Type -> HDecl
Callback :: CallConv -> Name -> Type -> HDecl
ExtLabel :: Name -> Name -> Type -> HDecl
TyD :: TyDecl -> HDecl
Class :: Context -> ClassName -> [TyVar] -> [HDecl] -> HDecl
Instance :: Context -> ClassName -> Type -> [HDecl] -> HDecl
Include :: String -> HDecl
Haskell :: String -> HDecl
CCode :: String -> HDecl
EmptyDecl :: HDecl
type LocSpec = (String, Maybe Integer, String, Maybe Int)
type ClassName = QualName
data Context
CtxtTuple :: [Context] -> Context
CtxtClass :: ClassName -> [Type] -> Context
data Type
TyVar :: Bool -> TyVar -> Type
TyCon :: TyCon -> Type
TyApply :: Type -> [Type] -> Type
TyList :: Type -> Type
TyTuple :: [Type] -> Type
TyFun :: Type -> Type -> Type
TyCtxt :: Context -> Type -> Type
data TyDecl
TypeSyn :: Name -> [Name] -> Type -> TyDecl
TyDecl :: TyDeclKind -> Name -> [Name] -> [ConDecl] -> [QualName] -> TyDecl
data TyDeclKind
Data :: TyDeclKind
Newtype :: TyDeclKind
data ConDecl
ConDecl :: Name -> [BangType] -> ConDecl
RecDecl :: Name -> [(Name, BangType)] -> ConDecl
data BangType
Banged :: Type -> BangType
Unbanged :: Type -> BangType
type TyVar = QualName
type TyCon = QualName
data GuardedExpr
GExpr :: [Expr] -> Expr -> GuardedExpr
data Expr
Lit :: Literal -> Expr
Lam :: [Pat] -> Expr -> Expr
Apply :: Expr -> [Expr] -> Expr
RApply :: Expr -> Expr -> Expr
Tup :: [Expr] -> Expr
List :: [Expr] -> Expr
InfixOp :: Expr -> VarName -> Expr -> Expr
BinOp :: BinaryOp -> Expr -> Expr -> Expr
UnOp :: UnaryOp -> Expr -> Expr
Bind :: Expr -> Pat -> Expr -> Expr
Bind_ :: Expr -> Expr -> Expr
Return :: Expr -> Expr
Case :: Expr -> [CaseAlt] -> Expr
If :: Expr -> Expr -> Expr -> Expr
Let :: [Binding] -> Expr -> Expr
Var :: VarName -> Expr
Con :: ConName -> Expr
WithTy :: Expr -> Type -> Expr
data Binding
Binder :: Name -> Expr -> Binding
type VarName = QualName
type ConName = QualName
data Pat
PatVar :: VarName -> Pat
PatLit :: Literal -> Pat
PatWildCard :: Pat
PatTuple :: [Pat] -> Pat
PatAs :: VarName -> Pat -> Pat
PatCon :: ConName -> [Pat] -> Pat
PatList :: [Pat] -> Pat
PatIrrefut :: Pat -> Pat
PatRecord :: VarName -> [(VarName, Pat)] -> Pat
data CaseAlt
Alt :: Pat -> [GuardedExpr] -> CaseAlt
Default :: (Maybe VarName) -> Expr -> CaseAlt
instance Eq Type
instance Show Type
instance Eq Context
instance Show Context
instance Eq HIEEntity

module DefGen
defGen :: [(String, Bool, [HTopDecl])] -> [(String, String)]

module CustomAttributes
sequenceAttr :: Name
terminatorAttr :: Name
ignoreAttr :: Name
newtypeAttr :: Name
pureAttr :: Name
flagAttr :: Name
finaliserAttr :: Name
abstractAttr :: Name
foreignAttr :: Name
tyArgAttr :: Name
ignoreResAttr :: Name
noFreeAttr :: Name
freeAttr :: Name
freeMethodAttr :: Name
errorHandlerAttr :: Name
cconvAttr :: Name
derivingAttr :: Name
tyArgsAttr :: Name
ctypeAttr :: Name
hsNameAttr :: Name
tyParamsAttr :: Name
dllNameAttr :: Name
jniClassAttr :: Name
jniImplementsAttr :: Name
jniSetFieldAttr :: Name
jniGetFieldAttr :: Name
jniIfaceTyAttr :: Name
jniStaticAttr :: Name
jniCtorAttr :: Name
jniFinalAttr :: Name

module IDLSyn
data Defn
Typedef :: Type -> [Attribute] -> [Id] -> Defn
TypeDecl :: Type -> Defn
ExternDecl :: Type -> [Id] -> Defn
Constant :: Id -> [Attribute] -> Type -> Expr -> Defn
Attributed :: [Attribute] -> Defn -> Defn
Attribute :: [Id] -> Bool -> Type -> Defn
Operation :: Id -> Type -> (Maybe Raises) -> (Maybe Context) -> Defn
Exception :: Id -> [Member] -> Defn
Interface :: Id -> Inherit -> [Defn] -> Defn
Forward :: Id -> Defn
Module :: Id -> [Defn] -> Defn
DispInterface :: Id -> [([Attribute], Type, Id)] -> [Defn] -> Defn
DispInterfaceDecl :: Id -> Id -> Defn
CoClass :: Id -> [CoClassMember] -> Defn
Library :: Id -> [Defn] -> Defn
CppQuote :: String -> Defn
HsQuote :: String -> Defn
CInclude :: String -> Defn
Import :: [(String, [Defn])] -> Defn
ImportLib :: String -> Defn
Pragma :: String -> Defn
IncludeStart :: String -> Defn
IncludeEnd :: Defn
data Id
Id :: String -> Id
AttrId :: [Attribute] -> Id -> Id
ArrayId :: Id -> [Expr] -> Id
Pointed :: [[Qualifier]] -> Id -> Id
CConvId :: CallConv -> Id -> Id
BitFieldId :: Int -> Id -> Id
FunId :: Id -> (Maybe CallConv) -> [Param] -> Id
data Type
TyApply :: Type -> Type -> Type
TyInteger :: Size -> Type
TyFloat :: Size -> Type
TyStable :: Type
TyChar :: Type
TySigned :: Bool -> Type
TyWChar :: Type
TyBool :: Type
TyOctet :: Type
TyAny :: Type
TyObject :: Type
TyStruct :: (Maybe Id) -> [Member] -> (Maybe Int) -> Type
TyString :: (Maybe Expr) -> Type
TyWString :: (Maybe Expr) -> Type
TySequence :: Type -> (Maybe Expr) -> Type
TyFixed :: (Maybe (Expr, IntegerLit)) -> Type
TyName :: String -> (Maybe Type) -> Type
TyIface :: Name -> Type
TyUnion :: (Maybe Id) -> Type -> Id -> (Maybe Id) -> [Switch] -> Type
TyEnum :: (Maybe Id) -> [(Id, [Attribute], Maybe Expr)] -> Type
TyUnionNon :: (Maybe Id) -> [Switch] -> Type
TyCUnion :: (Maybe Id) -> [Member] -> (Maybe Int) -> Type
TyBString :: Type
TyPointer :: Type -> Type
TyArray :: Type -> [Expr] -> Type
TySafeArray :: Type -> Type
TyFun :: (Maybe CallConv) -> Type -> [Param] -> Type
TyVoid :: Type
TyQualifier :: Qualifier -> Type
data Expr
Binary :: BinaryOp -> Expr -> Expr -> Expr
Cond :: Expr -> Expr -> Expr -> Expr
Unary :: UnaryOp -> Expr -> Expr
Var :: Name -> Expr
Lit :: Literal -> Expr
Cast :: Type -> Expr -> Expr
Sizeof :: Type -> Expr
type Raises = [Name]
type Context = [String]
type CoClassMember = (Bool, Id, [Attribute])
data Param
Param :: Id -> Type -> [Attribute] -> Param
type Member = (Type, [Attribute], [Id])
data Attribute
Attrib :: Id -> [AttrParam] -> Attribute
Mode :: ParamDir -> Attribute
data AttrParam
AttrExpr :: Expr -> AttrParam
EmptyAttr :: AttrParam
AttrLit :: Literal -> AttrParam
AttrPtr :: AttrParam -> AttrParam
data Switch
Switch :: [CaseLabel] -> (Maybe SwitchArm) -> Switch
data CaseLabel
Case :: [Expr] -> CaseLabel
Default :: CaseLabel
type SwitchArm = Param
data GNUAttrib
Packed :: GNUAttrib
CConv :: CallConv -> GNUAttrib
Unsupported :: String -> GNUAttrib
instance Eq GNUAttrib
instance Eq CaseLabel
instance Eq Switch
instance Eq AttrParam
instance Eq Attribute
instance Eq Param
instance Eq Expr
instance Eq Type
instance Eq Id
instance Eq Defn

module ImportLib
importLib :: String -> IO Defn

module LibUtils
hdirectLib :: Maybe String
bitsLib :: Maybe String
comLib :: Maybe String
comServLib :: Maybe String
prelude :: Maybe String
maybe_module :: Maybe String
autoLib :: Maybe String
ioExts :: Maybe String
intLib :: Maybe String
wordLib :: Maybe String
foreignLib :: Maybe String
arrayLib :: Maybe String
jniLib :: Maybe String
wStringLib :: Maybe String
safeArrayLib :: Maybe String
ptrLib :: Maybe String
foreignPtrLib :: Maybe String
iDispatch :: QualName
iUnknown :: QualName
iUnknownFO :: QualName
iID :: QualName
cLSID :: QualName
gUID :: QualName
lIBID :: QualName
mkIID :: QualName
mkCLSID :: QualName
mkLIBID :: QualName
primIP :: QualName
currency :: QualName
variantClass :: QualName
variantType :: QualName
groundInterface :: QualName
vARIANT :: QualName
sAFEARRAY :: QualName
derefPtr :: QualName
indexPtr :: QualName
interfacePtrToAddr :: QualName
intToAddr :: QualName
mkWString :: QualName
lengthWString :: QualName
castPtrName :: QualName
castFPtrName :: QualName
withForeignPtrName :: QualName
checkHR :: QualName
check2HR :: QualName
invokeAndCheck :: QualName
returnHR :: QualName
invokeIt :: QualName
primInvokeIt :: QualName
getIfaceState :: QualName
createComVTable :: QualName
createDispVTable :: QualName
comVTableTy :: QualName
createComInst :: QualName
mkComInterface :: QualName
mkDispInterface :: QualName
mkDualInterface :: QualName
comInterfaceTy :: QualName
componentInfo :: QualName
mkComponentInfo :: QualName
hasTypeLib :: QualName
mkForeignObj :: QualName
trivialFree :: QualName
allocOutPointer :: QualName
allocBytes :: QualName
allocWords :: QualName
list :: String
blist :: String
bstring :: String
ref :: String
unique :: String
fptr :: String
iptr :: String
wstring :: String
wstring2 :: String
enum32 :: String
enum16 :: String
stringName :: String
bool :: String
integer :: String
bstr :: String
safearray :: String
ptrName :: String
funPtrName :: String
foreignPtrName :: String
free :: QualName
freeRef :: QualName
doThenFree :: QualName
nullPtr :: QualName
nullFO :: QualName
nullFinaliser :: QualName
nullIPointer :: QualName
prelError :: QualName
raiseIOException :: QualName
prelUserError :: QualName
prelReturn :: QualName
bindName :: QualName
bind_Name :: QualName
xorName :: QualName
orName :: QualName
andName :: QualName
shiftLName :: QualName
shiftRName :: QualName
bitsClass :: QualName
complementName :: QualName
shiftName :: QualName
rotateName :: QualName
bitSizeName :: QualName
isSignedName :: QualName
addName :: QualName
subName :: QualName
divName :: QualName
modName :: QualName
mulName :: QualName
logAndName :: QualName
logOrName :: QualName
gtName :: QualName
geName :: QualName
eqName :: QualName
leName :: QualName
ltName :: QualName
neName :: QualName
negateName :: QualName
notName :: QualName
marshStruct :: QualName
unmarshStruct :: QualName
marshUnion :: QualName
unmarshUnion :: QualName
dollarName :: QualName
inArgName :: QualName
inIUnknownArgName :: QualName
outArgName :: QualName
inoutArgName :: QualName
retValName :: QualName
applyName :: QualName
mkDispMethod :: QualName
enumClass :: QualName
eqClass :: QualName
showClass :: QualName
numClass :: QualName
fromEnumName :: QualName
toEnumName :: QualName
enumToInt :: QualName
enumToFlag :: QualName
unboxInt :: QualName
flagToIntTag :: QualName
tagToEnum :: QualName
toIntFlag :: QualName
pow2Series :: QualName
orListName :: QualName
orFlagsName :: QualName
orFlagName :: QualName
flagsClass :: QualName
inVariantName :: QualName
resVariantName :: QualName
defaultVariantName :: QualName
vtEltTypeName :: QualName
fromMaybeName :: QualName
maybeName :: QualName
justName :: QualName
nothingName :: QualName
mapName :: QualName
mapListName :: QualName
concatName :: QualName
concatMapName :: QualName
intersectName :: QualName
mapMaybeName :: QualName
sumName :: QualName
fromIntegralName :: QualName
lengthName :: QualName
true :: QualName
false :: QualName
uPerformIO :: QualName
marshallPrefix :: String
marshallRefPrefix :: String
unmarshallPrefix :: String
unmarshallRefPrefix :: String
sizeofPrefix :: String
sizeOfName :: String
outPrefix :: String
allocPrefix :: String
freePrefix :: String
copyPrefix :: String
marshallMaybe :: QualName
writeMaybe :: QualName
readMaybe :: QualName
mkPrimitiveName :: String -> String
mkWrapperName :: String -> String
mkPrimExportName :: String -> String
mkVtblOffsetName :: String -> String -> String
mkCLSIDName :: String -> String
mkLIBIDName :: String -> String
defaultCConv :: CallConv
invokeMethod :: QualName
invokeStaticMethod :: QualName
invokeInterfaceMethod :: QualName
getField :: QualName
getStaticField :: QualName
setField :: QualName
setStaticField :: QualName
inArg :: QualName
jvalueClass :: QualName
jObject :: QualName
jArray :: QualName
jniEnv :: QualName
fPointer :: QualName
newObj :: QualName
className :: QualName
makeClassName :: QualName
mkClassName :: String -> String
newFPointer :: QualName
orbLib :: Maybe String
cObject :: QualName

module AbsHUtils
tyConst :: String -> Type
tyQConst :: Maybe String -> String -> Type
libTyQConst :: Maybe String -> Maybe String -> String -> Type
mkTyConst :: QualName -> Type
deTyCon :: Type -> QualName
tyCon :: String -> [Type] -> Type
tyQCon :: Maybe String -> String -> [Type] -> Type
mkTyCon :: QualName -> [Type] -> Type
tyVar :: String -> Type
uniqueTyVar :: String -> Type
tyQVar :: Maybe String -> String -> Type
isTyVar :: Type -> Bool
generaliseTys :: [Type] -> ([Type], Maybe Context)
overloadedTyVar :: ClassName -> String -> Type
ctxtTyApp :: Context -> Type -> Type
ctxtClass :: ClassName -> [Type] -> Context
mbCtxtTyApp :: Maybe Context -> Type -> Type
tyList :: Type -> Type
tyMaybe :: Type -> Type
tyVariant :: Type
tuple :: [Type] -> Type
tyInt8Name :: QualName
tyInt16Name :: QualName
tyInt32Name :: QualName
tyInt64Name :: QualName
tyIntName :: QualName
tyInt8 :: Type
tyInt16 :: Type
tyInt32 :: Type
tyInt64 :: Type
tyInt :: Type
tyInteger :: Type
tyIntegerName :: QualName
tyFloat :: Type
tyDouble :: Type
tyLongDouble :: Type
tyAddr :: Type
tyPtr :: Type -> Type
anyTyPtr :: Type
tyFunPtr :: Type -> Type
tyForeignObj :: Type
tyForeignPtr :: Type -> Type
isFOTy :: Type -> Bool
isPtrTy :: Type -> Bool
isVARIANTTy :: Type -> Bool
toPtrTy :: Type -> Type
tyStable :: Type
tyString :: Type
tyWString :: Type
tyByte :: Type
tyChar :: Type
tyWChar :: Type
tyBool :: Type
tyWord8Name :: QualName
tyWord16Name :: QualName
tyWord32Name :: QualName
tyWord64Name :: QualName
tyWord8 :: Type
tyWord16 :: Type
tyWord32 :: Type
tyWord64 :: Type
funTy :: Type -> Type -> Type
funTys :: [Type] -> Type -> Type
io :: Type -> Type
io_unit :: Type
tyUnit :: Type
purifyType :: Type -> Type
isIOTy :: Type -> Bool
recCon :: Name -> [(Name, Type)] -> ConDecl
recConBanged :: Name -> [(Name, Type)] -> ConDecl
conDecl :: Name -> [Type] -> ConDecl
recToConDecl :: ConDecl -> ConDecl
dataTy :: Name -> [Name] -> [ConDecl] -> HDecl
newTy :: Name -> [Name] -> ConDecl -> [QualName] -> HDecl
tySyn :: Name -> [Name] -> Type -> HDecl
conDeclToCon :: ConDecl -> Expr
conDeclToPat :: ConDecl -> Pat
splitFunTys :: Type -> ([Type], Type)
hInstance :: Maybe [(ClassName, [TyVar])] -> ClassName -> Type -> [HDecl] -> HDecl
hClass :: Context -> ClassName -> [TyVar] -> [HDecl] -> HDecl
groundTyVars :: Type -> Type
unconstrainType :: Type -> ([(Context, TyVar)], Type)
andDecl :: HDecl -> HDecl -> HDecl
andDecls :: [HDecl] -> HDecl
emptyDecl :: HDecl
comment :: String -> HDecl
isEmptyDecl :: HDecl -> Bool
cCode :: String -> HDecl
typeSig :: String -> Type -> HDecl
genTypeSig :: String -> Maybe Context -> Type -> HDecl
mkTypeSig :: String -> [Type] -> Type -> HDecl
funDef :: String -> [Pat] -> Expr -> HDecl
valDef :: String -> Expr -> HDecl
methodDef :: QualName -> [Pat] -> Expr -> HDecl
guardedFunDef :: String -> [Pat] -> [(Expr, Expr)] -> HDecl
prim :: CallConv -> LocSpec -> Name -> Type -> Bool -> [(Bool, String)] -> (Bool, String) -> HDecl
primcst :: CallConv -> Name -> Type -> Bool -> [(Bool, String)] -> (Bool, String) -> HDecl
fexport :: CallConv -> Maybe Name -> Name -> Type -> HDecl
extLabel :: Name -> Name -> Type -> HDecl
conPat :: ConName -> [Pat] -> Pat
patVar :: Name -> Pat
patRec :: VarName -> [(VarName, Pat)] -> Pat
qpatVar :: Maybe String -> Name -> Pat
litPat :: Literal -> Pat
varPat :: Expr -> Pat
tuplePat :: [Pat] -> Pat
exprToPat :: Expr -> Maybe Pat
wildPat :: Pat
isVarPat :: Pat -> Bool
ret :: Expr -> Expr
genBind :: Expr -> Pat -> Expr -> Expr
bind :: Expr -> Expr -> Expr -> Expr
bind_ :: Expr -> Expr -> Expr
var :: Name -> Expr
varName :: VarName -> Expr
qvar :: Maybe String -> Name -> Expr
lam :: [Pat] -> Expr -> Expr
lit :: Literal -> Expr
integerLit :: IntegerLit -> Expr
dataConst :: ConName -> Expr
dataCon :: ConName -> [Expr] -> Expr
funApp :: VarName -> [Expr] -> Expr
contApply :: Expr -> Expr -> Expr
funApply :: Expr -> [Expr] -> Expr
infixOp :: Expr -> VarName -> Expr -> Expr
binOp :: BinaryOp -> Expr -> Expr -> Expr
unaryOp :: UnaryOp -> Expr -> Expr
tup :: [Expr] -> Expr
hList :: [Expr] -> Expr
hCase :: Expr -> [CaseAlt] -> Expr
hIf :: Expr -> Expr -> Expr -> Expr
alt :: Pat -> Expr -> CaseAlt
genAlt :: Pat -> Expr -> Expr -> CaseAlt
defaultAlt :: (Maybe VarName) -> Expr -> CaseAlt
equals :: Expr -> Expr -> Binding
hLet :: Expr -> Expr -> Expr -> Expr
hLets :: [(Expr, Expr)] -> Expr -> Expr
intLit :: Integral a => a -> Expr
stringLit :: String -> Expr
addPtr :: Expr -> Expr -> Expr
castPtr :: Expr -> Expr
nothing :: Expr
just :: Expr -> Expr
unit :: Expr
prefix :: String -> TyCon -> VarName
prefixApp :: String -> TyCon -> VarName
appendStr :: String -> TyCon -> VarName
isVarsEq :: Expr -> Expr -> Bool
hModule :: Name -> Bool -> [HExport] -> [HImport] -> HDecl -> HTopDecl
hMeta :: String -> HTopDecl
cMeta :: String -> HTopDecl
hInclude :: String -> HTopDecl
hExport :: HIEEntity -> Maybe String -> HExport
hImport :: Name -> Bool -> [HIEEntity] -> HImport
hQImport :: Name -> Maybe Name -> [HIEEntity] -> HImport
ieModule :: Name -> HIEEntity
ieValue :: Name -> HIEEntity
ieClass :: Name -> HIEEntity
ieType :: Name -> Bool -> HIEEntity
subst :: Name -> Expr -> Expr -> Expr
mkQVarName :: Maybe String -> String -> VarName
mkVarName :: String -> VarName
mkConName :: String -> ConName
mkQConName :: Maybe String -> String -> ConName
mkTyVar :: String -> TyVar
mkQTyVar :: Maybe String -> String -> TyVar
mkQTyCon :: Maybe String -> String -> TyCon
mkIntTy :: Size -> Signed -> Type
mkCharTy :: Signed -> Type
mkFloatTy :: Size -> Type
findIncludes :: HDecl -> [String]
mkTySig :: [Type] -> Type -> String
replaceTyVar :: Type -> Type -> Type

module MarshallMonad
data Mm a
runMm :: Maybe String -> [String] -> Expr -> Mm a -> Expr
getMethodName :: Mm (Maybe String)
addCode :: (Expr -> Expr) -> Mm ()
addToEnv :: String -> String -> Mm ()
lookupName :: String -> Mm (Maybe String)
data MarshallInfo
MarshallInfo :: Bool -> Bool -> Bool -> Bool -> Bool -> MarshallInfo
forProxy :: MarshallInfo -> Bool
forStruct :: MarshallInfo -> Bool
forInOut :: MarshallInfo -> Bool
forRef :: MarshallInfo -> Bool
doFree :: MarshallInfo -> Bool
proxyMarshallInfo :: MarshallInfo
stubMarshallInfo :: MarshallInfo
structMarshallInfo :: MarshallInfo
instance Monad Mm

module CStubGen
cStubGen :: String -> [HTopDecl] -> String

module MkImport
mkImportLists :: String -> [QualName] -> [HDecl] -> [(String, Bool, [HIEEntity])]

module PpAbstractH
ppHTopDecls :: [HTopDecl] -> AbsHDoc a
ppType :: Type -> AbsHDoc a
showAbstractH :: AbsHDoc a -> String
ppExpr :: Expr -> PPDoc a

module TypeInfo
data TypeInfo
TypeInfo :: String -> QualName -> QualName -> QualName -> QualName -> QualName -> QualName -> Maybe QualName -> Maybe QualName -> Type -> String -> QualName -> Int -> Int -> QualName -> Bool -> Bool -> Maybe String -> TypeInfo
type_name :: TypeInfo -> String
haskell_type :: TypeInfo -> QualName
marshaller :: TypeInfo -> QualName
copy_marshaller :: TypeInfo -> QualName
unmarshaller :: TypeInfo -> QualName
ref_marshaller :: TypeInfo -> QualName
ref_unmarshaller :: TypeInfo -> QualName
alloc_type :: TypeInfo -> Maybe QualName
free_type :: TypeInfo -> Maybe QualName
prim_type :: TypeInfo -> Type
c_type :: TypeInfo -> String
prim_size :: TypeInfo -> QualName
prim_sizeof :: TypeInfo -> Int
prim_align :: TypeInfo -> Int
auto_type :: TypeInfo -> QualName
is_pointed :: TypeInfo -> Bool
finalised :: TypeInfo -> Bool
attributes :: TypeInfo -> Maybe String
typeInfos :: [TypeInfo]
v_bool_ti :: TypeInfo
variant_ti :: TypeInfo
mb_currency_ti :: Maybe TypeInfo
mb_date_ti :: Maybe TypeInfo
guid_ti :: TypeInfo
iid_ti :: TypeInfo
clsid_ti :: TypeInfo
bstr_ti :: TypeInfo
instance Show TypeInfo
instance Eq TypeInfo

module CoreIDL
data Decl
Typedef :: Id -> Type -> Type -> Decl
declId :: Decl -> Id
declType :: Decl -> Type
declOrigType :: Decl -> Type
Constant :: Id -> Type -> Type -> Expr -> Decl
declId :: Decl -> Id
declType :: Decl -> Type
declOrigType :: Decl -> Type
declExpr :: Decl -> Expr
Interface :: Id -> Bool -> InterfaceInherit -> [InterfaceDecl] -> Decl
declId :: Decl -> Id
isReference :: Decl -> Bool
declInherit :: Decl -> InterfaceInherit
declDecls :: Decl -> [InterfaceDecl]
Module :: Id -> [ModuleDecl] -> Decl
declId :: Decl -> Id
declDecls :: Decl -> [ModuleDecl]
DispInterface :: Id -> Maybe Decl -> [DispInterfaceDecl] -> [DispInterfaceDecl] -> Decl
declId :: Decl -> Id
dispExpandedFrom :: Decl -> Maybe Decl
declProps :: Decl -> [DispInterfaceDecl]
declDecls :: Decl -> [DispInterfaceDecl]
CoClass :: Id -> [CoClassDecl] -> Decl
declId :: Decl -> Id
declCoDecls :: Decl -> [CoClassDecl]
Library :: Id -> [LibraryDecl] -> Decl
declId :: Decl -> Id
declDecls :: Decl -> [LibraryDecl]
Method :: Id -> CallConv -> Result -> [Param] -> Maybe Int -> Decl
declId :: Decl -> Id
methCallConv :: Decl -> CallConv
methResult :: Decl -> Result
methParams :: Decl -> [Param]
methOffset :: Decl -> Maybe Int
Property :: Id -> Type -> Maybe Int -> Id -> Id -> Decl
declId :: Decl -> Id
declType :: Decl -> Type
propOffset :: Decl -> Maybe Int
declSetId :: Decl -> Id
declGetId :: Decl -> Id
HsLiteral :: String -> Decl
CInclude :: String -> Decl
CLiteral :: String -> Decl
type InterfaceDecl = Decl
type ModuleDecl = Decl
type DispInterfaceDecl = Decl
data CoClassDecl
CoClassInterface :: Id -> Maybe Decl -> CoClassDecl
coClassId :: CoClassDecl -> Id
coClassDecl :: CoClassDecl -> Maybe Decl
CoClassDispInterface :: Id -> Maybe Decl -> CoClassDecl
coClassId :: CoClassDecl -> Id
coClassDecl :: CoClassDecl -> Maybe Decl
type LibraryDecl = Decl
type InterfaceInherit = [(QualName, Int)]
data Expr
Binary :: BinaryOp -> Expr -> Expr -> Expr
Cond :: Expr -> Expr -> Expr -> Expr
Unary :: UnaryOp -> Expr -> Expr
Var :: Name -> Expr
Lit :: Literal -> Expr
Cast :: Type -> Expr -> Expr
Sizeof :: Type -> Expr
data Type
Integer :: Size -> Signed -> Type
StablePtr :: Type
FunTy :: CallConv -> Result -> [Param] -> Type
Float :: Size -> Type
Char :: Signed -> Type
WChar :: Type
Bool :: Type
Octet :: Type
Any :: Type
Object :: Type
String :: Type -> Bool -> (Maybe Expr) -> Type
WString :: Bool -> (Maybe Expr) -> Type
Sequence :: Type -> (Maybe Expr) -> (Maybe Expr) -> Type
Fixed :: Expr -> IntegerLit -> Type
Name :: Name -> Name -> (Maybe Name) -> (Maybe [Attribute]) -> (Maybe Type) -> (Maybe TypeInfo) -> Type
Struct :: Id -> [Field] -> (Maybe Int) -> Type
Enum :: Id -> EnumKind -> [EnumValue] -> Type
Union :: Id -> Type -> Id -> Id -> [Switch] -> Type
UnionNon :: Id -> [Switch] -> Type
CUnion :: Id -> [Field] -> (Maybe Int) -> Type
Pointer :: PointerType -> Bool -> Type -> Type
Array :: Type -> [Expr] -> Type
Void :: Type
Iface :: Name -> (Maybe Name) -> Name -> [Attribute] -> Bool -> InterfaceInherit -> Type
SafeArray :: Type -> Type
type Signed = Bool
data Id
Id :: Name -> Name -> Maybe Name -> [Attribute] -> Id
idName :: Id -> Name
idOrigName :: Id -> Name
idModule :: Id -> Maybe Name
idAttributes :: Id -> [Attribute]
data Attribute
AttrMode :: ParamDir -> Attribute
AttrDependent :: DepReason -> [AttributeParam] -> Attribute
atReason :: Attribute -> DepReason
atParams :: Attribute -> [AttributeParam]
Attribute :: Name -> [AttributeParam] -> Attribute
atName :: Attribute -> Name
atParams :: Attribute -> [AttributeParam]
data AttributeParam
ParamLit :: Literal -> AttributeParam
ParamType :: Type -> AttributeParam
ParamExpr :: Expr -> AttributeParam
ParamVar :: Name -> AttributeParam
ParamVoid :: AttributeParam
ParamPtr :: AttributeParam -> AttributeParam
data DepReason
SizeIs :: DepReason
LengthIs :: DepReason
LastIs :: DepReason
FirstIs :: DepReason
MaxIs :: DepReason
MinIs :: DepReason
SwitchIs :: DepReason
data Result
Result :: Type -> Type -> Result
resultType :: Result -> Type
resultOrigType :: Result -> Type
data Param
Param :: Id -> ParamDir -> Type -> Type -> Bool -> Param
paramId :: Param -> Id
paramMode :: Param -> ParamDir
paramType :: Param -> Type
paramOrigType :: Param -> Type
paramDependent :: Param -> Bool
data Switch
Switch :: Id -> [CaseLabel] -> Type -> Type -> Switch
switchId :: Switch -> Id
switchLabels :: Switch -> [CaseLabel]
switchType :: Switch -> Type
switchOrigType :: Switch -> Type
SwitchEmpty :: (Maybe [(CaseLabel, String)]) -> Switch
data CaseLabel
Case :: Expr -> CaseLabel
Default :: CaseLabel
data Field
Field :: Id -> Type -> Type -> Maybe Int -> Maybe Int -> Field
fieldId :: Field -> Id
fieldType :: Field -> Type
fieldOrigType :: Field -> Type
fieldSize :: Field -> Maybe Int
fieldOffset :: Field -> Maybe Int
data EnumValue
EnumValue :: Id -> (Either Int32 Expr) -> EnumValue
enumName :: EnumValue -> Id
enumValue :: EnumValue -> (Either Int32 Expr)
instance Eq EnumValue
instance Show EnumValue
instance Eq Field
instance Show Field
instance Eq CaseLabel
instance Show CaseLabel
instance Eq Switch
instance Show Switch
instance Eq Param
instance Show Param
instance Eq Result
instance Show Result
instance Eq DepReason
instance Show DepReason
instance Eq AttributeParam
instance Show AttributeParam
instance Eq Attribute
instance Show Attribute
instance Eq Id
instance Show Id
instance Eq Type
instance Show Type
instance Eq Expr
instance Show Expr

module Attribute
noAttrs :: [Attribute]
hasAttribute :: [Attribute] -> Attribute -> Bool
hasAttributeWithName :: [Attribute] -> Name -> Bool
hasAttributeWithNames :: [Attribute] -> [Name] -> Bool
filterOutAttributes :: [Attribute] -> [Name] -> [Attribute]
filterAttributes :: [Attribute] -> [Name] -> [Attribute]
findAttribute :: Name -> [Attribute] -> Maybe Attribute
findStringAttributes :: Name -> [Attribute] -> [String]
isDependentAttribute :: Attribute -> Maybe Attribute
isConstantAttribute :: Attribute -> Bool
stringToDepReason :: String -> Maybe DepReason
hasStringAttribute :: [Attribute] -> Bool
hasSeqAttribute :: [Attribute] -> Bool
hasSourceAttribute :: [Attribute] -> Bool
hasUniqueAttribute :: [Attribute] -> Bool
getLengthAttribute :: [Attribute] -> Maybe AttributeParam
hasModeAttribute :: ParamDir -> [Attribute] -> Bool
getSwitchIsAttribute :: [Attribute] -> Maybe Expr
getUuidAttribute :: [Attribute] -> Maybe [String]
getDispIdAttribute :: [Attribute] -> Maybe IntegerLit
hasDependentAttrs :: [Attribute] -> Bool
sourceAttribute :: Attribute
getDefaultCConv :: [Attribute] -> Maybe CallConv

module CgMonad
data CgM a
data IfaceType
StdFFI :: IfaceType
VTBLObject :: IfaceType
ComIDispatch :: Bool -> IfaceType
runCgM :: Env String [(Result, [Param])] -> Env String (Maybe Id) -> CgM a -> (a, [(HIEEntity, Bool, Maybe String)], [(String, Bool, [HIEEntity])], Bool, Bool)
getDllName :: CgM String
setDllName :: String -> CgM a -> CgM a
getDeclName :: (String -> CgM a) -> CgM a
withDeclName :: String -> CgM a -> CgM a
withIfaceDeclName :: String -> CgM a -> CgM a
needStubs :: Bool -> CgM ()
hasPrims :: CgM ()
setInterfaceFlag :: IfaceType -> CgM a -> CgM a
getInterfaceFlag :: CgM IfaceType
setSourceIfaceFlag :: Bool -> CgM a -> CgM a
getSourceIfaceFlag :: CgM Bool
setClientFlag :: Bool -> CgM a -> CgM a
getClientFlag :: CgM Bool
getIfaceName :: CgM String
setIfaceName :: String -> CgM a -> CgM a
inDispInterface :: CgM a -> CgM a
isInDispInterface :: CgM Bool
setIfaceAttributes :: [Attribute] -> CgM a -> CgM a
getIfaceAttributes :: CgM [Attribute]
getIfaceInherit :: CgM [QualName]
withIfaceInherit :: [QualName] -> CgM a -> CgM a
type IsoEnv = Env String [(Bool, Result, [Param])]
getIsoEnv :: CgM IsoEnv
setIsoEnv :: IsoEnv -> CgM ()
getIEnumFlag :: CgM Bool
setIEnumFlag :: Bool -> CgM a -> CgM a
addDynStub :: String -> String -> Bool -> CgM ()
lookupDynStub :: String -> CgM (Maybe (Bool, String))
addExport :: HIEEntity -> CgM ()
addVitalExport :: HIEEntity -> CgM ()
addExportWithComment :: HIEEntity -> String -> CgM ()
exportDecl :: (String, HDecl) -> CgM HDecl
addExplicitImports :: [(Bool, String)] -> CgM ()
hoistInClass :: String -> (Maybe Id -> CgM a) -> CgM a
getMethodNumber :: Maybe Int -> CgM Int
setMethodNumber :: Int -> CgM ()
incMethodNumber :: CgM ()
instance Eq IfaceType
instance Monad CgM

module PpCore
type CoreDoc = PPDoc (Bool, Bool, Bool, Bool, String)
showCore :: CoreDoc -> String
showHeader :: String -> CoreDoc -> String
ppCore :: [Decl] -> CoreDoc
ppHeaderDecl :: [Id] -> Decl -> CoreDoc
setDebug :: Bool -> CoreDoc -> CoreDoc
getCommentFlag :: (Bool -> CoreDoc) -> CoreDoc
inComment :: CoreDoc -> CoreDoc
setLibFlag :: Bool -> CoreDoc -> CoreDoc
ifTopLevLib :: CoreDoc -> CoreDoc -> CoreDoc
ifC :: CoreDoc -> CoreDoc -> CoreDoc
setThisType :: String -> CoreDoc -> CoreDoc
getThisType :: (String -> CoreDoc) -> CoreDoc
whenNotC :: CoreDoc -> CoreDoc
commentOutIfC :: CoreDoc -> CoreDoc
commentOut :: CoreDoc -> CoreDoc
getIfC :: (Bool -> CoreDoc) -> CoreDoc
ifDebug :: CoreDoc -> CoreDoc -> CoreDoc
ppDecl :: Decl -> CoreDoc
ppCoreDecls :: [Decl] -> [CoreDoc] -> CoreDoc
ppCoClassDecl :: CoClassDecl -> CoreDoc
ppId :: Id -> (CoreDoc -> CoreDoc) -> CoreDoc
ppIdVert :: Id -> (CoreDoc -> CoreDoc) -> CoreDoc
ppModule :: Id -> CoreDoc
ppAttr :: Attribute -> CoreDoc
ppAttrParam :: AttributeParam -> CoreDoc
ppDepReason :: DepReason -> CoreDoc
ppType :: Type -> CoreDoc
ppEnumValue :: EnumValue -> CoreDoc
ppArray :: CoreDoc -> Type -> [Expr] -> CoreDoc
ppPointerType :: PointerType -> CoreDoc
ppFunTy :: CallConv -> Result -> [Param] -> CoreDoc
ppArrayDims :: [Expr] -> CoreDoc
ppExpr :: Expr -> CoreDoc
ppParam :: Param -> CoreDoc
ppSwitch :: Bool -> Switch -> CoreDoc
ppField :: Field -> CoreDoc
ppResult :: Result -> CoreDoc
ppCaseLabels :: Bool -> [CaseLabel] -> CoreDoc
ppCaseLabel :: CaseLabel -> CoreDoc

module TLBWriter
writeTLB :: [String] -> [Decl] -> IO ()

module CoreUtils
mkId :: Name -> Name -> Maybe Name -> [Attribute] -> Id
setIdModule :: Maybe Name -> Id -> Id
mkParam :: Name -> ParamDir -> Type -> Param
flattenDecls :: [Decl] -> [Decl]
reallyFlattenDecls :: [Decl] -> [Decl]
inSeparateHaskellModule :: Decl -> Bool
findFieldTy :: [Field] -> Name -> Type
findFieldOrigTy :: [Field] -> Name -> Type
findParam :: [Param] -> Name -> Param
findParamTy :: [Param] -> Name -> Type
localiseTypes :: [Decl] -> [Decl]
getTypeAttributes :: Type -> [Attribute]
getHsImports :: Id -> [QualName]
keepValueAsPointer :: Type -> Bool
isStructTy :: Type -> Bool
isEnumTy :: Type -> Bool
isPointerTy :: Type -> Bool
isVoidPointerTy :: Type -> Bool
isArrayTy :: Type -> Bool
isSafeArrayTy :: Type -> Bool
isOpenArrayTy :: Type -> Bool
isFunTy :: Type -> Bool
isBoolTy :: Type -> Bool
isVoidTy :: Type -> Bool
isPointerOrArrayTy :: Type -> Bool
isPtrPointerTy :: Type -> Bool
isRefPointerTy :: Type -> Bool
isUniquePointerTy :: Type -> Bool
isStringTy :: Type -> Bool
isSeqTy :: Type -> Bool
isAnyTy :: Type -> Bool
isObjectTy :: Type -> Bool
isConstructedTy :: Type -> Bool
isCompleteTy :: Type -> Bool
isReferenceTy :: Type -> Bool
isSimpleTy :: Type -> Bool
isIntegerTy :: Type -> Bool
isSynTy :: Type -> Bool
isAbstractTy :: Type -> Bool
isAbstractFinalTy :: Type -> Bool
isNonEncUnionTy :: Type -> Bool
getNonEncUnionTy :: Type -> Type
isUnionTy :: Type -> Bool
isIfaceTy :: Type -> Bool
isIUnknownTy :: Type -> Bool
isIfacePtr :: Type -> Bool
isVariantTy :: Type -> Bool
getIfaceTy :: Type -> Type
tyFun :: CallConv -> Result -> [Param] -> Type
stringTy :: Type
wStringTy :: Type
bstrTy :: Type
intTy :: Type
addrTy :: Type
boolTy :: Type
variantBoolTy :: Type
variantTy :: Type
charTy :: Type
wCharTy :: Type
int32Ty :: Type
int64Ty :: Type
word64Ty :: Type
shortTy :: Type
floatTy :: Type
doubleTy :: Type
byteTy :: Type
word32Ty :: Type
int16Ty :: Type
word16Ty :: Type
voidTy :: Type
currencyTy :: Type
dateTy :: Type
fileTimeTy :: Type
safeArrayTy :: Type -> Type
iUnknownTy :: Type
iDispatchTy :: Type
hresultTy :: Type
guidTy :: Type
isHRESULTTy :: Type -> Bool
isHRESULT :: Result -> Bool
mkPtrPointer :: Type -> Type
removePtr :: Type -> Type
removePtrAndArray :: Type -> Type
removePtrAll :: Type -> Type
removePtrs :: Type -> Type
removeNames :: Type -> Type
nukeNames :: Type -> Type
pushPointerType :: PointerType -> Type -> Type
hasIgnoreAttribute :: Id -> Bool
findPtrType :: Bool -> [Attribute] -> (Type -> Type)
mkRefPointer :: Type -> Type
rawPointerToIP :: Type -> Type
notAggregatableAttribute :: Attribute -> Bool
childAttributes :: [Attribute] -> [Attribute]
getTyTag :: Type -> Id
findFreeVars :: Expr -> [Name]
solve :: Name -> Expr -> Expr -> Expr
complementOp :: BinaryOp -> BinaryOp
isCommutative :: BinaryOp -> Bool
contains :: Name -> Expr -> Bool
evalExpr :: Expr -> Integer
simplifyExpr :: Env String (Either Int32 Expr) -> Expr -> Expr
simpRedExpr :: Env String (Either Int32 Expr) -> Type -> Expr -> Expr
plusOne :: Expr -> Expr
minusOne :: Expr -> Expr
add :: Expr -> Expr -> Expr
sizeofType :: Type -> Int
sizeAndAlignModulus :: Maybe Int -> Type -> (Int, Int)
computeStructSizeOffsets :: Maybe Int -> [Field] -> ((Int, Int), [Int])
align :: Int -> Int -> Int
data Dependent
Dep :: DepReason -> [DepVal] -> Dependent
data DepVal
DepNone :: DepVal
DepVal :: (Maybe Name) -> Expr -> DepVal
type DependInfo = [(Id, [Dependent])]
findDependents :: [Id] -> DependInfo
attrToDependent :: Attribute -> Dependent
computeArrayConstraints :: Bool -> [Dependent] -> ([DepVal], [DepVal], [DepVal])
isLengthIs :: Dependent -> Bool
isSizeIs :: Dependent -> Bool
isMaxIs :: Dependent -> Bool
isMinIs :: Dependent -> Bool
isFirstIs :: Dependent -> Bool
isLastIs :: Dependent -> Bool
sizeOrLength :: Dependent -> Bool
minOrFirst :: Dependent -> Bool
maxOrLast :: Dependent -> Bool
isSwitchIs :: Dependent -> Bool
lookupDepender :: DependInfo -> Id -> Maybe [Dependent]
isDepender :: DependInfo -> Id -> Bool
isDependee :: DependInfo -> Id -> Bool
isSwitchDependee :: DependInfo -> Id -> Bool
isSwitchDepender :: DependInfo -> Id -> Bool
isNotSwitchDependee :: DependInfo -> Id -> Bool
hasNonConstantExprs :: Dependent -> Bool
mkHaskellVarName :: Name -> Name
mkHaskellTyConName :: Name -> Name
toCType :: Type -> Either String String
mkIfaceTypeName :: Name -> Name
getInterfaceIds :: Decl -> [Id]
idHaskellModule :: Id -> Maybe Name
isMethod :: Decl -> Bool
isConst :: Decl -> Bool
isMethodOrProp :: Decl -> Bool
isProperty :: Decl -> Bool
isCoClass :: Decl -> Bool
dummyMethod :: Decl
unionToStruct :: Type -> (Maybe (Id, Type), Type)
binParams :: [Param] -> ([Param], [Param], [Param], [Param], [Param])
objParam :: Name -> Param
resultParam :: Type -> Param
iPointerParam :: Name -> Param
derivesFromIDispatch :: CoClassDecl -> Bool
toDispInterfaceMethod :: Decl -> Decl
sortDecls :: [Decl] -> [Decl]
isFinalisedType :: Bool -> Type -> Bool
instance Show Dependent
instance Show DepVal

module MarshallUtils
mkHVar :: Id -> Expr
adjustField :: Bool -> [(Id, [Dependent])] -> Field -> Maybe Field
prefixHTy :: String -> Type -> QualName
appHTy :: String -> Type -> QualName
infoHeader :: Decl -> HDecl
helpStringComment :: Id -> HDecl
toHaskellIfaceTy :: Type -> Type
findParamDependents :: Bool -> [Param] -> ([Param], DependInfo)
findFieldDependents :: [Field] -> DependInfo
removeDependees :: DependInfo -> [Param] -> [Param]
removeDependents :: DependInfo -> [Param] -> [Param]
removeDependers :: DependInfo -> [Param] -> [Param]

module MarshallCore
toHaskellMethodTy :: Bool -> Bool -> Bool -> Maybe Type -> [Param] -> Result -> (Type, Maybe Context)
toHaskellTy :: Bool -> Type -> Type
paramToHaskellType :: DependInfo -> Bool -> Bool -> Bool -> Param -> Type
mkHStructDef :: Id -> [Field] -> ConDecl
mkHEnumDef :: Name -> [Attribute] -> EnumKind -> [EnumValue] -> [ConDecl]
mkHUnionDef :: Name -> [Switch] -> [ConDecl]
mkCUnionDef :: [Field] -> [ConDecl]
toHaskellBaseTy :: Bool -> Type -> Type
toBaseTy :: Type -> Type
toHaskellBaseMethodTy :: Bool -> [Param] -> Result -> Type
mkMarshaller :: String -> Type -> QualName
autoTypeToHaskellTy :: ParamDir -> Type -> Type
autoTypeToQName :: Type -> QualName
mbAutoTypeToHaskellTy :: ParamDir -> Type -> Maybe Type
constrainIIDParams :: (Param -> Type) -> (Param -> Type) -> [Param] -> [Param] -> ([Type], [Type])

module MarshallType
marshallType :: MarshallInfo -> Type -> Expr
unmarshallType :: MarshallInfo -> Type -> Expr
refMarshallType :: MarshallInfo -> Type -> Expr
refUnmarshallType :: MarshallInfo -> Type -> Expr
szType :: Type -> Expr
allocPointerTo :: Type -> Expr
freeType :: Type -> Expr
mbFreeType :: Type -> Maybe Expr
needsFreeing :: Type -> Bool
coreToHaskellExpr :: Expr -> Expr
coerceTy :: Type -> Type -> Expr -> Expr
coerceToInt :: Expr -> Expr

module MarshallEnum
marshallEnum :: Id -> EnumKind -> Bool -> [EnumValue] -> CgM HDecl
genDerivedEnumInstanceFor :: EnumKind -> [EnumValue] -> Bool

module MarshallAbstract
marshallAbstract :: Id -> CgM HDecl

module MarshallUnion
marshallUnion :: Name -> Either (Id, Type) Type -> Bool -> [Switch] -> Maybe Int -> CgM HDecl

module MarshallJNI
cgJNIMethod :: Id -> Result -> [Param] -> CgM HDecl
cgJNIInterface :: Id -> Bool -> CgM HDecl
cgJNIClass :: Id -> Bool -> CgM HDecl
cgClassNameDecl :: Id -> (HDecl, Name)

module MarshallJServ
cgJServMethod :: Id -> Result -> [Param] -> CgM HDecl
cgJClass :: Id -> [Decl] -> CgM HDecl

module Skeleton
cgSkeleton :: [Decl] -> [(String, Bool, [HTopDecl])]
genSkeleton :: Decl -> (String, Bool, [HTopDecl])
mkStubMethod :: Decl -> HDecl

module NormaliseType
normaliseType :: Type -> Type

module JavaProxy
javaProxyGen :: Decl -> String
prepareDecls :: [Decl] -> [(String, Decl)]

module MarshallDep
marshallDependents :: Bool -> Bool -> DependInfo -> (Name -> Type) -> Mm ()
unmarshallDependents :: Bool -> Bool -> DependInfo -> (Name -> Type) -> Mm ()
freeDependent :: Id -> (Name -> Type) -> [Dependent] -> Mm ()

module MarshallStruct
marshallStruct :: Name -> Id -> ConDecl -> [Field] -> Maybe Int -> CgM HDecl

module PpIDLSyn
type IDLDoc = PPDoc ()
showIDL :: IDLDoc -> String
ppIDL :: String -> [Defn] -> IDLDoc
ppId :: Id -> IDLDoc
ppDefn :: Defn -> IDLDoc
ppType :: Type -> IDLDoc
ppMembers :: [Member] -> IDLDoc
ppMember :: Member -> IDLDoc
ppDefns :: [Defn] -> IDLDoc
ppAttrs :: Bool -> [Attribute] -> IDLDoc
ppAttr :: Attribute -> IDLDoc
ppCoCMembers :: [CoClassMember] -> IDLDoc
ppCoCMember :: CoClassMember -> IDLDoc
ppParams :: [Param] -> IDLDoc
ppParam :: Param -> IDLDoc
ppRaises :: Maybe Raises -> IDLDoc
ppContext :: Maybe Context -> IDLDoc
ppProps :: [([Attribute], Type, Id)] -> IDLDoc
ppProp :: ([Attribute], Type, Id) -> IDLDoc
ppSwitches :: [Switch] -> IDLDoc
ppSwitch :: Switch -> IDLDoc
ppExpr :: Expr -> IDLDoc
ppCaseLabels :: [CaseLabel] -> IDLDoc
ppCaseLabel :: CaseLabel -> IDLDoc

module DsMonad
data DsM a
runDsM :: String -> Env String TypeInfo -> Env String (Bool, [Attribute]) -> [(String, Maybe String, Type)] -> DsM a -> IO (a, TypeEnv, TagEnv, SourceEnv, IfaceEnv)
mapDsM :: (a -> b) -> DsM a -> DsM b
lookupType :: String -> DsM (Maybe (Maybe String, Type, [Attribute]))
lookupTypeInfo :: String -> DsM (Maybe TypeInfo)
lookupAsf :: String -> DsM (Maybe (Bool, [Attribute]))
lookupConst :: String -> DsM (Maybe (Either Int32 Expr))
lookupIface :: String -> DsM (Maybe Decl)
lookupTag :: String -> DsM (Maybe (Maybe String, String))
getAttributes :: DsM [Attribute]
propagateAttributes :: [Attribute] -> DsM a -> DsM a
withAttributes :: [Attribute] -> DsM a -> DsM a
getSrcFilename :: DsM String
pushPack :: Maybe (Maybe (String, Maybe Int)) -> DsM ()
popPack :: Maybe (String, Maybe Int) -> DsM ()
getCurrentPack :: DsM (Maybe Int)
openUpScope :: DsM a -> DsM a
addToTypeEnv :: String -> Maybe String -> (Type, [Attribute]) -> DsM ()
addToIfaceEnv :: String -> Decl -> DsM ()
addToConstEnv :: String -> Either Int32 Expr -> DsM ()
getConstEnv :: DsM ConstEnv
addToTagEnv :: String -> String -> DsM ()
addSourceIface :: String -> DsM ()
getFilename :: DsM (Maybe String)
setFilename :: Maybe String -> DsM ()
getInterface :: DsM (Maybe String)
withInterface :: String -> DsM a -> DsM a
addToPath :: String -> DsM a -> DsM a
getPath :: DsM String
inLibrary :: DsM a -> DsM a
isInLibrary :: DsM Bool
inImportedContext :: DsM a -> DsM a
isInImportedContext :: DsM Bool
addWarning :: String -> DsM ()
ioToDsM :: IO a -> DsM a
type TypeEnv = Env String (Maybe String, Type, [Attribute])
type SourceEnv = Env String ()
type ConstEnv = Env String (Either Int32 Expr)
type TagEnv = Env String (Maybe String, String)
type IfaceEnv = Env String Decl
data TypeInfo
instance Monad DsM

module IDLUtils
iName :: Id -> Name
noAttrs :: [Attribute]
removeIdAttrs :: Id -> Id
idAttrs :: Id -> [Attribute]
isUnpointedId :: Id -> Bool
isConstructedTy :: Type -> Bool
isCompleteTy :: Type -> Bool
isReferenceTy :: Type -> Bool
isMIDLishTy :: Type -> Bool
isMIDLishId :: Id -> Bool
isFunTy :: Type -> Bool
isEmptyStructTy :: Type -> Bool
isAnonTy :: Type -> Bool
tyTag :: Type -> String
withTyTag :: String -> Type -> Type
getTyQual :: Type -> ([Qualifier], Type)
mkReferenceTy :: Type -> Type
getTyTag :: String -> Type -> String
isVoidTyDef :: Type -> [Id] -> Bool
reduceExpr :: (Type -> DsM Type) -> Expr -> DsM (Either Int32 Expr)
isLeafDefn :: Defn -> Bool
tyShort :: Type
tyWord16 :: Type
tyInt16 :: Type
tyWord32 :: Type
tyInt32 :: Type
tyGUID :: Type
tyIDispatch :: Type
tyVARIANT :: Type
tySafeArray :: Type -> Type
tyCURRENCY :: Type
tyDATE :: Type
tyFILETIME :: Type
tyAddr :: Type
tyVoid :: Type
tyIStream :: Type
tyIStorage :: Type
tyChar :: Type
tyWord64 :: Type
tyInt64 :: Type
tyByte :: Type
tyVariantBool :: Type
tyIUnknown :: Type
tyHRESULT :: Type
tyBSTR :: Type
tyString :: Type
tyWString :: Type
tyFloat :: Type
tyDouble :: Type
tyInt :: Type
retValAttribute :: Attribute
defaultAttribute :: Maybe Literal -> Maybe Attribute
lcidAttribute :: Attribute
optionalAttribute :: Attribute
controlAttribute :: Attribute
restrictedAttribute :: Attribute
hiddenAttribute :: Attribute
versionAttr :: Word16 -> Word16 -> Maybe Attribute
helpStringAttr :: String -> Maybe Attribute
helpContextAttr :: Integer -> Maybe Attribute
helpFileAttr :: String -> Maybe Attribute
helpStringDllAttr :: String -> Maybe Attribute
helpStringCtxtAttr :: Integer -> Maybe Attribute
lcidvalAttribute :: Integer -> Maybe Attribute
mkFunId :: Id -> [Param] -> Id
mkMethodId :: Id -> Id
massageId :: Id -> Id
sortDefns :: [Defn] -> [Defn]
winnowDefns :: Env String (Bool, [Attribute]) -> [Defn] -> [Defn]
exprToName :: Expr -> String
exprType :: Type -> Expr -> Type
transferPointedness :: Id -> Type -> Type
toCConvAttrib :: [GNUAttrib] -> (Id -> Id)
toPackedAttrib :: [GNUAttrib] -> Maybe Int
mkGNUAttrib :: String -> [Expr] -> GNUAttrib
handlePackPragma :: String -> DsM ()
childAttributes :: [Attribute] -> [Attribute]

module RnMonad
data RnM a
runRnM :: TypeEnv -> TagEnv -> SourceEnv -> IfaceEnv -> RnM a -> (a, IsoEnv, IfaceNukeEnv)
lookupTypeId :: Name -> RnM (Maybe (Maybe String, Type))
lookupIface :: Name -> RnM (Maybe Decl)
lookupTag :: Name -> RnM (Maybe (Maybe String, String))
getMethOffset :: RnM (Maybe Int)
setMethOffset :: Maybe Int -> RnM a -> RnM a
incMethOffset :: RnM ()
withNewVarIdEnv :: RnM a -> RnM a
inNewModule :: RnM a -> RnM a
isSourceIface :: Name -> RnM Bool
lookupVarIdAndAddEnv :: String -> (String -> RnM a) -> RnM a
lookupTypeIdAndAddEnv :: String -> (String -> RnM a) -> RnM a
lookupTyConAndAddEnv :: String -> (String -> RnM a) -> RnM a
lookupModIdAndAddEnv :: String -> (String -> RnM a) -> RnM a
lookupClassIdAndAddEnv :: String -> (String -> RnM a) -> RnM a
lookupTyConEnv :: String -> (String -> RnM a) -> RnM a
lookupTypeIdEnv :: String -> (String -> RnM a) -> RnM a
lookupVarIdEnv :: String -> (String -> RnM a) -> RnM a
varIdInScope :: String -> RnM Bool
addIface :: String -> Decl -> RnM ()
addNukeIface :: String -> Id -> RnM ()
addMethod :: String -> (Maybe Int, Result, [Param]) -> RnM ()
addIsoMethod :: String -> (Result, [Param]) -> RnM ()
lookupMethod :: String -> RnM (Maybe [(Maybe Int, Result, [Param])])
setIfaceName :: String -> RnM a -> RnM a
setModuleName :: String -> RnM a -> RnM a
withDependers :: [String] -> RnM a -> RnM a
getIfaceName :: (String -> RnM a) -> RnM a
getModuleName :: (String -> RnM a) -> RnM a
getDependers :: ([String] -> RnM a) -> RnM a
type IsoEnv = Env String [(Result, [Param])]
type IfaceNukeEnv = Env String (Maybe Id)
instance Monad RnM

module Validate
validateParam :: String -> Param -> Param

module Desugar
desugar :: String -> Env String (Bool, [Attribute]) -> [Defn] -> IO ([Decl], TypeEnv, TagEnv, SourceEnv, IfaceEnv)

module HugsCodeGen
hugsCodeGen :: String -> [HTopDecl] -> String

module IDLToken
data IDLToken
T_semi :: IDLToken
T_module :: IDLToken
T_interface :: IDLToken
T_oparen :: IDLToken
T_cparen :: IDLToken
T_ocurly :: IDLToken
T_ccurly :: IDLToken
T_colon :: IDLToken
T_dcolon :: IDLToken
T_const :: IDLToken
T_volatile :: IDLToken
T_equal :: IDLToken
T_eqeq :: IDLToken
T_neq :: IDLToken
T_negate :: IDLToken
T_rel_or :: IDLToken
T_or :: IDLToken
T_xor :: IDLToken
T_rel_and :: IDLToken
T_and :: IDLToken
T_shift :: ShiftDir -> IDLToken
T_div :: IDLToken
T_mod :: IDLToken
T_not :: IDLToken
T_typedef :: IDLToken
T_extern :: IDLToken
T_comma :: IDLToken
T_dot :: IDLToken
T_dotdotdot :: IDLToken
T_float :: Size -> IDLToken
T_int :: Size -> IDLToken
T_uint :: Size -> IDLToken
T_unsigned :: IDLToken
T_signed :: IDLToken
T_sizeof :: IDLToken
T_char :: IDLToken
T_wchar :: IDLToken
T_boolean :: IDLToken
T_octet :: IDLToken
T_any :: IDLToken
T_object :: IDLToken
T_struct :: IDLToken
T_union :: IDLToken
T_switch :: IDLToken
T_case :: IDLToken
T_default :: IDLToken
T_enum :: IDLToken
T_question :: IDLToken
T_lt :: IDLToken
T_le :: IDLToken
T_gt :: IDLToken
T_ge :: IDLToken
T_osquare :: IDLToken
T_csquare :: IDLToken
T_exception :: IDLToken
T_void :: IDLToken
T_mode :: ParamDir -> IDLToken
T_raises :: IDLToken
T_context :: IDLToken
T_fixed :: IDLToken
T_idl_type :: Type -> IDLToken
T_type :: String -> IDLToken
T_literal :: Literal -> IDLToken
T_string_lit :: String -> IDLToken
T_wstring_lit :: String -> IDLToken
T_callconv :: CallConv -> IDLToken
T_pragma :: String -> IDLToken
T_id :: String -> IDLToken
T_dispinterface :: IDLToken
T_coclass :: IDLToken
T_library :: IDLToken
T_plus :: IDLToken
T_times :: IDLToken
T_minus :: IDLToken
T_safearray :: IDLToken
T_sequence :: IDLToken
T_string :: IDLToken
T_wstring :: IDLToken
T_readonly :: IDLToken
T_attribute :: IDLToken
T_methods :: IDLToken
T_properties :: IDLToken
T_import :: IDLToken
T_include_start :: String -> IDLToken
T_include_end :: IDLToken
T_gnu_attribute :: IDLToken
T_importlib :: IDLToken
T_oneway :: IDLToken
T_cpp_quote :: IDLToken
T_hs_quote :: IDLToken
T_include :: String -> IDLToken
T_hdefine :: IDLToken
T_unknown :: (SrcLoc, String) -> IDLToken
T_ignore_start :: IDLToken
T_eof :: IDLToken
idlKeywords :: [(String, IDLToken)]
std_idl_keywords :: [(String, IDLToken)]
dce_keywords :: [(String, IDLToken)]
dce_idl_keywords :: [(String, IDLToken)]
midl_keywords :: [(String, IDLToken)]
ms_idl_keywords :: [(String, IDLToken)]
omg_keywords :: [(String, IDLToken)]
omg_idl_keywords :: [(String, IDLToken)]

module PreProc
preProcessFile :: String -> IO String
removeTmp :: IO ()

module LexM
data LexM a
runLexM :: [String] -> String -> String -> LexM a -> IO a
invokeLexM :: String -> String -> LexM a -> LexM a
ioToLexM :: IO a -> LexM a
incLineNo :: LexM a -> LexM a
setSrcLoc :: SrcLoc -> LexM a -> LexM a
getSrcLoc :: LexM SrcLoc
getOrigSrcLoc :: LexM SrcLoc
getPath :: LexM [FilePath]
isEOF :: LexM Bool
getNextChar :: LexM Char
putBackChar :: Char -> LexM ()
getStream :: LexM String
setStream :: String -> LexM ()
lookupSymbol :: String -> LexM (Maybe IDLToken)
lookupType :: String -> LexM (Maybe IDLToken)
addBuiltinType :: String -> LexM ()
addTypedef :: String -> LexM ()
setTok :: IDLToken -> LexM ()
getTok :: LexM (Maybe IDLToken)
inSystemContext :: Bool -> LexM a -> LexM a
getSystemContextFlag :: LexM Bool
cacheFilePath :: FilePath -> LexM ()
alreadySeenFile :: FilePath -> LexM Bool
importFile :: String -> LexM (Maybe String)
handleImportLib :: LexM [Defn] -> String -> LexM Defn
slurpImports :: LexM [Defn] -> [String] -> LexM Defn
thenLexM :: LexM a -> (a -> LexM b) -> LexM b
returnLexM :: a -> LexM a
instance Monad LexM

module Lex
lexIDL :: (IDLToken -> LexM a) -> LexM a

module Parser
parseIDL :: LexM (Either [Defn] [(Name, Bool, [Attribute])])

module OmgParser
parseIDL :: LexM [Defn]

module Rename
renameDecls :: TypeEnv -> TagEnv -> SourceEnv -> IfaceEnv -> [Decl] -> ([Decl], IsoEnv, IfaceNukeEnv)
type IsoEnv = Env String [(Result, [Param])]
type IfaceNukeEnv = Env String (Maybe Id)

module MarshallAuto
marshallVariantParam :: Param -> Expr
unmarshallVariantParam :: Param -> Expr
marshallVariant :: String -> Type -> Expr
classifyCall :: Id -> Bool -> [Param] -> Result -> VarName
permissibleAutoSig :: Result -> [Param] -> Bool

module MarshallMethod
cgMethod :: Id -> CallConv -> Result -> [Param] -> Maybe Int -> Maybe Name -> CgM HDecl
cgProperty :: Id -> Type -> Id -> Id -> CgM HDecl
findParamDependents :: Bool -> [Param] -> ([Param], DependInfo)
removeDependers :: DependInfo -> [Param] -> [Param]
removeDependees :: DependInfo -> [Param] -> [Param]
removeDependents :: DependInfo -> [Param] -> [Param]
allocateOutParams :: DependInfo -> (Name -> Param) -> [Param] -> Mm ()
marshallParams :: Bool -> Bool -> Bool -> [Param] -> Mm ()
freeInParamStorage :: DependInfo -> [Param] -> Mm ()
primDecl :: Bool -> Bool -> Bool -> Id -> String -> String -> CallConv -> Type -> [Param] -> CgM (Bool, HDecl, Maybe Name)
mkResult :: [Param] -> Expr

module MarshallServ
cgServMethod :: Id -> Result -> [Param] -> Bool -> Bool -> CgM HDecl
mkServVTBL :: Id -> Bool -> Bool -> [InterfaceDecl] -> CgM HDecl
mkServMain :: String -> Id -> [CoClassDecl] -> CgM HDecl

module MarshallFun
marshallFun :: Maybe Name -> Id -> Type -> CgM HDecl

module CodeGen
codeGen :: (Either String String, Maybe String) -> Env String [(Result, [Param])] -> Env String (Maybe Id) -> [Decl] -> ([(String, Decl)], [(String, Bool, [HTopDecl])])
instance Eq GuidKind

module Main
main :: IO ()
hdirectHelp :: IO ()
