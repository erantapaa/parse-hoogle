-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bidirectional (de-)serialization
--   
--   Roundtrip allows the definition of bidirectional (de-)serialization
--   specifications. The specification language is based on the ideas
--   described in the paper /Invertible Syntax Descriptions: Unifying
--   Parsing and Pretty Printing/ by Tillmann Rendel and Klaus Ostermann,
--   Haskell Symposium 2010.
--   
--   This package does not provide concrete instances of the specification
--   classes, see the packages roundtrip-string and roundtrip-xml instead.
--   
--   The package contains slightly modified code from Tillmann Rendel's
--   partial-isomorphisms and invertible-syntax packages (Copyright (c)
--   2010-11 University of Marburg).
@package roundtrip
@version 0.2.0.1

module Control.Isomorphism.Partial.Iso
data Iso a b
unsafeMakeIso :: (alpha -> Maybe beta) -> (beta -> Maybe alpha) -> Iso alpha beta
unsafeMakeIso' :: String -> Maybe (a -> ShowS) -> Maybe (b -> ShowS) -> (a -> Maybe b) -> (b -> Maybe a) -> Iso a b
unsafeMakeNamedIso :: String -> (alpha -> Maybe beta) -> (beta -> Maybe alpha) -> Iso alpha beta
unsafeMakeNamedIsoL :: Show alpha => String -> (alpha -> Maybe beta) -> (beta -> Maybe alpha) -> Iso alpha beta
unsafeMakeNamedIsoR :: Show beta => String -> (alpha -> Maybe beta) -> (beta -> Maybe alpha) -> Iso alpha beta
unsafeMakeNamedIsoLR :: (Show alpha, Show beta) => String -> (alpha -> Maybe beta) -> (beta -> Maybe alpha) -> Iso alpha beta
isoRL :: Iso a b -> b -> Maybe a
isoLR :: Iso a b -> a -> Maybe b
isoName :: Iso a b -> String
isoShowSL :: Iso a b -> Maybe (a -> ShowS)
isoShowSR :: Iso a b -> Maybe (b -> ShowS)
isoShowL :: Iso a b -> Maybe (a -> String)
isoShowR :: Iso a b -> Maybe (b -> String)
isoFailedErrorMessageL :: Iso a b -> a -> String
isoFailedErrorMessageR :: Iso a b -> b -> String

module Control.Isomorphism.Partial.TH
defineIsomorphisms :: Name -> Q [Dec]
defineIsomorphisms' :: Name -> (String -> String) -> Q [Dec]

module Control.Isomorphism.Partial.Constructors
nil :: Iso () [alpha]
cons :: Iso (alpha, [alpha]) [alpha]
listCases :: Iso (Either () (alpha, [alpha])) [alpha]
left :: Iso a (Either a b)
right :: Iso b (Either a b)
nothing :: Iso () (Maybe a)
just :: Iso a (Maybe a)

module Control.Isomorphism.Partial.Prim
idIso :: Iso a a
inverse :: Iso alpha beta -> Iso beta alpha
apply :: Iso alpha beta -> alpha -> Maybe beta
unapply :: Iso alpha beta -> beta -> Maybe alpha
class IsoFunctor f
(<$>) :: IsoFunctor f => Iso alpha beta -> (f alpha -> f beta)
ignore :: alpha -> Iso alpha ()

-- | the product type constructor `(,)` is a bifunctor from <a>Iso</a>
--   $times$ <a>Iso</a> to <a>Iso</a>, so that we have the bifunctorial map
--   <a>***</a> which allows two separate isomorphisms to work on the two
--   components of a tuple.
(***) :: Iso alpha beta -> Iso gamma delta -> Iso (alpha, gamma) (beta, delta)

-- | The mediating arrow for sums constructed with <a>Either</a>. This is
--   not a proper partial isomorphism because of <a>mplus</a>.
(|||) :: Iso alpha gamma -> Iso beta gamma -> Iso (Either alpha beta) gamma

-- | Nested products associate.
associate :: Iso (alpha, (beta, gamma)) ((alpha, beta), gamma)

-- | Products commute.
commute :: Iso (alpha, beta) (beta, alpha)

-- | `()` is the unit element for products.
unit :: Iso alpha (alpha, ())

-- | `element x` is the partial isomorphism between `()` and the singleton
--   set which contains just <tt>x</tt>.
element :: (Show alpha, Eq alpha) => alpha -> Iso () alpha

-- | For a predicate <tt>p</tt>, `subset p` is the identity isomorphism
--   restricted to elements matching the predicate.
subset :: Show alpha => (alpha -> Bool) -> Iso alpha alpha
namedSubset :: Show alpha => String -> (alpha -> Bool) -> Iso alpha alpha
iterateIso :: Iso alpha alpha -> Iso alpha alpha

-- | Products distribute over sums.
distribute :: Iso (alpha, Either beta gamma) (Either (alpha, beta) (alpha, gamma))
readShowIso :: (Read a, Show a) => Iso String a
readShowTextIso :: (Read a, Show a) => Iso Text a
textStringIso :: Iso Text String
lazyStrictTextIso :: Iso Text Text
listMapIso :: Ord a => Iso ([(a, b)]) (Map a b)
maybeUnitBoolIso :: Iso (Maybe ()) Bool
instance Category Iso

module Control.Isomorphism.Partial.Derived
foldl :: Iso (alpha, beta) alpha -> Iso (alpha, [beta]) alpha
swap23 :: Iso (a, (b, c)) (a, (c, b))
fixedValue :: (Show a, Eq a) => a -> Iso a ()

module Control.Isomorphism.Partial

module Text.Roundtrip.Classes
class ProductFunctor f
(<*>) :: ProductFunctor f => f alpha -> f beta -> f (alpha, beta)
class Alternative f
(<|>) :: Alternative f => f alpha -> f alpha -> f alpha
(<||>) :: Alternative f => f alpha -> f alpha -> f alpha
empty :: Alternative f => f alpha
class (IsoFunctor delta, ProductFunctor delta, Alternative delta) => Syntax delta
pure :: (Syntax delta, Eq alpha) => alpha -> delta alpha
rule :: Syntax delta => String -> delta beta -> delta alpha -> delta alpha
ruleInfix :: Syntax delta => String -> delta beta -> delta gamma -> delta alpha -> delta alpha
class Syntax delta => StringSyntax delta
token :: StringSyntax delta => (Char -> Bool) -> delta Char
anyToken :: StringSyntax delta => delta Char
type Attribute = (Name, [Content])
class Syntax delta => XmlSyntax delta
xmlBeginDoc :: XmlSyntax delta => delta ()
xmlEndDoc :: XmlSyntax delta => delta ()
xmlBeginElem :: XmlSyntax delta => Name -> delta ()
xmlEndElem :: XmlSyntax delta => Name -> delta ()
xmlAttrValue :: XmlSyntax delta => Name -> delta Text
xmlTextNotEmpty :: XmlSyntax delta => delta Text

module Text.Roundtrip.Combinators
char :: StringSyntax delta => Char -> delta ()
char' :: StringSyntax delta => Char -> delta Char

-- | <a>string</a> parses/prints a fixed text and consumes/produces a unit
--   value.
string :: StringSyntax delta => String -> delta ()
comma :: StringSyntax delta => delta ()
dot :: StringSyntax delta => delta ()
many :: Syntax delta => delta alpha -> delta [alpha]
many1 :: Syntax delta => delta alpha -> delta [alpha]
sepBy :: Syntax delta => delta alpha -> delta () -> delta [alpha]

-- | The <a>chainl1</a> combinator is used to parse a left-associative
--   chain of infix operators.
chainl1 :: Syntax delta => delta alpha -> delta beta -> Iso (alpha, (beta, alpha)) alpha -> delta alpha

-- | This variant of <a>&lt;*&gt;</a> ignores its left result. In contrast
--   to its counterpart derived from the <tt>Applicative</tt> class, the
--   ignored parts have type `delta ()` rather than `delta beta` because
--   otherwise information relevant for pretty-printing would be lost.
(*>) :: Syntax delta => delta () -> delta alpha -> delta alpha

-- | This variant of <a>&lt;*&gt;</a> ignores its right result. In contrast
--   to its counterpart derived from the <tt>Applicative</tt> class, the
--   ignored parts have type `delta ()` rather than `delta beta` because
--   otherwise information relevant for pretty-printing would be lost.
(<*) :: Syntax delta => delta alpha -> delta () -> delta alpha

-- | The <a>between</a> function combines <a>*&gt;</a> and <a>&lt;*</a> in
--   the obvious way.
between :: Syntax delta => delta () -> delta () -> delta alpha -> delta alpha
(<+>) :: Syntax delta => delta alpha -> delta beta -> delta (Either alpha beta)
optional :: Syntax delta => delta alpha -> delta (Maybe alpha)
optionalBool :: Syntax delta => delta () -> delta Bool
optionalWithDefault :: (Eq alpha, Syntax delta) => alpha -> delta alpha -> delta alpha

-- | <a>skipSpace</a> marks a position where whitespace is allowed to
--   occur. It accepts arbitrary space while parsing, and produces no space
--   while printing.
skipSpace :: StringSyntax delta => delta ()

-- | <a>sepSpace</a> marks a position where whitespace is required to
--   occur. It requires one or more space characters while parsing, and
--   produces a single space character while printing.
sepSpace :: StringSyntax delta => delta ()

-- | <a>optSpace</a> marks a position where whitespace is desired to occur.
--   It accepts arbitrary space while parsing, and produces a single space
--   character while printing.
optSpace :: StringSyntax delta => delta ()
xmlEatWhiteSpace :: XmlSyntax d => d ()
xmlElem :: XmlSyntax x => Name -> x a -> x a
xmlAttr :: XmlSyntax x => Name -> Iso Text a -> x a
xmlFixedAttr :: XmlSyntax x => Name -> Text -> x ()
xmlText :: XmlSyntax d => d Text
xmlString :: XmlSyntax d => d String

module Text.Roundtrip

module Text.Roundtrip.SpecPrinter
data SpecPrinter a
specPrinter :: Doc -> SpecPrinter a
runSpecPrinter :: SpecPrinter a -> String
instance XmlSyntax SpecPrinter
instance Syntax SpecPrinter
instance Alternative SpecPrinter
instance ProductFunctor SpecPrinter
instance IsoFunctor SpecPrinter
