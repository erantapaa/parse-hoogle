-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Smart derivation of Aeson instances
--   
--   Aeson-smart generates ToJSON and FromJSON instances that ignore extra
--   fields and fill in missing fields with default values.
@package aeson-smart
@version 0.2.0.0

module Data.Default.TH
deriveDefault :: Bool -> Name -> Q [Dec]

module Data.Aeson.TH.Smart

-- | Generates both <a>ToJSON</a> and <a>FromJSON</a> instance declarations
--   for the given data type.
--   
--   This is a convienience function which is equivalent to calling both
--   <a>deriveToJSON</a> and <a>deriveFromJSON</a>.
deriveJSON :: (String -> String) -> Bool -> Name -> Q [Dec]
deriveToJSON :: (String -> String) -> Bool -> Name -> Q [Dec]

-- | Generates a <a>FromJSON</a> instance declaration for the given data
--   type.
--   
--   Example:
--   
--   <pre>
--   data Foo = Foo Char Int
--   $(<a>deriveFromJSON</a> id ''Foo)
--   </pre>
--   
--   This will splice in the following code:
--   
--   <pre>
--   instance <a>FromJSON</a> Foo where
--       <a>parseJSON</a> =
--           value -&gt; case value of
--                       <a>Array</a> arr -&gt;
--                         if (V.length arr == 2)
--                         then Foo &lt;$&gt; <a>parseJSON</a> (arr <a>unsafeIndex</a> 0)
--                                  &lt;*&gt; <a>parseJSON</a> (arr <a>unsafeIndex</a> 1)
--                         else fail "&lt;error message&gt;"
--                       other -&gt; fail "&lt;error message&gt;"
--   </pre>
deriveFromJSON :: (String -> String) -> Bool -> Name -> Q [Dec]

-- | Generates a lambda expression which encodes the given data type as
--   JSON.
--   
--   Example:
--   
--   <pre>
--   data Foo = Foo Int
--   </pre>
--   
--   <pre>
--   encodeFoo :: Foo -&gt; <a>Value</a>
--   encodeFoo = $(<a>mkToJSON</a> id ''Foo)
--   </pre>
--   
--   This will splice in the following code:
--   
--   <pre>
--   value -&gt; case value of Foo arg1 -&gt; <a>toJSON</a> arg1
--   </pre>
mkToJSON :: (String -> String) -> Name -> Q Exp

-- | Generates a lambda expression which parses the JSON encoding of the
--   given data type.
--   
--   Example:
--   
--   <pre>
--   data Foo = Foo <tt>Int</tt>
--   </pre>
--   
--   <pre>
--   parseFoo :: <a>Value</a> -&gt; <a>Parser</a> Foo
--   parseFoo = $(<a>mkParseJSON</a> id ''Foo)
--   </pre>
--   
--   This will splice in the following code:
--   
--   <pre>
--   \value -&gt; case value of arg -&gt; Foo &lt;$&gt; <a>parseJSON</a> arg
--   </pre>
mkParseJSON :: (String -> String) -> Name -> Q Exp
