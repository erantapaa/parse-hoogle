-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Homeomorphic Embedding Test
--   
--   A library to carry out homeomorphic embedding tests.
@package homeomorphic
@version 0.1

module Data.Homeomorphic.Internal

-- | The central data type. All data structures must be converted so they
--   consist of <tt>Shell</tt>'s, which split a value into a component at
--   this level and the children. Create a <tt>Shell</tt> with
--   <a>shell</a>.
data Shell a
Shell :: a -> Int -> [Shell a] -> Shell a

-- | Create a value with a component at the current level and all the
--   children.
shell :: a -> [Shell a] -> Shell a

-- | A simple homeomorphic embedding. <i>O(expensive)</i>
(<<|) :: Eq a => Shell a -> Shell a -> Bool

-- | Does the dive rule apply.
dive :: Eq a => Shell a -> Shell a -> Bool

-- | Does the couple rule apply.
couple :: Eq a => Shell a -> Shell a -> Bool
instance Eq a => Eq (Shell a)
instance Ord a => Ord (Shell a)
instance Show a => Show (Shell a)
instance Arbitrary a => Arbitrary (Shell a)

module Data.Homeomorphic.Simple
data Homeomorphic k v
Homeomorphic :: [(Shell k, v)] -> Homeomorphic k v
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v

module Data.Homeomorphic.SimpleParallel
data Homeomorphic k v
Homeomorphic :: (IntMap v) -> (H k) -> Homeomorphic k v
data H k
H :: [Int] -> (Map (Int, k) (H k)) -> H k
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v
findIds :: Ord k => [Shell k] -> H k -> [Int]

module Data.Homeomorphic.Hash1
data Homeomorphic k v
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v

module Data.Homeomorphic.Hash2
data Homeomorphic k v
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v

module Data.Homeomorphic.Memo
data Homeomorphic k v
Homeomorphic :: (IORef (Cache k)) -> [(Shell k, v)] -> Homeomorphic k v
type Cache k = Map (Shell k) (Map (Shell k) Bool)
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
getCache :: Ord k => Shell k -> Shell k -> State (Cache k) (Maybe Bool)
addCache :: Ord k => Shell k -> Shell k -> Bool -> State (Cache k) ()
test :: Ord k => Shell k -> Shell k -> State (Cache k) Bool
diveM :: Ord k => Shell k -> Shell k -> State (Cache k) Bool
coupleM :: Ord k => Shell k -> Shell k -> State (Cache k) Bool

module Data.Homeomorphic.ShellId
data ShellIds k
data ShellId
ShellId :: Int -> Int -> [ShellId] -> ShellId
allId :: ShellId -> Int
headId :: ShellId -> Int
restId :: ShellId -> [ShellId]
empty :: ShellIds k
retrieve :: Ord k => Shell k -> ShellIds k -> (ShellIds k, ShellId)

module Data.Homeomorphic.MemoCache
data Homeomorphic k v
Homeomorphic :: (IORef Cache) -> [(ShellId, v)] -> (IORef (ShellIds k)) -> Homeomorphic k v
type Cache = IntMap (IntMap Bool)
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v
find :: Ord k => Shell k -> Homeomorphic k v -> [v]
getCache :: ShellId -> ShellId -> State Cache (Maybe Bool)
addCache :: ShellId -> ShellId -> Bool -> State Cache ()
test :: ShellId -> ShellId -> State Cache Bool
diveM :: ShellId -> ShellId -> State Cache Bool
coupleM :: ShellId -> ShellId -> State Cache Bool

module Data.Homeomorphic.Check
data Homeomorphic k v
Homeomorphic :: (Homeomorphic k v) -> (Homeomorphic k v) -> (Homeomorphic k v) -> (Homeomorphic k v) -> (Homeomorphic k v) -> (Homeomorphic k v) -> Homeomorphic k v
empty :: Homeomorphic k v
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
find :: (Ord k, Eq v, Show v, Show k) => Shell k -> Homeomorphic k v -> [v]
findOne :: (Ord k, Eq v, Show v, Show k) => Shell k -> Homeomorphic k v -> Maybe v

module Data.Homeomorphic.Test
data AB
A :: AB
B :: AB
data Command
Insert :: (Shell AB) -> Command
Find :: (Shell AB) -> Command
tester :: [Command] -> Bool
instance Eq Command
instance Ord Command
instance Show Command
instance Eq AB
instance Ord AB
instance Show AB
instance Arbitrary Command
instance Arbitrary AB

module Data.Homeomorphic

-- | The central data type. All data structures must be converted so they
--   consist of <tt>Shell</tt>'s, which split a value into a component at
--   this level and the children. Create a <tt>Shell</tt> with
--   <a>shell</a>.
data Shell a

-- | Create a value with a component at the current level and all the
--   children.
shell :: a -> [Shell a] -> Shell a

-- | A simple homeomorphic embedding. <i>O(expensive)</i>
(<<|) :: Eq a => Shell a -> Shell a -> Bool

-- | Does the couple rule apply.
couple :: Eq a => Shell a -> Shell a -> Bool

-- | Does the dive rule apply.
dive :: Eq a => Shell a -> Shell a -> Bool

-- | Datatype to store a homemorphic embedding.
data Homeomorphic k v

-- | An empty embedding
empty :: Homeomorphic k v

-- | Insert a new key (coded as a shell) and an associated value into an
--   embedding.
insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v

-- | Does any relation xs &lt;| y hold, given y.
find :: Ord k => Shell k -> Homeomorphic k v -> [v]

-- | <pre>
--   findOne y = listToMaybe . find y
--   </pre>
findOne :: Ord k => Shell k -> Homeomorphic k v -> Maybe v
