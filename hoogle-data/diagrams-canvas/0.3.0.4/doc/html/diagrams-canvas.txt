-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTML5 canvas backend for diagrams drawing EDSL
--   
@package diagrams-canvas
@version 0.3.0.4


-- | A full-featured rendering backend for diagrams using Canvas.
--   Implemented using the blank-canvas platform.
--   
--   To invoke the Canvas backend, you have three options.
--   
--   <ul>
--   <li>You can use the <a>Diagrams.Backend.Canvas.CmdLine</a> module to
--   create standalone executables which will display the diagram in a
--   browser using a web service.</li>
--   <li>You can use the <a>renderCanvas</a> function provided by this
--   module, which gives you more programmatic control over when and how
--   images are displayed (making it east to, for example, write a single
--   program that displays multiple images, or one that diaplays images
--   dynamically based on user input, and so on).</li>
--   <li>For the most flexiblity you can invoke the <a>renderDia</a> method
--   from <a>Backend</a> instance for <tt>Canvas</tt>. In particular,
--   <a>renderDia</a> has the generic type</li>
--   </ul>
--   
--   <pre>
--   renderDia :: b -&gt; Options b v -&gt; QDiagram b v m -&gt; Result b v
--   </pre>
--   
--   (omitting a few type class contraints). <tt>b</tt> represents the
--   backend type, <tt>v</tt> the vector space, and <tt>m</tt> the type of
--   monoidal query annotations on the diagram. <a>Options</a> and
--   <a>Result</a> are associated data and type families, respectively,
--   which yield the type of option records and rendering results specific
--   to any particular backend. For <tt>b ~ Canvas</tt> and <tt>v ~
--   R2</tt>, we have
--   
--   <pre>
--   data Options Canvas R2 = CanvaseOptions
--    { _size :: SizeSpec2D -- ^^ The requested size
--    }
--   </pre>
--   
--   <pre>
--   data family Render Canvas R2 = C (RenderM ())
--   </pre>
--   
--   <pre>
--   type family Result Canvas R2 = Canvas ()
--   </pre>
--   
--   So the type of <a>renderDia</a> resolves to
--   
--   <pre>
--   renderDia :: Canvas -&gt; Options Canvas R2 -&gt; QDiagram Canvas R2 m -&gt;
--   Canvas()
--   </pre>
--   
--   which you could call like <tt>renderDia Canvas (CanvaseOptions (width
--   250)) myDiagram</tt>
module Diagrams.Backend.Canvas

-- | This data declaration is simply used as a token to distinguish this
--   rendering engine.
data Canvas
Canvas :: Canvas
type B = Canvas

-- | Backend-specific rendering options.
renderCanvas :: Int -> SizeSpec2D -> Diagram Canvas R2 -> IO ()
instance Renderable (DImage External) Canvas
instance Renderable Text Canvas
instance Renderable (Path R2) Canvas
instance Renderable (Trail R2) Canvas
instance Renderable (Segment Closed R2) Canvas
instance Backend Canvas R2
instance Monoid (Render Canvas R2)
instance Default CanvasState
instance Typeable Canvas
instance Eq Canvas
instance Ord Canvas
instance Read Canvas
instance Show Canvas


-- | Convenient creation of command-line-driven executables for rendering
--   diagrams using the Canvas backend.
--   
--   <ul>
--   <li><a>defaultMain</a> creates an executable which can render a single
--   diagram at various options.</li>
--   <li><a>multiMain</a> is like <a>defaultMain</a> but allows for a list
--   of diagrams from which the user can choose one to render.</li>
--   <li><a>mainWith</a> is a generic form that does all of the above but
--   with a slightly scarier type. See <a>Diagrams.Backend.CmdLine</a>.
--   This form can also take a function type that has a suitable final
--   result (any of arguments to the above types) and <a>Parseable</a>
--   arguments.</li>
--   </ul>
--   
--   If you want to generate diagrams programmatically---<i>i.e.</i> if you
--   want to do anything more complex than what the below functions
--   provide---you have several options.
--   
--   <ul>
--   <li>Use a function with <a>mainWith</a>. This may require making
--   <a>Parseable</a> instances for custom argument types.</li>
--   <li>Make a new <a>Mainable</a> instance. This may require a newtype
--   wrapper on your diagram type to avoid the existing instances. This
--   gives you more control over argument parsing, intervening steps, and
--   diagram creation.</li>
--   <li>Build option records and pass them along with a diagram to
--   <a>mainRender</a> from <a>Diagrams.Backend.CmdLine</a>.</li>
--   </ul>
--   
--   For a tutorial on command-line diagram creation see
--   <a>http://projects.haskell.org/diagrams/doc/cmdline.html</a>.
module Diagrams.Backend.Canvas.CmdLine

-- | Main entry point for command-line diagram creation. This is the method
--   that users will call from their program <tt>main</tt>. For instance an
--   expected user program would take the following form.
--   
--   <pre>
--   import Diagrams.Prelude
--   import Diagrams.Backend.TheBestBackend.CmdLine
--   
--   d :: Diagram B R2
--   d = ...
--   
--   main = mainWith d
--   </pre>
--   
--   Most backends should be able to use the default implementation. A
--   different implementation should be used to handle more complex
--   interactions with the user.
mainWith :: (Mainable d, Parseable (MainOpts d)) => d -> IO ()
defaultMain :: Diagram Canvas R2 -> IO ()
multiMain :: [(String, Diagram Canvas R2)] -> IO ()

-- | This data declaration is simply used as a token to distinguish this
--   rendering engine.
data Canvas
type B = Canvas
instance Mainable [(String, Diagram Canvas R2)]
instance Mainable (Diagram Canvas R2)
instance Parseable DiaOpts
instance Typeable DiaOpts
instance Show DiaOpts
instance Data DiaOpts
