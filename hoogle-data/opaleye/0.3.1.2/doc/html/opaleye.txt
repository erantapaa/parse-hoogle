-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An SQL-generating DSL targeting PostgreSQL
--   
@package opaleye
@version 0.3.1.2

module Opaleye.Internal.HaskellDB.Sql
type SqlTable = String
newtype SqlColumn
SqlColumn :: String -> SqlColumn

-- | A valid SQL name for a parameter.
type SqlName = String
data SqlOrder
SqlAsc :: SqlOrder
SqlDesc :: SqlOrder

-- | Data type for SQL UPDATE statements.
data SqlUpdate
SqlUpdate :: SqlTable -> [(SqlColumn, SqlExpr)] -> [SqlExpr] -> SqlUpdate

-- | Data type for SQL DELETE statements.
data SqlDelete
SqlDelete :: SqlTable -> [SqlExpr] -> SqlDelete
data SqlInsert
SqlInsert :: SqlTable -> [SqlColumn] -> [SqlExpr] -> SqlInsert

-- | Expressions in SQL statements.
data SqlExpr
ColumnSqlExpr :: SqlColumn -> SqlExpr
BinSqlExpr :: String -> SqlExpr -> SqlExpr -> SqlExpr
PrefixSqlExpr :: String -> SqlExpr -> SqlExpr
PostfixSqlExpr :: String -> SqlExpr -> SqlExpr
FunSqlExpr :: String -> [SqlExpr] -> SqlExpr

-- | Aggregate functions separate from normal functions.
AggrFunSqlExpr :: String -> [SqlExpr] -> SqlExpr
ConstSqlExpr :: String -> SqlExpr
CaseSqlExpr :: [(SqlExpr, SqlExpr)] -> SqlExpr -> SqlExpr
ListSqlExpr :: [SqlExpr] -> SqlExpr
ParamSqlExpr :: (Maybe SqlName) -> SqlExpr -> SqlExpr
PlaceHolderSqlExpr :: SqlExpr
ParensSqlExpr :: SqlExpr -> SqlExpr
CastSqlExpr :: String -> SqlExpr -> SqlExpr
instance Show SqlColumn
instance Show SqlOrder
instance Show SqlExpr

module Opaleye.Internal.HaskellDB.Sql.Print
ppUpdate :: SqlUpdate -> Doc
ppDelete :: SqlDelete -> Doc
ppInsert :: SqlInsert -> Doc
ppSqlExpr :: SqlExpr -> Doc
ppWhere :: [SqlExpr] -> Doc
ppGroupBy :: [SqlExpr] -> Doc
ppOrderBy :: [(SqlExpr, SqlOrder)] -> Doc
ppAs :: String -> Doc -> Doc
commaV :: (a -> Doc) -> [a] -> Doc
commaH :: (a -> Doc) -> [a] -> Doc

module Opaleye.Internal.Helpers
(.:) :: (r -> z) -> (a -> b -> r) -> a -> b -> z
(.:.) :: (r -> z) -> (a -> b -> c -> r) -> a -> b -> c -> z
(.::) :: (r -> z) -> (a -> b -> c -> d -> r) -> a -> b -> c -> d -> z

module Opaleye.Internal.Tag
data Tag
UnsafeTag :: Int -> Tag
start :: Tag
next :: Tag -> Tag
unsafeUnTag :: Tag -> Int
tagWith :: Tag -> String -> String
instance Read Tag
instance Show Tag

module Opaleye.Internal.HaskellDB.PrimQuery
type TableName = String
type Attribute = String
type Name = String
type Scheme = [Attribute]
type Assoc = [(Attribute, PrimExpr)]
data Symbol
Symbol :: String -> Tag -> Symbol
data PrimExpr
AttrExpr :: Symbol -> PrimExpr
BaseTableAttrExpr :: Attribute -> PrimExpr
BinExpr :: BinOp -> PrimExpr -> PrimExpr -> PrimExpr
UnExpr :: UnOp -> PrimExpr -> PrimExpr
AggrExpr :: AggrOp -> PrimExpr -> PrimExpr
ConstExpr :: Literal -> PrimExpr
CaseExpr :: [(PrimExpr, PrimExpr)] -> PrimExpr -> PrimExpr
ListExpr :: [PrimExpr] -> PrimExpr
ParamExpr :: (Maybe Name) -> PrimExpr -> PrimExpr
FunExpr :: Name -> [PrimExpr] -> PrimExpr

-- | Cast an expression to a given type.
CastExpr :: Name -> PrimExpr -> PrimExpr
data Literal
NullLit :: Literal

-- | represents a default value
DefaultLit :: Literal
BoolLit :: Bool -> Literal
StringLit :: String -> Literal
ByteStringLit :: ByteString -> Literal
IntegerLit :: Integer -> Literal
DoubleLit :: Double -> Literal

-- | used for hacking in custom SQL
OtherLit :: String -> Literal
data BinOp
OpEq :: BinOp
OpLt :: BinOp
OpLtEq :: BinOp
OpGt :: BinOp
OpGtEq :: BinOp
OpNotEq :: BinOp
OpAnd :: BinOp
OpOr :: BinOp
OpLike :: BinOp
OpIn :: BinOp
OpOther :: String -> BinOp
OpCat :: BinOp
OpPlus :: BinOp
OpMinus :: BinOp
OpMul :: BinOp
OpDiv :: BinOp
OpMod :: BinOp
OpBitNot :: BinOp
OpBitAnd :: BinOp
OpBitOr :: BinOp
OpBitXor :: BinOp
OpAsg :: BinOp
data UnOp
OpNot :: UnOp
OpIsNull :: UnOp
OpIsNotNull :: UnOp
OpLength :: UnOp
OpAbs :: UnOp
OpNegate :: UnOp
OpLower :: UnOp
OpUpper :: UnOp
UnOpOther :: String -> UnOp
data AggrOp
AggrCount :: AggrOp
AggrSum :: AggrOp
AggrAvg :: AggrOp
AggrMin :: AggrOp
AggrMax :: AggrOp
AggrStdDev :: AggrOp
AggrStdDevP :: AggrOp
AggrVar :: AggrOp
AggrVarP :: AggrOp
AggrBoolOr :: AggrOp
AggrBoolAnd :: AggrOp
AggrOther :: String -> AggrOp
data OrderExpr
OrderExpr :: OrderOp -> PrimExpr -> OrderExpr
data OrderOp
OpAsc :: OrderOp
OpDesc :: OrderOp
instance Read Symbol
instance Show Symbol
instance Read Literal
instance Show Literal
instance Show BinOp
instance Read BinOp
instance Show UnOp
instance Read UnOp
instance Show AggrOp
instance Read AggrOp
instance Read PrimExpr
instance Show PrimExpr
instance Show OrderOp
instance Show OrderExpr

module Opaleye.Internal.PrimQuery
data LimitOp
LimitOp :: Int -> LimitOp
OffsetOp :: Int -> LimitOp
LimitOffsetOp :: Int -> Int -> LimitOp
data BinOp
Except :: BinOp
Union :: BinOp
UnionAll :: BinOp
data JoinType
LeftJoin :: JoinType
data PrimQuery
Unit :: PrimQuery
BaseTable :: String -> [(Symbol, PrimExpr)] -> PrimQuery
Product :: (NonEmpty PrimQuery) -> [PrimExpr] -> PrimQuery
Aggregate :: [(Symbol, (Maybe AggrOp, PrimExpr))] -> PrimQuery -> PrimQuery
Order :: [OrderExpr] -> PrimQuery -> PrimQuery
Limit :: LimitOp -> PrimQuery -> PrimQuery
Join :: JoinType -> [(Symbol, PrimExpr)] -> PrimExpr -> PrimQuery -> PrimQuery -> PrimQuery
Values :: [Symbol] -> [[PrimExpr]] -> PrimQuery
Binary :: BinOp -> [(Symbol, (PrimExpr, PrimExpr))] -> (PrimQuery, PrimQuery) -> PrimQuery
type PrimQueryFold p = (p, String -> [(Symbol, PrimExpr)] -> p, NonEmpty p -> [PrimExpr] -> p, [(Symbol, (Maybe AggrOp, PrimExpr))] -> p -> p, [OrderExpr] -> p -> p, LimitOp -> p -> p, JoinType -> [(Symbol, PrimExpr)] -> PrimExpr -> p -> p -> p, [Symbol] -> [[PrimExpr]] -> p, BinOp -> [(Symbol, (PrimExpr, PrimExpr))] -> (p, p) -> p)
foldPrimQuery :: PrimQueryFold p -> PrimQuery -> p
times :: PrimQuery -> PrimQuery -> PrimQuery
restrict :: PrimExpr -> PrimQuery -> PrimQuery
isUnit :: PrimQuery -> Bool
instance Show LimitOp
instance Show BinOp
instance Show JoinType
instance Show PrimQuery

module Opaleye.Internal.Optimize
optimize :: PrimQuery -> PrimQuery
removeUnit :: PrimQuery -> PrimQuery
mergeProduct :: PrimQuery -> PrimQuery

module Opaleye.Internal.PackMap
data PackMap a b s t
PackMap :: (Applicative f => (a -> f b) -> s -> f t) -> PackMap a b s t
packmap :: Applicative f => PackMap a b s t -> (a -> f b) -> s -> f t
over :: PackMap a b s t -> (a -> b) -> s -> t
type PM a = State (a, Int)
new :: PM a String
write :: a -> PM [a] ()
run :: PM [a] r -> (r, [a])
extractAttr :: String -> Tag -> a -> PM [(Symbol, a)] PrimExpr
extractAttrPE :: (a -> String -> String) -> Tag -> a -> PM [(Symbol, a)] PrimExpr
instance ProductProfunctor (PackMap a b)
instance Profunctor (PackMap a b)
instance Applicative (PackMap a b s)
instance Functor (PackMap a b s)

module Opaleye.Internal.Column

-- | The <a>Num</a> and <a>Fractional</a> instances for <a>Column</a>
--   <tt>a</tt> are too general. For example, they allow you to add two
--   <a>Column</a> <a>String</a>s. This will be fixed in a subsequent
--   release.
newtype Column a
Column :: PrimExpr -> Column a
data Nullable a
Nullable :: Nullable a
unColumn :: Column a -> PrimExpr
unsafeCoerce :: Column a -> Column b
binOp :: BinOp -> Column a -> Column b -> Column c
unOp :: UnOp -> Column a -> Column b
unsafeCase_ :: [(Column pgBool, Column a)] -> Column a -> Column a
unsafeIfThenElse :: Column pgBool -> Column a -> Column a -> Column a
unsafeGt :: Column a -> Column a -> Column pgBool
unsafeEq :: Column a -> Column a -> Column pgBool
class PGNum a
pgFromInteger :: PGNum a => Integer -> Column a
class PGFractional a
pgFromRational :: PGFractional a => Rational -> Column a
instance Show (Column a)
instance (PGNum a, PGFractional a) => Fractional (Column a)
instance PGNum a => Num (Column a)

module Opaleye.Internal.Binary
extractBinaryFields :: Tag -> (PrimExpr, PrimExpr) -> PM [(Symbol, (PrimExpr, PrimExpr))] PrimExpr
data Binaryspec columns columns'
Binaryspec :: (PackMap (PrimExpr, PrimExpr) PrimExpr (columns, columns) columns') -> Binaryspec columns columns'
runBinaryspec :: Applicative f => Binaryspec columns columns' -> ((PrimExpr, PrimExpr) -> f PrimExpr) -> (columns, columns) -> f columns'
binaryspecColumn :: Binaryspec (Column a) (Column a)
instance ProductProfunctor Binaryspec
instance Profunctor Binaryspec
instance Applicative (Binaryspec a)
instance Functor (Binaryspec a)
instance Default Binaryspec (Column a) (Column a)

module Opaleye.Internal.HaskellDB.Sql.Generate
data SqlGenerator
SqlGenerator :: (TableName -> [PrimExpr] -> Assoc -> SqlUpdate) -> (TableName -> [PrimExpr] -> SqlDelete) -> (TableName -> Assoc -> SqlInsert) -> (PrimExpr -> SqlExpr) -> (Literal -> String) -> (String -> String) -> SqlGenerator
sqlUpdate :: SqlGenerator -> TableName -> [PrimExpr] -> Assoc -> SqlUpdate
sqlDelete :: SqlGenerator -> TableName -> [PrimExpr] -> SqlDelete
sqlInsert :: SqlGenerator -> TableName -> Assoc -> SqlInsert
sqlExpr :: SqlGenerator -> PrimExpr -> SqlExpr
sqlLiteral :: SqlGenerator -> Literal -> String

-- | Turn a string into a quoted string. Quote characters and any escaping
--   are handled by this function.
sqlQuote :: SqlGenerator -> String -> String

module Opaleye.Internal.HaskellDB.Sql.Default
mkSqlGenerator :: SqlGenerator -> SqlGenerator
defaultSqlGenerator :: SqlGenerator
toSqlOrder :: SqlGenerator -> OrderExpr -> (SqlExpr, SqlOrder)
toSqlAssoc :: SqlGenerator -> Assoc -> [(SqlColumn, SqlExpr)]
defaultSqlUpdate :: SqlGenerator -> TableName -> [PrimExpr] -> Assoc -> SqlUpdate
defaultSqlInsert :: SqlGenerator -> TableName -> Assoc -> SqlInsert
defaultSqlDelete :: SqlGenerator -> TableName -> [PrimExpr] -> SqlDelete
defaultSqlExpr :: SqlGenerator -> PrimExpr -> SqlExpr
showBinOp :: BinOp -> String
data UnOpType
UnOpFun :: UnOpType
UnOpPrefix :: UnOpType
UnOpPostfix :: UnOpType
sqlUnOp :: UnOp -> (String, UnOpType)
showAggrOp :: AggrOp -> String
defaultSqlLiteral :: SqlGenerator -> Literal -> String
defaultSqlQuote :: SqlGenerator -> String -> String

-- | Quote a string and escape characters that need escaping We use
--   Postgres "escape strings", i.e. strings prefixed with E, to ensure
--   that escaping with backslash is valid.
quote :: String -> String

-- | Escape characters that need escaping
escape :: Char -> String

-- | Quote binary literals using Postgresql's hex format.
binQuote :: ByteString -> String

module Opaleye.Internal.Sql
data Select
SelectFrom :: From -> Select
Table :: SqlTable -> Select
SelectJoin :: Join -> Select
SelectValues :: Values -> Select
SelectBinary :: Binary -> Select
data From
From :: [(SqlExpr, Maybe SqlColumn)] -> [Select] -> [SqlExpr] -> [SqlExpr] -> [(SqlExpr, SqlOrder)] -> Maybe Int -> Maybe Int -> From
attrs :: From -> [(SqlExpr, Maybe SqlColumn)]
tables :: From -> [Select]
criteria :: From -> [SqlExpr]
groupBy :: From -> [SqlExpr]
orderBy :: From -> [(SqlExpr, SqlOrder)]
limit :: From -> Maybe Int
offset :: From -> Maybe Int
data Join
Join :: JoinType -> [(SqlExpr, Maybe SqlColumn)] -> (Select, Select) -> SqlExpr -> Join
jJoinType :: Join -> JoinType
jAttrs :: Join -> [(SqlExpr, Maybe SqlColumn)]
jTables :: Join -> (Select, Select)
jCond :: Join -> SqlExpr
data Values
Values :: [(SqlExpr, Maybe SqlColumn)] -> [[SqlExpr]] -> Values
vAttrs :: Values -> [(SqlExpr, Maybe SqlColumn)]
vValues :: Values -> [[SqlExpr]]
data Binary
Binary :: BinOp -> Select -> Select -> Binary
bOp :: Binary -> BinOp
bSelect1 :: Binary -> Select
bSelect2 :: Binary -> Select
data JoinType
LeftJoin :: JoinType
data BinOp
Except :: BinOp
Union :: BinOp
UnionAll :: BinOp
data TableName
String :: TableName
data Returning a
Returning :: a -> [SqlExpr] -> Returning a
sqlQueryGenerator :: PrimQueryFold Select
sql :: ([PrimExpr], PrimQuery, Tag) -> Select
unit :: Select
baseTable :: String -> [(Symbol, PrimExpr)] -> Select
product :: NonEmpty Select -> [PrimExpr] -> Select
aggregate :: [(Symbol, (Maybe AggrOp, PrimExpr))] -> Select -> Select
aggrExpr :: Maybe AggrOp -> PrimExpr -> PrimExpr
order :: [OrderExpr] -> Select -> Select
limit_ :: LimitOp -> Select -> Select
join :: JoinType -> [(Symbol, PrimExpr)] -> PrimExpr -> Select -> Select -> Select
values :: [Symbol] -> [[PrimExpr]] -> Select
binary :: BinOp -> [(Symbol, (PrimExpr, PrimExpr))] -> (Select, Select) -> Select
joinType :: JoinType -> JoinType
binOp :: BinOp -> BinOp
newSelect :: From
sqlExpr :: PrimExpr -> SqlExpr
sqlBinding :: (Symbol, PrimExpr) -> (SqlExpr, Maybe SqlColumn)
instance Show Values
instance Show JoinType
instance Show BinOp
instance Show Binary
instance Show Select
instance Show Join
instance Show From

module Opaleye.Internal.Print
ppSql :: Select -> Doc
ppSelectFrom :: From -> Doc
ppSelectJoin :: Join -> Doc
ppSelectValues :: Values -> Doc
ppSelectBinary :: Binary -> Doc
ppJoinType :: JoinType -> Doc
ppAttrs :: [(SqlExpr, Maybe SqlColumn)] -> Doc
nameAs :: (SqlExpr, Maybe SqlColumn) -> Doc
ppTables :: [Select] -> Doc
tableAlias :: Int -> Select -> (SqlTable, Select)
ppTable :: (SqlTable, Select) -> Doc
ppGroupBy :: [SqlExpr] -> Doc
ppLimit :: Maybe Int -> Doc
ppOffset :: Maybe Int -> Doc
ppValues :: [[SqlExpr]] -> Doc
ppValuesRow :: [SqlExpr] -> Doc
ppBinOp :: BinOp -> Doc
ppInsertReturning :: Returning SqlInsert -> Doc

module Opaleye.Internal.Aggregate

-- | An <a>Aggregator</a> takes a collection of rows of type <tt>a</tt>,
--   groups them, and transforms each group into a single row of type
--   <tt>b</tt>. This corresponds to aggregators using <tt>GROUP BY</tt> in
--   SQL.
newtype Aggregator a b
Aggregator :: (PackMap (Maybe AggrOp, PrimExpr) PrimExpr a b) -> Aggregator a b
makeAggr' :: Maybe AggrOp -> Aggregator (Column a) (Column b)
makeAggr :: AggrOp -> Aggregator (Column a) (Column b)
runAggregator :: Applicative f => Aggregator a b -> ((Maybe AggrOp, PrimExpr) -> f PrimExpr) -> a -> f b
aggregateU :: Aggregator a b -> (a, PrimQuery, Tag) -> (b, PrimQuery, Tag)
extractAggregateFields :: Tag -> (Maybe AggrOp, PrimExpr) -> PM [(Symbol, (Maybe AggrOp, PrimExpr))] PrimExpr
instance ProductProfunctor Aggregator
instance Profunctor Aggregator
instance Applicative (Aggregator a)
instance Functor (Aggregator a)

module Opaleye.PGTypes
data PGBool
data PGDate
data PGFloat4
data PGFloat8
data PGInt8
data PGInt4
data PGInt2
data PGNumeric
data PGText
data PGTime
data PGTimestamp
data PGTimestamptz
data PGUuid
data PGCitext
data PGArray a
data PGBytea
literalColumn :: Literal -> Column a
pgString :: String -> Column PGText
pgLazyByteString :: ByteString -> Column PGBytea
pgStrictByteString :: ByteString -> Column PGBytea
pgStrictText :: Text -> Column PGText
pgLazyText :: Text -> Column PGText
pgInt4 :: Int -> Column PGInt4
pgInt8 :: Int64 -> Column PGInt8
pgDouble :: Double -> Column PGFloat8
pgBool :: Bool -> Column PGBool
pgUUID :: UUID -> Column PGUuid
unsafePgFormatTime :: FormatTime t => Name -> String -> t -> Column c
pgDay :: Day -> Column PGDate
pgUTCTime :: UTCTime -> Column PGTimestamptz
pgLocalTime :: LocalTime -> Column PGTimestamp
pgTimeOfDay :: TimeOfDay -> Column PGTime
pgCiStrictText :: CI Text -> Column PGCitext
pgCiLazyText :: CI Text -> Column PGCitext
instance PGFractional PGFloat8
instance PGNum PGInt8
instance PGNum PGInt4
instance PGNum PGFloat8

module Opaleye.Column

-- | A NULL of any type
null :: Column (Nullable a)
isNull :: Column (Nullable a) -> Column PGBool

-- | If the <tt>Column (Nullable a)</tt> is NULL then return the <tt>Column
--   b</tt> otherwise map the underlying <tt>Column a</tt> using the
--   provided function.
--   
--   The Opaleye equivalent of the <a>maybe</a> function.
matchNullable :: Column b -> (Column a -> Column b) -> Column (Nullable a) -> Column b

-- | If the <tt>Column (Nullable a)</tt> is NULL then return the provided
--   <tt>Column a</tt> otherwise return the underlying <tt>Column a</tt>.
--   
--   The Opaleye equivalent of the <a>fromMaybe</a> function
fromNullable :: Column a -> Column (Nullable a) -> Column a

-- | The Opaleye equivalent of <a>Just</a>
toNullable :: Column a -> Column (Nullable a)

-- | If the argument is <a>Nothing</a> return NULL otherwise return the
--   provided value coerced to a nullable type.
maybeToNullable :: Maybe (Column a) -> Column (Nullable a)

-- | Cast a column to any other type. This is safe for some conversions
--   such as uuid to text.
unsafeCast :: String -> Column a -> Column b

-- | The <a>Num</a> and <a>Fractional</a> instances for <a>Column</a>
--   <tt>a</tt> are too general. For example, they allow you to add two
--   <a>Column</a> <a>String</a>s. This will be fixed in a subsequent
--   release.
data Column a
data Nullable a
unsafeCoerce :: Column a -> Column b

module Opaleye.Internal.Unpackspec
newtype Unpackspec columns columns'
Unpackspec :: (PackMap PrimExpr PrimExpr columns columns') -> Unpackspec columns columns'
unpackspecColumn :: Unpackspec (Column a) (Column a)
runUnpackspec :: Applicative f => Unpackspec columns b -> (PrimExpr -> f PrimExpr) -> columns -> f b
instance ProductProfunctor Unpackspec
instance Profunctor Unpackspec
instance Applicative (Unpackspec a)
instance Functor (Unpackspec a)
instance Default Unpackspec (Column a) (Column a)

module Opaleye.Internal.QueryArr
newtype QueryArr a b
QueryArr :: ((a, PrimQuery, Tag) -> (b, PrimQuery, Tag)) -> QueryArr a b
type Query = QueryArr ()
simpleQueryArr :: ((a, Tag) -> (b, PrimQuery, Tag)) -> QueryArr a b
runQueryArr :: QueryArr a b -> (a, PrimQuery, Tag) -> (b, PrimQuery, Tag)
runSimpleQueryArr :: QueryArr a b -> (a, Tag) -> (b, PrimQuery, Tag)
runQueryArrUnpack :: Unpackspec a b -> Query a -> ([PrimExpr], PrimQuery, Tag)
first3 :: (a1 -> b) -> (a1, a2, a3) -> (b, a2, a3)
instance ProductProfunctor QueryArr
instance Profunctor QueryArr
instance Applicative (QueryArr a)
instance Functor (QueryArr a)
instance Arrow QueryArr
instance Category QueryArr

module Opaleye.Operators

-- | Restrict query results to a particular condition. Corresponds to the
--   guard method of the MonadPlus class.
restrict :: QueryArr (Column PGBool) ()
doubleOfInt :: Column PGInt4 -> Column PGFloat8
(.==) :: Column a -> Column a -> Column PGBool
(./=) :: Column a -> Column a -> Column PGBool
(.>) :: Column a -> Column a -> Column PGBool
(.<) :: Column a -> Column a -> Column PGBool
(.<=) :: Column a -> Column a -> Column PGBool
(.>=) :: Column a -> Column a -> Column PGBool
case_ :: [(Column PGBool, Column a)] -> Column a -> Column a
ifThenElse :: Column PGBool -> Column a -> Column a -> Column a
(.&&) :: Column PGBool -> Column PGBool -> Column PGBool
(.||) :: Column PGBool -> Column PGBool -> Column PGBool
not :: Column PGBool -> Column PGBool
(.++) :: Column PGText -> Column PGText -> Column PGText
lower :: Column PGText -> Column PGText
upper :: Column PGText -> Column PGText
like :: Column PGText -> Column PGText -> Column PGBool


-- | This modules defines the <a>QueryArr</a> arrow, which is an arrow that
--   represents selecting data from a database, and composing multiple
--   queries together.
module Opaleye.QueryArr
data QueryArr a b
type Query = QueryArr ()

module Opaleye.Sql

-- | Example type specialization:
--   
--   <pre>
--   showSqlForPostgres :: Query (Column a, Column b) -&gt; String
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   showSqlForPostgres :: Query (Foo (Column a) (Column b) (Column c)) -&gt; String
--   </pre>
showSqlForPostgres :: Default Unpackspec columns columns => Query columns -> String
showSqlForPostgresUnopt :: Default Unpackspec columns columns => Query columns -> String
showSqlForPostgresExplicit :: Unpackspec columns b -> Query columns -> String
showSqlForPostgresUnoptExplicit :: Unpackspec columns b -> Query columns -> String
formatAndShowSQL :: ([PrimExpr], PrimQuery, Tag) -> String

module Opaleye.Internal.Values
valuesU :: Unpackspec columns columns' -> Valuesspec columns columns' -> [columns] -> ((), Tag) -> (columns', PrimQuery, Tag)
extractValuesEntry :: PrimExpr -> PM [PrimExpr] PrimExpr
extractValuesField :: Tag -> PrimExpr -> PM [(Symbol, PrimExpr)] PrimExpr
data Valuesspec columns columns'
Valuesspec :: (PackMap PrimExpr PrimExpr () columns') -> Valuesspec columns columns'
runValuesspec :: Applicative f => Valuesspec columns columns' -> (PrimExpr -> f PrimExpr) -> f columns'
instance ProductProfunctor Valuesspec
instance Profunctor Valuesspec
instance Applicative (Valuesspec a)
instance Functor (Valuesspec a)
instance Default Valuesspec (Column PGInt4) (Column PGInt4)

module Opaleye.Values

-- | Example type specialization:
--   
--   <pre>
--   values :: [(Column a, Column b)] -&gt; Query (Column a, Column b)
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   queryTable :: [Foo (Column a) (Column b) (Column c)] -&gt; Query (Foo (Column a) (Column b) (Column c))
--   </pre>
values :: (Default Valuesspec columns columns, Default Unpackspec columns columns) => [columns] -> Query columns
valuesExplicit :: Unpackspec columns columns' -> Valuesspec columns columns' -> [columns] -> Query columns'

module Opaleye.Internal.Join
data NullMaker a b
NullMaker :: (a -> b) -> NullMaker a b
toNullable :: NullMaker a b -> a -> b
extractLeftJoinFields :: Int -> Tag -> PrimExpr -> PM [(Symbol, PrimExpr)] PrimExpr
instance ProductProfunctor NullMaker
instance Profunctor NullMaker
instance Default NullMaker (Column (Nullable a)) (Column (Nullable a))
instance Default NullMaker (Column a) (Column (Nullable a))

module Opaleye.Join

-- | <tt>leftJoin</tt>'s use of the <a>Default</a> typeclass means that the
--   compiler will have trouble inferring types. It is strongly recommended
--   that you provide full type signatures when using <tt>leftJoin</tt>.
--   
--   Example specialization:
--   
--   <pre>
--   leftJoin :: Query (Column a, Column b)
--            -&gt; Query (Column c, Column (Nullable d))
--            -&gt; (((Column a, Column b), (Column c, Column (Nullable d))) -&gt; Column <a>PGBool</a>)
--            -&gt; Query ((Column a, Column b), (Column (Nullable c), Column (Nullable d)))
--   </pre>
leftJoin :: (Default Unpackspec columnsA columnsA, Default Unpackspec columnsB columnsB, Default NullMaker columnsB nullableColumnsB) => Query columnsA -> Query columnsB -> ((columnsA, columnsB) -> Column PGBool) -> Query (columnsA, nullableColumnsB)
leftJoinExplicit :: Unpackspec columnsA columnsA -> Unpackspec columnsB columnsB -> NullMaker columnsB nullableColumnsB -> Query columnsA -> Query columnsB -> ((columnsA, columnsB) -> Column PGBool) -> Query (columnsA, nullableColumnsB)

module Opaleye.Internal.RunQuery
data QueryRunnerColumn coltype haskell
QueryRunnerColumn :: (Unpackspec (Column coltype) ()) -> (FieldParser haskell) -> QueryRunnerColumn coltype haskell
data QueryRunner columns haskells
QueryRunner :: (Unpackspec columns ()) -> (RowParser haskells) -> QueryRunner columns haskells
fieldQueryRunnerColumn :: FromField haskell => QueryRunnerColumn coltype haskell
queryRunner :: QueryRunnerColumn a b -> QueryRunner (Column a) b
queryRunnerColumnNullable :: QueryRunnerColumn a b -> QueryRunnerColumn (Nullable a) (Maybe b)
class QueryRunnerColumnDefault a b
queryRunnerColumnDefault :: QueryRunnerColumnDefault a b => QueryRunnerColumn a b
arrayColumn :: Column (PGArray a) -> Column a
arrayFieldParser :: Typeable a => FieldParser a -> FieldParser (PGArray a)
fromArray :: FieldParser a -> TypeInfo -> Field -> Parser (Conversion [a])
instance ProductProfunctor QueryRunner
instance Profunctor QueryRunner
instance Applicative (QueryRunner c)
instance Functor (QueryRunner c)
instance (Typeable b, QueryRunnerColumnDefault a b) => QueryRunnerColumnDefault (PGArray a) [b]
instance QueryRunnerColumnDefault PGCitext (CI Text)
instance QueryRunnerColumnDefault PGCitext (CI Text)
instance QueryRunnerColumnDefault PGTime TimeOfDay
instance QueryRunnerColumnDefault PGTimestamp LocalTime
instance QueryRunnerColumnDefault PGTimestamptz UTCTime
instance QueryRunnerColumnDefault PGDate Day
instance QueryRunnerColumnDefault PGText Text
instance QueryRunnerColumnDefault PGText Text
instance QueryRunnerColumnDefault PGBytea ByteString
instance QueryRunnerColumnDefault PGBytea ByteString
instance QueryRunnerColumnDefault PGUuid UUID
instance QueryRunnerColumnDefault PGBool Bool
instance QueryRunnerColumnDefault PGFloat8 Double
instance QueryRunnerColumnDefault PGText String
instance QueryRunnerColumnDefault PGInt8 Int64
instance QueryRunnerColumnDefault PGInt4 Int
instance QueryRunnerColumnDefault a b => Default QueryRunner (Column a) b
instance QueryRunnerColumnDefault a b => QueryRunnerColumnDefault (Nullable a) (Maybe b)

module Opaleye.RunQuery

-- | <tt>runQuery</tt>'s use of the <a>Default</a> typeclass means that the
--   compiler will have trouble inferring types. It is strongly recommended
--   that you provide full type signatures when using <tt>runQuery</tt>.
--   
--   Example type specialization:
--   
--   <pre>
--   runQuery :: Query (Column <a>PGInt4</a>, Column <a>PGText</a>) -&gt; IO [(Column Int, Column String)]
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   runQuery :: Query (Foo (Column <a>PGInt4</a>) (Column <a>PGText</a>) (Column <a>PGBool</a>)
--            -&gt; IO [(Foo (Column Int) (Column String) (Column Bool)]
--   </pre>
--   
--   Opaleye types are converted to Haskell types based on instances of the
--   <a>QueryRunnerColumnDefault</a> typeclass.
runQuery :: Default QueryRunner columns haskells => Connection -> Query columns -> IO [haskells]
runQueryExplicit :: QueryRunner columns haskells -> Connection -> Query columns -> IO [haskells]

-- | Use <a>queryRunnerColumn</a> to make an instance to allow you to run
--   queries on your own datatypes. For example:
--   
--   <pre>
--   newtype Foo = Foo Int
--   instance Default QueryRunnerColumn Foo Foo where
--      def = queryRunnerColumn (<a>unsafeCoerce</a> :: Column Foo -&gt; Column PGInt4) Foo def
--   </pre>
queryRunnerColumn :: (Column a' -> Column a) -> (b -> b') -> QueryRunnerColumn a b -> QueryRunnerColumn a' b'
data QueryRunner columns haskells
data QueryRunnerColumn coltype haskell
fieldQueryRunnerColumn :: FromField haskell => QueryRunnerColumn coltype haskell

module Opaleye.Internal.Order
data SingleOrder a
SingleOrder :: OrderOp -> (a -> PrimExpr) -> SingleOrder a

-- | An <a>Order</a> represents an expression to order on and a sort
--   direction. Multiple <a>Order</a>s can be composed with <a>mappend</a>.
--   If two rows are equal according to the first <a>Order</a>, the second
--   is used, and so on.
newtype Order a
Order :: [SingleOrder a] -> Order a
order :: OrderOp -> (a -> Column b) -> Order a
orderByU :: Order a -> (a, PrimQuery, Tag) -> (a, PrimQuery, Tag)
limit' :: Int -> (a, PrimQuery, Tag) -> (a, PrimQuery, Tag)
offset' :: Int -> (a, PrimQuery, Tag) -> (a, PrimQuery, Tag)
instance Monoid (Order a)
instance Contravariant Order
instance Contravariant SingleOrder

module Opaleye.Order

-- | Order the rows of a <a>Query</a> according to the <tt>Order</tt>.
orderBy :: Order a -> Query a -> Query a

-- | Specify an ascending ordering by the given expression.
asc :: (a -> Column b) -> Order a

-- | Specify an descending ordering by the given expression.
desc :: (a -> Column b) -> Order a

-- | Limit the results of the given query to the given maximum number of
--   items.
limit :: Int -> Query a -> Query a

-- | Offset the results of the given query by the given amount, skipping
--   that many result rows.
offset :: Int -> Query a -> Query a

-- | An <a>Order</a> represents an expression to order on and a sort
--   direction. Multiple <a>Order</a>s can be composed with <a>mappend</a>.
--   If two rows are equal according to the first <a>Order</a>, the second
--   is used, and so on.
data Order a

module Opaleye.Internal.TableMaker
newtype ViewColumnMaker strings columns
ViewColumnMaker :: (PackMap () () strings columns) -> ViewColumnMaker strings columns
newtype ColumnMaker columns columns'
ColumnMaker :: (PackMap PrimExpr PrimExpr columns columns') -> ColumnMaker columns columns'
runViewColumnMaker :: ViewColumnMaker strings tablecolumns -> strings -> tablecolumns
runColumnMaker :: Applicative f => ColumnMaker tablecolumns columns -> (PrimExpr -> f PrimExpr) -> tablecolumns -> f columns
tableColumn :: ViewColumnMaker String (Column a)
column :: ColumnMaker (Column a) (Column a)
instance ProductProfunctor ColumnMaker
instance Profunctor ColumnMaker
instance Applicative (ColumnMaker a)
instance Functor (ColumnMaker a)
instance ProductProfunctor ViewColumnMaker
instance Profunctor ViewColumnMaker
instance Applicative (ViewColumnMaker a)
instance Functor (ViewColumnMaker a)
instance Default ColumnMaker (Column a) (Column a)
instance Default ViewColumnMaker String (Column a)

module Opaleye.Internal.Table

-- | Define a table as follows, where "id", "color", "location", "quantity"
--   and "radius" are the tables columns in Postgres and the types are
--   given in the type signature. The <tt>id</tt> field is an
--   autoincrementing field (i.e. optional for writes).
--   
--   <pre>
--   data Widget a b c d e = Widget { wid      :: a
--                                  , color    :: b
--                                  , location :: c
--                                  , quantity :: d
--                                  , radius   :: e }
--   
--   $(<a>makeAdaptorAndInstance</a> "pWidget" ''Widget)
--   
--   widgetTable :: Table (Widget (Maybe (Column PGInt4)) (Column PGText) (Column PGText)
--                                (Column PGInt4) (Column PGFloat8))
--                        (Widget (Column PGText) (Column PGText) (Column PGText)
--                                (Column PGInt4) (Column PGFloat8))
--   widgetTable = Table "widgetTable"
--                        (pWidget Widget { wid      = optional "id"
--                                        , color    = required "color"
--                                        , location = required "location"
--                                        , quantity = required "quantity"
--                                        , radius   = required "radius" })
--   </pre>
data Table writerColumns viewColumns
Table :: String -> (TableProperties writerColumns viewColumns) -> Table writerColumns viewColumns
data TableProperties writerColumns viewColumns
TableProperties :: (Writer writerColumns viewColumns) -> (View viewColumns) -> TableProperties writerColumns viewColumns
data View columns
View :: columns -> View columns
data Writer columns dummy
Writer :: (PackMap (PrimExpr, String) () columns ()) -> Writer columns dummy
queryTable :: ColumnMaker viewColumns columns -> Table writerColumns viewColumns -> Tag -> (columns, PrimQuery)
runColumnMaker :: ColumnMaker tablecolumns columns -> Tag -> tablecolumns -> (columns, [(Symbol, PrimExpr)])
runWriter :: Writer columns columns' -> columns -> [(PrimExpr, String)]
required :: String -> Writer (Column a) (Column a)
optional :: String -> Writer (Maybe (Column a)) (Column a)
instance Functor (Table a)
instance ProductProfunctor TableProperties
instance Profunctor TableProperties
instance Applicative (TableProperties a)
instance Functor (TableProperties a)
instance ProductProfunctor Writer
instance Profunctor Writer
instance Applicative (Writer a)
instance Functor (Writer a)

module Opaleye.Table

-- | Example type specialization:
--   
--   <pre>
--   queryTable :: Table w (Column a, Column b) -&gt; Query (Column a, Column b)
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   queryTable :: Table w (Foo (Column a) (Column b) (Column c)) -&gt; Query (Foo (Column a) (Column b) (Column c))
--   </pre>
queryTable :: Default ColumnMaker columns columns => Table a columns -> Query columns
queryTableExplicit :: ColumnMaker tablecolumns columns -> Table a tablecolumns -> Query columns
required :: String -> TableProperties (Column a) (Column a)
optional :: String -> TableProperties (Maybe (Column a)) (Column a)
data View columns
data Writer columns dummy

-- | Define a table as follows, where "id", "color", "location", "quantity"
--   and "radius" are the tables columns in Postgres and the types are
--   given in the type signature. The <tt>id</tt> field is an
--   autoincrementing field (i.e. optional for writes).
--   
--   <pre>
--   data Widget a b c d e = Widget { wid      :: a
--                                  , color    :: b
--                                  , location :: c
--                                  , quantity :: d
--                                  , radius   :: e }
--   
--   $(<a>makeAdaptorAndInstance</a> "pWidget" ''Widget)
--   
--   widgetTable :: Table (Widget (Maybe (Column PGInt4)) (Column PGText) (Column PGText)
--                                (Column PGInt4) (Column PGFloat8))
--                        (Widget (Column PGText) (Column PGText) (Column PGText)
--                                (Column PGInt4) (Column PGFloat8))
--   widgetTable = Table "widgetTable"
--                        (pWidget Widget { wid      = optional "id"
--                                        , color    = required "color"
--                                        , location = required "location"
--                                        , quantity = required "quantity"
--                                        , radius   = required "radius" })
--   </pre>
data Table writerColumns viewColumns
Table :: String -> (TableProperties writerColumns viewColumns) -> Table writerColumns viewColumns
data TableProperties writerColumns viewColumns

module Opaleye.Manipulation
arrangeInsert :: Table columns a -> columns -> SqlInsert
arrangeInsertSql :: Table columns a -> columns -> String
runInsert :: Connection -> Table columns columns' -> columns -> IO Int64
arrangeUpdate :: Table columnsW columnsR -> (columnsR -> columnsW) -> (columnsR -> Column PGBool) -> SqlUpdate
arrangeUpdateSql :: Table columnsW columnsR -> (columnsR -> columnsW) -> (columnsR -> Column PGBool) -> String
runUpdate :: Connection -> Table columnsW columnsR -> (columnsR -> columnsW) -> (columnsR -> Column PGBool) -> IO Int64
arrangeDelete :: Table a columnsR -> (columnsR -> Column PGBool) -> SqlDelete
arrangeDeleteSql :: Table a columnsR -> (columnsR -> Column PGBool) -> String
runDelete :: Connection -> Table a columnsR -> (columnsR -> Column PGBool) -> IO Int64
arrangeInsertReturning :: Unpackspec returned returned -> Table columnsW columnsR -> columnsW -> (columnsR -> returned) -> Returning SqlInsert
arrangeInsertReturningSql :: Unpackspec returned returned -> Table columnsW columnsR -> columnsW -> (columnsR -> returned) -> String
runInsertReturningExplicit :: QueryRunner returned haskells -> Unpackspec returned returned -> Connection -> Table columnsW columnsR -> columnsW -> (columnsR -> returned) -> IO [haskells]

-- | <tt>runInsertReturning</tt>'s use of the <a>Default</a> typeclass
--   means that the compiler will have trouble inferring types. It is
--   strongly recommended that you provide full type signatures when using
--   <tt>runInsertReturning</tt>.
runInsertReturning :: (Default QueryRunner returned haskells, Default Unpackspec returned returned) => Connection -> Table columnsW columnsR -> columnsW -> (columnsR -> returned) -> IO [haskells]
data Unpackspec columns columns'

module Opaleye.Binary

-- | Example type specialization:
--   
--   <pre>
--   unionAll :: Query (Column a, Column b)
--            -&gt; Query (Column a, Column b)
--            -&gt; Query (Column a, Column b)
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   unionAll :: Query (Foo (Column a) (Column b) (Column c))
--            -&gt; Query (Foo (Column a) (Column b) (Column c))
--            -&gt; Query (Foo (Column a) (Column b) (Column c))
--   </pre>
unionAll :: Default Binaryspec columns columns => Query columns -> Query columns -> Query columns
unionAllExplicit :: Binaryspec columns columns' -> Query columns -> Query columns -> Query columns'


-- | Perform aggregations on query results.
module Opaleye.Aggregate

-- | Given a <a>Query</a> producing rows of type <tt>a</tt> and an
--   <a>Aggregator</a> accepting rows of type <tt>a</tt>, apply the
--   aggregator to the results of the query.
aggregate :: Aggregator a b -> Query a -> Query b

-- | Group the aggregation by equality on the input to <a>groupBy</a>.
groupBy :: Aggregator (Column a) (Column a)

-- | Sum all rows in a group.
sum :: Aggregator (Column a) (Column a)

-- | Count the number of non-null rows in a group.
count :: Aggregator (Column a) (Column PGInt8)

-- | Average of a group
avg :: Aggregator (Column PGFloat8) (Column PGFloat8)

-- | Maximum of a group
max :: Aggregator (Column a) (Column a)

-- | Maximum of a group
min :: Aggregator (Column a) (Column a)
boolOr :: Aggregator (Column PGBool) (Column PGBool)
boolAnd :: Aggregator (Column PGBool) (Column PGBool)

-- | An <a>Aggregator</a> takes a collection of rows of type <tt>a</tt>,
--   groups them, and transforms each group into a single row of type
--   <tt>b</tt>. This corresponds to aggregators using <tt>GROUP BY</tt> in
--   SQL.
data Aggregator a b

module Opaleye.Internal.Distinct
distinctExplicit :: Distinctspec columns columns' -> Query columns -> Query columns'
data Distinctspec a b
Distinctspec :: (Aggregator a b) -> Distinctspec a b
instance ProductProfunctor Distinctspec
instance Profunctor Distinctspec
instance Applicative (Distinctspec a)
instance Functor (Distinctspec a)
instance Default Distinctspec (Column a) (Column a)

module Opaleye.Distinct

-- | Remove duplicate items from the query result.
--   
--   Example type specialization:
--   
--   <pre>
--   distinct :: Query (Column a, Column b) -&gt; Query (Column a, Column b)
--   </pre>
--   
--   Assuming the <tt>makeAdaptorAndInstance</tt> splice has been run for
--   the product type <tt>Foo</tt>:
--   
--   <pre>
--   distinct :: Query (Foo (Column a) (Column b) (Column c)) -&gt; Query (Foo (Column a) (Column b) (Column c))
--   </pre>
distinct :: Default Distinctspec columns columns => Query columns -> Query columns
distinctExplicit :: Distinctspec columns columns' -> Query columns -> Query columns'

module Opaleye
