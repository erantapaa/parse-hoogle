-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | hmac authentication tools for WAI apps
--   
--   authenticate requests made to your WAI apps using HMAC.
@package wai-hmac-auth
@version 1.0.0


-- | you should only need the contents of the types and tools sections, but
--   all the functions in this module are exported just in case.
module Network.Wai.Auth.HMAC

-- | a newtype wrapper for api keys
newtype ApiKey
ApiKey :: ByteString -> ApiKey

-- | newtype wrapper for secret keys
newtype SecretKey
SecretKey :: ByteString -> SecretKey

-- | specification for how the api key should be found in the request
data ApiKeySpec

-- | look for a query parameter with the specified name
QueryParamKey :: ByteString -> ApiKeySpec

-- | look for the header with this name
HeaderKey :: HeaderName -> ApiKeySpec

-- | request configuration specifies how to perform hmac signing and
--   authentication on the request - i.e. where the api key will be found,
--   where the timestamp is stored, how the signature is added to the
--   request, and the hash algorithm to use.
data RequestConfig alg
RequestConfig :: ApiKeySpec -> HeaderName -> HeaderName -> alg -> RequestConfig alg
keySpec :: RequestConfig alg -> ApiKeySpec
timestampHeader :: RequestConfig alg -> HeaderName
signatureHeader :: RequestConfig alg -> HeaderName
hashAlgorithm :: RequestConfig alg -> alg

-- | all of the way that signing or authentication can fail.
data AuthFailure

-- | the request does not have an api key value that fits the spec
MissingApiKey :: ApiKeySpec -> AuthFailure

-- | the request does not have a timestamp header
MissingTimestampHeader :: HeaderName -> AuthFailure

-- | the request does not have a signature header (<a>authenticate</a>
--   only)
MissingSignatureHeader :: HeaderName -> AuthFailure

-- | the signature was not url-safe base 64 encoded properly (authenticate
--   only)
SignatureBase64DecodeFailed :: String -> AuthFailure

-- | the signature was not a properly encoded hash digest (e.g. for the
--   hash algorithm being used) (authenticate only)
SignatureToDigestFailed :: AuthFailure

-- | the signature generated from the request did not match the signature
--   contained within the reqest (authenticate only)
HashMismatch :: AuthFailure

-- | default request configuration
--   
--   <pre>
--   defaultRequestConfig = <a>RequestConfig</a> <a>defaultApiKeySpec</a> "x-auth-timestamp" "x-auth-signature" <a>SHA256</a>
--   </pre>
defaultRequestConfig :: RequestConfig SHA256

-- | default spec for getting the api key
--   
--   <pre>
--   defaultApiKeySpec = <a>QueryParamKey</a> "apiKey"
--   </pre>
defaultApiKeySpec :: ApiKeySpec

-- | use this to get the api key from the request according to spec
getApiKey :: ApiKeySpec -> Request -> Maybe ApiKey

-- | authenticate the request according to the configuration and secret
--   key. if it succeeds, produces a request with a requestBody that will
--   produce the same chunk sequence as the original. if it fails, it will
--   explain why.
authenticate :: HashAlgorithm alg => RequestConfig alg -> Request -> SecretKey -> IO (Either AuthFailure Request)

-- | signs a request in accordance with the config. mostly for testing.
signRequest :: HashAlgorithm alg => RequestConfig alg -> Request -> SecretKey -> IO (Either AuthFailure Request)

-- | the operation performed by <a>authenticate</a>
checkRequestHmac :: (MonadIO m, HasReqConf alg m, AuthErrorsM m) => Request -> SecretKey -> m Request

-- | the operation performed by <a>signRequest</a>
addSignatureToRequest :: (MonadIO m, HasReqConf alg m, AuthErrorsM m) => Request -> SecretKey -> m Request

-- | a constraint alias for functions that need to access request
--   configuration
type HasReqConf alg m = (HashAlgorithm alg, MonadReader (RequestConfig alg) m, Functor m)

-- | a constrain alias for functions that can fail
type AuthErrorsM m = MonadError AuthFailure m

-- | a constraint alias for functions that save chunks of the request body
type WriteChunks m = MonadWriter (Seq ByteString) m

-- | a constrain alias for functions that perform incremental updates to
--   the hash value
type HmacState alg m = (Functor m, Applicative m, HashAlgorithm alg, MonadState (HMACContext alg) m)

-- | constructs a new request with a <a>requestBody</a> function that will
--   produce each item in the input sequence until the sequence is empty.
rerunRequestBody :: (Functor m, MonadIO m) => Request -> Seq ByteString -> m Request

-- | sets the request body to the IO action.
setRequestBody :: Request -> IO ByteString -> Request

-- | gets the next chunk from the referenced sequence, returning mempty if
--   it is already empty. (if it is not, then the IORef is updated to point
--   to the next item in the sequence).
produceChunked :: Monoid a => IORef (Seq a) -> IO a

-- | add a header to a request (without checking for pre-existing headers)
addHeader :: Request -> (HeaderName, ByteString) -> Request

-- | performs the full incremental hash/sign algorithm on the request and
--   returns the signature.
hmacRequest :: (MonadIO m, HasReqConf alg m, AuthErrorsM m, WriteChunks m) => Request -> SecretKey -> m (HMAC alg)

-- | sets up the hash algorithm with the secret key
hmacRequestInit :: HasReqConf alg m => SecretKey -> m (HMACContext alg)

-- | add all of the important components of the request to the hash
--   
--   <ul>
--   <li>request method (newline)</li>
--   <li>timestamp header (newline)</li>
--   <li>api key (if necessary)</li>
--   <li>raw path info</li>
--   <li>query params (with a question mark to separate from the path
--   info)</li>
--   <li>(newline)</li>
--   <li>the body of the request</li>
--   </ul>
addHashComponents :: (MonadIO m, HasReqConf alg m, AuthErrorsM m, WriteChunks m, HmacState alg m) => Request -> m ()

-- | ensure the hash/signature will include the api key value according to
--   the spec - i.e. in either spec, this will fail the computation if the
--   key is not present according to spec; this function will have no
--   further effect for a query parameter key, but for a header key, it
--   will add it to the hash.
ensureApiKeyIsAdded :: (AuthErrorsM m, HasReqConf alg m, HmacState alg m) => Request -> m ()

-- | keep getting chunks from the request and appending them to the hash
--   (and also storing them in the writer value) until there are no more
--   chunks
addBodyToHash :: (MonadIO m, HmacState alg m, WriteChunks m) => Request -> m ()

-- | get the next chunk from the request body, if there is one
getNextChunkForHash :: (MonadIO m, Functor m) => Request -> m (Maybe ByteString)

-- | add a value to the incremental hash
addToHash :: HmacState alg m => ByteString -> m ()

-- | get the signature header value, decode it from base64 url encoding,
--   and then read it as a digest
getBase64DecodedSignature :: (HasReqConf alg m, AuthErrorsM m) => Request -> m (HMAC alg)

-- | get the header that should contain the timestamp
getTimestampHeader :: (AuthErrorsM m, HasReqConf alg m) => Request -> m ByteString

-- | get the header that should contain the signature
getSignatureHeader :: (AuthErrorsM m, HasReqConf alg m) => Request -> m ByteString

-- | get a header from the request; throw an error if it can't be found
getHeader :: (AuthErrorsM m, HasReqConf alg m) => (RequestConfig alg -> HeaderName) -> (HeaderName -> AuthFailure) -> Request -> m ByteString

-- | return the value if the predicate of it is true
justWhen :: (a -> Bool) -> a -> Maybe a

-- | return the value if the predicate of it is false
justUnless :: (a -> Bool) -> a -> Maybe a

-- | calls every function in the data structure, and then traverses/folds
--   the contained actions.
allRead :: (Applicative m, Foldable t) => t (a -> m b) -> a -> m ()
instance Eq ApiKey
instance Show ApiKey
instance Eq SecretKey
instance Show SecretKey
instance Eq ApiKeySpec
instance Show ApiKeySpec
instance Eq alg => Eq (RequestConfig alg)
instance Show alg => Show (RequestConfig alg)
instance Eq AuthFailure
instance Show AuthFailure
