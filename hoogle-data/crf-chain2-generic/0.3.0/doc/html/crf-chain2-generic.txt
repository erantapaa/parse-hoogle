-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Second-order, generic, constrained, linear conditional random fields
--   
--   The library provides implementation of the second-order, linear
--   conditional random fields (CRFs) with position-wise constraints
--   imposed over label values. It also provides a generic framework for
--   defining custom feature data types and feature generation functions
--   (see <a>Data.CRF.Chain2.Generic</a>) together with some concrete model
--   examples (e.g. <a>Data.CRF.Chain2.Pair</a>).
@package crf-chain2-generic
@version 0.3.0


-- | External data representation.
module Data.CRF.Chain2.Generic.External

-- | A word consists of a set of observations and a set of potential
--   labels.
data Word a b

-- | A word constructor which checks non-emptiness of the potential set of
--   labels.
mkWord :: Set a -> Set b -> Word a b

-- | A sentence of words.
type Sent a b = [Word a b]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Dist a

-- | Construct the probability distribution.
mkDist :: Ord a => [(a, Double)] -> Dist a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels. We assume that every label from the distribution
--   domain is a member of the set of potential labels corresponding to the
--   word. TODO: Ensure the assumption using the smart constructor.
type WordL a b = (Word a b, Dist b)

-- | A sentence of labeled words.
type SentL a b = [WordL a b]
instance (Show a, Show b) => Show (Word a b)
instance (Eq a, Eq b) => Eq (Word a b)
instance (Ord a, Ord b) => Ord (Word a b)


-- | Internal core data types.
module Data.CRF.Chain2.Generic.Internal

-- | A word represented by a list of its observations and a list of its
--   potential label interpretations.
data X o t

-- | Sentence of words.
type Xs o t = Vector (X o t)

-- | X constructor.
mkX :: (Ord o, Ord t) => [o] -> [t] -> X o t

-- | List of observations.
unX :: X o t -> [o]

-- | List of potential labels.
unR :: X o t -> [t]

-- | Vector of chosen labels together with corresponding probabilities.
data Y t

-- | Sentence of Y (label choices).
type Ys t = Vector (Y t)

-- | Y constructor.
mkY :: Ord t => [(t, Double)] -> Y t

-- | Y deconstructor symetric to mkY.
unY :: Y t -> [(t, Double)]

-- | Potential label at the given position.
lbAt :: X o t -> LbIx -> t

-- | Potential label at the given position and at the given index. Return
--   Nothing for positions outside the domain.
lbOn :: Xs o t -> Int -> LbIx -> Maybe t

-- | Number of potential labels at the given position of the sentence.
--   Function extended to indices outside the positions' domain.
lbNum :: Xs o t -> Int -> Int

-- | List of label indices at the given position. Function extended to
--   indices outside the positions' domain.
lbIxs :: Xs o t -> Int -> [LbIx]

-- | A feature index. To every model feature a unique index is assigned.
newtype FeatIx
FeatIx :: Int -> FeatIx
unFeatIx :: FeatIx -> Int

-- | An index of the label.
type LbIx = Int

-- | An ascending vector of distinct elements.
data AVec a

-- | Smart AVec constructor which ensures that the underlying vector is
--   strictly ascending.
mkAVec :: Ord a => [a] -> AVec a

-- | An ascending vector of distinct elements with respect to <a>fst</a>
--   values.
data AVec2 a b

-- | Smart AVec constructor which ensures that the underlying vector is
--   strictly ascending with respect to fst values.
mkAVec2 :: Ord a => [(a, b)] -> AVec2 a b
instance Show a => Show (AVec a)
instance Eq a => Eq (AVec a)
instance Ord a => Ord (AVec a)
instance (Show a, Show b) => Show (AVec2 a b)
instance (Eq a, Eq b) => Eq (AVec2 a b)
instance (Ord a, Ord b) => Ord (AVec2 a b)
instance (Show o, Show t) => Show (X o t)
instance (Eq o, Eq t) => Eq (X o t)
instance (Ord o, Ord t) => Ord (X o t)
instance Show t => Show (Y t)
instance Eq t => Eq (Y t)
instance Ord t => Ord (Y t)
instance Show FeatIx
instance Eq FeatIx
instance Ord FeatIx
instance Binary FeatIx
instance IArray UArray FeatIx
instance Vector Vector FeatIx
instance MVector MVector FeatIx
instance Unbox FeatIx

module Data.CRF.Chain2.Generic.FeatMap
class FeatMap m f
featIndex :: FeatMap m f => f -> m f -> Maybe FeatIx
mkFeatMap :: FeatMap m f => [(f, FeatIx)] -> m f

module Data.CRF.Chain2.Generic.FeatMap.Map
newtype FeatMap f
FeatMap :: Map f FeatIx -> FeatMap f
unFeatMap :: FeatMap f -> Map f FeatIx
instance Show f => Show (FeatMap f)
instance Eq f => Eq (FeatMap f)
instance Ord f => Ord (FeatMap f)
instance (Ord f, Binary f) => Binary (FeatMap f)
instance Ord f => FeatMap FeatMap f

module Data.CRF.Chain2.Generic.Model

-- | Feature generation specification.
data FeatGen o t f
FeatGen :: (o -> t -> [f]) -> (t -> [f]) -> (t -> t -> [f]) -> (t -> t -> t -> [f]) -> FeatGen o t f
obFeats :: FeatGen o t f -> o -> t -> [f]
trFeats1 :: FeatGen o t f -> t -> [f]
trFeats2 :: FeatGen o t f -> t -> t -> [f]
trFeats3 :: FeatGen o t f -> t -> t -> t -> [f]

-- | A feature selection function type.
type FeatSel o t f = FeatGen o t f -> Xs o t -> Ys t -> [f]

-- | The <a>presentFeats</a> adapted to fit feature selection specs.
selectPresent :: FeatSel o t f

-- | The <a>hiddenFeats</a> adapted to fit feature selection specs.
selectHidden :: FeatSel o t f

-- | A conditional random field.
data Model m o t f
Model :: Vector Double -> m f -> FeatGen o t f -> Model m o t f
values :: Model m o t f -> Vector Double
ixMap :: Model m o t f -> m f
featGen :: Model m o t f -> FeatGen o t f
mkModel :: (Ord f, FeatMap m f) => FeatGen o t f -> FeatSel o t f -> [(Xs o t, Ys t)] -> Model m o t f

-- | A core of the model with no feature generation function. Unlike the
--   <a>Model</a>, the core can be serialized.
data Core m f
Core :: Vector Double -> m f -> Core m f
valuesC :: Core m f -> Vector Double
ixMapC :: Core m f -> m f

-- | Extract the model core.
core :: Model m o t f -> Core m f

-- | Construct model with the given core and feature generation function.
withCore :: Core m f -> FeatGen o t f -> Model m o t f

-- | Potential assigned to the feature -- exponential of the corresonding
--   parameter.
phi :: FeatMap m f => Model m o t f -> f -> LogFloat

-- | Index of the feature.
index :: FeatMap m f => Model m o t f -> f -> Maybe FeatIx

-- | Features present in the dataset element together with corresponding
--   occurence probabilities.
presentFeats :: FeatGen o t f -> Xs o t -> Ys t -> [(f, LogFloat)]

-- | Features hidden in the dataset element.
hiddenFeats :: FeatGen o t f -> Xs o t -> [f]
obFeatsOn :: FeatGen o t f -> Xs o t -> Int -> LbIx -> [f]
trFeatsOn :: FeatGen o t f -> Xs o t -> Int -> LbIx -> LbIx -> LbIx -> [f]
onWord :: FeatMap m f => Model m o t f -> Xs o t -> Int -> LbIx -> LogFloat
onTransition :: FeatMap m f => Model m o t f -> Xs o t -> Int -> LbIx -> LbIx -> LbIx -> LogFloat

-- | Number of potential labels at the given position of the sentence.
--   Function extended to indices outside the positions' domain.
lbNum :: Xs o t -> Int -> Int

-- | Potential label at the given position and at the given index. Return
--   Nothing for positions outside the domain.
lbOn :: Xs o t -> Int -> LbIx -> Maybe t

-- | List of label indices at the given position. Function extended to
--   indices outside the positions' domain.
lbIxs :: Xs o t -> Int -> [LbIx]
instance Binary (m f) => Binary (Core m f)

module Data.CRF.Chain2.Pair.Base
newtype Ob
Ob :: Int -> Ob
unOb :: Ob -> Int
newtype Lb1
Lb1 :: Int -> Lb1
unLb1 :: Lb1 -> Int
newtype Lb2
Lb2 :: Int -> Lb2
unLb2 :: Lb2 -> Int
type Lb = (Lb1, Lb2)
data Feat
TFeat3'1 :: {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> Feat
TFeat3'2 :: {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> Feat
TFeat2'1 :: {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> Feat
TFeat2'2 :: {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> Feat
TFeat1'1 :: {-# UNPACK #-} !Lb1 -> Feat
TFeat1'2 :: {-# UNPACK #-} !Lb2 -> Feat
OFeat'1 :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb1 -> Feat
OFeat'2 :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb2 -> Feat
featGen :: FeatGen Ob (Lb1, Lb2) Feat
instance Show Ob
instance Eq Ob
instance Ord Ob
instance Ix Ob
instance Binary Ob
instance Show Lb1
instance Eq Lb1
instance Ord Lb1
instance Ix Lb1
instance Binary Lb1
instance Show Lb2
instance Eq Lb2
instance Ord Lb2
instance Ix Lb2
instance Binary Lb2
instance Show Feat
instance Eq Feat
instance Ord Feat
instance Binary Feat

module Data.CRF.Chain2.Generic.Inference
tag :: FeatMap m f => Model m o t f -> Xs o t -> [t]
probs :: FeatMap m f => Model m o t f -> Xs o t -> [[LogFloat]]
marginals :: FeatMap m f => Model m o t f -> Xs o t -> [[LogFloat]]
expectedFeatures :: FeatMap m f => Model m o t f -> Xs o t -> [(f, LogFloat)]

-- | Compute the accuracy of the model with respect to the labeled dataset.
accuracy :: (Eq t, FeatMap m f) => Model m o t f -> [(Xs o t, Ys t)] -> Double
zx :: FeatMap m f => Model m o t f -> Xs o t -> LogFloat
zx' :: FeatMap m f => Model m o t f -> Xs o t -> LogFloat

module Data.CRF.Chain2.Generic.Train

-- | A codec specification.
data CodecSpec a b c o t
CodecSpec :: ([SentL a b] -> (c, [(Xs o t, Ys t)])) -> (c -> [SentL a b] -> [(Xs o t, Ys t)]) -> CodecSpec a b c o t
mkCodec :: CodecSpec a b c o t -> [SentL a b] -> (c, [(Xs o t, Ys t)])
encode :: CodecSpec a b c o t -> c -> [SentL a b] -> [(Xs o t, Ys t)]

-- | Train the CRF using the stochastic gradient descent method. When the
--   evaluation data <a>IO</a> action is <a>Just</a>, the iterative
--   training process will notify the user about the current accuracy on
--   the evaluation part every full iteration over the training part. TODO:
--   Add custom feature extraction function.
train :: (Ord a, Ord b, Eq t, Ord f, FeatMap m f) => SgdArgs -> CodecSpec a b c o t -> FeatGen o t f -> FeatSel o t f -> IO [SentL a b] -> Maybe (IO [SentL a b]) -> IO (c, Model m o t f)

module Data.CRF.Chain2.Generic.Codec

-- | A codec monad.
type CodecM c a = Codec c a

-- | An abstract codec representation with external observation type
--   <tt>a</tt>, external label type <tt>b</tt>, codec data type
--   <tt>c</tt>, internal observation type <tt>o</tt> and internal label
--   type <tt>e</tt>.
data Codec a b c o e
Codec :: c -> (a -> CodecM c o) -> (a -> CodecM c (Maybe o)) -> (b -> CodecM c e) -> (b -> CodecM c e) -> (e -> CodecM c (Maybe b)) -> (c -> b -> Bool) -> Codec a b c o e

-- | Empty codec.
empty :: Codec a b c o e -> c

-- | Encode the observation and update the codec (only in the encoding
--   direction).
encodeObU :: Codec a b c o e -> a -> CodecM c o

-- | Encode the observation and do *not* update the codec.
encodeObN :: Codec a b c o e -> a -> CodecM c (Maybe o)

-- | Encode the label and update the codec.
encodeLbU :: Codec a b c o e -> b -> CodecM c e

-- | Encode the label and do *not* update the codec. In case the label is
--   not a member of the codec, return the label code assigned to Nothing
--   label.
encodeLbN :: Codec a b c o e -> b -> CodecM c e

-- | Decode the label within the codec monad.
decodeLbC :: Codec a b c o e -> e -> CodecM c (Maybe b)

-- | Is label a member of the codec?
hasLabel :: Codec a b c o e -> c -> b -> Bool

-- | Encode the word and update the codec.
encodeWord'Cu :: (Ord e, Ord o) => Codec a b c o e -> Word a b -> CodecM c (X o e)

-- | Encode the word and do *not* update the codec.
encodeWord'Cn :: (Ord e, Ord o) => Codec a b c o e -> Word a b -> CodecM c (X o e)

-- | Encode the sentence and update the codec.
encodeSent'Cu :: (Ord e, Ord o) => Codec a b c o e -> Sent a b -> CodecM c (Xs o e)

-- | Encode the sentence and do *not* update the codec.
encodeSent'Cn :: (Ord e, Ord o) => Codec a b c o e -> Sent a b -> CodecM c (Xs o e)

-- | Encode the sentence using the given codec.
encodeSent :: (Ord e, Ord o) => Codec a b c o e -> c -> Sent a b -> Xs o e

-- | Encode the labeled word and update the codec.
encodeWordL'Cu :: (Ord e, Ord o) => Codec a b c o e -> WordL a b -> CodecM c (X o e, Y e)

-- | Encodec the labeled word and do *not* update the codec.
encodeWordL'Cn :: (Ord e, Ord o) => Codec a b c o e -> WordL a b -> CodecM c (X o e, Y e)

-- | Encode the labeled sentence and update the codec.
encodeSentL'Cu :: (Ord e, Ord o) => Codec a b c o e -> SentL a b -> CodecM c (Xs o e, Ys e)

-- | Encode the labeled sentence and do *not* update the codec. Substitute
--   the default label for any label not present in the codec.
encodeSentL'Cn :: (Ord e, Ord o) => Codec a b c o e -> SentL a b -> CodecM c (Xs o e, Ys e)

-- | Encode the labeled sentence with the given codec. Substitute the
--   default label for any label not present in the codec.
encodeSentL :: (Ord e, Ord o) => Codec a b c o e -> c -> SentL a b -> (Xs o e, Ys e)

-- | Decode the label.
decodeLabel :: Codec a b c o e -> c -> e -> Maybe b

-- | Decode the sequence of labels.
decodeLabels :: Codec a b c o e -> c -> [e] -> [Maybe b]

-- | Return the label when <a>Just</a> or one of the unknown values when
--   <a>Nothing</a>.
unJust :: Codec a b c o e -> c -> Word a b -> Maybe b -> b

-- | Create the codec on the basis of the labeled dataset, return the
--   resultant codec and the encoded dataset.
mkCodec :: (Ord e, Ord o) => Codec a b c o e -> [SentL a b] -> (c, [(Xs o e, Ys e)])

-- | Encode the dataset with the codec.
encodeData :: (Ord e, Ord o) => Codec a b c o e -> c -> [Sent a b] -> [Xs o e]

-- | Encode the labeled dataset using the codec. Substitute the default
--   label for any label not present in the codec.
encodeDataL :: (Ord e, Ord o) => Codec a b c o e -> c -> [SentL a b] -> [(Xs o e, Ys e)]

module Data.CRF.Chain2.Pair.Codec

-- | A codec. The first component is used to encode observations of type a,
--   the second one is used to encode labels of type b, third -- labels of
--   type c from the third level.
type CodecData a b c = (AtomCodec a, AtomCodec (Maybe b), AtomCodec (Maybe c))

-- | The maximum internal observation included in the codec.
obMax :: CodecData a b c -> Ob

-- | The maximum internal label included in the codec.
lb1Max :: CodecData a b c -> Lb1

-- | The maximum internal label included in the codec.
lb2Max :: CodecData a b c -> Lb2
codec :: (Ord a, Ord b, Ord c) => Codec a (b, c) (CodecData a b c) Ob Lb

module Data.CRF.Chain2.Pair.FeatMap
data FeatMap a
FeatMap :: UArray (Lb1, Lb1, Lb1) FeatIx -> UArray (Lb2, Lb2, Lb2) FeatIx -> Map Feat FeatIx -> FeatMap a
trMap3'1 :: FeatMap a -> UArray (Lb1, Lb1, Lb1) FeatIx
trMap3'2 :: FeatMap a -> UArray (Lb2, Lb2, Lb2) FeatIx
otherMap :: FeatMap a -> Map Feat FeatIx
instance Binary (FeatMap Feat)
instance FeatMap FeatMap Feat

module Data.CRF.Chain2.Pair

-- | A word consists of a set of observations and a set of potential
--   labels.
data Word a b

-- | A word constructor which checks non-emptiness of the potential set of
--   labels.
mkWord :: Set a -> Set b -> Word a b

-- | A sentence of words.
type Sent a b = [Word a b]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Dist a

-- | Construct the probability distribution.
mkDist :: Ord a => [(a, Double)] -> Dist a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels. We assume that every label from the distribution
--   domain is a member of the set of potential labels corresponding to the
--   word. TODO: Ensure the assumption using the smart constructor.
type WordL a b = (Word a b, Dist b)

-- | A sentence of labeled words.
type SentL a b = [WordL a b]
newtype Ob
Ob :: Int -> Ob
unOb :: Ob -> Int
newtype Lb1
Lb1 :: Int -> Lb1
unLb1 :: Lb1 -> Int
newtype Lb2
Lb2 :: Int -> Lb2
unLb2 :: Lb2 -> Int
type Lb = (Lb1, Lb2)
data Feat
TFeat3'1 :: {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> Feat
TFeat3'2 :: {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> Feat
TFeat2'1 :: {-# UNPACK #-} !Lb1 -> {-# UNPACK #-} !Lb1 -> Feat
TFeat2'2 :: {-# UNPACK #-} !Lb2 -> {-# UNPACK #-} !Lb2 -> Feat
TFeat1'1 :: {-# UNPACK #-} !Lb1 -> Feat
TFeat1'2 :: {-# UNPACK #-} !Lb2 -> Feat
OFeat'1 :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb1 -> Feat
OFeat'2 :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb2 -> Feat
data CRF a b c
CRF :: CodecData a b c -> Model FeatMap Ob Lb Feat -> CRF a b c
codecData :: CRF a b c -> CodecData a b c
model :: CRF a b c -> Model FeatMap Ob Lb Feat

-- | Train the CRF using the stochastic gradient descent method. When the
--   evaluation data <a>IO</a> action is <a>Just</a>, the iterative
--   training process will notify the user about the current accuracy on
--   the evaluation part every full iteration over the training part. Use
--   the provided feature selection function to determine model features.
train :: (Ord a, Ord b, Ord c) => SgdArgs -> FeatSel Ob Lb Feat -> IO [SentL a (b, c)] -> Maybe (IO [SentL a (b, c)]) -> IO (CRF a b c)

-- | Find the most probable label sequence.
tag :: (Ord a, Ord b, Ord c) => CRF a b c -> Sent a (b, c) -> [(b, c)]

-- | A feature selection function type.
type FeatSel o t f = FeatGen o t f -> Xs o t -> Ys t -> [f]

-- | The <a>hiddenFeats</a> adapted to fit feature selection specs.
selectHidden :: FeatSel o t f

-- | The <a>presentFeats</a> adapted to fit feature selection specs.
selectPresent :: FeatSel o t f
instance (Ord a, Ord b, Ord c, Binary a, Binary b, Binary c) => Binary (CRF a b c)
