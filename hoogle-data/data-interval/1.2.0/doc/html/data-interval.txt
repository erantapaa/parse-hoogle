-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interval arithmetic for both open and closed intervals
--   
--   Interval datatype and interval arithmetic for Haskell. Unlike the
--   intervals package
--   (<a>http://hackage.haskell.org/package/intervals</a>), this package
--   provides both open and closed intervals and is intended to be used
--   with exact number types such as Rational and Integer.
@package data-interval
@version 1.2.0


-- | Interval datatype and interval arithmetic.
--   
--   Unlike the intervals package
--   (<a>http://hackage.haskell.org/package/intervals</a>), this module
--   provides both open and closed intervals and is intended to be used
--   with <a>Rational</a>.
--   
--   For the purpose of abstract interpretation, it might be convenient to
--   use <a>Lattice</a> instance. See also lattices package
--   (<a>http://hackage.haskell.org/package/lattices</a>).
module Data.Interval

-- | The intervals (<i>i.e.</i> connected and convex subsets) over real
--   numbers <b>R</b>.
data Interval r

-- | Endpoints of intervals

-- | <i>Deprecated: EndPoint is deprecated. Please use Extended
--   instead.</i>
type EndPoint r = Extended r

-- | smart constructor for <a>Interval</a>
interval :: Ord r => (Extended r, Bool) -> (Extended r, Bool) -> Interval r

-- | closed interval [<tt>l</tt>,<tt>u</tt>]
(<=..<=) :: Ord r => Extended r -> Extended r -> Interval r

-- | left-open right-closed interval (<tt>l</tt>,<tt>u</tt>]
(<..<=) :: Ord r => Extended r -> Extended r -> Interval r

-- | left-closed right-open interval [<tt>l</tt>, <tt>u</tt>)
(<=..<) :: Ord r => Extended r -> Extended r -> Interval r

-- | open interval (<tt>l</tt>, <tt>u</tt>)
(<..<) :: Ord r => Extended r -> Extended r -> Interval r

-- | whole real number line (-∞, ∞)
whole :: Ord r => Interval r

-- | empty (contradicting) interval
empty :: Ord r => Interval r

-- | singleton set [x,x]
singleton :: Ord r => r -> Interval r

-- | Is the interval empty?
null :: Ord r => Interval r -> Bool

-- | Is the element in the interval?
member :: Ord r => r -> Interval r -> Bool

-- | Is the element not in the interval?
notMember :: Ord r => r -> Interval r -> Bool

-- | Is this a subset? <tt>(i1 `<a>isSubsetOf</a>` i2)</tt> tells whether
--   <tt>i1</tt> is a subset of <tt>i2</tt>.
isSubsetOf :: Ord r => Interval r -> Interval r -> Bool

-- | Is this a proper subset? (<i>i.e.</i> a subset but not equal).
isProperSubsetOf :: Ord r => Interval r -> Interval r -> Bool

-- | Lower endpoint (<i>i.e.</i> greatest lower bound) of the interval.
--   
--   <ul>
--   <li><a>lowerBound</a> of the empty interval is <a>PosInf</a>.</li>
--   <li><a>lowerBound</a> of a left unbounded interval is
--   <a>NegInf</a>.</li>
--   <li><a>lowerBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
lowerBound :: Interval r -> Extended r

-- | Upper endpoint (<i>i.e.</i> least upper bound) of the interval.
--   
--   <ul>
--   <li><a>upperBound</a> of the empty interval is <a>NegInf</a>.</li>
--   <li><a>upperBound</a> of a right unbounded interval is
--   <a>PosInf</a>.</li>
--   <li><a>upperBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
upperBound :: Interval r -> Extended r

-- | <a>lowerBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
lowerBound' :: Interval r -> (Extended r, Bool)

-- | <a>upperBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
upperBound' :: Interval r -> (Extended r, Bool)

-- | Width of a interval. Width of an unbounded interval is
--   <tt>undefined</tt>.
width :: (Num r, Ord r) => Interval r -> r

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>?
(<!) :: Ord r => Interval r -> Interval r -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>?
(<=!) :: Ord r => Interval r -> Interval r -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>?
(==!) :: Ord r => Interval r -> Interval r -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>?
(>=!) :: Ord r => Interval r -> Interval r -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>?
(>!) :: Ord r => Interval r -> Interval r -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=!) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
--   
--   Since 1.0.0
(==?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=?) :: Ord r => Interval r -> Interval r -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
--   
--   Since 1.0.0
(<??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
--   
--   Since 1.0.0
(<=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
--   
--   Since 1.0.0
(==??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
--   
--   Since 1.0.0
(>=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
--   
--   Since 1.0.0
(>??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)

-- | intersection of two intervals
intersection :: Ord r => Interval r -> Interval r -> Interval r

-- | intersection of a list of intervals.
--   
--   Since 0.6.0
intersections :: Ord r => [Interval r] -> Interval r

-- | convex hull of two intervals
hull :: Ord r => Interval r -> Interval r -> Interval r

-- | convex hull of a list of intervals.
--   
--   Since 0.6.0
hulls :: Ord r => [Interval r] -> Interval r

-- | pick up an element from the interval if the interval is not empty.
pickup :: (Real r, Fractional r) => Interval r -> Maybe r

-- | <a>simplestRationalWithin</a> returns the simplest rational number
--   within the interval.
--   
--   A rational number <tt>y</tt> is said to be <i>simpler</i> than another
--   <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> (<a>numerator</a> y) &lt;= <a>abs</a>
--   (<a>numerator</a> y')</tt>, and</li>
--   <li><tt><a>denominator</a> y &lt;= <a>denominator</a> y'</tt>.</li>
--   </ul>
--   
--   (see also <a>approxRational</a>)
--   
--   Since 0.4.0
simplestRationalWithin :: RealFrac r => Interval r -> Maybe Rational
instance Typeable Interval
instance Eq r => Eq (Interval r)
instance (Real r, Fractional r) => Fractional (Interval r)
instance (Num r, Ord r) => Num (Interval r)
instance (Ord r, Data r) => Data (Interval r)
instance (Ord r, Read r) => Read (Interval r)
instance (Ord r, Show r) => Show (Interval r)
instance Ord r => BoundedLattice (Interval r)
instance Ord r => BoundedMeetSemiLattice (Interval r)
instance Ord r => BoundedJoinSemiLattice (Interval r)
instance Ord r => Lattice (Interval r)
instance Ord r => MeetSemiLattice (Interval r)
instance Ord r => JoinSemiLattice (Interval r)
instance Hashable r => Hashable (Interval r)
instance NFData r => NFData (Interval r)


-- | Interval datatype and interval arithmetic over integers.
--   
--   Since 1.2.0
--   
--   For the purpose of abstract interpretation, it might be convenient to
--   use <a>Lattice</a> instance. See also lattices package
--   (<a>http://hackage.haskell.org/package/lattices</a>).
module Data.IntegerInterval

-- | The intervals (<i>i.e.</i> connected and convex subsets) over integers
--   (<b>Z</b>).
data IntegerInterval

-- | smart constructor for <a>Interval</a>
interval :: (Extended Integer, Bool) -> (Extended Integer, Bool) -> IntegerInterval

-- | closed interval [<tt>l</tt>,<tt>u</tt>]
(<=..<=) :: Extended Integer -> Extended Integer -> IntegerInterval

-- | left-open right-closed interval (<tt>l</tt>,<tt>u</tt>]
(<..<=) :: Extended Integer -> Extended Integer -> IntegerInterval

-- | left-closed right-open interval [<tt>l</tt>, <tt>u</tt>)
(<=..<) :: Extended Integer -> Extended Integer -> IntegerInterval

-- | open interval (<tt>l</tt>, <tt>u</tt>)
(<..<) :: Extended Integer -> Extended Integer -> IntegerInterval

-- | whole real number line (-∞, ∞)
whole :: IntegerInterval

-- | empty (contradicting) interval
empty :: IntegerInterval

-- | singleton set [x,x]
singleton :: Integer -> IntegerInterval

-- | Is the interval empty?
null :: IntegerInterval -> Bool

-- | Is the element in the interval?
member :: Integer -> IntegerInterval -> Bool

-- | Is the element not in the interval?
notMember :: Integer -> IntegerInterval -> Bool

-- | Is this a subset? <tt>(i1 `<a>isSubsetOf</a>` i2)</tt> tells whether
--   <tt>i1</tt> is a subset of <tt>i2</tt>.
isSubsetOf :: IntegerInterval -> IntegerInterval -> Bool

-- | Is this a proper subset? (<i>i.e.</i> a subset but not equal).
isProperSubsetOf :: IntegerInterval -> IntegerInterval -> Bool

-- | Lower endpoint (<i>i.e.</i> greatest lower bound) of the interval.
--   
--   <ul>
--   <li><a>lowerBound</a> of the empty interval is <a>PosInf</a>.</li>
--   <li><a>lowerBound</a> of a left unbounded interval is
--   <a>NegInf</a>.</li>
--   <li><a>lowerBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
lowerBound :: IntegerInterval -> Extended Integer

-- | Upper endpoint (<i>i.e.</i> least upper bound) of the interval.
--   
--   <ul>
--   <li><a>upperBound</a> of the empty interval is <a>NegInf</a>.</li>
--   <li><a>upperBound</a> of a right unbounded interval is
--   <a>PosInf</a>.</li>
--   <li><a>upperBound</a> of an interval is a member of the interval.</li>
--   </ul>
upperBound :: IntegerInterval -> Extended Integer

-- | <a>lowerBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
lowerBound' :: IntegerInterval -> (Extended Integer, Bool)

-- | <a>upperBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
upperBound' :: IntegerInterval -> (Extended Integer, Bool)

-- | Width of a interval. Width of an unbounded interval is
--   <tt>undefined</tt>.
width :: IntegerInterval -> Integer

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>?
(<!) :: IntegerInterval -> IntegerInterval -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>?
(<=!) :: IntegerInterval -> IntegerInterval -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>?
(==!) :: IntegerInterval -> IntegerInterval -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>?
(>=!) :: IntegerInterval -> IntegerInterval -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>?
(>!) :: IntegerInterval -> IntegerInterval -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>/=</a> y</tt>?
(/=!) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
(/=?) :: IntegerInterval -> IntegerInterval -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
(/=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)

-- | intersection of two intervals
intersection :: IntegerInterval -> IntegerInterval -> IntegerInterval

-- | intersection of a list of intervals.
intersections :: [IntegerInterval] -> IntegerInterval

-- | convex hull of two intervals
hull :: IntegerInterval -> IntegerInterval -> IntegerInterval

-- | convex hull of a list of intervals.
hulls :: [IntegerInterval] -> IntegerInterval

-- | pick up an element from the interval if the interval is not empty.
pickup :: IntegerInterval -> Maybe Integer

-- | <a>simplestIntegerWithin</a> returns the simplest rational number
--   within the interval.
--   
--   An integer <tt>y</tt> is said to be <i>simpler</i> than another
--   <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> y &lt;= <a>abs</a> y</tt>, and</li>
--   </ul>
--   
--   (see also <tt>approxRational</tt>)
simplestIntegerWithin :: IntegerInterval -> Maybe Integer

-- | Convert the interval to <a>Interval</a> data type.
toInterval :: Real r => IntegerInterval -> Interval r

-- | Conversion from <a>Interval</a> data type.
fromInterval :: Interval Integer -> IntegerInterval

-- | Given a <a>Interval</a> <tt>I</tt> over R, compute the smallest
--   <a>IntegerInterval</a> <tt>J</tt> such that <tt>I ⊆ J</tt>.
fromIntervalOver :: RealFrac r => Interval r -> IntegerInterval

-- | Given a <a>Interval</a> <tt>I</tt> over R, compute the largest
--   <a>IntegerInterval</a> <tt>J</tt> such that <tt>J ⊆ I</tt>.
fromIntervalUnder :: RealFrac r => Interval r -> IntegerInterval
instance Typeable IntegerInterval
instance Eq IntegerInterval
instance Num IntegerInterval
instance Data IntegerInterval
instance Read IntegerInterval
instance Show IntegerInterval
instance BoundedLattice IntegerInterval
instance BoundedMeetSemiLattice IntegerInterval
instance BoundedJoinSemiLattice IntegerInterval
instance Lattice IntegerInterval
instance MeetSemiLattice IntegerInterval
instance JoinSemiLattice IntegerInterval
instance Hashable IntegerInterval
instance NFData IntegerInterval
