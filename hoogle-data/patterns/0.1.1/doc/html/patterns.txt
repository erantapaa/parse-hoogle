-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common patterns in message-oriented applications
--   
--   In distributed, message-oriented applications, similar communication
--   patterns are used over and over again, such as Server/Client (a.k.a
--   Request/Response), Publish/Subscribe, Pipline (a.k.a. Push/Pull) and
--   Exclusive Pair (a.k.a. Peer-to-Peer). The Patterns package implements
--   those patterns based on zeromq. More information on zeromq can be
--   found at <a>http://www.zeromq.org</a>. More examples and a test suite
--   are available on <a>http://github.com/toschoo/mom</a>.
--   
--   Release History:
--   
--   <ul>
--   <li><i>0.1.1</i> Client (Basic and MDP): checkResult added; MDP
--   Broker: Many brokers in one process.</li>
--   <li><i>0.1.0</i> Major Review: Conduits replace enumerators,
--   Interfaces simplified to ByteString, Interfaces simplified in general,
--   Advanced patterns: Majordomo Broker.</li>
--   <li><i>0.0.1</i> Initial Release.</li>
--   </ul>
@package patterns
@version 0.1.1


-- | Fundamental streaming types
module Network.Mom.Patterns.Types

-- | The IO Resource transformer. See the conduit package for details
type RIO = ResourceT IO

-- | A stream source
type Source = Source RIO ByteString

-- | A stream sink without return type
type Sink = Sink ByteString RIO ()

-- | A stream sink wit return type
type SinkR r = Sink ByteString RIO r

-- | A conduit that links source and sink applying some transformation to
--   the stream. Input is always <a>ByteString</a>, output and return type
--   may vary.
type Conduit o r = ConduitM ByteString o RIO r

-- | Simplified Conduit where output is always <a>ByteString</a> and no
--   final value is returned.
type Conduit_ = Conduit ByteString ()

-- | Streaming the elements of a list
streamList :: [ByteString] -> Producer RIO ByteString

-- | Pass the stream through without applying any transformation to it
passThrough :: Conduit ByteString ()

-- | A <i>zeromq</i> <tt>AccessPoint</tt> can be bound or connected to its
--   address. Only one peer can bind the address, all other parties have to
--   connect.
data LinkType

-- | Bind the address
Bind :: LinkType

-- | Connect to the address
Connect :: LinkType

-- | Error handler for all services that are implemented as background
--   services, <i>e.g.</i> servers and brokers. The handler receives the
--   <a>Criticality</a> of the error event, the exception and an additional
--   descriptive string.
--   
--   A good policy is to terminate or restart the service when a
--   <a>Fatal</a> or <a>Critical</a> error occurs and to continue, if
--   possible, on a plain <a>Error</a>. The error handler may perform
--   additional, user-defined actions, such as logging the incident or
--   sending an SMS.
type OnError_ = Criticality -> SomeException -> String -> IO ()

-- | Indicates criticality of the error event
data Criticality

-- | The current operation (<i>e.g.</i> processing a request) has not
--   terminated properly, but the service is able to continue; the error
--   may have been caused by a faulty request or other temporal conditions.
Error :: Criticality

-- | The event has impact on the process, leaving it in an unkown state.
Critical :: Criticality

-- | The service cannot recover and will terminate
Fatal :: Criticality

-- | Stream Exception
data StreamException

-- | low-level error
SocketExc :: String -> StreamException

-- | IO error
IOExc :: String -> StreamException

-- | Protocol error
ProtocolExc :: String -> StreamException

-- | Application-defined error
AppExc :: String -> StreamException

-- | Internal error, indicating a code error in library
Ouch :: String -> StreamException

-- | String identifying a stream in the streams device
type Identifier = String

-- | String identifying a service provided, <i>e.g.</i> by a <i>server</i>
type Service = String

-- | Identity of a communication peer, needed for complex patterns
--   (<i>e.g.</i> broker)
type Identity = ByteString

-- | Message body, needed for complex patterns (<i>e.g.</i> broker)
type Body = [ByteString]

-- | Milliseconds
type Msec = Int

-- | Reexport from zeromq (timeout in microseconds)
type Timeout = Timeout

-- | Reexport from zeromq
type Context = Context

-- | Reexport from zeromq
type Size = Size

-- | Reexport from zeromq
withContext :: Size -> (Context -> IO a) -> IO a
instance Typeable StreamException
instance Show LinkType
instance Read LinkType
instance Eq Criticality
instance Ord Criticality
instance Show Criticality
instance Read Criticality
instance Show StreamException
instance Read StreamException
instance Eq StreamException
instance Exception StreamException


-- | Stream processing services
module Network.Mom.Patterns.Streams

-- | Starts polling on a set of streams. The actual polling will be run in
--   another thread. The current thread continues with the action passed
--   in. When this action terminates, the streamer stops polling.
--   
--   Parameters:
--   
--   <ul>
--   <li><a>Context</a> - The <i>ZMQ</i> context</li>
--   <li><a>Service</a> - The service name indicated for instance in error
--   messages.</li>
--   <li><a>Timeout</a> - The polling timeout: <i>&lt; 0</i> - listens
--   eternally, <i>0</i> - returns immediately, <i>&gt; 0</i> - timeout in
--   microseconds; when the timeout expires, the <a>StreamAction</a> is
--   invoked.</li>
--   <li><a>PollEntry</a> - List of <a>PollEntry</a>; the streamer will
--   poll over all list members. When input is available, it is directed to
--   the <a>StreamSink</a>.</li>
--   <li><a>StreamAction</a> - Invoked when timeout expires.</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>StreamSink</a> - The sink, to which the stream is sent. Note
--   that the sink must terminate the outgoing stream (using one of the
--   terminating sinks described below). Not terminating the stream
--   properly will result in a zeromq socket error.</li>
--   <li><a>Control</a> a - The action to invoke, when the streamer has
--   been started; The <a>Control</a> is used to control the device.</li>
--   </ul>
withStreams :: Context -> Service -> Timeout -> [PollEntry] -> StreamAction -> OnError_ -> StreamSink -> Control a -> IO a

-- | Receiver Sink: Internally a zeromq socket is waiting for input; when
--   input is available, it is send to the sink.
--   
--   <ul>
--   <li>'Z.Socket a' - The source socket</li>
--   <li><a>Timeout</a> - receiver timeout <i>&lt; 0</i> - listens
--   eternally, <i>0</i> - returns immediately, <i>&gt; 0</i> - timeout in
--   microseconds; when the timeout expires, the stream terminates and the
--   return value is Nothing.</li>
--   </ul>
runReceiver :: Socket a -> Timeout -> SinkR (Maybe o) -> IO (Maybe o)

-- | Sender Source: The <a>Source</a> generates a stream, which is relayed
--   to the <a>Socket</a>.
runSender :: Socket a -> Source -> IO ()

-- | A poll entry describes how to access and identify a socket
data PollEntry
Poll :: Identifier -> String -> AccessType -> LinkType -> [Service] -> [SocketOption] -> PollEntry

-- | How to address this particular stream
pollId :: PollEntry -> Identifier

-- | The address to link to
pollAdd :: PollEntry -> String

-- | The zeromq socket type
pollType :: PollEntry -> AccessType

-- | How to link (bind or connect)
pollLink :: PollEntry -> LinkType

-- | List of <a>Service</a> (or topics) for subscribers
pollSub :: PollEntry -> [Service]

-- | zeromq socket options
pollOs :: PollEntry -> [SocketOption]

-- | Defines the type of a <a>PollEntry</a>; the names of the constructors
--   are similar to the corresponding ZMQ socket types.
data AccessType

-- | Represents a server and expects connections from clients; corresponds
--   to ZMQ Socket Type <a>Rep</a>
ServerT :: AccessType

-- | Represents a client and connects to a server; corresponds to ZMQ
--   Socket Type <a>Req</a>
ClientT :: AccessType

-- | Represents a load balancer, expecting connections from clients;
--   corresponds to ZMQ Socket Type <a>XRep</a>
RouterT :: AccessType

-- | Represents a router expecting connections from servers; corresponds to
--   ZMQ Socket Type <a>XReq</a>
DealerT :: AccessType

-- | Represents a publisher; corresponds to ZMQ Socket Type <a>Pub</a>
PubT :: AccessType

-- | Represents a subscriber; corresponds to ZMQ Socket Type <a>Sub</a>
SubT :: AccessType

-- | Represents a Pipe; corresponds to ZMQ Socket Type <a>Push</a>
PipeT :: AccessType

-- | Represents a Puller; corresponds to ZMQ Socket Type <a>Pull</a>
PullT :: AccessType

-- | Represents a Peer; corresponds to ZMQ Socket Type <a>Pair</a>
PeerT :: AccessType

-- | Safely read <a>AccessType</a>; ignores the case of the input string
--   (<i>e.g.</i> "servert" -&gt; <a>ServerT</a>)
parseAccess :: String -> Maybe AccessType

-- | A <i>zeromq</i> <tt>AccessPoint</tt> can be bound or connected to its
--   address. Only one peer can bind the address, all other parties have to
--   connect.
data LinkType

-- | Bind the address
Bind :: LinkType

-- | Connect to the address
Connect :: LinkType

-- | Binds or connects a socket to an address
link :: LinkType -> Socket a -> String -> [SocketOption] -> IO ()

-- | Safely read <a>LinkType</a>; ignores the case of the input string and,
--   besides "bind" and "connect", also accepts "bin", "con" and "conn";
--   intended for use with command line parameters
parseLink :: String -> Maybe LinkType

-- | Holds information on streams and the current state of the streamer,
--   <i>i.e.</i> the current source. Streamers are passed to processing
--   conduits.
data Streamer

-- | Conduit with Streamer
type StreamConduit = Streamer -> Conduit ByteString ()

-- | Sink with Streamer
type StreamSink = Streamer -> Sink

-- | IO Action with Streamer (<i>e.g.</i> Timeout action)
type StreamAction = Streamer -> IO ()

-- | Filter subset of streams; usually you want to filter a subset of
--   streams to which to relay an incoming stream. Note that the result is
--   just a list of stream identifiers, which of course could be used
--   directly in the first place. A meaningful use of filterstreams would
--   be, for instance:
--   
--   <pre>
--   let targets = filterStreams s (/= getSource s)
--   </pre>
--   
--   Where all streams but the source are selected.
filterStreams :: Streamer -> (Identifier -> Bool) -> [Identifier]

-- | Get current source
getSource :: Streamer -> Identifier

-- | Send the <tt>ByteString</tt> segments to the outgoing streams
--   identified by [<a>Identifier</a>]. The stream is terminated.
stream :: Streamer -> [Identifier] -> [ByteString] -> Sink

-- | Send the <tt>ByteString</tt> segments to the outgoing streams
--   identified by [<a>Identifier</a>] without terminating the stream,
--   <i>i.e.</i> more segments must be sent.
part :: Streamer -> [Identifier] -> [ByteString] -> Sink

-- | Pass all segments of an incoming stream to a list of outgoing streams.
--   The stream is terminated.
passAll :: Streamer -> [Identifier] -> Sink

-- | Pass one segment and ignore the remainder of the stream. The stream is
--   terminated.
pass1 :: Streamer -> [Identifier] -> Sink

-- | Pass n segments and ignore the remainder of the stream. The stream is
--   terminated.
passN :: Streamer -> [Identifier] -> Int -> Sink

-- | Pass while condition is true and ignore the remainder of the stream.
--   The stream is terminated.
passWhile :: Streamer -> [Identifier] -> (ByteString -> Bool) -> Sink

-- | Ignore an incoming stream
ignoreStream :: Sink

-- | Controller
data Controller

-- | Control Action
type Control a = Controller -> IO a

-- | The internal stream that represents the <a>Controller</a>. StreamSinks
--   can write to this stream, <i>e.g.</i>:
--   
--   <pre>
--   passAll s [internal]
--   </pre>
--   
--   And the streamer may also receive from this stream, <i>e.g.</i>:
--   
--   <pre>
--   if getSource s == internal
--   </pre>
internal :: Identifier

-- | Stop streams
stop :: Controller -> IO ()

-- | Pause streams
pause :: Controller -> IO ()

-- | Resume streams
resume :: Controller -> IO ()

-- | Send a stream through the controller
send :: Controller -> [Identifier] -> Source -> IO ()

-- | Receive a stream through the controller that was sink'd to the target
--   <a>internal</a>.
receive :: Controller -> Timeout -> SinkR (Maybe a) -> IO (Maybe a)
instance Eq AccessType
instance Show AccessType
instance Read AccessType
instance Show PollEntry
instance Read PollEntry
instance Eq PollEntry


-- | Client side of Client/Server
module Network.Mom.Patterns.Basic.Client

-- | Client data type
data Client
clService :: Client -> Service

-- | Create a client with name <a>Service</a>, linking to address
--   <a>String</a>, connecting or binding the address according to
--   <a>LinkType</a> and finally entering the action, in whose scope the
--   client lives.
withClient :: Context -> Service -> String -> LinkType -> (Client -> IO a) -> IO a

-- | Request a service:
--   
--   <ul>
--   <li><a>Client</a> - The client, through which the service is
--   requested</li>
--   <li><a>Timeout</a> - Timeout in microseconds, -1 to wait eternally.
--   With timeout = 0, the function returns immediately with
--   <a>Nothing</a>. When the timeout expires, request is abandoned. In
--   this case, the result of the request is Nothing.</li>
--   <li><a>Source</a> - The source of the request stream; the format of
--   the request will probably comply with some communication protocol, as,
--   for instance, in the majordomo pattern.</li>
--   <li><a>SinkR</a> - The sink receiving the reply. The result of the
--   sink is returned as the request's overall result. Note that the sink
--   may perform different actions on the segments of the resulting stream,
--   <i>e.g.</i> storing data in a database, and return the number of
--   records received.</li>
--   </ul>
--   
--   A 'hello world' Example:
--   
--   <pre>
--   import qualified Data.Conduit          as C
--   import qualified Data.ByteString.Char8 as B
--   import           Network.Mom.Patterns.Basic.Client
--   import           Network.Mom.Patterns.Types
--   </pre>
--   
--   <pre>
--   main :: IO ()
--   main = withContext 1 $ \ctx -&gt; 
--            withClient ctx "test" 
--                "tcp://localhost:5555" Connect $ \c -&gt; do
--              mbX &lt;- request c (-1) src snk
--              case mbX of
--                Nothing -&gt; putStrLn "No Result"
--                Just x  -&gt; putStrLn $ "Result: " ++ x
--     where src = C.yield (B.pack "hello world")
--           snk = do mbX &lt;- C.await 
--                    case mbX of
--                      Nothing -&gt; return Nothing
--                      Just x  -&gt; return $ Just $ B.unpack x
--   </pre>
request :: Client -> Timeout -> Source -> SinkR (Maybe r) -> IO (Maybe r)

-- | Check for a of a previously requested result; use case: request with
--   timout 0, do some work and check for a result later. Do not use this
--   function without having requested the service previously. The
--   parameters equal those of <a>request</a>, but do not include a
--   <a>Source</a>.
checkResult :: Client -> Timeout -> SinkR (Maybe r) -> IO (Maybe r)


-- | Server side of 'Client/Server'
module Network.Mom.Patterns.Basic.Server

-- | Start a server as a background process
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - Service name</li>
--   <li><a>String</a> - The address to link to</li>
--   <li><a>LinkType</a> - Whether to connect to or to bind the
--   address</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Conduit_</a> - The application-defined stream transformer; the
--   conduit receives the request as input stream and should create the
--   output stream that is internally sent back to the client</li>
--   <li><a>Control</a> a - Control action</li>
--   </ul>
--   
--   A very simple example, which just sends the incoming stream back to
--   the client (<tt>bounce</tt>):
--   
--   <pre>
--   import           Control.Monad (forever)
--   import           Control.Concurrent
--   import           Network.Mom.Patterns.Basic.Server
--   import           Network.Mom.Patterns.Types
--   </pre>
--   
--   <pre>
--   main :: IO ()
--   main = withContext 1 $ \ctx -&gt; 
--              withServer ctx "Bouncer" "tcp://*:5555" Bind
--                         (\_ _ _ -&gt; return ()) -- ignore error
--                         bounce $ \_ -&gt; forever $ threadDelay 100000
--     where bounce = passThrough
--   </pre>
withServer :: Context -> Service -> String -> LinkType -> OnError_ -> Conduit_ -> Control a -> IO a

-- | A simple load balancer device to link clients and servers.
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - The service name of this queue</li>
--   <li>(String, <a>LinkType</a>) - Address and link type, to where
--   clients connect. Note if clients connect, the queue must bind the
--   address!</li>
--   <li>(String, <a>LinkType</a>) - Address and link type, to where
--   servers connect. Note, again, that if servers connect, the queue must
--   bind the address!</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Control</a> a - <a>Controller</a> action</li>
--   </ul>
withQueue :: Context -> Service -> (String, LinkType) -> (String, LinkType) -> OnError_ -> Control a -> IO a


-- | Publish side of 'Publish/Subscribe'
module Network.Mom.Patterns.Basic.Publisher

-- | Publisher data type
data Pub

-- | Create and link a publisher:
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>String</a> - The service address</li>
--   <li><a>LinkType</a> - How to link (bind or connect)</li>
--   <li>(Pub -&gt; IO a) - The action, in whose scope the publisher
--   lives</li>
--   </ul>
withPub :: Context -> String -> LinkType -> (Pub -> IO a) -> IO a

-- | Publish data:
--   
--   <ul>
--   <li><a>Pub</a> - The publisher</li>
--   <li>[<a>Service</a>] - List of topics, to which these data should be
--   published</li>
--   <li><a>Source</a> - Create the stream to publish. The first message
--   segment contains the subscription header, <i>i.e.</i> the
--   comma-separated list of topics</li>
--   </ul>
issue :: Pub -> [Service] -> Source -> IO ()

-- | A simple forwarder, <i>i.e.</i> a device that connects to a publisher
--   and provides an additional endpoint for more subscribers to connect
--   to. A forwarder, hence, is a means to extend the capacity of a
--   publisher.
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - The name of the forwarder</li>
--   <li>(String, <a>LinkType</a>) - access point for subscribers; usually,
--   you want to bind the address, such that subscribers connect to
--   it.</li>
--   <li>(String, <a>LinkType</a>) - access point for the publisher;
--   usually, you want to connect to the publisher.</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Control</a> a - Control loop</li>
--   </ul>
withForwarder :: Context -> Service -> [Service] -> (String, LinkType) -> (String, LinkType) -> OnError_ -> Control a -> IO a


-- | Subscriber side of 'Publish Subscribe'
module Network.Mom.Patterns.Basic.Subscriber

-- | Subscription data type
data Sub

-- | Create a subscription and start the action, in which it lives
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>String</a> - The address</li>
--   <li><a>LinkType</a> - The link type, usually Connect</li>
--   <li>(<a>Sub</a> -&gt; IO a) - The action, in which the subscription
--   lives</li>
--   </ul>
withSub :: Context -> String -> LinkType -> (Sub -> IO a) -> IO a

-- | Subscribe to a list of topics; Note that a subscriber has to subscribe
--   to at least one topic to receive any data.
--   
--   <ul>
--   <li><a>Sub</a> - The subscriber</li>
--   <li>[<a>Service</a>] - The list of topics to subscribe to</li>
--   </ul>
subscribe :: Sub -> [Service] -> IO ()

-- | Check for new data:
--   
--   <ul>
--   <li><a>Sub</a> - The subscriber</li>
--   <li><a>Timeout</a> - When timeout expires, the function returns
--   <a>Nothing</a>. Timeout may be -1 - listen eternally, 0 - return
--   immediately, &gt; 0 - timeout in microseconds</li>
--   <li><a>SinkR</a> - Sink the result stream. Note that the subscription
--   header, <i>i.e.</i> a message segment containing a comma-separated
--   list of the topics, to which the data belong, is dropped.</li>
--   </ul>
checkSub :: Sub -> Timeout -> SinkR (Maybe a) -> IO (Maybe a)


-- | Pusher side of 'Pipeline'
module Network.Mom.Patterns.Basic.Pusher

-- | The pusher data type
data Pusher

-- | The function in whose scope the pusher lives:
--   
--   <ul>
--   <li><a>Context</a> - The zeromq Context</li>
--   <li><a>String</a> - The address</li>
--   <li><a>LinkType</a> - Link type; usually, you want to bind a pusher to
--   its address</li>
--   <li>(<a>Pusher</a> -&gt; IO a) - Action in whose scope the pusher
--   lives</li>
--   </ul>
withPusher :: Context -> String -> LinkType -> (Pusher -> IO a) -> IO a

-- | Push a job down the pipeline; the <a>Source</a> creates the outgoing
--   stream.
push :: Pusher -> Source -> IO ()


-- | Puller side of 'Pipeline'
module Network.Mom.Patterns.Basic.Puller

-- | Start a puller as a background service:
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - Service name of this worker</li>
--   <li><a>String</a> - The address to link to</li>
--   <li><a>LinkType</a> - Whether to connect to or to bind the address;
--   usually you want to connect many workers to one pusher</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Sink</a> - The application-defined sink that does the job sent
--   down the pipeline</li>
--   <li><a>Control</a> a - Control loop</li>
--   </ul>
withPuller :: Context -> Service -> String -> LinkType -> OnError_ -> Sink -> (Controller -> IO a) -> IO a

-- | A pipeline extends the capacity of the pusher-puller chain; a pipeline
--   connects to a pusher and provides an access point to a set of pullers.
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - The service name of this queue</li>
--   <li>(String, <a>LinkType</a>) - Address and link type, to where
--   pullers connect. Note: if pullers connect, the pipeline must bind the
--   address!</li>
--   <li>(String, <a>LinkType</a>) - Address and link type that pushers
--   bind. Note, again, that if pusher bind, the pipeline must connect to
--   the address!</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Control</a> a - <a>Controller</a> action</li>
--   </ul>
withPipe :: Context -> Service -> (String, LinkType) -> (String, LinkType) -> OnError_ -> (Controller -> IO a) -> IO a


-- | Basic communication patterns
module Network.Mom.Patterns.Basic


-- | Majordomo common definitions
module Network.Mom.Patterns.Broker.Common

-- | Majordomo protocol client/worker version 1
mdpC01 :: ByteString

-- | Majordomo protocol client/worker version 1
mdpW01 :: ByteString

-- | Message types (ready, request, reply, heartbeat, disconnect)
xReady :: ByteString

-- | Message types (ready, request, reply, heartbeat, disconnect)
xDisc :: ByteString

-- | Message types (ready, request, reply, heartbeat, disconnect)
xHeartBeat :: ByteString

-- | Message types (ready, request, reply, heartbeat, disconnect)
xReply :: ByteString

-- | Message types (ready, request, reply, heartbeat, disconnect)
xRequest :: ByteString

-- | Service name
type ServiceName = String

-- | Majordomo Management Interface (MMI) - "mmi.service"
mmiHdr :: ByteString

-- | Majordomo Management Interface (MMI) - "mmi.service"
mmiSrv :: ByteString

-- | Majordomo Management Interface -- responses: Found ("200"), NotFound
--   ("404"), NotImplemented ("501")
mmiFound :: ByteString

-- | Majordomo Management Interface -- responses: Found ("200"), NotFound
--   ("404"), NotImplemented ("501")
mmiNimpl :: ByteString

-- | Majordomo Management Interface -- responses: Found ("200"), NotFound
--   ("404"), NotImplemented ("501")
mmiNotFound :: ByteString

-- | Client -&gt; Broker: send request
mdpCSndReq :: ServiceName -> Conduit ByteString ()

-- | Client -&gt; Broker: receive request
mdpCRcvReq :: Conduit o (Identity, ByteString)

-- | Broker -&gt; Client: send reply
mdpCSndRep :: ByteString -> [Identity] -> Conduit ByteString ()

-- | Broker -&gt; Client: receive reply
mdpCRcvRep :: ServiceName -> Conduit ByteString ()

-- | Broker -&gt; Server: send request
mdpWSndReq :: Identity -> [Identity] -> Conduit ByteString ()

-- | Broker -&gt; Server: receive request
mdpWRcvReq :: Conduit o WFrame

-- | Server -&gt; Broker: send reply
mdpWSndRep :: [Identity] -> Conduit ByteString ()

-- | Server -&gt; Broker: receive reply
mdpWRcvRep :: Conduit o WFrame

-- | Broker &lt;-&gt; Server: send heartbeat
mdpWBeat :: Conduit ByteString ()

-- | Server -&gt; Broker: send connect request (ready)
mdpWConnect :: ServiceName -> Source

-- | Server -&gt; Broker: disconnect
mdpWDisconnect :: Source

-- | Broker -&gt; Server: disconnect
mdpWBrkDisc :: Identity -> Source

-- | Broker / Server protocol: Heartbeat, Ready, Reply, Request, Disconnect
data WFrame
WBeat :: Identity -> WFrame
WReady :: Identity -> ByteString -> WFrame
WReply :: Identity -> [Identity] -> WFrame
WRequest :: [Identity] -> WFrame
WDisc :: Identity -> WFrame

-- | Worker Frame Type
data FrameType
ReadyT :: FrameType
RequestT :: FrameType
ReplyT :: FrameType
HeartBeatT :: FrameType
DisconnectT :: FrameType

-- | Get frame type
frameType :: Conduit o FrameType

-- | Get empty segment
empty :: Conduit o ()

-- | Check segment contents
chunk :: ByteString -> String -> Conduit o ()

-- | Get segment contents
getChunk :: Conduit o ByteString

-- | Get identity
identity :: Conduit o Identity

-- | Get block of identities (<a>envelope</a>)
envelope :: Conduit o [Identity]

-- | Create envelope [(identity, B.empty)]
toIs :: [Identity] -> [ByteString]

-- | MDP Exception
data MDPException

-- | Server-side exception
ServerExc :: String -> MDPException

-- | Client-side exception
ClientExc :: String -> MDPException

-- | Broker exception
BrokerExc :: String -> MDPException

-- | Generic Protocol
MDPExc :: String -> MDPException

-- | MMI Protocol
MMIExc :: String -> MDPException
instance Typeable MDPException
instance Eq WFrame
instance Show WFrame
instance Eq FrameType
instance Show FrameType
instance Read FrameType
instance Show MDPException
instance Read MDPException
instance Eq MDPException
instance Exception MDPException


-- | Majordomo Client
module Network.Mom.Patterns.Broker.Client

-- | Client data type
data Client

-- | Create a client and start the action, in whose scope the client lives;
withClient :: Context -> Service -> String -> LinkType -> (Client -> IO a) -> IO a

-- | Service discovery: The function checks whether the client's service is
--   provided by the broker.
--   
--   Return values:
--   
--   <ul>
--   <li>Nothing: The broker timed out</li>
--   <li>Just False: The service is not available</li>
--   <li>Just True: The service is available</li>
--   </ul>
checkService :: Client -> Timeout -> IO (Maybe Bool)

-- | Request a service:
--   
--   <ul>
--   <li><a>Client</a> - The client, through which the service is
--   requested</li>
--   <li><a>Timeout</a> - Timeout in microseconds, -1 to wait eternally.
--   With timeout = 0, the function returns immediately with
--   <a>Nothing</a>. When the timeout expires, request is abandoned. In
--   this case, the result of the request is Nothing.</li>
--   <li><a>Source</a> - The source of the request stream; the format of
--   the request will probably comply with some communication protocol, as,
--   for instance, in the majordomo pattern.</li>
--   <li><a>SinkR</a> - The sink receiving the reply. The result of the
--   sink is returned as the request's overall result. Note that the sink
--   may perform different actions on the segments of the resulting stream,
--   <i>e.g.</i> storing data in a database, and return the number of
--   records received.</li>
--   </ul>
request :: Client -> Timeout -> Source -> SinkR (Maybe a) -> IO (Maybe a)

-- | Check for a of a previously requested result; use case: request with
--   timout 0, do some work and check for a result later. Do not use this
--   function without having requested the service previously. The
--   parameters equal those of <a>request</a>, but do not include a
--   <a>Source</a>.
checkResult :: Client -> Timeout -> SinkR (Maybe a) -> IO (Maybe a)


-- | Majordomo Server
module Network.Mom.Patterns.Broker.Server

-- | Start a server as a background process
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - Service name; the service name is used to
--   register at the broker.</li>
--   <li><a>Msec</a> - Heartbeat in Milliseconds; must be synchronised with
--   the broker heartbeat</li>
--   <li><a>String</a> - The address to link to</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Conduit_</a> - The application-defined stream transformer; the
--   conduit receives the request as input stream and should create the
--   output stream that is internally sent back to the client</li>
--   <li><a>Control</a> a - Control action</li>
--   </ul>
withServer :: Context -> Service -> Msec -> String -> OnError_ -> Conduit_ -> (Control a) -> IO a


-- | Majordomo Broker
module Network.Mom.Patterns.Broker.Broker

-- | Start a broker as a background process
--   
--   <ul>
--   <li><a>Context</a> - The zeromq context</li>
--   <li><a>Service</a> - Service name - the service name is for debugging
--   only, there is no relation whatsoever to the service of the Majordomo
--   Protocol.</li>
--   <li><a>Msec</a> - The heartbeat interval in milliseconds, which should
--   be equal for all workers and the broker</li>
--   <li><a>String</a> - The address clients connect to</li>
--   <li><a>String</a> - The address servers connect to</li>
--   <li><a>OnError_</a> - Error handler</li>
--   <li><a>Control</a> a - Control action</li>
--   </ul>
withBroker :: Context -> Service -> Msec -> String -> String -> OnError_ -> (Controller -> IO r) -> IO r


-- | Majordomo Service Broker
module Network.Mom.Patterns.Broker


-- | In distributed message-oriented applications, the same communication
--   patterns show up over and over again. This package implements some of
--   these patterns based on the <i>zeromq</i> library. <i>Patterns</i>
--   uses the <i>zeromq-haskell</i> package, but goes beyond in several
--   aspects:
--   
--   <ul>
--   <li>It uses <i>conduits</i> to stream incoming and outgoing message
--   segments;</li>
--   <li>It defines libraries of basic patterns to enforce coherent use of
--   <i>zeromq</i> sockets;</li>
--   <li>It implements modules for advanced patterns; currently the
--   majordomo pattern (broker) is implemented.</li>
--   </ul>
--   
--   More information on <i>zeromq</i> can be found at
--   <a>http://www.zeromq.org</a>.
module Network.Mom.Patterns
