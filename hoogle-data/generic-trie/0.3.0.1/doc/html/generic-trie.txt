-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A map, where the keys may be complex structured data.
--   
@package generic-trie
@version 0.3.0.1


-- | Unstable implementation details
module Data.GenericTrie.Internal

-- | Types that may be used as the key of a <a>Trie</a>.
--   
--   For <tt>data</tt> delcarations, the instance can be automatically
--   derived from a <a>Generic</a> instance.
class TrieKey k where type family TrieRep k :: * -> * type instance TrieRep k = TrieRepDefault k trieEmpty = genericEmpty trieSingleton = genericSingleton trieNull = genericTrieNull trieLookup = genericLookup trieInsert = genericInsert trieDelete = genericDelete trieMap = genericTrieMap trieTraverse = genericTrieTraverse trieShowsPrec = genericTrieShowsPrec trieMapMaybeWithKey = genericMapMaybeWithKey trieFoldWithKey = genericFoldWithKey trieTraverseWithKey = genericTraverseWithKey trieMergeWithKey = genericMergeWithKey trieAt = genericAt
trieEmpty :: TrieKey k => Trie k a
trieNull :: TrieKey k => Trie k a -> Bool
trieLookup :: TrieKey k => k -> Trie k a -> Maybe a
trieInsert :: TrieKey k => k -> a -> Trie k a -> Trie k a
trieDelete :: TrieKey k => k -> Trie k a -> Trie k a
trieAt :: (TrieKey k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Trie k a -> f (Trie k a)
trieSingleton :: TrieKey k => k -> a -> Trie k a
trieMap :: TrieKey k => (a -> b) -> Trie k a -> Trie k b
trieTraverse :: (TrieKey k, Applicative f) => (a -> f b) -> Trie k a -> f (Trie k b)
trieShowsPrec :: (TrieKey k, Show a) => Int -> Trie k a -> ShowS
trieMapMaybeWithKey :: TrieKey k => (k -> a -> Maybe b) -> Trie k a -> Trie k b
trieFoldWithKey :: TrieKey k => (k -> a -> r -> r) -> r -> Trie k a -> r
trieTraverseWithKey :: (TrieKey k, Applicative f) => (k -> a -> f b) -> Trie k a -> f (Trie k b)
trieMergeWithKey :: TrieKey k => (k -> a -> b -> Maybe c) -> (Trie k a -> Trie k c) -> (Trie k b -> Trie k c) -> Trie k a -> Trie k b -> Trie k c

-- | A map from keys of type <tt>k</tt>, to values of type <tt>a</tt>.
newtype Trie k a
MkTrie :: (TrieRep k a) -> Trie k a

-- | Tries indexed by <a>OrdKey</a> will be represented as an ordinary
--   <a>Map</a> and the keys will be compared based on the <a>Ord</a>
--   instance for <tt>k</tt>.
newtype OrdKey k
OrdKey :: k -> OrdKey k
getOrdKey :: OrdKey k -> k

-- | Generic implementation of <a>trieNull</a>. This is the default
--   implementation.
genericTrieNull :: TrieRep k ~ TrieRepDefault k => Trie k a -> Bool

-- | Generic implementation of <a>trieMap</a>. This is the default
--   implementation.
genericTrieMap :: (GTrieKey (Rep k), TrieRep k ~ TrieRepDefault k) => (a -> b) -> Trie k a -> Trie k b

-- | Generic implementation of <a>trieTraverse</a>. This is the default
--   implementation.
genericTrieTraverse :: (GTrieKey (Rep k), TrieRep k ~ TrieRepDefault k, Applicative f) => (a -> f b) -> Trie k a -> f (Trie k b)

-- | Generic implementation of <a>trieShowsPrec</a>. This is the default
--   implementation.
genericTrieShowsPrec :: (Show a, GTrieKeyShow (Rep k), TrieRep k ~ TrieRepDefault k) => Int -> Trie k a -> ShowS

-- | Generic implementation of <tt>insert</tt>. This is the default
--   implementation.
genericInsert :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => k -> a -> Trie k a -> Trie k a

-- | Generic implementation of <a>lookup</a>. This is the default
--   implementation.
genericLookup :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => k -> Trie k a -> Maybe a

-- | Generic implementation of <tt>delete</tt>. This is the default
--   implementation.
genericDelete :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => k -> Trie k a -> Trie k a

-- | Generic implementation of <tt>mapMaybe</tt>. This is the default
--   implementation.
genericMapMaybeWithKey :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => (k -> a -> Maybe b) -> Trie k a -> Trie k b

-- | Generic implementation of <tt>singleton</tt>. This is the default
--   implementation.
genericSingleton :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => k -> a -> Trie k a

-- | Generic implementation of <tt>empty</tt>. This is the default
--   implementation.
genericEmpty :: TrieRep k ~ TrieRepDefault k => Trie k a

-- | Generic implementation of <tt>insert</tt>. This is the default
--   implementation.
genericAt :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Trie k a -> f (Trie k a)

-- | Generic implementation of <tt>foldWithKey</tt>. This is the default
--   implementation.
genericFoldWithKey :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k) => (k -> a -> r -> r) -> r -> Trie k a -> r

-- | Generic implementation of <tt>traverseWithKey</tt>. This is the
--   default implementation.
genericTraverseWithKey :: (GTrieKey (Rep k), Generic k, TrieRep k ~ TrieRepDefault k, Applicative f) => (k -> a -> f b) -> Trie k a -> f (Trie k b)

-- | The default implementation of a <a>TrieRep</a> is <a>GTrie</a> wrapped
--   in a <a>Maybe</a>. This wrapping is due to the <a>GTrie</a> being a
--   non-empty trie allowing all the of the "emptiness" to be represented
--   at the top level for any given generically implemented key.
type TrieRepDefault k = Compose Maybe (GTrie (Rep k))

-- | TrieKey operations on Generic representations used to provide the
--   default implementations of tries.
class GTrieKey f
gtrieLookup :: GTrieKey f => f p -> GTrie f a -> Maybe a
gtrieInsert :: GTrieKey f => f p -> a -> GTrie f a -> GTrie f a
gtrieSingleton :: GTrieKey f => f p -> a -> GTrie f a
gtrieDelete :: GTrieKey f => f p -> GTrie f a -> Maybe (GTrie f a)
gtrieMap :: GTrieKey f => (a -> b) -> GTrie f a -> GTrie f b
gtrieTraverse :: (GTrieKey f, Applicative m) => (a -> m b) -> GTrie f a -> m (GTrie f b)
gmapMaybeWithKey :: GTrieKey f => (f p -> a -> Maybe b) -> GTrie f a -> Maybe (GTrie f b)
gfoldWithKey :: GTrieKey f => (f p -> a -> r -> r) -> r -> GTrie f a -> r
gtraverseWithKey :: (GTrieKey f, Applicative m) => (f p -> a -> m b) -> GTrie f a -> m (GTrie f b)
gmergeWithKey :: GTrieKey f => (f p -> a -> b -> Maybe c) -> (GTrie f a -> Maybe (GTrie f c)) -> (GTrie f b -> Maybe (GTrie f c)) -> GTrie f a -> GTrie f b -> Maybe (GTrie f c)
gtrieAt :: (GTrieKey f, Functor m) => (Maybe (GTrie f a) -> r) -> f p -> (Maybe a -> m (Maybe a)) -> GTrie f a -> m r

-- | Mapping of generic representation of keys to trie structures.
instance Read k => Read (OrdKey k)
instance Show k => Show (OrdKey k)
instance Eq k => Eq (OrdKey k)
instance Ord k => Ord (OrdKey k)
instance TrieKey k => Traversable (Trie k)
instance TrieKey k => Foldable (Trie k)
instance TrieKey k => Functor (Trie k)
instance (Show a, GTrieKeyShow f) => Show (GTrie f a)
instance (Show a, TrieKey k) => Show (Trie k a)
instance GTrieKeyShow V1
instance GTrieKey V1
instance GTrieKeyShow U1
instance GTrieKey U1
instance (GTrieKeyShow f, GTrieKeyShow g) => GTrieKeyShow (f :+: g)
instance (GTrieKey f, GTrieKey g) => GTrieKey (f :+: g)
instance (GTrieKeyShow f, GTrieKeyShow g) => GTrieKeyShow (f :*: g)
instance (GTrieKey f, GTrieKey g) => GTrieKey (f :*: g)
instance TrieKey k => GTrieKeyShow (K1 i k)
instance TrieKey k => GTrieKey (K1 i k)
instance GTrieKeyShow f => GTrieKeyShow (M1 S s f)
instance (Constructor c, GTrieKeyShow f) => GTrieKeyShow (M1 C c f)
instance GTrieKeyShow f => GTrieKeyShow (M1 D d f)
instance GTrieKey f => GTrieKey (M1 i c f)
instance GTrieKey f => Functor (GTrie f)
instance TrieKey k => TrieKey [k]
instance (TrieKey a, TrieKey b, TrieKey c, TrieKey d, TrieKey e) => TrieKey (a, b, c, d, e)
instance (TrieKey a, TrieKey b, TrieKey c, TrieKey d) => TrieKey (a, b, c, d)
instance (TrieKey a, TrieKey b, TrieKey c) => TrieKey (a, b, c)
instance (TrieKey a, TrieKey b) => TrieKey (a, b)
instance (TrieKey a, TrieKey b) => TrieKey (Either a b)
instance TrieKey k => TrieKey (Maybe k)
instance TrieKey Bool
instance TrieKey ()
instance (Show k, Ord k) => TrieKey (OrdKey k)
instance TrieKey Char
instance TrieKey Integer
instance TrieKey Int


-- | This module implements an interface for working with maps.
--   
--   For primitive types, like <a>Int</a>, the library automatically
--   selects an efficient implementation (e.g., an <a>IntMap</a>).
--   
--   For complex structured types, the library uses an implementation based
--   on tries: this is useful when using large and similar keys where
--   comparing for order may become expensive, and storing the distinct
--   keys would be inefficient.
--   
--   The <a>OrdKey</a> type allows for maps with complex keys, where the
--   keys are compared based on order, rather than using the trie
--   implementation.
--   
--   All methods of <a>TrieKey</a> can be derived automatically using a
--   <a>Generic</a> instance.
--   
--   <pre>
--   data Demo = DemoC1 <a>Int</a> | DemoC2 <a>Int</a> <a>Char</a>  deriving <a>Generic</a>
--   
--   instance <a>TrieKey</a> Demo
--   </pre>
module Data.GenericTrie

-- | A map from keys of type <tt>k</tt>, to values of type <tt>a</tt>.
data Trie k a

-- | Types that may be used as the key of a <a>Trie</a>.
--   
--   For <tt>data</tt> delcarations, the instance can be automatically
--   derived from a <a>Generic</a> instance.
class TrieKey k where type instance TrieRep k = TrieRepDefault k trieEmpty = genericEmpty trieSingleton = genericSingleton trieNull = genericTrieNull trieLookup = genericLookup trieInsert = genericInsert trieDelete = genericDelete trieMap = genericTrieMap trieTraverse = genericTrieTraverse trieShowsPrec = genericTrieShowsPrec trieMapMaybeWithKey = genericMapMaybeWithKey trieFoldWithKey = genericFoldWithKey trieTraverseWithKey = genericTraverseWithKey trieMergeWithKey = genericMergeWithKey trieAt = genericAt

-- | Construct an empty trie
empty :: TrieKey k => Trie k a

-- | Construct a trie holding a single value
singleton :: TrieKey k => k -> a -> Trie k a

-- | Construct a trie from a list of key-value pairs
fromList :: TrieKey k => [(k, v)] -> Trie k v

-- | Construct a trie from a list of key-value pairs. The given function is
--   used to combine values at the same key.
fromListWith :: TrieKey k => (v -> v -> v) -> [(k, v)] -> Trie k v

-- | Version of <a>fromListWith</a> which is strict in the result of the
--   combining function.
fromListWith' :: TrieKey k => (v -> v -> v) -> [(k, v)] -> Trie k v

-- | Alter the value at the given key location. The parameter function
--   takes the value stored at the given key, if one exists, and should
--   return a value to insert at that location, or <a>Nothing</a> to delete
--   from that location.
alter :: TrieKey k => k -> (Maybe a -> Maybe a) -> Trie k a -> Trie k a

-- | Insert an element into a trie
insert :: TrieKey k => k -> a -> Trie k a -> Trie k a

-- | Insert a value at the given key. The combining function is used when a
--   value is already stored at that key. The new value is the first
--   argument to the combining function.
insertWith :: TrieKey k => (v -> v -> v) -> k -> v -> Trie k v -> Trie k v

-- | Version of <a>insertWith</a> that is strict in the result of combining
--   two elements.
insertWith' :: TrieKey k => (v -> v -> v) -> k -> v -> Trie k v -> Trie k v

-- | Delete an element from a trie
delete :: TrieKey k => k -> Trie k a -> Trie k a

-- | Lens for the value at a given key
at :: (Functor f, TrieKey k) => k -> (Maybe a -> f (Maybe a)) -> Trie k a -> f (Trie k a)

-- | Returns <a>True</a> when the <a>Trie</a> has a value stored at the
--   given key.
member :: TrieKey k => k -> Trie k a -> Bool

-- | Returns <a>False</a> when the <a>Trie</a> has a value stored at the
--   given key.
notMember :: TrieKey k => k -> Trie k a -> Bool

-- | Test for an empty trie
null :: TrieKey k => Trie k a -> Bool

-- | Lookup an element from a trie
lookup :: TrieKey k => k -> Trie k a -> Maybe a

-- | Fold a trie with a function of both key and value
foldWithKey :: TrieKey k => (k -> a -> r -> r) -> r -> Trie k a -> r

-- | Fold a trie with a function of the value
fold :: TrieKey k => (a -> r -> r) -> r -> Trie k a -> r

-- | Transform a trie to an association list.
toList :: TrieKey k => Trie k a -> [(k, a)]

-- | Traverse a trie with a function of both key and value
traverseWithKey :: (TrieKey k, Applicative f) => (k -> a -> f b) -> Trie k a -> f (Trie k b)

-- | Map a function over a trie filtering out elements where function
--   returns <a>Nothing</a>
mapMaybe :: TrieKey k => (a -> Maybe b) -> Trie k a -> Trie k b

-- | Apply a function to the values of a trie and keep the elements of the
--   trie that result in a <a>Just</a> value.
mapMaybeWithKey :: TrieKey k => (k -> a -> Maybe b) -> Trie k a -> Trie k b

-- | Filter the values of a trie with the given predicate.
filter :: TrieKey k => (a -> Bool) -> Trie k a -> Trie k a

-- | Version of <a>filter</a> where the predicate also gets the key.
filterWithKey :: TrieKey k => (k -> a -> Bool) -> Trie k a -> Trie k a

-- | Left-biased union of two tries
union :: TrieKey k => Trie k a -> Trie k a -> Trie k a

-- | Union of two tries with function used to merge overlapping elements
unionWith :: TrieKey k => (a -> a -> a) -> Trie k a -> Trie k a -> Trie k a

-- | Union of two tries with function used to merge overlapping elements
--   along with key
unionWithKey :: TrieKey k => (k -> a -> a -> a) -> Trie k a -> Trie k a -> Trie k a

-- | Left-biased intersection of two tries
intersection :: TrieKey k => Trie k a -> Trie k b -> Trie k a

-- | Intersection of two tries parameterized by a combining function of the
--   values at overlapping keys
intersectionWith :: TrieKey k => (a -> b -> c) -> Trie k a -> Trie k b -> Trie k c

-- | Intersection of two tries parameterized by a combining function of the
--   key and the values at overlapping keys
intersectionWithKey :: TrieKey k => (k -> a -> b -> c) -> Trie k a -> Trie k b -> Trie k c

-- | Remove the keys of the right trie from the left trie
difference :: TrieKey k => Trie k a -> Trie k b -> Trie k a

-- | Parameterized <a>difference</a> using a custom merge function. Return
--   <a>Just</a> to change the value stored in left trie, or <a>Nothing</a>
--   to remove from the left trie.
differenceWith :: TrieKey k => (a -> b -> Maybe a) -> Trie k a -> Trie k b -> Trie k a

-- | <a>differenceWith</a> where function also has access to the key
differenceWithKey :: TrieKey k => (k -> a -> b -> Maybe a) -> Trie k a -> Trie k b -> Trie k a

-- | Tries indexed by <a>OrdKey</a> will be represented as an ordinary
--   <a>Map</a> and the keys will be compared based on the <a>Ord</a>
--   instance for <tt>k</tt>.
newtype OrdKey k
OrdKey :: k -> OrdKey k
getOrdKey :: OrdKey k -> k
