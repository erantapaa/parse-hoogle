-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell SuperCollider Language
--   
@package hsc3-lang
@version 0.15


-- | Denis Lorrain. "A Panoply of Stochastic 'Cannons'". <i>Computer Music
--   Journal</i>, 4(1):53-81, Spring 1980.
module Sound.SC3.Lang.Random.Lorrain_1980

-- | §4.3.1 (g=1)
--   
--   <pre>
--   import System.Random
--   let r = take 32768 (randomRs (0.0,1.0) (mkStdGen 12345))
--   </pre>
--   
--   <pre>
--   import Sound.SC3.Plot
--   import Sound.SC3.Plot.Histogram
--   let h = plotHistogram . map (histogram 512)
--   </pre>
--   
--   <pre>
--   h [map (linear 1.0) r]
--   </pre>
linear :: Floating a => a -> a -> a

-- | §4.3.2 (δ=[0.5,1,2])
--   
--   <pre>
--   h (map (\d -&gt; map (exponential d) r) [0.5,1,2])
--   </pre>
exponential :: Floating a => a -> a -> a

-- | §4.3.5 (τ=1)
--   
--   <pre>
--   h [map (cauchy 1.0) r]
--   </pre>
--   
--   <pre>
--   import Data.Maybe
--   let narrow z n = if n &lt; -z || n &gt; z then Nothing else Just n
--   h [mapMaybe (narrow 10 . cauchy 1.0) r]
--   </pre>
cauchy :: Floating a => a -> a -> a

-- | §4.3.5 (iopt=False,τ=1) (Algorithm 10)
--   
--   <pre>
--   h [mapMaybe (narrow 20 . cauchy' False 1.0) r]
--   h [mapMaybe (narrow 20 . cauchy' True 1.0) r]
--   </pre>
cauchy' :: Floating a => Bool -> a -> a -> a

-- | §4.3.6
--   
--   <pre>
--   h [map hyperbolic_cosine r]
--   </pre>
hyperbolic_cosine :: Floating a => a -> a

-- | §4.3.7 (β=0,α=1)
--   
--   <pre>
--   h [map (logistic 0.0 1.0) r]
--   </pre>
logistic :: Floating a => a -> a -> a -> a

-- | §4.3.8
--   
--   <pre>
--   h [map arc_sine r]
--   </pre>
arc_sine :: Floating a => a -> a

-- | §4.4.2 (Algorithm 15)
--   
--   <pre>
--   let adj l = case l of {[] -&gt; []; p:q:l' -&gt; (p,q) : adj l'}
--   let r' = adj r
--   h [mapMaybe (beta 0.45 0.45) r'
--     ,mapMaybe (beta 0.65 0.45) r'
--     ,mapMaybe (beta 0.45 0.65) r']
--   </pre>
--   
--   <pre>
--   h [mapMaybe (beta 0.35 0.5) r'
--     ,mapMaybe (beta 0.5 0.65) r']
--   </pre>
beta :: (Floating a, Ord a) => a -> a -> (a, a) -> Maybe a


-- | <a>P</a> type, instance and core functions.
module Sound.SC3.Lang.Pattern.P.Core

-- | Patterns are opaque. <tt>P a</tt> is a pattern with elements of type
--   <tt>a</tt>. Patterns are constructed, manipulated and destructured
--   using the functions provided, ie. the pattern instances for
--   <a>return</a>, <a>pure</a> and <a>toList</a>, and the pattern specific
--   functions <a>undecided</a> and <a>toP</a>.
--   
--   <pre>
--   F.toList (toP [1,2,3] * 2) == [2,4,6]
--   </pre>
--   
--   Patterns are <a>Functor</a>s. <a>fmap</a> applies a function to each
--   element of a pattern.
--   
--   <pre>
--   fmap (* 2) (toP [1,2,3,4,5]) == toP [2,4,6,8,10]
--   </pre>
--   
--   Patterns are <a>Monoid</a>s. <a>mempty</a> is the empty pattern, and
--   <a>mappend</a> (<a>&lt;&gt;</a>) makes a sequence of two patterns.
--   
--   <pre>
--   1 &lt;&gt; mempty &lt;&gt; 2 == toP [1,2]
--   </pre>
--   
--   Patterns are <a>Applicative</a>. The pattern instance is pointwise
--   &amp; truncating, as for <a>ZipList</a>. <a>pure</a> lifts a value
--   into an infinite pattern of itself, <a>&lt;*&gt;</a> applies a pattern
--   of functions to a pattern of values. This is distinct from the
--   combinatorial instance for ordinary lists, ie. where <a>pure</a> is
--   <a>return</a> and <a>&lt;*&gt;</a> is <a>ap</a>.
--   
--   <pre>
--   liftA2 (+) (toP [1,2]) (toP [3,4,5]) == toP [4,6]
--   liftA2 (+) [1,2] [3,4,5] == [4,5,6,5,6,7]
--   </pre>
--   
--   Patterns are <a>Monad</a>s, and therefore allow <i>do</i> notation.
--   
--   <pre>
--   let p = do {x &lt;- toP [1,2]; y &lt;- toP [3,4,5]; return (x,y)}
--   in p == toP [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
--   </pre>
--   
--   Patterns are <a>Num</a>erical. The instances can be derived from the
--   <a>Applicative</a> instance.
--   
--   <pre>
--   1 + toP [2,3,4] == liftA2 (+) 1 (toP [2,3,4])
--   </pre>
data P a
P :: Either a [a] -> P a
unP_either :: P a -> Either a [a]

-- | Lift a value to a pattern deferring deciding if the constructor ought
--   to be <a>pure</a> or <a>return</a> to the consuming function. The
--   pattern instances for <a>fromInteger</a> and <a>fromRational</a> make
--   <a>undecided</a> patterns. In general <i>horizontal</i> functions (ie.
--   <a>&lt;&gt;</a>) resolve using <a>return</a> and <i>vertical</i>
--   functions (ie. <a>zip</a>) resolve using <a>pure</a>. In the
--   documentation functions that resolve using <a>pure</a> are annotated
--   as <i>implicitly repeating</i>.
--   
--   <pre>
--   1 &lt;&gt; toP [2,3] == return 1 &lt;&gt; toP [2,3]
--   toP [1,2] * 3  == toP [1,2] * pure 3
--   </pre>
undecided :: a -> P a

-- | The basic list to pattern function, inverse is <a>unP</a>.
--   
--   <pre>
--   unP (toP "str") == "str"
--   </pre>
--   
--   There is a <tt>default</tt> sound, given by <tt>defaultSynthdef</tt>
--   from <a>Sound.SC3</a>.
--   
--   <pre>
--   audition defaultSynthdef
--   </pre>
--   
--   If no instrument is specified we hear the default.
--   
--   <pre>
--   audition (pbind [(K_degree,pxrand 'α' [0,1,5,7] inf)
--                   ,(K_dur,toP [0.1,0.2,0.1])])
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,(Pxrand([0,1,5,7],inf))
--   &gt;      ,\dur,Pseq([0.1,0.2,0.1],1)).play
--   </pre>
--   
--   The pattern above is finite, <a>toP</a> can sometimes be replaced with
--   <tt>pseq</tt>.
--   
--   <pre>
--   audition (pbind [(K_degree,pxrand 'α' [0,1,5,7] inf)
--                   ,(K_dur,pseq [0.1,0.2,0.1] inf)])
--   </pre>
toP :: [a] -> P a

-- | Type specialised <a>toList</a>. <a>undecided</a> values are singular.
--   
--   <pre>
--   F.toList (undecided 'a') == ['a']
--   unP (return 'a') == ['a']
--   "aaa" `L.isPrefixOf` unP (pure 'a')
--   </pre>
unP :: P a -> [a]

-- | Variant of <a>unP</a> where <a>undecided</a> values are
--   <a>repeat</a>ed.
--   
--   <pre>
--   unP_repeat (return 'a') == ['a']
--   take 2 (unP_repeat (undecided 'a')) == ['a','a']
--   take 2 (unP_repeat (pure 'a')) == ['a','a']
--   </pre>
unP_repeat :: P a -> [a]

-- | Lift unary list function to pattern function.
liftP :: ([a] -> [b]) -> P a -> P b

-- | Lift binary list function to pattern function.
--   
--   <pre>
--   liftP2 (zipWith (+)) (toP [1,2]) (toP [3,4,5]) == toP [4,6]
--   liftA2 (+) (toP [1,2]) (toP [3,4,5]) == toP [4,6]
--   </pre>
liftP2 :: ([a] -> [b] -> [c]) -> P a -> P b -> P c

-- | Lift binary list function to <i>implicitly repeating</i> pattern
--   function.
liftP2_repeat :: ([a] -> [b] -> [c]) -> P a -> P b -> P c

-- | Lift ternary list function to pattern function.
liftP3 :: ([a] -> [b] -> [c] -> [d]) -> P a -> P b -> P c -> P d

-- | Lift ternary list function to <i>implicitly repeating</i> pattern
--   function.
liftP3_repeat :: ([a] -> [b] -> [c] -> [d]) -> P a -> P b -> P c -> P d

-- | An <i>implicitly repeating</i> pattern variant of <a>zipWith</a>.
--   
--   <pre>
--   zipWith (*) [1,2,3] [5,6] == [5,12]
--   pzipWith (*) (toP [1,2,3]) (toP [5,6]) == toP [5,12]
--   </pre>
--   
--   It is the basis for lifting binary operators to patterns.
--   
--   <pre>
--   toP [1,2,3] * toP [5,6] == toP [5,12]
--   </pre>
--   
--   <pre>
--   let p = pzipWith (,) (pseq [1,2] 2) (pseq [3,4] inf)
--   in p == toP [(1,3),(2,4),(1,3),(2,4)]
--   </pre>
--   
--   <pre>
--   zipWith (,) (return 0) (return 1) == return (0,1)
--   pzipWith (,) 0 1 == undecided (0,1)
--   </pre>
pzipWith :: (a -> b -> c) -> P a -> P b -> P c

-- | An <i>implicitly repeating</i> pattern variant of <a>zipWith3</a>.
pzipWith3 :: (a -> b -> c -> d) -> P a -> P b -> P c -> P d

-- | An <i>implicitly repeating</i> pattern variant of <a>zip</a>.
--   
--   <pre>
--   zip (return 0) (return 1) == return (0,1)
--   pzip (undecided 3) (undecided 4) == undecided (3,4)
--   pzip 0 1 == undecided (0,1)
--   </pre>
--   
--   Note that <a>pzip</a> is otherwise like haskell <a>zip</a>, ie.
--   truncating.
--   
--   <pre>
--   zip [1,2] [0] == [(1,0)]
--   pzip (toP [1,2]) (return 0) == toP [(1,0)]
--   pzip (toP [1,2]) (pure 0) == toP [(1,0),(2,0)]
--   pzip (toP [1,2]) 0 == toP [(1,0),(2,0)]
--   </pre>
pzip :: P a -> P b -> P (a, b)

-- | Pattern variant of <a>zip3</a>.
pzip3 :: P a -> P b -> P c -> P (a, b, c)

-- | Pattern variant on <a>unzip</a>.
--   
--   <pre>
--   let p = punzip (pzip (toP [1,2,3]) (toP [4,5]))
--   in p == (toP [1,2],toP [4,5])
--   </pre>
punzip :: P (a, b) -> (P a, P b)
instance Eq a => Eq (P a)
instance Show a => Show (P a)
instance OrdE a => OrdE (P a)
instance Ord a => Ord (P a)
instance Fractional a => Fractional (P a)
instance Num a => Num (P a)
instance MonadPlus P
instance Monad P
instance Traversable P
instance Foldable P
instance Alternative P
instance Applicative P
instance Monoid (P a)
instance Functor P


-- | Windowing functions.
module Sound.SC3.Lang.Math.Window

-- | A function from a (0,1) normalised input to an output.
type Window x = x -> x

-- | A discrete <i>n</i> element rendering of a <a>Window</a>.
type Table x = [x]

-- | Generate an <i>n</i> element table from a (0,1) normalised window
--   function.
window_table :: (Integral n, Fractional a, Enum a) => n -> Window a -> Table a

-- | Regular modified Bessel function of fractional order zero.
bessel0 :: Double -> Double

-- | <i>n</i> ^ 2.
square :: Num a => a -> a

-- | Gaussian window, θ &lt;= 0.5.
gaussian :: Floating a => a -> Window a

-- | Hann raised cosine window.
hann :: Floating a => Window a

-- | Hamming raised cosine window.
hamming :: Floating a => Window a

-- | Kaiser windowing function, β is shape (1,2,8).
kaiser :: Double -> Window Double

-- | <a>sinc</a> window.
lanczos :: Window Double

-- | Unit (<a>id</a>) window, also known as a Dirichlet window.
rectangular :: Window a

-- | <a>sin</a> window.
sine :: Floating a => Window a

-- | Triangular window, ie. Bartlett window with zero end-points.
triangular :: Fractional a => Window a

-- | <a>window_table</a> . <a>gaussian</a>.
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable [gaussian_table 1024 0.25,gaussian_table 1024 0.5]
--   </pre>
gaussian_table :: (Integral n, Floating b, Enum b) => n -> b -> [b]

-- | <a>window_table</a> . <a>hamming</a>.
--   
--   plotTable [hann_table 128,hamming_table 128]
hamming_table :: Int -> [Double]

-- | <a>window_table</a> . <a>hann</a>.
--   
--   plotTable [hann_table 128]
hann_table :: Int -> [Double]

-- | <a>window_table</a> . <a>kaiser</a>.
--   
--   let k = kaiser_table 128 in plotTable [k 1,k 2,k 8]
kaiser_table :: Int -> Double -> [Double]

-- | <a>window_table</a> . <a>lanczos</a>.
--   
--   plotTable [lanczos_table (2^9)]
lanczos_table :: Integral n => n -> [Double]

-- | <a>window_table</a> . <a>sine</a>.
--   
--   plotTable [sine_table 128]
sine_table :: (Integral n, Floating b, Enum b) => n -> [b]

-- | <a>window_table</a> . <a>triangular</a>.
--   
--   plotTable [triangular_table (2^9)]
triangular_table :: (Integral n, Fractional b, Enum b) => n -> [b]


-- | Data set giving formant locations for <a>Vowel</a>s.
module Sound.SC3.Lang.Data.Vowel

-- | Extract <a>Fn</a>th formant triple of an <a>Fdata</a>.
--   
--   <pre>
--   formant F1 (fdata Bass I) == (1750,-30,90)
--   </pre>
formant :: Num n => Fn -> Fdata n -> (n, n, n)

-- | Lookup formant <a>Fdata</a> given <a>Voice</a> and <a>Vowel</a>.
--   
--   <pre>
--   fdata Bass I == (Bass,I,[250,1750,2600,3050,3340]
--                          ,[0,-30,-16,-22,-28]
--                          ,[60,90,100,120,120])
--   </pre>
fdata :: Num n => Voice -> Vowel -> Fdata n

-- | Formant triples of an <a>Fdata</a>.
--   
--   <pre>
--   formants (fdata Bass I) == [(250,0,60)
--                              ,(1750,-30,90)
--                              ,(2600,-16,100)
--                              ,(3050,-22,120)
--                              ,(3340,-28,120)]
--   </pre>
formants :: Num n => Fdata n -> [(n, n, n)]

-- | Enumeration of voices.
data Voice
Soprano :: Voice
Alto :: Voice
CounterTenor :: Voice
Tenor :: Voice
Bass :: Voice

-- | Enumeration of vowels.
data Vowel
A :: Vowel
E :: Vowel
I :: Vowel
O :: Vowel
U :: Vowel

-- | Vowel tuple of form
--   (<a>Voice</a>,<a>Vowel</a>,<i>freq</i>,<i>db</i>,<i>bw</i>).
type Fdata n = (Voice, Vowel, [n], [n], [n])

-- | Enumeration of formant indices.
data Fn
F0 :: Fn
F1 :: Fn
F2 :: Fn
F3 :: Fn
F4 :: Fn

-- | <a>Fdata</a> table.
fdata_table :: Num n => [Fdata n]

-- | Construct a triple from a three element list.
--   
--   <pre>
--   triple [1..3] == Just (1,2,3)
--   </pre>
triple :: [a] -> Maybe (a, a, a)

-- | Partial variant of <a>triple</a>.
--   
--   <pre>
--   triple' [1..3] == (1,2,3)
--   </pre>
triple' :: [a] -> (a, a, a)
instance Enum Voice
instance Bounded Voice
instance Eq Voice
instance Read Voice
instance Show Voice
instance Enum Vowel
instance Bounded Vowel
instance Eq Vowel
instance Read Vowel
instance Show Vowel
instance Enum Fn
instance Bounded Fn
instance Eq Fn
instance Read Fn
instance Show Fn


-- | <a>http://www.csounds.com/manual/html/MiscModalFreq.html</a>
module Sound.SC3.Lang.Data.Modal

-- | Table of modal frequency ratios for specified sound sources.
--   
--   <pre>
--   import Sound.SC3
--   </pre>
--   
--   <pre>
--   let {f = 221
--       ;Just r = lookup "Tibetan bowl (180mm)" modal_frequency_ratios
--       ;u n = replicate (length r) n
--       ;k = klankSpec (map (* f) r) (u 1) (u 16)}
--   in audition (out 0 (klank (impulse AR 0.125 0 * 0.1) 1 0 1 k))
--   </pre>
modal_frequency_ratios :: Fractional n => [(String, [n])]

-- | Table of modal frequencies for subset of
--   <a>modal_frequency_ratios</a>.
modal_frequencies :: Fractional n => [(String, [n])]


-- | Arpabet phoneme definitions and CMU dictionary functions.
--   
--   <a>http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>
--   <a>http://en.wikipedia.org/wiki/Arpabet</a>
module Sound.SC3.Lang.Data.CMUdict

-- | Stress indicators, placed at the stressed syllabic vowel.
data Stress
No_stress :: Stress
Primary_stress :: Stress
Secondary_stress :: Stress

-- | Arpabet phonemes as used at CMU dictionary.
--   
--   <pre>
--   [AO .. NX] == [minBound .. maxBound]
--   length [AO .. NX] == 48
--   </pre>
data Phoneme
AO :: Phoneme
AA :: Phoneme
IY :: Phoneme
UW :: Phoneme
EH :: Phoneme
IH :: Phoneme
UH :: Phoneme
AH :: Phoneme
AX :: Phoneme
AE :: Phoneme
EY :: Phoneme
AY :: Phoneme
OW :: Phoneme
AW :: Phoneme
OY :: Phoneme
ER :: Phoneme
AXR :: Phoneme
Y :: Phoneme
W :: Phoneme
Q :: Phoneme
P :: Phoneme
B :: Phoneme
T :: Phoneme
D :: Phoneme
K :: Phoneme
G :: Phoneme
CH :: Phoneme
JH :: Phoneme
F :: Phoneme
V :: Phoneme
TH :: Phoneme
DH :: Phoneme
S :: Phoneme
Z :: Phoneme
SH :: Phoneme
ZH :: Phoneme
HH :: Phoneme
M :: Phoneme
EM :: Phoneme
N :: Phoneme
EN :: Phoneme
NG :: Phoneme
ENG :: Phoneme
L :: Phoneme
EL :: Phoneme
R :: Phoneme
DX :: Phoneme
NX :: Phoneme

-- | <a>Phoneme</a> with <a>Stress</a>, if given.
type Phoneme_str = (Phoneme, Maybe Stress)

-- | There is a variant CMU dictionary with syllable marks.
--   <a>http://webdocs.cs.ualberta.ca/~kondrak/cmudict.html</a>
type SYLLABLE = [Phoneme_str]

-- | An ARPABET word.
type ARPABET = [Phoneme_str]

-- | An ARPABET word, with syllables.
type ARPABET_syl = [SYLLABLE]

-- | Parameterised CMU dictionary.
type CMU_Dict_ty a = Map String a

-- | The CMU dictionary.
type CMU_Dict = CMU_Dict_ty ARPABET

-- | The syllabic CMU dictionary.
type CMU_Dict_syl = CMU_Dict_ty ARPABET_syl

-- | Parse <a>Phoneme_str</a>
--   
--   <pre>
--   parse_phoneme_str "EY1" == (EY,Just Primary_stress)
--   parse_phoneme_str "R" == (R,Nothing)
--   </pre>
parse_phoneme_str :: String -> Phoneme_str
parse_arpabet :: String -> (String, ARPABET)
parse_arpabet_syl :: String -> (String, ARPABET_syl)

-- | Classification of <a>Phoneme</a>s.
data Phoneme_Class
Monophthong :: Phoneme_Class
Diphthong :: Phoneme_Class
R_Coloured :: Phoneme_Class
Semivowel :: Phoneme_Class
Stop :: Phoneme_Class
Affricate :: Phoneme_Class
Fricative :: Phoneme_Class
Aspirate :: Phoneme_Class
Nasal :: Phoneme_Class
Liquid :: Phoneme_Class

-- | Classification table for <a>Phoneme</a>.
arpabet_classification_table :: [(Phoneme_Class, [Phoneme])]

-- | Consult <a>arpabet_classification_table</a>.
--   
--   <pre>
--   arpabet_classification HH == Aspirate
--   map arpabet_classification [minBound .. maxBound]
--   </pre>
arpabet_classification :: Phoneme -> Phoneme_Class
cmudict_load_ty :: (String -> (String, a)) -> FilePath -> IO (CMU_Dict_ty a)

-- | Load CMU dictionary from file.
--   
--   <pre>
--   d &lt;- cmudict_load "/home/rohan/data/cmudict/cmudict.0.7a"
--   M.size d == 133313
--   </pre>
cmudict_load :: FilePath -> IO CMU_Dict

-- | Load syllable CMU dictionary from file.
--   
--   <pre>
--   d &lt;- cmudict_syl_load "/home/rohan/data/cmudict/cmudict.0.6d.syl"
--   M.size d == 129463
--   </pre>
cmudict_syl_load :: FilePath -> IO CMU_Dict_syl

-- | Dictionary lookup.
--   
--   <pre>
--   let r = [(R,Nothing),(EY,Just Primary_stress)
--           ,(N,Nothing),(ER,Just No_stress),(D,Nothing)]
--   in d_lookup d "reynard" == Just r
--   </pre>
d_lookup :: CMU_Dict_ty a -> String -> Maybe a

-- | Variant that retains query string if not in dictionary.
d_lookup' :: CMU_Dict_ty a -> String -> Either String a

-- | Table mapping <i>Arpabet</i> phonemes to <i>IPA</i> strings.
--   
--   <pre>
--   length arpabet_ipa_table == 48
--   </pre>
arpabet_ipa_table :: [(Phoneme, Either String [(Stress, String)])]

-- | Consult <a>arpabet_ipa_table</a>.
--   
--   <pre>
--   map (phoneme_ipa (Just Primary_stress)) [minBound .. maxBound]
--   </pre>
phoneme_ipa :: Maybe Stress -> Phoneme -> String

-- | Consult <a>arpabet_ipa_table</a>.
--   
--   <pre>
--   let r = map parse_phoneme_str (words "R EY1 N ER0 D")
--   in arpabet_ipa r == "ɹeɪnɝd"
--   </pre>
arpabet_ipa :: ARPABET -> String
instance Eq Stress
instance Ord Stress
instance Enum Stress
instance Bounded Stress
instance Read Stress
instance Show Stress
instance Eq Phoneme
instance Ord Phoneme
instance Enum Phoneme
instance Bounded Phoneme
instance Read Phoneme
instance Show Phoneme
instance Eq Phoneme_Class
instance Ord Phoneme_Class
instance Enum Phoneme_Class
instance Bounded Phoneme_Class
instance Read Phoneme_Class
instance Show Phoneme_Class


-- | <tt>SC2</tt> <tt>OverlapTexture</tt> related functions.
--   
--   Generate sequences of overlapping instances of a <a>UGen</a> graph or
--   family of graphs. The <a>OverlapTexture</a> functions add an
--   <a>Envelope</a> and calculate inter-onset times and durations. There
--   are variants for different graph constructors, and to allow for a
--   post-processing stage.
--   
--   Here the implementation of texture adds sumOut nodes at bus 0 to the
--   head of group 1, post-processing adds a replaceOut node at bus 0 to
--   the tail of group 1.
module Sound.SC3.Lang.Control.OverlapTexture

-- | Envelope defined by <i>sustain</i> and <i>transition</i> times.
type Env_ST n = (n, n)

-- | Location in node tree, given as (<i>group</i>,<i>bus</i>).
type Loc_GB = (Int, UGen)

-- | Make an <a>envGen</a> <a>UGen</a> with <a>envLinen'</a> structure with
--   given by <a>Env_ST</a>.
mk_env :: Env_ST UGen -> UGen

-- | Add multiplier stage and <a>out</a> UGen writing to <i>bus</i>.
with_env_u :: UGen -> UGen -> Env_ST UGen -> UGen

-- | Variant of <a>with_env_u</a> where envelope parameters are lifted from
--   <a>Double</a> to <a>UGen</a>.
with_env :: UGen -> Env_ST Double -> UGen -> UGen
gen_nm :: UGen -> String

-- | Generate <a>Synthdef</a>, perhaps with envelope parameters for
--   <a>with_env</a>, and a continuous signal.
gen_synth :: UGen -> Maybe (Env_ST Double) -> UGen -> Synthdef

-- | Require envelope.
gen_synth' :: UGen -> Env_ST Double -> UGen -> Synthdef

-- | Schedule <a>Synthdef</a> at indicated intervals. Synthdef is sent once
--   at time zero.
nrt_sy1 :: Int -> Synthdef -> [Double] -> NRT

-- | Schedule <a>Synthdef</a>s at indicated intervals. Synthdef is sent in
--   activation bundle.
nrt_sy :: Int -> [Synthdef] -> [Time] -> NRT

-- | Control parameters for <a>overlapTextureU</a> and related functions.
--   Components are: 1. sustain time, 2. transition time, 3. number of
--   overlaping (simultaneous) nodes and 4. number of nodes altogether.
type OverlapTexture = (Double, Double, Double, Int)

-- | Record of <a>OverlapTexture</a>.
data OverlapTexture_
OverlapTexture :: Double -> Double -> Double -> Int -> OverlapTexture_
sustain_time :: OverlapTexture_ -> Double
transition_time :: OverlapTexture_ -> Double
overlaps :: OverlapTexture_ -> Double
max_repeats :: OverlapTexture_ -> Int

-- | Extract envelope parameters (sustain and transition times) for
--   <a>with_env</a> from <a>OverlapTexture</a>.
overlapTexture_env :: OverlapTexture -> Env_ST Double

-- | Inter-offset time given <a>OverlapTexture</a>.
--   
--   <pre>
--   overlapTexture_iot (3,1,5,maxBound) == 1
--   </pre>
overlapTexture_iot :: OverlapTexture -> Double

-- | Generate an <a>NRT</a> score from <a>OverlapTexture</a> control
--   parameters and a continuous signal.
overlapTexture_nrt :: Loc_GB -> OverlapTexture -> UGen -> NRT

-- | <a>audition</a> of <a>overlapTexture_nrt</a>.
--   
--   <pre>
--   import Sound.SC3.ID
--   import Sound.SC3.Lang.Control.OverlapTexture
--   
--   let {o = sinOsc AR (rand 'α' 440 880) 0
--       ;u = pan2 o (rand 'β' (-1) 1) (rand 'γ' 0.1 0.2)}
--   in overlapTextureU (3,1,6,9) u
--   </pre>
overlapTextureU :: OverlapTexture -> UGen -> IO ()

-- | Control parameters for <a>xfadeTextureU</a> and related functions.
--   Components are: 1. sustain time, 2. transition time, 3. number of
--   nodes instantiated altogether.
type XFadeTexture = (Double, Double, Int)

-- | Extract envelope parameters for <a>with_env</a> from
--   <a>XFadeTexture</a>.
xfadeTexture_env :: XFadeTexture -> Env_ST Double

-- | Inter-offset time from <a>XFadeTexture</a>.
xfadeTexture_iot :: XFadeTexture -> Double

-- | Generate an <a>NRT</a> score from <a>XFadeTexture</a> control
--   parameters and a continuous signal.
xfadeTexture_nrt :: Loc_GB -> XFadeTexture -> UGen -> NRT

-- | <a>audition</a> of <a>xfadeTexture_nrt</a>.
--   
--   <pre>
--   let {o = sinOsc AR (rand 'α' 440 880) 0
--       ;u = pan2 o (rand 'β' (-1) 1) (rand 'γ' 0.1 0.2)}
--   in xfadeTextureU (1,3,6) u
--   </pre>
xfadeTextureU :: XFadeTexture -> UGen -> IO ()

-- | Duration a function of the iteration number.
type Spawn_Texture = (Int -> Double, Int)

-- | Generate an <a>NRT</a> score from <a>OverlapTexture</a> control
--   parameters and a continuous signal.
spawnTexture_nrt :: Loc_GB -> Spawn_Texture -> UGen -> NRT

-- | <a>audition</a> <a>spawnTexture_nrt</a>.
spawnTextureU :: Spawn_Texture -> UGen -> IO ()
type PP_Bus = Either UGen (UGen, UGen)

-- | Generate <a>Synthdef</a> from a signal processing function over the
--   indicated number of channels. If there is a single bus, writes using
--   <a>replaceOut</a>, else using <a>out</a>.
post_process_s :: Int -> PP_Bus -> (UGen -> UGen) -> Synthdef

-- | Run post-processing function.
post_process :: Transport m => Int -> PP_Bus -> Int -> (UGen -> UGen) -> m ()

-- | Audition <a>NRT</a> with specified post-processing function.
post_process_nrt :: Transport m => Loc_GB -> NRT -> Int -> (UGen -> UGen) -> m ()

-- | Post processing function.
type PPF = UGen -> UGen

-- | Variant of <a>overlapTextureU</a> with post-processing stage.
overlapTextureU_pp :: OverlapTexture -> UGen -> Int -> PPF -> IO ()

-- | Variant of <a>xfadeTextureU</a> with post-processing stage.
xfadeTextureU_pp :: XFadeTexture -> UGen -> Int -> PPF -> IO ()

-- | UGen generating state transform function.
type USTF st = st -> (UGen, st)

-- | Variant of <a>overlapTexture_nrt</a> where the continuous signal for
--   each <i>event</i> is derived from a state transform function seeded
--   with given initial state.
overlapTexture_nrt_st :: Loc_GB -> OverlapTexture -> USTF st -> st -> NRT

-- | <a>audition</a> of <a>overlapTexture_nrt_st</a>.
overlapTextureS :: OverlapTexture -> USTF st -> st -> IO ()

-- | Variant of <a>overlapTextureS</a> with post-processing stage.
overlapTextureS_pp :: OverlapTexture -> USTF st -> st -> Int -> PPF -> IO ()

-- | Monadic state transform function.
type MSTF st m = st -> m (Maybe st)

-- | Run a monadic state transforming function <i>f</i> that operates with
--   a delta <a>Time</a> indicating the duration to pause before re-running
--   the function.
dt_rescheduler_m :: MonadIO m => MSTF (st, Time) m -> (st, Time) -> m ()

-- | Underlying function of <a>overlapTextureM</a> with explicit
--   <a>Transport</a>.
overlapTextureR :: Transport m => OverlapTexture -> IO UGen -> MSTF (Int, Time) m

-- | Variant of <a>overlapTextureU</a> where the continuous signal is in
--   the <a>IO</a> monad.
overlapTextureM :: OverlapTexture -> IO UGen -> IO ()


-- | Trivial midi functions.
module Sound.SC3.Lang.Control.Midi

-- | Join two 7-bit values into a 14-bit value.
--   
--   <pre>
--   map (uncurry b_join) [(0,0),(0,64),(127,127)] == [0,8192,16383]
--   </pre>
b_join :: Bits a => a -> a -> a

-- | Inverse of <a>b_join</a>.
--   
--   <pre>
--   map b_sep [0,8192,16383] == [(0,0),(0,64),(127,127)]
--   </pre>
b_sep :: (Num t, Bits t) => t -> (t, t)

-- | <a>http://www.midi.org/techspecs/midimessages.php</a>
data Midi_Message a
Chanel_Aftertouch :: a -> a -> Midi_Message a
Control_Change :: a -> a -> a -> Midi_Message a
Note_On :: a -> a -> a -> Midi_Message a
Note_Off :: a -> a -> a -> Midi_Message a
Polyphic_Key_Pressure :: a -> a -> a -> Midi_Message a
Program_Change :: a -> a -> Midi_Message a
Pitch_Bend :: a -> a -> Midi_Message a
Unknown :: [a] -> Midi_Message a

-- | <a>Control_Change</a> midi messages have, in some cases, commonly
--   defined meanings.
data Control_Message a
All_Notes_Off :: a -> Control_Message a
All_Sound_Off :: a -> Control_Message a
Balance :: a -> a -> Control_Message a
Bank_Select :: a -> a -> Control_Message a
Breath_Controller :: a -> a -> Control_Message a
Expression_Controller :: a -> a -> Control_Message a
Foot_Controller :: a -> a -> Control_Message a
Local_Control :: a -> a -> Control_Message a
Modulation_Wheel :: a -> a -> Control_Message a
Mono_Mode_On :: a -> a -> Control_Message a
Omni_Mode_Off :: a -> Control_Message a
Omni_Mode_On :: a -> Control_Message a
Pan :: a -> a -> Control_Message a
Poly_Mode_On :: a -> Control_Message a
Portamento_On_Off :: a -> a -> Control_Message a
Portamento_Time :: a -> a -> Control_Message a
Reset_All_Controllers :: a -> a -> Control_Message a
Soft_Pedal_On_Off :: a -> a -> Control_Message a
Sostenuto_On_Off :: a -> a -> Control_Message a
Sustain_On_Off :: a -> a -> Control_Message a
Undefined :: Control_Message a

-- | <a>Control_Change</a> midi messages may, in some cases, have commonly
--   defined meanings.
--   
--   <pre>
--   control_message (0,123,0) == All_Notes_Off 0
--   </pre>
control_message :: (Eq a, Num a) => (a, a, a) -> Control_Message a

-- | Parse <tt>midi-osc</tt> <tt><i>midi</i></tt> message.
parse_b :: Integral n => Message -> [n]

-- | Variant of <a>parse_b</a> that give status byte as low and high.
parse_c :: Integral n => Message -> [n]

-- | Variant of <a>parse_c</a> that constructs a <a>Midi_Message</a>.
parse_m :: (Bits n, Integral n) => Message -> Midi_Message n

-- | <tt>SC3</tt> node identifiers are integers.
type Node_Id = Int

-- | Map of allocated <a>Node_Id</a>s. For a single input controller, key
--   events always arrive in sequence (ie. on-&gt;off), ie. for any key on
--   message we can allocate an ID and associate it with the key, an off
--   message can retrieve the ID given the key.
data KY a
KY :: (Map a Node_Id) -> Node_Id -> KY a

-- | Initialise <a>KY</a> with starting <a>Node_Id</a>.
ky_init :: Node_Id -> KY a

-- | <a>KY</a> <a>Node_Id</a> allocator.
ky_alloc :: Ord a => KY a -> a -> (KY a, Node_Id)

-- | <a>KY</a> <a>Node_Id</a> removal.
ky_free :: Ord a => KY a -> a -> (KY a, Node_Id)

-- | Lookup <a>Node_Id</a>.
ky_get :: Ord a => KY a -> a -> Node_Id

-- | All <a>Node_Id</a>.
ky_all :: KY a -> [Node_Id]
type Midi_Init_f st = UDP -> IO st

-- | <a>Midi_Recv_f</a> is passed the <tt>SC3</tt> connection, the user
--   state, a <a>Midi_Message</a> and, for <a>Note_On</a> and
--   <a>Note_Off</a> messages, a <a>Node_Id</a>.
type Midi_Recv_f st = UDP -> st -> Midi_Message Int -> IO st

-- | Parse incoming midi messages and run <tt>Midi_Receiver</tt>.
midi_act :: Midi_Recv_f st -> UDP -> st -> Message -> IO st

-- | Connect to <tt>midi-osc</tt> and <tt>sc3</tt>, run initialiser, and
--   then receiver for each incoming message.
run_midi :: Midi_Init_f st -> Midi_Recv_f st -> IO ()
iterateM_ :: Monad m => st -> (st -> m st) -> m ()
instance Eq a => Eq (Midi_Message a)
instance Show a => Show (Midi_Message a)
instance Eq a => Eq (Control_Message a)
instance Show a => Show (Control_Message a)


-- | Maintain midi state, query functions.
module Sound.SC3.Lang.Control.Midi.ST
type Midi_7bit = Int
type Midi_Note = Midi_7bit
type Midi_Velocity = Midi_7bit
type Midi_Program = Midi_7bit
type Midi_CC_Ix = Midi_7bit
type Midi_CC_Value = Midi_7bit
type Midi_Key_Map = Map Midi_Note Midi_Velocity
type Midi_CC_Map = Map Midi_CC_Ix Midi_CC_Value
type Midi_State = MVar (Midi_Key_Map, Midi_Program, Midi_CC_Map)
st_edit_km :: Midi_State -> (Midi_Note, Midi_Velocity) -> IO Midi_State
st_edit_cc :: Midi_State -> (Midi_CC_Ix, Midi_CC_Value) -> IO Midi_State
st_edit_pc :: Midi_State -> Midi_Program -> IO Midi_State
p3_fst :: (t, u, v) -> t
p3_third :: (t, u, v) -> v
st_access_km :: (Midi_Key_Map -> r) -> Midi_State -> IO r
st_access_cc :: (Midi_CC_Map -> r) -> Midi_State -> IO r
st_read_note :: Midi_State -> Midi_Note -> IO (Maybe Midi_Velocity)
st_read_cc :: Midi_State -> Midi_CC_Ix -> IO Midi_CC_Value
st_chord :: Midi_State -> IO [Midi_Note]
st_init_f :: Midi_State -> Midi_Init_f Midi_State
st_recv_f :: Midi_Recv_f Midi_State
st_run :: IO (Midi_State, ThreadId)


-- | <tt>sclang</tt> math functions.
module Sound.SC3.Lang.Math

-- | <tt>SimpleNumber.ampdb</tt> converts linear amplitude to decibels.
--   
--   <pre>
--   &gt; [1,0.5,0.25,0.13,6e-2].collect({|i| i.ampdb.round}) == [0,-6,-12,-18,-24]
--   map (round . ampdb) [1,0.5,0.25,0.13,6e-2] == [0,-6,-12,-18,-24]
--   </pre>
--   
--   <pre>
--   &gt; [1,0.7,0.5,0.35,0.25].collect({|i| i.ampdb.round}) == [0,-3,-6,-9,-12]
--   map (round . ampdb) [1,0.7,0.5,0.35,0.25] == [0,-3,-6,-9,-12]
--   </pre>
ampdb :: Floating a => a -> a

-- | <tt>SimpleNumber.dbamp</tt> converts decibels to a linear amplitude.
--   
--   <pre>
--   &gt; [0,-3,-6,-9,-12].collect({|i| (i.dbamp * 100).floor}) == [100,70,50,35,25]
--   map (floor . (* 100) . dbamp) [0,-3,-6,-9,-12] == [100,70,50,35,25]
--   </pre>
dbamp :: Floating a => a -> a

-- | <tt>SimpleNumber.degreeToKey</tt> translates degree, scale and steps
--   per octave to key.
--   
--   <pre>
--   &gt; (0..5).collect({|i| i.degreeToKey([0,1,5,9,11],12)}) == [0,1,5,9,11,12]
--   map (degreeToKey [0,1,5,9,11] 12) [0..5] == [0,1,5,9,11,12]
--   </pre>
--   
--   <pre>
--   map (degreeToKey [0,2,4,5,7,9,11] 12) [5,6,7,8] == [9,11,12,14]
--   </pre>
degreeToKey :: RealFrac a => [a] -> a -> a -> a

-- | Psuedo-inifite bounded value.
--   
--   <pre>
--   inf == maxBound
--   </pre>
inf :: Bounded a => a

-- | Predicate for <a>inf</a>.
--   
--   <pre>
--   isInf inf == True
--   </pre>
isInf :: (Eq a, Bounded a) => a -> Bool

-- | <tt>SimpleNumber.linexp</tt> shifts from linear to exponential ranges.
--   
--   <pre>
--   &gt; [1,1.5,2].collect({|i| i.linexp(1,2,10,100).floor}) == [10,31,100]
--   map (floor . linexp 1 2 10 100) [1,1.5,2] == [10,31,100]
--   </pre>
linexp :: (Ord a, Floating a) => a -> a -> a -> a -> a -> a

-- | <tt>SimpleNumber.log10</tt> is the base 10 logarithm.
log10 :: Floating a => a -> a
octpc_to_midi :: Num a => (a, a) -> a

-- | <tt>SimpleNumber.midicps</tt> translates from midi note number to
--   cycles per second.
--   
--   <pre>
--   &gt; [57,69].collect({|i| i.midicps}) == [220,440]
--   map midicps [57,69] == [220,440]
--   </pre>
midicps :: Floating a => a -> a

-- | <a>midicps</a> of <a>octpc_to_midi</a>.
octpc_to_cps :: Floating a => (a, a) -> a

-- | <a>octpc_to_cps</a> of <a>degreeToKey</a>.
degree_to_cps :: (Floating a, RealFrac a) => [a] -> a -> a -> a -> a

-- | Variant with list inputs for degree and octave, and scalar inputs for
--   scale and steps.
degree_to_cps' :: (Floating a, RealFrac a) => [a] -> a -> [a] -> [a] -> [a]

-- | <tt>UGen.exprand</tt> shifts a linear (0,1) value to an exponential
--   range.
--   
--   <pre>
--   map (floor . exprange 10 100) [0,0.5,1] == [10,31,100]
--   </pre>
exprange :: Floating b => b -> b -> b -> b

-- | <tt>0</tt> is false, <tt>1</tt> is True, else error.
--   
--   <pre>
--   map bitChar "01" == [False,True]
--   </pre>
bitChar :: Char -> Bool

-- | Parse a sequence of 0 and 1 characters as a BE bit sequence
--   
--   <pre>
--   parseBits "101" == 5
--   parseBits "00001111" == 15
--   </pre>
parseBits :: (Num a, Bits a) => String -> a


-- | A <i>warp</i> is a mapping from the space <tt>[0,1]</tt> to a user
--   defined space <i>[l,r]</i>.
module Sound.SC3.Lang.Math.Warp

-- | Warp direction. <a>W_Map</a> is forward, <a>W_Unmap</a> is reverse.
data W_Direction
W_Map :: W_Direction
W_Unmap :: W_Direction

-- | Warp type
type Warp t = W_Direction -> t -> t

-- | Forward warp.
w_map :: Warp t -> t -> t

-- | Reverse warp.
w_unmap :: Warp t -> t -> t

-- | A linear real value map.
--   
--   <pre>
--   &gt; w = LinearWarp(ControlSpec(1,2))
--   &gt; [0,0.5,1].collect{|n| w.map(n)} == [1,1.5,2]
--   </pre>
--   
--   <pre>
--   map (w_map (warpLinear 1 2)) [0,1/2,1] == [1,3/2,2]
--   map (warpLinear (-1) 1 W_Map) [0,1/2,1] == [-1,0,1]
--   </pre>
warpLinear :: Fractional a => a -> a -> Warp a

-- | The left and right must both be non zero and have the same sign.
--   
--   <pre>
--   &gt; w = ExponentialWarp(ControlSpec(1,2))
--   &gt; [0,0.5,1].collect{|n| w.map(n)} == [1,pow(2,0.5),2]
--   </pre>
--   
--   <pre>
--   map (warpExponential 1 2 W_Map) [0,0.5,1] == [1,2 ** 0.5,2]
--   </pre>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable1 (map (warpExponential 1 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpExponential :: Floating a => a -> a -> Warp a

-- | Cosine warp
--   
--   <pre>
--   &gt; w = CosineWarp(ControlSpec(1,2))
--   &gt; [0,0.25,0.5,0.75,1].collect{|n| w.map(n)}
--   </pre>
--   
--   <pre>
--   map (warpCosine 1 2 W_Map) [0,0.25,0.5,0.75,1]
--   </pre>
--   
--   <pre>
--   plotTable1 (map (warpCosine 1 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpCosine :: Floating a => a -> a -> Warp a

-- | Sine warp
--   
--   <pre>
--   map (warpSine 1 2 W_Map) [0,0.25,0.5,0.75,1]
--   </pre>
--   
--   <pre>
--   plotTable1 (map (warpSine 1 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpSine :: Floating a => a -> a -> Warp a

-- | Fader warp. Left and right values are ordinarily zero and one.
--   
--   <pre>
--   map (warpFader 0 1 W_Map) [0,0.5,1] == [0,0.25,1]
--   </pre>
--   
--   <pre>
--   plotTable1 (map (warpFader 0 1 W_Map) [0,0.01 .. 1])
--   plotTable1 (map (warpFader 0 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpFader :: Floating a => a -> a -> Warp a

-- | DB fader warp. Left and right values are ordinarily negative infinity
--   and zero. An input of <tt>0</tt> gives <tt>-180</tt>.
--   
--   <pre>
--   map (round . warpDbFader W_Map) [0,0.5,1] == [-180,-12,0]
--   </pre>
--   
--   <pre>
--   plotTable1 (map (warpDbFader (-60) 0 W_Map) [0,0.01 .. 1])
--   plotTable1 (map (warpDbFader 0 60 W_Unmap) [0 .. 60])
--   </pre>
warpDbFader :: (TernaryOp a, Eq a, Floating a) => a -> a -> Warp a

-- | A curve warp given by a real <i>n</i>.
--   
--   <pre>
--   w_map (warpCurve (-3) 1 2) 0.25 == 1.5552791692202022
--   w_map (warpCurve (-3) 1 2) 0.50 == 1.8175744761936437
--   </pre>
--   
--   <pre>
--   plotTable1 (map (warpCurve (-3) 1 2 W_Map) [0,0.01 .. 1])
--   plotTable1 (map (warpCurve 9 1 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpCurve :: (Ord a, Floating a) => a -> a -> a -> Warp a

-- | Select warp function by name. Numerical names are interpreted as
--   <i>curve</i> values for <a>warpCurve</a>.
--   
--   <pre>
--   let Just w = warpNamed "lin"
--   let Just w = warpNamed "-3"
--   let Just w = warpNamed "6"
--   plotTable1 (map (w 1 2 W_Map) [0,0.01 .. 1])
--   </pre>
warpNamed :: (TernaryOp a, Ord a, Eq a, RealFrac a, Floating a) => String -> Maybe (a -> a -> Warp a)
instance Eq W_Direction
instance Enum W_Direction
instance Bounded W_Direction
instance Show W_Direction


-- | <tt>SC3</tt> pitch model implementation.
module Sound.SC3.Lang.Control.Pitch

-- | <a>Pitched</a> values, minimal definition is <a>midinote</a>.
--   
--   <pre>
--   midinote (defaultPitch {degree = 5}) == 69
--   freq (defaultPitch {degree = 5,detune = 10}) == 440 + 10
--   </pre>
class Pitched p where freq = midicps . midinote
midinote :: Pitched p => p -> Double
freq :: Pitched p => p -> Double

-- | The supercollider language pitch model is organised as a tree with
--   three separate layers, and is designed to allow separate processes to
--   manipulate aspects of the model independently.
--   
--   The haskell variant implements <a>Pitch</a> as a labeled data type,
--   with a default value such that scale degree 5 is the A above middle C.
--   
--   <pre>
--   freq (defaultPitch {degree = 5}) == 440
--   </pre>
--   
--   The note is given as a degree, with a modal transposition, indexing a
--   scale interpreted relative to an equally tempered octave divided into
--   the indicated number of steps.
--   
--   The midinote is derived from the note by adding the indicated root,
--   octave and gamut transpositions.
--   
--   The frequency is derived by a chromatic transposition of the midinote,
--   with a harmonic multiplier.
--   
--   <pre>
--   let {p = defaultPitch
--       ;n = p {stepsPerOctave = 12
--              ,scale = [0,2,4,5,7,9,11]
--              ,degree = 0
--              ,mtranspose = 5}
--       ;m = n {root = 0
--              ,octave = 5
--              ,gtranspose = 0}
--       ;f = m {ctranspose = 0
--              ,harmonic = 1}}
--   in (note n,midinote m,freq f) == (9,69,440)
--   </pre>
--   
--   By editing the values of aspects of a pitch, processes can cooperate.
--   Below one process controls the note by editing the modal
--   transposition, a second edits the octave.
--   
--   <pre>
--   let {edit_mtranspose p d = p {mtranspose = mtranspose p + d}
--       ;edit_octave p o = p {octave = octave p + o}
--       ;p' = repeat defaultPitch
--       ;q = zipWith edit_mtranspose p' [0,2,4,3,5]
--       ;r = zipWith edit_octave q [0,-1,0,1,0]
--       ;f = map midinote}
--   in (f q,f r) == ([60,64,67,65,69],[60,52,67,77,69])
--   </pre>
data Pitch
Pitch :: Double -> Double -> Double -> Double -> Double -> [Double] -> Double -> Double -> Double -> Double -> Maybe Double -> Maybe Double -> Maybe Double -> Pitch
mtranspose :: Pitch -> Double
gtranspose :: Pitch -> Double
ctranspose :: Pitch -> Double
octave :: Pitch -> Double
root :: Pitch -> Double
scale :: Pitch -> [Double]
degree :: Pitch -> Double
stepsPerOctave :: Pitch -> Double
detune :: Pitch -> Double
harmonic :: Pitch -> Double
freq' :: Pitch -> Maybe Double
midinote' :: Pitch -> Maybe Double
note' :: Pitch -> Maybe Double

-- | A default <a>Pitch</a> value of middle C given as degree <tt>0</tt> of
--   a C major scale.
--   
--   <pre>
--   let {p = defaultPitch
--       ;r = ([0,2,4,5,7,9,11],12,0,5,0)}
--   in (scale p,stepsPerOctave p,root p,octave p,degree p) == r
--   </pre>
defaultPitch :: Pitch

-- | Calculate <i>note</i> field.
--   
--   <pre>
--   note (defaultPitch {degree = 5}) == 9
--   </pre>
note :: Pitch -> Double

-- | Tuple in 6-1-6 arrangement.
type T616 a b c = (a, a, a, a, a, a, b, c, c, c, c, c, c)

-- | <a>Pitch</a> represented as tuple of optional values.
type OptPitch = T616 (Maybe Double) (Maybe [Double]) (Maybe Double)

-- | Transform <a>OptPitch</a> to <a>Pitch</a>.
optPitch :: OptPitch -> Pitch
instance Eq Pitch
instance Show Pitch
instance Pitched Pitch


-- | An instrument abstraction and a <i>default</i> instrument for
--   patterns.
module Sound.SC3.Lang.Control.Instrument

-- | An <a>Instr</a> is either a <a>Synthdef</a> or the <a>String</a>
--   naming a <a>Synthdef</a>.
data Instr
Instr_Def :: Synthdef -> Bool -> Instr
i_def :: Instr -> Synthdef
i_send_release :: Instr -> Bool
Instr_Ref :: String -> Bool -> Instr
i_ref :: Instr -> String
i_send_release :: Instr -> Bool

-- | All <a>Instr</a> have a name.
i_name :: Instr -> String

-- | All <a>Instr</a> may have a <a>Synthdef</a>.
i_synthdef :: Instr -> Maybe Synthdef

-- | If <tt>I_Def</tt> subsequent are <tt>I_Ref</tt>, else all
--   <tt>I_Ref</tt>.
i_repeat :: Instr -> [Instr]

-- | <a>Instr</a> of <a>defaultSynthdef</a>, ie. <a>def</a> of
--   <a>Synthdef</a>.
defaultInstr :: Instr
instance Eq Instr
instance Show Instr


-- | The <tt>SC3</tt> duration model.
module Sound.SC3.Lang.Control.Duration

-- | There are three parts to a duration:
--   
--   <a>delta</a> is the <i>logical</i> or <i>notated</i> duration.
--   
--   <a>occ</a> is the <i>sounding</i> duration, the interval that a value
--   actually occupies in time. If <a>occ</a> <a>&lt;</a> <a>delta</a>
--   there will be a <i>hole</i>, if <a>occ</a> <a>&gt;</a> <a>delta</a>
--   there will be an <i>overlap</i>.
--   
--   <a>fwd</a> is the <i>forward</i> duration, the interval to the start
--   time of the next value in the sequence, which may be <i>parallel</i>
--   to the current value. Ordinarily <a>fwd</a> is either <a>delta</a> or
--   <tt>0</tt>.
class Duration d where occ = delta fwd = delta
delta :: Duration d => d -> Double
occ :: Duration d => d -> Double
fwd :: Duration d => d -> Double

-- | Composite of <a>delta</a>, <a>occ</a>, and <a>fwd</a>.
duration :: Duration d => d -> (Double, Double, Double)

-- | Variant of the <tt>SC3</tt> <a>Duration</a> model.
--   
--   <pre>
--   delta (defaultDur {dur = 2,stretch = 2}) == 4
--   occ defaultDur == 0.8
--   let d = defaultDur {fwd' = Just 0} in (delta d,fwd d) == (1,0)
--   </pre>
data Dur
Dur :: Double -> Double -> Double -> Double -> Maybe Double -> Maybe Double -> Double -> Maybe Double -> Dur

-- | Tempo (in pulses per minute)
tempo :: Dur -> Double

-- | Duration (in pulses)
dur :: Dur -> Double

-- | Stretch multiplier
stretch :: Dur -> Double

-- | Legato multipler
legato :: Dur -> Double

-- | Sustain time
sustain' :: Dur -> Maybe Double

-- | Delta time
delta' :: Dur -> Maybe Double

-- | Lag value
lag :: Dur -> Double

-- | Possible non-sequential delta time field
fwd' :: Dur -> Maybe Double

-- | Default <a>Dur</a> value, equal to one second.
--   
--   <pre>
--   delta defaultDur == 1
--   </pre>
defaultDur :: Dur

-- | Eight tuple.
type T8 n = (n, n, n, n, n, n, n, n)

-- | <a>Dur</a> represented as an eight-tuple of optional values.
type OptDur = T8 (Maybe Double)

-- | Translate <a>OptDur</a> to <a>Dur</a>.
optDur :: OptDur -> Dur
instance Eq Dur
instance Show Dur
instance Duration Dur
instance Integral i => Duration (Ratio i)
instance Duration Double
instance Duration Float
instance Duration Integer
instance Duration Int


-- | Functions to allow using the <a>Sound.OpenSoundControl</a>
--   <a>Datum</a> as a <i>universal</i> data type. In addition to the
--   functions defined below it provides instances for:
--   
--   <a>Datum</a> are <a>IsString</a>
--   
--   <pre>
--   :set -XOverloadedStrings
--   "string" :: Datum
--   </pre>
--   
--   <a>Datum</a> are <a>EqE</a>
--   
--   <pre>
--   Int32 5 /=* Int32 6 == Int32 1
--   Double 5 ==* Double 5 == Double 1
--   </pre>
--   
--   <a>Datum</a> are <a>Num</a>
--   
--   <pre>
--   5 :: Datum
--   5 + 4 :: Datum
--   negate 5 :: Datum
--   </pre>
--   
--   <a>Datum</a> are <a>Fractional</a>
--   
--   <pre>
--   5.0 :: Datum
--   (5 / 4) :: Datum
--   </pre>
--   
--   <a>Datum</a> are <a>Floating</a>
--   
--   <pre>
--   pi :: Datum
--   sqrt (Int32 4) == Double 2
--   (2.0 ** 3.0) :: Datum
--   </pre>
--   
--   <a>Datum</a> are <a>Real</a>
--   
--   <pre>
--   toRational (Double 1.5) == (3/2 :: Rational)
--   (realToFrac (1.5 :: Double) :: Datum) == Double 1.5
--   (realToFrac (Double 1.5) :: Datum) == Double 1.5
--   (realToFrac (Double 1.5) :: Double) == 1.5
--   </pre>
--   
--   <a>Datum</a> are <a>RealFrac</a>
--   
--   <pre>
--   round (Double 1.4) == 1
--   </pre>
--   
--   <a>Datum</a> are <a>RealFracE</a>
--   
--   <pre>
--   roundE (Double 1.4) == Double 1
--   ceilingE (Double 1.4) == Double 2
--   </pre>
--   
--   <a>Datum</a> are <a>RealFloat</a>
--   
--   <pre>
--   isNaN (sqrt (negate (Int32 1))) == True
--   </pre>
--   
--   <a>Datum</a> are <a>Ord</a>
--   
--   <pre>
--   Double 7.5 &gt; Int32 7
--   string "because" &gt; string "again"
--   </pre>
--   
--   <a>Datum</a> are <a>OrdE</a>
--   
--   <pre>
--   Int32 7 &gt;* Int32 7 == Int32 0
--   Double 7.5 &gt;* Int32 7 == Double 1
--   </pre>
--   
--   <a>Datum</a> are <a>Enum</a>
--   
--   <pre>
--   [Int32 0 .. Int32 4] == [Int32 0,Int32 1,Int32 2,Int32 3,Int32 4]
--   [Double 1 .. Double 3] == [Double 1,Double 2,Double 3]
--   </pre>
--   
--   <a>Datum</a> are <a>Random</a>
--   
--   <pre>
--   System.Random.randomRIO (Int32 0,Int32 9):: IO Datum
--   System.Random.randomRIO (Float 0,Float 1):: IO Datum
--   </pre>
module Sound.SC3.Lang.Collection.Universal.Datum

-- | Unary operator.
type UOp n = n -> n

-- | Lift an equivalent set of <a>Int32</a>, <a>Int64</a>, <a>Float</a> and
--   <a>Double</a> unary functions to <a>Datum</a>.
--   
--   <pre>
--   map (liftD abs abs abs abs) [Int32 5,Float (-5)] == [Int32 5,Float 5]
--   </pre>
liftD :: UOp Int32 -> UOp Int64 -> UOp Float -> UOp Double -> UOp Datum

-- | Lift a <a>Double</a> unary operator to <a>Datum</a> via
--   <a>datum_promote</a>.
--   
--   <pre>
--   liftD' negate (Int 5) == Double (-5)
--   </pre>
liftD' :: UOp Double -> UOp Datum

-- | A binary operator.
type BinOp n = n -> n -> n

-- | Given <a>Int32</a>, <a>Int64</a>, <a>Float</a> and <a>Double</a>
--   binary operators generate <a>Datum</a> operator. If <a>Datum</a> are
--   of equal type result type is equal, else result type is <a>Double</a>.
--   
--   <pre>
--   liftD2 (+) (+) (+) (+) (Float 1) (Float 2) == Float 3
--   liftD2 (*) (*) (*) (*) (Int32 3) (Float 4) == Double 12
--   </pre>
liftD2 :: BinOp Int32 -> BinOp Int64 -> BinOp Float -> BinOp Double -> BinOp Datum

-- | A <a>datum_promote</a> variant of <a>liftD2</a>.
--   
--   <pre>
--   liftD2' (+) (Float 1) (Float 2) == Double 3
--   </pre>
liftD2' :: BinOp Double -> BinOp Datum

-- | Direct unary <a>Int32</a>, <a>Int64</a>, <a>Float</a> and
--   <a>Double</a> functions at <a>Datum</a> fields, or <a>error</a>.
--   
--   <pre>
--   atD show show show show (Int 5) == "5"
--   </pre>
atD :: (Int32 -> a) -> (Int64 -> a) -> (Float -> a) -> (Double -> a) -> Datum -> a

-- | Lift a <a>Double</a> <i>at</i> operator to <a>Datum</a> via
--   <a>datum_promote</a>.
--   
--   <pre>
--   atD' floatRadix (Int 5) == 2
--   </pre>
atD' :: (Double -> a) -> Datum -> a

-- | Binary <i>at</i> function.
type BinAt n a = n -> n -> a

-- | Direct binary <a>Int</a>, <a>Float</a> and <a>Double</a> functions at
--   <a>Datum</a> fields, or <a>error</a>.
atD2 :: BinAt Int32 a -> BinAt Int64 a -> BinAt Float a -> BinAt Double a -> BinAt Datum a

-- | Ternary <i>at</i> function.
type TriAt n a = n -> n -> n -> a

-- | Direct ternary <a>Int</a>, <a>Float</a> and <a>Double</a> functions at
--   <a>Datum</a> fields, or <a>error</a>.
atD3 :: TriAt Int32 a -> TriAt Int64 a -> TriAt Float a -> TriAt Double a -> TriAt Datum a
instance Random Datum
instance Enum Datum
instance OrdE Datum
instance Ord Datum
instance RealFloat Datum
instance RealFracE Datum
instance RealFrac Datum
instance Real Datum
instance Floating Datum
instance Fractional Datum
instance Num Datum
instance EqE Datum
instance IsString Datum


-- | List instances of the standard haskell numerical classes with standard
--   haskell truncating behaviour. Provides instances for <a>Num</a>,
--   <a>Fractional</a> and <a>Floating</a>.
--   
--   <pre>
--   [1,2] + [3,4,5] == [4,6]
--   [1,2,3] * [4,5] == [4,10]
--   </pre>
--   
--   Literals are interpreted as infinte lists.
--   
--   <pre>
--   [1,2,3] + 4 == [5,6,7]
--   [1,2,3] * 4 == [4,8,12]
--   </pre>
module Sound.SC3.Lang.Collection.Numerical.Truncating
instance Floating a => Floating [a]
instance Fractional a => Fractional [a]
instance Num a => Num [a]


-- | Core (shared) functions.
module Sound.SC3.Lang.Core

-- | <a>fmap</a> <a>.</a> <a>fmap</a>, ie. <tt>(t -&gt; c) -&gt; (a -&gt; b
--   -&gt; t) -&gt; a -&gt; b -&gt; c</tt>.
(.:) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | <a>fmap</a> <a>.</a> <a>.:</a>, ie. <tt>(t -&gt; d) -&gt; (a -&gt; b
--   -&gt; c -&gt; t) -&gt; a -&gt; b -&gt; c -&gt; d</tt>.
(.::) :: (Functor f, Functor g, Functor h) => (a -> b) -> f (g (h a)) -> f (g (h b))

-- | <a>fmap</a> <a>.</a> <a>.::</a>.
(.:::) :: (Functor f, Functor g, Functor h, Functor i) => (a -> b) -> f (g (h (i a))) -> f (g (h (i b)))

-- | <a>fmap</a> <a>.</a> <a>.:::</a>.
(.::::) :: (Functor f, Functor g, Functor h, Functor i, Functor j) => (a -> b) -> f (g (h (i (j a)))) -> f (g (h (i (j b))))

-- | <a>fmap</a> <a>.</a> <a>.::::</a>.
(.:::::) :: (Functor f, Functor g, Functor h, Functor i, Functor j, Functor k) => (a -> b) -> f (g (h (i (j (k a))))) -> f (g (h (i (j (k b)))))

-- | Variant that either takes precisely <i>n</i> elements or
--   <a>Nothing</a>.
--   
--   <pre>
--   map (genericTake 3) (inits "abc") == inits "abc"
--   Data.Maybe.mapMaybe (genericTakeMaybe 3) (inits "abc") == ["abc"]
--   </pre>
genericTakeMaybe :: Integral i => i -> [a] -> Maybe [a]

-- | Inverse of <a>:</a>.
--   
--   <pre>
--   map uncons [[],1:[]] == [(Nothing,[]),(Just 1,[])]
--   </pre>
uncons :: [a] -> (Maybe a, [a])

-- | <a>Maybe</a> variant of <a>!!</a>.
--   
--   <pre>
--   map (lindex "str") [2,3] == [Just 'r',Nothing]
--   </pre>
lindex :: [a] -> Int -> Maybe a

-- | If <i>n</i> is <a>maxBound</a> this is <a>id</a>, else it is
--   <a>take</a>.
take_inf :: Int -> [a] -> [a]

-- | Variant of <tt>transpose</tt> for <i>fixed width</i> interior lists.
--   Holes are represented by <a>Nothing</a>.
--   
--   <pre>
--   transpose_fw undefined [] == []
--   </pre>
--   
--   <pre>
--   transpose [[1,3],[2,4]] == [[1,2],[3,4]]
--   transpose_fw 2 [[1,3],[2,4]] == [[Just 1,Just 2],[Just 3,Just 4]]
--   </pre>
--   
--   <pre>
--   transpose [[1,5],[2],[3,7]] == [[1,2,3],[5,7]]
--   </pre>
--   
--   <pre>
--   transpose_fw 2 [[1,4],[2],[3,6]] == [[Just 1,Just 2,Just 3]
--                                       ,[Just 4,Nothing,Just 6]]
--   </pre>
--   
--   This function is more productive than <tt>transpose</tt> for the case
--   of an infinite list of finite lists.
--   
--   <pre>
--   map head (transpose_fw 4 (repeat [1..4])) == map Just [1,2,3,4]
--   map head (transpose (repeat [1..4])) == _|_
--   </pre>
transpose_fw :: Int -> [[a]] -> [[Maybe a]]

-- | Variant of <a>transpose_fw</a> with default value for holes.
transpose_fw_def :: a -> Int -> [[a]] -> [[a]]

-- | Variant of <a>transpose_fw_def</a> deriving <i>width</i> from first
--   element.
transpose_fw_def' :: a -> [[a]] -> [[a]]

-- | A <tt>transpose</tt> variant, halting when first hole appears.
--   
--   <pre>
--   transpose_st [[1,2,3],[4,5,6],[7,8]] == [[1,4,7],[2,5,8]]
--   </pre>
transpose_st :: [[a]] -> [[a]]

-- | Variant of <a>catMaybes</a> that returns <a>Nothing</a> unless
--   <i>all</i> elements are <a>Just</a>.
--   
--   <pre>
--   map all_just [[Nothing,Just 1],[Just 0,Just 1]] == [Nothing,Just [0,1]]
--   </pre>
all_just :: [Maybe a] -> Maybe [a]

-- | <a>mconcat</a> of <a>repeat</a>, for lists this is <a>cycle</a>.
--   
--   <pre>
--   [1,2,3,1,2] `isPrefixOf` take 5 (mcycle [1,2,3])
--   </pre>
mcycle :: Monoid a => a -> a


-- | Minimal functions for binding values to parameter names and sending to
--   scsynth.
module Sound.SC3.Lang.Pattern.Bind
type Param = [(String, [Double])]
pr_unused :: Synthdef -> Param -> [String]
sbind_init :: Int -> [Synthdef] -> [Bundle]
sbind_tseq :: Int -> [Int] -> (Synthdef, [Time], Maybe [Time], Param) -> [Bundle]
sbind_deriv :: Int -> [Int] -> (Synthdef, Param) -> [Bundle]
sbind :: [(Synthdef, Param)] -> NRT
sbind1 :: (Synthdef, Param) -> NRT
nbind_init :: Int -> [(Synthdef, Int, Param)] -> [Bundle]
nbind_tseq :: (Synthdef, Int, [Time], Param) -> [Bundle]
nbind_deriv :: (Synthdef, Int, Param) -> [Bundle]
nbind :: [(Synthdef, Int, Param)] -> NRT
nbind1 :: (Synthdef, Int, Param) -> NRT


-- | In cases where a method takes arguments, these precede the collection
--   argument in the haskell variant, so that <tt>c.m(i,j)</tt> becomes
--   <tt>m i j c</tt>.
module Sound.SC3.Lang.Collection

-- | <tt>Collection.*fill</tt> is <a>map</a> over indices to <i>n</i>.
--   
--   <pre>
--   fill 4 (* 2) == [0,2,4,6]
--   </pre>
fill :: (Enum n, Num n) => n -> (n -> a) -> [a]

-- | <tt>Collection.size</tt> is <a>length</a>.
--   
--   <pre>
--   size [1,2,3,4] == 4
--   </pre>
size :: Integral n => [a] -> n

-- | <tt>Collection.isEmpty</tt> is <a>null</a>.
--   
--   <pre>
--   isEmpty [] == True
--   </pre>
isEmpty :: [a] -> Bool

-- | Function equal to <a>const</a> of <i>f</i> of <i>e</i>.
--   
--   <pre>
--   select (ignoringIndex even) [1,2,3,4] == [2,4]
--   </pre>
ignoringIndex :: (a -> b) -> a -> z -> b

-- | <tt>Collection.collect</tt> is <a>map</a> with element indices.
--   
--   <pre>
--   collect (\i _ -&gt; i + 10) [1,2,3,4] == [11,12,13,14]
--   collect (\_ j -&gt; j + 11) [1,2,3,4] == [11,12,13,14]
--   </pre>
collect :: Integral i => (a -> i -> b) -> [a] -> [b]

-- | <tt>Collection.select</tt> is <a>filter</a> with element indices.
--   
--   <pre>
--   select (\i _ -&gt; even i) [1,2,3,4] == [2,4]
--   select (\_ j -&gt; even j) [1,2,3,4] == [1,3]
--   </pre>
select :: Integral i => (a -> i -> Bool) -> [a] -> [a]

-- | <tt>Collection.reject</tt> is negated <a>filter</a> with element
--   indices.
--   
--   <pre>
--   reject (\i _ -&gt; even i) [1,2,3,4] == [1,3]
--   reject (\_ j -&gt; even j) [1,2,3,4] == [2,4]
--   </pre>
reject :: Integral i => (a -> i -> Bool) -> [a] -> [a]

-- | <tt>Collection.detect</tt> is <a>first</a> <a>.</a> <a>select</a>.
--   
--   <pre>
--   detect (\i _ -&gt; even i) [1,2,3,4] == Just 2
--   </pre>
detect :: Integral i => (a -> i -> Bool) -> [a] -> Maybe a

-- | <tt>Collection.detectIndex</tt> is the index locating variant of
--   <a>detect</a>.
--   
--   <pre>
--   detectIndex (\i _ -&gt; even i) [1,2,3,4] == Just 1
--   </pre>
detectIndex :: Integral i => (a -> i -> Bool) -> [a] -> Maybe i

-- | <tt>Collection.inject</tt> is a variant on <a>foldl</a>.
--   
--   <pre>
--   inject 0 (+) [1..5] == 15
--   inject 1 (*) [1..5] == 120
--   </pre>
inject :: a -> (a -> b -> a) -> [b] -> a

-- | <tt>Collection.any</tt> is <a>True</a> if <a>detect</a> is not
--   <a>Nothing</a>.
--   
--   <pre>
--   any' (\i _ -&gt; even i) [1,2,3,4] == True
--   </pre>
any' :: Integral i => (a -> i -> Bool) -> [a] -> Bool

-- | <tt>Collection.every</tt> is <a>True</a> if <i>f</i> applies at all
--   elements.
--   
--   <pre>
--   every (\i _ -&gt; even i) [1,2,3,4] == False
--   </pre>
every :: Integral i => (a -> i -> Bool) -> [a] -> Bool

-- | <tt>Collection.count</tt> is <a>length</a> of <a>select</a>.
--   
--   <pre>
--   count (\i _ -&gt; even i) [1,2,3,4] == 2
--   </pre>
count :: Integral i => (a -> i -> Bool) -> [a] -> i

-- | <tt>Collection.occurencesOf</tt> is an <a>==</a> variant of
--   <a>count</a>.
--   
--   <pre>
--   occurencesOf 2 [1,2,3,4] == 1
--   occurencesOf 't' "test" == 2
--   </pre>
occurencesOf :: (Integral i, Eq a) => a -> [a] -> i

-- | <tt>Collection.sum</tt> is <a>sum</a> of <a>collect</a>.
--   
--   <pre>
--   sum' (ignoringIndex (* 2)) [1,2,3,4] == 20
--   </pre>
sum' :: (Num a, Integral i) => (b -> i -> a) -> [b] -> a

-- | <tt>Collection.maxItem</tt> is <a>maximum</a> of <a>collect</a>.
--   
--   <pre>
--   maxItem (ignoringIndex (* 2)) [1,2,3,4] == 8
--   </pre>
maxItem :: (Ord b, Integral i) => (a -> i -> b) -> [a] -> b

-- | <tt>Collection.minItem</tt> is <a>maximum</a> <a>.</a> <a>collect</a>.
--   
--   <pre>
--   minItem (ignoringIndex (* 2)) [1,2,3,4] == 2
--   </pre>
minItem :: (Integral i, Ord b) => (a -> i -> b) -> [a] -> b

-- | Variant of <a>zipWith</a> that cycles the shorter input.
--   
--   <pre>
--   zipWith_c (+) [1,2] [3,4,5] == [4,6,6]
--   </pre>
zipWith_c :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zipWith_c</a> variant of <a>zip</a>.
--   
--   <pre>
--   zip_c [1,2] [3,4,5] == [(1,3),(2,4),(1,5)]
--   </pre>
zip_c :: [a] -> [b] -> [(a, b)]

-- | Variant of <a>zipWith3</a> that cycles the shorter inputs.
--   
--   <pre>
--   zipWith3_c (,,) [1] [2,3] [4,5,6] == [(1,2,4),(1,3,5),(1,2,6)]
--   </pre>
zipWith3_c :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>zipWith3_c</a> based variant of <a>zip3</a>.
--   
--   <pre>
--   zip3_c [1] [2,3] [4,5,6] == [(1,2,4),(1,3,5),(1,2,6)]
--   </pre>
zip3_c :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith_c</a> based variant of applicative <tt>&lt;*&gt;</tt>.
--   
--   <pre>
--   zap_c [(+1),negate] [1..6] == [2,-2,4,-4,6,-6]
--   </pre>
zap_c :: [a -> b] -> [a] -> [b]

-- | <tt>SequenceableCollection.*series</tt> is an arithmetic series with
--   arguments <i>size</i>, <i>start</i> and <i>step</i>.
--   
--   <pre>
--   &gt; Array.series(5,10,2) == [10,12,14,16,18]
--   series 5 10 2 == [10,12 .. 18]
--   </pre>
--   
--   Note that this is quite different from the SimpleNumber.series method,
--   which is equal to <a>enumFromThenTo</a>.
--   
--   <pre>
--   &gt; 5.series(7,10) == [5,7,9]
--   enumFromThenTo 5 7 10 == [5,7,9]
--   </pre>
series :: (Num a, Integral i) => i -> a -> a -> [a]

-- | <tt>SequenceableCollection.*geom</tt> is a geometric series with
--   arguments <i>size</i>, <i>start</i> and <i>grow</i>.
--   
--   <pre>
--   &gt; Array.geom(5,3,6) == [3,18,108,648,3888]
--   geom 5 3 6 == [3,18,108,648,3888]
--   </pre>
geom :: (Integral i, Num a) => i -> a -> a -> [a]

-- | <tt>SequenceableCollection.*fib</tt> is the Fibonacci series where
--   <i>n</i> is number of elements, <i>i</i> is the initial step and
--   <i>j</i> the initial value.
--   
--   <pre>
--   &gt; Array.fib(5,2,32) == [32,34,66,100,166]
--   fib 5 2 32 == [32,34,66,100,166]
--   </pre>
fib :: (Integral i, Num a) => i -> a -> a -> [a]

-- | <tt>SequenceableCollection.first</tt> is a total variant of
--   <a>head</a>.
--   
--   <pre>
--   &gt; [3,4,5].first == 3
--   first [3,4,5] == Just 3
--   first' [3,4,5] == 3
--   </pre>
--   
--   <pre>
--   &gt; [].first == nil
--   first [] == Nothing
--   </pre>
first :: [t] -> Maybe t

-- | Synonym for <a>head</a>.
first' :: [t] -> t

-- | Total variant of <a>last</a>.
--   
--   <pre>
--   &gt; (1..5).last == 5
--   lastM [1..5] == Just 5
--   L.last [1..5] == 5
--   </pre>
--   
--   <pre>
--   &gt; [].last == nil
--   lastM [] == Nothing
--   </pre>
lastM :: [t] -> Maybe t

-- | <tt>SequenceableCollection.last</tt> is a synonym for <a>lastM</a>.
last :: [t] -> Maybe t

-- | Synonym for <a>last</a>.
last' :: [t] -> t

-- | <tt>SequenceableCollection.indexOf</tt> is a variant of
--   <a>elemIndex</a> with reversed arguments.
--   
--   <pre>
--   &gt; [3,4,100,5].indexOf(100) == 2
--   indexOf [3,4,100,5] 100 == Just 2
--   </pre>
indexOf :: Eq a => [a] -> a -> Maybe Int

-- | <a>fromJust</a> variant of <a>indexOf</a>.
indexOf' :: Eq a => [a] -> a -> Int

-- | <tt>SequenceableCollection.indexOfEqual</tt> is just <a>indexOf</a>.
indexOfEqual :: Eq a => [a] -> a -> Maybe Int

-- | <tt>SequenceableCollection.indexOfGreaterThan</tt> is the index of the
--   first greater element.
--   
--   <pre>
--   indexOfGreaterThan 70 [10,5,77,55,12,123] == Just 2
--   </pre>
indexOfGreaterThan :: Ord a => a -> [a] -> Maybe Int

-- | <tt>SequenceableCollection.indexIn</tt> is the index of nearest
--   element.
--   
--   <pre>
--   indexIn 5.2 [2,3,5,6] == 2
--   </pre>
indexIn :: (Ord a, Num a) => a -> [a] -> Int

-- | <tt>SequenceableCollection.indexInBetween</tt> is the linearly
--   interpolated fractional index. Collection must be sorted. The inverse
--   operation is <a>blendAt</a>.
--   
--   <pre>
--   &gt; [2,3,5,6].indexInBetween(5.2) == 2.2
--   indexInBetween 5.2 [2,3,5,6] == 2.2
--   </pre>
indexInBetween :: (Ord a, Fractional a) => a -> [a] -> a

-- | <tt>SequenceableCollection.keep</tt> is, for positive <i>n</i> a
--   synonym for <a>take</a>, and for negative <i>n</i> a variant on
--   <a>drop</a> based on the <a>length</a> of <i>l</i>.
--   
--   <pre>
--   &gt; [1,2,3,4,5].keep(3) == [1,2,3]
--   keep 3 [1,2,3,4,5] == [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt; [1,2,3,4,5].keep(-3) == [3,4,5]
--   keep (-3) [1,2,3,4,5] == [3,4,5]
--   </pre>
--   
--   <pre>
--   &gt; [1,2].keep(-4) == [1,2]
--   keep (-4) [1,2] == [1,2]
--   </pre>
keep :: Integral i => i -> [a] -> [a]

-- | <tt>SequenceableCollection.drop</tt> is, for positive <i>n</i> a
--   synonym for <a>drop</a>, for negative <i>n</i> a variant on
--   <a>take</a> based on the <a>length</a> of <i>l</i>.
--   
--   <pre>
--   &gt; [1,2,3,4,5].drop(3) == [4,5]
--   L.drop 3 [1,2,3,4,5] == [4,5]
--   </pre>
--   
--   <pre>
--   &gt; [1,2,3,4,5].drop(-3) == [1,2]
--   Sound.SC3.Lang.Collection.drop (-3) [1,2,3,4,5] == [1,2]
--   </pre>
--   
--   <pre>
--   &gt; [1,2].drop(-4) == []
--   Sound.SC3.Lang.Collection.drop (-4) [1,2] == []
--   </pre>
drop :: Integral i => i -> [a] -> [a]

-- | Function to calculate a list equal in length to the longest input
--   list, therefore being productive over infinite lists.
--   
--   <pre>
--   extension [[1],[2,3],[4,5,6]] == [(),(),()]
--   take 3 (extension [[1],[2..]]) == [(),(),()]
--   </pre>
extension :: [[a]] -> [()]

-- | <tt>SequenceableCollection.flop</tt> is a variant of <a>transpose</a>
--   that cycles input sequences and extends rather than truncates.
--   
--   <pre>
--   &gt; [(1..3),(4..5),(6..9)].flop == [[1,4,6],[2,5,7],[3,4,8],[1,5,9]]
--   flop [[1..3],[4..5],[6..9]] == [[1,4,6],[2,5,7],[3,4,8],[1,5,9]]
--   </pre>
--   
--   <pre>
--   &gt; [[1,2,3],[4,5,6],[7,8]].flop == [[1,4,7],[2,5,8],[3,6,7]]
--   flop [[1,2,3],[4,5,6],[7,8]] == [[1,4,7],[2,5,8],[3,6,7]]
--   </pre>
--   
--   The null case at <a>flop</a> is not handled equivalently to SC3
--   
--   <pre>
--   &gt; [].flop == [[]]
--   flop [] /= [[]]
--   flop [] == []
--   </pre>
--   
--   The <a>flop</a> and <a>extendSequences</a> functions are non-strict
--   and productive.
--   
--   <pre>
--   take 4 (flop [[1..3],[4..]]) == [[1,4],[2,5],[3,6],[1,7]]
--   map (take 4) (extendSequences [[1..3],[4..]]) == [[1,2,3,1],[4,5,6,7]]
--   </pre>
flop :: [[a]] -> [[a]]

-- | <tt>SequenceableCollection.integrate</tt> is the incremental sum of
--   elements.
--   
--   <pre>
--   &gt; [3,4,1,1].integrate == [3,7,8,9]
--   integrate [3,4,1,1] == [3,7,8,9]
--   </pre>
integrate :: Num a => [a] -> [a]

-- | <tt>SequenceableCollection.differentiate</tt> is the pairwise
--   difference between elements, with an implicit <tt>0</tt> at the start.
--   
--   <pre>
--   &gt; [3,4,1,1].differentiate == [3,1,-3,0]
--   differentiate [3,4,1,1] == [3,1,-3,0]
--   </pre>
--   
--   <pre>
--   &gt; [0,3,1].differentiate == [0,3,-2]
--   differentiate [0,3,1] == [0,3,-2]
--   </pre>
differentiate :: Num a => [a] -> [a]

-- | Variant of <a>separate</a> that performs initial separation.
separateAt :: (a -> a -> Bool) -> [a] -> ([a], [a])

-- | <tt>SequenceableCollection.separate</tt> applies the predicate
--   <tt>f</tt> to each adjacent pair of elements at <i>l</i>. If the
--   predicate is <a>True</a>, then a separation is made between the
--   elements.
--   
--   <pre>
--   &gt; [3,2,1,2,3,2].separate({|a,b| a&lt;b}) == [[3,2,1],[2],[3,2]]
--   separate (&lt;) [3,2,1,2,3,2] == [[3,2,1],[2],[3,2]]
--   </pre>
--   
--   <pre>
--   &gt; [1,2,3,5,6,8].separate({|a,b| (b - a) &gt; 1}) == [[1,2,3],[5,6],[8]]
--   separate (\a b -&gt; (b - a) &gt; 1) [1,2,3,5,6,8] == [[1,2,3],[5,6],[8]]
--   </pre>
separate :: (a -> a -> Bool) -> [a] -> [[a]]

-- | <tt>SequenceableCollection.clump</tt> is a synonym for
--   <a>chunksOf</a>.
--   
--   <pre>
--   &gt; [1,2,3,4,5,6,7,8].clump(3) == [[1,2,3],[4,5,6],[7,8]]
--   clump 3 [1,2,3,4,5,6,7,8] == [[1,2,3],[4,5,6],[7,8]]
--   </pre>
clump :: Int -> [a] -> [[a]]

-- | <tt>SequenceableCollection.clumps</tt> is a synonym for
--   <a>splitPlaces</a>.
--   
--   <pre>
--   &gt; [1,2,3,4,5,6,7,8].clumps([1,2]) == [[1],[2,3],[4],[5,6],[7],[8]]
--   clumps [1,2] [1,2,3,4,5,6,7,8] == [[1],[2,3],[4],[5,6],[7],[8]]
--   </pre>
clumps :: [Int] -> [a] -> [[a]]

-- | <a>blendAt</a> with <tt>clip</tt> function as argument.
blendAtBy :: (Integral i, RealFrac n) => (i -> t -> n) -> n -> t -> n

-- | <tt>SequenceableCollection.blendAt</tt> returns a linearly
--   interpolated value between the two closest indices. Inverse operation
--   is <a>indexInBetween</a>.
--   
--   <pre>
--   &gt; [2,5,6].blendAt(0.4) == 3.2
--   </pre>
--   
--   <pre>
--   blendAt 0 [2,5,6] == 2
--   blendAt 0.4 [2,5,6] == 3.2
--   </pre>
blendAt :: RealFrac a => a -> [a] -> a

-- | Resampling function, <i>n</i> is destination length, <i>r</i> is
--   source length, <i>f</i> is the indexing function, <i>c</i> is the
--   collection.
resamp1_gen :: (Integral i, RealFrac n) => i -> i -> (i -> t -> n) -> t -> i -> n

-- | <tt>SequenceableCollection.resamp1</tt> returns a new collection of
--   the desired length, with values resampled evenly-spaced from the
--   receiver with linear interpolation.
--   
--   <pre>
--   &gt; [1,2,3,4].resamp1(12)
--   &gt; [1,2,3,4].resamp1(3) == [1,2.5,4]
--   </pre>
--   
--   <pre>
--   resamp1 12 [1,2,3,4]
--   resamp1 3 [1,2,3,4] == [1,2.5,4]
--   </pre>
resamp1 :: (Enum n, RealFrac n) => Int -> [n] -> [n]

-- | <tt>List.lace</tt> is a concatenated transposition of cycled
--   subsequences.
--   
--   <pre>
--   &gt; [[1,2,3],[6],[8,9]].lace(12) == [1,6,8,2,6,9,3,6,8,1,6,9]
--   lace 12 [[1,2,3],[6],[8,9]] == [1,6,8,2,6,9,3,6,8,1,6,9]
--   </pre>
lace :: Integral i => i -> [[a]] -> [a]

-- | <tt>List.wrapExtend</tt> extends a sequence by <i>cycling</i>.
--   <a>wrapExtend</a> is in terms of <a>take</a> and <a>cycle</a>.
--   
--   <pre>
--   &gt; [1,2,3,4,5].wrapExtend(9) == [1,2,3,4,5,1,2,3,4]
--   wrapExtend 9 [1,2,3,4,5] == [1,2,3,4,5,1,2,3,4]
--   </pre>
wrapExtend :: Integral i => i -> [a] -> [a]

-- | Infinite variant of <a>foldExtend</a>.
cycleFold :: [a] -> [a]

-- | <tt>List.foldExtend</tt> extends sequence by <i>folding</i> backwards
--   at end. <a>foldExtend</a> is in terms of <a>cycleFold</a>, which is in
--   terms of <a>mirror1</a>.
--   
--   <pre>
--   &gt; [1,2,3,4,5].foldExtend(10)
--   foldExtend 10 [1,2,3,4,5] == [1,2,3,4,5,4,3,2,1,2]
--   </pre>
foldExtend :: Integral i => i -> [a] -> [a]

-- | <tt>Array.clipExtend</tt> extends sequence by repeating last element.
--   
--   <pre>
--   &gt; [1,2,3,4,5].clipExtend(9) == [1,2,3,4,5,5,5,5,5]
--   clipExtend 9 [1,2,3,4,5] == [1,2,3,4,5,5,5,5,5]
--   </pre>
clipExtend :: Integral i => i -> [a] -> [a]

-- | Infinite variant of <a>clipExtend</a>.
cycleClip :: [a] -> [a]

-- | Cycle input sequences to <a>extension</a> of input.
--   
--   <pre>
--   extendSequences [[1],[2,3],[4,5,6]] == [[1,1,1],[2,3,2],[4,5,6]]
--   </pre>
extendSequences :: [[a]] -> [[a]]

-- | <tt>ArrayedCollection.normalizeSum</tt> ensures sum of elements is
--   one.
--   
--   <pre>
--   &gt; [1,2,3].normalizeSum == [1/6,1/3,0.5]
--   normalizeSum [1,2,3] == [1/6,2/6,3/6]
--   </pre>
normalizeSum :: Fractional a => [a] -> [a]

-- | <tt>ArrayedCollection.normalize</tt> returns a new Array with the
--   receiver items normalized between min and max.
--   
--   <pre>
--   &gt; [1,2,3].normalize == [0,0.5,1]
--   &gt; [1,2,3].normalize(-20,10) == [-20,-5,10]
--   </pre>
--   
--   <pre>
--   normalize 0 1 [1,2,3] == [0,0.5,1]
--   normalize (-20) 10 [1,2,3] == [-20,-5,10]
--   </pre>
normalize :: (TernaryOp b, Fractional b, Ord b) => b -> b -> [b] -> [b]

-- | <tt>ArrayedCollection.asRandomTable</tt> returns an integral table
--   that can be used to generate random numbers with a specified
--   distribution.
--   
--   <pre>
--   &gt; [1,0,1,0,1,0,1].asRandomTable(256).plot
--   &gt; ((0..100) ++ (100..50) / 100).asRandomTable.plot
--   </pre>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable [asRandomTable 256 [1,0,1,0,1,0,1]]
--   plotTable [asRandomTable 256 (map (/ 100) ([0..100] ++ [100,99..50]))]
--   </pre>
asRandomTable :: (TernaryOp a, Enum a, RealFrac a) => Int -> [a] -> [a]

-- | <tt>List.slide</tt> is an identity window function with subsequences
--   of length <i>w</i> and stride of <i>n</i>.
--   
--   <pre>
--   &gt; [1,2,3,4,5,6].slide(3,1)
--   slide 3 1 [1,2,3,4,5,6] == [1,2,3,2,3,4,3,4,5,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt; [1,2,3,4,5,6].slide(3,2)
--   slide 3 2 [1,2,3,4,5,6] == [1,2,3,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt; [1,2,3,4,5,6].slide(4,2)
--   slide 4 2 [1,2,3,4,5,6] == [1,2,3,4,3,4,5,6]
--   </pre>
slide :: Integral i => i -> i -> [a] -> [a]

-- | <tt>List.mirror</tt> concatentates with <a>tail</a> of <a>reverse</a>
--   to make a palindrome.
--   
--   <pre>
--   &gt; [1,2,3,4].mirror == [1,2,3,4,3,2,1]
--   mirror [1,2,3,4] == [1,2,3,4,3,2,1]
--   </pre>
mirror :: [a] -> [a]

-- | <tt>List.mirror1</tt> is as <a>mirror</a> but with last element
--   removed.
--   
--   <pre>
--   &gt; [1,2,3,4].mirror1 == [1,2,3,4,3,2]
--   mirror1 [1,2,3,4] == [1,2,3,4,3,2]
--   </pre>
mirror1 :: [a] -> [a]

-- | <tt>List.mirror2</tt> concatenate with <a>reverse</a> to make a
--   palindrome, as <a>mirror</a> does, but with the center element
--   duplicated.
--   
--   <pre>
--   &gt; [1,2,3,4].mirror2 == [1,2,3,4,4,3,2,1]
--   mirror2 [1,2,3,4] == [1,2,3,4,4,3,2,1]
--   </pre>
mirror2 :: [a] -> [a]

-- | <tt>List.stutter</tt> repeats each element <i>n</i> times.
--   
--   <pre>
--   &gt; [1,2,3].stutter(2) == [1,1,2,2,3,3]
--   stutter 2 [1,2,3] == [1,1,2,2,3,3]
--   </pre>
stutter :: Integral i => i -> [a] -> [a]

-- | Rotate <i>n</i> places to the left.
--   
--   <pre>
--   rotateLeft 1 [1..5] == [2,3,4,5,1]
--   rotateLeft 3 [1..7] == [4,5,6,7,1,2,3]
--   </pre>
rotateLeft :: Integral i => i -> [a] -> [a]

-- | Rotate <i>n</i> places to the right.
--   
--   <pre>
--   rotateRight 1 [1..5] == [5,1,2,3,4]
--   rotateRight 3 [1..7] == [5,6,7,1,2,3,4]
--   </pre>
rotateRight :: Integral i => i -> [a] -> [a]

-- | <tt>Array.rotate</tt> is in terms of <a>rotateLeft</a> and
--   <a>rotateRight</a>, where negative <i>n</i> rotates left and positive
--   <i>n</i> rotates right.
--   
--   <pre>
--   &gt; (1..5).rotate(1) == [5,1,2,3,4]
--   rotate 1 [1..5] == [5,1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt; (1..5).rotate(-1) == [2,3,4,5,1]
--   rotate (-1) [1..5] == [2,3,4,5,1]
--   </pre>
--   
--   <pre>
--   &gt; (1..5).rotate(3) == [3,4,5,1,2]
--   rotate 3 [1..5] == [3,4,5,1,2]
--   </pre>
rotate :: Integral i => i -> [a] -> [a]

-- | <tt>ArrayedCollection.windex</tt> takes a list of probabilities, which
--   should sum to <i>n</i>, and returns the an index value given a
--   (0,<i>n</i>) input.
--   
--   <pre>
--   mapMaybe (windex [0.1,0.3,0.6]) [0,0.1 .. 0.4] == [0,1,1,1,2]
--   </pre>
windex :: (Ord a, Num a) => [a] -> a -> Maybe Int

-- | List of 2-tuples of elements at distance (stride) <i>n</i>.
--   
--   <pre>
--   t2_window 3 [1..9] == [(1,2),(4,5),(7,8)]
--   </pre>
t2_window :: Integral i => i -> [t] -> [(t, t)]

-- | List of 2-tuples of adjacent elements.
--   
--   <pre>
--   t2_adjacent [1..6] == [(1,2),(3,4),(5,6)]
--   t2_adjacent [1..5] == [(1,2),(3,4)]
--   </pre>
t2_adjacent :: [t] -> [(t, t)]

-- | List of 2-tuples of overlapping elements.
--   
--   <pre>
--   t2_overlap [1..4] == [(1,2),(2,3),(3,4)]
--   </pre>
t2_overlap :: [b] -> [(b, b)]

-- | Concat of 2-tuples.
--   
--   <pre>
--   t2_concat (t2_adjacent [1..6]) == [1..6]
--   t2_concat (t2_overlap [1..4]) == [1,2,2,3,3,4]
--   </pre>
t2_concat :: [(a, a)] -> [a]

-- | A Signal is half the size of a Wavetable, each element is the sum of
--   two adjacent elements of the Wavetable.
--   
--   <pre>
--   from_wavetable [-0.5,0.5,0,0.5,1.5,-0.5,1,-0.5] == [0.0,0.5,1.0,0.5]
--   let s = [0,0.5,1,0.5] in from_wavetable (to_wavetable s) == s
--   </pre>
from_wavetable :: Num n => [n] -> [n]

-- | A Wavetable is has <i>n * 2 + 2</i> elements, where <i>n</i> is the
--   number of elements of the Signal. Each signal element <i>e0</i>
--   expands to the two elements <i>(2 * e0 - e1, e1 - e0)</i> where
--   <i>e1</i> is the next element, or zero at the final element. Properly
--   wavetables are only of power of two element signals.
--   
--   <pre>
--   &gt; Signal[0,0.5,1,0.5].asWavetable == Wavetable[-0.5,0.5,0,0.5,1.5,-0.5,1,-0.5]
--   </pre>
--   
--   <pre>
--   to_wavetable [0,0.5,1,0.5] == [-0.5,0.5,0,0.5,1.5,-0.5,1,-0.5]
--   </pre>
to_wavetable :: Num a => [a] -> [a]

-- | Variant of <a>sineFill</a> that gives each component table.
--   
--   <pre>
--   let t = sineGen 1024 (map recip [1,2,3,5,8,13,21,34,55]) (replicate 9 0)
--   map length t == replicate 9 1024
--   </pre>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable t
--   </pre>
sineGen :: (Floating n, Enum n) => Int -> [n] -> [n] -> [[n]]

-- | <tt>Signal.*sineFill</tt> is a table generator. Frequencies are
--   partials, amplitudes and initial phases are as given. Result is
--   normalised.
--   
--   <pre>
--   let t = let a = [[21,5,34,3,2,13,1,8,55]
--                   ,[13,8,55,34,5,21,3,1,2]
--                   ,[55,34,1,3,2,13,5,8,21]]
--           in map (\amp -&gt; sineFill 1024 (map recip amp) (replicate 9 0)) a
--   </pre>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable t
--   </pre>
sineFill :: (TernaryOp n, Ord n, Floating n, Enum n) => Int -> [n] -> [n] -> [n]

-- | <i>z</i> ranges from 0 (for <i>i</i>) to 1 (for <i>j</i>).
--   
--   <pre>
--   &gt; 1.5.blend(2.0,0.50) == 1.75
--   &gt; 1.5.blend(2.0,0.75) == 1.875
--   </pre>
--   
--   <pre>
--   blend 0.50 1.5 2 == 1.75
--   blend 0.75 1.5 2 == 1.875
--   </pre>
blend :: Num a => a -> a -> a -> a

-- | Variant of '(!!)' but values for index greater than the size of the
--   collection will be clipped to the last index.
clipAt :: Int -> [a] -> a

-- | <a>abs</a> of '(-)'.
absdif :: Num a => a -> a -> a

-- | Variant where all inputs are lists and the result is not catentated.
--   Does not generate partial windows.
--   
--   <pre>
--   let r = ["abc","bc","def","ef","ghi","hi"]
--   in slide1 (cycle [3,2]) (cycle [1,2]) ['a'..'i'] == r
--   </pre>
--   
--   <pre>
--   let r = ["abc","bc","bcd","cd","cde","de"]
--   in slide1 (cycle [3,2]) (cycle [1,0]) ['a'..'e'] == r
--   </pre>
slide1 :: Integral i => [i] -> [i] -> [a] -> [[a]]

-- | <a>concat</a> of <a>slide1</a>.
slide2 :: Integral i => [i] -> [i] -> [a] -> [a]

-- | Variant where stutter input is a list and the result is not
--   catentated.
--   
--   <pre>
--   stutter1 [2,1,2] [1,2,3] == [[1,1],[2],[3,3]]
--   </pre>
stutter1 :: Integral i => [i] -> [a] -> [[a]]

-- | <a>concat</a> of <a>stutter1</a>.
stutter2 :: Integral i => [i] -> [a] -> [a]


-- | <a>Array</a> variants of <a>Sound.SC3.Lang.Collection</a>.
module Sound.SC3.Lang.Collection.Array

-- | <a>clipAt</a>.
clipAt :: Int -> Array Int a -> a

-- | <a>blendAtBy</a> of <a>clipAt</a>.
--   
--   <pre>
--   blendAt 0 (A.listArray (0,2) [2,5,6]) == 2
--   blendAt 0.4 (A.listArray (0,2) [2,5,6]) == 3.2
--   </pre>
blendAt :: RealFrac a => a -> Array Int a -> a

-- | <a>resamp1</a>.
--   
--   <pre>
--   resamp1 12 (A.listArray (0,3) [1,2,3,4])
--   resamp1 3 (A.listArray (0,3) [1,2,3,4]) == A.listArray (0,2) [1,2.5,4]
--   </pre>
resamp1 :: (Enum n, RealFrac n) => Int -> Array Int n -> Array Int n


-- | Variants of standard numerical operators with SC3 extension behaviour.
--   Pointwise operations in SuperCollider language extend the shorter
--   input by cycling.
--   
--   <pre>
--   [1,2] +. [3,4,5] == [1,2,1] +. [3,4,5]
--   [1,2] +. [3,4,5] == [4,6,6]
--   </pre>
--   
--   The function underlying the list numerical instances is
--   <a>zipWith_c</a>.
--   
--   <pre>
--   zipWith (+) [1,2] [3,4,5] == [4,6]
--   zipWith_c (+) [1,2] [3,4,5] == [4,6,6]
--   </pre>
module Sound.SC3.Lang.Collection.Extension

-- | Class defining <a>zipWith_c</a> which is a cycle extending variant of
--   <a>zipWith</a>.
class Extending f
zipWith_c :: Extending f => (a -> b -> c) -> f a -> f b -> f c

-- | <a>zipWith_c</a> <a>+</a>.
(+.) :: (Extending f, Num a) => f a -> f a -> f a

-- | <a>zipWith_c</a> <a>*</a>.
(*.) :: (Extending f, Num a) => f a -> f a -> f a

-- | <a>zipWith_c</a> <a>/</a>.
(/.) :: (Extending f, Fractional a) => f a -> f a -> f a

-- | <a>zipWith_c</a> <a>-</a>.
(-.) :: (Extending f, Num a) => f a -> f a -> f a
instance Extending []


-- | List instances of the standard haskell numerical classes with SC3
--   extension behaviour. Provides instances for <a>Num</a>,
--   <a>Fractional</a> and <a>Floating</a>.
--   
--   <pre>
--   [1,2] + [3,4,5] == [4,6,6]
--   [1,2,3] * [4,5] == [4,10,12]
--   </pre>
--   
--   Literals are interpreted as single element lists.
--   
--   <pre>
--   [1,2,3] + 4 == [5,6,7]
--   [1,2,3] * 4 == [4,8,12]
--   </pre>
module Sound.SC3.Lang.Collection.Numerical.Extending
instance Floating a => Floating [a]
instance Fractional a => Fractional [a]
instance Integral a => Integral [a]
instance Enum a => Enum [a]
instance Real a => Real [a]
instance Num a => Num [a]


-- | <a>Vector</a> variants of <a>Sound.SC3.Lang.Collection</a>.
module Sound.SC3.Lang.Collection.Vector

-- | <a>clipAt</a>.
clipAt :: Int -> Vector a -> a

-- | <a>blendAtBy</a> of <a>clipAt</a>.
--   
--   <pre>
--   blendAt 0 (V.fromList [2,5,6]) == 2
--   blendAt 0.4 (V.fromList [2,5,6]) == 3.2
--   blendAt 2.1 (V.fromList [2,5,6]) == 6
--   </pre>
blendAt :: RealFrac a => a -> Vector a -> a

-- | <a>resamp1</a>.
--   
--   <pre>
--   resamp1 12 (V.fromList [1,2,3,4])
--   resamp1 3 (V.fromList [1,2,3,4]) == V.fromList [1,2.5,4]
--   </pre>
resamp1 :: (Enum n, RealFrac n) => Int -> Vector n -> Vector n


-- | An <a>Event</a> is a (<a>Key</a>,<a>Field</a>) map.
module Sound.SC3.Lang.Control.Event

-- | Event field.
--   
--   <a>Field</a>s are <a>Num</a>.
--   
--   <pre>
--   5 :: Field
--   4 + 5 :: Field
--   negate 5 :: Field
--   f_array [2,3] + f_array [4,5] == f_array [6,8]
--   f_array [1,2,3] + f_array [4,5] == f_array [5,7,7]
--   4 + f_array [5,6] == f_array [9,10]
--   </pre>
data Field
F_Double :: Double -> Field
f_double :: Field -> Double
F_Vector :: [Field] -> Field
f_vector :: Field -> [Field]
F_String :: String -> Field
f_string :: Field -> String
F_Instr :: Instr -> Field
f_instr :: Field -> Instr

-- | Set of types that can be lifted to <a>Field</a>.
class F_Value a
toF :: F_Value a => a -> Field

-- | Numeric <a>F_Value</a> types.
class F_Value a => F_Num a

-- | Maybe variant of <a>f_double</a>.
f_double_m :: Field -> Maybe Double

-- | Variant of <i>reader</i> with specified error message.
f_reader_err :: String -> String -> (Field -> Maybe a) -> Field -> a

-- | Variant of <a>f_double</a> with specified error message.
f_double_err :: String -> Field -> Double

-- | Run <a>&gt;</a> <tt>0</tt> at <a>f_double</a>.
f_bool_err :: String -> Field -> Bool

-- | Run <a>round</a> at <a>f_double</a>.
f_int_err :: String -> Field -> Int

-- | Single element <a>F_Vector</a> constructor.
--   
--   <pre>
--   f_ref 1 == f_array [1]
--   </pre>
f_ref :: Field -> Field

-- | Uniform vector constructor.
--   
--   <pre>
--   f_array [1,2] == F_Vector [F_Double 1,F_Double 2]
--   </pre>
f_array :: [Double] -> Field

-- | Maybe variant of <a>f_vector</a>.
f_vector_m :: Field -> Maybe [Field]

-- | <a>length</a> of <a>f_vector_m</a>.
--   
--   <pre>
--   f_vector_length (f_array [1..5]) == Just 5
--   </pre>
f_vector_length :: Field -> Maybe Int

-- | Indexed variant of <a>f_double_err</a>.
--   
--   <pre>
--   f_double_err_ix "" Nothing 1 == 1
--   f_double_err_ix "" (Just 1) (f_array [0,1]) == 1
--   </pre>
f_double_err_ix :: String -> Maybe Int -> Field -> Double

-- | Maybe variant of <a>f_instr</a>.
f_instr_m :: Field -> Maybe Instr

-- | Variant of <a>f_instr</a> with specified error message.
f_instr_err :: String -> Field -> Instr

-- | Map <i>fn</i> over vector elements at <i>f</i>.
--   
--   <pre>
--   f_map negate (f_array [0,1]) == f_array [0,-1]
--   </pre>
f_map :: (Field -> Field) -> Field -> Field

-- | Numerical unary operator.
--   
--   <pre>
--   f_uop negate (F_Double 1) == F_Double (-1)
--   f_uop negate (F_Vector [F_Double 0,F_Double 1]) == f_array [0,-1]
--   </pre>
f_uop :: (Double -> Double) -> Field -> Field

-- | Numerical binary operator.
--   
--   <pre>
--   f_binop (+) (F_Double 1) (F_Double 2) == F_Double 3
--   f_binop (*) (f_array [1,2,3]) (f_array [3,4,5]) == f_array [3,8,15]
--   f_binop (/) (F_Double 9) (F_Double 3) == F_Double 3
--   </pre>
f_binop :: (Double -> Double -> Double) -> Field -> Field -> Field

-- | At floating branch of <a>Field</a>.
f_atf :: (Double -> a) -> Field -> a

-- | At floating branches of <a>Field</a>s.
f_atf2 :: (Double -> Double -> a) -> Field -> Field -> a

-- | At floating branches of <a>Field</a>s.
f_atf3 :: (Double -> Double -> Double -> a) -> Field -> Field -> Field -> a

-- | Extend to <a>Field</a> to <i>n</i>.
--   
--   <pre>
--   f_mce_extend 3 (f_array [1,2]) == f_array [1,2,1]
--   f_mce_extend 3 1 == f_array [1,1,1]
--   </pre>
f_mce_extend :: Int -> Field -> Field

-- | The type of the <i>key</i> at an <a>Event</a>.
--   
--   <pre>
--   :set -XOverloadedStrings
--   [K_dur,"pan"] == [K_dur,K_param "pan"]
--   </pre>
data Key
K_degree :: Key
K_mtranspose :: Key
K_scale :: Key
K_stepsPerOctave :: Key
K_gtranspose :: Key
K_note :: Key
K_octave :: Key
K_root :: Key
K_ctranspose :: Key
K_harmonic :: Key
K_midinote :: Key
K_detune :: Key
K_freq :: Key
K_delta :: Key
K_dur :: Key
K_lag :: Key
K_legato :: Key
K_fwd' :: Key
K_stretch :: Key
K_sustain :: Key
K_tempo :: Key
K_db :: Key
K_amp :: Key
K_rest :: Key
K_instr :: Key
K_id :: Key
K_type :: Key
K_latency :: Key
K_param :: String -> Key

-- | SC3 name of <a>Key</a>.
--   
--   <pre>
--   map k_name [K_freq,K_dur,K_param "pan"] == ["freq","dur","pan"]
--   </pre>
k_name :: Key -> String

-- | List of reserved <a>Key</a>s used in pitch, duration and amplitude
--   models. These are keys that may be provided explicitly, but if not
--   will be calculated implicitly.
--   
--   <pre>
--   (K_freq `elem` k_reserved) == True
--   </pre>
k_reserved :: [Key]
k_vector :: [Key]

-- | Is <a>Key</a> <i>not</i> <a>k_reserved</a>, and <i>not</i>
--   <a>k_vector</a>.
--   
--   <pre>
--   k_is_parameter (K_param "pan",0) == True
--   </pre>
k_is_parameter :: (Key, a) -> Bool

-- | An <a>Event</a> is a (<a>Key</a>,<a>Field</a>) map.
type Event = Map Key Field

-- | Insert (<i>k</i>,<i>v</i>) into <i>e</i>.
--   
--   <pre>
--   e_get K_id (e_insert K_id 1 mempty) == Just 1
--   </pre>
e_insert :: Key -> Field -> Event -> Event

-- | Event from association list.
--   
--   <pre>
--   e_get K_id (e_from_list [(K_id,1)]) == Just 1
--   </pre>
e_from_list :: [(Key, Field)] -> Event

-- | Event from association list.
--   
--   <pre>
--   let a = [(K_id,1)] in e_to_list (e_from_list a) == a
--   </pre>
e_to_list :: Event -> [(Key, Field)]

-- | Lookup <i>k</i> in <i>e</i>.
--   
--   <pre>
--   e_get K_id mempty == Nothing
--   </pre>
e_get :: Key -> Event -> Maybe Field

-- | Immediate or vector element lookup.
--   
--   <pre>
--   e_get_ix Nothing K_id (e_from_list [(K_id,1)]) == Just 1
--   </pre>
--   
--   <pre>
--   let n = f_array [0,1,2]
--   in e_get_ix Nothing K_id (e_from_list [(K_id,n)]) == Just n
--   </pre>
--   
--   <pre>
--   let n = f_array [0..9]
--   in e_get_ix (Just 5) K_id (e_from_list [(K_id,n)]) == Just 5
--   </pre>
e_get_ix :: Maybe Int -> Key -> Event -> Maybe Field

-- | Type specialised <a>e_get</a>.
e_get_double :: Key -> Event -> Maybe Double

-- | Type specialised <a>e_get_ix</a>.
e_get_double_ix :: Maybe Int -> Key -> Event -> Maybe Double

-- | Type specialised <a>e_get</a>.
e_get_bool :: Key -> Event -> Maybe Bool

-- | Type specialised <a>e_get</a>.
e_get_int :: Key -> Event -> Maybe Int

-- | Type specialised <a>e_get_ix</a>.
e_get_int_ix :: Maybe Int -> Key -> Event -> Maybe Int

-- | Type specialised <a>e_get</a>.
e_get_instr :: Key -> Event -> Maybe Instr

-- | Type specialised <a>e_get_ix</a>.
e_get_instr_ix :: Maybe Int -> Key -> Event -> Maybe Instr

-- | Type specialised <a>e_get</a>.
e_get_array :: Key -> Event -> Maybe [Double]

-- | Type specialised <a>e_get_ix</a>.
--   
--   <pre>
--   let e = e_from_list [(K_scale,f_array [0,2])]
--   in e_get_array_ix Nothing K_scale e == Just [0,2]
--   </pre>
--   
--   <pre>
--   let e = e_from_list [(K_scale,f_ref (f_array [0,2]))]
--   in e_get_array_ix (Just 0) K_scale e == Just [0,2]
--   </pre>
e_get_array_ix :: Maybe Int -> Key -> Event -> Maybe [Double]

-- | <a>Event</a> <i>type</i>.
--   
--   <pre>
--   e_type mempty == "s_new"
--   </pre>
e_type :: Event -> String

-- | Match on event types, in sequence: s_new, n_set, rest.
e_type_match :: Event -> T3 (Event -> t) -> t

-- | <a>const</a> variant of <a>e_type_match</a>.
e_type_match' :: Event -> T3 t -> t

-- | Generate <a>Dur</a> from <a>Event</a>.
--   
--   <pre>
--   D.delta (e_dur Nothing mempty) == 1
--   D.fwd (e_dur Nothing (e_from_list [(K_dur,1),(K_stretch,2)])) == 2
--   </pre>
--   
--   <pre>
--   let e = e_from_list [(K_dur,1),(K_legato,0.5)]
--   in D.occ (e_dur Nothing e) == 0.5
--   </pre>
e_dur :: Maybe Int -> Event -> Dur

-- | Generate <tt>Pitch</tt> from <a>Event</a>.
--   
--   <pre>
--   P.midinote (e_pitch Nothing mempty) == 60
--   P.freq (e_pitch Nothing (e_from_list [(K_degree,5)])) == 440
--   </pre>
--   
--   <pre>
--   let e = e_from_list [(K_degree,5),(K_scale,f_array [0,2,3,5,7,8,10])]
--   in P.midinote (e_pitch Nothing e) == 68
--   </pre>
--   
--   <pre>
--   let e = e_from_list [(K_degree,5),(K_scale,f_ref (f_array [0,2,3,5,7,8,10]))]
--   in P.midinote (e_pitch (Just 0) (e_mce_expand e)) == 68
--   </pre>
--   
--   <pre>
--   P.freq (e_pitch Nothing (e_from_list [(K_midinote,69)])) == 440
--   </pre>
e_pitch :: Maybe Int -> Event -> Pitch

-- | <a>Event</a> identifier.
e_id :: Maybe Int -> Event -> Maybe Int

-- | Lookup <i>db</i> field of <a>Event</a>.
--   
--   <pre>
--   e_db Nothing mempty == (-20)
--   </pre>
e_db :: Maybe Int -> Event -> Double

-- | The linear amplitude of the amplitude model at <i>e</i>.
--   
--   <pre>
--   e_amp Nothing (e_from_list [(K_db,-60)]) == 0.001
--   e_amp Nothing (e_from_list [(K_amp,0.01)]) == 0.01
--   e_amp Nothing mempty == 0.1
--   </pre>
e_amp :: Maybe Int -> Event -> Double

-- | Message <i>latency</i> of event.
--   
--   <pre>
--   e_latency mempty == 0.1
--   </pre>
e_latency :: Event -> Double

-- | Extract non-<tt>reserved</tt> <tt>Keys</tt> from <a>Event</a>.
--   
--   <pre>
--   let e = e_from_list [(K_freq,1),(K_param "p",1),(K_scale,f_ref (f_array [0,3,7]))]
--   in e_parameters Nothing e == [("p",1)]
--   </pre>
e_parameters :: Maybe Int -> Event -> [(String, Double)]

-- | <tt>Value</tt> editor for <a>Key</a> at <a>Event</a>, with default
--   value in case <a>Key</a> is not present.
e_edit :: Key -> Field -> (Field -> Field) -> Event -> Event

-- | Variant of <tt>edit_v</tt> with no default value.
e_edit' :: Key -> (Field -> Field) -> Event -> Event

-- | Merge two time-stamped <a>Event</a> sequences. Note that this uses
--   <a>fwd</a> to calculate start times.
e_merge' :: (Time, [Event]) -> (Time, [Event]) -> [(Time, Event)]

-- | Insert <i>fwd</i> <a>Key</a>s into a time-stamped <a>Event</a>
--   sequence.
e_add_fwd :: [(Time, Event)] -> [Event]

-- | Composition of <tt>add_fwd</tt> and <tt>merge'</tt>.
e_merge :: (Time, [Event]) -> (Time, [Event]) -> [Event]

-- | N-ary variant of <a>e_merge</a>.
--   
--   <pre>
--   e_par [(0,repeat (e_from_list [(K_id,1)]))
--         ,(0,repeat (e_from_list [(K_param "b",2)]))
--         ,(0,repeat (e_from_list [(K_param "c",3)]))]
--   </pre>
e_par :: [(Time, [Event])] -> [Event]

-- | <a>mempty</a> with <i>rest</i>.
e_rest :: Event

-- | Does <a>Event</a> have a <a>True</a> <tt>rest</tt> key.
--   
--   <pre>
--   e_is_rest mempty == False
--   e_is_rest (e_from_list [(K_rest,1)]) == True
--   </pre>
e_is_rest :: Event -> Bool

-- | Maximum vector length at <a>Event</a>.
--   
--   <pre>
--   e_mce_depth (e_from_list [(K_id,1)]) == Nothing
--   e_mce_depth (e_from_list [(K_id,1),(K_param "b",f_array [2,3])]) == Just 2
--   </pre>
e_mce_depth :: Event -> Maybe Int

-- | Extend vectors at <a>Event</a> if required, returning
--   <a>e_mce_depth</a>.
--   
--   <pre>
--   let {e = e_from_list [(K_id,f_array [1,2]),(K_param "b",f_array [2,3,4])]
--       ;r = e_from_list [(K_id,f_array [1,2,1]),(K_param "b",f_array [2,3,4])]}
--   in e_mce_extend e == Just (3,r)
--   </pre>
--   
--   <pre>
--   let e = e_from_list [(K_id,1)]
--   in e_mce_extend e == Nothing
--   </pre>
e_mce_extend :: Event -> Maybe (Int, Event)

-- | <a>e_mce_extend</a> variant.
e_mce_expand :: Event -> Event

-- | Parallel <a>Event</a>s, if required.
--   
--   <pre>
--   let {e = e_from_list [(K_id,1),(K_param "b",f_array [2,3])]
--       ;r = [e_from_list [(K_id,1),(K_param "b",2)],e_from_list [(K_id,1),(K_param "b",3)]]}
--   in e_un_mce e == Just r
--   </pre>
--   
--   <pre>
--   let {e = e_from_list [(K_id,f_array [1,2]),(K_param "b",f_array [3,4,5])]
--       ;r = e_from_list [(K_id,1),(K_param "b",5)]}
--   in fmap (!! 2) (e_un_mce e) == Just r
--   </pre>
--   
--   <pre>
--   e_un_mce (e_from_list [(K_id,1)]) == Nothing
--   </pre>
e_un_mce :: Event -> Maybe [Event]

-- | <a>e_un_mce</a> variant.
e_un_mce' :: Event -> [Event]

-- | Generate <tt>SC3</tt> <i>(on,off)</i> <a>Message</a> sets describing
--   <a>Event</a>.
e_messages :: Dur -> Event -> Int -> Maybe Int -> Maybe (T2 [Message])

-- | MCE variant of <a>e_messages</a>.
e_messages_mce :: Dur -> Event -> Int -> (Maybe (T2 [Message]), Int)

-- | Generate <tt>SC3</tt> <i>(on,off)</i> <a>Bundle</a>s describing
--   <a>Event</a>.
e_bundles :: Time -> Int -> Dur -> Event -> (Maybe (T2 Bundle), Int)

-- | Ordered sequence of <a>Event</a>.
newtype Event_Seq
Event_Seq :: [Event] -> Event_Seq
e_seq_events :: Event_Seq -> [Event]

-- | Transform <a>Event_Seq</a> into a sequence of <tt>SC3</tt>
--   <i>(on,off)</i> <tt>Bundles</tt>.
--   
--   <pre>
--   e_bundle_seq 0 (Event_Seq (replicate 5 mempty))
--   </pre>
e_bundle_seq :: Time -> Event_Seq -> [T2 Bundle]

-- | Transform (productively) an <a>Event_Seq</a> into an <a>NRT</a> score.
--   
--   <pre>
--   let {n1 = nrt_bundles (e_nrt (Event_Seq (replicate 5 mempty)))
--       ;n2 = take 11 (nrt_bundles (e_nrt (Event_Seq (repeat mempty))))}
--   in n1 == n2
--   </pre>
e_nrt :: Event_Seq -> NRT

-- | Audition <a>Event_Seq</a>.
e_play :: Transport m => Event_Seq -> m ()

-- | Type-specialised <a>mempty</a>.
e_empty :: Event

-- | Type-specialised <a>mappend</a>.
--   
--   <pre>
--   let {l = [(K_id,0)];r = [(K_degree,1)]}
--   in e_from_list l &lt;&gt; e_from_list r == e_from_list (l &lt;&gt; r)
--   </pre>
e_union :: Event -> Event -> Event

-- | Left-biased merge of two sorted sequence of temporal values.
--   
--   <pre>
--   let m = t_merge (zip [0,2,4,6] ['a'..]) (zip [0,3,6] ['A'..])
--   in m == [(0,'a'),(0,'A'),(2,'b'),(3,'B'),(4,'c'),(6,'d'),(6,'C')]
--   </pre>
t_merge :: Ord t => [(t, a)] -> [(t, a)] -> [(t, a)]

-- | Two tuple of <i>n</i>.
type T2 n = (n, n)

-- | Three tuple of <i>n</i>.
type T3 n = (n, n, n)

-- | <a>Maybe</a> variant of <tt>:</tt>.
mcons :: Maybe a -> [a] -> [a]
instance Eq Field
instance Show Field
instance Eq Key
instance Ord Key
instance Show Key
instance Audible Event_Seq
instance IsString Key
instance BinaryOp Field
instance UnaryOp Field
instance RealFracE Field
instance OrdE Field
instance EqE Field
instance Random Field
instance Enum Field
instance Ord Field
instance RealFloat Field
instance RealFrac Field
instance Real Field
instance Floating Field
instance Fractional Field
instance Num Field
instance IsString Field
instance F_Num Field
instance F_Num Double
instance F_Num Int
instance F_Value Field
instance F_Value Instr
instance F_Value Double
instance F_Value Int
instance F_Value Bool


-- | <a>RandomGen</a> based <tt>sclang</tt> random number functions.
module Sound.SC3.Lang.Random.Gen

-- | <tt>SimpleNumber.rand</tt> is <a>randomR</a> in (0,<i>n</i>).
rand :: (RandomGen g, Random n, Num n) => n -> g -> (n, g)

-- | State modifying variant of <a>iterate</a>. Lifts random generator
--   functions to infinte lists.
--   
--   <pre>
--   let r = [3,1,7,0,12,1,6,4,12,11,7,4]
--   in take 12 (r_iterate (rand 12) (mkStdGen 0)) == r
--   </pre>
r_iterate :: (t -> (a, t)) -> t -> [a]

-- | Function underlying both <a>kvariant</a> and <a>kvariant'</a>.
mk_kvariant :: r -> (t -> r -> r) -> (r -> r') -> Int -> (g -> (t, g)) -> g -> (r', g)

-- | Construct variant of <i>f</i> generating <i>k</i> values. Note that
--   the result is the reverse of the initial sequence given by
--   <a>r_iterate</a>.
--   
--   <pre>
--   let r = [3,1,7,0,12,1,6,4,12,11,7,4]
--   in fst (kvariant 12 (rand 12) (mkStdGen 0)) == reverse r
--   </pre>
kvariant :: Int -> (g -> (a, g)) -> g -> ([a], g)

-- | Variant of <a>kvariant</a> that generates sequence in the same order
--   as <a>r_iterate</a>. There is perhaps a slight overhead from using a
--   difference list.
--   
--   <pre>
--   let r = [3,1,7,0,12,1,6,4,12,11,7,4]
--   in fst (kvariant' 12 (rand 12) (mkStdGen 0)) == r
--   </pre>
kvariant' :: Int -> (g -> (a, g)) -> g -> ([a], g)

-- | Variant of <a>rand</a> generating <i>k</i> values.
--   
--   <pre>
--   fst (nrand 10 (5::Int) (mkStdGen 246873)) == [0,5,4,0,4,5,3,2,3,1]
--   </pre>
nrand :: (RandomGen g, Random n, Num n) => Int -> n -> g -> ([n], g)

-- | Stream variant of <a>rand</a>.
s_rand :: (RandomGen g, Random n, Num n) => n -> g -> [n]

-- | <tt>SimpleNumber.rand2</tt> is <a>randomR</a> in (-<i>n</i>,<i>n</i>).
rand2 :: (RandomGen g, Random n, Num n) => n -> g -> (n, g)

-- | Stream variant of <a>rand2</a>.
s_rand2 :: (RandomGen g, Random n, Num n) => n -> g -> [n]

-- | Variant of <a>rand2</a> generating <i>k</i> values.
nrand2 :: (RandomGen g, Random a, Num a) => Int -> a -> g -> ([a], g)

-- | <tt>SimpleNumber.rrand</tt> is <a>curry</a> <a>randomR</a>.
rrand :: (Random n, RandomGen g) => n -> n -> g -> (n, g)

-- | Variant of <a>rrand</a> generating <i>k</i> values.
nrrand :: (RandomGen g, Random a, Num a) => Int -> a -> a -> g -> ([a], g)

-- | <tt>SequenceableCollection.choose</tt> selects an element at random.
choose :: RandomGen g => [a] -> g -> (a, g)

-- | Variant of <a>choose</a> generating <i>k</i> values.
nchoose :: RandomGen g => Int -> [a] -> g -> ([a], g)

-- | <tt>SimpleNumber.exprand</tt> generates exponentially distributed
--   random number in the given interval.
exprand :: (Floating n, Random n, RandomGen g) => n -> n -> g -> (n, g)

-- | Variant of <a>exprand</a> generating <i>k</i> values.
nexprand :: (Floating n, Random n, RandomGen g) => Int -> n -> n -> g -> ([n], g)

-- | <tt>SimpleNumber.coin</tt> is <a>True</a> at given probability, which
--   is in range (0,1).
coin :: (RandomGen g, Random a, Ord a, Fractional a) => a -> g -> (Bool, g)

-- | Variant of <a>coin</a> generating <i>k</i> values.
--   
--   <pre>
--   fst (ncoin 5 0.5 (mkStdGen 0)) == [True,True,False,True,False]
--   </pre>
ncoin :: (RandomGen g, Random a, Ord a, Fractional a) => Int -> a -> g -> ([Bool], g)

-- | <tt>List.scramble</tt> shuffles the elements.
--   
--   <pre>
--   fst (scramble [1..5] (mkStdGen 0)) == [1,5,2,3,4]
--   </pre>
scramble :: RandomGen g => [t] -> g -> ([t], g)

-- | <tt>SequenceableCollection.wchoose</tt> selects an element from a list
--   given a list of weights which sum to <tt>1</tt>.
--   
--   <pre>
--   kvariant 10 (wchoose "abcd" (C.normalizeSum [8,4,2,1])) (mkStdGen 0)
--   </pre>
wchoose :: (RandomGen g, Random a, Ord a, Fractional a) => [b] -> [a] -> g -> (b, g)

-- | Variant that applies <a>normalizeSum</a> to weights.
--   
--   <pre>
--   let r = "dcbbacaadd"
--   in r == fst (kvariant 10 (wchoose_N "abcd" [8,4,2,1]) (mkStdGen 0))
--   </pre>
wchoose_N :: (Fractional a, Ord a, RandomGen g, Random a) => [b] -> [a] -> g -> (b, g)

-- | <a>kvariant</a> of <a>wchoose_N</a>.
nwchoose_N :: (Fractional a, Ord a, RandomGen g, Random a) => Int -> [b] -> [a] -> g -> ([b], g)


-- | Infinte list <tt>SC3</tt> pattern functions.
module Sound.SC3.Lang.Pattern.Stream

-- | Remove successive duplicates.
--   
--   <pre>
--   rsd [1,2,3,1,2,3] == [1,2,3,1,2,3]
--   </pre>
rsd :: Eq a => [a] -> [a]

-- | True if <i>a</i> is initially equal to <i>b</i>.
iEq :: Eq a => [a] -> [a] -> Bool

-- | Take elements from <i>l</i> until all elements in <i>s</i> have been
--   seen. If <i>s</i> contains duplicate elements these must be seen
--   multiple times.
--   
--   <pre>
--   take_until_forms_set "abc" "a random sentence beginning" == "a random sentence b"
--   </pre>
take_until_forms_set :: Eq a => [a] -> [a] -> [a]

-- | Underlying <a>brown</a>.
brown_ :: (RandomGen g, Random n, Num n, Ord n) => (n, n, n) -> (n, g) -> (n, g)

-- | Brown noise with list inputs.
--   
--   <pre>
--   let l = brown 'α' (repeat 1) (repeat 700) (cycle [1,20])
--   in l `iEq` [415,419,420,428]
--   </pre>
brown :: (Enum e, Random n, Num n, Ord n) => e -> [n] -> [n] -> [n] -> [n]

-- | <a>exprange</a> of <a>white</a>
exprand :: (Enum e, Random a, Floating a) => e -> a -> a -> [a]

-- | Geometric series.
--   
--   <pre>
--   geom 3 6 `iEq` [3,18,108,648,3888,23328,139968]
--   </pre>
geom :: Num a => a -> a -> [a]
lace :: [[a]] -> [a]

-- | Random elements from list.
--   
--   <pre>
--   take_until_forms_set "string" (rand 'α' "string") == "grtrsiirn"
--   </pre>
rand :: Enum e => e -> [a] -> [a]

-- | List section with <i>wrapped</i> indices.
--   
--   <pre>
--   segment [0..4] 5 (3,5) == [3,4,0]
--   </pre>
segment :: [a] -> Int -> (Int, Int) -> [a]
slide :: [a] -> Int -> Int -> Int -> Bool -> [[a]]

-- | <a>concat</a> of <a>slide</a>.
slidec :: [a] -> Int -> Int -> Int -> Bool -> [a]

-- | White noise.
--   
--   <pre>
--   take_until_forms_set [1..5] (white 'α' 1 5) == [4,1,2,2,2,1,2,1,2,5,1,4,3]
--   </pre>
white :: (Random n, Enum e) => e -> n -> n -> [n]

-- | Weighted selection of elements from a list.
wrand_generic :: (Enum e, Fractional n, Ord n, Random n) => e -> [a] -> [n] -> [a]

-- | Type restricted variant.
--   
--   <pre>
--   import qualified Sound.SC3.Lang.Collection as C
--   </pre>
--   
--   <pre>
--   let {w = C.normalizeSum [1..5]
--       ;r = wrand 'ζ' "wrand" w}
--   in take_until_forms_set "wrand" r == "dnanrdnaddrnrrndrrdw"
--   </pre>
wrand :: Enum e => e -> [a] -> [Double] -> [a]

-- | Select elements from <i>l</i> in random sequence, but do not
--   immediately repeat an element.
--   
--   <pre>
--   take_until_forms_set "string" (xrand 'α' "string") == "grtrsirn"
--   </pre>
xrand :: Enum e => e -> [a] -> [a]


-- | List variants of <tt>SC3</tt> pattern functions.
module Sound.SC3.Lang.Pattern.List

-- | <a>&gt;</a> <tt>0</tt>. Values greater than zero are <a>True</a> and
--   zero and negative values are <a>False</a>.
bool :: (Ord n, Num n) => n -> Bool

-- | <a>fmap</a> of <a>bool</a>.
--   
--   <pre>
--   fbool [2,1,0,-1] == [True,True,False,False]
--   </pre>
fbool :: (Ord a, Num a, Functor f) => f a -> f Bool

-- | SC3 pattern to fold values to lie within range (as opposed to wrap and
--   clip). This is <i>not</i> related to <a>Data.Foldable</a>.
--   
--   <pre>
--   ffold [10,11,12,-6,-7,-8] (-7) 11 == [10,11,10,-6,-7,-6]
--   </pre>
--   
--   The underlying primitive is the <a>fold_</a> function.
--   
--   <pre>
--   let f n = S.fold_ n (-7) 11
--   in map f [10,11,12,-6,-7,-8] == [10,11,10,-6,-7,-6]
--   </pre>
ffold :: (Functor f, Num a, Ord a) => f a -> a -> a -> f a

-- | SC3 pattern to constrain the range of output values by wrapping, the
--   primitive is <a>genericWrap</a>.
--   
--   <pre>
--   let p = fmap round (fwrap (geom 200 1.2 10) 200 1000)
--   in p == [200,240,288,346,415,498,597,717,860,231]
--   </pre>
fwrap :: (Functor f, Ord a, Num a) => f a -> a -> a -> f a

-- | Count the number of <a>False</a> values following each <a>True</a>
--   value.
--   
--   <pre>
--   countpost (map bool [1,0,1,0,0,0,1,1]) == [1,3,0,0]
--   </pre>
countpost :: [Bool] -> [Int]

-- | Count the number of <a>False</a> values preceding each <a>True</a>
--   value.
--   
--   <pre>
--   countpre (fbool [0,0,1,0,0,0,1,1]) == [2,3,0]
--   </pre>
countpre :: [Bool] -> [Int]

-- | Sample and hold initial value.
--   
--   <pre>
--   hold [] == []
--   hold [1..5] == [1,1,1,1,1]
--   hold [1,undefined] == [1,1]
--   </pre>
hold :: [a] -> [a]

-- | Interleave elements from two lists. If one list ends the other
--   continues until it also ends.
--   
--   <pre>
--   interleave2 [1,2,3,1,2,3] [4,5,6,7] == [1,4,2,5,3,6,1,7,2,3]
--   [1..9] `isPrefixOf` interleave2 [1,3..] [2,4..]
--   </pre>
interleave2 :: [a] -> [a] -> [a]

-- | N-ary variant of <a>interleave2</a>, ie. <a>concat</a> of
--   <a>transpose</a>.
--   
--   <pre>
--   interleave [whitei 'α' 0 4 3,whitei 'β' 5 9 3] == [3,7,0,8,1,6]
--   [1..9] `isPrefixOf` interleave [[1,4..],[2,5..],[3,6..]]
--   </pre>
interleave :: [[a]] -> [a]

-- | Pattern where the <tt>tr</tt> pattern determines the rate at which
--   values are read from the <tt>x</tt> pattern. For each sucessive true
--   value at <tt>tr</tt> the output is a (<a>Just</a> e) of each succesive
--   element at x. False values at <tt>tr</tt> generate <a>Nothing</a>
--   values.
--   
--   <pre>
--   let l = trigger (map toEnum [0,1,0,0,1,1]) [1,2,3]
--   in l == [Nothing,Just 1,Nothing,Nothing,Just 2,Just 3]
--   </pre>
trigger :: [Bool] -> [a] -> [Maybe a]

-- | Pbrown. SC3 pattern to generate psuedo-brownian motion.
--   
--   <pre>
--   [4,4,1,8,5] `isPrefixOf` brown 'α' 0 9 15
--   </pre>
brown :: (Enum e, Random n, Num n, Ord n) => e -> n -> n -> n -> [n]

-- | PdurStutter. SC3 pattern to partition a value into <i>n</i> equal
--   subdivisions. Subdivides each duration by each stutter and yields that
--   value stutter times. A stutter of <tt>0</tt> will skip the duration
--   value, a stutter of <tt>1</tt> yields the duration value unaffected.
--   
--   <pre>
--   let {s = [1,1,1,1,1,2,2,2,2,2,0,1,3,4,0]
--       ;d = [0.5,1,2,0.25,0.25]}
--   in durStutter s d == [0.5,1.0,2.0,0.25,0.25]
--   </pre>
durStutter :: Fractional a => [Int] -> [a] -> [a]

-- | Pexprand. SC3 pattern of random values that follow a exponential
--   distribution.
--   
--   <pre>
--   exprand 'α' 0.0001 1 10
--   </pre>
exprand :: (Enum e, Random a, Floating a) => e -> a -> a -> Int -> [a]

-- | Pfuncn. Variant of the SC3 pattern that evaluates a closure at each
--   step that has a <a>StdGen</a> form.
funcn :: Enum e => e -> (StdGen -> (n, StdGen)) -> Int -> [n]

-- | Pgeom. <a>geom</a> with arguments re-ordered.
--   
--   <pre>
--   geom 3 6 5 == [3,18,108,648,3888]
--   </pre>
geom :: Num a => a -> a -> Int -> [a]

-- | Pif. Consume values from <i>q</i> or <i>r</i> according to <i>p</i>.
--   
--   <pre>
--   if_demand [True,False,True] [1,3] [2] == [1,2,3]
--   </pre>
if_demand :: [Bool] -> [a] -> [a] -> [a]

-- | Prand. Random elements of <i>p</i>.
--   
--   <pre>
--   rand' 'α' [1..9] 9 == [3,9,2,9,4,7,4,3,8]
--   </pre>
rand' :: Enum e => e -> [a] -> Int -> [a]

-- | Pseq. <a>concat</a> of <a>replicate</a> of <a>concat</a>.
--   
--   <pre>
--   seq' [return 1,[2,3],return 4] 2 == [1,2,3,4,1,2,3,4]
--   </pre>
seq' :: [[a]] -> Int -> [a]

-- | Pslide. SC3 pattern to slide over a list of values.
--   
--   <pre>
--   slide [1,2,3,4] 4 3 1 0 True == [1,2,3,2,3,4,3,4,1,4,1,2]
--   slide [1,2,3,4,5] 3 3 (-1) 0 True == [1,2,3,5,1,2,4,5,1]
--   </pre>
slide :: [a] -> Int -> Int -> Int -> Int -> Bool -> [a]

-- | Pstutter. Repeat each element of a pattern <i>n</i> times.
--   
--   <pre>
--   stutter [1,2,3] [4,5,6] == [4,5,5,6,6,6]
--   stutter (repeat 2) [4,5,6] == [4,4,5,5,6,6]
--   </pre>
stutter :: [Int] -> [a] -> [a]

-- | Pswitch. SC3 pattern to select elements from a list of patterns by a
--   pattern of indices.
--   
--   <pre>
--   let r = switch [[1,2,3,1,2,3],[65,76],[800]] [2,2,0,1]
--   in r == [800,800,1,2,3,1,2,3,65,76]
--   </pre>
switch :: [[a]] -> [Int] -> [a]

-- | Pswitch1. SC3 pattern that uses a pattern of indices to select which
--   pattern to retrieve the next value from. Only one value is selected
--   from each pattern. This is in comparison to <a>switch</a>, which
--   embeds the pattern in its entirety.
--   
--   <pre>
--   let p = switch1 [(cycle [1,2,3])
--                   ,(cycle [65,76])
--                   ,repeat 8] (concat (replicate 6 [2,2,0,1]))
--   in p == [8,8,1,65,8,8,2,76,8,8,3,65,8,8,1,76,8,8,2,65,8,8,3,76]
--   </pre>
switch1 :: [[a]] -> [Int] -> [a]

-- | Pwhite. SC3 pattern to generate a uniform linear distribution in given
--   range.
--   
--   <pre>
--   white 'α' 0 9 5 == [3,0,1,6,6]
--   </pre>
--   
--   It is important to note that this structure is not actually
--   indeterminate, so that the below is zero.
--   
--   <pre>
--   white 'α' 1 9 5  == [3,9,2,9,4]
--   let p = white 'α' 0.0 1.0 3 in zipWith (-) p p == [0,0,0]
--   </pre>
white :: (Random n, Enum e) => e -> n -> n -> Int -> [n]

-- | Pwrand. SC3 pattern to embed values randomly chosen from a list.
--   Returns one item from the list at random for each repeat, the
--   probability for each item is determined by a list of weights which
--   should sum to 1.0 and must be equal in length to the selection list.
--   
--   <pre>
--   let w = C.normalizeSum [1,3,5]
--   in wrand 'ζ' [[1],[2],[3,4]] w 6 == [3,4,2,2,3,4,1,3,4]
--   </pre>
wrand :: (Enum e, Fractional n, Ord n, Random n) => e -> [[a]] -> [n] -> Int -> [a]

-- | Pxrand. SC3 pattern that is like <tt>rand</tt> but filters successive
--   duplicates.
--   
--   <pre>
--   xrand 'α' [return 1,[2,3],[4,5,6]] 9 == [4,5,6,2,3,4,5,6,1]
--   </pre>
xrand :: Enum e => e -> [[a]] -> Int -> [a]

-- | Underlying <a>if_demand</a>.
if_rec :: ([Bool], [a], [a]) -> Maybe (a, ([Bool], [a], [a]))

-- | <a>zip3</a> variant.
--   
--   <pre>
--   if_zip [True,False,True] [1,3] [2] == [1]
--   </pre>
if_zip :: [Bool] -> [a] -> [a] -> [a]

-- | Underlying <a>funcn</a>.
funcn' :: RandomGen g => g -> (g -> (n, g)) -> Int -> [n]
rorate_n' :: Num a => a -> a -> [a]
rorate_n :: Num a => [a] -> [a] -> [a]
rorate_l' :: Num a => [a] -> a -> [a]
rorate_l :: Num a => [[a]] -> [a] -> [a]

-- | <a>white</a> with pattern inputs.
--   
--   <pre>
--   white' 'α' (repeat 0) [9,19,9,19,9,19] == [3,0,1,6,6,15]
--   </pre>
white' :: (Enum e, Random n) => e -> [n] -> [n] -> [n]

-- | Type-specialised (<a>Integral</a>) <a>white</a>.
--   
--   <pre>
--   whitei' 'α' 1 9 5 == [3,9,2,9,4]
--   </pre>
whitei' :: (Random n, Integral n, Enum e) => e -> n -> n -> Int -> [n]

-- | A variant of <tt>pwhite</tt> that generates integral (rounded) values.
--   
--   <pre>
--   whitei 'α' 1 9 5 == [5,1,7,7,8]
--   </pre>
whitei :: (Random n, RealFracE n, Enum e) => e -> n -> n -> Int -> [n]

-- | Underlying <a>xrand</a>.
xrand' :: Enum e => e -> [[a]] -> [a]


-- | Pattern functions.
--   
--   Haskell: <a>pappend</a>, <a>pconcat</a>, <a>pcons</a>, <a>pcycle</a>,
--   <a>pempty</a>,<a>pfilter</a>, <a>pjoin</a>, <a>prepeat</a>,
--   <a>preplicate</a>, <a>pscanl</a>, <a>psplitPlaces</a>, <a>ptail</a>,
--   <a>ptake</a>, <a>pzip</a>, <a>pzipWith</a>.
--   
--   Non SC3: <a>pbool</a>, <a>pcountpost</a>,
--   <a>pcountpre</a>,<a>phold</a>, <a>pinterleave</a>, <a>prsd</a>,
--   <a>ptrigger</a>.
module Sound.SC3.Lang.Pattern.P.Base

-- | Type specialised <a>maxBound</a>, a pseudo-<i>infinite</i> value for
--   use at pattern repeat counts.
--   
--   <pre>
--   inf == maxBound
--   </pre>
inf :: Int

-- | Constant <i>NaN</i> (not a number) value.
--   
--   <pre>
--   isNaN nan == True
--   </pre>
--   
--   A frequency value of NaN indicates a rest. This constant value can be
--   used as a rest indicator at a frequency model input (not at a
--   <tt>rest</tt> key).
--   
--   <pre>
--   audition (pbind [(K_dur,pseq [0.1,0.7] inf)
--                   ,(K_legato,0.2)
--                   ,(K_degree,pseq [0,2,return nan] inf)])
--   </pre>
nan :: Floating a => a

-- | Pattern variant of <a>:</a>.
--   
--   <pre>
--   pcons 'α' (pn (return 'β') 2) == toP "αββ"
--   </pre>
pcons :: a -> P a -> P a

-- | Pattern variant of <a>null</a>.
--   
--   <pre>
--   pnull mempty == True
--   pnull (undecided 'a') == False
--   pnull (pure 'a') == False
--   pnull (return 'a') == False
--   </pre>
pnull :: P a -> Bool

-- | Alias for <a>pure</a>, pattern variant of <a>repeat</a>.
--   
--   <pre>
--   ptake 5 (prepeat 3) == toP [3,3,3,3,3]
--   ptake 5 (pure 3) == toP [3,3,3,3,3]
--   take 5 (pure 3) == [3]
--   </pre>
prepeat :: a -> P a

-- | Pattern variant of <a>splitAt</a>.
psplitAt :: Int -> P a -> (P a, P a)

-- | Pattern variant of <a>splitPlaces</a>.
--   
--   <pre>
--   psplitPlaces' (toP [1,2,3]) (pseries 1 1 6) == toP [[1],[2,3],[4,5,6]]
--   psplitPlaces' (toP [1,2,3]) (toP ['a'..]) == toP ["a","bc","def"]
--   </pre>
psplitPlaces' :: P Int -> P a -> P [a]

-- | <a>fmap</a> <a>toP</a> of <a>psplitPlaces'</a>.
--   
--   <pre>
--   psplitPlaces (toP [1,2,3]) (toP ['a'..]) == toP (map toP ["a","bc","def"])
--   </pre>
psplitPlaces :: P Int -> P a -> P (P a)

-- | Pattern variant of <a>take_inf</a>, see also <tt>pfinval</tt>.
--   
--   <pre>
--   ptake 5 (pseq [1,2,3] 2) == toP [1,2,3,1,2]
--   ptake 5 (toP [1,2,3]) == toP [1,2,3]
--   ptake 5 (pseq [1,2,3] inf) == toP [1,2,3,1,2]
--   ptake 5 (pwhite 'α' 0 5 inf) == toP [5,2,1,2,0]
--   </pre>
--   
--   Note that <a>ptake</a> does not extend the input pattern, unlike
--   <tt>pser</tt>.
--   
--   <pre>
--   ptake 5 (toP [1,2,3]) == toP [1,2,3]
--   pser [1,2,3] 5 == toP [1,2,3,1,2]
--   </pre>
ptake :: Int -> P a -> P a

-- | Type specialised <a>mcycle</a>.
--   
--   <pre>
--   ptake 5 (pcycle 1) == preplicate 5 1
--   ptake 5 (pcycle (pure 1)) == preplicate 5 1
--   ptake 5 (pcycle (return 1)) == preplicate 5 1
--   </pre>
pcycle :: P a -> P a

-- | Type specialised <a>mfilter</a>. Aliased to <tt>pselect</tt>. See also
--   <tt>preject</tt>.
--   
--   <pre>
--   mfilter even (pseq [1,2,3] 2) == toP [2,2]
--   mfilter (&lt; 3) (pseq [1,2,3] 2) == toP [1,2,1,2]
--   </pre>
pfilter :: (a -> Bool) -> P a -> P a

-- | Pattern variant of <a>replicate</a>.
--   
--   <pre>
--   preplicate 4 1 == toP [1,1,1,1]
--   </pre>
--   
--   Compare to <tt>pn</tt>:
--   
--   <pre>
--   pn 1 4 == toP [1,1,1,1]
--   pn (toP [1,2]) 3 == toP [1,2,1,2,1,2]
--   preplicate 4 (toP [1,2]) :: P (P Int)
--   </pre>
preplicate :: Int -> a -> P a

-- | Pattern variant of <a>scanl</a>. <a>scanl</a> is similar to
--   <a>foldl</a>, but returns a list of successive reduced values from the
--   left. pscanl is an accumulator, it provides a mechanism for state to
--   be threaded through a pattern. It can be used to write a function to
--   remove succesive duplicates from a pattern, to count the distance
--   between occurences of an element in a pattern and so on.
--   
--   <pre>
--   F.foldl (\x y -&gt; 2 * x + y) 4 (pseq [1,2,3] 1) == 43
--   pscanl (\x y -&gt; 2 * x + y) 4 (pseq [1,2,3] 1) == toP [4,9,20,43]
--   </pre>
--   
--   <pre>
--   F.foldl (flip (:)) [] (toP [1..3]) == [3,2,1]
--   pscanl (flip (:)) [] (toP [1..3]) == toP [[],[1],[2,1],[3,2,1]]
--   </pre>
--   
--   <pre>
--   F.foldl (+) 0 (toP [1..5]) == 15
--   pscanl (+) 0 (toP [1..5]) == toP [0,1,3,6,10,15]
--   </pre>
pscanl :: (a -> b -> a) -> a -> P b -> P a

-- | <tt>pdrop</tt> <tt>1</tt>. Pattern variant of <a>tail</a>. Drops first
--   element from pattern. Note that the haskell <a>tail</a> function is
--   partial, although <a>drop</a> is not. <a>ptake</a> is equal to `pdrop
--   1`.
--   
--   <pre>
--   tail [] == _|_
--   drop 1 [] == []
--   </pre>
--   
--   <pre>
--   ptail (toP [1,2]) == toP [2]
--   ptail mempty == mempty
--   </pre>
ptail :: P a -> P a

-- | Variant of <a>transpose</a>.
--   
--   <pre>
--   L.transpose [[1,2],[3,4,5]] == [[1,3],[2,4],[5]]
--   ptranspose [toP [1,2],toP [3,4,5]] == toP [[1,3],[2,4],[5]]
--   </pre>
--   
--   <pre>
--   let p = ptranspose [pseq [1,2] inf,pseq [4,5] inf]
--   in ptake 2 (pdrop (2^16) p) == toP [[1,4],[2,5]]
--   </pre>
ptranspose :: [P a] -> P [a]

-- | An <i>implicitly repeating</i> pattern variant of <a>transpose_st</a>.
ptranspose_st_repeat :: [P a] -> P [a]

-- | Type specialised <a>fbool</a>.
pbool :: (Ord a, Num a) => P a -> P Bool

-- | <a>mconcat</a> of <a>replicate</a>.
pconcatReplicate :: Int -> P a -> P a

-- | Lifted <a>countpost</a>.
pcountpost :: P Bool -> P Int

-- | Lifted <a>countpre</a>.
pcountpre :: P Bool -> P Int

-- | Lifted <a>hold</a>.
phold :: P a -> P a

-- | Lifted <a>interleave2</a>.
--   
--   <pre>
--   let p = pinterleave2 (pwhite 'α' 1 9 inf) (pseries 10 1 5)
--   in [3,10,9,11,2,12,9,13,4,14] `L.isPrefixOf` unP p
--   </pre>
pinterleave2 :: P a -> P a -> P a

-- | Lifted <a>interleave</a>.
--   
--   <pre>
--   pinterleave [pwhitei 'α' 0 4 3,pwhitei 'β' 5 9 3] == toP [2,7,0,5,3,6]
--   </pre>
pinterleave :: [P a] -> P a

-- | Lifted <a>isPrefixOf</a>.
pisPrefixOf :: Eq a => P a -> P a -> Bool

-- | Lifted <a>rsd</a>.
--   
--   <pre>
--   prsd (pstutter 2 (toP [1,2,3])) == toP [1,2,3]
--   prsd (pseq [1,2,3] 2) == toP [1,2,3,1,2,3]
--   </pre>
prsd :: Eq a => P a -> P a

-- | Lifted <a>trigger</a>.
--   
--   <pre>
--   let {tr = pbool (toP [0,1,0,0,1,1])
--       ;p = ptrigger tr (toP [1,2,3])
--       ;r = [Nothing,Just 1,Nothing,Nothing,Just 2,Just 3]}
--   in p == toP r
--   </pre>
ptrigger :: P Bool -> P a -> P (Maybe a)

-- | Type specialised <a>mappend</a>, sequences two patterns, ie.
--   <a>++</a>.
--   
--   <pre>
--   1 &lt;&gt; mempty &lt;&gt; 2 == toP [1,2]
--   </pre>
--   
--   <pre>
--   let {p = prand 'α' [0,1] 3
--       ;q = prand 'β' [5,7] 3}
--   in audition (pbind [(K_degree,pappend p q),(K_dur,0.15)])
--   </pre>
pappend :: P a -> P a -> P a

-- | Type specialised <a>mconcat</a> (or equivalently <a>msum</a> or
--   <a>concat</a>).
--   
--   <pre>
--   mconcat [pseq [1,2] 1,pseq [3,4] 2] == toP [1,2,3,4,3,4]
--   msum [pseq [1,2] 1,pseq [3,4] 2] == toP [1,2,3,4,3,4]
--   </pre>
pconcat :: [P a] -> P a

-- | Type specialised <a>mempty</a>, ie. 'Data.List.[]'.
pempty :: P a

-- | Type specialised <a>foldr</a>.
--   
--   <pre>
--   &gt; (Pser([1,2,3],5) + Pseq([0,10],3)).asStream.all == [1,12,3,11,2]
--   </pre>
--   
--   <pre>
--   let p = pser [1,2,3] 5 + pseq [0,10] 3
--   in F.foldr (:) [] p == [1,12,3,11,2]
--   </pre>
--   
--   Indefinte patterns may be folded.
--   
--   <pre>
--   take 3 (F.foldr (:) [] (prepeat 1)) == [1,1,1]
--   </pre>
--   
--   The <tt>Foldable</tt> module includes functions for <a>product</a>,
--   <a>sum</a>, <a>any</a>, <a>elem</a> etc.
--   
--   <pre>
--   F.product (toP [1,3,5]) == 15
--   floor (F.sum (ptake 100 (pwhite 'α' 0.25 0.75 inf))) == 51
--   F.any even (toP [1,3,5]) == False
--   F.elem 5 (toP [1,3,5]) == True
--   </pre>
pfoldr :: (a -> b -> b) -> b -> P a -> b

-- | Type specialised <a>join</a>.
--   
--   <pre>
--   join (replicate 2 [1,2]) == [1,2,1,2]
--   join (preplicate 2 (toP [1,2])) == toP [1,2,1,2]
--   </pre>
pjoin :: P (P a) -> P a

-- | <a>join</a> that pushes an outer <a>undecided</a> inward.
--   
--   <pre>
--   join (undecided (undecided 1)) == undecided 1
--   join (undecided (return 1)) == return 1
--   pjoin_repeat (undecided (return 1)) == pure 1 == _|_
--   </pre>
pjoin_repeat :: P (P a) -> P a

-- | Type specialised <a>fmap</a>, ie. <a>map</a>.
pmap :: (a -> b) -> P a -> P b

-- | Type specialised <a>&gt;&gt;=</a>.
--   
--   <pre>
--   (return 1 &gt;&gt;= return . id) == [1]
--   (undecided 1 &gt;&gt;= undecided . id) == undecided 1
--   </pre>
--   
--   <pre>
--   (pseq [1,2] 1 &gt;&gt;= \x -&gt;
--     pseq [3,4,5] 1 &gt;&gt;= \y -&gt;
--      return (x,y)) == toP [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
--   </pre>
pmbind :: P a -> (a -> P b) -> P b

-- | Type specialised <a>pure</a>.
ppure :: a -> P a

-- | Type specialised <a>return</a>.
preturn :: a -> P a

-- | Type specialised <a>traverse</a>.
--   
--   <pre>
--   let {f i e = (i + e,e * 2)
--       ;(r,p) = T.mapAccumL f 0 (toP [1,3,5])}
--   in (r,p) == (9,toP [2,6,10])
--   </pre>
ptraverse :: Applicative f => (a -> f b) -> P a -> f (P b)

module Sound.SC3.Lang.Pattern.Plain


-- | <tt>sclang</tt> value pattern functions.
--   
--   SC3 <i>value</i> patterns: <a>pbrown</a> (Pbrown), <a>pclutch</a>
--   (Pclutch), <a>pcollect</a> (Pcollect), <a>pconst</a> (Pconst),
--   <a>pdegreeToKey</a> (PdegreeToKey), <a>pdiff</a> (Pdiff), <a>pdrop</a>
--   (Pdrop), <a>pdurStutter</a> (PdurStutter), <a>pexprand</a> (Pexprand),
--   <a>pfinval</a> (Pfinval), <a>pfuncn</a> (Pfuncn), <a>pgeom</a>
--   (Pgeom), <a>pif</a> (Pif), <a>place</a> (Place), <a>pn</a> (Pn),
--   <a>ppatlace</a> (Ppatlace), <a>prand</a> (Prand), <a>preject</a>
--   (Preject), <a>prorate</a> (Prorate), <a>pselect</a> (Pselect),
--   <a>pseq</a> (Pseq), <a>pser</a> (Pser), <a>pseries</a> (Pseries),
--   <a>pshuf</a> (Pshuf), <a>pslide</a> (Pslide), <a>pstutter</a>
--   (Pstutter), <a>pswitch1</a> (Pswitch1), <a>pswitch</a> (Pswitch),
--   <a>ptuple</a> (Ptuple), <a>pwhite</a> (Pwhite), <a>pwrand</a>
--   (Pwrand), <a>pwrap</a> (Pwrap), <a>pxrand</a> (Pxrand).
--   
--   SC3 variant patterns: <a>pbrown</a>', <a>prand'</a>, <a>prorate'</a>,
--   <a>pseq1</a>, <a>pseqn</a>, <a>pser1</a>, <a>pseqr</a>,
--   <a>pwhite'</a>, <a>pwhitei</a>.
--   
--   SC3 collection patterns: <a>pfold</a>
module Sound.SC3.Lang.Pattern.P.SC3

-- | Variant of <a>flop</a>.
--   
--   <pre>
--   pflop' [toP [1,2],toP [3,4,5]] == toP [[1,3],[2,4],[1,5]]
--   pflop' [toP [1,2],3] == toP [[1,3],[2,3]]
--   pflop' [pseq [1,2] 1,pseq [3,4] inf]
--   </pre>
pflop' :: [P a] -> P [a]

-- | <a>fmap</a> <a>toP</a> of <a>pflop'</a>.
--   
--   <pre>
--   C.flop [[1,2],[3,4,5]] == [[1,3],[2,4],[1,5]]
--   pflop [toP [1,2],toP [3,4,5]] == toP (map toP [[1,3],[2,4],[1,5]])
--   </pre>
pflop :: [P a] -> P (P a)

-- | Type specialised <a>ffold</a>.
--   
--   <pre>
--   pfold (toP [10,11,12,-6,-7,-8]) (-7) 11 == toP [10,11,10,-6,-7,-6]
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pfold (pseries 4 1 inf) (-7) 11)
--                   ,(K_dur,0.0625)])
--   </pre>
--   
--   The underlying primitive is then <a>fold_</a> function.
--   
--   <pre>
--   let f = fmap (\n -&gt; fold_ n (-7) 11)
--   in audition (pbind [(K_degree,f (pseries 4 1 inf))
--                      ,(K_dur,0.0625)])
--   </pre>
pfold :: RealFrac n => P n -> n -> n -> P n

-- | Pattern variant of <a>normalizeSum</a>.
pnormalizeSum :: Fractional n => P n -> P n

-- | Pbrown. Lifted <a>brown</a>. SC3 pattern to generate psuedo-brownian
--   motion.
--   
--   <pre>
--   pbrown 'α' 0 9 1 5 == toP [4,4,5,4,3]
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_dur,0.065)
--                   ,(K_freq,pbrown 'α' 440 880 20 inf)])
--   </pre>
pbrown :: (Enum e, Random n, Num n, Ord n) => e -> n -> n -> n -> Int -> P n

-- | Pclutch. SC3 sample and hold pattern. For true values in the control
--   pattern, step the value pattern, else hold the previous value.
--   
--   <pre>
--   &gt; c = Pseq([1,0,1,0,0,1,1],inf);
--   &gt; p = Pclutch(Pser([1,2,3,4,5],8),c);
--   &gt; r = [1,1,2,2,2,3,4,5,5,1,1,1,2,3];
--   &gt; p.asStream.all == r
--   </pre>
--   
--   <pre>
--   let {c = pbool (pseq [1,0,1,0,0,1,1] inf)
--       ;p = pclutch (pser [1,2,3,4,5] 8) c
--       ;r = toP [1,1,2,2,2,3,4,5,5,1,1,1,2,3]}
--   in p == toP [1,1,2,2,2,3,4,5,5,1,1,1,2,3]
--   </pre>
--   
--   Note the initialization behavior, nothing is generated until the first
--   true value.
--   
--   <pre>
--   let {p = pseq [1,2,3,4,5] 1
--       ;q = pbool (pseq [0,0,0,0,0,0,1,0,0,1,0,1] 1)}
--   in pclutch p q == toP [1,1,1,2,2,3]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pstutter(Pwhite(3,10,inf),Pwhite(-4,11,inf)),
--   &gt;       \dur,Pclutch(Pwhite(0.1,0.4,inf),
--   &gt;                    Pdiff(Pkey(\degree)).abs &gt; 0),
--   &gt;       \legato,0.3).play;
--   </pre>
--   
--   <pre>
--   let {d = pstutter (pwhite 'α' 3 10 inf) (pwhitei 'β' (-4) 11 inf)
--       ;p = [(K_degree,d)
--            ,(K_dur,pclutch (pwhite 'γ' 0.1 0.4 inf)
--                            (pbool (abs (pdiff d) &gt;* 0)))
--            ,(K_legato,0.3)]}
--   in audition (pbind p)
--   </pre>
pclutch :: P a -> P Bool -> P a

-- | Pcollect. SC3 name for <a>fmap</a>, ie. patterns are functors.
--   
--   <pre>
--   &gt; Pcollect({|i| i * 3},Pseq(#[1,2,3],1)).asStream.all == [3,6,9]
--   pcollect (* 3) (toP [1,2,3]) == toP [3,6,9]
--   </pre>
--   
--   <pre>
--   &gt; Pseq(#[1,2,3],1).collect({|i| i * 3}).asStream.all == [3,6,9]
--   fmap (* 3) (toP [1,2,3]) == toP [3,6,9]
--   </pre>
pcollect :: (a -> b) -> P a -> P b

-- | Pconst. SC3 pattern to constrain the sum of a numerical pattern. Is
--   equal to <i>p</i> until the accumulated sum is within <i>t</i> of
--   <i>n</i>. At that point, the difference between the specified sum and
--   the accumulated sum concludes the pattern.
--   
--   <pre>
--   &gt; p = Pconst(10,Pseed(Pn(1000,1),Prand([1,2,0.5,0.1],inf),0.001));
--   &gt; p.asStream.all == [0.5,0.1,0.5,1,2,2,0.5,1,0.5,1,0.9]
--   </pre>
--   
--   <pre>
--   let p = pconst 10 (prand 'α' [1,2,0.5,0.1] inf) 0.001
--   in (p,Data.Foldable.sum p)
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pseq([-7,Pwhite(0,11,inf)],1),
--   &gt;       \dur,Pconst(4,Pwhite(1,4,inf) * 0.25)).play
--   </pre>
--   
--   <pre>
--   let p = [(K_degree,pcons (-7) (pwhitei 'α' 0 11 inf))
--           ,(K_dur,pconst 4 (pwhite 'β' 1 4 inf * 0.25) 0.001)]
--   in audition (pbind p)
--   </pre>
pconst :: (Ord a, Num a) => a -> P a -> a -> P a

-- | PdegreeToKey. SC3 pattern to derive notes from an index into a scale.
--   
--   <pre>
--   let {p = pseq [0,1,2,3,4,3,2,1,0,2,4,7,4,2] 2
--       ;q = pure [0,2,4,5,7,9,11]
--       ;r = [0,2,4,5,7,5,4,2,0,4,7,12,7,4,0,2,4,5,7,5,4,2,0,4,7,12,7,4]}
--   in pdegreeToKey p q (pure 12) == toP r
--   </pre>
--   
--   <pre>
--   let {p = pseq [0,1,2,3,4,3,2,1,0,2,4,7,4,2] 2
--       ;q = pseq (map return [[0,2,4,5,7,9,11],[0,2,3,5,7,8,11]]) 1
--       ;r = [0,2,4,5,7,5,4,2,0,4,7,12,7,4,0,2,3,5,7,5,3,2,0,3,7,12,7,3]}
--   in pdegreeToKey p (pstutter 14 q) (pure 12) == toP r
--   </pre>
--   
--   This is the pattern variant of <a>degreeToKey</a>.
--   
--   <pre>
--   let s = [0,2,4,5,7,9,11]
--   in map (M.degreeToKey s 12) [0,2,4,7,4,2,0] == [0,4,7,12,7,4,0]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\note,PdegreeToKey(Pseq([1,2,3,2,5,4,3,4,2,1],2),
--   &gt;                          #[0,2,3,6,7,9],
--   &gt;                          12),\dur,0.25).play
--   </pre>
--   
--   <pre>
--   let {n = pdegreeToKey (pseq [1,2,3,2,5,4,3,4,2,1] 2)
--                         (pure [0,2,3,6,7,9])
--                         12}
--   in audition (pbind [(K_note,n),(K_dur,0.25)])
--   </pre>
--   
--   <pre>
--   &gt; s = #[[0,2,3,6,7,9],[0,1,5,6,7,9,11],[0,2,3]];
--   &gt; d = [1,2,3,2,5,4,3,4,2,1];
--   &gt; Pbind(\note,PdegreeToKey(Pseq(d,4),
--   &gt;                          Pstutter(3,Prand(s,inf)),
--   &gt;                          12),\dur,0.25).play;
--   </pre>
--   
--   <pre>
--   let {s = map return [[0,2,3,6,7,9],[0,1,5,6,7,9,11],[0,2,3]]
--       ;d = [1,2,3,2,5,4,3,4,2,1]
--       ;k = pdegreeToKey (pseq d 4)
--                         (pstutter 3 (prand 'α' s 14))
--                         (pn 12 40)}
--   in audition (pbind [(K_note,k),(K_dur,0.25)])
--   </pre>
pdegreeToKey :: RealFrac a => P a -> P [a] -> P a -> P a

-- | Pdiff. SC3 pattern to calculate adjacent element difference.
--   
--   <pre>
--   &gt; Pdiff(Pseq([0,2,3,5,6,8,9],1)).asStream.all == [2,1,2,1,2,1]
--   pdiff (pseq [0,2,3,5,6,8,9] 1) == toP [2,1,2,1,2,1]
--   </pre>
pdiff :: Num n => P n -> P n

-- | Pdrop. Lifted <a>drop</a>.
--   
--   <pre>
--   &gt; p = Pseries(1,1,20).drop(5);
--   &gt; p.asStream.all == [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
--   </pre>
--   
--   <pre>
--   pdrop 5 (pseries 1 1 10) == toP [6,7,8,9,10]
--   pdrop 1 mempty == mempty
--   </pre>
pdrop :: Int -> P a -> P a

-- | PdurStutter. Lifted <a>durStutter</a>.
--   
--   <pre>
--   &gt; s = Pseq(#[1,1,1,1,1,2,2,2,2,2,0,1,3,4,0],inf);
--   &gt; d = Pseq(#[0.5,1,2,0.25,0.25],1);
--   &gt; PdurStutter(s,d).asStream.all == [0.5,1,2,0.25,0.25]
--   </pre>
--   
--   <pre>
--   let {s = pseq [1,1,1,1,1,2,2,2,2,2,0,1,3,4,0] inf
--       ;d = pseq [0.5,1,2,0.25,0.25] 1}
--   in pdurStutter s d == toP [0.5,1.0,2.0,0.25,0.25]
--   </pre>
--   
--   Applied to duration.
--   
--   <pre>
--   &gt; d = PdurStutter(Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4],inf),
--   &gt;                 Pseq(#[0.5,1,2,0.25,0.25],inf));
--   &gt; Pbind(\freq,440,\dur,d).play
--   </pre>
--   
--   <pre>
--   let {s = pseq [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4] inf
--       ;d = pseq [0.5,1,2,0.25,0.25] inf}
--   in audition (pbind [(K_freq,440),(K_dur,pdurStutter s d)])
--   </pre>
--   
--   Applied to frequency.
--   
--   <pre>
--   let {s = pseq [1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4] inf
--       ;d = pseq [0,2,3,5,7,9,10] inf + 80}
--   in audition (pbind [(K_midinote,pdurStutter s d),(K_dur,0.15)])
--   </pre>
pdurStutter :: Fractional a => P Int -> P a -> P a

-- | Pexprand. Lifted <a>exprand</a>.
--   
--   <pre>
--   &gt; Pexprand(0.0001,1,10).asStream.all
--   pexprand 'α' 0.0001 1 10
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\freq,Pexprand(0.0001,1,inf) * 600 + 300,\dur,0.02).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_freq,pexprand 'α' 0.0001 1 inf * 600 + 300)
--                   ,(K_dur,0.02)])
--   </pre>
pexprand :: (Enum e, Random a, Floating a) => e -> a -> a -> Int -> P a

-- | Pfinval. Alias for <a>ptake</a>
--   
--   <pre>
--   &gt; Pfinval(5,Pseq(#[1,2,3],inf)).asStream.all == [1,2,3,1,2]
--   pfinval 5 (pseq [1,2,3] inf) == toP [1,2,3,1,2]
--   </pre>
pfinval :: Int -> P a -> P a

-- | A variant of the SC3 pattern that evaluates a closure at each step.
--   The haskell variant function has a <a>StdGen</a> form.
--   
--   <pre>
--   &gt; p = Pfuncn({exprand(0.1,0.3) + #[1,2,3,6,7].choose},inf);
--   &gt; Pbind(\freq,p * 100 + 300,\dur,0.02).play
--   </pre>
--   
--   <pre>
--   let {exprand = Sound.SC3.Lang.Random.Gen.exprand
--       ;choose = Sound.SC3.Lang.Random.Gen.choose
--       ;p = pfuncn 'α' (exprand 0.1 0.3) inf
--       ;q = pfuncn 'β' (choose [1,2,3,6,7]) inf}
--   in audition (pbind [(K_freq,(p + q) * 100 + 300),(K_dur,0.02)])
--   </pre>
--   
--   Of course in this case there is a pattern equivalent.
--   
--   <pre>
--   let {p = pexprand 'α' 0.1 0.3 inf + prand 'β' [1,2,3,6,7] inf}
--   in audition (pbind [(K_freq,p * 100 + 300),(K_dur,0.02)])
--   </pre>
pfuncn :: Enum e => e -> (StdGen -> (n, StdGen)) -> Int -> P n

-- | Pgeom. SC3 geometric series pattern.
--   
--   <pre>
--   &gt; Pgeom(3,6,5).asStream.all == [3,18,108,648,3888]
--   pgeom 3 6 5 == toP [3,18,108,648,3888]
--   </pre>
--   
--   <pre>
--   &gt; Pgeom(1,2,10).asStream.all == [1,2,4,8,16,32,64,128,256,512]
--   pgeom 1 2 10 == toP [1,2,4,8,16,32,64,128,256,512]
--   </pre>
--   
--   Real numbers work as well.
--   
--   <pre>
--   &gt; p = Pgeom(1.0,1.1,6).collect({|i| (i * 100).floor});
--   &gt; p.asStream.all == [100,110,121,133,146,161];
--   </pre>
--   
--   <pre>
--   let p = fmap (floor . (* 100)) (pgeom 1.0 1.1 6)
--   in p == toP [100,110,121,133,146,161]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pseries(-7,1,15),
--   &gt;       \dur,Pgeom(0.5,0.89140193218427,15)).play;
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pseries (-7) 1 15)
--                   ,(K_dur,pgeom 0.5 0.89140193218427 15)])
--   </pre>
--   
--   There is a list variant.
--   
--   <pre>
--   &gt; 5.geom(3,6)
--   C.geom 5 3 6 == [3,18,108,648,3888]
--   </pre>
pgeom :: Num a => a -> a -> Int -> P a

-- | Pif. SC3 <i>implicitly repeating</i> pattern-based conditional
--   expression.
--   
--   <pre>
--   &gt; a = Pfunc({0.3.coin});
--   &gt; b = Pwhite(0,9,3);
--   &gt; c = Pwhite(10,19,3);
--   &gt; Pfin(9,Pif(a,b,c)).asStream.all
--   </pre>
--   
--   <pre>
--   let {a = fmap (&lt; 0.75) (pwhite 'α' 0.0 1.0 inf)
--       ;b = pwhite 'β' 0 9 6
--       ;c = pwhite 'γ' 10 19 6}
--   in pif a b c * (-1) == toP [-7,-3,-11,-17,-18,-6,-3,-4,-5]
--   </pre>
pif :: P Bool -> P a -> P a -> P a

-- | Place. SC3 interlaced embedding of subarrays.
--   
--   <pre>
--   &gt; Place([0,[1,2],[3,4,5]],3).asStream.all == [0,1,3,0,2,4,0,1,5]
--   C.lace 9 [[0],[1,2],[3,4,5]] == [0,1,3,0,2,4,0,1,5]
--   place [[0],[1,2],[3,4,5]] 3 == toP [0,1,3,0,2,4,0,1,5]
--   </pre>
--   
--   <pre>
--   &gt; Place(#[1,[2,5],[3,6]],2).asStream.all == [1,2,3,1,5,6]
--   C.lace 6 [[1],[2,5],[3,6]] == [1,2,3,1,5,6]
--   place [[1],[2,5],[3,6]] 2 == toP [1,2,3,1,5,6]
--   </pre>
--   
--   <pre>
--   C.lace 12 [[1],[2,5],[3,6..]] == [1,2,3,1,5,6,1,2,9,1,5,12]
--   place [[1],[2,5],[3,6..]] 4 == toP [1,2,3,1,5,6,1,2,9,1,5,12]
--   </pre>
place :: [[a]] -> Int -> P a

-- | Pn. SC3 pattern to repeat the enclosed pattern a number of times.
--   
--   <pre>
--   pn 1 4 == toP [1,1,1,1]
--   pn (toP [1,2,3]) 3 == toP [1,2,3,1,2,3,1,2,3]
--   </pre>
--   
--   This is related to <a>concat</a>.<a>replicate</a> in standard list
--   processing.
--   
--   <pre>
--   concat (replicate 4 [1]) == [1,1,1,1]
--   concat (replicate 3 [1,2,3]) == [1,2,3,1,2,3,1,2,3]
--   </pre>
--   
--   There is a <a>pconcatReplicate</a> near-alias (reversed argument
--   order).
--   
--   <pre>
--   pconcatReplicate 4 1 == toP [1,1,1,1]
--   pconcatReplicate 3 (toP [1,2]) == toP [1,2,1,2,1,2]
--   </pre>
--   
--   This is productive over infinite lists.
--   
--   <pre>
--   concat (replicate inf [1])
--   pconcat (replicate inf 1)
--   pconcatReplicate inf 1
--   </pre>
pn :: P a -> Int -> P a

-- | Ppatlace. SC3 <i>implicitly repeating</i> pattern to lace input
--   patterns.
--   
--   <pre>
--   &gt; p = Ppatlace([1,Pseq([2,3],2),4],5);
--   &gt; p.asStream.all == [1,2,4,1,3,4,1,2,4,1,3,4,1,4]
--   </pre>
--   
--   <pre>
--   ppatlace [1,pseq [2,3] 2,4] 5 == toP [1,2,4,1,3,4,1,2,4,1,3,4,1,4]
--   </pre>
--   
--   <pre>
--   &gt; p = Ppatlace([1,Pseed(Pn(1000,1),Prand([2,3],inf))],5);
--   &gt; p.asStream.all == [1,3,1,3,1,3,1,2,1,2]
--   </pre>
--   
--   <pre>
--   ppatlace [1,prand 'α' [2,3] inf] 5 == toP [1,3,1,2,1,3,1,2,1,2]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Ppatlace([Pseries(0,1,8),Pseries(2,1,7)],inf),
--   &gt;       \dur,0.25).play;
--   </pre>
--   
--   <pre>
--   let p = [(K_degree,ppatlace [pseries 0 1 8,pseries 2 1 7] inf)
--           ,(K_dur,0.125)]
--   in audition (pbind p)
--   </pre>
ppatlace :: [P a] -> Int -> P a

-- | Prand. SC3 pattern to make n random selections from a list of
--   patterns, the resulting pattern is flattened (joined).
--   
--   <pre>
--   &gt; p = Pseed(Pn(1000,1),Prand([1,Pseq([10,20,30]),2,3,4,5],6));
--   &gt; p.asStream.all == [3,5,3,10,20,30,2,2]
--   </pre>
--   
--   <pre>
--   prand 'α' [1,toP [10,20],2,3,4,5] 5 == toP [5,2,10,20,2,1]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\note,Prand([0,1,5,7],inf),\dur,0.25).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_note,prand 'α' [0,1,5,7] inf),(K_dur,0.25)])
--   </pre>
--   
--   Nested sequences of pitches:
--   
--   <pre>
--   &gt; Pbind(\midinote,Prand([Pseq(#[60,61,63,65,67,63]),
--   &gt;                        Prand(#[72,73,75,77,79],6),
--   &gt;                        Pshuf(#[48,53,55,58],2)],inf),
--   &gt;       \dur,0.25).play
--   </pre>
--   
--   <pre>
--   let {n = prand 'α' [pseq [60,61,63,65,67,63] 1
--                      ,prand 'β' [72,73,75,77,79] 6
--                      ,pshuf 'γ' [48,53,55,58] 2] inf}
--   in audition (pbind [(K_midinote,n),(K_dur,0.075)])
--   </pre>
--   
--   The below cannot be written as intended with the list based pattern
--   library. This is precisely because the noise patterns are values, not
--   processes with a state threaded non-locally.
--   
--   <pre>
--   do {n0 &lt;- Sound.SC3.Lang.Random.IO.rrand 2 5
--      ;n1 &lt;- Sound.SC3.Lang.Random.IO.rrand 3 9
--      ;let p = pseq [prand 'α' [pempty,pseq [24,31,36,43,48,55] 1] 1
--                    ,pseq [60,prand 'β' [63,65] 1
--                          ,67,prand 'γ' [70,72,74] 1] n0
--                    ,prand 'δ' [74,75,77,79,81] n1] inf
--       in return (ptake 24 p)}
--   </pre>
prand :: Enum e => e -> [P a] -> Int -> P a

-- | Preject. SC3 pattern to rejects values for which the predicate is
--   true. reject f is equal to filter (not . f).
--   
--   <pre>
--   preject (== 1) (pseq [1,2,3] 2) == toP [2,3,2,3]
--   pfilter (not . (== 1)) (pseq [1,2,3] 2) == toP [2,3,2,3]
--   </pre>
--   
--   <pre>
--   &gt; p = Pseed(Pn(1000,1),Pwhite(0,255,20).reject({|x| x.odd}));
--   &gt; p.asStream.all == [224,60,88,94,42,32,110,24,122,172]
--   </pre>
--   
--   <pre>
--   preject odd (pwhite 'α' 0 255 10) == toP [32,158,62,216,240,20]
--   </pre>
--   
--   <pre>
--   &gt; p = Pseed(Pn(1000,1),Pwhite(0,255,20).select({|x| x.odd}));
--   &gt; p.asStream.all == [151,157,187,129,45,245,101,79,77,243]
--   </pre>
--   
--   <pre>
--   pselect odd (pwhite 'α' 0 255 10) == toP [241,187,119,127]
--   </pre>
preject :: (a -> Bool) -> P a -> P a

-- | Prorate. SC3 <i>implicitly repeating</i> sub-dividing pattern.
--   
--   <pre>
--   &gt; p = Prorate(Pseq([0.35,0.5,0.8]),1);
--   &gt; p.asStream.all == [0.35,0.65,0.5,0.5,0.8,0.2];
--   </pre>
--   
--   <pre>
--   let p = prorate (fmap Left (pseq [0.35,0.5,0.8] 1)) 1
--   in fmap roundE (p * 100) == toP [35,65,50,50,80,20]
--   </pre>
--   
--   <pre>
--   &gt; p = Prorate(Pseq([0.35,0.5,0.8]),Pseed(Pn(100,1),Prand([20,1],inf)));
--   &gt; p.asStream.all == [7,13,0.5,0.5,16,4]
--   </pre>
--   
--   <pre>
--   let p = prorate (fmap Left (pseq [0.35,0.5,0.8] 1))
--                   (prand 'α' [20,1] 3)
--   in fmap roundE (p * 100) == toP [35,65,1000,1000,80,20]
--   </pre>
--   
--   <pre>
--   &gt; l = [[1,2],[5,7],[4,8,9]].collect(_.normalizeSum);
--   &gt; Prorate(Pseq(l,1)).asStream.all
--   </pre>
--   
--   <pre>
--   let l = map (Right . C.normalizeSum) [[1,2],[5,7],[4,8,9]]
--   in prorate (toP l) 1
--   </pre>
--   
--   <pre>
--   &gt; Pfinval(5,Prorate(0.6,0.5)).asStream.all == [0.3,0.2,0.3,0.2,0.3]
--   </pre>
--   
--   <pre>
--   pfinval 5 (prorate (fmap Left 0.6) 0.5) == toP [0.3,0.2,0.3,0.2,0.3]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pseries(4,1,inf).fold(-7,11),
--   &gt;       \dur,Prorate(0.6,0.5)).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pfold (pseries 4 1 inf) (-7) 11)
--                   ,(K_dur,prorate (fmap Left 0.6) 0.25)])
--   </pre>
prorate :: Num a => P (Either a [a]) -> P a -> P a

-- | Pselect. See <a>pfilter</a>.
--   
--   <pre>
--   pselect (&lt; 3) (pseq [1,2,3] 2) == toP [1,2,1,2]
--   </pre>
pselect :: (a -> Bool) -> P a -> P a

-- | Pseq. SC3 pattern to cycle over a list of patterns. The repeats
--   pattern gives the number of times to repeat the entire list.
--   
--   <pre>
--   pseq [return 1,return 2,return 3] 2 == toP [1,2,3,1,2,3]
--   pseq [1,2,3] 2 == toP [1,2,3,1,2,3]
--   pseq [1,pn 2 2,3] 2 == toP [1,2,2,3,1,2,2,3]
--   </pre>
--   
--   There is an <a>inf</a> value for the repeats variable.
--   
--   <pre>
--   ptake 3 (pdrop (10^5) (pseq [1,2,3] inf)) == toP [2,3,1]
--   </pre>
--   
--   Unlike the SC3 Pseq, <a>pseq</a> does not have an offset argument to
--   give a starting offset into the list.
--   
--   <pre>
--   pseq (C.rotate 3 [1,2,3,4]) 3 == toP [2,3,4,1,2,3,4,1,2,3,4,1]
--   </pre>
--   
--   As scale degrees.
--   
--   <pre>
--   &gt; Pbind(\degree,Pseq(#[0,0,4,4,5,5,4],1),
--   &gt;       \dur,Pseq(#[0.5,0.5,0.5,0.5,0.5,0.5,1],1)).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pseq [0,0,4,4,5,5,4] 1)
--                   ,(K_dur,pseq [0.5,0.5,0.5,0.5,0.5,0.5,1] 1)])
--   </pre>
--   
--   <pre>
--   &gt; Pseq(#[60,62,63,65,67,63],inf) + Pseq(#[0,0,0,0,-12],inf)
--   </pre>
--   
--   <pre>
--   let n = pseq [60,62,63,65,67,63] inf + pser [0,0,0,0,-12] 25
--   in audition (pbind [(K_midinote,n),(K_dur,0.2)])
--   </pre>
--   
--   Pattern <tt>b</tt> pattern sequences <tt>a</tt> once normally, once
--   transposed up a fifth and once transposed up a fourth.
--   
--   <pre>
--   &gt; a = Pseq(#[60,62,63,65,67,63]);
--   &gt; b = Pseq([a,a + 7,a + 5],inf);
--   &gt; Pbind(\midinote,b,\dur,0.3).play
--   </pre>
--   
--   <pre>
--   let {a = pseq [60,62,63,65,67,63] 1
--       ;b = pseq [a,a + 7,a + 5] inf}
--   in audition (pbind [(K_midinote,b),(K_dur,0.13)])
--   </pre>
pseq :: [P a] -> Int -> P a

-- | Pser. SC3 pattern that is like <a>pseq</a>, however the repeats
--   variable gives the number of elements in the sequence, not the number
--   of cycles of the pattern.
--   
--   <pre>
--   pser [1,2,3] 5 == toP [1,2,3,1,2]
--   pser [1,pser [10,20] 3,3] 9 == toP [1,10,20,10,3,1,10,20,10]
--   pser [1,2,3] 5 * 3 == toP [3,6,9,3,6]
--   </pre>
pser :: [P a] -> Int -> P a

-- | Pseries. SC3 arithmetric series pattern, see also <a>pgeom</a>.
--   
--   <pre>
--   pseries 0 2 10 == toP [0,2,4,6,8,10,12,14,16,18]
--   pseries 9 (-1) 10 == toP [9,8 .. 0]
--   pseries 1.0 0.2 3 == toP [1.0::Double,1.2,1.4]
--   </pre>
pseries :: Num a => a -> a -> Int -> P a

-- | Pshuf. SC3 pattern to return <tt>n</tt> repetitions of a shuffled --
--   sequence.
--   
--   <pre>
--   &gt; Pshuf([1,2,3,4],2).asStream.all
--   pshuf 'α' [1,2,3,4] 2 == toP [2,4,3,1,2,4,3,1]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pshuf([0,1,2,4,5],inf),\dur,0.25).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pshuf 'α' [0,1,2,4,5] inf)
--                   ,(K_dur,0.25)])
--   </pre>
pshuf :: Enum e => e -> [a] -> Int -> P a

-- | Pslide. Lifted <a>slide</a>.
--   
--   <pre>
--   &gt; Pslide([1,2,3,4],inf,3,1,0).asStream.all
--   pslide [1,2,3,4] 4 3 1 0 True == toP [1,2,3,2,3,4,3,4,1,4,1,2]
--   pslide [1,2,3,4,5] 3 3 (-1) 0 True == toP [1,2,3,5,1,2,4,5,1]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pslide((-6,-4 .. 12),8,3,1,0),
--   &gt;       \dur,Pseq(#[0.1,0.1,0.2],inf),
--   &gt;       \sustain,0.15).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pslide [-6,-4 .. 12] 8 3 1 0 True)
--                   ,(K_dur,pseq [0.05,0.05,0.1] inf)
--                   ,(K_sustain,0.15)])
--   </pre>
pslide :: [a] -> Int -> Int -> Int -> Int -> Bool -> P a

-- | Pstutter. SC3 <i>implicitly repeating</i> pattern to repeat each --
--   element of a pattern <i>n</i> times.
--   
--   <pre>
--   &gt; Pstutter(2,Pseq([1,2,3],1)).asStream.all == [1,1,2,2,3,3]
--   pstutter 2 (pseq [1,2,3] 1) == toP [1,1,2,2,3,3]
--   </pre>
--   
--   The count input may be a pattern.
--   
--   <pre>
--   let {p = pseq [1,2] inf
--       ;q = pseq [1,2,3] 2}
--   in pstutter p q == toP [1,2,2,3,1,1,2,3,3]
--   </pre>
--   
--   <pre>
--   pstutter (toP [1,2,3]) (toP [4,5,6]) == toP [4,5,5,6,6,6]
--   pstutter 2 (toP [4,5,6]) == toP [4,4,5,5,6,6]
--   </pre>
--   
--   Stutter scale degree and duration with the same random sequence.
--   
--   <pre>
--   &gt; Pbind(\n,Pwhite(3,10,inf),
--   &gt;       \degree,Pstutter(Pkey(\n),Pwhite(-4,11,inf)),
--   &gt;       \dur,Pstutter(Pkey(\n),Pwhite(0.05,0.4,inf)),
--   &gt;       \legato,0.3).play
--   </pre>
--   
--   <pre>
--   let {n = pwhite 'α' 3 10 inf
--       ;p = [(K_degree,pstutter n (pwhitei 'β' (-4) 11 inf))
--            ,(K_dur,pstutter n (pwhite 'γ' 0.05 0.4 inf))
--            ,(K_legato,0.3)]}
--   in audition (pbind p)
--   </pre>
pstutter :: P Int -> P a -> P a

-- | Pswitch. Lifted <a>switch</a>.
--   
--   <pre>
--   let p = pswitch [pseq [1,2,3] 2,pseq [65,76] 1,800] (toP [2,2,0,1])
--   in p == toP [800,800,1,2,3,1,2,3,65,76]
--   </pre>
pswitch :: [P a] -> P Int -> P a

-- | Pswitch1. Lifted <i>implicitly repeating</i> <a>switch1</a>.
--   
--   <pre>
--   &gt; l = [Pseq([1,2,3],inf),Pseq([65,76],inf),8];
--   &gt; p = Pswitch1(l,Pseq([2,2,0,1],3));
--   &gt; p.asStream.all == [8,8,1,65,8,8,2,76,8,8,3,65];
--   </pre>
--   
--   <pre>
--   let p = pswitch1 [pseq [1,2,3] inf
--                    ,pseq [65,76] inf
--                    ,8] (pseq [2,2,0,1] 6)
--   in p == toP [8,8,1,65,8,8,2,76,8,8,3,65,8,8,1,76,8,8,2,65,8,8,3,76]
--   </pre>
pswitch1 :: [P a] -> P Int -> P a

-- | Ptuple. <a>pseq</a> of <a>ptranspose_st_repeat</a>.
--   
--   <pre>
--   &gt; l = [Pseries(7,-1,8),3,Pseq([9,7,4,2],1),Pseq([4,2,0,0,-3],1)];
--   &gt; p = Ptuple(l,1);
--   &gt; p.asStream.all == [[7,3,9,4],[6,3,7,2],[5,3,4,0],[4,3,2,0]]
--   </pre>
--   
--   <pre>
--   let p = ptuple [pseries 7 (-1) 8
--                  ,3
--                  ,pseq [9,7,4,2] 1
--                  ,pseq [4,2,0,0,-3] 1] 1
--   in p == toP [[7,3,9,4],[6,3,7,2],[5,3,4,0],[4,3,2,0]]
--   </pre>
ptuple :: [P a] -> Int -> P [a]

-- | Pwhite. Lifted <a>white</a>.
--   
--   <pre>
--   pwhite 'α' 0 9 5 == toP [3,0,1,6,6]
--   pwhite 'α' 0 9 5 - pwhite 'α' 0 9 5 == toP [0,0,0,0,0]
--   </pre>
--   
--   The pattern below is alternately lower and higher noise.
--   
--   <pre>
--   let {l = pseq [0.0,9.0] inf
--       ;h = pseq [1.0,12.0] inf}
--   in audition (pbind [(K_freq,pwhite' 'α' l h * 20 + 800)
--                      ,(K_dur,0.25)])
--   </pre>
pwhite :: (Random n, Enum e) => e -> n -> n -> Int -> P n

-- | Pwrand. Lifted <a>wrand</a>.
--   
--   <pre>
--   let w = C.normalizeSum [12,6,3]
--   in pwrand 'α' [1,2,3] w 6 == toP [2,1,2,3,3,2]
--   </pre>
--   
--   <pre>
--   &gt; r = Pwrand.new([1,2,Pseq([3,4],1)],[1,3,5].normalizeSum,6);
--   &gt; p = Pseed(Pn(100,1),r);
--   &gt; p.asStream.all == [2,3,4,1,3,4,3,4,2]
--   </pre>
--   
--   <pre>
--   let w = C.normalizeSum [1,3,5]
--   in pwrand 'ζ' [1,2,pseq [3,4] 1] w 6 == toP [3,4,2,2,3,4,1,3,4]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pwrand((0..7),[4,1,3,1,3,2,1].normalizeSum,inf),
--   &gt;       \dur,0.25).play;
--   </pre>
--   
--   <pre>
--   let {w = C.normalizeSum [4,1,3,1,3,2,1]
--       ;d = pwrand 'α' (C.series 7 0 1) w inf}
--   in audition (pbind [(K_degree,d),(K_dur,0.25)])
--   </pre>
pwrand :: Enum e => e -> [P a] -> [Double] -> Int -> P a

-- | Pwrap. Type specialised <a>fwrap</a>, see also <a>pfold</a>.
--   
--   <pre>
--   &gt; p = Pwrap(Pgeom(200,1.25,9),200,1000.0);
--   &gt; r = p.asStream.all.collect({|n| n.round});
--   &gt; r == [200,250,313,391,488,610,763,954,392];
--   </pre>
--   
--   <pre>
--   let p = fmap roundE (pwrap (pgeom 200 1.25 9) 200 1000)
--   in p == toP [200,250,312,391,488,610,763,954,391]
--   </pre>
pwrap :: (Ord a, Num a) => P a -> a -> a -> P a

-- | Pxrand. Lifted <a>xrand</a>.
--   
--   <pre>
--   let p = pxrand 'α' [1,toP [2,3],toP [4,5,6]] 9
--   in p == toP [4,5,6,2,3,4,5,6,1]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\note,Pxrand([0,1,5,7],inf),\dur,0.25).play
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_note,pxrand 'α' [0,1,5,7] inf),(K_dur,0.25)])
--   </pre>
pxrand :: Enum e => e -> [P a] -> Int -> P a

-- | Lifted <i>implicitly repeating</i> <a>pbrown'</a>.
--   
--   <pre>
--   pbrown' 'α' 1 700 (pseq [1,20] inf) 4 == toP [415,419,420,428]
--   </pre>
pbrown' :: (Enum e, Random n, Num n, Ord n) => e -> P n -> P n -> P n -> Int -> P n

-- | Un-joined variant of <a>prand</a>.
--   
--   <pre>
--   let p = prand' 'α' [1,toP [2,3],toP [4,5,6]] 5
--   in p == toP [toP [4,5,6],toP [4,5,6],toP [2,3],toP [4,5,6],1]
--   </pre>
prand' :: Enum e => e -> [P a] -> Int -> P (P a)

-- | Underlying pattern for <a>prorate</a>.
--   
--   <pre>
--   prorate' (Left 0.6) 0.5
--   </pre>
prorate' :: Num a => Either a [a] -> a -> P a

-- | Variant of <a>pseq</a> that retrieves only one value from each pattern
--   on each list traversal. Compare to <a>pswitch1</a>.
--   
--   <pre>
--   pseq [pseq [1,2] 1,pseq [3,4] 1] 2 == toP [1,2,3,4,1,2,3,4]
--   pseq1 [pseq [1,2] 1,pseq [3,4] 1] 2 == toP [1,3,2,4]
--   pseq1 [pseq [1,2] inf,pseq [3,4] inf] 3 == toP [1,3,2,4,1,3]
--   </pre>
--   
--   <pre>
--   let {p = prand' 'α' [pempty,toP [24,31,36,43,48,55]] inf
--       ;q = pflop [60,prand 'β' [63,65] inf
--                  ,67,prand 'γ' [70,72,74] inf]
--       ;r = psplitPlaces (pwhite 'δ' 3 9 inf)
--                         (toP [74,75,77,79,81])
--       ;n = pjoin (pseq1 [p,q,r] inf)}
--   in audition (pbind [(K_midinote,n),(K_dur,0.13)])
--   </pre>
pseq1 :: [P a] -> Int -> P a

-- | A variant of <a>pseq</a> to aid translating a common SC3 idiom where a
--   finite random pattern is included in a <tt>Pseq</tt> list. In the SC3
--   case, at each iteration a new computation is run. This idiom does not
--   directly translate to the declarative haskell pattern library.
--   
--   <pre>
--   &gt; Pseq([1,Prand([2,3],1)],5).asStream.all
--   pseq [1,prand 'α' [2,3] 1] 5 == toP [1,3,1,3,1,3,1,3,1,3]
--   </pre>
--   
--   Although the intended pattern can usually be expressed using an
--   alternate construction:
--   
--   <pre>
--   &gt; Pseq([1,Prand([2,3],1)],5).asStream.all
--   ppatlace [1,prand 'α' [2,3] inf] 5 == toP [1,3,1,2,1,3,1,2,1,2]
--   </pre>
--   
--   the <a>pseqn</a> variant handles many common cases.
--   
--   <pre>
--   &gt; Pseq([Pn(8,2),Pwhite(9,16,1)],5).asStream.all
--   </pre>
--   
--   <pre>
--   let p = pseqn [2,1] [8,pwhite 'α' 9 16 inf] 5
--   in p == toP [8,8,10,8,8,9,8,8,12,8,8,15,8,8,15]
--   </pre>
pseqn :: [Int] -> [P a] -> Int -> P a

-- | A variant of <a>pseq</a> that passes a new seed at each invocation,
--   see also <a>pfuncn</a>.
--   
--   <pre>
--   &gt; pseqr (\e -&gt; [pshuf e [1,2,3,4] 1]) 2 == toP [2,3,4,1,4,1,2,3]
--   </pre>
--   
--   <pre>
--   let {d = pseqr (\e -&gt; [pshuf e [-7,-3,0,2,4,7] 4
--                         ,pseq [0,1,2,3,4,5,6,7] 1]) inf}
--   in audition (pbind [(K_degree,d),(K_dur,0.15)])
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\dur,0.2,
--   &gt;       \midinote,Pseq([Pshuf(#[60,61,62,63,64,65,66,67],3)],inf)).play
--   </pre>
--   
--   <pre>
--   let {m = pseqr (\e -&gt; [pshuf e [60,61,62,63,64,65,66,67] 3]) inf}
--   in audition (pbind [(K_dur,0.2),(K_midinote,m)])
--   </pre>
pseqr :: (Int -> [P a]) -> Int -> P a

-- | Variant of <a>pser</a> that consumes sub-patterns one element per
--   iteration.
--   
--   <pre>
--   pser1 [1,pser [10,20] 3,3] 9 == toP [1,10,3,1,20,3,1,10,3]
--   </pre>
pser1 :: [P a] -> Int -> P a

-- | Lifted <i>implicitly repeating</i> <a>pwhite</a>.
--   
--   <pre>
--   pwhite' 'α' 0 (pseq [9,19] 3) == toP [3,0,1,6,6,15]
--   </pre>
pwhite' :: (Enum e, Random n) => e -> P n -> P n -> P n

-- | Lifted <a>whitei</a>.
--   
--   <pre>
--   pwhitei 'α' 1 9 5 == toP [5,1,7,7,8]
--   </pre>
--   
--   <pre>
--   audition (pbind [(K_degree,pwhitei 'α' 0 8 inf),(K_dur,0.15)])
--   </pre>
pwhitei :: (RealFracE n, Random n, Enum e) => e -> n -> n -> Int -> P n

-- | <a>liftUId</a> of <a>pbrown</a>.
pbrownM :: (UId m, Num n, Ord n, Random n) => n -> n -> n -> Int -> m (P n)

-- | <a>liftUId</a> of <a>pexprand</a>.
pexprandM :: (UId m, Random a, Floating a) => a -> a -> Int -> m (P a)

-- | <a>liftUId</a> of <a>prand</a>.
prandM :: UId m => [P a] -> Int -> m (P a)

-- | <a>liftUId</a> of <a>pshuf</a>.
pshufM :: UId m => [a] -> Int -> m (P a)

-- | <a>liftUId</a> of <a>pwhite</a>.
pwhiteM :: (UId m, Random n) => n -> n -> Int -> m (P n)

-- | <a>liftUId</a> of <a>pwhitei</a>.
pwhiteiM :: (UId m, RealFracE n, Random n) => n -> n -> Int -> m (P n)

-- | <a>liftUId</a> of <a>pwrand</a>.
pwrandM :: UId m => [P a] -> [Double] -> Int -> m (P a)

-- | <a>liftUId</a> of <a>pxrand</a>.
pxrandM :: UId m => [P a] -> Int -> m (P a)


-- | Composite of Pattern.P modules. See
--   <a>http://rd.slavepianos.org/?t=hsc3-texts</a> for tutorial.
module Sound.SC3.Lang.Pattern.P


-- | <tt>sclang</tt> event pattern functions.
--   
--   SC3 <i>event</i> patterns: <a>padd</a> (Padd), <a>pbind</a> (Pbind),
--   <a>pkey</a> (Pkey), <a>pmono</a> (Pmono), <a>pmul</a> (Pmul),
--   <a>ppar</a> (Ppar), <a>pstretch</a> (Pstretch), <a>ptpar</a> (Ptpar).
--   <a>pedit</a>, <a>pinstr</a>, <a>pmce2</a>, <a>psynth</a>,
--   <a>punion</a>.
module Sound.SC3.Lang.Pattern.P.Event

-- | NewType for event patterns.
newtype P_Event
P_Event :: P Event -> P_Event
p_Event :: P_Event -> P Event

-- | <a>P_Event</a> is audible, <a>P</a> <a>Event</a> could be as well but
--   it'd be an orphan instance.
pplay :: Transport m => P Event -> m ()

-- | <a>audition</a> of <a>P_Event</a>.
paudition :: P Event -> IO ()

-- | Synonym for (<a>Key</a>,'P Field').
type P_Bind = (Key, P Field)

-- | Padd. Add a value to an existing key, or set the key if it doesn't
--   exist.
--   
--   <pre>
--   &gt; p = Padd(\freq,801,Pbind(\freq,Pseq([100],1)));
--   &gt; p.asStream.all(()) == [('freq':901)]
--   </pre>
--   
--   <pre>
--   let p = padd (K_freq,801) (pbind [(K_freq,return 100)])
--   in p == pbind [(K_freq,return 901)]
--   </pre>
--   
--   <pre>
--   &gt; Padd(\freq,Pseq([401,801],2),Pbind(\freq,100)).play
--   </pre>
--   
--   <pre>
--   paudition (padd (K_freq,pseq [401,801] 2) (pbind [(K_freq,100)]))
--   </pre>
--   
--   <pre>
--   let {d = pseq [pshuf 'α' [-7,-3,0,2,4,7] 2
--                 ,pseq [0,1,2,3,4,5,6,7] 1] 1
--       ;p = pbind [(K_dur,0.15),(K_degree,d)]
--       ;t n = padd (K_mtranspose,n) p}
--   in paudition (pseq [p,t 1,t 2] inf)
--   </pre>
padd :: P_Bind -> P Event -> P Event

-- | Pbind. SC3 pattern to assign keys to a set of <a>Field</a> patterns
--   making an <a>Event</a> pattern.
--   
--   Each input pattern is assigned to key in the resulting event pattern.
--   
--   There are a set of reserved keys that have particular roles in the
--   pattern library.
--   
--   <pre>
--   &gt; p = Pbind(\x,Pseq([1,2,3],1),\y,Pseed(Pn(100,1),Prand([4,5,6],inf)));
--   &gt; p.asStream.all(()) == [('y':4,'x':1),('y':6,'x':2),('y':4,'x':3)]
--   </pre>
--   
--   <pre>
--   let p = pbind [(K_param "x",prand 'α' [100,300,200] inf)
--                 ,(K_param "y",pseq [1,2,3] 1)]
--   in pkey (K_param "x") p == toP [200,200,300]
--   </pre>
--   
--   <a>K_param</a> can be elided if <i>OverloadedStrings</i> are in place.
--   
--   <pre>
--   :set -XOverloadedStrings
--   </pre>
--   
--   <pre>
--   ptake 2 (pbind [("x",pwhitei 'α' 0 9 inf)
--                  ,("y",pseq [1,2,3] inf)])
--   </pre>
--   
--   <a>Event</a>s implement variations on the <tt>SC3</tt> <a>Dur</a> and
--   <a>Pitch</a> models.
--   
--   <pre>
--   &gt; Pbind(\freq,Prand([300,500,231.2,399.2],inf),
--   &gt;       \dur,0.1).play;
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [300,500,231.2,399.2] inf)
--                    ,(K_dur,0.1)])
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\freq, Prand([300,500,231.2,399.2],inf),
--   &gt;       \dur,Prand([0.1,0.3],inf)).play;
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [300,500,231.2,399.2] inf)
--                    ,(K_dur,prand 'β' [0.1,0.3] inf)])
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\freq,Prand([1,1.2,2,2.5,3,4],inf) * 200,
--   &gt;       \dur,0.1).play;
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [1,1.2,2,2.5,3,4] inf * 200)
--                    ,(K_dur,0.1)])
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_freq,pseq [440,550,660,770] 2)
--                    ,(K_dur,pseq [0.1,0.15,0.1] inf)
--                    ,(K_amp,pseq [0.1,0.05] inf)
--                    ,(K_param "pan",pseq [-1,0,1] inf)])
--   </pre>
--   
--   A finite binding stops the <a>Event</a> pattern.
--   
--   <pre>
--   &gt; Pbind(\freq,Prand([300,500,231.2,399.2],inf),
--   &gt;       \dur,Pseq([0.1,0.2],3)).play;
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [300,500,231.2,399.2] inf)
--                    ,(K_dur,pseq [0.1,0.2] 3)])
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\freq,Prand([300,500,231.2,399.2],inf),
--   &gt;       \dur,Prand([0.1,0.3],inf)).play
--   </pre>
--   
--   All infinite inputs:
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [300,500,231.2,399.2] inf)
--                    ,(K_dur,prand 'β' [0.1,0.3] inf)])
--   </pre>
--   
--   Implicit <i>field</i> patterns is this context are infinite.
--   
--   <pre>
--   paudition (pbind [(K_freq,prand 'α' [1,1.2,2,2.5,3,4] inf * 200)
--                    ,(K_dur,0.1)])
--   </pre>
--   
--   <pre>
--   let test = let {freq = control KR "freq" 440
--                  ;amp = control KR "amp" 0.1
--                  ;nharms = control KR "nharms" 10
--                  ;pan = control KR "pan" 0
--                  ;gate = control KR "gate" 1
--                  ;s = blip AR freq nharms * amp
--                  ;e = linen gate 0.01 0.6 0.4 RemoveSynth
--                  ;o = offsetOut 0 (pan2 s pan e)}
--              in synthdef "test" o
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_instr,psynth test)
--                    ,(K_freq,prand 'α' [1,1.2,2,2.5,3,4] inf * 200)
--                    ,(K_dur,0.1)])
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_instr,psynth test)
--                    ,(K_param "nharms",pseq [4,10,40] inf)
--                    ,(K_dur,pseq [1,1,2,1] inf / 10)
--                    ,(K_freq,pn (pseries 1 1 16 * 50) 4)
--                    ,(K_sustain,pseq [1/10,0.5,1,2] inf)])
--   </pre>
--   
--   <pre>
--   let acid = let {freq = control KR "freq" 1000
--                  ;gate = control KR "gate" 1
--                  ;pan = control KR "pan" 0
--                  ;cut = control KR "cut" 4000
--                  ;res = control KR "res" 0.8
--                  ;amp = control KR "amp" 1
--                  ;s = rlpf (pulse AR freq 0.05) cut res
--                  ;d = envLinen 0.01 1 0.3 1
--                  ;e = envGen KR gate amp 0 1 RemoveSynth d
--                  ;o = out 0 (pan2 s pan e)}
--              in synthdef "acid" o
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\instrument,\acid,
--   &gt;       \dur,Pseq([0.25,0.5,0.25],4),
--   &gt;       \root,-24,
--   &gt;       \degree,Pseq([0,3,5,7,9,11,5,1],inf),
--   &gt;       \pan,Pfunc({1.0.rand2}),
--   &gt;       \cut,Pxrand([1000,500,2000,300],inf),
--   &gt;       \rez,Pfunc({0.7.rand +0.3}),
--   &gt;       \amp,0.2).play
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_instr,psynth acid)
--                    ,(K_dur,pseq [0.25,0.5,0.25] 4)
--                    ,(K_root,-24)
--                    ,(K_degree,pseq [0,3,5,7,9,11,5,1] inf)
--                    ,(K_param "pan",pwhite 'α' (-1.0) 1.0 inf)
--                    ,(K_param "cut",pxrand 'β' [1000,500,2000,300] inf)
--                    ,(K_param "res",pwhite 'γ' 0.3 1.0 inf)
--                    ,(K_amp,0.2)])
--   </pre>
--   
--   <pre>
--   &gt; Pseq([Pbind(\instrument,\acid,
--   &gt;             \dur,Pseq([0.25,0.5,0.25],4),
--   &gt;             \root,-24,
--   &gt;             \degree,Pseq([0,3,5,7,9,11,5,1],inf),
--   &gt;             \pan,Pfunc({1.0.rand2}),
--   &gt;             \cut,Pxrand([1000,500,2000,300],inf),
--   &gt;             \rez,Pfunc({0.7.rand + 0.3}),
--   &gt;             \amp,0.2),
--   &gt;       Pbind(\instrument,\acid,
--   &gt;             \dur,Pseq([0.25],6),
--   &gt;             \root,-24,
--   &gt;             \degree,Pseq([18,17,11,9],inf),
--   &gt;             \pan,Pfunc({1.0.rand2}),
--   &gt;             \cut,1500,
--   &gt;             \rez,Pfunc({0.7.rand + 0.3}),
--   &gt;             \amp,0.16)],inf).play
--   </pre>
--   
--   <pre>
--   paudition (pseq [pbind [(K_instr,psynth acid)
--                          ,(K_dur,pseq [0.25,0.5,0.25] 4)
--                          ,(K_root,-24)
--                          ,(K_degree,pseq [0,3,5,7,9,11,5,1] inf)
--                          ,(K_param "pan",pwhite 'α' (-1.0) 1.0 inf)
--                          ,(K_param "cut",pxrand 'β' [1000,500,2000,300] inf)
--                          ,(K_param "res",pwhite 'γ' 0.3 1.0 inf)
--                          ,(K_amp,0.2)]
--                   ,pbind [(K_instr,psynth acid)
--                          ,(K_dur,pn 0.25 6)
--                          ,(K_root,-24)
--                          ,(K_degree,pser [18,17,11,9] inf)
--                          ,(K_param "pan",pwhite 'δ' (-1.0) 1.0 inf)
--                          ,(K_param "cut",1500)
--                          ,(K_param "res",pwhite 'ε' 0.3 1.0 inf)
--                          ,(K_amp,0.16)]] inf)
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\instrument, \acid,
--   &gt;       \dur, Pseq([0.25,0.5,0.25], inf),
--   &gt;       \root, [-24,-17],
--   &gt;       \degree, Pseq([0,3,5,7,9,11,5,1], inf),
--   &gt;       \pan, Pfunc({1.0.rand2}),
--   &gt;       \cut, Pxrand([1000,500,2000,300], inf),
--   &gt;       \rez, Pfunc({0.7.rand +0.3}),
--   &gt;       \amp, 0.2).play;
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_instr,psynth acid)
--                    ,(K_dur,pseq [0.25,0.5,0.25] inf)
--                    ,(K_root,pmce2 (-24) (-17))
--                    ,(K_degree,pseq [0,3,5,7,9,11,5,1] inf)
--                    ,(K_param "pan",pwhite 'α' (-1.0) 1.0 inf)
--                    ,(K_param "cut",pxrand 'β' [1000,500,2000,300] inf)
--                    ,(K_param "res",pwhite 'γ' 0.3 1.0 inf)
--                    ,(K_amp,0.2)])
--   </pre>
--   
--   A persistent synthesis node with <i>freq</i> and <i>amp</i> controls.
--   
--   <pre>
--   import Sound.SC3.ID
--   </pre>
--   
--   <pre>
--   let {freq = control KR "freq" 440
--       ;amp = control KR "amp" 0.6
--       ;n = pinkNoise 'α' AR * amp}
--   in audition (out 0 (pan2 (moogFF n freq 2 0) 0 1))
--   </pre>
--   
--   A pattern to set <i>freq</i> and <i>amp</i> controls at the most
--   recently instantiated synthesis node.
--   
--   <pre>
--   :set -XOverloadedStrings
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_type,prepeat "n_set")
--                    ,(K_id,(-1))
--                    ,(K_freq,pwhite 'α' 100 1000 inf)
--                    ,(K_dur,0.2)
--                    ,(K_amp,toP [1,0.99 .. 0.1])])
--   </pre>
--   
--   <pre>
--   let berlinb =
--     let {k = control KR
--         ;o = k "out" 0
--         ;f = k "freq" 80
--         ;a = k "amp" 0.01
--         ;p = k "pan" 0
--         ;g = k "gate" 1
--         ;env = decay2 g 0.05 8 * 0.0003
--         ;syn = rlpf (lfPulse AR f 0 (sinOsc KR 0.12 (mce2 0 (pi/2)) * 0.48 + 0.5))
--                     (f * (sinOsc KR 0.21 0 * 18 + 20))
--                     0.07
--         ;syn_env = syn * env
--         ;kil = detectSilence (mceChannel 0 syn_env) 0.1 0.2 RemoveSynth}
--     in mrg2 (out o (a * mix (panAz 4 syn_env (mce2 p (p + 1)) 1 2 0.5))) kil
--   </pre>
--   
--   <pre>
--   paudition (ppar [pbind [(K_degree,pseq [0,1,2,4,6,3,4,8] inf)
--                          ,(K_dur,0.5)
--                          ,(K_octave,3)
--                          ,(K_instr,psynth (synthdef "berlinb" berlinb))]
--                   ,pbind [(K_degree,pseq [0,1,2,4,6,3,4,8] inf)
--                          ,(K_dur,0.5)
--                          ,(K_octave,pmce2 2 1)
--                          ,(K_param "pan",pwhite 'a' (-1) 1 inf)
--                          ,(K_instr,psynth (synthdef "berlinb" berlinb))]])
--   </pre>
pbind :: [P_Bind] -> P Event

-- | Operator to lift <a>F_Value</a> pattern to <a>P_Bind</a> tuple.
--   
--   <pre>
--   let {r = True `pcons` preplicate 3 False :: P Bool}
--   in pbind [K_rest &lt;| r] == pbind [(K_rest,pseq [1,0,0,0] 1)]
--   </pre>
(<|) :: F_Value v => Key -> P v -> P_Bind

-- | Pkey. SC3 pattern to read <a>Key</a> at <a>Event</a> pattern. Note --
--   however that in haskell is usually more appropriate to name the --
--   pattern using <i>let</i>.
--   
--   <pre>
--   pkey K_freq (pbind [(K_freq,return 440)]) == toP [440]
--   pkey K_amp (pbind [(K_amp,toP [0,1])]) == toP [0,1]
--   </pre>
--   
--   <pre>
--   &gt; Pbind(\degree,Pseq([Pseries(-7,1,14),Pseries(7,-1,14)],inf),
--   &gt;       \dur,0.25,
--   &gt;       \legato,Pkey(\degree).linexp(-7,7,2.0,0.05)).play
--   </pre>
--   
--   <pre>
--   let {d = pseq [pseries (-7) 1 14,pseries 7 (-1) 14] inf
--       ;l = fmap (Sound.SC3.Lang.Math.linexp (-7) 7 2 0.05) d}
--   in paudition (pbind [(K_degree,d)
--                       ,(K_dur,0.25)
--                       ,(K_legato,l)])
--   </pre>
pkey :: Key -> P Event -> P Field

-- | Pmono. SC3 pattern that is a variant of <a>pbind</a> for controlling
--   -- monophonic (persistent) synthesiser nodes.
--   
--   <pre>
--   let p = [(K_instr,pinstr' (Instr_Ref "default" False))
--           ,(K_id,100)
--           ,(K_degree,pxrand 'α' [0,2,4,5,7,9,11] inf)
--           ,(K_amp,pwrand 'β' [0.05,0.2] [0.7,0.3] inf)
--           ,(K_dur,0.25)]
--   in paudition (pmono p)
--   </pre>
pmono :: [P_Bind] -> P Event

-- | Pmul. SC3 pattern to multiply an existing key by a value, or set the
--   key if it doesn't exist.
--   
--   <pre>
--   let p = pbind [(K_dur,0.15),(K_freq,prand 'α' [440,550,660] 6)]
--   in paudition (pseq [p,pmul (K_freq,2) p,pmul (K_freq,0.5) p] 2)
--   </pre>
pmul :: P_Bind -> P Event -> P Event

-- | Ppar. Variant of <a>ptpar</a> with zero start times.
--   
--   The result of <a>pmerge</a> can be merged again, <a>ppar</a> merges a
--   list of patterns.
--   
--   <pre>
--   let {a = pbind [(K_param "a",pseq [1,2,3] inf)]
--       ;b = pbind [(K_param "b",pseq [4,5,6] inf)]
--       ;r = toP [e_from_list [(K_param "a",1),(K_fwd',0)]
--                ,e_from_list [(K_param "b",4),(K_fwd',1)]]}
--   in ptake 2 (ppar [a,b]) == r
--   </pre>
--   
--   <pre>
--   let {p = pbind [(K_dur,0.2),(K_midinote,pseq [62,65,69,72] inf)]
--       ;q = pbind [(K_dur,0.4),(K_midinote,pseq [50,45] inf)]
--       ;r = pbind [(K_dur,0.6),(K_midinote,pseq [76,79,81] inf)]}
--   in paudition (ppar [p,q,r])
--   </pre>
--   
--   Multiple nested <a>ppar</a> patterns.
--   
--   <pre>
--   let {a u = pbind [(K_dur,0.2),(K_param "pan",0.5),(K_midinote,pseq u 1)]
--       ;b l = pbind [(K_dur,0.4),(K_param "pan",-0.5),(K_midinote,pseq l 1)]
--       ;f u l = ppar [a u,b l]
--       ;h = pbind [(K_dur,prand 'α' [0.2,0.4,0.6] inf)
--                  ,(K_midinote,prand 'β' [72,74,76,77,79,81] inf)
--                  ,(K_db,-26)
--                  ,(K_legato,1.1)]
--       ;m = pseq [pbind [(K_dur,3.2),(K_freq,return nan)]
--                 ,prand 'γ' [f [60,64,67,64] [48,43]
--                            ,f [62,65,69,65] [50,45]
--                            ,f [64,67,71,67] [52,47]] 12] inf}
--   in paudition (ppar [h,m])
--   </pre>
ppar :: [P Event] -> P Event

-- | Pstretch. SC3 pattern to do time stretching. It is equal to
--   <a>pmul</a> at <a>K_stretch</a>.
--   
--   <pre>
--   let {d = pseq [pshuf 'α' [-7,-3,0,2,4,7] 2
--                 ,pseq [0,1,2,3,4,5,6,7] 1] 1
--       ;p = pbind [(K_dur,0.15),(K_degree,d)]}
--   in paudition (pseq [p,pstretch 0.5 p,pstretch 2 p] inf)
--   </pre>
pstretch :: P Field -> P Event -> P Event

-- | Ptpar. Merge a set of <a>Event</a> patterns each with indicated --
--   start <a>Time</a>.
--   
--   <a>ptpar</a> is a variant of <a>ppar</a> which allows non-equal start
--   times.
--   
--   <pre>
--   let {f d p n = pbind [(K_dur,d),(K_param "pan",p),(K_midinote,n)]
--       ;a = f 0.2 (-1) (pseries 60 1 15)
--       ;b = f 0.15 0 (pseries 58 2 15)
--       ;c = f 0.1 1 (pseries 46 3 15)}
--   in paudition (ptpar [(0,a),(1,b),(2,c)])
--   </pre>
--   
--   <pre>
--   let {d = pseq [pgeom 0.05 1.1 24,pgeom 0.5 0.909 24] 2
--       ;f n a p = pbind [(K_dur,d)
--                        ,(K_db,a)
--                        ,(K_param "pan",p)
--                        ,(K_midinote,pseq [n,n-4] inf)]}
--   in audition (ptpar [(0,f 53 (-20) (-0.9))
--                      ,(2,f 60 (-23) (-0.3))
--                      ,(4,f 67 (-26) 0.3)
--                      ,(6,f 74 (-29) 0.9)])
--   </pre>
ptpar :: [(Time, P Event)] -> P Event

-- | Pattern from <a>Instr</a>. An <a>Instr</a> is either a <a>Synthdef</a>
--   or a <i>name</i>. In the <a>Synthdef</a> case the instrument is
--   asynchronously sent to the server before processing the event, which
--   has timing implications. The pattern constructed here uses the
--   <a>Synthdef</a> for the first element, and the subsequently the
--   <i>name</i>.
--   
--   <pre>
--   paudition (pbind [(K_instr,pinstr' defaultInstr)
--                    ,(K_degree,toP [0,2,4,7])
--                    ,(K_dur,0.25)])
--   </pre>
pinstr' :: Instr -> P Field

-- | <a>Instr</a> pattern from instrument <i>name</i>. See also
--   <a>psynth</a> (where the <i>sine</i> instrument below is defined).
--   
--   <pre>
--   let {si = return (F_Instr (Instr_Ref "sine" True))
--       ;di = return (F_Instr (Instr_Ref "default" True))
--       ;i = pseq [si,si,di] inf
--       ;p = pbind [(K_instr,i),(K_degree,pseq [0,2,4,7] inf),(K_dur,0.25)]}
--   in paudition p
--   </pre>
pinstr :: String -> P Field

-- | <a>Synthdef</a>s can be used directly as an instrument using
--   <a>psynth</a>. The default synthdef is at <a>def</a>.
--   
--   <pre>
--   let sineSynth =
--     let {f = control KR "freq" 440
--         ;g = control KR "gate" 1
--         ;a = control KR "amp" 0.1
--         ;d = envASR 0.01 1 1 (EnvNum (-4))
--         ;e = envGen KR g a 0 1 RemoveSynth d
--         ;o = out 0 (sinOsc AR f 0 * e)}
--     in synthdef "sine" o
--   </pre>
--   
--   <pre>
--   paudition (pbind [(K_instr,psynth sineSynth)
--                    ,(K_degree,toP [0,2,4,7])
--                    ,(K_dur,0.25)])
--   </pre>
psynth :: Synthdef -> P Field

-- | Two-channel MCE for <i>field</i> patterns.
--   
--   <pre>
--   pmce2 (toP [1,2]) (toP [3,4]) == toP [f_array [1,3],f_array [2,4]]
--   </pre>
--   
--   <pre>
--   let p = pmce2 (pseq [1,2] inf) (pseq [3,4] inf)
--   in ptake 2 p == toP [f_array [1,3],f_array [2,4]]
--   </pre>
pmce2 :: P Field -> P Field -> P Field

-- | Three-channel MCE for <i>field</i> patterns.
pmce3 :: P Field -> P Field -> P Field -> P Field

-- | Remove one layer of MCE expansion at an <i>event</i> pattern. The
--   pattern will be expanded only to the width of the initial input. Holes
--   are filled with rests.
--   
--   <pre>
--   let {a = pseq [65,69,74] inf
--       ;b = pseq [60,64,67,72,76] inf
--       ;c = pseq [pmce3 72 76 79,pmce2 a b] 1}
--   in paudition (p_un_mce (pbind [(K_midinote,c)
--                                 ,(K_param "pan",pmce2 (-1) 1)
--                                 ,(K_dur,1 `pcons` prepeat 0.15)]))
--   </pre>
--   
--   <a>p_un_mce</a> translates via <a>ppar</a>. This allows <a>dur</a>
--   related fields to be MCE values. The underlying event processor also
--   implements one layer of MCE expansion.
--   
--   <pre>
--   paudition (p_un_mce
--              (pbind [(K_dur,pmce2 0.25 0.2525)
--                     ,(K_legato,pmce2 0.25 2.5)
--                     ,(K_freq,pmce2 (pseq [300,400,500] inf)
--                                    (pseq [302,402,502,202] inf))
--                     ,(K_param "pan",pmce2 (-0.5) 0.5)]))
--   </pre>
p_un_mce :: P Event -> P Event

-- | Edit <tt>a</tt> at <a>Key</a> in each element of an <a>Event</a>
--   pattern.
pedit :: Key -> (Field -> Field) -> P Event -> P Event

-- | Pattern of start times of events at event pattern.
--   
--   <pre>
--   p_time (pbind [(K_dur,toP [1,2,3,2,1])]) == toP [0,1,3,6,8,9]
--   p_time (pbind [(K_dur,pseries 0.5 0.5 5)]) == toP [0,0.5,1.5,3,5,7.5]
--   </pre>
p_time :: P Event -> P Time

-- | Pattern to extract <tt>a</tt>s at <a>Key</a> from an <a>Event</a>
--   pattern.
--   
--   <pre>
--   pkey_m K_freq (pbind [(K_freq,return 440)]) == toP [Just 440]
--   </pre>
pkey_m :: Key -> P Event -> P (Maybe Field)

-- | Variant of <a>ptmerge</a> with zero start times.
--   
--   <a>pmerge</a> merges two event streams, adding <i>fwd'</i> entries as
--   required.
--   
--   <pre>
--   let {p = pbind [(K_dur,0.2),(K_midinote,pseq [62,65,69,72] inf)]
--       ;q = pbind [(K_dur,0.4),(K_midinote,pseq [50,45] inf)]}
--   in paudition (pmerge p q)
--   </pre>
pmerge :: P Event -> P Event -> P Event

-- | Variant that does not insert key.
pmul' :: P_Bind -> P Event -> P Event

-- | Merge two <a>Event</a> patterns with indicated start <a>Time</a>s.
ptmerge :: (Time, P Event) -> (Time, P Event) -> P Event

-- | Left-biased union of event patterns.
punion :: P Event -> P Event -> P Event

-- | <a>punion</a> of <a>pbind</a> of <a>return</a>, ie. <tt>p_with
--   (K_Instr,psynth s)</tt>.
p_with :: P_Bind -> P Event -> P Event

-- | Transform an <i>event</i> pattern into a <i>non-real time</i> SC3
--   score.
--   
--   <pre>
--   let n = pNRT (pbind [(K_freq,prand 'α' [300,500,231.2,399.2] inf)
--                       ,(K_dur,pseq [0.1,0.2] 3)])
--   </pre>
--   
--   <pre>
--   audition n
--   </pre>
--   
--   <pre>
--   mapM_ (putStrLn . bundlePP) (nrt_bundles n)
--   </pre>
--   
--   Infinite <a>NRT</a> scores are productive for <a>audition</a>ing.
--   
--   <pre>
--   let n' = pNRT (pbind [(K_dur,0.25),(K_freq,pseq [300,600,900] inf)])
--   audition n'
--   mapM_ (putStrLn . bundlePP) (take 9 (nrt_bundles n'))
--   </pre>
pNRT :: P Event -> NRT
instance Audible P_Event


-- | Composite module.
module Sound.SC3.Lang.Pattern


-- | <tt>ID</tt> variants of <a>Sound.SC3.Lang.Random.Gen</a>.
module Sound.SC3.Lang.Random.ID
id_rand :: Enum e => e -> (StdGen -> (a, StdGen)) -> a
nchoose :: Enum e => e -> Int -> [a] -> [a]
rand :: (Random a, Num a, Enum e) => e -> a -> a
rrand :: (Random a, Num a, Enum e) => e -> a -> a -> a


-- | <a>getStdRandom</a> based <tt>sclang</tt> random number functions.
module Sound.SC3.Lang.Random.IO

-- | <a>liftIO</a> of <a>randomRIO</a>.
randomM :: (Random a, MonadIO m) => (a, a) -> m a

-- | <tt>SimpleNumber.rand</tt> is <a>randomRIO</a> in (0,<i>n</i>).
rand :: (MonadIO m, Random n, Num n) => n -> m n

-- | <tt>SimpleNumber.rand2</tt> is <a>randomRIO</a> in
--   (-<i>n</i>,<i>n</i>).
rand2 :: (MonadIO m, Random n, Num n) => n -> m n

-- | <a>liftIO</a> of <a>getStdRandom</a>.
randomG :: MonadIO m => (StdGen -> (a, StdGen)) -> m a

-- | Variant of <a>rand2</a> generating <i>k</i> values.
nrand2 :: (Random a, Num a) => Int -> a -> IO [a]

-- | <tt>SimpleNumber.rrand</tt> is <a>curry</a> <a>randomRIO</a>.
rrand :: (MonadIO m, Random n) => n -> n -> m n

-- | Variant of <a>rrand</a> generating <i>k</i> values.
nrrand :: (MonadIO m, Random a, Num a) => Int -> a -> a -> m [a]

-- | <tt>SequenceableCollection.choose</tt> selects an element at random.
choose :: MonadIO m => [a] -> m a

-- | <tt>SimpleNumber.exprand</tt> generates exponentially distributed
--   random number in the given interval.
exprand :: (MonadIO m, Floating n, Random n) => n -> n -> m n

-- | <tt>SimpleNumber.coin</tt> is <a>True</a> at given probability, which
--   is in range (0,1).
coin :: (MonadIO m, Random n, Fractional n, Ord n) => n -> m Bool

-- | <tt>List.scramble</tt> shuffles the elements.
scramble :: MonadIO m => [t] -> m [t]

-- | <tt>SequenceableCollection.wchoose</tt> selects an element from a list
--   given a list of weights which sum to <tt>1</tt>.
wchoose :: (MonadIO m, Random a, Ord a, Fractional a) => [b] -> [a] -> m b


-- | <a>Rand</a> monad based <tt>sclang</tt> random number functions.
module Sound.SC3.Lang.Random.Monad

-- | <tt>SimpleNumber.rand</tt> is <a>getRandomR</a> in (0,<i>n</i>).
--   
--   <pre>
--   evalRand (replicateM 2 (rand (10::Int))) (mkStdGen 6) == [5,8]
--   evalRand (rand (1::Double)) (mkStdGen 6) == 0.21915126172825694
--   </pre>
rand :: (RandomGen g, Random n, Num n) => n -> Rand g n

-- | Variant of <a>rand</a> generating <i>k</i> values.
--   
--   <pre>
--   evalRand (nrand 3 10) (mkStdGen 6) == [5,8,1]
--   </pre>
nrand :: (RandomGen g, Random n, Num n) => Int -> n -> Rand g [n]

-- | <tt>SimpleNumber.rand2</tt> is <a>getRandomR</a> in
--   (-<i>n</i>,<i>n</i>).
--   
--   <pre>
--   evalRand (replicateM 2 (rand2 10)) (mkStdGen 5) == [7,-6]
--   </pre>
rand2 :: (RandomGen g, Random n, Num n) => n -> Rand g n

-- | Variant of <a>rand2</a> generating <i>k</i> values.
--   
--   <pre>
--   evalRand (nrand2 3 10) (mkStdGen 5) == [7,-6,9]
--   </pre>
nrand2 :: (RandomGen g, Random n, Num n) => Int -> n -> Rand g [n]

-- | <tt>SimpleNumber.rrand</tt> is <a>curry</a> <a>getRandomR</a>.
--   
--   <pre>
--   evalRand (replicateM 2 (rrand 3 9)) (mkStdGen 1) == [5,8]
--   </pre>
rrand :: (RandomGen g, Random n, Num n) => n -> n -> Rand g n

-- | Variant of <a>rrand</a> generating <i>k</i> values.
--   
--   <pre>
--   evalRand (nrrand 4 3 9) (mkStdGen 1) == [5,8,9,6]
--   </pre>
nrrand :: (RandomGen g, Random n, Num n) => Int -> n -> n -> Rand g [n]

-- | <tt>SequenceableCollection.choose</tt> selects an element at random.
--   
--   <pre>
--   evalRand (choose [3..9]) (mkStdGen 1) == 5
--   </pre>
choose :: RandomGen g => [a] -> Rand g a
wchoose :: (RandomGen g, Fractional t, Ord t, Random t) => [a] -> [t] -> Rand g a
wchoose_N :: (RandomGen g, Fractional t, Ord t, Random t) => [a] -> [t] -> Rand g a

-- | Variant of <a>choose</a> generating <i>k</i> values.
--   
--   <pre>
--   evalRand (nchoose 4 [3..9]) (mkStdGen 1) == [5,8,9,6]
--   </pre>
nchoose :: RandomGen g => Int -> [a] -> Rand g [a]

-- | <tt>SimpleNumber.exprand</tt> generates exponentially distributed
--   random number in the given interval.
--   
--   <pre>
--   let r = replicateM 3 (exprand 10 100 &gt;&gt;= return.floor)
--   in evalRand r (mkStdGen 1) == [22,21,13]
--   </pre>
exprand :: (Floating n, Random n, RandomGen g) => n -> n -> Rand g n

-- | Variant of <a>exprand</a> generating <i>k</i> values.
--   
--   <pre>
--   let r = nexprand 3 10 100 &gt;&gt;= return . map floor
--   in evalRand r (mkStdGen 1) == [22,21,13]
--   </pre>
nexprand :: (Floating n, Random n, RandomGen g) => Int -> n -> n -> Rand g [n]
