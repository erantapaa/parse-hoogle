-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Signal processing and EEG data analysis
--   
@package hsignal
@version 0.2.7.1


-- | Noise generation functions
module Numeric.Signal.Noise

-- | 1/f scale invariant noise
pinkNoise :: Double -> Int -> Int -> Vector Double

-- | The method is briefly descirbed in Lennon, J.L. "Red-shifts and red
--   herrings in geographical ecology", Ecography, Vol. 23, p101-113 (2000)
--   
--   Matlab version Written by Jon Yearsley 1 May 2004
--   j.yearsley@macaulay.ac.uk
--   
--   Creates 1/f scale invariant spatial noise
spatialNoise :: Double -> Int -> Int -> Int -> Matrix Double

-- | generate noise from a power spectrum
powerNoise :: Vector Double -> Int -> Vector Double


-- | Signal processing functions
module Numeric.Signal
class Convolvable a
convolve :: Convolvable a => a -> a -> a
class (Storable a, Container Vector a, Num (Vector a), Convert a, Floating (Vector a), RealElement a, Num a) => Filterable a

-- | coefficients of a Hamming window
hamming :: Filterable a => Int -> Vector a

-- | Welch (1967) power spectrum density using periodogram/FFT method
pwelch :: Int -> Int -> Vector Double -> (Vector Double, Vector Double)

-- | produce an FIR filter
fir :: (Filterable a, Container Vector (Complex a), Convert (Complex a), Double ~ DoubleOf a) => Int -> [(a, a)] -> Int -> Int -> Vector a -> Vector a

-- | standard FIR filter | FIR filter with grid a power of 2 greater than
--   the order, ramp = grid/16, hamming window
standard_fir :: (Filterable a, Double ~ DoubleOf a, Container Vector (Complex a), Convert (Complex a)) => Int -> [(a, a)] -> Vector a

-- | a broadband FIR
broadband_fir :: (Filterable a, Double ~ DoubleOf a, Container Vector (Complex a), Convert (Complex a)) => Int -> (Int, Int) -> Vector a

-- | determine the frequency response of a filter, given a vector of
--   frequencies
freqzF :: (Filterable a, Double ~ DoubleOf a, Filterable (DoubleOf a)) => Vector a -> Vector a -> Int -> Vector a -> Vector a

-- | determine the frequency response of a filter, given a number of points
--   and sampling rate
freqzN :: (Filterable a, Enum a, Double ~ DoubleOf a) => Vector a -> Vector a -> Int -> Int -> (Vector a, Vector a)

-- | filters the signal
filter :: Filterable a => Vector a -> Vector a -> Int -> Vector a -> Vector a

-- | a broadband filter
broadband_filter :: (Filterable a, Double ~ DoubleOf a, Container Vector (Complex a), Convert (Complex a)) => Int -> (Int, Int) -> Vector a -> Vector a

-- | an analytic signal is the original signal with Hilbert-transformed
--   signal as imaginary component
analytic_signal :: Vector Double -> Vector (Complex Double)

-- | the power (amplitude^2 = v * (conj c)) of an analytic signal
analytic_power :: Filterable a => Vector (Complex Double) -> Vector a

-- | the phase of an analytic signal
analytic_phase :: (Filterable a, Container Vector a, Double ~ DoubleOf a) => Vector (Complex a) -> Vector a

-- | unwrap the phase of signal (input expected to be within (-pi,pi))
unwrap :: Filterable a => Vector a -> Vector a

-- | cross covariance of two signals the cross correlation is computed by
--   dividing the result by the product of the two standard deviations
cross_covariance :: Filterable a => Int -> Vector a -> Vector a -> (a, a, Vector a)

-- | cross correlation of two signals
cross_correlation :: Filterable a => Int -> Vector a -> Vector a -> Vector a

-- | compute the cross spectrum
cross_spectrum :: (Filterable a, Double ~ DoubleOf a) => Int -> Vector a -> Vector a -> Vector (Complex Double)

-- | auto covariance of two signals the auto correlation is computed by
--   dividing the result by the variance
auto_covariance :: Filterable a => Int -> Vector a -> (a, Vector a)

-- | auto correlation of two signals
auto_correlation :: Filterable a => Int -> Vector a -> Vector a

-- | remove a linear trend from data
detrend :: Int -> Vector Double -> Vector Double

-- | resize the vector to length n by resampling
resize :: Filterable a => Int -> Vector a -> Vector a

-- | resample, take one sample every n samples in the original
downsample :: Filterable a => Int -> Vector a -> Vector a

-- | the difference between consecutive elements of a vector
deriv :: Filterable a => Vector a -> Vector a

-- | cumulative sum of a series
cumulative_sum :: Filterable a => Vector a -> Vector a


-- | Signal processing functions, multichannel datatype
--   
--   link with '-threaded' and run with +RTS -Nn, where n is the number of
--   CPUs
module Numeric.Signal.Multichannel

-- | data type with multiple channels
data Multichannel a
readMultichannel :: Binary (Multichannel a) => FilePath -> IO (Multichannel a)
writeMultichannel :: Binary (Multichannel a) => FilePath -> Multichannel a -> IO ()

-- | create a multichannel data type
createMultichannel :: Storable a => Int -> Int -> [Vector a] -> Multichannel a

-- | the sampling rate
sampling_rate :: Multichannel a -> Int

-- | the bits of precision
precision :: Multichannel a -> Int

-- | the number of channels
channels :: Multichannel a -> Int

-- | the length, in samples
samples :: Multichannel a -> Int

-- | was the data detrended?
detrended :: Multichannel a -> Bool

-- | was the data filtered?
filtered :: Multichannel a -> Maybe (Int, Int)

-- | extract one channel
getChannel :: Int -> Multichannel a -> Vector a

-- | extract all channels
getChannels :: Multichannel a -> Array Int (Vector a)

-- | convert the data to a matrix with channels as rows
toMatrix :: Element a => Multichannel a -> Matrix a

-- | map a function executed concurrently
mapConcurrently :: Storable b => (Vector a -> Vector b) -> Multichannel a -> Multichannel b

-- | detrend the data with a specified window size
detrend :: Int -> Multichannel Double -> Multichannel Double

-- | filter the data with the given passband
filter :: (Filterable a, Double ~ DoubleOf a, Container Vector (Complex a), Convert (Complex a)) => (Int, Int) -> Multichannel a -> Multichannel a

-- | extract a slice of the data
slice :: Storable a => Int -> Int -> Multichannel a -> Multichannel a

-- | calculate histograms
histograms :: (Filterable a, Double ~ DoubleOf a) => Array Int (Vector a) -> Int -> (Double, Double) -> Int -> Int -> (Double, Double) -> (Double, Double) -> (Array Int Histogram, Array (Int, Int) Histogram2D)

-- | calculate the entropy of the phase difference between pairs of
--   channels (fills upper half of matrix)
entropy_delta_phase :: (Filterable a, Double ~ DoubleOf a) => Multichannel a -> Matrix Double

-- | calculate the mutual information of the phase between pairs of
--   channels (fills upper half of matrix)
mi_phase :: (Filterable a, Double ~ DoubleOf a) => Multichannel a -> Matrix Double
instance Binary (Multichannel (Complex Float))
instance Binary (Multichannel (Complex Double))
instance Binary (Multichannel Float)
instance Binary (Multichannel Double)


module Numeric.Signal.EEG
loadBDF :: FilePath -> IO (Maybe (Multichannel Float))
