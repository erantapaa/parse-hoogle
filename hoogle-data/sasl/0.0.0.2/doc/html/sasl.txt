-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SASL implementation using simple-pipe
--   
--   Example programs
--   
--   SCRAM-SHA-1 Client sample
--   
--   scramSha1sv.txt
--   
--   <pre>
--   r=00DEADBEEF007658cddf-0e44-4de2-87df-4132bce97f4,s=cGVwcGVy,i=4492
--   v=q0+IZgUtQTHYItaurlNyET1imLI=
--   success
--   </pre>
--   
--   examples/clientS.hs
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import "monads-tf" Control.Monad.State
--   import Data.Pipe
--   import Data.Pipe.ByteString
--   import System.IO
--   import Network.Sasl
--   import Network.Sasl.ScramSha1.Client
--   
--   import qualified Data.ByteString as BS
--   
--   data St = St [(BS.ByteString, BS.ByteString)] deriving Show
--   
--   instance SaslState St where
--   	getSaslState (St s) = s
--   	putSaslState s _ = St s
--   
--   serverFile :: String
--   serverFile = "examples/scramSha1sv.txt"
--   
--   main :: IO ()
--   main = do
--   	let	(_, (_, p)) = sasl
--   	r &lt;- runPipe (fromFileLn serverFile =$= input =$= p =$= toHandleLn stdout)
--   		`runStateT` St [
--   			("username", "yoshikuni"),
--   			("password", "password"),
--   			("cnonce", "00DEADBEEF00") ]
--   	print r
--   
--   input :: Pipe BS.ByteString (Either Success BS.ByteString) (StateT St IO) ()
--   input = await &gt;&gt;= \mbs -&gt; case mbs of
--   	Just "success" -&gt; yield . Left $ Success Nothing
--   	Just ch -&gt; yield (Right ch) &gt;&gt; input
--   	_ -&gt; return ()
--   </pre>
--   
--   SCRAM-SHA-1 Server sample
--   
--   scramSha1cl.txt
--   
--   <pre>
--   n,,n=yoshikuni,r=00DEADBEEF00
--   c=biws,r=00DEADBEEF007658cddf-0e44-4de2-87df-4132bce97f4,p=zup7ghwpAW43cP4Xu3YZTNnHo0g=
--   </pre>
--   
--   examples/serverS.hs
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import "monads-tf" Control.Monad.State
--   import Data.Pipe
--   import Data.Pipe.ByteString
--   import System.IO
--   import Network.Sasl
--   import Network.Sasl.ScramSha1.Server
--   
--   import qualified Data.ByteString as BS
--   
--   data St = St [(BS.ByteString, BS.ByteString)] deriving Show
--   
--   instance SaslState St where
--   	getSaslState (St s) = s
--   	putSaslState s _ = St s
--   
--   clientFile :: String
--   clientFile = "examples/scramSha1cl.txt"
--   
--   main :: IO ()
--   main = do
--   	let	slt = "pepper"
--   		i = 4492
--   		(stk, svk) = salt "password" slt i
--   		(_, (_, p)) = sasl $ \"yoshikuni" -&gt; return (slt, stk, svk, i)
--   	r &lt;- runPipe (fromFileLn clientFile =$= p =$= output =$= toHandleLn stdout)
--   		`runStateT` St [("snonce", "7658cddf-0e44-4de2-87df-4132bce97f4")]
--   	print r
--   
--   output :: Pipe (Either Success BS.ByteString) BS.ByteString (StateT St IO) ()
--   output = await &gt;&gt;= \mch -&gt; case mch of
--   	Just (Left (Success Nothing)) -&gt; yield "success"
--   	Just (Left (Success (Just bs))) -&gt; yield bs
--   	Just (Right bs) -&gt; yield bs &gt;&gt; output
--   	_ -&gt; return ()
--   </pre>
--   
--   See examples directory for more examples.
@package sasl
@version 0.0.0.2

module Network.Sasl
data Client m
Client :: (Maybe (Send m)) -> [(Receive m, Send m)] -> (Maybe (Receive m)) -> Client m
client :: Monad m => Client m -> (Bool, Pipe (Either Success ByteString) ByteString m ())
data Server m
Server :: (Maybe (Receive m)) -> [(Send m, Receive m)] -> (Maybe (Send m)) -> Server m
server :: Monad m => Server m -> (Bool, Pipe ByteString (Either Success ByteString) m ())
data Success
Success :: (Maybe ByteString) -> Success
class SaslState s
initSaslState :: SaslState s => s
getSaslState :: SaslState s => s -> [(ByteString, ByteString)]
putSaslState :: SaslState s => [(ByteString, ByteString)] -> s -> s
type Send m = m ByteString
type Receive m = ByteString -> m ()
class Error e => SaslError e
fromSaslError :: SaslError e => SaslErrorType -> ByteString -> e
data SaslErrorType
Aborted :: SaslErrorType
AccountDisabled :: SaslErrorType
CredentialExpired :: SaslErrorType
EncryptionRequired :: SaslErrorType
IncorrectEncoding :: SaslErrorType
InvalidAuthzid :: SaslErrorType
InvalidMechanism :: SaslErrorType
MalformedRequest :: SaslErrorType
MechanismTooWeak :: SaslErrorType
NotAuthorized :: SaslErrorType
TemporaryAuthFailure :: SaslErrorType
SaslErrorType :: ByteString -> SaslErrorType
instance Show Success
instance Show SaslErrorType
instance SaslError IOError

module Network.Sasl.Plain.Client
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => (ByteString, (Bool, Pipe (Either Success ByteString) ByteString m ()))

module Network.Sasl.Plain.Server
sasl :: (MonadState m, SaslState (StateType m), MonadError m, SaslError (ErrorType m)) => (ByteString -> ByteString -> ByteString -> m ()) -> (ByteString, (Bool, Pipe ByteString (Either Success ByteString) m ()))

module Network.Sasl.External.Client
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => (ByteString, (Bool, Pipe (Either Success ByteString) ByteString m ()))

module Network.Sasl.External.Server
sasl :: (MonadState m, SaslState (StateType m), MonadError m, SaslError (ErrorType m)) => (ByteString -> m ()) -> (ByteString, (Bool, Pipe ByteString (Either Success ByteString) m ()))

module Network.Sasl.DigestMd5.Client
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => (ByteString, (Bool, Pipe (Either Success ByteString) ByteString m ()))

module Network.Sasl.DigestMd5.Server
sasl :: (MonadState m, SaslState (StateType m), MonadError m, SaslError (ErrorType m)) => (ByteString -> m ByteString) -> (ByteString, (Bool, Pipe ByteString (Either Success ByteString) m ()))
mkStored :: ByteString -> ByteString -> ByteString -> ByteString

module Network.Sasl.ScramSha1.Client
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => (ByteString, (Bool, Pipe (Either Success ByteString) ByteString m ()))
saltedPassword :: ByteString -> ByteString -> Int -> ByteString
clientKey :: ByteString -> ByteString
serverKey :: ByteString -> ByteString

module Network.Sasl.ScramSha1.Server
sasl :: (MonadState m, SaslState (StateType m), MonadError m, SaslError (ErrorType m)) => (ByteString -> m (ByteString, ByteString, ByteString, Int)) -> (ByteString, (Bool, Pipe ByteString (Either Success ByteString) m ()))
salt :: ByteString -> ByteString -> Int -> (ByteString, ByteString)
