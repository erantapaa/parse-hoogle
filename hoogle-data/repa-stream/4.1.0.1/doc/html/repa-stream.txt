-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stream functions not present in the vector library.
--   
@package repa-stream
@version 4.1.0.1


-- | Data types used during low-level fusion optimisations.
--   
--   These types are synonyms for <tt>Maybe (a, b)</tt>, which are strict
--   in the components. They can be used to ensure that we do not suspend
--   the computation that produces these components in fused code.
module Data.Repa.Option

-- | A strict <a>Maybe</a> type.
data Option a
Some :: !a -> Option a
None :: Option a

-- | Convert an <a>Option</a> to a <a>Maybe</a>.
fromOption :: Option a -> Maybe a

-- | Convert a <a>Maybe</a> to an <a>Option</a>.
toOption :: Maybe a -> Option a

-- | A strict <a>Maybe</a> type, with two parameters.
data Option2 a b
Some2 :: !a -> !b -> Option2 a b
None2 :: Option2 a b

-- | Convert an <a>Option2</a> to a <a>Maybe</a>.
fromOption2 :: Option2 a b -> Maybe (a, b)

-- | Convert a <a>Maybe</a> to an <a>Option2</a>.
toOption2 :: Maybe (a, b) -> Option2 a b

-- | A strict <a>Maybe</a> type with three parameters.
data Option3 a b c
Some3 :: !a -> !b -> !c -> Option3 a b c
None3 :: Option3 a b c

-- | Convert an <a>Option2</a> to a <a>Maybe</a>.
fromOption3 :: Option3 a b c -> Maybe (a, b, c)

-- | Convert a <a>Maybe</a> to an <a>Option3</a>.
toOption3 :: Maybe (a, b, c) -> Option3 a b c
instance Show a => Show (Option a)
instance (Show a, Show b) => Show (Option2 a b)
instance (Show a, Show b, Show c) => Show (Option3 a b c)


-- | <ul>
--   <li>See the <a>Data.Repa.Vector.Unboxed</a> module for examples of how
--   these functions can be used.</li>
--   </ul>
module Data.Repa.Stream

-- | Extract segments from some source array and concatenate them.
extractS :: Monad m => (Int -> a) -> Stream m (Int, Int) -> Stream m a

-- | Insert elements produced by the given function in to a stream.
insertS :: Monad m => (Int -> Maybe a) -> Stream m a -> Stream m a

-- | Merge two key-value streams.
--   
--   The streams are assumed to be pre-sorted on the keys.
mergeS :: (Monad m, Ord k) => (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> Stream m (k, a) -> Stream m (k, b) -> Stream m (k, c)

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compactS :: Monad m => (s -> a -> (Maybe b, s)) -> s -> Stream m a -> Stream m b

-- | Like <tt>compact</tt> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactInS :: Monad m => (a -> a -> (Maybe a, a)) -> Stream m a -> Stream m a

-- | Return the <a>Just</a> elements from a stream, dropping the
--   <a>Nothing</a>s.
catMaybesS :: Monad m => Stream m (Maybe a) -> Stream m a

-- | Given predicates that detect the beginning and end of some interesting
--   segment of information, scan through a vector looking for when these
--   segments begin and end.
findSegmentsS :: Monad m => (a -> Bool) -> (a -> Bool) -> i -> Stream m (i, a) -> Stream m (i, i)

-- | Given predicates that detect the begining and end of interesting
--   segments of information, scan through a vector looking for when these
--   begin and end.
diceSepS :: Monad m => (a -> Bool) -> (a -> Bool) -> Stream m a -> Stream m (Maybe (Int, Int), Maybe (Int, Int))

-- | Given a stream of starting and ending indices for some segments,
--   convert it to a stream of starting indices and segment lengths.
--   
--   <ul>
--   <li>The ending indices must be after the starting indices, otherwise
--   the result will contain negative lengths.</li>
--   </ul>
startLengthsOfSegsS :: Monad m => Stream m (Int, Int) -> Stream m (Int, Int)

-- | Given a stream of keys and values, and a successor function for keys,
--   if the stream is has keys missing in the sequence then insert the
--   missing key, copying forward the the previous value.
padForwardS :: (Monad m, Ord k) => (k -> k) -> Stream m (k, v) -> Stream m (k, v)

-- | Interleaved <a>enumFromTo</a>.
--   
--   Given a vector of starting values, and a vector of stopping values,
--   produce an stream of elements where we increase each of the starting
--   values to the stopping values in a round-robin order. Also produce a
--   vector of result segment lengths.
--   
--   <pre>
--   unsafeRatchetS [10,20,30,40] [15,26,33,47]
--   =  [10,20,30,40       -- 4
--      ,11,21,31,41       -- 4
--      ,12,22,32,42       -- 4
--      ,13,23   ,43       -- 3
--      ,14,24   ,44       -- 3
--         ,25   ,45       -- 2
--               ,46]      -- 1
--   
--          ^^^^             ^^^
--        Elements         Lengths
--   </pre>
--   
--   The function takes the starting values in a mutable vector and updates
--   it during computation. Computation proceeds by making passes through
--   the mutable vector and updating the starting values until they match
--   the stopping values.
--   
--   UNSAFE: Both input vectors must have the same length, but this is not
--   checked.
unsafeRatchetS :: (MVector vm Int, Vector vv Int) => vm (PrimState IO) Int -> vv Int -> IORef (vm (PrimState IO) Int) -> Stream IO Int


-- | <ul>
--   <li>See the <a>Data.Repa.Vector.Unboxed</a> module for examples of how
--   these functions can be used.</li>
--   </ul>
module Data.Repa.Chain

-- | A chain is an abstract, stateful producer of elements. It is similar a
--   stream as used in stream fusion, except that internal state is visible
--   in its type. This allows the computation to be paused and resumed at a
--   later point.
data Chain m s a
Chain :: Size -> s -> (s -> m (Step s a)) -> Chain m s a

-- | Expected size of the output.
mchainSize :: Chain m s a -> Size

-- | Starting state.
mchainState :: Chain m s a -> s

-- | Step the chain computation.
mchainStep :: Chain m s a -> s -> m (Step s a)

-- | Result of a chain computation step.
data Step s a

-- | Yield an output value and a new seed.
Yield :: !a -> !s -> Step s a

-- | Provide just a new seed.
Skip :: !s -> Step s a

-- | Signal that the computation has finished.
Done :: !s -> Step s a

-- | Lift a pure chain to a monadic chain.
liftChain :: Monad m => Chain Identity s a -> Chain m s a

-- | Resume a chain computation from a previous state.
resumeChain :: Monad m => s -> Chain m s a -> Chain m s a

-- | A weave is a generalized merge of two input chains.
--   
--   The worker function takes the current state, values from the left and
--   right input chains, and produces a <a>Turn</a> which describes any
--   output at that point, as well as how the input chains should be
--   advanced.
weaveC :: Monad m => (k -> Option aL -> Option aR -> m (Turn k aX)) -> k -> Chain m sL aL -> Chain m sR aR -> Chain m (Weave sL aL sR aR k) aX

-- | Internal state of a weave.
data Weave sL aL sR aR k

-- | What to do after considering two input elements.
data Turn k a

-- | Give an element and a new state.
Give :: !a -> !k -> !Move -> Turn k a

-- | Move to the next input.
Next :: !k -> !Move -> Turn k a

-- | Weave is finished for now.
Finish :: !k -> !Move -> Turn k a

-- | How to move the input chains after considering to input elements.
data Move
MoveLeft :: Move
MoveRight :: Move
MoveBoth :: Move
MoveNone :: Move

-- | Apply a <a>Move</a> instruction to a weave state.
move :: k -> Move -> Weave s1 a1 s2 a2 k -> Weave s1 a1 s2 a2 k

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other.
foldsC :: Monad m => (a -> b -> m b) -> b -> Option3 n Int b -> Chain m sLen (n, Int) -> Chain m sVal a -> Chain m (Folds sLen sVal n a b) (n, b)

-- | Return state of a folds operation.
data Folds sLens sVals n a b
Folds :: !sLens -> !sVals -> !(Option n) -> !Int -> !b -> Folds sLens sVals n a b

-- | State of lengths chain.
_stateLens :: Folds sLens sVals n a b -> !sLens

-- | State of values chain.
_stateVals :: Folds sLens sVals n a b -> !sVals

-- | If we're currently in a segment, then hold its name,
_nameSeg :: Folds sLens sVals n a b -> !(Option n)

-- | Length of current segment.
_lenSeg :: Folds sLens sVals n a b -> !Int

-- | Accumulated value of current segment.
_valSeg :: Folds sLens sVals n a b -> !b

-- | Perform a left-to-right scan through an input vector, maintaining a
--   state value between each element. For each element of input we may or
--   may not produce an element of output.
scanMaybeC :: Monad m => (k -> a -> m (k, Maybe b)) -> k -> Chain m s a -> Chain m (s, k) b

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
groupsByC :: Monad m => (a -> a -> m Bool) -> Maybe (a, Int) -> Chain m s a -> Chain m (s, Maybe (a, Int)) (a, Int)


-- | Converting <tt>Stream</tt>s and <a>Chain</a>s to and from generic
--   <tt>Vector</tt>s.
--   
--   <ul>
--   <li>NOTE: Support for streams of unknown length is not complete.</li>
--   </ul>
module Data.Repa.Vector.Generic

-- | Unstream some elements to two separate vectors.
--   
--   <a>Nothing</a> values are ignored.
unstreamToVector2 :: (PrimMonad m, Vector v a, Vector v b) => Stream m (Maybe a, Maybe b) -> m (v a, v b)

-- | Unstream some elements to two separate mutable vectors.
--   
--   <a>Nothing</a> values are ignored.
unstreamToMVector2 :: (PrimMonad m, MVector v a, MVector v b) => Stream m (Maybe a, Maybe b) -> m (v (PrimState m) a, v (PrimState m) b)

-- | Produce a chain from a generic vector.
chainOfVector :: (Monad m, Vector v a) => v a -> Chain m Int a

-- | Compute a chain into a generic vector.
unchainToVector :: (PrimMonad m, Vector v a) => Chain m s a -> m (v a, s)

-- | Compute a chain into a generic mutable vector.
unchainToMVector :: (PrimMonad m, MVector v a) => Chain m s a -> m (v (PrimState m) a, s)

-- | Interleaved <a>enumFromTo</a>.
--   
--   Given a vector of starting values, and a vector of stopping values,
--   produce an stream of elements where we increase each of the starting
--   values to the stopping values in a round-robin order. Also produce a
--   vector of result segment lengths.
--   
--   <pre>
--   unsafeRatchetS [10,20,30,40] [15,26,33,47]
--   =  [10,20,30,40       -- 4
--      ,11,21,31,41       -- 4
--      ,12,22,32,42       -- 4
--      ,13,23   ,43       -- 3
--      ,14,24   ,44       -- 3
--         ,25   ,45       -- 2
--               ,46]      -- 1
--   
--          ^^^^             ^^^
--        Elements         Lengths
--   </pre>
ratchet :: (Vector v Int, Vector v (Int, Int)) => v (Int, Int) -> (v Int, v Int)

-- | Extract segments from some source array and concatenate them.
--   
--   <pre>
--   let arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
--   in  extractS (index arr) [(0, 1), (3, 3), (2, 6)]
--   
--    =&gt; [10, 13, 14, 15, 12, 13, 14, 15, 16, 17]
--   </pre>
extract :: (Vector v (Int, Int), Vector v a) => (Int -> a) -> v (Int, Int) -> v a

-- | Insert elements produced by the given function into a vector.
insert :: Vector v a => (Int -> Maybe a) -> v a -> v a

-- | Merge two pre-sorted key-value streams.
merge :: (Ord k, Vector v k, Vector v (k, a), Vector v (k, b), Vector v (k, c)) => (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> v (k, a) -> v (k, b) -> v (k, c)

-- | Like <a>merge</a>, but only produce the elements where the worker
--   functions return <a>Just</a>.
mergeMaybe :: (Ord k, Vector v k, Vector v (k, a), Vector v (k, b), Vector v (k, c)) => (k -> a -> b -> Maybe c) -> (k -> a -> Maybe c) -> (k -> b -> Maybe c) -> v (k, a) -> v (k, b) -> v (k, c)

-- | Given predicates that detect the beginning and end of some interesting
--   segment of information, scan through a vector looking for when these
--   segments begin and end. Return vectors of the segment starting
--   positions and lengths.
--   
--   <ul>
--   <li>As each segment must end on a element where the ending predicate
--   returns True, the miniumum segment length returned is 1.</li>
--   </ul>
findSegments :: (Vector v a, Vector v Int, Vector v (Int, Int)) => (a -> Bool) -> (a -> Bool) -> v a -> (v Int, v Int)

-- | Given predicates that detect the beginning and end of some interesting
--   segment of information, scan through a vector looking for when these
--   segments begin and end. Return vectors of the segment starting
--   positions and lengths.
findSegmentsFrom :: (Vector v Int, Vector v (Int, Int)) => (a -> Bool) -> (a -> Bool) -> Int -> (Int -> a) -> (v Int, v Int)

-- | Dice a vector stream into rows and columns.
diceSep :: (Vector v a, Vector v (Int, Int)) => (a -> Bool) -> (a -> Bool) -> v a -> (v (Int, Int), v (Int, Int))

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compact :: (Vector v a, Vector v b) => (s -> a -> (Maybe b, s)) -> s -> v a -> v b

-- | Like <a>compact</a> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactIn :: Vector v a => (a -> a -> (Maybe a, a)) -> v a -> v a

-- | Given a stream of keys and values, and a successor function for keys,
--   if the stream is has keys missing in the sequence then insert the
--   missing key, copying forward the the previous value.
padForward :: (Ord k, Vector v (k, a)) => (k -> k) -> v (k, a) -> v (k, a)

-- | Perform a left-to-right scan through an input vector, maintaining a
--   state value between each element. For each element of input we may or
--   may not produce an element of output.
scanMaybe :: (Vector v1 a, Vector v2 b) => (s -> a -> (s, Maybe b)) -> s -> v1 a -> (v2 b, s)

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
--   
--   <pre>
--   groupsBy (==) (Just (<tt>a</tt>, 4)) 
--                 ['a', 'a', 'a', 'b', 'b', 'c', 'd', 'd'] 
--    =&gt; ([(<tt>a</tt>, 7), (<tt>b</tt>, 2), (<tt>c</tt>, 1)], Just ('d', 2))
--   </pre>
groupsBy :: (Vector v1 a, Vector v2 (a, Int)) => (a -> a -> Bool) -> Maybe (a, Int) -> v1 a -> (v2 (a, Int), Maybe (a, Int))

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other. In the resulting state, <a>foldLensState</a> is the index
--   into the lengths vector *after* the last one that was consumed. If
--   this equals the length of the lengths vector then all segment lengths
--   were consumed. Similarly for the elements vector.
folds :: (Vector v (n, Int), Vector v a, Vector v (n, b)) => (a -> b -> b) -> b -> Option3 n Int b -> v (n, Int) -> v a -> (v (n, b), Folds Int Int n a b)

-- | Return state of a folds operation.
data Folds sLens sVals n a b
Folds :: !sLens -> !sVals -> !(Option n) -> !Int -> !b -> Folds sLens sVals n a b

-- | State of lengths chain.
_stateLens :: Folds sLens sVals n a b -> !sLens

-- | State of values chain.
_stateVals :: Folds sLens sVals n a b -> !sVals

-- | If we're currently in a segment, then hold its name,
_nameSeg :: Folds sLens sVals n a b -> !(Option n)

-- | Length of current segment.
_lenSeg :: Folds sLens sVals n a b -> !Int

-- | Accumulated value of current segment.
_valSeg :: Folds sLens sVals n a b -> !b

module Data.Repa.Vector.Unboxed

-- | Produce a chain from a generic vector.
chainOfVector :: (Monad m, Unbox a) => Vector a -> Chain m Int a

-- | Compute a chain into a vector.
unchainToVector :: (PrimMonad m, Unbox a) => Chain m s a -> m (Vector a, s)

-- | Compute a chain into a mutable vector.
unchainToMVector :: (PrimMonad m, Unbox a) => Chain m s a -> m (MVector (PrimState m) a, s)

-- | Interleaved <a>enumFromTo</a>.
--   
--   Given a vector of starting values, and a vector of stopping values,
--   produce an stream of elements where we increase each of the starting
--   values to the stopping values in a round-robin order. Also produce a
--   vector of result segment lengths.
--   
--   <pre>
--   unsafeRatchetS [10,20,30,40] [15,26,33,47]
--   =  [10,20,30,40       -- 4
--      ,11,21,31,41       -- 4
--      ,12,22,32,42       -- 4
--      ,13,23   ,43       -- 3
--      ,14,24   ,44       -- 3
--         ,25   ,45       -- 2
--               ,46]      -- 1
--   
--          ^^^^             ^^^
--        Elements         Lengths
--   </pre>
ratchet :: Vector (Int, Int) -> (Vector Int, Vector Int)

-- | Extract segments from some source array and concatenate them.
--   
--   <pre>
--   let arr = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
--   in  extractS (index arr) [(0, 1), (3, 3), (2, 6)]
--   
--    =&gt; [10, 13, 14, 15, 12, 13, 14, 15, 16, 17]
--   </pre>
extract :: Unbox a => (Int -> a) -> Vector (Int, Int) -> Vector a

-- | Insert elements produced by the given function into a vector.
insert :: Unbox a => (Int -> Maybe a) -> Vector a -> Vector a

-- | Merge two pre-sorted key-value streams.
merge :: (Ord k, Unbox k, Unbox a, Unbox b, Unbox c) => (k -> a -> b -> c) -> (k -> a -> c) -> (k -> b -> c) -> Vector (k, a) -> Vector (k, b) -> Vector (k, c)

-- | Like <a>merge</a>, but only produce the elements where the worker
--   functions return <a>Just</a>.
mergeMaybe :: (Ord k, Unbox k, Unbox a, Unbox b, Unbox c) => (k -> a -> b -> Maybe c) -> (k -> a -> Maybe c) -> (k -> b -> Maybe c) -> Vector (k, a) -> Vector (k, b) -> Vector (k, c)

-- | Given predicates that detect the beginning and end of some interesting
--   segment of information, scan through a vector looking for when these
--   segments begin and end. Return vectors of the segment starting
--   positions and lengths.
--   
--   <ul>
--   <li>As each segment must end on a element where the ending predicate
--   returns True, the miniumum segment length returned is 1.</li>
--   </ul>
findSegments :: Unbox a => (a -> Bool) -> (a -> Bool) -> Vector a -> (Vector Int, Vector Int)

-- | Given predicates that detect the beginning and end of some interesting
--   segment of information, scan through a vector looking for when these
--   segments begin and end. Return vectors of the segment starting
--   positions and lengths.
findSegmentsFrom :: (a -> Bool) -> (a -> Bool) -> Int -> (Int -> a) -> (Vector Int, Vector Int)

-- | Dice a vector stream into rows and columns.
diceSep :: Unbox a => (a -> Bool) -> (a -> Bool) -> Vector a -> (Vector (Int, Int), Vector (Int, Int))

-- | Combination of <tt>fold</tt> and <a>filter</a>.
--   
--   We walk over the stream front to back, maintaining an accumulator. At
--   each point we can chose to emit an element (or not)
compact :: (Unbox a, Unbox b) => (s -> a -> (Maybe b, s)) -> s -> Vector a -> Vector b

-- | Like <a>compact</a> but use the first value of the stream as the
--   initial state, and add the final state to the end of the output.
compactIn :: Unbox a => (a -> a -> (Maybe a, a)) -> Vector a -> Vector a

-- | Given a stream of keys and values, and a successor function for keys,
--   if the stream is has keys missing in the sequence then insert the
--   missing key, copying forward the the previous value.
padForward :: (Unbox k, Unbox v, Ord k) => (k -> k) -> Vector (k, v) -> Vector (k, v)

-- | Perform a left-to-right scan through an input vector, maintaining a
--   state value between each element. For each element of input we may or
--   may not produce an element of output.
scanMaybe :: (Unbox a, Unbox b) => (s -> a -> (s, Maybe b)) -> s -> Vector a -> (Vector b, s)

-- | From a stream of values which has consecutive runs of idential values,
--   produce a stream of the lengths of these runs.
--   
--   <pre>
--   groupsBy (==) (Just (<tt>a</tt>, 4)) 
--                 ['a', 'a', 'a', 'b', 'b', 'c', 'd', 'd'] 
--    =&gt; ([(<tt>a</tt>, 7), (<tt>b</tt>, 2), (<tt>c</tt>, 1)], Just ('d', 2))
--   </pre>
groupsBy :: Unbox a => (a -> a -> Bool) -> Maybe (a, Int) -> Vector a -> (Vector (a, Int), Maybe (a, Int))

-- | Segmented fold over vectors of segment lengths and input values.
--   
--   The total lengths of all segments need not match the length of the
--   input elements vector. The returned <a>Folds</a> state can be
--   inspected to determine whether all segments were completely folded, or
--   the vector of segment lengths or elements was too short relative to
--   the other. In the resulting state, <a>foldLensState</a> is the index
--   into the lengths vector *after* the last one that was consumed. If
--   this equals the length of the lengths vector then all segment lengths
--   were consumed. Similarly for the elements vector.
folds :: (Unbox n, Unbox a, Unbox b) => (a -> b -> b) -> b -> Option3 n Int b -> Vector (n, Int) -> Vector a -> (Vector (n, b), Folds Int Int n a b)

-- | Return state of a folds operation.
data Folds sLens sVals n a b
Folds :: !sLens -> !sVals -> !(Option n) -> !Int -> !b -> Folds sLens sVals n a b

-- | State of lengths chain.
_stateLens :: Folds sLens sVals n a b -> !sLens

-- | State of values chain.
_stateVals :: Folds sLens sVals n a b -> !sVals

-- | If we're currently in a segment, then hold its name,
_nameSeg :: Folds sLens sVals n a b -> !(Option n)

-- | Length of current segment.
_lenSeg :: Folds sLens sVals n a b -> !Int

-- | Accumulated value of current segment.
_valSeg :: Folds sLens sVals n a b -> !b
