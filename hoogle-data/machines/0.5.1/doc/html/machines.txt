-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Networked stream transducers
--   
@package machines
@version 0.5.1


module Data.Machine.Plan

-- | A <tt><a>Plan</a> k o a</tt> is a specification for a pure
--   <tt>Machine</tt>, that reads inputs selected by <tt>k</tt> with types
--   based on <tt>i</tt>, writes values of type <tt>o</tt>, and has
--   intermediate results of type <tt>a</tt>.
--   
--   A <tt><a>Plan</a> k o a</tt> can be used as a <tt><a>PlanT</a> k o m
--   a</tt> for any <tt><a>Monad</a> m</tt>.
--   
--   It is perhaps easier to think of <a>Plan</a> in its un-cps'ed form,
--   which would look like:
--   
--   <pre>
--   data <a>Plan</a> k o a
--     = Done a
--     | Yield o (Plan k o a)
--     | forall z. Await (z -&gt; Plan k o a) (k z) (Plan k o a)
--     | Fail
--   </pre>
type Plan k o a = forall m. PlanT k o m a

-- | Deconstruct a <a>Plan</a> without reference to a <a>Monad</a>.
runPlan :: PlanT k o Identity a -> (a -> r) -> (o -> r -> r) -> (forall z. (z -> r) -> k z -> r -> r) -> r -> r

-- | You can <tt>construct</tt> a <a>Plan</a> (or <a>PlanT</a>), turning it
--   into a <a>Machine</a> (or <a>MachineT</a>).
newtype PlanT k o m a
PlanT :: (forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r) -> PlanT k o m a
runPlanT :: PlanT k o m a -> forall r. (a -> m r) -> (o -> m r -> m r) -> (forall z. (z -> m r) -> k z -> m r -> m r) -> m r -> m r

-- | Output a result.
yield :: o -> Plan k o ()

-- | Like yield, except stops if there is no value to yield.
maybeYield :: Maybe o -> Plan k o ()

-- | Wait for input.
--   
--   <pre>
--   <a>await</a> = <a>awaits</a> <a>id</a>
--   </pre>
await :: Category k => Plan (k i) o i

-- | <pre>
--   <a>stop</a> = <a>empty</a>
--   </pre>
stop :: Plan k o a

-- | Wait for a particular input.
--   
--   <pre>
--   awaits <tt>L</tt>  :: <a>Plan</a> (<tt>T</tt> a b) o a
--   awaits <tt>R</tt>  :: <a>Plan</a> (<tt>T</tt> a b) o b
--   awaits <a>id</a> :: <a>Plan</a> (<a>Is</a> i) o i
--   </pre>
awaits :: k i -> Plan k o i

-- | Run a monadic action repeatedly yielding its results, until it returns
--   Nothing.
exhaust :: Monad m => m (Maybe a) -> PlanT k a m ()
instance MonadError e m => MonadError e (PlanT k o m)
instance MonadWriter w m => MonadWriter w (PlanT k o m)
instance MonadReader e m => MonadReader e (PlanT k o m)
instance MonadState s m => MonadState s (PlanT k o m)
instance MonadIO m => MonadIO (PlanT k o m)
instance MonadTrans (PlanT k o)
instance MonadPlus (PlanT k o m)
instance Monad (PlanT k o m)
instance Alternative (PlanT k o m)
instance Applicative (PlanT k o m)
instance Functor (PlanT k o m)


module Data.Machine.Type

-- | A <a>MachineT</a> reads from a number of inputs and may yield results
--   before stopping with monadic side-effects.
newtype MachineT m k o
MachineT :: m (Step k o (MachineT m k o)) -> MachineT m k o
runMachineT :: MachineT m k o -> m (Step k o (MachineT m k o))

-- | This is the base functor for a <a>Machine</a> or <a>MachineT</a>.
--   
--   Note: A <a>Machine</a> is usually constructed from <a>Plan</a>, so it
--   does not need to be CPS'd.
data Step k o r
Stop :: Step k o r
Yield :: o -> r -> Step k o r
Await :: (t -> r) -> (k t) -> r -> Step k o r

-- | A <a>Machine</a> reads from a number of inputs and may yield results
--   before stopping.
--   
--   A <a>Machine</a> can be used as a <tt><a>MachineT</a> m</tt> for any
--   <tt><a>Monad</a> m</tt>.
type Machine k o = forall m. Monad m => MachineT m k o

-- | Stop feeding input into model, taking only the effects.
runT_ :: Monad m => MachineT m k b -> m ()

-- | Stop feeding input into model and extract an answer
runT :: Monad m => MachineT m k b -> m [b]

-- | Run a pure machine and extract an answer.
run :: MachineT Identity k b -> [b]

-- | <pre>
--   <a>runMachine</a> = <a>runIdentity</a> . <a>runMachineT</a>
--   </pre>
runMachine :: MachineT Identity k o -> Step k o (MachineT Identity k o)

-- | Pack a <a>Step</a> of a <a>Machine</a> into a <a>Machine</a>.
encased :: Monad m => Step k o (MachineT m k o) -> MachineT m k o

-- | Compile a machine to a model.
construct :: Monad m => PlanT k o m a -> MachineT m k o

-- | Generates a model that runs a machine until it stops, then start it up
--   again.
--   
--   <pre>
--   <a>repeatedly</a> m = <a>construct</a> (<a>forever</a> m)
--   </pre>
repeatedly :: Monad m => PlanT k o m a -> MachineT m k o

-- | Evaluate a machine until it stops, and then yield answers according to
--   the supplied model.
before :: Monad m => MachineT m k o -> PlanT k o m a -> MachineT m k o
deconstruct :: Monad m => MachineT m k (Either a o) -> PlanT k o m a

-- | Use a predicate to mark a yielded value as the terminal value of this
--   <a>Machine</a>. This is useful in combination with <a>deconstruct</a>
--   to combine <a>Plan</a>s.
tagDone :: Monad m => (o -> Bool) -> MachineT m k o -> MachineT m k (Either o o)

-- | Use a function to produce and mark a yielded value as the terminal
--   value of a <a>Machine</a>. All yielded values for which the given
--   function returns <a>Nothing</a> are yielded down the pipeline, but the
--   first value for which the function returns a <a>Just</a> value will be
--   returned by a <a>Plan</a> created via <a>deconstruct</a>.
finishWith :: Monad m => (o -> Maybe r) -> MachineT m k o -> MachineT m k (Either r o)

-- | Connect different kinds of machines.
--   
--   <pre>
--   <a>fit</a> <a>id</a> = <a>id</a>
--   </pre>
fit :: Monad m => (forall a. k a -> k' a) -> MachineT m k o -> MachineT m k' o
fitM :: (Monad m, Monad m') => (forall a. m a -> m' a) -> MachineT m k o -> MachineT m' k o

-- | Given a handle, ignore all other inputs and just stream input from
--   that handle.
--   
--   <pre>
--   <a>pass</a> <a>id</a> :: <a>Process</a> a a
--   <a>pass</a> <a>L</a>  :: <a>Tee</a> a b a
--   <a>pass</a> <a>R</a>  :: <a>Tee</a> a b b
--   <a>pass</a> <a>X</a>  :: <a>Wye</a> a b a
--   <a>pass</a> <a>Y</a>  :: <a>Wye</a> a b b
--   <a>pass</a> <a>Z</a>  :: <a>Wye</a> a b (Either a b)
--   </pre>
pass :: k o -> Machine k o

-- | This is a stopped <a>Machine</a>
stopped :: Machine k b

-- | Transform a <a>Machine</a> by looking at a single step of that
--   machine.
stepMachine :: Monad m => MachineT m k o -> (Step k o (MachineT m k o) -> MachineT m k' o') -> MachineT m k' o'

-- | An input type that supports merging requests from multiple machines.
class Appliance k
applied :: (Appliance k, Monad m) => MachineT m k (a -> b) -> MachineT m k a -> MachineT m k b
instance m ~ Identity => Foldable (MachineT m k)
instance (Monad m, Appliance k) => Applicative (MachineT m k)
instance Monad m => Monoid (MachineT m k o)
instance Monad m => Semigroup (MachineT m k o)
instance Monad m => Pointed (MachineT m k)
instance Monad m => Functor (MachineT m k)
instance Functor (Step k o)


module Data.Machine.Stack

-- | This is a simple process type that knows how to push back input.
data Stack a r
Push :: a -> Stack a ()
Pop :: Stack a a

-- | Stream outputs from one <a>Machine</a> into another with the
--   possibility of pushing inputs back.
stack :: Monad m => MachineT m k a -> MachineT m (Stack a) o -> MachineT m k o

-- | Peek at the next value in the input stream without consuming it
peek :: Plan (Stack a) b a

-- | Pop the next value in the input stream
pop :: Plan (Stack a) b a

-- | Push back into the input stream
push :: a -> Plan (Stack a) b ()


-- | Allows bidirectional communication between two MachineT. Exposed the
--   same interface of Pipes library.
module Data.Machine.Pipe
data Exchange a' a b' b c
Request :: a' -> Exchange a' a b' b a
Respond :: b -> Exchange a' a b' b b'
type Proxy a' a b' b m c = MachineT m (Exchange a' a b' b) c

-- | <a>Effect</a>s neither <a>request</a> nor <a>respond</a>
type Effect m r = Proxy Void () () Void m r

-- | <tt>Client a' a</tt> sends requests of type <tt>a'</tt> and receives
--   responses of type <tt>a</tt>. <a>Client</a>s only <a>request</a> and
--   never <a>respond</a>.
type Client a' a m r = Proxy a' a () Void m r

-- | <tt>Server b' b</tt> receives requests of type <tt>b'</tt> and sends
--   responses of type <tt>b</tt>. <a>Server</a>s only <a>respond</a> and
--   never <a>request</a>.
type Server b' b m r = Proxy Void () b' b m r

-- | Like <a>Effect</a>, but with a polymorphic type
type Effect' m r = forall x' x y' y. Proxy x' x y' y m r

-- | Like <a>Server</a>, but with a polymorphic type
type Server' b' b m r = forall x' x. Proxy x' x b' b m r

-- | Like <a>Client</a>, but with a polymorphic type
type Client' a' a m r = forall y' y. Proxy a' a y' y m r

-- | Send a value of type a' upstream and block waiting for a reply of type
--   a. <a>request</a> is the identity of the request category.
request :: a' -> PlanT (Exchange a' a y' y) o m a

-- | Send a value of type a downstream and block waiting for a reply of
--   type a' <a>respond</a> is the identity of the respond category.
respond :: a -> PlanT (Exchange x' x a' a) o m a'

-- | Forward responses followed by requests. <a>push</a> is the identity of
--   the push category.
push :: Monad m => a -> Proxy a' a a' a m r

-- | Compose two proxies blocked while <a>request</a>ing data, creating a
--   new proxy blocked while <a>request</a>ing data. (<a>&gt;~&gt;</a>) is
--   the composition operator of the push category.
(>~>) :: Monad m => (_a -> Proxy a' a b' b m r) -> (b -> Proxy b' b c' c m r) -> _a -> Proxy a' a c' c m r

-- | (p &gt;&gt;~ f) pairs each <a>respond</a> in p with an <a>request</a>
--   in f.
(>>~) :: Monad m => Proxy a' a b' b m r -> (b -> Proxy b' b c' c m r) -> Proxy a' a c' c m r

-- | Forward requests followed by responses. <a>pull</a> is the identity of
--   the pull category.
pull :: Monad m => a' -> Proxy a' a a' a m r

-- | Compose two proxies blocked in the middle of <a>respond</a>ing,
--   creating a new proxy blocked in the middle of <a>respond</a>ing.
--   (<a>&gt;+&gt;</a>) is the composition operator of the pull category.
(>+>) :: Monad m => (b' -> Proxy a' a b' b m r) -> (_c' -> Proxy b' b c' c m r) -> _c' -> Proxy a' a c' c m r

-- | (f +&gt;&gt; p) pairs each <a>request</a> in p with a <a>respond</a>
--   in f.
(+>>) :: Monad m => (b' -> Proxy a' a b' b m r) -> Proxy b' b c' c m r -> Proxy a' a c' c m r

-- | Run a self-contained <a>Effect</a>, converting it back to the base
--   monad.
runEffect :: Monad m => Effect m o -> m [o]

-- | Like <a>runEffect</a> but discarding any produced value.
runEffect_ :: Monad m => Effect m o -> m ()


module Data.Machine.Is

-- | Witnessed type equality
data Is a b
Refl :: Is a a
instance Category Is
instance a ~ b => Read (Is a b)
instance a ~ b => Monoid (Is a b)
instance Ord (Is a b)
instance Eq (Is a b)
instance Show (Is a b)


module Data.Machine.Process

-- | A <tt><a>Process</a> a b</tt> is a stream transducer that can consume
--   values of type <tt>a</tt> from its input, and produce values of type
--   <tt>b</tt> for its output.
type Process a b = Machine (Is a) b

-- | A <tt><a>ProcessT</a> m a b</tt> is a stream transducer that can
--   consume values of type <tt>a</tt> from its input, and produce values
--   of type <tt>b</tt> and has side-effects in the <a>Monad</a>
--   <tt>m</tt>.
type ProcessT m a b = MachineT m (Is a) b

-- | An <a>Automaton</a> can be automatically lifted into a <a>Process</a>
class Automaton k
auto :: Automaton k => k a b -> Process a b

-- | Convert a machine into a process, with a little bit of help.
--   
--   <pre>
--   <a>process</a> <a>L</a> :: <a>Process</a> a c -&gt; <a>Tee</a> a b c
--   <a>process</a> <a>R</a> :: <a>Process</a> b c -&gt; <a>Tee</a> a b c
--   <a>process</a> <a>id</a> :: <a>Process</a> a b -&gt; <a>Process</a> a b
--   </pre>
process :: Monad m => (forall a. k a -> i -> a) -> MachineT m k o -> ProcessT m i o

-- | Build a new <a>Machine</a> by adding a <a>Process</a> to the output of
--   an old <a>Machine</a>
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>Process</a> b c -&gt; <a>Process</a> a b -&gt; <a>Process</a> a c
--   (<a>&lt;~</a>) :: <a>Process</a> c d -&gt; <a>Tee</a> a b c -&gt; <a>Tee</a> a b d
--   (<a>&lt;~</a>) :: <a>Process</a> b c -&gt; <a>Machine</a> k b -&gt; <a>Machine</a> k c
--   </pre>
(<~) :: Monad m => ProcessT m b c -> MachineT m k b -> MachineT m k c

-- | Flipped (<a>&lt;~</a>).
(~>) :: Monad m => MachineT m k b -> ProcessT m b c -> MachineT m k c

-- | The trivial <a>Process</a> that simply repeats each input it receives.
echo :: Process a a

-- | Feed a <a>Process</a> some input.
supply :: Monad m => [a] -> ProcessT m a b -> ProcessT m a b

-- | A <a>Process</a> that prepends the elements of a <a>Foldable</a> onto
--   its input, then repeats its input from there.
prepended :: Foldable f => f a -> Process a a

-- | A <a>Process</a> that only passes through inputs that match a
--   predicate.
filtered :: (a -> Bool) -> Process a a

-- | A <a>Process</a> that drops the first <tt>n</tt>, then repeats the
--   rest.
dropping :: Int -> Process a a

-- | A <a>Process</a> that passes through the first <tt>n</tt> elements
--   from its input then stops
taking :: Int -> Process a a

-- | A <a>Process</a> that drops elements while a predicate holds
droppingWhile :: (a -> Bool) -> Process a a

-- | A <a>Process</a> that passes through elements until a predicate ceases
--   to hold, then stops
takingWhile :: (a -> Bool) -> Process a a

-- | Chunk up the input into <tt>n</tt> element lists.
--   
--   Avoids returning empty lists and deals with the truncation of the
--   final group.
buffered :: Int -> Process a [a]

-- | Construct a <a>Process</a> from a left-folding operation.
--   
--   Like <a>scan</a>, but only yielding the final value.
--   
--   <pre>
--   <a>fold</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; Process b a
--   </pre>
fold :: Category k => (a -> b -> a) -> a -> Machine (k b) a

-- | <a>fold1</a> is a variant of <a>fold</a> that has no starting value
--   argument
fold1 :: Category k => (a -> a -> a) -> Machine (k a) a

-- | Construct a <a>Process</a> from a left-scanning operation.
--   
--   Like <a>fold</a>, but yielding intermediate values.
--   
--   <pre>
--   <a>scan</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; Process b a
--   </pre>
scan :: Category k => (a -> b -> a) -> a -> Machine (k b) a

-- | <a>scan1</a> is a variant of <a>scan</a> that has no starting value
--   argument
scan1 :: Category k => (a -> a -> a) -> Machine (k a) a

-- | Like <a>scan</a> only uses supplied function to map and uses Monoid
--   for associative operation
scanMap :: (Category k, Monoid b) => (a -> b) -> Machine (k a) b

-- | Break each input into pieces that are fed downstream individually.
asParts :: Foldable f => Process (f a) a

-- | <tt>sinkPart_ toParts sink</tt> creates a process that uses the
--   <tt>toParts</tt> function to break input into a tuple of
--   <tt>(passAlong, sinkPart)</tt> for which the second projection is
--   given to the supplied <tt>sink</tt> <a>ProcessT</a> (that produces no
--   output) while the first projection is passed down the pipeline.
sinkPart_ :: Monad m => (a -> (b, c)) -> ProcessT m c Void -> ProcessT m a b

-- | Apply a monadic function to each element of a <a>ProcessT</a>.
autoM :: Monad m => (a -> m b) -> ProcessT m a b

-- | Skip all but the final element of the input
--   
--   <pre>
--   <a>final</a> :: <a>Process</a> a a
--   </pre>
final :: Category k => Machine (k a) a

-- | Skip all but the final element of the input. If the input is empty,
--   the default value is emitted
--   
--   <pre>
--   <a>finalOr</a> :: a -&gt; <a>Process</a> a a
--   </pre>
finalOr :: Category k => a -> Machine (k a) a

-- | Intersperse an element between the elements of the input
--   
--   <pre>
--   <a>intersperse</a> :: a -&gt; <a>Process</a> a a
--   </pre>
intersperse :: Category k => a -> Machine (k a) a

-- | Return the maximum value from the input
largest :: (Category k, Ord a) => Machine (k a) a

-- | Return the minimum value from the input
smallest :: (Category k, Ord a) => Machine (k a) a

-- | Convert a stream of actions to a stream of values
sequencing :: (Category k, Monad m) => MachineT m (k (m a)) a

-- | Apply a function to all values coming from the input
mapping :: Category k => (a -> b) -> Machine (k a) b

-- | Parse <a>Read</a>able values, only emitting the value if the parse
--   succceeds. This <a>Machine</a> stops at first parsing error
reading :: (Category k, Read a) => Machine (k String) a

-- | Convert <a>Show</a>able values to <a>String</a>s
showing :: (Category k, Show a) => Machine (k a) String
instance Automaton Is
instance Automaton (->)


-- | <a>http://en.wikipedia.org/wiki/Moore_machine</a>
module Data.Machine.Moore

-- | <a>Moore</a> machines
data Moore a b
Moore :: b -> (a -> Moore a b) -> Moore a b

-- | Accumulate the input as a sequence.
logMoore :: Monoid m => Moore m m

-- | Construct a Moore machine from a state valuation and transition
--   function
unfoldMoore :: (s -> (b, a -> s)) -> s -> Moore a b
instance ComonadApply (Moore a)
instance Comonad (Moore a)
instance Copointed (Moore a)
instance Monad (Moore a)
instance Pointed (Moore a)
instance Applicative (Moore a)
instance Profunctor Moore
instance Functor (Moore a)
instance Automaton Moore


-- | <a>http://en.wikipedia.org/wiki/Mealy_machine</a>
module Data.Machine.Mealy

-- | <a>Mealy</a> machines
newtype Mealy a b
Mealy :: (a -> (b, Mealy a b)) -> Mealy a b
runMealy :: Mealy a b -> a -> (b, Mealy a b)

-- | A <a>Mealy</a> machine modeled with explicit state.
unfoldMealy :: (s -> a -> (b, s)) -> s -> Mealy a b

-- | Accumulate history.
logMealy :: Semigroup a => Mealy a a
instance ArrowApply Mealy
instance Choice Mealy
instance Strong Mealy
instance ArrowChoice Mealy
instance Arrow Mealy
instance Category Mealy
instance Automaton Mealy
instance Profunctor Mealy
instance Monad (Mealy a)
instance Pointed (Mealy a)
instance Applicative (Mealy a)
instance Functor (Mealy a)


module Data.Machine.Source

-- | A <a>Source</a> never reads from its inputs.
type Source b = forall k. Machine k b

-- | A <a>SourceT</a> never reads from its inputs, but may have monadic
--   side-effects.
type SourceT m b = forall k. MachineT m k b

-- | Generate a <a>Source</a> from any <a>Foldable</a> container.
source :: Foldable f => f b -> Source b

-- | Repeat the same value, over and over.
repeated :: o -> Source o

-- | Loop through a <a>Foldable</a> container over and over.
cycled :: Foldable f => f b -> Source b

-- | You can transform a <a>Source</a> with a <a>Process</a>.
--   
--   Alternately you can view this as capping the <a>Source</a> end of a
--   <a>Process</a>, yielding a new <a>Source</a>.
--   
--   <pre>
--   <a>cap</a> l r = l <a>&lt;~</a> r
--   </pre>
cap :: Process a b -> Source a -> Source b

-- | <a>iterated</a> <tt>f x</tt> returns an infinite source of repeated
--   applications of <tt>f</tt> to <tt>x</tt>
iterated :: (a -> a) -> a -> Source a

-- | <a>replicated</a> <tt>n x</tt> is a source of <tt>x</tt> emitted
--   <tt>n</tt> time(s)
replicated :: Int -> a -> Source a

-- | Enumerate from a value to a final value, inclusive, via <a>succ</a>
enumerateFromTo :: (Enum a, Eq a) => a -> a -> Source a


module Data.Machine.Tee

-- | A <a>Machine</a> that can read from two input stream in a
--   deterministic manner.
type Tee a b c = Machine (T a b) c

-- | A <a>Machine</a> that can read from two input stream in a
--   deterministic manner with monadic side-effects.
type TeeT m a b c = MachineT m (T a b) c

-- | The input descriptor for a <a>Tee</a> or <a>TeeT</a>
data T a b c
L :: T a b a
R :: T a b b

-- | Compose a pair of pipes onto the front of a Tee.
tee :: Monad m => ProcessT m a a' -> ProcessT m b b' -> TeeT m a' b' c -> TeeT m a b c

-- | Precompose a pipe onto the left input of a tee.
addL :: Monad m => ProcessT m a b -> TeeT m b c d -> TeeT m a c d

-- | Precompose a pipe onto the right input of a tee.
addR :: Monad m => ProcessT m b c -> TeeT m a c d -> TeeT m a b d

-- | Tie off one input of a tee by connecting it to a known source.
capL :: Monad m => SourceT m a -> TeeT m a b c -> ProcessT m b c

-- | Tie off one input of a tee by connecting it to a known source.
capR :: Monad m => SourceT m b -> TeeT m a b c -> ProcessT m a c

-- | wait for both the left and the right sides of a T and then merge them
--   with f.
zipWithT :: Monad m => (a -> b -> c) -> PlanT (T a b) c m ()


module Data.Machine.Wye

-- | A <a>Machine</a> that can read from two input stream in a
--   non-deterministic manner.
type Wye a b c = Machine (Y a b) c

-- | A <a>Machine</a> that can read from two input stream in a
--   non-deterministic manner with monadic side-effects.
type WyeT m a b c = MachineT m (Y a b) c

-- | The input descriptor for a <a>Wye</a> or <a>WyeT</a>
data Y a b c
X :: Y a b a
Y :: Y a b b
Z :: Y a b (Either a b)

-- | Compose a pair of pipes onto the front of a <a>Wye</a>.
--   
--   Precompose a <a>Process</a> onto each input of a <a>Wye</a> (or
--   <a>WyeT</a>).
--   
--   This is left biased in that it tries to draw values from the <a>X</a>
--   input whenever they are available, and only draws from the <a>Y</a>
--   input when <a>X</a> would block.
wye :: Monad m => ProcessT m a a' -> ProcessT m b b' -> WyeT m a' b' c -> WyeT m a b c

-- | Precompose a pipe onto the left input of a wye.
addX :: Monad m => ProcessT m a b -> WyeT m b c d -> WyeT m a c d

-- | Precompose a pipe onto the right input of a tee.
addY :: Monad m => ProcessT m b c -> WyeT m a c d -> WyeT m a b d

-- | Tie off one input of a tee by connecting it to a known source.
capX :: Monad m => SourceT m a -> WyeT m a b c -> ProcessT m b c

-- | Tie off one input of a tee by connecting it to a known source.
capY :: Monad m => SourceT m b -> WyeT m a b c -> ProcessT m a c


module Data.Machine


-- | Provide a notion of fanout wherein a single input is passed to several
--   consumers.
module Data.Machine.Fanout

-- | Share inputs with each of a list of processes in lockstep. Any values
--   yielded by the processes are combined into a single yield from the
--   composite process.
fanout :: (Functor m, Monad m, Semigroup r) => [ProcessT m a r] -> ProcessT m a r

-- | Share inputs with each of a list of processes in lockstep. If none of
--   the processes yields a value, the composite process will itself yield
--   <a>mempty</a>. The idea is to provide a handle on steps only executed
--   for their side effects. For instance, if you want to run a collection
--   of <a>ProcessT</a>s that await but don't yield some number of times,
--   you can use 'fanOutSteps . map (fmap (const ()))' followed by a
--   <a>taking</a> process.
fanoutSteps :: (Functor m, Monad m, Monoid r) => [ProcessT m a r] -> ProcessT m a r

module Data.Machine.Group

-- | Using a function to signal group changes, apply a machine
--   independently over each group.
groupingOn :: Monad m => (a -> a -> Bool) -> ProcessT m a b -> ProcessT m a b

-- | Mark a transition point between two groups as a function of adjacent
--   elements. <tt> <a>runT</a> (<a>supply</a> [1,2,2] (<a>taggedBy</a>
--   (==))) == [Right 1, Left (), Right 2, Right 2] </tt>
taggedBy :: Monad m => (a -> a -> Bool) -> ProcessT m a (Either () a)

-- | Run a machine multiple times over partitions of the input stream
--   specified by Left () values.
partitioning :: Monad m => ProcessT m a b -> ProcessT m (Either () a) b

-- | Run a machine with no input until it stops, then behave as another
--   machine..
starve :: Monad m => ProcessT m a b -> MachineT m k b -> MachineT m k b

-- | Read inputs until a condition is met, then behave as cont with | input
--   matching condition as first input of cont. | If await fails, stop.
awaitUntil :: Monad m => (a -> Bool) -> (a -> ProcessT m a b) -> ProcessT m a b
