-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | wxHaskell
--   
@package wx
@version 0.91.0.0


-- | Basic types.
module Graphics.UI.WX.Types

-- | The orientation of a widget.
data Orientation :: *
Horizontal :: Orientation
Vertical :: Orientation

-- | Reverse application, i.e. <tt>x # f</tt> = <tt>f x</tt>. Useful for an
--   object oriented style of programming.
--   
--   <pre>
--   (frame # frameSetTitle) "hi"
--   </pre>
(#) :: obj -> (obj -> a) -> a

-- | Inverse application, i.e. <tt>feed x f</tt> = <tt>f x</tt>.
feed :: a -> (a -> b) -> b

-- | Composed Inverse application, i.e. <tt>feed2 x y f</tt> = <tt>f x
--   y</tt>.
feed2 :: a -> b -> (a -> b -> c) -> c

-- | An <tt>Object a</tt> is a pointer to an object of type <tt>a</tt>. The
--   <tt>a</tt> parameter is used to encode the inheritance relation. When
--   the type parameter is unit <tt>()</tt>, it denotes an object of
--   exactly that class, when the parameter is a type variable <tt>a</tt>,
--   it specifies an object that is at least an instance of that class. For
--   example in wxWidgets, we have the following class hierarchy:
--   
--   <pre>
--   EvtHandler
--     |- Window
--          |- Frame
--          |- Control
--              |- Button
--              |- Radiobox
--   </pre>
--   
--   In wxHaskell, all the creation functions will return objects of
--   exactly that class and use the <tt>()</tt> type:
--   
--   <pre>
--   frameCreate :: Window a -&gt; ... -&gt; IO (Frame ())
--   buttonCreate :: Window a -&gt; ... -&gt; IO (Button ())
--   ...
--   </pre>
--   
--   In contrast, all the <i>this</i> (or <i>self</i>) pointers of methods
--   can take objects of any instance of that class and have a type
--   variable, for example:
--   
--   <pre>
--   windowSetClientSize :: Window a -&gt; Size -&gt; IO ()
--   controlSetLabel     :: Control a -&gt; String -&gt; IO ()
--   buttonSetDefault    :: Button a -&gt; IO ()
--   </pre>
--   
--   This means that we can use <tt>windowSetClientSize</tt> on any window,
--   including buttons and frames, but we can only use
--   <tt>controlSetLabel</tt> on controls, not including frames.
--   
--   In wxHaskell, this works since a <tt>Frame ()</tt> is actually a type
--   synonym for <tt>Window (CFrame ())</tt> (where <tt>CFrame</tt> is an
--   abstract data type). We can thus pass a value of type <tt>Frame
--   ()</tt> to anything that expects some <tt>Window a</tt>. For a button
--   this works too, as it is a synonym for <tt>Control (CButton ())</tt>
--   which is in turn a synonym for <tt>Window (CControl (CButton
--   ()))</tt>. Note that we can't pass a frame to something that expects a
--   value of type <tt>Control a</tt>. Of course, a <tt>Window a</tt> is
--   actually a type synonym for <tt>EvtHandler (CWindow a)</tt>. If you
--   study the documentation in <a>Graphics.UI.WX.Classes</a> closely, you
--   can discover where this chain ends :-).
--   
--   Objects are not automatically deleted. Normally you can use a delete
--   function like <tt>windowDelete</tt> to delete an object. However,
--   almost all objects in the wxWidgets library are automatically deleted
--   by the library. The only objects that should be used with care are
--   resources as bitmaps, fonts and brushes.
data Object a :: * -> *

-- | A null object. Use with care.
objectNull :: Object a

-- | Test for null object.
objectIsNull :: Object a -> Bool

-- | Cast an object to another type. Use with care.
objectCast :: Object a -> Object b

-- | Is this a managed object?
objectIsManaged :: Object a -> Bool

-- | Delete a wxObject, works for managed and unmanaged objects.
objectDelete :: WxObject a -> IO ()

-- | An <tt>Id</tt> is used to identify objects during event handling.
type Id = Int

-- | When creating a new window you may specify <a>idAny</a> to let
--   wxWidgets assign an unused identifier to it automatically.
--   Furthermore, it can be used in an event connection to handle events
--   for any identifier.
idAny :: Id

-- | Create a new unique identifier.
idCreate :: IO Id

-- | A mutable variable. Use this instead of <tt>MVar</tt>s or
--   <tt>IORef</tt>s to accomodate for future expansions with possible
--   concurrency.
type Var a = TVar a

-- | Create a fresh mutable variable.
varCreate :: a -> IO (Var a)

-- | Get the value of a mutable variable.
varGet :: Var a -> IO a

-- | Set the value of a mutable variable.
varSet :: Var a -> a -> IO ()

-- | Update the value of a mutable variable and return the old value.
varUpdate :: Var a -> (a -> a) -> IO a

-- | Swap the value of a mutable variable.
varSwap :: Var a -> a -> IO a

-- | Data types that can be represented through a bit mask. Only the
--   <tt>assocBitMask</tt> method is required for a new instance.
class Eq b => BitMask b where toBitMask x = case lookup x assocBitMask of { Just m -> m Nothing -> 0 } fromBitMask i = walk assocBitMask where walk [] = error "Graphics.UI.WX.Types.fromBitMask: empty list" walk [(x, 0)] = x walk ((x, m) : xs) | bitsSet m i = x | otherwise = walk xs setBitMask x i = i .-. (bits (map snd (assocBitMask :: [(b, Int)]))) .+. toBitMask x
assocBitMask :: BitMask b => [(b, Int)]
toBitMask :: BitMask b => b -> Int
fromBitMask :: BitMask b => Int -> b
setBitMask :: BitMask b => b -> Int -> Int

-- | Create a bitmask from a list of types.
mask :: BitMask b => [b] -> Int

-- | Bitwise <i>or</i> of two bit masks.
(.+.) :: Int -> Int -> Int

-- | Unset certain bits in a bitmask.
(.-.) :: Int -> BitFlag -> Int

-- | Bitwise <i>or</i> of a list of bit masks.
bits :: [Int] -> Int

-- | (<tt>bitsSet mask i</tt>) tests if all bits in <tt>mask</tt> are also
--   set in <tt>i</tt>.
bitsSet :: Int -> Int -> Bool
toCBool :: Bool -> CBool
fromCBool :: CBool -> Bool

-- | A <tt>Style</tt> is normally used as a flag mask to specify some
--   window style
type Style = Int

-- | An <tt>EventId</tt> is identifies specific events.
type EventId = Int

-- | Identifies tree items. Note: Replaces the <tt>TreeItemId</tt> object
--   and takes automatically care of allocation issues.
data TreeItem :: *

-- | An abstract data type to define colors.
--   
--   Note: Haddock 0.8 and 0.9 doesn't support GeneralizedNewtypeDeriving.
--   So, This class doesn't have <a>IArray</a> class's unboxed array
--   instance now. If you want to use this type with unboxed array, you
--   must write code like this.
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving, StandaloneDeriving, MultiParamTypeClasses #-}
--   import Graphics.UI.WXCore.WxcTypes
--   ...
--   deriving instance IArray UArray Color
--   </pre>
--   
--   We can't derive <a>MArray</a> class's unboxed array instance this way.
--   This is a bad point of current <a>MArray</a> class definition.
data Color :: *

-- | Create a color from a red/green/blue triple.
rgb :: Integral a => a -> a -> a -> Color

-- | Create a color from a red/green/blue triple.
colorRGB :: Integral a => a -> a -> a -> Color

-- | Returns a red color component
colorRed :: Num a => Color -> a

-- | Returns a green color component
colorGreen :: Num a => Color -> a

-- | Returns a blue color component
colorBlue :: Num a => Color -> a
black :: Color
darkgrey :: Color
dimgrey :: Color
mediumgrey :: Color
grey :: Color
lightgrey :: Color
white :: Color
red :: Color
green :: Color
blue :: Color
cyan :: Color
magenta :: Color
yellow :: Color

-- | System Colors.
data SystemColor :: *

-- | The scrollbar grey area.
ColorScrollBar :: SystemColor

-- | The desktop colour.
ColorBackground :: SystemColor

-- | Active window caption.
ColorActiveCaption :: SystemColor

-- | Inactive window caption.
ColorInactiveCaption :: SystemColor

-- | Menu background.
ColorMenu :: SystemColor

-- | Window background.
ColorWindow :: SystemColor

-- | Window frame.
ColorWindowFrame :: SystemColor

-- | Menu text.
ColorMenuText :: SystemColor

-- | Text in windows.
ColorWindowText :: SystemColor

-- | Text in caption, size box and scrollbar arrow box.
ColorCaptionText :: SystemColor

-- | Active window border.
ColorActiveBorder :: SystemColor

-- | Inactive window border.
ColorInactiveBorder :: SystemColor

-- | Background colour MDI -- ^applications.
ColorAppWorkspace :: SystemColor

-- | Item(s) selected in a control.
ColorHighlight :: SystemColor

-- | Text of item(s) selected in a control.
ColorHighlightText :: SystemColor

-- | Face shading on push buttons.
ColorBtnFace :: SystemColor

-- | Edge shading on push buttons.
ColorBtnShadow :: SystemColor

-- | Greyed (disabled) text.
ColorGrayText :: SystemColor

-- | Text on push buttons.
ColorBtnText :: SystemColor

-- | Colour of text in active captions.
ColorInactiveCaptionText :: SystemColor

-- | Highlight colour for buttons (same as 3DHILIGHT).
ColorBtnHighlight :: SystemColor

-- | Dark shadow for three-dimensional display elements.
Color3DDkShadow :: SystemColor

-- | Light colour for three-dimensional display elements.
Color3DLight :: SystemColor

-- | Text colour for tooltip controls.
ColorInfoText :: SystemColor

-- | Background colour for tooltip controls.
ColorInfoBk :: SystemColor

-- | Same as BACKGROUND.
ColorDesktop :: SystemColor

-- | Same as BTNFACE.
Color3DFace :: SystemColor

-- | Same as BTNSHADOW.
Color3DShadow :: SystemColor

-- | Same as BTNHIGHLIGHT.
Color3DHighlight :: SystemColor

-- | Same as BTNHIGHLIGHT.
Color3DHilight :: SystemColor

-- | Same as BTNHIGHLIGHT.
ColorBtnHilight :: SystemColor

-- | Convert a system color to a color.
colorSystem :: SystemColor -> Color

-- | Font descriptor. The font is normally specified thru the
--   <a>FontFamily</a>, giving some degree of portability. The
--   <a>_fontFace</a> can be used to specify the exact (platform dependent)
--   font.
--   
--   Note that the original wxWidgets <tt>FontStyle</tt> is renamed to
--   <tt>FontShape</tt>.
data FontStyle :: *
FontStyle :: SrictNotUnpackedInt -> SrictNotUnpackedFontFamily -> SrictNotUnpackedFontShape -> SrictNotUnpackedFontWeight -> SrictNotUnpackedBool -> SrictNotUnpackedString -> SrictNotUnpackedInt -> FontStyle
_fontSize :: FontStyle -> SrictNotUnpackedInt
_fontFamily :: FontStyle -> SrictNotUnpackedFontFamily
_fontShape :: FontStyle -> SrictNotUnpackedFontShape
_fontWeight :: FontStyle -> SrictNotUnpackedFontWeight
_fontUnderline :: FontStyle -> SrictNotUnpackedBool

-- | normally <tt>""</tt>
_fontFace :: FontStyle -> SrictNotUnpackedString

-- | normally <tt>wxFONTENCODING_DEFAULT</tt>
_fontEncoding :: FontStyle -> SrictNotUnpackedInt

-- | Standard font families.
data FontFamily :: *

-- | A system default font.
FontDefault :: FontFamily

-- | Decorative font.
FontDecorative :: FontFamily

-- | Formal serif font.
FontRoman :: FontFamily

-- | Hand writing font.
FontScript :: FontFamily

-- | Sans-serif font.
FontSwiss :: FontFamily

-- | Fixed pitch font.
FontModern :: FontFamily

-- | A teletype (i.e. monospaced) font
FontTeletype :: FontFamily

-- | The font style.
data FontShape :: *
ShapeNormal :: FontShape
ShapeItalic :: FontShape
ShapeSlant :: FontShape

-- | The font weight.
data FontWeight :: *
WeightNormal :: FontWeight
WeightBold :: FontWeight
WeightLight :: FontWeight

-- | Default 10pt font.
fontDefault :: FontStyle

-- | Default 10pt sans-serif font.
fontSwiss :: FontStyle

-- | Default 8pt font.
fontSmall :: FontStyle

-- | Default 10pt italic.
fontItalic :: FontStyle

-- | Monospaced font, 10pt.
fontFixed :: FontStyle

-- | Brush style.
data BrushStyle :: *
BrushStyle :: SrictNotUnpackedBrushKind -> SrictNotUnpackedColor -> BrushStyle
_brushKind :: BrushStyle -> SrictNotUnpackedBrushKind
_brushColor :: BrushStyle -> SrictNotUnpackedColor

-- | Brush kind.
data BrushKind :: *

-- | No filling
BrushTransparent :: BrushKind

-- | Solid color
BrushSolid :: BrushKind

-- | Hatch pattern
BrushHatch :: SrictNotUnpackedHatchStyle -> BrushKind
_brushHatch :: BrushKind -> SrictNotUnpackedHatchStyle

-- | Bitmap pattern (on win95 only 8x8 bitmaps are supported)
BrushStipple :: SrictNotUnpacked(Bitmap ()) -> BrushKind
_brushBitmap :: BrushKind -> SrictNotUnpacked(Bitmap ())

-- | Hatch style.
data HatchStyle :: *

-- | Backward diagonal
HatchBDiagonal :: HatchStyle

-- | Crossed diagonal
HatchCrossDiag :: HatchStyle

-- | Forward diagonal
HatchFDiagonal :: HatchStyle

-- | Crossed orthogonal
HatchCross :: HatchStyle

-- | Horizontal
HatchHorizontal :: HatchStyle

-- | Vertical
HatchVertical :: HatchStyle

-- | Default brush (transparent, black).
brushDefault :: BrushStyle

-- | A transparent brush.
brushTransparent :: BrushStyle

-- | Pen style.
data PenStyle :: *
PenStyle :: SrictNotUnpackedPenKind -> SrictNotUnpackedColor -> SrictNotUnpackedInt -> SrictNotUnpackedCapStyle -> SrictNotUnpackedJoinStyle -> PenStyle
_penKind :: PenStyle -> SrictNotUnpackedPenKind
_penColor :: PenStyle -> SrictNotUnpackedColor
_penWidth :: PenStyle -> SrictNotUnpackedInt
_penCap :: PenStyle -> SrictNotUnpackedCapStyle
_penJoin :: PenStyle -> SrictNotUnpackedJoinStyle

-- | Pen kinds.
data PenKind :: *

-- | No edge.
PenTransparent :: PenKind
PenSolid :: PenKind
PenDash :: SrictNotUnpackedDashStyle -> PenKind
_penDash :: PenKind -> SrictNotUnpackedDashStyle
PenHatch :: SrictNotUnpackedHatchStyle -> PenKind
_penHatch :: PenKind -> SrictNotUnpackedHatchStyle

-- | <tt>_penColor</tt> is ignored
PenStipple :: SrictNotUnpacked(Bitmap ()) -> PenKind
_penBitmap :: PenKind -> SrictNotUnpacked(Bitmap ())

-- | Cap style
data CapStyle :: *

-- | End points are rounded
CapRound :: CapStyle
CapProjecting :: CapStyle
CapButt :: CapStyle

-- | Join style.
data JoinStyle :: *

-- | Corners are rounded
JoinRound :: JoinStyle

-- | Corners are bevelled
JoinBevel :: JoinStyle

-- | Corners are blocked
JoinMiter :: JoinStyle

-- | Dash style
data DashStyle :: *
DashDot :: DashStyle
DashLong :: DashStyle
DashShort :: DashStyle
DashDotShort :: DashStyle

-- | Default pen (<tt>PenStyle PenSolid black 1 CapRound JoinRound</tt>)
penDefault :: PenStyle

-- | A solid pen with a certain color and width.
penColored :: Color -> Int -> PenStyle

-- | A transparent pen.
penTransparent :: PenStyle
type Point = Point2 Int

-- | A point has an x and y coordinate. Coordinates are normally relative
--   to the upper-left corner of their view frame, where a positive x goes
--   to the right and a positive y to the bottom of the view.
data Num a => Point2 a :: * -> *
Point :: SrictNotUnpackeda -> SrictNotUnpackeda -> Point2 a

-- | x component of a point.
pointX :: Point2 a -> SrictNotUnpackeda

-- | y component of a point.
pointY :: Point2 a -> SrictNotUnpackeda

-- | Construct a point.
point :: Num a => a -> a -> Point2 a

-- | Shorter function to construct a point.
pt :: Num a => a -> a -> Point2 a
pointFromVec :: Num a => Vector -> Point2 a
pointFromSize :: Num a => Size -> Point2 a

-- | Point at the origin.
pointZero :: Num a => Point2 a

-- | A <a>null</a> point is not a legal point (x and y are -1) and can be
--   used for some wxWidgets functions to select a default point.
pointNull :: Num a => Point2 a
pointMove :: Num a => Vector2 a -> Point2 a -> Point2 a
pointMoveBySize :: Num a => Point2 a -> Size2D a -> Point2 a
pointAdd :: Num a => Point2 a -> Point2 a -> Point2 a
pointSub :: Num a => Point2 a -> Point2 a -> Point2 a
pointScale :: Num a => Point2 a -> a -> Point2 a
type Size = Size2D Int

-- | A <tt>Size</tt> has a width and height.
data Num a => Size2D a :: * -> *
Size :: SrictNotUnpackeda -> SrictNotUnpackeda -> Size2D a

-- | the width of a size
sizeW :: Size2D a -> SrictNotUnpackeda

-- | the height of a size
sizeH :: Size2D a -> SrictNotUnpackeda

-- | Short function to construct a size
sz :: Num a => a -> a -> Size2D a
sizeFromPoint :: Num a => Point2 a -> Size2D a
sizeFromVec :: Num a => Vector2 a -> Size2D a
sizeZero :: Num a => Size2D a

-- | A <a>null</a> size is not a legal size (width and height are -1) and
--   can be used for some wxWidgets functions to select a default size.
sizeNull :: Num a => Size2D a

-- | Returns <a>True</a> if the first size totally encloses the second
--   argument.
sizeEncloses :: (Num a, Ord a) => Size2D a -> Size2D a -> Bool

-- | The minimum of two sizes.
sizeMin :: (Num a, Ord a) => Size2D a -> Size2D a -> Size2D a

-- | The maximum of two sizes.
sizeMax :: (Num a, Ord a) => Size2D a -> Size2D a -> Size2D a
type Vector = Vector2 Int

-- | A vector with an x and y delta.
data Num a => Vector2 a :: * -> *
Vector :: SrictNotUnpackeda -> SrictNotUnpackeda -> Vector2 a

-- | delta-x component of a vector
vecX :: Vector2 a -> SrictNotUnpackeda

-- | delta-y component of a vector
vecY :: Vector2 a -> SrictNotUnpackeda

-- | Construct a vector.
vector :: Num a => a -> a -> Vector2 a

-- | Short function to construct a vector.
vec :: Num a => a -> a -> Vector2 a
vecFromPoint :: Num a => Point2 a -> Vector2 a
vecFromSize :: Size -> Vector

-- | A zero vector
vecZero :: Num a => Vector2 a

-- | A <a>null</a> vector has a delta x and y of -1 and can be used for
--   some wxWidgets functions to select a default vector.
vecNull :: Num a => Vector2 a
vecNegate :: Num a => Vector2 a -> Vector2 a
vecOrtogonal :: Num a => Vector2 a -> Vector2 a
vecAdd :: Num a => Vector2 a -> Vector2 a -> Vector2 a
vecSub :: Num a => Vector2 a -> Vector2 a -> Vector2 a
vecScale :: Num a => Vector2 a -> a -> Vector2 a
vecBetween :: Num a => Point2 a -> Point2 a -> Vector2 a
vecLength :: Vector -> Double
vecLengthDouble :: Vector2 Double -> Double
type Rect = Rect2D Int

-- | A rectangle is defined by the left x coordinate, the top y coordinate,
--   the width and the height.
data Num a => Rect2D a :: * -> *
Rect :: SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> Rect2D a
rectLeft :: Rect2D a -> SrictNotUnpackeda
rectTop :: Rect2D a -> SrictNotUnpackeda
rectWidth :: Rect2D a -> SrictNotUnpackeda
rectHeight :: Rect2D a -> SrictNotUnpackeda
rectTopLeft :: Num a => Rect2D a -> Point2 a
rectTopRight :: Num a => Rect2D a -> Point2 a
rectBottomLeft :: Num a => Rect2D a -> Point2 a
rectBottomRight :: Num a => Rect2D a -> Point2 a
rectBottom :: Num a => Rect2D a -> a
rectRight :: Num a => Rect2D a -> a

-- | Create a rectangle at a certain (upper-left) point with a certain
--   size.
rect :: Num a => Point2 a -> Size2D a -> Rect2D a

-- | Construct a (positive) rectangle between two (arbitrary) points.
rectBetween :: (Num a, Ord a) => Point2 a -> Point2 a -> Rect2D a

-- | Create a rectangle of a certain size with the upper-left corner at
--   (<a>pt</a> 0 0).
rectFromSize :: Num a => Size2D a -> Rect2D a

-- | An empty rectangle at (0,0).
rectZero :: Num a => Rect2D a

-- | An <a>null</a> rectangle is not a valid rectangle (<tt>Rect -1 -1 -1
--   -1</tt>) but can used for some wxWidgets functions to select a default
--   rectangle. (i.e. <tt>frameCreate</tt>).
rectNull :: Num a => Rect2D a

-- | Get the size of a rectangle.
rectSize :: Num a => Rect2D a -> Size2D a
rectIsEmpty :: (Num a, Eq a) => Rect2D a -> Bool
rectContains :: (Num a, Ord a) => Rect2D a -> Point2 a -> Bool
rectMoveTo :: Num a => Rect2D a -> Point2 a -> Rect2D a
rectFromPoint :: Num a => Point2 a -> Rect2D a
rectCentralPoint :: Rect2D Int -> Point2 Int
rectCentralRect :: Rect2D Int -> Size -> Rect2D Int
rectStretchTo :: Num a => Rect2D a -> Size2D a -> Rect2D a
rectCentralPointDouble :: Fractional a => Rect2D a -> Point2 a
rectCentralRectDouble :: Fractional a => Rect2D a -> Size2D a -> Rect2D a
rectMove :: Num a => Rect2D a -> Vector2 a -> Rect2D a
rectOverlaps :: (Num a, Ord a) => Rect2D a -> Rect2D a -> Bool

-- | A list with rectangles that constitute the difference between two
--   rectangles.
rectsDiff :: (Num a, Ord a) => Rect2D a -> Rect2D a -> [Rect2D a]
rectUnion :: (Num a, Ord a) => Rect2D a -> Rect2D a -> Rect2D a

-- | The intersection between two rectangles.
rectOverlap :: (Num a, Ord a) => Rect2D a -> Rect2D a -> Rect2D a
rectUnions :: (Num a, Ord a) => [Rect2D a] -> Rect2D a

-- | Ignore the result of an <a>IO</a> action.
unitIO :: IO a -> IO ()

-- | Properly release resources, even in the event of an exception.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | Specialized variant of <a>bracket</a> where the return value is not
--   required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Run some computation afterwards, even if an exception occurs.
finally :: IO a -> IO b -> IO a

-- | Run some computation afterwards, even if an exception occurs. Equals
--   <a>finally</a> but with the arguments swapped.
finalize :: IO b -> IO a -> IO a

-- | Perform an action when a test succeeds.
when :: Bool -> IO () -> IO ()


-- | Widgets <tt>w</tt> can have attributes of type <tt>a</tt> represented
--   by the type <a>Attr</a> <tt>w a</tt>. An example of an attribute is
--   <a>text</a> with type:
--   
--   <pre>
--   text :: Attr (Window a) String
--   </pre>
--   
--   This means that any object derived from <tt>Window</tt> has a
--   <a>text</a> attribute of type <a>String</a>. An attribute can be read
--   with the <a>get</a> function:
--   
--   <pre>
--   get w title           :: IO String
--   </pre>
--   
--   When an attribute is associated with a value, we call it a
--   <i>property</i> of type <a>Prop</a> <tt>w</tt>. Properties are
--   constructed by assigning a value to an attribute with the (<a>:=</a>)
--   constructor:
--   
--   <pre>
--   text := "hello world"      :: Prop (Window a)
--   </pre>
--   
--   A list of properties can be set with the <a>set</a> function:
--   
--   <pre>
--   set w [text := "Hi"]   :: IO ()
--   </pre>
--   
--   The (<a>:~</a>) constructor is used to transform an attribute value
--   with an update function. For example, the <tt>interval</tt> on a timer
--   can be doubled with the following expression.
--   
--   <pre>
--   set timer [interval :~ (*2)]
--   </pre>
--   
--   The functions <a>get</a>, <a>set</a>, (<a>:=</a>), and (<a>:~</a>) are
--   polymorphic and work for all widgets, but the <tt>text</tt> attribute
--   just works for windows. Many attributes work for different kind of
--   objects and are organised into type classes. Actually, the real type
--   of the <a>text</a> attribute is:
--   
--   <pre>
--   Textual w =&gt; Attr w String
--   </pre>
--   
--   and <tt>Window</tt> derived objects are part of this class:
--   
--   <pre>
--   instance Textual (Window a)
--   </pre>
--   
--   But also menus and status fields:
--   
--   <pre>
--   instance Textual (Menu a)
--   instance Textual (StatusField)
--   </pre>
--   
--   Sometimes, it is convenient to also get a reference to the object
--   itself when setting a property. The operators (<a>::=</a>) and
--   (<a>::~</a>) provide this reference.
module Graphics.UI.WX.Attributes

-- | Widgets <tt>w</tt> can have attributes of type <tt>a</tt>.
data Attr w a

-- | A property of a widget <tt>w</tt> is an attribute that is already
--   associated with a value. .
data Prop w

-- | Assign a value to an attribute.
(:=) :: Attr w a -> a -> Prop w

-- | Apply an update function to an attribute.
(:~) :: Attr w a -> (a -> a) -> Prop w

-- | Assign a value to an attribute with the widget as argument.
(::=) :: Attr w a -> (w -> a) -> Prop w

-- | Apply an update function to an attribute with the widget as an
--   argument.
(::~) :: Attr w a -> (w -> a -> a) -> Prop w

-- | A read-only attribute. Just for documentation purposes.
type ReadAttr w a = Attr w a

-- | A write-only attribute. Just for documentation purposes.
type WriteAttr w a = Attr w a

-- | An attribute that should be specified at creation time. Just for
--   documentation purposes.
type CreateAttr w a = Attr w a

-- | Get the value of an attribute
--   
--   <pre>
--   t &lt;- get w text
--   </pre>
get :: w -> Attr w a -> IO a

-- | Set a list of properties.
--   
--   <pre>
--   set w [text := "Hi"]
--   </pre>
set :: w -> [Prop w] -> IO ()

-- | Set the value of an attribute and return the old value.
swap :: w -> Attr w a -> a -> IO a

-- | (<tt>mapAttr get set attr</tt>) maps an attribute of <tt>Attr w a</tt>
--   to <tt>Attr w b</tt> where (<tt>get :: a -&gt; b</tt>) is used when
--   the attribute is requested and (<tt>set :: a -&gt; b -&gt; a</tt>) is
--   applied to current value when the attribute is set.
mapAttr :: (a -> b) -> (a -> b -> a) -> Attr w a -> Attr w b

-- | (<tt>mapAttrW conv attr</tt>) maps an attribute of <tt>Attr w a</tt>
--   to <tt>Attr v a</tt> where (<tt>conv :: v -&gt; w</tt>) is used to
--   convert a widget <tt>v</tt> into a widget of type <tt>w</tt>.
mapAttrW :: (v -> w) -> Attr w a -> Attr v a

-- | Create a new attribute with a specified name, getter and setter
--   function.
newAttr :: String -> (w -> IO a) -> (w -> a -> IO ()) -> Attr w a

-- | Define a read-only attribute.
readAttr :: String -> (w -> IO a) -> ReadAttr w a

-- | Define a write-only attribute.
writeAttr :: String -> (w -> a -> IO ()) -> WriteAttr w a

-- | A dummy attribute.
nullAttr :: String -> WriteAttr w a

-- | A constant attribute.
constAttr :: Typeable a => String -> a -> Attr w a

-- | Create a new attribute with a specified name, getter, setter, and
--   updater function.
makeAttr :: String -> (w -> IO a) -> (w -> a -> IO ()) -> (w -> (a -> a) -> IO a) -> Attr w a

-- | Retrieve the name of an attribute
attrName :: Attr w a -> String

-- | Retrieve the name of a property.
propName :: Prop w -> String

-- | Is a certain property in a list of properties?
containsProperty :: Attr w a -> [Prop w] -> Bool

-- | Create a <i>reflective</i> attribute with a specified name: value can
--   possibly retrieved using <tt>getPropValue</tt>. Note: the use of this
--   function is discouraged as it leads to non-compositional code.
reflectiveAttr :: Typeable a => String -> (w -> IO a) -> (w -> a -> IO ()) -> Attr w a

-- | Create a <i>reflective</i> attribute with a specified name: value can
--   possibly retrieved using <tt>getPropValue</tt>. Note: the use of this
--   function is discouraged as it leads to non-compositional code.
createAttr :: Typeable a => String -> (w -> IO a) -> (w -> a -> IO ()) -> CreateAttr w a

-- | Try to find a property value and call the contination function with
--   that value and the property list witht the searched property removed.
--   If the property is not found, use the default value and the unchanged
--   property list.
withProperty :: Typeable a => Attr w a -> a -> (a -> [Prop w] -> b) -> [Prop w] -> b

-- | Try to find a property value. Return |Nothing| if not found at all.
findProperty :: Typeable a => Attr w a -> a -> [Prop w] -> Maybe (a, [Prop w])

-- | Transform the properties based on a style property.
withStyleProperty :: Attr w Bool -> Style -> ([Prop w] -> Style -> a) -> [Prop w] -> Style -> a

-- | Transform the properties based on a style property. The flag is
--   interpreted negatively, i.e. |True| removes the bit instead of setting
--   it.
withStylePropertyNot :: Attr w Bool -> Style -> ([Prop w] -> Style -> a) -> [Prop w] -> Style -> a

-- | Property value: used when retrieving a property from a list.
data PropValue a
PropValue :: a -> PropValue a
PropModify :: (a -> a) -> PropValue a
PropNone :: PropValue a

-- | Retrieve the value of a property and the list with the property
--   removed.
filterProperty :: Typeable a => Attr w a -> [Prop w] -> (PropValue a, [Prop w])

-- | Cast attributes.
castAttr :: (v -> w) -> Attr w a -> Attr v a

-- | Cast properties
castProp :: (v -> w) -> Prop w -> Prop v

-- | Cast a list of properties.
castProps :: (v -> w) -> [Prop w] -> [Prop v]
instance Show a => Show (PropValue a)
instance Show a => Show (Attr w a)
instance Show a => Show (Prop a)


-- | Just re-exports functionality of <a>Graphics.UI.WXCore.Layout</a>. See
--   that module for a description of layout combinators.
--   
--   Any object in the <a>Form</a> class has a <a>layout</a> attribute to
--   specify the layout. Here is a short example:
--   
--   <pre>
--   do f &lt;- frame [text := "layout demo"]
--      q &lt;- button f [text := "quit", on command := close f]
--      set f [layout := margin 10 $
--                       floatCentre $
--                       column 5 [label "hi",widget q]]
--   </pre>
module Graphics.UI.WX.Layout

-- | Forms can contain other widgets.
class Form w
layout :: Form w => Attr w Layout


-- | This modules defines attributes common to many widgets and organizes
--   them into Haskell classes. Look at the instance definitions to see
--   what kind of widgets support the attributes.
--   
--   Sometimes it is hard to find what attributes a certain widget supports
--   since the instance definitions might be on some class higher in the
--   hierarchy. For example, many instances are defined for <a>Window</a>
--   <tt>a</tt> -- this means that all those attributes are applicable to
--   any kind of <a>Window</a>, i.e. frames, buttons, panels etc. However,
--   these attributes will not be explicitly listed at the type definitions
--   of those classes.
module Graphics.UI.WX.Classes

-- | Window borders
data Border

-- | Displays a thin border around the window.
BorderSimple :: Border

-- | Displays a double border. Windows only.
BorderDouble :: Border

-- | Displays a sunken border.
BorderSunken :: Border

-- | Displays a raised border.
BorderRaised :: Border

-- | Displays a border suitable for a static control. Windows only
BorderStatic :: Border

-- | No border
BorderNone :: Border

-- | Widgets with a label or text field.
class Textual w where appendText w s = set w [text :~ (++ s)]
text :: Textual w => Attr w String
appendText :: Textual w => w -> String -> IO ()

-- | Widgets with a font.
class Literate w where fontSize = mapAttr _fontSize (\ finfo x -> finfo {_fontSize = x}) font fontWeight = mapAttr _fontWeight (\ finfo x -> finfo {_fontWeight = x}) font fontFamily = mapAttr _fontFamily (\ finfo x -> finfo {_fontFamily = x}) font fontShape = mapAttr _fontShape (\ finfo x -> finfo {_fontShape = x}) font fontFace = mapAttr _fontFace (\ finfo x -> finfo {_fontFace = x}) font fontUnderline = mapAttr _fontUnderline (\ finfo x -> finfo {_fontUnderline = x}) font
font :: Literate w => Attr w FontStyle
fontSize :: Literate w => Attr w Int
fontWeight :: Literate w => Attr w FontWeight
fontFamily :: Literate w => Attr w FontFamily
fontShape :: Literate w => Attr w FontShape
fontFace :: Literate w => Attr w String
fontUnderline :: Literate w => Attr w Bool
textColor :: Literate w => Attr w Color
textBgcolor :: Literate w => Attr w Color

-- | Widgets that have a size.
class Dimensions w where outerSize = mapAttr rectSize (\ r sz -> rect (rectTopLeft r) sz) area position = mapAttr rectTopLeft (\ r pt -> rect pt (rectSize r)) area area = newAttr "area" getArea setArea where getArea w = do { sz <- get w outerSize; pt <- get w position; return (rect pt sz) } setArea w rect = set w [outerSize := rectSize rect, position := rectTopLeft rect] clientSize = outerSize bestSize = outerSize virtualSize = clientSize
outerSize :: Dimensions w => Attr w Size
position :: Dimensions w => Attr w Point
area :: Dimensions w => Attr w Rect
bestSize :: Dimensions w => ReadAttr w Size
clientSize :: Dimensions w => Attr w Size
virtualSize :: Dimensions w => Attr w Size
class Colored w where bgcolor = nullAttr "bgcolor" color = nullAttr "color"
bgcolor :: Colored w => Attr w Color
color :: Colored w => Attr w Color

-- | Visible widgets.
class Visible w where fullRepaintOnResize = nullAttr "fullRepaintOnResize" visible = nullAttr "visible" refresh w = return ()
visible :: Visible w => Attr w Bool
refresh :: Visible w => w -> IO ()
fullRepaintOnResize :: Visible w => Attr w Bool

-- | Widgets with a border.
class Bordered w where border = nullAttr "border"
border :: Bordered w => Attr w Border

-- | Widgets that are part of a hierarchical order.
class Child w where parent = readAttr "parent" (\ w -> return objectNull)
parent :: Child w => ReadAttr w (Window ())

-- | Parent widgets.
class Parent w where children = nullAttr "window" clipChildren = nullAttr "clipChildren"
children :: Parent w => ReadAttr w [Window ()]
clipChildren :: Parent w => Attr w Bool

-- | Widgets that can be closed.
class Closeable w
close :: Closeable w => w -> IO ()

-- | Widgets with a single selection (radio group or listbox)
class Selection w
selection :: Selection w => Attr w Int

-- | Widget with zero or more selections (multi select list boxes)
class Selections w
selections :: Selections w => Attr w [Int]

-- | Widgets containing certain items (like strings in a listbox)
class Items w a | w -> a where items = newAttr "items" getter setter where getter :: w -> IO [a] getter w = do { n <- get w itemCount; mapM (\ i -> get w (item i)) [0 .. n - 1] } setter :: w -> [a] -> IO () setter w xs = do { itemsDelete w; mapM_ (\ x -> itemAppend w x) xs } itemAppend w x = do { xs <- get w items; set w [items := xs ++ [x]] } itemsDelete w = do { count <- get w itemCount; sequence_ (replicate count (itemDelete w 0)) }
itemCount :: Items w a => ReadAttr w Int
items :: Items w a => Attr w [a]
item :: Items w a => Int -> Attr w a
itemDelete :: Items w a => w -> Int -> IO ()
itemsDelete :: Items w a => w -> IO ()
itemAppend :: Items w a => w -> a -> IO ()

-- | Widgets that can be enabled or disabled.
class Able w
enabled :: Able w => Attr w Bool

-- | Widgets with help text.
class Help w
help :: Help w => Attr w String

-- | Widgets that have a tooltip
class Tipped w
tooltip :: Tipped w => Attr w String

-- | The identity determines the wxWidgets ID of a widget.
class Identity w
identity :: Identity w => Attr w Int

-- | The style is a bitmask that determines various properties of a widget.
class Styled w
style :: Styled w => Attr w Int

-- | Widgets that have a system frame around them.
class Framed w where resizeable = nullAttr "resizeable" minimizeable = nullAttr "minimizeable" maximizeable = nullAttr "maximizeable" closeable = nullAttr "closeable"
resizeable :: Framed w => Attr w Bool
minimizeable :: Framed w => Attr w Bool
maximizeable :: Framed w => Attr w Bool
closeable :: Framed w => Attr w Bool

-- | Checkable widgets
class Checkable w
checkable :: Checkable w => Attr w Bool
checked :: Checkable w => Attr w Bool

-- | Dockable widgets.
class Dockable w
dockable :: Dockable w => Attr w Bool

-- | Widgets with a picture.
class Pictured w
picture :: Pictured w => Attr w FilePath

-- | Items with a value.
class Valued w
value :: Valued w => Attr (w a) a

-- | Sized objects (like bitmaps)
class Sized w
size :: Sized w => Attr w Size

-- | Objects which activate a <a>Window</a> by default keypress
class HasDefault w
unsafeDefaultItem :: HasDefault w => Attr w (Window ())
defaultButton :: HasDefault w => Attr w (Button ())
instance Typeable Border
instance Eq Border
instance Show Border
instance Read Border
instance BitMask Border


-- | Images, Media, Sounds, and action!
module Graphics.UI.WX.Media

-- | Abstract layer between <a>MediaCtrl</a> and <a>Sound</a>. This class
--   intends to avoid breaking backward-compatibility.
class Media w
play :: Media w => w -> IO ()
stop :: Media w => w -> IO ()

-- | Return a managed sound object. The file path points to a valid sound
--   file, normally a <tt>.wav</tt>.
sound :: FilePath -> Sound ()

-- | Play a sound fragment repeatedly (and asynchronously).
playLoop :: Sound a -> IO ()

-- | Play a sound fragment synchronously (i.e. wait till completion).
playWait :: Sound a -> IO ()

-- | Return a managed image. Images are platform independent
--   representations of pictures, using an array of rgb pixels. See
--   <a>Graphics.UI.WXCore.Image</a> for lowlevel pixel manipulation. The
--   file path should point to a valid image file, like <tt>.jpg</tt>,
--   <tt>.bmp</tt>, <tt>.xpm</tt>, or <tt>.png</tt>, for example.
--   
--   Instances: <a>Sized</a>.
image :: FilePath -> Image ()

-- | usage: (<tt>imageCreateFromFile name</tt>).
imageCreateFromFile :: String -> IO (Image ())

-- | Create an image from a list of pixels.
imageCreateFromPixels :: Size -> [Color] -> IO (Image ())

-- | Get the pixels of an image.
imageGetPixels :: Image a -> IO [Color]

-- | Create an image from a pixel array
imageCreateFromPixelArray :: IArray a Color => a Point Color -> IO (Image ())

-- | Get the pixels of an image as an array
imageGetPixelArray :: IArray a Color => Image b -> IO (a Point Color)

-- | Return a managed bitmap object. Bitmaps are abstract images used for
--   drawing to a device context. The file path should point to a valid
--   bitmap file, normally a <tt>.ico</tt>, <tt>.bmp</tt>, <tt>.xpm</tt>,
--   or <tt>.png</tt>, but any file format supported by |Image| is
--   correctly loaded.
--   
--   Instances: <a>Sized</a>.
bitmap :: FilePath -> Bitmap ()

-- | Load a bitmap from an image file (gif, jpg, png, etc.)
bitmapCreateFromFile :: FilePath -> IO (Bitmap ())

-- | Create a bitmap from an image with the same color depth.
bitmapFromImage :: Image a -> IO (Bitmap ())
instance Media (Sound a)
instance Sized (Image a)
instance Sized (Bitmap a)


-- | Define event handling. Events are parametrised by the widget that can
--   correspond to a certain event and the type of the event handler. For
--   example, the <a>resize</a> event has type:
--   
--   <pre>
--   Reactive w =&gt; Event w (IO ())
--   </pre>
--   
--   This means that all widgets in the <a>Reactive</a> class can respond
--   to <a>resize</a> events. (and since <a>Window</a> is an instance of
--   this class, this means that basically all visible widgets are
--   reactive).
--   
--   An <tt>Event w a</tt> can be transformed into an attribute of type
--   <a>Attr</a> <tt>w a</tt> using the <a>on</a> function.
--   
--   <pre>
--   do f &lt;- frame [text := "test"]
--      set f [on resize := set f [text := "resizing"]]
--   </pre>
--   
--   For convenience, the <a>mouse</a> and <a>keyboard</a> have a serie of
--   <i>event filters</i>: <a>click</a>, <a>drag</a>, <a>enterKey</a>,
--   <a>charKey</a>, etc. These filters are write-only and do not overwrite
--   any previous mouse or keyboard handler but all stay active at the same
--   time. However, all filter will be overwritten again when <a>mouse</a>
--   or <a>keyboard</a> is set again. For example, the following program
--   makes sense:
--   
--   <pre>
--   set w [on click := ..., on drag := ...]
--   </pre>
--   
--   But in the following program, only the handler for <a>mouse</a> will
--   be called:
--   
--   <pre>
--   set w [on click := ..., on mouse := ...]
--   </pre>
--   
--   If you want to set the <a>mouse</a> later but retain the old event
--   filters, you can first read the current <a>mouse</a> handler and call
--   it in the new handler (and the same for the <a>keyboard</a> of
--   course). This implemenation technique is used to implement event
--   filters themselves and is also very useful when setting an event
--   handler for a <a>closing</a> event:
--   
--   <pre>
--   set w [on closing :~ \previous -&gt; do{ ...; previous }]
--   </pre>
--   
--   Note that you should call <a>propagateEvent</a> (or
--   <a>skipCurrentEvent</a>) whenever you do not process the event
--   yourself in an event handler. This propagates the event to the parent
--   event handlers and give them a chance to handle the event in an
--   appropiate way. This gives another elegant way to install a
--   <a>closing</a> event handler:
--   
--   <pre>
--   set w [on closing := do{ ...; propagateEvent }]
--   </pre>
module Graphics.UI.WX.Events

-- | An event for a widget <tt>w</tt> that expects an event handler of type
--   <tt>a</tt>.
data Event w a

-- | Transform an event to an attribute.
on :: Event w a -> Attr w a

-- | Change the event type.
mapEvent :: (a -> b) -> (a -> b -> a) -> Event w a -> Event w b

-- | Pass the event on the next <i>wxWidgets</i> event handler, either on
--   this window or its parent. Always call this method when you do not
--   process the event. (This function just call <a>skipCurrentEvent</a>).
propagateEvent :: IO ()

-- | <a>Selecting</a> widgets fire a <a>select</a> event when an item is
--   selected.
class Selecting w
select :: Selecting w => Event w (IO ())

-- | <a>Commanding</a> widgets fire a <a>command</a> event.
class Commanding w
command :: Commanding w => Event w (IO ())

-- | <a>Reactive</a> widgets are almost all visible widgets on the screen.
class Reactive w
mouse :: Reactive w => Event w (EventMouse -> IO ())
keyboard :: Reactive w => Event w (EventKey -> IO ())
closing :: Reactive w => Event w (IO ())
idle :: Reactive w => Event w (IO Bool)
resize :: Reactive w => Event w (IO ())
focus :: Reactive w => Event w (Bool -> IO ())
activate :: Reactive w => Event w (Bool -> IO ())

-- | <a>Paint</a> widgets can serve as a canvas. <i>Note:</i> it is illegal
--   to use both a <a>paint</a> and <a>paintRaw</a> event handler at the
--   same widget.
class Paint w
paint :: Paint w => Event w (DC () -> Rect -> IO ())
paintRaw :: Paint w => Event w (DC () -> Rect -> [Rect] -> IO ())
repaint :: Paint w => w -> IO ()
enter :: Reactive w => Event w (Point -> IO ())
leave :: Reactive w => Event w (Point -> IO ())
motion :: Reactive w => Event w (Point -> IO ())
drag :: Reactive w => Event w (Point -> IO ())
click :: Reactive w => Event w (Point -> IO ())
unclick :: Reactive w => Event w (Point -> IO ())
doubleClick :: Reactive w => Event w (Point -> IO ())
clickRight :: Reactive w => Event w (Point -> IO ())
unclickRight :: Reactive w => Event w (Point -> IO ())
anyKey :: Reactive w => Event w (Key -> IO ())
key :: Reactive w => Key -> Event w (IO ())
charKey :: Reactive w => Char -> Event w (IO ())
enterKey :: Reactive w => Event w (IO ())
tabKey :: Reactive w => Event w (IO ())
escKey :: Reactive w => Event w (IO ())
helpKey :: Reactive w => Event w (IO ())
delKey :: Reactive w => Event w (IO ())
homeKey :: Reactive w => Event w (IO ())
endKey :: Reactive w => Event w (IO ())
pgupKey :: Reactive w => Event w (IO ())
pgdownKey :: Reactive w => Event w (IO ())
downKey :: Reactive w => Event w (IO ())
upKey :: Reactive w => Event w (IO ())
leftKey :: Reactive w => Event w (IO ())
rightKey :: Reactive w => Event w (IO ())
rebind :: Event w (IO ()) -> Event w (IO ())

-- | The <tt>Modifiers</tt> indicate the meta keys that have been pressed
--   (<a>True</a>) or not (<a>False</a>).
data Modifiers :: *
Modifiers :: SrictNotUnpackedBool -> SrictNotUnpackedBool -> SrictNotUnpackedBool -> SrictNotUnpackedBool -> Modifiers

-- | alt key down
altDown :: Modifiers -> SrictNotUnpackedBool

-- | shift key down
shiftDown :: Modifiers -> SrictNotUnpackedBool

-- | control key down
controlDown :: Modifiers -> SrictNotUnpackedBool

-- | meta key down
metaDown :: Modifiers -> SrictNotUnpackedBool

-- | Show modifiers, for example for use in menus.
showModifiers :: Modifiers -> String

-- | Construct a <a>Modifiers</a> structure with no meta keys pressed.
noneDown :: Modifiers

-- | Construct a <a>Modifiers</a> structure with just Shift meta key
--   pressed.
justShift :: Modifiers

-- | Construct a <a>Modifiers</a> structure with just Alt meta key pressed.
justAlt :: Modifiers

-- | Construct a <a>Modifiers</a> structure with just Ctrl meta key
--   pressed.
justControl :: Modifiers

-- | Construct a <a>Modifiers</a> structure with just Meta meta key
--   pressed.
justMeta :: Modifiers

-- | Test if no meta key was pressed.
isNoneDown :: Modifiers -> Bool

-- | Test if no shift, alt, or control key was pressed.
isNoShiftAltControlDown :: Modifiers -> Bool

-- | Mouse events. The <a>Point</a> gives the logical (unscrolled)
--   position.
data EventMouse :: *

-- | Mouse was moved over the client area of the window
MouseMotion :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse enters in the client area of the window
MouseEnter :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse leaves the client area of the window
MouseLeave :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse left button goes down
MouseLeftDown :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse left button goes up
MouseLeftUp :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse left button double click
MouseLeftDClick :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse left button drag
MouseLeftDrag :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse right button goes down
MouseRightDown :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse right button goes up
MouseRightUp :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse right button double click
MouseRightDClick :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse right button drag (unsupported on most platforms)
MouseRightDrag :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse middle button goes down
MouseMiddleDown :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse middle button goes up
MouseMiddleUp :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse middle button double click
MouseMiddleDClick :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse middle button drag (unsupported on most platforms)
MouseMiddleDrag :: SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Mouse wheel rotation. (Bool is True for a downward rotation)
MouseWheel :: SrictNotUnpackedBool -> SrictNotUnpackedPoint -> SrictNotUnpackedModifiers -> EventMouse

-- | Show an <a>EventMouse</a> in a user friendly way.
showMouse :: EventMouse -> String

-- | Extract the position from a <a>MouseEvent</a>.
mousePos :: EventMouse -> Point

-- | Extract the modifiers from a <a>MouseEvent</a>.
mouseModifiers :: EventMouse -> Modifiers
data EventCalendar :: *
CalendarDayChanged :: DateTime () -> EventCalendar
CalendarDoubleClicked :: DateTime () -> EventCalendar
CalendarMonthChanged :: DateTime () -> EventCalendar
CalendarSelectionChanged :: DateTime () -> EventCalendar
CalendarWeekdayClicked :: Int -> EventCalendar
CalendarYearChanged :: DateTime () -> EventCalendar
CalendarUnknown :: EventCalendar
calendarEvent :: Event (CalendarCtrl a) (EventCalendar -> IO ())

-- | A keyboard event contains the key, the modifiers and the focus point.
data EventKey :: *
EventKey :: SrictNotUnpackedKey -> SrictNotUnpackedModifiers -> SrictNotUnpackedPoint -> EventKey

-- | A <a>Key</a> represents a single key on a keyboard.
data Key :: *

-- | An ascii code.
KeyChar :: SrictNotUnpackedChar -> Key

-- | An unknown virtual key.
KeyOther :: SrictNotUnpackedKeyCode -> Key
KeyBack :: Key
KeyTab :: Key
KeyReturn :: Key
KeyEscape :: Key
KeySpace :: Key
KeyDelete :: Key
KeyInsert :: Key
KeyEnd :: Key
KeyHome :: Key
KeyLeft :: Key
KeyUp :: Key
KeyRight :: Key
KeyDown :: Key
KeyPageUp :: Key
KeyPageDown :: Key
KeyStart :: Key
KeyClear :: Key
KeyShift :: Key
KeyAlt :: Key
KeyControl :: Key
KeyMenu :: Key
KeyPause :: Key
KeyCapital :: Key
KeyHelp :: Key
KeySelect :: Key
KeyPrint :: Key
KeyExecute :: Key
KeySnapshot :: Key
KeyCancel :: Key
KeyLeftButton :: Key
KeyRightButton :: Key
KeyMiddleButton :: Key
KeyNum0 :: Key
KeyNum1 :: Key
KeyNum2 :: Key
KeyNum3 :: Key
KeyNum4 :: Key
KeyNum5 :: Key
KeyNum6 :: Key
KeyNum7 :: Key
KeyNum8 :: Key
KeyNum9 :: Key
KeyMultiply :: Key
KeyAdd :: Key
KeySeparator :: Key
KeySubtract :: Key
KeyDecimal :: Key
KeyDivide :: Key
KeyF1 :: Key
KeyF2 :: Key
KeyF3 :: Key
KeyF4 :: Key
KeyF5 :: Key
KeyF6 :: Key
KeyF7 :: Key
KeyF8 :: Key
KeyF9 :: Key
KeyF10 :: Key
KeyF11 :: Key
KeyF12 :: Key
KeyF13 :: Key
KeyF14 :: Key
KeyF15 :: Key
KeyF16 :: Key
KeyF17 :: Key
KeyF18 :: Key
KeyF19 :: Key
KeyF20 :: Key
KeyF21 :: Key
KeyF22 :: Key
KeyF23 :: Key
KeyF24 :: Key
KeyNumLock :: Key
KeyScroll :: Key

-- | Extract the key from a keyboard event.
keyKey :: EventKey -> Key

-- | Extract the modifiers from a keyboard event.
keyModifiers :: EventKey -> Modifiers

-- | Extract the position from a keyboard event.
keyPos :: EventKey -> Point

-- | Show a key for use in menus for example.
showKey :: Key -> String

-- | Show a key/modifiers combination, for example for use in menus.
showKeyModifiers :: Key -> Modifiers -> String

-- | Create a new event from a get and set function.
newEvent :: String -> (w -> IO a) -> (w -> a -> IO ()) -> Event w a


-- | Exports default instances for generic windows.
--   
--   <ul>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Sized</a>,
--   <a>Parent</a>, <a>Help</a>, <a>Bordered</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
module Graphics.UI.WX.Window

-- | Pointer to an object of type <a>Window</a>, derived from
--   <a>EvtHandler</a>.
type Window a = EvtHandler (CWindow a)

-- | Create a plain window. Can be used to define custom controls for
--   example.
--   
--   <ul>
--   <li>Attributes: <a>rootParent</a>, <a>frameParent</a>,
--   <a>tabTraversal</a></li>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
window :: Window a -> [Prop (Window ())] -> IO (Window ())

-- | Ensure that a widget is refitted inside a window when its size
--   changes, for example when the <a>text</a> of a <tt>staticText</tt>
--   control changes. (calls <a>windowReFit</a>)
refit :: Window a -> IO ()

-- | Ensure that a widget is refitted inside a window when its size
--   changes, for example when the <a>text</a> of a <tt>staticText</tt>
--   control changes. Always resizes the window to its minimal acceptable
--   size. (calls <a>windowReFitMinimal</a>)
refitMinimal :: Window a -> IO ()

-- | The ultimate root parent of the widget.
rootParent :: ReadAttr (Window a) (Window ())

-- | The parent frame or dialog of a widget.
frameParent :: ReadAttr (Window a) (Window ())

-- | Enable (or disable) tab-traversal. (= wxTAB_TRAVERSAL)
tabTraversal :: Attr (Window a) Bool

-- | Pointer to an object of type <a>ScrolledWindow</a>, derived from
--   <a>Panel</a>.
type ScrolledWindow a = Panel (CScrolledWindow a)

-- | A scrollable window. Use <a>virtualSize</a> and <a>scrollRate</a> to
--   set the scrollbar behaviour.
--   
--   <ul>
--   <li>Attributes: <a>scrollRate</a></li>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
scrolledWindow :: Window a -> [Prop (ScrolledWindow ())] -> IO (ScrolledWindow ())

-- | The horizontal and vertical scroll rate of scrolled window. Use
--   <tt>0</tt> to disable scrolling in that direction.
scrollRate :: Attr (ScrolledWindow a) Size

-- | Helper function that retrieves initial window settings, including
--   |identity|, |style|, and |area| (or |position| and |outerSize|).
initialWindow :: (Id -> Rect -> [Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Helper function that retrieves initial window settings, including
--   |clipChildren| and |fullRepaintOnResize|.
initialContainer :: (Id -> Rect -> [Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Helper function that retrieves the initial |identity|.
initialIdentity :: Identity w => (Id -> [Prop w] -> a) -> [Prop w] -> a

-- | Helper function that retrieves the initial |style|.
initialStyle :: Styled w => ([Prop w] -> Style -> a) -> [Prop w] -> Style -> a

-- | Retrieve the initial title from the |text| attribute.
initialText :: Textual w => (String -> [Prop w] -> a) -> [Prop w] -> a

-- | Helper function that transforms the style accordding to the
--   <a>fullRepaintOnResize</a> flag in of the properties
initialFullRepaintOnResize :: Visible w => ([Prop w] -> Style -> a) -> [Prop w] -> Style -> a

-- | Helper function that transforms the style accordding to the
--   <a>clipChildren</a> flag out of the properties
initialClipChildren :: Parent w => ([Prop w] -> Style -> a) -> [Prop w] -> Style -> a
instance Paint (Window a)
instance Reactive (Window a)
instance Bordered (Window a)
instance Tipped (Window a)
instance Styled (Window a)
instance Identity (Window a)
instance Child (Window a)
instance Parent (Window a)
instance Visible (Window a)
instance Literate (Window a)
instance Colored (Window a)
instance Sized (Window a)
instance Dimensions (Window a)
instance Textual (Window a)
instance Able (Window a)


-- | wxTopLevelwindow (wxWidgets &gt;= 2.8.0) defines an (abstract) common
--   base class for wxFrame and wxDialog.
--   
--   In the wxHaskell implementation, TopLevel has been added to
--   encapsulate some of the common functionality between the <a>Dialog</a>
--   and <a>Frame</a> modules.
--   
--   <ul>
--   <li>Instances: <a>HasDefault</a>, <a>Pictured</a>, <a>Framed</a>,
--   <a>Form</a>, <a>Closeable</a></li>
--   <li>Instances inherited from <a>Window</a>: <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
module Graphics.UI.WX.TopLevelWindow

-- | Helper function that transforms the style accordding to the
--   <tt>windowResizable</tt> flag in of the properties
initialResizeable :: ([Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Helper function that transforms the style accordding to the
--   <tt>windowMaximizable</tt> flag in of the properties
initialMaximizeable :: ([Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Helper function that transforms the style accordding to the
--   <tt>windowMinimizable</tt> flag in of the properties
initialMinimizeable :: ([Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Helper function that transforms the style accordding to the
--   <tt>windowMinimizable</tt> flag in of the properties
initialCloseable :: ([Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a
instance Closeable (Frame a)
instance Form (Frame a)
instance Framed (TopLevelWindow a)
instance Pictured (TopLevelWindow a)
instance HasDefault (TopLevelWindow a)


-- | Mutable variables.
module Graphics.UI.WX.Variable

-- | Create a mutable variable. Change the value using the |value|
--   attribute.
variable :: [Prop (Var a)] -> IO (Var a)
instance Valued TVar


-- | Frames.
--   
--   <ul>
--   <li>Instances: <a>Form</a>, <a>Closeable</a>, <a>Framed</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>,
--   <a>HasDefault</a>.</li>
--   </ul>
module Graphics.UI.WX.Frame

-- | Pointer to an object of type <a>Frame</a>, derived from
--   <a>TopLevelWindow</a>.
type Frame a = TopLevelWindow (CFrame a)

-- | Create a top-level frame window.
frame :: [Prop (Frame ())] -> IO (Frame ())

-- | Create a top-level frame window that is not resizeable.
frameFixed :: [Prop (Frame ())] -> IO (Frame ())

-- | Create a tool window; floats on the parent and has a small caption.
frameTool :: [Prop (Frame ())] -> Window a -> IO (Frame ())

-- | Create a top-level frame window in a custom style.
frameEx :: Style -> [Prop (Frame ())] -> Window a -> IO (Frame ())

-- | Complete the construction of a top level frame which has been loaded
--   from a resource file.
frameLoadRes :: FilePath -> String -> [Prop (Frame ())] -> IO (Frame ())

-- | Complete the construction of a frame whcih is the child of some
--   existing parent window.
frameLoadChildRes :: Window a -> FilePath -> String -> [Prop (Frame ())] -> IO (Frame ())

-- | initial Frame flags
initialFrame :: (Id -> Rect -> String -> [Prop (Window w)] -> Style -> a) -> [Prop (Window w)] -> Style -> a

-- | Pointer to an object of type <a>MDIParentFrame</a>, derived from
--   <a>Frame</a>.
type MDIParentFrame a = Frame (CMDIParentFrame a)

-- | Pointer to an object of type <a>MDIChildFrame</a>, derived from
--   <a>Frame</a>.
type MDIChildFrame a = Frame (CMDIChildFrame a)

-- | Create an MDI parent frame.
mdiParentFrame :: [Prop (MDIParentFrame ())] -> IO (MDIParentFrame ())

-- | Create a MDI child frame.
mdiChildFrame :: MDIParentFrame a -> [Prop (MDIChildFrame ())] -> IO (MDIChildFrame ())

-- | Create an MDI parent frame with a custom style.
mdiParentFrameEx :: Window a -> Style -> [Prop (MDIParentFrame ())] -> IO (MDIParentFrame ())

-- | Create a MDI child frame with a custom style.
mdiChildFrameEx :: MDIParentFrame a -> Style -> [Prop (MDIChildFrame ())] -> IO (MDIChildFrame ())

-- | Return the active child frame (<a>objectIsNull</a> when no child is
--   active)
activeChild :: ReadAttr (MDIParentFrame a) (MDIChildFrame ())

-- | Activate the next child frame.
activateNext :: MDIParentFrame a -> IO ()

-- | Activate the previous child frame
activatePrevious :: MDIParentFrame a -> IO ()

-- | Arrange iconized mdi child frames.
arrangeIcons :: MDIParentFrame a -> IO ()

-- | Cascade the child frames.
cascade :: MDIParentFrame a -> IO ()

-- | Tile the child frames
tile :: MDIParentFrame a -> IO ()


-- | Defines common GUI controls.
module Graphics.UI.WX.Controls

-- | Alignment.
data Align
AlignLeft :: Align
AlignRight :: Align
AlignCentre :: Align

-- | Widgets that can have aligned content. Note: this property is not used
--   to set the alignment of a widget itself -- See
--   <a>Graphics.UI.WXCore.Layout</a> for more information about layout.
class Aligned w
alignment :: Aligned w => CreateAttr w Align

-- | Wrap mode.
data Wrap

-- | No wrapping (and show a horizontal scrollbar).
WrapNone :: Wrap

-- | Wrap lines that are too long at any position.
WrapLine :: Wrap

-- | Wrap lines that are too long at word boundaries.
WrapWord :: Wrap

-- | Widgets that have wrappable content.
class Wrapped w
wrap :: Wrapped w => CreateAttr w Wrap

-- | Widgets that have sorted contents.
class Sorted w
sorted :: Sorted w => CreateAttr w Bool

-- | Pointer to an object of type <a>Panel</a>, derived from <a>Window</a>.
type Panel a = Window (CPanel a)

-- | Create a <a>Panel</a>, a window that is normally used as a container
--   for controls. It has a standard background and maintains standard
--   keyboard navigation (ie. <i>Tab</i> moves through the controls).
--   
--   Note: <a>defaultButton</a> attibute is removed. Set
--   <a>defaultButton</a> to parent <a>Frame</a> or <a>Dialog</a> instead
--   of this control now. This is an incompatible change to support
--   wxWidgets 2.8.x.
--   
--   <ul>
--   <li>Attributes: <a>focusOn</a></li>
--   <li>Instances: <a>Form</a> -- <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Textual</a>, <a>Literate</a>,
--   <a>Reactive</a>, <a>Paint</a></li>
--   </ul>
panel :: Window a -> [Prop (Panel ())] -> IO (Panel ())

-- | Create a <a>Panel</a> with a specific style.
--   
--   Note: <a>defaultButton</a> attibute is removed. Set
--   <a>defaultButton</a> to parent <a>Frame</a> or <a>Dialog</a> instead
--   of this control now. This is an incompatible change to support
--   wxWidgets 2.8.x.
--   
--   <ul>
--   <li>Attributes: <a>focusOn</a></li>
--   <li>Instances: <a>Form</a> -- <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Textual</a>, <a>Literate</a>,
--   <a>Reactive</a>, <a>Paint</a></li>
--   </ul>
panelEx :: Window a -> Style -> [Prop (Panel ())] -> IO (Panel ())

-- | Pointer to an object of type <a>Notebook</a>, derived from
--   <a>Control</a>.
type Notebook a = Control (CNotebook a)

-- | Create a <a>Notebook</a>. Layout is managed with the <a>tabs</a>
--   combinator.
--   
--   <ul>
--   <li>Instances: <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Textual</a>, <a>Literate</a>, <a>Reactive</a>,
--   <a>Paint</a></li>
--   </ul>
notebook :: Window a -> [Prop (Notebook ())] -> IO (Notebook ())

-- | Set the initial focus on this control.
focusOn :: Window a -> IO ()

-- | Pointer to an object of type <a>Button</a>, derived from
--   <a>Control</a>.
type Button a = Control (CButton a)

-- | Create a standard push button.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
button :: Window a -> [Prop (Button ())] -> IO (Button ())

-- | Create a standard push button with the given flags.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
buttonEx :: Window a -> Style -> [Prop (Button ())] -> IO (Button ())

-- | Create a minimially sized push button.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
smallButton :: Window a -> [Prop (Button ())] -> IO (Button ())

-- | Complete the construction of a push button instance which has been
--   loaded from a resource file.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
buttonRes :: Window a -> String -> [Prop (Button ())] -> IO (Button ())

-- | Pointer to an object of type <a>BitmapButton</a>, derived from
--   <a>Button</a>.
type BitmapButton a = Button (CBitmapButton a)

-- | Create a bitmap button. Use the <a>picture</a> attribute to set the
--   bitmap.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>, <a>Pictured</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
bitmapButton :: Window a -> [Prop (BitmapButton ())] -> IO (BitmapButton ())

-- | Complete the construction of a bitmap button instance which has been
--   loaded from a resource file.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>, <a>Pictured</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
bitmapButtonRes :: Window a -> String -> [Prop (BitmapButton ())] -> IO (BitmapButton ())

-- | Pointer to an object of type <a>TextCtrl</a>, derived from
--   <a>Control</a>.
type TextCtrl a = Control (CTextCtrl a)

-- | Create a single-line text entry control. Note: <a>alignment</a> has to
--   be set at creation time (or the entry has default alignment (=left) ).
--   This is an alias for textEntry
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
entry :: Window a -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Create a single-line text entry control. Note: <a>alignment</a> has to
--   be set at creation time (or the entry has default alignment (=left) ).
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
textEntry :: Window a -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Create a multi-line text control. Note: the <a>wrap</a> and
--   <a>alignment</a> have to be set at creation time or the default to
--   <a>WrapNone</a> and <a>AlignLeft</a> respectively.
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
textCtrl :: Window a -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Create a multi-line text rich-text control with a certain wrap mode
--   Enables font and color settings on windows, while being equal to
--   <a>textCtrl</a> on other platforms. Note: the <a>wrap</a> and
--   <a>alignment</a> have to be set at creation time or the default to
--   <a>WrapNone</a> and <a>AlignLeft</a> respectively.
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
textCtrlRich :: Window a -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Create a generic text control given a certain style.
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
textCtrlEx :: Window a -> Style -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Complete the construction of a text control instance which has been
--   loaded from a resource file.
--   
--   <ul>
--   <li>Instances: <a>Wrap</a>, <a>Aligned</a>, <a>Commanding</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
textCtrlRes :: Window a -> String -> [Prop (TextCtrl ())] -> IO (TextCtrl ())

-- | Process <tt>enter</tt> key events, used in a <a>comboBox</a> or
--   <a>textCtrl</a> and catched using a <a>on</a> <a>command</a> handler.
--   (otherwise pressing <tt>Enter</tt> is either processed internally by
--   the control or used for navigation between dialog controls).
processEnter :: Styled w => Attr w Bool

-- | Process <tt>tab</tt> key events, used in a <a>comboBox</a> or
--   <a>textCtrl</a>. (otherwise pressing <tt>Tab</tt> is either processed
--   internally by the control or used for navigation between dialog
--   controls).
processTab :: Styled w => Attr w Bool

-- | Pointer to an object of type <a>CheckBox</a>, derived from
--   <a>Control</a>.
type CheckBox a = Control (CCheckBox a)

-- | Create a new checkbox.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>,<a>Checkable</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
checkBox :: Window a -> [Prop (CheckBox ())] -> IO (CheckBox ())

-- | Complete the construction of a check box instance which has been
--   loaded from a resource file.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>,<a>Checkable</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
checkBoxRes :: Window a -> String -> [Prop (CheckBox ())] -> IO (CheckBox ())

-- | Pointer to an object of type <a>Choice</a>, derived from
--   <a>Control</a>.
type Choice a = Control (CChoice a)

-- | Create a choice item to select a one of a list of strings.
--   
--   <ul>
--   <li>Instances: <a>Sorted</a>,
--   <a>Selecting</a>,<a>Selection</a>,<a>Items</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
choice :: Window a -> [Prop (Choice ())] -> IO (Choice ())

-- | Create a choice item, given a set of style flags, to select a one of a
--   list of strings
--   
--   <ul>
--   <li>Instances: <a>Selecting</a>,<a>Selection</a>,<a>Items</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
choiceEx :: Window a -> Style -> [Prop (Choice ())] -> IO (Choice ())

-- | Complete the construction of a choice instance which has been loaded
--   from a resource file.
choiceRes :: Window a -> String -> [Prop (Choice ())] -> IO (Choice ())

-- | Pointer to an object of type <a>ComboBox</a>, derived from
--   <a>Choice</a>.
type ComboBox a = Choice (CComboBox a)

-- | Create a new combo box.
--   
--   <ul>
--   <li>Instances: <a>Selecting</a>,
--   <a>Commanding</a>,<a>Selection</a>,<a>Items</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
--   
--   A <a>command</a> event is triggered when the <tt>enter</tt> key is
--   pressed and when <a>processEnter</a> has been set to <a>True</a>.
comboBox :: Window a -> [Prop (ComboBox ())] -> IO (ComboBox ())

-- | Create a new combo box with a given set of flags.
--   
--   <ul>
--   <li>Instances: <a>Selecting</a>,
--   <a>Commanding</a>,<a>Selection</a>,<a>Items</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
--   
--   A <a>command</a> event is triggered when the <tt>enter</tt> key is
--   pressed and when <a>processEnter</a> has been set to <a>True</a>.
comboBoxEx :: Window a -> Style -> [Prop (ComboBox ())] -> IO (ComboBox ())

-- | Complete the construction of a combo box instance which has been
--   loaded from a resource file.
comboBoxRes :: Window a -> String -> [Prop (ComboBox ())] -> IO (ComboBox ())

-- | Pointer to an object of type <a>ListBox</a>, derived from
--   <a>Control</a>.
type ListBox a = Control (CListBox a)

-- | Pointer to single selection list boxes, deriving from <a>ListBox</a>.
type SingleListBox a = ListBox (CSingleListBox a)

-- | Pointer to multiple selection list boxes, deriving from
--   <a>ListBox</a>.
type MultiListBox a = ListBox (CMultiListBox a)

-- | Create a single selection list box.
--   
--   <ul>
--   <li>Instances:
--   <a>Sorted</a>,<a>Selecting</a>,<a>Selection</a>,<a>Items</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
singleListBox :: Window a -> [Prop (SingleListBox ())] -> IO (SingleListBox ())

-- | Complete the construction of a single list box instance which has been
--   loaded from a resource file.
singleListBoxRes :: Window a -> String -> [Prop (SingleListBox ())] -> IO (SingleListBox ())
multiListBox :: Window a -> [Prop (MultiListBox ())] -> IO (MultiListBox ())

-- | Complete the construction of a single list box instance which has been
--   loaded from a resource file.
multiListBoxRes :: Window a -> String -> [Prop (MultiListBox ())] -> IO (MultiListBox ())

-- | Pointer to an object of type <a>RadioBox</a>, derived from
--   <a>Control</a>.
type RadioBox a = Control (CRadioBox a)

-- | Create a new radio button group with an initial orientation and a list
--   of labels. Use <a>selection</a> to get the currently selected item.
--   
--   <ul>
--   <li>Instances: <a>Selecting</a>,<a>Selection</a>,<a>Items</a> --
--   <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>,
--   <a>Visible</a>, <a>Child</a>, <a>Able</a>, <a>Tipped</a>,
--   <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
radioBox :: Window a -> Orientation -> [String] -> [Prop (RadioBox ())] -> IO (RadioBox ())

-- | Complete the construction of a radio box instance which has been
--   loaded from a resource file.
radioBoxRes :: Window a -> String -> [Prop (RadioBox ())] -> IO (RadioBox ())

-- | Pointer to an object of type <a>SpinCtrl</a>, derived from
--   <a>Control</a>.
type SpinCtrl a = Control (CSpinCtrl a)

-- | Create a spin control: a text field with up/down buttons. The value
--   (<a>selection</a>) is always between a specified minimum and maximum.
--   
--   <ul>
--   <li>Instances: <a>Selection</a>, <a>Selecting</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
spinCtrl :: Window a -> Int -> Int -> [Prop (SpinCtrl ())] -> IO (SpinCtrl ())

-- | Complete the construction of a spin control instance which has been
--   loaded from a resource file.
spinCtrlRes :: Window a -> String -> [Prop (SpinCtrl ())] -> IO (SpinCtrl ())

-- | Pointer to an object of type <a>Slider</a>, derived from
--   <a>Control</a>.
type Slider a = Control (CSlider a)

-- | Create a horizontal slider with a specified minimum and maximum. Set
--   the <a>Bool</a> argument to <a>True</a> to show labels (minimumn,
--   maximum, and current value). The <a>selection</a> attribute gives the
--   current value.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>,<a>Selection</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
hslider :: Window a -> Bool -> Int -> Int -> [Prop (Slider ())] -> IO (Slider ())

-- | Create a vertical slider with a specified minimum and maximum. Set the
--   <a>Bool</a> argument to <a>True</a> to show labels (minimumn, maximum,
--   and current value). The <a>selection</a> attribute gives the current
--   value.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>,<a>Selection</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
vslider :: Window a -> Bool -> Int -> Int -> [Prop (Slider ())] -> IO (Slider ())

-- | Create a slider with a specified minimum and maximum. The
--   <a>selection</a> attribute gives the current value.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>,<a>Selection</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
sliderEx :: Window a -> Int -> Int -> Style -> [Prop (Slider ())] -> IO (Slider ())

-- | Complete the construction of a slider instance which has been loaded
--   from a resource file.
sliderRes :: Window a -> String -> [Prop (Slider ())] -> IO (Slider ())

-- | Pointer to an object of type <a>Gauge</a>, derived from
--   <a>Control</a>.
type Gauge a = Control (CGauge a)

-- | Create a horizontal gauge with a specified integer range (max value).
--   The <a>selection</a> attribute determines the position of the gauge.
--   
--   <ul>
--   <li>Instances: <a>Selection</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
hgauge :: Window a -> Int -> [Prop (Gauge ())] -> IO (Gauge ())

-- | Create a vertical gauge with a specified integer range (max value).
--   The <a>selection</a> attribute determines the position of the gauge.
--   
--   <ul>
--   <li>Instances: <a>Selection</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
vgauge :: Window a -> Int -> [Prop (Gauge ())] -> IO (Gauge ())

-- | Create a gauge control. The <a>selection</a> attribute determines the
--   position of the gauge.
--   
--   <ul>
--   <li>Instances: <a>Selection</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
gaugeEx :: Window a -> Int -> Style -> [Prop (Gauge ())] -> IO (Gauge ())

-- | Complete the construction of a gauge instance which has been loaded
--   from a resource file.
gaugeRes :: Window a -> String -> [Prop (Gauge ())] -> IO (Gauge ())

-- | Pointer to an object of type <a>ToggleButton</a>, derived from
--   <a>Control</a>.
type ToggleButton a = Control (CToggleButton a)

-- | Pointer to an object of type <a>BitmapToggleButton</a>, derived from
--   <a>ToggleButton</a>.
type BitmapToggleButton a = ToggleButton (CBitmapToggleButton a)

-- | Create a toggle button.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>, <a>Checkable</a>, -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
toggleButton :: Window a -> [Prop (ToggleButton ())] -> IO (ToggleButton ())

-- | Create a bitmap toggle button. Use the <a>picture</a> attribute to set
--   the bitmap.
--   
--   <ul>
--   <li>Instances: <a>Commanding</a>, <a>Pictured</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
bitmapToggleButton :: Window a -> [Prop (BitmapToggleButton ())] -> IO (BitmapToggleButton ())

-- | Pointer to an object of type <a>TreeCtrl</a>, derived from
--   <a>Control</a>.
type TreeCtrl a = Control (CTreeCtrl a)

-- | Create a single-selection tree control with buttons (i.e. + and -
--   signs).
--   
--   <ul>
--   <li>Attributes: <a>treeEvent</a></li>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
treeCtrl :: Window a -> [Prop (TreeCtrl ())] -> IO (TreeCtrl ())

-- | Create a tree control.
--   
--   <ul>
--   <li>Attributes: <a>treeEvent</a></li>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
treeCtrlEx :: Window a -> Style -> [Prop (TreeCtrl ())] -> IO (TreeCtrl ())

-- | Tree control events.
treeEvent :: Event (TreeCtrl a) (EventTree -> IO ())

-- | Complete the construction of a tree control instance which has been
--   loaded from a resource file.
treeCtrlRes :: Window a -> String -> [Prop (TreeCtrl ())] -> IO (TreeCtrl ())

-- | Pointer to an object of type <a>ListCtrl</a>, derived from
--   <a>Control</a>.
type ListCtrl a = Control (CListCtrl a)

-- | Create a report-style list control.
--   
--   <ul>
--   <li>Attributes: <a>listEvent</a>, <a>columns</a></li>
--   <li>Instances: <a>Items</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
listCtrl :: Window a -> [Prop (ListCtrl ())] -> IO (ListCtrl ())

-- | Create a list control.
--   
--   <ul>
--   <li>Attributes: <a>listEvent</a>, <a>columns</a></li>
--   <li>Instances: <a>Items</a> -- <a>Textual</a>, <a>Literate</a>,
--   <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>, <a>Child</a>,
--   <a>Able</a>, <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>,
--   <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
listCtrlEx :: Window a -> Style -> [Prop (ListCtrl ())] -> IO (ListCtrl ())

-- | Complete the construction of a list control instance which has been
--   loaded from a resource file.
listCtrlRes :: Window a -> String -> [Prop (ListCtrl ())] -> IO (ListCtrl ())
listCtrlSetColumnWidths :: ListCtrl () -> Int -> IO ()

-- | List control events.
listEvent :: Event (ListCtrl a) (EventList -> IO ())

-- | The <tt>columns</tt> attribute controls the columns in a report-view
--   list control.
columns :: Attr (ListCtrl a) [(String, Align, Int)]

-- | A small wrapper over WX's ListCtrl, allowing us to keep the data we're
--   representing as well as its string form (shown to the user as rows).
data ListView a
ListView :: ListCtrl () -> Var [a] -> (a -> [String]) -> ListView a
listViewCtrl :: ListView a -> ListCtrl ()
listViewItems :: ListView a -> Var [a]
listViewToRow :: ListView a -> a -> [String]
listViewLayout :: ListView a -> Layout
listViewSetHandler :: ListView a -> (EventList -> IO ()) -> IO ()
listViewSelectHandle :: ListView a -> (Maybe a -> IO ()) -> EventList -> IO ()
listViewSetItems :: ListView a -> [a] -> IO ()
listViewGetItems :: ListView a -> IO [a]
listViewAddItem :: ListView a -> a -> IO ()
listView :: Window b -> [String] -> (a -> [String]) -> IO (ListView a)

-- | Pointer to an object of type <a>StaticText</a>, derived from
--   <a>Control</a>.
type StaticText a = Control (CStaticText a)

-- | Create static text label, see also <a>label</a>.
staticText :: Window a -> [Prop (StaticText ())] -> IO (StaticText ())

-- | Complete the construction of a static text label instance which has
--   been loaded from a resource file.
staticTextRes :: Window a -> String -> [Prop (StaticText ())] -> IO (StaticText ())

-- | Pointer to an object of type <a>SplitterWindow</a>, derived from
--   <a>Window</a>.
type SplitterWindow a = Window (CSplitterWindow a)

-- | Create a splitter window.
--   
--   <ul>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
splitterWindow :: Window a -> [Prop (SplitterWindow ())] -> IO (SplitterWindow ())

-- | Pointer to an object of type <a>ImageList</a>, derived from
--   <a>WxObject</a>.
type ImageList a = WxObject (CImageList a)

-- | Create an empty image list that will contain images of the desired
--   size.
imageList :: Size -> IO (ImageList ())

-- | Create an image list containing the images in the supplied file name
--   list that will be scaled towards the desired size.
imageListFromFiles :: Size -> [FilePath] -> IO (ImageList ())

-- | Optional back-end for your MediaCtrl. If you want to know more about
--   back-end, you must see wxWidgets' Document.
--   <a>http://www.wxwidgets.org/manuals/stable/wx_wxmediactrl.html#choosingbackendwxmediactrl</a>
data MediaCtrlBackend

-- | Use ActiveMovie/DirectShow. Default back-end on Windows.
DirectShow :: MediaCtrlBackend

-- | Use Media Command Interface. Windows Only.
MediaControlInterface :: MediaCtrlBackend

-- | Use Windows Media Player 10. Windows Only. Require to use wxWidgets
--   2.8.x.
WindowsMediaPlayer10 :: MediaCtrlBackend

-- | Use QuickTime. Mac Only.
QuickTime :: MediaCtrlBackend

-- | Use GStreamer. Unix Only. Require GStreamer and GStreamer Support.
GStreamer :: MediaCtrlBackend

-- | Use default back-end on your platform.
DefaultBackend :: MediaCtrlBackend

-- | Pointer to an object of type <a>MediaCtrl</a>, derived from
--   <a>Window</a>.
type MediaCtrl a = Window (CMediaCtrl a)
mediaCtrl :: Window a -> [Prop (MediaCtrl ())] -> IO (MediaCtrl ())

-- | Create MediaCtrl with choosing back-end. This is useful to select
--   back-end on Windows. But if you don't want to cause any effect to
--   other platforms, you must use wxToolkit or #ifdef macro to choose
--   correct function for platforms. For example,
--   
--   <pre>
--   import Graphics.UI.WXCore.Defines
--   ...
--     m &lt;- case wxToolkit of
--            WxMSW -&gt; mediaCtrlWithBackend f MediaControlInterface []
--            _     -&gt; mediaCtrl f []
--   </pre>
--   
--   or
--   
--   <pre>
--   #ifdef mingw32_HOST_OS || mingw32_TARGET_OS
--     m &lt;-  mediaCtrlWithBackend f MediaControlInterface []
--   #else
--     m &lt;-  mediaCtrl f []
--   #endif
--   </pre>
mediaCtrlWithBackend :: Window a -> MediaCtrlBackend -> [Prop (MediaCtrl ())] -> IO (MediaCtrl ())
mediaCtrlEx :: Window a -> Style -> MediaCtrlBackend -> [Prop (MediaCtrl ())] -> IO (MediaCtrl ())

-- | Pointer to an object of type <a>StyledTextCtrl</a>, derived from
--   <a>Control</a>.
type StyledTextCtrl a = Control (CStyledTextCtrl a)
stcEvent :: Event (StyledTextCtrl ()) (EventSTC -> IO ())
styledTextCtrl :: Window a -> [Prop (StyledTextCtrl ())] -> IO (StyledTextCtrl ())
styledTextCtrlEx :: Window a -> Style -> [Prop (StyledTextCtrl ())] -> IO (StyledTextCtrl ())

-- | Pointer to an object of type <a>PropertyGrid</a>, derived from
--   <a>Control</a>.
type PropertyGrid a = Control (CPropertyGrid a)

-- | Create a property grid.
--   
--   <ul>
--   <li>Attributes: <a>propertyGridEvent</a>,</li>
--   <li>Instances: <a>Textual</a>, <a>Literate</a>, <a>Dimensions</a>,
--   <a>Colored</a>, <a>Visible</a>, <a>Child</a>, <a>Able</a>,
--   <a>Tipped</a>, <a>Identity</a>, <a>Styled</a>, <a>Reactive</a>,
--   <a>Paint</a>.</li>
--   </ul>
propertyGrid :: Window a -> [Prop (PropertyGrid ())] -> IO (PropertyGrid ())

-- | PropertyGrid control events.
propertyGridEvent :: Event (PropertyGrid a) (EventPropertyGrid -> IO ())
instance Typeable Align
instance Typeable Wrap
instance Eq Align
instance Show Align
instance Read Align
instance Eq Wrap
instance Show Wrap
instance Read Wrap
instance Eq MediaCtrlBackend
instance Show MediaCtrlBackend
instance Media (MediaCtrl a)
instance Items (ListCtrl a) [String]
instance Pictured (BitmapToggleButton a)
instance Checkable (ToggleButton a)
instance Commanding (ToggleButton a)
instance Selecting (SpinCtrl a)
instance Selection (SpinCtrl a)
instance Selection (Slider a)
instance Commanding (Slider a)
instance Selection (Gauge a)
instance Items (RadioBox a) String
instance Selection (RadioBox a)
instance Selecting (RadioBox a)
instance Selections (MultiListBox a)
instance Selection (SingleListBox a)
instance Items (ListBox a) String
instance Selecting (ListBox a)
instance Sorted (ListBox a)
instance Selection (ComboBox a)
instance Selecting (ComboBox a)
instance Commanding (ComboBox a)
instance Items (Choice a) String
instance Selection (Choice ())
instance Selecting (Choice ())
instance Sorted (Choice a)
instance Checkable (CheckBox a)
instance Commanding (CheckBox a)
instance Commanding (TextCtrl a)
instance Wrapped (TextCtrl a)
instance Aligned (TextCtrl a)
instance BitMask Wrap
instance BitMask Align
instance Pictured (BitmapButton a)
instance Commanding (Button a)
instance Form (Panel a)


-- | Defines common dialogs.
--   
--   <ul>
--   <li>Instances: <a>Form</a>, <a>Framed</a> -- <a>Textual</a>,
--   <a>Literate</a>, <a>Dimensions</a>, <a>Colored</a>, <a>Visible</a>,
--   <a>Child</a>, <a>Able</a>, <a>Tipped</a>, <a>Identity</a>,
--   <a>Styled</a>, <a>Reactive</a>, <a>Paint</a>.</li>
--   </ul>
module Graphics.UI.WX.Dialogs

-- | Pointer to an object of type <a>Dialog</a>, derived from
--   <a>TopLevelWindow</a>.
type Dialog a = TopLevelWindow (CDialog a)

-- | Create a dialog window. Use <a>showModal</a> for a modal dialog. Use
--   the <a>visible</a> property to show/hide a modeless dialog.
dialog :: Window a -> [Prop (Dialog ())] -> IO (Dialog ())

-- | Show a modal dialog. Take a function as argument that takes a function
--   itself as argument that can be used to end the modal dialog. The
--   argument of this function is returned as the result of the dialog. The
--   result is <a>Nothing</a> when the dialog is dismissed via the system
--   menu.
--   
--   <pre>
--   d   &lt;- dialog w [text := "Demo"]
--   ok  &lt;- button d [text := "Ok"]
--   ...
--   result &lt;- showModal d (\stop -&gt; set ok [on command := stop (Just 42)])
--   </pre>
showModal :: Dialog b -> ((Maybe a -> IO ()) -> IO ()) -> IO (Maybe a)

-- | An error dialog with a single <i>Ok</i> button.
--   
--   <pre>
--   errorDialog parent "error" "fatal error, please re-install windows"
--   </pre>
errorDialog :: Window a -> String -> String -> IO ()

-- | An warning dialog with a single <i>Ok</i> button.
--   
--   <pre>
--   warningDialog parent "warning" "you need a break"
--   </pre>
warningDialog :: Window a -> String -> String -> IO ()

-- | An information dialog with a single <i>Ok</i> button.
--   
--   <pre>
--   infoDialog parent "info" "you've got mail"
--   </pre>
infoDialog :: Window a -> String -> String -> IO ()

-- | The expression (<tt>confirmDialog caption msg yesDefault parent</tt>)
--   shows a confirm dialog with a <i>Yes</i> and <i>No</i> button. If
--   <tt>yesDefault</tt> is <a>True</a>, the <i>Yes</i> button is default,
--   otherwise the <i>No</i> button. Returns <a>True</a> when the
--   <i>Yes</i> button was pressed.
--   
--   <pre>
--   yes &lt;- confirmDialog parent "confirm" "are you sure that you want to reformat the hardisk?"
--   </pre>
confirmDialog :: Window a -> String -> String -> Bool -> IO Bool

-- | An dialog with an <i>Ok</i> and <i>Cancel</i> button. Returns
--   <a>True</a> when <i>Ok</i> is pressed.
--   
--   <pre>
--   proceedDialog parent "Error" "Do you want to debug this application?"
--   </pre>
proceedDialog :: Window a -> String -> String -> IO Bool

-- | Show a modal file selection dialog. Usage:
--   
--   <pre>
--   fileOpenDialog parent rememberCurrentDir allowReadOnly message wildcards directory filename
--   </pre>
--   
--   If <tt>rememberCurrentDir</tt> is <a>True</a>, the library changes the
--   current directory to the one where the files were chosen.
--   <tt>allowReadOnly</tt> determines whether the read-only files can be
--   selected. The <tt>message</tt> is displayed on top of the dialog. The
--   <tt>directory</tt> is the default directory (use the empty string for
--   the current directory). The <tt>filename</tt> is the default file
--   name. The <tt>wildcards</tt> determine the entries in the file
--   selection box. It consists of a list of pairs: the first element is a
--   description (<tt>"Image files"</tt>) and the second element a list of
--   wildcard patterns (<tt>["*.bmp","*.gif"]</tt>).
--   
--   <pre>
--   fileOpenDialog frame True True "Open image" [("Any file",["*.*"]),("Bitmaps",["*.bmp"])] "" ""
--   </pre>
--   
--   Returns <a>Nothing</a> when the user presses the cancel button.
fileOpenDialog :: Window a -> Bool -> Bool -> String -> [(String, [String])] -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Opens a dialog that lets the user select multiple files. See
--   <a>fileOpenDialog</a> for a description of the arguments. Returns the
--   empty list when the user selected no files or pressed the cancel
--   button.
filesOpenDialog :: Window a -> Bool -> Bool -> String -> [(String, [String])] -> FilePath -> FilePath -> IO [FilePath]

-- | Show a modal file save dialog. Usage:
--   
--   <pre>
--   fileSaveDialog parent rememberCurrentDir overwritePrompt message directory filename
--   </pre>
--   
--   The <tt>overwritePrompt</tt> argument determines whether the user gets
--   a prompt for confirmation when overwriting a file. The other arguments
--   are as in <a>fileOpenDialog</a>.
fileSaveDialog :: Window a -> Bool -> Bool -> String -> [(String, [String])] -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Show a modal directory dialog. Usage:
--   
--   <pre>
--   dirOpenDialog parent allowNewDir message directory
--   </pre>
--   
--   The <tt>allowNewDir</tt> argument determines whether the user can
--   create new directories and edit directory names. The <tt>message</tt>
--   is displayed on top of the dialog and <tt>directory</tt> is the
--   default directory (or empty for the current directory). Return
--   <a>Nothing</a> when the users presses the cancel button.
dirOpenDialog :: Window a -> Bool -> FilePath -> FilePath -> IO (Maybe FilePath)

-- | Show a font selection dialog with a given initial font. Returns
--   <a>Nothing</a> when cancel was pressed.
fontDialog :: Window a -> FontStyle -> IO (Maybe FontStyle)

-- | Show a color selection dialog given an initial color. Returns
--   <a>Nothing</a> when cancel was pressed.
colorDialog :: Window a -> Color -> IO (Maybe Color)

-- | Retrieve a password from a user. Returns the empty string on cancel.
--   Usage:
--   
--   <pre>
--   passwordDialog window message caption defaultText
--   </pre>
passwordDialog :: Window a -> String -> String -> String -> IO String

-- | Retrieve a text string from a user. Returns the empty string on
--   cancel. Usage:
--   
--   <pre>
--   textDialog window message caption defaultText
--   </pre>
textDialog :: Window a -> String -> String -> String -> IO String

-- | Retrieve a <i>positive</i> number from a user. Returns <a>Nothing</a>
--   on cancel. Usage:
--   
--   <pre>
--   numberDialog window message prompt caption initialValue minimum maximum
--   </pre>
numberDialog :: Window a -> String -> String -> String -> Int -> Int -> Int -> IO (Maybe Int)

-- | Create a dialog window with a certain style.
dialogEx :: Window a -> Style -> [Prop (Dialog ())] -> IO (Dialog ())
instance Form (Dialog a)


-- | Support for milli-second timers.
module Graphics.UI.WX.Timer

-- | A timer generates a <a>command</a> event on a specified milli-second
--   <a>interval</a>.
--   
--   <ul>
--   <li>Attributes: <a>interval</a></li>
--   <li>Instances: <a>Able</a>, <a>Commanding</a></li>
--   </ul>
type Timer = TimerEx ()

-- | Create a new timer with a 1 second interval. The timer is
--   automatically discarded when the parent is deleted.
timer :: Window a -> [Prop Timer] -> IO Timer

-- | The milli-second interval of the timer.
interval :: Attr Timer Int
instance Commanding Timer
instance Able Timer


-- | Defines Menus, toolbars, and statusbars.
--   
--   The function <a>menuPane</a> is used to create a menu that can contain
--   <a>menuItem</a>s. Menu items can contain event handlers using
--   (<a>on</a> <a>command</a>), but they can also be set, using the
--   <a>menu</a> function, on a frame or (mdi) window so that the menu
--   command is handled in the context of the active window instead of the
--   context of the entire application.
--   
--   <pre>
--   do frame  &lt;- frame    [text := "Demo"]
--      file   &lt;- menuPane [text := "&amp;File"]
--      mclose &lt;- menuItem file [text := "&amp;Close\tCtrl+C", help := "Close the document"] 
--      set frame [menuBar          := [file] 
--                ,on (menu mclose) := ...] 
--   </pre>
module Graphics.UI.WX.Menu

-- | Pointer to an object of type <a>MenuBar</a>, derived from
--   <a>EvtHandler</a>.
type MenuBar a = EvtHandler (CMenuBar a)

-- | Pointer to an object of type <a>Menu</a>, derived from
--   <a>EvtHandler</a>.
type Menu a = EvtHandler (CMenu a)

-- | Set the menu bar of a frame.
menuBar :: WriteAttr (Frame a) [Menu ()]

-- | Show a popup menu for a certain window.
menuPopup :: Menu b -> Point -> Window a -> IO ()

-- | Create a new menu with a certain title (corresponds with <a>text</a>
--   attribute).
--   
--   <ul>
--   <li>Instances: <a>Textual</a></li>
--   </ul>
menuPane :: [Prop (Menu ())] -> IO (Menu ())

-- | Append a <i>help</i> menu item (<tt>"&amp;Help"</tt>). On some
--   platforms, the <i>help</i> menu is handled specially
menuHelp :: [Prop (Menu ())] -> IO (Menu ())

-- | Complete the construction of a menu which has been loaded from a
--   resource file. | Get a menu by name from a menu loaded from a resource
--   file, given the frame which owns the menu. You can directly set
--   properties on the item as part of the call, which enables simple
--   connection of event handlers (e.g. on command).
menuRes :: Window a -> String -> [Prop (Menu ())] -> IO (Menu ())

-- | Retrieve a menu bar instance which has been constructed by loading a
--   resource file for a given top level window.
menuBarLoadRes :: Window a -> FilePath -> String -> IO (MenuBar ())

-- | React to menu events.
menu :: MenuItem a -> Event (Window w) (IO ())

-- | React to a menu event based on identity.
menuId :: Id -> Event (Window w) (IO ())

-- | Pointer to an object of type <a>MenuItem</a>, derived from
--   <a>WxObject</a>.
type MenuItem a = WxObject (CMenuItem a)

-- | Append a menu item. The label can contain menu accellerators by using
--   an ampersand. It can also contain keyboard accellerators after a tab
--   (<tt>'\\t'</tt>) character.
--   
--   <pre>
--   menuItem menu [text := "&amp;Open\tCtrl+O", help := "Opens an existing document"] 
--   </pre>
--   
--   You can create a checkable menu item by setting <a>checkable</a> to
--   <a>True</a> in the properties of a menu item.
--   
--   Note: on GTK, it is required to set the <a>text</a> attribute
--   immediately at creation time.
--   
--   <ul>
--   <li>Events: <a>menu</a>, <a>menuId</a></li>
--   <li>Instances: <a>Textual</a>, <a>Able</a>, <a>Help</a>,
--   <a>Checkable</a>, <a>Identity</a>, <a>Commanding</a>.</li>
--   </ul>
menuItem :: Menu a -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | Append an <i>quit</i> menu item (<tt>"&amp;QuittCtrl+Q"</tt>). On some
--   platforms, the <i>quit</i> menu is handled specially
--   
--   <ul>
--   <li>Events: <a>menu</a>, <a>menuId</a></li>
--   <li>Instances: <a>Textual</a>, <a>Able</a>, <a>Help</a>,
--   <a>Checkable</a>, <a>Identity</a>, <a>Commanding</a>.</li>
--   </ul>
menuQuit :: Menu a -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | Append an <i>about</i> menu item (<tt>"&amp;About..."</tt>). On some
--   platforms, the <i>about</i> menu is handled specially.
--   
--   <ul>
--   <li>Events: <a>menu</a>, <a>menuId</a></li>
--   <li>Instances: <a>Textual</a>, <a>Able</a>, <a>Help</a>,
--   <a>Checkable</a>, <a>Identity</a>, <a>Commanding</a>.</li>
--   </ul>
menuAbout :: Menu a -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | Append a menu item with a specific id, label, and kind (like
--   <a>wxITEM_CHECK</a>).
--   
--   <ul>
--   <li>Events: <a>menu</a>, <a>menuId</a></li>
--   <li>Instances: <a>Textual</a>, <a>Able</a>, <a>Help</a>,
--   <a>Checkable</a>, <a>Identity</a>, <a>Commanding</a>.</li>
--   </ul>
menuItemEx :: Menu a -> Id -> String -> Int -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | When setting event handlers on menu items which have been loaded from
--   XRC resource files, properties cannot be used as the menu item
--   instances are opaque to wxHaskell.
--   
--   This function offers a convenient way to attach menu item event
--   handlers, given the identity of the window which owns the menu
--   containing the menu item, and the name of the menu item
menuItemOnCommandRes :: Window a -> String -> IO () -> IO ()

-- | Add a menu seperator.
menuLine :: Menu a -> IO ()

-- | Create a submenu item.
menuSub :: Menu b -> Menu a -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | Append a radio menu item. These items are <a>checkable</a> by default.
--   A sequence of radio menu items form automatically a group. A different
--   kind of menu item, like a <a>menuLine</a>, terminates the group. Note:
--   one sometimes has to set the first selected radio item specifically
--   after setting the "menubar" property, or otherwise the radio item
--   bullet is not displayed on windows. See <a>menuItem</a> for other
--   properties of menu radio items.
menuRadioItem :: Menu a -> [Prop (MenuItem ())] -> IO (MenuItem ())

-- | Pointer to an object of type <a>ToolBar</a>, derived from
--   <a>ToolBarBase</a>.
type ToolBar a = ToolBarBase (CToolBar a)

-- | Create a toolbar window with a divider and text labels. Normally, you
--   can use <a>toolMenu</a> to add tools in the toolbar that behave like
--   normal menu items.
--   
--   <pre>
--   tbar   &lt;- toolBar f []
--   toolMenu tbar open  "Open"  "open.png"  []
--   toolMenu tbar about "About" "about.png" []
--   </pre>
toolBar :: Frame a -> [Prop (ToolBar ())] -> IO (ToolBar ())

-- | Create a toolbar window. The second argument specifies whether text
--   labels should be shown, and the third argument whether a divider line
--   is present above the toolbar.
toolBarEx :: Frame a -> Bool -> Bool -> [Prop (ToolBar ())] -> IO (ToolBar ())

-- | A tool in a toolbar.
--   
--   <ul>
--   <li>Events: <a>tool</a></li>
--   <li>Instances: <a>Able</a>, <a>Help</a>, <a>Tipped</a>,
--   <a>Checkable</a>, <a>Identity</a>, <a>Commanding</a>.</li>
--   </ul>
data ToolBarItem

-- | Create a tool bar item based on a menu. Takes a a relevant menu item,
--   a label and an image file (bmp, png, gif, ico, etc.) as arguments. The
--   image file is normally 16x15 pixels. The toolbar item will fire the
--   relevant menu items just as if the menu has been selected. Checkable
--   menus will give a checkable toolbar item. Beware though that checkable
--   tools normally require a specific <tt>on command</tt> handler to keep
--   them synchronised with the corresponding menu item.
toolMenu :: ToolBar a -> MenuItem a -> String -> FilePath -> [Prop ToolBarItem] -> IO ToolBarItem

-- | This is a generalized version of <a>toolMenu</a> function. You can
--   specify <a>Bitmap</a> that is loaded from any other place instead of
--   using <a>FilePath</a> directly.
toolMenuFromBitmap :: ToolBar a -> MenuItem a -> String -> Bitmap b -> [Prop ToolBarItem] -> IO ToolBarItem

-- | Create an <i>orphan</i> toolbar item that is unassociated with a menu.
--   Takes a label, a flag that is <a>True</a> when the item is
--   <a>checkable</a> and a path to an image (bmp, png, gif, ico, etc.) as
--   arguments.
toolItem :: ToolBar a -> String -> Bool -> FilePath -> [Prop ToolBarItem] -> IO ToolBarItem

-- | Add an arbitrary control to a toolbar (typically a <a>ComboBox</a>).
--   The control must be created with the toolbar as the parent.
toolControl :: ToolBar a -> Control b -> IO ()

-- | React on tool event. (normally handled by <a>menu</a> though, so only
--   use this for orphan toolbar items).
tool :: ToolBarItem -> Event (Window w) (IO ())

-- | A field in a status bar.
--   
--   <ul>
--   <li>Instances: <a>Textual</a></li>
--   </ul>
data StatusField

-- | Specify the statusbar of a frame.
statusBar :: WriteAttr (Frame a) [StatusField]

-- | Create a status field.
statusField :: [Prop StatusField] -> IO StatusField

-- | The status width attribute determines the width of a status bar field.
--   A negative width makes the field stretchable. The width than
--   determines the amount of stretch in relation to other fields. The
--   default status width is <tt>-1</tt>, ie. all fields stretch evenly.
--   
--   Here is an example of a status bar with three fields, where the last
--   field is 50 pixels wide, the first takes 66% of the remaining space
--   and the second field 33%.
--   
--   <pre>
--   field1 &lt;- statusField [statusWidth := -2]
--   field2 &lt;- statusField [text := "hi"]
--   field3 &lt;- statusField [statusWidth := 50]
--   set frame [statusBar := [field1,field2,field3]] 
--   </pre>
statusWidth :: Attr StatusField Int

-- | <i>Deprecated</i>: use <a>menuPane</a>.

-- | <i>Deprecated: Use menuPane instead</i>
menuList :: [Prop (Menu ())] -> IO (Menu ())

-- | <i>Deprecated</i>: use <a>menuBar</a>.

-- | <i>Deprecated: Use menuBar instead</i>
menubar :: WriteAttr (Frame a) [Menu ()]

-- | <i>Deprecated</i>: use <a>statusBar</a>.

-- | <i>Deprecated: Use statusBar instead</i>
statusbar :: WriteAttr (Frame a) [StatusField]
instance Textual StatusField
instance Commanding ToolBarItem
instance Identity ToolBarItem
instance Checkable ToolBarItem
instance Help ToolBarItem
instance Tipped ToolBarItem
instance Able ToolBarItem
instance Commanding (MenuItem a)
instance Identity (MenuItem a)
instance Checkable (MenuItem a)
instance Help (MenuItem a)
instance Textual (MenuItem a)
instance Able (MenuItem a)
instance Textual (Menu a)


-- | Drawing.
--   
--   A <i>Device Context</i> or <a>DC</a>, is an instance of <a>Drawn</a>,
--   <a>Brushed</a>, <a>Literate</a>, and <a>Colored</a>.
module Graphics.UI.WX.Draw
class Drawn w
pen :: Drawn w => Attr w PenStyle
penKind :: Drawn w => Attr w PenKind
penWidth :: Drawn w => Attr w Int
penCap :: Drawn w => Attr w CapStyle
penJoin :: Drawn w => Attr w JoinStyle
penColor :: Drawn w => Attr w Color
class Brushed w
brush :: Brushed w => Attr w BrushStyle
brushKind :: Brushed w => Attr w BrushKind
brushColor :: Brushed w => Attr w Color

-- | Pointer to an object of type <a>DC</a>, derived from <a>WxObject</a>.
type DC a = WxObject (CDC a)

-- | Pointer to an object of type <a>Bitmap</a>, derived from
--   <a>GDIObject</a>.
type Bitmap a = GDIObject (CBitmap a)

-- | Draw a circle given a center point and radius.
circle :: DC a -> Point -> Int -> [Prop (DC a)] -> IO ()

-- | Draw an arc of a circle. Takes the center of the circle, its radius
--   and a starting and ending point relative to the three-o'clock
--   position. Angles are in degrees and positive values denote a counter
--   clockwise motion. If the angles are equal, an entire circle is drawn.
arc :: DC a -> Point -> Int -> Double -> Double -> [Prop (DC a)] -> IO ()

-- | Draw an ellipse, bounded by a certain rectangle.
ellipse :: DC a -> Rect -> [Prop (DC a)] -> IO ()

-- | Draw an elliptic arc. Takes the bounding rectangle, and a starting and
--   ending point relative to the three-o'clock position from the center of
--   the rectangle. Angles are in degrees and positive values denote a
--   counter clockwise motion. If the angles are equal, an entire ellipse
--   is drawn.
ellipticArc :: DC a -> Rect -> Double -> Double -> [Prop (DC a)] -> IO ()

-- | Draw a line.
line :: DC a -> Point -> Point -> [Prop (DC a)] -> IO ()

-- | Draw a polyline.
polyline :: DC a -> [Point] -> [Prop (DC a)] -> IO ()

-- | Draw a polygon. The polygon is filled with the odd-even rule. Note
--   that the polygon is automatically closed.
polygon :: DC a -> [Point] -> [Prop (DC a)] -> IO ()

-- | Draw a single point.
drawPoint :: DC a -> Point -> [Prop (DC a)] -> IO ()

-- | Draw a rectangle.
drawRect :: DC a -> Rect -> [Prop (DC a)] -> IO ()

-- | Draw a rectangle with rounded corners. The corners are quarter circles
--   with the given radius. If radius is positive, the value is assumed to
--   be the radius of the rounded corner. If radius is negative, the
--   absolute value is assumed to be the proportion of the smallest
--   dimension of the rectangle. This means that the corner can be a
--   sensible size relative to the size of the rectangle, and also avoids
--   the strange effects X produces when the corners are too big for the
--   rectangle.
roundedRect :: DC a -> Rect -> Double -> [Prop (DC a)] -> IO ()

-- | Draw text.
drawText :: DC a -> String -> Point -> [Prop (DC a)] -> IO ()

-- | Draw rotated text. Takes an angle in degrees relative to the
--   three-o'clock position.
rotatedText :: DC a -> String -> Point -> Double -> [Prop (DC a)] -> IO ()

-- | Draw a bitmap. Takes a bitmap, a point and a boolean that is
--   <a>True</a> when the bitmap is drawn with a transparency mask.
drawBitmap :: DC a -> Bitmap () -> Point -> Bool -> [Prop (DC a)] -> IO ()

-- | Draw an image.
drawImage :: DC a -> Image b -> Point -> [Prop (DC a)] -> IO ()
dcWith :: DC a -> [Prop (DC a)] -> IO b -> IO b

-- | usage: (<tt>dcClear obj</tt>).
dcClear :: DC a -> IO ()
instance Colored (DC a)
instance Literate (DC a)
instance Brushed (DC a)
instance Drawn (DC a)


-- | The WX module just re-exports functionality from helper modules and
--   defines the <a>start</a> function.
--   
--   The WX library provides a <i>haskellized</i> interface to the raw
--   wxWidgets functionality provided by the <a>Graphics.UI.WXCore</a>
--   library.
module Graphics.UI.WX

-- | <a>start</a> runs the GUI.
start :: IO a -> IO ()
