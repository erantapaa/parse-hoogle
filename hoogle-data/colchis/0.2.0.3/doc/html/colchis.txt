-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Rudimentary JSON-RPC 2.0 client over raw TCP.
--   
@package colchis
@version 0.2.0.3

module Network.Colchis.Protocol.JSONRPC20.Response
data Response
Response :: Text -> Maybe Value -> Maybe ErrorObject -> Value -> Response
_jsonrpc :: Response -> Text
_result :: Response -> Maybe Value
_error :: Response -> Maybe ErrorObject
_id :: Response -> Value
data ErrorObject
ErrorObject :: Int -> Text -> Maybe Value -> ErrorObject
_code :: ErrorObject -> Int
_message :: ErrorObject -> Text
_data :: ErrorObject -> Maybe Value
instance Generic ErrorObject
instance Show ErrorObject
instance Generic Response
instance Show Response
instance Datatype D1ErrorObject
instance Constructor C1_0ErrorObject
instance Selector S1_0_0ErrorObject
instance Selector S1_0_1ErrorObject
instance Selector S1_0_2ErrorObject
instance Datatype D1Response
instance Constructor C1_0Response
instance Selector S1_0_0Response
instance Selector S1_0_1Response
instance Selector S1_0_2Response
instance Selector S1_0_3Response
instance FromJSON ErrorObject
instance FromJSON Response

module Network.Colchis.Protocol.JSONRPC20.Request
data Request
Request :: Text -> Text -> Value -> Int -> Request
_jsonrpc :: Request -> Text
_method :: Request -> Text
_params :: Request -> Value
_id :: Request -> Int
instance Generic Request
instance Datatype D1Request
instance Constructor C1_0Request
instance Selector S1_0_0Request
instance Selector S1_0_1Request
instance Selector S1_0_2Request
instance Selector S1_0_3Request
instance ToJSON Request

module Network.Colchis.Transport

-- | A pipes <a>Server</a> waiting for a request, ready to be composed with
--   <a>+&gt;&gt;</a> or <a>&gt;+&gt;</a>.
--   
--   <a>Transport</a>s send requests over the wire and receive the
--   responses.
type Transport t m = MonadIO m => forall r. Value -> Server Value Value (t m) r

module Network.Colchis.Transport.TCP
tcp :: Transport TcpState m
runTcp :: HostName -> ServiceName -> TcpState IO r -> IO (Either TransportError r)
data TransportError
RequestParsingError :: ParsingError -> TransportError
UnexpectedData :: TransportError
UnexpectedConnectionClose :: TransportError

-- | A parsing error report, as provided by Attoparsec's <a>Fail</a>.
data ParsingError :: *
ParsingError :: [String] -> String -> ParsingError

-- | Contexts where the parsing error occurred.
peContexts :: ParsingError -> [String]

-- | Parsing error description message.
peMessage :: ParsingError -> String
instance Typeable TransportError
instance Show TransportError
instance Show ConnState

module Network.Colchis.Protocol

-- | A bidirectional <a>Proxy</a> waiting for a request, ready to be
--   composed with <tt>+&gt;&gt;</tt> or <tt>&gt;+&gt;</tt>.
--   
--   <a>Protocol</a>s format incoming requests from downstream before
--   sending them upstream. They also extract the values from returning
--   protocol responses and send them downstream.
--   
--   <a>Protocol</a>s isolate clients from the specific details of each
--   protocol.
type Protocol s m e = forall r. (s, Value) -> Proxy Value Value (s, Value) Value (ExceptT e m) r

module Network.Colchis.Protocol.JSONRPC20
jsonRPC20 :: Monad m => Protocol Text m (Text, Value, JSONRPC20Error)
data JSONRPC20Error
MalformedResponse :: Text -> Value -> JSONRPC20Error
ProtocolMismatch :: Text -> JSONRPC20Error
ResponseIdMismatch :: Int -> Int -> JSONRPC20Error
ErrorResponse :: ErrorObject -> JSONRPC20Error
data ErrorObject
ErrorObject :: Int -> Text -> Maybe Value -> ErrorObject
_code :: ErrorObject -> Int
_message :: ErrorObject -> Text
_data :: ErrorObject -> Maybe Value
instance Show JSONRPC20Error


-- | This module defines the client monad and the type signatures for
--   transports and prototocols.
module Network.Colchis

-- | Emits requests consisting in <a>Value</a>s paired with some metadata.
--   The metadata is usually the method name.
--   
--   Receives <a>Value</a> responses.
type JSONClient s m r = Client (s, Value) Value (ExceptT JSONClientError m) r

-- | (request associated with the error, error message, response that
--   caused the error)
type JSONClientError = (Value, Text, Value)
call :: (ToJSON a, FromJSON r, Monad m) => s -> a -> JSONClient s m r

-- | A bidirectional <a>Proxy</a> waiting for a request, ready to be
--   composed with <tt>+&gt;&gt;</tt> or <tt>&gt;+&gt;</tt>.
--   
--   <a>Protocol</a>s format incoming requests from downstream before
--   sending them upstream. They also extract the values from returning
--   protocol responses and send them downstream.
--   
--   <a>Protocol</a>s isolate clients from the specific details of each
--   protocol.
type Protocol s m e = forall r. (s, Value) -> Proxy Value Value (s, Value) Value (ExceptT e m) r

-- | A pipes <a>Server</a> waiting for a request, ready to be composed with
--   <a>+&gt;&gt;</a> or <a>&gt;+&gt;</a>.
--   
--   <a>Transport</a>s send requests over the wire and receive the
--   responses.
type Transport t m = MonadIO m => forall r. Value -> Server Value Value (t m) r

-- | The return value lives inside the monad associated to the transport
--   layer. The run function that peels off that layer depends on the
--   transport. See for example <a>runTcp</a> for the <a>tcp</a> transport.
runJSONClient :: (MonadTrans t, MFunctor t, MonadIO m, Monad (t m)) => Transport t m -> Protocol s m e -> JSONClient s m r -> t m (Either e (Either JSONClientError r))

-- | Apply a function to all requests flowing upstream in a bidirectional
--   pipe. Returns a function that can be composed with <a>+&gt;&gt;</a> or
--   <a>&gt;+&gt;</a>.
umap :: Monad m => (b' -> a') -> b' -> Proxy a' x b' x m r

-- | Apply a monadic function to all requests flowing upstream in a
--   bidirectional pipe. Returns a function that can be composed with
--   <a>+&gt;&gt;</a> or <a>&gt;+&gt;</a>.
umapM :: Monad m => (b' -> m a') -> b' -> Proxy a' x b' x m r

-- | Lift a monad morphism from <tt>m</tt> to <tt>n</tt> into a monad
--   morphism from <tt>(t m)</tt> to <tt>(t n)</tt>
hoist :: MFunctor t => forall (m :: * -> *) b (n :: * -> *). Monad m => (forall a. m a -> n a) -> t m b -> t n b
