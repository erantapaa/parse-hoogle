-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A representation of planar graphs
--   
--   Planar graphs are graphs that can be embedded onto a surface (i.e.
--   they can be drawn on that surface without any edges crossing). As
--   such, it is preferable to use a dedicated data structure for them that
--   has information about how to achieve this embedding rather than a
--   standard graph data structure.
--   
--   (Please note however that this implementation has only been tested in
--   terms of the embedding being on the unit sphere or disc; whether it
--   works or not as-is on any other type of surface is unknown.)
@package planar-graph
@version 1.0.0.0


-- | Planar graphs are graphs that can be embedded onto a surface (i.e.
--   they can be drawn on that surface without any edges crossing). As
--   such, it is preferable to use a dedicated data structure for them that
--   has information about how to achieve this embedding rather than a
--   standard graph data structure.
--   
--   (Please note however that this implementation has only been tested in
--   terms of the embedding being on the unit sphere or disc; whether it
--   works or not as-is on any other type of surface is unknown.)
--   
--   The implementation here is loosely based upon that found in
--   <i>plantri</i> by Gunnar Brinkmann and Brendan McKay:
--   <a>http://cs.anu.edu.au/~bdm/plantri/</a> (which is similar in concept
--   to a doubly-connected edge list). The main differences are (if my
--   understanding of the C code is correct):
--   
--   <ul>
--   <li>plantri uses arrays (technically it uses one big array that it
--   continually mutates); planar-graph uses Maps (thus making it easier to
--   grow/shrink graphs).</li>
--   <li>plantri doesn't explicitly store nodes, just edges.</li>
--   <li>plantri utilises pointers, avoiding extra lookups.</li>
--   <li>Each edge stores in plantri has the face it is on, but only after
--   they are explicitly calculated. In planar-graph, <tt>getFaces</tt>
--   instead returns a Map for the faces.</li>
--   <li>plantri doesn't allow labels.</li>
--   </ul>
--   
--   In particular, all edges - even undirected ones - are stored as two
--   opposing directed half-edges. As such, care should be taken when
--   dealing with edges. Also, the <a>Node</a>, <a>Edge</a> and <a>Face</a>
--   identifiers are all abstract, and as such cannot be constructed
--   directly.
--   
--   All returned <a>CList</a>s represent values in a clockwise fashion
--   (relative to the <a>Node</a> or <a>Face</a> in question).
--   
--   Care should also be taken when dealing with more than one connected
--   component, as there is no fixed embedding of multiple graphs on the
--   same surface.
module Data.Graph.Planar

-- | The overall planar graph data structure.
data PlanarGraph n e

-- | An abstract representation of a node.
data Node

-- | The number of nodes in the graph (i.e. <tt>length . nodes</tt>).
order :: PlanarGraph n e -> Int

-- | Is this node still in the graph?
hasNode :: PlanarGraph n e -> Node -> Bool

-- | All the nodes in the graph (in some arbitrary order).
nodes :: PlanarGraph n e -> [Node]

-- | All the nodes and their labels in the graph (in some arbitrary order).
labNodes :: PlanarGraph n e -> [(Node, n)]

-- | Returns all outgoing edges for the specified node, travelling
--   clockwise around the node. It assumes the node is indeed in the graph.
outgoingEdges :: PlanarGraph n e -> Node -> CList Edge

-- | Returns all incoming edges for the specified node, travelling
--   clockwise around the node. It assumes the node is indeed in the graph.
incomingEdges :: PlanarGraph n e -> Node -> CList Edge

-- | The <a>Node</a>s that are connected to this <a>Node</a> with an edge
--   (in clockwise order).
neighbours :: PlanarGraph n e -> Node -> CList Node

-- | Returns the label for the specified node.
nodeLabel :: PlanarGraph n e -> Node -> n

-- | An abstract representation of an edge. Note that an explicit
--   identifier is used for each edge rather than just using the two nodes
--   that the edge connects. This is required in case more than one edge
--   connects two nodes as we need to be able to distinguish them.
data Edge

-- | The number of edges in the graph (i.e. <tt>length . edges</tt>).
size :: PlanarGraph n e -> Int

-- | Is this edge still in the graph?
hasEdge :: PlanarGraph n e -> Edge -> Bool

-- | All the half-edges (thus also including inverses) in the graph (in
--   some arbitrary order).
halfEdges :: PlanarGraph n e -> [Edge]

-- | All the half-edges and their labels in the graph (in some arbitrary
--   order).
labHalfEdges :: PlanarGraph n e -> [(Edge, e)]

-- | A variant of <a>halfEdges</a> that returns the pair of nodes that form
--   an edge rather than its unique identifier (again including inverse
--   edges).
halfEdgesBetween :: PlanarGraph n e -> [(Node, Node)]

-- | As with <a>halfEdgesBetween</a>, but including the labels.
labHalfEdgesBetween :: PlanarGraph n e -> [((Node, Node), e)]

-- | All the primary edges in the graph returned in arbitrary order.
edges :: PlanarGraph n e -> [Edge]

-- | All the primary edges and their labels in the graph (in some arbitrary
--   order).
labEdges :: PlanarGraph n e -> [(Edge, e)]

-- | A variant of <a>edges</a> that returns the pair of nodes that form the
--   primary edges.
edgesBetween :: PlanarGraph n e -> [(Node, Node)]

-- | As with <a>edgesBetween</a> but including the labels.
labEdgesBetween :: PlanarGraph n e -> [((Node, Node), e)]

-- | The <a>Node</a> which this <a>Edge</a> is coming from.
fromNode :: PlanarGraph n e -> Edge -> Node

-- | The <a>Node</a> which this <a>Edge</a> is going to.
toNode :: PlanarGraph n e -> Edge -> Node

-- | The previous <a>Edge</a> going clockwise around the <a>fromNode</a>.
prevEdge :: PlanarGraph n e -> Edge -> Edge

-- | The next <a>Edge</a> going clockwise around the <a>fromNode</a>.
nextEdge :: PlanarGraph n e -> Edge -> Edge

-- | The <a>Edge</a> that is an inverse to this one; i.e.:
--   
--   <pre>
--   fromNode pg e == toNode pg $ inverseEdge pg e
--   toNode pg e == fromNode pg $ inverseEdge pg e
--   </pre>
inverseEdge :: PlanarGraph n e -> Edge -> Edge

-- | Return the label for the specified edge.
edgeLabel :: PlanarGraph n e -> Edge -> e

-- | <tt>mergeGraphs pg1 pg2</tt> creates a disjoint union between
--   <tt>pg1</tt> and <tt>pg2</tt> (i.e. puts them into the same graph but
--   disconnected). This is used when they were created independently and
--   thus probably have clashing <tt>Node</tt> and <tt>Edge</tt> values.
--   For best performance, <tt>pg1</tt> should be larger than <tt>pg2</tt>.
--   
--   Along with the merged graph, two functions are returned: they
--   respectively convert Node and Edge values from <tt>pg2</tt> to those
--   found in the merged graph.
--   
--   Please note that these functions are <i>partial</i> and should only be
--   used for the Node and Edge identifiers from <tt>pg2</tt>.
mergeGraphs :: PlanarGraph n e -> PlanarGraph n e -> (PlanarGraph n e, Node -> Node, Edge -> Edge)

-- | Merge all the provided planar graphs together into one large graph,
--   and provide translation functions for every graph in the list (the
--   first pair in this list is just <tt>(<a>id</a>,<a>id</a>)</tt>).
--   
--   See <a>mergeGraphs</a> for more information. For best performance, the
--   graphs should be decreasing in size/order.
mergeAllGraphs :: [PlanarGraph n e] -> (PlanarGraph n e, [(Node -> Node, Edge -> Edge)])

-- | Constructs an empty planar graph.
empty :: PlanarGraph n e

-- | Add a node with the provided label to the graph, returning the updated
--   graph and the node identifier.
addNode :: n -> PlanarGraph n e -> (Node, PlanarGraph n e)

-- | As with <a>addNode</a>, but uses <tt><a>mempty</a></tt> as the label.
addUNode :: Monoid n => PlanarGraph n e -> (Node, PlanarGraph n e)

-- | Specification of where to place a new edge on a node in clockwise
--   order.
data EdgePos

-- | The new edge can be placed anywhere.
Anywhere :: EdgePos

-- | The new edge should be placed before the specified edge.
BeforeEdge :: !Edge -> EdgePos

-- | The new edge should be placed after the specified edge.
AfterEdge :: !Edge -> EdgePos

-- | Add an edge between two nodes <tt>f</tt> and <tt>t</tt>. In reality,
--   since all edges are duplicated (see <a>inverseEdge</a>), two
--   half-edges are inserted, and the identifiers of both are returned.
--   
--   For functions such as <a>edges</a>, the first added half-edge is
--   assumed to be the <i>primary</i> one.
--   
--   If either node does not currently have any edges, then its
--   corresponding <a>EdgePos</a> value is ignored. An <a>EdgePos</a> of
--   <a>Anywhere</a> will place the edge before (i.e. anti-clockwise) of
--   the last edge added to that node.
--   
--   For example, let <tt>g</tt> refer to the following graph (where
--   <tt>n1</tt>, etc. are both the labels and the variable names):
--   
--   <pre>
--    ====                    ====
--   ( n1 )                  ( n2 )
--    ====                    ====
--   
--   
--   
--   
--   
--                            ====
--                           ( n3 )
--                            ====
--   </pre>
--   
--   We can add an edge between <tt>n1</tt> and <tt>n2</tt> (using
--   <a>Anywhere</a> as the <a>EdgePos</a> since there are currently no
--   edges on either node):
--   
--   <pre>
--   ((e1,e2),g') = addEdge n1 Anywhere n2 Anywhere "e1" "e2" g
--   </pre>
--   
--   This will result in the following graph:
--   
--   <pre>
--                 e2
--    ====  &lt;---------------  ====
--   ( n1 )                  ( n2 )
--    ====  ---------------&gt;  ====
--                 e1
--   
--   
--   
--   
--                            ====
--                           ( n3 )
--                            ====
--   </pre>
--   
--   If we want to add edges between <tt>n2</tt> and <tt>n3</tt>, we have
--   three options for the location on <tt>n2</tt>:
--   
--   <ul>
--   <li>Use <tt><a>Anywhere</a></tt>: since there is only one other edge,
--   it makes no difference in terms of the embedding where the second edge
--   goes.</li>
--   <li>Put the new edge <tt><a>BeforeEdge</a> e2</tt> (going clockwise
--   around <tt>n2</tt>).</li>
--   <li>Put the new edge <tt><a>AfterEdge</a> e2</tt> (going clockwise
--   around <tt>n2</tt>).</li>
--   </ul>
--   
--   Since <tt>n2</tt> currently only has one edge, all three
--   <a>EdgePos</a> values will result in the same graph, so we can
--   arbitrarily pick one:
--   
--   <pre>
--   ((e3,e4),g'') = addEdge n2 (BeforeEdge e2) n3 Anywhere "e3" "e4" g'
--   </pre>
--   
--   However, with more edges care must be taken on which <a>EdgePos</a>
--   value is used. The resulting graph is:
--   
--   <pre>
--                 e2
--    ====  &lt;---------------  ====
--   ( n1 )                  ( n2 )
--    ====  ---------------&gt;  ====
--                 e1         |  ^
--                            |  |
--                         e3 |  | e4
--                            |  |
--                            v  |
--                            ====
--                           ( n3 )
--                            ====
--   </pre>
--   
--   The same graph (up to the actual <a>Edge</a> values; so it won't
--   satisfy <tt>==</tt>) would have been obtained with:
--   
--   <pre>
--   ((e4,e3), g'') = addEdge n3 Anywhere n2 (BeforeEdge e2) "e4" "e3" g'
--   </pre>
--   
--   (Note, however, that now <a>edges</a> will return <tt>e4</tt> rather
--   than <tt>e3</tt> as it is considered to be the primary edge.)
addEdge :: Node -> EdgePos -> Node -> EdgePos -> e -> e -> PlanarGraph n e -> ((Edge, Edge), PlanarGraph n e)

-- | As with <a>addEdge</a>, but the edges are meant to be undirected so
--   use the same label for both.
addEdgeUndirected :: Node -> EdgePos -> Node -> EdgePos -> e -> PlanarGraph n e -> (Edge, PlanarGraph n e)

-- | As with <a>addEdge</a>, but both labels are set to
--   <tt><a>mempty</a></tt>.
addUEdge :: Monoid e => Node -> EdgePos -> Node -> EdgePos -> PlanarGraph n e -> ((Edge, Edge), PlanarGraph n e)

-- | Determines if the graph is empty.
isEmpty :: PlanarGraph n e -> Bool

-- | Delete the node and all adjacent edges from the graph.
deleteNode :: Node -> PlanarGraph n e -> PlanarGraph n e

-- | Delete the edge and its inverse from the graph.
deleteEdge :: Edge -> PlanarGraph n e -> PlanarGraph n e

-- | Merges the two nodes adjoined by this edge, and delete all edges
--   between them. The provided function is to decide what the label for
--   the resulting node should be (if the edge goes from <tt>f</tt> to
--   <tt>t</tt>, then the function is <tt>fLabel -&gt; tLabel -&gt;
--   newLabel</tt>). The <a>Node</a> value for the merged node is
--   <tt><a>fromNode</a> pg e</tt>.
--   
--   Note that this may result in multiple edges between the new node and
--   another node if it is adjacent to both nodes being merged.
contractEdge :: Edge -> (n -> n -> n) -> PlanarGraph n e -> PlanarGraph n e

-- | Remove all labels from this graph.
unlabel :: PlanarGraph n e -> PlanarGraph () ()

-- | Apply a mapping function over the node labels.
mapNodes :: (n -> n') -> PlanarGraph n e -> PlanarGraph n' e

-- | Apply a function to the label of the specified node.
adjustNodeLabel :: (n -> n) -> Node -> PlanarGraph n e -> PlanarGraph n e

-- | Set the label of the specified node.
setNodeLabel :: n -> Node -> PlanarGraph n e -> PlanarGraph n e

-- | Apply a mapping function over the edge labels.
mapEdges :: (e -> e') -> PlanarGraph n e -> PlanarGraph n e'

-- | Apply a function to the label of the specified edge.
adjustEdgeLabel :: (e -> e) -> Edge -> PlanarGraph n e -> PlanarGraph n e

-- | Set the label of the specified edge.
setEdgeLabel :: e -> Edge -> PlanarGraph n e -> PlanarGraph n e

-- | Traverse through a graph, and return each connected component found.
--   If an edge is specified, start with that edge and then for subsequent
--   components (if there are any) arbitrarily pick edges to start with; if
--   no edge is provided than start at an arbitrary edge.
traverse :: Traversal -> PlanarGraph n e -> Maybe Edge -> [GraphTraversal]

-- | Use a <a>breadthFirst</a> traversal to find all the connected
--   components. The node and edge identifiers for each component are
--   re-numbered.
connectedComponents :: PlanarGraph n e -> [(PlanarGraph n e, (Node -> Node, Edge -> Edge))]

-- | Perform a re-numbering of the identifiers in this graph using the
--   specified traversal and optionally starting from a specified edge.
--   
--   If there is only one connected component in the graph and the same
--   edge is specified each time (relative to the location in the graph),
--   then the re-numbering is <i>canonical</i>: that is, it can be used to
--   compare whether two graphs constructed via separate paths (and thus
--   using different identifiers) are indeed the same.
renumber :: Traversal -> PlanarGraph n e -> Maybe Edge -> (PlanarGraph n e, (Node -> Node, Edge -> Edge))

-- | Different ways of traversing through a graph.
--   
--   To assist in visualising how the traversals differ, sample traversals
--   will be provided for the following graph:
--   
--   <pre>
--                       =====
--                      (  1  )
--                       =====
--                         |
--                       a |
--                         |
--                       =====
--                      (  2  )
--                       =====
--                       / | \
--               b      /  |  \      c
--        /-------------   |   -------------\
--       /                 |                 \
--    =====              d |                =====
--   (  3  )               |               (  5  )
--    =====              =====              =====
--      |               (  4  )             /   \
--      |                =====             /     \
--      |                  |              /       \
--    e |                f |           g /         \ h
--      |                  |            /           \
--      |                  |           |             |
--      |                 /            |             |
--      |                /             |             |
--    =====             /           =====           =====
--   (  6  )-----------/           (  7  )         (  8  )
--    =====                         =====           =====
--   </pre>
--   
--   Each traversal shall start at the edge labelled <i>a</i>: note that
--   whenever an edge is traversed, it immediately also traverses its
--   inverse.
--   
--   In particular, note where the node labelled <i>4</i> and its two
--   adjacent edges are found.
data Traversal

-- | A breadth-first traversal on the sample graph would visit the nodes
--   and edges in the following order:
--   
--   <ul>
--   <li><i><i>nodes</i>:</i> 1 2 5 4 3 8 7 6</li>
--   <li><i><i>edges</i>:</i> a c d b h g f e</li>
--   </ul>
--   
--   If <a>spanningTraversal</a> was used, then the edge <i>e</i> wouldn't
--   be traversed; if <a>antiClockwiseTraversal</a> was also used, then
--   instead <i>f</i> wouldn't be traversed.
breadthFirst :: Traversal

-- | A depth-first traversal on the sample graph would visit the nodes and
--   edges in the following order:
--   
--   <ul>
--   <li><i><i>nodes</i>:</i> 1 2 5 8 7 4 6 3</li>
--   <li><i><i>edges</i>:</i> a c h g d f e b</li>
--   </ul>
--   
--   If <a>spanningTraversal</a> was used, then the edge <i>b</i> wouldn't
--   be traversed; if <a>antiClockwiseTraversal</a> was also used then
--   instead <i>d</i> wouldn't be traversed.
depthFirst :: Traversal

-- | By default, the traversals do so in a clockwise fashion, just as the
--   outgoing edges are defined for each node. This lets you specify that
--   an anti-clockwise traversal should be done instead.
--   
--   This is not computationally any more expensive than clockwise
--   traversals.
antiClockwiseTraversal :: Traversal -> Traversal

-- | Perform a traversal suitable for a spanning tree. In this case, edges
--   that reach a node that has already been visited won't be traversed.
--   
--   This <i>does</i> make getting each connected component more expensive.
spanningTraversal :: Traversal -> Traversal

-- | Specify part of a graph found by traversing it. For nodes,
--   <tt><a>visited</a> == <a>fromList</a> . <a>toList</a> .
--   <a>traversed</a></tt>; the same is true for edges <i>except</i> when
--   <a>spanningTraversal</a> is used. In that case, <a>traversed</a> may
--   contain a sub-set of <a>visited</a> (and if they aren't equal,
--   <a>anyMissing</a> will be <a>True</a>.).
type GraphTraversal = (TraversedValues Node, TraversedValues Edge)

-- | The values found whilst traversing. See <a>GraphTraversal</a> for more
--   specific information.
data TraversedValues a

-- | All values encountered.
visited :: TraversedValues a -> (Set a)

-- | The order in which values are encountered.
traversed :: TraversedValues a -> (Seq a)

-- | Did we skip any edges?
anyMissing :: TraversedValues a -> Bool

-- | Merge the results from <a>traverse</a> into one traversal (i.e. you
--   don't care about individual components).
mergeGraphTraversals :: [GraphTraversal] -> GraphTraversal

-- | An abstract representation of a face.
data Face

-- | Information about the faces in a planar graph.
type FaceMap = Map Face FaceInfo

-- | Information about a particular <a>Face</a>.
data FaceInfo

-- | The <a>Node</a>s that make up the face.
faceNodes :: FaceInfo -> (CList Node)

-- | The <a>Edge</a>s that make up the face, its inverse and the
--   <a>Face</a> on the other side of that <a>Edge</a>.
edgeCrossings :: FaceInfo -> (CList ((Edge, Edge), Face))

-- | The <a>Edge</a>s that make up the face.
faceEdges :: FaceInfo -> CList Edge

-- | The adjoining <a>Face</a>s. Will have repeats if the <a>Face</a>s are
--   adjacent over more than one <a>Edge</a>.
adjoiningFaces :: FaceInfo -> CList Face

-- | Finds all faces in the planar graph. A face is defined by traversing
--   along the right-hand-side of edges, e.g.:
--   
--   <pre>
--   o-----------------------------&gt;o
--   ^..............................|
--   |..............................|
--   |..............FACE............|
--   |..............................|
--   |..............................v
--   o&lt;-----------------------------o
--   </pre>
--   
--   (with the inverse edges all being on the outside of the edges shown).
getFaces :: PlanarGraph n e -> FaceMap

-- | Returns all nodes and edges in the same face as the provided edge
--   (including that edge); assumes the edge is part of the graph.
getFace :: PlanarGraph n e -> Edge -> ([Node], [Edge])

-- | Create the dual of a planar graph. If actual node and edge labels are
--   required, use <a>toDual</a>.
makeDual :: PlanarGraph n e -> PlanarGraph () ()

-- | Create the planar graph corresponding to the dual of the face
--   relationships. The usage of <a>FaceMap</a> rather than
--   <a>PlanarGraph</a> is to allow you to use the <a>FaceMap</a> for
--   constructing the label-creation functions if you so wish.
--   
--   The function <tt>eLabel</tt> for edge labels takes the <a>Face</a>
--   that the edge comes from, the <a>Edge</a> belonging to that
--   <a>Face</a> that it is crossing and then the <a>Face</a> that it is
--   going to. For example:
--   
--   <pre>
--       ....              ....&gt;
--           ...&gt; =====....
--               (#####)
--                =====
--                 | ^  e2
--                 | |
--                 | |
--   face1         | |      face2
--                 | |
--                 | |
--                 | |
--             e1  v |
--                =====
--               (#####)
--             ...===== &lt;..
--         &lt;...            ....
--                             ...
--   </pre>
--   
--   Here, the edge in the dual graph going from <i>face1</i> to
--   <i>face2</i> will have a label of "<tt>eLabel face1 e1 face2</tt>",
--   and the edge going from <i>face2</i> to <i>face1</i> will have a label
--   of "<tt>eLabel face2 e2 face1</tt>".
--   
--   The returned functions are a mapping from the faces in the
--   <a>FaceMap</a> to the nodes in the dual graph, and the edges in the
--   original graph to the edge in the dual that crosses it (e.g. in the
--   above diagram, <i>e1</i> will have a mapping to the edge from
--   <i>face1</i> to <i>face2</i>).
toDual :: (Face -> n) -> (Face -> Edge -> Face -> e) -> FaceMap -> ((Face -> Node, Edge -> Edge), PlanarGraph n e)

-- | Determine if this graph is the canonical representative of the
--   isomorphic class (defined as such by having a breadth-first
--   serialisation via <a>serialiseBFS</a> that is <tt>&lt;=</tt> any other
--   such serialisation).
--   
--   The function specifies all possible starting edges for the traversal
--   (it is safe to leave the specified edge being returned by this
--   function). If there are no known unique aspects of this graph that
--   could be used to minimise "uniqueness", then use the <a>halfEdges</a>
--   function (note: you probably do <i>not</i> want to use <a>edges</a> if
--   the graph is undirected).
--   
--   Note that this really only makes sense for graphs of type
--   <tt>PlanarGraph () ()</tt>, unless you are sure that the labels won't
--   affect the comparisons.
canonicalExampleBy :: (Ord n, Ord e) => (PlanarGraph n e -> [Edge]) -> Edge -> PlanarGraph n e -> Bool

-- | Filter out all those graphs for which <a>canonicalExampleBy</a> isn't
--   True.
--   
--   For this function to be correct, no two <tt>(Edge, PlanarGraph n
--   e)</tt> pairs should have the same result from <a>serialiseBFS</a>.
--   For example, consider the following graph <i>g</i>:
--   
--   <pre>
--               e1
--    ===== &lt;--------- =====
--   (     )---------&gt;(     )
--    =====          / =====
--    | ^           / /| | ^
--    | |          / /   | |
--    | |         / /    | |
--    | |        / /     | |
--    | |       / /      | |
--    | |      / /       | |
--    | |     / /        | |
--    | |    / /         | |
--    | |   / /          | |
--    v | |/ /           v |
--    ===== /          =====
--   (     )&lt;---------(     )
--    ===== ---------&gt; =====
--               e2
--   </pre>
--   
--   Then <tt>onlyCanonicalExamples <a>halfEdges</a> [(e1,g), (e2,g)]</tt>
--   will return both graphs, even though they represent the same graph.
--   
--   Note that this really only makes sense for graphs of type
--   <tt>PlanarGraph () ()</tt>, unless you are sure that the labels won't
--   affect the comparisons.
onlyCanonicalExamples :: (Ord n, Ord e) => (PlanarGraph n e -> [Edge]) -> [(Edge, PlanarGraph n e)] -> [(Edge, PlanarGraph n e)]

-- | The definition of a more compact, serialised form of a planar graph.
--   The various fields correspond to:
--   
--   <pre>
--   [( node index
--    , node label
--    , [( edge index
--       , node index that this edge points to
--       , edge label
--       , inverse edge index
--      )]
--   )]
--   </pre>
--   
--   The list of edges should be in clockwise order around the node.
--   
--   Note that there will be twice as many edges lists as the <i>size</i>;
--   that's because each edge is listed twice.
type SerialisedGraph n e = [(Word, n, [(Word, Word, e, Word)])]

-- | Create the serialised form of this graph.
serialise :: PlanarGraph n e -> SerialisedGraph n e

-- | Creates the graph from its serialised form. Assumes that the graph is
--   valid.
deserialise :: SerialisedGraph n e -> PlanarGraph n e

-- | An alias for <a>serialiseBFS</a> with no specified edge. Also added
--   are the <a>order</a> and <a>size</a> of the graph.
--   
--   This function is mainly intended for use by the
--   <a>Data.Graph.Planar.Serialisation</a> module.
serialTraversal :: PlanarGraph n e -> ((Int, Int), SerialisedGraph n e)

-- | Perform a breadth-first traversal serialisation of the provided graph.
--   If an edge is provided, then it is the first edge and its
--   <a>fromNode</a> is the first node; if no edge is provided then an
--   arbitrary edge is chosen.
--   
--   Up to the choice of starting edge, the returned <a>SerialisedGraph</a>
--   should be unique no matter how the graph was constructed.
--   
--   Note that only one connected component is used: this is because if
--   there is more than one component then the serialisation is <i>not</i>
--   unique (due to how to choose the ordering of the components).
serialiseBFS :: PlanarGraph n e -> Maybe Edge -> SerialisedGraph n e

-- | Pretty-print the graph. Note that this loses a lot of information,
--   such as edge inverses, etc.
prettify :: (Show n, Show e) => PlanarGraph n e -> String

-- | Pretty-print the graph to stdout.
prettyPrint :: (Show n, Show e) => PlanarGraph n e -> IO ()
instance Eq Node
instance Ord Node
instance NFData Node
instance Eq Edge
instance Ord Edge
instance NFData Edge
instance Eq n => Eq (NodeInfo n)
instance Show n => Show (NodeInfo n)
instance Read n => Read (NodeInfo n)
instance Eq EdgePos
instance Ord EdgePos
instance Show EdgePos
instance Read EdgePos
instance Eq e => Eq (EdgeInfo e)
instance Ord e => Ord (EdgeInfo e)
instance Show e => Show (EdgeInfo e)
instance Read e => Read (EdgeInfo e)
instance (Eq n, Eq e) => Eq (PlanarGraph n e)
instance Eq Face
instance Ord Face
instance NFData Face
instance Eq FaceInfo
instance Show FaceInfo
instance Read FaceInfo
instance Eq TravState
instance Ord TravState
instance Show TravState
instance Read TravState
instance NFData FaceInfo
instance Read Face
instance Show Face
instance NFData e => NFData (EdgeInfo e)
instance Read Edge
instance Show Edge
instance NFData n => NFData (NodeInfo n)
instance Read Node
instance Show Node
instance (NFData n, NFData e) => NFData (PlanarGraph n e)
instance (Read n, Read e) => Read (PlanarGraph n e)
instance (Show n, Show e) => Show (PlanarGraph n e)
instance Functor (PlanarGraph n)


module Data.Graph.Planar.Serialisation

-- | A class covering the different ways of encoding and decoding planar
--   graphs from binary data.
class PlanarEncoding ser where type family NLabel ser type family ELabel ser
putSG :: PlanarEncoding ser => ser -> ((Int, Int), SerialisedGraph (NLabel ser) (ELabel ser)) -> Builder
getSG :: PlanarEncoding ser => ser -> Parser (SerialisedGraph (NLabel ser) (ELabel ser))
putName :: PlanarEncoding ser => ser -> Builder
getName :: PlanarEncoding ser => Parser ser
sepByNewline :: PlanarEncoding ser => ser -> Bool

-- | Encode a list of planar graphs to file using the specified encoding.
encodePlanarFile :: PlanarEncoding ser => ser -> FilePath -> [PlanarGraph (NLabel ser) (ELabel ser)] -> IO Int

-- | Encode a list of planar graphs to file using the specified encoding,
--   with the serialisation traversing from the an optionally specified
--   edge.
encodePlanarFileFrom :: PlanarEncoding ser => ser -> FilePath -> [(Maybe Edge, PlanarGraph (NLabel ser) (ELabel ser))] -> IO Int

-- | Read in a file containing encoded graphs. The <a>PlanarEncoding</a>
--   argument is only used for its <i>type</i> to determine which parser to
--   use.
decodePlanarFile :: PlanarEncoding ser => ser -> FilePath -> IO [PlanarGraph (NLabel ser) (ELabel ser)]


module Data.Graph.Planar.Serialisation.PlanarCode

-- | PLANAR_CODE is the most common encoding for planar graphs, and is
--   supported by various generation and visualisation tools. It is a
--   binary format and not intended to be human-readable.
--   
--   The default encoding only supports graphs with <tt>&lt;256</tt> nodes,
--   and takes <tt>2*|E|+|N|+1</tt> bytes per graph.
--   
--   Please note that PLANAR_CODE is <i>not</i> suitable for graphs with
--   multiple loops on vertices (multiple edges with distinct endpoints
--   however are catered for). As such, no guarantees are made about what
--   happens with multiple loops.
data PlanarCode
PlanarCode :: PlanarCode
instance Eq PlanarCode
instance Ord PlanarCode
instance Show PlanarCode
instance Read PlanarCode
instance PlanarEncoding PlanarCode


module Data.Graph.Planar.Serialisation.AsciiCode

-- | ASCII_CODE is a human-readable variant of
--   <a>Data.Graph.Planar.Serialisation.PlanarCode</a>. The same caveats
--   regarding loops apply, but it is only able to represent graphs with
--   <tt>&lt;=26</tt> nodes.
data AsciiCode
AsciiCode :: AsciiCode
instance Eq AsciiCode
instance Ord AsciiCode
instance Show AsciiCode
instance Read AsciiCode
instance PlanarEncoding AsciiCode
