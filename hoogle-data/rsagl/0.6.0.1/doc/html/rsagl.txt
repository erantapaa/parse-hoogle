-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The RogueStar Animation and Graphics Library
--   
--   RSAGL, the RogueStar Animation and Graphics Library, was specifically
--   designed for a computer game called roguestar, but effort has been
--   made to make it accessable to other projects that might benefit from
--   it. It includes mathematical utilities, a 3D modeling language based
--   on parametric surfaces, and an arrow-based FRP framework.
@package rsagl
@version 0.6.0.1

module RSAGL.Color.ColorSpace

-- | A color space specification or color type that has an associated color
--   space.
--   
--   If a type implements both <a>ImportColorCoordinates</a> and
--   <a>ColorSpace</a>, then it must ensure that:
--   
--   <pre>
--   importColorCoordinates f =
--        (let c = importColorCoordinates (const $ f $ affineColorSpaceOf c) in c)
--   </pre>
--   
--   This is not hard -- all that is required is that
--   <tt>affineColorSpaceOf undefined</tt> is defined.
class ColorSpace cs
affineColorSpaceOf :: ColorSpace cs => cs -> AffineColorSpace

-- | A color type that can import its color coordinates.
class ImportColorCoordinates c
importColorCoordinates :: ImportColorCoordinates c => (AffineColorSpace -> Point3D) -> c

-- | A color type that can export its color coordinates. An easy
--   implementation is
--   
--   <pre>
--   transformColorFromTo your_color_space your_color_coordinates
--   </pre>
--   
--   If a type implements both <a>ExportColorCoordinates</a> and
--   <a>ImportColorCoordinates</a>, then it must ensure that
--   <tt>importColorCoordinates . exportColorCoordinates = id</tt>.
class ExportColorCoordinates c
exportColorCoordinates :: ExportColorCoordinates c => c -> AffineColorSpace -> Point3D

-- | An affine transformation from the default RGB color space to the
--   specified color space.
data AffineColorSpace

-- | A rotatable color space.
data ColorWheel

-- | A specific component of a 3-channel color space.
data ColorChannel

-- | <a>channel_u</a>, <a>channel_v</a>, <a>channel_w</a>, of a 3-channel
--   color space.
data ChannelIndex

-- | A view of a specific color channel, such as red, or luminance.
data LinearMetric
LinearMetric :: Maybe (RSdouble, RSdouble) -> (RSdouble -> Color) -> RSdouble -> Color -> LinearMetric

-- | The range of a color channel that is within gamut. This range depends
--   on the channel and the particular color being observed, and may not
--   exist if the color itself is out of gamut.
linear_gamut_bounds :: LinearMetric -> Maybe (RSdouble, RSdouble)

-- | A function to modify a color channel independantly from the other
--   color channels in the same color space.
linear_color_function :: LinearMetric -> RSdouble -> Color

-- | The value of the particular color channel for the particular color.
linear_value :: LinearMetric -> RSdouble

-- | The original color.
linear_original :: LinearMetric -> Color

-- | Pick a channel from a color space.
newChannel :: ColorSpace cs => ChannelIndex -> cs -> ColorChannel

-- | Construct an isotropic <a>ColorChannel</a> that runs along a hue
--   angle. The meaning of the hue angle depends on the primary colors used
--   in the construction of the color wheel.
newAngularChannel :: ColorWheel -> Angle -> ColorChannel

-- | Construct an isotropic <a>ColorChannel</a> along the radii of a color
--   wheel. This is exactly like calling <a>newAngularChannel</a> knowing
--   in advance the specific hue of the color in question.
newRadialChannel :: ColorWheel -> ColorChannel

-- | Construct a <a>ColorChannel</a> representing the maximum of the three
--   color components. For example, the maximum of <tt>RGB 0.25 0.5
--   0.4</tt> is 0.5.
newMaximalChannel :: AffineColorSpace -> ColorChannel

-- | Read a specific channel of a color.
viewChannel :: ExportColorCoordinates c => ColorChannel -> c -> LinearMetric

-- | The first channel of a color space represented by the ordered tripple,
--   <tt>(u,v,w)</tt>.
channel_u :: ChannelIndex

-- | The second channel of a color space represented by the ordered
--   tripple, <tt>(u,v,w)</tt>.
channel_v :: ChannelIndex

-- | The third channel of a color space represented by the ordered tripple,
--   <tt>(u,v,w)</tt>.
channel_w :: ChannelIndex

-- | Construct a new color space. This requires a minimal point (the black
--   point in an additive color space, or the white point in a subtractive
--   color space), and three primary colors. The three primarys color
--   correspond to the <a>channel_u</a>, <a>channel_v</a>, and
--   <a>channel_w</a> respectively.
newColorSpace :: ExportColorCoordinates c => c -> c -> c -> c -> AffineColorSpace

-- | Construct a new color wheel. This requires a minimal point, (the black
--   point in an additive color space, or the white point in a subtractive
--   color space), and three primary colors with assigned hue angles and
--   value parameters. The hue angle maps onto <a>channel_u</a> and
--   <a>channel_v</a>, while the value parameter maps directly and
--   additively onto <a>channel_w</a>.
newColorWheel :: ExportColorCoordinates c => c -> (c, Angle, RSdouble) -> (c, Angle, RSdouble) -> (c, Angle, RSdouble) -> ColorWheel

-- | The red-green-blue device color space.
color_space_rgb :: AffineColorSpace

-- | A color wheel constructed with red, green and blue device primaries
--   and a luminance component. This is the basis of the HCL color system.
color_wheel_rgbl :: ColorWheel

-- | Transform ordered triples between color spaces.
transformColorFromTo :: AffineColorSpace -> Point3D -> AffineColorSpace -> Point3D

-- | Transform colors between color spaces.
transformColor :: (ExportColorCoordinates source, ImportColorCoordinates dest) => source -> dest
instance Show AffineColorSpace
instance Show ColorWheel
instance ImportColorCoordinates Color
instance ExportColorCoordinates Color
instance ColorSpace ColorWheel
instance ColorSpace AffineColorSpace
instance Show LinearMetric

module RSAGL.Color.RGB

-- | A color in the red-green-blue color space.
data RGB
RGB :: {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> RGB
rgb_red :: RGB -> {-# UNPACK #-} !RSdouble
rgb_green :: RGB -> {-# UNPACK #-} !RSdouble
rgb_blue :: RGB -> {-# UNPACK #-} !RSdouble

-- | Construct a color from an RGB triple in the range [0.0..1.0].
rgb :: ImportColorCoordinates c => RSdouble -> RSdouble -> RSdouble -> c

-- | Construct a color from an RGB triple in the range [0..255].
rgb256 :: (ImportColorCoordinates c, Integral i) => i -> i -> i -> c

-- | Construct a gray color from a value in the range [0.0..1.0].
grayscale :: ImportColorCoordinates c => RSdouble -> c
greyscale :: ImportColorCoordinates c => RSdouble -> c

-- | Construct a gray color from a value in the range [0..255].
grayscale256 :: (Integral i, ImportColorCoordinates c) => i -> c
greyscale256 :: (Integral i, ImportColorCoordinates c) => i -> c
mapRGB :: (RSdouble -> RSdouble) -> RGB -> RGB
zipRGB :: (RSdouble -> RSdouble -> RSdouble) -> RGB -> RGB -> RGB

-- | A combining function on three RGB values.
zipRGB3 :: (RSdouble -> RSdouble -> RSdouble -> RSdouble) -> RGB -> RGB -> RGB -> RGB
instance Eq RGB
instance Ord RGB
instance Read RGB
instance Show RGB
instance AbstractVector RGB
instance AbstractScale RGB
instance AbstractSubtract RGB RGB
instance AbstractAdd RGB RGB
instance AbstractZero RGB
instance ImportColorCoordinates RGB
instance ExportColorCoordinates RGB
instance ColorSpace RGB
instance Xyz RGB
instance NFData RGB

module RSAGL.Color.HCL

-- | A color in the hue-chroma-luminance color space. This is an additive
--   color system (like RGB).
data HCL
HCL :: {-# UNPACK #-} !Angle -> {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> HCL
hcl_hue :: HCL -> {-# UNPACK #-} !Angle
hcl_chroma :: HCL -> {-# UNPACK #-} !RSdouble
hcl_luminance :: HCL -> {-# UNPACK #-} !RSdouble
instance Eq HCL
instance Ord HCL
instance Read HCL
instance Show HCL
instance ImportColorCoordinates HCL
instance ExportColorCoordinates HCL
instance ColorSpace HCL

module RSAGL.Color.Alpha

-- | A color with an alpha channel.
data Alpha c
Alpha :: {-# UNPACK #-} !RSdouble -> !c -> Alpha c
alpha_alpha :: Alpha c -> {-# UNPACK #-} !RSdouble
alpha_color :: Alpha c -> !c

-- | Apply (more) transparency to a color.
alpha :: RSdouble -> Alpha c -> Alpha c

-- | In the range [0..255].
alpha256 :: Integral i => i -> Alpha c -> Alpha c
instance AbstractVector c => AbstractVector (Alpha c)
instance AbstractScale c => AbstractScale (Alpha c)
instance AbstractSubtract c c => AbstractSubtract (Alpha c) (Alpha c)
instance AbstractAdd c c => AbstractAdd (Alpha c) (Alpha c)
instance AbstractZero c => AbstractZero (Alpha c)
instance ImportColorCoordinates c => ImportColorCoordinates (Alpha c)
instance Functor Alpha
instance NFData c => NFData (Alpha c)

module RSAGL.Color.OpenGL
class ColorToOpenGL c
colorToOpenGL :: ColorToOpenGL c => c -> Color4 GLdouble
instance ColorToOpenGL (Alpha RGB)
instance ColorToOpenGL RGB

module RSAGL.Color.Spaces

-- | The RGB color space with neutral gray as the origin.
color_space_neutral :: AffineColorSpace

-- | The subtractive Cyan-Magenta-Yellow color space.
color_space_cmy :: AffineColorSpace

-- | A color wheel using a simple definition of brightness, <tt>(red +
--   green + blue) / 3</tt>. The hue definition is identical to
--   <a>color_wheel_rgbl</a>.
color_wheel_rgb_brightness :: ColorWheel

-- | A color wheel in the subtractive Cyan-Magenta-Yellow color space. The
--   hue definition is identical to <a>color_wheel_rgbl</a>. This color
--   wheel uses a simple definition of black, <tt>(cyan + magenta + yellow)
--   / 3</tt>.
color_wheel_cmyk :: ColorWheel

-- | A color wheel with an isotropic Red-Cyan channel. The hue definition
--   is identical to <a>color_wheel_rgbl</a>.
color_wheel_red_cyan_iso :: ColorWheel

-- | A color wheel with an isotropic Blue-Yellow channel. The hue
--   definition is identical to <a>color_wheel_rgbl</a>.
color_wheel_blue_yellow_iso :: ColorWheel

-- | A color wheel with an isotropic Green-Magenta channel. The hue
--   definition is identical to <a>color_wheel_rgbl</a>.
color_wheel_green_magenta_iso :: ColorWheel

module RSAGL.Color.Channels

-- | The red channel of the RGB color space.
channel_red :: ColorChannel

-- | The green channel of the RGB color space.
channel_green :: ColorChannel

-- | The blue channel of the RGB color space.
channel_blue :: ColorChannel

-- | Luminance of a color as percieved by the human eye.
channel_luminance :: ColorChannel

-- | The Chroma (colorfulness) of a color, isotropic to luminance.
channel_chroma :: ColorChannel

-- | The cyan channel of the CMY color space.
channel_cyan :: ColorChannel

-- | The magenta channel of the CMY color space.
channel_magenta :: ColorChannel

-- | The yellow channel of the CMY color space.
channel_yellow :: ColorChannel

-- | The brightness channel in simple device interpretation. That is, (red
--   + green + blue) / 3.
channel_brightness :: ColorChannel

-- | A red (1.0) vs. cyan (-1.0) channel.
channel_red_cyan :: ColorChannel

-- | A blue (1.0) vs. yellow (-1.0) channel.
channel_blue_yellow :: ColorChannel

-- | A green (1.0) vs. magenta (-1.0) channel.
channel_green_magenta :: ColorChannel

-- | The maximum channel of the additive RGB color space. This is identical
--   to the value channel of the HSB color model. This channel represents
--   the device gamut: it should be between 0 and 1.
channel_value :: ColorChannel

-- | The maximum channel of the subtractive CMY color space. This channel
--   represents the device gamut: it should be between 0 and 1.
channel_boldness :: ColorChannel

-- | The maximum channel of the neutral RGB color space. This channel
--   represents the device gamut: it should be between -1 and 1.
channel_intensity :: ColorChannel

module RSAGL.Color.LinearAdjust
type LinearAdjustment = LinearMetric -> RSdouble

-- | Manipulate an arbitrary component of a color.
adjustColor :: (ExportColorCoordinates c, ImportColorCoordinates c') => ColorChannel -> LinearAdjustment -> c -> c'

-- | Increase a channel to a maximum in-gamut value.
maximize :: LinearAdjustment

-- | Decrease a channel to it's minimum in-gamut value.
minimize :: LinearAdjustment

-- | Clamp a channel to the gamut.
clamp :: LinearAdjustment

module RSAGL.Modeling.Noise

-- | Turbulence function. Accepts an amplitude, which determines how
--   intense turbulence will be. 'perlinTurbulence 0 == id'
perlinTurbulence :: RSdouble -> Point3D -> Point3D

-- | Generates an arbitrary, smoothly varying value between <tt>-1</tt> and
--   <tt>1</tt>.
perlinNoise :: Point3D -> RSdouble

module RSAGL.Modeling.Tesselation
type TesselatedSurface a = [TesselatedElement a]
data TesselatedElement a
TesselatedTriangleFan :: [a] -> TesselatedElement a
tesselated_vertices :: TesselatedElement a -> [a]
TesselatedTriangleStrip :: [a] -> TesselatedElement a
tesselated_vertices :: TesselatedElement a -> [a]
TesselatedTriangles :: [a] -> TesselatedElement a
tesselated_vertices :: TesselatedElement a -> [a]

-- | Generates a list of all vertices in a TesselatedSurface. There will be
--   duplicate entries.
tesselatedSurfaceToVertexCloud :: TesselatedSurface a -> [a]

-- | Tesselate a surface into a u-by-v grid of triangles.
tesselateSurface :: Surface a -> (Integer, Integer) -> TesselatedSurface a

-- | Tesselate polylines of possibly differing number of elements.
tesselateGrid :: [[(RSdouble, a)]] -> TesselatedSurface a
tesselatedElementToOpenGL :: OpenGLPrimitive a => Bool -> TesselatedElement a -> IO ()
unmapTesselatedElement :: TesselatedElement a -> (PrimitiveMode, [a])
instance Read a => Read (TesselatedElement a)
instance Show a => Show (TesselatedElement a)
instance Eq LR
instance Bound3D a => Bound3D (TesselatedElement a)
instance Functor TesselatedElement
instance NFData a => NFData (TesselatedElement a)
instance AffineTransformable a => AffineTransformable (TesselatedElement a)

module RSAGL.Modeling.Optimization
optimizeSurface :: (a -> a -> RSdouble) -> Surface a -> Integer -> TesselatedSurface a
allocateComplexity :: (p -> p -> RSdouble) -> [(Surface p, RSdouble)] -> Integer -> [Integer]
estimateSurfaceArea :: (a -> a -> RSdouble) -> Surface a -> RSdouble
instance Eq SurfaceConfiguration
instance Ord SurfaceConfiguration
instance Show SurfaceConfiguration

module RSAGL.Modeling.BakedModel
data BakedSurface
bakeSurface :: OpenGLPrimitive a => (IO () -> IO ()) -> Bool -> [(PrimitiveMode, [a])] -> IO BakedSurface
freeSurface :: BakedSurface -> IO ()
surfaceToOpenGL :: BakedSurface -> IO ()
tesselatedElementToOpenGL :: OpenGLPrimitive a => Bool -> TesselatedElement a -> IO ()

module RSAGL.Color
type RGBA = Alpha RGB

-- | Construct an RGBA color.
rgba :: RSdouble -> RSdouble -> RSdouble -> RSdouble -> RGBA

-- | Get the minimum of the three RGB components.
minRGB :: RGB -> RSdouble

-- | Arithmetic inverse of a color.
invertRGB :: RGB -> RGB
filterRGB :: RGB -> RGB -> RGB

-- | maps an RGB color between a black point and a white point. The first
--   parameter, the black point, will map to RGB 0 0 0. The second
--   parameter, the white point, will map to RGB 1 1 1.
filterRGBLinear :: RGB -> RGB -> RGB -> RGB

module RSAGL.RayTrace.Scattering
data Scattering
Scattering :: RGB -> (Angle -> RGB) -> Scattering
scattering_absorb :: Scattering -> RGB
scattering_scatter :: Scattering -> Angle -> RGB
absorbtionOverDistance :: RSdouble -> RGB -> RGB
achromaticAbsorbtion :: Scattering -> Scattering
withoutAbsorbtion :: Scattering -> Scattering
withoutScattering :: Scattering -> Scattering
emissionOverDistance :: RSdouble -> RGB -> RGB
traceScattering :: (Point3D -> Scattering) -> (Point3D -> (Vector3D, RGB)) -> SamplingAlgorithm (RGB, RGB) -> Point3D -> Point3D -> Samples (RGB, RGB)
traceAbsorbtion :: (Point3D -> Scattering) -> SamplingAlgorithm RGB -> Point3D -> Point3D -> Samples RGB
linearSamples :: SamplingAlgorithm a
class AdaptiveSample a

-- | <a>adaptiveSamples</a> tries to selectively subdivide samples that
--   seem most "conspicuous" using a user-supplied "conspicuous-ness"
--   function. This should give a better result in less samples for highly
--   detailed media models, but is likely to be slower that
--   <a>linearSamples</a> for the same number of samples.
adaptiveSamples :: AdaptiveSample a => SamplingAlgorithm a
dust :: RSdouble -> RGB -> Scattering
fog :: RSdouble -> RGB -> Scattering
rayleigh_sky :: RGB
rayleigh :: RSdouble -> RGB -> Scattering
elasticBackScatter :: RSdouble -> Angle -> RGB -> Scattering
elasticForwardScatter :: RSdouble -> Angle -> RGB -> Scattering
elasticOmnidirectionalScatter :: RSdouble -> RGB -> Scattering
instance Monoid Scattering
instance AdaptiveSample (RGB, RGB)
instance AdaptiveSample RGB

module RSAGL.Extras.ColorPhysics

-- | Evaluates planck's law respecting blackbody radiation. Accepts
--   temperature in Kelvins (K) and wavelength in nanometers (nm).
plancksLaw :: RSdouble -> RSdouble -> RSdouble

-- | Indicates the intensity of black body radiation in terms of
--   temperature and wavelength, as percieved by the human eye with a white
--   point at which all wavelengths equal 1.0 at 5800K. Accepts temperature
--   in Kelvins (K) and wavelength in nanometers (nm).
blackBody :: RSdouble -> RSdouble -> RSdouble

-- | Indicates the percieved color of a black body radiator, where <tt>rgb
--   1.0 1.0 1.0</tt> is the white point representing 5800K. Accepts
--   temperature in Kelvins (K). It is suggested to use
--   <tt>maximizeRGB</tt> or some other filter as very dark or overbright
--   colors are easily generated from this function. In particular
--   <tt>maximizeRGB . blackBodyRGB</tt> tends to approach roughly <tt>rgb
--   0.0 0.0 1.0</tt> for very low temperatures and roughly <tt>rgb 0.50
--   0.53 1.0</tt> for very high temperatures.
blackBodyRGB :: RSdouble -> RGB

-- | Interprets a spectral function as an <a>RGB</a> color by sampling in
--   the red, green, blue, and indigo wavelengths. This is pretty rough,
--   and actually interprets monochromatic spectral yellow or monochromatic
--   spectral cyan as black, for example. It also does not take into
--   account the relative responsiveness of the human eye to different
--   wavelengths, so passing <tt><a>plancksLaw</a> 5800</tt> directly to
--   this function results in bright green.
spectralRGB :: (RSdouble -> RSdouble) -> RGB


-- | RSAGL.Material handles properties of surfaces such as color,
--   shininess, and transparency including procedural textures but not
--   including anything touching the normal vector, such as bumpiness.
--   Materials are handled using layers.
module RSAGL.Modeling.Material

-- | A <a>MaterialLayer</a> is a layer of material some material quality
--   (diffuse, transparent, emissive, or specular highlight).
--   <tt>MaterialLayers</tt> are rendered one on top of another to create
--   layered effects.
data MaterialLayer

-- | A <a>MaterialSurface</a> is parameterized either on RGB or RGBA,
--   depending on whether or not the <a>MaterialLayer</a> is capable of
--   transparency. <a>MaterialSurface</a>s that are only one color (as
--   opposed to procedural textures) can be described using <a>pure</a>,
--   for example <a>pure red</a>.
type MaterialSurface a = ApplicativeWrapper Surface a

-- | A stack of <a>MaterialLayer</a>s. <a>Material</a> is smart about
--   compressing multiple layers into the least of number of equivalent
--   layers.
data Material
materialIsEmpty :: Material -> Bool

-- | Split open a Material into its component layers.
toLayers :: Material -> [MaterialLayer]

-- | Get the color information for a <a>MaterialLayer</a>.
materialLayerSurface :: MaterialLayer -> MaterialSurface RGBA

-- | Get a relevance layer for a surface. Purely irrelevant materials can
--   be removed without changing the appearance of a model. Irrelevant
--   triangles can also be selectively culled from a model.
materialLayerRelevant :: MaterialLayer -> MaterialSurface Bool

-- | Answers a complexity heuristic for a <a>Material</a>. Result is a
--   small integer greater than or equal to zero.
materialComplexity :: Material -> Integer

-- | Run an IO action wrapped in OpenGL state appropriate for the layer in
--   question.
materialLayerToOpenGLWrapper :: MaterialLayer -> IO () -> IO ()

-- | True if the <a>MaterialLayer</a> is completely opaque. A layer under
--   an opaque layer is not visible.
isOpaqueLayer :: MaterialLayer -> Bool

-- | A simple colored material.
diffuseLayer :: MaterialSurface RGB -> Material

-- | A shiny material with specular highlight, including a specular
--   exponent parameter. Larger exponents give tighter specular highlights,
--   but should be less than 128 (larger than that wouldn't have very much
--   effect anyway). Typical values are 1-10 or so.
specularLayer :: MaterialSurface RGB -> GLfloat -> Material

-- | A transparent colored material.
transparentLayer :: MaterialSurface RGBA -> Material

-- | A material that seems to glow.
emissiveLayer :: MaterialSurface RGB -> Material

-- | A material that doesn't reflect or emit life, but simply performs a
--   multiplicative filter on whatever is behind it.
filteringLayer :: MaterialSurface RGB -> Material
instance Monoid Material
instance NFData MaterialLayer

module RSAGL.Color.RSAGLColors
light_pink :: RGB
mustard :: RGB
indigo :: RGB
lime :: RGB
sea_green :: RGB
periwinkle :: RGB
dark_pink :: RGB
olive_green :: RGB
peach :: RGB
pale_green :: RGB
light_brown :: RGB
hot_pink :: RGB
black :: RGB
lilac :: RGB
navy_blue :: RGB
royal_blue :: RGB
beige :: RGB
salmon :: RGB
olive :: RGB
maroon :: RGB
bright_green :: RGB
dark_purple :: RGB
mauve :: RGB
forest_green :: RGB
aqua :: RGB
cyan :: RGB
tan :: RGB
dark_blue :: RGB
lavender :: RGB
turquoise :: RGB
dark_green :: RGB
violet :: RGB
light_purple :: RGB
lime_green :: RGB
grey :: RGB
sky_blue :: RGB
yellow :: RGB
magenta :: RGB
light_green :: RGB
orange :: RGB
teal :: RGB
light_blue :: RGB
red :: RGB
brown :: RGB
pink :: RGB
blue :: RGB
green :: RGB
purple :: RGB
white :: RGB
blackbody :: RGB

module RSAGL.Scene.CoordinateSystems
type AffineTransformation = Affine -> Affine
affine_identity :: AffineTransformation
data CoordinateSystem
newtype Affine
Affine :: (forall a. AffineTransformable a => a -> a) -> Affine
affine_transformation :: Affine -> forall a. AffineTransformable a => a -> a
affineOf :: AffineTransformation -> Affine
class CoordinateSystemClass csc
getCoordinateSystem :: CoordinateSystemClass csc => csc -> CoordinateSystem
storeCoordinateSystem :: CoordinateSystemClass csc => CoordinateSystem -> csc -> csc
class NestedCoordinateSystemTransformer a
root_coordinate_system :: CoordinateSystem
migrateToFrom :: AffineTransformable a => CoordinateSystem -> CoordinateSystem -> a -> a
transformation :: AffineTransformable a => AffineTransformation -> a -> a
inverseTransformation :: AffineTransformable a => AffineTransformation -> a -> a
data CSN a
importCSN :: AffineTransformable a => CoordinateSystem -> CSN a -> a
exportCSN :: AffineTransformable a => CoordinateSystem -> a -> CSN a
remoteCSN :: (AffineTransformable a, AffineTransformable b) => CoordinateSystem -> (a -> b) -> CSN a -> CSN b
importM :: (Monad m, MonadState s m, CoordinateSystemClass s, AffineTransformable a) => CSN a -> m a
exportM :: (Monad m, MonadState s m, CoordinateSystemClass s, AffineTransformable a) => a -> m (CSN a)
remoteM :: (Monad m, MonadState s m, CoordinateSystemClass s, AffineTransformable a, AffineTransformable b) => CoordinateSystem -> (a -> b) -> a -> m b
importA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, AffineTransformable a) => arr (CSN a) a
importFromA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, AffineTransformable a) => CoordinateSystem -> arr a a
exportA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, AffineTransformable a) => arr a (CSN a)
exportToA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, AffineTransformable a) => CoordinateSystem -> arr a a
exportCoordinateSystem :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s) => arr AffineTransformation CoordinateSystem
remoteA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, AffineTransformable a, AffineTransformable b) => arr (CoordinateSystem, a -> b, a) b
transformM :: (Monad m, MonadState s m, CoordinateSystemClass s, NestedCoordinateSystemTransformer cst) => cst -> m a -> m a
transformA :: (Arrow arr, ArrowState s arr, CoordinateSystemClass s, NestedCoordinateSystemTransformer cst) => arr a b -> arr (cst, a) b
data Distance
measure :: (AffineTransformable p, Xyz p) => p -> p -> Distance
distance :: Distance -> RSdouble
distanceSquared :: Distance -> RSdouble
instance Show CoordinateSystem
instance Show a => Show (CSN a)
instance AffineTransformable Distance
instance NestedCoordinateSystemTransformer CoordinateSystem
instance NestedCoordinateSystemTransformer Affine
instance AffineTransformable Affine
instance CoordinateSystemClass csc => CoordinateSystemClass (a, csc)
instance CoordinateSystemClass CoordinateSystem
instance AffineTransformable CoordinateSystem

module RSAGL.Scene.LightSource

-- | A light source. In addition to position information, each type of
--   light source (except <a>NoLight</a>) has a <a>color</a> term,
--   indicating the color of direct lighting, and an <a>ambient</a> term,
--   indicating the color of indirect lighting.
data LightSource

-- | A directional or infinite light source, which always appears to be
--   comming from the specified vector
DirectionalLight :: Vector3D -> RGB -> RGB -> LightSource
lightsource_direction :: LightSource -> Vector3D
lightsource_color :: LightSource -> RGB
lightsource_ambient :: LightSource -> RGB

-- | A point light, which has a specific position. The intensity of point
--   light radiation falls off with the inverse square of distance,
--   normalized to one at the specified radius. This means that point
--   lights will be overbright inside that radius.
PointLight :: Point3D -> Distance -> RGB -> RGB -> LightSource
lightsource_position :: LightSource -> Point3D
lightsource_radius :: LightSource -> Distance
lightsource_color :: LightSource -> RGB
lightsource_ambient :: LightSource -> RGB

-- | An inactive light source, equivalent to any light source with a color
--   and ambient term of <a>rgb 0 0 0</a>.
NoLight :: LightSource

-- | A DirectionalLight approximation of ambient sky radiation. Normally,
--   set the vector to straight up, since that is the direction of the sky.
skylight :: Vector3D -> RGB -> LightSource

-- | Encodes a transformation of a light source, including the light color
--   and ambient color terms, and any affine transformation. The
--   <a>Monoid</a> instance supports <a>MapLightSource</a> as a specialized
--   endomorphism (see <a>Endo</a>).
data MapLightSource

-- | Transformation of the direct illumination color of a light source.
mapLight :: (RGB -> RGB) -> MapLightSource

-- | Transformation of the ambient color of a light source.
mapAmbient :: (RGB -> RGB) -> MapLightSource

-- | Transformation of both the direct illumination and the ambient color
--   terms of a light source.
mapBoth :: (RGB -> RGB) -> MapLightSource

-- | Apply a <a>MapLightSource</a> to a <a>LightSource</a>.
mapLightSource :: MapLightSource -> LightSource -> LightSource

-- | <a>True</a> if a light is <a>NoLight</a>.
isNoLight :: LightSource -> Bool

-- | Converts a <a>PointLight</a> to a <a>DirectionalLight</a>, assuming
--   that the camera is at the origin.
infiniteLightSourceOf :: LightSource -> LightSource

-- | Set OpenGL light sources starting from 0.
setLightSourcesToOpenGL :: [LightSource] -> IO ()

-- | Set one specific OpenGL light source.
setLightSourceToOpenGL :: (Light, LightSource) -> IO ()
instance AffineTransformable LightSource
instance AffineTransformable MapLightSource
instance Monoid MapLightSource

module RSAGL.Scene.WrappedAffine

-- | WrappedAffine stores up affine transformations that are commited only
--   when the entity is unwrapped. In this way we can store affine
--   transformations for entities that can not be directly transformed, or
--   for which delaying transformation an optimization.
data WrappedAffine a
WrappedAffine :: CoordinateSystem -> a -> WrappedAffine a
wrapAffine :: a -> WrappedAffine a
unwrapAffine :: AffineTransformable a => WrappedAffine a -> a
instance Functor WrappedAffine
instance AffineTransformable (WrappedAffine a)

module RSAGL.RayTrace.RayTrace
class Geometry g
testRay :: Geometry g => Ray3D -> g -> [(RSdouble, SurfaceVertex3D)]
data Plane
plane :: Point3D -> Vector3D -> Plane
plane3 :: Point3D -> Point3D -> Point3D -> Plane
data UnitSphere
UnitSphere :: UnitSphere
type Sphere = WrappedAffine UnitSphere
sphere :: Point3D -> RSdouble -> Sphere
testRay1st :: Geometry g => Ray3D -> g -> Maybe (RSdouble, SurfaceVertex3D)
shadowDeform :: Geometry g => Vector3D -> g -> SurfaceVertex3D -> SurfaceVertex3D
instance Geometry g => Geometry (WrappedAffine g)
instance Geometry UnitSphere
instance AffineTransformable Plane
instance Geometry Plane
instance Geometry g => Geometry [g]

module RSAGL.Modeling.Extrusion

-- | The most general form of an extrusion. Requires first a control curve
--   for orientation, for example the center of a torus or a vector that
--   simply never runs parallel to the spine. Second, the spine of the
--   extrusion, and third the shape to be extruded.
--   
--   The +Y axis of the shape will be oriented toward the control curve.
extrude :: Curve (Either Point3D Vector3D) -> Curve Point3D -> Curve (Curve Point3D) -> Surface Point3D

-- | A tubular extrusion using taking a radius and a spine.
extrudeTube :: Curve RSdouble -> Curve Point3D -> Surface Point3D

-- | An extrusion whose spine is a straight line, with radii specified at
--   both ends. In this case only the extruded shape needs to be specified
--   as a curve.
extrudePrism :: Vector3D -> (Point3D, RSdouble) -> (Point3D, RSdouble) -> Curve Point3D -> Surface Point3D

module RSAGL.Modeling.Deformation

-- | A deformation of a surface. These come in two types: a deformation
--   that modifies only the shape of a surface, leaving the normal vectors
--   to be recalculated automatically, or a deformation that modified both
--   the shape and the normal vectors explicitly.
--   
--   For example, the deformation function of type <tt>(Point3D -&gt;
--   Ponit3D)</tt> depends on automatic differentiation to determine the
--   new surface normals.
--   
--   On the other hand, an affine transformation applied as a deformation
--   can quickly and correctly compute the new surface normals.
--   
--   Finally, one might want to construct a deformation that modifies the
--   surface normals while leaving the shape intact -- this is perfectly
--   legal.
type Deformation = Either (SurfaceVertex3D -> Point3D) (SurfaceVertex3D -> SurfaceVertex3D)

-- | A convenienve class to convert common descriptions of deformations
--   into the canonical representation.
class DeformationClass a
deformation :: DeformationClass a => a -> Deformation
constrain :: (a -> Bool) -> (a -> a) -> a -> a
instance DeformationClass (SurfaceVertex3D -> Affine)
instance DeformationClass (Point3D -> Affine)
instance DeformationClass (SurfaceVertex3D -> SurfaceVertex3D)
instance DeformationClass (SurfaceVertex3D -> Point3D)
instance DeformationClass (Point3D -> SurfaceVertex3D)
instance DeformationClass (Point3D -> Point3D)
instance DeformationClass Matrix
instance (DeformationClass a, DeformationClass b) => DeformationClass (Either a b)

module RSAGL.Modeling.Model
type Model attr = [ModeledSurface attr]
type Modeling attr = ModelingM attr ()
data ModelingM attr a
data MaterialM attr a
data IntermediateModel
generalSurface :: Monoid attr => Either (Surface Point3D) (Surface (Point3D, Vector3D)) -> Modeling attr
extractModel :: Modeling attr -> Model attr
class ModelType m
toIntermediateModel :: ModelType m => m -> IntermediateModel
data BakedModel
bakeModel :: IntermediateModel -> IO BakedModel
freeModel :: BakedModel -> IO ()
buildIntermediateModel :: Integer -> Modeling attr -> IntermediateModel
modelInfo :: IntermediateModel -> String
intermediateModelToOpenGL :: IntermediateModel -> IO ()
intermediateModelToVertexCloud :: IntermediateModel -> [SurfaceVertex3D]
splitOpaques :: IntermediateModel -> (IntermediateModel, [IntermediateModel])
modelingToOpenGL :: Integer -> Modeling attr -> IO ()
sphere :: Monoid attr => Point3D -> RSdouble -> Modeling attr
skySphere :: Monoid attr => Point3D -> RSdouble -> Modeling attr
hemisphere :: Monoid attr => Point3D -> Vector3D -> RSdouble -> Modeling attr
skyHemisphere :: Monoid attr => Point3D -> Vector3D -> RSdouble -> Modeling attr

-- | A <a>perspectiveSphere</a> is rendered anticipating the point from
--   which it is to be viewed. Only the part of the surface of the sphere
--   that would be visible from a vantage point is rendered, and otherwise
--   the sphere seems clipped.
--   
--   This is the appropriate geometry to model the curvature of a planet
--   from 200 kilometers altitude, for example.
perspectiveSphere :: Monoid attr => Point3D -> RSdouble -> Point3D -> Modeling attr
torus :: Monoid attr => RSdouble -> RSdouble -> Modeling attr
openCone :: Monoid attr => (Point3D, RSdouble) -> (Point3D, RSdouble) -> Modeling attr
closedCone :: Monoid attr => (Point3D, RSdouble) -> (Point3D, RSdouble) -> Modeling attr

-- | A flat disc with a hole in the middle, defined in terms of it's
--   center, normal vector, inner (hole) radius and outer radius.
openDisc :: Monoid attr => Point3D -> Vector3D -> RSdouble -> RSdouble -> Modeling attr
closedDisc :: Monoid attr => Point3D -> Vector3D -> RSdouble -> Modeling attr
quadralateral :: Monoid attr => Point3D -> Point3D -> Point3D -> Point3D -> Modeling attr
triangle :: Monoid attr => Point3D -> Point3D -> Point3D -> Modeling attr
box :: Monoid attr => Point3D -> Point3D -> Modeling attr
sor :: Monoid attr => Curve Point3D -> Modeling attr
tube :: Monoid attr => Curve (RSdouble, Point3D) -> Modeling attr
prism :: Monoid attr => Vector3D -> (Point3D, RSdouble) -> (Point3D, RSdouble) -> Curve Point3D -> Modeling attr
adaptive :: Modeling attr
fixed :: (Integer, Integer) -> Modeling attr
tesselationHintComplexity :: Monoid attr => Integer -> Modeling attr
twoSided :: Monoid attr => Bool -> Modeling attr

-- | Swap inside and outside surfaces and reverse normal vectors. This
--   shouldn't effect <a>twoSided</a> surfaces in any visible way.
reverseOrientation :: Monoid attr => Modeling attr -> Modeling attr
regenerateNormals :: Monoid attr => Modeling attr
attribute :: Monoid attr => attr -> Modeling attr
withAttribute :: (attr -> Bool) -> Modeling attr -> Modeling attr
model :: Modeling attr -> Modeling attr
type RGBFunction = ApplicativeWrapper ((->) SurfaceVertex3D) RGB
type RGBAFunction = ApplicativeWrapper ((->) SurfaceVertex3D) RGBA
material :: MonadMaterial m => MaterialM attr () -> m attr ()
pigment :: RGBFunction -> MaterialM attr ()
specular :: GLfloat -> RGBFunction -> MaterialM attr ()
emissive :: RGBFunction -> MaterialM attr ()
transparent :: RGBAFunction -> MaterialM attr ()
filtering :: RGBFunction -> MaterialM attr ()
class MonadAffine m
affine :: MonadAffine m => AffineTransformation -> m ()
turbulence :: (SurfaceVertex3D -> SurfaceVertex3D) -> MaterialM attr ()
deform :: DeformationClass dc => dc -> Modeling attr
instance Monad (ModelingM attr)
instance Monad (MaterialM attr)
instance NFData BakedModel
instance NFData MaterialVertex3D
instance NFData SingleMaterialSurfaceVertex3D
instance NFData IMLayer
instance NFData IMSurface
instance NFData IntermediateModel
instance Bound3D IMSurface
instance Bound3D IntermediateModel
instance ModelType BakedModel
instance ModelType IntermediateModel
instance OpenGLPrimitive SingleMaterialSurfaceVertex3D
instance MonadAffine (MaterialM attr)
instance MonadAffine (ModelingM attr)
instance AffineTransformable (MaterialM attr ())
instance AffineTransformable (ModelingM attr ())
instance MonadMaterial MaterialM
instance MonadMaterial ModelingM
instance MonadState [Quasimaterial] (MaterialM attr)
instance MonadState [ModeledSurface attr] (ModelingM attr)

module RSAGL.Modeling.ModelingExtras
smoothbox :: Monoid attr => RSdouble -> Point3D -> Point3D -> Modeling attr
regularPrism :: Monoid attr => (Point3D, RSdouble) -> (Point3D, RSdouble) -> Integer -> Modeling attr

-- | A rectangular height field rising off of the x-z plane.
heightField :: Monoid attr => (RSdouble, RSdouble) -> (RSdouble, RSdouble) -> ((RSdouble, RSdouble) -> RSdouble) -> Modeling attr

-- | A circular height field rising off of the x-z plane.
heightDisc :: Monoid attr => (RSdouble, RSdouble) -> RSdouble -> ((RSdouble, RSdouble) -> RSdouble) -> Modeling attr
rotationGroup :: AffineTransformable a => Vector3D -> Integer -> a -> [a]
glass :: RGBFunction -> MaterialM attr ()
plastic :: RGBFunction -> MaterialM attr ()
metallic :: RGBFunction -> MaterialM attr ()
pattern :: AbstractVector a => Pattern -> [(RSfloat, ColorFunction a)] -> ColorFunction a
cloudy :: Int -> RSdouble -> Pattern
blinkBoxes :: Int -> RSdouble -> RSdouble -> RSdouble -> Pattern
spherical :: Point3D -> RSdouble -> Pattern
directional :: Vector3D -> Pattern
gradient :: Point3D -> Vector3D -> Pattern
bumps :: Pattern -> Modeling attr
waves :: RSdouble -> RSdouble -> Pattern

-- | Raises or lowers each point in a model along the y-axis according to
--   its (x,z) coordinate. Typically this is used to construct height
--   fields.
heightMap :: ((RSdouble, RSdouble) -> RSdouble) -> Modeling attr

-- | For models where we are certain surface normals don't matter, then
--   don't calculate them.
disregardSurfaceNormals :: Modeling attr
type ColorFunction a = ApplicativeWrapper ((->) SurfaceVertex3D) a
type Pattern = SurfaceVertex3D -> RSdouble
dropRandomElements :: Int -> StdGen -> [a] -> [a]

-- | <a>ApplicativeWrapper</a> captures an applicative entity and remembers
--   whether the entity is pure.
newtype ApplicativeWrapper f a
ApplicativeWrapper :: (Either (f a) a) -> ApplicativeWrapper f a
fromPure :: Applicative f => ApplicativeWrapper f a -> Maybe a
toApplicative :: Applicative f => ApplicativeWrapper f a -> f a
unwrapApplicative :: Applicative f => ApplicativeWrapper f a -> Either (f a) a
wrapApplicative :: Applicative f => f a -> ApplicativeWrapper f a
isPure :: Applicative f => ApplicativeWrapper f a -> Bool

module RSAGL.Scene.Scene
data Scene
data Camera
PerspectiveCamera :: Point3D -> Point3D -> Vector3D -> Angle -> Camera
camera_position :: Camera -> Point3D
camera_lookat :: Camera -> Point3D
camera_up :: Camera -> Vector3D
camera_fov :: Camera -> Angle
infiniteCameraOf :: Camera -> Camera
data SceneLayerInfo
SceneLayerInfo :: (SceneLayer -> Camera) -> LightSourceLayerTransform -> SceneLayerInfo
scene_layer_camera :: SceneLayerInfo -> SceneLayer -> Camera
scene_layer_light_source_layer_transform :: SceneLayerInfo -> LightSourceLayerTransform
data SceneObject m
type SceneLayer = Integer
class (RecombinantState a, CoordinateSystemClass a, Monad m) => ScenicAccumulator a m | a -> m
accumulateScene :: ScenicAccumulator a m => SceneLayer -> SceneObject m -> a -> a
data SceneAccumulator m
null_scene_accumulator :: SceneAccumulator m
sceneObject :: (Monad m, ModelType mt) => m mt -> SceneObject m
cameraRelativeSceneObject :: Monad m => (Camera -> m (WrappedAffine IntermediateModel)) -> SceneObject m
lightSource :: LightSource -> SceneObject m
accumulateSceneM :: (ScenicAccumulator sa a, Monad m, MonadState sa m) => SceneLayer -> SceneObject a -> m ()
accumulateSceneA :: (ScenicAccumulator sa m, Arrow arr, ArrowState sa arr) => arr (SceneLayer, SceneObject m) ()
assembleScene :: Monad m => SceneLayerInfo -> SceneAccumulator m -> m Scene
sceneToOpenGL :: RSdouble -> (RSdouble, RSdouble) -> Scene -> IO ()
stdSceneLayerInfo :: Camera -> SceneLayerInfo
stdSceneLayers :: Camera -> SceneLayer -> Camera
std_scene_layer_hud :: SceneLayer
std_scene_layer_cockpit :: SceneLayer
std_scene_layer_local :: SceneLayer
std_scene_layer_infinite :: SceneLayer
newtype LightSourceLayerTransform
LightSourceLayerTransform :: (SceneLayer -> SceneLayer -> LightSource -> LightSource) -> LightSourceLayerTransform
lightSourceLayerTransform :: LightSourceLayerTransform -> SceneLayer -> SceneLayer -> LightSource -> LightSource

-- | Performs the minimal light source layer transform needed to maintain
--   correct light sources under camera transformations.
cameraLightSourceLayerTransform :: (SceneLayer -> Camera) -> LightSourceLayerTransform
instance Monoid LightSourceLayerTransform
instance Monad m => ScenicAccumulator (SceneAccumulator m) m
instance RecombinantState (SceneAccumulator m)
instance CoordinateSystemClass (SceneAccumulator m)
instance Monad m => AffineTransformable (SceneObject m)
instance AffineTransformable Camera

module RSAGL.Scene


-- | Generate a realistic sky.
module RSAGL.Extras.Sky

-- | An atmosphere, consisting of zero or more layers of different
--   composition.
type Atmosphere = [AtmosphereLayer]

-- | An adaptive color filter, used to set adaptive white and black points.
--   Returns <a>Nothing</a> if the result is a constant black.
type SkyFilter = (Vector3D -> RGB) -> Maybe (RGB -> RGB)

-- | A specific scattering model for an <a>AtmosphereLayer</a>
data AtmosphereComposition

-- | Uses Rayleigh scattering, as though an oxygen-nitrogen atmosphere.
Air :: AtmosphereComposition

-- | Uses Mie scattering (approximate) to give an effect similar to what we
--   would expect from some kind of suspended water vapor.
Vapor :: AtmosphereComposition

-- | Macroscopic colored dust spheres.
Dust :: RGB -> AtmosphereComposition

-- | Unrealistic colored fog, might be appropriate for some kind of poison
--   gas atmosphere.
Fog :: RGB -> AtmosphereComposition

-- | A single layer of atmosphere.
data AtmosphereLayer
AtmosphereLayer :: AtmosphereComposition -> RSdouble -> RSdouble -> AtmosphereLayer

-- | Represents what substance this layer of atmosphere is made of.
atmosphere_composition :: AtmosphereLayer -> AtmosphereComposition

-- | Represents the optical thickness of this layer looking straight up.
--   That is, if you reduce the altitude but hold the thickness constant,
--   the layer will be essentially unchanged in the vertical direction. A
--   typical value is 1.0.
atmosphere_thickness :: AtmosphereLayer -> RSdouble

-- | The altitude to the edge of this atmosphere layer, where 1.0 is the
--   diameter of the planet. Lowering the altitude actually increases the
--   density, and vice-versa, so double or halve the thickness and altitude
--   at the same time. A typical value is 1e-4.
atmosphere_altitude :: AtmosphereLayer -> RSdouble

-- | A <a>SkyFilter</a> that just passes through the raw RGB values,
--   essentially, <a>id</a>.
rawSkyFilter :: SkyFilter

-- | A <a>SkyFilter</a> that takes a maximum black point and a minimum
--   white point, and applies these to black and white points determined by
--   probabalistic means, and then generates a linear filter based on those
--   points. For well chosen parameters this will hopefully produce an
--   appealing sky at any time of day or twilight.
dynamicSkyFilter :: RSdouble -> RSdouble -> SkyFilter

-- | An atmosphere that is fairly typical of the earth.
earth_atmosphere :: Atmosphere

-- | Aggrigated absorbtion from multiple <tt>AtmosphereLayers</tt>.
atmosphereAbsorbtion :: Atmosphere -> Point3D -> Vector3D -> RGB

-- | Aggrigated scattering from multiple <tt>AtmosphereLayers</tt> and
--   multiple suns.
atmosphereScattering :: Atmosphere -> [(Vector3D, RGB)] -> Point3D -> Vector3D -> RGB

-- | Takes a filter color and modifies it on a logarithmic scale. Helps
--   when dealing with very dense color filters. In particular,
--   atmosphereScatteringMaterial uses this.
absorbtionFilter :: RGB -> RGB

-- | Generate a material for a sky sphere. This material includes both
--   scattering and absorbtion information. The material assumes the origin
--   as the eye point, tracing to the geometric point at each vertex.
--   Therefore, this material need not be applied to an exact sphere.
atmosphereScatteringMaterial :: Atmosphere -> [(Vector3D, RGB)] -> SkyFilter -> MaterialM attr ()

module RSAGL.Modeling

module RSAGL.Animation.KinematicSensors

-- | Measures the distance traveled, by the origin of the local coordinate
--   system, as measured in a remote coordinate system, in terms of a
--   vector in the local coordinate system.
--   
--   For example, if we are animating a model of a wheel, we could put an
--   odometer at the bottom-most point of the wheel, and then rotate the
--   wheel according to the result. The wheel would seem to turn as it
--   travels, but would not turn when dragged sidewise.
odometer :: (CoordinateSystemClass s, (StateOf m) ~ s) => CoordinateSystem -> Vector3D -> FRP e m () RSdouble

-- | Measures the (presumed) acceleration due to inertia of a point in the
--   local coordinate system, relative to a (presumably) inertial frame a
--   reference.
inertia :: (CoordinateSystemClass s, (StateOf m) ~ s) => CoordinateSystem -> Point3D -> FRP e m () (Acceleration Vector3D)

module RSAGL.Animation.Joint

-- | The result of computing a joint. It provides AffineTransformations
--   that describe the orientations of the components of the joint. All
--   affine transformations reorient the +Z axis to aim in the direction of
--   the far point. For example, in <tt>joint_arm_lower</tt> the +Z axis
--   aims at the position of the hand.
data Joint
Joint :: Point3D -> Point3D -> Point3D -> AffineTransformation -> AffineTransformation -> AffineTransformation -> Joint

-- | The fixed point of the joint.
joint_shoulder :: Joint -> Point3D

-- | The far end point of the joint.
joint_hand :: Joint -> Point3D

-- | The articulated point of the joint.
joint_elbow :: Joint -> Point3D

-- | The affine transformation to the lower arm, where the origin is the
--   elbow.
joint_arm_lower :: Joint -> AffineTransformation

-- | The affine transformation to the upper arm, where the origin is the
--   shoulder.
joint_arm_upper :: Joint -> AffineTransformation

-- | The affine transformation where the origin is the hand. Oriented to
--   preserve as much as possible the +Y axis.
joint_arm_hand :: Joint -> AffineTransformation

-- | Compute a joint where given a bend vector, describing the direction in
--   which the articulated point (elbow) will try to move when the arm is
--   retracted, and shoulder or base of the joint, the total length of the
--   joint, and ideal position of the hand.
joint :: Vector3D -> Point3D -> RSdouble -> Point3D -> Joint

module RSAGL.Animation.InverseKinematics

-- | Constructs a leg, based on several parameters. See the descriptions of
--   <a>foot</a> and <a>joint</a> for more information on how some of these
--   parameters are interpreted.
--   
--   <ul>
--   <li>style - See LegStyle. * bend - The bend vector of the articulated
--   joint * base - the base or shoulder or fixed point of the joint * len
--   - the total length of the articulation * end - the natural resting
--   point of the foot the foot will rarely actually be here, but will try
--   to return to this point as it walks. * animation - an animation to
--   display the joint</li>
--   </ul>
leg :: (CoordinateSystemClass s, (StateOf m) ~ s) => LegStyle -> Vector3D -> Point3D -> RSdouble -> Point3D -> (FRP e m Joint ()) -> Leg e m
data LegStyle
Upright :: LegStyle
Insectoid :: LegStyle

-- | A description of a leg.
data Leg e m

-- | Animates the upper and lower limbs of a joint into a single animation,
--   using the affine transformations <tt>joitn_arm_upper</tt> and
--   <a>joint_arm_lower</a>.
jointAnimation :: (CoordinateSystemClass s, (StateOf m) ~ s) => FRP e m () () -> FRP e m () () -> FRP e m Joint ()

-- | Combines a group of legs into a group that will try to keep at least
--   half of the legs on the ground at all times.
legs :: [Leg e m] -> FRP e m () ()

-- | An acceleration function that that tries to approach a goal point. It
--   begins slowing down when it comes within the goal radius, and
--   otherwise travels at a fixed speed toward the goal. The goal radius
--   and speed are defined in terms of the magnitude method of the vector
--   type.
--   
--   This function is just a pure differential equation, see
--   <a>approachFrom</a> and <a>approachA</a>.
--   
--   Parameters are: * A goal point. * A goal radius. * An approach speed.
approach :: (AbstractVector v, AbstractSubtract p v, AbstractMagnitude v) => p -> RSdouble -> Rate RSdouble -> (Time -> p -> Rate v)

-- | Approach a moving goal point from the specified starting point. See
--   the description of <a>approach</a>.
approachFrom :: (AbstractVector v, AbstractAdd p v, AbstractSubtract p v, AbstractMagnitude v) => RSdouble -> Rate RSdouble -> p -> FRP e m p p

-- | Approach a moving goal point, starting at the initial position of the
--   goal point. The particle won't move until the goal point moves.
approachA :: (AbstractVector v, AbstractAdd p v, AbstractSubtract p v, AbstractMagnitude v, FRPModel m) => RSdouble -> Rate RSdouble -> FRP e m p p
instance (StateOf m ~ s, CoordinateSystemClass s) => AffineTransformable (Leg e m)


-- | Supports monadic and arrow operations for animated scenes.
module RSAGL.Animation.Animation

-- | A monad for animation using RSAGL's scene accumulation system.
type AniM a = StateT (TimePlusSceneAccumulator IO) IO a

-- | A time-aware scene accumulator.
data TimePlusSceneAccumulator m

-- | Get's the time of the current frame.
frameTime :: AniM Time
runAniM :: AniM (a, SceneLayerInfo) -> IO (a, Scene)

-- | Generates a continuous rotation.
rotationM :: Vector3D -> Rate Angle -> AniM AffineTransformation

-- | Combine an animation with a continuous affine transformation.
animateM :: AniM AffineTransformation -> AniM b -> AniM b

-- | Rotate an animation continuously.
rotateM :: Vector3D -> Rate Angle -> AniM a -> AniM a

-- | An object that can capture either a monadic or arrow-based animation.
data AnimationObject i o
newAnimationObjectM :: (i -> AniM o) -> AnimationObject i o
newAnimationObjectA :: (forall e. FRP e (FRP1 (SceneAccumulator IO) i o) i o) -> IO (AnimationObject i o)
runAnimationObject :: AnimationObject i o -> i -> AniM o
instance CoordinateSystemClass (TimePlusSceneAccumulator m)
instance RecombinantState (TimePlusSceneAccumulator m)
instance Monad m => ScenicAccumulator (TimePlusSceneAccumulator m) m

module RSAGL.Animation.AnimationExtras

-- | Answers a continuous rotation.
rotationA :: Vector3D -> Rate Angle -> FRP e m ignored AffineTransformation

-- | Apply an affine transformation to an animation.
animateA :: (CoordinateSystemClass s, (StateOf m) ~ s) => FRP e m j AffineTransformation -> FRP e m j p -> FRP e m j p

-- | Animation that rotates continuously.
rotateA :: (CoordinateSystemClass s, (StateOf m) ~ s) => Vector3D -> Rate Angle -> FRP e m j p -> FRP e m j p

-- | Always rotates the model so that it's Y+ axis points directly at the
--   camera.
pointAtCameraA :: (Arrow a, ArrowState s a, CoordinateSystemClass s, ScenicAccumulator s m, ModelType model) => a (SceneLayer, m model) ()

-- | An energy-conserving force function describing gravitational
--   attraction. Accepts the intensity and singularity of the vector field.
inverseSquareLaw :: RSdouble -> Point3D -> ForceFunction

-- | An energy-conserving force function that increases in intensity with
--   distance.
quadraticTrap :: RSdouble -> Point3D -> ForceFunction

-- | A force function describing aerodynamic drag.
drag :: RSdouble -> ForceFunction

-- | Add many forces together.
concatForces :: [ForceFunction] -> ForceFunction

-- | A filter function on forces. Where the filter is False, the force is
--   coerced to zero.
constrainForce :: (Time -> Point3D -> Rate Vector3D -> Bool) -> ForceFunction -> ForceFunction

-- | Apply a varying force function to a particle.
singleParticle :: (CoordinateSystemClass s, (StateOf m) ~ s) => Frequency -> PV -> FRP e m ForceFunction PVA

-- | Apply a varying force function to a system of particles.
particleSystem :: (CoordinateSystemClass s, (StateOf m) ~ s) => Frequency -> [PV] -> FRP e m ([PV] -> ForceFunction) [PVA]

-- | A particle with a position and velocity.
type PV = (Point3D, Rate Vector3D)

-- | A particle with a position, velocity and acceleration.
type PVA = (Point3D, Rate Vector3D, Acceleration Vector3D)

-- | A time-varying, velocity-aware vector field that can act on a
--   particle.
type ForceFunction = Time -> Point3D -> Rate Vector3D -> Acceleration Vector3D

module RSAGL.Animation
