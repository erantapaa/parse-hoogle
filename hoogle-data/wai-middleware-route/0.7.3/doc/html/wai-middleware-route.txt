-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Wai dispatch middleware
--   
--   "Just enough" helpers for use <tt>yesod-routes</tt> with <tt>WAI</tt>.
@package wai-middleware-route
@version 0.7.3


-- | This module contains helpers for use <a>Yesod.Routes.Dispatch</a> with
--   <a>Network.Wai</a>.
--   
--   This <tt>Middleware</tt> uses first <a>Piece</a> in path to route
--   <tt>HTTP</tt> method. <a>Static</a> means concrete method.
--   <a>Dynamic</a> means any method.
module Network.Wai.Middleware.Route

-- | Rule for route. Rules without single quotes (<tt>'</tt>) means fixed
--   length paths. And vice versa, rules with single quotes (<tt>'</tt>)
--   means paths with variable lengh
--   
--   Paths converts to <a>Piece</a>s by following rules:
--   
--   <ul>
--   <li>Paths splits by slashes (<tt>/</tt>).</li>
--   <li>Text between slashes becomes <a>Static</a> <a>Piece</a>. The same
--   thing happens with the text at the ends of paths.</li>
--   <li>Hashes (<tt>#</tt>) inside slashes becomes <a>Dynamic</a>
--   <a>Piece</a>s.</li>
--   <li>To make route with variable length just add asterisk (<tt>*</tt>)
--   after last slash.</li>
--   </ul>
--   
--   <pre>
--   "foo"
--   [Static "foo"] Fixed
--   
--   "foo/bar"
--   [Static "foo", Static "bar"] Fixed
--   
--   "foo/#/bar"
--   [Static "foo", Dynamic, Static "bar"] Fixed
--   
--   "foo/#/bar/baz/*"
--   [Dynamic, Static "foo", Dynamic, Static "bar", Static "baz"] Variable
--   </pre>
data Rule

-- | <tt>GET</tt> method
Get :: Text -> Application -> Rule

-- | <tt>POST</tt> method
Post :: Text -> Application -> Rule

-- | <tt>HEAD</tt> method
Head :: Text -> Application -> Rule

-- | <tt>PUT</tt> method
Put :: Text -> Application -> Rule

-- | <tt>DELETE</tt> method
Delete :: Text -> Application -> Rule

-- | <tt>TRACE</tt> method
Trace :: Text -> Application -> Rule

-- | <tt>CONNECT</tt> method
Connect :: Text -> Application -> Rule

-- | <tt>OPTIONS</tt> method
Options :: Text -> Application -> Rule

-- | Any <tt>HTTP</tt> method
Any :: Text -> Application -> Rule

-- | Generic rule with <tt>HTTP</tt> method and path
Gen :: Text -> Text -> Application -> Rule

-- | Make <a>Route</a>s from <tt>Rules</tt>.
--   
--   Equivalent <tt>map mkRoute</tt>
mkRoutes :: [Rule] -> [Route Application]

-- | Make <a>Dispatch</a>s from <tt>Rules</tt>.
--   
--   Equivalent <tt>toDispatch . mkRoutes</tt>
mkRoutes' :: [Rule] -> Dispatch Application

-- | Make <a>Route</a> from <a>Rule</a>. <a>rhPieces</a> of <a>Route</a>
--   will be prepended with <a>Piece</a> with corresponding <tt>HTTP</tt>
--   method. <a>Static</a> means concrete method. <a>Dynamic</a> means any
--   method.
--   
--   <pre>
--   mkRoute $ Get "foo/bar" app
--   Route [Static "foo", Static "bar"] False (const $ Just app) 
--   </pre>
mkRoute :: Rule -> Route Application

-- | Dispatch <tt>Middleware</tt>.
--   
--   <pre>
--   rs :: Dispatch Application
--   rs = toDispatch . mkRoutes [
--        Get  "foo"  fooGetApp
--      , Post "foo"  fooPostApp
--      , Get "foo//bar" fooDynBarApp
--   
--      , Any  "any"  anyMethodApp
--      ]
--   
--   app :: Application
--   app = dispatch True rs (error "Not dispatched")
--   </pre>
dispatch :: Bool -> Dispatch Application -> Application -> Application
dispatch_ :: Dispatch Application -> Application -> Application
