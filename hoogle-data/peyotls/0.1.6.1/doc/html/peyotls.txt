-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty Easy YOshikuni-made TLS library
--   
--   Currently implement the TLS1.2 protocol only, and support the
--   following cipher suites.
--   
--   <ul>
--   <li>TLS_RSA_WITH_AES_128_CBC_SHA</li>
--   <li>TLS_RSA_WITH_AES_128_CBC_SHA256</li>
--   <li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li>
--   <li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li>
--   <li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li>
--   <li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li>
--   <li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li>
--   <li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li>
--   </ul>
--   
--   implement the following curves
--   
--   <ul>
--   <li>SEC p256r1</li>
--   </ul>
--   
--   And support client certificate with the following algorithms.
--   
--   <ul>
--   <li>RSA with SHA256</li>
--   <li>ECDSA with SHA256</li>
--   </ul>
--   
--   And support secure renegotiation (RFC 5746)
--   
--   Currently not implement the following features.
--   
--   <ul>
--   <li>session resumption (RFC 5077)</li>
--   <li>curves other than SEC p256r1</li>
--   </ul>
--   
--   Server sample
--   
--   <ul>
--   <li>file: examples/simpleServer.hs</li>
--   </ul>
--   
--   localhost.key: key file
--   
--   <pre>
--   -----BEGIN RSA PRIVATE KEY-----
--   ...
--   -----END RSA PRIVATE KEY-----
--   </pre>
--   
--   localhost.crt: certificate file
--   
--   <pre>
--   -----BEGIN CERTIFICATE-----
--   ...
--   -----END CERTIFICATE-----
--   </pre>
--   
--   examples/simpleServer.hs
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import Control.Applicative
--   import Control.Monad
--   import "monads-tf" Control.Monad.State
--   import Control.Concurrent
--   import Data.HandleLike
--   import Network
--   import Network.PeyoTLS.Server
--   import Network.PeyoTLS.ReadFile
--   import "crypto-random" Crypto.Random
--   
--   import qualified Data.ByteString as BS
--   import qualified Data.ByteString.Char8 as BSC
--   
--   main :: IO ()
--   main = do
--   k &lt;- readKey "localhost.key"
--   c &lt;- readCertificateChain ["localhost.crt"]
--   g0 &lt;- cprgCreate &lt;$&gt; createEntropyPool :: IO SystemRNG
--   soc &lt;- listenOn $ PortNumber 443
--   void . (`runStateT` g0) . forever $ do
--   	(h, _, _) &lt;- liftIO $ accept soc
--   	g &lt;- StateT $ return . cprgFork
--   	liftIO . forkIO . (`run` g) $ do
--   		p &lt;- open h ["TLS_RSA_WITH_AES_128_CBC_SHA"] [(k, c)]
--   			Nothing
--   		doUntil BS.null (hlGetLine p) &gt;&gt;= liftIO . mapM_ BSC.putStrLn
--   		hlPut p $ BS.concat [
--   			"HTTP/1.1 200 OK\r\n",
--   			"Transfer-Encoding: chunked\r\n",
--   			"Content-Type: text/plain\r\n\r\n",
--   			"5\r\nHello0\r\n\r\n" ]
--   		hlClose p
--   
--   doUntil :: Monad m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m [a]
--   doUntil p rd = rd &gt;&gt;= \x -&gt;
--   (if p x then return . (: []) else (`liftM` doUntil p rd) . (:)) x
--   </pre>
--   
--   Client sample (only show HTTP header)
--   
--   <ul>
--   <li>file: examples/simpleClient.hs</li>
--   </ul>
--   
--   cacert.pem: self-signed root certificate to validate server
--   
--   <pre>
--   -----BEGIN CERTIFICATE-----
--   ...
--   -----END CERTIFICATE-----
--   </pre>
--   
--   examples/simpleClient.hs
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import Control.Applicative
--   import Control.Monad
--   import "monads-tf" Control.Monad.Trans
--   import Data.HandleLike
--   import Network
--   import Network.PeyoTLS.ReadFile
--   import Network.PeyoTLS.Client
--   import "crypto-random" Crypto.Random
--   
--   import qualified Data.ByteString.Char8 as BSC
--   
--   main :: IO ()
--   main = do
--   	ca &lt;- readCertificateStore ["cacert.pem"]
--   	h &lt;- connectTo "localhost" $ PortNumber 443
--   	g &lt;- cprgCreate &lt;$&gt; createEntropyPool :: IO SystemRNG
--   	(`run` g) $ do
--   		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [] ca
--   	nms &lt;- getNames p
--   		hlPut p "GET / HTTP/1.1 \r\n"
--   		hlPut p "Host: localhost\r\n\r\n"
--   		doUntil BSC.null (hlGetLine p) &gt;&gt;= liftIO . mapM_ BSC.putStrLn
--   		hlClose p
--   
--   doUntil :: Monad m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m [a]
--   doUntil p rd = rd &gt;&gt;= \x -&gt;
--   	(if p x then return . (: []) else (`liftM` doUntil p rd) . (:)) x
--   </pre>
--   
--   Client certificate server
--   
--   <ul>
--   <li>file: examples/clcertServer.hs</li>
--   </ul>
--   
--   <pre>
--   % diff examples/simpleServer.hs examples/clcertServer.hs
--   19a20
--   &gt;	ca &lt;- readCertificateStore ["cacert.pem"]
--   27c28
--   &lt;				Nothing
--   ---
--   &gt;				$ Just ca
--   </pre>
--   
--   Client certificate client (RSA certificate)
--   
--   <ul>
--   <li>file: examples/clcertClient.hs</li>
--   </ul>
--   
--   <pre>
--   % diff examples/simpleClient.hs examples/clcertClient.hs
--   15a16,17
--   &gt;	rk &lt;- readKey "client_rsa.key"
--   &gt;	rc &lt;- readCertificateChain ["client_rsa.crt"]
--   20c22
--   &lt;		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [] ca
--   ---
--   &gt;		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [(rk, rc)] ca
--   </pre>
--   
--   Client certificate client (ECDSA or RSA certificate)
--   
--   <ul>
--   <li>file: examples/clcertEcdsaClient.hs</li>
--   </ul>
--   
--   <pre>
--   % diff examples/clcertClient.hs examples/clcertEcdsaClient.hs
--   17a18,19
--   &gt;	ek &lt;- readKey "client_ecdsa.key"
--   &gt;	ec &lt;- readCertificateChain ["client_ecdsa.crt"]
--   22c24
--   &lt;		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [(rk, rc)] ca
--   ---
--   &gt;		p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [(ek, ec), (rk, rc)] ca
--   </pre>
--   
--   ECC server (use ECC or RSA depending on client)
--   
--   <ul>
--   <li>file: examples/eccServer.hs</li>
--   </ul>
--   
--   <pre>
--   % diff examples/simpleServer.hs examples/eccServer.hs
--   15a16,26
--   &gt; cipherSuites :: [CipherSuite]
--   &gt; cipherSuites = [
--   &gt;       "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_RSA_WITH_AES_128_CBC_SHA" ]
--   &gt;
--   18,19c29,32
--   &lt;       k &lt;- readKey "localhost.key"
--   &lt;       c &lt;- readCertificateChain ["localhost.crt"]
--   ---
--   &gt;       rk &lt;- readKey "localhost.key"
--   &gt;       rc &lt;- readCertificateChain ["localhost.crt"]
--   &gt;       ek &lt;- readKey "localhost_ecdsa.key"
--   &gt;       ec &lt;- readCertificateChain ["localhost_ecdsa.crt"]
--   26c39
--   &lt;                       p &lt;- open h ["TLS_RSA_WITH_AES_128_CBC_SHA"] [(k, c)]
--   ---
--   &gt;                       p &lt;- open h cipherSuites [(rk, rc), (ek, ec)]
--   </pre>
--   
--   ECC client (use ECC or RSA depending on server)
--   
--   <ul>
--   <li>file: examples/eccClient.hs</li>
--   </ul>
--   
--   <pre>
--   % diff examples/simpleClient.hs examples/eccClient.hs
--   13a14,24
--   &gt; cipherSuites :: [CipherSuite]
--   &gt; cipherSuites = [
--   &gt;       "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
--   &gt;       "TLS_RSA_WITH_AES_128_CBC_SHA256",
--   &gt;       "TLS_RSA_WITH_AES_128_CBC_SHA" ]
--   &gt;
--   20c31
--   &lt;               p &lt;- open' h "localhost" ["TLS_RSA_WITH_AES_128_CBC_SHA"] [] ca
--   ---
--   &gt;               p &lt;- open' h "localhost" cipherSuites [] ca
--   </pre>
@package peyotls
@version 0.1.6.1

module Network.PeyoTLS.ReadFile
data CertSecretKey
readKey :: FilePath -> IO CertSecretKey
readCertificateChain :: [FilePath] -> IO CertificateChain
readCertificateStore :: [FilePath] -> IO CertificateStore

module Network.PeyoTLS.TChan.Server
open :: (CPRG g, ValidateHandle h, MonadBaseControl IO (HandleMonad h)) => h -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> Maybe CertificateStore -> g -> HandleMonad h (Maybe (String -> Bool, SignedCertificate), (TChan ByteString, TChan ByteString))
data CipherSuite
CipherSuite :: KeyEx -> BulkEnc -> CipherSuite
EMPTY_RENEGOTIATION_INFO :: CipherSuite
CipherSuiteRaw :: Word8 -> Word8 -> CipherSuite
data KeyEx
RSA :: KeyEx
DHE_RSA :: KeyEx
ECDHE_RSA :: KeyEx
ECDHE_ECDSA :: KeyEx
KE_NULL :: KeyEx
data BulkEnc
AES_128_CBC_SHA :: BulkEnc
AES_128_CBC_SHA256 :: BulkEnc
BE_NULL :: BulkEnc
class HandleLike h => ValidateHandle h
validate :: ValidateHandle h => h -> CertificateStore -> CertificateChain -> HandleMonad h [FailedReason]
data CertSecretKey
RsaKey :: PrivateKey -> CertSecretKey
rsaKey :: CertSecretKey -> PrivateKey
EcdsaKey :: PrivateKey -> CertSecretKey
ecdsaKey :: CertSecretKey -> PrivateKey


module Network.PeyoTLS.Server
type PeyotlsM = TlsM Handle SystemRNG
type PeyotlsHandle = TlsHandle Handle SystemRNG
type TlsM h g = ErrorT Alert (StateT (TlsState h g) (HandleMonad h))
data TlsHandle h g
data Alert
Alert :: AlertLevel -> AlertDesc -> String -> Alert
ExternalAlert :: String -> Alert
NotDetected :: String -> Alert
run :: HandleLike h => TlsM h g a -> g -> HandleMonad h a
open :: (ValidateHandle h, CPRG g) => h -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> Maybe CertificateStore -> TlsM h g (TlsHandle h g)
getNames :: HandleLike h => TlsHandle h g -> TlsM h g [String]
checkName :: HandleLike h => TlsHandle h g -> String -> TlsM h g Bool
getCertificate :: HandleLike h => TlsHandle h g -> TlsM h g SignedCertificate
renegotiate :: (ValidateHandle h, CPRG g) => TlsHandle h g -> TlsM h g ()
setCipherSuites :: (ValidateHandle h, CPRG g) => TlsHandle h g -> [CipherSuite] -> TlsM h g ()
setKeyCerts :: (ValidateHandle h, CPRG g) => TlsHandle h g -> [(CertSecretKey, CertificateChain)] -> TlsM h g ()
setCertificateStore :: (ValidateHandle h, CPRG g) => TlsHandle h g -> Maybe CertificateStore -> TlsM h g ()
data CipherSuite
CipherSuite :: KeyEx -> BulkEnc -> CipherSuite
EMPTY_RENEGOTIATION_INFO :: CipherSuite
CipherSuiteRaw :: Word8 -> Word8 -> CipherSuite
data KeyEx
RSA :: KeyEx
DHE_RSA :: KeyEx
ECDHE_RSA :: KeyEx
ECDHE_ECDSA :: KeyEx
KE_NULL :: KeyEx
data BulkEnc
AES_128_CBC_SHA :: BulkEnc
AES_128_CBC_SHA256 :: BulkEnc
BE_NULL :: BulkEnc
class HandleLike h => ValidateHandle h
validate :: ValidateHandle h => h -> CertificateStore -> CertificateChain -> HandleMonad h [FailedReason]
data CertSecretKey
RsaKey :: PrivateKey -> CertSecretKey
rsaKey :: CertSecretKey -> PrivateKey
EcdsaKey :: PrivateKey -> CertSecretKey
ecdsaKey :: CertSecretKey -> PrivateKey

module Network.PeyoTLS.TChan.Client
open :: (CPRG g, ValidateHandle h, MonadBaseControl IO (HandleMonad h)) => h -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> CertificateStore -> g -> HandleMonad h ((String -> Bool, SignedCertificate), (TChan ByteString, TChan ByteString))
open' :: (CPRG g, ValidateHandle h, MonadBaseControl IO (HandleMonad h)) => h -> String -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> CertificateStore -> g -> HandleMonad h (TChan ByteString, TChan ByteString)
data CipherSuite
CipherSuite :: KeyEx -> BulkEnc -> CipherSuite
EMPTY_RENEGOTIATION_INFO :: CipherSuite
CipherSuiteRaw :: Word8 -> Word8 -> CipherSuite
data KeyEx
RSA :: KeyEx
DHE_RSA :: KeyEx
ECDHE_RSA :: KeyEx
ECDHE_ECDSA :: KeyEx
KE_NULL :: KeyEx
data BulkEnc
AES_128_CBC_SHA :: BulkEnc
AES_128_CBC_SHA256 :: BulkEnc
BE_NULL :: BulkEnc
class HandleLike h => ValidateHandle h
validate :: ValidateHandle h => h -> CertificateStore -> CertificateChain -> HandleMonad h [FailedReason]
data CertSecretKey
RsaKey :: PrivateKey -> CertSecretKey
rsaKey :: CertSecretKey -> PrivateKey
EcdsaKey :: PrivateKey -> CertSecretKey
ecdsaKey :: CertSecretKey -> PrivateKey


module Network.PeyoTLS.Client
type PeyotlsM = TlsM Handle SystemRNG
type PeyotlsHandle = TlsHandle Handle SystemRNG
type TlsM h g = ErrorT Alert (StateT (TlsState h g) (HandleMonad h))
data TlsHandle h g
data Alert
Alert :: AlertLevel -> AlertDesc -> String -> Alert
ExternalAlert :: String -> Alert
NotDetected :: String -> Alert
run :: HandleLike h => TlsM h g a -> g -> HandleMonad h a

-- | Don't forget check server name by checkName.
open :: (ValidateHandle h, CPRG g) => h -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> CertificateStore -> TlsM h g (TlsHandle h g)

-- | This function open and check server name. Use this so as not to forget
--   to check server name.
open' :: (ValidateHandle h, CPRG g) => h -> String -> [CipherSuite] -> [(CertSecretKey, CertificateChain)] -> CertificateStore -> TlsM h g (TlsHandle h g)
getNames :: HandleLike h => TlsHandle h g -> TlsM h g [String]
getCertificate :: HandleLike h => TlsHandle h g -> TlsM h g SignedCertificate
checkName :: HandleLike h => TlsHandle h g -> String -> TlsM h g Bool
renegotiate :: (ValidateHandle h, CPRG g) => TlsHandle h g -> TlsM h g ()
setCipherSuites :: (ValidateHandle h, CPRG g) => TlsHandle h g -> [CipherSuite] -> TlsM h g ()
setKeyCerts :: (ValidateHandle h, CPRG g) => TlsHandle h g -> [(CertSecretKey, CertificateChain)] -> TlsM h g ()
setCertificateStore :: (ValidateHandle h, CPRG g) => TlsHandle h g -> CertificateStore -> TlsM h g ()
data CipherSuite
CipherSuite :: KeyEx -> BulkEnc -> CipherSuite
EMPTY_RENEGOTIATION_INFO :: CipherSuite
CipherSuiteRaw :: Word8 -> Word8 -> CipherSuite
data KeyEx
RSA :: KeyEx
DHE_RSA :: KeyEx
ECDHE_RSA :: KeyEx
ECDHE_ECDSA :: KeyEx
KE_NULL :: KeyEx
data BulkEnc
AES_128_CBC_SHA :: BulkEnc
AES_128_CBC_SHA256 :: BulkEnc
BE_NULL :: BulkEnc
class HandleLike h => ValidateHandle h
validate :: ValidateHandle h => h -> CertificateStore -> CertificateChain -> HandleMonad h [FailedReason]
data CertSecretKey
RsaKey :: PrivateKey -> CertSecretKey
rsaKey :: CertSecretKey -> PrivateKey
EcdsaKey :: PrivateKey -> CertSecretKey
ecdsaKey :: CertSecretKey -> PrivateKey
