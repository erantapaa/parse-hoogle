-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of barrier monad, can use custom front/back type
--   
--   Implementation of barrier monad, can use custom front/back type
@package barrier-monad
@version 0.1.0.1

module Control.Monad.Barrier
data Barrier f b t
Unit :: t -> Barrier f b t
Barrier :: f -> (b -> Barrier f b t) -> Barrier f b t
Fail :: String -> Barrier f b t
convert :: (f -> f') -> (b' -> b) -> Barrier f b t -> Barrier f' b' t
rebind :: (f -> Barrier f' b b) -> Barrier f b t -> Barrier f' b t
yield :: f -> Barrier f b b
approach :: Barrier f b t -> Maybe f
continue :: Barrier f b t -> b -> Barrier f b t
collect :: Barrier f () t -> [f]
uncollect :: [x] -> Barrier x a ()
perform :: (f -> s -> (b, s)) -> (String -> s -> o) -> (t -> s -> o) -> s -> Barrier f b t -> o
operate :: Monad m => (f -> m b) -> Barrier f b t -> m t
opencont :: Barrier f b t -> Barrier (f, b -> Barrier f b t) (Barrier f b t) t
closecont :: Barrier (f, b -> Barrier f b t) (Barrier f b t) t -> Barrier f b t
crosstalk :: Barrier f b t1 -> Barrier b f t2 -> [(f, b)]
data BarrierStream b f
BarrierStream :: f -> (b -> BarrierStream b f) -> BarrierStream b f
collectBS :: BarrierStream b f -> [b] -> [f]
streamify :: Barrier f b t -> BarrierStream b f
unstreamify :: BarrierStream b f -> Barrier f b t
initializeBS :: t -> BarrierStream t t
convertBS :: (b' -> b) -> BarrierStream b f -> BarrierStream b' f
newtype BarrierT f b m t
BarrierT :: m (Either t (f, b -> BarrierT f b m t)) -> BarrierT f b m t
runBarrierT :: BarrierT f b m t -> m (Either t (f, b -> BarrierT f b m t))
yieldT :: (Functor m, Monad m) => f -> BarrierT f b m b
approachT :: Functor m => BarrierT f b m t -> m (Maybe f)
continueT :: (Functor m, Monad m) => BarrierT f b m t -> b -> BarrierT f b m t
convertT :: Functor m => (f -> f') -> (b' -> b) -> BarrierT f b m t -> BarrierT f' b' m t
operateT :: (Functor m, Monad m) => (f -> m b) -> BarrierT f b m t -> m t
collectT :: (Functor m, Monad m) => BarrierT f () m t -> m [f]
opencontT :: Functor m => BarrierT f b m t -> BarrierT (f, b -> BarrierT f b m t) (BarrierT f b m t) m t
closecontT :: Functor m => BarrierT (f, b -> BarrierT f b m t) (BarrierT f b m t) m t -> BarrierT f b m t
crosstalkT :: (Functor m, Monad m) => BarrierT f b m t1 -> BarrierT b f m t2 -> m [(f, b)]
operatesT :: (Functor m, Monad m) => (s -> f -> m (s, b)) -> s -> BarrierT f b m t -> m (s, t)
liftBarrier :: Monad m => Barrier f b t -> BarrierT f b m t
unliftBarrier :: Comonad w => BarrierT f b w t -> Barrier f b t
displayBarrier :: (Show f, Show t) => Barrier f b t -> String
instance Comonad w => Comonad (BarrierT z z w)
instance Comonad w => Extend (BarrierT f b w)
instance (Functor m, MonadIO m) => MonadIO (BarrierT f b m)
instance (Functor m, MonadPlus m) => MonadPlus (BarrierT f b m)
instance (Alternative m, Monad m) => Alternative (BarrierT f b m)
instance (Functor m, Monad m) => Applicative (BarrierT f b m)
instance (Functor m, Monad m) => Monad (BarrierT f b m)
instance Functor m => Functor (BarrierT f b m)
instance MonadTrans (BarrierT f b)
instance Comonad (BarrierStream b)
instance Extend (BarrierStream b)
instance Applicative (BarrierStream b)
instance Monad (BarrierStream b)
instance Functor (BarrierStream b)
instance MonadError String (Barrier f b)
instance MonadPlus (Barrier f b)
instance Alternative (Barrier f b)
instance Applicative (Barrier f b)
instance Functor (Barrier f b)
instance Monad (Barrier f b)
