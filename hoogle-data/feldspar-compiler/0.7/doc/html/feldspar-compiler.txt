-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compiler for the Feldspar language
--   
@package feldspar-compiler
@version 0.7


-- | Marshaling between Feldspar and C99 types
module Feldspar.Compiler.Marshal

-- | Buffer descriptor for Feldspar arrays
data SA a
SA :: Ptr a -> Int32 -> Int32 -> Word32 -> SA a
buf :: SA a -> Ptr a
elems :: SA a -> Int32
esize :: SA a -> Int32
bytes :: SA a -> Word32
instance Eq (SA a)
instance Show (SA a)
instance (Marshal a, Marshal b, Marshal c, Marshal d, Marshal e, Marshal f, Marshal g) => Marshal (a, b, c, d, e, f, g)
instance (Marshal a, Marshal b, Marshal c, Marshal d, Marshal e, Marshal f) => Marshal (a, b, c, d, e, f)
instance (Marshal a, Marshal b, Marshal c, Marshal d, Marshal e) => Marshal (a, b, c, d, e)
instance (Marshal a, Marshal b, Marshal c, Marshal d) => Marshal (a, b, c, d)
instance (Marshal a, Marshal b, Marshal c) => Marshal (a, b, c)
instance (Marshal a, Marshal b) => Marshal (a, b)
instance Storable (a, b, c, d, e, f, g) => Reference (a, b, c, d, e, f, g)
instance Storable (a, b, c, d, e, f) => Reference (a, b, c, d, e, f)
instance Storable (a, b, c, d, e) => Reference (a, b, c, d, e)
instance Storable (a, b, c, d) => Reference (a, b, c, d)
instance Storable (a, b, c) => Reference (a, b, c)
instance Storable (a, b) => Reference (a, b)
instance (RealFloat a, Storable a) => Storable (Complex a)
instance Storable a => Reference (SA a)
instance Reference (Ptr a)
instance Storable a => Storable (SA a)
instance Default (SA a)
instance (Storable (Rep a), Marshal a) => Marshal [a]
instance Default (Ptr a)
instance Marshal (Complex a)
instance Marshal WordN
instance Marshal IntN
instance Reference (Complex a)
instance Reference WordN
instance Reference IntN


-- | A module provinding a linker hook that can be referenced to ensure
--   that the runtime support files are linked.
--   
--   NOTE. This file should not be loaded from ghci
module Feldspar.Runtime
feldspar_compiler_hook :: Int


-- | Type rewriting for Feldspar programs
module Feldspar.Compiler.CallConv

-- | Normalize the type (expand type synonyms and type families)
rewriteType :: Type -> Q Type

-- | Construct the corresponding Haskell type of a foreign Feldspar
--   function
--   
--   <pre>
--   prog1 :: Data Index -&gt; Vector1 Index
--   
--   sigD (mkName "h_prog1") $ loadFunType 'prog1 &gt;&gt;= rewriteType &gt;&gt;= buildHaskellType
--   </pre>
--   
--   becomes
--   
--   <pre>
--   h_prog1 :: Index -&gt; IO [Index]
--   </pre>
buildHaskellType :: Type -> Q Type

-- | Construct the corresponding C type of a compiled Feldspar function
--   
--   <pre>
--    sigD (mkName "c_prog1_fun") $ loadFunType 'prog1 &gt;&gt;= rewriteType
--   &gt;= buildCType
--   </pre>
--   
--   becomes
--   
--   <pre>
--   c_prog1_fun :: Word32 -&gt; Ptr (SA Word32) -&gt; IO ()
--   </pre>
buildCType :: Type -> Q Type

module Feldspar.Compiler.Backend.C.Library
replace :: Eq a => [a] -> [a] -> [a] -> [a]

-- | Encode special characters in function names
encodeFunctionName :: String -> String
makeDebugFileName :: String -> String
makeHFileName :: String -> String
makeCFileName :: String -> String

module Feldspar.Compiler.Error
data ErrorClass
InvariantViolation :: ErrorClass
InternalError :: ErrorClass
Warning :: ErrorClass
handleError :: String -> ErrorClass -> String -> a
instance Show ErrorClass
instance Eq ErrorClass

module Feldspar.Transformation.Framework
transformationError :: String -> a
class Default t where def = transformationError "Default value requested."
def :: Default t => t
class Combine t where combine = transformationError "Default combination function used."
combine :: Combine t => t -> t -> t
class (Default (Up t), Combine (Up t)) => Transformation t where type family From t type family To t type family State t type family Down t type family Up t
data Result t s
Result :: s (To t) -> State t -> Up t -> Result t s
result :: Result t s -> s (To t)
state :: Result t s -> State t
up :: Result t s -> Up t
data Result1 t s a
Result1 :: s (a (To t)) -> State t -> Up t -> Result1 t s a
result1 :: Result1 t s a -> s (a (To t))
state1 :: Result1 t s a -> State t
up1 :: Result1 t s a -> Up t
class Transformable t s
transform :: Transformable t s => t -> State t -> Down t -> s (From t) -> Result t s
class Transformable1 t s a
transform1 :: Transformable1 t s a => t -> State t -> Down t -> s (a (From t)) -> Result1 t s a
class DefaultTransformable t s
defaultTransform :: DefaultTransformable t s => t -> State t -> Down t -> s (From t) -> Result t s
class DefaultTransformable1 t s a
defaultTransform1 :: DefaultTransformable1 t s a => t -> State t -> Down t -> s (a (From t)) -> Result1 t s a
instance [overlap ok] (Transformation t, Show (s (b (To t))), Show (State t), Show (Up t)) => Show (Result1 t s b)
instance [overlap ok] (Transformation t, Show (s (To t)), Show (State t), Show (Up t)) => Show (Result t s)
instance [overlap ok] DefaultTransformable1 t s a => Transformable1 t s a
instance [overlap ok] DefaultTransformable t s => Transformable t s
instance [overlap ok] (Combine a, Combine b) => Combine (a, b)
instance [overlap ok] Combine Int
instance [overlap ok] Combine String
instance [overlap ok] Combine ()
instance [overlap ok] (Default a, Default b, Default c) => Default (a, b, c)
instance [overlap ok] (Default a, Default b) => Default (a, b)
instance [overlap ok] Default Int
instance [overlap ok] Default [a]
instance [overlap ok] Default ()

module Feldspar.Compiler.Imperative.Representation
data Module t
Module :: [Entity t] -> Module t
entities :: Module t -> [Entity t]
data Entity t
StructDef :: String -> [StructMember t] -> Entity t
structName :: Entity t -> String
structMembers :: Entity t -> [StructMember t]
TypeDef :: Type -> String -> Entity t
actualType :: Entity t -> Type
typeName :: Entity t -> String
Proc :: String -> [Variable t] -> [Variable t] -> Maybe (Block t) -> Entity t
procName :: Entity t -> String
inParams :: Entity t -> [Variable t]
outParams :: Entity t -> [Variable t]
procBody :: Entity t -> Maybe (Block t)
ValueDef :: Variable t -> Constant t -> Entity t
valVar :: Entity t -> Variable t
valValue :: Entity t -> Constant t
data StructMember t
StructMember :: String -> Type -> StructMember t
structMemberName :: StructMember t -> String
structMemberType :: StructMember t -> Type
data Block t
Block :: [Declaration t] -> Program t -> Block t
locals :: Block t -> [Declaration t]
blockBody :: Block t -> Program t
data Program t
Empty :: Program t
Comment :: Bool -> String -> Program t
isBlockComment :: Program t -> Bool
commentValue :: Program t -> String
Assign :: Expression t -> Expression t -> Program t
lhs :: Program t -> Expression t
rhs :: Program t -> Expression t
ProcedureCall :: String -> [ActualParameter t] -> Program t
procCallName :: Program t -> String
procCallParams :: Program t -> [ActualParameter t]
Sequence :: [Program t] -> Program t
sequenceProgs :: Program t -> [Program t]
Switch :: Expression t -> [(Pattern t, Block t)] -> Program t
scrutinee :: Program t -> Expression t
alts :: Program t -> [(Pattern t, Block t)]
SeqLoop :: Expression t -> Block t -> Block t -> Program t
sLoopCond :: Program t -> Expression t
sLoopCondCalc :: Program t -> Block t
sLoopBlock :: Program t -> Block t
ParLoop :: Bool -> Variable t -> Expression t -> Expression t -> Block t -> Program t
pParallel :: Program t -> Bool
pLoopCounter :: Program t -> Variable t
pLoopBound :: Program t -> Expression t
pLoopStep :: Program t -> Expression t
pLoopBlock :: Program t -> Block t
BlockProgram :: Block t -> Program t
blockProgram :: Program t -> Block t
data Pattern t
PatDefault :: Pattern t
Pat :: (Expression t) -> Pattern t
data ActualParameter t
ValueParameter :: Expression t -> ActualParameter t
valueParam :: ActualParameter t -> Expression t
TypeParameter :: Type -> ActualParameter t
typeParam :: ActualParameter t -> Type
FunParameter :: String -> ActualParameter t
funParamName :: ActualParameter t -> String
data Declaration t
Declaration :: Variable t -> Maybe (Expression t) -> Declaration t
declVar :: Declaration t -> Variable t
initVal :: Declaration t -> Maybe (Expression t)
data Expression t
VarExpr :: Variable t -> Expression t
varExpr :: Expression t -> Variable t
ArrayElem :: Expression t -> Expression t -> Expression t
array :: Expression t -> Expression t
arrayIndex :: Expression t -> Expression t
StructField :: Expression t -> String -> Expression t
struct :: Expression t -> Expression t
fieldName :: Expression t -> String
ConstExpr :: Constant t -> Expression t
constExpr :: Expression t -> Constant t
FunctionCall :: Function -> [Expression t] -> Expression t
function :: Expression t -> Function
funCallParams :: Expression t -> [Expression t]
Cast :: Type -> Expression t -> Expression t
castType :: Expression t -> Type
castExpr :: Expression t -> Expression t
AddrOf :: Expression t -> Expression t
addrExpr :: Expression t -> Expression t
SizeOf :: Type -> Expression t
sizeOf :: Expression t -> Type
data Function
Function :: String -> Type -> FunctionMode -> Function
funName :: Function -> String
returnType :: Function -> Type
funMode :: Function -> FunctionMode
data Constant t
IntConst :: Integer -> Type -> Constant t
intValue :: Constant t -> Integer
intType :: Constant t -> Type
DoubleConst :: Double -> Constant t
doubleValue :: Constant t -> Double
FloatConst :: Float -> Constant t
floatValue :: Constant t -> Float
BoolConst :: Bool -> Constant t
boolValue :: Constant t -> Bool
ComplexConst :: Constant t -> Constant t -> Constant t
realPartComplexValue :: Constant t -> Constant t
imagPartComplexValue :: Constant t -> Constant t
ArrayConst :: [Constant t] -> Constant t
arrayValues :: Constant t -> [Constant t]
data Variable t
Variable :: Type -> String -> Variable t
varType :: Variable t -> Type
varName :: Variable t -> String
data Size
S8 :: Size
S16 :: Size
S32 :: Size
S40 :: Size
S64 :: Size
data Signedness
Signed :: Signedness
Unsigned :: Signedness
data Type
VoidType :: Type
BoolType :: Type
BitType :: Type
FloatType :: Type
DoubleType :: Type
NumType :: Signedness -> Size -> Type
ComplexType :: Type -> Type
UserType :: String -> Type
Alias :: Type -> String -> Type
ArrayType :: (Range Length) -> Type -> Type
NativeArray :: (Maybe Length) -> Type -> Type
StructType :: String -> [(String, Type)] -> Type
Pointer :: Type -> Type
IVarType :: Type -> Type
data FunctionMode
Prefix :: FunctionMode
Infix :: FunctionMode
class HasType a where type family TypeOf a
typeof :: HasType a => a -> TypeOf a
reprError :: ErrorClass -> String -> a

-- | Free variables of an expression.
fv :: Expression t -> [Variable t]
fv' :: Expression t -> [Variable t]
instance [overlap ok] Typeable Variable
instance [overlap ok] Typeable Constant
instance [overlap ok] Typeable StructMember
instance [overlap ok] Typeable Function
instance [overlap ok] Typeable Expression
instance [overlap ok] Typeable Declaration
instance [overlap ok] Typeable ActualParameter
instance [overlap ok] Typeable Pattern
instance [overlap ok] Typeable Program
instance [overlap ok] Typeable Block
instance [overlap ok] Typeable Entity
instance [overlap ok] Typeable Module
instance [overlap ok] Eq Size
instance [overlap ok] Show Size
instance [overlap ok] Eq Signedness
instance [overlap ok] Show Signedness
instance [overlap ok] Eq Type
instance [overlap ok] Show Type
instance [overlap ok] Show (Variable t)
instance [overlap ok] Eq (Variable t)
instance [overlap ok] Show (Constant t)
instance [overlap ok] Eq (Constant t)
instance [overlap ok] Show (StructMember t)
instance [overlap ok] Eq (StructMember t)
instance [overlap ok] Eq FunctionMode
instance [overlap ok] Show FunctionMode
instance [overlap ok] Show Function
instance [overlap ok] Eq Function
instance [overlap ok] Show (Expression t)
instance [overlap ok] Eq (Expression t)
instance [overlap ok] Show (Declaration t)
instance [overlap ok] Eq (Declaration t)
instance [overlap ok] Show (ActualParameter t)
instance [overlap ok] Eq (ActualParameter t)
instance [overlap ok] Show (Pattern t)
instance [overlap ok] Eq (Pattern t)
instance [overlap ok] Show (Program t)
instance [overlap ok] Eq (Program t)
instance [overlap ok] Show (Block t)
instance [overlap ok] Eq (Block t)
instance [overlap ok] Show (Entity t)
instance [overlap ok] Eq (Entity t)
instance [overlap ok] Show (Module t)
instance [overlap ok] Eq (Module t)
instance [overlap ok] HasType (ActualParameter t)
instance [overlap ok] HasType (Expression t)
instance [overlap ok] HasType (Constant t)
instance [overlap ok] HasType (Variable t)
instance [overlap ok] Monoid (Block t)
instance [overlap ok] Monoid (Program t)

module Feldspar.Compiler.Imperative.Frontend
toBlock :: Program () -> Block ()
toProg :: Block () -> Program ()

-- | Copies expressions into a destination. If the destination is a
--   non-scalar the arguments are appended to the destination.
copyProg :: Maybe (Expression ()) -> [Expression ()] -> Program ()
mkInitialize :: String -> Maybe (Expression ()) -> Expression () -> Program ()
initArray :: Maybe (Expression ()) -> Expression () -> Program ()
setLength :: Maybe (Expression ()) -> Expression () -> Program ()
freeArray :: Variable () -> Program ()
freeArrays :: [Declaration ()] -> [Program ()]
arrayLength :: Expression () -> Expression ()
chaseArray :: Expression t -> Maybe (Range Length)
iVarInit :: Expression () -> Program ()
iVarGet :: Expression () -> Expression () -> Program ()
iVarPut :: Expression () -> Expression () -> Program ()
iVarDestroy :: Variable () -> Program ()
freeIVars :: [Declaration ()] -> [Program ()]
spawn :: String -> [Variable ()] -> Program ()
run :: String -> [Variable ()] -> Program ()
intWidth :: Type -> Maybe Integer
intSigned :: Type -> Maybe Bool
litF :: Float -> Expression t
litD :: Double -> Expression t
litB :: Bool -> Expression ()
litC :: Constant () -> Constant () -> Expression ()
litI :: Type -> Integer -> Expression ()
litI32 :: Integer -> Expression ()
isArray :: Type -> Bool
isNativeArray :: Type -> Bool
isIVar :: Type -> Bool
isPointer :: Type -> Bool
isVarExpr :: Expression () -> Bool
containsNativeArray :: Type -> Bool

-- | Returns a list of access functions and types for the leaves of the
--   struct tree of the type
flattenStructs :: Type -> [(Expression () -> Expression (), Type)]
hasReference :: Type -> Bool
dVar :: Declaration () -> Variable ()
vName :: Variable t -> String
lName :: Expression t -> String
varToExpr :: Variable t -> Expression t
binop :: Type -> String -> Expression () -> Expression () -> Expression ()
fun :: Type -> String -> [Expression ()] -> Expression ()
fun' :: FunctionMode -> Type -> String -> [Expression ()] -> Expression ()
call :: String -> [ActualParameter ()] -> Program ()
for :: Bool -> String -> Expression () -> Expression () -> Block () -> Program ()
while :: Block () -> Expression () -> Block () -> Program ()

module Feldspar.Compiler.Backend.C.Options
data Options
Options :: Platform -> UnrollStrategy -> DebugOption -> Bool -> Bool -> [Rule] -> FeldOpts -> Int -> Options
platform :: Options -> Platform
unroll :: Options -> UnrollStrategy
debug :: Options -> DebugOption
memoryInfoVisible :: Options -> Bool
printHeader :: Options -> Bool
rules :: Options -> [Rule]
frontendOpts :: Options -> FeldOpts

-- | Indentation size for PrettyPrinting
nestSize :: Options -> Int
data UnrollStrategy
NoUnroll :: UnrollStrategy
Unroll :: Int -> UnrollStrategy
data DebugOption
NoDebug :: DebugOption
NoPrimitiveInstructionHandling :: DebugOption
data Platform
Platform :: String -> [(Type, String)] -> [(Type, ShowValue)] -> [String] -> [Rule] -> Bool -> IsRestrict -> Platform
name :: Platform -> String
types :: Platform -> [(Type, String)]
values :: Platform -> [(Type, ShowValue)]
includes :: Platform -> [String]
platformRules :: Platform -> [Rule]
varFloating :: Platform -> Bool
isRestrict :: Platform -> IsRestrict
type ShowValue = Constant () -> String
data IsRestrict
Restrict :: IsRestrict
NoRestrict :: IsRestrict
data Action t
Replace :: t -> Action t
Propagate :: Rule -> Action t
WithId :: (Int -> [Action t]) -> Action t
WithOptions :: (Options -> [Action t]) -> Action t
data Rule
Rule :: (t -> [Action t]) -> Rule
rule :: Typeable t => (t -> [Action t]) -> Rule
replaceWith :: t -> Action t
propagate :: Typeable t => (t -> [Action t]) -> Action t'
instance Typeable Action
instance Eq UnrollStrategy
instance Show UnrollStrategy
instance Eq DebugOption
instance Show DebugOption
instance Show IsRestrict
instance Eq IsRestrict
instance Show Platform
instance Eq Rule
instance Show Rule
instance Eq ShowValue

module Feldspar.Compiler.Imperative.FromCore.Interpretation

-- | Code generation monad
type CodeWriter = RWS Readers Writers States
data Readers
Readers :: [(VarId, Expression ())] -> SourceInfo -> Options -> Readers

-- | variable aliasing
alias :: Readers -> [(VarId, Expression ())]

-- | Surrounding source info
sourceInfo :: Readers -> SourceInfo

-- | Options for the backend.
backendOpts :: Readers -> Options
initReader :: Options -> Readers
data Writers
Writers :: Block () -> [Entity ()] -> [Declaration ()] -> [Variable ()] -> [Program ()] -> Writers

-- | collects code within one block
block :: Writers -> Block ()

-- | collects top level definitions
def :: Writers -> [Entity ()]

-- | collects top level variable declarations
decl :: Writers -> [Declaration ()]

-- | collects top level parameters
params :: Writers -> [Variable ()]

-- | collects postlude code (freeing memory, etc)
epilogue :: Writers -> [Program ()]
data States
States :: VarId -> States

-- | The first fresh variable id
fresh :: States -> VarId
initState :: States

-- | Where to place the program result
type Location = Maybe (Expression ())

-- | A minimal complete instance has to define either <a>compileProgSym</a>
--   or <a>compileExprSym</a>.
class Compile sub dom where compileProgSym = compileExprLoc compileExprSym = compileProgFresh
compileProgSym :: Compile sub dom => sub a -> Info (DenResult a) -> Location -> Args (AST (Decor Info dom)) a -> CodeWriter ()
compileExprSym :: Compile sub dom => sub a -> Info (DenResult a) -> Args (AST (Decor Info dom)) a -> CodeWriter (Expression ())

-- | Implementation of <a>compileExprSym</a> that assigns an expression to
--   the given location.
compileExprLoc :: Compile sub dom => sub a -> Info (DenResult a) -> Location -> Args (AST (Decor Info dom)) a -> CodeWriter ()

-- | Implementation of <a>compileProgSym</a> that generates code into a
--   fresh variable.
compileProgFresh :: Compile sub dom => sub a -> Info (DenResult a) -> Args (AST (Decor Info dom)) a -> CodeWriter (Expression ())
compileDecor :: Info a -> CodeWriter b -> CodeWriter b
compileProgDecor :: Compile dom dom => Location -> Decor Info dom a -> Args (AST (Decor Info dom)) a -> CodeWriter ()
compileExprDecor :: Compile dom dom => Decor Info dom a -> Args (AST (Decor Info dom)) a -> CodeWriter (Expression ())
compileProg :: Compile dom dom => Location -> ASTF (Decor Info dom) a -> CodeWriter ()
compileExpr :: Compile dom dom => ASTF (Decor Info dom) a -> CodeWriter (Expression ())
compileExprVar :: Compile dom dom => ASTF (Decor Info dom) a -> CodeWriter (Expression ())
compileNumType :: Signedness a -> BitWidth n -> Type
mkStructType :: [(String, Type)] -> Type
compileTypeRep :: TypeRep a -> Size a -> Type

-- | Construct a variable.
mkVar :: Type -> VarId -> Expression ()

-- | Construct a named variable.
mkNamedVar :: String -> Type -> VarId -> Variable ()

-- | Construct a named pointer.
mkNamedRef :: String -> Type -> VarId -> Variable ()

-- | Construct a pointer.
mkRef :: Type -> VarId -> Expression ()
mkVariable :: Type -> VarId -> Variable ()
mkPointer :: Type -> VarId -> Variable ()
freshId :: CodeWriter VarId
freshVar :: String -> TypeRep a -> Size a -> CodeWriter (Expression ())
freshAlias :: Expression () -> CodeWriter (Expression ())
declare :: Expression () -> CodeWriter ()
declareAlias :: Expression () -> CodeWriter ()
initialize :: Expression () -> Expression () -> CodeWriter ()
tellDef :: [Entity ()] -> CodeWriter ()
tellProg :: [Program ()] -> CodeWriter ()
tellDeclWith :: Bool -> [Declaration ()] -> CodeWriter ()
encodeType :: Type -> String
getTypes :: Options -> [Declaration ()] -> [Entity ()]
assign :: Location -> Expression () -> CodeWriter ()
shallowAssign :: Location -> Expression () -> CodeWriter ()
freshAliasInit :: Expression () -> CodeWriter (Expression ())
shallowCopyWithRefSwap :: Expression () -> Expression () -> CodeWriter ()
shallowCopyReferences :: Expression () -> Expression () -> CodeWriter ()
mkDoubleBufferState :: Expression () -> VarId -> CodeWriter (Expression (), Expression ())

-- | Like <a>listen</a>, but also prevents the program from being written
--   in the monad.
confiscateBlock :: CodeWriter a -> CodeWriter (a, Block ())

-- | Like <a>listen</a>, but also catches writer things and prevents the
--   program from being written in the monad.
confiscateBigBlock :: CodeWriter a -> CodeWriter ((a, Writers), Block ())
withAlias :: VarId -> Expression () -> CodeWriter a -> CodeWriter a
isVariableOrLiteral :: (Project (Variable :|| Type) dom, Project (Literal :|| Type) dom) => AST (Decor info dom) a -> Bool
mkLength :: (Project (Literal :|| Type) dom, Project (Variable :|| Type) dom, Compile dom dom) => ASTF (Decor Info dom) a -> TypeRep a -> Size a -> CodeWriter (Expression ())
mkBranch :: Compile dom dom => Location -> ASTF (Decor Info dom) Bool -> ASTF (Decor Info dom) a -> Maybe (ASTF (Decor Info dom) a) -> CodeWriter ()
isComposite :: Type -> Bool
instance (Compile sub1 dom, Compile sub2 dom) => Compile (sub1 :+: sub2) dom
instance Monoid Writers

module Feldspar.Compiler.Imperative.FromCore.Binding
compileLet :: Compile dom dom => ASTF (Decor Info dom) a -> Info (a -> b) -> VarId -> CodeWriter (Expression ())
compileBind :: Compile dom dom => (VarId, ASTB (Decor Info dom) Type) -> CodeWriter ()
instance (Compile dom dom, Project (CLambda Type) dom) => Compile Let dom
instance Compile (CLambda Type) dom
instance Compile (Variable :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Array
instance (Compile dom dom, Project (CLambda Type) dom, Project (Literal :|| Type) dom, Project (Variable :|| Type) dom, Project Let dom, Project (Array :|| Type) dom, Project (Tuple :|| Type) dom, ConstrainedBy dom Typeable, AlphaEq dom dom (Decor Info dom) [(VarId, VarId)]) => Compile (Array :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Condition
instance Compile dom dom => Compile (Condition :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.ConditionM
instance Compile dom dom => Compile (ConditionM m) dom

module Feldspar.Compiler.Imperative.FromCore.Error
compileAssert :: Compile dom dom => ASTF (Decor Info dom) a -> String -> CodeWriter ()
instance Compile dom dom => Compile (Error :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.FFI
instance Compile dom dom => Compile (FFI :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Future
instance Compile dom dom => Compile (FUTURE :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Literal
literal :: TypeRep a -> Size a -> a -> CodeWriter (Expression ())
instance Compile (Literal :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Loop
instance (Compile dom dom, Project (CLambda Type) dom, Project (Literal :|| Type) dom, Project (Variable :|| Type) dom) => Compile (LoopM Mut) dom
instance (Compile dom dom, Project (CLambda Type) dom, Project (Literal :|| Type) dom, Project (Variable :|| Type) dom, Project Let dom, ConstrainedBy dom Typeable) => Compile (Loop :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Mutable
instance (Compile dom dom, Project (CLambda Type) dom) => Compile MutableArray dom
instance (Compile dom dom, Project (CLambda Type) dom) => Compile MutableReference dom
instance (Compile dom dom, Project (CLambda Type) dom) => Compile Mutable dom
instance (Compile dom dom, Project (CLambda Type) dom) => Compile (MONAD Mut) dom

module Feldspar.Compiler.Imperative.FromCore.MutableToPure

-- | Chase down the right-spine of <a>Bind</a> and <a>Then</a> constructs
--   and return the last term
chaseBind :: (Project (MONAD Mut) dom, Project (CLambda Type) dom) => AST dom a -> AST dom a
instance (Compile dom dom, Project (CLambda Type) dom, Project (Variable :|| Type) dom, Project (MONAD Mut) dom, Project MutableArray dom) => Compile MutableToPure dom

module Feldspar.Compiler.Imperative.FromCore.NoInline
instance [overlap ok] Compile dom dom => Compile (NoInline :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Par
instance (Compile dom dom, Project (Variable :|| Type) dom) => Compile ParFeature dom
instance (Compile dom dom, Project (CLambda Type) dom, Project ParFeature dom) => Compile (MONAD Par) dom

module Feldspar.Compiler.Imperative.FromCore.Primitive

-- | Converts symbols to primitive function calls

-- | Convenient implementation of <a>compileExprSym</a> for primitive
--   functions
compilePrim :: (Semantic expr, Compile dom dom) => (expr :|| Type) a -> Info (DenResult a) -> Args (AST (Decor Info dom)) a -> CodeWriter (Expression ())
instance Compile dom dom => Compile (Trace :|| Type) dom
instance Compile dom dom => Compile (REALFLOAT :|| Type) dom
instance Compile dom dom => Compile (ORD :|| Type) dom
instance Compile dom dom => Compile (NUM :|| Type) dom
instance Compile dom dom => Compile (Logic :|| Type) dom
instance Compile dom dom => Compile (INTEGRAL :|| Type) dom
instance Compile dom dom => Compile (FRACTIONAL :|| Type) dom
instance Compile dom dom => Compile (FLOATING :|| Type) dom
instance Compile dom dom => Compile (EQ :|| Type) dom
instance Compile dom dom => Compile (Conversion :|| Type) dom
instance Compile dom dom => Compile (COMPLEX :|| Type) dom
instance Compile dom dom => Compile (BITS :|| Type) dom
instance Compile dom dom => Compile Semantics dom

module Feldspar.Compiler.Imperative.FromCore.Save
instance Compile dom dom => Compile (Save :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.SizeProp
instance Compile dom dom => Compile (PropSize :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Switch
chaseTree :: (Compile dom dom, Project (Condition :|| Type) dom, Project (EQ :|| Type) dom) => Location -> ASTF (Decor Info dom) a -> ASTF (Decor Info dom) b -> CodeWriter [(Pattern (), Block ())]
instance (Compile dom dom, Project (EQ :|| Type) dom, Project (Condition :|| Type) dom) => Compile (Switch :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.SourceInfo
instance Compile dom dom => Compile (Decor SourceInfo1 Identity :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore.Tuple
instance Compile dom dom => Compile (Select :|| Type) dom
instance Compile dom dom => Compile (Tuple :|| Type) dom

module Feldspar.Compiler.Imperative.FromCore
compileProgTop :: (Compile dom dom, Project (CLambda Type) dom, Project Let dom, Project (Literal :|| Type) dom, ConstrainedBy dom Typeable) => Options -> String -> [(VarId, ASTB (Decor Info dom) Type)] -> ASTF (Decor Info dom) a -> CodeWriter (Variable ())
fromCore :: SyntacticFeld a => Options -> String -> a -> Module ()

-- | Get the generated core for a program.
getCore' :: SyntacticFeld a => Options -> a -> Module ()
instance Compile Empty dom
instance Compile FeldDom FeldDom

module Feldspar.Compiler.Imperative.TransformationInstance
instance [overlap ok] (Transformable t a, Default (Up t), Transformation t) => DefaultTransformable1 t Maybe a
instance [overlap ok] (Transformable t a, Default (Up t), Combine (Up t), Transformation t) => DefaultTransformable1 t [] a
instance [overlap ok] Default (Up t) => DefaultTransformable t Variable
instance [overlap ok] (Transformable t Constant, Transformable1 t [] Constant, Combine (Up t), Default (Up t)) => DefaultTransformable t Constant
instance [overlap ok] (Transformable t Expression, Transformable t Variable, Transformable t Constant, Transformable1 t [] Expression, Combine (Up t), Default (Up t)) => DefaultTransformable t Expression
instance [overlap ok] (Transformable t Variable, Transformable1 t Maybe Expression, Combine (Up t)) => DefaultTransformable t Declaration
instance [overlap ok] (Transformable t Expression, Default (Up t)) => DefaultTransformable t ActualParameter
instance [overlap ok] (Transformable t Constant, Transformable t Expression, Transformable1 t [] ActualParameter, Transformable t Block, Transformable t Variable, Combine (Up t), Default (Up t)) => DefaultTransformable t Pattern
instance [overlap ok] (Transformable1 t [] Program, Transformable t Expression, Transformable1 t [] ActualParameter, Transformable t Block, Transformable t Variable, Combine (Up t), Default (Up t), Transformation t) => DefaultTransformable t Program
instance [overlap ok] (Transformable1 t [] Declaration, Transformable t Program, Combine (Up t)) => DefaultTransformable t Block
instance [overlap ok] Default (Up t) => DefaultTransformable t StructMember
instance [overlap ok] (Transformable1 t [] StructMember, Transformable1 t [] Variable, Transformable t Block, Transformable t Declaration, Transformable t Constant, Combine (Up t), Default (Up t), Transformation t) => DefaultTransformable t Entity
instance [overlap ok] Transformable1 t [] Entity => DefaultTransformable t Module

module Feldspar.Transformation
class Transformable t Module => Plugin t where type family ExternalInfo t
executePlugin :: Plugin t => t -> ExternalInfo t -> Module (From t) -> Module (To t)

module Feldspar.Compiler.Imperative.Plugin.IVars
data IVarPlugin
IVarPlugin :: IVarPlugin
instance [overlap ok] Transformable IVarPlugin Program
instance [overlap ok] Transformable IVarPlugin Entity
instance [overlap ok] Plugin IVarPlugin
instance [overlap ok] Transformation IVarPlugin

module Feldspar.Compiler.Backend.C.Plugin.Rule
data RulePlugin
RulePlugin :: RulePlugin
instance Combine [Rule]
instance (DefaultTransformable RulePlugin t, Typeable t) => Transformable RulePlugin t
instance Plugin RulePlugin
instance Transformation RulePlugin

module Feldspar.Compiler.Backend.C.CodeGeneration
codeGenerationError :: ErrorClass -> String -> a
data PrintEnv
PEnv :: Options -> PrintEnv
options :: PrintEnv -> Options
compToCWithInfos :: Options -> Module () -> String
class CodeGen a
cgen :: CodeGen a => PrintEnv -> a -> Doc
cgenList :: CodeGen a => PrintEnv -> [a] -> Doc
transformConst :: PrintEnv -> Constant () -> Maybe String
call :: Doc -> [Doc] -> Doc
blockComment :: [Doc] -> Doc
sizeInBrackets :: Type -> Doc
stmt :: Doc -> Doc
block :: PrintEnv -> Doc -> Doc
pvar :: PrintEnv -> Variable t -> Doc
pvars :: PrintEnv -> [Variable t] -> Doc
instance CodeGen Type
instance CodeGen (Constant ())
instance CodeGen (Variable t)
instance CodeGen (Expression ())
instance CodeGen (ActualParameter ())
instance CodeGen (Pattern ())
instance CodeGen (Program ())
instance CodeGen (Declaration ())
instance CodeGen (Block ())
instance CodeGen (StructMember ())
instance CodeGen (Entity ())
instance CodeGen (Module ())

module Feldspar.Compiler.Backend.C.Platforms
availablePlatforms :: [Platform]
c99 :: Platform
c99OpenMp :: Platform
tic64x :: Platform
c99Rules :: [Rule]
tic64xRules :: [Rule]
traceRules :: [Rule]
nativeArrayRules :: [Rule]

module Feldspar.Compiler.Compiler
data SplitModuleDescriptor
SplitModuleDescriptor :: Module () -> Module () -> SplitModuleDescriptor
smdSource :: SplitModuleDescriptor -> Module ()
smdHeader :: SplitModuleDescriptor -> Module ()
data SplitCompToCCoreResult
SplitCompToCCoreResult :: CompToCCoreResult () -> CompToCCoreResult () -> SplitCompToCCoreResult
sctccrSource :: SplitCompToCCoreResult -> CompToCCoreResult ()
sctccrHeader :: SplitCompToCCoreResult -> CompToCCoreResult ()
data CompToCCoreResult t
CompToCCoreResult :: String -> Module t -> CompToCCoreResult t
sourceCode :: CompToCCoreResult t -> String
debugModule :: CompToCCoreResult t -> Module t
moduleSplitter :: Module () -> SplitModuleDescriptor
moduleToCCore :: Options -> Module () -> CompToCCoreResult ()

-- | Compiler core This functionality should not be duplicated. Instead,
--   everything should call this and only do a trivial interface
--   adaptation.
compileToCCore :: SyntacticFeld c => String -> Options -> c -> SplitCompToCCoreResult
genIncludeLines :: Options -> Maybe String -> String

-- | Predefined options
defaultOptions :: Options
c99PlatformOptions :: Options
c99OpenMpPlatformOptions :: Options
tic64xPlatformOptions :: Options
unrollOptions :: Options
noPrimitiveInstructionHandling :: Options
noMemoryInformation :: Options

-- | Plugin system
pluginChain :: ExternalInfoCollection -> Module () -> Module ()
data ExternalInfoCollection
ExternalInfoCollection :: ExternalInfo RulePlugin -> ExternalInfo RulePlugin -> ExternalInfoCollection
primitivesExternalInfo :: ExternalInfoCollection -> ExternalInfo RulePlugin
ruleExternalInfo :: ExternalInfoCollection -> ExternalInfo RulePlugin
executePluginChain :: SyntacticFeld c => String -> Options -> c -> Module ()

module Feldspar.Compiler.Frontend.Interactive.Interface
compile :: SyntacticFeld t => t -> FilePath -> String -> Options -> IO ()
icompile :: SyntacticFeld t => t -> IO ()
icompileWith :: SyntacticFeld t => Options -> t -> IO ()
icompile' :: SyntacticFeld t => Options -> String -> t -> IO ()

-- | Get the generated core for a program.
getCore :: SyntacticFeld t => t -> Module ()

-- | Print the generated core for a program.
printCore :: SyntacticFeld t => t -> IO ()

module Feldspar.Compiler.Internal

-- | Predefined options
defaultOptions :: Options
c99PlatformOptions :: Options
c99OpenMpPlatformOptions :: Options
tic64xPlatformOptions :: Options
unrollOptions :: Options
nativeArrayRules :: [Rule]
noPrimitiveInstructionHandling :: Options
noMemoryInformation :: Options

module Feldspar.Compiler
compile :: SyntacticFeld t => t -> FilePath -> String -> Options -> IO ()
icompile :: SyntacticFeld t => t -> IO ()
icompileWith :: SyntacticFeld t => Options -> t -> IO ()
icompile' :: SyntacticFeld t => Options -> String -> t -> IO ()

-- | Get the generated core for a program.
getCore :: SyntacticFeld t => t -> Module ()

-- | Print the generated core for a program.
printCore :: SyntacticFeld t => t -> IO ()
data Options
Options :: Platform -> UnrollStrategy -> DebugOption -> Bool -> Bool -> [Rule] -> FeldOpts -> Int -> Options
platform :: Options -> Platform
unroll :: Options -> UnrollStrategy
debug :: Options -> DebugOption
memoryInfoVisible :: Options -> Bool
printHeader :: Options -> Bool
rules :: Options -> [Rule]
frontendOpts :: Options -> FeldOpts

-- | Indentation size for PrettyPrinting
nestSize :: Options -> Int

-- | Predefined options
defaultOptions :: Options

-- | A record with options for explicit passing in rewrite rules.
data FeldOpts :: *
FeldOpts :: [Target] -> FeldOpts
targets :: FeldOpts -> [Target]

-- | Possible compilation targets.
data Target :: *
RegionInf :: Target
SICS :: Target
c99PlatformOptions :: Options
c99OpenMpPlatformOptions :: Options
tic64xPlatformOptions :: Options
nativeArrayRules :: [Rule]
unrollOptions :: Options
noPrimitiveInstructionHandling :: Options
noMemoryInformation :: Options


-- | Dynamically load a compiled Feldspar function as a Haskell function
module Feldspar.Compiler.Plugin

-- | Compile and load Feldspar functions into the current GHC session.
--   
--   <pre>
--   prog1 :: Data Index -&gt; Vector1 Index
--   prog1 c = indexed c (const c)
--   
--   $(loadFun ['prog1])
--   </pre>
--   
--   The call to <tt>loadFun</tt> above will splice code into the current
--   module to compile, load and wrap a Feldspar function as a Haskell
--   function:
--   
--   <pre>
--   c_prog1 :: Index -&gt; [Index]
--   </pre>
loadFun :: [Name] -> Q [Dec]

-- | Call <tt>loadFun</tt> with C compiler options
loadFunOpts :: [String] -> [Name] -> Q [Dec]

-- | Generic function compiler and loader
loadFunWithConfig :: Config -> [Name] -> Q [Dec]
defaultConfig :: Config

-- | Pack a value into its runtime representation
--   
--   <pre>
--   pack a = to a &gt;&gt;= ref
--   </pre>
pack :: (Reference (Rep a), Marshal a) => a -> IO (Ref (Rep a))

-- | Unpack a value from its runtime representation
--   
--   <pre>
--   unpack a = deref a &gt;&gt;= from
--   </pre>
unpack :: (Reference (Rep a), Marshal a) => Ref (Rep a) -> IO a
