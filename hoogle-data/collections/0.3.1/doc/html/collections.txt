-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Useful standard collections types and related functions.
--   
--   This package provides a suite of data structures types, with a
--   consistent API. It is intended as an evolution of the data structures
--   in the <tt>base</tt> package.
@package collections
@version 0.3.1


-- | This module defines the <a>XInt</a> type which is a specialised
--   instance of <a>Ord</a> which allows the number of comparisons
--   performed to be counted. This may be used evaluate various algorithms.
--   The functions defined here are not exported by the main
--   <a>Data.Tree.AVL</a> module. You need to import this module explicitly
--   if you want to use any of them.
module Data.Tree.AVL.Test.Counter

-- | Basic data type.
newtype XInt
XInt :: Int -> XInt

-- | Read the current comparison counter.
getCount :: IO Int

-- | Reset the comparison counter to zero.
resetCount :: IO ()
instance Eq XInt
instance Show XInt
instance Read XInt
instance Ord XInt


-- | AVL Tree data type definition and a few simple utility functions.
module Data.Tree.AVL.Types

-- | AVL tree data type.
--   
--   The balance factor (BF) of an <a>AVL</a> tree node is defined as the
--   difference between the height of the left and right sub-trees. An
--   <a>AVL</a> tree is ALWAYS height balanced, such that |BF| &lt;= 1. The
--   functions in this library (<a>Data.Tree.AVL</a>) are designed so that
--   they never construct an unbalanced tree (well that's assuming they're
--   not broken). The <a>AVL</a> tree type defined here has the BF encoded
--   the constructors.
--   
--   Some functions in this library return <a>AVL</a> trees that are also
--   "flat", which (in the context of this library) means that the sizes of
--   left and right sub-trees differ by at most one and are also flat. Flat
--   sorted trees should give slightly shorter searches than sorted trees
--   which are merely height balanced. Whether or not flattening is worth
--   the effort depends on the number of times the tree will be searched
--   and the cost of element comparison.
--   
--   In cases where the tree elements are sorted, all the relevant
--   <a>AVL</a> functions follow the convention that the leftmost tree
--   element is least and the rightmost tree element is the greatest. Bear
--   this in mind when defining general comparison functions. It should
--   also be noted that all functions in this library for sorted trees
--   require that the tree does not contain multiple elements which are
--   "equal" (according to whatever criterion has been used to sort the
--   elements).
--   
--   It is important to be consistent about argument ordering when defining
--   general purpose comparison functions (or selectors) for searching a
--   sorted tree, such as ..
--   
--   <pre>
--   
--   myComp  :: (k -&gt; e -&gt; Ordering)
--   -- or..
--   myCComp :: (k -&gt; e -&gt; COrdering a)
--   </pre>
--   
--   In these cases the first argument is the search key and the second
--   argument is an element of the <a>AVL</a> tree. For example..
--   
--   <pre>
--   
--   key `myCComp` element -&gt; Lt  implies key &lt; element, proceed down the left sub-tree 
--   key `myCComp` element -&gt; Gt  implies key &gt; element, proceed down the right sub-tree
--   </pre>
--   
--   This convention is same as that used by the overloaded <a>compare</a>
--   method from <a>Ord</a> class.
--   
--   WARNING: The constructors of this data type are exported from this
--   module but not from the top level <a>AVL</a> wrapper
--   (<a>Data.Tree.AVL</a>). Don't try to construct your own <a>AVL</a>
--   trees unless you're sure you know what your doing. If you end up
--   creating and using <a>AVL</a> trees that aren't you'll break most of
--   the functions in this library.
--   
--   Controlling Strictness.
--   
--   The <a>AVL</a> data type is declared as non-strict in all it's fields,
--   but all the functions in this library behave as though it is strict in
--   its recursive fields (left and right sub-trees). Strictness in the
--   element field is controlled either by using the strict variants of
--   functions (defined in this library where appropriate), or using strict
--   variants of the combinators defined in <a>Data.COrdering</a>, or using
--   <a>seq</a> etc. in your own code (in any combining comparisons you
--   define, for example).
--   
--   A note about <a>Eq</a> and <a>Ord</a> class instances.
--   
--   For <a>AVL</a> trees the defined instances of <a>Ord</a> and <a>Eq</a>
--   are based on the lists that are produced using the
--   <tt>Data.Tree.AVL.List.asListL</tt> function (it could just as well
--   have been <tt>Data.Tree.AVL.List.asListR</tt>, the choice is arbitrary
--   but I can only chose one). This means that two trees which contain the
--   same elements in the same order are equal regardless of detailed tree
--   structure. The same principle has been applied to the instances of
--   <a>Read</a> and <a>Show</a>. Unfortunately, this has the undesirable
--   and non-intuitive effect of making "equal" trees potentially
--   distinguishable using some functions (such as height). All such
--   functions have been placed in the Data.Tree.AVL.Internals modules,
--   which are not included in the main <a>Data.Tree.AVL</a> wrapper. For
--   all "normal" functions (f) exported by <a>Data.Tree.AVL</a> it is safe
--   to assume that if a and b are <a>AVL</a> trees then (a == b) implies
--   (f a == f b), provided the same is true for the tree elements.
data AVL e

-- | Empty Tree
E :: AVL e

-- | BF=-1 (right height &gt; left height)
N :: (AVL e) -> e -> (AVL e) -> AVL e

-- | BF= 0
Z :: (AVL e) -> e -> (AVL e) -> AVL e

-- | BF=+1 (left height &gt; right height)
P :: (AVL e) -> e -> (AVL e) -> AVL e

-- | The empty AVL tree.
empty :: AVL e

-- | Returns <a>True</a> if an AVL tree is empty.
--   
--   Complexity: O(1)
isEmpty :: AVL e -> Bool

-- | Returns <a>True</a> if an AVL tree is non-empty.
--   
--   Complexity: O(1)
isNonEmpty :: AVL e -> Bool

-- | Creates an AVL tree with just one element.
--   
--   Complexity: O(1)
singleton :: e -> AVL e

-- | Create an AVL tree of two elements, occuring in same order as the
--   arguments.
pair :: e -> e -> AVL e

-- | If the AVL tree is a singleton (has only one element <tt>e</tt>) then
--   this function returns <tt>(<a>Just</a> e)</tt>. Otherwise it returns
--   Nothing.
--   
--   Complexity: O(1)
tryGetSingleton :: AVL e -> Maybe e
instance Foldable AVL
instance (Typeable e) => Typeable (AVL e)
instance Typeable1 AVL


-- | AVL Tree size related utilities.
module Data.Tree.AVL.Size

-- | Counts the total number of elements in an AVL tree.
--   
--   Complexity: O(n)
size :: AVL e -> Int

-- | Adds the size of a tree to the first argument.
--   
--   Complexity: O(n)
addSize :: Int -> AVL e -> Int


module Data.Ranged.Boundaries

-- | Distinguish between dense and sparse ordered types. A dense type is
--   one in which any two values <tt>v1 &lt; v2</tt> have a third value
--   <tt>v3</tt> such that <tt>v1 &lt; v3 &lt; v2</tt>.
--   
--   In theory the floating types are dense, although in practice they can
--   only have finitely many values. This class treats them as dense.
--   
--   Tuples up to 4 members are declared as instances. Larger tuples may be
--   added if necessary.
--   
--   This approach was suggested by Ben Rudiak-Gould on
--   comp.lang.functional.
class (Ord a) => DiscreteOrdered a
adjacent :: (DiscreteOrdered a) => a -> a -> Bool

-- | Check adjacency for sparse enumerated types (i.e. where there is no
--   value between <tt>x</tt> and <tt>succ x</tt>). Use as the definition
--   of <a>adjacent</a> for most enumerated types.
enumAdjacent :: (Ord a, Enum a) => a -> a -> Bool

-- | Check adjacency, allowing for case where x = maxBound. Use as the
--   definition of <a>adjacent</a> for bounded enumerated types such as Int
--   and Char.
boundedAdjacent :: (Ord a, Enum a) => a -> a -> Bool

-- | A Boundary is a division of an ordered type into values above and
--   below the boundary. No value can sit on a boundary.
--   
--   Known bug: for Bounded types
--   
--   <ul>
--   <li><pre>BoundaryAbove maxBound &lt; BoundaryAboveAll</pre></li>
--   <li><pre>BoundaryBelow minBound &gt; BoundaryBelowAll</pre></li>
--   </ul>
--   
--   This is incorrect because there are no possible values in between the
--   left and right sides of these inequalities.
data Boundary a

-- | The argument is the highest value below the boundary.
BoundaryAbove :: a -> Boundary a

-- | The argument is the lowest value above the boundary.
BoundaryBelow :: a -> Boundary a

-- | The boundary above all values.
BoundaryAboveAll :: Boundary a

-- | The boundary below all values.
BoundaryBelowAll :: Boundary a

-- | True if the value is above the boundary, false otherwise.
above :: (Ord v) => Boundary v -> v -> Bool

-- | Same as <a>above</a>, but with the arguments reversed for more
--   intuitive infix usage.
(/>/) :: (Ord v) => v -> Boundary v -> Bool
instance (Show a) => Show (Boundary a)
instance (Arbitrary a) => Arbitrary (Boundary a)
instance (DiscreteOrdered a) => Ord (Boundary a)
instance (DiscreteOrdered a) => Eq (Boundary a)
instance (Ord a, Ord b, Ord c, DiscreteOrdered d) => DiscreteOrdered (a, b, c, d)
instance (Ord a, Ord b, DiscreteOrdered c) => DiscreteOrdered (a, b, c)
instance (Ord a, DiscreteOrdered b) => DiscreteOrdered (a, b)
instance (Ord a) => DiscreteOrdered [a]
instance DiscreteOrdered Double
instance DiscreteOrdered Float
instance (Integral a) => DiscreteOrdered (Ratio a)
instance DiscreteOrdered Integer
instance DiscreteOrdered Int
instance DiscreteOrdered Char
instance DiscreteOrdered Ordering
instance DiscreteOrdered Bool


-- | A range has an upper and lower boundary.
module Data.Ranged.Ranges

-- | A Range has upper and lower boundaries.
data (Ord v) => Range v
Range :: Boundary v -> Boundary v -> Range v
rangeLower :: Range v -> Boundary v
rangeUpper :: Range v -> Boundary v

-- | The empty range
emptyRange :: (DiscreteOrdered v) => Range v

-- | The full range. All values are within it.
fullRange :: (DiscreteOrdered v) => Range v

-- | A range is empty unless its upper boundary is greater than its lower
--   boundary.
rangeIsEmpty :: (DiscreteOrdered v) => Range v -> Bool

-- | Two ranges overlap if their intersection is non-empty.
rangeOverlap :: (DiscreteOrdered v) => Range v -> Range v -> Bool

-- | The first range encloses the second if every value in the second range
--   is also within the first range. If the second range is empty then this
--   is always true.
rangeEncloses :: (DiscreteOrdered v) => Range v -> Range v -> Bool

-- | True if the value is within the range.
rangeHas :: (Ord v) => Range v -> v -> Bool

-- | True if the value is within one of the ranges.
rangeListHas :: (Ord v) => [Range v] -> v -> Bool

-- | A range containing a single value
singletonRange :: (DiscreteOrdered v) => v -> Range v

-- | Intersection of two ranges, if any.
rangeIntersection :: (DiscreteOrdered v) => Range v -> Range v -> Range v

-- | Union of two ranges. Returns one or two results.
--   
--   If there are two results then they are guaranteed to have a non-empty
--   gap in between, but may not be in ascending order.
rangeUnion :: (DiscreteOrdered v) => Range v -> Range v -> [Range v]

-- | <tt>range1</tt> minus <tt>range2</tt>. Returns zero, one or two
--   results. Multiple results are guaranteed to have non-empty gaps in
--   between, but may not be in ascending order.
rangeDifference :: (DiscreteOrdered v) => Range v -> Range v -> [Range v]
instance (Arbitrary v, DiscreteOrdered v, Show v) => Arbitrary (Range v)
instance (Show a, DiscreteOrdered a) => Show (Range a)
instance (DiscreteOrdered a) => Ord (Range a)
instance (DiscreteOrdered a) => Eq (Range a)

module Data.Ranged.RangedSet

-- | An RSet (for Ranged Set) is a list of ranges. The ranges must be
--   sorted and not overlap.
data (DiscreteOrdered v) => RSet v
rSetRanges :: RSet v -> [Range v]

-- | Create a new Ranged Set from a list of ranges. The list may contain
--   ranges that overlap or are not in ascending order.
makeRangedSet :: (DiscreteOrdered v) => [Range v] -> RSet v

-- | Create a new Ranged Set from a list of ranges. <tt>validRangeList
--   ranges</tt> must return <tt>True</tt>. This precondition is not
--   checked.
unsafeRangedSet :: (DiscreteOrdered v) => [Range v] -> RSet v

-- | Determine if the ranges in the list are both in order and
--   non-overlapping. If so then they are suitable input for the
--   unsafeRangedSet function.
validRangeList :: (DiscreteOrdered v) => [Range v] -> Bool

-- | Rearrange and merge the ranges in the list so that they are in order
--   and non-overlapping.
normaliseRangeList :: (DiscreteOrdered v) => [Range v] -> [Range v]

-- | Create a Ranged Set from a single element.
rSingleton :: (DiscreteOrdered v) => v -> RSet v

-- | True if the set has no members.
rSetIsEmpty :: (DiscreteOrdered v) => RSet v -> Bool

-- | True if the value is within the ranged set. Infix precedence is left
--   5.
(-?-) :: (DiscreteOrdered v) => RSet v -> v -> Bool
rSetHas :: (DiscreteOrdered v) => RSet v -> v -> Bool

-- | True if the first argument is a subset of the second argument, or is
--   equal.
--   
--   Infix precedence is left 5.
(-<=-) :: (DiscreteOrdered v) => RSet v -> RSet v -> Bool
rSetIsSubset :: (DiscreteOrdered v) => RSet v -> RSet v -> Bool

-- | True if the first argument is a strict subset of the second argument.
--   
--   Infix precedence is left 5.
(-<-) :: (DiscreteOrdered v) => RSet v -> RSet v -> Bool
rSetIsSubsetStrict :: (DiscreteOrdered v) => RSet v -> RSet v -> Bool

-- | Set union for ranged sets. Infix precedence is left 6.
(-\/-) :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v
rSetUnion :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v

-- | Set intersection for ranged sets. Infix precedence is left 7.
(-/\-) :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v
rSetIntersection :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v

-- | Set difference. Infix precedence is left 6.
(-!-) :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v
rSetDifference :: (DiscreteOrdered v) => RSet v -> RSet v -> RSet v

-- | Set negation.
rSetNegation :: (DiscreteOrdered a) => RSet a -> RSet a

-- | The empty set.
rSetEmpty :: (DiscreteOrdered a) => RSet a

-- | The set that contains everything.
rSetFull :: (DiscreteOrdered a) => RSet a

-- | Construct a range set.
rSetUnfold :: (DiscreteOrdered a) => Boundary a -> (Boundary a -> Boundary a) -> (Boundary a -> Maybe (Boundary a)) -> RSet a
instance (DiscreteOrdered v) => Eq (RSet v)
instance (Show v, DiscreteOrdered v) => Show (RSet v)
instance (Arbitrary v, DiscreteOrdered v, Show v) => Arbitrary (RSet v)
instance Typeable1 RSet
instance (DiscreteOrdered a) => Monoid (RSet a)

module Data.Ranged


-- | Derived from Data.Set by Daan Leijen License : BSD Maintainer : David
--   F. Place Stability : Experimental Portability : ?
--   
--   An efficient implementation of sets over small enumerations.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. eg.
--   
--   <pre>
--   import Data.Set.Enum as Set
--   </pre>
--   
--   The implementation of <tt>EnumSet</tt> is based on bit-wise
--   operations.
module Data.Set.Enum

-- | A set of values <tt>a</tt> implemented as bitwise operations. Useful
--   for members of class Enum with no more elements than there are bits in
--   <tt>Word</tt>.
data Set a
(\\) :: Set a -> Set a -> Set a

-- | <i>O(1)</i>. Is this the empty set?
null :: Set a -> Bool

-- | <i>O(1)</i>. The number of elements in the set.
size :: (Enum a) => Set a -> Int

-- | <i>O(1)</i>. Is the element in the set?
member :: (Enum a) => a -> Set a -> Bool

-- | <i>O(1)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: Set a -> Set a -> Bool

-- | <i>O(1)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Set a -> Set a -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: Set a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: (Enum a) => a -> Set a

-- | <i>O(1)</i>. Insert an element in a set. If the set already contains
--   an element equal to the given value, it is replaced with the new
--   value.
insert :: (Enum a) => a -> Set a -> Set a

-- | <i>O(1)</i>. Delete an element from a set.
delete :: (Enum a) => a -> Set a -> Set a

-- | <i>O(1)</i>. The union of two sets.
union :: Set a -> Set a -> Set a

-- | The union of a list of sets: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: [Set a] -> Set a

-- | <i>O(1)</i>. Difference of two sets.
difference :: Set a -> Set a -> Set a

-- | <i>O(1)</i>. The intersection of two sets.
intersection :: Set a -> Set a -> Set a

-- | <i>O(1)</i>. The complement of a set with its universe set.
--   <tt>complement</tt> can be used with bounded types for which the
--   universe set will be automatically created.
complement :: (Bounded a, Enum a) => Set a -> Set a
complementWith :: Set a -> Set a -> Set a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
filter :: (Enum a) => (a -> Bool) -> Set a -> Set a

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: (Enum a) => (a -> Bool) -> Set a -> (Set a, Set a)
split :: (Ord a, Enum a) => a -> Set a -> (Set a, Set a)
splitMember :: (Ord a, Enum a) => a -> Set a -> (Set a, Bool, Set a)

-- | <i>O(n)</i>. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Enum a, Enum b) => (a -> b) -> Set a -> Set b

-- | <tt><a>mapMonotonic</a></tt> is provided for compatibility with the
--   Data.Set interface.
mapMonotonic :: (Enum a, Enum b) => (a -> b) -> Set a -> Set b

-- | <i>O(n)</i>. Fold over the elements of a set in an unspecified order.
fold :: (Enum a) => (b -> a -> b) -> b -> Set a -> b
foldr :: (Enum a) => (a -> c -> c) -> c -> Set a -> c

-- | The minimal element of a set.
findMin :: (Enum a) => Set a -> a

-- | The maximal element of a set.
findMax :: (Enum a) => Set a -> a

-- | Delete the minimal element.
deleteMin :: Set a -> Set a

-- | Delete the maximal element.
deleteMax :: Set a -> Set a
deleteFindMin :: (Enum a) => Set a -> (a, Set a)
deleteFindMax :: (Enum a) => Set a -> (a, Set a)

-- | <i>O(n)</i>. The elements of a set.
elems :: (Enum a) => Set a -> [a]

-- | <i>O(n)</i>. Convert the set to a list of elements.
toList :: (Enum a) => Set a -> [a]

-- | <i>O(n)</i>. Create a set from a list of elements.
fromList :: (Enum a) => [a] -> Set a

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: (Ord a, Enum a) => Set a -> [a]

-- | <tt>fromAscList</tt> and <tt>fromDistinctAscList</tt> maintained for
--   compatibility with Data.Set, but here give no advantage.
fromAscList :: (Enum a) => [a] -> Set a
fromDistinctAscList :: (Enum a) => [a] -> Set a
instance Eq (Set a)
instance (Enum a) => Monoid (Set a)
instance (Enum a, Ord a) => Ord (Set a)
instance (Enum a, Show a) => Show (Set a)
instance Typeable1 Set


-- | Class of data structures that can be folded to a summary value.
module Data.Collections.Foldable

-- | Data structures that can be folded.
--   
--   Minimal complete definition: <a>foldMap</a> or <a>foldr</a>.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws.
class Foldable t a | t -> a
fold :: (Foldable t a, Monoid a) => t -> a
foldMap :: (Foldable t a, Monoid m) => (a -> m) -> t -> m
foldr :: (Foldable t a) => (a -> b -> b) -> b -> t -> b
foldl :: (Foldable t a) => (b -> a -> b) -> b -> t -> b
foldr1 :: (Foldable t a) => (a -> a -> a) -> t -> a
foldl1 :: (Foldable t a) => (a -> a -> a) -> t -> a
null :: (Foldable t a) => t -> Bool
size :: (Foldable t a) => t -> Int
isSingleton :: (Foldable t a) => t -> Bool

-- | Fold over the elements of a structure, associating to the right, but
--   strictly.
foldr' :: (Foldable t a) => (a -> b -> b) -> b -> t -> b

-- | Fold over the elements of a structure, associating to the left, but
--   strictly.
foldl' :: (Foldable t b) => (a -> b -> a) -> a -> t -> a

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t a, Monad m) => (a -> b -> m b) -> b -> t -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t b, Monad m) => (a -> b -> m a) -> a -> t -> m a

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results.
traverse_ :: (Foldable t a, Applicative f) => (a -> f b) -> t -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped.
for_ :: (Foldable t a, Applicative f) => t -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results.
sequenceA_ :: (Foldable t (f a), Applicative f) => t -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
asum :: (Foldable t (f a), Alternative f) => t -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results.
mapM_ :: (Foldable t a, Monad m) => (a -> m b) -> t -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped.
forM_ :: (Foldable t a, Monad m) => t -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results.
sequence_ :: (Foldable t (m a), Monad m) => t -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
msum :: (Foldable t (m a), MonadPlus m) => t -> m a

-- | List of elements of a structure.
toList :: (Foldable t a) => t -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: (Foldable t Bool) => t -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: (Foldable t Bool) => t -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: (Foldable t a) => (a -> Bool) -> t -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: (Foldable t a) => (a -> Bool) -> t -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t a, Num a) => t -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t a, Num a) => t -> a

-- | The largest element of the structure.
maximum :: (Foldable t a, Ord a) => t -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: (Foldable t a) => (a -> a -> Ordering) -> t -> a

-- | The least element of a non-null structure.
minimum :: (Foldable t a, Ord a) => t -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: (Foldable t a) => (a -> a -> Ordering) -> t -> a

-- | Does the element occur in the structure?
elem :: (Foldable t a, Eq a) => a -> t -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t a, Eq a) => a -> t -> Bool

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: (Foldable t a) => (a -> Bool) -> t -> Maybe a
instance (Ix i) => Foldable (Array i a) (i, a)
instance Foldable [a] a
instance Foldable (Maybe a) a


-- | This module defines a useful variant of the <a>Prelude</a>
--   <a>Ordering</a> data type.
--   
--   Typically this data type is used as the result of a "combining
--   comparison" which combines values that are deemed to be equal
--   (somehow). Note that the functions defined here adhere to the same
--   ordering convention as the overloaded <a>compare</a> (from the
--   <a>Ord</a> class). That is..
--   
--   <pre>
--   a `compare` b -&gt; LT (or Lt) implies a &lt; b   
--   a `compare` b -&gt; GT (or Gt) implies a &gt; b   
--   </pre>
--   
--   The combinators exported from this module have a "CC" suffix if they
--   return a combining comparison (most of them) and a "C" suffix if they
--   return an ordinary comparison. All the combinators defined here are
--   INLINEd, in the hope that the compiler can avoid the overhead of using
--   HOFs for frequently used comparisons (dunno if this does any good
--   though :-)
module Data.COrdering

-- | Result of a combining comparison.
data COrdering a
Lt :: COrdering a
Eq :: a -> COrdering a
Gt :: COrdering a

-- | A combining comparison for an instance of <a>Ord</a> which returns
--   unit () where appropriate.
--   
--   <pre>
--   unitCC a b = case compare a b of LT -&gt; Lt
--                                    EQ -&gt; Eq ()
--                                    GT -&gt; Gt
--   </pre>
unitCC :: (Ord a) => (a -> a -> COrdering ())

-- | Create a combining comparison from an ordinary comparison by returning
--   unit () where appropriate.
--   
--   <pre>
--   unitByCC cmp a b = case cmp a b of LT -&gt; Lt
--                                      EQ -&gt; Eq ()
--                                      GT -&gt; Gt
--   </pre>
unitByCC :: (a -> b -> Ordering) -> (a -> b -> COrdering ())

-- | A combining comparison for an instance of <a>Ord</a> which keeps the
--   first argument if they are deemed equal. The second argument is
--   discarded in this case.
--   
--   <pre>
--   fstCC a a' = case compare a a' of LT -&gt; Lt
--                                     EQ -&gt; Eq a
--                                     GT -&gt; Gt
--   </pre>
fstCC :: (Ord a) => (a -> a -> COrdering a)

-- | Create a combining comparison from an ordinary comparison by keeping
--   the first argument if they are deemed equal. The second argument is
--   discarded in this case.
--   
--   <pre>
--   fstByCC cmp a b = case cmp a b of LT -&gt; Lt
--                                     EQ -&gt; Eq a
--                                     GT -&gt; Gt
--   </pre>
fstByCC :: (a -> b -> Ordering) -> (a -> b -> COrdering a)

-- | A combining comparison for an instance of <a>Ord</a> which keeps the
--   second argument if they are deemed equal. The first argument is
--   discarded in this case.
--   
--   <pre>
--   sndCC a a' = case compare a a' of LT -&gt; Lt
--                                     EQ -&gt; Eq a'
--                                     GT -&gt; Gt
--   </pre>
sndCC :: (Ord a) => (a -> a -> COrdering a)

-- | Create a combining comparison from an ordinary comparison by keeping
--   the second argument if they are deemed equal. The first argument is
--   discarded in this case.
--   
--   <pre>
--   sndByCC cmp a b = case cmp a b of LT -&gt; Lt
--                                     EQ -&gt; Eq b
--                                     GT -&gt; Gt
--   </pre>
sndByCC :: (a -> b -> Ordering) -> (a -> b -> COrdering b)

-- | Converts a comparison to one which takes arguments in flipped order,
--   but preserves the ordering that would be given by the "unflipped"
--   version (disregarding type issues). So it's not the same as using the
--   prelude <a>flip</a> (which would reverse the ordering too).
--   
--   <pre>
--   flipC cmp b a = case cmp a b of LT -&gt; GT
--                                   EQ -&gt; EQ
--                                   GT -&gt; LT
--   </pre>
flipC :: (a -> b -> Ordering) -> (b -> a -> Ordering)

-- | Converts a combining comparison to one which takes arguments in
--   flipped order, but preserves the ordering that would be given by the
--   "unflipped" version (disregarding type issues). So it's not the same
--   as using the prelude <a>flip</a> (which would reverse the ordering
--   too).
--   
--   <pre>
--   flipCC cmp b a = case cmp a b of Lt       -&gt; Gt
--                                    e@(Eq _) -&gt; e
--                                    Gt       -&gt; Lt
--   </pre>
flipCC :: (a -> b -> COrdering c) -> (b -> a -> COrdering c)

-- | Create a combining comparison using the supplied combining function,
--   which is applied if <a>compare</a> returns <a>EQ</a>. See
--   <a>withCC'</a> for a stricter version of this function.
--   
--   <pre>
--   withCC f a a' = case compare a a' of LT -&gt; Lt
--                                        EQ -&gt; Eq (f a a')
--                                        GT -&gt; Gt
--   </pre>
withCC :: (Ord a) => (a -> a -> b) -> (a -> a -> COrdering b)

-- | Same as <a>withCC</a>, except the combining function is applied
--   strictly.
--   
--   <pre>
--   withCC' f a a' = case compare a a' of LT -&gt; Lt
--                                         EQ -&gt; let b = f a a' in b `seq` Eq b
--                                         GT -&gt; Gt
--   </pre>
withCC' :: (Ord a) => (a -> a -> b) -> (a -> a -> COrdering b)

-- | Create a combining comparison using the supplied comparison and
--   combining function, which is applied if the comparison returns
--   <a>EQ</a>. See <a>withByCC'</a> for a stricter version of this
--   function.
--   
--   <pre>
--   withByCC cmp f a b = case cmp a b of LT -&gt; Lt
--                                        EQ -&gt; Eq (f a b)
--                                        GT -&gt; Gt
--   </pre>
withByCC :: (a -> b -> Ordering) -> (a -> b -> c) -> (a -> b -> COrdering c)

-- | Same as <a>withByCC</a>, except the combining function is applied
--   strictly.
--   
--   <pre>
--   withByCC' cmp f a b = case cmp a b of LT -&gt; Lt
--                                         EQ -&gt; let c = f a b in c `seq` Eq c
--                                         GT -&gt; Gt
--   </pre>
withByCC' :: (a -> b -> Ordering) -> (a -> b -> c) -> (a -> b -> COrdering c)
instance (Eq a) => Eq (COrdering a)
instance (Ord a) => Ord (COrdering a)
instance (Read a) => Read (COrdering a)
instance (Show a) => Show (COrdering a)
instance (Typeable e) => Typeable (COrdering e)
instance Typeable1 COrdering


-- | This module defines useful functions for searching AVL trees and
--   reading information from a particular element. The functions defined
--   here do not alter either the content or the structure of a tree.
module Data.Tree.AVL.Read

-- | Read the leftmost element from a <i>non-empty</i> tree. Raises an
--   error if the tree is empty. If the tree is sorted this will return the
--   least element.
--   
--   Complexity: O(log n)
assertReadL :: AVL e -> e

-- | Similar to <a>assertReadL</a> but returns <a>Nothing</a> if the tree
--   is empty.
--   
--   Complexity: O(log n)
tryReadL :: AVL e -> Maybe e

-- | Read the rightmost element from a <i>non-empty</i> tree. Raises an
--   error if the tree is empty. If the tree is sorted this will return the
--   greatest element.
--   
--   Complexity: O(log n)
assertReadR :: AVL e -> e

-- | Similar to <a>assertReadR</a> but returns <a>Nothing</a> if the tree
--   is empty.
--   
--   Complexity: O(log n)
tryReadR :: AVL e -> Maybe e

-- | General purpose function to perform a search of a sorted tree, using
--   the supplied selector. This function raises a error if the search
--   fails.
--   
--   Complexity: O(log n)
genAssertRead :: AVL e -> (e -> COrdering a) -> a

-- | General purpose function to perform a search of a sorted tree, using
--   the supplied selector. This function is similar to
--   <a>genAssertRead</a>, but returns <a>Nothing</a> if the search failed.
--   
--   Complexity: O(log n)
genTryRead :: AVL e -> (e -> COrdering a) -> Maybe a

-- | This version returns the result of the selector (without adding a
--   <a>Just</a> wrapper) if the search succeeds, or <a>Nothing</a> if it
--   fails.
--   
--   Complexity: O(log n)
genTryReadMaybe :: AVL e -> (e -> COrdering (Maybe a)) -> Maybe a

-- | General purpose function to perform a search of a sorted tree, using
--   the supplied selector. This function is similar to
--   <a>genAssertRead</a>, but returns a the default value (first argument)
--   if the search fails.
--   
--   Complexity: O(log n)
genDefaultRead :: a -> AVL e -> (e -> COrdering a) -> a

-- | General purpose function to perform a search of a sorted tree, using
--   the supplied selector. Returns True if matching element is found.
--   
--   Complexity: O(log n)
genContains :: AVL e -> (e -> Ordering) -> Bool


-- | This module defines useful functions for searching AVL trees and
--   writing information to a particular element. The functions defined
--   here may alter the content of a tree (values of tree elements) but not
--   the structure of a tree (no insertion or deletion).
module Data.Tree.AVL.Write

-- | Replace the left most element of a tree with the supplied new element.
--   This function raises an error if applied to an empty tree.
--   
--   Complexity: O(log n)
writeL :: e -> AVL e -> AVL e

-- | Similar to <a>writeL</a>, but returns <a>Nothing</a> if applied to an
--   empty tree.
--   
--   Complexity: O(log n)
tryWriteL :: e -> AVL e -> Maybe (AVL e)

-- | Replace the right most element of a tree with the supplied new
--   element. This function raises an error if applied to an empty tree.
--   
--   Complexity: O(log n)
writeR :: AVL e -> e -> AVL e

-- | Similar to <a>writeR</a>, but returns <a>Nothing</a> if applied to an
--   empty tree.
--   
--   Complexity: O(log n)
tryWriteR :: AVL e -> e -> Maybe (AVL e)

-- | A general purpose function to perform a search of a tree, using the
--   supplied selector. If the search succeeds the found element is
--   replaced by the value (<tt>e</tt>) of the <tt>(<a>Eq</a> e)</tt>
--   constructor returned by the selector. If the search fails this
--   function returns the original tree.
--   
--   Complexity: O(log n)
genWrite :: (e -> COrdering e) -> AVL e -> AVL e

-- | Functionally identical to <a>genWrite</a>, but returns an identical
--   tree (one with all the nodes on the path duplicated) if the search
--   fails. This should probably only be used if you know the search will
--   succeed and will return an element which is different from that
--   already present.
--   
--   Complexity: O(log n)
genWriteFast :: (e -> COrdering e) -> AVL e -> AVL e

-- | A general purpose function to perform a search of a tree, using the
--   supplied selector. The found element is replaced by the value
--   (<tt>e</tt>) of the <tt>(<a>Eq</a> e)</tt> constructor returned by the
--   selector. This function returns <a>Nothing</a> if the search failed.
--   
--   Complexity: O(log n)
genTryWrite :: (e -> COrdering e) -> AVL e -> Maybe (AVL e)

-- | Similar to <a>genWrite</a>, but also returns the original tree if the
--   search succeeds but the selector returns <tt>(<a>Eq</a>
--   <a>Nothing</a>)</tt>. (This version is intended to help reduce heap
--   burn rate if it's likely that no modification of the value is needed.)
--   
--   Complexity: O(log n)
genWriteMaybe :: (e -> COrdering (Maybe e)) -> AVL e -> AVL e

-- | Similar to <a>genTryWrite</a>, but also returns the original tree if
--   the search succeeds but the selector returns <tt>(<a>Eq</a>
--   <a>Nothing</a>)</tt>. (This version is intended to help reduce heap
--   burn rate if it's likely that no modification of the value is needed.)
--   
--   Complexity: O(log n)
genTryWriteMaybe :: (e -> COrdering (Maybe e)) -> AVL e -> Maybe (AVL e)


-- | This module defines functions for searching AVL trees and pushing a
--   new element in the tree (or modifying the value of an existing
--   element). The functions defined here may alter the content of a tree
--   (value of an existing tree element) and also the structure of a tree
--   (by adding a new element).
module Data.Tree.AVL.Push

-- | Push a new element in the leftmost position of an AVL tree. No
--   comparison or searching is involved.
--   
--   Complexity: O(log n)
pushL :: e -> AVL e -> AVL e

-- | Push a new element in the rightmost position of an AVL tree. No
--   comparison or searching is involved.
--   
--   Complexity: O(log n)
pushR :: AVL e -> e -> AVL e

-- | General push. This function searches the AVL tree using the supplied
--   selector. If a matching element is found it's replaced by the value
--   (<tt>e</tt>) returned in the <tt>(<a>Eq</a> e)</tt> constructor
--   returned by the selector. If no match is found then the default
--   element value is added at in the appropriate position in the tree.
--   
--   Note that for this to work properly requires that the selector behave
--   as if it were comparing the (potentially) new default element with
--   existing tree elements, even if it isn't.
--   
--   Note also that this function is <i>non-strict</i> in it's second
--   argument (the default value which is inserted if the search fails or
--   is discarded if the search succeeds). If you want to force evaluation,
--   but only if it's actually incorprated in the tree, then use
--   <a>genPush'</a>
--   
--   Complexity: O(log n)
genPush :: (e -> COrdering e) -> e -> AVL e -> AVL e

-- | Almost identical to <a>genPush</a>, but this version forces evaluation
--   of the default new element (second argument) if no matching element is
--   found. Note that it does <i>not</i> do this if a matching element is
--   found, because in this case the default new element is discarded
--   anyway. Note also that it does not force evaluation of any replacement
--   value provided by the selector (if it returns Eq). (You have to do
--   that yourself if that's what you want.)
--   
--   Complexity: O(log n)
genPush' :: (e -> COrdering e) -> e -> AVL e -> AVL e

-- | Similar to <a>genPush</a>, but returns the original tree if the
--   combining comparison returns <tt>(<a>Eq</a> <a>Nothing</a>)</tt>. So
--   this function can be used reduce heap burn rate by avoiding
--   duplication of nodes on the insertion path. But it may also be
--   marginally slower otherwise.
--   
--   Note that this function is <i>non-strict</i> in it's second argument
--   (the default value which is inserted in the search fails or is
--   discarded if the search succeeds). If you want to force evaluation,
--   but only if it's actually incorprated in the tree, then use
--   <a>genPushMaybe'</a>
--   
--   Complexity: O(log n)
genPushMaybe :: (e -> COrdering (Maybe e)) -> e -> AVL e -> AVL e

-- | Almost identical to <a>genPushMaybe</a>, but this version forces
--   evaluation of the default new element (second argument) if no matching
--   element is found. Note that it does <i>not</i> do this if a matching
--   element is found, because in this case the default new element is
--   discarded anyway.
--   
--   Complexity: O(log n)
genPushMaybe' :: (e -> COrdering (Maybe e)) -> e -> AVL e -> AVL e


-- | List related utilities for AVL trees.
module Data.Tree.AVL.List

-- | List AVL tree contents in left to right order. The resulting list in
--   ascending order if the tree is sorted.
--   
--   Complexity: O(n)
asListL :: AVL e -> [e]

-- | Join the AVL tree contents to an existing list in left to right order.
--   This is a ++ free function which behaves as if defined thusly..
--   
--   <pre>
--   avl `toListL` as = (asListL avl) ++ as 
--   </pre>
--   
--   Complexity: O(n)
toListL :: AVL e -> [e] -> [e]

-- | List AVL tree contents in right to left order. The resulting list in
--   descending order if the tree is sorted.
--   
--   Complexity: O(n)
asListR :: AVL e -> [e]

-- | Join the AVL tree contents to an existing list in right to left order.
--   This is a ++ free function which behaves as if defined thusly..
--   
--   <pre>
--   avl `toListR` as = (asListR avl) ++ as 
--   </pre>
--   
--   Complexity: O(n)
toListR :: AVL e -> [e] -> [e]

-- | Convert a list of known length into an AVL tree, such that the head of
--   the list becomes the leftmost tree element. The resulting tree is flat
--   (and also sorted if the supplied list is sorted in ascending order).
--   
--   If the actual length of the list is not the same as the supplied
--   length then an error will be raised.
--   
--   Complexity: O(n)
asTreeLenL :: Int -> [e] -> AVL e

-- | As <a>asTreeLenL</a>, except the length of the list is calculated
--   internally, not supplied as an argument.
--   
--   Complexity: O(n)
asTreeL :: [e] -> AVL e

-- | Convert a list of known length into an AVL tree, such that the head of
--   the list becomes the rightmost tree element. The resulting tree is
--   flat (and also sorted if the supplied list is sorted in descending
--   order).
--   
--   If the actual length of the list is not the same as the supplied
--   length then an error will be raised.
--   
--   Complexity: O(n)
asTreeLenR :: Int -> [e] -> AVL e

-- | As <a>asTreeLenR</a>, except the length of the list is calculated
--   internally, not supplied as an argument.
--   
--   Complexity: O(n)
asTreeR :: [e] -> AVL e

-- | Invokes <a>genPushList</a> on the empty AVL tree.
--   
--   Complexity: O(n.(log n))
genAsTree :: (e -> e -> COrdering e) -> [e] -> AVL e

-- | Push the elements of an unsorted List in a sorted AVL tree using the
--   supplied combining comparison.
--   
--   Complexity: O(n.(log (m+n))) where n is the list length, m is the tree
--   size.
genPushList :: (e -> e -> COrdering e) -> AVL e -> [e] -> AVL e

-- | Reverse an AVL tree (swaps and reverses left and right sub-trees). The
--   resulting tree is the mirror image of the original.
--   
--   Complexity: O(n)
reverseAVL :: AVL e -> AVL e

-- | Apply a function to every element in an AVL tree. This function
--   preserves the tree shape. There is also a strict version of this
--   function (<a>mapAVL'</a>).
--   
--   N.B. If the tree is sorted the result of this operation will only be
--   sorted if the applied function preserves ordering (for some suitable
--   ordering definition).
--   
--   Complexity: O(n)
mapAVL :: (a -> b) -> AVL a -> AVL b

-- | Similar to <a>mapAVL</a>, but the supplied function is applied
--   strictly.
--   
--   Complexity: O(n)
mapAVL' :: (a -> b) -> AVL a -> AVL b
traverseAVL :: (Applicative f) => (a -> f b) -> AVL a -> f (AVL b)

-- | Construct a flat AVL tree of size n (n&gt;=0), where all elements are
--   identical.
--   
--   Complexity: O(log n)
replicateAVL :: Int -> e -> AVL e

-- | Remove all AVL tree elements which do not satisfy the supplied
--   predicate. Element ordering is preserved. The resulting tree is flat.
--   
--   Complexity: O(n)
filterViaList :: (e -> Bool) -> AVL e -> AVL e

-- | Remove all AVL tree elements for which the supplied function returns
--   <a>Nothing</a>. Element ordering is preserved. The resulting tree is
--   flat.
--   
--   Complexity: O(n)
mapMaybeViaList :: (a -> Maybe b) -> AVL a -> AVL b

-- | Partition an AVL tree using the supplied predicate. The first AVL tree
--   in the resulting pair contains all elements for which the predicate is
--   True, the second contains all those for which the predicate is False.
--   Element ordering is preserved. Both of the resulting trees are flat.
--   
--   Complexity: O(n)
partitionAVL :: (e -> Bool) -> AVL e -> (AVL e, AVL e)

-- | The AVL equivalent of <a>foldr</a> on lists. This is a the lazy
--   version (as lazy as the folding function anyway). Using this version
--   with a function that is strict in it's second argument will result in
--   O(n) stack use. See <a>foldrAVL'</a> for a strict version.
--   
--   It behaves as if defined..
--   
--   <pre>
--   foldrAVL f a avl = foldr f a (asListL avl)
--   </pre>
--   
--   For example, the <a>asListL</a> function could be defined..
--   
--   <pre>
--   asListL = foldrAVL (:) []
--   </pre>
--   
--   Complexity: O(n)
foldrAVL :: (e -> a -> a) -> a -> AVL e -> a

-- | The strict version of <a>foldrAVL</a>, which is useful for functions
--   which are strict in their second argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldrAVL' :: (e -> a -> a) -> a -> AVL e -> a

-- | The AVL equivalent of <a>foldr1</a> on lists. This is a the lazy
--   version (as lazy as the folding function anyway). Using this version
--   with a function that is strict in it's second argument will result in
--   O(n) stack use. See <a>foldr1AVL'</a> for a strict version.
--   
--   <pre>
--   foldr1AVL f avl = foldr1 f (asListL avl)
--   </pre>
--   
--   This function raises an error if the tree is empty.
--   
--   Complexity: O(n)
foldr1AVL :: (e -> e -> e) -> AVL e -> e

-- | The strict version of <a>foldr1AVL</a>, which is useful for functions
--   which are strict in their second argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldr1AVL' :: (e -> e -> e) -> AVL e -> e

-- | This fold is a hybrid between <a>foldrAVL</a> and <a>foldr1AVL</a>. As
--   with <a>foldr1AVL</a>, it requires a non-empty tree, but instead of
--   treating the rightmost element as an initial value, it applies a
--   function to it (second function argument) and uses the result instead.
--   This allows a more flexible type for the main folding function (same
--   type as that used by <a>foldrAVL</a>). As with <a>foldrAVL</a> and
--   <a>foldr1AVL</a>, this function is lazy, so it's best not to use it
--   with functions that are strict in their second argument. See
--   <a>foldr2AVL'</a> for a strict version.
--   
--   Complexity: O(n)
foldr2AVL :: (e -> a -> a) -> (e -> a) -> AVL e -> a

-- | The strict version of <a>foldr2AVL</a>, which is useful for functions
--   which are strict in their second argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldr2AVL' :: (e -> a -> a) -> (e -> a) -> AVL e -> a

-- | The AVL equivalent of <a>foldl</a> on lists. This is a the lazy
--   version (as lazy as the folding function anyway). Using this version
--   with a function that is strict in it's first argument will result in
--   O(n) stack use. See <a>foldlAVL'</a> for a strict version.
--   
--   <pre>
--   foldlAVL f a avl = foldl f a (asListL avl)
--   </pre>
--   
--   For example, the <a>asListR</a> function could be defined..
--   
--   <pre>
--   asListR = foldlAVL (flip (:)) []
--   </pre>
--   
--   Complexity: O(n)
foldlAVL :: (a -> e -> a) -> a -> AVL e -> a

-- | The strict version of <a>foldlAVL</a>, which is useful for functions
--   which are strict in their first argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldlAVL' :: (a -> e -> a) -> a -> AVL e -> a

-- | The AVL equivalent of <a>foldl1</a> on lists. This is a the lazy
--   version (as lazy as the folding function anyway). Using this version
--   with a function that is strict in it's first argument will result in
--   O(n) stack use. See <a>foldl1AVL'</a> for a strict version.
--   
--   <pre>
--   foldl1AVL f avl = foldl1 f (asListL avl)
--   </pre>
--   
--   This function raises an error if the tree is empty.
--   
--   Complexity: O(n)
foldl1AVL :: (e -> e -> e) -> AVL e -> e

-- | The strict version of <a>foldl1AVL</a>, which is useful for functions
--   which are strict in their first argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldl1AVL' :: (e -> e -> e) -> AVL e -> e

-- | This fold is a hybrid between <a>foldlAVL</a> and <a>foldl1AVL</a>. As
--   with <a>foldl1AVL</a>, it requires a non-empty tree, but instead of
--   treating the leftmost element as an initial value, it applies a
--   function to it (second function argument) and uses the result instead.
--   This allows a more flexible type for the main folding function (same
--   type as that used by <a>foldlAVL</a>). As with <a>foldlAVL</a> and
--   <a>foldl1AVL</a>, this function is lazy, so it's best not to use it
--   with functions that are strict in their first argument. See
--   <a>foldl2AVL'</a> for a strict version.
--   
--   Complexity: O(n)
foldl2AVL :: (a -> e -> a) -> (e -> a) -> AVL e -> a

-- | The strict version of <a>foldl2AVL</a>, which is useful for functions
--   which are strict in their first argument. The advantage of this
--   version is that it reduces the stack use from the O(n) that the lazy
--   version gives (when used with strict functions) to O(log n).
--   
--   Complexity: O(n)
foldl2AVL' :: (a -> e -> a) -> (e -> a) -> AVL e -> a

-- | Flatten an AVL tree, preserving the ordering of the tree elements.
--   
--   Complexity: O(n)
flatten :: AVL e -> AVL e

-- | Similar to <a>flatten</a>, but the tree elements are reversed. This
--   function has higher constant factor overhead than <a>reverseAVL</a>.
--   
--   Complexity: O(n)
flatReverse :: AVL e -> AVL e

-- | Similar to <a>mapAVL</a>, but the resulting tree is flat. This
--   function has higher constant factor overhead than <a>mapAVL</a>.
--   
--   Complexity: O(n)
flatMap :: (a -> b) -> AVL a -> AVL b

-- | Same as <a>flatMap</a>, but the supplied function is applied strictly.
--   
--   Complexity: O(n)
flatMap' :: (a -> b) -> AVL a -> AVL b

-- | Uses the supplied combining comparison to sort list elements into
--   ascending order. Multiple occurences of the same element are
--   eliminated (they are combined in some way).
--   
--   Complexity: O(n.(log n))
genSortAscending :: (e -> e -> COrdering e) -> [e] -> [e]

-- | Uses the supplied combining comparison to sort list elements into
--   descending order. Multiple occurences of the same element are
--   eliminated (they are combined in some way).
--   
--   Complexity: O(n.(log n))
genSortDescending :: (e -> e -> COrdering e) -> [e] -> [e]


-- | <a>AVL</a> tree related test and verification utilities. The functions
--   defined here are not exported by the main <a>Data.Tree.AVL</a> module.
--   You need to import this module explicitly if you want to use any of
--   them.
module Data.Tree.AVL.Test.Utils

-- | Verify that a tree is height balanced and that the BF of each node is
--   correct.
--   
--   Complexity: O(n)
isBalanced :: AVL e -> Bool

-- | Verify that a tree is balanced and the BF of each node is correct.
--   Returns (Just height) if so, otherwise Nothing.
--   
--   Complexity: O(n)
checkHeight :: AVL e -> Maybe Int

-- | Verify that a tree is sorted.
--   
--   Complexity: O(n)
isSorted :: (e -> e -> Ordering) -> AVL e -> Bool

-- | Verify that a tree is sorted, height balanced and the BF of each node
--   is correct.
--   
--   Complexity: O(n)
isSortedOK :: (e -> e -> Ordering) -> AVL e -> Bool

-- | AVL Tree test data. Each element of a the list is a pair consisting of
--   a height, and list of all possible sorted trees of the same height,
--   paired with their sizes. The elements of each tree of size s are
--   0..s-1.
type TestTrees = [(Int, [(AVL Int, Int)])]

-- | All possible sorted AVL trees.
allAVL :: TestTrees

-- | Same as <a>allAVL</a>, but excluding the empty tree (of height 0).
allNonEmptyAVL :: TestTrees

-- | Returns the number of possible AVL trees of a given height.
--   
--   Behaves as if defined..
--   
--   <pre>
--   numTrees h = (\(_,xs) -&gt; length xs) (allAVL !! h)
--   </pre>
--   
--   and satisfies this recurrence relation..
--   
--   <pre>
--   numTrees 0 = 1
--   numTrees 1 = 1
--   numTrees h = (2*(numTrees (h-2)) + (numTrees (h-1))) * (numTrees (h-1)) 
--   </pre>
numTrees :: Int -> Integer

-- | Generates a flat AVL tree of n elements [0..n-1].
flatAVL :: Int -> AVL Int

-- | Apply the test function to each AVL tree in the TestTrees argument,
--   and report progress as test proceeds. The first two arguments of the
--   test function are tree height and size respectively.
exhaustiveTest :: (Int -> Int -> AVL Int -> Bool) -> TestTrees -> IO ()

-- | Detetermine the minimum number of elements in an AVL tree of given
--   height. This function satisfies this recurrence relation..
--   
--   <pre>
--   minElements 0 = 0
--   minElements 1 = 1
--   minElements h = 1 + minElements (h-1) + minElements (h-2)
--              -- = Some weird expression involving the golden ratio
--   </pre>
minElements :: Int -> Integer

-- | Detetermine the maximum number of elements in an AVL tree of given
--   height. This function satisfies this recurrence relation..
--   
--   <pre>
--   maxElements 0 = 0
--   maxElements h = 1 + 2 * maxElements (h-1) -- = 2^h-1
--   </pre>
maxElements :: Int -> Integer

-- | Infinite test tree. Used for test purposes for BinPath module. Value
--   at each node is the path to that node.
pathTree :: AVL Int


-- | This module defines functions for deleting elements from AVL trees and
--   related utilities.
module Data.Tree.AVL.Delete

-- | Delete the left-most element of a <i>non-empty</i> AVL tree. If the
--   tree is sorted this will be the least element. This function raises an
--   error if it's argument is an empty tree.
--   
--   Complexity: O(log n)
assertDelL :: AVL e -> AVL e

-- | Delete the right-most element of a <i>non-empty</i> AVL tree. If the
--   tree is sorted this will be the greatest element. This function raises
--   an error if it's argument is an empty tree.
--   
--   Complexity: O(log n)
assertDelR :: AVL e -> AVL e

-- | Try to delete the left-most element of a <i>non-empty</i> AVL tree. If
--   the tree is sorted this will be the least element. This function
--   returns <a>Nothing</a> if it's argument is an empty tree.
--   
--   Complexity: O(log n)
tryDelL :: AVL e -> Maybe (AVL e)

-- | Try to delete the right-most element of a <i>non-empty</i> AVL tree.
--   If the tree is sorted this will be the greatest element. This function
--   returns <a>Nothing</a> if it's argument is an empty tree.
--   
--   Complexity: O(log n)
tryDelR :: AVL e -> Maybe (AVL e)

-- | General purpose function for deletion of elements from a sorted AVL
--   tree. If a matching element is not found then this function returns
--   the original tree.
--   
--   Complexity: O(log n)
genDel :: (e -> Ordering) -> AVL e -> AVL e

-- | Functionally identical to <a>genDel</a>, but returns an identical tree
--   (one with all the nodes on the path duplicated) if the search fails.
--   This should probably only be used if you know the search will succeed.
--   
--   Complexity: O(log n)
genDelFast :: (e -> Ordering) -> AVL e -> AVL e

-- | This version only deletes the element if the supplied selector returns
--   <tt>(<a>Eq</a> <a>True</a>)</tt>. If it returns <tt>(<a>Eq</a>
--   <a>False</a>)</tt> or if no matching element is found then this
--   function returns the original tree.
--   
--   Complexity: O(log n)
genDelIf :: (e -> COrdering Bool) -> AVL e -> AVL e

-- | This version only deletes the element if the supplied selector returns
--   <tt>(<a>Eq</a> <a>Nothing</a>)</tt>. If it returns <tt>(<a>Eq</a>
--   (<a>Just</a> e))</tt> then the matching element is replaced by e. If
--   no matching element is found then this function returns the original
--   tree.
--   
--   Complexity: O(log n)
genDelMaybe :: (e -> COrdering (Maybe e)) -> AVL e -> AVL e

-- | Pop the left-most element from a non-empty AVL tree, returning the
--   popped element and the modified AVL tree. If the tree is sorted this
--   will be the least element. This function raises an error if it's
--   argument is an empty tree.
--   
--   Complexity: O(log n)
assertPopL :: AVL e -> (e, AVL e)

-- | Pop the right-most element from a non-empty AVL tree, returning the
--   popped element and the modified AVL tree. If the tree is sorted this
--   will be the greatest element. This function raises an error if it's
--   argument is an empty tree.
--   
--   Complexity: O(log n)
assertPopR :: AVL e -> (AVL e, e)

-- | Same as <a>assertPopL</a>, except this version returns <a>Nothing</a>
--   if it's argument is an empty tree.
--   
--   Complexity: O(log n)
tryPopL :: AVL e -> Maybe (e, AVL e)

-- | Same as <a>assertPopR</a>, except this version returns <a>Nothing</a>
--   if it's argument is an empty tree.
--   
--   Complexity: O(log n)
tryPopR :: AVL e -> Maybe (AVL e, e)

-- | General purpose function for popping elements from a sorted AVL tree.
--   An error is raised if a matching element is not found. The pair
--   returned by this function consists of the popped value and the
--   modified tree.
--   
--   Complexity: O(log n)
genAssertPop :: (e -> COrdering a) -> AVL e -> (a, AVL e)

-- | Similar to <tt>genPop</tt>, but this function returns <a>Nothing</a>
--   if the search fails.
--   
--   Complexity: O(log n)
genTryPop :: (e -> COrdering a) -> AVL e -> Maybe (a, AVL e)

-- | In this case the selector returns two values if a search succeeds. If
--   the second is <tt>(<a>Just</a> e)</tt> then the new value (<tt>e</tt>)
--   is substituted in the same place in the tree. If the second is
--   <a>Nothing</a> then the corresponding tree element is deleted. This
--   function raises an error if the search fails.
--   
--   Complexity: O(log n)
genAssertPopMaybe :: (e -> COrdering (a, Maybe e)) -> AVL e -> (a, AVL e)

-- | Similar to <a>genAssertPopMaybe</a>, but returns <a>Nothing</a> if the
--   search fails.
--   
--   Complexity: O(log n)
genTryPopMaybe :: (e -> COrdering (a, Maybe e)) -> AVL e -> Maybe (a, AVL e)

-- | A simpler version of <a>genAssertPopMaybe</a>. The corresponding
--   element is deleted if the second value returned by the selector is
--   <a>True</a>. If it's <a>False</a>, the original tree is returned. This
--   function raises an error if the search fails.
--   
--   Complexity: O(log n)
genAssertPopIf :: (e -> COrdering (a, Bool)) -> AVL e -> (a, AVL e)

-- | Similar to <tt>genPopIf</tt>, but returns <a>Nothing</a> if the search
--   fails.
--   
--   Complexity: O(log n)
genTryPopIf :: (e -> COrdering (a, Bool)) -> AVL e -> Maybe (a, AVL e)


-- | Functions for joining AVL trees.
module Data.Tree.AVL.Join

-- | Join two AVL trees. This is the AVL equivalent of (++).
--   
--   <pre>
--   asListL (l `join` r) = asListL l ++ asListL r
--   </pre>
--   
--   Complexity: O(log n), where n is the size of the larger of the two
--   trees.
join :: AVL e -> AVL e -> AVL e

-- | Concatenate a <i>finite</i> list of AVL trees. During construction of
--   the resulting tree the input list is consumed lazily, but it will be
--   consumed entirely before the result is returned.
--   
--   <pre>
--   asListL (concatAVL avls) = concatMap asListL avls
--   </pre>
--   
--   Complexity: Umm..Dunno. Uses a divide and conquer approach to splice
--   adjacent pairs of trees in the list recursively, until only one tree
--   remains. The complexity of each splice is proportional to the
--   difference in tree heights.
concatAVL :: [AVL e] -> AVL e

-- | Similar to <a>concatAVL</a>, except the resulting tree is flat. This
--   function evaluates the entire list of trees before constructing the
--   result.
--   
--   Complexity: O(n), where n is the total number of elements in the
--   resulting tree.
flatConcat :: [AVL e] -> AVL e


-- | An implementation of "The Zipper" for AVL trees. This can be used like
--   a functional pointer to a serial data structure which can be navigated
--   and modified, without having to worry about all those tricky tree
--   balancing issues. See JFP Vol.7 part 5 or ..
--   
--   <a>http://haskell.org/hawiki/TheZipper</a>
--   
--   Notes about efficiency:
--   
--   The functions defined here provide a useful way to achieve those
--   awkward operations which may not be covered by the rest of this
--   package. They're reasonably efficient (mostly O(log n) or better), but
--   zipper flexibility is bought at the expense of keeping path
--   information explicitly as a heap data structure rather than implicitly
--   on the stack. Since heap storage probably costs more, zipper
--   operations will are likely to incur higher constant factors than
--   equivalent non-zipper operations (if available).
--   
--   Some of the functions provided here may appear to be weird
--   combinations of functions from a more logical set of primitives. They
--   are provided because they are not really simple combinations of the
--   corresponding primitives. They are more efficient, so you should use
--   them if possible (e.g combining deleting with Zipper closing).
--   
--   Also, consider using the <a>BAVL</a> as a cheaper alternative if you
--   don't actually need to navigate the tree.
module Data.Tree.AVL.Zipper

-- | Abstract data type for a successfully opened AVL tree. All ZAVL's are
--   non-empty! A ZAVL can be tought of as a functional pointer to an AVL
--   tree element.
data ZAVL e

-- | Abstract data type for an unsuccessfully opened AVL tree. A PAVL can
--   be tought of as a functional pointer to the gap where the expected
--   element should be (but isn't). You can fill this gap using the
--   <a>fill</a> function, or fill and close at the same time using the
--   <a>fillClose</a> function.
data PAVL e

-- | Opens a non-empty AVL tree at the leftmost element. This function
--   raises an error if the tree is empty.
--   
--   Complexity: O(log n)
assertOpenL :: AVL e -> ZAVL e

-- | Opens a non-empty AVL tree at the rightmost element. This function
--   raises an error if the tree is empty.
--   
--   Complexity: O(log n)
assertOpenR :: AVL e -> ZAVL e

-- | Attempts to open a non-empty AVL tree at the leftmost element. This
--   function returns <a>Nothing</a> if the tree is empty.
--   
--   Complexity: O(log n)
tryOpenL :: AVL e -> Maybe (ZAVL e)

-- | Attempts to open a non-empty AVL tree at the rightmost element. This
--   function returns <a>Nothing</a> if the tree is empty.
--   
--   Complexity: O(log n)
tryOpenR :: AVL e -> Maybe (ZAVL e)

-- | Opens a sorted AVL tree at the element given by the supplied selector.
--   This function raises an error if the tree does not contain such an
--   element.
--   
--   Complexity: O(log n)
genAssertOpen :: (e -> Ordering) -> AVL e -> ZAVL e

-- | Attempts to open a sorted AVL tree at the element given by the
--   supplied selector. This function returns <a>Nothing</a> if there is no
--   such element.
--   
--   Note that this operation will still create a zipper path structure on
--   the heap (which is promptly discarded) if the search fails, and so is
--   potentially inefficient if failure is likely. In cases like this it
--   may be better to use <a>genOpenBAVL</a>, test for "fullness" using
--   <a>fullBAVL</a> and then convert to a <a>ZAVL</a> using
--   <a>fullBAVLtoZAVL</a>.
--   
--   Complexity: O(log n)
genTryOpen :: (e -> Ordering) -> AVL e -> Maybe (ZAVL e)

-- | Attempts to open a sorted AVL tree at the least element which is
--   greater than or equal, according to the supplied selector. This
--   function returns <a>Nothing</a> if the tree does not contain such an
--   element.
--   
--   Complexity: O(log n)
genTryOpenGE :: (e -> Ordering) -> AVL e -> Maybe (ZAVL e)

-- | Attempts to open a sorted AVL tree at the greatest element which is
--   less than or equal, according to the supplied selector. This function
--   returns _Nothing_ if the tree does not contain such an element.
--   
--   Complexity: O(log n)
genTryOpenLE :: (e -> Ordering) -> AVL e -> Maybe (ZAVL e)

-- | Returns <tt>(<a>Right</a> zavl)</tt> if the expected element was
--   found, <tt>(<a>Left</a> pavl)</tt> if the expected element was not
--   found. It's OK to use this function on empty trees.
--   
--   Complexity: O(log n)
genOpenEither :: (e -> Ordering) -> AVL e -> Either (PAVL e) (ZAVL e)

-- | Closes a Zipper.
--   
--   Complexity: O(log n)
close :: ZAVL e -> AVL e

-- | Essentially the same operation as <a>fill</a>, but the resulting
--   <a>ZAVL</a> is closed immediately.
--   
--   Complexity: O(log n)
fillClose :: e -> PAVL e -> AVL e

-- | Gets the current element of a Zipper.
--   
--   Complexity: O(1)
getCurrent :: ZAVL e -> e

-- | Overwrites the current element of a Zipper.
--   
--   Complexity: O(1)
putCurrent :: e -> ZAVL e -> ZAVL e

-- | Applies a function to the current element of a Zipper (lazily). See
--   also <a>applyCurrent'</a> for a strict version of this function.
--   
--   Complexity: O(1)
applyCurrent :: (e -> e) -> ZAVL e -> ZAVL e

-- | Applies a function to the current element of a Zipper strictly. See
--   also <a>applyCurrent</a> for a non-strict version of this function.
--   
--   Complexity: O(1)
applyCurrent' :: (e -> e) -> ZAVL e -> ZAVL e

-- | Moves one step left. This function raises an error if the current
--   element is already the leftmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
assertMoveL :: ZAVL e -> ZAVL e

-- | Moves one step right. This function raises an error if the current
--   element is already the rightmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
assertMoveR :: ZAVL e -> ZAVL e

-- | Attempts to move one step left. This function returns <a>Nothing</a>
--   if the current element is already the leftmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
tryMoveL :: ZAVL e -> Maybe (ZAVL e)

-- | Attempts to move one step right. This function returns <a>Nothing</a>
--   if the current element is already the rightmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
tryMoveR :: ZAVL e -> Maybe (ZAVL e)

-- | Inserts a new element to the immediate left of the current element.
--   
--   Complexity: O(1) average, O(log n) worst case.
insertL :: e -> ZAVL e -> ZAVL e

-- | Inserts a new element to the immediate right of the current element.
--   
--   Complexity: O(1) average, O(log n) worst case.
insertR :: ZAVL e -> e -> ZAVL e

-- | Inserts a new element to the immediate left of the current element and
--   then moves one step left (so the newly inserted element becomes the
--   current element).
--   
--   Complexity: O(1) average, O(log n) worst case.
insertMoveL :: e -> ZAVL e -> ZAVL e

-- | Inserts a new element to the immediate right of the current element
--   and then moves one step right (so the newly inserted element becomes
--   the current element).
--   
--   Complexity: O(1) average, O(log n) worst case.
insertMoveR :: ZAVL e -> e -> ZAVL e

-- | Fill the gap pointed to by a <a>PAVL</a> with the supplied element,
--   which becomes the current element of the resulting <a>ZAVL</a>. The
--   supplied filling element should be "equal" to the value used in the
--   search which created the <a>PAVL</a>.
--   
--   Complexity: O(1)
fill :: e -> PAVL e -> ZAVL e

-- | Deletes the current element and then closes the Zipper.
--   
--   Complexity: O(log n)
delClose :: ZAVL e -> AVL e

-- | Deletes the current element and moves one step left. This function
--   raises an error if the current element is already the leftmost
--   element.
--   
--   Complexity: O(1) average, O(log n) worst case.
assertDelMoveL :: ZAVL e -> ZAVL e

-- | Deletes the current element and moves one step right. This function
--   raises an error if the current element is already the rightmost
--   element.
--   
--   Complexity: O(1) average, O(log n) worst case.
assertDelMoveR :: ZAVL e -> ZAVL e

-- | Attempts to delete the current element and move one step right. This
--   function returns <a>Nothing</a> if the current element is already the
--   rightmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
tryDelMoveR :: ZAVL e -> Maybe (ZAVL e)

-- | Attempts to delete the current element and move one step left. This
--   function returns <a>Nothing</a> if the current element is already the
--   leftmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
tryDelMoveL :: ZAVL e -> Maybe (ZAVL e)

-- | Delete all elements to the left of the current element.
--   
--   Complexity: O(log n)
delAllL :: ZAVL e -> ZAVL e

-- | Delete all elements to the right of the current element.
--   
--   Complexity: O(log n)
delAllR :: ZAVL e -> ZAVL e

-- | Similar to <a>delAllL</a>, in that all elements to the left of the
--   current element are deleted, but this function also closes the tree in
--   the process.
--   
--   Complexity: O(log n)
delAllCloseL :: ZAVL e -> AVL e

-- | Similar to <a>delAllR</a>, in that all elements to the right of the
--   current element are deleted, but this function also closes the tree in
--   the process.
--   
--   Complexity: O(log n)
delAllCloseR :: ZAVL e -> AVL e

-- | Similar to <a>delAllCloseL</a>, but in this case the current element
--   and all those to the left of the current element are deleted.
--   
--   Complexity: O(log n)
delAllIncCloseL :: ZAVL e -> AVL e

-- | Similar to <a>delAllCloseR</a>, but in this case the current element
--   and all those to the right of the current element are deleted.
--   
--   Complexity: O(log n)
delAllIncCloseR :: ZAVL e -> AVL e

-- | Inserts a new AVL tree to the immediate left of the current element.
--   
--   Complexity: O(log n), where n is the size of the inserted tree.
insertTreeL :: AVL e -> ZAVL e -> ZAVL e

-- | Inserts a new AVL tree to the immediate right of the current element.
--   
--   Complexity: O(log n), where n is the size of the inserted tree.
insertTreeR :: ZAVL e -> AVL e -> ZAVL e

-- | Returns <a>True</a> if the current element is the leftmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
isLeftmost :: ZAVL e -> Bool

-- | Returns <a>True</a> if the current element is the rightmost element.
--   
--   Complexity: O(1) average, O(log n) worst case.
isRightmost :: ZAVL e -> Bool

-- | Counts the number of elements to the left of the current element (this
--   does not include the current element).
--   
--   Complexity: O(n), where n is the count result.
sizeL :: ZAVL e -> Int

-- | Counts the number of elements to the right of the current element
--   (this does not include the current element).
--   
--   Complexity: O(n), where n is the count result.
sizeR :: ZAVL e -> Int

-- | Counts the total number of elements in a ZAVL.
--   
--   Complexity: O(n)
sizeZAVL :: ZAVL e -> Int

-- | A <a>BAVL</a> is like a pointer reference to somewhere inside an
--   <a>AVL</a> tree. It may be either "full" (meaning it points to an
--   actual tree node containing an element), or "empty" (meaning it points
--   to the position in a tree where an element was expected but wasn't
--   found).
data BAVL e

-- | Search for an element in a <i>sorted</i> <a>AVL</a> tree using the
--   supplied selector. Returns a "full" <a>BAVL</a> if a matching element
--   was found, otherwise returns an "empty" <a>BAVL</a>.
--   
--   Complexity: O(log n)
genOpenBAVL :: (e -> Ordering) -> AVL e -> BAVL e

-- | Returns the original tree, extracted from the <a>BAVL</a>. Typically
--   you will not need this, as the original tree will still be in scope in
--   most cases.
--   
--   Complexity: O(1)
closeBAVL :: BAVL e -> AVL e

-- | Returns <a>True</a> if the <a>BAVL</a> is "full" (a corresponding
--   element was found).
--   
--   Complexity: O(1)
fullBAVL :: BAVL e -> Bool

-- | Returns <a>True</a> if the <a>BAVL</a> is "empty" (no corresponding
--   element was found).
--   
--   Complexity: O(1)
emptyBAVL :: BAVL e -> Bool

-- | Read the element value from a "full" <a>BAVL</a>. This function
--   returns <a>Nothing</a> if applied to an "empty" <a>BAVL</a>.
--   
--   Complexity: O(1)
tryReadBAVL :: BAVL e -> Maybe e

-- | Read the element value from a "full" <a>BAVL</a>. This function raises
--   an error if applied to an "empty" <a>BAVL</a>.
--   
--   Complexity: O(1)
readFullBAVL :: BAVL e -> e

-- | If the <a>BAVL</a> is "full", this function returns the original tree
--   with the corresponding element replaced by the new element (first
--   argument). If it's "empty" the original tree is returned with the new
--   element inserted.
--   
--   Complexity: O(log n)
pushBAVL :: e -> BAVL e -> AVL e

-- | If the <a>BAVL</a> is "full", this function returns the original tree
--   with the corresponding element deleted. If it's "empty" the original
--   tree is returned unmodified.
--   
--   Complexity: O(log n) (or O(1) for an empty <a>BAVL</a>)
deleteBAVL :: BAVL e -> AVL e

-- | Converts a "full" <a>BAVL</a> as a <a>ZAVL</a>. Raises an error if
--   applied to an "empty" <a>BAVL</a>.
--   
--   Complexity: O(log n)
fullBAVLtoZAVL :: BAVL e -> ZAVL e

-- | Converts an "empty" <a>BAVL</a> as a <a>PAVL</a>. Raises an error if
--   applied to a "full" <a>BAVL</a>.
--   
--   Complexity: O(log n)
emptyBAVLtoPAVL :: BAVL e -> PAVL e

-- | Converts a <a>BAVL</a> to either a <a>PAVL</a> or <a>ZAVL</a>
--   (depending on whether it is "empty" or "full").
--   
--   Complexity: O(log n)
anyBAVLtoEither :: BAVL e -> Either (PAVL e) (ZAVL e)


-- | Functions for splitting AVL trees.
module Data.Tree.AVL.Split

-- | Split an AVL tree from the Left. The <a>Int</a> argument n (n &gt;= 0)
--   specifies the split point. This function raises an error if n is
--   negative.
--   
--   If the tree size is greater than n the result is (Right (l,r)) where l
--   contains the leftmost n elements and r contains the remaining
--   rightmost elements (r will be non-empty).
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
splitAtL :: Int -> AVL e -> Either Int (AVL e, AVL e)

-- | Split an AVL tree from the Right. The <a>Int</a> argument n (n &gt;=
--   0) specifies the split point. This function raises an error if n is
--   negative.
--   
--   If the tree size is greater than n the result is (Right (l,r)) where r
--   contains the rightmost n elements and l contains the remaining
--   leftmost elements (l will be non-empty).
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
splitAtR :: Int -> AVL e -> Either Int (AVL e, AVL e)

-- | This is a simplified version of <a>splitAtL</a> which does not return
--   the remaining tree. The <a>Int</a> argument n (n &gt;= 0) specifies
--   the number of elements to take (from the left). This function raises
--   an error if n is negative.
--   
--   If the tree size is greater than n the result is (Right l) where l
--   contains the leftmost n elements.
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
takeL :: Int -> AVL e -> Either Int (AVL e)

-- | This is a simplified version of <a>splitAtR</a> which does not return
--   the remaining tree. The <a>Int</a> argument n (n &gt;= 0) specifies
--   the number of elements to take (from the right). This function raises
--   an error if n is negative.
--   
--   If the tree size is greater than n the result is (Right r) where r
--   contains the rightmost n elements.
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
takeR :: Int -> AVL e -> Either Int (AVL e)

-- | This is a simplified version of <a>splitAtL</a> which returns the
--   remaining tree only (rightmost elements). This function raises an
--   error if n is negative.
--   
--   If the tree size is greater than n the result is (Right r) where r
--   contains the remaining elements (r will be non-empty).
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
dropL :: Int -> AVL e -> Either Int (AVL e)

-- | This is a simplified version of <a>splitAtR</a> which returns the
--   remaining tree only (leftmost elements). This function raises an error
--   if n is negative.
--   
--   If the tree size is greater than n the result is (Right l) where l
--   contains the remaining elements (l will be non-empty).
--   
--   If the tree size is less than or equal to n then the result is (Left
--   s), where s is tree size.
--   
--   An empty tree will always yield a result of (Left 0).
--   
--   Complexity: O(n)
dropR :: Int -> AVL e -> Either Int (AVL e)

-- | Rotate an AVL tree one place left. This function pops the leftmost
--   element and pushes into the rightmost position. An empty tree yields
--   an empty tree.
--   
--   Complexity: O(log n)
rotateL :: AVL e -> AVL e

-- | Rotate an AVL tree one place right. This function pops the rightmost
--   element and pushes into the leftmost position. An empty tree yields an
--   empty tree.
--   
--   Complexity: O(log n)
rotateR :: AVL e -> AVL e

-- | Similar to <a>rotateL</a>, but returns the rotated element. This
--   function raises an error if applied to an empty tree.
--   
--   Complexity: O(log n)
popRotateL :: AVL e -> (e, AVL e)

-- | Similar to <a>rotateR</a>, but returns the rotated element. This
--   function raises an error if applied to an empty tree.
--   
--   Complexity: O(log n)
popRotateR :: AVL e -> (AVL e, e)

-- | Rotate an AVL tree left by n places. If s is the size of the tree then
--   ordinarily n should be in the range [0..s-1]. However, this function
--   will deliver a correct result for any n (n&lt;0 or n&gt;=s), the
--   actual rotation being given by (n `mod` s) in such cases. The result
--   of rotating an empty tree is an empty tree.
--   
--   Complexity: O(n)
rotateByL :: AVL e -> Int -> AVL e

-- | Rotate an AVL tree right by n places. If s is the size of the tree
--   then ordinarily n should be in the range [0..s-1]. However, this
--   function will deliver a correct result for any n (n&lt;0 or n&gt;=s),
--   the actual rotation being given by (n `mod` s) in such cases. The
--   result of rotating an empty tree is an empty tree.
--   
--   Complexity: O(n)
rotateByR :: AVL e -> Int -> AVL e

-- | Span an AVL tree from the left, using the supplied predicate. This
--   function returns a pair of trees (l,r), where l contains the leftmost
--   consecutive elements which satisfy the predicate. The leftmost element
--   of r (if any) is the first to fail the predicate. Either of the
--   resulting trees may be empty. Element ordering is preserved.
--   
--   Complexity: O(n), where n is the size of l.
spanL :: (e -> Bool) -> AVL e -> (AVL e, AVL e)

-- | Span an AVL tree from the right, using the supplied predicate. This
--   function returns a pair of trees (l,r), where r contains the rightmost
--   consecutive elements which satisfy the predicate. The rightmost
--   element of l (if any) is the first to fail the predicate. Either of
--   the resulting trees may be empty. Element ordering is preserved.
--   
--   Complexity: O(n), where n is the size of r.
spanR :: (e -> Bool) -> AVL e -> (AVL e, AVL e)

-- | This is a simplified version of <a>spanL</a> which does not return the
--   remaining tree The result is the leftmost consecutive sequence of
--   elements which satisfy the supplied predicate (which may be empty).
--   
--   Complexity: O(n), where n is the size of the result.
takeWhileL :: (e -> Bool) -> AVL e -> AVL e

-- | This is a simplified version of <a>spanL</a> which does not return the
--   tree containing the elements which satisfy the supplied predicate. The
--   result is a tree whose leftmost element is the first to fail the
--   predicate, starting from the left (which may be empty).
--   
--   Complexity: O(n), where n is the number of elements dropped.
dropWhileL :: (e -> Bool) -> AVL e -> AVL e

-- | This is a simplified version of <a>spanR</a> which does not return the
--   remaining tree The result is the rightmost consecutive sequence of
--   elements which satisfy the supplied predicate (which may be empty).
--   
--   Complexity: O(n), where n is the size of the result.
takeWhileR :: (e -> Bool) -> AVL e -> AVL e

-- | This is a simplified version of <a>spanR</a> which does not return the
--   tree containing the elements which satisfy the supplied predicate. The
--   result is a tree whose rightmost element is the first to fail the
--   predicate, starting from the right (which may be empty).
--   
--   Complexity: O(n), where n is the number of elements dropped.
dropWhileR :: (e -> Bool) -> AVL e -> AVL e

-- | Divide a sorted AVL tree into left and right sorted trees (l,r), such
--   that l contains all the elements less than or equal to according to
--   the supplied selector and r contains all the elements greater than
--   according to the supplied selector.
--   
--   Complexity: O(log n)
genForkL :: (e -> Ordering) -> AVL e -> (AVL e, AVL e)

-- | Divide a sorted AVL tree into left and right sorted trees (l,r), such
--   that l contains all the elements less than supplied selector and r
--   contains all the elements greater than or equal to the supplied
--   selector.
--   
--   Complexity: O(log n)
genForkR :: (e -> Ordering) -> AVL e -> (AVL e, AVL e)

-- | Similar to <a>genForkL</a> and <a>genForkR</a>, but returns any equal
--   element found (instead of incorporating it into the left or right tree
--   results respectively).
--   
--   Complexity: O(log n)
genFork :: (e -> COrdering a) -> AVL e -> (AVL e, Maybe a, AVL e)

-- | This is a simplified version of <a>genForkL</a> which returns a sorted
--   tree containing only those elements which are less than or equal to
--   according to the supplied selector. This function also has the synonym
--   <a>genDropGT</a>.
--   
--   Complexity: O(log n)
genTakeLE :: (e -> Ordering) -> AVL e -> AVL e

-- | A synonym for <a>genTakeLE</a>.
--   
--   Complexity: O(log n)
genDropGT :: (e -> Ordering) -> AVL e -> AVL e

-- | This is a simplified version of <a>genForkR</a> which returns a sorted
--   tree containing only those elements which are less than according to
--   the supplied selector. This function also has the synonym
--   <a>genDropGE</a>.
--   
--   Complexity: O(log n)
genTakeLT :: (e -> Ordering) -> AVL e -> AVL e

-- | A synonym for <a>genTakeLT</a>.
--   
--   Complexity: O(log n)
genDropGE :: (e -> Ordering) -> AVL e -> AVL e

-- | This is a simplified version of <a>genForkL</a> which returns a sorted
--   tree containing only those elements which are greater according to the
--   supplied selector. This function also has the synonym
--   <a>genDropLE</a>.
--   
--   Complexity: O(log n)
genTakeGT :: (e -> Ordering) -> AVL e -> AVL e

-- | A synonym for <a>genTakeGT</a>.
--   
--   Complexity: O(log n)
genDropLE :: (e -> Ordering) -> AVL e -> AVL e

-- | This is a simplified version of <a>genForkR</a> which returns a sorted
--   tree containing only those elements which are greater or equal to
--   according to the supplied selector. This function also has the synonym
--   <a>genDropLT</a>.
--   
--   Complexity: O(log n)
genTakeGE :: (e -> Ordering) -> AVL e -> AVL e

-- | A synonym for <a>genTakeGE</a>.
--   
--   Complexity: O(log n)
genDropLT :: (e -> Ordering) -> AVL e -> AVL e


-- | Functions for manipulating AVL trees which represent ordered sets
--   (I.E. <i>sorted</i> trees). Note that although many of these functions
--   work with a variety of different element types they all require that
--   elements are sorted according to the same criterion (such as a field
--   value in a record).
module Data.Tree.AVL.Set

-- | Uses the supplied combining comparison to evaluate the union of two
--   sets represented as sorted AVL trees. Whenever the combining
--   comparison is applied, the first comparison argument is an element of
--   the first tree and the second comparison argument is an element of the
--   second tree.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out. (Faster than Hedge union from Data.Set at any rate).
genUnion :: (e -> e -> COrdering e) -> AVL e -> AVL e -> AVL e

-- | Similar to <a>genUnion</a>, but the resulting tree does not include
--   elements in cases where the supplied combining comparison returns
--   <tt>(Eq Nothing)</tt>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genUnionMaybe :: (e -> e -> COrdering (Maybe e)) -> AVL e -> AVL e -> AVL e

-- | Uses the supplied combining comparison to evaluate the union of all
--   sets in a list of sets represented as sorted AVL trees. Behaves as if
--   defined..
--   
--   <pre>
--   genUnions ccmp avls = foldl' (<a>genUnion</a> ccmp) empty avls
--   </pre>
genUnions :: (e -> e -> COrdering e) -> [AVL e] -> AVL e

-- | Uses the supplied comparison to evaluate the difference between two
--   sets represented as sorted AVL trees. The expression..
--   
--   <pre>
--   genDifference cmp setA setB
--   </pre>
--   
--   .. is a set containing all those elements of <tt>setA</tt> which do
--   not appear in <tt>setB</tt>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genDifference :: (a -> b -> Ordering) -> AVL a -> AVL b -> AVL a

-- | Similar to <a>genDifference</a>, but the resulting tree also includes
--   those elements a' for which the combining comparison returns <tt>(Eq
--   (Just a'))</tt>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genDifferenceMaybe :: (a -> b -> COrdering (Maybe a)) -> AVL a -> AVL b -> AVL a

-- | The symmetric difference is the set of elements which occur in one set
--   or the other but <i>not both</i>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genSymDifference :: (e -> e -> Ordering) -> AVL e -> AVL e -> AVL e

-- | Uses the supplied combining comparison to evaluate the intersection of
--   two sets represented as sorted AVL trees.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersection :: (a -> b -> COrdering c) -> AVL a -> AVL b -> AVL c

-- | Similar to <a>genIntersection</a>, but the resulting tree does not
--   include elements in cases where the supplied combining comparison
--   returns <tt>(Eq Nothing)</tt>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersectionMaybe :: (a -> b -> COrdering (Maybe c)) -> AVL a -> AVL b -> AVL c

-- | Similar to <a>genIntersection</a>, but prepends the result to the
--   supplied list in left to right order. This is a (++) free function
--   which behaves as if defined:
--   
--   <pre>
--   genIntersectionToListL c setA setB cs = asListL (genIntersection c setA setB) ++ cs
--   </pre>
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersectionToListL :: (a -> b -> COrdering c) -> AVL a -> AVL b -> [c] -> [c]

-- | Applies <a>genIntersectionToListL</a> to the empty list.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersectionAsListL :: (a -> b -> COrdering c) -> AVL a -> AVL b -> [c]

-- | Similar to <a>genIntersectionToListL</a>, but the result does not
--   include elements in cases where the supplied combining comparison
--   returns <tt>(Eq Nothing)</tt>.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersectionMaybeToListL :: (a -> b -> COrdering (Maybe c)) -> AVL a -> AVL b -> [c] -> [c]

-- | Applies <a>genIntersectionMaybeToListL</a> to the empty list.
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIntersectionMaybeAsListL :: (a -> b -> COrdering (Maybe c)) -> AVL a -> AVL b -> [c]

-- | Uses the supplied comparison to test whether the first set is a subset
--   of the second, both sets being represented as sorted AVL trees. This
--   function returns True if any of the following conditions hold..
--   
--   <ul>
--   <li>The first set is empty (the empty set is a subset of any
--   set).</li>
--   <li>The two sets are equal.</li>
--   <li>The first set is a proper subset of the second set.</li>
--   </ul>
--   
--   Complexity: Not sure, but I'd appreciate it if someone could figure it
--   out.
genIsSubsetOf :: (a -> b -> Ordering) -> AVL a -> AVL b -> Bool


-- | Many of the functions defined by this package make use of generalised
--   comparison functions which return a variant of the Prelude
--   <a>Ordering</a> data type: <tt>Data.COrdering.COrdering</tt>. These
--   are refered to as "combining comparisons". (This is because they
--   combine "equal" values in some manner defined by the user.)
--   
--   The idea is that using this simple mechanism you can define many
--   practical and useful variations of tree (or general set) operations
--   from a few generic primitives, something that would not be so easy
--   using plain <a>Ordering</a> comparisons (overloaded or otherwise).
--   
--   Functions which involve searching a tree really only require a single
--   argument function which takes the current tree element value as
--   argument and returns an <a>Ordering</a> or
--   <tt>Data.COrdering.COrdering</tt> to direct the next stage of the
--   search down the left or right sub-trees (or stop at the current
--   element). For documentation purposes, these functions are called
--   "selectors" throughout this library. Typically a selector will be
--   obtained by partially applying the appropriate combining comparison
--   with the value or key being searched for. For example..
--   
--   <pre>
--   mySelector :: Int -&gt; Ordering               Tree elements are Ints
--   or..
--   mySelector :: (key,val) -&gt; COrdering val    Tree elements are (key,val) pairs
--   </pre>
--   
--   Please read the notes in the <a>Data.Tree.AVL.Types</a> module
--   documentation too.
module Data.Tree.AVL

-- | Convert a <tt>Data.Set.Set</tt> (from the base package Data.Set
--   module) to a sorted AVL tree. Elements and element ordering are
--   preserved (ascending order is left to right).
--   
--   Complexity: O(n)
set2AVL :: Set a -> AVL a

-- | Convert a <i>sorted</i> AVL tree to a <tt>Data.Set.Set</tt> (from the
--   base package Data.Set module). Elements and element ordering are
--   preserved.
--   
--   Complexity: O(n)
avl2Set :: AVL a -> Set a

-- | Convert a <tt>Data.Map.Map</tt> (from the base package Data.Map
--   module) to a sorted (by key) AVL tree. Elements and element ordering
--   are preserved (ascending order is left to right).
--   
--   Complexity: O(n)
map2AVL :: Map key val -> AVL (key, val)

-- | Convert a <i>sorted</i> (by key) AVL tree to a <tt>Data.Map.Map</tt>
--   (from the base package Data.Map module). Elements and element ordering
--   are preserved.
--   
--   Complexity: O(n)
avl2Map :: AVL (key, val) -> Map key val
instance Traversable AVL
instance Functor AVL
instance (Read e) => Read (AVL e)
instance (Show e) => Show (AVL e)
instance (Ord e) => Ord (AVL e)
instance (Eq e) => Eq (AVL e)


-- | This module provides an AVL tree based clone of the base package
--   Data.Set.
--   
--   There are some differences though..
--   
--   <ul>
--   <li><a>size</a> is O(n), not O(1)</li>
--   <li>The showTree and showTreeWith functions are not implemented.</li>
--   <li>The complexities of
--   <a>isSubsetOf</a>,<a>isProperSubsetOf</a>,<a>union</a>,<a>intersection</a>,<a>difference</a>
--   are unknown (because my maths isn't good enough to figure it out), but
--   are probably no worse than the originals.</li>
--   <li>Conversion functions <a>toTree</a>, <a>unsafeFromTree</a>,
--   <a>toStdSet</a>, <a>fromStdSet</a>. have been added.</li>
--   </ul>
module Data.Set.AVL

-- | A set of values <tt>a</tt>.
data Set a

-- | <i>O(?)</i>. See <a>difference</a>.
(\\) :: (Ord a) => Set a -> Set a -> Set a

-- | <i>O(1)</i>. Is this the empty set?
null :: Set a -> Bool

-- | <i>O(n)</i>. The number of elements in the set.
size :: Set a -> Int

-- | <i>O(log n)</i>. Is the element in the set?
member :: (Ord a) => a -> Set a -> Bool

-- | <i>O(?)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: (Ord a) => Set a -> Set a -> Bool

-- | <i>O(?)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: (Ord a) => Set a -> Set a -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: Set a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: a -> Set a

-- | <i>O(log n)</i>. Insert an element in a set. If the set already
--   contains an element equal to the given value, it is replaced with the
--   new value.
insert :: (Ord a) => a -> Set a -> Set a

-- | <i>O(log n)</i>. Delete an element from a set.
delete :: (Ord a) => a -> Set a -> Set a

-- | <i>O(?)</i>. The union of two sets, preferring the first set when
--   equal elements are encountered.
union :: (Ord a) => Set a -> Set a -> Set a

-- | The union of a list of sets: (<tt><a>unions</a> == <tt>foldl'</tt>
--   <a>union</a> <a>empty</a></tt>).
unions :: (Ord a) => [Set a] -> Set a

-- | <i>O(?)</i>. Difference of two sets.
difference :: (Ord a) => Set a -> Set a -> Set a

-- | <i>O(?)</i>. The intersection of two sets.
intersection :: (Ord a) => Set a -> Set a -> Set a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
filter :: (Ord a) => (a -> Bool) -> Set a -> Set a

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: (Ord a) => (a -> Bool) -> Set a -> (Set a, Set a)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> x set</tt>) is a
--   pair <tt>(set1,set2)</tt> where all elements in <tt>set1</tt> are
--   lower than <tt>x</tt> and all elements in <tt>set2</tt> larger than
--   <tt>x</tt>. <tt>x</tt> is not found in neither <tt>set1</tt> nor
--   <tt>set2</tt>.
split :: (Ord a) => a -> Set a -> (Set a, Set a)

-- | <i>O(log n)</i>. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
splitMember :: (Ord a) => a -> Set a -> (Set a, Bool, Set a)

-- | <i>O(n*log n)</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b

-- | <i>O(n)</i>. The identity
--   
--   <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, works only when
--   <tt>f</tt> is monotonic. <i>The precondition is not checked.</i>
--   Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls] 
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (a -> b) -> Set a -> Set b

-- | <i>O(n)</i>. Fold over the elements of a set in an unspecified order.
fold :: (a -> b -> b) -> b -> Set a -> b

-- | <i>O(log n)</i>. The minimal element of a set.
findMin :: Set a -> a

-- | <i>O(log n)</i>. The maximal element of a set.
findMax :: Set a -> a

-- | <i>O(log n)</i>. Delete the minimal element.
deleteMin :: Set a -> Set a

-- | <i>O(log n)</i>. Delete the maximal element.
deleteMax :: Set a -> Set a

-- | <i>O(log n)</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Set a -> (a, Set a)

-- | <i>O(log n)</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Set a -> (a, Set a)

-- | <i>O(n)</i>. The elements of a set.
elems :: Set a -> [a]

-- | <i>O(n)</i>. Convert the set to a list of elements.
toList :: Set a -> [a]

-- | <i>O(n*log n)</i>. Create a set from a list of elements.
fromList :: (Ord a) => [a] -> Set a

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: Set a -> [a]

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: (Eq a) => [a] -> Set a

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: [a] -> Set a

-- | <i>O(n)</i>. Convert an AVL tree based Set (as provided by this
--   module) to a Data.Set.Set.
toStdSet :: Set a -> Set a

-- | <i>O(n)</i>. Convert a Data.Set.Set to an AVL tree based Set (as
--   provided by this module).
fromStdSet :: Set a -> Set a

-- | <i>O(1)</i>. Convert an AVL tree based Set (as provided by this
--   module) to a sorted AVL tree.
toTree :: Set a -> AVL a

-- | <i>O(1)</i>. Convert a <i>sorted</i> AVL tree to an AVL tree based Set
--   (as provided by this module). This function does not check the input
--   AVL tree is sorted.
unsafeFromTree :: AVL a -> Set a

-- | <i>O(n)</i>. Test if the internal set structure is valid.
valid :: (Ord a) => Set a -> Bool

-- | Obsolete equivalent of <a>empty</a>.
emptySet :: Set a

-- | Obsolete equivalent of <a>fromList</a>.
mkSet :: (Ord a) => [a] -> Set a

-- | Obsolete equivalent of <a>elems</a>.
setToList :: Set a -> [a]

-- | Obsolete equivalent of <a>singleton</a>.
unitSet :: a -> Set a

-- | Obsolete equivalent of <a>member</a>.
elementOf :: (Ord a) => a -> Set a -> Bool

-- | Obsolete equivalent of <a>null</a>.
isEmptySet :: Set a -> Bool

-- | Obsolete equivalent of <a>size</a>.
cardinality :: Set a -> Int

-- | Obsolete equivalent of <a>unions</a>.
unionManySets :: (Ord a) => [Set a] -> Set a

-- | Obsolete equivalent of <a>difference</a>.
minusSet :: (Ord a) => Set a -> Set a -> Set a

-- | Obsolete equivalent of <a>map</a>.
mapSet :: (Ord a, Ord b) => (b -> a) -> Set b -> Set a

-- | Obsolete equivalent of <a>intersection</a>.
intersect :: (Ord a) => Set a -> Set a -> Set a

-- | Obsolete equivalent of <tt><a>flip</a> <a>insert</a></tt>.
addToSet :: (Ord a) => Set a -> a -> Set a

-- | Obsolete equivalent of <tt><a>flip</a> <a>delete</a></tt>.
delFromSet :: (Ord a) => Set a -> a -> Set a
instance (Data a, Ord a) => Data (Set a)
instance Typeable1 Set
instance (Ord a) => Monoid (Set a)
instance (Show a) => Show (Set a)
instance (Ord a) => Ord (Set a)
instance (Eq a) => Eq (Set a)


-- | This module provides an AVL tree based clone of the base package
--   Data.Map.
--   
--   There are some differences though..
--   
--   <ul>
--   <li><a>size</a> is O(n), not O(1). Consequently, indexed access is
--   disabled.</li>
--   <li>The showTree and showTreeWith functions are not implemented.</li>
--   <li>Some other functions are not yet implemented.</li>
--   </ul>
module Data.Map.AVL

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
(!) :: (Ord k) => Map k a -> k -> a

-- | <i>O(n+m)</i>. See <a>difference</a>.
(\\) :: (Ord k) => Map k a -> Map k b -> Map k a

-- | <i>O(1)</i>. Is the map empty?
null :: Map k a -> Bool

-- | <i>O(n)</i>. The number of elements in the map.
size :: Map k a -> Int

-- | <i>O(log n)</i>. Is the key a member of the map?
member :: (Ord k) => k -> Map k a -> Bool

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
lookup :: (Monad m, Ord k) => k -> Map k a -> m a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not in the map.
findWithDefault :: (Ord k) => a -> k -> Map k a -> a

-- | <i>O(1)</i>. The empty map.
empty :: Map k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: k -> a -> Map k a

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
insert :: (Ord k) => k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert with a combining function.
insertWith :: (Ord k) => (a -> a -> a) -> k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. Insert with a combining function.
insertWithKey :: (Ord k) => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>insertLookupWithKey</a> f k x
--   map</tt>) is a pair where the first element is equal to
--   (<tt><a>lookup</a> k map</tt>) and the second element equal to
--   (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   TODO: only one traversal. This requires fiddling with AVL.Push.
insertLookupWithKey :: (Ord k) => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: (Ord k) => k -> Map k a -> Map k a

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
adjust :: (Ord k) => (a -> a) -> k -> Map k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <a>Map</a>. In
--   short : <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k
--   m)</tt>
alter :: (Ord k) => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
adjustWithKey :: (Ord k) => (k -> a -> a) -> k -> Map k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>update</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
update :: (Ord k) => (a -> Maybe a) -> k -> Map k a -> Map k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k
--   map</tt>) updates the value <tt>x</tt> at <tt>k</tt> (if it is in the
--   map). If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted.
--   If it is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the
--   new value <tt>y</tt>.
updateWithKey :: (Ord k) => (k -> a -> Maybe a) -> k -> Map k a -> Map k a

-- | <i>O(log n)</i>. Lookup and update.
--   
--   TODO: only one traversal. This requires fiddling with AVL.Push.
updateLookupWithKey :: (Ord k) => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)

-- | <i>O(n+m)</i>. The expression (<tt><a>union</a> t1 t2</tt>) takes the
--   left-biased union of <tt>t1</tt> and <tt>t2</tt>. It prefers
--   <tt>t1</tt> when duplicate keys are encountered, i.e.
--   (<tt><a>union</a> == <a>unionWith</a> <a>const</a></tt>). The
--   implementation uses the efficient <i>hedge-union</i> algorithm.
--   Hedge-union is more efficient on (bigset <a>union</a> smallset)?
union :: (Ord k) => Map k a -> Map k a -> Map k a

-- | <i>O(n+m)</i>. Union with a combining function.
unionWith :: (Ord k) => (a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | <i>O(n+m)</i>. Union with a combining function.
unionWithKey :: (Ord k) => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | The union of a list of maps: (<tt><a>unions</a> ==
--   <tt>Prelude.foldl</tt> <a>union</a> <a>empty</a></tt>).
unions :: (Ord k) => [Map k a] -> Map k a

-- | The union of a list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <tt>Prelude.foldl</tt> (<a>unionWith</a>
--   f) <a>empty</a></tt>).
unionsWith :: (Ord k) => (a -> a -> a) -> [Map k a] -> Map k a

-- | <i>O(n+m)</i>. Difference of two maps.
difference :: (Ord k) => Map k a -> Map k b -> Map k a

-- | <i>O(n+m)</i>. Difference with a combining function.
differenceWith :: (Ord k) => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: (Ord k) => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a

-- | <i>O(n+m)</i>. Intersection of two maps. The values in the first map
--   are returned, i.e. (<tt><a>intersection</a> m1 m2 ==
--   <a>intersectionWith</a> <a>const</a> m1 m2</tt>).
intersection :: (Ord k) => Map k a -> Map k b -> Map k a

-- | <i>O(n+m)</i>. Intersection with a combining function.
intersectionWith :: (Ord k) => (a -> b -> c) -> Map k a -> Map k b -> Map k c

-- | <i>O(n+m)</i>. Intersection with a combining function. Intersection is
--   more efficient on (bigset <a>intersection</a> smallset)
intersectionWithKey :: (Ord k) => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c

-- | <i>O(n)</i>. Map a function over all values in the map.
map :: (a -> b) -> Map k a -> Map k b

-- | <i>O(n)</i>. Map a function over all values in the map.
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b

-- | <i>O(n)</i>. The function <a>mapAccum</a> threads an accumulating
--   argument through the map in ascending order of keys.
mapAccum :: (Ord k) => (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)

-- | <i>O(n)</i>. Fold the values in the map, such that <tt><a>fold</a> f z
--   == <tt>Prelude.foldr</tt> f z . <a>elems</a></tt>. For example,
--   
--   <pre>
--   elems map = fold (:) [] map
--   </pre>
fold :: (a -> b -> b) -> b -> Map k a -> b
foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b

-- | <i>O(n)</i>. Convert to a list of values.
elems :: Map k a -> [a]

-- | <i>O(n)</i>. Convert to a list of keys.
keys :: Map k a -> [k]

-- | <i>O(n)</i>. The set of all keys of the map.
keysSet :: Map k a -> Set k

-- | <i>O(n)</i>. Apply a function to each element of a set and return the
--   resulting map.
liftKeysSet :: (k -> b) -> Set k -> Map k b

-- | <i>O(n)</i>. Convert to a list of key/value pairs.
assocs :: Map k a -> [(k, a)]

-- | <i>O(1)</i>. Convert a <i>sorted</i> AVL tree to an AVL tree based Set
--   (as provided by this module). This function does not check the input
--   AVL tree is sorted.
unsafeFromTree :: AVL (k, a) -> Map k a

-- | <i>O(1)</i>. Convert an AVL tree based Set (as provided by this
--   module) to a sorted AVL tree.
toTree :: Map k a -> AVL (k, a)

-- | <i>O(n)</i>. Convert to a list of key/value pairs.
toList :: Map k a -> [(k, a)]
fromList :: (Ord k) => [(k, a)] -> Map k a

-- | <i>O(n*log n)</i>. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
fromListWith :: (Ord k) => (a -> a -> a) -> [(k, a)] -> Map k a

-- | <i>O(n*log n)</i>. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWithKey</a>.
fromListWithKey :: (Ord k) => (k -> a -> a -> a) -> [(k, a)] -> Map k a

-- | <i>O(n)</i>. Convert to a list of key/value pairs.
toAscList :: Map k a -> [(k, a)]

-- | <i>O(n)</i>. Build a map from an ascending list in linear time. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: (Eq k) => [(k, a)] -> Map k a

-- | <i>O(n)</i>. Build a map from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
fromAscListWith :: (Eq k) => (a -> a -> a) -> [(k, a)] -> Map k a

-- | <i>O(n)</i>. Build a map from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
fromAscListWithKey :: (Eq k) => (k -> a -> a -> a) -> [(k, a)] -> Map k a

-- | <i>O(n)</i>. Build a map from an ascending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
fromDistinctAscList :: [(k, a)] -> Map k a

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filter :: (Ord k) => (a -> Bool) -> Map k a -> Map k a

-- | <i>O(n)</i>. Filter all keys/values that satisfy the predicate.
filterWithKey :: (Ord k) => (k -> a -> Bool) -> Map k a -> Map k a

-- | <i>O(n)</i>. partition the map according to a predicate. The first map
--   contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate.
partition :: (Ord k) => (a -> Bool) -> Map k a -> (Map k a, Map k a)

-- | <i>O(n)</i>. partition the map according to a predicate. The first map
--   contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate.
partitionWithKey :: (Ord k) => (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)

-- | <i>O(log n)</i>. The expression (<tt><a>split</a> x set</tt>) is a
--   pair <tt>(set1,set2)</tt> where all elements in <tt>set1</tt> are
--   lower than <tt>x</tt> and all elements in <tt>set2</tt> larger than
--   <tt>x</tt>. <tt>x</tt> is not found in neither <tt>set1</tt> nor
--   <tt>set2</tt>.
split :: (Ord k) => k -> Map k a -> (Map k a, Map k a)

-- | <i>O(log n)</i>. The expression (<tt><a>splitLookup</a> k map</tt>)
--   splits a map just like <a>split</a> but also returns <tt><a>lookup</a>
--   k map</tt>.
splitLookup :: (Ord k) => k -> Map k a -> (Map k a, Maybe a, Map k a)

-- | <i>O(n+m)</i>. This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool

-- | <i>O(n+m)</i>. The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>)
--   returns <a>True</a> if all keys in <tt>t1</tt> are in tree
--   <tt>t2</tt>, and when <tt>f</tt> returns <a>True</a> when applied to
--   their respective values. For example, the following expressions are
--   all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])
--   </pre>
isSubmapOfBy :: (Ord k) => (a -> b -> Bool) -> Map k a -> Map k b -> Bool

-- | <i>O(log n)</i>. The minimal key of the map.
findMin :: Map k a -> (k, a)

-- | <i>O(log n)</i>. The minimal key of the map.
findMax :: Map k a -> (k, a)

-- | <i>O(log n)</i>. Delete the minimal key.
deleteMin :: Map k a -> Map k a

-- | <i>O(log n)</i>. Delete the minimal key.
deleteMax :: Map k a -> Map k a

-- | <i>O(log n)</i>. Delete and find the minimal element.
deleteFindMin :: Map k a -> ((k, a), Map k a)

-- | <i>O(log n)</i>. Delete and find the maximal element.
deleteFindMax :: Map k a -> ((k, a), Map k a)
instance Functor (Map k)
instance (Ord k) => Monoid (Map k a)
instance Foldable (Map k)
instance (Show k, Show a) => Show (Map k a)
instance (Ord k, Ord a) => Ord (Map k a)
instance (Eq k, Eq a) => Eq (Map k a)
instance Typeable2 Map


-- | This module defines a class framework for collection types. It
--   provides:
--   
--   <ul>
--   <li>Classes for the most common type of collections</li>
--   <li><i>View</i> types to change the type of a collection, so it
--   implements other classes. This allows to use types for purposes that
--   they are not originally designed for. (eg. <a>ElemsView</a>)</li>
--   <li>A few generic functions for handling collections.</li>
--   <li>Infix (operator) version of common functions.</li>
--   </ul>
--   
--   Should you need a more precise documentation,
--   <a>Data.Collections.Properties</a> lists laws that implementations are
--   entitled to assume.
--   
--   The classes defined in this module are intended to give hints about
--   performance. eg. if a function has a <tt><a>Map</a> c k v</tt>
--   context, this indicates that the function will perform better if
--   <tt>c</tt> has an efficitent lookup function.
--   
--   This class framework is based on ideas found in Simon Peyton Jones,
--   "<i>Bulk types with class</i>".
--   <a>http://research.microsoft.com/Users/simonpj/Papers/collections.ps.gz</a>
--   
--   Another inspiration source are the examples of MPTC and fuctional
--   dependencies in Oleg Kiselyov's many articles posted to the haskell
--   mailing list.
--   
--   This module name-clashes with a lot of Prelude functions, subsuming
--   those. The user is encouraged to import Prelude hiding the clashing
--   functions. Alternatively, it can be imported <tt>qualified</tt>.
module Data.Collections

-- | Class of collection with unobservable elements. It is the dual of the
--   <a>Foldable</a> class.
class Unfoldable c i | c -> i
insert :: (Unfoldable c i) => i -> c -> c
empty :: (Unfoldable c i) => c
singleton :: (Unfoldable c i) => i -> c
insertMany :: (Unfoldable c i, Foldable c' i) => c' -> c -> c
insertManySorted :: (Unfoldable c i, Foldable c' i) => c' -> c -> c

-- | Class of collection types.
class (Foldable c a, Unfoldable c a) => Collection c a | c -> a
filter :: (Collection c a) => (a -> Bool) -> c -> c

-- | Class of map-like types. (aka. for sparse associative types).
--   
--   In opposition of Indexed, Map supports unexisting value for some
--   indices.
class (Monoid c) => Map c k a | c -> k a
delete :: (Map c k a) => k -> c -> c
member :: (Map c k a) => k -> c -> Bool
union :: (Map c k a) => c -> c -> c
intersection :: (Map c k a) => c -> c -> c
difference :: (Map c k a) => c -> c -> c
isSubset :: (Map c k a) => c -> c -> Bool
lookup :: (Map c k a, Monad m) => k -> c -> m a
alter :: (Map c k a) => (Maybe a -> Maybe a) -> k -> c -> c
insertWith :: (Map c k a) => (a -> a -> a) -> k -> a -> c -> c
fromFoldableWith :: (Map c k a, Foldable l (k, a)) => (a -> a -> a) -> l -> c
foldGroups :: (Map c k a, Foldable l (k, b)) => (b -> a -> a) -> a -> l -> c
mapWithKey :: (Map c k a) => (k -> a -> a) -> c -> c
unionWith :: (Map c k a) => (a -> a -> a) -> c -> c -> c
intersectionWith :: (Map c k a) => (a -> a -> a) -> c -> c -> c
differenceWith :: (Map c k a) => (a -> a -> Maybe a) -> c -> c -> c
isSubmapBy :: (Map c k a) => (a -> a -> Bool) -> c -> c -> Bool

-- | The expression <tt>(<a>lookupWithDefault</a> def k map)</tt> returns
--   the value at key <tt>k</tt> or returns <tt>def</tt> when the key is
--   not in the map.
lookupWithDefault :: (Map c k a) => a -> k -> c -> a

-- | Union of many (key) sets, with combining function
unionsWith :: (Unfoldable s i, Map s k a, Foldable cs s) => (a -> a -> a) -> cs -> s

-- | Same as <a>intersectionWith</a>, but with a more general type.
intersectionWith' :: (Functor m, Map (m (O a b c)) k (O a b c)) => (a -> b -> c) -> m a -> m b -> m c

-- | Same as <a>differenceWith</a>, but with a more general type.
differenceWith' :: (Functor m, Map (m (O a b c)) k (O a b c)) => (a -> b -> Maybe c) -> m a -> m b -> m c
mapWithKey' :: (Functor m, Map (m (Either a b)) k (Either a b)) => (k -> a -> b) -> m a -> m b

-- | Infix version of <a>index</a>, with arguments swapped.
(!) :: (Indexed c k v) => c -> k -> v

-- | Class for set-like collection types. A set is really a map with no
--   value associated to the keys, so Set just states so.
class (Map c k ()) => Set c k | c -> k
haddock_candy :: (Set c k) => c -> k

-- | Union of many (key) sets.
unions :: (Unfoldable s i, Map s k a, Foldable cs s) => cs -> s

-- | Tells whether a key is not a member of the keySet.
notMember :: (Map c k a) => k -> c -> Bool

-- | Infix version of <a>difference</a>. Difference of two (key) sets.
(\\) :: (Map c k a) => c -> c -> c

-- | Class of sequential-access types. In addition of the <a>Collection</a>
--   services, it provides deconstruction and concatenation.
class (Monoid c, Collection c a) => Sequence c a
take :: (Sequence c a) => Int -> c -> c
drop :: (Sequence c a) => Int -> c -> c
splitAt :: (Sequence c a) => Int -> c -> (c, c)
reverse :: (Sequence c a) => c -> c
front :: (Sequence c a, Monad m) => c -> m (a, c)
back :: (Sequence c a, Monad m) => c -> m (c, a)
cons :: (Sequence c a) => a -> c -> c
snoc :: (Sequence c a) => c -> a -> c
isPrefix :: (Sequence c a, Eq a) => c -> c -> Bool
head :: (Sequence s a) => s -> a
tail :: (Sequence s a) => s -> s

-- | Concatenate two sequences.
append :: (Sequence c a) => c -> c -> c

-- | The concatenation of all the elements of a container of sequences.
concat :: (Sequence s a, Foldable t s) => t -> s

-- | Map a function over all the elements of a container and concatenate
--   the resulting sequences.
concatMap :: (Sequence s b, Foldable t a) => (a -> s) -> t -> s

-- | Infix version of <a>cons</a>: add an element to the left end of a
--   sequence. Mnemonic: a triangle with the single element at the pointy
--   end.
(<|) :: (Sequence c i) => i -> c -> c

-- | Infix version of <a>snoc</a>: add an element to the right end of a
--   sequence. Mnemonic: a triangle with the single element at the pointy
--   end.
(|>) :: (Sequence c i) => c -> i -> c

-- | Infix verion of <a>append</a>. Concatenate two sequences.
(><) :: (Sequence c a) => c -> c -> c
class (Ix k, Foldable c (k, v), Indexed c k v) => Array c k v | c -> k v
bounds :: (Array c k v) => c -> (k, k)
array :: (Array c k v, Foldable l (k, v)) => (k, k) -> l -> c

-- | Class of indexed types. The collection is <tt>dense</tt>: there is no
--   way to <i>remove</i> an element nor for lookup to return <a>not
--   found</a>.
--   
--   In practice however, most shallow collection types will instanciate
--   this class in addition of <a>Map</a>, and leave the responsibility of
--   failure to the caller.
class Indexed c k v | c -> k v
index :: (Indexed c k v) => k -> c -> v
adjust :: (Indexed c k v) => (v -> v) -> k -> c -> c
inDomain :: (Indexed c k v) => k -> c -> Bool
(//) :: (Indexed c k v, Foldable l (k, v)) => c -> l -> c
accum :: (Indexed c k v, Foldable l (k, v')) => (v -> v' -> v) -> c -> l -> c

-- | Conversion from a Foldable to a Collection.
fromFoldable :: (Foldable f a, Collection c' a) => f -> c'

-- | Conversion from a Foldable to a Collection, with the <i>unchecked</i>
--   precondition that the input is sorted
fromAscFoldable :: (Foldable f a, Collection c' a) => f -> c'

-- | Converts a list into a collection.
fromList :: (Collection c a) => [a] -> c

-- | Specialized version of fromFoldableWith for lists.
fromListWith :: (Map c k a) => (a -> a -> a) -> [(k, a)] -> c

-- | Converts a list into a collection, with the precondition that the
--   input is sorted.
fromAscList :: (Collection c a) => [a] -> c

-- | <a>View</a> to the keys of a dictionnary
newtype KeysView m k v
KeysView :: m -> KeysView m k v
fromKeysView :: KeysView m k v -> m

-- | <a>View</a> to the elements of a dictionnary
newtype ElemsView m k v
ElemsView :: m -> ElemsView m k v
fromElemsView :: ElemsView m k v -> m
withKeys :: (Collection m (k, v)) => T (KeysView m k v) -> T m
withElems :: (Collection m (k, v)) => T (ElemsView m k v) -> T m

-- | General-purpose finite sequences.
data Seq a :: * -> *

-- | A map of integers to values <tt>a</tt>.
data IntMap a :: * -> *

-- | A set of integers.
data IntSet :: *
type StdSet = Set
type StdMap = Map
type AvlSet = Set
type AvlMap = Map
type RangedSet = RSet
instance (Map m k v) => Map (KeysView m k v) k v
instance (Monoid m, Map m k v) => Monoid (KeysView m k v)
instance (Unfoldable m (k, v)) => Unfoldable (ElemsView m k v) (k, v)
instance (Foldable m (k, v)) => Foldable (ElemsView m k v) v
instance (Unfoldable m (k, v)) => Unfoldable (KeysView m k v) (k, v)
instance (Foldable m (k, v)) => Foldable (KeysView m k v) k
instance (DiscreteOrdered a) => Set (RangedSet a) a
instance (DiscreteOrdered a) => Map (RangedSet a) a ()
instance (DiscreteOrdered a) => Unfoldable (RangedSet a) a
instance (Enum a) => Map (Set a) a ()
instance (Enum a) => Set (Set a) a
instance (Enum a) => Collection (Set a) a
instance (Enum a) => Unfoldable (Set a) a
instance (Enum a) => Foldable (Set a) a
instance Map IntSet Int ()
instance Set IntSet Int
instance Collection IntSet Int
instance Unfoldable IntSet Int
instance Foldable IntSet Int
instance (Ord a) => SortingCollection (Set a) a
instance (Ord a) => Map (Set a) a ()
instance (Ord a) => Set (Set a) a
instance (Ord a) => Collection (Set a) a
instance (Ord a) => Unfoldable (Set a) a
instance Foldable (Set a) a
instance (Ord a) => SortingCollection (Set a) a
instance (Ord a) => Map (Set a) a ()
instance (Ord a) => Set (Set a) a
instance (Ord a) => Collection (Set a) a
instance (Ord a) => Unfoldable (Set a) a
instance Foldable (Set a) a
instance Map (IntMap a) Int a
instance Indexed (IntMap a) Int a
instance Collection (IntMap a) (Int, a)
instance Unfoldable (IntMap a) (Int, a)
instance Foldable (IntMap a) (Int, a)
instance (Ord k) => SortingCollection (Map k a) (k, a)
instance (Ord k) => Map (Map k a) k a
instance (Ord k) => Indexed (Map k a) k a
instance (Ord k) => Collection (Map k a) (k, a)
instance (Ord k) => Unfoldable (Map k a) (k, a)
instance Foldable (Map k a) (k, a)
instance (Ord k) => SortingCollection (Map k a) (k, a)
instance (Ord k) => Map (Map k a) k a
instance (Ord k) => Indexed (Map k a) k a
instance (Ord k) => Collection (Map k a) (k, a)
instance (Ord k) => Unfoldable (Map k a) (k, a)
instance Foldable (Map k a) (k, a)
instance (Ix i) => Array (Array i e) i e
instance (Ix i) => Indexed (Array i e) i e
instance Indexed ByteString Int Word8
instance Sequence ByteString Word8
instance Collection ByteString Word8
instance Unfoldable ByteString Word8
instance Foldable ByteString Word8
instance Indexed ByteString Int Word8
instance Sequence ByteString Word8
instance Collection ByteString Word8
instance Unfoldable ByteString Word8
instance Foldable ByteString Word8
instance Indexed (Seq a) Int a
instance Sequence (Seq a) a
instance Collection (Seq a) a
instance Foldable (Seq a) a
instance Unfoldable (Seq a) a
instance Indexed [a] Int a
instance Sequence [a] a
instance Collection [a] a
instance Unfoldable [a] a


-- | The purpose of this module is twofold:
--   
--   <ol>
--   <li>Check instances of the classes in the collection framework.</li>
--   <li>Give those classes more formal semantics.</li>
--   </ol>
--   
--   Therefore, this acts as a contract between the collections users and
--   implementers.
--   
--   Each function in this module returns a list of <tt>(property_name,
--   propterty)</tt> for a given class (or set of classes). Each function
--   is parameterized on the type of the collection to check, so a value
--   witnessing the type must be passed. This value is guaranteed not to be
--   evaluated, so it can always be <a>undefined</a>.
--   
--   These properties allow to verify, with a high degree of confidence,
--   that instances of the classes defined in <tt>Data.Collections</tt>
--   satisfy the prescribed properties.
--   
--   You will note that properties depend on the <a>Eq</a> class. This
--   means that
--   
--   <ul>
--   <li>properties are verified up-to <a>Eq</a> equivalence.</li>
--   <li>Infinite structures and other <tt>bottom</tt>s are not testable
--   with this module.</li>
--   </ul>
--   
--   For convenience, this module provides an instance of
--   <tt><a>Arbitrary</a> (<a>Maybe</a> a)</tt>.
module Data.Collections.Properties

-- | unfoldable_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>singleton</i></i></li>
--   </ul>
--   
--   <pre>
--   singleton a == insert a empty
--   </pre>
--   
--   <ul>
--   <li><i><i>insertMany</i></i></li>
--   </ul>
--   
--   <pre>
--   insertMany l c == Foldable.foldr insert c l
--   </pre>
--   
--   <ul>
--   <li><i><i>insertManySorted</i></i></li>
--   </ul>
--   
--   <pre>
--   insertManySorted l c == Foldable.foldr insert c l
--      where l = List.sort l0
--   </pre>
unfoldable_properties :: (Arbitrary c, Arbitrary a, Ord a, Show a, Show c, Eq c, Eq a, Unfoldable c a) => c -> [(Property, String)]

-- | foldable_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>size</i></i></li>
--   </ul>
--   
--   <pre>
--   size c == foldr (const (+1)) 0 c
--   </pre>
--   
--   <ul>
--   <li><i><i>null</i></i></li>
--   </ul>
--   
--   <pre>
--   null c &lt;==&gt; all (const False) c
--   </pre>
--   
--   <ul>
--   <li><i><i>isSingleton</i></i></li>
--   </ul>
--   
--   <pre>
--   isSingleton c &lt;==&gt; size c == 1
--   </pre>
--   
--   <ul>
--   <li><i><i>eq_elem</i></i></li>
--   </ul>
--   
--   <pre>
--   c1 == c2 ==&gt; elem x c1 == elem x c2 -- note that the order of folding is not enforced, and that the converse is not true
--   </pre>
foldable_properties :: (Arbitrary c, Arbitrary a, Show a, Show c, Eq c, Eq a, Foldable c a) => c -> [(Property, String)]

-- | collection_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>collection</i></i></li>
--   </ul>
--   
--   <pre>
--   foldr insert empty c == c
--   </pre>
--   
--   <ul>
--   <li><i><i>empty</i></i></li>
--   </ul>
--   
--   <pre>
--   null empty
--   </pre>
--   
--   <ul>
--   <li><i><i>insert1</i></i></li>
--   </ul>
--   
--   <pre>
--   a `elem` (insert a c)                                 -- insert puts the element in the collection
--   </pre>
--   
--   <ul>
--   <li><i><i>insert2</i></i></li>
--   </ul>
--   
--   <pre>
--   a /= a' ==&gt; (a' `elem` c &lt;==  a' `elem` (insert a c)) -- insert does not insert other elements
--   </pre>
--   
--   <ul>
--   <li><i><i>insert3</i></i></li>
--   </ul>
--   
--   <pre>
--   let c' = insert a c in x `elem` c &amp;&amp; y `elem` c ==&gt; x `elem` c' || y `elem` c' -- insert alters at most one element
--   </pre>
--   
--   <ul>
--   <li><i><i>filter</i></i></li>
--   </ul>
--   
--   <pre>
--   (a `elem` filter f c) &lt;==&gt; ((a `elem` c) &amp;&amp; f a)
--   </pre>
collection_properties :: (Arbitrary c, Arbitrary i, Show i, Show c, Eq c, Eq i, Collection c i) => c -> [(Property, String)]

-- | map_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>alter</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k (alter f k m) == f (lookup k m)
--   </pre>
--   
--   <ul>
--   <li><i><i>mapWithKey</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k (mapWithKey f m) == fmap (f k) (lookup k m)
--   </pre>
--   
--   <ul>
--   <li><i><i>unionWith</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k (unionWith f m1 m2) == case (lookup k m1, lookup k m2) of
--      (Nothing,Nothing) -&gt; Nothing
--      (Just x, Nothing) -&gt; Just x
--      (Nothing,Just x)  -&gt; Just x
--      (Just x, Just y)  -&gt; Just (f x y)
--   </pre>
--   
--   <ul>
--   <li><i><i>intersectionWith</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k (intersectionWith f m1 m2) == case (lookup k m1, lookup k m2) of
--      (Just x, Just y) -&gt; Just (f x y)
--      _ -&gt; Nothing
--   </pre>
--   
--   <ul>
--   <li><i><i>differenceWith</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k (differenceWith f m1 m2) == case (lookup k m1, lookup k m2) of
--      (Just x, Nothing) -&gt; Just x
--      (Just x, Just y)  -&gt; f x y
--      (Nothing, _)      -&gt; Nothing
--   </pre>
--   
--   <ul>
--   <li><i><i>isSubmapBy</i></i></li>
--   </ul>
--   
--   <pre>
--   isSubmapBy f m1 m2 &lt;==&gt; differenceWith (\x y-&gt;if f x y then Nothing else Just v) m1 m2 == mempty
--   </pre>
--   
--   <ul>
--   <li><i><i>insertWith</i></i></li>
--   </ul>
--   
--   <pre>
--   insertWith f k a m == alter (\x -&gt; Just $ case x of {Nothing-&gt;a;Just a' -&gt; f a a'}) k m
--   </pre>
--   
--   <ul>
--   <li><i><i>fromFoldableWith</i></i></li>
--   </ul>
--   
--   <pre>
--   fromFoldableWith f l == foldr (uncurry (insertWith f)) mempty l
--   </pre>
--   
--   <ul>
--   <li><i><i>delete</i></i></li>
--   </ul>
--   
--   <pre>
--   delete k m == alter (const Nothing) k m
--   </pre>
--   
--   <ul>
--   <li><i><i>member</i></i></li>
--   </ul>
--   
--   <pre>
--   member k m &lt;==&gt; isJust (lookup k m)
--   </pre>
--   
--   <ul>
--   <li><i><i>union</i></i></li>
--   </ul>
--   
--   <pre>
--   union m1 m2 == unionWith const m1 m2
--   </pre>
--   
--   <ul>
--   <li><i><i>intersection</i></i></li>
--   </ul>
--   
--   <pre>
--   intersection m1 m2 == intersectionWith const m1 m2 
--   </pre>
--   
--   <ul>
--   <li><i><i>difference</i></i></li>
--   </ul>
--   
--   <pre>
--   difference m1 m2 == differenceWith (\_ _ -&gt; Nothing) m1 m2
--   </pre>
--   
--   <ul>
--   <li><i><i>subset</i></i></li>
--   </ul>
--   
--   <pre>
--   isSubset m1 m2 &lt;==&gt; isSubmapBy (\_ _ -&gt; True) m1 m2
--   </pre>
--   
--   <ul>
--   <li><i><i>mempty</i></i></li>
--   </ul>
--   
--   <pre>
--   lookup k mempty == Nothing
--   </pre>
--   
--   <ul>
--   <li><i><i>mappend</i></i></li>
--   </ul>
--   
--   <pre>
--   mappend m1 m2 == union m1 m2
--   </pre>
--   
--   <ul>
--   <li><i><i>eq_lookup</i></i></li>
--   </ul>
--   
--   <pre>
--   c1 == c2 ==&gt; lookup x c1 == lookup x c2 -- should really be: c1 == c2 &lt;==&gt; forall x. lookup x c1 == lookup x c2
--   </pre>
map_properties :: (Arbitrary m, Arbitrary k, Arbitrary v, Show k, Show v, Show m, Eq m, Eq v, Map m k v) => m -> [(Property, String)]

-- | map_unfold_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>mempty</i></i></li>
--   </ul>
--   
--   <pre>
--   mempty == empty
--   </pre>
--   
--   <ul>
--   <li><i><i>insert</i></i></li>
--   </ul>
--   
--   <pre>
--   insert (k,v) m == insertWith (\x _ -&gt; x) k v m
--   </pre>
map_unfold_properties :: (Arbitrary m, Arbitrary k, Arbitrary v, Show k, Show v, Show m, Eq m, Eq v, Eq k, Map m k v, Collection m (k, v)) => m -> [(Property, String)]

-- | set_unfold_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>mempty</i></i></li>
--   </ul>
--   
--   <pre>
--   mempty == empty
--   </pre>
--   
--   <ul>
--   <li><i><i>insert</i></i></li>
--   </ul>
--   
--   <pre>
--   insert k m == insertWith (\x _-&gt;x) k () m
--   </pre>
set_unfold_properties :: (Arbitrary m, Arbitrary k, Show k, Show m, Eq m, Eq k, Map m k (), Unfoldable m k) => m -> [(Property, String)]

-- | map_fold_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>foldable</i></i></li>
--   </ul>
--   
--   <pre>
--   maybeToList (lookup k m) == map snd (filter ((== k) . fst) (toList m))
--   </pre>
--   
--   <ul>
--   <li><i><i>size</i></i></li>
--   </ul>
--   
--   <pre>
--   sizeExcept (alter f k m) == sizeExcept m
--     where sizeExcept m = size m - maybe 0 (const 1) (lookup k m)
--   </pre>
map_fold_properties :: (Arbitrary m, Arbitrary k, Arbitrary v, Show k, Show v, Show m, Eq m, Eq v, Eq k, Map m k v, Collection m (k, v)) => m -> [(Property, String)]

-- | set_fold_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>foldable</i></i></li>
--   </ul>
--   
--   <pre>
--   maybeToList (lookup k m) == map (const ()) (filter (== k) (toList m))
--   </pre>
--   
--   <ul>
--   <li><i><i>size</i></i></li>
--   </ul>
--   
--   <pre>
--   sizeExcept (alter f k m) == sizeExcept m
--     where sizeExcept m = size m - maybe 0 (const 1) (lookup k m)
--   </pre>
set_fold_properties :: (Arbitrary m, Arbitrary k, Show k, Show m, Eq m, Eq k, Map m k (), Foldable m k) => m -> [(Property, String)]

-- | indexed_map_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>domain</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` m &lt;==&gt; k `member` m
--   </pre>
--   
--   <ul>
--   <li><i><i>index</i></i></li>
--   </ul>
--   
--   <pre>
--   case lookup k m of {Just x -&gt; x == index k m; _ -&gt; True}
--   </pre>
indexed_map_properties :: (Arbitrary m, Arbitrary k, Arbitrary v, Show k, Show v, Show m, Eq m, Eq v, Map m k v, Indexed m k v) => m -> [(Property, String)]

-- | sequence_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>fold0</i></i></li>
--   </ul>
--   
--   <pre>
--   foldMap f empty == mempty
--   </pre>
--   
--   <ul>
--   <li><i><i>fold1</i></i></li>
--   </ul>
--   
--   <pre>
--   foldMap f (x &lt;| s) == f x `mappend` foldMap f s
--   </pre>
--   
--   <ul>
--   <li><i><i>fold2</i></i></li>
--   </ul>
--   
--   <pre>
--   foldMap f (s |&gt; x) == foldMap f s `mappend` f x
--   </pre>
--   
--   <ul>
--   <li><i><i>fold3</i></i></li>
--   </ul>
--   
--   <pre>
--   foldMap f (s &gt;&lt; t) == foldMap f s `mappend` foldMap f t
--   </pre>
--   
--   <ul>
--   <li><i><i>front0</i></i></li>
--   </ul>
--   
--   <pre>
--   front empty == Nothing
--   </pre>
--   
--   <ul>
--   <li><i><i>front1</i></i></li>
--   </ul>
--   
--   <pre>
--   front (x &lt;| s) == Just (x,s)
--   </pre>
--   
--   <ul>
--   <li><i><i>front2</i></i></li>
--   </ul>
--   
--   <pre>
--   front (s |&gt; x) == case front s of {Nothing -&gt; Just (x, empty); Just (x',s') -&gt; Just (x', s' |&gt; x)}
--   </pre>
--   
--   <ul>
--   <li><i><i>front3</i></i></li>
--   </ul>
--   
--   <pre>
--   front (s &gt;&lt; t) == case front s of {Nothing -&gt; front t;         Just (x',s') -&gt; Just (x', s' &gt;&lt; t)}
--   </pre>
--   
--   <ul>
--   <li><i><i>back0</i></i></li>
--   </ul>
--   
--   <pre>
--   back empty == Nothing
--   </pre>
--   
--   <ul>
--   <li><i><i>back1</i></i></li>
--   </ul>
--   
--   <pre>
--   back (s |&gt; x) == Just (s,x)
--   </pre>
--   
--   <ul>
--   <li><i><i>back2</i></i></li>
--   </ul>
--   
--   <pre>
--   back (x &lt;| s) == case back s of {Nothing -&gt; Just (empty, x); Just (s',x') -&gt; Just (x &lt;| s', x')}
--   </pre>
--   
--   <ul>
--   <li><i><i>back3</i></i></li>
--   </ul>
--   
--   <pre>
--   back (t &gt;&lt; s) == case back s of {Nothing -&gt; back t;          Just (s',x') -&gt; Just (t &gt;&lt; s', x')}
--   </pre>
--   
--   <ul>
--   <li><i><i>drop1</i></i></li>
--   </ul>
--   
--   <pre>
--   drop 0     s == s
--   </pre>
--   
--   <ul>
--   <li><i><i>drop2</i></i></li>
--   </ul>
--   
--   <pre>
--   n&gt;0 ==&gt; drop (n+1) s == case front (drop n s) of Nothing -&gt; empty; Just (_,s') -&gt; s'
--   </pre>
--   
--   <ul>
--   <li><i><i>take1</i></i></li>
--   </ul>
--   
--   <pre>
--   take 0     s == empty
--   </pre>
--   
--   <ul>
--   <li><i><i>take2</i></i></li>
--   </ul>
--   
--   <pre>
--   n&gt;0 ==&gt; take (n+1) s == case front s of Nothing -&gt; empty; Just (x,s') -&gt; x &lt;| take n s'
--   </pre>
--   
--   <ul>
--   <li><i><i>reverse</i></i></li>
--   </ul>
--   
--   <pre>
--   foldMap f (reverse s) == getDual (foldMap (Dual . f) s)
--   </pre>
--   
--   <ul>
--   <li><i><i>mempty</i></i></li>
--   </ul>
--   
--   <pre>
--   mempty == empty
--   </pre>
--   
--   <ul>
--   <li><i><i>eq_fold</i></i></li>
--   </ul>
--   
--   <pre>
--   s1 == s2 ==&gt; foldMap f s1 == foldMap f s2
--   </pre>
sequence_properties :: (Arbitrary s, Arbitrary a, Show s, Show a, Eq s, Eq a, Sequence s a) => s -> [(Property, String)]

-- | indexed_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>adjust</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` m ==&gt; index k (adjust f k m) == f (index k m)
--   </pre>
indexed_properties :: (Arbitrary m, Arbitrary k, Arbitrary v, Show k, Show v, Show m, Eq m, Eq v, Indexed m k v) => m -> [(Property, String)]

-- | indexed_sequence_properties returns the following properties:
--   
--   <ul>
--   <li><i><i>domain</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` s &lt;==&gt; k &gt;= 0 &amp;&amp; k &lt; size s
--   </pre>
--   
--   <ul>
--   <li><i><i>left1</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` s ==&gt; index (k+1)      (x &lt;| s) == index k s
--   </pre>
--   
--   <ul>
--   <li><i><i>left2</i></i></li>
--   </ul>
--   
--   <pre>
--   index 0          (x &lt;| s) == x
--   </pre>
--   
--   <ul>
--   <li><i><i>right1</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` s ==&gt; index k          (s |&gt; x) == index k s
--   </pre>
--   
--   <ul>
--   <li><i><i>right2</i></i></li>
--   </ul>
--   
--   <pre>
--   index (size s)   (s |&gt; x) == x
--   </pre>
--   
--   <ul>
--   <li><i><i>append1</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` t ==&gt; index (k+size s) (s &gt;&lt; t) == index k t
--   </pre>
--   
--   <ul>
--   <li><i><i>append2</i></i></li>
--   </ul>
--   
--   <pre>
--   k `inDomain` s ==&gt; index k          (s &gt;&lt; t) == index k s
--   </pre>
indexed_sequence_properties :: (Arbitrary s, Arbitrary a, Show s, Show a, Eq s, Eq a, Sequence s a, Indexed s Int a) => s -> [(Property, String)]
instance Show (a -> b)

module Data.Map.List

-- | View a list (actually any <a>Sequence</a>) of <tt>(key,value)</tt>
--   pairs as a <a>Map</a> collection.
--   
--   This allows to feed sequences into algorithms that require a map
--   without building a full-fledged map. Most of the time this will be
--   used only when the parameter list is known to be very small, such that
--   conversion to a Map would be to costly.
newtype AssocList s k v
AssocList :: s -> AssocList s k v
instance (Ord k, Sequence c (k, v), Monoid (AssocList c k v)) => Map (AssocList c k v) k v
instance (Ord k, Sequence c (k, v)) => Monoid (AssocList c k v)
instance (Ord k, Sequence c (k, v)) => Indexed (AssocList c k v) k v
instance (Ord k, Sequence c (k, v)) => Unfoldable (AssocList c k v) (k, v)
instance (Ord k, Sequence c (k, v)) => Collection (AssocList c k v) (k, v)
instance (Sequence c (k, v)) => Foldable (AssocList c k v) (k, v)
instance (Show l) => Show (AssocList l k v)
instance (Eq c, Eq k, Eq v, Foldable c (k, v)) => Eq (AssocList c k v)
instance Typeable3 AssocList

module Data.Set.List

-- | View a list of as a <a>Set</a> collection.
--   
--   This allows to feed sequences into algorithms that require a Set
--   without building a full-fledged Set. Most of the time this will be
--   used only when the parameter list is known to be very small, such that
--   conversion to a Set would be to costly.
newtype SetList s
SetList :: s -> SetList s
fromSetList :: SetList s -> s
instance (Eq a) => Map (SetList [a]) a ()
instance (Eq a) => Collection (SetList [a]) a
instance (Eq a) => Unfoldable (SetList [a]) a
instance (Eq a) => Monoid (SetList [a])
instance (Eq a) => Set (SetList [a]) a
instance Foldable (SetList [a]) a
instance (Show l) => Show (SetList l)
instance Typeable1 SetList
instance (Eq s, Eq a, Foldable s a) => Eq (SetList s)


-- | Note: performance is currently rather bad. See the benchmark
--   directory. Please contribute :)
module Data.Trie

-- | A Trie with key elements of type <tt>k</tt> (keys of type
--   <tt>[k]</tt>) and values of type <tt>v</tt>. Note that the type is not
--   opaque: user can pattern match on it and construct and Trie value.
--   This is because there is no non-trivial invariant to preserve.
data Trie s k v
Trie :: !Maybe v -> !Map k (Trie s k v) -> Trie s k v
value :: Trie s k v -> !Maybe v
children :: Trie s k v -> !Map k (Trie s k v)
(!) :: (Foldable s k, Ord k) => Trie s k v -> s -> v

-- | Is the trie empty ?
null :: Trie s k v -> Bool
member :: (Foldable s k, Ord k) => s -> Trie s k v -> Bool
lookup :: (Foldable s k, Monad m, Ord k) => s -> Trie s k v -> m v

-- | <tt>prefixLookup k p</tt> returns a sequence of all <tt>(k',v)</tt>
--   pairs, such that <tt>k</tt> is a prefix of <tt>k'</tt>. The sequence
--   is sorted by lexicographic order of keys.
prefixLookup :: (Ord k, Sequence s k, Sequence result (s, v)) => s -> Trie s k v -> result

-- | The empty trie.
empty :: (Ord k) => Trie s k v

-- | The singleton trie.
singleton :: (Ord k, Foldable s k) => s -> v -> Trie s k v
insert :: (Foldable s k, Ord k) => s -> v -> Trie s k v -> Trie s k v
insertWith :: (Foldable s k, Ord k) => (v -> v -> v) -> s -> v -> Trie s k v -> Trie s k v
alter :: (Foldable s k, Ord k) => (Maybe v -> Maybe v) -> s -> Trie s k v -> Trie s k v

-- | Combining two tries. The first shadows the second.
union :: (Ord k) => Trie s k v -> Trie s k v -> Trie s k v

-- | Combining two tries. If the two define the same key, the specified
--   combining function is used.
unionWith :: (Ord k) => (v -> v -> v) -> Trie s k v -> Trie s k v -> Trie s k v
difference :: (Ord k) => Trie s k v -> Trie s k v -> Trie s k v
differenceWith :: (Ord k) => (v -> v -> Maybe v) -> Trie s k v -> Trie s k v -> Trie s k v
intersection :: (Ord k) => Trie s k v -> Trie s k v -> Trie s k v

-- | Combining two tries. If the two tries define the same key, the
--   specified combining function is used.
intersectionWith :: (Ord k) => (v -> v -> v) -> Trie s k v -> Trie s k v -> Trie s k v
retypeKeys :: Trie s1 k v -> Trie s2 k v
fromAscList :: (Sequence s k, Ord k) => [(s, v)] -> Trie s k v
fromList :: (Sequence s k, Ord k) => [(s, v)] -> Trie s k v
fromListWith :: (Sequence s k, Ord k) => (v -> v -> v) -> [(s, v)] -> Trie s k v
toList :: (Sequence s k, Ord k) => Trie s k v -> [(s, v)]
filter :: (Ord k, Sequence s k) => (v -> Bool) -> Trie s k v -> Trie s k v
isSubmapOfBy :: (Ord k) => (v -> v -> Bool) -> Trie s k v -> Trie s k v -> Bool

-- | An upwards accumulation on the trie.
upwards :: (Ord k) => (Trie s k v -> Trie s k v) -> Trie s k v -> Trie s k v

-- | A downwards accumulation on the trie.
downwards :: (Ord k) => (Trie s k v -> Trie s k v) -> Trie s k v -> Trie s k v

-- | Return the prefix of the trie satisfying <tt>f</tt>.
takeWhile :: (Ord k) => (Trie s k v -> Bool) -> Trie s k v -> Trie s k v

-- | Return the prefix of the trie satisfying <tt>f</tt> on all values
--   present.
takeWhile' :: (Ord k) => (v -> Bool) -> Trie s k v -> Trie s k v

-- | Return the fringe of the trie (the trie composed of only the leaf
--   nodes).
fringe :: (Ord k) => Trie s k v -> Trie s k v
toTree :: k -> Trie s k v -> Tree (k, Maybe v)
instance (Eq k, Eq v) => Eq (Trie s k v)
instance (Ord k) => Monoid (Trie s k v)
instance (Show k, Show v) => Show (Trie [k] k v)
instance (Ord k, Foldable s k) => Indexed (Trie s k v) s v
instance (Ord k, Sequence s k) => Map (Trie s k v) s v
instance (Ord k, Sequence s k) => Collection (Trie s k v) (s, v)
instance (Ord k, Sequence s k) => Unfoldable (Trie s k v) (s, v)
instance (Sequence s k) => Foldable (Trie s k v) (s, v)
instance Foldable (Trie s k)
instance Typeable3 Trie
