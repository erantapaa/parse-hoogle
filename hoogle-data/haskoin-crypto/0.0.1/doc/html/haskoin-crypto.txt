-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of Bitcoin cryptographic primitives.
--   
--   This package provides the elliptic curve cryptography required for
--   creating and validating bitcoin transactions. It also provides SHA-256
--   and RIPEMD-160 hashing functions.
@package haskoin-crypto
@version 0.0.1


-- | QuickCheck Arbitrary instances for Haskoin.Crypto types.
module Network.Haskoin.Crypto.Arbitrary

-- | Generate an arbitrary compressed private key
genPrvKeyC :: Gen PrvKey

-- | Generate an arbitrary uncompressed private key
genPrvKeyU :: Gen PrvKey
instance Arbitrary Signature
instance Arbitrary Address
instance Arbitrary PubKey
instance Arbitrary PrvKey
instance Arbitrary Point
instance Arbitrary CheckSum32
instance RingMod n => Arbitrary (Ring n)


-- | This package provides the elliptic curve cryptography required for
--   creating and validating bitcoin transactions. It also provides SHA-256
--   and RIPEMD-160 hashing functions.
module Network.Haskoin.Crypto

-- | Elliptic curve public key type. Two constructors are provided for
--   creating compressed and uncompressed public keys from a Point. The use
--   of compressed keys is preferred as it produces shorter keys without
--   compromising security. Uncompressed keys are supported for backwards
--   compatibility.
data PubKey

-- | Compressed public key
PubKey :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Uncompressed public key
PubKeyU :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Returns True if the public key is valid. This will check if the public
--   key point lies on the curve.
isValidPubKey :: PubKey -> Bool

-- | Returns True if the public key is uncompressed
isPubKeyU :: PubKey -> Bool

-- | Derives a public key from a private key. This function will preserve
--   information on key compression (PrvKey becomes PubKey and PrvKeyU
--   becomes PubKeyU)
derivePubKey :: PrvKey -> PubKey

-- | Computes an Address value from a public key
pubKeyAddr :: PubKey -> Address

-- | Add a public key to a private key defined by its Hash256 value. This
--   will transform the private key into a public key and add the
--   respective public key points together. This is provided as a helper
--   for BIP32 wallet implementations. This function fails for uncompressed
--   keys and returns Nothing if the private key value is &gt;= than the
--   order of the curve N.
addPubKeys :: PubKey -> Hash256 -> Maybe PubKey

-- | Elliptic curve private key type. Two constructors are provided for
--   creating compressed or uncompressed private keys. Compression
--   information is stored in private key WIF formats and needs to be
--   preserved to generate the correct addresses from the corresponding
--   public key.
data PrvKey

-- | Compressed private key
PrvKey :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Uncompressed private key
PrvKeyU :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Returns True if the private key is valid. This will check if the
--   integer value representing the private key is greater than 0 and
--   smaller than the curve order N.
isValidPrvKey :: Integer -> Bool

-- | Builds a compressed private key from an Integer value. Returns Nothing
--   if the Integer would not produce a valid private key. For security,
--   the Integer needs to be generated from a random source with sufficient
--   entropy.
makePrvKey :: Integer -> Maybe PrvKey

-- | Builds an uncompressed private key from an Integer value. Returns
--   Nothing if the Integer would not produce a valid private key. For
--   security, the Integer needs to be generated from a random source with
--   sufficient entropy.
makePrvKeyU :: Integer -> Maybe PrvKey

-- | Returns the Integer value of a private key
fromPrvKey :: PrvKey -> Integer

-- | Returns True of the private key is uncompressed
isPrvKeyU :: PrvKey -> Bool

-- | Add two private keys together. One of the keys is defined by a
--   Hash256. The functions fails on uncompressed private keys and return
--   Nothing if the Hash256 is smaller than the order of the curve N. This
--   is provided as a helper for implementing BIP32 wallets.
addPrvKeys :: PrvKey -> Hash256 -> Maybe PrvKey

-- | Serialize a private key into the Data.Binary.Put monad as a 32 byte
--   big endian ByteString. This is useful when a constant length
--   serialization format for private keys is required
putPrvKey :: PrvKey -> Put

-- | Deserializes a compressed private key from the Data.Binary.Get monad
--   as a 32 byte big endian ByteString.
getPrvKey :: Get PrvKey

-- | Deserializes an uncompressed private key from the Data.Binary.Get
--   monad as a 32 byte big endian ByteString
getPrvKeyU :: Get PrvKey

-- | Decodes a private key from a WIF encoded String. This function can
--   fail if the input string does not decode correctly as a base 58 string
--   or if the checksum fails.
--   <a>http://en.bitcoin.it/wiki/Wallet_import_format</a>
fromWIF :: String -> Maybe PrvKey

-- | Encodes a private key into WIF format
toWIF :: PrvKey -> String

-- | StateT monad stack tracking the internal state of HMAC DRBG pseudo
--   random number generator using SHA-256. The <a>SecretT</a> monad is run
--   with the <a>withSource</a> function by providing it a source of
--   entropy.
type SecretT m a = StateT (SecretState m) m a

-- | Run a <a>SecretT</a> monad by providing it a source of entropy. You
--   can use <a>devURandom</a>, <a>devRandom</a> or provide your own
--   entropy source function.
withSource :: Monad m => (Int -> m ByteString) -> SecretT m a -> m a

-- | /dev/urandom entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devURandom :: Int -> IO ByteString

-- | /dev/random entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devRandom :: Int -> IO ByteString

-- | Produce a new <a>PrvKey</a> randomly from the <a>SecretT</a> monad.
genPrvKey :: Monad m => SecretT m PrvKey

-- | Data type representing an ECDSA signature.
data Signature

-- | Safely sign a message inside the <a>SecretT</a> monad. The
--   <a>SecretT</a> monad will generate a new nonce for each signature.
signMsg :: Monad m => Hash256 -> PrvKey -> SecretT m Signature

-- | Sign a message using ECDSA deterministic signatures as defined by RFC
--   6979 <a>http://tools.ietf.org/html/rfc6979</a>
detSignMsg :: Hash256 -> PrvKey -> Signature

-- | Verify an ECDSA signature
verifySig :: Hash256 -> Signature -> PubKey -> Bool

-- | Returns True if the S component of a Signature is &lt;= order/2.
--   Signatures need to pass this test to be canonical.
isCanonicalHalfOrder :: Signature -> Bool

-- | Data type representing a 512 bit unsigned integer. It is implemented
--   as an Integer modulo 2^512.
type Hash512 = Ring Mod512

-- | Data type representing a 256 bit unsigned integer. It is implemented
--   as an Integer modulo 2^256.
type Hash256 = Ring Mod256

-- | Data type representing a 160 bit unsigned integer. It is implemented
--   as an Integer modulo 2^160.
type Hash160 = Ring Mod160

-- | Data type representing a 32 bit checksum
data CheckSum32

-- | Computes SHA-512.
hash512 :: ByteString -> Hash512

-- | Computes SHA-512 and returns the result as a bytestring.
hash512BS :: ByteString -> ByteString

-- | Computes SHA-256.
hash256 :: ByteString -> Hash256

-- | Computes SHA-256 and returns the result as a bytestring.
hash256BS :: ByteString -> ByteString

-- | Computes RIPEMD-160.
hash160 :: ByteString -> Hash160

-- | Computes RIPEMD-160 and returns the result as a bytestring.
hash160BS :: ByteString -> ByteString

-- | Computes two rounds of SHA-256.
doubleHash256 :: ByteString -> Hash256

-- | Computes two rounds of SHA-256 and returns the result as a bytestring.
doubleHash256BS :: ByteString -> ByteString

-- | Computes a 32 bit checksum.
chksum32 :: ByteString -> CheckSum32

-- | Computes HMAC over SHA-512.
hmac512 :: ByteString -> ByteString -> Hash512

-- | Computes HMAC over SHA-512 and return the result as a bytestring.
hmac512BS :: ByteString -> ByteString -> ByteString

-- | Computes HMAC over SHA-256.
hmac256 :: ByteString -> ByteString -> Hash256

-- | Computes HMAC over SHA-256 and return the result as a bytestring.
hmac256BS :: ByteString -> ByteString -> ByteString

-- | Split a <a>Hash512</a> into a pair of <a>Hash256</a>.
split512 :: Hash512 -> (Hash256, Hash256)

-- | Join a pair of <a>Hash256</a> into a <a>Hash512</a>.
join512 :: (Hash256, Hash256) -> Hash512

-- | Data type representing a Bitcoin address
data Address

-- | Public Key Hash Address
PubKeyAddress :: Hash160 -> Address
getAddress :: Address -> Hash160

-- | Script Hash Address
ScriptAddress :: Hash160 -> Address
getAddress :: Address -> Hash160

-- | Decodes an Address from a base58 encoded String. This function can
--   fail if the String is not properly encoded as base58 or the checksum
--   fails.
base58ToAddr :: String -> Maybe Address

-- | Transforms an Address into a base58 encoded String
addrToBase58 :: Address -> String

-- | Encode a bytestring to a base 58 representation.
encodeBase58 :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring. This can fail if the input
--   bytestring contains invalid base 58 characters such as 0,O,l,I
decodeBase58 :: ByteString -> Maybe ByteString

-- | Computes a checksum for the input bytestring and encodes the input and
--   the checksum to a base 58 representation.
encodeBase58Check :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring that contains a checksum. This
--   function returns Nothing if the input bytestring contains invalid base
--   58 characters or if the checksum fails.
decodeBase58Check :: ByteString -> Maybe ByteString
