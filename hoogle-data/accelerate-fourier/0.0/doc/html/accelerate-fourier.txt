-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast Fourier transform and convolution using the Accelerate framework
--   
@package accelerate-fourier
@version 0.0

module Data.Array.Accelerate.Convolution.Preprocessed
type Transform2 sh a = Acc (Array sh a) -> Acc (Array sh a) -> Acc (Array sh a)

-- | Both arrays must have the same size.
--   
--   There is not much to preprocess, thus you should prefer
--   <a>karatsuba</a>.
karatsuba :: (Shape sh, Slice sh, Elt a, IsNum a) => Int -> Transform2 (sh :. Int) a

module Data.Array.Accelerate.Fourier.Utility
scaleDown :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform (sh :. Int) (Complex a)

module Data.Array.Accelerate.Cyclic
type Transform sh a = Acc (Array sh a) -> Acc (Array sh a)
reverse :: (Shape sh, Slice sh, Elt a) => Transform (sh :. Int) a
reverse2d :: (Shape sh, Slice sh, Elt a) => Transform ((sh :. Int) :. Int) a


-- | Compute transforms on real data based on complex-valued transforms.
module Data.Array.Accelerate.Fourier.Real

-- | Perform a real-to-complex transform using a complex-to-complex
--   transform of half size. Input must have an even size. Result has the
--   same size as the input, i.e. it is not halved.
toSpectrum :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform (sh :. Int) (Complex a) -> Acc (Array (sh :. Int) a) -> Acc (Array (sh :. Int) (Complex a))

-- | Perform a complex-to-real transform using a complex-to-complex of half
--   size. Input must be self-adjoint and must have an even size. Result
--   has the same size as the input, i.e. it is not doubled.
fromSpectrum :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform (sh :. Int) (Complex a) -> Acc (Array (sh :. Int) (Complex a)) -> Acc (Array (sh :. Int) a)

-- | Perform a real-to-complex transform of two real inputs using a
--   complex-to-complex transform of the same size. Input can have
--   arbitrary size.
twoToSpectrum :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform (sh :. Int) (Complex a) -> Acc (Array (sh :. Int) (a, a)) -> Acc (Array (sh :. Int) (Complex a, Complex a))
twoToSpectrum2d :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform ((sh :. Int) :. Int) (Complex a) -> Acc (Array ((sh :. Int) :. Int) (a, a)) -> Acc (Array ((sh :. Int) :. Int) (Complex a, Complex a))

-- | You can transform two real data sets using one complex transform. This
--   function can be used to untangle the resulting spectrum.
untangleSpectra :: (Shape sh, Slice sh, Elt a, IsFloating a) => Acc (Array (sh :. Int) (Complex a)) -> Acc (Array (sh :. Int) (Complex a, Complex a))
untangleSpectra2d :: (Shape sh, Slice sh, Elt a, IsFloating a) => Acc (Array ((sh :. Int) :. Int) (Complex a)) -> Acc (Array ((sh :. Int) :. Int) (Complex a, Complex a))
untangleCoefficient :: (IsFloating a, Elt a) => Exp (Complex a) -> Exp (Complex a) -> Exp (Complex a, Complex a)
twoFromSpectrum :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform (sh :. Int) (Complex a) -> Acc (Array (sh :. Int) (Complex a, Complex a)) -> Acc (Array (sh :. Int) (a, a))
twoFromSpectrum2d :: (Shape sh, Slice sh, Elt a, IsFloating a) => Transform ((sh :. Int) :. Int) (Complex a) -> Acc (Array ((sh :. Int) :. Int) (Complex a, Complex a)) -> Acc (Array ((sh :. Int) :. Int) (a, a))
entangleSpectra :: (Shape sh, Slice sh, Elt a, IsFloating a) => Acc (Array (sh :. Int) (Complex a, Complex a)) -> Acc (Array (sh :. Int) (Complex a))
entangleSpectra2d :: (Shape sh, Slice sh, Elt a, IsFloating a) => Acc (Array ((sh :. Int) :. Int) (Complex a, Complex a)) -> Acc (Array ((sh :. Int) :. Int) (Complex a))
entangleCoefficient :: (IsFloating a, Elt a) => Exp (Complex a) -> Exp (Complex a) -> Exp (Complex a, Complex a)


-- | The implementations in this module work entirely in the <a>Acc</a>
--   domain. This means that they can be applied to any array without
--   knowing their extent on the Haskell side. The downside is, that they
--   cannot share any preprocessing.
module Data.Array.Accelerate.Fourier.Adhoc
type Transform sh a = Acc (Array sh a) -> Acc (Array sh a)

-- | Automatically choose transformation algorithms according to the size
--   of the array. However, they are not as sophisticated as the algorithms
--   in <a>Data.Array.Accelerate.Fourier.Planned</a>.
transform :: (Slice sh, Shape sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)

-- | Split-Radix for power-of-two sizes.
ditSplitRadix :: (Slice sh, Shape sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)

-- | Decimation in time for power-of-two sizes.
dit2 :: (Slice sh, Shape sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)

-- | Decimation in time for sizes that are composites of the factors 2, 3
--   and 5. These sizes are known as 5-smooth numbers or the Hamming
--   sequence. <a>http://oeis.org/A051037</a>.
dit235 :: (Slice sh, Shape sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)

-- | Next greater or equal 5-smooth number as needed by <a>dit235</a>.
ceiling5Smooth :: Exp Int -> Exp Int

-- | Transformation of arbitrary length based on Bluestein on a
--   power-of-two size.
transformChirp2 :: (Shape sh, Slice sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)

-- | Transformation of arbitrary length based on Bluestein on a 5-smooth
--   size.
transformChirp235 :: (Shape sh, Slice sh, IsFloating a, Elt a) => Exp (Sign a) -> Transform (sh :. Int) (Complex a)
data Sign a
forward :: (Elt a, IsNum a) => Exp (Sign a)
inverse :: (Elt a, IsNum a) => Exp (Sign a)
transform2d :: (Shape sh, Slice sh, IsFloating a, Elt a) => SubTransform (Complex a) -> Transform ((sh :. Int) :. Int) (Complex a)
transform3d :: (Shape sh, Slice sh, IsFloating a, Elt a) => SubTransform (Complex a) -> Transform (((sh :. Int) :. Int) :. Int) (Complex a)
data SubTransform a
SubTransform :: (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> SubTransform a


-- | The implementations in this module require that you know the
--   transformation data set size on the Haskell side. This knowledge is
--   baked into the Accelerate code. The advantage is, that you can share
--   preprocessing between calls to the Fourier transforms, like in:
--   
--   <pre>
--   let transform = dit2 1024
--   in  transform x ... transform y
--   </pre>
module Data.Array.Accelerate.Fourier.Preprocessed
type Transform sh a = Acc (Array sh a) -> Acc (Array sh a)

-- | Decimation in time for power-of-two using the split-radix algorithm.
--   Should be faster than <a>dit2</a>.
ditSplitRadix :: (Slice sh, Shape sh, IsFloating a, Elt a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Decimation in time for power-of-two sizes.
dit2 :: (Slice sh, Shape sh, IsFloating a, Elt a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Decimation in frequency for power-of-two sizes.
dif2 :: (Slice sh, Shape sh, IsFloating a, Elt a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)
data Sign a
forward :: Num a => Sign a
inverse :: Num a => Sign a

-- | Transforms in <a>SubTransformPair</a> are ordered from
--   least-significant to most-significant dimension.
transform2d :: (Shape sh, Slice sh, IsFloating a, Elt a) => SubTransformPair (Complex a) -> Transform ((sh :. Int) :. Int) (Complex a)

-- | Transforms in <a>SubTransformTriple</a> are ordered from
--   least-significant to most-significant dimension.
transform3d :: (Shape sh, Slice sh, IsFloating a, Elt a) => SubTransformTriple (Complex a) -> Transform (((sh :. Int) :. Int) :. Int) (Complex a)
data SubTransformPair a
SubTransformPair :: (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> SubTransformPair a
data SubTransformTriple a
SubTransformTriple :: (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> (forall sh. (Shape sh, Slice sh) => Transform (sh :. Int) a) -> SubTransformTriple a

module Data.Array.Accelerate.Convolution.Adhoc
type Transform2 sh a = Acc (Array sh a) -> Acc (Array sh a) -> Acc (Array sh a)

-- | Both arrays must have the same size.
karatsuba :: (Shape sh, Slice sh, Elt a, IsNum a) => Transform2 (sh :. Int) a

-- | Turn an ordinary convolution into a cyclic convolution of the same
--   length.
cyclic :: (Shape sh, Slice sh, Elt a, IsNum a) => Transform2 (sh :. Int) a -> Transform2 (sh :. Int) a

-- | Turn a real-valued convolution into a complex-valued convolution. Can
--   be removed when we get <tt>instance IsNum (Complex a)</tt>.
complex :: (Shape sh, Slice sh, Elt a, IsNum a) => Transform2 (sh :. Int) a -> Transform2 (sh :. Int) (Complex a)


-- | Like <a>Data.Array.Accelerate.Fourier.Preprocessed</a> this module
--   allows to factor out some preprocessing. Additionally it gives you
--   concrete objects (plans and caches) for sharing preprocessed data
--   between transforms. You cannot only share the preprocessing between
--   transforms of the same size, but across all array sizes. This
--   implementation also has the largest collection of algorithms and thus
--   should be generally fastest among all implementations in this package.
module Data.Array.Accelerate.Fourier.Planned
type Transform sh a = Acc (Array sh a) -> Acc (Array sh a)

-- | Fourier transform of arbitrary size. Sign can be
--   
--   <ul>
--   <li><tt>forward</tt>: from time domain to frequency spectrum</li>
--   <li><tt>inverse</tt>: from frequency spectrum to time domain</li>
--   </ul>
--   
--   You may share <tt>transform sign n</tt> between several calls in order
--   to run some preprocessing only once. You must make sure that the
--   <tt>length</tt> is equal to the extent of the inner dimension of every
--   transformed array.
transform :: (Slice sh, Shape sh, RealFloat a, Elt a, IsFloating a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Transform using only Cooley-Tukey, Good-Thomas, Rader, Split-Radix,
--   but no Bluestein. This is more for testing and benchmarking than for
--   real use.
transformDecompose :: (Slice sh, Shape sh, Elt a, IsFloating a, RealFloat a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Fourier transform for arbitrary lengths based on the Bluestein
--   transform or chirp z-transform on an array with power-of-two size. It
--   may be faster than <a>transform</a> for certain prime factors. Find
--   bad factors e.g. in <a>http://oeis.org/A061092</a> and
--   <a>http://oeis.org/A059411</a> and nicer factors in
--   <a>http://oeis.org/A061303</a>.
transformChirp2 :: (Slice sh, Shape sh, Elt a, IsFloating a, RealFloat a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Fourier transform for arbitrary lengths based on the Bluestein
--   transform on an array with 5-smooth size. (5-smooth = all prime
--   factors are at most 5)
transformChirp235 :: (Slice sh, Shape sh, Elt a, IsFloating a, RealFloat a) => Sign a -> Int -> Transform (sh :. Int) (Complex a)

-- | Signals must have equal size and must not be empty.
convolveCyclic :: (Shape sh, Slice sh, a ~ Complex b, Elt b, IsFloating b, RealFloat b) => Int -> Acc (Array (sh :. Int) a) -> Acc (Array (sh :. Int) a) -> Acc (Array (sh :. Int) a)

-- | Memorize factorizations of the data size and permutation vectors.
data Plan

-- | Plan transform algorithms for a certain array size.
plan :: Integer -> Plan
transformWithPlanner :: (Slice sh, Shape sh, Elt a, IsFloating a, RealFloat a) => (Integer -> State PlanMap Plan) -> Sign a -> Int -> Transform (sh :. Int) (Complex a)
type PlanMap = Map Integer Plan

-- | Too many nested Rader transformations slow down the transform, up to
--   quadratic time in the worst case. As a heuristic we allow at most
--   nesting depth two, and switch to Bluestein transformation otherwise.
--   We could compute more precise operation counts and base our decision
--   on these, but we found that the actual execution time differs
--   considerably from the operation counts.
planWithMapUpdate :: Integer -> State PlanMap Plan
planDecomposeWithMapUpdate :: Integer -> State PlanMap Plan
planChirpWithMapUpdate :: (Integer -> Integer) -> Integer -> State PlanMap Plan

-- | Map of primitive transforms. You should use this as the initial map
--   when evaluating a planning sequence using <a>evalState</a>.
smallPlanMap :: PlanMap

-- | Cache arrays of twiddle factors, i.e. powers of the primitive root of
--   unity.
data Cache a

-- | The expression <tt>cache sign len</tt> precomputes all data that is
--   needed for Fourier transforms for signals of length <tt>len</tt>. You
--   can use this cache in <a>transformWithCache</a>.
cache :: (RealFloat a, Elt a, IsFloating a) => Sign a -> Int -> Cache (Complex a)

-- | It is <tt>(cache inverse x, cache forward x) = cacheDuplex x</tt> but
--   <a>cacheDuplex</a> shares common data of both caches.
cacheDuplex :: (a ~ Complex b, RealFloat b, Elt b, IsFloating b) => Int -> (Cache a, Cache a)

-- | The size and type of the signal must match the parameters, that the
--   cache was generated for.
transformWithCache :: (Slice sh, Shape sh, Elt a, IsFloating a) => Cache (Complex a) -> Transform (sh :. Int) (Complex a)
type CacheMap a = Map (Integer, Direction) (Cache a)
data Direction
Forward :: Direction
Inverse :: Direction
cacheFromPlanWithMapUpdate :: (a ~ Complex b, RealFloat b, Elt b, IsFloating b) => Plan -> (Direction, Sign b) -> State (CacheMap a) (Cache a)
directionMode :: (Num a, Ord a) => Sign a -> Int -> (Direction, Sign a)
cacheFromPlanWithMapUpdate2 :: (a ~ Complex b, RealFloat b, Elt b, IsFloating b) => (Plan, Plan) -> ((Direction, Sign b), (Direction, Sign b)) -> State (CacheMap a) (Cache a, Cache a)
directionModes :: Num a => Int -> ((Direction, Sign a), (Direction, Sign a))
data Sign a
forward :: Num a => Sign a
inverse :: Num a => Sign a
instance Show Direction
instance Eq Direction
instance Ord Direction
instance Show LevelSmall
instance Eq LevelSmall
instance Ord LevelSmall
instance Enum LevelSmall
instance Show PlanStructure
instance Show Plan
instance Show a => Show (LevelCacheSmall a)
instance Elt a => Show (LevelCacheRadix2 a)
instance Elt a => Show (LevelCacheSplitRadix a)
instance Elt a => Show (LevelCacheComposite a)
instance Show LevelCacheCoprime
instance Elt a => Show (LevelCachePrime a)
instance Elt a => Show (LevelCacheChirp a)
instance Elt a => Show (Cache a)
instance Elt a => Show (CacheSplitRadixChain a)
