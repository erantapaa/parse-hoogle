-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe file handling
--   
--   This package adds three safety features on top of the regular
--   <tt>System.IO</tt> file handles and operations:
--   
--   <ul>
--   <li>Regional file handles. Files must be opened in a <i>region</i>.
--   When the region terminates all opened files are automatically closed.
--   The main advantage of regions is that the handles to the opened files
--   can not be returned from the region which ensures no I/O with closed
--   files is possible.</li>
--   <li>Explicit IOModes. The regional file handles are parameterized by
--   the IOMode in which they were opened. All operations on handles
--   explicitly specify the needed IOMode. This way it is impossible to
--   read from a write-only handle or write to a read-only handle for
--   example.</li>
--   <li>Type-safe filepath creation and manipulation using the
--   <tt>pathtype</tt> package.</li>
--   </ul>
--   
--   The primary technique used in this package is called "Lightweight
--   monadic regions" which was invented by Oleg Kiselyov and Chung-chieh
--   Shan. See:
--   
--   <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a>
--   
--   This technique is implemented in the <tt>regions</tt> package which is
--   re-exported from <tt>safer-file-handles</tt>.
--   
--   See the <tt>safer-file-handles-examples</tt> package for examples how
--   to use this package:
--   
--   <pre>
--   git clone <a>https://github.com/basvandijk/safer-file-handles-examples</a>
--   </pre>
--   
--   See the <tt>safer-file-handles-bytestring/text</tt> package for
--   <tt>ByteString/Text</tt> operations on regional file handles.
@package safer-file-handles
@version 0.11


-- | <i>Unsafe</i> functions for retrieving the native <tt>Handle</tt> from
--   a regional file handle and for lifting operations on <tt>Handles</tt>
--   to <tt>RegionalFileHandles</tt>.
--   
--   These operations are unsafe because they allow you to close regional
--   file handles before exiting their region. So they enable you to
--   perform <tt>IO</tt> with already closed handles.
module System.IO.SaferFileHandles.Unsafe
unsafeHandle :: FileHandle handle => handle ioMode r -> Handle ioMode
wrap :: (FileHandle handle, MonadIO m) => (Handle ioMode -> IO α) -> (handle ioMode r -> m α)
wrap2 :: (FileHandle handle, MonadIO m) => (Handle ioMode -> β -> IO α) -> (handle ioMode r -> β -> m α)
wrap3 :: (FileHandle handle, MonadIO m) => (Handle ioMode -> γ -> β -> IO α) -> (handle ioMode r -> γ -> β -> m α)

-- | Modify thrown <tt>IOErrors</tt> in the given computation by erasing
--   the <a>ioe_handle</a> field in the <tt>IOError</tt> which may contain
--   the <tt>Handle</tt> which caused the <tt>IOError</tt>.
--   
--   I use this to ensure that <tt>Handles</tt> don't <i>leak</i> out the
--   region via exceptions.
sanitizeIOError :: IO α -> IO α


-- | The contributions of this module are as follows:
--   
--   <ul>
--   <li>This module extends the <tt>regions</tt> library with the ability
--   to open files in a <a>RegionT</a>. When the region terminates, all
--   opened resources will be closed automatically. The main advantage of
--   regions is that the handles to the opened resources can not be
--   returned from the region. This ensures no I/O with closed resources is
--   possible. The primary technique used in <tt>regions</tt> is called
--   "Lightweight monadic regions" which was invented by Oleg Kiselyov and
--   Chung-chieh Shan. See:
--   <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a></li>
--   <li>Secondly this module provides all the file operations of
--   <tt>System.IO</tt> lifted to the region monad.</li>
--   <li>Third, filepaths that are given to functions like <a>openFile</a>
--   are created and manipulated in a type-safe way using the
--   <tt>pathtype</tt> package.</li>
--   <li>The final contribution of this module is that file handles are
--   parameterised with the IOMode in which the file was opened. This can
--   be either <a>ReadMode</a>, <a>WriteMode</a>, <a>AppendMode</a> or
--   <a>ReadWriteMode</a>. All operations on files explicitly specify the
--   needed IOMode using the <a>ReadModes</a> and <a>WriteModes</a> type
--   classes. This way it is impossible to read from a write-only handle or
--   write to a read-only handle for example.</li>
--   </ul>
--   
--   See the <tt>safer-file-handles-examples</tt> package for examples how
--   to use this package:
--   
--   <pre>
--   git clone <a>https://github.com/basvandijk/safer-file-handles-examples</a>
--   </pre>
--   
--   <i>NOTE:</i> This module also provides functions from
--   <tt>System.IO</tt> which don't directly work with file handles like
--   <a>putStrLn</a> or <a>getLine</a> for example. These functions
--   implicitly use the standard handles. I actually provide more general
--   versions of these that work in any <a>MonadIO</a>. It could be argued
--   that these functions don't belong in this module because they don't
--   have anything to do with regions and explicit IOModes. However I
--   provide them as a convenience. But be warned that in the future these
--   lifted functions may move to their own package!
module System.IO.SaferFileHandles
class FileHandle handle :: (* -> (* -> *) -> *)

-- | A regional handle to an opened file parameterized by the <a>IOMode</a>
--   in which you opened the file and the region in which it was created.
data RegionalFileHandle ioMode r :: (* -> *)

-- | Read only.
data ReadMode :: *

-- | Write only.
data WriteMode :: *

-- | Write only by appending.
data AppendMode :: *

-- | Both read and write.
data ReadWriteMode :: *

-- | Class of readable IO mode types.
--   
--   Note the super class <tt>ReadModesPrivate</tt>. This type class is not
--   exported by this module which ensures you can't accidentally make
--   another type (like <a>WriteMode</a> or <a>AppendMode</a>) an instance
--   of <a>ReadModes</a>.
class ReadModesPrivate ioMode => ReadModes ioMode

-- | Class of writable IO mode types.
--   
--   Note the super class <tt>WriteModesPrivate</tt>. This type class is
--   not exported by this module which ensures you can't accidentally make
--   another type (like <a>ReadMode</a>) an instance of <a>WriteModes</a>.
class WriteModesPrivate ioMode => WriteModes ioMode

-- | The IOMode GADT which for each constructor specifies the associated
--   IOMode type.
--   
--   Also see: <tt>System.IO.<a>IOMode</a></tt>.
data IOMode ioMode :: * -> *
ReadMode :: IOMode ReadMode
WriteMode :: IOMode WriteMode
AppendMode :: IOMode AppendMode
ReadWriteMode :: IOMode ReadWriteMode
class MkIOMode ioMode
mkIOMode :: MkIOMode ioMode => IOMode ioMode
data StdFileHandle ioMode r :: (* -> *)

-- | Wraps: <tt>System.IO.<a>stdin</a></tt>.
stdin :: StdFileHandle ReadMode RootRegion

-- | Wraps: <tt>System.IO.<a>stdout</a></tt>.
stdout :: StdFileHandle WriteMode RootRegion

-- | Wraps: <tt>System.IO.<a>stderr</a></tt>.
stderr :: StdFileHandle WriteMode RootRegion

-- | Cast the IOMode of a handle if the handle supports it.
--   
--   This function is used in combination with the standard handles. When
--   you know the IOMode of a handle is different from its default IOMode
--   you can cast it to the right one.
cast :: (AncestorRegion pr cr, MonadIO cr, CheckMode castedIOMode) => StdFileHandle anyIOMode pr -> cr (Maybe (StdFileHandle castedIOMode pr))

-- | Computation <a>openFile</a> <tt>filePath ioMode</tt> allocates and
--   returns a new, regional file handle to manage the file identified by
--   <tt>filePath</tt>. It provides a safer replacement for
--   <tt>System.IO.<a>openFile</a></tt>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>ioMode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>ioMode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>ioMode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   Note that the returned regional file handle is parameterized by the
--   region in which it was created. This ensures that handles can never
--   escape their region. And it also allows operations on handles to be
--   executed in a child region of the region in which the handle was
--   created.
--   
--   Note that if you do wish to return a handle from the region in which
--   it was created you have to duplicate the handle by applying <a>dup</a>
--   to it.
--   
--   Finally note that the returned regional file handle is also
--   parameterized by the IOMode in which you opened the file. All
--   operations on files explicitly specify the needed IOMode using the
--   <a>ReadModes</a> and <a>WriteModes</a> type classes. This way it is
--   impossible to read from a write-only handle or write to a read-only
--   handle for example.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isAlreadyInUseError</a> if the file is already open and cannot
--   be reopened;</li>
--   <li><a>isDoesNotExistError</a> if the file does not exist; or</li>
--   <li><a>isPermissionError</a> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: (RegionControlIO pr, AbsRelClass ar) => FilePath ar -> IOMode ioMode -> RegionT s pr (RegionalFileHandle ioMode (RegionT s pr))

-- | Convenience function which opens a file, applies the given
--   continuation function to the resulting regional file handle and runs
--   the resulting region. This provides a safer safer replacement for
--   <tt>System.IO.<a>withFile</a></tt>.
withFile :: (RegionControlIO pr, AbsRelClass ar) => FilePath ar -> IOMode ioMode -> (forall s. RegionalFileHandle ioMode (RegionT s pr) -> RegionT s pr α) -> pr α

-- | Open a file without explicitly specifying the IOMode. The IOMode is
--   inferred from the type of the resulting <a>RegionalFileHandle</a>.
--   
--   Note that: <tt>openFile' fp = <a>openFile</a> fp <a>mkIOMode</a></tt>.
openFile' :: (RegionControlIO pr, AbsRelClass ar, MkIOMode ioMode) => FilePath ar -> RegionT s pr (RegionalFileHandle ioMode (RegionT s pr))

-- | Note that: <tt>withFile' filePath = <a>withFile</a> filePath
--   <a>mkIOMode</a></tt>.
withFile' :: (RegionControlIO pr, AbsRelClass ar, MkIOMode ioMode) => FilePath ar -> (forall s. RegionalFileHandle ioMode (RegionT s pr) -> RegionT s pr α) -> pr α

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
--   
--   Wraps: <tt>System.IO.<a>hFileSize</a></tt>.
hFileSize :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
--   
--   Wraps: <tt>System.IO.<a>hSetFileSize</a></tt>.
hSetFileSize :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> Integer -> cr ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it is the same as calling
--   <a>hLookAhead</a> and checking for an EOF exception.
--   
--   Wraps: <tt>System.IO.<a>hIsEOF</a></tt>.
hIsEOF :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr Bool

-- | Generalizes: <tt>System.IO.<a>isEOF</a></tt> to any <a>MonadIO</a>.
isEOF :: MonadIO m => m Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a
--   <tt>System.IO.hFlush</tt> is issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <tt>System.IO.hFlush</tt> is issued, or the handle is
--   closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <tt>System.IO.hLookAhead</tt> operation implies that even a
--   no-buffered handle may require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode :: *

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hSetBuffering</a></tt>.
hSetBuffering :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> BufferMode -> cr ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
--   
--   Wraps: <tt>System.IO.<a>hGetBuffering</a></tt>.
hGetBuffering :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hFlush</a></tt>.
hFlush :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, WriteModes ioMode) => handle ioMode pr -> cr ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
--   
--   Wraps: <tt>System.IO.<a>hGetPosn</a></tt>.
hGetPosn :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hSetPosn</a></tt>.
hSetPosn :: MonadIO m => HandlePosn -> m ()
data HandlePosn :: *

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hSeek</a></tt>.
hSeek :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> SeekMode -> Integer -> cr ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode :: *

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Wraps: <tt>System.IO.<a>hTell</a></tt>.
hTell :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Integer

-- | Note that this operation should always return <a>True</a> since the
--   <tt>regions</tt> framework ensures that handles are always open. This
--   function is used only for testing the correctness of this library.
--   
--   Wraps: <tt>System.IO.<a>hIsOpen</a></tt>.
hIsOpen :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Note that this operation should always return <a>False</a> since the
--   <tt>regions</tt> framework ensures that handles are never closed. This
--   function is used only for testing the correctness of this library.
--   
--   Wraps: <tt>System.IO.<a>hIsClosed</a></tt>.
hIsClosed :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Note that this operation should always return <a>True</a> for IOModes
--   which have an instance for <a>ReadModes</a>. This function is used
--   only for testing the correctness of this library.
--   
--   Wraps: <tt>System.IO.<a>hIsReadable</a></tt>.
hIsReadable :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Note that this operation should always return <a>True</a> for IOModes
--   which have an instance for <a>WriteModes</a>. This function is used
--   only for testing the correctness of this library.
--   
--   Wraps: <tt>System.IO.<a>hIsWritable</a></tt>.
hIsWritable :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Wraps: <tt>System.IO.<a>hIsSeekable</a></tt>.
hIsSeekable :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Is the handle connected to a terminal?
--   
--   Wraps: <tt>System.IO.<a>hIsTerminalDevice</a></tt>.
hIsTerminalDevice :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Set the echoing status of a handle connected to a terminal.
--   
--   Wraps: <tt>System.IO.<a>hSetEcho</a></tt>.
hSetEcho :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> Bool -> cr ()

-- | Get the echoing status of a handle connected to a terminal.
--   
--   Wraps: <tt>System.IO.<a>hGetEcho</a></tt>.
hGetEcho :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr Bool

-- | Wraps: <tt>System.IO.<a>hShow</a></tt>.
hShow :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput t</tt> where <tt>t &gt;= 0</tt> will block all other
--   Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
--   
--   Wraps: <tt>System.IO.<a>hWaitForInput</a></tt>.
hWaitForInput :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> Int -> cr Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hReady</a></tt>.
hReady :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hGetChar</a></tt>.
hGetChar :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   Wraps: <tt>System.IO.<a>hGetLine</a></tt>.
hGetLine :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hLookAhead</a></tt>.
hLookAhead :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. A semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if its corresponding region terminates;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hGetContents</a></tt>.
hGetContents :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, ReadModes ioMode) => handle ioMode pr -> cr String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hPutChar</a></tt>.
hPutChar :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, WriteModes ioMode) => handle ioMode pr -> Char -> cr ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hPutStr</a></tt>.
hPutStr :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, WriteModes ioMode) => handle ioMode pr -> String -> cr ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
--   
--   Wraps: <tt>System.IO.<a>hPutStrLn</a></tt>.
hPutStrLn :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, WriteModes ioMode) => handle ioMode pr -> String -> cr ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <tt>shows</tt> function to
--   the file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hPrint</a></tt>.
hPrint :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr, WriteModes ioMode, Show α) => handle ioMode pr -> α -> cr ()

-- | Generalizes <tt>System.IO.<a>interact</a></tt> to any <a>MonadIO</a>.
interact :: MonadIO m => (String -> String) -> m ()

-- | Generalizes <tt>System.IO.<a>putChar</a></tt> to any <a>MonadIO</a>.
putChar :: MonadIO m => Char -> m ()

-- | Generalizes <tt>System.IO.<a>putStr</a></tt> to any <a>MonadIO</a>.
putStr :: MonadIO m => String -> m ()

-- | Generalizes <tt>System.IO.<a>putStrLn</a></tt> to any <a>MonadIO</a>.
putStrLn :: MonadIO m => String -> m ()

-- | Generalizes <tt>System.IO.<a>print</a></tt> to any <a>MonadIO</a>.
print :: (MonadIO m, Show α) => α -> m ()

-- | Generalizes <tt>System.IO.<a>getChar</a></tt> to any <a>MonadIO</a>.
getChar :: MonadIO m => m Char

-- | Generalizes <tt>System.IO.<a>getLine</a></tt> to any <a>MonadIO</a>.
getLine :: MonadIO m => m String

-- | Generalizes <tt>System.IO.<a>getContents</a></tt> to any
--   <a>MonadIO</a>.
getContents :: MonadIO m => m String

-- | Generalizes <tt>System.IO.<a>readIO</a></tt> to any <a>MonadIO</a>.
readIO :: (MonadIO m, Read α) => String -> m α

-- | Generalizes <tt>System.IO.<a>readLn</a></tt> to any <a>MonadIO</a>.
readLn :: (MonadIO m, Read α) => m α

-- | Like <a>openFile</a>, but open the file in binary mode.
--   
--   On Windows, reading a file in text mode (which is the default) will
--   translate CRLF to LF, and writing will translate LF to CRLF. This is
--   usually what you want with text files. With binary files this is
--   undesirable; also, as usual under Microsoft operating systems, text
--   mode treats control-Z as EOF. Binary mode turns off all special
--   treatment of end-of-line and end-of-file characters. (See also
--   <a>hSetBinaryMode</a>.)
--   
--   This provides a safer replacement for
--   <tt>System.IO.<a>openBinaryFile</a></tt>.
openBinaryFile :: (RegionControlIO pr, AbsRelClass ar) => FilePath ar -> IOMode ioMode -> RegionT s pr (RegionalFileHandle ioMode (RegionT s pr))

-- | A convenience function which opens a file in binary mode, applies the
--   given continuation function to the resulting regional file handle and
--   runs the resulting region. This provides a safer replacement for
--   <tt>System.IO.<a>withBinaryFile</a></tt>.
withBinaryFile :: (RegionControlIO pr, AbsRelClass ar) => FilePath ar -> IOMode ioMode -> (forall s. RegionalFileHandle ioMode (RegionT s pr) -> RegionT s pr α) -> pr α

-- | Note that: <tt>openBinaryFile' filePath = <a>openBinaryFile</a>
--   filePath <a>mkIOMode</a></tt>.
openBinaryFile' :: (RegionControlIO pr, AbsRelClass ar, MkIOMode ioMode) => FilePath ar -> RegionT s pr (RegionalFileHandle ioMode (RegionT s pr))

-- | Note that: <tt>withBinaryFile' filePath = <a>withBinaryFile</a>
--   filePath <a>mkIOMode</a></tt>.
withBinaryFile' :: (RegionControlIO pr, AbsRelClass ar, MkIOMode ioMode) => FilePath ar -> (forall s. RegionalFileHandle ioMode (RegionT s pr) -> RegionT s pr α) -> pr α

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>latin1</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
--   
--   Wraps: <tt>System.IO.<a>hSetBinaryMode</a></tt>.
hSetBinaryMode :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> Bool -> cr ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the handle,
--   writing the bytes directly to the underlying file or device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the handle, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>ResourceVanished</tt> if the handle is a pipe or socket, and
--   the reading end is closed. (If this is a POSIX system, and the program
--   has not asked to ignore SIGPIPE, then a SIGPIPE may be delivered
--   instead, whose default action is to terminate the program).</li>
--   </ul>
--   
--   Wraps: <tt>System.IO.<a>hPutBuf</a></tt>.
hPutBuf :: (AncestorRegion pr1 cr, AncestorRegion pr2 cr, FileHandle handle, AllocatedPointer pointer, MonadIO cr, WriteModes ioMode) => handle ioMode pr1 -> pointer α pr2 -> Int -> cr ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> ignores whatever <a>TextEncoding</a> the handle is
--   currently using, and reads bytes directly from the underlying IO
--   device.
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the handle, and reads bytes directly.
--   
--   Wraps: <tt>System.IO.<a>hGetBuf</a></tt>.
hGetBuf :: (AncestorRegion pr1 cr, AncestorRegion pr2 cr, FileHandle handle, AllocatedPointer pointer, MonadIO cr, ReadModes ioMode) => handle ioMode pr1 -> pointer α pr2 -> Int -> cr Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the handle, and reads bytes directly.
--   
--   Wraps: <tt>System.IO.<a>hGetBufSome</a></tt>.
hGetBufSome :: (AncestorRegion pr1 cr, AncestorRegion pr2 cr, FileHandle handle, AllocatedPointer pointer, MonadIO cr, ReadModes ioMode) => handle ioMode pr1 -> pointer α pr2 -> Int -> cr Int

-- | Wraps: <tt>System.IO.<a>hPutBufNonBlocking</a></tt>.
hPutBufNonBlocking :: (AncestorRegion pr1 cr, AncestorRegion pr2 cr, FileHandle handle, AllocatedPointer pointer, MonadIO cr, WriteModes ioMode) => handle ioMode pr1 -> pointer α pr2 -> Int -> cr Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   <a>hGetBufNonBlocking</a> ignores whatever <a>TextEncoding</a> the
--   handle is currently using, and reads bytes directly from the
--   underlying IO device.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the handle, and reads bytes directly.
--   
--   Wraps: <tt>System.IO.<a>hGetBufNonBlocking</a></tt>.
hGetBufNonBlocking :: (AncestorRegion pr1 cr, AncestorRegion pr2 cr, FileHandle handle, AllocatedPointer pointer, MonadIO cr, ReadModes ioMode) => handle ioMode pr1 -> pointer α pr2 -> Int -> cr Int

-- | The template of a temporary file path.
--   
--   If the template is "foo.ext" then the created file will be
--   "fooXXX.ext" where XXX is some random number.
type Template = RelFile

-- | The function creates a temporary file in <a>ReadWriteMode</a>. The
--   created file isn't deleted automatically, so you need to delete it
--   manually.
--   
--   The file is created with permissions such that only the current user
--   can read/write it.
--   
--   With some exceptions (see below), the file will be created securely in
--   the sense that an attacker should not be able to cause
--   <a>openTempFile</a> to overwrite another file on the filesystem using
--   your credentials, by putting symbolic links (on Unix) in the place
--   where the temporary file is to be created. On Unix the
--   <tt>O_CREAT</tt> and <tt>O_EXCL</tt> flags are used to prevent this
--   attack, but note that <tt>O_EXCL</tt> is sometimes not supported on
--   NFS filesystems, so if you rely on this behaviour it is best to use
--   local filesystems only.
--   
--   This provides a safer replacement for
--   <tt>System.IO.<a>openTempFile</a></tt>.
openTempFile :: (RegionControlIO pr, AbsRelClass ar) => DirPath ar -> Template -> RegionT s pr (AbsFile, RegionalFileHandle ReadWriteMode (RegionT s pr))

-- | Like <a>openTempFile</a>, but opens the file in binary mode. See
--   <a>openBinaryFile</a> for more comments.
--   
--   This provides a safer replacement for
--   <tt>System.IO.<a>openBinaryTempFile</a></tt>.
openBinaryTempFile :: (RegionControlIO pr, AbsRelClass ar) => DirPath ar -> Template -> RegionT s pr (AbsFile, RegionalFileHandle ReadWriteMode (RegionT s pr))

-- | Like <a>openTempFile</a>, but uses the default file permissions.
--   
--   This provides a safer replacement for
--   <tt>System.IO.<a>openTempFileWithDefaultPermissions</a></tt>.
openTempFileWithDefaultPermissions :: (RegionControlIO pr, AbsRelClass ar) => DirPath ar -> Template -> RegionT s pr (AbsFile, RegionalFileHandle ReadWriteMode (RegionT s pr))

-- | Like <a>openBinaryTempFile</a>, but uses the default file permissions.
--   
--   This provides a safer replacement for
--   <tt>System.IO.<a>openBinaryTempFileWithDefaultPermissions</a></tt>.
openBinaryTempFileWithDefaultPermissions :: (RegionControlIO pr, AbsRelClass ar) => DirPath ar -> Template -> RegionT s pr (AbsFile, RegionalFileHandle ReadWriteMode (RegionT s pr))

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a handle is created is
--   <a>localeEncoding</a>, namely the default encoding for the current
--   locale.
--   
--   To create a handle with no encoding at all, use <a>openBinaryFile</a>.
--   To stop further encoding or decoding on an existing handle, use
--   <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
--   
--   Wraps: <tt>System.IO.<a>hSetEncoding</a></tt>.
hSetEncoding :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> TextEncoding -> cr ()

-- | Return the current <a>TextEncoding</a> for the specified handle, or
--   <tt>Nothing</tt> if the handle is in binary mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this handle. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
--   
--   Wraps: <tt>System.IO.<a>hGetEncoding</a></tt>.
hGetEncoding :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> cr (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding :: *

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The Unicode encoding of the current locale
localeEncoding :: TextEncoding

-- | Generalizes <tt>System.IO.<a>mkTextEncoding</a></tt> to any
--   <a>MonadIO</a>.
mkTextEncoding :: MonadIO m => String -> m TextEncoding

-- | Set the <a>NewlineMode</a> on the specified handle.
--   
--   All buffered data is flushed first.
--   
--   Wraps: <tt>System.IO.<a>hSetNewlineMode</a></tt>.
hSetNewlineMode :: (FileHandle handle, AncestorRegion pr cr, MonadIO cr) => handle ioMode pr -> NewlineMode -> cr ()

-- | The representation of a newline in the external file or stream.
data Newline :: *

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode :: *
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
inputNL :: NewlineMode -> Newline

-- | the representation of newlines on output
outputNL :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF, 
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode
instance FileHandle StdFileHandle
