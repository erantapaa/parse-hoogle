-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A family of combinators for defining webservices APIs
--   
@package servant
@version 0.4.3.1

module Servant.Common.Text

-- | For getting values from url captures and query string parameters
--   Instances should obey: &gt; fromText (toText a) == Just a
class FromText a
fromText :: FromText a => Text -> Maybe a

-- | For putting values in paths and query string parameters Instances
--   should obey: &gt; fromText (toText a) == Just a
class ToText a
toText :: ToText a => a -> Text
instance ToText Float
instance FromText Float
instance ToText Double
instance FromText Double
instance ToText Integer
instance FromText Integer
instance ToText Word64
instance FromText Word64
instance ToText Word32
instance FromText Word32
instance ToText Word16
instance FromText Word16
instance ToText Word8
instance FromText Word8
instance ToText Word
instance FromText Word
instance ToText Int64
instance FromText Int64
instance ToText Int32
instance FromText Int32
instance ToText Int16
instance FromText Int16
instance ToText Int8
instance FromText Int8
instance ToText Int
instance FromText Int
instance ToText Bool
instance FromText Bool
instance ToText String
instance FromText String
instance ToText Text
instance FromText Text

module Servant.API.Raw

-- | Endpoint for plugging in your own Wai <tt>Application</tt>s.
--   
--   The given <tt>Application</tt> will get the request as received by the
--   server, potentially with a modified (stripped) <tt>pathInfo</tt> if
--   the <tt>Application</tt> is being routed with <a>:&gt;</a>.
--   
--   In addition to just letting you plug in your existing WAI
--   <tt>Application</tt>s, this can also be used with
--   <a>serveDirectory</a> to serve static files stored in a particular
--   directory on your filesystem
data Raw
instance Typeable Raw


-- | A collection of basic Content-Types (also known as Internet Media
--   Types, or MIME types). Additionally, this module provides classes that
--   encapsulate how to serialize or deserialize values to or from a
--   particular Content-Type.
--   
--   Content-Types are used in <tt>ReqBody</tt> and the method combinators:
--   
--   <pre>
--   &gt;&gt;&gt; type MyEndpoint = ReqBody '[JSON, PlainText] Book :&gt; Get '[JSON, PlainText] :&gt; Book
--   </pre>
--   
--   Meaning the endpoint accepts requests of Content-Type
--   <tt>application/json</tt> or <tt>text/plain;charset-utf8</tt>, and
--   returns data in either one of those formats (depending on the
--   <tt>Accept</tt> header).
--   
--   If you would like to support Content-Types beyond those provided here,
--   then:
--   
--   <ol>
--   <li>Declare a new data type with no constructors (e.g. <tt>data
--   HTML</tt>).</li>
--   <li>Make an instance of it for <a>Accept</a>.</li>
--   <li>If you want to be able to serialize data *into* that Content-Type,
--   make an instance of it for <a>MimeRender</a>.</li>
--   <li>If you want to be able to deserialize data *from* that
--   Content-Type, make an instance of it for <a>MimeUnrender</a>.</li>
--   </ol>
--   
--   Note that roles are reversed in <tt>servant-server</tt> and
--   <tt>servant-client</tt>: to be able to serve (or even typecheck) a
--   <tt>Get '[JSON, XML] MyData</tt>, you'll need to have the appropriate
--   <a>MimeRender</a> instances in scope, whereas to query that endpoint
--   with <tt>servant-client</tt>, you'll need a <a>MimeUnrender</a>
--   instance in scope.
module Servant.API.ContentTypes
data JSON
data PlainText
data FormUrlEncoded
data OctetStream

-- | Instances of <a>Accept</a> represent mimetypes. They are used for
--   matching against the <tt>Accept</tt> HTTP header of the request, and
--   for setting the <tt>Content-Type</tt> header of the response
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media ((//), (/:))
--   
--   &gt;&gt;&gt; data HTML
--   
--   &gt;&gt;&gt; :{
--   instance Accept HTML where
--      contentType _ = "text" // "html" /: ("charset", "utf-8")
--   :}
--   </pre>
class Accept ctype
contentType :: Accept ctype => Proxy ctype -> MediaType

-- | Instantiate this class to register a way of serializing a type based
--   on the <tt>Accept</tt> header.
--   
--   Example:
--   
--   <pre>
--   data MyContentType
--   
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   
--   instance Show a =&gt; MimeRender MyContentType where
--      mimeRender _ val = pack ("This is MINE! " ++ show val)
--   
--   type MyAPI = "path" :&gt; Get '[MyContentType] Int
--   </pre>
class Accept ctype => MimeRender ctype a
mimeRender :: MimeRender ctype a => Proxy ctype -> a -> ByteString

-- | Instantiate this class to register a way of deserializing a type based
--   on the request's <tt>Content-Type</tt> header.
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media hiding (Accept)
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BSC
--   
--   &gt;&gt;&gt; data MyContentType = MyContentType String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Read a =&gt; MimeUnrender MyContentType a where
--      mimeUnrender _ bs = case BSC.take 12 bs of
--        "MyContentType" -&gt; return . read . BSC.unpack $ BSC.drop 12 bs
--        _ -&gt; Left "didn't start with the magic incantation"
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type MyAPI = "path" :&gt; ReqBody '[MyContentType] Int :&gt; Get '[JSON] Int
--   </pre>
class Accept ctype => MimeUnrender ctype a
mimeUnrender :: MimeUnrender ctype a => Proxy ctype -> ByteString -> Either String a
newtype AcceptHeader
AcceptHeader :: ByteString -> AcceptHeader
class AllCTRender (list :: [*]) a
handleAcceptH :: AllCTRender list a => Proxy list -> AcceptHeader -> a -> Maybe (ByteString, ByteString)
class IsNonEmpty list => AllCTUnrender (list :: [*]) a
handleCTypeH :: AllCTUnrender list a => Proxy list -> ByteString -> ByteString -> Maybe (Either String a)
class AllMimeRender (list :: [*]) a
allMimeRender :: AllMimeRender list a => Proxy list -> a -> [(MediaType, ByteString)]
class AllMimeUnrender (list :: [*]) a
allMimeUnrender :: AllMimeUnrender list a => Proxy list -> ByteString -> [(MediaType, Either String a)]

-- | A type that can be converted from
--   <tt>application/x-www-form-urlencoded</tt>, with the possibility of
--   failure.
class FromFormUrlEncoded a
fromFormUrlEncoded :: FromFormUrlEncoded a => [(Text, Text)] -> Either String a

-- | A type that can be converted to
--   <tt>application/x-www-form-urlencoded</tt>
class ToFormUrlEncoded a
toFormUrlEncoded :: ToFormUrlEncoded a => a -> [(Text, Text)]

-- | Like <a>eitherDecode</a> but allows all JSON values instead of just
--   objects and arrays.
--   
--   Will handle trailing whitespace, but not trailing junk. ie.
--   
--   <pre>
--   &gt;&gt;&gt; eitherDecodeLenient "1 " :: Either String Int
--   Right 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; eitherDecodeLenient "1 junk" :: Either String Int
--   Left "trailing junk after valid JSON: endOfInput"
--   </pre>
eitherDecodeLenient :: FromJSON a => ByteString -> Either String a
instance Typeable JSON
instance Typeable PlainText
instance Typeable FormUrlEncoded
instance Typeable OctetStream
instance Eq AcceptHeader
instance Show AcceptHeader
instance FromFormUrlEncoded [(Text, Text)]
instance ToFormUrlEncoded [(Text, Text)]
instance MimeUnrender OctetStream ByteString
instance MimeUnrender OctetStream ByteString
instance MimeUnrender PlainText Text
instance MimeUnrender PlainText Text
instance FromFormUrlEncoded a => MimeUnrender FormUrlEncoded a
instance FromJSON a => MimeUnrender JSON a
instance MimeRender OctetStream ByteString
instance MimeRender OctetStream ByteString
instance MimeRender PlainText Text
instance MimeRender PlainText Text
instance ToFormUrlEncoded a => MimeRender FormUrlEncoded a
instance ToJSON a => MimeRender JSON a
instance (MimeUnrender ctyp a, AllMimeUnrender ctyps a) => AllMimeUnrender (ctyp : ctyps) a
instance AllMimeUnrender '[] a
instance AllMimeRender '[] a
instance (MimeRender ctyp a, AllMimeRender (ctyp' : ctyps) a) => AllMimeRender (ctyp : ctyp' : ctyps) a
instance MimeRender ctyp a => AllMimeRender '[ctyp] a
instance (AllMimeUnrender ctyps a, IsNonEmpty ctyps) => AllCTUnrender ctyps a
instance (AllMimeRender ctyps a, IsNonEmpty ctyps) => AllCTRender ctyps a
instance Accept OctetStream
instance Accept PlainText
instance Accept FormUrlEncoded
instance Accept JSON

module Servant.API.Patch

-- | Endpoint for PATCH requests. The type variable represents the type of
--   the response body (not the request body, use <a>ReqBody</a> for that).
--   
--   If the HTTP response is empty, only () is supported.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- PATCH /books
--   
--   &gt;&gt;&gt; -- with a JSON encoded Book as the request body
--   
--   &gt;&gt;&gt; -- returning the just-created Book
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Patch '[JSON] Book
--   </pre>
data Patch (contentTypes :: [*]) a
instance Typeable Patch

module Servant.API.Put

-- | Endpoint for PUT requests, usually used to update a ressource. The
--   type <tt>a</tt> is the type of the response body that's returned.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- PUT /books/:isbn
--   
--   &gt;&gt;&gt; -- with a Book as request body, returning the updated Book
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; ReqBody '[JSON] Book :&gt; Put '[JSON] Book
--   </pre>
data Put (contentTypes :: [*]) a
instance Typeable Put

module Servant.API.Delete

-- | Combinator for DELETE requests.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- DELETE /books/:isbn
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Delete
--   </pre>
data Delete (contentTypes :: [*]) a
instance Typeable Delete

module Servant.API.Post

-- | Endpoint for POST requests. The type variable represents the type of
--   the response body (not the request body, use <a>ReqBody</a> for that).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- POST /books
--   
--   &gt;&gt;&gt; -- with a JSON encoded Book as the request body
--   
--   &gt;&gt;&gt; -- returning the just-created Book
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   </pre>
data Post (contentTypes :: [*]) a
instance Typeable Post

module Servant.API.Get

-- | Endpoint for simple GET requests. Serves the result as JSON.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Get '[JSON] [Book]
--   </pre>
data Get (contentTypes :: [*]) a
instance Typeable Get

module Servant.API.MatrixParam

-- | Lookup a potentially value-less matrix string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books;published
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; MatrixFlag "published" :&gt; Get '[JSON] [Book]
--   </pre>
data MatrixFlag (sym :: Symbol)

-- | Lookup the value associated to the <tt>sym</tt> matrix string
--   parameter and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books;author=&lt;author name&gt;
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; MatrixParam "author" Text :&gt; Get '[JSON] [Book]
--   </pre>
data MatrixParam (sym :: Symbol) a

-- | Lookup the values associated to the <tt>sym</tt> matrix string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support matrix string parameters of the form
--   <tt>param[]=val1;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books;authors[]=&lt;author1&gt;;authors[]=&lt;author2&gt;;...
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; MatrixParams "authors" Text :&gt; Get '[JSON] [Book]
--   </pre>
data MatrixParams (sym :: Symbol) a
instance Typeable MatrixParam
instance Typeable MatrixParams
instance Typeable MatrixFlag

module Servant.API.ReqBody

-- | Extract the request body as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- POST /books
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   </pre>
data ReqBody (contentTypes :: [*]) a
instance Typeable ReqBody

module Servant.API.QueryParam

-- | Lookup a potentially value-less query string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?published
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get '[JSON] [Book]
--   </pre>
data QueryFlag (sym :: Symbol)

-- | Lookup the value associated to the <tt>sym</tt> query string parameter
--   and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?author=&lt;author name&gt;
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get '[JSON] [Book]
--   </pre>
data QueryParam (sym :: Symbol) a

-- | Lookup the values associated to the <tt>sym</tt> query string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support query string parameters of the form
--   <tt>param[]=val1&amp;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1&amp;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?authors[]=&lt;author1&gt;&amp;authors[]=&lt;author2&gt;&amp;...
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get '[JSON] [Book]
--   </pre>
data QueryParams (sym :: Symbol) a
instance Typeable QueryParam
instance Typeable QueryParams

module Servant.API.Header

-- | Extract the given header's value as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; newtype Referer = Referer Text deriving (Eq, Show)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; -- GET /view-my-referer
--   
--   &gt;&gt;&gt; type MyApi = "view-my-referer" :&gt; Header "from" Referer :&gt; Get '[JSON] Referer
--   </pre>
data Header (sym :: Symbol) a
Header :: a -> Header a
MissingHeader :: Header a
UndecodableHeader :: ByteString -> Header a
instance Typeable Header
instance Eq a => Eq (Header sym a)
instance Show a => Show (Header sym a)
instance Functor (Header sym)


-- | This module provides facilities for adding headers to a response.
--   
--   <pre>
--   &gt;&gt;&gt; let headerVal = addHeader "some-url" 5 :: Headers '[Header "Location" String] Int
--   </pre>
--   
--   The value is added to the header specified by the type
--   (<tt>Location</tt> in the example above).
module Servant.API.ResponseHeaders

-- | Response Header objects. You should never need to construct one
--   directly. Instead, use <a>addHeader</a>.
data Headers ls a
Headers :: a -> HList ls -> Headers ls a

-- | The underlying value of a <a>Headers</a>
getResponse :: Headers ls a -> a

-- | HList of headers.
getHeadersHList :: Headers ls a -> HList ls
class AddHeader h v orig new | h v orig -> new, new -> h, new -> v, new -> orig
addHeader :: AddHeader h v orig new => v -> orig -> new
class BuildHeadersTo hs
buildHeadersTo :: BuildHeadersTo hs => [Header] -> HList hs
class GetHeaders ls
getHeaders :: GetHeaders ls => ls -> [Header]
data HList a
HNil :: HList []
HCons :: Header h x -> HList xs -> HList (Header h x : xs)
instance [overlap ok] Functor (Headers ls)
instance [overlap ok] (KnownSymbol h, ToByteString v, new ~ Headers '[Header h v] a) => AddHeader h v a new
instance [overlap ok] (KnownSymbol h, ToByteString v, Contains h (fst : rest) ~ 'False) => AddHeader h v (Headers (fst : rest) a) (Headers (Header h v : fst : rest) a)
instance [overlap ok] (KnownSymbol h, GetHeaders (HList rest), ToByteString v) => GetHeaders (Headers (Header h v : rest) a)
instance [overlap ok] GetHeaders (Headers '[] a)
instance [overlap ok] (KnownSymbol h, ToByteString x, GetHeaders (HList xs)) => GetHeaders (HList (Header h x : xs))
instance [overlap ok] GetHeaders (HList '[])
instance [overlap ok] (FromByteString v, BuildHeadersTo xs, KnownSymbol h, Contains h xs ~ 'False) => BuildHeadersTo (Header h v : xs)
instance [overlap ok] BuildHeadersTo '[]

module Servant.API.Capture

-- | Capture a value from the request path under a certain type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /books/:isbn
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
data Capture (sym :: Symbol) a
instance Typeable Capture

module Servant.API.Alternative

-- | Union of two APIs, first takes precedence in case of overlap.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--          :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] () -- POST /books
--   :}
--   </pre>
data (:<|>) a b
(:<|>) :: a -> b -> (:<|>) a b
instance Typeable (:<|>)
instance (Eq a, Eq b) => Eq (a :<|> b)
instance (Show a, Show b) => Show (a :<|> b)
instance (Monoid a, Monoid b) => Monoid (a :<|> b)

module Servant.API.Sub

-- | The contained API (second argument) can be found under <tt>("/" ++
--   path)</tt> (path being the first argument).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /hello/world
--   
--   &gt;&gt;&gt; -- returning a JSON encoded World value
--   
--   &gt;&gt;&gt; type MyApi = "hello" :&gt; "world" :&gt; Get '[JSON] World
--   </pre>
data (:>) (path :: k) a
instance Typeable (:>)


-- | Type safe generation of internal links.
--   
--   Given an API with a few endpoints:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds -XTypeFamilies -XTypeOperators
--   
--   &gt;&gt;&gt; import Servant.API
--   
--   &gt;&gt;&gt; import Servant.Utils.Links
--   
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; type Hello = "hello" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; type Bye   = "bye"   :&gt; QueryParam "name" String :&gt; Delete '[JSON] ()
--   
--   &gt;&gt;&gt; type API   = Hello :&lt;|&gt; Bye
--   
--   &gt;&gt;&gt; let api = Proxy :: Proxy API
--   </pre>
--   
--   It is possible to generate links that are guaranteed to be within
--   <tt>API</tt> with <a>safeLink</a>. The first argument to
--   <a>safeLink</a> is a type representing the API you would like to
--   restrict links to. The second argument is the destination endpoint you
--   would like the link to point to, this will need to end with a verb
--   like GET or POST. Further arguments may be required depending on the
--   type of the endpoint. If everything lines up you will get a <a>URI</a>
--   out the other end.
--   
--   You may omit <a>QueryParam</a>s and the like should you not want to
--   provide them, but types which form part of the URL path like
--   <a>Capture</a> must be included. The reason you may want to omit
--   <a>QueryParam</a>s is that safeLink is a bit magical: if parameters
--   are included that could take input it will return a function that
--   accepts that input and generates a link. This is best shown with an
--   example. Here, a link is generated with no parameters:
--   
--   <pre>
--   &gt;&gt;&gt; let hello = Proxy :: Proxy ("hello" :&gt; Get '[JSON] Int)
--   
--   &gt;&gt;&gt; print (safeLink api hello :: URI)
--   hello
--   </pre>
--   
--   If the API has an endpoint with parameters then we can generate links
--   with or without those:
--   
--   <pre>
--   &gt;&gt;&gt; let with = Proxy :: Proxy ("bye" :&gt; QueryParam "name" String :&gt; Delete '[JSON] ())
--   
--   &gt;&gt;&gt; print $ safeLink api with "Hubert"
--   bye?name=Hubert
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let without = Proxy :: Proxy ("bye" :&gt; Delete '[JSON] ())
--   
--   &gt;&gt;&gt; print $ safeLink api without
--   bye
--   </pre>
--   
--   If you would like create a helper for generating links only within
--   that API, you can partially apply safeLink if you specify a correct
--   type signature like so:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XConstraintKinds
--   
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let apiLink :: (IsElem endpoint API, HasLink endpoint)
--   
--   &gt;&gt;&gt; =&gt; Proxy endpoint -&gt; MkLink endpoint
--   
--   &gt;&gt;&gt; apiLink = safeLink api
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   Attempting to construct a link to an endpoint that does not exist in
--   api will result in a type error like this:
--   
--   <pre>
--   &gt;&gt;&gt; let bad_link = Proxy :: Proxy ("hello" :&gt; Delete '[JSON] ())
--   
--   &gt;&gt;&gt; safeLink api bad_link
--   ...
--       Could not deduce (Or
--                           (IsElem' (Delete '[JSON] ()) (Get '[JSON] Int))
--                           (IsElem'
--                              ("hello" :&gt; Delete '[JSON] ())
--                              ("bye" :&gt; (QueryParam "name" String :&gt; Delete '[JSON] ()))))
--         arising from a use of ‘safeLink’
--       In the expression: safeLink api bad_link
--       In an equation for ‘it’: it = safeLink api bad_link
--   </pre>
--   
--   This error is essentially saying that the type family couldn't find
--   bad_link under api after trying the open (but empty) type family
--   <a>IsElem'</a> as a last resort.
module Servant.Utils.Links

-- | Create a valid (by construction) relative URI with query params.
--   
--   This function will only typecheck if <tt>endpoint</tt> is part of the
--   API <tt>api</tt>
safeLink :: (IsElem endpoint api, HasLink endpoint) => Proxy api -> Proxy endpoint -> MkLink endpoint

-- | Represents a general universal resource identifier using its component
--   parts.
--   
--   For example, for the URI
--   
--   <pre>
--   foo://anonymous@www.haskell.org:42/ghc?query#frag
--   </pre>
--   
--   the components are:
data URI :: *
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI

-- | <pre>
--   foo:
--   </pre>
uriScheme :: URI -> String

-- | <pre>
--   //anonymous@www.haskell.org:42
--   </pre>
uriAuthority :: URI -> Maybe URIAuth

-- | <pre>
--   /ghc
--   </pre>
uriPath :: URI -> String

-- | <pre>
--   ?query
--   </pre>
uriQuery :: URI -> String

-- | <pre>
--   #frag
--   </pre>
uriFragment :: URI -> String

-- | Construct a toLink for an endpoint.
class HasLink endpoint where type family MkLink endpoint
toLink :: HasLink endpoint => Proxy endpoint -> Link -> MkLink endpoint
linkURI :: Link -> URI

-- | A safe link datatype. The only way of constructing a <a>Link</a> is
--   using <a>safeLink</a>, which means any <a>Link</a> is guaranteed to be
--   part of the mentioned API.
data Link

-- | You may use this type family to tell the type checker that your custom
--   type may be skipped as part of a link. This is useful for things like
--   <a>QueryParam</a> that are optional in a URI and do not affect them if
--   they are omitted.
--   
--   <pre>
--   &gt;&gt;&gt; data CustomThing
--   
--   &gt;&gt;&gt; type instance IsElem' e (CustomThing :&gt; s) = IsElem e s
--   </pre>
--   
--   Note that <a>IsElem</a> is called, which will mutually recurse back to
--   <a>IsElem'</a> if it exhausts all other options again.
--   
--   Once you have written a HasLink instance for CustomThing you are ready
--   to go.

-- | Closed type family, check if endpoint is within api

-- | If either a or b produce an empty constraint, produce an empty
--   constraint.
instance Show (Param a)
instance Show Link
instance HasLink Raw
instance HasLink (Delete y r)
instance HasLink (Put y r)
instance HasLink (Post y r)
instance HasLink (Get y r)
instance HasLink sub => HasLink (Header sym a :> sub)
instance (ToText v, HasLink sub) => HasLink (Capture sym v :> sub)
instance HasLink sub => HasLink (ReqBody ct a :> sub)
instance (KnownSymbol sym, HasLink sub) => HasLink (MatrixFlag sym :> sub)
instance (KnownSymbol sym, ToText v, HasLink sub) => HasLink (MatrixParams sym v :> sub)
instance (KnownSymbol sym, ToText v, HasLink sub) => HasLink (MatrixParam sym v :> sub)
instance (KnownSymbol sym, HasLink sub) => HasLink (QueryFlag sym :> sub)
instance (KnownSymbol sym, ToText v, HasLink sub) => HasLink (QueryParams sym v :> sub)
instance (KnownSymbol sym, ToText v, HasLink sub) => HasLink (QueryParam sym v :> sub)
instance (KnownSymbol sym, HasLink sub) => HasLink (sym :> sub)

module Servant.API
