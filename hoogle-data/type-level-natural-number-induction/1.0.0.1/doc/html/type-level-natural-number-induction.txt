-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High-level combinators for performing inductive operations.
--   
--   This package provides high-level combinators for working with
--   inductive structures --- that is, structures tagged with a phantom
--   type-level natural number. Combinators are provided for building up a
--   structure from seed data using induction, tearing down a structure to
--   obtain a result, and inductively transforming one structure into
--   another with the same size.
--   
--   This package uses the type-level-natural-number package for its
--   type-level representations of the natural numbers. The only
--   non-Haskell 2010 extension it needs is Rank2Types.
@package type-level-natural-number-induction
@version 1.0.0.1

module TypeLevel.NaturalNumber.Induction

-- | The Induction class contains high-level combinators for performing
--   monadic operations on inductive structures --- that is, datatypes
--   tagged with a natural number.
class Induction n
deductionM :: (Induction n, Monad m) => α -> (f Zero -> α -> m β) -> (forall n. f (SuccessorTo n) -> α -> m (f n, α)) -> f n -> m β
deduction2M :: (Induction n, Monad m) => α -> (f Zero -> g Zero -> α -> m β) -> (forall n. f (SuccessorTo n) -> g (SuccessorTo n) -> α -> m (f n, g n, α)) -> f n -> g n -> m β
inductionM :: (Induction n, Monad m) => (α -> m (α, f Zero)) -> (forall n. α -> f n -> m (α, f (SuccessorTo n))) -> α -> m (α, f n)
transformM :: (Induction n, Monad m) => (f Zero -> m (g Zero)) -> (forall n. (f n -> m (g n)) -> f (SuccessorTo n) -> m (g (SuccessorTo n))) -> f n -> m (g n)

-- | The <a>inductionMOnLeftFold</a> function is provided for the common
--   case where one is building up an inductive structure by performing a
--   monadic left fold over a list. A pre-condition of calling this
--   function is that the list be the same size as the data structure, i.e.
--   that the length of the list be equal to the natural number tagging the
--   structure. When this pre-condition is violated, it returns _|_ by
--   calling <a>error</a> with a message that the list is either too long
--   or too short. See <a>inductionOnLeftFold</a> for a non-monadic version
--   of this function, and <a>inductionMOnRightFold</a> for a version of
--   this function that performs a right fold over the list.
inductionMOnLeftFold :: (Induction n, Monad m) => m (f Zero) -> (forall n. α -> f n -> m (f (SuccessorTo n))) -> [α] -> m (f n)

-- | This function is the same idea as <a>inductionMOnLeftFold</a>
--   function, but it performs a right-fold rather than a left-fold over
--   the list. See <a>inductionOnRightFold</a> for a non-monadic version of
--   this function.
inductionMOnRightFold :: (Induction n, Monad m) => m (f Zero) -> (forall n. α -> f n -> m (f (SuccessorTo n))) -> [α] -> m (f n)

-- | The <a>deduction</a> function provides a high-level combinator for
--   folding over an inductive structure; essentially this method is the
--   opposite of the <a>induction</a> method which builds up an inductive
--   structure rather than tearing one down. See <a>deductionM</a> for a
--   monadic version of this function, and <a>deduction</a> for a version
--   of this function acting on two structures simultaneously rather than
--   one.
deduction :: Induction n => α -> (f Zero -> α -> β) -> (forall n. f (SuccessorTo n) -> α -> (f n, α)) -> f n -> β

-- | The <a>deduction2</a> function is the same idea as the
--   <a>deductionM</a> function, but it simultaneously folds over two
--   inductive structures rather than one.
deduction2 :: Induction n => α -> (f Zero -> g Zero -> α -> β) -> (forall n. f (SuccessorTo n) -> g (SuccessorTo n) -> α -> (f n, g n, α)) -> f n -> g n -> β

-- | The <a>induction</a> function provides a high-level combinator for
--   building up an inductive structure starting from given seed data;
--   essentially this method is the opposite of <a>deduction</a> method
--   which tears down an inductive structure rather than building one up.
--   See <a>inductionM</a> for a monadic version of this function.
induction :: Induction n => (a -> (a, f Zero)) -> (forall n. a -> f n -> (a, f (SuccessorTo n))) -> a -> (a, f n)

-- | The <a>transform</a> function provides a high-level combinator for
--   transforming one inductive structure into another. See
--   <a>transformM</a> for a monadic version of this function.
transform :: Induction n => (f Zero -> g Zero) -> (forall n. (f n -> g n) -> f (SuccessorTo n) -> g (SuccessorTo n)) -> f n -> g n

-- | The <a>inductionOnLeftFold</a> function is provided for the common
--   case where one is building up an inductive structure by performing a
--   left fold over a list. A pre-condition of calling this function is
--   that the list be the same size as the data structure, i.e. that the
--   length of the list be equal to the natural number tagging the
--   structure. When this pre-condition is violated, it returns _|_ by
--   calling <a>error</a> with a message that the list is either too long
--   or too short. See <a>inductionMOnLeftFold</a> for a monadic version of
--   this function, and <a>inductionOnRightFold</a> for a version of this
--   function that performs a right fold over the list.
inductionOnLeftFold :: Induction n => f Zero -> (forall n. α -> f n -> f (SuccessorTo n)) -> [α] -> f n

-- | This function is the same idea as <a>inductionOnLeftFold</a> function,
--   but it performs a right-fold rather than a left-fold over the list.
--   See <a>inductionMOnRightFold</a> for a monadic version of this
--   function.
inductionOnRightFold :: Induction n => f Zero -> (forall n. α -> f n -> f (SuccessorTo n)) -> [α] -> f n
instance Induction n => Induction (SuccessorTo n)
instance Induction Zero
