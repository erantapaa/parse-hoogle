-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Aho-Corasick string matching algorithm
--   
--   Aho-Corasick string matching algorithm.
--   
--   See homepage for examples of usage:
--   <a>http://github.com/lymar/AhoCorasick</a>
@package AhoCorasick
@version 0.0.3


-- | Aho-Corasick string matching algorithm
--   
--   Simplest example:
--   
--   <pre>
--   example1 = mapM_ print $ findAll simpleSM "ushers" where
--       simpleSM = makeSimpleStateMachine ["he","she","his","hers"]
--   </pre>
--   
--   <pre>
--   Position {pIndex = 1, pLength = 3, pVal = "she"}
--   Position {pIndex = 2, pLength = 2, pVal = "he"}
--   Position {pIndex = 2, pLength = 4, pVal = "hers"}
--   </pre>
--   
--   With data:
--   
--   <pre>
--   example2 = mapM_ print $ findAll sm "ushers" where
--       sm = makeStateMachine [("he",0),("she",1),("his",2),("hers",3)]
--   </pre>
--   
--   <pre>
--   Position {pIndex = 1, pLength = 3, pVal = 1}
--   Position {pIndex = 2, pLength = 2, pVal = 0}
--   Position {pIndex = 2, pLength = 4, pVal = 3}
--   </pre>
--   
--   Step-by-step state machine evaluation:
--   
--   <pre>
--   example3 = mapM_ print $ next sm "ushers" where
--       sm = makeSimpleStateMachine ["he","she","his","hers"]
--       next _ [] = []
--       next sm (s:n) = let (SMStepRes match nextSM) = stateMachineStep sm s in
--           (s, match) : next nextSM n
--   </pre>
--   
--   <pre>
--   ('u',[])
--   ('s',[])
--   ('h',[])
--   ('e',[(3,"she"),(2,"he")])
--   ('r',[])
--   ('s',[(4,"hers")])
--   </pre>
module Text.AhoCorasick
data (Eq keySymb, Hashable keySymb) => StateMachine keySymb val
makeStateMachine :: (Eq keySymb, Hashable keySymb) => [([keySymb], val)] -> StateMachine keySymb val
makeSimpleStateMachine :: (Eq keySymb, Hashable keySymb) => [[keySymb]] -> StateMachine keySymb [keySymb]
findAll :: (Eq keySymb, Hashable keySymb) => StateMachine keySymb val -> [keySymb] -> [Position val]
data Position val
Position :: Int -> Int -> val -> Position val
pIndex :: Position val -> Int
pLength :: Position val -> Int
pVal :: Position val -> val
stateMachineStep :: (Eq keySymb, Hashable keySymb) => StateMachine keySymb val -> keySymb -> SMStepRes keySymb val
type KeyLength = Int
data (Eq keySymb, Hashable keySymb) => SMStepRes keySymb val
SMStepRes :: [(KeyLength, val)] -> StateMachine keySymb val -> SMStepRes keySymb val
smsrMatch :: SMStepRes keySymb val -> [(KeyLength, val)]
smsrNextSM :: SMStepRes keySymb val -> StateMachine keySymb val
resetStateMachine :: (Eq keySymb, Hashable keySymb) => StateMachine keySymb val -> StateMachine keySymb val
instance Show val => Show (Position val)
instance (Eq keySymb, Hashable keySymb, Show keySymb, Show val) => Show (SMStepRes keySymb val)
instance (Eq keySymb, Hashable keySymb, Show keySymb, Show val) => Show (StateMachine keySymb val)
instance (Eq keySymb, Hashable keySymb, Show keySymb) => Show (SMElem keySymb)
