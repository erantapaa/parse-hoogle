-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Ropes, an alternative to (Byte)Strings.
--   
--   Ropes : an alternative to Strings, a time and space-efficient
--   representation of character strings.
@package Data-Rope
@version 0.2

module Data.Rope.Internals
c_mmap :: Ptr a -> CSize -> CInt -> CInt -> CInt -> CInt -> IO (Ptr Word8)
c_munmap :: Ptr a -> CSize -> IO ()
c_PROT_NONE :: CInt
c_PROT_READ :: CInt
c_PROT_WRITE :: CInt
c_PROT_EXEC :: CInt
c_MAP_SHARED :: CInt
c_MAP_FILE :: CInt
w2c :: Word8 -> Char
c2w :: Char -> Word8


-- | Implementation of the ideas in
--   <a>http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf</a>.
--   Inspired also by <a>Data.Map</a> and the OCaml version of ropes.
module Data.Rope
data Rope

-- | O(1) The empty <a>Rope</a>
empty :: Rope

-- | O(1) Convert a <a>Word8</a> into a <a>Rope</a>
singleton :: Word8 -> Rope

-- | O(n) Convert a list of <a>Word8</a> into a <a>Rope</a>
pack :: [Word8] -> Rope

-- | O(n) Inverse conversion
unpack :: Rope -> [Word8]

-- | O(n) Conversion from a strict <tt>ByteString</tt>
fromByteString :: ByteString -> Rope

-- | O(n) Conversion to a strict <tt>ByteString</tt>
toByteString :: Rope -> ByteString

-- | O(log n). Appends the specified byte at the beginning of the
--   <a>Rope</a>.
cons :: Word8 -> Rope -> Rope

-- | O(log n). Appends the specified byte at the end of the <a>Rope</a>.
snoc :: Rope -> Word8 -> Rope

-- | O(log n) Concatenates two <a>Rope</a>s
append :: Rope -> Rope -> Rope

-- | O(log n) First element of the <a>Rope</a>. Raises an error if the
--   argument is empty.
head :: Rope -> Word8

-- | O(log n). Returns the first element of the <a>Rope</a>, and the
--   <a>Rope</a> of the remaining elements.
uncons :: Rope -> Maybe (Word8, Rope)

-- | O(log n). Last element of a <a>Rope</a>.
last :: Rope -> Word8

-- | O(log n) The elements after the head. An error is raised if the
--   <a>Rope</a> is empty.
tail :: Rope -> Rope

-- | O(log n) The elements in the <a>Rope</a> except the last one.
init :: Rope -> Rope

-- | O(1) Tests whether a <a>Rope</a> is empty.
null :: Rope -> Bool

-- | O(1) Length of a <a>Rope</a>.
length :: Rope -> Int

-- | O(n). <tt><a>map</a> f r</tt> applies <tt>f</tt> on each element of
--   <tt>r</tt> and returns the concatenation of the result.
map :: (Word8 -> Word8) -> Rope -> Rope

-- | O(n) efficient way to reverse a <a>Rope</a>.
reverse :: Rope -> Rope

-- | O(n) intercalate an element between each element of the list of
--   <a>Rope</a>s and concatenates the result.
intercalate :: Rope -> [Rope] -> Rope

-- | O(log n) <tt><a>insert</a> a i b</tt> inserts <a>Rope</a> <tt>a</tt>
--   in <a>Rope</a> <tt>b</tt> after the <tt>i</tt>th element of
--   <tt>b</tt>.
insert :: Rope -> Int -> Rope -> Rope

-- | O(n). fold over a <a>Rope</a>. This implementation is not
--   tail-recursive but never pushes more than O(log n) calls on the stack.
foldl :: (a -> Word8 -> a) -> a -> Rope -> a

-- | O(n). like <a>foldl</a> but strict.
foldl' :: (a -> Word8 -> a) -> a -> Rope -> a

-- | O(n). Right fold. Again not tail-recursive but never uses more than
--   O(log n) on the stack.
foldr :: (Word8 -> a -> a) -> a -> Rope -> a
take :: Int -> Rope -> Rope
drop :: Int -> Rope -> Rope
splitAt# :: Int -> Rope -> (# Rope, Rope #)

-- | O(log n). <tt><a>splitAt</a> n xs</tt> is equivalent to (take n xs,
--   drop n xs), but a little faster.
splitAt :: Int -> Rope -> (Rope, Rope)

-- | O(n). <tt><a>breakByte</a> c r</tt> breaks <a>Rope</a> <tt>r</tt>
--   before the first occurence of <tt>c</tt>.
breakByte :: Word8 -> Rope -> (Rope, Rope)

-- | O(n). <tt><a>breaks</a> w r</tt> breaks <a>Rope</a> <tt>r</tt> between
--   each occurence of <tt>w</tt> (non-inclusive). This function is not
--   tail-recursive, uses <tt>memchr</tt> and constructs the list in
--   parallel using <tt><a>par</a></tt>.
breaks :: Word8 -> Rope -> [Rope]

-- | O(n). Satisfies <tt>lines r == breaks 0x0a r</tt>.
lines :: Rope -> [Rope]

-- | O(log n) returns the <a>Word8</a> at given index in the <a>Rope</a>
index :: Rope -> Int -> Char

-- | O(n) returns the index of the first element equal to the query
--   element. This implementation uses memchr at leaves, and explores the
--   rope in parallel (with <a>par</a>).
elemIndex :: Word8 -> Rope -> Maybe Int

-- | O(n) Same as <a>elemIndex</a>, but explores the <a>Rope</a>
--   sequentially. Useful for <a>Rope</a>s loaded lazily with
--   <a>readFile</a>.
elemIndex' :: Word8 -> Rope -> Maybe Int

-- | O(n) returns the list of all positions where the queried elements
--   occurs in the <a>Rope</a>. This implementation uses memchr.
elemIndices :: Word8 -> Rope -> [Int]

-- | Lazy file reading, using <tt>mmap</tt>.
readFile :: FilePath -> IO Rope

-- | Strict hGet. The whole rope is constructed.
hGet :: Handle -> Int -> IO Rope

-- | Returns the next line in the input <a>Handle</a>. If you need to
--   iterate <a>hGetLine</a>, it may be more efficient to first
--   <tt>mmap</tt> the file using <a>readFile</a>, or even load it with
--   then iterate <tt><a>breakByte</a> 0x0a</tt> : <a>hGetLine</a>
--   allocates a buffer to read the file and may waste most of this space
--   if the lines are shorter than the standard buffer size of this module.
hGetLine :: Handle -> IO Rope

-- | Reads the contents of a file handle strictly, then closes it.
hGetContents :: Handle -> IO Rope

-- | Writes the contents of the <a>Rope</a> on the specified <a>Handle</a>.
hPut :: Handle -> Rope -> IO ()

-- | like <a>hPut</a>, but with a newline character at the end of the
--   output
hPutStrLn :: Handle -> Rope -> IO ()

-- | synonym for <a>hPut</a>.
hPutStr :: Handle -> Rope -> IO ()

-- | like <a>putStr</a> but with a newline character at the end of the
--   output
putStrLn :: Rope -> IO ()

-- | Writes the contents of the <a>Rope</a> on the standard output.
putStr :: Rope -> IO ()
instance Ord Rope
instance Eq Rope
instance Show Rope
instance IsString Rope
