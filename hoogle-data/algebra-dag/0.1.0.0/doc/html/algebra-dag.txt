-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Infrastructure for DAG-shaped relational algebra plans
--   
--   This library contains infrastructure for DAG-shaped plans of
--   relational operators. It offers an API for construction and
--   modification of algebra plans and a DSL for specifying rewrites on
--   plans. Examples of usage can be found in the packages <a>DSH</a> and
--   <a>algebra-sql</a>
@package algebra-dag
@version 0.1.0.0

module Database.Algebra.Dag.Common

-- | Identifiers for DAG nodes.
type AlgNode = Int
type AlgMap alg = Map alg AlgNode
type NodeMap a = IntMap a
type Tag = String

-- | Tertiary, Binary, unary and leaf nodes of a relational algebra DAG.
data Algebra t b u n c
TerOp :: t -> c -> c -> c -> Algebra t b u n c
BinOp :: b -> c -> c -> Algebra t b u n c
UnOp :: u -> c -> Algebra t b u n c
NullaryOp :: n -> Algebra t b u n c
instance (Ord t, Ord b, Ord u, Ord n, Ord c) => Ord (Algebra t b u n c)
instance (Eq t, Eq b, Eq u, Eq n, Eq c) => Eq (Algebra t b u n c)
instance (Show t, Show b, Show u, Show n, Show c) => Show (Algebra t b u n c)
instance (Read t, Read b, Read u, Read n, Read c) => Read (Algebra t b u n c)
instance Generic (Algebra t b u n c)
instance Datatype D1Algebra
instance Constructor C1_0Algebra
instance Constructor C1_1Algebra
instance Constructor C1_2Algebra
instance Constructor C1_3Algebra
instance (FromJSON t, FromJSON b, FromJSON u, FromJSON n, FromJSON c) => FromJSON (Algebra t b u n c)
instance (ToJSON t, ToJSON b, ToJSON u, ToJSON n, ToJSON c) => ToJSON (Algebra t b u n c)

module Database.Algebra.Dag
data AlgebraDag a
class (Ord a, Show a) => Operator a
opChildren :: Operator a => a -> [AlgNode]
replaceOpChild :: Operator a => a -> AlgNode -> AlgNode -> a

-- | Return the nodemap of a DAG
nodeMap :: AlgebraDag a -> NodeMap a

-- | Return the (possibly modified) list of root nodes from a DAG
rootNodes :: AlgebraDag a -> [AlgNode]

-- | A map storing the number of parents for each node.
refCountMap :: AlgebraDag a -> NodeMap Int

-- | Create a DAG from a node map of algebra operators and a list of root
--   nodes. Nodes which are not reachable from the root nodes provided will
--   be pruned!
mkDag :: Operator a => NodeMap a -> [AlgNode] -> AlgebraDag a

-- | Construct an empty DAG with no root nodes. Beware: before any
--   collections are performed, root nodes must be added. Otherwise, all
--   nodes will be considered unreachable.
emptyDag :: AlgebraDag a

-- | Add a list of root nodes to a DAG, all of which must be present in the
--   DAG. The node map is normalized by removing all nodes which are not
--   reachable from the root nodes. FIXME re-use graph, opmap etc, only
--   remove pruned nodes.
addRootNodes :: Operator a => AlgebraDag a -> [AlgNode] -> AlgebraDag a

-- | Return the list of parents of a node.
parents :: AlgNode -> AlgebraDag a -> [AlgNode]

-- | Return a topological ordering of all nodes which are reachable from
--   the root nodes.
topsort :: Operator a => AlgebraDag a -> [AlgNode]

-- | Tests wether there is a path from the first to the second node.
hasPath :: AlgNode -> AlgNode -> AlgebraDag a -> Bool

-- | Return all nodes that are reachable from one node.
reachableNodesFrom :: AlgNode -> AlgebraDag a -> Set AlgNode

-- | Returns the operator for a node.
operator :: Operator a => AlgNode -> AlgebraDag a -> a

-- | Insert a new node into the DAG.
insert :: Operator a => a -> AlgebraDag a -> (AlgNode, AlgebraDag a)

-- | Insert an operator without checking if an equivalent operator is
--   already present.
insertNoShare :: Operator a => a -> AlgebraDag a -> (AlgNode, AlgebraDag a)

-- | 'replaceChild n old new' replaces all links from node n to node old
--   with links to node new.
replaceChild :: Operator a => AlgNode -> AlgNode -> AlgNode -> AlgebraDag a -> AlgebraDag a

-- | Replace an entry in the list of root nodes with a new node. The root
--   node must be present in the DAG.
replaceRoot :: Operator a => AlgebraDag a -> AlgNode -> AlgNode -> AlgebraDag a
collect :: Operator o => Set AlgNode -> AlgebraDag o -> AlgebraDag o

module Database.Algebra.Dag.Build

-- | The DAG builder monad, abstracted over the algebra stored in the DAG.
--   Internally, the monad detects sharing of subgraphs via hash consing.
type Build alg = State (BuildState alg)

-- | Evaluate the monadic graph into an algebraic plan, given a loop
--   relation.
runBuild :: Build alg r -> (AlgebraDag alg, r, NodeMap [Tag])

-- | Tag a subtree with a comment (monadic version)
tagM :: String -> Build alg AlgNode -> Build alg AlgNode

-- | Insert a node into the graph construction environment, first check if
--   the node already exists | if so return its id, otherwise insert it and
--   return its id.
insert :: Operator alg => alg -> Build alg AlgNode
insertNoShare :: Operator alg => alg -> Build alg AlgNode


-- | This module provides a monadic interface to rewrites on algebra DAGs.
module Database.Algebra.Rewrite.DagRewrite

-- | A Monad for DAG rewrites, parameterized over the type of algebra
--   operators.
data Rewrite o e a

-- | Run a rewrite action on the supplied graph. Returns the rewritten node
--   map, the potentially modified list of root nodes, the result of the
--   rewrite and the rewrite log.
runRewrite :: Operator o => Rewrite o e r -> AlgebraDag o -> e -> Bool -> (AlgebraDag o, e, r, Log)
initRewriteState :: (Ord o, Operator o) => AlgebraDag o -> e -> Bool -> RewriteState o e

-- | The log from a sequence of rewrite actions.
type Log = Seq String

-- | Log a general message
logGeneral :: String -> Rewrite o e ()

-- | Log a rewrite
logRewrite :: String -> AlgNode -> Rewrite o e ()

-- | Return the set of nodes that are reachable from the specified node.
reachableNodesFrom :: AlgNode -> Rewrite o e (Set AlgNode)

-- | Return the parents of a node
parents :: AlgNode -> Rewrite o e [AlgNode]

-- | Return a topological ordering of all reachable nodes in the DAG.
topsort :: Operator o => Rewrite o e [AlgNode]

-- | Return the operator for a node id.
operator :: Operator o => AlgNode -> Rewrite o e o
operatorSafe :: AlgNode -> Rewrite o e (Maybe o)

-- | Returns the root nodes of the DAG.
rootNodes :: Rewrite o e [AlgNode]

-- | Exposes the current state of the DAG
exposeDag :: Rewrite o e (AlgebraDag o)
getExtras :: Rewrite o e e
updateExtras :: e -> Rewrite o e ()

-- | Preserve the effects of a rewrite only if the rewrite signals success
--   by returning True. Otherwise, the state before the rewrite is put in
--   place again.
condRewrite :: Rewrite o e Bool -> Rewrite o e Bool

-- | Insert an operator into the DAG and return its node id. If the
--   operator is already present (same op, same children), reuse it.
insert :: (Operator o, Show o) => o -> Rewrite o e AlgNode

-- | Insert an operator into the DAG and return its node id WITHOUT reusing
--   an operator if it is already present.
insertNoShare :: Operator o => o -> Rewrite o e AlgNode

-- | replaceChildM n old new replaces all links from node n to node old
--   with links to node new
replaceChild :: Operator o => AlgNode -> AlgNode -> AlgNode -> Rewrite o e ()

-- | replace old new replaces _all_ links to old with links to new
replace :: Operator o => AlgNode -> AlgNode -> Rewrite o e ()

-- | Creates a new node from the operator and replaces the old node with it
--   by rewiring all links to the old node.
replaceWithNew :: (Operator o, Show o) => AlgNode -> o -> Rewrite o e AlgNode
replaceRoot :: Operator o => AlgNode -> AlgNode -> Rewrite o e ()

-- | Apply a pure function to the DAG.
infer :: (AlgebraDag o -> b) -> Rewrite o e b
collect :: (Show o, Operator o) => Rewrite o e ()
instance Monad (Rewrite o e)
instance Functor (Rewrite o e)
instance Applicative (Rewrite o e)


-- | Pattern matches on algebra plans.
module Database.Algebra.Rewrite.Match

-- | The Match monad models the failing of a match and provides limited
--   read-only access to the DAG.
newtype Match o p e a
M :: (MaybeT (Reader (Env o p e)) a) -> Match o p e a

-- | Runs a match on the supplied DAG. If the Match fails, <a>Nothing</a>
--   is returned. If the Match succeeds, it returns just the result.
runMatch :: e -> AlgebraDag o -> NodeMap p -> Match o p e a -> Maybe a

-- | Returns the parents of a node in a Match context.
getParents :: AlgNode -> Match o p e [AlgNode]
getOperator :: Operator o => AlgNode -> Match o p e o
hasPath :: AlgNode -> AlgNode -> Match o p e Bool
getRootNodes :: Match o p e [AlgNode]

-- | Fails the complete match if the predicate is False.
predicate :: Bool -> Match o p e ()

-- | Fails the complete match if the value is Nothing
try :: Maybe a -> Match o p e a

-- | Runs the supplied Match action on the operator that belongs to the
--   given node.
matchOp :: Operator o => AlgNode -> (o -> Match o p e a) -> Match o p e a
lookupExtras :: Match o p e e
exposeEnv :: Match o p e (AlgebraDag o, NodeMap p, e)

-- | Look up the properties for a given node.
properties :: AlgNode -> Match o p e p
instance Monad (Match o p e)
instance Functor (Match o p e)
instance Applicative (Match o p e)

module Database.Algebra.Rewrite.Rule
type Rule o p e = AlgNode -> Match o p e (Rewrite o e ())
type RuleSet o p e = [Rule o p e]

-- | Try a set of rules on a node and apply the rewrite of the first rule
--   that matches.
applyRuleSet :: e -> NodeMap p -> RuleSet o p e -> AlgNode -> Rewrite o e Bool

module Database.Algebra.Rewrite.Traversal

-- | Infer properties, then traverse the DAG in preorder fashion and apply
--   the rule set at every node. Properties are re-inferred after every
--   change.
preOrder :: Operator o => Rewrite o e (NodeMap p) -> RuleSet o p e -> Rewrite o e Bool

-- | Infer properties, then traverse the DAG in a postorder fashion and
--   apply the rule set at every node. Properties are re-inferred after
--   every change.
postOrder :: Operator o => Rewrite o e (NodeMap p) -> RuleSet o p e -> Rewrite o e Bool
applyToAll :: Rewrite o e (NodeMap p) -> RuleSet o p e -> Rewrite o e Bool

-- | Map a ruleset over the nodes of a DAG in topological order. This
--   function assumes that the structur of the DAG is not changed during
--   the rewrites. Properties are only inferred once.
topologically :: Operator o => Rewrite o e (NodeMap p) -> RuleSet o p e -> Rewrite o e Bool

-- | Iteratively apply a rewrite, until no further changes occur.
iteratively :: Rewrite o e Bool -> Rewrite o e Bool

-- | Sequence a list of rewrites and propagate information about wether one
--   of them applied.
sequenceRewrites :: [Rewrite o e Bool] -> Rewrite o e Bool

module Database.Algebra.Rewrite.Properties

-- | Infer bottom up properties with the given inference function.
inferBottomUpGeneral :: Operator o => (NodeMap o -> o -> AlgNode -> NodeMap p -> p) -> AlgebraDag o -> NodeMap p

module Database.Algebra.Rewrite.PatternConstruction

-- | Take a quoted variable with the root node on which to apply the
--   pattern, a string description of the pattern and the body of the match
--   and return the complete match statement. The body has to be a quoted
--   ([| ...|]) do-block.
dagPatMatch :: Name -> String -> Q Exp -> Q Exp

-- | Reference a variable that is bound by a pattern in a quoted match
--   body.
v :: String -> Q Exp

module Database.Algebra.Rewrite
