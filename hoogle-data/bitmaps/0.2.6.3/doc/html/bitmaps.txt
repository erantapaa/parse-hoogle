-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bitmap library
--   
@package bitmaps
@version 0.2.6.3


-- | This module is unstable; functions are not guaranteed to be the same
--   or even to exist in future versions
--   
--   It is intended primarily for use by this library itself.
module Data.Bitmap.Util

-- | Hack to catch "pureish" asynchronous errors
--   
--   This is only used as a workaround to the binary library's shortcoming
--   of using asynchronous errors instead of pure error handling, and also
--   zlib's same shortcoming.
--   
--   This function is similar to the <tt>spoon</tt> package's
--   <tt>teaspoon</tt> function, except that it can return more information
--   when an exception is caught.
tablespoon :: a -> Either String a

-- | Return a substring
--   
--   <a>subStr</a> <tt>index</tt> <tt>length</tt> returns <tt>length</tt>
--   characters from the string starting at <tt>index</tt>, which starts at
--   0.
--   
--   <pre>
--   subStr 1 2 "abcd" == "bc"
--   </pre>
subStr :: StringCells s => Int -> Int -> s -> s
padByte :: Word8

module Data.Bitmap.Types
type Dimensions i = (i, i)
type Coordinates i = (i, i)

-- | These are the color depths that the bitmap class supports
--   
--   The depth does not necessarily indicate any particular order; instead
--   the components listed in the name indicate which components are
--   contained in each pixel.
--   
--   The order in which the constructors are defined is significant; it
--   determines which match <tt>mostLikelyMatchCBF</tt> will choose.
data Depth

-- | 24 bit pixel consisting of one pixel per component and lacking an
--   alpha component
--   
--   Each pixel of this type thus requires three bytes to be fully
--   represented. Implementations are not required to pack the image data,
--   however; they are free, for instance, to store each pixel in 32-bit
--   (4-byte) integers.
Depth24RGB :: Depth

-- | 32 bit pixel also consisting of one pixel per component but contains
--   the alpha component
--   
--   Four bytes are needed for pixels of this type to be fully represented.
Depth32RGBA :: Depth

-- | Formats that bitmaps that are instances of the <tt>Bitmap</tt> class
--   need to support; these formats include the necessary meta-information
data CompleteBitmapFormat

-- | Uncompressed BITMAPINFOHEADER BMP format
--   (CompleteBitmapFormat_BitMaPInfoheaderUncompressed)
--   
--   The image format of this format is <a>IBF_BGR24A4VR</a>
--   
--   Due to being uncompressed, strings encoded in this format can grow
--   large quite quickly. This format is standard and widely supported, and
--   can be written directly to a file, the extension of which is typically
--   ".bmp"
--   
--   This format is one possible format for "bmp" files.
CBF_BMPIU :: CompleteBitmapFormat

-- | Same as <a>CBF_BMPIU</a> except that that final result is base-64
--   encoded and is thus suitable for human-readable strings defining a
--   small bitmap (CompleteBitmapFormat_BitMaPInfoheaderUncompressed)
--   
--   Like <a>CBF_BMPIU</a>, strings encoded in this format can become large
--   quick quickly, and even about a third more so, due to the more
--   restrictive range of values.
CBF_BMPIU64 :: CompleteBitmapFormat
CBF_BMPIUZ64 :: CompleteBitmapFormat

-- | Similar to CBF_BMPIU, but internally the pixel data is stored in the
--   <a>IBF_BGRU32VR</a> format instead of <a>IBF_BGR24A4VR</a>
--   
--   This format is another common format of "bmp" files.
CBF_BMPIUU :: CompleteBitmapFormat

-- | Formats for raw image data that don't include information such as
--   dimensions
data ImageBitmapFormat

-- | Series of red, green, and blue; the string is compressed and then
--   base-64 encoded; the encoded string is prepended with an <tt>m</tt>
--   for simpler identification
IBF_IDRGB24Z64 :: ImageBitmapFormat

-- | Series of blue, green, and red, that is rotated two bytes right; the
--   string is compressed and then base-64 encoded; the encoded string is
--   prepended with a <tt>b</tt> for simpler identification
IBF_IDBGR24R2RZ64 :: ImageBitmapFormat

-- | Series of red, green, and blue; the string is hex encoded, then
--   compressed, then hex encoded again; the encoded string is prepended
--   with with <tt>z</tt>
IBF_IDBGR24HZH :: ImageBitmapFormat

-- | Series of unused byte, red, green, and blue; the string is compressed
--   and then base-64 encoded; identified by an <tt>l</tt> character
IBF_IDRGB32Z64 :: ImageBitmapFormat

-- | Series of red, green, and blue, represented as a series of hexadecimal
--   pairs
IBF_BGR24H :: ImageBitmapFormat

-- | Series of blue, green, red, blue, etc. with a row alignment of 4,
--   stored upside-down
IBF_BGR24A4VR :: ImageBitmapFormat

-- | Series of blue, green, red, unused, blue, etc. stored upside-down
--   (already aligned to a 4-byte boundary)
IBF_BGRU32VR :: ImageBitmapFormat

-- | Series of blue, green, red, unused, blue, etc. (already aligned to a
--   4-byte boundary)
IBF_BGRU32 :: ImageBitmapFormat

-- | Series of red, green, blue, red, etc. with a row alignment of 4,
--   stored upside-down
IBF_RGB24A4VR :: ImageBitmapFormat

-- | Series of red, green, blue, red, etc. with a row alignment of 4
IBF_RGB24A4 :: ImageBitmapFormat

-- | Series of unused byte, red, green, and blue
IBF_RGB32 :: ImageBitmapFormat

-- | Series of unused byte, red, green, and blue; the string is compressed
--   and then base-64 encoded
IBF_RGB32Z64 :: ImageBitmapFormat
instance Typeable Depth
instance Typeable CompleteBitmapFormat
instance Typeable ImageBitmapFormat
instance Eq Depth
instance Ord Depth
instance Enum Depth
instance Bounded Depth
instance Show Depth
instance Read Depth
instance Data Depth
instance Eq CompleteBitmapFormat
instance Ord CompleteBitmapFormat
instance Enum CompleteBitmapFormat
instance Bounded CompleteBitmapFormat
instance Show CompleteBitmapFormat
instance Read CompleteBitmapFormat
instance Data CompleteBitmapFormat
instance Eq ImageBitmapFormat
instance Ord ImageBitmapFormat
instance Enum ImageBitmapFormat
instance Bounded ImageBitmapFormat
instance Show ImageBitmapFormat
instance Read ImageBitmapFormat
instance Data ImageBitmapFormat

module Codec.String.Base64
bytes64 :: Array Word8 Word8
ibytes64 :: Map Word8 Word8
fillByte64 :: Word8
encode64 :: StringCells s => s -> s
decode64 :: StringCells s => s -> Maybe s

module Codec.String.Base16
encodeHex :: StringCells s => s -> s
decodeHex :: StringCells s => s -> Maybe s


-- | Support for pixels with a colour depth of 24 or 32, either lacking or
--   containing an alpha component
--   
--   Greater precision and color depth are not yet supported. Support for
--   floating point representations of components is planned for the
--   future.
module Data.Bitmap.Pixel
class (Integral a, ConvPixelRGB a, ConvPixelRGBA a, ConvPixelBGR a, ConvPixelBGRA a) => Pixel a where leastIntensity = case alpha of { (Just alpha') -> (red =: leastIntensityComponent) . (green =: leastIntensityComponent) . (blue =: leastIntensityComponent) . (alpha' =: leastIntensityComponent) $ fromIntegral (0 :: Integer) (Nothing) -> (red =: leastIntensityComponent) . (green =: leastIntensityComponent) . (blue =: leastIntensityComponent) $ fromIntegral (0 :: Integer) } greatestIntensity = case alpha of { (Just alpha') -> (red =: greatestIntensityComponent) . (green =: greatestIntensityComponent) . (blue =: greatestIntensityComponent) . (alpha' =: greatestIntensityComponent) $ leastIntensity (Nothing) -> (red =: greatestIntensityComponent) . (green =: greatestIntensityComponent) . (blue =: greatestIntensityComponent) $ leastIntensity } toPixel = convertPixelValue fromPixel = convertPixelValue
red :: Pixel a => a :-> PixelComponent
green :: Pixel a => a :-> PixelComponent
blue :: Pixel a => a :-> PixelComponent
alpha :: Pixel a => Maybe (a :-> PixelComponent)
leastIntensity :: Pixel a => a
greatestIntensity :: Pixel a => a
toPixel :: (Pixel a, Pixel p) => a -> p
fromPixel :: (Pixel a, Pixel p) => p -> a

-- | A less efficient way of converting pixels by their components
convertPixelValue :: (Pixel a, Pixel b) => a -> b
type PixelStorage = Word32
type PixelComponent = Word8
leastIntensityComponent :: PixelComponent
greatestIntensityComponent :: PixelComponent
newtype PixelRGB
PixelRGB :: PixelStorage -> PixelRGB
unwrapPixelRGB :: PixelRGB -> PixelStorage
newtype PixelBGR
PixelBGR :: PixelStorage -> PixelBGR
unwrapPixelBGR :: PixelBGR -> PixelStorage
newtype PixelRGBA
PixelRGBA :: PixelStorage -> PixelRGBA
unwrapPixelRGBA :: PixelRGBA -> PixelStorage
newtype PixelBGRA
PixelBGRA :: PixelStorage -> PixelBGRA
unwrapPixelBGRA :: PixelBGRA -> PixelStorage
class ConvPixelRGB p
toPixelRGB :: ConvPixelRGB p => p -> PixelRGB
fromPixelRGB :: ConvPixelRGB p => PixelRGB -> p
class ConvPixelBGR p
toPixelBGR :: ConvPixelBGR p => p -> PixelBGR
fromPixelBGR :: ConvPixelBGR p => PixelBGR -> p
class ConvPixelRGBA p
toPixelRGBA :: ConvPixelRGBA p => p -> PixelRGBA
fromPixelRGBA :: ConvPixelRGBA p => PixelRGBA -> p
class ConvPixelBGRA p
toPixelBGRA :: ConvPixelBGRA p => p -> PixelBGRA
fromPixelBGRA :: ConvPixelBGRA p => PixelBGRA -> p

-- | Generic pixel type which has not be efficient enough when used with
--   bitmaps in practice
data GenPixel

-- | The most significant byte is unused
GenPixelRGB :: GenPixelStorage -> GenPixel
unwrapPixelStorage :: GenPixel -> GenPixelStorage

-- | The most significant byte is unused
GenPixelBGR :: GenPixelStorage -> GenPixel
unwrapPixelStorage :: GenPixel -> GenPixelStorage
GenPixelRGBA :: GenPixelStorage -> GenPixel
unwrapPixelStorage :: GenPixel -> GenPixelStorage
GenPixelBGRA :: GenPixelStorage -> GenPixel
unwrapPixelStorage :: GenPixel -> GenPixelStorage

-- | If the Genpixel types differ, they can still be determined to be
--   equivalent if their components are equal
--   
--   Unlike the default derived instance of Eq,
eqGenPixelValue :: GenPixel -> GenPixel -> Bool

-- | If the Genpixel types differ, they can still be determined to be
--   equivalent if their components are equal
--   
--   Unlike the default derived instance of Eq,
neqGenPixelValue :: GenPixel -> GenPixel -> Bool
genRed :: GenPixel :-> GenPixelComponent
genGreen :: GenPixel :-> GenPixelComponent
genBlue :: GenPixel :-> GenPixelComponent
genAlpha :: GenPixel :-> GenPixelComponent
toGenPixelRGB :: GenPixel -> GenPixel
toGenPixelBGR :: GenPixel -> GenPixel
toGenPixelRGBA :: GenPixel -> GenPixel
toGenPixelBGRA :: GenPixel -> GenPixel
type GenPixelStorage = Word32
type GenPixelComponent = Word8
leastIntensityGenComponent :: GenPixelComponent
greatestIntensityGenComponent :: GenPixelComponent
leastIntensityGen :: GenPixel
greatestIntensityGen :: GenPixel
bigEndian :: Bool

-- | Return a color from the first 6-bytes of a string representing the
--   red, green, and blue components of the color
--   
--   <pre>
--   (colorString "FF0000"  :: Maybe PixelRGBA) == Just $ (red =: 0xFF) . (green =: 0x00) . (blue =: 0x00) $ greatestIntensity
--   </pre>
colorString :: (StringCells s, Pixel p) => s -> Maybe p
instance Typeable PixelRGB
instance Typeable PixelBGR
instance Typeable PixelRGBA
instance Typeable PixelBGRA
instance Typeable GenPixel
instance Eq PixelRGB
instance Bounded PixelRGB
instance Enum PixelRGB
instance Ord PixelRGB
instance Real PixelRGB
instance Integral PixelRGB
instance Bits PixelRGB
instance Num PixelRGB
instance Show PixelRGB
instance Data PixelRGB
instance Eq PixelBGR
instance Bounded PixelBGR
instance Enum PixelBGR
instance Ord PixelBGR
instance Real PixelBGR
instance Integral PixelBGR
instance Bits PixelBGR
instance Num PixelBGR
instance Show PixelBGR
instance Data PixelBGR
instance Eq PixelRGBA
instance Bounded PixelRGBA
instance Enum PixelRGBA
instance Ord PixelRGBA
instance Real PixelRGBA
instance Integral PixelRGBA
instance Bits PixelRGBA
instance Num PixelRGBA
instance Show PixelRGBA
instance Data PixelRGBA
instance Eq PixelBGRA
instance Bounded PixelBGRA
instance Enum PixelBGRA
instance Ord PixelBGRA
instance Real PixelBGRA
instance Integral PixelBGRA
instance Bits PixelBGRA
instance Num PixelBGRA
instance Show PixelBGRA
instance Data PixelBGRA
instance Eq GenPixel
instance Show GenPixel
instance Data GenPixel
instance ConvPixelBGRA PixelBGRA
instance ConvPixelBGRA PixelRGBA
instance ConvPixelBGRA PixelBGR
instance ConvPixelBGRA PixelRGB
instance ConvPixelRGBA PixelBGRA
instance ConvPixelRGBA PixelRGBA
instance ConvPixelRGBA PixelBGR
instance ConvPixelRGBA PixelRGB
instance ConvPixelBGR PixelBGRA
instance ConvPixelBGR PixelRGBA
instance ConvPixelBGR PixelBGR
instance ConvPixelBGR PixelRGB
instance ConvPixelRGB PixelBGRA
instance ConvPixelRGB PixelRGBA
instance ConvPixelRGB PixelBGR
instance ConvPixelRGB PixelRGB
instance Pixel PixelBGRA
instance Pixel PixelRGBA
instance Pixel PixelBGR
instance Pixel PixelRGB

module Data.Bitmap.Class

-- | Bitmap class
--   
--   Pixels are indexed by (row, column), where (0, 0) represents the
--   upper-left-most corner of the bitmap. Instances of this class are not
--   required to support empty bitmaps.
--   
--   The encoding and decoding lists contain functions that can encode and
--   decode or return a string containing information about why it could
--   not be decoded in that format. The order is important: When a function
--   tries multiple or any decoder, it will use or return the one(s)
--   closest to the head of the list. There are lists of generic functions
--   that are defined by default. Normally, if an implementation of a
--   bitmap type overrides the default instance, it will only need to
--   replace one or a few decoders, not touching the rest of the default
--   decoders or the order of the decoders; thus the function
--   <a>updateIdentifiableElements</a> is defined and exported.
--   
--   Instances *must* support every serialization format.
class (Integral (BIndexType bmp), Pixel (BPixelType bmp)) => Bitmap bmp where type family BIndexType bmp type family BPixelType bmp convertInternalFormat = const completeEncoders = map (second unwrapGenericBitmapSerializer) defaultCompleteEncoders completeDecoders = map (second unwrapGenericBitmapSerializer) defaultCompleteDecoders imageEncoders = map (second unwrapGenericBitmapSerializer) defaultImageEncoders imageDecoders = map (second unwrapGenericBitmapSerializer) defaultImageDecoders
depth :: Bitmap bmp => bmp -> Depth
dimensions :: Bitmap bmp => bmp -> Dimensions (BIndexType bmp)
getPixel :: Bitmap bmp => bmp -> Coordinates (BIndexType bmp) -> BPixelType bmp
constructPixels :: Bitmap bmp => (Coordinates (BIndexType bmp) -> BPixelType bmp) -> Dimensions (BIndexType bmp) -> bmp
convertInternalFormat :: Bitmap bmp => bmp -> bmp -> bmp
completeEncoders :: Bitmap bmp => [(CompleteBitmapFormat, CompleteEncoder bmp)]
completeDecoders :: Bitmap bmp => [(CompleteBitmapFormat, CompleteDecoder bmp)]
imageEncoders :: Bitmap bmp => [(ImageBitmapFormat, ImageEncoder bmp)]
imageDecoders :: Bitmap bmp => [(ImageBitmapFormat, ImageDecoder bmp)]

-- | Convert one bitmap type to another
convertBitmap :: (Bitmap a, Bitmap b) => a -> b
newtype CompleteEncoder bmp
CompleteEncoder :: (forall s. Stringy s => bmp -> s) -> CompleteEncoder bmp
unwrapCompleteEncoder :: CompleteEncoder bmp -> forall s. Stringy s => bmp -> s
newtype CompleteDecoder bmp
CompleteDecoder :: (forall s. Stringy s => s -> Either String bmp) -> CompleteDecoder bmp
unwrapCompleteDecoder :: CompleteDecoder bmp -> forall s. Stringy s => s -> Either String bmp
newtype ImageEncoder bmp
ImageEncoder :: (forall s. Stringy s => bmp -> s) -> ImageEncoder bmp
unwrapImageEncoder :: ImageEncoder bmp -> forall s. Stringy s => bmp -> s
newtype ImageDecoder bmp
ImageDecoder :: (forall s. Stringy s => bmp -> s -> Either String bmp) -> ImageDecoder bmp
unwrapImageDecoder :: ImageDecoder bmp -> forall s. Stringy s => bmp -> s -> Either String bmp
newtype GenericBitmapSerializer s
GenericBitmapSerializer :: (forall bmp. Bitmap bmp => s bmp) -> GenericBitmapSerializer s
unwrapGenericBitmapSerializer :: GenericBitmapSerializer s -> forall bmp. Bitmap bmp => s bmp

-- | Update identifiable elements
--   
--   <a>updateIdentifiableElements</a> <tt>orig new</tt> returns
--   <tt>orig</tt> with each matching pair updated; extraneous replacements
--   in <tt>new</tt> are ignored.
updateIdentifiableElements :: Eq k => [(k, v)] -> [(k, v)] -> [(k, v)]
defaultCompleteEncoders :: [(CompleteBitmapFormat, GenericBitmapSerializer CompleteEncoder)]
encodeCBF_BMPIUZ64 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeCBF_BMPIU64 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeCBF_BMPIU :: (Stringy s, Bitmap bmp) => bmp -> s
encodeCBF_BMPIUU :: (Stringy s, Bitmap bmp) => bmp -> s
defaultCompleteDecoders :: [(CompleteBitmapFormat, GenericBitmapSerializer CompleteDecoder)]
tryCBF_BMPIUZ64 :: (Stringy s, Bitmap bmp) => s -> Either String bmp
tryCBF_BMPIU64 :: (Stringy s, Bitmap bmp) => s -> Either String bmp
tryCBF_BMPIU :: (Stringy s, Bitmap bmp) => s -> Either String bmp
tryCBF_BMPIUU :: (Stringy s, Bitmap bmp) => s -> Either String bmp
defaultImageEncoders :: [(ImageBitmapFormat, GenericBitmapSerializer ImageEncoder)]
encodeIBF_IDRGB24Z64 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_IDBGR24R2RZ64 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_IDBGR24HZH :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_IDRGB32Z64 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_BGR24H :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_BGR24A4VR :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_BGRU32VR :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_BGRU32 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_RGB24A4VR :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_RGB24A4 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_RGB32 :: (Stringy s, Bitmap bmp) => bmp -> s
encodeIBF_RGB32Z64 :: (Stringy s, Bitmap bmp) => bmp -> s
defaultImageDecoders :: [(ImageBitmapFormat, GenericBitmapSerializer ImageDecoder)]
tryIBF_IDRGB24Z64 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_IDBGR24R2RZ64 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_IDBGR24HZH :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_IDRGB32Z64 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_BGR24H :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_BGR24A4VR :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_BGRU32VR :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_BGRU32 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_RGB24A4VR :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_RGB24A4 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_RGB32 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp
tryIBF_RGB32Z64 :: (Stringy s, Bitmap bmp) => bmp -> s -> Either String bmp

-- | Encode a bitmap
--   
--   An implementation can choose the most efficient or appropriate format
--   by placing its encoder first in its list of encoders.
encodeComplete :: (Stringy s, Bitmap bmp) => bmp -> s

-- | Decode a bitmap
--   
--   The result of first decoder of the implementation that succeeds will
--   be returned. If none succeed, <a>Nothing</a> is returned.
decodeComplete :: (Stringy s, Bitmap bmp) => s -> Maybe (CompleteBitmapFormat, bmp)

-- | Encode the pixels of a bitmap
--   
--   An implementation can choose the most efficient or appropriate format
--   by placing its encoder first in its list of encoders.
encodeImage :: (Stringy s, Bitmap bmp) => bmp -> s

-- | Decode the pixels of a bitmap
--   
--   The result of first decoder of the implementation that succeeds will
--   be returned. If none succeed, <a>Nothing</a> is returned.
decodeImage :: (Stringy s, Bitmap bmp) => bmp -> s -> Maybe (ImageBitmapFormat, bmp)

-- | Encode a bitmap in a particular format
encodeCompleteFmt :: (Stringy s, Bitmap bmp) => CompleteBitmapFormat -> bmp -> s

-- | Decode a bitmap in a particular format
decodeCompleteFmt :: (Stringy s, Bitmap bmp) => CompleteBitmapFormat -> s -> Either String bmp

-- | Encode the pixels of a bitmap in a particular format
encodeImageFmt :: (Stringy s, Bitmap bmp) => ImageBitmapFormat -> bmp -> s

-- | Decode the pixels of a bitmap in a particular format
decodeImageFmt :: (Stringy s, Bitmap bmp) => ImageBitmapFormat -> bmp -> s -> Either String bmp

-- | Decode an image with the given dimensions
--   
--   This is only guaranteed to work on implementations and formats that
--   only need dimensions in addition to the raw pixel data. This is
--   convenient because most often the dimensions are all that is needed.
--   
--   Currently, this function works by constructing a bitmap with the given
--   dimensions and with each pixel set to the least intensity. Thus it is
--   significantly more efficient if this is used with a bitmap that
--   doesn't strictly evaluate the entire pixel data when the structure is
--   first constructed (not necessarily when any pixel is accessed)
--   (currently none of the bitmap types exported in this library are so
--   strict), as the bitmap will not need to be fully evaluated; only the
--   dimensions will be used.
decodeImageDimensions :: (Stringy s, Bitmap bmp) => Dimensions (BIndexType bmp) -> s -> Maybe (ImageBitmapFormat, bmp)

-- | Decode an image with the given dimensions as
--   <a>decodeImageDimensions</a> does it, but in a specific format
decodeImageDimensionsFmt :: (Stringy s, Bitmap bmp) => ImageBitmapFormat -> Dimensions (BIndexType bmp) -> s -> Either String bmp

-- | Determine whether the seconds dimensions passed can fit within the
--   first dimensions passed
--   
--   If the width or height of the second dimensions exceeds those of first
--   dimensions, <a>False</a> is returned.
dimensionsFit :: Integral a => Dimensions a -> Dimensions a -> Bool

-- | Returns the width of a bitmap
bitmapWidth :: Bitmap bmp => bmp -> BIndexType bmp

-- | Returns the height of a bitmap
bitmapHeight :: Bitmap bmp => bmp -> BIndexType bmp

module Data.Bitmap.Array.Internal

-- | Arrays of 32-bit RGBA pixels
newtype BitmapArray
BitmapArray :: UArray (Integer, Integer) Word32 -> BitmapArray
unwrapBitmapArray :: BitmapArray -> UArray (Integer, Integer) Word32
instance Eq BitmapArray
instance Ord BitmapArray
instance Binary BitmapArray
instance Serialize BitmapArray
instance Bitmap BitmapArray
instance Show BitmapArray


-- | Bitmaps as unboxed arrays of 32-bit RGBA pixels
--   
--   These bitmaps are generally less efficient than
--   <tt>BitmapString</tt>s, but can be arbitrarily large (if having
--   dimensions larger than the bound of <a>Int</a> is really so useful),
--   and have the advantages of being stored in an array.
module Data.Bitmap.Array

-- | Arrays of 32-bit RGBA pixels
data BitmapArray
bitmapArrayToArray :: BitmapArray -> UArray (Integer, Integer) Word32
bitmapArrayToBitmapArray :: UArray (Integer, Integer) Word32 -> BitmapArray

module Data.Bitmap.Croppable

-- | Class for bitmaps that can be rectangularly cropped into (possibly)
--   smaller sizes
--   
--   Using the functions of the <a>Bitmap</a> class, default functions are
--   be defined for each of these; of course, implementations are free to
--   write more efficient versions.
class Bitmap bmp => BitmapCroppable bmp where crop super (cropRow, cropColumn) = constructPixels (\ (row, column) -> getPixel super (row + cropRow, column + cropColumn))
crop :: BitmapCroppable bmp => bmp -> Coordinates (BIndexType bmp) -> Dimensions (BIndexType bmp) -> bmp
instance [overlap ok] Bitmap a => BitmapCroppable a

module Data.Bitmap.Reflectable

-- | Class for reflectable bitmaps
--   
--   Using the functions of the <a>Bitmap</a> class, default functions are
--   be defined for each of these; of course, implementations are free to
--   write more efficient versions.
class Bitmap bmp => BitmapReflectable bmp where reflectVertically b = constructPixels f dms where dms@(_, height) = dimensions b maxRow = abs . pred $ height f (r, c) = getPixel b (maxRow - r, c) reflectHorizontally b = constructPixels f dms where dms@(width, _) = dimensions b maxColumn = abs . pred $ width f (r, c) = getPixel b (r, maxColumn - c)
reflectVertically :: BitmapReflectable bmp => bmp -> bmp
reflectHorizontally :: BitmapReflectable bmp => bmp -> bmp
instance [overlap ok] Bitmap a => BitmapReflectable a


-- | Wrapping interface for <tt>IOBitmap</tt>s as defined by the "bitmap"
--   package
--   
--   TODO: Add support for "bitmap"'s pure bitmap type. Since this package
--   was originally written, <tt>bitmap</tt> version 0.0.2 was released
--   with new support for using both <tt>IOBitmap</tt>s and pure
--   <tt>Bitmap</tt>s.
module Data.Bitmap.Foreign
type FBBitmapBase = IOBitmap

-- | The foreign bitmap as defined by the "bitmap" package
--   
--   For more information see documentation of the "bitmap" package.
--   
--   NB: this type is actually a reference to a memory location; thus the
--   possible issues with concurrency and referential transparency are
--   introduced.
newtype BitmapForeign
BitmapForeign :: FBBitmapBase PixelComponent -> BitmapForeign
unwrapBitmapForeign :: BitmapForeign -> FBBitmapBase PixelComponent
instance Bitmap BitmapForeign

module Data.Bitmap.Searchable

-- | Class for searchable bitmaps
--   
--   Using the functions of the <a>Bitmap</a> class, default functions are
--   be defined for each of these; of course, implementations are free to
--   define more efficient versions.
class Bitmap bmp => BitmapSearchable bmp where foldrCoords f z base_i@(baseRow, _) (maxRow, maxColumn) bmp = go base_i where maxRow' = min maxRow $ pred (bitmapHeight bmp) maxColumn' = min maxColumn $ pred (bitmapWidth bmp) go i@(row, column) | column > maxColumn' = go (succ row, baseRow) | row > maxRow' = z | otherwise = i `f` go (row, succ column) findPixel f b = findPixelOrder f b (0, 0) findPixelOrder f bmp startCoords = foldrCoords step Nothing startCoords (dimensions bmp) bmp where step coords | f $ getPixel bmp coords = const $ Just coords | otherwise = id findPixelEqual p = findPixelOrder (== p) findPixels f b = r' where (width, height) = dimensions b maxColumn = abs . pred $ width maxRow = abs . pred $ height nextCoordinate (row, column) | column >= maxColumn = (succ row, 0) | otherwise = (row, succ column) r' i = case findPixelOrder f b i of { (Just i'@(row, column)) -> if row < maxRow || column < maxColumn then i' : findPixels f b (nextCoordinate i') else i' : [] (Nothing) -> [] } findPixelsEqual p b = r' where (width, height) = dimensions b maxColumn = abs . pred $ width maxRow = abs . pred $ height nextCoordinate (row, column) | column >= maxColumn = (succ row, 0) | otherwise = (row, succ column) r' i = case findPixelEqual p b i of { (Just i'@(row, column)) -> if row < maxRow || column < maxColumn then i' : findPixelsEqual p b (nextCoordinate i') else i' : [] (Nothing) -> [] } findSubBitmap f super sub = findSubBitmapOrder f super sub (0, 0) findSubBitmapOrder f super sub = r' where r' i@(row, column) | column > maxColumn = r' (succ row, 0) | row > maxRow = Nothing | matches (0, 0) = Just i | otherwise = r' (row, succ column) where matches offi@(offRow, offColumn) | offColumn > maxOffColumn = matches (succ offRow, 0) | offRow > maxOffRow = True | not $ f (getPixel super (row + offRow, column + offColumn)) (getPixel sub offi) = False | otherwise = matches (offRow, succ offColumn) (widthSuper, heightSuper) = dimensions super (widthSub, heightSub) = dimensions sub (maxRow, maxColumn) = (heightSuper - heightSub, widthSuper - widthSub) (maxOffRow, maxOffColumn) = (abs . pred $ heightSub, abs . pred $ widthSub) findSubBitmapEqual = findSubBitmapOrder (==) findSubBitmaps f super sub = r' where (widthSuper, heightSuper) = dimensions super (widthSub, heightSub) = dimensions sub (maxRow, maxColumn) = (heightSuper - heightSub, widthSuper - widthSub) nextCoordinate (row, column) | column >= maxColumn = (succ row, 0) | otherwise = (row, succ column) r' i = case findSubBitmapOrder f super sub i of { (Just i'@(row, column)) -> if row < maxRow || column < maxColumn then i' : findSubBitmaps f super sub (nextCoordinate i') else i' : [] (Nothing) -> [] } findSubBitmapsEqual super sub = r' where (widthSuper, heightSuper) = dimensions super (widthSub, heightSub) = dimensions sub (maxRow, maxColumn) = (heightSuper - heightSub, widthSuper - widthSub) nextCoordinate (row, column) | column >= maxColumn = (succ row, 0) | otherwise = (row, succ column) r' i = case findSubBitmapEqual super sub i of { (Just i'@(row, column)) -> if row < maxRow || column < maxColumn then i' : findSubBitmapsEqual super sub (nextCoordinate i') else i' : [] (Nothing) -> [] } findEmbeddedBitmap allEmbs super (row, column) = r' 0 allEmbs where pixAny = matchPixelAny pixSame = matchPixelSame pixThrs = matchPixelSameThreshold pixDif = matchPixelDif pixDft = matchPixelDifThreshold dimensionsSuper = dimensions super r' _ [] = Nothing r' n (e : es) | True <- dimensionsFit dimensionsSuper (widthSub + column, heightSub + row), True <- matches Nothing [] [] [] (0, 0) = Just $ (n, e) | otherwise = r' (succ n) es where matches matchColor difColors dftColors thrsColors offi@(offRow, offColumn) | offColumn > maxOffColumn = matches matchColor difColors dftColors thrsColors (succ offRow, 0) | offRow > maxOffRow = True | (False, _, _, _, _) <- posCondition = False | (_, matchColor', difColors', dftColors', thrsColors') <- posCondition = matches matchColor' difColors' dftColors' thrsColors' (offRow, succ offColumn) where posCondition | subPixel == pixAny = (True, matchColor, difColors, dftColors, thrsColors) | True <- subPixel == pixSame, (Just matchColor') <- matchColor = (superPixel == matchColor', matchColor, difColors, dftColors,  thrsColors) | True <- subPixel == pixSame = ((not $ superPixel `elem` difColors) && (not $ any (`areColorsSimilar` superPixel) dftColors) && (all (`areColorsSimilar` superPixel) thrsColors),  Just superPixel, [], [], []) | True <- subPixel == pixDif, (Just matchColor') <- matchColor = (superPixel /= matchColor', matchColor, difColors, dftColors,  thrsColors) | True <- subPixel == pixDif = (True, matchColor, nub $ superPixel : difColors, dftColors,  thrsColors) | True <- subPixel == pixDft, (Just matchColor') <- matchColor = (not $ superPixel `areColorsSimilar` matchColor', matchColor,  difColors, dftColors, thrsColors) | True <- subPixel == pixDft = (True, matchColor, difColors, nub $ superPixel : dftColors,  thrsColors) | True <- subPixel == pixThrs, (Just matchColor') <- matchColor = (superPixel `areColorsSimilar` matchColor', matchColor,  difColors, dftColors, thrsColors) | True <- subPixel == pixThrs = (True, matchColor, difColors, dftColors,  nub $ superPixel : thrsColors) | otherwise = (False, matchColor, difColors, dftColors, thrsColors) where superPixel = getPixel super (row + offRow, column + offColumn) subPixel = getPixel e offi (widthSub, heightSub) = dimensions e (maxOffRow, maxOffColumn) = (abs . pred $ heightSub, abs . pred $ widthSub) findEmbeddedBitmapString f z allEmbs super = go where go pos@(row, column) = case findEmbeddedBitmap allEmbs super pos of { (Nothing) -> z (Just r@(_, bmp)) -> r `f` go (row, column + (max 1 $ bitmapWidth bmp)) } findFixedEmbeddedBitmapString (extraRowsW, extraColumnsW) allEmbs super base_i@(base_row, base_column) = foldrCoords step zero base_i (base_row + extraRows, base_column + extraColumns) super where maxRow = abs . pred $ bitmapHeight super maxColumn = abs . pred $ bitmapWidth super maxExtraRows = maxRow - base_row maxExtraColumns = maxColumn - base_column extraRows = maybe maxExtraRows (max 0 . min maxExtraRows) extraRowsW extraColumns = maybe maxExtraColumns (max 0 . min maxExtraColumns) extraColumnsW zero = Nothing step i a | textFound i = Just i | otherwise = a textFound = go allEmbs go [] _ = True go (e : es) i@(row, column) | (Just (_ :: Int, _)) <- findEmbeddedBitmap [e] super i = go es (row, column + bitmapWidth e) | otherwise = False
foldrCoords :: BitmapSearchable bmp => (Coordinates (BIndexType bmp) -> a -> a) -> a -> Coordinates (BIndexType bmp) -> Coordinates (BIndexType bmp) -> bmp -> a
findPixel :: BitmapSearchable bmp => (BPixelType bmp -> Bool) -> bmp -> Maybe (Coordinates (BIndexType bmp))
findPixelOrder :: BitmapSearchable bmp => (BPixelType bmp -> Bool) -> bmp -> Coordinates (BIndexType bmp) -> Maybe (Coordinates (BIndexType bmp))
findPixelEqual :: BitmapSearchable bmp => BPixelType bmp -> bmp -> Coordinates (BIndexType bmp) -> Maybe (Coordinates (BIndexType bmp))
findPixels :: BitmapSearchable bmp => (BPixelType bmp -> Bool) -> bmp -> Coordinates (BIndexType bmp) -> [Coordinates (BIndexType bmp)]
findPixelsEqual :: BitmapSearchable bmp => BPixelType bmp -> bmp -> Coordinates (BIndexType bmp) -> [Coordinates (BIndexType bmp)]
findSubBitmap :: BitmapSearchable bmp => (BPixelType bmp -> BPixelType bmp -> Bool) -> bmp -> bmp -> Maybe (Coordinates (BIndexType bmp))
findSubBitmapOrder :: BitmapSearchable bmp => (BPixelType bmp -> BPixelType bmp -> Bool) -> bmp -> bmp -> Coordinates (BIndexType bmp) -> Maybe (Coordinates (BIndexType bmp))
findSubBitmapEqual :: BitmapSearchable bmp => bmp -> bmp -> Coordinates (BIndexType bmp) -> Maybe (Coordinates (BIndexType bmp))
findSubBitmaps :: BitmapSearchable bmp => (BPixelType bmp -> BPixelType bmp -> Bool) -> bmp -> bmp -> Coordinates (BIndexType bmp) -> [(Coordinates (BIndexType bmp))]
findSubBitmapsEqual :: BitmapSearchable bmp => bmp -> bmp -> Coordinates (BIndexType bmp) -> [(Coordinates (BIndexType bmp))]
findEmbeddedBitmap :: (BitmapSearchable bmp, Integral i) => [bmp] -> bmp -> Coordinates (BIndexType bmp) -> Maybe (i, bmp)
findEmbeddedBitmapString :: (BitmapSearchable bmp, Integral i) => ((i, bmp) -> a -> a) -> a -> [bmp] -> bmp -> Coordinates (BIndexType bmp) -> a
findFixedEmbeddedBitmapString :: BitmapSearchable bmp => Dimensions (Maybe (BIndexType bmp)) -> [bmp] -> bmp -> Coordinates (BIndexType bmp) -> Maybe (Coordinates (BIndexType bmp))

-- | Binary similarity comparison
--   
--   This function considers two colors to be "similar" if their difference
--   according to the CIE94 algorithm (see <a>colorDifferenceCIE94</a>) is
--   less than 23.
areColorsSimilar :: Pixel p => p -> p -> Bool

-- | Approximate difference in color according to the CIE94 algorithm
colorDifferenceCIE94 :: (Pixel p, RealFloat n, Ord n) => p -> p -> n

-- | Default transparent pixel value; FF007E
defaultTransparentPixel :: Pixel p => p
matchPixelAny :: Pixel p => p
matchPixelSame :: Pixel p => p
matchPixelSameThreshold :: Pixel p => p
matchPixelDif :: Pixel p => p
matchPixelDifThreshold :: Pixel p => p
instance [overlap ok] Bitmap a => BitmapSearchable a

module Data.Bitmap.Function.Internal
data BitmapFunction
BitmapFunction :: Dimensions Integer -> (Coordinates Integer -> PixelRGBA) -> BitmapFunction
_bmpf_dimensions :: BitmapFunction -> Dimensions Integer
_bmpf_getPixel :: BitmapFunction -> Coordinates Integer -> PixelRGBA
bmpf_dimensions :: ArrowApply cat => Lens cat BitmapFunction (Dimensions Integer)
bmpf_getPixel :: ArrowApply cat => Lens cat BitmapFunction (Coordinates Integer -> PixelRGBA)
instance Bitmap BitmapFunction


-- | Bitmaps defined by functions
module Data.Bitmap.Function
data BitmapFunction

module Data.Bitmap.String.Internal

-- | A bitmap represented as a string or stored as bytes
--   
--   By default, the RGB32 format (where the most significant byte, the
--   head-most one, is unused) is used.
--   
--   The bitmap must be stored by pixels not separated by component. Each
--   pixel must contain at least the red, blue, and green component, each
--   one byte wide (bytes are assumed to be octets), either in that order
--   or reversed. There may be an alpha component either immediately before
--   the other three components or immediately after. Thus there are four
--   possible arrangements of components for each pixel, which must be
--   consistent for every pixel. Any amount of padding or unused bytes is
--   permitted before each pixel, but the amount must be fixed. The same is
--   true also after each pixel.
--   
--   This type is most efficient with lazy bytestrings.
data BitmapString
BitmapString :: GenString -> Dimensions (BIndexType BitmapString) -> Int -> Bool -> Maybe Bool -> Int -> Int -> Bool -> Bool -> Int -> Int -> Int -> Int -> BitmapString

-- | Bitmap data; it is assumed to be large enough
_bmps_data :: BitmapString -> GenString

-- | Width and height of the data; <a>bmps_rowFromBeg</a>, etc. need to be
--   taken account for the dimensions of the bitmap
_bmps_dimensions :: BitmapString -> Dimensions (BIndexType BitmapString)

-- | Each row is aligned to this many bytes; when necessary, null bytes are
--   added to each row
_bmps_rowAlignment :: BitmapString -> Int

-- | Whether the red component is first; if <a>True</a>, the order of the
--   components is red, green, blue; otherwise, it is blue, green, red
_bmps_redHead :: BitmapString -> Bool

-- | If <a>Nothing</a>, then there is no alpha component; otherwise, if
--   <a>True</a>, it is before the other three components (towards the
--   head) <i> most significant </i> first, otherwise, it is after the
--   other three components <i> towards the tail </i> least significant /
--   last of the four components
_bmps_alphaHead :: BitmapString -> Maybe Bool

-- | Number of unused bytes before each pixel
_bmps_paddingHead :: BitmapString -> Int

-- | Number of unused bytes after each pixel
_bmps_paddingTail :: BitmapString -> Int

-- | Is the first row at the top?
_bmps_rowFromTop :: BitmapString -> Bool

-- | Is the first column in each row at the left?
_bmps_columnFromLeft :: BitmapString -> Bool

-- | How many rows of data to skip from the beginning (from *first* row);
--   used in cropping
_bmps_rowFromBeg :: BitmapString -> Int

-- | How many rows of data to skip from the end; used in cropping
_bmps_rowFromEnd :: BitmapString -> Int
_bmps_columnFromBeg :: BitmapString -> Int
_bmps_columnFromEnd :: BitmapString -> Int
bmps_data :: ArrowApply cat => Lens cat BitmapString GenString
bmps_dimensions :: ArrowApply cat => Lens cat BitmapString (Dimensions (BIndexType BitmapString))
bmps_rowAlignment :: ArrowApply cat => Lens cat BitmapString Int
bmps_redHead :: ArrowApply cat => Lens cat BitmapString Bool
bmps_alphaHead :: ArrowApply cat => Lens cat BitmapString (Maybe Bool)
bmps_paddingHead :: ArrowApply cat => Lens cat BitmapString Int
bmps_paddingTail :: ArrowApply cat => Lens cat BitmapString Int
bmps_rowFromTop :: ArrowApply cat => Lens cat BitmapString Bool
bmps_columnFromLeft :: ArrowApply cat => Lens cat BitmapString Bool
bmps_rowFromBeg :: ArrowApply cat => Lens cat BitmapString Int
bmps_rowFromEnd :: ArrowApply cat => Lens cat BitmapString Int
bmps_columnFromBeg :: ArrowApply cat => Lens cat BitmapString Int
bmps_columnFromEnd :: ArrowApply cat => Lens cat BitmapString Int
formatEq :: BitmapString -> BitmapString -> Bool

-- | Default <a>BitmapString</a> format
--   
--   This is equivalent to <a>IBF_BGRU32</a>
defaultBSFormat :: BitmapString

-- | Return (rowSize, paddingSize) based on width, bytes per pixel, and
--   alignment
--   
--   Be careful when using the results of this function that you're
--   actually using the right value.
rowPadding :: BIndexType BitmapString -> Int -> Int -> (Int, Int)
bytesPerPixel :: BitmapString -> Int

-- | Return (rowSize, paddingSize)
--   
--   Be careful when using the results of this function that you're
--   actually using the right value.
rowPaddingBS :: BitmapString -> (Int, Int)
rgbOffsets :: BitmapString -> (Int, Int, Int)
alphaOffset :: BitmapString -> Maybe Int

-- | Get part of a pixel as a cell of <tt>GenStringDefault</tt>
--   
--   The bitmap passed is only used for its format; its dimensions and data
--   are not used. This function doesn't return any alpha parts; for those
--   it returns pad bytes, which are zero.
pixelPart :: BitmapString -> BPixelType BitmapString -> Int -> StringCellChar GenStringDefault
imageSizeBS :: BitmapString -> Int

-- | Construct a bitmap in the format of the meta bitmap passed
--   
--   Only the format fields of the bitmap is used, so the data and
--   dimensions of it can be <a>undefined</a>.
--   
--   The data in the new bitmap is what <tt>GenStringDefault</tt> is
--   aliased to.
constructBitmapStringFormatted :: BitmapString -> Dimensions (BIndexType BitmapString) -> (Coordinates (BIndexType BitmapString) -> BPixelType BitmapString) -> BitmapString
bitmapFmtBGR24A4VR :: BitmapString
bitmapFmtRGB24A4VR :: BitmapString
bitmapFmtRGB24A4 :: BitmapString
bitmapFmtRGB32 :: BitmapString

-- | Used by the encoders
encodeBSFormat :: Stringy s => BitmapString -> (BitmapString -> s)
encodeIBF_BGR24A4VR' :: Stringy s => BitmapString -> s
encodeIBF_RGB24A4VR' :: Stringy s => BitmapString -> s
encodeIBF_RGB24A4' :: Stringy s => BitmapString -> s
encodeIBF_RGB32' :: Stringy s => BitmapString -> s

-- | Used by the decoders
tryBSFormat :: Stringy s => String -> BitmapString -> (BitmapString -> s -> Either String BitmapString)
tryIBF_BGR24A4VR' :: Stringy s => BitmapString -> s -> Either String BitmapString
tryIBF_RGB24A4VR' :: Stringy s => BitmapString -> s -> Either String BitmapString
tryIBF_RGB24A4' :: Stringy s => BitmapString -> s -> Either String BitmapString
tryIBF_RGB32' :: Stringy s => BitmapString -> s -> Either String BitmapString
instance BitmapCroppable BitmapString
instance BitmapReflectable BitmapString
instance Bitmap BitmapString
instance Serialize BitmapString
instance Binary BitmapString


-- | Bitmaps represented as strings
--   
--   The module provides polymorphic support for representation of bitmaps
--   as strings. This module is designed to be most efficient with lazy
--   bytestrings.
module Data.Bitmap.String

-- | A bitmap represented as a string or stored as bytes
--   
--   By default, the RGB32 format (where the most significant byte, the
--   head-most one, is unused) is used.
--   
--   The bitmap must be stored by pixels not separated by component. Each
--   pixel must contain at least the red, blue, and green component, each
--   one byte wide (bytes are assumed to be octets), either in that order
--   or reversed. There may be an alpha component either immediately before
--   the other three components or immediately after. Thus there are four
--   possible arrangements of components for each pixel, which must be
--   consistent for every pixel. Any amount of padding or unused bytes is
--   permitted before each pixel, but the amount must be fixed. The same is
--   true also after each pixel.
--   
--   This type is most efficient with lazy bytestrings.
data BitmapString


-- | Super module of bitmaps
--   
--   For functions that expect two bitmaps or otherwise two parameters
--   based on two bitmaps (such as dimensions) to be passed, this library's
--   convention is to accept the "super" bitmap or the larger / main bitmap
--   first and the "sub" bitmap second.
module Data.Bitmap.BMP

module Data.Bitmap.StringRGB24A4VR.Internal

-- | Container for a string that represents a sequence of raw pixels
--   lacking the alpha component and that is stored upside down
data BitmapImageString
BitmapImageString :: s -> BitmapImageString
_polyval_bitmapImageString :: BitmapImageString -> s

-- | A bitmap represented as a string
--   
--   This is essentially the format of pixels in the BMP format in which
--   each row is aligned to a four-byte boundry and each row contains a
--   series of RGB pixels.
--   
--   This type is most efficient for programs interacting heavily with BMP
--   files.
data BitmapStringRGB24A4VR
BitmapStringRGB24A4VR :: (Int, Int) -> BitmapImageString -> BitmapStringRGB24A4VR

-- | Width and height of the bitmap
_bmps_dimensions :: BitmapStringRGB24A4VR -> (Int, Int)

-- | Data stored in a string
_bmps_data :: BitmapStringRGB24A4VR -> BitmapImageString
bmps_dimensions :: ArrowApply cat => Lens cat BitmapStringRGB24A4VR (Int, Int)
bmps_data :: ArrowApply cat => Lens cat BitmapStringRGB24A4VR BitmapImageString

-- | Return (rowSize, paddingSize) based on width, bytes per pixel, and
--   alignment
bytesPerRow :: Int -> Int -> Int -> (Int, Int)
bitmapStringBytesPerRow :: BitmapStringRGB24A4VR -> (Int, Int)
widthPadding :: Int -> String
encodeIBF_RGB24A4VR' :: StringCells s => BitmapStringRGB24A4VR -> s
tryIBF_RGB24A4VR' :: StringCells s => BitmapStringRGB24A4VR -> s -> Either String BitmapStringRGB24A4VR
padByte :: Word8
imageSize :: Dimensions Int -> Int
instance BitmapReflectable BitmapStringRGB24A4VR
instance BitmapSearchable BitmapStringRGB24A4VR
instance Bitmap BitmapStringRGB24A4VR
instance Serialize BitmapStringRGB24A4VR
instance Binary BitmapStringRGB24A4VR
instance Eq BitmapImageString


-- | This bitmap type is deprecated; use <a>String</a> instead
--   
--   Bitmaps represented as strings
--   
--   The module provides polymorphic support for representation of bitmaps
--   as strings. This module is designed to be most efficient with lazy
--   bytestrings.

-- | <i>Deprecated: Use Data.Bitmap.String instead</i>
module Data.Bitmap.StringRGB24A4VR

-- | A bitmap represented as a string
--   
--   This is essentially the format of pixels in the BMP format in which
--   each row is aligned to a four-byte boundry and each row contains a
--   series of RGB pixels.
--   
--   This type is most efficient for programs interacting heavily with BMP
--   files.
data BitmapStringRGB24A4VR

module Data.Bitmap.StringRGB32.Internal

-- | Polymorphic container of a string
data BitmapImageString
BitmapImageString :: s -> BitmapImageString
_polyval_bitmapImageString :: BitmapImageString -> s

-- | A bitmap represented as a string, which contains a series of aligned
--   rows, which themselves consist of a series of pixels stored in 4 bytes
--   in which the most significant byte is unused (thus the rows are always
--   aligned to a four-byte boundary)
data BitmapStringRGB32
BitmapStringRGB32 :: (Int, Int) -> BitmapImageString -> BitmapStringRGB32

-- | Width and height of the bitmap
_bmps_dimensions :: BitmapStringRGB32 -> (Int, Int)

-- | Data stored in a string
_bmps_data :: BitmapStringRGB32 -> BitmapImageString
bmps_dimensions :: ArrowApply cat => Lens cat BitmapStringRGB32 (Int, Int)
bmps_data :: ArrowApply cat => Lens cat BitmapStringRGB32 BitmapImageString
encodeIBF_RGB32' :: StringCells s => BitmapStringRGB32 -> s
tryIBF_RGB32' :: StringCells s => BitmapStringRGB32 -> s -> Either String BitmapStringRGB32
padByte :: Word8
instance BitmapReflectable BitmapStringRGB32
instance BitmapSearchable BitmapStringRGB32
instance Bitmap BitmapStringRGB32
instance Serialize BitmapStringRGB32
instance Binary BitmapStringRGB32
instance Eq BitmapImageString


-- | This bitmap type is deprecated; use <a>String</a> instead
--   
--   | Bitmaps represented as strings
--   
--   The module provides polymorphic support for representation of bitmaps
--   as strings. This module is designed to be most efficient with lazy
--   bytestrings.

-- | <i>Deprecated: Use Data.Bitmap.String instead</i>
module Data.Bitmap.StringRGB32

-- | A bitmap represented as a string, which contains a series of aligned
--   rows, which themselves consist of a series of pixels stored in 4 bytes
--   in which the most significant byte is unused (thus the rows are always
--   aligned to a four-byte boundary)
data BitmapStringRGB32
