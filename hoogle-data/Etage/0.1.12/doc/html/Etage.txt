-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A general data-flow framework
--   
--   A general data-flow framework featuring nondeterminism, laziness and
--   neurological pseudo-terminology. It can be used for example for
--   data-flow computations or event propagation networks. It tries hard to
--   aide type checking and to allow proper initialization and cleanup so
--   that interfaces to input and output devices (data or events producers
--   or consumers) can be made (so that created models/systems/networks can
--   be used directly in real world applications, for example robots).
--   
--   Its main goal is to model complex neural networks with more biological
--   realism. Namely that impulses do take time to travel and neuron
--   responses are also not instantaneous. And of course that neural
--   systems are in its base nondeterministic and that some level of
--   determinism is build upon that. All this of course makes reasoning
--   about such networks even harder (impossible?).
--   
--   This framework is in fact just a simple abstraction of Haskell threads
--   and data passing between them through channels with threads'
--   initialization and cleanup wrapped into a Haskell type class.
--   
--   Feel free to contribute or suggest additional features or (example)
--   programs or to create interfaces to other modules.
@package Etage
@version 0.1.12


-- | This data-flow framework consists mainly of <a>Neuron</a>s which are
--   data processing units in data-flow network, receiving and sending
--   <a>Impulse</a>s over bidirectional <a>Nerve</a>s <a>attach</a>ed to
--   each other. <a>Neuron</a>s and <a>Nerve</a>s are best <a>grow</a>n in
--   <a>Incubation</a> monad, which takes care of proper <a>grow</a>ing and
--   <a>dissolve</a>-ing of <a>Neuron</a>s. It comes with some example
--   <a>Neuron</a>s but you should probably define your own.
module Control.Etage

-- | Runs an <a>Incubation</a>, <a>grow</a>ing <a>Neuron</a>s and
--   <a>attach</a>ing <a>Nerve</a>s and after that waiting for them to
--   finish and cleanup. It rethrows any exception which might have been
--   thrown.
incubate :: Incubation () -> IO ()

-- | Grows a <a>Neuron</a>, taking a function which changes default options
--   and returning a <a>Nerve</a> <a>attach</a>ed to the <a>Neuron</a>.
--   
--   Internally it combines <a>growNerve</a> and <a>attach</a>.
growNeuron :: (Neuron n, GrowAxon (Axon (NeuronFromImpulse n) fromConductivity), GrowAxon (Axon (NeuronForImpulse n) forConductivity)) => (NeuronOptions n -> NeuronOptions n) -> Incubation (Nerve (NeuronFromImpulse n) fromConductivity (NeuronForImpulse n) forConductivity)

-- | Attaches a <a>Nerve</a> to other <a>Nerve</a>s so that <a>Impulse</a>s
--   send from the <a>Neuron</a> over the first <a>Nerve</a> are received
--   by <a>Neuron</a>s of other <a>Nerve</a>s. <a>Impulse</a>s are
--   <a>propagate</a>d only in this direction, not in the other. If you
--   want also the other direction use <a>attachTo</a> again for that
--   direction. <a>attachTo</a> takes care of all the details (like
--   branching <a>Nerve</a>s as necessary).
--   
--   Be careful if you are attaching the same <a>Nerve</a> multiple times
--   as some <a>Impulse</a>s might already been <a>propagate</a>d and thus
--   are not available anymore to later attached <a>Nerve</a>s. Just list
--   all destination <a>Nerve</a>s the first time.
--   
--   Internally it uses <a>propagate</a>.
attachTo :: (Impulse from, Impulse for) => Nerve from AxonConductive for forConductivity -> [TranslatableFor from] -> Incubation ()

-- | Fuses <a>Impulse</a>s received from given <a>Nerve</a>s using the
--   given function, sending them over the resulting <a>grow</a>n
--   <a>Nerve</a>. <a>fuseWith</a> takes care of all the details (like
--   branching <a>Nerve</a>s as necessary).
--   
--   The important aspect of <a>fuse</a>-ing is its synchronization
--   behavior, as it requires exactly one <a>Impulse</a> from each given
--   <a>Nerve</a> at a time to <a>fuse</a> them together. So it is
--   important that all given <a>Nerve</a>s have more or less the equal
--   density of <a>Impulse</a>s, otherwise queues of some <a>Nerve</a>s
--   will grow unproportionally because of the stalled <a>Impulse</a>s,
--   causing at least a memory leak.
--   
--   <tt>impulseFuser</tt> helper function can maybe help you with defining
--   fusing function. <a>fuseWith</a> uses type of the given function to
--   construct type of the resulting <a>Nerve</a> so probably too
--   polymorphic type will give you problems.
--   
--   For example, <a>fuse</a>-ing by <a>sum</a>ing two <a>Impulse</a>s
--   together can be achived like this:
--   
--   <pre>
--   incubate $ do
--     nerveRandom1 &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) defaultOptions
--     nerveRandom2 &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) defaultOptions
--     nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) defaultOptions
--     
--     nerveFused &lt;- [TranslatableFrom nerveRandom1, TranslatableFrom nerveRandom2] `fuseWith` (impulseFuser ((: []) . sum . concat))
--     
--     nerveFused `attachTo` [TranslatableFor nerveDump]
--   </pre>
--   
--   Internally it uses <a>fuse</a>.
fuseWith :: (Impulse i, Impulse j) => [TranslatableFrom i] -> (ImpulseTime -> [i] -> [j]) -> Incubation (Nerve (FuseFromImpulse i j) AxonConductive (FuseForImpulse i j) AxonNonConductive)

-- | Type which helps you define (fix) a type of the <a>growNeuron</a>
--   function so that compiler knows whith <a>Neuron</a> instance to
--   choose. It takes type of the <a>Neuron</a> you want to <a>grow</a> as
--   an argument and specifies a <a>Nerve</a> which is conductive in both
--   directions.
type NerveBoth n = (NeuronOptions n -> NeuronOptions n) -> Incubation (Nerve (NeuronFromImpulse n) AxonConductive (NeuronForImpulse n) AxonConductive)

-- | Type which helps you define (fix) a type of the <a>growNeuron</a>
--   function so that compiler knows whith <a>Neuron</a> instance to
--   choose. It takes type of the <a>Neuron</a> you want to <a>grow</a> as
--   an argument and specifies a <a>Nerve</a> which is not conductive in
--   any directions.
type NerveNone n = (NeuronOptions n -> NeuronOptions n) -> Incubation (Nerve (NeuronFromImpulse n) AxonNonConductive (NeuronForImpulse n) AxonNonConductive)

-- | Type which helps you define (fix) a type of the <a>growNeuron</a>
--   function so that compiler knows whith <a>Neuron</a> instance to
--   choose. It takes type of the <a>Neuron</a> you want to <a>grow</a> as
--   an argument and specifies a <a>Nerve</a> which is conductive only in
--   the direction from the <a>Neuron</a>.
type NerveOnlyFrom n = (NeuronOptions n -> NeuronOptions n) -> Incubation (Nerve (NeuronFromImpulse n) AxonConductive (NeuronForImpulse n) AxonNonConductive)

-- | Type which helps you define (fix) a type of the <a>growNeuron</a>
--   function so that compiler knows whith <a>Neuron</a> instance to
--   choose. It takes type of the <a>Neuron</a> you want to <a>grow</a> as
--   an argument and specifies a <a>Nerve</a> which is conductive only in
--   the direction to the <a>Neuron</a>.
type NerveOnlyFor n = (NeuronOptions n -> NeuronOptions n) -> Incubation (Nerve (NeuronFromImpulse n) AxonNonConductive (NeuronForImpulse n) AxonConductive)

-- | An <a>Incubation</a> monad type. It makes sure network is <a>grow</a>n
--   properly and that everything is cleaned up as necessary.
data Incubation a

-- | Grows an unattached <a>Nerve</a>. By specifying type of the
--   <a>Nerve</a> you can specify conductivity of both directions (which is
--   then type checked for consistency around the program) and thus specify
--   which <a>Impulse</a>s you are interested in (and thus limit possible
--   memory leak). With type of <a>Impulse</a>s this <a>Nerve</a> is
--   capable of conducting you can also specify which <tt>Neuron</tt> you
--   are interested in <tt>grow</tt>ing on the one end of the <a>Nerve</a>.
--   
--   For example, you could grow a <a>Nerve</a> for
--   <a>Control.Etage.Sequence</a> <tt>Neuron</tt> and <tt>Neuron</tt>
--   itself like this:
--   
--   <pre>
--   nerve &lt;- growNerve :: IO (Nerve (SequenceFromImpulse Int) AxonConductive (SequenceForImpulse Int) AxonNonConductive)
--   neuron &lt;- attach defaultOptions nerve
--   </pre>
--   
--   and for example print all <a>Impulse</a>s as they are coming in:
--   
--   <pre>
--   print =&lt;&lt; getContentsFromNeuron nerve
--   </pre>
--   
--   Check <tt>growNeuron</tt> for a more high-level function (of
--   <tt>Incubation</tt>) which both <tt>grow</tt>s a <tt>Neuron</tt> and
--   corresponding <a>Nerve</a> taking care of all the details. Use this
--   function only if you need decoupled <tt>grow</tt>ing.
growNerve :: (Impulse from, Impulse for, GrowAxon (Axon from fromConductivity), GrowAxon (Axon for forConductivity)) => IO (Nerve from fromConductivity for forConductivity)

-- | It <a>grow</a>s an internal <a>Neuron</a> which <a>propagate</a>s
--   <a>Impulse</a>s from a given <a>Nerve</a> to other <a>Nerve</a>s,
--   <a>translate</a>-ing as necessary.
--   
--   Be careful if you are <a>propagate</a>-ing the same <a>Nerve</a>
--   multiple times as some <a>Impulse</a>s might already been
--   <a>propagate</a>d and thus are not available anymore to later
--   <a>propagate</a>d <a>Nerve</a>s. Just list all destination
--   <a>Nerve</a>s the first time.
--   
--   Check <tt>attachTo</tt> for a more high-level function (of
--   <tt>Incubation</tt>) taking care of all the details (like branching
--   <a>Nerve</a>s as necessary). Use this function only if you are dealing
--   with <a>grow</a>ing and <a>attach</a>ing of <a>Nerve</a>s directly.
propagate :: (Impulse from, Impulse for) => Nerve from AxonConductive for forConductivity -> [TranslatableFor from] -> IO ()

-- | It <a>grow</a>s an internal <a>Neuron</a> which <a>fuse</a>s
--   <a>Impulse</a>s received from given <a>Nerve</a>s using the given
--   function, sending them over the resulting <a>grow</a>n <a>Nerve</a>,
--   <a>translate</a>-ing received <a>Impulse</a>s as necessary.
--   
--   The important aspect of <a>fuse</a>-ing is its synchronization
--   behavior, as it requires exactly one <a>Impulse</a> from each given
--   <a>Nerve</a> at a time to <a>fuse</a> them together. So it is
--   important that all given <a>Nerve</a>s have more or less the equal
--   density of <a>Impulse</a>s, otherwise queues of some <a>Nerve</a>s
--   will grow unproportionally because of the stalled <a>Impulse</a>s,
--   causing at least a memory leak.
--   
--   <tt>impulseFuser</tt> helper function can maybe help you with defining
--   fusing function. <tt>fuseWith</tt> uses type of the given function to
--   construct type of the resulting <a>Nerve</a> so probably too
--   polymorphic type will give you problems.
--   
--   Check <tt>fuseWith</tt> for a more high-level function (of
--   <tt>Incubation</tt>) taking care of all the details (like branching
--   <a>Nerve</a>s as necessary). Use this function only if you are dealing
--   with <a>grow</a>ing and <a>attach</a>ing of <a>Nerve</a>s directly.
fuse :: (Impulse i, Impulse j) => [TranslatableFrom i] -> (ImpulseTime -> [i] -> [j]) -> IO (Nerve (FuseFromImpulse i j) AxonConductive (FuseForImpulse i j) AxonNonConductive)

-- | Branches <a>Nerve</a> on the <a>Neuron</a> side. This allows multiple
--   <a>Neuron</a>s to be attached to it and still receive all
--   <a>Impulse</a>s (otherwise just the first <a>Neuron</a> which would
--   read from a <a>Nerve</a> would receive a given <a>Impulse</a>). Only
--   new <a>Impulse</a>s from a moment of branching on are conducted over
--   new the branch, old <a>Impulse</a>s are not reconducted. Branching can
--   be applied multiple times.
branchNerveFor :: Nerve from fromConductivity for AxonConductive -> IO (Nerve from fromConductivity for AxonConductive)

-- | Branches <a>Nerve</a> on the other (non-<a>Neuron</a>) side. This
--   allows using the same <a>Nerve</a> at multiple parts of the network
--   (program) and still receive all <a>Impulse</a>s from <a>Neuron</a> at
--   all parts of the network (otherwise just the first read from a
--   <a>Nerve</a> would receive a given <a>Impulse</a>). Only new
--   <a>Impulse</a>s from a moment of branching on are conducted over the
--   new branch, old <a>Impulse</a>s are not reconducted. Branching can be
--   applied multiple times.
branchNerveFrom :: Nerve from AxonConductive for forConductivity -> IO (Nerve from AxonConductive for forConductivity)

-- | Branches <a>Nerve</a> on both sides. Same as both
--   <a>branchNerveFor</a> and <a>branchNerveFrom</a>.
branchNerveBoth :: Nerve from AxonConductive for AxonConductive -> IO (Nerve from AxonConductive for AxonConductive)

-- | Crosses axons around in a <a>Nerve</a>. Useful probably only when you
--   want to <tt>attachTo</tt> <a>Nerve</a> so that it looks as
--   <a>Impulse</a>s are comming from a <tt>Neuron</tt> and are not send to
--   a <tt>Neuron</tt>. So in this case you are <tt>attach</tt>ing
--   <a>Nerve</a> in a direction away from a <tt>Neuron</tt> and not
--   towards it, what is a default.
--   
--   For example, you can do something like this:
--   
--   <pre>
--   nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) defaultOptions
--   nerveOnes &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) (\o -&gt; o { valueSource = repeat 1 })
--   nerveTwos &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) (\o -&gt; o { valueSource = repeat 2 })
--   
--   nerveOnes `attachTo` [TranslatableFor (cross nerveTwos)]
--   nerveTwos `attachTo` [TranslatableFor nerveDump]
--   </pre>
--   
--   Of course in this example you could simply <tt>attachTo</tt> both
--   <a>Nerve</a>s to <a>Control.Etage.Dump</a> <tt>Neuron</tt>. So
--   <a>cross</a> is probably useful only when using <a>Nerve</a>s
--   unattached to its <tt>Neuron</tt> (made by <a>growNerve</a>, for
--   example) and/or when using such <a>Nerve</a>s with <tt>Neuron</tt>s
--   which operate on how <a>Impulse</a>s are <tt>propagate</tt>d (or
--   <tt>fuse</tt>d).
cross :: Nerve from fromConductivity for forConductivity -> Nerve for forConductivity from fromConductivity

-- | A type class which defines common methods and data types of
--   <a>Neuron</a>s.
class (Typeable n, Impulse (NeuronFromImpulse n), Impulse (NeuronForImpulse n), Typeable (NeuronFromImpulse n), Typeable (NeuronForImpulse n)) => Neuron n where type family NeuronFromImpulse n type family NeuronForImpulse n data family NeuronOptions n mkDefaultOptions = return undefined getNeuronMapCapability _ = NeuronFreelyMapOnCapability grow _ = return undefined dissolve _ = return () live _ _ = waitForException attach = attach'
mkDefaultOptions :: Neuron n => IO (NeuronOptions n)
getNeuronMapCapability :: Neuron n => NeuronOptions n -> NeuronMapCapability
grow :: Neuron n => NeuronOptions n -> IO n
live :: Neuron n => Nerve (NeuronFromImpulse n) fromConductivity (NeuronForImpulse n) forConductivity -> n -> IO ()
dissolve :: Neuron n => n -> IO ()
attach :: Neuron n => (NeuronOptions n -> NeuronOptions n) -> Nerve (NeuronFromImpulse n) fromConductivity (NeuronForImpulse n) forConductivity -> IO LiveNeuron

-- | Default implementation for <a>attach</a> method. It takes a function
--   which changes default options and returns a <a>LiveNeuron</a> value
--   which can be used for <a>detach</a>ing (and thus <a>dissolve</a>-ing)
--   the <a>Neuron</a>.
--   
--   It changes default options according to a given function, creates
--   thread for a <a>Neuron</a> to live in based on
--   <a>getNeuronMapCapability</a>, <a>grow</a>s a <a>Neuron</a>, runs
--   <a>live</a> and prepares everything for cleanup with <a>dissolve</a>,
--   whether because <a>live</a> finished or because of an exception. In
--   the later case it rethrows an exception in the parent <a>Neuron</a>
--   (or in <tt>Incubation</tt>). It also signals the <a>Neuron</a> has
--   <a>dissolve</a>d for <a>detachAndWait</a> and
--   <a>detachManyAndWait</a>.
attach' :: Neuron n => (NeuronOptions n -> NeuronOptions n) -> Nerve (NeuronFromImpulse n) fromConductivity (NeuronForImpulse n) forConductivity -> IO LiveNeuron

-- | Initiates <a>dissolve</a>-ing of a <a>Neuron</a> by throwing a
--   <a>DissolveException</a>. To be used outside of a <a>Neuron</a>.
detach :: LiveNeuron -> IO ()

-- | Similar to <a>detachAndWait</a> but it also waits <a>Neuron</a> to
--   finish <a>dissolve</a>-ing.
detachAndWait :: LiveNeuron -> IO ()

-- | Similar to <a>detach</a> but for many <a>Neuron</a>s at the same time.
--   It initiates <a>dissolve</a>-ing in the list order.
detachMany :: [LiveNeuron] -> IO ()

-- | Similar to <a>detachAndWait</a> but for many <a>Neuron</a>s at the
--   same time. It first initiates <a>dissolve</a>-ing in the list order
--   and then wait for all <a>Neuron</a>s to finish <a>dissolve</a>-ing.
detachManyAndWait :: [LiveNeuron] -> IO ()

-- | Type representing a <tt>live</tt> <tt>Neuron</tt>.
data LiveNeuron

-- | An exception which initiates <a>dissolve</a>-ing of a <a>Neuron</a>.
--   Should be thrown outside the <a>Neuron</a> to the <a>Neuron</a>. For
--   throwing inside the <a>Neuron</a> use <a>DissolvingException</a> (or
--   simply <a>dissolving</a>).
data DissolveException

-- | Initiates <a>dissolve</a>-ing of a <a>Neuron</a> by throwing a
--   <a>DissolvingException</a>. To be used inside a <a>Neuron</a> to maybe
--   prematurely finish its life but more importantly to initiate
--   <a>dissolve</a>-ing in the parent <a>Neuron</a> (or in
--   <tt>Incubation</tt>). As an argument it is accustomed to pass a
--   <a>Neuron</a> value as passed to <a>live</a> method.
dissolving :: Show n => n -> IO a

-- | An exception which initiates <a>dissolve</a>-ing of a <a>Neuron</a>.
--   Should be thrown inside the <a>Neuron</a> with passing its
--   <a>Neuron</a> value as argument (as passed to <a>live</a> method). For
--   throwing outside the <a>Neuron</a> use <a>DissolveException</a> (or
--   simply <a>detach</a> and others).
data DissolvingException

-- | Creates a <a>NeuronMapOnCapability</a> value with a chosen capability
--   picked by random. Useful when you have to map few <a>Neuron</a>s to
--   the same capability (because of an eternal (FFI) library limitations)
--   but it does not matter to which one. So you create this value and pass
--   it as an option to all those <a>Neuron</a>s, making sure that they
--   will return it with their <a>getNeuronMapCapability</a> method. For
--   example, sometimes you have to assure that both your <a>Neuron</a> and
--   <a>Control.Etage.Worker</a> <a>Neuron</a> are running on the same
--   capability so that you can correctly offload lengthly IO actions to
--   it. This makes both <a>Neuron</a>s in fact still running in one thread
--   (which is often a limitation of external libraries), Haskell taking
--   care of interleaving <a>Neuron</a>s IO actions.
mkNeuronMapOnRandomCapability :: IO NeuronMapCapability

-- | <a>Neuron</a>s can be mapped to capabilities (OS threads) in different
--   ways. The best is to let Haskell decide the best capability (and also
--   move <a>Neuron</a>s among them as necessary) by using
--   <a>NeuronFreelyMapOnCapability</a> value, but sometimes because of an
--   external (FFI) library limitations you have to map <a>Neuron</a> to a
--   fixed capability, you can use <a>NeuronMapOnCapability</a> for that.
--   
--   Sometimes it is not important to which capability you map a
--   <a>Neuron</a>, just that few <a>Neuron</a>s are mapped to the same.
--   You can use <a>mkNeuronMapOnRandomCapability</a> to create such
--   <a>NeuronMapCapability</a> value.
data NeuronMapCapability

-- | Map a <a>Neuron</a> to fixed capability.
NeuronMapOnCapability :: Int -> NeuronMapCapability

-- | Let Haskell decide on which capability is best to map a <a>Neuron</a>
--   at a given time.
NeuronFreelyMapOnCapability :: NeuronMapCapability

-- | Function which can be used as an argument to <tt>growNeuron</tt> or
--   <a>attach</a> which leaves default options as they are.
--   
--   In fact it is just an <a>id</a>entity function.
defaultOptions :: Neuron n => NeuronOptions n -> NeuronOptions n

-- | Type class with common methods for impulses send over <a>Nerve</a>s
--   and processed in <tt>Neuron</tt>s so that it is possible to define
--   <tt>Neuron</tt>s which operate on any <a>Impulse</a> type by using
--   <tt>AnyImpulse</tt> type as their receiving <a>Impulse</a>s type. An
--   example of such <tt>Neuron</tt> is <a>Control.Etage.Dump</a>.
class (Show i, Typeable i) => Impulse i
impulseTime :: Impulse i => i -> ImpulseTime
impulseValue :: Impulse i => i -> ImpulseValue

-- | Type of <a>Impulse</a> timestamp. You can use
--   <tt>getCurrentImpulseTime</tt> for timestamp representing current
--   time.
type ImpulseTime = POSIXTime

-- | Type of a general representation of <a>Impulse</a> values (data
--   payload). Currently it is just a list of <a>Rational</a> values.
type ImpulseValue = [Rational]

-- | An existentially quantified type encompassing all <a>Impulse</a>s.
--   Useful when <a>Neuron</a> should send or receive any <a>Impulse</a>
--   type.
data AnyImpulse
AnyImpulse :: i -> AnyImpulse

-- | Empty <a>Impulse</a> data type. Useful when <a>Neuron</a> does not
--   send or receive <a>Impulse</a>s.
data NoImpulse

-- | Basic <a>Impulse</a> data type holding a <a>value</a>.
--   
--   Ordered first by <a>impulseValueTimestamp</a> and then by
--   <a>value</a>. Equal only if both <a>impulseValueTimestamp</a> and
--   <a>value</a> are equal.
data (Real r, Show r, Typeable r) => IValue r
IValue :: ImpulseTime -> r -> IValue r

-- | Time when the <a>Impulse</a> was created/finalized.
impulseValueTimestamp :: IValue r -> ImpulseTime

-- | <a>value</a> of the <a>Impulse</a>.
value :: IValue r -> r

-- | <a>IValue</a> type with <a>value</a> as <a>Integer</a> type.
type IInteger = IValue Integer

-- | <a>IValue</a> type with <a>value</a> as <a>Rational</a> type.
type IRational = IValue Rational

-- | Basic <a>Impulse</a> data type holding a <a>list</a> of values.
--   
--   Ordered first by <a>impulseListTimestamp</a> and then by <a>list</a>.
--   Equal only if both <a>impulseListTimestamp</a> and <a>list</a> are
--   equal.
data (Real r, Show r, Typeable r) => IList r
IList :: ImpulseTime -> [r] -> IList r

-- | Time when the <a>Impulse</a> was created/finalized.
impulseListTimestamp :: IList r -> ImpulseTime

-- | <a>list</a> of values of the <a>Impulse</a>.
list :: IList r -> [r]

-- | <a>IList</a> type with <a>list</a> having <a>Integer</a> type values.
type IIntegerList = IList Integer

-- | <a>IList</a> type with <a>list</a> having <a>Rational</a> type values.
type IRationalList = IList Rational

-- | This type class defines a method for translating between
--   <a>Impulse</a> types.
class (Impulse i, Impulse j) => ImpulseTranslator i j
translate :: ImpulseTranslator i j => i -> [j]

-- | Translates (if necessary <a>ImpulseTranslator</a> exists) an
--   <a>Impulse</a> and sends translation to <a>Neuron</a>.
translateAndSend :: ImpulseTranslator i for => Nerve from fromConductivity for AxonConductive -> i -> IO ()

-- | Type representing a <a>Nerve</a> between <tt>Neuron</tt>s. It is
--   bi-directional (from and to a <tt>Neuron</tt>, each direction being
--   one axon) and you can specify type of <a>Impulse</a>s traveling along
--   the axon and its conductivity (with AxonConductive or
--   AxonNonConductive).
--   
--   You mostly do not need to specify this type manually if you are using
--   <tt>growNeuron</tt> and one of <tt>NerveBoth</tt>, <tt>NerveNone</tt>,
--   <tt>NerveOnlyFrom</tt> and <tt>NerveOnlyFor</tt> types.
data Nerve from fromConductivity for forConductivity

-- | Is axon (one direction of a <a>Nerve</a>) conductive? Yes, it is.
--   
--   This is type checked and enforced. If you define axon as conductive
--   you have to make make sure that <a>Impulse</a>s send along it are
--   really read somewhere, otherwise a memory leak will occur.
data AxonConductive

-- | Is axon (one direction of a <a>Nerve</a>) conductive? No, it is not.
--   
--   This is type checked and enforced. It is useful to specify
--   nonconductive axons when you are not interested in <a>Impulse</a>s
--   from a particular axon (direction), making sure there will not be a
--   memory leak because <a>Impulse</a>s would pile up.
data AxonNonConductive

-- | An existentially quantified type encompassing all <a>Nerve</a>s which
--   are conductive from a <tt>Neuron</tt>.
data FromNerve
FromNerve :: Nerve from AxonConductive for forConductivity -> FromNerve

-- | An existentially quantified type encompassing all <a>Nerve</a>s which
--   are conductive to a <tt>Neuron</tt>.
data ForNerve
ForNerve :: Nerve from fromConductivity for AxonConductive -> ForNerve

-- | An existentially quantified type encompassing all <a>Nerve</a>s which
--   are conductive in both directions.
data BothNerve
BothNerve :: Nerve from AxonConductive for AxonConductive -> BothNerve

-- | An existentially quantified type encompassing all <a>Nerve</a>s which
--   can be <a>translate</a>d to the same <a>Impulse</a> type. Used in
--   <tt>fuseWith</tt> (and <tt>fuse</tt>) to list all <a>Nerve</a>s from
--   which you want to <tt>fuse</tt> <a>Impulse</a>s.
data TranslatableFrom i
TranslatableFrom :: Nerve from AxonConductive for forConductivity -> TranslatableFrom i

-- | An existentially quantified type encompassing all <a>Nerve</a>s which
--   can be <a>translate</a>d from the same <a>Impulse</a> type. Used in
--   <tt>attachTo</tt> (and <tt>propagate</tt>) to list all <a>Nerve</a>s
--   to which you want a given <a>Nerve</a> to <a>attach</a> to (and
--   <a>Impulse</a>s to <tt>propagate</tt>).
data TranslatableFor i
TranslatableFor :: Nerve from fromConductivity for AxonConductive -> TranslatableFor i

-- | Sends an <a>Impulse</a> to a <a>Neuron</a>. <a>Nerve</a> has to be
--   conductive.
sendForNeuron :: Nerve from fromConductivity for AxonConductive -> for -> IO ()

-- | Gets an <a>Impulse</a> from a <a>Neuron</a>. It blocks until an
--   <a>Impulse</a> is available. <a>Nerve</a> has to be conductive.
getFromNeuron :: Nerve from AxonConductive for forConductivity -> IO from

-- | Similar to <a>getFromNeuron</a> just that it does not block if
--   <a>Impulse</a> is not available.
maybeGetFromNeuron :: Nerve from AxonConductive for forConductivity -> IO (Maybe from)

-- | Gets all immediately available <a>Impulse</a>s from a <a>Neuron</a>.
--   There could be no <a>Impulse</a>s available and thus the result is an
--   empty list. Oldest <a>Impulse</a> is the last in the list.
--   <a>Nerve</a> has to be conductive.
slurpFromNeuron :: Nerve from AxonConductive for forConductivity -> IO [from]

-- | Similar to <a>slurpFromNeuron</a> but it waits for at least one
--   <a>Impulse</a>.
waitAndSlurpFromNeuron :: Nerve from AxonConductive for forConductivity -> IO [from]

-- | Returns a lazy list of <a>Impulse</a>s from a <a>Neuron</a>.
--   <a>Nerve</a> has to be conductive.
getContentsFromNeuron :: Nerve from AxonConductive for forConductivity -> IO [from]

-- | Sends all <tt>Impulses</tt> from a given list to a <a>Neuron</a>.
--   <a>Nerve</a> has to be conductive.
sendListForNeuron :: Nerve from fromConductivity for AxonConductive -> [for] -> IO ()

-- | Sends an <a>Impulse</a> from a <a>Neuron</a>. <a>Nerve</a> does not
--   need to be conductive, <a>Impulse</a> will be silently dropped in this
--   case.
sendFromNeuron :: Nerve from fromConductivity for forConductivity -> from -> IO ()

-- | Gets an <a>Impulse</a> for a <a>Neuron</a>. It blocks until an
--   <a>Impulse</a> is available. <a>Nerve</a> does not need to be
--   conductive, it will block indefinitely (until an exception) in this
--   case.
getForNeuron :: Nerve from fromConductivity for forConductivity -> IO for

-- | Similar to <a>getForNeuron</a> just that it does not block if
--   <a>Impulse</a> is not available. <a>Nerve</a> does not need to be
--   conductive, it will always return <a>Nothing</a> in this case.
maybeGetForNeuron :: Nerve from fromConductivity for forConductivity -> IO (Maybe for)

-- | Gets all immediately available <a>Impulse</a>s for a <a>Neuron</a>.
--   There could be no <a>Impulse</a>s available and thus the result is an
--   empty list. Oldest <a>Impulse</a> is the last in the list.
--   <a>Nerve</a> does not need to be conductive, it will always return an
--   empty list in this case.
slurpForNeuron :: Nerve from fromConductivity for forConductivity -> IO [for]

-- | Similar to <a>slurpForNeuron</a> but it waits for at least one
--   <a>Impulse</a>. <a>Nerve</a> does not need to be conductive, it will
--   block indefinitely (until an exception) in this case.
waitAndSlurpForNeuron :: Nerve from fromConductivity for forConductivity -> IO [for]

-- | Similar to <a>waitAndSlurpForNeuron</a> but it will return only the
--   newest <a>Impulse</a> for every <a>NeuronForImpulse</a> data type
--   constructor. This is the same as <tt>head &lt;$&gt;
--   waitAndSlurpForNeuron</tt> iff <a>NeuronForImpulse</a> has only one
--   constructor defined. Otherwise it can return multiple <a>Impulse</a>s,
--   for each constructor one.
getNewestForNeuron :: Data for => Nerve from fromConductivity for forConductivity -> IO [for]

-- | Returns a lazy list of <a>Impulse</a>s for a <a>Neuron</a>.
--   <a>Nerve</a> does not need to be conductive, it will block
--   indefinitely (until an exception) in this case.
getContentsForNeuron :: Nerve from fromConductivity for forConductivity -> IO [for]

-- | Sends all <tt>Impulses</tt> from a given list to a <a>Neuron</a>.
--   <a>Nerve</a> does not need to be conductive, <a>Impulse</a>s will be
--   silently dropped in this case.
sendListFromNeuron :: Nerve from fromConductivity for forConductivity -> [from] -> IO ()

-- | Helper function which does some common initialization. Currently it
--   sets <a>stderr</a> buffering to <a>LineBuffering</a> so that when
--   multiple <a>Neuron</a>s print to <a>stderr</a> output is not mixed. It
--   also installs handlers for <a>keyboardSignal</a> and
--   <a>softwareTermination</a> signals so that cleanup in
--   <tt>Incubation</tt> works as expected.
--   
--   Using it has also an useful side-effect of Haskell not throwing
--   <a>BlockedIndefinitelyOnMVar</a> exceptions when the network runs out.
prepareEnvironment :: IO ()

-- | Helper function for use with <tt>fuseWith</tt> (and <tt>fuse</tt>)
--   which wraps given function with <a>impulseValue</a> before it and
--   <a>IValue</a> after.
--   
--   For example, you can define a fusing function which makes a
--   <a>product</a> of fusing <a>Impulse</a>s (more precisely their data
--   payload):
--   
--   <pre>
--   impulseFuser ((: []) . product . concat)
--   </pre>
fuserFun :: (Real r, Show r, Typeable r) => ([ImpulseValue] -> [r]) -> ImpulseTime -> [AnyImpulse] -> [IValue r]

-- | Helper function for use with <tt>fuseWith</tt> (and <tt>fuse</tt>)
--   which converts a list of <a>IValue</a> <a>Impulse</a>s to a
--   <a>IList</a> <a>Impulse</a>. If given list is empty no resulting
--   <a>Impulse</a> is made.
listFuser :: (Real r, Show r, Typeable r) => ImpulseTime -> [IValue r] -> [IList r]

-- | Returns current time. Useful when creating new <a>Impulse</a>s.
getCurrentImpulseTime :: IO ImpulseTime

-- | This function defines equality between <a>Impulse</a>s as equality of
--   <a>impulseTime</a> and <a>impulseValue</a> values.
impulseEq :: (Impulse i, Impulse j) => i -> j -> Bool

-- | This function defines ordering between <a>Impulse</a>s as ordering
--   first by <a>impulseTime</a> values and then by <a>impulseValue</a>
--   values.
impulseCompare :: (Impulse i, Impulse j) => i -> j -> Ordering


-- | This module defines a <a>Neuron</a> which dumps all <a>Impulse</a>s it
--   receives. You <a>grow</a> it in <a>Incubation</a> by using something
--   like:
--   
--   <pre>
--   nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) (\o -&gt; o { showInsteadOfDump = True })
--   </pre>
--   
--   It is an example of a <a>Neuron</a> which can recieve any
--   <a>Impulse</a> type. It processes all <a>Impulse</a>s it receives.
module Control.Etage.Dump
data DumpNeuron

-- | <a>Impulse</a>s from <a>DumpNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would send, <a>NoImpulse</a>.
type DumpFromImpulse = NeuronFromImpulse DumpNeuron

-- | <a>Impulse</a>s for <a>DumpNeuron</a>. This <a>Neuron</a> can recieve
--   any <a>Impulse</a> type, <a>AnyImpulse</a>.
type DumpForImpulse = NeuronForImpulse DumpNeuron

-- | Options for <a>DumpNeuron</a>. Those options are defined:
--   
--   <ul>
--   <li><i><tt>handle :: <a>Handle</a></tt></i> <a>Handle</a> to which it
--   dumps. Default is <a>stdout</a>.</li>
--   <li><i><tt>showInsteadOfDump :: <a>Bool</a></tt></i> Should it use
--   <a>show</a> when dumping <a>Impulse</a>s? By default it dumps
--   <a>impulseTime</a> and <a>impulseValue</a> values.</li>
--   <li><i><tt>prefix :: <a>String</a></tt></i> Prefix to use when
--   dumping. Default is no prefix.</li>
--   </ul>
type DumpOptions = NeuronOptions DumpNeuron
instance Typeable DumpNeuron
instance Eq (NeuronOptions DumpNeuron)
instance Show (NeuronOptions DumpNeuron)
instance Neuron DumpNeuron


-- | This module defines a <a>Neuron</a> which generates values based on a
--   given sequence at a given interval. If it reaches the end of a
--   sequence it initiates <a>dissolving</a>. You <a>grow</a> default
--   version of it, which gives you an infinite source of random
--   <a>Int</a>s at random interval of maximum length of 1 second, in
--   <a>Incubation</a> by using something like:
--   
--   <pre>
--   nerveRandom &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) defaultOptions
--   </pre>
--   
--   or for an infinite source of ones with same random interval:
--   
--   <pre>
--   nerveOnes &lt;- (growNeuron :: NerveOnlyFrom (SequenceNeuron Int)) (\o -&gt; o { valueSource = repeat 1 })
--   </pre>
--   
--   This <a>Neuron</a> is an example of a <a>Neuron</a> with a
--   parametrized type. Check also <a>Control.Etage.Function</a> for a
--   <a>Neuron</a> with both receiving and sending <a>Impulse</a>s types
--   parametrized. It does not process any (receiving) <a>Impulse</a>s.
module Control.Etage.Sequence
data SequenceNeuron v

-- | <a>Impulse</a>s from <a>SequenceNeuron</a>, <tt><a>IValue</a> v</tt>.
type SequenceFromImpulse v = NeuronFromImpulse (SequenceNeuron v)

-- | <a>Impulse</a>s for <a>SequenceNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would receive, <a>NoImpulse</a>.
type SequenceForImpulse v = NeuronForImpulse (SequenceNeuron v)

-- | Options for <a>SequenceNeuron</a>. Those options are defined:
--   
--   <ul>
--   <li><i><tt>valueSource :: [v]</tt></i> The list of values to send. If
--   the end of the list is reached, <a>Neuron</a> initiates
--   <a>dissolving</a>. Default is an infinite list of values of type
--   <tt>v</tt> generated by the <a>StdGen</a> random generator.</li>
--   <li><i><tt>intervalSource :: [<a>Int</a>]</tt></i> The list of
--   intervals between values. It is defined as a delay in microseconds
--   before the next value is send. If the end of the list is reached,
--   <a>Neuron</a> initiates <a>dissolving</a>. Default is a list of random
--   delays with maximum length of 1 second generated by the <a>StdGen</a>
--   random generator.</li>
--   </ul>
type SequenceOptions v = NeuronOptions (SequenceNeuron v)
instance Typeable1 SequenceNeuron
instance Data v => Data (SequenceNeuron v)
instance Eq v => Eq (NeuronOptions (SequenceNeuron v))
instance Ord v => Ord (NeuronOptions (SequenceNeuron v))
instance Read v => Read (NeuronOptions (SequenceNeuron v))
instance Show v => Show (NeuronOptions (SequenceNeuron v))
instance Data v => Data (NeuronOptions (SequenceNeuron v))
instance (Real v, Random v, Show v, Typeable v) => Neuron (SequenceNeuron v)
instance Typeable v => Show (SequenceNeuron v)


-- | This module defines a worker <a>Neuron</a> which evaluates <a>IO</a>
--   actions it receives. It is useful to offload lengthly <a>IO</a>
--   actions into another thread. In the case of too many queued <a>IO</a>
--   actions they are silently dropped and only newest ones are evaluated.
--   You <a>grow</a> it in <a>Incubation</a> by using something like:
--   
--   <pre>
--   nerveWorker &lt;- (growNeuron :: NerveOnlyFor WorkerNeuron) defaultOptions
--   </pre>
--   
--   It is an example of a <a>Neuron</a> which defines
--   <a>getNeuronMapCapability</a>. It processes only the newest
--   <a>Impulse</a>s it receives, when they get queued, so <a>Impulse</a>s
--   are dropped if load is too high.
module Control.Etage.Worker
data WorkerNeuron

-- | <a>Impulse</a>s from <a>WorkerNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would send, <a>NoImpulse</a>.
type WorkerFromImpulse = NeuronFromImpulse WorkerNeuron

-- | <a>Impulse</a>s for <a>WorkerNeuron</a>.
data WorkerForImpulse
Work :: ImpulseTime -> WorkType -> WorkerForImpulse

-- | Time when the action was enqueued for evaluation in the
--   <a>WorkerNeuron</a>.
impulseTimestamp :: WorkerForImpulse -> ImpulseTime

-- | Enqueued action.
work :: WorkerForImpulse -> WorkType

-- | Options for <a>WorkerNeuron</a>. This option is defined:
--   
--   <ul>
--   <li><i><tt>mapOnCapability :: <a>NeuronMapCapability</a></tt></i> How
--   to map the <a>Neuron</a> on capabilities (OS threads). With this
--   option you can fix multiple <a>Neuron</a>s on the same capability (for
--   example, by generating one value with
--   <a>mkNeuronMapOnRandomCapability</a> and using it for all those
--   <a>Neuron</a>s) which is sometimes necessary when dealing with
--   external (FFI) libraries. Default value is
--   <a>NeuronFreelyMapOnCapability</a>.</li>
--   </ul>
type WorkerOptions = NeuronOptions WorkerNeuron

-- | Type of work this worker <a>Neuron</a> evaluates.
type WorkType = IO ()
instance Typeable WorkerNeuron
instance Typeable WorkerForImpulse
instance Data WorkerNeuron
instance Show WorkerForImpulse
instance Eq (NeuronOptions WorkerNeuron)
instance Ord (NeuronOptions WorkerNeuron)
instance Read (NeuronOptions WorkerNeuron)
instance Show (NeuronOptions WorkerNeuron)
instance Data (NeuronOptions WorkerNeuron)
instance Neuron WorkerNeuron
instance Impulse WorkerForImpulse
instance Show WorkType


-- | This module defines a simple <a>Neuron</a> which initiates
--   <a>dissolving</a> after a given delay. It can be used to limit
--   execution time of the network. You <a>grow</a> it in <a>Incubation</a>
--   by using something like:
--   
--   <pre>
--   _ &lt;- (growNeuron :: NerveNone TimeoutNeuron) (\o -&gt; o { timeout = 10000000 })
--   </pre>
--   
--   somewhere among (best at the end) <a>growNeuron</a> calls for other
--   <a>Neuron</a>s in <a>Incubation</a>.
--   
--   It is an example of a <a>Neuron</a> which does not <a>live</a>
--   indefinitely (until an exception) but <a>dissolve</a>s after some time
--   (by using <a>dissolving</a>). It does not process any <a>Impulse</a>s.
module Control.Etage.Timeout
data TimeoutNeuron

-- | <a>Impulse</a>s from <a>TimeoutNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would send, <a>NoImpulse</a>.
type TimeoutFromImpulse = NeuronFromImpulse TimeoutNeuron

-- | <a>Impulse</a>s for <a>TimeoutNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would receive, <a>NoImpulse</a>.
type TimeoutForImpulse = NeuronForImpulse TimeoutNeuron

-- | Options for <a>TimeoutNeuron</a>. This option is defined:
--   
--   <ul>
--   <li><i><tt>timeout :: <a>Int</a></tt></i> The length of the delay in
--   microseconds before initiating <a>dissolving</a>. Default is 60
--   seconds.</li>
--   </ul>
type TimeoutOptions = NeuronOptions TimeoutNeuron
instance Typeable TimeoutNeuron
instance Data TimeoutNeuron
instance Eq (NeuronOptions TimeoutNeuron)
instance Ord (NeuronOptions TimeoutNeuron)
instance Read (NeuronOptions TimeoutNeuron)
instance Show (NeuronOptions TimeoutNeuron)
instance Data (NeuronOptions TimeoutNeuron)
instance Neuron TimeoutNeuron
instance Show TimeoutNeuron


-- | This module defines a <a>Neuron</a> which applies a given function to
--   received <a>Impulse</a>s. As Haskell is a lazy language this does not
--   mean that the result will be immediately (fully) evaluated but that it
--   will be evaluated when (and if) the result will be needed (probably in
--   some other <a>Neuron</a>). You <a>grow</a> it in <a>Incubation</a> by
--   using something like:
--   
--   <pre>
--   nerveFunction &lt;- (growNeuron :: NerveBoth (FunctionNeuron AnyImpulse IRational)) (\o -&gt; o { function = \t -&gt; (: []) . IValue t . sum . impulseValue })
--   </pre>
--   
--   This example can receive any <a>Impulse</a> type (<a>AnyImpulse</a>)
--   and returns <a>sum</a> of its data payload (as given by
--   <a>impulseValue</a>) as <a>IRational</a> type.
--   
--   The following example calculates the greatest common divisor
--   (<a>gcd</a>):
--   
--   <pre>
--   incubate $ do
--     let gcd t IList { list = (a:b:is) } = let r = a `mod` b in if r == 0 then [IList t (b:is)] else [IList t (b:r:is)]
--         gcd _ _ = []
--     
--     nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) (\o -&gt; o { showInsteadOfDump = True })
--     nerveSum &lt;- (growNeuron :: NerveBoth (FunctionNeuron IIntegerList IIntegerList)) (\o -&gt; o { function = gcd })
--     
--     nerveSum `attachTo` [TranslatableFor nerveSum, TranslatableFor nerveDump]
--     
--     liftIO $ do
--       t &lt;- getCurrentImpulseTime
--       sendForNeuron nerveSum $ IList t [110, 80, 5]
--   </pre>
--   
--   This <a>Neuron</a> is an example of a <a>Neuron</a> with both
--   receiving and sending <a>Impulse</a>s types parametrized. It processes
--   only the newest <a>Impulse</a>s it receives, when they get queued, so
--   <a>Impulse</a>s are dropped if load is too high.
module Control.Etage.Function
data FunctionNeuron i j

-- | <a>Impulse</a>s from <a>FunctionNeuron</a>, of type <tt>j</tt>.
type FunctionFromImpulse i j = NeuronFromImpulse (FunctionNeuron i j)

-- | <a>Impulse</a>s for <a>FunctionNeuron</a>, of type <tt>i</tt>.
type FunctionForImpulse i j = NeuronForImpulse (FunctionNeuron i j)

-- | Options for <a>FunctionNeuron</a>. This option is defined:
--   
--   <ul>
--   <li><i><tt>function :: <a>ImpulseTime</a> -&gt; i -&gt; [j]</tt></i>
--   The function to apply to recieved <a>Impulse</a>s. Resulting
--   <a>Impulse</a>s are send in the list order. Default is to always
--   return an empty list.</li>
--   </ul>
type FunctionOptions i j = NeuronOptions (FunctionNeuron i j)
instance Typeable2 FunctionNeuron
instance (Impulse i, Impulse j) => Neuron (FunctionNeuron i j)
instance (Impulse i, Impulse j) => Show (FunctionNeuron i j)


-- | This module defines a simple <a>Neuron</a> which just fails (throws a
--   <a>DissolvingException</a>) in <a>grow</a>ing phase. It can be used to
--   test error recovery and cleanup in <a>grow</a>ing phase or early
--   stages of <a>live</a>ing phase in other <a>Neuron</a>s by using
--   something like:
--   
--   <pre>
--   _ &lt;- (growNeuron :: NerveNone FailNeuron) (\o -&gt; o { delay = 10000000 })
--   </pre>
--   
--   somewhere among (or after) <a>growNeuron</a> calls for other
--   <a>Neuron</a>s in <a>Incubation</a>.
--   
--   This <a>Neuron</a> does not process any <a>Impulse</a>s.
module Control.Etage.Fail
data FailNeuron

-- | <a>Impulse</a>s from <a>FailNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would send, <a>NoImpulse</a>.
type FailFromImpulse = NeuronFromImpulse FailNeuron

-- | <a>Impulse</a>s for <a>FailNeuron</a>. This <a>Neuron</a> does not
--   define any <a>Impulse</a>s it would receive, <a>NoImpulse</a>.
type FailForImpulse = NeuronForImpulse FailNeuron

-- | Options for <a>FailNeuron</a>. This option is defined:
--   
--   <ul>
--   <li><i><tt>delay :: <a>Int</a></tt></i> The delay in microseconds
--   before <a>Neuron</a> fails. Default is no delay.</li>
--   </ul>
type FailOptions = NeuronOptions FailNeuron
instance Typeable FailNeuron
instance Data FailNeuron
instance Eq (NeuronOptions FailNeuron)
instance Ord (NeuronOptions FailNeuron)
instance Read (NeuronOptions FailNeuron)
instance Show (NeuronOptions FailNeuron)
instance Data (NeuronOptions FailNeuron)
instance Neuron FailNeuron
instance Show FailNeuron


-- | This module defines a <a>Neuron</a> which delays received
--   <a>Impulse</a>s before sending them further. In this way network can
--   have a simple kind of memory (state) without a need of special
--   <a>Neuron</a>s. You <a>grow</a> it in <a>Incubation</a> by using
--   something like:
--   
--   <pre>
--   nerveDelay &lt;- (growNeuron :: NerveBoth (DelayNeuron IInteger)) (\o -&gt; o { delay = 2 })
--   </pre>
--   
--   Sometimes the same effect can be achieved by using a <a>Nerve</a> as a
--   queue and using <a>fuseWith</a> (or <a>fuse</a>) to synchronize (and
--   thus delay) <a>Impulse</a>s. For example, the following two programs
--   both output Fibonacci sequence:
--   
--   <pre>
--   incubate $ do
--     nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) (\o -&gt; o { showInsteadOfDump = True })
--     nerveDelay &lt;- (growNeuron :: NerveBoth (DelayNeuron IInteger)) defaultOptions
--     nerveSum &lt;- (growNeuron :: NerveBoth (FunctionNeuron IIntegerList IInteger)) (\o -&gt; o { function = \t -&gt; (: []) . IValue t . sum . list })
--     nerveFused &lt;- [TranslatableFrom nerveDelay, TranslatableFrom nerveSum] `fuseWith` (listFuser :: ImpulseTime -&gt; [IInteger] -&gt; [IIntegerList])
--     
--     nerveSum `attachTo` [TranslatableFor nerveDelay, TranslatableFor nerveDump]
--     nerveFused `attachTo` [TranslatableFor nerveSum]
--     
--     liftIO $ do
--       t &lt;- getCurrentImpulseTime
--       sendFromNeuron nerveSum $ IValue t 1
--       sendFromNeuron nerveDelay $ IValue t 0
--   </pre>
--   
--   <pre>
--   incubate $ do
--     nerveDump &lt;- (growNeuron :: NerveOnlyFor DumpNeuron) (\o -&gt; o { showInsteadOfDump = True })
--     nerveSum &lt;- (growNeuron :: NerveBoth (FunctionNeuron IIntegerList IInteger)) (\o -&gt; o { function = \t -&gt; (: []) . IValue t . sum . list })
--     
--     liftIO $ do
--       t &lt;- getCurrentImpulseTime
--       sendFromNeuron nerveSum $ IValue t 0
--     
--     nerveSum' &lt;- liftIO $ branchNerveFrom nerveSum
--     nerveFused &lt;- [TranslatableFrom nerveSum, TranslatableFrom nerveSum'] `fuseWith` (listFuser :: ImpulseTime -&gt; [IInteger] -&gt; [IIntegerList])
--     
--     nerveSum `attachTo` [TranslatableFor nerveDump]
--     nerveFused `attachTo` [TranslatableFor nerveSum]
--     
--     liftIO $ do
--       t &lt;- getCurrentImpulseTime
--       sendFromNeuron nerveSum $ IValue t 1
--   </pre>
--   
--   This <a>Neuron</a> processes all <a>Impulse</a>s it receives.
module Control.Etage.Delay
data DelayNeuron i

-- | <a>Impulse</a>s from <a>DelayNeuron</a>, of type <tt>i</tt>.
type DelayFromImpulse i = NeuronFromImpulse (DelayNeuron i)

-- | <a>Impulse</a>s for <a>DelayNeuron</a>, of type <tt>i</tt>.
type DelayForImpulse i = NeuronForImpulse (DelayNeuron i)

-- | Options for <a>DelayNeuron</a>. This option is defined:
--   
--   <ul>
--   <li><i><tt>delay :: <a>Int</a></tt></i> For how many <a>Impulse</a>s
--   should received <a>Impulse</a>s be delayed before sending them.
--   Default value is 1.</li>
--   </ul>
type DelayOptions i = NeuronOptions (DelayNeuron i)
instance Typeable1 DelayNeuron
instance Data i => Data (DelayNeuron i)
instance Eq (NeuronOptions (DelayNeuron i))
instance Ord (NeuronOptions (DelayNeuron i))
instance Read (NeuronOptions (DelayNeuron i))
instance Show (NeuronOptions (DelayNeuron i))
instance Data i => Data (NeuronOptions (DelayNeuron i))
instance Impulse i => Neuron (DelayNeuron i)
