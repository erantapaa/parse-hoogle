-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Audio signal processing coded in Haskell: Low level part
--   
--   Low level audio signal processing used by the other synthesizer
--   packages. The routines can be really fast due to StorableVector,
--   Stream-like list type and aggressive inlining. For an interface to
--   Haskore see
--   <a>http://code.haskell.org/haskore/revised/synthesizer/</a>. For
--   introductory examples see <a>Synthesizer.Plain.Tutorial</a> and
--   <a>Synthesizer.Generic.Tutorial</a>.
@package synthesizer-core
@version 0.4.0.4

module Synthesizer.Causal.Displacement

-- | Mix two signals. Unfortunately we have to use <a>zipWith</a> semantic
--   here, that is the result is as long as the shorter of both inputs.
mix :: (C v, Arrow arrow) => arrow (v, v) v

-- | Add a number to all of the signal values. This is useful for adjusting
--   the center of a modulation.
raise :: (C v, Arrow arrow) => v -> arrow v v

-- | In <a>Synthesizer.Basic.Distortion</a> you find a collection of
--   appropriate distortion functions.
distort :: (Arrow arrow) => (c -> a -> a) -> arrow (c, a) a
mapLinear :: (C a, Arrow arrow) => a -> a -> arrow a a
mapExponential :: (C a, Arrow arrow) => a -> a -> arrow a a


-- | This is old code, handling Int16 using two characters.
module Synthesizer.Plain.IO

-- | Uses endianess of the machine, like Sox does.
writeInt16Stream :: FilePath -> [Int16] -> IO ()

-- | The end of the list is undefined, if the file has odd length. It would
--   be better if it throws an exception.
readInt16StreamStrict :: FilePath -> IO [Int16]

-- | Write a little endian 16 bit integer stream via String data and
--   <a>writeFile</a>.
writeLEInt16Stream :: FilePath -> [Int16] -> IO ()

-- | The end of the list is undefined, if the file has odd length. It would
--   be better if it throws an exception.
readLEInt16Stream :: FilePath -> IO [Int16]
putInt16Stream :: Handle -> [Int16] -> IO ()
putInt16StreamChunky :: Handle -> [Int16] -> IO ()
intToTwoLEChars :: Int -> [Char]
twoLECharsToInt :: Char -> Char -> Int

module Synthesizer.Plain.Miscellaneous

-- | simulate an moving sounding object convert the way of the object
--   through 3D space into a delay and attenuation information, sonicDelay
--   is the reciprocal of the sonic velocity
receive3Dsound :: (C a, C a v) => a -> a -> v -> [v] -> ([a], [a])

module Synthesizer.Plain.LorenzAttractor
computeDerivatives :: (C y) => (y, y, y) -> (y, y, y) -> (y, y, y)
explicitEuler :: (C a v) => a -> (v -> v) -> v -> [v]
equilibrium :: (Double, Double, Double)
example0 :: [(Double, Double, Double)]
example :: [(Double, Double, Double)]


module Synthesizer.Plain.Filter.Recursive.AllpassPoly
newtype Parameter a
Parameter :: [a] -> Parameter a

-- | Compute coefficients for an allpass that shifts low frequencies by
--   approximately the shift you want. To achieve this we solve a linear
--   least squares problem, where low frequencies are more weighted than
--   high ones. The output is a list of coefficients for an arbitrary order
--   allpass.
shiftParam :: (Scalar a, Fractional a, C a) => Int -> a -> a -> Parameter a
makePhase :: (C a) => Parameter a -> a -> a
scalarProdScrewExp :: (C a) => a -> Int -> a -> Int -> Int -> a
screwProd :: (C a) => Int -> a -> Int -> Int -> a -> a
integrateScrewExp :: (C a) => a -> Int -> (a, a)
integrateNum :: (C a, C a v) => Int -> (a, a) -> (a -> v) -> v
instance (Show a) => Show (Parameter a)


module Synthesizer.Plain.Filter.Recursive

-- | Description of a filter pole.
data Pole a
Pole :: !a -> !a -> Pole a

-- | Resonance, that is the amplification of the band center frequency.
poleResonance :: Pole a -> !a

-- | Band center frequency.
poleFrequency :: Pole a -> !a
data Passband
Lowpass :: Passband
Highpass :: Passband
instance Show Passband
instance Eq Passband
instance Enum Passband
instance (Eq a) => Eq (Pole a)
instance (Show a) => Show (Pole a)
instance (Read a) => Read (Pole a)
instance (C a v) => C a (Pole v)
instance (C v) => C (Pole v)


-- | Support for stateful modifiers like controlled filters. This is
--   similar to <a>Synthesizer.Causal.Process</a> but we cannot replace the
--   Modifier structure by the Causal structure because the Modifier
--   structure exhibits the state which allows stacking of modifiers using
--   an efficient storage for the stacked state. More precisely, because
--   Modifiers exhibits the type of the state, we can ensure that the state
--   type of several modifiers is equal and thus the individual states can
--   be stored in an array or a StorableVector.
module Synthesizer.Plain.Modifier
type T a = [a]
data Simple s ctrl a b
Simple :: s -> (ctrl -> a -> State s b) -> Simple s ctrl a b
init :: Simple s ctrl a b -> s
step :: Simple s ctrl a b -> ctrl -> a -> State s b

-- | modif is a process controlled by values of type c with an internal
--   state of type s, it converts an input value of type a into an output
--   value of type b while turning into a new state
--   
--   ToDo: Shall finite signals be padded with zeros?
static :: Simple s ctrl a b -> ctrl -> T a -> T b

-- | Here the control may vary over the time.
modulated :: Simple s ctrl a b -> T ctrl -> T a -> T b
data Initialized s init ctrl a b
Initialized :: (init -> s) -> (ctrl -> a -> State s b) -> Initialized s init ctrl a b
initInit :: Initialized s init ctrl a b -> init -> s
initStep :: Initialized s init ctrl a b -> ctrl -> a -> State s b
initialize :: Initialized s init ctrl a b -> init -> Simple s ctrl a b
staticInit :: Initialized s init ctrl a b -> init -> ctrl -> T a -> T b

-- | Here the control may vary over the time.
modulatedInit :: Initialized s init ctrl a b -> init -> T ctrl -> T a -> T b

-- | The number of stacked state monads depends on the size of the list of
--   state values. This is like a dynamically nested StateT.
stackStatesR :: (a -> State s a) -> (a -> State [s] a)
stackStatesL :: (a -> State s a) -> (a -> State [s] a)
stackStatesStorableR :: (Storable s) => (a -> State s a) -> (a -> State (Vector s) a)
stackStatesStorableL :: (Storable s) => (a -> State s a) -> (a -> State (Vector s) a)
stackStatesStorableVaryL :: (Storable s, Storable c) => (c -> a -> State s a) -> (Vector c -> a -> State (Vector s) a)


module Synthesizer.Plain.Signal
type T a = [a]
type Modifier s ctrl a b = Simple s ctrl a b

-- | modif is a process controlled by values of type c with an internal
--   state of type s, it converts an input value of type a into an output
--   value of type b while turning into a new state
--   
--   ToDo: Shall finite signals be padded with zeros?
modifyStatic :: Modifier s ctrl a b -> ctrl -> T a -> T b

-- | Here the control may vary over the time.
modifyModulated :: Modifier s ctrl a b -> T ctrl -> T a -> T b
type ModifierInit s init ctrl a b = Initialized s init ctrl a b
modifierInitialize :: ModifierInit s init ctrl a b -> init -> Modifier s ctrl a b
modifyStaticInit :: ModifierInit s init ctrl a b -> init -> ctrl -> T a -> T b

-- | Here the control may vary over the time.
modifyModulatedInit :: ModifierInit s init ctrl a b -> init -> T ctrl -> T a -> T b
unfoldR :: (acc -> Maybe (y, acc)) -> acc -> (acc, T y)
reduceL :: (x -> acc -> Maybe acc) -> acc -> T x -> acc
mapAccumL :: (x -> acc -> Maybe (y, acc)) -> acc -> T x -> (acc, T y)
crochetL :: (x -> acc -> Maybe (y, acc)) -> acc -> T x -> T y

-- | Feed back signal into signal processor, and apply a delay by one
--   value. <a>fix1</a> is a kind of <tt>Signal.generate</tt>.
fix1 :: y -> (T y -> T y) -> T y

-- | <tt>dropMarginRem n m xs</tt> drops at most the first <tt>m</tt>
--   elements of <tt>xs</tt> and ensures that <tt>xs</tt> still contains
--   <tt>n</tt> elements. Additionally returns the number of elements that
--   could not be dropped due to the margin constraint. That is
--   <tt>dropMarginRem n m xs == (k,ys)</tt> implies <tt>length xs - m ==
--   length ys - k</tt>. Requires <tt>length xs &gt;= n</tt>.
dropMarginRem :: Int -> Int -> T a -> (Int, T a)
dropMargin :: Int -> Int -> T a -> T a

-- | Test whether a list has at least <tt>n</tt> elements.
lengthAtLeast :: Int -> T a -> Bool

-- | Can be implemented more efficiently than just by <a>zipWith</a> and
--   <a>tails</a> for other data structures.
zipWithTails :: (y0 -> T y1 -> y2) -> T y0 -> T y1 -> T y2
zipWithRest :: (y0 -> y0 -> y1) -> T y0 -> T y0 -> (T y1, (Bool, T y0))
zipWithRest' :: (y0 -> y0 -> y1) -> T y0 -> T y0 -> (T y1, (Bool, T y0))
zipWithAppend :: (y -> y -> y) -> T y -> T y -> T y


-- | Filter operators from calculus
module Synthesizer.Plain.Filter.Recursive.Integration

-- | Integrate with initial value zero. However the first emitted value is
--   the value of the input signal. It maintains the length of the signal.
run :: (C v) => T v -> T v

-- | Integrate with initial condition. First emitted value is the initial
--   condition. The signal becomes one element longer.
runInit :: (C v) => v -> T v -> T v


module Synthesizer.Plain.Cut

-- | Take signal until it falls short of a certain amplitude for a given
--   time.
takeUntilPause :: (C a) => a -> Int -> T a -> T a

-- | Take values until the predicate p holds for n successive values. The
--   list is truncated at the beginning of the interval of matching values.
takeUntilInterval :: (a -> Bool) -> Int -> T a -> T a
selectBool :: (T a, T a) -> T Bool -> T a
select :: (Ix i) => Array i (T a) -> T i -> T a

-- | Given a list of signals with time stamps, mix them into one signal as
--   they occur in time. Ideally for composing music.
--   
--   Cf. <tt>MathObj.LaurentPolynomial.series</tt>
arrange :: (C v) => T Int (T v) -> T v


-- | <a>http://en.wikipedia.org/wiki/Particle_displacement</a>
module Synthesizer.Plain.Displacement

-- | Mix two signals. In opposition to <a>zipWith</a> the result has the
--   length of the longer signal.
mix :: (C v) => T v -> T v -> T v

-- | Mix an arbitrary number of signals.
mixMulti :: (C v) => [T v] -> T v

-- | Add a number to all of the signal values. This is useful for adjusting
--   the center of a modulation.
raise :: (C v) => v -> T v -> T v

-- | In <a>Synthesizer.Basic.Distortion</a> you find a collection of
--   appropriate distortion functions.
distort :: (c -> a -> a) -> T c -> T a -> T a


-- | Noise and random processes.
module Synthesizer.Plain.Noise

-- | Deterministic white noise, uniformly distributed between -1 and 1.
--   That is, variance is 1/3.
white :: (C y, Random y) => T y
whiteGen :: (C y, Random y, RandomGen g) => g -> T y

-- | Approximates normal distribution with variance 1 by a quadratic
--   B-spline distribution.
whiteQuadraticBSplineGen :: (C y, Random y, RandomGen g) => g -> T y
randomPeeks :: (C y, Random y) => T y -> T Bool
randomPeeksGen :: (C y, Random y, RandomGen g) => g -> T y -> T Bool

module Synthesizer.Utility

-- | If two values are equal, then return one of them, otherwise raise an
--   error.
common :: (Eq a) => String -> a -> a -> a
fwrap :: (C a) => (a, a) -> a -> a
fmod :: (C a) => a -> a -> a
fmodAlt :: (C a) => a -> a -> a
propFMod :: (C a) => a -> a -> Bool
affineComb :: (C t y) => t -> (y, y) -> y
balanceLevel :: (C y) => y -> [y] -> [y]
randomRsBalanced :: (RandomGen g, Random y, C y) => g -> Int -> y -> y -> [y]

module Synthesizer.Plain.Control
constant :: y -> T y
linear :: (C y) => y -> y -> T y

-- | Minimize rounding errors by reducing number of operations per element
--   to a logarithmuc number.
linearMultiscale :: (C y) => y -> y -> T y

-- | Linear curve starting at zero.
linearMultiscaleNeutral :: (C y) => y -> T y

-- | As stable as the addition of time values.
linearStable :: (C y) => y -> y -> T y

-- | It computes the same like <a>linear</a> but in a numerically more
--   stable manner, namely using a subdivision scheme. The division needed
--   is a division by two.
--   
--   0 4 8 0 2 4 6 8 0 1 2 3 4 5 6 7 8
linearMean :: (C y) => y -> y -> T y

-- | Intersperse linearly interpolated values.
linearSubdivision :: (C y) => T y -> T y

-- | Linear curve of a fixed length. The final value is not actually
--   reached, instead we stop one step before. This way we can concatenate
--   several lines without duplicate adjacent values.
line :: (C y) => Int -> (y, y) -> T y
exponentialMultiscale :: (C y) => y -> y -> T y
exponentialStable :: (C y) => y -> y -> T y
exponential :: (C y) => y -> y -> T y
exponentialMultiscaleNeutral :: (C y) => y -> T y
exponential2Multiscale :: (C y) => y -> y -> T y
exponential2Stable :: (C y) => y -> y -> T y
exponential2 :: (C y) => y -> y -> T y
exponential2MultiscaleNeutral :: (C y) => y -> T y
exponentialFromToMultiscale :: (C y) => y -> y -> y -> T y
exponentialFromTo :: (C y) => y -> y -> y -> T y
exponentialStableGen :: (C y, C t) => (t -> y) -> t -> y -> T y

-- | This is an extension of <a>exponential</a> to vectors which is
--   straight-forward but requires more explicit signatures. But since it
--   is needed rarely I setup a separate function.
vectorExponential :: (C y, C y v) => y -> v -> T v
vectorExponential2 :: (C y, C y v) => y -> v -> T v
cosineMultiscale :: (C y) => y -> y -> T y
cosineSubdiv :: (C y) => y -> y -> T y
cosineStable :: (C y) => y -> y -> T y
cosine :: (C y) => y -> y -> T y
cosineSubdivision :: (C y) => y -> T y -> T y
cosineWithSlope :: (C y) => (y -> y -> signal) -> y -> y -> signal
cubicHermite :: (C y) => (y, (y, y)) -> (y, (y, y)) -> T y

-- | 0 16 0 8 16 0 4 8 12 16 0 2 4 6 8 10 12 14 16 0 1 2 3 4 5 6 7 8 9 10
--   11 12 13 14 15 16
cubicFunc :: (C y) => (y, (y, y)) -> (y, (y, y)) -> y -> y
cubicHermiteStable :: (C y) => (y, (y, y)) -> (y, (y, y)) -> T y
cubicSubdivision :: (C y) => T y -> T y

-- | The curve type of a piece of a piecewise defined control curve.
data Control y
CtrlStep :: Control y
CtrlLin :: Control y
CtrlExp :: y -> Control y
ctrlExpSaturation :: Control y -> y
CtrlCos :: Control y
CtrlCubic :: y -> y -> Control y
ctrlCubicGradient0 :: Control y -> y
ctrlCubicGradient1 :: Control y -> y

-- | The full description of a control curve piece.
data ControlPiece y
ControlPiece :: Control y -> y -> y -> y -> ControlPiece y
pieceType :: ControlPiece y -> Control y
pieceY0 :: ControlPiece y -> y
pieceY1 :: ControlPiece y -> y
pieceDur :: ControlPiece y -> y
newtype PieceRightSingle y
PRS :: y -> PieceRightSingle y
newtype PieceRightDouble y
PRD :: y -> PieceRightDouble y
type ControlDist y = (y, Control y, y)

-- | The 6 operators simplify constructing a list of <tt>ControlPiece
--   a</tt>. The description consists of nodes (namely the curve values at
--   nodes) and the connecting curve types. The naming scheme is as
--   follows: In the middle there is a bar <tt>|</tt>. With respect to the
--   bar, the pad symbol <tt>#</tt> is at the side of the curve type, at
--   the other side there is nothing, a minus sign <tt>-</tt>, or an
--   equality sign <tt>=</tt>.
--   
--   <ol>
--   <li>Nothing means that here is the start or the end node of a
--   curve.</li>
--   <li>Minus means that here is a node where left and right curve meet at
--   the same value. The node description is thus one value.</li>
--   <li>Equality sign means that here is a split node, where left and
--   right curve might have different ending and beginning values,
--   respectively. The node description consists of a pair of values.</li>
--   </ol>
(#|-) :: (y, Control y) -> (PieceRightSingle y, [ControlPiece y]) -> (ControlDist y, [ControlPiece y])
(-|#) :: y -> (ControlDist y, [ControlPiece y]) -> (PieceRightSingle y, [ControlPiece y])
(#|=) :: (y, Control y) -> (PieceRightDouble y, [ControlPiece y]) -> (ControlDist y, [ControlPiece y])
(=|#) :: (y, y) -> (ControlDist y, [ControlPiece y]) -> (PieceRightDouble y, [ControlPiece y])
(#|) :: (y, Control y) -> y -> (ControlDist y, [ControlPiece y])
(|#) :: y -> (ControlDist y, [ControlPiece y]) -> [ControlPiece y]
piecewise :: (C y, C y) => [ControlPiece y] -> T y
piecewisePart :: (C y) => y -> y -> y -> y -> Int -> Control y -> T y
curveStable :: (C t) => (t -> y) -> (y -> y -> y) -> t -> y -> T y
unreachable :: a
double :: (C t) => t -> t
concatMapPair :: (a -> (b, b)) -> T a -> T b
flattenPairs :: T (a, a) -> T a
subdivide :: (y -> y -> y) -> T y -> T y
concatMapPair' :: (a -> (b, b)) -> T a -> T b
curveMultiscale :: (y -> y -> y) -> y -> y -> T y
curveMultiscaleNeutral :: (y -> y -> y) -> y -> y -> T y
instance (Eq y) => Eq (ControlPiece y)
instance (Show y) => Show (ControlPiece y)
instance (Eq y) => Eq (Control y)
instance (Show y) => Show (Control y)

module Synthesizer.Plain.Analysis

-- | Volume based on Manhattan norm.
volumeMaximum :: (C y) => T y -> y

-- | Volume based on Energy norm.
volumeEuclidean :: (C y) => T y -> y
volumeEuclideanSqr :: (C y) => T y -> y

-- | Volume based on Sum norm.
volumeSum :: (C y, C y) => T y -> y

-- | Volume based on Manhattan norm.
volumeVectorMaximum :: (C y yv, Ord y) => T yv -> y

-- | Volume based on Energy norm.
volumeVectorEuclidean :: (C y, C y yv) => T yv -> y
volumeVectorEuclideanSqr :: (C y, Sqr y yv) => T yv -> y

-- | Volume based on Sum norm.
volumeVectorSum :: (C y yv, C y) => T yv -> y

-- | Compute minimum and maximum value of the stream the efficient way.
--   Input list must be non-empty and finite.
bounds :: (Ord y) => T y -> (y, y)

-- | Input list must be finite. List is scanned twice, but counting may be
--   faster.
histogramDiscreteArray :: T Int -> (Int, T Int)

-- | Input list must be finite. If the input signal is empty, the offset is
--   <tt>undefined</tt>. List is scanned twice, but counting may be faster.
--   The sum of all histogram values is one less than the length of the
--   signal.
histogramLinearArray :: (C y) => T y -> (Int, T y)

-- | Input list must be finite. If the input signal is empty, the offset is
--   <tt>undefined</tt>. List is scanned once, counting may be slower.
histogramDiscreteIntMap :: T Int -> (Int, T Int)
histogramLinearIntMap :: (C y) => T y -> (Int, T y)
histogramIntMap :: (C y) => y -> T y -> (Int, T Int)
quantize :: (C y) => y -> T y -> T Int
attachOne :: T i -> T (i, Int)
meanValues :: (C y) => T y -> [(Int, y)]
spread :: (C y) => (y, y) -> [(Int, y)]

-- | Requires finite length. This is identical to the arithmetic mean.
directCurrentOffset :: (C y) => T y -> y
scalarProduct :: (C y) => T y -> T y -> y

-- | <a>directCurrentOffset</a> must be non-zero.
centroid :: (C y) => T y -> y
centroidAlt :: (C y) => T y -> y
firstMoment :: (C y) => T y -> y
average :: (C y) => T y -> y
rectify :: (C y) => T y -> T y

-- | Detects zeros (sign changes) in a signal. This can be used as a simple
--   measure of the portion of high frequencies or noise in the signal. It
--   ca be used as voiced/unvoiced detector in a vocoder.
--   
--   <tt>zeros x !! n</tt> is <tt>True</tt> if and only if <tt>(x !! n
--   &gt;= 0) /= (x !! (n+1) &gt;= 0)</tt>. The result will be one value
--   shorter than the input.
zeros :: (Ord y, C y) => T y -> T Bool
data BinaryLevel
Low :: BinaryLevel
High :: BinaryLevel
binaryLevelFromBool :: Bool -> BinaryLevel
binaryLevelToNumber :: (C a) => BinaryLevel -> a

-- | Detect thresholds with a hysteresis.
flipFlopHysteresis :: (Ord y) => (y, y) -> BinaryLevel -> T y -> T BinaryLevel

-- | Almost naive implementation of the chirp transform, a generalization
--   of the Fourier transform.
--   
--   More sophisticated algorithms like Rader, Cooley-Tukey, Winograd,
--   Prime-Factor may follow.
chirpTransform :: (C y) => y -> T y -> T y
binarySign :: (Ord y, C y) => T y -> T BinaryLevel

-- | The output type could be different from the input type but then we
--   would need a conversion from output to input for feedback.
deltaSigmaModulation :: (C y) => T y -> T BinaryLevel
instance Eq BinaryLevel
instance Show BinaryLevel
instance Enum BinaryLevel

module Synthesizer.Plain.Filter.LinearPredictive

-- | Determine optimal filter coefficients and residue by adaptive
--   approximation. The number of initial filter coefficients is used as
--   filter order.
approxCoefficients :: (C a) => a -> [a] -> [a] -> [(a, [a])]


module Synthesizer.Plain.Filter.NonRecursive
amplify :: (C a) => a -> T a -> T a
amplifyVector :: (C a v) => a -> T v -> T v
envelope :: (C a) => T a -> T a -> T a
envelopeVector :: (C a v) => T a -> T v -> T v
fadeInOut :: (C a) => Int -> Int -> Int -> T a -> T a
fadeInOutAlt :: (C a) => Int -> Int -> Int -> T a -> T a
delay :: (C y) => Int -> T y -> T y
delayPad :: y -> Int -> T y -> T y

-- | Unmodulated non-recursive filter
generic :: (C a v) => T a -> T v -> T v

-- | Unmodulated non-recursive filter Output has same length as the input.
--   
--   It is elegant but leaks memory.
genericAlt :: (C a v) => T a -> T v -> T v
propGeneric :: (C a v, Eq v) => T a -> T v -> Bool

-- | <tt>eps</tt> is the threshold relatively to the maximum. That is, if
--   the gaussian falls below <tt>eps * gaussian 0</tt>, then the function
--   truncated.
gaussian :: (C a, C a, C a v) => a -> a -> a -> T v -> T v
binomial :: (C a, C a, C a v) => a -> a -> T v -> T v

-- | Compute the variance of the Gaussian such that its Fourier transform
--   has value <tt>ratio</tt> at frequency <tt>freq</tt>.
ratioFreqToVariance :: (C a) => a -> a -> a
binomial1 :: (C v) => T v -> T v

-- | Moving (uniformly weighted) average in the most trivial form. This is
--   very slow and needs about <tt>n * length x</tt> operations.
sums :: (C v) => Int -> T v -> T v
sumsDownsample2 :: (C v) => T v -> T v
downsample2 :: T a -> T a

-- | Given a list of numbers and a list of sums of (2*k) of successive
--   summands, compute a list of the sums of (2*k+1) or (2*k+2) summands.
--   
--   Example for 2*k+1
--   
--   <pre>
--   [0+1+2+3, 2+3+4+5, 4+5+6+7, ...] -&gt;
--      [0+1+2+3+4, 1+2+3+4+5, 2+3+4+5+6, 3+4+5+6+7, 4+5+6+7+8, ...]
--   </pre>
--   
--   Example for 2*k+2
--   
--   <pre>
--   [0+1+2+3, 2+3+4+5, 4+5+6+7, ...] -&gt;
--      [0+1+2+3+4+5, 1+2+3+4+5+6, 2+3+4+5+6+7, 3+4+5+6+7+8, 4+5+6+7+8+9, ...]
--   </pre>
sumsUpsampleOdd :: (C v) => Int -> T v -> T v -> T v
sumsUpsampleEven :: (C v) => Int -> T v -> T v -> T v
sumsPyramid :: (C v) => Int -> T v -> T v

-- | Compute the sum of the values from index l to (r-1). (I.e. somehow a
--   right open interval.) This can be used for implementation of a moving
--   average filter. However, its counterpart <a>sumRangeFromPyramid</a> is
--   much faster for large windows.
sumRange :: (C v) => T v -> (Int, Int) -> v
pyramid :: (C v) => T v -> [T v]
unitSizesFromPyramid :: [signal] -> [Int]
sumRangePrepare :: (C v) => ((Int, Int) -> source -> v) -> (source -> (Int, Int) -> v)

-- | This function should be much faster than <a>sumRange</a> but slower
--   than the recursively implemented <tt>movingAverage</tt>. However in
--   contrast to <tt>movingAverage</tt> it should not suffer from
--   cancelation.
sumRangeFromPyramid :: (C v) => [T v] -> (Int, Int) -> v
symmetricRangePrepare :: ((Int, Int) -> source -> v) -> (source -> (Int, Int) -> v)
minRange :: (Ord v) => T v -> (Int, Int) -> v
getRangeFromPyramid :: [T v] -> (Int, Int) -> [v]
sumRangeFromPyramidRec :: (C v) => [T v] -> (Int, Int) -> v
sumRangeFromPyramidFoldr :: (C v) => [T v] -> (Int, Int) -> v
sumsPosModulated :: (C v) => T (Int, Int) -> T v -> T v

-- | Moving average, where window bounds must be always non-negative.
--   
--   The laziness granularity is <tt>2^height</tt>.
sumsPosModulatedPyramid :: (C v) => Int -> T (Int, Int) -> T v -> T v

-- | The first argument is the amplification. The main reason to introduce
--   it, was to have only a Module constraint instead of Field. This way we
--   can also filter stereo signals.
--   
--   A control value <tt>n</tt> corresponds to filter window size
--   <tt>2*n+1</tt>.
movingAverageModulatedPyramid :: (C a, C a v) => a -> Int -> Int -> T Int -> T v -> T v

-- | Forward difference quotient. Shortens the signal by one. Inverts
--   <tt>Synthesizer.Plain.Filter.Recursive.Integration.run</tt> in the
--   sense that <tt>differentiate (zero : integrate x) == x</tt>. The
--   signal is shifted by a half time unit.
differentiate :: (C v) => T v -> T v

-- | Central difference quotient. Shortens the signal by two elements, and
--   shifts the signal by one element. (Which can be fixed by prepending an
--   appropriate value.) For linear functions this will yield essentially
--   the same result as <a>differentiate</a>. You obtain the result of
--   <a>differentiateCenter</a> if you smooth the one of
--   <a>differentiate</a> by averaging pairs of adjacent values.
--   
--   ToDo: Vector variant
differentiateCenter :: (C v) => T v -> T v

-- | Second derivative. It is <tt>differentiate2 == differentiate .
--   differentiate</tt> but <a>differentiate2</a> should be faster.
differentiate2 :: (C v) => T v -> T v


module Synthesizer.Plain.Filter.Recursive.MovingAverage

-- | Like <tt>Synthesizer.Plain.Filter.NonRecursive.sums</tt> but in a
--   recursive form. This needs only linear time (independent of the window
--   size) but may accumulate rounding errors.
--   
--   <pre>
--   ys = xs * (1,0,0,0,-1) / (1,-1)
--   ys * (1,-1) = xs * (1,0,0,0,-1)
--   ys = xs * (1,0,0,0,-1) + ys * (0,1)
--   </pre>
sumsStaticInt :: (C v) => Int -> T v -> T v
modulatedFrac :: (C a, C a v) => Int -> T a -> T v -> T v

module Synthesizer.Basic.Phase
data T a
fromRepresentative :: (C a) => a -> T a
toRepresentative :: T a -> a
increment :: (C a) => a -> T a -> T a
decrement :: (C a) => a -> T a -> T a
multiply :: (C a, C b) => b -> T a -> T a
instance (Eq a) => Eq (T a)
instance (C a) => C (T a)
instance (C a, Random a) => Arbitrary (T a)
instance (C a, Random a) => Random (T a)
instance (Storable a) => Storable (T a)
instance (Show a) => Show (T a)


-- | Basic waveforms
--   
--   If you want to use parametrized waves with two parameters then zip
--   your parameter signals and apply <a>uncurry</a> to the wave function.
module Synthesizer.Basic.Wave
newtype T t y
Cons :: (T t -> y) -> T t y
decons :: T t y -> T t -> y
fromFunction :: (t -> y) -> (T t y)
raise :: (C y) => y -> T t y -> T t y
amplify :: (C y) => y -> T t y -> T t y
distort :: (y -> z) -> T t y -> T t z
overtone :: (C t, C n) => n -> T t y -> T t y
apply :: T t y -> (T t -> y)

-- | Turn an unparametrized waveform into a parametrized one, where the
--   parameter is a phase offset. This way you express a phase modulated
--   oscillator using a shape modulated oscillator.
--   
--   <tt>flip phaseOffset</tt> could have also be named
--   <tt>rotateLeft</tt>, since it rotates the wave to the left.
phaseOffset :: (C a) => T a b -> (a -> T a b)

-- | map a phase to value of a sine wave
sine :: (C a) => T a a
cosine :: (C a) => T a a
helix :: (C a) => T a (T a)

-- | Approximation of sine by parabolas. Surprisingly it is not really
--   faster than <a>sine</a>. The wave results from integrating the
--   <a>triangle</a> wave, thus it the <tt>k</tt>-th harmonic has amplitude
--   <tt>recip (k^3)</tt>.
fastSine2 :: (Ord a, C a) => T a a
fastSine2Alt :: (C a) => T a a

-- | Piecewise third order polynomial approximation by integrating
--   <a>fastSine2</a>.
fastSine3 :: (Ord a, C a) => T a a
fastSine3Alt :: (C a, C a) => T a a

-- | Piecewise fourth order polynomial approximation by integrating
--   <a>fastSine3</a>.
fastSine4 :: (Ord a, C a) => T a a
fastSine4Alt :: (C a, C a) => T a a

-- | Least squares approximation of sine by fourth order polynomials
--   computed with MuPad.
fastSine4LeastSquares :: (Ord a, C a) => T a a

-- | The coefficient of the highest power is the reciprocal of an element
--   from http:<i></i>www.research.att.com<i>~njas</i>sequences/A000111 and
--   the polynomial coefficients are
--   http:<i></i>www.research.att.com<i>~njas</i>sequences/A119879 .
--   
--   <pre>
--   mapM_ print $ map (\p -&gt; fmap ((round :: Rational -&gt; Integer) . (/last(Poly.coeffs p))) p) (take 10 $ fastSinePolynomials)
--   </pre>
fastSinePolynomials :: (C a) => [T a]
fastSines :: (C a) => [T a a]

-- | This is a helix that is distorted in phase such that is a purely
--   rational function. It is guaranteed that the magnitude of the wave is
--   one. For the distortion factor <tt>recip pi</tt> you get the closest
--   approximation to an undistorted helix. We have chosen this scaling in
--   order to stay with field operations.
rationalHelix1 :: (C a) => a -> T a (T a)
rationalHelix1Alt :: (C a) => a -> T a (T a)

-- | Here we distort the rational helix in phase using tangent
--   approximations by a sum of 2*n reciprocal functions. For the tangent
--   function we obtain perfect cosine and sine, thus for <tt>k = recip
--   pi</tt> and high <tt>n</tt> we approach an undistorted complex helix.
rationalHelix :: (C a) => Int -> a -> T a (T a)
helixFromTangent :: (C a) => a -> T a

-- | saw tooth, it's a ramp down in order to have a positive coefficient
--   for the first partial sine
saw :: (C a) => T a a

-- | This wave has the same absolute Fourier coefficients as <a>saw</a> but
--   the partial waves are shifted by 90 degree. That is, it is the Hilbert
--   transform of the saw wave. The formula is derived from
--   <a>sawComplex</a>.
sawCos :: (C a, C a) => T a a

-- | <pre>
--   sawCos + i*saw
--   </pre>
--   
--   This is an analytic function and thus it may be used for frequency
--   shifting.
--   
--   The formula can be derived from the power series of the logarithm
--   function.
sawComplex :: (Power a, C a) => T a (T a)

-- | square
square :: (Ord a, C a) => T a a

-- | This wave has the same absolute Fourier coefficients as <a>square</a>
--   but the partial waves are shifted by 90 degree. That is, it is the
--   Hilbert transform of the saw wave.
squareCos :: (C a, C a) => T a a

-- | <pre>
--   squareCos + i*square
--   </pre>
--   
--   This is an analytic function and thus it may be used for frequency
--   shifting.
--   
--   The formula can be derived from the power series of the area tangens
--   function.
squareComplex :: (Power a, C a) => T a (T a)

-- | triangle
triangle :: (Ord a, C a) => T a a

-- | A truncated cosine. This has rich overtones.
truncOddCosine :: (C a) => Int -> T a a

-- | For parameter zero this is <a>saw</a>.
truncOddTriangle :: (C a) => Int -> T a a

-- | A truncated cosine plus a ramp that guarantees a bump of high 2 at the
--   boundaries.
--   
--   It is <tt>truncCosine (2 * fromIntegral n + 0.5) == truncOddCosine
--   (2*n)</tt>
truncCosine :: (C a) => a -> T a a
truncTriangle :: (C a) => a -> T a a

-- | Power function.
--   
--   Roughly the map <tt>x p -&gt; x**p</tt> but retains the sign of
--   <tt>x</tt> and normalizes the mapping over <tt>[-1,1]</tt> to L2 norm
--   of 1.
powerNormed :: (C a, C a) => a -> T a a

-- | auxiliary
power01Normed :: (C a, C a) => a -> a -> a

-- | auxiliary
powerSigned :: (C a, C a) => a -> a -> a

-- | Tangens hyperbolicus allows interpolation between some kind of saw
--   tooth and square wave. In principle it is not necessary because you
--   can distort a saw tooth oscillation by <tt>map tanh</tt>.
logitSaw :: (C a) => a -> T a a

-- | Tangens hyperbolicus of a sine allows interpolation between some kind
--   of sine and square wave. In principle it is not necessary because you
--   can distort a square oscillation by <tt>map tanh</tt>.
logitSine :: (C a) => a -> T a a

-- | Interpolation between <a>sine</a> and <a>square</a>.
sineSquare :: (C a, C a) => a -> T a a

-- | Interpolation between <a>fastSine2</a> and <a>saw</a>. We just shrink
--   the parabola towards the borders and insert a linear curve such that
--   its slope matches the one of the parabola.
piecewiseParabolaSaw :: (C a, Ord a) => a -> T a a

-- | Interpolation between <a>sine</a> and <a>saw</a>. We just shrink the
--   sine towards the borders and insert a linear curve such that its slope
--   matches the one of the sine.
piecewiseSineSaw :: (C a, Ord a) => a -> T a a

-- | Interpolation between <a>sine</a> and <a>saw</a> with smooth
--   intermediate shapes but no perfect saw.
sineSawSmooth :: (C a) => a -> T a a

-- | Interpolation between <a>sine</a> and <a>saw</a> with perfect saw, but
--   sharp intermediate shapes.
sineSawSharp :: (C a) => a -> T a a
affineComb :: (C a) => a -> (a, a) -> a

-- | Harmonics of a saw wave that is smoothed by a Gaussian lowpass filter.
--   This can also be used to interpolate between saw wave and sine. The
--   parameter is the cutoff-frequency defined as the standard deviation of
--   the Gaussian in frequency space. That is, high values approximate a
--   saw and need many harmonics, whereas low values tend to a sine and
--   need only few harmonics.
sawGaussianHarmonics :: (C a, C a) => a -> [Harmonic a]

-- | saw with space
sawPike :: (Ord a, C a) => a -> T a a

-- | triangle with space
trianglePike :: (C a, C a) => a -> T a a

-- | triangle with space and shift
trianglePikeShift :: (C a, C a) => a -> a -> T a a

-- | square with space, can also be generated by mixing square waves with
--   different phases
squarePike :: (C a) => a -> T a a

-- | square with space and shift
squarePikeShift :: (C a) => a -> a -> T a a

-- | square with different times for high and low
squareAsymmetric :: (Ord a, C a) => a -> T a a

-- | Like <a>squareAsymmetric</a> but with zero average. It could be
--   simulated by adding two saw oscillations with 180 degree phase
--   difference and opposite sign.
squareBalanced :: (Ord a, C a) => a -> T a a

-- | triangle
triangleAsymmetric :: (Ord a, C a) => a -> T a a

-- | Mixing <a>trapezoid</a> and <a>trianglePike</a> you can get back a
--   triangle wave form
trapezoid :: (C a, C a) => a -> T a a

-- | Trapezoid with distinct high and low time. That is the high and low
--   trapezoids are symmetric itself, but the whole waveform is not
--   symmetric.
trapezoidAsymmetric :: (C a, C a) => a -> a -> T a a

-- | trapezoid with distinct high and low time and zero direct current
--   offset
trapezoidBalanced :: (C a, C a) => a -> a -> T a a

-- | parametrized trapezoid that can range from a saw ramp to a square
--   waveform.
trapezoidSkew :: (Ord a, C a) => a -> T a a

-- | This is similar to Polar coordinates, but the range of the phase is
--   from <tt>0</tt> to <tt>1</tt>, not <tt>0</tt> to <tt>2*pi</tt>.
--   
--   If you need to represent a harmonic by complex coefficients instead of
--   the polar representation, then please build a complex valued
--   polynomial from your coefficients and use it to distort a
--   <a>helix</a>.
--   
--   <pre>
--   distort (Poly.evaluate (Poly.fromCoeffs complexCoefficients)) helix
--   </pre>
data Harmonic a
Harmonic :: T a -> a -> Harmonic a
harmonicPhase :: Harmonic a -> T a
harmonicAmplitude :: Harmonic a -> a
harmonic :: T a -> a -> Harmonic a

-- | Specify the wave by its harmonics.
--   
--   The function is implemented quite efficiently by applying the Horner
--   scheme to a polynomial with complex coefficients (the harmonic
--   parameters) using a complex exponential as argument.
composedHarmonics :: (C a) => [Harmonic a] -> T a a
instance Applicative (T t)
instance Functor (T t)
instance (C a y) => C a (T t y)
instance (C y) => C (T t y)


-- | Waveforms which are smoothed according to the oscillator frequency in
--   order to suppress aliasing effects.
module Synthesizer.Basic.WaveSmoothed
data T t y
fromFunction :: (t -> t -> y) -> (T t y)

-- | Use this function for waves which are sufficiently smooth. If the
--   Nyquist frequency is exceeded the wave is simply replaced by a
--   constant zero wave.
fromWave :: (C t, C t, C y) => T t y -> (T t y)
fromControlledWave :: (C t, C t, C y) => (t -> T t y) -> (T t y)
raise :: (C y) => y -> T t y -> T t y
amplify :: (C y) => y -> T t y -> T t y
distort :: (y -> z) -> T t y -> T t z
apply :: T t y -> (t -> T t -> y)

-- | map a phase to value of a sine wave
sine :: (C a, C a) => T a a
cosine :: (C a, C a) => T a a

-- | saw tooth, it's a ramp down in order to have a positive coefficient
--   for the first partial sine
saw :: (C a, C a) => T a a

-- | square
square :: (C a, C a) => T a a

-- | triangle
triangle :: (C a, C a) => T a a

-- | This is similar to Polar coordinates, but the range of the phase is
--   from <tt>0</tt> to <tt>1</tt>, not <tt>0</tt> to <tt>2*pi</tt>.
--   
--   If you need to represent a harmonic by complex coefficients instead of
--   the polar representation, then please build a complex valued
--   polynomial from your coefficients and use it to distort a
--   <a>helix</a>.
--   
--   <pre>
--   distort (Poly.evaluate (Poly.fromCoeffs complexCoefficients)) helix
--   </pre>
data Harmonic a
harmonic :: T a -> a -> Harmonic a

-- | Specify the wave by its harmonics.
--   
--   The function is implemented quite efficiently by applying the Horner
--   scheme to a polynomial with complex coefficients (the harmonic
--   parameters) using a complex exponential as argument.
composedHarmonics :: (C a, C a) => [Harmonic a] -> T a a
instance (C a y) => C a (T t y)
instance (C y) => C (T t y)


-- | The distortion functions have slope 1 at zero, if they are
--   differentiable at that point, at all. This ensures that signals with
--   low amplitude are only slightly altered. Non-differentiable
--   distortions try to have an overall slope of 1.
module Synthesizer.Basic.Distortion

-- | limit, fuzz booster
clip :: (C a) => a -> a

-- | logit, tanh
logit :: (C a) => a -> a

-- | zig-zag
zigZag :: (C a) => a -> a

-- | sine
sine :: (C a) => a -> a

-- | Odd Chebyshev polynomial
--   
--   <tt>oddChebyshev n</tt> is an appropriately scaled Chebyshev
--   polynomial of order <tt>2*n+1</tt>. The argument <tt>n</tt> must be
--   non-negative.
--   
--   <pre>
--   Graphics.Gnuplot.Simple.plotFuncs [Graphics.Gnuplot.Simple.YRange (-1,1)] (Graphics.Gnuplot.Simple.linearScale 1000 (-7,7::Double)) (List.map oddChebyshev [0..5])
--   </pre>
oddChebyshev :: (C a) => (C a) => Int -> a -> a
quantize :: (C a) => a -> a

module Synthesizer.Basic.DistortionControlled

-- | limit, fuzz booster
clip :: (C a) => a -> a -> a

-- | logit, tanh
logit :: (C a) => a -> a -> a

-- | zig-zag
zigZag :: (C a) => a -> a -> a

-- | sine
sine :: (C a) => a -> a -> a
quantize :: (C a) => a -> a -> a

module Synthesizer.Frame.Stereo
data T a :: * -> *
left :: T a -> a
right :: T a -> a
cons :: a -> a -> T a
map :: (a -> b) -> T a -> T b

-- | Run a causal process independently on each stereo channel.
arrowFromMono :: (Arrow arrow) => arrow a b -> arrow (T a) (T b)
arrowFromMonoControlled :: (Arrow arrow) => arrow (c, a) b -> arrow (c, T a) (T b)
arrowFromChannels :: (Arrow arrow) => arrow a b -> arrow a b -> arrow (T a) (T b)


-- | Chunky signal stream build on StorableVector.
--   
--   Hints for fusion: - Higher order functions should always be inlined in
--   the end in order to turn them into machine loops instead of calling a
--   function in an inner loop.
module Synthesizer.Storable.Signal
type T = Vector
hPut :: (Storable a) => Handle -> Vector a -> IO ()
data ChunkSize :: *
chunkSize :: Int -> ChunkSize
defaultChunkSize :: ChunkSize
scanL :: (Storable a, Storable b) => (a -> b -> a) -> a -> T b -> T a
map :: (Storable x, Storable y) => (x -> y) -> Vector x -> Vector y
iterate :: (Storable a) => ChunkSize -> (a -> a) -> a -> Vector a

-- | Generates laziness breaks wherever one of the input signals has a
--   chunk boundary.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
append :: (Storable a) => Vector a -> Vector a -> Vector a
concat :: (Storable a) => [Vector a] -> Vector a
span :: (Storable a) => (a -> Bool) -> Vector a -> (Vector a, Vector a)
splitAt :: (Storable a) => Int -> Vector a -> (Vector a, Vector a)
viewL :: (Storable a) => Vector a -> Maybe (a, Vector a)
viewR :: (Storable a) => Vector a -> Maybe (Vector a, a)
switchL :: (Storable a) => b -> (a -> Vector a -> b) -> Vector a -> b
unfoldr :: (Storable b) => ChunkSize -> (a -> Maybe (b, a)) -> a -> Vector b
reverse :: (Storable a) => Vector a -> Vector a
crochetL :: (Storable x, Storable y) => (x -> acc -> Maybe (y, acc)) -> acc -> Vector x -> Vector y
writeFile :: (Storable a) => FilePath -> Vector a -> IO ()

-- | This implementation generates laziness breaks whereever one of the
--   original sequences has laziness breaks. It should be commutative in
--   this respect.
--   
--   It is more efficient than <a>mixSize</a> since it appends the rest of
--   the longer signal without copying.
mix :: (C x, Storable x) => T x -> T x -> T x

-- | Mix while maintaining the pattern of the second operand. This is
--   closer to the behavior of Vector.zipWithLastPattern.
mixSndPattern :: (C x, Storable x) => T x -> T x -> T x
mixSize :: (C x, Storable x) => ChunkSize -> T x -> T x -> T x
splitAtPad :: (C x, Storable x) => ChunkSize -> Int -> T x -> (T x, T x)
null :: (Storable a) => Vector a -> Bool
fromChunks :: (Storable a) => [Vector a] -> Vector a
foldr :: (Storable b) => (b -> a -> a) -> a -> Vector b -> a
delay :: (Storable y) => ChunkSize -> y -> Int -> T y -> T y
delayLoop :: (Storable y) => (T y -> T y) -> T y -> T y
delayLoopOverlap :: (C y, Storable y) => Int -> (T y -> T y) -> T y -> T y
empty :: (Storable a) => Vector a
cons :: (Storable a) => a -> Vector a -> Vector a
replicate :: (Storable a) => ChunkSize -> Int -> a -> Vector a
repeat :: (Storable a) => ChunkSize -> a -> Vector a
drop :: (Storable a) => Int -> Vector a -> Vector a
take :: (Storable a) => Int -> Vector a -> Vector a
takeCrochet :: (Storable a) => Int -> T a -> T a
fromList :: (Storable a) => ChunkSize -> [a] -> T a
zipWithRest :: (Storable c, Storable x) => (x -> x -> c) -> T x -> T x -> (Vector c, (Bool, T x))
zipWithAppend :: (Storable x) => (x -> x -> x) -> T x -> T x -> T x
switchR :: (Storable a) => b -> (Vector a -> a -> b) -> Vector a -> b
toList :: (Storable a) => T a -> [a]
chunks :: Vector a -> [Vector a]
genericLength :: (C i) => T x -> i

module Synthesizer.Storable.Cut
arrange :: (Storable v, C v) => ChunkSize -> T Int (T v) -> T v

-- | Chunk sizes are adapted to the time differences. Explicit ChunkSize
--   parameter is only required for zero padding. Since no ST monad is
--   needed, this can be generalized to Generic.Signal.Transform class.
arrangeAdaptive :: (Storable v, C v) => ChunkSize -> T Int (T v) -> T v

-- | This function also uses the time differences as chunk sizes, but may
--   occasionally use smaller chunk sizes due to the chunk structure of an
--   input signal until the next signal starts.
arrangeList :: (Storable v, C v) => ChunkSize -> T Int (T v) -> T v
addShiftedMany :: (Storable a, C a) => ChunkSize -> [Int] -> [T a] -> T a
addShifted :: (Storable a, C a) => ChunkSize -> Int -> T a -> T a -> T a

-- | The result is a Lazy StorableVector with chunks of the given size.
arrangeEquidist :: (Storable v, C v) => ChunkSize -> T Int (T v) -> T v
addToBuffer :: (Storable a, C a) => Vector s a -> Int -> T a -> ST s (Int, T a)

-- | chunk must fit into the buffer
addChunkToBuffer :: (Storable a, C a) => Vector s a -> Int -> Vector a -> ST s ()

-- | chunk must fit into the buffer
addChunkToBufferFoldr :: (Storable a, C a) => Vector s a -> Int -> Vector a -> ST s ()
addToBufferFoldr :: (Storable a, C a) => Vector s a -> Int -> T a -> ST s (Int, T a)
addToBufferSwitchL :: (Storable a, C a) => Vector s a -> Int -> T a -> ST s (Int, T a)


-- | Tone generators
module Synthesizer.Storable.Oscillator

-- | Convert a list of phase steps into a list of momentum phases phase is
--   a number in the interval [0,1) freq contains the phase steps
freqToPhase :: (C a, Storable a) => T a -> T a -> T (T a)

-- | oscillator with constant frequency
static :: (C a, Storable a, Storable b) => ChunkSize -> T a b -> (T a -> a -> T b)

-- | oscillator with modulated phase
phaseMod :: (C a, Storable a, Storable b) => ChunkSize -> T a b -> a -> T a -> T b

-- | oscillator with modulated shape
shapeMod :: (C a, Storable a, Storable b, Storable c) => ChunkSize -> (c -> T a b) -> T a -> a -> T c -> T b

-- | oscillator with modulated frequency
freqMod :: (C a, Storable a, Storable b) => ChunkSize -> T a b -> T a -> T a -> T b

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a, Storable a, Storable b) => ChunkSize -> T a b -> T a -> T a -> T b

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a, Storable a, Storable b, Storable c) => ChunkSize -> (c -> T a b) -> T a -> T c -> T a -> T b

-- | sine oscillator with static frequency
staticSine :: (C a, C a, Storable a) => ChunkSize -> T a -> a -> T a

-- | sine oscillator with modulated frequency
freqModSine :: (C a, C a, Storable a) => ChunkSize -> T a -> T a -> T a

-- | sine oscillator with modulated phase, useful for FM synthesis
phaseModSine :: (C a, C a, Storable a) => ChunkSize -> a -> T a -> T a

-- | saw tooth oscillator with modulated frequency
staticSaw :: (C a, Storable a) => ChunkSize -> T a -> a -> T a

-- | saw tooth oscillator with modulated frequency
freqModSaw :: (C a, Storable a) => ChunkSize -> T a -> T a -> T a

module Synthesizer.Basic.Binary
class C a
outputFromCanonical :: (C a, Bounded int, C int, Monoid out) => (int -> out) -> a -> out
numberOfChannels :: (C a) => a -> Int
toCanonical :: (C real, Bounded int, C int) => (int -> real)
fromCanonicalWith :: (C real, Bounded int, C int) => (real -> int) -> (real -> int)
numberOfSignalChannels :: (C yv) => sig yv -> Int
int16ToCanonical :: (C a) => Int16 -> a
int16FromCanonical :: (C a) => a -> Int16
int16FromFloat :: Float -> Int16
int16FromDouble :: Double -> Int16
instance (C a) => C (T a)
instance (C a, C b) => C (a, b)
instance C Double
instance C Float

module Synthesizer.Plain.Builder
data T a
type Put a = a -> T a
put :: Put a
run :: T a -> [a]
signalToBinary :: (C v, C int, Bounded int) => [v] -> [int]
signalToBinaryMono :: (C a, C int, Bounded int) => [a] -> [int]
signalToBinaryStereo :: (C a, C int, Bounded int) => [(a, a)] -> [int]
instance Monoid (T a)

module Synthesizer.Plain.File

-- | See <a>write</a>.
render :: (Storable int, C int, C int, Bounded int, C a, C v) => Put int -> FilePath -> a -> (a -> [v]) -> IO ExitCode
renderToInt16 :: (C a, C v) => FilePath -> a -> (a -> [v]) -> IO ExitCode
renderMonoToInt16 :: (C a) => FilePath -> a -> (a -> [a]) -> IO ExitCode
renderStereoToInt16 :: (C a) => FilePath -> a -> (a -> [(a, a)]) -> IO ExitCode

-- | The output format is determined by SoX by the file name extension. The
--   sample precision is determined by the provided <a>Put</a> function.
--   
--   Example:
--   
--   <pre>
--   import qualified Synthesizer.Plain.Builder as Builder
--   
--   write (Builder.put :: Builder.Put Int16) "test.aiff" 44100 sound
--   </pre>
write :: (Storable int, C int, C int, Bounded int, C a, C v) => Put int -> FilePath -> a -> [v] -> IO ExitCode
writeToInt16 :: (C a, C v) => FilePath -> a -> [v] -> IO ExitCode
writeMonoToInt16 :: (C a) => FilePath -> a -> [a] -> IO ExitCode
writeStereoToInt16 :: (C a) => FilePath -> a -> [(a, a)] -> IO ExitCode
writeRaw :: (C a, C v, Storable v) => T -> FilePath -> a -> [v] -> IO ExitCode

-- | You hardly need this routine since you can use a filename with
--   <tt>.mp3</tt> or <tt>.ogg</tt> extension for <a>writeRaw</a> and SoX
--   will do the corresponding compression for you.
writeRawCompressed :: (C a, C v, Storable v) => T -> FilePath -> a -> [v] -> IO ExitCode
rawToAIFF :: (C a) => FilePath -> T -> a -> Int -> IO ExitCode
compress :: FilePath -> IO ExitCode
readAIFFMono :: (C a) => FilePath -> IO [a]

-- | I suspect we cannot handle file closing properly.
readMonoFromInt16 :: (C a) => FilePath -> IO [a]
getInt16List :: Get [Int16]

module Synthesizer.Plain.Play

-- | See <tt>Synthesizer.Plain.File.write</tt>.
render :: (Storable int, C int, C int, Bounded int, C a, C v) => Put int -> a -> (a -> [v]) -> IO ExitCode
renderToInt16 :: (C a, C v) => a -> (a -> [v]) -> IO ExitCode
renderMonoToInt16 :: (C a) => a -> (a -> [a]) -> IO ExitCode
renderStereoToInt16 :: (C a) => a -> (a -> [(a, a)]) -> IO ExitCode

-- | See <tt>Synthesizer.Plain.File.write</tt>.
auto :: (Storable int, C int, C int, Bounded int, C a, C v) => Put int -> a -> [v] -> IO ExitCode
toInt16 :: (C a, C v) => a -> [v] -> IO ExitCode
monoToInt16 :: (C a) => a -> [a] -> IO ExitCode
stereoToInt16 :: (C a) => a -> [(a, a)] -> IO ExitCode
raw :: (C a, C v, Storable v) => T -> a -> [v] -> IO ExitCode
exampleMono :: IO ExitCode
exampleStereo :: IO ExitCode

module Synthesizer.Storable.Play

-- | Latency is high using Sox - We can achieve better results using ALSA's
--   sound output! See synthesizer-alsa package.
monoToInt16 :: (Storable a, C a) => a -> T a -> IO ExitCode
stereoToInt16 :: (Storable a, C a) => a -> T (T a) -> IO ExitCode


-- | Construction of a data type that describes piecewise defined curves.
module Synthesizer.Piecewise
type T t y sig = [PieceData t y sig]

-- | The curve type of a piece of a piecewise defined control curve.
newtype Piece t y sig
Piece :: (y -> y -> t -> sig) -> Piece t y sig
computePiece :: Piece t y sig -> y -> y -> t -> sig
pieceFromFunction :: (y -> y -> t -> sig) -> Piece t y sig

-- | The full description of a control curve piece.
data PieceData t y sig
PieceData :: Piece t y sig -> y -> y -> t -> PieceData t y sig
pieceType :: PieceData t y sig -> Piece t y sig
pieceY0 :: PieceData t y sig -> y
pieceY1 :: PieceData t y sig -> y
pieceDur :: PieceData t y sig -> t
newtype PieceRightSingle y
PRS :: y -> PieceRightSingle y
newtype PieceRightDouble y
PRD :: y -> PieceRightDouble y
data PieceDist t y sig
PD :: t -> (Piece t y sig) -> y -> PieceDist t y sig

-- | The 6 operators simplify constructing a list of <tt>PieceData a</tt>.
--   The description consists of nodes (namely the curve values at nodes)
--   and the connecting curve types. The naming scheme is as follows: In
--   the middle there is a bar <tt>|</tt>. With respect to the bar, the pad
--   symbol <tt>#</tt> is at the side of the curve type, at the other side
--   there is nothing, a minus sign <tt>-</tt>, or an equality sign
--   <tt>=</tt>.
--   
--   <ol>
--   <li>Nothing means that here is the start or the end node of a
--   curve.</li>
--   <li>Minus means that here is a node where left and right curve meet at
--   the same value. The node description is thus one value.</li>
--   <li>Equality sign means that here is a split node, where left and
--   right curve might have different ending and beginning values,
--   respectively. The node description consists of a pair of values.</li>
--   </ol>
(#|-) :: (t, Piece t y sig) -> (PieceRightSingle y, T t y sig) -> (PieceDist t y sig, T t y sig)
(-|#) :: y -> (PieceDist t y sig, T t y sig) -> (PieceRightSingle y, T t y sig)
(#|=) :: (t, Piece t y sig) -> (PieceRightDouble y, T t y sig) -> (PieceDist t y sig, T t y sig)
(=|#) :: (y, y) -> (PieceDist t y sig, T t y sig) -> (PieceRightDouble y, T t y sig)
(#|) :: (t, Piece t y sig) -> y -> (PieceDist t y sig, T t y sig)
(|#) :: y -> (PieceDist t y sig, T t y sig) -> T t y sig


-- | Very simple random number generator which should be fast and should
--   suffice for generating just noise.
--   <a>http://www.softpanorama.org/Algorithms/random_generators.shtml</a>
module Synthesizer.RandomKnuth
data T
cons :: Int -> T
instance Show T
instance RandomGen T

module Synthesizer.Format
class C sig
format :: (C sig, Show x) => Int -> sig x -> ShowS


-- | ToDo: Better name for the module is certainly
--   Synthesizer.Generator.Signal
module Synthesizer.State.Signal

-- | Cf. StreamFusion Data.Stream
data T a
Cons :: !StateT s Maybe a -> !s -> T a

-- | It is a common pattern to use <tt>switchL</tt> or <tt>viewL</tt> in a
--   loop in order to traverse a signal. However this needs repeated
--   packing and unpacking of the <a>viewL</a> function and the state. It
--   seems that GHC is not clever enough to detect, that the <tt>view</tt>
--   function does not change. With <a>runViewL</a> you can unpack a stream
--   once and use an efficient <a>viewL</a> in the loop.
runViewL :: T y -> (forall s. (s -> Maybe (y, s)) -> s -> x) -> x
runSwitchL :: T y -> (forall s. (forall z. z -> (y -> s -> z) -> s -> z) -> s -> x) -> x
generate :: (acc -> Maybe (y, acc)) -> acc -> T y
unfoldR :: (acc -> Maybe (y, acc)) -> acc -> T y
generateInfinite :: (acc -> (y, acc)) -> acc -> T y
fromList :: [y] -> T y
toList :: T y -> [y]
fromStorableSignal :: (Storable a) => T a -> T a
toStorableSignal :: (Storable a) => ChunkSize -> T a -> T a
toStrictStorableSignal :: (Storable a) => Int -> T a -> Vector a
toStorableSignalVary :: (Storable a) => LazySize -> T a -> T a
fromPiecewiseConstant :: (C time, Integral time) => T time a -> T a
iterate :: (a -> a) -> a -> T a
iterateAssociative :: (a -> a -> a) -> a -> T a
repeat :: a -> T a
crochetL :: (x -> acc -> Maybe (y, acc)) -> acc -> T x -> T y
scanL :: (acc -> x -> acc) -> acc -> T x -> T acc

-- | input and output have equal length, that's better for fusion
scanLClip :: (acc -> x -> acc) -> acc -> T x -> T acc
map :: (a -> b) -> (T a -> T b)

-- | This function will recompute the input lists and is thus probably not
--   what you want. If you want to avoid recomputation please consider
--   Causal.Process.
unzip :: T (a, b) -> (T a, T b)
unzip3 :: T (a, b, c) -> (T a, T b, T c)

-- | This is a fusion friendly implementation of delay. However, in order
--   to be a <a>crochetL</a> the output has the same length as the input,
--   that is, the last element is removed - at least for finite input.
delay1 :: a -> T a -> T a
delay :: y -> Int -> T y -> T y
take :: Int -> T a -> T a
takeWhile :: (a -> Bool) -> T a -> T a
replicate :: Int -> a -> T a
zipWith :: (a -> b -> c) -> (T a -> T b -> T c)
zipWithStorable :: (Storable b, Storable c) => (a -> b -> c) -> (T a -> T b -> T c)
zipWith3 :: (a -> b -> c -> d) -> (T a -> T b -> T c -> T d)
zipWith4 :: (a -> b -> c -> d -> e) -> (T a -> T b -> T c -> T d -> T e)
zip :: T a -> T b -> T (a, b)
zip3 :: T a -> T b -> T c -> T (a, b, c)
zip4 :: T a -> T b -> T c -> T d -> T (a, b, c, d)
foldL' :: (x -> acc -> acc) -> acc -> T x -> acc
foldL :: (acc -> x -> acc) -> acc -> T x -> acc
length :: T a -> Int
equal :: (Eq a) => T a -> T a -> Bool
foldR :: (x -> acc -> acc) -> acc -> T x -> acc
null :: T a -> Bool
empty :: T a
singleton :: a -> T a

-- | This is expensive and should not be used to construct lists
--   iteratively!
cons :: a -> T a -> T a
viewL :: T a -> Maybe (a, T a)
viewR :: (Storable a) => T a -> Maybe (T a, a)
viewRSize :: (Storable a) => ChunkSize -> T a -> Maybe (T a, a)
switchL :: b -> (a -> T a -> b) -> T a -> b
switchR :: (Storable a) => b -> (T a -> a -> b) -> T a -> b

-- | This implementation requires that the input generator has to check
--   repeatedly whether it is finished.
extendConstant :: T a -> T a
drop :: Int -> T a -> T a

-- | This implementation expects that looking ahead is cheap.
dropMarginRem :: Int -> Int -> T a -> (Int, T a)
dropMargin :: Int -> Int -> T a -> T a
dropMatch :: T b -> T a -> T a
index :: Int -> T a -> a
splitAt :: (Storable a) => Int -> T a -> (T a, T a)
splitAtSize :: (Storable a) => ChunkSize -> Int -> T a -> (T a, T a)
dropWhile :: (a -> Bool) -> T a -> T a
span :: (Storable a) => (a -> Bool) -> T a -> (T a, T a)
spanSize :: (Storable a) => ChunkSize -> (a -> Bool) -> T a -> (T a, T a)
cycle :: T a -> T a
mix :: (C a) => T a -> T a -> T a
sub :: (C a) => T a -> T a -> T a
neg :: (C a) => T a -> T a
append :: T a -> T a -> T a
appendStored :: (Storable a) => T a -> T a -> T a
appendStoredSize :: (Storable a) => ChunkSize -> T a -> T a -> T a

-- | certainly inefficient because of frequent list deconstruction
concat :: [T a] -> T a
concatStored :: (Storable a) => [T a] -> T a
concatStoredSize :: (Storable a) => ChunkSize -> [T a] -> T a
liftA2 :: (a -> b -> c) -> (T a -> T b -> T c)
reverse :: T a -> T a
reverseStored :: (Storable a) => T a -> T a
reverseStoredSize :: (Storable a) => ChunkSize -> T a -> T a
sum :: (C a) => T a -> a
maximum :: (Ord a) => T a -> a
init :: T y -> T y
sliceVert :: Int -> T y -> [T y]
zapWith :: (a -> a -> b) -> T a -> T b
zapWithAlt :: (a -> a -> b) -> T a -> T b
mapAdjacent :: (a -> a -> b) -> T a -> T b
modifyStatic :: Simple s ctrl a b -> ctrl -> T a -> T b

-- | Here the control may vary over the time.
modifyModulated :: Simple s ctrl a b -> T ctrl -> T a -> T b
linearComb :: (C t y) => T t -> T y -> y
mapTails :: (T y0 -> y1) -> T y0 -> T y1
zipWithTails :: (y0 -> T y1 -> y2) -> T y0 -> T y1 -> T y2
zipWithAppend :: (y -> y -> y) -> T y -> T y -> T y
zipStep :: (s -> Maybe (a, s)) -> (t -> Maybe (a, t)) -> (a -> a -> a) -> (s, t) -> Maybe (a, (s, t))
delayLoop :: (T y -> T y) -> T y -> T y
delayLoopOverlap :: (C y) => Int -> (T y -> T y) -> T y -> T y
sequence_ :: (Monad m) => T (m a) -> m ()
mapM_ :: (Monad m) => (a -> m ()) -> T a -> m ()

-- | Counterpart to <tt>Data.Monoid.mconcat</tt>.
monoidConcat :: (Monoid m) => T m -> m
monoidConcatMap :: (Monoid m) => (a -> m) -> T a -> m
catMaybes :: T (Maybe a) -> T a
flattenPairs :: T (a, a) -> T a
instance Monoid (T y)
instance (C y yv) => C y (T yv)
instance (C y) => C (T y)
instance Monad T
instance Applicative T
instance Functor T
instance C T
instance (Eq y) => Eq (T y)
instance (Show y) => Show (T y)

module Synthesizer.Interpolation

-- | interpolation as needed for resampling
data T t y
Cons :: !Margin -> !t -> T y -> y -> T t y
margin :: T t y -> !Margin
func :: T t y -> !t -> T y -> y
data Margin
Margin :: !Int -> !Int -> Margin

-- | interpolation requires a total number of <a>number</a>
marginNumber :: Margin -> !Int

-- | interpolation requires <a>offset</a> values before the current
marginOffset :: Margin -> !Int
cons :: Int -> Int -> (t -> T y -> y) -> T t y
number :: T t y -> Int
offset :: T t y -> Int
newtype PrefixReader y a
PrefixReader :: (Writer (Sum Int) (StateT (T y) Maybe a)) -> PrefixReader y a
getNode :: PrefixReader y y
fromPrefixReader :: String -> Int -> PrefixReader y (t -> y) -> T t y

-- | Consider the signal to be piecewise constant, where the leading value
--   is used for filling the interval [0,1).
constant :: T t y
instance Show Margin
instance Eq Margin
instance Applicative (PrefixReader y)
instance Functor (PrefixReader y)

module Synthesizer.Basic.ToneModulation

-- | Convert from the (shape,phase) parameter pair to the index within a
--   wave (step) and the index of a wave (leap) in the sampled prototype
--   tone.
--   
--   For this routine it would be simpler, if <tt>shape</tt> would measure
--   in multiples of <tt>period</tt> (we would only need a Ring instance),
--   but for <tt>shapeLimit</tt> it is better the way it is.
untangleShapePhase :: (C a) => Int -> a -> (a, a) -> (a, a)
untangleShapePhaseAnalytic :: (C a) => Int -> a -> (a, a) -> (a, a)
solveSLE2 :: (C a) => ((a, a), (a, a)) -> (a, a) -> (a, a)
det2 :: (C a) => ((a, a), (a, a)) -> a
flattenShapePhaseAnalytic :: (C a) => Int -> a -> (a, T a) -> (Int, (a, a))
flattenShapePhase :: (C a) => Int -> a -> (a, T a) -> (Int, (a, a))
shapeLimits :: (C t) => Margin -> Margin -> Int -> t -> (t, t)
interpolationOffset :: Margin -> Margin -> Int -> Int
interpolationNumber :: Margin -> Margin -> Int -> Int
type Coords t = (Int, (Int, (t, t)))
type Skip t = (Int, (t, T t))


-- | See NumericPrelude.AffineSpace for design discussion.
module Synthesizer.Interpolation.Class

-- | Given that <tt>scale zero v == Additive.zero</tt> this type class is
--   equivalent to Module in the following way:
--   
--   <pre>
--   scaleAndAccumulate (a,x) =
--      let ax = a *&gt; x
--      in  (ax, (ax+))
--   </pre>
--   
--   (see implementation of <a>scaleAndAccumulateModule</a>) and
--   
--   <pre>
--   x+y = scaleAccumulate one y $ scale one x
--   zero = scale zero x
--   s*&gt;x = scale s x
--   </pre>
--   
--   But this redundancy is only because of a lack of the type system or
--   lack of my imagination how to solve it better. Use this type class for
--   all kinds of interpolation, that is where addition and scaling alone
--   make no sense.
--   
--   I intended to name this class AffineSpace, because all interpolations
--   should be affine combinations. This property is equivalent to
--   interpolations that preserve constant functions. However, I cannot
--   easily assert this property and I'm not entirely sure that all
--   reasonable interpolations are actually affine.
--   
--   Early versions had a <tt>zero</tt> method, but this is against the
--   idea of interpolation. For implementing <tt>zero</tt> we needed a
--   <tt>Maybe</tt> wrapper for interpolation of <tt>StorableVector</tt>s.
--   Btw. having <tt>zero</tt> instead of <tt>scale</tt> is also
--   inefficient, since every sum must include a zero summand, which works
--   well only when the optimizer simplifies addition with a constant.
--   
--   We use only one class method that contains actually two methods:
--   <tt>scale</tt> and <tt>scaleAccumulate</tt>. We expect that instances
--   are always defined on record types lifting interpolations from scalars
--   to records. This should be done using <a>makeMac</a> and friends or
--   the <a>MAC</a> type and the <a>Applicative</a> interface for records
--   with many elements.
class (C a) => C a v
scaleAndAccumulate :: (C a v) => (a, v) -> (v, v -> v)
scale :: (C a v) => (a, v) -> v
scaleAccumulate :: (C a v) => (a, v) -> v -> v

-- | Infix variant of <a>scaleAccumulate</a>.
(+.*) :: (C a v) => v -> (a, v) -> v
combine2 :: (C a v) => a -> (v, v) -> v
combineMany :: (C a v) => (a, T a) -> (v, T v) -> v
scaleAndAccumulateRing :: (C a) => (a, a) -> (a, a -> a)
scaleAndAccumulateModule :: (C a v) => (a, v) -> (v, v -> v)
scaleAndAccumulateApplicative :: (C a v, Applicative f) => (a, f v) -> (f v, f v -> f v)
scaleAndAccumulateRingApplicative :: (C a, Applicative f) => (a, f a) -> (f a, f a -> f a)
scaleAndAccumulateModuleApplicative :: (C a v, Applicative f) => (a, f v) -> (f v, f v -> f v)

-- | A special reader monad.
newtype MAC a v x
MAC :: ((a, v) -> (x, v -> x)) -> MAC a v x
runMac :: MAC a v x -> (a, v) -> (x, v -> x)
element :: (C a x) => (v -> x) -> MAC a v x
makeMac :: (C a x) => (x -> v) -> (v -> x) -> (a, v) -> (v, v -> v)
makeMac2 :: (C a x, C a y) => (x -> y -> v) -> (v -> x) -> (v -> y) -> (a, v) -> (v, v -> v)
makeMac3 :: (C a x, C a y, C a z) => (x -> y -> z -> v) -> (v -> x) -> (v -> y) -> (v -> z) -> (a, v) -> (v, v -> v)
instance Applicative (MAC a v)
instance Functor (MAC a v)
instance (C a v) => C a (T v)
instance (C a v, C a w, C a u) => C a (v, w, u)
instance (C a v, C a w) => C a (v, w)
instance (C a) => C (T a) (T a)
instance (C a v) => C a (T v)
instance C Double Double
instance C Float Float


-- | This module allows abstraction of operations that operate on the time
--   axis and do also work on signal types without sample values. The most
--   distinctive instances are certainly Dirac signals and chunky time
--   values.
module Synthesizer.Generic.Cut
class Read sig
null :: (Read sig) => sig -> Bool
length :: (Read sig) => sig -> Int
class (Read sig) => NormalForm sig
evaluateHead :: (NormalForm sig) => sig -> ()
class (Read sig, Monoid sig) => Transform sig
take :: (Transform sig) => Int -> sig -> sig
drop :: (Transform sig) => Int -> sig -> sig
dropMarginRem :: (Transform sig) => Int -> Int -> sig -> (Int, sig)
splitAt :: (Transform sig) => Int -> sig -> (sig, sig)
reverse :: (Transform sig) => sig -> sig
intToChunky :: (C a, C a) => String -> Int -> T a
intToChunky98 :: (Num a, C a) => String -> Int -> T a
empty :: (Monoid sig) => sig
cycle :: (Monoid sig) => sig -> sig
append :: (Monoid sig) => sig -> sig -> sig
concat :: (Monoid sig) => [sig] -> sig

-- | Like <tt>lengthAtLeast n xs = length xs &gt;= n</tt>, but is more
--   efficient, because it is more lazy.
lengthAtLeast :: (Transform sig) => Int -> sig -> Bool
lengthAtMost :: (Transform sig) => Int -> sig -> Bool
sliceVertical :: (Transform sig) => Int -> sig -> T sig
instance (Integral a, C a) => Transform (T a)
instance (Integral a, C a, NFData a) => NormalForm (T a)
instance (Integral a) => Read (T a)
instance (C a, C a) => Transform (T a)
instance (C a, C a, NFData a) => NormalForm (T a)
instance (C a, C a) => Read (T a)
instance (Integral t, C t) => Transform (T t y)
instance (Integral t, NFData y) => NormalForm (T t y)
instance (Integral t) => Read (T t y)
instance Transform (T y)
instance (NFData y) => NormalForm (T y)
instance Read (T y)
instance Transform [y]
instance (NFData y) => NormalForm [y]
instance Read [y]
instance (Storable y) => Transform (Vector y)
instance (Storable y) => NormalForm (Vector y)
instance (Storable y) => Read (Vector y)


-- | Type classes that give a uniform interface to storable signals,
--   stateful signals, lists, fusable lists. Some of the signal types
--   require constraints on the element type. Storable signals require
--   Storable elements. Thus we need multiparameter type classes. In this
--   module we collect functions where the element type is not altered by
--   the function.
module Synthesizer.Generic.Signal
class (Read (sig y)) => Read sig y
toList :: (Read sig y) => sig y -> [y]
toState :: (Read sig y) => sig y -> T y
foldL :: (Read sig y) => (s -> y -> s) -> s -> sig y -> s
foldR :: (Read sig y) => (y -> s -> s) -> s -> sig y -> s
index :: (Read sig y) => sig y -> Int -> y
class (Read sig y, Transform (sig y)) => Transform sig y
cons :: (Transform sig y) => y -> sig y -> sig y
takeWhile :: (Transform sig y) => (y -> Bool) -> sig y -> sig y
dropWhile :: (Transform sig y) => (y -> Bool) -> sig y -> sig y
span :: (Transform sig y) => (y -> Bool) -> sig y -> (sig y, sig y)
viewL :: (Transform sig y) => sig y -> Maybe (y, sig y)
viewR :: (Transform sig y) => sig y -> Maybe (sig y, y)
map :: (Transform sig y) => (y -> y) -> (sig y -> sig y)
scanL :: (Transform sig y) => (y -> y -> y) -> y -> sig y -> sig y
crochetL :: (Transform sig y) => (y -> s -> Maybe (y, s)) -> s -> sig y -> sig y
zipWithAppend :: (Transform sig y) => (y -> y -> y) -> sig y -> sig y -> sig y

-- | This type is used for specification of the maximum size of strict
--   packets. Packets can be smaller, can have different sizes in one
--   signal. In some kinds of streams, like lists and stateful generators,
--   the packet size is always 1. The packet size is not just a burden
--   caused by efficiency, but we need control over packet size in
--   applications with feedback.
newtype LazySize
LazySize :: Int -> LazySize

-- | This can be used for internal signals that have no observable effect
--   on laziness. E.g. when you construct a list by <tt>repeat
--   defaultLazySize zero</tt> we assume that <tt>zero</tt> is defined for
--   all Additive types.
defaultLazySize :: LazySize

-- | We could provide the <a>LazySize</a> by a Reader monad, but we don't
--   do that because we expect that the choice of the lazy size is more
--   local than say the choice of the sample rate. E.g. there is no need to
--   have the same laziness coarseness for multiple signal processors.
class (Transform sig y) => Write sig y
fromList :: (Write sig y) => LazySize -> [y] -> sig y
repeat :: (Write sig y) => LazySize -> y -> sig y
replicate :: (Write sig y) => LazySize -> Int -> y -> sig y
iterate :: (Write sig y) => LazySize -> (y -> y) -> y -> sig y
iterateAssociative :: (Write sig y) => LazySize -> (y -> y -> y) -> y -> sig y
unfoldR :: (Write sig y) => LazySize -> (s -> Maybe (y, s)) -> s -> sig y
withStorableContext :: (ChunkSize -> a) -> (LazySize -> a)
switchL :: (Transform sig y) => a -> (y -> sig y -> a) -> sig y -> a
switchR :: (Transform sig y) => a -> (sig y -> y -> a) -> sig y -> a
runViewL :: (Read sig y) => sig y -> (forall s. (s -> Maybe (y, s)) -> s -> x) -> x
runSwitchL :: (Read sig y) => sig y -> (forall s. (forall z. z -> (y -> s -> z) -> s -> z) -> s -> x) -> x
mix :: (C y, Transform sig y) => sig y -> sig y -> sig y
zipWith :: (Read sig a, Transform sig b) => (a -> b -> b) -> (sig a -> sig b -> sig b)
zipWithState :: (Transform sig b) => (a -> b -> b) -> T a -> sig b -> sig b
zipWithState3 :: (Transform sig c) => (a -> b -> c -> c) -> (T a -> T b -> sig c -> sig c)
delay :: (Write sig y) => LazySize -> y -> Int -> sig y -> sig y
delayLoop :: (Transform sig y) => (sig y -> sig y) -> sig y -> sig y
delayLoopOverlap :: (C y, Write sig y) => Int -> (sig y -> sig y) -> sig y -> sig y
sum :: (C a, Read sig a) => sig a -> a
monoidConcatMap :: (Read sig a, Monoid m) => (a -> m) -> sig a -> m
tails :: (Transform sig y) => sig y -> T (sig y)

-- | Like <tt>tail</tt>, but for an empty signal it simply returns an empty
--   signal.
laxTail :: (Transform sig y) => sig y -> sig y
mapAdjacent :: (Read sig a, Transform sig a) => (a -> a -> a) -> sig a -> sig a
modifyStatic :: (Transform sig a) => Simple s ctrl a a -> ctrl -> sig a -> sig a

-- | Here the control may vary over the time.
modifyModulated :: (Transform sig a, Read sig ctrl) => Simple s ctrl a a -> sig ctrl -> sig a -> sig a
linearComb :: (C t y, Read sig t, Read sig y) => sig t -> sig y -> y
fromState :: (Write sig y) => LazySize -> T y -> sig y
extendConstant :: (Write sig y) => LazySize -> sig y -> sig y
mapTails :: (Transform sig a) => (sig a -> a) -> sig a -> sig a
mapTailsAlt :: (Transform sig a, Write sig b) => LazySize -> (sig a -> b) -> sig a -> sig b

-- | Only non-empty suffixes are processed. More oftenly we might need
--   
--   <pre>
--   zipWithTails :: (Read sig b, Transform2 sig a) =&gt;
--      (b -&gt; sig a -&gt; a) -&gt; sig b -&gt; sig a -&gt; sig a
--   </pre>
--   
--   this would preserve the chunk structure of <tt>sig a</tt>, but it is a
--   bit more hassle to implement that.
zipWithTails :: (Transform sig b, Transform sig a) => (a -> sig b -> a) -> sig a -> sig b -> sig a
indexByDrop :: (Transform sig a) => sig a -> Int -> a
null :: (Read sig) => sig -> Bool
length :: (Read sig) => sig -> Int
empty :: (Monoid sig) => sig
cycle :: (Monoid sig) => sig -> sig
append :: (Monoid sig) => sig -> sig -> sig
concat :: (Monoid sig) => [sig] -> sig
take :: (Transform sig) => Int -> sig -> sig
drop :: (Transform sig) => Int -> sig -> sig
dropMarginRem :: (Transform sig) => Int -> Int -> sig -> (Int, sig)
splitAt :: (Transform sig) => Int -> sig -> (sig, sig)
reverse :: (Transform sig) => sig -> sig

-- | Like <tt>lengthAtLeast n xs = length xs &gt;= n</tt>, but is more
--   efficient, because it is more lazy.
lengthAtLeast :: (Transform sig) => Int -> sig -> Bool
lengthAtMost :: (Transform sig) => Int -> sig -> Bool
sliceVertical :: (Transform sig) => Int -> sig -> T sig
instance Eq LazySize
instance Ord LazySize
instance Show LazySize
instance C LazySize
instance (C time, Integral time) => Write (T time) y
instance (C time, Integral time) => Transform (T time) y
instance (C time, Integral time) => Read (T time) y
instance Write T y
instance Transform T y
instance Read T y
instance Write [] y
instance Transform [] y
instance Read [] y
instance (Storable y) => Write Vector y
instance (Storable y) => Transform Vector y
instance (Storable y) => Read Vector y
instance C LazySize
instance C LazySize

module Synthesizer.ChunkySize
type T = T LazySize
fromStorableVectorSize :: LazySize -> T
toStorableVectorSize :: T -> LazySize
toNullList :: T -> [()]


-- | <a>http://en.wikipedia.org/wiki/Particle_displacement</a>
module Synthesizer.Generic.Displacement

-- | Mix two signals. In opposition to <a>zipWith</a> the result has the
--   length of the longer signal.
mix :: (C v, Transform sig v) => sig v -> sig v -> sig v

-- | Mix one or more signals.
mixMulti :: (C v, Transform sig v) => [sig v] -> sig v

-- | Add a number to all of the signal values. This is useful for adjusting
--   the center of a modulation.
raise :: (C v, Transform sig v) => v -> sig v -> sig v

-- | In <a>Synthesizer.Basic.Distortion</a> you find a collection of
--   appropriate distortion functions.
distort :: (Read sig c, Transform sig v) => (c -> v -> v) -> sig c -> sig v -> sig v
mapLinear :: (C a, Transform sig a) => a -> a -> sig a -> sig a
mapExponential :: (C a, Transform sig a) => a -> a -> sig a -> sig a


-- | Filter operators from calculus
module Synthesizer.Generic.Filter.Recursive.Integration

-- | Integrate with initial value zero. However the first emitted value is
--   the value of the input signal. It maintains the length of the signal.
run :: (C v, Transform sig v) => sig v -> sig v

-- | Integrate with initial condition. First emitted value is the initial
--   condition. The signal become one element longer.
runInit :: (C v, Transform sig v) => v -> sig v -> sig v


-- | Functions for cutting signals with respect to lazy chunky time
--   measures. This is essential for realtime applications.
module Synthesizer.ChunkySize.Cut
class (Read sig) => Read sig
length :: (Read sig) => sig -> T
class (Read sig, Monoid sig) => Transform sig
take :: (Transform sig) => T -> sig -> sig
drop :: (Transform sig) => T -> sig -> sig
splitAt :: (Transform sig) => T -> sig -> (sig, sig)
instance Transform (T y)
instance Read (T y)
instance Transform [y]
instance Read [y]
instance (Storable y) => Transform (Vector y)
instance (Storable y) => Read (Vector y)

module Synthesizer.ChunkySize.Signal
class (Write sig y, Transform (sig y)) => Write sig y
unfoldRN :: (Write sig y) => T -> (s -> Maybe (y, s)) -> s -> sig y
replicate :: (Write sig y) => T -> y -> sig y
iterateN :: (Write sig y) => (y -> y) -> T -> y -> sig y
fromState :: (Write sig y) => T -> T y -> sig y
instance Write T y
instance Write [] y
instance (Storable y) => Write Vector y

module Synthesizer.State.Displacement

-- | Mix two signals. In opposition to <a>zipWith</a> the result has the
--   length of the longer signal.
mix :: (C v) => T v -> T v -> T v

-- | Mix an arbitrary number of signals.
mixMulti :: (C v) => [T v] -> T v

-- | Add a number to all of the signal values. This is useful for adjusting
--   the center of a modulation.
raise :: (C v) => v -> T v -> T v

-- | In <a>Synthesizer.Basic.Distortion</a> you find a collection of
--   appropriate distortion functions.
distort :: (c -> a -> a) -> T c -> T a -> T a
mapLinear :: (C a) => a -> a -> T a -> T a
mapExponential :: (C a) => a -> a -> T a -> T a


module Synthesizer.State.Control
constant :: a -> T a
linear :: (C a) => a -> a -> T a

-- | As stable as the addition of time values.
linearMultiscale :: (C y) => y -> y -> T y

-- | Linear curve starting at zero.
linearMultiscaleNeutral :: (C y) => y -> T y

-- | Linear curve of a fixed length. The final value is not actually
--   reached, instead we stop one step before. This way we can concatenate
--   several lines without duplicate adjacent values.
line :: (C y) => Int -> (y, y) -> T y
exponentialMultiscale :: (C a) => a -> a -> T a
exponential :: (C a) => a -> a -> T a
exponentialMultiscaleNeutral :: (C y) => y -> T y
exponential2Multiscale :: (C a) => a -> a -> T a
exponential2 :: (C a) => a -> a -> T a
exponential2MultiscaleNeutral :: (C y) => y -> T y
exponentialFromToMultiscale :: (C y) => y -> y -> y -> T y
exponentialFromTo :: (C y) => y -> y -> y -> T y

-- | This is an extension of <a>exponential</a> to vectors which is
--   straight-forward but requires more explicit signatures. But since it
--   is needed rarely I setup a separate function.
vectorExponential :: (C a, C a v) => a -> v -> T v
vectorExponential2 :: (C a, C a v) => a -> v -> T v
cosine :: (C a) => a -> a -> T a
cubicHermite :: (C a) => (a, (a, a)) -> (a, (a, a)) -> T a
splitDurations :: (C t) => [t] -> [(Int, t)]
piecewise :: (C a) => T a a (a -> T a) -> T a
type Piece a = Piece a a (a -> T a)
stepPiece :: Piece a
linearPiece :: (C a) => Piece a
exponentialPiece :: (C a) => a -> Piece a
cosinePiece :: (C a) => Piece a
data FlatPosition
FlatLeft :: FlatPosition
FlatRight :: FlatPosition

-- | <pre>
--   Graphics.Gnuplot.Simple.plotList [] $ Sig.toList $ piecewise $ 1 |# (10.9, halfSinePiece FlatRight) #| 2
--   </pre>
halfSinePiece :: (C a) => FlatPosition -> Piece a
cubicPiece :: (C a) => a -> a -> Piece a
curveMultiscale :: (y -> y -> y) -> y -> y -> T y
curveMultiscaleNeutral :: (y -> y -> y) -> y -> y -> T y
instance Show FlatPosition
instance Eq FlatPosition
instance Ord FlatPosition
instance Ix FlatPosition
instance Enum FlatPosition

module Synthesizer.State.Analysis

-- | Volume based on Manhattan norm.
volumeMaximum :: (C y) => T y -> y

-- | Volume based on Energy norm.
volumeEuclidean :: (C y) => T y -> y
volumeEuclideanSqr :: (C y) => T y -> y

-- | Volume based on Sum norm.
volumeSum :: (C y, C y) => T y -> y

-- | Volume based on Manhattan norm.
volumeVectorMaximum :: (C y yv, Ord y) => T yv -> y

-- | Volume based on Energy norm.
volumeVectorEuclidean :: (C y, C y yv) => T yv -> y
volumeVectorEuclideanSqr :: (C y, Sqr y yv) => T yv -> y

-- | Volume based on Sum norm.
volumeVectorSum :: (C y yv, C y) => T yv -> y

-- | Compute minimum and maximum value of the stream the efficient way.
--   Input list must be non-empty and finite.
bounds :: (Ord y) => T y -> (y, y)

-- | Input list must be finite. List is scanned twice, but counting may be
--   faster.
histogramDiscreteArray :: T Int -> (Int, T Int)

-- | Input list must be finite. If the input signal is empty, the offset is
--   <tt>undefined</tt>. List is scanned twice, but counting may be faster.
--   The sum of all histogram values is one less than the length of the
--   signal.
histogramLinearArray :: (C y) => T y -> (Int, T y)

-- | Input list must be finite. If the input signal is empty, the offset is
--   <tt>undefined</tt>. List is scanned once, counting may be slower.
histogramDiscreteIntMap :: T Int -> (Int, T Int)
histogramLinearIntMap :: (C y) => T y -> (Int, T y)
withAtLeast1 :: String -> (T y -> (Int, T y)) -> T y -> (Int, T y)
withAtLeast2 :: (C y) => String -> (T y -> (Int, T y)) -> T y -> (Int, T y)
histogramIntMap :: (C y) => y -> T y -> (Int, T Int)
quantize :: (C y) => y -> T y -> T Int
attachOne :: T i -> [(i, Int)]
meanValues :: (C y) => T y -> [(Int, y)]
spread :: (C y) => (y, y) -> [(Int, y)]

-- | Requires finite length. This is identical to the arithmetic mean.
directCurrentOffset :: (C y) => T y -> y
scalarProduct :: (C y) => T y -> T y -> y

-- | <a>directCurrentOffset</a> must be non-zero.
centroid :: (C y) => T y -> y
centroidRecompute :: (C y) => T y -> y
firstMoment :: (C y) => T y -> y
average :: (C y) => T y -> y
averageRecompute :: (C y) => T y -> y
rectify :: (C y) => T y -> T y

-- | Detects zeros (sign changes) in a signal. This can be used as a simple
--   measure of the portion of high frequencies or noise in the signal. It
--   ca be used as voiced/unvoiced detector in a vocoder.
--   
--   <tt>zeros x !! n</tt> is <tt>True</tt> if and only if <tt>(x !! n
--   &gt;= 0) /= (x !! (n+1) &gt;= 0)</tt>. The result will be one value
--   shorter than the input.
zeros :: (Ord y, C y) => T y -> T Bool

-- | Detect thresholds with a hysteresis.
flipFlopHysteresis :: (Ord y) => (y, y) -> Bool -> T y -> T Bool

-- | Almost naive implementation of the chirp transform, a generalization
--   of the Fourier transform.
--   
--   More sophisticated algorithms like Rader, Cooley-Tukey, Winograd,
--   Prime-Factor may follow.
chirpTransform :: (C y) => y -> T y -> T y


module Synthesizer.State.Cut

-- | Take signal until it falls short of a certain amplitude for a given
--   time.
takeUntilPause :: (C a) => a -> Int -> T a -> T a

-- | Take values until the predicate p holds for n successive values. The
--   list is truncated at the beginning of the interval of matching values.
takeUntilInterval :: (a -> Bool) -> Int -> T a -> T a
selectBool :: (T a, T a) -> T Bool -> T a
select :: (Ix i) => Array i (T a) -> T i -> T a
arrange :: (C v) => T Int (T v) -> T v

-- | Given a list of signals with time stamps, mix them into one signal as
--   they occur in time. Ideally for composing music.
--   
--   Cf. <tt>MathObj.LaurentPolynomial.series</tt>
arrangeList :: (C v) => T Int (T v) -> T v

module Synthesizer.State.Interpolation
zeroPad :: (C t) => (T t y -> t -> T y -> a) -> y -> T t y -> t -> T y -> a
constantPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a

-- | Only for finite input signals.
cyclicPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a

-- | The extrapolation may miss some of the first and some of the last
--   points
extrapolationPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a
skip :: (C t) => T t y -> (t, T y) -> (t, T y)
single :: (C t) => T t y -> t -> T y -> y
delayPad :: y -> Int -> T y -> T y

module Synthesizer.State.Filter.Delay
static :: (C y) => Int -> T y -> T y
staticPad :: y -> Int -> T y -> T y
staticPos :: (C y) => Int -> T y -> T y
staticNeg :: Int -> T y -> T y
modulatedCore :: (C a, C v) => T a v -> Int -> T a -> T v -> T v

-- | This is essentially different for constant interpolation, because this
--   function <a>looks forward</a> whereas the other two variants <a>look
--   backward</a>. For the symmetric interpolation functions of linear and
--   cubic interpolation, this does not really matter.
modulated :: (C a, C v) => T a v -> Int -> T a -> T v -> T v


module Synthesizer.State.Filter.NonRecursive
amplify :: (C a) => a -> T a -> T a
amplifyVector :: (C a v) => a -> T v -> T v
envelope :: (C a) => T a -> T a -> T a
envelopeVector :: (C a v) => T a -> T v -> T v
fadeInOut :: (C a) => Int -> Int -> Int -> T a -> T a

-- | Unmodulated non-recursive filter
generic :: (C a v) => T a -> T v -> T v
binomial :: (C a, C a, C a v) => a -> a -> T v -> T v

-- | Compute the variance of the Gaussian such that its Fourier transform
--   has value <tt>ratio</tt> at frequency <tt>freq</tt>.
ratioFreqToVariance :: (C a) => a -> a -> a
binomial1 :: (C v) => T v -> T v

-- | Moving (uniformly weighted) average in the most trivial form. This is
--   very slow and needs about <tt>n * length x</tt> operations.
sums :: (C v) => Int -> T v -> T v

-- | This is inverse to frequency modulation. If all control values in
--   <tt>ctrl</tt> are above one, then it holds: <tt> frequencyModulation
--   ctrl (inverseFrequencyModulationFloor ctrl xs) == xs </tt>. Otherwise
--   <a>inverseFrequencyModulationFloor</a> is lossy. For the precise
--   property we refer to
--   <a>Test.Sound.Synthesizer.Plain.Interpolation</a>. The modulation uses
--   constant interpolation. Other interpolation types are tricky to
--   implement, since they would need interpolation on non-equidistant
--   grids. Ok, at least linear interpolation could be supported with
--   acceptable effort, but perfect reconstruction would be hard to get.
--   The process is not causal in any of its inputs, however control and
--   input are aligned.
--   
--   If you use interpolation for resampling or frequency modulation, you
--   may want to smooth the signal before resampling according to the local
--   resampling factor. However you cannot simply use the resampling
--   control to also control the smoothing, because of the subsequent
--   distortion by resampling. Instead you have to stretch the control
--   inversely to the resampling factor. This is the task of this function.
--   It may be applied like:
--   
--   <pre>
--   frequencyModulation ctrl (smooth (inverseFrequencyModulationFloor ctrl ctrl) xs)
--   </pre>
inverseFrequencyModulationFloor :: (Ord t, C t) => T t -> T v -> T v
inverseFrequencyModulationCeiling :: (Ord t, C t) => T t -> T v -> T v
inverseFrequencyModulationGen :: (Ord t, C t) => (t -> Bool) -> T t -> T v -> T v

-- | Forward difference quotient. Shortens the signal by one. Inverts
--   <tt>Synthesizer.State.Filter.Recursive.Integration.run</tt> in the
--   sense that <tt>differentiate (zero : integrate x) == x</tt>. The
--   signal is shifted by a half time unit.
differentiate :: (C v) => T v -> T v

-- | Central difference quotient. Shortens the signal by two elements, and
--   shifts the signal by one element. (Which can be fixed by prepending an
--   appropriate value.) For linear functions this will yield essentially
--   the same result as <a>differentiate</a>. You obtain the result of
--   <a>differentiateCenter</a> if you smooth the one of
--   <a>differentiate</a> by averaging pairs of adjacent values.
--   
--   ToDo: Vector variant
differentiateCenter :: (C v) => T v -> T v

-- | Second derivative. It is <tt>differentiate2 == differentiate .
--   differentiate</tt> but <a>differentiate2</a> should be faster.
differentiate2 :: (C v) => T v -> T v

module Synthesizer.State.Miscellaneous

-- | simulate an moving sounding object convert the way of the object
--   through 3D space into a delay and attenuation information, sonicDelay
--   is the reciprocal of the sonic velocity
receive3Dsound :: (C a, C a v) => a -> a -> v -> T v -> (T a, T a)


-- | Noise and random processes.
module Synthesizer.State.Noise

-- | Deterministic white noise, uniformly distributed between -1 and 1.
--   That is, variance is 1/3.
white :: (C y, Random y) => T y
whiteGen :: (C y, Random y, RandomGen g) => g -> T y

-- | Approximates normal distribution with variance 1 by a quadratic
--   B-spline distribution.
whiteQuadraticBSplineGen :: (C y, Random y, RandomGen g) => g -> T y
randomPeeks :: (C y, Random y) => T y -> T Bool
randomPeeksGen :: (C y, Random y, RandomGen g) => g -> T y -> T Bool
randomRs :: (C y, Random y, RandomGen g) => (y, y) -> g -> T y


-- | Noise and random processes. This uses a fast reimplementation of
--   <tt>System.Random.randomR</tt> since the standard function seems not
--   to be inlined (at least in GHC-6.8.2).
module Synthesizer.State.NoiseCustom

-- | Deterministic white noise, uniformly distributed between -1 and 1.
--   That is, variance is 1/3.
white :: (C y, Random y) => T y
whiteGen :: (C y, Random y, RandomGen g) => g -> T y

-- | Approximates normal distribution with variance 1 by a quadratic
--   B-spline distribution.
whiteQuadraticBSplineGen :: (C y, Random y, RandomGen g) => g -> T y
randomPeeks :: (C y, Random y) => T y -> T Bool
randomPeeksGen :: (C y, Random y, RandomGen g) => g -> T y -> T Bool
randomRs :: (C y, Random y, RandomGen g) => (y, y) -> g -> T y
randomR :: (RandomGen g, C y) => (y, y) -> g -> (y, g)


-- | Type class for several signal storage types that allows alter element
--   types. There is some overlap between the two <tt>Transform</tt>
--   classes. This was done in order to save us from ubiquitous
--   <tt>Transform sig y y</tt> constraints.
module Synthesizer.Generic.Signal2
class (Transform sig y0, Transform sig y1) => Transform sig y0 y1
map :: (Transform sig y0 y1) => (y0 -> y1) -> (sig y0 -> sig y1)
scanL :: (Transform sig y0 y1) => (y1 -> y0 -> y1) -> y1 -> sig y0 -> sig y1
crochetL :: (Transform sig y0 y1) => (y0 -> s -> Maybe (y1, s)) -> s -> sig y0 -> sig y1
zipWith :: (Read sig a, Transform sig b c) => (a -> b -> c) -> (sig a -> sig b -> sig c)
mapAdjacent :: (Transform sig a b) => (a -> a -> b) -> sig a -> sig b
zip :: (Read sig a, Transform sig b (a, b)) => sig a -> sig b -> sig (a, b)
zipWith3 :: (Read sig a, Read sig b, Transform sig c d) => (a -> b -> c -> d) -> (sig a -> sig b -> sig c -> sig d)
zip3 :: (Read sig a, Read sig b, Transform sig c (a, b, c)) => sig a -> sig b -> sig c -> sig (a, b, c)
unzip :: (Transform sig (a, b) a, Transform sig (a, b) b) => sig (a, b) -> (sig a, sig b)
unzip3 :: (Transform sig (a, b, c) a, Transform sig (a, b, c) b, Transform sig (a, b, c) c) => sig (a, b, c) -> (sig a, sig b, sig c)
modifyStatic :: (Transform sig a b) => Simple s ctrl a b -> ctrl -> sig a -> sig b

-- | Here the control may vary over the time.
modifyModulated :: (Transform sig a b, Read sig ctrl) => Simple s ctrl a b -> sig ctrl -> sig a -> sig b
linearComb :: (C t y, Read sig t, Transform sig y y) => sig t -> sig y -> y
mapTails :: (Transform sig a b) => (sig a -> b) -> sig a -> sig b
zipWithTails :: (Transform sig b, Transform sig a c) => (a -> sig b -> c) -> sig a -> sig b -> sig c
zipWith2Tails :: (Transform sig b, Transform sig c, Transform sig a d) => (a -> sig b -> sig c -> d) -> sig a -> sig b -> sig c -> sig d
zipWithState :: (Transform sig b c) => (a -> b -> c) -> T a -> sig b -> sig c
zipWithState3 :: (Transform sig c d) => (a -> b -> c -> d) -> (T a -> T b -> sig c -> sig d)
instance (C time, Integral time) => Transform (T time) y0 y1
instance Transform T y0 y1
instance Transform [] y0 y1
instance (Storable y0, Storable y1) => Transform Vector y0 y1


-- | Processes that use only the current and past data. Essentially this is
--   a data type for the <tt>Synthesizer.State.Signal.crochetL</tt>
--   function.
module Synthesizer.Causal.Process

-- | Cf. StreamFusion <tt>Synthesizer.State.Signal.T</tt>
data T a b
fromStateMaybe :: (a -> StateT s Maybe b) -> s -> T a b
fromState :: (a -> State s b) -> s -> T a b
fromSimpleModifier :: Simple s ctrl a b -> T (ctrl, a) b
id :: T a a
map :: (a -> b) -> T a b

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: (Arrow a) => forall b c d. a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: (Arrow a) => forall b c d. a b c -> a (d, b) (d, c)
compose :: T a b -> T b c -> T a c
split :: T a b -> T c d -> T (a, c) (b, d)
fanout :: T a b -> T a c -> T a (b, c)
loop :: (ArrowLoop a) => forall b d c. a (b, d) (c, d) -> a b c
apply :: (Transform sig a b) => T a b -> sig a -> sig b
applyFst :: (Read sig a) => T (a, b) c -> sig a -> T b c
applySnd :: (Read sig b) => T (a, b) c -> sig b -> T a c
applySameType :: (Transform sig a) => T a a -> sig a -> sig a

-- | applyConst c x == apply c (repeat x)
applyConst :: T a b -> a -> T b
apply2 :: (Read sig a, Transform sig b c) => T (a, b) c -> sig a -> sig b -> sig c
apply3 :: (Read sig a, Read sig b, Transform sig c d) => T (a, b, c) d -> sig a -> sig b -> sig c -> sig d
feed :: (Read sig a) => sig a -> T () a
feedFst :: (Read sig a) => sig a -> T b (a, b)
feedSnd :: (Read sig a) => sig a -> T b (b, a)
feedGenericFst :: (Read sig a) => sig a -> T b (a, b)
feedGenericSnd :: (Read sig a) => sig a -> T b (b, a)
feedConstFst :: a -> T b (a, b)
feedConstSnd :: a -> T b (b, a)
crochetL :: (x -> acc -> Maybe (y, acc)) -> acc -> T x y
scanL :: (acc -> x -> acc) -> acc -> T x acc
scanL1 :: (x -> x -> x) -> T x x
zipWith :: (Read sig a) => (a -> b -> c) -> sig a -> T b c

-- | Prepend an element to a signal, but keep the signal length, i.e. drop
--   the last element.
consInit :: x -> T x x
chainControlled :: [T (c, x) x] -> T (c, x) x

-- | If <tt>T</tt> would be the function type <tt>-&gt;</tt> then
--   <tt>replicateControlled 3 f</tt> computes <tt>(c,x) -&gt; f(c, f(c,
--   f(c, x)))</tt>.
replicateControlled :: Int -> T (c, x) x -> T (c, x) x
feedback :: T (a, c) b -> T b c -> T a b
feedbackControlled :: T ((ctrl, a), c) b -> T (ctrl, b) c -> T (ctrl, a) b

-- | I think this function does too much. Better use <a>feedFst</a> and
--   (&gt;&gt;&gt;).
applyFst' :: (Read sig a) => T (a, b) c -> sig a -> T b c

-- | I think this function does too much. Better use <a>feedSnd</a> and
--   (&gt;&gt;&gt;).
applySnd' :: (Read sig b) => T (a, b) c -> sig b -> T a c
instance ArrowLoop T
instance Arrow T
instance Category T


module Synthesizer.Plain.Filter.Recursive.Allpass
newtype Parameter a

-- | Feedback factor.
Parameter :: a -> Parameter a
getParameter :: Parameter a -> a

-- | Compute the filter parameter such that a given phase shift is achieved
--   at a certain frequency.
--   
--   Both frequency and phase are with respect to unit 1. This is conform
--   to Phase definition and allows to avoid Transcendental constraint in
--   some cases since we need no factor <tt>2*pi</tt>. See for instance
--   <a>parameterApprox</a>. However, it is intended that the phase
--   parameter is not of type Phase, because for the
--   <a>cascadeParameter</a> we divide by the cascade order and then there
--   is a difference between phase pi and 3*pi.
parameter :: (C a) => a -> a -> Parameter a

-- | This is the same as <a>parameter</a>, but for <tt>phase =
--   frequency</tt> it has a division of a zero by a zero of multiplicity
--   2, whereas <a>parameter</a> has a division of a non-zero number by
--   zero. Thus <a>parameter</a> suffers less from cancellation if
--   <tt>phase</tt> is close to <tt>frequency</tt>.
parameterAlt :: (C a) => a -> a -> Parameter a

-- | An approximation to <a>parameter</a> for small phase and frequency
--   values. It needs only field operations due to our choice of the unit 1
--   for the phase parameter.
parameterApprox :: (C a) => a -> a -> Parameter a
type State v = (v, v)
firstOrderStep :: (C a, C a v) => Parameter a -> v -> State (State v) v
firstOrderModifier :: (C a, C a v) => Simple (State v) (Parameter a) v v
firstOrderCausal :: (C a, C a v) => T (Parameter a, v) v
firstOrder :: (C a, C a v) => T (Parameter a) -> T v -> T v

-- | Compute phase shift of an allpass at a given frequency.
makePhase :: (C a) => Parameter a -> a -> a
cascadeParameter :: (C a) => Int -> a -> a -> Parameter a
flangerPhase :: (C a) => a
flangerParameter :: (C a) => Int -> a -> Parameter a
cascadeStep :: (C a, C a v) => Parameter a -> v -> State [v] v
cascadeStepStackPairs :: (C a, C a v) => Parameter a -> v -> State [State v] v
cascadeStepRec :: (C a, C a v) => Parameter a -> v -> State [v] v
cascadeStepScanl :: (C a, C a v) => Parameter a -> v -> State [v] v
cascadeStepStack :: (C a, C a v) => Parameter a -> v -> State [v] v
fromPairs :: [(a, a)] -> [a]
toPairs :: [a] -> [(a, a)]
cascadeModifier :: (C a, C a v) => Int -> Simple [v] (Parameter a) v v
cascadeCausalStacked :: (C a, C a v) => Int -> T (Parameter a, v) v
cascadeCausalModifier :: (C a, C a v) => Int -> T (Parameter a, v) v
cascadeCausal :: (C a, C a v) => Int -> T (Parameter a, v) v
cascadeState :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
cascadeIterative :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
cascade :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
cascadeDiverseStepScanl :: (C a, C a v) => [Parameter a] -> v -> State [v] v
cascadeDiverseStep :: (C a, C a v) => [Parameter a] -> v -> State [v] v
instance (Show a) => Show (Parameter a)
instance (Storable a) => Storable (Parameter a)
instance (C a v) => C a (Parameter v)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter


-- | First order low pass and high pass filter.
module Synthesizer.Plain.Filter.Recursive.FirstOrder
newtype Parameter a
Parameter :: a -> Parameter a
getParameter :: Parameter a -> a

-- | Convert cut-off frequency to feedback factor.
parameter :: (C a) => a -> Parameter a
lowpassStep :: (C a, C a v) => Parameter a -> v -> State v v
lowpassModifierInit :: (C a, C a v) => Initialized v v (Parameter a) v v
lowpassModifier :: (C a, C a v) => Simple v (Parameter a) v v
lowpassCausal :: (C a, C a v) => T (Parameter a, v) v
lowpassInit :: (C a, C a v) => v -> T (Parameter a) -> T v -> T v
lowpass :: (C a, C a v) => T (Parameter a) -> T v -> T v
highpassStep :: (C a, C a v) => Parameter a -> v -> State v v
highpassModifierInit :: (C a, C a v) => Initialized v v (Parameter a) v v
highpassModifier :: (C a, C a v) => Simple v (Parameter a) v v
highpassInit :: (C a, C a v) => v -> T (Parameter a) -> T v -> T v
highpassInitAlt :: (C a, C a v) => v -> T (Parameter a) -> T v -> T v
highpass :: (C a, C a v) => T (Parameter a) -> T v -> T v
data Result a
Result :: !a -> !a -> Result a
highpass_ :: Result a -> !a
lowpass_ :: Result a -> !a
step :: (C a, C a v) => Parameter a -> v -> State v (Result v)
modifierInit :: (C a, C a v) => Initialized v v (Parameter a) v v
modifier :: (C a, C a v) => Simple v (Parameter a) v v
instance (Show a) => Show (Parameter a)
instance (Storable a) => Storable (Result a)
instance (C a v) => C a (Result v)
instance (C v) => C (Result v)
instance Traversable Result
instance Foldable Result
instance Applicative Result
instance Functor Result
instance (Storable a) => Storable (Parameter a)
instance (C a v) => C a (Parameter v)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter


-- | Comb filters, useful for emphasis of tones with harmonics and for
--   repeated echos.
module Synthesizer.Plain.Filter.Recursive.Comb

-- | The most simple version of the Karplus-Strong algorithm which is
--   suitable to simulate a plucked string. It is similar to the
--   <a>runProc</a> function.
karplusStrong :: (C a, C a v) => Parameter a -> T v -> T v

-- | Infinitely many equi-delayed exponentially decaying echos. The echos
--   are clipped to the input length. We think it is easier (and simpler to
--   do efficiently) to pad the input with zeros or whatever instead of
--   cutting the result according to the input length.
run :: (C a v) => Int -> a -> T v -> T v

-- | Echos of different delays.
runMulti :: (C a, C a v) => [Int] -> a -> T v -> T v

-- | Echos can be piped through an arbitrary signal processor.
runProc :: (C v) => Int -> (T v -> T v) -> T v -> T v


-- | Comb filters, useful for emphasis of tones with harmonics and for
--   repeated echos.
module Synthesizer.State.Filter.Recursive.Comb

-- | The most simple version of the Karplus-Strong algorithm which is
--   suitable to simulate a plucked string. It is similar to the
--   <a>runProc</a> function.
karplusStrong :: (C a, C a v) => Parameter a -> T v -> T v

-- | Infinitely many equi-delayed exponentially decaying echos. The echos
--   are clipped to the input length. We think it is easier (and simpler to
--   do efficiently) to pad the input with zeros or whatever instead of
--   cutting the result according to the input length.
run :: (C a v) => Int -> a -> T v -> T v

-- | Echos of different delays.
runMulti :: (C a, C a v) => [Int] -> a -> T v -> T v

-- | Echos can be piped through an arbitrary signal processor.
runProc :: (C v) => Int -> (T v -> T v) -> T v -> T v


-- | First order lowpass and highpass with complex valued feedback. The
--   complex feedback allows resonance.
module Synthesizer.Plain.Filter.Recursive.FirstOrderComplex
data Parameter a

-- | The internal parameters are computed such that:
--   
--   <ul>
--   <li>At the resonance frequency the filter amplifies by the factor
--   <tt>resonance</tt> with no phase shift.</li>
--   <li>At resonance frequency plus half sample rate the filter amplifies
--   by facter <tt>recip $ 2 - recip resonance</tt> with no phase shift,
--   but you cannot observe this immediately, because it is outside the
--   Nyquist band.</li>
--   </ul>
parameter :: (C a) => Pole a -> Parameter a

-- | The internal parameters are computed such that:
--   
--   <ul>
--   <li>At the resonance frequency the filter amplifies by the factor
--   <tt>resonance</tt> with no phase shift.</li>
--   <li>At resonance frequency plus and minus band width the filter
--   amplifies by facter 1 with a non-zero phase shift.</li>
--   </ul>
parameterFromPeakWidth :: (C a) => a -> Pole a -> Parameter a

-- | The internal parameters are computed such that:
--   
--   <ul>
--   <li>At the resonance frequency the filter amplifies by the factor
--   <tt>resonance</tt> with a non-zero phase shift.</li>
--   <li>The filter amplifies the direct current (frequency zero) by factor
--   1 with no phase shift.</li>
--   <li>The real component is a lowpass, the imaginary component is a
--   highpass. You can interpolate between them using other complex
--   projections.</li>
--   </ul>
parameterFromPeakToDCRatio :: (C a) => Pole a -> Parameter a

-- | Universal filter: Computes high pass, band pass, low pass in one go
step :: (C a v) => Parameter a -> v -> State (T v) (Result v)
modifierInit :: (C a, C a v) => Initialized (T v) (T v) (Parameter a) v (Result v)
modifier :: (C a, C a v) => Simple (T v) (Parameter a) v (Result v)
causal :: (C a, C a v) => T (Parameter a, v) (Result v)
runInit :: (C a, C a v) => T v -> T (Parameter a) -> T v -> T (Result v)
run :: (C a, C a v) => T (Parameter a) -> T v -> T (Result v)
instance (Show a) => Show (Parameter a)
instance (C a v) => C a (Parameter v)


-- | Moog cascade lowpass with resonance.
module Synthesizer.Plain.Filter.Recursive.Moog
data Parameter a
Parameter :: !a -> !Parameter a -> Parameter a

-- | Feedback of the lowpass cascade
feedback :: Parameter a -> !a

-- | Feedback of each of the lowpasses of 1st order
lowpassParam :: Parameter a -> !Parameter a
parameterInstable :: (C a) => Int -> Pole a -> Parameter a
parameter :: (C a) => Int -> Pole a -> Parameter a
type State = []
lowpassStepStack :: (C a, C a v) => Parameter a -> v -> State (State v) v
lowpassStepRev :: (C a, C a v) => Parameter a -> v -> State (State v) v
lowpassModifier :: (C a, C a v) => Int -> Simple (State v) (Parameter a) v v
lowpassCausalStacked :: (C a, C a v) => Int -> T (Parameter a, v) v
lowpassCausalModifier :: (C a, C a v) => Int -> T (Parameter a, v) v
lowpassCausal :: (C a, C a v) => Int -> T (Parameter a, v) v
lowpassState :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
lowpassRecursive :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
lowpass :: (C a, C a v) => Int -> T (Parameter a) -> T v -> T v
instance (Show a) => Show (Parameter a)
instance (C a v) => C a (Parameter v)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter


-- | Filter operators from calculus
module Synthesizer.State.Filter.Recursive.Integration

-- | Integrate with initial value zero. However the first emitted value is
--   the value of the input signal. It maintains the length of the signal.
run :: (C v) => T v -> T v

-- | Integrate with initial condition. First emitted value is the initial
--   condition. The signal become one element longer.
runInit :: (C v) => v -> T v -> T v
causal :: (C v) => T v v

-- | Integrate with initial condition. First emitted value is the initial
--   condition. The signal become one element longer.
causalInit :: (C v) => v -> T v v


module Synthesizer.State.Filter.Recursive.MovingAverage

-- | Like <tt>Synthesizer.State.Filter.NonRecursive.sums</tt> but in a
--   recursive form. This needs only linear time (independent of the window
--   size) but may accumulate rounding errors.
--   
--   <pre>
--   ys = xs * (1,0,0,0,-1) / (1,-1)
--   ys * (1,-1) = xs * (1,0,0,0,-1)
--   ys = xs * (1,0,0,0,-1) + ys * (0,1)
--   </pre>
sumsStaticInt :: (C v) => Int -> T v -> T v
modulatedFrac :: (C a, C a v) => Int -> T a -> T v -> T v


-- | Basics for building tone generators. They generate signals of phases
--   and these signals can be converted to arbitrary waveforms by mapping
--   them via <tt>Wave</tt> objects. This is also the fundament for
--   dimensional oscillators.
module Synthesizer.Causal.Oscillator.Core
static :: (C a) => T a -> a -> T (T a)

-- | oscillator with modulated phase
phaseMod :: (C a) => a -> T a (T a)

-- | oscillator with modulated shape
shapeMod :: (C a) => T a -> a -> T c (c, T a)

-- | Convert a list of phase steps into a list of momentum phases. phase is
--   a number in the interval [0,1). freq contains the phase steps. The
--   last element is omitted.
freqMod :: (C a) => T a -> T a (T a)

-- | Like <a>freqMod</a> but the first element is omitted.
freqModSync :: (C a) => T a -> T a (T a)

-- | oscillator with modulated frequency
freqModAntiAlias :: (C a) => T a -> T a (a, T a)

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a) => T (a, a) (T a)

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a) => T a -> T (c, a) (c, T a)

module Synthesizer.State.ToneModulation
type Cell sig y = T (sig y)
interpolateCell :: (Read sig y) => T a y -> T b y -> (a, b) -> Cell sig y -> y
data Prototype sig a v
Prototype :: Margin -> Margin -> Int -> a -> Int -> (a, a) -> sig v -> Prototype sig a v
protoMarginLeap :: Prototype sig a v -> Margin
protoMarginStep :: Prototype sig a v -> Margin
protoIpOffset :: Prototype sig a v -> Int
protoPeriod :: Prototype sig a v -> a
protoPeriodInt :: Prototype sig a v -> Int
protoShapeLimits :: Prototype sig a v -> (a, a)
protoSignal :: Prototype sig a v -> sig v
makePrototype :: (C a, Read sig v) => Margin -> Margin -> a -> sig v -> Prototype sig a v
sampledToneCell :: (C a, Transform sig v) => Prototype sig a v -> a -> T a -> ((a, a), Cell sig v)

-- | This function should not be used, since it requires recomputation of
--   <tt>shapes</tt> and <tt>freqs</tt> lists.
oscillatorCells :: (C t, Transform sig y) => Margin -> Margin -> t -> sig y -> (t, T t) -> (T t, T t) -> T ((t, t), Cell sig y)
checkNonNeg :: (Ord a, C a, Show a) => a -> a
makeCell :: (Transform sig y) => Int -> sig y -> Cell sig y
oscillatorCoords :: (C t) => Int -> t -> (t, T t) -> (T t, T t) -> T (Coords t)
limitRelativeShapes :: (C t) => Margin -> Margin -> Int -> (t, T t) -> (t, T t)
limitMinRelativeValues :: (C t, Ord t) => t -> (t, T t) -> (t, T t)

module Synthesizer.Generic.Wave
sample :: (C a, Transform sig v) => T a v -> sig v -> T a v

-- | Interpolate first within waves and then across waves, which is simpler
--   but maybe less efficient for lists. However for types with fast
--   indexing/drop like StorableVector this is optimal.
sampledTone :: (C a, Transform sig v) => T a v -> T a v -> a -> sig v -> a -> T a v

module Synthesizer.Causal.Cut
take :: Int -> T a a

module Synthesizer.Causal.ToneModulation
interpolateCell :: (Read sig y) => T a y -> T b y -> (a, b) -> Cell sig y -> y
seekCell :: (C t, Transform sig y) => Int -> t -> ((t, T t), sig y) -> ((t, t), Cell sig y)
oscillatorCells :: (C t, Transform sig y) => Margin -> Margin -> Int -> t -> sig y -> (t, T t) -> T (t, t) ((t, t), Cell sig y)

-- | In contrast to the counterpart of this function for plain lists, it
--   does not use sophisticated list transposition tricks, but seeks
--   through the prototype signal using <a>drop</a>. Since <a>drop</a> is
--   used in an inner loop, it must be fast. This is true for
--   StorableVectors.
oscillatorSuffixes :: (C t, Transform sig y) => Margin -> Margin -> Int -> t -> sig y -> (t, T t) -> T (t, t) ((t, T t), sig y)
integrateFractional :: (C t) => t -> (t, T t) -> (Skip t, T (t, t) (Skip t))

-- | Delays output by one element and shorten it by one element at the end.
integrateFractionalClip :: (C t) => t -> (t, T t) -> T (t, t) (Skip t)
limitRelativeShapes :: (C t, Ord t) => Margin -> Margin -> Int -> t -> (t, T t t)
limitMinRelativeValues :: (C t, Ord t) => t -> t -> (t, T t t)


-- | Filter operators from calculus
module Synthesizer.Causal.Filter.Recursive.Integration

-- | Integrate with initial value zero. However the first emitted value is
--   the value of the input signal. It maintains the length of the signal.
run :: (C v) => T v v

-- | Integrate with initial condition. First emitted value is the initial
--   condition. The signal becomes one element longer.
runInit :: (C v) => v -> T v v

module Synthesizer.Causal.Arrow
class (Arrow arrow) => C arrow
apply :: (C arrow, Transform sig a b) => arrow a b -> sig a -> sig b
instance C (->)
instance C T

module Synthesizer.Generic.Analysis

-- | Volume based on Manhattan norm.
volumeMaximum :: (C y, Read sig y) => sig y -> y

-- | Volume based on Energy norm.
volumeEuclidean :: (C y, Read sig y) => sig y -> y
volumeEuclideanSqr :: (C y, Read sig y) => sig y -> y

-- | Volume based on Sum norm.
volumeSum :: (C y, C y, Read sig y) => sig y -> y

-- | Volume based on Manhattan norm.
volumeVectorMaximum :: (C y yv, Ord y, Read sig yv) => sig yv -> y

-- | Volume based on Energy norm.
volumeVectorEuclidean :: (C y, C y yv, Read sig yv) => sig yv -> y
volumeVectorEuclideanSqr :: (C y, Sqr y yv, Read sig yv) => sig yv -> y

-- | Volume based on Sum norm.
volumeVectorSum :: (C y yv, C y, Read sig yv) => sig yv -> y

-- | Compute minimum and maximum value of the stream the efficient way.
--   Input list must be non-empty and finite.
bounds :: (Ord y, Read sig y) => sig y -> (y, y)

-- | Requires finite length. This is identical to the arithmetic mean.
directCurrentOffset :: (C y, Read sig y) => sig y -> y
scalarProduct :: (C y, Read sig y) => sig y -> sig y -> y

-- | <a>directCurrentOffset</a> must be non-zero.
centroid :: (C y, Read sig y) => sig y -> y
average :: (C y, Read sig y) => sig y -> y
rectify :: (C y, Transform sig y) => sig y -> sig y

-- | Detects zeros (sign changes) in a signal. This can be used as a simple
--   measure of the portion of high frequencies or noise in the signal. It
--   ca be used as voiced/unvoiced detector in a vocoder.
--   
--   <tt>zeros x !! n</tt> is <tt>True</tt> if and only if <tt>(x !! n
--   &gt;= 0) /= (x !! (n+1) &gt;= 0)</tt>. The result will be one value
--   shorter than the input.
zeros :: (Ord y, C y, Transform sig y Bool) => sig y -> sig Bool

-- | Detect thresholds with a hysteresis.
flipFlopHysteresis :: (Ord y, Transform sig y Bool) => (y, y) -> Bool -> sig y -> sig Bool

module Synthesizer.Generic.Control
constant :: (Write sig y) => LazySize -> y -> sig y
linear :: (C y, Write sig y) => LazySize -> y -> y -> sig y

-- | Minimize rounding errors by reducing number of operations per element
--   to a logarithmuc number.
linearMultiscale :: (C y, Write sig y) => LazySize -> y -> y -> sig y

-- | Linear curve starting at zero.
linearMultiscaleNeutral :: (C y, Write sig y) => LazySize -> y -> sig y

-- | Linear curve of a fixed length. The final value is not actually
--   reached, instead we stop one step before. This way we can concatenate
--   several lines without duplicate adjacent values.
line :: (C y, Write sig y) => LazySize -> Int -> (y, y) -> sig y
exponentialMultiscale :: (C y, Write sig y) => LazySize -> y -> y -> sig y
exponential :: (C y, Write sig y) => LazySize -> y -> y -> sig y
exponentialMultiscaleNeutral :: (C y, Write sig y) => LazySize -> y -> sig y
exponential2Multiscale :: (C y, Write sig y) => LazySize -> y -> y -> sig y
exponential2 :: (C y, Write sig y) => LazySize -> y -> y -> sig y
exponential2MultiscaleNeutral :: (C y, Write sig y) => LazySize -> y -> sig y

-- | This is an extension of <a>exponential</a> to vectors which is
--   straight-forward but requires more explicit signatures. But since it
--   is needed rarely I setup a separate function.
vectorExponential :: (C y, C y v, Write sig v) => LazySize -> y -> v -> sig v
vectorExponential2 :: (C y, C y v, Write sig v) => LazySize -> y -> v -> sig v
cosineMultiscaleLinear :: (C y, Write sig y) => LazySize -> y -> y -> sig y
cosine :: (C y, Write sig y) => LazySize -> y -> y -> sig y
cosineMultiscale :: (C y, Write sig (T y), Transform sig (T y) y) => LazySize -> y -> y -> sig y
cosineWithSlope :: (C y) => (y -> y -> signal) -> y -> y -> signal
cubicHermite :: (C y, Write sig y) => LazySize -> (y, (y, y)) -> (y, (y, y)) -> sig y

-- | 0 16 0 8 16 0 4 8 12 16 0 2 4 6 8 10 12 14 16 0 1 2 3 4 5 6 7 8 9 10
--   11 12 13 14 15 16
cubicFunc :: (C y) => (y, (y, y)) -> (y, (y, y)) -> y -> y

-- | The curve type of a piece of a piecewise defined control curve.
data Control y
CtrlStep :: Control y
CtrlLin :: Control y
CtrlExp :: y -> Control y
ctrlExpSaturation :: Control y -> y
CtrlCos :: Control y
CtrlCubic :: y -> y -> Control y
ctrlCubicGradient0 :: Control y -> y
ctrlCubicGradient1 :: Control y -> y

-- | The full description of a control curve piece.
data ControlPiece y
ControlPiece :: Control y -> y -> y -> y -> ControlPiece y
pieceType :: ControlPiece y -> Control y
pieceY0 :: ControlPiece y -> y
pieceY1 :: ControlPiece y -> y
pieceDur :: ControlPiece y -> y
newtype PieceRightSingle y
PRS :: y -> PieceRightSingle y
newtype PieceRightDouble y
PRD :: y -> PieceRightDouble y
type ControlDist y = (y, Control y, y)

-- | The 6 operators simplify constructing a list of <tt>ControlPiece
--   a</tt>. The description consists of nodes (namely the curve values at
--   nodes) and the connecting curve types. The naming scheme is as
--   follows: In the middle there is a bar <tt>|</tt>. With respect to the
--   bar, the pad symbol <tt>#</tt> is at the side of the curve type, at
--   the other side there is nothing, a minus sign <tt>-</tt>, or an
--   equality sign <tt>=</tt>.
--   
--   <ol>
--   <li>Nothing means that here is the start or the end node of a
--   curve.</li>
--   <li>Minus means that here is a node where left and right curve meet at
--   the same value. The node description is thus one value.</li>
--   <li>Equality sign means that here is a split node, where left and
--   right curve might have different ending and beginning values,
--   respectively. The node description consists of a pair of values.</li>
--   </ol>
(#|-) :: (y, Control y) -> (PieceRightSingle y, [ControlPiece y]) -> (ControlDist y, [ControlPiece y])
(-|#) :: y -> (ControlDist y, [ControlPiece y]) -> (PieceRightSingle y, [ControlPiece y])
(#|=) :: (y, Control y) -> (PieceRightDouble y, [ControlPiece y]) -> (ControlDist y, [ControlPiece y])
(=|#) :: (y, y) -> (ControlDist y, [ControlPiece y]) -> (PieceRightDouble y, [ControlPiece y])
(#|) :: (y, Control y) -> y -> (ControlDist y, [ControlPiece y])
(|#) :: y -> (ControlDist y, [ControlPiece y]) -> [ControlPiece y]
piecewise :: (C y, C y, Write sig y) => LazySize -> [ControlPiece y] -> sig y
piecewisePart :: (C y, Write sig y) => LazySize -> y -> y -> y -> y -> Int -> Control y -> sig y
curveMultiscale :: (Write sig y) => LazySize -> (y -> y -> y) -> y -> y -> sig y
curveMultiscaleNeutral :: (Write sig y) => LazySize -> (y -> y -> y) -> y -> y -> sig y
instance (Eq y) => Eq (ControlPiece y)
instance (Show y) => Show (ControlPiece y)
instance (Eq y) => Eq (Control y)
instance (Show y) => Show (Control y)


module Synthesizer.Generic.Filter.NonRecursive
negate :: (C a, Transform sig a) => sig a -> sig a
amplify :: (C a, Transform sig a) => a -> sig a -> sig a
amplifyVector :: (C a v, Transform sig v) => a -> sig v -> sig v
envelope :: (C a, Transform sig a) => sig a -> sig a -> sig a
envelopeVector :: (C a v, Read sig a, Transform sig v) => sig a -> sig v -> sig v
fadeInOut :: (C a, Write sig a) => Int -> Int -> Int -> sig a -> sig a
delay :: (C y, Write sig y) => Int -> sig y -> sig y
delayPad :: (Write sig y) => y -> Int -> sig y -> sig y
delayPos :: (C y, Write sig y) => Int -> sig y -> sig y
delayNeg :: (Transform sig y) => Int -> sig y -> sig y
delayLazySize :: (C y, Write sig y) => LazySize -> Int -> sig y -> sig y

-- | The pad value <tt>y</tt> must be defined, otherwise the chunk size of
--   the padding can be observed.
delayPadLazySize :: (Write sig y) => LazySize -> y -> Int -> sig y -> sig y
delayPosLazySize :: (C y, Write sig y) => LazySize -> Int -> sig y -> sig y
binomialMask :: (C a, Write sig a) => LazySize -> Int -> sig a

-- | Unmodulated non-recursive filter
generic :: (C a v, Transform sig a, Write sig v) => sig a -> sig v -> sig v
binomial :: (C a, C a, C a v, Transform sig v) => a -> a -> sig v -> sig v

-- | Compute the variance of the Gaussian such that its Fourier transform
--   has value <tt>ratio</tt> at frequency <tt>freq</tt>.
ratioFreqToVariance :: (C a) => a -> a -> a
binomial1 :: (C v, Transform sig v) => sig v -> sig v

-- | Moving (uniformly weighted) average in the most trivial form. This is
--   very slow and needs about <tt>n * length x</tt> operations.
sums :: (C v, Transform sig v) => Int -> sig v -> sig v
sumsDownsample2 :: (C v, Write sig v) => LazySize -> sig v -> sig v
downsample2 :: (Write sig v) => LazySize -> sig v -> sig v
downsample :: (Write sig v) => LazySize -> Int -> sig v -> sig v
sumRange :: (C v, Transform sig v) => sig v -> (Int, Int) -> v
pyramid :: (C v, Write sig v) => Int -> sig v -> ([Int], [sig v])
sumRangeFromPyramid :: (C v, Transform sig v) => [sig v] -> (Int, Int) -> v
sumRangeFromPyramidReverse :: (C v, Transform sig v) => [sig v] -> (Int, Int) -> v
sumRangeFromPyramidFoldr :: (C v, Transform sig v) => [sig v] -> (Int, Int) -> v
maybeAccumulateRangeFromPyramid :: (Transform sig v) => (v -> v -> v) -> [sig v] -> (Int, Int) -> Maybe v
consumeRangeFromPyramid :: (Transform sig v) => (v -> a -> a) -> a -> [sig v] -> (Int, Int) -> a
sumsPosModulated :: (C v, Transform sig (Int, Int) v) => sig (Int, Int) -> sig v -> sig v

-- | Moving average, where window bounds must be always non-negative.
--   
--   The laziness granularity is <tt>2^height</tt>.
accumulatePosModulatedFromPyramid :: (Transform sig (Int, Int), Write sig v) => ([sig v] -> (Int, Int) -> v) -> ([Int], [sig v]) -> sig (Int, Int) -> sig v
sumsPosModulatedPyramid :: (C v, Transform sig (Int, Int), Write sig v) => Int -> sig (Int, Int) -> sig v -> sig v
withPaddedInput :: (Transform sig Int (Int, Int), Write sig y) => y -> (sig (Int, Int) -> sig y -> v) -> Int -> sig Int -> sig y -> v

-- | The first argument is the amplification. The main reason to introduce
--   it, was to have only a Module constraint instead of Field. This way we
--   can also filter stereo signals.
movingAverageModulatedPyramid :: (C a, C a v, Transform sig Int (Int, Int), Write sig v) => a -> Int -> Int -> sig Int -> sig v -> sig v
inverseFrequencyModulationFloor :: (Ord t, C t, Write sig v, Read sig t) => LazySize -> sig t -> sig v -> sig v

-- | Forward difference quotient. Shortens the signal by one. Inverts
--   <tt>Synthesizer.Generic.Filter.Recursive.Integration.run</tt> in the
--   sense that <tt>differentiate (zero : integrate x) == x</tt>. The
--   signal is shifted by a half time unit.
differentiate :: (C v, Transform sig v) => sig v -> sig v

-- | Central difference quotient. Shortens the signal by two elements, and
--   shifts the signal by one element. (Which can be fixed by prepending an
--   appropriate value.) For linear functions this will yield essentially
--   the same result as <a>differentiate</a>. You obtain the result of
--   <a>differentiateCenter</a> if you smooth the one of
--   <a>differentiate</a> by averaging pairs of adjacent values.
--   
--   ToDo: Vector variant
differentiateCenter :: (C v, Transform sig v) => sig v -> sig v

-- | Second derivative. It is <tt>differentiate2 == differentiate .
--   differentiate</tt> but <a>differentiate2</a> should be faster.
differentiate2 :: (C v, Transform sig v) => sig v -> sig v


module Synthesizer.Storable.Filter.NonRecursive

-- | The Maybe type carries an unpaired value from one block to the next
--   one.
accumulateDownsample2Strict :: (Storable v) => (v -> v -> v) -> Maybe v -> Vector v -> (Maybe v, Vector v)
accumulateDownsample2 :: (Storable v) => (v -> v -> v) -> T v -> T v
sumsDownsample2 :: (C v, Storable v) => T v -> T v
sumsDownsample2Alt :: (C v, Storable v) => T v -> T v
convolveDownsample2 :: (C a v, Storable a, Storable v) => T a -> T v -> T v
halfLazySize :: T ChunkSize -> T ChunkSize

-- | offset must be zero or one.
downsample2Strict :: (Storable v) => Int -> Vector v -> Vector v
laxTailStrict :: (Storable v) => Vector v -> Vector v
downsample2 :: (Storable v) => T v -> T v
pyramid :: (Storable v) => (v -> v -> v) -> Int -> T v -> [T v]

-- | Moving average, where window bounds must be always non-negative.
--   
--   The laziness granularity is <tt>2^height</tt>.
--   
--   This function is only slightly more efficient than its counterpart
--   from Generic.Filter, since it generates strict blocks and not
--   one-block chunky signals.
accumulatePosModulatedPyramid :: (Storable v) => ([T v] -> (Int, Int) -> v) -> ([Int], [T v]) -> T (Int, Int) -> T v
sumsPosModulatedPyramid :: (C v, Storable v) => Int -> T (Int, Int) -> T v -> T v
accumulateBinPosModulatedPyramid :: (Storable v) => (v -> v -> v) -> Int -> T (Int, Int) -> T v -> T v

-- | The first argument is the amplification. The main reason to introduce
--   it, was to have only a Module constraint instead of Field. This way we
--   can also filter stereo signals.
movingAverageModulatedPyramid :: (C a, C a v, Storable Int, Storable v) => a -> Int -> Int -> T Int -> T v -> T v
movingAccumulateModulatedPyramid :: (Storable v) => (v -> v -> v) -> v -> Int -> Int -> T Int -> T v -> T v

-- | The function is like that of
--   <tt>Synthesizer.State.Filter.NonRecursive.inverseFrequencyModulationFloor</tt>,
--   but this function preserves in a sense the chunk structure.
--   
--   The result will have laziness breaks at least at the chunk boundaries
--   that correspond to the breaks in the input signal. However we insert
--   more breaks, such that a maximum chunk size can be warrented. (Since
--   control and input signal are aligned in time, we might as well use the
--   control chunk structure. Currently I do not know what is better. For
--   the above example it doesn't matter.)
--   
--   This function cannot be written using generic functions, since we have
--   to inspect the chunks individually.
inverseFrequencyModulationFloor :: (Storable v, Read sig t, C t, Ord t) => ChunkSize -> sig t -> T v -> T v
inverseFrequencyModulationChunk :: (Storable v, C t, Ord t) => ChunkSize -> (s -> Maybe (t, s)) -> (t, s) -> Vector v -> (T v, Maybe (t, s))


-- | Comb filters, useful for emphasis of tones with harmonics and for
--   repeated echos.
module Synthesizer.Generic.Filter.Recursive.Comb

-- | The most simple version of the Karplus-Strong algorithm which is
--   suitable to simulate a plucked string. It is similar to the
--   <a>runProc</a> function.
karplusStrong :: (C t, C t y, Write sig y) => Parameter t -> sig y -> sig y

-- | Infinitely many equi-delayed exponentially decaying echos. The echos
--   are clipped to the input length. We think it is easier (and simpler to
--   do efficiently) to pad the input with zeros or whatever instead of
--   cutting the result according to the input length.
run :: (C t y, Write sig y) => Int -> t -> sig y -> sig y

-- | Echos of different delays. Chunk size must be smaller than all of the
--   delay times.
runMulti :: (C t, C t y, Write sig y) => [Int] -> t -> sig y -> sig y

-- | Echos can be piped through an arbitrary signal processor.
runProc :: (C y, Write sig y) => Int -> (sig y -> sig y) -> sig y -> sig y


-- | These are pieces that can be assembled to a control curve. This was
--   formerly part of the <tt>Control</tt> module but because of the
--   overlap with immediate control curve generators I created a new
--   module.
module Synthesizer.Generic.Piece
type T sig a = Piece a a (LazySize -> a -> sig a)
run :: (C a, Transform (sig a)) => LazySize -> T a a (LazySize -> a -> sig a) -> sig a
step :: (Write sig a) => T sig a
linear :: (C a, Write sig a) => T sig a
exponential :: (C a, Write sig a) => a -> T sig a
cosine :: (C a, Write sig a) => T sig a

-- | <pre>
--   Graphics.Gnuplot.Simple.plotList [] $ Sig.toList $ run $ 1 |# (10.9, halfSine FlatRight) #| 2
--   </pre>
halfSine :: (C a, Write sig a) => FlatPosition -> T sig a
cubic :: (C a, Write sig a) => a -> a -> T sig a
data FlatPosition
FlatLeft :: FlatPosition
FlatRight :: FlatPosition

module Synthesizer.Causal.Filter.NonRecursive
amplify :: (C a) => a -> T a a
amplifyVector :: (C a v) => a -> T v v
envelope :: (C a) => T (a, a) a
envelopeVector :: (C a v) => T (a, v) v
accumulatePosModulatedFromPyramid :: (Transform sig v) => ([sig v] -> (Int, Int) -> v) -> [sig v] -> T (Int, Int) v
sumsPosModulatedFromPyramid :: (C v, Transform sig v) => [sig v] -> T (Int, Int) v


-- | Noise and random processes.
module Synthesizer.Generic.Noise

-- | Deterministic white noise, uniformly distributed between -1 and 1.
--   That is, variance is 1/3.
white :: (C y, Random y, Write sig y) => LazySize -> sig y
whiteGen :: (C y, Random y, RandomGen g, Write sig y) => LazySize -> g -> sig y

-- | Approximates normal distribution with variance 1 by a quadratic
--   B-spline distribution.
whiteQuadraticBSplineGen :: (C y, Random y, RandomGen g, Write sig y) => LazySize -> g -> sig y
randomPeeks :: (C y, Random y, Transform sig y Bool) => sig y -> sig Bool
randomPeeksGen :: (C y, Random y, RandomGen g, Transform sig y Bool) => g -> sig y -> sig Bool

module Synthesizer.ApplicativeUtility
liftA4 :: (Applicative f) => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
liftA5 :: (Applicative f) => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
liftA6 :: (Applicative f) => (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h

-- | Create a loop (feedback) from one node to another one. That is,
--   compute the fix point of a process iteration.
loop :: (Functor f) => f (a -> a) -> f a

-- | This corresponds to <a>&lt;*&gt;</a>
($:) :: (Applicative f) => f (a -> b) -> f a -> f b

-- | Instead of <tt>mixMulti $:: map f xs</tt> the caller should write
--   <tt>mixMulti $: mapM f xs</tt> in order to save the user from learning
--   another infix operator.
($::) :: (Applicative f, Traversable t) => f (t a -> b) -> t (f a) -> f b
(.:) :: (Applicative f, Arrow arrow) => f (arrow b c) -> f (arrow a b) -> f (arrow a c)
($^) :: (Functor f) => (a -> b) -> f a -> f b
(.^) :: (Functor f, Arrow arrow) => arrow b c -> f (arrow a b) -> f (arrow a c)
($#) :: (Functor f) => f (a -> b) -> a -> f b

-- | Our signal processors have types like <tt>f (a -&gt; b -&gt; c)</tt>.
--   They could also have the type <tt>a -&gt; b -&gt; f c</tt> or <tt>f a
--   -&gt; f b -&gt; f c</tt>. We did not choose the last variant for
--   reduction of redundancy in type signatures and for simplifying
--   sharing, and we did not choose the second variant for easy composition
--   of processors. However the forms are freely convertible, and if you
--   prefer the last one because you do not want to sprinkle '($:)' in your
--   code, then you may want to convert the processors using the following
--   functions, that can be defined purely in the <a>Applicative</a> class.
liftP :: (Applicative f) => f (a -> b) -> f a -> f b
liftP2 :: (Applicative f) => f (a -> b -> c) -> f a -> f b -> f c
liftP3 :: (Applicative f) => f (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftP4 :: (Applicative f) => f (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e


-- | Special interpolations defined in terms of Module operations.
module Synthesizer.Interpolation.Module

-- | interpolation as needed for resampling
data T t y

-- | Consider the signal to be piecewise constant, where the leading value
--   is used for filling the interval [0,1).
constant :: T t y

-- | Consider the signal to be piecewise linear.
linear :: (C t y) => T t y

-- | Consider the signal to be piecewise cubic, with smooth connections at
--   the nodes. It uses a cubic curve which has node values x0 at 0 and x1
--   at 1 and derivatives (x1-xm1)<i>2 and (x2-x0)</i>2, respectively. You
--   can see how it works if you evaluate the expression for t=0 and t=1 as
--   well as the derivative at these points.
cubic :: (C t, C t y) => T t y

-- | The interpolators for module operations do not simply compute a
--   straight linear combination of some vectors. Instead they add then
--   scale, then add again, and so on. This is efficient whenever scaling
--   and addition is cheap. In this case they might save multiplications. I
--   can't say much about numeric cancellations, however.
cubicAlt :: (C t, C t y) => T t y
piecewise :: (C t y) => Int -> [t -> t] -> T t y
piecewiseConstant :: (C t y) => T t y
piecewiseLinear :: (C t y) => T t y
piecewiseCubic :: (C t, C t y) => T t y

-- | with this wrapper you can use the collection of interpolating
--   functions from Donadio's DSP library
function :: (C t y) => (Int, Int) -> (t -> t) -> T t y

module Synthesizer.Plain.Interpolation

-- | interpolation as needed for resampling
data T t y
func :: T t y -> t -> T y -> y
offset :: T t y -> Int
number :: T t y -> Int
zeroPad :: (C t) => (T t y -> t -> T y -> a) -> y -> T t y -> t -> T y -> a
constantPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a

-- | Only for finite input signals.
cyclicPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a

-- | The extrapolation may miss some of the first and some of the last
--   points
extrapolationPad :: (C t) => (T t y -> t -> T y -> a) -> T t y -> t -> T y -> a
single :: (C t) => T t y -> t -> T y -> y

-- | All values of frequency control must be non-negative.
multiRelative :: (C t) => T t y -> t -> T y -> T t -> T y
multiRelativeZeroPad :: (C t) => y -> T t y -> t -> T t -> T y -> T y
multiRelativeConstantPad :: (C t) => T t y -> t -> T t -> T y -> T y
multiRelativeCyclicPad :: (C t) => T t y -> t -> T t -> T y -> T y

-- | The extrapolation may miss some of the first and some of the last
--   points
multiRelativeExtrapolationPad :: (C t) => T t y -> t -> T t -> T y -> T y
multiRelativeZeroPadConstant :: (C t, C y) => t -> T t -> T y -> T y
multiRelativeZeroPadLinear :: (C t, C t y) => t -> T t -> T y -> T y
multiRelativeZeroPadCubic :: (C t, C t y) => t -> T t -> T y -> T y

-- | Consider the signal to be piecewise constant, where the leading value
--   is used for filling the interval [0,1).
constant :: T t y

-- | Consider the signal to be piecewise linear.
linear :: (C t y) => T t y

-- | Consider the signal to be piecewise cubic, with smooth connections at
--   the nodes. It uses a cubic curve which has node values x0 at 0 and x1
--   at 1 and derivatives (x1-xm1)<i>2 and (x2-x0)</i>2, respectively. You
--   can see how it works if you evaluate the expression for t=0 and t=1 as
--   well as the derivative at these points.
cubic :: (C t, C t y) => T t y
piecewise :: (C t y) => Int -> [t -> t] -> T t y

-- | with this wrapper you can use the collection of interpolating
--   functions from Donadio's DSP library
function :: (C t y) => (Int, Int) -> (t -> t) -> T t y
data Margin
margin :: T t y -> Margin

-- | alternative implementation of <a>single</a>
singleRec :: (Ord t, C t) => T t y -> t -> T y -> y


-- | An implementation of a Delay using a classical circular buffer running
--   in the State Thread monad.
module Synthesizer.Plain.Filter.Delay.ST
modulatedAction :: (C a, C v) => T a v -> Int -> [a] -> [v] -> ST s [v]
modulated :: (C a, C v) => T a v -> Int -> [a] -> [v] -> [v]

module Synthesizer.Plain.Filter.Delay.List

-- | This function uses suffixes of the reversed signal. This way small
--   delays perform well but the big drawback is that the garbage collector
--   can not deallocate old samples.
modulatedRevCore :: (C a, C v) => T a v -> Int -> [a] -> [v] -> [v]
modulatedRev :: (C a, C v) => T a v -> Int -> [a] -> [v] -> [v]
modulatedCore :: (C a, C v) => T a v -> Int -> [a] -> [v] -> [v]

-- | This is essentially different for constant interpolation, because this
--   function <a>looks forward</a> whereas the other two variants <a>look
--   backward</a>. For the symmetric interpolation functions of linear and
--   cubic interpolation, this does not really matter.
modulated :: (C a, C v) => T a v -> Int -> [a] -> [v] -> [v]


-- | Fast delay based on block lists. Blocks are arrays. They are part of
--   Haskell 98. In contrast to ring buffers, block lists allow infinite
--   look ahead.
module Synthesizer.Plain.Filter.Delay.Block
modulatedCore :: (C a, C v) => T a v -> Int -> T a -> T v -> T v
modulated :: (C a, C v) => T a v -> Int -> T a -> T v -> T v
type BlockList a = [Array Int a]
listToBlocks :: Int -> T a -> BlockList a
dropBlocksToList :: Int -> BlockList a -> T a
propDrop :: Int -> Int -> [Int] -> Property

-- | Drop elements from a blocked list. The offset must lie in the leading
--   block.
dropSingleBlocksToList :: Int -> BlockList a -> T a
suffixIndexes :: BlockList a -> [(Int, BlockList a)]

module Synthesizer.Plain.Filter.Delay
phaser :: (C a v, C a) => a -> [a] -> [v] -> [v]
plane :: Double -> [Double]
propSingle :: T Double Double -> [Bool]

-- | The test for constant interpolation will fail, due to different point
--   of views in forward and backward interpolation.
propAll :: [[Bool]]


-- | Avoid importing this module. Better use functions from
--   <a>Synthesizer.Plain.Oscillator</a> and <a>Synthesizer.Basic.Wave</a>
--   
--   Input data is interpreted as samples of data on a cylinder in the
--   following form:
--   
--   <pre>
--   |*          |
--   |   *       |
--   |      *    |
--   |         * |
--   | *         |
--   |    *      |
--   |       *   |
--   |          *|
--   |  *        |
--   |     *     |
--   |        *  |
--   </pre>
--   
--   <pre>
--   -----------
--   *
--       *
--           *
--    *
--        *
--            *
--     *
--         *
--             *
--      *
--          *
--   -----------
--   </pre>
--   
--   We have to interpolate in the parallelograms.
module Synthesizer.Plain.ToneModulation
type Cell y = T (T y)
interpolateCell :: T a y -> T b y -> (a, b) -> Cell y -> y
data Prototype t y
Prototype :: Margin -> Margin -> Int -> t -> Int -> (t, t) -> Array Int y -> Prototype t y
protoMarginLeap :: Prototype t y -> Margin
protoMarginStep :: Prototype t y -> Margin
protoIpOffset :: Prototype t y -> Int
protoPeriod :: Prototype t y -> t
protoPeriodInt :: Prototype t y -> Int
protoShapeLimits :: Prototype t y -> (t, t)
protoArray :: Prototype t y -> Array Int y
makePrototype :: (C t) => Margin -> Margin -> Int -> t -> T y -> Prototype t y
sampledToneCell :: (C t) => Prototype t y -> t -> T t -> ((t, t), Cell y)
oscillatorCells :: (C t) => Margin -> Margin -> Int -> t -> T y -> (t, T t) -> (T t, T t) -> T ((t, t), Cell y)
seekCell :: (C t) => Int -> t -> ((t, T t), Cell y) -> ((t, t), Cell y)
oscillatorSuffixes :: (C t) => Margin -> Margin -> Int -> t -> T y -> (t, T t) -> (T t, T t) -> T ((t, T t), Cell y)
dropFrac :: (C i) => i -> T a -> (Int, i, T a)
dropFrac' :: (C i) => i -> T a -> (Int, i, T a)
propDropFrac :: (C i, Eq a) => i -> T a -> Bool
dropRem :: Int -> T a -> (Int, T a)
dropRem' :: Int -> T a -> (Int, T a)
propDropRem :: (Eq a) => Int -> T a -> Bool
oscillatorCoords :: (C t) => Int -> t -> (t, T t) -> (T t, T t) -> T (Coords t)
integrateFractional :: (C t) => t -> (t, T t) -> (T t, T t) -> T (Skip t)

-- | Convert a list of phase steps into a list of momentum phases phase is
--   a number in the interval [0,1) freq contains the phase steps
freqsToPhases :: (C a) => T a -> T a -> T (T a)
limitRelativeShapes :: (C t, Ord t) => Margin -> Margin -> Int -> T y -> (t, T t) -> (t, T t)
limitMinRelativeValues :: (C a, Ord a) => a -> a -> T a -> (a, T a)
limitMaxRelativeValues :: (C a, Ord a) => a -> a -> T a -> (a, T a)

-- | Avoids negative numbers and thus can be used with Chunky numbers.
limitMaxRelativeValuesNonNeg :: (C a, Ord a) => a -> a -> T a -> (a, T a)
safeSub :: (C a, Ord a) => a -> a -> (Bool, a)


-- | Tone generators
--   
--   Frequencies are always specified in ratios of the sample rate, e.g.
--   the frequency 0.01 for the sample rate 44100 Hz means a physical
--   frequency of 441 Hz.
module Synthesizer.Plain.Oscillator
type Phase a = a

-- | oscillator with constant frequency
static :: (C a) => T a b -> (Phase a -> a -> T b)

-- | oscillator with modulated frequency
freqMod :: (C a) => T a b -> Phase a -> T a -> T b

-- | oscillator with modulated phase
phaseMod :: (C a) => T a b -> a -> T (Phase a) -> T b

-- | oscillator with modulated shape
shapeMod :: (C a) => (c -> T a b) -> (Phase a) -> a -> T c -> T b

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a) => T a b -> T (Phase a) -> T a -> T b

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a) => (c -> T a b) -> Phase a -> T c -> T a -> T b

-- | oscillator with a sampled waveform with constant frequency This is
--   essentially an interpolation with cyclic padding.
staticSample :: (C a) => T a b -> [b] -> Phase a -> a -> T b

-- | oscillator with a sampled waveform with modulated frequency Should
--   behave homogenously for different types of interpolation.
freqModSample :: (C a) => T a b -> [b] -> Phase a -> T a -> T b

-- | Shape control is a list of relative changes, each of which must be
--   non-negative in order to allow lazy processing. '1' advances by one
--   wave. Frequency control can be negative. If you want to use sampled
--   waveforms as well then use <tt>Wave.sample</tt> in the list of
--   waveforms. With sampled waves this function is identical to
--   HunkTranspose in Assampler.
--   
--   Example: interpolate different versions of <tt>Wave.oddCosine</tt> and
--   <tt>Wave.oddTriangle</tt>.
--   
--   You could also chop a tone into single waves and use the waves as
--   input for this function but you certainly want to use
--   <tt>Wave.sampledTone</tt> or <a>shapeFreqModFromSampledTone</a>
--   instead, because in the wave information for <a>shapeFreqModSample</a>
--   shape and phase are strictly separated.
shapeFreqModSample :: (C c, C b) => T c (T b a) -> [T b a] -> c -> Phase b -> T c -> T b -> T a
shapePhaseFreqModSample :: (C c, C b) => T c (T b a) -> [T b a] -> c -> T c -> T (Phase b) -> T b -> T a

-- | Time stretching and frequency modulation of a pure tone.
--   
--   We consider a tone as the result of a shape modulated oscillator, and
--   virtually reconstruct the waveform function (a function of time and
--   phase) by interpolation and resample it. This way we can alter
--   frequency and time progress of the tone independently.
--   
--   This function is identical to using <a>shapeFreqMod</a> with a wave
--   function constructed by <tt>Wave.sampledTone</tt> but it consumes the
--   sampled source tone lazily and thus allows only relative shape control
--   with non-negative control steps.
--   
--   The function is similar to <a>shapeFreqModSample</a> but respects that
--   in a sampled tone, phase and shape control advance synchronously.
--   Actually we could re-use <a>shapeFreqModSample</a> with modified phase
--   values. But we would have to cope with negative shape control jumps,
--   and waves would be padded locally cyclically. The latter one is not
--   wanted since we want padding according to the adjacencies in the
--   source tone. Note that differently from <a>shapeFreqModSample</a> the
--   shape control difference <tt>1</tt> does not mean to skip to the next
--   wave, since this oscillator has no discrete waveforms. Instead
--   <tt>1</tt> means that the shape alters as fast as in the prototype
--   signal.
--   
--   Although the shape difference values must be non-negative I hesitate
--   to give them the type <tt>Number.NonNegative.T t</tt> because then you
--   cannot call this function with other types of non-negative numbers
--   like <tt>Number.NonNegativeChunky.T</tt>.
--   
--   The prototype tone signal is reproduced if <tt>freqs == repeat
--   (1/period)</tt> and <tt>shapes == repeat 1</tt>.
shapeFreqModFromSampledTone :: (C t) => T t y -> T t y -> t -> T y -> t -> t -> T t -> T t -> T y
shapePhaseFreqModFromSampledTone :: (C t) => T t y -> T t y -> t -> T y -> t -> t -> T t -> T t -> T t -> T y

-- | sine oscillator with static frequency
staticSine :: (C a, C a) => a -> a -> T a

-- | sine oscillator with modulated frequency
freqModSine :: (C a, C a) => a -> T a -> T a

-- | sine oscillator with modulated phase, useful for FM synthesis
phaseModSine :: (C a, C a) => a -> T a -> T a

-- | saw tooth oscillator with modulated frequency
staticSaw :: (C a) => a -> a -> T a

-- | saw tooth oscillator with modulated frequency
freqModSaw :: (C a) => a -> T a -> T a


-- | Two allpasses that approach a relative phase difference of 90 degree
--   over a large range of frequencies.
--   
--   ToDo: More parameters for controling the affected frequency range.
module Synthesizer.Plain.Filter.Recursive.Hilbert
data Parameter a
Parameter :: [Parameter a] -> [Parameter a] -> Parameter a
parameterCosine :: Parameter a -> [Parameter a]
parameterSine :: Parameter a -> [Parameter a]
polesSine :: (C a) => [a]
polesCosine :: (C a) => [a]

-- | Convert sample rate to allpass parameters.
parameter :: (C a) => a -> Parameter a
step2 :: (C a, C a v) => Parameter a -> v -> State [T v] (T v)
modifierInit2 :: (C a, C a v) => Initialized [T v] [T v] (Parameter a) v (T v)
cascade :: (C a, C a v) => [Parameter a] -> T v v

-- | Although we get (almost) only the right-rotating part of the real
--   input signal, the amplitude is as large as the input amplitude. That
--   is, the amplitude actually doubled.
causal2 :: (C a, C a v) => Parameter a -> T v (T v)
causalComplex2 :: (C a, C a v) => Parameter a -> T (T v) (T v)
scaleWithParamType :: (C a v) => Parameter a -> a -> v -> v
causal :: (C a, C a v) => Parameter a -> T v (T v)
causalComplex :: (C a, C a v) => Parameter a -> T (T v) (T v)
runInit2 :: (C a, C a v) => [T v] -> Parameter a -> T v -> T (T v)
run2 :: (C a, C a v) => Parameter a -> T v -> T (T v)

-- | Approximation to perfect lowpass. However in the low frequencies the
--   above filter is far away from being a perfect Hilbert filter, thus the
--   cut is not straight as expected. This implementation is lazy, but
--   shifts phases.
lowpassStream :: (C a, C a, C a v) => a -> a -> T v -> T v

-- | If we could achieve lowpass filtering while maintaining phases, we
--   could do approximate Whittaker interpolation. Here we try to do this
--   by filtering forward and backward. However, this does not work since
--   we move the spectrum between two Hilbert transforms and thus the phase
--   distortions do not match. It does not even yield a fine lowpass, since
--   reversing the signal does not reverse the spectrum.
lowpassMaintainPhase :: (C a, C a, C a v) => a -> a -> T v -> T v
instance (Show a) => Show (Parameter a)

module Synthesizer.Plain.Effect.Glass

-- | We try to simulate the sound of broken glass as a mixture of short
--   percussive sounds with random pitch
glass :: Double -> [Double]
particles :: Double -> Double -> T Int [Double]
particle :: (C a, C a, C a a) => a -> a -> a -> [a]
densityHeavy :: (C a) => a -> a
densitySmooth :: (C a) => a -> a
timeDiffsAlt :: [Bool] -> [Int]
timeDiffs :: [Bool] -> [Int]
segmentBefore :: (a -> Bool) -> [a] -> [[a]]

module Synthesizer.Plain.Wave
sample :: (C a) => T a v -> T v -> T a v

-- | We assume that a tone was generated by a shape modulated oscillator.
--   We try to reconstruct the wave function (with parameters shape control
--   and phase) from a tone by interpolation.
--   
--   The unit for the shape control parameter is the sampling period. That
--   is the shape parameter is a time parameter pointing to a momentary
--   shape of the prototype signal. Of course this momentary shape does not
--   exist and we can only guess it using interpolation.
--   
--   At the boundaries we repeat the outermost shapes that can be
--   reconstructed entirely from interpolated data (that is, no
--   extrapolation is needed). This way we cannot reproduce the shape at
--   the boundaries because we have no data for cyclically extending it. On
--   the other hand this method guarantees a nice wave shape with the
--   required fractional period.
--   
--   It must be <tt>length tone &gt;= Interpolation.number ipStep +
--   Interpolation.number ipLeap * ceiling period</tt>.
sampledTone :: (C a) => T a v -> T a v -> a -> T v -> a -> T a v

module Synthesizer.Plain.Effect.Fly
main :: IO ExitCode
sampleRate :: Double

-- | stereo sound of a humming fly
fly :: [(Double, Double)]

module Synthesizer.Causal.Interpolation

-- | interpolation as needed for resampling
data T t y

-- | All values of frequency control must be non-negative.
relative :: (C t) => T t y -> t -> T y -> T t y
relativeZeroPad :: (C t) => y -> T t y -> t -> T y -> T t y
relativeConstantPad :: (C t) => T t y -> t -> T y -> T t y
relativeCyclicPad :: (C t) => T t y -> t -> T y -> T t y

-- | The extrapolation may miss some of the first and some of the last
--   points
relativeExtrapolationPad :: (C t) => T t y -> t -> T y -> T t y
relativeZeroPadConstant :: (C t, C y) => t -> T y -> T t y
relativeZeroPadLinear :: (C t, C t y) => t -> T y -> T t y
relativeZeroPadCubic :: (C t, C t y) => t -> T y -> T t y


-- | Tone generators
module Synthesizer.Causal.Oscillator

-- | oscillator with modulated phase
phaseMod :: (C a) => T a b -> a -> T a b

-- | oscillator with modulated shape
shapeMod :: (C a) => (c -> T a b) -> T a -> a -> T c b

-- | oscillator with modulated frequency
freqMod :: (C a) => T a b -> T a -> T a b

-- | oscillator with modulated frequency
freqModAntiAlias :: (C a) => T a b -> T a -> T a b

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a) => T a b -> T (a, a) b

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a) => (c -> T a b) -> T a -> T (c, a) b

-- | oscillator with a sampled waveform with modulated frequency Should
--   behave homogenously for different types of interpolation.
freqModSample :: (C a) => T a b -> T b -> T a -> T a b
shapeFreqModSample :: (C c, C b) => T c (T b a) -> T (T b a) -> c -> T b -> T (c, b) a
shapeFreqModFromSampledTone :: (C t, Transform sig y) => T t y -> T t y -> t -> sig y -> t -> T t -> T (t, t) y
shapePhaseFreqModFromSampledTone :: (C t, Transform sig y) => T t y -> T t y -> t -> sig y -> t -> T t -> T (t, t, t) y

-- | sine oscillator with modulated frequency
freqModSine :: (C a, C a) => T a -> T a a

-- | sine oscillator with modulated phase, useful for FM synthesis
phaseModSine :: (C a, C a) => a -> T a a

-- | saw tooth oscillator with modulated frequency
freqModSaw :: (C a) => T a -> T a a


-- | Tone generators
module Synthesizer.State.Oscillator

-- | Oscillator with constant frequency. It causes aliasing effects for
--   sharp waveforms and high frequencies.
static :: (C a) => T a b -> (T a -> a -> T b)

-- | Oscillator with constant frequency that suppresses aliasing effects
--   using waveforms with controllable smoothness.
staticAntiAlias :: (C a) => T a b -> (T a -> a -> T b)

-- | oscillator with modulated phase
phaseMod :: (C a) => T a b -> a -> T a -> T b

-- | oscillator with modulated shape
shapeMod :: (C a) => (c -> T a b) -> T a -> a -> T c -> T b

-- | oscillator with modulated frequency
freqMod :: (C a) => T a b -> T a -> T a -> T b

-- | oscillator with modulated frequency
freqModAntiAlias :: (C a) => T a b -> T a -> T a -> T b

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a) => T a b -> T a -> T a -> T b

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a) => (c -> T a b) -> T a -> T c -> T a -> T b

-- | oscillator with a sampled waveform with constant frequency This
--   essentially an interpolation with cyclic padding.
staticSample :: (C a) => T a b -> T b -> T a -> a -> T b

-- | oscillator with a sampled waveform with modulated frequency Should
--   behave homogenously for different types of interpolation.
freqModSample :: (C a) => T a b -> T b -> T a -> T a -> T b
shapeFreqModSample :: (C c, C a) => T c (T a b) -> T (T a b) -> c -> T a -> T c -> T a -> T b
shapeFreqModFromSampledTone :: (C a, Transform sig b) => T a b -> T a b -> a -> sig b -> a -> T a -> T a -> T a -> T b
shapePhaseFreqModFromSampledTone :: (C a, Transform sig b) => T a b -> T a b -> a -> sig b -> a -> T a -> T a -> T a -> T a -> T b

-- | sine oscillator with static frequency
staticSine :: (C a, C a) => T a -> a -> T a

-- | sine oscillator with modulated frequency
freqModSine :: (C a, C a) => T a -> T a -> T a

-- | sine oscillator with modulated phase, useful for FM synthesis
phaseModSine :: (C a, C a) => a -> T a -> T a

-- | saw tooth oscillator with modulated frequency
staticSaw :: (C a) => T a -> a -> T a

-- | saw tooth oscillator with modulated frequency
freqModSaw :: (C a) => T a -> T a -> T a


-- | Several functions that add a loop to a sampled sound. This way you can
--   obtain an infinite sound that consumes only finite space.
module Synthesizer.Generic.Loop

-- | Most simple of looping: You give start and length of the loop body and
--   this part is repeated. The data behind start+length is ignored.
simple :: (Transform sig) => Int -> Int -> sig -> sig

-- | Create a smooth loop by cross-fading a part with delayed versions of
--   itself. The loop length will be rounded to the next smaller even
--   number.
fade :: (Transform sig yv, C y, C y yv) => y -> Int -> Int -> sig yv -> sig yv

-- | Resample a sampled sound with a smooth loop using our time
--   manipulation algorithm. Time is first controlled linearly, then
--   switches to a sine or triangular control. Loop start must be large
--   enough in order provide enough spare data for interpolation at the
--   beginning and loop start plus length must preserve according space at
--   the end. One period is enough space for linear interpolation.
--   
--   In order to get a loopable sound with finite space we have to reduce
--   the loop length to a multiple of a wave period. We will also modify
--   the period a little bit, such that in our loop body there is an
--   integral number of periods.
--   
--   We return the modified period and the looped sound.
timeReverse :: (Write sig yv, C q, C q yv) => LazySize -> T q yv -> T q yv -> TimeControl q -> q -> q -> (q, sig yv) -> (q, sig yv)
data TimeControl a
timeControlSine :: (C a) => TimeControl a
timeControlZigZag :: (C a) => TimeControl a


-- | Tone generators
--   
--   Frequencies are always specified in ratios of the sample rate, e.g.
--   the frequency 0.01 for the sample rate 44100 Hz means a physical
--   frequency of 441 Hz.
module Synthesizer.Generic.Oscillator

-- | oscillator with constant frequency
static :: (C a, Write sig b) => LazySize -> T a b -> (T a -> a -> sig b)

-- | oscillator with modulated frequency
freqMod :: (C a, Transform sig a b) => T a b -> T a -> sig a -> sig b

-- | oscillator with modulated phase
phaseMod :: (C a, Transform sig a b) => T a b -> a -> sig a -> sig b

-- | oscillator with modulated shape
shapeMod :: (C a, Transform sig c b) => (c -> T a b) -> T a -> a -> sig c -> sig b

-- | oscillator with both phase and frequency modulation
phaseFreqMod :: (C a, Transform sig a b) => T a b -> sig a -> sig a -> sig b

-- | oscillator with both shape and frequency modulation
shapeFreqMod :: (C a, Read sig c, Transform sig a b) => (c -> T a b) -> T a -> sig c -> sig a -> sig b

-- | oscillator with a sampled waveform with constant frequency This is
--   essentially an interpolation with cyclic padding.
staticSample :: (C a, Read wave b, Write sig b) => LazySize -> T a b -> wave b -> T a -> a -> sig b

-- | oscillator with a sampled waveform with modulated frequency Should
--   behave homogenously for different types of interpolation.
freqModSample :: (C a, Read wave b, Transform sig a b) => T a b -> wave b -> T a -> sig a -> sig b

-- | sine oscillator with static frequency
staticSine :: (C a, C a, Write sig a) => LazySize -> T a -> a -> sig a

-- | sine oscillator with modulated frequency
freqModSine :: (C a, C a, Transform sig a) => T a -> sig a -> sig a

-- | sine oscillator with modulated phase, useful for FM synthesis
phaseModSine :: (C a, C a, Transform sig a) => a -> sig a -> sig a

-- | saw tooth oscillator with modulated frequency
staticSaw :: (C a, Write sig a) => LazySize -> T a -> a -> sig a

-- | saw tooth oscillator with modulated frequency
freqModSaw :: (C a, Transform sig a) => T a -> sig a -> sig a

module Synthesizer.Generic.Interpolation

-- | interpolation as needed for resampling
data T t y
func :: (Read sig y) => T t y -> t -> sig y -> y
offset :: T t y -> Int
number :: T t y -> Int
zeroPad :: (C t, Write sig y) => (T t y -> t -> sig y -> a) -> y -> T t y -> t -> sig y -> a
constantPad :: (C t, Write sig y) => (T t y -> t -> sig y -> a) -> T t y -> t -> sig y -> a

-- | Only for finite input signals.
cyclicPad :: (C t, Transform sig y) => (T t y -> t -> sig y -> a) -> T t y -> t -> sig y -> a

-- | The extrapolation may miss some of the first and some of the last
--   points
extrapolationPad :: (C t, Transform sig y) => (T t y -> t -> sig y -> a) -> T t y -> t -> sig y -> a
single :: (C t, Transform sig y) => T t y -> t -> sig y -> y

-- | All values of frequency control must be non-negative.
multiRelative :: (C t, Transform sig t y) => T t y -> t -> sig y -> sig t -> sig y
multiRelativeZeroPad :: (C t, Transform sig t y, Write sig y) => y -> T t y -> t -> sig t -> sig y -> sig y
multiRelativeConstantPad :: (C t, Transform sig t y, Write sig y) => T t y -> t -> sig t -> sig y -> sig y
multiRelativeCyclicPad :: (C t, Transform sig t y) => T t y -> t -> sig t -> sig y -> sig y

-- | The extrapolation may miss some of the first and some of the last
--   points
multiRelativeExtrapolationPad :: (C t, Transform sig t y) => T t y -> t -> sig t -> sig y -> sig y
multiRelativeZeroPadConstant :: (C t, C y, Transform sig t y, Write sig y) => t -> sig t -> sig y -> sig y
multiRelativeZeroPadLinear :: (C t, C t y, Transform sig t y, Write sig y) => t -> sig t -> sig y -> sig y
multiRelativeZeroPadCubic :: (C t, C t y, Transform sig t y, Write sig y) => t -> sig t -> sig y -> sig y

module Synthesizer.Generic.Filter.Delay
static :: (C y, Write sig y) => Int -> sig y -> sig y
staticPad :: (Write sig y) => y -> Int -> sig y -> sig y
staticPos :: (C y, Write sig y) => Int -> sig y -> sig y
staticNeg :: (Write sig y) => Int -> sig y -> sig y
modulatedCore :: (C t, C y, Read sig t, Transform sig t y) => T t y -> Int -> sig t -> sig y -> sig y

-- | This is essentially different for constant interpolation, because this
--   function <a>looks forward</a> whereas the other two variants <a>look
--   backward</a>. For the symmetric interpolation functions of linear and
--   cubic interpolation, this does not really matter.
modulated :: (C t, C y, Read sig t, Transform sig t y, Write sig y) => T t y -> Int -> sig t -> sig y -> sig y


module Synthesizer.Generic.Filter.Recursive.MovingAverage

-- | Like <tt>Synthesizer.Generic.Filter.NonRecursive.sums</tt> but in a
--   recursive form. This needs only linear time (independent of the window
--   size) but may accumulate rounding errors.
--   
--   <pre>
--   ys = xs * (1,0,0,0,-1) / (1,-1)
--   ys * (1,-1) = xs * (1,0,0,0,-1)
--   ys = xs * (1,0,0,0,-1) + ys * (0,1)
--   </pre>
sumsStaticInt :: (C v, Write sig v) => Int -> sig v -> sig v
modulatedFrac :: (C a, C a v, Transform sig a v, Write sig v) => Int -> sig a -> sig v -> sig v


-- | Special interpolations defined in terms of our custom Interpolation
--   class.
module Synthesizer.Interpolation.Custom

-- | interpolation as needed for resampling
data T t y

-- | Consider the signal to be piecewise constant, where the leading value
--   is used for filling the interval [0,1).
constant :: T t y

-- | Consider the signal to be piecewise linear.
linear :: (C t y) => T t y

-- | Consider the signal to be piecewise cubic, with smooth connections at
--   the nodes. It uses a cubic curve which has node values x0 at 0 and x1
--   at 1 and derivatives (x1-xm1)<i>2 and (x2-x0)</i>2, respectively. You
--   can see how it works if you evaluate the expression for t=0 and t=1 as
--   well as the derivative at these points.
cubic :: (C t, C t y) => T t y

-- | List of functions must be non-empty.
piecewise :: (C t y) => Int -> [t -> t] -> T t y
piecewiseConstant :: (C t y) => T t y
piecewiseLinear :: (C t y) => T t y
piecewiseCubic :: (C t, C t y) => T t y

-- | with this wrapper you can use the collection of interpolating
--   functions from Donadio's DSP library
function :: (C t y) => (Int, Int) -> (t -> t) -> T t y


-- | All recursive filters with real coefficients can be decomposed into
--   first order and second order filters with real coefficients. This
--   follows from the Fundamental theorem of algebra.
module Synthesizer.Plain.Filter.Recursive.SecondOrder

-- | Parameters for a general recursive filter of 2nd order.
data Parameter a
Parameter :: !a -> !a -> !a -> !a -> !a -> Parameter a
c0 :: Parameter a -> !a
c1 :: Parameter a -> !a
c2 :: Parameter a -> !a
d1 :: Parameter a -> !a
d2 :: Parameter a -> !a
data State a
State :: !a -> !a -> !a -> !a -> State a
u1 :: State a -> !a
u2 :: State a -> !a
y1 :: State a -> !a
y2 :: State a -> !a
zeroState :: (C a) => State a
storeParameter :: (Storable a) => Dictionary (Parameter a)
storeState :: (Storable a) => Dictionary (State a)

-- | Given a function which computes the filter parameters of a lowpass
--   filter for a given frequency, turn that into a function which
--   generates highpass parameters, if requested filter type is Highpass.
adjustPassband :: (C a) => Passband -> (a -> Parameter a) -> (a -> Parameter a)

-- | Change filter parameter such that result is amplified by a given
--   factor.
amplify :: (C a) => a -> Parameter a -> Parameter a
step :: (C a, C a v) => Parameter a -> v -> State (State v) v
modifierInit :: (C a, C a v) => Initialized (State v) (State v) (Parameter a) v v
modifier :: (C a, C a v) => Simple (State v) (Parameter a) v v
causal :: (C a, C a v) => T (Parameter a, v) v
runInit :: (C a, C a v) => State v -> T (Parameter a) -> T v -> T v
run :: (C a, C a v) => T (Parameter a) -> T v -> T v
instance (Show a) => Show (State a)
instance (Show a) => Show (Parameter a)
instance (Storable a) => Storable (State a)
instance (Storable a) => Storable (Parameter a)
instance Traversable State
instance Foldable State
instance Applicative State
instance Functor State
instance (C a v) => C a (Parameter v)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter


-- | All recursive filters with real coefficients can be decomposed into
--   first order and second order filters with real coefficients. This
--   follows from the Fundamental theorem of algebra.
--   
--   This implements a cascade of second order filters using
--   StorableVectors for state and filter parameters.
module Synthesizer.Plain.Filter.Recursive.SecondOrderCascade
newtype Parameter a
Parameter :: (Vector (Parameter a)) -> Parameter a
type State a = Vector (State a)
checkSizes :: String -> Vector a -> Vector b -> c -> c
withSizeCheck :: String -> (Vector a -> Vector b -> c) -> (Vector a -> Vector b -> c)
step :: (C a, C a v, Storable a, Storable v) => Parameter a -> v -> State (State v) v
modifierInit :: (C a, C a v, Storable a, Storable v) => Initialized (State v) (State v) (Parameter a) v v
modifier :: (C a, C a v, Storable a, Storable v) => Int -> Simple (State v) (Parameter a) v v
causal :: (C a, C a v, Storable a, Storable v) => Int -> T (Parameter a, v) v
instance (C a v, Storable v) => C a (Parameter v)


-- | Butterworth lowpass and highpass
module Synthesizer.Plain.Filter.Recursive.Butterworth
sineListSlow :: (C a) => a -> [a]
sineListFast :: (C a) => a -> [a]
sineList :: (C a) => a -> [a]
makeSines :: (C a) => Int -> [a]
partialRatio :: (C a) => Int -> a -> a
partialParameter :: (C a) => a -> a -> a -> Parameter a
partialParameterInstable :: (C a) => a -> a -> a -> Parameter a
type Parameter a = Parameter a
parameter :: (C a, Storable a) => Passband -> Int -> Pole a -> Parameter a
modifier :: (C a, C a v, Storable a, Storable v) => Int -> Simple (State v) (Parameter a) v v
causal :: (C a, C a v, Storable a, Storable v) => Int -> T (Parameter a, v) v
checkedHalf :: String -> Int -> Int

-- | When called as <tt>runPole kind order ratio freqs</tt>, the filter
--   amplifies frequency 0 with factor 1 and frequency <tt>freq</tt> with
--   factor <tt>ratio</tt>.
--   
--   It uses the frequency and ratio information directly and thus cannot
--   benefit from efficient parameter interpolation (asynchronous run of a
--   ControlledProcess.
runPole :: (C a, C a v) => Passband -> Int -> T a -> T a -> T v -> T v
causalPole :: (C a, C a v) => Passband -> Int -> T (Pole a, v) v
highpassCausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
lowpassCausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
highpassPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v
lowpassPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v


-- | Chebyshev lowpass and highpass
module Synthesizer.Plain.Filter.Recursive.Chebyshev
circleListSlow :: (C a) => a -> [T a]
circleListFast :: (C a) => a -> [T a]
circleList :: (C a) => a -> [T a]
makeCirclePoints :: (C a) => Int -> [T a]

-- | compute the partial filter of the second order from the pole
--   information
partialParameterB :: (C a) => Int -> a -> a -> T a -> Parameter a
partialParameterA :: (C a) => Int -> a -> a -> T a -> Parameter a
type ParameterA a = (a, Parameter a)
parameterA :: (C a, Storable a) => Passband -> Int -> Pole a -> ParameterA a
type ParameterB a = Parameter a
parameterB :: (C a, Storable a) => Passband -> Int -> Pole a -> ParameterB a
causalA :: (C a, C a v, Storable a, Storable v) => Int -> T (ParameterA a, v) v
causalB :: (C a, C a v, Storable a, Storable v) => Int -> T (ParameterB a, v) v
runBPole :: (C a, C a v) => Passband -> Int -> T a -> T a -> T v -> T v
runAPole :: (C a, C a v) => Passband -> Int -> T a -> T a -> T v -> T v
causalBPole :: (C a, C a v) => Passband -> Int -> T (Pole a, v) v
causalAPole :: (C a, C a v) => Passband -> Int -> T (Pole a, v) v
highpassACausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
lowpassBCausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
highpassBCausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
lowpassACausalPole :: (C a, C a v) => Int -> T (Pole a, v) v
highpassAPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v
lowpassBPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v
highpassBPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v
lowpassAPole :: (C a, C a v) => Int -> T a -> T a -> T v -> T v


-- | State variable filter. One filter that generates lowpass, bandpass,
--   highpass, bandlimit at once.
module Synthesizer.Plain.Filter.Recursive.Universal
data Parameter a
Parameter :: !a -> !a -> !a -> !a -> !a -> !a -> Parameter a
k1 :: Parameter a -> !a
k2 :: Parameter a -> !a
ampIn :: Parameter a -> !a
ampI1 :: Parameter a -> !a
ampI2 :: Parameter a -> !a
ampLimit :: Parameter a -> !a
storeParameter :: (Storable a) => Dictionary (Parameter a)
data Result a
Result :: !a -> !a -> !a -> !a -> Result a
highpass :: Result a -> !a
bandpass :: Result a -> !a
lowpass :: Result a -> !a
bandlimit :: Result a -> !a
storeResult :: (Storable a) => Dictionary (Result a)

-- | The computation of the internal parameters is a bit complicated, but
--   it fulfills the following properties:
--   
--   <ul>
--   <li>At the resonance frequency the band pass has 180 degree phase
--   shift. This is also approximately the frequency where the filter has
--   maximum output. Even more important, this is the frequency where the
--   band limit filter works.</li>
--   <li>At the resonance frequency highpass, lowpass, and bandpass amplify
--   by the factor <tt>resonance</tt>.</li>
--   <li>The lowpass amplifies the frequency zero by factor 1.</li>
--   <li>The highpass amplifies the highest representable (Nyquist)
--   frequency by the factor 1.</li>
--   <li>The bandlimit amplifies both frequency zero and Nyquist frequency
--   by factor one and cancels the resonance frequency.</li>
--   </ul>
parameter :: (C a) => Pole a -> Parameter a
type State v = (v, v)

-- | Universal filter: Computes high pass, band pass, low pass in one go
step :: (C a, C a v) => Parameter a -> v -> State (State v) (Result v)
modifierInit :: (C a, C a v) => Initialized (State v) (v, v) (Parameter a) v (Result v)
modifier :: (C a, C a v) => Simple (State v) (Parameter a) v (Result v)
causal :: (C a, C a v) => T (Parameter a, v) (Result v)
runInit :: (C a, C a v) => (v, v) -> T (Parameter a) -> T v -> T (Result v)
run :: (C a, C a v) => T (Parameter a) -> T v -> T (Result v)
instance (Storable a) => Storable (Result a)
instance (C a v) => C a (Result v)
instance (C v) => C (Result v)
instance Traversable Result
instance Foldable Result
instance Applicative Result
instance Functor Result
instance (Storable a) => Storable (Parameter a)
instance (C a v) => C a (Parameter v)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter

module Synthesizer.Plain.Filter.Recursive.Test
sampleRate :: (C a) => a
chirp :: Double -> [Double]
filter2ndOrderTest :: [Double]
butterworthLowpassTest0 :: [Double]
butterworthLowpassTest1 :: Double
butterworthLowpassTest2 :: [Double]
chebyParameterB :: (C a) => a -> T a -> a -> Parameter a
chebyParameterA :: (C a) => a -> T a -> a -> Parameter a
chebyshevALowpassTest0 :: Parameter Double
chebyshevBLowpassTest0 :: Parameter Double
chebyshevLowpassTest1 :: [Double]
chebyshevALowpassTest2 :: [Double]
chebyshevBLowpassTest2 :: [Double]
moogLowpassTest :: [Double]
universalTest :: [Result Double]
complexRealTest :: [T Double]
chirpComplex :: Double -> [T Double]
complexTest :: [T Double]

module Synthesizer.Plain.Instrument

-- | Create a sound of a slightly changed frequency just as needed for a
--   simple stereo sound.
stereoPhaser :: (C a) => (a -> [b]) -> a -> a -> [b]
allpassPlain :: (C a, C a, C a a) => a -> a -> a -> a -> [a]
allpassDown :: (C a, C a, C a a) => a -> Int -> a -> a -> a -> [a]
moogReso :: (C a, C a, C a a) => a -> Int -> a -> a -> a -> [a]
moogDown :: (C a, C a, C a a) => a -> Int -> a -> a -> a -> [a]
bell :: (C a, C a) => a -> a -> [a]
bellHarmonic :: (C a, C a) => a -> a -> a -> a -> [a]
squareBell :: (C a, C a, C a a) => a -> a -> [a]
moogGuitar :: (C a, C a, C a a) => a -> a -> [a]
moogGuitarSoft :: (C a, C a, C a a) => a -> a -> [a]
simpleSaw :: (C a, C a, C a a) => a -> a -> [a]
fatSaw :: (C a, C a, C a a) => a -> a -> [a]
fastBell :: (C a, C a, C a a) => a -> a -> [a]
filterSaw :: (C a a, C a, C a) => a -> a -> a -> [a]
fmBell :: (C a, C a) => a -> a -> a -> a -> [a]

-- | low pass with resonance
filterSweep :: (C v, C a v, C a, C a) => a -> a -> [v] -> [v]
fatSawChord :: (C a, C a, C a a) => a -> a -> [a]
fatSawChordFilter :: (C a, C a, C a a) => a -> a -> [a]
filterDown :: (C a, C a) => a -> [Parameter a]

-- | accumulate multiple similar saw sounds and observe the increase of
--   volume The oscillator <tt>osc</tt> must accept relative frequencies.
modulatedWave :: (C a, C a) => a -> (a -> [a] -> [a]) -> a -> a -> a -> a -> a -> [a]
accumulatedSaws :: (Random a, C a, C a) => a -> a -> [[a]]
choirWave :: (C a) => [a]
choir :: (Random a, C a, C a) => a -> a -> [a]
osciDoubleSaw :: (C a, C a a) => a -> [a] -> [a]

-- | A tone with a waveform with roughly the dependency x -&gt; x**p, where
--   the waveform is normalized to constant quadratic norm
osciSharp :: (C a, C a) => a -> a -> [a]

-- | Build a saw sound from its harmonics and modulate it. Different to
--   normal modulation I modulate each harmonic with the same depth rather
--   than a proportional one.
osciAbsModSaw :: (C a, C a) => a -> a -> [a]

-- | Short pulsed Noise.white, i.e. Noise.white amplified with pulses of
--   varying H/L ratio.
pulsedNoise :: (C a, Random a, C a, C a) => a -> a -> [a]
noiseBass :: (C a, Random a, C a, C a, C a a) => a -> a -> [a]

-- | Drum sound using the Karplus-Strong-Algorithm This is a Noise.white
--   enveloped by an exponential2 which is piped through the Karplus-Strong
--   machine for generating some frequency. The whole thing is then
--   frequency modulated to give a falling frequency.
electroTom :: (C a, Random a, C a, C a, C a a) => a -> [a]

module Synthesizer.Plain.Effect
main :: IO ExitCode
soundB :: Double -> [Double]
soundA :: Double -> [Double]
sound9 :: Double -> [Double]
sound8 :: Double -> [Double]
sound7 :: Double -> [Double]
sound6 :: Double -> [Double]
sound5 :: Double -> [Double]
sound4 :: Double -> [Double]
sound3 :: Double -> [Double]
sound2 :: Double -> [Double]
sound1 :: Double -> [Double]
sound0 :: Double -> [Double]
soundm0 :: Double -> [Double]
soundE :: Double -> [Double]
cFreq :: Double


-- | This module gives some introductory examples to signal processing with
--   plain Haskell lists. For more complex examples see
--   <a>Synthesizer.Plain.Instrument</a> and
--   <a>Synthesizer.Plain.Effect</a>. The examples require a basic
--   understanding of audio signal processing.
--   
--   In the Haddock documentation you will only see the API. In order to
--   view the example code, please use the "Source code" links beside the
--   function documentation. This requires however, that the Haddock was
--   executed with <tt>hyperlink-source</tt> option.
--   
--   Using plain lists is not very fast, particularly not fast enough for
--   serious real-time applications. It is however the most flexible data
--   structure, which you can also use without knowledge of low level
--   programming. For real-time applications see
--   <a>Synthesizer.Generic.Tutorial</a>.
module Synthesizer.Plain.Tutorial

-- | Play a simple sine tone at 44100 sample rate and 16 bit. These are the
--   parameters used for compact disks. The period of the tone is
--   <tt>2*pi*10</tt>. Playing at sample rate 44100 Hz results in a tone of
--   <tt>44100 / (20*pi) Hz</tt>, that is about <tt>702 Hz</tt>. This is
--   simple enough to be performed in real-time, at least on my machine.
--   For playback we use <tt>SoX</tt>.
sine :: IO ExitCode

-- | Now the same for a stereo signal. Both stereo channels are slightly
--   detuned in order to achieve a stereophonic phasing effect. In
--   principle there is no limit of the number of channels, but with more
--   channels playback becomes difficult. Many signal processes in our
--   package support any tuple and even nested tuples using the notion of
--   an algebraic <tt>module</tt> (see <a>C</a>). A module is a vector
--   space where the scalar numbers do not need to support division. A
--   vector space is often also called a linear space, because all we
--   require of vectors is that they can be added and scaled and these two
--   operations fulfill some natural laws.
sineStereo :: IO ExitCode

-- | Of course we can also write a tone to disk using <tt>sox</tt>.
writeSine :: IO ExitCode

-- | For the following examples we will stick to monophonic sounds played
--   at 44100 Hz. Thus we define a function for convenience.
play :: T Double -> IO ExitCode

-- | Now, let's repeat the <a>sine</a> example in a higher level style. We
--   use the oscillator <a>static</a> that does not allow any modulation.
--   We can however use any waveform. The waveform is essentially a
--   function which maps from the phase to the displacement. Functional
--   programming proves to be very useful here, since anonymous functions
--   as waveforms are optimally supported by the language. We can also
--   expect, that in compiled form the oscillator does not have to call
--   back the waveform function by an expensive explicit function call, but
--   that the compiler will inline both oscillator and waveform such that
--   the oscillator is turned into a simple loop which handles both
--   oscillation and waveform computation.
--   
--   Using the oscillator with <a>sine</a> also has the advantage that we
--   do not have to cope with <a>pi</a>s any longer. The frequency is given
--   as ratio of the sample rate. That is, <tt>0.01</tt> at <tt>44100
--   Hz</tt> sample rate means <tt>441 Hz</tt>. This way all frequencies
--   are given in the low-level signal processing.
--   
--   It is not optimal to handle frequencies this way, since all frequency
--   values are bound to the sample rate. For overcoming this problem, see
--   the high level routines using physical dimensions. For examples see
--   <a>Synthesizer.Dimensional.RateAmplitude.Demonstration</a>.
oscillator :: IO ExitCode

-- | It is very simple to switch to another waveform like a saw tooth wave.
--   Instead of a sharp saw tooth, we use an extreme asymmetric triangle.
--   This is a poor man's band-limiting approach that shall reduce aliasing
--   at high oscillation frequencies. We should really work on band-limited
--   oscillators, but this is hard in the general case.
saw :: IO ExitCode

-- | When we apply a third power to each value of the saw tooths we get an
--   oscillator with cubic polynomial functions as waveform. The distortion
--   function applied to a saw wave can be used to turn every function on
--   the interval [-1,1] into a waveform.
cubic :: IO ExitCode

-- | Now let's start with modulated tones. The first simple example is
--   changing the degree of asymmetry according to a slow oscillator (LFO =
--   low frequency oscillator).
sawMorph :: IO ExitCode

-- | It's also very common to modulate the frequency of a tone.
laser :: IO ExitCode
pingSig :: T Double

-- | A simple sine wave with exponentially decaying amplitude.
ping :: IO ExitCode

-- | The <a>ping</a> sound can also be used to modulate the phase another
--   oscillator. This is a well-known effect used excessively in FM
--   synthesis, that was introduced by the Yamaha DX-7 synthesizer.
fmPing :: IO ExitCode

-- | One of the most impressive sounds effects is certainly frequency
--   filtering, especially when the filter parameters are modulated. In
--   this example we use a resonant lowpass whose resonance frequency is
--   controlled by a slow sine wave. The frequency filters usually use
--   internal filter parameters that are not very intuitive to use
--   directly. Thus we apply a function (here <a>parameter</a>) in order to
--   turn the intuitive parameters "resonance frequency" and "resonance"
--   (resonance frequency amplification while frequency zero is left
--   unchanged) into internal filter parameters. We have not merged these
--   two steps since the computation of internal filter parameters is more
--   expensive then the filtering itself and you may want to reduce the
--   computation by computing the internal filter parameters at a low
--   sample rate and interpolate them. However, in the list implementation
--   this will not save you much time, if at all, since the list operations
--   are too expensive.
--   
--   Now this is the example where my machine is no longer able to produce
--   a constant audio stream in real-time. For tackling this problem,
--   please continue with <a>Synthesizer.Generic.Tutorial</a>.
filterSaw :: IO ExitCode


-- | In this module we demonstrate techniques for getting sound in
--   real-time. Getting real-time performance is mostly an issue of the
--   right signal data structure. However, there is no one-size-fits-all
--   data structure. For choosing the right one, you need to understand how
--   various data structures work, what are their strengths and what are
--   their weaknesses.
module Synthesizer.Generic.Tutorial

-- | First, we define a play routine for lazy storable vectors. Storable
--   lazy vectors are lazy lists of low-level arrays. They are both
--   efficient in time and memory consumption, but the blocks disallow
--   feedback by small delays. Elements of a storable vector must be of
--   type class Storable. This means that elements must have fixed size and
--   advanced data types like functions cannot be used.
play :: T Double -> IO ExitCode

-- | Here is a simple oscillator generated as lazy storable vector. An
--   oscillator is a signal generator, that is it produces a signal without
--   consuming other signals that correspond in time. Signal generators
--   have the maximal block size as parameter. This is the lower limit of
--   possible feedback delays.
oscillator :: IO ExitCode

-- | A routine just for the case that we want to post-process a signal
--   somewhere else.
write :: FilePath -> T Double -> IO ExitCode

-- | The simple brass sound demonstrates how to generate piecewise defined
--   curves. Some infix operators are used in order to make the pieces fit
--   in height. There are also operators for intended jumps.
brass :: IO ExitCode

-- | We rewrite the filter example <a>filterSaw</a> in terms of type
--   classes for more signal types. The constraints become quite large
--   because we must assert, that a particular sample type can be used in
--   the addressed signal type.
filterSawSig :: (Write sig Double, Transform sig (Result Double) Double, Transform sig Double (Result Double), Transform sig Double (Parameter Double)) => sig Double

-- | Here we instantiate <a>filterSawSig</a> for storable vectors and play
--   it. This means that all operations convert a storable vector into
--   another storable vector. While every single operation probably is as
--   efficient as possible, the composition of all those processes could be
--   more efficient. So keep on reading.
filterSaw :: IO ExitCode

-- | The next signal type we want to consider is the stateful signal
--   generator. It is not a common data structure, where the sample values
--   are materialized. Instead it is a description of how to generate
--   sample values iteratively. This is almost identical to the
--   <tt>Data.Stream</tt> module from the <tt>stream-fusion</tt> package.
--   With respect to laziness and restrictions of the sample type (namely
--   none), this signal representation is equivalent to lists. You can
--   convert one into the other in a lossless way. That is, function as
--   sample type is possible. Combination of such signal generators is
--   easily possible and does not require temporary storage, because this
--   signal representation needs no sample value storage at all. However at
--   the end of such processes, the signal must be materialized. Here we
--   write the result into a lazy storable vector and play that. What the
--   compiler actually does is to create a single loop, that generates the
--   storable vector to be played in one go.
playState :: T Double -> IO ExitCode

-- | We demonstrate the stateful signal generator using the known
--   <a>filterSaw</a> example. Actually we can reuse the code from above,
--   because the signal generator is also an instance of the generic signal
--   class.
filterSawState :: IO ExitCode

-- | Merging subsequent signal processes based on signal generators into an
--   efficient large signal processor is easy. Not storing intermediate
--   results is however a problem in another situation: Sometimes you want
--   to share one signal between several processes.
filterPingStateProc :: T Double -> T Double

-- | In the following example we generate an exponential curve which shall
--   be used both as envelope and as resonance frequency control of a
--   resonant lowpass. Actually, recomputing an exponential curve is not an
--   issue, since it only needs one multiplication per sample. But it is
--   simple enough to demonstrate the problem and its solutions. The
--   expression <tt>let env = exponential2 50000 1</tt> fools the reader of
--   the program, since the <tt>env</tt> that is shared, is only the signal
--   generator, that is, the description of how to compute the exponential
--   curve successively. That is wherever a signal process reads
--   <tt>env</tt>, it is computed again.
filterPingState :: IO ExitCode

-- | You can achieve sharing by a very simple way. You can write the result
--   of the signal generator in a list (<a>toList</a>) and use this list as
--   source for a new generator (<a>fromList</a>). <a>fromList</a> provides
--   a signal generator that generates new sample values by delivering the
--   next sample from the list.
--   
--   In a real world implementation you would move the <tt>Sig.fromList .
--   Sig.toList</tt> to <a>filterPingStateProc</a>, since the caller cannot
--   know, that this function uses the signal twice, and the implementor of
--   <a>filterPingStateProc</a> cannot know, how expensive the computation
--   of <tt>env</tt> is.
--   
--   You can use any other signal type for sharing, e.g. storable vectors,
--   but whatever type you choose, you also get its disadvantages. Namely,
--   storable vectors only work for storable samples and lists are
--   generally slow, and they also cannot be optimized away, since this
--   only works, when no sharing is required.
--   
--   Whenever a signal is shared as input between several signal processes,
--   the actual materialized data is that between the slowest and the
--   fastest reading process. This is due to lazy evaluation and garbage
--   collection. If the different readers read with different speed, then
--   you will certainly need a temporary sample storage.
filterPingShare :: IO ExitCode

-- | It is however not uncommon that all readers read with the same speed.
--   In this case we would in principle only need to share the input signal
--   per sample. This way we would not need a data structure for storing a
--   sub-sequence of samples temporarily. But how to do that practically?
--   
--   The solution is not to think in terms of signals and signal
--   processors, e.g. <tt>Sig.T a</tt> and <tt>Sig.T a -&gt; Sig.T b -&gt;
--   Sig.T c</tt>, respectively, but in terms of signal processors, that
--   are guaranteed to run in sync. That is we must assert that signal
--   processors process the samples in chronological order and emit one
--   sample per input sample. We call such processes "causal" processes.
--   For example <tt>Causal.T (a,b) c</tt> represents the function
--   <tt>Sig.T (a,b) -&gt; Sig.T c</tt> but it also carries the guarantee,
--   that for each input of type <tt>(a,b)</tt> one sample of type
--   <tt>c</tt> is emitted or the output terminates. Internally it is the
--   Kleisli arrow of the <tt>StateT Maybe</tt> monad.
--   
--   Another important application of the Causal arrow is feedback. Using
--   causal processes guarantees, that a process cannot read ahead, such
--   that it runs into future data, which does still not exist due to
--   recursion.
--   
--   Programming with arrows needs a bit experience or Haskell extensions.
--   Haskell extensions are either an <tt>Arrow</tt> syntax preprocessor or
--   the preprocessor that is built into GHC. However, for computing with
--   physical dimensions you can no longer use the original <tt>Arrow</tt>
--   class and thus you cannot use the arrow syntax. So here is an example
--   of how to program <a>filterPingShare</a> using <tt>Arrow</tt>
--   combinators.
filterPingCausal :: IO ExitCode


-- | Rendering sound effects off-line has its virtue, but really cool is
--   real-time signal generation. For a long time I thought that it is the
--   compiler's responsibility to make list based signal processing fast
--   enough. However, the compiler has to respect correctness first. That
--   is, it cannot do too fancy optimization, since the optimized program
--   must still do the same as the unoptimized program. So, when we write
--   functions that rely on the maximal flexibility, the compiler cannot
--   turn it to something less flexible. Actually, a list as in
--   <a>Synthesizer.Plain.Signal</a> is the best representation of a signal
--   in terms of flexibility: It allows free choice of the element type,
--   even functions, it is element-wise lazy, allowing for short feedback,
--   it allows sharing of computed data. The drawback is, that it is slow
--   and memory inefficient. In most cases we don't need this full
--   flexibility, but the compiler has no chance to find this out
--   automatically. It can merge several operations on a list to a single
--   operation by the fusion technique, however even a single list
--   operation is hard to perform in real-time.
--   
--   How do real-time software synthesizer achieve real-time performance?
--   They get the popular fast inner loops by processing signals in chunks
--   of raw data. This way, they lose flexibility, because they cannot do
--   quick feedback. We can do the same in Haskell, getting the same
--   restrictions. Additionally, in order to store raw data we must
--   restrict the element types e.g. to the <tt>Storable</tt> class, since
--   we use <tt>StorableVector</tt> in <a>Synthesizer.Storable.Signal</a>.
--   With this technique single signal operations are fast, but their
--   combination cannot be optimized in many cases. This is so, again,
--   because top priority in optimization is correctness. Consider <tt>mix
--   x (cons 0 x)</tt> where <tt>cons 0 x</tt> means <tt>0:x</tt> for our
--   chunky signal data. This expression is a perfect candidate for
--   optimization. But in this case it must not be applied since the chunk
--   structures of <tt>x</tt> and <tt>cons 0 x</tt> do not match. In such
--   cases we would not gain anything over SuperCollider and CSound.
--   
--   Remember that we introduced the chunky signal representation entirely
--   because of efficiency concerns. Actually we are not interested in a
--   special chunk structure, so this should not be a reason for disabling
--   optimization. Of course, we could ignore the correctness and write
--   incorrect optimizer rules that are based on correct ideas. However,
--   experience shows that wrong optimization leads to surprise and
--   infelicities sooner or later. The later the worse, because the later
--   the more code you have written relying on invalid optimization.
--   
--   What we can try is to use list representation, enjoy the optimization
--   that GHC already provides for it, and then let fusion rules jump in
--   that make lists disappear when they are used in connection with chunky
--   sequences. E.g. <tt>Chunky.fromList (List.oscillator freq)</tt> could
--   be turned into <tt>Chunky.oscillator freq</tt>. This approach would be
--   really cool, but works only in theory. In practice it is hard to
--   predict how GHC transforms various operations. Additionally to
--   optimizer rule application it also expands functions to their
--   definitions (known as inlining/unfolding) or specializes functions to
--   fixed types. We cannot rely on our optimizer rules being actually
--   applied. This means however, that in unpredictable cases the
--   optimization fails and the efficiency drops from real-time to
--   non-real-time. This is unacceptable.
--   
--   The solution is a third signal representation, see
--   <a>Synthesizer.State.Signal</a>. (Already got tired?) It consists of
--   no actual data but it is a function that generates elements. Its type
--   is <tt>s -&gt; Maybe (a,s)</tt> or short <tt>StateT s Maybe a</tt>.
--   Given a state of type <tt>s</tt> it produces <tt>Nothing</tt> when the
--   list terminates or <tt>Just</tt> the next element and the updated
--   state. This can be easily converted from and to lists while preserving
--   laziness. We convert to lists by <tt>List.unfoldr</tt> and from lists
--   using <tt>viewL</tt>. Actually this signal representation is very
--   close to the list representation used in the streams package. The main
--   differences are: Firstly, we do not use a list storage that is fused
--   away when only used temporarily. Thus we do not need a fusion rule
--   (that could be skipped by the compiler). Secondly, we have no notion
--   of <tt>Skip</tt>, since operations like <a>filter</a> are uncommon in
--   signal processing. If we write our signal processing in terms of these
--   virtual signals and then convert the result to regular lists or chunky
--   sequences, then only one data structure will be built and GHC does
--   it's best to generate efficient inner loops.
--   
--   We cannot use these virtual signals for sharing and feedback, because
--   there is no data structure that stores the data. If we try to do so
--   anyway, data will be recomputed. Thus we still need chunky sequences
--   or lists for sharing of interim results and for feedback. Actually, an
--   expression like <tt>mix x (reverse x)</tt> would definitely benefit
--   from interim conversion to a chunky sequence, but for <tt>mix x (cons
--   0 x)</tt> this is overkill.
--   
--   In order to get processes like the last one efficient we have a new
--   data type (no, not another one!) but this time it is not a signal data
--   type but a signal processor type. It is the result of thinking about
--   which processes allow sharing on a per-sample basis at all. We come to
--   the conclusion that these can be only causal processes, i.e. processes
--   that depend only on current and past data, not on data from the
--   future. So, we already have a good name:
--   <a>Synthesizer.Causal.Process</a>. Causal processes are
--   <a>Control.Arrow</a>s, however the higher level variant does no longer
--   fit into the Arrow type class. This means that there are various
--   combinations that turn causal processes into larger causal processes.
--   It needs a bit experience in pointfree coding style in order to use
--   the arrow combinators, but there is no way around it, when you want to
--   use physical dimensions. GHC's arrow notation does only support types
--   of the Arrow class. E.g. the expression <tt>mix x (cons 0 x)</tt>
--   becomes <tt>Causal.mix &lt;&lt;&lt; (Causal.id &amp;&amp;&amp;
--   Causal.cons 0)</tt>. When you manage this burden you get processes
--   that are warranted to be causal. They can not only be used to make
--   something efficient, but they also allow to process data from the
--   outside world in a streaming way without <tt>unsafeInterleaveIO</tt>
--   as required e.g. in JACK plugins.
--   
--   We have now a pretty big set of signal storage types that differ
--   considerably in performance but not in the set of operations. This
--   calls for a type class! You find it in
--   <a>Synthesizer.Generic.Signal</a> and
--   <a>Synthesizer.Generic.Signal2</a>.
module Synthesizer.Storage
