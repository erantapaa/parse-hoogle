-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Declarative request parsing
--   
--   WAI Request Spec is a declarative validation layer for HTTP requests.
--   It aims to make error-handling for malformed requests as easy as
--   taking the happy path.
--   
--   A brief summary of the core features:
--   
--   <ul>
--   <li>Can specify headers and query params as input sources</li>
--   <li>Support for parsing ints, floats, text, bytes (with encodings),
--   and bools</li>
--   <li>A parser combinator interface for chaining together request
--   requirements</li>
--   <li>Support for Alternatives</li>
--   <li>Support for optional parameters</li>
--   <li>Convenient and informative default error messages that let service
--   consumers know what went wrong</li>
--   </ul>
--   
--   It is built on WAI, so it is compatible with several Haskell web
--   frameworks. All you need is the ability to access the Request object,
--   and WAI Request Spec takes care of the rest!
@package wai-request-spec
@version 0.10.0.1


module Network.Wai.RequestSpec.Internal.Env
data Env
Env :: Headers -> QParams -> FParams -> Env
headers :: Env -> Headers
qParams :: Env -> QParams
fParams :: Env -> FParams
type EnvMap k v = Map k v
type ParamMap a = EnvMap Text (Maybe Text)
data QueryParams
data FormParams
defaultEnv :: Env
mkHeaders :: RequestHeaders -> Headers
mkQParams :: Query -> QParams

-- | Given a ByteString, constructs association list
mkFParams :: ByteString -> Maybe [(Text, Maybe Text)]

-- | Construct an Env without parsing any form parameters This is ideal if
--   you're not consuming any form data.
toEnv :: Request -> Env

-- | Construct an Env from a Request and an association list of form
--   parameters If a framework exposes parameters in this fashion (Spock,
--   Scotty), use this over <a>toEnvRaw</a>. It's likely the framework
--   consumes the request body when data is sent along using content-type
--   'application/x-www-form-urlencoded'
toEnvWithForm :: Request -> [(Text, Text)] -> Env

-- | Expects form data via request body ByteString This is appropriate if
--   you're programming with raw Network.Wai NOTE: if you're expecting form
--   data, and the form data is in an invalid format this will happily
--   construct an Env with empty form data
toEnvRaw :: Request -> ByteString -> Env
instance Show Env


module Network.Wai.RequestSpec.Error
data Loc
Header :: (CI Text) -> Loc
Param :: Text -> Loc
type Reason = Text
data Error
Missing :: Loc -> Error
Malformed :: Reason -> Text -> Error
Freeform :: Reason -> Error
Or :: Error -> Error -> Error
And :: Error -> Error -> Error
Annotation :: Text -> Error
Clear :: Error
toList :: Error -> [String]
toTextList :: Error -> [Text]
instance Monoid Error
instance Show Error
instance Show Loc


module Network.Wai.RequestSpec.Internal.Parser
data Result a
Failure :: Error -> Result a
Success :: a -> Result a
newtype P a
P :: (forall r. (Error -> Result r) -> (a -> Error -> Result r) -> Result r) -> P a
runP :: P a -> forall r. (Error -> Result r) -> (a -> Error -> Result r) -> Result r
instance Monoid a => Monoid (P a)
instance Alternative P
instance MonadPlus P
instance Applicative P
instance Monad P
instance Functor P
instance Show a => Show (Result a)
instance Monad Result
instance Applicative Result
instance Functor Result


module Network.Wai.RequestSpec.Parser
data Result a
Failure :: Error -> Result a
Success :: a -> Result a
data P a
parse :: (a -> P b) -> a -> Result b
parseMaybe :: (a -> P b) -> a -> Maybe b
parseEither :: (a -> P b) -> a -> Either Error b
(<?>) :: P a -> Text -> P a
missing :: Loc -> P a
malformed :: Reason -> Text -> P a
freeform :: Text -> P a


module Network.Wai.RequestSpec.Internal.Combinators

-- | Required header, apply a function to it
header :: (Text -> P a) -> CI Text -> Env -> P a

-- | Optional header, apply a function to it
headerM :: (Text -> P a) -> CI Text -> Env -> P (Maybe a)

-- | Required query parameter, apply a function to it
qParam :: (Text -> P a) -> Text -> Env -> P a

-- | Optional query parameter, apply a function to it
qParamM :: (Text -> P a) -> Text -> Env -> P (Maybe a)

-- | Required form parameter, apply a function to it
fParam :: (Text -> P a) -> Text -> Env -> P a

-- | Optional form parameter, apply a function to it
fParamM :: (Text -> P a) -> Text -> Env -> P (Maybe a)
int :: (Read a, Integral a) => Text -> P a
bool :: Text -> P Bool
float :: (Read a, Fractional a) => Text -> P a


module Network.Wai.RequestSpec.Combinators

-- | Require a parameter as an integral type
intQ :: (Read a, Integral a) => Text -> Env -> P a

-- | Require a parameter as a boolean: "true" | "false"
boolQ :: Text -> Env -> P Bool

-- | Require a parameter as a fractional type
floatQ :: (Read a, Fractional a) => Text -> Env -> P a

-- | Require a parameter as text
textQ :: Text -> Env -> P Text

-- | Require a parameter as bytes, applying the encoding function
--   <tt>f</tt>
bytesQ :: (Text -> ByteString) -> Text -> Env -> P ByteString

-- | Optional parameter as text
textQM :: Text -> Env -> P (Maybe Text)

-- | Optional parameter as integral
intQM :: (Read a, Integral a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as fractional
floatQM :: (Read a, Fractional a) => Text -> Env -> P (Maybe a)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesQM :: (Text -> ByteString) -> Text -> Env -> P (Maybe ByteString)

-- | Require a parameter as an integral type
intF :: (Read a, Integral a) => Text -> Env -> P a

-- | Require a parameter as a boolean: "true" | "false"
boolF :: Text -> Env -> P Bool

-- | Require a parameter as a fractional type
floatF :: (Read a, Fractional a) => Text -> Env -> P a

-- | Require a parameter as text
textF :: Text -> Env -> P Text

-- | Require a parameter as bytes, applying the encoding function
--   <tt>f</tt>
bytesF :: (Text -> ByteString) -> Text -> Env -> P ByteString

-- | Optional parameter as text
textFM :: Text -> Env -> P (Maybe Text)

-- | Optional parameter as integral
intFM :: (Read a, Integral a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as fractional
floatFM :: (Read a, Fractional a) => Text -> Env -> P (Maybe a)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesFM :: (Text -> ByteString) -> Text -> Env -> P (Maybe ByteString)

-- | Require a header as an integral type
intH :: (Integral a, Read a) => CI Text -> Env -> P a

-- | Require a header as a boolean: "true" | "false"
boolH :: CI Text -> Env -> P Bool

-- | Require a header a fractional type
floatH :: (Fractional a, Read a) => CI Text -> Env -> P a

-- | Require a header as text
textH :: CI Text -> Env -> P Text

-- | Require a header as bytes, applying the encoding function <tt>f</tt>
bytesH :: (Text -> ByteString) -> CI Text -> Env -> P ByteString

-- | Optional header as text
textHM :: CI Text -> Env -> P (Maybe Text)

-- | Optional header as integral
intHM :: (Integral a, Read a) => CI Text -> Env -> P (Maybe a)

-- | Optional header as floating
floatHM :: (Fractional a, Read a) => CI Text -> Env -> P (Maybe a)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesHM :: (Text -> ByteString) -> CI Text -> Env -> P (Maybe ByteString)

-- | Combine a series of alternatives choice [a, b, c] == a <a>|</a> b
--   <a>|</a> c <a>|</a> empty
choice :: [P a] -> P a


-- | A typeclass for constructing data types from an environment. For more
--   details on environments, see
--   <a>Network.Wai.RequestSpec.Internal.Env</a>.
module Network.Wai.RequestSpec.Class

-- | Allows for the parsing of a data type <tt>a</tt> from an Env
class FromEnv a
fromEnv :: FromEnv a => Env -> P a


module Network.Wai.RequestSpec
data Result a
Failure :: Error -> Result a
Success :: a -> Result a
data P a
parse :: (a -> P b) -> a -> Result b
parseMaybe :: (a -> P b) -> a -> Maybe b
parseEither :: (a -> P b) -> a -> Either Error b
(<?>) :: P a -> Text -> P a
freeform :: Text -> P a
malformed :: Reason -> Text -> P a
missing :: Loc -> P a
data Loc
Header :: (CI Text) -> Loc
Param :: Text -> Loc
type Reason = Text
data Error
Missing :: Loc -> Error
Malformed :: Reason -> Text -> Error
Freeform :: Reason -> Error
Or :: Error -> Error -> Error
And :: Error -> Error -> Error
Annotation :: Text -> Error
Clear :: Error

-- | Construct an Env without parsing any form parameters This is ideal if
--   you're not consuming any form data.
toEnv :: Request -> Env

-- | Construct an Env from a Request and an association list of form
--   parameters If a framework exposes parameters in this fashion (Spock,
--   Scotty), use this over <a>toEnvRaw</a>. It's likely the framework
--   consumes the request body when data is sent along using content-type
--   'application/x-www-form-urlencoded'
toEnvWithForm :: Request -> [(Text, Text)] -> Env

-- | Expects form data via request body ByteString This is appropriate if
--   you're programming with raw Network.Wai NOTE: if you're expecting form
--   data, and the form data is in an invalid format this will happily
--   construct an Env with empty form data
toEnvRaw :: Request -> ByteString -> Env
data Env

-- | Allows for the parsing of a data type <tt>a</tt> from an Env
class FromEnv a
fromEnv :: FromEnv a => Env -> P a

-- | Require a parameter as an integral type
intQ :: (Read a, Integral a) => Text -> Env -> P a

-- | Require a parameter as a boolean: "true" | "false"
boolQ :: Text -> Env -> P Bool

-- | Require a parameter as a fractional type
floatQ :: (Read a, Fractional a) => Text -> Env -> P a

-- | Require a parameter as text
textQ :: Text -> Env -> P Text

-- | Require a parameter as bytes, applying the encoding function
--   <tt>f</tt>
bytesQ :: (Text -> ByteString) -> Text -> Env -> P ByteString

-- | Optional parameter as integral
intQM :: (Read a, Integral a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as fractional
floatQM :: (Read a, Fractional a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as text
textQM :: Text -> Env -> P (Maybe Text)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesQM :: (Text -> ByteString) -> Text -> Env -> P (Maybe ByteString)

-- | Require a parameter as an integral type
intF :: (Read a, Integral a) => Text -> Env -> P a

-- | Require a parameter as a boolean: "true" | "false"
boolF :: Text -> Env -> P Bool

-- | Require a parameter as a fractional type
floatF :: (Read a, Fractional a) => Text -> Env -> P a

-- | Require a parameter as text
textF :: Text -> Env -> P Text

-- | Require a parameter as bytes, applying the encoding function
--   <tt>f</tt>
bytesF :: (Text -> ByteString) -> Text -> Env -> P ByteString

-- | Optional parameter as integral
intFM :: (Read a, Integral a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as fractional
floatFM :: (Read a, Fractional a) => Text -> Env -> P (Maybe a)

-- | Optional parameter as text
textFM :: Text -> Env -> P (Maybe Text)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesFM :: (Text -> ByteString) -> Text -> Env -> P (Maybe ByteString)

-- | Require a header as an integral type
intH :: (Integral a, Read a) => CI Text -> Env -> P a

-- | Require a header as a boolean: "true" | "false"
boolH :: CI Text -> Env -> P Bool

-- | Require a header a fractional type
floatH :: (Fractional a, Read a) => CI Text -> Env -> P a

-- | Require a header as text
textH :: CI Text -> Env -> P Text

-- | Require a header as bytes, applying the encoding function <tt>f</tt>
bytesH :: (Text -> ByteString) -> CI Text -> Env -> P ByteString

-- | Optional header as integral
intHM :: (Integral a, Read a) => CI Text -> Env -> P (Maybe a)

-- | Optional header as floating
floatHM :: (Fractional a, Read a) => CI Text -> Env -> P (Maybe a)

-- | Optional header as text
textHM :: CI Text -> Env -> P (Maybe Text)

-- | Optional header as bytes, applying the encoding function <tt>f</tt>
bytesHM :: (Text -> ByteString) -> CI Text -> Env -> P (Maybe ByteString)

-- | Combine a series of alternatives choice [a, b, c] == a <a>|</a> b
--   <a>|</a> c <a>|</a> empty
choice :: [P a] -> P a
