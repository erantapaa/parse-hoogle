-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of the Bitcoin protocol.
--   
--   Haskoin is a package providing an implementation of the Bitcoin
--   protocol specifications. It provides the cryptographic ECDSA and
--   hashing primitives, functions for handling BIP32 extended keys,
--   functions for building and signing various types of regular and
--   multisig transactions and a definition of the network protocol
--   messages.
@package haskoin
@version 0.1.0.2


-- | This module defines various utility functions used across the
--   Network.Haskoin modules.
module Network.Haskoin.Util

-- | Transforms a lazy bytestring into a strict bytestring
toStrictBS :: ByteString -> ByteString

-- | Transforms a strict bytestring into a lazy bytestring
toLazyBS :: ByteString -> ByteString

-- | Transforms a string into a strict bytestring
stringToBS :: String -> ByteString

-- | Transform a strict bytestring to a string
bsToString :: ByteString -> String

-- | Decode a big endian Integer from a bytestring
bsToInteger :: ByteString -> Integer

-- | Encode an Integer to a bytestring as big endian
integerToBS :: Integer -> ByteString

-- | Encode a bytestring to a base16 (HEX) representation
bsToHex :: ByteString -> String

-- | Decode a base16 (HEX) string from a bytestring. This function can fail
--   if the string contains invalid HEX characters
hexToBS :: String -> Maybe ByteString

-- | Strict version of <tt>Data.Binary.encode</tt>
encode' :: Binary a => a -> ByteString

-- | Strict version of <tt>Data.Binary.decode</tt>
decode' :: Binary a => ByteString -> a

-- | Strict version of <tt>Data.Binary.runPut</tt>
runPut' :: Put -> ByteString

-- | Strict version of <tt>Data.Binary.runGet</tt>
runGet' :: Binary a => Get a -> ByteString -> a

-- | Strict version of <tt>Data.Binary.decodeOrFail</tt>
decodeOrFail' :: Binary a => ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Strict version of <tt>Data.Binary.runGetOrFail</tt>
runGetOrFail' :: Binary a => Get a -> ByteString -> Either (ByteString, ByteOffset, String) (ByteString, ByteOffset, a)

-- | Try to decode a Data.Binary value. If decoding succeeds, apply the
--   function to the result. Otherwise, return the default value.
fromDecode :: Binary a => ByteString -> b -> (a -> b) -> b

-- | Try to run a Data.Binary.Get monad. If decoding succeeds, apply a
--   function to the result. Otherwise, return the default value.
fromRunGet :: Binary a => Get a -> ByteString -> b -> (a -> b) -> b

-- | Decode a Data.Binary value into the Either monad. A Right value is
--   returned with the result upon success. Otherwise a Left value with the
--   error message is returned.
decodeToEither :: Binary a => ByteString -> Either String a

-- | Decode a Data.Binary value into the Maybe monad. A Just value is
--   returned with the result upon success. Otherwise, Nothing is returned.
decodeToMaybe :: Binary a => ByteString -> Maybe a

-- | Isolate a Data.Binary.Get monad for the next <tt>Int</tt> bytes. Only
--   the next <tt>Int</tt> bytes of the input bytestring will be available
--   for the Get monad to consume. This function will fail if the Get monad
--   fails or some of the input is not consumed.
isolate :: Binary a => Int -> Get a -> Get a

-- | Returns True if the Either value is Left
isLeft :: Either a b -> Bool

-- | Returns True if the Either value is Right
isRight :: Either a b -> Bool

-- | Extract the Right value from an Either value. Fails if the value is
--   Left
fromRight :: Either a b -> b

-- | Extract the Left value from an Either value. Fails if the value is
--   Right
fromLeft :: Either a b -> a

-- | Transforms an Either value into a Maybe value. Right is mapped to Just
--   and Left is mapped to Nothing. The value inside Left is lost.
eitherToMaybe :: Either a b -> Maybe b

-- | Transforms a Maybe value into an Either value. Just is mapped to Right
--   and Nothing is mapped to Left. You also pass in an error value in case
--   Left is returned.
maybeToEither :: b -> Maybe a -> Either b a

-- | Lift a Either computation into the EitherT monad
liftEither :: Monad m => Either b a -> EitherT b m a

-- | Lift a Maybe computation into the EitherT monad
liftMaybe :: Monad m => b -> Maybe a -> EitherT b m a

-- | Applies a function to only one element of a list defined by it's
--   index. If the index is out of the bounds of the list, the original
--   list is returned.
updateIndex :: Int -> [a] -> (a -> a) -> [a]

-- | Use the list [b] as a template and try to match the elements of [a]
--   against it. For each element of [b] return the (first) matching
--   element of [a], or Nothing. Output list has same size as [b] and
--   contains results in same order. Elements of [a] can only appear once.
matchTemplate :: [a] -> [b] -> (a -> b -> Bool) -> [Maybe a]

-- | Returns the first value of a triple.
fst3 :: (a, b, c) -> a

-- | Returns the second value of a triple.
snd3 :: (a, b, c) -> b

-- | Returns the last value of a triple.
lst3 :: (a, b, c) -> c


-- | Network specific constants
module Network.Haskoin.Constants

-- | Name of the bitcoin network
networkName :: String

-- | Prefix for base58 PubKey hash address
addrPrefix :: Word8

-- | Prefix for base58 script hash address
scriptPrefix :: Word8

-- | Prefix for private key WIF format
secretPrefix :: Word8

-- | Prefix for extended public keys (BIP32)
extPubKeyPrefix :: Word32

-- | Prefix for extended private keys (BIP32)
extSecretPrefix :: Word32

-- | Network magic bytes
networkMagic :: Word32

-- | Genesis block header information
genesisHeader :: BlockHeader

-- | Maximum size of a block in bytes
maxBlockSize :: Int

-- | User agent of this haskoin package
haskoinUserAgent :: String

-- | Default port
defaultPort :: Int

-- | Should we allow relaxed difficulty transition rules. This is useful
--   for testnet.
allowMinDifficultyBlocks :: Bool

-- | Checkpoints to enfore
checkpoints :: [(Int, BlockHash)]


-- | This package provides all of the basic types used for the Bitcoin
--   networking protocol together with Data.Binary instances for
--   efficiently serializing and de-serializing them. More information on
--   the bitcoin protocol is available here:
--   <a>http://en.bitcoin.it/wiki/Protocol_specification</a>
module Network.Haskoin.Protocol

-- | Data type describing a block in the bitcoin protocol. Blocks are sent
--   in response to <a>GetData</a> messages that are requesting information
--   from a block hash.
data Block
Block :: !BlockHeader -> !CoinbaseTx -> ![Tx] -> Block

-- | Header information for this block.
blockHeader :: Block -> !BlockHeader

-- | Coinbase transaction of this block.
blockCoinbaseTx :: Block -> !CoinbaseTx

-- | List of transactions pertaining to this block.
blockTxns :: Block -> ![Tx]
type BlockLocator = [BlockHash]

-- | Data type representing a GetBlocks message request. It is used in the
--   bitcoin protocol to retrieve blocks from a peer by providing it a
--   <a>BlockLocator</a> object. The <a>BlockLocator</a> is a sparse list
--   of block hashes from the caller node with the purpose of informing the
--   receiving node about the state of the caller's blockchain. The
--   receiver node will detect a wrong branch in the caller's main chain
--   and send the caller appropriate <tt>Blocks</tt>. The response to a
--   <a>GetBlocks</a> message is an <a>Inv</a> message containing the list
--   of block hashes pertaining to the request.
data GetBlocks
GetBlocks :: !Word32 -> !BlockLocator -> !BlockHash -> GetBlocks

-- | The protocol version
getBlocksVersion :: GetBlocks -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the genesis block. The list is dense at first and
--   sparse towards the end.
getBlocksLocator :: GetBlocks -> !BlockLocator

-- | Hash of the last desired block. If set to zero, the maximum number of
--   block hashes is returned (500).
getBlocksHashStop :: GetBlocks -> !BlockHash

-- | Data type recording information on a <a>Block</a>. The hash of a block
--   is defined as the hash of this data structure. The block mining
--   process involves finding a partial hash collision by varying the nonce
--   in the <a>BlockHeader</a> and/or additional randomness in the
--   <a>CoinbaseTx</a> of this <a>Block</a>. Variations in the
--   <a>CoinbaseTx</a> will result in different merkle roots in the
--   <a>BlockHeader</a>.
data BlockHeader
BlockHeader :: !Word32 -> !BlockHash -> !Word256 -> !Word32 -> !Word32 -> !Word32 -> BlockHeader

-- | Block version information, based on the version of the software
--   creating this block.
blockVersion :: BlockHeader -> !Word32

-- | Hash of the previous block (parent) referenced by this block.
prevBlock :: BlockHeader -> !BlockHash

-- | Root of the merkle tree of all transactions pertaining to this block.
merkleRoot :: BlockHeader -> !Word256

-- | Unix timestamp recording when this block was created
blockTimestamp :: BlockHeader -> !Word32

-- | The difficulty target being used for this block
blockBits :: BlockHeader -> !Word32

-- | A random nonce used to generate this block. Additional randomness is
--   included in the coinbase transaction of this block.
bhNonce :: BlockHeader -> !Word32

-- | Similar to the <a>GetBlocks</a> message type but for retrieving block
--   headers only. The response to a <a>GetHeaders</a> request is a
--   <a>Headers</a> message containing a list of block headers pertaining
--   to the request. A maximum of 2000 block headers can be returned.
--   <a>GetHeaders</a> is used by thin (SPV) clients to exclude block
--   contents when synchronizing the blockchain.
data GetHeaders
GetHeaders :: !Word32 -> !BlockLocator -> !BlockHash -> GetHeaders

-- | The protocol version
getHeadersVersion :: GetHeaders -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the Genesis block. The list is dense at first and
--   sparse towards the end.
getHeadersBL :: GetHeaders -> !BlockLocator

-- | Hash of the last desired block header. When set to zero, the maximum
--   number of block headers is returned (2000)
getHeadersHashStop :: GetHeaders -> !BlockHash

-- | The <a>Headers</a> type is used to return a list of block headers in
--   response to a <a>GetHeaders</a> message.
data Headers
Headers :: ![BlockHeaderCount] -> Headers

-- | List of block headers with respective transaction counts
headersList :: Headers -> ![BlockHeaderCount]

-- | <a>BlockHeader</a> type with a transaction count as <a>VarInt</a>
type BlockHeaderCount = (BlockHeader, VarInt)

-- | The <a>GetData</a> type is used to retrieve information on a specific
--   object (<a>Block</a> or <a>Tx</a>) identified by the objects hash. The
--   payload of a <a>GetData</a> request is a list of <a>InvVector</a>
--   which represent all the hashes for which a node wants to request
--   information. The response to a <tt>GetBlock</tt> message wille be
--   either a <a>Block</a> or a <a>Tx</a> message depending on the type of
--   the object referenced by the hash. Usually, <a>GetData</a> messages
--   are sent after a node receives an <a>Inv</a> message to obtain
--   information on unknown object hashes.
data GetData
GetData :: ![InvVector] -> GetData

-- | List of object hashes
getDataList :: GetData -> ![InvVector]

-- | <a>Inv</a> messages are used by nodes to advertise their knowledge of
--   new objects by publishing a list of hashes. <a>Inv</a> messages can be
--   sent unsolicited or in response to a <a>GetBlocks</a> message.
data Inv
Inv :: ![InvVector] -> Inv

-- | Inventory vectors
invList :: Inv -> ![InvVector]

-- | Invectory vectors represent hashes identifying objects such as a
--   <a>Block</a> or a <a>Tx</a>. They are sent inside messages to notify
--   other peers about new data or data they have requested.
data InvVector
InvVector :: !InvType -> !Word256 -> InvVector

-- | Type of the object referenced by this inventory vector
invType :: InvVector -> !InvType

-- | Hash of the object referenced by this inventory vector
invHash :: InvVector -> !Word256

-- | Data type identifying the type of an inventory vector.
data InvType

-- | Error. Data containing this type can be ignored.
InvError :: InvType

-- | InvVector hash is related to a transaction
InvTx :: InvType

-- | InvVector hash is related to a block
InvBlock :: InvType

-- | InvVector has is related to a merkle block
InvMerkleBlock :: InvType

-- | A <a>NotFound</a> message is returned as a response to a
--   <a>GetData</a> message whe one of the requested objects could not be
--   retrieved. This could happen, for example, if a tranasaction was
--   requested and was not available in the memory pool of the receiving
--   node.
data NotFound
NotFound :: ![InvVector] -> NotFound

-- | Inventory vectors related to this request
notFoundList :: NotFound -> ![InvVector]

-- | Data type representing a bitcoin transaction
data Tx
Tx :: !Word32 -> ![TxIn] -> ![TxOut] -> !Word32 -> Tx

-- | Transaction data format version
txVersion :: Tx -> !Word32

-- | List of transaction inputs
txIn :: Tx -> ![TxIn]

-- | List of transaction outputs
txOut :: Tx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked
txLockTime :: Tx -> !Word32

-- | Data type representing the coinbase transaction of a <a>Block</a>.
--   Coinbase transactions are special types of transactions which are
--   created by miners when they find a new block. Coinbase transactions
--   have no inputs. They have outputs sending the newly generated bitcoins
--   together with all the block's fees to a bitcoin address (usually the
--   miners address). Data can be embedded in a Coinbase transaction which
--   can be chosen by the miner of a block. This data also typically
--   contains some randomness which is used, together with the nonce, to
--   find a partial hash collision on the block's hash.
data CoinbaseTx
CoinbaseTx :: !Word32 -> !OutPoint -> !ByteString -> !Word32 -> ![TxOut] -> !Word32 -> CoinbaseTx

-- | Transaction data format version.
cbVersion :: CoinbaseTx -> !Word32

-- | Previous outpoint. This is ignored for coinbase transactions but
--   preserved for computing the correct txid.
cbPrevOutput :: CoinbaseTx -> !OutPoint

-- | Data embedded inside the coinbase transaction.
cbData :: CoinbaseTx -> !ByteString

-- | Transaction sequence number. This is ignored for coinbase transactions
--   but preserved for computing the correct txid.
cbInSequence :: CoinbaseTx -> !Word32

-- | List of transaction outputs.
cbOut :: CoinbaseTx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked.
cbLockTime :: CoinbaseTx -> !Word32

-- | Data type representing a transaction input.
data TxIn
TxIn :: !OutPoint -> !ByteString -> !Word32 -> TxIn

-- | Reference the previous transaction output (hash + position)
prevOutput :: TxIn -> !OutPoint

-- | Script providing the requirements of the previous transaction output
--   to spend those coins.
scriptInput :: TxIn -> !ByteString

-- | Transaction version as defined by the sender of the transaction. The
--   intended use is for replacing transactions with new information before
--   the transaction is included in a block.
txInSequence :: TxIn -> !Word32

-- | Data type representing a transaction output.
data TxOut
TxOut :: !Word64 -> !ByteString -> TxOut

-- | Transaction output value.
outValue :: TxOut -> !Word64

-- | Script specifying the conditions to spend this output.
scriptOutput :: TxOut -> !ByteString

-- | The OutPoint is used inside a transaction input to reference the
--   previous transaction output that it is spending.
data OutPoint
OutPoint :: !TxHash -> !Word32 -> OutPoint

-- | The hash of the referenced transaction.
outPointHash :: OutPoint -> !TxHash

-- | The position of the specific output in the transaction. The first
--   output position is 0.
outPointIndex :: OutPoint -> !Word32
data MerkleBlock
MerkleBlock :: !BlockHeader -> !Word32 -> ![Word256] -> ![Bool] -> MerkleBlock

-- | Header information for this merkle block.
merkleHeader :: MerkleBlock -> !BlockHeader

-- | Number of transactions in the block (including unmatched
--   transactions).
merkleTotalTxns :: MerkleBlock -> !Word32

-- | Hashes in depth-first order. They are used to rebuild a partial merkle
--   tree.
mHashes :: MerkleBlock -> ![Word256]

-- | Flag bits, packed per 8 in a byte. Least significant bit first. Flag
--   bits are used to rebuild a partial merkle tree.
mFlags :: MerkleBlock -> ![Bool]

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter
BloomFilter :: !(Seq Word8) -> !Word32 -> !Word32 -> !BloomFlags -> BloomFilter

-- | Bloom filter data
bloomData :: BloomFilter -> !(Seq Word8)

-- | Number of hash functions for this filter
bloomHashFuncs :: BloomFilter -> !Word32

-- | Hash function random nonce
bloomTweak :: BloomFilter -> !Word32

-- | Bloom filter auto-update flags
bloomFlags :: BloomFilter -> !BloomFlags

-- | Set a new bloom filter on the peer connection.
newtype FilterLoad
FilterLoad :: BloomFilter -> FilterLoad
getBloomFilter :: FilterLoad -> BloomFilter

-- | Add the given data element to the connections current filter without
--   requiring a completely new one to be set.
newtype FilterAdd
FilterAdd :: ByteString -> FilterAdd
getFilterData :: FilterAdd -> ByteString

-- | Data type representing a variable length integer. The <a>VarInt</a>
--   type usually precedes an array or a string that can vary in length.
newtype VarInt
VarInt :: Word64 -> VarInt
getVarInt :: VarInt -> Word64

-- | Data type for variable length strings. Variable length strings are
--   serialized as a <a>VarInt</a> followed by a bytestring.
newtype VarString
VarString :: ByteString -> VarString
getVarString :: VarString -> ByteString

-- | Data type describing a bitcoin network address. Addresses are stored
--   in IPv6. IPv4 addresses are mapped to IPv6 using IPv4 mapped IPv6
--   addresses:
--   <a>http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses</a>.
--   Sometimes, timestamps are sent together with the <a>NetworkAddress</a>
--   such as in the <a>Addr</a> data type.
data NetworkAddress
NetworkAddress :: !Word64 -> !(Word64, Word64) -> !Word16 -> NetworkAddress

-- | Bitmask of services available for this address
naServices :: NetworkAddress -> !Word64

-- | IPv6 address serialized as big endian
naAddress :: NetworkAddress -> !(Word64, Word64)

-- | Port number serialized as big endian
naPort :: NetworkAddress -> !Word16

-- | Provides information on known nodes in the bitcoin network. An
--   <a>Addr</a> type is sent inside a <tt>Message</tt> as a response to a
--   <tt>GetAddr</tt> message.
data Addr
Addr :: ![NetworkAddressTime] -> Addr
addrList :: Addr -> ![NetworkAddressTime]

-- | Network address with a timestamp
type NetworkAddressTime = (Word32, NetworkAddress)

-- | When a bitcoin node creates an outgoing connection to another node,
--   the first message it will send is a <a>Version</a> message. The other
--   node will similarly respond with it's own <a>Version</a> message.
data Version
Version :: !Word32 -> !Word64 -> !Word64 -> !NetworkAddress -> !NetworkAddress -> !Word64 -> !VarString -> !Word32 -> !Bool -> Version

-- | Protocol version being used by the node.
version :: Version -> !Word32

-- | Bitmask of features to enable for this connection.
services :: Version -> !Word64

-- | UNIX timestamp
timestamp :: Version -> !Word64

-- | Network address of the node receiving this message.
addrRecv :: Version -> !NetworkAddress

-- | Network address of the node sending this message.
addrSend :: Version -> !NetworkAddress

-- | Randomly generated identifying sent with every version message. This
--   nonce is used to detect connection to self.
verNonce :: Version -> !Word64

-- | User agent
userAgent :: Version -> !VarString

-- | The height of the last block received by the sending node.
startHeight :: Version -> !Word32

-- | Wether the remote peer should announce relaying transactions or not.
--   This feature is enabled since version &gt;= 70001. See BIP37 for more
--   details.
relay :: Version -> !Bool

-- | A Ping message is sent to bitcoin peers to check if a TCP/IP
--   connection is still valid.
newtype Ping
Ping :: Word64 -> Ping

-- | A random nonce used to identify the recipient of the ping request once
--   a Pong response is received.
pingNonce :: Ping -> Word64

-- | A Pong message is sent as a response to a ping message.
newtype Pong
Pong :: Word64 -> Pong

-- | When responding to a Ping request, the nonce from the Ping is copied
--   in the Pong response.
pongNonce :: Pong -> Word64

-- | Data type describing signed messages that can be sent between bitcoin
--   nodes to display important notifications to end users about the health
--   of the network.
data Alert
Alert :: !VarString -> !VarString -> Alert

-- | Alert payload.
alertPayload :: Alert -> !VarString

-- | ECDSA signature of the payload
alertSignature :: Alert -> !VarString

-- | The reject message is sent when messages are rejected by a peer.
data Reject
Reject :: !MessageCommand -> !RejectCode -> !VarString -> Reject

-- | Type of message rejected
rejectMessage :: Reject -> !MessageCommand

-- | Code related to the rejected message
rejectCode :: Reject -> !RejectCode

-- | Text version of rejected reason
rejectReason :: Reject -> !VarString
data RejectCode
RejectMalformed :: RejectCode
RejectInvalid :: RejectCode
RejectObsolete :: RejectCode
RejectDuplicate :: RejectCode
RejectNonStandard :: RejectCode
RejectDust :: RejectCode
RejectInsufficientFee :: RejectCode
RejectCheckpoint :: RejectCode

-- | Convenience function to build a Reject message
reject :: MessageCommand -> RejectCode -> String -> Reject

-- | The <a>Message</a> type is used to identify all the valid messages
--   that can be sent between bitcoin peers. Only values of type
--   <a>Message</a> will be accepted by other bitcoin peers as bitcoin
--   protocol messages need to be correctly serialized with message
--   headers. Serializing a <a>Message</a> value will include the
--   <a>MessageHeader</a> with the correct checksum value automatically. No
--   need to add the <a>MessageHeader</a> separately.
data Message
MVersion :: !Version -> Message
MVerAck :: Message
MAddr :: !Addr -> Message
MInv :: !Inv -> Message
MGetData :: !GetData -> Message
MNotFound :: !NotFound -> Message
MGetBlocks :: !GetBlocks -> Message
MGetHeaders :: !GetHeaders -> Message
MTx :: !Tx -> Message
MBlock :: !Block -> Message
MMerkleBlock :: !MerkleBlock -> Message
MHeaders :: !Headers -> Message
MGetAddr :: Message
MFilterLoad :: !FilterLoad -> Message
MFilterAdd :: !FilterAdd -> Message
MFilterClear :: Message
MPing :: !Ping -> Message
MPong :: !Pong -> Message
MAlert :: !Alert -> Message
MReject :: Reject -> Message

-- | Data type representing the header of a <a>Message</a>. All messages
--   sent between nodes contain a message header.
data MessageHeader
MessageHeader :: !Word32 -> !MessageCommand -> !Word32 -> !CheckSum32 -> MessageHeader

-- | Network magic bytes. It is used to differentiate messages meant for
--   different bitcoin networks, such as prodnet and testnet.
headMagic :: MessageHeader -> !Word32

-- | Message command identifying the type of message. included in the
--   payload.
headCmd :: MessageHeader -> !MessageCommand

-- | Byte length of the payload.
headPayloadSize :: MessageHeader -> !Word32

-- | Checksum of the payload.
headChecksum :: MessageHeader -> !CheckSum32

-- | A <a>MessageCommand</a> is included in a <tt>MessageHeader</tt> in
--   order to identify the type of message present in the payload. This
--   allows the message de-serialization code to know how to decode a
--   particular message payload. Every valid <tt>Message</tt> constructor
--   has a corresponding <a>MessageCommand</a> constructor.
data MessageCommand
MCVersion :: MessageCommand
MCVerAck :: MessageCommand
MCAddr :: MessageCommand
MCInv :: MessageCommand
MCGetData :: MessageCommand
MCNotFound :: MessageCommand
MCGetBlocks :: MessageCommand
MCGetHeaders :: MessageCommand
MCTx :: MessageCommand
MCBlock :: MessageCommand
MCMerkleBlock :: MessageCommand
MCHeaders :: MessageCommand
MCGetAddr :: MessageCommand
MCFilterLoad :: MessageCommand
MCFilterAdd :: MessageCommand
MCFilterClear :: MessageCommand
MCPing :: MessageCommand
MCPong :: MessageCommand
MCAlert :: MessageCommand
MCReject :: MessageCommand


-- | This package provides the elliptic curve cryptography required for
--   creating and validating bitcoin transactions. It also provides SHA-256
--   and RIPEMD-160 hashing functions; as well as mnemonic keys from
--   BIP-0039.
module Network.Haskoin.Crypto

-- | Elliptic curve public key type. Two constructors are provided for
--   creating compressed and uncompressed public keys from a Point. The use
--   of compressed keys is preferred as it produces shorter keys without
--   compromising security. Uncompressed keys are supported for backwards
--   compatibility.
data PubKey

-- | Compressed public key
PubKey :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Uncompressed public key
PubKeyU :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Returns True if the public key is valid. This will check if the public
--   key point lies on the curve.
isValidPubKey :: PubKey -> Bool

-- | Returns True if the public key is uncompressed
isPubKeyU :: PubKey -> Bool

-- | Derives a public key from a private key. This function will preserve
--   information on key compression (PrvKey becomes PubKey and PrvKeyU
--   becomes PubKeyU)
derivePubKey :: PrvKey -> PubKey

-- | Computes an Address value from a public key
pubKeyAddr :: PubKey -> Address

-- | Elliptic curve private key type. Two constructors are provided for
--   creating compressed or uncompressed private keys. Compression
--   information is stored in private key WIF formats and needs to be
--   preserved to generate the correct addresses from the corresponding
--   public key.
data PrvKey

-- | Compressed private key
PrvKey :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Uncompressed private key
PrvKeyU :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Returns True if the private key is valid. This will check if the
--   integer value representing the private key is greater than 0 and
--   smaller than the curve order N.
isValidPrvKey :: Integer -> Bool

-- | Builds a compressed private key from an Integer value. Returns Nothing
--   if the Integer would not produce a valid private key. For security,
--   the Integer needs to be generated from a random source with sufficient
--   entropy.
makePrvKey :: Integer -> Maybe PrvKey

-- | Builds an uncompressed private key from an Integer value. Returns
--   Nothing if the Integer would not produce a valid private key. For
--   security, the Integer needs to be generated from a random source with
--   sufficient entropy.
makePrvKeyU :: Integer -> Maybe PrvKey

-- | Returns the Integer value of a private key
fromPrvKey :: PrvKey -> Integer

-- | Returns True of the private key is uncompressed
isPrvKeyU :: PrvKey -> Bool

-- | Serialize a private key into the Data.Binary.Put monad as a 32 byte
--   big endian ByteString. This is useful when a constant length
--   serialization format for private keys is required
putPrvKey :: PrvKey -> Put

-- | Deserializes a compressed private key from the Data.Binary.Get monad
--   as a 32 byte big endian ByteString.
getPrvKey :: Get PrvKey

-- | Deserializes an uncompressed private key from the Data.Binary.Get
--   monad as a 32 byte big endian ByteString
getPrvKeyU :: Get PrvKey

-- | Decodes a private key from a WIF encoded String. This function can
--   fail if the input string does not decode correctly as a base 58 string
--   or if the checksum fails.
--   <a>http://en.bitcoin.it/wiki/Wallet_import_format</a>
fromWIF :: String -> Maybe PrvKey

-- | Encodes a private key into WIF format
toWIF :: PrvKey -> String

-- | StateT monad stack tracking the internal state of HMAC DRBG pseudo
--   random number generator using SHA-256. The <a>SecretT</a> monad is run
--   with the <a>withSource</a> function by providing it a source of
--   entropy.
type SecretT m = StateT (SecretState m) m

-- | Run a <a>SecretT</a> monad by providing it a source of entropy. You
--   can use <a>devURandom</a>, <a>devRandom</a> or provide your own
--   entropy source function.
withSource :: Monad m => (Int -> m ByteString) -> SecretT m a -> m a

-- | /dev/urandom entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devURandom :: Int -> IO ByteString

-- | /dev/random entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devRandom :: Int -> IO ByteString

-- | Produce a new <a>PrvKey</a> randomly from the <a>SecretT</a> monad.
genPrvKey :: Monad m => SecretT m PrvKey

-- | Data type representing an ECDSA signature.
data Signature

-- | Safely sign a message inside the <a>SecretT</a> monad. The
--   <a>SecretT</a> monad will generate a new nonce for each signature.
signMsg :: Monad m => Word256 -> PrvKey -> SecretT m Signature

-- | Sign a message using ECDSA deterministic signatures as defined by RFC
--   6979 <a>http://tools.ietf.org/html/rfc6979</a>
detSignMsg :: Word256 -> PrvKey -> Signature

-- | Verify an ECDSA signature
verifySig :: Word256 -> Signature -> PubKey -> Bool

-- | Returns True if the S component of a Signature is &lt;= order/2.
--   Signatures need to pass this test to be canonical.
isCanonicalHalfOrder :: Signature -> Bool

-- | Data type representing a 512 bit unsigned integer. It is implemented
--   as an Integer modulo 2^512.
type Word512 = BigWord Mod512

-- | Data type representing a 256 bit unsigned integer. It is implemented
--   as an Integer modulo 2^256.
type Word256 = BigWord Mod256

-- | Data type representing a 160 bit unsigned integer. It is implemented
--   as an Integer modulo 2^160.
type Word160 = BigWord Mod160

-- | Data type representing a 128 bit unsigned integer. It is implemented
--   as an Integer modulo 2^128.
type Word128 = BigWord Mod128

-- | Type representing a transaction hash.
type TxHash = BigWord Mod256Tx

-- | Type representing a block hash.
type BlockHash = BigWord Mod256Block
type CheckSum32 = Word32

-- | Computes the hash of a transaction.
txHash :: Tx -> TxHash

-- | Computes the hash of a coinbase transaction.
cbHash :: CoinbaseTx -> TxHash

-- | Compute the hash of a block header
headerHash :: BlockHeader -> BlockHash

-- | Encodes a <a>TxHash</a> as little endian in HEX format. This is mostly
--   used for displaying transaction ids. Internally, these ids are handled
--   as big endian but are transformed to little endian when displaying
--   them.
encodeTxHashLE :: TxHash -> String

-- | Decodes a little endian <a>TxHash</a> in HEX format.
decodeTxHashLE :: String -> Maybe TxHash

-- | Encodes a <a>BlockHash</a> as little endian in HEX format. This is
--   mostly used for displaying Block hash ids. Internally, these ids are
--   handled as big endian but are transformed to little endian when
--   displaying them.
encodeBlockHashLE :: BlockHash -> String

-- | Decodes a little endian <a>BlockHash</a> in HEX format.
decodeBlockHashLE :: String -> Maybe BlockHash

-- | Computes SHA-512.
hash512 :: ByteString -> Word512

-- | Computes SHA-512 and returns the result as a bytestring.
hash512BS :: ByteString -> ByteString

-- | Computes SHA-256.
hash256 :: ByteString -> Word256

-- | Computes SHA-256 and returns the result as a bytestring.
hash256BS :: ByteString -> ByteString

-- | Computes SHA-160.
hashSha1 :: ByteString -> Word160

-- | Computes SHA-160 and returns the result as a bytestring.
hashSha1BS :: ByteString -> ByteString

-- | Computes RIPEMD-160.
hash160 :: ByteString -> Word160

-- | Computes RIPEMD-160 and returns the result as a bytestring.
hash160BS :: ByteString -> ByteString

-- | Computes two rounds of SHA-256.
doubleHash256 :: ByteString -> Word256

-- | Computes two rounds of SHA-256 and returns the result as a bytestring.
doubleHash256BS :: ByteString -> ByteString

-- | Computes a 32 bit checksum.
chksum32 :: ByteString -> CheckSum32

-- | Computes HMAC over SHA-512.
hmac512 :: ByteString -> ByteString -> Word512

-- | Computes HMAC over SHA-512 and return the result as a bytestring.
hmac512BS :: ByteString -> ByteString -> ByteString

-- | Computes HMAC over SHA-256.
hmac256 :: ByteString -> ByteString -> Word256

-- | Computes HMAC over SHA-256 and return the result as a bytestring.
hmac256BS :: ByteString -> ByteString -> ByteString

-- | Split a <a>Word512</a> into a pair of <a>Word256</a>.
split512 :: Word512 -> (Word256, Word256)

-- | Join a pair of <a>Word256</a> into a <a>Word512</a>.
join512 :: (Word256, Word256) -> Word512

-- | MurmurHash3 (x86_32). For more details, see
--   <a>http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp</a>
--   This code is used in the bloom filters of SPV nodes.
murmurHash3 :: Word32 -> ByteString -> Word32

-- | Decode the compact number used in the difficulty target of a block
--   into an Integer.
--   
--   As described in the Satoshi reference implementation
--   <i>src</i>bignum.h:
--   
--   The <a>compact</a> format is a representation of a whole number N
--   using an unsigned 32bit number similar to a floating point format. The
--   most significant 8 bits are the unsigned exponent of base 256. This
--   exponent can be thought of as <a>number of bytes of N</a>. The lower
--   23 bits are the mantissa. Bit number 24 (0x800000) represents the sign
--   of N.
--   
--   <pre>
--   N = (-1^sign) * mantissa * 256^(exponent-3)
--   </pre>
decodeCompact :: Word32 -> Integer

-- | Encode an Integer to the compact number format used in the difficulty
--   target of a block.
encodeCompact :: Integer -> Word32

-- | Data type representing a Bitcoin address
data Address

-- | Public Key Hash Address
PubKeyAddress :: Word160 -> Address
getAddrHash :: Address -> Word160

-- | Script Hash Address
ScriptAddress :: Word160 -> Address
getAddrHash :: Address -> Word160

-- | Decodes an Address from a base58 encoded String. This function can
--   fail if the String is not properly encoded as base58 or the checksum
--   fails.
base58ToAddr :: String -> Maybe Address

-- | Transforms an Address into a base58 encoded String
addrToBase58 :: Address -> String

-- | Encode a bytestring to a base 58 representation.
encodeBase58 :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring. This can fail if the input
--   bytestring contains invalid base 58 characters such as 0,O,l,I
decodeBase58 :: ByteString -> Maybe ByteString

-- | Computes a checksum for the input bytestring and encodes the input and
--   the checksum to a base 58 representation.
encodeBase58Check :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring that contains a checksum. This
--   function returns Nothing if the input bytestring contains invalid base
--   58 characters or if the checksum fails.
decodeBase58Check :: ByteString -> Maybe ByteString
type Entropy = ByteString
type Mnemonic = String
type Passphrase = String
type Seed = ByteString

-- | Provide intial entropy as a <a>ByteString</a> of length multiple of 4
--   bytes. Output a mnemonic sentence.
toMnemonic :: Entropy -> Either String Mnemonic

-- | Get a 512-bit seed from a mnemonic sentence. Will calculate checksum.
--   Passphrase can be used to protect the mnemonic. Use an empty string as
--   passphrase if none is required.
mnemonicToSeed :: Passphrase -> Mnemonic -> Either String Seed
type ChainCode = Word256

-- | Data type representing an extended BIP32 private key. An extended key
--   is a node in a tree of key derivations. It has a depth in the tree, a
--   parent node and an index to differentiate it from other siblings.
data XPrvKey
XPrvKey :: !Word8 -> !Word32 -> !Word32 -> !ChainCode -> !PrvKey -> XPrvKey

-- | Depth in the tree of key derivations.
xPrvDepth :: XPrvKey -> !Word8

-- | Fingerprint of the parent key.
xPrvParent :: XPrvKey -> !Word32

-- | Key derivation index.
xPrvIndex :: XPrvKey -> !Word32

-- | Chain code.
xPrvChain :: XPrvKey -> !ChainCode

-- | The private key of this extended key node.
xPrvKey :: XPrvKey -> !PrvKey

-- | Build a BIP32 compatible extended private key from a bytestring. This
--   will produce a root node (depth=0 and parent=0).
makeXPrvKey :: ByteString -> Maybe XPrvKey

-- | Returns True if the extended private key was derived through a prime
--   derivation.
xPrvIsPrime :: XPrvKey -> Bool

-- | Returns the derivation index of this extended private key without the
--   prime bit set.
xPrvChild :: XPrvKey -> Word32

-- | Computes the key identifier of an extended private key.
xPrvID :: XPrvKey -> Word160

-- | Computes the key fingerprint of an extended private key.
xPrvFP :: XPrvKey -> Word32

-- | Exports an extended private key to the BIP32 key export format (base
--   58).
xPrvExport :: XPrvKey -> String

-- | Decodes a BIP32 encoded extended private key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPrvImport :: String -> Maybe XPrvKey

-- | Export an extended private key to WIF (Wallet Import Format).
xPrvWIF :: XPrvKey -> String

-- | Data type representing an extended BIP32 public key.
data XPubKey
XPubKey :: !Word8 -> !Word32 -> !Word32 -> !ChainCode -> !PubKey -> XPubKey

-- | Depth in the tree of key derivations.
xPubDepth :: XPubKey -> !Word8

-- | Fingerprint of the parent key.
xPubParent :: XPubKey -> !Word32

-- | Key derivation index.
xPubIndex :: XPubKey -> !Word32

-- | Chain code.
xPubChain :: XPubKey -> !ChainCode

-- | The public key of this extended key node.
xPubKey :: XPubKey -> !PubKey

-- | Derive an extended public key from an extended private key. This
--   function will preserve the depth, parent, index and chaincode fields
--   of the extended private keys.
deriveXPubKey :: XPrvKey -> XPubKey

-- | Returns True if the extended public key was derived through a prime
--   derivation.
xPubIsPrime :: XPubKey -> Bool

-- | Returns the derivation index of this extended public key without the
--   prime bit set.
xPubChild :: XPubKey -> Word32

-- | Computes the key identifier of an extended public key.
xPubID :: XPubKey -> Word160

-- | Computes the key fingerprint of an extended public key.
xPubFP :: XPubKey -> Word32

-- | Computer the <a>Address</a> of an extended public key.
xPubAddr :: XPubKey -> Address

-- | Exports an extended public key to the BIP32 key export format (base
--   58).
xPubExport :: XPubKey -> String

-- | Decodes a BIP32 encoded extended public key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPubImport :: String -> Maybe XPubKey

-- | Compute a private, non-prime child key derivation. A private non-prime
--   derivation will allow the equivalent extended public key to derive the
--   public key for this child. Given a parent key <i>m</i> and a
--   derivation index <i>i</i>, this function will compute m/i/.
--   
--   Non-prime derivations allow for more flexibility such as read-only
--   wallets. However, care must be taken not the leak both the parent
--   extended public key and one of the extended child private keys as this
--   would compromise the extended parent private key.
prvSubKey :: XPrvKey -> Word32 -> Maybe XPrvKey

-- | Compute a public, non-prime child key derivation. Given a parent key
--   <i>M</i> and a derivation index <i>i</i>, this function will compute
--   M/i/.
pubSubKey :: XPubKey -> Word32 -> Maybe XPubKey

-- | Compute a prime child key derivation. Prime derivations can only be
--   computed for private keys. Prime derivations do not allow the parent
--   public key to derive the child public keys. However, they are safer as
--   a breach of the parent public key and child private keys does not lead
--   to a breach of the parent private key. Given a parent key <i>m</i> and
--   a derivation index <i>i</i>, this function will compute m/i'/.
primeSubKey :: XPrvKey -> Word32 -> Maybe XPrvKey

-- | Cyclic list of all private non-prime child key derivations of a parent
--   key starting from an offset index.
prvSubKeys :: XPrvKey -> Word32 -> [(XPrvKey, Word32)]

-- | Cyclic list of all public non-prime child key derivations of a parent
--   key starting from an offset index.
pubSubKeys :: XPubKey -> Word32 -> [(XPubKey, Word32)]

-- | Cyclic list of all prime child key derivations of a parent key
--   starting from an offset index.
primeSubKeys :: XPrvKey -> Word32 -> [(XPrvKey, Word32)]

-- | Compute a public, non-prime subkey derivation for all of the parent
--   public keys in the input. This function will succeed only if the child
--   key derivations for all the parent keys are valid.
--   
--   This function is intended to be used in the context of multisignature
--   accounts. Parties exchanging their master public keys to create a
--   multisignature account can then individually generate all the
--   receiving multisignature addresses without further communication.
mulSigSubKey :: [XPubKey] -> Word32 -> Maybe [XPubKey]

-- | Cyclic list of all public, non-prime multisig key derivations of a
--   list of parent keys starting from an offset index.
mulSigSubKeys :: [XPubKey] -> Word32 -> [([XPubKey], Word32)]
type KeyIndex = Word32

-- | Data type representing an extended private key at the root of the
--   derivation tree. Master keys have depth 0 and no parents. They are
--   represented as m/ in BIP32 notation.
newtype MasterKey
MasterKey :: XPrvKey -> MasterKey
masterKey :: MasterKey -> XPrvKey

-- | Create a <a>MasterKey</a> from a seed.
makeMasterKey :: ByteString -> Maybe MasterKey

-- | Load a <a>MasterKey</a> from an <a>XPrvKey</a>. This function will
--   fail if the extended private key does not have the properties of a
--   <a>MasterKey</a>.
loadMasterKey :: XPrvKey -> Maybe MasterKey

-- | Data type representing a private account key. Account keys are
--   generated from a <a>MasterKey</a> through prime derivation. This
--   guarantees that the <a>MasterKey</a> will not be compromised if the
--   account key is compromised. <a>AccPrvKey</a> is represented as m/i'/
--   in BIP32 notation.
newtype AccPrvKey
AccPrvKey :: XPrvKey -> AccPrvKey
getAccPrvKey :: AccPrvKey -> XPrvKey

-- | Data type representing a public account key. It is computed through
--   derivation from an <a>AccPrvKey</a>. It can not be derived from the
--   <a>MasterKey</a> directly (property of prime derivation). It is
--   represented as M/i'/ in BIP32 notation. <a>AccPubKey</a> is used for
--   generating receiving payment addresses without the knowledge of the
--   <a>AccPrvKey</a>.
newtype AccPubKey
AccPubKey :: XPubKey -> AccPubKey
getAccPubKey :: AccPubKey -> XPubKey

-- | Load a private account key from an <a>XPrvKey</a>. This function will
--   fail if the extended private key does not have the properties of a
--   <a>AccPrvKey</a>.
loadPrvAcc :: XPrvKey -> Maybe AccPrvKey

-- | Load a public account key from an <a>XPubKey</a>. This function will
--   fail if the extended public key does not have the properties of a
--   <a>AccPubKey</a>.
loadPubAcc :: XPubKey -> Maybe AccPubKey

-- | Computes an <a>AccPrvKey</a> from a <a>MasterKey</a> and a derivation
--   index.
accPrvKey :: MasterKey -> KeyIndex -> Maybe AccPrvKey

-- | Computes an <a>AccPubKey</a> from a <a>MasterKey</a> and a derivation
--   index.
accPubKey :: MasterKey -> KeyIndex -> Maybe AccPubKey

-- | Cyclic list of all valid <a>AccPrvKey</a> derived from a
--   <a>MasterKey</a> and starting from an offset index.
accPrvKeys :: MasterKey -> KeyIndex -> [(AccPrvKey, KeyIndex)]

-- | Cyclic list of all valid <a>AccPubKey</a> derived from a
--   <a>MasterKey</a> and starting from an offset index.
accPubKeys :: MasterKey -> KeyIndex -> [(AccPubKey, KeyIndex)]

-- | Data type representing a private address key. Private address keys are
--   generated through a non-prime derivation from an <a>AccPrvKey</a>.
--   Non-prime derivation is used so that the public account key can
--   generate the receiving payment addresses without knowledge of the
--   private account key. <a>AccPrvKey</a> is represented as m/i'/0/j/ in
--   BIP32 notation if it is a regular receiving address. Internal (change)
--   addresses are represented as m/i'/1/j/. Non-prime subtree 0 is used
--   for regular receiving addresses and non-prime subtree 1 for internal
--   (change) addresses.
newtype AddrPrvKey
AddrPrvKey :: XPrvKey -> AddrPrvKey
getAddrPrvKey :: AddrPrvKey -> XPrvKey

-- | Data type representing a public address key. They are generated
--   through non-prime derivation from an <a>AccPubKey</a>. This is a
--   useful feature for read-only wallets. They are represented as M/i'/0/j
--   in BIP32 notation for regular receiving addresses and by M/i'/1/j for
--   internal (change) addresses.
newtype AddrPubKey
AddrPubKey :: XPubKey -> AddrPubKey
getAddrPubKey :: AddrPubKey -> XPubKey

-- | Computes an <a>Address</a> from an <a>AddrPubKey</a>.
addr :: AddrPubKey -> Address

-- | Computes an external <a>AddrPrvKey</a> from an <a>AccPrvKey</a> and a
--   derivation index.
extPrvKey :: AccPrvKey -> KeyIndex -> Maybe AddrPrvKey

-- | Computes an external <a>AddrPubKey</a> from an <a>AccPubKey</a> and a
--   derivation index.
extPubKey :: AccPubKey -> KeyIndex -> Maybe AddrPubKey

-- | Computes an internal <a>AddrPrvKey</a> from an <a>AccPrvKey</a> and a
--   derivation index.
intPrvKey :: AccPrvKey -> KeyIndex -> Maybe AddrPrvKey

-- | Computes an internal <a>AddrPubKey</a> from an <a>AccPubKey</a> and a
--   derivation index.
intPubKey :: AccPubKey -> KeyIndex -> Maybe AddrPubKey

-- | Cyclic list of all valid external <a>AddrPrvKey</a> derived from a
--   <a>AccPrvKey</a> and starting from an offset index.
extPrvKeys :: AccPrvKey -> KeyIndex -> [(AddrPrvKey, KeyIndex)]

-- | Cyclic list of all valid external <a>AddrPubKey</a> derived from a
--   <a>AccPubKey</a> and starting from an offset index.
extPubKeys :: AccPubKey -> KeyIndex -> [(AddrPubKey, KeyIndex)]

-- | Cyclic list of all internal <a>AddrPrvKey</a> derived from a
--   <a>AccPrvKey</a> and starting from an offset index.
intPrvKeys :: AccPrvKey -> KeyIndex -> [(AddrPrvKey, KeyIndex)]

-- | Cyclic list of all internal <a>AddrPubKey</a> derived from a
--   <a>AccPubKey</a> and starting from an offset index.
intPubKeys :: AccPubKey -> KeyIndex -> [(AddrPubKey, KeyIndex)]

-- | Computes an external address from an <a>AccPubKey</a> and a derivation
--   index.
extAddr :: AccPubKey -> KeyIndex -> Maybe Address

-- | Computes an internal addres from an <a>AccPubKey</a> and a derivation
--   index.
intAddr :: AccPubKey -> KeyIndex -> Maybe Address

-- | Cyclic list of all external addresses derived from a <a>AccPubKey</a>
--   and starting from an offset index.
extAddrs :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Cyclic list of all internal addresses derived from a <a>AccPubKey</a>
--   and starting from an offset index.
intAddrs :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Same as <a>extAddrs</a> with the list reversed.
extAddrs' :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Same as <a>intAddrs</a> with the list reversed.
intAddrs' :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Computes a list of external <a>AddrPubKey</a> from an
--   <a>AccPubKey</a>, a list of thirdparty multisig keys and a derivation
--   index. This is useful for computing the public keys associated with a
--   derivation index for multisig accounts.
extMulSigKey :: AccPubKey -> [XPubKey] -> KeyIndex -> Maybe [AddrPubKey]

-- | Computes a list of internal <a>AddrPubKey</a> from an
--   <a>AccPubKey</a>, a list of thirdparty multisig keys and a derivation
--   index. This is useful for computing the public keys associated with a
--   derivation index for multisig accounts.
intMulSigKey :: AccPubKey -> [XPubKey] -> KeyIndex -> Maybe [AddrPubKey]

-- | Cyclic list of all external multisignature <a>AddrPubKey</a>
--   derivations starting from an offset index.
extMulSigKeys :: AccPubKey -> [XPubKey] -> KeyIndex -> [([AddrPubKey], KeyIndex)]

-- | Cyclic list of all internal multisignature <a>AddrPubKey</a>
--   derivations starting from an offset index.
intMulSigKeys :: AccPubKey -> [XPubKey] -> KeyIndex -> [([AddrPubKey], KeyIndex)]

-- | Computes an external multisig address from an <a>AccPubKey</a>, a list
--   of thirdparty multisig keys and a derivation index.
extMulSigAddr :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> Maybe Address

-- | Computes an internal multisig address from an <a>AccPubKey</a>, a list
--   of thirdparty multisig keys and a derivation index.
intMulSigAddr :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> Maybe Address

-- | Cyclic list of all external multisig addresses derived from an
--   <a>AccPubKey</a> and a list of thirdparty multisig keys. The list
--   starts at an offset index.
extMulSigAddrs :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> [(Address, KeyIndex)]

-- | Cyclic list of all internal multisig addresses derived from an
--   <a>AccPubKey</a> and a list of thirdparty multisig keys. The list
--   starts at an offset index.
intMulSigAddrs :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> [(Address, KeyIndex)]

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | Build a bloom filter that will provide the given false positive rate
--   when the given number of elements have been inserted.
bloomCreate :: Int -> Double -> Word32 -> BloomFlags -> BloomFilter

-- | Insert arbitrary data into a bloom filter. Returns the new bloom
--   filter containing the new data.
bloomInsert :: BloomFilter -> ByteString -> BloomFilter

-- | Tests if some arbitrary data matches the filter. This can be either
--   because the data was inserted into the filter or because it is a false
--   positive.
bloomContains :: BloomFilter -> ByteString -> Bool

-- | Tests if a given bloom filter is valid.
isBloomValid :: BloomFilter -> Bool

-- | Returns True if the filter is empty (all bytes set to 0x00)
isBloomEmpty :: BloomFilter -> Bool

-- | Returns True if the filter is full (all bytes set to 0xff)
isBloomFull :: BloomFilter -> Bool

-- | Computes the height of a merkle tree.
calcTreeHeight :: Int -> Int

-- | Computes the width of a merkle tree at a specific height. The
--   transactions are at height 0.
calcTreeWidth :: Int -> Int -> Int

-- | Computes the root of a merkle tree from a list of leaf node hashes.
buildMerkleRoot :: [TxHash] -> MerkleRoot

-- | Computes the hash of a specific node in a merkle tree.
calcHash :: Int -> Int -> [TxHash] -> Word256

-- | Build a partial merkle tree.
buildPartialMerkle :: [(TxHash, Bool)] -> (FlagBits, PartialMerkleTree)

-- | Extracts the matching hashes from a partial merkle tree. This will
--   return the list of transaction hashes that have been included (set to
--   True) in a call to <a>buildPartialMerkle</a>.
extractMatches :: FlagBits -> PartialMerkleTree -> Int -> Either String (MerkleRoot, [TxHash])

module Network.Haskoin.Stratum

-- | Stratum Request data. To be placed inside JSON request.
data StratumRequest
StratumReqVersion :: !Text -> !Text -> StratumRequest
stratumReqClientVer :: StratumRequest -> !Text
stratumReqProtoVer :: StratumRequest -> !Text
StratumReqHistory :: !Address -> StratumRequest
stratumReqAddr :: StratumRequest -> !Address
StratumReqBalance :: !Address -> StratumRequest
stratumReqAddr :: StratumRequest -> !Address
StratumReqUnspent :: !Address -> StratumRequest
stratumReqAddr :: StratumRequest -> !Address
StratumReqTx :: !TxHash -> StratumRequest
stratumReqTxid :: StratumRequest -> !TxHash
StratumBcastTx :: !Tx -> StratumRequest
stratumReqTx :: StratumRequest -> !Tx
StratumSubAddr :: !Address -> StratumRequest
stratumReqAddr :: StratumRequest -> !Address
data StratumNotif
StratumNotifAddr :: !Address -> !Word256 -> StratumNotif
stratumNotifAddr :: StratumNotif -> !Address
stratumNotifAddrStatus :: StratumNotif -> !Word256

-- | Stratum Response Result data.
data StratumResult
StratumSrvVersion :: !String -> StratumResult
stratumSrvVersion :: StratumResult -> !String
StratumAddrHistory :: ![StratumTxInfo] -> StratumResult
stratumAddrHist :: StratumResult -> ![StratumTxInfo]
StratumAddrBalance :: !Word64 -> !Word64 -> StratumResult
stratumConfirmed :: StratumResult -> !Word64
stratumUnconfirmed :: StratumResult -> !Word64
StratumAddrUnspent :: ![StratumCoin] -> StratumResult
stratumCoins :: StratumResult -> ![StratumCoin]
StratumAddrStatus :: !Word256 -> StratumResult
stratumAddrStatus :: StratumResult -> !Word256
StratumTx :: !Tx -> StratumResult
stratumTx :: StratumResult -> !Tx
StratumBcastId :: !TxHash -> StratumResult
stratumTxId :: StratumResult -> !TxHash

-- | Transaction height and ID pair. Used in history responses.
data StratumTxInfo
StratumTxInfo :: !Word -> !TxHash -> StratumTxInfo

-- | Block height.
stratumTxInfoHeight :: StratumTxInfo -> !Word

-- | Transaction id.
stratumTxInfoId :: StratumTxInfo -> !TxHash

-- | Bitcoin outpoint information.
data StratumCoin
StratumCoin :: !OutPoint -> !StratumTxInfo -> !Word64 -> StratumCoin

-- | Coin data.
stratumCoinOutPoint :: StratumCoin -> !OutPoint

-- | Transaction information.
stratumCoinTxInfo :: StratumCoin -> !StratumTxInfo

-- | Output vale.
stratumCoinValue :: StratumCoin -> !Word64
instance Eq StratumRequest
instance Show StratumRequest
instance Eq StratumNotif
instance Show StratumNotif
instance Show StratumTxInfo
instance Eq StratumTxInfo
instance Show StratumCoin
instance Eq StratumCoin
instance Eq StratumResult
instance Show StratumResult
instance ToJSON StratumCoin
instance FromJSON StratumCoin
instance NFData StratumCoin
instance ToJSON StratumTxInfo
instance FromJSON StratumTxInfo
instance NFData StratumTxInfo
instance FromResponse StratumResult
instance ToJSON StratumResult
instance NFData StratumResult
instance FromNotif StratumNotif
instance ToNotif StratumNotif
instance ToJSON StratumNotif
instance NFData StratumNotif
instance FromRequest StratumRequest
instance ToRequest StratumRequest
instance ToJSON StratumRequest
instance NFData StratumRequest


-- | This package provides functions for parsing and evaluating bitcoin
--   transaction scripts. Data types are provided for building and
--   deconstructing all of the standard input and output script types.
module Network.Haskoin.Script

-- | Data type representing a transaction script. Scripts are defined as
--   lists of script operators <a>ScriptOp</a>. Scripts are used to:
--   
--   <ul>
--   <li>Define the spending conditions in the output of a transaction</li>
--   <li>Provide the spending signatures in the input of a transaction</li>
--   </ul>
data Script
Script :: ![ScriptOp] -> Script

-- | List of script operators defining this script
scriptOps :: Script -> ![ScriptOp]

-- | Data type representing all of the operators allowed inside a
--   <a>Script</a>.
data ScriptOp
OP_PUSHDATA :: !ByteString -> !PushDataType -> ScriptOp
OP_0 :: ScriptOp
OP_1NEGATE :: ScriptOp
OP_RESERVED :: ScriptOp
OP_1 :: ScriptOp
OP_2 :: ScriptOp
OP_3 :: ScriptOp
OP_4 :: ScriptOp
OP_5 :: ScriptOp
OP_6 :: ScriptOp
OP_7 :: ScriptOp
OP_8 :: ScriptOp
OP_9 :: ScriptOp
OP_10 :: ScriptOp
OP_11 :: ScriptOp
OP_12 :: ScriptOp
OP_13 :: ScriptOp
OP_14 :: ScriptOp
OP_15 :: ScriptOp
OP_16 :: ScriptOp
OP_NOP :: ScriptOp
OP_VER :: ScriptOp
OP_IF :: ScriptOp
OP_NOTIF :: ScriptOp
OP_VERIF :: ScriptOp
OP_VERNOTIF :: ScriptOp
OP_ELSE :: ScriptOp
OP_ENDIF :: ScriptOp
OP_VERIFY :: ScriptOp
OP_RETURN :: ScriptOp
OP_TOALTSTACK :: ScriptOp
OP_FROMALTSTACK :: ScriptOp
OP_IFDUP :: ScriptOp
OP_DEPTH :: ScriptOp
OP_DROP :: ScriptOp
OP_DUP :: ScriptOp
OP_NIP :: ScriptOp
OP_OVER :: ScriptOp
OP_PICK :: ScriptOp
OP_ROLL :: ScriptOp
OP_ROT :: ScriptOp
OP_SWAP :: ScriptOp
OP_TUCK :: ScriptOp
OP_2DROP :: ScriptOp
OP_2DUP :: ScriptOp
OP_3DUP :: ScriptOp
OP_2OVER :: ScriptOp
OP_2ROT :: ScriptOp
OP_2SWAP :: ScriptOp
OP_CAT :: ScriptOp
OP_SUBSTR :: ScriptOp
OP_LEFT :: ScriptOp
OP_RIGHT :: ScriptOp
OP_SIZE :: ScriptOp
OP_INVERT :: ScriptOp
OP_AND :: ScriptOp
OP_OR :: ScriptOp
OP_XOR :: ScriptOp
OP_EQUAL :: ScriptOp
OP_EQUALVERIFY :: ScriptOp
OP_RESERVED1 :: ScriptOp
OP_RESERVED2 :: ScriptOp
OP_1ADD :: ScriptOp
OP_1SUB :: ScriptOp
OP_2MUL :: ScriptOp
OP_2DIV :: ScriptOp
OP_NEGATE :: ScriptOp
OP_ABS :: ScriptOp
OP_NOT :: ScriptOp
OP_0NOTEQUAL :: ScriptOp
OP_ADD :: ScriptOp
OP_SUB :: ScriptOp
OP_MUL :: ScriptOp
OP_DIV :: ScriptOp
OP_MOD :: ScriptOp
OP_LSHIFT :: ScriptOp
OP_RSHIFT :: ScriptOp
OP_BOOLAND :: ScriptOp
OP_BOOLOR :: ScriptOp
OP_NUMEQUAL :: ScriptOp
OP_NUMEQUALVERIFY :: ScriptOp
OP_NUMNOTEQUAL :: ScriptOp
OP_LESSTHAN :: ScriptOp
OP_GREATERTHAN :: ScriptOp
OP_LESSTHANOREQUAL :: ScriptOp
OP_GREATERTHANOREQUAL :: ScriptOp
OP_MIN :: ScriptOp
OP_MAX :: ScriptOp
OP_WITHIN :: ScriptOp
OP_RIPEMD160 :: ScriptOp
OP_SHA1 :: ScriptOp
OP_SHA256 :: ScriptOp
OP_HASH160 :: ScriptOp
OP_HASH256 :: ScriptOp
OP_CODESEPARATOR :: ScriptOp
OP_CHECKSIG :: ScriptOp
OP_CHECKSIGVERIFY :: ScriptOp
OP_CHECKMULTISIG :: ScriptOp
OP_CHECKMULTISIGVERIFY :: ScriptOp
OP_NOP1 :: ScriptOp
OP_NOP2 :: ScriptOp
OP_NOP3 :: ScriptOp
OP_NOP4 :: ScriptOp
OP_NOP5 :: ScriptOp
OP_NOP6 :: ScriptOp
OP_NOP7 :: ScriptOp
OP_NOP8 :: ScriptOp
OP_NOP9 :: ScriptOp
OP_NOP10 :: ScriptOp
OP_PUBKEYHASH :: ScriptOp
OP_PUBKEY :: ScriptOp
OP_INVALIDOPCODE :: !Word8 -> ScriptOp

-- | Data type representing the type of an OP_PUSHDATA opcode.
data PushDataType

-- | The next opcode bytes is data to be pushed onto the stack
OPCODE :: PushDataType

-- | The next byte contains the number of bytes to be pushed onto the stack
OPDATA1 :: PushDataType

-- | The next two bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA2 :: PushDataType

-- | The next four bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA4 :: PushDataType

-- | Optimally encode data using one of the 4 types of data pushing opcodes
opPushData :: ByteString -> ScriptOp

-- | Data type describing standard transaction output scripts. Output
--   scripts provide the conditions that must be fulfilled for someone to
--   spend the output coins.
data ScriptOutput

-- | Pay to a public key.
PayPK :: !PubKey -> ScriptOutput
getOutputPubKey :: ScriptOutput -> !PubKey

-- | Pay to a public key hash.
PayPKHash :: !Address -> ScriptOutput
getOutputAddress :: ScriptOutput -> !Address

-- | Pay to multiple public keys.
PayMulSig :: ![PubKey] -> !Int -> ScriptOutput
getOutputMulSigKeys :: ScriptOutput -> ![PubKey]
getOutputMulSigRequired :: ScriptOutput -> !Int

-- | Pay to a script hash.
PayScriptHash :: !Address -> ScriptOutput
getOutputAddress :: ScriptOutput -> !Address

-- | Computes a <a>Script</a> from a <a>ScriptOutput</a>. The <a>Script</a>
--   is a list of <a>ScriptOp</a> can can be used to build a <tt>Tx</tt>.
encodeOutput :: ScriptOutput -> Script

-- | Similar to <a>encodeOutput</a> but encodes to a ByteString
encodeOutputBS :: ScriptOutput -> ByteString

-- | Tries to decode a <a>ScriptOutput</a> from a <a>Script</a>. This can
--   fail if the script is not recognized as any of the standard output
--   types.
decodeOutput :: Script -> Either String ScriptOutput

-- | Similar to <a>decodeOutput</a> but decodes from a ByteString
decodeOutputBS :: ByteString -> Either String ScriptOutput

-- | Returns True if the script is a pay to public key output.
isPayPK :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to public key hash output.
isPayPKHash :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to multiple public keys output.
isPayMulSig :: ScriptOutput -> Bool

-- | Returns true if the script is a pay to script hash output.
isPayScriptHash :: ScriptOutput -> Bool

-- | Computes a script address from a script output. This address can be
--   used in a pay to script hash output.
scriptAddr :: ScriptOutput -> Address

-- | Sorts the public keys of a multisignature output in ascending order by
--   comparing their serialized representations. This feature allows for
--   easier multisignature account management as participants in a
--   multisignature wallet will blindly agree on an ordering of the public
--   keys without having to communicate.
sortMulSig :: ScriptOutput -> ScriptOutput
data ScriptInput
RegularInput :: SimpleInput -> ScriptInput
getRegularInput :: ScriptInput -> SimpleInput
ScriptHashInput :: SimpleInput -> RedeemScript -> ScriptInput
getScriptHashInput :: ScriptInput -> SimpleInput
getScriptHashRedeem :: ScriptInput -> RedeemScript

-- | Data type describing standard transaction input scripts. Input scripts
--   provide the signing data required to unlock the coins of the output
--   they are trying to spend.
data SimpleInput

-- | Spend the coins of a PayPK output.
SpendPK :: !TxSignature -> SimpleInput
getInputSig :: SimpleInput -> !TxSignature

-- | Spend the coins of a PayPKHash output.
SpendPKHash :: !TxSignature -> !PubKey -> SimpleInput
getInputSig :: SimpleInput -> !TxSignature
getInputKey :: SimpleInput -> !PubKey

-- | Spend the coins of a PayMulSig output.
SpendMulSig :: ![TxSignature] -> SimpleInput
getInputMulSigKeys :: SimpleInput -> ![TxSignature]
type RedeemScript = ScriptOutput
encodeInput :: ScriptInput -> Script

-- | Similar to <a>encodeInput</a> but encodes to a ByteString
encodeInputBS :: ScriptInput -> ByteString

-- | Decodes a <a>ScriptInput</a> from a <a>Script</a>. This function fails
--   if the script can not be parsed as a standard script input.
decodeInput :: Script -> Either String ScriptInput

-- | Similar to <a>decodeInput</a> but decodes from a ByteString
decodeInputBS :: ByteString -> Either String ScriptInput

-- | Returns True if the input script is spending a public key.
isSpendPK :: ScriptInput -> Bool

-- | Returns True if the input script is spending a public key hash.
isSpendPKHash :: ScriptInput -> Bool

-- | Returns True if the input script is spending a multisignature output.
isSpendMulSig :: ScriptInput -> Bool
isScriptHashInput :: ScriptInput -> Bool

-- | Computes the recipient address of a script. This function fails if the
--   script could not be decoded as a pay to public key hash or pay to
--   script hash.
scriptRecipient :: Script -> Either String Address

-- | Computes the sender address of a script. This function fails if the
--   script could not be decoded as a spend public key hash or script hash
--   input.
scriptSender :: Script -> Either String Address

-- | Transforms integers [1 .. 16] to <a>ScriptOp</a> [OP_1 .. OP_16]
intToScriptOp :: Int -> ScriptOp

-- | Decode <a>ScriptOp</a> [OP_1 .. OP_16] to integers [1 .. 16]. This
--   functions fails for other values of <a>ScriptOp</a>
scriptOpToInt :: ScriptOp -> Either String Int

-- | Data type representing the different ways a transaction can be signed.
--   When producing a signature, a hash of the transaction is used as the
--   message to be signed. The <a>SigHash</a> parameter controls which
--   parts of the transaction are used or ignored to produce the
--   transaction hash. The idea is that if some part of a transaction is
--   not used to produce the transaction hash, then you can change that
--   part of the transaction after producing a signature without
--   invalidating that signature.
--   
--   If the anyoneCanPay flag is True, then only the current input is
--   signed. Otherwise, all of the inputs of a transaction are signed. The
--   default value for anyoneCanPay is False.
data SigHash

-- | Sign all of the outputs of a transaction (This is the default value).
--   Changing any of the outputs of the transaction will invalidate the
--   signature.
SigAll :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Sign none of the outputs of a transaction. This allows anyone to
--   change any of the outputs of the transaction.
SigNone :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Sign only the output corresponding the the current transaction input.
--   You care about your own output in the transaction but you don't care
--   about any of the other outputs.
SigSingle :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Unrecognized sighash types will decode to SigUnknown.
SigUnknown :: !Bool -> !Word8 -> SigHash
anyoneCanPay :: SigHash -> !Bool
getSigCode :: SigHash -> !Word8

-- | Computes the hash that will be used for signing a transaction.
txSigHash :: Tx -> Script -> Int -> SigHash -> Word256

-- | Encodes a <a>SigHash</a> to a 32 bit-long bytestring.
encodeSigHash32 :: SigHash -> ByteString

-- | Returns True if the <a>SigHash</a> has the value SigAll.
isSigAll :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigNone.
isSigNone :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigSingle.
isSigSingle :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigUnknown.
isSigUnknown :: SigHash -> Bool

-- | Data type representing a <a>Signature</a> together with a
--   <a>SigHash</a>. The <a>SigHash</a> is serialized as one byte at the
--   end of a regular ECDSA <a>Signature</a>. All signatures in transaction
--   inputs are of type <a>TxSignature</a>.
data TxSignature
TxSignature :: !Signature -> !SigHash -> TxSignature
txSignature :: TxSignature -> !Signature
sigHashType :: TxSignature -> !SigHash

-- | Serialize a <a>TxSignature</a> to a ByteString.
encodeSig :: TxSignature -> ByteString

-- | Decode a <a>TxSignature</a> from a ByteString.
decodeSig :: ByteString -> Either String TxSignature

-- | Decode a <a>TxSignature</a> from a ByteString. This function will
--   check if the signature is canonical and fail if it is not.
decodeCanonicalSig :: ByteString -> Either String TxSignature
evalScript :: Script -> Script -> SigCheck -> Bool

-- | Uses <a>evalScript</a> to check that the input script of a spending
--   transaction satisfies the output script.
verifySpend :: Tx -> Int -> Script -> Bool

-- | Defines the type of function required by script evaluating functions
--   to check transaction signatures.
type SigCheck = [ScriptOp] -> TxSignature -> PubKey -> Bool


-- | This package provides functions for building and signing both simple
--   transactions and multisignature transactions.
module Network.Haskoin.Transaction

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of <a>ScriptOutput</a> and amounts as outputs.
buildTx :: [OutPoint] -> [(ScriptOutput, Word64)] -> Either String Tx

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of recipients addresses and amounts as outputs.
buildAddrTx :: [OutPoint] -> [(String, Word64)] -> Either String Tx

-- | Data type used to specify the signing parameters of a transaction
--   input. To sign an input, the previous output script, outpoint and
--   sighash are required. When signing a pay to script hash output, an
--   additional redeem script is required.
data SigInput
SigInput :: !ScriptOutput -> !OutPoint -> !SigHash -> !(Maybe RedeemScript) -> SigInput

-- | Output script to spend.
sigDataOut :: SigInput -> !ScriptOutput

-- | Spending tranasction OutPoint
sigDataOP :: SigInput -> !OutPoint

-- | Signature type.
sigDataSH :: SigInput -> !SigHash

-- | Redeem script
sigDataRedeem :: SigInput -> !(Maybe RedeemScript)

-- | Sign a transaction by providing the <a>SigInput</a> signing parameters
--   and a list of private keys. The signature is computed within the
--   <a>SecretT</a> monad to generate the random signing nonce. This
--   function returns a transaction completion status. If false, some of
--   the inputs are not fully signed or are non-standard.
signTx :: Monad m => Tx -> [SigInput] -> [PrvKey] -> EitherT String (SecretT m) (Tx, Bool)

-- | Sign a single input in a transaction within the <a>SecretT</a> monad.
--   This function will return a completion status only for that input. If
--   false, that input is either non-standard or not fully signed.
signInput :: Monad m => Tx -> Int -> SigInput -> PrvKey -> EitherT String (SecretT m) (Tx, Bool)

-- | Sign a transaction by providing the <a>SigInput</a> signing paramters
--   and a list of private keys. The signature is computed
--   deterministically as defined in RFC-6979. This function returns a
--   transaction completion status. If false, some of the inputs are not
--   fully signed or are non-standard.
detSignTx :: Tx -> [SigInput] -> [PrvKey] -> Either String (Tx, Bool)

-- | Sign a single input in a transaction deterministically (RFC-6979).
--   This function will return a completion status only for that input. If
--   false, that input is either non-standard or not fully signed.
detSignInput :: Tx -> Int -> SigInput -> PrvKey -> Either String (Tx, Bool)

-- | Verify if a transaction is valid and all of its inputs are standard.
verifyStdTx :: Tx -> [(ScriptOutput, OutPoint)] -> Bool

-- | Verify if a transaction input is valid and standard.
verifyStdInput :: Tx -> Int -> ScriptOutput -> Bool

-- | A Coin is an output of a transaction that can be spent by another
--   transaction.
data Coin
Coin :: !Word64 -> !ScriptOutput -> !OutPoint -> !(Maybe RedeemScript) -> Coin

-- | Value in satoshi
coinValue :: Coin -> !Word64

-- | Output script
coinScript :: Coin -> !ScriptOutput

-- | Previous outpoint
coinOutPoint :: Coin -> !OutPoint

-- | Redeem script
coinRedeem :: Coin -> !(Maybe RedeemScript)

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account.
chooseCoins :: Word64 -> Word64 -> [Coin] -> Either String ([Coin], Word64)

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address.
chooseMSCoins :: Word64 -> Word64 -> (Int, Int) -> [Coin] -> Either String ([Coin], Word64)

-- | Computes an upper bound on the size of a transaction based on some
--   known properties of the transaction.
guessTxSize :: Int -> [(Int, Int)] -> Int -> Int -> Int


-- | This module expose haskoin internals. No guarantee is made on the
--   stability of the interface of these internal modules.
module Network.Haskoin.Internals
extendedModGCD :: Integer -> Integer -> Integer -> (Integer, Integer)
mulInverse :: Integer -> Integer -> Integer
pairG :: (Integer, Integer)
curveP :: Integer
curveN :: Integer
integerB :: Integer
integerA :: Integer
type CheckSum32 = Word32

-- | Computes SHA-512.
hash512 :: ByteString -> Word512

-- | Computes SHA-256.
hash256 :: ByteString -> Word256

-- | Computes SHA-160.
hashSha1 :: ByteString -> Word160

-- | Computes RIPEMD-160.
hash160 :: ByteString -> Word160

-- | Computes SHA-512 and returns the result as a bytestring.
hash512BS :: ByteString -> ByteString

-- | Computes SHA-256 and returns the result as a bytestring.
hash256BS :: ByteString -> ByteString

-- | Computes SHA-160 and returns the result as a bytestring.
hashSha1BS :: ByteString -> ByteString

-- | Computes RIPEMD-160 and returns the result as a bytestring.
hash160BS :: ByteString -> ByteString

-- | Computes two rounds of SHA-256.
doubleHash256 :: ByteString -> Word256

-- | Computes two rounds of SHA-256 and returns the result as a bytestring.
doubleHash256BS :: ByteString -> ByteString

-- | Computes a 32 bit checksum.
chksum32 :: ByteString -> CheckSum32

-- | Computes HMAC over SHA-512.
hmac512 :: ByteString -> ByteString -> Word512

-- | Computes HMAC over SHA-512 and return the result as a bytestring.
hmac512BS :: ByteString -> ByteString -> ByteString

-- | Computes HMAC over SHA-256.
hmac256 :: ByteString -> ByteString -> Word256

-- | Computes HMAC over SHA-256 and return the result as a bytestring.
hmac256BS :: ByteString -> ByteString -> ByteString
hmacDRBGNew :: EntropyInput -> Nonce -> PersString -> WorkingState
hmacDRBGUpd :: ProvidedData -> ByteString -> ByteString -> (ByteString, ByteString)
hmacDRBGRsd :: WorkingState -> EntropyInput -> AdditionalInput -> WorkingState
hmacDRBGGen :: WorkingState -> Word16 -> AdditionalInput -> (WorkingState, Maybe ByteString)
type WorkingState = (ByteString, ByteString, Word16)

-- | MurmurHash3 (x86_32). For more details, see
--   <a>http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp</a>
--   This code is used in the bloom filters of SPV nodes.
murmurHash3 :: Word32 -> ByteString -> Word32

-- | Split a <a>Word512</a> into a pair of <a>Word256</a>.
split512 :: Word512 -> (Word256, Word256)

-- | Join a pair of <a>Word256</a> into a <a>Word512</a>.
join512 :: (Word256, Word256) -> Word512

-- | Decode the compact number used in the difficulty target of a block
--   into an Integer.
--   
--   As described in the Satoshi reference implementation
--   <i>src</i>bignum.h:
--   
--   The <a>compact</a> format is a representation of a whole number N
--   using an unsigned 32bit number similar to a floating point format. The
--   most significant 8 bits are the unsigned exponent of base 256. This
--   exponent can be thought of as <a>number of bytes of N</a>. The lower
--   23 bits are the mantissa. Bit number 24 (0x800000) represents the sign
--   of N.
--   
--   <pre>
--   N = (-1^sign) * mantissa * 256^(exponent-3)
--   </pre>
decodeCompact :: Word32 -> Integer

-- | Encode an Integer to the compact number format used in the difficulty
--   target of a block.
encodeCompact :: Integer -> Word32

-- | Computes the hash of a transaction.
txHash :: Tx -> TxHash

-- | Computes the hash of a coinbase transaction.
cbHash :: CoinbaseTx -> TxHash

-- | Compute the hash of a block header
headerHash :: BlockHeader -> BlockHash

-- | Type representing a transaction hash.
type TxHash = BigWord Mod256Tx

-- | Type representing a block hash.
type BlockHash = BigWord Mod256Block

-- | Data type representing a 512 bit unsigned integer. It is implemented
--   as an Integer modulo 2^512.
type Word512 = BigWord Mod512

-- | Data type representing a 256 bit unsigned integer. It is implemented
--   as an Integer modulo 2^256.
type Word256 = BigWord Mod256

-- | Data type representing a 160 bit unsigned integer. It is implemented
--   as an Integer modulo 2^160.
type Word160 = BigWord Mod160

-- | Data type representing a 128 bit unsigned integer. It is implemented
--   as an Integer modulo 2^128.
type Word128 = BigWord Mod128

-- | Data type representing an Integer modulo coordinate field order P.
type FieldP = BigWord ModP

-- | Data type representing an Integer modulo curve order N.
type FieldN = BigWord ModN
newtype BigWord n
BigWord :: Integer -> BigWord n
getBigWordInteger :: BigWord n -> Integer
class BigWordMod a
rFromInteger :: BigWordMod a => Integer -> BigWord a
rBitSize :: BigWordMod a => BigWord a -> Int
inverseP :: FieldP -> FieldP
inverseN :: FieldN -> FieldN
quadraticResidue :: FieldP -> [FieldP]
isIntegerValidKey :: Integer -> Bool

-- | Encodes a <a>TxHash</a> as little endian in HEX format. This is mostly
--   used for displaying transaction ids. Internally, these ids are handled
--   as big endian but are transformed to little endian when displaying
--   them.
encodeTxHashLE :: TxHash -> String

-- | Decodes a little endian <a>TxHash</a> in HEX format.
decodeTxHashLE :: String -> Maybe TxHash

-- | Encodes a <a>BlockHash</a> as little endian in HEX format. This is
--   mostly used for displaying Block hash ids. Internally, these ids are
--   handled as big endian but are transformed to little endian when
--   displaying them.
encodeBlockHashLE :: BlockHash -> String

-- | Decodes a little endian <a>BlockHash</a> in HEX format.
decodeBlockHashLE :: String -> Maybe BlockHash

-- | Elliptic curves of the form y^2 = x^3 + 7 (mod p) Point on the
--   elliptic curve in transformed Jacobian coordinates (X,Y,Z) such that
--   (x,y) = (X<i>Z^2, Y</i>Z^3) InfPoint is the point at infinity
data Point
InfPoint :: Point
makePoint :: FieldP -> FieldP -> Maybe Point
makeInfPoint :: Point
getAffine :: Point -> Maybe (FieldP, FieldP)
getX :: Point -> Maybe FieldP
getY :: Point -> Maybe FieldP
validatePoint :: Point -> Bool
isInfPoint :: Point -> Bool
addPoint :: Point -> Point -> Point
doublePoint :: Point -> Point
mulPoint :: FieldN -> Point -> Point
shamirsTrick :: FieldN -> Point -> FieldN -> Point -> Point
curveB :: FieldP
curveA :: FieldP

-- | Data type representing a Bitcoin address
data Address

-- | Public Key Hash Address
PubKeyAddress :: Word160 -> Address
getAddrHash :: Address -> Word160

-- | Script Hash Address
ScriptAddress :: Word160 -> Address
getAddrHash :: Address -> Word160

-- | Transforms an Address into a base58 encoded String
addrToBase58 :: Address -> String

-- | Decodes an Address from a base58 encoded String. This function can
--   fail if the String is not properly encoded as base58 or the checksum
--   fails.
base58ToAddr :: String -> Maybe Address

-- | Encode a bytestring to a base 58 representation.
encodeBase58 :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring. This can fail if the input
--   bytestring contains invalid base 58 characters such as 0,O,l,I
decodeBase58 :: ByteString -> Maybe ByteString

-- | Computes a checksum for the input bytestring and encodes the input and
--   the checksum to a base 58 representation.
encodeBase58Check :: ByteString -> ByteString

-- | Decode a base 58 encoded bytestring that contains a checksum. This
--   function returns Nothing if the input bytestring contains invalid base
--   58 characters or if the checksum fails.
decodeBase58Check :: ByteString -> Maybe ByteString

-- | Elliptic curve public key type. Two constructors are provided for
--   creating compressed and uncompressed public keys from a Point. The use
--   of compressed keys is preferred as it produces shorter keys without
--   compromising security. Uncompressed keys are supported for backwards
--   compatibility.
data PubKey

-- | Compressed public key
PubKey :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Uncompressed public key
PubKeyU :: !Point -> PubKey
pubKeyPoint :: PubKey -> !Point

-- | Returns True if the public key is valid. This will check if the public
--   key point lies on the curve.
isValidPubKey :: PubKey -> Bool

-- | Returns True if the public key is uncompressed
isPubKeyU :: PubKey -> Bool

-- | Derives a public key from a private key. This function will preserve
--   information on key compression (PrvKey becomes PubKey and PrvKeyU
--   becomes PubKeyU)
derivePubKey :: PrvKey -> PubKey

-- | Computes an Address value from a public key
pubKeyAddr :: PubKey -> Address

-- | Elliptic curve private key type. Two constructors are provided for
--   creating compressed or uncompressed private keys. Compression
--   information is stored in private key WIF formats and needs to be
--   preserved to generate the correct addresses from the corresponding
--   public key.
data PrvKey

-- | Compressed private key
PrvKey :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Uncompressed private key
PrvKeyU :: !FieldN -> PrvKey
prvKeyFieldN :: PrvKey -> !FieldN

-- | Returns True if the private key is valid. This will check if the
--   integer value representing the private key is greater than 0 and
--   smaller than the curve order N.
isValidPrvKey :: Integer -> Bool

-- | Builds a compressed private key from an Integer value. Returns Nothing
--   if the Integer would not produce a valid private key. For security,
--   the Integer needs to be generated from a random source with sufficient
--   entropy.
makePrvKey :: Integer -> Maybe PrvKey

-- | Builds an uncompressed private key from an Integer value. Returns
--   Nothing if the Integer would not produce a valid private key. For
--   security, the Integer needs to be generated from a random source with
--   sufficient entropy.
makePrvKeyU :: Integer -> Maybe PrvKey

-- | Returns the Integer value of a private key
fromPrvKey :: PrvKey -> Integer

-- | Returns True of the private key is uncompressed
isPrvKeyU :: PrvKey -> Bool

-- | Serialize a private key into the Data.Binary.Put monad as a 32 byte
--   big endian ByteString. This is useful when a constant length
--   serialization format for private keys is required
putPrvKey :: PrvKey -> Put

-- | Deserializes a compressed private key from the Data.Binary.Get monad
--   as a 32 byte big endian ByteString.
getPrvKey :: Get PrvKey

-- | Deserializes an uncompressed private key from the Data.Binary.Get
--   monad as a 32 byte big endian ByteString
getPrvKeyU :: Get PrvKey

-- | Decodes a private key from a WIF encoded String. This function can
--   fail if the input string does not decode correctly as a base 58 string
--   or if the checksum fails.
--   <a>http://en.bitcoin.it/wiki/Wallet_import_format</a>
fromWIF :: String -> Maybe PrvKey

-- | Encodes a private key into WIF format
toWIF :: PrvKey -> String

-- | G parameter of the EC curve expressed as a Point
curveG :: Point

-- | Data type representing an extended BIP32 public key.
data XPubKey
XPubKey :: !Word8 -> !Word32 -> !Word32 -> !ChainCode -> !PubKey -> XPubKey

-- | Depth in the tree of key derivations.
xPubDepth :: XPubKey -> !Word8

-- | Fingerprint of the parent key.
xPubParent :: XPubKey -> !Word32

-- | Key derivation index.
xPubIndex :: XPubKey -> !Word32

-- | Chain code.
xPubChain :: XPubKey -> !ChainCode

-- | The public key of this extended key node.
xPubKey :: XPubKey -> !PubKey

-- | Data type representing an extended BIP32 private key. An extended key
--   is a node in a tree of key derivations. It has a depth in the tree, a
--   parent node and an index to differentiate it from other siblings.
data XPrvKey
XPrvKey :: !Word8 -> !Word32 -> !Word32 -> !ChainCode -> !PrvKey -> XPrvKey

-- | Depth in the tree of key derivations.
xPrvDepth :: XPrvKey -> !Word8

-- | Fingerprint of the parent key.
xPrvParent :: XPrvKey -> !Word32

-- | Key derivation index.
xPrvIndex :: XPrvKey -> !Word32

-- | Chain code.
xPrvChain :: XPrvKey -> !ChainCode

-- | The private key of this extended key node.
xPrvKey :: XPrvKey -> !PrvKey
type ChainCode = Word256

-- | Build a BIP32 compatible extended private key from a bytestring. This
--   will produce a root node (depth=0 and parent=0).
makeXPrvKey :: ByteString -> Maybe XPrvKey

-- | Derive an extended public key from an extended private key. This
--   function will preserve the depth, parent, index and chaincode fields
--   of the extended private keys.
deriveXPubKey :: XPrvKey -> XPubKey

-- | Compute a private, non-prime child key derivation. A private non-prime
--   derivation will allow the equivalent extended public key to derive the
--   public key for this child. Given a parent key <i>m</i> and a
--   derivation index <i>i</i>, this function will compute m/i/.
--   
--   Non-prime derivations allow for more flexibility such as read-only
--   wallets. However, care must be taken not the leak both the parent
--   extended public key and one of the extended child private keys as this
--   would compromise the extended parent private key.
prvSubKey :: XPrvKey -> Word32 -> Maybe XPrvKey

-- | Compute a public, non-prime child key derivation. Given a parent key
--   <i>M</i> and a derivation index <i>i</i>, this function will compute
--   M/i/.
pubSubKey :: XPubKey -> Word32 -> Maybe XPubKey

-- | Compute a prime child key derivation. Prime derivations can only be
--   computed for private keys. Prime derivations do not allow the parent
--   public key to derive the child public keys. However, they are safer as
--   a breach of the parent public key and child private keys does not lead
--   to a breach of the parent private key. Given a parent key <i>m</i> and
--   a derivation index <i>i</i>, this function will compute m/i'/.
primeSubKey :: XPrvKey -> Word32 -> Maybe XPrvKey

-- | Cyclic list of all private non-prime child key derivations of a parent
--   key starting from an offset index.
prvSubKeys :: XPrvKey -> Word32 -> [(XPrvKey, Word32)]

-- | Cyclic list of all public non-prime child key derivations of a parent
--   key starting from an offset index.
pubSubKeys :: XPubKey -> Word32 -> [(XPubKey, Word32)]

-- | Cyclic list of all prime child key derivations of a parent key
--   starting from an offset index.
primeSubKeys :: XPrvKey -> Word32 -> [(XPrvKey, Word32)]

-- | Compute a public, non-prime subkey derivation for all of the parent
--   public keys in the input. This function will succeed only if the child
--   key derivations for all the parent keys are valid.
--   
--   This function is intended to be used in the context of multisignature
--   accounts. Parties exchanging their master public keys to create a
--   multisignature account can then individually generate all the
--   receiving multisignature addresses without further communication.
mulSigSubKey :: [XPubKey] -> Word32 -> Maybe [XPubKey]

-- | Cyclic list of all public, non-prime multisig key derivations of a
--   list of parent keys starting from an offset index.
mulSigSubKeys :: [XPubKey] -> Word32 -> [([XPubKey], Word32)]

-- | Returns True if the extended private key was derived through a prime
--   derivation.
xPrvIsPrime :: XPrvKey -> Bool

-- | Returns True if the extended public key was derived through a prime
--   derivation.
xPubIsPrime :: XPubKey -> Bool

-- | Returns the derivation index of this extended private key without the
--   prime bit set.
xPrvChild :: XPrvKey -> Word32

-- | Returns the derivation index of this extended public key without the
--   prime bit set.
xPubChild :: XPubKey -> Word32

-- | Computes the key identifier of an extended public key.
xPubID :: XPubKey -> Word160

-- | Computes the key identifier of an extended private key.
xPrvID :: XPrvKey -> Word160

-- | Computes the key fingerprint of an extended public key.
xPubFP :: XPubKey -> Word32

-- | Computes the key fingerprint of an extended private key.
xPrvFP :: XPrvKey -> Word32

-- | Computer the <a>Address</a> of an extended public key.
xPubAddr :: XPubKey -> Address

-- | Exports an extended public key to the BIP32 key export format (base
--   58).
xPubExport :: XPubKey -> String

-- | Exports an extended private key to the BIP32 key export format (base
--   58).
xPrvExport :: XPrvKey -> String

-- | Decodes a BIP32 encoded extended public key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPubImport :: String -> Maybe XPubKey

-- | Decodes a BIP32 encoded extended private key. This function will fail
--   if invalid base 58 characters are detected or if the checksum fails.
xPrvImport :: String -> Maybe XPrvKey

-- | Export an extended private key to WIF (Wallet Import Format).
xPrvWIF :: XPrvKey -> String
cycleIndex :: Word32 -> [Word32]
cycleIndex' :: Word32 -> [Word32]
addPubKeys :: PubKey -> Word256 -> Maybe PubKey
addPrvKeys :: PrvKey -> Word256 -> Maybe PrvKey

-- | Data type representing an extended private key at the root of the
--   derivation tree. Master keys have depth 0 and no parents. They are
--   represented as m/ in BIP32 notation.
newtype MasterKey
MasterKey :: XPrvKey -> MasterKey
masterKey :: MasterKey -> XPrvKey

-- | Data type representing a private account key. Account keys are
--   generated from a <a>MasterKey</a> through prime derivation. This
--   guarantees that the <a>MasterKey</a> will not be compromised if the
--   account key is compromised. <a>AccPrvKey</a> is represented as m/i'/
--   in BIP32 notation.
newtype AccPrvKey
AccPrvKey :: XPrvKey -> AccPrvKey
getAccPrvKey :: AccPrvKey -> XPrvKey

-- | Data type representing a public account key. It is computed through
--   derivation from an <a>AccPrvKey</a>. It can not be derived from the
--   <a>MasterKey</a> directly (property of prime derivation). It is
--   represented as M/i'/ in BIP32 notation. <a>AccPubKey</a> is used for
--   generating receiving payment addresses without the knowledge of the
--   <a>AccPrvKey</a>.
newtype AccPubKey
AccPubKey :: XPubKey -> AccPubKey
getAccPubKey :: AccPubKey -> XPubKey

-- | Data type representing a private address key. Private address keys are
--   generated through a non-prime derivation from an <a>AccPrvKey</a>.
--   Non-prime derivation is used so that the public account key can
--   generate the receiving payment addresses without knowledge of the
--   private account key. <a>AccPrvKey</a> is represented as m/i'/0/j/ in
--   BIP32 notation if it is a regular receiving address. Internal (change)
--   addresses are represented as m/i'/1/j/. Non-prime subtree 0 is used
--   for regular receiving addresses and non-prime subtree 1 for internal
--   (change) addresses.
newtype AddrPrvKey
AddrPrvKey :: XPrvKey -> AddrPrvKey
getAddrPrvKey :: AddrPrvKey -> XPrvKey

-- | Data type representing a public address key. They are generated
--   through non-prime derivation from an <a>AccPubKey</a>. This is a
--   useful feature for read-only wallets. They are represented as M/i'/0/j
--   in BIP32 notation for regular receiving addresses and by M/i'/1/j for
--   internal (change) addresses.
newtype AddrPubKey
AddrPubKey :: XPubKey -> AddrPubKey
getAddrPubKey :: AddrPubKey -> XPubKey
type KeyIndex = Word32

-- | Create a <a>MasterKey</a> from a seed.
makeMasterKey :: ByteString -> Maybe MasterKey

-- | Load a <a>MasterKey</a> from an <a>XPrvKey</a>. This function will
--   fail if the extended private key does not have the properties of a
--   <a>MasterKey</a>.
loadMasterKey :: XPrvKey -> Maybe MasterKey

-- | Load a private account key from an <a>XPrvKey</a>. This function will
--   fail if the extended private key does not have the properties of a
--   <a>AccPrvKey</a>.
loadPrvAcc :: XPrvKey -> Maybe AccPrvKey

-- | Load a public account key from an <a>XPubKey</a>. This function will
--   fail if the extended public key does not have the properties of a
--   <a>AccPubKey</a>.
loadPubAcc :: XPubKey -> Maybe AccPubKey

-- | Computes an <a>Address</a> from an <a>AddrPubKey</a>.
addr :: AddrPubKey -> Address

-- | Computes an <a>AccPrvKey</a> from a <a>MasterKey</a> and a derivation
--   index.
accPrvKey :: MasterKey -> KeyIndex -> Maybe AccPrvKey

-- | Computes an <a>AccPubKey</a> from a <a>MasterKey</a> and a derivation
--   index.
accPubKey :: MasterKey -> KeyIndex -> Maybe AccPubKey

-- | Computes an external <a>AddrPrvKey</a> from an <a>AccPrvKey</a> and a
--   derivation index.
extPrvKey :: AccPrvKey -> KeyIndex -> Maybe AddrPrvKey

-- | Computes an external <a>AddrPubKey</a> from an <a>AccPubKey</a> and a
--   derivation index.
extPubKey :: AccPubKey -> KeyIndex -> Maybe AddrPubKey

-- | Computes an internal <a>AddrPrvKey</a> from an <a>AccPrvKey</a> and a
--   derivation index.
intPrvKey :: AccPrvKey -> KeyIndex -> Maybe AddrPrvKey

-- | Computes an internal <a>AddrPubKey</a> from an <a>AccPubKey</a> and a
--   derivation index.
intPubKey :: AccPubKey -> KeyIndex -> Maybe AddrPubKey

-- | Cyclic list of all valid <a>AccPrvKey</a> derived from a
--   <a>MasterKey</a> and starting from an offset index.
accPrvKeys :: MasterKey -> KeyIndex -> [(AccPrvKey, KeyIndex)]

-- | Cyclic list of all valid <a>AccPubKey</a> derived from a
--   <a>MasterKey</a> and starting from an offset index.
accPubKeys :: MasterKey -> KeyIndex -> [(AccPubKey, KeyIndex)]

-- | Cyclic list of all valid external <a>AddrPrvKey</a> derived from a
--   <a>AccPrvKey</a> and starting from an offset index.
extPrvKeys :: AccPrvKey -> KeyIndex -> [(AddrPrvKey, KeyIndex)]

-- | Cyclic list of all valid external <a>AddrPubKey</a> derived from a
--   <a>AccPubKey</a> and starting from an offset index.
extPubKeys :: AccPubKey -> KeyIndex -> [(AddrPubKey, KeyIndex)]

-- | Cyclic list of all internal <a>AddrPrvKey</a> derived from a
--   <a>AccPrvKey</a> and starting from an offset index.
intPrvKeys :: AccPrvKey -> KeyIndex -> [(AddrPrvKey, KeyIndex)]

-- | Cyclic list of all internal <a>AddrPubKey</a> derived from a
--   <a>AccPubKey</a> and starting from an offset index.
intPubKeys :: AccPubKey -> KeyIndex -> [(AddrPubKey, KeyIndex)]

-- | Computes an external address from an <a>AccPubKey</a> and a derivation
--   index.
extAddr :: AccPubKey -> KeyIndex -> Maybe Address

-- | Computes an internal addres from an <a>AccPubKey</a> and a derivation
--   index.
intAddr :: AccPubKey -> KeyIndex -> Maybe Address

-- | Cyclic list of all external addresses derived from a <a>AccPubKey</a>
--   and starting from an offset index.
extAddrs :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Cyclic list of all internal addresses derived from a <a>AccPubKey</a>
--   and starting from an offset index.
intAddrs :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Same as <a>extAddrs</a> with the list reversed.
extAddrs' :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Same as <a>intAddrs</a> with the list reversed.
intAddrs' :: AccPubKey -> KeyIndex -> [(Address, KeyIndex)]

-- | Computes a list of external <a>AddrPubKey</a> from an
--   <a>AccPubKey</a>, a list of thirdparty multisig keys and a derivation
--   index. This is useful for computing the public keys associated with a
--   derivation index for multisig accounts.
extMulSigKey :: AccPubKey -> [XPubKey] -> KeyIndex -> Maybe [AddrPubKey]

-- | Computes a list of internal <a>AddrPubKey</a> from an
--   <a>AccPubKey</a>, a list of thirdparty multisig keys and a derivation
--   index. This is useful for computing the public keys associated with a
--   derivation index for multisig accounts.
intMulSigKey :: AccPubKey -> [XPubKey] -> KeyIndex -> Maybe [AddrPubKey]

-- | Cyclic list of all external multisignature <a>AddrPubKey</a>
--   derivations starting from an offset index.
extMulSigKeys :: AccPubKey -> [XPubKey] -> KeyIndex -> [([AddrPubKey], KeyIndex)]

-- | Cyclic list of all internal multisignature <a>AddrPubKey</a>
--   derivations starting from an offset index.
intMulSigKeys :: AccPubKey -> [XPubKey] -> KeyIndex -> [([AddrPubKey], KeyIndex)]

-- | Computes an external multisig address from an <a>AccPubKey</a>, a list
--   of thirdparty multisig keys and a derivation index.
extMulSigAddr :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> Maybe Address

-- | Computes an internal multisig address from an <a>AccPubKey</a>, a list
--   of thirdparty multisig keys and a derivation index.
intMulSigAddr :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> Maybe Address

-- | Cyclic list of all external multisig addresses derived from an
--   <a>AccPubKey</a> and a list of thirdparty multisig keys. The list
--   starts at an offset index.
extMulSigAddrs :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> [(Address, KeyIndex)]

-- | Cyclic list of all internal multisig addresses derived from an
--   <a>AccPubKey</a> and a list of thirdparty multisig keys. The list
--   starts at an offset index.
intMulSigAddrs :: AccPubKey -> [XPubKey] -> Int -> KeyIndex -> [(Address, KeyIndex)]

-- | StateT monad stack tracking the internal state of HMAC DRBG pseudo
--   random number generator using SHA-256. The <a>SecretT</a> monad is run
--   with the <a>withSource</a> function by providing it a source of
--   entropy.
type SecretT m = StateT (SecretState m) m

-- | Data type representing an ECDSA signature.
data Signature
Signature :: !FieldN -> !FieldN -> Signature
sigR :: Signature -> !FieldN
sigS :: Signature -> !FieldN

-- | Run a <a>SecretT</a> monad by providing it a source of entropy. You
--   can use <a>devURandom</a>, <a>devRandom</a> or provide your own
--   entropy source function.
withSource :: Monad m => (Int -> m ByteString) -> SecretT m a -> m a

-- | /dev/urandom entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devURandom :: Int -> IO ByteString

-- | /dev/random entropy source. This is only available on machines
--   supporting it. This function is meant to be used together with
--   <a>withSource</a>.
devRandom :: Int -> IO ByteString

-- | Safely sign a message inside the <a>SecretT</a> monad. The
--   <a>SecretT</a> monad will generate a new nonce for each signature.
signMsg :: Monad m => Word256 -> PrvKey -> SecretT m Signature

-- | Sign a message using ECDSA deterministic signatures as defined by RFC
--   6979 <a>http://tools.ietf.org/html/rfc6979</a>
detSignMsg :: Word256 -> PrvKey -> Signature
unsafeSignMsg :: Word256 -> FieldN -> (FieldN, Point) -> Maybe Signature

-- | Verify an ECDSA signature
verifySig :: Word256 -> Signature -> PubKey -> Bool

-- | Produce a new <a>PrvKey</a> randomly from the <a>SecretT</a> monad.
genPrvKey :: Monad m => SecretT m PrvKey

-- | Returns True if the S component of a Signature is &lt;= order/2.
--   Signatures need to pass this test to be canonical.
isCanonicalHalfOrder :: Signature -> Bool
type Entropy = ByteString
type Mnemonic = String
type Passphrase = String
type Seed = ByteString

-- | Provide intial entropy as a <a>ByteString</a> of length multiple of 4
--   bytes. Output a mnemonic sentence.
toMnemonic :: Entropy -> Either String Mnemonic

-- | Revert <a>toMnemonic</a>. Do not use this to generate seeds. Instead
--   use <a>mnemonicToSeed</a>. This outputs the original entropy used to
--   generate a mnemonic.
fromMnemonic :: Mnemonic -> Either String Entropy

-- | Get a 512-bit seed from a mnemonic sentence. Will calculate checksum.
--   Passphrase can be used to protect the mnemonic. Use an empty string as
--   passphrase if none is required.
mnemonicToSeed :: Passphrase -> Mnemonic -> Either String Seed

-- | Obtain <a>Int</a> bits from beginning of <a>ByteString</a>. Resulting
--   <a>ByteString</a> will be smallest required to hold that many bits,
--   padded with zeroes to the right.
getBits :: Int -> ByteString -> ByteString

-- | Computes the height of a merkle tree.
calcTreeHeight :: Int -> Int

-- | Computes the width of a merkle tree at a specific height. The
--   transactions are at height 0.
calcTreeWidth :: Int -> Int -> Int

-- | Computes the root of a merkle tree from a list of leaf node hashes.
buildMerkleRoot :: [TxHash] -> MerkleRoot

-- | Computes the hash of a specific node in a merkle tree.
calcHash :: Int -> Int -> [TxHash] -> Word256

-- | Build a partial merkle tree.
buildPartialMerkle :: [(TxHash, Bool)] -> (FlagBits, PartialMerkleTree)

-- | Extracts the matching hashes from a partial merkle tree. This will
--   return the list of transaction hashes that have been included (set to
--   True) in a call to <a>buildPartialMerkle</a>.
extractMatches :: FlagBits -> PartialMerkleTree -> Int -> Either String (MerkleRoot, [TxHash])

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter
BloomFilter :: !(Seq Word8) -> !Word32 -> !Word32 -> !BloomFlags -> BloomFilter

-- | Bloom filter data
bloomData :: BloomFilter -> !(Seq Word8)

-- | Number of hash functions for this filter
bloomHashFuncs :: BloomFilter -> !Word32

-- | Hash function random nonce
bloomTweak :: BloomFilter -> !Word32

-- | Bloom filter auto-update flags
bloomFlags :: BloomFilter -> !BloomFlags

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | Build a bloom filter that will provide the given false positive rate
--   when the given number of elements have been inserted.
bloomCreate :: Int -> Double -> Word32 -> BloomFlags -> BloomFilter

-- | Insert arbitrary data into a bloom filter. Returns the new bloom
--   filter containing the new data.
bloomInsert :: BloomFilter -> ByteString -> BloomFilter

-- | Tests if some arbitrary data matches the filter. This can be either
--   because the data was inserted into the filter or because it is a false
--   positive.
bloomContains :: BloomFilter -> ByteString -> Bool

-- | Tests if a given bloom filter is valid.
isBloomValid :: BloomFilter -> Bool

-- | Returns True if the filter is empty (all bytes set to 0x00)
isBloomEmpty :: BloomFilter -> Bool

-- | Returns True if the filter is full (all bytes set to 0xff)
isBloomFull :: BloomFilter -> Bool

-- | The <a>Message</a> type is used to identify all the valid messages
--   that can be sent between bitcoin peers. Only values of type
--   <a>Message</a> will be accepted by other bitcoin peers as bitcoin
--   protocol messages need to be correctly serialized with message
--   headers. Serializing a <a>Message</a> value will include the
--   <a>MessageHeader</a> with the correct checksum value automatically. No
--   need to add the <a>MessageHeader</a> separately.
data Message
MVersion :: !Version -> Message
MVerAck :: Message
MAddr :: !Addr -> Message
MInv :: !Inv -> Message
MGetData :: !GetData -> Message
MNotFound :: !NotFound -> Message
MGetBlocks :: !GetBlocks -> Message
MGetHeaders :: !GetHeaders -> Message
MTx :: !Tx -> Message
MBlock :: !Block -> Message
MMerkleBlock :: !MerkleBlock -> Message
MHeaders :: !Headers -> Message
MGetAddr :: Message
MFilterLoad :: !FilterLoad -> Message
MFilterAdd :: !FilterAdd -> Message
MFilterClear :: Message
MPing :: !Ping -> Message
MPong :: !Pong -> Message
MAlert :: !Alert -> Message
MReject :: Reject -> Message

-- | Data type representing the header of a <a>Message</a>. All messages
--   sent between nodes contain a message header.
data MessageHeader
MessageHeader :: !Word32 -> !MessageCommand -> !Word32 -> !CheckSum32 -> MessageHeader

-- | Network magic bytes. It is used to differentiate messages meant for
--   different bitcoin networks, such as prodnet and testnet.
headMagic :: MessageHeader -> !Word32

-- | Message command identifying the type of message. included in the
--   payload.
headCmd :: MessageHeader -> !MessageCommand

-- | Byte length of the payload.
headPayloadSize :: MessageHeader -> !Word32

-- | Checksum of the payload.
headChecksum :: MessageHeader -> !CheckSum32

-- | Provides information on known nodes in the bitcoin network. An
--   <a>Addr</a> type is sent inside a <tt>Message</tt> as a response to a
--   <tt>GetAddr</tt> message.
data Addr
Addr :: ![NetworkAddressTime] -> Addr
addrList :: Addr -> ![NetworkAddressTime]

-- | Network address with a timestamp
type NetworkAddressTime = (Word32, NetworkAddress)

-- | Data type describing signed messages that can be sent between bitcoin
--   nodes to display important notifications to end users about the health
--   of the network.
data Alert
Alert :: !VarString -> !VarString -> Alert

-- | Alert payload.
alertPayload :: Alert -> !VarString

-- | ECDSA signature of the payload
alertSignature :: Alert -> !VarString

-- | Data type describing a block in the bitcoin protocol. Blocks are sent
--   in response to <a>GetData</a> messages that are requesting information
--   from a block hash.
data Block
Block :: !BlockHeader -> !CoinbaseTx -> ![Tx] -> Block

-- | Header information for this block.
blockHeader :: Block -> !BlockHeader

-- | Coinbase transaction of this block.
blockCoinbaseTx :: Block -> !CoinbaseTx

-- | List of transactions pertaining to this block.
blockTxns :: Block -> ![Tx]

-- | Data type recording information on a <a>Block</a>. The hash of a block
--   is defined as the hash of this data structure. The block mining
--   process involves finding a partial hash collision by varying the nonce
--   in the <a>BlockHeader</a> and/or additional randomness in the
--   <a>CoinbaseTx</a> of this <a>Block</a>. Variations in the
--   <a>CoinbaseTx</a> will result in different merkle roots in the
--   <a>BlockHeader</a>.
data BlockHeader
BlockHeader :: !Word32 -> !BlockHash -> !Word256 -> !Word32 -> !Word32 -> !Word32 -> BlockHeader

-- | Block version information, based on the version of the software
--   creating this block.
blockVersion :: BlockHeader -> !Word32

-- | Hash of the previous block (parent) referenced by this block.
prevBlock :: BlockHeader -> !BlockHash

-- | Root of the merkle tree of all transactions pertaining to this block.
merkleRoot :: BlockHeader -> !Word256

-- | Unix timestamp recording when this block was created
blockTimestamp :: BlockHeader -> !Word32

-- | The difficulty target being used for this block
blockBits :: BlockHeader -> !Word32

-- | A random nonce used to generate this block. Additional randomness is
--   included in the coinbase transaction of this block.
bhNonce :: BlockHeader -> !Word32

-- | The bloom flags are used to tell the remote peer how to auto-update
--   the provided bloom filter.
data BloomFlags

-- | Never update
BloomUpdateNone :: BloomFlags

-- | Auto-update on all outputs
BloomUpdateAll :: BloomFlags

-- | Only auto-update on outputs that are pay-to-pubkey or pay-to-multisig.
--   This is the default setting.
BloomUpdateP2PubKeyOnly :: BloomFlags

-- | A bloom filter is a probabilistic data structure that SPV clients send
--   to other peers to filter the set of transactions received from them.
--   Bloom filters are probabilistic and have a false positive rate. Some
--   transactions that pass the filter may not be relevant to the receiving
--   peer. By controlling the false positive rate, SPV nodes can trade off
--   bandwidth versus privacy.
data BloomFilter
BloomFilter :: !(Seq Word8) -> !Word32 -> !Word32 -> !BloomFlags -> BloomFilter

-- | Bloom filter data
bloomData :: BloomFilter -> !(Seq Word8)

-- | Number of hash functions for this filter
bloomHashFuncs :: BloomFilter -> !Word32

-- | Hash function random nonce
bloomTweak :: BloomFilter -> !Word32

-- | Bloom filter auto-update flags
bloomFlags :: BloomFilter -> !BloomFlags

-- | Set a new bloom filter on the peer connection.
newtype FilterLoad
FilterLoad :: BloomFilter -> FilterLoad
getBloomFilter :: FilterLoad -> BloomFilter

-- | Add the given data element to the connections current filter without
--   requiring a completely new one to be set.
newtype FilterAdd
FilterAdd :: ByteString -> FilterAdd
getFilterData :: FilterAdd -> ByteString

-- | Data type representing a GetBlocks message request. It is used in the
--   bitcoin protocol to retrieve blocks from a peer by providing it a
--   <a>BlockLocator</a> object. The <a>BlockLocator</a> is a sparse list
--   of block hashes from the caller node with the purpose of informing the
--   receiving node about the state of the caller's blockchain. The
--   receiver node will detect a wrong branch in the caller's main chain
--   and send the caller appropriate <tt>Blocks</tt>. The response to a
--   <a>GetBlocks</a> message is an <a>Inv</a> message containing the list
--   of block hashes pertaining to the request.
data GetBlocks
GetBlocks :: !Word32 -> !BlockLocator -> !BlockHash -> GetBlocks

-- | The protocol version
getBlocksVersion :: GetBlocks -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the genesis block. The list is dense at first and
--   sparse towards the end.
getBlocksLocator :: GetBlocks -> !BlockLocator

-- | Hash of the last desired block. If set to zero, the maximum number of
--   block hashes is returned (500).
getBlocksHashStop :: GetBlocks -> !BlockHash
type BlockLocator = [BlockHash]

-- | The <a>GetData</a> type is used to retrieve information on a specific
--   object (<a>Block</a> or <a>Tx</a>) identified by the objects hash. The
--   payload of a <a>GetData</a> request is a list of <a>InvVector</a>
--   which represent all the hashes for which a node wants to request
--   information. The response to a <tt>GetBlock</tt> message wille be
--   either a <a>Block</a> or a <a>Tx</a> message depending on the type of
--   the object referenced by the hash. Usually, <a>GetData</a> messages
--   are sent after a node receives an <a>Inv</a> message to obtain
--   information on unknown object hashes.
data GetData
GetData :: ![InvVector] -> GetData

-- | List of object hashes
getDataList :: GetData -> ![InvVector]

-- | Similar to the <a>GetBlocks</a> message type but for retrieving block
--   headers only. The response to a <a>GetHeaders</a> request is a
--   <a>Headers</a> message containing a list of block headers pertaining
--   to the request. A maximum of 2000 block headers can be returned.
--   <a>GetHeaders</a> is used by thin (SPV) clients to exclude block
--   contents when synchronizing the blockchain.
data GetHeaders
GetHeaders :: !Word32 -> !BlockLocator -> !BlockHash -> GetHeaders

-- | The protocol version
getHeadersVersion :: GetHeaders -> !Word32

-- | Block locator object. It is a list of block hashes from the most
--   recent block back to the Genesis block. The list is dense at first and
--   sparse towards the end.
getHeadersBL :: GetHeaders -> !BlockLocator

-- | Hash of the last desired block header. When set to zero, the maximum
--   number of block headers is returned (2000)
getHeadersHashStop :: GetHeaders -> !BlockHash

-- | The <a>Headers</a> type is used to return a list of block headers in
--   response to a <a>GetHeaders</a> message.
data Headers
Headers :: ![BlockHeaderCount] -> Headers

-- | List of block headers with respective transaction counts
headersList :: Headers -> ![BlockHeaderCount]

-- | <a>BlockHeader</a> type with a transaction count as <a>VarInt</a>
type BlockHeaderCount = (BlockHeader, VarInt)

-- | <a>Inv</a> messages are used by nodes to advertise their knowledge of
--   new objects by publishing a list of hashes. <a>Inv</a> messages can be
--   sent unsolicited or in response to a <a>GetBlocks</a> message.
data Inv
Inv :: ![InvVector] -> Inv

-- | Inventory vectors
invList :: Inv -> ![InvVector]

-- | Invectory vectors represent hashes identifying objects such as a
--   <a>Block</a> or a <a>Tx</a>. They are sent inside messages to notify
--   other peers about new data or data they have requested.
data InvVector
InvVector :: !InvType -> !Word256 -> InvVector

-- | Type of the object referenced by this inventory vector
invType :: InvVector -> !InvType

-- | Hash of the object referenced by this inventory vector
invHash :: InvVector -> !Word256

-- | Data type identifying the type of an inventory vector.
data InvType

-- | Error. Data containing this type can be ignored.
InvError :: InvType

-- | InvVector hash is related to a transaction
InvTx :: InvType

-- | InvVector hash is related to a block
InvBlock :: InvType

-- | InvVector has is related to a merkle block
InvMerkleBlock :: InvType
data MerkleBlock
MerkleBlock :: !BlockHeader -> !Word32 -> ![Word256] -> ![Bool] -> MerkleBlock

-- | Header information for this merkle block.
merkleHeader :: MerkleBlock -> !BlockHeader

-- | Number of transactions in the block (including unmatched
--   transactions).
merkleTotalTxns :: MerkleBlock -> !Word32

-- | Hashes in depth-first order. They are used to rebuild a partial merkle
--   tree.
mHashes :: MerkleBlock -> ![Word256]

-- | Flag bits, packed per 8 in a byte. Least significant bit first. Flag
--   bits are used to rebuild a partial merkle tree.
mFlags :: MerkleBlock -> ![Bool]

-- | Data type describing a bitcoin network address. Addresses are stored
--   in IPv6. IPv4 addresses are mapped to IPv6 using IPv4 mapped IPv6
--   addresses:
--   <a>http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses</a>.
--   Sometimes, timestamps are sent together with the <a>NetworkAddress</a>
--   such as in the <a>Addr</a> data type.
data NetworkAddress
NetworkAddress :: !Word64 -> !(Word64, Word64) -> !Word16 -> NetworkAddress

-- | Bitmask of services available for this address
naServices :: NetworkAddress -> !Word64

-- | IPv6 address serialized as big endian
naAddress :: NetworkAddress -> !(Word64, Word64)

-- | Port number serialized as big endian
naPort :: NetworkAddress -> !Word16

-- | A <a>NotFound</a> message is returned as a response to a
--   <a>GetData</a> message whe one of the requested objects could not be
--   retrieved. This could happen, for example, if a tranasaction was
--   requested and was not available in the memory pool of the receiving
--   node.
data NotFound
NotFound :: ![InvVector] -> NotFound

-- | Inventory vectors related to this request
notFoundList :: NotFound -> ![InvVector]

-- | A Ping message is sent to bitcoin peers to check if a TCP/IP
--   connection is still valid.
newtype Ping
Ping :: Word64 -> Ping

-- | A random nonce used to identify the recipient of the ping request once
--   a Pong response is received.
pingNonce :: Ping -> Word64

-- | A Pong message is sent as a response to a ping message.
newtype Pong
Pong :: Word64 -> Pong

-- | When responding to a Ping request, the nonce from the Ping is copied
--   in the Pong response.
pongNonce :: Pong -> Word64

-- | The reject message is sent when messages are rejected by a peer.
data Reject
Reject :: !MessageCommand -> !RejectCode -> !VarString -> Reject

-- | Type of message rejected
rejectMessage :: Reject -> !MessageCommand

-- | Code related to the rejected message
rejectCode :: Reject -> !RejectCode

-- | Text version of rejected reason
rejectReason :: Reject -> !VarString
data RejectCode
RejectMalformed :: RejectCode
RejectInvalid :: RejectCode
RejectObsolete :: RejectCode
RejectDuplicate :: RejectCode
RejectNonStandard :: RejectCode
RejectDust :: RejectCode
RejectInsufficientFee :: RejectCode
RejectCheckpoint :: RejectCode

-- | Convenience function to build a Reject message
reject :: MessageCommand -> RejectCode -> String -> Reject

-- | Data type representing a bitcoin transaction
data Tx
Tx :: !Word32 -> ![TxIn] -> ![TxOut] -> !Word32 -> Tx

-- | Transaction data format version
txVersion :: Tx -> !Word32

-- | List of transaction inputs
txIn :: Tx -> ![TxIn]

-- | List of transaction outputs
txOut :: Tx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked
txLockTime :: Tx -> !Word32

-- | Data type representing a transaction input.
data TxIn
TxIn :: !OutPoint -> !ByteString -> !Word32 -> TxIn

-- | Reference the previous transaction output (hash + position)
prevOutput :: TxIn -> !OutPoint

-- | Script providing the requirements of the previous transaction output
--   to spend those coins.
scriptInput :: TxIn -> !ByteString

-- | Transaction version as defined by the sender of the transaction. The
--   intended use is for replacing transactions with new information before
--   the transaction is included in a block.
txInSequence :: TxIn -> !Word32

-- | Data type representing a transaction output.
data TxOut
TxOut :: !Word64 -> !ByteString -> TxOut

-- | Transaction output value.
outValue :: TxOut -> !Word64

-- | Script specifying the conditions to spend this output.
scriptOutput :: TxOut -> !ByteString

-- | The OutPoint is used inside a transaction input to reference the
--   previous transaction output that it is spending.
data OutPoint
OutPoint :: !TxHash -> !Word32 -> OutPoint

-- | The hash of the referenced transaction.
outPointHash :: OutPoint -> !TxHash

-- | The position of the specific output in the transaction. The first
--   output position is 0.
outPointIndex :: OutPoint -> !Word32

-- | Data type representing the coinbase transaction of a <a>Block</a>.
--   Coinbase transactions are special types of transactions which are
--   created by miners when they find a new block. Coinbase transactions
--   have no inputs. They have outputs sending the newly generated bitcoins
--   together with all the block's fees to a bitcoin address (usually the
--   miners address). Data can be embedded in a Coinbase transaction which
--   can be chosen by the miner of a block. This data also typically
--   contains some randomness which is used, together with the nonce, to
--   find a partial hash collision on the block's hash.
data CoinbaseTx
CoinbaseTx :: !Word32 -> !OutPoint -> !ByteString -> !Word32 -> ![TxOut] -> !Word32 -> CoinbaseTx

-- | Transaction data format version.
cbVersion :: CoinbaseTx -> !Word32

-- | Previous outpoint. This is ignored for coinbase transactions but
--   preserved for computing the correct txid.
cbPrevOutput :: CoinbaseTx -> !OutPoint

-- | Data embedded inside the coinbase transaction.
cbData :: CoinbaseTx -> !ByteString

-- | Transaction sequence number. This is ignored for coinbase transactions
--   but preserved for computing the correct txid.
cbInSequence :: CoinbaseTx -> !Word32

-- | List of transaction outputs.
cbOut :: CoinbaseTx -> ![TxOut]

-- | The block number of timestamp at which this transaction is locked.
cbLockTime :: CoinbaseTx -> !Word32

-- | Data type representing a variable length integer. The <a>VarInt</a>
--   type usually precedes an array or a string that can vary in length.
newtype VarInt
VarInt :: Word64 -> VarInt
getVarInt :: VarInt -> Word64

-- | Data type for variable length strings. Variable length strings are
--   serialized as a <a>VarInt</a> followed by a bytestring.
newtype VarString
VarString :: ByteString -> VarString
getVarString :: VarString -> ByteString

-- | When a bitcoin node creates an outgoing connection to another node,
--   the first message it will send is a <a>Version</a> message. The other
--   node will similarly respond with it's own <a>Version</a> message.
data Version
Version :: !Word32 -> !Word64 -> !Word64 -> !NetworkAddress -> !NetworkAddress -> !Word64 -> !VarString -> !Word32 -> !Bool -> Version

-- | Protocol version being used by the node.
version :: Version -> !Word32

-- | Bitmask of features to enable for this connection.
services :: Version -> !Word64

-- | UNIX timestamp
timestamp :: Version -> !Word64

-- | Network address of the node receiving this message.
addrRecv :: Version -> !NetworkAddress

-- | Network address of the node sending this message.
addrSend :: Version -> !NetworkAddress

-- | Randomly generated identifying sent with every version message. This
--   nonce is used to detect connection to self.
verNonce :: Version -> !Word64

-- | User agent
userAgent :: Version -> !VarString

-- | The height of the last block received by the sending node.
startHeight :: Version -> !Word32

-- | Wether the remote peer should announce relaying transactions or not.
--   This feature is enabled since version &gt;= 70001. See BIP37 for more
--   details.
relay :: Version -> !Bool

-- | A <a>MessageCommand</a> is included in a <tt>MessageHeader</tt> in
--   order to identify the type of message present in the payload. This
--   allows the message de-serialization code to know how to decode a
--   particular message payload. Every valid <tt>Message</tt> constructor
--   has a corresponding <a>MessageCommand</a> constructor.
data MessageCommand
MCVersion :: MessageCommand
MCVerAck :: MessageCommand
MCAddr :: MessageCommand
MCInv :: MessageCommand
MCGetData :: MessageCommand
MCNotFound :: MessageCommand
MCGetBlocks :: MessageCommand
MCGetHeaders :: MessageCommand
MCTx :: MessageCommand
MCBlock :: MessageCommand
MCMerkleBlock :: MessageCommand
MCHeaders :: MessageCommand
MCGetAddr :: MessageCommand
MCFilterLoad :: MessageCommand
MCFilterAdd :: MessageCommand
MCFilterClear :: MessageCommand
MCPing :: MessageCommand
MCPong :: MessageCommand
MCAlert :: MessageCommand
MCReject :: MessageCommand

-- | Data type representing all of the operators allowed inside a
--   <a>Script</a>.
data ScriptOp
OP_PUSHDATA :: !ByteString -> !PushDataType -> ScriptOp
OP_0 :: ScriptOp
OP_1NEGATE :: ScriptOp
OP_RESERVED :: ScriptOp
OP_1 :: ScriptOp
OP_2 :: ScriptOp
OP_3 :: ScriptOp
OP_4 :: ScriptOp
OP_5 :: ScriptOp
OP_6 :: ScriptOp
OP_7 :: ScriptOp
OP_8 :: ScriptOp
OP_9 :: ScriptOp
OP_10 :: ScriptOp
OP_11 :: ScriptOp
OP_12 :: ScriptOp
OP_13 :: ScriptOp
OP_14 :: ScriptOp
OP_15 :: ScriptOp
OP_16 :: ScriptOp
OP_NOP :: ScriptOp
OP_VER :: ScriptOp
OP_IF :: ScriptOp
OP_NOTIF :: ScriptOp
OP_VERIF :: ScriptOp
OP_VERNOTIF :: ScriptOp
OP_ELSE :: ScriptOp
OP_ENDIF :: ScriptOp
OP_VERIFY :: ScriptOp
OP_RETURN :: ScriptOp
OP_TOALTSTACK :: ScriptOp
OP_FROMALTSTACK :: ScriptOp
OP_IFDUP :: ScriptOp
OP_DEPTH :: ScriptOp
OP_DROP :: ScriptOp
OP_DUP :: ScriptOp
OP_NIP :: ScriptOp
OP_OVER :: ScriptOp
OP_PICK :: ScriptOp
OP_ROLL :: ScriptOp
OP_ROT :: ScriptOp
OP_SWAP :: ScriptOp
OP_TUCK :: ScriptOp
OP_2DROP :: ScriptOp
OP_2DUP :: ScriptOp
OP_3DUP :: ScriptOp
OP_2OVER :: ScriptOp
OP_2ROT :: ScriptOp
OP_2SWAP :: ScriptOp
OP_CAT :: ScriptOp
OP_SUBSTR :: ScriptOp
OP_LEFT :: ScriptOp
OP_RIGHT :: ScriptOp
OP_SIZE :: ScriptOp
OP_INVERT :: ScriptOp
OP_AND :: ScriptOp
OP_OR :: ScriptOp
OP_XOR :: ScriptOp
OP_EQUAL :: ScriptOp
OP_EQUALVERIFY :: ScriptOp
OP_RESERVED1 :: ScriptOp
OP_RESERVED2 :: ScriptOp
OP_1ADD :: ScriptOp
OP_1SUB :: ScriptOp
OP_2MUL :: ScriptOp
OP_2DIV :: ScriptOp
OP_NEGATE :: ScriptOp
OP_ABS :: ScriptOp
OP_NOT :: ScriptOp
OP_0NOTEQUAL :: ScriptOp
OP_ADD :: ScriptOp
OP_SUB :: ScriptOp
OP_MUL :: ScriptOp
OP_DIV :: ScriptOp
OP_MOD :: ScriptOp
OP_LSHIFT :: ScriptOp
OP_RSHIFT :: ScriptOp
OP_BOOLAND :: ScriptOp
OP_BOOLOR :: ScriptOp
OP_NUMEQUAL :: ScriptOp
OP_NUMEQUALVERIFY :: ScriptOp
OP_NUMNOTEQUAL :: ScriptOp
OP_LESSTHAN :: ScriptOp
OP_GREATERTHAN :: ScriptOp
OP_LESSTHANOREQUAL :: ScriptOp
OP_GREATERTHANOREQUAL :: ScriptOp
OP_MIN :: ScriptOp
OP_MAX :: ScriptOp
OP_WITHIN :: ScriptOp
OP_RIPEMD160 :: ScriptOp
OP_SHA1 :: ScriptOp
OP_SHA256 :: ScriptOp
OP_HASH160 :: ScriptOp
OP_HASH256 :: ScriptOp
OP_CODESEPARATOR :: ScriptOp
OP_CHECKSIG :: ScriptOp
OP_CHECKSIGVERIFY :: ScriptOp
OP_CHECKMULTISIG :: ScriptOp
OP_CHECKMULTISIGVERIFY :: ScriptOp
OP_NOP1 :: ScriptOp
OP_NOP2 :: ScriptOp
OP_NOP3 :: ScriptOp
OP_NOP4 :: ScriptOp
OP_NOP5 :: ScriptOp
OP_NOP6 :: ScriptOp
OP_NOP7 :: ScriptOp
OP_NOP8 :: ScriptOp
OP_NOP9 :: ScriptOp
OP_NOP10 :: ScriptOp
OP_PUBKEYHASH :: ScriptOp
OP_PUBKEY :: ScriptOp
OP_INVALIDOPCODE :: !Word8 -> ScriptOp

-- | Data type representing a transaction script. Scripts are defined as
--   lists of script operators <a>ScriptOp</a>. Scripts are used to:
--   
--   <ul>
--   <li>Define the spending conditions in the output of a transaction</li>
--   <li>Provide the spending signatures in the input of a transaction</li>
--   </ul>
data Script
Script :: ![ScriptOp] -> Script

-- | List of script operators defining this script
scriptOps :: Script -> ![ScriptOp]

-- | Data type representing the type of an OP_PUSHDATA opcode.
data PushDataType

-- | The next opcode bytes is data to be pushed onto the stack
OPCODE :: PushDataType

-- | The next byte contains the number of bytes to be pushed onto the stack
OPDATA1 :: PushDataType

-- | The next two bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA2 :: PushDataType

-- | The next four bytes contains the number of bytes to be pushed onto the
--   stack
OPDATA4 :: PushDataType

-- | Check whether opcode is only data.
isPushOp :: ScriptOp -> Bool

-- | Optimally encode data using one of the 4 types of data pushing opcodes
opPushData :: ByteString -> ScriptOp

-- | Data type describing standard transaction output scripts. Output
--   scripts provide the conditions that must be fulfilled for someone to
--   spend the output coins.
data ScriptOutput

-- | Pay to a public key.
PayPK :: !PubKey -> ScriptOutput
getOutputPubKey :: ScriptOutput -> !PubKey

-- | Pay to a public key hash.
PayPKHash :: !Address -> ScriptOutput
getOutputAddress :: ScriptOutput -> !Address

-- | Pay to multiple public keys.
PayMulSig :: ![PubKey] -> !Int -> ScriptOutput
getOutputMulSigKeys :: ScriptOutput -> ![PubKey]
getOutputMulSigRequired :: ScriptOutput -> !Int

-- | Pay to a script hash.
PayScriptHash :: !Address -> ScriptOutput
getOutputAddress :: ScriptOutput -> !Address
data ScriptInput
RegularInput :: SimpleInput -> ScriptInput
getRegularInput :: ScriptInput -> SimpleInput
ScriptHashInput :: SimpleInput -> RedeemScript -> ScriptInput
getScriptHashInput :: ScriptInput -> SimpleInput
getScriptHashRedeem :: ScriptInput -> RedeemScript

-- | Data type describing standard transaction input scripts. Input scripts
--   provide the signing data required to unlock the coins of the output
--   they are trying to spend.
data SimpleInput

-- | Spend the coins of a PayPK output.
SpendPK :: !TxSignature -> SimpleInput
getInputSig :: SimpleInput -> !TxSignature

-- | Spend the coins of a PayPKHash output.
SpendPKHash :: !TxSignature -> !PubKey -> SimpleInput
getInputSig :: SimpleInput -> !TxSignature
getInputKey :: SimpleInput -> !PubKey

-- | Spend the coins of a PayMulSig output.
SpendMulSig :: ![TxSignature] -> SimpleInput
getInputMulSigKeys :: SimpleInput -> ![TxSignature]
type RedeemScript = ScriptOutput

-- | Computes a script address from a script output. This address can be
--   used in a pay to script hash output.
scriptAddr :: ScriptOutput -> Address

-- | Computes the recipient address of a script. This function fails if the
--   script could not be decoded as a pay to public key hash or pay to
--   script hash.
scriptRecipient :: Script -> Either String Address

-- | Computes the sender address of a script. This function fails if the
--   script could not be decoded as a spend public key hash or script hash
--   input.
scriptSender :: Script -> Either String Address
encodeInput :: ScriptInput -> Script

-- | Similar to <a>encodeInput</a> but encodes to a ByteString
encodeInputBS :: ScriptInput -> ByteString

-- | Decodes a <a>ScriptInput</a> from a <a>Script</a>. This function fails
--   if the script can not be parsed as a standard script input.
decodeInput :: Script -> Either String ScriptInput

-- | Similar to <a>decodeInput</a> but decodes from a ByteString
decodeInputBS :: ByteString -> Either String ScriptInput

-- | Computes a <a>Script</a> from a <a>ScriptOutput</a>. The <a>Script</a>
--   is a list of <a>ScriptOp</a> can can be used to build a <tt>Tx</tt>.
encodeOutput :: ScriptOutput -> Script

-- | Similar to <a>encodeOutput</a> but encodes to a ByteString
encodeOutputBS :: ScriptOutput -> ByteString

-- | Tries to decode a <a>ScriptOutput</a> from a <a>Script</a>. This can
--   fail if the script is not recognized as any of the standard output
--   types.
decodeOutput :: Script -> Either String ScriptOutput

-- | Similar to <a>decodeOutput</a> but decodes from a ByteString
decodeOutputBS :: ByteString -> Either String ScriptOutput

-- | Sorts the public keys of a multisignature output in ascending order by
--   comparing their serialized representations. This feature allows for
--   easier multisignature account management as participants in a
--   multisignature wallet will blindly agree on an ordering of the public
--   keys without having to communicate.
sortMulSig :: ScriptOutput -> ScriptOutput

-- | Transforms integers [1 .. 16] to <a>ScriptOp</a> [OP_1 .. OP_16]
intToScriptOp :: Int -> ScriptOp

-- | Decode <a>ScriptOp</a> [OP_1 .. OP_16] to integers [1 .. 16]. This
--   functions fails for other values of <a>ScriptOp</a>
scriptOpToInt :: ScriptOp -> Either String Int

-- | Returns True if the script is a pay to public key output.
isPayPK :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to public key hash output.
isPayPKHash :: ScriptOutput -> Bool

-- | Returns True if the script is a pay to multiple public keys output.
isPayMulSig :: ScriptOutput -> Bool

-- | Returns true if the script is a pay to script hash output.
isPayScriptHash :: ScriptOutput -> Bool

-- | Returns True if the input script is spending a public key.
isSpendPK :: ScriptInput -> Bool

-- | Returns True if the input script is spending a public key hash.
isSpendPKHash :: ScriptInput -> Bool

-- | Returns True if the input script is spending a multisignature output.
isSpendMulSig :: ScriptInput -> Bool
isScriptHashInput :: ScriptInput -> Bool

-- | Data type representing the different ways a transaction can be signed.
--   When producing a signature, a hash of the transaction is used as the
--   message to be signed. The <a>SigHash</a> parameter controls which
--   parts of the transaction are used or ignored to produce the
--   transaction hash. The idea is that if some part of a transaction is
--   not used to produce the transaction hash, then you can change that
--   part of the transaction after producing a signature without
--   invalidating that signature.
--   
--   If the anyoneCanPay flag is True, then only the current input is
--   signed. Otherwise, all of the inputs of a transaction are signed. The
--   default value for anyoneCanPay is False.
data SigHash

-- | Sign all of the outputs of a transaction (This is the default value).
--   Changing any of the outputs of the transaction will invalidate the
--   signature.
SigAll :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Sign none of the outputs of a transaction. This allows anyone to
--   change any of the outputs of the transaction.
SigNone :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Sign only the output corresponding the the current transaction input.
--   You care about your own output in the transaction but you don't care
--   about any of the other outputs.
SigSingle :: !Bool -> SigHash
anyoneCanPay :: SigHash -> !Bool

-- | Unrecognized sighash types will decode to SigUnknown.
SigUnknown :: !Bool -> !Word8 -> SigHash
anyoneCanPay :: SigHash -> !Bool
getSigCode :: SigHash -> !Word8

-- | Encodes a <a>SigHash</a> to a 32 bit-long bytestring.
encodeSigHash32 :: SigHash -> ByteString

-- | Returns True if the <a>SigHash</a> has the value SigAll.
isSigAll :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigNone.
isSigNone :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigSingle.
isSigSingle :: SigHash -> Bool

-- | Returns True if the <a>SigHash</a> has the value SigUnknown.
isSigUnknown :: SigHash -> Bool

-- | Computes the hash that will be used for signing a transaction.
txSigHash :: Tx -> Script -> Int -> SigHash -> Word256

-- | Data type representing a <a>Signature</a> together with a
--   <a>SigHash</a>. The <a>SigHash</a> is serialized as one byte at the
--   end of a regular ECDSA <a>Signature</a>. All signatures in transaction
--   inputs are of type <a>TxSignature</a>.
data TxSignature
TxSignature :: !Signature -> !SigHash -> TxSignature
txSignature :: TxSignature -> !Signature
sigHashType :: TxSignature -> !SigHash

-- | Serialize a <a>TxSignature</a> to a ByteString.
encodeSig :: TxSignature -> ByteString

-- | Decode a <a>TxSignature</a> from a ByteString.
decodeSig :: ByteString -> Either String TxSignature

-- | Decode a <a>TxSignature</a> from a ByteString. This function will
--   check if the signature is canonical and fail if it is not.
decodeCanonicalSig :: ByteString -> Either String TxSignature

-- | Uses <a>evalScript</a> to check that the input script of a spending
--   transaction satisfies the output script.
verifySpend :: Tx -> Int -> Script -> Bool
evalScript :: Script -> Script -> SigCheck -> Bool

-- | Defines the type of function required by script evaluating functions
--   to check transaction signatures.
type SigCheck = [ScriptOp] -> TxSignature -> PubKey -> Bool

-- | Data type of the evaluation state.
data Program
type Stack = [StackValue]

-- | Encoding function for the stack value format of integers. Most
--   significant bit defines sign.
encodeInt :: Int64 -> StackValue

-- | Inverse of <a>encodeInt</a>.
decodeInt :: StackValue -> Maybe Int64
encodeBool :: Bool -> StackValue

-- | Conversion of StackValue to Bool (true if non-zero).
decodeBool :: StackValue -> Bool
runStack :: Program -> Stack
checkStack :: Stack -> Bool
dumpScript :: [ScriptOp] -> String
dumpStack :: Stack -> String
execScript :: Script -> Script -> SigCheck -> Either EvalError Program

-- | A Coin is an output of a transaction that can be spent by another
--   transaction.
data Coin
Coin :: !Word64 -> !ScriptOutput -> !OutPoint -> !(Maybe RedeemScript) -> Coin

-- | Value in satoshi
coinValue :: Coin -> !Word64

-- | Output script
coinScript :: Coin -> !ScriptOutput

-- | Previous outpoint
coinOutPoint :: Coin -> !OutPoint

-- | Redeem script
coinRedeem :: Coin -> !(Maybe RedeemScript)

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of <a>ScriptOutput</a> and amounts as outputs.
buildTx :: [OutPoint] -> [(ScriptOutput, Word64)] -> Either String Tx

-- | Build a transaction by providing a list of outpoints as inputs and a
--   list of recipients addresses and amounts as outputs.
buildAddrTx :: [OutPoint] -> [(String, Word64)] -> Either String Tx

-- | Data type used to specify the signing parameters of a transaction
--   input. To sign an input, the previous output script, outpoint and
--   sighash are required. When signing a pay to script hash output, an
--   additional redeem script is required.
data SigInput
SigInput :: !ScriptOutput -> !OutPoint -> !SigHash -> !(Maybe RedeemScript) -> SigInput

-- | Output script to spend.
sigDataOut :: SigInput -> !ScriptOutput

-- | Spending tranasction OutPoint
sigDataOP :: SigInput -> !OutPoint

-- | Signature type.
sigDataSH :: SigInput -> !SigHash

-- | Redeem script
sigDataRedeem :: SigInput -> !(Maybe RedeemScript)

-- | Sign a transaction by providing the <a>SigInput</a> signing parameters
--   and a list of private keys. The signature is computed within the
--   <a>SecretT</a> monad to generate the random signing nonce. This
--   function returns a transaction completion status. If false, some of
--   the inputs are not fully signed or are non-standard.
signTx :: Monad m => Tx -> [SigInput] -> [PrvKey] -> EitherT String (SecretT m) (Tx, Bool)

-- | Sign a single input in a transaction within the <a>SecretT</a> monad.
--   This function will return a completion status only for that input. If
--   false, that input is either non-standard or not fully signed.
signInput :: Monad m => Tx -> Int -> SigInput -> PrvKey -> EitherT String (SecretT m) (Tx, Bool)

-- | Sign a transaction by providing the <a>SigInput</a> signing paramters
--   and a list of private keys. The signature is computed
--   deterministically as defined in RFC-6979. This function returns a
--   transaction completion status. If false, some of the inputs are not
--   fully signed or are non-standard.
detSignTx :: Tx -> [SigInput] -> [PrvKey] -> Either String (Tx, Bool)

-- | Sign a single input in a transaction deterministically (RFC-6979).
--   This function will return a completion status only for that input. If
--   false, that input is either non-standard or not fully signed.
detSignInput :: Tx -> Int -> SigInput -> PrvKey -> Either String (Tx, Bool)

-- | Verify if a transaction is valid and all of its inputs are standard.
verifyStdTx :: Tx -> [(ScriptOutput, OutPoint)] -> Bool

-- | Verify if a transaction input is valid and standard.
verifyStdInput :: Tx -> Int -> ScriptOutput -> Bool

-- | Computes an upper bound on the size of a transaction based on some
--   known properties of the transaction.
guessTxSize :: Int -> [(Int, Int)] -> Int -> Int -> Int

-- | Coin selection algorithm for normal (non-multisig) transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account.
chooseCoins :: Word64 -> Word64 -> [Coin] -> Either String ([Coin], Word64)

-- | Coin selection algorithm for multisignature transactions. This
--   function returns the selected coins together with the amount of change
--   to send back to yourself, taking the fee into account. This function
--   assumes all the coins are script hash outputs that send funds to a
--   multisignature address.
chooseMSCoins :: Word64 -> Word64 -> (Int, Int) -> [Coin] -> Either String ([Coin], Word64)
getFee :: Word64 -> Int -> Word64
getMSFee :: Word64 -> (Int, Int) -> Int -> Word64
