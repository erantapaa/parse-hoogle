-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Third cake the Makefile EDSL
--   
--   Cake3 is a EDSL for building Makefiles, written in Haskell. With
--   cake3, developer can write their build logic in Haskell, obtain clean
--   and safe Makefile and distribute it among the non-Haskell-aware users.
--   Currenly, GNU Make is the only backend supported.
--   
--   <i>Example program</i>
--   
--   <pre>
--   module Cakefile where
--   
--   import Development.Cake3
--   import Cakefile_P
--   
--   cs = map file ["main.c", "second.c"]
--   
--   main = writeMake (file "Makefile") $ do
--     selfUpdate
--     d &lt;- rule $ do
--       shell [cmd|gcc -M $cs -MF @(file "depend.mk")|]
--     os &lt;- forM cs $ \c -&gt; do
--       rule $ do
--         shell [cmd| gcc -c $(extvar "CFLAGS") -o @(c.="o") $c |]
--     elf &lt;- rule $ do
--       shell [cmd| gcc -o @(file "main.elf") $os |]
--     rule $ do
--       phony "all"
--       depend elf
--     includeMakefile d
--   </pre>
--   
--   <i>Basic workflow</i>
--   
--   <ul>
--   <li>Install the cake3</li>
--   <li>Create Cakefile.hs in the project root</li>
--   <li>Build the application using cake3 script provided</li>
--   <li>Execute the application to obtain the Makefile</li>
--   </ul>
--   
--   See the README on the GitHub <a>https://github.com/grwlf/cake3</a> for
--   more information. Distribution contains several example projects.
@package cake3
@version 0.6.0


-- | QuasyString-like module. Tweaked for the cake3
module Text.QuasiMake

-- | Chunk is a part of quasy-quotation
data Chunk

-- | the text
T :: Text -> Chunk

-- | $(expr) or @(expr)
E :: Char -> Text -> Chunk

-- | A simple <a>QuasiQuoter</a> to interpolate <a>Text</a> into other
--   pieces of <a>Text</a>. Expressions can be embedded using $(expr) or
--   @(expr), and values can be interpolated with $name. Inside $( )s, if
--   you have a string of ambiguous type, it will default to the Show
--   instance for toText, which will escape unicode characters in the
--   string, and add quotes around them.
getChunks :: Text -> [Chunk]
instance [incoherent] Show Chunk
instance [incoherent] Eq Chunk
instance [incoherent] Show a => Textish a
instance [incoherent] Textish [Char]
instance [incoherent] Textish Text
instance [incoherent] Lift Text

module System.FilePath.Wrapper
newtype FileT a
FileT :: a -> FileT a

-- | Simple wrapper for FilePath.
type File = FileT FilePath

-- | Convert File back to FilePath
toFilePath :: (FileT FilePath) -> FilePath
fromFilePath :: FilePath -> FileT FilePath

-- | Convert File back to FilePath with escaped spaces
escapeFile :: File -> FilePath
class FileLike a
combine :: FileLike a => a -> String -> a
takeDirectory :: FileLike a => a -> a
takeBaseName :: FileLike a => a -> String
takeFileName :: FileLike a => a -> String
makeRelative :: FileLike a => a -> a -> a
replaceExtension :: FileLike a => a -> String -> a
takeExtension :: FileLike a => a -> String
takeExtensions :: FileLike a => a -> String
dropExtensions :: FileLike a => a -> a
dropExtension :: FileLike a => a -> a
splitDirectories :: FileLike a => a -> [String]

-- | Redefine standard <tt><a>/</a></tt> operator to work with Files
(</>) :: FileLike a => a -> String -> a

-- | Alias for replaceExtension
(.=) :: FileLike a => a -> String -> a
instance Typeable FileT
instance Show a => Show (FileT a)
instance Eq a => Eq (FileT a)
instance Ord a => Ord (FileT a)
instance Data a => Data (FileT a)
instance FileLike FilePath
instance FileLike a => FileLike (FileT a)
instance Monoid a => Monoid (FileT a)

module Development.Cake3.Types

-- | The representation of Makefile variable.
data Variable
Variable :: String -> Maybe String -> Variable

-- | The name of a variable
vname :: Variable -> String

-- | Nothing means that variable is defined elsewhere (eg. borrowed from
--   the environment)
vval :: Variable -> Maybe String

-- | The representation a tool used by the Makefile's recipe. Typical
--   example are <tt>gcc</tt> or <tt>bison</tt>
data Tool
Tool :: String -> Tool

-- | Name of tool.
tname :: Tool -> String

-- | Command represents OS command line and consists of a list of
--   fragments. Each fragment is either text (may contain spaces) or
--   FilePath (spaces should be escaped)
type Command = [CommandPiece]
data CommandPiece
CmdStr :: String -> CommandPiece
CmdFile :: File -> CommandPiece
return_text :: Monad m => String -> m [CommandPiece]
return_file :: Monad m => File -> m [CommandPiece]
data Flag
Phony :: Flag
Intermediate :: Flag

-- | Recipe answers to the question 'How to build the targets'. Internally,
--   it contains sets of targets and prerequisites, as well as shell
--   commands required to build former from latter
data Recipe
Recipe :: Set File -> Set File -> [Command] -> Set Variable -> Set Tool -> String -> Set Flag -> Recipe

-- | Targets
rtgt :: Recipe -> Set File

-- | Prerequisites
rsrc :: Recipe -> Set File

-- | A list of shell commands
rcmd :: Recipe -> [Command]

-- | A set of variables employed in the recipe. The target Makefile should
--   notice changes in those variables and rebuild the targets
rvars :: Recipe -> Set Variable

-- | A set of tools employed in the recipe. Make
rtools :: Recipe -> Set Tool

-- | Location (probably, doesn't function)
rloc :: Recipe -> String

-- | Set of flags (Makefile-specific)
rflags :: Recipe -> Set Flag
emptyRecipe :: String -> Recipe
addPrerequisites :: Set File -> Recipe -> Recipe
addPrerequisite :: File -> Recipe -> Recipe
type Target = Set File
groupSet :: (Ord k, Ord x, Foldable t) => (x -> Set k) -> t x -> Map k (Set x)
groupRecipes :: Foldable t => t Recipe -> Map File (Set Recipe)
flattern :: [Set x] -> [x]
applyPlacement' :: Eq x => [File] -> Map File x -> [x]
filterRecipesByTools :: Foldable t => [Tool] -> t Recipe -> Set Recipe
filterRecipesByTargets :: (Foldable t, Foldable t2) => t2 File -> t Recipe -> Set Recipe
filterRecipesByToolsDeep :: [Tool] -> Set Recipe -> Set Recipe
applyPlacement :: Foldable t => [File] -> t Recipe -> [Recipe]
transformRecipes :: Applicative m => (Recipe -> m (Set Recipe)) -> Set Recipe -> m (Set Recipe)
transformRecipesM_ :: (Monad m, Foldable t) => (Recipe -> m ()) -> t Recipe -> m ()
queryVariables :: Foldable t => t Recipe -> Set Variable
queryVariablesE :: Foldable t => t Recipe -> Either String (Set Variable)
queryTargets :: Foldable t => t Recipe -> Set File
queryPrereq :: Foldable t => t Recipe -> Set File
var :: String -> Maybe String -> Variable
intermediateFiles :: Foldable t => t Recipe -> Set File
tool :: String -> Tool

-- | Define the Makefile-level variable. Rules, referring to a variable,
--   <tt>notice</tt> it's changes.
makevar :: String -> String -> Variable

-- | Declare the variable defined elsewhere. Typycally, environment
--   variables may be decalred with this functions. Variables are tracked
--   by the cake3. Rules, referring to a variable, <tt>notice</tt> it's
--   changes.
extvar :: String -> Variable

-- | Reref to special variable <tt>$(MAKE)</tt>
make :: Variable
instance Typeable Variable
instance Typeable Tool
instance Typeable CommandPiece
instance Typeable Flag
instance Typeable Recipe
instance Show Variable
instance Eq Variable
instance Ord Variable
instance Data Variable
instance Show Tool
instance Eq Tool
instance Ord Tool
instance Data Tool
instance Show CommandPiece
instance Eq CommandPiece
instance Ord CommandPiece
instance Data CommandPiece
instance Show Flag
instance Eq Flag
instance Ord Flag
instance Data Flag
instance Show Recipe
instance Eq Recipe
instance Ord Recipe
instance Data Recipe

module Development.Cake3.Monad
type Location = String

-- | MakeState describes the state of the EDSL synthesizers during the the
--   program execution.
data MakeState
MS :: Recipe -> Recipe -> Set Recipe -> Location -> Set File -> [File] -> Set File -> String -> String -> File -> Set File -> MakeState

-- | Prebuild commands. targets/prerequsites of the recipe are ignored,
--   commands are executed before any target
prebuilds :: MakeState -> Recipe

-- | Postbuild commands.
postbuilds :: MakeState -> Recipe

-- | The set of recipes, to be checked and renderd as a Makefile
recipes :: MakeState -> Set Recipe

-- | Current location. FIXME: fix or remove
sloc :: MakeState -> Location

-- | Set of files which the Makefile depends on
makeDeps :: MakeState -> Set File

-- | Placement list is the order of targets to be placed in the output file
placement :: MakeState -> [File]

-- | Set of files to include in the output file (Makefile specific thing)
includes :: MakeState -> Set File

-- | Errors found so far
errors :: MakeState -> String

-- | Warnings found so far
warnings :: MakeState -> String

-- | Name of the Makefile being generated , tmpIndex :: Int ^ Index to
--   build temp names
outputFile :: MakeState -> File

-- | extra clean files
extraClean :: MakeState -> Set File
initialMakeState :: File -> MakeState
getPlacementPos :: Make Int
addPlacement :: Int -> File -> Make ()
addMakeDep :: File -> Make ()
tmp_file :: String -> File

-- | Add prebuild command
prebuild :: MonadMake m => CommandGen -> m ()

-- | Add prebuild command
postbuild :: MonadMake m => CommandGen -> m ()

-- | Find recipes without targets. Empty result means 'No errors'
checkForEmptyTarget :: Foldable f => f Recipe -> String

-- | Find recipes sharing a target. Empty result means 'No errors'
checkForTargetConflicts :: Foldable f => f Recipe -> String

-- | A Monad providing access to MakeState. TODO: not mention IO here.
class Monad m => MonadMake m
liftMake :: MonadMake m => (Make' IO) a -> m a
newtype Make' m a
Make :: (StateT MakeState m) a -> Make' m a
unMake :: Make' m a -> (StateT MakeState m) a
type Make a = Make' IO a

-- | Evaluate the Make monad <tt>mf</tt>, return MakeState containing the
--   result. Name <tt>mf</tt> is used for self-referencing recipes.
evalMake :: Monad m => File -> Make' m a -> m MakeState
modifyLoc :: MonadState MakeState m => (Location -> Location) -> m ()
addRecipe :: Recipe -> Make ()
getLoc :: Make String

-- | Add 'include ...' directive to the final Makefile for each input file.
includeMakefile :: Foldable t => t File -> Make ()

-- | <a>A</a> here stands for Action. It is a State monad carrying a Recipe
--   as its state. Various monadic actions add targets, prerequisites and
--   shell commands to this recipe. After that, <tt>rule</tt> function
--   records it to the <tt>MakeState</tt>. After the recording, no
--   modification is allowed for this recipe.
newtype A' m a
A' :: StateT Recipe m a -> A' m a
unA' :: A' m a -> StateT Recipe m a

-- | Verison of Action monad with fixed parents
type A a = A' (Make' IO) a

-- | A class of monads providing access to the underlying A monad
class (Monad m, Monad t) => MonadAction t m | t -> m
liftAction :: MonadAction t m => A' m x -> t x

-- | Run the Action monad, using already existing Recipe as input.
runA' :: Monad m => Recipe -> A' m a -> m (Recipe, a)

-- | Create new empty recipe and run action on it.
runA :: Monad m => String -> A' m a -> m (Recipe, a)

-- | Version of runA discarding the result of A's computation
runA_ :: Monad m => String -> A' m a -> m Recipe

-- | Get a list of targets added so far
targets :: (Applicative m, Monad m) => A' m (Set File)

-- | Get a list of prerequisites added so far
prerequisites :: (Applicative m, Monad m) => A' m (Set File)

-- | Mark the recipe as <tt>PHONY</tt> i.e. claim that all it's targets are
--   not real files. Makefile-specific.
markPhony :: Monad m => A' m ()

-- | Adds the phony target for a rule. Typical usage:
--   
--   <pre>
--   rule $ do
--    phony "clean"
--    unsafeShell [cmd|rm $elf $os $d|]
--   </pre>
phony :: Monad m => String -> A' m ()

-- | Mark the recipe as <tt>INTERMEDIATE</tt> i.e. claim that all it's
--   targets may be removed after the build process. Makefile-specific.
markIntermediate :: Monad m => A' m ()

-- | Obtain the contents of a File. Note, that this generally means, that
--   Makefile should be regenerated each time the File is changed.
readFileForMake :: MonadMake m => File -> m ByteString

-- | CommandGen is a recipe-builder packed in the newtype to prevent
--   partial expantion of it's commands
newtype CommandGen' m
CommandGen' :: A' m Command -> CommandGen' m
unCommand :: CommandGen' m -> A' m Command
type CommandGen = CommandGen' (Make' IO)

-- | Pack the command builder into a CommandGen
commandGen :: A Command -> CommandGen

-- | Modifie the recipe builder: ignore all the dependencies
ignoreDepends :: Monad m => A' m a -> A' m a

-- | Apply the recipe builder to the current recipe state. Return the list
--   of targets of the current <tt>Recipe</tt> under construction
shell :: Monad m => CommandGen' m -> A' m [File]

-- | Version of <tt>shell</tt> which doesn't track it's dependencies
unsafeShell :: Monad m => CommandGen' m -> A' m [File]

-- | Simple wrapper for strings, a target for various typeclass instances.
newtype CakeString
CakeString :: String -> CakeString

-- | An alias to CakeString constructor
string :: String -> CakeString

-- | Class of things which may be referenced using '@(expr)' syntax of the
--   quasi-quoted shell expressions.
class Monad m => RefOutput m x
refOutput :: RefOutput m x => x -> A' m Command
inbetween :: Monad m => t -> m [[t]] -> m [t]
spacify :: Monad m => m [[CommandPiece]] -> m [CommandPiece]

-- | Class of things which may be referenced using '$(expr)' syntax of the
--   quasy-quoted shell expressions
class MonadAction a m => RefInput a m x
refInput :: RefInput a m x => x -> a Command

-- | Add it's argument to the list of dependencies (prerequsites) of a
--   current recipe under construction
depend :: RefInput a m x => x -> a ()

-- | Declare that current recipe produces some producable item.
produce :: RefOutput m x => x -> A' m ()

-- | Add variables <tt>vs</tt> to tracking list of the current recipe
variables :: (Foldable t, Monad m) => (t Variable) -> A' m ()

-- | Add tools <tt>ts</tt> to the tracking list of the current recipe
tools :: (Foldable t, Monad m) => (t Tool) -> A' m ()

-- | Add commands to the list of commands of a current recipe under
--   construction. Warning: this function behaves like unsafeShell i.e. it
--   doesn't analyze the command text
commands :: Monad m => [Command] -> A' m ()

-- | Set the recipe's location in the Cakefile.hs
location :: Monad m => String -> A' m ()

-- | Set additional flags
flags :: Monad m => Set Flag -> A' m ()

-- | Has effect of a function <tt>QQ -&gt; CommandGen</tt> where QQ is a
--   string supporting the following syntax:
--   
--   <ul>
--   <li>$(expr) evaluates to expr and adds it to the list of dependencies
--   (prerequsites)</li>
--   <li>@(expr) evaluates to expr and adds it to the list of targets</li>
--   <li>$$ and @@ evaluates to $ and @</li>
--   </ul>
--   
--   <i>Example</i>
--   
--   <pre>
--   [cmd|gcc $flags -o @file|]
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   return $ CommandGen $ do
--     s1 &lt;- refInput "gcc "
--     s2 &lt;- refInput (flags :: Variable)
--     s3 &lt;- refInput " -o "
--     s4 &lt;- refOutput (file :: File)
--     return (s1 ++ s2 ++ s3 ++ s4)
--   </pre>
--   
--   Later, this command may be examined or passed to the shell function to
--   apply it to the recipe
cmd :: QuasiQuoter
instance [overlap ok] Monad m => Monad (Make' m)
instance [overlap ok] Functor m => Functor (Make' m)
instance [overlap ok] (Monad m, Functor m) => Applicative (Make' m)
instance [overlap ok] Monad m => MonadState MakeState (Make' m)
instance [overlap ok] MonadIO m => MonadIO (Make' m)
instance [overlap ok] MonadFix m => MonadFix (Make' m)
instance [overlap ok] Monad m => Monad (A' m)
instance [overlap ok] Functor m => Functor (A' m)
instance [overlap ok] (Monad m, Functor m) => Applicative (A' m)
instance [overlap ok] Monad m => MonadState Recipe (A' m)
instance [overlap ok] MonadIO m => MonadIO (A' m)
instance [overlap ok] MonadFix m => MonadFix (A' m)
instance [overlap ok] Show CakeString
instance [overlap ok] Eq CakeString
instance [overlap ok] Ord CakeString
instance [overlap ok] MonadAction a m => RefInput a m (CommandGen' m)
instance [overlap ok] MonadAction a m => RefInput a m CakeString
instance [overlap ok] MonadAction a m => RefInput a m Tool
instance [overlap ok] MonadAction a m => RefInput a m Variable
instance [overlap ok] RefInput a m x => RefInput a m (Maybe x)
instance [overlap ok] (RefInput a m x, MonadMake a) => RefInput a m (Make x)
instance [overlap ok] (MonadAction a m, MonadMake a) => RefInput a m (Make Recipe)
instance [overlap ok] (MonadIO a, RefInput a m x) => RefInput a m (IO x)
instance [overlap ok] MonadAction a m => RefInput a m (Set File)
instance [overlap ok] RefInput a m x => RefInput a m [x]
instance [overlap ok] MonadAction a m => RefInput a m Recipe
instance [overlap ok] MonadAction a m => RefInput a m File
instance [overlap ok] RefOutput m x => RefOutput m (Maybe x)
instance [overlap ok] Monad m => RefOutput m (Set File)
instance [overlap ok] Monad m => RefOutput m [File]
instance [overlap ok] Monad m => RefOutput m File
instance [overlap ok] Monad m => MonadAction (A' m) m
instance [overlap ok] Monad m => MonadLoc (Make' m)
instance [overlap ok] MonadMake m => MonadMake (StateT s m)
instance [overlap ok] MonadMake m => MonadMake (A' m)
instance [overlap ok] MonadMake (Make' IO)

module Development.Cake3.Writer

-- | Default Makefile location
defaultMakefile :: File

-- | Render the Makefile. Return either the content (Right), or error
--   messages (Left).
buildMake :: MakeState -> Either String String
instance Functor MakeLL
instance Monad MakeLL
instance MonadState ([File], Set Recipe) MakeLL
instance Applicative MakeLL
instance ToMakeText (Set File)
instance ToMakeText CommandPiece
instance ToMakeText Command
instance ToMakeText File
instance ToMakeText [Char]

module Development.Cake3

-- | The representation of Makefile variable.
data Variable

-- | Recipe answers to the question 'How to build the targets'. Internally,
--   it contains sets of targets and prerequisites, as well as shell
--   commands required to build former from latter
data Recipe

-- | Class of things which may be referenced using '$(expr)' syntax of the
--   quasy-quoted shell expressions
class MonadAction a m => RefInput a m x
refInput :: RefInput a m x => x -> a Command

-- | Class of things which may be referenced using '@(expr)' syntax of the
--   quasi-quoted shell expressions.
class Monad m => RefOutput m x
refOutput :: RefOutput m x => x -> A' m Command

-- | Simple wrapper for strings, a target for various typeclass instances.
data CakeString

-- | An alias to CakeString constructor
string :: String -> CakeString

-- | Verison of Action monad with fixed parents
type A a = A' (Make' IO) a
type Make a = Make' IO a

-- | Render the Makefile. Return either the content (Right), or error
--   messages (Left).
buildMake :: MakeState -> Either String String

-- | Execute the <tt>mk</tt> monad, return the Makefile as a String. In
--   case of errors, print report to stderr and abort the execution with
--   <tt>fail</tt> call
runMake :: Make a -> IO String

-- | A Generic Make monad runner. Execute the monad <tt>mk</tt>, provide
--   the <tt>output</tt> handler with Makefile encoded as a string. Note
--   that Makefile may contain rules which references the file itself by
--   the name <tt>makefile</tt>. In case of errors, print report to stderr
--   and abort the execution with <tt>fail</tt> call
runMakeH :: MakeState -> (String -> IO b) -> IO (MakeState, b)

-- | A Version of <tt>runMakeH</tt> returning no state
runMakeH_ :: MakeState -> (String -> IO b) -> IO b

-- | Execute the <tt>mk</tt> monad, build the Makefile, write it to the
--   output file. In case of errors, print report to stderr and abort the
--   execution with <tt>fail</tt> call
writeMake :: File -> Make a -> IO ()

-- | Add 'include ...' directive to the final Makefile for each input file.
includeMakefile :: Foldable t => t File -> Make ()

-- | A Monad providing access to MakeState. TODO: not mention IO here.
class Monad m => MonadMake m
liftMake :: MonadMake m => (Make' IO) a -> m a

-- | A version of rule2. Rule places it's recipe above all recipies defined
--   so far.
rule :: A a -> Make a

-- | Build a Recipe using the builder provided and record it to the
--   MakeState. Return the copy of Recipe (which should not be changed in
--   future) and the result of recipe builder. The typical recipe builder
--   result is the list of it's targets.
--   
--   <i>Example</i> Lets declare a rule which builds "main.o" out of
--   "main.c" and <a>CFLAGS</a> variable
--   
--   <pre>
--   let c = file "main.c"
--   rule $ shell [cmd| gcc -c $(extvar "CFLAGS") -o @(c.="o") $c |]
--   </pre>
rule2 :: MonadMake m => A a -> m (Recipe, a)

-- | A version of rule, without monad set explicitly
rule' :: MonadMake m => A a -> m a

-- | Adds the phony target for a rule. Typical usage:
--   
--   <pre>
--   rule $ do
--    phony "clean"
--    unsafeShell [cmd|rm $elf $os $d|]
--   </pre>
phony :: Monad m => String -> A' m ()

-- | Add it's argument to the list of dependencies (prerequsites) of a
--   current recipe under construction
depend :: RefInput a m x => x -> a ()

-- | Declare that current recipe produces some producable item.
produce :: RefOutput m x => x -> A' m ()

-- | Modifie the recipe builder: ignore all the dependencies
ignoreDepends :: Monad m => A' m a -> A' m a

-- | Add prebuild command
prebuild :: MonadMake m => CommandGen -> m ()

-- | Add prebuild command
postbuild :: MonadMake m => CommandGen -> m ()
class FileLike a
combine :: FileLike a => a -> String -> a
takeDirectory :: FileLike a => a -> a
takeBaseName :: FileLike a => a -> String
takeFileName :: FileLike a => a -> String
makeRelative :: FileLike a => a -> a -> a
replaceExtension :: FileLike a => a -> String -> a
takeExtension :: FileLike a => a -> String
takeExtensions :: FileLike a => a -> String
dropExtensions :: FileLike a => a -> a
dropExtension :: FileLike a => a -> a
splitDirectories :: FileLike a => a -> [String]

-- | Simple wrapper for FilePath.
type File = FileT FilePath

-- | Converts string representation of Path into type-safe File.
--   Internally, files are stored as a relative offsets from the project
--   root directory
file' :: ProjectLocation -> String -> File

-- | Alias for replaceExtension
(.=) :: FileLike a => a -> String -> a

-- | Redefine standard <tt><a>/</a></tt> operator to work with Files
(</>) :: FileLike a => a -> String -> a

-- | Convert File back to FilePath
toFilePath :: (FileT FilePath) -> FilePath

-- | Obtain the contents of a File. Note, that this generally means, that
--   Makefile should be regenerated each time the File is changed.
readFileForMake :: MonadMake m => File -> m ByteString
genFile :: MonadMake m => File -> String -> m File

-- | Get a list of prerequisites added so far
prerequisites :: (Applicative m, Monad m) => A' m (Set File)

-- | Apply the recipe builder to the current recipe state. Return the list
--   of targets of the current <tt>Recipe</tt> under construction
shell :: Monad m => CommandGen' m -> A' m [File]

-- | Version of <tt>shell</tt> which doesn't track it's dependencies
unsafeShell :: Monad m => CommandGen' m -> A' m [File]

-- | Has effect of a function <tt>QQ -&gt; CommandGen</tt> where QQ is a
--   string supporting the following syntax:
--   
--   <ul>
--   <li>$(expr) evaluates to expr and adds it to the list of dependencies
--   (prerequsites)</li>
--   <li>@(expr) evaluates to expr and adds it to the list of targets</li>
--   <li>$$ and @@ evaluates to $ and @</li>
--   </ul>
--   
--   <i>Example</i>
--   
--   <pre>
--   [cmd|gcc $flags -o @file|]
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   return $ CommandGen $ do
--     s1 &lt;- refInput "gcc "
--     s2 &lt;- refInput (flags :: Variable)
--     s3 &lt;- refInput " -o "
--     s4 &lt;- refOutput (file :: File)
--     return (s1 ++ s2 ++ s3 ++ s4)
--   </pre>
--   
--   Later, this command may be examined or passed to the shell function to
--   apply it to the recipe
cmd :: QuasiQuoter

-- | Define the Makefile-level variable. Rules, referring to a variable,
--   <tt>notice</tt> it's changes.
makevar :: String -> String -> Variable

-- | Declare the variable defined elsewhere. Typycally, environment
--   variables may be decalred with this functions. Variables are tracked
--   by the cake3. Rules, referring to a variable, <tt>notice</tt> it's
--   changes.
extvar :: String -> Variable
tool :: String -> Tool

-- | CommandGen is a recipe-builder packed in the newtype to prevent
--   partial expantion of it's commands
newtype CommandGen' m
CommandGen' :: A' m Command -> CommandGen' m
unCommand :: CommandGen' m -> A' m Command

-- | Reref to special variable <tt>$(MAKE)</tt>
make :: Variable
data ProjectLocation
ProjectLocation :: FilePath -> FilePath -> ProjectLocation
root :: ProjectLocation -> FilePath
off :: ProjectLocation -> FilePath
currentDirLocation :: MonadIO m => m ProjectLocation
instance Show ProjectLocation
instance Eq ProjectLocation
instance Ord ProjectLocation

module Development.Cake3.Ext.UrWeb
data UrpAllow
UrpMime :: UrpAllow
UrpUrl :: UrpAllow
UrpResponseHeader :: UrpAllow
UrpEnvVar :: UrpAllow
UrpHeader :: UrpAllow
data UrpRewrite
UrpStyle :: UrpRewrite
UrpAll :: UrpRewrite
UrpTable :: UrpRewrite
data UrpHdrToken
UrpDatabase :: String -> UrpHdrToken
UrpSql :: File -> UrpHdrToken
UrpAllow :: UrpAllow -> String -> UrpHdrToken
UrpRewrite :: UrpRewrite -> String -> UrpHdrToken
UrpLibrary :: File -> UrpHdrToken
UrpDebug :: UrpHdrToken
UrpInclude :: File -> UrpHdrToken
UrpLink :: (Either File String) -> UrpHdrToken
UrpSrc :: File -> String -> String -> UrpHdrToken
UrpPkgConfig :: String -> UrpHdrToken
UrpFFI :: File -> UrpHdrToken

-- | Module name, UrWeb name, JavaScript name
UrpJSFunc :: String -> String -> String -> UrpHdrToken
UrpSafeGet :: String -> UrpHdrToken
UrpScript :: String -> UrpHdrToken
UrpClientOnly :: String -> UrpHdrToken
data UrpModToken
UrpModule1 :: File -> UrpModToken
UrpModule2 :: File -> File -> UrpModToken
UrpModuleSys :: String -> UrpModToken
data Urp
Urp :: File -> Maybe File -> [UrpHdrToken] -> [UrpModToken] -> Urp
urp :: Urp -> File
uexe :: Urp -> Maybe File
uhdr :: Urp -> [UrpHdrToken]
umod :: Urp -> [UrpModToken]
newtype UWLib
UWLib :: Urp -> UWLib
newtype UWExe
UWExe :: Urp -> UWExe
class UrpLike x where tempfiles = (\ x -> (urpObjs x) ++ maybeToList (urpSql' x) ++ maybeToList (urpExe' x)) . toUrp
toUrp :: UrpLike x => x -> Urp
tempfiles :: UrpLike x => x -> [File]
urpDeps :: Urp -> [File]
urpSql' :: Urp -> Maybe File
urpSql :: Urp -> File
urpSrcs :: Urp -> [(File, String)]
urpObjs :: Urp -> [File]
urpLibs :: Urp -> [File]
urpExe' :: Urp -> Maybe File
urpExe :: Urp -> File
urpPkgCfg :: Urp -> [String]
data UrpState
UrpState :: Urp -> File -> UrpState
urpst :: UrpState -> Urp
urautogen :: UrpState -> File
defState :: File -> UrpState
class ToUrpWord a
toUrpWord :: ToUrpWord a => a -> String
class ToUrpLine a
toUrpLine :: ToUrpLine a => FilePath -> a -> String
maskPkgCfg :: [Char] -> [Char]
newtype UrpGen m a
UrpGen :: StateT UrpState m a -> UrpGen m a
unUrpGen :: UrpGen m a -> StateT UrpState m a
toFile :: MonadIO m => FileT FilePath -> Writer String a -> m ()
tempPrefix :: File -> String
mkFileRule :: MonadMake m => String -> Writer String a -> m File
line :: MonadWriter String m => String -> m ()
uwlib :: File -> UrpGen (Make' IO) () -> Make UWLib
uwapp :: String -> File -> UrpGen (Make' IO) () -> Make UWExe
setAutogenDir :: MonadState UrpState m => File -> m ()
addHdr :: MonadState UrpState m => UrpHdrToken -> m ()
addMod :: MonadState UrpState m => UrpModToken -> m ()
database :: MonadMake m => String -> UrpGen m ()
allow :: MonadMake m => UrpAllow -> String -> UrpGen m ()
rewrite :: MonadMake m => UrpRewrite -> String -> UrpGen m ()
urpUp :: File -> FilePath

-- | A general method of including a library into the UrWeb project.
library' :: MonadMake m => Make [File] -> UrpGen m ()

-- | Include a library defined somewhere in the current project
library :: MonadMake m => UWLib -> UrpGen m ()

-- | Build a file using external Makefile facility.
externalMake3 :: File -> File -> String -> Make [File]

-- | Build a file using external Makefile facility.
externalMake' :: File -> File -> Make [File]

-- | Build a file from external project. It is expected, that this project
--   has a <tt>Makwfile</tt> in it's root directory. Call Makefile with the
--   default target
externalMake :: File -> Make [File]

-- | Build a file from external project. It is expected, that this project
--   has a <tt>Makwfile</tt> in it's root directory
externalMakeTarget :: File -> String -> Make [File]

-- | Build a file from external project. It is expected, that this project
--   has a fiel.mk (a Makefile with an unusual name) in it's root directory
externalMake2 :: File -> Make [File]
ur :: MonadMake m => UrpModToken -> UrpGen m ()
module_ :: MonadMake m => UrpModToken -> UrpGen m ()
pair :: File -> UrpModToken
single :: File -> UrpModToken
sys :: String -> UrpModToken
debug :: MonadMake m => UrpGen m ()
include :: MonadMake m => File -> UrpGen m ()
link' :: MonadMake m => File -> String -> UrpGen m ()
link :: MonadMake m => File -> UrpGen m ()
csrc' :: MonadMake m => File -> String -> String -> UrpGen m ()
csrc :: MonadMake m => File -> UrpGen m ()
ffi :: MonadMake m => File -> UrpGen m ()
sql :: MonadMake m => File -> UrpGen m ()
jsFunc :: MonadState UrpState m => String -> String -> String -> m ()
safeGet' :: MonadMake m => String -> UrpGen m ()
safeGet :: MonadMake m => File -> String -> UrpGen m ()
url :: UrpAllow
mime :: UrpAllow
style :: UrpRewrite
all :: UrpRewrite
table :: UrpRewrite
env :: UrpAllow
hdr :: UrpAllow
requestHeader :: UrpAllow
responseHeader :: UrpAllow
script :: MonadMake m => String -> UrpGen m ()
guessMime :: String -> [Char]
pkgconfig :: MonadMake m => String -> UrpGen m ()
type BinOptions = [BinOption]
data BinOption
NoScan :: BinOption
UseUrembed :: BinOption
bin :: (MonadIO m, MonadMake m) => File -> BinOptions -> UrpGen m ()
bin' :: (MonadIO m, MonadMake m) => FilePath -> ByteString -> BinOptions -> UrpGen m ()
data JSFunc
JSFunc :: String -> String -> String -> JSFunc

-- | URS declaration for this function
urdecl :: JSFunc -> String

-- | UrWeb name of this function
urname :: JSFunc -> String

-- | JavaScript name of this function
jsname :: JSFunc -> String
data JSType
JSType :: String -> JSType
urtdecl :: JSType -> String

-- | Parse the JavaScript file, extract top-level functions, convert their
--   signatures into Ur/Web format, return them as the list of strings
parse_js :: ByteString -> Make (Either String ([JSType], [JSFunc]))
transform_css :: Stream s m Char => ParsecT s u m [Either ByteString [Char]]
parse_css :: Monad m => ByteString -> (String -> m String) -> m (Either ParseError ByteString)
instance Typeable UrpAllow
instance Typeable UrpRewrite
instance Typeable UrpHdrToken
instance Typeable UrpModToken
instance Typeable Urp
instance Typeable UWLib
instance Typeable UWExe
instance Show UrpAllow
instance Data UrpAllow
instance Show UrpRewrite
instance Data UrpRewrite
instance Show UrpHdrToken
instance Data UrpHdrToken
instance Show UrpModToken
instance Data UrpModToken
instance Show Urp
instance Data Urp
instance Show UWLib
instance Data UWLib
instance Show UWExe
instance Data UWExe
instance Show UrpState
instance Functor m => Functor (UrpGen m)
instance (Monad m, Functor m) => Applicative (UrpGen m)
instance Monad m => Monad (UrpGen m)
instance Monad m => MonadState UrpState (UrpGen m)
instance MonadMake m => MonadMake (UrpGen m)
instance MonadIO m => MonadIO (UrpGen m)
instance Show BinOption
instance Eq BinOption
instance Show JSFunc
instance Show JSType
instance ToUrpLine UrpModToken
instance ToUrpLine UrpHdrToken
instance ToUrpWord UrpRewrite
instance ToUrpWord UrpAllow
instance UrpLike UWExe
instance UrpLike UWLib
instance UrpLike Urp
instance MonadAction a m => RefInput a m UWExe
instance MonadAction a m => RefInput a m UWLib

module Development.Cake3.Utils.Find
filterExts :: [String] -> [File] -> [File]
getDirectoryContentsRecursive :: MonadIO m => File -> m [File]

module Development.Cake3.Utils.Slice

-- | Build the full Makefile named <tt>fo</tt> and a set of <tt>sliced</tt>
--   versions. <tt>Slicing</tt> here means filtering out all rules which
--   depends on certain tools (second element of <tt>sls</tt>) and all
--   upstream rules.
writeSliced :: File -> [(File, [Tool])] -> Make a -> IO ()
