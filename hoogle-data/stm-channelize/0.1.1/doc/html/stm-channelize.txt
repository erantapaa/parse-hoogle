-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Transactional I/O for duplex streams
--   
--   Turn I/O operations into STM transactions on channels.
@package stm-channelize
@version 0.1.1


-- | Wrap a network connection such that sending and receiving can be done
--   via STM transactions.
--   
--   See <a>connectHandle</a> for basic usage. See the <tt>examples</tt>
--   directory of this package for full examples.
module Control.Concurrent.STM.Channelize

-- | Open a connection, and manage it so it can be used as a
--   <a>TDuplex</a>.
--   
--   This works by spawning two threads, one which receives messages and
--   another which sends messages. If the <a>recvMsg</a> callback throws an
--   exception, it will be forwarded to the next <a>recv</a> call (once the
--   receive queue is empty).
--   
--   When the inner computation completes (or throws an exception), the
--   send queue is flushed and the connection is closed.
channelize :: IO (ChannelizeConfig msg_in msg_out) -> (TDuplex msg_in msg_out -> IO a) -> IO a

-- | An abstract object that supports sending and receiving messages in
--   STM.
--   
--   Internally, it is a pair of <a>TChan</a>s, with additional flags to
--   check for I/O errors on <a>recv</a>, and to avoid filling the send
--   queue with messages that will never be sent.
data TDuplex msg_in msg_out

-- | Read a message from the receive queue. <a>retry</a> if no message is
--   available yet.
--   
--   This will throw an exception if the reading thread encountered an
--   error, or if the connection is closed.
--   
--   Remember that STM transactions have no effect until they commit. Thus,
--   to send a message and wait for a response, you will need to use two
--   separate transactions:
--   
--   <pre>
--   <a>atomically</a> $ <a>send</a> duplex "What is your name?"
--   name &lt;- <a>atomically</a> $ <a>recv</a> duplex
--   </pre>
recv :: TDuplex msg_in msg_out -> STM msg_in

-- | Write a message to the send queue.
--   
--   If an error occurred while sending a previous message, or if the
--   connection is closed, <a>send</a> silently ignores the message and
--   returns. Rationale: suppose you have threads for clients A and B. A
--   sends a message to B. If <a>send</a> were to throw an exception on
--   failure, you might inadvertently disconnect A because of a failure
--   that is B's fault.
send :: TDuplex msg_in msg_out -> msg_out -> STM ()

-- | Like <a>send</a>, but throw an exception if the message was discarded
--   (either because <a>sendMsg</a> failed on a previous message, or
--   because the connection has been closed).
sendE :: TDuplex msg_in msg_out -> msg_out -> STM ()

-- | Callbacks telling <a>channelize</a> how to use a duplex connection.
data ChannelizeConfig msg_in msg_out
ChannelizeConfig :: IO msg_in -> (msg_out -> IO ()) -> IO () -> IO () -> ChannelizeConfig msg_in msg_out
recvMsg :: ChannelizeConfig msg_in msg_out -> IO msg_in

-- | Callbacks for sending and receiving messages. All calls of
--   <a>recvMsg</a> will be in one thread, and all calls of <a>sendMsg</a>
--   will be in another thread. If <a>recvMsg</a> throws an exception, it
--   will not be called again. If <a>sendMsg</a> throws an exception, it
--   will not be called again, nor will <a>sendBye</a> be called.
--   
--   This means it is safe to use an <a>IORef</a> to pass state from one
--   <a>recvMsg</a> or <a>sendMsg</a> call to the next. However, to share
--   state between <a>recvMsg</a> and <a>sendMsg</a>, you will need to use
--   thread synchronization (e.g. <a>MVar</a>, <a>STM</a>).
sendMsg :: ChannelizeConfig msg_in msg_out -> msg_out -> IO ()

-- | Action to call before closing the connection, but only if none of the
--   send calls failed. This is called from the same thread as
--   <a>sendMsg</a>.
sendBye :: ChannelizeConfig msg_in msg_out -> IO ()

-- | Callback for closing the connection. Called when <a>channelize</a>
--   completes.
connClose :: ChannelizeConfig msg_in msg_out -> IO ()

-- | Treat <a>stdin</a> and <a>stdout</a> as a "connection", where each
--   message corresponds to a line.
--   
--   This sets the buffering mode of <a>stdin</a> and <a>stdout</a> to
--   <a>LineBuffering</a>.
connectStdio :: IO (ChannelizeConfig String String)

-- | Wrap a duplex <a>Handle</a> in a <a>ChannelizeConfig</a>. Each message
--   corresponds to a line.
--   
--   Example (client):
--   
--   <pre>
--   let connect = connectTo "localhost" (PortNumber 1234) &gt;&gt;= connectHandle
--    in channelize connect $ \duplex -&gt; do
--           ...
--   </pre>
--   
--   Example (Telnet server):
--   
--   <pre>
--   (handle, host, port) &lt;- accept sock
--   putStrLn $ "Accepted connection from " ++ host ++ ":" ++ show port
--   
--   -- Swallow carriage returns sent by telnet clients
--   hSetNewlineMode handle universalNewlineMode
--   
--   forkIO $ channelize (connectHandle handle) $ \duplex -&gt; do
--       ...
--   </pre>
connectHandle :: Handle -> IO (ChannelizeConfig String String)

-- | Perform a read action on a <a>Handle</a>. Try to ensure that it can be
--   interrupted by an asynchronous exception.
--   
--   On Windows with -threaded, a thread reading a <a>Handle</a> cannot be
--   interrupted by an asynchronous exception. The exception will not be
--   delivered until the receive operation completes or fails.
--   
--   <a>hGetInterruptible</a> works around this problem (when present) by
--   calling <a>hWaitForInput</a> over and over with a delay of one second.
hGetInterruptible :: (Handle -> IO a) -> Handle -> IO a
data ChannelizeException
ChannelizeClosedRecv :: ChannelizeException
ChannelizeClosedSend :: ChannelizeException
instance Typeable ChannelizeException
instance Typeable ChannelizeKill
instance Show ChannelizeKill
instance Exception ChannelizeKill
instance Exception ChannelizeException
instance Show ChannelizeException
