-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Framework for inferring generative probabilistic models
with Gibbs sampling
--   
--   bayes-stack is a framework for inference on generative probabilistic
--   models. The framework uses Gibbs sampling, although is suitable for
--   other iterative update methods.
@package bayes-stack
@version 0.2.0.1

module Data.Sequence.Chunk

-- | 'chunk n xs' splits <tt>xs</tt> into <tt>n</tt> chunks
chunk :: Int -> Seq a -> Seq (Seq a)

module Data.Random.Sequence
randomElementT :: Seq a -> RVarT m a

module BayesStack.TupleEnum
instance (Enum a, Enum b) => Enum (a, b)

module BayesStack.UniqueKey
getUniqueKey :: (Monad m, Applicative m, Ord key, Ord val) => val -> UniqueKeyT val key m key

-- | Get map of values to unique keys
getValueMap :: (Monad m, Applicative m, Ord key, Ord val) => UniqueKeyT val key m (Map val key)

-- | Get map of unique keys to values
getKeyMap :: (Monad m, Applicative m, Ord key, Ord val) => UniqueKeyT val key m (Map key val)
mapTraversable :: (Traversable t, Ord key, Ord val) => [key] -> t val -> (t key, Map key val)

-- | 'UniqueKey val key' is a monad for a calculation of a mapping unique
--   keys <tt>key</tt> onto values <tt>val</tt>
type UniqueKey val key = UniqueKeyT val key Identity
data UniqueKeyT val key m a
runUniqueKey :: Ord key => [key] -> UniqueKey val key a -> a
runUniqueKeyT :: (Monad m, Ord key) => [key] -> UniqueKeyT val key m a -> m a

-- | Run a <a>UniqueKey</a>, returning the result and the associated key
--   map
runUniqueKey' :: (Ord key, Ord val) => [key] -> UniqueKey val key a -> (a, Map key val)

-- | Run a <a>UniqueKeyT</a>, returning the result and the associated key
--   map
runUniqueKeyT' :: (Monad m, Applicative m, Ord key, Ord val) => [key] -> UniqueKeyT val key m a -> m (a, Map key val)
instance Monad m => Monad (UniqueKeyT val key m)
instance (Monad m, Functor m) => Applicative (UniqueKeyT val key m)
instance Functor m => Functor (UniqueKeyT val key m)
instance MonadTrans (UniqueKeyT val key)

module Data.Serialize.LogFloat
instance Serialize LogFloat

module Data.Serialize.EnumMap
instance (Enum k, Serialize k, Serialize v) => Serialize (EnumMap k v)

module BayesStack.Dirichlet

-- | A Dirichlet prior
data Alpha a
symAlpha :: Enum a => [a] -> Double -> Alpha a

-- | Construct an asymmetric Alpha
asymAlpha :: Enum a => EnumMap a Double -> Alpha a

-- | 'alphaDomain a' is the domain of prior <tt>a</tt>
alphaDomain :: Enum a => Alpha a -> Seq a
alphaNormalizer :: Enum a => Alpha a -> LogFloat

-- | 'sumAlpha alpha' is the sum of all alphas
sumAlpha :: Enum a => Alpha a -> Double
type DirMean a = EnumMap a Double
type DirPrecision = Double

-- | 'alphaOf alpha k' is the value of element <tt>k</tt> in prior
--   <tt>alpha</tt>
alphaOf :: Enum a => Alpha a -> a -> Double

-- | Set a particular alpha element
setAlphaOf :: Enum a => a -> Double -> Alpha a -> Alpha a
setSymAlpha :: Enum a => Double -> Alpha a -> Alpha a

-- | 'alphaToMeanPrecision a' is the mean/precision representation of the
--   prior <tt>a</tt>
alphaToMeanPrecision :: Enum a => Alpha a -> (DirMean a, DirPrecision)

-- | 'meanPrecisionToAlpha m p' is a prior with mean <tt>m</tt> and
--   precision <a>p</a>
meanPrecisionToAlpha :: Enum a => DirMean a -> DirPrecision -> Alpha a

-- | Symmetrize a Dirichlet prior (such that mean=0)
symmetrizeAlpha :: Enum a => Alpha a -> Alpha a

-- | Pretty-print a Dirichlet prior
prettyAlpha :: Enum a => (a -> String) -> Alpha a -> Doc
instance (Enum a, Show a) => Show (Alpha a)
instance Eq a => Eq (Alpha a)
instance Generic (Alpha a)
instance Datatype D1Alpha
instance Constructor C1_0Alpha
instance Constructor C1_1Alpha
instance Selector S1_0_0Alpha
instance Selector S1_0_1Alpha
instance Selector S1_0_2Alpha
instance Selector S1_1_0Alpha
instance Selector S1_1_1Alpha
instance Selector S1_1_2Alpha
instance (Enum a, Serialize a) => Serialize (Alpha a)

module BayesStack.Core.Gibbs
class UpdateUnit uu where type family ModelState uu type family Setting uu
fetchSetting :: UpdateUnit uu => uu -> ModelState uu -> Setting uu
evolveSetting :: UpdateUnit uu => ModelState uu -> uu -> RVar (Setting uu)
updateSetting :: UpdateUnit uu => uu -> Setting uu -> Setting uu -> ModelState uu -> ModelState uu
data WrappedUpdateUnit ms
WrappedUU :: uu -> WrappedUpdateUnit ms
gibbsUpdate :: Int -> ms -> [WrappedUpdateUnit ms] -> IO ms

module BayesStack.Core.Types
type Probability = LogFloat
class HasLikelihood p where type family LContext p a :: Constraint type instance LContext p a = ()
likelihood :: (HasLikelihood p, LContext p a) => p a -> Probability
prob :: (HasLikelihood p, LContext p a) => p a -> a -> Probability

-- | A distribution for which a full conditional factor can be produced
class FullConditionable p where type family FCContext p a :: Constraint type instance FCContext p a = ()
sampleProb :: (FullConditionable p, FCContext p a) => p a -> a -> Double

module BayesStack.Core

module BayesStack.DirMulti

-- | 'Multinom a' represents multinomial distribution over domain
--   <tt>a</tt>. Optionally, this can include a collapsed Dirichlet prior.
--   'Multinom alpha count total' is a multinomial with Dirichlet prior
--   with symmetric parameter <tt>alpha</tt>, ...
data Multinom a

-- | Create an asymmetric Dirichlet/multinomial from items and alphas
dirMulti :: Enum a => [(a, Double)] -> Multinom a

-- | Create a symmetric Dirichlet/multinomial
symDirMulti :: Enum a => Double -> [a] -> Multinom a

-- | A multinomial without a prior
multinom :: Enum a => [(a, Double)] -> Multinom a
dmTotal :: Multinom a -> Int
dmAlpha :: Multinom a -> Alpha a
dmDomain :: Multinom a -> Seq a
setMultinom :: (Enum a, Ord a) => SetUnset -> a -> Multinom a -> Multinom a
data SetUnset
Set :: SetUnset
Unset :: SetUnset
decMultinom :: (Ord a, Enum a) => a -> Multinom a -> Multinom a
incMultinom :: (Ord a, Enum a) => a -> Multinom a -> Multinom a
prettyMultinom :: (Ord a, Enum a) => Int -> (a -> String) -> Multinom a -> Doc

-- | Update the prior of a Dirichlet/multinomial
updatePrior :: (Alpha a -> Alpha a) -> Multinom a -> Multinom a
estimatePrior :: Enum a => Double -> [Multinom a] -> Alpha a
reestimatePriors :: (Foldable f, Functor f, Enum a) => f (Multinom a) -> f (Multinom a)
reestimateSymPriors :: (Foldable f, Functor f, Enum a) => f (Multinom a) -> f (Multinom a)
probabilities :: (Ord a, Enum a) => Multinom a -> Seq (Double, a)

-- | Probabilities sorted decreasingly
decProbabilities :: (Ord a, Enum a) => Multinom a -> Seq (Double, a)
instance (Enum a, Show a) => Show (Multinom a)
instance Eq a => Eq (Multinom a)
instance Generic (Multinom a)
instance Datatype D1Multinom
instance Constructor C1_0Multinom
instance Constructor C1_1Multinom
instance Selector S1_0_0Multinom
instance Selector S1_0_1Multinom
instance Selector S1_0_2Multinom
instance Selector S1_0_3Multinom
instance Selector S1_1_0Multinom
instance Selector S1_1_1Multinom
instance Selector S1_1_2Multinom
instance Selector S1_1_3Multinom
instance FullConditionable Multinom
instance HasLikelihood Multinom
instance (Enum a, Serialize a) => Serialize (Multinom a)
