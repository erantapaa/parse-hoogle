-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Client API for Rocket Scissor Spacegoo
--   
@package haskell-spacegoo
@version 0.2.0.1


-- | This module provides you with everything to quicky write clients for
--   the GPN13 Spacegoo programming contest. Essentially you write a
--   function of type <a>Strategy</a> that takes the <a>State</a> and may
--   return a <a>Move</a>. If you pass such a function to <tt>clients</tt>,
--   you are good to go. See the examples section for some examples.
module Game.Spacegoo

-- | The player (0,1 or 2)
type PlayerId = Int

-- | A Round count
type Round = Int

-- | Units, either on a planet, on a fleet, or as a production indication.
type Units = (Int, Int, Int)

-- | A position on the map
type Coord = (Int, Int)
data Player
Player :: Bool -> PlayerId -> Text -> Player
itsme :: Player -> Bool
playerId :: Player -> PlayerId
name :: Player -> Text
data Fleet
Fleet :: Int -> PlayerId -> Int -> Int -> Units -> Int -> Fleet
fleetId :: Fleet -> Int
fleetOwner :: Fleet -> PlayerId
origin :: Fleet -> Int
target :: Fleet -> Int
fleetShips :: Fleet -> Units
eta :: Fleet -> Int
data Planet
Planet :: Int -> Coord -> PlayerId -> Units -> Units -> Planet
planetId :: Planet -> Int
position :: Planet -> Coord
planetOwner :: Planet -> PlayerId
production :: Planet -> Units
planetShips :: Planet -> Units
data State
State :: Bool -> Round -> Round -> [Player] -> [Fleet] -> [Planet] -> State
gameOver :: State -> Bool
currentRound :: State -> Round
maxRounds :: State -> Round
players :: State -> [Player]
fleets :: State -> [Fleet]
planets :: State -> [Planet]

-- | A Move contains the id of a source planet, the id or a target planet,
--   and the number of ships to send
type Move = Maybe (Int, Int, Units)
type Strategy = State -> Move

-- | This is your main entry point to play one round of the game.
client :: Int -> String -> String -> String -> Strategy -> IO ()

-- | My id
me :: State -> Int

-- | The other players id
he :: State -> Int

-- | The opponent's name; to filter out known bad opponents
opponentName :: State -> Text

-- | Whether the first argument wins against the second, and how many ships
--   are left
battle :: Units -> Units -> (Bool, Units)

-- | Whether the first fleet wins against the second (defaulting to the
--   second)
winsAgainst :: Units -> Units -> Bool
distance :: Planet -> Planet -> Int

-- | Whether the first player has at least as many ships as the other
hasMore :: Units -> Units -> Bool

-- | Predict the owner and strength of the planet at the given round
ownerAt :: State -> Int -> Round -> (PlayerId, Units)
linInt :: Double -> Units -> Units -> Units
nemesisOf :: Units -> Units
minimizeUnits :: Units -> Units -> Units

-- | The dead man strategy. Usually not very effective.
nop :: Strategy

-- | Picks an own planet with a reasonable number of ships and sends it to
--   some neutral planet.
attackNeutral :: Strategy

-- | From any own planet, send all ships to any opposing planet.
sendSomewhere :: Strategy

-- | Look for an opposing fleet. If we have a planet with more ships than
--   the opposing fleet that would arrive shortly after that, send a fleet
--   the same size as the opposing fleet.
intercept :: Strategy
instance Show Player
instance Show Fleet
instance Show Planet
instance Show State
instance FromJSON State
instance FromJSON Planet
instance FromJSON Fleet
instance FromJSON Player
