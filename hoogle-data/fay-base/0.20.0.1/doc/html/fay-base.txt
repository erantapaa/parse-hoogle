-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The base package for Fay.
--   
@package fay-base
@version 0.20.0.1

module Data.Data

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable * a => Data a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

module Prelude

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Arbitrary-precision integers.
data Integer :: *
data Bool :: *
False :: Bool
True :: Bool

-- | Parsing of <a>String</a>s, producing values.
--   
--   Minimal complete definition: <a>readsPrec</a> (or, for GHC only,
--   <a>readPrec</a>)
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
class Read a

-- | Conversion of values to readable <a>String</a>s.
--   
--   Minimal complete definition: <a>showsPrec</a> or <a>show</a>.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Maybe type.
--   
--   Either type.
maybe :: t -> (t1 -> t) -> Maybe t1 -> t

-- | Monomorphic bind for Fay.
(>>=) :: Ptr (Fay a) -> Ptr (a -> Fay b) -> Ptr (Fay b)

-- | Monomorphic then for Fay.
(>>) :: Ptr (Fay a) -> Ptr (Fay b) -> Ptr (Fay b)

-- | Monomorphic return for Fay.
return :: a -> Fay a
fail :: String -> Fay a
when :: Bool -> Fay () -> Fay ()
unless :: Bool -> Fay () -> Fay ()
forM :: [a] -> (a -> Fay b) -> Fay [b]
forM_ :: [a] -> (a -> Fay b) -> Fay ()
mapM :: (a -> Fay b) -> [a] -> Fay [b]
mapM_ :: (a -> Fay b) -> [a] -> Fay ()
(=<<) :: (a -> Fay b) -> Fay a -> Fay b

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: [Fay a] -> Fay [a]
sequence_ :: [Fay a] -> Fay ()
void :: Fay a -> Fay ()
(>=>) :: (a -> Fay b) -> (b -> Fay c) -> a -> Fay c
(<=<) :: (b -> Fay c) -> (a -> Fay b) -> a -> Fay c
(*) :: Num a => a -> a -> a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
class Eq a => Ord a
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering
compare :: Ord a => a -> a -> Ordering
succ :: Num a => a -> a
pred :: Num a => a -> a
enumFrom :: Num a => a -> [a]
enumFromTo :: (Ord t, Num t) => t -> t -> [t]
enumFromBy :: Num t => t -> t -> [t]
enumFromThen :: Num t => t -> t -> [t]
enumFromByTo :: (Ord t, Num t) => t -> t -> t -> [t]
enumFromThenTo :: (Ord t, Num t) => t -> t -> t -> [t]
(/) :: Fractional a => a -> a -> a
fromIntegral :: (Num a, Num b) => Ptr a -> Ptr b
fromInteger :: Num a => Ptr Integer -> Ptr a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
not :: Bool -> Bool
otherwise :: Bool

-- | Uses JSON.stringify.
show :: Automatic a -> String

-- | Throws a JavaScript error.
error :: String -> a

-- | Throws "undefined" via "error".
undefined :: a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
data Either a b :: * -> * -> *
Left :: a -> Either a b
Right :: b -> Either a b
either :: (a -> c) -> (b -> c) -> Either a b -> c
until :: (a -> Bool) -> (a -> a) -> a -> a
($!) :: (a -> b) -> a -> b

-- | Evaluates its first argument to head normal form, and then returns its
--   second argument as the result.
seq :: a -> b -> b
const :: a -> b -> a
id :: a -> a
(.) :: (t1 -> t) -> (t2 -> t1) -> t2 -> t
($) :: (t1 -> t) -> t1 -> t
flip :: (t1 -> t2 -> t) -> t2 -> t1 -> t
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
snd :: (t, t1) -> t1
fst :: (t, t1) -> t
div :: Int -> Int -> Int
mod :: Int -> Int -> Int
divMod :: Int -> Int -> (Int, Int)
min :: Num a => a -> a -> a
max :: Num a => a -> a -> a
recip :: Double -> Double

-- | Implemented in Fay.
negate :: Num a => a -> a

-- | Implemented in Fay.
abs :: (Num a, Ord a) => a -> a

-- | Implemented in Fay.
signum :: (Num a, Ord a) => a -> a

-- | Uses Math.PI.
pi :: Double

-- | Uses Math.exp.
exp :: Double -> Double

-- | Uses Math.sqrt.
sqrt :: Double -> Double

-- | Uses Math.log.
log :: Double -> Double

-- | Uses Math.pow.
(**) :: Double -> Double -> Double

-- | Uses Math.pow.
(^^) :: Double -> Int -> Double

-- | Uses Math.pow.
unsafePow :: (Num a, Num b) => a -> b -> a

-- | Implemented in Fay, it's not fast.
(^) :: Num a => a -> Int -> a

-- | Implemented in Fay, not fast.
logBase :: Double -> Double -> Double

-- | Uses Math.sin.
sin :: Double -> Double

-- | Uses Math.tan.
tan :: Double -> Double

-- | Uses Math.cos.
cos :: Double -> Double

-- | Uses Math.asin.
asin :: Double -> Double

-- | Uses Math.atan.
atan :: Double -> Double

-- | Uses Math.acos.
acos :: Double -> Double

-- | Implemented in Fay, not fast.
sinh :: Double -> Double

-- | Implemented in Fay, not fast.
tanh :: Double -> Double

-- | Implemented in Fay, not fast.
cosh :: Double -> Double

-- | Implemented in Fay, not fast.
asinh :: Double -> Double

-- | Implemented in Fay, not fast.
atanh :: Double -> Double

-- | Implemented in Fay, not fast.
acosh :: Double -> Double

-- | Implemented in Fay, not fast.
properFraction :: Double -> (Int, Double)

-- | Implemented in Fay, not fast.
truncate :: Double -> Int

-- | Uses Math.round.
round :: Double -> Int

-- | Uses Math.ceil.
ceiling :: Double -> Int

-- | Uses Math.floor.
floor :: Double -> Int

-- | Flip (-).
subtract :: Num a => a -> a -> a

-- | Implemented in Fay, not fast.
even :: Int -> Bool

-- | not (even x)
odd :: Int -> Bool

-- | Implemented in Fay, not fast.
gcd :: Int -> Int -> Int

-- | Uses quot'.
quot :: Int -> Int -> Int

-- | Uses ~~(a/b).
quot' :: Int -> Int -> Int

-- | (quot x y, rem x y)
quotRem :: Int -> Int -> (Int, Int)

-- | Uses rem'.
rem :: Int -> Int -> Int

-- | Uses %%.
rem' :: Int -> Int -> Int
lcm :: Int -> Int -> Int
find :: (a -> Bool) -> [a] -> Maybe a
filter :: (a -> Bool) -> [a] -> [a]
null :: [t] -> Bool
map :: (a -> b) -> [a] -> [b]
nub :: Eq a => [a] -> [a]
nub' :: Eq a => [a] -> [a] -> [a]
elem :: Eq a => a -> [a] -> Bool
notElem :: Eq a => a -> [a] -> Bool
sort :: Ord a => [a] -> [a]
sortBy :: (t -> t -> Ordering) -> [t] -> [t]
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | Append two lists.
conc :: [a] -> [a] -> [a]
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
foldr :: (t -> t1 -> t1) -> t1 -> [t] -> t1
foldr1 :: (a -> a -> a) -> [a] -> a
foldl :: (t1 -> t -> t1) -> t1 -> [t] -> t1
foldl1 :: (a -> a -> a) -> [a] -> a
(++) :: [a] -> [a] -> [a]
(!!) :: [a] -> Int -> a
head :: [a] -> a
tail :: [a] -> [a]
init :: [a] -> [a]
last :: [a] -> a
iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
lines :: String -> [String]
unlines :: [String] -> String
words :: String -> [String]
unwords :: [String] -> String
and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
intersperse :: a -> [a] -> [a]
prependToAll :: a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
maximum :: Num a => [a] -> a
minimum :: Num a => [a] -> a
product :: Num a => [a] -> a
sum :: Num a => [a] -> a
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
lookup :: Eq a1 => a1 -> [(a1, a)] -> Maybe a
length :: [a] -> Int
length' :: Int -> [a] -> Int
reverse :: [a] -> [a]
print :: Automatic a -> Fay ()
putStrLn :: String -> Fay ()

-- | Default definition for using RebindableSyntax.
ifThenElse :: Bool -> t -> t -> t

-- | The JavaScript FFI interfacing monad.
data Fay a :: * -> *
instance Integral Int
instance Fractional Double
instance Enum Int
instance Ord Integer
instance Ord Int
instance Ord Double
instance Ord Char
instance Num Double
instance Num Int


-- | Either operations.
module Data.Either

-- | Basically forM.
whenLeft :: Either a b -> (a -> Fay c) -> Fay (Maybe c)

-- | Basically forM.
whenRight :: Either a b -> (b -> Fay c) -> Fay (Maybe c)

-- | Usual isLeft.
isLeft :: Either a b -> Bool

-- | Usual isRight.
isRight :: Either a b -> Bool


-- | Maybe functions.
module Data.Maybe

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
fromMaybe :: a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
maybeToList :: Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
listToMaybe :: [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it just <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
mapMaybeFB :: (b -> r -> r) -> (a -> Maybe b) -> a -> r -> r

-- | Handy alternative to not having forM.
whenJust :: Maybe a -> (a -> Fay ()) -> Fay ()

-- | Similar to forM again.
whenJust' :: Maybe a -> (a -> Fay b) -> Fay (Maybe b)

-- | Basically fmap for Maybe.
onJust :: (a -> b) -> Maybe a -> Maybe b

-- | Join for Maybe.
joinMaybe :: Maybe (Maybe a) -> Maybe a

module Data.List

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. Both lists must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   stripPrefix "foo" "foobar" == Just "bar"
--   stripPrefix "foo" "foo" == Just ""
--   stripPrefix "foo" "barfoo" == Nothing
--   stripPrefix "foo" "barfoobaz" == Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Like <a>stripPrefix</a>, but drops the given suffix from the end.
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Split lists at delimiter specified by a condition Drops empty groups
--   (similar to <a>words</a>)
splitWhen :: (a -> Bool) -> [a] -> [[a]]

-- | Split lists at the specified delimiter Drops empty groups (similar to
--   <a>words</a>)
splitOn :: Eq a => a -> [a] -> [[a]]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   inits "abc" == ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]
groupSortBy :: (a -> a -> Ordering) -> [a] -> [[a]]

-- | Classic group by.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | Belongs in Control.Monad, right?
findM :: (a -> Fay (Maybe b)) -> [a] -> Fay (Maybe b)

module Data.Char
chr :: Int -> Char
ord :: Char -> Int
isAscii :: Char -> Bool
isLatin1 :: Char -> Bool
toUpper :: Char -> Char
toLower :: Char -> Char
isAsciiLower :: Char -> Bool
isAsciiUpper :: Char -> Bool
isDigit :: Char -> Bool
isOctDigit :: Char -> Bool
isHexDigit :: Char -> Bool
isSpace :: Char -> Bool


-- | Orderings
module Data.Ord

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering


-- | Functions
module Data.Function

-- | (*) <a>on</a> f = x y -&gt; f x * f y.
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

-- | The "f" is for "Fay", not "Functor" ;)
fmap :: (a -> b) -> Fay a -> Fay b

-- | See <a>&lt;*&gt;</a>.
ap :: Fay (a -> b) -> Fay a -> Fay b

-- | A la Control.Applicative.
(<*>) :: Fay (a -> b) -> Fay a -> Fay b

module FFI


-- | Unsafe coerce.
module Unsafe.Coerce
unsafeCoerce :: a -> b


-- | Exception handling.
module Control.Exception

-- | Try the given action and catch if there's an error.
onException :: Fay a -> Fay a -> Fay a

-- | Try the given action and catch the exception.
catch :: Fay a -> (Automatic e -> Fay a) -> Fay a

-- | Throw an exception.
throw :: Automatic e -> Fay a

module Debug.Trace
trace :: String -> Ptr a -> Ptr a
traceShow :: Automatic a -> Ptr b -> Ptr b


-- | Functions for the <a>Defined</a> type.
module Data.Defined

-- | Convert from defined to maybe.
fromDefined :: Defined a -> Maybe a

-- | Convert from maybe to defined.
toDefined :: Maybe a -> Defined a

module Data.Var

-- | A subscribable signal. Can have handlers subscribed to them, but
--   doesn't store a value.
data Sig a

-- | Make a new signal.
newSig :: Fay (Ptr (Sig a))

-- | A mutable reference, with no subscribers.
data Ref a

-- | Make a new mutable reference.
newRef :: Ptr a -> Fay (Ptr (Ref a))

-- | A reactive variable. Stores a value, and can have handlers subscribed
--   to changes.
data Var a

-- | Make a new reactive variable.
newVar :: Ptr a -> Fay (Ptr (Var a))

-- | All of the variable types can be set to a value.
class Settable v

-- | Write to the value (if any), and call subscribers (if any).
set :: Settable (v a) => Ptr (v a) -> Ptr a -> Fay ()

-- | <a>Ref</a> and <a>Var</a> store their last set value.
class Gettable v

-- | Get the value of a <a>Ref</a> or <a>Var</a>.
get :: Gettable (v a) => Ptr (v a) -> Fay (Ptr a)

-- | Modifies the current value with a pure function.
modify :: (Settable (v a), Gettable (v a)) => v a -> (a -> a) -> Fay ()

-- | Runs a <a>Fay</a> action on the current value, and updates with the
--   result.
modifyWith :: (Settable (v a), Gettable (v a)) => v a -> (a -> Fay a) -> Fay ()

-- | <a>Sig</a> and <a>Var</a> have lists of subscribers that are notified
--   when <a>set</a> is used.
class Settable v => Subscribable v

-- | Subscribe to the value of a <a>Sig</a> or <a>Var</a>.
--   
--   The result is an unsubscribe function.
subscribe :: Subscribable (v a) => Ptr (v a) -> Ptr (a -> Fay void) -> Fay (() -> Fay ())

-- | Run the same subscribing action but provide an additional unsubscribe
--   parameter to the handler.
withUnsubscriber :: ((a -> Fay ()) -> Fay (() -> Fay ())) -> (((() -> Fay ()) -> a -> Fay ()) -> Fay (() -> Fay ()))

-- | Subscribe to a <a>Var</a>, along with the previous value.
--   
--   The result is an unsubscribe function.
subscribeWithOld :: Var a -> (a -> a -> Fay ()) -> Fay (() -> Fay ())

-- | Subscribe to a <a>Var</a>, but only call handler when it actually
--   changes.
--   
--   The result is an unsubscribe function.
subscribeChange :: Eq a => Var a -> (a -> Fay ()) -> Fay (() -> Fay ())

-- | Subscribe to a <a>Var</a>, and call the function on the current value.
--   
--   The result is an unsubscribe function.
subscribeAndRead :: Var a -> (a -> Fay void) -> Fay (() -> Fay ())

-- | Subscribe to a <a>Var</a>, but only call handler when it actually
--   changes, and also initially on registration.
--   
--   The result is an unsubscribe function.
subscribeChangeAndRead :: Eq a => Var a -> (a -> Fay ()) -> Fay (() -> Fay ())

-- | Given a change handler, returns a function that can be used to set a
--   subscribable without invoking the handler. This can be useful in
--   situations where the handler for a <a>Var</a> causes an event which
--   otherwise ought to set the value of the <a>Var</a>. An example of this
--   is interfacing with HTML input field change events.
--   
--   The <a>snd</a> part of the result is an unsubscribe function.
subscribeExclusive :: Subscribable (v a) => v a -> (a -> Fay ()) -> Fay (a -> Fay (), () -> Fay ())

-- | Given a change handler, returns a function that can be used to set a
--   var without invoking the handler. The handler is called with the
--   initial value. This can be useful in situations where the handler for
--   a <a>Var</a> causes an event which otherwise ought to set the value of
--   the <a>Var</a>. An example of this is interfacing with HTML input
--   field change events.
--   
--   The <a>snd</a> part of the result is an unsubscribe function.
subscribeAndReadExclusive :: Var a -> (a -> Fay ()) -> Fay (a -> Fay (), () -> Fay ())

-- | Creates a <a>Var</a> that updates whenever the source var is changed,
--   applying the provided function to compute the new value.
mapVar :: (a -> b) -> Var a -> Fay (Var b)

-- | Creates a <a>Var</a> that updates whenever one of its source vars are
--   changed. If the 2nd argument is a <a>Just</a> value, then its used to
--   set the source vars when the variable is changed. Setting using a
--   merged var is sometimes preferred because both values are set before
--   the subscribers are called.
--   
--   The <a>snd</a> part of the result is an unsubscribe function.
mergeVars :: (a -> b -> c) -> Maybe (c -> (a, b)) -> Var a -> Var b -> Fay (Var c, Fay ())

-- | Like <a>mergeVars</a>, but discards the unsubscribe function.
mergeVars' :: (a -> b -> c) -> Maybe (c -> (a, b)) -> Var a -> Var b -> Fay (Var c)

-- | Creates a <a>Var</a> that updates whenever one of its source vars are
--   changed. It can also be used to set both source vars at once.
--   
--   See <a>mergeVars</a> for more information. Note that when using nested
--   tuples, if you want all of the values to be set before broadcast, then
--   they should nest to the left.
tupleVars :: Var a -> Var b -> Fay (Var (a, b), Fay ())

-- | Like <a>tupleVars</a>, but discards the unsubscribe function.
tupleVars' :: Var a -> Var b -> Fay (Var (a, b))

-- | Wait for n signals on the given signaller.
waitForN :: Int -> Fay (Fay void -> Fay (), Sig ())

-- | Wait for the given predicate to be satisfied on the var and then
--   unsubscribe.
waitFor :: Var a -> (a -> Bool) -> (a -> Fay ()) -> Fay ()

-- | Make a one-shot variable subscription that immediately unsubscribes
--   after the event has triggered.
oneShot :: Subscribable (v a) => v a -> (a -> Fay ()) -> Fay ()

-- | Turn a sig into a var, by storing the last reported value.
holdSig :: a -> Sig a -> Fay (Var a)
instance Subscribable (Var a)
instance Subscribable (Sig a)
instance Gettable (Var a)
instance Gettable (Ref a)
instance Settable (Var a)
instance Settable (Sig a)
instance Settable (Ref a)


-- | A trivial mutex.
module Data.Mutex
data Mutex
Mutex :: (Var Bool) -> Mutex

-- | Make a new unlocked mutex.
newMutex :: Fay Mutex

-- | If a mutex is free run the action, otherwise don't.
ifMutexFree :: Mutex -> Fay () -> Fay ()

-- | Wait until the mutex is free to do something.
whenMutexFree :: Mutex -> Fay () -> Fay ()

-- | Lock the given mutex until I'm done with it.
lockMutex :: Mutex -> (Fay () -> Fay a) -> Fay a


-- | Nullable functions.
module Data.Nullable

-- | Convert from nullable to maybe.
fromNullable :: Nullable a -> Maybe a

-- | Convert from maybe to nullable.
toNullable :: Maybe a -> Nullable a


-- | Unsafe running of Fay actions in pure code.
module Fay.Unsafe

-- | Run a Fay action as a pure value.
unsafePerformFay :: Fay a -> a

module Data.Ratio
data Rational
Ratio :: Int -> Int -> Rational
(%) :: Int -> Int -> Rational
numerator :: Rational -> Int
denominator :: Rational -> Int
instance Typeable Rational
instance Data Rational
instance Show Rational


-- | Compatible API with the <tt>text</tt> package.
module Data.Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | O(n) Convert a String into a Text. Subject to fusion. Performs
--   replacement on invalid scalar values.
pack :: String -> Text

-- | O(n) Convert a Text into a String. Subject to fusion.
unpack :: Text -> String

-- | Convert from a string to text.
fromString :: String -> Text

-- | O(1) The empty Text.
empty :: Text
showInt :: Int -> Text
toShortest :: Double -> Text
putStrLn :: Text -> Fay ()

-- | O(m+n) Break a Text into pieces separated by the first Text argument,
--   consuming the delimiter. An empty delimiter is invalid, and will cause
--   an error to be raised.
splitOn :: Char -> Text -> [Text]

-- | O(n) Return the prefix of the second string if its suffix matches the
--   entire first string.
stripSuffix :: Text -> Text -> Maybe Text

-- | O(n) Adds a character to the front of a Text. This function is more
--   costly than its List counterpart because it requires copying a new
--   array. Subject to fusion. Performs replacement on invalid scalar
--   values.
cons :: Char -> Text -> Text

-- | O(n) Adds a character to the end of a Text. This copies the entire
--   array in the process, unless fused. Subject to fusion. Performs
--   replacement on invalid scalar values.
snoc :: Text -> Char -> Text

-- | O(n) Appends one Text to the other by copying both of them into a new
--   Text. Subject to fusion.
append :: Text -> Text -> Text

-- | Append two texts.
(<>) :: Text -> Text -> Text

-- | O(1) Returns the first character and rest of a Text, or Nothing if
--   empty. Subject to fusion.
uncons :: Text -> Maybe (Char, Text)

-- | O(1) Returns the first character of a Text, which must be non-empty.
--   Subject to fusion.
head :: Text -> Char

-- | O(1) Returns all but the last character of a Text, which must be
--   non-empty. Subject to fusion.
init :: Text -> Text

-- | O(1) Returns the last character of a Text, which must be non-empty.
--   Subject to fusion.
last :: Text -> Char

-- | O(1) Returns all characters after the head of a Text, which must be
--   non-empty. Subject to fusion.
tail :: Text -> Text

-- | O(1) Tests whether a Text is empty or not. Subject to fusion.
null :: Text -> Bool

-- | O(n) Returns the number of characters in a Text. Subject to fusion.
length :: Text -> Int

-- | O(n) maximum returns the maximum value from a Text, which must be
--   non-empty. Subject to fusion.
maximum :: Text -> Char

-- | O(n) all p t determines whether all characters in the Text t satisify
--   the predicate p. Subject to fusion.
all :: (Char -> Bool) -> Text -> Bool

-- | O(n) any p t determines whether any character in the Text t satisifes
--   the predicate p. Subject to fusion.
any :: (Char -> Bool) -> Text -> Bool

-- | O(n) Map a function over a Text that results in a Text, and
--   concatenate the results.
concatMap :: (Char -> Text) -> Text -> Text

-- | O(n) Concatenate a list of Texts.
concat :: [Text] -> Text

-- | O(n) minimum returns the minimum value from a Text, which must be
--   non-empty. Subject to fusion.
minimum :: Text -> Char

-- | O(n) Convert a string to lower case, using simple case conversion. The
--   result string may be longer than the input string. For instance, "İ"
--   (Latin capital letter I with dot above, U+0130) maps to the sequence
--   "i" (Latin small letter i, U+0069) followed by " ̇" (combining dot
--   above, U+0307).
toLower :: Text -> Text

-- | O(n) Convert a string to upper case, using simple case conversion. The
--   result string may be longer than the input string. For instance, the
--   German "ß" (eszett, U+00DF) maps to the two-letter sequence <a>SS</a>.
toUpper :: Text -> Text

-- | O(n) map f t is the Text obtained by applying f to each element of t.
--   Subject to fusion. Performs replacement on invalid scalar values.
map :: (Char -> Char) -> Text -> Text

-- | O(n) The intercalate function takes a Text and a list of Texts and
--   concatenates the list after interspersing the first argument between
--   each element of the list.
intercalate :: Text -> [Text] -> Text

-- | O(n) The intersperse function takes a character and places it between
--   the characters of a Text. Subject to fusion. Performs replacement on
--   invalid scalar values.
intersperse :: Char -> Text -> Text

-- | O(n) Reverse the characters of a string. Subject to fusion.
reverse :: Text -> Text

-- | O(n) The isPrefixOf function takes two Texts and returns True iff the
--   first is a prefix of the second. Subject to fusion.
--   <a>http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html</a>
isPrefixOf :: Text -> Text -> Bool

-- | O(n) drop n, applied to a Text, returns the suffix of the Text after
--   the first n characters, or the empty Text if n is greater than the
--   length of the Text. Subject to fusion.
drop :: Int -> Text -> Text

-- | O(n) take n, applied to a Text, returns the prefix of the Text of
--   length n, or the Text itself if n is greater than the length of the
--   Text. Subject to fusion.
take :: Int -> Text -> Text

-- | O(n) Joins lines, after appending a terminating newline to each.
unlines :: [Text] -> Text

-- | O(n) Breaks a Text up into a list of Texts at newline Chars. The
--   resulting strings do not contain newlines.
lines :: Text -> [Text]
instance Typeable Text
instance Data Text
instance Eq Text
instance IsString Text
instance Ord Text


-- | Simple local storage bindings.
module Data.LocalStorage
setLocalStorage :: Text -> Text -> Fay ()
getLocalStorage :: Text -> Fay (Defined Text)
removeLocalStorage :: Text -> Fay ()
hasLocalStorage :: Bool

module Data.MutMap.Internal
data KeyValI a
KeyValI :: Salted -> a -> KeyValI a
data Salted
addSalt :: Text -> Salted
unsalt :: Salted -> Text
checkSalted :: Salted -> Bool

module Data.MutMap
data MutMap a
mutEmpty :: Fay (MutMap a)
mutFromList :: [(Text, a)] -> Fay (MutMap a)
mutLookup :: Text -> MutMap a -> Fay (Maybe a)
mutElems :: MutMap a -> Fay [a]
mutKeys :: MutMap a -> Fay [Text]
mutAssocs :: MutMap a -> Fay [(Text, a)]
mutClone :: MutMap a -> Fay (MutMap a)
mutMapM :: (a -> Fay b) -> MutMap a -> MutMap b
mutMapM_ :: (a -> Fay ()) -> MutMap a -> Fay ()
mutMapMaybeM :: (a -> Fay (Maybe b)) -> MutMap a -> MutMap b
mutInsert :: Text -> a -> MutMap a -> Fay ()
mutDelete :: Text -> MutMap a -> Fay ()
mutClear :: MutMap a -> Fay ()


-- | A limited subset of the time package.
module Data.Time

-- | Get the current time.
getCurrentTime :: Fay UTCTime

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31).
fromGregorian :: Int -> Int -> Int -> Day

-- | Date representation (internally represented as milliseconds from
--   Epoch).
data UTCTime

-- | Day representation (internally represented as milliseconds from
--   Epoch).
data Day

-- | Extract the day from the time.
utctDay :: UTCTime -> Day

-- | Show a time. Meant for debugging purposes, not production
--   presentation.
showTime :: UTCTime -> Text

-- | Show a day. Meant for debugging purposes, not production presentation.
showDay :: Day -> Text
instance Typeable UTCTime
instance Typeable Day
instance Ord Day
instance Eq Day
instance Show Day
instance Data Day
instance Ord UTCTime
instance Eq UTCTime
instance Show UTCTime
instance Data UTCTime
