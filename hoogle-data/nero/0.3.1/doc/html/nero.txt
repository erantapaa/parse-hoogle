-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens-based HTTP toolkit
--   
--   This package provides the core functionality of the <tt>Nero</tt> HTTP
--   toolkit.
--   
--   Check the <a>README</a> for a more detailed explanation.
@package nero
@version 0.3.1


-- | This module is meant to be imported unqualified. It takes care of
--   different versions of <tt>base</tt> and re-exports the following:
--   
--   <ul>
--   <li><i>everything</i> from <a>Control.Lens</a>.</li>
--   <li></li>
--   <li><a>&lt;$&gt;</a>, <a>&lt;*&gt;</a>, <a>pure</a> from
--   <a>Control.Applicative</a>.</li>
--   <li><a>fold</a> form <a>Data.Foldable</a>.</li>
--   <li><a>&gt;=&gt;</a>, <a>&lt;=&lt;</a> from <a>Control.Monad</a>.</li>
--   <li><a>Monoid</a>, <a>&lt;&gt;</a>, <a>mappend</a>, <a>mempty</a> from
--   <a>Data.Monoid</a>.</li>
--   </ul>
module Nero.Prelude


-- | This module should be mostly used for matching the <a>Path</a> of a
--   <a>Request</a>, also known as <b>routing</b>.
module Nero.Match

-- | This contains matched <a>Text</a> in reverse order to how it was
--   matched.
type Match = [Text]

-- | This is just <tt>to pure</tt> with a refined type.
match :: Getter Text Match

-- | This <a>Prism'</a> <i>strips/prepends</i> a prefix.
--   
--   <pre>
--   &gt;&gt;&gt; ("/hello/there"::Text) ^? prefixed "/hello/"
--   Just "there"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "/hello/" # ("there"::Text)
--   "/hello/there"
--   </pre>
--   
--   If matching the entire source it previews to an empty <a>Text</a>. You
--   might use <a>exact</a> if you are expecting this behavior.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello"::Text) ^? prefixed "hello"
--   Just ""
--   </pre>
--   
--   This also means that to <a>review</a> an entire source, you need to
--   give it an empty <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "hello" # (mempty::Text)
--   "hello"
--   </pre>
--   
--   An empty <a>Match</a> matches to itself regardless of the pattern.
--   
--   <pre>
--   &gt;&gt;&gt; preview (prefixed "hello") (review (prefixed "hello") (mempty::Text)) &lt;&amp;&gt; is _Empty
--   Just True
--   </pre>
class Prefixed a
prefixed :: Prefixed a => Text -> Prism' a a

-- | This <a>Prism'</a> <i>strips/appends</i> a suffix.
--   
--   <pre>
--   &gt;&gt;&gt; ("/hello/there"::Text) ^? suffixed "there"
--   Just "/hello/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed "there" # ("/hello/"::Text)
--   "/hello/there"
--   </pre>
--   
--   If matching the entire source it previews to an empty <a>Text</a>. You
--   might use <a>exact</a> if you are expecting this behavior.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello"::Text) ^? suffixed "hello"
--   Just ""
--   </pre>
--   
--   This also means that to <a>review</a> an entire source, you need to
--   give it an empty <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; suffixed "hello" # (mempty::Text)
--   "hello"
--   </pre>
--   
--   An empty <a>Match</a> matches to itself regardless of the pattern.
--   
--   <pre>
--   &gt;&gt;&gt; preview (suffixed "hello") (review (suffixed "hello") (mempty::Text)) &lt;&amp;&gt; is _Empty
--   Just True
--   </pre>
class Suffixed a
suffixed :: Suffixed a => Text -> Prism' a a

-- | This <a>Prism'</a> <i>splits/joins</i> at the first occurrence of a
--   boundary for the first value of a <a>Match</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pure "hello/out/there" ^? sep "/" &lt;&amp;&gt; toListOf folded
--   Just ["out/there","hello"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sep "/" # (pure "out/there" &lt;&gt; pure "hello") &amp; view _head
--   "hello/out/there"
--   </pre>
--   
--   Notice what happens when there is no source before or after a
--   boundary:
--   
--   <pre>
--   &gt;&gt;&gt; pure "hello/" ^? sep "/"
--   Just ["","hello"]
--   
--   &gt;&gt;&gt; (pure "hello/" &lt;&gt; pure "there") ^? sep "/"
--   Just ["","hello","there"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pure "/hello" ^? sep "/"
--   Just ["hello",""]
--   
--   &gt;&gt;&gt; (pure "/hello" &lt;&gt; pure "there") ^? sep "/"
--   Just ["hello","","there"]
--   </pre>
--   
--   When the source <i>is</i> identical to the boundary: &gt;&gt;&gt; pure
--   "hello" ^? sep "hello" Just []
sep :: Text -> Prism' Match Match

-- | This is the composition of <a>match</a> and <a>sep</a>. Use this to
--   avoid lifting a <a>Match</a> explicitly. Notice that, unlike
--   <a>sep</a>, this is not reversible.
split :: Text -> Fold Text Match

-- | This is just an alias to <a>only</a>. Use this to match the entirety
--   of the source. The source mustn't be lifted to a <a>Match</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? exact "hello"
--   Just ()
--   </pre>
exact :: Text -> Prism' Text ()

-- | <a>Prism'</a> between a <a>Match</a> and a target type.
class Target a
target :: Target a => Prism' Match a
instance Prefixed Text
instance Prefixed Match
instance Suffixed Text
instance Suffixed Match
instance Target Match
instance Target Text
instance Target Int
instance Target Float
instance (Target a, Target b) => Target (a, b)

module Nero.Binary

-- | Represents something that can be serialized to a <a>ByteString</a>
--   with the context of <tt>Nero</tt>.
class Renderable a
render :: Renderable a => a -> ByteString

-- | Represents something that can be deserialized from a <a>ByteString</a>
--   within the context of <tt>Nero</tt>. Notice that the whole
--   <a>ByteString</a> has to be consumed.
class Parseable a
parse :: Parseable a => ByteString -> Maybe a

-- | A convenient <a>Prism'</a> to pack <i>serializers/deserializers</i>.
binary :: (Renderable a, Parseable a) => Prism' ByteString a


-- | This module is mainly intended for internal use. <a>Nero.Request</a>
--   and <a>Nero.Payload</a> should provide everything you need for dealing
--   with HTTP parameters.
module Nero.Param

-- | A <a>Traversal'</a> of the values of a given HTTP parameter.
class Param a
param :: Param a => Text -> Traversal' a Text

-- | A <a>Map</a> with multiple values. Also known as a <tt>MultiDict</tt>
--   in other web frameworks.
data MultiMap

-- | Like <a>fromList</a> from <a>Data.Map</a> but <a>mappend</a>ing the
--   values.
fromList :: [(Text, [Text])] -> MultiMap

-- | Is the map empty?
null :: MultiMap -> Bool
instance Show MultiMap
instance Eq MultiMap
instance Monoid MultiMap
instance Wrapped MultiMap
instance Ixed MultiMap
instance At MultiMap
instance Param MultiMap
instance Renderable MultiMap

module Nero.Payload

-- | Contains the <a>Body</a> and any metadata associated with it.
data Payload
payloadText :: Encoding -> Body -> Payload

-- | Indicates a <tt>Text</tt> encoding.
data Encoding
utf8Encoding :: Encoding

-- | A <a>Lens'</a> for types with a <a>Payload</a>.
class HasPayload a
payload :: HasPayload a => Lens' a Payload

-- | It's the main data associated with the <a>Payload</a> of
--   <tt>Request</tt> or a <tt>Response</tt>.
type Body = ByteString

-- | Get the <a>Body</a> for types with one.
class HasBody a
body :: HasBody a => a -> Body

-- | A <a>MultiMap</a> in the context of a form.
type Form = MultiMap

-- | A <a>Prism'</a> to obtain a <a>Form</a> from a <a>Payload</a> and make
--   <a>Payload</a> from a <a>Form</a>.
_Form :: Prism' Payload Form

-- | A <a>Traversal'</a> to access a potential <a>Form</a>.
class Formed a
form :: Formed a => Traversal' a Form

-- | A <a>Payload</a> with an empty <a>Form</a> useful for testing.
dummyPayloadForm :: Payload
instance Eq Payload
instance Show Payload
instance Eq Encoding
instance Show Encoding
instance HasBody Payload
instance Formed Payload
instance Param Payload

module Nero.Url

-- | Composite type of a <a>Scheme</a>, <a>Host</a>, <a>Path</a>,
--   <a>Query</a>.
data Url
[Url] :: Scheme -> Host -> Path -> Query -> Url

-- | The scheme given in the <a>Url</a>, i.e. <tt>http</tt> or
--   <tt>https</tt>.
data Scheme
[Http] :: Scheme
[Https] :: Scheme

-- | The host name of a <a>Url</a>.
type Host = ByteString

-- | Path after the host name in a <a>Url</a>.
type Path = Text

-- | The <i>query string</i> in the form of a <a>MultiMap</a>.
type Query = MultiMap

-- | <a>Lens'</a> for types with an <a>Url</a>.
class HasUrl a
url :: HasUrl a => Lens' a Url

-- | <a>Traversal'</a> to obtain the <a>Url</a> of types with
--   <tt>Location</tt>.
class Location a
location :: Location a => Traversal' a Url

-- | <a>Lens'</a> for types with a <a>Host</a>.
class HasHost a
host :: HasHost a => Lens' a Host

-- | <a>Lens'</a> for types with a <a>Path</a>.
class HasPath a
path :: HasPath a => Lens' a Path

-- | <a>Lens'</a> for types with a <a>Query</a>.
class HasQuery a
query :: HasQuery a => Lens' a Query

-- | A <a>Traversal'</a> of the values of a given HTTP parameter.
class Param a
param :: Param a => Text -> Traversal' a Text

-- | Empty <a>Url</a> useful for testing.
dummyUrl :: Url
instance Eq Url
instance Show Url
instance Eq Scheme
instance Show Scheme
instance Renderable Scheme
instance Parseable Scheme
instance HasHost Url
instance HasPath Url
instance HasQuery Url
instance Param Url
instance Renderable Url

module Nero.Request

-- | An HTTP Request.
data Request

-- | Smart constructor for <a>GET</a> <a>Request</a>s.
get :: Url -> Request

-- | Smart constructor for <a>POST</a> <a>Request</a>s.
post :: Url -> Payload -> Request

-- | <a>Prism'</a> for <a>GET</a> <a>Request</a>s.
_GET :: Prism' Request GET

-- | <a>Prism'</a> to filter for <a>POST</a> <a>Request</a>s.
_POST :: Prism' Request POST

-- | Show <a>Request</a> method.
method :: Request -> ByteString

-- | <a>Traversal'</a> to obtain a <a>Payload</a> from a <a>Request</a>.
--   This is not a <a>Lens'</a> because some <a>Request</a>s, such has
--   <a>GET</a>, are not allowed to have a <a>Payload</a>.
payloaded :: Traversal' Request Payload

-- | This <a>Traversal</a> lets you traverse every HTTP parameter
--   regardless of whether it's present in the <i>query string</i> or in
--   the <i>form encoded body</i> of a <tt>POST</tt> <a>Request</a>. In the
--   rare case where there are HTTP parameters in both, every parameter is
--   still being traversed starting from the /query string/.
--   
--   You might want to use <a>param</a> for traversing a specific
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let request = dummyRequestForm &amp; query . at "name" ?~ ["hello", "out"] &amp; form  . at "name" ?~ ["there"]
--   
--   &gt;&gt;&gt; foldOf params request ^? ix "name"
--   Just ["hello","out","there"]
--   </pre>
params :: Traversal' Request MultiMap

-- | A <tt>GET</tt> <a>Request</a>.
data GET

-- | A <tt>POST</tt> <a>Request</a>.
data POST

-- | An empty GET request useful for testing.
dummyRequest :: Request

-- | An empty POST request with an empty <i>form encoded body</i> useful
--   for testing.
dummyRequestForm :: Request
instance Eq Request
instance Show Request
instance Eq POST
instance Show POST
instance Eq GET
instance Show GET
instance HasUrl Request
instance HasHost Request
instance HasPath Request
instance HasQuery Request
instance Param Request
instance Formed Request
instance HasBody Request
instance HasUrl GET
instance HasHost GET
instance HasPath GET
instance HasQuery GET
instance HasUrl POST
instance HasPayload POST
instance HasHost POST
instance HasPath POST
instance HasQuery POST

module Nero.Response

-- | An HTTP response.
data Response

-- | Creates an <i>200 OK</i> response from the given text. It
--   automatically encodes the text to 'utf-8'. The <i>Mime type</i> is
--   text/plain.
ok :: Text -> Response

-- | Creates an <i>301 Moved Permanently</i> response with the
--   <a>Location</a> corresponding to the given <a>Url</a>.
movedPermanently :: Url -> Response

-- | Creates an <i>404 Not Found</i> response from the given text. It
--   automatically encodes the text to 'utf-8'. The <i>Mime type</i> is
--   text/plain.
notFound :: Text -> Response

-- | A <a>Prism'</a> to <i>obtain/convert</i> a <a>Payload</a>
--   <i>from/to</i> a <i>200 OK</i> <a>Response</a>.
_Ok :: Prism' Response Payload

-- | A <a>Prism'</a> to <i>obtain/convert</i> a <a>Payload</a>
--   <i>from/to</i> a <i>301 Moved Permanently</i> <a>Response</a>.
_MovedPermanently :: Prism' Response Url

-- | A <a>Prism'</a> to <i>obtain/convert</i> a <a>Payload</a>
--   <i>from/to</i> a <i>404 Not Found</i> <a>Response</a>.
_NotFound :: Prism' Response Payload

-- | The HTTP status code and description.
data Status

-- | Obtain the <a>Status</a> from a <a>Response</a>.
status :: Response -> Status
instance Eq Response
instance Show Response
instance Location Response
instance HasBody Response
instance Show Status

module Nero.Application
type Application = Request -> IO Response

-- | Ultimately any valid Nero server application must be transformed
--   <tt><a>Request</a> -&gt; <a>IO</a> <a>Response</a></tt>. This type
--   class facilitates the creation of web server handling <tt>Nero</tt>
--   applications.
class Server a
application :: Server a => a -> Application

-- | Redirect with slash appended URL if only a trailing slash is needed
--   for successful matching, otherwise it responds normally.
--   
--   <pre>
--   &gt;&gt;&gt; let mkRequest p = dummyRequest &amp; host .~ "example.com" &amp; path .~ p
--   
--   &gt;&gt;&gt; let respond name = ok $ "&lt;h1&gt;Hello " &lt;&gt; name &lt;&gt; "&lt;/h1&gt;"
--   
--   &gt;&gt;&gt; let app = slashRedirect (prefixed "/hello/" . suffixed "/") respond :: Request -&gt; Maybe Response
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; app (mkRequest "/hello/there") &lt;&amp;&gt; status
--   Just "301 Moved Permanently"
--   
--   &gt;&gt;&gt; app (mkRequest "/hello/there") &gt;&gt;= preview location &lt;&amp;&gt; render
--   Just "http://example.com/hello/there/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; app (mkRequest "/hello/there/") &lt;&amp;&gt; status
--   Just "200 OK"
--   
--   &gt;&gt;&gt; app (mkRequest "/hello/there/") &lt;&amp;&gt; body
--   Just "&lt;h1&gt;Hello there&lt;/h1&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; app $ mkRequest "/bye/"
--   Nothing
--   </pre>
slashRedirect :: (Target a, HasUrl r, HasPath r) => Prism' Match Match -> (a -> Response) -> r -> Maybe Response
instance Server Response
instance Server (Request -> Response)
instance Server (Request -> Maybe Response)


-- | This module re-exports the essential functions for quickly writing
--   <tt>Nero</tt> applications. Use the original modules for more
--   specialized functions.
module Nero
type Application = Request -> IO Response

-- | Ultimately any valid Nero server application must be transformed
--   <tt><a>Request</a> -&gt; <a>IO</a> <a>Response</a></tt>. This type
--   class facilitates the creation of web server handling <tt>Nero</tt>
--   applications.
class Server a
application :: Server a => a -> Application

-- | An HTTP Request.
data Request

-- | Smart constructor for <a>GET</a> <a>Request</a>s.
get :: Url -> Request

-- | Smart constructor for <a>POST</a> <a>Request</a>s.
post :: Url -> Payload -> Request

-- | <a>Prism'</a> for <a>GET</a> <a>Request</a>s.
_GET :: Prism' Request GET

-- | <a>Prism'</a> to filter for <a>POST</a> <a>Request</a>s.
_POST :: Prism' Request POST

-- | Show <a>Request</a> method.
method :: Request -> ByteString
path :: HasPath a => Lens' a Path
query :: HasQuery a => Lens' a Query
form :: Formed a => Traversal' a Form

-- | This <a>Traversal</a> lets you traverse every HTTP parameter
--   regardless of whether it's present in the <i>query string</i> or in
--   the <i>form encoded body</i> of a <tt>POST</tt> <a>Request</a>. In the
--   rare case where there are HTTP parameters in both, every parameter is
--   still being traversed starting from the /query string/.
--   
--   You might want to use <a>param</a> for traversing a specific
--   parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let request = dummyRequestForm &amp; query . at "name" ?~ ["hello", "out"] &amp; form  . at "name" ?~ ["there"]
--   
--   &gt;&gt;&gt; foldOf params request ^? ix "name"
--   Just ["hello","out","there"]
--   </pre>
params :: Traversal' Request MultiMap
param :: Param a => Text -> Traversal' a Text
body :: HasBody a => a -> Body

-- | A <tt>GET</tt> <a>Request</a>.
data GET

-- | A <tt>POST</tt> <a>Request</a>.
data POST

-- | An HTTP response.
data Response

-- | Creates an <i>200 OK</i> response from the given text. It
--   automatically encodes the text to 'utf-8'. The <i>Mime type</i> is
--   text/plain.
ok :: Text -> Response

-- | Creates an <i>301 Moved Permanently</i> response with the
--   <a>Location</a> corresponding to the given <a>Url</a>.
movedPermanently :: Url -> Response

-- | Composite type of a <a>Scheme</a>, <a>Host</a>, <a>Path</a>,
--   <a>Query</a>.
data Url

-- | This is just <tt>to pure</tt> with a refined type.
match :: Getter Text Match

-- | This <a>Prism'</a> <i>strips/prepends</i> a prefix.
--   
--   <pre>
--   &gt;&gt;&gt; ("/hello/there"::Text) ^? prefixed "/hello/"
--   Just "there"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "/hello/" # ("there"::Text)
--   "/hello/there"
--   </pre>
--   
--   If matching the entire source it previews to an empty <a>Text</a>. You
--   might use <a>exact</a> if you are expecting this behavior.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello"::Text) ^? prefixed "hello"
--   Just ""
--   </pre>
--   
--   This also means that to <a>review</a> an entire source, you need to
--   give it an empty <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "hello" # (mempty::Text)
--   "hello"
--   </pre>
--   
--   An empty <a>Match</a> matches to itself regardless of the pattern.
--   
--   <pre>
--   &gt;&gt;&gt; preview (prefixed "hello") (review (prefixed "hello") (mempty::Text)) &lt;&amp;&gt; is _Empty
--   Just True
--   </pre>
class Prefixed a
prefixed :: Prefixed a => Text -> Prism' a a

-- | This <a>Prism'</a> <i>strips/appends</i> a suffix.
--   
--   <pre>
--   &gt;&gt;&gt; ("/hello/there"::Text) ^? suffixed "there"
--   Just "/hello/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed "there" # ("/hello/"::Text)
--   "/hello/there"
--   </pre>
--   
--   If matching the entire source it previews to an empty <a>Text</a>. You
--   might use <a>exact</a> if you are expecting this behavior.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello"::Text) ^? suffixed "hello"
--   Just ""
--   </pre>
--   
--   This also means that to <a>review</a> an entire source, you need to
--   give it an empty <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; suffixed "hello" # (mempty::Text)
--   "hello"
--   </pre>
--   
--   An empty <a>Match</a> matches to itself regardless of the pattern.
--   
--   <pre>
--   &gt;&gt;&gt; preview (suffixed "hello") (review (suffixed "hello") (mempty::Text)) &lt;&amp;&gt; is _Empty
--   Just True
--   </pre>
class Suffixed a
suffixed :: Suffixed a => Text -> Prism' a a

-- | This <a>Prism'</a> <i>splits/joins</i> at the first occurrence of a
--   boundary for the first value of a <a>Match</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pure "hello/out/there" ^? sep "/" &lt;&amp;&gt; toListOf folded
--   Just ["out/there","hello"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sep "/" # (pure "out/there" &lt;&gt; pure "hello") &amp; view _head
--   "hello/out/there"
--   </pre>
--   
--   Notice what happens when there is no source before or after a
--   boundary:
--   
--   <pre>
--   &gt;&gt;&gt; pure "hello/" ^? sep "/"
--   Just ["","hello"]
--   
--   &gt;&gt;&gt; (pure "hello/" &lt;&gt; pure "there") ^? sep "/"
--   Just ["","hello","there"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pure "/hello" ^? sep "/"
--   Just ["hello",""]
--   
--   &gt;&gt;&gt; (pure "/hello" &lt;&gt; pure "there") ^? sep "/"
--   Just ["hello","","there"]
--   </pre>
--   
--   When the source <i>is</i> identical to the boundary: &gt;&gt;&gt; pure
--   "hello" ^? sep "hello" Just []
sep :: Text -> Prism' Match Match

-- | This is the composition of <a>match</a> and <a>sep</a>. Use this to
--   avoid lifting a <a>Match</a> explicitly. Notice that, unlike
--   <a>sep</a>, this is not reversible.
split :: Text -> Fold Text Match

-- | This is just an alias to <a>only</a>. Use this to match the entirety
--   of the source. The source mustn't be lifted to a <a>Match</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? exact "hello"
--   Just ()
--   </pre>
exact :: Text -> Prism' Text ()

-- | <a>Prism'</a> between a <a>Match</a> and a target type.
class Target a
target :: Target a => Prism' Match a

-- | An empty GET request useful for testing.
dummyRequest :: Request

-- | An empty POST request with an empty <i>form encoded body</i> useful
--   for testing.
dummyRequestForm :: Request

-- | Empty <a>Url</a> useful for testing.
dummyUrl :: Url
