-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple Functional Lenses
--   
@package lenses
@version 0.1.7


-- | This modules provides a convienient way to access and update the
--   elements of a structure. It is very similar to Data.Accessors, but a
--   bit more generic and has fewer dependencies. I particularly like how
--   cleanly it handles nested structures in state monads.
--   <a>runSTLense</a> is also a very useful function.
--   
--   A brief tutorial to get started:
--   
--   To create a lense, you can use fromGetSet (although usually you would
--   just derive them using templat haskell and <tt>deriveLenses</tt> from
--   <a>Data.Lenses.Template</a>):
--   
--   <pre>
--   lense = fromGetSet getField setField
--   </pre>
--   
--   The lense has type:
--   
--   <pre>
--   lense :: (MonadState r m) =&gt; StateT a m b -&gt; m b
--   </pre>
--   
--   Where r is the type of the record, and a is the type of the field, (b
--   can be any type you choose, more on that latter). Though it may help
--   to think of it as:
--   
--   <pre>
--   lense :: State a b -&gt; State r b
--   </pre>
--   
--   Which is not entirely accurate, but emphasises how the lense works.
--   You can think of it as "pass in an action that operates on the field,
--   and you get an action that operates on the record". So say we pass in
--   get (with a more specific type for clarity):
--   
--   <pre>
--   get :: State a a
--   
--   lense get :: State r a
--   </pre>
--   
--   We get out a state monad that we can run on our record to fetch our
--   field.
--   
--   <pre>
--   fieldValue = lense get `evalState` record
--   </pre>
--   
--   This module has a special function <a>fetch</a> that does this:
--   
--   <pre>
--   fieldValue = record `fetch` lense
--   </pre>
--   
--   You can also pass in <a>put</a> to get back an action that updates the
--   field.
--   
--   <pre>
--   put :: a -&gt; State a ()
--   
--   lense (put someValue) :: State r ()
--   </pre>
--   
--   Now we have a state monad that we can run on our record to update our
--   field.
--   
--   <pre>
--   updatedRecord = lense (put someValue) `execState` record
--   </pre>
--   
--   This module has a special function <a>update</a> that does this:
--   
--   <pre>
--   updatedRecord = (record `update` lense) someValue
--   </pre>
--   
--   To aid in clarity and to deal with the actual types of the lenses this
--   module provides <a>execIn</a>, <a>evalFrom</a>, and <a>runOn</a> to be
--   used in place of <a>execState</a>, <a>evalState</a>, and
--   <a>runState</a>. Also note that <a>execIn</a>, <a>evalFrom</a>, and
--   <a>runOn</a> have their parameters fliped from their state
--   counterparts. There is nothing magical about these functions, they are
--   just a little more handy than their state counterparts.
--   
--   The lenses are especially convienient if you have nested structures.
--   Lense composition is just function composition.
--   
--   <pre>
--   data Point = Point {
--                   x_ :: Float,
--                   y_ :: Float
--                   }
--      deriving (Show)
--   </pre>
--   
--   $( deriveLenses ''Point )
--   
--   <pre>
--   data Triangle = Triangle {
--                   pa_ :: Point,
--                   pb_ :: Point,
--                   pc_ :: Point
--                   }
--      deriving (Show)
--   </pre>
--   
--   $( deriveLenses ''Triangle )
--   
--   <pre>
--   a_y :: (MonadState Triangle m) =&gt; StateT Float (StateT Point m) b -&gt; m b
--   a_y = pa . y
--   </pre>
--   
--   a_y is now a lense that can operate on the y coordinate of point "a"
--   inside a triangle. We can use a_y to fetch the coordinate or update
--   it, on whatever triangle we choose.
--   
--   <pre>
--   someTriangle = Triangle (Point 5 3) (Point 0 1) (Point 10 6)
--   
--   ayValue = someTriangle `fetch` a_y
--   -- ayValue == 3
--   
--   updatedTriangle = (someTriangle `update` a_y) 7
--   -- updatedTriangle == Triangle (Point 5 7) (Point 0 1) (Point 10 6)
--   </pre>
--   
--   Or we could apply our lense to an action and pass it into
--   <a>execIn</a>
--   
--   <pre>
--   (someTriangle `update` a_y) 7 == execIn someTriangle (a_y (put 7))
--   </pre>
--   
--   We can also chain actions together:
--   
--   <pre>
--   a_x :: (MonadState Triangle m) =&gt; StateT Float (StateT Point m) b -&gt; m b
--   a_x = pa . x
--   c_y :: (MonadState Triangle m) =&gt; StateT Float (StateT Point m) b -&gt; m b
--   c_y = pc . y
--   
--   updatedTriangle = execIn someTriangle $ a_y (put 7) &gt;&gt; a_x (put 1) &gt;&gt; c_y (put 9)
--   -- updatedTriangle == Triangle (Point 1 7) (Point 0 1) (Point 10 9)
--   </pre>
--   
--   What if we wanted to put the value of c_y into a_x? Can do!
--   
--   <pre>
--   updatedTriangle = execIn someTriangle $ do
--     cy &lt;- c_y get
--     a_x $ put cy
--   -- updatedTriangle == Triangle (Point 6 3) (Point 0 1) (Point 10 6)
--   </pre>
--   
--   Or if the order really bugs you, you can use the <a>$%</a> operator
--   (taken from <a>Data.Accessors.Basic</a>, it really should be in a
--   standard lib)
--   
--   <pre>
--   updatedTriangle = execIn someTriangle $ do
--     cy &lt;- get $% c_y
--     put cy $% a_x
--   -- updatedTriangle == Triangle (Point 6 3) (Point 0 1) (Point 10 6)
--   </pre>
--   
--   Or you can use the <a>$=</a> operator:
--   
--   <pre>
--   updatedTriangle = execIn someTriangle $ do
--     cy &lt;- c_y get
--     a_x $= cy
--   </pre>
--   
--   Or more concisely:
--   
--   <pre>
--   updatedTriangle = execIn someTriangle $ (c_y get &gt;&gt;= a_x . put)
--   </pre>
--   
--   Or say we want to put the value of c_y into a_x, but want to throw an
--   error if c_y is zero. We can do that as well!
--   
--   <pre>
--   updatedTriangle :: Either String Triangle
--   updatedTriangle = execInT someTriangle $ do
--     cy &lt;- c_y get
--     when (cy == 0) $ throwError "Something bad happend"
--     a_x $ put cy
--   -- updatedTriangle == Right $ Triangle (Point 6 3) (Point 0 1) (Point 10 6)
--   -- if cy had equaled 0 then we would have gotten this:
--   -- updatedTriangle == Left "Something bad happend"
--   </pre>
--   
--   Note that <a>execInT</a> = <a>flip</a> <a>execStateT</a>.
--   
--   Yay for monad transformers!
--   
--   This module has one last feature that allows you to convert a function
--   that fetches data from a structure to a function that modifies it! For
--   an example see the documentation for <a>runSTLense</a>.
--   
--   One final note: Due to the generality of the lenses you might end up
--   accidentally running into the monomorphism restriction. So if get a
--   type error like:
--   
--   <pre>
--   Couldn't match expected type `SomeMonad SomeStructureType'
--          against inferred type `Control.Monad.Identity.Identity SomeStructureType'
--   </pre>
--   
--   and nothing appears to be wrong with your code, try turning the
--   restriction off with -XNoMonomorphismRestriction and see if it goes
--   away. If it does then you probably need to add some explicit type
--   signatures somewhere.
--   
--   I whipped out this documentation in a hurry, so if you spot any
--   errors, or think I should explain something better, <i>please</i> let
--   me know. This library is hosted on github (click on the
--   <i>Contents</i> link above and you should see the Homepage link) so it
--   should be very easy to forked it and send patches to me. Also since
--   this module is new I'm open to radical modifications if you have a
--   good suggestion, so suggest away! :)
module Data.Lenses

-- | This function takes a "getter" and "setter" function and returns our
--   lense.
--   
--   Usually you only need to use this if you don't want to use Template
--   Haskell to derive your Lenses for you. With a structure Point:
--   
--   <pre>
--   data Point = Point {
--                   x_ :: Float,
--                   y_ :: Float
--                   }
--      deriving (Show)
--   </pre>
--   
--   This (from <a>Data.Lenses.Template</a>):
--   
--   $( deriveLenses ''Point )
--   
--   is equivalent to this:
--   
--   <pre>
--   x :: (MonadState Point m) =&gt; StateT Float m b -&gt; m b
--   x = fromGetSet x_ (\a s -&gt; s { x_ = a })
--   y :: (MonadState Point m) =&gt; StateT Float m b -&gt; m b
--   y = fromGetSet y_ (\a s -&gt; s { y_ = a })
--   </pre>
fromGetSet :: MonadState r m => (r -> a) -> (a -> r -> r) -> StateT a m b -> m b

-- | fetches a field from a structure using a lense:
--   
--   <pre>
--   somePoint = Point 5 3
--   a = somePoint `fetch` x
--   b = somePoint `fetch` y
--   </pre>
--   
--   <pre>
--   -- a == 5
--   -- b == 3
--   </pre>
fetch :: MonadState a m => r -> (m a -> StateT r Identity a) -> a

-- | updates a field in a structure using a lense:
--   
--   <pre>
--   somePoint = Point 5 3
--   newPoint = (somePoint `update` y) 15
--   </pre>
--   
--   <pre>
--   -- newPoint == Point 5 15
--   </pre>
update :: MonadState a m => r -> (m () -> StateT r Identity b) -> a -> r

-- | alters a field in a structure using a lense and a function:
--   
--   <pre>
--   somePoint = Point 5 3
--   newPoint = (somePoint `alter` y) (+1)
--   </pre>
--   
--   <pre>
--   -- newPoint == Point 5 4
--   </pre>
alter :: MonadState a m => (m () -> StateT r Identity b) -> (a -> a) -> r -> r

-- | Runs a state monad action on a structure and returns the value
--   returned from the action and the updated structure.
--   
--   <pre>
--   somePoint = Point 5 3
--   a = runOn somePoint $ x (modifyAndGet (+1))
--   -- a == (6, Point 6 3)
--   </pre>
runOn :: b -> StateT b Identity a -> (a, b)

-- | Monad transformer version of <a>runOn</a>. Note that <a>runOnT</a> =
--   <a>runStateT</a>.
runOnT :: b -> StateT b m a -> m (a, b)

-- | Runs a state monad action on a structure and returns the value
--   returned from the action.
--   
--   Use it to fetch values from fields.
--   
--   <pre>
--   someTriangle = Triangle (Point 5 3) (Point 0 1) (Point 10 6)
--   a = evalFrom someTriangle $ pb . x get
--   -- a == 0
--   </pre>
--   
--   note that:
--   
--   <pre>
--   evalFrom someTriangle (pb . x get) == someTriangle `fetch` (pb . x)
--   </pre>
--   
--   The advantage over <a>fetch</a> is that it allows you to specify a
--   different final action besides <a>get</a> like so:
--   
--   <pre>
--   evalFrom someTriangle $ pb . x (modifyAndGet (+1))
--   </pre>
evalFrom :: b -> StateT b Identity a -> a

-- | Monad transformer version of <a>evalFrom</a>. Note that
--   <a>evalFromT</a> = <a>flip</a> <a>evalStateT</a>.
evalFromT :: Monad m => b -> StateT b m a -> m a

-- | Runs a state monad action on a structure and returns the updated
--   structure
--   
--   Use it to update fields:
--   
--   <pre>
--   somePoint = Point 5 3
--   a = execIn somePoint $ x (put 1)
--   -- a == Point 1 3
--   </pre>
--   
--   note that:
--   
--   <pre>
--   execIn somePoint (x (put 1)) == (somePoint `update` x) 1
--   </pre>
--   
--   The advantage over <a>update</a> is that it allows you to specify a
--   different final action besides <a>put</a> like so:
--   
--   <pre>
--   a = execIn somePoint $ x (modifyAndGet (+1))
--   -- a = Point 6 3
--   </pre>
execIn :: a -> StateT a Identity b -> a

-- | Monad transformer version of <a>execIn</a>. Note that <a>execIn</a> =
--   <a>flip</a> <a>execStateT</a>.
execInT :: Monad m => b -> StateT b m a -> m b

-- | This function has the magical ability to convert a function that
--   fetches elements from a structure, to a function that lets you modify
--   the elements in the structure. The catch is that the structure must be
--   a member of <a>Traversable</a>.
--   
--   So say you have a function that gets the diagonal of a list of lists:
--   
--   <pre>
--   diagonal :: [[a]] -&gt; [a]
--   </pre>
--   
--   we can make a function that increments the diagonal like so:
--   
--   <pre>
--   addOne :: State Int ()
--   addOne = modify (+1)
--   </pre>
--   
--   <pre>
--   incrementDiagonal :: [[a]] -&gt; [[a]]
--   incrementDiagonal xss = snd $ runSTLense (fmap ($ addOne) . diagonal) xss
--   </pre>
--   
--   Of course there are some helper combinators to make this cleaner:
--   
--   <pre>
--   incrementDiagonal xss = (addOne `to` diagonal) `from` xss
--   </pre>
--   
--   <a>runSTLense</a> takes a function, a traversable structure, and
--   returns a pair of (collected values, updated structure) For
--   clarification:
--   
--   <pre>
--   specialFunction ::  (Traversable f, Traversable t) =&gt; f (State a b -&gt; s) -&gt; t s
--   (collectedValues, updatedStructure) = runSTLense specialFunction originalStructure
--   collectedAlmostValues = specialFunction processedOriginalStructure
--   </pre>
--   
--   processedOriginalStructure has the same shape as originalStructure but
--   every element has been replaced with a transformer function (State a b
--   -&gt; s). specialFunction needs to return the result of the
--   application of the functions in processedOriginalStructure to a state
--   monad. The state monad by definition will return a result and
--   potentially update state. Getting state will get the value of the
--   element in originalStructure. Updating state will update the value of
--   the element in updatedStructure. The returned values are gathered in
--   collectedValues.
runSTLense :: (Traversable f, Traversable t) => (forall s. f (State a b -> s) -> t s) -> f a -> (t b, f a)

-- | A helper combinator used for applying a monad to element collected by
--   a fetching function.
--   
--   For example:
--   
--   <pre>
--   everyOther :: [a] -&gt; [a]
--   everyOther [] = []
--   everyOther (x:[]) = [x]
--   everyOther (x:y:xs) = x : everyOther xs
--   </pre>
--   
--   <pre>
--   addOne :: State Int ()
--   addOne = modify (+1)
--   </pre>
--   
--   <pre>
--   test :: [Int]
--   test = (addOne `to` everyOther) `from` [1, 2, 9, 6, 7, 8, 4]
--   -- test == [2, 2, 10, 6, 8, 8, 5]
--   </pre>
--   
--   which is the same as:
--   
--   <pre>
--   test = snd $ runSTLense (addOne `to` everyOther) [1, 2, 9, 6, 7, 8, 4]
--   </pre>
--   
--   which is the same as:
--   
--   <pre>
--   test = snd $ runSTLense (fmap ($ addOne) . everyOther) [1, 2, 9, 6, 7, 8, 4]
--   </pre>
to :: Functor f => a -> (c -> f (a -> b)) -> c -> f b

-- | Applies <a>runSTLense</a> to a function and a structure and returns
--   the <a>snd</a> of the result. See <a>to</a> for example of use.
from :: (Traversable t, Traversable f) => (forall s. t (State a b -> s) -> f s) -> t a -> t a

-- | Modifies the state in a state monad and returns the original value.
--   
--   <a>getAndModify</a> and <a>modifyAndGet</a> should really be in
--   <a>Class</a>
getAndModify :: MonadState s m => (s -> s) -> m s

-- | Modifies the state in a state monad and returns the new value.
modifyAndGet :: MonadState s m => (s -> s) -> m s

-- | An operator for assigning a value to the value referenced by a lense.
--   (see the example near the end of the tutorial at the start of this
--   module)
($=) :: MonadState s m => (m () -> b) -> s -> b

-- | Flipped version of '($)'.
($%) :: a -> (a -> b) -> b


-- | This module provides an automatic Template Haskell routine to scour
--   data type definitions and generate lense objects for them
--   automatically.
--   
--   It was copied almost verbatim (2 line change) from the wonderful
--   Data.Accessors.Template module made by Luke Palmer, and Henning
--   Thielemann.
--   
--   You will need to add:
--   
--   {-# LANGUAGE TemplateHaskell, FlexibleContexts #-}
--   
--   to the top of any modules that use this one.
module Data.Lenses.Template

-- | <tt>nameDeriveLenses n f</tt> where <tt>n</tt> is the name of a data
--   type declared with <tt>data</tt> and <tt>f</tt> is a function from
--   names of fields in that data type to the name of the corresponding
--   accessor. If <tt>f</tt> returns <tt>Nothing</tt>, then no accessor is
--   generated for that field.
nameDeriveLenses :: Name -> (String -> Maybe String) -> Q [Dec]

-- | <tt>deriveLenses n</tt> where <tt>n</tt> is the name of a data type
--   declared with <tt>data</tt> looks through all the declared fields of
--   the data type, and for each field ending in an underscore generates an
--   accessor of the same name without the underscore.
--   
--   It is "nameDeriveLenses" n f where <tt>f</tt> satisfies
--   
--   <pre>
--   f (s ++ "_") = Just s
--   f x          = Nothing    -- otherwise
--   </pre>
--   
--   For example, given the data type:
--   
--   <pre>
--   data Score = Score { p1Score_ :: Int
--                      , p2Score_ :: Int
--                      , rounds   :: Int
--                      }
--   </pre>
--   
--   <tt>deriveLenses</tt> will generate the following objects:
--   
--   <pre>
--   p1Score :: (MonadState Score m) =&gt; StateT Int m b -&gt; m b
--   p1Score = fromGetSet p1Score_ (\x s -&gt; s { p1Score_ = x })
--   p2Score :: (MonadState Score m) =&gt; StateT Int m b -&gt; m b
--   p2Score = fromGetSet p2Score_ (\x s -&gt; s { p2Score_ = x })
--   </pre>
--   
--   It is used with Template Haskell syntax like:
--   
--   <pre>
--   $( deriveLenses ''TypeName )
--   </pre>
--   
--   And will generate accessors when TypeName was declared using
--   <tt>data</tt> or <tt>newtype</tt>.
deriveLenses :: Name -> Q [Dec]
