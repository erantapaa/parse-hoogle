-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Webmachine inspired toolkit for building http applications and services.
--   
--   Webmachine inspired toolkit for building http applications and
--   services.
@package webcrank
@version 0.2.2

module Webcrank.ServerAPI.WebcrankT

-- | Monad transformer that can be used by server API providers. Provides
--   tracking of the request state and logging of the decisions made so
--   far. For example
--   
--   <pre>
--   type WaiCrank m a = ReaderT (Request, HTTPDate) (WebcrankT m) a
--   </pre>
newtype WebcrankT m a
[WebcrankT] :: RWST (ResourceData (WebcrankT m)) LogData ReqData m a -> WebcrankT m a
[unWebcrankT] :: WebcrankT m a -> RWST (ResourceData (WebcrankT m)) LogData ReqData m a
runWebcrankT :: WebcrankT m a -> ServerAPI (WebcrankT m) -> Resource (WebcrankT m) -> ReqData -> m (a, ReqData, LogData)
instance MonadMask m => MonadMask (WebcrankT m)
instance MonadCatch m => MonadCatch (WebcrankT m)
instance MonadThrow m => MonadThrow (WebcrankT m)
instance Monad m => MonadWriter LogData (WebcrankT m)
instance Monad m => MonadState ReqData (WebcrankT m)
instance Monad m => MonadReader (ResourceData (WebcrankT m)) (WebcrankT m)
instance MonadIO m => MonadIO (WebcrankT m)
instance Monad m => Monad (WebcrankT m)
instance Monad m => Applicative (WebcrankT m)
instance Functor m => Functor (WebcrankT m)
instance MonadTrans WebcrankT

module Webcrank.Internal.DecisionCore
data FlowChart m a
[Decision] :: String -> m (FlowChart m a) -> FlowChart m a
[Done] :: m a -> FlowChart m a
decision :: String -> m (FlowChart m a) -> FlowChart m a
decision' :: Functor m => String -> m Bool -> FlowChart m a -> FlowChart m a -> FlowChart m a
done :: m a -> FlowChart m a
done' :: (Applicative m, Monad m) => a -> FlowChart m a
runFlowChart :: Monad m => FlowChart m a -> m a
respond :: Monad m => Status -> FlowChart (HaltT m) Status
errorResponse :: Monad m => Status -> ByteString -> HaltT m a
errorResponse' :: Monad m => Status -> HaltT m a
b13 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b12 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b11 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b10 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b9 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b8 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b6 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b4 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
b3 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
c3 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
c4 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
d4 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
d5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
e5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
e6 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
setCharsetFrom :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> HaltT m ()
f6 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
f7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
chooseEncoding :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> HaltT m ()
g7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
getVariances :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HaltT m [HeaderName]
g8 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
g9 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
g11 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
h7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
h10 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
h11 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
h12 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HTTPDate -> FlowChart (HaltT m) Status
i4 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
movedPermanentlyOr :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status -> HaltT m (FlowChart (HaltT m) Status)
i7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
i12 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
i13 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
j18 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
k5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
k7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
k13 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
l5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
l7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
l13 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
l14 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => ByteString -> FlowChart (HaltT m) Status
l15 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HTTPDate -> FlowChart (HaltT m) Status
l17 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HTTPDate -> FlowChart (HaltT m) Status
m5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
m7 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
m16 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
m20 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
n5 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
n11 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
appendPath :: ByteString -> [Text] -> ByteString
splitURI :: ByteString -> (ByteString, ByteString)
n16 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
o14 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
isConflict' :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HaltT m (FlowChart (HaltT m) Status)
o16 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
o18 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
o20 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
p3 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
p11 :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => FlowChart (HaltT m) Status
accept :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HaltT m ()
bool :: a -> a -> Bool -> a
(<%%=) :: MonadState s m => Lens' s a -> (a -> m a) -> m ()
encodeBodyIfSet :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => HaltT m ()
encodeBody :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => Body -> HaltT m Body
encodeBody' :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s) => Body -> m Body

module Webcrank.Internal.Halt
runHaltT :: HaltT m a -> m (Either Halt a)

-- | Immediately end processing of the request, returning the response
--   <tt>Status</tt>. It is the responsibility of the resource to ensure
--   that all necessary response header and body elements have been added
--   in order to make that response code valid.
halt :: Monad m => Status -> HaltT m a

-- | Immediately end processing of this request, returning a <tt>500
--   Internal Server Error</tt> response. The response body will contain
--   the reason.
werror :: Monad m => ByteString -> HaltT m a

-- | Immediately end processing of this request, returning a response with
--   the given <tt>Status</tt>. The response body will contain the reason.
werrorWith :: Monad m => Status -> ByteString -> HaltT m a

module Webcrank.ServerAPI

-- | A dictionary of functions that Webcrank needs in order to make
--   decisions.
data ServerAPI m
[ServerAPI] :: m Method -> m ByteString -> (HeaderName -> m (Maybe ByteString)) -> m HTTPDate -> ServerAPI m

-- | Get the request method of the current request.
[srvGetRequestMethod] :: ServerAPI m -> m Method

-- | The full URI of the request.
[srvGetRequestURI] :: ServerAPI m -> m ByteString

-- | Get the request header of the current request.
[srvGetRequestHeader] :: ServerAPI m -> HeaderName -> m (Maybe ByteString)

-- | Get the time the request was received.
[srvGetRequestTime] :: ServerAPI m -> m HTTPDate

-- | Container used to keep track of the decision state and what is known
--   about response while processing a request.
data ReqData

-- | Smart constructor for creating a <tt>ReqData</tt> value with initial
--   values.
newReqData :: ReqData
class HasReqData c_arV9 where reqDataDispPath = (.) reqData reqDataDispPath reqDataRespBody = (.) reqData reqDataRespBody reqDataRespCharset = (.) reqData reqDataRespCharset reqDataRespEncoding = (.) reqData reqDataRespEncoding reqDataRespHeaders = (.) reqData reqDataRespHeaders reqDataRespMediaType = (.) reqData reqDataRespMediaType
reqData :: HasReqData c_arV9 => Lens' c_arV9 ReqData

-- | A wrapper for the <tt><a>ServerAPI</a></tt> and
--   <tt><a>Resource</a></tt> that should be used to process requests to a
--   path.
data ResourceData m
newResourceData :: ServerAPI m -> Resource m -> ResourceData m
class HasResourceData c_arRb m_apwF | c_arRb -> m_apwF where resourceDataResource = (.) resourceData resourceDataResource resourceDataServerAPI = (.) resourceData resourceDataServerAPI
resourceData :: HasResourceData c_arRb m_apwF => Lens' c_arRb (ResourceData m_apwF)
data LogData

-- | Process a request according to the webmachine state diagram. Intended
--   for use by server API providers. <tt>run</tt> is a function which can
--   run process to completion.
--   
--   <tt><a>WebcrankT</a></tt> is provided as a starting point. For the
--   type
--   
--   <pre>
--   type WaiCrank = ReaderT (Request, HTTPDate) (WebcrankT IO)
--   </pre>
--   
--   an appropriate <tt>run</tt> function would be
--   
--   <pre>
--   run :: Resource WaiCrank -&gt; Request -&gt; HTTPDate -&gt; WaiCrank a -&gt; IO (a, ReqData, LogData)
--   run resource req date wa = runReaderT (runWebcrankT wa (ResourceData api resource) newReqData) (req, date)
--   </pre>
handleRequest :: (Applicative m, MonadReader r m, HasResourceData r m, MonadState s m, HasReqData s, MonadCatch m, Functor n) => (forall a. m a -> n (a, ReqData, LogData)) -> n (Status, HeadersMap, Maybe Body)

module Webcrank.Internal

module Webcrank

-- | A <tt>Resource</tt> is a dictionary of functions which are used in the
--   Webcrank decision process to determine how requests should be handled.
--   
--   Each function has a type of either <tt>m a</tt> or <tt><a>HaltT</a> m
--   a</tt>. A resource function which yields a <tt>HaltT m a</tt> value
--   allows the function to terminate the request processing early using
--   <tt><tt>halt</tt></tt> or <tt><tt>werror</tt></tt>.
--   
--   The defaults documented are used by the <tt><tt>resource</tt></tt>
--   smart constructor. A resource that responds to <tt>GET</tt> requests
--   with an HTML response would be written as
--   
--   <pre>
--   myResource = resource { contentTypesProvided = return $ [("text/html", return "Hello world!")] }
--   </pre>
--   
--   <tt><tt>responseWithBody</tt></tt> and
--   <tt><tt>responseWithHtml</tt></tt> are additional smart constructors
--   useful creating resources.
data Resource m
[Resource] :: HaltT m Bool -> HaltT m Bool -> m [Method] -> HaltT m Bool -> HaltT m Authorized -> HaltT m Bool -> HaltT m Bool -> HaltT m Bool -> HaltT m Bool -> m ResponseHeaders -> m [(MediaType, HaltT m Body)] -> m CharsetsProvided -> m [(Encoding, Body -> Body)] -> HaltT m Bool -> MaybeT m ETag -> MaybeT m HTTPDate -> MaybeT m HTTPDate -> MaybeT (HaltT m) ByteString -> MaybeT (HaltT m) ByteString -> HaltT m Bool -> HaltT m Bool -> HaltT m Bool -> HaltT m Bool -> m (PostAction m) -> m [(MediaType, HaltT m ())] -> m [HeaderName] -> HaltT m Bool -> m Bool -> m () -> Resource m

-- | <tt>False</tt> will result in <tt>503 Service Unavailable</tt>.
--   Defaults to <tt>True</tt>.
[serviceAvailable] :: Resource m -> HaltT m Bool

-- | <tt>True</tt> will result in <tt>414 Request Too Long</tt>. Defaults
--   to <tt>False</tt>.
[uriTooLong] :: Resource m -> HaltT m Bool

-- | If a <tt>Method</tt> not in this list is requested, then a <tt>405
--   Method Not Allowed</tt> will be sent. Defaults to <tt>[<a>GET</a>,
--   <a>HEAD</a>]</tt>.
[allowedMethods] :: Resource m -> m [Method]

-- | <tt>True</tt> will result in <tt>400 Bad Request</tt>. Defaults to
--   <tt>False</tt>.
[malformedRequest] :: Resource m -> HaltT m Bool

-- | If <tt>Authorized</tt>, the response will be <tt>401
--   Unauthorized</tt>. <tt>Unauthorized</tt> will be used as the challenge
--   in the <tt>WWW-Authenticate</tt> header, e.g. <tt>Basic
--   realm=<a>Webcrank</a></tt>. Defaults to <tt>Authorized</tt>.
[isAuthorized] :: Resource m -> HaltT m Authorized

-- | <tt>True</tt> will result in <tt>403 Forbidden</tt>. Defaults to
--   <tt>False</tt>.
[forbidden] :: Resource m -> HaltT m Bool

-- | <tt>False</tt> will result in <tt>501 Not Implemented</tt>. Defaults
--   to <tt>True</tt>.
[validContentHeaders] :: Resource m -> HaltT m Bool

-- | <tt>False</tt> will result in <tt>415 Unsupported Media Type</tt>.
--   Defaults to <tt>True</tt>.
[knownContentType] :: Resource m -> HaltT m Bool

-- | <tt>False</tt> will result in <tt>413 Request Entity Too Large</tt>.
--   Defaults to <tt>True</tt>.
[validEntityLength] :: Resource m -> HaltT m Bool

-- | If the OPTIONS method is supported and is used, the headers that
--   should appear in the response. Defaults to <tt>[]</tt>.
[options] :: Resource m -> m ResponseHeaders

-- | Content negotiation is driven by this function. For example, if a
--   client request includes an <tt>Accept</tt> header with a value that
--   does not appear as a <tt>MediaType</tt> in any of the tuples, then a
--   <tt>406 Not Acceptable</tt> will be sent. If there is a matching
--   <tt>MediaType</tt>, that function is used to create the entity when a
--   response should include one. Defaults to <tt>[]</tt>.
[contentTypesProvided] :: Resource m -> m [(MediaType, HaltT m Body)]

-- | Used on GET requests to ensure that the entity is in <tt>Charset</tt>.
--   Defaults to <tt>NoCharset</tt>.
[charsetsProvided] :: Resource m -> m CharsetsProvided

-- | Used on GET requests to ensure that the body is encoded. One useful
--   setting is to have the function check on method, and on GET requests
--   return <tt>[("identity", id), ("gzip", compress)]</tt> as this is all
--   that is needed to support gzip content encoding. Defaults to
--   <tt>[]</tt>.
[encodingsProvided] :: Resource m -> m [(Encoding, Body -> Body)]

-- | <tt>False</tt> will result in <tt>404 Not Found</tt>. Defaults to
--   <tt>True</tt>.
[resourceExists] :: Resource m -> HaltT m Bool

-- | If this returns an <tt>ETag</tt>, it will be used for the ETag header
--   and for comparison in conditional requests. Defaults to
--   <tt>mzero</tt>.
[generateETag] :: Resource m -> MaybeT m ETag

-- | If this returns a <tt>HTTPDate</tt>, it will be used for the
--   Last-Modified header and for comparison in conditional requests.
--   Defaults to <tt>mzero</tt>.
[lastModified] :: Resource m -> MaybeT m HTTPDate

-- | If this returns a <tt>HTTPDate</tt>, it will be used for the Expires
--   header. Defaults to <tt>mzero</tt>.
[expires] :: Resource m -> MaybeT m HTTPDate

-- | If this returns a URI, the client will receive a 301 Moved Permanently
--   with the URI in the Location header. Defaults to <tt>mzero</tt>.
[movedPermanently] :: Resource m -> MaybeT (HaltT m) ByteString

-- | If this returns a URI, the client will receive a 307 Temporary
--   Redirect with URI in the Location header. Defaults to <tt>mzero</tt>.
[movedTemporarily] :: Resource m -> MaybeT (HaltT m) ByteString

-- | If this returns <tt>True</tt>, the <tt>movedPermanently</tt> and
--   <tt>movedTemporarily</tt> callbacks will be invoked to determine
--   whether the response should be 301 Moved Permanently, 307 Temporary
--   Redirect, or 410 Gone. Defaults to <tt>False</tt>.
[previouslyExisted] :: Resource m -> HaltT m Bool

-- | If the resource accepts POST requests to nonexistent resources, then
--   this should return <tt>True</tt>. Defaults to <tt>False</tt>.
[allowMissingPost] :: Resource m -> HaltT m Bool

-- | This is called when a DELETE request should be enacted, and should
--   return <tt>True</tt> if the deletion succeeded or has been accepted.
--   Defaults to <tt>True</tt>.
[deleteResource] :: Resource m -> HaltT m Bool

-- | This is only called after a successful <tt>deleteResource</tt> call,
--   and should return <tt>False</tt> if the deletion was accepted but
--   cannot yet be guaranteed to have finished. Defaults to <tt>True</tt>.
[deleteCompleted] :: Resource m -> HaltT m Bool

-- | If POST requests should be treated as a request to put content into a
--   (potentially new) resource as opposed to being a generic submission
--   for processing, then this function should return <tt>PostCreate
--   path</tt>. If it does return <tt>PostCreate path</tt>, then the rest
--   of the request will be treated much like a PUT to the path entry.
--   Otherwise, if it returns <tt>PostProcess a</tt>, then the action
--   <tt>a</tt> will be run. Defaults to <tt>PostProcess $ return ()</tt>.
[postAction] :: Resource m -> m (PostAction m)

-- | This is used similarly to <tt>contentTypesProvided</tt>, except that
--   it is for incoming resource representations -- for example,
--   <tt>PUT</tt> requests. Handler functions usually want to use server
--   specific functions to access the incoming request body. Defaults to
--   <tt>[]</tt>.
[contentTypesAccepted] :: Resource m -> m [(MediaType, HaltT m ())]

-- | This function should return a list of strings with header names that
--   should be included in a given response's Vary header. The standard
--   conneg headers (Accept, Accept-Encoding, Accept-Charset,
--   Accept-Language) do not need to be specified here as Webcrank will add
--   the correct elements of those automatically depending on resource
--   behavior. Defaults to <tt>[]</tt>.
[variances] :: Resource m -> m [HeaderName]

-- | If this returns <tt>True</tt>, then it is assumed that multiple
--   representations of the response are possible and a single one cannot
--   be automatically chosen, so a <tt>300 Multiple Choices</tt> will be
--   sent instead of a <tt>200 OK</tt>. Defaults to <tt>False</tt>.
[multipleChoices] :: Resource m -> HaltT m Bool

-- | If this returns <tt>True</tt>, the client will receive a 409 Conflict.
--   Defaults to <tt>False</tt>.
[isConflict] :: Resource m -> m Bool

-- | Called just before the final response is constructed and sent.
[finishRequest] :: Resource m -> m ()

-- | Builds a <tt>Resource m</tt> value where all the resource functions
--   will return default values as described in the
--   <tt><a>Resource</a></tt> function documentation.
resource :: Monad m => Resource m

-- | Creates a resource that provides a single content type.
resourceWithBody :: Monad m => MediaType -> m Body -> Resource m

-- | Creates a resource that provides a <tt>text/html</tt> content type.
resourceWithHtml :: Monad m => m Body -> Resource m

-- | Content coding type, e.g. gzip, decompress. See
--   <tt><a>encodingsProvided</a></tt>.
type Encoding = CI ByteString

-- | Indicates whether client is authorized to perform the requested
--   operation on the resource. See <tt><a>isAuthorized</a></tt>.
data Authorized

-- | Tells Webcrank that the client is authorized to perform the requested
--   operation on the resource.
[Authorized] :: Authorized

-- | Tells Webcrank that the client is not authorized to perform the
--   operation on the resource. The value is sent in the
--   <tt>WWW-Authenticate</tt> header of the response, e.g. <tt>Basic
--   realm=<a>Webcrank</a></tt>.
[Unauthorized] :: ByteString -> Authorized

-- | Weak or strong entity tags as used in HTTP ETag and
--   <tt>If-*-Match</tt> headers.
data ETag
[StrongETag] :: ByteString -> ETag
[WeakETag] :: ByteString -> ETag

-- | How <tt>POST</tt> requests should be treated. See
--   <tt><a>postAction</a></tt>.
data PostAction m

-- | Treat <tt>POST</tt>s as creating new resources and respond with
--   <tt>201 Created</tt>, with the given path in the Location header.
[PostCreate] :: [Text] -> PostAction m

-- | Treat <tt>POST</tt>s as creating new resources and respond with
--   <tt>301 See Other</tt>, redirecting the client to the new resource.
[PostCreateRedir] :: [Text] -> PostAction m

-- | Treat <tt>POST</tt>s as a process which is executed without redirect.
[PostProcess] :: (HaltT m ()) -> PostAction m

-- | Treat <tt>POST</tt>s as a process and redirect the client to a
--   different (possibly new) resource.
[PostProcessRedir] :: (HaltT m ByteString) -> PostAction m

-- | Create a <tt>PostAction</tt> which performs resource creation without
--   redirecting.
postCreate :: Monad m => [Text] -> m (PostAction m)

-- | Create a <tt>PostAction</tt> which performs resource creation and
--   redirects.
postCreateRedir :: Monad m => [Text] -> m (PostAction m)

-- | Create a <tt>PostAction</tt> which runs some process and does not
--   redirect.
postProcess :: Monad m => HaltT m () -> m (PostAction m)

-- | Create a <tt>PostAction</tt> which runs some process and does
--   redirects.
postProcessRedir :: Monad m => HaltT m ByteString -> m (PostAction m)

-- | Monad transformer for <tt><a>Resource</a></tt> functions which can
--   halt the request processing early with an error or some other
--   response. Values are created with the smart constructors
--   <tt><tt>werror</tt></tt> and <tt><tt>halt</tt></tt>.
data HaltT m a

-- | Immediately end processing of the request, returning the response
--   <tt>Status</tt>. It is the responsibility of the resource to ensure
--   that all necessary response header and body elements have been added
--   in order to make that response code valid.
halt :: Monad m => Status -> HaltT m a

-- | Immediately end processing of this request, returning a <tt>500
--   Internal Server Error</tt> response. The response body will contain
--   the reason.
werror :: Monad m => ByteString -> HaltT m a

-- | Immediately end processing of this request, returning a response with
--   the given <tt>Status</tt>. The response body will contain the reason.
werrorWith :: Monad m => Status -> ByteString -> HaltT m a

-- | The “local” path of the resource URI; the part after any prefix used
--   in dispatch configuration. Of the three path accessors, this is the
--   one you usually want. This is also the one that will change after
--   postAction is called in your resource.
getDispatchPath :: (MonadState s m, HasReqData s) => m [Text]

-- | Container used to keep track of the decision state and what is known
--   about response while processing a request.
data ReqData
class HasReqData c_arV9 where reqDataDispPath = (.) reqData reqDataDispPath reqDataRespBody = (.) reqData reqDataRespBody reqDataRespCharset = (.) reqData reqDataRespCharset reqDataRespEncoding = (.) reqData reqDataRespEncoding reqDataRespHeaders = (.) reqData reqDataRespHeaders reqDataRespMediaType = (.) reqData reqDataRespMediaType

-- | Character set type, e.g. utf-8. See <tt><a>charsetsProvided</a></tt>.
type Charset = CI ByteString

-- | Indicates whether the resource supports multiple character sets or
--   not. See <tt><a>charsetsProvided</a></tt>
data CharsetsProvided

-- | Indicates that the resource doesn't support any additional character
--   sets, all responses from the resource will have the same character
--   set, regardless of what the client requests.
[NoCharset] :: CharsetsProvided

-- | The character sets the resource supports along with functions for
--   converting the response body.
[CharsetsProvided] :: (NonEmpty (Charset, Body -> Body)) -> CharsetsProvided

-- | Shortcut for <tt>return . CharsetsProvided</tt>
provideCharsets :: Monad m => NonEmpty (Charset, Body -> Body) -> m CharsetsProvided
type HeadersMap = HashMap HeaderName [ByteString]

-- | Add a header to the response.
addResponseHeader :: (MonadState s m, HasReqData s) => HeaderName -> ByteString -> m ()

-- | Replace any existing response headers for the header name with the new
--   value.
putResponseHeader :: (MonadState s m, HasReqData s) => HeaderName -> ByteString -> m ()

-- | Response body type.
type Body = ByteString

-- | Create a response <tt>Body</tt> from a lazy <tt>ByteString</tt>.
lazyByteStringBody :: ByteString -> Body

-- | Create a response <tt>Body</tt> from a <tt>ByteString</tt>.
byteStringBody :: ByteString -> Body

-- | Create a response <tt>Body</tt> from lazy <tt>Text</tt>.
lazyTextBody :: Text -> Body

-- | Create a response <tt>Body</tt> from strict <tt>Text</tt>.
textBody :: Text -> Body

-- | Create a response <tt>Body</tt> from a <tt>String</tt>.
strBody :: String -> Body

-- | Use the <tt>Body</tt> as the response body.
writeBody :: (MonadState s m, HasReqData s) => ByteString -> m ()

-- | Use the lazy <tt>ByteString</tt> as the response body.
writeLBS :: (MonadState s m, HasReqData s) => ByteString -> m ()

-- | Use the <tt>ByteString</tt> as the response body.
writeBS :: (MonadState s m, HasReqData s) => ByteString -> m ()

-- | Use the lazy <tt>Text</tt> as the response body.
writeLT :: (MonadState s m, HasReqData s) => Text -> m ()

-- | Use the <tt>Text</tt> as the response body.
writeText :: (MonadState s m, HasReqData s) => Text -> m ()

-- | Use the <tt>String</tt> as the response body.
writeStr :: (MonadState s m, HasReqData s) => String -> m ()
hAcceptCharset :: HeaderName
hAcceptEncoding :: HeaderName
hAllow :: HeaderName
hETag :: HeaderName
hExpires :: HeaderName
hIfMatch :: HeaderName
hIfNoneMatch :: HeaderName
hIfUnmodifiedSince :: HeaderName
hTransferEncoding :: HeaderName
hVary :: HeaderName
hWWWAuthenticate :: HeaderName
