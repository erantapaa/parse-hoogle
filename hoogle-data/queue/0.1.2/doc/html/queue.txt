-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstraction typeclasses for queue-like things.
--   
--   A collection of abstract interfaces to mutable queue-like things. Note
--   that I named this module before I realized that there was a module of
--   the same name in (base&lt;3). I am open to suggestions for a new name.
@package queue
@version 0.1.2

module Data.Queue.Classes

-- | Construct a new FIFO queue.
class Monad m => NewFifo q m
newFifo :: NewFifo q m => m q

-- | A type class carrying an altered set of functional dependencies used
--   to constrain queues when the type of the queue never escapes far
--   enough for a more deliberate choice to be made.
class Monad m => DefaultFifo q m a | q -> a, m a -> q
class Monad m => Enqueue q m a | q -> a
enqueue :: Enqueue q m a => q -> a -> m ()
enqueueBatch :: Enqueue q m a => q -> [a] -> m ()
class Monad m => Dequeue q m a | q -> a
dequeue :: Dequeue q m a => q -> m (Maybe a)
dequeueBatch :: Dequeue q m a => q -> m [a]
class Monad m => DequeueWhere q m a | q -> a
dequeueWhere :: DequeueWhere q m a => q -> (a -> Bool) -> m (Maybe a)
class Monad m => PeekQueue q m a | q -> a
peekQueue :: PeekQueue q m a => q -> m [a]
peekQueueTaking :: PeekQueue q m a => Int -> q -> m [a]
class Monad m => QueueSize q m
queueSize :: QueueSize q m => q -> m Int

module Data.Queue.Instances

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a :: * -> *

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a a box, which may be empty or full.
data MVar a :: * -> *

-- | A monad supporting atomic memory transactions.
data STM a :: * -> *

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data TChan a :: * -> *

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a :: * -> *

-- | Perform a series of STM actions atomically.
--   
--   You cannot use <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>. Any attempt to do so will result in a
--   runtime error. (Reason: allowing this would effectively allow a
--   transaction inside a transaction, depending on exactly when the thunk
--   is evaluated.)
--   
--   However, see <a>newTVarIO</a>, which can be called inside
--   <a>unsafePerformIO</a>, and which allows top-level TVars to be
--   allocated.
atomically :: STM a -> IO a
instance Dequeue (MVar a) IO a
instance Enqueue (MVar a) IO a
instance NewFifo (MVar a) IO
instance Enqueue (Chan a) IO a
instance NewFifo (Chan a) IO

module Data.Queue

-- | Construct a new FIFO queue.
class Monad m => NewFifo q m
newFifo :: NewFifo q m => m q

-- | A type class carrying an altered set of functional dependencies used
--   to constrain queues when the type of the queue never escapes far
--   enough for a more deliberate choice to be made.
class Monad m => DefaultFifo q m a | q -> a, m a -> q
class Monad m => Enqueue q m a | q -> a
enqueue :: Enqueue q m a => q -> a -> m ()
enqueueBatch :: Enqueue q m a => q -> [a] -> m ()
class Monad m => Dequeue q m a | q -> a
dequeue :: Dequeue q m a => q -> m (Maybe a)
dequeueBatch :: Dequeue q m a => q -> m [a]
class Monad m => DequeueWhere q m a | q -> a
dequeueWhere :: DequeueWhere q m a => q -> (a -> Bool) -> m (Maybe a)
class Monad m => PeekQueue q m a | q -> a
peekQueue :: PeekQueue q m a => q -> m [a]
peekQueueTaking :: PeekQueue q m a => Int -> q -> m [a]
class Monad m => QueueSize q m
queueSize :: QueueSize q m => q -> m Int

-- | <a>RQueue</a> : read-only newtype wrapper for arbitrary queues
data RQueue q
mkRQueue :: q -> RQueue q

-- | <a>WQueue</a> : write-only newtype wrapper for arbitrary queues
data WQueue q
mkWQueue :: q -> WQueue q
instance Enqueue q m a => Enqueue (WQueue q) m a
instance Dequeue q m a => Dequeue (RQueue q) m a
