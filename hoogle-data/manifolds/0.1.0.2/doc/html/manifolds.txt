-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Working with manifolds in a direct, embedding-free way.
--   
@package manifolds
@version 0.1.0.2

module Data.LinearMap.HerMetric

-- | <a>HerMetric</a> is a portmanteau of <i>Hermitian</i> and
--   <i>metric</i> (in the sense as used in e.g. general relativity –
--   though those particular ones aren't positive definite and thus not
--   really metrics).
--   
--   Mathematically, there are two directly equivalent ways to describe
--   such a metric: as a bilinear mapping of two vectors to a scalar, or as
--   a linear mapping from a vector space to its dual space. We choose the
--   latter, though you can always as well think of metrics as “quadratic
--   dual vectors”.
--   
--   Yet other possible interpretations of this type include <i>density
--   matrix</i> (as in quantum mechanics), <i>standard range of statistical
--   fluctuations</i>, and <i>volume element</i>.
data HerMetric v

-- | A metric on the dual space; equivalent to a linear mapping from the
--   dual space to the original vector space.
--   
--   Prime-versions of the functions in this module target those dual-space
--   metrics, so we can avoid some explicit handling of double-dual spaces.
data HerMetric' v

-- | Evaluate a vector through a metric. For the canonical metric on a
--   Hilbert space, this will be simply <a>magnitudeSq</a>.
metricSq :: HasMetric v => HerMetric v -> v -> Scalar v
metricSq' :: HasMetric v => HerMetric' v -> DualSpace v -> Scalar v

-- | Evaluate a vector's “magnitude” through a metric. This assumes an
--   actual mathematical metric, i.e. positive definite – otherwise the
--   internally used square root may get negative arguments (though it can
--   still produce results if the scalars are complex; however, complex
--   spaces aren't supported yet).
metric :: (HasMetric v, Floating (Scalar v)) => HerMetric v -> v -> Scalar v
metric' :: (HasMetric v, Floating (Scalar v)) => HerMetric' v -> DualSpace v -> Scalar v

-- | Square-sum over the metrics for each dual-space vector.
--   
--   <pre>
--   metrics m vs ≡ sqrt . sum $ metricSq m <a>&lt;$&gt;</a> vs
--   </pre>
metrics :: (HasMetric v, Floating (Scalar v)) => HerMetric v -> [v] -> Scalar v
metrics' :: (HasMetric v, Floating (Scalar v)) => HerMetric' v -> [DualSpace v] -> Scalar v

-- | A metric on <tt>v</tt> that simply yields the squared overlap of a
--   vector with the given dual-space reference.
--   
--   It will perhaps be the most common way of defining <a>HerMetric</a>
--   values to start with such dual-space vectors and superimpose the
--   projectors using the <a>VectorSpace</a> instance; e.g.
--   <tt><a>projector</a> (1,0) <a>^+^</a> <a>projector</a> (0,2)</tt>
--   yields a hermitian operator describing the ellipsoid span of the
--   vectors <i>e</i>₀ and 2⋅<i>e</i>₁. Metrics generated this way are
--   positive definite if no negative coefficients have been introduced
--   with the <a>*^</a> scaling operator or with <a>^-^</a>.
projector :: HasMetric v => DualSpace v -> HerMetric v
projector' :: HasMetric v => v -> HerMetric' v

-- | Transpose a linear operator. Contrary to popular belief, this does not
--   just inverse the direction of mapping between the spaces, but also
--   switch to their duals.
adjoint :: (HasMetric v, HasMetric w, Scalar w ~ Scalar v) => (v :-* w) -> DualSpace w :-* DualSpace v
transformMetric :: (HasMetric v, HasMetric w, Scalar v ~ Scalar w) => (w :-* v) -> HerMetric v -> HerMetric w
transformMetric' :: (HasMetric v, HasMetric w, Scalar v ~ Scalar w) => (v :-* w) -> HerMetric' v -> HerMetric' w
dualiseMetric :: (HasMetric v, HasMetric (DualSpace v)) => HerMetric (DualSpace v) -> HerMetric' v
dualiseMetric' :: (HasMetric v, HasMetric (DualSpace v)) => HerMetric' v -> HerMetric (DualSpace v)

-- | While the main purpose of this class is to express <a>HerMetric</a>,
--   it's actually all about dual spaces.
class (HasBasis v, VectorSpace (Scalar v), HasTrie (Basis v), VectorSpace (DualSpace v), HasBasis (DualSpace v), Scalar v ~ Scalar (DualSpace v), Basis v ~ Basis (DualSpace v)) => HasMetric v where type family DualSpace v :: * type instance DualSpace v = v
(<.>^) :: HasMetric v => DualSpace v -> v -> Scalar v
functional :: HasMetric v => (v -> Scalar v) -> DualSpace v
doubleDual :: (HasMetric v, HasMetric (DualSpace v)) => v -> DualSpace (DualSpace v)
doubleDual' :: (HasMetric v, HasMetric (DualSpace v)) => DualSpace (DualSpace v) -> v

-- | Simple flipped version of <a>&lt;.&gt;^</a>.
(^<.>) :: HasMetric v => v -> DualSpace v -> Scalar v
metriScale :: (HasMetric v, Floating (Scalar v)) => HerMetric v -> v -> v
metriScale' :: (HasMetric v, Floating (Scalar v)) => HerMetric' v -> DualSpace v -> DualSpace v
instance (HasMetric v, v ~ Scalar v, v ~ DualSpace v, Floating v) => Floating (HerMetric v)
instance (HasMetric v, v ~ Scalar v, v ~ DualSpace v, Fractional v) => Fractional (HerMetric v)
instance (HasMetric v, v ~ DualSpace v, Num (Scalar v)) => Num (HerMetric v)
instance (HasMetric v, HasMetric w, Scalar v ~ Scalar w, HasMetric (DualSpace v), DualSpace (DualSpace v) ~ v, HasMetric (DualSpace w), DualSpace (DualSpace w) ~ w) => HasMetric (v, w)
instance HasMetric Double
instance VectorSpace k => HasMetric (ZeroDim k)
instance HasMetric v => VectorSpace (HerMetric' v)
instance HasMetric v => AdditiveGroup (HerMetric' v)
instance HasMetric v => VectorSpace (HerMetric v)
instance HasMetric v => AdditiveGroup (HerMetric v)


-- | This is the second prototype of a manifold class. It appears to give
--   considerable advantages over <a>Manifold</a>, so that class will
--   probably soon be replaced with the one we define here (though
--   <a>PseudoAffine</a> does not follow the standard notion of a manifold
--   very closely, it should work quite equivalently for pretty much all
--   Haskell types that qualify as manifolds).
--   
--   Manifolds are interesting as objects of various categories, from
--   continuous to diffeomorphic. At the moment, we mainly focus on
--   <i>region-wise differentiable functions</i>, which are a promising
--   compromise between flexibility of definition and provability of
--   analytic properties. In particular, they are well-suited for
--   visualisation purposes.
module Data.Manifold.PseudoAffine

-- | <a>PseudoAffine</a> is intended as an alternative class for
--   <a>Manifold</a>s. The interface is almost identical to the
--   better-known <a>AffineSpace</a> class, but unlike in the mathematical
--   definition of affine spaces we don't require associativity of
--   <a>.+~^</a> with <a>^+^</a> – except in an asymptotic sense for small
--   vectors.
--   
--   That innocent-looking change makes the class applicable to vastly more
--   general types: while an affine space is basically nothing but a vector
--   space without particularly designated origin, a pseudo-affine space
--   can have nontrivial topology on the global scale, and yet be used in
--   practically the same way as an affine space. At least the usual
--   spheres and tori make good instances, perhaps the class is in fact
--   equivalent to <i>parallelisable manifolds</i>.
class PseudoAffine x where type family PseudoDiff x :: *
(.-~.) :: PseudoAffine x => x -> x -> Option (PseudoDiff x)
(.+~^) :: PseudoAffine x => x -> PseudoDiff x -> x

-- | A pathwise connected subset of a manifold <tt>m</tt>, whose tangent
--   space has scalar <tt>s</tt>.
data Region s m

-- | The category of differentiable functions between manifolds over scalar
--   <tt>s</tt>.
--   
--   As you might guess, these offer <i>automatic differentiation</i> of
--   sorts (basically, simple forward AD), but that's in itself is not
--   really the killer feature here. More interestingly, we actually have
--   the (à la Curry-Howard) <i>proof</i> built in: the function <i>f</i>
--   has at <i>x</i>₀ derivative <i>f'ₓ</i>₀, if, for¹ <i>ε</i>&gt;0, there
--   exists <i>δ</i> such that |<i>f</i> <i>x</i> − (<i>f</i> <i>x</i>₀ +
--   <i>x</i>⋅<i>f'ₓ</i>₀)| &lt; <i>ε</i> for all |<i>x</i> − <i>x</i>₀|
--   &lt; <i>δ</i>.
--   
--   Observe that, though this looks quite similar to the standard
--   definition of differentiability, it is not equivalent thereto – in
--   fact it does not prove any analytic properties at all. To make it
--   equivalent, we need a lower bound on <i>δ</i>: simply <i>δ</i> gives
--   us continuity, and for continuous differentiability, <i>δ</i> must
--   grow at least like √<i>ε</i> for small <i>ε</i>. Neither of these
--   conditions are enforced by the type system, but we do require them for
--   any allowed values because these proofs are obviously tremendously
--   useful – for instance, you can have a root-finding algorithm and
--   actually be sure you get <i>all</i> solutions correctly, not just
--   <i>some</i> that are (hopefully) the closest to some reference point
--   you'd need to laborously define!
--   
--   Unfortunately however, this also prevents doing any serious algebra
--   etc. with the category, because even something as simple as division
--   necessary introduces singularities where the derivatives must diverge.
--   Not to speak of many trigonometric e.g. trigonometric functions that
--   are undefined on whole regions. The <a>PWDiffable</a> and
--   <a>RWDiffable</a> categories have explicit handling for those issues
--   built in; you may simply use these categories even when you know the
--   result will be smooth in your relevant domain (or must be, for e.g.
--   physics reasons).
--   
--   ¹(The implementation does not deal with <i>ε</i> and <i>δ</i> as
--   difference-bounding reals, but rather as metric tensors that define a
--   boundary by prohibiting the overlap from exceeding one; this makes the
--   concept actually work on general manifolds.)
data Differentiable s d c

-- | Category of functions that almost everywhere have an open region in
--   which they are continuously differentiable, i.e.
--   <i>PieceWiseDiff'able</i>.
data PWDiffable s d c

-- | Category of functions that, where defined, have an open region in
--   which they are continuously differentiable. Hence
--   <i>RegionWiseDiff'able</i>. Basically these are the partial version of
--   <a>PWDiffable</a>.
--   
--   Though the possibility of undefined regions is of course not too nice
--   (we don't need Java to demonstrate this with its everywhere-looming
--   <tt>null</tt> values...), this category will propably be the
--   “workhorse” for most serious calculus applications, because it
--   contains all the usual trig etc. functions and of course everything
--   algebraic you can do in the reals.
--   
--   The easiest way to define ordinary functions in this category is hence
--   with its <a>AgentVal</a>ues, which have instances of the standard
--   classes <a>Num</a> through <a>Floating</a>. For instance, the
--   following defines the <i>binary entropy</i> as a differentiable
--   function on the interval <tt>]0,1[</tt>: (it will actually <i>know</i>
--   where it's defined and where not! – and I don't mean you need to
--   exhaustively <a>isNaN</a>-check all results...)
--   
--   <pre>
--   hb :: RWDiffable R R R
--   hb = alg (\p -&gt; - p * logBase 2 p - (1-p) * logBase 2 (1-p) )
--   </pre>
data RWDiffable s d c
instance (RealDimension n, LocallyScalable n a) => Floating (RWDfblFuncValue n a n)
instance (RealDimension n, LocallyScalable n a) => Fractional (RWDfblFuncValue n a n)
instance (RealDimension n, LocallyScalable n a) => Num (RWDfblFuncValue n a n)
instance (LinearManifold s v, LocallyScalable s a, RealDimension s) => AdditiveGroup (RWDfblFuncValue s a v)
instance (RealDimension s) => PointAgent (RWDfblFuncValue s) (RWDiffable s) a x
instance (RealDimension s) => CartesianAgent (RWDiffable s)
instance (RealDimension s) => HasAgent (RWDiffable s)
instance (RealDimension s) => WellPointed (RWDiffable s)
instance (RealDimension s) => PreArrow (RWDiffable s)
instance (RealDimension s) => Morphism (RWDiffable s)
instance (RealDimension s) => Cartesian (RWDiffable s)
instance (RealDimension s) => EnhancedCat (RWDiffable s) (PWDiffable s)
instance (RealDimension s) => EnhancedCat (RWDiffable s) (Differentiable s)
instance (RealDimension s) => Category (RWDiffable s)
instance (RealDimension n, LocallyScalable n a) => Fractional (PWDfblFuncValue n a n)
instance (RealDimension n, LocallyScalable n a) => Num (PWDfblFuncValue n a n)
instance (LinearManifold s v, LocallyScalable s a, RealDimension s) => AdditiveGroup (PWDfblFuncValue s a v)
instance (RealDimension s) => PointAgent (PWDfblFuncValue s) (PWDiffable s) a x
instance (RealDimension s) => CartesianAgent (PWDiffable s)
instance (RealDimension s) => HasAgent (PWDiffable s)
instance (RealDimension s) => WellPointed (PWDiffable s)
instance (RealDimension s) => PreArrow (PWDiffable s)
instance (RealDimension s) => Morphism (PWDiffable s)
instance (RealDimension s) => Cartesian (PWDiffable s)
instance (RealDimension s) => EnhancedCat (PWDiffable s) (Differentiable s)
instance (RealDimension s) => Category (PWDiffable s)
instance (RealDimension n, LocallyScalable n a) => Num (DfblFuncValue n a n)
instance (LinearManifold s v, LocallyScalable s a, Floating s) => AdditiveGroup (DfblFuncValue s a v)
instance VectorSpace s => PointAgent (DfblFuncValue s) (Differentiable s) a x
instance VectorSpace s => CartesianAgent (Differentiable s)
instance VectorSpace s => HasAgent (Differentiable s)
instance VectorSpace s => WellPointed (Differentiable s)
instance VectorSpace s => PreArrow (Differentiable s)
instance VectorSpace s => Morphism (Differentiable s)
instance VectorSpace s => Cartesian (Differentiable s)
instance VectorSpace s => Category (Differentiable s)
instance PseudoAffine S²
instance PseudoAffine S¹
instance (PseudoAffine a, PseudoAffine b, PseudoAffine c) => PseudoAffine (a, b, c)
instance (PseudoAffine a, PseudoAffine b) => PseudoAffine (a, b)
instance PseudoAffine (ZeroDim k)
instance PseudoAffine Rational
instance PseudoAffine Double


-- | This is something of a first attempt at formalising manifolds and
--   continuous mappings thereon. They <i>work</i> (check out
--   <a>http://hackage.haskell.org/package/dynamic-plot-0.1.0.0</a> for a
--   use case), but aren't very efficient. The interface might well change
--   considerably in the future.
module Data.Manifold

-- | Continuous mapping.
data (:-->) domain codomain
Continuous :: (Chart d -> v -> (Chart c, u, ε -> Option δ)) -> d :--> c
runContinuous :: d :--> c -> Chart d -> v -> (Chart c, u, ε -> Option δ)
continuous_id' :: Manifold m => m :--> m
const__ :: (Manifold c, Manifold d) => c -> d :--> c
flatContinuous :: (FlatManifold v, FlatManifold w, δ ~ Metric v, ε ~ Metric w) => (v -> (w, ε -> Option δ)) -> (v :--> w)
runFlatContinuous :: (FlatManifold v, FlatManifold w, δ ~ Metric v, ε ~ Metric w) => (v :--> w) -> v -> (w, ε -> Option δ)

-- | A chart is a homeomorphism from a connected, open subset <i>Q</i> ⊂
--   <i>M</i> of an <i>n</i>-manifold <i>M</i> to either the open unit disk
--   <i>Dⁿ</i> ⊂ <i>V</i> ≃ ℝ<i>ⁿ</i>, or the half-disk <i>Hⁿ</i> =
--   {<i>x</i> ∊ <i>Dⁿ</i>: x₀≥0}. In e.g. the former case,
--   <a>chartInMap</a> is thus defined ∀ <i>v</i> ∊ <i>V</i> : |<i>v</i>|
--   &lt; 1, while 'chartOutMap p' will yield <tt>Just x</tt> with <i>x</i>
--   ∊ <i>Dⁿ</i> provided <i>p</i> is in <i>Q</i>, and <tt>Nothing</tt>
--   otherwise. Obviously, <tt>fromJust . <a>chartOutMap</a> .
--   <a>chartInMap</a></tt> should be equivalent to <tt>id</tt> on
--   <i>Dⁿ</i>, and <tt><a>chartInMap</a> . fromJust .
--   <a>chartOutMap</a></tt> to <tt>id</tt> on <i>Q</i>.
data Chart :: * -> *
IdChart :: Chart v
Chart :: v :--> m -> (m -> Maybe (m :--> v)) -> ChartKind -> Chart m
chartInMap :: Chart m -> v :--> m
chartOutMap :: Chart m -> m -> Maybe (m :--> v)
chartKind :: Chart m -> ChartKind
data ChartKind

-- | A <i>M</i> ⇆ <i>Dⁿ</i> chart, for ordinary manifolds
LandlockedChart :: ChartKind

-- | A <i>M</i> ⇆ <i>Hⁿ</i> chart, for manifolds with a rim
RimChart :: ChartKind
type FlatManifold v = (MetricSpace v, Manifold v, v ~ TangentSpace v)
isInUpperHemi :: EuclidSpace v => v -> Bool
type Atlas m = [Chart m]
class (MetricSpace (TangentSpace m), Metric (TangentSpace m) ~ ℝ) => Manifold m where type family TangentSpace m :: * type instance TangentSpace m = m
localAtlas :: Manifold m => m -> Atlas m
vectorSpaceAtlas :: FlatManifold v => v -> Atlas v
type Representsℝ r = (EqFloating r, FlatManifold r, r ~ Scalar r, r ~ Metric r)
continuousFlatFunction :: (FlatManifold d, FlatManifold c, ε ~ Metric c, δ ~ Metric d) => (d -> (c, ε -> Option δ)) -> d :--> c
type CntnRealFunction = Representsℝ r => r :--> r
sin__ :: CntnRealFunction
asinh__ :: CntnRealFunction
tanh__ :: CntnRealFunction
cosh__ :: CntnRealFunction
sinh__ :: CntnRealFunction
exp__ :: CntnRealFunction
atan__ :: CntnRealFunction
cos__ :: CntnRealFunction
cntnFuncsCombine :: (FlatManifold c, FlatManifold c', FlatManifold c'', ε ~ Metric c, ε' ~ Metric c', ε'' ~ Metric c'', ε ~ ε', ε ~ ε'') => (c' -> c'' -> (c, ε -> (ε', ε''))) -> (d :--> c') -> (d :--> c'') -> d :--> c
data CntnFuncValue d c
CntnFuncValue :: d :--> c -> CntnFuncValue d c
runCntnFuncValue :: CntnFuncValue d c -> d :--> c
CntnFuncConst :: c -> CntnFuncValue d c
cntnFnValsFunc :: (FlatManifold c, FlatManifold c', Manifold d, ε ~ Metric c, ε ~ Metric c') => (c' -> (c, ε -> Option ε)) -> CntnFuncValue d c' -> CntnFuncValue d c
cntnFnValsCombine :: (FlatManifold c, FlatManifold c', FlatManifold c'', Manifold d, ε ~ Metric c, ε' ~ Metric c', ε'' ~ Metric c'', ε ~ ε', ε ~ ε'') => (c' -> c'' -> (c, ε -> (ε', (ε', ε''), ε''))) -> CntnFuncValue d c' -> CntnFuncValue d c'' -> CntnFuncValue d c
finiteGraphContinℝtoℝ :: GraphWindowSpec -> (Double :--> Double) -> [(Double, Double)]
finiteGraphContinℝtoℝ² :: GraphWindowSpec -> (Double :--> (Double, Double)) -> [[(Double, Double)]]
midBetween :: (VectorSpace v, Fractional (Scalar v)) => [v] -> v
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
just :: a -> Option a
nothing :: Option a
class (RealFloat (Metric v), InnerSpace v) => MetricSpace v where type family Metric v :: * type instance Metric v = ℝ metric = sqrt . metricSq metricSq = (^ 2) . metric μ |*^ v = metricToScalar v μ *^ v
metric :: MetricSpace v => v -> Metric v
metricSq :: MetricSpace v => v -> Metric v
(|*^) :: MetricSpace v => Metric v -> v -> v
metricToScalar :: MetricSpace v => v -> Metric v -> Scalar v
type EuclidSpace v = (HasBasis v, EqFloating (Scalar v), Eq v)
type EqFloating f = (Eq f, Ord f, Floating f)
data GraphWindowSpec
GraphWindowSpec :: Double -> Double -> Double -> Double -> Int -> Int -> GraphWindowSpec
lBound :: GraphWindowSpec -> Double
rBound :: GraphWindowSpec -> Double
bBound :: GraphWindowSpec -> Double
tBound :: GraphWindowSpec -> Double
xResolution :: GraphWindowSpec -> Int
yResolution :: GraphWindowSpec -> Int
data ZeroDim k
Origin :: ZeroDim k
data S⁰
PositiveHalfSphere :: S⁰
NegativeHalfSphere :: S⁰
newtype S¹
S¹ :: Double -> S¹
φParamS¹ :: S¹ -> Double
data S²
S² :: !Double -> !Double -> S²
ϑParamS² :: S² -> !Double
φParamS² :: S² -> !Double
class NaturallyEmbedded m v
embed :: NaturallyEmbedded m v => m -> v
coEmbed :: NaturallyEmbedded m v => v -> m
type Endomorphism a = a -> a
type ℝ = Double
type ℝ² = (ℝ, ℝ)
type ℝ³ = (ℝ², ℝ)
(^) :: Num a => a -> Int -> a
instance (MetricSpace v, MetricSpace (Scalar v), MetricSpace w, Scalar v ~ Scalar w, Metric v ~ Metric (Scalar v), Metric w ~ Metric v, Metric (Scalar w) ~ Metric v, RealFloat (Metric v)) => MetricSpace (v, w)
instance (RealFloat r, MetricSpace r, Scalar (Complex r) ~ Metric r) => MetricSpace (Complex r)
instance MetricSpace ℝ
instance MetricSpace ()
instance (FlatManifold v, MetricSpace v, Metric v ~ ℝ, FlatManifold (Scalar v), MetricSpace (Scalar v), Metric (Scalar v) ~ ℝ, Manifold d) => VectorSpace (CntnFuncValue d v)
instance (FlatManifold v, Manifold d) => AdditiveGroup (CntnFuncValue d v)
instance (Representsℝ r, Manifold d) => Floating (CntnFuncValue d r)
instance (Representsℝ r, Manifold d) => Fractional (CntnFuncValue d r)
instance (Representsℝ r, Manifold d) => Num (CntnFuncValue d r)
instance CartesianAgent (:-->)
instance PointAgent CntnFuncValue (:-->) d c
instance HasAgent (:-->)
instance (FlatManifold v₁, FlatManifold v₂, Scalar v₁ ~ Scalar v₂, MetricSpace (Scalar v₁), Metric (Scalar v₁) ~ ℝ, VectorSpace (v₁, v₂), Scalar (v₁, v₂) ~ Scalar v₁) => Manifold (v₁, v₂)
instance Manifold Double
instance Manifold ()
instance PreArrow (:-->)
instance Morphism (:-->)
instance Cartesian (:-->)
instance EnhancedCat (->) (:-->)
instance Category (:-->)
