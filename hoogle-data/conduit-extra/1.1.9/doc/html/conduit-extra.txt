-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Batteries included conduit: adapters for common libraries.
--   
@package conduit-extra
@version 1.1.9


-- | Streaming compression and decompression using conduits.
--   
--   Parts of this code were taken from zlib-enum and adapted for conduits.
module Data.Conduit.Zlib

-- | Compress (deflate) a stream of <a>ByteString</a>s. The
--   <a>WindowBits</a> also control the format (zlib vs. gzip).
compress :: (MonadBase base m, PrimMonad base, MonadThrow m) => Int -> WindowBits -> Conduit ByteString m ByteString

-- | Decompress (inflate) a stream of <a>ByteString</a>s. For example:
--   
--   <pre>
--   sourceFile "test.z" $= decompress defaultWindowBits $$ sinkFile "test"
--   </pre>
decompress :: (MonadBase base m, PrimMonad base, MonadThrow m) => WindowBits -> Conduit ByteString m ByteString

-- | Gzip compression with default parameters.
gzip :: (MonadThrow m, MonadBase base m, PrimMonad base) => Conduit ByteString m ByteString

-- | Gzip decompression with default parameters.
ungzip :: (MonadBase base m, PrimMonad base, MonadThrow m) => Conduit ByteString m ByteString

-- | Same as <a>compress</a>, but allows you to explicitly flush the
--   stream.
compressFlush :: (MonadBase base m, PrimMonad base, MonadThrow m) => Int -> WindowBits -> Conduit (Flush ByteString) m (Flush ByteString)

-- | Same as <a>decompress</a>, but allows you to explicitly flush the
--   stream.
decompressFlush :: (MonadBase base m, PrimMonad base, MonadThrow m) => WindowBits -> Conduit (Flush ByteString) m (Flush ByteString)

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>8..15</tt>
--   which corresponds to compression window sizes of 256b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
data WindowBits :: *
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a> is 15 which is also the maximum size.
defaultWindowBits :: WindowBits


-- | Handle streams of text.
--   
--   Parts of this code were taken from enumerator and adapted for
--   conduits.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Text

-- | A specific character encoding.
--   
--   Since 0.3.0
data Codec

-- | Convert text into bytes, using the provided codec. If the codec is not
--   capable of representing an input character, an exception will be
--   thrown.
--   
--   Since 0.3.0
encode :: MonadThrow m => Codec -> Conduit Text m ByteString

-- | Convert bytes into text, using the provided codec. If the codec is not
--   capable of decoding an input byte sequence, an exception will be
--   thrown.
--   
--   Since 0.3.0
decode :: MonadThrow m => Codec -> Conduit ByteString m Text

-- | Since 0.3.0
utf8 :: Codec

-- | Since 0.3.0
utf16_le :: Codec

-- | Since 0.3.0
utf16_be :: Codec

-- | Since 0.3.0
utf32_le :: Codec

-- | Since 0.3.0
utf32_be :: Codec

-- | Since 0.3.0
ascii :: Codec

-- | Since 0.3.0
iso8859_1 :: Codec

-- | Emit each line separately
--   
--   Since 0.4.1
lines :: Monad m => Conduit Text m Text

-- | Variant of the lines function with an integer parameter. The text
--   length of any emitted line never exceeds the value of the parameter.
--   Whenever this is about to happen a LengthExceeded exception is thrown.
--   This function should be used instead of the lines function whenever we
--   are dealing with user input (e.g. a file upload) because we can't be
--   sure that user input won't have extraordinarily large lines which
--   would require large amounts of memory if consumed.
linesBounded :: MonadThrow m => Int -> Conduit Text m Text

-- | Since 0.3.0
data TextException
DecodeException :: Codec -> Word8 -> TextException
EncodeException :: Codec -> Char -> TextException
LengthExceeded :: Int -> TextException
TextException :: SomeException -> TextException
NewDecodeException :: !Text -> !Int -> !ByteString -> TextException

-- | Since 1.0.8
takeWhile :: Monad m => (Char -> Bool) -> Conduit Text m Text

-- | Since 1.0.8
dropWhile :: Monad m => (Char -> Bool) -> Consumer Text m ()

-- | Since 1.0.8
take :: Monad m => Int -> Conduit Text m Text

-- | Since 1.0.8
drop :: Monad m => Int -> Consumer Text m ()

-- | Since 1.0.8
foldLines :: Monad m => (a -> ConduitM Text o m a) -> a -> ConduitM Text o m a

-- | Since 1.0.8
withLine :: Monad m => Sink Text m a -> Consumer Text m (Maybe a)

-- | Decode a stream of UTF8-encoded bytes into a stream of text, throwing
--   an exception on invalid input.
--   
--   Since 1.0.15
decodeUtf8 :: MonadThrow m => Conduit ByteString m Text

-- | Decode a stream of UTF8 data, and replace invalid bytes with the
--   Unicode replacement character.
--   
--   Since 1.1.1
decodeUtf8Lenient :: Monad m => Conduit ByteString m Text

-- | Encode a stream of text into a stream of bytes.
--   
--   Since 1.0.15
encodeUtf8 :: Monad m => Conduit Text m ByteString

-- | Automatically determine which UTF variant is being used. This function
--   checks for BOMs, removing them as necessary. It defaults to assuming
--   UTF-8.
--   
--   Since 1.1.9
detectUtf :: MonadThrow m => Conduit ByteString m Text
instance Typeable TextException
instance Exception TextException
instance Show TextException
instance Show Codec

module Data.Conduit.Network.UDP

-- | Representation of a single UDP message
data Message :: *
Message :: SrictNotUnpackedByteString -> SrictNotUnpackedSockAddr -> Message
msgData :: Message -> SrictNotUnpackedByteString
msgSender :: Message -> SrictNotUnpackedSockAddr

-- | Stream messages from the socket.
--   
--   The given <tt>len</tt> defines the maximum packet size. Every produced
--   item contains the message payload and the origin address.
--   
--   This function does <i>not</i> automatically close the socket.
sourceSocket :: MonadIO m => Socket -> Int -> Producer m Message

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>send</tt>, so some of it might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>sendAll</tt>, so it might end up in
--   multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendTo</tt>, so some of it
--   might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkToSocket :: MonadIO m => Socket -> Consumer Message m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendAllTo</tt>, so it might end
--   up in multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllToSocket :: MonadIO m => Socket -> Consumer Message m ()

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt></li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt></li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt></li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt></li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt></li>
--   </ul>
--   
--   Any other values is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference :: *

module Data.Conduit.Network

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> Producer m ByteString

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | The data passed to an <tt>Application</tt>.
data AppData :: *
appSource :: (HasReadWrite ad, MonadIO m) => ad -> Producer m ByteString
appSink :: (HasReadWrite ad, MonadIO m) => ad -> Consumer ByteString m ()
appSockAddr :: AppData -> SockAddr
appLocalAddr :: AppData -> Maybe SockAddr

-- | Settings for a TCP server. It takes a port to listen on, and an
--   optional hostname to bind to.
data ServerSettings :: *
serverSettings :: Int -> HostPreference -> ServerSettings

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runTCPServer :: ServerSettings -> (AppData -> IO ()) -> IO a
runTCPServerWithHandle :: ServerSettings -> ConnectionHandle -> IO a

-- | Fork a TCP Server
--   
--   Will fork the runGeneralTCPServer function but will only return from
--   this call when the server is bound to the port and accepting incoming
--   connections. Will return the thread id of the server
--   
--   Since 1.1.4
forkTCPServer :: MonadBaseControl IO m => ServerSettings -> (AppData -> m ()) -> m ThreadId

-- | Run a general TCP server
--   
--   Same as <a>runTCPServer</a>, except monad can be any instance of
--   <a>MonadBaseControl</a> <a>IO</a>.
--   
--   Note that any changes to the monadic state performed by individual
--   client handlers will be discarded. If you have mutable state you want
--   to share among multiple handlers, you need to use some kind of mutable
--   variables.
--   
--   Since 1.1.3
runGeneralTCPServer :: MonadBaseControl IO m => ServerSettings -> (AppData -> m ()) -> m a

-- | Settings for a TCP client, specifying how to connect to the server.
data ClientSettings :: *
clientSettings :: Int -> ByteString -> ClientSettings

-- | Run an <tt>Application</tt> by connecting to the specified server.
runTCPClient :: ClientSettings -> (AppData -> IO a) -> IO a

-- | Run a general TCP client
--   
--   Same as <a>runTCPClient</a>, except monad can be any instance of
--   <a>MonadBaseControl</a> <a>IO</a>.
--   
--   Since 1.1.3
runGeneralTCPClient :: MonadBaseControl IO m => ClientSettings -> (AppData -> m a) -> m a
getPort :: HasPort a => a -> Int
getHost :: ClientSettings -> ByteString
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
getNeedLocalAddr :: ServerSettings -> Bool
setPort :: HasPort a => Int -> a -> a
setHost :: ByteString -> ClientSettings -> ClientSettings
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a
setNeedLocalAddr :: Bool -> ServerSettings -> ServerSettings

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt></li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt></li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt></li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt></li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt></li>
--   </ul>
--   
--   Any other values is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference :: *

module Data.Conduit.Network.Unix

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> Producer m ByteString

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | The data passed to a Unix domain sockets <tt>Application</tt>.
data AppDataUnix :: *
appSource :: (HasReadWrite ad, MonadIO m) => ad -> Producer m ByteString
appSink :: (HasReadWrite ad, MonadIO m) => ad -> Consumer ByteString m ()

-- | Settings for a Unix domain sockets server.
data ServerSettingsUnix :: *
serverSettings :: FilePath -> ServerSettingsUnix

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runUnixServer :: ServerSettingsUnix -> (AppDataUnix -> IO ()) -> IO a

-- | Settings for a Unix domain sockets client.
data ClientSettingsUnix :: *
clientSettings :: FilePath -> ClientSettingsUnix

-- | Run an <tt>Application</tt> by connecting to the specified server.
runUnixClient :: ClientSettingsUnix -> (AppDataUnix -> IO a) -> IO a
getPath :: HasPath a => a -> FilePath
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
setPath :: HasPath a => FilePath -> a -> a
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a


-- | Use lazy I/O for consuming the contents of a source. Warning: All
--   normal warnings of lazy I/O apply. In particular, if you are using
--   this with a <tt>ResourceT</tt> transformer, you must force the list to
--   be evaluated before exiting the <tt>ResourceT</tt>.
module Data.Conduit.Lazy

-- | Use lazy I/O to consume all elements from a <tt>Source</tt>.
--   
--   This function relies on <a>monadActive</a> to determine if the
--   underlying monadic state has been closed.
--   
--   Since 0.3.0
lazyConsume :: (MonadBaseControl IO m, MonadActive m) => Source m a -> m [a]

-- | Determine if some monad is still active. This is intended to prevent
--   usage of a monadic state after it has been closed. This is necessary
--   for such cases as lazy I/O, where an unevaluated thunk may still refer
--   to a closed <tt>ResourceT</tt>.
--   
--   Since 0.3.0
class Monad m => MonadActive m
monadActive :: MonadActive m => m Bool
instance MonadActive m => MonadActive (ConduitM i o m)
instance MonadActive m => MonadActive (Pipe l i o u m)
instance (Monoid w, MonadActive m) => MonadActive (WriterT w m)
instance MonadActive m => MonadActive (StateT s m)
instance (Monoid w, MonadActive m) => MonadActive (RWST r w s m)
instance (Monoid w, MonadActive m) => MonadActive (RWST r w s m)
instance (Monoid w, MonadActive m) => MonadActive (WriterT w m)
instance MonadActive m => MonadActive (StateT s m)
instance MonadActive m => MonadActive (ReaderT r m)
instance (Error e, MonadActive m) => MonadActive (ErrorT e m)
instance MonadActive m => MonadActive (MaybeT m)
instance MonadActive m => MonadActive (ListT m)
instance MonadActive m => MonadActive (IdentityT m)
instance MonadActive (ST s)
instance MonadActive (ST s)
instance MonadActive IO
instance MonadActive Identity
instance (MonadIO m, MonadActive m) => MonadActive (ResourceT m)

module Data.Conduit.Filesystem

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
--   
--   Since 1.1.0
sourceDirectory :: MonadResource m => FilePath -> Producer m FilePath

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
--   
--   Since 1.1.0
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> Producer m FilePath


-- | Convert a stream of blaze-builder <tt>Builder</tt>s into a stream of
--   <tt>ByteString</tt>s.
--   
--   Works with both blaze-builder &lt; 0.4's <tt>Builder</tt>s and
--   <a>Builder</a>.
--   
--   Adapted from blaze-builder-enumerator, written by myself and Simon
--   Meier.
--   
--   Note that the functions here can work in any monad built on top of
--   <tt>IO</tt> or <tt>ST</tt>.
--   
--   Since 1.1.7.0
module Data.Conduit.ByteString.Builder

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => Conduit b m ByteString

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => IO Buffer -> Conduit b m ByteString

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => BufferAllocStrategy -> Conduit b m ByteString

-- | Since 0.0.2
builderToByteStringFlush :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => Conduit (Flush b) m (Flush ByteString)

-- | Since 0.0.2
builderToByteStringWithFlush :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => BufferAllocStrategy -> Conduit (Flush b) m (Flush ByteString)

-- | A buffer <tt>Buffer fpbuf p0 op ope</tt> describes a buffer with the
--   underlying byte array <tt>fpbuf..ope</tt>, the currently written slice
--   <tt>p0..op</tt> and the free space <tt>op..ope</tt>.
--   
--   Since 0.1.10.0
data Buffer :: *

-- | The size of the free space of the buffer.
--   
--   Since 0.1.10.0
freeSize :: Buffer -> Int

-- | The size of the written slice in the buffer.
--   
--   Since 0.1.10.0
sliceSize :: Buffer -> Int

-- | The size of the whole byte array underlying the buffer.
--   
--   Since 0.1.10.0
bufferSize :: Buffer -> Int

-- | <tt>allocBuffer size</tt> allocates a new buffer of size
--   <tt>size</tt>.
--   
--   Since 0.1.10.0
allocBuffer :: Int -> IO Buffer

-- | Resets the beginning of the next slice and the next free byte such
--   that the whole buffer can be filled again.
--   
--   Since 0.1.10.0
reuseBuffer :: Buffer -> Buffer

-- | Move the beginning of the slice to the next free byte such that the
--   remaining free space of the buffer can be filled further. This
--   operation is safe and can be used to fill the remaining part of the
--   buffer after a direct insertion of a bytestring or a flush.
--   
--   Since 0.1.10.0
nextSlice :: Int -> Buffer -> Maybe Buffer

-- | Convert the buffer to a bytestring. This operation is unsafe in the
--   sense that created bytestring shares the underlying byte array with
--   the buffer. Hence, depending on the later use of this buffer (e.g., if
--   it gets reset and filled again) referential transparency may be lost.
--   
--   Since 0.1.10.0
unsafeFreezeBuffer :: Buffer -> ByteString

-- | Convert a buffer to a non-empty bytestring. See
--   <a>unsafeFreezeBuffer</a> for the explanation of why this operation
--   may be unsafe.
--   
--   Since 0.1.10.0
unsafeFreezeNonEmptyBuffer :: Buffer -> Maybe ByteString

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
--   
--   Since 0.1.10.0
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO (IO Buffer))

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
--   
--   Since 0.1.10.0
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
--   
--   Since 0.1.10.0
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy


-- | Convert a stream of blaze-builder <tt>Builder</tt>s into a stream of
--   <tt>ByteString</tt>s.
--   
--   Adapted from blaze-builder-enumerator, written by myself and Simon
--   Meier.
--   
--   Note that the functions here can work in any monad built on top of
--   <tt>IO</tt> or <tt>ST</tt>.
--   
--   Since 1.1.7.0, the functions here call their counterparts in
--   <a>Data.Conduit.ByteString.Builder</a>, which work with both
--   <a>Builder</a> and blaze-builder 0.3's <a>Builder</a>.
module Data.Conduit.Blaze

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: (MonadBase base m, PrimMonad base) => Conduit Builder m ByteString

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: (MonadBase base m, PrimMonad base) => IO Buffer -> Conduit Builder m ByteString

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: (MonadBase base m, PrimMonad base) => BufferAllocStrategy -> Conduit Builder m ByteString

-- | Since 0.0.2
builderToByteStringFlush :: (MonadBase base m, PrimMonad base) => Conduit (Flush Builder) m (Flush ByteString)

-- | Since 0.0.2
builderToByteStringWithFlush :: (MonadBase base m, PrimMonad base) => BufferAllocStrategy -> Conduit (Flush Builder) m (Flush ByteString)

-- | A buffer <tt>Buffer fpbuf p0 op ope</tt> describes a buffer with the
--   underlying byte array <tt>fpbuf..ope</tt>, the currently written slice
--   <tt>p0..op</tt> and the free space <tt>op..ope</tt>.
--   
--   Since 0.1.10.0
data Buffer :: *

-- | The size of the free space of the buffer.
--   
--   Since 0.1.10.0
freeSize :: Buffer -> Int

-- | The size of the written slice in the buffer.
--   
--   Since 0.1.10.0
sliceSize :: Buffer -> Int

-- | The size of the whole byte array underlying the buffer.
--   
--   Since 0.1.10.0
bufferSize :: Buffer -> Int

-- | <tt>allocBuffer size</tt> allocates a new buffer of size
--   <tt>size</tt>.
--   
--   Since 0.1.10.0
allocBuffer :: Int -> IO Buffer

-- | Resets the beginning of the next slice and the next free byte such
--   that the whole buffer can be filled again.
--   
--   Since 0.1.10.0
reuseBuffer :: Buffer -> Buffer

-- | Move the beginning of the slice to the next free byte such that the
--   remaining free space of the buffer can be filled further. This
--   operation is safe and can be used to fill the remaining part of the
--   buffer after a direct insertion of a bytestring or a flush.
--   
--   Since 0.1.10.0
nextSlice :: Int -> Buffer -> Maybe Buffer

-- | Convert the buffer to a bytestring. This operation is unsafe in the
--   sense that created bytestring shares the underlying byte array with
--   the buffer. Hence, depending on the later use of this buffer (e.g., if
--   it gets reset and filled again) referential transparency may be lost.
--   
--   Since 0.1.10.0
unsafeFreezeBuffer :: Buffer -> ByteString

-- | Convert a buffer to a non-empty bytestring. See
--   <a>unsafeFreezeBuffer</a> for the explanation of why this operation
--   may be unsafe.
--   
--   Since 0.1.10.0
unsafeFreezeNonEmptyBuffer :: Buffer -> Maybe ByteString

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
--   
--   Since 0.1.10.0
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO (IO Buffer))

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
--   
--   Since 0.1.10.0
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
--   
--   Since 0.1.10.0
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy


-- | Functions for interacting with bytes.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Binary

-- | Stream the contents of a file as binary data.
--   
--   Since 0.3.0
sourceFile :: MonadResource m => FilePath -> Producer m ByteString

-- | Stream the contents of a <a>Handle</a> as binary data. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes, since it did not acquire the <tt>Handle</tt> in
--   the first place.
--   
--   Since 0.3.0
sourceHandle :: MonadIO m => Handle -> Producer m ByteString

-- | Same as <tt>sourceHandle</tt>, but instead of allocating a new buffer
--   for each incoming chunk of data, reuses the same buffer. Therefore,
--   the <tt>ByteString</tt>s yielded by this function are not
--   referentially transparent between two different <tt>yield</tt>s.
--   
--   This function will be slightly more efficient than
--   <tt>sourceHandle</tt> by avoiding allocations and reducing garbage
--   collections, but should only be used if you can guarantee that you do
--   not reuse a <tt>ByteString</tt> (or any slice thereof) between two
--   calls to <tt>await</tt>.
--   
--   Since 1.0.12
sourceHandleUnsafe :: MonadIO m => Handle -> Source m ByteString

-- | An alternative to <a>sourceHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in read
--   mode), so that it can open it only when needed and closed it as soon
--   as possible.
--   
--   Since 0.3.0
sourceIOHandle :: MonadResource m => IO Handle -> Producer m ByteString

-- | Stream the contents of a file as binary data, starting from a certain
--   offset and only consuming up to a certain number of bytes.
--   
--   Since 0.3.0
sourceFileRange :: MonadResource m => FilePath -> Maybe Integer -> Maybe Integer -> Producer m ByteString

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   
--   Since 1.0.8
sourceHandleRange :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> Producer m ByteString

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   This function consumes chunks as specified by the buffer size.
--   
--   Since 1.1.8
sourceHandleRangeWithBuffer :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> Int -> Producer m ByteString

-- | Stream all incoming data to the given file.
--   
--   Since 0.3.0
sinkFile :: MonadResource m => FilePath -> Consumer ByteString m ()

-- | Stream all incoming data to the given <a>Handle</a>. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes.
--   
--   Since 0.3.0
sinkHandle :: MonadIO m => Handle -> Consumer ByteString m ()

-- | An alternative to <a>sinkHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in write
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
--   
--   Since 0.3.0
sinkIOHandle :: MonadResource m => IO Handle -> Consumer ByteString m ()

-- | Stream the contents of the input to a file, and also send it along the
--   pipeline. Similar in concept to the Unix command <tt>tee</tt>.
--   
--   Since 0.3.0
conduitFile :: MonadResource m => FilePath -> Conduit ByteString m ByteString

-- | Stream the contents of the input to a <tt>Handle</tt>, and also send
--   it along the pipeline. Similar in concept to the Unix command
--   <tt>tee</tt>. Like <tt>sourceHandle</tt>, does not close the handle on
--   completion. Related to: <tt>conduitFile</tt>.
--   
--   Since 1.0.9
conduitHandle :: MonadIO m => Handle -> Conduit ByteString m ByteString

-- | Stream the chunks from a lazy bytestring.
--   
--   Since 0.5.0
sourceLbs :: Monad m => ByteString -> Producer m ByteString

-- | Return the next byte from the stream, if available.
--   
--   Since 0.3.0
head :: Monad m => Consumer ByteString m (Maybe Word8)

-- | Ignore all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
dropWhile :: Monad m => (Word8 -> Bool) -> Consumer ByteString m ()

-- | Take the given number of bytes, if available.
--   
--   Since 0.3.0
take :: Monad m => Int -> Consumer ByteString m ByteString

-- | Drop up to the given number of bytes.
--   
--   Since 0.5.0
drop :: Monad m => Int -> Consumer ByteString m ()

-- | Stream the input data into a temp file and count the number of bytes
--   present. When complete, return a new <tt>Source</tt> reading from the
--   temp file together with the length of the input in bytes.
--   
--   All resources will be cleaned up automatically.
--   
--   Since 1.0.5
sinkCacheLength :: (MonadResource m1, MonadResource m2) => Sink ByteString m1 (Word64, Source m2 ByteString)

-- | Consume a stream of input into a lazy bytestring. Note that no lazy
--   I/O is performed, but rather all content is read into memory strictly.
--   
--   Since 1.0.5
sinkLbs :: Monad m => Sink ByteString m ByteString

-- | Perform a computation on each <tt>Word8</tt> in a stream.
--   
--   Since 1.0.10
mapM_ :: Monad m => (Word8 -> m ()) -> Consumer ByteString m ()

-- | Ensure that only up to the given number of bytes are consume by the
--   inner sink. Note that this does <i>not</i> ensure that all of those
--   bytes are in fact consumed.
--   
--   Since 0.3.0
isolate :: Monad m => Int -> Conduit ByteString m ByteString

-- | Return all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
takeWhile :: Monad m => (Word8 -> Bool) -> Conduit ByteString m ByteString

-- | Split the input bytes into lines. In other words, split on the LF byte
--   (10), and strip it from the output.
--   
--   Since 0.3.0
lines :: Monad m => Conduit ByteString m ByteString


-- | A full tutorial for this module is available on FP School of Haskell:
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/data-conduit-process</a>.
--   
--   Note that this is a very thin layer around the
--   <tt>Data.Streaming.Process</tt> module. In particular, it:
--   
--   <ul>
--   <li>Provides orphan instances for conduit</li>
--   <li>Provides some useful helper functions</li>
--   </ul>
module Data.Conduit.Process

-- | Like <tt>sourceProcessWithConsumer</tt> but providing the command to
--   be run as a <tt>String</tt>.
--   
--   Since 1.1.2
sourceCmdWithConsumer :: MonadIO m => String -> Consumer ByteString m a -> m (ExitCode, a)

-- | Given a <tt>CreateProcess</tt>, run the process, with its output being
--   used as a <tt>Source</tt> to feed the provided <tt>Consumer</tt>. Once
--   the process has completed, return a tuple of the <tt>ExitCode</tt>
--   from the process and the output collected from the <tt>Consumer</tt>.
--   
--   Since 1.1.2
sourceProcessWithConsumer :: MonadIO m => CreateProcess -> Consumer ByteString m a -> m (ExitCode, a)
instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, o ~ ByteString) => OutputSink (ConduitM i o m r, n r')
instance (r ~ (), MonadIO m, o ~ ByteString) => OutputSink (ConduitM i o m r)
instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, i ~ ByteString) => InputSource (ConduitM i o m r, n r')
instance (r ~ (), MonadIO m, i ~ ByteString) => InputSource (ConduitM i o m r)


-- | Consume attoparsec parsers via conduit.
--   
--   This code was taken from attoparsec-enumerator and adapted for
--   conduits.
module Data.Conduit.Attoparsec

-- | Convert an Attoparsec <a>Parser</a> into a <a>Sink</a>. The parser
--   will be streamed bytes until it returns <a>Done</a> or <a>Fail</a>.
--   
--   If parsing fails, a <a>ParseError</a> will be thrown with
--   <a>monadThrow</a>.
--   
--   Since 0.5.0
sinkParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> Consumer a m b

-- | Same as <a>sinkParser</a>, but we return an <a>Either</a> type instead
--   of raising an exception.
--   
--   Since 1.1.5
sinkParserEither :: (AttoparsecInput a, Monad m) => Parser a b -> Consumer a m (Either ParseError b)

-- | Consume a stream of parsed tokens, returning both the token and the
--   position it appears at. This function will raise a <a>ParseError</a>
--   on bad input.
--   
--   Since 0.5.0
conduitParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> Conduit a m (PositionRange, b)

-- | Same as <a>conduitParser</a>, but we return an <a>Either</a> type
--   instead of raising an exception.
conduitParserEither :: (Monad m, AttoparsecInput a) => Parser a b -> Conduit a m (Either ParseError (PositionRange, b))

-- | The context and message from a <a>Fail</a> value.
data ParseError
ParseError :: [String] -> String -> Position -> ParseError
errorContexts :: ParseError -> [String]
errorMessage :: ParseError -> String
errorPosition :: ParseError -> Position
DivergentParser :: ParseError
data Position
Position :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Position
posLine :: Position -> {-# UNPACK #-} !Int
posCol :: Position -> {-# UNPACK #-} !Int
data PositionRange
PositionRange :: {-# UNPACK #-} !Position -> {-# UNPACK #-} !Position -> PositionRange
posRangeStart :: PositionRange -> {-# UNPACK #-} !Position
posRangeEnd :: PositionRange -> {-# UNPACK #-} !Position

-- | A class of types which may be consumed by an Attoparsec parser.
class AttoparsecInput a
instance Typeable ParseError
instance Eq Position
instance Ord Position
instance Show ParseError
instance Eq PositionRange
instance Ord PositionRange
instance AttoparsecInput Text
instance AttoparsecInput ByteString
instance Show PositionRange
instance Show Position
instance Exception ParseError
