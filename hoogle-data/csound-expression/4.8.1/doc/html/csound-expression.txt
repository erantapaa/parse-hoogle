-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | library to make electronic music
--   
@package csound-expression
@version 4.8.1


-- | Properties that specify the appearance of the GUI elements. The
--   specification is inspired by CSS. All properties are set in the
--   cascade manner. For example, if you want to change the font type for
--   all elements you should set this property only for the top-most GUI
--   element. If the property is set on the lower level it wins versus
--   property that is set on the higher level.
module Csound.Control.Gui.Props

-- | Sets the properties for a GUI element.
props :: [Prop] -> Gui -> Gui

-- | Sets the properties for a GUI element on all levels.
forceProps :: [Prop] -> Gui -> Gui

-- | Properties of the widgets.
data Prop :: *
SetLabel :: String -> Prop
SetMaterial :: Material -> Prop
SetBoxType :: BoxType -> Prop
SetColor1 :: Color -> Prop
SetColor2 :: Color -> Prop
SetTextColor :: Color -> Prop
SetFontSize :: Int -> Prop
SetFontType :: FontType -> Prop
SetEmphasis :: Emphasis -> Prop
SetSliderType :: SliderType -> Prop
SetTextType :: TextType -> Prop
SetButtonType :: ButtonType -> Prop
SetOrient :: Orient -> Prop
SetKnobType :: KnobType -> Prop
SetLabelType :: LabelType -> Prop
data BorderType :: *
NoBorder :: BorderType
DownBoxBorder :: BorderType
UpBoxBorder :: BorderType
EngravedBorder :: BorderType
EmbossedBorder :: BorderType
BlackLine :: BorderType
ThinDown :: BorderType
ThinUp :: BorderType

-- | The Csound colours.
type Color = Colour Double

-- | A rectangle.
data Rect :: *
Rect :: Int -> Int -> Int -> Int -> Rect
px :: Rect -> Int
py :: Rect -> Int
width :: Rect -> Int
height :: Rect -> Int
data FontType :: *
Helvetica :: FontType
Courier :: FontType
Times :: FontType
Symbol :: FontType
Screen :: FontType
Dingbats :: FontType
data Emphasis :: *
NoEmphasis :: Emphasis
Italic :: Emphasis
Bold :: Emphasis
BoldItalic :: Emphasis

-- | The type of the material of the element. It affects sliders and
--   buttons.
data Material :: *
NoPlastic :: Material
Plastic :: Material

-- | The orientation of the widget (slider, roller). This property is never
--   needs to be set in practice. If this property is not set then default
--   orientation is calculated from the bounding box of the widget. If the
--   width is greater than the height then we need to use a horizontal
--   widget otherwise it should be a vertical one.
data Orient :: *
Hor :: Orient
Ver :: Orient
setBorder :: BorderType -> Gui -> Gui
setLabel :: String -> Gui -> Gui
setMaterial :: Material -> Gui -> Gui
setColor1 :: Color -> Gui -> Gui
setColor2 :: Color -> Gui -> Gui
setColors :: Color -> Color -> Gui -> Gui
setTextColor :: Color -> Gui -> Gui
setFontSize :: Int -> Gui -> Gui
setFontType :: FontType -> Gui -> Gui
setEmphasis :: Emphasis -> Gui -> Gui
setOrient :: Orient -> Gui -> Gui


-- | The functions from this module specify the geometry of the
--   GUI-elements. They tell where to render the elements.
--   
--   Every element is rectangular. To know where to place the element is to
--   know the parameters of the bounding rectangle. All rectangles are
--   relative and automatically aligned.
--   
--   We have two functions for grouping. They construct horizontal and
--   vertical groups of the elements. Within the group we can change the
--   relative size of the rectangles (by scaling one side of the
--   rectangle). In place of rectangle we can put an empty space.
module Csound.Control.Gui.Layout

-- | Horizontal groupping of the elements. All elements are placed in the
--   stright horizontal line and aligned by Y-coordinate and height.
hor :: [Gui] -> Gui

-- | Vertical groupping of the elements. All elements are placed in the
--   stright vertical line and aligned by X-coordinate and width.
ver :: [Gui] -> Gui

-- | An empty space.
space :: Gui

-- | Scales an element within the group. It depends on the type of the
--   alignment (horizontal or vertical) which side of the bounding box is
--   scaled. If it's a horizontal group then the width is scaled and height
--   is scaled otherwise.
--   
--   Every element in the group has a scaling factor. By default it equals
--   to one. During rendering all scaling factors are summed and divided on
--   the sum of all factors. So that factors become weights or proportions.
--   This process is called normalization. Scaling one element affects not
--   only this element but all other elements in the group!
--   
--   An example:
--   
--   One element is twice as large as the other two:
--   
--   <pre>
--   hor [a, b, sca 2 c]
--   </pre>
--   
--   Why is it so? Let's look at the hidden scaling factors:
--   
--   <pre>
--   hor [sca 1 a, sca 1 b, sca 2 c]
--   </pre>
--   
--   During rendering we scale all the scaling fators so that total sum
--   equals to one:
--   
--   <pre>
--   hor [sca 0.25 a, sca 0.25 b, sca 0.5 c]
--   </pre>
sca :: Double -> Gui -> Gui

-- | Weighted horizontal grouping. It takes a list of scaling factors and
--   elements.
horSca :: [(Double, Gui)] -> Gui

-- | Weighted vertical grouping. It takes a list of scaling factors and
--   elements.
verSca :: [(Double, Gui)] -> Gui

-- | Sets the padding of the element. How much empty space to reserve
--   outside the element.
padding :: Int -> Gui -> Gui

-- | Sets the margin of the element. How much empty space to reserve
--   between the elements within the group. It affects only compound
--   elements.
margin :: Int -> Gui -> Gui


-- | Named channels.
--   
--   With named channels we can read and write values to the variables with
--   dynamic names. We can specify the variable with string (Str).
--   
--   Csound has an C api wich is ported to many languages. With named
--   channels we can interact with csound that runns a program. We can read
--   and write to named channels from another program.
module Csound.Control.Channel

-- | Reads a value of type double.
chnGetD :: Str -> SE D

-- | Reads an audio signal.
chnGetSig :: Str -> SE Sig

-- | Reads a control signal. The control signals are updated at the lower
--   rate.
chnGetCtrl :: Str -> SE Sig

-- | Reads a string.
chnGetStr :: Str -> SE Str

-- | Writes a value of type double.
chnSetD :: D -> Str -> SE ()

-- | Writes an audio signal.
chnSetSig :: Sig -> Str -> SE ()

-- | Writes a control signal. The control signals are updated at the lower
--   rate.
chnSetCtrl :: Sig -> Str -> SE ()

-- | Writes a string.
chnSetStr :: Str -> Str -> SE ()


-- | Open Sound Control.
module Csound.Control.Osc

-- | Initializes host client. The process starts to run in the background.
initOsc :: OscPort -> SE OscRef

-- | Listens for the OSC-messages. The first argument is OSC-reference. We
--   can create it with the function <tt>oscInit</tt>. The next two
--   arguments are strings. The former specifies the path-like address to
--   listen the messages. It can be:
--   
--   <pre>
--   /foo/bar/baz
--   </pre>
--   
--   The latter specifies the type of expected arguments. The string can
--   contain the characters "bcdfilmst" which stand for Boolean, character,
--   double, float, 32-bit integer, 64-bit integer, MIDI, string and
--   timestamp.
--   
--   The result is an event of messages. We can run a callback on it with
--   standard function <tt>runEvt</tt>:
--   
--   <pre>
--   runEvt :: Evt a -&gt; (a -&gt; SE ()) -&gt; SE ()
--   </pre>
listenOsc :: Tuple a => OscRef -> OscAddress -> OscType -> Evt a

-- | Sends OSC-messages. It takes in a name of the host computer (empty
--   string is alocal machine), port on which the target machine is
--   listening, OSC-addres and type. The last argument produces the values
--   for OSC-messages.
sendOsc :: Tuple a => OscHost -> OscPort -> OscAddress -> OscType -> Evt a -> SE ()

module Csound.Control.SE

-- | The Csound's <tt>IO</tt>-monad. All values that produce side effects
--   are wrapped in the <tt>SE</tt>-monad.
data SE a :: * -> *

-- | It describes a reference to mutable values.
data SERef a :: * -> *
writeSERef :: Tuple a => SERef a -> a -> SE ()
readSERef :: Tuple a => SERef a -> SE a

-- | Modifies the SERef value with given function.
modifySERef :: Tuple a => SERef a -> (a -> a) -> SE ()

-- | Adds the given signal to the value that is contained in the reference.
mixSERef :: (Num a, Tuple a) => SERef a -> a -> SE ()

-- | Allocates a new local (it is visible within the instrument) mutable
--   value and initializes it with value. A reference can contain a tuple
--   of variables.
newSERef :: Tuple a => a -> SE (SERef a)

-- | An alias for the function <tt>newSERef</tt>. It returns not the
--   reference to mutable value but a pair of reader and writer functions.
sensorsSE :: Tuple a => a -> SE (SE a, a -> SE ())

-- | Allocates a new global mutable value and initializes it with value. A
--   reference can contain a tuple of variables.
newGlobalSERef :: Tuple a => a -> SE (SERef a)

-- | An alias for the function <tt>newSERef</tt>. It returns not the
--   reference to mutable value but a pair of reader and writer functions.
globalSensorsSE :: Tuple a => a -> SE (SE a, a -> SE ())

module Csound.Options

-- | Csound options. The default values are
--   
--   <pre>
--   flags      = def     -- the only flag set by default is "no-displays" 
--                        -- to supress the display of the tables
--   sampleRate = 44100
--   blockSize  = 64
--   gain       = 0.5
--   tabFi      = fineFi 13 [(idLins, 11), (idExps, 11), (idConsts, 9), (idSplines, 11), (idStartEnds, 12)] }
--   </pre>
data Options :: *
Options :: Flags -> Maybe Int -> Maybe Int -> Maybe Double -> Maybe TabFi -> Options

-- | Csound command line flags
csdFlags :: Options -> Flags

-- | The sample rate
csdSampleRate :: Options -> Maybe Int

-- | The number of audio samples in one control step
csdBlockSize :: Options -> Maybe Int

-- | A gain of the final output
csdGain :: Options -> Maybe Double

-- | Default fidelity of the arrays
csdTabFi :: Options -> Maybe TabFi

-- | Sets the global duration of the file or output signal to the given
--   value. It should be used only once! The proper place is in the
--   top-most expression before sending to <tt>dac</tt> or
--   <tt>writeWav</tt>.
setDur :: Sigs a => D -> a -> a

-- | Sets sample rate and block size
--   
--   <pre>
--   setRates sampleRate blockSize
--   </pre>
setRates :: Int -> Int -> Options

-- | Sets hardware and software buffers.
--   
--   <pre>
--   setBufs hardwareBuf ioBuf
--   </pre>
setBufs :: Int -> Int -> Options
setGain :: Double -> Options
setJack :: String -> Options
setOutput :: String -> Options
setInput :: String -> Options
setDac :: Options
setAdc :: Options
setDacBy :: String -> Options
setAdcBy :: String -> Options
setThru :: Options

-- | Sets the output to nosound.
setSilent :: Options

-- | Sets midi device
setMidiDevice :: String -> Options

-- | Sets midi device to all.
setMa :: Options
data Flags :: *
Flags :: AudioFileOutput -> IdTags -> Maybe Rtaudio -> Maybe PulseAudio -> MidiIO -> MidiRT -> Maybe Rtmidi -> Displays -> Config -> Maybe String -> Flags
audioFileOutput :: Flags -> AudioFileOutput
idTags :: Flags -> IdTags
rtaudio :: Flags -> Maybe Rtaudio
pulseAudio :: Flags -> Maybe PulseAudio
midiIO :: Flags -> MidiIO
midiRT :: Flags -> MidiRT
rtmidi :: Flags -> Maybe Rtmidi
displays :: Flags -> Displays
config :: Flags -> Config
flagsVerbatim :: Flags -> Maybe String
data AudioFileOutput :: *
AudioFileOutput :: Maybe FormatSamples -> Maybe FormatType -> Maybe String -> Maybe String -> Bool -> Bool -> Maybe Dither -> AudioFileOutput
formatSamples :: AudioFileOutput -> Maybe FormatSamples
formatType :: AudioFileOutput -> Maybe FormatType
output :: AudioFileOutput -> Maybe String
input :: AudioFileOutput -> Maybe String
nosound :: AudioFileOutput -> Bool
nopeaks :: AudioFileOutput -> Bool
dither :: AudioFileOutput -> Maybe Dither
data FormatHeader :: *
NoHeader :: FormatHeader
RewriteHeader :: FormatHeader
data FormatSamples :: *
Bit24 :: FormatSamples
Alaw :: FormatSamples
Uchar :: FormatSamples
Schar :: FormatSamples
FloatSamples :: FormatSamples
Ulaw :: FormatSamples
Short :: FormatSamples
Long :: FormatSamples
data FormatType :: *
Aiff :: FormatType
Au :: FormatType
Avr :: FormatType
Caf :: FormatType
Flac :: FormatType
Htk :: FormatType
Ircam :: FormatType
Mat4 :: FormatType
Mat5 :: FormatType
Nis :: FormatType
Paf :: FormatType
Pvf :: FormatType
Raw :: FormatType
Sd2 :: FormatType
Sds :: FormatType
Svx :: FormatType
Voc :: FormatType
W64 :: FormatType
Wav :: FormatType
Wavex :: FormatType
Xi :: FormatType
data Dither :: *
Triangular :: Dither
Uniform :: Dither
data IdTags :: *
IdTags :: Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> IdTags
idArtist :: IdTags -> Maybe String
idComment :: IdTags -> Maybe String
idCopyright :: IdTags -> Maybe String
idDate :: IdTags -> Maybe String
idSoftware :: IdTags -> Maybe String
idTitle :: IdTags -> Maybe String
data Rtaudio :: *
PortAudio :: Rtaudio
Alsa :: Rtaudio
Jack :: String -> String -> String -> Rtaudio
jackClient :: Rtaudio -> String
jackInport :: Rtaudio -> String
jackOutport :: Rtaudio -> String
Mme :: Rtaudio
CoreAudio :: Rtaudio
NoRtaudio :: Rtaudio
data PulseAudio :: *
PulseAudio :: String -> String -> String -> PulseAudio
paServer :: PulseAudio -> String
paOutput :: PulseAudio -> String
paInput :: PulseAudio -> String
data MidiIO :: *
MidiIO :: Maybe String -> Maybe String -> Maybe String -> Bool -> Bool -> MidiIO
midiFile :: MidiIO -> Maybe String
midiOutFile :: MidiIO -> Maybe String
muteTracks :: MidiIO -> Maybe String
rawControllerMode :: MidiIO -> Bool
terminateOnMidi :: MidiIO -> Bool
data MidiRT :: *
MidiRT :: Maybe String -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe String -> MidiRT
midiDevice :: MidiRT -> Maybe String
midiKey :: MidiRT -> Maybe Int
midiKeyCps :: MidiRT -> Maybe Int
midiKeyOct :: MidiRT -> Maybe Int
midiKeyPch :: MidiRT -> Maybe Int
midiVelocity :: MidiRT -> Maybe Int
midiVelocityAmp :: MidiRT -> Maybe Int
midiOutDevice :: MidiRT -> Maybe String
data Rtmidi :: *
PortMidi :: Rtmidi
AlsaMidi :: Rtmidi
CoreMidi :: Rtmidi
MmeMidi :: Rtmidi
WinmmeMidi :: Rtmidi
VirtualMidi :: Rtmidi
NoRtmidi :: Rtmidi
data Displays :: *
Displays :: Maybe Int -> Maybe DisplayMode -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Bool -> Maybe Int -> Displays
csdLineNums :: Displays -> Maybe Int
displayMode :: Displays -> Maybe DisplayMode
displayHeartbeat :: Displays -> Maybe Int
messageLevel :: Displays -> Maybe Int
mAmps :: Displays -> Maybe Int
mRange :: Displays -> Maybe Int
mWarnings :: Displays -> Maybe Int
mDb :: Displays -> Maybe Int
mColours :: Displays -> Maybe Int
mBenchmarks :: Displays -> Maybe Int
msgColor :: Displays -> Bool
displayVerbose :: Displays -> Bool
listOpcodes :: Displays -> Maybe Int
data DisplayMode :: *
NoDisplay :: DisplayMode
PostScriptDisplay :: DisplayMode
AsciiDisplay :: DisplayMode
data Config :: *
Config :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe String -> Maybe (String, String) -> Maybe (String, String) -> Bool -> Maybe Int -> Maybe (Int, String) -> Maybe Double -> Maybe Int -> Config
hwBuf :: Config -> Maybe Int
ioBuf :: Config -> Maybe Int
newKr :: Config -> Maybe Int
newSr :: Config -> Maybe Int
scoreIn :: Config -> Maybe String
omacro :: Config -> Maybe (String, String)
smacro :: Config -> Maybe (String, String)
setSched :: Config -> Bool
schedNum :: Config -> Maybe Int
strsetN :: Config -> Maybe (Int, String)
skipSeconds :: Config -> Maybe Double
setTempo :: Config -> Maybe Int


-- | The Csound types.
--   
--   There are several primitive types:
--   
--   <ul>
--   <li><tt>Sig</tt> - signals</li>
--   <li><tt>D</tt> - numbers</li>
--   <li><tt>Str</tt> - strings</li>
--   <li><tt>Tab</tt> - 1-dimensional arrays</li>
--   <li><tt>Spec</tt> and <tt>Wspec</tt> - sound spectrums</li>
--   </ul>
--   
--   A signal is a stream of numbers. Signals carry sound or time varied
--   control values. Numbers are constants. 1-dimensional arrays contain
--   some useful data which is calculated at the initial run of the
--   program.
--   
--   There is only one compound type. It's a tuple of Csound values. The
--   empty tuple is signified with special type called <tt>Unit</tt>.
module Csound.Types

-- | Signals
data Sig :: *

-- | Constant numbers
data D :: *

-- | Tables (or arrays)
data Tab :: *

-- | Strings
data Str :: *

-- | Spectrum. It's <tt>fsig</tt> in the Csound.
data Spec :: *

-- | Another type for spectrum. It's <tt>wsig</tt> in the Csound.
data Wspec :: *

-- | A signal of booleans.
data BoolSig :: *

-- | A constant boolean value.
data BoolD :: *

-- | Contains all Csound values.
class Val a
fromGE :: Val a => GE E -> a
toGE :: Val a => a -> GE E
fromE :: Val a => E -> a
class (IsPrim a, RealFrac (PrimOf a), Val a) => SigOrD a
type Sig2 = (Sig, Sig)
type Sig3 = (Sig, Sig, Sig)
type Sig4 = (Sig, Sig, Sig, Sig)
type Sig5 = (Sig, Sig, Sig, Sig, Sig)
type Sig6 = (Sig, Sig, Sig, Sig, Sig, Sig)
type Sig8 = (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig)

-- | Constructs a number.
double :: Double -> D

-- | Constructs an integer.
int :: Int -> D

-- | Constructs a string.
text :: String -> Str

-- | Querries a total duration of the note. It's equivallent to Csound's
--   <tt>p3</tt> field.
idur :: D
getSampleRate :: D
getControlRate :: D
getBlockSize :: D

-- | Sets a rate of the signal to audio rate.
ar :: Sig -> Sig

-- | Sets a rate of the signal to control rate.
kr :: Sig -> Sig

-- | Converts a signal to the number (initial value of the signal).
ir :: Sig -> D

-- | Makes a constant signal from the number.
sig :: D -> Sig

-- | Appends initialisation arguments. It's up to user to supply arguments
--   with the right types. For example:
--   
--   <pre>
--   oscil 0.5 440 sinWave `withInits` (0.5 :: D)
--   </pre>
withInits :: (Tuple a, Tuple b) => a -> b -> a

-- | A special case of <tt>withInits</tt>. Here all inits are numbers.
withDs :: Tuple a => a -> [D] -> a

-- | A special case of <tt>withInits</tt>. Here all inits are signals.
withSigs :: Tuple a => a -> [Sig] -> a

-- | A special case of <tt>withInits</tt>. Here all inits are arrays.
withTabs :: Tuple a => a -> [Tab] -> a

-- | Appends an init value which is a number.
withD :: Tuple a => a -> D -> a

-- | Appends an init value which is a signal.
withSig :: Tuple a => a -> Sig -> a

-- | Appends an init value which is a table.
withTab :: Tuple a => a -> Tab -> a

-- | Applies a seed to the random value. It's equivalent to the
--   <tt>withD</tt> but it has a special meaning of canceling the side
--   effect. When random opcode is provided with seed value it's no longer
--   contains a side effect so we don't need to restrict it.
withSeed :: SE Sig -> D -> Sig
quot' :: SigOrD a => a -> a -> a
rem' :: SigOrD a => a -> a -> a
div' :: SigOrD a => a -> a -> a
mod' :: SigOrD a => a -> a -> a
ceil' :: SigOrD a => a -> a
floor' :: SigOrD a => a -> a
round' :: SigOrD a => a -> a
int' :: SigOrD a => a -> a
frac' :: SigOrD a => a -> a

-- | Creates a constant boolean signal.
boolSig :: BoolD -> BoolSig

-- | Invokes the given procedure if the boolean signal is true.
when1 :: BoolSig -> SE () -> SE ()

-- | The chain of <tt>when1</tt>s. Tests all the conditions in sequence if
--   everything is false it invokes the procedure given in the second
--   argument.
whens :: [(BoolSig, SE ())] -> SE () -> SE ()
whileDo :: BoolSig -> SE () -> SE ()
untilDo :: BoolSig -> SE () -> SE ()
ar1 :: Sig -> Sig
ar2 :: (Sig, Sig) -> (Sig, Sig)
ar4 :: (Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig)
ar6 :: (Sig, Sig, Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig, Sig, Sig)
ar8 :: (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig)

-- | A tuple of Csound values.
class Tuple a
tupleMethods :: Tuple a => TupleMethods a

-- | Defines instance of type class <a>Tuple</a> for a new type in terms of
--   an already defined one.
makeTupleMethods :: Tuple a => (a -> b) -> (b -> a) -> TupleMethods b

-- | Csound's empty tuple.
data Unit :: *

-- | Constructs Csound's empty tuple.
unit :: Unit

-- | Gets an control/audio-rate value from the list by index.
atTuple :: Tuple a => [a] -> Sig -> a

-- | <tt>ifB</tt> for tuples of csound values.
ifTuple :: Tuple a => BoolSig -> a -> a -> a

-- | <tt>guardedB</tt> for tuples of csound values.
guardedTuple :: Tuple b => [(BoolSig, b)] -> b -> b

-- | <tt>caseB</tt> for tuples of csound values.
caseTuple :: Tuple b => a -> [(a -> BoolSig, b)] -> b -> b
class Tuple a => Arg a

-- | Gets an init-rate value from the list by index.
atArg :: (Tuple a, Arg a) => [a] -> D -> a

-- | <tt>ifB</tt> for constants.
ifArg :: (Arg a, Tuple a) => BoolD -> a -> a -> a

-- | <tt>guardedB</tt> for constants.
guardedArg :: (Tuple b, Arg b) => [(BoolD, b)] -> b -> b

-- | <tt>caseB</tt> for constants.
caseArg :: (Tuple b, Arg b) => a -> [(a -> BoolD, b)] -> b -> b

-- | The tuples of signals.
class (Tuple a, Num a) => Sigs a

module Csound.SigSpace

-- | A class for easy way to process the outputs of the instruments.
class SigSpace a
mapSig :: SigSpace a => (Sig -> Sig) -> a -> a

-- | A class for easy way to process the outputs of the instruments.
class SigSpace a => BindSig a
bindSig :: BindSig a => (Sig -> SE Sig) -> a -> SE a

-- | Scaling the sound.
mul :: SigSpace a => Sig -> a -> a

-- | Rescaling of the bipolar signal (-1, 1) -&gt; (a, b)
--   
--   <pre>
--   on a b biSig
--   </pre>
on :: SigSpace a => Sig -> Sig -> a -> a

-- | Rescaling of the unipolar signal (0, 1) -&gt; (a, b)
--   
--   <pre>
--   on a b uniSig
--   </pre>
uon :: SigSpace a => Sig -> Sig -> a -> a
class SigSpace b => At a b c where type family AtOut a b c :: *
at :: At a b c => (a -> b) -> c -> AtOut a b c

-- | It applies an effect and mixes the processed signal with original one.
--   The first argument is for proportion of dry<i>wet
--   (original</i>processed). It's like <tt>at</tt> but it allows to
--   balance processed signal with original one.
mixAt :: (At a b c, c ~ AtOut a b c, SigSpace c, Num c) => Sig -> (a -> b) -> c -> c

-- | It applies an effect and balances the processed signal by original
--   one.
bat :: At Sig a b => (Sig -> a) -> b -> AtOut Sig a b

-- | Crossfade.
--   
--   <pre>
--   cfd coeff sig1 sig2
--   </pre>
--   
--   If coeff equals 0 then we get the first signal and if it equals 1 we
--   get the second signal.
cfd :: (Num a, SigSpace a) => Sig -> a -> a -> a

-- | Bilinear interpolation for four signals. The signals are placed in the
--   corners of the unit square. The first two signals are the xy
--   coordinates in the square.
--   
--   <pre>
--   cfd4 x y a b c d
--   </pre>
--   
--   <ul>
--   <li>(0, 0) is for a</li>
--   <li>(1, 0) is for b</li>
--   <li>(1, 1) is for c</li>
--   <li>(0, 1) is for d</li>
--   </ul>
cfd4 :: (Num a, SigSpace a) => Sig -> Sig -> a -> a -> a -> a -> a

-- | Generic crossfade for n coefficients and n+1 signals.
--   
--   <pre>
--   cfds coeffs sigs
--   </pre>
cfds :: (Num a, SigSpace a) => [Sig] -> [a] -> a

-- | Spectral crossfade.
cfdSpec :: Sig -> Spec -> Spec -> Spec

-- | Spectral bilinear crossfade (see <tt>cfd4</tt>).
cfdSpec4 :: Sig -> Sig -> Spec -> Spec -> Spec -> Spec -> Spec

-- | Generic spectral crossfade.
cfdsSpec :: [Sig] -> [Spec] -> Spec

-- | Weighted sum.
wsum :: (Num a, SigSpace a) => [(Sig, a)] -> a
instance At Sig2 (SE Sig2) (SE Sig2)
instance At Sig2 (SE Sig2) (SE Sig)
instance At Sig2 (SE Sig2) Sig2
instance At Sig2 (SE Sig2) Sig
instance At Sig2 Sig2 (SE Sig2)
instance At Sig2 Sig2 (SE Sig)
instance At Sig2 Sig2 Sig2
instance At Sig2 Sig2 Sig
instance At Sig Sig2 (SE Sig2)
instance At Sig Sig2 Sig2
instance At Sig Sig2 (SE Sig)
instance At Sig Sig2 Sig
instance At Sig (SE Sig) (SE Sig4)
instance At Sig (SE Sig) (SE Sig3)
instance At Sig (SE Sig) (SE Sig2)
instance At Sig (SE Sig) (SE Sig)
instance At Sig (SE Sig) Sig4
instance At Sig (SE Sig) Sig3
instance At Sig (SE Sig) Sig2
instance At Sig (SE Sig) Sig
instance SigSpace a => At Sig Sig a
instance Fractional (a -> (Sig, Sig, Sig, Sig))
instance Fractional (a -> (Sig, Sig, Sig))
instance Fractional (a -> (Sig, Sig))
instance Fractional (a -> Sig)
instance Fractional (a -> SE (Sig, Sig, Sig, Sig))
instance Fractional (a -> SE (Sig, Sig, Sig))
instance Fractional (a -> SE (Sig, Sig))
instance Fractional (a -> SE Sig)
instance Fractional (SE (Sig, Sig, Sig, Sig))
instance Fractional (SE (Sig, Sig, Sig))
instance Fractional (SE (Sig, Sig))
instance Fractional (SE Sig)
instance Fractional (Sig, Sig, Sig, Sig)
instance Fractional (Sig, Sig, Sig)
instance Fractional (Sig, Sig)
instance Num (a -> SE (Sig, Sig, Sig, Sig))
instance Num (a -> SE (Sig, Sig, Sig))
instance Num (a -> SE (Sig, Sig))
instance Num (a -> SE Sig)
instance Num (a -> (Sig, Sig, Sig, Sig))
instance Num (a -> (Sig, Sig, Sig))
instance Num (a -> (Sig, Sig))
instance Num (a -> Sig)
instance Num (SE (Sig, Sig, Sig, Sig))
instance Num (SE (Sig, Sig, Sig))
instance Num (SE (Sig, Sig))
instance Num (SE Sig)
instance BindSig (SE (Sig, Sig, Sig, Sig))
instance SigSpace (SE (Sig, Sig, Sig, Sig))
instance BindSig (SE (Sig, Sig, Sig))
instance SigSpace (SE (Sig, Sig, Sig))
instance BindSig (SE (Sig, Sig))
instance SigSpace (SE (Sig, Sig))
instance BindSig (SE Sig)
instance SigSpace (SE Sig)
instance BindSig (Sig, Sig, Sig, Sig)
instance SigSpace (Sig, Sig, Sig, Sig)
instance BindSig (Sig, Sig, Sig)
instance SigSpace (Sig, Sig, Sig)
instance BindSig (Sig, Sig)
instance SigSpace (Sig, Sig)
instance BindSig Sig
instance SigSpace Sig


-- | Filters
module Csound.Air.Filter

-- | First order low pass filter (tone in Csound, 6 dB)
--   
--   <pre>
--   lp1 centerFreq asig
--   </pre>
lp1 :: Sig -> Sig -> Sig

-- | First order high pass filter (atone in Csound, 6 dB)
--   
--   <pre>
--   hp1 centerFreq asig
--   </pre>
hp1 :: Sig -> Sig -> Sig

-- | Low-pass filter.
--   
--   <pre>
--   lp cutoff resonance sig
--   </pre>
lp :: Sig -> Sig -> Sig -> Sig

-- | High-pass filter.
--   
--   <pre>
--   hp cutoff resonance sig
--   </pre>
hp :: Sig -> Sig -> Sig -> Sig

-- | Band-pass filter.
--   
--   <pre>
--   bp cutoff resonance sig
--   </pre>
bp :: Sig -> Sig -> Sig -> Sig

-- | Band-reject filter.
--   
--   <pre>
--   br cutoff resonance sig
--   </pre>
br :: Sig -> Sig -> Sig -> Sig

-- | All-pass filter.
--   
--   <pre>
--   alp cutoff resonance sig
--   </pre>
alp :: Sig -> Sig -> Sig -> Sig

-- | Resonance band pass filter (yet another implementation, it's reson in
--   Csound)
--   
--   <pre>
--   bp2 centerFreq q asig
--   </pre>
bp2 :: Sig -> Sig -> Sig -> Sig

-- | Resonance band reject filter (yet another implementation, it's areson
--   in Csound)
--   
--   <pre>
--   br2 centerFreq q asig
--   </pre>
br2 :: Sig -> Sig -> Sig -> Sig

-- | Low-pass filter.
--   
--   <pre>
--   blp cutoff sig
--   </pre>
blp :: Sig -> Sig -> Sig

-- | High-pass filter.
--   
--   <pre>
--   bhp cutoff sig
--   </pre>
bhp :: Sig -> Sig -> Sig

-- | Band-pass filter.
--   
--   <pre>
--   bbp cutoff bandwidth sig
--   </pre>
bbp :: Sig -> Sig -> Sig -> Sig

-- | Band-regect filter.
--   
--   <pre>
--   bbr cutoff bandwidth sig
--   </pre>
bbr :: Sig -> Sig -> Sig -> Sig

-- | Resonant filter.
--   
--   <pre>
--   f centerFreq q asig
--   </pre>
type ResonFilter = Sig -> Sig -> Sig -> Sig

-- | Filter without a resonance.
--   
--   <pre>
--   f centerFreq q asig
--   </pre>
type FlatFilter = Sig -> Sig -> Sig

-- | Applies a filter n-times. The n is given in the first rgument.
filt :: Int -> ResonFilter -> ResonFilter

-- | Applies a flat filter (without resonance) n-times. The n is given in
--   the first rgument.
flatFilt :: Int -> FlatFilter -> FlatFilter

-- | Moog's low-pass filter.
--   
--   <pre>
--   mlp centerFrequency qResonance signal
--   </pre>
mlp :: Sig -> Sig -> Sig -> Sig

-- | Another implementation of moog low pass filter (it's moogvcf in
--   Csound). The arguments have are just like in the <tt>mlp</tt> filter.
mlp2 :: Sig -> Sig -> Sig -> Sig

-- | Mooglowpass filter with 18 dB.
mlp3 :: Sig -> Sig -> Sig -> Sig

-- | Low pass filter 18 dB with built in distortion module.
--   
--   <pre>
--   lp18 distortion centerFreq resonance asig
--   </pre>
--   
--   <ul>
--   <li>distortion's range is 0 to 1</li>
--   <li>resonance's range is 0 to 1</li>
--   </ul>
lp18 :: Sig -> Sig -> Sig -> Sig -> Sig

-- | Formant filter.
--   
--   <pre>
--   formant bandPassFilter formants asig
--   </pre>
--   
--   It expects a band pass filter, a list of formants and processed
--   signal. The signal is processed with each filter the result is a sum
--   of all proceessed signals. Formant filters are used to mimic the
--   vocalization of the sound.
formant :: ResonFilter -> [(Sig, Sig)] -> Sig -> Sig

-- | Formant filter that sings an A.
singA :: Sig -> Sig

-- | Formant filter that sings an O.
singO :: Sig -> Sig

-- | Formant filter that sings an E.
singE :: Sig -> Sig

-- | Formant filter that sings an U.
singU :: Sig -> Sig

-- | Formant filter that sings an O.
singO2 :: Sig -> Sig

-- | Produces smooth transitions between values in the signals. The first
--   value defines a duration in seconds for a transition from one value to
--   another in piecewise constant signals.
smooth :: Sig -> Sig -> Sig

-- | Makes slides between values in the signals. The first value defines a
--   duration in seconds for a transition from one value to another in
--   piecewise constant signals.
slide :: Sig -> Sig -> Sig


-- | Sound fonts. Playing Sf2 samples.
--   
--   There are three groups of functions. Functions that are defined for
--   midi messages, midi notes (it's a pair of integers from 0-127) and the
--   frequencies (in Hz). Each group contains four functions. They are
--   destinguished by suffixes. The function with no suffix play a sf2 file
--   with linear interpolation and take stereo output. The function with
--   suffix <tt>3</tt> read samples with cubic interpolation. The functions
--   with suffix <tt>m</tt> produce mono outputs. The loopers play samples
--   in loops.
module Csound.Control.Sf

-- | The sf2 sound font preset. It is defined with file name, bank and
--   program integers.
data Sf :: *
Sf :: String -> Int -> Int -> Sf

-- | Creates a midi instrument from sf2 sound font. Midi listens on all
--   channels. It's useful to quickly test a sound font. The second
--   argument is a sustain in seconds. How long it takes for the sound to
--   decay.
sf2 :: Sf -> D -> SE (Sig, Sig)

-- | Creates a midi instrument from sf2 sound font file. The second
--   argument is sustain in seconds. Reads samples with linear
--   interpolation.
sfMsg :: Sf -> D -> Msg -> SE (Sig, Sig)

-- | Creates a midi instrument from sf2 sound font file. The second
--   argument is sustain in seconds. Reads samples with cubic
--   interpolation.
sfMsg3 :: Sf -> D -> Msg -> SE (Sig, Sig)

-- | Creates a midi instrument from sf2 sound font file. The second
--   argument is sustain in seconds. Reads samples with linear
--   interpolation. Produces mono output.
sfMsgm :: Sf -> D -> Msg -> SE Sig

-- | Creates a midi instrument from sf2 sound font file. The second
--   argument is sustain in seconds. Reads samples with cubic
--   interpolation. Produces mono output.
sfMsg3m :: Sf -> D -> Msg -> SE Sig

-- | Midi looper of the sf2 samples. The first arguments are: start, end,
--   crossfade of the loop.
sfMsgLooper :: Sig -> Sig -> Sig -> Sf -> D -> Msg -> SE (Sig, Sig)

-- | Reads sf2 samples at given midi velocity and key (both are from 0 to
--   127). The second argument is sustain. Interpolation is linear.
sfKey :: Sf -> D -> D -> D -> (Sig, Sig)

-- | Reads sf2 samples at given midi velocity and key (both are from 0 to
--   127). The second argument is sustain. Interpolation is cubic.
sfKey3 :: Sf -> D -> D -> D -> (Sig, Sig)

-- | Reads sf2 samples at given midi velocity and key (both are from 0 to
--   127). The second argument is sustain. Interpolation is linear. The
--   output is mono.
sfKeym :: Sf -> D -> D -> D -> Sig

-- | Reads sf2 samples at given midi velocity and key (both are from 0 to
--   127). The second argument is sustain. Interpolation is cubic. The
--   output is mono.
sfKey3m :: Sf -> D -> D -> D -> Sig

-- | Looper of the sf2 samples. The first arguments are: start, end,
--   crossfade of the loop.
sfKeyLooper :: Sig -> Sig -> Sig -> Sf -> D -> D -> D -> (Sig, Sig)

-- | Reads sf2 samples with amplitude in (0, 1) and frequency in Hz. The
--   interpolation is linear.
sfCps :: Sf -> D -> D -> D -> (Sig, Sig)

-- | Reads sf2 samples with amplitude in (0, 1) and frequency in Hz. The
--   interpolation is cubic.
sfCps3 :: Sf -> D -> D -> D -> (Sig, Sig)

-- | Reads sf2 samples with amplitude in (0, 1) and frequency in Hz. The
--   interpolation is linear. The output is mono.
sfCpsm :: Sf -> D -> D -> D -> Sig

-- | Reads sf2 samples with amplitude in (0, 1) and frequency in Hz. The
--   interpolation is cubic. The output is mono.
sfCps3m :: Sf -> D -> D -> D -> Sig

-- | Looper of the sf2 samples. The first arguments are: start, end,
--   crossfade of the loop.
sfCpsLooper :: Sig -> Sig -> Sig -> Sf -> D -> D -> D -> (Sig, Sig)

module Csound.Control.Evt

-- | A stream of events. We can convert a stream of events to the procedure
--   with the function <tt>runEvt</tt>. It waits for events and invokes the
--   given procedure when the event happens.
data Evt a :: * -> *
Evt :: (Bam a -> SE ()) -> Evt a
runEvt :: Evt a -> Bam a -> SE ()

-- | A procedure. Something that takes a value and suddenly bams with it.
type Bam a = a -> SE ()
type Tick = Evt Unit

-- | Converts booleans to events.
boolToEvt :: BoolSig -> Evt Unit
evtToBool :: Evt a -> BoolSig

-- | Triggers an event when signal equals to 1.
sigToEvt :: Sig -> Evt Unit
evtToSig :: D -> (Evt D) -> Sig

-- | Converts events to signals.
stepper :: Tuple a => a -> Evt a -> SE a

-- | Filters events with predicate.
filterE :: (a -> BoolD) -> Evt a -> Evt a

-- | Filters events with effectful predicate.
filterSE :: (a -> SE BoolD) -> Evt a -> Evt a

-- | Accumulator for events with side effects.
accumSE :: Tuple s => s -> (a -> s -> SE (b, s)) -> Evt a -> Evt b

-- | Accumulator for events.
accumE :: Tuple s => s -> (a -> s -> (b, s)) -> Evt a -> Evt b

-- | Accumulator with filtering. It can skip the events from the event
--   stream. If the third element of the triple equals to 1 then we should
--   include the event in the resulting stream. If the element equals to 0
--   we skip the event.
filterAccumE :: Tuple s => s -> (a -> s -> (BoolD, b, s)) -> Evt a -> Evt b

-- | Accumulator for events with side effects and filtering. Event triggers
--   only if the first element in the tripplet is true.
filterAccumSE :: Tuple s => s -> (a -> s -> SE (BoolD, b, s)) -> Evt a -> Evt b

-- | A snapshot of the signal. It converts a type of the signal to the type
--   of the value in the given moment. Instances:
--   
--   <pre>
--   type instance Snap D   = D
--   type instance Snap Str = Str
--   type instance Snap Tab = Tab
--   
--   type instance Snap Sig = D
--   
--   type instance Snap (a, b) = (Snap a, Snap b)
--   type instance Snap (a, b, c) = (Snap a, Snap b, Snap c)
--   type instance Snap (a, b, c, d) = (Snap a, Snap b, Snap c, Snap d)
--   type instance Snap (a, b, c, d, e) = (Snap a, Snap b, Snap c, Snap d, Snap e)
--   type instance Snap (a, b, c, d, e, f) = (Snap a, Snap b, Snap c, Snap d, Snap e, Snap f)
--   </pre>

-- | Get values of some signal at the given events.
snapshot :: (Tuple a, Tuple (Snap a)) => (Snap a -> b -> c) -> a -> Evt b -> Evt c

-- | Constructs an event stream that contains values from the given signal.
--   Events happens only when the signal changes.
snaps :: Sig -> Evt D

-- | Constructs an event stream that contains pairs from the given pair of
--   signals. Events happens when any signal changes.
snaps2 :: Sig2 -> Evt (D, D)

-- | Executes actions synchronized with global tempo (in Hz).
--   
--   <pre>
--   runEvtSync tempoCps evt proc
--   </pre>
sync :: (Default a, Tuple a) => D -> Evt a -> Evt a

-- | the sync function but time is measured in beats per minute.
syncBpm :: (Default a, Tuple a) => D -> Evt a -> Evt a

-- | Behaves like <a>metro</a>, but returns an event stream.
metroE :: Sig -> Evt Unit

-- | Fires a single event in the given time ahead.
impulseE :: D -> Evt Unit

-- | Behaves like <a>changed</a>, but returns an event stream.
changedE :: [Sig] -> Evt Unit

-- | Behaves like <a>trigger</a>, but returns an event stream.
triggerE :: Sig -> Sig -> Sig -> Evt Unit

-- | Fires a single event right now.
--   
--   <pre>
--   loadbang = pulseE 0
--   </pre>
loadbang :: Evt Unit

-- | Fires a single true value in the given time ahead.
impulse :: D -> Sig

-- | Constant event stream. It produces the same value (the first argument)
--   all the time.
devt :: D -> Evt a -> Evt D

-- | Makes an event stream from list of events.
eventList :: [(D, D, a)] -> Evt (Sco a)

-- | Constructs an event stream that contains an infinite repetition values
--   from the given list. When an event happens this function takes the
--   next value from the list, if there is no values left it starts from
--   the beggining of the list.
cycleE :: (Tuple a, Arg a) => [a] -> Evt b -> Evt a

-- | When something happens on the given event stream resulting event
--   stream contains an application of some unary function to the given
--   initial value. So the event stream contains the values:
--   
--   <pre>
--   [s0, f s0, f (f s0), f (f (f s0)), ...]
--   </pre>
iterateE :: Tuple a => a -> (a -> a) -> Evt b -> Evt a

-- | Substitutes all values in the input stream with the given constant
--   value.
repeatE :: Tuple a => a -> Evt b -> Evt a

-- | Accumulates a values from the given event stream with binary function.
--   It's a variant of the fold for event streams.
--   
--   <pre>
--   appendE z f evt
--   </pre>
--   
--   When value <tt>a</tt> happens with <tt>evt</tt>, the resulting event
--   stream contains a value (z <tt>f</tt> a) and in the next time
--   <tt>z</tt> equals to this value.
appendE :: Tuple a => a -> (a -> a -> a) -> Evt a -> Evt a

-- | A special variant of the function <a>appendE</a> for the monoids.
--   Initial value is <a>mempty</a> and binary function is <a>mappend</a>
--   which belong to the instance of the class <a>Monoid</a>.
mappendE :: (Monoid a, Tuple a) => Evt a -> Evt a

-- | Splits event stream on two streams with predicate.
partitionE :: (a -> BoolD) -> Evt a -> (Evt a, Evt a)

-- | Takes the ns events from the event stream and ignores the rest of the
--   stream.
takeE :: Int -> Evt a -> Evt a

-- | Drops the ns events from the event stream and leaves the rest of the
--   stream.
dropE :: Int -> Evt a -> Evt a

-- | Takes events while the predicate is true.
takeWhileE :: (a -> BoolD) -> Evt a -> Evt a

-- | Drops events while the predicate is true.
dropWhileE :: (a -> BoolD) -> Evt a -> Evt a

-- | Splits a toggle event stream on on-events and off-events.
splitToggle :: Evt D -> (Evt D, Evt D)

-- | Converts clicks to alternating 0 and 1 (toggle event stream)
toTog :: Tick -> Evt D

-- | Converts clicks to alternating 1 and 0 (toggle event stream with first
--   value set to 1)
toTog1 :: Tick -> Evt D

-- | Represents a values with frequency of occurence.
type Rnds a = [(D, a)]

-- | Constructs an event stream that contains values from the given list
--   which are taken in the random order.
oneOf :: (Tuple a, Arg a) => [a] -> Evt b -> Evt a

-- | Constructs an event stream that contains values from the given list
--   which are taken in the random order. In the list we specify not only
--   values but the frequencies of occurrence. Sum of the frequencies
--   should be equal to one.
freqOf :: (Tuple a, Arg a) => Rnds a -> Evt b -> Evt a

-- | This function combines the functions <a>accumE</a> and <a>freqOf</a>.
--   We transform the values of the event stream with stateful function
--   that produce not just values but the list of values with frequencies
--   of occurrence. We apply this function to the current state and the
--   value and then at random pick one of the values.
freqAccum :: (Tuple s, Tuple (b, s), Arg (b, s)) => s -> (a -> s -> Rnds (b, s)) -> Evt a -> Evt b

-- | An event stream of the random values in the interval <tt>(0, 1)</tt>.
randDs :: Evt b -> Evt D

-- | An event stram of lists of random values in the interval <tt>(0,
--   1)</tt>. The first argument is the length of the each list.
randList :: Int -> Evt b -> Evt [D]

-- | An event stream of the integers taken from the given diapason.
randInts :: (D, D) -> Evt b -> Evt D

-- | Skips elements at random.
--   
--   <pre>
--   randSkip prob
--   </pre>
--   
--   where <tt>prob</tt> is probability of includinng the element in the
--   output stream.
randSkip :: D -> Evt a -> Evt a

-- | Skips elements at random.
--   
--   <pre>
--   randSkip probFun
--   </pre>
--   
--   It behaves just like <tt>randSkip</tt>, but probability depends on the
--   value.
randSkipBy :: (a -> D) -> Evt a -> Evt a

-- | <pre>
--   range (xMin, xMax) === cycleE [xMin .. pred xMax]
--   </pre>
range :: (D, D) -> Evt b -> Evt D

-- | Turns an event of indices to the event of the values from the list. A
--   value is taken with index.
listAt :: (Tuple a, Arg a) => [a] -> Evt D -> Evt a

-- | Specialization of the function <a>masked</a>.
--   
--   <pre>
--   every n [a, b, c, ..] evt
--   </pre>
--   
--   constructs a mask that skips first <tt>n</tt> elements and then
--   produces an event and skips next (a - 1) events, then produces an
--   event and skips next (b - 1) events and so on. It's useful for
--   construction of the percussive beats. For example
--   
--   <pre>
--   every 0 [2] (metroE 2)
--   </pre>
--   
--   triggers an event on the odd beats. With this function we can create a
--   complex patterns of cyclic events.
every :: (Tuple a, Arg a) => Int -> [Int] -> Evt a -> Evt a

-- | Filters events with the mask. A mask is a list of ones and zeroes.
--   n'th element from the given list should be included in the resulting
--   stream if the n'th element from the list equals to one or skipped if
--   the element equals to zero.
masked :: (Tuple a, Arg a) => [D] -> Evt a -> Evt a


-- | We can convert notes to sound signals with instruments. An instrument
--   is a function:
--   
--   <pre>
--   (Arg a, Sigs b) =&gt; a -&gt; SE b
--   </pre>
--   
--   It takes a tuple of primitive Csound values (number, string or array)
--   and converts it to the tuple of signals and it makes some side effects
--   along the way so the output is wrapped in the <a>SE</a>-monad.
--   
--   There are only three ways of making a sound with an instrument:
--   
--   <ul>
--   <li>Suplpy an instrument with notes (<tt>Mix</tt>-section).</li>
--   <li>Trigger an instrument with event stream
--   (<tt>Evt</tt>-section).</li>
--   <li>By using midi-instruments (see <tt>Csound.Control.Midi</tt>).</li>
--   </ul>
--   
--   Sometimes we don't want to produce any sound. Our instrument is just a
--   procedure that makes something useful without being noisy about it.
--   It's type is:
--   
--   <pre>
--   (Arg a) =&gt; a -&gt; SE ()
--   </pre>
--   
--   To invoke the procedures there are functions with trailing underscore.
--   For example we have the function <tt>trig</tt> to convert event stream
--   to sound:
--   
--   <pre>
--   trig :: (Arg a, Sigs b) =&gt; (a -&gt; SE b) -&gt; Evts (D, D, a) -&gt; b 
--   </pre>
--   
--   and we have a <tt>trig</tt> with underscore to convert the event
--   stream to the sequence of the procedure invkations:
--   
--   <pre>
--   trig_ :: (Arg a) =&gt; (a -&gt; SE ()) -&gt; Evts (D, D, a) -&gt; SE () 
--   </pre>
--   
--   To invoke instruments from another instrumetnts we use artificial
--   closures made with functions with trailing xxxBy. For example:
--   
--   <pre>
--   trigBy :: (Arg a, Arg c, Sigs b) =&gt; (a -&gt; SE b) -&gt; (c -&gt; Evts (D, D, a)) -&gt; (c -&gt; b)
--   </pre>
--   
--   Notice that the event stream depends on the argument of the type c.
--   Here goes all the parameters that we want to pass from the outer
--   instrument. Unfortunately we can not just create the closure, because
--   our values are not the real values. It's a text of the programm (a
--   tiny snippet of it) to be executed. For a time being I don't know how
--   to make it better. So we need to pass the values explicitly.
--   
--   For example, if we want to make an arpeggiator:
--   
--   <pre>
--   pureTone :: D -&gt; SE Sig
--   pureTone cps = return $ mul env $ osc $ sig cps
--      where env = linseg [0, 0.01, 1, 0.25, 0]
--   
--   majArpeggio :: D -&gt; SE Sig
--   majArpeggio = return . schedBy pureTone evts
--       where evts cps = withDur 0.5 $ fmap (* cps) $ cycleE [1, 5/3, 3/2, 2] $ metroE 5
--   
--   main = dac $ mul 0.5 $ midi $ onMsg majArpeggio
--   </pre>
--   
--   We should use <a>schedBy</a> to pass the frequency as a parameter to
--   the event stream.
module Csound.Control.Instr
type Sco a = Track D a

-- | Special type that represents a scores of sound signals. If an
--   instrument is triggered with the scores the result is wrapped in the
--   value of this type.
data Mix a :: * -> *

-- | Plays a bunch of notes with the given instrument.
--   
--   <pre>
--   res = sco instrument scores 
--   </pre>
sco :: (Arg a, Sigs b) => (a -> SE b) -> Sco a -> Sco (Mix b)

-- | Renders a scores to the sound signals. we can use it inside the other
--   instruments.
mix :: Sigs a => Sco (Mix a) -> a

-- | Applies an effect to the sound. Effect is applied to the sound on the
--   give track.
--   
--   <pre>
--   res = eff effect sco 
--   </pre>
--   
--   <ul>
--   <li><tt>effect</tt> - a function that takes a tuple of signals and
--   produces a tuple of signals.</li>
--   <li><tt>sco</tt> - something that is constructed with <a>sco</a> or
--   <a>eff</a>.</li>
--   </ul>
--   
--   With the function <a>eff</a> you can apply a reverb or adjust the
--   level of the signal. It functions like a mixing board but unlike
--   mixing board it produces the value that you can arrange with functions
--   from your favorite Score-generation library. You can delay it or mix
--   with some other track and apply some another effect on top of it!
eff :: (Sigs a, Sigs b) => (a -> SE b) -> Sco (Mix a) -> Sco (Mix b)

-- | Mixes the scores and plays them in the loop.
mixLoop :: Sigs a => Sco (Mix a) -> a

-- | Invokes a procedure for the given bunch of events.
sco_ :: Arg a => (a -> SE ()) -> Sco a -> Sco (Mix Unit)

-- | Converts a bunch of procedures scheduled with scores to a single
--   procedure.
mix_ :: Sco (Mix Unit) -> SE ()

-- | Mixes the procedures and plays them in the loop.
mixLoop_ :: Sco (Mix Unit) -> SE ()

-- | Imitates a closure for a bunch of notes to be played within another
--   instrument.
mixBy :: (Arg a, Sigs b) => (a -> Sco (Mix b)) -> a -> b
infiniteDur :: Num a => a
sched :: (Arg a, Sigs b) => (a -> SE b) -> Evt (Sco a) -> b
retrig :: (Arg a, Sigs b) => (a -> SE b) -> Evt a -> b

-- | An instrument is triggered with event stream and delay time is set to
--   zero (event fires immediately) and duration is set to inifinite time.
--   The note is held while the instrument is producing something. If the
--   instrument is silent for some seconds (specified in the first
--   argument) then it's turned off.
schedHarp :: (Arg a, Sigs b) => D -> (a -> SE b) -> Evt [a] -> b

-- | Invokes an instrument with first event stream and holds the note until
--   the second event stream is active.
schedUntil :: (Arg a, Sigs b) => (a -> SE b) -> Evt a -> Evt c -> b

-- | Invokes an instrument with toggle event stream (1 stands for on and 0
--   stands for off).
schedToggle :: Sigs b => SE b -> Evt D -> b

-- | Triggers a procedure on the event stream.
sched_ :: Arg a => (a -> SE ()) -> Evt (Sco a) -> SE ()

-- | Invokes an instrument with first event stream and holds the note until
--   the second event stream is active.
schedUntil_ :: Arg a => (a -> SE ()) -> Evt a -> Evt c -> SE ()

-- | A closure to trigger an instrument inside the body of another
--   instrument.
schedBy :: (Arg a, Sigs b, Arg c) => (a -> SE b) -> (c -> Evt (Sco a)) -> c -> b

-- | A closure to trigger an instrument inside the body of another
--   instrument.
schedHarpBy :: (Arg a, Sigs b, Arg c) => D -> (a -> SE b) -> (c -> Evt [a]) -> c -> b

-- | Sets the same duration for all events. It's useful with the functions
--   <tt>sched</tt>, <tt>schedBy</tt>, <tt>sched_</tt>.
withDur :: D -> Evt a -> Evt (Sco a)

-- | Executes some procedure for the whole lifespan of the program,
alwaysOn :: SE () -> SE ()

-- | Transforms an instrument from always on to conditional one. The
--   routput instrument plays only when condition is true otherwise it
--   produces silence.
playWhen :: Sigs a => BoolSig -> (b -> SE a) -> (b -> SE a)
class Sigs (SigOuts a) => Outs a where type family SigOuts a :: *
toOuts :: Outs a => a -> SE (SigOuts a)
onArg :: Outs b => (a -> b) -> (a -> SE (SigOuts b))

-- | Constructs a drum-like instrument. Drum like instrument has a single
--   argument that signifies an amplitude.
class AmpInstr a where type family AmpInstrOut a :: *
onAmp :: AmpInstr a => a -> D -> SE (AmpInstrOut a)

-- | Constructs a simple instrument that takes in a tuple of two arguments.
--   They are amplitude and the frequency (in Hz or cycles per second).
class CpsInstr a where type family CpsInstrOut a :: *
onCps :: CpsInstr a => a -> (D, D) -> SE (CpsInstrOut a)


-- | Midi.
module Csound.Control.Midi

-- | Specifies the midi channel or programm.
data MidiChn
ChnAll :: MidiChn
Chn :: Int -> MidiChn
Pgm :: (Maybe Int) -> Int -> MidiChn
type MidiFun a = (Msg -> SE a) -> SE a
toMidiFun :: Sigs a => MidiChn -> MidiFun a
toMidiFun_ :: MidiChn -> MidiFun ()
data Msg :: *
type Channel = Int

-- | Triggers a midi-instrument (aka Csound's massign) for all channels.
--   It's useful to test a single instrument.
midi :: (Num a, Sigs a) => (Msg -> SE a) -> SE a

-- | Triggers a midi-instrument (aka Csound's massign) on the specified
--   channel.
midin :: (Num a, Sigs a) => Channel -> (Msg -> SE a) -> SE a

-- | Triggers a midi-instrument (aka Csound's pgmassign) on the specified
--   programm bank.
pgmidi :: (Num a, Sigs a) => Maybe Int -> Channel -> (Msg -> SE a) -> SE a
ampCps :: Msg -> (D, D)

-- | Triggers a midi-procedure (aka Csound's massign) for all channels.
midi_ :: (Msg -> SE ()) -> SE ()

-- | Triggers a midi-procedure (aka Csound's pgmassign) on the given
--   channel.
midin_ :: Channel -> (Msg -> SE ()) -> SE ()

-- | Triggers a midi-procedure (aka Csound's pgmassign) on the given
--   programm bank.
pgmidi_ :: Maybe Int -> Channel -> (Msg -> SE ()) -> SE ()

-- | Produces midi amplitude and frequency as a signal. The signal fades
--   out when nothing is pressed. It can be used in mono-synths. Arguments
--   are portamento time and release time. A portamento time is time it
--   takes for transition from one note to another.
--   
--   <pre>
--   monoMsg channel portamentoTime releaseTime
--   </pre>
monoMsg :: MidiChn -> D -> D -> SE (Sig, Sig)

-- | Produces midi amplitude and frequency as a signal and holds the last
--   value till the next one is present. It can be used in mono-synths.
--   Arguments are portamento time and release time. A portamento time is
--   time it takes for transition from one note to another.
--   
--   <pre>
--   holdMsg portamentoTime
--   </pre>
holdMsg :: MidiChn -> D -> SE (Sig, Sig)

-- | Listens to midi on event on the given key as event stream. The event
--   stream carries the level of volume (ranges from 0 to 1).
midiKeyOn :: MidiChn -> D -> SE (Evt D)

-- | Listens to midi on event off the given key as event stream.
midiKeyOff :: MidiChn -> D -> SE Tick

-- | Get the note number of the current MIDI event, expressed in
--   cycles-per-second.
--   
--   <pre>
--   icps  cpsmidi 
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/cpsmidi.html</a>
cpsmidi :: Msg -> D

-- | Get the velocity of the current MIDI event.
--   
--   <pre>
--   iamp  ampmidi  iscal [, ifn]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/ampmidi.html</a>
ampmidi :: Msg -> D -> D

-- | Initialization of the midi control-messages.
initc7 :: D -> D -> D -> SE ()

-- | Allows a floating-point 7-bit MIDI signal scaled with a minimum and a
--   maximum range.
--   
--   <pre>
--   idest  ctrl7  ichan, ictlno, imin, imax [, ifn]
--   kdest  ctrl7  ichan, ictlno, kmin, kmax [, ifn]
--   adest  ctrl7  ichan, ictlno, kmin, kmax [, ifn] [, icutoff]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/ctrl7.html</a>
ctrl7 :: D -> D -> D -> D -> Sig

-- | Initializes midi control and get the value in the specified range.
midiCtrl7 :: D -> D -> D -> D -> D -> SE Sig

-- | Initializes midi control and get the value in the range (-1) to 1.
midiCtrl :: D -> D -> D -> SE Sig

-- | Unipolar midiCtrl. Initializes midi control and get the value in the
--   range 0 to 1.
umidiCtrl :: D -> D -> D -> SE Sig

-- | Converts a value to the midi-instrument. It's used with the functions
--   <a>midi</a>, <a>midin</a>.
class MidiInstr a where type family MidiInstrOut a :: *
onMsg :: MidiInstr a => a -> Msg -> SE (MidiInstrOut a)
instance Show MidiChn
instance Eq MidiChn


-- | Primitive GUI elements.
--   
--   There is a convention that constructors take only parameters that
--   specify the logic of the widget. The view is set for GUI-elements with
--   other functions.
module Csound.Control.Gui.Widget

-- | The diapason of the continuous value.
data ValDiap :: *
ValDiap :: Double -> Double -> ValDiap
valDiapMin :: ValDiap -> Double
valDiapMax :: ValDiap -> Double
type ValStep = Double
data ValScaleType :: *
Linear :: ValScaleType
Exponential :: ValScaleType

-- | A value span is a diapason of the value and a type of the scale (can
--   be linear or exponential).
data ValSpan :: *
ValSpan :: ValDiap -> ValScaleType -> ValSpan
valSpanDiap :: ValSpan -> ValDiap
valSpanScale :: ValSpan -> ValScaleType

-- | Makes a linear <tt>ValSpan</tt> with specified boundaries.
--   
--   <pre>
--   linSpan minVal maxVal
--   </pre>
linSpan :: Double -> Double -> ValSpan

-- | Makes an exponential <tt>ValSpan</tt> with specified boundaries.
--   
--   <pre>
--   expSpan minVal maxVal
--   </pre>
expSpan :: Double -> Double -> ValSpan

-- | Unit span. A special case:
--   
--   <pre>
--   uspan = linSpan 0 1
--   </pre>
uspan :: ValSpan

-- | Bipolar unit span. A special case:
--   
--   <pre>
--   uspan = linSpan (-1) 1
--   </pre>
bspan :: ValSpan

-- | An exponential unit span. A special case:
--   
--   <pre>
--   uspan = expSpan 0 1
--   </pre>
uspanExp :: ValSpan

-- | Allows the user to increase/decrease a value with mouse clicks on a
--   corresponding arrow button. Output is an event stream that contains
--   values when counter changes.
--   
--   <pre>
--   count diapason fineValStep maybeCoarseValStep initValue 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLcount.html</a>
count :: ValDiap -> ValStep -> Maybe ValStep -> Double -> Source (Evt D)

-- | A variance on the function <a>count</a>, but it produces a signal of
--   piecewise constant function.
countSig :: ValDiap -> ValStep -> Maybe ValStep -> Double -> Source Sig

-- | It is a squared area that allows the user to modify two output values
--   at the same time. It acts like a joystick.
--   
--   <pre>
--   joy valueSpanX valueSpanY (initX, initY) 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLjoy.html</a>
joy :: ValSpan -> ValSpan -> (Double, Double) -> Source (Sig, Sig)

-- | A FLTK widget opcode that creates a knob.
--   
--   <pre>
--   knob valueSpan initValue
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLknob.html</a>
knob :: String -> ValSpan -> Double -> Source Sig
data KnobType :: *
ThreeD :: Maybe Int -> KnobType
Pie :: KnobType
Clock :: KnobType
Flat :: KnobType
setKnobType :: KnobType -> Gui -> Gui

-- | FLroller is a sort of knob, but put transversally.
--   
--   <pre>
--   roller valueSpan step initVal
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLroller.html</a>
roller :: String -> ValSpan -> ValStep -> Double -> Source Sig

-- | FLslider puts a slider into the corresponding container.
--   
--   <pre>
--   slider valueSpan initVal 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLslider.html</a>
slider :: String -> ValSpan -> Double -> Source Sig

-- | Constructs a list of linear unit sliders (ranges in [0, 1]). It takes
--   a list of init values.
sliderBank :: String -> [Double] -> Source [Sig]
data SliderType :: *
Fill :: SliderType
Engraved :: SliderType
Nice :: SliderType
setSliderType :: SliderType -> Gui -> Gui

-- | numeric (originally FLtext in the Csound) allows the user to modify a
--   parameter value by directly typing it into a text field.
--   
--   <pre>
--   numeric diapason step initValue 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLtext.html</a>
numeric :: String -> ValDiap -> ValStep -> Double -> Source Sig
data TextType :: *
NormalText :: TextType
NoDrag :: TextType
NoEdit :: TextType
setTextType :: TextType -> Gui -> Gui

-- | A FLTK widget that displays text inside of a box. If the text is
--   longer than 255 characters the text is split on several parts (Csound
--   limitations).
--   
--   <pre>
--   box text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbox.html</a>
box :: String -> Display

-- | The type of the box. Some values are not implemented on the Csound
--   level.
data BoxType :: *
FlatBox :: BoxType
UpBox :: BoxType
DownBox :: BoxType
ThinUpBox :: BoxType
ThinDownBox :: BoxType
EngravedBox :: BoxType
EmbossedBox :: BoxType
BorderBox :: BoxType
ShadowBox :: BoxType
Roundedbox :: BoxType
RoundedShadowBox :: BoxType
RoundedFlatBox :: BoxType
RoundedUpBox :: BoxType
RoundedDownBox :: BoxType
DiamondUpBox :: BoxType
DiamondDownBox :: BoxType
OvalBox :: BoxType
OvalShadowBox :: BoxType
OvalFlatBox :: BoxType
setBoxType :: BoxType -> Gui -> Gui

-- | A FLTK widget opcode that creates a button.
--   
--   <pre>
--   button text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutton.html</a>
button :: String -> Source (Evt Unit)

-- | The type of the button. It affects toggle buttons and button banks.
--   
--   In Csound buttons and toggle buttons are constructed with the same
--   function (but with different button types). But in this library they
--   are contructed by different functions (<tt>button</tt> and
--   <tt>toggle</tt>). Normal button is a plain old button, but other
--   values specify toggle buttons. So this property doesn't affect the
--   buttons (since they could be only normal buttons).
data ButtonType :: *
NormalButton :: ButtonType
LightButton :: ButtonType
CheckButton :: ButtonType
RoundButton :: ButtonType
setButtonType :: ButtonType -> Gui -> Gui

-- | A FLTK widget opcode that creates a toggle button.
--   
--   <pre>
--   button text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutton.html</a>
toggle :: String -> Bool -> Source (Evt D)

-- | A FLTK widget opcode that creates a bank of buttons. Result is (x, y)
--   coordinate of the triggered button.
--   
--   <pre>
--   butBank xNumOfButtons yNumOfButtons
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutBank.html</a>
butBank :: String -> Int -> Int -> (Int, Int) -> Source (Evt (D, D))

-- | A variance on the function <a>toggle</a>, but it produces a signal of
--   piecewise constant function.
toggleSig :: String -> Bool -> Source Sig

-- | A variance on the function <a>butBank</a>, but it produces a signal of
--   piecewise constant function. Result is (x, y) coordinate of the
--   triggered button.
butBankSig :: String -> Int -> Int -> (Int, Int) -> Source (Sig, Sig)

-- | A FLTK widget opcode that creates a bank of buttons.
--   
--   <pre>
--   butBank xNumOfButtons yNumOfButtons
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutBank.html</a>
butBank1 :: String -> Int -> Int -> (Int, Int) -> Source (Evt D)
butBankSig1 :: String -> Int -> Int -> (Int, Int) -> Source Sig

-- | A radio button. It takes a list of values with labels.
radioButton :: Arg a => String -> [(String, a)] -> Int -> Source (Evt a)

-- | A matrix of values.
matrixButton :: Arg a => String -> Int -> Int -> [a] -> (Int, Int) -> Source (Evt a)

-- | Radio button that returns functions. Useful for picking a waveform or
--   type of filter.
funnyRadio :: Tuple b => String -> [(String, a -> b)] -> Int -> Source (a -> b)

-- | Matrix of functional values.
funnyMatrix :: Tuple b => String -> Int -> Int -> [(a -> b)] -> (Int, Int) -> Source (a -> b)

-- | FLtext that is sink shows current the value of a valuator in a text
--   field.
setNumeric :: String -> ValDiap -> ValStep -> Double -> Sink Sig

-- | A slider that serves as indicator. It consumes values instead of
--   producing.
--   
--   <pre>
--   meter valueSpan initValue
--   </pre>
meter :: String -> ValSpan -> Double -> Sink Sig
setKnob :: String -> ValSpan -> Double -> SinkSource Sig
setSlider :: String -> ValSpan -> Double -> SinkSource Sig
setToggle :: String -> Bool -> SinkSource (Evt D)
setToggleSig :: String -> Bool -> SinkSource Sig

-- | Appends a title to a group of widgets.
setTitle :: String -> Gui -> SE Gui

-- | Keyboard events.
data KeyEvt :: *
Press :: Key -> KeyEvt
Release :: Key -> KeyEvt

-- | Keys.
data Key :: *
CharKey :: Char -> Key
F1 :: Key
F2 :: Key
F3 :: Key
F4 :: Key
F5 :: Key
F6 :: Key
F7 :: Key
F8 :: Key
F9 :: Key
F10 :: Key
F11 :: Key
F12 :: Key
Scroll :: Key
CapsLook :: Key
LeftShift :: Key
RightShift :: Key
LeftCtrl :: Key
RightCtrl :: Key
Enter :: Key
LeftAlt :: Key
RightAlt :: Key
LeftWinKey :: Key
RightWinKey :: Key
Backspace :: Key
ArrowUp :: Key
ArrowLeft :: Key
ArrowRight :: Key
ArrowDown :: Key
Insert :: Key
Home :: Key
PgUp :: Key
Delete :: Key
End :: Key
PgDown :: Key
NumLock :: Key
NumDiv :: Key
NumMul :: Key
NumSub :: Key
NumHome :: Key
NumArrowUp :: Key
NumPgUp :: Key
NumArrowLeft :: Key
NumSpace :: Key
NumArrowRight :: Key
NumEnd :: Key
NumArrowDown :: Key
NumPgDown :: Key
NumIns :: Key
NumDel :: Key
NumEnter :: Key
NumPlus :: Key
Num7 :: Key
Num8 :: Key
Num9 :: Key
Num4 :: Key
Num5 :: Key
Num6 :: Key
Num1 :: Key
Num2 :: Key
Num3 :: Key
Num0 :: Key
NumDot :: Key

-- | The stream of keyboard press/release events.
keyIn :: KeyEvt -> Evt Unit

-- | Shortcut for press <a>CharKey</a> events.
charOn :: Char -> Evt Unit

-- | Shortcut for release <a>CharKey</a> events.
charOff :: Char -> Evt Unit

-- | Creates an event in the output stream when one of the chars is
--   pressed.
strOn :: String -> Tick

-- | Creates an event in the output stream when one of the chars is
--   depressed.
strOff :: String -> Tick

-- | Unipolar linear knob. The value belongs to the interval [0, 1]. The
--   argument is for initial value.
uknob :: Double -> Source Sig

-- | Exponential knob (usefull for exploring frequencies or decibels).
--   
--   <pre>
--   xknob (min, max) initVal
--   </pre>
--   
--   The value belongs to the interval [min, max]. The last argument is for
--   initial value.
xknob :: Range Double -> Double -> Source Sig

-- | Unipolar linear slider. The value belongs to the interval [0, 1]. The
--   argument is for initial value.
uslider :: Double -> Source Sig

-- | Exponential slider (usefull for exploring frequencies or decibels).
--   
--   <pre>
--   xknob (min, max) initVal
--   </pre>
--   
--   The value belongs to the interval [min, max]. The last argument is for
--   initial value.
xslider :: Range Double -> Double -> Source Sig

-- | Unit linear joystick.
ujoy :: (Double, Double) -> Source (Sig, Sig)

-- | Horizontal radio group.
hradio :: [String] -> Int -> Source (Evt D)

-- | Vertical radio group.
vradio :: [String] -> Int -> Source (Evt D)

-- | Horizontal radio group.
hradioSig :: [String] -> Int -> Source Sig

-- | Vertical radio group.
vradioSig :: [String] -> Int -> Source Sig

-- | The sample and hold widget. You can pick a value from the list of
--   doubles. The original value is a head of the list (the first element).
--   The visual grouping is horizontal (notice the prefix <tt>h</tt>). It's
--   common to use it with function <tt>selector</tt>.
hnumbers :: [Double] -> Source Sig

-- | The sample and hold widget. You can pick a value from the list of
--   doubles. The original value is a head of the list (the first element).
--   The visual grouping is vertical (notice the prefix <tt>v</tt>). It's
--   common to use it with function <tt>selector</tt>.
vnumbers :: [Double] -> Source Sig

-- | Pair of minimum and maximum values.
type Range a = (a, a)

-- | Creates a knob that outputs only integers in the given range. It
--   produces an event stream of integer values. It can be used with list
--   access functions <tt>listAt</tt>, <tt>atTuple</tt>, <tt>atArg</tt>.
--   
--   <pre>
--   rangeKnob needInit (min, max) initVal
--   </pre>
--   
--   The first argument is a boolean. If it's true than the initial value
--   is put in the output stream. If its False the initial value is
--   skipped.
rangeKnob :: Bool -> Range Int -> Int -> Source (Evt D)

-- | Creates a slider that outputs only integers in the given range. It
--   produces an event stream of integer values. It can be used with list
--   access functions <tt>listAt</tt>, <tt>atTuple</tt>, <tt>atArg</tt>.
--   
--   <pre>
--   rangeSlider needInit (min, max) initVal
--   </pre>
--   
--   The first argument is a boolean. If it's true than the initial value
--   is put in the output stream. If its False the initial value is
--   skipped.
rangeSlider :: Bool -> Range Int -> Int -> Source (Evt D)

-- | Creates a knob that outputs only integers in the given range. It
--   produces a signal of integer values.
--   
--   <pre>
--   rangeKnobSig (min, max) initVal 
--   </pre>
rangeKnobSig :: Range Int -> Int -> Source Sig

-- | Creates a slider that outputs only integers in the given range. It
--   produces a signal of integer values.
--   
--   <pre>
--   rangeSliderSig (min, max) initVal 
--   </pre>
rangeSliderSig :: Range Int -> Int -> Source Sig

-- | 2d range range slider. Outputs a pair of event streams. Each stream
--   contains changes in the given direction (Ox or Oy).
--   
--   <pre>
--   rangeJoy needsInit rangeX rangeY (initX, initY)
--   </pre>
--   
--   The first argument is a boolean. If it's true than the initial value
--   is put in the output stream. If its False the initial value is
--   skipped.
rangeJoy :: Bool -> Range Int -> Range Int -> (Int, Int) -> Source (Evt D, Evt D)

-- | 2d range range slider. It produces a single event stream. The event
--   fires when any signal changes.
--   
--   <pre>
--   rangeJoy2 needsInit rangeX rangeY (initX, initY)
--   </pre>
--   
--   The first argument is a boolean. If it's true than the initial value
--   is put in the output stream. If its False the initial value is
--   skipped.
rangeJoy2 :: Bool -> Range Int -> Range Int -> (Int, Int) -> Source (Evt (D, D))

-- | 2d range range slider. It produces the pair of integer signals
rangeJoySig :: Range Int -> Range Int -> (Int, Int) -> Source (Sig, Sig)

-- | The matrix of unipolar knobs.
--   
--   <pre>
--   knobPad columnNum rowNum names initVals 
--   </pre>
--   
--   It takes in the dimensions of matrix, the names (we can leave it empty
--   if names are not important) and list of init values. It returns a
--   function that takes in indices and produces the signal in the
--   corresponding cell.
knobPad :: Int -> Int -> [String] -> [Double] -> Source (Int -> Int -> Sig)

-- | The matrix of toggle buttons.
--   
--   <pre>
--   togglePad columnNum rowNum names initVals 
--   </pre>
--   
--   It takes in the dimensions of matrix, the names (we can leave it empty
--   if names are not important) and list of init values (on/off booleans).
--   It returns a function that takes in indices and produces the event
--   stream in the corresponding cell.
togglePad :: Int -> Int -> [String] -> [Bool] -> Source (Int -> Int -> Evt D)

-- | The matrix of buttons.
--   
--   <pre>
--   buttonPad columnNum rowNum names
--   </pre>
--   
--   It takes in the dimensions of matrix, the names (we can leave it empty
--   if names are not important). It returns a function that takes in
--   indices and produces the event stream in the corresponding cell.
buttonPad :: Int -> Int -> [String] -> Source (Int -> Int -> Evt Unit)

-- | A generic constructor for matrixes of sound source widgets. It takes
--   the constructor of the widget, a default initial value, the dimensions
--   of the matrix, the list of names and the list of initial values. It
--   produces the function that maps indices to corresponding values.
genPad :: (String -> a -> Source b) -> a -> Int -> Int -> [String] -> [a] -> Source (Int -> Int -> b)

-- | It's like simple <tt>button</tt>, but it can be controlled with
--   external control. The first argument is for external control.
button' :: Tick -> String -> Source Tick

-- | It's like simple <tt>toggle</tt>, but it can be controlled with
--   external control. The first argument is for external control.
toggle' :: Evt D -> String -> Bool -> Source (Evt D)
toggleSig' :: Sig -> String -> Bool -> Source Sig

-- | It's like simple <tt>knob</tt>, but it can be controlled with external
--   control. The first argument is for external control.
knob' :: Sig -> String -> ValSpan -> Double -> Source Sig

-- | It's like simple <tt>slider</tt>, but it can be controlled with
--   external control. The first argument is for external control.
slider' :: Sig -> String -> ValSpan -> Double -> Source Sig

-- | It's like simple <tt>uknob</tt>, but it can be controlled with
--   external control. The first argument is for external control.
uknob' :: Sig -> Double -> Source Sig

-- | It's like simple <tt>uslider</tt>, but it can be controlled with
--   external control. The first argument is for external control.
uslider' :: Sig -> Double -> Source Sig

-- | It's like simple <tt>hradio</tt>, but it can be controlled with
--   external control. The first argument is for external control.
hradio' :: Evt D -> [String] -> Int -> Source (Evt D)

-- | It's like simple <tt>vradio</tt>, but it can be controlled with
--   external control. The first argument is for external control.
vradio' :: Evt D -> [String] -> Int -> Source (Evt D)

-- | It's like simple <tt>hradioSig</tt>, but it can be controlled with
--   external control. The first argument is for external control.
hradioSig' :: Sig -> [String] -> Int -> Source Sig

-- | It's like simple <tt>vradioSig</tt>, but it can be controlled with
--   external control. The first argument is for external control.
vradioSig' :: Sig -> [String] -> Int -> Source Sig


-- | GUI (Graphical User Interface) elements are handy to change the
--   parameters of the sound in real time. It includes sliders, knobs,
--   rollers, buttons and other widgets.
--   
--   A GUI element consists of two parts. They are view (how it looks) and
--   logic (what's going on with it). For example a slider can be
--   horizontal or vertical or green or yellow or small or big. It's the
--   view of the slider. And a slider can produce a continuous signal
--   within the given interval. It's a logic of the slider.
--   
--   Let's talk about the view. The view is divided on two parts:
--   
--   <ul>
--   <li>where element is placed or Layout.</li>
--   <li>all other properties or just Properties.</li>
--   </ul>
--   
--   The layout is defined with very simple functions. There are vertical
--   and horizontal grouping of the elements. We can scale the element
--   within the group and include an empty space in the group. Everything
--   is aligned (see <a>Csound.Gui.Layout</a>). Other properties include
--   colors, fonts (size and type), borders, specific properties of the
--   widgets (see <a>Csound.Gui.Props</a>).
--   
--   Let's consider the logic. The logic consists of three parts:
--   
--   <ul>
--   <li>what is consumed (<a>Output</a>)</li>
--   <li>what is produced (<a>Input</a>)</li>
--   <li>what's going on inside (<a>Inner</a>)</li>
--   </ul>
--   
--   A widget can react on values, produce values or do something useful.
--   There are special types of widgets:
--   
--   <ul>
--   <li><a>Source</a> - they produce values only</li>
--   <li><a>Sink</a> - they consume values only</li>
--   <li><a>Display</a> - something is going on inside them (for example,
--   it can show a "hello world" message)</li>
--   </ul>
--   
--   Widgets can be simple and compound. Simple widgets are primitive
--   elements (sliders, knobs, rollers, buttons). We have a special
--   constructors that produce simple widgets (see
--   <a>Csound.Gui.Widget</a>). Compound widgets glue together several
--   widgets. That is the view contains several elements and all of them
--   involved in the logic of the widget.
module Csound.Control.Gui

-- | A visual representation of the GUI-element.
data Gui :: *

-- | A widget consists of visible element (Gui), value consumer (Output)
--   and producer (Input) and an inner state (Inner).
type Widget a b = SE (Gui, Output a, Input b, Inner)

-- | Widgets that produce something has inputs.
type Input a = a

-- | Widgets that consume something has outputs.
type Output a = a -> SE ()

-- | Widgets that just do something inside them or have an inner state.
type Inner = SE ()

-- | A consumer of the values.
type Sink a = SE (Gui, Output a)

-- | A producer of the values.
type Source a = SE (Gui, Input a)

-- | A static element. We can only look at it.
type Display = SE Gui
type SinkSource a = SE (Gui, Output a, Input a)

-- | A widget constructor.
widget :: SE (Gui, Output a, Input b, Inner) -> Widget a b

-- | A consumer constructor.
sink :: SE (Gui, Output a) -> Sink a

-- | A producer constructor.
source :: SE (Gui, Input a) -> Source a

-- | A display constructor.
display :: SE Gui -> Display
sinkSource :: SE (Gui, Output a, Input a) -> SinkSource a
sinkSlice :: SinkSource a -> Sink a
sourceSlice :: SinkSource a -> Source a

-- | A handy function for transforming the value of producers.
mapSource :: (a -> b) -> Source a -> Source b

-- | A handy function for transforming the GUIs of producers.
mapGuiSource :: (Gui -> Gui) -> Source a -> Source a

-- | Horizontal grouping of widgets that can produce monoidal values.
mhor :: Monoid a => [Source a] -> Source a

-- | Vertical grouping of widgets that can produce monoidal values.
mver :: Monoid a => [Source a] -> Source a

-- | Scaling of widgets that can produce values.
msca :: Double -> Source a -> Source a

-- | Hides the SE inside Source.
joinSource :: Source (SE a) -> Source a

-- | Renders the GUI elements on the window. Rectangle is calculated
--   automatically (window doesn't listens for keyboard events).
panel :: Gui -> SE ()

-- | Creates a window with the given name, size and content
--   
--   <pre>
--   win name (width, height) gui
--   </pre>
win :: String -> (Int, Int) -> Gui -> SE ()

-- | Renders a list of panels.
panels :: [Gui] -> SE ()

-- | Renders the GUI elements on the window. We can specify the window
--   title and rectangle of the window.
panelBy :: String -> Maybe Rect -> Gui -> SE ()

-- | Renders the GUI elements on the window. Rectangle is calculated
--   automatically (window listens for keyboard events).
keyPanel :: Gui -> SE ()
keyWin :: String -> (Int, Int) -> Gui -> SE ()

-- | Renders a list of panels. Panels are sensitive to keyboard events.
keyPanels :: [Gui] -> SE ()

-- | Renders the GUI elements on the window. We can specify the window
--   title and rectangle of the window. Panesls are sensitive to keyboard
--   events.
keyPanelBy :: String -> Maybe Rect -> Gui -> SE ()

-- | Groups a list of Source-widgets. The visuals are horizontally aligned.
hlifts :: ([a] -> b) -> [Source a] -> Source b

-- | Groups a list of Source-widgets. The visuals are vertically aligned.
vlifts :: ([a] -> b) -> [Source a] -> Source b

-- | The shortcut for <tt>mapSource</tt>.
lift1 :: (a -> b) -> Source a -> Source b

-- | Combines two sound sources. Visuals are aligned horizontally and the
--   sound sources a grouped with the given function.
hlift2 :: (a -> b -> c) -> Source a -> Source b -> Source c

-- | Combines two sound sources. Visuals are aligned vertically and the
--   sound sources a grouped with the given function.
vlift2 :: (a -> b -> c) -> Source a -> Source b -> Source c

-- | The same as <tt>hlift2</tt> but for three sound sources.
hlift3 :: (a -> b -> c -> d) -> Source a -> Source b -> Source c -> Source d

-- | The same as <tt>vlift2</tt> but for three sound sources.
vlift3 :: (a -> b -> c -> d) -> Source a -> Source b -> Source c -> Source d

-- | The same as <tt>hlift2</tt> but for four sound sources.
hlift4 :: (a -> b -> c -> d -> e) -> Source a -> Source b -> Source c -> Source d -> Source e

-- | The same as <tt>vlift2</tt> but for four sound sources.
vlift4 :: (a -> b -> c -> d -> e) -> Source a -> Source b -> Source c -> Source d -> Source e

-- | The same as <tt>hlift2</tt> but for five sound sources.
hlift5 :: (a1 -> a2 -> a3 -> a4 -> a5 -> b) -> Source a1 -> Source a2 -> Source a3 -> Source a4 -> Source a5 -> Source b

-- | The same as <tt>vlift2</tt> but for five sound sources.
vlift5 :: (a1 -> a2 -> a3 -> a4 -> a5 -> b) -> Source a1 -> Source a2 -> Source a3 -> Source a4 -> Source a5 -> Source b

-- | Groups a list of Source-widgets. The visuals are horizontally aligned.
--   It uses the list of proportions.
hlifts' :: [Double] -> ([a] -> b) -> [Source a] -> Source b

-- | Groups a list of Source-widgets. The visuals are vertically aligned.
--   It uses the list of proportions.
vlifts' :: [Double] -> ([a] -> b) -> [Source a] -> Source b

-- | It's just like the <tt>hlift2</tt> but two more parameters change
--   visual scaling of the widgets.
hlift2' :: Double -> Double -> (a -> b -> c) -> Source a -> Source b -> Source c

-- | It's just like the <tt>vlift2</tt> but two more parameters change
--   visual scaling of the widgets.
vlift2' :: Double -> Double -> (a -> b -> c) -> Source a -> Source b -> Source c

-- | The same as <tt>hlift2'</tt> but for three sound sources.
hlift3' :: Double -> Double -> Double -> (a -> b -> c -> d) -> Source a -> Source b -> Source c -> Source d

-- | The same as <tt>vlift2'</tt> but for three sound sources.
vlift3' :: Double -> Double -> Double -> (a -> b -> c -> d) -> Source a -> Source b -> Source c -> Source d

-- | The same as <tt>hlift2'</tt> but for four sound sources.
hlift4' :: Double -> Double -> Double -> Double -> (a -> b -> c -> d -> e) -> Source a -> Source b -> Source c -> Source d -> Source e

-- | The same as <tt>vlift2'</tt> but for four sound sources.
vlift4' :: Double -> Double -> Double -> Double -> (a -> b -> c -> d -> e) -> Source a -> Source b -> Source c -> Source d -> Source e

-- | The same as <tt>hlift2'</tt> but for five sound sources.
hlift5' :: Double -> Double -> Double -> Double -> Double -> (a1 -> a2 -> a3 -> a4 -> a5 -> b) -> Source a1 -> Source a2 -> Source a3 -> Source a4 -> Source a5 -> Source b

-- | The same as <tt>vlift2'</tt> but for five sound sources.
vlift5' :: Double -> Double -> Double -> Double -> Double -> (a1 -> a2 -> a3 -> a4 -> a5 -> b) -> Source a1 -> Source a2 -> Source a3 -> Source a4 -> Source a5 -> Source b
instance At Sig2 (SE Sig2) a => At Sig2 (SE Sig2) (Source a)
instance At Sig2 Sig2 a => At Sig2 Sig2 (Source a)
instance At Sig (SE Sig) a => At Sig (SE Sig) (Source a)
instance SigSpace a => SigSpace (Source a)


-- | The module contains the modules that are responsible for converting
--   events to signals
module Csound.Control


-- | Rendering of Csound files and playing the music in real time.
--   
--   How are we going to get the sound out of Haskell code? Instruments are
--   ready and we have written all the scores for them. Now, it's time to
--   use the rendering functions. We can render haskell expressions to
--   Csound code. A rendering function takes a value that represents a
--   sound (it's a tuple of signals) and produces a string with Csound
--   code. It can take a value that represents the flags for the csound
--   compiler and global settings (<a>Options</a>). Then we can save this
--   string to file and convert it to sound with csound compiler
--   
--   <pre>
--   csound -o music.wav music.csd
--   </pre>
--   
--   Or we can play it in real time with -odac flag. It sends the sound
--   directly to soundcard. It's usefull when we are using midi or tweek
--   the parameters in real time with sliders or knobs.
--   
--   <pre>
--   csound -odac music.csd
--   </pre>
--   
--   The main function of this module is <a>renderCsdBy</a>. Other function
--   are nothing but wrappers that produce the Csound code and make
--   something useful with it (saving to file, playing with specific player
--   or in real time).
module Csound.IO
class RenderCsd a
renderCsdBy :: RenderCsd a => Options -> a -> IO String

-- | Renders Csound file.
renderCsd :: RenderCsd a => a -> IO String

-- | Render Csound file and save it to the give file.
writeCsd :: RenderCsd a => String -> a -> IO ()

-- | Render Csound file with options and save it to the give file.
writeCsdBy :: RenderCsd a => Options -> String -> a -> IO ()

-- | Render Csound file and save result sound to the wav-file.
writeSnd :: RenderCsd a => String -> a -> IO ()

-- | Render Csound file with options and save result sound to the wav-file.
writeSndBy :: RenderCsd a => Options -> String -> a -> IO ()

-- | Renders Csound file, saves it to the given file, renders with csound
--   command and plays it with the given program.
--   
--   <pre>
--   playCsd program file csd 
--   </pre>
--   
--   Produces files <tt>file.csd</tt> (with <a>renderCsd</a>) and
--   <tt>file.wav</tt> (with <tt>csound</tt>) and then invokes:
--   
--   <pre>
--   program "file.wav"
--   </pre>
playCsd :: RenderCsd a => (String -> IO ()) -> String -> a -> IO ()

-- | Works just like <a>playCsd</a> but you can supply csound options.
playCsdBy :: RenderCsd a => Options -> (String -> IO ()) -> String -> a -> IO ()

-- | Renders to tmp.csd and tmp.wav and plays with mplayer.
mplayer :: RenderCsd a => a -> IO ()

-- | Renders to tmp.csd and tmp.wav and plays with mplayer.
mplayerBy :: RenderCsd a => Options -> a -> IO ()

-- | Renders to tmp.csd and tmp.wav and plays with totem player.
totem :: RenderCsd a => a -> IO ()

-- | Renders to tmp.csd and tmp.wav and plays with totem player.
totemBy :: RenderCsd a => Options -> a -> IO ()

-- | Renders csound code to file <tt>tmp.csd</tt> with flags set to
--   <tt>-odac</tt> and <tt>-Ma</tt> (sound output goes to soundcard in
--   real time).
dac :: RenderCsd a => a -> IO ()

-- | <a>dac</a> with options.
dacBy :: RenderCsd a => Options -> a -> IO ()

-- | Output to dac with virtual midi keyboard.
vdac :: RenderCsd a => a -> IO ()

-- | Output to dac with virtual midi keyboard with specified options.
vdacBy :: RenderCsd a => Options -> a -> IO ()

-- | Renders to file <tt>tmp.csd</tt> and invokes the csound on it.
csd :: RenderCsd a => a -> IO ()

-- | Renders to file <tt>tmp.csd</tt> and invokes the csound on it.
csdBy :: RenderCsd a => Options -> a -> IO ()
instance RenderCsd (Source (SE Sig4))
instance RenderCsd (Source (SE Sig2))
instance RenderCsd (Source (SE Sig))
instance RenderCsd (Source Sig4)
instance RenderCsd (Source Sig2)
instance RenderCsd (Source Sig)
instance (Sigs a, Sigs b) => RenderCsd (a -> SE b)
instance Sigs a => RenderCsd (a -> (Sig8, Sig8, Sig8, Sig8))
instance Sigs a => RenderCsd (a -> (Sig8, Sig8))
instance Sigs a => RenderCsd (a -> Sig8)
instance Sigs a => RenderCsd (a -> Sig6)
instance Sigs a => RenderCsd (a -> Sig4)
instance Sigs a => RenderCsd (a -> Sig2)
instance Sigs a => RenderCsd (a -> Sig)
instance RenderCsd (SE (Sig8, Sig8, Sig8, Sig8))
instance RenderCsd (SE (Sig8, Sig8))
instance RenderCsd (SE Sig8)
instance RenderCsd (SE Sig6)
instance RenderCsd (SE Sig4)
instance RenderCsd (SE Sig2)
instance RenderCsd (SE Sig)
instance RenderCsd (Sig8, Sig8, Sig8, Sig8)
instance RenderCsd (Sig8, Sig8)
instance RenderCsd Sig8
instance RenderCsd Sig6
instance RenderCsd Sig4
instance RenderCsd Sig2
instance RenderCsd Sig
instance RenderCsd (SE ())


-- | Creating Function Tables (Buffers)
module Csound.Tab

-- | Tables (or arrays)
data Tab :: *

-- | The default table. It's rendered to <tt>(-1)</tt> in the Csound.
noTab :: Tab

-- | nsamp  Returns the number of samples loaded into a stored function
--   table number.
--   
--   <pre>
--   nsamp(x) (init-rate args only)
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/nsamp.html</a>
nsamp :: Tab -> D

-- | Returns a length of the table.
ftlen :: Tab -> D

-- | Returns the sample rate for a table that stores wav files
ftsr :: Tab -> D

-- | Returns the number of channels for a table that stores wav files
ftchnls :: Tab -> D

-- | Returns the base frequency for a table that stores wav files
ftcps :: Tab -> D

-- | Table size fidelity (how many points in the table by default).
data TabFi :: *

-- | Sets different table size for different GEN-routines.
--   
--   <pre>
--   fineFi n ps 
--   </pre>
--   
--   where
--   
--   <ul>
--   <li><tt>n</tt> is the default value for table size (size is a
--   <tt>n</tt> power of 2) for all gen routines that are not listed in the
--   next argument <tt>ps</tt>.</li>
--   <li><tt>ps</tt> is a list of pairs <tt>(genRoutineId,
--   tableSizeDegreeOf2)</tt> that sets the given table size for a given
--   GEN-routine.</li>
--   </ul>
--   
--   with this function we can set lower table sizes for tables that are
--   usually used in the envelopes.
fineFi :: Int -> [(Int, Int)] -> TabFi

-- | Sets the same table size for all tables.
--   
--   <pre>
--   coarseFi n
--   </pre>
--   
--   where <tt>n</tt> is a degree of 2. For example, <tt>n = 10</tt> sets
--   size to 1024 points for all tables by default.
coarseFi :: Int -> TabFi

-- | Table contains all provided values (table is extended to contain all
--   values and to be of the power of 2 or the power of two plus one). (by
--   default it skips normalization).
doubles :: [Double] -> Tab

-- | Creates a new table. The Tab could be used while the instrument is
--   playing. When the instrument is retriggered the new tab is allocated.
--   
--   <pre>
--   newTab size
--   </pre>
newTab :: D -> SE Tab

-- | Creates a new global table. It's generated only once. It's persisted
--   between instrument calls.
--   
--   <pre>
--   newGlobalTab identifier size
--   </pre>
newGlobalTab :: D -> SE Tab

-- | Calculates the number of samples needed to store the given amount of
--   seconds. It multiplies the value by the current sample rate.
tabSizeSeconds :: D -> D

-- | Calculates the closest power of two value for a given size.
tabSizePower2 :: D -> D

-- | Calculates the closest power of two value in samples for a given size
--   in seconds.
tabSizeSecondsPower2 :: D -> D
data WavChn
WavLeft :: WavChn
WavRight :: WavChn
WavAll :: WavChn
data Mp3Chn
Mp3Mono :: Mp3Chn
Mp3Stereo :: Mp3Chn
Mp3Left :: Mp3Chn
Mp3Right :: Mp3Chn
Mp3All :: Mp3Chn

-- | Loads wav or aiff file to table
--   
--   <pre>
--   wavs fileName skipTime channel
--   </pre>
--   
--   skipTime specifies from what second it should read the file.
--   
--   with channel argument we can read left, right or both channels.
wavs :: String -> Double -> WavChn -> Tab

-- | Loads mp3 file to table:
--   
--   <pre>
--   mp3s fileName skipTime format
--   </pre>
--   
--   skipTime specifies from what second it should read the file.
--   
--   format is: 1 - for mono files, 2 - for stereo files, 3 - for left
--   channel of stereo file, 4 for right channel of stereo file
mp3s :: String -> Double -> Mp3Chn -> Tab
type PartialStrength = Double
type PartialNumber = Double
type PartialPhase = Double
type PartialDC = Double

-- | Series of harmonic partials:
--   
--   <pre>
--   sine = sines [1]
--   </pre>
--   
--   <pre>
--   saw = sines $ fmap (1 / ) [1 .. 10]
--   </pre>
--   
--   <pre>
--   square = sines $ fmap (1 / ) [1, 3 .. 11]
--   </pre>
--   
--   <pre>
--   triangle = sines $ zipWith (\a b -&gt; a / (b ** 2)) (cycle [1, -1]) [1, 3 .. 11]
--   </pre>
sines :: [PartialStrength] -> Tab

-- | Specifies series of possibly inharmonic partials.
sines3 :: [(PartialNumber, PartialStrength, PartialPhase)] -> Tab

-- | Just like <a>sines3</a> but phases are set to zero.
sines2 :: [(PartialNumber, PartialStrength)] -> Tab

-- | Just like <a>sines2</a> but partial strength is set to one.
sines1 :: [PartialNumber] -> Tab

-- | Specifies series of possibly inharmonic partials with direct current.
sines4 :: [(PartialNumber, PartialStrength, PartialPhase, PartialDC)] -> Tab

-- | Generates values similar to the opcode <a>buzz</a>.
--   
--   <pre>
--   buzzes numberOfHarmonics [lowestHarmonic, coefficientOfAttenuation]
--   </pre>
--   
--   With <tt>buzzes n [l, r]</tt> you get <tt>n</tt> harmonics from
--   <tt>l</tt> that are attenuated by the factor of <tt>r</tt> on each
--   step.
buzzes :: Double -> [Double] -> Tab

-- | Table for pure sine wave.
sine :: Tab

-- | Table for pure cosine wave.
cosine :: Tab

-- | Table for sigmoid wave.
sigmoid :: Tab

-- | Constant segments (sample and hold).
--   
--   <pre>
--   consts [a, n1, b, n2, c, ...]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>a, b, c .. - are ordinate values</li>
--   <li><tt>n1, n2, ...</tt> are lengths of the segments relative to the
--   total number of the points in the table</li>
--   </ul>
consts :: [Double] -> Tab

-- | Segments of straight lines.
--   
--   <pre>
--   lins [a, n1, b, n2, c, ...]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>a, b, c .. - are ordinate values</li>
--   <li><tt>n1, n2, ...</tt> are lengths of the segments relative to the
--   total number of the points in the table</li>
--   </ul>
lins :: [Double] -> Tab

-- | Segments of cubic polynomials.
--   
--   <pre>
--   cubes [a, n1, b, n2, c, ...]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>a, b, c .. - are ordinate values</li>
--   <li><tt>n1, n2, ...</tt> are lengths of the segments relative to the
--   total number of the points in the table</li>
--   </ul>
cubes :: [Double] -> Tab

-- | Segments of the exponential curves.
--   
--   <pre>
--   exps [a, n1, b, n2, c, ...]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li><tt>a, b, c, ...</tt> are ordinate values</li>
--   <li><tt>n1, n2, ...</tt> are lengths of the segments relative to the
--   total number of the points in the table</li>
--   </ul>
exps :: [Double] -> Tab

-- | Cubic spline curve.
--   
--   <pre>
--   splines [a, n1, b, n2, c, ...]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>a, b, c .. - are ordinate values</li>
--   <li><tt>n1, n2, ...</tt> are lengths of the segments relative to the
--   total number of the points in the table</li>
--   </ul>
splines :: [Double] -> Tab

-- | Creates a table from a starting value to an ending value.
--   
--   <pre>
--   startEnds [val1, dur1, type1, val2, dur2, type2, val3, ... typeX, valN]
--   </pre>
--   
--   <ul>
--   <li>val1, val2 ... -- end points of the segments</li>
--   <li>dur1, dur2 ... -- durations of the segments</li>
--   <li>type1, type2 ... -- if 0, a straight line is produced. If
--   non-zero, then it creates the following curve, for dur steps:</li>
--   </ul>
--   
--   <pre>
--   beg+(end-beg)*(1-exp(i*type))/(1-exp(type * dur))
--   </pre>
--   
--   <ul>
--   <li>beg, end - end points of the segment</li>
--   <li>dur - duration of the segment</li>
--   </ul>
startEnds :: [Double] -> Tab

-- | Equally spaced constant segments.
--   
--   <pre>
--   econsts [a, b, c, ...] 
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   consts [a, 1, b, 1, c, ...]
--   </pre>
econsts :: [Double] -> Tab

-- | Equally spaced segments of straight lines.
--   
--   <pre>
--   elins [a, b, c, ...] 
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   lins [a, 1, b, 1, c, ...]
--   </pre>
elins :: [Double] -> Tab

-- | Equally spaced segments of cubic polynomials.
--   
--   <pre>
--   ecubes [a, b, c, ...] 
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   cubes [a, 1, b, 1, c, ...]
--   </pre>
ecubes :: [Double] -> Tab

-- | Equally spaced segments of exponential curves.
--   
--   <pre>
--   eexps [a, b, c, ...] 
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   exps [a, 1, b, 1, c, ...]
--   </pre>
eexps :: [Double] -> Tab

-- | Equally spaced spline curve.
--   
--   <pre>
--   esplines [a, b, c, ...] 
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   splines [a, 1, b, 1, c, ...]
--   </pre>
esplines :: [Double] -> Tab

-- | Equally spaced interpolation for the function <tt>startEnds</tt>
--   
--   <pre>
--   estartEnds [val1, type1, val2, typ2, ...]
--   </pre>
--   
--   is the same as
--   
--   <pre>
--   estartEnds [val1, 1, type1, val2, 1, type2, ...]
--   </pre>
estartEnds :: [Double] -> Tab

-- | Polynomials.
--   
--   <pre>
--   polys xl xr [c0, c1, c2, ..]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>xl, xr - left and right values of the interval over wich
--   polynomial is defined</li>
--   <li>[c0, c1, c2, ...] -- coefficients of the polynomial</li>
--   </ul>
--   
--   <pre>
--   c0 + c1 * x + c2 * x * x + ...
--   </pre>
polys :: Double -> Double -> [Double] -> Tab

-- | Chebyshev polynomials of the first kind.
--   
--   <pre>
--   polys xl xr [h0, h1, h2, ..]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>xl, xr - left and right values of the interval over wich
--   polynomial is defined</li>
--   <li>[h0, h1, h2, ...] -- relative strength of the partials</li>
--   </ul>
chebs1 :: Double -> Double -> [Double] -> Tab

-- | Chebyshev polynomials of the second kind.
--   
--   <pre>
--   polys xl xr [h0, h1, h2, ..]
--   </pre>
--   
--   where
--   
--   <ul>
--   <li>xl, xr - left and right values of the interval over wich
--   polynomial is defined</li>
--   <li>[h0, h1, h2, ...] -- relative strength of the partials</li>
--   </ul>
chebs2 :: Double -> Double -> [Double] -> Tab

-- | Modified Bessel function of the second kind, order 0 (for amplitude
--   modulated FM).
--   
--   <pre>
--   bessels xint
--   </pre>
--   
--   the function is defined within the interval <tt>[0, xint]</tt>.
bessels :: Double -> Tab
winHamming :: [Double] -> Tab
winHanning :: [Double] -> Tab
winBartlett :: [Double] -> Tab
winBlackman :: [Double] -> Tab
winHarris :: [Double] -> Tab
winGaussian :: [Double] -> Tab
winKaiser :: [Double] -> Tab
winRectangle :: [Double] -> Tab
winSync :: [Double] -> Tab

-- | Creates a table of doubles (It's f-table in Csound). Arguments are:
--   
--   <ul>
--   <li>identificator of the GEN routine</li>
--   <li>GEN routine arguments</li>
--   </ul>
--   
--   All tables are created at 0 and memory is never released.
gen :: Int -> [Double] -> Tab

-- | Skips normalization (sets table size to negative value)
skipNorm :: Tab -> Tab

-- | Force normalization (sets table size to positive value). Might be
--   useful to restore normalization for table <a>doubles</a>.
forceNorm :: Tab -> Tab

-- | Sets an absolute size value. As you can do it in the Csound files.
setSize :: Int -> Tab -> Tab

-- | Sets the relative size value. You can set the base value in the
--   options (see <a>tabResolution</a> at <a>CsdOptions</a>, with
--   tabResolution you can easily change table sizes for all your tables).
--   Here zero means the base value. 1 is the base value multiplied by 2, 2
--   is the base value multiplied by 4 and so on. Negative values mean
--   division by the specified degree.
setDegree :: Int -> Tab -> Tab

-- | Adds guard point to the table size (details of the interpolation
--   schemes: you do need guard point if your intention is to read the
--   table once but you don't need the guard point if you read table in
--   many cycles, the guard point is the the first point of your table).
guardPoint :: Tab -> Tab

-- | Shortcut for <a>guardPoint</a>.
gp :: Tab -> Tab

-- | Sets degrees from -3 to 3.
lllofi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
llofi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
lofi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
midfi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
hifi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
hhifi :: Tab -> Tab

-- | Sets degrees from -3 to 3.
hhhifi :: Tab -> Tab
idWavs :: Int
idMp3s :: Int
idDoubles :: Int
idSines :: Int
idSines3 :: Int
idSines2 :: Int
idPartials :: Int
idSines4 :: Int
idBuzzes :: Int
idConsts :: Int
idLins :: Int
idCubes :: Int
idExps :: Int
idSplines :: Int
idStartEnds :: Int
idPolys :: Int
idChebs1 :: Int
idChebs2 :: Int
idBessels :: Int
idWins :: Int

-- | Writes tables in sequential locations.
--   
--   This opcode writes to a table in sequential locations to and from an
--   a-rate variable. Some thought is required before using it. It has at
--   least two major, and quite different, applications which are discussed
--   below.
--   
--   <pre>
--   kstart tablewa kfn, asig, koff
--   </pre>
--   
--   csound docs: <a>http://www.csounds.com/manual/html/tablewa.html</a>
tablewa :: Tab -> Sig -> Sig -> SE Sig

-- | Transforms phasor that is defined in seconds to relative phasor that
--   ranges in 0 to 1.
sec2rel :: Tab -> Sig -> Sig
instance Show WavChn
instance Eq WavChn
instance Show Mp3Chn
instance Eq Mp3Chn
instance Default Mp3Chn
instance Default WavChn


-- | Basic waveforms that are used most often. A waveform function takes in
--   a time varied frequency (in Hz).
module Csound.Air.Wave

-- | A pure tone (sine wave).
osc :: Sig -> Sig

-- | An oscillator with user provided waveform.
oscBy :: Tab -> Sig -> Sig

-- | A sawtooth.
saw :: Sig -> Sig

-- | Integrated sawtooth: 4 * x * (1 - x).
isaw :: Sig -> Sig

-- | Pulse (not normalized).
pulse :: Sig -> Sig

-- | A square wave.
sqr :: Sig -> Sig

-- | Pulse width modulation (width range is 0 to 1)
--   
--   <pre>
--   pw dutyCycle cps
--   </pre>
pw :: Sig -> Sig -> Sig

-- | A triangle wave.
tri :: Sig -> Sig

-- | Triangle wave with ramp factor (factor's range is 0 to 1)
--   
--   <pre>
--   ramp factor cps
--   </pre>
ramp :: Sig -> Sig -> Sig

-- | A band-limited oscillator with user defined waveform (it's stored in
--   the table).
blosc :: Tab -> Sig -> Sig

-- | Turns a bipolar sound (ranges from -1 to 1) to unipolar (ranges from 0
--   to 1)
unipolar :: Sig -> Sig

-- | Turns an unipolar sound (ranges from 0 to 1) to bipolar (ranges from
--   -1 to 1)
bipolar :: Sig -> Sig

-- | Unipolar pure tone.
uosc :: Sig -> Sig

-- | Unipolar <a>oscBy</a>.
uoscBy :: Tab -> Sig -> Sig

-- | Unipolar sawtooth.
usaw :: Sig -> Sig

-- | Unipolar integrated sawtooth.
uisaw :: Sig -> Sig

-- | Unipolar pulse.
upulse :: Sig -> Sig

-- | Unipolar square wave.
usqr :: Sig -> Sig

-- | Unipolar pulse width modulation wave.
upw :: Sig -> Sig -> Sig

-- | Unipolar triangle wave.
utri :: Sig -> Sig

-- | Unipolar triangle wave with ram factor.
uramp :: Sig -> Sig -> Sig

-- | Unipolar band-limited oscillator.
ublosc :: Tab -> Sig -> Sig

-- | Constant random signal. It updates random numbers with given
--   frequency.
--   
--   <pre>
--   constRnd freq 
--   </pre>
rndh :: Sig -> SE Sig

-- | Unipolar <tt>rndh</tt>
urndh :: Sig -> SE Sig

-- | Linear random signal. It updates random numbers with given frequency.
--   
--   <pre>
--   rndi freq 
--   </pre>
rndi :: Sig -> SE Sig

-- | Unipolar <tt>rndi</tt>
urndi :: Sig -> SE Sig

-- | White noise.
white :: SE Sig

-- | Pink noise.
pink :: SE Sig

-- | Frequency modulation
--   
--   <pre>
--   fosc carrierFreq modulatorFreq modIndex cps
--   </pre>
fosc :: Sig -> Sig -> Sig -> Sig -> Sig

-- | Low frequency oscillator
type Lfo = Sig

-- | Low frequency oscillator
--   
--   <pre>
--   lfo shape depth rate
--   </pre>
lfo :: (Sig -> Sig) -> Sig -> Sig -> Sig


-- | Envelopes
module Csound.Air.Envelope

-- | Linear adsr envelope generator with release
--   
--   <pre>
--   leg attack decay sustain release
--   </pre>
leg :: D -> D -> D -> D -> Sig

-- | Exponential adsr envelope generator with release
--   
--   <pre>
--   xeg attack decay sustain release
--   </pre>
xeg :: D -> D -> D -> D -> Sig

-- | Makes time intervals relative to the note's duration. So that:
--   
--   <pre>
--   onIdur [a, t1, b, t2, c]
--   </pre>
--   
--   becomes:
--   
--   <pre>
--   [a, t1 * idur, b, t2 * idur, c]
--   </pre>
onIdur :: [D] -> [D]

-- | The opcode <a>linseg</a> with time intervals relative to the total
--   duration of the note.
lindur :: [D] -> Sig

-- | The opcode <a>expseg</a> with time intervals relative to the total
--   duration of the note.
expdur :: [D] -> Sig

-- | The opcode <a>linen</a> with time intervals relative to the total
--   duration of the note. Total time is set to the value of idur.
--   
--   <pre>
--   linendur asig rise decay
--   </pre>
linendur :: Sig -> D -> D -> Sig

-- | Makes time intervals relative to the note's duration. So that:
--   
--   <pre>
--   onDur dt [a, t1, b, t2, c]
--   </pre>
--   
--   becomes:
--   
--   <pre>
--   [a, t1 * dt, b, t2 * dt, c]
--   </pre>
onDur :: D -> [D] -> [D]

-- | The opcode <a>linseg</a> with time intervals relative to the total
--   duration of the note given by the user.
lindurBy :: D -> [D] -> Sig

-- | The opcode <a>expseg</a> with time intervals relative to the total
--   duration of the note given by the user.
expdurBy :: D -> [D] -> Sig

-- | The opcode <a>linen</a> with time intervals relative to the total
--   duration of the note. Total time is set to the value of the first
--   argument.
--   
--   <pre>
--   linendurBy dt asig rise decay
--   </pre>
linendurBy :: D -> Sig -> D -> D -> Sig

-- | Fades in with the given attack time.
fadeIn :: D -> Sig

-- | Fades out with the given attack time.
fadeOut :: D -> Sig

-- | A combination of fade in and fade out.
--   
--   <pre>
--   fades attackDuration decayDuration
--   </pre>
fades :: D -> D -> Sig

-- | Fades in by exponent with the given attack time.
expFadeIn :: D -> Sig

-- | Fades out by exponent with the given attack time.
expFadeOut :: D -> Sig

-- | A combination of exponential fade in and fade out.
--   
--   <pre>
--   expFades attackDuration decayDuration
--   </pre>
expFades :: D -> D -> Sig

-- | A function transformer (decorator). We can transform an envelope
--   producer so that all values are sumed with some random value. The
--   amplitude of the random value is given with the first argument.
--   
--   It can transform linseg, expseg, sequence producers and simplified
--   sequence producers.
--   
--   An example:
--   
--   <pre>
--   dac $ mul (humanVal 0.1 sqrSeq [1, 0.5, 0.2, 0.1] 1) $ white
--   </pre>
--   
--   As you can see it transforms the whole function. So we don't need for
--   extra parenthesis.
class HumanizeValue a where type family HumanizeValueOut a :: *
humanVal :: HumanizeValue a => Sig -> a -> HumanizeValueOut a

-- | A function transformer (decorator). We can transform an envelope
--   producer so that all durations are sumed with some random value. The
--   amplitude of the random value is given with the first argument.
--   
--   It can transform linseg, expseg, sequence producers and simplified
--   sequence producers.
--   
--   An example:
--   
--   <pre>
--   dac $ mul (humanTime 0.1 sqrSeq [1, 0.5, 0.2, 0.1] 1) $ white
--   </pre>
--   
--   As you can see it transforms the whole function. So we don't need for
--   extra parenthesis.
class HumanizeTime a where type family HumanizeTimeOut a :: *
humanTime :: HumanizeTime a => Sig -> a -> HumanizeTimeOut a

-- | A function transformer (decorator). We can transform an envelope
--   producer so that all values and durations are sumed with some random
--   value. The amplitude of the random value is given with the first two
--   arguments.
--   
--   It can transform linseg, expseg, sequence producers and simplified
--   sequence producers.
--   
--   An example:
--   
--   <pre>
--   dac $ mul (humanValTime 0.1 0.1 sqrSeq [1, 0.5, 0.2, 0.1] 1) $ white
--   </pre>
--   
--   As you can see it transforms the whole function. So we don't need for
--   extra parenthesis.
class HumanizeValueTime a where type family HumanizeValueTimeOut a :: *
humanValTime :: HumanizeValueTime a => Sig -> Sig -> a -> HumanizeValueTimeOut a

-- | Alias for <tt>humanVal</tt>.
hval :: HumanizeValue a => Sig -> a -> HumanizeValueOut a

-- | Alias for <tt>humanTime</tt>.
htime :: HumanizeTime a => Sig -> a -> HumanizeTimeOut a

-- | Alias for <tt>humanValTime</tt>.
hvalTime :: HumanizeValueTime a => Sig -> Sig -> a -> HumanizeValueTimeOut a

-- | Looping sample and hold envelope. The first argument is the list of
--   pairs:
--   
--   <pre>
--   [a, durA, b, durB, c, durc, ...]
--   </pre>
--   
--   It's a list of values and durations. The durations are relative to the
--   period of repetition. The period is specified with the second
--   argument. The second argument is the frequency of repetition measured
--   in Hz.
--   
--   <pre>
--   lpshold valDurs frequency
--   </pre>
lpshold :: [Sig] -> Sig -> Sig

-- | Looping linear segments envelope. The first argument is the list of
--   pairs:
--   
--   <pre>
--   [a, durA, b, durB, c, durc, ...]
--   </pre>
--   
--   It's a list of values and durations. The durations are relative to the
--   period of repetition. The period is specified with the second
--   argument. The second argument is the frequency of repetition measured
--   in Hz.
--   
--   <pre>
--   loopseg valDurs frequency
--   </pre>
loopseg :: [Sig] -> Sig -> Sig

-- | Looping exponential segments envelope. The first argument is the list
--   of pairs:
--   
--   <pre>
--   [a, durA, b, durB, c, durc, ...]
--   </pre>
--   
--   It's a list of values and durations. The durations are relative to the
--   period of repetition. The period is specified with the second
--   argument. The second argument is the frequency of repetition measured
--   in Hz.
--   
--   <pre>
--   loopxseg valDurs frequency
--   </pre>
loopxseg :: [Sig] -> Sig -> Sig

-- | It's like lpshold but we can specify the phase of repetition (phase
--   belongs to [0, 1]).
lpsholdBy :: D -> [Sig] -> Sig -> Sig

-- | It's like loopseg but we can specify the phase of repetition (phase
--   belongs to [0, 1]).
loopsegBy :: D -> [Sig] -> Sig -> Sig

-- | It's like loopxseg but we can specify the phase of repetition (phase
--   belongs to [0, 1]).
loopxsegBy :: D -> [Sig] -> Sig -> Sig

-- | The looping sequence of constant segments.
--   
--   <pre>
--   linSeg [a, durA, b, durB, c, durC, ...] [scale1, scale2, scale3] cps
--   </pre>
--   
--   The first argument is the list that specifies the shape of the looping
--   wave. It's the alternating values and durations of transition from one
--   value to another. The durations are relative to the period. So that
--   lists
--   
--   <pre>
--   [0, 0.5, 1, 0.5, 0]  and [0, 50, 1, 50, 0]
--   </pre>
--   
--   produce the same results. The second list is the list of scales for
--   subsequent periods. Every value in the period is scaled with values
--   from the second list. The last argument is the rate of repetition
--   (Hz).
holdSeq :: [Sig] -> [Sig] -> Sig -> Sig

-- | The looping sequence of linear segments.
--   
--   <pre>
--   linSeg [a, durA, b, durB, c, durC, ...] [scale1, scale2, scale3] cps
--   </pre>
--   
--   The first argument is the list that specifies the shape of the looping
--   wave. It's the alternating values and durations of transition from one
--   value to another. The durations are relative to the period. So that
--   lists
--   
--   <pre>
--   [0, 0.5, 1, 0.5, 0]  and [0, 50, 1, 50, 0]
--   </pre>
--   
--   produce the same results. The second list is the list of scales for
--   subsequent periods. Every value in the period is scaled with values
--   from the second list. The last argument is the rate of repetition
--   (Hz).
linSeq :: [Sig] -> [Sig] -> Sig -> Sig

-- | The looping sequence of exponential segments.
--   
--   <pre>
--   expSeg [a, durA, b, durB, c, durC, ...] [scale1, scale2, scale3] cps
--   </pre>
--   
--   The first argument is the list that specifies the shape of the looping
--   wave. It's the alternating values and durations of transition from one
--   value to another. The durations are relative to the period. So that
--   lists
--   
--   <pre>
--   [0, 0.5, 1, 0.5, 0]  and [0, 50, 1, 50, 0]
--   </pre>
--   
--   produce the same results. The second list is the list of scales for
--   subsequent periods. Every value in the period is scaled with values
--   from the second list. The last argument is the rate of repetition
--   (Hz).
expSeq :: [Sig] -> [Sig] -> Sig -> Sig

-- | It's just like <tt>linseg</tt> but it loops over the envelope.
linloop :: [Sig] -> Sig

-- | It's just like <tt>expseg</tt> but it loops over the envelope.
exploop :: [Sig] -> Sig

-- | Sample and hold cyclic signal. It takes the list of
--   
--   <pre>
--   [a, dta, b, dtb, c, dtc, ...]
--   </pre>
--   
--   the a, b, c, ... are values of the constant segments
--   
--   the dta, dtb, dtc, are durations in seconds of constant segments.
--   
--   The period of the repetition equals to the sum of all durations.
sah :: [Sig] -> Sig
stepSeq :: [Sig] -> Sig -> Sig

-- | Sample and hold sequence. It outputs the looping sequence of constan
--   elements.
constSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar triangle.
triSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar square.
sqrSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar sawtooth.
sawSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar inveted sawtooth.
isawSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar exponential sawtooth.
xsawSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar inverted exponential sawtooth.
ixsawSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar inveted square.
isqrSeq :: [Sig] -> Sig -> Sig

-- | Step sequencer with unipolar exponential triangle.
xtriSeq :: [Sig] -> Sig -> Sig

-- | A sequence of unipolar waves with pulse width moulation (see upw). The
--   first argument is a duty cycle in range 0 to 1.
pwSeq :: Sig -> [Sig] -> Sig -> Sig

-- | A sequence of unipolar inverted waves with pulse width moulation (see
--   upw). The first argument is a duty cycle in range 0 to 1.
ipwSeq :: Sig -> [Sig] -> Sig -> Sig

-- | A sequence of unipolar triangle waves with ramp factor (see uramp).
--   The first argument is a ramp factor cycle in range 0 to 1.
rampSeq :: Sig -> [Sig] -> Sig -> Sig

-- | A sequence of unipolar inverted triangle waves with ramp factor (see
--   uramp). The first argument is a ramp factor cycle in range 0 to 1.
irampSeq :: Sig -> [Sig] -> Sig -> Sig

-- | A sequence of unipolar exponential triangle waves with ramp factor
--   (see uramp). The first argument is a ramp factor cycle in range 0 to
--   1.
xrampSeq :: Sig -> [Sig] -> Sig -> Sig

-- | A sequence of unipolar inverted exponential triangle waves with ramp
--   factor (see uramp). The first argument is a ramp factor cycle in range
--   0 to 1.
ixrampSeq :: Sig -> [Sig] -> Sig -> Sig

-- | The looping ADSR envelope.
--   
--   <pre>
--   xadsrSeq attack decay sustain release weights frequency
--   </pre>
--   
--   The sum of attack, decay, sustain and release time durations should be
--   equal to one.
adsrSeq :: Sig -> Sig -> Sig -> Sig -> [Sig] -> Sig -> Sig

-- | The looping exponential ADSR envelope. there is a fifth segment at the
--   end of the envelope during which the envelope equals to zero.
--   
--   <pre>
--   xadsrSeq attack decay sustain release weights frequency
--   </pre>
--   
--   The sum of attack, decay, sustain and release time durations should be
--   equal to one.
xadsrSeq :: Sig -> Sig -> Sig -> Sig -> [Sig] -> Sig -> Sig

-- | The looping ADSR envelope with the rest at the end.
--   
--   <pre>
--   adsrSeq attack decay sustain release rest weights frequency
--   </pre>
--   
--   The sum of attack, decay, sustain, release and rest time durations
--   should be equal to one.
adsrSeq_ :: Sig -> Sig -> Sig -> Sig -> Sig -> [Sig] -> Sig -> Sig

-- | The looping exponential ADSR envelope. there is a fifth segment at the
--   end of the envelope during which the envelope equals to zero.
--   
--   <pre>
--   xadsrSeq_ attack decay sustain release rest weights frequency
--   </pre>
--   
--   The sum of attack, decay, sustain, release and rest time durations
--   should be equal to one.
xadsrSeq_ :: Sig -> Sig -> Sig -> Sig -> Sig -> [Sig] -> Sig -> Sig

-- | The seq is a type for step sequencers. The step sequencer is a
--   monophonic control signal. Most often step sequencer is a looping
--   segment of some values. It's used to create bas lines or conrtrol the
--   frequency of the filter in dub or trance music. There are simple
--   functions for creation of step sequencers defined in the module
--   <a>Csound.Air.Envelope</a>.
--   
--   Basically the step sequence is a list of pairs:
--   
--   <pre>
--   [(valA, durA), (valB, durB), (valC, durC)]
--   </pre>
--   
--   each pair defines a segment of height valN that lasts for durN. The
--   sequence is repeated with the given frequency. Each segment has
--   certain shape. It can be a constant or line segment or fragment of
--   square wave or fragment of an adsr envelope. There are many predefined
--   functions.
--   
--   With Seq we can construct control signals in very flexible way. We can
--   use the score composition functions for creation of sequences. We can
--   use <tt>mel</tt> for sequencing of individual steps, we can use
--   <tt>str</tt> for stretching the sequence in time domain, we can delay
--   with <tt>del</tt>.
--   
--   Here is an example:
--   
--   <pre>
--   dac $ tri $ seqConst [str 0.25 $ mel [440, 220, 330, 220], 110] 1
--   </pre>
--   
--   We can see how the function <tt>str</tt> was used to make a certain
--   segment faster. There are numerical instaces for Seq. Bt it defines
--   only functions <tt>fronInteger</tt> and <tt>fromRational</tt>.
data Seq

-- | Creates a
toSeq :: Sig -> Seq

-- | Squashes a sequence to a single beat.
onBeat :: Seq -> Seq

-- | Squashes a sequence to a single beat and then stretches to the given
--   value.
onBeats :: Sig -> Seq -> Seq

-- | A sequence of constant segments.
seqConst :: [Seq] -> Sig -> Sig

-- | A linear sequence.
seqLin :: [Seq] -> Sig -> Sig

-- | An exponential sequence.
seqExp :: [Seq] -> Sig -> Sig

-- | The sequence of pulse width waves. The first argument is a duty cycle
--   (ranges from 0 to 1).
seqPw :: Sig -> [Seq] -> Sig -> Sig

-- | The sequence of inversed pulse width waves.
iseqPw :: Sig -> [Seq] -> Sig -> Sig

-- | The sequence of square waves.
seqSqr :: [Seq] -> Sig -> Sig

-- | The sequence of inversed square waves.
iseqSqr :: [Seq] -> Sig -> Sig

-- | The sequence of sawtooth waves.
seqSaw :: [Seq] -> Sig -> Sig

-- | The sequence of inversed sawtooth waves.
iseqSaw :: [Seq] -> Sig -> Sig

-- | The sequence of exponential sawtooth waves.
xseqSaw :: [Seq] -> Sig -> Sig

-- | The sequence of inversed exponential sawtooth waves.
ixseqSaw :: [Seq] -> Sig -> Sig

-- | The sequence of ramp functions. The first argument is a duty cycle.
seqRamp :: Sig -> [Seq] -> Sig -> Sig

-- | The sequence of inversed ramp functions. The first argument is a duty
--   cycle.
iseqRamp :: Sig -> [Seq] -> Sig -> Sig

-- | The sequence of triangular waves.
seqTri :: [Seq] -> Sig -> Sig

-- | The sequence of ramped triangular waves.
seqTriRamp :: Sig -> [Seq] -> Sig -> Sig

-- | The sequence of ADSR-envelopes.
--   
--   <pre>
--   seqAdsr att dec sus rel
--   </pre>
--   
--   It has to be:
--   
--   <pre>
--   att + dec + sus_time + rel == 1
--   </pre>
seqAdsr :: Sig -> Sig -> Sig -> Sig -> [Seq] -> Sig -> Sig

-- | The sequence of exponential ADSR-envelopes.
xseqAdsr :: Sig -> Sig -> Sig -> Sig -> [Seq] -> Sig -> Sig

-- | The sequence of ADSR-envelopes with rest at the end.
--   
--   <pre>
--   seqAdsr att dec sus rel rest
--   </pre>
--   
--   It has to be:
--   
--   <pre>
--   att + dec + sus_time + rel + rest == 1
--   </pre>
seqAdsr_ :: Sig -> Sig -> Sig -> Sig -> Sig -> [Seq] -> Sig -> Sig

-- | The sequence of exponential ADSR-envelopes with rest at the end.
xseqAdsr_ :: Sig -> Sig -> Sig -> Sig -> Sig -> [Seq] -> Sig -> Sig

-- | Function for creation of accented beats. The steady beat pattern of
--   accents is repeated. The first argument describes the list of
--   integers. Each integer is a main beat and the length of the beat. We
--   can create a typical latino beat:
--   
--   <pre>
--   dac $ mul (seqSaw [seqPat [3, 3, 2]] 1) white
--   </pre>
seqPat :: [Int] -> Seq

-- | It's like <tt>seqPat</tt> but inplace of rests it fills the gaps with
--   segments ascending in value.
--   
--   <pre>
--   dac $ mul (seqSaw [seqAsc [3, 3, 2]] 1) white
--   </pre>
seqAsc :: [Int] -> Seq

-- | It's like <tt>seqPat</tt> but inplace of rests it fills the gaps with
--   segments descending in value.
--   
--   <pre>
--   dac $ mul (seqSaw [seqDesc [3, 3, 2]] 1) white
--   </pre>
seqDesc :: [Int] -> Seq

-- | It's like <tt>seqPat</tt> but inplace of rests it fills the gaps with
--   0.5s.
--   
--   <pre>
--   dac $ mul (seqSaw [seqHalf [3, 3, 2]] 1) white
--   </pre>
seqHalf :: [Int] -> Seq
instance HumanizeValueTime ([D] -> D -> Sig)
instance HumanizeValueTime ([D] -> Sig)
instance HumanizeValueTime ([Seq] -> Sig -> Sig)
instance HumanizeTime ([D] -> D -> Sig)
instance HumanizeTime ([D] -> Sig)
instance HumanizeTime ([Seq] -> Sig -> Sig)
instance HumanizeValue ([D] -> D -> Sig)
instance HumanizeValue ([D] -> Sig)
instance HumanizeValue ([Sig] -> Sig -> Sig)
instance HumanizeValue ([Seq] -> Sig -> Sig)
instance Fractional Seq
instance Num Seq
instance Stretch Seq
instance Melody Seq
instance Delay Seq
instance Rest Seq
instance Duration Seq


-- | Patterns
module Csound.Air.Misc

-- | Mean value.
mean :: Fractional a => [a] -> a

-- | Adds vibrato to the sound unit. Sound units is a function that takes
--   in a frequency.
vibrate :: Sig -> Sig -> (Sig -> a) -> (Sig -> a)

-- | Adds a random vibrato to the sound unit. Sound units is a function
--   that takes in a frequency.
randomPitch :: Sig -> Sig -> (Sig -> a) -> (Sig -> SE a)

-- | Chorus takes a number of copies, chorus width and wave shape.
chorusPitch :: Int -> Sig -> (Sig -> Sig) -> Sig -> Sig

-- | Applies a resonator to the signals. A resonator is a list of band pass
--   filters. A list contains the parameters for the filters:
--   
--   <pre>
--   [(centerFrequency, bandWidth)]
--   </pre>
resons :: [(Sig, Sig)] -> Sig -> Sig

-- | A resonator with user defined band pass filter. Warning: a filter
--   takes in a center frequency, band width and the signal. The signal
--   comes last (this order is not standard in the Csound but it's more
--   convinient to use with Haskell).
resonsBy :: (cps -> bw -> Sig -> Sig) -> [(cps, bw)] -> Sig -> Sig

-- | Chain of mass-spring-damping filters.
--   
--   <pre>
--   modes params baseCps exciter 
--   </pre>
--   
--   <ul>
--   <li>params - a list of pairs <tt>(resonantFrequencyRatio,
--   filterQuality)</tt></li>
--   <li><tt>baseCps</tt> - base frequency of the resonator</li>
--   <li>exciter - an impulse that starts a resonator.</li>
--   </ul>
modes :: [(Sig, Sig)] -> Sig -> Sig -> Sig

-- | Mixes dry and wet signals.
--   
--   <pre>
--   dryWet ratio effect asig
--   </pre>
--   
--   <ul>
--   <li><tt>ratio</tt> - of dry signal to wet</li>
--   <li><tt>effect</tt> - means to wet the signal</li>
--   <li><tt>asig</tt> -- processed signal</li>
--   </ul>
dryWet :: Sig -> (Sig -> Sig) -> Sig -> Sig

-- | Reads table once during the note length.
once :: Tab -> Sig

-- | Reads table once during a given period of time.
onceBy :: D -> Tab -> Sig

-- | Reads table several times during the note length.
several :: Tab -> Sig -> Sig

-- | Doubles the mono signal to get the stereo signal.
fromMono :: Sig -> (Sig, Sig)

-- | Selects odd elements from the list.
odds :: [a] -> [a]

-- | Selects even elements from the list.
evens :: [a] -> [a]

-- | Random panning
rndPan :: Sig -> SE Sig2

-- | Random panning
rndPan2 :: Sig2 -> SE Sig2

-- | Random volume
--   
--   <pre>
--   gaussVol (minVolume, maxVolume)
--   </pre>
rndVol :: SigSpace a => (D, D) -> a -> SE a

-- | Random volume (with gauss distribution)
--   
--   <pre>
--   gaussVol radiusOfDistribution
--   </pre>
gaussVol :: SigSpace a => D -> a -> SE a

-- | It picks a signal from the list by integer index. The original value
--   is taken from the head of the list (the first element).
selector :: (Num a, SigSpace a) => [a] -> Sig -> a

-- | Hi-fi output for stereo signals. Saves the stereo signal to file. The
--   length of the file is defined in seconds.
--   
--   <pre>
--   writeHifi fileLength fileName asig
--   </pre>
writeHifi :: D -> String -> SE Sig2 -> IO ()

-- | Creates running arpeggios.
--   
--   <pre>
--   arpeggiBy ampWeights pitches instrument cps
--   </pre>
--   
--   It plays an instrument with fast sequence of notes. We can specify the
--   pitches and amplitude weights of the notes as well as frequency of
--   repetition.
arpeggi :: SigSpace a => [Sig] -> [Sig] -> (Sig -> a) -> Sig -> a

-- | Creates running arpeggios.
--   
--   <pre>
--   arpeggiBy ampWave pitchwave ampWeights pitches instrument cps
--   </pre>
--   
--   It plays an instrument with fast sequence of notes. We can specify
--   amplitude envelope wave, pitch envelope wave, the pitches and
--   amplitude weights of the notes as well as frequency of repetition.
arpBy :: SigSpace a => ([Sig] -> Sig -> Sig) -> ([Sig] -> Sig -> Sig) -> [Sig] -> [Sig] -> (Sig -> a) -> Sig -> a

-- | Low-pass filter pictured as joystick. Ox is for center frequency and
--   Oy is for resonance.
lpJoy :: Source (Sig -> Sig)

-- | Delay a signal by certain number of seconds There is a subtle
--   difference between the function and the function <tt>delaySnd</tt>.
--   The <tt>delaySig</tt> is for delaying a signal on a micro level (the
--   delay time have to be small) It's implemented with delay buffer in the
--   csound. But <tt>delaySnd</tt> is for delaying on macro level (the
--   delay time can be big). It's implemented with scores and invocation of
--   hidden instruments.
--   
--   <pre>
--   delaySig numOfSamples asig
--   </pre>
delaySig :: D -> Sig -> Sig

-- | Chains all functions in the list.
funSeq :: [a -> a] -> a -> a

-- | Applies all functions in the list to the given input and summs them
--   up.
funPar :: Num a => [a -> a] -> a -> a


-- | Spectral functions
module Csound.Air.Spec

-- | Converts signal to spectrum.
toSpec :: Sig -> Spec

-- | Converts spectrum to signal.
fromSpec :: Spec -> Sig

-- | Applies a transformation to the spectrum of the signal.
mapSpec :: (Spec -> Spec) -> Sig -> Sig

-- | Scales all frequencies. Usefull for transposition. For example, we can
--   transpose a signal by the given amount of semitones:
--   
--   <pre>
--   scaleSpec (semitone 1) asig
--   </pre>
scaleSpec :: Sig -> Sig -> Sig

-- | Adds given amount of Hz to all frequencies.
--   
--   <pre>
--   addSpec hz asig
--   </pre>
addSpec :: Sig -> Sig -> Sig

-- | Scales frequency in semitones.
scalePitch :: Sig -> Sig -> Sig

-- | Settings for cross filtering algorithm.
--   
--   They are the defaults for opvodes: <tt>pvsifd</tt>, <tt>tradsyn</tt>,
--   <tt>trcross</tt> and <tt>partials</tt>.
--   
--   <ul>
--   <li>Fft size degree -- it's the power of 2. The default is 12.</li>
--   <li>Hop size degree -- it's the power of 2. The default is 9</li>
--   <li>scale --amplitude scaling factor. default is 1</li>
--   <li>pitch -- the pitch scaling factor. default is 1</li>
--   <li><tt>maxTracks</tt> -- max number of tracks in resynthesis
--   (tradsyn) and analysis (partials).</li>
--   <li><tt>winType</tt> -- O: Hamming, 1: Hanning (default)</li>
--   <li><tt>Search</tt> -- search interval length. The default is
--   1.05</li>
--   <li><tt>Depth</tt> -- depth of the effect</li>
--   <li><tt>Thresh</tt> -- analysis threshold. Tracks below
--   ktresh*max_magnitude will be discarded (1 &gt; ktresh &gt;= 0).The
--   default is 0.01</li>
--   <li><tt>MinPoints</tt> -- minimum number of time points for a detected
--   peak to make a track (1 is the minimum).</li>
--   <li><tt>MaxGap</tt> -- maximum gap between time-points for track
--   continuation (&gt; 0). Tracks that have no continuation after kmaxgap
--   will be discarded.</li>
--   </ul>
data CrossSpec
CrossSpec :: D -> D -> Sig -> Sig -> D -> D -> Sig -> Sig -> Sig -> Sig -> Sig -> CrossSpec
crossFft :: CrossSpec -> D
crossHopSize :: CrossSpec -> D
crossScale :: CrossSpec -> Sig
crossPitch :: CrossSpec -> Sig
crossMaxTracks :: CrossSpec -> D
crossWinType :: CrossSpec -> D
crossSearch :: CrossSpec -> Sig
crossDepth :: CrossSpec -> Sig
crossThresh :: CrossSpec -> Sig
crossMinPoints :: CrossSpec -> Sig
crossMaxGap :: CrossSpec -> Sig

-- | Filters the partials of the second signal with partials of the first
--   signal.
crossSpecFilter :: CrossSpec -> Sig2 -> Sig2 -> Sig2

-- | Substitutes the partials of the second signal with partials of the
--   first signal.
crossSpecVocoder :: CrossSpec -> Sig2 -> Sig2 -> Sig2

-- | <tt>crossSpecFilter</tt> for mono signals.
crossSpecFilter1 :: CrossSpec -> Sig -> Sig -> Sig

-- | <tt>crossSpecVocoder</tt> for mono signals.
crossSpecVocoder1 :: CrossSpec -> Sig -> Sig -> Sig
instance Default CrossSpec


-- | Sound file playback
module Csound.Air.Wav

-- | Reads stereo signal from the sound-file (wav or mp3 or aiff).
readSnd :: String -> (Sig, Sig)

-- | Reads stereo signal from the sound-file (wav or mp3 or aiff) and loops
--   it with the file length.
loopSnd :: String -> (Sig, Sig)

-- | Reads stereo signal from the sound-file (wav or mp3 or aiff) and loops
--   it with the given period (in seconds).
loopSndBy :: D -> String -> (Sig, Sig)

-- | Reads the wav file with the given speed (if speed is 1 it's a norma
--   playback). We can use negative speed to read file in reverse.
readWav :: Sig -> String -> (Sig, Sig)

-- | Reads th wav file and loops over it.
loopWav :: Sig -> String -> (Sig, Sig)

-- | Reads a segment from wav file.
readSegWav :: D -> D -> Sig -> String -> (Sig, Sig)

-- | Reads th wav file and loops over it. Scales the tempo with first
--   argument.
tempoLoopWav :: Sig -> String -> (Sig, Sig)

-- | Reads the wav file with the given speed (if speed is 1 it's a norma
--   playback). We can use negative speed to read file in reverse. Scales
--   the tempo with first argument.
tempoReadWav :: Sig -> String -> (Sig, Sig)

-- | The mono variant of the function <tt>readSnd</tt>.
readSnd1 :: String -> Sig

-- | The mono variant of the function <tt>loopSnd</tt>.
loopSnd1 :: String -> Sig

-- | The mono variant of the function <tt>loopSndBy</tt>.
loopSndBy1 :: D -> String -> Sig

-- | The mono variant of the function <tt>readWav</tt>.
readWav1 :: Sig -> String -> Sig

-- | The mono variant of the function <tt>loopWav</tt>.
loopWav1 :: Sig -> String -> Sig

-- | Reads a segment from wav file.
readSegWav1 :: D -> D -> Sig -> String -> Sig

-- | Reads th mono wav file and loops over it. Scales the tempo with first
--   argument.
tempoLoopWav1 :: Sig -> String -> Sig

-- | Reads the mono wav file with the given speed (if speed is 1 it's a
--   norma playback). We can use negative speed to read file in reverse.
--   Scales the tempo with first argument.
tempoReadWav1 :: Sig -> String -> Sig
data LoopMode
Once :: LoopMode
Loop :: LoopMode
Bounce :: LoopMode

-- | Loads the sample in the table. The sample should be short. The size of
--   the table is limited. It's up to 3 minutes for 44100 sample rate (sr),
--   2.9 minutes for 48000 sr, 1.4 minutes for 96000 sr.
ramSnd :: LoopMode -> Sig -> String -> Sig2

-- | Loads the sample in the table. The sample should be short. The size of
--   the table is limited. It's up to 6 minutes for 44100 sample rate (sr),
--   5.9 minutes for 48000 sr, 2.8 minutes for 96000 sr.
ramSnd1 :: LoopMode -> Sig -> String -> Sig

-- | Mincer. We can playback a table and scale by tempo and pitch.
--   
--   <pre>
--   mincer fidelity table pointer pitch 
--   </pre>
--   
--   fidelity is the parameter that specifies the size of the window (for
--   FFT transform). The size equals to formula (fidelity + 11) ^ 2. If you
--   don't know what to choose choose 0 for pitched sounds and -2 for
--   drums. The table contains the sample to playback. The pointer loops
--   over the table. The pitch specifies a scaling factor for pitch. So we
--   can raise tone an octave up by setting the pitch to 2.
ramTab :: Fidelity -> Tab -> Sig -> Sig -> Sig

-- | mincer  Phase-locked vocoder processing.
--   
--   mincer implements phase-locked vocoder processing using function
--   tables containing sampled-sound sources, with GEN01, and mincer will
--   accept deferred allocation tables.
--   
--   This opcode allows for time and frequency-independent scaling. Time is
--   controlled by a time index (in seconds) to the function table position
--   and can be moved forward and backward at any chosen speed, as well as
--   stopped at a given position ("frozen"). The quality of the effect is
--   generally improved with phase locking switched on.
--   
--   <pre>
--   asig mincer atimpt, kamp, kpitch, ktab, klock[,ifftsize,idecim]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/mincer.html</a>
mincer :: Sig -> Sig -> Sig -> Tab -> Sig -> Sig

-- | Looping phasor. It creates a looping pointer to the file. It's used in
--   the function ram.
--   
--   Ther arguments are: file name, start and end of the looping segment
--   (in seconds), and the playback speed.
data Phsr
Phsr :: String -> Sig -> Sig -> Sig -> Phsr
phsrFile :: Phsr -> String
phsrStart :: Phsr -> Sig
phsrEnd :: Phsr -> Sig
phsrSpeed :: Phsr -> Sig

-- | Creates a pointer signal for reading audio from the table in loops.
--   
--   <pre>
--   lphase length start end speed
--   </pre>
--   
--   Arguments are:
--   
--   <ul>
--   <li>length of the table in seconds</li>
--   <li>start and end points of the reading interval</li>
--   <li>playback speed</li>
--   </ul>
lphase :: D -> Sig -> Sig -> Sig -> Sig

-- | Creates a phasor if segments are relative to the total length. It can
--   be useful for drum loops. If we don't know the complete length but we
--   know that loop contains four distinct parts.
relPhsr :: String -> Sig -> Sig -> Sig -> Phsr

-- | Creates a phasor for reading the whole audio file in loops with given
--   speed.
sndPhsr :: String -> Sig -> Phsr

-- | Reads the file forth and back.
phsrBounce :: Phsr -> Phsr

-- | Forces phasor to play only once.
phsrOnce :: Phsr -> Phsr

-- | Reads audio files in loops. The file is loaded in RAM. The size of the
--   file is limited. It should be not more than 6 minutes for sample rate
--   of 44100. 5.9 minutes for 48000.
--   
--   What makes this function so cool is that we can scale the sound by
--   tempo without affecting pitch, and we can scale the sound by pitch
--   without affecting the tempo. Let's study the arguments.
--   
--   <pre>
--   ram fidelity phasor pitch 
--   </pre>
--   
--   fidelity corresponds to the size of the FFT-window. The function
--   performs the FFT transform and it has to know the size. It's not the
--   value for the size it's an integer value that proportional to the
--   size. The higher the value the higher the size the lower the value the
--   lower the size. The default value is 0. Zero is best for most of the
--   cases. For drums we can lower it to (-2).
--   
--   The phasor is a quadruple of values
--   
--   <pre>
--   (Phsr fileName startTime endTime playbackSpeed)
--   </pre>
--   
--   we can read the file from startTime to endTime (in seconds) and we can
--   set the speed for playback. If speed is negative file is played in
--   reverse. The playback is looped. So to scale the tempo or play in
--   reverse we can change the playbackSpeed.
--   
--   The last argument is pitch factor. We can rise by octave with factor
--   2. It's good place to use the function semitone. It produces factors
--   for a number in semitones.
--   
--   Note that all parameters (except window size) are signals. It makes
--   this function very flexible. We can change the speed of playback and
--   start and end of the reading segment as we wish.
--   
--   <pre>
--   ram 0 (Phsr "file.wav" 0 1 1.2) 1
--   </pre>
--   
--   PS: here is the formula for window size: 2 ** (fidelity + 11)
ram :: Fidelity -> Phsr -> Sig -> Sig2
ram1 :: Fidelity -> Phsr -> Sig -> Sig

-- | Fidelity corresponds to the size of the FFT-window that is used by
--   functions of RAM-family. The function performs the FFT transform and
--   it has to know the size. It's not the value for the size it's an
--   integer value that proportional to the size. The higher the value the
--   higher the size the lower the value the lower the size. The default
--   value is 0. Zero is best for most of the cases. For drums we can lower
--   it to (-2).
--   
--   PS: here is the formula for window size: 2 ** (fidelity + 11). So the
--   fidelity is actually the degree for power of two. The FFT-algorithm
--   requires the window size to be a power of two.
--   
--   The lower fidelity is the less power is consumed by the function.
type Fidelity = D

-- | Scaling factor for tempo. The 1 is inherent tempo.
type TempoSig = Sig

-- | Scaling factor for pitch. The 1 is inherent pitch.
type PitchSig = Sig

-- | Reads file once and scales it by tempo and pitch.
readRam :: Fidelity -> TempoSig -> PitchSig -> String -> Sig2

-- | Loop over file and scales it by tempo and pitch.
loopRam :: Fidelity -> TempoSig -> PitchSig -> String -> Sig2

-- | Reads a segment from file once and scales it by tempo and pitch.
--   Segment is defined in seconds.
readSeg :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig2

-- | Loops over a segment of file and scales it by tempo and pitch. Segment
--   is defined in seconds.
loopSeg :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig2

-- | Reads a relative segment from file once and scales it by tempo and
--   pitch. Segment is defined in seconds. The end ponits for the segment
--   are relative to the total length of the file.
readRel :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig2

-- | Loops over a relative segment of file and scales it by tempo and
--   pitch. Segment is defined in seconds. The end ponits for the segment
--   are relative to the total length of the file.
loopRel :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig2

-- | The mono version of readRam.
readRam1 :: Fidelity -> TempoSig -> PitchSig -> String -> Sig

-- | The mono version of loopRam.
loopRam1 :: Fidelity -> TempoSig -> PitchSig -> String -> Sig

-- | The mono version of readSeg.
readSeg1 :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig

-- | The mono version of loopSeg.
loopSeg1 :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig

-- | The mono version of readRel.
readRel1 :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig

-- | The mono version of loopRel.
loopRel1 :: Fidelity -> (Sig, Sig) -> TempoSig -> PitchSig -> String -> Sig

-- | The sample format.
data SampleFormat

-- | 32-bit floating point samples without header
NoHeaderFloat32 :: SampleFormat

-- | 16-bit integers without header
NoHeaderInt16 :: SampleFormat

-- | 16-bit integers with a header. The header type depends on the render
--   (-o) format
HeaderInt16 :: SampleFormat

-- | u-law samples with a header
UlawSamples :: SampleFormat

-- | 16-bit integers with a header
Int16 :: SampleFormat

-- | 32-bit integers with a header
Int32 :: SampleFormat

-- | 32-bit floats with a header
Float32 :: SampleFormat

-- | 8-bit unsigned integers with a header
Uint8 :: SampleFormat

-- | 24-bit integers with a header
Int24 :: SampleFormat

-- | 64-bit floats with a header
Float64 :: SampleFormat

-- | Writes a sound signal to the file with the given format. It supports
--   only four formats: Wav, Aiff, Raw and Ircam.
writeSigs :: FormatType -> SampleFormat -> String -> [Sig] -> SE ()

-- | Writes wav files.
writeWav :: String -> (Sig, Sig) -> SE ()

-- | Writes aiff files.
writeAiff :: String -> (Sig, Sig) -> SE ()

-- | Writes mono signals to wav files.
writeWav1 :: String -> Sig -> SE ()

-- | Writes mono signals to aiff files.
writeAiff1 :: String -> Sig -> SE ()

-- | Length in seconds of the sound file.
lengthSnd :: String -> D

-- | Produces repeating segments with the given time in seconds.
segments :: D -> Evt (Sco Unit)

-- | Takes only given amount (in seconds) from the signal (the rest is
--   silence).
takeSnd :: Sigs a => D -> a -> a

-- | Delays signals by the given amount (in seconds).
delaySnd :: Sigs a => D -> a -> a

-- | Plays the first signal for some time (in seconds) and then switches to
--   the next one.
--   
--   <pre>
--   afterSnd dur sig1 sig2
--   </pre>
afterSnd :: (Num b, Sigs b) => D -> b -> b -> b

-- | Creates a sequence of signals. Each segment lasts for fixed amount of
--   time given in the first argument.
lineSnd :: (Num a, Sigs a) => D -> [a] -> a

-- | Creates a sequence of signals and loops over the sequence. Each
--   segment lasts for fixed amount of time given in the first argument.
loopLineSnd :: (Num a, Sigs a) => D -> [a] -> a

-- | Delays a signal by the first argument and takes only second argument
--   amount of signal (everything is measured in seconds).
segmentSnd :: Sigs a => D -> D -> a -> a

-- | Repeats the signal with the given period.
repeatSnd :: Sigs a => D -> a -> a

-- | Converts stereosignal to mono with function mean.
toMono :: (Sig, Sig) -> Sig
instance Show LoopMode
instance Eq LoopMode
instance Enum LoopMode
instance Eq SampleFormat
instance Ord SampleFormat
instance Enum SampleFormat

module Csound.Air.Seg

-- | A segment of the signal. The signal segment is a limited span of
--   signal in time. The time can be measured in seconds or in events! The
--   time span which is measured in events is the first occurence of the
--   event in the event stream.
--   
--   There are handy functions for scheduling the signal segments. we can
--   delay the segment or loop over it or limit it with tme interval or
--   play a sequence of segments. The main feature of the segments is the
--   ability to schedule the signals with event streams (like button clicks
--   or midi-events).
data Seg a

-- | Converts signals to segments. The segment is not limited in length.
toSeg :: a -> Seg a

-- | Converts segments to signals.
runSeg :: Sigs a => Seg a -> a

-- | Limits the length of the segment with constant length in seconds.
constLim :: D -> Seg a -> Seg a

-- | Delays a segment by a given time interval in seconds.
constDel :: Num a => D -> Seg a -> Seg a

-- | A pause. Plays nothing for the given time interval in seconds.
constRest :: Num a => D -> Seg a

-- | Limits a signal with an event stream and retriggers it after stop.
limSnd :: Sigs a => Tick -> a -> a
instance Sigs a => Limit (Seg a)
instance (Sigs a, Num a) => Rest (Seg a)
instance Sigs a => Loop (Seg a)
instance Sigs a => Delay (Seg a)
instance Sigs a => Compose (Seg a)
instance Sigs a => Harmony (Seg a)
instance Sigs a => Melody (Seg a)
instance SigSpace a => SigSpace (Seg a)
instance Functor Seg

module Csound.Air.Sampler

-- | Triggers the signal with the first stream and turns it off with the
--   second stream.
evtTrig :: Sigs a => Tick -> Tick -> a -> a

-- | Consider note limiting? or performance degrades every note is held to
--   infinity and it continues to produce zeroes. No it's not every
--   sequence note triggers it but it's best to limit them anyway
evtTap :: Sigs a => D -> Tick -> a -> a

-- | Plays a list signals. It triggers the signal with event stream and
--   silences all the rest in the list so that only one signal is playing.
--   We can create simple costum monosynthes with this function. The last
--   event stream stops all signals.
evtGroup :: Sigs a => [(Tick, a)] -> Tick -> a

-- | Triggers one signal after another with an event stream.
evtCycle :: Sigs a => Tick -> Tick -> [a] -> a

-- | Triggers a signal when one of the chars from the first string is
--   pressed. Stos signal from playing when one of the chars from the
--   second string is pressed.
charTrig :: Sigs a => String -> String -> a -> a

-- | Consider note limiting? or performance degrades every note is held to
--   infinity and it continues to produce zeroes. No it's not every
--   sequence note triggers it but it's best to limit them anyway
charTap :: Sigs a => D -> String -> a -> a

-- | Plays a signal while a key is pressed.
charPush :: Sigs a => Char -> a -> a

-- | Toggles the signal when key is pressed.
charToggle :: Sigs a => Char -> a -> a

-- | Plays a list of signals when corresponding key is pressed. Turns off
--   all other signals in the group. The last string is for stopping the
--   group from playing.
charGroup :: Sigs a => [(Char, a)] -> String -> a

-- | Plays signals one after another when key is pressed. Stops the group
--   from playing when the char from the last argument is pressed.
charCycle :: Sigs a => Char -> String -> [a] -> a

-- | Plays a signal when the key is pressed. Retriggers the signal when the
--   key is pressed again. The key is an integer midi code. The C1 is 60
--   and the A1 is 69.
midiTrig :: (SigSpace a, Sigs a) => MidiChn -> Int -> a -> SE a

-- | Plays a signal when the key is pressed. Retriggers the signal when the
--   key is pressed again. Turns off the signal after specified duration (n
--   seconds). The key is an integer midi code. The C1 is 60 and the A1 is
--   69.
midiTap :: (SigSpace a, Sigs a) => MidiChn -> D -> Int -> a -> SE a

-- | Plyas a signal while the key is pressed. The key is an integer midi
--   code. The C1 is 60 and the A1 is 69.
midiPush :: (SigSpace a, Sigs a) => MidiChn -> Int -> a -> SE a

-- | Plays and stops a signal in the toggle mode. The key is an integer
--   midi code. The C1 is 60 and the A1 is 69.
midiToggle :: (SigSpace a, Sigs a) => MidiChn -> Int -> a -> SE a

-- | Plays a set of signals on the list of keys. When certain key is
--   pressed the corresponding signal starts to play and all the rest are
--   stopped.
--   
--   <ul>
--   <li>- The key is an integer midi code. The C1 is 60 and the A1 is
--   69.</li>
--   </ul>
midiGroup :: (SigSpace a, Sigs a) => MidiChn -> [(Int, a)] -> SE a

-- | The generic midiTrig. We can specify the midi function. The midi
--   function takes in a signal and a volume of the pressed key (it ranges
--   from 0 to 1). It produces some output. The default is scaling the
--   signal with the amplitude.
midiTrigBy :: (SigSpace a, Sigs a) => MidiTrigFun a -> MidiChn -> Int -> a -> SE a

-- | The generic midiTap. We can specify the midi function. The midi
--   function takes in a signal and a volume of the pressed key (it ranges
--   from 0 to 1). It produces some output. The default is scaling the
--   signal with the amplitude.
midiTapBy :: (SigSpace a, Sigs a) => MidiTrigFun a -> MidiChn -> D -> Int -> a -> SE a

-- | The generic midiPush. We can specify the midi function. The midi
--   function takes in a signal and a volume of the pressed key (it ranges
--   from 0 to 1). It produces some output. The default is scaling the
--   signal with the amplitude.
midiPushBy :: (SigSpace a, Sigs a) => MidiTrigFun a -> MidiChn -> Int -> a -> SE a

-- | The generic midiToggle. We can specify the midi function. The midi
--   function takes in a signal and a volume of the pressed key (it ranges
--   from 0 to 1). It produces some output. The default is scaling the
--   signal with the amplitude.
midiToggleBy :: (SigSpace a, Sigs a) => MidiTrigFun a -> MidiChn -> Int -> a -> SE a

-- | The generic midiGroup. We can specify the midi function. The midi
--   function takes in a signal and a volume of the pressed key (it ranges
--   from 0 to 1). It produces some output. The default is scaling the
--   signal with the amplitude.
midiGroupBy :: (SigSpace a, Sigs a) => MidiTrigFun a -> MidiChn -> [(Int, a)] -> SE a
type MidiTrigFun a = a -> D -> SE a

-- | Scales the signal with the amplitude.
midiAmpInstr :: (SigSpace a, Sigs a) => a -> D -> SE a

-- | Applies a low pass filter to the signal. The first two arguments are
--   the frequency range for center frequency of the filter and the second
--   one is amount of resonance (ranges from 0 to 1).
midiLpInstr :: (SigSpace a, Sigs a) => (Sig, Sig) -> Sig -> a -> D -> SE a

-- | the midiLpInstr with audio range for center frequency.
midiAudioLpInstr :: (SigSpace a, Sigs a) => Sig -> a -> D -> SE a

-- | Ignores the amplitude and justplays back the original signal.
midiConstInstr :: (SigSpace a, Sigs a) => a -> D -> SE a


-- | Effects
module Csound.Air.Fx

-- | Mono version of the cool reverberation opcode reverbsc.
--   
--   <pre>
--   reverbsc1 asig feedbackLevel cutOffFreq
--   </pre>
reverbsc1 :: Sig -> Feedback -> ToneSig -> Sig

-- | Mono reverb (based on reverbsc)
--   
--   <pre>
--   rever1 feedback asig
--   </pre>
rever1 :: Feedback -> Sig -> (Sig, Sig)

-- | Mono reverb (based on reverbsc)
--   
--   <pre>
--   rever2 feedback (asigLeft, asigRight)
--   </pre>
rever2 :: Feedback -> Sig2 -> Sig2

-- | Reverb with given time.
reverTime :: DelayTime -> Sig -> Sig

-- | Mono reverb for small room.
smallRoom :: Sig -> (Sig, Sig)

-- | Mono reverb for small hall.
smallHall :: Sig -> (Sig, Sig)

-- | Mono reverb for large hall.
largeHall :: Sig -> (Sig, Sig)

-- | The magic cave reverb (mono).
magicCave :: Sig -> (Sig, Sig)

-- | Stereo reverb for small room.
smallRoom2 :: Sig2 -> Sig2

-- | Stereo reverb for small hall.
smallHall2 :: Sig2 -> Sig2

-- | Stereo reverb for large hall.
largeHall2 :: Sig2 -> Sig2

-- | The magic cave reverb (stereo).
magicCave2 :: Sig2 -> Sig2

-- | The maximum delay time.
type MaxDelayTime = D

-- | The delaya time
type DelayTime = Sig

-- | Feedback for delay
type Feedback = Sig

-- | Dry/Wet mix value (ranges from 0 to 1). The 0 is all dry. The 1 is all
--   wet.
type Balance = Sig

-- | The simplest delay with feedback. Arguments are: delay length and
--   decay ratio.
--   
--   <pre>
--   echo delayLength ratio
--   </pre>
echo :: MaxDelayTime -> Feedback -> Sig -> SE Sig

-- | Delay with feedback.
--   
--   <pre>
--   fdelay delayLength decayRatio balance
--   </pre>
fdelay :: MaxDelayTime -> Feedback -> Balance -> Sig -> SE Sig

-- | Delay with feedback.
--   
--   <pre>
--   fdelay maxDelayLength delayLength feedback balance
--   </pre>
fvdelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> Sig -> SE Sig

-- | Multitap delay. Arguments are: max delay length, list of pairs
--   <tt>(delayLength, decayRatio)</tt>, balance of mixed signal with
--   processed signal.
--   
--   <pre>
--   fdelay maxDelayLength  delays balance asig
--   </pre>
fvdelays :: MaxDelayTime -> [(DelayTime, Feedback)] -> Balance -> Sig -> SE Sig

-- | Generic multitap delay. It's just like <tt>fvdelays</tt> but instead
--   of constant feedbackLevel it expects a function for processing a
--   delayed signal on the tap.
--   
--   <pre>
--   fdelay maxDelayLength  delays balance asig
--   </pre>
funDelays :: MaxDelayTime -> [(DelayTime, Sig -> Sig)] -> Balance -> Sig -> SE Sig

-- | Delay for functions that use some table (as a buffer). As granular
--   synth or mincer.
--   
--   <pre>
--   tabDelay fn maxDelayTime delayTime feedback balance asig
--   </pre>
tabDelay :: (Tab -> Sig -> SE Sig) -> MaxDelayTime -> DelayTime -> Feedback -> Balance -> Sig -> SE Sig

-- | Distortion.
--   
--   <pre>
--   distort distLevel asig
--   </pre>
distortion :: Sig -> Sig -> Sig
type DepthSig = Sig
type RateSig = Sig
type WidthSig = Sig
type ToneSig = Sig

-- | Chorus.
--   
--   <pre>
--   chorus depth rate balance asig
--   </pre>
chorus :: DepthSig -> RateSig -> Balance -> Sig -> SE Sig

-- | Flanger. Lfo depth ranges in 0 to 1.
--   
--   flanger lfo feedback balance asig
flange :: Lfo -> Feedback -> Balance -> Sig -> Sig

-- | First order phaser.
phase1 :: Sig -> Lfo -> Feedback -> Balance -> Sig -> Sig

-- | Second order phaser. Sweeping gaps in the timbre are placed
--   harmonicaly
harmPhase :: Sig -> Lfo -> Sig -> Sig -> Feedback -> Balance -> Sig -> Sig

-- | Second order phaser. Sweeping gaps in the timbre are placed by powers
--   of the base frequency.
powerPhase :: Sig -> Lfo -> Sig -> Sig -> Feedback -> Balance -> Sig -> Sig

-- | Distortion
--   
--   <pre>
--   fxDistort level drive tone sigIn
--   </pre>
fxDistort :: Feedback -> Sig -> ToneSig -> Sig -> Sig

-- | Stereo distortion.
fxDistort2 :: Feedback -> Sig -> ToneSig -> Sig2 -> Sig2

-- | Stereo chorus.
--   
--   <pre>
--   stChorus2 mix rate depth width sigIn
--   </pre>
stChorus2 :: Balance -> RateSig -> DepthSig -> WidthSig -> Sig2 -> Sig2

-- | Phaser
--   
--   <pre>
--   fxPhaser mix rate depth freq feedback sigIn
--   </pre>
fxPhaser :: Balance -> Feedback -> RateSig -> DepthSig -> Sig -> Sig -> Sig

-- | Stereo phaser.
fxPhaser2 :: Balance -> Feedback -> RateSig -> DepthSig -> Sig -> Sig2 -> Sig2

-- | Flanger
--   
--   <pre>
--   fxFlanger mix feedback rate depth delay sigIn
--   </pre>
fxFlanger :: Balance -> Feedback -> RateSig -> DepthSig -> DelayTime -> Sig -> Sig

-- | Stereo flanger
fxFlanger2 :: Balance -> Feedback -> RateSig -> DepthSig -> DelayTime -> Sig2 -> Sig2

-- | Analog delay.
--   
--   <pre>
--   analogDelay mix feedback time tone sigIn
--   </pre>
analogDelay :: Balance -> Feedback -> DelayTime -> ToneSig -> Sig -> SE Sig

-- | Stereo analog delay.
analogDelay2 :: Balance -> Feedback -> DelayTime -> ToneSig -> Sig2 -> SE Sig2

-- | Simplified delay
--   
--   <pre>
--   fxEcho maxDelayLength delTime feedback sigIn
--   </pre>
fxEcho :: D -> Sig -> Sig -> Sig -> SE Sig

-- | Simplified stereo delay.
fxEcho2 :: D -> Sig -> Sig -> Sig2 -> SE Sig2

-- | Filter effect (a pair of butterworth low and high pass filters).
--   
--   <pre>
--   fxFilter lowPassfFreq highPassFreq gain 
--   </pre>
fxFilter :: Sig -> Sig -> Sig -> Sig -> Sig

-- | Stereo filter effect (a pair of butterworth low and high pass
--   filters).
fxFilter2 :: Sig -> Sig -> Sig -> Sig2 -> Sig2

-- | Adds filtered white noize to the signal
--   
--   <pre>
--   fxWhite lfoFreq depth sigIn
--   </pre>
fxWhite :: Sig -> Sig -> Sig -> SE Sig

-- | Adds filtered white noize to the stereo signal
fxWhite2 :: Sig -> Sig -> Sig2 -> SE Sig2

-- | Adds filtered pink noize to the signal
--   
--   <pre>
--   fxWhite lfoFreq depth sigIn
--   </pre>
fxPink :: Sig -> Sig -> Sig -> SE Sig

-- | Adds filtered pink noize to the stereo signal
fxPink2 :: Sig -> Sig -> Sig2 -> SE Sig2

-- | Equalizer
--   
--   <pre>
--   equalizer gainsAndFrequencies gain sigIn
--   </pre>
equalizer :: [(Sig, Sig)] -> Sig -> Sig -> Sig

-- | Stereo equalizer.
equalizer2 :: [(Sig, Sig)] -> Sig -> Sig2 -> Sig2

-- | Equalizer with frequencies: 100, 400, 1600, 6400
eq4 :: [Sig] -> Sig -> Sig2 -> Sig2

-- | Equalizer with frequencies: 100, 200, 400, 800, 1600, 3200, 6400
eq7 :: [Sig] -> Sig -> Sig2 -> Sig2

-- | Gain
--   
--   <pre>
--   fxGain gain sigIn
--   </pre>
fxGain :: Sig -> Sig2 -> Sig2

-- | Instrument plays an input signal in different modes. The segments of
--   signal can be played back and forth.
--   
--   <pre>
--   trackerSplice maxLength segLength mode
--   </pre>
--   
--   <ul>
--   <li><tt>maxLength</tt> -- the maximum length of the played segment (in
--   seconds)</li>
--   <li><tt>segLength</tt> -- the segment length in seconds</li>
--   <li><tt>mode</tt> -- mode of the playing. If it's 1 - only a part of
--   the sample is plyaed and it's played forward. The portion of the
--   signal starts from the current playback point. It lasts for segLength.
--   If it's 2 - the segment is played in reverse. Other values produce the
--   normal input signal.</li>
--   </ul>
--   
--   Original author: Rory Walsh
--   
--   Example:
--   
--   <pre>
--   main = dac $ do    
--      let ev ch1 ch2 dt = fmap (\x -&gt; (x, dt)) $ mconcat [
--            fmap (const 1.5) $ charOn ch1 
--          , fmap (const 2.5) $ charOn ch2 
--          , fmap (const 0) $ charOff ch1 &lt;&gt; charOff ch2]
--   
--      (k, dt) &lt;- stepper (0, 0.1) $ ev 'q' 'w' 0.1 &lt;&gt; ev 'a' 's' 0.2 &lt;&gt; ev 'z' 'x' 0.4
--      mul 1.3 $ trackerSplice 0.8 dt (int' k) $ fst $ loopWav 1 "drumLoop.wav"
--   </pre>
trackerSplice :: D -> Sig -> Sig -> Sig -> SE Sig


-- | The Csound contains a set of functions for granular synthesis.
--   Unfortunately they are very hard to use due to large number of
--   arguments. This module attempts to set most of the arguments with
--   sensible defaults. So that a novice could start to use it. The
--   defaults are implemented with the help of the class <tt>Default</tt>.
--   It's a standard way to implement defaults in the Haskell. The class
--   <tt>Defaults</tt> defines a single constnat called <tt>def</tt>. With
--   <tt>def</tt> we can get the default value for the given type.
--   
--   Several csound opcodes are reimplemented so that first argument
--   contains secondary parameters. The type for parameters always has the
--   instance for the class <tt>Default</tt>. The original csound opcodes
--   are defined in the end of the module with prefix <tt>csd</tt>.
--   
--   Also many granular synth opcodes expect the sound file as input. There
--   are predefined versions of the opcodes that take in the file names
--   instead of tables with sampled sound. They have suffix <tt>Snd</tt>
--   for stereo and <tt>Snd1</tt> for mono files.
--   
--   For example, that's how we can use the <tt>granule</tt> opcode:
--   
--   <pre>
--   dac $ granuleSnd1 spec [1, 2, 3] grainSize "fox.wav"
--   </pre>
--   
--   No need to set all 22 parameters. Look at the official tutorial (on
--   github) for more examples.
--   
--   The five functions are reimplemented in this way: <tt>sndwarp</tt>,
--   <tt>syncgrain</tt>, <tt>partikkel</tt>, <tt>granule</tt>,
--   <tt>fof2</tt>.
--   
--   The most often used arguments are:
--   
--   <ul>
--   <li>Scale factors for tempo and pitch: <tt>TempoSig</tt> or
--   <tt>speed</tt> and <tt>PitchSig</tt>. Ranges in 0 to 1</li>
--   <li>Grain size is the size of produced grains in seconds. Good range
--   is 0.005 to 0.01 or even 0.1. The higer the value the more it sounds
--   like the original sound.</li>
--   <li>Grain rate. It's the speed of grain production in Hz. If it's in
--   audio range we can no longer percieve the original pitch of the file.
--   Then the pitch is determined with grain rate value.</li>
--   <li>Grain gap. It's the gap in samples between the grains. Good values
--   are 1 to 100.</li>
--   <li>Grain window function. For the sound to be a grain it have to be
--   enveloped with grain window (some sort of bell shaped envelope). We
--   can use half-sine for this purpose (and it's so in most of the
--   defauts) or we can use a table in the <tt>GEN20</tt> family. In the
--   library they implemented as window tables see the table constructors
--   with prefix <tt>win</tt>.</li>
--   </ul>
--   
--   Usual order of arguments is: <tt>GrainRate</tt>, <tt>GrainSize</tt>,
--   <tt>TempoSig</tt>, <tt>PitchSig</tt>, file <tt>table</tt> or
--   <tt>name</tt>, <tt>poniter</tt> to the table.
module Csound.Air.Granular
type GrainRate = Sig
type GrainSize = Sig
type Pointer = Sig
type ConstPitchSig = D

-- | Randomized parameters for function <tt>grainy</tt>. We can randomize
--   pitch scaleing factor (0 to 1), read position (in ratio: 0 to 1), and
--   duration of the grains (in seconds, in magnitude of 0.005 to 0.5).
data RndGrainySpec
RndGrainySpec :: Sig -> Sig -> Sig -> RndGrainySpec
rndGrainyPitch :: RndGrainySpec -> Sig
rndGrainyPos :: RndGrainySpec -> Sig
rndGrainyDur :: RndGrainySpec -> Sig

-- | Simplified version of partikkel. The partikkel for stereo sounds.
--   
--   <pre>
--   grainy1 speed grainrate grainsize kfreqFactor file
--   </pre>
--   
--   <ul>
--   <li><tt>speed</tt> - speed of the playback</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - size of the grains</li>
--   <li><tt>file</tt> - filename of an audio file to read the grains.</li>
--   </ul>
grainy :: GrainRate -> GrainSize -> TempoSig -> PitchSig -> String -> Sig2

-- | Simplified version of partikkel. The partikkel for mono sounds.
--   
--   <pre>
--   grainy1 speed grainrate grainsize kfreqFactor file
--   </pre>
--   
--   <ul>
--   <li><tt>speed</tt> - speed of the playback</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - size of the grains</li>
--   <li><tt>file</tt> - filename of an audio file to read the grains.</li>
--   </ul>
grainy1 :: GrainRate -> GrainSize -> TempoSig -> PitchSig -> String -> Sig

-- | Randomized version of <tt>grainy</tt>.
rndGrainy :: RndGrainySpec -> GrainRate -> GrainSize -> TempoSig -> PitchSig -> String -> SE Sig2

-- | Randomized version of <tt>grainy1</tt>.
rndGrainy1 :: RndGrainySpec -> GrainRate -> GrainSize -> TempoSig -> PitchSig -> String -> SE Sig

-- | Simplified version of partikkel with pointer access to the table. The
--   partikkel for mono sounds.
--   
--   <pre>
--   ptrGrainy grainrate grainsize kfreqFactor tab apnter
--   </pre>
--   
--   <ul>
--   <li><tt>speed</tt> - speed of the playback</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - size of the grains</li>
--   <li><tt>tab</tt> - table with sampled sound.</li>
--   <li><tt>apnter</tt> - pointer to the table. pointer is relative to
--   total size (0 to 1).</li>
--   </ul>
ptrGrainy :: GrainRate -> GrainSize -> PitchSig -> Tab -> Pointer -> Sig

-- | Randomized version of <tt>ptrGrainy</tt>.
rndPtrGrainy :: RndGrainySpec -> GrainRate -> GrainSize -> PitchSig -> Tab -> Pointer -> SE Sig

-- | Simplified version of partikkel with pointer access to the table. The
--   partikkel for mono sounds.
--   
--   <pre>
--   ptrGrainy grainrate grainsize kfreqFactor tab apnter
--   </pre>
--   
--   <ul>
--   <li><tt>speed</tt> - speed of the playback</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - size of the grains</li>
--   <li><tt>file</tt> - file with sampled sound.</li>
--   <li><tt>apnter</tt> - pointer to the table in seconds</li>
--   </ul>
ptrGrainySnd :: GrainRate -> GrainSize -> PitchSig -> String -> Pointer -> Sig2

-- | Simplified version of partikkel with pointer access to the table. The
--   partikkel for mono sounds.
--   
--   <pre>
--   ptrGrainy grainrate grainsize kfreqFactor tab apnter
--   </pre>
--   
--   <ul>
--   <li><tt>speed</tt> - speed of the playback</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - size of the grains</li>
--   <li><tt>file</tt> - file with sampled sound.</li>
--   <li><tt>apnter</tt> - pointer to the table in seconds</li>
--   </ul>
ptrGrainySnd1 :: GrainRate -> GrainSize -> PitchSig -> String -> Pointer -> Sig

-- | Sndwarp secondary parameters. It's instance of <tt>Default</tt>, we
--   can use the constant <tt>def</tt> to get the value.
--   
--   <ul>
--   <li><tt>WinSize</tt> - window size in seconds (not in samples as in
--   Csound!). The default is 0.1</li>
--   <li><tt>Randw</tt> - the bandwidth of a random number generator. The
--   random numbers will be added to iwsize. It's measured in ratio to
--   WinSize. So the 1 means the one WinSize length. The default is
--   0.3</li>
--   <li><tt>Overlap</tt> - determines the density of overlapping windows.
--   The default value is 50. It's in range (0 to 100)</li>
--   </ul>
data SndwarpSpec
SndwarpSpec :: D -> D -> D -> Tab -> SndwarpSpec
sndwarpWinSize :: SndwarpSpec -> D
sndwarpRandw :: SndwarpSpec -> D
sndwarpOvelrap :: SndwarpSpec -> D
sndwarpWin :: SndwarpSpec -> Tab

-- | Simple sndwarp with scaling mode (corresponds to Csound's <tt>initmode
--   == 0</tt>).
--   
--   <pre>
--   sndwarp spec resample speed ftab 
--   </pre>
--   
--   <ul>
--   <li><tt>spec</tt> - secondary params (use <tt>def</tt> to get the
--   defaults)</li>
--   <li><tt>resample</tt> - the factor by which to change the pitch of the
--   sound. For example, a value of 2 will produce a sound one octave
--   higher than the original. The timing of the sound, however, will not
--   be altered.</li>
--   <li><tt>speed</tt> - the factor by which to change the tempo of the
--   sound.</li>
--   <li><tt>ftab</tt> -- table with the samples</li>
--   </ul>
sndwarp :: SndwarpSpec -> TempoSig -> PitchSig -> Tab -> Sig

-- | Stereo version of the <tt>sndwarp</tt>.
sndwarpst :: SndwarpSpec -> TempoSig -> PitchSig -> Tab -> Sig2

-- | Sndwarp that is defined on stereo audio files. We provide the filename
--   instead of table. The rest is the same.
sndwarpSnd :: SndwarpSpec -> TempoSig -> PitchSig -> String -> Sig2

-- | Sndwarp that is defined on mono audio files. We provide the filename
--   instead of table. The rest is the same.
sndwarpSnd1 :: SndwarpSpec -> TempoSig -> PitchSig -> String -> Sig

-- | The simple sndwarp with pointer (Csound <tt>initmode = 1</tt>).
--   
--   <pre>
--   sndwarp spec resample ftab ptr
--   </pre>
--   
--   <ul>
--   <li><tt>spec</tt> - secondary params (use <tt>def</tt> to get the
--   defaults)</li>
--   <li><tt>resample</tt> - the factor by which to change the pitch of the
--   sound. For example, a value of 2 will produce a sound one octave
--   higher than the original. The timing of the sound, however, will not
--   be altered.</li>
--   <li><tt>ftab</tt> -- table with the samples</li>
--   <li><tt>ptr</tt> - pointer to read the table (in seconds).</li>
--   </ul>
ptrSndwarp :: SndwarpSpec -> PitchSig -> Tab -> Pointer -> Sig

-- | Stereo version of <tt>ptrSndwarp</tt>.
ptrSndwarpst :: SndwarpSpec -> PitchSig -> Tab -> Pointer -> Sig2

-- | ptrSndwarp that is defined on stereo audio files. We provide the
--   filename instead of table. The rest is the same.
ptrSndwarpSnd :: SndwarpSpec -> PitchSig -> String -> Pointer -> Sig2

-- | ptrSndwarp that is defined on mono audio files. We provide the
--   filename instead of table. The rest is the same.
ptrSndwarpSnd1 :: SndwarpSpec -> PitchSig -> String -> Pointer -> Sig

-- | Secondary parameters for syncgrain.
--   
--   <ul>
--   <li><tt>Win</tt> -- grain window function (half-sine is used by
--   default)</li>
--   <li><tt>Overlap</tt> -- grain overlap (use values in range 0 to 100,
--   the 25 is default)</li>
--   </ul>
data SyncgrainSpec
SyncgrainSpec :: Tab -> D -> SyncgrainSpec
syncgrainWin :: SyncgrainSpec -> Tab
syncgrainOverlap :: SyncgrainSpec -> D

-- | Randomized parameters for arguments (in range 0 to 1).
data RndSyncgrainSpec
RndSyncgrainSpec :: Sig -> Sig -> Sig -> RndSyncgrainSpec
rndSyncTimescale :: RndSyncgrainSpec -> Sig
rndSyncgrainPitch :: RndSyncgrainSpec -> Sig
rndSyncgrainGrainDur :: RndSyncgrainSpec -> Sig

-- | Synchronous granular synthesis.
--   
--   syncgrain implements synchronous granular synthesis. The source sound
--   for the grains is obtained by reading a function table containing the
--   samples of the source waveform. For sampled-sound sources, GEN01 is
--   used. syncgrain will accept deferred allocation tables.
--   
--   <pre>
--   syncgrain spec graidDuration timeScale PitchSig ftab
--   </pre>
--   
--   <ul>
--   <li><tt>spec</tt> - secondary params (use <tt>def</tt> to get the
--   defaults)</li>
--   <li><tt>graidDuration</tt> - duration of grains in seconds.</li>
--   <li><tt>timeScale</tt> - tempo scaling factor.</li>
--   <li><tt>PitchSig</tt> - pitch scaling factor.</li>
--   <li><tt>ftab</tt> - table with sampled sound.</li>
--   </ul>
syncgrain :: SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Tab -> Sig

-- | syncgrain that is defined on stereo audio files. We provide the
--   filename instead of table. The rest is the same.
syncgrainSnd :: SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> String -> Sig2

-- | syncgrain that is defined on mono audio files. We provide the filename
--   instead of table. The rest is the same.
syncgrainSnd1 :: SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> String -> Sig

-- | The syncgrain with randomized parameters.
rndSyncgrain :: RndSyncgrainSpec -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Tab -> SE Sig

-- | rndSyncgrain that is defined on stereo audio files. We provide the
--   filename instead of table. The rest is the same.
rndSyncgrainSnd :: RndSyncgrainSpec -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> String -> SE Sig2

-- | rndSyncgrain that is defined on mono audio files. We provide the
--   filename instead of table. The rest is the same.
rndSyncgrainSnd1 :: RndSyncgrainSpec -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> String -> SE Sig

-- | Secondary parameters for <tt>granule</tt>. We can use the <tt>def</tt>
--   to get the defaults.
--   
--   <ul>
--   <li><tt>Gap</tt> - gap between grains in sec.</li>
--   <li>Voice - number of voices (integer value in magnitude of 1 to 128,
--   64 is default)</li>
--   <li>Ratio - ratio of the speed of the gskip pointer relative to output
--   audio sample rate (the default is 1)</li>
--   <li>Mode - playback mode (see <tt>GranuleMode</tt>, play forward is
--   the default)</li>
--   <li>Skip_os - gskip pointer random offset in sec, 0 will be no offset
--   (0.5 is default).</li>
--   <li>Gap_os - gap random offset in ratios (0 to 1) of the gap size, 0
--   gives no offset (0.5 is default).</li>
--   <li>Size_os -grain size random offset in ratios (0 to 1) of grain
--   size, 0 gives no offset (0.5 is default).</li>
--   <li>Seed - seed for the random number generator (0.5 is default).</li>
--   <li>Att - attack of the grain envelope in ratios (0 to 1) of grain
--   size (0.3 is default).</li>
--   <li>Dec - decay of the grain envelope in ratios (0 to 1) of grain size
--   (0.3 is default).</li>
--   </ul>
data GranuleSpec
GranuleSpec :: Sig -> D -> D -> GranuleMode -> D -> D -> D -> D -> D -> D -> GranuleSpec
granuleGap :: GranuleSpec -> Sig
granuleVoice :: GranuleSpec -> D
granuleRatio :: GranuleSpec -> D
granuleMode :: GranuleSpec -> GranuleMode
granuleSkip_os :: GranuleSpec -> D
granuleGap_os :: GranuleSpec -> D
granuleSize_os :: GranuleSpec -> D
granuleSeed :: GranuleSpec -> D
granuleAtt :: GranuleSpec -> D
granuleDec :: GranuleSpec -> D

-- | Granule playback mode.
data GranuleMode
GranuleForward :: GranuleMode
GranuleBackward :: GranuleMode
GranuleRandom :: GranuleMode

-- | A more complex granular synthesis texture generator.
--   
--   granule is a Csound unit generator which employs a wavetable as input
--   to produce granularly synthesized audio output. Wavetable data may be
--   generated by any of the GEN subroutines such as GEN01 which reads an
--   audio data file into a wavetable. This enable a sampled sound to be
--   used as the source for the grains. Up to 128 voices are implemented
--   internally. The maximum number of voices can be increased by
--   redefining the variable MAXVOICE in the grain4.h file. granule has a
--   build-in random number generator to handle all the random offset
--   parameters. Thresholding is also implemented to scan the source
--   function table at initialization stage. This facilitates features such
--   as skipping silence passage between sentences.
--   
--   <pre>
--   granule spec chord grainSize ftab
--   </pre>
--   
--   <ul>
--   <li><tt>spec</tt> -- secondary parameters. We can use <tt>def</tt> to
--   get the defaults.</li>
--   <li><tt>chord :: [D]</tt> -- the list of pitch factors to scale the
--   original sound. It can be up to 4 items long. This parameters allows
--   us to create a chords out of grains.</li>
--   <li><tt>grainSize</tt> -- grain size in sec.</li>
--   <li><tt>ftab</tt> - table with sampled sound.</li>
--   </ul>
granule :: GranuleSpec -> [ConstPitchSig] -> GrainSize -> Tab -> Sig

-- | <tt>granule</tt> that is defined on stereo audio files. We provide the
--   filename instead of table. The rest is the same.
granuleSnd :: GranuleSpec -> [ConstPitchSig] -> GrainSize -> String -> Sig2

-- | <tt>granule</tt> that is defined on mono audio files. We provide the
--   filename instead of table. The rest is the same.
granuleSnd1 :: GranuleSpec -> [ConstPitchSig] -> GrainSize -> String -> Sig

-- | Secondary parameters for the partikkel opcode. We can use the
--   <tt>def</tt> to get the defaults. See the official docs to know the
--   complete description:
--   
--   csound doc: <a>http://www.csounds.com/manual/html/partikkel.html</a>
data PartikkelSpec
PartikkelSpec :: Sig -> Tab -> Sig -> Sig -> Tab -> Tab -> Tab -> Sig -> Sig -> Sig -> Tab -> Sig -> Tab -> Tab -> Sig -> Tab -> Tab -> Tab -> Sig -> Sig -> Tab -> Sig -> Tab -> [Sig] -> D -> PartikkelSpec
partikkelDistribution :: PartikkelSpec -> Sig
partikkelDisttab :: PartikkelSpec -> Tab
partikkelSync :: PartikkelSpec -> Sig
partikkelEnv2amt :: PartikkelSpec -> Sig
partikkelEnv2tab :: PartikkelSpec -> Tab
partikkelEnv_attack :: PartikkelSpec -> Tab
partikkelEnv_decay :: PartikkelSpec -> Tab
partikkelSustain_amount :: PartikkelSpec -> Sig
partikkelA_d_ratio :: PartikkelSpec -> Sig
partikkelAmp :: PartikkelSpec -> Sig
partikkelGainmasks :: PartikkelSpec -> Tab
partikkelSweepshape :: PartikkelSpec -> Sig
partikkelWavfreqstarttab :: PartikkelSpec -> Tab
partikkelWavfreqendtab :: PartikkelSpec -> Tab
partikkelWavfm :: PartikkelSpec -> Sig
partikkelFmamptab :: PartikkelSpec -> Tab
partikkelFmenv :: PartikkelSpec -> Tab
partikkelCosine :: PartikkelSpec -> Tab
partikkelNumpartials :: PartikkelSpec -> Sig
partikkelChroma :: PartikkelSpec -> Sig
partikkelChannelmasks :: PartikkelSpec -> Tab
partikkelRandommask :: PartikkelSpec -> Sig
partikkelWaveamptab :: PartikkelSpec -> Tab
partikkelWavekeys :: PartikkelSpec -> [Sig]
partikkelMax_grains :: PartikkelSpec -> D

-- | Granular synthesizer with "per grain" control over many of its
--   parameters. Has a sync input to sychronize its internal grain
--   scheduler clock to an external clock source.
--   
--   partikkel was conceived after reading Curtis Roads' book
--   <a>Microsound</a>, and the goal was to create an opcode that was
--   capable of all time-domain varieties of granular synthesis described
--   in this book. The idea being that most of the techniques only differ
--   in parameter values, and by having a single opcode that can do all
--   varieties of granular synthesis makes it possible to interpolate
--   between techniques. Granular synthesis is sometimes dubbed particle
--   synthesis, and it was thought apt to name the opcode partikkel to
--   distinguish it from other granular opcodes.
--   
--   <pre>
--   partikkel spec grainrate grainsize kpitch ifiltabs apnters
--   </pre>
--   
--   <ul>
--   <li><tt>spec</tt> - secondary parameters</li>
--   <li><tt>grainrate</tt> - rate of the grain creation</li>
--   <li><tt>grainsize</tt> - grain size in sec (!!!not in ms as for
--   Csound!!!).</li>
--   <li><tt>kpitch</tt> -- pitch scaling factor.</li>
--   <li><tt>apnters</tt> -- list of pointers (up to 4 values can be
--   used)</li>
--   <li><tt>ifiltabs</tt> -- list of tables (up to 4 values can be
--   used)</li>
--   </ul>
partikkel :: PartikkelSpec -> GrainRate -> GrainSize -> PitchSig -> [Tab] -> [Pointer] -> Sig

-- | Defaults for <tt>fof2</tt> opcode.
data Fof2Spec
Fof2Spec :: Sig -> Sig -> Sig -> Sig -> Sig -> Sig -> Sig -> Tab -> Fof2Spec
fof2TimeMod :: Fof2Spec -> Sig
fof2PitchMod :: Fof2Spec -> Sig
fof2Oct :: Fof2Spec -> Sig
fof2Band :: Fof2Spec -> Sig
fof2Rise :: Fof2Spec -> Sig
fof2Decay :: Fof2Spec -> Sig
fof2Gliss :: Fof2Spec -> Sig
fof2Win :: Fof2Spec -> Tab

-- | Reimplementation of fof2 opcode.
fof2 :: Fof2Spec -> GrainRate -> GrainSize -> Tab -> Pointer -> Sig

-- | Reimplementation of fof2 opcode for stereo audio files.
fof2Snd :: Fof2Spec -> GrainRate -> GrainSize -> TempoSig -> String -> Sig2

-- | Reimplementation of fof2 opcode for mono audio files.
fof2Snd1 :: Fof2Spec -> GrainRate -> GrainSize -> TempoSig -> String -> Sig

-- | Granular delay effect for <tt>grainy</tt>.
grainyDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for <tt>rndGrainy</tt>.
rndGrainyDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> RndGrainySpec -> GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for <tt>sndwarp</tt>.
sndwarpDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> SndwarpSpec -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for <tt>syncgrain</tt>.
syncgrainDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for <tt>rndSyncgrain</tt>.
rndSyncgrainDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> RndSyncgrainSpec -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for <tt>partikkel</tt>.
partikkelDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> PartikkelSpec -> GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular delay effect for fof2. Good values for grain rate and size
--   are
--   
--   <pre>
--   grainRate = 25
--   grainSize = 2.5
--   </pre>
fofDelay :: MaxDelayTime -> DelayTime -> Feedback -> Balance -> Fof2Spec -> GrainRate -> GrainSize -> Sig -> SE Sig

-- | Granular effect for <tt>grainy</tt>.
grainyFx :: GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>rndGrainy</tt>.
rndGrainyFx :: RndGrainySpec -> GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>sndwarp</tt>.
sndwarpFx :: SndwarpSpec -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>syncgrain</tt>.
syncgrainFx :: SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>rndSyncgrain</tt>.
rndSyncgrainFx :: RndSyncgrainSpec -> SyncgrainSpec -> GrainSize -> TempoSig -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>partikkel</tt>.
partikkelFx :: PartikkelSpec -> GrainRate -> GrainSize -> PitchSig -> Sig -> SE Sig

-- | Granular effect for <tt>fof2</tt>.
fofFx :: Fof2Spec -> GrainRate -> GrainSize -> Sig -> SE Sig

-- | Reads a mono sound sample from a table and applies time-stretching
--   and/or pitch modification.
--   
--   sndwarp reads sound samples from a table and applies time-stretching
--   and/or pitch modification. Time and frequency modification are
--   independent from one another. For example, a sound can be stretched in
--   time while raising the pitch!
--   
--   <pre>
--   ares [, ac]  sndwarp  xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, \
--             irandw, ioverlap, ifn2, itimemode
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/sndwarp.html</a>
csdSndwarp :: Sig -> Sig -> Sig -> Tab -> D -> D -> D -> D -> Tab -> D -> Sig

-- | Reads a stereo sound sample from a table and applies time-stretching
--   and/or pitch modification.
--   
--   sndwarpst reads stereo sound samples from a table and applies
--   time-stretching and/or pitch modification. Time and frequency
--   modification are independent from one another. For example, a sound
--   can be stretched in time while raising the pitch!
--   
--   <pre>
--   ar1, ar2 [,ac1] [, ac2]  sndwarpst  xamp, xtimewarp, xresample, ifn1, \
--             ibeg, iwsize, irandw, ioverlap, ifn2, itimemode
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/sndwarpst.html</a>
csdSndwarpst :: Sig -> Sig -> Sig -> Tab -> D -> D -> D -> D -> Tab -> D -> Sig2

-- | Synchronous granular synthesis.
--   
--   syncgrain implements synchronous granular synthesis. The source sound
--   for the grains is obtained by reading a function table containing the
--   samples of the source waveform. For sampled-sound sources, GEN01 is
--   used. syncgrain will accept deferred allocation tables.
--   
--   <pre>
--   asig  syncgrain  kamp, kfreq, kpitch, kgrsize, kprate, ifun1, \
--             ifun2, iolaps
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/syncgrain.html</a>
csdSyncgrain :: Sig -> Sig -> Sig -> Sig -> Sig -> Tab -> Tab -> D -> Sig

-- | A more complex granular synthesis texture generator.
--   
--   The granule unit generator is more complex than grain, but does add
--   new possibilities.
--   
--   <pre>
--   ares  granule  xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, \
--             igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec \
--             [, iseed] [, ipitch1] [, ipitch2] [, ipitch3] [, ipitch4] [, ifnenv]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/granule.html</a>
csdGranule :: Sig -> D -> D -> D -> D -> Tab -> D -> D -> D -> D -> Sig -> D -> Sig -> D -> D -> D -> Sig

-- | Granular synthesizer with "per grain" control over many of its
--   parameters. Has a sync input to sychronize its internal grain
--   scheduler clock to an external clock source.
--   
--   partikkel was conceived after reading Curtis Roads' book
--   <a>Microsound</a>, and the goal was to create an opcode that was
--   capable of all time-domain varieties of granular synthesis described
--   in this book. The idea being that most of the techniques only differ
--   in parameter values, and by having a single opcode that can do all
--   varieties of granular synthesis makes it possible to interpolate
--   between techniques. Granular synthesis is sometimes dubbed particle
--   synthesis, and it was thought apt to name the opcode partikkel to
--   distinguish it from other granular opcodes.
--   
--   <pre>
--   a1 [, a2, a3, a4, a5, a6, a7, a8]  partikkel  agrainfreq, \
--                     kdistribution, idisttab, async, kenv2amt, ienv2tab, ienv_attack, \
--                     ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, \
--                     kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \
--                     ifmamptab, kfmenv, icosine, ktraincps, knumpartials, kchroma, \
--                     ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, \
--                     kwaveform4, iwaveamptab, asamplepos1, asamplepos2, asamplepos3, \
--                     asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains \
--                     [, iopcode_id]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/partikkel.html</a>
csdPartikkel :: Tuple a => Sig -> Sig -> Tab -> Sig -> Sig -> Tab -> Tab -> Tab -> Sig -> Sig -> Sig -> Sig -> Tab -> Sig -> Sig -> Tab -> Tab -> Sig -> Tab -> Tab -> Tab -> Sig -> Sig -> Sig -> Tab -> Sig -> Tab -> Tab -> Tab -> Tab -> Tab -> Sig -> Sig -> Sig -> Sig -> Sig -> Sig -> Sig -> Sig -> D -> a
instance Default Fof2Spec
instance Default SndwarpSpec
instance Default RndSyncgrainSpec
instance Default SyncgrainSpec
instance Default GranuleSpec
instance Default GranuleMode
instance Default RndGrainySpec
instance Default PartikkelSpec


-- | UIs for live performances
module Csound.Air.Live

-- | Widget that represents a mixer.
mixer :: [(String, SE Sig2)] -> Source Sig2

-- | Widget that represents a mixer with horizontal grouping of elements.
hmixer :: [(String, SE Sig2)] -> Source Sig2

-- | Transforms the mono signal to the stereo input for the mixer widget.
mixMono :: String -> Sig -> (String, SE Sig2)

-- | The stereo signal processing function.
type FxFun = Sig2 -> SE Sig2
class FxUI a
applyFxArgs :: FxUI a => a -> [Sig] -> Sig2 -> SE Sig2
arityFx :: FxUI a => a -> Int

-- | Creates a widget that represents a stereo signal processing function.
--   The parameters of the widget are updated with sliders. For example
--   let's create a simple gain widget. It can be encoded like this:
--   
--   <pre>
--   uiGain :: Bool -&gt; Double -&gt; Source FxFun
--   uiGain isOn gain = fxBox "Gain" fx isOn [("gain", gain)]
--      where 
--          fx :: Sig -&gt; Sig2 -&gt; Sig2
--          fx = mul
--   </pre>
--   
--   Let's look at the arguments of the function
--   
--   <pre>
--   fxBox name fx isOn args
--   </pre>
--   
--   <ul>
--   <li><tt>name</tt> -- is the name of the widget</li>
--   <li><tt>fx</tt> -- is signal processing function (see the class
--   <tt>FxUI</tt>).</li>
--   <li><tt>isOn</tt> -- whether widget in the active state</li>
--   <li><tt>args</tt> -- list of initial values for arguments and names of
--   the arguments.</li>
--   </ul>
--   
--   It's cool to set the color of the widget with <tt>fxColor</tt>
--   function. we can make our widgets much more intersting to look at.
fxBox :: FxUI a => String -> a -> Bool -> [(String, Double)] -> Source FxFun

-- | Creates an FX-box from the given visual representation. It insertes a
--   big On/Off button atop of the GUI.
uiBox :: String -> Source FxFun -> Bool -> Source FxFun

-- | Colors the source widgets.
fxColor :: Color -> Source a -> Source a

-- | Groups the signal processing widgets. The functions are composed the
--   visuals are grouped verticaly.
fxVer :: [Source FxFun] -> Source FxFun

-- | Groups the signal processing widgets. The functions are composed the
--   visuals are grouped horizontaly.
fxHor :: [Source FxFun] -> Source FxFun

-- | Scales the gui for signal processing widgets.
fxSca :: Double -> Source FxFun -> Source FxFun

-- | Applies a function to a signal processing function.
fxApp :: FxFun -> Source FxFun -> Source FxFun

-- | Chooses an instrument among several alternatives. It uses the
--   <tt>hradio</tt> for GUI groupping.
hinstrChooser :: Sigs b => [(String, a -> SE b)] -> Int -> Source (a -> SE b)

-- | Chooses an instrument among several alternatives. It uses the
--   <tt>vradio</tt> for GUI groupping.
vinstrChooser :: Sigs b => [(String, a -> SE b)] -> Int -> Source (a -> SE b)

-- | Chooses a midi instrument among several alternatives. It uses the
--   <tt>hradio</tt> for GUI groupping.
hmidiChooser :: Sigs a => [(String, Msg -> SE a)] -> Int -> Source a

-- | Chooses a midi instrument among several alternatives. It uses the
--   <tt>vradio</tt> for GUI groupping.
vmidiChooser :: Sigs a => [(String, Msg -> SE a)] -> Int -> Source a

-- | The distortion widget. The arguments are
--   
--   <pre>
--   uiDistort isOn levelOfDistortion drive tone
--   </pre>
uiDistort :: Bool -> Double -> Double -> Double -> Source FxFun

-- | The chorus widget. The arguments are
--   
--   <pre>
--   uiChorus isOn mix rate depth width 
--   </pre>
uiChorus :: Bool -> Double -> Double -> Double -> Double -> Source FxFun

-- | The flanger widget. The arguments are
--   
--   <pre>
--   uiFlanger isOn mix feedback rate depth delay
--   </pre>
uiFlanger :: Bool -> Double -> Double -> Double -> Double -> Double -> Source FxFun

-- | The phaser widget. The arguments are
--   
--   <pre>
--   uiPhaser isOn mix feedback rate depth frequency
--   </pre>
uiPhaser :: Bool -> Double -> Double -> Double -> Double -> Double -> Source FxFun

-- | The delay widget. The arguments are
--   
--   <pre>
--   uiDelay isOn mix feedback delayTime tone
--   </pre>
uiDelay :: Bool -> Double -> Double -> Double -> Double -> Source FxFun

-- | The simplified delay widget. The arguments are
--   
--   <pre>
--   uiEcho isOn maxDelayTime delayTime feedback
--   </pre>
uiEcho :: Bool -> D -> Double -> Double -> Source FxFun

-- | The pair of low and high pass filters
--   
--   <pre>
--   uiFilter isOn lowPassfrequency highPassFrequency gain
--   </pre>
uiFilter :: Bool -> Double -> Double -> Double -> Source FxFun

-- | The reverb widget. The arguments are:
--   
--   <pre>
--   uiReverb mix depth
--   </pre>
uiReverb :: Bool -> Double -> Double -> Source FxFun

-- | The gain widget. The arguments are
--   
--   <pre>
--   uiGain isOn amountOfGain
--   </pre>
uiGain :: Bool -> Double -> Source FxFun

-- | The filtered white noize widget. The arguments are
--   
--   <pre>
--   uiWhite isOn centerFreqOfFilter amountOfNoize 
--   </pre>
uiWhite :: Bool -> Double -> Double -> Source FxFun

-- | The filtered pink noize widget. The arguments are
--   
--   <pre>
--   uiPink isOn centerFreqOfFilter amountOfNoize 
--   </pre>
uiPink :: Bool -> Double -> Double -> Source FxFun

-- | The constructor for signal processing functions with no arguments
--   (controlls).
uiFx :: FxUI a => String -> a -> Bool -> Source FxFun

-- | The reverb for room.
uiRoom :: Bool -> Source FxFun

-- | The reverb for hall.
uiHall :: Bool -> Source FxFun

-- | The reverb for magic cave.
uiCave :: Bool -> Source FxFun

-- | the widget for mixing in a signal to the signal.
uiSig :: String -> Bool -> Source Sig2 -> Source FxFun

-- | A mixer widget represented as an effect. The effect sums the signals
--   with given wieghts.
uiMix :: Bool -> [(String, SE Sig2)] -> Source FxFun

-- | Midi chooser implemented as FX-box.
uiMidi :: [(String, Msg -> SE Sig2)] -> Int -> Source FxFun
data AdsrBound
AdsrBound :: Double -> Double -> Double -> AdsrBound
attBound :: AdsrBound -> Double
decBound :: AdsrBound -> Double
relBound :: AdsrBound -> Double
data AdsrInit
AdsrInit :: Double -> Double -> Double -> Double -> AdsrInit
attInit :: AdsrInit -> Double
decInit :: AdsrInit -> Double
susInit :: AdsrInit -> Double
relInit :: AdsrInit -> Double
linAdsr :: String -> AdsrBound -> AdsrInit -> Source Sig
expAdsr :: String -> AdsrBound -> AdsrInit -> Source Sig

-- | A widget with four standard waveforms: pure tone, triangle, square and
--   sawtooth. The last parameter is a default waveform (it's set at init
--   time).
classicWaves :: String -> Int -> Source (Sig -> Sig)

-- | Slider for master volume
masterVolume :: Source Sig

-- | Knob for master volume
masterVolumeKnob :: Source Sig
instance FxUI a => FxUI (Sig -> a)
instance FxUI FxFun
instance FxUI (Sig2 -> Sig2)
instance SigSpace FxFun


-- | A multitap looper.
module Csound.Air.Looper

-- | The type for fine tuning of the looper. Let's review the values:
--   
--   <ul>
--   <li><tt>loopMixVal</tt> - list of initial values for mix levels
--   (default is 0.5 for all taps)</li>
--   <li><tt>loopPrefx</tt> - list of pre-loop effects (the default is
--   do-nothing effect)</li>
--   <li><tt>loopPostfx</tt> - list of post-loop effects (the default is
--   do-nothing effect)</li>
--   <li><tt>loopPrefxVal</tt> - list of dry/wet values for pre-looop
--   effects (the default is 0.5 for all taps)</li>
--   <li><tt>loopPostfxVal</tt> - list of dry/wet values for post-looop
--   effects (the default is 0.5 for all taps)</li>
--   <li><tt>loopInitInstr</tt> - the initial sounding tap (sound source)
--   (what tap we are going to record when the looper starts up).</li>
--   <li><tt>loopFades</tt> - the list of instrument groups to fade/out.
--   Eachl list item is a list of integers where an integer points to a tap
--   number. By default a single fader is given to each tap. with lists of
--   integers we can group the sound sources by their functions in the
--   song. We may group all harmonic instruments in a single group and all
--   drums into another group.</li>
--   <li><tt>loopReeatFades</tt> -- a repeat fade weight is a value that
--   represents an amount of repetition. A looping tap is implemented as a
--   delay tap with big feedback. The repeat fades equals to the feedback
--   amount. It have to be not bigger than 1. If the value equals to 1 than
--   the loop is repeated forever. If it's lower than 1 the loop is
--   gradually going to fade.</li>
--   <li><tt>loopControl</tt> -- specifies an external controllers for the
--   looper. See the docs for the type <tt>LoopSpec</tt>.</li>
--   </ul>
data LoopSpec
LoopSpec :: [Sig] -> [FxFun] -> [FxFun] -> [Sig] -> [Sig] -> Int -> [[Int]] -> [Sig] -> LoopControl -> LoopSpec
loopMixVal :: LoopSpec -> [Sig]
loopPrefx :: LoopSpec -> [FxFun]
loopPostfx :: LoopSpec -> [FxFun]
loopPrefxVal :: LoopSpec -> [Sig]
loopPostfxVal :: LoopSpec -> [Sig]
loopInitInstr :: LoopSpec -> Int
loopFades :: LoopSpec -> [[Int]]
loopRepeatFades :: LoopSpec -> [Sig]
loopControl :: LoopSpec -> LoopControl

-- | External controllers. We can control the looper with UI-widgets but
--   sometimes it's convenient to control the loper with some external
--   midi-device. This structure mocks all controls (except knobs for
--   effects and mix).
--   
--   <ul>
--   <li><tt>loopTap</tt> - selects the current tap. It's a stream of
--   integers (from 0 to a given integer).</li>
--   <li><tt>loopFade</tt> - can fade in or fade out a group of taps. It's
--   a list of toggle-like event streams. they produce 1s for on and 0s for
--   off.</li>
--   <li><tt>loopDel</tt> - is for deleting the content of a given tap.
--   It's just a click of the button. So the value should be an event
--   stream of units (which is <tt>Tick = Evt Unit</tt>).</li>
--   <li><tt>loopThrough</tt> - is an event stream of toggles.</li>
--   </ul>
--   
--   All values are wrapped in the <tt>Maybe</tt> type. If the value is
--   <tt>Nothing</tt> in the given cell the looper is controled only with
--   virtual widgets.
--   
--   There is an instance of <tt>Default</tt> for <tt>LoopControl</tt> with
--   all values set to <tt>Nothing</tt>. It's useful when we want to
--   control only a part of parameters externally. We can use the value
--   <tt>def</tt> to set the rest parameters:
--   
--   <pre>
--   def { loopTap = Just someEvt }
--   </pre>
data LoopControl
LoopControl :: Maybe (Evt D) -> Maybe ([Evt D]) -> Maybe Tick -> Maybe (Evt D) -> LoopControl
loopTap :: LoopControl -> Maybe (Evt D)
loopFade :: LoopControl -> Maybe ([Evt D])
loopDel :: LoopControl -> Maybe Tick
loopThrough :: LoopControl -> Maybe (Evt D)

-- | Simple multitap Looper. We can create as many taps as we like also we
--   can create fade outs/ins insert effects and control mix.
--   
--   <pre>
--   sigLoop spec bpm times imputs 
--   </pre>
--   
--   Arguments:
--   
--   <ul>
--   <li>looper <tt>spec</tt> (see the docs for the type)</li>
--   <li>main <tt>bpm</tt> rate. All taps are aligned with the main
--   rate</li>
--   <li>list of multipliers for each tap. Each tap is going to have a
--   fixed length that is a multiplier of the main rate. It doesn't have to
--   be an integer. So we can create weird drum patterns with odd loop
--   durations.</li>
--   <li>list of signal sources. By convention all sources are stereo
--   signals. We can use the function <tt>fromMono</tt> to convert the mono
--   signal to stereo.</li>
--   </ul>
sigLoop :: LoopSpec -> D -> [D] -> [Sig2] -> Source Sig2

-- | The <tt>sigLoop</tt> that is adapted for usage with midi instruments.
--   It takes a list of midi instruments in place of signal inputs. The
--   rest is the same
midiLoop :: LoopSpec -> D -> [D] -> [Msg -> SE Sig2] -> Source Sig2

-- | The <tt>midiLoop</tt> that is adapted for usage with soundfonts. It
--   takes in a list of pairs of sound fonts as sound sources. The second
--   value in the pair is the release time for the given sound font.
sfLoop :: LoopSpec -> D -> [D] -> [(Sf, D)] -> Source Sig2
instance Default LoopControl
instance Default LoopSpec


-- | The vital tools.
module Csound.Air


-- | Basic types and functions.
--   
--   This module re-exports everything.
--   
--   WARNING (for Csound users): the maximum amplitude is 1.0. There is no
--   way to alter it. Don't define your amplitudes with 9000 or 11000. But
--   the good news are: all signals are clipped by 1 so that you can not
--   damage your ears and your speakers by a little typo.
module Csound.Base


-- | Hyper vectorial synthesis
module Csound.Air.Hvs

-- | Hvs vector
type HvsSnapshot = [Double]

-- | 1D matrix
type HvsMatrix1 = [HvsSnapshot]

-- | 2D matrix (grid of vecotrs)
type HvsMatrix2 = [HvsMatrix1]

-- | 3D matrix (cube of vectors)
type HvsMatrix3 = [HvsMatrix2]

-- | One dimensional Hyper vectorial synthesis. We can provide a list of
--   vectors (of lists but the same length for all items is assumed) and a
--   signal that ranges from 0 to 1. It interpolates between vectors in the
--   list. As a result we get a n interpolated vector. It's a list but the
--   actual length equals to the length of input vectors.
--   
--   An example. We can set the center frequency and resonance of the
--   filter with the single parameter:
--   
--   <pre>
--   let f = hvs1 [[100, 0.1], [300, 0.1], [600, 0.5], [800, 0.9]]
--    dac $ lift1 (\x -&gt; fmap (\[cps, q] -&gt; mlp cps q (saw 110)) $ f x) (uknob 0.5)
--   </pre>
--   
--   Notice the exact pattern match with the list in the argument of the
--   lambda function:
--   
--   <pre>
--   \[cps, q] -&gt; mlp cps q (saw 110)) $ f x
--   </pre>
--   
--   It's determined by the length of the items in the input list.
hvs1 :: HvsMatrix1 -> Sig -> SE [Sig]

-- | Two dimensional Hyper vectorial synthesis. Now we provide a list of
--   lists of vectors. The length of all vectors should be the same but
--   there is no limit for the number! So that's how we can control a lot
--   of parameters with pair of signals. The input 2D atrix is the grid of
--   samples. It finds the closest four points in the grid and interpolates
--   between them (it's a weighted sum).
--   
--   <pre>
--   hvs2 matrix (x, y)
--   </pre>
--   
--   The usage is the same as in the case of <tt>hvs1</tt>. An example:
--   
--   <pre>
--   g = hvs2 [[[100, 0.1, 0.3], [800, 0.1, 0.5], [1400, 0.1, 0.8]], 
--   		  [[100, 0.5, 0.3], [800, 0.5, 0.5], [1400, 0.5, 0.8]], 
--   		  [[100, 0.8, 0.3], [800, 0.8, 0.5], [1400, 0.8, 0.8]]]
--   
--   main = dac $ do
--   	(g1, kx) &lt;- uknob 0.5
--   	(g2, ky) &lt;- uknob 0.5
--   	[cfq, q, w] &lt;- g (kx, ky)
--   	panel $ hor [g1, g2]
--   	at (mlp cfq q) $ fmap (cfd w (saw 110)) (white)
--   </pre>
hvs2 :: HvsMatrix2 -> Sig2 -> SE [Sig]

-- | The three dimensional
hvs3 :: HvsMatrix3 -> Sig3 -> SE [Sig]

-- | Allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled by
--   externally-updated k-variables.
--   
--   hvs1 allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled
--   by externally-updated k-variables.
--   
--   <pre>
--   hvs1  kx, inumParms, inumPointsX, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/hvs1.html</a>
csdHvs1 :: Sig -> D -> D -> Tab -> Tab -> Tab -> SE ()

-- | Allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled by
--   externally-updated k-variables.
--   
--   hvs2 allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled
--   by externally-updated k-variables.
--   
--   <pre>
--   hvs2  kx, ky, inumParms, inumPointsX, inumPointsY, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/hvs2.html</a>
csdHvs2 :: Sig -> Sig -> D -> D -> D -> Tab -> Tab -> Tab -> SE ()

-- | Allows three-dimensional Hyper Vectorial Synthesis (HVS) controlled by
--   externally-updated k-variables.
--   
--   hvs3 allows three-dimensional Hyper Vectorial Synthesis (HVS)
--   controlled by externally-updated k-variables.
--   
--   <pre>
--   hvs3  kx, ky, kz, inumParms, inumPointsX, inumPointsY, inumPointsZ, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/hvs3.html</a>
csdHvs3 :: Sig -> Sig -> Sig -> D -> D -> D -> D -> Tab -> Tab -> Tab -> SE ()
