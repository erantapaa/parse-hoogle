-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | O(log n) persistent on-line lowest common ancestor calculation without preprocessing
--   
@package lca
@version 0.3


module Data.LCA.View

-- | Provides a consistent <a>View</a> for peeling off the bottom node of a
--   path.
data View f a
Root :: View f a
Node :: {-# UNPACK #-} !Int -> a -> (f a) -> View f a
instance (Eq a, Eq (f a)) => Eq (View f a)
instance (Ord a, Ord (f a)) => Ord (View f a)
instance (Read a, Read (f a)) => Read (View f a)
instance (Show a, Show (f a)) => Show (View f a)
instance Traversable f => Traversable (View f)
instance Foldable f => Foldable (View f)
instance Functor f => Functor (View f)


-- | Provides online calculation of the the lowest common ancestor in
--   <i>O(log h)</i> by compressing the spine of the paths using a
--   skew-binary random access list.
--   
--   This library implements the technique described in my talk
--   
--   
--   <a>http://www.slideshare.net/ekmett/skewbinary-online-lowest-common-ancestor-search</a>
--   
--   to improve the known asymptotic bounds on both online lowest common
--   ancestor search
--   
--   <a>http://en.wikipedia.org/wiki/Lowest_common_ancestor</a>
--   
--   and the online level ancestor problem:
--   
--   <a>http://en.wikipedia.org/wiki/Level_ancestor_problem</a>
--   
--   Algorithms used here assume that the key values chosen for <tt>k</tt>
--   are globally unique.
--   
--   This version provides access to a monoidal "summary" of the elided
--   path for many operations.
module Data.LCA.Online.Monoidal

-- | A compressed <a>Path</a> as a skew binary random access list
data Path a

-- | Convert a <a>Path</a> to a list of <tt>(ID, value)</tt> pairs.
toList :: Path a -> [(Int, a)]

-- | Build a <a>Path</a> from a list of <tt>(ID, value)</tt> pairs.
fromList :: Monoid a => [(Int, a)] -> Path a

-- | <i>O(n)</i> Re-annotate a <a>Path</a> full of monoidal values using a
--   different <a>Monoid</a>.
map :: Monoid b => (a -> b) -> Path a -> Path b

-- | <i>O(n)</i> Re-annotate a <a>Path</a> full of monoidal values/
--   
--   Unlike <a>map</a>, <tt><a>mapHom</a> f</tt> assumes that <tt>f</tt> is
--   a <a>Monoid</a> homomorphism, that is to say you must ensure
--   
--   <pre>
--   f a `'mappend'` f b = f (a `'mappend'` b)
--   f <a>mempty</a> = <a>mempty</a>
--   </pre>
mapHom :: (a -> b) -> Path a -> Path b

-- | <i>O(n)</i> Re-annotate a <a>Path</a> full of monoidal values with
--   access to the key.
mapWithKey :: Monoid b => (Int -> a -> b) -> Path a -> Path b

-- | Traverse a <a>Path</a> yielding a new monoidal annotation.
traverse :: (Applicative f, Monoid b) => (a -> f b) -> Path a -> f (Path b)

-- | Traverse a <a>Path</a> with access to the node IDs.
traverseWithKey :: (Applicative f, Monoid b) => (Int -> a -> f b) -> Path a -> f (Path b)

-- | The empty <a>Path</a>
empty :: Path a

-- | <i>O(1)</i> Invariant: most operations assume that the keys <tt>k</tt>
--   are globally unique
--   
--   Extend the <a>Path</a> with a new node ID and value.
cons :: Monoid a => Int -> a -> Path a -> Path a

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>.
uncons :: Monoid a => Path a -> Maybe (Int, a, Path a)

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>, slightly faster than <a>uncons</a>.
view :: Monoid a => Path a -> View Path a

-- | <i>O(1)</i> Returns <a>True</a> iff the path is <a>empty</a>.
null :: Path a -> Bool

-- | <i>O(1)</i> Determine the <a>length</a> of a <a>Path</a>.
length :: Path a -> Int

-- | Extract a monoidal summary of a <a>Path</a>.
measure :: Monoid a => Path a -> a

-- | <i>O(log h)</i> <tt>xs `'isAncestorOf'` ys</tt> holds when <tt>xs</tt>
--   is a prefix starting at the root of path <tt>ys</tt>.
isAncestorOf :: Monoid b => Path a -> Path b -> Bool

-- | <i>O(log (h - k))</i> to <tt><a>keep</a> k</tt> elements of
--   <a>Path</a> of <a>length</a> <tt>h</tt>
--   
--   This solves the online version of the "level ancestor problem" with no
--   preprocessing in <i>O(log h)</i> time, improving known complexity
--   bounds.
--   
--   <a>http://en.wikipedia.org/wiki/Level_ancestor_problem</a>
keep :: Monoid a => Int -> Path a -> Path a

-- | <i>O(log (h - k))</i> to keep <tt>k</tt> elements of <a>Path</a> of
--   <a>length</a> <tt>h</tt>, and provide a monoidal summary of the
--   dropped elements using a supplied monoid homomorphism.
mkeep :: (Monoid a, Monoid b) => (a -> b) -> Int -> Path a -> (b, Path a)

-- | <i>O(log k)</i> to <tt><a>drop</a> k</tt> elements from a <a>Path</a>
drop :: Monoid a => Int -> Path a -> Path a

-- | <i>O(log k)</i> to drop <tt>k</tt> elements from a <a>Path</a> and
--   provide a monoidal summary of the dropped elements using a suplied
--   monoid homomorphism
mdrop :: (Monoid a, Monoid b) => (a -> b) -> Int -> Path a -> (b, Path a)

-- | <i>O(1)</i> Compare to see if two trees have the same leaf key
(~=) :: Path a -> Path b -> Bool

-- | <i>O(log h)</i> Compute the lowest common ancestor of two paths
lca :: (Monoid a, Monoid b) => Path a -> Path b -> Path a

-- | <i>O(log h)</i> Compute the lowest common ancestor of two paths along
--   with a monoidal summary of their respective tails using the supplied
--   monoid homomorphisms.
mlca :: (Monoid a, Monoid b, Monoid c, Monoid d) => (a -> c) -> (b -> d) -> Path a -> Path b -> (c, Path a, d, Path b)
instance Show a => Show (Tree a)
instance Read a => Read (Tree a)
instance Show a => Show (Path a)
instance Read a => Read (Path a)
instance Foldable Path
instance Foldable Tree


-- | Naive online calculation of the the lowest common ancestor in
--   <i>O(h)</i>
module Data.LCA.Online.Naive

-- | An uncompressed <a>Path</a> with memoized length.
data Path a

-- | The empty <a>Path</a>
empty :: Path a

-- | <i>O(1)</i> Invariant: most operations assume that the keys <tt>k</tt>
--   are globally unique
--   
--   Extend the path with a new node ID and value.
cons :: Int -> a -> Path a -> Path a

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>.
uncons :: Path a -> Maybe (Int, a, Path a)

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>, slightly faster than <a>uncons</a>.
view :: Path a -> View Path a

-- | <i>O(1)</i> Returns <a>True</a> iff the <a>Path</a> is <a>empty</a>.
null :: Path a -> Bool

-- | <i>O(1)</i> Determine the length of a <a>Path</a>.
length :: Path a -> Int

-- | <i>O(h)</i> <tt>xs <a>isAncestorOf</a> ys</tt> holds when <tt>xs</tt>
--   is a prefix starting at the root of <a>Path</a> <tt>ys</tt>.
isAncestorOf :: Path a -> Path b -> Bool

-- | <i>O(h)</i> Compute the lowest common ancestor of two paths
lca :: Path a -> Path b -> Path a

-- | <i>O(h - k)</i> to <tt><a>keep</a> k</tt> elements of <a>Path</a> of
--   <a>length</a> <tt>h</tt>
keep :: Int -> Path a -> Path a

-- | <i>O(k)</i> to <tt><a>drop</a> k</tt> elements from a <a>Path</a>
drop :: Int -> Path a -> Path a

-- | Traverse a <a>Path</a> with access to the node IDs.
traverseWithKey :: Applicative f => (Int -> a -> f b) -> Path a -> f (Path b)

-- | Convert a <a>Path</a> to a list of <tt>(ID, value)</tt> pairs.
toList :: Path a -> [(Int, a)]

-- | Build a <a>Path</a> from a list of <tt>(ID, value)</tt> pairs.
fromList :: [(Int, a)] -> Path a

-- | <i>O(1)</i> Compare to see if two trees have the same leaf key
(~=) :: Path a -> Path b -> Bool
instance Show a => Show (Path a)
instance Read a => Read (Path a)
instance Traversable Path
instance Foldable Path
instance Functor Path


-- | Provides online calculation of the the lowest common ancestor in
--   <i>O(log h)</i> by compressing the spine of a <a>Path</a> using a
--   skew-binary random access list.
--   
--   This library implements the technique described in my talk
--   
--   
--   <a>http://www.slideshare.net/ekmett/skewbinary-online-lowest-common-ancestor-search</a>
--   
--   to improve the known asymptotic bounds on both online lowest common
--   ancestor search
--   
--   <a>http://en.wikipedia.org/wiki/Lowest_common_ancestor</a>
--   
--   and the online level ancestor problem:
--   
--   <a>http://en.wikipedia.org/wiki/Level_ancestor_problem</a>
--   
--   Algorithms used here assume that the key values chosen for <tt>k</tt>
--   are globally unique.
module Data.LCA.Online

-- | Compressed paths using skew binary random access lists
data Path a

-- | <i>O(log h)</i> Compute the lowest common ancestor of two paths.
lca :: Path a -> Path b -> Path a

-- | The <a>empty</a> <a>Path</a>
empty :: Path a

-- | <i>O(1)</i> Invariant: most operations assume that the keys <tt>k</tt>
--   are globally unique
--   
--   Extend the <a>Path</a> with a new node ID and value.
cons :: Int -> a -> Path a -> Path a

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>.
uncons :: Path a -> Maybe (Int, a, Path a)

-- | <i>O(1)</i> Extract the node ID and value from the newest node on the
--   <a>Path</a>, slightly faster than <a>uncons</a>.
view :: Path a -> View Path a

-- | <i>O(1)</i> Returns <a>True</a> iff the path is <a>empty</a>.
null :: Path a -> Bool

-- | <i>O(1)</i> Determine the <a>length</a> of a <a>Path</a>.
length :: Path a -> Int

-- | <i>O(log h)</i> <tt>xs <a>isAncestorOf</a> ys</tt> holds when
--   <tt>xs</tt> is a prefix starting at the root of <a>Path</a>
--   <tt>ys</tt>.
isAncestorOf :: Path a -> Path b -> Bool

-- | <i>O(log (h - k))</i> to <tt><a>keep</a> k</tt> elements of
--   <a>Path</a> of <a>length</a> <tt>h</tt>
--   
--   This solves the online version of the "level ancestor problem" with no
--   preprocessing in <i>O(log h)</i> time, improving known complexity
--   bounds.
--   
--   <a>http://en.wikipedia.org/wiki/Level_ancestor_problem</a>
keep :: Int -> Path a -> Path a

-- | <i>O(log k)</i> to <tt><a>drop</a> k</tt> elements from a <a>Path</a>
drop :: Int -> Path a -> Path a

-- | Traverse a <a>Path</a> with access to the node IDs.
traverseWithKey :: Applicative f => (Int -> a -> f b) -> Path a -> f (Path b)

-- | Convert a <a>Path</a> to a list of <tt>(ID, value)</tt> pairs.
toList :: Path a -> [(Int, a)]

-- | Build a <a>Path</a> from a list of <tt>(ID, value)</tt> pairs.
fromList :: [(Int, a)] -> Path a

-- | <i>O(1)</i> Compare to see if two trees have the same leaf key
(~=) :: Path a -> Path b -> Bool
instance Show a => Show (Tree a)
instance Read a => Read (Tree a)
instance Show a => Show (Path a)
instance Read a => Read (Path a)
instance Traversable Path
instance Foldable Path
instance Functor Path
instance Traversable Tree
instance Foldable Tree
instance Functor Tree
