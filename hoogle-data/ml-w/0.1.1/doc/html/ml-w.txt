-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Minimal ML language to to demonstrate the W type
infererence algorithm.
--   
--   This package implements a minimal ML-like language to demonstrate how
--   the W algorithm works.
--   
--   The <a>ML</a> module contains the definition of the language in the
--   form of an Haskell data type, plus functions to parse files and pretty
--   print the datatype.
--   
--   The <a>TypeInfer</a> module contains the W algorithm itself.
--   
--   The <a>Main</a> module contains a program that parses and typechecks
--   programs reading from standard input.
--   
--   The library and executable is compatible with GHC and Hugs (to use
--   Hugs with cabal use the flag <tt>--hugs</tt>).
@package ml-w
@version 0.1.1


-- | This module defines some datatypes to represent a minimal ML-like
--   language, plus parsing and pretty-printing functions.
--   
--   The syntax is:
--   
--   <pre>
--   program     ::= declaration ';' program | expression
--   declaration ::= id '=' expression ';'
--   id          ::= [a-zA-Z][a-zA-Z0-9_]*
--   ids         ::= id+
--   expression  ::= id
--                |  '(' '\' ids <a>.</a> expression ')'
--                |  '(' expression expression ')'
--                |  '(' 'let' id '=' expression 'in' expression ')'
--                |  '(' <tt>fix</tt> id <a>.</a> expression ')'
--   </pre>
--   
--   We'll omit parenthesis in the usual way - <tt>a b c</tt> is equivalent
--   to <tt>(a b) c</tt>.
--   
--   Example:
--   
--   <pre>
--   s = \ x y z . x z (y z);
--   k = \ x y . x;
--   i = \ x . x;
--   k i;
--   </pre>
module Language.ML.Syntax

-- | An identifier (predictably a <a>String</a>).
type Id = String

-- | Data type representing lambda-calculus expressions.
data Expr

-- | A variable.
Var :: Id -> Expr

-- | A lambda abstraction.
Lam :: Id -> Expr -> Expr

-- | An expression applied to another.
App :: Expr -> Expr -> Expr

-- | Polymorphic let.
Let :: Id -> Expr -> Expr -> Expr

-- | Fixed point combinator (bye bye normalization).
Fix :: Id -> Expr -> Expr

-- | A declaration (binds a certain expression to a variable). We add this
--   abstraction on top of let so that we can write programs more easily
--   (leaving let for local declarations).
type Decl = (Id, Expr)

-- | A <a>Program</a> is a list of declaration and an expression
--   representing what the program does. Each declaration can use previous
--   declarations only (no mutual recursion).
data Program
Program :: [Decl] -> Expr -> Program
parseExpr :: String -> Either ParseError Expr
parseExpr' :: FilePath -> IO (Either ParseError Expr)
parseProgram :: String -> Either ParseError Program
parseProgram' :: FilePath -> IO (Either ParseError Program)
prettyExpr :: Expr -> Doc
prettyDecl :: Decl -> Doc
prettyProgram :: Program -> Doc
instance Eq Expr
instance Eq Program
instance Show Program
instance Show Expr
instance Read Program
instance Read Expr


-- | This module implements the W algorithm for the small language we are
--   using.
--   
--   There is one minor annoyance: The <a>Type</a> datatype distinguishes
--   between free type variables and quantified type variable, but the
--   exposed functions of this module should produce types completely free
--   of free type variables. This could be checked statically having a
--   separate datatype without free type variables, but I compromised for
--   clarity and brevity.
--   
--   Partly inspired by the paper "<i>Typing Haskell in Haskell</i>" by
--   Mark P. Jones, <a>http://web.cecs.pdx.edu/~mpj/thih/</a>.
module Language.ML.TypeCheck

-- | A type variable. We use integers for easy generation of new variables.
type TyVar = Int

-- | A data type to represent types. Note that the functions of this module
--   should return <a>Type</a>s without <a>TyVar</a>s (we want the schemes
--   to have no free variables).
data Type

-- | A type variable.
TyVar :: TyVar -> Type

-- | The arrow type (A -&gt; B)
TyArr :: Type -> Type -> Type

-- | A quantified variable. We use a different constructor (separated from
--   TyVar) so that there can be no clash between the two, and we
--   immediately know what is what.
TyGen :: Int -> Type

-- | A type scheme. The <a>Int</a> represents the number of quantified
--   variables (must be &gt;= 0).
--   
--   Invariants: all the <a>TyGen</a> in the scheme must be &lt; of the
--   <a>Int</a>. If this is not the case the program crashes badly (see
--   <a>freshen</a>).
data Scheme
Scheme :: Int -> Type -> Scheme

-- | An assumption about the type of a (value) variable.
data Assump
(:>:) :: Id -> Scheme -> Assump

-- | What can go wrong when inferring the types.
data TypeError

-- | Unification failed (e.g. when trying to unify a quantified variable
--   with an arrow type).
UnificationFail :: Type -> Type -> TypeError

-- | The user is trying to construct an infinite type, e.g. 'a = a -&gt;
--   b'.
InfiniteType :: TyVar -> Type -> TypeError

-- | Unbound variable (value, not type variable).
UnboundVariable :: Id -> TypeError

-- | Generic error, needed for the <a>Error</a> instances.
TypeError :: TypeError

-- | Types an <a>Expr</a> given a list of <a>Assump</a>. Returns either a
--   <a>TypeError</a> if the algorithm failed or a <a>Scheme</a> if it
--   succeeded.
typeExpr :: [Assump] -> Expr -> Either TypeError Scheme

-- | Types a list of declarations (a <a>Program</a>) returning the
--   principal type for each declaration and the type of the final
--   expression.
typeProgram :: Program -> Either TypeError ([(Id, Scheme)], Scheme)
prettyType :: Type -> Doc
prettyScheme :: Scheme -> Doc
instance Eq Type
instance Eq Scheme
instance Show TypeError
instance Show Scheme
instance Show Type
instance Types Assump
instance MonadInfer (ErrorT TypeError (State [Int]))
instance Error TypeError
instance Types Scheme
instance Types a => Types [a]
instance Types Type


module Language.ML
