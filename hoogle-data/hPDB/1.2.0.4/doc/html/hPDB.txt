-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Protein Databank file format library
--   
--   Protein Data Bank file format is a most popular format for holding
--   biological macromolecular data.
--   
--   This is a very fast sequential parser:
--   
--   <ul>
--   <li>below 7s for the largest entry in PDB - 1HTQ which is over 70MB -
--   as compared with</li>
--   <li>11s of RASMOL 2.7.5,</li>
--   <li>or 2m15s of BioPython with Python 2.6 interpreter.</li>
--   </ul>
--   
--   In its parallel incarnation it is most probably the fastest parser for
--   PDB format.
--   
--   It is aimed to not only deliver event-based interface, but also a
--   high-level data structure for manipulating data in spirit of
--   BioPython's PDB parser.
--   
--   <a>hPDB - Haskell library for processing atomic biomolecular
--   structures in Protein Data Bank format - Michal Jan Gajda. BMC
--   Research Notes 2013, 6:483.</a>
@package hPDB
@version 1.2.0.4


-- | Opening and reading a either normal or gzipped file in an efficient
--   way - either using strict <tt>ByteString</tt> or mmap
module Bio.PDB.IO.OpenAnyFile

-- | Read file contents as strict <tt>ByteString</tt>. Uses mmap if
--   possible. May decompress file contents, if needed.
readFile :: FilePath -> IO ByteString

-- | Write file contents as strict <tt>ByteString</tt>.
writeFile :: FilePath -> (Handle -> IO a) -> IO ()


-- | This module wraps 3D vector operations, and adds missing ones.
module Bio.PDB.Structure.Vector
data Vector3 :: *
[Vector3] :: UnpkScalar -> UnpkScalar -> UnpkScalar -> Vector3
[v3x] :: Vector3 -> UnpkScalar
[v3y] :: Vector3 -> UnpkScalar
[v3z] :: Vector3 -> UnpkScalar

-- | Unpacks an abstract 3D vector into a triple of <a>Double</a>s.
unpackVector3 :: Vector3 -> (Double, Double, Double)

-- | Normalises to a unit vector in the same direction as input.
vnormalise :: Vector3 -> Vector3

-- | Computes a dot product of two 3D vectors.
vdot :: Vector3 -> Vector3 -> Double

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(*|) :: Double -> Vector3 -> Vector3

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(|*) :: Vector3 -> Double -> Vector3

-- | Maps an operation on a pair of <a>Double</a>s onto a pair of 3D
--   vectors coordinatewise.
vzip :: (Double -> Double -> Double) -> Vector3 -> Vector3 -> Vector3

-- | Maps an operation that modifies a <a>Double</a> onto a 3D vector.
vmap :: (Double -> Double) -> Vector3 -> Vector3

-- | 2-norm of a vector (also called a magnitude or length.)
vnorm :: Vector3 -> Double

-- | Finds a vector component of the first vector that is a projection onto
--   direction of second vector.
vproj :: Vector3 -> Vector3 -> Vector3

-- | Returns a component of the vector v that is perpendicular to w.
vperpend :: Vector3 -> Vector3 -> Vector3

-- | Finds a component of the vector v that is perpendicular to all vectors
--   in a list.
vperpends :: Foldable t => Vector3 -> t Vector3 -> Vector3

-- | Compute dihedral between three bond vectors using spherical angle
--   formula.
vdihedral :: Vector3 -> Vector3 -> Vector3 -> Double
instance Arbitrary Vector3


-- | Collections used within the Structure, currently aliases for the
--   <tt>Vector</tt> and <tt>MVector</tt> types.
module Bio.PDB.Structure.List

-- | Type alias for a immutable sequence of elements.
type List a = Vector a

-- | Type alias for a mutable sequence of elements.
data TempList m a

-- | Allocate initial space for a new mutable vector.
initialNew :: Int -> ST m (TempList m a)

-- | Create a new mutable vector.
new :: MonadTrans t => Int -> t (ST m) (TempList m a)

-- | Appends an element to a mutable vector.
add :: MonadTrans t => TempList s a -> a -> t (ST s) ()

-- | Finalizes a mutable vector, and returns immutable vector. [Does it
--   shrink allocated space?]
finalize :: MonadTrans t => TempList s a -> t (ST s) (Vector a)

-- | Length of mutable vector.
tempLength :: MonadTrans t1 => TempList s t -> t1 (ST s) Int

-- | Empty vector.
empty :: Vector a

-- | <a>last</a> on immutable vectors.
last :: Vector a -> a

-- | Vector with a single element
singleton :: a -> Vector a

-- | <a>map</a> on immutable vectors.
map :: (a -> b) -> Vector a -> Vector b

-- | <a>mapM</a> on immutable vectors.
mapM :: Monad m => (a -> m b) -> Vector a -> m (Vector b)

-- | <a>foldl</a> on immutable vectors.
foldl :: (a -> b -> a) -> a -> Vector b -> a

-- | <a>foldl'</a> on immutable vectors.
foldl' :: (a -> b -> a) -> a -> Vector b -> a

-- | <a>foldr</a> on immutable vectors.
foldr :: (a -> b -> b) -> b -> Vector a -> b

-- | <a>foldM</a> on immutable vectors.
foldM :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a

-- | <a>filter</a> on immutable vectors.
filter :: (a -> Bool) -> Vector a -> Vector a

-- | <a>length</a> on immutable vectors.
length :: Vector a -> Int

-- | Default initial size of a mutable vector for structure contents.
defaultSize :: Num a => a

-- | Default initial size of a mutable vector for residue contents.
residueVectorSize :: Num a => a

-- | Default initial size of a mutable vector for chain contents.
chainVectorSize :: Num a => a

-- | Conversion of an immutable vector to list.
toList :: Vector a -> [a]

-- | <a>map</a> on immutable vectors.
vimap :: (Int -> a -> b) -> Vector a -> Vector b

-- | Indexing of an immutable vector.
(!) :: Vector a -> Int -> a

-- | Concatenation of two immutable
(++) :: Vector a -> Vector a -> Vector a

-- | Concatenation of a list of immutable vectors.
concat :: [Vector a] -> Vector a

-- | Remove last element of immutable vectors.
init :: Vector a -> Vector a

-- | Remove first element of immutable vector.
tail :: Vector a -> Vector a

-- | First element of immutable vector.
head :: Vector a -> a
instance NFData (TempList m a)


-- | Module with enumeration of beta-strand senses.
module Bio.PDB.EventParser.StrandSense

-- | Enumeration of beta-strand sense.
data StrandSenseT
[Parallel] :: StrandSenseT
[Antiparallel] :: StrandSenseT
instance Read StrandSenseT
instance Show StrandSenseT
instance Ord StrandSenseT
instance Eq StrandSenseT


-- | Module contains enumeration of helix types, and auxiliary functions
--   for converting these into PDB CLASS codes.
module Bio.PDB.EventParser.HelixTypes

-- | Enumeration of helix types
--   
--   PDB Class number in columns 39-40 for each type of helix in HELIX
--   record:
--   
--   <ol>
--   <li>Right-handed alpha (default, most common)</li>
--   <li>Right-handed omega</li>
--   <li>Right-handed pi</li>
--   <li>Right-handed gamma</li>
--   <li>Right-handed 3 - 10</li>
--   <li>Left-handed alpha</li>
--   <li>Left-handed omega</li>
--   <li>Left-handed gamma</li>
--   <li>2 - 7 ribbon/helix</li>
--   <li>Polyproline</li>
--   </ol>
data HelixT

-- | helix2code converts a <a>HelixT</a> enumeration into an PDB CLASS
--   code.
helix2code :: Num a => HelixT -> a

-- | helix2code converts an PDB CLASS code into a <a>HelixT</a>
--   enumeration.
code2helix :: (Eq a, Num a) => a -> HelixT
instance Read HelixT
instance Show HelixT
instance Ord HelixT
instance Eq HelixT


-- | This module contains an enumeration of experimental methods.
module Bio.PDB.EventParser.ExperimentalMethods

-- | Enumeration of experimental methods occuring in the PDB archive.
data ExpMethod
[XRayDiffraction] :: ExpMethod
[FiberDiffraction] :: ExpMethod
[NeutronDiffraction] :: ExpMethod
[ElectronCrystallography] :: ExpMethod
[ElectronMicroscopy] :: ExpMethod
[SolidStateNMR] :: ExpMethod
[SolutionNMR] :: ExpMethod
[SolutionScattering] :: ExpMethod
[OtherExpMethod] :: !ByteString -> ExpMethod

-- | Generates an <a>ExpMethod</a> from words in PDB
mkExpMethod :: [ByteString] -> ExpMethod

-- | Converts an <a>ExpMethod</a> back into text
showExpMethod :: ExpMethod -> ByteString
instance Ord ExpMethod
instance Eq ExpMethod
instance Read ExpMethod
instance Show ExpMethod


-- | This module contains datatype declaration for PDB parsing events
--   generated by <tt>PDBEventParser</tt> module.
module Bio.PDB.EventParser.PDBEvents

-- | We use only strict <tt>ByteString</tt> as strings in PDB parser.
type String = ByteString
data Vector3 :: *
[Vector3] :: UnpkScalar -> UnpkScalar -> UnpkScalar -> Vector3
[v3x] :: Vector3 -> UnpkScalar
[v3y] :: Vector3 -> UnpkScalar
[v3z] :: Vector3 -> UnpkScalar

-- | Atom id: atom name, residue name, chain, residue id, residue insertion
--   code
newtype ATID
[ATID] :: (String, String, Char, Int, Char) -> ATID

-- | Residue id: residue name, chain, residue id, residue insertion code
newtype RESID
[RESID] :: (String, Char, Int, Char) -> RESID

-- | Datatype for event-based PDB parser
data PDBEvent
[ATOM] :: !Int -> !String -> !String -> !Char -> !Int -> !Char -> !Char -> !Vector3 -> !Double -> !Double -> !String -> !String -> !String -> !Bool -> PDBEvent
[no] :: PDBEvent -> !Int
[atomtype] :: PDBEvent -> !String
[restype] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[resid] :: PDBEvent -> !Int
[resins] :: PDBEvent -> !Char
[altloc] :: PDBEvent -> !Char
[coords] :: PDBEvent -> !Vector3
[occupancy] :: PDBEvent -> !Double
[bfactor] :: PDBEvent -> !Double
[segid] :: PDBEvent -> !String
[elt] :: PDBEvent -> !String
[charge] :: PDBEvent -> !String
[hetatm] :: PDBEvent -> !Bool
[SIGATM] :: !Int -> !String -> !String -> !Char -> !Int -> !Char -> !Char -> !Vector3 -> !Double -> !Double -> !String -> !String -> !String -> PDBEvent
[no] :: PDBEvent -> !Int
[atomtype] :: PDBEvent -> !String
[restype] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[resid] :: PDBEvent -> !Int
[resins] :: PDBEvent -> !Char
[altloc] :: PDBEvent -> !Char
[coords] :: PDBEvent -> !Vector3
[occupancy] :: PDBEvent -> !Double
[bfactor] :: PDBEvent -> !Double
[segid] :: PDBEvent -> !String
[elt] :: PDBEvent -> !String
[charge] :: PDBEvent -> !String
[ANISOU] :: !Int -> !String -> !String -> !Char -> !Int -> !Char -> !Char -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !String -> !String -> !String -> PDBEvent
[no] :: PDBEvent -> !Int
[atomtype] :: PDBEvent -> !String
[restype] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[resid] :: PDBEvent -> !Int
[resins] :: PDBEvent -> !Char
[altloc] :: PDBEvent -> !Char
[u_1_1] :: PDBEvent -> !Int
[u_2_2] :: PDBEvent -> !Int
[u_3_3] :: PDBEvent -> !Int
[u_1_2] :: PDBEvent -> !Int
[u_1_3] :: PDBEvent -> !Int
[u_2_3] :: PDBEvent -> !Int
[segid] :: PDBEvent -> !String
[elt] :: PDBEvent -> !String
[charge] :: PDBEvent -> !String
[SIGUIJ] :: !Int -> !String -> !String -> !Char -> !Int -> !Char -> !Char -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !String -> !String -> !String -> PDBEvent
[no] :: PDBEvent -> !Int
[atomtype] :: PDBEvent -> !String
[restype] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[resid] :: PDBEvent -> !Int
[resins] :: PDBEvent -> !Char
[altloc] :: PDBEvent -> !Char
[u_1_1] :: PDBEvent -> !Int
[u_2_2] :: PDBEvent -> !Int
[u_3_3] :: PDBEvent -> !Int
[u_1_2] :: PDBEvent -> !Int
[u_1_3] :: PDBEvent -> !Int
[u_2_3] :: PDBEvent -> !Int
[segid] :: PDBEvent -> !String
[elt] :: PDBEvent -> !String
[charge] :: PDBEvent -> !String
[SEQRES] :: !Int -> !Char -> !Int -> ![String] -> PDBEvent
[serial] :: PDBEvent -> !Int
[chain] :: PDBEvent -> !Char
[num] :: PDBEvent -> !Int
[resList] :: PDBEvent -> ![String]
[HEADER] :: !String -> !String -> !String -> PDBEvent
[classification] :: PDBEvent -> !String
[depDate] :: PDBEvent -> !String
[idCode] :: PDBEvent -> !String
[TITLE] :: !Int -> !String -> PDBEvent
[continuation] :: PDBEvent -> !Int
[title] :: PDBEvent -> !String
[KEYWDS] :: !Int -> ![String] -> PDBEvent
[continuation] :: PDBEvent -> !Int
[aList] :: PDBEvent -> ![String]
[AUTHOR] :: !Int -> ![String] -> PDBEvent
[continuation] :: PDBEvent -> !Int
[aList] :: PDBEvent -> ![String]
[REMARK] :: !Int -> ![String] -> PDBEvent
[num] :: PDBEvent -> !Int
[text] :: PDBEvent -> ![String]
[EXPDTA] :: !Int -> ![ExpMethod] -> PDBEvent
[continuation] :: PDBEvent -> !Int
[expMethods] :: PDBEvent -> ![ExpMethod]
[MDLTYP] :: !Int -> ![String] -> PDBEvent
[continuation] :: PDBEvent -> !Int
[aList] :: PDBEvent -> ![String]
[NUMMDL] :: !Int -> PDBEvent
[num] :: PDBEvent -> !Int
[MODEL] :: !Int -> PDBEvent
[num] :: PDBEvent -> !Int
[CONECT] :: ![Int] -> PDBEvent
[atoms] :: PDBEvent -> ![Int]
[CAVEAT] :: !Int -> !String -> !String -> PDBEvent
[cont] :: PDBEvent -> !Int
[pdbid] :: PDBEvent -> !String
[comment] :: PDBEvent -> !String
[DBREF] :: !String -> !Char -> !Int -> !Char -> !Int -> !Char -> !String -> !String -> !String -> !Int -> !Char -> !Int -> !Char -> PDBEvent
[idCode] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[iniSeqNumPDB] :: PDBEvent -> !Int
[iniInsCodePDB] :: PDBEvent -> !Char
[endSeqNumPDB] :: PDBEvent -> !Int
[endInsCodePDB] :: PDBEvent -> !Char
[seqDbName] :: PDBEvent -> !String
[seqDbAccCode] :: PDBEvent -> !String
[seqDbIdCode] :: PDBEvent -> !String
[iniSeqNumInDb] :: PDBEvent -> !Int
[iniInsCodeInPDBRef] :: PDBEvent -> !Char
[endSeqNumInDb] :: PDBEvent -> !Int
[endInsCodeInPDBRef] :: PDBEvent -> !Char
[REVDAT] :: !Int -> !Int -> !String -> !String -> !Int -> ![String] -> PDBEvent
[modNum] :: PDBEvent -> !Int
[cont] :: PDBEvent -> !Int
[modDat] :: PDBEvent -> !String
[modId] :: PDBEvent -> !String
[modTyp] :: PDBEvent -> !Int
[details] :: PDBEvent -> ![String]
[HETNAM] :: !Int -> !String -> !String -> !Bool -> PDBEvent
[cont] :: PDBEvent -> !Int
[hetId] :: PDBEvent -> !String
[name] :: PDBEvent -> !String
[notSynonym] :: PDBEvent -> !Bool
[HET] :: !String -> !Char -> !Int -> !Char -> !Int -> !String -> PDBEvent
[hetId] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[seqNum] :: PDBEvent -> !Int
[insCode] :: PDBEvent -> !Char
[atmNum] :: PDBEvent -> !Int
[description] :: PDBEvent -> !String
[FORMUL] :: !Int -> !String -> !Int -> !Bool -> ![String] -> PDBEvent
[compNum] :: PDBEvent -> !Int
[hetId] :: PDBEvent -> !String
[cont] :: PDBEvent -> !Int
[isWater] :: PDBEvent -> !Bool
[formula] :: PDBEvent -> ![String]
[CISPEP] :: !Int -> !RESID -> !RESID -> !Int -> Maybe Double -> PDBEvent
[serial] :: PDBEvent -> !Int
[res1] :: PDBEvent -> !RESID
[res2] :: PDBEvent -> !RESID
[modNum] :: PDBEvent -> !Int
[angle] :: PDBEvent -> Maybe Double
[HELIX] :: Int -> RESID -> RESID -> HelixT -> String -> Int -> PDBEvent
[serial] :: PDBEvent -> Int
[iniRes] :: PDBEvent -> RESID
[endRes] :: PDBEvent -> RESID
[helixClass] :: PDBEvent -> HelixT
[comment] :: PDBEvent -> String
[len] :: PDBEvent -> Int
[SHEET] :: Int -> String -> Int -> Maybe StrandSenseT -> RESID -> RESID -> Maybe ATID -> Maybe ATID -> PDBEvent
[strandId] :: PDBEvent -> Int
[sheetId] :: PDBEvent -> String
[numStrands] :: PDBEvent -> Int
[sense] :: PDBEvent -> Maybe StrandSenseT
[iniRes] :: PDBEvent -> RESID
[endRes] :: PDBEvent -> RESID
[curAt] :: PDBEvent -> Maybe ATID
[prevAt] :: PDBEvent -> Maybe ATID
[ORIGXn] :: Int -> [Vector3] -> [Double] -> PDBEvent
[n] :: PDBEvent -> Int
[o] :: PDBEvent -> [Vector3]
[t] :: PDBEvent -> [Double]
[SCALEn] :: Int -> [Vector3] -> [Double] -> PDBEvent
[n] :: PDBEvent -> Int
[o] :: PDBEvent -> [Vector3]
[t] :: PDBEvent -> [Double]
[MTRIXn] :: !Int -> !Bool -> !Int -> ![Vector3] -> ![Double] -> PDBEvent
[serial] :: PDBEvent -> !Int
[relMol] :: PDBEvent -> !Bool
[n] :: PDBEvent -> !Int
[o] :: PDBEvent -> ![Vector3]
[t] :: PDBEvent -> ![Double]
[CRYST1] :: !Double -> !Double -> !Double -> !Double -> !Double -> !Double -> !String -> !Int -> PDBEvent
[a] :: PDBEvent -> !Double
[b] :: PDBEvent -> !Double
[c] :: PDBEvent -> !Double
[alpha] :: PDBEvent -> !Double
[beta] :: PDBEvent -> !Double
[gamma] :: PDBEvent -> !Double
[spcGrp] :: PDBEvent -> !String
[zValue] :: PDBEvent -> !Int
[COMPND] :: !Int -> ![(String, String)] -> PDBEvent
[cont] :: PDBEvent -> !Int
[tokens] :: PDBEvent -> ![(String, String)]
[SOURCE] :: !Int -> ![(String, String)] -> PDBEvent
[cont] :: PDBEvent -> !Int
[tokens] :: PDBEvent -> ![(String, String)]
[TER] :: !Int -> !String -> !Char -> !Int -> !Char -> PDBEvent
[num] :: PDBEvent -> !Int
[resname] :: PDBEvent -> !String
[chain] :: PDBEvent -> !Char
[resid] :: PDBEvent -> !Int
[insCode] :: PDBEvent -> !Char
[MASTER] :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> PDBEvent
[numRemark] :: PDBEvent -> !Int
[numHet] :: PDBEvent -> !Int
[numHelix] :: PDBEvent -> !Int
[numSheet] :: PDBEvent -> !Int
[numTurn] :: PDBEvent -> !Int
[numSite] :: PDBEvent -> !Int
[numXform] :: PDBEvent -> !Int
[numAts] :: PDBEvent -> !Int
[numMaster] :: PDBEvent -> !Int
[numConect] :: PDBEvent -> !Int
[numSeqres] :: PDBEvent -> !Int
[END] :: PDBEvent
[ENDMDL] :: PDBEvent
[SITE] :: !Int -> !String -> !Int -> ![RESID] -> PDBEvent
[serial] :: PDBEvent -> !Int
[siteid] :: PDBEvent -> !String
[numres] :: PDBEvent -> !Int
[residues] :: PDBEvent -> ![RESID]
[OBSLTE] :: !Int -> !String -> !String -> ![String] -> PDBEvent
[cont] :: PDBEvent -> !Int
[date] :: PDBEvent -> !String
[this] :: PDBEvent -> !String
[entries] :: PDBEvent -> ![String]
[SPRSDE] :: !Int -> !String -> !String -> ![String] -> PDBEvent
[cont] :: PDBEvent -> !Int
[date] :: PDBEvent -> !String
[this] :: PDBEvent -> !String
[entries] :: PDBEvent -> ![String]
[SPLIT] :: !Int -> ![String] -> PDBEvent
[cont] :: PDBEvent -> !Int
[codes] :: PDBEvent -> ![String]
[SSBOND] :: !Int -> RESID -> RESID -> !String -> !String -> !Double -> PDBEvent
[serial] :: PDBEvent -> !Int
[res1] :: PDBEvent -> RESID
[res2] :: PDBEvent -> RESID
[symOp1] :: PDBEvent -> !String
[symOp2] :: PDBEvent -> !String
[bondLen] :: PDBEvent -> !Double
[LINK] :: !ATID -> !Char -> !ATID -> !Char -> !String -> !String -> Maybe Double -> PDBEvent
[at1] :: PDBEvent -> !ATID
[altloc1] :: PDBEvent -> !Char
[at2] :: PDBEvent -> !ATID
[altloc2] :: PDBEvent -> !Char
[symop1] :: PDBEvent -> !String
[symop2] :: PDBEvent -> !String
[linkdist] :: PDBEvent -> Maybe Double
[SLTBRG] :: !ATID -> !Char -> !ATID -> !Char -> !String -> !String -> PDBEvent
[at1] :: PDBEvent -> !ATID
[altloc1] :: PDBEvent -> !Char
[at2] :: PDBEvent -> !ATID
[altloc2] :: PDBEvent -> !Char
[symOp1] :: PDBEvent -> !String
[symOp2] :: PDBEvent -> !String
[HYDBND] :: !ATID -> !Char -> !ATID -> !Char -> !ATID -> !Char -> !String -> !String -> PDBEvent
[at1] :: PDBEvent -> !ATID
[altloc1] :: PDBEvent -> !Char
[atH] :: PDBEvent -> !ATID
[altlocH] :: PDBEvent -> !Char
[at2] :: PDBEvent -> !ATID
[altloc2] :: PDBEvent -> !Char
[symOp1] :: PDBEvent -> !String
[symOp2] :: PDBEvent -> !String
[TVECT] :: !Int -> Vector3 -> PDBEvent
[serial] :: PDBEvent -> !Int
[vec] :: PDBEvent -> Vector3
[JRNL] :: !Int -> ![(String, String)] -> !Bool -> PDBEvent
[cont] :: PDBEvent -> !Int
[content] :: PDBEvent -> ![(String, String)]
[isFirst] :: PDBEvent -> !Bool
[MODRES] :: !String -> !RESID -> !String -> !String -> PDBEvent
[pdbCode] :: PDBEvent -> !String
[residue] :: PDBEvent -> !RESID
[stdRes] :: PDBEvent -> !String
[comment] :: PDBEvent -> !String
[SEQADV] :: !String -> Maybe RESID -> !String -> !String -> !String -> Maybe Int -> !String -> PDBEvent
[pdbId] :: PDBEvent -> !String
[advResidue] :: PDBEvent -> Maybe RESID
[database] :: PDBEvent -> !String
[accessionCode] :: PDBEvent -> !String
[dbResname] :: PDBEvent -> !String
[dbSeqNum] :: PDBEvent -> Maybe Int
[comment] :: PDBEvent -> !String
[PDBParseError] :: !Int -> !Int -> !String -> PDBEvent
[PDBIgnoredLine] :: ByteString -> PDBEvent

-- | Enumeration of beta-strand sense.
data StrandSenseT
[Parallel] :: StrandSenseT
[Antiparallel] :: StrandSenseT

-- | Enumeration of helix types
--   
--   PDB Class number in columns 39-40 for each type of helix in HELIX
--   record:
--   
--   <ol>
--   <li>Right-handed alpha (default, most common)</li>
--   <li>Right-handed omega</li>
--   <li>Right-handed pi</li>
--   <li>Right-handed gamma</li>
--   <li>Right-handed 3 - 10</li>
--   <li>Left-handed alpha</li>
--   <li>Left-handed omega</li>
--   <li>Left-handed gamma</li>
--   <li>2 - 7 ribbon/helix</li>
--   <li>Polyproline</li>
--   </ol>
data HelixT

-- | Enumeration of experimental methods occuring in the PDB archive.
data ExpMethod
[XRayDiffraction] :: ExpMethod
[FiberDiffraction] :: ExpMethod
[NeutronDiffraction] :: ExpMethod
[ElectronCrystallography] :: ExpMethod
[ElectronMicroscopy] :: ExpMethod
[SolidStateNMR] :: ExpMethod
[SolutionNMR] :: ExpMethod
[SolutionScattering] :: ExpMethod
[OtherExpMethod] :: !ByteString -> ExpMethod
instance Eq PDBEvent
instance Show PDBEvent
instance Eq RESID
instance Ord RESID
instance Show RESID
instance Eq ATID
instance Ord ATID
instance Show ATID


-- | Low-level event-based parser interface.
module Bio.PDB.EventParser.PDBEventParser

-- | Parses a strict ByteString <tt>contents</tt> named <tt>fname</tt> and
--   performs <tt>action</tt> on events given by parsing chunks, returning
--   accumulated results. Accumulator is primed by <tt>acc</tt>.
parsePDBRecords :: Monad m => t -> ByteString -> (t1 -> PDBEvent -> m t1) -> t1 -> m t1


-- | Module defines all components of high-level data type description of
--   PDB model.
module Bio.PDB.Structure

-- | We use only strict <tt>ByteString</tt> as strings in PDB parser.
type String = ByteString

-- | Computes a dot product of two 3D vectors.
vdot :: Vector3 -> Vector3 -> Double

-- | 2-norm of a vector (also called a magnitude or length.)
vnorm :: Vector3 -> Double

-- | Finds a vector component of the first vector that is a projection onto
--   direction of second vector.
vproj :: Vector3 -> Vector3 -> Vector3

-- | Returns a component of the vector v that is perpendicular to w.
vperpend :: Vector3 -> Vector3 -> Vector3

-- | Finds a component of the vector v that is perpendicular to all vectors
--   in a list.
vperpends :: Foldable t => Vector3 -> t Vector3 -> Vector3

-- | Compute dihedral between three bond vectors using spherical angle
--   formula.
vdihedral :: Vector3 -> Vector3 -> Vector3 -> Double

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(*|) :: Double -> Vector3 -> Vector3

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(|*) :: Vector3 -> Double -> Vector3

-- | Structure holds all data parsed from a single PDB entry
data Structure
[Structure] :: List Model -> Structure
[models] :: Structure -> List Model

-- | PDB entry may contain multiple models, with slight differences in
--   coordinates etc.
data Model
[Model] :: !Int -> List Chain -> Model
[modelId] :: Model -> !Int
[chains] :: Model -> List Chain

-- | Single linear polymer chain of protein, or nucleic acids
data Chain
[Chain] :: !Char -> List Residue -> Chain
[chainId] :: Chain -> !Char
[residues] :: Chain -> List Residue

-- | Residue groups all atoms assigned to the same aminoacid or nucleic
--   acid base within a polymer chain.
data Residue
[Residue] :: !String -> !Int -> List Atom -> !Char -> Residue
[resName] :: Residue -> !String
[resSeq] :: Residue -> !Int
[atoms] :: Residue -> List Atom
[insCode] :: Residue -> !Char

-- | Single atom position | NOTE: disordered atoms are now reported as
--   multiplicates
data Atom
[Atom] :: !String -> !Int -> !Vector3 -> !Double -> !Double -> !String -> !String -> !String -> !Bool -> Atom
[atName] :: Atom -> !String
[atSerial] :: Atom -> !Int
[coord] :: Atom -> !Vector3
[bFactor] :: Atom -> !Double
[occupancy] :: Atom -> !Double
[element] :: Atom -> !String
[segid] :: Atom -> !String
[charge] :: Atom -> !String
[hetatm] :: Atom -> !Bool
instance Selector S1_0_0Structure
instance Constructor C1_0Structure
instance Datatype D1Structure
instance Selector S1_0_1Model
instance Selector S1_0_0Model
instance Constructor C1_0Model
instance Datatype D1Model
instance Selector S1_0_1Chain
instance Selector S1_0_0Chain
instance Constructor C1_0Chain
instance Datatype D1Chain
instance Selector S1_0_3Residue
instance Selector S1_0_2Residue
instance Selector S1_0_1Residue
instance Selector S1_0_0Residue
instance Constructor C1_0Residue
instance Datatype D1Residue
instance Selector S1_0_8Atom
instance Selector S1_0_7Atom
instance Selector S1_0_6Atom
instance Selector S1_0_5Atom
instance Selector S1_0_4Atom
instance Selector S1_0_3Atom
instance Selector S1_0_2Atom
instance Selector S1_0_1Atom
instance Selector S1_0_0Atom
instance Constructor C1_0Atom
instance Datatype D1Atom
instance Generic Structure
instance Show Structure
instance Eq Structure
instance Generic Model
instance Show Model
instance Eq Model
instance Generic Chain
instance Show Chain
instance Eq Chain
instance Generic Residue
instance Show Residue
instance Eq Residue
instance Generic Atom
instance Show Atom
instance Eq Atom
instance NFData Structure
instance NFData Model
instance NFData Chain
instance NFData Residue
instance NFData Atom


-- | Iterable instances and convenience functions.
module Bio.PDB.Iterable

-- | Class for iterating all nested components <tt>b</tt> of type
--   <tt>a</tt>.
class Iterable a b
itmapM :: (Iterable a b, Monad m) => (b -> m b) -> a -> m a
itmap :: Iterable a b => (b -> b) -> a -> a
itfoldM :: (Iterable a b, Monad m) => (c -> b -> m c) -> c -> a -> m c
itfoldr :: Iterable a b => (b -> c -> c) -> c -> a -> c
itfoldl :: Iterable a b => (c -> b -> c) -> c -> a -> c
itfoldl' :: Iterable a b => (c -> b -> c) -> c -> a -> c
itlength :: Iterable a b => Proxy * b -> a -> Int

-- | Takes a first model.
firstModel :: (Iterable a Model) => a -> Maybe Model

-- | Number of all atoms within the structure.
numAtoms :: Iterable a Atom => a -> Int

-- | Number of all residues within the structure.
numResidues :: Iterable a Residue => a -> Int

-- | Number of all chains within the structure.
numChains :: Iterable a Chain => a -> Int

-- | Number of all models within the structure.
numModels :: Iterable a Model => a -> Int


-- | Conversion of PDB residue codes to FASTA single-letter sequence codes.
module Bio.PDB.Fasta

-- | Dictionary mapping three-letter PDB residue code to a single-letter
--   FASTA code.
resname2fastacode :: String -> Char

-- | Dictionary mapping single-letter FASTA standard aminoacid code to a
--   PDB residue name
fastacode2resname :: Char -> String

-- | Three-letter PDB code for an unknown type of residue.
defaultResname :: String

-- | One-letter aminoacid code for an unknown type of residue.
defaultFastaCode :: Char

-- | Converts an <a>Iterable</a> yielding <a>Residue</a>s into a list of
--   aminoacid one-character codes.
fastaSequence :: (Iterable a Residue) => a -> [Char]

-- | Converts an <a>Iterable</a> yielding <a>Residue</a>s into a list of
--   aminoacid one-character codes.
fastaGappedSequence :: (Iterable a Residue) => a -> [Char]

-- | Returns <a>String</a> with ungapped sequence of a given PDB
--   <a>Chain</a>.
fastaRecord :: [Char] -> Chain -> [Char]

-- | Returns <a>String</a> with gapped sequence of a given PDB
--   <a>Chain</a>. Gaps are placed to assure consistent numbering of
--   residues and indices in the output <a>String</a>.
fastaGappedRecord :: [Char] -> Chain -> [Char]


-- | Basic properties of chemical <a>Element</a>s as suggested by Cambridge
--   Structural Database.
module Bio.PDB.Structure.Elements

-- | Type alias for <a>Element</a> names.
type Element = ByteString

-- | Given a PDB <a>Atom</a> extract or guess its <a>Element</a> name.
assignElement :: Atom -> Element

-- | Guessing an <a>Element</a> name from PDB <a>Atom</a> name. Returns
--   empty string, if <a>Element</a> can't be guessed.
guessElement :: ByteString -> Element

-- | Atomic number of a given element
atomicNumber :: Element -> Int

-- | Atomic mass of a given element in g/mol
atomicMass :: Element -> Double

-- | Covalent radius of an element with a given name.
covalentRadius :: (Eq a1, Fractional a, Show a1, IsString a1) => a1 -> a

-- | Upper bound of <tt>covalentRadius</tt>.
maxCovalentRadius :: Double

-- | Van der Waals radius of the given element
vanDerWaalsRadius :: Element -> Double

-- | Upper bound of <tt>vanDerWaalsRadius</tt>.
maxVanDerWaalsRadius :: Double


-- | Searching for neighbouring atoms in a 3D space using <tt>Octree</tt>.
module Bio.PDB.Structure.Neighbours

-- | Make an Octree of <a>Atom</a>s
makeOctree :: Iterable a Atom => a -> AtomOctree

-- | Find all <a>Atom</a>s within a given radius from a point.
findInRadius :: AtomOctree -> Double -> Vector3 -> [(Vector3, Atom)]

-- | Find an <a>Atom</a>s closest to a point.
findNearest :: AtomOctree -> Vector3 -> Maybe (Vector3, Atom)

-- | Octree of <a>Atom</a>s.
type AtomOctree = Octree Atom


-- | Front-end module presenting minimal interface for serial and parallel
--   parsing.
module Bio.PDB.StructureBuilder

-- | Default parser - uses parallel capabilities, if available.
parse :: FilePath -> String -> (Structure, List PDBEvent)

-- | Given filename, and contents, parses a whole PDB file, returning a
--   monadic action | with a tuple of (Structure, [PDBEvent]), where the
--   list of events contains all | parsing or construction errors.
parseSerial :: FilePath -> String -> (Structure, List PDBEvent)

-- | Parse file in parallel with as many threads as we have capabilities.
parseParallel :: FilePath -> ByteString -> (Structure, List PDBEvent)

-- | Parse input file with N parallel threads.
parseWithNParallel :: Integral a => a -> FilePath -> ByteString -> (Structure, List PDBEvent)


-- | Low-level output routines: printing any <a>PDBEvent</a>.
module Bio.PDB.EventParser.PDBEventPrinter

-- | Prints a PDBEvent to a filehandle.
print :: Handle -> PDBEvent -> IO ()

-- | Reports whether a given PDB record is already printable [temporary
--   method, they all should be.] Including errors.
isPrintable :: PDBEvent -> Bool


-- | High-level output routines for <a>Structure</a>.
module Bio.PDB.StructurePrinter

-- | Writes a structure or its part in a PDB format to a filehandle.
write :: PDBWritable a => Handle -> a -> IO ()

-- | Class generating events for PDB structure fragments.
class PDBWritable a where pdbEvents = flip pdbEventS []
instance PDBWritable Structure
instance PDBWritable Model
instance PDBWritable Chain
instance PDBWritable Residue
instance PDBWritable Atom


-- | Simple input/output wrappers taking filenames, and handling
--   compression.
module Bio.PDB.IO

-- | Parse a .pdb file and return <a>Structure</a>.
parse :: FilePath -> IO (Maybe Structure)

-- | Write structure to a .pdb file.
write :: PDBWritable a => a -> FilePath -> IO ()

-- | Class generating events for PDB structure fragments.
class PDBWritable a where pdbEvents = flip pdbEventS []


-- | Default interface for <tt>Bio.PDB</tt> package. Ideally should expose
--   all commonly used functions and classes.
module Bio.PDB

-- | Parse a .pdb file and return <a>Structure</a>.
parse :: FilePath -> IO (Maybe Structure)

-- | Write structure to a .pdb file.
write :: PDBWritable a => a -> FilePath -> IO ()

-- | Class generating events for PDB structure fragments.
class PDBWritable a where pdbEvents = flip pdbEventS []

-- | Structure holds all data parsed from a single PDB entry
data Structure
[Structure] :: List Model -> Structure
[models] :: Structure -> List Model

-- | PDB entry may contain multiple models, with slight differences in
--   coordinates etc.
data Model
[Model] :: !Int -> List Chain -> Model
[modelId] :: Model -> !Int
[chains] :: Model -> List Chain

-- | Single linear polymer chain of protein, or nucleic acids
data Chain
[Chain] :: !Char -> List Residue -> Chain
[chainId] :: Chain -> !Char
[residues] :: Chain -> List Residue

-- | Residue groups all atoms assigned to the same aminoacid or nucleic
--   acid base within a polymer chain.
data Residue
[Residue] :: !String -> !Int -> List Atom -> !Char -> Residue
[resName] :: Residue -> !String
[resSeq] :: Residue -> !Int
[atoms] :: Residue -> List Atom
[insCode] :: Residue -> !Char

-- | Single atom position | NOTE: disordered atoms are now reported as
--   multiplicates
data Atom
[Atom] :: !String -> !Int -> !Vector3 -> !Double -> !Double -> !String -> !String -> !String -> !Bool -> Atom
[atName] :: Atom -> !String
[atSerial] :: Atom -> !Int
[coord] :: Atom -> !Vector3
[bFactor] :: Atom -> !Double
[occupancy] :: Atom -> !Double
[element] :: Atom -> !String
[segid] :: Atom -> !String
[charge] :: Atom -> !String
[hetatm] :: Atom -> !Bool

-- | Class for iterating all nested components <tt>b</tt> of type
--   <tt>a</tt>.
class Iterable a b
itmapM :: (Iterable a b, Monad m) => (b -> m b) -> a -> m a
itmap :: Iterable a b => (b -> b) -> a -> a
itfoldM :: (Iterable a b, Monad m) => (c -> b -> m c) -> c -> a -> m c
itfoldr :: Iterable a b => (b -> c -> c) -> c -> a -> c
itfoldl :: Iterable a b => (c -> b -> c) -> c -> a -> c
itfoldl' :: Iterable a b => (c -> b -> c) -> c -> a -> c
itlength :: Iterable a b => Proxy * b -> a -> Int

-- | Number of all atoms within the structure.
numAtoms :: Iterable a Atom => a -> Int

-- | Number of all residues within the structure.
numResidues :: Iterable a Residue => a -> Int

-- | Number of all chains within the structure.
numChains :: Iterable a Chain => a -> Int

-- | Number of all models within the structure.
numModels :: Iterable a Model => a -> Int

-- | Takes a first model.
firstModel :: (Iterable a Model) => a -> Maybe Model

-- | Dictionary mapping three-letter PDB residue code to a single-letter
--   FASTA code.
resname2fastacode :: String -> Char

-- | Dictionary mapping single-letter FASTA standard aminoacid code to a
--   PDB residue name
fastacode2resname :: Char -> String

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(*|) :: Double -> Vector3 -> Vector3

-- | Scalar product. (asterisk - "*" - indicates side on which one can put
--   a scalar.)
(|*) :: Vector3 -> Double -> Vector3

-- | 2-norm of a vector (also called a magnitude or length.)
vnorm :: Vector3 -> Double

-- | Type alias for <a>Element</a> names.
type Element = ByteString

-- | Given a PDB <a>Atom</a> extract or guess its <a>Element</a> name.
assignElement :: Atom -> Element

-- | Atomic number of a given element
atomicNumber :: Element -> Int

-- | Atomic mass of a given element in g/mol
atomicMass :: Element -> Double

-- | Covalent radius of an element with a given name.
covalentRadius :: (Eq a1, Fractional a, Show a1, IsString a1) => a1 -> a

-- | Van der Waals radius of the given element
vanDerWaalsRadius :: Element -> Double
