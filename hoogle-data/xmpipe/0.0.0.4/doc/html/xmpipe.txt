-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | XMPP implementation using simple-PIPE
--   
--   This package includes XMPP libraries. Now this contains only core (RFC
--   6120). This package needs more improvement yet. It has following
--   features.
--   
--   C2S
--   
--   <ul>
--   <li>TLS: use package
--   <a>https://hackage.haskell.org/package/peyotls</a> (sample programs
--   are coming soon)</li>
--   <li>SASL: PLAIN, DIGEST-MD5, SCRAM-SHA-1, EXTERNAL (XEP-0178)</li>
--   </ul>
--   
--   S2S
--   
--   <ul>
--   <li>TLS: use package
--   <a>https://hackage.haskell.org/package/peyotls</a> (sample programs
--   are comming soon)</li>
--   <li>SASL: EXTERNAL (XEP-0178)</li>
--   </ul>
--   
--   It does not have following features yet.
--   
--   S2S
--   
--   <ul>
--   <li>DIALBACK (XEP-0220)</li>
--   </ul>
--   
--   Example programs
--   
--   Client
--   
--   examples/simpleClient.hs
--   
--   <pre>
--   % runhaskell simpleClient.hs yoshikuni@localhost/im password yoshio@localhost
--   Hello, my name is Yoshikuni!
--   yoshio@localhost: Hi, I'm Yoshio.
--   yoshio@localhost: I am busy.
--   Good-bye!
--   /quit
--   </pre>
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   replace
--   
--   <ul>
--   <li>&amp;#123; to '{'</li>
--   <li>&amp;#125; to '}'</li>
--   </ul>
--   
--   <pre>
--   import Prelude hiding (filter)
--   
--   import Control.Applicative
--   import "monads-tf" Control.Monad.State
--   import "monads-tf" Control.Monad.Writer
--   import Control.Concurrent hiding (yield)
--   import Data.Maybe
--   import Data.Pipe
--   import Data.Pipe.Flow
--   import Data.Pipe.ByteString
--   import System.IO
--   import System.Environment
--   import Text.XML.Pipe
--   import Network
--   import Network.Sasl
--   import Network.XMPiPe.Core.C2S.Client
--   
--   import qualified Data.ByteString as BS
--   import qualified Data.ByteString.Char8 as BSC
--   
--   mechanisms :: [BS.ByteString]
--   mechanisms = ["SCRAM-SHA-1", "DIGEST-MD5", "PLAIN"]
--   
--   data St = St [(BS.ByteString, BS.ByteString)]
--   instance SaslState St where getSaslState (St ss) = ss; putSaslState ss _ = St ss
--   
--   main :: IO ()
--   main = do
--   	(me_ : pw : you_ : _) &lt;- map BSC.pack &lt;$&gt; getArgs
--   	let	me@(Jid un d (Just rsc)) = toJid me_; you = toJid you_
--   		ss = St [
--   			("username", un), ("authcid", un), ("password", pw),
--   			("cnonce", "00DEADBEEF00") ]
--   	h &lt;- connectTo (BSC.unpack d) $ PortNumber 5222
--   	void . (`evalStateT` ss) . runPipe $
--   		fromHandle h =$= sasl d mechanisms =$= toHandle h
--   	(Just ns, _fts) &lt;- runWriterT . runPipe $
--   		fromHandle h =$= bind d rsc =@= toHandle h
--   	void . forkIO . void . runPipe $ fromHandle h =$= input ns
--   		=$= convert fromMessage =$= filter isJust =$= convert fromJust
--   		=$= toHandleLn stdout
--   	void . (`runStateT` 0) . runPipe $ do
--   		yield (presence me) =$= output =$= toHandle h
--   		fromHandleLn stdin =$= before (== "/quit")
--   			=$= mkMessage you =$= output =$= toHandle h
--   		yield End =$= output =$= toHandle h
--   
--   presence :: Jid -&gt; Mpi
--   presence me = Presence
--   	(tagsNull &amp;#123; tagFrom = Just me &amp;#125;) [XmlNode (nullQ "presence") [] [] []]
--   
--   mkMessage :: Jid -&gt; Pipe BS.ByteString Mpi (StateT Int IO) ()
--   mkMessage you = (await &gt;&gt;=) . maybe (return ()) $ \m -&gt; do
--   	n &lt;- get; modify succ
--   	yield $ toM n m
--   	mkMessage you
--   	where toM n msg = Message (tagsType "chat") &amp;#123;
--   			tagId = Just . BSC.pack . ("msg_" ++) $ show n,
--   			tagTo = Just you &amp;#125;
--   		[XmlNode (nullQ "body") [] [] [XmlCharData msg]]
--   
--   fromMessage :: Mpi -&gt; Maybe BS.ByteString
--   fromMessage (Message ts [XmlNode _ [] [] [XmlCharData m]])
--   	| Just (Jid n d _) &lt;- tagFrom ts = Just $ BS.concat [n, "@", d, ": ", m]
--   fromMessage _ = Nothing
--   </pre>
--   
--   Server
--   
--   examples/simpleServer.hs
--   
--   This simple server can process only chat between same domain
--   (localhost) users. Because this code use only C2S modules. You can
--   implement S2S connection by S2S modules. But now this package contain
--   only EXTERNAL authentification. This package is not contain DIALBACK
--   yet. S2S examples which use EXTERNAL are comming soon.
--   
--   extensions
--   
--   <ul>
--   <li>OverloadedStrings</li>
--   <li>PackageImports</li>
--   </ul>
--   
--   replace
--   
--   <ul>
--   <li>&amp;#123; to '{'</li>
--   <li>&amp;#125; to '}'</li>
--   </ul>
--   
--   <pre>
--   import Control.Applicative
--   import Control.Arrow
--   import Control.Monad
--   import "monads-tf" Control.Monad.State
--   import "monads-tf" Control.Monad.Error
--   import Control.Concurrent hiding (yield)
--   import Control.Concurrent.STM
--   import Data.Pipe
--   import Data.Pipe.ByteString
--   import Data.Pipe.TChan
--   import Network
--   import Network.Sasl
--   import Network.XMPiPe.Core.C2S.Server
--   
--   import qualified Data.ByteString as BS
--   import qualified Network.Sasl.DigestMd5.Server as DM5
--   import qualified Network.Sasl.ScramSha1.Server as SS1
--   
--   main :: IO ()
--   main = do
--   	userlist &lt;- atomically $ newTVar []
--   	soc &lt;- listenOn $ PortNumber 5222
--   	forever $ accept soc &gt;&gt;= \(h, _, _) -&gt; forkIO $ do
--   		c &lt;- atomically newTChan
--   		(Just ns, st) &lt;- (`runStateT` initXSt) . runPipe $ do
--   			fromHandle h =$= sasl "localhost" retrieves =$= toHandle h
--   			fromHandle h =$= bind "localhost" [] =@= toHandle h
--   		let u = user st; sl = selector userlist
--   		atomically $ modifyTVar userlist ((u, c) :)
--   		void . forkIO . runPipe_ $ fromTChan c =$= output =$= toHandle h
--   		runPipe_ $ fromHandle h =$= input ns =$= select u =$= toTChansM sl
--   
--   selector :: TVar [(Jid, TChan Mpi)] -&gt; IO [(Jid -&gt; Bool, TChan Mpi)]
--   selector ul = map (first eq) &lt;$&gt; atomically (readTVar ul)
--   	where
--   	eq (Jid u d _) (Jid v e Nothing) = u == v &amp;&amp; d == e
--   	eq j k = j == k
--   
--   select :: Monad m =&gt; Jid -&gt; Pipe Mpi (Jid, Mpi) m ()
--   select f = (await &gt;&gt;=) . maybe (return ()) $ \mpi -&gt; case mpi of
--   	End -&gt; yield (f, End)
--   	Message tgs@(Tags &amp;#123; tagTo = Just to &amp;#125;) b -&gt;
--   		yield (to, Message tgs &amp;#123; tagFrom = Just f &amp;#125; b) &gt;&gt; select f
--   	_ -&gt; select f
--   
--   initXSt :: XSt
--   initXSt = XSt &amp;#123;
--   	user = Jid "" "localhost" Nothing, rands = repeat "00DEADBEEF00",
--   	sSt = [	("realm", "localhost"), ("qop", "auth"), ("charset", "utf-8"),
--   		("algorithm", "md5-sess") ] &amp;#125;
--   
--   retrieves :: (
--   	MonadState m, SaslState (StateType m),
--   	MonadError m, SaslError (ErrorType m) ) =&gt; [Retrieve m]
--   retrieves = [RTPlain retrievePln, RTDigestMd5 retrieveDM5, RTScramSha1 retrieveSS1]
--   
--   retrievePln :: (
--   	MonadState m, SaslState (StateType m),
--   	MonadError m, SaslError (ErrorType m) ) =&gt;
--   	BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString -&gt; m ()
--   retrievePln "" "yoshikuni" "password" = return ()
--   retrievePln "" "yoshio" "password" = return ()
--   retrievePln _ _ _ = throwError $ fromSaslError NotAuthorized "auth failure"
--   
--   retrieveDM5 :: (
--   	MonadState m, SaslState (StateType m),
--   	MonadError m, SaslError (ErrorType m) ) =&gt; BS.ByteString -&gt; m BS.ByteString
--   retrieveDM5 "yoshikuni" = return $ DM5.mkStored "yoshikuni" "localhost" "password"
--   retrieveDM5 "yoshio" = return $ DM5.mkStored "yoshio" "localhost" "password"
--   retrieveDM5 _ = throwError $ fromSaslError NotAuthorized "auth failure"
--   
--   retrieveSS1 :: (
--   	MonadState m, SaslState (StateType m),
--   	MonadError m, SaslError (ErrorType m) ) =&gt; BS.ByteString -&gt;
--   	m (BS.ByteString, BS.ByteString, BS.ByteString, Int)
--   retrieveSS1 "yoshikuni" = return (slt, stk, svk, i)
--   	where slt = "pepper"; i = 4492; (stk, svk) = SS1.salt "password" slt i
--   retrieveSS1 "yoshio" = return (slt, stk, svk, i)
--   	where slt = "sugar"; i = 4492; (stk, svk) = SS1.salt "password" slt i
--   retrieveSS1 _ = throwError $ fromSaslError NotAuthorized "auth failure"
--   
--   type Pairs a = [(a, a)]
--   data XSt = XSt &amp;#123; user :: Jid, rands :: [BS.ByteString], sSt :: Pairs BS.ByteString &amp;#125;
--   
--   instance XmppState XSt where
--   	getXmppState xs = (user xs, rands xs)
--   	putXmppState (usr, rl) xs = xs &amp;#123; user = usr, rands = rl &amp;#125;
--   
--   instance SaslState XSt where
--   	getSaslState XSt &amp;#123; user = Jid n _ _, rands = nnc : _, sSt = ss &amp;#125; =
--   		("username", n) : ("nonce", nnc) : ("snonce", nnc) : ss
--   	getSaslState _ = error "XSt.getSaslState: null random list"
--   	putSaslState ss xs@XSt &amp;#123; user = Jid _ d r, rands = _ : rs &amp;#125; =
--   		xs &amp;#123; user = Jid n d r, rands = rs, sSt = ss &amp;#125;
--   		where Just n = lookup "username" ss
--   	putSaslState _ _ = error "XSt.getSaslState: null random list"
--   </pre>
@package xmpipe
@version 0.0.0.4

module Network.XMPiPe.Core.C2S.Server
data Mpi
Message :: Tags -> [XmlNode] -> Mpi
Presence :: Tags -> [XmlNode] -> Mpi
Iq :: Tags -> [XmlNode] -> Mpi
End :: Mpi
MpiRaw :: XmlNode -> Mpi
type Feature = XmlNode
data Jid
Jid :: ByteString -> ByteString -> (Maybe ByteString) -> Jid
data Tags
Tags :: Maybe ByteString -> Maybe ByteString -> Maybe Jid -> Maybe Jid -> Maybe ByteString -> [(QName, ByteString)] -> Tags
tagId :: Tags -> Maybe ByteString
tagType :: Tags -> Maybe ByteString
tagFrom :: Tags -> Maybe Jid
tagTo :: Tags -> Maybe Jid
tagLang :: Tags -> Maybe ByteString
tagOthers :: Tags -> [(QName, ByteString)]
tagsType :: ByteString -> Tags
class SaslState xs => XmppState xs
getXmppState :: XmppState xs => xs -> (Jid, [ByteString])
putXmppState :: XmppState xs => (Jid, [ByteString]) -> xs -> xs
data Retrieve m
RTPlain :: (ByteString -> ByteString -> ByteString -> m ()) -> Retrieve m
RTExternal :: (ByteString -> m ()) -> Retrieve m
RTDigestMd5 :: (ByteString -> m ByteString) -> Retrieve m
RTScramSha1 :: (ByteString -> m (ByteString, ByteString, ByteString, Int)) -> Retrieve m
starttls :: (MonadState m, [ByteString] ~ StateType m) => ByteString -> Pipe ByteString ByteString m ()
sasl :: (MonadState m, XmppState (StateType m), MonadError m, SaslError (ErrorType m)) => ByteString -> [Retrieve m] -> Pipe ByteString ByteString m ()
bind :: (MonadState m, XmppState (StateType m), MonadError m, SaslError (ErrorType m)) => ByteString -> [Feature] -> Pipe ByteString ByteString m [Xmlns]
input :: Monad m => [Xmlns] -> Pipe ByteString Mpi m ()
output :: Monad m => Pipe Mpi ByteString m ()

module Network.XMPiPe.Core.S2S.Client
data Mpi
Message :: Tags -> [XmlNode] -> Mpi
Presence :: Tags -> [XmlNode] -> Mpi
Iq :: Tags -> [XmlNode] -> Mpi
End :: Mpi
MpiRaw :: XmlNode -> Mpi
data Jid
Jid :: ByteString -> ByteString -> (Maybe ByteString) -> Jid
data Tags
Tags :: Maybe ByteString -> Maybe ByteString -> Maybe Jid -> Maybe Jid -> Maybe ByteString -> [(QName, ByteString)] -> Tags
tagId :: Tags -> Maybe ByteString
tagType :: Tags -> Maybe ByteString
tagFrom :: Tags -> Maybe Jid
tagTo :: Tags -> Maybe Jid
tagLang :: Tags -> Maybe ByteString
tagOthers :: Tags -> [(QName, ByteString)]
tagsNull :: Tags
tagsType :: ByteString -> Tags
starttls :: Monad m => ByteString -> ByteString -> Pipe ByteString ByteString m ()
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => ByteString -> ByteString -> Pipe ByteString ByteString m ()
begin :: Monad m => ByteString -> ByteString -> Pipe ByteString ByteString m [Xmlns]
input :: Monad m => [Xmlns] -> Pipe ByteString Mpi m ()
output :: Monad m => Pipe Mpi ByteString m ()

module Network.XMPiPe.Core.S2S.Server
data Mpi
Message :: Tags -> [XmlNode] -> Mpi
Presence :: Tags -> [XmlNode] -> Mpi
Iq :: Tags -> [XmlNode] -> Mpi
End :: Mpi
MpiRaw :: XmlNode -> Mpi
data XmppState
XmppState :: Maybe ByteString -> [ByteString] -> XmppState
xsDomainName :: XmppState -> Maybe ByteString
xsUuid :: XmppState -> [ByteString]
data Tags
Tags :: Maybe ByteString -> Maybe ByteString -> Maybe Jid -> Maybe Jid -> Maybe ByteString -> [(QName, ByteString)] -> Tags
tagId :: Tags -> Maybe ByteString
tagType :: Tags -> Maybe ByteString
tagFrom :: Tags -> Maybe Jid
tagTo :: Tags -> Maybe Jid
tagLang :: Tags -> Maybe ByteString
tagOthers :: Tags -> [(QName, ByteString)]
tagsNull :: Tags
tagsType :: ByteString -> Tags
class SaslState s
class Error e => SaslError e
starttls :: (MonadState m, XmppState ~ StateType m) => Pipe ByteString ByteString m ()
sasl :: (MonadState m, StateType m ~ XmppState, MonadError m, SaslError (ErrorType m)) => (ByteString -> Bool) -> Pipe ByteString ByteString m ()
begin :: (MonadState m, StateType m ~ XmppState) => Pipe ByteString ByteString m [Xmlns]
input :: Monad m => [Xmlns] -> Pipe ByteString Mpi m ()
output :: Monad m => Pipe Mpi ByteString m ()
instance Show XmppState
instance SaslState XmppState

module Network.XMPiPe.Core.C2S.Client
data Mpi
Message :: Tags -> [XmlNode] -> Mpi
Presence :: Tags -> [XmlNode] -> Mpi
Iq :: Tags -> [XmlNode] -> Mpi
End :: Mpi
MpiRaw :: XmlNode -> Mpi
type Feature = XmlNode
data Jid
Jid :: ByteString -> ByteString -> (Maybe ByteString) -> Jid
toJid :: ByteString -> Jid
fromJid :: Jid -> ByteString
data Tags
Tags :: Maybe ByteString -> Maybe ByteString -> Maybe Jid -> Maybe Jid -> Maybe ByteString -> [(QName, ByteString)] -> Tags
tagId :: Tags -> Maybe ByteString
tagType :: Tags -> Maybe ByteString
tagFrom :: Tags -> Maybe Jid
tagTo :: Tags -> Maybe Jid
tagLang :: Tags -> Maybe ByteString
tagOthers :: Tags -> [(QName, ByteString)]
tagsNull :: Tags
tagsType :: ByteString -> Tags
starttls :: Monad m => ByteString -> Pipe ByteString ByteString m ()
sasl :: (MonadState m, SaslState (StateType m), MonadError m, Error (ErrorType m)) => ByteString -> [ByteString] -> Pipe ByteString ByteString m ()
bind :: (Monad m, MonadWriter m, [Feature] ~ WriterType m, MonadError m, Error (ErrorType m)) => ByteString -> ByteString -> Pipe ByteString ByteString m [Xmlns]
input :: Monad m => [Xmlns] -> Pipe ByteString Mpi m ()
output :: Monad m => Pipe Mpi ByteString m ()
