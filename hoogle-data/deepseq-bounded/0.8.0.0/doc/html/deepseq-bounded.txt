-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bounded deepseq, including support for generic deriving
--   
--   This package provides methods for partially (or fully) evaluating data
--   structures ("bounded deep evaluation").
--   
--   More information is available on the project <a>homepage</a>. There
--   may be activity on this <a>reddit</a> discussion, where your comments
--   are invited.
--   
--   Quoting from the <a>deepseq</a> package:
--   
--   "<i>Artificial forcing is often used for adding strictness to a
--   program, e.g. in order to force pending exceptions, remove space
--   leaks, or force lazy IO to happen. It is also useful in parallel
--   programs, to ensure work does not migrate to the wrong thread.</i>"
--   
--   Sometimes we don't want to, or cannot, force all the way, for instance
--   when dealing with potentially infinite values of coinductive types.
--   Also, bounded forcing bridges the theoretical axis between shallow seq
--   and full deepseq.
--   
--   We provide two new classes <a>NFDataN</a> and <a>NFDataP</a>.
--   Instances of these provide bounded deep evaluation for arbitrary
--   polytypic terms:
--   
--   <ul>
--   <li><a>rnfn</a> bounds the forced evaluation by depth of
--   recursion.</li>
--   <li><a>rnfp</a> forces based on patterns (static or dynamic).</li>
--   </ul>
--   
--   Instances of <a>NFDataN</a> and <a>NFDataP</a> can be automatically
--   derived via <a>Generics.SOP</a>, backed by the <a>GNFDataN</a> and
--   <a>GNFDataP</a> modules. <a>NFDataN</a> can optionally be derived by
--   the standard <a>GHC.Generics</a> facility (but not so for
--   <a>NFDataP</a>).
--   
--   Another approach is <a>Seqable</a>, which is similar to
--   <a>NFDataN</a>, but optimised for use as a dynamically-reconfigurable
--   forcing harness in the <a>seqaid</a> auto-instrumentation tool.
--   
--   Recent developments supporting parallelisation control (in
--   <a>Pattern</a> and <a>Seqable</a> modules) may justify renaming this
--   library to something which encompasses both strictness and parallelism
--   aspects.
--   
--   <i> NOTE: Versions &gt;=0.6 are substantially different from the
--   original (now deprecated) 0.5.* releases, particularly as regards
--   NFDataP. </i>
@package deepseq-bounded
@version 0.8.0.0


module Control.DeepSeq.Bounded.Pattern
type Pattern = Rose PatNode

-- | Only <a>WR</a> and <a>TR</a> allow for explicit recursion.
--   
--   All other <a>PatNode</a> values are in leaf position when they occur.
--   
--   Concrete syntax for <tt>W*</tt> and <tt>T*</tt> nodes are identical. A
--   <tt>T*</tt> node is simply a <tt>W*</tt> node bearing a type
--   constraint attribute. Please refer to the <b>Grammar</b> further down
--   this page for more details, and links to even more information.
--   
--   <i>Notes:</i>
--   
--   <i>I've kept the <tt>T*</tt> types broken out as separate
--   constructors, although they could be handled as special cases of
--   <tt>W*</tt> types in a way analogous to <a>doSpark</a>
--   (<a>PatNodeAttrs</a>). These were not "absorbed" because the semantics
--   seems icky, and it's still not clear which <tt>W*</tt> types even make
--   sense with a type constraint...</i>
--   
--   <i>I tried parametrising this, but it messed up my Show instance and
--   seemed to be pulling me away from Haskell 98, so reverted. It looks a
--   bit ugly in the Haddock unfortunately, with the redundant column of
--   <tt>PatNodeAttrs</tt>. The <tt>T*</tt> nodes will be absorbed by
--   <a>PatNodeAttrs</a> in version 0.7, and it won't look so bad.</i>
data PatNode

-- | (<i><b>I</b>nsulate</i>, <b>.</b> ) Don't even unwrap the constructor
--   of this node.
WI :: !PatNodeAttrs -> PatNode

-- | (<i><b>R</b>ecurse</i>, <b>(</b>...<b>)</b> ) Continue pattern
--   matching descendants, provided that arity is compatible (else the
--   match fails). Interior nodes of a pattern are always <tt>WR</tt>,
--   <i>i.e.</i> <tt>WR</tt> is the only <tt>PatNode</tt> offering explicit
--   recursion. The rest (<tt>?S</tt>, <tt>?N</tt>, and <tt>?W</tt>) are
--   implicitly recursive, but control is only as powerful as
--   <a>NFDataN</a>.
WR :: !PatNodeAttrs -> PatNode

-- | (<i><b>S</b>top</i>, <b>!</b> ) Stop recursing (nothing more forced
--   down this branch). This is equivalent to <a>WN</a> at a <a>depth</a>
--   of 1. <i><a>WS</a> is somewhat vestigial, and may be removed in
--   0.7.</i>
WS :: !PatNodeAttrs -> PatNode

-- | (<i><b>N</b> (depth)</i>, <b>*</b>n ) <tt><a>rnfn</a> n</tt> the
--   branch under this node.
WN :: !PatNodeAttrs -> PatNode

-- | (<i><b>W</b></i>ild, <b>*</b> ) Fully force (<a>rnf</a>) the whole
--   branch under this node. <i>Note that this is</i> not <i>achievable as
--   a limiting case of <a>WN</a>, so the existence of <a>WW</a> is
--   formally justifiable in a way that <a>WS</a> is not. Having said that,
--   for all practical purposes, a <a>WN</a> with <a>depth</a> <tt>=
--   maxBound::Int</tt> could be used for <a>WW</a>...</i>
WW :: !PatNodeAttrs -> PatNode

-- | Don't even unwrap the constructor of this node, if it's type is in the
--   list; otherwise behave as <a>WW</a>. (Note this behaviour is the
--   complement of <a>TW</a> behaviour.)
TI :: !PatNodeAttrs -> PatNode

-- | Match any of the types in the list (and continue pattern matching
--   descendants); behave as <a>WI</a> for nodes of type not in the list.
TR :: !PatNodeAttrs -> PatNode

-- | <tt><a>rnfn</a> n</tt> the branch under this node, if the node type
--   matches any of the types in the list; otherwise behave as <a>WI</a>.
TN :: !PatNodeAttrs -> PatNode

-- | Fully force (<a>rnf</a>) the whole branch under this node, if the node
--   type matches any of the types in the list; otherwise behave as
--   <a>WI</a>. (Note this behaviour is the complement of <a>TI</a>
--   behaviour.)
TW :: !PatNodeAttrs -> PatNode

-- | Dummy node type reserved for internal use.
XX :: PatNode

-- | These attributes can be mixed freely. Certain combinations may seem
--   unuseful, but nothing is prohibited by design.
--   
--   While this may seem bloated, most of these capabilities can be truly
--   banished from the code via build flags (<b>use_par_patnode</b>, etc.).
--   
--   In the concrete pattern syntax, all attributes are represented as
--   prefix modifiers (prefixing the <tt>'.'</tt>, <tt>'!'</tt>,
--   <tt>'('</tt> or <tt>'*'</tt> pattern node designator). Prefix
--   modifiers may be given in any order.
--   
--   <i> NOTE: The <a>depth</a> field in <a>PatNodeAttrs</a> is not really
--   an attribute, </i> <i> it is logically a (mandatory) extra parameter
--   to <a>WN</a> and <a>TN</a> </i> <i> nodes (and only those). (Whereas
--   attributes are all optional </i> <i> and node-type-agnostic.) The
--   <a>depth</a> is stored here as a </i> <i> convenient hack only!
--   Explanation becomes necessary since </i> <i> Haddock makes it visible
--   no matter what, I mention this, in case </i> <i> of confusion, because
--   the <a>depth</a> is always <b>post</b>fix, not prefix. </i>
data PatNodeAttrs
PatNodeAttrs :: !Int -> !Int -> !Bool -> ![String] -> !Bool -> !Int -> !Bool -> !Bool -> Maybe [Int] -> !Bool -> !Bool -> Maybe ThreadId -> !Bool -> !Bool -> !Int -> !Int -> !Int -> PatNodeAttrs

-- | Optional for convenience; set up with
--   <a>setPatternPatNodeUniqueIDs</a>. Beware that this function is not
--   called automatically (or if it happens to be at the moment, this
--   behaviour shouldn't be relied upon). For example, if you were to call
--   <a>growPat</a>, the added nodes would all have "uniqueID" of 0.
uniqueID :: PatNodeAttrs -> !Int

-- | (<b>*</b><i>n</i>) Depth of forcing for <a>WN</a> and <a>TN</a> nodes
--   (<i>n</i> is decimal integer depth). <i>(This is not an attribute,
--   it's a displaced mandatory parameter, specific to these two node
--   types.)</i>
depth :: PatNodeAttrs -> !Int

-- | (<b>:</b>) Constrain pattern to match only types named in
--   <a>typeConstraints</a>. <i><b>XXX</b> This should be considered
--   experimental still in 0.6. This and the <a>NFDataPDyn</a> aspects lost
--   attention to</i> <a>seqaid</a>.
doConstrainType :: PatNodeAttrs -> !Bool

-- | The list of type rep strings used in the type constraint (when
--   <a>doConstrainType</a> is <a>True</a>).
typeConstraints :: PatNodeAttrs -> ![String]

-- | (<b>@</b>) Delay (current thread) for <a>delayus</a> microseconds.
--   <i><b>XXX</b> Still buggy?</i>
doDelay :: PatNodeAttrs -> !Bool

-- | Microseconds of delay (when <a>doDelay</a> is <a>True</a>).
delayus :: PatNodeAttrs -> !Int

-- | (<b>=</b>) Spark matching for parallel evaluation.
doSpark :: PatNodeAttrs -> !Bool

-- | (<b>&gt;</b><i>perm</i>) Sequence child subpattern matching, according
--   to the permutation in <a>pseqPerm</a>.
doPseq :: PatNodeAttrs -> !Bool

-- | Lowercase alphabetic sequence is used in the concrete pattern syntax.
--   <tt><b>&gt;cdba(wxyz)</b></tt> will cause subpattern matching
--   recursion on a quaternary constructor, with the subpattern
--   computations sequenced <tt><b>y</b></tt> then <tt><b>z</b></tt> then
--   <tt><b>x</b></tt> then <tt><b>w</b></tt> (order corresponds to
--   <tt><b>cdba</b></tt>).
pseqPerm :: PatNodeAttrs -> Maybe [Int]

-- | (<b>+</b>) Output a traceline to stderr.
doTrace :: PatNodeAttrs -> !Bool

-- | (<b>^</b>) Raise informative (asynchronous? support is not strong for
--   it, <a>throwTo</a> blocks...) exception <i>en passant</i>, for benefit
--   of upstream. The exception is thrown in a new thread, so that the
--   pattern matching continues; for a terminating version, see
--   <a>doDie</a>.
doPing :: PatNodeAttrs -> !Bool

-- | Needed as argument for <tt>throwTo</tt> call.
pingParentTID :: PatNodeAttrs -> Maybe ThreadId

-- | (<b>/</b>) Kill (just this) thread.
doDie :: PatNodeAttrs -> !Bool

-- | (<b>%</b>) Note time passed since pattern-matched parent node.
--   <i><b>XXX</b> Work in progress.</i>
doTiming :: PatNodeAttrs -> !Bool
timestamp :: PatNodeAttrs -> !Int
parent_timestamp :: PatNodeAttrs -> !Int
delta_timestamp :: PatNodeAttrs -> !Int
isWI :: PatNode -> Bool
isWR :: PatNode -> Bool
isWS :: PatNode -> Bool
isWN :: PatNode -> Bool
isWW :: PatNode -> Bool
isTI :: PatNode -> Bool
isTR :: PatNode -> Bool
isTN :: PatNode -> Bool
isTW :: PatNode -> Bool
emptyPatNodeAttrs :: PatNodeAttrs
getPatNodeAttrs :: PatNode -> PatNodeAttrs
setPatNodeAttrs :: PatNode -> PatNodeAttrs -> PatNode
setPatNodePingParentTID :: ThreadId -> PatNode -> PatNode
showPerm :: Maybe [Int] -> String
showPatRaw :: Pattern -> String
showPatNodeRaw :: PatNode -> String
setPatternPatNodeUniqueIDs :: Int -> Pattern -> Pattern
data Rose a
Node :: a -> [Rose a] -> Rose a
data SeqNode
Insulate :: SeqNode
Propagate :: SeqNode
Spark :: SeqNode
instance Typeable Rose
instance Typeable PatNodeAttrs
instance Typeable PatNode
instance Show a => Show (Rose a)
instance Eq a => Eq (Rose a)
instance Show PatNodeAttrs
instance Eq PatNodeAttrs
instance Eq PatNode
instance Eq SeqNode
instance Ord SeqNode
instance Show PatNode
instance NFData PatNode
instance NFData PatNodeAttrs
instance NFData ThreadId
instance Functor Rose
instance NFData a => NFData (Rose a)


module Control.DeepSeq.Bounded.PatUtil

-- | Compute the union of a list of <a>Pattern</a>s.
--   
--   Note that unionPats is undefined when homologous nodes specify
--   incompatible arities (only possible when <a>WR</a> or <a>TR</a> are
--   involved).
--   
--   <i><b>XXX</b> Support for the various attributes is work in progress.
--   It may be impossible to arrive at a consistent treatment for all
--   attributes under unions. This is work in progress, but the five
--   un-modified <tt>W*</tt> node types should be safe.</i>
unionPats :: [Pattern] -> Pattern

-- | Compute the intersection of a list of <a>Pattern</a>s.
--   
--   Where two (or more) homologous <a>WR</a> nodes disagree in arity, the
--   intersection at that position becomes <a>WI</a>.
--   
--   <i><b>XXX</b> This doesn't yet handle type-constrained <a>PatNode</a>s
--   (<a>TI</a>, <a>TR</a>, <a>TN</a> or <a>TW</a>). Other attributes are
--   handled in a haphazard fashion. This is work in progress, but the five
--   un-modified <tt>W*</tt> node types should be safe.</i>
intersectPats :: [Pattern] -> Pattern

-- | Return <a>True</a> if the first pattern matches the second (and
--   <a>False</a> otherwise).
--   
--   Arities must correspond (or the second pattern's node must be wild)
--   for the match to succeed at each <b>recursive</b> <a>PatNode</a>
--   (<i>i.e.</i> <a>WR</a> or <a>TR</a>). Matching does not imply
--   spanning; <tt><a>flip</a> <a>subPat</a></tt> would work for that.
--   
--   <i><b>XXX</b> This doesn't yet handle type-constrained <a>PatNode</a>s
--   (<a>TI</a>, <a>TR</a>, <a>TN</a> or <a>TW</a>), because
--   <a>intersectPats</a> doesn't. Generally speaking, it is difficult to
--   arrive at a good policy for subpattern, union and intersection, when
--   mixed types of nodes with various attribute values are considered!
--   Other attributes are handled in a haphazard fashion. This is work in
--   progress, but the five un-modified <tt>W*</tt> node types should be
--   safe.</i>
--   
--   More formally, we have two "Subpattern Axioms":
--   
--   <ul>
--   <li><b>Not More Specifc</b> A subpattern (of a pattern) is never more
--   specific (<i>i.e.</i> less permissive), in terms of what values it
--   will match.</li>
--   <li><b>Not More Forcing</b> A subpattern never has greater forcing
--   potential.</li>
--   </ul>
--   
--   And a <i>proper</i> subpattern will always be strictly more permissive
--   or less forcing (or both).
subPat :: Pattern -> Pattern -> Bool

-- | Obtain a lazy, potentially infinite pattern, matching the shape of an
--   arbitrary term (value expression).
--   
--   There is only one kind of <a>PatNode</a> employed here, <a>WR</a>.
--   
--   The <a>Pattern</a> is extended indefinitely on demand. In case the
--   term has leaves, these will be <a>WR</a> nodes with empty child lists
--   in the corresponding pattern.
--   
--   <b>Caveat</b>: Note that <tt>mkPat</tt> gives counter-intuitive
--   results when used on rose trees, in particular on <a>Pattern</a>
--   itself. For example, a rose tree with a single node will have a 3-node
--   /\ shape.) Formally, <a>mkPat</a> is not idempotent on
--   <a>Pattern</a>s, but rather grows without bound when iterated. This
--   shouldn't be an issue in practise.
mkPat :: Data d => d -> Pattern

-- | Obtain a lazy, finite pattern, matching the shape of an arbitrary
--   term, but only down to at most depth <tt>n</tt>.
--   
--   Satisfies <tt><tt>forcep</tt> . <a>mkPatN</a> n = <tt>forcen</tt>
--   n</tt>. <i>(Later: I kinda doubt that is true in full generality?...
--   Although it does convey the idea.)</i>
--   
--   Unlike <a>mkPat</a>, three pattern node contexts arise here:
--   
--   <ul>
--   <li>those corresponding to actual leaf (nullary) nodes of the
--   term<ul><li>these are <tt>Node WR []</tt></li></ul></li>
--   </ul>
--   
--   <ul>
--   <li>interior nodes of the pattern corresponding to interior nodes of
--   the term<ul><li>these are <tt>Node WR chs</tt> where <tt>chs</tt> are
--   the child subpatterns of this interior pattern node</li></ul></li>
--   </ul>
--   
--   <ul>
--   <li>leaf nodes of the pattern corresponding to interior nodes of the
--   term, that is, non-leaf nodes of the term which are at a depth
--   <tt>n</tt> of nested constructor applications.<ul><li>these are
--   <tt>Node WR chs'</tt> where <tt>chs' = map (const $ Node WI []) chs =
--   map (const emptyPat) chs</tt></li><li>this essentially says we're
--   allowed to know the arity of the node, but aside from this cardinal
--   number we know nothing whatsoever concerning the child subpatterns and
--   are not even permitted to evaluate their heads</li></ul></li>
--   </ul>
--   
--   All interior nodes are <a>WR</a>, and all leaf nodes are <a>WI</a>;
--   <a>WS</a> never arise.
--   
--   See caveat in the <a>mkPat</a> documentation.
mkPatN :: Data d => Int -> d -> Pattern

-- | Grow all leaves by one level within the shape of the provided value.
--   This is intended to be used with "plain" patterns, <i>i.e.</i> those
--   containing only <a>WR</a> and <a>WI</a> nodes. (There is no code
--   enforcing this.) A new growth node always replaces a <a>WI</a> (leaf)
--   node with a <a>WR</a> node bearing the suitable number of <a>WI</a>
--   children to encode arity (see <a>mkPat</a> for general commentary
--   about this).
growPat :: Data d => Pattern -> d -> Pattern

-- | Given an integer depth and a pattern, truncate the pattern to extend
--   to at most this requested depth.
--   
--   Nodes in the truncated pattern which were <a>WR</a> and are now
--   leaves, are changed to <a>WI</a>.
--   
--   <i><b>XXX</b> Note that <tt>*N</tt> and <tt>*W</tt> nodes are
--   retained, so if you are using those then "extend to at most this
--   depth" does not mean the forcing potential of the pattern is at most
--   that depth... It would be quite possible to improve this, so
--   <tt>*N</tt> (and <tt>*W</tt> nodes, obviously) are "weakened" (depth
--   is reduced) so that they end at the truncation depth, regardless of
--   how far up they reside. In particular, any <tt>*N</tt> or <tt>*W</tt>
--   node at truncation depth could be replaced by <tt>WS</tt>. This works
--   well as all these node types are arity-agnostic.</i>
truncatePat :: Int -> Pattern -> Pattern

-- | Elide all leaves which have no non-leaf sibling. We want the pattern
--   to still match the same value, only less of it. Merely eliding all
--   leaves would, in most cases, cause match failure, so we have to be a
--   bit more subtle. There are some arbitrary decisions about the
--   relaxation route through the lattice. (Refer to the source for
--   details.)
--   
--   More formally, we have some "Shrinkage Axioms". The first two are
--   really just the "Subpattern Axioms" again, that is, shrinkage is
--   always to a subpattern in our sense of the word (see also
--   <a>subPat</a>):
--   
--   <ul>
--   <li><b>Not More Specifc</b> Shrinkage is never towards a more specific
--   (<i>i.e.</i> less permissive) pattern.</li>
--   <li><b>Not More Forcing</b> Shrinkage is never towards a pattern with
--   greater forcing potential.</li>
--   </ul>
--   
--   And additionally, for finite patterns only:
--   
--   <ul>
--   <li><b>Non-Constancy</b> A finite pattern is constant under shrinkage
--   <i>iff</i> the pattern is trivial (emptyPat, ".", Node WI []).
--   However, infinite patterns have other limits. For instance, the
--   infinite pattern <tt><a>concat</a> $ <a>repeat</a> "(."</tt> (yes you
--   can do that!) is already stationary under shrinkage.</li>
--   <li><b>Convergence</b> On iteration, shrinkage of finite patterns
--   reaches the trivial pattern in a number of steps proportional to the
--   size of the initial pattern argument. (Actually, <tt>*N</tt> and
--   <tt>*W</tt> nodes can make this larger.) However, in the case of
--   infinite patterns, all bets are off: Simple examples exist which
--   converge immediately, or which continue shrinking indefinitely.)</li>
--   </ul>
shrinkPat :: Pattern -> Pattern

-- | There is no <tt>Nil</tt> in the <tt>Pattern</tt> type, but a single
--   <a>WI</a> node as empty pattern is a dependable way to ensure that the
--   empty pattern never forces anything. This sets <a>PatNodeAttrs</a> to
--   <a>emptyPatNodeAttrs</a>.
emptyPat :: Pattern

-- | This creates a new <a>WR</a> node, the common root, with
--   <a>PatNodeAttrs</a> set to <a>emptyPatNodeAttrs</a>. The argument
--   patterns become the children of the root (order is preserved).
liftPats :: [Pattern] -> Pattern

-- | Add children to a node (interior or leaf) of the target. The first
--   argument is target pattern, the second is a path (0-based indexing)
--   from the root of the target to any choice node, and the third is a
--   list of subpatterns for insertion, along with the indices of the
--   insertion slots. Indices range through <tt>-1,0..n</tt>, where
--   <tt>n</tt> is the number of existing children, and <tt>-1</tt> is
--   short for <tt>n</tt> (so you don't need to count off the children to
--   append!). Indices are always relative to the original target as it was
--   received.
splicePats :: Pattern -> [Int] -> [(Int, Pattern)] -> Pattern

-- | Elide children of a node (interior or leaf) of the target. The first
--   argument is target pattern, the second is a path (0-based indexing)
--   from the root of the target to any choice node, and the third is a
--   list of child indices for elision. Indices range through
--   <tt>-1,0..n-1</tt>, where <tt>n</tt> is the number of existing
--   children, and <tt>-1</tt> is short for <tt>n-1</tt> (so you don't need
--   to count off the children to elide the rightmost). Indices are always
--   relative to the original target as it was received.
elidePats :: Pattern -> [Int] -> [Int] -> Pattern

-- | Select a leaf at random, and elide it. In order to achieve fairness,
--   the node probabilities are weighted by nodes in branch. The path arg
--   can "focus" the stochastic erosion to only consider leaves beneath a
--   given node.
erodePat :: StdGen -> [Int] -> Pattern -> (Pattern, StdGen)
type Shape = Rose ()
shapeOf :: Data d => d -> Shape
ghom :: Data d => GenericQ r -> d -> Rose r
probDensRose :: Rose r -> Rose (r, Double)
weightedRose :: Rose r -> Rose (r, Int)
unzipRose :: Rose (r, s) -> (Rose r, Rose s)
showRose :: Show r => Rose r -> String


module Control.DeepSeq.Bounded.Compile
compilePat :: String -> Pattern

-- | Inverse of <a>compilePat</a>.
--   
--   <pre>
--   showPat . compilePat patstring  =  patstring
--   </pre>
--   
--   (up to optional whitespace, and canonical ordering of any attributes),
--   provided that <tt>compilePat patstring</tt> succeeds.
showPat :: Pattern -> String
instance IsString Pattern


-- | Generic function version of <a>Seqable</a> (via <a>Generics.SOP</a>).
--   
--   Probably, a <a>GHC.Generics</a> variant would also be possible.
--   
--   This metaboilerplate is standard for using the generic deriving
--   facilities of <a>Generics.SOP</a>. Consider <a>seqaid</a> for a
--   turnkey solution.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE DeriveDataTypeable #-}
--   {-# LANGUAGE GADTs #-}  -- for GHC &lt; 7.8 (== 7.6.3)
--   
--   import Generics.SOP.TH
--   import Control.DeepSeq.Bounded.Seqable
--   
--   data TA = A1 TB TA | A2
--   data TB = B1 Int | B2 TA
--   
--   deriveGeneric ''TA
--   deriveGeneric ''TB
--   
--   main = return $! force_ Propagate (A1 (force_ Propagate (B2 undefined)) A2)
--   </pre>
module Control.DeepSeq.Bounded.Generic.GSeqable
grnf_ :: Generic a => SeqNode -> a -> ()
gseq_ :: Generic a => SeqNode -> a -> b -> b
gforce_ :: Generic a => SeqNode -> a -> a

-- | <tt><a>seqharn</a> x</tt> is semantically the same as <tt>x</tt>,
--   except its strictness, parallellism, etc. can be tweaked
--   dynamically...
--   
--   <pre>
--   seqharn = to . hliftA (gforce_ Insulate) . from
--   </pre>
--   
--   <i>I can see how this would be useful at compile-time, but how can we
--   use this if seqharn only runs post-compilation? Or is it just
--   analogous to forcep?...</i>
--   
--   <i>Also: How exactly to</i> dynamically configure <i>this?...</i>
seqharn :: Generic a => a -> a


-- | This module provides an overloaded function, <a>deepseqn</a>, for
--   partially (or fully) evaluating data structures to a given depth.
module Control.DeepSeq.Bounded.NFDataN

-- | <tt><a>deepseqn</a> n x y</tt> evaluates <tt>x</tt> to depth n, before
--   returning <tt>y</tt>.
--   
--   This is used when expression <tt>x</tt> also appears in <tt>y</tt>,
--   but mere evaluation of <tt>y</tt> does not force the embedded
--   <tt>x</tt> subexpression as deeply as we wish.
--   
--   The name <a>deepseqn</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <tt><a>deepseqn</a> n</tt>
--   traverses (evaluates) the entire top <tt>n</tt> levels of the data
--   structure.
--   
--   A typical use is to ensure any exceptions hidden within lazy fields of
--   a data structure do not leak outside the scope of the exception
--   handler; another is to force evaluation of a data structure in one
--   thread, before passing it to another thread (preventing work moving to
--   the wrong threads). Unlike <a>DeepSeq</a>, potentially infinite values
--   of coinductive data types are supported by principled bounding of deep
--   evaluation.
--   
--   It is also useful for diagnostic purposes when trying to understand
--   and manipulate space/time trade-offs in lazy code, and as a less
--   indiscriminate substitute for <tt>deepseq</tt>.
--   
--   Furthermore, <a>deepseqn</a> can sometimes be a better solution than
--   using stict fields in your data structures, because the latter will
--   behave strictly everywhere that its constructors are used, instead of
--   just where its laziness is problematic.
--   
--   There may be possible applications to the prevention of resource leaks
--   in lazy streaming, but I'm not certain.
--   
--   One of the special qualities of <a>NFDataN</a> is shape oblivity: it
--   doesn't care about any details of the shape of the term it's forcing,
--   it only cares about stratifying levels of recursion depth. (I would
--   say "as contrasted with <a>NFDataP</a>" but cannot, because
--   <a>NFDataP</a> was extended to include <a>NFDataN</a>
--   syntax/capabilities, precisely to ammend this deficiency.)
deepseqn :: NFDataN a => Int -> a -> b -> b

-- | <a>forcen</a> is a variant of <a>deepseqn</a> that is useful in some
--   circumstances.
--   
--   <pre>
--   forcen n x = deepseqn n x x
--   </pre>
--   
--   <tt>forcen n x</tt> evaluates <tt>x</tt> to depth <tt>n</tt>, and then
--   returns it. Recall that, in common with all Haskell functions,
--   <tt>forcen</tt> only performs evaluation when upstream demand actually
--   occurs, so essentially it turns shallow evaluation into
--   depth-<tt>n</tt> evaluation.
forcen :: NFDataN a => Int -> a -> a

-- | A class of types that can be evaluated to arbitrary depth.
class NFDataN a where rnfn n x | n <= 0 = () | otherwise = x `seq` ()
rnfn :: NFDataN a => Int -> a -> ()
instance (NFDataN a1, NFDataN a2, NFDataN a3, NFDataN a4, NFDataN a5, NFDataN a6, NFDataN a7, NFDataN a8, NFDataN a9) => NFDataN (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (NFDataN a1, NFDataN a2, NFDataN a3, NFDataN a4, NFDataN a5, NFDataN a6, NFDataN a7, NFDataN a8) => NFDataN (a1, a2, a3, a4, a5, a6, a7, a8)
instance (NFDataN a1, NFDataN a2, NFDataN a3, NFDataN a4, NFDataN a5, NFDataN a6, NFDataN a7) => NFDataN (a1, a2, a3, a4, a5, a6, a7)
instance (NFDataN a1, NFDataN a2, NFDataN a3, NFDataN a4, NFDataN a5, NFDataN a6) => NFDataN (a1, a2, a3, a4, a5, a6)
instance (NFDataN a1, NFDataN a2, NFDataN a3, NFDataN a4, NFDataN a5) => NFDataN (a1, a2, a3, a4, a5)
instance (NFDataN a, NFDataN b, NFDataN c, NFDataN d) => NFDataN (a, b, c, d)
instance (NFDataN a, NFDataN b, NFDataN c) => NFDataN (a, b, c)
instance (NFDataN a, NFDataN b) => NFDataN (a, b)
instance (Ix a, NFDataN a, NFDataN b) => NFDataN (Array a b)
instance NFDataN a => NFDataN [a]
instance NFDataN Version
instance (NFDataN a, NFDataN b) => NFDataN (Either a b)
instance NFDataN a => NFDataN (Maybe a)
instance (RealFloat a, NFDataN a) => NFDataN (Complex a)
instance (Integral a, NFDataN a) => NFDataN (Ratio a)
instance NFDataN (a -> b)
instance NFDataN (Fixed a)
instance NFDataN Word64
instance NFDataN Word32
instance NFDataN Word16
instance NFDataN Word8
instance NFDataN Int64
instance NFDataN Int32
instance NFDataN Int16
instance NFDataN Int8
instance NFDataN ()
instance NFDataN Bool
instance NFDataN Char
instance NFDataN Double
instance NFDataN Float
instance NFDataN Integer
instance NFDataN Word
instance NFDataN Int


-- | This module provides an overloaded function, <a>deepseqp</a>, for
--   partially (or fully) evaluating data structures to bounded depth via
--   pattern matching on term shape, and on class, type, and constructor
--   names.
--   
--   There are two ways to use this API.
--   
--   <ol>
--   <li>You can use the <a>PatNode</a> constructors directly.</li>
--   <li>You can compile your patterns from strings in a concise embedded
--   language.</li>
--   </ol>
--   
--   There's no difference in expressive power, but use of the DSL is
--   recommended, because the embedded <a>Pattern</a> compiler can catch
--   some errors that GHC cannot (using <a>PatNode</a> constructors
--   explicitly). Also, the pattern strings are easier to read and write.
--   
--   With some qualifications (concerning <a>WI</a> nodes, and
--   <a>PatNodeAttrs</a> configuration), composition fuses, and what's
--   more, it's commutative...
--   
--   <b>Motivation</b>
--   
--   A typical use is to ensure any exceptions hidden within lazy fields of
--   a data structure do not leak outside the scope of the exception
--   handler; another is to force evaluation of a data structure in one
--   thread, before passing it to another thread (preventing work moving to
--   the wrong threads). Unlike <a>DeepSeq</a>, potentially infinite values
--   of coinductive data types are supported by principled bounding of deep
--   evaluation.
--   
--   It is also useful for diagnostic purposes when trying to understand
--   and manipulate space/time trade-offs in lazy code, and as an optimal
--   substitute for <tt>deepseq</tt> (where "optimal" doesn't include
--   changing the code to remove the need for artificial forcing!).
--   
--   <a>deepseqp</a> with optimal patterns is usually a better solution
--   even than stict fields in your data structures, because the latter
--   will behave strictly everywhere the constructors are used, instead of
--   just where its laziness is problematic.
--   
--   There may be possible applications to the prevention of resource leaks
--   in lazy streaming, but I'm not certain.
--   
--   <b>Semantics</b>
--   
--   (For additional details, see <a>Control.DeepSeq.Bounded.Pattern</a>.)
--   
--   <a>deepseqp</a> and friends artifically force evaluation of a term so
--   long as the pattern matches.
--   
--   A mismatch occurs at a pattern node when the corresponding constructor
--   node either:
--   
--   <ul>
--   <li>has arity different than the number of subpatterns (only when
--   subpatterns given)</li>
--   <li>has class/type/name not named in the constraint (only when
--   constraint given)</li>
--   </ul>
--   
--   A mismatch will cause evaluation down that branch to stop, but any
--   upstream matching/forcing will continue uninterrupted. <i> (This
--   behaviour can now be changed with <a>PatNodeAttrs</a>, available since
--   0.6.) </i>
--   
--   Note that patterns may extend beyond the values they match against,
--   without incurring any mismatch. This semantics is not the only
--   possible, but bear in mind that order of evaluation is
--   nondeterministic, barring further measures. <i> (This behaviour can
--   also now be changed with <a>PatNodeAttrs</a>.) </i>
--   
--   See also <a>NFDataPDyn</a> for another approach, which dynamically
--   generates forcing patterns, and can depend on value info (in addition
--   to type info). <i> (These dynamic aspects never received the attention
--   I intended to give them, I got so caught up in seqaid, which offers
--   similar features. Hopefully actual use of these tools in the near
--   future will give me some perspective on whether</i> <a>NFDataPDyn</a>
--   <i>should get attention.) </i>
module Control.DeepSeq.Bounded.NFDataP

-- | <a>deepseqp</a> evaluates the first argument to the extent specified
--   by a <a>Pattern</a>, before returning the second.
--   
--   Quoting from the <a>DeepSeq</a> documentation (<a>deepseq</a>
--   package):
--   
--   "<a>deepseq</a> <i>can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the</i>
--   <a>parallel</a> <i>package). </i>
--   
--   Self-composition fuses via
--   
--   <pre>
--   "deepseqp/composition"
--      forall p1 p2 x1 x2.
--          (.) (<a>deepseqp</a> p2 x2) (<a>deepseqp</a> p1 x1)
--        = <a>deepseqp</a> ( <a>liftPats</a> [p1, p2] ) (x1,x2)
--   </pre>
--   
--   (Other fusion rules, not yet documented, may also be in effect.)
deepseqp :: NFDataP a => Pattern -> a -> b -> b

-- | A variant of <a>deepseqp</a> that is sometimes convenient:
--   
--   <pre>
--   forcep pat x = deepseqp pat x x   -- (cannot write x `deepseqp pat` x by analogy with x `deepseq` x)
--   </pre>
--   
--   <tt>forcep pat x</tt> evaluates <tt>x</tt> to the depth determined by
--   <tt>pat</tt>, and then returns <tt>x</tt>. Again from <a>deepseq</a>:
--   <i> "Note that <tt>forcep pat x</tt> only takes effect when the value
--   of <tt>forcep pat x</tt> itself is demanded, so essentially it turns
--   shallow evaluation into evaluation to arbitrary bounded depth." </i>
--   
--   Self-composition fuses via
--   
--   <pre>
--   "forcep/composition"
--      forall p1 p2 x.
--          (.) (<a>forcep</a> p2) (<a>forcep</a> p1) x
--        = <a>forcep</a> ( <a>unionPats</a> [p1, p2] ) x
--   </pre>
--   
--   (Other fusion rules, not yet documented, may also be in effect.)
forcep :: NFDataP a => Pattern -> a -> a

-- | <i>Deprecated: OverloadedStrings is in effect for pattern strings
--   (since 0.8), so you can use deepseqp and forcep with either a Pattern
--   or a String literal as first argument. To work with String variables,
--   write your own wrapper function calling compilePat (or build with
--   OVERLOEADED_STRINGS flag False). These underscore versions will be
--   removed in 0.9 (mere days from now...).</i>
deepseqp_ :: NFDataP a => Pattern -> a -> b -> b

-- | <a>deepseqp_</a> and <a>forcep_</a> are merely aliases to the
--   non-underscored functions. They are vestigial and retained for
--   compatibility until the next major version bump. Then it seems safe to
--   remove them, since can always build with <tt>OVERLOADED_STRINGS</tt>
--   flag set <tt>False</tt> if their absence is a problem (or define the
--   aliases yourself). So, DEPRECATED, and slated for removal in 0.8.

-- | <i>Deprecated: OverloadedStrings is in effect for pattern strings
--   (since 0.8), so you can use deepseqp and forcep with either a Pattern
--   or a String literal as first argument. To work with String variables,
--   write your own wrapper function calling compilePat (or build with
--   OVERLOEADED_STRINGS flag False). These underscore versions will be
--   removed in 0.9 (mere days from now...).</i>
forcep_ :: NFDataP a => Pattern -> a -> a
data DeepSeqBounded_PingException
DeepSeqBounded_PingException :: String -> DeepSeqBounded_PingException

-- | A class of types that can be evaluated over an arbitrary finite
--   pattern.
class (Typeable a, NFDataN a, NFData a) => NFDataP a where rnfp p x | handleAttrs p x == Node XX [] = undefined rnfp (Node (WI {}) _) _ = () rnfp (Node (TR as) chs) d = if elem td treps then d `seq` () else () where td = show $ typeRepTyCon $ typeOf d treps = typeConstraints as rnfp (Node (TI as) chs) d = if elem td treps then () else d `seq` () where td = show $ typeRepTyCon $ typeOf d treps = typeConstraints as rnfp (Node (TW as) chs) d = if elem td treps then d `seq` () else () where td = show $ typeRepTyCon $ typeOf d treps = typeConstraints as rnfp _ d = d `seq` ()
rnfp :: NFDataP a => Pattern -> a -> ()
handleAttrs :: Typeable d => Pattern -> d -> Pattern
instance Typeable DeepSeqBounded_PingException
instance Show DeepSeqBounded_PingException
instance (Typeable a, NFDataP a, Typeable b, NFDataP b, Typeable c, NFDataP c, Typeable d, NFDataP d, Typeable e, NFDataP e, Typeable f, NFDataP f, Typeable g, NFDataP g) => NFDataP (a, b, c, d, e, f, g)
instance (Typeable a, NFDataP a, Typeable b, NFDataP b, Typeable c, NFDataP c, Typeable d, NFDataP d, Typeable e, NFDataP e, Typeable f, NFDataP f) => NFDataP (a, b, c, d, e, f)
instance (Typeable a, NFDataP a, Typeable b, NFDataP b, Typeable c, NFDataP c, Typeable d, NFDataP d, Typeable e, NFDataP e) => NFDataP (a, b, c, d, e)
instance (Typeable a, NFDataP a, Typeable b, NFDataP b, Typeable c, NFDataP c, Typeable d, NFDataP d) => NFDataP (a, b, c, d)
instance (Typeable a, NFDataP a, Typeable b, NFDataP b, Typeable c, NFDataP c) => NFDataP (a, b, c)
instance (Typeable a, NFDataP a, Typeable b, NFDataP b) => NFDataP (a, b)
instance (Ix a, NFDataP a, NFDataP b) => NFDataP (Array a b)
instance NFDataP a => NFDataP [a]
instance NFDataP Version
instance (NFDataP a, NFDataP b) => NFDataP (Either a b)
instance NFDataP a => NFDataP (Maybe a)
instance (RealFloat a, NFDataP a) => NFDataP (Complex a)
instance (Integral a, NFDataP a) => NFDataP (Ratio a)
instance (Typeable a, Typeable b) => NFDataP (a -> b)
instance Typeable a => NFDataP (Fixed a)
instance NFDataP Word64
instance NFDataP Word32
instance NFDataP Word16
instance NFDataP Word8
instance NFDataP Int64
instance NFDataP Int32
instance NFDataP Int16
instance NFDataP Int8
instance NFDataP ()
instance NFDataP Bool
instance NFDataP Char
instance NFDataP Double
instance NFDataP Float
instance NFDataP Integer
instance NFDataP Word
instance NFDataP Int
instance Exception DeepSeqBounded_PingException


module Control.DeepSeq.Bounded.NFDataPDyn

-- | SOP/SYB hybrid dynamic <a>rnfp</a>. Takes a SYB <tt>GenericQ</tt>
--   <a>PatNode</a> argument, which extends the pattern dynamically,
--   depending on the type of the value node.
rnfpDyn :: (Generic a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a), All2 Data (Code a)) => (forall c. Data c => c -> PatNode) -> a -> ()

-- | SOP/SYB hybrid dynamic <a>deepseqp</a>.
deepseqpDyn :: (Show a, NFDataP a, Generic a, Data a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a), All2 Data (Code a)) => (forall c. Data c => c -> PatNode) -> a -> b -> b

-- | SOP/SYB hybrid dynamic <a>forcep</a>.
forcepDyn :: (Show a, NFDataP a, Generic a, Data a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a), All2 Data (Code a)) => (forall c. Data c => c -> PatNode) -> a -> a

-- | SOP-only dynamic <a>rnfp</a>. Takes a SOP generic function yielding
--   <a>PatNode</a>, which extends the pattern dynamically, depending on
--   the type of the value node.
rnfpDyn' :: (Generic a, All2 Generic (Code a), All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Generic c => c -> PatNode) -> a -> ()

-- | SOP-only dynamic <a>deepseqp</a>.
deepseqpDyn' :: (Show a, NFDataP a, Generic a, Data a, All2 Generic (Code a), All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Generic c => c -> PatNode) -> a -> b -> b

-- | SOP-only dynamic <a>forcep</a>.
forcepDyn' :: (Show a, NFDataP a, Generic a, Data a, All2 Generic (Code a), All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Generic c => c -> PatNode) -> a -> a

-- | SOP/Typeable hybrid dynamic <a>rnfp</a>. Takes a SYB <tt>GenericQ</tt>
--   <a>PatNode</a> argument, which extends the pattern dynamically,
--   depending on the type of the value node.
rnfpDyn'' :: (Generic a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Typeable c => c -> PatNode) -> a -> ()

-- | SOP/Typeable hybrid dynamic <a>deepseqp</a>.
deepseqpDyn'' :: (Show a, NFDataP a, Generic a, Data a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Typeable c => c -> PatNode) -> a -> b -> b

-- | SOP/Typeable hybrid dynamic <a>forcep</a>.
forcepDyn'' :: (Show a, NFDataP a, Generic a, Data a, All2 Show (Code a), All2 NFData (Code a), All2 NFDataN (Code a), All2 NFDataP (Code a)) => (forall c. Typeable c => c -> PatNode) -> a -> a


-- | This module provides generic functions <a>rnf_</a>, <a>force_</a> and
--   <a>seq_</a>, for efficient switching between <tt>n=0</tt> and
--   <tt>n=2</tt> in the corresponding 'rnfn n', 'forcen n' and 'deepseqn
--   n' (of <a>NFDataN</a>). This is useful for connecting units of forcing
--   (propagating demand). It was motivated for use with
--   auto-instrumentation, where <a>seq_</a> can be injected at every node
--   of the AST (refer to the <a>seqaid</a> project).
--   
--   Each <a>SeqNode</a> carries a couple bits of information, determining
--   which depth (0 or 2) is in effect, and whether to spark parallel
--   evaluation when the depth is 2. This state can be configured
--   statically or dynamically.
module Control.DeepSeq.Bounded.Seqable
rnf_ :: Generic a => SeqNode -> a -> ()
force_ :: Generic a => SeqNode -> a -> a
seq_ :: Generic a => SeqNode -> a -> b -> b
data SeqNode
Insulate :: SeqNode
Propagate :: SeqNode
Spark :: SeqNode


-- | Support for generic deriving (via <a>Generics.SOP</a>) of
--   <a>NFDataN</a> instances.
--   
--   <a>NFDataN</a> does not have any superclasses.
--   
--   It is also possible to derive instances using <a>GHC.Generics</a>,
--   which avoids SOP and TH, but if you plan to use <tt>NFDataP</tt> then
--   SOP is required. (SOP can be used without TH if necessary; the
--   interested reader is referred to SOP documentation.)
--   
--   This metaboilerplate is standard for using the generic deriving
--   facilities of <a>GHC.Generics</a> and <a>Generics.SOP</a>. Consider
--   <a>seqaid</a> for a turnkey solution.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE GADTs #-}  -- for GHC &lt; 7.8 (== 7.6.3)
--   
--   import Generics.SOP.TH
--   import Control.DeepSeq.Bounded ( NFDataN(..), grnfn )
--   import GHC.Generics ( Generic )
--   
--   import Control.DeepSeq.Bounded ( forcen )
--   
--   data TA = A1 TB TA | A2  deriving ( Generic )
--   instance NFDataN TA where rnfn = grnfn
--   
--   data TB = B1 Int | B2 TA  deriving ( Generic )
--   instance NFDataN TB where rnfn = grnfn
--   
--   deriveGeneric ''TA
--   deriveGeneric ''TB
--   
--   main = return $! forcen 3 (A1 (B2 undefined) A2)
--   </pre>
module Control.DeepSeq.Bounded.Generic.GNFDataN
grnfn :: (Generic a, All2 NFDataN (Code a)) => Int -> a -> ()


-- | Support for generic deriving (via <a>Generics.SOP</a>) of
--   <a>NFDataP</a> instances.
--   
--   Note that <a>NFDataP</a> has superclasses <a>NFDataN</a>,
--   <a>NFData</a> and <a>Typeable</a>.
--   
--   This metaboilerplate is standard for using the generic deriving
--   facilities of <a>GHC.Generics</a> and <a>Generics.SOP</a>. Consider
--   <a>seqaid</a> for a turnkey solution.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE DeriveDataTypeable #-}
--   {-# LANGUAGE GADTs #-}  -- for GHC &lt; 7.8 (== 7.6.3)
--   
--   import Generics.SOP.TH
--   import Control.DeepSeq.Bounded ( NFDataP(..), grnfp )
--   import Control.DeepSeq.Bounded ( NFDataN(..), grnfn )
--   import Control.DeepSeq.Generics ( NFData(..), genericRnf )
--   import GHC.Generics ( Generic )    -- for deriving NFData
--   import Data.Typeable ( Typeable )  -- for name-constrained pattern nodes
--   
--   import Control.DeepSeq.Bounded ( forcep )
--   
--   data TA = A1 TB TA | A2  deriving ( Generic, Typeable )
--   instance NFData  TA where rnf  = genericRnf
--   instance NFDataN TA where rnfn = grnfn
--   instance NFDataP TA where rnfp = grnfp
--   
--   data TB = B1 Int | B2 TA  deriving ( Generic, Typeable )
--   instance NFData  TB where rnf  = genericRnf
--   instance NFDataN TB where rnfn = grnfn
--   instance NFDataP TB where rnfp = grnfp
--   
--   deriveGeneric ''TA
--   deriveGeneric ''TB
--   
--   main = return $! forcep "((!).)" (A1 (B2 undefined) A2)
--   </pre>
module Control.DeepSeq.Bounded.Generic.GNFDataP
grnfp :: (Generic a, HasDatatypeInfo a, All2 NFDataP (Code a), NFDataP a) => Pattern -> a -> ()


-- | Support for generic deriving (via <a>Generics.SOP</a>) of
--   <a>NFDataN</a> and <a>NFDataP</a> instances. Also, <tt>SOP</tt>
--   generic functions implementing <a>Seqable</a> without a class and
--   instances.
--   
--   This metaboilerplate is standard for using the generic deriving
--   facilities of <a>GHC.Generics</a> and <a>Generics.SOP</a>. Consider
--   <a>seqaid</a> for a turnkey solution.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE DeriveDataTypeable #-}
--   {-# LANGUAGE GADTs #-}  -- for GHC &lt; 7.8 (== 7.6.3)
--   
--   import Generics.SOP.TH
--   import Control.DeepSeq.Bounded ( NFDataN(..), grnfn, NFDataP(..), grnfp )
--   import Control.DeepSeq.Generic ( NFData(..), genericRnf )
--   import GHC.Generics ( Generic )    -- for deriving NFData
--   import Data.Typeable ( Typeable )  -- for name-constrained pattern nodes
--   import Control.DeepSeq.Bounded ( forcen, forcep )
--   
--   data TA = A1 TB TA | A2  deriving ( Generic, Typeable )
--   instance NFData  TA where rnf  = genericRnf
--   instance NFDataN TA where rnfn = grnfn
--   instance NFDataP TA where rnfp = grnfp
--   
--   data TB = B1 Int | B2 TA  deriving ( Generic, Typeable )
--   instance NFData  TB where rnf  = genericRnf
--   instance NFDataN TB where rnfn = grnfn
--   instance NFDataP TB where rnfp = grnfp
--   
--   deriveGeneric ''TA
--   deriveGeneric ''TB
--   
--   main = mainP
--   mainN = return $! forcen 3         (A1 (B2 undefined) A2) :: IO TA
--   mainP = return $! forcep "((!).)"  (A1 (B2 undefined) A2) :: IO TA
--   mainS = return $! force_ Propagate (A1 (force_ Propagate (B2 undefined)) A2) :: IO TA
--   </pre>
module Control.DeepSeq.Bounded.Generic
grnfn :: (Generic a, All2 NFDataN (Code a)) => Int -> a -> ()
grnfp :: (Generic a, HasDatatypeInfo a, All2 NFDataP (Code a), NFDataP a) => Pattern -> a -> ()
grnf_ :: Generic a => SeqNode -> a -> ()
gseq_ :: Generic a => SeqNode -> a -> b -> b
gforce_ :: Generic a => SeqNode -> a -> a


-- | We provide forcing functions which take a non-strict value of a
--   datatype, and force its evaluation in a pricipled way. As with
--   <a>NFData</a>, one should bear in mind the difference between forcing
--   and demand: in order for your forcing to take effect, demand must be
--   placed on the forcing function itself by the course of execution.
--   
--   Artificial forcing is most commonly used to suppress space leak, but
--   it has many uses besides. Another is to ensure that exceptions hidden
--   within lazy fields of a data structure don't leak outside the scope of
--   the exception handler; another is to force evaluation of a data
--   structure in one thread, before passing it to another thread
--   (preventing work moving to the wrong threads, a form of <i>time
--   leak</i>).
--   
--   Unlike <a>DeepSeq</a>, potentially infinite values of coinductive data
--   types are supported by principled bounding of deep evaluation.
--   
--   Refer to comments in the <a>deepseq</a> package for more information
--   on how artificial forcing can be useful.
--   
--   Recently, control (static or dynamic) of parallelisation has been
--   added. Control of evaluation order is also supported (via
--   <a>pseq</a>).
module Control.DeepSeq.Bounded
data Rose a
Node :: a -> [Rose a] -> Rose a
class FF k where data family F k :: * -> *
phi :: (FF k, Generic v, NFDataN v, NFDataP v) => k -> F k v -> v
instance FF Pattern
instance FF Int
instance FF SeqNode
