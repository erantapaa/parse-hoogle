-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators to efficiently slice and dice audio streams
--   
@package conduit-audio
@version 0.1


-- | A high-level functional interface for manipulating streams of audio.
module Data.Conduit.Audio

-- | An abstraction of a stream of audio. Inside is a Conduit <a>Source</a>
--   which loads or generates smallish chunks of audio on demand.
--   <tt>m</tt> is the <a>Monad</a> used by the <a>Source</a> to produce
--   audio. <tt>a</tt> is the type of audio samples, contained in storable
--   vectors (and thus should be <a>Storable</a>). Both (signed)
--   <a>Integral</a> and <a>Fractional</a> sample types are supported.
data AudioSource m a
AudioSource :: Source m (Vector a) -> Rate -> Channels -> Frames -> AudioSource m a

-- | The stream of audio chunks; samples interleaved by channel. Each chunk
--   can be any positive whole number of frames.
source :: AudioSource m a -> Source m (Vector a)
rate :: AudioSource m a -> Rate
channels :: AudioSource m a -> Channels

-- | The stated length in frames of this audio stream. Not guaranteed to be
--   exactly frame-accurate; the output of some operations like resampling
--   or time-stretching may store only approximate frame counts.
frames :: AudioSource m a -> Frames

-- | A duration in real time.
type Seconds = Double

-- | A frame consists of one sample for each audio channel.
type Frames = Int

-- | The number of samples per second.
type Rate = Double

-- | The number of audio channels (1 = mono, 2 = stereo, etc.)
type Channels = Int

-- | Used for functions that accept durations in either real time or audio
--   frames.
data Duration
Seconds :: Seconds -> Duration
Frames :: Frames -> Duration

-- | Generates a stream of silence with the given parameters.
silent :: (Monad m, Num a, Storable a) => Duration -> Rate -> Channels -> AudioSource m a

-- | Generates a mono sine wave with the given frequency.
sine :: (Monad m, Floating a, Storable a) => a -> Duration -> Rate -> AudioSource m a

-- | Connects the end of the first audio source to the beginning of the
--   second. The two sources must have the same sample rate and channel
--   count.
concatenate :: Monad m => AudioSource m a -> AudioSource m a -> AudioSource m a

-- | Mixes two audio streams together by adding them samplewise. The two
--   streams must have the same sample rate and channel count. It is
--   recommended to only mix floating-point sample types. If you mix
--   integral types and the result goes outside of the type's range, the
--   result will not be a normal "clipping" effect, but will instead
--   overflow, producing glitchy audio.
mix :: (Monad m, Num a, Storable a) => AudioSource m a -> AudioSource m a -> AudioSource m a

-- | Combines the channels of two audio streams into a single source with
--   all the channels. The two streams must have the same sample rate, but
--   can have any number of channels.
merge :: (Monad m, Num a, Storable a) => AudioSource m a -> AudioSource m a -> AudioSource m a

-- | Splits an audio stream into several, each providing a single channel
--   of the original stream.
splitChannels :: (Monad m, Storable a) => AudioSource m a -> [AudioSource m a]

-- | Adds silence to the start of the audio stream.
padStart :: (Monad m, Num a, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Adds silence to the end of the audio stream.
padEnd :: (Monad m, Num a, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Takes no more than the given duration of audio from the start of the
--   stream.
takeStart :: (Monad m, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Takes no more than the given duration of audio from the end of the
--   stream. This function relies on the <a>frames</a> value stored with
--   the stream.
takeEnd :: (Monad m, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Drops the given duration of audio from the start of the stream.
dropStart :: (Monad m, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Drops the given duration of audio from the end of the stream. This
--   function relies on the <a>frames</a> value stored with the stream.
dropEnd :: (Monad m, Storable a) => Duration -> AudioSource m a -> AudioSource m a

-- | Fades the audio from start (silent) to end (original volume). This
--   function relies on the <a>frames</a> value stored with the stream.
fadeIn :: (Monad m, Ord a, Fractional a, Storable a) => AudioSource m a -> AudioSource m a

-- | Fades the audio from start (original volume) to end (silent). This
--   function relies on the <a>frames</a> value stored with the stream.
fadeOut :: (Monad m, Ord a, Fractional a, Storable a) => AudioSource m a -> AudioSource m a

-- | Applies a function to every sample in the audio stream.
mapSamples :: (Monad m, Storable a, Storable b) => (a -> b) -> AudioSource m a -> AudioSource m b

-- | Multiplies all the audio samples by the given scaling factor. It is
--   best to use this function on floating-point sample types, for the same
--   reasons that apply to <a>mix</a>.
gain :: (Monad m, Num a, Storable a) => a -> AudioSource m a -> AudioSource m a

-- | Divides the vector length by the channel count to calculate the number
--   of audio frames.
vectorFrames :: Storable a => Vector a -> Channels -> Frames

-- | Uses the sample rate to convert frames to seconds.
framesToSeconds :: Frames -> Rate -> Seconds

-- | Uses the sample rate to convert seconds to frames, rounding if
--   necessary.
secondsToFrames :: Seconds -> Rate -> Frames

-- | An arbitrary size, in frames, for smallish audio chunks.
chunkSize :: Frames

-- | Given a vector with interleaved samples, like <tt>[L0, R0, L1, R1,
--   ...]</tt>, converts it into <tt>[[L0, L1, ...], [R0, R1, ...]]</tt>.
deinterleave :: Storable a => Channels -> Vector a -> [Vector a]

-- | Opposite of <a>deinterleave</a>. All the input vectors should have the
--   same length.
interleave :: Storable a => [Vector a] -> Vector a

-- | Converts fractional samples in the range <tt>[-1, 1]</tt> to integral
--   samples in a two's-complement type. Fractional samples beyond that
--   range are clamped.
integralSample :: (RealFrac a, Integral b, Bounded b) => a -> b

-- | Converts integral samples in a two's-complement type to fractional
--   samples in the range <tt>[-1, 1]</tt>.
fractionalSample :: (Integral a, Bounded a, Fractional b) => a -> b
instance Eq Duration
instance Ord Duration
instance Show Duration
instance Read Duration
