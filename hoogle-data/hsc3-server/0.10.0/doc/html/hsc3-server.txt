-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SuperCollider server resource management and synchronization.
--   
@package hsc3-server
@version 0.10.0

module Sound.SC3.Server.Allocator.Range

-- | Open ended interval [begin, end).
data Range a

-- | Construct a range from a lower bound (included) and an upper bound
--   (excluded).
--   
--   <pre>
--   \(r :: Range Int) -&gt; begin r == end r
--   </pre>
range :: Ord a => a -> a -> Range a

-- | Construct a range from a size and a lower bound.
--   
--   <pre>
--   &gt;&gt;&gt; sized 20 10
--   Range 10 30
--   </pre>
sized :: Num a => Int -> a -> Range a

-- | The empty range starting at some value.
--   
--   <pre>
--   &gt;&gt;&gt; empty 10
--   Range 10 10
--   </pre>
--   
--   null (empty 10) True
--   
--   size (empty 10) 0
empty :: Num a => a -> Range a
begin :: Range a -> a
end :: Range a -> a

-- | The last value in the range.
--   
--   <pre>
--   &gt;&gt;&gt; last (range 10 20)
--   19
--   </pre>
last :: Enum a => Range a -> a

-- | The size of the range.
--   
--   <pre>
--   &gt;&gt;&gt; size (range 10 20)
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (sized 100 10)
--   100
--   </pre>
size :: Integral a => Range a -> Int

-- | True if range is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null (range 10 10)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (range 10 20)
--   False
--   </pre>
null :: Eq a => Range a -> Bool

-- | Convert range to a list of its values.
toList :: Enum a => Range a -> [a]

-- | Return true if a given value is contained within the range.
--   
--   <pre>
--   &gt;&gt;&gt; within 12 (sized 3 10)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; within 20 (range 10 20)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; within 30 (range 30 30)
--   False
--   </pre>
within :: Ord a => a -> Range a -> Bool

-- | Return true if two ranges adjoin each other.
--   
--   <pre>
--   &gt;&gt;&gt; range 10 20 `adjoins` range 20 30
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; range 10 20 `adjoins` range 21 30
--   False
--   </pre>
adjoins :: Eq a => Range a -> Range a -> Bool

-- | Return true if two ranges overlap each other.
overlaps :: Ord a => Range a -> Range a -> Bool

-- | Return true if the second range lies completely within the first
--   range.
contains :: Ord a => Range a -> Range a -> Bool

-- | Split a range at an index.
--   
--   <pre>
--   &gt;&gt;&gt; let (r1, r2) = split 6 (range 10 20)
--   
--   &gt;&gt;&gt; size r1
--   6
--   
--   &gt;&gt;&gt; size r2
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (r1, r2) = split 6 (empty 6)
--   
--   &gt;&gt;&gt; null r1 &amp;&amp; null r2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (r1, r2) = split 10 (sized 4 10)
--   
--   &gt;&gt;&gt; size r1
--   4
--   
--   &gt;&gt;&gt; size r2
--   0
--   </pre>
split :: Integral a => Int -> Range a -> (Range a, Range a)
join :: Ord a => Range a -> Range a -> Range a
instance Eq a => Eq (Range a)
instance Show a => Show (Range a)

module Sound.SC3.Server.Allocator

-- | Failure type for allocators.
data AllocFailure

-- | There are no free ids left in the allocator.
NoFreeIds :: AllocFailure

-- | The id being released has not been allocated by this allocator.
InvalidId :: AllocFailure

-- | Simple allocator usage statistics.
data Statistics
Statistics :: Int -> Int -> Int -> Statistics

-- | Total number of available identifiers
numAvailable :: Statistics -> Int

-- | Number of currently available identifiers
numFree :: Statistics -> Int

-- | Number of identifiers currently in use
numUsed :: Statistics -> Int

-- | Percentage of currently available identifiers.
--   
--   <pre>
--   percentFree s = numFree s / numAvailable s
--   percentFree s + percentUsed s = 1
--   </pre>
percentFree :: Statistics -> Double

-- | Percentage of identifiers currently in use.
--   
--   <pre>
--   percentUsed s = numUsed s / numAvailable s
--   percentUsed s + percentFree s = 1
--   </pre>
percentUsed :: Statistics -> Double

-- | IdAllocator provides an interface for allocating and releasing
--   identifiers that correspond to server resources, such as node, buffer
--   and bus ids.
class IdAllocator a where type family Id a
alloc :: (IdAllocator a, Failure AllocFailure m) => a -> m (Id a, a)
free :: (IdAllocator a, Failure AllocFailure m) => Id a -> a -> m a
statistics :: IdAllocator a => a -> Statistics

-- | Allocate a number of (not necessarily consecutive) IDs with the given
--   allocator.
--   
--   Returns the list of IDs and the modified allocator.
allocMany :: (IdAllocator a, Failure AllocFailure m) => Int -> a -> m ([Id a], a)

-- | Free a number of IDs with the given allocator.
--   
--   Returns the modified allocator.
freeMany :: (IdAllocator a, Failure AllocFailure m) => [Id a] -> a -> m a

-- | RangeAllocator provides an interface for allocating and releasing
--   ranges of consecutive identifiers.
class IdAllocator a => RangeAllocator a
allocRange :: (RangeAllocator a, Failure AllocFailure m) => Int -> a -> m (Range (Id a), a)
freeRange :: (RangeAllocator a, Failure AllocFailure m) => Range (Id a) -> a -> m a
instance Typeable AllocFailure
instance Show AllocFailure
instance Eq Statistics
instance Show Statistics
instance Exception AllocFailure

module Sound.SC3.Server.Allocator.BlockAllocator.FirstFit
data FirstFitAllocator i
data Sorting
Address :: Sorting
IncreasingSize :: Sorting
DecreasingSize :: Sorting
data Coalescing
NoCoalescing :: Coalescing
LazyCoalescing :: Coalescing
cons :: Integral i => Sorting -> Coalescing -> Range i -> FirstFitAllocator i
addressFit :: Integral i => Coalescing -> Range i -> FirstFitAllocator i
bestFit :: Integral i => Coalescing -> Range i -> FirstFitAllocator i
worstFit :: Integral i => Coalescing -> Range i -> FirstFitAllocator i
instance Enum Coalescing
instance Eq Coalescing
instance Show Coalescing
instance Eq i => Eq (FirstFitAllocator i)
instance Show i => Show (FirstFitAllocator i)
instance Integral i => RangeAllocator (FirstFitAllocator i)
instance Integral i => IdAllocator (FirstFitAllocator i)

module Sound.SC3.Server.Allocator.SetAllocator
data SetAllocator i
cons :: Integral i => Range i -> SetAllocator i
instance Eq i => Eq (SetAllocator i)
instance (Enum i, Show i) => Show (SetAllocator i)
instance Integral i => IdAllocator (SetAllocator i)

module Sound.SC3.Server.Allocator.SimpleAllocator
data SimpleAllocator i
cons :: Range i -> SimpleAllocator i
instance Eq i => Eq (SimpleAllocator i)
instance Show i => Show (SimpleAllocator i)
instance Integral i => IdAllocator (SimpleAllocator i)


-- | Helper functions for newtype wrappers.
module Sound.SC3.Server.Allocator.Wrapped
alloc :: (Failure AllocFailure m, IdAllocator a) => (a -> a') -> a -> m (Id a, a')
free :: (Failure AllocFailure m, IdAllocator a) => (a -> a') -> Id a -> a -> m a'
statistics :: IdAllocator a => a -> Statistics
allocRange :: (Failure AllocFailure m, RangeAllocator a) => (a -> a') -> Int -> a -> m (Range (Id a), a')
freeRange :: (Failure AllocFailure m, RangeAllocator a) => (a -> a') -> Range (Id a) -> a -> m a'


-- | Server notification processors.
module Sound.SC3.Server.Notification

-- | A notification transformer, extracting a value from a matching OSC
--   message.
newtype Notification a
Notification :: (Message -> Maybe a) -> Notification a
match :: Notification a -> Message -> Maybe a

-- | Wait for an OSC message matching a specific address.
--   
--   Returns the matched OSC message.
hasAddress :: String -> Notification Message

-- | Send an OSC packet and wait for a notification.
--   
--   Returns the transformed value.
waitFor :: (RecvOSC m, SendOSC m) => Notification a -> m a

-- | Send an OSC packet and wait for a list of notifications.
--   
--   Returns the transformed values, in unspecified order.
waitForAll :: (RecvOSC m, SendOSC m) => [Notification a] -> m [a]
data Status
Status :: Int32 -> Int32 -> Int32 -> Int32 -> Float -> Float -> Double -> Double -> Status
numUGens :: Status -> Int32
numSynths :: Status -> Int32
numGroups :: Status -> Int32
numSynthDefs :: Status -> Int32
avgCPU :: Status -> Float
peakCPU :: Status -> Float
nominalSampleRate :: Status -> Double
actualSampleRate :: Status -> Double
status_reply :: Notification Status
tr :: NodeId -> Maybe Int32 -> Notification Float
synced :: SyncId -> Notification SyncId
done :: String -> Notification [Datum]
data NodeNotification
headNodeId :: NodeNotification -> Maybe NodeId
tailNodeId :: NodeNotification -> Maybe NodeId
n_go :: NodeId -> Notification NodeNotification
n_end :: NodeId -> Notification NodeNotification
n_off :: NodeId -> Notification NodeNotification
n_on :: NodeId -> Notification NodeNotification
n_move :: NodeId -> Notification NodeNotification
n_info :: NodeId -> Notification NodeNotification
n_go_ :: NodeId -> Notification ()
n_end_ :: NodeId -> Notification ()
n_off_ :: NodeId -> Notification ()
n_on_ :: NodeId -> Notification ()
n_set :: NodeId -> Notification [(Either Int32 String, Float)]
n_setn :: NodeId -> Notification [(Either Int32 String, [Float])]
data BufferInfo
BufferInfo :: Int32 -> Int32 -> Float -> BufferInfo
numFrames :: BufferInfo -> Int32
numChannels :: BufferInfo -> Int32
sampleRate :: BufferInfo -> Float
b_info :: BufferId -> Notification BufferInfo
instance Eq Status
instance Show Status
instance Eq NodeNotification
instance Show NodeNotification
instance Eq BufferInfo
instance Show BufferInfo
instance Functor Notification

module Sound.SC3.Server.State.Monad.Class
class Monad m => MonadServer m
serverOptions :: MonadServer m => m ServerOptions
rootNodeId :: MonadServer m => m NodeId

-- | Return a server option.
serverOption :: MonadServer m => (ServerOptions -> a) -> m a

-- | Monadic resource id management interface.
class Monad m => MonadIdAllocator m where data family Allocator m a
nodeIdAllocator :: MonadIdAllocator m => Allocator m NodeIdAllocator
syncIdAllocator :: MonadIdAllocator m => Allocator m SyncIdAllocator
bufferIdAllocator :: MonadIdAllocator m => Allocator m BufferIdAllocator
audioBusIdAllocator :: MonadIdAllocator m => Allocator m AudioBusIdAllocator
controlBusIdAllocator :: MonadIdAllocator m => Allocator m ControlBusIdAllocator
alloc :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> m (Id a)
free :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> Id a -> m ()
statistics :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> m Statistics
allocRange :: (MonadIdAllocator m, RangeAllocator a) => Allocator m a -> Int -> m (Range (Id a))
freeRange :: (MonadIdAllocator m, RangeAllocator a) => Allocator m a -> Range (Id a) -> m ()
class SendOSC m => RequestOSC m
request :: (RequestOSC m, OSC o) => o -> Notification a -> m a
requestAll :: (RequestOSC m, OSC o) => o -> [Notification a] -> m [a]

module Sound.SC3.Server.State.Monad
data Server a

-- | Run a <a>Server</a> computation given a connection and return the
--   result.
runServer :: Server a -> ServerOptions -> Connection -> IO a
class Monad m => MonadServer m
serverOptions :: MonadServer m => m ServerOptions
rootNodeId :: MonadServer m => m NodeId

-- | Return a server option.
serverOption :: MonadServer m => (ServerOptions -> a) -> m a

-- | Buffer id.
data BufferId

-- | Buffer id allocator.
data BufferIdAllocator

-- | Control bus id.
data ControlBusId

-- | Control bus id allocator.
data ControlBusIdAllocator

-- | Audio bus id.
data AudioBusId

-- | Audio bus id allocator.
data AudioBusIdAllocator

-- | Node id.
data NodeId

-- | Node id allocator.
data NodeIdAllocator

-- | Monadic resource id management interface.
class Monad m => MonadIdAllocator m where data family Allocator m a
nodeIdAllocator :: MonadIdAllocator m => Allocator m NodeIdAllocator
syncIdAllocator :: MonadIdAllocator m => Allocator m SyncIdAllocator
bufferIdAllocator :: MonadIdAllocator m => Allocator m BufferIdAllocator
audioBusIdAllocator :: MonadIdAllocator m => Allocator m AudioBusIdAllocator
controlBusIdAllocator :: MonadIdAllocator m => Allocator m ControlBusIdAllocator
alloc :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> m (Id a)
free :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> Id a -> m ()
statistics :: (MonadIdAllocator m, IdAllocator a) => Allocator m a -> m Statistics
allocRange :: (MonadIdAllocator m, RangeAllocator a) => Allocator m a -> Int -> m (Range (Id a))
freeRange :: (MonadIdAllocator m, RangeAllocator a) => Allocator m a -> Range (Id a) -> m ()

-- | Sender monad.
class Monad m => SendOSC (m :: * -> *)
sendOSC :: (SendOSC m, OSC o) => o -> m ()
class SendOSC m => RequestOSC m
request :: (RequestOSC m, OSC o) => o -> Notification a -> m a
requestAll :: (RequestOSC m, OSC o) => o -> [Notification a] -> m [a]

-- | Synchronisation barrier id.
data SyncId

-- | Synchronisation barrier id allocator.
data SyncIdAllocator

-- | Send an OSC packet and wait for the synchronization barrier.
sync :: Packet -> Server ()
unsafeSync :: Server ()
asTransport :: AsTransport a -> Server a

-- | Fork a computation in a new thread and return the thread id.
--   
--   This is an alias for <a>fork</a>.
fork :: Server () -> Server ThreadId
instance Applicative Server
instance Failure AllocFailure Server
instance Functor Server
instance Monad Server
instance MonadFix Server
instance MonadIO Server
instance Functor AsTransport
instance Applicative AsTransport
instance Monad AsTransport
instance MonadIO AsTransport
instance RequestOSC Server
instance Transport AsTransport
instance DuplexOSC AsTransport
instance RecvOSC AsTransport
instance SendOSC AsTransport
instance SendOSC Server
instance MonadIdAllocator Server
instance MonadServer Server
instance MonadBaseControl IO Server
instance MonadBase IO Server

module Sound.SC3.Server.State.Monad.Process

-- | Open a transport to an existing <tt>scsynth</tt> process determined by
--   <a>networkPort</a> and run the supplied <a>Server</a> action.
withTransport :: ServerOptions -> RTOptions -> Maybe String -> Server a -> IO a

-- | Start an <tt>scsynth</tt> instance and run the supplied <a>Server</a>
--   action.
--   
--   When the action returns, <tt>scsynth</tt> will quit.
withSynth :: ServerOptions -> RTOptions -> OutputHandler -> Server a -> IO a

-- | Start an <tt>scsynth</tt> instance with default options and run the
--   supplied <a>Server</a> action.
withDefaultSynth :: Server a -> IO a

module Sound.SC3.Server.State.Monad.Command

-- | Server-side action (or sequence of actions).
data Request m a

-- | Execute a request.
--   
--   The commands after the last asynchronous command will be scheduled at
--   the given time.
exec :: (MonadIdAllocator m, RequestOSC m) => Time -> Request m a -> m a

-- | Execute a request immediately.
exec_ :: (MonadIdAllocator m, RequestOSC m) => Request m a -> m a

-- | Representation of a deferred server resource.
--   
--   Resource resource values can only be observed with <a>extract</a>
--   after the surrounding <a>Request</a> action has been executed with
--   <a>exec</a>.
data Result a

-- | Extract a 'Result'\'s value.
extract :: MonadIO m => Result a -> m a

-- | Request server status.
status :: MonadIO m => Request m (Result Status)

-- | Request server status.
statusM :: (MonadIdAllocator m, RequestOSC m, MonadIO m) => m Status

-- | Enumeration of Message printer types.
data PrintLevel :: *
NoPrinter :: PrintLevel
TextPrinter :: PrintLevel
HexPrinter :: PrintLevel
AllPrinter :: PrintLevel

-- | Select printing of incoming Open Sound Control messages.
dumpOSC :: MonadIdAllocator m => PrintLevel -> Request m ()

-- | Remove all bundles from the scheduling queue.
clearSched :: Monad m => Request m ()

-- | Error posting scope.
data ErrorScope :: *

-- | Global scope
Globally :: ErrorScope

-- | Bundle scope
Locally :: ErrorScope

-- | Error posting mode.
data ErrorMode :: *

-- | Turn error posting off
ErrorsOff :: ErrorMode

-- | Turn error posting on
ErrorsOn :: ErrorMode

-- | Set error posting scope and mode.
errorMode :: Monad m => ErrorScope -> ErrorMode -> Request m ()
data SynthDef

-- | Construct a synth definition from a name.
d_named :: String -> SynthDef

-- | The default synth definition.
d_default :: SynthDef

-- | Compute a unique name for a UGen graph. graphName :: UGen -&gt; String
--   graphName = SHA.showBSasHex . SHA.hash SHA.SHA256 . BZip.compress .
--   Synthdef.graphdef . Synthdef.synth
--   
--   Create a new synth definition. d_new :: Monad m =&gt; String -&gt;
--   UGen -&gt; Async m SynthDef d_new prefix ugen | length prefix &lt; 127
--   = mkAsync $ return (sd, f) | otherwise = error "d_new: name prefix too
--   long, resulting string exceeds 255 characters" where sd = SynthDef
--   (prefix ++ "-" ++ graphName ugen) f osc = (mkC C.d_recv C.d_recv' osc)
--   (Synthdef.synthdef (name sd) ugen)
--   
--   Create a synth definition from a name and a UGen graph.
d_recv :: Monad m => String -> UGen -> Request m SynthDef

-- | Load a synth definition from a named file. (Asynchronous)
d_load :: Monad m => FilePath -> Request m ()

-- | Load a directory of synth definition files. (Asynchronous)
d_loadDir :: Monad m => FilePath -> Request m ()

-- | Remove definition once all nodes using it have ended.
d_free :: Monad m => SynthDef -> Request m ()
class Node a
nodeId :: Node a => a -> NodeId

-- | Enumeration of possible locations to add new nodes (s_new and g_new).
data AddAction :: *
AddToHead :: AddAction
AddToTail :: AddAction
AddBefore :: AddAction
AddAfter :: AddAction
AddReplace :: AddAction
data AbstractNode

-- | Construct an abstract node wrapper.
node :: (Eq n, Node n, Show n) => n -> AbstractNode

-- | Place node <tt>a</tt> after node <tt>b</tt>.
n_after :: (Node a, Node b, Monad m) => a -> b -> Request m ()

-- | Place node <tt>a</tt> before node <tt>b</tt>.
n_before :: (Node a, Node b, Monad m) => a -> b -> Request m ()

-- | Fill ranges of a node's control values.
n_fill :: (Node a, Monad m) => a -> [(String, Int, Double)] -> Request m ()

-- | Delete a node.
n_free :: (Node a, MonadIdAllocator m) => a -> Request m ()

-- | Mapping node controls to buses.
class BusMapping n b
n_map :: (BusMapping n b, Node n, Bus b, Monad m) => n -> String -> b -> Request m ()
n_unmap :: (BusMapping n b, Node n, Bus b, Monad m) => n -> String -> b -> Request m ()

-- | Query a node.
n_query_ :: (Node a, Monad m) => a -> Request m ()

-- | Query a node.
n_query :: (Node a, MonadIO m) => a -> Request m (Result NodeNotification)

-- | Query a node.
n_queryM :: (Node a, MonadIdAllocator m, RequestOSC m, MonadIO m) => a -> m NodeNotification

-- | Turn node on or off.
n_run_ :: (Node a, Monad m) => a -> Bool -> Request m ()

-- | Set a node's control values.
n_set :: (Node a, Monad m) => a -> [(String, Double)] -> Request m ()

-- | Set ranges of a node's control values.
n_setn :: (Node a, Monad m) => a -> [(String, [Double])] -> Request m ()

-- | Trace a node.
n_trace :: (Node a, Monad m) => a -> Request m ()

-- | Move an ordered sequence of nodes.
n_order :: (Node n, Monad m) => AddAction -> n -> [AbstractNode] -> Request m ()
newtype Synth
Synth :: NodeId -> Synth

-- | Create a new synth.
s_new :: MonadIdAllocator m => SynthDef -> AddAction -> Group -> [(String, Double)] -> Request m Synth

-- | Create a new synth in the root group.
s_new_ :: (MonadServer m, MonadIdAllocator m) => SynthDef -> AddAction -> [(String, Double)] -> Request m Synth

-- | Release a synth with a "gate" envelope control.
s_release :: MonadIdAllocator m => Double -> Synth -> Request m ()

-- | Get control values.
s_get :: MonadIO m => Synth -> [String] -> Request m (Result [(Either Int32 String, Float)])

-- | Get ranges of control values.
s_getn :: MonadIO m => Synth -> [(String, Int)] -> Request m (Result [(Either Int32 String, [Float])])

-- | Free a synth's ID and auto-reassign it to a reserved value (the node
--   is not freed!).
s_noid :: MonadIdAllocator m => Synth -> Request m ()
newtype Group
Group :: NodeId -> Group

-- | Return the server's root group.
rootNode :: MonadServer m => m Group

-- | Create a new group.
g_new :: MonadIdAllocator m => AddAction -> Group -> Request m Group

-- | Create a new group in the top level group.
g_new_ :: (MonadServer m, MonadIdAllocator m) => AddAction -> Request m Group

-- | Free all synths in this group and all its sub-groups.
g_deepFree :: Monad m => Group -> Request m ()

-- | Delete all nodes in a group.
g_freeAll :: Monad m => Group -> Request m ()

-- | Add node to head of group.
g_head :: (Node n, Monad m) => Group -> n -> Request m ()

-- | Add node to tail of group.
g_tail :: (Node n, Monad m) => Group -> n -> Request m ()

-- | Post a representation of a group's node subtree, optionally including
--   the current control values for synths.
g_dumpTree :: Monad m => [(Group, Bool)] -> Request m ()

-- | Send a plugin command.
cmd :: Monad m => String -> [Datum] -> Request m ()

-- | Send a command to a unit generator.
u_cmd :: Monad m => AbstractNode -> Int -> String -> [Datum] -> Request m ()
data Buffer
bufferId :: Buffer -> BufferId

-- | Allocates zero filled buffer to number of channels and samples.
--   (Asynchronous)
b_alloc :: MonadIdAllocator m => Int -> Int -> Request m Buffer

-- | Allocate buffer space and read a sound file. (Asynchronous)
b_allocRead :: MonadIdAllocator m => FilePath -> Maybe Int -> Maybe Int -> Request m Buffer

-- | Allocate buffer space and read a sound file, picking specific
--   channels. (Asynchronous)
b_allocReadChannel :: MonadIdAllocator m => FilePath -> Maybe Int -> Maybe Int -> [Int] -> Request m Buffer

-- | Read sound file data into an existing buffer. (Asynchronous)
b_read :: Monad m => Buffer -> FilePath -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Request m ()

-- | Read sound file data into an existing buffer, picking specific
--   channels. (Asynchronous)
b_readChannel :: MonadIO m => Buffer -> FilePath -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> [Int] -> Request m ()

-- | Sound file format.
data SoundFileFormat :: *
Aiff :: SoundFileFormat
Flac :: SoundFileFormat
Ircam :: SoundFileFormat
Next :: SoundFileFormat
Raw :: SoundFileFormat
Wave :: SoundFileFormat

-- | Sample format.
data SampleFormat :: *
PcmInt8 :: SampleFormat
PcmInt16 :: SampleFormat
PcmInt24 :: SampleFormat
PcmInt32 :: SampleFormat
PcmFloat :: SampleFormat
PcmDouble :: SampleFormat
PcmMulaw :: SampleFormat
PcmAlaw :: SampleFormat

-- | Write sound file data. (Asynchronous)
b_write :: MonadIO m => Buffer -> FilePath -> SoundFileFormat -> SampleFormat -> Maybe Int -> Maybe Int -> Bool -> Request m ()

-- | Free buffer. (Asynchronous)
b_free :: MonadIdAllocator m => Buffer -> Request m ()

-- | Zero sample data. (Asynchronous)
b_zero :: MonadIO m => Buffer -> Request m ()

-- | Set sample values.
b_set :: Monad m => Buffer -> [(Int, Double)] -> Request m ()

-- | Set ranges of sample values.
b_setn :: Monad m => Buffer -> [(Int, [Double])] -> Request m ()

-- | Fill ranges of sample values.
b_fill :: Monad m => Buffer -> [(Int, Int, Double)] -> Request m ()

-- | Call a command to fill a buffer. (Asynchronous)
b_gen :: MonadIdAllocator m => Buffer -> String -> [Datum] -> Request m ()

-- | Fill a buffer with partials, specifying amplitudes.
b_gen_sine1 :: MonadIdAllocator m => Buffer -> [B_Gen] -> [Double] -> Request m ()

-- | Fill a buffer with partials, specifying frequencies (in cycles per
--   buffer) and amplitudes.
b_gen_sine2 :: MonadIdAllocator m => Buffer -> [B_Gen] -> [(Double, Double)] -> Request m ()

-- | Fill a buffer with partials, specifying frequencies (in cycles per
--   buffer), amplitudes and phases.
b_gen_sine3 :: MonadIdAllocator m => Buffer -> [B_Gen] -> [(Double, Double, Double)] -> Request m ()

-- | Fills a buffer with a series of chebyshev polynomials.
b_gen_cheby :: MonadIdAllocator m => Buffer -> [B_Gen] -> [Double] -> Request m ()

-- | Copy samples from the source buffer to the destination buffer.
b_gen_copy :: MonadIdAllocator m => Buffer -> Int -> Buffer -> Int -> Maybe Int -> Request m ()

-- | Close attached soundfile and write header information. (Asynchronous)
b_close :: Monad m => Buffer -> Request m ()

-- | Request <tt>BufferInfo</tt>.
b_query :: MonadIO m => Buffer -> Request m (Result BufferInfo)

-- | Request <tt>BufferInfo</tt>.
b_queryM :: (MonadIdAllocator m, RequestOSC m, MonadIO m) => Buffer -> m BufferInfo

-- | Abstract interface for control and audio rate buses.
class Bus a
rate :: Bus a => a -> Rate
numChannels :: Bus a => a -> Int
freeBus :: (Bus a, MonadServer m, MonadIdAllocator m) => a -> m ()

-- | Audio bus.
data AudioBus

-- | Get audio bus id.
audioBusId :: AudioBus -> AudioBusId

-- | Get hardware input bus.
inputBus :: (MonadServer m, Failure AllocFailure m) => Int -> Int -> m AudioBus

-- | Get hardware output bus.
outputBus :: (MonadServer m, Failure AllocFailure m) => Int -> Int -> m AudioBus

-- | Allocate audio bus with the specified number of channels.
newAudioBus :: MonadIdAllocator m => Int -> m AudioBus

-- | Control bus.
data ControlBus

-- | Get control bus ID.
controlBusId :: ControlBus -> ControlBusId

-- | Allocate control bus with the specified number of channels.
newControlBus :: MonadIdAllocator m => Int -> m ControlBus
instance Eq SynthDef
instance Show SynthDef
instance Eq Synth
instance Ord Synth
instance Show Synth
instance Eq Group
instance Ord Group
instance Show Group
instance Eq Buffer
instance Ord Buffer
instance Show Buffer
instance Eq AudioBus
instance Show AudioBus
instance Eq ControlBus
instance Show ControlBus
instance Bus ControlBus
instance Bus AudioBus
instance Node Group
instance Node Synth
instance BusMapping n AudioBus
instance BusMapping n ControlBus
instance Show AbstractNode
instance Node AbstractNode
instance Eq AbstractNode
