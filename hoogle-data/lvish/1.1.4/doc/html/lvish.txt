-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parallel scheduler, LVar data structures, and infrastructure to build more.
--   
@package lvish
@version 1.1.4


-- | This module is <i>not</i> Safe Haskell, but it must be used to create
--   new LVar types.
module Control.LVish.DeepFrz.Internal

-- | DeepFreezing is a type-level (guaranteed <i>O(1)</i> time complexity)
--   operation. It marks an LVar and its contents (recursively) as frozen.
--   DeepFreezing is not an action that can be taken directly by the user,
--   however. Rather, it is the final step in a <tt>runParThenFreeze</tt>
--   invocation.
class DeepFrz a where type family FrzType a :: * frz a = a
frz :: DeepFrz a => a -> FrzType a

-- | This exists only for the purpose of being a type which is <i>not</i>
--   equal to <a>Frzn</a>. One could just as well have used <tt>()</tt>,
--   but this is more descriptive.
data NonFrzn

-- | An uninhabited type that signals that an LVar has been frozen. LVars
--   should use this in place of their <tt>s</tt> parameter.
data Frzn

-- | An uninhabited type that signals that an LVar is not only frozen, but
--   it may be traversed in whatever order its internal representation
--   dictates.
data Trvrsbl


-- | This module is <i>not</i> Safe Haskell; as an end-user, you shouldn't
--   ever need to import it.
--   
--   It is exposed only because it is necessary for implementing <i>new</i>
--   LVar types that will live in their own, separate packages.
module Control.LVish.Internal

-- | The type of parallel computations. A computation <tt>Par d s a</tt>
--   may or may not be deterministic based on the setting of the <tt>d</tt>
--   parameter (of kind <a>Determinism</a>). The <tt>s</tt> parameter is
--   for preventing the escape of <tt>LVar</tt>s from <tt>Par</tt>
--   computations (just like the <tt>ST</tt> monad).
--   
--   Implementation note: This is a wrapper around the internal <a>Par</a>
--   type, only with more type parameters.
newtype Par :: Determinism -> * -> * -> *
WrapPar :: Par a -> Par d s a

-- | The generic representation of LVars used by the scheduler. The
--   end-user can't actually do anything with these and should not try to.
newtype LVar s all delt
WrapLVar :: LVar all delt -> LVar s all delt
unWrapLVar :: LVar s all delt -> LVar all delt

-- | This datatype is promoted to type-level (<tt>DataKinds</tt> extension)
--   and used to indicate whether a <a>Par</a> computation is
--   guaranteed-deterministic, or only quasi-deterministic (i.e., might
--   throw <tt>NonDeterminismExn</tt>).
data Determinism
Det :: Determinism
QuasiDet :: Determinism

-- | A shorthand for quasi-deterministic <a>Par</a> computations.
type QPar = Par QuasiDet

-- | Unsafe: drops type information to go from the safe <a>Par</a> monad to
--   the internal, dangerous one.
unWrapPar :: Par d s a -> Par a

-- | This is cheating! It pays no attention to session sealing (<tt>s</tt>)
--   or to the determinism level (<tt>d</tt>).
unsafeRunPar :: Par d s a -> a

-- | Ignore the extra type annotations regarding both determinism and
--   session-sealing.
unsafeConvert :: Par d1 s1 a -> Par d2 s2 a

-- | Unsafe coercion from quasi-deterministic to deterministic. The user is
--   promising that code is carefully constructed so that put/freeze races
--   will not occur.
unsafeDet :: Par d1 s a -> Par d2 s a

-- | Extract the state of an LVar. This should only be used by
--   implementations of new LVar data structures.
state :: LVar s a d -> a

-- | Unsafe internal operation to lift IO into the Par monad.
liftIO :: IO a -> Par d s a

-- | Debugging flag shared by several modules. This is activated by setting
--   the environment variable <tt>DEBUG=1..5</tt>.
--   
--   By convention <tt>DEBUG=100</tt> turns on full sequentialization of
--   the program and control over the interleavings in concurrent code,
--   enabling systematic debugging of concurrency problems.
dbgLvl :: Int
instance Show Determinism
instance Monad (Par $a $b)
instance Functor (Par $a $b)
instance Applicative (Par $a $b)
instance MonadToss (Par d s)


-- | The <a>DeepFrz</a> module provides a way to return arbitrarily complex
--   data structures containing LVars from <a>Par</a> computations.
--   
--   The important thing to know is that to use <a>runParThenFreeze</a> to
--   run a <a>Par</a> computation, you must make sure that all types you
--   return from the <a>Par</a> computation have <a>DeepFrz</a> instances.
--   This means that, if you wish to return a user-defined type, you will
--   need to include a bit of boilerplate to give it a <a>DeepFrz</a>
--   instance. Here is a complete example:
--   
--   <pre>
--   import Control.LVish.DeepFrz
--   
--   data MyData = MyData Int deriving Show
--   
--   instance DeepFrz MyData where
--     type FrzType MyData = MyData
--   
--   main = print (runParThenFreeze (return (MyData 3)))
--   </pre>
module Control.LVish.DeepFrz

-- | Under normal conditions, calling a <tt>freeze</tt> operation inside a
--   <a>Par</a> computation makes the <a>Par</a> computation
--   quasi-deterministic. However, if we freeze only after all LVar
--   operations are completed (after the implicit global barrier of
--   <a>runPar</a>), then we've avoided all data races, and freezing is
--   therefore safe. Running a <a>Par</a> computation with
--   <a>runParThenFreeze</a> accomplishes this, without our having to call
--   <tt>freeze</tt> explicitly.
--   
--   In order to use <a>runParThenFreeze</a>, the type returned from the
--   <a>Par</a> computation must be a member of the <a>DeepFrz</a> class.
--   All the <tt>Data.LVar.*</tt> libraries should provide instances of
--   <a>DeepFrz</a> already. Further, you can create additional instances
--   for custom, pure datatypes. The result of a <a>runParThenFreeze</a>
--   depends on the type-level function <a>FrzType</a>, whose only purpose
--   is to toggle the <tt>s</tt> parameters of all IVars to the <a>Frzn</a>
--   state.
--   
--   Significantly, the freeze at the end of <a>runParThenFreeze</a> has
--   <i>no</i> runtime cost, in spite of the fact that it enables a
--   <i>deep</i> (recursive) freeze of the value returned by the <a>Par</a>
--   computation.
runParThenFreeze :: DeepFrz a => Par Det NonFrzn a -> FrzType a

-- | This version works for nondeterministic computations as well.
--   
--   Of course, nondeterministic computations may also call <tt>freeze</tt>
--   internally, but this function has an advantage to doing your own
--   <tt>freeze</tt> at the end of a <a>runParIO</a>: there is an implicit
--   barrier before the final freeze. Further, <a>DeepFrz</a> has no
--   runtime overhead, whereas regular freezing has a cost.
runParThenFreezeIO :: DeepFrz a => Par d NonFrzn a -> IO (FrzType a)

-- | DeepFreezing is a type-level (guaranteed <i>O(1)</i> time complexity)
--   operation. It marks an LVar and its contents (recursively) as frozen.
--   DeepFreezing is not an action that can be taken directly by the user,
--   however. Rather, it is the final step in a <tt>runParThenFreeze</tt>
--   invocation.
class DeepFrz a where type family FrzType a :: * frz a = a

-- | This exists only for the purpose of being a type which is <i>not</i>
--   equal to <a>Frzn</a>. One could just as well have used <tt>()</tt>,
--   but this is more descriptive.
data NonFrzn

-- | An uninhabited type that signals that an LVar has been frozen. LVars
--   should use this in place of their <tt>s</tt> parameter.
data Frzn

-- | An uninhabited type that signals that an LVar is not only frozen, but
--   it may be traversed in whatever order its internal representation
--   dictates.
data Trvrsbl
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e, DeepFrz f, DeepFrz g, DeepFrz h, DeepFrz i) => DeepFrz (a, b, c, d, e, f, g, h, i)
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e, DeepFrz f, DeepFrz g, DeepFrz h) => DeepFrz (a, b, c, d, e, f, g, h)
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e, DeepFrz f, DeepFrz g) => DeepFrz (a, b, c, d, e, f, g)
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e, DeepFrz f) => DeepFrz (a, b, c, d, e, f)
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e) => DeepFrz (a, b, c, d, e)
instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d) => DeepFrz (a, b, c, d)
instance (DeepFrz a, DeepFrz b, DeepFrz c) => DeepFrz (a, b, c)
instance (DeepFrz a, DeepFrz b) => DeepFrz (a, b)
instance (DeepFrz a, DeepFrz b) => DeepFrz (Either a b)
instance DeepFrz a => DeepFrz (Maybe a)
instance DeepFrz a => DeepFrz [a]
instance DeepFrz Ordering
instance DeepFrz ()
instance DeepFrz Double
instance DeepFrz Float
instance DeepFrz Integer
instance DeepFrz Char
instance DeepFrz Bool
instance DeepFrz Word64
instance DeepFrz Word32
instance DeepFrz Word16
instance DeepFrz Word8
instance DeepFrz Word
instance DeepFrz Int64
instance DeepFrz Int32
instance DeepFrz Int16
instance DeepFrz Int8
instance DeepFrz Int


-- | For debugging purposes, it can be useful to lift an IO computation
--   into an LVish <tt>Par</tt> monad.
--   
--   This module is imported for instances only (specifically, the
--   <a>MonadIO</a> instance).
module Control.LVish.Unsafe
instance MonadIO (Par d s)


-- | This module contains the unsafe bits that we cannot expose from
--   <a>Data.LVar.Generic</a>.
module Data.LVar.Generic.Internal

-- | A class representing monotonic data structures that take <i>one</i>
--   type parameter, as well as an <tt>s</tt> parameter for session safety.
--   
--   LVars that fall into this class are typically collection types.
--   
--   The superclass constraint on this class serves to ensure that once
--   frozen, the LVar contents are foldable.
class Foldable (f Trvrsbl) => LVarData1 (f :: * -> * -> *) where sortFrzn lv = let lv3 :: f Trvrsbl a lv3 = unsafeCoerceLVar lv ls = foldr (:) [] lv3 ls' = sort ls in AFoldable ls'
addHandler :: LVarData1 f => Maybe HandlerPool -> f s elt -> (elt -> Par d s ()) -> Par d s ()
freeze :: LVarData1 f => f s a -> Par QuasiDet s (f Frzn a)
sortFrzn :: (LVarData1 f, Ord a) => f Frzn a -> AFoldable a

-- | A class enabling generic creation of new LVars.
class LVarWBottom (f :: * -> * -> *) where type family LVContents f a :: Constraint
newBottom :: (LVarWBottom f, LVContents f a) => Par d s (f s a)

-- | Carries a <tt>Foldable</tt> type, but you don't get to know which one.
--   The purpose of this type is that <tt>sortFreeze</tt> should not have
--   to impose a particular memory representation.
data AFoldable a
AFoldable :: (f2 a) -> AFoldable a

-- | A safer version of <a>unsafeCoerce#</a> (that is, with a slightly more
--   constrained type) for LVars only. Note, that the type of the LVar's
--   contents must be allowed to change, because freezing is recursive.
unsafeCoerceLVar :: LVarData1 f => f s1 a -> f s2 b

-- | Here we gain permission to expose the nondeterministic internal
--   structure of an LVar: namely, the order in which its contents occur.
--   We pay the piper with an <a>IO</a> action.
unsafeTraversable :: LVarData1 f => f Frzn a -> IO (f Trvrsbl a)
instance Show a => Show (AFoldable a)


-- | A generic interface providing operations that work on <i>all</i>
--   LVars.
module Data.LVar.Generic

-- | A class representing monotonic data structures that take <i>one</i>
--   type parameter, as well as an <tt>s</tt> parameter for session safety.
--   
--   LVars that fall into this class are typically collection types.
--   
--   The superclass constraint on this class serves to ensure that once
--   frozen, the LVar contents are foldable.
class Foldable (f Trvrsbl) => LVarData1 (f :: * -> * -> *) where sortFrzn lv = let lv3 :: f Trvrsbl a lv3 = unsafeCoerceLVar lv ls = foldr (:) [] lv3 ls' = sort ls in AFoldable ls'
addHandler :: LVarData1 f => Maybe HandlerPool -> f s elt -> (elt -> Par d s ()) -> Par d s ()
freeze :: LVarData1 f => f s a -> Par QuasiDet s (f Frzn a)
sortFrzn :: (LVarData1 f, Ord a) => f Frzn a -> AFoldable a

-- | A class enabling generic creation of new LVars.
class LVarWBottom (f :: * -> * -> *) where type family LVContents f a :: Constraint
newBottom :: (LVarWBottom f, LVContents f a) => Par d s (f s a)

-- | Some LVar datatypes are stored in an <i>internally</i> ordered way so
--   that it is then possible to take <i>O(1)</i> frozen snapshots and
--   consume them inexpensively in a deterministic order.
--   
--   LVars with this additional property provide this class as well as
--   <a>LVarData1</a>.
class LVarData1 f => OrderedLVarData1 (f :: * -> * -> *)
snapFreeze :: OrderedLVarData1 f => f s a -> Par QuasiDet s (f Trvrsbl a)

-- | Carries a <tt>Foldable</tt> type, but you don't get to know which one.
--   The purpose of this type is that <tt>sortFreeze</tt> should not have
--   to impose a particular memory representation.
data AFoldable a
AFoldable :: (f2 a) -> AFoldable a

-- | <a>Trvrsbl</a> is a stronger property than <a>Frzn</a>, so it is
--   always safe to "upcast" to the weaker version.
castFrzn :: LVarData1 f => f Trvrsbl a -> f Frzn a

-- | LVish <a>Par</a> actions must commute, therefore one safe way to
--   consume a frozen (but unordered) LVar, even in another <a>runPar</a>
--   session, is to run a <a>Par</a> computation for each element.
forFrzn :: LVarData1 f => f Frzn a -> (a -> Par d s ()) -> Par d s ()


-- | IVars are the very simplest form of LVars. They are either empty or
--   full, and contain at most a single value.
--   
--   For further information on using IVars in Haskell, see the
--   <tt>monad-par</tt> and <tt>meta-par</tt> packages and papers:
--   
--   <ul>
--   
--   <li><a>http://hackage.haskell.org/package/monad-par</a><ul><li><a>http://www.cs.indiana.edu/~rrnewton/papers/haskell2011_monad-par.pdf</a></li><li><a>http://hackage.haskell.org/package/meta-par</a></li><li><a>http://www.cs.indiana.edu/~rrnewton/papers/2012-ICFP_meta-par.pdf</a></li></ul></li>
--   </ul>
--   
--   Unlike the <tt>IVar</tt> type provided by <tt>monad-par</tt>, the
--   <a>IVar</a> type provided in this module permits repeated <a>put</a>s
--   of the same value, in keeping with the lattice-based semantics of
--   LVars in which a <a>put</a> takes the least upper bound of the old and
--   new values.
module Data.LVar.IVar

-- | An <a>IVar</a> is the simplest form of <a>LVar</a>.
newtype IVar s a
IVar :: (LVar s (IORef (Maybe a)) a) -> IVar s a

-- | A new IVar that starts out empty.
new :: Par d s (IVar s a)

-- | Read the value in a IVar. The <a>get</a> can only return when the
--   value has been written by a prior or concurrent <tt>put</tt> to the
--   same IVar.
get :: IVar s a -> Par d s a

-- | Fill an <a>IVar</a>.
put :: (Eq a, NFData a) => IVar s a -> a -> Par d s ()

-- | Put a value into an IVar. Multiple <a>put</a>s to the same IVar are
--   not allowed, and result in a runtime error, unless the values put
--   happen to be <tt>(==)</tt>.
--   
--   This function is always at least strict up to WHNF in the element put.
put_ :: Eq a => IVar s a -> a -> Par d s ()

-- | A simple future represented as an IVar. The result is fully evaluated
--   before the child computation returns.
spawn :: (Eq a, NFData a) => Par d s a -> Par d s (IVar s a)

-- | A version of <a>spawn</a> that uses only WHNF, rather than full
--   <a>NFData</a>.
spawn_ :: Eq a => Par d s a -> Par d s (IVar s a)
spawnP :: (Eq a, NFData a) => a -> Par d s (IVar s a)

-- | A specialized freezing operation for IVars that leaves the result in a
--   handy format (<a>Maybe</a>).
freezeIVar :: IVar s a -> Par QuasiDet s (Maybe a)

-- | Unpack a frozen IVar (as produced by a generic <a>freeze</a>
--   operation) as a more palatable data structure.
fromIVar :: IVar Frzn a -> Maybe a

-- | Register a handler that fires when the IVar is filled, which, of
--   course, only happens once.
whenFull :: Maybe HandlerPool -> IVar s a -> (a -> Par d s ()) -> Par d s ()
instance Show a => Show (IVar Trvrsbl a)
instance Show a => Show (IVar Frzn a)
instance Foldable (IVar Trvrsbl)
instance DeepFrz a => DeepFrz (IVar s a)
instance LVarWBottom IVar
instance LVarData1 IVar
instance Eq (IVar s a)


-- | The <tt>lvish</tt> package provides a parallel programming model based
--   on monotonically growing data structures.
--   
--   This module provides the core scheduler and basic control flow
--   operations. But to do anything useful you will need to import, along
--   with this module, one of the data structure modules
--   (<tt>Data.LVar.*</tt>).
--   
--   Here is a self-contained example. This program writes the same value
--   to an <tt>LVar</tt> called <tt>num</tt> twice. It deterministically
--   prints <tt>4</tt> instead of raising an error, as it would if
--   <tt>num</tt> were a traditional IVar rather than an LVar. (You will
--   need to compile using the <tt>-XDataKinds</tt> extension.)
--   
--   <pre>
--   import Control.LVish  -- Generic scheduler; works with any lattice.
--   import Data.LVar.IVar -- The particular lattice in question.
--   
--   p :: Par Det s Int
--   p = do
--     num &lt;- new
--     fork $ put num 4
--     fork $ put num 4
--     get num
--   
--   main = do
--     print $ runPar $ p
--   </pre>
module Control.LVish

-- | The type of parallel computations. A computation <tt>Par d s a</tt>
--   may or may not be deterministic based on the setting of the <tt>d</tt>
--   parameter (of kind <a>Determinism</a>). The <tt>s</tt> parameter is
--   for preventing the escape of <tt>LVar</tt>s from <tt>Par</tt>
--   computations (just like the <tt>ST</tt> monad).
--   
--   Implementation note: This is a wrapper around the internal <a>Par</a>
--   type, only with more type parameters.
data Par :: Determinism -> * -> * -> *

-- | This datatype is promoted to type-level (<tt>DataKinds</tt> extension)
--   and used to indicate whether a <a>Par</a> computation is
--   guaranteed-deterministic, or only quasi-deterministic (i.e., might
--   throw <tt>NonDeterminismExn</tt>).
data Determinism
Det :: Determinism
QuasiDet :: Determinism

-- | It is always safe to lift a deterministic computation to a
--   quasi-deterministic one.
liftQD :: Par Det s a -> Par QuasiDet s a

-- | All <tt>LVar</tt>s share a common notion of exceptions. The two common
--   forms of exception currently are conflicting-put and put-after-freeze.
--   There are also errors that correspond to particular invariants for
--   particular LVars.
data LVishException
ConflictingPutExn :: String -> LVishException
PutAfterFreezeExn :: String -> LVishException
LVarSpecificExn :: String -> LVishException

-- | Execute a computation in parallel.
fork :: Par d s () -> Par d s ()

-- | Cooperatively schedule other threads.
yield :: Par d s ()

-- | If a computation is guaranteed-deterministic, then <a>Par</a> becomes
--   a dischargeable effect. This function will create new worker threads
--   and do the work in parallel, returning the final result.
--   
--   (For now there is no sharing of workers with repeated invocations; so
--   keep in mind that <tt>runPar</tt> is an expensive operation.
--   [2013.09.27])
runPar :: (forall s. Par Det s a) -> a

-- | If the input computation is quasi-deterministic (<a>QuasiDet</a>),
--   then this may throw a <a>LVishException</a> nondeterministically on
--   the thread that calls it, but if it returns without exception then it
--   always returns the same answer.
--   
--   If the input computation is deterministic (<a>Det</a>), then
--   <tt>runParIO</tt> will return the same result as <a>runPar</a>.
--   However, <a>runParIO</a> is still possibly useful for avoiding an
--   extra <a>unsafePerformIO</a> required inside the implementation of
--   <a>runPar</a>.
--   
--   In the future, <i>full</i> nondeterminism may be allowed as a third
--   setting beyond <a>Det</a> and <a>QuasiDet</a>.
runParIO :: (forall s. Par d s a) -> IO a

-- | Left-biased parallel for loop. As worker threads beyond the first are
--   added, this hews closer to the sequential iteration order than an
--   unbiased parallel loop.
--   
--   Takes a range as inclusive-start, exclusive-end.

-- | <i>Deprecated: These will be removed in a future release in favor of a
--   more general approach to loops.</i>
parForL :: (Int, Int) -> (Int -> Par d s ()) -> Par d s ()

-- | The least-sophisticated form of parallel loop. Fork iterations one at
--   a time.

-- | <i>Deprecated: These will be removed in a future release in favor of a
--   more general approach to loops.</i>
parForSimple :: (Int, Int) -> (Int -> Par d s ()) -> Par d s ()

-- | Divide the iteration space recursively, but ultimately run every
--   iteration in parallel. That is, the loop body is permitted to block on
--   other iterations.

-- | <i>Deprecated: These will be removed in a future release in favor of a
--   more general approach to loops.</i>
parForTree :: (Int, Int) -> (Int -> Par d s ()) -> Par d s ()

-- | Split the work into a number of tiles, and fork it in a tree topology.

-- | <i>Deprecated: These will be removed in a future release in favor of a
--   more general approach to loops.</i>
parForTiled :: Maybe HandlerPool -> Int -> (Int, Int) -> (Int -> Par d s ()) -> Par d s ()

-- | A simple for loop for numeric ranges (not requiring deforestation
--   optimizations like <tt>forM</tt>). Inclusive start, exclusive end.
for_ :: Monad m => (Int, Int) -> (Int -> m ()) -> m ()

-- | A parallel <tt>And</tt> operation that can return early---whenever a
--   False appears on either branch.
asyncAnd :: Maybe HandlerPool -> (Par d s Bool) -> (Par d s Bool) -> (Bool -> Par d s ()) -> Par d s ()

-- | Analagous operation for <tt>Or</tt>.
asyncOr :: Maybe HandlerPool -> (Par d s Bool) -> (Par d s Bool) -> (Bool -> Par d s ()) -> Par d s ()
andMap :: Maybe HandlerPool -> (a -> Par d s Bool) -> [a] -> Par d s Bool
orMap :: Maybe HandlerPool -> (a -> Par d s Bool) -> [a] -> Par d s Bool

-- | A <tt>HandlerPool</tt> contains a way to count outstanding parallel
--   computations that are affiliated with the pool. It detects the
--   condition where all such threads have completed.
data HandlerPool

-- | Create a new pool that can be used to synchronize on the completion of
--   all parallel computations associated with the pool.
newPool :: Par d s HandlerPool

-- | Execute a Par computation in the context of a fresh handler pool.
withNewPool :: (HandlerPool -> Par d s a) -> Par d s (a, HandlerPool)

-- | Execute a Par computation in the context of a fresh handler pool,
--   while ignoring the result of the computation.
withNewPool_ :: (HandlerPool -> Par d s ()) -> Par d s HandlerPool

-- | Block until a handler pool is quiescent, i.e., until all associated
--   parallel computations have completed.
quiesce :: HandlerPool -> Par d s ()

-- | A version of <a>fork</a> that also allows the forked computation to be
--   tracked in a <tt>HandlerPool</tt>, that enables the programmer to
--   synchronize on the completion of the child computation. But be
--   careful; this does not automatically wait for all downstream forked
--   computations (transitively).
forkHP :: Maybe HandlerPool -> Par d s () -> Par d s ()

-- | Log a line of debugging output. This is only used when *compiled* in
--   debugging mode. It atomically adds a string onto an in-memory log.
--   
--   The provided <a>Int</a>, is the "debug level" associated with the
--   message, 1-5. One is the least verbose, and five is the most. When
--   debugging, the user can control the debug level by setting the env var
--   DEBUG, e.g. <tt>DEBUG=5</tt>.
logDbgLn :: Int -> String -> Par d s ()

-- | Useful for debugging. Returns debugging logs, in realtime order, in
--   addition to the final result.
runParLogged :: (forall s. Par d s a) -> IO ([String], a)

-- | A variant with full control over the relevant knobs.
--   
--   Returns a list of flushed debug messages at the end (if in-memory
--   logging was enabled, otherwise the list is empty).
--   
--   This version of runPar catches ALL exceptions that occur within the
--   runPar, and returns them via an Either. The reason for this is that
--   even if an error occurs, it is still useful to observe the log
--   messages that lead to the failure.
runParDetailed :: DbgCfg -> Int -> (forall s. Par d s a) -> IO ([String], Either SomeException a)

-- | A destination for log messages
data OutDest

-- | Output via GHC's <tt>traceEvent</tt> runtime events.
OutputEvents :: OutDest

-- | Printed human-readable output to a handle.
OutputTo :: Handle -> OutDest

-- | Accumulate output in memory and flush when appropriate.
OutputInMemory :: OutDest
data DbgCfg
DbgCfg :: Maybe (Int, Int) -> [OutDest] -> Bool -> DbgCfg

-- | Inclusive range of debug messages to accept (i.e. filter on priority
--   level). If Nothing, use the default level, which is (0,N) where N is
--   controlled by the DEBUG environment variable. The convention is to use
--   Just (0,0) to disable logging.
dbgRange :: DbgCfg -> Maybe (Int, Int)

-- | Destinations for debug log messages.
dbgDests :: DbgCfg -> [OutDest]

-- | In additional to logging debug messages, control thread interleaving
--   at these points when this is True.
dbgScheduling :: DbgCfg -> Bool

-- | The generic representation of LVars used by the scheduler. The
--   end-user can't actually do anything with these and should not try to.
data LVar s all delt


-- | An I-Structure, also known as an array of IVars, implemented using a
--   boxed vector.
module Data.LVar.IStructure

-- | An I-Structure, also known as an array of IVars.
data IStructure s a

-- | Create a new, empty, monotonically growing <a>IStructure</a> of a
--   given size. All entries start off as zero, which must be "bottom".
newIStructure :: Int -> Par d s (IStructure s elt)

-- | Register handlers on each internal IVar as it is created. This
--   operation should be more efficient than <a>newIStructure</a> followed
--   by <a>forEachHP</a>.
newIStructureWithCallback :: Int -> (Int -> elt -> Par d s ()) -> Par d s (IStructure s elt)

-- | Put a single element in the <a>IStructure</a> at a given index. This
--   variant is deeply strict (<a>NFData</a>).
put :: (NFData elt, Eq elt) => IStructure s elt -> Int -> elt -> Par d s ()

-- | Put a single element in the <a>IStructure</a> at a given index. That
--   index must be previously empty. (WHNF) Strict in the element being put
--   in the set.
put_ :: Eq elt => IStructure s elt -> Int -> elt -> Par d s ()

-- | Wait for the indexed entry to contain a value, and return that value.
get :: Eq elt => IStructure s elt -> Int -> Par d s elt

-- | Retrieve the number of slots in the <a>IStructure</a>.
getLength :: IStructure s a -> Par d s Int

-- | Add an (asynchronous) callback that listens for all new elements added
--   to the <a>IStructure</a>, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> IStructure s a -> (Int -> a -> Par d s ()) -> Par d s ()

-- | <i>O(N)</i> complexity, unfortunately. This implementation of
--   <a>IStructure</a>s requires freezing each of the individual IVars
--   stored in the array.
freezeIStructure :: IStructure s a -> Par QuasiDet s (Vector (Maybe a))
instance Show a => Show (IStructure Trvrsbl a)
instance Show a => Show (IStructure Frzn a)
instance DeepFrz a => DeepFrz (IStructure s a)
instance Foldable (IStructure Trvrsbl)
instance Foldable (IStructure Frzn)
instance OrderedLVarData1 IStructure
instance LVarData1 IStructure
instance Eq (IStructure s v)


-- | This module provides sets that only grow. It is based on the popular
--   <a>Data.Set</a> balanced-tree representation of sets. Thus scalability
--   is <i>not</i> good for this implementation. However, there are some
--   interoperability benefits. For exmaple, after running a parallel
--   computation with a set result, this module can produce a <tt>Set</tt>
--   in <i>O(1)</i> without copying, which may be useful downstream.
module Data.LVar.PureSet

-- | The set datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (like an <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: There is only <i>one</i> mutable location in this
--   implementation. Thus it is not a scalable implementation.
newtype ISet s a
ISet :: (LVar s (IORef (Set a)) a) -> ISet s a

-- | Create a new, empty, monotonically growing set.
newEmptySet :: Par d s (ISet s a)

-- | Create a new set populated with initial elements.
newSet :: Set a -> Par d s (ISet s a)

-- | Create a new set drawing initial elements from an existing list.
newFromList :: Ord a => [a] -> Par d s (ISet s a)

-- | Put a single element in the set. (WHNF) Strict in the element being
--   put in the set.
insert :: Ord a => a -> ISet s a -> Par d s ()

-- | Wait for the set to contain a specified element.
waitElem :: Ord a => a -> ISet s a -> Par d s ()

-- | Wait on the <i>size</i> of the set, not its contents.
waitSize :: Int -> ISet s a -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new elements added
--   to the set.
forEach :: ISet s a -> (a -> Par d s ()) -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new elements added
--   to the set, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> ISet s a -> (a -> Par d s ()) -> Par d s ()

-- | Freeze an <a>ISet</a> after a specified callback/handler is done
--   running. This differs from <a>withCallbacksThenFreeze</a> by not
--   taking an additional action to run in the context of the handlers.
--   
--   (<tt><a>freezeSetAfter</a> <tt>s</tt> <tt>f</tt> ==
--   <a>withCallbacksThenFreeze</a> <tt>s</tt> <tt>f</tt> 'return ()'
--   </tt>)
freezeSetAfter :: ISet s a -> (a -> QPar s ()) -> QPar s ()

-- | Register a per-element callback, then run an action in this context,
--   and freeze when all (recursive) invocations of the callback are
--   complete. Returns the final value of the provided action.
withCallbacksThenFreeze :: Eq b => ISet s a -> (a -> QPar s ()) -> QPar s b -> QPar s b

-- | Get the exact contents of the set. As with any quasi-deterministic
--   operation, using <a>freezeSet</a> may cause your program to exhibit a
--   limited form of nondeterminism: it will never return the wrong answer,
--   but it may include synchronization bugs that can
--   (nondeterministically) cause exceptions.
--   
--   This <a>Data.Set</a>-based implementation has the special property
--   that you can retrieve the full set without any <a>IO</a>, and without
--   nondeterminism leaking. (This is because the internal order is fixed
--   for the tree-based representation of sets that <a>Data.Set</a> uses.)
freezeSet :: ISet s a -> QPar s (Set a)

-- | <i>O(1)</i>: Convert from an <a>ISet</a> to a plain <a>Set</a>. This
--   is only permitted when the <a>ISet</a> has already been frozen. This
--   is useful for processing the result of <a>runParThenFreeze</a>.
fromISet :: ISet Frzn a -> Set a

-- | Return a fresh set which will contain strictly more elements than the
--   input set. That is, things put in the former go in the latter, but not
--   vice versa.
copy :: Ord a => ISet s a -> Par d s (ISet s a)

-- | Establish a monotonic map between the input and output sets.
traverseSet :: Ord b => (a -> Par d s b) -> ISet s a -> Par d s (ISet s b)

-- | An imperative-style, in-place version of <a>traverseSet</a> that takes
--   the output set as an argument.
traverseSet_ :: Ord b => (a -> Par d s b) -> ISet s a -> ISet s b -> Par d s ()

-- | Return a new set which will (ultimately) contain everything in either
--   input set.
union :: Ord a => ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Build a new set which will contain the intersection of the two input
--   sets.
intersection :: Ord a => ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Take the cartesian product of two sets.
cartesianProd :: (Ord a, Ord b) => ISet s a -> ISet s b -> Par d s (ISet s (a, b))

-- | Take the cartesian product of several sets.
cartesianProds :: Ord a => [ISet s a] -> Par d s (ISet s [a])

-- | Variant of <a>traverseSet</a> that optionally ties the handlers to a
--   pool.
traverseSetHP :: Ord b => Maybe HandlerPool -> (a -> Par d s b) -> ISet s a -> Par d s (ISet s b)

-- | Variant of <a>traverseSet_</a> that optionally ties the handlers to a
--   pool.
traverseSetHP_ :: Ord b => Maybe HandlerPool -> (a -> Par d s b) -> ISet s a -> ISet s b -> Par d s ()

-- | Variant of <a>union</a> that optionally ties the handlers in the
--   resulting set to the same handler pool as those in the two input sets.
unionHP :: Ord a => Maybe HandlerPool -> ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Variant of <a>intersection</a> that optionally ties the handlers in
--   the resulting set to the same handler pool as those in the two input
--   sets.
intersectionHP :: Ord a => Maybe HandlerPool -> ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Variant of <a>cartesianProd</a> that optionally ties the handlers to a
--   pool.
cartesianProdHP :: (Ord a, Ord b) => Maybe HandlerPool -> ISet s a -> ISet s b -> Par d s (ISet s (a, b))

-- | Variant of <a>cartesianProds</a> that optionally ties the handlers to
--   a pool.
cartesianProdsHP :: Ord a => Maybe HandlerPool -> [ISet s a] -> Par d s (ISet s [a])
instance Show a => Show (ISet Trvrsbl a)
instance Show a => Show (ISet Frzn a)
instance DeepFrz a => DeepFrz (ISet s a)
instance Foldable (ISet Trvrsbl)
instance Foldable (ISet Frzn)
instance OrderedLVarData1 ISet
instance LVarData1 ISet
instance Eq (ISet s v)

module Data.LVar.PureMap.Unsafe

-- | An unsafe, nonblocking version of <tt>getKey</tt>. This reveals
--   whether
unsafePeekKey :: Ord k => k -> IMap k s v -> Par d s (Maybe v)

-- | The map datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (think <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: There is only <i>one</i> mutable location in this
--   implementation. Thus it is not a scalable implementation.
newtype IMap k s v
IMap :: (LVar s (IORef (Map k v)) (k, v)) -> IMap k s v

-- | Add an (asynchronous) callback that listens for all new key/value
--   pairs added to the map, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> IMap k s v -> (k -> v -> Par d s ()) -> Par d s ()
instance (Show k, Show a) => Show (IMap k Trvrsbl a)
instance (Show k, Show a) => Show (IMap k Frzn a)
instance DeepFrz a => DeepFrz (IMap k s a)
instance Foldable (IMap k Trvrsbl)
instance Foldable (IMap k Frzn)
instance OrderedLVarData1 (IMap k)
instance LVarData1 (IMap k)
instance Eq (IMap k s v)


-- | This module provides finite maps that only grow. It is based on the
--   popular <a>Data.Map</a> balanced-tree representation of maps. Thus
--   scalability is <i>not</i> good for this implementation. However, there
--   are some interoperability benefits. For example, after running a
--   parallel computation with a map result, this module can produce a
--   <tt>Map</tt> in <i>O(1)</i> without copying, which may be useful
--   downstream.
module Data.LVar.PureMap

-- | The map datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (think <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: There is only <i>one</i> mutable location in this
--   implementation. Thus it is not a scalable implementation.
newtype IMap k s v
IMap :: (LVar s (IORef (Map k v)) (k, v)) -> IMap k s v

-- | Create a fresh map with nothing in it.
newEmptyMap :: Par d s (IMap k s v)

-- | Create a new map populated with initial elements.
newMap :: Map k v -> Par d s (IMap k s v)

-- | A convenience function that is equivalent to calling <a>fromList</a>
--   followed by <a>newMap</a>.
newFromList :: (Ord k, Eq v) => [(k, v)] -> Par d s (IMap k s v)

-- | Put a single entry into the map. Strict (WHNF) in the key and value.
--   
--   As with other container LVars, if a key is inserted multiple times,
--   the values had better be equal <tt>(==)</tt>, or a multiple-put error
--   is raised.
insert :: (Ord k, Eq v) => k -> v -> IMap k s v -> Par d s ()

-- | Wait for the map to contain a specified key, and return the associated
--   value.
getKey :: Ord k => k -> IMap k s v -> Par d s v

-- | Wait until the map contains a certain value (on any key).
waitValue :: (Ord k, Eq v) => v -> IMap k s v -> Par d s ()

-- | Wait on the <i>size</i> of the map, not its contents.
waitSize :: Int -> IMap k s v -> Par d s ()

-- | <a>IMap</a>s containing other LVars have some additional capabilities
--   compared to those containing regular Haskell data. In particular, it
--   is possible to modify existing entries (monotonically). Further, this
--   <a>modify</a> function implicitly inserts a "bottom" element if there
--   is no existing entry for the key.
--   
--   Unfortunately, that means that this takes another computation for
--   creating new "bottom" elements for the nested LVars stored inside the
--   <a>IMap</a>.
modify :: (Ord key, Show key, Ord a) => IMap key s (f s a) -> key -> (Par d s (f s a)) -> (f s a -> Par d s b) -> Par d s b

-- | A generic version of <a>modify</a> that does not require a
--   <a>newBottom</a> argument, rather, it uses the generic version of that
--   function.
gmodify :: (Ord key, LVarWBottom f, LVContents f a, Show key, Ord a) => IMap key s (f s a) -> key -> (f s a -> Par d s b) -> Par d s b

-- | Return the preexisting value for a key if it exists, and otherwise
--   return
--   
--   This is a convenience routine that can easily be defined in terms of
--   <a>gmodify</a>
getOrInit :: (Ord key, LVarData1 f, LVarWBottom f, LVContents f a, Show key, Ord a) => key -> IMap key s (f s a) -> Par d s (f s a)

-- | Add an (asynchronous) callback that listens for all new new key/value
--   pairs added to the map.
forEach :: IMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new key/value
--   pairs added to the map, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> IMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Register a per-element callback, then run an action in this context,
--   and freeze when all (recursive) invocations of the callback are
--   complete. Returns the final value of the provided action.
withCallbacksThenFreeze :: Eq b => IMap k s v -> (k -> v -> QPar s ()) -> QPar s b -> QPar s b

-- | Get the exact contents of the map. As with any quasi-deterministic
--   operation, using <a>freezeMap</a> may cause your program to exhibit a
--   limited form of nondeterminism: it will never return the wrong answer,
--   but it may include synchronization bugs that can
--   (nondeterministically) cause exceptions.
--   
--   This <a>Data.Map</a>-based implementation has the special property
--   that you can retrieve the full map without any <a>IO</a>, and without
--   nondeterminism leaking. (This is because the internal order is fixed
--   for the tree-based representation of maps that <a>Data.Map</a> uses.)
freezeMap :: IMap k s v -> QPar s (Map k v)

-- | <i>O(1)</i>: Convert from an <a>IMap</a> to a plain <a>Map</a>. This
--   is only permitted when the <a>IMap</a> has already been frozen. This
--   is useful for processing the result of <a>runParThenFreeze</a>.
fromIMap :: IMap k Frzn a -> Map k a

-- | Traverse a frozen map for side effect. This is useful (in comparison
--   with more generic operations) because the function passed in may see
--   the key as well as the value.
traverseFrzn_ :: Ord k => (k -> a -> Par d s ()) -> IMap k Frzn a -> Par d s ()

-- | Return a fresh map which will contain strictly more elements than the
--   input. That is, things put in the former go in the latter, but not
--   vice versa.
copy :: (Ord k, Eq v) => IMap k s v -> Par d s (IMap k s v)

-- | Establish a monotonic map between the input and output sets. Produce a
--   new result based on each element, while leaving the keys the same.
traverseMap :: (Ord k, Eq b) => (k -> a -> Par d s b) -> IMap k s a -> Par d s (IMap k s b)

-- | An imperative-style, in-place version of <a>traverseMap</a> that takes
--   the output set as an argument.
traverseMap_ :: (Ord k, Eq b) => (k -> a -> Par d s b) -> IMap k s a -> IMap k s b -> Par d s ()

-- | Return a new map which will (ultimately) contain everything in either
--   input map. Conflicting entries will result in a multiple put
--   exception.
union :: (Ord k, Eq a) => IMap k s a -> IMap k s a -> Par d s (IMap k s a)

-- | A variant of <a>traverseMap</a> that optionally ties the handlers to a
--   pool.
traverseMapHP :: (Ord k, Eq b) => Maybe HandlerPool -> (k -> a -> Par d s b) -> IMap k s a -> Par d s (IMap k s b)

-- | A variant of <a>traverseMap_</a> that optionally ties the handlers to
--   a pool.
traverseMapHP_ :: (Ord k, Eq b) => Maybe HandlerPool -> (k -> a -> Par d s b) -> IMap k s a -> IMap k s b -> Par d s ()

-- | A variant of <a>union</a> that optionally ties the handlers in the
--   resulting set to the same handler pool as those in the two input sets.
unionHP :: (Ord k, Eq a) => Maybe HandlerPool -> IMap k s a -> IMap k s a -> Par d s (IMap k s a)


-- | Saturating maps. These store pure (joinable) values, but when a join
--   fails the map fails (saturates), after which it requires only a small,
--   constant amount of memory.
module Data.LVar.SatMap

-- | A partial version of <a>Algebra.Lattice.JoinSemiLattice</a>, this
--   could be made into a complete lattice by the addition of a top
--   element.
class PartialJoinSemiLattice a
joinMaybe :: PartialJoinSemiLattice a => a -> a -> Maybe a

-- | The map datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (think <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: There is only <i>one</i> mutable location in this
--   implementation. Thus it is not a scalable implementation.
newtype SatMap k s v
SatMap :: (LVar s (IORef (SatMapContents k v)) (k, v)) -> SatMap k s v
type SatMapContents k v = Maybe (Map k v, OnSat)

-- | Callback to execute when saturating occurs.
type OnSat = Par ()

-- | Equality is physical equality, as with <tt>IORef</tt>s.

-- | An <a>SatMap</a> can be treated as a generic container LVar. However,
--   the polymorphic operations are less useful than the monomorphic ones
--   exposed by this module.

-- | The <a>SatMap</a>s in this module also have the special property that
--   they support an <i>O(1)</i> freeze operation which immediately yields
--   a <tt>Foldable</tt> container (<a>snapFreeze</a>).

-- | As with all LVars, after freezing, map elements can be consumed. In
--   the case of this <a>SatMap</a> implementation, it need only be
--   <a>Frzn</a>, not <a>Trvrsbl</a>.

-- | For convenience only; the user could define this.

-- | Add an (asynchronous) callback that listens for all new key/value
--   pairs added to the map, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> SatMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Create a fresh map with nothing in it.
newEmptyMap :: Par d s (SatMap k s v)

-- | Create a new map populated with initial elements.
newMap :: Map k v -> Par d s (SatMap k s v)

-- | A convenience function that is equivalent to calling <a>fromList</a>
--   followed by <a>newMap</a>.
newFromList :: (Ord k, Eq v) => [(k, v)] -> Par d s (SatMap k s v)

-- | Register a per-element callback, then run an action in this context,
--   and freeze when all (recursive) invocations of the callback are
--   complete. Returns the final value of the provided action.
withCallbacksThenFreeze :: Eq b => SatMap k s v -> (k -> v -> QPar s ()) -> QPar s b -> QPar s b

-- | Add an (asynchronous) callback that listens for all new new key/value
--   pairs added to the map.
forEach :: SatMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Put a single entry into the map. Strict (WHNF) in the key and value.
--   
--   As with other container LVars, if a key is inserted multiple times,
--   the values had better be equal <tt>(==)</tt>, or a multiple-put error
--   is raised.
insert :: (Ord k, PartialJoinSemiLattice v, Eq v) => k -> v -> SatMap k s v -> Par d s ()

-- | Register a callback that is only called if the SatMap LVar becomes
--   <i>saturated</i>.
whenSat :: SatMap k s v -> Par d s () -> Par d s ()

-- | Drive the variable to top. This is equivalent to an insert of a
--   conflicting binding.
saturate :: SatMap k s v -> Par d s ()

-- | <i>O(1)</i>: Convert from an <a>SatMap</a> to a plain <a>Map</a>. This
--   is only permitted when the <a>SatMap</a> has already been frozen. This
--   is useful for processing the result of <a>runParThenFreeze</a>.
fromIMap :: SatMap k Frzn a -> Maybe (Map k a)
t0 :: SatMap String Frzn Int
t1 :: SatMap String Frzn Int
instance PartialJoinSemiLattice Int
instance (Show k, Show a) => Show (SatMap k Trvrsbl a)
instance (Show k, Show a) => Show (SatMap k Frzn a)
instance DeepFrz a => DeepFrz (SatMap k s a)
instance Foldable (SatMap k Trvrsbl)
instance Foldable (SatMap k Frzn)
instance OrderedLVarData1 (SatMap k)
instance LVarData1 (SatMap k)
instance Eq (SatMap k s v)


-- | An implementation of concurrent finite maps based on skip lists. Only
--   supports lookup and insertions, not modifications or removals.
--   
--   Skip lists are a probabilistic data structure that roughly approximate
--   balanced trees. At the bottom layer is a standard linked list
--   representation of a finite map. Above this is some number of "index"
--   lists that provide shortcuts to the layer below them. When a key/value
--   pair is added, it is always added to the bottom layer, and is added
--   with exponentially decreasing probability to each index layer above
--   it.
--   
--   Skip lists are a very good match for lock-free programming, since the
--   linearization point can be taken as insertion into the bottom list,
--   and index nodes can be added *afterward* in a best-effort style (i.e.,
--   if there is contention to add them, we can simply walk away, with the
--   effect that the probability of appearing in an index is partly a
--   function of contention.)
--   
--   To implement skip lists in Haskell, we use a GADT to represent the
--   layers, each of which has a different type (since it indexes the layer
--   below it).
module Data.Concurrent.SkipListMap
data SLMap k v

-- | Create a new skip list with the given number of levels.
newSLMap :: Int -> IO (SLMap k v)

-- | Attempt to locate a key in the map.
find :: Ord k => SLMap k v -> k -> IO (Maybe v)
data PutResult v
Added :: v -> PutResult v
Found :: v -> PutResult v

-- | Adds a key/value pair if the key is not present, all within a given
--   monad. Returns the value now associated with the key in the map.
putIfAbsent :: (Ord k, MonadIO m, MonadToss m) => SLMap k v -> k -> m v -> m (PutResult v)

-- | Adds a key/value pair if the key is not present, all within a given
--   monad. Returns the value now associated with the key in the map.
putIfAbsentToss :: (Ord k, MonadIO m) => SLMap k v -> k -> m v -> m Bool -> m (PutResult v)

-- | Concurrently fold over all key/value pairs in the map within the given
--   monad, in increasing key order. Inserts that arrive concurrently may
--   or may not be included in the fold.
--   
--   Strict in the accumulator.
foldlWithKey :: Monad m => (forall x. IO x -> m x) -> (a -> k -> v -> m a) -> a -> SLMap k v -> m a

-- | Returns the sizes of the skiplist levels; for performance debugging.
counts :: SLMap k v -> IO [Int]

-- | Print a slice with each layer on a line.
debugShow :: (Ord k, Show k, Show v) => SLMapSlice k v -> IO String

-- | A portion of an SLMap between two keys. If the upper-bound is missing,
--   that means "go to the end". The optional lower bound is used to
--   "lazily" prune the fronts each layer. The reason for this is that we
--   don't want to reallocate an IORef spine and prematurely prune all
--   lower layers IF we're simply going to split again before actually
--   enumerating the contents.
data SLMapSlice k v
Slice :: (SLMap k v) -> !(Maybe k) -> !(Maybe k) -> SLMapSlice k v

-- | Create a slice corresponding to the entire (non-empty) map.
toSlice :: SLMap k v -> SLMapSlice k v

-- | Attempt to split a slice of an SLMap. If there are not enough elements
--   to form two slices, this retruns Nothing.
splitSlice :: (Show k, Ord k) => SLMapSlice k v -> IO (Maybe (SLMapSlice k v, SLMapSlice k v))

-- | <i>O(N)</i> measure the length of the bottom tier.
sliceSize :: Ord k => SLMapSlice k v -> IO Int
instance Show (LMList k v)
instance Show (LMap k v)
instance Eq (SLMap k v)


-- | This module provides sets that only grow. It is based on a
--   <i>concurrent skip list</i> representation of sets.
--   
--   This module is usually a more efficient alternative to
--   <a>Data.LVar.PureSet</a>, and provides almost the same interface.
--   However, it's always good to test multiple data structures if you have
--   a performance-critical use case.
module Data.LVar.SLSet

-- | The set datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (think <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: this data structure reduces contention between
--   parallel computations inserting into the map, but all <i>blocking</i>
--   computations are not as scalable. All continuations waiting for
--   not-yet-present elements will currently share a single queue
--   [2013.09.26].
data ISet s a

-- | Create a new, empty, monotonically growing set.
newEmptySet :: Ord a => Par d s (ISet s a)

-- | Create a new <a>ISet</a> populated with initial elements.
newSet :: Ord a => Set a -> Par d s (ISet s a)

-- | A simple convenience function. Create a new <a>ISet</a> drawing
--   initial elements from an existing list.
newFromList :: Ord a => [a] -> Par d s (ISet s a)

-- | Put a single element in the set. (WHNF) Strict in the element being
--   put in the set.
insert :: Ord a => a -> ISet s a -> Par d s ()

-- | Wait for the set to contain a specified element.
waitElem :: Ord a => a -> ISet s a -> Par d s ()

-- | Wait on the <i>size</i> of the set, not its contents.
waitSize :: Int -> ISet s a -> Par d s ()

-- | Test whether an element is in a frozen image of a set.
member :: a -> ISet Frzn a -> Bool

-- | Add an (asynchronous) callback that listens for all new elements added
--   to the set.
forEach :: ISet s a -> (a -> Par d s ()) -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new elements added
--   to the set, optionally enrolled in a handler pool.
forEachHP :: Maybe HandlerPool -> ISet s a -> (a -> Par d s ()) -> Par d s ()

-- | Freeze an <a>ISet</a> after a specified callback/handler is done
--   running. This differs from <a>withCallbacksThenFreeze</a> by not
--   taking an additional action to run in the context of the handlers.
--   
--   (<tt><a>freezeSetAfter</a> <tt>s</tt> <tt>f</tt> ==
--   <a>withCallbacksThenFreeze</a> <tt>s</tt> <tt>f</tt> 'return ()'
--   </tt>)
freezeSetAfter :: ISet s a -> (a -> QPar s ()) -> QPar s ()

-- | Register a per-element callback, then run an action in this context,
--   and freeze when all (recursive) invocations of the callback are
--   complete. Returns the final value of the provided action.
withCallbacksThenFreeze :: Eq b => ISet s a -> (a -> QPar s ()) -> QPar s b -> QPar s b

-- | Return a fresh set which will contain strictly more elements than the
--   input set. That is, things put in the former go in the latter, but not
--   vice versa.
copy :: Ord a => ISet s a -> Par d s (ISet s a)

-- | Establish a monotonic map between the input and output sets.
traverseSet :: Ord b => (a -> Par d s b) -> ISet s a -> Par d s (ISet s b)

-- | An imperative-style, in-place version of <a>traverseSet</a> that takes
--   the output set as an argument.
traverseSet_ :: Ord b => (a -> Par d s b) -> ISet s a -> ISet s b -> Par d s ()

-- | Return a new set which will (ultimately) contain everything in either
--   input set.
union :: Ord a => ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Build a new set which will contain the intersection of the two input
--   sets.
intersection :: Ord a => ISet s a -> ISet s a -> Par d s (ISet s a)

-- | Take the cartesian product of two sets.
cartesianProd :: (Ord a, Ord b) => ISet s a -> ISet s b -> Par d s (ISet s (a, b))

-- | Take the cartesian product of several sets.
cartesianProds :: Ord a => [ISet s a] -> Par d s (ISet s [a])

-- | Variant of <a>traverseSet</a> that optionally ties the handlers to a
--   pool.
traverseSetHP :: Ord b => Maybe HandlerPool -> (a -> Par d s b) -> ISet s a -> Par d s (ISet s b)

-- | Variant of <a>traverseSet_</a> that optionally ties the handlers to a
--   pool.
traverseSetHP_ :: Ord b => Maybe HandlerPool -> (a -> Par d s b) -> ISet s a -> ISet s b -> Par d s ()

-- | Variant of <a>cartesianProd</a> that optionally ties the handlers to a
--   pool.
cartesianProdHP :: (Ord a, Ord b) => Maybe HandlerPool -> ISet s a -> ISet s b -> Par d s (ISet s (a, b))

-- | Variant of <a>cartesianProds</a> that optionally ties the handlers to
--   a pool.
cartesianProdsHP :: Ord a => Maybe HandlerPool -> [ISet s a] -> Par d s (ISet s [a])
instance Foldable (ISet Trvrsbl)
instance Foldable (ISet Frzn)
instance Show a => Show (ISet Trvrsbl a)
instance Show a => Show (ISet Frzn a)
instance DeepFrz a => DeepFrz (ISet s a)
instance OrderedLVarData1 ISet
instance LVarData1 ISet
instance Eq (ISet s v)

module Data.LVar.SLMap.Unsafe


-- | This module provides finite maps that only grow. It is based on a
--   <i>concurrent skip list</i> implementation of maps.
--   
--   This module is usually a more efficient alternative to <a>PureMap</a>,
--   and provides almost the same interface. However, it's always good to
--   test multiple data structures if you have a performance-critical use
--   case.
module Data.LVar.SLMap

-- | The map datatype itself. Like all other LVars, it has an <tt>s</tt>
--   parameter (think <tt>STRef</tt>) in addition to the <tt>a</tt>
--   parameter that describes the type of elements in the set.
--   
--   Performance note: this data structure reduces contention between
--   parallel computations inserting into the map, but all <i>blocking</i>
--   computations are not as scalable. All continuations waiting for
--   not-yet-present elements will currently share a single queue
--   [2013.09.26].
data IMap k s v

-- | Create a fresh map with nothing in it.
newEmptyMap :: Ord k => Par d s (IMap k s v)

-- | Create a new map populated with initial elements.
newMap :: Ord k => Map k v -> Par d s (IMap k s v)

-- | Create a new map drawing initial elements from an existing list.
newFromList :: (Ord k, Eq v) => [(k, v)] -> Par d s (IMap k s v)

-- | Put a single entry into the map. (WHNF) Strict in the key and value.
insert :: (Ord k, Eq v) => k -> v -> IMap k s v -> Par d s ()

-- | Wait for the map to contain a specified key, and return the associated
--   value.
getKey :: Ord k => k -> IMap k s v -> Par d s v

-- | Wait on the SIZE of the map, not its contents.
waitSize :: Int -> IMap k s v -> Par d s ()

-- | Wait until the map contains a certain value (on any key).
waitValue :: (Ord k, Eq v) => v -> IMap k s v -> Par d s ()

-- | <a>IMap</a>s containing other LVars have some additional capabilities
--   compared to those containing regular Haskell data. In particular, it
--   is possible to modify existing entries (monotonically). Further, this
--   <a>modify</a> function implicitly inserts a "bottom" element if there
--   is no existing entry for the key.
modify :: (Ord key, Show key, Ord a) => IMap key s (f s a) -> key -> (Par d s (f s a)) -> (f s a -> Par d s b) -> Par d s b

-- | Get the exact contents of the map. As with any quasi-deterministic
--   operation, using <a>freezeMap</a> may cause your program to exhibit a
--   limited form of nondeterminism: it will never return the wrong answer,
--   but it may include synchronization bugs that can
--   (nondeterministically) cause exceptions.
--   
--   This is an <i>O(1)</i> operation that doesn't copy the in-memory
--   representation of the IMap.
freezeMap :: Ord k => IMap k s v -> QPar s (IMap k Frzn v)

-- | Traverse a frozen map for side effect. This is useful (in comparison
--   with more generic operations) because the function passed in may see
--   the key as well as the value.
traverseFrzn_ :: Ord k => (k -> a -> Par d s ()) -> IMap k Frzn a -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new new key/value
--   pairs added to the map.
forEach :: IMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Add an (asynchronous) callback that listens for all new key/value
--   pairs added to the map, optionally tied to a handler pool.
forEachHP :: Maybe HandlerPool -> IMap k s v -> (k -> v -> Par d s ()) -> Par d s ()

-- | Register a per-element callback, then run an action in this context,
--   and freeze when all (recursive) invocations of the callback are
--   complete. Returns the final value of the provided action.
withCallbacksThenFreeze :: Eq b => IMap k s v -> (k -> v -> QPar s ()) -> QPar s b -> QPar s b

-- | Return a fresh map which will contain strictly more elements than the
--   input. That is, things put in the former go in the latter, but not
--   vice versa.
copy :: (Ord k, Eq v) => IMap k s v -> Par d s (IMap k s v)

-- | Establish a monotonic map between the input and output map Produce a
--   new result based on each element, while leaving the keys the same.
traverseMap :: (Ord k, Eq b) => (k -> a -> Par d s b) -> IMap k s a -> Par d s (IMap k s b)

-- | An imperative-style, in-place version of <a>traverseMap</a> that takes
--   the output map as an argument.
traverseMap_ :: (Ord k, Eq b) => (k -> a -> Par d s b) -> IMap k s a -> IMap k s b -> Par d s ()

-- | Variant of <a>traverseMap</a> that optionally ties the handlers to a
--   pool.
traverseMapHP :: (Ord k, Eq b) => Maybe HandlerPool -> (k -> a -> Par d s b) -> IMap k s a -> Par d s (IMap k s b)

-- | Variant of <a>traverseMap_</a> that optionally ties the handlers to a
--   pool.
traverseMapHP_ :: (Ord k, Eq b) => Maybe HandlerPool -> (k -> a -> Par d s b) -> IMap k s a -> IMap k s b -> Par d s ()

-- | Return a new map which will (ultimately) contain everything in either
--   input map. Conflicting entries will result in a multiple put
--   exception. Optionally ties the handlers to a pool.
unionHP :: (Ord k, Eq a) => Maybe HandlerPool -> IMap k s a -> IMap k s a -> Par d s (IMap k s a)
levelCounts :: IMap k s a -> IO [Int]
instance (Show k, Show a) => Show (IMap k Trvrsbl a)
instance (Show k, Show a) => Show (IMap k Frzn a)
instance Foldable (IMap k Trvrsbl)
instance Foldable (IMap k Frzn)
instance DeepFrz a => DeepFrz (IMap k s a)
instance OrderedLVarData1 (IMap k)
instance LVarData1 (IMap k)
instance Eq (IMap k s v)


-- | This is <i>not</i> a datatype for the end-user.
--   
--   Rather, this module is for building <i>new</i> LVar types in a
--   comparatively easy way: by putting a pure value in a mutable
--   container, and defining a <tt>put</tt> operation as a pure function.
--   
--   The data structure implementor who uses this module must guarantee
--   that their <tt>put</tt> operation computes a <i>least upper bound</i>,
--   ensuring that the set of states that their LVar type can take on form
--   a join-semilattice (<a>http://en.wikipedia.org/wiki/Semilattice</a>).
module Data.LVar.Internal.Pure

-- | An LVar which consists merely of an immutable, pure value inside a
--   mutable box.
newtype PureLVar s t
PureLVar :: (LVar s (IORef t) t) -> PureLVar s t

-- | A new pure LVar populated with the provided initial state.
newPureLVar :: JoinSemiLattice t => t -> Par d s (PureLVar s t)

-- | Put a new value which will be joined with the old.
putPureLVar :: JoinSemiLattice t => PureLVar s t -> t -> Par d s ()

-- | Wait until the pure LVar has crossed a threshold and then unblock. (In
--   the semantics, this is a singleton query set.)
waitPureLVar :: (JoinSemiLattice t, Eq t) => PureLVar s t -> t -> Par d s ()

-- | Freeze the pure LVar, returning its exact value. Subsequent
--   <tt>put</tt>s will raise an error.
freezePureLVar :: PureLVar s t -> Par QuasiDet s t

-- | Read the exact contents of an already frozen PureLVar.
fromPureLVar :: PureLVar Frzn t -> t

-- | Blocks until the contents of <tt>lv</tt> are at or above one element
--   of <tt>thrshSet</tt>, then returns that one element.
getPureLVar :: (JoinSemiLattice t, Eq t) => PureLVar s t -> [t] -> Par d s t

-- | Like <a>getPureLVar</a> but uses a threshold function rather than an
--   explicit set.
unsafeGetPureLVar :: (JoinSemiLattice t, Eq t) => PureLVar s t -> (t -> Bool) -> Par d s t

-- | Takes a finite set of states and a join operation (e.g., for an
--   instance of JoinSemiLattice) and returns an error message if the
--   join-semilattice properties don't hold.
verifyFiniteJoin :: (Eq a, Show a) => [a] -> (a -> a -> a) -> Maybe String

-- | Verify that a blocking get is monotone in just the right way. This
--   takes a designated bottom and top element.
verifyFiniteGet :: (Eq a, Show a, JoinSemiLattice a, Eq b, Show b) => [a] -> (b, b) -> (a -> b) -> Maybe String
instance DeepFrz a => DeepFrz (PureLVar s a)
instance Eq (PureLVar s v)
instance Show a => Show (PureLVar Frzn a)


-- | In contrast with <a>Data.LVar.Memo</a>, this module provides a way to
--   run a computation for each node of a graph WITH support for cycles.
--   Cycles are explicitly recognized and then may be handled in an
--   application specific fashion.
module Data.LVar.CycGraph

-- | This supercombinator does a parallel depth-first search of a dynamic
--   graph, with detection of cycles.
--   
--   Each node in the graph is a computation whose input is the
--   <tt>key</tt> (the vertex ID). Each such computation dynamically
--   computes which other keys it depends on and requests the values
--   associated with those keys.
--   
--   This implementation uses a sequential depth-first-search (DFS),
--   starting from the initially requested key. One can picture this search
--   as a directed tree radiating from the starting key. When a cycle is
--   detected at any leaf of this tree, an alternate cycle handler is
--   called instead of running the normal computation for that key.
exploreGraph_seq :: (Ord k, Eq v, Show k, Show v) => (k -> Par d s (Response (Par d s) k v)) -> (k -> Par d s v) -> k -> Par d s v

-- | A means of building a dynamic graph. The node computation returns a
--   response which may either be a final value, or a request to explore
--   more nodes (together with a continuation for the resulting value).
--   
--   Note that because only one key is requested at a time, this cannot
--   express parallel graph traversals.
data Response par key ans
Done :: !ans -> Response par key ans
Request :: !key -> (RequestCont par key ans) -> Response par key ans

-- | This combinator provides parallel exploration of a graph that contains
--   cycles. The limitation is that the work to be performed at each node
--   (<a>NodeAction</a>) is not invoked until the graph is fully traversed,
--   i.e. after a barrier. Thus the graph explored is not a "dynamic graph"
--   in the sense of being computed on the fly by the <a>NodeAction</a>.
--   
--   The algorithm used in this function is fairly expensive. For each
--   node, it uses a monotonic data structure to track the full set of
--   other nodes that can reach it in the graph.
exploreGraph :: (Ord k, Eq v, Show k, Show v) => (k -> Par QuasiDet s [k]) -> NodeAction QuasiDet s k v -> k -> Par QuasiDet s v

-- | At the end of the handler execution, the value of a node is either
--   ready, or it is instead deferred to be exactly the value provided by
--   another key.
data NodeValue k v
FinalValue :: !v -> NodeValue k v
Defer :: k -> NodeValue k v

-- | The handler at a particular node (key) in the graph. This takes as
--   argument a key, along with a boolean indicating whether the current
--   node has been found to be part of a cycle.
--   
--   Also, for each child node, this handler is provided a way to demand
--   the resulting value of that child node, plus an indication of whether
--   the child node participates in a cycle.
--   
--   Finally, this handler is expected to produce a value which becomes
--   associated with the key.
type NodeAction d s k v = IsCycle -> k -> [(k, IsCycle, IVar s v)] -> Par d s (NodeValue k v)

-- | A show class that tries to stay under a budget.
class Show t => ShortShow t where shortShow n x = take n (show x)
shortShow :: ShortShow t => Int -> t -> String

-- | Combine two things within a given size budget.
shortTwo :: (ShortShow t, ShortShow t1) => Int -> t -> t1 -> (String, String)
instance Eq k => Eq (NodeRecord s k v)
instance (Show k, Show v) => Show (NodeValue k v)
instance (Eq k, Eq v) => Eq (NodeValue k v)
instance (Ord k, Ord v) => Ord (NodeValue k v)
instance (ShortShow a, ShortShow b) => ShortShow (a, b)
instance ShortShow String
instance ShortShow Int64
instance ShortShow Int32
instance ShortShow Int16
instance ShortShow Int8
instance ShortShow Int
instance ShortShow Integer
instance ShortShow Bool
