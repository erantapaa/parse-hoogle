-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dead simple JSON parser, with some Template Haskell sugar.
--   
--   This is dead simple JSON, consisting of a simple parser built with
--   Parsec and some Template Haskell syntactic sugar (which you may or may
--   not use, it works without).
@package dead-simple-json
@version 0.1.2


-- | The basic JSON data types.
module Text.DeadSimpleJSON.Types

-- | A JSON value.
data Value

-- | A JSON String, represented as ordinary Haskell String.
String :: String -> Value

-- | A JSON Number, represented by two <a>Integer</a>s in exponontial form.
--   <tt>Number n e</tt> is the same as <tt>{n}e{exp}</tt>, that is <tt>n *
--   10 ^ e</tt>. This allows for arbitrary precision fixed point
--   rationals. See <tt>Convert</tt> for easy conversions.
Number :: !Integer -> !Integer -> Value

-- | A JSON Object, represented as <a>Map</a>.
Object :: (Map String Value) -> Value

-- | A JSON Array, represented as <a>Vector</a> of Values.
Array :: (Vector Value) -> Value

-- | True.
True :: Value

-- | False.
False :: Value

-- | Null (void, unit, <tt>()</tt>).
Null :: Value

-- | A top-level JSON object.
--   
--   Merely a wrapper that ensures that no other <a>Value</a>s but
--   <a>Array</a> and <a>Object</a> reside at the top-level.
newtype JSON
JSON :: Value -> JSON
instance Typeable Value
instance Typeable JSON
instance Eq Value
instance Show Value
instance Read Value
instance Data Value
instance Eq JSON
instance Data JSON

module Text.DeadSimpleJSON.Convert

-- | A JSON value.
data Value

-- | A JSON String, represented as ordinary Haskell String.
String :: String -> Value

-- | A JSON Number, represented by two <a>Integer</a>s in exponontial form.
--   <tt>Number n e</tt> is the same as <tt>{n}e{exp}</tt>, that is <tt>n *
--   10 ^ e</tt>. This allows for arbitrary precision fixed point
--   rationals. See <tt>Convert</tt> for easy conversions.
Number :: !Integer -> !Integer -> Value

-- | A JSON Object, represented as <a>Map</a>.
Object :: (Map String Value) -> Value

-- | A JSON Array, represented as <a>Vector</a> of Values.
Array :: (Vector Value) -> Value

-- | True.
True :: Value

-- | False.
False :: Value

-- | Null (void, unit, <tt>()</tt>).
Null :: Value
class Convert a where convert' n@(Number _ _) = return $ convert n convert' _ = fail "" toJSON = undefined
convert :: Convert a => Value -> a
convert' :: Convert a => Value -> Maybe a
toJSON :: Convert a => a -> Value
instance [overlap ok] Convert Int64
instance [overlap ok] Convert Int32
instance [overlap ok] Convert Int16
instance [overlap ok] Convert Int8
instance [overlap ok] Convert Int
instance [overlap ok] Convert Integer
instance [overlap ok] (Read a, Integral a) => Convert (Ratio a)
instance [overlap ok] Convert Float
instance [overlap ok] Convert Double
instance [overlap ok] Convert a => Convert [a]
instance [overlap ok] Convert String
instance [overlap ok] Convert Bool
instance [overlap ok] Convert Value
instance [overlap ok] Convert a => Convert (Maybe a)

module Text.DeadSimpleJSON.Query
query :: Convert a => Query -> JSON -> a
query' :: Convert a => Query -> JSON -> Maybe a
queryV :: Convert a => Query -> Value -> a
queryV' :: Convert a => Query -> Value -> Maybe a
data Query
Field :: String -> Query -> Query
Index :: Int -> Query -> Query
Read :: Query
mkQuery :: String -> Query
mkQuery' :: String -> Either ParseError Query
(?) :: Convert a => JSON -> String -> a
instance Typeable Query
instance Show Query
instance Data Query


-- | A simple approach for parsing JSON.
--   
--   To read JSON data use <a>read</a>. To print JSON data use <a>show</a>:
--   
--   <pre>
--   let jsonData = read "[1,2,4,8,16]" :: JSON
--   putStrLn $ show jsonData
--   </pre>
--   
--   You can query json data using <a>?</a>. Querying implies conversion,
--   therefor you may need to specify the result type:
--   
--   <pre>
--   let jsonData = read "{\"seven\": 7, \"nine\": [1,2,4,8,16]}"
--   print $ (jsonData ? "nine[3]" :: Int)
--   </pre>
--   
--   For tighter control use <a>parse</a>. A more convenient way for
--   creating JSON objects in source code or querying JSON data, is using
--   Template Haskell. See <tt>Text.SimpleJSON.TH</tt>.
--   
--   The recommended way for importing this module is importing it
--   qualified, like so:
--   
--   <pre>
--   import qualified Text.SimpleJSON as JSON
--   import Text.SimpleJSON (JSON)
--   </pre>
module Text.DeadSimpleJSON

-- | Parse a String for JSON data or return a ParseError.
parse :: String -> Either ParseError JSON

-- | Parses a top-level JSON object, returning Just a Value or Nothing.
parse' :: String -> Maybe Value

-- | Purely Monadic version of <a>parse'</a>.
parseM :: Monad m => String -> m Value

-- | A JSON value.
data Value

-- | A JSON String, represented as ordinary Haskell String.
String :: String -> Value

-- | A JSON Number, represented by two <a>Integer</a>s in exponontial form.
--   <tt>Number n e</tt> is the same as <tt>{n}e{exp}</tt>, that is <tt>n *
--   10 ^ e</tt>. This allows for arbitrary precision fixed point
--   rationals. See <tt>Convert</tt> for easy conversions.
Number :: !Integer -> !Integer -> Value

-- | A JSON Object, represented as <a>Map</a>.
Object :: (Map String Value) -> Value

-- | A JSON Array, represented as <a>Vector</a> of Values.
Array :: (Vector Value) -> Value

-- | True.
True :: Value

-- | False.
False :: Value

-- | Null (void, unit, <tt>()</tt>).
Null :: Value

-- | A top-level JSON object.
--   
--   Merely a wrapper that ensures that no other <a>Value</a>s but
--   <a>Array</a> and <a>Object</a> reside at the top-level.
data JSON
(?) :: Convert a => JSON -> String -> a

-- | Unwraps a top-level JSON object to a Value.
top :: JSON -> Value
class Convert a where convert' n@(Number _ _) = return $ convert n convert' _ = fail "" toJSON = undefined
convert :: Convert a => Value -> a
convert' :: Convert a => Value -> Maybe a
toJSON :: Convert a => a -> Value
instance Read JSON
instance Show JSON


-- | Template Haskell syntax sugar for working with <a>JSON</a> data.
--   
--   For using this module, you need to declare a LANGUAGE pragma like the
--   following:
--   
--   <pre>
--   {-# LANGUAGE Haskell2010, TemplateHaskell, QuasiQuotes #-}
--   </pre>
module Text.DeadSimpleJSON.TH

-- | A QuasiQuoter which queries a json object using JavaScript notation.
--   
--   Suppose obj contains a json object of type JSON:
--   
--   <pre>
--   [jsq| obj.prop.list[3] |]
--   </pre>
--   
--   The above will query the object in obj as if it was JavaScript.
--   
--   The type of the expression is polymorphic: <tt>Convert a =&gt; a</tt>.
--   
--   You will need to specify the type of the query, like so:
--   
--   <pre>
--   [jsq| obj.prop.list |] :: [Integer]
--   </pre>
--   
--   For possible conversions, see the instances for <a>Convert</a>.
jsq :: QuasiQuoter

-- | A QuasiQuoter which includes JSON data.
--   
--   The type of the expression is <a>JSON</a>.
json :: QuasiQuoter

-- | A QuasiQuoter which includes JSON data from files.
--   
--   The following example will include the contents of <tt>data.json</tt>
--   as <a>JSON</a>.
--   
--   <pre>
--   let str = [jsonF|data.json|]
--   </pre>
--   
--   Note that every character inside the brackets is treated as part of
--   the file name, that is <tt>[jsonF| data.json |]</tt> is not the same
--   as the above example (it will try to find a file which name includes
--   space characters).
jsonF :: QuasiQuoter

-- | A QuasiQuoter on raw strings.
--   
--   The definition is basically:
--   
--   <pre>
--   s = QuasiQuoter {
--     quoteExp  = return . LitE . StringL
--   }
--   </pre>
s :: QuasiQuoter

-- | A QuasiQuoter which includes raw strings from files.
--   
--   The following example will include the contents of <tt>file.txt</tt>
--   as a <tt>String</tt>.
--   
--   <pre>
--   let str = [sF|file.txt|]
--   </pre>
--   
--   Note that every character inside the brackets is treated as part of
--   the file name, that is <tt>[sF| file.txt |]</tt> is not the same as
--   the above example (it will try to find a file which name includes
--   space characters).
sF :: QuasiQuoter
