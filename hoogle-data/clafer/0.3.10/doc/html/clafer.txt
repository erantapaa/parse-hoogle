-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.
--   
@package clafer
@version 0.3.10

module Language.Clafer.SplitJoin

-- | Given a string, split into the available arguments. The inverse of
--   <a>joinArgs</a>.
splitArgs :: String -> [String]

-- | Given a sequence of arguments, join them together in a manner that
--   could be used on | the command line, giving preference to the Windows
--   <tt>cmd</tt> shell quoting conventions. | For an alternative version,
--   intended for actual running the result in a shell, see
--   "System.Process.showCommandForUser"
joinArgs :: [String] -> String

module Language.Clafer.Generator.Schema
xsd :: String

module Language.Clafer.Front.LexClafer
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc (Posn -> String -> Token) user)
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Posn -> String -> Token) (Any *)) -> Int -> AlexAcc (Posn -> String -> Token) (Any *)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t1 -> Int# -> AlexInput -> Int# -> AlexLastAcc (Posn -> String -> Token) -> (AlexLastAcc (Posn -> String -> Token), AlexInput)
tok :: (Posn -> String -> Token) -> (Posn -> String -> Token)
share :: String -> String
data Tok
TS :: !String -> !Int -> Tok
TL :: !String -> Tok
TI :: !String -> Tok
TV :: !String -> Tok
TD :: !String -> Tok
TC :: !String -> Tok
T_PosInteger :: !String -> Tok
T_PosDouble :: !String -> Tok
T_PosString :: !String -> Tok
T_PosIdent :: !String -> Tok
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token
tokenPos :: [Token] -> String
tokenPosn :: Token -> Posn
tokenLineCol :: Token -> (Int, Int)
posLineCol :: Posn -> (Int, Int)
mkPosToken :: Token -> ((Int, Int), String)
prToken :: Token -> String
data BTree
N :: BTree
B :: String -> Tok -> BTree -> BTree -> BTree
eitherResIdent :: (String -> Tok) -> String -> Tok
resWords :: BTree
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
alex_action_8 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
data AlexLastAcc a
AlexNone :: AlexLastAcc a
AlexLastAcc :: a -> !AlexInput -> !Int -> AlexLastAcc a
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc a
data AlexAcc a user
AlexAccNone :: AlexAcc a user
AlexAcc :: a -> AlexAcc a user
AlexAccSkip :: AlexAcc a user
iUnbox :: Int -> Int#
instance Eq Tok
instance Show Tok
instance Ord Tok
instance Show BTree
instance Eq Posn
instance Show Posn
instance Ord Posn
instance Eq Token
instance Show Token
instance Ord Token
instance Functor AlexLastAcc

module Language.Clafer.Front.AbsClafer
data Pos
Pos :: Integer -> Integer -> Pos
noPos :: Pos
data Span
Span :: Pos -> Pos -> Span
noSpan :: Span
class Spannable n
getSpan :: Spannable n => n -> Span
(>-) :: Span -> Span -> Span
len :: [a] -> Integer
newtype PosInteger
PosInteger :: ((Int, Int), String) -> PosInteger
newtype PosDouble
PosDouble :: ((Int, Int), String) -> PosDouble
newtype PosString
PosString :: ((Int, Int), String) -> PosString
newtype PosIdent
PosIdent :: ((Int, Int), String) -> PosIdent
data Module
Module :: Span -> [Declaration] -> Module
data Declaration
EnumDecl :: Span -> PosIdent -> [EnumId] -> Declaration
ElementDecl :: Span -> Element -> Declaration
data Clafer
Clafer :: Span -> Abstract -> GCard -> PosIdent -> Super -> Reference -> Card -> Init -> Elements -> Clafer
data Constraint
Constraint :: Span -> [Exp] -> Constraint
data SoftConstraint
SoftConstraint :: Span -> [Exp] -> SoftConstraint
data Goal
Goal :: Span -> [Exp] -> Goal
data Abstract
AbstractEmpty :: Span -> Abstract
Abstract :: Span -> Abstract
data Elements
ElementsEmpty :: Span -> Elements
ElementsList :: Span -> [Element] -> Elements
data Element
Subclafer :: Span -> Clafer -> Element
ClaferUse :: Span -> Name -> Card -> Elements -> Element
Subconstraint :: Span -> Constraint -> Element
Subgoal :: Span -> Goal -> Element
Subsoftconstraint :: Span -> SoftConstraint -> Element
data Super
SuperEmpty :: Span -> Super
SuperSome :: Span -> SetExp -> Super
data Reference
ReferenceEmpty :: Span -> Reference
ReferenceSet :: Span -> SetExp -> Reference
ReferenceBag :: Span -> SetExp -> Reference
data Init
InitEmpty :: Span -> Init
InitSome :: Span -> InitHow -> Exp -> Init
data InitHow
InitConstant :: Span -> InitHow
InitDefault :: Span -> InitHow
data GCard
GCardEmpty :: Span -> GCard
GCardXor :: Span -> GCard
GCardOr :: Span -> GCard
GCardMux :: Span -> GCard
GCardOpt :: Span -> GCard
GCardInterval :: Span -> NCard -> GCard
data Card
CardEmpty :: Span -> Card
CardLone :: Span -> Card
CardSome :: Span -> Card
CardAny :: Span -> Card
CardNum :: Span -> PosInteger -> Card
CardInterval :: Span -> NCard -> Card
data NCard
NCard :: Span -> PosInteger -> ExInteger -> NCard
data ExInteger
ExIntegerAst :: Span -> ExInteger
ExIntegerNum :: Span -> PosInteger -> ExInteger
data Name
Path :: Span -> [ModId] -> Name
data Exp
DeclAllDisj :: Span -> Decl -> Exp -> Exp
DeclAll :: Span -> Decl -> Exp -> Exp
DeclQuantDisj :: Span -> Quant -> Decl -> Exp -> Exp
DeclQuant :: Span -> Quant -> Decl -> Exp -> Exp
EGMax :: Span -> Exp -> Exp
EGMin :: Span -> Exp -> Exp
EIff :: Span -> Exp -> Exp -> Exp
EImplies :: Span -> Exp -> Exp -> Exp
EOr :: Span -> Exp -> Exp -> Exp
EXor :: Span -> Exp -> Exp -> Exp
EAnd :: Span -> Exp -> Exp -> Exp
ENeg :: Span -> Exp -> Exp
ELt :: Span -> Exp -> Exp -> Exp
EGt :: Span -> Exp -> Exp -> Exp
EEq :: Span -> Exp -> Exp -> Exp
ELte :: Span -> Exp -> Exp -> Exp
EGte :: Span -> Exp -> Exp -> Exp
ENeq :: Span -> Exp -> Exp -> Exp
EIn :: Span -> Exp -> Exp -> Exp
ENin :: Span -> Exp -> Exp -> Exp
QuantExp :: Span -> Quant -> Exp -> Exp
EAdd :: Span -> Exp -> Exp -> Exp
ESub :: Span -> Exp -> Exp -> Exp
EMul :: Span -> Exp -> Exp -> Exp
EDiv :: Span -> Exp -> Exp -> Exp
ERem :: Span -> Exp -> Exp -> Exp
ESumSetExp :: Span -> Exp -> Exp
EProdSetExp :: Span -> Exp -> Exp
ECSetExp :: Span -> Exp -> Exp
EMinExp :: Span -> Exp -> Exp
EImpliesElse :: Span -> Exp -> Exp -> Exp -> Exp
EInt :: Span -> PosInteger -> Exp
EDouble :: Span -> PosDouble -> Exp
EStr :: Span -> PosString -> Exp
ESetExp :: Span -> SetExp -> Exp
data SetExp
Union :: Span -> SetExp -> SetExp -> SetExp
UnionCom :: Span -> SetExp -> SetExp -> SetExp
Difference :: Span -> SetExp -> SetExp -> SetExp
Intersection :: Span -> SetExp -> SetExp -> SetExp
Domain :: Span -> SetExp -> SetExp -> SetExp
Range :: Span -> SetExp -> SetExp -> SetExp
Join :: Span -> SetExp -> SetExp -> SetExp
ClaferId :: Span -> Name -> SetExp
data Decl
Decl :: Span -> [LocId] -> SetExp -> Decl
data Quant
QuantNo :: Span -> Quant
QuantNot :: Span -> Quant
QuantLone :: Span -> Quant
QuantOne :: Span -> Quant
QuantSome :: Span -> Quant
data EnumId
EnumIdIdent :: Span -> PosIdent -> EnumId
data ModId
ModIdIdent :: Span -> PosIdent -> ModId
data LocId
LocIdIdent :: Span -> PosIdent -> LocId
instance Typeable Pos
instance Typeable Span
instance Typeable PosInteger
instance Typeable PosDouble
instance Typeable PosString
instance Typeable PosIdent
instance Typeable Abstract
instance Typeable InitHow
instance Typeable ExInteger
instance Typeable NCard
instance Typeable Card
instance Typeable GCard
instance Typeable Quant
instance Typeable EnumId
instance Typeable ModId
instance Typeable Name
instance Typeable SetExp
instance Typeable Reference
instance Typeable Super
instance Typeable LocId
instance Typeable Decl
instance Typeable Exp
instance Typeable Init
instance Typeable Goal
instance Typeable SoftConstraint
instance Typeable Constraint
instance Typeable Element
instance Typeable Elements
instance Typeable Clafer
instance Typeable Declaration
instance Typeable Module
instance Eq Pos
instance Ord Pos
instance Show Pos
instance Read Pos
instance Data Pos
instance Generic Pos
instance Eq Span
instance Ord Span
instance Show Span
instance Read Span
instance Data Span
instance Generic Span
instance Eq PosInteger
instance Ord PosInteger
instance Show PosInteger
instance Read PosInteger
instance Data PosInteger
instance Generic PosInteger
instance Eq PosDouble
instance Ord PosDouble
instance Show PosDouble
instance Read PosDouble
instance Data PosDouble
instance Generic PosDouble
instance Eq PosString
instance Ord PosString
instance Show PosString
instance Read PosString
instance Data PosString
instance Generic PosString
instance Eq PosIdent
instance Ord PosIdent
instance Show PosIdent
instance Read PosIdent
instance Data PosIdent
instance Generic PosIdent
instance Eq Abstract
instance Ord Abstract
instance Show Abstract
instance Read Abstract
instance Data Abstract
instance Generic Abstract
instance Eq InitHow
instance Ord InitHow
instance Show InitHow
instance Read InitHow
instance Data InitHow
instance Generic InitHow
instance Eq ExInteger
instance Ord ExInteger
instance Show ExInteger
instance Read ExInteger
instance Data ExInteger
instance Generic ExInteger
instance Eq NCard
instance Ord NCard
instance Show NCard
instance Read NCard
instance Data NCard
instance Generic NCard
instance Eq Card
instance Ord Card
instance Show Card
instance Read Card
instance Data Card
instance Generic Card
instance Eq GCard
instance Ord GCard
instance Show GCard
instance Read GCard
instance Data GCard
instance Generic GCard
instance Eq Quant
instance Ord Quant
instance Show Quant
instance Read Quant
instance Data Quant
instance Generic Quant
instance Eq EnumId
instance Ord EnumId
instance Show EnumId
instance Read EnumId
instance Data EnumId
instance Generic EnumId
instance Eq ModId
instance Ord ModId
instance Show ModId
instance Read ModId
instance Data ModId
instance Generic ModId
instance Eq Name
instance Ord Name
instance Show Name
instance Read Name
instance Data Name
instance Generic Name
instance Eq SetExp
instance Ord SetExp
instance Show SetExp
instance Read SetExp
instance Data SetExp
instance Generic SetExp
instance Eq Reference
instance Ord Reference
instance Show Reference
instance Read Reference
instance Data Reference
instance Generic Reference
instance Eq Super
instance Ord Super
instance Show Super
instance Read Super
instance Data Super
instance Generic Super
instance Eq LocId
instance Ord LocId
instance Show LocId
instance Read LocId
instance Data LocId
instance Generic LocId
instance Eq Decl
instance Ord Decl
instance Show Decl
instance Read Decl
instance Data Decl
instance Generic Decl
instance Eq Exp
instance Ord Exp
instance Show Exp
instance Read Exp
instance Data Exp
instance Generic Exp
instance Eq Init
instance Ord Init
instance Show Init
instance Read Init
instance Data Init
instance Generic Init
instance Eq Goal
instance Ord Goal
instance Show Goal
instance Read Goal
instance Data Goal
instance Generic Goal
instance Eq SoftConstraint
instance Ord SoftConstraint
instance Show SoftConstraint
instance Read SoftConstraint
instance Data SoftConstraint
instance Generic SoftConstraint
instance Eq Constraint
instance Ord Constraint
instance Show Constraint
instance Read Constraint
instance Data Constraint
instance Generic Constraint
instance Eq Element
instance Ord Element
instance Show Element
instance Read Element
instance Data Element
instance Generic Element
instance Eq Elements
instance Ord Elements
instance Show Elements
instance Read Elements
instance Data Elements
instance Generic Elements
instance Eq Clafer
instance Ord Clafer
instance Show Clafer
instance Read Clafer
instance Data Clafer
instance Generic Clafer
instance Eq Declaration
instance Ord Declaration
instance Show Declaration
instance Read Declaration
instance Data Declaration
instance Generic Declaration
instance Eq Module
instance Ord Module
instance Show Module
instance Read Module
instance Data Module
instance Generic Module
instance Datatype D1Pos
instance Constructor C1_0Pos
instance Datatype D1Span
instance Constructor C1_0Span
instance Datatype D1PosInteger
instance Constructor C1_0PosInteger
instance Datatype D1PosDouble
instance Constructor C1_0PosDouble
instance Datatype D1PosString
instance Constructor C1_0PosString
instance Datatype D1PosIdent
instance Constructor C1_0PosIdent
instance Datatype D1Abstract
instance Constructor C1_0Abstract
instance Constructor C1_1Abstract
instance Datatype D1InitHow
instance Constructor C1_0InitHow
instance Constructor C1_1InitHow
instance Datatype D1ExInteger
instance Constructor C1_0ExInteger
instance Constructor C1_1ExInteger
instance Datatype D1NCard
instance Constructor C1_0NCard
instance Datatype D1Card
instance Constructor C1_0Card
instance Constructor C1_1Card
instance Constructor C1_2Card
instance Constructor C1_3Card
instance Constructor C1_4Card
instance Constructor C1_5Card
instance Datatype D1GCard
instance Constructor C1_0GCard
instance Constructor C1_1GCard
instance Constructor C1_2GCard
instance Constructor C1_3GCard
instance Constructor C1_4GCard
instance Constructor C1_5GCard
instance Datatype D1Quant
instance Constructor C1_0Quant
instance Constructor C1_1Quant
instance Constructor C1_2Quant
instance Constructor C1_3Quant
instance Constructor C1_4Quant
instance Datatype D1EnumId
instance Constructor C1_0EnumId
instance Datatype D1ModId
instance Constructor C1_0ModId
instance Datatype D1Name
instance Constructor C1_0Name
instance Datatype D1SetExp
instance Constructor C1_0SetExp
instance Constructor C1_1SetExp
instance Constructor C1_2SetExp
instance Constructor C1_3SetExp
instance Constructor C1_4SetExp
instance Constructor C1_5SetExp
instance Constructor C1_6SetExp
instance Constructor C1_7SetExp
instance Datatype D1Reference
instance Constructor C1_0Reference
instance Constructor C1_1Reference
instance Constructor C1_2Reference
instance Datatype D1Super
instance Constructor C1_0Super
instance Constructor C1_1Super
instance Datatype D1LocId
instance Constructor C1_0LocId
instance Datatype D1Decl
instance Constructor C1_0Decl
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Constructor C1_10Exp
instance Constructor C1_11Exp
instance Constructor C1_12Exp
instance Constructor C1_13Exp
instance Constructor C1_14Exp
instance Constructor C1_15Exp
instance Constructor C1_16Exp
instance Constructor C1_17Exp
instance Constructor C1_18Exp
instance Constructor C1_19Exp
instance Constructor C1_20Exp
instance Constructor C1_21Exp
instance Constructor C1_22Exp
instance Constructor C1_23Exp
instance Constructor C1_24Exp
instance Constructor C1_25Exp
instance Constructor C1_26Exp
instance Constructor C1_27Exp
instance Constructor C1_28Exp
instance Constructor C1_29Exp
instance Constructor C1_30Exp
instance Constructor C1_31Exp
instance Constructor C1_32Exp
instance Constructor C1_33Exp
instance Constructor C1_34Exp
instance Datatype D1Init
instance Constructor C1_0Init
instance Constructor C1_1Init
instance Datatype D1Goal
instance Constructor C1_0Goal
instance Datatype D1SoftConstraint
instance Constructor C1_0SoftConstraint
instance Datatype D1Constraint
instance Constructor C1_0Constraint
instance Datatype D1Element
instance Constructor C1_0Element
instance Constructor C1_1Element
instance Constructor C1_2Element
instance Constructor C1_3Element
instance Constructor C1_4Element
instance Datatype D1Elements
instance Constructor C1_0Elements
instance Constructor C1_1Elements
instance Datatype D1Clafer
instance Constructor C1_0Clafer
instance Datatype D1Declaration
instance Constructor C1_0Declaration
instance Constructor C1_1Declaration
instance Datatype D1Module
instance Constructor C1_0Module
instance Spannable LocId
instance Spannable ModId
instance Spannable EnumId
instance Spannable Quant
instance Spannable Decl
instance Spannable SetExp
instance Spannable Exp
instance Spannable Name
instance Spannable ExInteger
instance Spannable NCard
instance Spannable Card
instance Spannable GCard
instance Spannable InitHow
instance Spannable Init
instance Spannable Reference
instance Spannable Super
instance Spannable Element
instance Spannable Elements
instance Spannable Abstract
instance Spannable Goal
instance Spannable SoftConstraint
instance Spannable Constraint
instance Spannable Clafer
instance Spannable Declaration
instance Spannable Module
instance Spannable PosIdent
instance Spannable PosString
instance Spannable PosDouble
instance Spannable PosInteger
instance Spannable n => Spannable [n]

module Language.Clafer.Front.PrintClafer
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS
class Print a where prtList = concatD . map (prt 0)
prt :: Print a => Int -> a -> Doc
prtList :: Print a => [a] -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Print LocId
instance Print ModId
instance Print EnumId
instance Print Quant
instance Print Decl
instance Print SetExp
instance Print Exp
instance Print Name
instance Print ExInteger
instance Print NCard
instance Print Card
instance Print GCard
instance Print InitHow
instance Print Init
instance Print Reference
instance Print Super
instance Print Element
instance Print Elements
instance Print Abstract
instance Print Goal
instance Print SoftConstraint
instance Print Constraint
instance Print Clafer
instance Print Declaration
instance Print Module
instance Print PosIdent
instance Print PosString
instance Print PosDouble
instance Print PosInteger
instance Print Double
instance Print Integer
instance Print Char
instance Print a => Print [a]


-- | Intermediate representation (IR) of a Clafer model
module Language.Clafer.Intermediate.Intclafer

-- | unique identifier of a clafer
type UID = String

-- | clafer name as declared in the source model
type CName = String

-- | file:/<i> ftp:</i><i> or http:</i>/ prefixed URL
type URL = String

-- | A "supertype" of all IR types
data Ir
IRIModule :: IModule -> Ir
IRIElement :: IElement -> Ir
IRIType :: IType -> Ir
IRClafer :: IClafer -> Ir
IRIExp :: IExp -> Ir
IRPExp :: PExp -> Ir
IRIReference :: (Maybe IReference) -> Ir
IRIQuant :: IQuant -> Ir
IRIDecl :: IDecl -> Ir
IRIGCard :: (Maybe IGCard) -> Ir
data IType
TBoolean :: IType
TString :: IType
TInteger :: IType
TReal :: IType

-- | the type is an intersection of the listed clafers supports having
--   paths in the inheritance hierarchy supports multiple inheritance
TClafer :: [UID] -> IType

-- | each file contains exactly one mode. A module is a list of
--   declarations
data IModule
IModule :: String -> [IElement] -> IModule

-- | always empty (no syntax for declaring modules)
_mName :: IModule -> String

-- | List of top-level elements
_mDecls :: IModule -> [IElement]

-- | Clafer has a list of fields that specify its properties. Some fields,
--   marked as (o) are for generating optimized code
data IClafer
IClafer :: Span -> Bool -> Maybe IGCard -> CName -> UID -> UID -> Maybe PExp -> Maybe IReference -> Maybe Interval -> Interval -> [IElement] -> IClafer

-- | the position of the syntax in source code
_cinPos :: IClafer -> Span

-- | whether abstract or not (i.e., concrete)
_isAbstract :: IClafer -> Bool

-- | group cardinality
_gcard :: IClafer -> Maybe IGCard

-- | name declared in the model
_ident :: IClafer -> CName

-- | a unique identifier
_uid :: IClafer -> UID

-- | "root" if top-level, "" if unresolved or for root clafer, otherwise
--   UID of the parent clafer
_parentUID :: IClafer -> UID

-- | superclafer - only allowed PExp is IClaferId. Nothing = default super
--   "clafer"
_super :: IClafer -> Maybe PExp

-- | reference type, bag or set
_reference :: IClafer -> Maybe IReference

-- | clafer cardinality
_card :: IClafer -> Maybe Interval

-- | (o) global cardinality
_glCard :: IClafer -> Interval

-- | nested elements
_elements :: IClafer -> [IElement]

-- | Clafer's subelement is either a clafer, a constraint, or a goal
--   (objective) This is a wrapper type needed to have polymorphic lists of
--   elements
data IElement
IEClafer :: IClafer -> IElement

-- | the actual clafer
_iClafer :: IElement -> IClafer
IEConstraint :: Bool -> PExp -> IElement

-- | whether hard constraint or assertion
_isHard :: IElement -> Bool

-- | the container of the actual expression
_cpexp :: IElement -> PExp

-- | Goal (optimization objective)
IEGoal :: Bool -> PExp -> IElement

-- | whether maximize or minimize
_isMaximize :: IElement -> Bool

-- | the container of the actual expression
_cpexp :: IElement -> PExp

-- | A type of reference. -&gt; values unique (set) -&gt;&gt; values
--   non-unique (bag)
data IReference
IReference :: Bool -> PExp -> IReference

-- | whether set or bag
_isSet :: IReference -> Bool

-- | the only allowed reference expressions are IClafer and set expr. (++,
--   **, --s)
_ref :: IReference -> PExp

-- | Group cardinality is specified as an interval. It may also be given by
--   a keyword. xor 1..1 isKeyword = True 1..1 1..1 isKeyword = False
data IGCard
IGCard :: Bool -> Interval -> IGCard

-- | whether given by keyword: or, xor, mux
_isKeyword :: IGCard -> Bool
_interval :: IGCard -> Interval

-- | (Min, Max) integer interval. -1 denotes *
type Interval = (Integer, Integer)

-- | This is expression container (parent). It has meta information about
--   an actual expression <a>exp</a>
data PExp
PExp :: Maybe IType -> String -> Span -> IExp -> PExp

-- | the inferred type
_iType :: PExp -> Maybe IType

-- | non-empty unique id for expressions with span, "" for noSpan
_pid :: PExp -> String

-- | position in the input Clafer file
_inPos :: PExp -> Span

-- | the actual expression
_exp :: PExp -> IExp

-- | Embedes reference to a resolved Clafer
type ClaferBinding = Maybe UID
data IExp

-- | quantified expression with declarations e.g., [ all x1; x2 : X |
--   x1.ref != x2.ref ]
IDeclPExp :: IQuant -> [IDecl] -> PExp -> IExp
_quant :: IExp -> IQuant
_oDecls :: IExp -> [IDecl]
_bpexp :: IExp -> PExp

-- | expression with a unary function, e.g., -1 binary function, e.g., 2 +
--   3 ternary function, e.g., if x then 4 else 5
IFunExp :: String -> [PExp] -> IExp
_op :: IExp -> String
_exps :: IExp -> [PExp]

-- | integer number
IInt :: Integer -> IExp
_iint :: IExp -> Integer

-- | real number
IDouble :: Double -> IExp
_idouble :: IExp -> Double

-- | string
IStr :: String -> IExp
_istr :: IExp -> String

-- | a reference to a clafer name
IClaferId :: String -> CName -> Bool -> ClaferBinding -> IExp

-- | module name - currently not used and empty since we have no module
--   system
_modName :: IExp -> String

-- | name of the clafer being referred to
_sident :: IExp -> CName

-- | identifier refers to a top-level definition
_isTop :: IExp -> Bool

-- | the UID of the bound IClafer, if resolved
_binding :: IExp -> ClaferBinding

-- | For IFunExp standard set of operators includes: 1. Unary operators: !
--   - not (logical) # - set counting operator - - negation (arithmetic)
--   max - maximum (created for goals) min - minimum (created for goals) 2.
--   Binary operators: &lt;=&gt; - equivalence =&gt; - implication || -
--   disjunction xor - exclusive or &amp;&amp; - conjunction &lt; - less
--   than &gt; - greater than = - equality &lt;= - less than or equal &gt;=
--   - greater than or equal != - inequality in - belonging to a set/being
--   a subset nin - not belonging to a set/not being a subset + -
--   addition/string concatenation - - substraction * - multiplication / -
--   division ++ - set union -- - set difference ** - set intersection
--   &lt;: - domain restriction :&gt; - range restriction . - relational
--   join 3. Ternary operators ifthenelse -- if then else
--   
--   Local declaration disj x1; x2 : X ++ Y y1 : Y
data IDecl
IDecl :: Bool -> [CName] -> PExp -> IDecl

-- | is disjunct
_isDisj :: IDecl -> Bool

-- | a list of local names
_decls :: IDecl -> [CName]

-- | set to which local names refer to
_body :: IDecl -> PExp

-- | quantifier
data IQuant

-- | does not exist
INo :: IQuant

-- | less than one
ILone :: IQuant

-- | exactly one
IOne :: IQuant

-- | at least one (i.e., exists)
ISome :: IQuant

-- | for all
IAll :: IQuant
type LineNo = Integer
type ColNo = Integer

-- | map over IR
mapIR :: (Ir -> Ir) -> IModule -> IModule

-- | foldMap over IR
foldMapIR :: Monoid m => (Ir -> m) -> IModule -> m

-- | fold the IR
foldIR :: (Ir -> a -> a) -> a -> IModule -> a
iMap :: (Ir -> Ir) -> Ir -> Ir
iFoldMap :: Monoid m => (Ir -> m) -> Ir -> m
iFold :: (Ir -> a -> a) -> a -> Ir -> a
unWrapIModule :: Ir -> IModule
unWrapIElement :: Ir -> IElement
unWrapIType :: Ir -> IType
unWrapIClafer :: Ir -> IClafer
unWrapIExp :: Ir -> IExp
unWrapPExp :: Ir -> PExp
unWrapIReference :: Ir -> Maybe IReference
unWrapIQuant :: Ir -> IQuant
unWrapIDecl :: Ir -> IDecl
unWrapIGCard :: Ir -> Maybe IGCard
mName :: Lens' IModule String
mDecls :: Lens' IModule [IElement]
uid :: Lens' IClafer UID
super :: Lens' IClafer (Maybe PExp)
reference :: Lens' IClafer (Maybe IReference)
parentUID :: Lens' IClafer UID
isAbstract :: Lens' IClafer Bool
ident :: Lens' IClafer CName
glCard :: Lens' IClafer Interval
gcard :: Lens' IClafer (Maybe IGCard)
elements :: Lens' IClafer [IElement]
cinPos :: Lens' IClafer Span
card :: Lens' IClafer (Maybe Interval)
isMaximize :: Traversal' IElement Bool
isHard :: Traversal' IElement Bool
iClafer :: Traversal' IElement IClafer
cpexp :: Traversal' IElement PExp
ref :: Lens' IReference PExp
isSet :: Lens' IReference Bool
isKeyword :: Lens' IGCard Bool
interval :: Lens' IGCard Interval
pid :: Lens' PExp String
inPos :: Lens' PExp Span
iType :: Lens' PExp (Maybe IType)
exp :: Lens' PExp IExp
sident :: Traversal' IExp CName
quant :: Traversal' IExp IQuant
op :: Traversal' IExp String
oDecls :: Traversal' IExp [IDecl]
modName :: Traversal' IExp String
istr :: Traversal' IExp String
isTop :: Traversal' IExp Bool
iint :: Traversal' IExp Integer
idouble :: Traversal' IExp Double
exps :: Traversal' IExp [PExp]
bpexp :: Traversal' IExp PExp
binding :: Traversal' IExp ClaferBinding
isDisj :: Lens' IDecl Bool
decls :: Lens' IDecl [CName]
body :: Lens' IDecl PExp
instance ToJSON Pos
instance ToJSON Span
instance ToJSON IQuant
instance ToJSON IDecl
instance ToJSON IExp
instance ToJSON PExp
instance ToJSON IGCard
instance ToJSON IReference
instance ToJSON IElement
instance ToJSON IClafer
instance ToJSON IModule
instance ToJSON IType
instance Typeable IType
instance Typeable IGCard
instance Typeable IQuant
instance Typeable IExp
instance Typeable IDecl
instance Typeable PExp
instance Typeable IReference
instance Typeable IClafer
instance Typeable IElement
instance Typeable IModule
instance Eq IType
instance Ord IType
instance Show IType
instance Data IType
instance Eq IGCard
instance Ord IGCard
instance Show IGCard
instance Data IGCard
instance Eq IQuant
instance Ord IQuant
instance Show IQuant
instance Data IQuant
instance Eq IExp
instance Ord IExp
instance Show IExp
instance Data IExp
instance Eq IDecl
instance Ord IDecl
instance Show IDecl
instance Data IDecl
instance Eq PExp
instance Ord PExp
instance Show PExp
instance Data PExp
instance Eq IReference
instance Ord IReference
instance Show IReference
instance Data IReference
instance Eq IClafer
instance Ord IClafer
instance Show IClafer
instance Data IClafer
instance Eq IElement
instance Ord IElement
instance Show IElement
instance Data IElement
instance Eq IModule
instance Ord IModule
instance Show IModule
instance Data IModule
instance Eq Ir
instance Show Ir
instance Plated IExp
instance Plated PExp
instance Plated IClafer
instance Plated IModule

module Language.Clafer.Generator.Stats
data Stats
Stats :: Int -> Int -> Int -> Int -> Int -> Interval -> Stats
naClafers :: Stats -> Int
nrClafers :: Stats -> Int
ncClafers :: Stats -> Int
nConstraints :: Stats -> Int
nGoals :: Stats -> Int
sglCard :: Stats -> Interval
statsModule :: IModule -> Stats
statsClafer :: MonadState Stats m => IClafer -> m ()
statsCard :: Interval -> Interval -> Interval
statsElement :: MonadState Stats m => IElement -> m ()
instance Show Stats

module Language.Clafer.Intermediate.StringAnalyzer

-- | Convert all strings into ints for analysis | Return an inverse map
--   from ints back to strings
astrModule :: IModule -> (IModule, Map Int String)
astrClafer :: MonadState (Map String Int) m => IClafer -> m IClafer
astrElement :: MonadState (Map String Int) m => IElement -> m IElement
astrPExp :: MonadState (Map String Int) m => PExp -> m PExp
astrIExp :: MonadState (Map String Int) m => IExp -> m IExp


-- | Support for dealing with unique IDs (UIDs), fully- and least-partially
--   qualified names.
module Language.Clafer.QNameUID

-- | a fully- or partially-qualified name
type QName = String

-- | fully-qualified name, must begin with :: | e.g., `::Person::name`,
--   `::Company::Department::chair`
type FQName = String

-- | partially-qualified name, must not begin with :: | e.g.,
--   `Person::name`, <tt>chair</tt>
type PQName = String

-- | maps between fully-, least-partially-qualified names and UIDs
data QNameMaps

-- | unique identifier of a clafer
type UID = String

-- | derive maps between fully-, partially-qualified names, and UIDs
deriveQNameMaps :: IModule -> QNameMaps

-- | get the UID of a clafer given a fully qualifed name or potentially
--   many UIDs given a partially qualified name
getUIDs :: QNameMaps -> QName -> [UID]

-- | get the fully-qualified name of a clafer given its UID
getFQName :: QNameMaps -> UID -> Maybe FQName

-- | get the least-partially-qualified name of a clafer given its UID
getLPQName :: QNameMaps -> UID -> Maybe PQName
getQNameUIDTriples :: QNameMaps -> [(FQName, PQName, UID)]


-- | Creates JSON outputs for different kinds of metadata.
module Language.Clafer.JSONMetaData

-- | Generate a JSON list of triples containing a fully-qualified-,
--   least-partially-qualified name, and unique id. | Both the FQNames and
--   UIDs are brittle. LPQNames are the least brittle.
generateJSONnameUIDMap :: QNameMaps -> String

-- | Generate a JSON list of tuples containing a least-partially-qualified
--   name and a scope
generateJSONScopes :: QNameMaps -> [(UID, Integer)] -> String

-- | given the QNameMaps, parse the JSON scopes and return list of scopes
parseJSONScopes :: QNameMaps -> String -> [(UID, Integer)]

-- | Write a .cfr-scope file
writeCfrScopeFile :: [(UID, Integer)] -> QNameMaps -> FilePath -> IO ()

-- | Read a .cfr-scope file
readCfrScopeFile :: QNameMaps -> FilePath -> IO (Maybe [(UID, Integer)])

module Language.Clafer.Intermediate.Tracing
traceIrModule :: IModule -> Map Span [Ir]
traceAstModule :: Module -> Map Span [Ast]
data Ast
AstModule :: Module -> Ast
AstDeclaration :: Declaration -> Ast
AstClafer :: Clafer -> Ast
AstConstraint :: Constraint -> Ast
AstSoftConstraint :: SoftConstraint -> Ast
AstGoal :: Goal -> Ast
AstAbstract :: Abstract -> Ast
AstElements :: Elements -> Ast
AstElement :: Element -> Ast
AstSuper :: Super -> Ast
AstReference :: Reference -> Ast
AstInit :: Init -> Ast
AstInitHow :: InitHow -> Ast
AstGCard :: GCard -> Ast
AstCard :: Card -> Ast
AstNCard :: NCard -> Ast
AstExInteger :: ExInteger -> Ast
AstName :: Name -> Ast
AstExp :: Exp -> Ast
AstSetExp :: SetExp -> Ast
AstDecl :: Decl -> Ast
AstQuant :: Quant -> Ast
AstEnumId :: EnumId -> Ast
AstModId :: ModId -> Ast
AstLocId :: LocId -> Ast
instance Eq Ast
instance Show Ast

module Language.Clafer.Css
header :: String
css :: String

module Language.Clafer.Common
type Result = String
transIdent :: PosIdent -> String
mkIdent :: String -> PosIdent
mkInteger :: Read a => PosInteger -> a
type Ident = PosIdent

-- | Returns only [] or [_]
getSuper :: IClafer -> [String]

-- | Returns only [] or [_]
getReference :: IClafer -> [String]

-- | Returns only [] or [_] or [_, _]
getSuperAndReference :: IClafer -> [String]
getSuperId :: PExp -> String
isEqClaferId :: String -> IClafer -> Bool
mkPLClaferId :: CName -> Bool -> ClaferBinding -> PExp
pExpDefPidPos :: IExp -> PExp
pExpDefPid :: Span -> IExp -> PExp
pExpDef :: String -> Span -> IExp -> PExp
isParent :: PExp -> Bool
isClaferName :: PExp -> Bool
isClaferName' :: PExp -> Bool
getClaferName :: PExp -> String
isTopLevel :: IClafer -> Bool
elemToClafer :: IElement -> Maybe IClafer
toClafers :: [IElement] -> [IClafer]
type UIDIClaferMap = StringMap IClafer
createUidIClaferMap :: IModule -> UIDIClaferMap
findIClafer :: UIDIClaferMap -> UID -> Maybe IClafer

-- | Finds all super clafers according to sFun
findHierarchy :: (IClafer -> [String]) -> UIDIClaferMap -> IClafer -> [IClafer]

-- | Finds hierarchy and transforms each element
mapHierarchy :: (IClafer -> b) -> (IClafer -> [String]) -> UIDIClaferMap -> IClafer -> [b]

-- | traverse the inheritance hierarchy upwards to find a clafer with the
--   given uidToFind
findUIDinSupers :: UIDIClaferMap -> UID -> IClafer -> Maybe IClafer

-- | traverse the containment hierarchy upwards to find a clafer with the
--   given uidToFind
findUIDinParents :: UIDIClaferMap -> UID -> IClafer -> Maybe IClafer
data NestedInheritanceMatch
NestedInheritanceMatch :: IClafer -> IClafer -> Maybe IClafer -> Maybe IClafer -> Maybe IClafer -> IClafer -> IClafer -> Maybe IClafer -> NestedInheritanceMatch

-- | the clafer for which the match is computed
_headClafer :: NestedInheritanceMatch -> IClafer

-- | parent of the head clafer
_parentClafer :: NestedInheritanceMatch -> IClafer

-- | parent of the super of the head clafer
_parentsSuperClafer :: NestedInheritanceMatch -> Maybe IClafer

-- | target of the head clafer
_targetClafer :: NestedInheritanceMatch -> Maybe IClafer

-- | super of the target of the head clafer
_targetsSuperClafer :: NestedInheritanceMatch -> Maybe IClafer

-- | super of the head clafer (must exist, otherwise no match)
_superClafer :: NestedInheritanceMatch -> IClafer

-- | parent of the super of the head clafer
_superClafersParent :: NestedInheritanceMatch -> IClafer

-- | target of the super of the head clafer
_superClafersTarget :: NestedInheritanceMatch -> Maybe IClafer

-- | assumes that isProperNesting m == True
--   
--   This represents a match of this shape
--   
--   superClafersParent / &lt;&gt; ?1| * parentsSuperClafer / [=]
--   superClafer --*-&gt; superClafersTarget *| <i> </i> parentClafer | |?2
--   &lt;&gt; *| [=] targetsSuperClafer * | / | *| headClafer
--   -----*-----&gt; targetClafer
--   
--   The clafers are obtained by navigating from the headClafer by
--   following the links marked by * The link marked by ?1 is checked for
--   correctness of nesting (isProperNesting): - _uid parentsSuperClafer ==
--   _parentUID superClafer The link marked by ?2 is checked for
--   correctness of redefinition (isProperRefinement): - proper subtyping,
--   bag to set, proper cardinality restriction Redefinition occurs when
--   the name of headClafer is the same as the name of superClafer
--   (isProperRedefinition): - isProperNesting &amp;&amp;
--   isProperRefinement &amp;&amp; (_ident headClafer) == (_ident
--   superClafer)
isProperNesting :: UIDIClaferMap -> Maybe NestedInheritanceMatch -> Bool

-- | assumes that isProperNesting m == True and isProperRefinement m ==
--   (True, True, True)
isProperRefinement :: UIDIClaferMap -> Maybe NestedInheritanceMatch -> (Bool, Bool, Bool)

-- | try to match the nested inheritance pattern ^ only available after the
--   parentUIDs were computed
isRedefinition :: Maybe NestedInheritanceMatch -> Bool
matchNestedInheritance :: UIDIClaferMap -> IClafer -> Maybe NestedInheritanceMatch
apply :: (t -> t1) -> t -> (t, t1)
bfs :: (b1 -> (b, [b1])) -> [b1] -> [b]
toNodeShallow :: IClafer -> (IClafer, [IClafer])
getSubclafers :: [IElement] -> [IClafer]
bfsClafers :: [IClafer] -> [IClafer]
lurry :: ([t1] -> t) -> t1 -> t1 -> t
fst3 :: (t, t1, t2) -> t
snd3 :: (t, t1, t2) -> t1
trd3 :: (t, t1, t2) -> t2
toTriple :: t -> (t1, t2) -> (t, t1, t2)
toMTriple :: t -> (t1, t2) -> Maybe (t, t1, t2)
iNot :: String
iCSet :: String
iMin :: String
iGMax :: String
iGMin :: String
iSumSet :: String
iProdSet :: String
unOps :: [String]
iIff :: String
iImpl :: String
iOr :: String
iXor :: String
iAnd :: String
logBinOps :: [String]
iLt :: String
iGt :: String
iEq :: String
iLte :: String
iGte :: String
iNeq :: String
iIn :: String
iNin :: String
relGenBinOps :: [String]
relSetBinOps :: [String]
relBinOps :: [String]
iPlus :: String
iSub :: String
iMul :: String
iDiv :: String
iRem :: String
iSumSet' :: String
arithBinOps :: [String]
iUnion :: String
iDifference :: String
iIntersection :: String
iDomain :: String
iRange :: String
iJoin :: String
setBinOps :: [String]
binOps :: [String]
iIfThenElse :: String
mkIFunExp :: String -> [IExp] -> IExp
toLowerS :: String -> String
rootIdent :: String
rootUID :: String
thisIdent :: String
parentIdent :: String
refIdent :: String
childrenIdent :: String
specialNames :: [String]
isSpecial :: String -> Bool
stringType :: String
intType :: String
integerType :: String
realType :: String
booleanType :: String
baseClafer :: String
modSep :: String
primitiveTypes :: [String]
isPrimitive :: String -> Bool

-- | reserved keywords which cannot be used as clafer identifiers
keywordIdents :: [String]
data GEnv
GEnv :: Map String Int -> Int -> Map UID [[UID]] -> [IClafer] -> UIDIClaferMap -> GEnv
identCountMap :: GEnv -> Map String Int
expCount :: GEnv -> Int
stable :: GEnv -> Map UID [[UID]]
sClafers :: GEnv -> [IClafer]
uidClaferMap :: GEnv -> UIDIClaferMap
voidf :: Monad m => m t -> m ()
safeTail :: [a] -> [a]
instance Show NestedInheritanceMatch
instance Eq GEnv
instance Show GEnv


-- | Generates JS representation of IR for the <a>Chocosolver</a>.
module Language.Clafer.Generator.Choco

-- | Choco 3 code generation
genCModule :: (IModule, GEnv) -> [(UID, Integer)] -> Result

module Language.Clafer.Generator.Concat

-- | representation of strings in chunks (for line/column numbering)
data Concat
CString :: String -> Concat
Concat :: IrTrace -> [Concat] -> Concat
srcPos :: Concat -> IrTrace
nodes :: Concat -> [Concat]
type Position = ((LineNo, ColNo), (LineNo, ColNo))
data IrTrace
IrPExp :: String -> IrTrace
pUid :: IrTrace -> String
LowerCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
UpperCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
ExactCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
NoTrace :: IrTrace
mkConcat :: IrTrace -> String -> Concat
mapToCStr :: [String] -> [Concat]
iscPrimitive :: Concat -> Bool
flatten :: Concat -> String
(+++) :: Concat -> Concat -> Concat
cconcat :: [Concat] -> Concat
cintercalate :: Concat -> [Concat] -> Concat
filterNull :: [Concat] -> [Concat]
isNull :: Concat -> Bool
cunlines :: [Concat] -> Concat
instance Eq IrTrace
instance Show IrTrace
instance Eq Concat
instance Show Concat


-- | Generates JS representation of IR for the <a>Chocosolver</a>.
module Language.Clafer.Generator.Python

-- | Choco 3 code generation
genPythonModule :: (IModule, GEnv) -> [(UID, Integer)] -> Result


-- | Generates a XML representation of IR conforming to the ClaferIR.xsd.
module Language.Clafer.Generator.Xml
tag :: String -> String -> String
optTag :: Maybe a -> (a -> String) -> String
tagType :: String -> String -> String -> String
genXmlInteger :: Integer -> String
genXmlBoolean :: String -> Bool -> String
genXmlString :: String -> String
genXmlIntPair :: (Integer, Integer) -> String

-- | Generate an XML representation of the IR
genXmlModule :: IModule -> Result
genXmlClafer :: IClafer -> Result
genXmlAbstract :: Bool -> String
genXmlGCard :: IGCard -> String
genXmlInterval :: (Integer, Integer) -> String
genXmlId :: String -> String
genXmlUid :: String -> String
genXmlParentUid :: String -> String
genXmlSuper :: Maybe PExp -> String
genXmlReference :: Maybe IReference -> String
genXmlCard :: (Integer, Integer) -> String
genXmlGlCard :: (Integer, Integer) -> String
genXmlElement :: IElement -> String
genXmlAnyOp :: (a -> String) -> (a -> String) -> [(String, a)] -> String
genXmlPExp :: String -> PExp -> String
genXmlPosition :: Span -> String
genXmlIExpType :: IExp -> String
genXmlIExp :: IExp -> String
genXmlDecl :: IDecl -> String
genXmlQuantType :: IQuant -> String
genXmlITypeType :: IType -> String
genXmlIType :: IType -> String


-- | Transforms an Abstract Syntax Tree (AST) from
--   <a>Language.Clafer.Front.AbsClafer</a> into Intermediate
--   representation (IR) from <a>Language.Clafer.Intermediate.Intclafer</a>
--   of a Clafer model.
module Language.Clafer.Intermediate.Desugarer

-- | Transform the AST into the intermediate representation (IR)
desugarModule :: Maybe String -> Module -> IModule
sugarModule :: IModule -> Module

-- | desugars enumeration to abstract and global singleton features
desugarEnums :: Declaration -> [Declaration]
desugarDeclaration :: Declaration -> [IElement]
sugarDeclaration :: IElement -> Declaration
desugarClafer :: Clafer -> [IElement]
getPExpClaferIdent :: SetExp -> String
sugarClafer :: IClafer -> Clafer
desugarSuper :: Super -> Maybe PExp
desugarReference :: Reference -> Maybe IReference
desugarInit :: PosIdent -> Init -> [IElement]
desugarInitHow :: InitHow -> Bool
desugarName :: Name -> IExp
desugarModId :: ModId -> Result
sugarModId :: String -> ModId
sugarSuper :: Maybe PExp -> Super
sugarReference :: Maybe IReference -> Reference
sugarInitHow :: Bool -> InitHow
desugarConstraint :: Constraint -> PExp
desugarSoftConstraint :: SoftConstraint -> PExp
desugarGoal :: Goal -> PExp
sugarConstraint :: PExp -> Constraint
sugarSoftConstraint :: PExp -> SoftConstraint
sugarGoal :: PExp -> Goal
desugarAbstract :: Abstract -> Bool
sugarAbstract :: Bool -> Abstract
desugarElements :: Elements -> [IElement]
sugarElements :: [IElement] -> Elements
desugarElement :: Element -> [IElement]
sugarElement :: IElement -> Element
desugarGCard :: GCard -> Maybe IGCard
isOptionalDef :: NCard -> Bool
isExIntegerAst :: ExInteger -> Bool
sugarGCard :: Maybe IGCard -> GCard
desugarCard :: Card -> Maybe Interval
desugarNCard :: NCard -> (Integer, Integer)
desugarExInteger :: ExInteger -> Integer
sugarCard :: Maybe Interval -> Card
sugarExInteger :: Integer -> ExInteger
desugarExp :: Exp -> PExp
desugarExp' :: Exp -> IExp
desugarOp :: (a -> PExp) -> String -> [a] -> IExp
desugarSetExp :: SetExp -> PExp
desugarSetExp' :: SetExp -> IExp
sugarExp :: PExp -> Exp
sugarExp' :: IExp -> Exp
sugarSetExp :: PExp -> SetExp
sugarSetExp' :: IExp -> SetExp
desugarPath :: PExp -> PExp
isSetExp :: IExp -> Bool
reducePExp :: PExp -> PExp
reduceIExp :: IExp -> IExp
reduceNav :: IExp -> IExp
desugarDecl :: Bool -> Decl -> IDecl
sugarDecl :: IDecl -> Decl
desugarLocId :: LocId -> String
sugarLocId :: String -> LocId
desugarQuant :: Quant -> IQuant
sugarQuant :: IQuant -> Quant

module Language.Clafer.Intermediate.Transformer
transModule :: IModule -> IModule
transElement :: IElement -> IElement
transClafer :: IClafer -> IClafer
transPExp :: Bool -> PExp -> PExp
transIExp :: IType -> IExp -> IExp

module Language.Clafer.Intermediate.SimpleScopeAnalyzer

-- | Collects the global cardinality and hierarchy information into proper,
--   not necessarily lower, bounds.
simpleScopeAnalysis :: IModule -> [(String, Integer)]

module Language.Clafer.Comments
getOptions :: InputModel -> String
getFragments :: InputModel -> [Int]
getStats :: InputModel -> [Int]
getGraph :: InputModel -> [Int]
getComments :: InputModel -> [(Span, String)]

module Language.Clafer.Front.ErrM
data Err a
Ok :: a -> Err a
Bad :: Pos -> String -> Err a
instance Read a => Read (Err a)
instance Show a => Show (Err a)
instance Eq a => Eq (Err a)
instance Ord a => Ord (Err a)
instance Alternative Err
instance MonadPlus Err
instance Functor Err
instance Applicative Err
instance Monad Err

module Language.Clafer.Front.ParClafer
newtype HappyAbsSyn
HappyAbsSyn :: HappyAny -> HappyAbsSyn
type HappyAny = Any
happyIn8 :: (PosInteger) -> (HappyAbsSyn)
happyOut8 :: (HappyAbsSyn) -> (PosInteger)
happyIn9 :: (PosDouble) -> (HappyAbsSyn)
happyOut9 :: (HappyAbsSyn) -> (PosDouble)
happyIn10 :: (PosString) -> (HappyAbsSyn)
happyOut10 :: (HappyAbsSyn) -> (PosString)
happyIn11 :: (PosIdent) -> (HappyAbsSyn)
happyOut11 :: (HappyAbsSyn) -> (PosIdent)
happyIn12 :: (Module) -> (HappyAbsSyn)
happyOut12 :: (HappyAbsSyn) -> (Module)
happyIn13 :: (Declaration) -> (HappyAbsSyn)
happyOut13 :: (HappyAbsSyn) -> (Declaration)
happyIn14 :: (Clafer) -> (HappyAbsSyn)
happyOut14 :: (HappyAbsSyn) -> (Clafer)
happyIn15 :: (Constraint) -> (HappyAbsSyn)
happyOut15 :: (HappyAbsSyn) -> (Constraint)
happyIn16 :: (SoftConstraint) -> (HappyAbsSyn)
happyOut16 :: (HappyAbsSyn) -> (SoftConstraint)
happyIn17 :: (Goal) -> (HappyAbsSyn)
happyOut17 :: (HappyAbsSyn) -> (Goal)
happyIn18 :: (Abstract) -> (HappyAbsSyn)
happyOut18 :: (HappyAbsSyn) -> (Abstract)
happyIn19 :: (Elements) -> (HappyAbsSyn)
happyOut19 :: (HappyAbsSyn) -> (Elements)
happyIn20 :: (Element) -> (HappyAbsSyn)
happyOut20 :: (HappyAbsSyn) -> (Element)
happyIn21 :: (Super) -> (HappyAbsSyn)
happyOut21 :: (HappyAbsSyn) -> (Super)
happyIn22 :: (Reference) -> (HappyAbsSyn)
happyOut22 :: (HappyAbsSyn) -> (Reference)
happyIn23 :: (Init) -> (HappyAbsSyn)
happyOut23 :: (HappyAbsSyn) -> (Init)
happyIn24 :: (InitHow) -> (HappyAbsSyn)
happyOut24 :: (HappyAbsSyn) -> (InitHow)
happyIn25 :: (GCard) -> (HappyAbsSyn)
happyOut25 :: (HappyAbsSyn) -> (GCard)
happyIn26 :: (Card) -> (HappyAbsSyn)
happyOut26 :: (HappyAbsSyn) -> (Card)
happyIn27 :: (NCard) -> (HappyAbsSyn)
happyOut27 :: (HappyAbsSyn) -> (NCard)
happyIn28 :: (ExInteger) -> (HappyAbsSyn)
happyOut28 :: (HappyAbsSyn) -> (ExInteger)
happyIn29 :: (Name) -> (HappyAbsSyn)
happyOut29 :: (HappyAbsSyn) -> (Name)
happyIn30 :: (Exp) -> (HappyAbsSyn)
happyOut30 :: (HappyAbsSyn) -> (Exp)
happyIn31 :: (Exp) -> (HappyAbsSyn)
happyOut31 :: (HappyAbsSyn) -> (Exp)
happyIn32 :: (Exp) -> (HappyAbsSyn)
happyOut32 :: (HappyAbsSyn) -> (Exp)
happyIn33 :: (Exp) -> (HappyAbsSyn)
happyOut33 :: (HappyAbsSyn) -> (Exp)
happyIn34 :: (Exp) -> (HappyAbsSyn)
happyOut34 :: (HappyAbsSyn) -> (Exp)
happyIn35 :: (Exp) -> (HappyAbsSyn)
happyOut35 :: (HappyAbsSyn) -> (Exp)
happyIn36 :: (Exp) -> (HappyAbsSyn)
happyOut36 :: (HappyAbsSyn) -> (Exp)
happyIn37 :: (Exp) -> (HappyAbsSyn)
happyOut37 :: (HappyAbsSyn) -> (Exp)
happyIn38 :: (Exp) -> (HappyAbsSyn)
happyOut38 :: (HappyAbsSyn) -> (Exp)
happyIn39 :: (Exp) -> (HappyAbsSyn)
happyOut39 :: (HappyAbsSyn) -> (Exp)
happyIn40 :: (Exp) -> (HappyAbsSyn)
happyOut40 :: (HappyAbsSyn) -> (Exp)
happyIn41 :: (Exp) -> (HappyAbsSyn)
happyOut41 :: (HappyAbsSyn) -> (Exp)
happyIn42 :: (Exp) -> (HappyAbsSyn)
happyOut42 :: (HappyAbsSyn) -> (Exp)
happyIn43 :: (Exp) -> (HappyAbsSyn)
happyOut43 :: (HappyAbsSyn) -> (Exp)
happyIn44 :: (SetExp) -> (HappyAbsSyn)
happyOut44 :: (HappyAbsSyn) -> (SetExp)
happyIn45 :: (SetExp) -> (HappyAbsSyn)
happyOut45 :: (HappyAbsSyn) -> (SetExp)
happyIn46 :: (SetExp) -> (HappyAbsSyn)
happyOut46 :: (HappyAbsSyn) -> (SetExp)
happyIn47 :: (SetExp) -> (HappyAbsSyn)
happyOut47 :: (HappyAbsSyn) -> (SetExp)
happyIn48 :: (SetExp) -> (HappyAbsSyn)
happyOut48 :: (HappyAbsSyn) -> (SetExp)
happyIn49 :: (SetExp) -> (HappyAbsSyn)
happyOut49 :: (HappyAbsSyn) -> (SetExp)
happyIn50 :: (SetExp) -> (HappyAbsSyn)
happyOut50 :: (HappyAbsSyn) -> (SetExp)
happyIn51 :: (Decl) -> (HappyAbsSyn)
happyOut51 :: (HappyAbsSyn) -> (Decl)
happyIn52 :: (Quant) -> (HappyAbsSyn)
happyOut52 :: (HappyAbsSyn) -> (Quant)
happyIn53 :: (EnumId) -> (HappyAbsSyn)
happyOut53 :: (HappyAbsSyn) -> (EnumId)
happyIn54 :: (ModId) -> (HappyAbsSyn)
happyOut54 :: (HappyAbsSyn) -> (ModId)
happyIn55 :: (LocId) -> (HappyAbsSyn)
happyOut55 :: (HappyAbsSyn) -> (LocId)
happyIn56 :: ([Declaration]) -> (HappyAbsSyn)
happyOut56 :: (HappyAbsSyn) -> ([Declaration])
happyIn57 :: ([EnumId]) -> (HappyAbsSyn)
happyOut57 :: (HappyAbsSyn) -> ([EnumId])
happyIn58 :: ([Element]) -> (HappyAbsSyn)
happyOut58 :: (HappyAbsSyn) -> ([Element])
happyIn59 :: ([Exp]) -> (HappyAbsSyn)
happyOut59 :: (HappyAbsSyn) -> ([Exp])
happyIn60 :: ([LocId]) -> (HappyAbsSyn)
happyOut60 :: (HappyAbsSyn) -> ([LocId])
happyIn61 :: ([ModId]) -> (HappyAbsSyn)
happyOut61 :: (HappyAbsSyn) -> ([ModId])
happyInTok :: (Token) -> (HappyAbsSyn)
happyOutTok :: (HappyAbsSyn) -> (Token)
happyActOffsets :: HappyAddr
happyGotoOffsets :: HappyAddr
happyDefActions :: HappyAddr
happyCheck :: HappyAddr
happyTable :: HappyAddr
happyReduceArr :: Array Int (Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn)
happy_n_terms :: Int
happy_n_nonterms :: Int
happyReduce_5 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_5 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_6 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_6 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_7 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_7 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_8 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_8 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_9 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_9 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_10 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_10 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_11 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_11 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_12 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_12 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_13 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_13 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_14 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_14 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_15 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_15 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_16 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_16 :: HappyAbsSyn
happyReduce_17 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_17 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_18 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_18 :: HappyAbsSyn
happyReduce_19 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_19 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_20 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_20 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_21 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_21 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_22 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_22 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_23 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_23 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_24 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_24 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_25 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_25 :: HappyAbsSyn
happyReduce_26 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_26 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_27 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_27 :: HappyAbsSyn
happyReduce_28 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_28 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_29 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_29 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_30 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_30 :: HappyAbsSyn
happyReduce_31 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_31 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_32 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_32 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_33 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_33 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_34 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_34 :: HappyAbsSyn
happyReduce_35 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_35 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_36 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_36 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_37 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_37 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_38 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_38 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_39 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_39 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_40 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_40 :: HappyAbsSyn
happyReduce_41 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_41 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_42 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_42 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_43 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_43 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_44 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_44 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_45 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_45 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_46 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_46 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_47 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_47 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_48 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_48 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_49 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_49 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_50 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_50 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_51 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_51 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_52 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_52 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_53 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_53 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_54 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_54 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_55 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_55 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_56 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_56 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_57 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_57 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_58 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_58 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_59 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_59 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_60 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_60 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_61 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_61 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_62 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_62 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_63 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_63 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_64 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_64 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_65 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_65 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_66 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_66 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_67 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_67 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_68 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_68 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_69 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_69 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_70 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_70 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_71 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_71 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_72 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_72 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_73 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_73 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_74 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_74 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_75 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_75 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_76 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_76 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_77 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_77 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_78 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_78 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_79 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_79 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_80 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_80 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_81 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_81 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_82 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_82 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_83 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_83 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_84 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_84 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_85 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_85 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_86 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_86 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_87 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_87 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_88 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_88 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_89 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_89 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_90 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_90 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_91 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_91 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_92 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_92 :: HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn
happyReduce_93 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_93 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_94 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_94 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_95 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_95 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_96 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_96 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_97 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_97 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_98 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_98 :: t -> HappyAbsSyn -> t1 -> HappyAbsSyn
happyReduce_99 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_99 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_100 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_100 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_101 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_101 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_102 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_102 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_103 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_103 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_104 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_104 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_105 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_105 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_106 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_106 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_107 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_107 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_108 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_108 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_109 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_109 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_110 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_110 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_111 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_111 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_112 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_112 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_113 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_113 :: t -> HappyAbsSyn -> t1 -> HappyAbsSyn
happyReduce_114 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_114 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_115 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_115 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_116 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_116 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_117 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_117 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_118 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_118 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_119 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_119 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_120 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_120 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_121 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_121 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_122 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_122 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_123 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_123 :: HappyAbsSyn
happyReduce_124 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_124 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_125 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_125 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_126 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_126 :: HappyAbsSyn -> t -> HappyAbsSyn -> HappyAbsSyn
happyReduce_127 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_127 :: HappyAbsSyn
happyReduce_128 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_128 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_129 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_129 :: HappyAbsSyn
happyReduce_130 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_130 :: HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn
happyReduce_131 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_131 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_132 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_132 :: HappyAbsSyn -> t -> HappyAbsSyn -> HappyAbsSyn
happyReduce_133 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_133 :: HappyAbsSyn -> HappyAbsSyn
happyReduce_134 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduction_134 :: HappyAbsSyn -> t -> HappyAbsSyn -> HappyAbsSyn
happyNewToken :: Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyError_ :: Int# -> Token -> [Token] -> Err a
happyThen :: Err a -> (a -> Err b) -> Err b
happyReturn :: a -> Err a
happyThen1 :: Err a -> (a -> t -> Err b) -> t -> Err b
happyReturn1 :: a -> b -> Err a
happyError' :: [(Token)] -> Err a
pModule :: [Token] -> Err Module
pClafer :: [Token] -> Err Clafer
pConstraint :: [Token] -> Err Constraint
pSoftConstraint :: [Token] -> Err SoftConstraint
pGoal :: [Token] -> Err Goal
happySeq :: a -> b -> b
returnM :: a -> Err a
thenM :: Err a -> (a -> Err b) -> Err b
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
gp :: Token -> Span
pp :: [Token] -> Pos
mkCatSpan :: Spannable c => c -> Span
mkTokenSpan :: Token -> Span
data Happy_IntList
HappyCons :: Int# -> Happy_IntList -> Happy_IntList
data HappyStk a
HappyStk :: a -> (HappyStk a) -> HappyStk a
happyParse :: Int# -> [Token] -> Err HappyAbsSyn
happyAccept :: Int# -> t -> Int# -> t1 -> HappyStk a -> b -> Err a
happyDoAction :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
indexShortOffAddr :: HappyAddr -> Int# -> Int#
data HappyAddr
HappyA# :: Addr# -> HappyAddr
happyShift :: Int# -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happySpecReduce_0 :: Int# -> HappyAbsSyn -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happySpecReduce_1 :: Int# -> (HappyAbsSyn -> HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happySpecReduce_2 :: Int# -> (HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happySpecReduce_3 :: Int# -> (HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn -> HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyReduce :: Int# -> Int# -> (HappyStk HappyAbsSyn -> HappyStk HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyMonadReduce :: Int# -> Int# -> (HappyStk HappyAbsSyn -> Token -> Err HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyMonad2Reduce :: Int# -> Int# -> (HappyStk HappyAbsSyn -> Token -> Err HappyAbsSyn) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyDrop :: Int# -> Happy_IntList -> Happy_IntList
happyDropStk :: Int# -> HappyStk t -> HappyStk t
happyGoto :: Int# -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
happyFail :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk HappyAbsSyn -> [Token] -> Err HappyAbsSyn
notHappyAtAll :: a
happyTcHack :: Int# -> a -> a
happyDoSeq :: a -> b -> b
happyDontSeq :: a -> b -> b


-- | Command Line Arguments of the compiler.
--   
--   See also <a>a model of the arguments in Clafer</a>, including
--   constraints and examples.
module Language.Clafer.ClaferArgs

-- | Type of output to be generated at the end of compilation
data ClaferMode
Alloy42 :: ClaferMode
Alloy :: ClaferMode
Xml :: ClaferMode
JSON :: ClaferMode
Clafer :: ClaferMode
Html :: ClaferMode
Graph :: ClaferMode
CVLGraph :: ClaferMode
Python :: ClaferMode
Choco :: ClaferMode

-- | Scope inference strategy
data ScopeStrategy
None :: ScopeStrategy
Simple :: ScopeStrategy
data ClaferArgs
ClaferArgs :: [ClaferMode] -> Bool -> Bool -> Int -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ScopeStrategy -> Bool -> Bool -> Bool -> FilePath -> ClaferArgs
mode :: ClaferArgs -> [ClaferMode]
console_output :: ClaferArgs -> Bool
flatten_inheritance :: ClaferArgs -> Bool
timeout_analysis :: ClaferArgs -> Int
no_layout :: ClaferArgs -> Bool
new_layout :: ClaferArgs -> Bool
check_duplicates :: ClaferArgs -> Bool
skip_resolver :: ClaferArgs -> Bool
keep_unused :: ClaferArgs -> Bool
no_stats :: ClaferArgs -> Bool
schema :: ClaferArgs -> Bool
validate :: ClaferArgs -> Bool
noalloyruncommand :: ClaferArgs -> Bool
tooldir :: ClaferArgs -> FilePath
alloy_mapping :: ClaferArgs -> Bool
self_contained :: ClaferArgs -> Bool
add_graph :: ClaferArgs -> Bool
show_references :: ClaferArgs -> Bool
add_comments :: ClaferArgs -> Bool
ecore2clafer :: ClaferArgs -> Bool
scope_strategy :: ClaferArgs -> ScopeStrategy
afm :: ClaferArgs -> Bool
skip_goals :: ClaferArgs -> Bool
meta_data :: ClaferArgs -> Bool
file :: ClaferArgs -> FilePath
clafer :: ClaferArgs
mergeArgs :: ClaferArgs -> ClaferArgs -> ClaferArgs
mainArgs :: IO (ClaferArgs, String)
retrieveModelFromURL :: String -> IO String
argsWithOPTIONS :: ClaferArgs -> String -> ClaferArgs
defaultClaferArgs :: ClaferArgs
instance Typeable ClaferMode
instance Typeable ScopeStrategy
instance Typeable ClaferArgs
instance Eq ClaferMode
instance Show ClaferMode
instance Ord ClaferMode
instance Data ClaferMode
instance Eq ScopeStrategy
instance Show ScopeStrategy
instance Data ScopeStrategy
instance Show ClaferArgs
instance Data ClaferArgs
instance Default ScopeStrategy
instance Default ClaferMode


-- | Generates Alloy4.1 or 4.2 code for a Clafer model
module Language.Clafer.Generator.Alloy

-- | Alloy code generation 07th Mayo 2012 Rafael Olaechea Added Logic to
--   print a goal block in case there is at least one goal.
genModule :: ClaferArgs -> (IModule, GEnv) -> [(UID, Integer)] -> (Result, [(Span, IrTrace)])
instance Show GenEnv
instance Eq AlloyEnv
instance Show AlloyEnv

module Language.Clafer.Intermediate.ScopeAnalysis

-- | Return an appropriate scope analysis for a given strategy
getScopeStrategy :: ScopeStrategy -> IModule -> [(String, Integer)]


-- | This is in a separate module from the module <a>Language.Clafer</a> so
--   that other modules that require ClaferEnv can just import this module
--   without all the parsing<i>compiline</i>generating functionality.
module Language.ClaferT
data ClaferEnv
ClaferEnv :: ClaferArgs -> [String] -> Maybe Module -> Maybe (IModule, GEnv, Bool) -> [Pos] -> Map Span [Ast] -> ClaferEnv
args :: ClaferEnv -> ClaferArgs
modelFrags :: ClaferEnv -> [String]
cAst :: ClaferEnv -> Maybe Module
cIr :: ClaferEnv -> Maybe (IModule, GEnv, Bool)
frags :: ClaferEnv -> [Pos]
astModuleTrace :: ClaferEnv -> Map Span [Ast]

-- | This simulates a field in the ClaferEnv that will always recompute the
--   map, since the IR always changes and the map becomes obsolete
irModuleTrace :: ClaferEnv -> Map Span [Ir]

-- | This simulates a field in the ClaferEnv that will always recompute the
--   map, since the IR always changes and the map becomes obsolete maps
--   from a UID to an IClafer with the given UID
uidIClaferMap :: ClaferEnv -> UIDIClaferMap
makeEnv :: ClaferArgs -> ClaferEnv
getAst :: Monad m => ClaferT m Module
getIr :: Monad m => ClaferT m (IModule, GEnv, Bool)

-- | Monad for using Clafer.
type ClaferM = ClaferT Identity

-- | Monad Transformer for using Clafer.
type ClaferT m = ExceptT ClaferErrs (StateT ClaferEnv m)

-- | Possible errors that can occur when using Clafer | Generate errors
--   using throwErr/throwErrs:
data CErr p

-- | Generic error
ClaferErr :: String -> CErr p
msg :: CErr p -> String

-- | Error generated by the parser
ParseErr :: p -> String -> CErr p

-- | Position of the error
pos :: CErr p -> p
msg :: CErr p -> String

-- | Error generated by semantic analysis
SemanticErr :: p -> String -> CErr p

-- | Position of the error
pos :: CErr p -> p
msg :: CErr p -> String

-- | Clafer keeps track of multiple errors.
data CErrs p
ClaferErrs :: [CErr p] -> CErrs p
errs :: CErrs p -> [CErr p]
type ClaferErr = CErr ErrPos
type ClaferErrs = CErrs ErrPos
type ClaferSErr = CErr Span
type ClaferSErrs = CErrs Span
data ErrPos
ErrPos :: Int -> Pos -> Pos -> ErrPos

-- | The fragment where the error occurred.
fragId :: ErrPos -> Int

-- | Error positions are relative to their fragments. | For example an
--   error at (Pos 2 3) means line 2 column 3 of the fragment, not the
--   entire model.
fragPos :: ErrPos -> Pos

-- | The error position relative to the model.
modelPos :: ErrPos -> Pos

-- | The full ErrPos requires lots of information that needs to be
--   consistent. Every time we throw an error, | we need BOTH the (fragId,
--   fragPos) AND modelPos. This makes it easier for developers using
--   ClaferT so they | only need to provide part of the information and the
--   rest is automatically calculated. The code using | ClaferT is more
--   concise and less error-prone. | | modelPos &lt;- modelPosFromFragPos
--   fragdId fragPos | throwErr $ ParserErr (ErrPos fragId fragPos
--   modelPos) | | vs | | throwErr $ ParseErr (ErrFragPos fragId fragPos) |
--   | Hopefully making the error handling easier will make it more
--   universal.
data PartialErrPos

-- | Position relative to the start of the fragment. Will calculate model
--   position automatically. | fragId starts at 0 | The position is
--   relative to the start of the fragment.
ErrFragPos :: Int -> Pos -> PartialErrPos
pFragId :: PartialErrPos -> Int
pFragPos :: PartialErrPos -> Pos
ErrFragSpan :: Int -> Span -> PartialErrPos
pFragId :: PartialErrPos -> Int
pFragSpan :: PartialErrPos -> Span

-- | Position relative to the start of the complete model. Will calculate
--   fragId and fragPos automatically. | The position is relative to the
--   entire complete model.
ErrModelPos :: Pos -> PartialErrPos
pModelPos :: PartialErrPos -> Pos
ErrModelSpan :: Span -> PartialErrPos
pModelSpan :: PartialErrPos -> Span

-- | Throw many errors.
throwErrs :: (Monad m, Throwable t) => [t] -> ClaferT m a

-- | Throw one error.
throwErr :: (Monad m, Throwable t) => t -> ClaferT m a

-- | Catch errors
catchErrs :: Monad m => ClaferT m a -> ([ClaferErr] -> ClaferT m a) -> ClaferT m a

-- | Get the ClaferEnv
getEnv :: Monad m => ClaferT m ClaferEnv
getsEnv :: Monad m => (ClaferEnv -> a) -> ClaferT m a

-- | Modify the ClaferEnv
modifyEnv :: Monad m => (ClaferEnv -> ClaferEnv) -> ClaferT m ()

-- | Set the ClaferEnv. Remember to set the env after every change.
putEnv :: Monad m => ClaferEnv -> ClaferT m ()

-- | Convenience
runClafer :: ClaferArgs -> ClaferM a -> Either [ClaferErr] a

-- | Uses the ErrorT convention: | Left is for error (a string containing
--   the error message) | Right is for success (with the result)
runClaferT :: Monad m => ClaferArgs -> ClaferT m a -> m (Either [ClaferErr] a)
class Throwable t
toErr :: Throwable t => t -> Monad m => ClaferT m ClaferErr
data Span
Span :: Pos -> Pos -> Span
data Pos
Pos :: Integer -> Integer -> Pos
instance Show ClaferEnv
instance Show p => Show (CErr p)
instance Show p => Show (CErrs p)
instance Show ErrPos
instance Show PartialErrPos
instance ClaferErrPos p => Throwable (CErr p)
instance ClaferErrPos PartialErrPos
instance ClaferErrPos ErrPos
instance ClaferErrPos Span


-- | Resolves indentation into explicit nesting using { }
module Language.Clafer.Front.LayoutResolver
data LayEnv
LayEnv :: Int -> [Int] -> String -> String -> Int -> LayEnv
level :: LayEnv -> Int
levels :: LayEnv -> [Int]
input :: LayEnv -> String
output :: LayEnv -> String
brCtr :: LayEnv -> Int

-- | ident level of new line, current level or parenthesis
type LastNl = (Int, Int)
type Position = Posn
data ExToken
NewLine :: LastNl -> ExToken
ExToken :: Token -> ExToken

-- | ident level stack, last new line
data LEnv
LEnv :: [Int] -> (Maybe LastNl) -> LEnv
getToken :: Monad m => ExToken -> ClaferT m Token
layoutOpen :: String
layoutClose :: String
resolveLayout :: Monad m => [Token] -> ClaferT m [Token]
resolve :: Monad m => LEnv -> [ExToken] -> ClaferT m [Token]
indent :: Token
dedent :: Token
toToken :: ExToken -> [Token]
isExTokenIn :: [String] -> ExToken -> Bool
isNewLine :: Token -> Token -> Bool

-- | Add to the global and column positions of a token. | The column
--   position is only changed if the token is on | the same line as the
--   given position.
incrGlobal :: Monad m => Position -> Int -> Token -> ClaferT m Token
tokenLookup :: String -> Maybe Int

-- | Get the position of a token.
position :: Token -> Position

-- | Get the line number of a token.
line :: Token -> Int

-- | Get the column number of a token.
column :: Token -> Int

-- | Check if a token is one of the given symbols.
isTokenIn :: [String] -> Token -> Bool

-- | Check if a token is the layout open token.
isLayoutOpen :: Token -> Bool
isBracketOpen :: Token -> Bool

-- | Check if a token is the layout close token.
isLayoutClose :: Token -> Bool
isBracketClose :: Token -> Bool

-- | Get the number of characters in the token.
tokenLength :: Token -> Int
addNewLines :: Monad m => [Token] -> ClaferT m [ExToken]
addNewLines' :: Monad m => Int -> [Token] -> ClaferT m [ExToken]
adjust :: Monad m => [Token] -> ClaferT m [Token]
updToken :: Monad m => [Token] -> ClaferT m [Token]

-- | Insert a new symbol token at the begninning of a list of tokens.
addToken :: Monad m => Position -> String -> [Token] -> ClaferT m [Token]
resLayout :: String -> String
resolveLayout' :: StateT LayEnv Identity ()
handleIndent :: Char -> StateT LayEnv Identity Char
emit :: MonadState LayEnv m => Char -> m ()
readC :: (Num a, Ord a) => a -> StateT LayEnv Identity Char
eatSpaces :: StateT LayEnv Identity Int
emitIndent :: MonadState LayEnv m => Int -> m ()
emitDedent :: MonadState LayEnv m => Int -> m ()
isEof :: StateT LayEnv Identity Bool
getc :: StateT LayEnv Identity Char
revertLayout :: String -> String
revertLayout' :: [String] -> Int -> [String]
instance Show LayEnv
instance Show ExToken


-- | Generates HTML and plain text rendering of a Clafer model.
module Language.Clafer.Generator.Html

-- | Generate the model as HTML document
genHtml :: Module -> IModule -> String

-- | Generate the model as plain text | This is used by the graph generator
--   for tooltips
genText :: Module -> IModule -> String
genTooltip :: Module -> Map Span [Ir] -> String
printModule :: Module -> Map Span [Ir] -> Bool -> String
printDeclaration :: Declaration -> Int -> Map Span [Ir] -> Bool -> [(Span, String)] -> String
printDecl :: Decl -> Int -> Map Span [Ir] -> Bool -> [(Span, String)] -> String
traceAstModule :: Module -> Map Span [Ast]
traceIrModule :: IModule -> Map Span [Ir]
cleanOutput :: String -> String
revertLayout :: String -> String
printComment :: Span -> [(Span, String)] -> ([(Span, String)], String)
printPreComment :: Span -> [(Span, String)] -> ([(Span, String)], String)
printStandaloneComment :: String -> String
printInlineComment :: String -> String
highlightErrors :: String -> [ClaferErr] -> String


-- | Generates simple graph and CVL graph representation for a Clafer model
--   in GraphViz DOT.
module Language.Clafer.Generator.Graph

-- | Generate a graph in the simplified notation
genSimpleGraph :: Module -> IModule -> String -> Bool -> String

-- | Generate a graph in CVL variability abstraction notation
genCVLGraph :: Module -> IModule -> String -> String
traceAstModule :: Module -> Map Span [Ast]
traceIrModule :: IModule -> Map Span [Ir]

module Language.Clafer.Optimizer.Optimizer

-- | Apply optimizations for unused abstract clafers and inheritance
--   flattening
optimizeModule :: ClaferArgs -> (IModule, GEnv) -> IModule
optimizeElement :: Interval -> IElement -> IElement
optimizeClafer :: Interval -> IClafer -> IClafer
multInt :: Interval -> Interval -> Interval
multExInt :: Integer -> Integer -> Integer
makeZeroUnusedAbs :: [IElement] -> [IElement]
remUnusedAbs :: [IElement] -> [IElement]
findUnusedAbs :: [IClafer] -> [String] -> [IClafer]
getUniqExtended :: [IClafer] -> [String]
getExtended :: IClafer -> [String]
expModule :: ([IElement], GEnv) -> [IElement]
expClafer :: MonadState GEnv m => IClafer -> m IClafer
expElement :: MonadState GEnv m => IElement -> m IElement
expPExp :: MonadState GEnv m => PExp -> m PExp
expIExp :: MonadState GEnv m => IExp -> m IExp
expDecl :: MonadState GEnv m => IDecl -> m IDecl
expNav :: MonadState GEnv m => IExp -> m IExp
expNav' :: MonadState GEnv m => String -> IExp -> m (IExp, String)
split' :: MonadState GEnv m => IExp -> (IExp -> m IExp) -> m [IExp]
allUnique :: IModule -> Bool
checkConstraintElement :: [String] -> IElement -> Bool
checkConstraintPExp :: [String] -> PExp -> Bool
checkConstraintIExp :: [String] -> IExp -> Bool
checkConstraintIDecl :: [String] -> IDecl -> [String]
findDupModule :: ClaferArgs -> IModule -> Either ClaferErr IModule
markTopModule :: [IElement] -> [IElement]
markTopClafer :: [String] -> IClafer -> IClafer
markTopElement :: [String] -> IElement -> IElement
markTopPExp :: [String] -> PExp -> PExp
markTopIExp :: [String] -> IExp -> IExp
markTopDecl :: [String] -> IDecl -> IDecl

module Language.Clafer.Intermediate.ResolverName

-- | this environment is created for each clafer
data SEnv
SEnv :: [IClafer] -> Maybe IClafer -> [(IClafer, [IClafer])] -> [(IClafer, [IClafer])] -> [([String], [IClafer])] -> [IClafer] -> GEnv -> [(IClafer, [IClafer])] -> [(IClafer, [IClafer])] -> SEnv
clafers :: SEnv -> [IClafer]
context :: SEnv -> Maybe IClafer
subClafers :: SEnv -> [(IClafer, [IClafer])]
ancClafers :: SEnv -> [(IClafer, [IClafer])]
bindings :: SEnv -> [([String], [IClafer])]
resPath :: SEnv -> [IClafer]
genv :: SEnv -> GEnv
aClafers :: SEnv -> [(IClafer, [IClafer])]
cClafers :: SEnv -> [(IClafer, [IClafer])]

-- | How a given name was resolved
data HowResolved

-- | "this", "parent", "children", and "root"
Special :: HowResolved

-- | primitive type: "integer", "string"
TypeSpecial :: HowResolved

-- | local variable (in constraints)
Binding :: HowResolved

-- | clafer's descendant
Subclafers :: HowResolved

-- | resolved by a reference
Reference :: HowResolved

-- | clafer's ancestor
Ancestor :: HowResolved

-- | abstract clafer
AbsClafer :: HowResolved

-- | non-abstract top-level clafer
TopClafer :: HowResolved
type Resolve = Either ClaferSErr
defSEnv :: GEnv -> [IElement] -> SEnv
checkDuplicateSiblings :: IModule -> Resolve [IElement]
checkDuplicateSiblings' :: [IElement] -> Maybe (String, Span)
checkForJust :: [Maybe (String, Span)] -> Maybe (String, Span)
checkListDuplicates :: [(String, Span)] -> Maybe (String, Span)
checkListDuplicates' :: [(String, Span)] -> Maybe (String, Span)
isIEClafer :: IElement -> Bool
resolveModuleNames :: (IModule, GEnv) -> Resolve IModule
resolveClafer :: SEnv -> IClafer -> Resolve IClafer
mkAncestorList :: SEnv -> [IClafer] -> [(IClafer, [IClafer])]
resolveElement :: SEnv -> IElement -> Resolve IElement
resolvePExp :: SEnv -> PExp -> Resolve PExp
resolveIExp :: Span -> SEnv -> IExp -> Resolve IExp
liftError :: Monad m => Either e a -> ExceptT e m a
processDecl :: MonadState SEnv m => IDecl -> m (Resolve IDecl)
resolveNav :: Span -> SEnv -> IExp -> Bool -> Resolve (IExp, [IClafer])
mkPath :: SEnv -> (HowResolved, String, [IClafer]) -> (IExp, [IClafer])
toTuple :: IClafer -> (String, Maybe IClafer)
toNav' :: [(String, Maybe IClafer)] -> IExp
adjustAncestor :: IClafer -> [(String, Maybe IClafer)] -> [(String, Maybe IClafer)] -> [(String, Maybe IClafer)]
mkPath' :: String -> (HowResolved, String, [IClafer]) -> (IExp, [IClafer])
resolveName :: Span -> SEnv -> String -> Resolve (HowResolved, String, [IClafer])
resolveImmName :: Span -> SEnv -> String -> Resolve (HowResolved, String, [IClafer])
resolve :: (Monad f, Functor f) => SEnv -> String -> [SEnv -> String -> f (Maybe b)] -> f b
resolveNone :: Span -> SEnv -> String -> Resolve t
resolveSpecial :: SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveBind :: SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveDescendants :: SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveChildren :: Span -> SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveReference :: Span -> SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveChildren' :: Span -> SEnv -> String -> (SEnv -> [IClafer]) -> HowResolved -> Either ClaferSErr (Maybe (HowResolved, String, [IClafer]))
liftMaybe :: Maybe a -> MaybeT (Either ClaferSErr) a
resolveAncestor :: Span -> SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
resolveTopLevel :: Span -> SEnv -> String -> Resolve (Maybe (HowResolved, String, [IClafer]))
toNodeDeep :: SEnv -> ((IClafer, [IClafer]), [SEnv])
allInhChildren :: SEnv -> [IClafer]
allChildren :: SEnv -> [IClafer]
selectChildren :: (IClafer -> [String]) -> SEnv -> [IClafer]
findUnique :: Span -> String -> [(IClafer, [IClafer])] -> Resolve (Maybe (String, [IClafer]))
findFirst :: String -> [(IClafer, [IClafer])] -> Maybe (String, [IClafer])
showPath :: [String] -> String
isNamespaceConflict :: [[String]] -> Bool
filterPaths :: String -> [(IClafer, [IClafer])] -> [(IClafer, [IClafer])]
instance Show SEnv
instance Eq HowResolved
instance Show HowResolved

module Language.Clafer.Intermediate.ResolverType
resolveTModule :: (IModule, GEnv) -> Either ClaferSErr IModule
instance MonadError ClaferSErr TypeAnalysis
instance Monad TypeAnalysis
instance Functor TypeAnalysis
instance MonadReader TypeInfo TypeAnalysis
instance Applicative TypeAnalysis
instance MonadTypeAnalysis m => MonadTypeAnalysis (ExceptT ClaferSErr m)
instance MonadTypeAnalysis m => MonadTypeAnalysis (ListT m)
instance MonadTypeAnalysis TypeAnalysis

module Language.Clafer.Intermediate.ResolverInheritance

-- | Resolve Non-overlapping inheritance
resolveNModule :: (IModule, GEnv) -> Resolve (IModule, GEnv)
resolveNClafer :: [IClafer] -> IClafer -> Resolve IClafer
resolveNSuper :: [IClafer] -> Maybe PExp -> Resolve (Maybe PExp, Maybe IClafer)
resolveNElement :: [IClafer] -> IElement -> Resolve IElement
resolveN :: Span -> [IClafer] -> String -> Resolve (Maybe (String, [IClafer]))
resolveHierarchy :: UIDIClaferMap -> IElement -> IElement

-- | Resolve overlapping inheritance
resolveOModule :: (IModule, GEnv) -> Resolve (IModule, GEnv)
resolveOClafer :: SEnv -> IClafer -> Resolve IClafer
resolveOReference :: SEnv -> Maybe IReference -> Resolve (Maybe IReference)
resolveOElement :: SEnv -> IElement -> Resolve IElement

-- | Resolve inherited and default cardinalities
analyzeModule :: (IModule, GEnv) -> IModule
analyzeClafer :: SEnv -> IClafer -> IClafer
analyzeGCard :: SEnv -> IClafer -> Maybe IGCard
analyzeCard :: SEnv -> IClafer -> Maybe Interval
analyzeElement :: SEnv -> IElement -> IElement

-- | Expand inheritance
resolveEModule :: (IModule, GEnv) -> (IModule, GEnv)
unrollableModule :: IModule -> [String]
unrollabeDeclaration :: IElement -> Maybe (String, [String])
unrollableClafer :: IClafer -> [String]
getDirUnrollables :: [(String, [String])] -> [String]
resolveEClafer :: MonadState GEnv m => [String] -> [String] -> Bool -> [IElement] -> IClafer -> m IClafer
renameClafer :: MonadState GEnv m => Bool -> UID -> IClafer -> m IClafer
renameClafer' :: MonadState GEnv m => UID -> IClafer -> m IClafer
genId :: String -> Int -> String
resolveEInheritance :: MonadState GEnv m => [String] -> [String] -> Bool -> [IElement] -> [IClafer] -> m ([IElement], Maybe PExp, [IClafer])
resolveEElement :: MonadState GEnv m => [String] -> [String] -> Bool -> [IElement] -> IElement -> m IElement
resolveRedefinition :: (IModule, GEnv) -> Resolve IModule

module Language.Clafer.Intermediate.Resolver

-- | Run the various resolvers
resolveModule :: ClaferArgs -> IModule -> Resolve (IModule, GEnv)

-- | Name resolver
nameModule :: Bool -> IModule -> (IModule, GEnv)
nameElement :: MonadState GEnv m => Bool -> UID -> IElement -> m IElement
nameClafer :: MonadState GEnv m => Bool -> UID -> IClafer -> m IClafer
namePExp :: MonadState GEnv m => PExp -> m PExp
nameIExp :: MonadState GEnv m => IExp -> m IExp
nameIDecl :: MonadState GEnv m => IDecl -> m IDecl
resolveNamesModule :: ClaferArgs -> (IModule, GEnv) -> Resolve (IModule, GEnv)


-- | Top-level interface to the Clafer compiler
--   
--   Normal usage:
--   
--   <pre>
--   t :: InputModel -&gt; InputModel -&gt; Either [ClaferErr] [String]
--   t a b =
--     runClafer defaultClaferArgs $
--       do
--         addModuleFragment a
--         addModuleFragment b
--         parse
--         iModule &lt;- desugar ""
--         compile iModule
--         generate
--   </pre>
--   
--   Example of compiling a model consisting of one fragment:
--   
--   <pre>
--   compileOneFragment :: ClaferArgs -&gt; InputModel -&gt; Either ClaferErr CompilerResult
--   compileOneFragment args model =
--     runClafer args $
--       do
--         addModuleFragment model
--         parse
--         iModule &lt;- desugar "http://mydomain.org/mymodel.cfr"
--         compile iModule
--         generate
--   </pre>
--   
--   <pre>
--   compileTwoFragments :: ClaferArgs -&gt; InputModel -&gt; InputModel -&gt; Either ClaferErr [String]
--   compileTwoFragments args frag1 frag2 =
--     runClafer args $
--      do
--        addModuleFragment frag1
--        addModuleFragment frag2
--        parse
--        iModule &lt;- desugar ""
--        compile iModule
--        generate
--   </pre>
--   
--   Use "throwErr" to halt execution:
--   
--   <pre>
--   runClafer args $
--     when (notValid args) $ throwErr (ClaferErr "Invalid arguments.")
--   </pre>
--   
--   Use "catchErrs" to catch the errors.
module Language.Clafer

-- | Run the Clafer compiler. mURL = Nothing means compile the top-level
--   module mURL = Just url means compile an imported module from the given
--   url
runCompiler :: Maybe URL -> ClaferArgs -> InputModel -> IO ()

-- | Add a new fragment to the model. Fragments should be added in order.
addModuleFragment :: Monad m => InputModel -> ClaferT m ()

-- | Compiles the AST into IR.
compile :: Monad m => IModule -> ClaferT m ()

-- | Parses the model into AST. Adding more fragments beyond this point
--   will have no effect.
parse :: Monad m => ClaferT m ()
desugar :: Monad m => Maybe URL -> ClaferT m IModule

-- | Generates outputs for the given IR.
generate :: Monad m => ClaferT m (Map ClaferMode CompilerResult)

-- | Splits the AST into their fragments, and generates the output for each
--   fragment.
generateHtml :: ClaferEnv -> String

-- | Uses the ErrorT convention: | Left is for error (a string containing
--   the error message) | Right is for success (with the result)
runClaferT :: Monad m => ClaferArgs -> ClaferT m a -> m (Either [ClaferErr] a)

-- | Convenience
runClafer :: ClaferArgs -> ClaferM a -> Either [ClaferErr] a
type ClaferErr = CErr ErrPos

-- | Get the ClaferEnv
getEnv :: Monad m => ClaferT m ClaferEnv

-- | Set the ClaferEnv. Remember to set the env after every change.
putEnv :: Monad m => ClaferEnv -> ClaferT m ()

-- | Result of generation for a given mode
data CompilerResult
CompilerResult :: String -> String -> String -> ClaferEnv -> [(Span, IrTrace)] -> (Map Int String) -> [(UID, Integer)] -> CompilerResult

-- | output file extension
extension :: CompilerResult -> String

-- | output text
outputCode :: CompilerResult -> String

-- | the final environment of the compiler
statistics :: CompilerResult -> String

-- | Maps source constraint spans in Alloy to the spans in the IR
claferEnv :: CompilerResult -> ClaferEnv

-- | Map back from Ints used to represent Strings
mappingToAlloy :: CompilerResult -> [(Span, IrTrace)]

-- | scopes generated by scope inference
stringMap :: CompilerResult -> (Map Int String)
scopesList :: CompilerResult -> [(UID, Integer)]
NoCompilerResult :: String -> CompilerResult
reason :: CompilerResult -> String

-- | The XML Schema of the IR
claferIRXSD :: String
type InputModel = String
data Token
data Module
data GEnv

-- | each file contains exactly one mode. A module is a list of
--   declarations
data IModule
voidf :: Monad m => m t -> m ()
data ClaferEnv
ClaferEnv :: ClaferArgs -> [String] -> Maybe Module -> Maybe (IModule, GEnv, Bool) -> [Pos] -> Map Span [Ast] -> ClaferEnv
args :: ClaferEnv -> ClaferArgs
modelFrags :: ClaferEnv -> [String]
cAst :: ClaferEnv -> Maybe Module
cIr :: ClaferEnv -> Maybe (IModule, GEnv, Bool)
frags :: ClaferEnv -> [Pos]
astModuleTrace :: ClaferEnv -> Map Span [Ast]
getIr :: Monad m => ClaferT m (IModule, GEnv, Bool)
getAst :: Monad m => ClaferT m Module
makeEnv :: ClaferArgs -> ClaferEnv
data Pos
Pos :: Integer -> Integer -> Pos
data IrTrace
IrPExp :: String -> IrTrace
pUid :: IrTrace -> String
LowerCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
UpperCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
ExactCard :: String -> Bool -> IrTrace
pUid :: IrTrace -> String
isGroup :: IrTrace -> Bool
NoTrace :: IrTrace
instance Show CompilerResult
