-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tools for working with regular grids (graphs, lattices).
--   
--   Provides tools for working with regular arrangements of tiles, such as
--   might be used in a board game or some other type of grid map.
--   Currently supports triangular, square, and hexagonal tiles, with
--   various 2D and toroidal layouts. The userguide is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
@package grid
@version 7.8.4


-- | A module containing private <tt>Grid</tt> internals. Most developers
--   should use <tt>Grid</tt> instead. This module is subject to change
--   without notice.
module Math.Geometry.GridInternal

-- | A regular arrangement of tiles. Minimal complete definition:
--   <tt><a>Index</a></tt>, <tt><a>Direction</a></tt>,
--   <tt><a>indices</a></tt>, <tt><a>distance</a></tt>,
--   <tt><a>directionTo</a></tt>.
class Grid g where type family Index g type family Direction g minDistance = defaultMinDistance neighbours = defaultNeighbours neighboursOfSet = defaultNeighboursOfSet neighbour = defaultNeighbour numNeighbours g = length . neighbours g contains g a = a `elem` indices g tileCount = length . indices null g = tileCount g == 0 nonNull = not . null edges = defaultEdges viewpoint g p = map f (indices g) where f a = (a, distance g p a) isAdjacent = defaultIsAdjacent adjacentTilesToward = defaultAdjacentTilesToward minimalPaths = defaultMinimalPaths defaultMinDistance g xs a = minimum . map (distance g a) $ xs defaultNeighbours g a = filter (\ b -> distance g a b == 1) $ indices g defaultNeighboursOfSet g as = ns \\ as where ns = nub . concatMap (neighbours g) $ as defaultNeighbour g a d = maybeHead . filter (\ b -> [d] == directionTo g a b) . neighbours g $ a where maybeHead (x : _) = Just x maybeHead _ = Nothing defaultTileCount = length . indices defaultEdges g = nubBy sameEdge $ concatMap (`adjacentEdges` g) $ indices g defaultIsAdjacent g a b = distance g a b == 1 defaultAdjacentTilesToward g a b = filter f $ neighbours g a where f c = distance g c b == distance g a b - 1 defaultMinimalPaths g a b | a == b = [[a]] | distance g a b == 1 = [[a, b]] | otherwise = map (a :) xs where xs = concatMap (\ c -> minimalPaths g c b) ys ys = adjacentTilesToward g a b
indices :: Grid g => g -> [Index g]
distance :: Grid g => g -> Index g -> Index g -> Int
minDistance :: Grid g => g -> [Index g] -> Index g -> Int
neighbours :: (Grid g, Eq (Index g)) => g -> Index g -> [Index g]
neighboursOfSet :: (Grid g, Eq (Index g)) => g -> [Index g] -> [Index g]
neighbour :: (Grid g, Eq (Index g), Eq (Direction g)) => g -> Index g -> Direction g -> Maybe (Index g)
numNeighbours :: (Grid g, Eq (Index g)) => g -> Index g -> Int
contains :: (Grid g, Eq (Index g)) => g -> Index g -> Bool
tileCount :: Grid g => g -> Int
null :: Grid g => g -> Bool
nonNull :: Grid g => g -> Bool
edges :: (Grid g, Eq (Index g)) => g -> [(Index g, Index g)]
viewpoint :: Grid g => g -> Index g -> [(Index g, Int)]
isAdjacent :: Grid g => g -> Index g -> Index g -> Bool
adjacentTilesToward :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [Index g]
minimalPaths :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [[Index g]]
directionTo :: Grid g => g -> Index g -> Index g -> [Direction g]
defaultMinDistance :: Grid g => g -> [Index g] -> Index g -> Int
defaultNeighbours :: Grid g => g -> Index g -> [Index g]
defaultNeighboursOfSet :: (Grid g, Eq (Index g)) => g -> [Index g] -> [Index g]
defaultNeighbour :: (Grid g, Eq (Index g), Eq (Direction g)) => g -> Index g -> Direction g -> Maybe (Index g)
defaultTileCount :: Grid g => g -> Int
defaultEdges :: (Grid g, Eq (Index g)) => g -> [(Index g, Index g)]
defaultIsAdjacent :: Grid g => g -> Index g -> Index g -> Bool
defaultAdjacentTilesToward :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [Index g]
defaultMinimalPaths :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [[Index g]]

-- | A regular arrangement of tiles where the number of tiles is finite.
--   Minimal complete definition: <tt><a>size</a></tt>,
--   <tt><a>maxPossibleDistance</a></tt>.
class Grid g => FiniteGrid g where type family Size g
size :: FiniteGrid g => g -> Size g
maxPossibleDistance :: FiniteGrid g => g -> Int

-- | A regular arrangement of tiles with an edge. Minimal complete
--   definition: <tt><a>tileSideCount</a></tt>.
class Grid g => BoundedGrid g where boundary = defaultBoundary isBoundary = defaultIsBoundary centre = defaultCentre isCentre = defaultIsCentre defaultBoundary g = map fst . filter f $ xds where xds = map (\ b -> (b, numNeighbours g b)) $ indices g f (_, n) = n < tileSideCount g defaultIsBoundary g a = a `elem` boundary g defaultCentre g = map fst . head . groupBy ((==) `on` snd) . sortBy (comparing snd) $ xds where xds = map (\ b -> (b, f b)) $ indices g bs = boundary g f x = sum . map (distance g x) $ bs defaultIsCentre g a = a `elem` centre g
tileSideCount :: BoundedGrid g => g -> Int
boundary :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
isBoundary :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
centre :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
isCentre :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
defaultBoundary :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
defaultIsBoundary :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
defaultCentre :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
defaultIsCentre :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool

-- | A regular arrangement of tiles where the boundaries are joined.
--   Minimal complete definition: <tt><a>normalise</a></tt> and
--   <tt><a>denormalise</a></tt>.
class (Grid g) => WrappedGrid g
normalise :: WrappedGrid g => g -> Index g -> Index g
denormalise :: WrappedGrid g => g -> Index g -> [Index g]
neighboursBasedOn :: (Eq (Index u), Grid g, Grid u, Index g ~ Index u) => u -> g -> Index g -> [Index g]
distanceBasedOn :: (Eq (Index g), Grid g, Grid u, Index g ~ Index u) => u -> g -> Index g -> Index g -> Int
directionToBasedOn :: (Eq (Index g), Eq (Direction g), Grid g, Grid u, Index g ~ Index u, Direction g ~ Direction u) => u -> g -> Index g -> Index g -> [Direction g]
neighboursWrappedBasedOn :: (Eq (Index g), WrappedGrid g, Grid u, Index g ~ Index u) => u -> g -> Index g -> [Index g]
neighbourWrappedBasedOn :: (Eq (Index g), Eq (Direction g), WrappedGrid g, Grid u, Index g ~ Index u, Direction g ~ Direction u) => u -> g -> Index g -> Direction g -> Maybe (Index g)
distanceWrappedBasedOn :: (Eq (Index g), WrappedGrid g, Grid u, Index g ~ Index u) => u -> g -> Index g -> Index g -> Int
directionToWrappedBasedOn :: (Eq (Index g), Eq (Direction g), WrappedGrid g, Grid u, Index g ~ Index u, Direction g ~ Direction u) => u -> g -> Index g -> Index g -> [Direction g]
sameEdge :: Eq t => (t, t) -> (t, t) -> Bool
adjacentEdges :: (Grid g, Eq (Index g)) => Index g -> g -> [(Index g, Index g)]
cartesianIndices :: (Enum r, Enum c, Num r, Num c, Ord r, Ord c) => (r, c) -> [(c, r)]
cartesianCentre :: (Int, Int) -> [(Int, Int)]
cartesianMidpoints :: Int -> [Int]


-- | A module containing private <tt>TriGrid</tt> internals. Most
--   developers should use <tt>TriGrid</tt> instead. This module is subject
--   to change without notice.
module Math.Geometry.Grid.TriangularInternal
data TriDirection
[South] :: TriDirection
[Northwest] :: TriDirection
[Northeast] :: TriDirection
[North] :: TriDirection
[Southeast] :: TriDirection
[Southwest] :: TriDirection

-- | An unbounded grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedTriGrid
[UnboundedTriGrid] :: UnboundedTriGrid

-- | For triangular tiles, it is convenient to define a third component z.
triZ :: Int -> Int -> Int

-- | A triangular grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TriTriGrid
[TriTriGrid] :: Int -> [(Int, Int)] -> TriTriGrid
inTriTriGrid :: (Int, Int) -> Int -> Bool

-- | <tt><a>triTriGrid</a> s</tt> returns a triangular grid with sides of
--   length <tt>s</tt>, using triangular tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>s^2</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
triTriGrid :: Int -> TriTriGrid

-- | A Parallelogrammatical grid with triangular tiles. The grid and its
--   indexing scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data ParaTriGrid
[ParaTriGrid] :: (Int, Int) -> [(Int, Int)] -> ParaTriGrid

-- | <tt><a>paraTriGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   triangular tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>2*r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
paraTriGrid :: Int -> Int -> ParaTriGrid
parallelogramIndices :: Int -> Int -> [(Int, Int)]

-- | A rectangular grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectTriGrid
[RectTriGrid] :: (Int, Int) -> [(Int, Int)] -> RectTriGrid

-- | <tt><a>rectTriGrid</a> r c</tt> returns a grid in the shape of a
--   rectangle (with jagged edges) that has <tt>r</tt> rows and <tt>c</tt>
--   columns, using triangular tiles. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
rectTriGrid :: Int -> Int -> RectTriGrid

-- | A toroidal grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorTriGrid
[TorTriGrid] :: (Int, Int) -> [(Int, Int)] -> TorTriGrid

-- | <tt><a>torTriGrid</a> r c</tt> returns a toroidal grid with <tt>r</tt>
--   rows and <tt>c</tt> columns, using triangular tiles. The indexing
--   method is the same as for <tt>ParaTriGrid</tt>. If <tt>r</tt> and
--   <tt>c</tt> are both nonnegative, the resulting grid will have
--   <tt>2*r*c</tt> tiles. Otherwise, the resulting grid will be null and
--   the list of indices will be null.
torTriGrid :: Int -> Int -> TorTriGrid

-- | A cylindrical grid with triangular tiles, where the cylinder is along
--   the y-axis. The grid and its indexing scheme are illustrated in the
--   user guide, available at <a>https://github.com/mhwombat/grid/wiki</a>.
data YCylTriGrid
[YCylTriGrid] :: (Int, Int) -> [(Int, Int)] -> YCylTriGrid

-- | <tt><a>yCylTriGrid</a> r c</tt> returns a cylindrical grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using triangular tiles, where
--   the cylinder is along the y-axis. The indexing method is the same as
--   for <tt>ParaTriGrid</tt>. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
yCylTriGrid :: Int -> Int -> YCylTriGrid

-- | A cylindrical grid with triangular tiles, where the cylinder is along
--   the x-axis. The grid and its indexing scheme are illustrated in the
--   user guide, available at <a>https://github.com/mhwombat/grid/wiki</a>.
data XCylTriGrid
[XCylTriGrid] :: (Int, Int) -> [(Int, Int)] -> XCylTriGrid

-- | <tt><a>xCylTriGrid</a> r c</tt> returns a cylindrical grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using triangular tiles, where
--   the cylinder is along the y-axis. The indexing method is the same as
--   for <tt>ParaTriGrid</tt>. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
xCylTriGrid :: Int -> Int -> XCylTriGrid
instance Constructor C1_0XCylTriGrid
instance Datatype D1XCylTriGrid
instance Constructor C1_0YCylTriGrid
instance Datatype D1YCylTriGrid
instance Constructor C1_0TorTriGrid
instance Datatype D1TorTriGrid
instance Constructor C1_0RectTriGrid
instance Datatype D1RectTriGrid
instance Constructor C1_0ParaTriGrid
instance Datatype D1ParaTriGrid
instance Constructor C1_0TriTriGrid
instance Datatype D1TriTriGrid
instance Constructor C1_0UnboundedTriGrid
instance Datatype D1UnboundedTriGrid
instance Constructor C1_5TriDirection
instance Constructor C1_4TriDirection
instance Constructor C1_3TriDirection
instance Constructor C1_2TriDirection
instance Constructor C1_1TriDirection
instance Constructor C1_0TriDirection
instance Datatype D1TriDirection
instance Generic XCylTriGrid
instance Eq XCylTriGrid
instance Generic YCylTriGrid
instance Eq YCylTriGrid
instance Generic TorTriGrid
instance Eq TorTriGrid
instance Generic RectTriGrid
instance Eq RectTriGrid
instance Generic ParaTriGrid
instance Eq ParaTriGrid
instance Generic TriTriGrid
instance Eq TriTriGrid
instance Generic UnboundedTriGrid
instance Show UnboundedTriGrid
instance Eq UnboundedTriGrid
instance Generic TriDirection
instance Eq TriDirection
instance Show TriDirection
instance Grid UnboundedTriGrid
instance Show TriTriGrid
instance Grid TriTriGrid
instance FiniteGrid TriTriGrid
instance BoundedGrid TriTriGrid
instance Show ParaTriGrid
instance Grid ParaTriGrid
instance FiniteGrid ParaTriGrid
instance BoundedGrid ParaTriGrid
instance Show RectTriGrid
instance Grid RectTriGrid
instance FiniteGrid RectTriGrid
instance BoundedGrid RectTriGrid
instance Show TorTriGrid
instance Grid TorTriGrid
instance FiniteGrid TorTriGrid
instance WrappedGrid TorTriGrid
instance Show YCylTriGrid
instance Grid YCylTriGrid
instance FiniteGrid YCylTriGrid
instance WrappedGrid YCylTriGrid
instance Show XCylTriGrid
instance Grid XCylTriGrid
instance FiniteGrid XCylTriGrid
instance WrappedGrid XCylTriGrid


-- | A regular arrangement of triangular tiles. The userguide, with
--   illustrations, is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>. Also see
--   <tt>Math.Geometry.Grid</tt> for examples of how to use this class.
module Math.Geometry.Grid.Triangular

-- | An unbounded grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedTriGrid
[UnboundedTriGrid] :: UnboundedTriGrid

-- | A triangular grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TriTriGrid

-- | <tt><a>triTriGrid</a> s</tt> returns a triangular grid with sides of
--   length <tt>s</tt>, using triangular tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>s^2</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
triTriGrid :: Int -> TriTriGrid

-- | A Parallelogrammatical grid with triangular tiles. The grid and its
--   indexing scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data ParaTriGrid

-- | <tt><a>paraTriGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   triangular tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>2*r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
paraTriGrid :: Int -> Int -> ParaTriGrid

-- | A rectangular grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectTriGrid

-- | <tt><a>rectTriGrid</a> r c</tt> returns a grid in the shape of a
--   rectangle (with jagged edges) that has <tt>r</tt> rows and <tt>c</tt>
--   columns, using triangular tiles. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
rectTriGrid :: Int -> Int -> RectTriGrid

-- | A toroidal grid with triangular tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorTriGrid

-- | <tt><a>torTriGrid</a> r c</tt> returns a toroidal grid with <tt>r</tt>
--   rows and <tt>c</tt> columns, using triangular tiles. The indexing
--   method is the same as for <tt>ParaTriGrid</tt>. If <tt>r</tt> and
--   <tt>c</tt> are both nonnegative, the resulting grid will have
--   <tt>2*r*c</tt> tiles. Otherwise, the resulting grid will be null and
--   the list of indices will be null.
torTriGrid :: Int -> Int -> TorTriGrid

-- | A cylindrical grid with triangular tiles, where the cylinder is along
--   the y-axis. The grid and its indexing scheme are illustrated in the
--   user guide, available at <a>https://github.com/mhwombat/grid/wiki</a>.
data YCylTriGrid

-- | <tt><a>yCylTriGrid</a> r c</tt> returns a cylindrical grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using triangular tiles, where
--   the cylinder is along the y-axis. The indexing method is the same as
--   for <tt>ParaTriGrid</tt>. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
yCylTriGrid :: Int -> Int -> YCylTriGrid

-- | A cylindrical grid with triangular tiles, where the cylinder is along
--   the x-axis. The grid and its indexing scheme are illustrated in the
--   user guide, available at <a>https://github.com/mhwombat/grid/wiki</a>.
data XCylTriGrid

-- | <tt><a>xCylTriGrid</a> r c</tt> returns a cylindrical grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using triangular tiles, where
--   the cylinder is along the y-axis. The indexing method is the same as
--   for <tt>ParaTriGrid</tt>. If <tt>r</tt> and <tt>c</tt> are both
--   nonnegative, the resulting grid will have <tt>2*r*c</tt> tiles.
--   Otherwise, the resulting grid will be null and the list of indices
--   will be null.
xCylTriGrid :: Int -> Int -> XCylTriGrid


-- | A module containing private <tt>SquareGrid</tt> internals. Most
--   developers should use <tt>SquareGrid</tt> instead. This module is
--   subject to change without notice.
module Math.Geometry.Grid.SquareInternal
data SquareDirection
[North] :: SquareDirection
[East] :: SquareDirection
[South] :: SquareDirection
[West] :: SquareDirection

-- | An unbounded grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedSquareGrid
[UnboundedSquareGrid] :: UnboundedSquareGrid

-- | A rectangular grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectSquareGrid
[RectSquareGrid] :: (Int, Int) -> [(Int, Int)] -> RectSquareGrid

-- | <tt><a>rectSquareGrid</a> r c</tt> produces a rectangular grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using square tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
rectSquareGrid :: Int -> Int -> RectSquareGrid

-- | A toroidal grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorSquareGrid
[TorSquareGrid] :: (Int, Int) -> [(Int, Int)] -> TorSquareGrid

-- | <tt><a>torSquareGrid</a> r c</tt> returns a toroidal grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using square tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
torSquareGrid :: Int -> Int -> TorSquareGrid
instance Constructor C1_0TorSquareGrid
instance Datatype D1TorSquareGrid
instance Constructor C1_0RectSquareGrid
instance Datatype D1RectSquareGrid
instance Constructor C1_0UnboundedSquareGrid
instance Datatype D1UnboundedSquareGrid
instance Generic TorSquareGrid
instance Eq TorSquareGrid
instance Generic RectSquareGrid
instance Eq RectSquareGrid
instance Generic UnboundedSquareGrid
instance Show UnboundedSquareGrid
instance Eq UnboundedSquareGrid
instance Eq SquareDirection
instance Show SquareDirection
instance Grid UnboundedSquareGrid
instance Show RectSquareGrid
instance Grid RectSquareGrid
instance FiniteGrid RectSquareGrid
instance BoundedGrid RectSquareGrid
instance Show TorSquareGrid
instance Grid TorSquareGrid
instance FiniteGrid TorSquareGrid
instance WrappedGrid TorSquareGrid


-- | A regular arrangement of square tiles. The userguide, with
--   illustrations, is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>. Also see
--   <tt>Math.Geometry.Grid</tt> for examples of how to use this class.
module Math.Geometry.Grid.Square

-- | An unbounded grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedSquareGrid
[UnboundedSquareGrid] :: UnboundedSquareGrid

-- | A rectangular grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectSquareGrid

-- | <tt><a>rectSquareGrid</a> r c</tt> produces a rectangular grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using square tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
rectSquareGrid :: Int -> Int -> RectSquareGrid

-- | A toroidal grid with square tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorSquareGrid

-- | <tt><a>torSquareGrid</a> r c</tt> returns a toroidal grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using square tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
torSquareGrid :: Int -> Int -> TorSquareGrid


-- | A module containing private <tt>HexGrid</tt> internals. Most
--   developers should use <tt>HexGrid</tt> instead. This module is subject
--   to change without notice.
module Math.Geometry.Grid.HexagonalInternal
data HexDirection
[West] :: HexDirection
[Northwest] :: HexDirection
[Northeast] :: HexDirection
[East] :: HexDirection
[Southeast] :: HexDirection
[Southwest] :: HexDirection

-- | An unbounded grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedHexGrid
[UnboundedHexGrid] :: UnboundedHexGrid

-- | A hexagonal grid with hexagonal tiles The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data HexHexGrid
[HexHexGrid] :: Int -> [(Int, Int)] -> HexHexGrid

-- | <tt><a>hexHexGrid</a> s</tt> returns a grid of hexagonal shape, with
--   sides of length <tt>s</tt>, using hexagonal tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>3*s*(s-1) + 1</tt>
--   tiles. Otherwise, the resulting grid will be null and the list of
--   indices will be null.
hexHexGrid :: Int -> HexHexGrid

-- | A parallelogramatical grid with hexagonal tiles The grid and its
--   indexing scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data ParaHexGrid
[ParaHexGrid] :: (Int, Int) -> [(Int, Int)] -> ParaHexGrid

-- | <tt><a>paraHexGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   hexagonal tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
paraHexGrid :: Int -> Int -> ParaHexGrid
instance Constructor C1_0ParaHexGrid
instance Datatype D1ParaHexGrid
instance Constructor C1_0HexHexGrid
instance Datatype D1HexHexGrid
instance Constructor C1_0UnboundedHexGrid
instance Datatype D1UnboundedHexGrid
instance Constructor C1_5HexDirection
instance Constructor C1_4HexDirection
instance Constructor C1_3HexDirection
instance Constructor C1_2HexDirection
instance Constructor C1_1HexDirection
instance Constructor C1_0HexDirection
instance Datatype D1HexDirection
instance Generic ParaHexGrid
instance Eq ParaHexGrid
instance Generic HexHexGrid
instance Eq HexHexGrid
instance Generic UnboundedHexGrid
instance Eq UnboundedHexGrid
instance Show UnboundedHexGrid
instance Generic HexDirection
instance Eq HexDirection
instance Show HexDirection
instance Grid UnboundedHexGrid
instance Show HexHexGrid
instance Grid HexHexGrid
instance FiniteGrid HexHexGrid
instance BoundedGrid HexHexGrid
instance Show ParaHexGrid
instance Grid ParaHexGrid
instance FiniteGrid ParaHexGrid
instance BoundedGrid ParaHexGrid


-- | A regular arrangement of hexagonal tiles. The userguide, with
--   illustrations, is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>. Also see
--   <tt>Math.Geometry.Grid</tt> for examples of how to use this class.
module Math.Geometry.Grid.Hexagonal

-- | An unbounded grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedHexGrid
[UnboundedHexGrid] :: UnboundedHexGrid

-- | A hexagonal grid with hexagonal tiles The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data HexHexGrid

-- | <tt><a>hexHexGrid</a> s</tt> returns a grid of hexagonal shape, with
--   sides of length <tt>s</tt>, using hexagonal tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>3*s*(s-1) + 1</tt>
--   tiles. Otherwise, the resulting grid will be null and the list of
--   indices will be null.
hexHexGrid :: Int -> HexHexGrid

-- | A parallelogramatical grid with hexagonal tiles The grid and its
--   indexing scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data ParaHexGrid

-- | <tt><a>paraHexGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   hexagonal tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
paraHexGrid :: Int -> Int -> ParaHexGrid


-- | A module containing private <tt>HexGrid2</tt> internals. Most
--   developers should use <tt>HexGrid2</tt> instead. This module is
--   subject to change without notice.
module Math.Geometry.Grid.HexagonalInternal2
data HexDirection
[Northwest] :: HexDirection
[North] :: HexDirection
[Northeast] :: HexDirection
[Southeast] :: HexDirection
[South] :: HexDirection
[Southwest] :: HexDirection

-- | An unbounded grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedHexGrid
[UnboundedHexGrid] :: UnboundedHexGrid

-- | A hexagonal grid with hexagonal tiles The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data HexHexGrid
[HexHexGrid] :: Int -> [(Int, Int)] -> HexHexGrid

-- | <tt><a>hexHexGrid</a> s</tt> returns a grid of hexagonal shape, with
--   sides of length <tt>s</tt>, using hexagonal tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>3*s*(s-1) + 1</tt>
--   tiles. Otherwise, the resulting grid will be null and the list of
--   indices will be null.
hexHexGrid :: Int -> HexHexGrid

-- | A rectangular grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectHexGrid
[RectHexGrid] :: (Int, Int) -> [(Int, Int)] -> RectHexGrid

-- | <tt><a>rectHexGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   hexagonal tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
rectHexGrid :: Int -> Int -> RectHexGrid
rectHexGridY :: Int -> Int -> Int
instance Constructor C1_0RectHexGrid
instance Datatype D1RectHexGrid
instance Constructor C1_0HexHexGrid
instance Datatype D1HexHexGrid
instance Constructor C1_0UnboundedHexGrid
instance Datatype D1UnboundedHexGrid
instance Constructor C1_5HexDirection
instance Constructor C1_4HexDirection
instance Constructor C1_3HexDirection
instance Constructor C1_2HexDirection
instance Constructor C1_1HexDirection
instance Constructor C1_0HexDirection
instance Datatype D1HexDirection
instance Generic RectHexGrid
instance Eq RectHexGrid
instance Generic HexHexGrid
instance Eq HexHexGrid
instance Generic UnboundedHexGrid
instance Show UnboundedHexGrid
instance Eq UnboundedHexGrid
instance Generic HexDirection
instance Eq HexDirection
instance Show HexDirection
instance Grid UnboundedHexGrid
instance Show HexHexGrid
instance Grid HexHexGrid
instance FiniteGrid HexHexGrid
instance BoundedGrid HexHexGrid
instance Show RectHexGrid
instance Grid RectHexGrid
instance FiniteGrid RectHexGrid
instance BoundedGrid RectHexGrid


-- | Same as <tt><a>Hexagonal</a></tt>, except the grids are oriented so
--   that the flat part of the hexagonal tiles is on the top. The
--   userguide, with illustrations, is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>. Also see
--   <tt>Math.Geometry.Grid</tt> for examples of how to use this class.
module Math.Geometry.Grid.Hexagonal2

-- | An unbounded grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedHexGrid
[UnboundedHexGrid] :: UnboundedHexGrid

-- | A hexagonal grid with hexagonal tiles The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data HexHexGrid

-- | <tt><a>hexHexGrid</a> s</tt> returns a grid of hexagonal shape, with
--   sides of length <tt>s</tt>, using hexagonal tiles. If <tt>s</tt> is
--   nonnegative, the resulting grid will have <tt>3*s*(s-1) + 1</tt>
--   tiles. Otherwise, the resulting grid will be null and the list of
--   indices will be null.
hexHexGrid :: Int -> HexHexGrid

-- | A rectangular grid with hexagonal tiles The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectHexGrid

-- | <tt><a>rectHexGrid</a> r c</tt> returns a grid in the shape of a
--   parallelogram with <tt>r</tt> rows and <tt>c</tt> columns, using
--   hexagonal tiles. If <tt>r</tt> and <tt>c</tt> are both nonnegative,
--   the resulting grid will have <tt>r*c</tt> tiles. Otherwise, the
--   resulting grid will be null and the list of indices will be null.
rectHexGrid :: Int -> Int -> RectHexGrid


-- | A module containing private <tt>OctGrid</tt> internals. Most
--   developers should use <tt>OctGrid</tt> instead. This module is subject
--   to change without notice.
module Math.Geometry.Grid.OctagonalInternal
data OctDirection
[West] :: OctDirection
[Northwest] :: OctDirection
[North] :: OctDirection
[Northeast] :: OctDirection
[East] :: OctDirection
[Southeast] :: OctDirection
[South] :: OctDirection
[Southwest] :: OctDirection

-- | An unbounded grid with octagonal tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedOctGrid
[UnboundedOctGrid] :: UnboundedOctGrid

-- | A rectangular grid with octagonal tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectOctGrid
[RectOctGrid] :: (Int, Int) -> [(Int, Int)] -> RectOctGrid

-- | <tt><a>rectOctGrid</a> r c</tt> produces a rectangular grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using octagonal tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
rectOctGrid :: Int -> Int -> RectOctGrid

-- | A toroidal grid with octagonal tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorOctGrid
[TorOctGrid] :: (Int, Int) -> [(Int, Int)] -> TorOctGrid

-- | <tt><a>torOctGrid</a> r c</tt> returns a toroidal grid with <tt>r</tt>
--   rows and <tt>c</tt> columns, using octagonal tiles. If <tt>r</tt> and
--   <tt>c</tt> are both nonnegative, the resulting grid will have
--   <tt>r*c</tt> tiles. Otherwise, the resulting grid will be null and the
--   list of indices will be null.
torOctGrid :: Int -> Int -> TorOctGrid
instance Constructor C1_0TorOctGrid
instance Datatype D1TorOctGrid
instance Constructor C1_0RectOctGrid
instance Datatype D1RectOctGrid
instance Constructor C1_0UnboundedOctGrid
instance Datatype D1UnboundedOctGrid
instance Constructor C1_7OctDirection
instance Constructor C1_6OctDirection
instance Constructor C1_5OctDirection
instance Constructor C1_4OctDirection
instance Constructor C1_3OctDirection
instance Constructor C1_2OctDirection
instance Constructor C1_1OctDirection
instance Constructor C1_0OctDirection
instance Datatype D1OctDirection
instance Generic TorOctGrid
instance Eq TorOctGrid
instance Generic RectOctGrid
instance Eq RectOctGrid
instance Generic UnboundedOctGrid
instance Show UnboundedOctGrid
instance Eq UnboundedOctGrid
instance Generic OctDirection
instance Eq OctDirection
instance Show OctDirection
instance Grid UnboundedOctGrid
instance Show RectOctGrid
instance Grid RectOctGrid
instance FiniteGrid RectOctGrid
instance BoundedGrid RectOctGrid
instance Show TorOctGrid
instance Grid TorOctGrid
instance FiniteGrid TorOctGrid
instance WrappedGrid TorOctGrid


-- | A regular arrangement of octagonal tiles. Octagons won't tile a
--   regular plane (there will be diamond-shaped gaps between the tiles),
--   but they will tile a <i>hyperbolic</i> plane. (Alternatively, you can
--   think of these as squares on a board game where diagonal moves are
--   allowed.) The userguide, with illustrations, is available at
--   <a>https://github.com/mhwombat/grid/wiki</a>. Also see
--   <tt>Math.Geometry.Grid</tt> for examples of how to use this class.
module Math.Geometry.Grid.Octagonal

-- | An unbounded grid with octagonal tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data UnboundedOctGrid
[UnboundedOctGrid] :: UnboundedOctGrid

-- | A rectangular grid with octagonal tiles. The grid and its indexing
--   scheme are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data RectOctGrid

-- | <tt><a>rectOctGrid</a> r c</tt> produces a rectangular grid with
--   <tt>r</tt> rows and <tt>c</tt> columns, using octagonal tiles. If
--   <tt>r</tt> and <tt>c</tt> are both nonnegative, the resulting grid
--   will have <tt>r*c</tt> tiles. Otherwise, the resulting grid will be
--   null and the list of indices will be null.
rectOctGrid :: Int -> Int -> RectOctGrid

-- | A toroidal grid with octagonal tiles. The grid and its indexing scheme
--   are illustrated in the user guide, available at
--   <a>https://github.com/mhwombat/grid/wiki</a>.
data TorOctGrid

-- | <tt><a>torOctGrid</a> r c</tt> returns a toroidal grid with <tt>r</tt>
--   rows and <tt>c</tt> columns, using octagonal tiles. If <tt>r</tt> and
--   <tt>c</tt> are both nonnegative, the resulting grid will have
--   <tt>r*c</tt> tiles. Otherwise, the resulting grid will be null and the
--   list of indices will be null.
torOctGrid :: Int -> Int -> TorOctGrid


-- | A regular arrangement of tiles. Grids have a variety of uses,
--   including games and self-organising maps. The userguide is available
--   at <a>https://github.com/mhwombat/grid/wiki</a>.
--   
--   In this package, tiles are called "triangular", "square", etc., based
--   on the number of <i>neighbours</i> they have. For example, a square
--   tile has four neighbours, and a hexagonal tile has six. There are only
--   three regular polygons that can tile a plane: triangles, squares, and
--   hexagons. Of course, other plane tilings are possible if you use
--   irregular polygons, or curved shapes, or if you combine tiles of
--   different shapes.
--   
--   When you tile other surfaces, things get very interesting. Octagons
--   will tile a <i>hyperbolic</i> plane. (Alternatively, you can think of
--   these as squares on a board game where diagonal moves are allowed.)
--   
--   For a board game, you probably want to choose the grid type based on
--   the number of <i>directions</i> a player can move, rather than the
--   number of sides the tile will have when you display it. For example,
--   for a game that uses square tiles and allows the user to move
--   diagonally as well as horizontally and vertically, consider using one
--   of the grids with <i>octagonal</i> tiles to model the board. You can
--   still <i>display</i> the tiles as squares, but for internal
--   calculations they are octagons.
--   
--   NOTE: Version 6.0 moved the various grid flavours to sub-modules.
--   
--   NOTE: Version 4.0 uses associated (type) synonyms instead of
--   multi-parameter type classes.
--   
--   NOTE: Version 3.0 changed the order of parameters for many functions.
--   This makes it easier for the user to write mapping and folding
--   operations.
module Math.Geometry.Grid

-- | A regular arrangement of tiles. Minimal complete definition:
--   <tt><a>Index</a></tt>, <tt><a>Direction</a></tt>,
--   <tt><a>indices</a></tt>, <tt><a>distance</a></tt>,
--   <tt><a>directionTo</a></tt>.
class Grid g where type family Index g type family Direction g minDistance = defaultMinDistance neighbours = defaultNeighbours neighboursOfSet = defaultNeighboursOfSet neighbour = defaultNeighbour numNeighbours g = length . neighbours g contains g a = a `elem` indices g tileCount = length . indices null g = tileCount g == 0 nonNull = not . null edges = defaultEdges viewpoint g p = map f (indices g) where f a = (a, distance g p a) isAdjacent = defaultIsAdjacent adjacentTilesToward = defaultAdjacentTilesToward minimalPaths = defaultMinimalPaths defaultMinDistance g xs a = minimum . map (distance g a) $ xs defaultNeighbours g a = filter (\ b -> distance g a b == 1) $ indices g defaultNeighboursOfSet g as = ns \\ as where ns = nub . concatMap (neighbours g) $ as defaultNeighbour g a d = maybeHead . filter (\ b -> [d] == directionTo g a b) . neighbours g $ a where maybeHead (x : _) = Just x maybeHead _ = Nothing defaultTileCount = length . indices defaultEdges g = nubBy sameEdge $ concatMap (`adjacentEdges` g) $ indices g defaultIsAdjacent g a b = distance g a b == 1 defaultAdjacentTilesToward g a b = filter f $ neighbours g a where f c = distance g c b == distance g a b - 1 defaultMinimalPaths g a b | a == b = [[a]] | distance g a b == 1 = [[a, b]] | otherwise = map (a :) xs where xs = concatMap (\ c -> minimalPaths g c b) ys ys = adjacentTilesToward g a b
indices :: Grid g => g -> [Index g]
distance :: Grid g => g -> Index g -> Index g -> Int
minDistance :: Grid g => g -> [Index g] -> Index g -> Int
neighbours :: (Grid g, Eq (Index g)) => g -> Index g -> [Index g]
neighbour :: (Grid g, Eq (Index g), Eq (Direction g)) => g -> Index g -> Direction g -> Maybe (Index g)
contains :: (Grid g, Eq (Index g)) => g -> Index g -> Bool
tileCount :: Grid g => g -> Int
null :: Grid g => g -> Bool
nonNull :: Grid g => g -> Bool
edges :: (Grid g, Eq (Index g)) => g -> [(Index g, Index g)]
viewpoint :: Grid g => g -> Index g -> [(Index g, Int)]
isAdjacent :: Grid g => g -> Index g -> Index g -> Bool
adjacentTilesToward :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [Index g]
minimalPaths :: (Grid g, Eq (Index g)) => g -> Index g -> Index g -> [[Index g]]
directionTo :: Grid g => g -> Index g -> Index g -> [Direction g]

-- | A regular arrangement of tiles where the number of tiles is finite.
--   Minimal complete definition: <tt><a>size</a></tt>,
--   <tt><a>maxPossibleDistance</a></tt>.
class Grid g => FiniteGrid g where type family Size g
size :: FiniteGrid g => g -> Size g
maxPossibleDistance :: FiniteGrid g => g -> Int

-- | A regular arrangement of tiles with an edge. Minimal complete
--   definition: <tt><a>tileSideCount</a></tt>.
class Grid g => BoundedGrid g where boundary = defaultBoundary isBoundary = defaultIsBoundary centre = defaultCentre isCentre = defaultIsCentre defaultBoundary g = map fst . filter f $ xds where xds = map (\ b -> (b, numNeighbours g b)) $ indices g f (_, n) = n < tileSideCount g defaultIsBoundary g a = a `elem` boundary g defaultCentre g = map fst . head . groupBy ((==) `on` snd) . sortBy (comparing snd) $ xds where xds = map (\ b -> (b, f b)) $ indices g bs = boundary g f x = sum . map (distance g x) $ bs defaultIsCentre g a = a `elem` centre g
tileSideCount :: BoundedGrid g => g -> Int
boundary :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
isBoundary :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
centre :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
isCentre :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
defaultBoundary :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
defaultIsBoundary :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool
defaultCentre :: (BoundedGrid g, Eq (Index g)) => g -> [Index g]
defaultIsCentre :: (BoundedGrid g, Eq (Index g)) => g -> Index g -> Bool


-- | Ordered maps from tiles on a grid to values. This module is a wrapper
--   around <tt><a>Grid</a></tt> and <tt><a>Map</a></tt>, in order to
--   combine the functionality of grids and maps into a single type.
module Math.Geometry.GridMap

-- | A regular arrangement of tiles, having a value associated with each
--   tile. Minimal complete definition: <tt>toMap</tt>, <tt>toGrid</tt>,
--   <tt>insertWithKey</tt>, <tt>delete</tt>, <tt>adjustWithKey</tt>,
--   <tt>alter</tt>, <tt>mapWithKey</tt>, <tt>filterWithKey</tt>.
--   
--   Once a <tt><a>GridMap</a></tt> is created, the underlying grid is
--   <i>fixed</i>; tiles cannot be added or removed. However, values can be
--   added to empty tiles, and the value at a tile can be modified or
--   removed.
--   
--   Note: Some of the methods have an <tt>Ord</tt> constraint on the grid
--   index. This is purely to make it easier to write implementations.
--   While tile positions can be ordered (e.g., <tt>(1,2) &lt; (2,1)</tt>),
--   the ordering may not be particularly meaningful. (Comparisons such as
--   <i>east of</i> or <i>south of</i> may be more sensible.) However, it
--   is convenient to write implementations of this class using
--   <tt>Data.Map</tt>, with the grid indices as keys. Many of the
--   functions in <tt>Data.Map</tt> impose the <tt>Ord</tt> constraint on
--   map keys, so we'll live with it. In summary, to use some methods in
--   this class, your grid indices must be orderable.
class (Grid (BaseGrid gm v), Foldable gm) => GridMap (gm :: * -> *) v where type family BaseGrid gm v (!) gm k = toMap gm ! k toList = toList . toMap lookup k = lookup k . toMap insert = insertWith const insertWith f = insertWithKey (\ _ x' y' -> f x' y') insertLookupWithKey f k v gm = (lookup k gm, insertWithKey f k v gm) adjust f = adjustWithKey (\ _ v -> f v) findWithDefault v k = findWithDefault v k . toMap keys = keys . toMap elems = elems . toMap map f = mapWithKey (\ _ v -> f v) filter p = filterWithKey (\ _ x -> p x)
(!) :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => gm v -> k -> v
toMap :: (GridMap gm v, k ~ (Index (BaseGrid gm v))) => gm v -> Map k v
toGrid :: GridMap gm v => gm v -> BaseGrid gm v
toList :: (GridMap gm v, k ~ (Index (BaseGrid gm v))) => gm v -> [(k, v)]
lookup :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => k -> gm v -> Maybe v
insert :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => k -> v -> gm v -> gm v
insertWith :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (v -> v -> v) -> k -> v -> gm v -> gm v
insertWithKey :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (k -> v -> v -> v) -> k -> v -> gm v -> gm v
insertLookupWithKey :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (k -> v -> v -> v) -> k -> v -> gm v -> (Maybe v, gm v)
delete :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => k -> gm v -> gm v
adjust :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (v -> v) -> k -> gm v -> gm v
adjustWithKey :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (k -> v -> v) -> k -> gm v -> gm v
alter :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => (Maybe v -> Maybe v) -> k -> gm v -> gm v
findWithDefault :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => v -> k -> gm v -> v
keys :: (GridMap gm v, k ~ (Index (BaseGrid gm v)), Ord k) => gm v -> [k]
elems :: GridMap gm v => gm v -> [v]
map :: (GridMap gm v, GridMap gm v2, Index (BaseGrid gm v) ~ Index (BaseGrid gm v2)) => (v -> v2) -> gm v -> gm v2
mapWithKey :: (GridMap gm v, k ~ Index (BaseGrid gm v), k ~ Index (BaseGrid gm v2), GridMap gm v2) => (k -> v -> v2) -> gm v -> gm v2
filter :: GridMap gm v => (v -> Bool) -> gm v -> gm v
filterWithKey :: (GridMap gm v, k ~ (Index (BaseGrid gm v))) => (k -> v -> Bool) -> gm v -> gm v

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
--   
--   <pre>
--   let f a len = len + (length a)
--   foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldr :: (a -> b -> b) -> b -> Map k a -> b

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Map k a -> b

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   For example,
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   let f len a = len + (length a)
--   foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4
--   </pre>
foldl :: (a -> b -> a) -> a -> Map k b -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Map k b -> a


-- | Ordered maps from tiles on a grid to values. This module is a wrapper
--   around <tt><a>Grid</a></tt> and <tt><a>Map</a></tt>, in order to
--   combine the functionality of grids and maps into a single type.
module Math.Geometry.GridMap.Lazy

-- | A map from tile positions in a grid to values.
data LGridMap g v

-- | Construct a grid map which is strict in the keys (tile positions), but
--   lazy in the values.
lazyGridMap :: (Ord (Index g), Grid g) => g -> [v] -> LGridMap g v
empty :: Grid g => g -> LGridMap g v
instance Selector S1_0_1LGridMap
instance Selector S1_0_0LGridMap
instance Constructor C1_0LGridMap
instance Datatype D1LGridMap
instance Generic (LGridMap g v)
instance (Grid g, Ord (Index g)) => Functor (LGridMap g)
instance Foldable (LGridMap g)
instance Grid g => Grid (LGridMap g v)
instance FiniteGrid g => FiniteGrid (LGridMap g v)
instance Grid g => GridMap (LGridMap g) v
instance (Eq g, Eq (Index g), Eq v) => Eq (LGridMap g v)
instance (Show g, Show v) => Show (LGridMap g v)
