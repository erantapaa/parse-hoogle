-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Memory map Vector from disk into memory efficiently
--   
--   Memory map Data.Packed.Vector.Vector from disk into memory
--   efficiently.
@package hmatrix-mmap
@version 0.0.5


-- | Functions to represent a <tt>Vector</tt> on disk in efficient, if
--   unportable, ways.
--   
--   This module uses memory-mapping, a feature of all modern
--   operating-systems, to mirror the disk contents in memory. There are
--   quite a few advantages to memory-mapping files instead of reading the
--   files traditionally:
--   
--   <ul>
--   <li>Speed: memory-mapping is often much faster than traditional
--   reading.</li>
--   <li>Memory efficiency: Memory-mapped files are loaded into RAM
--   on-demand, and easily swapped out. The upside is that the program can
--   work with data-sets larger than the available RAM, as long as they are
--   accessed carefully.</li>
--   </ul>
--   
--   The caveat to using memory-mapping is that it makes the files specific
--   to the current architecture because of the endianness of the data. For
--   more information, see the description in <a>System.IO.MMap</a>
--   
--   If you wish to write the contents in a portable fashion, either use
--   the ASCII load and save functions in <a>Numeric.Container</a>, or use
--   the binary serialization in <a>Data.Binary</a>.
module Data.Packed.Vector.MMap

-- | Map a file into memory (read-only) as a <tt>Vector</tt>.
--   
--   It is considered unsafe because changes to the underlying file may (or
--   may not) be reflected in the <tt>Vector</tt>, which breaks referential
--   transparency.
unsafeMMapVector :: Storable a => FilePath -> Maybe (Int64, Int) -> IO (Vector a)

-- | Map a file into memory as a lazy-list of equal-sized <tt>Vector</tt>,
--   even if they can't all fit in the address space at the same time.
--   
--   <pre>
--   (numVectors,vectors) &lt;- unsafeLazyMMapVectors filename Nothing vectorSize
--   </pre>
--   
--   Commonly, a data file will contain multiple vectors of equal length
--   (matrix). This function is convenient for those uses, but it plays a
--   more important role: supporting data-sets that cannot fit in the
--   address space of the current machine.
--   
--   On 32-bit machines the address space is only 4GB, and it is actually
--   pretty easy to find data-sets that are too large to be represented,
--   even in virtual memory.
--   
--   This function loads the data in chunks, and as long as you drop your
--   reference to the vectors as you consume the data, the old chunks will
--   be unmapped before mapping the next chunk.
--   
--   The number of vectors in the list is returned because it's often
--   needed, yet calculating it using <a>length</a> would demand the whole
--   list.
unsafeLazyMMapVectors :: Storable a => FilePath -> Maybe (Int64, Int64) -> Int -> IO (Int64, [Vector a])

-- | Write out a vector verbatim into an open file handle.
hPutVector :: Storable a => Handle -> Vector a -> IO ()

-- | Write the vector verbatim to a file.
writeVector :: Storable a => FilePath -> Vector a -> IO ()
