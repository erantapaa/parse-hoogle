-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type safe URLs for Snap
--   
--   Type safe URL generation and routing for Snap using <a>web-routes</a>,
--   and builds on <a>work</a> done by Jeremy Shaw.
--   
--   Get started with the comprehensive __<a>tutorial</a>__.
--   
--   = Brief overview
--   
--   It allows you to define a data type that represents the routes in your
--   application:
--   
--   <pre>
--   data AppUrl
--       = Login                   -- routes to /login
--       | Logout                  -- routes to /logout
--       | User (Resource UserId)  -- provides RESTful routes at /user
--   </pre>
--   
--   <a>Resource</a> is documented in Snap.Snaplet.Router.REST, and makes
--   defining RESTful routes easier. Also provided are functions to use the
--   URL data type in your app:
--   
--   <pre>
--   someHandler :: Handler App App ()
--   someHandler :: doSomething &gt;&gt; redirectURL $ User Index
--   </pre>
--   
--   and to generate URLs in views:
--   
--   <pre>
--   linksHandler :: Handler App App ()
--   linksHandler = heistLocal (I.bindSplices linksSplices) $ render "links"
--     where
--       linksSplices = do
--           "loginUrl" ## urlSplice Login
--   </pre>
@package snap-web-routes
@version 0.5.0.0


-- | This module provides data types useful for declaring RESTful routes.
--   <a>Resource</a> is provided for the common case of resource specified
--   by a unique identifier (for e.g. <tt>/products/3</tt>).
--   <a>SingletonResource</a> is provided for resources that do not require
--   an identifier. Typical usage would be as follows:
--   
--   <pre>
--   data AppUrl
--       = User (Resource Int)
--       | Profile SingletonResource
--       | Login
--       | Logout
--   </pre>
--   
--   This now allows you to define handlers for different end points for
--   your resource. <tt> routeAppUrl appUrl = case appUrl of Login -&gt;
--   with auth handleLogin -- /login Logout -&gt; with auth handleLogout --
--   /logout User Index -&gt; handleUserIndex -- /user User New -&gt;
--   handleUserNew -- /user/new User (Show n) -&gt; handleUserShow n --
--   /user/:Int User (Edit n) -&gt; handleUserEdit n -- /user/:Int/edit
--   Profile ShowS -&gt; handleProfileShow -- /profile Profile NewS -&gt;
--   handleProfileNew -- /profile/new Profile EditS -&gt; handleProfileEdit
--   -- /profile/edit </tt>
module Snap.Snaplet.Router.REST

-- | A data type to represent RESTful resources that have a unique
--   identifier. The data type used as the identifier must be an instance
--   of <a>PathInfo</a>.
data PathInfo id => Resource id
Index :: Resource id
New :: Resource id
Show :: id -> Resource id
Edit :: id -> Resource id

-- | A data type to represent singleton RESTful resources. Generally these
--   are identified in some other way, often the user's session.
data SingletonResource
ShowS :: SingletonResource
NewS :: SingletonResource
EditS :: SingletonResource
instance (Eq id, PathInfo id) => Eq (Resource id)
instance (Show id, PathInfo id) => Show (Resource id)
instance (Read id, PathInfo id) => Read (Resource id)
instance Eq SingletonResource
instance Show SingletonResource
instance Read SingletonResource
instance PathInfo SingletonResource
instance PathInfo id => PathInfo (Resource id)

module Snap.Snaplet.Router.Internal.Types
type Path = Text
data RouterState
RouterState :: Text -> RouterState
_prefix :: RouterState -> Text

-- | Instantiate this type class for <tt>Handler App App</tt> and
--   <tt>Handler b RouterState</tt> so that the snaplet can find its state.
--   An instance requires a type for <tt>URL m</tt> - being the URL data
--   type you have defined - and an instance of <tt>getRouterState</tt>.
--   Assuming your URL data type is called <tt>AppUrl</tt>, the instance
--   for <tt>Handler b RouterState</tt> would be
--   
--   <pre>
--   instance HasRouter (Handler b RouterState) where
--       type URL (Handler b RouterState) = AppUrl
--       getRouterState = get
--   </pre>
--   
--   If the lens for the <a>Router</a> snaplet is <tt>router</tt>, your
--   <tt>Handler App App</tt> instance would be
--   
--   <pre>
--   instance HasRouter (Handler App App) where
--       type URL (Handler App App) = AppUrl
--       getRouterState = with router get
--   </pre>
class Monad m => HasRouter m where type family URL m
getRouterState :: HasRouter m => m RouterState
instance HasRouter m => HasRouter (HeistT n m)

module Snap.Snaplet.Router.Types
data RouterState
RouterState :: Text -> RouterState
_prefix :: RouterState -> Text

-- | Instantiate this type class for <tt>Handler App App</tt> and
--   <tt>Handler b RouterState</tt> so that the snaplet can find its state.
--   An instance requires a type for <tt>URL m</tt> - being the URL data
--   type you have defined - and an instance of <tt>getRouterState</tt>.
--   Assuming your URL data type is called <tt>AppUrl</tt>, the instance
--   for <tt>Handler b RouterState</tt> would be
--   
--   <pre>
--   instance HasRouter (Handler b RouterState) where
--       type URL (Handler b RouterState) = AppUrl
--       getRouterState = get
--   </pre>
--   
--   If the lens for the <a>Router</a> snaplet is <tt>router</tt>, your
--   <tt>Handler App App</tt> instance would be
--   
--   <pre>
--   instance HasRouter (Handler App App) where
--       type URL (Handler App App) = AppUrl
--       getRouterState = with router get
--   </pre>
class Monad m => HasRouter m where type family URL m
getRouterState :: HasRouter m => m RouterState

-- | Simple parsing and rendering for a type to and from URL path segments.
--   
--   If you're using GHC 7.2 or later, you can use <tt>DeriveGeneric</tt>
--   to derive instances of this class:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   data Sitemap = Home | BlogPost Int deriving Generic
--   instance PathInfo Sitemap
--   </pre>
--   
--   This results in the following instance:
--   
--   <pre>
--   instance PathInfo Sitemap where
--       toPathSegments Home = ["home"]
--       toPathSegments (BlogPost x) = "blog-post" : toPathSegments x
--       fromPathSegments = Home &lt;$ segment "home"
--                      &lt;|&gt; BlogPost &lt;$ segment "blog-post" &lt;*&gt; fromPathSegments
--   </pre>
--   
--   And here it is in action:
--   
--   <pre>
--   &gt;&gt;&gt; toPathInfo (BlogPost 123)
--   "/blog-post/123"
--   
--   &gt;&gt;&gt; fromPathInfo "/blog-post/123" :: Either String Sitemap
--   Right (BlogPost 123)
--   </pre>
--   
--   To instead derive instances using <tt>TemplateHaskell</tt>, see
--   <a>web-routes-th</a>.
class PathInfo url

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a

module Snap.Snaplet.Router.URL

-- | Returns the path for the given URL
urlPath :: (HasRouter m, PathInfo (URL m)) => URL m -> m Path

-- | Returns the path with query string for the given URL and params
urlPathParams :: (HasRouter m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m Path

-- | Redirect to the path for the given URL
redirectURL :: (HasRouter m, MonadSnap m, PathInfo (URL m)) => URL m -> m ()

-- | Redirect to the path for the given URL with params as query string
redirectURLParams :: (HasRouter m, MonadSnap m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m ()

module Snap.Snaplet.Router.HeistSplices

-- | Returns the given URL as a <tt>Heist</tt> splice
urlSplice :: (HasRouter m, PathInfo (URL m)) => URL m -> m [Node]

-- | Returns the given URL as a <tt>Heist</tt> splice with query string for
--   params
urlParamsSplice :: (HasRouter m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m [Node]

module Snap.Snaplet.Router
data RouterState
RouterState :: Text -> RouterState
_prefix :: RouterState -> Text

-- | Instantiate this type class for <tt>Handler App App</tt> and
--   <tt>Handler b RouterState</tt> so that the snaplet can find its state.
--   An instance requires a type for <tt>URL m</tt> - being the URL data
--   type you have defined - and an instance of <tt>getRouterState</tt>.
--   Assuming your URL data type is called <tt>AppUrl</tt>, the instance
--   for <tt>Handler b RouterState</tt> would be
--   
--   <pre>
--   instance HasRouter (Handler b RouterState) where
--       type URL (Handler b RouterState) = AppUrl
--       getRouterState = get
--   </pre>
--   
--   If the lens for the <a>Router</a> snaplet is <tt>router</tt>, your
--   <tt>Handler App App</tt> instance would be
--   
--   <pre>
--   instance HasRouter (Handler App App) where
--       type URL (Handler App App) = AppUrl
--       getRouterState = with router get
--   </pre>
class Monad m => HasRouter m where type family URL m
getRouterState :: HasRouter m => m RouterState

-- | Snaplet initializer.
initRouter :: Text -> SnapletInit b RouterState

-- | Returns the path for the given URL
urlPath :: (HasRouter m, PathInfo (URL m)) => URL m -> m Path

-- | Returns the path with query string for the given URL and params
urlPathParams :: (HasRouter m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m Path

-- | Redirect to the path for the given URL
redirectURL :: (HasRouter m, MonadSnap m, PathInfo (URL m)) => URL m -> m ()

-- | Redirect to the path for the given URL with params as query string
redirectURLParams :: (HasRouter m, MonadSnap m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m ()

-- | Given a routing function, routes matching requests or calls
--   <a>pass</a>.
routeWith :: (PathInfo url, MonadSnap m) => (url -> m ()) -> m ()

-- | Given a routing function, routes matching requests or returns
--   debugging information. This is __not suitable for production__, but
--   can be useful in seeing what paths are available or determining why a
--   path isn't routing as expected.
routeWithDebug :: (PathInfo url, MonadSnap m) => (url -> m ()) -> m ()

-- | Returns the given URL as a <tt>Heist</tt> splice
urlSplice :: (HasRouter m, PathInfo (URL m)) => URL m -> m [Node]

-- | Returns the given URL as a <tt>Heist</tt> splice with query string for
--   params
urlParamsSplice :: (HasRouter m, PathInfo (URL m)) => URL m -> [(Text, Maybe Text)] -> m [Node]
