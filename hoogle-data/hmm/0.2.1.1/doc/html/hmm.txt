-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A hidden markov model library
--   
--   Data.HMM is a library for using Hidden Markov Models with Haskell.
--   Commonly used algoriths (i.e. the forward and backwards algorithms,
--   Viterbi, and Baum-Welch) are implemented. The best way to learn to use
--   it is to visit the tutorial at
--   http://izbicki.me/blog/using-hmms-in-haskell-for-bioinformatics. The
--   tutorial also includes performance benchmarks that you should be aware
--   of.
@package hmm
@version 0.2.1.1


-- | Data.HMM is a library for using Hidden Markov Models (HMMs) with
--   Haskell. HMMs are a common method of machine learning. All of the most
--   frequently used algorithms---the forward and backwards algorithms,
--   Viterbi, and Baum-Welch---are implemented in this library.
module Data.HMM

-- | The data types for our HMM.
data HMM stateType eventType
HMM :: [stateType] -> [eventType] -> (stateType -> Prob) -> (stateType -> stateType -> Prob) -> (stateType -> eventType -> Prob) -> HMM stateType eventType
states :: HMM stateType eventType -> [stateType]
events :: HMM stateType eventType -> [eventType]
initProbs :: HMM stateType eventType -> (stateType -> Prob)
transMatrix :: HMM stateType eventType -> (stateType -> stateType -> Prob)
outMatrix :: HMM stateType eventType -> (stateType -> eventType -> Prob)
type Prob = LogFloat

-- | forward algorithm determines the probability that a given event array
--   would be emitted by our HMM
forward :: (Eq eventType, Eq stateType, Show eventType, Show stateType) => HMM stateType eventType -> [eventType] -> Prob

-- | backwards algorithm does the same thing as the forward algorithm, just
--   a different implementation
backward :: (Eq eventType, Eq stateType, Show eventType, Show stateType) => HMM stateType eventType -> [eventType] -> Prob

-- | Viterbi's algorithm calculates the most probable path through our
--   states given an event array
viterbi :: (Eq eventType, Eq stateType, Show eventType, Show stateType) => HMM stateType eventType -> Array Int eventType -> [stateType]

-- | Baum-Welch is used to train an HMM
baumWelch :: (Eq eventType, Eq stateType, Show eventType, Show stateType) => HMM stateType eventType -> Array Int eventType -> Int -> HMM stateType eventType
baumWelchItr :: (Eq eventType, Eq stateType, Show eventType, Show stateType) => HMM stateType eventType -> Array Int eventType -> HMM stateType eventType

-- | Use simpleMM to create an untrained standard Markov model
simpleMM :: (Eq a1, Eq a, Num a, Show a1) => [a1] -> a -> HMM [a1] a1

-- | Use simpleHMM to create an untrained hidden Markov model
simpleHMM :: (Eq stateType, Show eventType, Show stateType) => [stateType] -> [eventType] -> HMM stateType eventType

-- | Joins 2 HMMs by connecting every state in the first HMM to every state
--   in the second, and vice versa, with probabilities based on the join
--   ratio
hmmJoin :: (Eq stateType, Eq eventType, Read stateType, Show stateType) => HMM stateType eventType -> HMM stateType eventType -> Prob -> HMM (Int, stateType) eventType

-- | initProbs should always equal 1; the others should equal the number of
--   states
verifyhmm :: HMM stateType eventType -> IO ()
loadHMM :: (Eq eventType, Eq stateType, Read stateType, Read eventType, Show eventType, Show stateType) => FilePath -> IO (HMM stateType eventType)

-- | saves the HMM to a file for later retrieval. HMMs can take a long time
--   to calculate, so this is very useful
saveHMM :: (Show stateType, Show eventType) => String -> HMM stateType eventType -> IO ()
instance (Show stateType, Show eventType) => Show (HMMArray stateType eventType)
instance (Read stateType, Read eventType) => Read (HMMArray stateType eventType)
instance Read LogFloat
instance (Show stateType, Show eventType) => Show (HMM stateType eventType)
