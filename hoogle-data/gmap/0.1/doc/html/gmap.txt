-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Composable maps and generic tries.
--   
--   Provides typeclass for and several implementations of composable maps
--   and generic tries. OrdMap is roughly equivalent to Data.Map . ListMap,
--   EitherMap, MaybeMap, TupleMap and EnumMap allow you to break down the
--   corresponding types. InjectKeys is the easiest way to define tries on
--   your own types, see EitherMap for a simple example. ChoiceMap and
--   TupleMap correspond to sum and product types, respectively. The
--   type-level syntax for creating maps is currently unwieldy. This will
--   improve significantly in the next version.
@package gmap
@version 0.1

module Data.GMap

-- | Type of composable maps. For an example of a composed map see
--   Data.GMap.ListMap
class (Eq k) => Map map k | map -> k
empty :: (Map map k) => map a
singleton :: (Map map k) => k -> a -> map a
pair :: (Map map k) => k -> k -> Maybe (a -> a -> map a)
fromAssocsWith :: (Map map k) => (a -> a -> a) -> [(k, a)] -> map a
fromAssocsMaybe :: (Map map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a
status :: (Map map k) => map a -> Status k a
nonEmpty :: (Map map k) => map a -> Maybe (map a)
addSize :: (Map map k) => map a -> Int# -> Int#
lookup :: (Map map k) => k -> map a -> Maybe a
lookupCont :: (Map map k) => (a -> Maybe b) -> k -> map a -> Maybe b
alter :: (Map map k) => (Maybe a -> Maybe a) -> k -> map a -> map a
insertWith :: (Map map k) => (a -> a) -> k -> a -> map a -> map a
insertWith' :: (Map map k) => (a -> a) -> k -> a -> map a -> map a
insertMaybe :: (Map map k) => (a -> Maybe a) -> k -> a -> map a -> map a
delete :: (Map map k) => k -> map a -> map a
adjustWith :: (Map map k) => (a -> a) -> k -> map a -> map a
adjustWith' :: (Map map k) => (a -> a) -> k -> map a -> map a
adjustMaybe :: (Map map k) => (a -> Maybe a) -> k -> map a -> map a
venn :: (Map map k) => (a -> b -> c) -> map a -> map b -> (map a, map c, map b)
venn' :: (Map map k) => (a -> b -> c) -> map a -> map b -> (map a, map c, map b)
vennMaybe :: (Map map k) => (a -> b -> Maybe c) -> map a -> map b -> (map a, map c, map b)
union :: (Map map k) => (a -> a -> a) -> map a -> map a -> map a
union' :: (Map map k) => (a -> a -> a) -> map a -> map a -> map a
unionMaybe :: (Map map k) => (a -> a -> Maybe a) -> map a -> map a -> map a
disjointUnion :: (Map map k) => map a -> map a -> map a
intersection :: (Map map k) => (a -> b -> c) -> map a -> map b -> map c
intersection' :: (Map map k) => (a -> b -> c) -> map a -> map b -> map c
intersectionMaybe :: (Map map k) => (a -> b -> Maybe c) -> map a -> map b -> map c
difference :: (Map map k) => map a -> map b -> map a
differenceMaybe :: (Map map k) => (a -> b -> Maybe a) -> map a -> map b -> map a
isSubsetOf :: (Map map k) => map a -> map b -> Bool
isSubmapOf :: (Map map k) => (a -> b -> Bool) -> map a -> map b -> Bool
map :: (Map map k) => (a -> b) -> map a -> map b
map' :: (Map map k) => (a -> b) -> map a -> map b
mapMaybe :: (Map map k) => (a -> Maybe b) -> map a -> map b
mapWithKey :: (Map map k) => (k -> a -> b) -> map a -> map b
mapWithKey' :: (Map map k) => (k -> a -> b) -> map a -> map b
filter :: (Map map k) => (a -> Bool) -> map a -> map a
foldElems :: (Map map k) => (a -> b -> b) -> b -> map a -> b
foldKeys :: (Map map k) => (k -> b -> b) -> b -> map a -> b
foldAssocs :: (Map map k) => (k -> a -> b -> b) -> b -> map a -> b
foldElems' :: (Map map k) => (a -> b -> b) -> b -> map a -> b
foldKeys' :: (Map map k) => (k -> b -> b) -> b -> map a -> b
foldAssocs' :: (Map map k) => (k -> a -> b -> b) -> b -> map a -> b
foldElemsUInt :: (Map map k) => (a -> Int# -> Int#) -> Int# -> map a -> Int#
valid :: (Map map k) => map a -> Maybe String
disjointUnionError :: a

-- | Raised by disjointUnion if the arguments are not disjoint. Note that
--   instances of Map are *not* required to test that arguments are
--   disjoint.
--   
--   This is the return type for the <a>status</a> method of the <a>Map</a>
--   class
data Status k a
None :: Status k a
One :: k -> a -> Status k a
Many :: Status k a

-- | Same as <a>vennMaybe</a> except that the new associated values are
--   strictly evaluated.
vennMaybe' :: (Map map k) => (a -> b -> Maybe c) -> map a -> map b -> (map a, map c, map b)

-- | Like <a>alter</a> except that the new associated value is strictly
--   evaluated
alter' :: (Map map k) => (Maybe a -> Maybe a) -> k -> map a -> map a

-- | Like <a>adjustMaybe</a> except that the new associated value is
--   strictly evaluated
adjustMaybe' :: (Map map k) => (a -> Maybe a) -> k -> map a -> map a

-- | Like <a>insertMaybe</a> except that if the key is already present the
--   new associated value is evaluated strictly. If the key is not present
--   then the supplied value is *not* evaluated strictly. (TODO Change
--   this)
insertMaybe' :: (Map map k) => (a -> Maybe a) -> k -> a -> map a -> map a

-- | Like <a>unionMaybe</a> except that the new associated values are
--   strictly evaluated
unionMaybe' :: (Map map k) => (a -> a -> Maybe a) -> map a -> map a -> map a

-- | Like <a>intersectionMaybe</a> except that the new associated values
--   are strictly evaluated
intersectionMaybe' :: (Map map k) => (a -> b -> Maybe c) -> map a -> map b -> map c

-- | Like <a>differenceMaybe</a> except that the new associated values are
--   strictly evaluated
differenceMaybe' :: (Map map k) => (a -> b -> Maybe a) -> map a -> map b -> map a

-- | Like <a>mapMaybe</a> except that the new associated values are
--   strictly evaluated
mapMaybe' :: (Map map k) => (a -> Maybe b) -> map a -> map b
isEmpty :: (Map map l) => map a -> Bool
isSingleton :: (Map map l) => map a -> Bool

-- | Write a new association in the map, overwriting any value currently
--   associated with the key.
insert :: (Map map k) => k -> a -> map a -> map a

-- | Write a new association in the map, overwriting any value currently
--   associated with the key. The new value is evaluated strictly.
insert' :: (Map map k) => k -> a -> map a -> map a

-- | Count the number of associations in a map.
size :: (Map map k) => map a -> Int

-- | Insert an unordered list of key/value pairs into a map. Repeated keys
--   will be overwritten by the last occurence of the key.
insertAssocs :: (Map map k) => [(k, a)] -> map a -> map a
insertAssocsWith :: (Map map k) => (a -> a -> a) -> [(k, a)] -> map a -> map a
insertAssocsMaybe :: (Map map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a -> map a
fromAssocs :: (Map map k) => [(k, a)] -> map a

-- | Monadic lookup.
lookupM :: (Map map k, Monad m) => k -> map a -> m a
keys :: (Map map k) => map a -> [k]
elems :: (Map map k) => map a -> [a]
assocs :: (Map map k) => map a -> [(k, a)]

-- | Maps which maintain some order on their keys, determined by
--   compareKey.
class (Map map k) => OrderedMap map k
compareKey :: (OrderedMap map k) => map a -> k -> k -> Ordering
fromAssocsAscWith :: (OrderedMap map k) => (a -> a -> a) -> [(k, a)] -> map a
fromAssocsAscMaybe :: (OrderedMap map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a
fromAssocsDescWith :: (OrderedMap map k) => (a -> a -> a) -> [(k, a)] -> map a
fromAssocsDescMaybe :: (OrderedMap map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a
foldElemsAsc :: (OrderedMap map k) => (a -> b -> b) -> b -> map a -> b
foldElemsDesc :: (OrderedMap map k) => (a -> b -> b) -> b -> map a -> b
foldKeysAsc :: (OrderedMap map k) => (k -> b -> b) -> b -> map a -> b
foldKeysDesc :: (OrderedMap map k) => (k -> b -> b) -> b -> map a -> b
foldAssocsAsc :: (OrderedMap map k) => (k -> a -> b -> b) -> b -> map a -> b
foldAssocsDesc :: (OrderedMap map k) => (k -> a -> b -> b) -> b -> map a -> b
foldElemsAsc' :: (OrderedMap map k) => (a -> b -> b) -> b -> map a -> b
foldElemsDesc' :: (OrderedMap map k) => (a -> b -> b) -> b -> map a -> b
foldKeysAsc' :: (OrderedMap map k) => (k -> b -> b) -> b -> map a -> b
foldKeysDesc' :: (OrderedMap map k) => (k -> b -> b) -> b -> map a -> b
foldAssocsAsc' :: (OrderedMap map k) => (k -> a -> b -> b) -> b -> map a -> b
foldAssocsDesc' :: (OrderedMap map k) => (k -> a -> b -> b) -> b -> map a -> b
fromAssocsAsc :: (OrderedMap map k) => [(k, a)] -> map a
fromAssocsDesc :: (OrderedMap map k) => [(k, a)] -> map a

-- | Insert an ascending list of associations into a map Duplicate keys are
--   replaced by the rightmost value
insertAssocsAsc :: (OrderedMap map k) => [(k, a)] -> map a -> map a

-- | Insert a descending list of associations into a map Duplicate keys are
--   replaced by the rightmost value
insertAssocsDesc :: (OrderedMap map k) => [(k, a)] -> map a -> map a

-- | Insert an ascending list of associations into a map Duplicate keys are
--   combined with the supplied function
insertAssocsAscWith :: (OrderedMap map k) => (a -> a -> a) -> [(k, a)] -> map a -> map a

-- | Insert a descending list of associations into a map Duplicate keys are
--   combined with the supplied function
insertAssocsDescWith :: (OrderedMap map k) => (a -> a -> a) -> [(k, a)] -> map a -> map a

-- | Same as <a>insertAssocsAscWith</a> except that if Nothing is returned
--   then the key is discarded
insertAssocsAscMaybe :: (OrderedMap map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a -> map a

-- | Same as <a>insertAssocsDescWith</a> except that if Nothing is returned
--   then the key is discarded
insertAssocsDescMaybe :: (OrderedMap map k) => (a -> a -> Maybe a) -> [(k, a)] -> map a -> map a

-- | List the elements in the map in ascending order of keys.
elemsAsc :: (OrderedMap map k) => map a -> [a]

-- | List the elements in the map in descending order of keys.
elemsDesc :: (OrderedMap map k) => map a -> [a]

-- | List all associations in the map in ascending order of keys.
assocsAsc :: (OrderedMap map k) => map a -> [(k, a)]

-- | List all associations in the map in descending order of keys.
assocsDesc :: (OrderedMap map k) => map a -> [(k, a)]

-- | List all keys in the map in ascending order.
keysAsc :: (OrderedMap map k) => map a -> [k]

-- | List all keys in the map in descending order.
keysDesc :: (OrderedMap map k) => map a -> [k]

-- | Similar to <a>isSubsetOf</a>, but also requires that the size of the
--   second map is greater than the first (so does not include the case
--   where the key sets are identical).
isProperSubsetOf :: (Map map k) => map a -> map b -> Bool

-- | Similar to <a>isSubmapOf</a>, but also requires that the size of the
--   second map is greater than the first (so does not include the case
--   where the key sets are identical).
isProperSubmapOfBy :: (Map map k) => (a -> b -> Bool) -> map a -> map b -> Bool

-- | Use a map of the supplied type to sort a list of keys into ascending
--   order Slower than nubAscWith, but retains duplicate keys
sortAscWith :: (OrderedMap map k) => map Int -> [k] -> [k]

-- | Use a map of the supplied type to sort a list of keys into descending
--   order Slower than nubDescWith, but retains duplicate keys
sortDescWith :: (OrderedMap map k) => map Int -> [k] -> [k]

-- | Use a map of the supplied type to sort a list of keys into ascending
--   order (eliminating duplicates).
nubAscWith :: (OrderedMap map k) => map () -> [k] -> [k]

-- | Use a map of the supplied type to sort a list of keys into descending
--   order (eliminating duplicates).
nubDescWith :: (OrderedMap map k) => map () -> [k] -> [k]
instance (Eq k, Eq a) => Eq (Status k a)

module Data.GMap.AssocList
newtype AList k a
AL :: [(k, a)] -> AList k a
newtype SList map :: (* -> *) k a
SL :: [(k, a)] -> SList k a
sl :: (OrderedMap mp k) => [(k, a)] -> SList mp k a
data ImaginaryOrdMap k a
type OList k = SList (ImaginaryOrdMap k) k
instance (Eq k, Ord k) => OrderedMap (ImaginaryOrdMap k) k
instance (Eq k) => Map (ImaginaryOrdMap k) k
instance (Eq k, Ord k, OrderedMap mp k) => OrderedMap (SList mp k) k
instance (Eq k, Ord k, OrderedMap mp k) => Map (SList mp k) k
instance (Eq k) => Map (AList k) k

module Data.GMap.OrdMap

-- | The default <a>Map</a> type any key type which is an instance of
--   <a>Ord</a>. This is a newtype wrapper around
--   <tt><tt>Data.Tree.AVL.AVL</tt> (k,a)</tt>.
data OrdMap k a
instance Foldable (OrdMap k)
instance (Ord k, Monoid a) => Monoid (OrdMap k a)
instance Functor (OrdMap k)
instance (Typeable1 (OrdMap k), Typeable a) => Typeable (OrdMap k a)
instance (Ord k, Typeable k) => Typeable1 (OrdMap k)
instance (Ord k, Read k, Read a) => Read (OrdMap k a)
instance (Ord k, Show k, Show a) => Show (OrdMap k a)
instance (Ord k, Ord a) => Ord (OrdMap k a)
instance (Eq k, Eq a) => Eq (OrdMap k a)
instance (Ord k) => OrderedMap (OrdMap k) k
instance (Ord k) => Map (OrdMap k) k

module Data.GMap.IntMap

-- | The GT type for <a>Int</a> keys.
data IntMap a
instance (Eq a) => Eq (IAList a)
instance (Ord a) => Ord (IAList a)
instance Foldable IntMap
instance (Monoid a) => Monoid (IntMap a)
instance Functor IntMap
instance (Typeable a) => Typeable (IntMap a)
instance Typeable1 IntMap
instance (Read a) => Read (IntMap a)
instance (Show a) => Show (IntMap a)
instance (Ord a) => Ord (IntMap a)
instance (Eq a) => Eq (IntMap a)
instance OrderedMap IntMap Int
instance Map IntMap Int

module Data.GMap.ListMap

-- | The <a>Map</a> type for keys of form <tt><a>Map</a> map k =&gt;
--   [k]</tt>.
data ListMap map k a
instance (Map map k) => Foldable (ListMap map k)
instance (Map map k, Monoid a) => Monoid (ListMap map k a)
instance (Map map k) => Functor (ListMap map k)
instance (Typeable1 (ListMap map k), Typeable a) => Typeable (ListMap map k a)
instance (Typeable1 map, Typeable k) => Typeable1 (ListMap map k)
instance (Map map k, Read k, Read a) => Read (ListMap map k a)
instance (Map map k, Show k, Show a) => Show (ListMap map k a)
instance (Map map k, Ord k, Ord a, Ord (map (ListMap map k a))) => Ord (ListMap map k a)
instance (Eq k, Eq a, Eq (map (ListMap map k a))) => Eq (ListMap map k a)
instance (OrderedMap map k) => OrderedMap (ListMap map k) [k]
instance (Map map k) => Map (ListMap map k) [k]

module Data.GMap.InjectKeys
data InjectKeys t k1 k2 map a

-- | <tt>t</tt> is a phantom type which determines the encoding and
--   decoding functions used. <tt>t</tt> is passed as an undefined value.
--   <a>inject</a> must be injective (ie (inject a) == (inject b) implies a
--   == b) and reversible by <a>outject</a>
class Injection t k1 k2 | t -> k1, t -> k2
inject :: (Injection t k1 k2) => t -> k1 -> k2
outject :: (Injection t k1 k2) => t -> k2 -> k1
instance (Map map k2) => Foldable (InjectKeys t k1 k2 map)
instance (Map map k2, Monoid a) => Monoid (InjectKeys t k1 k2 map a)
instance (Map map k2) => Functor (InjectKeys t k1 k2 map)
instance (Typeable1 (InjectKeys t k1 k2 map), Typeable a) => Typeable (InjectKeys t k1 k2 map a)
instance (Typeable1 map) => Typeable1 (InjectKeys t k1 k2 map)
instance (Ord (map a)) => Ord (InjectKeys t k1 k2 map a)
instance (Eq (map a)) => Eq (InjectKeys t k1 k2 map a)
instance (Eq k1, Injection t k1 k2, OrderedMap map k2) => OrderedMap (InjectKeys t k1 k2 map) k1
instance (Eq k1, Injection t k1 k2, Map map k2) => Map (InjectKeys t k1 k2 map) k1

module Data.GMap.ChoiceMap
data Choice2 a b
C1of2 :: a -> Choice2 a b
C2of2 :: b -> Choice2 a b

-- | The <a>Map</a> type for keys of form <tt>(<a>Map</a> mapL kL,
--   <a>Map</a> mapR kR) =&gt; <a>Choice2</a> kL kR</tt>.
data Choice2Map mapL mapR kL kR a
data Choice3 a b c
C1of3 :: a -> Choice3 a b c
C2of3 :: b -> Choice3 a b c
C3of3 :: c -> Choice3 a b c
type Choice3Map mapa mapb mapc a b c = InjectKeys (InjectChoice3 a b c) (Choice3 a b c) (Choice2 a (Choice2 b c)) (Choice2Map mapa (Choice2Map mapb mapc b c) a (Choice2 b c))
data Choice4 a b c d
C1of4 :: a -> Choice4 a b c d
C2of4 :: b -> Choice4 a b c d
C3of4 :: c -> Choice4 a b c d
C4of4 :: d -> Choice4 a b c d
type Choice4Map mapa mapb mapc mapd a b c d = InjectKeys (InjectChoice4 a b c d) (Choice4 a b c d) (Choice2 (Choice2 a b) (Choice2 c d)) (Choice2Map (Choice2Map mapa mapb a b) (Choice2Map mapc mapd c d) (Choice2 a b) (Choice2 c d))
data Choice5 a b c d e
C1of5 :: a -> Choice5 a b c d e
C2of5 :: b -> Choice5 a b c d e
C3of5 :: c -> Choice5 a b c d e
C4of5 :: d -> Choice5 a b c d e
C5of5 :: e -> Choice5 a b c d e
type Choice5Map mapa mapb mapc mapd mape a b c d e = InjectKeys (InjectChoice5 a b c d e) (Choice5 a b c d e) (Choice2 (Choice2 a b) (Choice2 c (Choice2 d e))) (Choice2Map (Choice2Map mapa mapb a b) (Choice2Map mapc (Choice2Map mapd mape d e) c (Choice2 d e)) (Choice2 a b) (Choice2 c (Choice2 d e)))
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (Choice5 a b c d e)
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (Choice5 a b c d e)
instance (Read a, Read b, Read c, Read d, Read e) => Read (Choice5 a b c d e)
instance (Show a, Show b, Show c, Show d, Show e) => Show (Choice5 a b c d e)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (Choice4 a b c d)
instance (Ord a, Ord b, Ord c, Ord d) => Ord (Choice4 a b c d)
instance (Read a, Read b, Read c, Read d) => Read (Choice4 a b c d)
instance (Show a, Show b, Show c, Show d) => Show (Choice4 a b c d)
instance (Eq a, Eq b, Eq c) => Eq (Choice3 a b c)
instance (Ord a, Ord b, Ord c) => Ord (Choice3 a b c)
instance (Read a, Read b, Read c) => Read (Choice3 a b c)
instance (Show a, Show b, Show c) => Show (Choice3 a b c)
instance (Eq a, Eq b) => Eq (Choice2 a b)
instance (Ord a, Ord b) => Ord (Choice2 a b)
instance (Read a, Read b) => Read (Choice2 a b)
instance (Show a, Show b) => Show (Choice2 a b)
instance Injection (InjectChoice5 a b c d e) (Choice5 a b c d e) (Choice2 (Choice2 a b) (Choice2 c (Choice2 d e)))
instance Injection (InjectChoice4 a b c d) (Choice4 a b c d) (Choice2 (Choice2 a b) (Choice2 c d))
instance Injection (InjectChoice3 a b c) (Choice3 a b c) (Choice2 a (Choice2 b c))
instance (Map mapL kL, Map mapR kR) => Foldable (Choice2Map mapL mapR kL kR)
instance (Map mapL kL, Map mapR kR, Monoid a) => Monoid (Choice2Map mapL mapR kL kR a)
instance (Map mapL kL, Map mapR kR) => Functor (Choice2Map mapL mapR kL kR)
instance (Typeable1 (Choice2Map mapL mapR kL kR), Typeable a) => Typeable (Choice2Map mapL mapR kL kR a)
instance (Typeable1 mapL, Typeable1 mapR) => Typeable1 (Choice2Map mapL mapR kL kR)
instance (Map mapL kL, Map mapR kR, Read kL, Read kR, Read a) => Read (Choice2Map mapL mapR kL kR a)
instance (Map mapL kL, Map mapR kR, Show kL, Show kR, Show a) => Show (Choice2Map mapL mapR kL kR a)
instance (Map mapL kL, Map mapR kR, Ord (mapL a), Ord (mapR a)) => Ord (Choice2Map mapL mapR kL kR a)
instance (Eq (mapL a), Eq (mapR a)) => Eq (Choice2Map mapL mapR kL kR a)
instance (OrderedMap mapL kL, OrderedMap mapR kR) => OrderedMap (Choice2Map mapL mapR kL kR) (Choice2 kL kR)
instance (Map mapL kL, Map mapR kR) => Map (Choice2Map mapL mapR kL kR) (Choice2 kL kR)

module Data.GMap.EitherMap
type EitherMap mapL mapR l r = InjectKeys (InjectEither l r) (Either l r) (Choice2 l r) (Choice2Map mapL mapR l r)
instance Injection (InjectEither l r) (Either l r) (Choice2 l r)

module Data.GMap.UnitMap

-- | The default <a>Map</a> type unit (empty tuple) keys.
data UnitMap a
instance Foldable UnitMap
instance (Monoid a) => Monoid (UnitMap a)
instance Functor UnitMap
instance (Typeable a) => Typeable (UnitMap a)
instance Typeable1 UnitMap
instance (Read a) => Read (UnitMap a)
instance (Show a) => Show (UnitMap a)
instance (Ord a) => Ord (UnitMap a)
instance (Eq a) => Eq (UnitMap a)
instance OrderedMap UnitMap ()
instance Map UnitMap ()

module Data.GMap.MaybeMap
type MaybeMap map k = InjectKeys (InjectMaybe k) (Maybe k) (Choice2 k ()) (Choice2Map map UnitMap k ())
instance Injection (InjectMaybe k) (Maybe k) (Choice2 k ())

module Data.GMap.CacheKeys

-- | A map transformer that causes keys to be cached alongside elements
data CacheKeys mp k a
cacheKeys :: (Map mp k) => mp a -> CacheKeys mp k a
uncacheKeys :: (Map mp k) => CacheKeys mp k a -> mp a
instance (Map mp k) => Foldable (CacheKeys mp k)
instance (Map mp k, Monoid a) => Monoid (CacheKeys mp k a)
instance (Map mp k) => Functor (CacheKeys mp k)
instance (Typeable1 (CacheKeys mp k), Typeable a) => Typeable (CacheKeys mp k a)
instance (Typeable1 mp) => Typeable1 (CacheKeys mp k)
instance (Read k, Read a, Map mp k) => Read (CacheKeys mp k a)
instance (Show k, Show a, Map mp k) => Show (CacheKeys mp k a)
instance (Ord (mp (k, a))) => Ord (CacheKeys mp k a)
instance (Eq (mp (k, a))) => Eq (CacheKeys mp k a)
instance (OrderedMap mp k) => OrderedMap (CacheKeys mp k) k
instance (Map mp k) => Map (CacheKeys mp k) k

module Data.GMap.EnumMap
type EnumMap k = InjectKeys (InjectEnum k) k Int IntMap
instance (Enum k) => Injection (InjectEnum k) k Int

module Data.GMap.TupleMap
data Tuple2Map map1 map2 k1 k2 a
type Tuple3Map mapa mapb mapc a b c = InjectKeys (InjectTuple3 a b c) (a, b, c) (a, (b, c)) (Tuple2Map mapa (Tuple2Map mapb mapc b c) a (b, c))
type Tuple4Map mapa mapb mapc mapd a b c d = InjectKeys (InjectTuple4 a b c d) (a, b, c, d) (a, (b, (c, d))) (Tuple2Map mapa (Tuple2Map mapb (Tuple2Map mapc mapd c d) b (c, d)) a (b, (c, d)))
type Tuple5Map mapa mapb mapc mapd mape a b c d e = InjectKeys (InjectTuple5 a b c d e) (a, b, c, d, e) (a, (b, (c, (d, e)))) (Tuple2Map mapa (Tuple2Map mapb (Tuple2Map mapc (Tuple2Map mapd mape d e) c (d, e)) b (c, (d, e))) a (b, (c, (d, e))))
instance Injection (InjectTuple5 a b c d e) (a, b, c, d, e) (a, (b, (c, (d, e))))
instance Injection (InjectTuple4 a b c d) (a, b, c, d) (a, (b, (c, d)))
instance Injection (InjectTuple3 a b c) (a, b, c) (a, (b, c))
instance (Map map1 k1, Map map2 k2) => Foldable (Tuple2Map map1 map2 k1 k2)
instance (Map map1 k1, Map map2 k2, Monoid a) => Monoid (Tuple2Map map1 map2 k1 k2 a)
instance (Map map1 k1, Map map2 k2) => Functor (Tuple2Map map1 map2 k1 k2)
instance (Typeable1 (Tuple2Map map1 map2 k1 k2), Typeable a) => Typeable (Tuple2Map map1 map2 k1 k2 a)
instance (Typeable1 map1, Typeable1 map2) => Typeable1 (Tuple2Map map1 map2 k1 k2)
instance (Map map1 k1, Map map2 k2, Read k1, Read k2, Read a) => Read (Tuple2Map map1 map2 k1 k2 a)
instance (Map map1 k1, Map map2 k2, Show k1, Show k2, Show a) => Show (Tuple2Map map1 map2 k1 k2 a)
instance (Map map1 k1, Map map2 k2, Ord (map1 (map2 a))) => Ord (Tuple2Map map1 map2 k1 k2 a)
instance (Eq (map1 (map2 a))) => Eq (Tuple2Map map1 map2 k1 k2 a)
instance (OrderedMap map1 k1, OrderedMap map2 k2) => OrderedMap (Tuple2Map map1 map2 k1 k2) (k1, k2)
instance (Map map1 k1, Map map2 k2) => Map (Tuple2Map map1 map2 k1 k2) (k1, k2)

module Test.GMap.Utils
data Test m1 m2
SimpleTest :: (m1 -> b) -> Test m1 m2
SimpleTest2 :: ((m1, m1) -> b) -> Test m1 m2
CompareTest :: (m1 -> a -> b) -> (m2 -> a -> b) -> Test m1 m2
CompareTest2 :: ((m1, m1) -> a -> b) -> ((m2, m2) -> a -> b) -> Test m1 m2
compareTest :: (OrderedMap mp1 k, OrderedMap mp2 k, Arbitrary a, Show a, Eq b, Ord k) => (forall mp. (OrderedMap mp k, Eq k, Ord k) => (mp e) -> a -> b) -> Test (mp1 e) (mp2 e)
compareTest2 :: (OrderedMap mp1 k, OrderedMap mp2 k, Arbitrary a, Show a, Eq b, Ord k) => (forall mp. (OrderedMap mp k, Eq k, Ord k) => (mp e, mp e) -> a -> b) -> Test (mp1 e) (mp2 e)
type Tests m1 m2 = [(Test m1 m2, String)]
runTests :: (Testable (Test m1 m2)) => Tests m1 m2 -> Int -> IO ()
runAListTest :: (OrderedMap mp k, Testable (Test (mp a) (AList k a))) => (mp a) -> Tests (mp a) (AList k a) -> Int -> IO ()
runSListTest :: (OrderedMap mp k, Testable (Test (mp a) (SList mp k a))) => (mp a) -> Tests (mp a) (SList mp k a) -> Int -> IO ()
instance [incoherent] (OrderedMap mp1 k, OrderedMap mp2 k, Show (mp1 a), Show (mp2 a), Arbitrary k, Arbitrary a, Show k, Show a) => Testable (Test (mp1 a) (mp2 a))
instance [incoherent] (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e) => Arbitrary (Choice5 a b c d e)
instance [incoherent] (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => Arbitrary (Choice4 a b c d)
instance [incoherent] (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (Choice3 a b c)
instance [incoherent] (Arbitrary a, Arbitrary b) => Arbitrary (Choice2 a b)
instance [incoherent] (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e) => Arbitrary (a, b, c, d, e)
instance [incoherent] Arbitrary Char
instance [incoherent] (OrderedMap map k, Show k, Show a) => Show (map a)
instance [incoherent] (OrderedMap map k, Arbitrary k, Arbitrary a) => Arbitrary (map a)
instance [incoherent] Show (a -> b)

module Test.GMap
mapSortKeys :: (OrderedMap map k) => map a -> [k] -> [k]
mapSortAssocs :: (OrderedMap map k) => map a -> [(k, a)] -> [(k, a)]
isLazyMerge :: (OrderedMap map k) => map a -> map a -> k -> (map a -> map a -> map a) -> Bool
isStrictMerge :: (OrderedMap map k) => map a -> map a -> k -> (map a -> map a -> map a) -> Bool
vennAssocs :: (OrderedMap map k, Ord k) => (map a, map a, map a) -> ([(k, a)], [(k, a)], [(k, a)])
keyedLike :: (OrderedMap map k) => map a -> map b -> map a
