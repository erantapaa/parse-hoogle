-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Regional memory pointers
--   
--   The library allows you to allocate memory in a region yielding a
--   regional pointer to it. When the region terminates all pointers are
--   automatically freed. Most importantly, a pointer can't be returned
--   from the region. So it's impossible to reference unallocated memory.
--   
--   The primary technique used in this package is called "Lightweight
--   monadic regions" which was invented by Oleg Kiselyov and Chung-chieh
--   Shan. See:
--   
--   <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a>
--   
--   This technique is implemented in the <tt>regions</tt> package which is
--   re-exported from this library.
--   
--   This library provides wrappers around all the <tt>Ptr</tt> functions
--   from the <tt>Foreign.*</tt> modules of the <tt>base</tt> library.
@package regional-pointers
@version 0.7


-- | <i>Unsafe</i> functions for constructing regional pointers, retrieving
--   the native <tt>Ptr</tt> from a regional pointer and for lifting
--   operations on <tt>Ptrs</tt> to <tt>RegionalPtrs</tt>.
module Foreign.Ptr.Region.Unsafe

-- | Construct a regional pointer from a native pointer and an <tt>IO</tt>
--   computation that finalizes the pointer (like <tt>free ptr</tt>) which
--   is performed when the region terminates.
--   
--   This function is unsafe because this library can't guarantee that the
--   finalizer will actually finalize the pointer (suppose having
--   <tt>return ()</tt> as the finalizer). You have to verify the correct
--   finalisation yourself.
unsafeRegionalPtr :: MonadIO pr => Ptr α -> Finalizer -> RegionT s pr (RegionalPtr α (RegionT s pr))
wrapAlloca :: RegionControlIO pr => ((Ptr α -> IO (RegionT s pr β)) -> IO (RegionT s pr β)) -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β
wrapAlloca2 :: RegionControlIO pr => ((γ -> Ptr α -> IO (RegionT s pr β)) -> IO (RegionT s pr β)) -> (forall sl. γ -> LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β
wrapMalloc :: RegionControlIO pr => IO (Ptr α) -> RegionT s pr (RegionalPtr α (RegionT s pr))
wrapPeekStringLen :: (Pointer pointer, AncestorRegion pr cr, MonadIO cr) => ((Ptr α, Int) -> IO String) -> (pointer α pr, Int) -> cr String
wrapNewStringLen :: RegionControlIO pr => IO (Ptr α, Int) -> RegionT s pr (RegionalPtr α (RegionT s pr), Int)
wrapWithStringLen :: RegionControlIO pr => (((Ptr α, Int) -> IO (RegionT s pr β)) -> IO (RegionT s pr β)) -> (forall sl. (LocalPtr α (LocalRegion sl s), Int) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Retrieve the native pointer from a regional pointer.
--   
--   This function is unsafe because it allows you to both <tt>free</tt>
--   the pointer before the region terminates and use the pointer outside
--   the region when it is already freed.
unsafePtr :: Pointer pointer => pointer α r -> Ptr α
unsafeWrap :: (MonadIO m, Pointer pointer) => (Ptr α -> IO β) -> (pointer α r -> m β)
unsafeWrap2 :: (MonadIO m, Pointer pointer) => (Ptr α -> γ -> IO β) -> (pointer α r -> γ -> m β)
unsafeWrap3 :: (MonadIO m, Pointer pointer) => (Ptr α -> γ -> δ -> IO β) -> (pointer α r -> γ -> δ -> m β)
unsafeWrap2flp :: (MonadIO m, Pointer pointer) => (γ -> Ptr α -> IO β) -> (γ -> pointer α r -> m β)


module Foreign.Ptr.Region

-- | A regional pointer to memory.
--   
--   This should provide a safer replacement for
--   <tt>Foreign.Ptr.<a>Ptr</a></tt>
data RegionalPtr α r :: (* -> *)

-- | The constant <tt>nullPtr</tt> is a pointer which is not associated
--   with a valid memory location.
--   
--   Note that <tt>nullPtr</tt> is a pure value. This means it does not
--   perform the side-effect of registering a finalizer like "<tt>free
--   nullPtr</tt>" in the <a>RegionT</a> monad.
--   
--   Finally note that the region parameter of the <a>NullPtr</a> is set to
--   <a>RootRegion</a> which is the ancestor of any region. This allows
--   <a>nullPtr</a> to be used in any region.
nullPtr :: NullPtr α RootRegion
data NullPtr α r :: (* -> *)
class Pointer pointer :: (* -> (* -> *) -> *)
mapPointer :: Pointer pointer => (Ptr α -> Ptr β) -> (pointer α r -> pointer β r)

-- | Class of pointers which point to allocated memory. <a>NullPtr</a> is
--   the only pointer which is not an instance of this class.
--   
--   The super class <a>PrivateAllocatedPointer</a> is not exported by this
--   module which ensures you can't accidentally make <a>NullPtr</a> an
--   instance of this class.
class PrivateAllocatedPointer pointer => AllocatedPointer pointer

-- | The <tt>castPtr</tt> function casts a pointer from one type to
--   another.
--   
--   Wraps: <tt>Foreign.Ptr.</tt><a>castPtr</a>
castPtr :: Pointer pointer => pointer α r -> pointer β r

-- | Given an arbitrary address and an alignment constraint,
--   <tt>alignPtr</tt> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
--   
--   Wraps: <tt>Foreign.Ptr.</tt><a>alignPtr</a>
alignPtr :: AllocatedPointer pointer => pointer α r -> Int -> pointer α r

-- | Advances the given address by the given offset in bytes.
--   
--   Wraps: <tt>Foreign.Ptr.</tt><a>plusPtr</a>
plusPtr :: AllocatedPointer pointer => pointer α r -> Int -> pointer β r

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
--   
--   Wraps: <tt>Foreign.Ptr.</tt><a>minusPtr</a>
minusPtr :: AllocatedPointer pointer => pointer α r1 -> pointer β r2 -> Int


module Foreign.Marshal.Alloc.Region

-- | A regional pointer to memory which was locally allocated by one of the
--   <tt>alloca</tt>-like functions.
--   
--   Note that a <tt>LocalPtr</tt> can not be <a>dup</a>licated to a parent
--   region.
data LocalPtr α r :: (* -> *)

-- | <tt><a>alloca</a> f</tt> executes the computation <tt>f</tt>, passing
--   as argument a pointer to a temporarily allocated block of memory
--   sufficient to hold values of type <tt>α</tt>.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception).
--   
--   This should provide a safer replacement for:
--   <tt>Foreign.Marshal.Alloc.<a>alloca</a></tt>.
alloca :: (Storable α, RegionControlIO pr) => (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | <tt><a>allocaBytes</a> n f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory of <tt>n</tt> bytes. The block of memory is sufficiently
--   aligned for any of the basic foreign types that fits into a memory
--   block of the allocated size.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception).
--   
--   This should provide a safer replacement for:
--   <tt>Foreign.Marshal.Alloc.<a>allocaBytes</a></tt>.
allocaBytes :: RegionControlIO pr => Int -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | This should provide a safer replacement for:
--   <tt>Foreign.Marshal.Alloc.<a>allocaBytesAligned</a></tt>.
allocaBytesAligned :: RegionControlIO pr => Int -> Int -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Allocate a block of memory that is sufficient to hold values of type
--   <tt>α</tt>.
--   
--   Note that: <tt>malloc = <a>mallocBytes</a> $ <a>sizeOf</a> (undefined
--   :: α)</tt>
--   
--   This should provide a safer replacement for:
--   <tt>Foreign.Marshal.Alloc.<a>malloc</a></tt>.
malloc :: (Storable α, RegionControlIO pr) => RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Allocate a block of memory of the given number of bytes. The block of
--   memory is sufficiently aligned for any of the basic foreign types that
--   fits into a memory block of the allocated size.
--   
--   This should provide a safer replacement for:
--   <tt>Foreign.Marshal.Alloc.<a>mallocBytes</a></tt>.
mallocBytes :: RegionControlIO pr => Int -> RegionT s pr (RegionalPtr α (RegionT s pr))


module Foreign.Marshal.Utils.Region

-- | <tt><a>with</a> val f</tt> executes the computation <tt>f</tt>,
--   passing as argument a regional pointer to a temporarily allocated
--   block of memory into which <tt>val</tt> has been marshalled (the
--   combination of <tt>alloca</tt> and <tt>poke</tt>).
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception).
--   
--   This provides a safer replacement for
--   <tt>Foreign.Marshal.Utils.<a>with</a></tt>.
with :: (Storable α, RegionControlIO pr) => α -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Allocate a block of memory and marshal a value into it (the
--   combination of <tt>malloc</tt> and <tt>poke</tt>). The size of the
--   area allocated is determined by the <a>sizeOf</a> method from the
--   instance of <a>Storable</a> for the appropriate type.
--   
--   This provides a safer replacement for
--   <tt>Foreign.Marshal.Utils.<a>new</a></tt>.
new :: (Storable α, RegionControlIO pr) => α -> RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: Num a => a -> Bool

-- | A <tt><a>MaybePointer</a> α</tt> corresponds to a <tt><a>Maybe</a>
--   α</tt> but additionally introduces some type equalities to the
--   type-checker.
data MaybePointer α :: * pointer :: * β :: * r :: (* -> *)
NullPointer :: MaybePointer α (NullPtr β RootRegion) β RootRegion
JustPointer :: α -> MaybePointer α (RegionalPtr β r) β r

-- | Allocate storage and marshal a storable value wrapped into a
--   <a>MaybePointer</a>.
--   
--   The <a>nullPtr</a> is used to represent <a>NullPointer</a>.
--   
--   Alternative for <a>maybeNew</a>.
maybeNew :: Monad m => (α -> m (RegionalPtr β r)) -> (MaybePointer α pointer β r -> m pointer)

-- | Converts a <tt>withXXX</tt> combinator into one marshalling a value
--   wrapped into a <a>MaybePointer</a>, using <a>nullPtr</a> to represent
--   <tt>NoPointer</tt>.
--   
--   Alternative for <a>maybeWith</a>
maybeWith :: (α -> (pointer -> m γ) -> m γ) -> (MaybePointer α pointer β r -> (pointer -> m γ) -> m γ)
class MaybePeek pointer :: (* -> (* -> *) -> *)
maybePeek :: (MaybePeek pointer, Applicative m) => (pointer α r -> m β) -> (pointer α r -> m (Maybe β))

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas may <i>not</i> overlap
--   
--   Wraps: <tt>Foreign.Marshal.Utils.<a>copyBytes</a></tt>.
copyBytes :: (AllocatedPointer pointer1, AllocatedPointer pointer2, AncestorRegion pr1 cr, AncestorRegion pr2 cr, MonadIO cr) => pointer1 α pr1 -> pointer2 α pr2 -> Int -> cr ()

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas <i>may</i> overlap
--   
--   Wraps: <tt>Foreign.Marshal.Utils.<a>moveBytes</a></tt>.
moveBytes :: (AllocatedPointer pointer1, AllocatedPointer pointer2, AncestorRegion pr1 cr, AncestorRegion pr2 cr, MonadIO cr) => pointer1 α pr1 -> pointer2 α pr2 -> Int -> cr ()
instance MaybePeek RegionalPtr
instance MaybePeek NullPtr


module Foreign.Marshal.Array.Region

-- | Allocate storage for the given number of elements of a storable type.
--   
--   Like <a>malloc</a>, but for multiple elements.
mallocArray :: (Storable α, RegionControlIO pr) => Int -> RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Like <a>mallocArray</a>, but add an extra position to hold a special
--   termination element.
mallocArray0 :: (Storable α, RegionControlIO pr) => Int -> RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Temporarily allocate space for the given number of elements (like
--   <a>alloca</a>, but for multiple elements).
allocaArray :: (Storable α, RegionControlIO pr) => Int -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Like <a>allocaArray</a>, but add an extra position to hold a special
--   termination element.
allocaArray0 :: (Storable α, RegionControlIO pr) => Int -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Convert an array of given length into a Haskell list.
--   
--   (This version traverses the array backwards using an accumulating
--   parameter, which uses constant stack space. The previous version using
--   <tt>mapM</tt> needed linear stack space.)
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>peekArray</a></tt>.
peekArray :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => Int -> pointer α pr -> cr [α]

-- | Convert an array terminated by the given end marker into a Haskell
--   list.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>peekArray0</a></tt>.
peekArray0 :: (AllocatedPointer pointer, Storable α, Eq α, AncestorRegion pr cr, MonadIO cr) => α -> pointer α pr -> cr [α]

-- | Write the list elements consecutive into memory.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>pokeArray</a></tt>.
pokeArray :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer α pr -> [α] -> cr ()

-- | Write the list elements consecutive into memory and terminate them
--   with the given marker element.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>pokeArray0</a></tt>.
pokeArray0 :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => α -> pointer α pr -> [α] -> cr ()

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values.
--   
--   Like <a>new</a>, but for multiple elements.
newArray :: (Storable α, RegionControlIO pr) => [α] -> RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values, where the end is fixed by the given end
--   marker.
newArray0 :: (Storable α, RegionControlIO pr) => α -> [α] -> RegionT s pr (RegionalPtr α (RegionT s pr))

-- | Temporarily store a list of storable values in memory.
--   
--   Like <a>with</a>, but for multiple elements.
withArray :: (Storable α, RegionControlIO pr) => [α] -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Like <a>withArray</a>, but a terminator indicates where the array
--   ends.
withArray0 :: (Storable α, RegionControlIO pr) => α -> [α] -> (forall sl. LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter.
withArrayLen :: (Storable α, RegionControlIO pr) => [α] -> (forall sl. Int -> LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Like <a>withArrayLen</a>, but a terminator indicates where the array
--   ends.
withArrayLen0 :: (Storable α, RegionControlIO pr) => α -> [α] -> (forall sl. Int -> LocalPtr α (LocalRegion sl s) -> RegionT (Local s) pr β) -> RegionT s pr β

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas may <i>not</i>
--   overlap.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>copyArray</a></tt>.
copyArray :: (AllocatedPointer pointer1, AllocatedPointer pointer2, Storable α, AncestorRegion pr1 cr, AncestorRegion pr2 cr, MonadIO cr) => pointer1 α pr1 -> pointer2 α pr2 -> Int -> cr ()

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas <i>may</i> overlap.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>moveArray</a></tt>.
moveArray :: (AllocatedPointer pointer1, AllocatedPointer pointer2, Storable α, AncestorRegion pr1 cr, AncestorRegion pr2 cr, MonadIO cr) => pointer1 α pr1 -> pointer2 α pr2 -> Int -> cr ()

-- | Return the number of elements in an array, excluding the terminator.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>lengthArray0</a></tt>.
lengthArray0 :: (AllocatedPointer pointer, Storable α, Eq α, AncestorRegion pr cr, MonadIO cr) => α -> pointer α pr -> cr Int

-- | Advance a pointer into an array by the given number of elements.
--   
--   Wraps: <tt>Foreign.Marshal.Array.<a>advancePtr</a></tt>.
advancePtr :: (AllocatedPointer pointer, Storable α) => pointer α pr -> Int -> pointer α pr


-- | Lifts methods of the <a>Storable</a> type class from
--   <tt>Foreign.Storable</tt> to regional pointers.
module Foreign.Storable.Region

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
--   
--   Wraps: <tt>Foreign.Storable.<a>peekElemOff</a></tt>.
peekElemOff :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer α pr -> Int -> cr α

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x =
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
--   
--   Wraps: <tt>Foreign.Storable.<a>pokeElemOff</a></tt>.
pokeElemOff :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer α pr -> Int -> α -> cr ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
--   
--   Wraps: <tt>Foreign.Storable.<a>peekByteOff</a></tt>.
peekByteOff :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer β pr -> Int -> cr α

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
--   
--   Wraps: <tt>Foreign.Storable.<a>pokeByteOff</a></tt>.
pokeByteOff :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer β pr -> Int -> α -> cr ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <tt>alignment</tt> is fulfilled.
--   
--   Wraps: <tt>Foreign.Storable.<a>peek</a></tt>.
peek :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer α pr -> cr α

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
--   
--   Wraps: <tt>Foreign.Storable.<a>poke</a></tt>.
poke :: (AllocatedPointer pointer, Storable α, AncestorRegion pr cr, MonadIO cr) => pointer α pr -> α -> cr ()


-- | Lifts functions and types from <tt>Foreign.C.String</tt> to regional
--   pointers.
module Foreign.C.String.Region

-- | Handy type synonym for a regional pointer to an array of C characters
--   terminated by a NUL.
--   
--   This should provide a safer replacement for
--   <tt>Foreign.C.String.<a>CString</a></tt>.
type RegionalCString pointer :: (* -> (* -> *) -> *) r = pointer CChar r

-- | Handy type synonym for a regional pointer to an array of C characters
--   which is paired with the length of the array instead of terminated by
--   a NUL. (Thus allowing NUL characters in the middle of the string)
--   
--   This should provide a safer replacement for
--   <tt>Foreign.C.String.<a>CStringLen</a></tt>.
type RegionalCStringLen pointer r = (RegionalCString pointer r, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCString</a></tt>
peekCString :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCString pointer pr -> cr String

-- | Marshal a C string with explicit length into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCStringLen</a></tt>.
peekCStringLen :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCStringLen pointer pr -> cr String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   The Haskell string may <i>not</i> contain any NUL characters
--   
--   Wraps: <tt>Foreign.C.String.<a>newCString</a></tt>.
newCString :: RegionControlIO pr => String -> RegionT s pr (RegionalCString RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   Wraps: <tt>Foreign.C.String.<a>newCStringLen</a></tt>.
newCStringLen :: RegionControlIO pr => String -> RegionT s pr (RegionalCStringLen RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCString</a></tt>.
withCString :: RegionControlIO pr => String -> (forall sl. RegionalCString LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCStringLen</a></tt>.
withCStringLen :: RegionControlIO pr => String -> (forall sl. RegionalCStringLen LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α

-- | Generalizes <tt>Foreign.C.String.<a>charIsRepresentable</a></tt> to
--   any <a>MonadIO</a>.
charIsRepresentable :: MonadIO m => Char -> m Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Marshal a NUL terminated C string into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCAString</a></tt>.
peekCAString :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCString pointer pr -> cr String

-- | Marshal a C string with explicit length into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCAStringLen</a></tt>.
peekCAStringLen :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCStringLen pointer pr -> cr String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   The Haskell string may <i>not</i> contain any NUL characters
--   
--   Wraps: <tt>Foreign.C.String.<a>newCAString</a></tt>.
newCAString :: RegionControlIO pr => String -> RegionT s pr (RegionalCString RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   Wraps: <tt>Foreign.C.String.<a>newCAStringLen</a></tt>.
newCAStringLen :: RegionControlIO pr => String -> RegionT s pr (RegionalCStringLen RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCAString</a></tt>.
withCAString :: RegionControlIO pr => String -> (forall sl. RegionalCString LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCAStringLen</a></tt>.
withCAStringLen :: RegionControlIO pr => String -> (forall sl. RegionalCStringLen LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α

-- | Handy type synonym for a regional pointer to an array of C wide
--   characters terminated by a NUL.
--   
--   This should provide a safer replacement for
--   <tt>Foreign.C.String.<a>CWString</a></tt>.
type RegionalCWString pointer :: (* -> (* -> *) -> *) r = pointer CWchar r

-- | Handy type synonym for a regional pointer to an array of C wide
--   characters which is paired with the length of the array instead of
--   terminated by a NUL. (Thus allowing NUL characters in the middle of
--   the string)
--   
--   This should provide a safer replacement for
--   <tt>Foreign.C.String.<a>CWStringLen</a></tt>.
type RegionalCWStringLen pointer r = (RegionalCWString pointer r, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCWString</a></tt>.
peekCWString :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCWString pointer pr -> cr String

-- | Marshal a C wide string with explicit length into a Haskell string.
--   
--   Wraps: <tt>Foreign.C.String.<a>peekCWStringLen</a></tt>.
peekCWStringLen :: (AllocatedPointer pointer, AncestorRegion pr cr, MonadIO cr) => RegionalCWStringLen pointer pr -> cr String

-- | Marshal a Haskell string into a NUL terminated C wide string.
--   
--   The Haskell string may <i>not</i> contain any NUL characters.
--   
--   Wraps: <tt>Foreign.C.String.<a>newCWString</a></tt>.
newCWString :: RegionControlIO pr => String -> RegionT s pr (RegionalCWString RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a C wide string (ie, wide character
--   array) with explicit length information.
--   
--   Wraps: <tt>Foreign.C.String.<a>newCWStringLen</a></tt>.
newCWStringLen :: RegionControlIO pr => String -> RegionT s pr (RegionalCWStringLen RegionalPtr (RegionT s pr))

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCWString</a></tt>.
withCWString :: RegionControlIO pr => String -> (forall sl. RegionalCWString LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters.</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception).</li>
--   </ul>
--   
--   Wraps: <tt>Foreign.C.String.<a>withCWStringLen</a></tt>.
withCWStringLen :: RegionControlIO pr => String -> (forall sl. RegionalCWStringLen LocalPtr (LocalRegion sl s) -> RegionT (Local s) pr α) -> RegionT s pr α
