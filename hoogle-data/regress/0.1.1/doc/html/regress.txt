-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Linear and logistic regression through automatic differentiation
--   
@package regress
@version 0.1.1

module Numeric.Regression.Logistic

-- | A model using the given <tt>f</tt> to store parameters of type
--   <tt>a</tt>. Can be thought of as some kind of vector throughough this
--   package.
type Model f a = f a

-- | Given some observed "predictions" <tt>ys</tt>, the corresponding input
--   values <tt>xs</tt> and initial values for the model's parameters
--   <tt>theta0</tt>,
--   
--   <pre>
--   regress ys xs theta0
--   </pre>
--   
--   returns a stream of values for the parameters that'll fit the data
--   better and better.
--   
--   Example:
--   
--   <pre>
--   ys_ex :: [Double]
--   xs_ex :: [[Double]]
--   (ys_ex, xs_ex) = unzip $
--     [ (1, [1, 1])
--     , (0, [-1, -2])
--     , (1, [2, 5])
--     , (0, [-1, 1])
--     , (1, [2, -1])
--     , (1, [1, -10])
--     , (0, [-0.1, 30])
--     ]
--   
--   t0 :: [Double]
--   t0 = [1, 0.1]
--   
--   approxs' :: [Model [] Double]
--   approxs' = learn 0.1 ys_ex xs_ex t0
--   </pre>
regress :: (Traversable v, Applicative v, Foldable f, Applicative f, Ord a, Floating a) => a -> f a -> f (v a) -> Model v a -> [Model v a]

module Numeric.Regression.Linear

-- | A model using the given <tt>f</tt> to store parameters of type
--   <tt>a</tt>. Can be thought of as some kind of vector throughough this
--   package.
type Model f a = f a

-- | Compute the predicted value for the given model on the given
--   observation
compute :: (Applicative v, Foldable v, Num a) => Model v a -> v a -> a

-- | Given some observed "predictions" <tt>ys</tt>, the corresponding input
--   values <tt>xs</tt> and initial values for the model's parameters
--   <tt>theta0</tt>,
--   
--   <pre>
--   regress ys xs theta0
--   </pre>
--   
--   returns a stream of values for the parameters that'll fit the data
--   better and better.
--   
--   Example:
--   
--   <pre>
--   -- the theta we're approximating
--   realtheta :: Model V.Vector Double
--   realtheta = V.fromList [1.0, 2.0, 3.0]
--   
--   -- let's start there and make <a>regress</a>
--   -- get values that better fit the input data
--   theta0 :: Model V.Vector Double
--   theta0 = V.fromList [0.2, 3.0, 2.23]
--   
--   -- input data. (output value, vector of values for each input)
--   ys_ex :: V.Vector Double
--   xs_ex :: V.Vector (V.Vector Double)
--   (ys_ex, xs_ex) = V.unzip . V.fromList $
--     [ (3, V.fromList [0, 0, 1])
--     , (1, V.fromList [1, 0, 0])
--     , (2, V.fromList [0, 1, 0])
--     , (6, V.fromList [1, 1, 1])
--     ]
--   
--   -- stream of increasingly accurate parameters
--   thetaApproxs :: [Model V.Vector Double]
--   thetaApproxs = learnAll ys_ex xs_ex theta0
--   </pre>
regress :: (Traversable v, Applicative v, Foldable v, Applicative f, Foldable f, Ord a, Floating a) => f a -> f (v a) -> Model v a -> [Model v a]
