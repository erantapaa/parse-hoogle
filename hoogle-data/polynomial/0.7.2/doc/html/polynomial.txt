-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Polynomials
--   
@package polynomial
@version 0.7.2


-- | Low-level interface for the <a>Poly</a> type.
module Math.Polynomial.Type
data Endianness

-- | Big-Endian (head is highest-order term)
BE :: Endianness

-- | Little-Endian (head is const term)
LE :: Endianness
data Poly a

-- | The polynomial "0"
zero :: Poly a

-- | Make a <a>Poly</a> from a list of coefficients using the specified
--   coefficient order.
poly :: (Num a, Eq a) => Endianness -> [a] -> Poly a

-- | Make a <a>Poly</a> from a list of coefficients, at most <tt>n</tt> of
--   which are significant.
polyN :: (Num a, Eq a) => Int -> Endianness -> [a] -> Poly a
unboxedPoly :: (Unbox a, Num a, Eq a) => Endianness -> [a] -> Poly a
unboxedPolyN :: (Unbox a, Num a, Eq a) => Int -> Endianness -> [a] -> Poly a

-- | Like fmap, but able to preserve unboxedness
mapPoly :: (Num a, Eq a) => (a -> a) -> Poly a -> Poly a
rawMapPoly :: (a -> a) -> Poly a -> Poly a

-- | like <tt>fmap WrapNum</tt> but using <a>unsafeCoerce</a> to avoid a
--   pointless traversal
wrapPoly :: Poly a -> Poly (WrappedNum a)

-- | like <tt>fmap unwrapNum</tt> but using <a>unsafeCoerce</a> to avoid a
--   pointless traversal
unwrapPoly :: Poly (WrappedNum a) -> Poly a
unboxPoly :: Unbox a => Poly a -> Poly a

-- | Make a <a>Poly</a> from a list of coefficients using the specified
--   coefficient order, without the <a>Num</a> context (and therefore
--   without trimming zeroes from the coefficient list)
rawListPoly :: Endianness -> [a] -> Poly a
rawListPolyN :: Int -> Endianness -> [a] -> Poly a
rawVectorPoly :: Endianness -> Vector a -> Poly a
rawUVectorPoly :: Unbox a => Endianness -> Vector a -> Poly a

-- | Trim zeroes from a polynomial (given a predicate for identifying
--   zero). In particular, drops zeroes from the highest-order
--   coefficients, so that <tt>0x^n + 0x^(n-1) + 0x^(n-2) + ... + ax^k +
--   ...</tt>, <tt>a /= 0</tt> is normalized to <tt>ax^k + ...</tt>.
--   
--   The <a>Eq</a> instance for <a>Poly</a> and all the standard
--   constructors / destructors are defined using <tt>trim (0==)</tt>.
trim :: (a -> Bool) -> Poly a -> Poly a
vTrim :: (Eq a, AdditiveGroup a) => Poly a -> Poly a
polyIsZero :: (Num a, Eq a) => Poly a -> Bool
polyIsOne :: (Num a, Eq a) => Poly a -> Bool

-- | Get the coefficients of a a <a>Poly</a> in the specified order.
polyCoeffs :: (Num a, Eq a) => Endianness -> Poly a -> [a]

-- | Get the coefficients of a a <a>Poly</a> in the specified order.
vPolyCoeffs :: (Eq a, AdditiveGroup a) => Endianness -> Poly a -> [a]
rawCoeffsOrder :: Poly a -> Endianness
rawPolyCoeffs :: Poly a -> [a]
untrimmedPolyCoeffs :: Endianness -> Poly a -> [a]

-- | Get the degree of a a <a>Poly</a> (the highest exponent with nonzero
--   coefficient)
polyDegree :: (Num a, Eq a) => Poly a -> Int
rawPolyDegree :: Poly a -> Int
rawPolyLength :: Poly a -> Int
instance Eq Endianness
instance Ord Endianness
instance Enum Endianness
instance Bounded Endianness
instance Show Endianness
instance (Eq a, VectorSpace a, AdditiveGroup (Scalar a), Eq (Scalar a)) => VectorSpace (Poly a)
instance AdditiveGroup a => AdditiveGroup (Poly a)
instance Functor Poly
instance (AdditiveGroup a, Eq a) => Eq (Poly a)
instance Show a => Show (Poly a)
instance NFData a => NFData (Poly a)
instance NFData Endianness


-- | Same general interface as Math.Polynomial, but using AdditiveGroup,
--   VectorSpace, etc., instead of Num where sensible.
module Math.Polynomial.VectorSpace
data Endianness

-- | Big-Endian (head is highest-order term)
BE :: Endianness

-- | Little-Endian (head is const term)
LE :: Endianness
data Poly a
poly :: (Eq a, AdditiveGroup a) => Endianness -> [a] -> Poly a
polyDegree :: (Eq a, AdditiveGroup a) => Poly a -> Int

-- | Get the coefficients of a a <a>Poly</a> in the specified order.
vPolyCoeffs :: (Eq a, AdditiveGroup a) => Endianness -> Poly a -> [a]
polyIsZero :: (Eq a, AdditiveGroup a) => Poly a -> Bool
polyIsOne :: (Num a, Eq a) => Poly a -> Bool

-- | The polynomial "0"
zero :: Poly a

-- | The polynomial "1"
one :: (Num a, Eq a) => Poly a

-- | Given some constant <tt>k</tt>, construct the polynomial whose value
--   is constantly <tt>k</tt>.
constPoly :: (Eq a, AdditiveGroup a) => a -> Poly a

-- | The polynomial (in x) "x"
x :: (Num a, Eq a) => Poly a

-- | Given some scalar <tt>s</tt> and a polynomial <tt>f</tt>, computes the
--   polynomial <tt>g</tt> such that:
--   
--   <pre>
--   evalPoly g x = s * evalPoly f x
--   </pre>
scalePoly :: (Eq a, VectorSpace a, AdditiveGroup (Scalar a), Eq (Scalar a)) => Scalar a -> Poly a -> Poly a

-- | Given some polynomial <tt>f</tt>, computes the polynomial <tt>g</tt>
--   such that:
--   
--   <pre>
--   evalPoly g x = negate (evalPoly f x)
--   </pre>
negatePoly :: (AdditiveGroup a, Eq a) => Poly a -> Poly a

-- | <tt>composePoly f g</tt> constructs the polynomial <tt>h</tt> such
--   that:
--   
--   <pre>
--   evalPoly h = evalPoly f . evalPoly g
--   </pre>
--   
--   This is a very expensive operation and, in general, returns a
--   polynomial that is quite a bit more expensive to evaluate than
--   <tt>f</tt> and <tt>g</tt> together (because it is of a much higher
--   order than either). Unless your polynomials are quite small or you are
--   quite certain you need the coefficients of the composed polynomial, it
--   is recommended that you simply evaluate <tt>f</tt> and <tt>g</tt> and
--   explicitly compose the resulting functions. This will usually be much
--   more efficient.
composePolyWith :: (AdditiveGroup a, Eq a) => (a -> a -> a) -> Poly a -> Poly a -> Poly a

-- | Given polynomials <tt>f</tt> and <tt>g</tt>, computes the polynomial
--   <tt>h</tt> such that:
--   
--   <pre>
--   evalPoly h x = evalPoly f x + evalPoly g x
--   </pre>
addPoly :: (AdditiveGroup a, Eq a) => Poly a -> Poly a -> Poly a
sumPolys :: (AdditiveGroup a, Eq a) => [Poly a] -> Poly a

-- | Given polynomials <tt>f</tt> and <tt>g</tt>, computes the polynomial
--   <tt>h</tt> such that:
--   
--   <pre>
--   evalPoly h x = evalPoly f x * evalPoly g x
--   </pre>
multPolyWith :: (AdditiveGroup a, Eq a) => (a -> a -> a) -> Poly a -> Poly a -> Poly a

-- | Given a polynomial <tt>f</tt> and exponent <tt>n</tt>, computes the
--   polynomial <tt>g</tt> such that:
--   
--   <pre>
--   evalPoly g x = evalPoly f x ^ n
--   </pre>
powPolyWith :: (AdditiveGroup a, Eq a, Integral b) => a -> (a -> a -> a) -> Poly a -> b -> Poly a

-- | Given polynomials <tt>a</tt> and <tt>b</tt>, with <tt>b</tt> not
--   <a>zero</a>, computes polynomials <tt>q</tt> and <tt>r</tt> such that:
--   
--   <pre>
--   addPoly (multPoly q b) r == a
--   </pre>
quotRemPolyWith :: (AdditiveGroup a, Eq a) => (a -> a -> a) -> (a -> a -> a) -> Poly a -> Poly a -> (Poly a, Poly a)
quotPolyWith :: (AdditiveGroup a, Eq a) => (a -> a -> a) -> (a -> a -> a) -> Poly a -> Poly a -> Poly a
remPolyWith :: (AdditiveGroup a, Eq a) => (a -> a -> a) -> (a -> a -> a) -> Poly a -> Poly a -> Poly a

-- | Evaluate a polynomial at a point or, equivalently, convert a
--   polynomial to the function it represents. For example, <tt>evalPoly
--   <a>x</a> = <a>id</a></tt> and <tt>evalPoly (<a>constPoly</a> k) =
--   <a>const</a> k.</tt>
evalPoly :: (VectorSpace a, Eq a, AdditiveGroup (Scalar a), Eq (Scalar a)) => Poly a -> Scalar a -> a

-- | Evaluate a polynomial and its derivative (respectively) at a point.
evalPolyDeriv :: (VectorSpace a, Eq a) => Poly a -> Scalar a -> (a, a)

-- | Evaluate a polynomial and all of its nonzero derivatives at a point.
--   This is roughly equivalent to:
--   
--   <pre>
--   evalPolyDerivs p x = map (`evalPoly` x) (takeWhile (not . polyIsZero) (iterate polyDeriv p))
--   </pre>
evalPolyDerivs :: (VectorSpace a, Eq a, Num (Scalar a)) => Poly a -> Scalar a -> [a]

-- | "Contract" a polynomial by attempting to divide out a root.
--   
--   <tt>contractPoly p a</tt> returns <tt>(q,r)</tt> such that <tt>q*(x-a)
--   + r == p</tt>
contractPoly :: (VectorSpace a, Eq a) => Poly a -> Scalar a -> (Poly a, a)

-- | Normalize a polynomial so that its highest-order coefficient is 1
monicPolyWith :: (AdditiveGroup a, Eq a) => a -> (a -> a -> a) -> Poly a -> Poly a

-- | <tt>gcdPoly a b</tt> computes the highest order monic polynomial that
--   is a divisor of both <tt>a</tt> and <tt>b</tt>. If both <tt>a</tt> and
--   <tt>b</tt> are <a>zero</a>, the result is undefined.
gcdPolyWith :: (AdditiveGroup a, Eq a) => a -> (a -> a -> a) -> (a -> a -> a) -> Poly a -> Poly a -> Poly a

-- | Compute the derivative of a polynomial.
polyDeriv :: (VectorSpace a, Eq a, Num (Scalar a)) => Poly a -> Poly a

-- | Compute all nonzero derivatives of a polynomial, starting with its
--   "zero'th derivative", the original polynomial itself.
polyDerivs :: (VectorSpace a, Eq a, Num (Scalar a)) => Poly a -> [Poly a]

-- | Compute the definite integral (from 0 to x) of a polynomial.
polyIntegral :: (VectorSpace a, Eq a, Fractional (Scalar a)) => Poly a -> Poly a

module Math.Polynomial
data Endianness

-- | Big-Endian (head is highest-order term)
BE :: Endianness

-- | Little-Endian (head is const term)
LE :: Endianness
data Poly a

-- | Make a <a>Poly</a> from a list of coefficients using the specified
--   coefficient order.
poly :: (Num a, Eq a) => Endianness -> [a] -> Poly a

-- | Get the degree of a a <a>Poly</a> (the highest exponent with nonzero
--   coefficient)
polyDegree :: (Num a, Eq a) => Poly a -> Int

-- | Get the coefficients of a a <a>Poly</a> in the specified order.
polyCoeffs :: (Num a, Eq a) => Endianness -> Poly a -> [a]
polyIsZero :: (Num a, Eq a) => Poly a -> Bool
polyIsOne :: (Num a, Eq a) => Poly a -> Bool

-- | The polynomial "0"
zero :: Poly a

-- | The polynomial "1"
one :: (Num a, Eq a) => Poly a

-- | Given some constant <tt>k</tt>, construct the polynomial whose value
--   is constantly <tt>k</tt>.
constPoly :: (Num a, Eq a) => a -> Poly a

-- | The polynomial (in x) "x"
x :: (Num a, Eq a) => Poly a

-- | Given some scalar <tt>s</tt> and a polynomial <tt>f</tt>, computes the
--   polynomial <tt>g</tt> such that:
--   
--   <pre>
--   evalPoly g x = s * evalPoly f x
--   </pre>
scalePoly :: (Num a, Eq a) => a -> Poly a -> Poly a

-- | Given some polynomial <tt>f</tt>, computes the polynomial <tt>g</tt>
--   such that:
--   
--   <pre>
--   evalPoly g x = negate (evalPoly f x)
--   </pre>
negatePoly :: (Num a, Eq a) => Poly a -> Poly a

-- | <tt>composePoly f g</tt> constructs the polynomial <tt>h</tt> such
--   that:
--   
--   <pre>
--   evalPoly h = evalPoly f . evalPoly g
--   </pre>
--   
--   This is a very expensive operation and, in general, returns a
--   polynomial that is quite a bit more expensive to evaluate than
--   <tt>f</tt> and <tt>g</tt> together (because it is of a much higher
--   order than either). Unless your polynomials are quite small or you are
--   quite certain you need the coefficients of the composed polynomial, it
--   is recommended that you simply evaluate <tt>f</tt> and <tt>g</tt> and
--   explicitly compose the resulting functions. This will usually be much
--   more efficient.
composePoly :: (Num a, Eq a) => Poly a -> Poly a -> Poly a

-- | Given polynomials <tt>f</tt> and <tt>g</tt>, computes the polynomial
--   <tt>h</tt> such that:
--   
--   <pre>
--   evalPoly h x = evalPoly f x + evalPoly g x
--   </pre>
addPoly :: (Num a, Eq a) => Poly a -> Poly a -> Poly a
sumPolys :: (Num a, Eq a) => [Poly a] -> Poly a

-- | Given polynomials <tt>f</tt> and <tt>g</tt>, computes the polynomial
--   <tt>h</tt> such that:
--   
--   <pre>
--   evalPoly h x = evalPoly f x * evalPoly g x
--   </pre>
multPoly :: (Num a, Eq a) => Poly a -> Poly a -> Poly a

-- | Given a polynomial <tt>f</tt> and exponent <tt>n</tt>, computes the
--   polynomial <tt>g</tt> such that:
--   
--   <pre>
--   evalPoly g x = evalPoly f x ^ n
--   </pre>
powPoly :: (Num a, Eq a, Integral b) => Poly a -> b -> Poly a

-- | Given polynomials <tt>a</tt> and <tt>b</tt>, with <tt>b</tt> not
--   <a>zero</a>, computes polynomials <tt>q</tt> and <tt>r</tt> such that:
--   
--   <pre>
--   addPoly (multPoly q b) r == a
--   </pre>
quotRemPoly :: (Fractional a, Eq a) => Poly a -> Poly a -> (Poly a, Poly a)
quotPoly :: (Fractional a, Eq a) => Poly a -> Poly a -> Poly a
remPoly :: (Fractional a, Eq a) => Poly a -> Poly a -> Poly a

-- | Evaluate a polynomial at a point or, equivalently, convert a
--   polynomial to the function it represents. For example, <tt>evalPoly
--   <a>x</a> = <a>id</a></tt> and <tt>evalPoly (<a>constPoly</a> k) =
--   <a>const</a> k.</tt>
evalPoly :: (Num a, Eq a) => Poly a -> a -> a

-- | Evaluate a polynomial and its derivative (respectively) at a point.
evalPolyDeriv :: (Num a, Eq a) => Poly a -> a -> (a, a)

-- | Evaluate a polynomial and all of its nonzero derivatives at a point.
--   This is roughly equivalent to:
--   
--   <pre>
--   evalPolyDerivs p x = map (`evalPoly` x) (takeWhile (not . polyIsZero) (iterate polyDeriv p))
--   </pre>
evalPolyDerivs :: (Num a, Eq a) => Poly a -> a -> [a]

-- | "Contract" a polynomial by attempting to divide out a root.
--   
--   <tt>contractPoly p a</tt> returns <tt>(q,r)</tt> such that <tt>q*(x-a)
--   + r == p</tt>
contractPoly :: (Num a, Eq a) => Poly a -> a -> (Poly a, a)

-- | Normalize a polynomial so that its highest-order coefficient is 1
monicPoly :: (Fractional a, Eq a) => Poly a -> Poly a

-- | <tt>gcdPoly a b</tt> computes the highest order monic polynomial that
--   is a divisor of both <tt>a</tt> and <tt>b</tt>. If both <tt>a</tt> and
--   <tt>b</tt> are <a>zero</a>, the result is undefined.
gcdPoly :: (Fractional a, Eq a) => Poly a -> Poly a -> Poly a

-- | Separate a nonzero polynomial into a set of factors none of which have
--   multiple roots, and the product of which is the original polynomial.
--   Note that if division is not exact, it may fail to separate roots.
--   Rational coefficients is a good idea.
--   
--   Useful when applicable as a way to simplify root-finding problems.
separateRoots :: (Fractional a, Eq a) => Poly a -> [Poly a]

-- | Compute the derivative of a polynomial.
polyDeriv :: (Num a, Eq a) => Poly a -> Poly a

-- | Compute all nonzero derivatives of a polynomial, starting with its
--   "zero'th derivative", the original polynomial itself.
polyDerivs :: (Num a, Eq a) => Poly a -> [Poly a]

-- | Compute the definite integral (from 0 to x) of a polynomial.
polyIntegral :: (Fractional a, Eq a) => Poly a -> Poly a

module Math.Polynomial.Bernstein

-- | The Bernstein basis polynomials. The <tt>n</tt>th inner list is a
--   basis for the polynomials of order <tt>n</tt> or lower. The
--   <tt>n</tt>th basis consists of <tt>n</tt> polynomials of order
--   <tt>n</tt> which sum to <tt>1</tt>, and have roots of varying
--   multiplicities at <tt>0</tt> and <tt>1</tt>.
bernstein :: [[Poly Integer]]

-- | <tt>evalBernstein n v x</tt> evaluates the <tt>v</tt>'th Bernstein
--   polynomial of order <tt>n</tt> at the point <tt>x</tt>.
evalBernstein :: (Integral a, Num b) => a -> a -> b -> b

-- | <tt>bernsteinFit n f</tt>: Approximate a function <tt>f</tt> as a
--   linear combination of Bernstein polynomials of order <tt>n</tt>. This
--   approximation converges slowly but uniformly to <tt>f</tt> on the
--   interval [0,1].
bernsteinFit :: (Fractional b, Integral a) => a -> (b -> b) -> [b]

-- | Evaluate a polynomial given as a list of <tt>n</tt> coefficients for
--   the <tt>n</tt>th Bernstein basis. Roughly:
--   
--   <pre>
--   evalBernsteinSeries cs = sum (zipWith scalePoly cs (bernstein !! (length cs - 1)))
--   </pre>
evalBernsteinSeries :: Num a => [a] -> a -> a

-- | de Casteljau's algorithm, returning the whole tableau. Used both for
--   evaluating and splitting polynomials in Bernstein form.
deCasteljau :: Num a => [a] -> a -> [[a]]

-- | Given a polynomial in Bernstein form (that is, a list of coefficients
--   for a basis set from <a>bernstein</a>, such as is returned by
--   <a>bernsteinFit</a>) and a parameter value <tt>x</tt>, split the
--   polynomial into two halves, mapping <tt>[0,x]</tt> and <tt>[x,1]</tt>
--   respectively onto <tt>[0,1]</tt>.
--   
--   A typical use for this operation would be to split a Bezier curve
--   (inserting a new knot at <tt>x</tt>).
splitBernsteinSeries :: Num a => [a] -> a -> ([a], [a])

module Math.Polynomial.Bernoulli

-- | Bernoulli polynomial with a nonstandard normalization
--   
--   <pre>
--   b_i = bernoulliPoly !! i
--   </pre>
--   
--   Has the following generating function (C.2 in IH Sloan &amp; S Joe
--   "Lattice Methods for multiple integration" 1994 page 227)
--   
--   <pre>
--   t exp(x*t) / (exp(t) - 1) = sum_{i=0} b_i t^i
--   </pre>
--   
--   The standard normalization would have <tt>= sum_{i=0} B_i t^i /
--   i!</tt>
bernoulliPoly :: (Fractional a, Eq a) => [Poly a]

module Math.Polynomial.Chebyshev

-- | The Chebyshev polynomials of the first kind with <a>Integer</a>
--   coefficients.
ts :: [Poly Integer]
us :: [Poly Integer]

-- | Compute the coefficients of the n'th Chebyshev polynomial of the first
--   kind.
t :: (Num a, Eq a) => Int -> Poly a

-- | Compute the coefficients of the n'th Chebyshev polynomial of the
--   second kind.
u :: (Num a, Eq a) => Int -> Poly a

-- | Evaluate the n'th Chebyshev polynomial of the first kind at a point X.
--   Both more efficient and more numerically stable than computing the
--   coefficients and evaluating the polynomial.
evalT :: Num a => Int -> a -> a

-- | Evaluate all the Chebyshev polynomials of the first kind at a point X.
evalTs :: Num a => a -> [a]

-- | Evaluate the n'th Chebyshev polynomial of the second kind at a point
--   X. Both more efficient and more numerically stable than computing the
--   coefficients and evaluating the polynomial.
evalU :: Num a => Int -> a -> a

-- | Evaluate all the Chebyshev polynomials of the second kind at a point
--   X.
evalUs :: Num a => a -> [a]

-- | Evaluate the n'th Chebyshev polynomials of both kinds at a point X.
evalTU :: Num a => Int -> a -> (a, a)

-- | Evaluate all the Chebyshev polynomials of both kinds at a point X.
evalTsUs :: Num a => a -> ([a], [a])

-- | Compute the roots of the n'th Chebyshev polynomial of the first kind.
tRoots :: Floating a => Int -> [a]

-- | Compute the extreme points of the n'th Chebyshev polynomial of the
--   first kind.
tExtrema :: Floating a => Int -> [a]

-- | <tt>chebyshevFit n f</tt> returns a list of N coefficients <tt>cs</tt>
--   such that <tt>f x</tt> ~= <tt>sum (zipWith (*) cs (evalTs x))</tt> on
--   the interval -1 &lt; x &lt; 1.
--   
--   The N roots of the N'th Chebyshev polynomial are the fitting points at
--   which the function will be evaluated and at which the approximation
--   will be exact. These points always lie within the interval -1 &lt; x
--   &lt; 1. Outside this interval, the approximation will diverge quickly.
--   
--   This function deviates from most chebyshev-fit implementations in that
--   it returns the first coefficient pre-scaled so that the series
--   evaluation operation is a simple inner product, since in most other
--   algorithms operating on chebyshev series, that factor is almost always
--   a nuissance.
chebyshevFit :: Floating a => Int -> (a -> a) -> [a]

-- | Evaluate a Chebyshev series expansion with a finite number of terms.
--   
--   Note that this function expects the first coefficient to be pre-scaled
--   by 1/2, which is what is produced by <a>chebyshevFit</a>. Thus, this
--   computes a simple inner product of the given list with a
--   matching-length sequence of chebyshev polynomials.
evalChebyshevSeries :: Num a => [a] -> a -> a

module Math.Polynomial.Hermite
probHermite :: [Poly Integer]
physHermite :: [Poly Integer]
evalProbHermite :: (Integral a, Num b) => a -> b -> b
evalProbHermiteDeriv :: (Integral a, Num b) => a -> b -> (b, b)
evalPhysHermite :: (Integral a, Num b) => a -> b -> b
evalPhysHermiteDeriv :: (Integral a, Num b) => a -> b -> (b, b)

module Math.Polynomial.Lagrange

-- | Returns the Lagrange basis set of polynomials associated with a set of
--   points. This is the set of polynomials each of which is <tt>1</tt> at
--   its corresponding point in the input list and <tt>0</tt> at all
--   others.
--   
--   These polynomials are especially convenient, mathematically, for
--   interpolation. The interpolating polynomial for a set of points
--   <tt>(x,y)</tt> is given by using the <tt>y</tt>s as coefficients for
--   the basis given by <tt>lagrangeBasis xs</tt>. Computationally, this is
--   not an especially stable procedure though. <a>lagrangePolyFit</a>
--   implements a slightly better algorithm based on the same idea.
--   
--   Generally it is better to not compute the coefficients at all.
--   <a>polyInterp</a> evaluates the interpolating polynomial directly, and
--   is both quicker and more stable than any method I know of that
--   computes the coefficients.
lagrangeBasis :: (Fractional a, Eq a) => [a] -> [Poly a]

-- | Construct the Lagrange "master polynomial" for the Lagrange
--   barycentric form: That is, the monic polynomial with a root at each
--   point in the input list.
lagrange :: (Num a, Eq a) => [a] -> Poly a

-- | Compute the weights associated with each abscissa in the Lagrange
--   barycentric form.
lagrangeWeights :: Fractional a => [a] -> [a]

module Math.Polynomial.Interpolation

-- | Evaluate a polynomial passing through the specified set of points. The
--   order of the interpolating polynomial will (at most) be one less than
--   the number of points given.
polyInterp :: Fractional a => [(a, a)] -> a -> a

-- | Computes the tableau generated by Neville's algorithm. Each successive
--   row of the table is a list of interpolants one order higher than the
--   previous, using a range of input points starting at the same position
--   in the input list as the interpolant's position in the output list.
neville :: Fractional a => [(a, a)] -> a -> [[a]]

-- | Computes the tableau generated by a modified form of Neville's
--   algorithm described in Numerical Recipes, Ch. 3, Sec. 2, which records
--   the differences between interpolants at each level. Each pair (c,d) is
--   the amount to add to the previous level's interpolant at either the
--   same or the subsequent position (respectively) in order to obtain the
--   new level's interpolant. Mathematically, either sum yields the same
--   value, but due to numerical errors they may differ slightly, and some
--   "paths" through the table may yield more accurate final results than
--   others.
nevilleDiffs :: Fractional a => [(a, a)] -> a -> [[(a, a)]]

-- | Fit a polynomial to a set of points by iteratively evaluating the
--   interpolated polynomial (using <a>polyInterp</a>) at 0 to establish
--   the constant coefficient and reducing the polynomial by subtracting
--   that coefficient from all y's and dividing by their corresponding x's.
--   
--   Slower than <a>lagrangePolyFit</a> but stable under different sets of
--   conditions.
--   
--   Note that computing the coefficients of a fitting polynomial is an
--   inherently ill-conditioned problem. In most cases it is both faster
--   and more accurate to use <a>polyInterp</a> or <a>nevilleDiffs</a>
--   instead of evaluating a fitted polynomial.
iterativePolyFit :: (Fractional a, Eq a) => [(a, a)] -> Poly a

-- | Fit a polynomial to a set of points using barycentric Lagrange
--   polynomials.
--   
--   Note that computing the coefficients of a fitting polynomial is an
--   inherently ill-conditioned problem. In most cases it is both faster
--   and more accurate to use <a>polyInterp</a> or <a>nevilleDiffs</a>
--   instead of evaluating a fitted polynomial.
lagrangePolyFit :: (Fractional a, Eq a) => [(a, a)] -> Poly a

module Math.Polynomial.Legendre

-- | The Legendre polynomials with <a>Rational</a> coefficients. These
--   polynomials form an orthogonal basis of the space of all polynomials,
--   relative to the L2 inner product on [-1,1] (which is given by
--   integrating the product of 2 polynomials over that range).
legendres :: [Poly Rational]

-- | Compute the coefficients of the n'th Legendre polynomial.
legendre :: (Fractional a, Eq a) => Int -> Poly a

-- | Evaluate the n'th Legendre polynomial at a point X. Both more
--   efficient and more numerically stable than computing the coefficients
--   and evaluating the polynomial.
evalLegendre :: Fractional a => Int -> a -> a

-- | Evaluate all the Legendre polynomials at a point X.
evalLegendres :: Fractional a => a -> [a]

-- | Evaluate the n'th Legendre polynomial and its derivative at a point X.
--   Both more efficient and more numerically stable than computing the
--   coefficients and evaluating the polynomial.
evalLegendreDeriv :: Fractional a => Int -> a -> (a, a)

-- | Zeroes of the n'th Legendre polynomial.
legendreRoots :: (Fractional b, Ord b) => Int -> b -> [b]

module Math.Polynomial.Newton

-- | Returns the Newton basis set of polynomials associated with a set of
--   abscissas. This is the set of monic polynomials each of which is
--   <tt>0</tt> at all previous points in the input list.
newtonBasis :: (Num a, Eq a) => [a] -> [Poly a]


-- | This module exports a <a>Num</a> instance for the <a>Poly</a> type.
--   This instance does not implement all operations, because <a>abs</a>
--   and <a>signum</a> are simply not definable, so I have placed it into a
--   separate module so that I can make people read this caveat ;).
--   
--   Use at your own risk.
module Math.Polynomial.NumInstance
instance (Num a, Eq a) => Num (Poly a)
