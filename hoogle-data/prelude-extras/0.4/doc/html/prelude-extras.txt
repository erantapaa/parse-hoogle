-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 98 - higher order versions of Prelude classes
--   
--   Haskell 98 - higher order versions of Prelude classes to ease
--   programming with polymorphic recursion and reduce UndecidableInstances
--   
--   See <a>http://flint.cs.yale.edu/trifonov/papers/sqcc.pdf</a> for
--   further discussion of the approach taken here.
@package prelude-extras
@version 0.4

module Prelude.Extras
class Eq1 f where ==# = (==)
(==#) :: (Eq1 f, Eq a) => f a -> f a -> Bool
(/=#) :: (Eq1 f, Eq a) => f a -> f a -> Bool
class Eq1 f => Ord1 f where compare1 = compare
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering
(<#) :: (Ord1 f, Ord a) => f a -> f a -> Bool
(<=#) :: (Ord1 f, Ord a) => f a -> f a -> Bool
(>=#) :: (Ord1 f, Ord a) => f a -> f a -> Bool
(>#) :: (Ord1 f, Ord a) => f a -> f a -> Bool
max1 :: (Ord1 f, Ord a) => f a -> f a -> f a
min1 :: (Ord1 f, Ord a) => f a -> f a -> f a
class Show1 f where showsPrec1 = showsPrec showList1 ls s = showList__ shows1 ls s
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS
showList1 :: (Show1 f, Show a) => [f a] -> ShowS
show1 :: (Show1 f, Show a) => f a -> String
shows1 :: (Show1 f, Show a) => f a -> ShowS
class Read1 f where readsPrec1 = readsPrec readList1 = readPrec_to_S (list readPrec1) 0
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)
readList1 :: (Read1 f, Read a) => ReadS [f a]
read1 :: (Read1 f, Read a) => String -> f a
reads1 :: (Read1 f, Read a) => ReadS (f a)
readPrec1 :: (Read1 f, Read a) => ReadPrec (f a)
readListPrec1 :: (Read1 f, Read a) => ReadPrec [f a]
readList1Default :: (Read1 f, Read a) => ReadS [f a]
readListPrec1Default :: (Read1 f, Read a) => ReadPrec [f a]
newtype Lift1 f a
Lift1 :: f a -> Lift1 f a
lower1 :: Lift1 f a -> f a
class Eq2 f where ==## = (==)
(==##) :: (Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool
(/=##) :: (Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool
class Eq2 f => Ord2 f where compare2 = compare
compare2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Ordering
(<##) :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Bool
(<=##) :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Bool
(>=##) :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Bool
(>##) :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Bool
max2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> f a b
min2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> f a b
class Show2 f where showsPrec2 = showsPrec showList2 ls s = showList__ shows2 ls s
showsPrec2 :: (Show2 f, Show a, Show b) => Int -> f a b -> ShowS
showList2 :: (Show2 f, Show a, Show b) => [f a b] -> ShowS
show2 :: (Show2 f, Show a, Show b) => f a b -> String
shows2 :: (Show2 f, Show a, Show b) => f a b -> ShowS
class Read2 f where readsPrec2 = readsPrec readList2 = readPrec_to_S (list readPrec2) 0
readsPrec2 :: (Read2 f, Read a, Read b) => Int -> ReadS (f a b)
readList2 :: (Read2 f, Read a, Read b) => ReadS [f a b]
read2 :: (Read2 f, Read a, Read b) => String -> f a b
reads2 :: (Read2 f, Read a, Read b) => ReadS (f a b)
readPrec2 :: (Read2 f, Read a, Read b) => ReadPrec (f a b)
readListPrec2 :: (Read2 f, Read a, Read b) => ReadPrec [f a b]
readList2Default :: (Read2 f, Read a, Read b) => ReadS [f a b]
readListPrec2Default :: (Read2 f, Read a, Read b) => ReadPrec [f a b]
newtype Lift2 f a b
Lift2 :: f a b -> Lift2 f a b
lower2 :: Lift2 f a b -> f a b
instance Functor f => Functor (Lift1 f)
instance Foldable f => Foldable (Lift1 f)
instance Traversable f => Traversable (Lift1 f)
instance Functor (f a) => Functor (Lift2 f a)
instance Foldable (f a) => Foldable (Lift2 f a)
instance Traversable (f a) => Traversable (Lift2 f a)
instance (Read2 f, Read a, Read b) => Read (Lift2 f a b)
instance (Show2 f, Show a, Show b) => Show (Lift2 f a b)
instance (Ord2 f, Ord a, Ord b) => Ord (Lift2 f a b)
instance (Eq2 f, Eq a, Eq b) => Eq (Lift2 f a b)
instance (Read2 f, Read a) => Read1 (Lift2 f a)
instance (Show2 f, Show a) => Show1 (Lift2 f a)
instance (Ord2 f, Ord a) => Ord1 (Lift2 f a)
instance (Eq2 f, Eq a) => Eq1 (Lift2 f a)
instance Read2 f => Read2 (Lift2 f)
instance Show2 f => Show2 (Lift2 f)
instance Ord2 f => Ord2 (Lift2 f)
instance Eq2 f => Eq2 (Lift2 f)
instance (Read1 f, Read a) => Read (Lift1 f a)
instance (Show1 f, Show a) => Show (Lift1 f a)
instance (Ord1 f, Ord a) => Ord (Lift1 f a)
instance (Eq1 f, Eq a) => Eq (Lift1 f a)
instance Read1 f => Read1 (Lift1 f)
instance Show1 f => Show1 (Lift1 f)
instance Ord1 f => Ord1 (Lift1 f)
instance Eq1 f => Eq1 (Lift1 f)
instance Read2 Either
instance Read2 (,)
instance Read a => Read1 ((,) a)
instance Read a => Read1 (Either a)
instance Read1 Maybe
instance Read1 []
instance Show2 Either
instance Show2 (,)
instance Show a => Show1 ((,) a)
instance Show a => Show1 (Either a)
instance Show1 []
instance Show1 Maybe
instance Ord2 Either
instance Ord1 []
instance Ord a => Ord1 (Either a)
instance Ord1 Maybe
instance Eq2 Either
instance Eq1 []
instance Eq a => Eq1 (Either a)
instance Eq1 Maybe
