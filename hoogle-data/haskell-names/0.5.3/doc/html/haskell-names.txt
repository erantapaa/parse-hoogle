-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Name resolution library for Haskell
--   
@package haskell-names
@version 0.5.3


-- | This module is designed to be imported qualified.
module Language.Haskell.Names.LocalSymbolTable

-- | Local symbol table — contains locally bound names
data Table
empty :: Table
lookupValue :: QName l -> Table -> Either (Error l) SrcLoc
addValue :: SrcInfo l => Name l -> Table -> Table
instance Monoid Table

module Language.Haskell.Names.SyntaxUtils
dropAnn :: Functor a => a l -> a ()
setAnn :: Functor a => l' -> a l -> a l'
annName :: Name -> Name ()
getModuleName :: Module l -> ModuleName l
getImports :: Module l -> [ImportDecl l]
getExportSpecList :: Module l -> Maybe (ExportSpecList l)
getDeclHead :: Decl l -> Maybe (DeclHead l)
getDeclHeadName :: DeclHead l -> Name l
getModuleDecls :: Module l -> [Decl l]
isTypeDecl :: Decl l -> Bool
opName :: Op l -> Name l
isCon :: Name l -> Bool
nameToString :: Name l -> String
stringToName :: String -> Name ()
specialConToString :: SpecialCon l -> String
qNameToName :: QName l -> Name l
nameToQName :: Name l -> QName l
unCName :: CName l -> Name l
getErrors :: (Ord l, Foldable a) => a (Scoped l) -> Set (Error l)
type ExtensionSet = Set KnownExtension

-- | Compute the extension set for the given module, based on the global
--   preferences (e.g. specified on the command line) and module's LANGUAGE
--   pragmas.
moduleExtensions :: Language -> [Extension] -> Module l -> ExtensionSet
getModuleExtensions :: Module l -> (Maybe Language, [Extension])


-- | This module is designed to be imported qualified.
module Language.Haskell.Names.GlobalSymbolTable

-- | Global symbol table — contains names declared somewhere at the top
--   level.
type Table = Map QName [Symbol]

-- | Empty global symbol table.
empty :: Table

-- | For each name take the union of the lists of symbols they refer to.
mergeTables :: Table -> Table -> Table
data Result l
SymbolFound :: Symbol -> Result l
Error :: (Error l) -> Result l
Special :: Result l
lookupValue :: QName l -> Table -> Result l
lookupType :: QName l -> Table -> Result l

-- | Methods and associated types in instance declarations are referenced
--   unqualified and still resolved to a symbol that is only in scope
--   qualified.
--   <a>https://www.haskell.org/pipermail/haskell-prime/2008-April/002569.html</a>
--   The test for this is tests<i>annotations</i>QualifiedMethods.hs
lookupUnqualifiedAsQualified :: Name l -> Table -> (Result l, Maybe QName)
lookupName :: QName l -> Table -> Result l
filterTable :: (Symbol -> Bool) -> Table -> Table
isValue :: Symbol -> Bool
isType :: Symbol -> Bool
isMethodOrAssociated :: Symbol -> Bool
fromList :: [(QName, Symbol)] -> Table

module Language.Haskell.Names.GetBound

-- | Get bound value identifiers.
class GetBound a l | a -> l
getBound :: GetBound a l => Table -> a -> [Name l]
instance Data l => GetBound (Pat l) l
instance Data l => GetBound (QualStmt l) l
instance Data l => GetBound (Stmt l) l
instance Data l => GetBound (Match l) l
instance Data l => GetBound (ClassDecl l) l
instance Data l => GetBound (FieldDecl l) l
instance Data l => GetBound (ConDecl l) l
instance Data l => GetBound (GadtDecl l) l
instance Data l => GetBound (QualConDecl l) l
instance Data l => GetBound (Decl l) l
instance Data l => GetBound (Binds l) l
instance (GetBound a l, GetBound b l) => GetBound (a, b) l
instance GetBound a l => GetBound (Maybe a) l
instance GetBound a l => GetBound [a] l

module Language.Haskell.Names.Open

-- | A type that implements <a>Resolvable</a> provides a way to perform a
--   shallow scope-aware traversal.
class Typeable a => Resolvable a
rtraverse :: (Resolvable a, Applicative f, ?alg :: Alg f) => a -> Scope -> f a

-- | The algebra for <a>rtraverse</a>. It's newtype-wrapped because an
--   implicit parameter cannot be polymorphic.
newtype Alg w
Alg :: (forall d. Resolvable d => d -> Scope -> w d) -> Alg w
runAlg :: Alg w -> forall d. Resolvable d => d -> Scope -> w d

-- | Analogous to <a>gmap</a>, but for <a>Resolvable</a>
rmap :: Resolvable a => (forall b. Resolvable b => Scope -> b -> b) -> Scope -> a -> a

-- | Analogous to <a>gmap</a>, but for <a>Resolvable</a>
rfoldMap :: (Monoid r, Resolvable a) => (forall b. Resolvable b => Scope -> b -> r) -> Scope -> a -> r

-- | Contains information about the node's enclosing scope. Can be accessed
--   through the lenses: <a>gTable</a>, <a>lTable</a>, <a>nameCtx</a>,
--   <a>wcNames</a>.
data Scope

-- | Describes how we should treat names in the current context
data NameContext
BindingT :: NameContext
BindingV :: NameContext
ReferenceT :: NameContext
ReferenceV :: NameContext

-- | Reference a method in an instance declaration Unqualified names also
--   match qualified names in scope
--   <a>https://www.haskell.org/pipermail/haskell-prime/2008-April/002569.html</a>
ReferenceUV :: NameContext

-- | Reference an associated type in an instance declaration Unqualified
--   names also match qualified names in scope
--   <a>https://www.haskell.org/pipermail/haskell-prime/2008-April/002569.html</a>
ReferenceUT :: NameContext
Other :: NameContext

-- | Create an initial scope
initialScope :: Table -> Scope
gTable :: Lens Scope Table
lTable :: Lens Scope Table
nameCtx :: Lens Scope NameContext

-- | Information about the names being introduced by a record wildcard
--   
--   During resolving traversal, we always (lazily) construct this list
--   when we process PRec or RecConstr, even if it doesn't contain a
--   wildcard.
--   
--   Then, if the pattern or construction actually contains a wildcard, we
--   use the computed value.
type WcNames = [WcField]

-- | Information about a field in the wildcard
data WcField
WcField :: Name -> ModuleName -> Bool -> WcField

-- | the field's simple name
wcFieldName :: WcField -> Name

-- | the field's original name
wcFieldModuleName :: WcField -> ModuleName

-- | whether there is a global value in scope with the same name as the
--   field but different from the field selector
wcExistsGlobalValue :: WcField -> Bool
wcNames :: Lens Scope WcNames

module Language.Haskell.Names.Annotated

-- | A pair of the name information and original annotation. Used as an
--   annotation type for AST.
data Scoped l
Scoped :: (NameInfo l) -> l -> Scoped l

-- | Information about the names used in an AST.
data NameInfo l

-- | global entitiy and the way it is referenced
GlobalSymbol :: Symbol -> QName -> NameInfo l

-- | local value, and location where it is bound
LocalValue :: SrcLoc -> NameInfo l

-- | type variable, and location where it is bound
TypeVar :: SrcLoc -> NameInfo l

-- | here the value name is bound
ValueBinder :: NameInfo l

-- | here the type name is defined
TypeBinder :: NameInfo l

-- | <tt>import</tt> declaration, and the table of symbols that it
--   introduces
Import :: (Map QName [Symbol]) -> NameInfo l

-- | part of an <tt>import</tt> declaration
ImportPart :: [Symbol] -> NameInfo l

-- | part of an <tt>export</tt> declaration
Export :: [Symbol] -> NameInfo l

-- | wildcard in a record pattern. The list contains resolved names of the
--   fields that are brought in scope by this pattern.
RecPatWildcard :: [Symbol] -> NameInfo l

-- | wildcard in a record construction expression. The list contains
--   resolved names of the fields and information about values assigned to
--   those fields.
RecExpWildcard :: [(Name, NameInfo l)] -> NameInfo l

-- | no annotation
None :: NameInfo l

-- | scope error
ScopeError :: (Error l) -> NameInfo l
annotate :: (Resolvable (a (Scoped l)), Functor a, Typeable l) => Scope -> a l -> a (Scoped l)


-- | Reading <tt>Symbols</tt> from and writing to interface files
module Language.Haskell.Names.Interfaces

-- | The database used by <tt>hs-gen-iface</tt>. Use it together with
--   functions from <a>Distribution.HaskellSuite.Packages</a>.
newtype NamesDB
NamesDB :: FilePath -> NamesDB

-- | Specialized version of <a>runModuleT</a> that works with name files
runNamesModuleT :: ModuleT [Symbol] IO a -> Packages -> Map ModuleName [Symbol] -> IO (a, Map ModuleName [Symbol])

-- | Specialized version of <a>evalModuleT</a> that works with name files
evalNamesModuleT :: ModuleT [Symbol] IO a -> Packages -> IO a

-- | Read an interface file
readInterface :: FilePath -> IO [Symbol]

-- | Write an interface file
writeInterface :: FilePath -> [Symbol] -> IO ()
data IfaceException

-- | Interface could not be parsed. This tells you the file name of the
--   interface file and the parse error text.
BadInterface :: FilePath -> String -> IfaceException
instance Typeable IfaceException
instance Show IfaceException
instance IsPackageDB NamesDB
instance FromJSON Symbol
instance ToJSON Symbol
instance Exception IfaceException

module Language.Haskell.Names.Imports
processImport :: (MonadModule m, ModuleInfo m ~ [Symbol]) => ImportDecl l -> m (ImportDecl (Scoped l), Table)
processImports :: (MonadModule m, ModuleInfo m ~ [Symbol]) => ExtensionSet -> [ImportDecl l] -> m ([ImportDecl (Scoped l)], Table)
instance ModName (ModuleName l)

module Language.Haskell.Names.ModuleSymbols

-- | Compute the symbols that are defined in the given module.
--   
--   The import table is needed to resolve possible top-level record
--   wildcard bindings, such as
--   
--   <pre>
--   A {..} = foo
--   </pre>
moduleSymbols :: (Eq l, Data l) => Table -> Module l -> [Symbol]

-- | Compute module's global table. It contains both the imported entities
--   and the global entities defined in this module.
moduleTable :: (Eq l, Data l) => Table -> Module l -> Table
getTopDeclSymbols :: (Eq l, Data l) => Table -> ModuleName l -> Decl l -> [Symbol]

module Language.Haskell.Names.Exports
processExports :: (MonadModule m, ModuleInfo m ~ [Symbol], Data l, Eq l) => Table -> Module l -> m (Maybe (ExportSpecList (Scoped l)), [Symbol])
resolveExportSpecList :: (MonadModule m, ModuleInfo m ~ [Symbol]) => Table -> ExportSpecList l -> m (ExportSpecList (Scoped l), [Symbol])
resolveExportSpec :: (MonadModule m, ModuleInfo m ~ [Symbol]) => Table -> ExportSpec l -> m (ExportSpec (Scoped l), [Symbol])

module Language.Haskell.Names

-- | <a>computeInterfaces</a> takes a list of possibly recursive modules
--   and computes the interface of each module. The computed interfaces are
--   written into the <tt>m</tt>'s cache and are available to further
--   computations in this monad.
--   
--   Returns the set of import/export errors. Note that the interfaces are
--   registered in the cache regardless of whether there are any errors,
--   but if there are errors, the interfaces may be incomplete.
computeInterfaces :: (MonadModule m, ModuleInfo m ~ [Symbol], Data l, SrcInfo l, Ord l) => Language -> [Extension] -> [Module l] -> m (Set (Error l))

-- | Like <a>computeInterfaces</a>, but also returns a list of interfaces,
--   one per module and in the same order
getInterfaces :: (MonadModule m, ModuleInfo m ~ [Symbol], Data l, SrcInfo l, Ord l) => Language -> [Extension] -> [Module l] -> m ([[Symbol]], Set (Error l))

-- | Annotate a module with scoping information. This assumes that all
--   module dependencies have been resolved and cached — usually you need
--   to run <a>computeInterfaces</a> first, unless you have one module in
--   isolation.
annotateModule :: (MonadModule m, ModuleInfo m ~ [Symbol], Data l, SrcInfo l, Eq l) => Language -> [Extension] -> Module l -> m (Module (Scoped l))

-- | Information about an entity. Carries at least the module it was
--   originally declared in and its name.
data Symbol

-- | value or function
Value :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | class method
Method :: ModuleName -> Name -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name
className :: Symbol -> Name

-- | record field selector
Selector :: ModuleName -> Name -> Name -> [Name] -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name
typeName :: Symbol -> Name
constructors :: Symbol -> [Name]

-- | data constructor
Constructor :: ModuleName -> Name -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name
typeName :: Symbol -> Name

-- | type synonym
Type :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | data type
Data :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | newtype
NewType :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | type family
TypeFam :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | data family
DataFam :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | type class
Class :: ModuleName -> Name -> Symbol
symbolModule :: Symbol -> ModuleName
symbolName :: Symbol -> Name

-- | A pair of the name information and original annotation. Used as an
--   annotation type for AST.
data Scoped l
Scoped :: (NameInfo l) -> l -> Scoped l

-- | Information about the names used in an AST.
data NameInfo l

-- | global entitiy and the way it is referenced
GlobalSymbol :: Symbol -> QName -> NameInfo l

-- | local value, and location where it is bound
LocalValue :: SrcLoc -> NameInfo l

-- | type variable, and location where it is bound
TypeVar :: SrcLoc -> NameInfo l

-- | here the value name is bound
ValueBinder :: NameInfo l

-- | here the type name is defined
TypeBinder :: NameInfo l

-- | <tt>import</tt> declaration, and the table of symbols that it
--   introduces
Import :: (Map QName [Symbol]) -> NameInfo l

-- | part of an <tt>import</tt> declaration
ImportPart :: [Symbol] -> NameInfo l

-- | part of an <tt>export</tt> declaration
Export :: [Symbol] -> NameInfo l

-- | wildcard in a record pattern. The list contains resolved names of the
--   fields that are brought in scope by this pattern.
RecPatWildcard :: [Symbol] -> NameInfo l

-- | wildcard in a record construction expression. The list contains
--   resolved names of the fields and information about values assigned to
--   those fields.
RecExpWildcard :: [(Name, NameInfo l)] -> NameInfo l

-- | no annotation
None :: NameInfo l

-- | scope error
ScopeError :: (Error l) -> NameInfo l

-- | Errors during name resolution.
data Error l

-- | name is not in scope
ENotInScope :: (QName l) -> Error l

-- | name is ambiguous
EAmbiguous :: (QName l) -> [Symbol] -> Error l

-- | type is used where a type class is expected
ETypeAsClass :: (QName l) -> Error l

-- | type class is used where a type is expected
EClassAsType :: (QName l) -> Error l

-- | Attempt to explicitly import a name which is not exported (or,
--   possibly, does not even exist). For example:
--   
--   <pre>
--   import Prelude(Bool(Right))
--   </pre>
--   
--   The fields are:
--   
--   <ol>
--   <li>optional parent in the import list, e.g. <tt>Bool</tt> in
--   <tt>Bool(Right)</tt></li>
--   <li>the name which is not exported</li>
--   <li>the module which does not export the name</li>
--   </ol>
ENotExported :: (Maybe (Name l)) -> (Name l) -> (ModuleName l) -> Error l

-- | module not found
EModNotFound :: (ModuleName l) -> Error l

-- | internal error
EInternal :: String -> Error l

-- | Display an error.
--   
--   Note: can span multiple lines; the trailing newline is included.
ppError :: SrcInfo l => Error l -> String

-- | Pretty print a symbol.
ppSymbol :: Symbol -> String
