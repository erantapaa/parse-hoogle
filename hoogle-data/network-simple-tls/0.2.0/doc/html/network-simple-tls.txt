-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple interface to TLS secured network sockets.
--   
--   Simple interface to TLS secured network sockets.
@package network-simple-tls
@version 0.2.0


-- | This module exports simple tools for establishing TLS-secured TCP
--   connections, relevant to both the client side and server side of the
--   connection.
--   
--   This module re-exports some functions from the
--   <a>Network.Simple.TCP</a> module in the <tt>network-simple</tt>
--   package. Consider using that module directly if you need a similar API
--   without TLS support.
--   
--   This module uses <a>MonadIO</a> and <a>MonadCatch</a> extensively so
--   that you can reuse these functions in monads other than <a>IO</a>.
--   However, if you don't care about any of that, just pretend you are
--   using the <a>IO</a> monad all the time and everything will work as
--   expected.
module Network.Simple.TCP.TLS

-- | Start a TLS-secured TCP server that accepts incoming connections and
--   handles each of them concurrently, in different threads.
--   
--   Any acquired network resources are properly closed and discarded when
--   done or in case of exceptions. This function binds a listening socket,
--   accepts an incoming connection, performs a TLS handshake and then
--   safely closes the connection when done or in case of exceptions. You
--   don't need to perform any of those steps manually.
serve :: MonadIO m => ServerSettings -> HostPreference -> ServiceName -> ((Context, SockAddr) -> IO ()) -> m ()

-- | Bind a TCP listening socket and use it.
--   
--   The listening socket is closed when done or in case of exceptions.
--   
--   If you prefer to acquire and close the socket yourself, then use
--   <a>bindSock</a>, <a>closeSock</a> and the <a>listen</a> function from
--   <a>Network.Socket</a> instead.
--   
--   Note: <a>maxListenQueue</a> is tipically 128, which is too small for
--   high performance servers. So, we use the maximum between
--   <a>maxListenQueue</a> and 2048 as the default size of the listening
--   queue. The <a>NoDelay</a> and <a>ReuseAddr</a> options are set on the
--   socket.
listen :: (MonadIO m, MonadCatch m) => HostPreference -> ServiceName -> ((Socket, SockAddr) -> m r) -> m r

-- | Accepts a single incomming TLS-secured TCP connection and use it.
--   
--   A TLS handshake is performed immediately after establishing the TCP
--   connection and the TLS and TCP connections are properly closed when
--   done or in case of exceptions. If you need to manage the lifetime of
--   the connection resources yourself, then use <a>acceptTls</a> instead.
accept :: (MonadIO m, MonadCatch m) => ServerSettings -> Socket -> ((Context, SockAddr) -> m r) -> m r

-- | Like <a>accept</a>, except it uses a different thread to performs the
--   TLS handshake and run the given computation.
acceptFork :: MonadIO m => ServerSettings -> Socket -> ((Context, SockAddr) -> IO ()) -> m ThreadId

-- | Abstract type representing the configuration settings for a TLS
--   server.
--   
--   Use <a>makeServerSettings</a> to obtain your <a>ServerSettings</a>
--   value, and <a>updateServerParams</a> to update it.
data ServerSettings

-- | Make default <a>ServerSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Supported cipher suites for <a>TLS10</a></i> In decreasing
--   order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>, <a>cipher_RC4_128_SHA1</a>,
--   <a>cipher_RC4_128_MD5</a>. The cipher suite preferred by the client is
--   used.</li>
--   <li><i>Supported cipher suites for <a>TLS11</a> and <a>TLS12</a></i>
--   In decreasing order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>. The cipher suite preferred by the client is
--   used.</li>
--   </ul>
makeServerSettings :: Credential -> Maybe CertificateStore -> ServerSettings

-- | Update advanced TLS server configuration <a>Params</a>. See the
--   <a>Network.TLS</a> module for details.
updateServerParams :: (Params -> Params) -> ServerSettings -> ServerSettings

-- | A <a>Lens</a> into the TLS server configuration <a>Params</a>. See the
--   <a>Network.TLS</a> and the <tt>lens</tt> package for details.
serverParams :: Functor f => (Params -> f Params) -> (ServerSettings -> f ServerSettings)

-- | Connect to a TLS-secured TCP server and use the connection
--   
--   A TLS handshake is performed immediately after establishing the TCP
--   connection and the TLS and TCP connections are properly closed when
--   done or in case of exceptions. If you need to manage the lifetime of
--   the connection resources yourself, then use <a>connectTls</a> instead.
connect :: (MonadIO m, MonadCatch m) => ClientSettings -> HostName -> ServiceName -> ((Context, SockAddr) -> m r) -> m r

-- | Abstract type representing the configuration settings for a TLS
--   client.
--   
--   Use <a>makeClientSettings</a> or <a>getDefaultClientSettings</a> to
--   obtain your <a>ClientSettings</a> value.
data ClientSettings

-- | Make defaults <a>ClientSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Version reported during <i>ClientHello</i></i>
--   <a>TLS10</a>.</li>
--   <li><i>Supported cipher suites</i> In decreasing order of preference:
--   <a>cipher_AES256_SHA256</a>, <a>cipher_AES256_SHA1</a>,
--   <a>cipher_AES128_SHA256</a>, <a>cipher_AES128_SHA1</a>,
--   <a>cipher_RC4_128_SHA1</a>, <a>cipher_RC4_128_MD5</a>.</li>
--   </ul>
makeClientSettings :: [Credential] -> Maybe HostName -> CertificateStore -> ClientSettings

-- | Get the system default <a>ClientSettings</a>.
--   
--   See <a>makeClientSettings</a> for the for the default TLS settings
--   used.
getDefaultClientSettings :: MonadIO m => m ClientSettings

-- | Update advanced TLS client configuration <a>Params</a>. See the
--   <a>Network.TLS</a> module for details.
updateClientParams :: (Params -> Params) -> ClientSettings -> ClientSettings

-- | A <a>Lens</a> into the TLS client configuration <a>Params</a>. See the
--   <a>Network.TLS</a> and the <tt>lens</tt> package for details.
clientParams :: Functor f => (Params -> f Params) -> (ClientSettings -> f ClientSettings)

-- | Primary certificate, private key and the rest of the certificate
--   chain.
data Credential
Credential :: !X509 -> !PrivateKey -> [X509] -> Credential

-- | Convert client <a>Credential</a> to the format expected by
--   <a>pCertificates</a>.
credentialToCertList :: Credential -> [(X509, Maybe PrivateKey)]

-- | Receives decrypted bytes from the given <a>Context</a>. Returns
--   <a>Nothing</a> on EOF.
--   
--   Up to <tt>16384</tt> decrypted bytes will be received at once. The TLS
--   connection is automatically renegotiated if a <i>ClientHello</i>
--   message is received.
recv :: MonadIO m => Context -> m (Maybe ByteString)

-- | Encrypts the given strict <a>ByteString</a> and sends it through the
--   <a>Context</a>.
send :: MonadIO m => Context -> ByteString -> m ()

-- | Perform a TLS handshake on the given <a>Context</a>, then perform the
--   given action and at last gracefully close the TLS session using
--   <a>bye</a>.
--   
--   This function does not close the underlying TCP connection when done.
--   Prefer to use <a>useTlsThenClose</a> or <a>useTlsThenCloseFork</a> if
--   you need that behavior. Otherwise, you must call <a>contextClose</a>
--   yourself at some point.
useTls :: (MonadIO m, MonadCatch m) => ((Context, SockAddr) -> m a) -> ((Context, SockAddr) -> m a)

-- | Like <a>useTls</a>, except it also fully closes the TCP connection
--   when done.
useTlsThenClose :: (MonadIO m, MonadCatch m) => ((Context, SockAddr) -> m a) -> ((Context, SockAddr) -> m a)

-- | Similar to <a>useTlsThenClose</a>, except it performs the all the IO
--   actions in a new thread.
--   
--   Use this instead of forking <a>useTlsThenClose</a> yourself, as that
--   won't give the right behavior.
useTlsThenCloseFork :: MonadIO m => ((Context, SockAddr) -> IO ()) -> ((Context, SockAddr) -> m ThreadId)

-- | Estalbishes a TCP connection to a remote server and returns a TLS
--   <a>Context</a> configured on top of it using the given
--   <a>ClientSettings</a>. The remote end address is also returned.
--   
--   Prefer to use <a>connect</a> if you will be using the obtained
--   <a>Context</a> within a limited scope.
--   
--   You need to perform a TLS handshake on the resulting <a>Context</a>
--   before using it for communication purposes, and gracefully close the
--   TLS and TCP connections afterwards using. The <a>useTls</a>,
--   <a>useTlsThenClose</a> and <a>useTlsThenCloseFork</a> can help you
--   with that.
connectTls :: MonadIO m => ClientSettings -> HostName -> ServiceName -> m (Context, SockAddr)

-- | Accepts an incoming TCP connection and returns a TLS <a>Context</a>
--   configured on top of it using the given <a>ServerSettings</a>. The
--   remote end address is also returned.
--   
--   Prefer to use <a>accept</a> if you will be using the obtained
--   <a>Context</a> within a limited scope.
--   
--   You need to perform a TLS handshake on the resulting <a>Context</a>
--   before using it for communication purposes, and gracefully close the
--   TLS and TCP connections afterwards using. The <a>useTls</a>,
--   <a>useTlsThenClose</a> and <a>useTlsThenCloseFork</a> can help you
--   with that.
acceptTls :: MonadIO m => ServerSettings -> Socket -> m (Context, SockAddr)

-- | Make a client-side TLS <a>Context</a> for the given settings, on top
--   of the given TCP <a>Socket</a> connected to the remote end.
makeClientContext :: MonadIO m => ClientSettings -> Socket -> m Context

-- | Make a server-side TLS <a>Context</a> for the given settings, on top
--   of the given TCP <a>Socket</a> connected to the remote end.
makeServerContext :: MonadIO m => ServerSettings -> Socket -> m Context

-- | On Windows operating systems, the networking subsystem has to be
--   initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   Although this is only strictly necessary on Windows platforms, it is
--   harmless on other platforms, so for portability it is good practice to
--   use it all the time.
withSocketsDo :: IO a -> IO a
instance Show Credential
