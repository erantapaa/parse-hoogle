-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a remote procedure call framework
--   
--   A library and framework for making remote procedure calls in haskell
--   easy and typesafe.
--   
--   See <a>http://github.com/mmirman/rpc-framework</a> for more
--   information.
@package rpc-framework
@version 2.0.0.2

module Control.Concurrent.ForkableRPC
class Monad m => Forkable m
forkIO :: Forkable m => m a -> m ThreadId
instance [incoherent] Forkable m => Forkable (StateT s m)
instance [incoherent] Forkable m => Forkable (ReaderT r m)
instance [incoherent] Forkable IO


-- | A server that allows for the declaration of services and for the
--   calling of services.
module Network.Remote.RPC.Internal.MultiServer
data ServiceID
LocNumber :: Integer -> ServiceID
LocName :: String -> ServiceID
data Message
Talk :: ServiceID -> Message
Kill :: ServiceID -> Message
type Handlers m = Map ServiceID (Handle -> AIO m ())
type State m = MVar (Handlers m, Integer)
newtype AIO m a
AIO :: (ReaderT (State m) m a) -> AIO m a
send :: (Show a, MonadIO m) => Handle -> a -> m ()
recv :: (Read a, MonadIO m) => Handle -> m a
startServer :: Servable m => Integer -> AIO m a -> m a
safeFind :: (Ord k, Show k) => Map k a -> k -> a
getHandlers :: Monad m => AIO m (State m)
addService :: (Monad m, MonadIO m) => (Handle -> AIO m ()) -> AIO m ServiceID
addServiceByName :: (Monad m, MonadIO m) => String -> (Handle -> AIO m ()) -> AIO m ServiceID
connectToService :: MonadIO m => String -> Integer -> ServiceID -> m Handle

-- | <a>Servable</a> is a declaration that the given monad can be made into
--   a servlet.
class (Functor m, Monad m, MonadIO m, Forkable m) => Servable m
track :: Servable m => (String, Integer, ServiceID) -> a -> AIO m a
instance [incoherent] Forkable m => Forkable (AIO m)
instance [incoherent] MonadIO m => MonadIO (AIO m)
instance [incoherent] Functor m => Functor (AIO m)
instance [incoherent] Monad m => Monad (AIO m)
instance [incoherent] Show ServiceID
instance [incoherent] Read ServiceID
instance [incoherent] Ord ServiceID
instance [incoherent] Eq ServiceID
instance [incoherent] Show Message
instance [incoherent] Read Message
instance [incoherent] Ord Message
instance [incoherent] Eq Message
instance [incoherent] Servable m => Servable (AIO m)
instance [incoherent] Servable IO
instance [incoherent] Monad m => MonadReader (State m) (AIO m)
instance [incoherent] MonadTrans AIO


-- | The functions for using a function as a service and calling a remote
--   process
module Network.Remote.RPC.Internal.Runtime

-- | <tt><a>WIO</a> w m a</tt> is a newtype over a server transformer that
--   adds the phantom host argument <tt>w</tt>
data WIO w m a

-- | <a>onHost</a> declares that the code is running on the given host. it
--   is usefull when a type inference is wanted, but the action also needs
--   to be made into a service and used as a remote procedure
onHost :: (Servable m, Host w) => w -> WIO w m ()
world :: (Servable m, Host w) => WIO w m w
realRemoteCall :: RPC a a' m w => a -> String -> a'
makeService :: Service a m w => a -> String -> WIO w m ()

-- | <tt><a>Host</a> World</tt> declares that the world is a host. It
--   should only have one constructor, and the location and port should be
--   invariant of the given constructor. Specifically, <tt>getLocation</tt>
--   and <tt>getPort</tt> should work even if bottom is supplied.
class Host a where getData w = do { let (_ :: a, ioref) = topLevelSetter; readIORef ioref } setHost _ l p = do { let (_ :: a, ioref) = topLevelSetter; writeIORef ioref (l, p) } topLevelSetter = (getValue,  unsafePerformIO $ do { newIORef $ getDataDefault (getValue :: a) })
getDataDefault :: Host a => a -> (String, Integer)
getValue :: Host a => a
setHost :: Host a => a -> String -> Integer -> IO ()
class (Host w, Servable m, Servable m') => Sendable w m a m' a' | m a' w -> a, m' a -> a', a -> m w, a' -> m'
class (Servable m, Servable m') => Receivable m a m' a' | m a' -> a, m' a -> a', a -> m, a' -> m'

-- | <a>Servable</a> is a declaration that the given monad can be made into
--   a servlet.
class (Functor m, Monad m, MonadIO m, Forkable m) => Servable m
data Ref a a'

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | <a>runServer</a> runs a name server and doesn't return
runServer :: (Servable m, Host w) => WIO w m () -> m ()

-- | <a>runServerBG</a> runs a name server on a background thread and does
--   return
runServerBG :: Host w => WIO w IO () -> IO ThreadId
instance [incoherent] Read (Ref a a')
instance [incoherent] Show (Ref a a')
instance [incoherent] Forkable m => Forkable (WIO w m)
instance [incoherent] MonadIO m => MonadIO (WIO w m)
instance [incoherent] Functor m => Functor (WIO w m)
instance [incoherent] Monad m => Monad (WIO w m)
instance [incoherent] (Receivable m a' m a, Service b m w) => Service (a -> b) m w
instance [incoherent] (Host w, Servable m, Sendable w m a m a') => Service (WIO w m a) m w
instance [incoherent] (Sendable w' m a' m a, RPC b b' m w') => RPC (a -> b) (a' -> b') m w'
instance [incoherent] (Receivable m a m' a', Host w, Host w', Servable m, Servable m') => RPC (WIO w m a) (WIO w' m' a') m' w'
instance [incoherent] (Sendable w' m' a' m a, Receivable m b m' b') => Receivable m (a -> b) m' (a' -> WIO w' m' b')
instance [incoherent] (Receivable m' a' m a, Sendable w m b m' b') => Sendable w m (a -> b) m' (a' -> WIO w' m' b')
instance [incoherent] Receivable m b m' b' => Receivable m (WIO w m b) m' (WIO w' m' b')
instance [incoherent] Sendable w m b m' b' => Sendable w m (WIO w m b) m' (WIO w' m' b')
instance [incoherent] (Show a, Read a', a ~ a', Servable m', Servable m) => Receivable m a m' a'
instance [incoherent] (Show a, Read a', a ~ a', Servable m', Servable m, Host w) => Sendable w m a m' a'
instance [incoherent] MonadTrans (WIO w)
instance [incoherent] Servable m => Servable (WIO w m)

module Network.Remote.RPC.Internal.Templates

-- | <tt>$(<a>rpcCall</a> 'serviceNm)</tt> simply splices in
--   <tt><a>realRemoteCall</a> (undefined :: typeofcall) "serviceNm"</tt>
--   which is typed in a manner similar to typeofcall.
rpcCall :: Name -> Q Exp

-- | <tt>$(<a>makeHost</a> "HostName" "hostLocation" hostPortNumber)</tt>
--   makes a <tt>newtype HostName</tt> and declares an <tt>instance
--   <tt>Host</tt> HostName</tt>.
makeHost :: String -> String -> Integer -> Q [Dec]

-- | <tt>$(<a>makeServices</a> ['service1 ,..., 'serviceN])</tt> makes all
--   given services listen for incoming requests.
makeServices :: [Name] -> Q Exp

-- | <tt>$(<a>autoService</a> 'World)</tt> finds all services declared in
--   the module that definitely run on the given world, and makes them
--   listen for incoming requests.
autoService :: Name -> Q Exp
instance [incoherent] MonadIO Q


-- | Declaration of the frontend for RPC.
module Network.Remote.RPC

-- | <tt><a>Host</a> World</tt> declares that the world is a host. It
--   should only have one constructor, and the location and port should be
--   invariant of the given constructor. Specifically, <tt>getLocation</tt>
--   and <tt>getPort</tt> should work even if bottom is supplied.
class Host a where getData w = do { let (_ :: a, ioref) = topLevelSetter; readIORef ioref } setHost _ l p = do { let (_ :: a, ioref) = topLevelSetter; writeIORef ioref (l, p) } topLevelSetter = (getValue,  unsafePerformIO $ do { newIORef $ getDataDefault (getValue :: a) })
getDataDefault :: Host a => a -> (String, Integer)
getValue :: Host a => a
setHost :: Host a => a -> String -> Integer -> IO ()

-- | <tt><a>WIO</a> w m a</tt> is a newtype over a server transformer that
--   adds the phantom host argument <tt>w</tt>
data WIO w m a
world :: (Servable m, Host w) => WIO w m w

-- | <a>Servable</a> is a declaration that the given monad can be made into
--   a servlet.
class (Functor m, Monad m, MonadIO m, Forkable m) => Servable m

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | <a>runServer</a> runs a name server and doesn't return
runServer :: (Servable m, Host w) => WIO w m () -> m ()

-- | <a>runServerBG</a> runs a name server on a background thread and does
--   return
runServerBG :: Host w => WIO w IO () -> IO ThreadId

-- | <a>onHost</a> declares that the code is running on the given host. it
--   is usefull when a type inference is wanted, but the action also needs
--   to be made into a service and used as a remote procedure
onHost :: (Servable m, Host w) => w -> WIO w m ()

-- | <tt>$(<a>autoService</a> 'World)</tt> finds all services declared in
--   the module that definitely run on the given world, and makes them
--   listen for incoming requests.
autoService :: Name -> Q Exp

-- | <tt>$(<a>makeHost</a> "HostName" "hostLocation" hostPortNumber)</tt>
--   makes a <tt>newtype HostName</tt> and declares an <tt>instance
--   <tt>Host</tt> HostName</tt>.
makeHost :: String -> String -> Integer -> Q [Dec]

-- | <tt>$(<a>makeServices</a> ['service1 ,..., 'serviceN])</tt> makes all
--   given services listen for incoming requests.
makeServices :: [Name] -> Q Exp

-- | <tt>$(<a>rpcCall</a> 'serviceNm)</tt> simply splices in
--   <tt><a>realRemoteCall</a> (undefined :: typeofcall) "serviceNm"</tt>
--   which is typed in a manner similar to typeofcall.
rpcCall :: Name -> Q Exp
class Monad m => Forkable m
forkIO :: Forkable m => m a -> m ThreadId

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a transformer of
--   monads:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: (* -> *) -> * -> *)
lift :: (MonadTrans t, Monad m) => m a -> t m a
