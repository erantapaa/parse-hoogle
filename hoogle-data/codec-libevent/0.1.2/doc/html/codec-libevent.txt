-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cross-platform structure serialisation
--   
--   This package parses and generates Haskell code for serialising and
--   deserialising the tagging format in libevent 1.4.
@package codec-libevent
@version 0.1.2

module Codec.Libevent.Class
class TaggedStructure a
empty :: TaggedStructure a => a
serialise :: TaggedStructure a => a -> ByteString
deserialise :: TaggedStructure a => ByteString -> Either String a


-- | This module parses libevent <a>http://monkey.org/~provos/libevent</a>
--   tagged data structures as implimented in libevent-1.4.0-beta. These
--   data structures are described in a .rpc file.
module Codec.Libevent.Parse

-- | This is a libevent .rpc file - just a list of the structures within
data RPCFile
RPCFile :: [RPCStruct] -> RPCFile
rpcstructs :: RPCFile -> [RPCStruct]

-- | An RPC structure has a name and a list of elements
data RPCStruct
RPCStruct :: String -> [RPCElem] -> RPCStruct
structname :: RPCStruct -> String
structelems :: RPCStruct -> [RPCElem]

-- | An RPC element is a tagged member
data RPCElem
RPCElem :: Presence -> Type -> String -> Integer -> RPCElem
elempresence :: RPCElem -> Presence
elemtype :: RPCElem -> Type
elemname :: RPCElem -> String
elemtag :: RPCElem -> Integer
data Presence
Required :: Presence
Optional :: Presence
Repeated :: Presence
data Type
Bytes :: Int -> Type
VarBytes :: Type
String :: Type
Int :: Type
Struct :: String -> Type

-- | Parse the given filename
parseRPCFile :: FilePath -> IO (Either ParseError RPCFile)

-- | Parse the given string as an RPC file
parseRPC :: String -> Either ParseError RPCFile
instance Eq Type
instance Show Type
instance Show Presence
instance Show RPCElem
instance Show RPCStruct
instance Show RPCFile


-- | This module generates Haskell code for serialising and deserialising
--   libevent tagged data structures, as implemented in
--   libevent-1.4.0-beta.
--   
--   A single .rpc file (containing one or more structures) is mapped to a
--   single Haskell file. Take this example:
--   
--   <pre>
--   struct test {
--     required int a = 1;
--     optional string b = 2;
--     repeated struct[test2] c = 3;
--   }
--   </pre>
--   
--   This will result in a data decl for <tt>Test</tt>, having named
--   members: test_a, test_b and test_c. Required elements are simple,
--   optional elements are wrapped in a Maybe and repeated elements in a
--   list.
--   
--   Types are mapped thus:
--   
--   <ul>
--   <li>int -&gt; Word32</li>
--   <li>string -&gt; String</li>
--   <li>bytes -&gt; ByteString (strict)</li>
--   <li>bytes[n] -&gt; ByteString (with runtime checks on the size)</li>
--   <li>struct[name] -&gt; Name (the struct must be defined in the same
--   file)</li>
--   </ul>
--   
--   In the example above, <tt>test2</tt> is required to be in the same
--   .rpc file.
--   
--   For a structure named <tt>test</tt>, the following would also be
--   generated:
--   
--   <ul>
--   <li><tt>testEmpty</tt> - a Test filled with default values</li>
--   <li><tt>testDeserialise</tt> - a strict Get instance to deserialise a
--   test. Note that these structures are self-deliminating, so additional
--   garbage at the end will be consumed and will probably result in an
--   error</li>
--   <li><tt>testDeserialiseBS</tt> - a function with type ByteString -&gt;
--   Either String Test where the String is an error message</li>
--   <li><tt>testSerialise</tt> - a Put Test function. Again, recall that
--   these structures aren't self deliminating</li>
--   <li><tt>testSerialiseBS</tt> - a function with type Test -&gt;
--   ByteString</li>
--   </ul>
--   
--   Each structure will also be an instance of the
--   <tt>TaggedStructure</tt> class that you can find in
--   <a>Codec.Libevent.Class</a>
module Codec.Libevent.Generate

-- | Generate the Haskell code for the given RPC file and write to standard
--   out. The generated module will export everything and takes the given
--   name
generate :: String -> RPCFile -> IO ()


-- | Tagged data structures are an extensible way of serialising data in a
--   platform independent way for transmission across a network etc. This
--   package implements the tagged structures from libevent 1.4.0-beta.
--   
--   A tagged structure is described in a text file and might look like
--   this:
--   
--   <pre>
--   struct foo {
--     required int count = 1;
--     optional struct[bar] names = 2;
--   }
--   
--   struct bar {
--     repeated string s = 1;
--   }
--   </pre>
--   
--   The numbers after the equals signs are the tag numbers for each
--   element of a structure. The tag numbers must be unique within a
--   structure and should be sequenctial (but are not required to be).
--   
--   The tag numbers must also be fixed for all time. When deserialising,
--   unknown tags are ignored. Thus one can add a new (non-required)
--   element to <tt>foo</tt> in the future and still interoperate with
--   older code which knows nothing of the new element.
--   
--   Each element in the description looks like:
--   
--   <pre>
--   &lt;presence&gt; &lt;type&gt; &lt;name&gt; = &lt;tag number&gt; ;
--   </pre>
--   
--   The possible presence values are: <tt>required</tt>, <tt>optional</tt>
--   and <tt>repeated</tt>. The types are (currently): <tt>int</tt>,
--   <tt>string</tt>, <tt>struct[NAME]</tt> and <tt>bytes</tt>.
--   
--   Other modules in this package parse these descriptions and
--   automatically generate Haskell code for them. You should have a binary
--   called <tt>codec-libevent-generate</tt> which does this. See the
--   documentation for <a>Codec.Libevent.Generate</a> about the structure
--   of the generated code.
--   
--   Once you have generated the code, you can import it as a regular
--   Haskell module and serialise/deserialise these structures. You can
--   also use the libevent library to process them in C.
--   
--   This module contains helper functions and is imported by the code
--   generated by <a>Codec.Libevent.Generate</a>. Apart from the
--   <tt>TaggedStructure</tt> class, there's probably not anything
--   generally useful here.
module Codec.Libevent

-- | Decode a base128 encoded integer. This is a variable length encoded
--   int where the last byte has the MSB set to 0.
getBase128 :: Get Word32

-- | Encode a integer in Base128 form
putBase128 :: Word32 -> Put

-- | Decode a number where the first nibble of the first byte is the number
--   of nibbles in the number. The remaining nibbles appear in
--   little-endian order following, with 0 padding to the nearest byte.
getLengthPrefixed :: Get Word32

-- | Return the number of nibbles, n, required to encode a given number. n
--   &gt;= 1
nibbleLength :: Word32 -> Int

-- | Encode a Word32 by prefixing the number of nibbles and following with
--   the nibbles of the number in little-endian order
putLengthPrefixed :: Word32 -> Put

-- | Return the length of the length-prefixed representation of a Word32
lengthPrefixedLength :: Word32 -> Int
putTaggedWord32 :: Word32 -> Word32 -> Put
putTaggedString :: Word32 -> String -> Put
putTaggedVarBytes :: Word32 -> ByteString -> Put
decodeString :: ByteString -> String
