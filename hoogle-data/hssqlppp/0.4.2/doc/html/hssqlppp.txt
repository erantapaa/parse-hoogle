-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SQL parser and type checker
--   
--   SQL parser and type checker, targets PostgreSQL SQL and PL/pgSQL.
--   
--   Documentation, examples on the homepage:
--   <a>http://jakewheat.github.com/hssqlppp/</a>.
--   
--   Changes here:
--   <a>https://github.com/JakeWheat/hssqlppp/blob/master/CHANGES</a>
@package hssqlppp
@version 0.4.2


-- | Contains the SQL data types, type errors, and a few supporting
--   functions.
module Database.HsSqlPpp.Types
data Type
ScalarType :: String -> Type
ArrayType :: Type -> Type
SetOfType :: Type -> Type
NamedCompositeType :: String -> Type
CompositeType :: [(String, Type)] -> Type
AnonymousRecordType :: [Type] -> Type
PgRecord :: (Maybe Type) -> Type
DomainType :: String -> Type
EnumType :: String -> Type
Pseudo :: PseudoType -> Type
UnknownType :: Type
data PseudoType
Any :: PseudoType
AnyArray :: PseudoType
AnyElement :: PseudoType
AnyEnum :: PseudoType
AnyNonArray :: PseudoType
Cstring :: PseudoType
Record :: PseudoType
TriggerRecord :: PseudoType
Trigger :: PseudoType
Void :: PseudoType
Internal :: PseudoType
LanguageHandler :: PseudoType
Opaque :: PseudoType
FdwHandler :: PseudoType
typeSmallInt :: Type
typeBigInt :: Type
typeInt :: Type
typeNumeric :: Type
typeFloat4 :: Type
typeFloat8 :: Type
typeVarChar :: Type
typeChar :: Type
typeBool :: Type
typeDate :: Type
typeInterval :: Type
canonicalizeTypeName :: String -> String
canonicalizeTypes :: Data a => a -> a
data TypeError
WrongTypes :: Type -> [Type] -> TypeError
UnknownTypeError :: Type -> TypeError
UnknownTypeName :: String -> TypeError
NoMatchingOperator :: String -> [Type] -> TypeError
TypelessEmptyArray :: TypeError
IncompatibleTypeSet :: [Type] -> TypeError
IncompatibleTypes :: Type -> Type -> TypeError
ValuesListsMustBeSameLength :: TypeError
NoRowsGivenForValues :: TypeError
UnrecognisedIdentifier :: String -> TypeError
UnrecognisedRelation :: String -> TypeError
UnrecognisedCorrelationName :: String -> TypeError
BadStarExpand :: TypeError
AmbiguousIdentifier :: String -> TypeError
ContextError :: String -> TypeError
MissingJoinAttribute :: TypeError
ExpressionMustBeBool :: TypeError
WrongNumberOfColumns :: TypeError
ExpectedDomainType :: Type -> TypeError
DomainDefNotFound :: Type -> TypeError
BadCatalogUpdate :: String -> TypeError
TypeAlreadyExists :: Type -> TypeError
AnyAllError :: String -> TypeError
InternalError :: String -> TypeError
FromToTypesNotSame :: Type -> Type -> TypeError
WrongNumberOfAliasCols :: Int -> Int -> TypeError
MiscError :: String -> TypeError


-- | This module contains the database catalog data types and helper
--   functions.
--   
--   The catalog data type serves the following purposes:
--   
--   <ul>
--   <li>Contains all the catalog information needed to type check against
--   an existing database.</li>
--   <li>A copy of the catalog information from a default template1
--   database is included - <a>defaultTemplate1Catalog</a>.</li>
--   <li>It is used internally to keep track of updates to the catalog
--   whilst running an annotation process (e.g. so that a select can type
--   check against a create table given in the same source). It is also
--   used to track other identifier types, such as attribute references in
--   select expressions, and argument and variable types inside create
--   function statements.</li>
--   </ul>
--   
--   You can see what kind of stuff is contained in the Catalog type by
--   looking at the <a>CatalogUpdate</a> type.
module Database.HsSqlPpp.Catalog

-- | The main datatype, this holds the catalog and context information to
--   type check against.
data Catalog
data CatalogUpdate

-- | add a new scalar type with the name given, also creates an array type
--   automatically
CatCreateScalar :: Type -> String -> Bool -> CatalogUpdate

-- | add a new domain to the catalog
CatCreateDomain :: Type -> Type -> CatalogUpdate

-- | add a new composite type to the catalog
CatCreateComposite :: String -> [(String, Type)] -> CatalogUpdate

-- | add a new cast to the catalog
CatCreateCast :: Type -> Type -> CastContext -> CatalogUpdate

-- | add a new table to the catalog with the given public and private
--   columns also creates the composite type to go with this table
CatCreateTable :: String -> [(String, Type)] -> [(String, Type)] -> CatalogUpdate

-- | add the view to the catalog, using the column names and types supplied
CatCreateView :: String -> [(String, Type)] -> CatalogUpdate

-- | add a new function to the catalog
CatCreateFunction :: FunFlav -> String -> [Type] -> Type -> Bool -> CatalogUpdate

-- | drop a function from the catalog
CatDropFunction :: Bool -> String -> [Type] -> CatalogUpdate

-- | attempt to show a readable representation of a <a>CatalogUpdate</a>
--   value
ppCatUpdate :: CatalogUpdate -> String

-- | Use to note what the flavour of a cast is, i.e. if/when it can be used
--   implicitly.
data CastContext
ImplicitCastContext :: CastContext
AssignmentCastContext :: CastContext
ExplicitCastContext :: CastContext

-- | Used to distinguish between standalone composite types, and
--   automatically generated ones, generated from a table or view
--   respectively.
data CompositeFlavour
Composite :: CompositeFlavour
TableComposite :: CompositeFlavour
ViewComposite :: CompositeFlavour

-- | Provides the definition of a composite type. The components are
--   composite (or table or view) name, the flavour of the composite, the
--   types of the composite attributes, and the types of the system columns
--   iff the composite represents a table type (the third and fourth
--   components are always <a>CompositeType</a>s).
type CompositeDef = (String, CompositeFlavour, Type, Type)

-- | The components are: function (or operator) name, argument types,
--   return type and is variadic.
type FunctionPrototype = (String, [Type], Type, Bool)

-- | The components are domain type, base type (todo: add check
--   constraint).
type DomainDefinition = (Type, Type)
data FunFlav
FunPrefix :: FunFlav
FunPostfix :: FunFlav
FunBinary :: FunFlav
FunName :: FunFlav
FunAgg :: FunFlav
FunWindow :: FunFlav

-- | Represents an empty catalog. This doesn't contain things like the
--   'and' operator, <a>defaultCatalog</a> contains these.
emptyCatalog :: Catalog

-- | Represents what you probably want to use as a starting point if you
--   are building an catalog from scratch. It contains information on built
--   in function like things that aren't in the PostgreSQL catalog, such as
--   greatest, coalesce, keyword operators like 'and', etc..
defaultCatalog :: Catalog
defaultTemplate1Catalog :: Catalog

-- | items in first catalog and not second, items in second and not first.
data CatalogDiff
CatalogDiff :: [CatalogUpdate] -> [CatalogUpdate] -> CatalogDiff

-- | find differences between two catalogs
compareCatalogs :: Catalog -> Catalog -> Catalog -> CatalogDiff

-- | print a catdiff in a more human readable way than show.
ppCatDiff :: CatalogDiff -> String

-- | Applies a list of <a>CatalogUpdate</a>s to an <a>Catalog</a> value to
--   produce a new Catalog value.
updateCatalog :: Catalog -> [CatalogUpdate] -> Either [TypeError] Catalog
deconstructCatalog :: Catalog -> [CatalogUpdate]
data OperatorType
BinaryOp :: OperatorType
PrefixOp :: OperatorType
PostfixOp :: OperatorType
getOperatorType :: Catalog -> String -> Either [TypeError] OperatorType
isOperatorName :: String -> Bool


-- | Contains the annotation data types and a few auxiliary functions.
module Database.HsSqlPpp.Annotation

-- | Annotation type - one of these is attached to most of the data types
--   used in the ast.
data Annotation
Annotation :: Maybe SourcePosition -> Maybe Type -> [TypeError] -> Maybe ParameterizedStatementType -> [CatalogUpdate] -> Maybe FunctionPrototype -> Maybe Type -> Annotation

-- | source position for this node
asrc :: Annotation -> Maybe SourcePosition

-- | type of the node, <a>Nothing</a> if the tree hasn't been typechecked
--   or if a type error prevents determining the type
atype :: Annotation -> Maybe Type

-- | any type errors
errs :: Annotation -> [TypeError]

-- | used for getting the in and out types of a parameterized statement
stType :: Annotation -> Maybe ParameterizedStatementType

-- | any catalog updates that a ddl statement produces
catUpd :: Annotation -> [CatalogUpdate]

-- | the matched function prototype for a funcall
fnProt :: Annotation -> Maybe FunctionPrototype

-- | <tt>inferred</tt> type - fake type inference used for getting the type
--   of ? placeholders in parameterized statements
infType :: Annotation -> Maybe Type

-- | Represents a source file position, usually set by the parser.
type SourcePosition = (String, Int, Int)

-- | Statement type is used for getting type information for a
--   parameterized statement.
type ParameterizedStatementType = ([Type], [(String, Type)])

-- | get the annotation for the root element of the tree passed
getAnnotation :: Data a => a -> Annotation

-- | Update the first annotation in a tree using the function supplied
updateAnnotation :: Data a => (Annotation -> Annotation) -> a -> a

-- | An annotation value with no information.
emptyAnnotation :: Annotation


-- | Contains the data types and functions for annotating an ast and
--   working with annotated trees, including the representations of SQL
--   data types.
--   
--   Annotations:
--   
--   <ul>
--   <li>are attached to most of the ast node data types, but not quite all
--   of them;</li>
--   <li>types annotations are attached to most nodes during type
--   checking;</li>
--   <li>type errors are attached to the lowest down node that the type
--   error is detected at;</li>
--   <li>nodes who fail the type check or whose type depends on a node with
--   a type error are given the type <tt>TypeCheckFailed</tt>;</li>
--   <li>each statement has an additional <tt>StatementInfo</tt> annotation
--   attached to it;</li>
--   <li>the parser fills in the source position annotation in every
--   annotatable ast node.</li>
--   </ul>
module Database.HsSqlPpp.TypeChecker

-- | Takes an ast, checks against catalog passed, and adds annotations,
--   including types, type errors, and statement info. Returns the updated
--   catalog as well as the annotated ast.
typeCheckStatements :: Catalog -> [Statement] -> (Catalog, [Statement])

-- | Unfinished version of type check which can type check an individual
--   statement with ? or positional arg placeholders in it. Will error if
--   the statement isn't select, update, insert or delete. For use in type
--   checking embedded parameterized statements. Does all typechecking and
--   annotation that the regular typecheck does.
typeCheckParameterizedStatement :: Catalog -> Statement -> Either String Statement
typeCheckQueryExpr :: Catalog -> QueryExpr -> QueryExpr

-- | Testing utility, mainly used to check an expression for type errors or
--   to get its type.
typeCheckScalarExpr :: Catalog -> ScalarExpr -> ScalarExpr

-- | transform the tree by converting * to explicit lists of columns and
--   adding qualifiers to all column references
fixUpIdentifiers :: Catalog -> [Statement] -> [Statement]
fixUpIdentifiersQE :: Catalog -> QueryExpr -> QueryExpr
fixUpIdentifiersSE :: Catalog -> ScalarExpr -> ScalarExpr

-- | Run through a typechecked tree and add in explicit casts where
--   implicit casts are used to typecheck. Does function and operator
--   calls, case result expressions, and string, integer and float literals
--   at the moment, todo: union, array, greatest, least
addExplicitCasts :: Data a => a -> a

-- | Convert all the typenames in the ast to canonical form e.g. int -&gt;
--   int4
canonicalizeTypeNames :: Data a => a -> a

-- | Run through the ast and return all the annotations attached to a
--   Statement node.
getStatementAnnotations :: Data a => a -> [Annotation]


-- | This module contains the ast node data types. They are very
--   permissive, in that they allow a lot of invalid SQL to be represented.
--   The type checking process should catch all invalid trees, but doesn't
--   quite manage at the moment. Sorry about all the seemingly pointless
--   type synonyms below, they are an artefact of using UUAGC. You can see
--   labels for the fields by looking at the ag source here:
--   <a>http://jakewheat.github.com/hssqlppp/source/src/Database/HsSqlPpp/Internals/AstInternal.ag.html</a>
module Database.HsSqlPpp.Ast
type StatementList = [Statement]
data Statement
AlterSequence :: (Annotation) -> (Name) -> (Name) -> Statement
AlterTable :: (Annotation) -> (Name) -> (AlterTableActionList) -> Statement
AntiStatement :: (String) -> Statement
Assignment :: (Annotation) -> (Name) -> (ScalarExpr) -> Statement
Block :: (Annotation) -> ((Maybe String)) -> (VarDefList) -> (StatementList) -> Statement
CaseStatement :: (Annotation) -> (ScalarExprListStatementListPairList) -> (StatementList) -> Statement
CaseStatementSimple :: (Annotation) -> (ScalarExpr) -> (ScalarExprListStatementListPairList) -> (StatementList) -> Statement
ContinueStatement :: (Annotation) -> ((Maybe String)) -> Statement
Copy :: (Annotation) -> (Name) -> (([NameComponent])) -> (CopySource) -> Statement
CopyData :: (Annotation) -> (String) -> Statement
CreateDomain :: (Annotation) -> (Name) -> (TypeName) -> (String) -> (MaybeBoolExpr) -> Statement
CreateFunction :: (Annotation) -> (Name) -> (ParamDefList) -> (TypeName) -> (Replace) -> (Language) -> (FnBody) -> (Volatility) -> Statement
CreateLanguage :: (Annotation) -> (String) -> Statement
CreateSequence :: (Annotation) -> (Name) -> (Integer) -> (Integer) -> (Integer) -> (Integer) -> (Integer) -> Statement
CreateTable :: (Annotation) -> (Name) -> (AttributeDefList) -> (ConstraintList) -> Statement
CreateTableAs :: (Annotation) -> (Name) -> (QueryExpr) -> Statement
CreateTrigger :: (Annotation) -> (NameComponent) -> (TriggerWhen) -> (([TriggerEvent])) -> (Name) -> (TriggerFire) -> (Name) -> (ScalarExprList) -> Statement
CreateType :: (Annotation) -> (Name) -> (TypeAttributeDefList) -> Statement
CreateView :: (Annotation) -> (Name) -> (MaybeNameComponentList) -> (QueryExpr) -> Statement
Delete :: (Annotation) -> (Name) -> (TableRefList) -> (MaybeBoolExpr) -> (MaybeSelectList) -> Statement
DropFunction :: (Annotation) -> (IfExists) -> (NameTypeNameListPairList) -> (Cascade) -> Statement
DropSomething :: (Annotation) -> (DropType) -> (IfExists) -> (([Name])) -> (Cascade) -> Statement
Execute :: (Annotation) -> (ScalarExpr) -> Statement
ExitStatement :: (Annotation) -> ((Maybe String)) -> Statement
ForIntegerStatement :: (Annotation) -> ((Maybe String)) -> (NameComponent) -> (ScalarExpr) -> (ScalarExpr) -> (StatementList) -> Statement
ForQueryStatement :: (Annotation) -> ((Maybe String)) -> (NameComponent) -> (QueryExpr) -> (StatementList) -> Statement
If :: (Annotation) -> (ScalarExprStatementListPairList) -> (StatementList) -> Statement
Insert :: (Annotation) -> (Name) -> (([NameComponent])) -> (QueryExpr) -> (MaybeSelectList) -> Statement
Into :: (Annotation) -> (Bool) -> (([Name])) -> (Statement) -> Statement
LoopStatement :: (Annotation) -> ((Maybe String)) -> (StatementList) -> Statement
Notify :: (Annotation) -> (String) -> Statement
NullStatement :: (Annotation) -> Statement
Perform :: (Annotation) -> (ScalarExpr) -> Statement
QueryStatement :: (Annotation) -> (QueryExpr) -> Statement
Raise :: (Annotation) -> (RaiseType) -> (String) -> (ScalarExprList) -> Statement
Return :: (Annotation) -> (MaybeScalarExpr) -> Statement
ReturnNext :: (Annotation) -> (ScalarExpr) -> Statement
ReturnQuery :: (Annotation) -> (QueryExpr) -> Statement
Set :: (Annotation) -> (String) -> (([SetValue])) -> Statement
Truncate :: (Annotation) -> (([Name])) -> (RestartIdentity) -> (Cascade) -> Statement
Update :: (Annotation) -> (Name) -> (SetClauseList) -> (TableRefList) -> (MaybeBoolExpr) -> (MaybeSelectList) -> Statement
WhileStatement :: (Annotation) -> ((Maybe String)) -> (ScalarExpr) -> (StatementList) -> Statement
data ScalarExpr
AggregateFn :: (Annotation) -> (Distinct) -> (ScalarExpr) -> (ScalarExprDirectionPairList) -> ScalarExpr
AntiScalarExpr :: (String) -> ScalarExpr
BooleanLit :: (Annotation) -> (Bool) -> ScalarExpr
Case :: (Annotation) -> (CaseScalarExprListScalarExprPairList) -> (MaybeScalarExpr) -> ScalarExpr
CaseSimple :: (Annotation) -> (ScalarExpr) -> (CaseScalarExprListScalarExprPairList) -> (MaybeScalarExpr) -> ScalarExpr
Cast :: (Annotation) -> (ScalarExpr) -> (TypeName) -> ScalarExpr
Exists :: (Annotation) -> (QueryExpr) -> ScalarExpr
Extract :: (Annotation) -> (ExtractField) -> (ScalarExpr) -> ScalarExpr
FunCall :: (Annotation) -> (Name) -> (ScalarExprList) -> ScalarExpr
Identifier :: (Annotation) -> (NameComponent) -> ScalarExpr
InPredicate :: (Annotation) -> (ScalarExpr) -> (Bool) -> (InList) -> ScalarExpr
Interval :: (Annotation) -> (String) -> (IntervalField) -> ((Maybe Int)) -> ScalarExpr
LiftOperator :: (Annotation) -> (String) -> (LiftFlavour) -> (ScalarExprList) -> ScalarExpr
NullLit :: (Annotation) -> ScalarExpr
NumberLit :: (Annotation) -> (String) -> ScalarExpr
Placeholder :: (Annotation) -> ScalarExpr
PositionalArg :: (Annotation) -> (Integer) -> ScalarExpr
QIdentifier :: (Annotation) -> (([NameComponent])) -> ScalarExpr
QStar :: (Annotation) -> (NameComponent) -> ScalarExpr
ScalarSubQuery :: (Annotation) -> (QueryExpr) -> ScalarExpr
Star :: (Annotation) -> ScalarExpr
StringLit :: (Annotation) -> (String) -> ScalarExpr
TypedStringLit :: (Annotation) -> (TypeName) -> (String) -> ScalarExpr
WindowFn :: (Annotation) -> (ScalarExpr) -> (ScalarExprList) -> (ScalarExprDirectionPairList) -> (FrameClause) -> ScalarExpr
data QueryExpr
CombineQueryExpr :: (Annotation) -> (CombineType) -> (QueryExpr) -> (QueryExpr) -> QueryExpr
Select :: (Annotation) -> (Distinct) -> (SelectList) -> (TableRefList) -> (MaybeBoolExpr) -> (ScalarExprList) -> (MaybeBoolExpr) -> (ScalarExprDirectionPairList) -> (MaybeScalarExpr) -> (MaybeScalarExpr) -> QueryExpr
Values :: (Annotation) -> (ScalarExprListList) -> QueryExpr
WithQueryExpr :: (Annotation) -> (WithQueryList) -> (QueryExpr) -> QueryExpr
data SelectList
SelectList :: (Annotation) -> (SelectItemList) -> SelectList
data SelectItem
SelExp :: (Annotation) -> (ScalarExpr) -> SelectItem
SelectItem :: (Annotation) -> (ScalarExpr) -> (NameComponent) -> SelectItem
data TableRef
FunTref :: (Annotation) -> (ScalarExpr) -> (TableAlias) -> TableRef
JoinTref :: (Annotation) -> (TableRef) -> (Natural) -> (JoinType) -> (TableRef) -> (OnExpr) -> (TableAlias) -> TableRef
SubTref :: (Annotation) -> (QueryExpr) -> (TableAlias) -> TableRef
Tref :: (Annotation) -> (Name) -> (TableAlias) -> TableRef
data TableAlias
FullAlias :: (Annotation) -> (NameComponent) -> (([NameComponent])) -> TableAlias
NoAlias :: (Annotation) -> TableAlias
TableAlias :: (Annotation) -> (NameComponent) -> TableAlias
data JoinExpr
JoinOn :: (Annotation) -> (ScalarExpr) -> JoinExpr
JoinUsing :: (Annotation) -> (([NameComponent])) -> JoinExpr
data JoinType
Inner :: JoinType
LeftOuter :: JoinType
RightOuter :: JoinType
FullOuter :: JoinType
Cross :: JoinType
data Natural
Natural :: Natural
Unnatural :: Natural
data CombineType
Except :: CombineType
Union :: CombineType
Intersect :: CombineType
UnionAll :: CombineType
data Direction
Asc :: Direction
Desc :: Direction
data Distinct
Distinct :: Distinct
Dupes :: Distinct
data InList
InList :: (Annotation) -> (ScalarExprList) -> InList
InQueryExpr :: (Annotation) -> (QueryExpr) -> InList
data LiftFlavour
LiftAny :: LiftFlavour
LiftAll :: LiftFlavour
data FrameClause
FrameUnboundedPreceding :: FrameClause
FrameUnboundedFull :: FrameClause
FrameRowsUnboundedPreceding :: FrameClause
type WithQueryList = [WithQuery]
data WithQuery
WithQuery :: (Annotation) -> (NameComponent) -> ((Maybe [NameComponent])) -> (QueryExpr) -> WithQuery
data IntervalField
IntervalYear :: IntervalField
IntervalMonth :: IntervalField
IntervalDay :: IntervalField
IntervalHour :: IntervalField
IntervalMinute :: IntervalField
IntervalSecond :: IntervalField
IntervalYearToMonth :: IntervalField
IntervalDayToHour :: IntervalField
IntervalDayToMinute :: IntervalField
IntervalDayToSecond :: IntervalField
IntervalHourToMinute :: IntervalField
IntervalHourToSecond :: IntervalField
IntervalMinuteToSecond :: IntervalField
data ExtractField
ExtractCentury :: ExtractField
ExtractDay :: ExtractField
ExtractDecade :: ExtractField
ExtractDow :: ExtractField
ExtractDoy :: ExtractField
ExtractEpoch :: ExtractField
ExtractHour :: ExtractField
ExtractIsodow :: ExtractField
ExtractIsoyear :: ExtractField
ExtractMicroseconds :: ExtractField
ExtractMillennium :: ExtractField
ExtractMilliseconds :: ExtractField
ExtractMinute :: ExtractField
ExtractMonth :: ExtractField
ExtractQuarter :: ExtractField
ExtractSecond :: ExtractField
ExtractTimezone :: ExtractField
ExtractTimezoneHour :: ExtractField
ExtractTimezoneMinute :: ExtractField
ExtractWeek :: ExtractField
ExtractYear :: ExtractField
data Name
Name :: (Annotation) -> (([NameComponent])) -> Name
data NameComponent
Nmc :: String -> NameComponent
QNmc :: String -> NameComponent
ncStr :: NameComponent -> String
data CopySource
CopyFilename :: String -> CopySource
Stdin :: CopySource
data RestartIdentity
RestartIdentity :: RestartIdentity
ContinueIdentity :: RestartIdentity
data SetClause
MultiSetClause :: (Annotation) -> (([NameComponent])) -> (ScalarExpr) -> SetClause
SetClause :: (Annotation) -> (NameComponent) -> (ScalarExpr) -> SetClause
data AttributeDef
AttributeDef :: (Annotation) -> (NameComponent) -> (TypeName) -> (MaybeScalarExpr) -> (RowConstraintList) -> AttributeDef
data RowConstraint
NotNullConstraint :: (Annotation) -> (String) -> RowConstraint
NullConstraint :: (Annotation) -> (String) -> RowConstraint
RowCheckConstraint :: (Annotation) -> (String) -> (ScalarExpr) -> RowConstraint
RowPrimaryKeyConstraint :: (Annotation) -> (String) -> RowConstraint
RowReferenceConstraint :: (Annotation) -> (String) -> (Name) -> ((Maybe NameComponent)) -> (Cascade) -> (Cascade) -> RowConstraint
RowUniqueConstraint :: (Annotation) -> (String) -> RowConstraint
data Constraint
CheckConstraint :: (Annotation) -> (String) -> (ScalarExpr) -> Constraint
PrimaryKeyConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> Constraint
ReferenceConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> (Name) -> (([NameComponent])) -> (Cascade) -> (Cascade) -> Constraint
UniqueConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> Constraint
data AlterTableAction
AddConstraint :: (Annotation) -> (Constraint) -> AlterTableAction
AlterColumnDefault :: (Annotation) -> (NameComponent) -> (ScalarExpr) -> AlterTableAction
data TypeAttributeDef
TypeAttDef :: (Annotation) -> (NameComponent) -> (TypeName) -> TypeAttributeDef
data TypeName
ArrayTypeName :: (Annotation) -> (TypeName) -> TypeName
Prec2TypeName :: (Annotation) -> (String) -> (Integer) -> (Integer) -> TypeName
PrecTypeName :: (Annotation) -> (String) -> (Integer) -> TypeName
SetOfTypeName :: (Annotation) -> (TypeName) -> TypeName
SimpleTypeName :: (Annotation) -> (String) -> TypeName
data DropType
Table :: DropType
Domain :: DropType
View :: DropType
Type :: DropType
data IfExists
Require :: IfExists
IfExists :: IfExists
data Replace
Replace :: Replace
NoReplace :: Replace
data Cascade
Cascade :: Cascade
Restrict :: Cascade
data TriggerWhen
TriggerBefore :: TriggerWhen
TriggerAfter :: TriggerWhen
data TriggerEvent
TInsert :: TriggerEvent
TUpdate :: TriggerEvent
TDelete :: TriggerEvent
AntiTriggerEvent :: String -> TriggerEvent
data TriggerFire
EachRow :: TriggerFire
EachStatement :: TriggerFire
data FnBody
PlpgsqlFnBody :: (Annotation) -> (Statement) -> FnBody
SqlFnBody :: (Annotation) -> (StatementList) -> FnBody
data ParamDef
ParamDef :: (Annotation) -> (NameComponent) -> (TypeName) -> ParamDef
ParamDefTp :: (Annotation) -> (TypeName) -> ParamDef
data VarDef
ParamAlias :: (Annotation) -> (NameComponent) -> (Integer) -> VarDef
VarAlias :: (Annotation) -> (NameComponent) -> (Name) -> VarDef
VarDef :: (Annotation) -> (NameComponent) -> (TypeName) -> ((Maybe ScalarExpr)) -> VarDef
data RaiseType
RNotice :: RaiseType
RException :: RaiseType
RError :: RaiseType
data Volatility
Volatile :: Volatility
Stable :: Volatility
Immutable :: Volatility
data Language
Sql :: Language
Plpgsql :: Language
data SetValue
SetStr :: Annotation -> String -> SetValue
SetId :: Annotation -> String -> SetValue
SetNum :: Annotation -> Double -> SetValue
type ScalarExprListStatementListPairList = [ScalarExprListStatementListPair]
type ScalarExprListStatementListPair = (ScalarExprList, StatementList)
type ScalarExprList = [ScalarExpr]
type MaybeSelectList = Maybe SelectList
type ParamDefList = [ParamDef]
type AttributeDefList = [AttributeDef]
type ConstraintList = [Constraint]
type TypeAttributeDefList = [TypeAttributeDef]
type TypeNameList = [TypeName]
type NameTypeNameListPair = (Name, TypeNameList)
type NameTypeNameListPairList = [NameTypeNameListPair]
type ScalarExprStatementListPairList = [ScalarExprStatementListPair]
type CaseScalarExprListScalarExprPairList = [CaseScalarExprListScalarExprPair]
type MaybeScalarExpr = Maybe ScalarExpr
type MaybeBoolExpr = Maybe ScalarExpr
type TableRefList = [TableRef]
type ScalarExprListList = [ScalarExprList]
type SelectItemList = [SelectItem]
type OnExpr = Maybe JoinExpr
type RowConstraintList = [RowConstraint]
type VarDefList = [VarDef]
type ScalarExprStatementListPair = (ScalarExpr, StatementList)
type CaseScalarExprListScalarExprPair = (ScalarExprList, ScalarExpr)
type ScalarExprDirectionPair = (ScalarExpr, Direction)
type ScalarExprDirectionPairList = [ScalarExprDirectionPair]
type AlterTableActionList = [AlterTableAction]
type SetClauseList = [SetClause]


-- | Functions to parse SQL.
module Database.HsSqlPpp.Parser
parseStatements :: String -> String -> Either ParseErrorExtra [Statement]
parseStatementsWithPosition :: FilePath -> Int -> Int -> String -> Either ParseErrorExtra [Statement]
parseStatementsFromFile :: FilePath -> IO (Either ParseErrorExtra [Statement])
parseQueryExpr :: String -> String -> Either ParseErrorExtra QueryExpr

-- | Parse expression fragment, used for testing purposes
parseScalarExpr :: String -> String -> Either ParseErrorExtra ScalarExpr

-- | Parse plpgsql statements, used for testing purposes - this can be used
--   to parse a list of plpgsql statements which aren't contained in a
--   create function. (The produced ast won't pass a type check.)
parsePlpgsql :: String -> String -> Either ParseErrorExtra [Statement]

-- | Simple wrapper to allow showing the source context of a ParseError
data ParseErrorExtra
ParseErrorExtra :: ParseError -> Maybe (Int, Int) -> String -> ParseErrorExtra

-- | wrapped error
parseErrorError :: ParseErrorExtra -> ParseError

-- | source position adjustment to get the context bit in error messages
--   right - this is the same as what is passed into parseSqlWithPosition
parseErrorPosition :: ParseErrorExtra -> Maybe (Int, Int)

-- | sql source
parseErrorSqlSource :: ParseErrorExtra -> String


-- | Functions to convert sql asts to valid SQL source code. Includes a
--   function - <tt>printSqlAnn</tt> - to output the annotations from a
--   tree in comments in the outputted SQL source.
--   
--   Produces sort of readable code, but mainly just written to produce
--   reparsable text. Could do with some work to make the outputted text
--   layout better.
module Database.HsSqlPpp.Pretty

-- | convert an ast back to valid SQL source, it's also almost human
--   readable.
printStatements :: StatementList -> String

-- | convert the ast back to valid source, and convert any annotations to
--   text using the function provided and interpolate the output of this
--   function(inside comments) with the SQL source.
printStatementsAnn :: (Annotation -> String) -> StatementList -> String
printQueryExpr :: QueryExpr -> String

-- | Testing function, pretty print an expression
printScalarExpr :: ScalarExpr -> String

-- | Try harder to make the output human readable, not necessary correct
--   sql output at the moment
printQueryExprNice :: QueryExpr -> String


-- | A quasiquoter for SQL. Antiquoting is a bit inconsistent. The splice
--   variable names must be all lower case because of a limitation in the
--   parser.
--   
--   Example:
--   
--   <pre>
--   
--   import Database.HsSqlPpp.Ast
--   import Database.HsSqlPpp.Quote
--   import Database.HsSqlPpp.Annotation
--   
--   test :: Statement
--   test = [$sqlStmt|
--   
--     create table $(tablename) (
--      $(varname) $(typename)
--     );
--   
--           |]
--     where
--       tablename = "my_table"
--       varname = "my_field"
--       typename = "text"
--   </pre>
--   
--   See <a>http://jakewheat.github.com/hssqlppp/QuasiQuoteTests.html</a>
--   for more simple examples
module Database.HsSqlPpp.Quote

-- | quotes Statements
sqlStmts :: QuasiQuoter

-- | quotes a single Statement
sqlStmt :: QuasiQuoter

-- | quotes plpgsql Statements
pgsqlStmts :: QuasiQuoter

-- | quotes a plpgsql Statement
pgsqlStmt :: QuasiQuoter

-- | quotes a ScalarExpr
sqlExpr :: QuasiQuoter
