-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The frictionless WAI Framework
--   
--   Wheb's a framework for building robust, high-concurrency web
--   applications simply and effectively.
--   
--   <ul>
--   <li>The core datatype will let you build anything from a read-only
--   server to a fully interactive web application with basic Haskell.</li>
--   <li>Minimal boilerplate to start your application.</li>
--   <li>Session, Auth and Cache interfaces are built in. Just drop in a
--   backend.</li>
--   <li>Typesafe web-routes or named routes and URL generation.</li>
--   <li>Easy to use for REST APIs</li>
--   <li>CSRF Protection</li>
--   <li>WebSockets</li>
--   <li>Fully database and template agnostic</li>
--   <li>Easy handler debugging.</li>
--   <li>Middleware</li>
--   <li>Fast. It deploys on warp.</li>
--   </ul>
--   
--   <i>Plugins:</i>
--   
--   Wheb makes it easy to write plugins. Plugins can add routes,
--   middlware, settings and even handle resource cleanup on server
--   shutdown. Named routes allow plugins to dynamically generate their
--   routes at runtime based on settings.
--   
--   Examples of plugins:
--   
--   <ul>
--   <li>Sessions</li>
--   <li>Auth</li>
--   <li>Cache</li>
--   <li><a>Wheb-Mongo</a></li>
--   <li><a>Wheb-Redis</a></li>
--   <li><a>Wheb-Strapped</a></li>
--   </ul>
--   
--   <i>Wheb in action:</i>
--   
--   Use with language extensions <i>OverloadedStrings</i>
--   
--   <pre>
--   import           Web.Wheb
--   
--   main :: IO ()
--   main = do
--     opts &lt;- genMinOpts $ do
--        addGET "home" rootPat $ text "Hi!"
--        addGET "about" ("about" &lt;/&gt; "something") $ html "&lt;html&gt;&lt;body&gt;&lt;h1&gt;About!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"
--     runWhebServer opts
--   </pre>
--   
--   <i>Bigger example (Stateful.hs):</i>
--   
--   Wheb makes it easy to share a global context and handle requests
--   statefully. The Wheb monad is both a Reader and a State Monad allowing
--   you to seperate thread-safe resources.
--   
--   Below is an example of site that naively counts the non-unique hits
--   across all pages. MyApp is our Reader's type and MyHandlerData is our
--   State's type. MyApp is shared across requests while MyHandlerData is
--   thread specific with a starting state given in options. We have a
--   middleware that intercepts the request, safely increments the shared
--   resource TVar and sets our MyHandlerData to the correct count before
--   it reaches our handler. We use a TVar in the Global context because
--   any state changes to the handler state will not affect other requests.
--   
--   <pre>
--   import           Control.Concurrent.STM
--   import           Control.Monad.IO.Class
--   import           Data.Monoid
--   import           Data.Text.Lazy (Text)
--   import           Web.Wheb
--   
--   data MyApp = MyApp Text (TVar Int)
--   data MyHandlerData = MyHandlerData Int
--   
--   counterMw :: MonadIO m =&gt; WhebMiddleware MyApp MyHandlerData m
--   counterMw = do
--     (MyApp _ ctr) &lt;- getApp
--     number &lt;- liftIO $ atomically $ do
--             num &lt;- readTVar ctr
--             writeTVar ctr (succ num)
--             return num
--     putHandlerState (MyHandlerData number)
--     return Nothing
--   
--   homePage :: WhebHandler MyApp MyHandlerData
--   homePage = do
--     (MyApp appName _)   &lt;- getApp
--     (MyHandlerData num) &lt;- getHandlerState
--     html $ ("&lt;h1&gt;Welcome to" &lt;&gt; appName &lt;&gt;
--             "&lt;/h1&gt;&lt;h2&gt;You are visitor #" &lt;&gt; (spack num) &lt;&gt; "&lt;/h2&gt;")
--   
--   main :: IO ()
--   main = do
--     opts &lt;- generateOptions $ do
--               startingCounter &lt;- liftIO $ newTVarIO 0
--               addWhebMiddleware counterMw
--               addGET "." rootPat $ homePage
--               return $ (MyApp "AwesomeApp" startingCounter, MyHandlerData 0)
--     runWhebServer opts
--   </pre>
@package Wheb
@version 0.3.1.0

module Web.Wheb.Types

-- | WhebT g s m
--   
--   <ul>
--   <li>g -&gt; The global confirgured context (Read-only data shared
--   between threads)</li>
--   <li>s -&gt; Handler state for each request.</li>
--   <li>m -&gt; Monad we are transforming</li>
--   </ul>
newtype WhebT g s m a
WhebT :: ExceptT WhebError (ReaderT (HandlerData g s m) (StateT (InternalState s) m)) a -> WhebT g s m a
runWhebT :: WhebT g s m a -> ExceptT WhebError (ReaderT (HandlerData g s m) (StateT (InternalState s) m)) a

-- | Writer Monad to build options.
newtype InitM g s m a
InitM :: WriterT (InitOptions g s m) IO a -> InitM g s m a
runInitM :: InitM g s m a -> WriterT (InitOptions g s m) IO a

-- | Converts a type to a WAI <a>Response</a>
class WhebContent a
toResponse :: WhebContent a => Status -> ResponseHeaders -> a -> Response

-- | A Wheb response that represents a file.
data WhebFile
WhebFile :: Text -> WhebFile
data HandlerResponse
HandlerResponse :: Status -> a -> HandlerResponse

-- | Our <a>ReaderT</a> portion of <a>WhebT</a> uses this.
data HandlerData g s m
HandlerData :: g -> Request -> ([Param], [File ByteString]) -> RouteParamList -> WhebOptions g s m -> HandlerData g s m
globalCtx :: HandlerData g s m -> g
request :: HandlerData g s m -> Request
postData :: HandlerData g s m -> ([Param], [File ByteString])
routeParams :: HandlerData g s m -> RouteParamList
globalSettings :: HandlerData g s m -> WhebOptions g s m

-- | Our <a>StateT</a> portion of <a>WhebT</a> uses this.
data InternalState s
InternalState :: s -> Map HeaderName ByteString -> CookiesText -> InternalState s
reqState :: InternalState s -> s
respHeaders :: InternalState s -> Map HeaderName ByteString
curCookies :: InternalState s -> CookiesText
data SettingsValue
MkVal :: a -> SettingsValue
data WhebError
Error500 :: Text -> WhebError
Error404 :: WhebError
Error403 :: WhebError
ErrorStatus :: Status -> Text -> WhebError
RouteParamDoesNotExist :: WhebError
URLError :: Text -> UrlBuildError -> WhebError

-- | Monoid to use in InitM's WriterT
data InitOptions g s m
InitOptions :: [Route g s m] -> [SocketRoute g s m] -> [PackedSite g s m] -> CSettings -> Middleware -> [WhebMiddleware g s m] -> [IO ()] -> InitOptions g s m
initRoutes :: InitOptions g s m -> [Route g s m]
initWhebSockets :: InitOptions g s m -> [SocketRoute g s m]
initSites :: InitOptions g s m -> [PackedSite g s m]
initSettings :: InitOptions g s m -> CSettings
initWaiMw :: InitOptions g s m -> Middleware
initWhebMw :: InitOptions g s m -> [WhebMiddleware g s m]
initCleanup :: InitOptions g s m -> [IO ()]

-- | The main option datatype for Wheb
data WhebOptions g s m
WhebOptions :: [Route g s m] -> [SocketRoute g s m] -> [PackedSite g s m] -> CSettings -> Settings -> g -> InternalState s -> Middleware -> [WhebMiddleware g s m] -> (WhebError -> WhebHandlerT g s m) -> TVar Bool -> TVar Int -> [IO ()] -> WhebOptions g s m
appRoutes :: WhebOptions g s m -> [Route g s m]
appWhebSockets :: WhebOptions g s m -> [SocketRoute g s m]
appSites :: WhebOptions g s m -> [PackedSite g s m]
runTimeSettings :: WhebOptions g s m -> CSettings
warpSettings :: WhebOptions g s m -> Settings

-- | Global ctx shared between requests
startingCtx :: WhebOptions g s m -> g

-- | Handler state given each request
startingState :: WhebOptions g s m -> InternalState s
waiStack :: WhebOptions g s m -> Middleware
whebMiddlewares :: WhebOptions g s m -> [WhebMiddleware g s m]
defaultErrorHandler :: WhebOptions g s m -> WhebError -> WhebHandlerT g s m
shutdownTVar :: WhebOptions g s m -> TVar Bool
activeConnections :: WhebOptions g s m -> TVar Int
cleanupActions :: WhebOptions g s m -> [IO ()]
type EResponse = Either WhebError Response
type CSettings = Map Text SettingsValue
type WhebHandler g s = WhebT g s IO HandlerResponse
type WhebHandlerT g s m = WhebT g s m HandlerResponse
type WhebMiddleware g s m = WhebT g s m (Maybe HandlerResponse)
type WhebSocket g s m = Connection -> WhebT g s m ()

-- | A minimal type for WhebT
type MinWheb a = WhebT () () IO a
type MinHandler = MinWheb HandlerResponse

-- | A minimal type for WhebOptions
type MinOpts = WhebOptions () () IO
data PackedSite g s m
PackedSite :: Text -> (Site a (WhebHandlerT g s m)) -> PackedSite g s m
type RouteParamList = [(Text, ParsedChunk)]
type MethodMatch = StdMethod -> Bool
data ParsedChunk
MkChunk :: a -> ParsedChunk
data UrlBuildError
NoParam :: UrlBuildError
ParamTypeMismatch :: Text -> UrlBuildError
UrlNameNotFound :: UrlBuildError

-- | A Parser should be able to extract params and regenerate URL from
--   params.
data UrlParser
UrlParser :: ([Text] -> Maybe RouteParamList) -> (RouteParamList -> Either UrlBuildError Text) -> UrlParser
parseFunc :: UrlParser -> ([Text] -> Maybe RouteParamList)
genFunc :: UrlParser -> (RouteParamList -> Either UrlBuildError Text)
data Route g s m
Route :: (Maybe Text) -> MethodMatch -> UrlParser -> (WhebHandlerT g s m) -> Route g s m
routeName :: Route g s m -> (Maybe Text)
routeMethod :: Route g s m -> MethodMatch
routeParser :: Route g s m -> UrlParser
routeHandler :: Route g s m -> (WhebHandlerT g s m)
data SocketRoute g s m
SocketRoute :: UrlParser -> WhebSocket g s m -> SocketRoute g s m
srouteParser :: SocketRoute g s m -> UrlParser
srouteHandler :: SocketRoute g s m -> WhebSocket g s m
data ChunkType
IntChunk :: ChunkType
TextChunk :: ChunkType
data UrlPat
Chunk :: Text -> UrlPat
Composed :: [UrlPat] -> UrlPat
FuncChunk :: Text -> (Text -> Maybe ParsedChunk) -> ChunkType -> UrlPat
chunkParamName :: UrlPat -> Text
chunkFunc :: UrlPat -> (Text -> Maybe ParsedChunk)
chunkType :: UrlPat -> ChunkType
instance Show UrlBuildError
instance Show WhebError
instance Functor m => Functor (WhebT g s m)
instance (Monad m, Functor m) => Applicative (WhebT g s m)
instance Monad m => Monad (WhebT g s m)
instance MonadIO m => MonadIO (WhebT g s m)
instance Functor (InitM g s m)
instance Applicative (InitM g s m)
instance Monad (InitM g s m)
instance MonadIO (InitM g s m)
instance Show ChunkType
instance IsString UrlPat
instance Show UrlPat
instance Show ParsedChunk
instance Monoid (InitOptions g s m)
instance Monad m => MonadError WhebError (WhebT g s m)
instance MonadTrans (WhebT g s)

module Web.Wheb.Utils
lazyTextToSBS :: Text -> ByteString
sbsToLazyText :: ByteString -> Text
builderToText :: Builder -> Text
builderToStrictText :: Builder -> Text

-- | Show and pack into Lazy <tt>Text</tt>
spack :: Show a => a -> Text

-- | Show and pack into Strict <tt>Text</tt>
spacks :: Show a => a -> Text

-- | See a <a>HandlerResponse</a>s as <tt>Text</tt>
showResponseBody :: HandlerResponse -> IO Text
makeUUID :: MonadIO m => WhebT g s m Text
defaultErr :: Monad m => WhebError -> WhebHandlerT g s m
uhOh :: Response
instance WhebContent WhebFile
instance WhebContent Text
instance WhebContent Builder

module Web.Wheb.Routes

-- | Allows for easier building of URL patterns This should be the primary
--   URL constructor.
--   
--   <pre>
--   (\"blog\" '&lt;/&gt;' ('grabInt' \"pk\") '&lt;/&gt;' \"edit\" '&lt;/&gt;' ('grabText' \"verb\"))
--   </pre>
(</>) :: UrlPat -> UrlPat -> UrlPat

-- | Parses URL parameter and matches on <a>Int</a>
grabInt :: Text -> UrlPat

-- | Parses URL parameter and matches on <tt>Text</tt>
grabText :: Text -> UrlPat

-- | Constructors to use w/o OverloadedStrings
pT :: Text -> UrlPat
pS :: String -> UrlPat

-- | Build a <a>Route</a> from a <a>UrlPat</a>
patRoute :: (Maybe Text) -> StdMethod -> UrlPat -> WhebHandlerT g s m -> Route g s m

-- | Convert a <a>UrlPat</a> to a <a>UrlParser</a>
compilePat :: UrlPat -> UrlParser

-- | Represents root path <tt>/</tt>
rootPat :: UrlPat

-- | Lookup and cast a URL parameter to its expected type if it exists.
getParam :: Typeable a => Text -> RouteParamList -> Maybe a

-- | Convert URL chunks (split on /)
matchUrl :: [Text] -> UrlParser -> Maybe RouteParamList

-- | Runs a <a>UrlParser</a> with <a>RouteParamList</a> to a URL path
generateUrl :: UrlParser -> RouteParamList -> Either UrlBuildError Text

-- | Sort through a list of routes to find a Handler and
--   <a>RouteParamList</a>
findUrlMatch :: StdMethod -> [Text] -> [Route g s m] -> Maybe (WhebHandlerT g s m, RouteParamList)

-- | Sort through socket routes to find a match
findSocketMatch :: [Text] -> [SocketRoute g s m] -> Maybe (WhebSocket g s m, RouteParamList)
findSiteMatch :: [PackedSite g s m] -> [Text] -> Maybe (WhebHandlerT g s m)

-- | Test a parser to make sure it can match what it produces and vice
--   versa
testUrlParser :: UrlParser -> RouteParamList -> Bool

module Web.Wheb.InitM
addGET :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addPOST :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addPUT :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addDELETE :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addSite :: Text -> Site url (WhebHandlerT g s m) -> InitM g s m ()
addRoute :: Route g s m -> InitM g s m ()
addRoutes :: [Route g s m] -> InitM g s m ()

-- | Catch all requests regardless of method or path
catchAll :: WhebHandlerT g s m -> InitM g s m ()
addWhebSocket :: UrlPat -> WhebSocket g s m -> InitM g s m ()

-- | Add generic <a>WAI</a> middleware
addWAIMiddleware :: Middleware -> InitM g s m ()

-- | Add <a>Wheb</a> specific middleware
addWhebMiddleware :: WhebMiddleware g s m -> InitM g s m ()

-- | Wrapped <a>addSetting'</a> to help prevent monomorphism errors for
--   simple settings.
addSetting :: Text -> Text -> InitM g s m ()

-- | Adds a setting value, replacing it if its key already exists.
addSetting' :: Typeable a => Text -> a -> InitM g s m ()
addSettings :: CSettings -> InitM g s m ()

-- | Reads a file line by line and splits keys and values by ":". Uses
--   default <a>Text.Read</a> to try to match <a>Int</a>, <a>Bool</a> or
--   <a>Float</a> and will add specific typed settings for those.
readSettingsFile :: FilePath -> InitM g s m ()

-- | IO Actions to run after server has been stopped.
addCleanupHook :: IO () -> InitM g s m ()

-- | Generate <a>WhebOptions</a> from <a>InitM</a> in <a>IO</a>
generateOptions :: MonadIO m => InitM g s m (g, s) -> IO (WhebOptions g s m)

-- | Generate options for an application without a context or state
genMinOpts :: InitM () () IO () -> IO MinOpts

module Web.Wheb.Internal

-- | Convert <a>WhebOptions</a> to <a>Application</a>
optsToApplication :: WhebOptions g s m -> (forall a. m a -> IO a) -> Application

-- | Run all inner wheb monads to the top level.
runWhebHandler :: Monad m => WhebOptions g s m -> WhebHandlerT g s m -> InternalState s -> HandlerData g s m -> m EResponse

-- | Same as above but returns arbitrary type for debugging.
runDebugHandler :: Monad m => WhebOptions g s m -> WhebT g s m a -> HandlerData g s m -> m (Either WhebError a)

-- | Runs middlewares in order, stopping if one returns a response
runMiddlewares :: Monad m => WhebOptions g s m -> [WhebMiddleware g s m] -> HandlerData g s m -> m (Maybe Response, InternalState s)
runWhebMiddleware :: Monad m => WhebOptions g s m -> InternalState s -> HandlerData g s m -> WhebMiddleware g s m -> m (Maybe Response, InternalState s)

module Web.Wheb.WhebT

-- | Get the <tt>g</tt> in <tt>WhebT g s m g</tt>. This is a read-only
--   state so only thread-safe resources such as DB connections should go
--   in here.
getApp :: Monad m => WhebT g s m g
getWithApp :: Monad m => (g -> a) -> WhebT g s m a

-- | Get the <tt>s</tt> in <tt>WhebT g s m g</tt>. This is a read and
--   writable state so you can get and put information in your state. Each
--   request gets its own fresh state duplicated from our options
--   <a>startingState</a>
getHandlerState :: Monad m => WhebT g s m s
putHandlerState :: Monad m => s -> WhebT g s m ()
modifyHandlerState :: Monad m => (s -> s) -> WhebT g s m s
modifyHandlerState' :: Monad m => (s -> s) -> WhebT g s m ()

-- | Set a header for the response
setHeader :: Monad m => Text -> Text -> WhebT g s m ()

-- | Set a Strict ByteString header for the response
setRawHeader :: Monad m => Header -> WhebT g s m ()

-- | Return simple HTML from lazy Text
html :: Monad m => Text -> WhebHandlerT g s m

-- | Return simple lazy Text
text :: Monad m => Text -> WhebHandlerT g s m

-- | Give filepath and content type to serve a file via lazy text.
file :: Monad m => Text -> Text -> WhebHandlerT g s m

-- | Give content type and Blaze Builder
builder :: Monad m => Text -> Builder -> WhebHandlerT g s m

-- | Redirect to a given URL
redirect :: Monad m => Text -> WhebHandlerT g s m

-- | Thow a redirect as an error
throwRedirect :: Monad m => Text -> WhebHandlerT g s m

-- | Help prevent monomorphism errors for simple settings.
getSetting :: Monad m => Text -> WhebT g s m (Maybe Text)

-- | Open up underlying support for polymorphic global settings
getSetting' :: (Monad m, Typeable a) => Text -> WhebT g s m (Maybe a)

-- | Get a setting or a default
getSetting'' :: (Monad m, Typeable a) => Text -> a -> WhebT g s m a

-- | Get all settings.
getSettings :: Monad m => WhebT g s m CSettings

-- | Get all route params.
getRouteParams :: Monad m => WhebT g s m RouteParamList

-- | Cast a route param into its type.
getRouteParam :: (Typeable a, Monad m) => Text -> WhebT g s m a

-- | Convert <a>Either</a> from <a>getRoute'</a> into an error in the Monad
getRoute :: Monad m => Text -> RouteParamList -> WhebT g s m Text

-- | Generate a route from a name and param list.
getRoute' :: Monad m => Text -> RouteParamList -> WhebT g s m (Either UrlBuildError Text)

-- | Generate the raw route
getRawRoute :: Monad m => Text -> RouteParamList -> WhebT g s m (Maybe (Route g s m))

-- | Access the request
getRequest :: Monad m => WhebT g s m Request

-- | Get a request header
getRequestHeader :: Monad m => Text -> WhebT g s m (Maybe Text)
getWithRequest :: Monad m => (Request -> a) -> WhebT g s m a

-- | Get params from URL (e.g. from '/foo/?q=4')
getQueryParams :: Monad m => WhebT g s m Query

-- | Maybe get one param if it exists.
getPOSTParam :: MonadIO m => Text -> WhebT g s m (Maybe Text)

-- | Get POST params as <tt>Text</tt>
getPOSTParams :: MonadIO m => WhebT g s m [(Text, Text)]

-- | Get the raw parsed POST data including files.
getRawPOST :: MonadIO m => WhebT g s m ([Param], [File ByteString])

-- | Convenience wrapper for <a>runWhebServerT</a> function in IO
runWhebServer :: (WhebOptions g s IO) -> IO ()

-- | Run a server with a function to run your inner Transformer to IO and
--   generated options
runWhebServerT :: (forall a. m a -> IO a) -> WhebOptions g s m -> IO ()

-- | Convenience wrapper for <a>runRawHandlerT</a> function in <a>IO</a>
runRawHandler :: WhebOptions g s IO -> WhebT g s IO a -> IO (Either WhebError a)

-- | Running a Handler with a custom Transformer
runRawHandlerT :: WhebOptions g s m -> (m (Either WhebError a) -> IO (Either WhebError a)) -> Request -> WhebT g s m a -> IO (Either WhebError a)

module Web.Wheb.Cookie
setCookie :: Monad m => Text -> Text -> WhebT g s m ()

-- | Set a cookie. Looks up setting "enable-secure-cookies" to control
--   turning HTTPS only cookies on. This should be enabled on production
--   environments.
setCookie' :: Monad m => Text -> Text -> SetCookie -> WhebT g s m ()
getCookie :: Monad m => Text -> WhebT g s m (Maybe Text)
getCookies :: Monad m => WhebT g s m CookiesText
removeCookie :: Monad m => Text -> WhebT g s m ()


-- | This module reexports Wheb modules. It should be the only thing you
--   need to import to get started.
--   
--   <pre>
--   import           Web.Wheb
--   import           Data.Text.Lazy (pack)
--   
--   main :: IO ()
--   main = do
--     opts &lt;- generateOptions $ addGET (pack ".") rootPat $ (text (pack "Hi!"))
--     runWhebServer opts
--   </pre>
module Web.Wheb

-- | Get the <tt>g</tt> in <tt>WhebT g s m g</tt>. This is a read-only
--   state so only thread-safe resources such as DB connections should go
--   in here.
getApp :: Monad m => WhebT g s m g
getWithApp :: Monad m => (g -> a) -> WhebT g s m a

-- | Get the <tt>s</tt> in <tt>WhebT g s m g</tt>. This is a read and
--   writable state so you can get and put information in your state. Each
--   request gets its own fresh state duplicated from our options
--   <a>startingState</a>
getHandlerState :: Monad m => WhebT g s m s
putHandlerState :: Monad m => s -> WhebT g s m ()
modifyHandlerState :: Monad m => (s -> s) -> WhebT g s m s
modifyHandlerState' :: Monad m => (s -> s) -> WhebT g s m ()

-- | Return simple HTML from lazy Text
html :: Monad m => Text -> WhebHandlerT g s m

-- | Return simple lazy Text
text :: Monad m => Text -> WhebHandlerT g s m

-- | Give filepath and content type to serve a file via lazy text.
file :: Monad m => Text -> Text -> WhebHandlerT g s m

-- | Give content type and Blaze Builder
builder :: Monad m => Text -> Builder -> WhebHandlerT g s m

-- | Redirect to a given URL
redirect :: Monad m => Text -> WhebHandlerT g s m

-- | Thow a redirect as an error
throwRedirect :: Monad m => Text -> WhebHandlerT g s m

-- | Set a header for the response
setHeader :: Monad m => Text -> Text -> WhebT g s m ()

-- | Set a Strict ByteString header for the response
setRawHeader :: Monad m => Header -> WhebT g s m ()
setCookie :: Monad m => Text -> Text -> WhebT g s m ()

-- | Set a cookie. Looks up setting "enable-secure-cookies" to control
--   turning HTTPS only cookies on. This should be enabled on production
--   environments.
setCookie' :: Monad m => Text -> Text -> SetCookie -> WhebT g s m ()
getCookie :: Monad m => Text -> WhebT g s m (Maybe Text)
getCookies :: Monad m => WhebT g s m CookiesText
removeCookie :: Monad m => Text -> WhebT g s m ()

-- | Help prevent monomorphism errors for simple settings.
getSetting :: Monad m => Text -> WhebT g s m (Maybe Text)

-- | Open up underlying support for polymorphic global settings
getSetting' :: (Monad m, Typeable a) => Text -> WhebT g s m (Maybe a)

-- | Get a setting or a default
getSetting'' :: (Monad m, Typeable a) => Text -> a -> WhebT g s m a

-- | Get all settings.
getSettings :: Monad m => WhebT g s m CSettings

-- | Get all route params.
getRouteParams :: Monad m => WhebT g s m RouteParamList

-- | Cast a route param into its type.
getRouteParam :: (Typeable a, Monad m) => Text -> WhebT g s m a

-- | Convert <a>Either</a> from <a>getRoute'</a> into an error in the Monad
getRoute :: Monad m => Text -> RouteParamList -> WhebT g s m Text

-- | Generate a route from a name and param list.
getRoute' :: Monad m => Text -> RouteParamList -> WhebT g s m (Either UrlBuildError Text)

-- | Access the request
getRequest :: Monad m => WhebT g s m Request

-- | Get a request header
getRequestHeader :: Monad m => Text -> WhebT g s m (Maybe Text)
getWithRequest :: Monad m => (Request -> a) -> WhebT g s m a

-- | Get params from URL (e.g. from '/foo/?q=4')
getQueryParams :: Monad m => WhebT g s m Query

-- | Maybe get one param if it exists.
getPOSTParam :: MonadIO m => Text -> WhebT g s m (Maybe Text)

-- | Get POST params as <tt>Text</tt>
getPOSTParams :: MonadIO m => WhebT g s m [(Text, Text)]

-- | Get the raw parsed POST data including files.
getRawPOST :: MonadIO m => WhebT g s m ([Param], [File ByteString])

-- | Convenience wrapper for <a>runWhebServerT</a> function in IO
runWhebServer :: (WhebOptions g s IO) -> IO ()

-- | Run a server with a function to run your inner Transformer to IO and
--   generated options
runWhebServerT :: (forall a. m a -> IO a) -> WhebOptions g s m -> IO ()

-- | Convenience wrapper for <a>runRawHandlerT</a> function in <a>IO</a>
runRawHandler :: WhebOptions g s IO -> WhebT g s IO a -> IO (Either WhebError a)

-- | Running a Handler with a custom Transformer
runRawHandlerT :: WhebOptions g s m -> (m (Either WhebError a) -> IO (Either WhebError a)) -> Request -> WhebT g s m a -> IO (Either WhebError a)
addGET :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addPOST :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addPUT :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addDELETE :: Text -> UrlPat -> WhebHandlerT g s m -> InitM g s m ()
addRoute :: Route g s m -> InitM g s m ()
addRoutes :: [Route g s m] -> InitM g s m ()

-- | Catch all requests regardless of method or path
catchAll :: WhebHandlerT g s m -> InitM g s m ()
addWhebSocket :: UrlPat -> WhebSocket g s m -> InitM g s m ()
addSite :: Text -> Site url (WhebHandlerT g s m) -> InitM g s m ()

-- | Add generic <a>WAI</a> middleware
addWAIMiddleware :: Middleware -> InitM g s m ()

-- | Add <a>Wheb</a> specific middleware
addWhebMiddleware :: WhebMiddleware g s m -> InitM g s m ()

-- | Wrapped <a>addSetting'</a> to help prevent monomorphism errors for
--   simple settings.
addSetting :: Text -> Text -> InitM g s m ()

-- | Adds a setting value, replacing it if its key already exists.
addSetting' :: Typeable a => Text -> a -> InitM g s m ()
addSettings :: CSettings -> InitM g s m ()

-- | Reads a file line by line and splits keys and values by ":". Uses
--   default <a>Text.Read</a> to try to match <a>Int</a>, <a>Bool</a> or
--   <a>Float</a> and will add specific typed settings for those.
readSettingsFile :: FilePath -> InitM g s m ()

-- | IO Actions to run after server has been stopped.
addCleanupHook :: IO () -> InitM g s m ()

-- | Generate <a>WhebOptions</a> from <a>InitM</a> in <a>IO</a>
generateOptions :: MonadIO m => InitM g s m (g, s) -> IO (WhebOptions g s m)

-- | Generate options for an application without a context or state
genMinOpts :: InitM () () IO () -> IO MinOpts

-- | Convert a <a>UrlPat</a> to a <a>UrlParser</a>
compilePat :: UrlPat -> UrlParser

-- | Represents root path <tt>/</tt>
rootPat :: UrlPat

-- | Allows for easier building of URL patterns This should be the primary
--   URL constructor.
--   
--   <pre>
--   (\"blog\" '&lt;/&gt;' ('grabInt' \"pk\") '&lt;/&gt;' \"edit\" '&lt;/&gt;' ('grabText' \"verb\"))
--   </pre>
(</>) :: UrlPat -> UrlPat -> UrlPat

-- | Parses URL parameter and matches on <a>Int</a>
grabInt :: Text -> UrlPat

-- | Parses URL parameter and matches on <tt>Text</tt>
grabText :: Text -> UrlPat

-- | Constructors to use w/o OverloadedStrings
pT :: Text -> UrlPat
pS :: String -> UrlPat

-- | Show and pack into Lazy <tt>Text</tt>
spack :: Show a => a -> Text
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

module Web.Wheb.Plugins.Session
data SessionContainer
SessionContainer :: r -> SessionContainer
class SessionApp a
getSessionContainer :: SessionApp a => a -> SessionContainer
class SessionBackend c
backendSessionPut :: (SessionBackend c, SessionApp a, MonadIO m) => Text -> Text -> Text -> c -> WhebT a b m ()
backendSessionGet :: (SessionBackend c, SessionApp a, MonadIO m) => Text -> Text -> c -> WhebT a b m (Maybe Text)
backendSessionDelete :: (SessionBackend c, SessionApp a, MonadIO m) => Text -> Text -> c -> WhebT a b m ()
backendSessionClear :: (SessionBackend c, SessionApp a, MonadIO m) => Text -> c -> WhebT a b m ()
setSessionValue :: (SessionApp a, MonadIO m) => Text -> Text -> WhebT a b m ()
getSessionValue :: (SessionApp a, MonadIO m) => Text -> WhebT a b m (Maybe Text)
getSessionValue' :: (SessionApp a, MonadIO m) => Text -> Text -> WhebT a b m Text
deleteSessionValue :: (SessionApp a, MonadIO m) => Text -> WhebT a b m ()
generateSessionKey :: (SessionApp a, MonadIO m) => WhebT a b m Text
getCurrentSessionKey :: (SessionApp a, MonadIO m) => WhebT a b m Text
clearSessionKey :: (SessionApp a, MonadIO m) => WhebT a b m Text

module Web.Wheb.Plugins.Auth

-- | Log a user in
login :: (AuthApp a, AuthState b, MonadIO m) => UserKey -> Password -> WhebT a b m (Either AuthError AuthUser)

-- | Log a user out
logout :: (AuthApp a, AuthState b, MonadIO m) => WhebT a b m ()

-- | Register a user
register :: (AuthApp a, MonadIO m) => AuthUser -> Password -> WhebT a b m (Either AuthError AuthUser)

-- | Get the current user from the handler state (Needs to be populated
--   first with <a>authMiddleware</a>)
getCurrentUser :: (AuthState b, MonadIO m) => WhebT a b m (Maybe AuthUser)

-- | Explicitly query a user with the backend. Since this is an IO hit, it
--   is better to use the middleware and <a>getCurrentUser</a>
queryCurrentUser :: (AuthApp a, MonadIO m) => WhebT a b m (Maybe AuthUser)

-- | Checks if a user is logged in with <a>getCurrentUser</a> and throws a
--   500 if they aren't.
loginRequired :: (AuthState b, MonadIO m) => WhebHandlerT a b m -> WhebHandlerT a b m

-- | Auto-populates the handler state with the current user.
authMiddleware :: (AuthApp a, AuthState b, MonadIO m) => WhebMiddleware a b m
data AuthUser
AuthUser :: UserKey -> AuthUser
uniqueUserKey :: AuthUser -> UserKey
data AuthContainer
AuthContainer :: r -> AuthContainer

-- | Interface for creating Auth backends
class SessionApp a => AuthApp a
getAuthContainer :: AuthApp a => a -> AuthContainer

-- | Minimal implementation for a
class AuthState a
getAuthUser :: AuthState a => a -> PossibleUser
modifyAuthUser :: AuthState a => (PossibleUser -> PossibleUser) -> a -> a

-- | Interface for creating Auth backends
class AuthBackend c where backendLogout _ = getUserSessionKey >>= deleteSessionValue
backendLogin :: (AuthBackend c, AuthApp a, MonadIO m) => SessionApp a => UserKey -> Password -> c -> WhebT a b m (Either AuthError AuthUser)
backendRegister :: (AuthBackend c, AuthApp a, MonadIO m) => AuthUser -> Password -> c -> WhebT a b m (Either AuthError AuthUser)
backendGetUser :: (AuthBackend c, AuthApp a, MonadIO m) => UserKey -> c -> WhebT a b m (Maybe AuthUser)
backendLogout :: (AuthBackend c, AuthApp a, MonadIO m) => c -> WhebT a b m ()
data AuthError
DuplicateUsername :: AuthError
UserDoesNotExist :: AuthError
InvalidPassword :: AuthError
type UserKey = Text
type Password = Text
type PwHash = Text
makePwHash :: MonadIO m => Password -> WhebT a b m PwHash
verifyPw :: Text -> Text -> Bool
getUserSessionKey :: (AuthApp a, MonadIO m) => WhebT a b m Text
instance Show AuthError
instance Show AuthUser

module Web.Wheb.Plugins.Cache
data CacheContainer
CacheContainer :: r -> CacheContainer
class CacheApp a
getCacheContainer :: CacheApp a => a -> CacheContainer
class CacheBackend c
backendCachePut :: (CacheBackend c, CacheApp a, MonadIO m) => Text -> ByteString -> Integer -> c -> WhebT a b m ()
backendCacheGet :: (CacheBackend c, CacheApp a, MonadIO m) => Text -> c -> WhebT a b m (Maybe ByteString)
backendCacheDelete :: (CacheBackend c, CacheApp a, MonadIO m) => Text -> c -> WhebT a b m ()

-- | Set a cache value with an expiration of an hour
setCacheValue :: (CacheApp a, MonadIO m) => Text -> ByteString -> WhebT a b m ()

-- | Set a cache value with expiration in seconds
setCacheValue' :: (CacheApp a, MonadIO m) => Text -> ByteString -> Integer -> WhebT a b m ()
getCacheValue :: (CacheApp a, MonadIO m) => Text -> WhebT a b m (Maybe ByteString)
getCacheValue' :: (CacheApp a, MonadIO m) => ByteString -> Text -> WhebT a b m ByteString
deleteCacheValue :: (CacheApp a, MonadIO m) => Text -> WhebT a b m ()

module Web.Wheb.Plugins.Debug.MemoryBackend
data SessionData
SessionData :: TVar (Map Text (Map Text Text)) -> SessionData
sessionMemory :: SessionData -> TVar (Map Text (Map Text Text))
data UserData
UserData :: TVar (Map UserKey PwHash) -> UserData
userStorage :: UserData -> TVar (Map UserKey PwHash)
data CacheData
CacheData :: TVar (Map Text ByteString) -> CacheData
cacheStorage :: CacheData -> TVar (Map Text ByteString)

-- | In memory cache backend. Cache value will not persist after server
--   restart and will never clear old values.

-- | In memory session backend. Session values will not persist after
--   server restart.

-- | In memory auth backend. User values will not persist after server
--   restart.
initSessionMemory :: InitM g s m SessionContainer
initAuthMemory :: InitM g s m AuthContainer
initCacheMemory :: InitM g s m CacheContainer
instance AuthBackend UserData
instance SessionBackend SessionData
instance CacheBackend CacheData


-- | Provides middleware and view protection against CSRF attacks. To
--   ensure maximum protection, turn on the setting
--   "enable-secure-cookies".
module Web.Wheb.Plugins.Security

-- | A middleware to protect ALL incoming POST requests aginst CSRF,
--   throwing the handler upon failure
csrfMiddleware :: MonadIO m => WhebHandlerT g s m -> WhebMiddleware g s m

-- | Takes a handler to throw when CSRF fails and a handler to run when it
--   succeeds
csrfProtect :: MonadIO m => WhebHandlerT g s m -> WhebHandlerT g s m -> WhebHandlerT g s m

-- | CSRF reads a cookie value ("csrf_token") and compares it to either
--   submitted post data (param "csrf_token") or request header
--   (<a>X-CSRF-TOKEN</a>)
csrfPassed :: MonadIO m => WhebT a b m Bool

-- | This will get or generate and set a new CSRF Token in the Cookies
getCSRFToken :: MonadIO m => WhebT a b m Text
