-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reusable corecursive queues, via continuations.
--   
--   This library provides efficient real-time queues via self-referential
--   lazy lists. The technique was first published in <i>Circular Programs
--   and Self-Referential Structures</i> by Lloyd Allison, <i>Software
--   Practice and Experience</i>, 19(2), pp.99-109, Feb 1989
--   
--   <a>http://www.csse.monash.edu.au/~lloyd/tildeFP/1989SPE/</a>
--   
--   For an explanation of the library implementation, see <i>Lloyd
--   Allison's Corecursive Queues: Why Continuations Matter</i> by Leon P
--   Smith, in <i>The Monad Reader</i>, Issue 14, Jul 2009.
--   
--   <a>http://themonadreader.files.wordpress.com/2009/07/issue142.pdf</a>
--   
--   A lightly edited version of the paper above is available at:
--   
--   <a>http://www.melding-monads.com/files/CorecQueues.pdf</a>
@package control-monad-queue
@version 0.2


-- | A library implementation of corecursive queues, see <i>Circular
--   Programs and Self-Referential Structures</i> by Lloyd Allison,
--   <i>Software Practice and Experience</i>, 19(2), pp.99-109, Feb 1989
--   
--   <a>http://www.csse.monash.edu.au/~lloyd/tildeFP/1989SPE/</a>
--   
--   For an explanation of the library implementation, see <i>Lloyd
--   Allison's Corecursive Queues: Why Continuations Matter</i> by Leon P
--   Smith, in <i>The Monad Reader</i>, Issue 14, Jul 2009. This library
--   corresponds to <tt>CorecQ</tt> in that paper.
--   
--   <a>http://themonadreader.files.wordpress.com/2009/07/issue142.pdf</a>
module Control.Monad.Queue.Allison
data Q e a
type LenType = Word

-- | Returns a list of all elements enqueued during the queue computation
runQueue :: Q e a -> [e]

-- | Enqueues an element to the queue
enQ :: e -> Q e ()

-- | Dequeues an element, returns <a>Nothing</a> if the queue is empty.
deQ :: Q e (Maybe e)

-- | Dequeues up to <tt>len</tt> elements from the queue
deQs :: Integral len => len -> Q e [e]

-- | Dequeues an element: terminates the queue computation if the queue is
--   empty.
deQ_break :: Q e e

-- | Examines the front element of the queue without removing it.
peekQ :: Q e (Maybe e)

-- | Examines the element currently at position <tt>index</tt> in the
--   queue, indexing starts with <tt>0</tt>, like <a>!!</a>.
peekQn :: Integral index => index -> Q e (Maybe e)

-- | Examines up to <tt>maxlen</tt> elements of the queue without removing
--   them.
peekQs :: Integral maxlen => maxlen -> Q e [e]

-- | Returns the length of the queue
lenQ :: Integral len => Q e len

-- | Returns the length of the queue
lenQ_ :: Q e LenType
callCC :: ((a -> forall b. Q e b) -> Q e a) -> Q e a

-- | Terminates the queue computation
exit :: Q e a
instance Monad (Q e)
instance Applicative (Q e)
instance Functor (Q e)


-- | Corecursive queues with return values. This is a straightforward
--   generalization of Control.Monad.Queue.Allison. It corresponds to
--   <tt>CorecQW</tt> in the paper <i>Lloyd Allison's Corecursive Queues:
--   Why Continuations Matter</i> by Leon P Smith in the Monad Reader issue
--   14.
module Control.Monad.Queue.Corec
data Q w e a
type LenType = Word

-- | Runs the computation, returns the result of the computation and a list
--   of all elements enqueued
runResultQueue :: Q a e a -> (a, [e])

-- | Runs the computation, returns the result of the computation
runResult :: Q a e a -> a

-- | Runs the computation, returns a list of all elements enqueued
runQueue :: Q a e a -> [e]

-- | Enqueues an element to the queue
enQ :: e -> Q w e ()

-- | Dequeues and element: returns <a>Nothing</a> if the queue is empty.
deQ :: Q w e (Maybe e)

-- | Dequeues an element: terminates the computation with the final result
--   <tt>w</tt> if the queue is empty.
deQ_break :: w -> Q w e e

-- | Dequeues up to <tt>len</tt> elements from the queue
deQs :: Integral len => len -> Q w e [e]

-- | Examines the front element of the queue without removing it.
peekQ :: Q w e (Maybe e)

-- | Examines the element currently at position <tt>index</tt> in the
--   queue, indexing starts from <tt>0</tt>, like <a>!!</a>
peekQn :: Integral index => index -> Q w e (Maybe e)

-- | Looks at up to the first <tt>len</tt> elements of the queue, like
--   <a>deQs</a> except without removing them.
peekQs :: Integral len => len -> Q w e [e]

-- | Returns the length of the queue
lenQ :: Integral len => Q w e len

-- | Returns the length of the queue
lenQ_ :: Q w e LenType

-- | Applies a function to the final return value of the entire
--   computation, like <tt>Control.Monad.Cont.mapCont</tt>
mapQ :: (w -> w) -> Q w e a -> Q w e a

-- | Computes a fixpoint on the result; usually used in conjunction with
--   <tt>mapQ</tt>
wfix :: (w -> Q w e a) -> Q w e a
callCC :: ((a -> forall b. Q w e b) -> Q w e a) -> Q w e a

-- | Terminates the queue computation with result <tt>w</tt>
exit :: w -> Q w e a
instance Monad (Q w e)
instance Applicative (Q w e)
instance Functor (Q w e)


module Control.Monad.Queue.Class
class Monad q => MonadQueue e q | q -> e
enQ :: MonadQueue e q => e -> q ()
deQ :: MonadQueue e q => q (Maybe e)
deQs :: (MonadQueue e q, Integral maxlen) => maxlen -> q [e]
peekQ :: MonadQueue e q => q (Maybe e)
peekQs :: (MonadQueue e q, Integral maxlen) => maxlen -> q [e]
peekQn :: (MonadQueue e q, Integral index) => index -> q (Maybe e)
lenQ :: (MonadQueue e q, Integral len) => q len
instance MonadQueue e (Q w e)
instance MonadQueue e (Q e)
