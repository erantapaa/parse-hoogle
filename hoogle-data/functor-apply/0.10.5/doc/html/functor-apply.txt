-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 98: Applicative sans pure, Monad sans return, Alternative sans empty
--   
--   Provides a wide array of semigroup based Functors.
--   
--   When working with comonads you often have the <tt>&lt;*&gt;</tt>
--   portion of an <tt>Applicative</tt>, but not the <tt>pure</tt>. This
--   was captured in Uustalu and Vene's "Essence of Dataflow Programming"
--   in the form of the <tt>ComonadZip</tt> class in the days before
--   <tt>Applicative</tt>. Apply provides a weaker invariant, but for the
--   comonads used for data flow programming (found in the streams
--   package), this invariant is preserved.
--   
--   Ideally the following relationships would hold:
--   
--   <pre>
--   Traversable &lt;---- Foldable &lt;--- Functor ------&gt; Alt ---------&gt; Plus
--        |               |            |                              |
--        v               v            v                              v
--   Traversable1 &lt;--- Foldable1     Apply --------&gt; Applicative -&gt; Alternative
--                                     |               |              |
--                                     v               v              v
--                                   Bind ---------&gt; Monad -------&gt; MonadPlus
--   
--   
--   
--   Bitraversable &lt;-- Bifoldable &lt;- Bifunctor                      Semigroupoid
--       |                  |          |                              |
--       v                  v          v                              v
--   Bitraversable1 &lt;- Bifoldable1   Biapply                        Category
--                                                                    |
--                                                                    v
--                                                                  Arrow
--   </pre>
--   
--   This lets us remove many of the restrictions from various monad
--   transformers as in many cases the binding operation or
--   <tt>&lt;*&gt;</tt> operation does not require them.
--   
--   Finally, to work with these weaker structures it is beneficial to have
--   containers that can provide stronger guarantees about their contents,
--   so versions of <a>Traversable</a> and <a>Foldable</a> that can be
--   folded with just a <a>Semigroup</a> are added.
@package functor-apply
@version 0.10.5


-- | NB: The definitions exported through <a>Data.Functor.Apply</a> need to
--   be included here because otherwise the instances for the transformers
--   package have orphaned heads.
module Data.Functor.Bind

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <tt>Data.Maybe.Maybe</tt>
--   and <tt>System.IO.IO</tt> satisfy these laws.
class Functor f :: (* -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | TODO: move into Data.Functor
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
(-<<) :: Bind m => (a -> m b) -> m a -> m b
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
instance (Comonad w, Apply w) => ArrowLoop (Cokleisli w)
instance Bind Tree
instance Bind Seq
instance Bind IntMap
instance Ord k => Bind (Map k)
instance Bind (ContT r m)
instance (Bind m, Semigroup w) => Bind (RWST r w s m)
instance (Bind m, Semigroup w) => Bind (RWST r w s m)
instance Bind m => Bind (StateT s m)
instance Bind m => Bind (StateT s m)
instance (Bind m, Semigroup w) => Bind (WriterT w m)
instance (Bind m, Semigroup w) => Bind (WriterT w m)
instance Bind m => Bind (ReaderT e m)
instance (Bind m, Monad m) => Bind (ErrorT e m)
instance (Bind m, Monad m) => Bind (ListT m)
instance (Bind m, Monad m) => Bind (MaybeT m)
instance Monad m => Bind (WrappedMonad m)
instance Bind m => Bind (IdentityT m)
instance Bind Identity
instance Bind Option
instance Bind Maybe
instance Bind IO
instance Bind []
instance Bind ((->) m)
instance (Bind f, Bind g) => Bind (Product f g)
instance Bind (Either a)
instance Semigroup m => Bind ((,) m)
instance Apply (Cokleisli w a)
instance Comonad f => Comonad (MaybeApply f)
instance Extend f => Extend (MaybeApply f)
instance Apply f => Applicative (MaybeApply f)
instance Apply f => Apply (MaybeApply f)
instance Functor f => Functor (MaybeApply f)
instance Alternative f => Alternative (WrappedApplicative f)
instance Applicative f => Applicative (WrappedApplicative f)
instance Applicative f => Apply (WrappedApplicative f)
instance Functor f => Functor (WrappedApplicative f)
instance Apply (ContT r m)
instance (Bind m, Semigroup w) => Apply (RWST r w s m)
instance (Bind m, Semigroup w) => Apply (RWST r w s m)
instance Bind m => Apply (StateT s m)
instance Bind m => Apply (StateT s m)
instance (Apply m, Semigroup w) => Apply (WriterT w m)
instance (Apply m, Semigroup w) => Apply (WriterT w m)
instance Apply m => Apply (ListT m)
instance Apply m => Apply (ReaderT e m)
instance (Bind m, Monad m) => Apply (ErrorT e m)
instance (Bind m, Monad m) => Apply (MaybeT m)
instance Apply Tree
instance Apply Seq
instance Apply IntMap
instance Ord k => Apply (Map k)
instance Arrow a => Apply (WrappedArrow a b)
instance Monad m => Apply (WrappedMonad m)
instance Apply w => Apply (IdentityT w)
instance Apply Identity
instance Apply Option
instance Apply Maybe
instance Apply IO
instance Apply []
instance Apply ZipList
instance Apply ((->) m)
instance Semigroup m => Apply (Const m)
instance Apply (Either a)
instance Semigroup m => Apply ((,) m)
instance (Apply f, Apply g) => Apply (Product f g)
instance (Apply f, Apply g) => Apply (Compose f g)


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance BindTrans (ContT r)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance BindTrans (StateT s)
instance BindTrans (StateT s)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance BindTrans (ReaderT e)
instance BindTrans IdentityT


module Data.Bifunctor.Apply

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <tt>Applicative</tt> without <tt>pure</tt>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Bifunctor p => Biapply p
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d
(.>>) :: Biapply p => p a b -> p c d -> p c d
(<<.) :: Biapply p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
(<<..>>) :: Biapply p => p a c -> p (a -> b) (c -> d) -> p b d

-- | Lift a binary function into a comonad with zipping
bilift2 :: Biapply w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift a ternary function into a comonad with zipping
bilift3 :: Biapply w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
instance Biapply (,)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <tt>Control.Category.Category</tt> sans <tt>Control.Category.id</tt>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
instance Semigroupoid Op
instance Extend w => Semigroupoid (Cokleisli w)
instance Bind m => Semigroupoid (Kleisli m)
instance Semigroupoid (->)


module Data.Functor.Apply

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <tt>Data.Maybe.Maybe</tt>
--   and <tt>System.IO.IO</tt> satisfy these laws.
class Functor f :: (* -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | TODO: move into Data.Functor
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distributon" law of MonadPlus with respect to <a>.</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   But <a>Maybe</a>, <a>IO</a>, <tt><a>Either</a> a</tt>,
--   <tt><a>ErrorT</a> e m</tt>, and <tt>STM</tt> satisfy the alternative
--   "left catch" law instead:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   However, this variation cannot be stated purely in terms of the
--   dependencies of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <a>Bind</a> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
instance Alt f => Alt (RWST r w s f)
instance Alt f => Alt (RWST r w s f)
instance Alt f => Alt (WriterT w f)
instance Alt f => Alt (WriterT w f)
instance Alt f => Alt (StateT e f)
instance Alt f => Alt (StateT e f)
instance Apply f => Alt (ListT f)
instance (Bind f, Monad f) => Alt (ErrorT e f)
instance (Bind f, Monad f) => Alt (MaybeT f)
instance Alt f => Alt (ReaderT e f)
instance Alt f => Alt (IdentityT f)
instance Alternative f => Alt (WrappedApplicative f)
instance Alt Seq
instance Alt IntMap
instance Ord k => Alt (Map k)
instance ArrowPlus a => Alt (WrappedArrow a b)
instance MonadPlus m => Alt (WrappedMonad m)
instance Alt Option
instance Alt Maybe
instance Alt []
instance Alt IO
instance Alt (Either a)


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a
instance Plus f => Plus (RWST r w s f)
instance Plus f => Plus (RWST r w s f)
instance Plus f => Plus (WriterT w f)
instance Plus f => Plus (WriterT w f)
instance Plus f => Plus (StateT e f)
instance Plus f => Plus (StateT e f)
instance (Apply f, Applicative f) => Plus (ListT f)
instance (Bind f, Monad f, Error e) => Plus (ErrorT e f)
instance (Bind f, Monad f) => Plus (MaybeT f)
instance Plus f => Plus (ReaderT e f)
instance Plus f => Plus (IdentityT f)
instance Alternative f => Plus (WrappedApplicative f)
instance Plus Seq
instance Plus IntMap
instance Ord k => Plus (Map k)
instance ArrowPlus a => Plus (WrappedArrow a b)
instance MonadPlus m => Plus (WrappedMonad m)
instance Plus Option
instance Plus Maybe
instance Plus []
instance Plus IO


module Data.Semigroup.Bifoldable
class Bifoldable t => Bifoldable1 t
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
bitraverse1_ :: (Bifoldable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f ()
bifor1_ :: (Bifoldable1 t, Apply f) => t a c -> (a -> f b) -> (c -> f d) -> f ()
bisequenceA1_ :: (Bifoldable1 t, Apply f) => t (f a) (f b) -> f ()

-- | Usable default for foldMap, but only if you define bifoldMap1 yourself
bifoldMapDefault1 :: (Bifoldable1 t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)
instance Bifoldable1 (,)
instance Bifoldable1 Either


module Data.Semigroup.Bitraversable
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
bifoldMap1Default :: (Bitraversable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Bitraversable1 (,)
instance Bitraversable1 Either


module Data.Semigroup.Foldable
class Foldable t => Foldable1 t
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m

module Control.Arrow.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
runStatic :: Static f a b -> f (a -> b)
instance Applicative f => ArrowChoice (Static f)
instance Alternative f => ArrowPlus (Static f)
instance Alternative f => ArrowZero (Static f)
instance Applicative f => Arrow (Static f)
instance Applicative f => Category (Static f)
instance Apply f => Semigroupoid (Static f)
instance (Comonad f, Semigroup a, Monoid a) => Comonad (Static f a)
instance (Extend f, Semigroup a) => Extend (Static f a)
instance Applicative f => Applicative (Static f a)
instance Plus f => Plus (Static f a)
instance Alt f => Alt (Static f a)
instance Apply f => Apply (Static f a)
instance Functor f => Functor (Static f a)
