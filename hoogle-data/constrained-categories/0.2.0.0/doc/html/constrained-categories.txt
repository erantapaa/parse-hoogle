-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constrained clones of the category-theory type classes, using ConstraintKinds.
--   
@package constrained-categories
@version 0.2.0.0


-- | Re-exports of all the common category-theory inspired classes from the
--   "base" package, i.e. basically endofunctors in the Hask category (with
--   functions <tt>(-&gt;)</tt> as morphisms). The module is thus intended
--   to be imported <tt>qualified as Hask</tt>.
--   
--   Main use case would be defining new such functors / monads etc.
--   yourself; even if you only intend to use them through the more general
--   category-agnostic interface established in this package then the
--   <i>instances</i> should still be defined for the plain old
--   Hask-specific classes, i.e. for some
--   
--   <pre>
--   data F a = ...
--   fmapF :: (a-&gt;b) -&gt; F a-&gt;F b@
--   
--   instance Hask.Functor F where
--     Hask.fmap = fmapF
--   </pre>
--   
--   An instance of <a>Functor</a> arises automatically from this, as
--   defined generically for all <tt>(-&gt;)</tt> functors in that module.
module Control.Category.Hask


-- | The most basic category theory tools are included partly in this
--   module, partly in <a>Control.Arrow.Constrained</a>.
module Control.Category.Constrained

-- | In mathematics, a category is defined as a class of <i>objects</i>,
--   plus a class of <i>morphisms</i> between those objects. In Haskell,
--   one traditionally works in the category <tt>(-&gt;)</tt> (called
--   <i>Hask</i>), in which <i>any Haskell type</i> is an object. But of
--   course there are lots of useful categories where the objects are much
--   more specific, e.g. vector spaces with linear maps as morphisms. The
--   obvious way to express this in Haskell is as type class constraints,
--   and the <tt>ConstraintKinds</tt> extension allows quantifying over
--   such object classes.
--   
--   Like in <a>Control.Category</a>, "the category <tt>k</tt>" means
--   actually <tt>k</tt> is the <i>morphism type constructor</i>. From a
--   mathematician's point of view this may seem a bit strange way to
--   define the category, but it just turns out to be quite convenient for
--   practical purposes.
class Category k where type family Object k o :: Constraint type instance Object k o = ()
id :: (Category k, Object k a) => k a a
(.) :: (Category k, Object k a, Object k b, Object k c) => k b c -> k a b -> k a c

-- | Quite a few categories (<i>monoidal categories</i>) will permit
--   "products" of objects as objects again – in the Haskell sense those
--   are tuples – allowing for "dyadic morphisms" <tt>(x,y) ~&gt; r</tt>.
--   
--   Together with a unique <a>UnitObject</a>, this makes for a monoidal
--   structure, with a few natural isomorphisms. Ordinary tuples may not
--   always be powerful enough to express the product objects; we avoid
--   making a dedicated associated type for the sake of simplicity, but
--   allow for an extra constraint to be imposed on objects prior to
--   consideration of pair-building.
--   
--   The name <a>Cartesian</a> is disputable: in category theory that would
--   rather Imply <i>cartesian closed category</i> (which we represent with
--   <a>Curry</a>). <tt>Monoidal</tt> would make sense, but we reserve that
--   to <tt>Functors</tt>.
class (Category k, Monoid (UnitObject k), Object k (UnitObject k)) => Cartesian k where type family PairObjects k a b :: Constraint type family UnitObject k :: * type instance PairObjects k a b = () type instance UnitObject k = ()
swap :: (Cartesian k, ObjectPair k a b, ObjectPair k b a) => k (a, b) (b, a)
attachUnit :: (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u) => k a (a, u)
detachUnit :: (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u) => k (a, u) a
regroup :: (Cartesian k, Object k a, Object k c, ObjectPair k a b, ObjectPair k b c, ObjectPair k a (b, c), ObjectPair k (a, b) c) => k (a, (b, c)) ((a, b), c)
regroup' :: (Cartesian k, Object k a, Object k c, ObjectPair k a b, ObjectPair k b c, ObjectPair k a (b, c), ObjectPair k (a, b) c) => k ((a, b), c) (a, (b, c))

-- | Use this constraint to ensure that <tt>a</tt>, <tt>b</tt> and
--   <tt>(a,b)</tt> are all "fully valid" objects of your category
--   (meaning, you can use them with the <a>Cartesian</a> combinators).
type ObjectPair k a b = (Category k, Object k a, Object k b, PairObjects k a b, Object k (a, b))
class Cartesian k => Curry k where type family MorphObjects k b c :: Constraint type instance MorphObjects k b c = () apply = uncurry id
uncurry :: (Curry k, ObjectPair k a b, ObjectMorphism k b c) => k a (k b c) -> k (a, b) c
curry :: (Curry k, ObjectPair k a b, ObjectMorphism k b c) => k (a, b) c -> k a (k b c)
apply :: (Curry k, ObjectMorphism k a b, ObjectPair k (k a b) a) => k (k a b, a) b

-- | Analogous to <a>ObjectPair</a>: express that <tt>k b c</tt> be an
--   exponential object representing the morphism.
type ObjectMorphism k b c = (Object k b, Object k c, MorphObjects k b c, Object k (k b c))
type (+) = Either

-- | Monoidal categories need not be based on a cartesian product. The
--   relevant alternative is coproducts.
--   
--   The dual notion to <a>Cartesian</a> replaces such products (pairs)
--   with sums (<a>Either</a>), and unit '()' with void types.
--   
--   Basically, the only thing that doesn't mirror <a>Cartesian</a> here is
--   that we don't require <tt>CoMonoid (<a>ZeroObject</a> k)</tt>.
--   Comonoids do in principle make sense, but not from a Haskell viewpoint
--   (every type is trivially a comonoid).
--   
--   Haskell of course uses sum types, <i>variants</i>, most often without
--   <a>Either</a> appearing. But variants are generally isomorphic to
--   sums; the most important (sums of unit) are methods here.
class (Category k, Object k (ZeroObject k)) => CoCartesian k where type family SumObjects k a b :: Constraint type family ZeroObject k :: * type instance SumObjects k a b = () type instance ZeroObject k = Void
coSwap :: (CoCartesian k, ObjectSum k a b, ObjectSum k b a) => k (a + b) (b + a)
attachZero :: (CoCartesian k, Object k a, z ~ ZeroObject k, ObjectSum k a z) => k a (a + z)
detachZero :: (CoCartesian k, Object k a, z ~ ZeroObject k, ObjectSum k a z) => k (a + z) a
coRegroup :: (CoCartesian k, Object k a, Object k c, ObjectSum k a b, ObjectSum k b c, ObjectSum k a (b + c), ObjectSum k (a + b) c) => k (a + (b + c)) ((a + b) + c)
coRegroup' :: (CoCartesian k, Object k a, Object k c, ObjectSum k a b, ObjectSum k b c, ObjectSum k a (b + c), ObjectSum k (a + b) c) => k ((a + b) + c) (a + (b + c))
maybeAsSum :: (CoCartesian k, ObjectSum k u a, u ~ UnitObject k, Object k (Maybe a)) => k (Maybe a) (u + a)
maybeFromSum :: (CoCartesian k, ObjectSum k u a, u ~ UnitObject k, Object k (Maybe a)) => k (u + a) (Maybe a)
boolAsSum :: (CoCartesian k, ObjectSum k u u, u ~ UnitObject k, Object k Bool) => k Bool (u + u)
boolFromSum :: (CoCartesian k, ObjectSum k u u, u ~ UnitObject k, Object k Bool) => k (u + u) Bool
type ObjectSum k a b = (Category k, Object k a, Object k b, SumObjects k a b, Object k (a + b))

-- | Apart from <i>the</i> identity morphism, <a>id</a>, there are other
--   morphisms that can basically be considered identies. For instance, in
--   any cartesian category (where it makes sense to have tuples and unit
--   <tt>()</tt> at all), it should be possible to switch between
--   <tt>a</tt> and the isomorphic <tt>(a, ())</tt>. <a>iso</a> is the
--   method for such "pseudo-identities", the most basic of which are
--   required as methods of the <a>Cartesian</a> class.
--   
--   Why it is necessary to make these morphisms explicit: they are needed
--   for a couple of general-purpose category-theory methods, but even
--   though they're normally trivial to define there is no uniform way to
--   do so. For instance, for vector spaces, the baseis of <tt>(a,
--   (b,c))</tt> and <tt>((a,b), c)</tt> are sure enough structurally
--   equivalent, but not in the same way the spaces themselves are (sum vs.
--   product types).
class Category k => Isomorphic k a b
iso :: Isomorphic k a b => k a b

-- | A given category can be specialised, by using the same morphisms but
--   adding extra constraints to what is considered an object.
--   
--   For instance, <tt><a>ConstrainedCategory</a> (-&gt;) <a>Ord</a></tt>
--   is the category of all totally ordered data types (but with arbitrary
--   functions; this does not require monotonicity or anything).
newtype ConstrainedCategory (k :: * -> * -> *) (o :: * -> Constraint) (a :: *) (b :: *)
ConstrainedMorphism :: k a b -> ConstrainedCategory

-- | Cast a morphism to its equivalent in a more constrained category,
--   provided it connects objects that actually satisfy the extra
--   constraint.
constrained :: (Category k, o a, o b) => k a b -> ConstrainedCategory k o a b

-- | "Unpack" a constrained morphism again (forgetful functor).
--   
--   Note that you may often not need to do that; in particular morphisms
--   that are actually <tt>Function</tt>s can just be applied to their
--   objects with <a>$</a> right away, no need to go back to Hask first.
unconstrained :: Category k => ConstrainedCategory k o a b -> k a b

-- | An agent value is a "general representation" of a category's values,
--   i.e. <i>global elements</i>. This is useful to define certain
--   morphisms (including ones that can't just "inherit" from '-&gt;' with
--   <a>arr</a>) in ways other than point-free composition pipelines.
--   Instead, you can write algebraic expressions much as if dealing with
--   actual values of your category's objects, but using the agent type
--   which is restricted so any function defined as such a
--   lambda-expression qualifies as a morphism of that category.
class Category k => HasAgent k where type family AgentVal k a v :: * type instance AgentVal k a v = GenericAgent k a v
alg :: (HasAgent k, Object k a, Object k b) => (forall q. Object k q => AgentVal k q a -> AgentVal k q b) -> k a b
($~) :: (HasAgent k, Object k a, Object k b, Object k c) => k b c -> AgentVal k a b -> AgentVal k a c
genericAlg :: (HasAgent k, Object k a, Object k b) => (forall q. Object k q => GenericAgent k q a -> GenericAgent k q b) -> k a b
genericAgentMap :: (HasAgent k, Object k a, Object k b, Object k c) => k b c -> GenericAgent k a b -> GenericAgent k a c
data GenericAgent k a v
GenericAgent :: k a v -> GenericAgent k a v
runGenericAgent :: GenericAgent k a v -> k a v

-- | Analogue to <a>asTypeOf</a>, this does not actually do anything but
--   can give the compiler type unification hints in a convenient manner.
inCategoryOf :: Category k => k a b -> k c d -> k a b

-- | Tagged type for values that depend on some choice of category, but not
--   on some particular object / arrow therein.
type CatTagged k x = Tagged (k (UnitObject k) (UnitObject k)) x
instance HasAgent (->)
instance (Curry f, o (UnitObject f)) => Curry (ConstrainedCategory f o)
instance Curry (->)
instance (CoCartesian f, o (ZeroObject f)) => CoCartesian (ConstrainedCategory f o)
instance CoCartesian (->)
instance (Cartesian f, o (UnitObject f)) => Cartesian (ConstrainedCategory f o)
instance Cartesian (->)
instance (CoCartesian k, Object k a, ObjectSum k a b, ObjectSum k b c, ObjectSum k a (b + c), ObjectSum k (a + b) c, Object k c) => Isomorphic k ((a + b) + c) (a + (b + c))
instance (CoCartesian k, Object k a, ObjectSum k a b, ObjectSum k b c, ObjectSum k a (b + c), ObjectSum k (a + b) c, Object k c) => Isomorphic k (a + (b + c)) ((a + b) + c)
instance (CoCartesian k, Object k a, u ~ ZeroObject k, ObjectSum k a u, ObjectSum k u a, Object k (u + a), Object k (a + u)) => Isomorphic k (u + a) a
instance (CoCartesian k, Object k a, u ~ ZeroObject k, ObjectSum k a u, ObjectSum k u a, Object k (u + a), Object k (a + u)) => Isomorphic k a (u + a)
instance (CoCartesian k, Object k a, u ~ ZeroObject k, ObjectSum k a u) => Isomorphic k (a + u) a
instance (CoCartesian k, Object k a, u ~ ZeroObject k, ObjectSum k a u) => Isomorphic k a (a + u)
instance (Cartesian k, Object k a, ObjectPair k a b, ObjectPair k b c, ObjectPair k a (b, c), ObjectPair k (a, b) c, Object k c) => Isomorphic k ((a, b), c) (a, (b, c))
instance (Cartesian k, Object k a, ObjectPair k a b, ObjectPair k b c, ObjectPair k a (b, c), ObjectPair k (a, b) c, Object k c) => Isomorphic k (a, (b, c)) ((a, b), c)
instance (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u, ObjectPair k u a, Object k (u, a), Object k (a, u)) => Isomorphic k (u, a) a
instance (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u, ObjectPair k u a, Object k (u, a), Object k (a, u)) => Isomorphic k a (u, a)
instance (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u) => Isomorphic k (a, u) a
instance (Cartesian k, Object k a, u ~ UnitObject k, ObjectPair k a u) => Isomorphic k a (a, u)
instance Category k => Category (ConstrainedCategory k isObj)
instance Category (->)


module Control.Functor.Constrained
class (Category r, Category t, Object t (f (UnitObject r))) => Functor f r t | f r -> t, f t -> r
fmap :: (Functor f r t, Object r a, Object t (f a), Object r b, Object t (f b)) => r a b -> t (f a) (f b)
(<$>) :: (Functor f r (->), Object r a, Object r b) => r a b -> f a -> f b
constrainedFmap :: (Category r, Category t, o a, o b, o (f a), o (f b)) => (r a b -> t (f a) (f b)) -> ConstrainedCategory r o a b -> ConstrainedCategory t o (f a) (f b)

-- | It is fairly common for functors (typically, container-like) to map
--   <a>Either</a> to tuples in a natural way, thus "separating the
--   variants". This is related to <a>Foldable</a> (with list and tuple
--   monoids), but rather more effective.
class (CoCartesian r, Cartesian t, Functor f r t, Object t (f (ZeroObject r))) => SumToProduct f r t
sum2product :: (SumToProduct f r t, ObjectSum r a b, ObjectPair t (f a) (f b)) => t (f (a + b)) (f a, f b)
mapEither :: (SumToProduct f r t, Object r a, ObjectSum r b c, Object t (f a), ObjectPair t (f b) (f c)) => r a (b + c) -> t (f a) (f b, f c)
filter :: (SumToProduct f r t, Object r a, Object r Bool, Object t (f a)) => r a Bool -> t (f a) (f a)
instance (o (), o [()], o Void, o [Void]) => SumToProduct [] (ConstrainedCategory (->) o) (ConstrainedCategory (->) o)
instance (Functor [] k k, o [UnitObject k]) => Functor [] (ConstrainedCategory k o) (ConstrainedCategory k o)
instance SumToProduct [] (->) (->)
instance Functor f => Functor f (->) (->)


-- | Haskell's <a>Arrow</a>s, going back to [Hughes 2000], combine multiple
--   ideas from category theory:
--   
--   <ul>
--   <li>They expand upon cartesian categories, by offering ways to combine
--   arrows between simple objects to composite ones working on tuples
--   (i.e. <i>products</i>) thereof.</li>
--   <li>They constitute a "profunctor" interface, allowing to
--   "<tt>fmap</tt>" both covariantly over the second parameter, as well as
--   contravariantly over the first. As in case of
--   <a>Control.Functor.Constrained</a>, we wish the underlying category to
--   fmap from not to be limited to <i>Hask</i>, so <a>Arrow</a> also has
--   an extra parameter.</li>
--   </ul>
--   
--   To facilitate these somewhat divergent needs, <a>Arrow</a> is split up
--   in three classes. These do not even form an ordinary hierarchy, to
--   allow categories to implement only one <i>or</i> the other aspect.
--   
--   That's not the only significant difference of this module, compared to
--   <a>Control.Arrow</a>:
--   
--   <ul>
--   <li>Kleisli arrows are not defined here, but in
--   <a>Control.Monad.Constrained</a>. Monads are really a much more
--   specific concept than category arrows.</li>
--   <li>Some extra utilities are included that don't apparently have much
--   to do with <a>Arrow</a> at all, but require the expanded
--   cartesian-category tools and are therefore not in
--   <a>Control.Category.Constrained</a>.</li>
--   </ul>
module Control.Arrow.Constrained
type Arrow a k = (WellPointed a, EnhancedCat a k)
class Cartesian a => Morphism a where first = (*** id) second = (id ***)
first :: (Morphism a, ObjectPair a b d, ObjectPair a c d) => a b c -> a (b, d) (c, d)
second :: (Morphism a, ObjectPair a d b, ObjectPair a d c) => a b c -> a (d, b) (d, c)
(***) :: (Morphism a, ObjectPair a b b', ObjectPair a c c') => a b c -> a b' c' -> a (b, b') (c, c')

-- | Unlike <a>first</a>, <a>second</a>, <a>***</a> and <a>arr</a>,
--   <a>&amp;&amp;&amp;</a> has an intrinsic notion of "direction": it is
--   basically equivalent to precomposing the result of <a>***</a> with a
--   <tt>b -&gt; (b,b)</tt>, but that is in general only available for
--   arrows that generalise ordinary functions, in their native direction.
--   (<tt>(b,b) -&gt;b</tt> is specific to semigroups.) It is for this
--   reason the only constituent class of <a>Arrow</a> that actually has
--   "arrow" in its name.
--   
--   In terms of category theory, this "direction" reflects the distinction
--   between <i>initial-</i> and <i>terminal objects</i>. The latter are
--   more interesting, basically what <a>UnitObject</a> is useful for. It
--   gives rise to the tuple selector morphisms as well.
class Morphism a => PreArrow a
(&&&) :: (PreArrow a, Object a b, ObjectPair a c c') => a b c -> a b c' -> a b (c, c')
terminal :: (PreArrow a, Object a b) => a b (UnitObject a)
fst :: (PreArrow a, ObjectPair a x y) => a (x, y) x
snd :: (PreArrow a, ObjectPair a x y) => a (x, y) y

-- | <a>WellPointed</a> expresses the relation between your category's
--   objects and the values of the Haskell data types (which is, after all,
--   what objects are in this library). Specifically, this class allows you
--   to "point" on specific objects, thus making out a value of that type
--   as a point of the object.
--   
--   Perhaps easier than thinking about what that's supposed to mean is
--   noting this class contains <a>const</a>. Thus <a>WellPointed</a> is
--   <i>almost</i> the traditional <a>Arrow</a>: it lets you express all
--   the natural transformations and inject constant values, only you can't
--   just promote arbitrary functions to arrows of the category.
--   
--   Unlike with <a>Morphism</a> and <a>PreArrow</a>, a literal dual of
--   <a>WellPointed</a> does not seem useful.
class (PreArrow a, ObjectPoint a (UnitObject a)) => WellPointed a where type family PointObject a x :: Constraint type instance PointObject a x = () globalElement = const const x = globalElement x . terminal
globalElement :: (WellPointed a, ObjectPoint a x) => x -> a (UnitObject a) x
unit :: WellPointed a => CatTagged a (UnitObject a)
const :: (WellPointed a, Object a b, ObjectPoint a x) => x -> a b x
type ObjectPoint k a = (Object k a, PointObject k a)
class Category k => EnhancedCat a k
arr :: (EnhancedCat a k, Object k b, Object k c, Object a b, Object a c) => k b c -> a b c
type ArrowChoice a k = (WellPointed a, PreArrChoice a, EnhancedCat a k)

-- | Dual to <a>Morphism</a>, dealing with sums instead of products.
class CoCartesian a => MorphChoice a where left = (+++ id) right = (id +++)
left :: (MorphChoice a, ObjectSum a b d, ObjectSum a c d) => a b c -> a (b + d) (c + d)
right :: (MorphChoice a, ObjectSum a d b, ObjectSum a d c) => a b c -> a (d + b) (d + c)
(+++) :: (MorphChoice a, ObjectSum a b b', ObjectSum a c c') => a b c -> a b' c' -> a (b + b') (c + c')

-- | Dual to <a>PreArrow</a>, this class deals with the vacuous initial
--   (zero) objects, but also more usefully with choices / sums. This
--   represents the most part of <a>ArrowChoice</a>.
class MorphChoice k => PreArrChoice k
(|||) :: (PreArrChoice k, ObjectSum k b b', Object k c) => k b c -> k b' c -> k (b + b') c
initial :: (PreArrChoice k, Object k b) => k (ZeroObject k) b
coFst :: (PreArrChoice k, ObjectSum k a b) => k a (a + b)
coSnd :: (PreArrChoice k, ObjectSum k a b) => k b (a + b)

-- | Like in arithmetics, the distributive law <tt>a ⋅ (b + c) ≈ (a ⋅ b) +
--   (a ⋅ c)</tt> holds for Haskell types – in the usual isomorphism sense.
--   But like many such isomorphisms that are trivial to inline in
--   <i>Hask</i>, this is not necessarily the case for general categories.
class (PreArrow k, PreArrChoice k) => SPDistribute k
distribute :: (SPDistribute k, ObjectSum k (a, b) (a, c), ObjectPair k a (b + c), ObjectSum k b c, PairObjects k a b, PairObjects k a c) => k (a, b + c) ((a, b) + (a, c))
unDistribute :: (SPDistribute k, ObjectSum k (a, b) (a, c), ObjectPair k a (b + c), ObjectSum k b c, PairObjects k a b, PairObjects k a c) => k ((a, b) + (a, c)) (a, b + c)
boolAsSwitch :: (SPDistribute k, ObjectSum k a a, ObjectPair k Bool a) => k (Bool, a) (a + a)
boolFromSwitch :: (SPDistribute k, ObjectSum k a a, ObjectPair k Bool a) => k (a + a) (Bool, a)

-- | Many categories have as morphisms essentially <i>functions with extra
--   properties</i>: group homomorphisms, linear maps, continuous
--   functions...
--   
--   It makes sense to generalise the notion of function application to
--   these morphisms; we can't do that for the simple juxtaposition writing
--   <tt>f x</tt>, but it is possible for the function-application operator
--   <tt>$</tt>.
--   
--   This is particularly useful for <a>ConstrainedCategory</a> versions of
--   Hask, where after all the morphisms are <i>nothing but functions</i>.
type Function f = EnhancedCat (->) f
($) :: (Function f, Object f a, Object f b) => f a b -> a -> b
(>>>) :: (Category k, Object k a, Object k b, Object k c) => k a b -> k b c -> k a c
(<<<) :: (Category k, Object k a, Object k b, Object k c) => k b c -> k a b -> k a c
class (Morphism k, HasAgent k) => CartesianAgent k
alg1to2 :: (CartesianAgent k, Object k a, ObjectPair k b c) => (forall q. Object k q => AgentVal k q a -> (AgentVal k q b, AgentVal k q c)) -> k a (b, c)
alg2to1 :: (CartesianAgent k, ObjectPair k a b, Object k c) => (forall q. Object k q => AgentVal k q a -> AgentVal k q b -> AgentVal k q c) -> k (a, b) c
alg2to2 :: (CartesianAgent k, ObjectPair k a b, ObjectPair k c d) => (forall q. Object k q => AgentVal k q a -> AgentVal k q b -> (AgentVal k q c, AgentVal k q d)) -> k (a, b) (c, d)
genericAgentCombine :: (HasAgent k, PreArrow k, Object k a, ObjectPair k b c, Object k d) => k (b, c) d -> GenericAgent k a b -> GenericAgent k a c -> GenericAgent k a d
genericUnit :: (PreArrow k, HasAgent k, Object k a) => GenericAgent k a (UnitObject k)
genericAlg1to2 :: (PreArrow k, u ~ UnitObject k, Object k a, ObjectPair k b c) => (forall q. Object k q => GenericAgent k q a -> (GenericAgent k q b, GenericAgent k q c)) -> k a (b, c)
genericAlg2to1 :: (PreArrow k, u ~ UnitObject k, ObjectPair k a u, ObjectPair k a b, ObjectPair k b u, ObjectPair k b a) => (forall q. Object k q => GenericAgent k q a -> GenericAgent k q b -> GenericAgent k q c) -> k (a, b) c
genericAlg2to2 :: (PreArrow k, u ~ UnitObject k, ObjectPair k a u, ObjectPair k a b, ObjectPair k c d, ObjectPair k b u, ObjectPair k b a) => (forall q. Object k q => GenericAgent k q a -> GenericAgent k q b -> (GenericAgent k q c, GenericAgent k q d)) -> k (a, b) (c, d)
class (HasAgent k, AgentVal k a x ~ p a x) => PointAgent p k a x | p -> k
point :: (PointAgent p k a x, Object k a, Object k x) => x -> p a x
genericPoint :: (WellPointed k, Object k a, ObjectPoint k x) => x -> GenericAgent k a x

-- | Basically <a>ifThenElse</a> with inverted argument order, and
--   "morphismised" arguments.
choose :: (Arrow f (->), Function f, Object f Bool, Object f a) => f (UnitObject f) a -> f (UnitObject f) a -> f Bool a
ifThenElse :: (EnhancedCat f (->), Function f, Object f Bool, Object f a, Object f (f a a), Object f (f a (f a a))) => Bool `f` (a `f` (a `f` a))
instance (SPDistribute k, o (ZeroObject k), o (UnitObject k)) => SPDistribute (ConstrainedCategory k o)
instance (PreArrChoice k, o (ZeroObject k)) => PreArrChoice (ConstrainedCategory k o)
instance (MorphChoice k, o (ZeroObject k)) => MorphChoice (ConstrainedCategory k o)
instance (Arrow a k, o (UnitObject a)) => EnhancedCat (ConstrainedCategory a o) k
instance (WellPointed a, o (UnitObject a)) => WellPointed (ConstrainedCategory a o)
instance (PreArrow a, o (UnitObject a)) => PreArrow (ConstrainedCategory a o)
instance (Morphism a, o (UnitObject a)) => Morphism (ConstrainedCategory a o)
instance WellPointed (->)
instance SPDistribute (->)
instance PreArrChoice (->)
instance PreArrow (->)
instance MorphChoice (->)
instance Morphism (->)
instance Function f => EnhancedCat (->) (ConstrainedCategory f o)
instance Category k => EnhancedCat k k
instance (SPDistribute k, ObjectSum k a a, ObjectPair k Bool a) => Isomorphic k (a + a) (Bool, a)
instance (SPDistribute k, ObjectSum k a a, ObjectPair k Bool a) => Isomorphic k (Bool, a) (a + a)
instance (SPDistribute k, ObjectSum k (a, b) (a, c), ObjectPair k a (b + c), ObjectSum k b c, PairObjects k a b, PairObjects k a c) => Isomorphic k ((a, b) + (a, c)) (a, b + c)
instance (SPDistribute k, ObjectSum k (a, b) (a, c), ObjectPair k a (b + c), ObjectSum k b c, PairObjects k a b, PairObjects k a c) => Isomorphic k (a, b + c) ((a, b) + (a, c))


module Control.Applicative.Constrained
class (Functor f r t, Cartesian r, Cartesian t) => Monoidal f r t
pureUnit :: Monoidal f r t => UnitObject t `t` f (UnitObject r)
fzipWith :: (Monoidal f r t, ObjectPair r a b, Object r c, ObjectPair t (f a) (f b), Object t (f c)) => r (a, b) c -> t (f a, f b) (f c)
class (Monoidal f r t, Curry r, Curry t) => Applicative f r t where (<*>) = curry (fzipWith $ uncurry id)
pure :: (Applicative f r t, Object r a, Object t (f a)) => a `t` f a
(<*>) :: (Applicative f r t, ObjectMorphism r a b, ObjectMorphism t (f a) (f b), Object t (t (f a) (f b)), ObjectPair r (r a b) a, ObjectPair t (f (r a b)) (f a), Object r a, Object r b) => f (r a b) `t` t (f a) (f b)
constrainedFZipWith :: (Category r, Category t, o a, o b, o (a, b), o c, o (f a, f b), o (f c)) => (r (a, b) c -> t (f a, f b) (f c)) -> ConstrainedCategory r o (a, b) c -> ConstrainedCategory t o (f a, f b) (f c)
constPure :: (WellPointed r, Monoidal f r t, ObjectPoint r a, Object t (f a)) => a -> t (UnitObject t) (f a)
fzip :: (Monoidal f r t, ObjectPair r a b, ObjectPair t (f a) (f b), Object t (f (a, b))) => t (f a, f b) (f (a, b))
(<**>) :: (Applicative f r (->), ObjectMorphism r a b, ObjectPair r (r a b) a) => f a -> f (r a b) -> f b
liftA :: (Applicative f r t, Object r a, Object r b, Object t (f a), Object t (f b)) => a `r` b -> f a `t` f b
liftA2 :: (Applicative f r t, Object r c, ObjectMorphism r b c, Object t (f c), ObjectMorphism t (f b) (f c), ObjectPair r a b, ObjectPair t (f a) (f b)) => a `r` (b `r` c) -> f a `t` (f b `t` f c)
liftA3 :: (Applicative f r t, Object r c, Object r d, ObjectMorphism r c d, ObjectMorphism r b (c `r` d), Object r (r c d), ObjectPair r a b, ObjectPair r (r c d) c, Object t (f c), Object t (f d), Object t (f a, f b), ObjectMorphism t (f c) (f d), ObjectMorphism t (f b) (t (f c) (f d)), Object t (t (f c) (f d)), ObjectPair t (f a) (f b), ObjectPair t (t (f c) (f d)) (f c), ObjectPair t (f (r c d)) (f c)) => a `r` (b `r` (c `r` d)) -> f a `t` (f b `t` (f c `t` f d))
instance Applicative f => Applicative f (->) (->)
instance Applicative f => Monoidal f (->) (->)


module Data.Foldable.Constrained
class Functor t k l => Foldable t k l
ffoldl :: (Foldable t k l, ObjectPair k a b, ObjectPair l a (t b)) => k (a, b) a -> l (a, t b) a
foldMap :: (Foldable t k l, Object k a, Object l (t a), Monoid m, Object k m, Object l m) => (a `k` m) -> t a `l` m
fold :: (Foldable t k k, Monoid m, Object k m, Object k (t m)) => t m `k` m

-- | Despite the ridiculous-looking signature, this is in fact equivalent
--   to <a>traverse_</a> within Hask.
traverse_ :: (Foldable t k l, PreArrow k, PreArrow l, Monoidal f l l, Monoidal f k k, ObjectPair l (f ul) (t a), ObjectPair k (f ul) a, ObjectPair l ul (t a), ObjectPair l (t a) ul, ObjectPair k b ul, Object k (f b), ObjectPair k (f ul) (f ul), ObjectPair k ul ul, uk ~ UnitObject k, ul ~ UnitObject l, uk ~ ul) => a `k` f b -> t a `l` f ul

-- | The distinction between <a>mapM_</a> and <a>traverse_</a> doesn't
--   really make sense on grounds of <a>Monoidal</a> / <a>Applicative</a>
--   vs <a>Monad</a>, but it has in fact some benefits to restrict this to
--   endofunctors, to make the constraint list at least somewhat shorter.
mapM_ :: (Foldable t k k, WellPointed k, Monoidal f k k, u ~ UnitObject k, ObjectPair k (f u) (t a), ObjectPair k (f u) a, ObjectPair k u (t a), ObjectPair k (t a) u, ObjectPair k (f u) (f u), ObjectPair k u u, ObjectPair k b u, Object k (f b)) => a `k` f b -> t a `k` f u
forM_ :: (Foldable t k l, Monoidal f l l, Monoidal f k k, Function l, Arrow k (->), Arrow l (->), ul ~ UnitObject l, uk ~ UnitObject k, uk ~ ul, ObjectPair l ul ul, ObjectPair l (f ul) (f ul), ObjectPair l (f ul) (t a), ObjectPair l ul (t a), ObjectPair l (t a) ul, ObjectPair l (f ul) a, ObjectPair k b (f b), ObjectPair k b ul, ObjectPair k uk uk, ObjectPair k (f uk) a, ObjectPair k (f uk) (f uk)) => t a -> a `k` f b -> f uk
sequence_ :: (Foldable t k l, Arrow k (->), Arrow l (->), uk ~ UnitObject k, ul ~ UnitObject l, uk ~ ul, Monoidal m k k, Monoidal m l l, ObjectPair k a uk, ObjectPair k (t (m a)) uk, ObjectPair k uk uk, ObjectPair k (m uk) (m uk), ObjectPair k (t (m a)) ul, ObjectPair l (m ul) (t (m a)), ObjectPair l ul (t (m a)), ObjectPair l (m uk) (t (m a)), ObjectPair l (t (m a)) ul, ObjectPair k (m uk) (m a)) => t (m a) `l` m uk
concatMap :: (Foldable f k l, Object k a, Object k [b], Object l (f a), Object l [b]) => a `k` [b] -> f a `l` [b]
instance (Foldable f s t, WellPointed s, WellPointed t, Functor f (ConstrainedCategory s o) (ConstrainedCategory t o)) => Foldable f (ConstrainedCategory s o) (ConstrainedCategory t o)
instance Foldable Maybe (->) (->)
instance Foldable [] (->) (->)
instance (Monoidal f k k, Function k, u ~ UnitObject k, Monoid u, ObjectPair k u u, ObjectPair k (f u) (f u), Object k (f u, f u)) => Monoid (Monoidal_ k k f u)
instance (Category k, Object k a) => Monoid (Endo' k a)


module Data.Traversable.Constrained
class (Category k, Category l, Functor s l l, Functor t k k) => Traversable s t k l | s k l -> t, t k l -> s, s t k -> l, s t l -> k
traverse :: (Traversable s t k l, Monoidal f k l, Object l a, Object l (s a), ObjectPair k b (t b), ObjectPair l (f b) (f (t b)), ObjectPoint k (t b)) => a `l` f b -> s a `l` f (t b)
sequence :: (Traversable t t k k, Monoidal f k k, ObjectPair k a (t a), ObjectPair k (f a) (f (t a)), Object k (t (f a)), ObjectPoint k (t a)) => t (f a) `k` f (t a)

-- | <a>traverse</a>, restricted to endofunctors.
mapM :: (Traversable t t k k, Monoidal m k k, Object k a, Object k (t a), ObjectPair k b (t b), ObjectPair k (m b) (m (t b)), ObjectPoint k (t b)) => a `k` m b -> t a `k` m (t b)

-- | Flipped version of <a>traverse</a> / <a>mapM</a>.
forM :: (Traversable s t k l, Monoidal m k l, Function l, Object k b, Object k (t b), ObjectPair k b (t b), Object l a, Object l (s a), ObjectPair l (m b) (m (t b)), ObjectPoint k (t b)) => s a -> (a `l` m b) -> m (t b)
instance (Arrow k (->), WellPointed k, Function k, Functor Maybe k k) => Traversable Maybe Maybe k k
instance (Arrow k (->), WellPointed k, Function k, Functor [] k k) => Traversable [] [] k k


module Control.Monad.Constrained
class (Applicative m k k, Object k (m (UnitObject k)), Object k (m (m (UnitObject k)))) => Monad m k
join :: (Monad m k, Object k a, Object k (m a), Object k (m (m a))) => m (m a) `k` m a

-- | This is monomorphic in the category <i>Hask</i>, thus exactly the same
--   as <a>return</a> from the standard prelude. This allows writing
--   expressions like <tt><a>return</a> <a>$</a> case x of ...</tt>, which
--   would always be ambiguous with the more general signature <tt>Monad m
--   k =&gt; k a (m a)</tt>.
--   
--   Use <a>pure</a> when you want to "return" in categories other than
--   <tt>(-&gt;)</tt>; this always works since <a>Applicative</a> is a
--   superclass of <a>Monad</a>.
return :: Monad m (->) => a -> m a
(>>=) :: (Function f, Monad m f, Object f a, Object f b, Object f (m a), Object f (m b), Object f (m (m b))) => m a -> f a (m b) -> m b
(=<<) :: (Monad m k, Object k a, Object k b, Object k (m a), Object k (m b), Object k (m (m b))) => k a (m b) -> k (m a) (m b)
(>>) :: (WellPointed k, Monad m k, ObjectPair k b (UnitObject k), ObjectPair k (m b) (UnitObject k), ObjectPair k (UnitObject k) (m b), ObjectPair k b a, ObjectPair k a b, Object k (m (a, b)), ObjectPair k (m a) (m b), ObjectPoint k (m a)) => m a -> k (m b) (m b)
(<<) :: (Monad m k, WellPointed k, Object k a, Object k b, Object k (m a), ObjectPoint k (m b), Object k (m (m b))) => m b -> k (m a) (m b)
(>=>) :: (Monad m k, Object k a, Object k b, Object k c, Object k (m b), Object k (m c), Object k (m (m c))) => a `k` m b -> b `k` m c -> a `k` m c
(<=<) :: (Monad m k, Object k a, Object k b, Object k c, Object k (m b), Object k (m c), Object k (m (m c))) => b `k` m c -> a `k` m b -> a `k` m c
newtype Kleisli m k a b
Kleisli :: k a (m b) -> Kleisli m k a b
runKleisli :: Kleisli m k a b -> k a (m b)

-- | <a>MonadPlus</a> cannot be adapted quite analogously to <a>Monad</a>,
--   since <a>mzero</a> is just a value with no way to indicate its
--   morphism category. The current implementation is probably not ideal,
--   mainly written to give <a>MonadFail</a> (<a>fail</a> being needed for
--   <tt>RebindableSyntax</tt>-<tt>do</tt> notation) a mathematically
--   reasonable superclass.
--   
--   Consider these classes provisorial, avoid relying on them explicitly.
class Monad m k => MonadZero m k
fmzero :: (MonadZero m k, Object k a, Object k (m a)) => UnitObject k `k` m a
mzero :: MonadZero m (->) => m a
class MonadZero m k => MonadPlus m k
fmplus :: (MonadPlus m k, ObjectPair k (m a) (m a)) => k (m a, m a) (m a)
mplus :: MonadPlus m (->) => m a -> m a -> m a
class MonadPlus m k => MonadFail m k
fail :: (MonadFail m k, Object k (m a)) => k String (m a)

-- | <a>traverse</a>, restricted to endofunctors.
mapM :: (Traversable t t k k, Monoidal m k k, Object k a, Object k (t a), ObjectPair k b (t b), ObjectPair k (m b) (m (t b)), ObjectPoint k (t b)) => a `k` m b -> t a `k` m (t b)

-- | The distinction between <a>mapM_</a> and <a>traverse_</a> doesn't
--   really make sense on grounds of <a>Monoidal</a> / <a>Applicative</a>
--   vs <a>Monad</a>, but it has in fact some benefits to restrict this to
--   endofunctors, to make the constraint list at least somewhat shorter.
mapM_ :: (Foldable t k k, WellPointed k, Monoidal f k k, u ~ UnitObject k, ObjectPair k (f u) (t a), ObjectPair k (f u) a, ObjectPair k u (t a), ObjectPair k (t a) u, ObjectPair k (f u) (f u), ObjectPair k u u, ObjectPair k b u, Object k (f b)) => a `k` f b -> t a `k` f u

-- | Flipped version of <a>traverse</a> / <a>mapM</a>.
forM :: (Traversable s t k l, Monoidal m k l, Function l, Object k b, Object k (t b), ObjectPair k b (t b), Object l a, Object l (s a), ObjectPair l (m b) (m (t b)), ObjectPoint k (t b)) => s a -> (a `l` m b) -> m (t b)
forM_ :: (Foldable t k l, Monoidal f l l, Monoidal f k k, Function l, Arrow k (->), Arrow l (->), ul ~ UnitObject l, uk ~ UnitObject k, uk ~ ul, ObjectPair l ul ul, ObjectPair l (f ul) (f ul), ObjectPair l (f ul) (t a), ObjectPair l ul (t a), ObjectPair l (t a) ul, ObjectPair l (f ul) a, ObjectPair k b (f b), ObjectPair k b ul, ObjectPair k uk uk, ObjectPair k (f uk) a, ObjectPair k (f uk) (f uk)) => t a -> a `k` f b -> f uk
sequence :: (Traversable t t k k, Monoidal f k k, ObjectPair k a (t a), ObjectPair k (f a) (f (t a)), Object k (t (f a)), ObjectPoint k (t a)) => t (f a) `k` f (t a)
sequence_ :: (Foldable t k l, Arrow k (->), Arrow l (->), uk ~ UnitObject k, ul ~ UnitObject l, uk ~ ul, Monoidal m k k, Monoidal m l l, ObjectPair k a uk, ObjectPair k (t (m a)) uk, ObjectPair k uk uk, ObjectPair k (m uk) (m uk), ObjectPair k (t (m a)) ul, ObjectPair l (m ul) (t (m a)), ObjectPair l ul (t (m a)), ObjectPair l (m uk) (t (m a)), ObjectPair l (t (m a)) ul, ObjectPair k (m uk) (m a)) => t (m a) `l` m uk
guard :: (MonadPlus m k, Arrow k (->), Function k, UnitObject k ~ (), Object k Bool) => Bool `k` m ()
when :: (Monad m k, PreArrow k, u ~ UnitObject k, ObjectPair k (m u) u) => Bool -> m u `k` m u
unless :: (Monad m k, PreArrow k, u ~ UnitObject k, ObjectPair k (m u) u) => Bool -> m u `k` m u
forever :: (Monad m k, Function k, Arrow k (->), Object k a, Object k b, Object k (m a), Object k (m (m a)), ObjectPoint k (m b), Object k (m (m b))) => m a `k` m b
void :: (Monad m k, PreArrow k, Object k a, Object k (m a), ObjectPair k a u, u ~ UnitObject k) => m a `k` m (UnitObject k)
instance (Monad m k, Arrow k (->), Function k, PreArrChoice k, Object k (m (ZeroObject k)), Object k (m (m (ZeroObject k)))) => PreArrChoice (Kleisli m k)
instance (Monad m k, Arrow k (->), Function k, PreArrChoice k, Object k (m (ZeroObject k)), Object k (m (m (ZeroObject k)))) => MorphChoice (Kleisli m k)
instance (Monad m a, WellPointed a, ObjectPoint a (m (UnitObject a))) => WellPointed (Kleisli m a)
instance (SPDistribute k, Monad m k, PreArrow (Kleisli m k), PreArrChoice (Kleisli m k)) => SPDistribute (Kleisli m k)
instance (Monad m a, PreArrow a, Curry a) => PreArrow (Kleisli m a)
instance (Monad m a, Morphism a, Curry a) => Morphism (Kleisli m a)
instance (Monad m a, Arrow a q, Cartesian a) => EnhancedCat (Kleisli m a) q
instance (Monad m a, Arrow a (->), Function a) => Curry (Kleisli m a)
instance (Monad m k, CoCartesian k, Object k (m (ZeroObject k)), Object k (m (m (ZeroObject k)))) => CoCartesian (Kleisli m k)
instance (Monad m a, Cartesian a) => Cartesian (Kleisli m a)
instance Monad m k => Category (Kleisli m k)
instance (MonadPlus m, Applicative m) => MonadFail m (->)
instance (MonadPlus m, Applicative m) => MonadPlus m (->)
instance (MonadPlus m, Applicative m) => MonadZero m (->)
instance (Applicative m, Monad m) => Monad m (->)


module Control.Category.Constrained.Prelude
