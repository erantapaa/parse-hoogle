-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Second-order, tiered, constrained, linear conditional random fields
--   
@package crf-chain2-tiers
@version 0.2.4

module Data.CRF.Chain2.Tiers.Array

-- | An unboxed array implemented in terms of an unboxed vector.
data Array i a

-- | Construct array with a default dummy value.
mkArray :: (Bounds i, Unbox a) => a -> [(i, a)] -> Array i a

-- | Deconstruct the array.
unArray :: (Bounds i, Unbox a) => Array i a -> [(i, a)]
(!?) :: (Ix i, Unbox a) => Array i a -> i -> Maybe a

-- | An extended Ix class.
class Ix i => Bounds i
lower :: Bounds i => i -> i -> i
upper :: Bounds i => i -> i -> i
instance Bounds i => Bounds (i, i, i)
instance Bounds i => Bounds (i, i)
instance Bounds Int16
instance (Binary i, Binary a, Unbox a) => Binary (Array i a)


-- | Internal core data types.
module Data.CRF.Chain2.Tiers.Dataset.Internal

-- | An observation.
newtype Ob
Ob :: Int32 -> Ob
_unOb :: Ob -> Int32

-- | Smart observation constructor.
mkOb :: Int -> Ob

-- | Deconstract observation.
unOb :: Ob -> Int

-- | An atomic label.
newtype Lb
Lb :: Int16 -> Lb
_unLb :: Lb -> Int16

-- | Smart label constructor.
mkLb :: Int -> Lb

-- | Deconstract label.
unLb :: Lb -> Int

-- | A feature index. To every model feature a unique index is assigned.
newtype FeatIx
FeatIx :: Int32 -> FeatIx
_unFeatIx :: FeatIx -> Int32

-- | Smart feature index constructor.
mkFeatIx :: Int -> FeatIx

-- | Deconstract feature index.
unFeatIx :: FeatIx -> Int

-- | An index of the label.
type CbIx = Int

-- | A complex label is a vector of atomic labels.
newtype Cb
Cb :: Vector Lb -> Cb
_unCb :: Cb -> Vector Lb

-- | Smart complex label constructor.
mkCb :: [Lb] -> Cb

-- | Deconstract complex label.
unCb :: Cb -> [Lb]

-- | A word is represented by a list of its observations and a list of its
--   potential label interpretations.
data X

-- | Sentence of words.
type Xs = Vector X

-- | Smart <a>X</a> constructor.
mkX :: [Ob] -> [Cb] -> X

-- | List of observations.
unX :: X -> [Ob]

-- | List of potential labels.
unR :: X -> [Cb]

-- | Vector of chosen labels together with corresponding probabilities in
--   log domain.
data Y

-- | Sentence of Y (label choices).
type Ys = Vector Y

-- | Y constructor.
mkY :: [(Cb, Double)] -> Y

-- | Y deconstructor symetric to mkY.
unY :: Y -> [(Cb, LogFloat)]

-- | Potential label at the given position.
lbAt :: X -> CbIx -> Cb

-- | Potential label at the given position and at the given index. Return
--   Nothing for positions outside the domain.
lbOn :: Xs -> Int -> CbIx -> Maybe Cb

-- | Number of potential labels at the given position of the sentence.
--   Function extended to indices outside the positions' domain.
lbNum :: Xs -> Int -> Int

-- | List of label indices at the given position. Function extended to
--   indices outside the positions' domain.
lbIxs :: Xs -> Int -> [CbIx]
instance Show Cb
instance Eq Cb
instance Ord Cb
instance Binary Cb
instance Show X
instance Eq X
instance Ord X
instance Show Y
instance Eq Y
instance Ord Y
instance Binary Y
instance Binary X
instance Vector Vector FeatIx
instance MVector MVector FeatIx
instance Unbox FeatIx
instance Show FeatIx
instance Eq FeatIx
instance Ord FeatIx
instance Binary FeatIx
instance IArray UArray FeatIx
instance Vector Vector Lb
instance MVector MVector Lb
instance Unbox Lb
instance Show Lb
instance Eq Lb
instance Ord Lb
instance Binary Lb
instance IArray UArray Lb
instance Num Lb
instance Ix Lb
instance Bounds Lb
instance Vector Vector Ob
instance MVector MVector Ob
instance Unbox Ob
instance Show Ob
instance Eq Ob
instance Ord Ob
instance Binary Ob
instance IArray UArray Ob

module Data.CRF.Chain2.Tiers.Feature

-- | Feature; every feature is associated to a layer with <a>ln</a>
--   identifier.
data Feat

-- | Second-order transition feature.
TFeat3 :: {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Int -> Feat
x1 :: Feat -> {-# UNPACK #-} !Lb
x2 :: Feat -> {-# UNPACK #-} !Lb
x3 :: Feat -> {-# UNPACK #-} !Lb
ln :: Feat -> {-# UNPACK #-} !Int

-- | First-order transition feature.
TFeat2 :: {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Int -> Feat
x1 :: Feat -> {-# UNPACK #-} !Lb
x2 :: Feat -> {-# UNPACK #-} !Lb
ln :: Feat -> {-# UNPACK #-} !Int

-- | Zero-order transition feature.
TFeat1 :: {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Int -> Feat
x1 :: Feat -> {-# UNPACK #-} !Lb
ln :: Feat -> {-# UNPACK #-} !Int

-- | Observation feature.
OFeat :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Int -> Feat
ob :: Feat -> {-# UNPACK #-} !Ob
x1 :: Feat -> {-# UNPACK #-} !Lb
ln :: Feat -> {-# UNPACK #-} !Int

-- | Generate observation features.
obFeats :: Ob -> Cb -> [Feat]

-- | Generate zero-order transition features.
trFeats1 :: Cb -> [Feat]

-- | Generate first-order transition features.
trFeats2 :: Cb -> Cb -> [Feat]

-- | Generate second-order transition features.
trFeats3 :: Cb -> Cb -> Cb -> [Feat]

-- | Features present in the dataset element together with corresponding
--   occurence probabilities.
presentFeats :: Xs -> Ys -> [(Feat, LogFloat)]

-- | Features hidden in the dataset element.
hiddenFeats :: Xs -> [Feat]

-- | Observation features on a given position and with respect to a given
--   label (determined by idenex).
obFeatsOn :: Xs -> Int -> CbIx -> [Feat]

-- | Transition features on a given position and with respect to a given
--   labels (determined by indexes).
trFeatsOn :: Xs -> Int -> CbIx -> CbIx -> CbIx -> [Feat]

-- | A feature selection function type.
type FeatSel = Xs -> Ys -> [Feat]

-- | The <a>presentFeats</a> adapted to fit feature selection specs.
selectPresent :: FeatSel

-- | The <a>hiddenFeats</a> adapted to fit feature selection specs.
selectHidden :: FeatSel
instance Show Feat
instance Eq Feat
instance Ord Feat
instance Binary Feat

module Data.CRF.Chain2.Tiers.Model

-- | Internal model data.
data Model
Model :: Vector Double -> FeatMap -> Model
values :: Model -> Vector Double
featMap :: Model -> FeatMap

-- | Construct model from a dataset given a feature selection function.
mkModel :: FeatSel -> [(Xs, Ys)] -> Model

-- | Construct model from a feature set. All values will be set to 1 in log
--   domain.
fromSet :: Set Feat -> Model

-- | Construct model from a (feature -&gt; value) map.
fromMap :: Map Feat LogFloat -> Model

-- | Convert model to a (feature -&gt; value) map.
toMap :: Model -> Map Feat LogFloat

-- | Potential assigned to the feature -- exponential of the corresonding
--   parameter.
phi :: Model -> Feat -> LogFloat

-- | Index of a feature.
index :: Model -> Feat -> Maybe FeatIx

-- | Observation potential on a given position and a given label
--   (identified by index).
onWord :: Model -> Xs -> Int -> CbIx -> LogFloat

-- | Transition potential on a given position and a given labels
--   (identified by indexes).
onTransition :: Model -> Xs -> Int -> CbIx -> CbIx -> CbIx -> LogFloat
instance Binary Model
instance Binary LayerMap
instance Binary OMap

module Data.CRF.Chain2.Tiers.Inference

-- | Find the most probable label sequence satisfying the constraints
--   imposed over label values.
tag :: Model -> Xs -> [Cb]

-- | Tag potential labels with marginal probabilities.
marginals :: Model -> Xs -> [[LogFloat]]

-- | A list of features (represented by feature indices) defined within the
--   context of the sentence accompanied by expected probabilities
--   determined on the basis of the model.
--   
--   One feature can occur multiple times in the output list.
expectedFeatures :: Model -> Xs -> [(Feat, LogFloat)]

-- | Compute the accuracy of the model with respect to the labeled dataset.
accuracy :: Model -> [(Xs, Ys)] -> Double

-- | Normalization factor computed for the Xs sentence using the backward
--   computation.
zx :: Model -> Xs -> LogFloat

-- | Normalization factor computed for the Xs sentence using the forward
--   computation.
zx' :: Model -> Xs -> LogFloat


-- | External data representation.
module Data.CRF.Chain2.Tiers.Dataset.External

-- | A word consists of a set of observations and a set of potential
--   labels.
data Word a b

-- | A word constructor which checks non-emptiness of the potential set of
--   labels.
mkWord :: Set a -> Set [b] -> Word a b

-- | A sentence of words.
type Sent a b = [Word a b]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Prob a

-- | Construct the probability distribution.
mkProb :: Ord a => [(a, Double)] -> Prob a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels. We assume that every label from the distribution
--   domain is a member of the set of potential labels corresponding to the
--   word. TODO: Ensure the assumption using the smart constructor.
type WordL a b = (Word a b, Prob [b])

-- | A sentence of labeled words.
type SentL a b = [WordL a b]
instance (Show a, Show b) => Show (Word a b)
instance (Eq a, Eq b) => Eq (Word a b)
instance (Ord a, Ord b) => Ord (Word a b)
instance Show a => Show (Prob a)
instance Eq a => Eq (Prob a)
instance Ord a => Ord (Prob a)

module Data.CRF.Chain2.Tiers.Dataset.Codec

-- | Codec internal data. The first component is used to encode
--   observations of type a, the second one is used to encode labels of
--   type [b].
type Codec a b = (AtomCodec a, Vector (AtomCodec (Maybe b)))

-- | Type synonym for the codec monad.
type CodecM a b c = Codec (Codec a b) c

-- | The maximum internal observation included in the codec.
obMax :: Codec a b -> Ob

-- | The maximum internal labels included in the codec.
lbMax :: Codec a b -> [Lb]

-- | Encode the word and update the codec.
encodeWord'Cu :: (Ord a, Ord b) => Word a b -> CodecM a b X

-- | Encode the word and do *not* update the codec.
encodeWord'Cn :: (Ord a, Ord b) => Word a b -> CodecM a b X

-- | Encode the sentence and update the codec.
encodeSent'Cu :: (Ord a, Ord b) => Sent a b -> CodecM a b Xs

-- | Encode the sentence and do *not* update the codec.
encodeSent'Cn :: (Ord a, Ord b) => Sent a b -> CodecM a b Xs

-- | Encode the sentence using the given codec.
encodeSent :: (Ord a, Ord b) => Codec a b -> Sent a b -> Xs

-- | Encode the labeled word and update the codec.
encodeWordL'Cu :: (Ord a, Ord b) => WordL a b -> CodecM a b (X, Y)

-- | Encodec the labeled word and do *not* update the codec.
encodeWordL'Cn :: (Ord a, Ord b) => WordL a b -> CodecM a b (X, Y)

-- | Encode the labeled sentence and update the codec.
encodeSentL'Cu :: (Ord a, Ord b) => SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence and do *not* update the codec. Substitute
--   the default label for any label not present in the codec.
encodeSentL'Cn :: (Ord a, Ord b) => SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence with the given codec. Substitute the
--   default label for any label not present in the codec.
encodeSentL :: (Ord a, Ord b) => Codec a b -> SentL a b -> (Xs, Ys)

-- | Decode the label.
decodeLabel :: Ord b => Codec a b -> Cb -> Maybe [b]

-- | Decode the sequence of labels.
decodeLabels :: Ord b => Codec a b -> [Cb] -> [Maybe [b]]

-- | Create codec on the basis of the labeled dataset.
mkCodec :: (Ord a, Ord b) => Int -> [SentL a b] -> Codec a b

-- | Encode the dataset with the codec.
encodeData :: (Ord a, Ord b) => Codec a b -> [Sent a b] -> [Xs]

-- | Encode the labeled dataset using the codec. Substitute the default
--   label for any label not present in the codec.
encodeDataL :: (Ord a, Ord b) => Codec a b -> [SentL a b] -> [(Xs, Ys)]

-- | Return the label when <a>Just</a> or one of the unknown values when
--   <a>Nothing</a>.
unJust :: Ord b => Codec a b -> Word a b -> Maybe [b] -> [b]

module Data.CRF.Chain2.Tiers

-- | CRF model data.
data CRF a b
CRF :: Int -> Codec a b -> Model -> CRF a b
numOfLayers :: CRF a b -> Int
codec :: CRF a b -> Codec a b
model :: CRF a b -> Model

-- | Compute size (number of features) of the model.
size :: CRF a b -> Int

-- | Discard model features with absolute values (in log-domain) lower than
--   the given threshold.
prune :: Double -> CRF a b -> CRF a b

-- | Train the CRF using the stochastic gradient descent method.
train :: (Ord a, Ord b) => Int -> FeatSel -> SgdArgs -> Bool -> IO [SentL a b] -> IO [SentL a b] -> IO (CRF a b)

-- | Re-train the CRF using the stochastic gradient descent method.
reTrain :: (Ord a, Ord b) => CRF a b -> SgdArgs -> Bool -> IO [SentL a b] -> IO [SentL a b] -> IO (CRF a b)

-- | Find the most probable label sequence.
tag :: (Ord a, Ord b) => CRF a b -> Sent a b -> [[b]]

-- | Tag labels with marginal probabilities.
marginals :: (Ord a, Ord b) => CRF a b -> Sent a b -> [[Double]]
instance (Ord a, Ord b, Binary a, Binary b) => Binary (CRF a b)
