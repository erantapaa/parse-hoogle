-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad transformers for multi-prompt delimited control
--   
--   Oleg Kiselyov's three new monad transformers for multi-prompt
--   delimited control (released with his permission)
--   
--   This library implements the superset of the interface described in *
--   <i>A Monadic Framework for Delimited Continuations</i>, R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a>
--   
--   This library's <a>Control.Monad.CC.CCCxe</a> is derived as a CPS
--   version of <a>http://hackage.haskell.org/package/CC-delcont-exc</a>'s
--   Control.Monad.CC.CCExc. <a>Control.Monad.CC.CCCxe</a> is sometimes
--   more efficient; it is always less perspicuous. Both libraries provide
--   the identical interface and are interchangeable. It seems that
--   CC-delcont-exc's Control.Monad.CC.CCExc is faster at delimited control
--   but imposes more overhead on the conventional code;
--   <a>Control.Monad.CC.CCCxe</a> is dual. It pays to use
--   <a>Control.Monad.CC.CCCxe</a> in code with long stretches of
--   determinism punctuated by fits and restarts.
--   
--   See the original article at
--   <a>http://okmij.org/ftp/continuations/implementations.html#CC-monads</a>
--   for more information.
--   
--   This package split multi-prompt delimited control from
--   <a>http://hackage.haskell.org/package/liboleg</a> for usability.
@package CC-delcont-cxe
@version 0.1.0.2


-- | This file is the CPS version of
--   <a>http://hackage.haskell.org/package/CC-delcont-exc</a>'s
--   Control.Monad.CC.CCExc, implementing the identical interface
--   
--   Monad transformer for multi-prompt delimited control It implements the
--   superset of the interface described in
--   
--   <ul>
--   <li>"<i>A Monadic Framework for Delimited Continuations</i>", R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a></li>
--   </ul>
--   
--   The first main difference is the use of generalized prompts, which do
--   not have to be created with new_prompt and therefore can be defined at
--   top level. That removes one of the main practical drawbacks of Dybvig
--   et al implementations: the necessity to carry around the prompts
--   throughout all the code.
--   
--   The delimited continuation monad is parameterized by the flavor of
--   generalized prompts. The end of this code defines several flavors; the
--   library users may define their own. User-defined flavors are
--   especially useful when user's code uses a small closed set of
--   answer-types. Flavors PP and PD below are more general, assuming the
--   set of possible answer-types is open and Typeable. If the user wishes
--   to create several distinct prompts with the same answer-types, the
--   user should use the flavor of prompts accepting an integral prompt
--   identifier, such as PD. Prompts of the flavor PD correspond to the
--   prompts in Dybvig, Peyton Jones, Sabry framework. If the user wishes
--   to generate unique prompts, the user should arrange himself for the
--   generation of unique integers (using a state monad, for example). On
--   the other hand, the user can differentiate answer-types using
--   `newtype.' The latter can only produce the set of distinct prompts
--   that is fixed at run-time. Sometimes that is sufficient. There is not
--   need to create a gensym monad then.
--   
--   See Control.Monad.CC.CCExc for further comments about the
--   implementation
module Control.Monad.CC.CCCxe

-- | Delimited-continuation monad transformer It is parameterized by the
--   prompt flavor p The first argument is the regular (success)
--   continuation, the second argument is the bubble, or a resumable
--   exception
data CC p m a

-- | The captured sub-continuation
type SubCont p m a b = CC p m a -> CC p m b

-- | The type of control operator's body
type CCT p m a w = SubCont p m a w -> CC p m w

-- | Generalized prompts for the answer-type w: an injection-projection
--   pair
type Prompt p m w = (forall x. CCT p m x w -> p m x, forall x. p m x -> Maybe (CCT p m x w))
pushPrompt :: Monad m => Prompt p m w -> CC p m w -> CC p m w

-- | Create the initial bubble
takeSubCont :: Monad m => Prompt p m w -> CCT p m x w -> CC p m x

-- | Apply the captured continuation
pushSubCont :: Monad m => SubCont p m a b -> CC p m a -> CC p m b
runCC :: Monad m => CC (p :: (* -> *) -> * -> *) m a -> m a
abortP :: Monad m => Prompt p m w -> CC p m w -> CC p m any
shiftP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
shift0P :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
controlP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a

-- | The extreme case: prompts for the single answer-type w. The monad (CC
--   PS) then is the monad for regular (single-prompt) delimited
--   continuations
data PS w m x
ps :: Prompt (PS w) m w

-- | Prompts for the closed set of answer-types The following prompt flavor
--   P2, for two answer-types w1 and w2, is given as an example. Typically,
--   a programmer would define their own variant data type with variants
--   for the answer-types that occur in their program.
data P2 w1 w2 m x

-- | There are two generalized prompts of the flavor P2
p2L :: Prompt (P2 w1 w2) m w1
p2R :: Prompt (P2 w1 w2) m w2

-- | Prompts for the open set of answer-types
data PP m x
pp :: Typeable w => Prompt PP m w

-- | The same as PP but with the phantom parameter c The parameter is
--   useful to statically enforce various constrains (statically pass some
--   information between shift and reset) The prompt PP is too
--   <tt>dynamic</tt>: all errors are detected dynamically See
--   Generator2.hs for an example
data PM c m x
pm :: Typeable w => Prompt (PM c) m w

-- | Open set of answer types, with an additional distinction (given by
--   integer identifiers) This prompt flavor corresponds to the prompts in
--   the Dybvig, Peyton-Jones, Sabry framework (modulo the Typeable
--   constraint).
data PD m x
newPrompt :: Typeable w => Int -> Prompt PD m w

-- | It is often helpful, for clarity of error messages, to specify the
--   answer-type associated with the prompt explicitly (rather than relying
--   on the type inference to figure that out). The following function is
--   useful for that purpose.
as_prompt_type :: Prompt p m w -> w -> Prompt p m w
instance MonadIO m => MonadIO (CC p m)
instance MonadTrans (CC p)
instance Monad m => Monad (CC p m)
