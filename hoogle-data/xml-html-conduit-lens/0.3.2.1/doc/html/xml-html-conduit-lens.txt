-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optics for xml-conduit and html-conduit
--   
--   Optics for xml-conduit and html-conduit
@package xml-html-conduit-lens
@version 0.3.2.1


-- | Optics Template Haskell could generate, but didn't
module Text.Xml.Lens.LowLevel

-- | A Lens into <a>psDecodeEntities</a>
psDecodeEntities :: Lens' ParseSettings DecodeEntities

-- | A Lens into <a>rsPretty</a>
rsPretty :: Lens' RenderSettings Bool

-- | A Lens into <a>rsNamespaces</a>
rsNamespaces :: Lens' RenderSettings [(Text, Text)]

-- | A Lens into <a>rsAttrOrder</a>
rsAttrOrder :: Lens' RenderSettings (Name -> Map Name Text -> [(Name, Text)])

-- | A Lens into <a>documentPrologue</a>
documentPrologue :: Lens' Document Prologue

-- | A Lens into <a>documentRoot</a>
documentRoot :: Lens' Document Element

-- | A Lens into <a>documentEpilogue</a>
documentEpilogue :: Lens' Document [Miscellaneous]

-- | A Lens into <a>prologueBefore</a>
prologueBefore :: Lens' Prologue [Miscellaneous]

-- | A Lens into <a>prologueDoctype</a>
prologueDoctype :: Lens' Prologue (Maybe Doctype)

-- | A Lens into <a>prologueAfter</a>
prologueAfter :: Lens' Prologue [Miscellaneous]

-- | A Lens into <a>doctypeName</a>
doctypeName :: Lens' Doctype Text

-- | A Lens into <a>doctypeID</a>
doctypeID :: Lens' Doctype (Maybe ExternalID)

-- | A Prism into <a>SystemID</a>
_SystemID :: Prism' ExternalID Text

-- | A Prism into <a>SystemID</a>
_PublicID :: Prism' ExternalID (Text, Text)

-- | A Lens into <a>elementName</a>
elementName :: Lens' Element Name

-- | A Lens into <a>elementAttributes</a>
elementAttributes :: Lens' Element (Map Name Text)

-- | A Lens into <a>elementNodes</a>
elementNodes :: Lens' Element [Node]

-- | A Lens into <a>nameLocalName</a>
nameLocalName :: Lens' Name Text

-- | A Lens into <a>nameNamespace</a>
nameNamespace :: Lens' Name (Maybe Text)

-- | A Lens into <a>namePrefix</a>
namePrefix :: Lens' Name (Maybe Text)

-- | A Lens into <a>instructionTarget</a>
instructionTarget :: Lens' Instruction Text

-- | A Lens into <a>instructionData</a>
instructionData :: Lens' Instruction Text

-- | An Iso into <a>Document</a>
_Document :: Iso' Document (Prologue, Element, [Miscellaneous])

-- | An Iso into <a>Prologue</a>
_Prologue :: Iso' Prologue ([Miscellaneous], Maybe Doctype, [Miscellaneous])

-- | An Iso into <a>Instruction</a>
_Instruction :: Iso' Instruction (Text, Text)

-- | An Iso into <a>Element</a>
_Element :: Iso' Element (Name, Map Name Text, [Node])

-- | An Iso into <a>Name</a>
_Name :: Iso' Name (Text, Maybe Text, Maybe Text)

-- | An Iso into <a>Doctype</a>
_Doctype :: Iso' Doctype (Text, Maybe ExternalID)

-- | A Prism into <a>NodeElement</a>
_NodeElement :: Prism' Node Element

-- | A Prism into <a>NodeContent</a>
_NodeContent :: Prism' Node Text

-- | A Prism into <a>NodeInstruction</a>
_NodeInstruction :: Prism' Node Instruction

-- | A Prism into <a>NodeComment</a>
_NodeComment :: Prism' Node Text

-- | A Prism into <a>MiscComment</a>
_MiscComment :: Prism' Miscellaneous Text

-- | A Prism into <a>MiscInstruction</a>
_MiscInstruction :: Prism' Miscellaneous Instruction
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d


-- | Optics for xml-conduit and html-conduit
module Text.Xml.Lens
data Document :: *

-- | A Traversal into XML document root node
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;foo/&gt;" :: TL.Text) ^? xml.name
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;foo&gt;&lt;bar/&gt;&lt;baz/&gt;&lt;/foo&gt;" :: TL.Text) ^? xml.name
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;foo/&gt;" :: TL.Text) &amp; xml.name .~ "boo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;boo/&gt;"
--   </pre>
xml :: AsXmlDocument t => Traversal' t Element

-- | A Fold into HTML document root node
--   
--   Not every parseable HTML document is a valid XML document:
--   
--   <pre>
--   &gt;&gt;&gt; let quasiXml = "&lt;html&gt;&lt;br&gt;&lt;br&gt;&lt;/html&gt;" :: BL.ByteString
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quasiXml ^.. html...name
--   ["br","br"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quasiXml ^? xml...name
--   Nothing
--   </pre>
html :: AsHtmlDocument t => Fold t Element

-- | An alias for <a>xml</a>
root :: AsXmlDocument t => Traversal' t Element

-- | Fold <a>Element</a> into the XML document
--   
--   Convenience function mostly useful because <tt>xml-conduit</tt> does
--   not provide handy method to convert <a>Element</a> into text. Assumes
--   empty XML prolog
--   
--   See also <a>render</a>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     let
--       bare l   = (l, Data.Map.empty, [])
--       tag l    = _Element # bare l
--       subtag l = _NodeElement._Element # bare l
--       doc      = tag "root"
--           &amp; elementNodes &lt;&gt;~ [subtag "child1", subtag "child2", subtag "child3"]
--           &amp; elementNodes %~ (subtag "child0" &lt;|)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Data.Text.Lazy.IO.putStr $ doc ^. render
--   &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;root&gt;&lt;child0/&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Data.Text.Lazy.IO.putStr $ doc ^. renderWith (rsPretty .~ True)
--   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
--   &lt;root&gt;
--       &lt;child0/&gt;
--       &lt;child1/&gt;
--       &lt;child2/&gt;
--       &lt;child3/&gt;
--   &lt;/root&gt;
--   </pre>
renderWith :: AsXmlDocument t => (RenderSettings -> RenderSettings) -> Fold Element t

-- | Fold <a>Element</a> into the XML document with the default rendering
--   settings
render :: AsXmlDocument t => Fold Element t
data Prologue :: *

-- | A Traversal into XML prolog
prolog :: AsXmlDocument t => Traversal' t Prologue

-- | A Traversal into XML epilog
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root/&gt;&lt;!--qux--&gt;&lt;?foo bar?&gt;&lt;!--quux--&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. epilog.folded.comments
--   ["qux","quux"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. epilog.folded.instructions.target
--   ["foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; epilog .~ []
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root/&gt;"
--   </pre>
epilog :: AsXmlDocument t => Traversal' t [Miscellaneous]

-- | XML document parsing and rendering overloading
--   
--   This is a general version; for parsing/rendering with the default
--   options see <a>_XmlDocument</a>
class AsXmlDocument t
_XmlDocumentWith :: AsXmlDocument t => (ParseSettings -> ParseSettings) -> (RenderSettings -> RenderSettings) -> Prism' t Document
data ParseSettings :: *
data RenderSettings :: *

-- | XML document parsing and rendering with the default settings
_XmlDocument :: AsXmlDocument t => Prism' t Document

-- | HTML document parsing overloading
class AsHtmlDocument t
_HtmlDocument :: AsHtmlDocument t => Fold t Document

-- | Note: due to the incredible complexity of DTDs, this type only
--   supports external subsets. I've tried adding internal subset types,
--   but they quickly gain more code than the rest of this module put
--   together.
--   
--   It is possible that some future version of this library might support
--   internal subsets, but I am no longer actively working on adding them.
data Doctype :: *

-- | A Lens into XML DOCTYPE declaration
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;!DOCTYPE foo&gt;&lt;root/&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? prolog.doctype.folded.doctypeName
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; prolog.doctype.traverse.doctypeName .~ "moo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE moo&gt;&lt;root/&gt;"
--   </pre>
--   
--   Since <tt>doctype</tt>'s a Lens, it's possible to attach DOCTYPE
--   declaration to an XML document which didn't have it before:
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) &amp; prolog.doctype ?~ XML.Doctype "moo" Nothing
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE moo&gt;&lt;root/&gt;"
--   </pre>
doctype :: Lens' Prologue (Maybe Doctype)

-- | A Lens into nodes before XML DOCTYPE declaration
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;!--foo--&gt;&lt;!DOCTYPE bar&gt;&lt;!--baz--&gt;&lt;root/&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? prolog.beforeDoctype.folded.comments
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; prolog.beforeDoctype.traverse.comments %~ Text.toUpper
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--FOO--&gt;&lt;!DOCTYPE bar&gt;&lt;!--baz--&gt;&lt;root/&gt;"
--   </pre>
beforeDoctype :: Lens' Prologue [Miscellaneous]

-- | A Lens into nodes after XML DOCTYPE declaration
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;!--foo--&gt;&lt;!DOCTYPE bar&gt;&lt;!--baz--&gt;&lt;root/&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? prolog.afterDoctype.folded.comments
--   Just "baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; prolog.afterDoctype.traverse.comments %~ Text.toUpper
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--foo--&gt;&lt;!DOCTYPE bar&gt;&lt;!--BAZ--&gt;&lt;root/&gt;"
--   </pre>
afterDoctype :: Lens' Prologue [Miscellaneous]
data Element :: *

-- | Index subnodes selected with a <a>Traversal</a> by an <a>Int</a>
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;zero&lt;foo&gt;one&lt;/foo&gt;&lt;bar&gt;two&lt;/bar&gt;three&lt;baz/&gt;four&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.ixOf _NodeContent 2
--   Just "four"
--   </pre>
ixOf :: Traversal' Node a -> Index Element -> Traversal' Element a

-- | Traverse immediate children with a specific name
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;foo&gt;boo&lt;/foo&gt;&lt;foo&gt;hoo&lt;/foo&gt;&lt;bar&gt;moo&lt;/bar&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^. xml.node "foo".text
--   "boohoo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.node "bar".text
--   Just "moo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.node "baz".text
--   Nothing
--   </pre>
node :: Name -> Traversal' Element Element

-- | Select nodes by name
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;foo&gt;4&lt;/foo&gt;&lt;foo&gt;7&lt;/foo&gt;&lt;bar&gt;11&lt;/bar&gt;&lt;bar xmlns=\"zap\"&gt;28&lt;/bar&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml...named (only "foo").name
--   ["foo","foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml...named (namespace.traverse.only "zap").text
--   Just "28"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml...named (only "baz").name
--   Nothing
--   </pre>
named :: Fold Name a -> Traversal' Element Element

-- | Traverse node attributes
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;foo bar=\"baz\" qux=\"zap\"/&gt;&lt;foo quux=\"xyzzy\"/&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml...attrs.indices (has (name.unpacked.prefixed "qu"))
--   ["zap","xyzzy"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml...attrs %~ Text.toUpper
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;foo bar=\"BAZ\" qux=\"ZAP\"/&gt;&lt;foo quux=\"XYZZY\"/&gt;&lt;/root&gt;"
--   </pre>
attrs :: IndexedTraversal' Name Element Text

-- | Traverse node attributes with a specific name
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;foo bar=\"baz\" qux=\"quux\"/&gt;&lt;foo qux=\"xyzzy\"/&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml...attr "qux".traverse
--   ["quux","xyzzy"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml...attr "bar"
--   [Just "baz",Nothing]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml...attr "qux".traverse %~ Text.reverse
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;foo bar=\"baz\" qux=\"xuuq\"/&gt;&lt;foo qux=\"yzzyx\"/&gt;&lt;/root&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml.ix 1.attr "bar" ?~ "bazzy"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;foo bar=\"baz\" qux=\"quux\"/&gt;&lt;foo bar=\"bazzy\" qux=\"xyzzy\"/&gt;&lt;/root&gt;"
--   </pre>
attr :: Name -> Lens' Element (Maybe Text)

-- | Select nodes by attributes' values
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;foo bar=\"baz\"&gt;4&lt;/foo&gt;&lt;foo bar=\"quux\"&gt;7&lt;/foo&gt;&lt;bar bar=\"baz\"&gt;11&lt;/bar&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml...attributed (ix "bar".only "baz").text
--   ["4","11"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml...attributed (folded.to Text.length.only 4).text
--   Just "7"
--   </pre>
attributed :: Fold (Map Name Text) a -> Traversal' Element Element

-- | Traverse node text contents
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;boo&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.text
--   Just "boo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml.text &lt;&gt;~ "hoo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;boohoo&lt;/root&gt;"
--   </pre>
text :: Traversal' Element Text

-- | Traverse node text contents recursively
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;qux&lt;foo&gt;boo&lt;/foo&gt;&lt;bar&gt;&lt;baz&gt;hoo&lt;/baz&gt;quux&lt;/bar&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^.. xml.texts
--   ["qux","boo","hoo","quux"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml.texts %~ Text.toUpper
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;QUX&lt;foo&gt;BOO&lt;/foo&gt;&lt;bar&gt;&lt;baz&gt;HOO&lt;/baz&gt;QUUX&lt;/bar&gt;&lt;/root&gt;"
--   </pre>
texts :: Traversal' Element Text

-- | Anything that has comments
class HasComments t
comments :: HasComments t => Traversal' t Text

-- | Anything that has processing instructions
class HasInstructions t
instructions :: HasInstructions t => Traversal' t Instruction

-- | A fully qualified name.
--   
--   Prefixes are not semantically important; they are included only to
--   simplify pass-through parsing. When comparing names with <a>Eq</a> or
--   <a>Ord</a> methods, prefixes are ignored.
--   
--   The <tt>IsString</tt> instance supports Clark notation; see
--   <a>http://www.jclark.com/xml/xmlns.htm</a> and
--   <a>http://infohost.nmt.edu/tcc/help/pubs/pylxml/etree-QName.html</a>.
--   Use the <tt>OverloadedStrings</tt> language extension for very simple
--   <tt>Name</tt> construction:
--   
--   <pre>
--   myname :: Name
--   myname = "{http://example.com/ns/my-namespace}my-name"
--   </pre>
data Name :: *

-- | A Lens into node name
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) ^. xml.name
--   "root"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root&gt;&lt;foo/&gt;&lt;bar/&gt;&lt;baz/&gt;&lt;/root&gt;" :: TL.Text) ^.. xml...name
--   ["foo","bar","baz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root&gt;&lt;foo/&gt;&lt;bar/&gt;&lt;baz&gt;&lt;/root&gt;" :: TL.Text) &amp; xml.partsOf (plate.name) .~ ["boo", "hoo", "moo"]
--   "&lt;root&gt;&lt;foo/&gt;&lt;bar/&gt;&lt;baz&gt;&lt;/root&gt;"
--   </pre>
name :: HasName t => Lens' t Text

-- | A Lens into node namespace
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) ^. xml.namespace
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) &amp; xml.namespace ?~ "foo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root xmlns=\"foo\"/&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root xmlns=\"foo\"/&gt;" :: TL.Text) &amp; xml.namespace .~ Nothing
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root/&gt;"
--   </pre>
namespace :: HasName t => Lens' t (Maybe Text)

-- | A Lens into node namespace
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) ^. xml.prefix
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root/&gt;" :: TL.Text) &amp; xml.prefix ?~ "foo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root/&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;root xmlns=\"foo\"/&gt;" :: TL.Text) &amp; xml.prefix ?~ "foo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;foo:root xmlns:foo=\"foo\"/&gt;"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;foo:root xmlns:foo=\"foo\"/&gt;" :: TL.Text) &amp; xml.prefix .~ Nothing
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root xmlns=\"foo\"/&gt;"
--   </pre>
prefix :: HasName t => Lens' t (Maybe Text)

-- | Anything that has a name
class HasName t
fullName :: HasName t => Lens' t Name
data Instruction :: *

-- | Processing instruction target
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;?foo bar?&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.instructions.target
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml.instructions.target .~ "boo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;?boo bar?&gt;&lt;/root&gt;"
--   </pre>
target :: Traversal' Instruction Text

-- | Processing instruction data
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "&lt;root&gt;&lt;?foo bar?&gt;&lt;/root&gt;" :: TL.Text
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc ^? xml.instructions.data_
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; doc &amp; xml.instructions.data_ .~ "hoo"
--   "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;?foo hoo?&gt;&lt;/root&gt;"
--   </pre>
data_ :: Traversal' Instruction Text
data UnresolvedEntityException :: *
data XMLException :: *

-- | A Prism into <a>MissingRootElement</a>
_MissingRootElement :: AsInvalidEventStream t => Prism' t ()

-- | A Prism into <a>ContentAfterRoot</a>
_ContentAfterRoot :: AsInvalidEventStream t => Prism' t EventPos

-- | A Prism into <a>InvalidInlineDoctype</a>
_InvalidInlineDoctype :: AsInvalidEventStream t => Prism' t EventPos

-- | A Prism into <a>MissingEndElement</a>
_MissingEndElement :: AsInvalidEventStream t => Prism' t (Name, Maybe EventPos)

-- | A Prism into <a>UnterminatedInlineDoctype</a>
_UnterminatedInlineDoctype :: AsInvalidEventStream t => Prism' t ()

-- | <tt>xml-conduit</tt> entity resolving exceptions overloading
class AsUnresolvedEntityException t
_UnresolvedEntityException :: AsUnresolvedEntityException t => Prism' t UnresolvedEntityException

-- | <tt>xml-conduit</tt> general XML exception overloading
class AsXMLException t
_XMLException :: AsXMLException t => Prism' t XMLException

-- | <tt>xml-conduit</tt> XML parsing exceptions overloading
class AsInvalidEventStream t
_InvalidEventStream :: AsInvalidEventStream t => Prism' t InvalidEventStream
instance AsInvalidEventStream SomeException
instance AsInvalidEventStream InvalidEventStream
instance AsXMLException SomeException
instance AsXMLException XMLException
instance AsUnresolvedEntityException SomeException
instance AsUnresolvedEntityException UnresolvedEntityException
instance HasName Element
instance HasName Name
instance HasInstructions Miscellaneous
instance HasInstructions Element
instance HasComments Miscellaneous
instance HasComments Element
instance Plated Element
instance Ixed Element
instance AsHtmlDocument ByteString
instance AsHtmlDocument Document
instance AsXmlDocument Text
instance AsXmlDocument ByteString
instance AsXmlDocument Document
