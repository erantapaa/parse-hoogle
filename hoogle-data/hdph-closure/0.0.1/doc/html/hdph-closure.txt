-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Explicit closures in Haskell distributed parallel Haskell
--   
--   Explicit closures are serialisable representations of thunks. This
--   package exports the fully polymorphic explicit closures of HdpH
--   (Haskell distributed parallel Haskell), for use by HdpH or other
--   packages.
@package hdph-closure
@version 0.0.1


-- | Explicit Closures, inspired by [1] and refined by [2].
--   
--   References:
--   
--   <ol>
--   <li>Epstein, Black, Peyton-Jones. <i>Towards Haskell in the Cloud</i>.
--   Haskell Symposium 2011.</li>
--   <li>Maier, Trinder. <i>Implementing a High-level
--   Distributed-Memory</i> <i>Parallel Haskell in Haskell</i>. IFL
--   2011.</li>
--   </ol>
module Control.Parallel.HdpH.Closure

-- | An explicit Closure, ie. a term of type <tt>Closure a</tt>, maintains
--   a dual representation of an actual closure (ie. a thunk) of type
--   <tt>a</tt>.
--   
--   <ol>
--   <li>One half of that representation is the actual closure, the
--   <i>thunk</i> of type <tt>a</tt>.</li>
--   <li>The other half is a serialisable representation of the thunk,
--   consisting of a <tt><a>Static</a></tt> environment deserialiser, of
--   type <tt><a>Static</a> (<a>Env</a> -&gt; a)</tt>, plus a serialised
--   environment of type <tt><a>Env</a></tt>.</li>
--   </ol>
--   
--   Representation (1) is used for computing with Closures while
--   representation (2) is used for serialising and communicating Closures
--   across the network.
data Closure a

-- | Eliminates a Closure by returning its thunk. This operation is cheap.
unClosure :: Closure a -> a

-- | <tt>forceClosure</tt> fully forces its argument, ie. fully normalises
--   the thunk. Importantly, <tt>forceClosure</tt> also updates the
--   serialisable closure represention in order to keep it in sync with the
--   normalised thunk. Note that only the thunk of the resulting Closure is
--   in normal form; for the serialisable representation to also be in
--   normal form, the resulting Closure must be forced by
--   <tt><a>deepseq</a></tt>.
--   
--   Note that <tt>forceClosure clo</tt> does not have the same effect as
--   
--   <ul>
--   <li><tt><a>force</a> clo</tt> (because <tt>forceClosure</tt> updates
--   the closure representation), or</li>
--   <li><tt><a>force</a> $ toClosure $ unClosure clo</tt> (because
--   <tt>forceClosure</tt> does not force the resulting Closure's
--   serialisable representation).</li>
--   </ul>
forceClosure :: (NFData a, ToClosure a) => Closure a -> Closure a

-- | Identity arrow wrapped in a Closure.
idC :: Closure (a -> a)

-- | Terminal arrow wrapped in a Closure.
termC :: Closure (a -> ())

-- | Composition of function Closures.
compC :: Closure (b -> c) -> Closure (a -> b) -> Closure (a -> c)

-- | Application of a function Closure to another Closure. Behaves like the
--   <tt>ap</tt> operation of an applicative functor.
apC :: Closure (a -> b) -> Closure a -> Closure b

-- | <tt>toClosure x</tt> constructs a value Closure wrapping <tt>x</tt>,
--   provided the type of <tt>x</tt> is an instance of class
--   <tt><a>ToClosure</a></tt>. Note that the serialised representation of
--   the resulting Closure stores a serialised representation (as per class
--   <tt><a>Serialize</a></tt>) of <tt>x</tt>, so serialising the resulting
--   Closure will force <tt>x</tt> (hence could be costly). However,
--   Closure construction itself is cheap.
toClosure :: ToClosure a => a -> Closure a

-- | Indexing class, recording types which support the
--   <tt><a>toClosure</a></tt> operation; see the tutorial below for a more
--   thorough explanation. Note that <tt>ToClosure</tt> is a subclass of
--   <tt><a>Serialize</a></tt>.
class Serialize a => ToClosure a
locToClosure :: ToClosure a => LocT a

-- | Type synonym for declaring the <tt><a>Static</a></tt> deserialisers
--   required by <tt><a>ToClosure</a></tt> instances; see the tutorial
--   below for a more thorough explanation.
type StaticToClosure a = Static (Env -> a)

-- | <tt><a>Static</a></tt> deserialiser required by a
--   <tt><a>ToClosure</a></tt> instance; see the tutorial below for a more
--   thorough explanation.
staticToClosure :: ToClosure a => StaticToClosure a

-- | Template Haskell transformation constructing a Closure from a given
--   thunk. The thunk must either be a single toplevel closure (in which
--   case the result is a <i>static</i> Closure), or an application of a
--   toplevel closure abstraction to a tuple of local variables. See the
--   tutorial below for how to use <tt>mkClosure</tt>.
mkClosure :: ExpQ -> ExpQ

-- | Template Haskell transformation constructing a family of Closures from
--   a given thunk. The family is indexed by location (that's what the
--   suffix <tt>Loc</tt> stands for). The thunk must either be a single
--   toplevel closure (in which case the result is a family of
--   <i>static</i> Closures), or an application of a toplevel closure
--   abstraction to a tuple of local variables. See the tutorial below for
--   how to use <tt>mkClosureLoc</tt>.
mkClosureLoc :: ExpQ -> ExpQ

-- | A value of type <tt>'LocT a'</tt> is a representation of a Haskell
--   source location (or more precisely, the location of a Template Haskell
--   slice, as produced by <tt><a>here</a></tt>). Additionally, this
--   location is annotated with a phantom type <tt>a</tt>, which is used
--   for mapping location indexing to type indexing.
data LocT a

-- | Template Haskell construct returning its own location when spliced.
here :: ExpQ

-- | <tt>unsafeMkClosure thk fun env</tt> constructs a Closure that
--   
--   <ol>
--   <li>wraps the thunk <tt>thk</tt> and</li>
--   <li>whose serialised representation consists of the
--   <tt><a>Static</a></tt> deserialiser <tt>fun</tt> and the serialised
--   environment <tt>env</tt>.</li>
--   </ol>
--   
--   This operation is cheap and does not require Template Haskell support,
--   but it is <i>unsafe</i> because it relies on the programmer to ensure
--   that both closure representations evaluate to the same term.
unsafeMkClosure :: a -> Static (Env -> a) -> Env -> Closure a

-- | A term of type <tt>Static a</tt> is a serialisable reference to a
--   <i>static</i> term of type <tt>a</tt>.
data Static a

-- | A <tt><a>Static</a></tt> declaration is a collection of static terms
--   together with their serialisable <tt><a>Static</a></tt> references.
--   <tt><a>Static</a></tt> declarations form a monoid, and can be combined
--   by methods of class <tt><a>Monoid</a></tt>.
data StaticDecl

-- | Promotes a given <tt><a>Static</a></tt> reference to a
--   <tt><a>Static</a></tt> declaration consisting exactly of the given
--   <tt><a>Static</a></tt> reference (and the static term it refers to).
--   See the tutorial below for how to declare <tt><a>Static</a></tt>
--   references.
declare :: Static a -> StaticDecl

-- | Registers the given <tt><a>Static</a></tt> declaration; that is,
--   stores the declaration in the global <tt><a>Static</a></tt>
--   <i>table</i>. Must be called exactly once, before any operations
--   involving <tt><a>Static</a></tt> references (or explicit Closures).
--   See the tutorial below for how to register a <tt><a>Static</a></tt>
--   declaration.
register :: StaticDecl -> IO ()

-- | Emits the contents of the global <tt><a>Static</a></tt> table as a
--   list of Strings, one per entry. Useful for debugging; not to be called
--   prior to registration.
showStaticTable :: [String]

-- | Template Haskell transformation converting a toplevel closure
--   abstraction (given by its name) into a <tt><a>Static</a></tt>
--   deserialiser. See the tutorial below for how to use <tt>static</tt>.
static :: Name -> ExpQ

-- | Template Haskell transformation converting a static toplevel closure
--   (given by its name) into a <tt><a>Static</a></tt> deserialiser. Note
--   that a static closure ignores its empty environment (which is what the
--   suffix <tt>_</tt> is meant to signify). See the tutorial below for how
--   to use <tt>static_</tt>.
static_ :: Name -> ExpQ

-- | Template Haskell transformation converting a toplevel closure
--   abstraction (given by its name) into a family of
--   <tt><a>Static</a></tt> deserialisers indexed by location (that's what
--   the suffix <tt>Loc</tt> stands for). See the tutorial below for how to
--   use <tt>staticLoc</tt>.
staticLoc :: Name -> ExpQ

-- | Template Haskell transformation converting a static toplevel closure
--   (given by its name) into a family of <tt><a>Static</a></tt>
--   deserialisers indexed by location (that's what the suffix <tt>Loc</tt>
--   stands for). Note that a static closure ignores its empty environment
--   (which is what the suffix <tt>_</tt> is meant to signify). See the
--   tutorial below for how to use <tt>staticLoc_</tt>.
staticLoc_ :: Name -> ExpQ

-- | Abstract type of serialised environments.
data Env

-- | Creates a serialised environment from a given value of type
--   <tt>a</tt>.
encodeEnv :: Serialize a => a -> Env

-- | Deserialises a serialised environment producing a value of type
--   <tt>a</tt>. Note that the programmer asserts that the environment can
--   be deserialised at type <tt>a</tt>, a type mismatch may abort or crash
--   the program.
decodeEnv :: Serialize a => Env -> a
declareStatic :: StaticDecl
instance ToClosure (Closure a)
