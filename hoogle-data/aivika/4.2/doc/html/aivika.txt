-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A multi-paradigm simulation library
--   
@package aivika
@version 4.2


-- | Tested with: GHC 7.10.1
--   
--   It defines the table functions.
module Simulation.Aivika.Table

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using linear
--   interpolation.
tableLookup :: Double -> Array Int (Double, Double) -> Double

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using stepwise
--   function.
tableLookupStepwise :: Double -> Array Int (Double, Double) -> Double


-- | Tested with: GHC 7.10.1
--   
--   An imperative vector.
module Simulation.Aivika.Vector

-- | Represents a resizable vector.
data Vector a

-- | Create a new vector.
newVector :: IO (Vector a)

-- | Copy the vector.
copyVector :: Vector a -> IO (Vector a)

-- | Return the element count.
vectorCount :: Vector a -> IO Int

-- | Add the specified element to the end of the vector.
appendVector :: Vector a -> a -> IO ()

-- | Read a value from the vector, where indices are started from 0.
readVector :: Vector a -> Int -> IO a

-- | Set an array item at the specified index which is started from 0.
writeVector :: Vector a -> Int -> a -> IO ()

-- | Return the index of the specified element using binary search;
--   otherwise, a negated insertion index minus one: 0 -&gt; -0 - 1, ..., i
--   -&gt; -i - 1, ....
vectorBinarySearch :: Ord a => Vector a -> a -> IO Int

-- | Insert the element in the vector at the specified index.
vectorInsert :: Vector a -> Int -> a -> IO ()

-- | Delete the element at the specified index.
vectorDeleteAt :: Vector a -> Int -> IO ()

-- | Remove the specified element and return a flag indicating whether the
--   element was found and removed.
vectorDelete :: Eq a => Vector a -> a -> IO Bool

-- | Remove an element by the specified predicate and return the element if
--   found.
vectorDeleteBy :: Vector a -> (a -> Bool) -> IO (Maybe a)

-- | Return the index of the item or -1.
vectorIndex :: Eq a => Vector a -> a -> IO Int

-- | Return an index of the item satisfying the predicate or -1.
vectorIndexBy :: Vector a -> (a -> Bool) -> IO Int

-- | Return the elements of the vector in an immutable array.
freezeVector :: Vector a -> IO (Array Int a)


-- | Tested with: GHC 7.10.1
--   
--   An imperative heap-based priority queue.
module Simulation.Aivika.PriorityQueue

-- | The <a>PriorityQueue</a> type represents an imperative heap-based
--   priority queue.
data PriorityQueue a

-- | Test whether the priority queue is empty.
queueNull :: PriorityQueue a -> IO Bool

-- | Return the number of elements in the priority queue.
queueCount :: PriorityQueue a -> IO Int

-- | Create a new priority queue.
newQueue :: IO (PriorityQueue a)

-- | Enqueue a new element with the specified priority.
enqueue :: PriorityQueue a -> Double -> a -> IO ()

-- | Dequeue the element with the minimal priority.
dequeue :: PriorityQueue a -> IO ()

-- | Return the element with the minimal priority.
queueFront :: PriorityQueue a -> IO (Double, a)

-- | Remove the specified element from the queue and return a computation
--   of the flag indicating whether the element was actually removed.
--   
--   Note that unlike other functions it has complexity O(n).
queueDelete :: Eq a => PriorityQueue a -> a -> IO Bool

-- | Remove an element satisfying the predicate and return a computation of
--   the element if found.
--   
--   Note that unlike other functions it has complexity O(n).
queueDeleteBy :: PriorityQueue a -> (a -> Bool) -> IO (Maybe a)

-- | Use <a>queueDelete</a> instead.

-- | <i>Deprecated: Use queueDelete instead.</i>
remove :: Eq a => PriorityQueue a -> a -> IO Bool

-- | Use <a>queueDeleteBy</a> instead.

-- | <i>Deprecated: Use queueDeleteBy instead.</i>
removeBy :: PriorityQueue a -> (a -> Bool) -> IO Bool


-- | Tested with: GHC 7.10.1
--   
--   The <a>Unboxed</a> class allows creating unboxed arrays in monad
--   <a>IO</a>.
module Simulation.Aivika.Unboxed

-- | The type which values can be contained in an unboxed array.
class MArray IOUArray e IO => Unboxed e where newUnboxedArray_ = newArray_
newUnboxedArray_ :: (Unboxed e, Ix i) => (i, i) -> IO (IOUArray i e)
instance Unboxed Word64
instance Unboxed Int64
instance Unboxed Word32
instance Unboxed Word16
instance Unboxed Word8
instance Unboxed Word
instance Unboxed Int32
instance Unboxed Int16
instance Unboxed Int8
instance Unboxed Int
instance Unboxed Float
instance Unboxed Double
instance Unboxed Char
instance Unboxed Bool


-- | Tested with: GHC 7.10.1
--   
--   An imperative unboxed vector.
module Simulation.Aivika.Vector.Unboxed

-- | Represents an unboxed resizable vector.
data Vector a

-- | Create a new vector.
newVector :: Unboxed a => IO (Vector a)

-- | Copy the vector.
copyVector :: Unboxed a => Vector a -> IO (Vector a)

-- | Return the element count.
vectorCount :: Unboxed a => Vector a -> IO Int

-- | Add the specified element to the end of the vector.
appendVector :: Unboxed a => Vector a -> a -> IO ()

-- | Read a value from the vector, where indices are started from 0.
readVector :: Unboxed a => Vector a -> Int -> IO a

-- | Set an array item at the specified index which is started from 0.
writeVector :: Unboxed a => Vector a -> Int -> a -> IO ()

-- | Return the index of the specified element using binary search;
--   otherwise, a negated insertion index minus one: 0 -&gt; -0 - 1, ..., i
--   -&gt; -i - 1, ....
vectorBinarySearch :: (Unboxed a, Ord a) => Vector a -> a -> IO Int

-- | Insert the element in the vector at the specified index.
vectorInsert :: Unboxed a => Vector a -> Int -> a -> IO ()

-- | Delete the element at the specified index.
vectorDeleteAt :: Unboxed a => Vector a -> Int -> IO ()

-- | Remove the specified element and return a flag indicating whether the
--   element was found and removed.
vectorDelete :: (Unboxed a, Eq a) => Vector a -> a -> IO Bool

-- | Remove an element by the specified predicate and return a flag
--   indicating whether the element was found and removed.
vectorDeleteBy :: Unboxed a => Vector a -> (a -> Bool) -> IO Bool

-- | Return the index of the item or -1.
vectorIndex :: (Unboxed a, Eq a) => Vector a -> a -> IO Int

-- | Return an index of the item satisfying the predicate or -1.
vectorIndexBy :: Unboxed a => Vector a -> (a -> Bool) -> IO Int

-- | Return the elements of the vector in an immutable array.
freezeVector :: Unboxed a => Vector a -> IO (Array Int a)


-- | Tested with: GHC 7.10.1
--   
--   An imperative double-linked list.
module Simulation.Aivika.DoubleLinkedList

-- | The <a>DoubleLinkedList</a> type represents an imperative
--   double-linked list.
data DoubleLinkedList a

-- | Test whether the list is empty.
listNull :: DoubleLinkedList a -> IO Bool

-- | Return the number of elements in the list.
listCount :: DoubleLinkedList a -> IO Int

-- | Create a new list.
newList :: IO (DoubleLinkedList a)

-- | Insert a new element in the beginning.
listInsertFirst :: DoubleLinkedList a -> a -> IO ()

-- | Add a new element to the end.
listAddLast :: DoubleLinkedList a -> a -> IO ()

-- | Remove the first element.
listRemoveFirst :: DoubleLinkedList a -> IO ()

-- | Remove the last element.
listRemoveLast :: DoubleLinkedList a -> IO ()

-- | Remove the specified element from the list and return a flag
--   indicating whether the element was found and removed.
listRemove :: Eq a => DoubleLinkedList a -> a -> IO Bool

-- | Remove an element satisfying the specified predicate and return the
--   element if found.
listRemoveBy :: DoubleLinkedList a -> (a -> Bool) -> IO (Maybe a)

-- | Return the first element.
listFirst :: DoubleLinkedList a -> IO a

-- | Return the last element.
listLast :: DoubleLinkedList a -> IO a


-- | Tested with: GHC 7.10.1
--   
--   Represents statistics.
module Simulation.Aivika.Statistics

-- | Describes when the statistics consists of only samples not bound to
--   the simulation time.
data SamplingStats a
SamplingStats :: !Int -> !a -> !a -> !Double -> !Double -> SamplingStats a

-- | The total number of samples.
samplingStatsCount :: SamplingStats a -> !Int

-- | The minimum value among the samples.
samplingStatsMin :: SamplingStats a -> !a

-- | The maximum value among the samples.
samplingStatsMax :: SamplingStats a -> !a

-- | The average value.
samplingStatsMean :: SamplingStats a -> !Double

-- | The average square value.
samplingStatsMean2 :: SamplingStats a -> !Double

-- | Specifies data type from which values we can gather the statistics.
class Num a => SamplingData a
emptySamplingStats :: SamplingData a => SamplingStats a
addSamplingStats :: SamplingData a => a -> SamplingStats a -> SamplingStats a
combineSamplingStats :: SamplingData a => SamplingStats a -> SamplingStats a -> SamplingStats a

-- | If allows combining statistics more efficiently if we know that the
--   first argument can be a scalar.
combineSamplingStatsEither :: SamplingData a => Either a (SamplingStats a) -> SamplingStats a -> SamplingStats a

-- | Return the variance.
samplingStatsVariance :: SamplingStats a -> Double

-- | Return the deviation.
samplingStatsDeviation :: SamplingStats a -> Double

-- | Show the summary of the statistics using the specified indent.
samplingStatsSummary :: Show a => SamplingStats a -> Int -> ShowS

-- | Return the statistics by a single sample.
returnSamplingStats :: SamplingData a => a -> SamplingStats a

-- | Create the statistics by the specified list of data.
listSamplingStats :: SamplingData a => [a] -> SamplingStats a

-- | Convert the statistics from integer to double values.
fromIntSamplingStats :: SamplingStats Int -> SamplingStats Double

-- | This is the timing statistics where data are bound to the time.
data TimingStats a
TimingStats :: !Int -> !a -> !a -> !a -> !Double -> !Double -> !Double -> !Double -> !Double -> !Double -> TimingStats a

-- | Return the number of samples.
timingStatsCount :: TimingStats a -> !Int

-- | Return the minimum value.
timingStatsMin :: TimingStats a -> !a

-- | Return the maximum value.
timingStatsMax :: TimingStats a -> !a

-- | Return the last value.
timingStatsLast :: TimingStats a -> !a

-- | Return the time at which the minimum is attained.
timingStatsMinTime :: TimingStats a -> !Double

-- | Return the time at which the maximum is attained.
timingStatsMaxTime :: TimingStats a -> !Double

-- | Return the start time of sampling.
timingStatsStartTime :: TimingStats a -> !Double

-- | Return the last time of sampling.
timingStatsLastTime :: TimingStats a -> !Double

-- | Return the sum of values.
timingStatsSum :: TimingStats a -> !Double

-- | Return the sum of square values.
timingStatsSum2 :: TimingStats a -> !Double

-- | Defines the data type from which values we can gather the timing
--   statistics.
class Num a => TimingData a
emptyTimingStats :: TimingData a => TimingStats a
addTimingStats :: TimingData a => Double -> a -> TimingStats a -> TimingStats a
timingStatsMean :: TimingData a => TimingStats a -> Double
timingStatsMean2 :: TimingData a => TimingStats a -> Double
timingStatsVariance :: TimingData a => TimingStats a -> Double

-- | Return the deviation.
timingStatsDeviation :: TimingData a => TimingStats a -> Double

-- | Show the summary of the statistics using the specified indent.
timingStatsSummary :: (Show a, TimingData a) => TimingStats a -> Int -> ShowS

-- | Return the statistics by single timing data.
returnTimingStats :: TimingData a => Double -> a -> TimingStats a

-- | Convert the statistics from integer to double values.
fromIntTimingStats :: TimingStats Int -> TimingStats Double

-- | Convert the statistics to its normalised sampling-based
--   representation, where the first argument specifies the number of
--   pseudo-samples.
normTimingStats :: TimingData a => Int -> TimingStats a -> SamplingStats a

-- | A counter for which the statistics is collected too.
data SamplingCounter a
SamplingCounter :: a -> SamplingStats a -> SamplingCounter a

-- | The counter value.
samplingCounterValue :: SamplingCounter a -> a

-- | The counter statistics.
samplingCounterStats :: SamplingCounter a -> SamplingStats a

-- | An empty counter.
emptySamplingCounter :: SamplingData a => SamplingCounter a

-- | Increase the counter.
incSamplingCounter :: SamplingData a => a -> SamplingCounter a -> SamplingCounter a

-- | Decrease the counter.
decSamplingCounter :: SamplingData a => a -> SamplingCounter a -> SamplingCounter a

-- | Set a new value for the counter.
setSamplingCounter :: SamplingData a => a -> SamplingCounter a -> SamplingCounter a

-- | Create a counter with the specified initial value.
returnSamplingCounter :: SamplingData a => a -> SamplingCounter a

-- | A counter for which the timing statistics is collected too.
data TimingCounter a
TimingCounter :: a -> TimingStats a -> TimingCounter a

-- | The counter value.
timingCounterValue :: TimingCounter a -> a

-- | The counter statistics.
timingCounterStats :: TimingCounter a -> TimingStats a

-- | An empty counter.
emptyTimingCounter :: TimingData a => TimingCounter a

-- | Increase the counter at the specified time.
incTimingCounter :: TimingData a => Double -> a -> TimingCounter a -> TimingCounter a

-- | Decrease the counter at the specified time.
decTimingCounter :: TimingData a => Double -> a -> TimingCounter a -> TimingCounter a

-- | Set a new value for the counter at the specified time.
setTimingCounter :: TimingData a => Double -> a -> TimingCounter a -> TimingCounter a

-- | Create a timing counter with the specified initial value at the given
--   time.
returnTimingCounter :: TimingData a => Double -> a -> TimingCounter a
instance Eq a => Eq (SamplingStats a)
instance Ord a => Ord (SamplingStats a)
instance Eq a => Eq (TimingStats a)
instance Ord a => Ord (TimingStats a)
instance Eq a => Eq (SamplingCounter a)
instance Ord a => Ord (SamplingCounter a)
instance Show a => Show (SamplingCounter a)
instance Eq a => Eq (TimingCounter a)
instance Ord a => Ord (TimingCounter a)
instance (Show a, TimingData a) => Show (TimingCounter a)
instance (Show a, TimingData a) => Show (TimingStats a)
instance TimingData Int
instance TimingData Double
instance Show a => Show (SamplingStats a)
instance SamplingData Int
instance SamplingData Double
instance SamplingData a => Monoid (SamplingStats a)
instance ConvertableToDouble Int
instance ConvertableToDouble Double


-- | Tested with: GHC 7.10.1
--   
--   Below is defined a type class of the random number generator.
module Simulation.Aivika.Generator

-- | Defines a random number generator.
data Generator
Generator :: (Double -> Double -> IO Double) -> (Int -> Int -> IO Int) -> (Double -> Double -> Double -> IO Double) -> (Double -> Double -> IO Double) -> (Double -> Double -> IO Double) -> (Double -> IO Double) -> (Double -> Int -> IO Double) -> (Double -> IO Int) -> (Double -> Int -> IO Int) -> (Double -> Double -> IO Double) -> (Double -> Double -> IO Double) -> (Double -> Double -> IO Double) -> (forall a. DiscretePDF a -> IO a) -> Generator

-- | Generate an uniform random number with the specified minimum and
--   maximum.
generateUniform :: Generator -> Double -> Double -> IO Double

-- | Generate an uniform integer random number with the specified minimum
--   and maximum.
generateUniformInt :: Generator -> Int -> Int -> IO Int

-- | Generate a triangular random number by the specified minimum, median
--   and maximum.
generateTriangular :: Generator -> Double -> Double -> Double -> IO Double

-- | Generate the normal random number with the specified mean and
--   deviation.
generateNormal :: Generator -> Double -> Double -> IO Double

-- | Generate a random number from the lognormal distribution derived from
--   a normal distribution with the specified mean and deviation.
generateLogNormal :: Generator -> Double -> Double -> IO Double

-- | Generate the random number distributed exponentially with the
--   specified mean (the reciprocal of the rate).
generateExponential :: Generator -> Double -> IO Double

-- | Generate the Erlang random number with the specified scale (the
--   reciprocal of the rate) and integer shape.
generateErlang :: Generator -> Double -> Int -> IO Double

-- | Generate the Poisson random number with the specified mean.
generatePoisson :: Generator -> Double -> IO Int

-- | Generate the binomial random number with the specified probability and
--   number of trials.
generateBinomial :: Generator -> Double -> Int -> IO Int

-- | Generate a random number from the Gamma distribution with the
--   specified shape (kappa) and scale (theta, a reciprocal of the rate).
--   
--   The probability density for the Gamma distribution is
--   
--   <pre>
--   f x = x ** (kappa - 1) * exp (- x / theta) / theta ** kappa * Gamma kappa
--   </pre>
generateGamma :: Generator -> Double -> Double -> IO Double

-- | Generate a random number from the Beta distribution by the specified
--   shape parameters (alpha and beta).
--   
--   The probability density for the Beta distribution is
--   
--   <pre>
--   f x = x ** (alpha - 1) * (1 - x) ** (beta - 1) / B alpha beta
--   </pre>
generateBeta :: Generator -> Double -> Double -> IO Double

-- | Generate a random number from the Weibull distribution by the
--   specified shape and scale.
generateWeibull :: Generator -> Double -> Double -> IO Double

-- | Generate a random value from the specified discrete distribution.
generateDiscrete :: Generator -> forall a. DiscretePDF a -> IO a

-- | Defines a type of the random number generator.
data GeneratorType

-- | The simple random number generator.
SimpleGenerator :: GeneratorType

-- | The simple random number generator with the specified seed.
SimpleGeneratorWithSeed :: Int -> GeneratorType

-- | The custom random number generator.
CustomGenerator :: (IO Generator) -> GeneratorType

-- | The custom random number generator by the specified uniform generator
--   of numbers from 0 to 1.
CustomGenerator01 :: (IO Double) -> GeneratorType

-- | A discrete probability density function.
type DiscretePDF a = [(a, Double)]

-- | Create a new random number generator by the specified type.
newGenerator :: GeneratorType -> IO Generator

-- | Create a new random generator by the specified standard generator.
newRandomGenerator :: RandomGen g => g -> IO Generator


-- | Tested with: GHC 7.10.1
--   
--   It defines the simulation specs and functions for this data type.
module Simulation.Aivika.Specs

-- | It defines the simulation specs.
data Specs
Specs :: Double -> Double -> Double -> Method -> GeneratorType -> Specs

-- | the start time
spcStartTime :: Specs -> Double

-- | the stop time
spcStopTime :: Specs -> Double

-- | the integration time step
spcDT :: Specs -> Double

-- | the integration method
spcMethod :: Specs -> Method

-- | the type of the random number generator
spcGeneratorType :: Specs -> GeneratorType

-- | It defines the integration method.
data Method

-- | Euler's method
Euler :: Method

-- | the 2nd order Runge-Kutta method
RungeKutta2 :: Method

-- | the 4th order Runge-Kutta method
RungeKutta4 :: Method

-- | Returns a simulation time for the integration point specified by the
--   specs, iteration and phase.
basicTime :: Specs -> Int -> Int -> Double

-- | Returns the first and last integration iterations.
integIterationBnds :: Specs -> (Int, Int)

-- | Returns the last integration iteration.
integIterationHiBnd :: Specs -> Int

-- | Returns the first integration iteration, i.e. zero.
integIterationLoBnd :: Specs -> Int

-- | Returns the first and last integration phases.
integPhaseBnds :: Specs -> (Int, Int)

-- | Returns the last integration phase, 0 for Euler's method, 1 for RK2
--   and 3 for RK4.
integPhaseHiBnd :: Specs -> Int

-- | Returns the first integration phase, i.e. zero.
integPhaseLoBnd :: Specs -> Int

-- | Return the integration time values.
integTimes :: Specs -> [Double]


-- | Tested with: GHC 7.10.1
--   
--   The module defines the <a>Parameter</a> monad that allows representing
--   the model parameters. For example, they can be used when running the
--   Monte-Carlo simulation.
--   
--   In general, this monad is very useful for representing a computation
--   which is external relative to the model itself.
module Simulation.Aivika.Parameter

-- | The <a>Parameter</a> monad that allows specifying the model
--   parameters. For example, they can be used when running the Monte-Carlo
--   simulation.
--   
--   In general, this monad is very useful for representing a computation
--   which is external relative to the model itself.
data Parameter a

-- | A type class to lift the parameters to other computations.
class ParameterLift m
liftParameter :: ParameterLift m => Parameter a -> m a

-- | Run the parameter using the specified specs.
runParameter :: Parameter a -> Specs -> IO a

-- | Run the given number of parameters using the specified specs, where
--   each parameter is distinguished by its index <tt>parameterIndex</tt>.
runParameters :: Parameter a -> Specs -> Int -> [IO a]

-- | Exception handling within <a>Parameter</a> computations.
catchParameter :: Exception e => Parameter a -> (e -> Parameter a) -> Parameter a

-- | A computation with finalization part like the <a>finally</a> function.
finallyParameter :: Parameter a -> Parameter b -> Parameter a

-- | Like the standard <a>throw</a> function.
throwParameter :: Exception e => e -> Parameter a

-- | Return the run index for the current simulation.
simulationIndex :: Parameter Int

-- | Return the number of simulations currently run.
simulationCount :: Parameter Int

-- | Return the simulation specs.
simulationSpecs :: Parameter Specs

-- | Return the random number generator for the simulation run.
generatorParameter :: Parameter Generator

-- | Computation that returns the start simulation time.
starttime :: Parameter Double

-- | Computation that returns the final simulation time.
stoptime :: Parameter Double

-- | Computation that returns the integration time step.
dt :: Parameter Double

-- | Memoize the <a>Parameter</a> computation, always returning the same
--   value within a simulation run. However, the value will be recalculated
--   for other simulation runs. Also it is thread-safe when different
--   simulation runs are executed in parallel on physically different
--   operating system threads.
memoParameter :: Parameter a -> IO (Parameter a)

-- | Return a parameter which value is taken consequently from the
--   specified table based on the run index of the current simulation
--   starting from zero. After all values from the table are used, it takes
--   again the first value of the table, then the second one and so on.
tableParameter :: Array Int a -> Parameter a


-- | Tested with: GHC 7.10.1
--   
--   The module defines the <a>Simulation</a> monad that represents a
--   computation within the simulation run.
module Simulation.Aivika.Simulation

-- | A value in the <a>Simulation</a> monad represents a computation within
--   the simulation run.
data Simulation a

-- | A type class to lift the simulation computations to other
--   computations.
class SimulationLift m
liftSimulation :: SimulationLift m => Simulation a -> m a

-- | Run the simulation using the specified specs.
runSimulation :: Simulation a -> Specs -> IO a

-- | Run the given number of simulations using the specified specs, where
--   each simulation is distinguished by its index <a>simulationIndex</a>.
runSimulations :: Simulation a -> Specs -> Int -> [IO a]

-- | Exception handling within <a>Simulation</a> computations.
catchSimulation :: Exception e => Simulation a -> (e -> Simulation a) -> Simulation a

-- | A computation with finalization part like the <a>finally</a> function.
finallySimulation :: Simulation a -> Simulation b -> Simulation a

-- | Like the standard <a>throw</a> function.
throwSimulation :: Exception e => e -> Simulation a

-- | Memoize the <a>Simulation</a> computation, always returning the same
--   value within a simulation run.
memoSimulation :: Simulation a -> Simulation (Simulation a)

-- | The root of simulation exceptions.
data SimulationException

-- | A particular simulation exception.
SimulationException :: e -> SimulationException

-- | An exception that signals of aborting the simulation.
data SimulationAbort

-- | The exception to abort the simulation.
SimulationAbort :: SimulationAbort


-- | Tested with: GHC 7.10.1
--   
--   This module defines a light-weight and more fast version of an
--   updatable reference that depends on the event queue but that doesn't
--   supply with the signal notification.
module Simulation.Aivika.Ref.Base

-- | The <a>Ref</a> type represents a mutable variable similar to the
--   <a>IORef</a> variable but only dependent on the event queue, which
--   allows synchronizing the reference with the model explicitly through
--   the <a>Event</a> monad.
data Ref a

-- | Create a new reference.
newRef :: a -> Simulation (Ref a)

-- | Read the value of a reference.
readRef :: Ref a -> Event a

-- | Write a new value into the reference.
writeRef :: Ref a -> a -> Event ()

-- | Mutate the contents of the reference.
modifyRef :: Ref a -> (a -> a) -> Event ()


-- | Tested with: GHC 7.10.1
--   
--   The module defines the <a>Event</a> monad which is very similar to the
--   <tt>Dynamics</tt> monad but only now the computation is strongly
--   synchronized with the event queue.
--   
--   The <tt>Dynamics</tt> computation is defined in all time points
--   simultaneously, while the <tt>Event</tt> computation can be described
--   in every time point differently and can change in discrete steps.
--   Therefore, the former is destined for differential and difference
--   equations of System Dynamics, while the latter is destined for
--   discrete event simulation, being its core actually.
module Simulation.Aivika.Event

-- | A value in the <a>Event</a> monad represents a polymorphic time
--   varying function which is strongly synchronized with the event queue.
data Event a

-- | A type class to lift the <a>Event</a> computation to other
--   computations.
class EventLift m
liftEvent :: EventLift m => Event a -> m a

-- | Defines how the events are processed.
data EventProcessing

-- | either process all earlier and then current events, or raise an error
--   if the current simulation time is less than the actual time of the
--   event queue (safe within the <a>Event</a> computation as this is
--   protected by the type system)
CurrentEvents :: EventProcessing

-- | either process all earlier events not affecting the events at the
--   current simulation time, or raise an error if the current simulation
--   time is less than the actual time of the event queue (safe within the
--   <a>Event</a> computation as this is protected by the type system)
EarlierEvents :: EventProcessing

-- | either process all earlier and then current events, or do nothing if
--   the current simulation time is less than the actual time of the event
--   queue (do not use unless the documentation states the opposite)
CurrentEventsOrFromPast :: EventProcessing

-- | either process all earlier events, or do nothing if the current
--   simulation time is less than the actual time of the event queue (do
--   not use unless the documentation states the opposite)
EarlierEventsOrFromPast :: EventProcessing

-- | Run the <a>Event</a> computation in the current simulation time within
--   the <a>Dynamics</a> computation involving all pending
--   <a>CurrentEvents</a> in the processing too.
runEvent :: Event a -> Dynamics a

-- | Run the <a>Event</a> computation in the current simulation time within
--   the <a>Dynamics</a> computation specifying what pending events should
--   be involved in the processing.
runEventWith :: EventProcessing -> Event a -> Dynamics a

-- | Run the <a>Event</a> computation in the start time involving all
--   pending <a>CurrentEvents</a> in the processing too.
runEventInStartTime :: Event a -> Simulation a

-- | Run the <a>Event</a> computation in the stop time involving all
--   pending <a>CurrentEvents</a> in the processing too.
runEventInStopTime :: Event a -> Simulation a

-- | Enqueue the event which must be actuated at the specified time.
enqueueEvent :: Double -> Event () -> Event ()

-- | Enqueue the event with an ability to cancel it.
enqueueEventWithCancellation :: Double -> Event () -> Event EventCancellation

-- | Actuate the event handler in the specified time points.
enqueueEventWithTimes :: [Double] -> Event () -> Event ()

-- | Actuate the event handler in the integration time points.
enqueueEventWithIntegTimes :: Event () -> Event ()

-- | Enqueue the event which must be actuated with the current modeling
--   time but later.
yieldEvent :: Event () -> Event ()

-- | Return the number of pending events that should be yet actuated.
eventQueueCount :: Event Int

-- | It allows cancelling the event.
data EventCancellation

-- | Cancel the event.
cancelEvent :: EventCancellation -> Event ()

-- | Test whether the event was cancelled.
eventCancelled :: EventCancellation -> Event Bool

-- | Test whether the event was processed and finished.
eventFinished :: EventCancellation -> Event Bool

-- | Exception handling within <a>Event</a> computations.
catchEvent :: Exception e => Event a -> (e -> Event a) -> Event a

-- | A computation with finalization part like the <a>finally</a> function.
finallyEvent :: Event a -> Event b -> Event a

-- | Like the standard <a>throw</a> function.
throwEvent :: Exception e => e -> Event a

-- | Memoize the <a>Event</a> computation, always returning the same value
--   within a simulation run.
memoEvent :: Event a -> Simulation (Event a)

-- | Memoize the <a>Event</a> computation, always returning the same value
--   in the same modeling time. After the time changes, the value is
--   recalculated by demand.
--   
--   It is possible to implement this function efficiently, for the
--   <a>Event</a> computation is always synchronized with the event queue
--   which time flows in one direction only. This synchronization is a key
--   difference between the <a>Event</a> and <a>Dynamics</a> computations.
memoEventInTime :: Event a -> Simulation (Event a)

-- | Defines a computation disposing some entity.
newtype DisposableEvent
DisposableEvent :: Event () -> DisposableEvent

-- | Dispose something within the <a>Event</a> computation.
disposeEvent :: DisposableEvent -> Event ()

-- | Show the debug message with the current simulation time.
traceEvent :: String -> Event a -> Event a


-- | Tested with: GHC 7.10.1
--   
--   This module defines the queue strategies.
module Simulation.Aivika.QueueStrategy

-- | Defines the basic queue strategy.
class QueueStrategy s where data family StrategyQueue s :: * -> *
newStrategyQueue :: QueueStrategy s => s -> Simulation (StrategyQueue s i)
strategyQueueNull :: QueueStrategy s => StrategyQueue s i -> Event Bool

-- | Defines a strategy with support of the dequeuing operation.
class QueueStrategy s => DequeueStrategy s
strategyDequeue :: DequeueStrategy s => StrategyQueue s i -> Event i

-- | It defines a strategy when we can enqueue a single element.
class DequeueStrategy s => EnqueueStrategy s
strategyEnqueue :: EnqueueStrategy s => StrategyQueue s i -> i -> Event ()

-- | It defines a strategy when we can enqueue an element with the
--   specified priority.
class DequeueStrategy s => PriorityQueueStrategy s p | s -> p
strategyEnqueueWithPriority :: PriorityQueueStrategy s p => StrategyQueue s i -> p -> i -> Event ()

-- | Defines a strategy with support of the deleting operation.
class DequeueStrategy s => DeletingQueueStrategy s where strategyQueueDelete s i = fmap isJust $ strategyQueueDeleteBy s (== i)
strategyQueueDelete :: (DeletingQueueStrategy s, Eq i) => StrategyQueue s i -> i -> Event Bool
strategyQueueDeleteBy :: DeletingQueueStrategy s => StrategyQueue s i -> (i -> Bool) -> Event (Maybe i)

-- | Strategy: First Come - First Served (FCFS).
data FCFS
FCFS :: FCFS

-- | Strategy: Last Come - First Served (LCFS)
data LCFS
LCFS :: LCFS

-- | Strategy: Service in Random Order (SIRO).
data SIRO
SIRO :: SIRO

-- | Strategy: Static Priorities. It uses the priority queue.
data StaticPriorities
StaticPriorities :: StaticPriorities

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.
instance Eq FCFS
instance Ord FCFS
instance Show FCFS
instance Eq LCFS
instance Ord LCFS
instance Show LCFS
instance Eq SIRO
instance Ord SIRO
instance Show SIRO
instance Eq StaticPriorities
instance Ord StaticPriorities
instance Show StaticPriorities
instance DeletingQueueStrategy SIRO
instance EnqueueStrategy SIRO
instance DequeueStrategy SIRO
instance QueueStrategy SIRO
instance DeletingQueueStrategy StaticPriorities
instance PriorityQueueStrategy StaticPriorities Double
instance DequeueStrategy StaticPriorities
instance QueueStrategy StaticPriorities
instance DeletingQueueStrategy LCFS
instance EnqueueStrategy LCFS
instance DequeueStrategy LCFS
instance QueueStrategy LCFS
instance DeletingQueueStrategy FCFS
instance EnqueueStrategy FCFS
instance DequeueStrategy FCFS
instance QueueStrategy FCFS


-- | Tested with: GHC 7.10.1
--   
--   This module defines the signal which we can subscribe handlers to.
--   These handlers can be disposed. The signal is triggered in the current
--   time point actuating the corresponded computations from the handlers.
module Simulation.Aivika.Signal

-- | The signal that can have disposable handlers.
data Signal a
Signal :: ((a -> Event ()) -> Event DisposableEvent) -> Signal a

-- | Subscribe the handler to the specified signal and return a nested
--   computation within a disposable object that, being applied,
--   unsubscribes the handler from this signal.
handleSignal :: Signal a -> (a -> Event ()) -> Event DisposableEvent

-- | Subscribe the handler to the specified signal forever. To subscribe
--   the disposable handlers, use function <a>handleSignal</a>.
handleSignal_ :: Signal a -> (a -> Event ()) -> Event ()

-- | The signal source that can publish its signal.
data SignalSource a

-- | Create a new signal source.
newSignalSource :: Simulation (SignalSource a)

-- | Publish the signal.
publishSignal :: SignalSource a -> Signal a

-- | Trigger the signal actuating all its handlers at the current
--   simulation time point.
triggerSignal :: SignalSource a -> a -> Event ()

-- | Map the signal according the specified function.
mapSignal :: (a -> b) -> Signal a -> Signal b

-- | Compose the signal.
mapSignalM :: (a -> Event b) -> Signal a -> Signal b

-- | Transform the signal.
apSignal :: Event (a -> b) -> Signal a -> Signal b

-- | Filter only those signal values that satisfy the specified predicate.
filterSignal :: (a -> Bool) -> Signal a -> Signal a

-- | Filter only those signal values that satisfy the specified predicate,
--   but then ignoring the values.
filterSignal_ :: (a -> Bool) -> Signal a -> Signal ()

-- | Filter only those signal values that satisfy the specified predicate.
filterSignalM :: (a -> Event Bool) -> Signal a -> Signal a

-- | Filter only those signal values that satisfy the specified predicate,
--   but then ignoring the values.
filterSignalM_ :: (a -> Event Bool) -> Signal a -> Signal ()

-- | An empty signal which is never triggered.
emptySignal :: Signal a

-- | Merge two signals.
merge2Signals :: Signal a -> Signal a -> Signal a

-- | Merge three signals.
merge3Signals :: Signal a -> Signal a -> Signal a -> Signal a

-- | Merge four signals.
merge4Signals :: Signal a -> Signal a -> Signal a -> Signal a -> Signal a

-- | Merge five signals.
merge5Signals :: Signal a -> Signal a -> Signal a -> Signal a -> Signal a -> Signal a

-- | Transform a signal so that the resulting signal returns a sequence of
--   arrivals saving the information about the time points at which the
--   original signal was received.
arrivalSignal :: Signal a -> Signal (Arrival a)

-- | Return a signal that is triggered in the specified time points.
newSignalInTimes :: [Double] -> Event (Signal Double)

-- | Return a signal that is triggered in the integration time points. It
--   should be called with help of <a>runEventInStartTime</a>.
newSignalInIntegTimes :: Event (Signal Double)

-- | Return a signal that is triggered in the start time. It should be
--   called with help of <a>runEventInStartTime</a>.
newSignalInStartTime :: Event (Signal Double)

-- | Return a signal that is triggered in the final time.
newSignalInStopTime :: Event (Signal Double)

-- | Represents the history of the signal values.
data SignalHistory a

-- | The signal for which the history is created.
signalHistorySignal :: SignalHistory a -> Signal a

-- | Create a history of the signal values.
newSignalHistory :: Signal a -> Event (SignalHistory a)

-- | Create a history of the signal values starting with the optional
--   initial value.
newSignalHistoryStartingWith :: Maybe a -> Signal a -> Event (SignalHistory a)

-- | Read the history of signal values.
readSignalHistory :: SignalHistory a -> Event (Array Int Double, Array Int a)

-- | Describes a computation that also signals when changing its value.
data Signalable a
Signalable :: Event a -> Signal () -> Signalable a

-- | Return a computation of the value.
readSignalable :: Signalable a -> Event a

-- | Return a signal notifying that the value has changed but without
--   providing the information about the changed value.
signalableChanged_ :: Signalable a -> Signal ()

-- | Return a signal notifying that the value has changed.
signalableChanged :: Signalable a -> Signal a

-- | Return an identity.
emptySignalable :: Monoid a => Signalable a

-- | An associative operation.
appendSignalable :: Monoid a => Signalable a -> Signalable a -> Signalable a

-- | Show the debug message with the current simulation time.
traceSignal :: String -> Signal a -> Signal a
instance Monoid a => Monoid (Signalable a)
instance Functor Signalable
instance Monoid (Signal a)
instance Functor Signal
instance Eq (SignalHandler a)


-- | Tested with: GHC 7.10.1
--   
--   This module defines an updatable reference that depends on the event
--   queue.
module Simulation.Aivika.Ref

-- | The <a>Ref</a> type represents a mutable variable similar to the
--   <a>IORef</a> variable but only dependent on the event queue, which
--   allows synchronizing the reference with the model explicitly through
--   the <a>Event</a> monad.
data Ref a

-- | Return a signal that notifies about every change of the reference
--   state.
refChanged :: Ref a -> Signal a

-- | Return a signal that notifies about every change of the reference
--   state.
refChanged_ :: Ref a -> Signal ()

-- | Create a new reference.
newRef :: a -> Simulation (Ref a)

-- | Read the value of a reference.
readRef :: Ref a -> Event a

-- | Write a new value into the reference.
writeRef :: Ref a -> a -> Event ()

-- | Mutate the contents of the reference.
modifyRef :: Ref a -> (a -> a) -> Event ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines a variable that is bound up with the event queue
--   and that keeps the history of changes storing the values in arrays,
--   which allows using the variable in differential and difference
--   equations of System Dynamics within hybrid discrete-continuous
--   simulation.
module Simulation.Aivika.Var

-- | Like the <a>Ref</a> reference but keeps the history of changes in
--   different time points. The <a>Var</a> variable is safe to be used in
--   the hybrid discrete-continuous simulation.
--   
--   For example, the memoised values of a variable can be used in the
--   differential or difference equations of System Dynamics, while the
--   variable iself can be updated wihin the discrete event simulation.
--   
--   Only this variable is much slower than the reference.
data Var a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged :: Var a -> Signal a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged_ :: Var a -> Signal ()

-- | Create a new variable.
newVar :: a -> Simulation (Var a)

-- | Read the recent actual value of a variable for the requested time.
--   
--   This computation is destined for using within discrete event
--   simulation.
readVar :: Var a -> Event a

-- | Read the first actual, i.e. memoised, value of a variable for the
--   requested time actuating the current events from the queue if needed.
--   
--   This computation can be used in the ordinary differential and
--   difference equations of System Dynamics.
varMemo :: Var a -> Dynamics a

-- | Write a new value into the variable.
writeVar :: Var a -> a -> Event ()

-- | Mutate the contents of the variable.
modifyVar :: Var a -> (a -> a) -> Event ()

-- | Freeze the variable and return in arrays the time points and
--   corresponded first and last values when the variable had changed or
--   had been memoised in different time points: (1) the time points are
--   sorted in ascending order; (2) the first and last actual values per
--   each time point are provided.
--   
--   If you need to get all changes including those ones that correspond to
--   the same simulation time points then you can use the
--   <a>newSignalHistory</a> function passing in the <a>varChanged</a>
--   signal to it and then call function <a>readSignalHistory</a>.
freezeVar :: Var a -> Event (Array Int Double, Array Int a, Array Int a)


-- | Tested with: GHC 7.10.1
--   
--   This module defines an unboxed variable that is bound up with the
--   event queue and that keeps the history of changes storing the values
--   in unboxed arrays, which allows using the variable in differential and
--   difference equations of System Dynamics within hybrid
--   discrete-continuous simulation.
module Simulation.Aivika.Var.Unboxed

-- | Like the <a>Ref</a> reference but keeps the history of changes in
--   different time points. The <a>Var</a> variable is safe to be used in
--   the hybrid discrete-continuous simulation.
--   
--   For example, the memoised values of a variable can be used in the
--   differential or difference equations of System Dynamics, while the
--   variable iself can be updated wihin the discrete event simulation.
--   
--   Only this variable is much slower than the reference.
data Var a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged :: Var a -> Signal a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged_ :: Var a -> Signal ()

-- | Create a new variable.
newVar :: Unboxed a => a -> Simulation (Var a)

-- | Read the recent actual value of a variable for the requested time.
--   
--   This computation is destined for using within discrete event
--   simulation.
readVar :: Unboxed a => Var a -> Event a

-- | Read the first actual, i.e. memoised, value of a variable for the
--   requested time actuating the current events from the queue if needed.
--   
--   This computation can be used in the ordinary differential and
--   difference equations of System Dynamics.
varMemo :: Unboxed a => Var a -> Dynamics a

-- | Write a new value into the variable.
writeVar :: Unboxed a => Var a -> a -> Event ()

-- | Mutate the contents of the variable.
modifyVar :: Unboxed a => Var a -> (a -> a) -> Event ()

-- | Freeze the variable and return in arrays the time points and
--   corresponded first and last values when the variable had changed or
--   had been memoised in different time points: (1) the time points are
--   sorted in ascending order; (2) the first and last actual values per
--   each time point are provided.
--   
--   If you need to get all changes including those ones that correspond to
--   the same simulation time points then you can use the
--   <a>newSignalHistory</a> function passing in the <a>varChanged</a>
--   signal to it and then call function <a>readSignalHistory</a>.
freezeVar :: Unboxed a => Var a -> Event (Array Int Double, Array Int a, Array Int a)


-- | Tested with: GHC 7.10.1
--   
--   A value in the <a>Process</a> monad represents a discontinuous process
--   that can suspend in any simulation time point and then resume later in
--   the same or another time point.
--   
--   The process of this type can involve the <tt>Event</tt>,
--   <tt>Dynamics</tt> and <tt>Simulation</tt> computations. Moreover, a
--   value in the <tt>Process</tt> monad can be run within the
--   <tt>Event</tt> computation.
--   
--   A value of the <a>ProcessId</a> type is just an identifier of such a
--   process.
--   
--   The characteristic property of the <tt>Process</tt> type is function
--   <a>holdProcess</a> that suspends the current process for the specified
--   time interval.
module Simulation.Aivika.Process

-- | Represents a process identifier.
data ProcessId

-- | Specifies a discontinuous process that can suspend at any time and
--   then resume later.
data Process a

-- | A type class to lift the <a>Process</a> computation to other
--   computations.
class ProcessLift m
liftProcess :: ProcessLift m => Process a -> m a

-- | Run immediately the process. A new <a>ProcessId</a> identifier will be
--   assigned to the process.
--   
--   To run the process at the specified time, you can use the
--   <a>enqueueProcess</a> function.
runProcess :: Process () -> Event ()

-- | Run immediately the process with the specified identifier. It will be
--   more efficient than as you would specify the process identifier with
--   help of the <a>processUsingId</a> combinator and then would call
--   <a>runProcess</a>.
--   
--   To run the process at the specified time, you can use the
--   <a>enqueueProcessUsingId</a> function.
runProcessUsingId :: ProcessId -> Process () -> Event ()

-- | Run the process in the start time immediately involving all pending
--   <a>CurrentEvents</a> in the computation too.
runProcessInStartTime :: Process () -> Simulation ()

-- | Run the process in the start time immediately using the specified
--   identifier and involving all pending <a>CurrentEvents</a> in the
--   computation too.
runProcessInStartTimeUsingId :: ProcessId -> Process () -> Simulation ()

-- | Run the process in the final simulation time immediately involving all
--   pending <a>CurrentEvents</a> in the computation too.
runProcessInStopTime :: Process () -> Simulation ()

-- | Run the process in the final simulation time immediately using the
--   specified identifier and involving all pending <a>CurrentEvents</a> in
--   the computation too.
runProcessInStopTimeUsingId :: ProcessId -> Process () -> Simulation ()

-- | Spawn the child process. In case of cancelling one of the processes,
--   other process will be cancelled too.
spawnProcess :: Process () -> Process ()

-- | Spawn the child process with the specified process identifier. In case
--   of cancelling one of the processes, other process will be cancelled
--   too.
spawnProcessUsingId :: ProcessId -> Process () -> Process ()

-- | Spawn the child process specifying how the child and parent processes
--   should be cancelled in case of need.
spawnProcessWith :: ContCancellation -> Process () -> Process ()

-- | Spawn the child process specifying how the child and parent processes
--   should be cancelled in case of need.
spawnProcessUsingIdWith :: ContCancellation -> ProcessId -> Process () -> Process ()

-- | Enqueue the process that will be then started at the specified time
--   from the event queue.
enqueueProcess :: Double -> Process () -> Event ()

-- | Enqueue the process that will be then started at the specified time
--   from the event queue.
enqueueProcessUsingId :: Double -> ProcessId -> Process () -> Event ()

-- | Create a new process identifier.
newProcessId :: Simulation ProcessId

-- | Return the current process identifier.
processId :: Process ProcessId

-- | Allow calling the process with the specified identifier. It creates a
--   nested process when canceling any of two, or raising an <tt>IO</tt>
--   exception in any of the both, affects the <a>Process</a> computation.
--   
--   At the same time, the interruption has no such effect as it requires
--   explicit specifying the <a>ProcessId</a> identifier of the nested
--   process itself, that is the nested process cannot be interrupted using
--   only the parent process identifier.
processUsingId :: ProcessId -> Process a -> Process a

-- | Hold the process for the specified time period.
holdProcess :: Double -> Process ()

-- | Interrupt a process with the specified identifier if the process is
--   held by computation <a>holdProcess</a>.
interruptProcess :: ProcessId -> Event ()

-- | Test whether the process with the specified identifier was
--   interrupted.
processInterrupted :: ProcessId -> Event Bool

-- | Passivate the process.
passivateProcess :: Process ()

-- | Test whether the process with the specified identifier is passivated.
processPassive :: ProcessId -> Event Bool

-- | Reactivate a process with the specified identifier.
reactivateProcess :: ProcessId -> Event ()

-- | Cancel a process with the specified identifier, interrupting it if
--   needed.
cancelProcessWithId :: ProcessId -> Event ()

-- | The process cancels itself.
cancelProcess :: Process a

-- | Test whether the process with the specified identifier was cancelled.
processCancelled :: ProcessId -> Event Bool

-- | Return a signal that notifies about cancelling the process with the
--   specified identifier.
processCancelling :: ProcessId -> Signal ()

-- | Register a handler that will be invoked in case of cancelling the
--   current process.
whenCancellingProcess :: Event () -> Process ()

-- | Await the signal.
processAwait :: Signal a -> Process a

-- | Return a signal when the process is preempted.
processPreemptionBeginning :: ProcessId -> Signal ()

-- | Return a signal when the process is proceeded after it was preempted
--   earlier.
processPreemptionEnding :: ProcessId -> Signal ()

-- | Yield to allow other <a>Process</a> and <a>Event</a> computations to
--   run at the current simulation time point.
processYield :: Process ()

-- | Try to run the child process within the specified timeout. If the
--   process will finish successfully within this time interval then the
--   result wrapped in <a>Just</a> will be returned; otherwise, the child
--   process will be cancelled and <a>Nothing</a> will be returned.
--   
--   If an exception is raised in the child process then it is propagated
--   to the parent computation as well.
--   
--   A cancellation of the child process doesn't lead to cancelling the
--   parent process. Then <a>Nothing</a> is returned within the
--   computation.
timeoutProcess :: Double -> Process a -> Process (Maybe a)

-- | Try to run the child process with the given identifier within the
--   specified timeout. If the process will finish successfully within this
--   time interval then the result wrapped in <a>Just</a> will be returned;
--   otherwise, the child process will be cancelled and <a>Nothing</a> will
--   be returned.
--   
--   If an exception is raised in the child process then it is propagated
--   to the parent computation as well.
--   
--   A cancellation of the child process doesn't lead to cancelling the
--   parent process. Then <a>Nothing</a> is returned within the
--   computation.
timeoutProcessUsingId :: Double -> ProcessId -> Process a -> Process (Maybe a)

-- | Execute the specified computations in parallel within the current
--   computation and return their results. The cancellation of any of the
--   nested computations affects the current computation. The exception
--   raised in any of the nested computations is propagated to the current
--   computation as well.
--   
--   Here word <tt>parallel</tt> literally means that the computations are
--   actually executed on a single operating system thread but they are
--   processed simultaneously by the event queue.
--   
--   New <a>ProcessId</a> identifiers will be assigned to the started
--   processes.
processParallel :: [Process a] -> Process [a]

-- | Like <a>processParallel</a> but allows specifying the process
--   identifiers. It will be more efficient than as you would specify the
--   process identifiers with help of the <a>processUsingId</a> combinator
--   and then would call <a>processParallel</a>.
processParallelUsingIds :: [(ProcessId, Process a)] -> Process [a]

-- | Like <a>processParallel</a> but ignores the result.
processParallel_ :: [Process a] -> Process ()

-- | Like <a>processParallelUsingIds</a> but ignores the result.
processParallelUsingIds_ :: [(ProcessId, Process a)] -> Process ()

-- | Exception handling within <a>Process</a> computations.
catchProcess :: Exception e => Process a -> (e -> Process a) -> Process a

-- | A computation with finalization part.
finallyProcess :: Process a -> Process b -> Process a

-- | Throw the exception with the further exception handling.
--   
--   By some reason, an exception raised with help of the standard
--   <a>throw</a> function is not handled properly within <a>Process</a>
--   computation, altough it will be still handled if it will be wrapped in
--   the <a>IO</a> monad. Therefore, you should use specialised functions
--   like the stated one that use the <a>throw</a> function but within the
--   <a>IO</a> computation, which allows already handling the exception.
throwProcess :: Exception e => e -> Process a

-- | Zip two parallel processes waiting for the both.
zipProcessParallel :: Process a -> Process b -> Process (a, b)

-- | Zip three parallel processes waiting for their results.
zip3ProcessParallel :: Process a -> Process b -> Process c -> Process (a, b, c)

-- | Unzip the process using memoization so that the both returned
--   processes could be applied independently, although they will refer to
--   the same pair of values.
unzipProcess :: Process (a, b) -> Simulation (Process a, Process b)

-- | Memoize the process so that it would always return the same value
--   within the simulation run.
memoProcess :: Process a -> Simulation (Process a)

-- | A computation that never computes the result. It behaves like a black
--   hole for the discontinuous process, although such a process can still
--   be canceled outside (see <a>cancelProcessWithId</a>), but then only
--   its finalization parts (see <a>finallyProcess</a>) will be called,
--   usually, to release the resources acquired before.
neverProcess :: Process a

-- | Show the debug message with the current simulation time.
traceProcess :: String -> Process a -> Process a


-- | Tested with: GHC 7.10.1
--   
--   The module defines a gate which can be either opened or closed.
module Simulation.Aivika.Gate

-- | Represents a gate, which can be either opened or closed.
data Gate

-- | Create a new gate, specifying whether the gate is initially open.
newGate :: Bool -> Simulation Gate

-- | Create a new initially open gate.
newGateOpened :: Simulation Gate

-- | Create a new initially close gate.
newGateClosed :: Simulation Gate

-- | Open the gate if it was closed.
openGate :: Gate -> Event ()

-- | Close the gate if it was open.
closeGate :: Gate -> Event ()

-- | Test whether the gate is open.
gateOpened :: Gate -> Event Bool

-- | Test whether the gate is closed.
gateClosed :: Gate -> Event Bool

-- | Await the gate to be opened if required. If the gate is already open
--   then the computation returns immediately.
awaitGateOpened :: Gate -> Process ()

-- | Await the gate to be closed if required. If the gate is already closed
--   then the computation returns immediately.
awaitGateClosed :: Gate -> Process ()

-- | Signal triggered when the state of the gate changes.
gateChanged_ :: Gate -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines the resource which can be acquired and then
--   released by the discontinuous process <a>Process</a>. The resource can
--   be either limited by the upper bound (run-time check), or it can have
--   no upper bound. The latter is useful for modeling the infinite queue,
--   for example.
module Simulation.Aivika.Resource

-- | The ordinary FCFS (First Come - First Serviced) resource.
type FCFSResource = Resource FCFS

-- | The ordinary LCFS (Last Come - First Serviced) resource.
type LCFSResource = Resource LCFS

-- | The SIRO (Serviced in Random Order) resource.
type SIROResource = Resource SIRO

-- | The resource with static priorities.
type PriorityResource = Resource StaticPriorities

-- | Represents the resource with strategy <tt>s</tt> applied for queuing
--   the requests.
data Resource s

-- | Create a new FCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newFCFSResource :: Int -> Event FCFSResource

-- | Create a new FCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newFCFSResourceWithMaxCount :: Int -> Maybe Int -> Event FCFSResource

-- | Create a new LCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newLCFSResource :: Int -> Event LCFSResource

-- | Create a new LCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newLCFSResourceWithMaxCount :: Int -> Maybe Int -> Event LCFSResource

-- | Create a new SIRO resource with the specified initial count which
--   value becomes the upper bound as well.
newSIROResource :: Int -> Event SIROResource

-- | Create a new SIRO resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newSIROResourceWithMaxCount :: Int -> Maybe Int -> Event SIROResource

-- | Create a new priority resource with the specified initial count which
--   value becomes the upper bound as well.
newPriorityResource :: Int -> Event PriorityResource

-- | Create a new priority resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newPriorityResourceWithMaxCount :: Int -> Maybe Int -> Event PriorityResource

-- | Create a new resource with the specified queue strategy and initial
--   count. The last value becomes the upper bound as well.
newResource :: QueueStrategy s => s -> Int -> Event (Resource s)

-- | Create a new resource with the specified queue strategy, initial and
--   maximum counts, where <a>Nothing</a> means that the resource has no
--   upper bound.
newResourceWithMaxCount :: QueueStrategy s => s -> Int -> Maybe Int -> Event (Resource s)

-- | Return the strategy applied for queuing the requests.
resourceStrategy :: Resource s -> s

-- | Return the maximum count of the resource, where <a>Nothing</a> means
--   that the resource has no upper bound.
resourceMaxCount :: Resource s -> Maybe Int

-- | Return the current available count of the resource.
resourceCount :: Resource s -> Event Int

-- | Return the statistics for the available count of the resource.
resourceCountStats :: Resource s -> Event (TimingStats Int)

-- | Return the current utilisation count of the resource.
resourceUtilisationCount :: Resource s -> Event Int

-- | Return the statistics for the utilisation count of the resource.
resourceUtilisationCountStats :: Resource s -> Event (TimingStats Int)

-- | Return the current queue length of the resource.
resourceQueueCount :: Resource s -> Event Int

-- | Return the statistics for the queue length of the resource.
resourceQueueCountStats :: Resource s -> Event (TimingStats Int)

-- | Return the total wait time of the resource.
resourceTotalWaitTime :: Resource s -> Event Double

-- | Return the statistics for the wait time of the resource.
resourceWaitTime :: Resource s -> Event (SamplingStats Double)

-- | Request for the resource decreasing its count in case of success,
--   otherwise suspending the discontinuous process until some other
--   process releases the resource.
requestResource :: EnqueueStrategy s => Resource s -> Process ()

-- | Request with the priority for the resource decreasing its count in
--   case of success, otherwise suspending the discontinuous process until
--   some other process releases the resource.
requestResourceWithPriority :: PriorityQueueStrategy s p => Resource s -> p -> Process ()

-- | Try to request for the resource decreasing its count in case of
--   success and returning <a>True</a> in the <a>Event</a> monad;
--   otherwise, returning <a>False</a>.
tryRequestResourceWithinEvent :: Resource s -> Event Bool

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResource :: DequeueStrategy s => Resource s -> Process ()

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResourceWithinEvent :: DequeueStrategy s => Resource s -> Event ()

-- | Acquire the resource, perform some action and safely release the
--   resource in the end, even if the <a>IOException</a> was raised within
--   the action.
usingResource :: EnqueueStrategy s => Resource s -> Process a -> Process a

-- | Acquire the resource with the specified priority, perform some action
--   and safely release the resource in the end, even if the
--   <a>IOException</a> was raised within the action.
usingResourceWithPriority :: PriorityQueueStrategy s p => Resource s -> p -> Process a -> Process a

-- | Increase the count of available resource by the specified number,
--   invoking the awaiting processes as needed.
incResourceCount :: DequeueStrategy s => Resource s -> Int -> Event ()

-- | Decrease the count of available resource by the specified number,
--   waiting for the processes capturing the resource as needed.
decResourceCount :: EnqueueStrategy s => Resource s -> Int -> Process ()

-- | Signal triggered when the <a>resourceCount</a> property changes.
resourceCountChanged :: Resource s -> Signal Int

-- | Signal triggered when the <a>resourceCount</a> property changes.
resourceCountChanged_ :: Resource s -> Signal ()

-- | Signal triggered when the <a>resourceUtilisationCount</a> property
--   changes.
resourceUtilisationCountChanged :: Resource s -> Signal Int

-- | Signal triggered when the <a>resourceUtilisationCount</a> property
--   changes.
resourceUtilisationCountChanged_ :: Resource s -> Signal ()

-- | Signal triggered when the <a>resourceQueueCount</a> property changes.
resourceQueueCountChanged :: Resource s -> Signal Int

-- | Signal triggered when the <a>resourceQueueCount</a> property changes.
resourceQueueCountChanged_ :: Resource s -> Signal ()

-- | Signal triggered when the <a>resourceTotalWaitTime</a> and
--   <a>resourceWaitTime</a> properties change.
resourceWaitTimeChanged :: Resource s -> Signal (SamplingStats Double)

-- | Signal triggered when the <a>resourceTotalWaitTime</a> and
--   <a>resourceWaitTime</a> properties change.
resourceWaitTimeChanged_ :: Resource s -> Signal ()

-- | Signal triggered when one of the resource counters changes.
resourceChanged_ :: Resource s -> Signal ()
instance Eq (Resource s)


-- | Tested with: GHC 7.10.1
--   
--   This module defines an optimised version of the resource which can be
--   acquired and then released by the discontinuous process
--   <a>Process</a>. The resource can be either limited by the upper bound
--   (run-time check), or it can have no upper bound. The latter is useful
--   for modeling the infinite queue, for example.
--   
--   The module is optimised in the sense that this kind of the resource
--   has neither additional signals, nor counters that would may slow down
--   the simulation.
module Simulation.Aivika.Resource.Base

-- | The ordinary FCFS (First Come - First Serviced) resource.
type FCFSResource = Resource FCFS

-- | The ordinary LCFS (Last Come - First Serviced) resource.
type LCFSResource = Resource LCFS

-- | The SIRO (Serviced in Random Order) resource.
type SIROResource = Resource SIRO

-- | The resource with static priorities.
type PriorityResource = Resource StaticPriorities

-- | Represents the resource with strategy <tt>s</tt> applied for queuing
--   the requests.
data Resource s

-- | Create a new FCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newFCFSResource :: Int -> Simulation FCFSResource

-- | Create a new FCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newFCFSResourceWithMaxCount :: Int -> Maybe Int -> Simulation FCFSResource

-- | Create a new LCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newLCFSResource :: Int -> Simulation LCFSResource

-- | Create a new LCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newLCFSResourceWithMaxCount :: Int -> Maybe Int -> Simulation LCFSResource

-- | Create a new SIRO resource with the specified initial count which
--   value becomes the upper bound as well.
newSIROResource :: Int -> Simulation SIROResource

-- | Create a new SIRO resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newSIROResourceWithMaxCount :: Int -> Maybe Int -> Simulation SIROResource

-- | Create a new priority resource with the specified initial count which
--   value becomes the upper bound as well.
newPriorityResource :: Int -> Simulation PriorityResource

-- | Create a new priority resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newPriorityResourceWithMaxCount :: Int -> Maybe Int -> Simulation PriorityResource

-- | Create a new resource with the specified queue strategy and initial
--   count. The last value becomes the upper bound as well.
newResource :: QueueStrategy s => s -> Int -> Simulation (Resource s)

-- | Create a new resource with the specified queue strategy, initial and
--   maximum counts, where <a>Nothing</a> means that the resource has no
--   upper bound.
newResourceWithMaxCount :: QueueStrategy s => s -> Int -> Maybe Int -> Simulation (Resource s)

-- | Return the strategy applied for queuing the requests.
resourceStrategy :: Resource s -> s

-- | Return the maximum count of the resource, where <a>Nothing</a> means
--   that the resource has no upper bound.
resourceMaxCount :: Resource s -> Maybe Int

-- | Return the current count of the resource.
resourceCount :: Resource s -> Event Int

-- | Request for the resource decreasing its count in case of success,
--   otherwise suspending the discontinuous process until some other
--   process releases the resource.
requestResource :: EnqueueStrategy s => Resource s -> Process ()

-- | Request with the priority for the resource decreasing its count in
--   case of success, otherwise suspending the discontinuous process until
--   some other process releases the resource.
requestResourceWithPriority :: PriorityQueueStrategy s p => Resource s -> p -> Process ()

-- | Try to request for the resource decreasing its count in case of
--   success and returning <a>True</a> in the <a>Event</a> monad;
--   otherwise, returning <a>False</a>.
tryRequestResourceWithinEvent :: Resource s -> Event Bool

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResource :: DequeueStrategy s => Resource s -> Process ()

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResourceWithinEvent :: DequeueStrategy s => Resource s -> Event ()

-- | Acquire the resource, perform some action and safely release the
--   resource in the end, even if the <a>IOException</a> was raised within
--   the action.
usingResource :: EnqueueStrategy s => Resource s -> Process a -> Process a

-- | Acquire the resource with the specified priority, perform some action
--   and safely release the resource in the end, even if the
--   <a>IOException</a> was raised within the action.
usingResourceWithPriority :: PriorityQueueStrategy s p => Resource s -> p -> Process a -> Process a

-- | Increase the count of available resource by the specified number,
--   invoking the awaiting processes as needed.
incResourceCount :: DequeueStrategy s => Resource s -> Int -> Event ()

-- | Decrease the count of available resource by the specified number,
--   waiting for the processes capturing the resource as needed.
decResourceCount :: EnqueueStrategy s => Resource s -> Int -> Process ()
instance Eq (Resource s)


-- | Tested with: GHC 7.10.1
--   
--   The <a>Task</a> value represents a process that was already started in
--   background. We can check the completion of the task, receive
--   notifications about changing its state and even suspend an outer
--   process awaiting the final result of the task. It complements the
--   <a>Process</a> monad as it allows immediately continuing the main
--   computation without suspension.
module Simulation.Aivika.Task

-- | The task represents a process that was already started in background.
data Task a

-- | Represents the result of the task.
data TaskResult a

-- | the task was successfully completed and it returned the specified
--   result
TaskCompleted :: a -> TaskResult a

-- | the specified exception was raised when performing the task.
TaskError :: IOException -> TaskResult a

-- | the task was cancelled
TaskCancelled :: TaskResult a

-- | Return an identifier for the process that was launched in background
--   for this task.
taskId :: Task a -> ProcessId

-- | Try to get the task result immediately without suspension.
tryGetTaskResult :: Task a -> Event (Maybe (TaskResult a))

-- | Return the task result suspending the outer process if required.
taskResult :: Task a -> Process (TaskResult a)

-- | Return a signal that notifies about receiving the result of the task.
taskResultReceived :: Task a -> Signal (TaskResult a)

-- | Return an outer process that behaves like the task itself, for
--   example, when the task is cancelled if the outer process is cancelled.
taskProcess :: Task a -> Process a

-- | Cancel the task.
cancelTask :: Task a -> Event ()

-- | Test whether the task was cancelled.
taskCancelled :: Task a -> Event Bool

-- | Run the process in background and return the corresponded task
--   immediately.
runTask :: Process a -> Event (Task a)

-- | Run the process with the specified identifier in background and return
--   the corresponded task immediately.
runTaskUsingId :: ProcessId -> Process a -> Event (Task a)

-- | Run a child process in background and return immediately the
--   corresponded task.
spawnTask :: Process a -> Process (Task a)

-- | Run using the specified identifier a child process in background and
--   return immediately the corresponded task.
spawnTaskUsingId :: ProcessId -> Process a -> Process (Task a)

-- | Run a child process in background and return immediately the
--   corresponded task.
spawnTaskWith :: ContCancellation -> Process a -> Process (Task a)

-- | Run using the specified identifier a child process in background and
--   return immediately the corresponded task.
spawnTaskUsingIdWith :: ContCancellation -> ProcessId -> Process a -> Process (Task a)

-- | Enqueue the process that will be started at the specified time from
--   the event queue. It returns the corresponded task immediately.
enqueueTask :: Double -> Process a -> Event (Task a)

-- | Enqueue the process that will be started at the specified time with
--   the given identifier from the event queue. It returns the corresponded
--   task immediately.
enqueueTaskUsingId :: Double -> ProcessId -> Process a -> Event (Task a)

-- | Return the result of two parallel tasks.
taskParallelResult :: Task a -> Task a -> Process (TaskResult a, Task a)

-- | Return an outer process for two parallel tasks returning the result of
--   the first finished task and the rest task in pair.
taskParallelProcess :: Task a -> Task a -> Process (a, Task a)


-- | Tested with: GHC 7.10.1
--   
--   This module defines the preemptible resource.
--   
--   The module is optimised in the sense that this kind of the resource
--   has neither additional signals, nor counters that would may slow down
--   the simulation.
module Simulation.Aivika.Resource.Preemption.Base

-- | Represents a preemptible resource.
data Resource

-- | Create a new resource with the specified initial count that becomes
--   the upper bound as well.
newResource :: Int -> Simulation Resource

-- | Create a new resource with the specified initial and maximum counts,
--   where <a>Nothing</a> means that the resource has no upper bound.
newResourceWithMaxCount :: Int -> Maybe Int -> Simulation Resource

-- | Return the maximum count of the resource, where <a>Nothing</a> means
--   that the resource has no upper bound.
resourceMaxCount :: Resource -> Maybe Int

-- | Return the current count of the resource.
resourceCount :: Resource -> Event Int

-- | Request with the priority for the resource decreasing its count in
--   case of success, otherwise suspending the discontinuous process until
--   some other process releases the resource.
--   
--   It may preempt another process if the latter aquired the resource
--   before but had a lower priority. Then the current process takes an
--   ownership of the resource.
requestResourceWithPriority :: Resource -> Double -> Process ()

-- | Release the resource increasing its count and resuming one of the
--   previously suspended or preempted processes as possible.
releaseResource :: Resource -> Process ()

-- | Acquire the resource with the specified priority, perform some action
--   and safely release the resource in the end, even if the
--   <a>IOException</a> was raised within the action.
usingResourceWithPriority :: Resource -> Double -> Process a -> Process a

-- | Increase the count of available resource by the specified number,
--   invoking the awaiting and preempted processes according to their
--   priorities as needed.
incResourceCount :: Resource -> Int -> Event ()

-- | Decrease the count of available resource by the specified number,
--   preempting the processes according to their priorities as needed.
decResourceCount :: Resource -> Int -> Event ()

-- | Alter the resource count either increasing or decreasing it by calling
--   <a>incResourceCount</a> or <a>decResourceCount</a> respectively.
alterResourceCount :: Resource -> Int -> Event ()
instance Eq ResourceActingItem
instance Eq Resource


-- | Tested with: GHC 7.10.1
--   
--   This module defines a queue that can use the specified strategies. So,
--   having only the <a>FCFS</a>, <a>LCFS</a>, <a>SIRO</a> and
--   <a>StaticPriorities</a> strategies, you can build 4 x 4 x 4 = 64
--   different types of the queue, each of them will have its own
--   behaviour.
module Simulation.Aivika.Queue

-- | A type synonym for the ordinary FIFO queue also known as the FCFS
--   (First Come - First Serviced) queue.
type FCFSQueue a = Queue FCFS FCFS FCFS a

-- | A type synonym for the ordinary LIFO queue also known as the LCFS
--   (Last Come - First Serviced) queue.
type LCFSQueue a = Queue FCFS LCFS FCFS a

-- | A type synonym for the SIRO (Serviced in Random Order) queue.
type SIROQueue a = Queue FCFS SIRO FCFS a

-- | A type synonym for the queue with static priorities applied when
--   storing the elements in the queue.
type PriorityQueue a = Queue FCFS StaticPriorities FCFS a

-- | Represents a queue using the specified strategies for enqueueing
--   (input), <tt>si</tt>, internal storing (in memory), <tt>sm</tt>, and
--   dequeueing (output), <tt>so</tt>, where <tt>a</tt> denotes the type of
--   items stored in the queue.
data Queue si sm so a

-- | Create a new FCFS queue with the specified capacity.
newFCFSQueue :: Int -> Event (FCFSQueue a)

-- | Create a new LCFS queue with the specified capacity.
newLCFSQueue :: Int -> Event (LCFSQueue a)

-- | Create a new SIRO queue with the specified capacity.
newSIROQueue :: Int -> Event (SIROQueue a)

-- | Create a new priority queue with the specified capacity.
newPriorityQueue :: Int -> Event (PriorityQueue a)

-- | Create a new queue with the specified strategies and capacity.
newQueue :: (QueueStrategy si, QueueStrategy sm, QueueStrategy so) => si -> sm -> so -> Int -> Event (Queue si sm so a)

-- | The strategy applied to the enqueueing (input) processes when the
--   queue is full.
enqueueStrategy :: Queue si sm so a -> si

-- | The strategy applied when storing (in memory) items in the queue.
enqueueStoringStrategy :: Queue si sm so a -> sm

-- | The strategy applied to the dequeueing (output) processes when the
--   queue is empty.
dequeueStrategy :: Queue si sm so a -> so

-- | Test whether the queue is empty.
--   
--   See also <a>queueNullChanged</a> and <a>queueNullChanged_</a>.
queueNull :: Queue si sm so a -> Event Bool

-- | Test whether the queue is full.
--   
--   See also <a>queueFullChanged</a> and <a>queueFullChanged_</a>.
queueFull :: Queue si sm so a -> Event Bool

-- | The queue capacity.
queueMaxCount :: Queue si sm so a -> Int

-- | Return the current queue size.
--   
--   See also <a>queueCountStats</a>, <a>queueCountChanged</a> and
--   <a>queueCountChanged_</a>.
queueCount :: Queue si sm so a -> Event Int

-- | Return the queue size statistics.
queueCountStats :: Queue si sm so a -> Event (TimingStats Int)

-- | Return the total number of input items that were enqueued.
--   
--   See also <a>enqueueCountChanged</a> and <a>enqueueCountChanged_</a>.
enqueueCount :: Queue si sm so a -> Event Int

-- | Return the number of lost items.
--   
--   See also <a>enqueueLostCountChanged</a> and
--   <a>enqueueLostCountChanged_</a>.
enqueueLostCount :: Queue si sm so a -> Event Int

-- | Return the total number of input items that were stored.
--   
--   See also <a>enqueueStoreCountChanged</a> and
--   <a>enqueueStoreCountChanged_</a>.
enqueueStoreCount :: Queue si sm so a -> Event Int

-- | Return the total number of requests for dequeueing the items, not
--   taking into account the failed attempts to dequeue immediately without
--   suspension.
--   
--   See also <a>dequeueCountChanged</a> and <a>dequeueCountChanged_</a>.
dequeueCount :: Queue si sm so a -> Event Int

-- | Return the total number of output items that were actually dequeued.
--   
--   See also <a>dequeueExtractCountChanged</a> and
--   <a>dequeueExtractCountChanged_</a>.
dequeueExtractCount :: Queue si sm so a -> Event Int

-- | Return the load factor: the queue size divided by its maximum size.
--   
--   See also <a>queueLoadFactorChanged</a> and
--   <a>queueLoadFactorChanged_</a>.
queueLoadFactor :: Queue si sm so a -> Event Double

-- | Return the rate of the input items that were enqueued: how many items
--   per time.
enqueueRate :: Queue si sm so a -> Event Double

-- | Return the rate of the items that were stored: how many items per
--   time.
enqueueStoreRate :: Queue si sm so a -> Event Double

-- | Return the rate of the requests for dequeueing the items: how many
--   requests per time. It does not include the failed attempts to dequeue
--   immediately without suspension.
dequeueRate :: Queue si sm so a -> Event Double

-- | Return the rate of the output items that were actually dequeued: how
--   many items per time.
dequeueExtractRate :: Queue si sm so a -> Event Double

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
--   
--   See also <a>queueWaitTimeChanged</a> and <a>queueWaitTimeChanged_</a>.
queueWaitTime :: Queue si sm so a -> Event (SamplingStats Double)

-- | Return the total wait time from the time at which the enqueueing
--   operation was initiated to the time at which the item was dequeued.
--   
--   In some sense, <tt>queueTotalWaitTime == enqueueWaitTime +
--   queueWaitTime</tt>.
--   
--   See also <a>queueTotalWaitTimeChanged</a> and
--   <a>queueTotalWaitTimeChanged_</a>.
queueTotalWaitTime :: Queue si sm so a -> Event (SamplingStats Double)

-- | Return the enqueue wait time from the time at which the enqueueing
--   operation was initiated to the time at which the item was stored in
--   the queue.
--   
--   See also <a>enqueueWaitTimeChanged</a> and
--   <a>enqueueWaitTimeChanged_</a>.
enqueueWaitTime :: Queue si sm so a -> Event (SamplingStats Double)

-- | Return the dequeue wait time from the time at which the item was
--   requested for dequeueing to the time at which it was actually
--   dequeued.
--   
--   See also <a>dequeueWaitTimeChanged</a> and
--   <a>dequeueWaitTimeChanged_</a>.
dequeueWaitTime :: Queue si sm so a -> Event (SamplingStats Double)

-- | Return a long-term average queue rate calculated as the average queue
--   size divided by the average wait time.
--   
--   This value may be less than the actual arrival rate as the queue is
--   finite and new arrivals may be locked while the queue remains full.
--   
--   See also <a>queueRateChanged</a> and <a>queueRateChanged_</a>.
queueRate :: Queue si sm so a -> Event Double

-- | Dequeue suspending the process if the queue is empty.
dequeue :: (DequeueStrategy si, DequeueStrategy sm, EnqueueStrategy so) => Queue si sm so a -> Process a

-- | Dequeue with the output priority suspending the process if the queue
--   is empty.
dequeueWithOutputPriority :: (DequeueStrategy si, DequeueStrategy sm, PriorityQueueStrategy so po) => Queue si sm so a -> po -> Process a

-- | Try to dequeue immediately.
tryDequeue :: (DequeueStrategy si, DequeueStrategy sm) => Queue si sm so a -> Event (Maybe a)

-- | Enqueue the item suspending the process if the queue is full.
enqueue :: (EnqueueStrategy si, EnqueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Process ()

-- | Enqueue with the input priority the item suspending the process if the
--   queue is full.
enqueueWithInputPriority :: (PriorityQueueStrategy si pi, EnqueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> pi -> a -> Process ()

-- | Enqueue with the storing priority the item suspending the process if
--   the queue is full.
enqueueWithStoringPriority :: (EnqueueStrategy si, PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue si sm so a -> pm -> a -> Process ()

-- | Enqueue with the input and storing priorities the item suspending the
--   process if the queue is full.
enqueueWithInputStoringPriorities :: (PriorityQueueStrategy si pi, PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue si sm so a -> pi -> pm -> a -> Process ()

-- | Try to enqueue the item. Return <a>False</a> in the monad if the queue
--   is full.
tryEnqueue :: (EnqueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Event Bool

-- | Try to enqueue with the storing priority the item. Return <a>False</a>
--   in the monad if the queue is full.
tryEnqueueWithStoringPriority :: (PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue si sm so a -> pm -> a -> Event Bool

-- | Try to enqueue the item. If the queue is full then the item will be
--   lost and <a>False</a> will be returned.
enqueueOrLost :: (EnqueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Event Bool

-- | Try to enqueue the item. If the queue is full then the item will be
--   lost.
enqueueOrLost_ :: (EnqueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Event ()

-- | Try to enqueue with the storing priority the item. If the queue is
--   full then the item will be lost and <a>False</a> will be returned.
enqueueWithStoringPriorityOrLost :: (PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue si sm so a -> pm -> a -> Event Bool

-- | Try to enqueue with the storing priority the item. If the queue is
--   full then the item will be lost.
enqueueWithStoringPriorityOrLost_ :: (PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue si sm so a -> pm -> a -> Event ()

-- | Remove the item from the queue and return a flag indicating whether
--   the item was found and actually removed.
queueDelete :: (Eq a, DequeueStrategy si, DeletingQueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Event Bool

-- | Remove the specified item from the queue.
queueDelete_ :: (Eq a, DequeueStrategy si, DeletingQueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> a -> Event ()

-- | Remove an item satisfying the specified predicate and return the item
--   if found.
queueDeleteBy :: (DequeueStrategy si, DeletingQueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> (a -> Bool) -> Event (Maybe a)

-- | Remove an item satisfying the specified predicate.
queueDeleteBy_ :: (DequeueStrategy si, DeletingQueueStrategy sm, DequeueStrategy so) => Queue si sm so a -> (a -> Bool) -> Event ()

-- | Clear the queue immediately.
clearQueue :: (DequeueStrategy si, DequeueStrategy sm) => Queue si sm so a -> Event ()

-- | Wait while the queue is full.
waitWhileFullQueue :: Queue si sm so a -> Process ()

-- | Return the summary for the queue with desciption of its properties and
--   activities using the specified indent.
queueSummary :: (Show si, Show sm, Show so) => Queue si sm so a -> Int -> Event ShowS

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged :: Queue si sm so a -> Signal Bool

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueFull</a> property value has changed.
queueFullChanged :: Queue si sm so a -> Signal Bool

-- | Signal when the <a>queueFull</a> property value has changed.
queueFullChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>enqueueCount</a> property value has changed.
enqueueCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>enqueueCount</a> property value has changed.
enqueueCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>enqueueLostCount</a> property value has changed.
enqueueLostCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>enqueueLostCount</a> property value has changed.
enqueueLostCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged :: Queue si sm so a -> Signal Int

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueLoadFactor</a> property value has changed.
queueLoadFactorChanged :: Queue si sm so a -> Signal Double

-- | Signal when the <a>queueLoadFactor</a> property value has changed.
queueLoadFactorChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged :: Queue si sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueTotalWaitTime</a> property value has changed.
queueTotalWaitTimeChanged :: Queue si sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>queueTotalWaitTime</a> property value has changed.
queueTotalWaitTimeChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>enqueueWaitTime</a> property value has changed.
enqueueWaitTimeChanged :: Queue si sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>enqueueWaitTime</a> property value has changed.
enqueueWaitTimeChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged :: Queue si sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged_ :: Queue si sm so a -> Signal ()

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged :: Queue si sm so a -> Signal Double

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged_ :: Queue si sm so a -> Signal ()

-- | Return a signal that notifies when the enqueuing operation is
--   initiated.
enqueueInitiated :: Queue si sm so a -> Signal a

-- | Return a signal that notifies when the enqueuing operation is
--   completed and the item is stored in the internal memory of the queue.
enqueueStored :: Queue si sm so a -> Signal a

-- | Return a signal which notifies that the item was lost when attempting
--   to add it to the full queue with help of <a>enqueueOrLost</a>,
--   <a>enqueueOrLost_</a> or similar functions that imply that the element
--   can be lost. All their names are ending with <tt>OrLost</tt> or
--   <tt>OrLost_</tt>.
--   
--   In other cases the enqueued items are not lost but the corresponded
--   process can suspend until the internal queue storage is freed.
--   Although there is one exception from this rule. If the process trying
--   to enqueue a new element was suspended but then canceled through
--   <a>cancelProcess</a> from the outside then the item will not be added.
enqueueLost :: Queue si sm so a -> Signal a

-- | Return a signal that notifies when the dequeuing operation was
--   requested.
dequeueRequested :: Queue si sm so a -> Signal ()

-- | Return a signal that notifies when the item was extracted from the
--   internal storage of the queue and prepared for immediate receiving by
--   the dequeuing process.
dequeueExtracted :: Queue si sm so a -> Signal a

-- | Signal whenever any property of the queue changes.
--   
--   The property must have the corresponded signal. There are also
--   characteristics similar to the properties but that have no signals. As
--   a rule, such characteristics already depend on the simulation time and
--   therefore they may change at any time point.
queueChanged_ :: Queue si sm so a -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines an infinite queue that can use the specified
--   strategies.
module Simulation.Aivika.Queue.Infinite

-- | A type synonym for the ordinary FIFO queue also known as the FCFS
--   (First Come - First Serviced) queue.
type FCFSQueue a = Queue FCFS FCFS a

-- | A type synonym for the ordinary LIFO queue also known as the LCFS
--   (Last Come - First Serviced) queue.
type LCFSQueue a = Queue LCFS FCFS a

-- | A type synonym for the SIRO (Serviced in Random Order) queue.
type SIROQueue a = Queue SIRO FCFS a

-- | A type synonym for the queue with static priorities applied when
--   storing the elements in the queue.
type PriorityQueue a = Queue StaticPriorities FCFS a

-- | Represents an infinite queue using the specified strategies for
--   internal storing (in memory), <tt>sm</tt>, and dequeueing (output),
--   <tt>so</tt>, where <tt>a</tt> denotes the type of items stored in the
--   queue.
data Queue sm so a

-- | Create a new infinite FCFS queue.
newFCFSQueue :: Event (FCFSQueue a)

-- | Create a new infinite LCFS queue.
newLCFSQueue :: Event (LCFSQueue a)

-- | Create a new infinite SIRO queue.
newSIROQueue :: Event (SIROQueue a)

-- | Create a new infinite priority queue.
newPriorityQueue :: Event (PriorityQueue a)

-- | Create a new infinite queue with the specified strategies.
newQueue :: (QueueStrategy sm, QueueStrategy so) => sm -> so -> Event (Queue sm so a)

-- | The strategy applied when storing (in memory) items in the queue.
enqueueStoringStrategy :: Queue sm so a -> sm

-- | The strategy applied to the dequeueing (output) processes.
dequeueStrategy :: Queue sm so a -> so

-- | Test whether the queue is empty.
--   
--   See also <a>queueNullChanged</a> and <a>queueNullChanged_</a>.
queueNull :: Queue sm so a -> Event Bool

-- | Return the current queue size.
--   
--   See also <a>queueCountStats</a>, <a>queueCountChanged</a> and
--   <a>queueCountChanged_</a>.
queueCount :: Queue sm so a -> Event Int

-- | Return the queue size statistics.
queueCountStats :: Queue sm so a -> Event (TimingStats Int)

-- | Return the total number of input items that were stored.
--   
--   See also <a>enqueueStoreCountChanged</a> and
--   <a>enqueueStoreCountChanged_</a>.
enqueueStoreCount :: Queue sm so a -> Event Int

-- | Return the total number of requests for dequeueing the items, not
--   taking into account the failed attempts to dequeue immediately without
--   suspension.
--   
--   See also <a>dequeueCountChanged</a> and <a>dequeueCountChanged_</a>.
dequeueCount :: Queue sm so a -> Event Int

-- | Return the total number of output items that were actually dequeued.
--   
--   See also <a>dequeueExtractCountChanged</a> and
--   <a>dequeueExtractCountChanged_</a>.
dequeueExtractCount :: Queue sm so a -> Event Int

-- | Return the rate of the items that were stored: how many items per
--   time.
enqueueStoreRate :: Queue sm so a -> Event Double

-- | Return the rate of the requests for dequeueing the items: how many
--   requests per time. It does not include the failed attempts to dequeue
--   immediately without suspension.
dequeueRate :: Queue sm so a -> Event Double

-- | Return the rate of the output items that were dequeued: how many items
--   per time.
dequeueExtractRate :: Queue sm so a -> Event Double

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
--   
--   See also <a>queueWaitTimeChanged</a> and <a>queueWaitTimeChanged_</a>.
queueWaitTime :: Queue sm so a -> Event (SamplingStats Double)

-- | Return the dequeue wait time from the time at which the item was
--   requested for dequeueing to the time at which it was actually
--   dequeued.
--   
--   See also <a>dequeueWaitTimeChanged</a> and
--   <a>dequeueWaitTimeChanged_</a>.
dequeueWaitTime :: Queue sm so a -> Event (SamplingStats Double)

-- | Return a long-term average queue rate calculated as the average queue
--   size divided by the average wait time.
--   
--   See also <a>queueRateChanged</a> and <a>queueRateChanged_</a>.
queueRate :: Queue sm so a -> Event Double

-- | Dequeue suspending the process if the queue is empty.
dequeue :: (DequeueStrategy sm, EnqueueStrategy so) => Queue sm so a -> Process a

-- | Dequeue with the output priority suspending the process if the queue
--   is empty.
dequeueWithOutputPriority :: (DequeueStrategy sm, PriorityQueueStrategy so po) => Queue sm so a -> po -> Process a

-- | Try to dequeue immediately.
tryDequeue :: DequeueStrategy sm => Queue sm so a -> Event (Maybe a)

-- | Enqueue the item.
enqueue :: (EnqueueStrategy sm, DequeueStrategy so) => Queue sm so a -> a -> Event ()

-- | Enqueue with the storing priority the item.
enqueueWithStoringPriority :: (PriorityQueueStrategy sm pm, DequeueStrategy so) => Queue sm so a -> pm -> a -> Event ()

-- | Remove the item from the queue and return a flag indicating whether
--   the item was found and actually removed.
queueDelete :: (Eq a, DeletingQueueStrategy sm, DequeueStrategy so) => Queue sm so a -> a -> Event Bool

-- | Remove the specified item from the queue.
queueDelete_ :: (Eq a, DeletingQueueStrategy sm, DequeueStrategy so) => Queue sm so a -> a -> Event ()

-- | Remove an item satisfying the specified predicate and return the item
--   if found.
queueDeleteBy :: (DeletingQueueStrategy sm, DequeueStrategy so) => Queue sm so a -> (a -> Bool) -> Event (Maybe a)

-- | Remove an item satisfying the specified predicate.
queueDeleteBy_ :: (DeletingQueueStrategy sm, DequeueStrategy so) => Queue sm so a -> (a -> Bool) -> Event ()

-- | Clear the queue immediately.
clearQueue :: DequeueStrategy sm => Queue sm so a -> Event ()

-- | Return the summary for the queue with desciption of its properties and
--   activities using the specified indent.
queueSummary :: (Show sm, Show so) => Queue sm so a -> Int -> Event ShowS

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged :: Queue sm so a -> Signal Bool

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged :: Queue sm so a -> Signal Int

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged :: Queue sm so a -> Signal Int

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged :: Queue sm so a -> Signal Int

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged :: Queue sm so a -> Signal Int

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged :: Queue sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged :: Queue sm so a -> Signal (SamplingStats Double)

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged_ :: Queue sm so a -> Signal ()

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged :: Queue sm so a -> Signal Double

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged_ :: Queue sm so a -> Signal ()

-- | Return a signal that notifies when the enqueued item is stored in the
--   internal memory of the queue.
enqueueStored :: Queue sm so a -> Signal a

-- | Return a signal that notifies when the dequeuing operation was
--   requested.
dequeueRequested :: Queue sm so a -> Signal ()

-- | Return a signal that notifies when the item was extracted from the
--   internal storage of the queue and prepared for immediate receiving by
--   the dequeuing process.
dequeueExtracted :: Queue sm so a -> Signal a

-- | Signal whenever any property of the queue changes.
--   
--   The property must have the corresponded signal. There are also
--   characteristics similar to the properties but that have no signals. As
--   a rule, such characteristics already depend on the simulation time and
--   therefore they may change at any time point.
queueChanged_ :: Queue sm so a -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines the preemptible resource.
module Simulation.Aivika.Resource.Preemption

-- | Represents a preemptible resource.
data Resource

-- | Create a new resource with the specified initial count that becomes
--   the upper bound as well.
newResource :: Int -> Event Resource

-- | Create a new resource with the specified initial and maximum counts,
--   where <a>Nothing</a> means that the resource has no upper bound.
newResourceWithMaxCount :: Int -> Maybe Int -> Event Resource

-- | Return the maximum count of the resource, where <a>Nothing</a> means
--   that the resource has no upper bound.
resourceMaxCount :: Resource -> Maybe Int

-- | Return the current available count of the resource.
resourceCount :: Resource -> Event Int

-- | Return the statistics for the available count of the resource.
resourceCountStats :: Resource -> Event (TimingStats Int)

-- | Return the current utilisation count of the resource.
resourceUtilisationCount :: Resource -> Event Int

-- | Return the statistics for the utilisation count of the resource.
resourceUtilisationCountStats :: Resource -> Event (TimingStats Int)

-- | Return the current queue length of the resource.
resourceQueueCount :: Resource -> Event Int

-- | Return the statistics for the queue length of the resource.
resourceQueueCountStats :: Resource -> Event (TimingStats Int)

-- | Return the total wait time of the resource.
resourceTotalWaitTime :: Resource -> Event Double

-- | Return the statistics for the wait time of the resource.
resourceWaitTime :: Resource -> Event (SamplingStats Double)

-- | Request with the priority for the resource decreasing its count in
--   case of success, otherwise suspending the discontinuous process until
--   some other process releases the resource.
--   
--   It may preempt another process if the latter aquired the resource
--   before but had a lower priority. Then the current process takes an
--   ownership of the resource.
requestResourceWithPriority :: Resource -> Double -> Process ()

-- | Release the resource increasing its count and resuming one of the
--   previously suspended or preempted processes as possible.
releaseResource :: Resource -> Process ()

-- | Acquire the resource with the specified priority, perform some action
--   and safely release the resource in the end, even if the
--   <a>IOException</a> was raised within the action.
usingResourceWithPriority :: Resource -> Double -> Process a -> Process a

-- | Increase the count of available resource by the specified number,
--   invoking the awaiting and preempted processes according to their
--   priorities as needed.
incResourceCount :: Resource -> Int -> Event ()

-- | Decrease the count of available resource by the specified number,
--   preempting the processes according to their priorities as needed.
decResourceCount :: Resource -> Int -> Event ()

-- | Alter the resource count either increasing or decreasing it by calling
--   <a>incResourceCount</a> or <a>decResourceCount</a> respectively.
alterResourceCount :: Resource -> Int -> Event ()

-- | Signal triggered when the <a>resourceCount</a> property changes.
resourceCountChanged :: Resource -> Signal Int

-- | Signal triggered when the <a>resourceCount</a> property changes.
resourceCountChanged_ :: Resource -> Signal ()

-- | Signal triggered when the <a>resourceUtilisationCount</a> property
--   changes.
resourceUtilisationCountChanged :: Resource -> Signal Int

-- | Signal triggered when the <a>resourceUtilisationCount</a> property
--   changes.
resourceUtilisationCountChanged_ :: Resource -> Signal ()

-- | Signal triggered when the <a>resourceQueueCount</a> property changes.
resourceQueueCountChanged :: Resource -> Signal Int

-- | Signal triggered when the <a>resourceQueueCount</a> property changes.
resourceQueueCountChanged_ :: Resource -> Signal ()

-- | Signal triggered when the <a>resourceTotalWaitTime</a> and
--   <a>resourceWaitTime</a> properties change.
resourceWaitTimeChanged :: Resource -> Signal (SamplingStats Double)

-- | Signal triggered when the <a>resourceTotalWaitTime</a> and
--   <a>resourceWaitTime</a> properties change.
resourceWaitTimeChanged_ :: Resource -> Signal ()

-- | Signal triggered when one of the resource counters changes.
resourceChanged_ :: Resource -> Signal ()
instance Eq ResourceActingItem
instance Eq Resource


-- | Tested with: GHC 7.10.1
--   
--   This module defines auxiliary functions such as interpolation ones
--   that complement the memoization, for example. There are scan functions
--   too.
module Simulation.Aivika.Dynamics.Extra

-- | Return the initial value.
initDynamics :: Dynamics a -> Dynamics a

-- | Discretize the computation in the integration time points.
discreteDynamics :: Dynamics a -> Dynamics a

-- | Interpolate the computation based on the integration time points only.
--   Unlike the <a>discreteDynamics</a> function it knows about the
--   intermediate time points that are used in the Runge-Kutta method.
interpolateDynamics :: Dynamics a -> Dynamics a

-- | Like the standard <a>scanl</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the third argument, which should be either function
--   <tt>memo0Dynamics</tt> or its unboxed version.
scanDynamics :: (a -> b -> a) -> a -> (Dynamics a -> Simulation (Dynamics a)) -> (Dynamics b -> Simulation (Dynamics a))

-- | Like the standard <a>scanl1</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the second argument, which should be either function
--   <tt>memo0Dynamics</tt> or its unboxed version.
scan1Dynamics :: (a -> a -> a) -> (Dynamics a -> Simulation (Dynamics a)) -> (Dynamics a -> Simulation (Dynamics a))


-- | Tested with: GHC 7.10.1
--   
--   This module defines memo functions. The memoization creates such
--   <a>Dynamics</a> computations, which values are cached in the
--   integration time points. Then these values are interpolated in all
--   other time points.
module Simulation.Aivika.Dynamics.Memo

-- | Memoize and order the computation in the integration time points using
--   the interpolation that knows of the Runge-Kutta method. The values are
--   calculated sequentially starting from <a>starttime</a>.
memoDynamics :: Dynamics e -> Simulation (Dynamics e)

-- | Memoize and order the computation in the integration time points using
--   the <a>discreteDynamics</a> interpolation. It consumes less memory
--   than the <a>memoDynamics</a> function but it is not aware of the
--   Runge-Kutta method. There is a subtle difference when we request for
--   values in the intermediate time points that are used by this method to
--   integrate. In general case you should prefer the <a>memo0Dynamics</a>
--   function above <a>memoDynamics</a>.
memo0Dynamics :: Dynamics e -> Simulation (Dynamics e)

-- | Iterate sequentially the dynamic process with side effects in the
--   integration time points. It is equivalent to a call of the
--   <a>memo0Dynamics</a> function but significantly more efficient, for
--   the array is not created.
iterateDynamics :: Dynamics () -> Simulation (Dynamics ())

-- | Memoize and unzip the computation of pairs, applying the
--   <a>memoDynamics</a> function.
unzipDynamics :: Dynamics (a, b) -> Simulation (Dynamics a, Dynamics b)

-- | Memoize and unzip the computation of pairs, applying the
--   <a>memo0Dynamics</a> function.
unzip0Dynamics :: Dynamics (a, b) -> Simulation (Dynamics a, Dynamics b)


-- | Tested with: GHC 7.10.1
--   
--   This module defines the unboxed memo functions. The memoization
--   creates such <a>Dynamics</a> computations, which values are cached in
--   the integration time points. Then these values are interpolated in all
--   other time points.
module Simulation.Aivika.Dynamics.Memo.Unboxed

-- | Memoize and order the computation in the integration time points using
--   the interpolation that knows of the Runge-Kutta method. The values are
--   calculated sequentially starting from <a>starttime</a>.
memoDynamics :: Unboxed e => Dynamics e -> Simulation (Dynamics e)

-- | Memoize and order the computation in the integration time points using
--   the <a>discreteDynamics</a> interpolation. It consumes less memory
--   than the <a>memoDynamics</a> function but it is not aware of the
--   Runge-Kutta method. There is a subtle difference when we request for
--   values in the intermediate time points that are used by this method to
--   integrate. In general case you should prefer the <a>memo0Dynamics</a>
--   function above <a>memoDynamics</a>.
memo0Dynamics :: Unboxed e => Dynamics e -> Simulation (Dynamics e)


-- | Tested with: GHC 7.10.1
--   
--   This module defines the random functions that always return the same
--   values in the integration time points within a single simulation run.
--   The values for another simulation run will be regenerated anew.
--   
--   For example, the computations returned by these functions can be used
--   in the equations of System Dynamics.
--   
--   Also it is worth noting that the values are generated in a strong
--   order starting from <a>starttime</a> with step <a>dt</a>. This is how
--   the <a>memo0Dynamics</a> function actually works.
module Simulation.Aivika.Dynamics.Random

-- | Computation that generates random numbers distributed uniformly and
--   memoizes the numbers in the integration time points.
memoRandomUniformDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random integer numbers distributed
--   uniformly and memoizes the numbers in the integration time points.
memoRandomUniformIntDynamics :: Dynamics Int -> Dynamics Int -> Simulation (Dynamics Int)

-- | Computation that generates random numbers from the triangular
--   distribution and memoizes the numbers in the integration time points.
memoRandomTriangularDynamics :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random numbers distributed normally and
--   memoizes the numbers in the integration time points.
memoRandomNormalDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random numbers from the lognormal
--   distribution and memoizes the numbers in the integration time points.
memoRandomLogNormalDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates exponential random numbers with the
--   specified mean (the reciprocal of the rate) and memoizes the numbers
--   in the integration time points.
memoRandomExponentialDynamics :: Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates the Erlang random numbers with the
--   specified scale (the reciprocal of the rate) and integer shape but
--   memoizes the numbers in the integration time points.
memoRandomErlangDynamics :: Dynamics Double -> Dynamics Int -> Simulation (Dynamics Double)

-- | Computation that generats the Poisson random numbers with the
--   specified mean and memoizes the numbers in the integration time
--   points.
memoRandomPoissonDynamics :: Dynamics Double -> Simulation (Dynamics Int)

-- | Computation that generates binomial random numbers with the specified
--   probability and trials but memoizes the numbers in the integration
--   time points.
memoRandomBinomialDynamics :: Dynamics Double -> Dynamics Int -> Simulation (Dynamics Int)

-- | Computation that generates random numbers from the Gamma distribution
--   with the specified shape and scale but memoizes the numbers in the
--   integration time points.
memoRandomGammaDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random numbers from the Beta distribution
--   by the specified shape parameters and memoizes the numbers in the
--   integration time points.
memoRandomBetaDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random numbers from the Weibull
--   distribution with the specified shape and scale but memoizes the
--   numbers in the integration time points.
memoRandomWeibullDynamics :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Computation that generates random values from the specified discrete
--   distribution and memoizes the values in the integration time points.
memoRandomDiscreteDynamics :: Unboxed a => Dynamics (DiscretePDF a) -> Simulation (Dynamics a)


-- | Tested with: GHC 7.10.1
--   
--   This module defines integrals and other functions of System Dynamics.
module Simulation.Aivika.SystemDynamics

-- | Compare for equality.
(.==.) :: Eq a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Compare for inequality.
(./=.) :: Eq a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Compare for ordering.
(.<.) :: Ord a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Compare for ordering.
(.>=.) :: Ord a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Compare for ordering.
(.>.) :: Ord a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Compare for ordering.
(.<=.) :: Ord a => Dynamics a -> Dynamics a -> Dynamics Bool

-- | Return the maximum.
maxDynamics :: Ord a => Dynamics a -> Dynamics a -> Dynamics a

-- | Return the minimum.
minDynamics :: Ord a => Dynamics a -> Dynamics a -> Dynamics a

-- | Implement the if-then-else operator.
ifDynamics :: Dynamics Bool -> Dynamics a -> Dynamics a -> Dynamics a

-- | Return an integral with the specified derivative and initial value.
--   
--   To create a loopback, you should use the recursive do-notation. It
--   allows defining the differential equations unordered as in
--   mathematics:
--   
--   <pre>
--   model :: Simulation [Double]
--   model = 
--     mdo a &lt;- integ (- ka * a) 100
--         b &lt;- integ (ka * a - kb * b) 0
--         c &lt;- integ (kb * b) 0
--         let ka = 1
--             kb = 1
--         runDynamicsInStopTime $ sequence [a, b, c]
--   </pre>
integ :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Like <a>integ</a> but allows either setting a new <a>Left</a> integral
--   value, or integrating using the <a>Right</a> derivative directly
--   within computation.
--   
--   This function always uses Euler's method.
integEither :: Dynamics (Either Double Double) -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the first order exponential smooth.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   smoothI x t i =
--     mdo y &lt;- integ ((x - y) / t) i
--         return y
--   </pre>
smoothI :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the first order exponential smooth.
--   
--   This is a simplified version of the <a>smoothI</a> function without
--   specifing the initial value.
smooth :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the third order exponential smooth.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   smooth3I x t i =
--     mdo y  &lt;- integ ((s2 - y) / t') i
--         s2 &lt;- integ ((s1 - s2) / t') i
--         s1 &lt;- integ ((x - s1) / t') i
--         let t' = t / 3.0
--         return y
--   </pre>
smooth3I :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the third order exponential smooth.
--   
--   This is a simplified version of the <a>smooth3I</a> function without
--   specifying the initial value.
smooth3 :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the n'th order exponential smooth.
--   
--   The result is not discrete in that sense that it may change within the
--   integration time interval depending on the integration method used.
--   Probably, you should apply the <a>discreteDynamics</a> function to the
--   result if you want to achieve an effect when the value is not changed
--   within the time interval, which is used sometimes.
smoothNI :: Dynamics Double -> Dynamics Double -> Int -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the n'th order exponential smooth.
--   
--   This is a simplified version of the <a>smoothNI</a> function without
--   specifying the initial value.
smoothN :: Dynamics Double -> Dynamics Double -> Int -> Simulation (Dynamics Double)

-- | Return the first order exponential delay.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   delay1I x t i =
--     mdo y &lt;- integ (x - y / t) (i * t)
--         return $ y / t
--   </pre>
delay1I :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the first order exponential delay.
--   
--   This is a simplified version of the <a>delay1I</a> function without
--   specifying the initial value.
delay1 :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the third order exponential delay.
delay3I :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the third order exponential delay.
--   
--   This is a simplified version of the <a>delay3I</a> function without
--   specifying the initial value.
delay3 :: Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the n'th order exponential delay.
delayNI :: Dynamics Double -> Dynamics Double -> Int -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the n'th order exponential delay.
--   
--   This is a simplified version of the <a>delayNI</a> function without
--   specifying the initial value.
delayN :: Dynamics Double -> Dynamics Double -> Int -> Simulation (Dynamics Double)

-- | Return the forecast.
--   
--   The function has the following definition:
--   
--   <pre>
--   forecast x at hz =
--     do y &lt;- smooth x at
--        return $ x * (1.0 + (x / y - 1.0) / at * hz)
--   </pre>
forecast :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the trend.
--   
--   The function has the following definition:
--   
--   <pre>
--   trend x at i =
--     do y &lt;- smoothI x at (x / (1.0 + i * at))
--        return $ (x / y - 1.0) / at
--   </pre>
trend :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Retun the sum for the difference equation. It is like an integral
--   returned by the <a>integ</a> function, only now the difference is used
--   instead of derivative.
--   
--   As usual, to create a loopback, you should use the recursive
--   do-notation.
diffsum :: (Num a, Unboxed a) => Dynamics a -> Dynamics a -> Simulation (Dynamics a)

-- | Like <a>diffsum</a> but allows either setting a new <a>Left</a> sum
--   value, or adding the <a>Right</a> difference.
diffsumEither :: (Num a, Unboxed a) => Dynamics (Either a a) -> Dynamics a -> Simulation (Dynamics a)

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using linear
--   interpolation.
lookupDynamics :: Dynamics Double -> Array Int (Double, Double) -> Dynamics Double

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using stepwise
--   function.
lookupStepwiseDynamics :: Dynamics Double -> Array Int (Double, Double) -> Dynamics Double

-- | Return the delayed value using the specified lag time.
delay :: Dynamics a -> Dynamics Double -> Dynamics a

-- | Return the delayed value using the specified lag time and initial
--   value. Because of the latter, it allows creating a loop back.
delayI :: Dynamics a -> Dynamics Double -> Dynamics a -> Simulation (Dynamics a)

-- | Computation that returns 0 until the step time and then returns the
--   specified height.
step :: Dynamics Double -> Dynamics Double -> Dynamics Double

-- | Computation that returns 1, starting at the time start, and lasting
--   for the interval width; 0 is returned at all other times.
pulse :: Dynamics Double -> Dynamics Double -> Dynamics Double

-- | Computation that returns 1, starting at the time start, and lasting
--   for the interval width and then repeats this pattern with the
--   specified period; 0 is returned at all other times.
pulseP :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Dynamics Double

-- | Computation that returns 0 until the specified time start and then
--   slopes upward until the end time and then holds constant.
ramp :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Dynamics Double

-- | Return the Net Present Value (NPV) of the stream computed using the
--   specified discount rate, the initial value and some factor (usually
--   1).
--   
--   It is defined in the following way:
--   
--   <pre>
--   npv stream rate init factor =
--     mdo let dt' = liftParameter dt
--         df &lt;- integ (- df * rate) 1
--         accum &lt;- integ (stream * df) init
--         return $ (accum + dt' * stream * df) * factor
--   </pre>
npv :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)

-- | Return the Net Present Value End of period (NPVE) of the stream
--   computed using the specified discount rate, the initial value and some
--   factor.
--   
--   It is defined in the following way:
--   
--   <pre>
--   npve stream rate init factor =
--     mdo let dt' = liftParameter dt
--         df &lt;- integ (- df * rate / (1 + rate * dt')) (1 / (1 + rate * dt'))
--         accum &lt;- integ (stream * df) init
--         return $ (accum + dt' * stream * df) * factor
--   </pre>
npve :: Dynamics Double -> Dynamics Double -> Dynamics Double -> Dynamics Double -> Simulation (Dynamics Double)


-- | Tested with: GHC 7.10.1
--   
--   The module defines the <a>Dynamics</a> monad representing a time
--   varying polymorphic function.
module Simulation.Aivika.Dynamics

-- | A value in the <a>Dynamics</a> monad represents a polymorphic time
--   varying function.
data Dynamics a

-- | A type class to lift the <a>Dynamics</a> computations to other
--   computations.
class DynamicsLift m
liftDynamics :: DynamicsLift m => Dynamics a -> m a

-- | Run the <a>Dynamics</a> computation in the initial time point.
runDynamicsInStartTime :: Dynamics a -> Simulation a

-- | Run the <a>Dynamics</a> computation in the final time point.
runDynamicsInStopTime :: Dynamics a -> Simulation a

-- | Run the <a>Dynamics</a> computation in all integration time points.
runDynamicsInIntegTimes :: Dynamics a -> Simulation [IO a]

-- | Run the <a>Dynamics</a> computation in the specified time point.
runDynamicsInTime :: Double -> Dynamics a -> Simulation a

-- | Run the <a>Dynamics</a> computation in the specified time points.
runDynamicsInTimes :: [Double] -> Dynamics a -> Simulation [IO a]

-- | Exception handling within <a>Dynamics</a> computations.
catchDynamics :: Exception e => Dynamics a -> (e -> Dynamics a) -> Dynamics a

-- | A computation with finalization part like the <a>finally</a> function.
finallyDynamics :: Dynamics a -> Dynamics b -> Dynamics a

-- | Like the standard <a>throw</a> function.
throwDynamics :: Exception e => e -> Dynamics a

-- | Computation that returns the current simulation time.
time :: Dynamics Double

-- | Whether the current time is an integration time.
isTimeInteg :: Dynamics Bool

-- | Return the integration iteration closest to the current simulation
--   time.
integIteration :: Dynamics Int

-- | Return the integration phase for the current simulation time. It is
--   <tt>(-1)</tt> for non-integration time points.
integPhase :: Dynamics Int

-- | Show the debug message with the current simulation time.
traceDynamics :: String -> Dynamics a -> Dynamics a


-- | Tested with: GHC 7.10.1
--   
--   This module defines the random parameters of simulation experiments.
--   
--   To create a parameter that would return the same value within the
--   simulation run, you should memoize the computation with help of
--   <a>memoParameter</a>, which is important for the Monte-Carlo
--   simulation.
--   
--   To create a random function that would return the same values in the
--   integration time points within the simulation run, you should either
--   lift the computation to the <a>Dynamics</a> computation and then
--   memoize it too but using the <a>memo0Dynamics</a> function for that
--   computation, or just take the predefined function that does namely
--   this.
module Simulation.Aivika.Parameter.Random

-- | Computation that generates a new random number distributed uniformly.
randomUniform :: Double -> Double -> Parameter Double

-- | Computation that generates a new random integer number distributed
--   uniformly.
randomUniformInt :: Int -> Int -> Parameter Int

-- | Computation that generates a new random number from the triangular
--   distribution.
randomTriangular :: Double -> Double -> Double -> Parameter Double

-- | Computation that generates a new random number distributed normally.
randomNormal :: Double -> Double -> Parameter Double

-- | Computation that generates a new random number from the lognormal
--   distribution.
randomLogNormal :: Double -> Double -> Parameter Double

-- | Computation that returns a new exponential random number with the
--   specified mean (the reciprocal of the rate).
randomExponential :: Double -> Parameter Double

-- | Computation that returns a new Erlang random number with the specified
--   scale (the reciprocal of the rate) and integer shape.
randomErlang :: Double -> Int -> Parameter Double

-- | Computation that returns a new Poisson random number with the
--   specified mean.
randomPoisson :: Double -> Parameter Int

-- | Computation that returns a new binomial random number with the
--   specified probability and trials.
randomBinomial :: Double -> Int -> Parameter Int

-- | Computation that returns a new random number from the Gamma
--   distribution.
randomGamma :: Double -> Double -> Parameter Double

-- | Computation that returns a new random number from the Beta
--   distribution.
randomBeta :: Double -> Double -> Parameter Double

-- | Computation that returns a new random number from the Weibull
--   distribution.
randomWeibull :: Double -> Double -> Parameter Double

-- | Computation that returns a new random value from the specified
--   discrete distribution.
randomDiscrete :: DiscretePDF a -> Parameter a

-- | Computation that returns <a>True</a> in case of success.
randomTrue :: Double -> Parameter Bool

-- | Computation that returns <a>False</a> in case of success.
randomFalse :: Double -> Parameter Bool


-- | Tested with: GHC 7.10.1
--   
--   This module defines helper functions, which are useful to hold the
--   <a>Process</a> computation for a time interval according to some
--   random distribution.
module Simulation.Aivika.Process.Random

-- | Hold the process for a random time interval distributed uniformly.
randomUniformProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval distributed uniformly.
randomUniformProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval distributed uniformly.
randomUniformIntProcess :: Int -> Int -> Process Int

-- | Hold the process for a random time interval distributed uniformly.
randomUniformIntProcess_ :: Int -> Int -> Process ()

-- | Hold the process for a random time interval having the triangular
--   distribution.
randomTriangularProcess :: Double -> Double -> Double -> Process Double

-- | Hold the process for a random time interval having the triangular
--   distribution.
randomTriangularProcess_ :: Double -> Double -> Double -> Process ()

-- | Hold the process for a random time interval distributed normally.
randomNormalProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval distributed normally.
randomNormalProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval having the lognormal
--   distribution.
randomLogNormalProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval having the lognormal
--   distribution.
randomLogNormalProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval distributed exponentially
--   with the specified mean (the reciprocal of the rate).
randomExponentialProcess :: Double -> Process Double

-- | Hold the process for a random time interval distributed exponentially
--   with the specified mean (the reciprocal of the rate).
randomExponentialProcess_ :: Double -> Process ()

-- | Hold the process for a random time interval having the Erlang
--   distribution with the specified scale (the reciprocal of the rate) and
--   shape parameters.
randomErlangProcess :: Double -> Int -> Process Double

-- | Hold the process for a random time interval having the Erlang
--   distribution with the specified scale (the reciprocal of the rate) and
--   shape parameters.
randomErlangProcess_ :: Double -> Int -> Process ()

-- | Hold the process for a random time interval having the Poisson
--   distribution with the specified mean.
randomPoissonProcess :: Double -> Process Int

-- | Hold the process for a random time interval having the Poisson
--   distribution with the specified mean.
randomPoissonProcess_ :: Double -> Process ()

-- | Hold the process for a random time interval having the binomial
--   distribution with the specified probability and trials.
randomBinomialProcess :: Double -> Int -> Process Int

-- | Hold the process for a random time interval having the binomial
--   distribution with the specified probability and trials.
randomBinomialProcess_ :: Double -> Int -> Process ()

-- | Hold the process for a random time interval having the Gamma
--   distribution with the specified shape and scale.
randomGammaProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval having the Gamma
--   distribution with the specified shape and scale.
randomGammaProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval having the Beta
--   distribution with the specified shape parameters (alpha and beta).
randomBetaProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval having the Beta
--   distribution with the specified shape parameters (alpha and beta).
randomBetaProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval having the Weibull
--   distribution with the specified shape and scale.
randomWeibullProcess :: Double -> Double -> Process Double

-- | Hold the process for a random time interval having the Weibull
--   distribution with the specified shape and scale.
randomWeibullProcess_ :: Double -> Double -> Process ()

-- | Hold the process for a random time interval having the specified
--   discrete distribution.
randomDiscreteProcess :: DiscretePDF Double -> Process Double

-- | Hold the process for a random time interval having the specified
--   discrete distribution.
randomDiscreteProcess_ :: DiscretePDF Double -> Process ()


-- | Tested with: GHC 7.10.1
--   
--   This small utility module allows accumulating the timing statistics
--   based on <a>Signalable</a> data such as the queue size or the number
--   of lost items in the queue.
module Simulation.Aivika.Statistics.Accumulator

-- | Represents an accumulator for the timing statistics.
data TimingStatsAccumulator a

-- | Start gathering the timing statistics from the current simulation
--   time.
newTimingStatsAccumulator :: TimingData a => Signalable a -> Event (TimingStatsAccumulator a)

-- | Return the accumulated statistics.
timingStatsAccumulated :: TimingStatsAccumulator a -> Event (TimingStats a)


-- | Tested with: GHC 7.10.1
--   
--   The module defines something which is most close to the notion of
--   analogous circuit as an opposite to the digital one.
module Simulation.Aivika.Transform

-- | It allows representing an analogous circuit as an opposite to the
--   digital one.
--   
--   This is a transform of one time varying function to another usually
--   specified in the integration time points and then interpolated in
--   other time points with help of one of the memoization functions like
--   <a>memo0Dynamics</a>.
newtype Transform a b
Transform :: (Dynamics a -> Simulation (Dynamics b)) -> Transform a b

-- | Run the transform.
runTransform :: Transform a b -> Dynamics a -> Simulation (Dynamics b)

-- | Return a delayed transform by the specified lag time and initial
--   value.
--   
--   This is actually the <a>delayI</a> function wrapped in the
--   <a>Transform</a> type.
delayTransform :: Dynamics Double -> Dynamics a -> Transform a a

-- | A transform that returns the current modeling time.
timeTransform :: Transform a Double

-- | Return a transform that maps the derivative to an integral by the
--   specified initial value.
--   
--   This is actually the <a>integ</a> function wrapped in the
--   <a>Transform</a> type.
integTransform :: Dynamics Double -> Transform Double Double

-- | Like <a>integTransform</a> but allows either setting a new <a>Left</a>
--   value of the integral, or updating it by the specified <a>Right</a>
--   derivative.
integTransformEither :: Dynamics Double -> Transform (Either Double Double) Double

-- | Return a transform that maps the difference to a sum by the specified
--   initial value.
--   
--   This is actually the <a>diffsum</a> function wrapped in the
--   <a>Transform</a> type.
sumTransform :: (Num a, Unboxed a) => Dynamics a -> Transform a a

-- | Like <a>sumTransform</a> but allows either setting a new <a>Left</a>
--   value of the sum, or updating it by the specified <a>Right</a>
--   difference.
sumTransformEither :: (Num a, Unboxed a) => Dynamics a -> Transform (Either a a) a
instance ArrowLoop Transform
instance Arrow Transform
instance Category Transform


-- | Tested with: GHC 7.10.1
--   
--   This module defines memoization transforms. The memoization creates
--   such <a>Dynamics</a> computations, which values are cached in the
--   integration time points. Then these values are interpolated in all
--   other time points.
module Simulation.Aivika.Transform.Memo

-- | A transform that memoizes and order the computation in the integration
--   time points using the interpolation that knows of the Runge-Kutta
--   method. The values are calculated sequentially starting from
--   <a>starttime</a>.
memoTransform :: Transform e e

-- | A transform that memoizes and order the computation in the integration
--   time points using the <a>discreteDynamics</a> interpolation. It
--   consumes less memory than the <a>memoTransform</a> computation but it
--   is not aware of the Runge-Kutta method. There is a subtle difference
--   when we request for values in the intermediate time points that are
--   used by this method to integrate. In general case you should prefer
--   the <a>memo0Transform</a> computation above <a>memoTransform</a>.
memo0Transform :: Transform e e

-- | A transform that iterates sequentially the dynamic process with side
--   effects in the integration time points. It is equivalent to the
--   <a>memo0Transform</a> computation but significantly more efficient,
--   for the internal array is not created.
iteratingTransform :: Transform () ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines auxiliary computations such as interpolation ones
--   that complement the memoization, for example. There are scan
--   computations too.
module Simulation.Aivika.Transform.Extra

-- | A transform that returns the initial value.
initTransform :: Transform a a

-- | A transform that discretizes the computation in the integration time
--   points.
discreteTransform :: Transform a a

-- | A tranform that interpolates the computation based on the integration
--   time points only. Unlike the <a>discreteTransform</a> computation it
--   knows about the intermediate time points that are used in the
--   Runge-Kutta method.
interpolatingTransform :: Transform a a

-- | Like the standard <a>scanl</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the third argument, which should be either
--   <a>memo0Transform</a> or its unboxed version.
scanTransform :: (a -> b -> a) -> a -> Transform a a -> Transform b a

-- | Like the standard <a>scanl1</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the second argument, which should be either
--   <a>memo0Transform</a> or its unboxed version.
scan1Transform :: (a -> a -> a) -> Transform a a -> Transform a a


-- | Tested with: GHC 7.10.1
--   
--   This module defines the unboxed memoization transforms. The
--   memoization creates such <a>Dynamics</a> computations, which values
--   are cached in the integration time points. Then these values are
--   interpolated in all other time points.
module Simulation.Aivika.Transform.Memo.Unboxed

-- | A transform that memoizes and order the computation in the integration
--   time points using the interpolation that knows of the Runge-Kutta
--   method. The values are calculated sequentially starting from
--   <a>starttime</a>.
memoTransform :: Unboxed e => Transform e e

-- | A transform that memoizes and order the computation in the integration
--   time points using the <a>discreteDynamics</a> interpolation. It
--   consumes less memory than the <a>memoTransform</a> computation but it
--   is not aware of the Runge-Kutta method. There is a subtle difference
--   when we request for values in the intermediate time points that are
--   used by this method to integrate. In general case you should prefer
--   the <a>memo0Transform</a> computation above <a>memoTransform</a>.
memo0Transform :: Unboxed e => Transform e e


-- | Tested with: GHC 7.10.1
--   
--   The <a>Cont</a> monad is a variation of the standard Cont monad and F#
--   async workflow, where the result of applying the continuations is the
--   <a>Event</a> computation.
module Simulation.Aivika.Cont

-- | It defines how the parent and child computations should be cancelled.
data ContCancellation

-- | Cancel the both computations together.
CancelTogether :: ContCancellation

-- | Cancel the child if its parent is cancelled.
CancelChildAfterParent :: ContCancellation

-- | Cancel the parent if its child is cancelled.
CancelParentAfterChild :: ContCancellation

-- | Cancel the computations in isolation.
CancelInIsolation :: ContCancellation

-- | The <a>Cont</a> type is similar to the standard <tt>Cont</tt> monad
--   and F# async workflow but only the result of applying the
--   continuations return the <a>Event</a> computation.
data Cont a


-- | Tested with: GHC 7.10.1
--   
--   The infinite stream of data in time.
module Simulation.Aivika.Stream

-- | Represents an infinite stream of data in time, some kind of the cons
--   cell.
newtype Stream a
Cons :: Process (a, Stream a) -> Stream a

-- | Run the stream.
runStream :: Stream a -> Process (a, Stream a)

-- | An empty stream that never returns data.
emptyStream :: Stream a

-- | Merge two streams applying the <a>FCFS</a> strategy for enqueuing the
--   input data.
mergeStreams :: Stream a -> Stream a -> Stream a

-- | Merge two streams.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>mergeStreams</a> that does
--   namely this.
mergeQueuedStreams :: EnqueueStrategy s => s -> Stream a -> Stream a -> Stream a

-- | Merge two priority streams.
mergePriorityStreams :: PriorityQueueStrategy s p => s -> Stream (p, a) -> Stream (p, a) -> Stream a

-- | Concatenate the input streams applying the <a>FCFS</a> strategy and
--   producing one output stream.
concatStreams :: [Stream a] -> Stream a

-- | Concatenate the input streams producing one output stream.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>concatStreams</a> that does
--   namely this.
concatQueuedStreams :: EnqueueStrategy s => s -> [Stream a] -> Stream a

-- | Concatenate the input priority streams producing one output stream.
concatPriorityStreams :: PriorityQueueStrategy s p => s -> [Stream (p, a)] -> Stream a

-- | Split the input stream into the specified number of output streams
--   after applying the <a>FCFS</a> strategy for enqueuing the output
--   requests.
splitStream :: Int -> Stream a -> Simulation [Stream a]

-- | Split the input stream into the specified number of output streams.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>splitStream</a> that does
--   namely this.
splitStreamQueueing :: EnqueueStrategy s => s -> Int -> Stream a -> Simulation [Stream a]

-- | Split the input stream into a list of output streams using the
--   specified priorities.
splitStreamPrioritising :: PriorityQueueStrategy s p => s -> [Stream p] -> Stream a -> Simulation [Stream a]

-- | Create a stream that will use the specified process identifier. It can
--   be useful to refer to the underlying <a>Process</a> computation which
--   can be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
streamUsingId :: ProcessId -> Stream a -> Stream a

-- | Prefetch the input stream requesting for one more data item in advance
--   while the last received item is not yet fully processed in the chain
--   of streams, usually by the processors.
--   
--   You can think of this as the prefetched stream could place its latest
--   data item in some temporary space for later use, which is very useful
--   for modeling a sequence of separate and independent work places.
prefetchStream :: Stream a -> Stream a

-- | Delay the stream by one step using the specified initial value.
delayStream :: a -> Stream a -> Stream a

-- | Transform a stream so that the resulting stream returns a sequence of
--   arrivals saving the information about the time points at which the
--   original stream items were received by demand.
arrivalStream :: Stream a -> Stream (Arrival a)

-- | Memoize the stream so that it would always return the same data within
--   the simulation run.
memoStream :: Stream a -> Simulation (Stream a)

-- | Zip two streams trying to get data sequentially.
zipStreamSeq :: Stream a -> Stream b -> Stream (a, b)

-- | Zip two streams trying to get data as soon as possible, launching the
--   sub-processes in parallel.
zipStreamParallel :: Stream a -> Stream b -> Stream (a, b)

-- | Zip three streams trying to get data sequentially.
zip3StreamSeq :: Stream a -> Stream b -> Stream c -> Stream (a, b, c)

-- | Zip three streams trying to get data as soon as possible, launching
--   the sub-processes in parallel.
zip3StreamParallel :: Stream a -> Stream b -> Stream c -> Stream (a, b, c)

-- | Unzip the stream.
unzipStream :: Stream (a, b) -> Simulation (Stream a, Stream b)

-- | To form each new portion of data for the output stream, read data
--   sequentially from the input streams.
--   
--   This is a generalization of <a>zipStreamSeq</a>.
streamSeq :: [Stream a] -> Stream [a]

-- | To form each new portion of data for the output stream, read data from
--   the input streams in parallel.
--   
--   This is a generalization of <a>zipStreamParallel</a>.
streamParallel :: [Stream a] -> Stream [a]

-- | Consume the stream. It returns a process that infinitely reads data
--   from the stream and then redirects them to the provided function. It
--   is useful for modeling the process of enqueueing data in the queue
--   from the input stream.
consumeStream :: (a -> Process ()) -> Stream a -> Process ()

-- | Sink the stream. It returns a process that infinitely reads data from
--   the stream. The resulting computation can be a moving force to
--   simulate the whole system of the interconnected streams and
--   processors.
sinkStream :: Stream a -> Process ()

-- | Return a stream of values generated by the specified process.
repeatProcess :: Process a -> Stream a

-- | Map the stream according the specified function.
mapStream :: (a -> b) -> Stream a -> Stream b

-- | Compose the stream.
mapStreamM :: (a -> Process b) -> Stream a -> Stream b

-- | Sequential application.
apStream :: Stream (a -> b) -> Stream a -> Stream b

-- | Sequential application.
apStreamM :: Stream (a -> Process b) -> Stream a -> Stream b

-- | Filter only those data values that satisfy to the specified predicate.
filterStream :: (a -> Bool) -> Stream a -> Stream a

-- | Filter only those data values that satisfy to the specified predicate.
filterStreamM :: (a -> Process Bool) -> Stream a -> Stream a

-- | Return the prefix of the stream of the specified length.
takeStream :: Int -> Stream a -> Stream a

-- | Return the longest prefix of the stream of elements that satisfy the
--   predicate.
takeStreamWhile :: (a -> Bool) -> Stream a -> Stream a

-- | Return the longest prefix of the stream of elements that satisfy the
--   computation.
takeStreamWhileM :: (a -> Process Bool) -> Stream a -> Stream a

-- | Return the suffix of the stream after the specified first elements.
dropStream :: Int -> Stream a -> Stream a

-- | Return the suffix of the stream of elements remaining after
--   <a>takeStreamWhile</a>.
dropStreamWhile :: (a -> Bool) -> Stream a -> Stream a

-- | Return the suffix of the stream of elements remaining after
--   <a>takeStreamWhileM</a>.
dropStreamWhileM :: (a -> Process Bool) -> Stream a -> Stream a

-- | Return a stream consisting of exactly one element and inifinite tail.
singletonStream :: a -> Stream a

-- | Removes one level of the computation, projecting its bound stream into
--   the outer level.
joinStream :: Process (Stream a) -> Stream a

-- | Takes the next stream from the list after the current stream fails
--   because of cancelling the underlying process.
failoverStream :: [Stream a] -> Stream a

-- | Return a stream of values triggered by the specified signal.
--   
--   Since the time at which the values of the stream are requested for may
--   differ from the time at which the signal is triggered, it can be
--   useful to apply the <a>arrivalSignal</a> function to add the
--   information about the time points at which the signal was actually
--   received.
--   
--   The point is that the <a>Stream</a> is requested outside, while the
--   <a>Signal</a> is triggered inside. They are different by nature. The
--   former is passive, while the latter is active.
--   
--   The resulting stream may be a root of space leak as it uses an
--   internal queue to store the values received from the signal. The
--   oldest value is dequeued each time we request the stream and it is
--   returned within the computation.
--   
--   Cancel the stream's process to unsubscribe from the specified signal.
signalStream :: Signal a -> Process (Stream a)

-- | Return a computation of the signal that triggers values from the
--   specified stream, each time the next value of the stream is received
--   within the underlying <a>Process</a> computation.
--   
--   Cancel the returned process to stop reading from the specified stream.
streamSignal :: Stream a -> Process (Signal a)

-- | The stream of <a>Left</a> values.
leftStream :: Stream (Either a b) -> Stream a

-- | The stream of <a>Right</a> values.
rightStream :: Stream (Either a b) -> Stream b

-- | Replace the <a>Left</a> values.
replaceLeftStream :: Stream (Either a b) -> Stream c -> Stream (Either c b)

-- | Replace the <a>Right</a> values.
replaceRightStream :: Stream (Either a b) -> Stream c -> Stream (Either a c)

-- | Partition the stream of <a>Either</a> values into two streams.
partitionEitherStream :: Stream (Either a b) -> Simulation (Stream a, Stream b)

-- | Show the debug messages with the current simulation time.
traceStream :: Maybe String -> Maybe String -> Stream a -> Stream a
instance Monoid (Stream a)
instance Alternative Stream
instance Applicative Stream
instance Functor Stream


-- | Tested with: GHC 7.10.1
--   
--   The processor of simulation data.
module Simulation.Aivika.Processor

-- | Represents a processor of simulation data.
newtype Processor a b
Processor :: (Stream a -> Stream b) -> Processor a b

-- | Run the processor.
runProcessor :: Processor a b -> Stream a -> Stream b

-- | A processor that never finishes its work producing an
--   <a>emptyStream</a>.
emptyProcessor :: Processor a b

-- | Create a simple processor by the specified handling function that runs
--   the discontinuous process for each input value to get the output.
arrProcessor :: (a -> Process b) -> Processor a b

-- | Accumulator that outputs a value determined by the supplied function.
accumProcessor :: (acc -> a -> Process (acc, b)) -> acc -> Processor a b

-- | Involve the computation with side effect when processing a stream of
--   data.
withinProcessor :: Process () -> Processor a a

-- | Create a processor that will use the specified process identifier. It
--   can be useful to refer to the underlying <a>Process</a> computation
--   which can be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
processorUsingId :: ProcessId -> Processor a b -> Processor a b

-- | This is a prefetch processor that requests for one more data item from
--   the input in advance while the latest item is not yet fully processed
--   in the chain of streams, usually by other processors.
--   
--   You can think of this as the prefetched processor could place its
--   latest data item in some temporary space for later use, which is very
--   useful for modeling a sequence of separate and independent work
--   places.
prefetchProcessor :: Processor a a

-- | A processor that delays the input stream by one step using the
--   specified initial value.
delayProcessor :: a -> Processor a a

-- | Create a buffer processor, where the process from the first argument
--   consumes the input stream but the stream passed in as the second
--   argument and produced usually by some other process is returned as an
--   output. This kind of processor is very useful for modeling the queues.
bufferProcessor :: (Stream a -> Process ()) -> Stream b -> Processor a b

-- | Like <a>bufferProcessor</a> but allows creating a loop when some items
--   can be processed repeatedly. It is very useful for modeling the
--   processors with queues and loop-backs.
bufferProcessorLoop :: (Stream a -> Stream c -> Process ()) -> Stream d -> Processor d (Either e b) -> Processor e c -> Processor a b

-- | Return a processor with help of which we can model the queue.
--   
--   Although the function doesn't refer to the queue directly, its main
--   use case is namely a processing of the queue. The first argument
--   should be the enqueueing operation, while the second argument should
--   be the opposite dequeueing operation.
--   
--   The reason is as follows. There are many possible combinations how the
--   queues can be modeled. There is no sense to enumerate all them
--   creating a separate function for each case. We can just use
--   combinators to define exactly what we need.
--   
--   So, the queue can lose the input items if the queue is full, or the
--   input process can suspend while the queue is full, or we can use
--   priorities for enqueueing, storing and dequeueing the items in
--   different combinations. There are so many use cases!
--   
--   There is a hope that this function along with other similar functions
--   from this module is sufficient to cover the most important cases. Even
--   if it is not sufficient then you can use a more generic function
--   <a>bufferProcessor</a> which this function is based on. In case of
--   need, you can even write your own function from scratch. It is quite
--   easy actually.
queueProcessor :: (a -> Process ()) -> Process b -> Processor a b

-- | Like <a>queueProcessor</a> creates a queue processor but with a loop
--   when some items can be processed and then added to the queue again.
--   Also it allows specifying how two input streams of data can be merged.
queueProcessorLoopMerging :: (Stream a -> Stream d -> Stream e) -> (e -> Process ()) -> Process c -> Processor c (Either f b) -> Processor f d -> Processor a b

-- | Like <a>queueProcessorLoopMerging</a> creates a queue processor with a
--   loop when some items can be processed and then added to the queue
--   again. Only it sequentially merges two input streams of data: one
--   stream that come from the external source and another stream of data
--   returned by the loop. The first stream has a priority over the second
--   one.
queueProcessorLoopSeq :: (a -> Process ()) -> Process c -> Processor c (Either e b) -> Processor e a -> Processor a b

-- | Like <a>queueProcessorLoopMerging</a> creates a queue processor with a
--   loop when some items can be processed and then added to the queue
--   again. Only it runs two simultaneous processes to enqueue the input
--   streams of data: one stream that come from the external source and
--   another stream of data returned by the loop.
queueProcessorLoopParallel :: (a -> Process ()) -> Process c -> Processor c (Either e b) -> Processor e a -> Processor a b

-- | Launches the processors sequentially using the
--   <a>prefetchProcessor</a> between them to model an autonomous work of
--   each of the processors specified.
processorSeq :: [Processor a a] -> Processor a a

-- | Launches the processors in parallel consuming the same input stream
--   and producing a combined output stream. This version applies the
--   <a>FCFS</a> strategy both for input and output, which suits the most
--   part of uses cases.
processorParallel :: [Processor a b] -> Processor a b

-- | Launches the specified processors in parallel consuming the same input
--   stream and producing a combined output stream.
--   
--   If you don't know what the enqueue strategies to apply, then you will
--   probably need <a>FCFS</a> for the both parameters, or function
--   <a>processorParallel</a> that does namely this.
processorQueuedParallel :: (EnqueueStrategy si, EnqueueStrategy so) => si -> so -> [Processor a b] -> Processor a b

-- | Launches the specified processors in parallel using priorities for
--   combining the output.
processorPrioritisingOutputParallel :: (EnqueueStrategy si, PriorityQueueStrategy so po) => si -> so -> [Processor a (po, b)] -> Processor a b

-- | Launches the specified processors in parallel using priorities for
--   consuming the intput.
processorPrioritisingInputParallel :: (PriorityQueueStrategy si pi, EnqueueStrategy so) => si -> so -> [(Stream pi, Processor a b)] -> Processor a b

-- | Launches the specified processors in parallel using priorities for
--   consuming the input and combining the output.
processorPrioritisingInputOutputParallel :: (PriorityQueueStrategy si pi, PriorityQueueStrategy so po) => si -> so -> [(Stream pi, Processor a (po, b))] -> Processor a b

-- | A processor that adds the information about the time points at which
--   the original stream items were received by demand.
arrivalProcessor :: Processor a (Arrival a)

-- | Removes one level of the computation, projecting its bound processor
--   into the outer level.
joinProcessor :: Process (Processor a b) -> Processor a b

-- | Takes the next processor from the list after the current processor
--   fails because of cancelling the underlying process.
failoverProcessor :: [Processor a b] -> Processor a b

-- | Convert the specified signal transform to a processor.
--   
--   The processor may return data with delay as the values are requested
--   by demand. Consider using the <a>arrivalSignal</a> function to provide
--   with the information about the time points at which the signal was
--   actually triggered.
--   
--   The point is that the <a>Stream</a> used in the <a>Processor</a> is
--   requested outside, while the <a>Signal</a> is triggered inside. They
--   are different by nature. The former is passive, while the latter is
--   active.
--   
--   Cancel the processor's process to unsubscribe from the signals
--   provided.
signalProcessor :: (Signal a -> Signal b) -> Processor a b

-- | Convert the specified processor to a signal transform.
--   
--   The processor may return data with delay as the values are requested
--   by demand. Consider using the <a>arrivalSignal</a> function to provide
--   with the information about the time points at which the signal was
--   actually triggered.
--   
--   The point is that the <a>Stream</a> used in the <a>Processor</a> is
--   requested outside, while the <a>Signal</a> is triggered inside. They
--   are different by nature. The former is passive, while the latter is
--   active.
--   
--   Cancel the returned process to unsubscribe from the signal specified.
processorSignaling :: Processor a b -> Signal a -> Process (Signal b)

-- | Show the debug messages with the current simulation time.
traceProcessor :: Maybe String -> Maybe String -> Processor a b -> Processor a b
instance ArrowPlus Processor
instance ArrowZero Processor
instance ArrowChoice Processor
instance Arrow Processor
instance Category Processor


-- | Tested with: GHC 7.10.1
--   
--   This module defines some useful random processors that hold the
--   current process for the corresponding time interval, when processing
--   every input element.
module Simulation.Aivika.Processor.Random

-- | When processing every input element, hold the process for a random
--   time interval distributed uniformly.
randomUniformProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval distributed uniformly.
randomUniformIntProcessor :: Int -> Int -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the triangular distribution.
randomTriangularProcessor :: Double -> Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval distributed normally.
randomNormalProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the lognormal distribution.
randomLogNormalProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval distributed exponentially with the specified mean (the
--   reciprocal of the rate).
randomExponentialProcessor :: Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the Erlang distribution with the specified scale
--   (the reciprocal of the rate) and shape parameters.
randomErlangProcessor :: Double -> Int -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the Poisson distribution with the specified mean.
randomPoissonProcessor :: Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the binomial distribution with the specified
--   probability and trials.
randomBinomialProcessor :: Double -> Int -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the Gamma distribution with the specified shape
--   and scale.
randomGammaProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the Beta distribution with the specified shape
--   parameters (alpha and beta).
randomBetaProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the Weibull distribution with the specified shape
--   and scale.
randomWeibullProcessor :: Double -> Double -> Processor a a

-- | When processing every input element, hold the process for a random
--   time interval having the specified discrete distribution.
randomDiscreteProcessor :: DiscretePDF Double -> Processor a a


-- | Tested with: GHC 7.10.1
--   
--   The module defines the Round-Robbin processor.
module Simulation.Aivika.Processor.RoundRobbin

-- | Represents the Round-Robbin processor that tries to perform the task
--   within the specified timeout. If the task times out, then it is
--   canceled and returned to the processor again; otherwise, the
--   successful result is redirected to output.
roundRobbinProcessor :: Processor (Process Double, Process a) a

-- | Like <a>roundRobbinProcessor</a> but allows specifying the process
--   identifiers which must be unique for every new attemp to perform the
--   task even if the task is the same.
roundRobbinProcessorUsingIds :: Processor (Process (Double, ProcessId), Process a) a


-- | Tested with: GHC 7.10.1
--   
--   It models the server that prodives a service.
module Simulation.Aivika.Server

-- | It models a server that takes <tt>a</tt> and provides <tt>b</tt>
--   having state <tt>s</tt>.
data Server s a b

-- | Create a new server that can provide output <tt>b</tt> by input
--   <tt>a</tt>.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newServer :: (a -> Process b) -> Simulation (Server () a b)

-- | Create a new server that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newStateServer :: (s -> a -> Process (s, b)) -> s -> Simulation (Server s a b)

-- | Create a new preemptible server that can provide output <tt>b</tt> by
--   input <tt>a</tt>.
newPreemptibleServer :: Bool -> (a -> Process b) -> Simulation (Server () a b)

-- | Create a new preemptible server that can provide output <tt>b</tt> by
--   input <tt>a</tt> starting from state <tt>s</tt>.
newPreemptibleStateServer :: Bool -> (s -> a -> Process (s, b)) -> s -> Simulation (Server s a b)

-- | Return a processor for the specified server.
--   
--   The processor updates the internal state of the server. The usual case
--   is when the processor is applied only once in a chain of data
--   processing. Otherwise; every time the processor is used, the state of
--   the server changes. Sometimes it can be indeed useful if you want to
--   aggregate the statistics for different servers simultaneously, but it
--   would be more preferable to avoid this.
--   
--   If you connect different server processors returned by this function
--   in a chain with help of <a>&gt;&gt;&gt;</a> or other category
--   combinator then this chain will act as one whole, where the first
--   server will take a new task only after the last server finishes its
--   current task and requests for the next one from the previous processor
--   in the chain. This is not always that thing you might need.
--   
--   To model a sequence of the server processors working independently,
--   you should use the <a>processorSeq</a> function which separates the
--   processors with help of the <a>prefetchProcessor</a> that plays a role
--   of a small one-place buffer in that case.
--   
--   The queue processors usually have the prefetching capabilities per se,
--   where the items are already stored in the queue. Therefore, the server
--   processor should not be prefetched if it is connected directly to the
--   queue processor.
serverProcessor :: Server s a b -> Processor a b

-- | The initial state of the server.
serverInitState :: Server s a b -> s

-- | Return the current state of the server.
--   
--   See also <a>serverStateChanged</a> and <a>serverStateChanged_</a>.
serverState :: Server s a b -> Event s

-- | Return the counted total time when the server was locked while
--   awaiting the input.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalInputWaitTimeChanged</a> and
--   <a>serverTotalInputWaitTimeChanged_</a>.
serverTotalInputWaitTime :: Server s a b -> Event Double

-- | Return the counted total time spent by the server while processing the
--   tasks.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalProcessingTimeChanged</a> and
--   <a>serverTotalProcessingTimeChanged_</a>.
serverTotalProcessingTime :: Server s a b -> Event Double

-- | Return the counted total time when the server was locked while trying
--   to deliver the output.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalOutputWaitTimeChanged</a> and
--   <a>serverTotalOutputWaitTimeChanged_</a>.
serverTotalOutputWaitTime :: Server s a b -> Event Double

-- | Return the counted total time spent by the server while it was
--   preempted waiting for the further proceeding.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalPreemptionTimeChanged</a> and
--   <a>serverTotalPreemptionTimeChanged_</a>.
serverTotalPreemptionTime :: Server s a b -> Event Double

-- | Return the statistics of the time when the server was locked while
--   awaiting the input.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverInputWaitTimeChanged</a> and
--   <a>serverInputWaitTimeChanged_</a>.
serverInputWaitTime :: Server s a b -> Event (SamplingStats Double)

-- | Return the statistics of the time spent by the server while processing
--   the tasks.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverProcessingTimeChanged</a> and
--   <a>serverProcessingTimeChanged_</a>.
serverProcessingTime :: Server s a b -> Event (SamplingStats Double)

-- | Return the statistics of the time when the server was locked while
--   trying to deliver the output.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverOutputWaitTimeChanged</a> and
--   <a>serverOutputWaitTimeChanged_</a>.
serverOutputWaitTime :: Server s a b -> Event (SamplingStats Double)

-- | Return the statistics of the time spent by the server while it was
--   preempted waiting for the further proceeding.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverPreemptionTimeChanged</a> and
--   <a>serverPreemptionTimeChanged_</a>.
serverPreemptionTime :: Server s a b -> Event (SamplingStats Double)

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was awaiting for the next input task.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalInputWaitTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverInputWaitFactorChanged</a> and
--   <a>serverInputWaitFactorChanged_</a>.
serverInputWaitFactor :: Server s a b -> Event Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was busy with direct processing its tasks.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalProcessingTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverProcessingFactorChanged</a> and
--   <a>serverProcessingFactorChanged_</a>.
serverProcessingFactor :: Server s a b -> Event Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was locked trying to deliver the output after the task is
--   finished.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalOutputWaitTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverOutputWaitFactorChanged</a> and
--   <a>serverOutputWaitFactorChanged_</a>.
serverOutputWaitFactor :: Server s a b -> Event Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was preempted waiting for the further proceeding.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalPreemptionTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverPreemptionFactorChanged</a> and
--   <a>serverPreemptionFactorChanged_</a>.
serverPreemptionFactor :: Server s a b -> Event Double

-- | Return the summary for the server with desciption of its properties
--   and activities using the specified indent.
serverSummary :: Server s a b -> Int -> Event ShowS

-- | Signal when the <a>serverState</a> property value has changed.
serverStateChanged :: Server s a b -> Signal s

-- | Signal when the <a>serverState</a> property value has changed.
serverStateChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverTotalInputWaitTime</a> property value has
--   changed.
serverTotalInputWaitTimeChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverTotalInputWaitTime</a> property value has
--   changed.
serverTotalInputWaitTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverTotalProcessingTime</a> property value has
--   changed.
serverTotalProcessingTimeChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverTotalProcessingTime</a> property value has
--   changed.
serverTotalProcessingTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverTotalOutputWaitTime</a> property value has
--   changed.
serverTotalOutputWaitTimeChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverTotalOutputWaitTime</a> property value has
--   changed.
serverTotalOutputWaitTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverTotalPreemptionTime</a> property value has
--   changed.
serverTotalPreemptionTimeChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverTotalPreemptionTime</a> property value has
--   changed.
serverTotalPreemptionTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverInputWaitTime</a> property value has changed.
serverInputWaitTimeChanged :: Server s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>serverInputWaitTime</a> property value has changed.
serverInputWaitTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverProcessingTime</a> property value has
--   changed.
serverProcessingTimeChanged :: Server s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>serverProcessingTime</a> property value has
--   changed.
serverProcessingTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverOutputWaitTime</a> property value has
--   changed.
serverOutputWaitTimeChanged :: Server s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>serverOutputWaitTime</a> property value has
--   changed.
serverOutputWaitTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverPreemptionTime</a> property value has
--   changed.
serverPreemptionTimeChanged :: Server s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>serverPreemptionTime</a> property value has
--   changed.
serverPreemptionTimeChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverInputWaitFactor</a> property value has
--   changed.
serverInputWaitFactorChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverInputWaitFactor</a> property value has
--   changed.
serverInputWaitFactorChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverProcessingFactor</a> property value has
--   changed.
serverProcessingFactorChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverProcessingFactor</a> property value has
--   changed.
serverProcessingFactorChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverOutputWaitFactor</a> property value has
--   changed.
serverOutputWaitFactorChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverOutputWaitFactor</a> property value has
--   changed.
serverOutputWaitFactorChanged_ :: Server s a b -> Signal ()

-- | Signal when the <a>serverPreemptionFactor</a> property value has
--   changed.
serverPreemptionFactorChanged :: Server s a b -> Signal Double

-- | Signal when the <a>serverPreemptionFactor</a> property value has
--   changed.
serverPreemptionFactorChanged_ :: Server s a b -> Signal ()

-- | Raised when the server receives a new input task.
serverInputReceived :: Server s a b -> Signal a

-- | Raised when the task processing was preempted.
serverTaskPreemptionBeginning :: Server s a b -> Signal a

-- | Raised when the task processing was proceeded after it had been
--   preempeted earlier.
serverTaskPreemptionEnding :: Server s a b -> Signal a

-- | Raised when the server has just processed the task.
serverTaskProcessed :: Server s a b -> Signal (a, b)

-- | Raised when the server has just delivered the output.
serverOutputProvided :: Server s a b -> Signal (a, b)

-- | Signal whenever any property of the server changes.
serverChanged_ :: Server s a b -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines some useful predefined servers that hold the
--   current process for the corresponding random time interval, when
--   processing every input element.
module Simulation.Aivika.Server.Random

-- | Create a new server that holds the process for a random time interval
--   distributed uniformly, when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomUniformServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed uniformly, when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomUniformIntServer :: Int -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the triangular distribution, when processing every input
--   element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomTriangularServer :: Double -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed normally, when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomNormalServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the lognormal distribution, when processing every input
--   element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomLogNormalServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed exponentially with the specified mean (the reciprocal of
--   the rate), when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomExponentialServer :: Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Erlang distribution with the specified scale (the
--   reciprocal of the rate) and shape parameters, when processing every
--   input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomErlangServer :: Double -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Poisson distribution with the specified mean, when
--   processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomPoissonServer :: Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the binomial distribution with the specified probability and
--   trials, when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomBinomialServer :: Double -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Gamma distribution with the specified shape and scale, when
--   processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomGammaServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Beta distribution with the specified shape parameters
--   (alpha and beta), when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomBetaServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Weibull distribution with the specified shape and scale,
--   when processing every input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomWeibullServer :: Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the specified discrete distribution, when processing every
--   input element.
--   
--   By default, it is assumed that the server process cannot be preempted,
--   because the handling of possible task preemption is rather costly
--   operation.
newRandomDiscreteServer :: DiscretePDF Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed uniformly, when processing every input element.
newPreemptibleRandomUniformServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed uniformly, when processing every input element.
newPreemptibleRandomUniformIntServer :: Bool -> Int -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the triangular distribution, when processing every input
--   element.
newPreemptibleRandomTriangularServer :: Bool -> Double -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed normally, when processing every input element.
newPreemptibleRandomNormalServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the lognormal distribution, when processing every input
--   element.
newPreemptibleRandomLogNormalServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   distributed exponentially with the specified mean (the reciprocal of
--   the rate), when processing every input element.
newPreemptibleRandomExponentialServer :: Bool -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Erlang distribution with the specified scale (the
--   reciprocal of the rate) and shape parameters, when processing every
--   input element.
newPreemptibleRandomErlangServer :: Bool -> Double -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Poisson distribution with the specified mean, when
--   processing every input element.
newPreemptibleRandomPoissonServer :: Bool -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the binomial distribution with the specified probability and
--   trials, when processing every input element.
newPreemptibleRandomBinomialServer :: Bool -> Double -> Int -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Gamma distribution with the specified shape and scale, when
--   processing every input element.
newPreemptibleRandomGammaServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Beta distribution with the specified shape parameters
--   (alpha and beta), when processing every input element.
newPreemptibleRandomBetaServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the Weibull distribution with the specified shape and scale,
--   when processing every input element.
newPreemptibleRandomWeibullServer :: Bool -> Double -> Double -> Simulation (Server () a a)

-- | Create a new server that holds the process for a random time interval
--   having the specified discrete distribution, when processing every
--   input element.
newPreemptibleRandomDiscreteServer :: Bool -> DiscretePDF Double -> Simulation (Server () a a)


-- | Tested with: GHC 7.10.1
--   
--   It represents a circuit synchronized with the event queue. Also it
--   allows creating the recursive links with help of the proc-notation.
--   
--   The implementation is based on the <a>Arrow Tutorial</a>.
module Simulation.Aivika.Circuit

-- | Represents a circuit synchronized with the event queue. Besides, it
--   allows creating the recursive links with help of the proc-notation.
newtype Circuit a b
Circuit :: (a -> Event (b, Circuit a b)) -> Circuit a b

-- | Run the circuit.
runCircuit :: Circuit a b -> a -> Event (b, Circuit a b)

-- | Iterate the circuit in the integration time points returning a task
--   which completes after the final output of the circuit is received.
iterateCircuitInIntegTimes :: Circuit a a -> a -> Event (Task a)

-- | Iterate the circuit in the integration time points.
iterateCircuitInIntegTimes_ :: Circuit a a -> a -> Event ()

-- | Iterate the circuit in the integration time points, interrupting the
--   iteration immediately if <a>Nothing</a> is returned within the
--   <a>Circuit</a> computation.
iterateCircuitInIntegTimesMaybe :: Circuit a (Maybe a) -> a -> Event ()

-- | Iterate the circuit in the integration time points returning a task
--   that computes the final output of the circuit either after all points
--   are exhausted, or after the <a>Left</a> result of type <tt>b</tt> is
--   received, which interrupts the computation immediately.
iterateCircuitInIntegTimesEither :: Circuit a (Either b a) -> a -> Event (Task (Either b a))

-- | Iterate the circuit in the specified time points returning a task
--   which completes after the final output of the circuit is received.
iterateCircuitInTimes :: [Double] -> Circuit a a -> a -> Event (Task a)

-- | Iterate the circuit in the specified time points.
iterateCircuitInTimes_ :: [Double] -> Circuit a a -> a -> Event ()

-- | Iterate the circuit in the specified time points, interrupting the
--   iteration immediately if <a>Nothing</a> is returned within the
--   <a>Circuit</a> computation.
iterateCircuitInTimesMaybe :: [Double] -> Circuit a (Maybe a) -> a -> Event ()

-- | Iterate the circuit in the specified time points returning a task that
--   computes the final output of the circuit either after all points are
--   exhausted, or after the <a>Left</a> result of type <tt>b</tt> is
--   received, which interrupts the computation immediately.
iterateCircuitInTimesEither :: [Double] -> Circuit a (Either b a) -> a -> Event (Task (Either b a))

-- | Create a simple circuit by the specified handling function that runs
--   the computation for each input value to get an output.
arrCircuit :: (a -> Event b) -> Circuit a b

-- | Accumulator that outputs a value determined by the supplied function.
accumCircuit :: (acc -> a -> Event (acc, b)) -> acc -> Circuit a b

-- | A circuit that adds the information about the time points at which the
--   values were received.
arrivalCircuit :: Circuit a (Arrival a)

-- | Delay the input by one step using the specified initial value.
delayCircuit :: a -> Circuit a a

-- | A circuit that returns the current modeling time.
timeCircuit :: Circuit a Double

-- | Like <a>&lt;&lt;&lt;</a> but processes only the represented events.
(<?<) :: Circuit b c -> Circuit a (Maybe b) -> Circuit a (Maybe c)

-- | Like <a>&gt;&gt;&gt;</a> but processes only the represented events.
(>?>) :: Circuit a (Maybe b) -> Circuit b c -> Circuit a (Maybe c)

-- | Filter the circuit, calculating only those parts of the circuit that
--   satisfy the specified predicate.
filterCircuit :: (a -> Bool) -> Circuit a b -> Circuit a (Maybe b)

-- | Filter the circuit within the <a>Event</a> computation, calculating
--   only those parts of the circuit that satisfy the specified predicate.
filterCircuitM :: (a -> Event Bool) -> Circuit a b -> Circuit a (Maybe b)

-- | The source of events that never occur.
neverCircuit :: Circuit a (Maybe b)

-- | Get a signal transform by the specified circuit.
circuitSignaling :: Circuit a b -> Signal a -> Signal b

-- | Transform the circuit to a processor.
circuitProcessor :: Circuit a b -> Processor a b

-- | An approximation of the integral using Euler's method.
--   
--   This function can be rather inaccurate as it depends on the time
--   points at wich the <a>Circuit</a> computation is actuated. Also
--   Euler's method per se is not most accurate, although simple enough for
--   implementation.
--   
--   Consider using the <a>integ</a> function whenever possible. That
--   function can integrate with help of the Runge-Kutta method by the
--   specified integration time points that are passed in the simulation
--   specs to every <a>Simulation</a>, when running the model.
--   
--   At the same time, the <a>integCircuit</a> function has no mutable
--   state unlike the former. The latter consumes less memory but at the
--   cost of inaccuracy and relatively more slow simulation, had we
--   requested the integral in the same time points.
--   
--   Regarding the recursive equations, the both functions allow defining
--   them but whithin different computations (either with help of the
--   recursive do-notation or the proc-notation).
integCircuit :: Double -> Circuit Double Double

-- | Like <a>integCircuit</a> but allows either setting a new <a>Left</a>
--   integral value, or using the <a>Right</a> derivative when integrating
--   by Euler's method.
integCircuitEither :: Double -> Circuit (Either Double Double) Double

-- | A sum of differences starting from the specified initial value.
--   
--   Consider using the more accurate <a>diffsum</a> function whener
--   possible as it is calculated in every integration time point specified
--   by specs passed in to every <a>Simulation</a>, when running the model.
--   
--   At the same time, the <a>sumCircuit</a> function has no mutable state
--   and it consumes less memory than the former.
--   
--   Regarding the recursive equations, the both functions allow defining
--   them but whithin different computations (either with help of the
--   recursive do-notation or the proc-notation).
sumCircuit :: Num a => a -> Circuit a a

-- | Like <a>sumCircuit</a> but allows either setting a new <a>Left</a>
--   value for the sum, or updating it by specifying the <a>Right</a>
--   difference.
sumCircuitEither :: Num a => a -> Circuit (Either a a) a

-- | Approximate the circuit as a transform of time varying function,
--   calculating the values in the integration time points and then
--   interpolating in all other time points. The resulting transform
--   computation is synchronized with the event queue.
--   
--   This procedure consumes memory as the underlying memoization allocates
--   an array to store the calculated values.
circuitTransform :: Circuit a b -> Transform a b

-- | Show the debug messages with the current simulation time.
traceCircuit :: Maybe String -> Maybe String -> Circuit a b -> Circuit a b
instance ArrowChoice Circuit
instance ArrowLoop Circuit
instance Arrow Circuit
instance Category Circuit


-- | Tested with: GHC 7.10.1
--   
--   The module defines a <a>Net</a> arrow that can be applied to modeling
--   the queue networks like the <a>Processor</a> arrow from another
--   module. Only the former has a more efficient implementation of the
--   <a>Arrow</a> interface than the latter, although at the cost of some
--   decreasing in generality.
--   
--   While the <tt>Processor</tt> type is just a function that transforms
--   the input <a>Stream</a> into another, the <tt>Net</tt> type is
--   actually an automaton that has an implementation very similar to that
--   one which the <a>Circuit</a> type has, only the computations occur in
--   the <a>Process</a> monad. But unlike the <tt>Circuit</tt> type, the
--   <tt>Net</tt> type doesn't allow declaring recursive definitions, being
--   based on continuations.
--   
--   In a nutshell, the <tt>Net</tt> type is an interchangeable alternative
--   to the <tt>Processor</tt> type with its weaknesses and strengths. The
--   <tt>Net</tt> arrow is useful for constructing computations with help
--   of the proc-notation to be transformed then to the <tt>Processor</tt>
--   computations that are more general in nature and more easy-to-use but
--   which computations created with help of the proc-notation are not so
--   efficient.
module Simulation.Aivika.Net

-- | Represents the net as an automaton working within the <a>Process</a>
--   computation.
newtype Net a b
Net :: (a -> Process (b, Net a b)) -> Net a b

-- | Run the net.
runNet :: Net a b -> a -> Process (b, Net a b)

-- | Iterate infinitely using the specified initial value.
iterateNet :: Net a a -> a -> Process ()

-- | Iterate the net using the specified initial value until <a>Nothing</a>
--   is returned within the <a>Net</a> computation.
iterateNetMaybe :: Net a (Maybe a) -> a -> Process ()

-- | Iterate the net using the specified initial value until the
--   <a>Left</a> result is returned within the <a>Net</a> computation.
iterateNetEither :: Net a (Either b a) -> a -> Process b

-- | A net that never finishes its work.
emptyNet :: Net a b

-- | Create a simple net by the specified handling function that runs the
--   discontinuous process for each input value to get an output.
arrNet :: (a -> Process b) -> Net a b

-- | Accumulator that outputs a value determined by the supplied function.
accumNet :: (acc -> a -> Process (acc, b)) -> acc -> Net a b

-- | Involve the computation with side effect when processing the input.
withinNet :: Process () -> Net a a

-- | Create a net that will use the specified process identifier. It can be
--   useful to refer to the underlying <a>Process</a> computation which can
--   be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
netUsingId :: ProcessId -> Net a b -> Net a b

-- | A net that adds the information about the time points at which the
--   values were received.
arrivalNet :: Net a (Arrival a)

-- | Delay the input by one step using the specified initial value.
delayNet :: a -> Net a a

-- | Transform the net to an equivalent processor (a rather cheap
--   transformation).
netProcessor :: Net a b -> Processor a b

-- | Transform the processor to a similar net (a more costly
--   transformation).
processorNet :: Processor a b -> Net a b

-- | Show the debug messages with the current simulation time.
traceNet :: Maybe String -> Maybe String -> Net a b -> Net a b
instance ArrowChoice Net
instance Arrow Net
instance Category Net


-- | Tested with: GHC 7.10.1
--   
--   This module defines some useful random network computations that hold
--   the current process for the corresponding time interval, when
--   processing every input element.
module Simulation.Aivika.Net.Random

-- | When processing every input element, hold the process for a random
--   time interval distributed uniformly.
randomUniformNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval distributed uniformly.
randomUniformIntNet :: Int -> Int -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the triangular distribution.
randomTriangularNet :: Double -> Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval distributed normally.
randomNormalNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the lognormal distribution.
randomLogNormalNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval distributed exponentially with the specified mean (the
--   reciprocal of the rate).
randomExponentialNet :: Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the Erlang distribution with the specified scale
--   (the reciprocal of the rate) and shape parameters.
randomErlangNet :: Double -> Int -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the Poisson distribution with the specified mean.
randomPoissonNet :: Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the binomial distribution with the specified
--   probability and trials.
randomBinomialNet :: Double -> Int -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the Gamma distribution with the specified shape
--   and scale.
randomGammaNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the Beta distribution with the specified shape
--   parameters (alpha and beta).
randomBetaNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the Weibull distribution with the specified shape
--   and scale.
randomWeibullNet :: Double -> Double -> Net a a

-- | When processing every input element, hold the process for a random
--   time interval having the specified discrete distribution.
randomDiscreteNet :: DiscretePDF Double -> Net a a


-- | Tested with: GHC 7.10.1
--   
--   This module defines the types and functions for working with the
--   events that can represent something that arrive from outside the
--   model, or represent other things which computation is delayed and
--   hence is not synchronized.
--   
--   Therefore, the additional information is provided about the time and
--   delay of arrival.
module Simulation.Aivika.Arrival

-- | It defines when an event has arrived, usually generated by some random
--   stream.
--   
--   Such events should arrive one by one without time lag in the following
--   sense that the model should start awaiting the next event exactly in
--   that time when the previous event has arrived.
--   
--   Another use case is a situation when the actual event is not
--   synchronized with the <a>Event</a> computation, being synchronized
--   with the event queue, nevertheless. Then the arrival is used for
--   providing the additional information about the time at which the event
--   had been actually arrived.
data Arrival a
Arrival :: a -> Double -> Maybe Double -> Arrival a

-- | the data we received with the event
arrivalValue :: Arrival a -> a

-- | the simulation time at which the event has arrived
arrivalTime :: Arrival a -> Double

-- | the delay time which has passed from the time of arriving the previous
--   event
arrivalDelay :: Arrival a -> Maybe Double

-- | Accumulates the statistics about that how long the arrived events are
--   processed.
data ArrivalTimer

-- | Create a new timer that measures how long the arrived events are
--   processed.
newArrivalTimer :: Simulation ArrivalTimer

-- | Return a processor that actually measures how much time has passed
--   from the time of arriving the events.
arrivalTimerProcessor :: ArrivalTimer -> Processor (Arrival a) (Arrival a)

-- | Return the statistics about that how long the arrived events were
--   processed.
arrivalProcessingTime :: ArrivalTimer -> Event (SamplingStats Double)

-- | Return a signal raised when the the processing time statistics
--   changes.
arrivalProcessingTimeChanged :: ArrivalTimer -> Signal (SamplingStats Double)

-- | Return a signal raised when the the processing time statistics
--   changes.
arrivalProcessingTimeChanged_ :: ArrivalTimer -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines random streams of events, which are useful for
--   describing the input of the model.
module Simulation.Aivika.Stream.Random

-- | Return a sream of random events that arrive with the specified delay.
randomStream :: Parameter (Double, a) -> Stream (Arrival a)

-- | Create a new stream with random delays distributed uniformly.
randomUniformStream :: Double -> Double -> Stream (Arrival Double)

-- | Create a new stream with integer random delays distributed uniformly.
randomUniformIntStream :: Int -> Int -> Stream (Arrival Int)

-- | Create a new stream with random delays having the triangular
--   distribution.
randomTriangularStream :: Double -> Double -> Double -> Stream (Arrival Double)

-- | Create a new stream with random delays distributed normally.
randomNormalStream :: Double -> Double -> Stream (Arrival Double)

-- | Create a new stream with random delays having the lognormal
--   distribution.
randomLogNormalStream :: Double -> Double -> Stream (Arrival Double)

-- | Return a new stream with random delays distibuted exponentially with
--   the specified mean (the reciprocal of the rate).
randomExponentialStream :: Double -> Stream (Arrival Double)

-- | Return a new stream with random delays having the Erlang distribution
--   with the specified scale (the reciprocal of the rate) and shape
--   parameters.
randomErlangStream :: Double -> Int -> Stream (Arrival Double)

-- | Return a new stream with random delays having the Poisson distribution
--   with the specified mean.
randomPoissonStream :: Double -> Stream (Arrival Int)

-- | Return a new stream with random delays having the binomial
--   distribution with the specified probability and trials.
randomBinomialStream :: Double -> Int -> Stream (Arrival Int)

-- | Return a new stream with random delays having the Gamma distribution
--   by the specified shape and scale.
randomGammaStream :: Double -> Double -> Stream (Arrival Double)

-- | Return a new stream with random delays having the Beta distribution by
--   the specified shape parameters (alpha and beta).
randomBetaStream :: Double -> Double -> Stream (Arrival Double)

-- | Return a new stream with random delays having the Weibull distribution
--   by the specified shape and scale.
randomWeibullStream :: Double -> Double -> Stream (Arrival Double)

-- | Return a new stream with random delays having the specified discrete
--   distribution.
randomDiscreteStream :: DiscretePDF Double -> Stream (Arrival Double)


-- | Tested with: GHC 7.10.1
--   
--   This module introduces basic entities for the agent-based modeling.
module Simulation.Aivika.Agent

-- | Represents an agent.
data Agent

-- | Represents the agent state.
data AgentState

-- | Create an agent.
newAgent :: Simulation Agent

-- | Create a new state.
newState :: Agent -> Simulation AgentState

-- | Create a child state.
newSubstate :: AgentState -> Simulation AgentState

-- | Return the selected active state.
selectedState :: Agent -> Event (Maybe AgentState)

-- | Return a signal that notifies about every change of the selected
--   state.
selectedStateChanged :: Agent -> Signal (Maybe AgentState)

-- | Return a signal that notifies about every change of the selected
--   state.
selectedStateChanged_ :: Agent -> Signal ()

-- | Select the state. The activation and selection are repeated while
--   there is the transition state defined by <a>setStateTransition</a>.
selectState :: AgentState -> Event ()

-- | Return the corresponded agent.
stateAgent :: AgentState -> Agent

-- | Return the parent state or <a>Nothing</a>.
stateParent :: AgentState -> Maybe AgentState

-- | Add to the state a timeout handler that will be actuated in the
--   specified time period if the state will remain active.
addTimeout :: AgentState -> Double -> Event () -> Event ()

-- | Add to the state a timer handler that will be actuated in the
--   specified time period and then repeated again many times, while the
--   state remains active.
addTimer :: AgentState -> Event Double -> Event () -> Event ()

-- | Set the activation computation for the specified state.
setStateActivation :: AgentState -> Event () -> Event ()

-- | Set the deactivation computation for the specified state.
setStateDeactivation :: AgentState -> Event () -> Event ()

-- | Set the transition state which will be next and which is used only
--   when selecting the state directly with help of <a>selectState</a>. If
--   the state was activated intermediately, when selecting another state,
--   then this computation is not used.
setStateTransition :: AgentState -> Event (Maybe AgentState) -> Event ()
instance Eq AgentState
instance Eq Agent


-- | Tested with: GHC 7.10.1
--   
--   It models an activity that can be utilised. The activity is similar to
--   a <a>Server</a> but destined for simulation within <a>Net</a>
--   computation.
module Simulation.Aivika.Activity

-- | Like <a>Server</a> it models an activity that takes <tt>a</tt> and
--   provides <tt>b</tt> having state <tt>s</tt>. But unlike the former the
--   activity is destined for simulation within <a>Net</a> computation.
data Activity s a b

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt>.
--   
--   By default, it is assumed that the activity utilisation cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newActivity :: (a -> Process b) -> Simulation (Activity () a b)

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
--   
--   By default, it is assumed that the activity utilisation cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newStateActivity :: (s -> a -> Process (s, b)) -> s -> Simulation (Activity s a b)

-- | Create a new preemptible activity that can provide output <tt>b</tt>
--   by input <tt>a</tt>.
newPreemptibleActivity :: Bool -> (a -> Process b) -> Simulation (Activity () a b)

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
newPreemptibleStateActivity :: Bool -> (s -> a -> Process (s, b)) -> s -> Simulation (Activity s a b)

-- | Return a network computation for the specified activity.
--   
--   The computation updates the internal state of the activity. The usual
--   case is when the computation is applied only once in a chain of data
--   processing. Otherwise; every time the computation is used, the state
--   of the activity changes. Sometimes it can be indeed useful if you want
--   to aggregate the statistics for different activities simultaneously,
--   but it would be more preferable to avoid this.
--   
--   If you connect different activity computations returned by this
--   function in a chain with help of <a>&gt;&gt;&gt;</a> or other category
--   combinator then this chain will act as one whole, where the first
--   activity will take a new task only after the last activity finishes
--   its current task and requests for the next one from the previous
--   activity in the chain. This is not always that thing you might need.
activityNet :: Activity s a b -> Net a b

-- | The initial state of the activity.
activityInitState :: Activity s a b -> s

-- | Return the current state of the activity.
--   
--   See also <a>activityStateChanged</a> and <a>activityStateChanged_</a>.
activityState :: Activity s a b -> Event s

-- | Return the counted total time when the activity was utilised.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityTotalUtilisationTimeChanged</a> and
--   <a>activityTotalUtilisationTimeChanged_</a>.
activityTotalUtilisationTime :: Activity s a b -> Event Double

-- | Return the counted total time when the activity was idle.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityTotalIdleTimeChanged</a> and
--   <a>activityTotalIdleTimeChanged_</a>.
activityTotalIdleTime :: Activity s a b -> Event Double

-- | Return the counted total time when the activity was preemted waiting
--   for the further proceeding.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityTotalPreemptionTimeChanged</a> and
--   <a>activityTotalPreemptionTimeChanged_</a>.
activityTotalPreemptionTime :: Activity s a b -> Event Double

-- | Return the statistics for the time when the activity was utilised.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityUtilisationTimeChanged</a> and
--   <a>activityUtilisationTimeChanged_</a>.
activityUtilisationTime :: Activity s a b -> Event (SamplingStats Double)

-- | Return the statistics for the time when the activity was idle.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityIdleTimeChanged</a> and
--   <a>activityIdleTimeChanged_</a>.
activityIdleTime :: Activity s a b -> Event (SamplingStats Double)

-- | Return the statistics for the time when the activity was preempted
--   waiting for the further proceeding.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityPreemptionTimeChanged</a> and
--   <a>activityPreemptionTimeChanged_</a>.
activityPreemptionTime :: Activity s a b -> Event (SamplingStats Double)

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was utilised.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalUtilisationTime / (totalUtilisationTime + totalIdleTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>activityUtilisationFactorChanged</a> and
--   <a>activityUtilisationFactorChanged_</a>.
activityUtilisationFactor :: Activity s a b -> Event Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was idle.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalIdleTime / (totalUtilisationTime + totalIdleTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>activityIdleFactorChanged</a> and
--   <a>activityIdleFactorChanged_</a>.
activityIdleFactor :: Activity s a b -> Event Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was preempted waiting for the further proceeding.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalUtilisationTime / (totalUtilisationTime + totalIdleTime + totalPreemptionTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>activityPreemptionFactorChanged</a> and
--   <a>activityPreemptionFactorChanged_</a>.
activityPreemptionFactor :: Activity s a b -> Event Double

-- | Return the summary for the activity with desciption of its properties
--   using the specified indent.
activitySummary :: Activity s a b -> Int -> Event ShowS

-- | Signal when the <a>activityState</a> property value has changed.
activityStateChanged :: Activity s a b -> Signal s

-- | Signal when the <a>activityState</a> property value has changed.
activityStateChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityTotalUtilisationTime</a> property value has
--   changed.
activityTotalUtilisationTimeChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityTotalUtilisationTime</a> property value has
--   changed.
activityTotalUtilisationTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityTotalIdleTime</a> property value has
--   changed.
activityTotalIdleTimeChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityTotalIdleTime</a> property value has
--   changed.
activityTotalIdleTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityTotalPreemptionTime</a> property value has
--   changed.
activityTotalPreemptionTimeChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityTotalPreemptionTime</a> property value has
--   changed.
activityTotalPreemptionTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityUtilisationTime</a> property value has
--   changed.
activityUtilisationTimeChanged :: Activity s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>activityUtilisationTime</a> property value has
--   changed.
activityUtilisationTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityIdleTime</a> property value has changed.
activityIdleTimeChanged :: Activity s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>activityIdleTime</a> property value has changed.
activityIdleTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityPreemptionTime</a> property value has
--   changed.
activityPreemptionTimeChanged :: Activity s a b -> Signal (SamplingStats Double)

-- | Signal when the <a>activityPreemptionTime</a> property value has
--   changed.
activityPreemptionTimeChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityUtilisationFactor</a> property value has
--   changed.
activityUtilisationFactorChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityUtilisationFactor</a> property value has
--   changed.
activityUtilisationFactorChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityIdleFactor</a> property value has changed.
activityIdleFactorChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityIdleFactor</a> property value has changed.
activityIdleFactorChanged_ :: Activity s a b -> Signal ()

-- | Signal when the <a>activityPreemptionFactor</a> property value has
--   changed.
activityPreemptionFactorChanged :: Activity s a b -> Signal Double

-- | Signal when the <a>activityPreemptionFactor</a> property value has
--   changed.
activityPreemptionFactorChanged_ :: Activity s a b -> Signal ()

-- | Raised when starting to utilise the activity after a new input task is
--   received.
activityUtilising :: Activity s a b -> Signal a

-- | Raised when the activity has been utilised after the current task is
--   processed.
activityUtilised :: Activity s a b -> Signal (a, b)

-- | Raised when the activity utilisation was preempted.
activityPreemptionBeginning :: Activity s a b -> Signal a

-- | Raised when the activity utilisation was proceeded after it had been
--   preempted earlier.
activityPreemptionEnding :: Activity s a b -> Signal a

-- | Signal whenever any property of the activity changes.
activityChanged_ :: Activity s a b -> Signal ()


-- | Tested with: GHC 7.10.1
--   
--   This module defines some useful predefined activities that hold the
--   current process for the corresponding random time interval, when
--   processing every input element.
module Simulation.Aivika.Activity.Random

-- | Create a new activity that holds the process for a random time
--   interval distributed uniformly, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomUniformActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed uniformly, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomUniformIntActivity :: Int -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the triangular distribution, when processing every
--   input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomTriangularActivity :: Double -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed normally, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomNormalActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the lognormal distribution, when processing every
--   input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomLogNormalActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed exponentially with the specified mean (the
--   reciprocal of the rate), when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomExponentialActivity :: Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Erlang distribution with the specified scale (the
--   reciprocal of the rate) and shape parameters, when processing every
--   input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomErlangActivity :: Double -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Poisson distribution with the specified mean, when
--   processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomPoissonActivity :: Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the binomial distribution with the specified
--   probability and trials, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomBinomialActivity :: Double -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Gamma distribution with the specified shape and
--   scale, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomGammaActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Beta distribution with the specified shape
--   parameters (alpha and beta), when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomBetaActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Weibull distribution with the specified shape and
--   scale, when processing every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomWeibullActivity :: Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the specified discrete distribution, when processing
--   every input element.
--   
--   By default, it is assumed that the activity process cannot be
--   preempted, because the handling of possible task preemption is rather
--   costly operation.
newRandomDiscreteActivity :: DiscretePDF Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed uniformly, when processing every input element.
newPreemptibleRandomUniformActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed uniformly, when processing every input element.
newPreemptibleRandomUniformIntActivity :: Bool -> Int -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the triangular distribution, when processing every
--   input element.
newPreemptibleRandomTriangularActivity :: Bool -> Double -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed normally, when processing every input element.
newPreemptibleRandomNormalActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the lognormal distribution, when processing every
--   input element.
newPreemptibleRandomLogNormalActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval distributed exponentially with the specified mean (the
--   reciprocal of the rate), when processing every input element.
newPreemptibleRandomExponentialActivity :: Bool -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Erlang distribution with the specified scale (the
--   reciprocal of the rate) and shape parameters, when processing every
--   input element.
newPreemptibleRandomErlangActivity :: Bool -> Double -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Poisson distribution with the specified mean, when
--   processing every input element.
newPreemptibleRandomPoissonActivity :: Bool -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the binomial distribution with the specified
--   probability and trials, when processing every input element.
newPreemptibleRandomBinomialActivity :: Bool -> Double -> Int -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Gamma distribution with the specified shape and
--   scale, when processing every input element.
newPreemptibleRandomGammaActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Beta distribution with the specified shape
--   parameters (alpha and beta), when processing every input element.
newPreemptibleRandomBetaActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the Weibull distribution with the specified shape and
--   scale, when processing every input element.
newPreemptibleRandomWeibullActivity :: Bool -> Double -> Double -> Simulation (Activity () a a)

-- | Create a new activity that holds the process for a random time
--   interval having the specified discrete distribution, when processing
--   every input element.
newPreemptibleRandomDiscreteActivity :: Bool -> DiscretePDF Double -> Simulation (Activity () a a)


-- | Tested with: GHC 7.10.1
--   
--   The module defines locales for outputting and printing the simulation
--   results.
module Simulation.Aivika.Results.Locale

-- | A locale to output the simulation results.
--   
--   Examples are: <tt>"ru", </tt>"en" etc.
type ResultLocale = String

-- | It localises the description of simulation results.
type ResultLocalisation = ResultId -> ResultDescription

-- | A description used for describing the results when generating output.
type ResultDescription = String

-- | The Russian locale.
russianResultLocale :: ResultLocale

-- | The English locale.
englishResultLocale :: ResultLocale

-- | Lookup a localisation by the specified locale.
lookupResultLocalisation :: ResultLocale -> ResultLocalisation

-- | The Russian localisation of the simulation results.
russianResultLocalisation :: ResultLocalisation

-- | The English localisation of the simulation results.
englishResultLocalisation :: ResultLocalisation

-- | The result entity identifier.
data ResultId

-- | A <a>time</a> computation.
TimeId :: ResultId

-- | Describes a vector.
VectorId :: ResultId

-- | Describes a vector item with the specified subscript.
VectorItemId :: String -> ResultId

-- | A <a>SamplingStats</a> value.
SamplingStatsId :: ResultId

-- | Property <a>samplingStatsCount</a>.
SamplingStatsCountId :: ResultId

-- | Property <a>samplingStatsMin</a>.
SamplingStatsMinId :: ResultId

-- | Property <a>samplingStatsMax</a>.
SamplingStatsMaxId :: ResultId

-- | Property <a>samplingStatsMean</a>.
SamplingStatsMeanId :: ResultId

-- | Property <a>samplingStatsMean2</a>.
SamplingStatsMean2Id :: ResultId

-- | Property <a>samplingStatsVariance</a>.
SamplingStatsVarianceId :: ResultId

-- | Property <a>samplingStatsDeviation</a>.
SamplingStatsDeviationId :: ResultId

-- | A <a>SamplingCounter</a> value.
SamplingCounterId :: ResultId

-- | Property <a>samplingCounterValue</a>.
SamplingCounterValueId :: ResultId

-- | Property <a>samplingCounterStats</a>.
SamplingCounterStatsId :: ResultId

-- | A <a>TimingStats</a> value.
TimingStatsId :: ResultId

-- | Property <a>timingStatsCount</a>.
TimingStatsCountId :: ResultId

-- | Property <a>timingStatsMin</a>.
TimingStatsMinId :: ResultId

-- | Property <a>timingStatsMax</a>.
TimingStatsMaxId :: ResultId

-- | Property <a>timingStatsMean</a>.
TimingStatsMeanId :: ResultId

-- | Property <a>timingStatsVariance</a>.
TimingStatsVarianceId :: ResultId

-- | Property <a>timingStatsDeviation</a>.
TimingStatsDeviationId :: ResultId

-- | Property <a>timingStatsMinTime</a>.
TimingStatsMinTimeId :: ResultId

-- | Property <a>timingStatsMaxTime</a>.
TimingStatsMaxTimeId :: ResultId

-- | Property <a>timingStatsStartTime</a>.
TimingStatsStartTimeId :: ResultId

-- | Property <a>timingStatsLastTime</a>.
TimingStatsLastTimeId :: ResultId

-- | Property <a>timingStatsSum</a>.
TimingStatsSumId :: ResultId

-- | Property <a>timingStatsSum2</a>.
TimingStatsSum2Id :: ResultId

-- | A <a>TimingCounter</a> value.
TimingCounterId :: ResultId

-- | Property <a>timingCounterValue</a>.
TimingCounterValueId :: ResultId

-- | Property <a>timingCounterStats</a>.
TimingCounterStatsId :: ResultId

-- | A finite <a>Queue</a>.
FiniteQueueId :: ResultId

-- | An infinite <a>Queue</a>.
InfiniteQueueId :: ResultId

-- | Property <a>enqueueStrategy</a>.
EnqueueStrategyId :: ResultId

-- | Property <a>enqueueStoringStrategy</a>.
EnqueueStoringStrategyId :: ResultId

-- | Property <a>dequeueStrategy</a>.
DequeueStrategyId :: ResultId

-- | Property <a>queueNull</a>.
QueueNullId :: ResultId

-- | Property <a>queueFull</a>.
QueueFullId :: ResultId

-- | Property <a>queueMaxCount</a>.
QueueMaxCountId :: ResultId

-- | Property <a>queueCount</a>.
QueueCountId :: ResultId

-- | Property <a>queueCountStats</a>.
QueueCountStatsId :: ResultId

-- | Property <a>enqueueCount</a>.
EnqueueCountId :: ResultId

-- | Property <a>enqueueLostCount</a>.
EnqueueLostCountId :: ResultId

-- | Property <a>enqueueStoreCount</a>.
EnqueueStoreCountId :: ResultId

-- | Property <a>dequeueCount</a>.
DequeueCountId :: ResultId

-- | Property <a>dequeueExtractCount</a>.
DequeueExtractCountId :: ResultId

-- | Property <a>queueLoadFactor</a>.
QueueLoadFactorId :: ResultId

-- | Property <a>enqueueRate</a>.
EnqueueRateId :: ResultId

-- | Property <a>enqueueStoreRate</a>.
EnqueueStoreRateId :: ResultId

-- | Property <a>dequeueRate</a>.
DequeueRateId :: ResultId

-- | Property <a>dequeueExtractRate</a>.
DequeueExtractRateId :: ResultId

-- | Property <a>queueWaitTime</a>.
QueueWaitTimeId :: ResultId

-- | Property <a>queueTotalWaitTime</a>.
QueueTotalWaitTimeId :: ResultId

-- | Property <a>enqueueWaitTime</a>.
EnqueueWaitTimeId :: ResultId

-- | Property <a>dequeueWaitTime</a>.
DequeueWaitTimeId :: ResultId

-- | Property <a>queueRate</a>.
QueueRateId :: ResultId

-- | An <a>ArrivalTimer</a>.
ArrivalTimerId :: ResultId

-- | Property <a>arrivalProcessingTime</a>.
ArrivalProcessingTimeId :: ResultId

-- | Represents a <a>Server</a>.
ServerId :: ResultId

-- | Property <a>serverInitState</a>.
ServerInitStateId :: ResultId

-- | Property <a>serverState</a>.
ServerStateId :: ResultId

-- | Property <a>serverTotalInputWaitTime</a>.
ServerTotalInputWaitTimeId :: ResultId

-- | Property <a>serverTotalProcessingTime</a>.
ServerTotalProcessingTimeId :: ResultId

-- | Property <a>serverTotalOutputWaitTime</a>.
ServerTotalOutputWaitTimeId :: ResultId

-- | Property <a>serverTotalPreemptionTime</a>.
ServerTotalPreemptionTimeId :: ResultId

-- | Property <a>serverInputWaitTime</a>.
ServerInputWaitTimeId :: ResultId

-- | Property <a>serverProcessingTime</a>.
ServerProcessingTimeId :: ResultId

-- | Property <a>serverOutputWaitTime</a>.
ServerOutputWaitTimeId :: ResultId

-- | Property <a>serverPreemptionTime</a>.
ServerPreemptionTimeId :: ResultId

-- | Property <a>serverInputWaitFactor</a>.
ServerInputWaitFactorId :: ResultId

-- | Property <a>serverProcessingFactor</a>.
ServerProcessingFactorId :: ResultId

-- | Property <a>serverOutputWaitFactor</a>.
ServerOutputWaitFactorId :: ResultId

-- | Property <a>serverPreemptionFactor</a>.
ServerPreemptionFactorId :: ResultId

-- | Represents an <a>Activity</a>.
ActivityId :: ResultId

-- | Property <a>activityInitState</a>.
ActivityInitStateId :: ResultId

-- | Property <a>activityState</a>.
ActivityStateId :: ResultId

-- | Property <a>activityTotalUtilisationTime</a>.
ActivityTotalUtilisationTimeId :: ResultId

-- | Property <a>activityTotalIdleTime</a>.
ActivityTotalIdleTimeId :: ResultId

-- | Property <a>activityTotalPreemptionTime</a>.
ActivityTotalPreemptionTimeId :: ResultId

-- | Property <a>activityUtilisationTime</a>.
ActivityUtilisationTimeId :: ResultId

-- | Property <a>activityIdleTime</a>.
ActivityIdleTimeId :: ResultId

-- | Property <a>activityPreemptionTime</a>.
ActivityPreemptionTimeId :: ResultId

-- | Property <a>activityUtilisationFactor</a>.
ActivityUtilisationFactorId :: ResultId

-- | Property <a>activityIdleFactor</a>.
ActivityIdleFactorId :: ResultId

-- | Property <a>activityPreemptionFactor</a>.
ActivityPreemptionFactorId :: ResultId

-- | Represents a <a>Resource</a>.
ResourceId :: ResultId

-- | Property <a>resourceCount</a>.
ResourceCountId :: ResultId

-- | Property <a>resourceCountStats</a>.
ResourceCountStatsId :: ResultId

-- | Property <a>resourceUtilisationCount</a>.
ResourceUtilisationCountId :: ResultId

-- | Property <a>resourceUtilisationCountStats</a>.
ResourceUtilisationCountStatsId :: ResultId

-- | Property <a>resourceQueueCount</a>.
ResourceQueueCountId :: ResultId

-- | Property <a>resourceQueueCountStats</a>.
ResourceQueueCountStatsId :: ResultId

-- | Property <a>resourceTotalWaitTime</a>.
ResourceTotalWaitTimeId :: ResultId

-- | Property <a>resourceWaitTime</a>.
ResourceWaitTimeId :: ResultId

-- | An user defined description.
UserDefinedResultId :: ResultDescription -> ResultId

-- | A localised property or object name.
LocalisedResultId :: (Map ResultLocale ResultDescription) -> ResultId
instance Eq ResultId
instance Ord ResultId
instance Show ResultId


-- | Tested with: GHC 7.10.1
--   
--   The module allows exporting the simulation results from the model.
module Simulation.Aivika.Results

-- | It contains the results of simulation.
data Results

-- | It transforms the results of simulation.
type ResultTransform = Results -> Results

-- | A name used for indentifying the results when generating output.
type ResultName = String

-- | Represents a provider of the simulation results. It is usually
--   something, or an array of something, or a list of such values which
--   can be simulated to get data.
class ResultProvider p where resultSource name descr = resultSource' name (UserDefinedResultId descr)
resultSource :: ResultProvider p => ResultName -> ResultDescription -> p -> ResultSource
resultSource' :: ResultProvider p => ResultName -> ResultId -> p -> ResultSource

-- | Prepare the simulation results.
results :: [ResultSource] -> Results

-- | Return an expanded version of the simulation results expanding the
--   properties as possible, which takes place for expanding statistics to
--   show the count, average, deviation, minimum, maximum etc. as separate
--   values.
expandResults :: ResultTransform

-- | Return a short version of the simulation results, i.e. their summary,
--   expanding the main properties or excluding auxiliary properties if
--   required.
resultSummary :: ResultTransform

-- | Take a result by its name.
resultByName :: ResultName -> ResultTransform

-- | Take a result from the object with the specified property label, but
--   it is more preferrable to refer to the property by its <a>ResultId</a>
--   identifier with help of the <a>resultById</a> function.
resultByProperty :: ResultName -> ResultTransform

-- | Take a result from the object with the specified identifier. It can
--   identify an item, object property, the object iself, vector or its
--   elements.
resultById :: ResultId -> ResultTransform

-- | Take a result from the vector by the specified integer index.
resultByIndex :: Int -> ResultTransform

-- | Take a result from the vector by the specified string subscript.
resultBySubscript :: ResultName -> ResultTransform

-- | Represents a computation that can return the simulation data.
class ResultComputing m
computeResultData :: ResultComputing m => m a -> ResultData a
computeResultSignal :: ResultComputing m => m a -> ResultSignal

-- | Represents a computation that can return the simulation data.
data ResultComputation a
ResultComputation :: ResultData a -> ResultSignal -> ResultComputation a

-- | Return data from the computation.
resultComputationData :: ResultComputation a -> ResultData a

-- | Return a signal from the computation.
resultComputationSignal :: ResultComputation a -> ResultSignal

-- | Represents a list with the specified subscript.
data ResultListWithSubscript p
ResultListWithSubscript :: [p] -> [String] -> ResultListWithSubscript p

-- | Represents an array with the specified subscript.
data ResultArrayWithSubscript i p
ResultArrayWithSubscript :: (Array i p) -> (Array i String) -> ResultArrayWithSubscript i p

-- | Represents a vector with the specified subscript.
data ResultVectorWithSubscript p
ResultVectorWithSubscript :: (Vector p) -> (Vector String) -> ResultVectorWithSubscript p

-- | A parameterised value that actually represents a generalised result
--   item that have no parametric type.
data ResultValue e
ResultValue :: ResultName -> ResultId -> ResultData e -> ResultSignal -> ResultValue e

-- | The value name.
resultValueName :: ResultValue e -> ResultName

-- | The value identifier.
resultValueId :: ResultValue e -> ResultId

-- | Simulation data supplied by the value.
resultValueData :: ResultValue e -> ResultData e

-- | Whether the value emits a signal when changing simulation data.
resultValueSignal :: ResultValue e -> ResultSignal

-- | Represent the results as integer numbers.
resultsToIntValues :: Results -> [ResultValue Int]

-- | Represent the results as lists of integer numbers.
resultsToIntListValues :: Results -> [ResultValue [Int]]

-- | Represent the results as statistics based on integer numbers.
resultsToIntStatsValues :: Results -> [ResultValue (SamplingStats Int)]

-- | Represent the results as statistics based on integer numbers and
--   optimised for fast aggregation.
resultsToIntStatsEitherValues :: Results -> [ResultValue (Either Int (SamplingStats Int))]

-- | Represent the results as timing statistics based on integer numbers.
resultsToIntTimingStatsValues :: Results -> [ResultValue (TimingStats Int)]

-- | Represent the results as double floating point numbers.
resultsToDoubleValues :: Results -> [ResultValue Double]

-- | Represent the results as lists of double floating point numbers.
resultsToDoubleListValues :: Results -> [ResultValue [Double]]

-- | Represent the results as statistics based on double floating point
--   numbers.
resultsToDoubleStatsValues :: Results -> [ResultValue (SamplingStats Double)]

-- | Represent the results as statistics based on double floating point
--   numbers and optimised for fast aggregation.
resultsToDoubleStatsEitherValues :: Results -> [ResultValue (Either Double (SamplingStats Double))]

-- | Represent the results as timing statistics based on double floating
--   point numbers.
resultsToDoubleTimingStatsValues :: Results -> [ResultValue (TimingStats Double)]

-- | Represent the results as string values.
resultsToStringValues :: Results -> [ResultValue String]

-- | It representes the predefined signals provided by every simulation
--   model.
data ResultPredefinedSignals
ResultPredefinedSignals :: Signal Double -> Signal Double -> Signal Double -> ResultPredefinedSignals

-- | The signal triggered in the integration time points.
resultSignalInIntegTimes :: ResultPredefinedSignals -> Signal Double

-- | The signal triggered in the start time.
resultSignalInStartTime :: ResultPredefinedSignals -> Signal Double

-- | The signal triggered in the stop time.
resultSignalInStopTime :: ResultPredefinedSignals -> Signal Double

-- | Create the predefined signals provided by every simulation model.
newResultPredefinedSignals :: Simulation ResultPredefinedSignals

-- | Return a signal emitted by the specified results.
resultSignal :: Results -> ResultSignal

-- | Return a pure signal as a result of combination of the predefined
--   signals with the specified result signal usually provided by the
--   sources.
--   
--   The signal returned is triggered when the source signal is triggered.
--   The pure signal is also triggered in the integration time points if
--   the source signal is unknown or it was combined with any unknown
--   signal.
pureResultSignal :: ResultPredefinedSignals -> ResultSignal -> Signal ()

-- | It associates the result sources with their names.
type ResultSourceMap = Map ResultName ResultSource

-- | Encapsulates the result source.
data ResultSource

-- | The source consisting of a single item.
ResultItemSource :: ResultItem -> ResultSource

-- | An object-like source.
ResultObjectSource :: ResultObject -> ResultSource

-- | A vector-like structure.
ResultVectorSource :: ResultVector -> ResultSource

-- | This is a separator text.
ResultSeparatorSource :: ResultSeparator -> ResultSource

-- | The simulation results represented by a single item.
data ResultItem
ResultItem :: a -> ResultItem

-- | Represents a type class for actual representing the items.
class ResultItemable a
resultItemName :: ResultItemable a => a -> ResultName
resultItemId :: ResultItemable a => a -> ResultId
resultItemSignal :: ResultItemable a => a -> ResultSignal
resultItemExpansion :: ResultItemable a => a -> ResultSource
resultItemSummary :: ResultItemable a => a -> ResultSource
resultItemAsIntValue :: ResultItemable a => a -> Maybe (ResultValue Int)
resultItemAsIntListValue :: ResultItemable a => a -> Maybe (ResultValue [Int])
resultItemAsIntStatsValue :: ResultItemable a => a -> Maybe (ResultValue (SamplingStats Int))
resultItemAsIntTimingStatsValue :: ResultItemable a => a -> Maybe (ResultValue (TimingStats Int))
resultItemAsDoubleValue :: ResultItemable a => a -> Maybe (ResultValue Double)
resultItemAsDoubleListValue :: ResultItemable a => a -> Maybe (ResultValue [Double])
resultItemAsDoubleStatsValue :: ResultItemable a => a -> Maybe (ResultValue (SamplingStats Double))
resultItemAsDoubleTimingStatsValue :: ResultItemable a => a -> Maybe (ResultValue (TimingStats Double))
resultItemAsStringValue :: ResultItemable a => a -> Maybe (ResultValue String)

-- | Try to return a version optimised for fast aggregation of the
--   statistics based on integer numbers.
resultItemAsIntStatsEitherValue :: ResultItemable a => a -> Maybe (ResultValue (Either Int (SamplingStats Int)))

-- | Try to return a version optimised for fast aggregation of the
--   statistics based on double floating point numbers.
resultItemAsDoubleStatsEitherValue :: ResultItemable a => a -> Maybe (ResultValue (Either Double (SamplingStats Double)))

-- | Return integer numbers in time points.
resultItemToIntValue :: ResultItemable a => a -> ResultValue Int

-- | Return lists of integer numbers in time points.
resultItemToIntListValue :: ResultItemable a => a -> ResultValue [Int]

-- | Return statistics based on integer numbers.
resultItemToIntStatsValue :: ResultItemable a => a -> ResultValue (SamplingStats Int)

-- | Return a version optimised for fast aggregation of the statistics
--   based on integer numbers.
resultItemToIntStatsEitherValue :: ResultItemable a => a -> ResultValue (Either Int (SamplingStats Int))

-- | Return timing statistics based on integer numbers.
resultItemToIntTimingStatsValue :: ResultItemable a => a -> ResultValue (TimingStats Int)

-- | Return double numbers in time points.
resultItemToDoubleValue :: ResultItemable a => a -> ResultValue Double

-- | Return lists of double numbers in time points.
resultItemToDoubleListValue :: ResultItemable a => a -> ResultValue [Double]

-- | Return statistics based on double numbers.
resultItemToDoubleStatsValue :: ResultItemable a => a -> ResultValue (SamplingStats Double)

-- | Return a version optimised for fast aggregation of the statistics
--   based on double floating point numbers.
resultItemToDoubleStatsEitherValue :: ResultItemable a => a -> ResultValue (Either Double (SamplingStats Double))

-- | Return timing statistics based on integer numbers.
resultItemToDoubleTimingStatsValue :: ResultItemable a => a -> ResultValue (TimingStats Double)

-- | Return string representations in time points.
resultItemToStringValue :: ResultItemable a => a -> ResultValue String

-- | The simulation results represented by an object having properties.
data ResultObject
ResultObject :: ResultName -> ResultId -> ResultId -> [ResultProperty] -> ResultSignal -> ResultSource -> ResultObject

-- | The object name.
resultObjectName :: ResultObject -> ResultName

-- | The object identifier.
resultObjectId :: ResultObject -> ResultId

-- | The object type identifier.
resultObjectTypeId :: ResultObject -> ResultId

-- | The object properties.
resultObjectProperties :: ResultObject -> [ResultProperty]

-- | A combined signal if present.
resultObjectSignal :: ResultObject -> ResultSignal

-- | A short version of the object, i.e. its summary.
resultObjectSummary :: ResultObject -> ResultSource

-- | The object property containing the simulation results.
data ResultProperty
ResultProperty :: ResultName -> ResultId -> ResultSource -> ResultProperty

-- | The property short label.
resultPropertyLabel :: ResultProperty -> ResultName

-- | The property identifier.
resultPropertyId :: ResultProperty -> ResultId

-- | The simulation results supplied by the property.
resultPropertySource :: ResultProperty -> ResultSource

-- | The simulation results represented by a vector.
data ResultVector
ResultVector :: ResultName -> ResultId -> Array Int ResultSource -> Array Int ResultName -> ResultSignal -> ResultSource -> ResultVector

-- | The vector name.
resultVectorName :: ResultVector -> ResultName

-- | The vector identifier.
resultVectorId :: ResultVector -> ResultId

-- | The results supplied by the vector items.
resultVectorItems :: ResultVector -> Array Int ResultSource

-- | The subscript used as a suffix to create item names.
resultVectorSubscript :: ResultVector -> Array Int ResultName

-- | A combined signal if present.
resultVectorSignal :: ResultVector -> ResultSignal

-- | A short version of the vector, i.e. summary.
resultVectorSummary :: ResultVector -> ResultSource

-- | Calculate the result vector signal and memoize it in a new vector.
memoResultVectorSignal :: ResultVector -> ResultVector

-- | Calculate the result vector summary and memoize it in a new vector.
memoResultVectorSummary :: ResultVector -> ResultVector

-- | It separates the simulation results when printing.
data ResultSeparator
ResultSeparator :: String -> ResultSeparator

-- | The separator text.
resultSeparatorText :: ResultSeparator -> String

-- | A container of the simulation results such as queue, server or array.
data ResultContainer e
ResultContainer :: ResultName -> ResultId -> e -> ResultSignal -> ResultContainer e

-- | The container name.
resultContainerName :: ResultContainer e -> ResultName

-- | The container identifier.
resultContainerId :: ResultContainer e -> ResultId

-- | The container data.
resultContainerData :: ResultContainer e -> e

-- | Whether the container emits a signal when changing simulation data.
resultContainerSignal :: ResultContainer e -> ResultSignal

-- | Create a new property source by the specified container.
resultContainerPropertySource :: ResultItemable (ResultValue b) => ResultContainer a -> ResultName -> ResultId -> (a -> ResultData b) -> (a -> ResultSignal) -> ResultSource

-- | Create a constant property by the specified container.
resultContainerConstProperty :: ResultItemable (ResultValue b) => ResultContainer a -> ResultName -> ResultId -> (a -> b) -> ResultProperty

-- | Create by the specified container a property that changes in the
--   integration time points, or it is supposed to be such one.
resultContainerIntegProperty :: ResultItemable (ResultValue b) => ResultContainer a -> ResultName -> ResultId -> (a -> Event b) -> ResultProperty

-- | Create a property by the specified container.
resultContainerProperty :: ResultItemable (ResultValue b) => ResultContainer a -> ResultName -> ResultId -> (a -> Event b) -> (a -> Signal ()) -> ResultProperty

-- | Create by the specified container a mapped property which is
--   recomputed each time again and again.
resultContainerMapProperty :: ResultItemable (ResultValue b) => ResultContainer (ResultData a) -> ResultName -> ResultId -> (a -> b) -> ResultProperty

-- | Convert the result value to a container with the specified object
--   identifier.
resultValueToContainer :: ResultValue a -> ResultContainer (ResultData a)

-- | Convert the result container to a value.
resultContainerToValue :: ResultContainer (ResultData a) -> ResultValue a

-- | Represents the very simulation results.
type ResultData e = Event e

-- | Whether an object containing the results emits a signal notifying
--   about change of data.
data ResultSignal

-- | There is no signal at all.
EmptyResultSignal :: ResultSignal

-- | The signal is unknown, but the entity probably changes.
UnknownResultSignal :: ResultSignal

-- | When the signal is precisely specified.
ResultSignal :: (Signal ()) -> ResultSignal

-- | When the specified signal was combined with unknown signal.
ResultSignalMix :: (Signal ()) -> ResultSignal

-- | Construct a new result signal by the specified optional pure signal.
maybeResultSignal :: Maybe (Signal ()) -> ResultSignal

-- | Return an arbitrary text as a separator source.
textResultSource :: String -> ResultSource

-- | Return the source of the modeling time.
timeResultSource :: ResultSource

-- | Represent the result source as integer numbers.
resultSourceToIntValues :: ResultSource -> [ResultValue Int]

-- | Represent the result source as lists of integer numbers.
resultSourceToIntListValues :: ResultSource -> [ResultValue [Int]]

-- | Represent the result source as statistics based on integer numbers.
resultSourceToIntStatsValues :: ResultSource -> [ResultValue (SamplingStats Int)]

-- | Represent the result source as statistics based on integer numbers and
--   optimised for fast aggregation.
resultSourceToIntStatsEitherValues :: ResultSource -> [ResultValue (Either Int (SamplingStats Int))]

-- | Represent the result source as timing statistics based on integer
--   numbers.
resultSourceToIntTimingStatsValues :: ResultSource -> [ResultValue (TimingStats Int)]

-- | Represent the result source as double floating point numbers.
resultSourceToDoubleValues :: ResultSource -> [ResultValue Double]

-- | Represent the result source as lists of double floating point numbers.
resultSourceToDoubleListValues :: ResultSource -> [ResultValue [Double]]

-- | Represent the result source as statistics based on double floating
--   point numbers.
resultSourceToDoubleStatsValues :: ResultSource -> [ResultValue (SamplingStats Double)]

-- | Represent the result source as statistics based on double floating
--   point numbers and optimised for fast aggregation.
resultSourceToDoubleStatsEitherValues :: ResultSource -> [ResultValue (Either Double (SamplingStats Double))]

-- | Represent the result source as timing statistics based on double
--   floating point numbers.
resultSourceToDoubleTimingStatsValues :: ResultSource -> [ResultValue (TimingStats Double)]

-- | Represent the result source as string values.
resultSourceToStringValues :: ResultSource -> [ResultValue String]

-- | The sources of simulation results as a map of associated names.
resultSourceMap :: Results -> ResultSourceMap

-- | The sources of simulation results as an ordered list.
resultSourceList :: Results -> [ResultSource]

-- | Compose the results using the specified transformation function.
composeResults :: (ResultSource -> [ResultSource]) -> ResultTransform

-- | Return a new result value by the specified name, identifier and
--   computation.
computeResultValue :: ResultComputing m => ResultName -> ResultId -> m a -> ResultValue a
instance ResultProvider Resource
instance (Show s, ResultItemable (ResultValue s)) => ResultProvider (Resource s)
instance (Show s, ResultItemable (ResultValue s)) => ResultProvider (Activity s a b)
instance (Show s, ResultItemable (ResultValue s)) => ResultProvider (Server s a b)
instance ResultProvider ArrivalTimer
instance (Show sm, Show so, ResultItemable (ResultValue sm), ResultItemable (ResultValue so)) => ResultProvider (Queue sm so a)
instance (Show si, Show sm, Show so, ResultItemable (ResultValue si), ResultItemable (ResultValue sm), ResultItemable (ResultValue so)) => ResultProvider (Queue si sm so a)
instance ResultComputing m => ResultProvider (m (Vector Int))
instance ResultComputing m => ResultProvider (m (Vector Double))
instance (Ix i, Show i, ResultComputing m) => ResultProvider (m (Array i Int))
instance (Ix i, Show i, ResultComputing m) => ResultProvider (m (Array i Double))
instance ResultProvider p => ResultProvider (ResultVectorWithSubscript p)
instance (Show i, Ix i, ResultProvider p) => ResultProvider (ResultArrayWithSubscript i p)
instance ResultProvider p => ResultProvider (ResultListWithSubscript p)
instance ResultProvider p => ResultProvider (Vector p)
instance (Show i, Ix i, ResultProvider p) => ResultProvider (Array i p)
instance ResultProvider p => ResultProvider [p]
instance ResultComputing m => ResultProvider (m String)
instance ResultComputing m => ResultProvider (m (TimingCounter Int))
instance ResultComputing m => ResultProvider (m (SamplingCounter Int))
instance ResultComputing m => ResultProvider (m (TimingStats Int))
instance ResultComputing m => ResultProvider (m (SamplingStats Int))
instance ResultComputing m => ResultProvider (m [Int])
instance ResultComputing m => ResultProvider (m Int)
instance ResultComputing m => ResultProvider (m (TimingCounter Double))
instance ResultComputing m => ResultProvider (m (SamplingCounter Double))
instance ResultComputing m => ResultProvider (m (TimingStats Double))
instance ResultComputing m => ResultProvider (m (SamplingStats Double))
instance ResultComputing m => ResultProvider (m [Double])
instance ResultComputing m => ResultProvider (m Double)
instance ResultComputing Signalable
instance ResultComputing Var
instance ResultComputing Ref
instance ResultComputing Ref
instance ResultComputing Event
instance ResultComputing Dynamics
instance ResultComputing Simulation
instance ResultComputing Parameter
instance ResultComputing ResultComputation
instance Monoid Results
instance ResultItemable (ResultValue StaticPriorities)
instance ResultItemable (ResultValue SIRO)
instance ResultItemable (ResultValue LCFS)
instance ResultItemable (ResultValue FCFS)
instance ResultItemable (ResultValue ())
instance ResultItemable (ResultValue String)
instance ResultItemable (ResultValue Bool)
instance ResultItemable (ResultValue (TimingStats Double))
instance ResultItemable (ResultValue (TimingStats Int))
instance ResultItemable (ResultValue (SamplingStats Double))
instance ResultItemable (ResultValue (SamplingStats Int))
instance ResultItemable (ResultValue [Double])
instance ResultItemable (ResultValue [Int])
instance ResultItemable (ResultValue Double)
instance ResultItemable (ResultValue Int)
instance Monoid ResultSignal
instance Functor ResultContainer
instance Functor ResultValue


-- | Tested with: GHC 7.10.1
--   
--   The module allows printing and converting the <a>Simulation</a>
--   <a>Results</a> to a <a>String</a>.
module Simulation.Aivika.Results.IO

-- | This is a function that prints the simulation results within the
--   <a>Event</a> computation synchronized with the event queue.
type ResultSourcePrint = ResultSource -> Event ()

-- | This is a function that shows the simulation results within the
--   <a>Event</a> computation synchronized with the event queue.
type ResultSourceShowS = ResultSource -> Event ShowS

-- | Print the results with the information about the modeling time.
printResultsWithTime :: ResultSourcePrint -> Results -> Event ()

-- | Print the simulation results in start time.
printResultsInStartTime :: ResultSourcePrint -> Results -> Simulation ()

-- | Print the simulation results in stop time.
printResultsInStopTime :: ResultSourcePrint -> Results -> Simulation ()

-- | Print the simulation results in the integration time points.
printResultsInIntegTimes :: ResultSourcePrint -> Results -> Simulation ()

-- | Print the simulation results in the specified time.
printResultsInTime :: Double -> ResultSourcePrint -> Results -> Simulation ()

-- | Print the simulation results in the specified time points.
printResultsInTimes :: [Double] -> ResultSourcePrint -> Results -> Simulation ()

-- | Run the simulation and then print the results in the start time.
printSimulationResultsInStartTime :: ResultSourcePrint -> Simulation Results -> Specs -> IO ()

-- | Run the simulation and then print the results in the final time.
printSimulationResultsInStopTime :: ResultSourcePrint -> Simulation Results -> Specs -> IO ()

-- | Run the simulation and then print the results in the integration time
--   points.
printSimulationResultsInIntegTimes :: ResultSourcePrint -> Simulation Results -> Specs -> IO ()

-- | Run the simulation and then print the results in the specified time
--   point.
printSimulationResultsInTime :: Double -> ResultSourcePrint -> Simulation Results -> Specs -> IO ()

-- | Run the simulation and then print the results in the specified time
--   points.
printSimulationResultsInTimes :: [Double] -> ResultSourcePrint -> Simulation Results -> Specs -> IO ()

-- | Show the results with the information about the modeling time.
showResultsWithTime :: ResultSourceShowS -> Results -> Event ShowS

-- | Show the simulation results in start time.
showResultsInStartTime :: ResultSourceShowS -> Results -> Simulation ShowS

-- | Show the simulation results in stop time.
showResultsInStopTime :: ResultSourceShowS -> Results -> Simulation ShowS

-- | Show the simulation results in the integration time points.
--   
--   It may consume much memory, for we have to traverse all the
--   integration points to create the resulting function within the
--   <a>Simulation</a> computation.
showResultsInIntegTimes :: ResultSourceShowS -> Results -> Simulation ShowS

-- | Show the simulation results in the specified time point.
showResultsInTime :: Double -> ResultSourceShowS -> Results -> Simulation ShowS

-- | Show the simulation results in the specified time points.
--   
--   It may consume much memory, for we have to traverse all the specified
--   points to create the resulting function within the <a>Simulation</a>
--   computation.
showResultsInTimes :: [Double] -> ResultSourceShowS -> Results -> Simulation ShowS

-- | Run the simulation and then show the results in the start time.
showSimulationResultsInStartTime :: ResultSourceShowS -> Simulation Results -> Specs -> IO ShowS

-- | Run the simulation and then show the results in the final time.
showSimulationResultsInStopTime :: ResultSourceShowS -> Simulation Results -> Specs -> IO ShowS

-- | Run the simulation and then show the results in the integration time
--   points.
--   
--   It may consume much memory, for we have to traverse all the
--   integration points to create the resulting function within the
--   <a>IO</a> computation.
showSimulationResultsInIntegTimes :: ResultSourceShowS -> Simulation Results -> Specs -> IO ShowS

-- | Run the simulation and then show the results in the integration time
--   point.
showSimulationResultsInTime :: Double -> ResultSourceShowS -> Simulation Results -> Specs -> IO ShowS

-- | Run the simulation and then show the results in the specified time
--   points.
--   
--   It may consume much memory, for we have to traverse all the specified
--   points to create the resulting function within the <a>IO</a>
--   computation.
showSimulationResultsInTimes :: [Double] -> ResultSourceShowS -> Simulation Results -> Specs -> IO ShowS

-- | Print a localised text representation of the results by the specified
--   source and with the given indent.
hPrintResultSourceIndented :: Handle -> Int -> ResultLocalisation -> ResultSourcePrint

-- | Print a localised text representation of the results by the specified
--   source.
hPrintResultSource :: Handle -> ResultLocalisation -> ResultSourcePrint

-- | Print in Russian a text representation of the results by the specified
--   source.
hPrintResultSourceInRussian :: Handle -> ResultSourcePrint

-- | Print in English a text representation of the results by the specified
--   source.
hPrintResultSourceInEnglish :: Handle -> ResultSourcePrint

-- | Print a localised text representation of the results by the specified
--   source and with the given indent.
printResultSourceIndented :: Int -> ResultLocalisation -> ResultSourcePrint

-- | Print a localised text representation of the results by the specified
--   source.
printResultSource :: ResultLocalisation -> ResultSourcePrint

-- | Print in Russian a text representation of the results by the specified
--   source.
printResultSourceInRussian :: ResultSourcePrint

-- | Print in English a text representation of the results by the specified
--   source.
printResultSourceInEnglish :: ResultSourcePrint

-- | Show a localised text representation of the results by the specified
--   source and with the given indent.
showResultSourceIndented :: Int -> ResultLocalisation -> ResultSourceShowS

-- | Show a localised text representation of the results by the specified
--   source.
showResultSource :: ResultLocalisation -> ResultSourceShowS

-- | Show in Russian a text representation of the results by the specified
--   source.
showResultSourceInRussian :: ResultSourceShowS

-- | Show in English a text representation of the results by the specified
--   source.
showResultSourceInEnglish :: ResultSourceShowS


-- | Tested with: GHC 7.10.1
--   
--   The module defines useful result transformations that can be used in
--   simulation experiments.
module Simulation.Aivika.Results.Transform

-- | Something that can transform the results.
class ResultTransformer a
tr :: ResultTransformer a => a -> ResultTransform

-- | Represents a statistics based upon observations.
newtype SamplingStats
SamplingStats :: ResultTransform -> SamplingStats

-- | The total number of samples.
samplingStatsCount :: SamplingStats -> ResultTransform

-- | The minimum value among the samples.
samplingStatsMin :: SamplingStats -> ResultTransform

-- | The maximum value among the samples.
samplingStatsMax :: SamplingStats -> ResultTransform

-- | The average value.
samplingStatsMean :: SamplingStats -> ResultTransform

-- | The average square value.
samplingStatsMean2 :: SamplingStats -> ResultTransform

-- | Return tha variance.
samplingStatsVariance :: SamplingStats -> ResultTransform

-- | Return the deviation.
samplingStatsDeviation :: SamplingStats -> ResultTransform

-- | The time-dependent statistics.
newtype TimingStats
TimingStats :: ResultTransform -> TimingStats

-- | Return the number of samples.
timingStatsCount :: TimingStats -> ResultTransform

-- | Return the minimum value.
timingStatsMin :: TimingStats -> ResultTransform

-- | Return the maximum value.
timingStatsMax :: TimingStats -> ResultTransform

-- | Return the average value.
timingStatsMean :: TimingStats -> ResultTransform

-- | Return the variance.
timingStatsVariance :: TimingStats -> ResultTransform

-- | Return the deviation.
timingStatsDeviation :: TimingStats -> ResultTransform

-- | Return the time at which the minimum is attained.
timingStatsMinTime :: TimingStats -> ResultTransform

-- | Return the time at which the maximum is attained.
timingStatsMaxTime :: TimingStats -> ResultTransform

-- | Return the start time of sampling.
timingStatsStartTime :: TimingStats -> ResultTransform

-- | Return the last time of sampling.
timingStatsLastTime :: TimingStats -> ResultTransform

-- | Return the sum of values.
timingStatsSum :: TimingStats -> ResultTransform

-- | Return the sum of square values.
timingStatsSum2 :: TimingStats -> ResultTransform

-- | A counter for which the statistics is collected too.
newtype SamplingCounter
SamplingCounter :: ResultTransform -> SamplingCounter

-- | The counter value.
samplingCounterValue :: SamplingCounter -> ResultTransform

-- | The counter statistics.
samplingCounterStats :: SamplingCounter -> SamplingStats

-- | A time-dependent counter that collects the statistics too.
newtype TimingCounter
TimingCounter :: ResultTransform -> TimingCounter

-- | The counter value.
timingCounterValue :: TimingCounter -> ResultTransform

-- | The counter statistics.
timingCounterStats :: TimingCounter -> TimingStats

-- | Represents either finite or infinite queue.
newtype Queue
Queue :: ResultTransform -> Queue

-- | The strategy applied to the enqueueing (input) processes when the
--   finite queue is full.
enqueueStrategy :: Queue -> ResultTransform

-- | The strategy applied when storing (in memory) items in the queue.
enqueueStoringStrategy :: Queue -> ResultTransform

-- | The strategy applied to the dequeueing (output) processes when the
--   queue is empty.
dequeueStrategy :: Queue -> ResultTransform

-- | Test whether the queue is empty.
queueNull :: Queue -> ResultTransform

-- | Test whether the finite queue is full.
queueFull :: Queue -> ResultTransform

-- | The finite queue capacity.
queueMaxCount :: Queue -> ResultTransform

-- | Return the current queue size.
queueCount :: Queue -> ResultTransform

-- | Return the queue size statistics.
queueCountStats :: Queue -> TimingStats

-- | Return the total number of input items that were enqueued in the
--   finite queue.
enqueueCount :: Queue -> ResultTransform

-- | Return the number of lost items for the finite queue.
enqueueLostCount :: Queue -> ResultTransform

-- | Return the total number of input items that were stored.
enqueueStoreCount :: Queue -> ResultTransform

-- | Return the total number of requests for dequeueing the items, not
--   taking into account the failed attempts to dequeue immediately without
--   suspension.
dequeueCount :: Queue -> ResultTransform

-- | Return the total number of output items that were actually dequeued.
dequeueExtractCount :: Queue -> ResultTransform

-- | Return the load factor: the finite queue size divided by its capacity.
queueLoadFactor :: Queue -> ResultTransform

-- | Return the rate of the input items that were enqueued in the finite
--   queue: how many items per time.
enqueueRate :: Queue -> ResultTransform

-- | Return the rate of the items that were stored: how many items per
--   time.
enqueueStoreRate :: Queue -> ResultTransform

-- | Return the rate of the requests for dequeueing the items: how many
--   requests per time. It does not include the failed attempts to dequeue
--   immediately without suspension.
dequeueRate :: Queue -> ResultTransform

-- | Return the rate of the output items that were dequeued: how many items
--   per time.
dequeueExtractRate :: Queue -> ResultTransform

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
queueWaitTime :: Queue -> SamplingStats

-- | Return the total wait time for the finite queue from the time at which
--   the enqueueing operation was initiated to the time at which the item
--   was dequeued.
queueTotalWaitTime :: Queue -> SamplingStats

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
enqueueWaitTime :: Queue -> SamplingStats

-- | Return the dequeue wait time from the time at which the item was
--   requested for dequeueing to the time at which it was actually
--   dequeued.
dequeueWaitTime :: Queue -> SamplingStats

-- | Return a long-term average queue rate calculated as the average queue
--   size divided by the average wait time.
queueRate :: Queue -> ResultTransform

-- | Accumulates the statistics about that how long the arrived events are
--   processed.
newtype ArrivalTimer
ArrivalTimer :: ResultTransform -> ArrivalTimer

-- | Return the statistics about that how long the arrived events were
--   processed.
arrivalProcessingTime :: ArrivalTimer -> SamplingStats

-- | It models the server that prodives a service.
newtype Server
Server :: ResultTransform -> Server

-- | The initial state of the server.
serverInitState :: Server -> ResultTransform

-- | Return the current state of the server.
serverState :: Server -> ResultTransform

-- | Return the counted total time when the server was locked while
--   awaiting the input.
serverTotalInputWaitTime :: Server -> ResultTransform

-- | Return the counted total time spent by the server while processing the
--   tasks.
serverTotalProcessingTime :: Server -> ResultTransform

-- | Return the counted total time when the server was locked while trying
--   to deliver the output.
serverTotalOutputWaitTime :: Server -> ResultTransform

-- | Return the counted total time spent by the server while it was
--   preempted waiting for the further proceeding.
serverTotalPreemptionTime :: Server -> ResultTransform

-- | Return the statistics of the time when the server was locked while
--   awaiting the input.
serverInputWaitTime :: Server -> SamplingStats

-- | Return the statistics of the time spent by the server while processing
--   the tasks.
serverProcessingTime :: Server -> SamplingStats

-- | Return the statistics of the time when the server was locked while
--   trying to deliver the output.
serverOutputWaitTime :: Server -> SamplingStats

-- | Return the statistics of the time spent by the server while it was
--   preempted waiting for the further proceeding.
serverPreemptionTime :: Server -> SamplingStats

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was awaiting for the next input task.
serverInputWaitFactor :: Server -> ResultTransform

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was busy with direct processing its tasks.
serverProcessingFactor :: Server -> ResultTransform

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was locked trying to deliver the output after the task is
--   finished.
serverOutputWaitFactor :: Server -> ResultTransform

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was preempted waiting for the further proceeding.
serverPreemptionFactor :: Server -> ResultTransform

-- | It models an activity that can be utilised.
newtype Activity
Activity :: ResultTransform -> Activity

-- | The initial state of the activity.
activityInitState :: Activity -> ResultTransform

-- | Return the current state of the activity.
activityState :: Activity -> ResultTransform

-- | Return the counted total time when the activity was utilised.
activityTotalUtilisationTime :: Activity -> ResultTransform

-- | Return the counted total time when the activity was idle.
activityTotalIdleTime :: Activity -> ResultTransform

-- | Return the counted total time when the activity was preemted waiting
--   for the further proceeding.
activityTotalPreemptionTime :: Activity -> ResultTransform

-- | Return the statistics for the time when the activity was utilised.
activityUtilisationTime :: Activity -> SamplingStats

-- | Return the statistics for the time when the activity was idle.
activityIdleTime :: Activity -> SamplingStats

-- | Return the statistics for the time when the activity was preempted
--   waiting for the further proceeding.
activityPreemptionTime :: Activity -> SamplingStats

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was utilised.
activityUtilisationFactor :: Activity -> ResultTransform

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was idle.
activityIdleFactor :: Activity -> ResultTransform

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was preempted waiting for the further proceeding.
activityPreemptionFactor :: Activity -> ResultTransform

-- | The resource which can be acquired and then released.
newtype Resource
Resource :: ResultTransform -> Resource

-- | Return the current available count of the resource.
resourceCount :: Resource -> ResultTransform

-- | Return the statistics for the available count of the resource.
resourceCountStats :: Resource -> TimingStats

-- | Return the current utilisation count of the resource.
resourceUtilisationCount :: Resource -> ResultTransform

-- | Return the statistics for the utilisation count of the resource.
resourceUtilisationCountStats :: Resource -> TimingStats

-- | Return the current queue length of the resource.
resourceQueueCount :: Resource -> ResultTransform

-- | Return the statistics for the queue length of the resource.
resourceQueueCountStats :: Resource -> TimingStats

-- | Return the total wait time of the resource.
resourceTotalWaitTime :: Resource -> ResultTransform

-- | Return the statistics for the wait time of the resource.
resourceWaitTime :: Resource -> SamplingStats
instance ResultTransformer Resource
instance ResultTransformer Activity
instance ResultTransformer Server
instance ResultTransformer ArrivalTimer
instance ResultTransformer Queue
instance ResultTransformer TimingCounter
instance ResultTransformer TimingStats
instance ResultTransformer SamplingCounter
instance ResultTransformer SamplingStats
instance ResultTransformer ResultTransform


-- | Tested with: GHC 7.10.1
--   
--   This module re-exports the most part of the library functionality. But
--   there are modules that must be imported explicitly.
module Simulation.Aivika
