-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pointless Lenses library
--   
--   Pointless Lenses is library of bidirectional lenses
--   (<a>http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl.pdf</a>)
--   defined in the point-free style of programming. Generic bidirectional
--   lenses can be defined over inductive types by relying in a set of
--   lifted lens combinators from the standard point-free combinators.
--   Virtually any recursive lens can be defined by combining the lenses
--   for the recursion patterns of catamorphisms and anamorphism. The
--   library also provides QuickCheck procedures to test the
--   well-behavedness of user-defined lens transformations.
@package pointless-lenses
@version 0.0.7


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module defines the structure of lenses and provides Quickcheck
--   procedures to test lens well-behavedness.
module Generics.Pointless.Lenses

-- | The data type of lenses
data Lens c a
Lens :: (c -> a) -> ((a, c) -> c) -> (a -> c) -> Lens c a
get :: Lens c a -> c -> a
put :: Lens c a -> (a, c) -> c
create :: Lens c a -> a -> c

-- | The type of natural lenses. Lenses that encode bidirectional natural
--   transformations.
type NatLens f g = forall x. x -> Lens (Rep f x) (Rep g x)

-- | Increment a number.
inc_lns :: Enum a => Lens a a

-- | Decrement a number.
dec_lns :: Enum a => Lens a a

-- | QuickCheck procedure to test if two lenses are equivalent.
lnsEq :: (Eq a, Eq c) => Lens c a -> Lens c a -> a -> c -> Bool
getEq :: Eq a => Lens c a -> Lens c a -> c -> Bool
putEq :: (Eq a, Eq c) => Lens c a -> Lens c a -> a -> c -> Bool
createEq :: Eq c => Lens c a -> Lens c a -> a -> Bool

-- | QuickCheck procedure to test if a lens is well-behaved.
wb :: (Eq a, Eq c) => Lens c a -> a -> c -> Bool

-- | QuickCheck procedure to test if a lens satisfies the PutGet law.
putget :: (Eq a, Eq c) => Lens c a -> a -> c -> Bool

-- | QuickCheck procedure to test if a lens satisfies the GetPut law.
getput :: Eq c => Lens c a -> c -> Bool

-- | QuickCheck procedure to test if a lens satisfies the CreateGet law.
createget :: Eq a => Lens c a -> a -> Bool


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module lifts a standard set of point-free combinators into
--   bidirectional lenses.
module Generics.Pointless.Lenses.Combinators

-- | Function application is a lens.
ap_lns :: Eq a => (b -> a) -> Lens (a -> b, a) b

-- | Predicate application is a lens.
(?<) :: Eq a => Lens (a -> Bool, a) (Either a a)

-- | The right exponentiation combinator as a lens. Applies a lens to the
--   domain of a function.
rexp_lns :: Lens b c -> Lens (a -> b) (a -> c)
curry_lns :: Lens ((a, b) -> c) (a -> b -> c)
uncurry_lns :: Lens (a -> b -> c) ((a, b) -> c)

-- | The lens composition operator.
(.<) :: Lens b a -> Lens c b -> Lens c a

-- | The <tt>fst</tt> point-free combinator.
fst_lns :: (a -> b) -> Lens (a, b) a

-- | The <tt>snd</tt> point-free combinator.
snd_lns :: (b -> a) -> Lens (a, b) b

-- | The <tt>&gt;&lt;</tt> point-free combinator.
(><<) :: Lens c a -> Lens d b -> Lens (c, d) (a, b)
(\/<) :: (c -> Either One One) -> Lens a c -> Lens b c -> Lens (Either a b) c

-- | The left-biased <tt>/</tt> point-free combinator. It chooses left
--   values over right values in the <tt>create</tt> direction.
(.\/<) :: Lens a c -> Lens b c -> Lens (Either a b) c

-- | The right-biased <tt>/</tt> point-free combinator. It chooses right
--   values over left values in the <tt>create</tt> direction.
(\/.<) :: Lens a c -> Lens b c -> Lens (Either a b) c

-- | The <tt>-|-</tt> point-free combinator.
(-|-<) :: Lens c a -> Lens d b -> Lens (Either c d) (Either a b)

-- | The <tt>-|-</tt> point-free combinator with user-defined backward
--   behavior.
sum_lns :: ((a, d) -> c) -> ((b, c) -> d) -> Lens c a -> Lens d b -> Lens (Either c d) (Either a b)

-- | The <tt>pnt</tt> point-free combinator.
(!<) :: (One -> c) -> Lens c One

-- | The <tt>(a!) / f</tt> point-free expression, where <tt>a</tt> is a
--   constant and <tt>f</tt> a function. The additional argument of type
--   <tt>c</tt> is the default value when the view matches the constant of
--   type <tt>a</tt>.
(!\/<) :: Eq a => a -> Lens b a -> c -> Lens (Either c b) a

-- | The <tt>f / (a!)</tt> point-free expression, where <tt>a</tt> is a
--   constant and <tt>f</tt> a function. The additional argument of type
--   <tt>b</tt> is the default value when the view matches the constant of
--   type <tt>a</tt>.
(\/!<) :: Eq a => a -> Lens c a -> b -> Lens (Either c b) a

-- | The <tt>inl / f</tt> point-free expression, where <tt>f</tt> is a
--   function.
(#\/<) :: Lens a c -> Lens b (Either c d) -> Lens (Either a b) (Either c d)

-- | The <tt>f / inr</tt> point-free expression, where <tt>f</tt> is a
--   function.
(\/$<) :: Lens a (Either c d) -> Lens b d -> Lens (Either a b) (Either c d)

-- | The <tt>bang / f</tt> point-free expression, where <tt>f</tt> is a
--   function.
(!/\<) :: Lens c a -> Lens c (One, a)

-- | The <tt>f / bang</tt> point-free expression, where <tt>f</tt> is a
--   function.
(/\!<) :: Lens c a -> Lens c (a, One)

-- | The lens identity combinator.
id_lns :: Lens c c

-- | The <tt>subr</tt> point-free combinator.
subr_lns :: Lens (a, (b, c)) (b, (a, c))

-- | The <tt>subl</tt> point-free combinator.
subl_lns :: Lens ((a, b), c) ((a, c), b)

-- | The <tt>cosubr</tt> point-free combinator.
cosubr_lns :: Lens (Either a (Either b c)) (Either b (Either a c))

-- | The <tt>cosubl</tt> point-free combinator.
cosubl_lns :: Lens (Either (Either a b) c) (Either (Either a c) b)

-- | The <tt>distp</tt> point-free combinator.
distp_lns :: Lens ((c, d), (a, b)) ((c, a), (d, b))

-- | The <tt>dists</tt> point-free combinator.
dists_lns :: Lens (Either a b, Either c d) (Either (Either (a, c) (a, d)) (Either (b, c) (b, d)))

-- | The <tt>swap</tt> point-free combinator.
swap_lns :: Lens (a, b) (b, a)

-- | The <tt>coswap</tt> point-free combinator
coswap_lns :: Lens (Either a b) (Either b a)

-- | The <tt>distl</tt> point-free combinator.
distl_lns :: Lens (Either a b, c) (Either (a, c) (b, c))

-- | The <tt>undistl</tt> point-free combinator.
undistl_lns :: Lens (Either (a, c) (b, c)) (Either a b, c)

-- | The <tt>distr</tt> point-free combinator.
distr_lns :: Lens (c, Either a b) (Either (c, a) (c, b))

-- | The <tt>undistr</tt> point-free combinator.
undistr_lns :: Lens (Either (c, a) (c, b)) (c, Either a b)

-- | The <tt>assocl</tt> point-free combinator.
assocl_lns :: Lens (a, (b, c)) ((a, b), c)

-- | The <tt>assocr</tt> point-free combinator.
assocr_lns :: Lens ((a, b), c) (a, (b, c))

-- | The <tt>coassocl</tt> point-free combinator.
coassocl_lns :: Lens (Either a (Either b c)) (Either (Either a b) c)

-- | The <tt>coassocr</tt> point-free combinator.
coassocr_lns :: Lens (Either (Either a b) c) (Either a (Either b c))


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module provides catamorphism and anamorphism bidirectional
--   combinators for the definition of recursive lenses.
module Generics.Pointless.Lenses.RecursionPatterns

-- | The <tt>inn</tt> point-free combinator.
inn_lns :: Mu a => Lens (F a a) a

-- | The <tt>out</tt> point-free combinator.
out_lns :: Mu a => Lens a (F a a)

-- | The functor mapping function <tt>fmap</tt> as a lens.
fmap_lns :: Fctrable f => Fix f -> Lens c a -> Lens (Rep f c) (Rep f a)

-- | The polytypic functor zipping combinator. Gives preference to the
--   abstract (first) F-structure.
fzip :: Fctr f -> (a -> c) -> (Rep f a, Rep f c) -> Rep f (a, c)

-- | The <tt>hylo</tt> recursion pattern as the composition of a lens
--   catamorphism after a lens anamorphism .
hylo_lns :: (Mu b, Fctrable (PF b)) => b -> Lens (F b c) c -> Lens a (F b a) -> Lens a c

-- | The <tt>ana</tt> recursion pattern as a lens. For <tt>ana_lns</tt> to
--   be a well-behaved lens, we MUST prove termination of |get| for each
--   instance.
ana_lns :: (Mu b, Fctrable (PF b)) => b -> Lens a (F b a) -> Lens a b

-- | The <tt>cata</tt> recursion pattern as a lens. For <tt>cata_lns</tt>
--   to be a well-behaved lens, we MUST prove termination of |put| and
--   |create| for each instance.
cata_lns :: (Mu a, Fctrable (PF a)) => a -> (Lens (F a b) b) -> Lens a b

-- | The recursion pattern for recursive functions that can be expressed
--   both as anamorphisms and catamorphisms. Proofs of termination are
--   dismissed.
nat_lns :: (Mu a, Mu b, Fctrable (PF b)) => a -> NatLens (PF a) (PF b) -> Lens a b
binn_lns :: Bimu d => Lens (B d a (d a)) (d a)
bout_lns :: Bimu d => Lens (d a) (B d a (d a))

-- | The bifunctor mapping function <tt>bmap</tt> as a lens.
bmap_lns :: Bifctrable f => BFix f -> Lens c a -> NatLens (BRep f c) (BRep f a)

-- | The polytypic bifunctor zipping combinator. Just maps over the
--   polymorphic parameter. To map over the recursive parameter we can use
--   <tt>fzip</tt>.
bzip :: x -> Bifctr f -> (a -> c) -> (Rep (BRep f a) x, Rep (BRep f c) x) -> Rep (BRep f (a, c)) x

-- | Generic mapping lens for parametric types with one polymorphic
--   parameter. Cannot be defined using <tt>nat_lns</tt> because of the
--   required equality constraints between functors and bifunctors. This
--   could, however, be overcome by defining specific recursive combinators
--   for bifunctors.
gmap_lns :: (Mu (d c), Mu (d a), Fctrable (PF (d c)), Bifctrable (BF d), (F (d a) (d a)) ~ (B d a (d a)), (F (d c) (d a)) ~ (B d c (d a))) => d a -> Lens c a -> Lens (d c) (d a)


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module provides catamorphism and anamorphism bidirectional
--   combinators for the definition of recursive lenses. The
--   implementations use a monad reader so that each lens combinator
--   permits a more flexible environment.
module Generics.Pointless.Lenses.Reader.RecursionPatterns

-- | The functor mapping function <tt>fmap</tt> as a more relaxed lens. The
--   extra function allows user-defined behavior when creating default
--   concrete F-values.
fmap_lns' :: Fctrable f => Fix f -> ((a, Rep f c) -> c) -> Lens c a -> Lens (Rep f c) (Rep f a)

-- | The polytypic functor zipping combinator. Gives preference to the
--   abstract (first) F-structure.
fzip' :: Fctr f -> ((a, e) -> c) -> (Rep f a, Rep f c) -> (e -> Rep f (a, c))

-- | The polytypic auxiliary function for <tt>fzip'</tt>. Similar to
--   <tt>fmap (id / create)</tt> but using a monad reader for the concrete
--   reconstruction function.
fcre' :: Fctr f -> ((a, e) -> c) -> Rep f a -> (e -> Rep f (a, c))

-- | The <tt>ana</tt> recursion pattern as a more relaxed lens. For
--   <tt>ana_lns'</tt> to be a well-behaved lens, we MUST prove termination
--   of |get| for each instance.
ana_lns' :: (Mu b, Fctrable (PF b)) => ((b, a) -> a) -> Lens a (F b a) -> Lens a b

-- | The <tt>cata</tt> recursion pattern as a more relaxed lens. For
--   <tt>cata_lns'</tt> to be a well-behaved lens, we MUST prove
--   termination of |put| and |create| for each instance.
cata_lns' :: (Mu a, Fctrable (PF a)) => ((b, a) -> a) -> (Lens (F a b) b) -> Lens a b

-- | A more relaxed version of the recursion pattern for recursive
--   functions that can be expressed both as anamorphisms and
--   catamorphisms. Proofs of termination are dismissed.
nat_lns' :: (Mu a, Mu b, Fctrable (PF b)) => ((b, a) -> a) -> NatLens (PF a) (PF b) -> Lens a b

-- | A more relaxed version of the bifunctor mapping function <tt>bmap</tt>
--   as a lens. Cannot employ <tt>NatLens</tt> because the extra function
--   depends on the polymorphic type argument.
bmap_lns' :: Bifctrable f => x -> BFix f -> ((a, Rep (BRep f c) x) -> c) -> Lens c a -> Lens (Rep (BRep f c) x) (Rep (BRep f a) x)

-- | A more relaxed version of the the polytypic bifunctor zipping
--   combinator.
bzip' :: x -> Bifctr f -> ((a, e) -> c) -> (Rep (BRep f a) x, Rep (BRep f c) x) -> (e -> Rep (BRep f (a, c)) x)
bcre' :: x -> Bifctr f -> ((a, e) -> c) -> Rep (BRep f a) x -> (e -> (Rep (BRep f (a, c)) x))

-- | A more relaxed version of the generic mapping lens for parametric
--   types with one polymorphic parameter. We do not define
--   <tt>gmap_lns'</tt> as a recursion pattern lens because we want to
--   provide more control in the auxiliary functions. Using
--   <tt>bmap_lns'</tt> we would not get <tt>(a,d c) -&gt; c</tt> but
--   instead <tt>(a,B d c (d a)) -&gt; c</tt>.
gmap_lns' :: (Mu (d a), Mu (d c), Fctrable (PF (d c)), Fctrable (PF (d a)), Bifctrable (BF d), (F (d a) (d c)) ~ (B d a (d c)), (F (d c) (d c)) ~ (B d c (d c)), (F (d a) (d a)) ~ (B d a (d a)), (F (d c) (d a)) ~ (B d c (d a))) => ((a, d c) -> c) -> ((d a, d c) -> d c) -> Lens c a -> Lens (d c) (d a)


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module provides examples, examples and more examples.
module Generics.Pointless.Lenses.Examples.Examples

-- | Flatten a tree into a list.
preOrd_lns :: Lens (Tree a) [a]

-- | Flatten a tree into a list.
postOrd_lns :: Lens (Tree a) [a]

-- | List length lens.
length_lns :: a -> Lens [a] Nat
zipWith_lns :: Lens (a, b) c -> Lens ([a], [b]) [c]

-- | List zipping lens.
zip_lns :: Lens ([a], [b]) [(a, b)]

-- | Take the first n elements from a list
take_lns :: Lens (Nat, [a]) [a]

-- | List filtering lens. The argument passed to <tt>snd_lns</tt> can be
--   undefined because it will never be used
filter_left_lns :: Lens [Either a b] [a]
filter_right_lns :: Lens [Either a b] [b]

-- | Binary list concatenation. Lens hylomorphisms can be defined as the
--   composition of a catamorphism after an anamorphism.
cat_lns :: Lens ([a], [a]) [a]

-- | Binary list transposition. Binary version of <tt>transpose</tt>.
transpose_lns :: Lens ([a], [a]) [a]

-- | Addition of two natural numbers.
plus_lns :: Lens (Nat, Nat) Nat
suml_lns :: Lens [Nat] Nat
concatMap_lns :: Lens a [b] -> Lens [a] [b]

-- | List concatenation.
concat_lns :: Lens [[a]] [a]

-- | Partitions a list of options into two lists. Note that this imposes
--   some redefinement of the traditional definition in order to fit our
--   framework.
partition_lns :: Lens [Either a b] ([a], [b])

-- | List mapping lens.
map_lns :: Lens c a -> Lens [c] [a]
head_lns :: [a] -> Lens [a] (Either One a)
tail_lns :: a -> Lens [a] (Either One [a])

-- | Inserts an element at the end of a list, thus making it non-empty.
snoc_lns :: Lens (a, [a]) (Some a)

-- | Isomorphism between a list and an optional non-empty list.
toSome_lns :: Lens [a] (Either One (Some a))

-- | Converts a list into a non-empty list.
some_lns :: Eq a => a -> Lens [a] (Some a)

-- | Isomorphism between a list and an optional non-empty list.
fromSome_lns :: Lens (Either One (Some a)) [a]
eitherNilSnoc :: Lens (Either One (a, [a])) [a]

-- | The list reversal lens is an isomorphism.
reverse_lns :: Lens [a] [a]

-- | List length using an accumulation (after simplification into an
--   hylomorphism). Uses <tt>Int</tt> instead of <tt>Nat</tt> because
--   <tt>succ</tt> on <tt>Nat</tt> is not a valid lens.
len_lns :: Lens ([a], Int) Int
add_lns :: Lens (Int, Int) Int

-- | Sum of a list of integers.
sumInt_lns :: Lens [Int] Int

-- | Incremental summation of a list. Since general splitting is not a
--   lens, we need to provide user-defined put and create functions that
--   serve our purpose and construct a valid lens.
isum_lns :: Lens [Int] [Int]


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   This module provides specialized versions of recursion patterns to
--   avoid using the internal classes and type families. These functions
--   are more efficient and better for profiling and runtime tests.
module Generics.Pointless.Lenses.Examples.Recs
innNat :: Either One Nat -> Nat
outNat :: Nat -> Either One Nat
innNat_lns :: Lens (Either One Nat) Nat
outNat_lns :: Lens Nat (Either One Nat)
innMaybe :: Either One a -> Maybe a
outMaybe :: Maybe a -> Either One a
innMaybe_lns :: Lens (Either One a) (Maybe a)
outMaybe_lns :: Lens (Maybe a) (Either One a)
innList :: Either One (a, [a]) -> [a]
outList :: [a] -> Either One (a, [a])
innList_lns :: Lens (Either One (a, [a])) [a]
outList_lns :: Lens [a] (Either One (a, [a]))
outNeList :: (NeList a b) -> Either a (b, NeList a b)
innNeList :: Either a (b, NeList a b) -> NeList a b
cataList :: (Either One (a, b) -> b) -> [a] -> b
anaList :: (b -> Either One (a, b)) -> b -> [a]
fmapList :: (x -> y) -> Either z (a, x) -> Either z (a, y)
fmapNat :: (x -> y) -> Either a x -> Either a y
fzipList :: (a -> c) -> (Either z (x, a), Either z (x, c)) -> Either z (x, (a, c))
fzipNat :: (a -> c) -> (Either z a, Either z c) -> Either z (a, c)
cataList_lns :: (Lens (Either One (a, b)) b) -> Lens [a] b
hyloList :: (Either x (y, c) -> c) -> (a -> Either x (y, a)) -> (a -> c)
outNeNat :: NeNat a -> Either a (NeNat a)
data NeNat a
NNil :: a -> NeNat a
NCons :: (NeNat a) -> NeNat a
cataNeNat :: (Either a c -> c) -> NeNat a -> c
anaNeNat :: (c -> Either a c) -> c -> NeNat a
accumNeNat :: ((Either a y, x) -> y) -> ((Either a (NeNat a), x) -> Either a (NeNat a, x)) -> ((NeNat a, x) -> y)
cataNeNat_lns :: (Lens (Either a c) c) -> Lens (NeNat a) c
anaNeNat_lns :: (Lens c (Either a c)) -> Lens c (NeNat a)
hyloNeNat_lns :: (Lens (Either x b) b) -> (Lens a (Either x a)) -> Lens a b
data NeList a b
NeNil :: a -> NeList a b
NeCons :: b -> (NeList a b) -> NeList a b
cataNeList :: (Either a (b, c) -> c) -> NeList a b -> c
anaNeList :: (c -> Either a (b, c)) -> c -> NeList a b
accumNeList :: ((Either a (b, y), x) -> y) -> ((Either a (b, NeList a b), x) -> Either a (b, (NeList a b, x))) -> ((NeList a b, x) -> y)
cataNeList_lns :: (Lens (Either a (b, c)) c) -> Lens (NeList a b) c
anaNeList_lns :: (Lens c (Either a (b, c))) -> Lens c (NeList a b)
hyloNeList_lns :: (Lens (Either x (y, b)) b) -> (Lens a (Either x (y, a))) -> Lens a b
length_pf :: a -> Lens [a] Nat
plus_pf :: Lens (Nat, Nat) Nat
suml_pf :: Lens [Nat] Nat
cat_pf :: Lens ([a], [a]) [a]
concat_pf :: Lens [[a]] [a]
map_pf :: Lens a b -> Lens [a] [b]
filter_left_pf :: Lens [Either a b] [a]
filter_right_pf :: Lens [Either a b] [b]


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   Internet Movie Database example
module Generics.Pointless.Lenses.Examples.Imdb
type Imdb = ([Show], [Actor])
type Show = (((Year, Title), [Review]), Either Movie TV)
type Review = (User, [Comment])
type Movie = (Director, [BoxOffice])
type BoxOffice = (Country, Maybe Value)
type TV = [Season]
type Season = (Year, [Episode])
type Actor = (Name, [Played])
type Played = (((Year, Title), Role), [Award])
type Award = (Year, Category)
type Year = Int
type Title = String
type User = String
type Comment = String
type Director = String
type Country = String
type Value = Nat
type Episode = String
type Name = String
type Role = String
type Category = String
dytrole :: x -> ((Year, Title), Role)
imdb :: Lens Imdb ([(((Year, Title), Nat), (Director, Value))], [(Name, [Category])])
actor :: Lens Actor (Name, [Category])
movie :: Lens Movie (Director, Value)
awards :: Lens [Played] [Category]
shows :: Lens [Show] [(((Year, Title), Nat), (Director, Value))]
boxoffices :: Lens [BoxOffice] Value
reviews :: Lens [Review] Nat
tv :: Lens TV [Episode]
imdb_opt :: Lens Imdb ([(((Year, Title), Nat), (Director, Value))], [(Name, [Category])])
actor_opt :: Lens Actor (Name, [Category])
movie_opt :: Lens Movie (Director, Value)
awards_opt :: Lens [Played] [Category]
shows_opt :: Lens [Show] [(((Year, Title), Nat), (Director, Value))]
boxoffices_opt :: Lens [BoxOffice] Value
reviews_opt :: Lens [Review] Nat


-- | Pointless Lenses: bidirectional lenses with point-free programming
--   
--   More example involving composed maps.
module Generics.Pointless.Lenses.Examples.MapExamples
mapbang_hand :: Lens [Either [(Int, Char)] [(Bool, Char)]] [One]
mapbang_pf :: Lens [Either [(Int, Char)] [(Bool, Char)]] [One]
mapbang_opt :: Lens [Either [(Int, Char)] [(Bool, Char)]] [One]
type Person = (Name, Gender)
type Name = String
data Gender
M :: Gender
F :: Gender
innGender :: Either One One -> Gender
outGender :: Gender -> Either One One
outGender_lns :: Lens Gender (Either One One)
women_hand :: Lens [Person] Nat
women_pf :: Lens [Person] Nat
women_opt :: Lens [Person] Nat
instance Eq Gender
instance Show Gender
instance Read Gender
instance Mu Gender
