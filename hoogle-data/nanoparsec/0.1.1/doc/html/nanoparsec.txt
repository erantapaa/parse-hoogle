-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of attoparsec-like parser around list-like
--   
--   An implementation of attoparsec-like parser around list-like
@package nanoparsec
@version 0.1.1


-- | Useful parser combinators, similar to those provided by Parsec.
module Data.Nanoparsec.Combinator

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]
skipMany :: Alternative f => f a -> f ()
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Zero or more.
many :: Alternative f => f a -> f [a]


-- | Simple, efficient combinator parsing for <tt>LL.ListLike</tt> lists
--   based on Attoparsec library.
module Data.Nanoparsec
data Parser δ a
data Result δ r
Fail :: !δ -> [String] -> String -> Result δ r
Partial :: (δ -> Result δ r) -> Result δ r
Done :: !δ -> r -> Result δ r

-- | Run a parser and return its result.
parse :: Monoid δ => Parser δ a -> δ -> Result δ a
feed :: Monoid δ => Result δ r -> δ -> Result δ r

-- | Run a parser with an initial input string, and a monadic action that
--   can supply more input if needed.
parseWith :: (Monad m, Monoid δ) => (m δ) -> Parser δ a -> δ -> m (Result δ a)

-- | Run a parser and print its result to standard output.
parseTest :: (Show a, Show δ, Monoid δ) => Parser δ a -> δ -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value. A
--   <a>Partial</a> result is treated as failure.
maybeResult :: Result δ r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value. A
--   <a>Partial</a> result is treated as failure.
eitherResult :: Result δ r -> Either String r

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
(<?>) :: Parser δ a -> String -> Parser δ a

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is useful in cases where a parser might consume some
--   input before failing, i.e. the parser needs arbitrary lookahead. The
--   downside to using this combinator is that it can retain input for
--   longer than is desirable.
try :: Monoid δ => Parser δ a -> Parser δ a
elem :: (Eq ε, Show ε, ListLike δ ε) => ε -> Parser δ ε
anyElem :: ListLike δ ε => Parser δ ε

-- | The parser <tt>satisfy p</tt> succeeds for any element for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the element that is
--   actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
--   </pre>
satisfy :: ListLike δ ε => (ε -> Bool) -> Parser δ ε

-- | The parser <tt>satisfyWith f p</tt> transforms an element, and
--   succeeds if the predicate <tt>p</tt> returns <a>True</a> on the
--   transformed value. The parser returns the transformed element that was
--   parsed.
satisfyWith :: ListLike δ ε => (ε -> a) -> (a -> Bool) -> Parser δ a

-- | The parser <tt>skip p</tt> succeeds for any element for which the
--   predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   space = skip isSpace
--       where isDigit w = w == 9 || w == 10 || w == 13 || w == 32
--   </pre>
skip :: ListLike δ ε => (ε -> Bool) -> Parser δ ()

-- | <tt>string s</tt> parses a sequence of elements that identically match
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This parser
--   consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt><a>for</a></tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In Nnaoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: (Eq δ, ListLike δ ε) => δ -> Parser δ δ
skipWhile :: ListLike δ ε => (ε -> Bool) -> Parser δ ()

-- | Consume exactly <tt>n</tt> elements of input.
take :: ListLike δ ε => Int -> Parser δ δ

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first element of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: ListLike δ ε => (ε -> Bool) -> Parser δ δ

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one element
--   of input: it will fail if the predicate never returns <a>True</a> or
--   if there is no input left.
takeWhile1 :: ListLike δ ε => (ε -> Bool) -> Parser δ δ

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first element of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: ListLike δ ε => (ε -> Bool) -> Parser δ δ

-- | Match only if all input has been consumed.
endOfInput :: ListLike δ ε => Parser δ ()

-- | Succeed only if at least <tt>n</tt> elements of input are available.
ensure :: ListLike δ ε => Int -> Parser δ ()

-- | Same as <tt>Applicative</tt>'s <tt>&lt;*</tt> but specialized.
(<*.) :: Monoid δ => Parser δ a -> Parser δ δ -> Parser δ a

-- | Same as <tt>Applicative</tt>'s <tt>*&gt;</tt> but specialized.
(.*>) :: Monoid δ => Parser δ δ -> Parser δ a -> Parser δ a
instance Functor (Result δ)
instance (Show δ, Show r) => Show (Result δ r)
