-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell implementation of Mustache templates
--   
--   Haskell implementation of Mustache templates
--   (<a>http://mustache.github.com/</a>).
--   
--   See homepage for examples of usage:
--   <a>http://github.com/lymar/hastache</a>
@package hastache
@version 0.6.1


-- | Haskell implementation of Mustache templates
--   
--   See homepage for examples of usage:
--   <a>http://github.com/lymar/hastache</a>
--   
--   Simplest example:
--   
--   <pre>
--   import           Text.Hastache
--   import           Text.Hastache.Context
--   import qualified Data.Text.Lazy.IO as TL
--   
--   main = do 
--       res &lt;- hastacheStr defaultConfig (encodeStr template)  
--           (mkStrContext context) 
--       TL.putStrLn res 
--     where 
--       template = "Hello, {{name}}!\n\nYou have {{unread}} unread messages." 
--       context "name" = MuVariable "Haskell"
--       context "unread" = MuVariable (100 :: Int)
--   </pre>
--   
--   Result:
--   
--   <pre>
--   Hello, Haskell!
--   
--   You have 100 unread messages.
--   </pre>
--   
--   Using Generics:
--   
--   <pre>
--   {-# LANGUAGE DeriveDataTypeable, OverloadedStrings #-}
--   
--   import           Text.Hastache
--   import           Text.Hastache.Context
--   import qualified Data.Text.Lazy.IO as TL
--   import           Data.Data
--   
--   data Info = Info {
--       name    :: String,
--       unread  :: Int
--       } deriving (Data, Typeable)
--   
--   main = do
--       res &lt;- hastacheStr defaultConfig template
--           (mkGenericContext inf)
--       TL.putStrLn res
--     where
--       template = "Hello, {{name}}!\n\nYou have {{unread}} unread messages."
--       inf = Info "Haskell" 100
--   </pre>
module Text.Hastache

-- | Render Hastache template from <a>Text</a>
hastacheStr :: MonadIO m => MuConfig m -> Text -> MuContext m -> m Text

-- | Render Hastache template from file
hastacheFile :: MonadIO m => MuConfig m -> FilePath -> MuContext m -> m Text

-- | Render Hastache template from <a>Text</a>
hastacheStrBuilder :: MonadIO m => MuConfig m -> Text -> MuContext m -> m Builder

-- | Render Hastache template from file
hastacheFileBuilder :: MonadIO m => MuConfig m -> FilePath -> MuContext m -> m Builder

-- | Data for Hastache variable
type MuContext m = Text -> m (MuType m)
data MuType m
MuVariable :: a -> MuType m
MuList :: [MuContext m] -> MuType m
MuBool :: Bool -> MuType m
MuLambda :: (Text -> a) -> MuType m
MuLambdaM :: (Text -> m a) -> MuType m
MuNothing :: MuType m
data MuConfig m
MuConfig :: (Text -> Text) -> Maybe FilePath -> Maybe String -> (FilePath -> m (Maybe Text)) -> MuConfig m

-- | Escape function (<a>htmlEscape</a>, <a>emptyEscape</a> etc.)
muEscapeFunc :: MuConfig m -> Text -> Text

-- | Directory for search partial templates (<tt>{{&gt;
--   templateName}}</tt>)
muTemplateFileDir :: MuConfig m -> Maybe FilePath

-- | Partial template files extension
muTemplateFileExt :: MuConfig m -> Maybe String

-- | Template retrieval function. <a>Nothing</a> indicates that the
--   template could not be found.
muTemplateRead :: MuConfig m -> FilePath -> m (Maybe Text)
class Show a => MuVar a where isEmpty _ = False
toLText :: MuVar a => a -> Text
isEmpty :: MuVar a => a -> Bool

-- | Left-leaning compoistion of contexts. Given contexts <tt>c1</tt> and
--   <tt>c2</tt>, the behaviour of <tt>(c1 &lt;&gt; c2) x</tt> is
--   following: if <tt>c1 x</tt> produces <a>MuNothing</a>, then the result
--   is <tt>c2 x</tt>. Otherwise the result is <tt>c1 x</tt>. Even if
--   <tt>c1 x</tt> is <a>MuNothing</a>, the monadic effects of <tt>c1</tt>
--   are still to take place.
composeCtx :: Monad m => MuContext m -> MuContext m -> MuContext m

-- | Escape HTML symbols
htmlEscape :: Text -> Text

-- | No escape
emptyEscape :: Text -> Text

-- | Default config: HTML escape function, current directory as template
--   directory, template file extension not specified
defaultConfig :: MonadIO m => MuConfig m

-- | Convert <a>String</a> to <a>Text</a>
encodeStr :: String -> Text

-- | Convert <a>String</a> to Lazy <a>Text</a>
encodeStrLT :: String -> Text

-- | Convert <a>Text</a> to <a>String</a>
decodeStr :: Text -> String

-- | Convert Lazy <a>Text</a> to <a>String</a>
decodeStrLT :: Text -> String
instance [incoherent] Show (MuType m)
instance [incoherent] MuVar [Char]
instance [incoherent] (MuVar a, MuVar b) => MuVar (Either a b)
instance [incoherent] MuVar a => MuVar (Maybe a)
instance [incoherent] MuVar a => MuVar [a]
instance [incoherent] MuVar Char
instance [incoherent] MuVar Version
instance [incoherent] MuVar ()
instance [incoherent] MuVar Word64
instance [incoherent] MuVar Word32
instance [incoherent] MuVar Word16
instance [incoherent] MuVar Word8
instance [incoherent] MuVar Word
instance [incoherent] MuVar Int64
instance [incoherent] MuVar Int32
instance [incoherent] MuVar Int16
instance [incoherent] MuVar Int8
instance [incoherent] MuVar Double
instance [incoherent] MuVar Float
instance [incoherent] MuVar Int
instance [incoherent] MuVar Integer
instance [incoherent] MuVar ByteString
instance [incoherent] MuVar ByteString
instance [incoherent] MuVar Text
instance [incoherent] MuVar Text
instance [incoherent] Monad m => Monoid (MuContext m)


-- | Hastache context helpers
module Text.Hastache.Context

-- | Make Hastache context from String -&gt; MuType function
mkStrContext :: Monad m => (String -> MuType m) -> MuContext m

-- | Make Hastache context from monadic String -&gt; MuType function
mkStrContextM :: Monad m => (String -> m (MuType m)) -> MuContext m

-- | Make Hastache context from Data.Data deriving type
--   
--   Supported field types:
--   
--   <ul>
--   <li>()</li>
--   <li>String</li>
--   <li>Char</li>
--   <li>Double</li>
--   <li>Float</li>
--   <li>Int</li>
--   <li>Int8</li>
--   <li>Int16</li>
--   <li>Int32</li>
--   <li>Int64</li>
--   <li>Integer</li>
--   <li>Word</li>
--   <li>Word8</li>
--   <li>Word16</li>
--   <li>Word32</li>
--   <li>Word64</li>
--   <li>Data.ByteString.ByteString</li>
--   <li>Data.ByteString.Lazy.ByteString</li>
--   <li>Data.Text.Text</li>
--   <li>Data.Text.Lazy.Text</li>
--   <li>Bool</li>
--   <li>Version</li>
--   <li>Maybe <tt>a</tt> (where <tt>a</tt> is a supported datatype)</li>
--   <li>Either <tt>a</tt> <tt>b</tt> (where <tt>a</tt> and <tt>b</tt> are
--   supported datatypes)</li>
--   <li>Data.Text.Text -&gt; Data.Text.Text</li>
--   <li>Data.Text.Text -&gt; Data.Text.Lazy.Text</li>
--   <li>Data.Text.Lazy.Text -&gt; Data.Text.Lazy.Text</li>
--   <li>Data.ByteString.ByteString -&gt; Data.ByteString.ByteString</li>
--   <li>String -&gt; String</li>
--   <li>Data.ByteString.ByteString -&gt;
--   Data.ByteString.Lazy.ByteString</li>
--   <li>MonadIO m =&gt; Data.Text.Text -&gt; m Data.Text.Text</li>
--   <li>MonadIO m =&gt; Data.Text.Text -&gt; m Data.Text.Lazy.Text</li>
--   <li>MonadIO m =&gt; Data.Text.Lazy.Text -&gt; m
--   Data.Text.Lazy.Text</li>
--   <li>MonadIO m =&gt; Data.ByteString.ByteString -&gt; m
--   Data.ByteString.ByteString</li>
--   <li>MonadIO m =&gt; String -&gt; m String</li>
--   <li>MonadIO m =&gt; Data.ByteString.ByteString -&gt; m
--   Data.ByteString.Lazy.ByteString</li>
--   </ul>
--   
--   Example:
--   
--   <pre>
--   import Text.Hastache 
--   import Text.Hastache.Context
--   import qualified Data.Text as T
--   import qualified Data.Text.Lazy as TL
--   import qualified Data.Text.Lazy.IO as TL
--   import Data.Data 
--   import Data.Generics 
--   import Data.Char
--   
--   data InternalData = InternalData {
--       someField       :: String,
--       anotherField    :: Int
--       } deriving (Data, Typeable, Show)
--   
--   data Example = Example {
--       stringField             :: String,
--       intField                :: Int,
--       dataField               :: InternalData,
--       simpleListField         :: [String],
--       dataListField           :: [InternalData],
--       stringFunc              :: String -&gt; String,
--       textFunc                :: T.Text -&gt; T.Text,
--       monadicStringFunc       :: String -&gt; IO String,
--       monadicTextFunc         :: T.Text -&gt; IO T.Text
--       } deriving (Data, Typeable)
--   
--   example = hastacheStr defaultConfig (encodeStr template) 
--       (mkGenericContext context)
--       where
--       template = unlines [
--           "string: {{stringField}}",
--           "int: {{intField}}",
--           "data: {{dataField.someField}}, {{dataField.anotherField}}",
--           "data: {{#dataField}}{{someField}}, {{anotherField}}{{/dataField}}",
--           "simple list: {{#simpleListField}}{{.}} {{/simpleListField}}",
--           "data list:",
--           "{{#dataListField}}",
--           " * {{someField}}, {{anotherField}}. top level var: {{intField}}",
--           "{{/dataListField}}",
--           "{{#stringFunc}}upper{{/stringFunc}}",
--           "{{#textFunc}}reverse{{/textFunc}}",
--           "{{#monadicStringFunc}}upper (monadic){{/monadicStringFunc}}",
--           "{{#monadicTextFunc}}reverse (monadic){{/monadicTextFunc}}"]
--       context = Example { stringField = "string value", intField = 1, 
--           dataField = InternalData "val" 123, simpleListField = ["a","b","c"],
--           dataListField = [InternalData "aaa" 1, InternalData "bbb" 2],
--           stringFunc = map toUpper,
--           textFunc = T.reverse,
--           monadicStringFunc = return . map toUpper,
--           monadicTextFunc = return . T.reverse }
--   
--   main = example &gt;&gt;= TL.putStrLn
--   </pre>
--   
--   Result:
--   
--   <pre>
--   string: string value 
--   int: 1 
--   data: val, 123 
--   data: val, 123 
--   simple list: a b c  
--   data list: 
--    * aaa, 1. top level var: 1 
--    * bbb, 2. top level var: 1 
--   UPPER 
--   esrever 
--   UPPER (MONADIC)
--   )cidanom( esrever
--   </pre>
--   
--   Hastache also supports datatypes with multiple constructors:
--   
--   <pre>
--   data A = A { str :: String }
--          | B { num :: Int }
--   
--   {{#A}}
--   A : {{str}}
--   {{/A}}
--   {{#B}}
--   B : {{num}}
--   {{/B}}
--   </pre>
mkGenericContext :: (Monad m, Data a, Typeable m) => a -> MuContext m

-- | Like <a>mkGenericContext</a>, but apply the first function to record
--   field names when constructing the context. The second function is used
--   to constructing values for context from datatypes that are nor
--   supported as primitives in the library. The resulting value can be
--   accessed using the <tt>.DatatypeName</tt> field:
--   
--   <pre>
--   {-# LANGUAGE DeriveDataTypeable #-}
--   {-# LANGUAGE FlexibleInstances #-}
--   {-# LANGUAGE ScopedTypeVariables #-}
--   {-# LANGUAGE StandaloneDeriving #-}
--   {-# LANGUAGE TypeSynonymInstances #-}
--   import Text.Hastache 
--   import Text.Hastache.Context 
--   
--   import qualified Data.Text.Lazy as TL 
--   import qualified Data.Text.Lazy.IO as TL 
--   
--   import Data.Data (Data, Typeable)
--   import Data.Decimal
--   import Data.Generics.Aliases (extQ)
--   
--   data Test = Test {n::Int, m::Decimal} deriving (Data, Typeable)
--   deriving instance Data Decimal
--   
--   val :: Test
--   val = Test 1 (Decimal 3 1500)
--   
--   q :: Ext
--   q = defaultExt `extQ` ((i::Decimal) -&gt; "A decimal: " ++ show i)
--   
--   r "m" = "moo"
--   r x   = x
--   
--   example :: IO TL.Text
--   example = hastacheStr defaultConfig
--                         (encodeStr template)
--                         (mkGenericContext' r q val)
--   
--   template = concat [ 
--        "{{n}}\n",
--        "{{moo.Decimal}}"
--        ] 
--   
--   main = example &gt;&gt;= TL.putStrLn
--   </pre>
--   
--   Result:
--   
--   <pre>
--   1
--   A decimal: 1.500
--   </pre>
mkGenericContext' :: (Monad m, Data a, Typeable m) => (String -> String) -> Ext -> a -> MuContext m
type Ext = forall b. (Data b, Typeable b) => b -> String

-- | <tt>defaultExt ==</tt> <a>gshow</a>
defaultExt :: Ext
instance Show (TD m)
