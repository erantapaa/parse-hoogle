-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a code generator for partial differential equations solvers.
--   
@package Paraiso
@version 0.3.1.3

module Language.Paraiso.OM.Arithmetic
class Arity a
arity :: Arity a => a -> (Int, Int)
arityI :: Arity a => a -> Int
arityO :: Arity a => a -> Int
data Operator
Identity :: Operator
Add :: Operator
Sub :: Operator
Neg :: Operator
Mul :: Operator
Div :: Operator
Mod :: Operator
DivMod :: Operator
Inv :: Operator
Not :: Operator
And :: Operator
Or :: Operator
EQ :: Operator
NE :: Operator
LT :: Operator
LE :: Operator
GT :: Operator
GE :: Operator
Max :: Operator
Min :: Operator
Abs :: Operator
Signum :: Operator
Select :: Operator

-- | x^y where y is an integer
Ipow :: Operator

-- | x^y where y is real number
Pow :: Operator
Madd :: Operator
Msub :: Operator
Nmadd :: Operator
Nmsub :: Operator
Sqrt :: Operator
Exp :: Operator
Log :: Operator
Sin :: Operator
Cos :: Operator
Tan :: Operator
Asin :: Operator
Acos :: Operator
Atan :: Operator
Atan2 :: Operator
Sincos :: Operator
Cast :: TypeRep -> Operator
instance Eq Operator
instance Ord Operator
instance Show Operator
instance Arity Operator

module Language.Paraiso.OM.Reduce
data Operator
Max :: Operator
Min :: Operator
Sum :: Operator
toArith :: Operator -> Operator
instance Eq Operator
instance Ord Operator
instance Show Operator
instance Read Operator


-- | The <a>Realm</a> represents how the data reside in Orthotope Machines.
--   <a>Array</a> data are n-dimensional array that is distributed among
--   nodes. <a>Scalar</a> data are single-point value, possibly reside in
--   the master node. . Be noted that <a>Array</a> and <a>Scalar</a> were
--   initially called <tt>Local</tt> and <tt>Global</tt>. but I opted for
--   more conventional notation. If you find any historical notation
--   remaining, please let me know!
module Language.Paraiso.OM.Realm

-- | Type-level representation of <a>Scalar</a> realm
data TScalar
TScalar :: TScalar

-- | Type-level representation of <a>Array</a> realm
data TArray
TArray :: TArray

-- | Type-level representations of realm
class TRealm a
tRealm :: TRealm a => a -> Realm
unitTRealm :: TRealm a => a

-- | Value-level representations of realm
data Realm

-- | Value-level representation of <a>Scalar</a> realm
Scalar :: Realm

-- | Value-level representation of <a>Array</a> realm
Array :: Realm

-- | Means of obtaining value-level realm from things
class Realmable a
realm :: Realmable a => a -> Realm
instance Eq Realm
instance Show Realm
instance Realmable TArray
instance Realmable TScalar
instance Realmable Realm
instance TRealm TArray
instance TRealm TScalar


-- | The <a>Value</a> is flowing through the OM dataflow graph.
--   <a>Value</a> carries the type and homogeneity information about the
--   dataflow as Type. Therefore, operation between <a>Value</a> with wrong
--   type will raise type errors.
module Language.Paraiso.OM.Value

-- | value type, with its realm and content type discriminated in type
--   level
data Value rea con

-- | data obtained from the dataflow graph. <a>realm</a> carries a
--   type-level realm information, <a>content</a> carries only type
--   information and its ingredient is nonsignificant and can be
--   <a>undefined</a>.
FromNode :: rea -> con -> Node -> Value rea con
realm :: Value rea con -> rea
content :: Value rea con -> con
node :: Value rea con -> Node

-- | data obtained as an immediate value. <a>realm</a> carries a type-level
--   realm information, <a>content</a> is the immediate value to be stored.
FromImm :: rea -> con -> Value rea con
realm :: Value rea con -> rea
content :: Value rea con -> con

-- | static value type.
data StaticValue rea con
StaticValue :: rea -> con -> StaticValue rea con
instance (Eq rea, Eq con) => Eq (Value rea con)
instance (Show rea, Show con) => Show (Value rea con)
instance (Eq rea, Eq con) => Eq (StaticValue rea con)
instance (Show rea, Show con) => Show (StaticValue rea con)
instance (TRealm rea, Typeable con) => Realmable (Value rea con)


-- | The <a>DynValue</a> is stored in the OM dataflow graph type.
--   <a>DynValue</a> carries the type and homogeneity information in value.
--   Therefore, <a>DynValue</a> with various types can be stored in single
--   container type such as graph.
module Language.Paraiso.OM.DynValue

-- | dynamic value type, with its realm and content type informed as values
data DynValue
DynValue :: Realm -> TypeRep -> DynValue
realm :: DynValue -> Realm
typeRep :: DynValue -> TypeRep

-- | Make <a>DynValue</a> value-level type, from the pair of Type-level
--   type.
mkDyn :: (TRealm r, Typeable c) => r -> c -> DynValue

-- | map <a>toDyn</a> over functors. an idiom used in collecting OM static
--   variables.
f2d :: (Functor f, ToDynable x) => f x -> f DynValue

-- | Something that can be converted to <a>DynValue</a>
class ToDynable a
toDyn :: ToDynable a => a -> DynValue
instance Eq DynValue
instance Show DynValue
instance Realmable DynValue
instance (TRealm r, Typeable c) => ToDynable (StaticValue r c)
instance (TRealm r, Typeable c) => ToDynable (Value r c)


-- | name identifier.
module Language.Paraiso.Name

-- | something that has name.
class Nameable a where nameText = (\ (Name str) -> str) . name nameStr = unpack . (\ (Name str) -> str) . name
name :: Nameable a => a -> Name
nameText :: Nameable a => a -> Text
nameStr :: Nameable a => a -> String

-- | a name.
data Name

-- | create a name from a <a>Text</a>. We do not export the constructor
--   <a>Name</a> for future extensibility.
mkName :: Text -> Name

-- | create Named object in an instance.
isNameOf :: Text -> a -> Named a

-- | Convert some type to a named type.
data Named a
Named :: Name -> a -> Named a

-- | The thing the name points to.
namee :: Named a -> a
instance Read a => Read (Named a)
instance Show a => Show (Named a)
instance Eq a => Eq (Named a)
instance Eq Name
instance Ord Name
instance Show Name
instance Read Name
instance Ord a => Ord (Named a)
instance Functor Named
instance Nameable (Named a)
instance Nameable Name


-- | the components for constructing Orthotope Machine data flow draph.
--   Most components take three arguments:
--   
--   <ul>
--   <li><i><tt>vector :: * -&gt; *</tt></i> The array dimension. It is a
--   <a>Vector</a> that defines the dimension of the Orthotope on which the
--   OM operates.</li>
--   <li><i><tt>gauge :: *</tt></i> The array index. The combination
--   <tt>vector gauge</tt> needs to be an instance of <a>C</a> if you want
--   to perform <tt>Shift</tt> operation.</li>
--   <li><i><tt>anot :: *</tt></i> The annotations put on each node. If you
--   want to use Annotation, <tt>anot</tt> needs to be an instance of
--   <a>Monoid</a>.</li>
--   </ul>
module Language.Paraiso.OM.Graph

-- | An OM Setup, a set of information needed before you start building a
--   <a>Kernel</a>.
data Setup (vector :: * -> *) gauge anot
Setup :: Vector (Named DynValue) -> anot -> Setup gauge anot

-- | The list of static orthotopes (its identifier, Realm and Type carried
--   in the form of <tt>NamedValue</tt>)
staticValues :: Setup gauge anot -> Vector (Named DynValue)

-- | The machine-global annotations
globalAnnotation :: Setup gauge anot -> anot

-- | A <a>Kernel</a> for OM perfor a block of calculations on OM.
data Kernel vector gauge anot
Kernel :: Name -> Graph vector gauge anot -> Kernel vector gauge anot
kernelName :: Kernel vector gauge anot -> Name
dataflow :: Kernel vector gauge anot -> Graph vector gauge anot

-- | The dataflow graph for Orthotope Machine. anot is an additional
--   annotation.
type Graph vector gauge anot = Gr (Node vector gauge anot) Edge

-- | Map the <a>Graph</a> annotation from one type to another.
--   Unfortunately we cannot make one data both the instances of
--   <a>Graph</a> and <a>Functor</a>, so <a>nmap</a> is a standalone
--   function.
nmap :: (a -> b) -> Graph v g a -> Graph v g b

-- | Map the <a>Graph</a> annotation from one type to another, while
--   referring to the node indices.
imap :: (Node -> a -> b) -> Graph v g a -> Graph v g b

-- | get annotation of the node.
getA :: Node v g a -> a

-- | The <a>Node</a> for the dataflow <a>Graph</a> of the Orthotope
--   machine. The dataflow graph is a 2-part graph consisting of
--   <a>NValue</a> and <a>NInst</a> nodes.
data Node vector gauge anot

-- | A value node. An <a>NValue</a> node only connects to <a>NInst</a>
--   nodes. An <a>NValue</a> node has one and only one input edge, and has
--   arbitrary number of output edges.
NValue :: DynValue -> anot -> Node vector gauge anot

-- | An instruction node. An <a>NInst</a> node only connects to
--   <a>NValue</a> nodes. The number of input and output edges an
--   <a>NValue</a> node has is specified by its <a>Arity</a>.
NInst :: (Inst vector gauge) -> anot -> Node vector gauge anot

-- | The <a>Edge</a> label for the dataflow <a>Graph</a>. | It keeps track
--   of the order of the arguments.
data Edge

-- | an unordered edge.
EUnord :: Edge

-- | edges where the order matters.
EOrd :: Int -> Edge
newtype StaticIdx
StaticIdx :: Int -> StaticIdx
fromStaticIdx :: StaticIdx -> Int
data Inst vector gauge
Load :: StaticIdx -> Inst vector gauge
Store :: StaticIdx -> Inst vector gauge
Reduce :: Operator -> Inst vector gauge
Broadcast :: Inst vector gauge
LoadIndex :: (Axis vector) -> Inst vector gauge
LoadSize :: (Axis vector) -> Inst vector gauge
Shift :: (vector gauge) -> Inst vector gauge
Imm :: Dynamic -> Inst vector gauge
Arith :: Operator -> Inst vector gauge
instance Eq anot => Eq (Setup vector gauge anot)
instance Show anot => Show (Setup vector gauge anot)
instance Eq Edge
instance Ord Edge
instance Show Edge
instance Show (vector gauge) => Show (Inst vector gauge)
instance (Show anot, Show (vector gauge)) => Show (Node vector gauge anot)
instance (Show anot, Show (vector gauge)) => Show (Kernel vector gauge anot)
instance Arity (Inst vector gauge)
instance Show StaticIdx
instance Functor (Node v g)
instance Nameable (Kernel v g a)


-- | a module for handling failure
module Language.Paraiso.Failure
unsafePerformFailure :: IO a -> a


-- | In mathematics, a pi-system is a non-empty family of sets that is
--   closed under finite intersections.
module Language.Paraiso.PiSystem
class PiSystem a
empty :: PiSystem a => a
null :: PiSystem a => a -> Bool
intersection :: PiSystem a => a -> a -> a
instance [overlap ok] (PiSystem a, Vector v) => PiSystem (v a)


-- | an <a>Interval</a> is a pair of <a>lower</a> and <a>upper</a>,
--   representing some interval in ordered system. The lower bound is
--   inclusive and the upper bound is exclusive: (<a>lower</a> &lt;= x &lt;
--   <a>upper</a>) . The intersection of two intervals are also interval
--   but the union of two intervals are not, so <a>Interval</a> constitute
--   a <a>PiSystem</a>.
module Language.Paraiso.Interval
data Interval a

-- | an empty interval.
Empty :: Interval a

-- | a non-empty interval.
Interval :: a -> a -> Interval a
lower :: Interval a -> a
upper :: Interval a -> a
instance [incoherent] Typeable Interval
instance [incoherent] Eq a => Eq (Interval a)
instance [incoherent] Show a => Show (Interval a)
instance [incoherent] Ord a => PiSystem (Interval a)


-- | In geometry, an <tt>Orthotope</tt> (also called a hyperrectangle or a
--   box) is the generalization of a rectangle for higher dimensions,
--   formally defined as the Cartesian product of <a>Interval</a>s.
module Language.Paraiso.Orthotope
type Orthotope0 a = Vec0 (Interval a)
type Orthotope1 a = Vec1 (Interval a)
type Orthotope2 a = Vec2 (Interval a)
type Orthotope3 a = Vec3 (Interval a)


-- | an extension of the standard Prelude for paraiso.
module Language.Paraiso.Prelude
class Boolean b
true, false :: Boolean b => b
not :: Boolean b => b -> b
(&&, ||) :: Boolean b => b -> b -> b

-- | An efficient String that is used thoroughout Paraiso modules.
type Text = Text
showT :: Show a => a -> Text
(++) :: Appendable a => a -> a -> a
instance Boolean Bool
instance Appendable Text
instance Appendable [a]


-- | An <tt>Annotation</tt> that sets the execution priority of the
--   statements. Statements with <tt>Ballon</tt>s will be allocated as fast
--   as possible, and statements with negative ballons, or <tt>Stone</tt>s,
--   will be allocated as later as possible.
module Language.Paraiso.Annotation.Balloon
data (Ord a, Typeable a) => Balloon a
Balloon :: a -> Balloon a
instance Typeable Balloon
instance (Ord a, Typeable a) => Eq (Balloon a)
instance (Ord a, Typeable a) => Ord (Balloon a)


-- | calculate the <a>Valid</a> regions for each <tt>Orthotope</tt> value
--   where all information needed to update the region is available. also
--   annotates the global boundary condition.
module Language.Paraiso.Annotation.Boundary

-- | a type that represents valid region of computation.
newtype Valid g
Valid :: [Interval (NearBoundary g)] -> Valid g

-- | the displacement around either side of the boundary.
data NearBoundary a
NegaInfinity :: NearBoundary a
LowerBoundary :: a -> NearBoundary a
UpperBoundary :: a -> NearBoundary a
PosiInfinity :: NearBoundary a

-- | type for global boundary conditions
data Condition

-- | open boundary; do not touch anything
Open :: Condition

-- | cyclic boundary; data out of the bounds are copied from the other side
Cyclic :: Condition
instance Typeable NearBoundary
instance Typeable Valid
instance Eq a => Eq (NearBoundary a)
instance Ord a => Ord (NearBoundary a)
instance Show a => Show (NearBoundary a)
instance Eq g => Eq (Valid g)
instance Show g => Show (Valid g)
instance Eq Condition
instance Read Condition
instance Show Condition
instance Ord g => PiSystem (Valid g)


-- | An effectless <tt>Annotation</tt> with a comment
module Language.Paraiso.Annotation.Comment
data Comment
Comment :: Text -> Comment
instance Typeable Comment
instance Eq Comment
instance Show Comment


-- | An <tt>Annotation</tt> that describes the dependency of the nodes and
--   labels certain group of Manifest nodes that can safely be accessed
--   simultaneously
module Language.Paraiso.Annotation.Dependency

-- | The list of Manifest or Existing nodes that this node directly depends
--   on. Y directly depends on X if you need to read X in subroutine you
--   calculate Y
newtype Direct
Direct :: [Node] -> Direct

-- | The list of All nodes that this node directly depends on. Y directly
--   depends on X if you need to calculate X in subroutine you calculate Y
newtype Calc
Calc :: (Set Node) -> Calc

-- | The list of Manifest or Existing nodes that this node indirectly
--   depends on. Y indirectly depends on X if you need to calculate X
--   before you calculace Y
newtype Indirect
Indirect :: [Node] -> Indirect

-- | Write grouping, continuously numbered from [0 ..] . The numbering
--   starts from 0 for each kerenel in a Orthotope Machine.
data KernelWriteGroup
KernelWriteGroup :: Int -> KernelWriteGroup
getKernelGroupID :: KernelWriteGroup -> Int

-- | Write grouping, continuously numbered from [0 ..] . The numbering is
--   unique in one Orthotope Machine.
data OMWriteGroup
OMWriteGroup :: Int -> OMWriteGroup
getOMGroupID :: OMWriteGroup -> Int
instance Typeable Direct
instance Typeable Indirect
instance Typeable Calc
instance Typeable KernelWriteGroup
instance Typeable OMWriteGroup
instance Eq Direct
instance Show Direct
instance Eq Indirect
instance Show Indirect
instance Eq Calc
instance Show Calc
instance Eq KernelWriteGroup
instance Show KernelWriteGroup
instance Eq OMWriteGroup
instance Show OMWriteGroup


-- | An effectless <tt>Annotation</tt> with a comment
module Language.Paraiso.Annotation.Execution

-- | used in dead code elimination.
data Alive
Alive :: Bool -> Alive
instance Typeable Alive
instance Eq Alive
instance Show Alive


-- | An <tt>Annotation</tt> that lets you call __syncthreads() before or
--   after a statement.
module Language.Paraiso.Annotation.SyncThreads
data Timing
Pre :: Timing
Post :: Timing
instance Typeable Timing
instance Eq Timing
instance Ord Timing


-- | <ul>
--   <li><i>CLARIS</i> C++-Like Abstract Representation of Intermediate
--   Syntax.</li>
--   </ul>
--   
--   Claris connects the higher-level concepts to native languages with
--   capability to describe C++ syntax such as classes and containers.
--   Claris also have support for extension made by C++-like languages such
--   as CUDA qualifier and kernel call.
--   
--   The design goal of Claris is to cover the necessity of the code
--   generation and to make it simple. Claris is not designed for syntatic
--   correctness, and it's possible to describe a Claris code that will
--   cause a compile error in C++.
--   
--   In Claris, variables, functions and classes are described in a unified
--   manner that supports both the declaration and definition. From that
--   information, the declarations and definitions are generated at
--   appropriate places.
module Language.Paraiso.Generator.Claris

-- | A Claris program.
data Program
Program :: Name -> [Statement] -> Program

-- | the name of the program
progName :: Program -> Name

-- | the top-level elements of the program.
topLevel :: Program -> [Statement]

-- | C++ class descriptions are separated to two files
data FileType
HeaderFile :: FileType
SourceFile :: FileType

-- | C++ top-level statements
data Statement

-- | Preprosessor directive
StmtPrpr :: Preprocessing -> Statement

-- | Name space declaration
UsingNamespace :: Name -> Statement

-- | Class definition
ClassDef :: Class -> Statement

-- | Function definition
FuncDef :: Function -> Statement

-- | variable definition as an expression
VarDef :: Var -> Statement

-- | define a variable and call a constructor
VarDefCon :: Var -> [Expr] -> Statement

-- | define a variable and substitute a value
VarDefSub :: Var -> Expr -> Statement

-- | Expression
StmtExpr :: Expr -> Statement

-- | While loop
StmtWhile :: Expr -> [Statement] -> Statement

-- | For loop
StmtFor :: Statement -> Expr -> Expr -> [Statement] -> Statement

-- | return
StmtReturn :: Expr -> Statement

-- | A statement that is included exclusively in either of the file type
Exclusive :: FileType -> Statement -> Statement

-- | text directly embedded into source code
RawStatement :: Text -> Statement

-- | a comment
Comment :: Text -> Statement

-- | Preprocessor directive
data Preprocessing
PrprInclude :: Parenthesis -> Text -> Preprocessing
PrprPragma :: Text -> Preprocessing

-- | description C++ type
data TypeRep

-- | Types for simple objects
UnitType :: TypeRep -> TypeRep

-- | Pointer type
PtrOf :: TypeRep -> TypeRep

-- | Reference type
RefOf :: TypeRep -> TypeRep

-- | Constant type
Const :: TypeRep -> TypeRep

-- | A template type
TemplateType :: Text -> [TypeRep] -> TypeRep

-- | Qualified type
QualifiedType :: [Qualifier] -> TypeRep -> TypeRep

-- | the type of mu which is returned from constructor / destructor
ConstructorType :: TypeRep

-- | the type of kuu that is detached from reincarnation
UnknownType :: TypeRep

-- | make C++ type from Haskell objects
typeOf :: Typeable a => a -> TypeRep

-- | make a C++ expression from Haskell objects
toDyn :: Typeable a => a -> Expr

-- | C++ class
data Class
Class :: Name -> [MemberDef] -> Class
className :: Class -> Name
classMember :: Class -> [MemberDef]

-- | C++ class member definition
data MemberDef

-- | A member function
MemberFunc :: AccessModifier -> Bool -> Function -> MemberDef
memberAccess :: MemberDef -> AccessModifier
inlined :: MemberDef -> Bool
memberFunc :: MemberDef -> Function

-- | A member variable
MemberVar :: AccessModifier -> Var -> MemberDef
memberAccess :: MemberDef -> AccessModifier
memberVar :: MemberDef -> Var

-- | C++ class member access modifier
data AccessModifier
Private :: AccessModifier
Protected :: AccessModifier
Public :: AccessModifier

-- | C++ syntax for variable definition
--   
--   C++ function definition
data Function
Function :: Name -> TypeRep -> [Var] -> [Statement] -> [Expr] -> Function
funcName :: Function -> Name
funcType :: Function -> TypeRep
funcArgs :: Function -> [Var]
funcBody :: Function -> [Statement]
funcMemberInitializer :: Function -> [Expr]

-- | A default function maker
function :: TypeRep -> Name -> Function

-- | <ul>
--   <li><i>CUDA extension</i> qualifiers to use accelerator</li>
--   </ul>
data Qualifier
CudaGlobal :: Qualifier
CudaDevice :: Qualifier
CudaHost :: Qualifier
CudaShared :: Qualifier
CudaConst :: Qualifier

-- | C++ Variable definition
data Var
Var :: TypeRep -> Name -> Var

-- | C++ Expression
data Expr

-- | an immediate
Imm :: Dynamic -> Expr

-- | an expression made of a variable
VarExpr :: Var -> Expr

-- | user function call
FuncCallUsr :: Name -> [Expr] -> Expr

-- | builtin function call
FuncCallStd :: Text -> [Expr] -> Expr

-- | cuda function call with Grid topology
CudaFuncCallUsr :: Name -> Expr -> Expr -> [Expr] -> Expr

-- | access a member of an object
MemberAccess :: Expr -> Expr -> Expr

-- | prefix unary operator
Op1Prefix :: Text -> Expr -> Expr

-- | postfix unary operator
Op1Postfix :: Text -> Expr -> Expr

-- | infix binary operator
Op2Infix :: Text -> Expr -> Expr -> Expr

-- | sandwiched trinity operator
Op3Infix :: Text -> Text -> Expr -> Expr -> Expr -> Expr

-- | access a component of an array
ArrayAccess :: Expr -> Expr -> Expr

-- | commented expr
CommentExpr :: Text -> Expr -> Expr

-- | parentheses used in C++
data Parenthesis

-- | expression coupling, function call
Paren :: Parenthesis

-- | array access
Bracket :: Parenthesis

-- | create a code block
Brace :: Parenthesis

-- | tepmplate type
Chevron :: Parenthesis

-- | not used
Chevron2 :: Parenthesis

-- | CUDA kernel call
Chevron3 :: Parenthesis

-- | character
Quotation :: Parenthesis

-- | string
Quotation2 :: Parenthesis

-- | comment
SlashStar :: Parenthesis
instance Eq FileType
instance Show FileType
instance Eq AccessModifier
instance Show AccessModifier
instance Eq Qualifier
instance Show Qualifier
instance Eq TypeRep
instance Show TypeRep
instance Eq Var
instance Show Var
instance Show Expr
instance Eq Parenthesis
instance Show Parenthesis
instance Eq Preprocessing
instance Show Preprocessing
instance Eq Statement
instance Show Statement
instance Eq Function
instance Show Function
instance Eq Class
instance Show Class
instance Eq MemberDef
instance Show MemberDef
instance Show Program
instance C Expr
instance C Expr
instance C Expr
instance C Expr
instance Eq Expr
instance Nameable Var
instance Nameable Function
instance Nameable Class
instance Nameable Program

module Language.Paraiso.Generator.ClarisTrans
class Translatable a
translate :: Translatable a => Context -> a -> Text

-- | an parenthesizer for lazy person.
paren :: Parenthesis -> Text -> Text
joinBy :: Text -> [Text] -> Text
joinEndBy :: Text -> [Text] -> Text
joinBeginBy :: Text -> [Text] -> Text
joinBeginEndBy :: Text -> [Text] -> Text
headerFile :: Context
sourceFile :: Context
data Context

-- | The databeses for Haskell -&gt; Cpp type name translations.
typeRepDB :: TypeRep -> Maybe Text

-- | The databeses for Haskell -&gt; Cpp immediate values translations.
dynamicDB :: Dynamic -> Maybe Text
instance Eq Namespace
instance Show Namespace
instance Eq Context
instance Show Context
instance Translatable Expr
instance Translatable Var
instance Translatable Dynamic
instance Translatable TypeRep
instance Translatable Qualifier
instance Translatable TypeRep
instance Translatable Function
instance Translatable AccessModifier
instance Translatable Class
instance Translatable Preprocessing
instance Translatable Statement
instance Translatable Program
instance Nameable Namespace


-- | Taking the optimized OM as the input, The <a>Plan</a> summarizes and
--   fixes the detail of the code generation, such as amount of memory to
--   be allocated, the extra subroutines which does internal calculations,
--   and decisions on which part of calculation each subroutines make etc.
module Language.Paraiso.Generator.Plan

-- | A data structure that contains all informations for code generation.
data Plan v g a
Plan :: Name -> Setup v g a -> Vector (StorageRef v g a) -> Vector (Kernel v g a) -> Vector (SubKernelRef v g a) -> v g -> v g -> Plan v g a

-- | name of the plan
planName :: Plan v g a -> Name

-- | OM setup, includes all static variables
setup :: Plan v g a -> Setup v g a

-- | Newly allocated Manifest variables
storages :: Plan v g a -> Vector (StorageRef v g a)

-- | kernels
kernels :: Plan v g a -> Vector (Kernel v g a)

-- | subkernels
subKernels :: Plan v g a -> Vector (SubKernelRef v g a)

-- | the total lower margin of the OM, large enough to fit all the kernels
lowerMargin :: Plan v g a -> v g

-- | the total upper margin of the OM, large enough to fit all the kernels
upperMargin :: Plan v g a -> v g

-- | subroutines that executes portion of a calculations for certain kernel
data SubKernelRef v g a
SubKernelRef :: Plan v g a -> Int -> Int -> Vector Node -> Vector Node -> Vector Node -> Realm -> v g -> v g -> SubKernelRef v g a
subKernelParent :: SubKernelRef v g a -> Plan v g a
kernelIdx :: SubKernelRef v g a -> Int
omWriteGroupIdx :: SubKernelRef v g a -> Int
inputIdxs :: SubKernelRef v g a -> Vector Node
calcIdxs :: SubKernelRef v g a -> Vector Node
outputIdxs :: SubKernelRef v g a -> Vector Node
subKernelRealm :: SubKernelRef v g a -> Realm
lowerBoundary :: SubKernelRef v g a -> v g
upperBoundary :: SubKernelRef v g a -> v g

-- | refers to a storage required in the plan
data StorageRef v g a
StorageRef :: Plan v g a -> StorageIdx -> DynValue -> StorageRef v g a
storageRefParent :: StorageRef v g a -> Plan v g a
storageIdx :: StorageRef v g a -> StorageIdx
storageDynValue :: StorageRef v g a -> DynValue
data StorageIdx

-- | (StatigRef plan i) = i'th static variable in the plan
StaticRef :: Int -> StorageIdx

-- | (ManifestRef plan i j) = j'th node of the i'th kernel in the plan
ManifestRef :: Int -> Node -> StorageIdx

-- | a data that holds referrence to the Plan it belongs to.
class Referrer a b | a -> b
parent :: Referrer a b => a -> b
dataflow :: SubKernelRef v g a -> Graph v g a

-- | a list of inputs the subroutine needs.
labNodesIn :: SubKernelRef v g a -> Vector (LNode (Node v g a))

-- | a list of outputs the subroutine makes.
labNodesOut :: SubKernelRef v g a -> Vector (LNode (Node v g a))

-- | all the caclulations performed in the subroutine.
labNodesCalc :: SubKernelRef v g a -> Vector (LNode (Node v g a))

-- | get the DynValue description for a storage referrence.
storageType :: StorageRef v g a -> DynValue
instance Eq StorageIdx
instance Show StorageIdx
instance Realmable (StorageRef v g a)
instance Nameable (StorageRef v g a)
instance Referrer (StorageRef v g a) (Plan v g a)
instance Realmable (SubKernelRef v g a)
instance Nameable (SubKernelRef v g a)
instance Referrer (SubKernelRef v g a) (Plan v g a)
instance Nameable (Plan v g a)


-- | A monadic library to build dataflow graphs for OM. Builder is only for
--   Graph vector gauge () . Graphs with other annotation types can be
--   created by fmap. This module exports everything, for writing other
--   Builder modules.
module Language.Paraiso.OM.Builder.Internal

-- | The <a>Builder</a> monad is used to build <a>Kernel</a>s.
type Builder (vector :: * -> *) (gauge :: *) (anot :: *) (val :: *) = State (BuilderState vector gauge anot) val
data BuilderState vector gauge anot
BuilderState :: Setup vector gauge anot -> BuilderContext anot -> Graph vector gauge anot -> BuilderState vector gauge anot
setup :: BuilderState vector gauge anot -> Setup vector gauge anot
context :: BuilderState vector gauge anot -> BuilderContext anot
target :: BuilderState vector gauge anot -> Graph vector gauge anot
type B ret = forall (v :: * -> *) (g :: *) (a :: *). Builder v g a ret
type BuilderOf r c = forall (v :: * -> *) (g :: *) (a :: *). Builder v g a (Value r c)

-- | Create a <a>Kernel</a> from a <a>Builder</a> monad.
buildKernel :: Setup v g a -> Name -> Builder v g a () -> Kernel v g a

-- | Create an initial state for <a>Builder</a> monad from a OM
--   <a>Setup</a>.
initState :: Setup v g a -> BuilderState v g a

-- | Modify the dataflow graph stored in the <a>Builder</a>.
modifyG :: (Graph v g a -> Graph v g a) -> Builder v g a ()

-- | Get the graph stored in the <a>Builder</a>.
getG :: Builder v g a (Graph v g a)

-- | get the number of the next unoccupied <a>Node</a> in the graph.
freeNode :: B Node

-- | add a node to the graph.
addNode :: [Node] -> Node v g a -> Builder v g a Node

-- | add a node to the graph with an empty Annotation.
addNodeE :: [Node] -> (a -> Node v g a) -> Builder v g a Node

-- | convert a <a>Value</a> to a
valueToNode :: (TRealm r, Typeable c) => Value r c -> B Node

-- | look up the <a>Named</a> <a>DynValue</a> with the correct name and
--   type is included in the <a>staticValues</a> of the <a>BuilderState</a>
lookUpStatic :: Named DynValue -> B StaticIdx

-- | run the given builder monad, get the result graph node, and wrap it in
--   a <a>return</a> monad for later use. it is like binding a value to a
--   monad-level identifier.
bind :: (Monad m, Functor m) => m a -> m (m a)

-- | Load from a static value.
load :: (TRealm r, Typeable c) => Named (StaticValue r c) -> B (Value r c)

-- | Store to a static value.
store :: (TRealm r, Typeable c) => Named (StaticValue r c) -> Builder v g a (Value r c) -> Builder v g a ()

-- | Reduce over a <a>TArray</a> <a>Value</a> using the specified reduction
--   <a>Operator</a> to make a <a>TScalar</a> <a>Value</a>
reduce :: Typeable c => Operator -> Builder v g a (Value TArray c) -> Builder v g a (Value TScalar c)

-- | Broadcast a <a>TScalar</a> <a>Value</a> to make it a <a>TArray</a>
--   <a>Value</a>
broadcast :: Typeable c => Builder v g a (Value TScalar c) -> Builder v g a (Value TArray c)

-- | Load the <a>Axis</a> component of the mesh address, to a <a>TArray</a>
--   <a>Value</a>.
loadIndex :: Typeable g => Axis v -> Builder v g a (Value TArray g)

-- | Load the <a>Axis</a> component of the mesh size, to either a
--   <a>TScalar</a> <a>Value</a> or <a>TArray</a> <a>Value</a>..
loadSize :: Typeable g => Axis v -> Builder v g a (Value TScalar g)

-- | Shift a <a>TArray</a> <a>Value</a> with a constant vector.
shift :: Typeable c => v g -> Builder v g a (Value TArray c) -> Builder v g a (Value TArray c)

-- | Create an immediate <a>Value</a> from a Haskell concrete value.
--   <a>TRealm</a> is type-inferred.
imm :: (TRealm r, Typeable c) => c -> B (Value r c)

-- | Make a unary operator
mkOp1 :: (TRealm r, Typeable c) => Operator -> (Builder v g a (Value r c)) -> (Builder v g a (Value r c))

-- | Make a binary operator
mkOp2 :: (TRealm r, Typeable c) => Operator -> (Builder v g a (Value r c)) -> (Builder v g a (Value r c)) -> (Builder v g a (Value r c))

-- | Perform the cast that keeps the realm while change the content type
--   from <tt>c1</tt> to <tt>c2</tt>.
cast :: (TRealm r, Typeable c1, Typeable c2) => (Builder v g a (Value r c1)) -> (Builder v g a (Value r c2))

-- | take a phantom object <tt>c2</tt>, and perform the cast that keeps the
--   realm while change the content type from <tt>c1</tt> to <tt>c2</tt>.
castTo :: (TRealm r, Typeable c1, Typeable c2) => c2 -> (Builder v g a (Value r c1)) -> (Builder v g a (Value r c2))

-- | Execute the builder, and annotate the very result with the givin
--   function.
annotate :: (TRealm r, Typeable c) => (a -> a) -> Builder v g a (Value r c) -> Builder v g a (Value r c)

-- | (<a>?</a>) = annotate
(<?>) :: (TRealm r, Typeable c) => (a -> a) -> Builder v g a (Value r c) -> Builder v g a (Value r c)

-- | Execute the builder under modifed annotation.
withAnnotation :: (a -> a) -> Builder v g a ret -> Builder v g a ret
instance Show anot => Show (BuilderContext anot)
instance (Show anot, Show (vector gauge)) => Show (BuilderState vector gauge anot)
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance TRealm r => Boolean (Builder v g a (Value r Bool))
instance (TRealm r, Typeable c, C c, Fractional c) => Fractional (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => Num (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance (TRealm r, Typeable c, C c) => C (Builder v g a (Value r c))
instance Show (Builder v g a ret)
instance Eq (Builder v g a ret)


-- | A monadic library to build dataflow graphs for OM. This module just
--   exports a set of chosen symbols from <a>Internal</a>.
module Language.Paraiso.OM.Builder

-- | The <a>Builder</a> monad is used to build <a>Kernel</a>s.
type Builder (vector :: * -> *) (gauge :: *) (anot :: *) (val :: *) = State (BuilderState vector gauge anot) val
data BuilderState vector gauge anot
BuilderState :: Setup vector gauge anot -> BuilderContext anot -> Graph vector gauge anot -> BuilderState vector gauge anot
setup :: BuilderState vector gauge anot -> Setup vector gauge anot
context :: BuilderState vector gauge anot -> BuilderContext anot
target :: BuilderState vector gauge anot -> Graph vector gauge anot
type BuilderOf r c = forall (v :: * -> *) (g :: *) (a :: *). Builder v g a (Value r c)

-- | Create a <a>Kernel</a> from a <a>Builder</a> monad.
buildKernel :: Setup v g a -> Name -> Builder v g a () -> Kernel v g a

-- | run the given builder monad, get the result graph node, and wrap it in
--   a <a>return</a> monad for later use. it is like binding a value to a
--   monad-level identifier.
bind :: (Monad m, Functor m) => m a -> m (m a)

-- | Load from a static value.
load :: (TRealm r, Typeable c) => Named (StaticValue r c) -> B (Value r c)

-- | Store to a static value.
store :: (TRealm r, Typeable c) => Named (StaticValue r c) -> Builder v g a (Value r c) -> Builder v g a ()

-- | Reduce over a <a>TArray</a> <a>Value</a> using the specified reduction
--   <a>Operator</a> to make a <a>TScalar</a> <a>Value</a>
reduce :: Typeable c => Operator -> Builder v g a (Value TArray c) -> Builder v g a (Value TScalar c)

-- | Broadcast a <a>TScalar</a> <a>Value</a> to make it a <a>TArray</a>
--   <a>Value</a>
broadcast :: Typeable c => Builder v g a (Value TScalar c) -> Builder v g a (Value TArray c)

-- | Load the <a>Axis</a> component of the mesh address, to a <a>TArray</a>
--   <a>Value</a>.
loadIndex :: Typeable g => Axis v -> Builder v g a (Value TArray g)

-- | Load the <a>Axis</a> component of the mesh size, to either a
--   <a>TScalar</a> <a>Value</a> or <a>TArray</a> <a>Value</a>..
loadSize :: Typeable g => Axis v -> Builder v g a (Value TScalar g)

-- | Shift a <a>TArray</a> <a>Value</a> with a constant vector.
shift :: Typeable c => v g -> Builder v g a (Value TArray c) -> Builder v g a (Value TArray c)

-- | Create an immediate <a>Value</a> from a Haskell concrete value.
--   <a>TRealm</a> is type-inferred.
imm :: (TRealm r, Typeable c) => c -> B (Value r c)

-- | Perform the cast that keeps the realm while change the content type
--   from <tt>c1</tt> to <tt>c2</tt>.
cast :: (TRealm r, Typeable c1, Typeable c2) => (Builder v g a (Value r c1)) -> (Builder v g a (Value r c2))

-- | take a phantom object <tt>c2</tt>, and perform the cast that keeps the
--   realm while change the content type from <tt>c1</tt> to <tt>c2</tt>.
castTo :: (TRealm r, Typeable c1, Typeable c2) => c2 -> (Builder v g a (Value r c1)) -> (Builder v g a (Value r c2))

-- | Execute the builder, and annotate the very result with the givin
--   function.
annotate :: (TRealm r, Typeable c) => (a -> a) -> Builder v g a (Value r c) -> Builder v g a (Value r c)

-- | (<a>?</a>) = annotate
(<?>) :: (TRealm r, Typeable c) => (a -> a) -> Builder v g a (Value r c) -> Builder v g a (Value r c)

-- | Execute the builder under modifed annotation.
withAnnotation :: (a -> a) -> Builder v g a ret -> Builder v g a ret

module Language.Paraiso.OM

-- | POM is Primordial Orthotope Machine.
data OM vector gauge anot
OM :: Name -> Setup vector gauge anot -> Vector (Kernel vector gauge anot) -> OM vector gauge anot
omName :: OM vector gauge anot -> Name
setup :: OM vector gauge anot -> Setup vector gauge anot
kernels :: OM vector gauge anot -> Vector (Kernel vector gauge anot)

-- | create a POM easily and consistently.
makeOM :: Name -> a -> [Named DynValue] -> [Named (Builder v g a ())] -> OM v g a
instance (Show anot, Show (vector gauge)) => Show (OM vector gauge anot)
instance Nameable (OM v g a)


-- | An extension module of building blocks. Contains booleans, comparison
--   operations, branchings.
module Language.Paraiso.OM.Builder.Boolean

-- | Equal
eq :: CompareOp

-- | Not equal
ne :: CompareOp

-- | Less than
lt :: CompareOp

-- | Less than or equal to
le :: CompareOp

-- | Greater than
gt :: CompareOp

-- | Greater than or equal to
ge :: CompareOp

-- | selects either the second or the third argument based
select :: (TRealm r, Typeable c) => (Builder v g a (Value r Bool)) -> (Builder v g a (Value r c)) -> (Builder v g a (Value r c)) -> (Builder v g a (Value r c))


-- | An <tt>Annotation</tt> that selects whether the data should be stored
--   globally on memory or to be calculated.
module Language.Paraiso.Annotation.Allocation
data Allocation

-- | This entity is already allocated as a static variable.
Existing :: Allocation

-- | Allocate additional memory for this entity.
Manifest :: Allocation

-- | Do not allocate, re-compute it whenever if needed.
Delayed :: Allocation
data AllocationChoice
AllocationChoice :: [Allocation] -> AllocationChoice
instance Typeable Allocation
instance Typeable AllocationChoice
instance Eq Allocation
instance Show Allocation
instance Eq AllocationChoice
instance Show AllocationChoice


-- | <a>Annotation</a> is a collection of <a>Typeable</a>s with which you
--   can annotate each OM node.
module Language.Paraiso.Annotation
type Annotation = [Dynamic]

-- | Add an annotation to a collection.
add :: Typeable a => a -> Annotation -> Annotation

-- | An empty collection.
empty :: Annotation

-- | Map all annotations of type <tt>a</tt> to type <tt>b</tt>, while
--   leaving the others untouched.
map :: (Typeable a, Typeable b) => (a -> b) -> Annotation -> Annotation

-- | Remove all elements of type <tt>a</tt> from the collection, and set
--   <tt>x</tt> as the only member of the type in the collection.
set :: Typeable a => a -> Annotation -> Annotation

-- | set <tt>x</tt> as the only member of the type in the collection, only
--   if no annotation of the same type pre-exists.
weakSet :: Typeable a => a -> Annotation -> Annotation

-- | Extract all annotations of type <tt>a</tt> from the collection.
toList :: Typeable a => Annotation -> [a]

-- | Extract the first annotation of the given type, if it exists.
toMaybe :: Typeable a => Annotation -> Maybe a


-- | Basic definitions for optimization
module Language.Paraiso.Optimization.Graph

-- | the most frequent type of optimization is which
type Optimization = forall (v :: * -> *) (g :: *). Graph v g Annotation -> Graph v g Annotation
type OptimizationEx = forall (v :: * -> *) (g :: *) (a :: *). OM v g a -> OM v g a
type OptimizationOf (v :: * -> *) (g :: *) = Graph v g Annotation -> Graph v g Annotation

-- | (Ready v g) indicates that the pair (v, g) has all the instances for
--   the full optimizations to be serviced.
class (Vector v, Num g, Ord g, C g, Show g, Typeable g, C (v g), Ord (v g), Show (v g)) => Ready (v :: * -> *) (g :: *)

-- | map the graph optimization to each dataflow graph of the kernel
gmap :: (Graph v g a -> Graph v g a) -> OM v g a -> OM v g a
instance (Vector v, Num g, Ord g, C g, Show g, Typeable g, C (v g), Ord (v g), Show (v g)) => Ready v g

module Language.Paraiso.OM.PrettyPrint

-- | pretty print the OM, neglecting any annotations.
prettyPrint :: Ready v g => OM v g a -> Text

-- | pretty print the OM with your choice of prettyprinter for annotation.
prettyPrintA :: Ready v g => (a -> [Text]) -> OM v g a -> Text

-- | pretty print the OM, using a default printing for annotation.
prettyPrintA1 :: Ready v g => OM v g Annotation -> Text


-- | The volume of mesh that contains the correct results shrinks as the
--   stencil calculation proceeds. This is because in stencil calculation
--   each mesh access to its neighbour meshes and for boundary meshes it
--   cannot be obtained.
--   
--   boundaryAnalysis marks each node of the Orthotope Machine with the
--   region for which the computation result is Valid.
module Language.Paraiso.Optimization.BoundaryAnalysis
boundaryAnalysis :: (Vector v, C g, Ord g, Typeable g) => Graph v g Annotation -> Graph v g Annotation

module Language.Paraiso.Optimization.DeadCodeElimination

-- | an optimization that changes nothing.
deadCodeElimination :: Optimization


-- | The choice of making each Orthotope Machine node Manifest or not
--   largely depends on the user or the automated tuning. However, code
--   generators requires that nodes are Manifest at certain contexts.
--   
--   decideAllocation makes sure that such nodes are marked as Manifest,
--   and also makes sure that every node is marked with at least some
--   Allocation.
module Language.Paraiso.Optimization.DecideAllocation
decideAllocation :: Optimization


-- | This module performs dependency analysis for generating subroutines.
--   
--   <ol>
--   <li>Direct dependency between Manifest/Existing nodes X and Y: the
--   subroutine that outputs Y needs to read X as input</li>
--   <li>Indirect dependency between Manifest nodes X and Y: the
--   computation of Y requires that the computation of X is finished, and
--   therefore X and Y cannot be output by the same subroutine</li>
--   <li>Calculation dependency between any node X and Manifest node Y: in
--   the subroutine you output Y you need to calculate X.</li>
--   </ol>
--   
--   c.f. <a>Dependency</a>
module Language.Paraiso.Optimization.DependencyAnalysis

-- | Give unique numbering to each groups in the entire OM in preparation
--   for code generation
writeGrouping :: Ready v g => OM v g Annotation -> OM v g Annotation

module Language.Paraiso.Optimization.Identity

-- | an optimization that changes nothing.
identity :: Optimization


-- | tipycal optimization menu
module Language.Paraiso.Optimization
optimize :: Ready v g => Level -> OM v g Annotation -> OM v g Annotation
data Level
Unoptimized :: Level
O0 :: Level
O1 :: Level
O2 :: Level
O3 :: Level

-- | (Ready v g) indicates that the pair (v, g) has all the instances for
--   the full optimizations to be serviced.
class (Vector v, Num g, Ord g, C g, Show g, Typeable g, C (v g), Ord (v g), Show (v g)) => Ready (v :: * -> *) (g :: *)
instance Typeable Level
instance Eq Level
instance Ord Level
instance Show Level


-- | informations for generating native codes.
module Language.Paraiso.Generator.Native

-- | the setups that needed to generate the native codes.
data Setup (vector :: * -> *) (gauge :: *)
Setup :: Language -> FilePath -> Level -> vector gauge -> vector Condition -> (Int, Int) -> Setup

-- | the preferred native language
language :: Setup -> Language

-- | the directory on which programs are to be generated
directory :: Setup -> FilePath

-- | the intensity of optimization
optLevel :: Setup -> Level

-- | the dimension of the physically meaningful region
localSize :: Setup -> vector gauge

-- | the boundary condition imposed
boundary :: Setup -> vector Condition

-- | CUDA grid x block size (will be variable of subkernel in the future)
cudaGridSize :: Setup -> (Int, Int)
defaultSetup :: Ready v g => v g -> Setup v g
data Language
CPlusPlus :: Language
CUDA :: Language
instance (Show (v Condition), Show (v g)) => Show (Setup v g)
instance Eq Language
instance Show Language

module Language.Paraiso.Generator.PlanTrans
translate :: Ready v g => Setup v g -> Plan v g AnAn -> Program
commonLibraries :: [(FilePath, Text)]

module Language.Paraiso.Generator.OMTrans
translate :: Ready v g => Setup v g -> OM v g Annotation -> Plan v g Annotation
instance Show (v g) => Show (Triplet v g)


-- | a general code generator definition.
module Language.Paraiso.Generator

-- | Generate the (filename, content) list from a code generation setup and
--   a orthotope machine definition.
generate :: Ready v g => Setup v g -> OM v g Annotation -> [(FilePath, Text)]

-- | Perform the code generation and returns the list of written filepaths
--   and their contents, for your interest.
generateIO :: Ready v g => Setup v g -> OM v g Annotation -> IO [(FilePath, Text)]

module Language.Paraiso.Tuning.Genetic
data Genome
data Species v g
Species :: Setup v g -> OM v g Annotation -> Species v g
setup :: Species v g -> Setup v g
machine :: Species v g -> OM v g Annotation
makeSpecies :: Setup v g -> OM v g Annotation -> Species v g
readGenome :: Species v g -> Genome
overwriteGenome :: Ready v g => Genome -> Species v g -> Species v g
mutate :: Genome -> IO Genome
cross :: Genome -> Genome -> IO Genome
triangulate :: Genome -> Genome -> Genome -> IO Genome
generateIO :: Ready v g => Species v g -> IO [(FilePath, Text)]
instance (Show (Setup v g), Show (OM v g Annotation)) => Show (Species v g)
instance Eq Genome
instance Monad Get
instance Monad Put
instance Read Genome
instance Show Genome


-- | Paraiso main module. This module will export a starter-kit modules and
--   functions in the future, but is useless right now. The building-blocks
--   of Paraiso programs are in the module <a>Builder</a>.
--   
--   A series of intoduction is being written in Japanese
--   <a>http://d.hatena.ne.jp/nushio/searchdiary?word=*%5BICFDP%5D</a> and
--   English <a>http://nushisblogger.blogspot.jp/search/label/ICFDP</a>.
--   
--   Also refer to the wiki <a>http://www.paraiso-lang.org/wiki/</a> and
--   the paper <a>http://arxiv.org/abs/1204.4779</a> for more detail.
module Language.Paraiso

-- | Generate Wonderful Program
run :: () -> String
