-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A silly container
--   
@package meep
@version 0.1.2.0


-- | A <tt>Map</tt>-like structure that contains up to one key-value pair
--   
--   A <a>Meep</a> is strict in the key.
--   
--   <tt>Meep k a</tt> is isomorphic to <tt>Maybe (k, a)</tt> with
--   <a>maybeing</a> witnessing the isomorphism
module Data.Meep

-- | A Meep from key <tt>k</tt> to value <tt>a</tt>
data Meep k a

-- | <i>O(1)</i>. An empty <a>Meep</a>
empty :: Meep k a

-- | <i>O(1)</i>. A <a>Meep</a> with a single key-value pair
singleton :: k -> a -> Meep k a

-- | <i>O(1)</i>. The size of the <a>Meep</a>
--   
--   <pre>
--   &gt;&gt;&gt; size empty
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (singleton 4 "foo")
--   1
--   </pre>
size :: Num b => Meep k a -> b

-- | <i>O(1)</i>. The emptiness check for the <a>Meep</a>
--   
--   <pre>
--   &gt;&gt;&gt; null empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (singleton 4 "foo")
--   False
--   </pre>
null :: Meep k a -> Bool

-- | <i>O(1)</i>. Build the <a>Meep</a>
--   
--   <pre>
--   fromMaybe ≡ view (from maybeing)
--   </pre>
fromMaybe :: Maybe (k, a) -> Meep k a

-- | <i>O(1)</i>. Destroy the <a>Meep</a>
--   
--   <pre>
--   toMaybe ≡ view maybeing
--   </pre>
toMaybe :: Meep k a -> Maybe (k, a)

-- | <i>O(1)</i>. A witness to
--   
--   <pre>
--   <a>Meep</a> k v ≅ <a>Maybe</a> (k, v)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton 4 "foo" ^. maybeing
--   Just (4,"foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^. from maybeing
--   fromMaybe Nothing
--   </pre>
maybeing :: Iso (Meep k v) (Meep k' v') (Maybe (k, v)) (Maybe (k', v'))

-- | <i>O(1)</i>. Intersection of two <a>Meep</a>s
--   
--   <pre>
--   intersection ≡ <a>intersectionWith</a> <a>const</a>
--   </pre>
intersection :: Eq k => Meep k a -> Meep k b -> Meep k a

-- | <i>O(1)</i>. Intersection of two <a>Meep</a>s with a combining
--   function
--   
--   <pre>
--   &gt;&gt;&gt; intersectionWith (+) (Meep "hello" 4) (Meep "hello" 7)
--   fromMaybe (Just ("hello",11))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intersectionWith (+) (Meep "hello" 4) (Meep "bye" 7)
--   fromMaybe Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intersectionWith (+) Empty (Meep "hello" 7)
--   fromMaybe Nothing
--   </pre>
--   
--   <pre>
--   intersectionWith f ≡ intersectionWithKey (const f)
--   </pre>
intersectionWith :: Eq k => (a -> b -> c) -> Meep k a -> Meep k b -> Meep k c

-- | <i>O(1)</i>. Intersection of two <a>Meep</a>s with a combining
--   function
intersectionWithKey :: Eq k => (k -> a -> b -> c) -> Meep k a -> Meep k b -> Meep k c

-- | <i>O(1)</i>. Return all keys from the <a>Meep</a>
--   
--   <pre>
--   &gt;&gt;&gt; keys (singleton 4 "foo")
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; keys empty
--   Nothing
--   </pre>
keys :: Meep k a -> Maybe k

-- | <i>O(1)</i>. Return all values from the <a>Meep</a>
--   
--   <pre>
--   &gt;&gt;&gt; elems (singleton 4 "foo")
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elems empty
--   Nothing
--   </pre>
elems :: Meep k a -> Maybe a
instance Typeable Meep
instance (Eq k, Eq a) => Eq (Meep k a)
instance (Ord k, Ord a) => Ord (Meep k a)
instance Functor (Meep k)
instance Foldable (Meep k)
instance Traversable (Meep k)
instance (Data k, Data a) => Data (Meep k a)
instance Generic (Meep k a)
instance Datatype D1Meep
instance Constructor C1_0Meep
instance Constructor C1_1Meep
instance AsEmpty (Meep k a)
instance TraversableWithIndex k (Meep k)
instance FoldableWithIndex k (Meep k)
instance FunctorWithIndex k (Meep k)
instance Eq k => At (Meep k a)
instance Eq k => Ixed (Meep k a)
instance Bitraversable Meep
instance Bifoldable Meep
instance Biapply Meep
instance Bifunctor Meep
instance Eq k => Apply (Meep k)
instance (Eq k, Semigroup a) => Semigroup (Meep k a)
instance (Show k, Show a) => Show (Meep k a)
