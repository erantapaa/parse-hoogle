-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a haskell implementation of Game 2048
--   
@package h2048
@version 0.2.0.1


-- | helper functions used when implementing game logic
module Game.H2048.Utils

-- | modify a specified element in a list, this is a simple semantic editor
--   combinator
inPos :: Int -> (a -> a) -> [a] -> [a]

-- | all possible values for a Bounded Enum
universe :: (Bounded e, Enum e) => [e]


-- | The core game logic implementation for Game 2048.
--   
--   The routine for using this library would be:
--   
--   <ol>
--   <li>use <a>initGameBoard</a> to get a valid board to begin with. (two
--   new cells are inserted for you, if you want to use an empty board,
--   <a>initBoard</a> is a shorthand)</li>
--   <li>interact with user <i> algorithm </i> etc., use <a>updateBoard</a>
--   to update a board.</li>
--   <li>use <a>insertNewCell</a> to insert a new cell randomly</li>
--   <li>examine if the player wins <i> loses </i> is still alive using
--   <a>gameState</a>.</li>
--   </ol>
module Game.H2048.Core

-- | represent a 4x4 board for Game 2048 each element should be either zero
--   or 2^i where i &gt;= 1.
type Board = [[Int]]

-- | a list of 4 elements, stands for one column / row in the board
type Line = [Int]

-- | move direction
data Dir
DUp :: Dir
DDown :: Dir
DLeft :: Dir
DRight :: Dir

-- | result after a successful <a>updateBoard</a>
data BoardUpdated
BoardUpdated :: Board -> Int -> BoardUpdated

-- | new board
brBoard :: BoardUpdated -> Board

-- | score collected in this update
brScore :: BoardUpdated -> Int

-- | current game state, see also <a>gameState</a>
data GameState

-- | win, can make no step further
Win :: GameState

-- | win, and still alive
WinAlive :: GameState

-- | can make no step further, no cell reaches 2048
Lose :: GameState

-- | playing
Alive :: GameState

-- | return current game state. <a>Win</a> if any cell is equal to or
--   greater than 2048 or <a>Lose</a> if we can move no further otherwise,
--   <a>Alive</a>.
gameState :: Board -> GameState

-- | move each non-zero element to their leftmost possible position while
--   preserving the order
compactLine :: Line -> Writer (Sum Int) Line

-- | the initial board before a game started
initBoard :: Board

-- | initialize the board by puting two cells randomly into the board. See
--   <a>generateNewCell</a> for the cell generating rule.
initGameBoard :: MonadRandom r => r (Board, Int)

-- | update the board taking a direction, a <a>BoardUpdated</a> is returned
--   on success, if this update does nothing, that means a failure
--   (Nothing)
updateBoard :: Dir -> Board -> Maybe BoardUpdated

-- | try to insert a new cell randomly
insertNewCell :: MonadRandom r => Board -> r (Maybe Board)

-- | generate a new cell according to the game rule we have 90% probability
--   of getting a cell of value 2, and 10% probability of getting a cell of
--   value 4.
generateNewCell :: MonadRandom r => r Int
instance Eq BoardUpdated
instance Show BoardUpdated
instance Enum GameState
instance Eq GameState
instance Show GameState
instance Enum Dir
instance Bounded Dir
instance Eq Dir
instance Ord Dir
instance Show Dir


-- | A simple CLI implemention of Game 2048
module Game.H2048.UI.Simple

-- | pretty print the board to stdout
drawBoard :: Board -> IO ()

-- | play game on a given board until user quits or game ends
playGame :: RandomGen g => (Board, Int) -> RandT g IO ()

-- | the entry of Simple UI
mainSimple :: IO ()


-- | A CLI version of Game 2048 implemented using vty-ui
module Game.H2048.UI.Vty

-- | indicate the status of a playing session
data PlayState g
PlayState :: Board -> Int -> GameState -> g -> PlayState g

-- | current board
psBoard :: PlayState g -> Board

-- | current collected score
psScore :: PlayState g -> Int

-- | indicate whether the game terminates
psGState :: PlayState g -> GameState

-- | next random generator
psRGen :: PlayState g -> g

-- | the entry for vty-ui CLI implementation
mainVty :: IO ()
