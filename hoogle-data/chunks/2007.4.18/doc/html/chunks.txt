-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple template library with static safety
--   
--   This library supports templates inspired by the Perl HTML::Chunks
--   module, but this Haskell implementation checks at compile time that
--   the templates used exist and are used correctly. The templates are
--   combined within the compiled Haskell, removing the dependency on the
--   external template file.
@package chunks
@version 2007.4.18


-- | Whilst the syntax for modules makes use of HTML-style comments, there
--   is nothing preventing the use of templates for non-HTML purposes.
--   
--   Chunks are delimited by <tt>&lt;!-- BEGIN <i>name</i> --&gt; <i>some
--   text</i> &lt;!-- END --&gt;</tt> where <tt><i>name</i></tt> specifies
--   the name of the chunk, and <tt><i>some text</i></tt> is replaced by
--   whatever you wish to appear within the chunk. Chunks can be nested but
--   this is <i>only</i> for convenience: a nested chunk is <i>never</i>
--   output as part of its parent chunk. The purpose of allowing nesting is
--   so that the template can be constructed so that it itself renders
--   acceptably in a browser.
--   
--   Variables can be specified in the content of the chunk by
--   <tt>##<i>name</i>##</tt> where <tt><i>name</i></tt> is the variable
--   name. In order to prevent the variables from appearing in the template
--   when rendered in a browser, the variable may be set in a comment as
--   long as it's the only thing in the comment, e.g. <tt>&lt;!--
--   ##<i>name</i>## --&gt;</tt>
--   
--   Typical use is to use the splice syntax (ghc needs <tt>-fth</tt> for
--   this) to include the chunk definitions in the currrent module, e.g.
--   
--   <pre>
--   $(chunksFromFile "/path/to/templates/template_01.html")
--   </pre>
--   
--   This causes, <i>at compile time</i>, the template to be parsed and for
--   the chunks to be converted into <tt>data</tt> declarations which are
--   instances of both <a>Show</a> (for debugging purposes) and
--   <a>Chunk</a> (for formatting purposes). The template is thus
--   incorporated directly within the executable eliminating the dependency
--   on the template at runtime. This also means that if you just change
--   the template then you must recompile with <tt>-fforce-recomp</tt>
--   inorder to force the recompilation.
--   
--   The naming convention used converts the names of chunks to
--   <tt>Chunk_<i>name</i></tt> and chunk variables to fields in the data
--   type with names of <tt><i>chunk-name</i>_<i>var-name</i></tt>. The
--   function <a>showChunksData</a> exists to allow you to inspect these.
module Text.HTML.Chunks

-- | Parse the supplied file and generate the Haskell AST representing
--   data-type declarations of the chunks with instances of <a>Chunk</a>
--   incorporating the body of the chunks. Expected use is through splicing
--   (ghc needs <tt>-fth</tt> option for this):
--   
--   <pre>
--   $(chunksFromFile "/path/to/templates/template_01.html")
--   </pre>
chunksFromFile :: FilePath -> Q [Dec]

-- | Parse the supplied file for chunks and return a string representing
--   the code generated for the data-type declarations only of the chunks.
--   This is useful for debugging purposes, particularly from within
--   <tt>ghci</tt>. E.g.
--   
--   <pre>
--   &gt; showChunksData "/path/to/templates/template_01.html" &gt;&gt;= putStrLn
--   </pre>
showChunksData :: FilePath -> IO String

-- | Parse the supplied file for chunks and return a string representing
--   all the code generated for the chunks. This will return both the text
--   of the data-declarations and the instance <a>Chunk</a> declarations.
--   The instance declarations will often be very large as they
--   incorporated the text of the chunk taken from the template.
showChunksAll :: FilePath -> IO String
class Chunk a
format :: Chunk a => a -> String
