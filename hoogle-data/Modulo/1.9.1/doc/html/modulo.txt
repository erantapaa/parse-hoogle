-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Modular C code generator
--   
--   Modulo is a tool that generates modular, standard C interfaces based
--   on a high-level description language. The idea is to specify
--   functionality in the module language and implement it in any language
--   that supports C-style calling conventions. This package include
--   generators for C, Haskell, Common Lisp and NodeJS-style JavaScript.
@package modulo
@version 1.9.1


-- | Renders module descriptions as JavaScript imports, using Node package
--   <tt>ffi</tt>.
--   
--   See <a>https://github.com/rbranson/node-ffi</a>
module Language.Modulo.JavaScript


module Language.Modulo.Util

-- | Synonym for <a>toUpper</a>
toUpperChar :: Char -> Char

-- | Synonym for <a>toLower</a>
toLowerChar :: Char -> Char

-- | Synonym for 'fmap Char.toUpper'
toUpperString :: String -> String

-- | Synonym for 'fmap Char.toLower'
toLowerString :: String -> String

-- | Convert a string to use upper case for the leading letter and lower
--   case for remaining letters.
toCapitalString :: String -> String

-- | Synonym for '(++)'
withPrefix :: [a] -> [a] -> [a]

-- | Synonym for 'flip (++)'
withSuffix :: [a] -> [a] -> [a]

-- | Separate a list by the given element.
--   
--   Equivalent to <a>intersperse</a>
sep :: a -> [a] -> [a]

-- | Initiate and separate a list by the given element.
pre :: a -> [a] -> [a]

-- | Separate and terminate a list by the given element.
post :: a -> [a] -> [a]

-- | Separate and terminate a list by the given element.
wrap :: a -> a -> [a] -> [a]

-- | Combination of <a>concat</a> and <a>sep</a>.
concatSep :: [a] -> [[a]] -> [a]

-- | Combination of <a>concat</a> and <a>pre</a>.
concatPre :: [a] -> [[a]] -> [a]

-- | Combination of <a>concat</a> and <a>post</a>.
concatPost :: [a] -> [[a]] -> [a]

-- | Combination of <a>concat</a> and <a>wrap</a>.
concatWrap :: [a] -> [a] -> [[a]] -> [a]

-- | Divide a list into parts of maximum length n.
divideList :: Int -> [a] -> [[a]]

-- | Break up a list into parts of maximum length n, inserting the given
--   list as separator. Useful for breaking up strings, as in <tt>breakList
--   80 <a>n</a> str</tt>.
breakList :: Int -> [a] -> [a] -> [a]

-- | Break up a list into parts of maximum length n, inserting the given
--   list as separator. Useful for breaking up strings, as in <tt>breakList
--   80 <a>n</a> str</tt>.
concatMapM :: (Monad f, Functor f) => (a -> f [b]) -> [a] -> f [b]


-- | Manglers for various kinds of identifiers.
module Language.Modulo.Util.Mangle

-- | Mangle an indentifier in mixed case, i.e. <tt>[foo, bar]</tt> becomes
--   <tt>fooBar</tt>.
mixedCase :: [String] -> String

-- | Mangle an indentifier in capital case, i.e. <tt>[foo, bar]</tt>
--   becomes <tt>FooBar</tt>.
capitalCase :: [String] -> String

-- | Mangle an indentifier using the underscore as separator, i.e.
--   <tt>[foo, bar]</tt> becomes <tt>foo_bar</tt>.
sepCase :: [String] -> String


-- | Unmanglers for various kinds of identifiers.
module Language.Modulo.Util.Unmangle

-- | Unmangle an indentifier in mixed or separarated case.
unmangle :: String -> [String]

-- | Unmangle an indentifier in mixed case, i.e. <tt>fooBar</tt> becomes
--   <tt>[foo, bar]</tt>.
uncase :: String -> [String]

-- | Unmangle an indentifier using the underscore as separator, i.e.
--   <tt>foo_bar</tt> becomes <tt>[foo, bar]</tt>.
--   
--   <pre>
--   unsep (sep a) = a, iff a /= []
--   </pre>
unsep :: String -> [String]


-- | This Haskell module defines the Modulo description language.
--   Typically, modules are created by writing <tt>.module</tt> files and
--   using the parser defined in <a>Language.Modulo.Parser</a>, or the
--   <tt>modulo</tt> command-line tool. The abstract syntax tree is given
--   below.
--   
--   The module language is very simple. Each module consists of a name
--   followed by eventual import declarations, followed by all other
--   declarations. Here is an example module:
--   
--   <pre>
--   module Scl.List
--   {
--     opaque Elem;
--     opaque List;
--   
--     nil     : () -&gt; List;
--     cons    : (Elem, List) -&gt; List;
--     head    : (List) -&gt; Elem;
--     tail    : (List) -&gt; List;
--   
--     empty   : (List) -&gt; Bool;
--     lenght  : (List) -&gt; Int;
--   
--     reverse : (List) -&gt; List;
--     sort    : (List) -&gt; List;
--   }
--   </pre>
--   
--   Like C, the module language uses structural typing for pointers and
--   functions, but nominal typing for structures and unions. Thus in the
--   following example values of type <tt>A</tt> and <tt>B</tt> are
--   interchangeable, but values of type <tt>C</tt> and <tt>D</tt> are not.
--   
--   <pre>
--   type A = Ptr Int
--   type B = Ptr Int
--   type C = struct { x : Int, y : Int }
--   type D = struct { x : Int, y : Int }
--   </pre>
--   
--   The pointer type constructor can be used with any type:
--   
--   <pre>
--   type IntPtr = Int*
--   type FloatPtr = Float*
--   </pre>
--   
--   The array type constructor need an explicit length:
--   
--   <pre>
--   type IntVec = [Int x 10]
--   </pre>
--   
--   Functions are written as in Haskell, except for the parentheses
--   enclosing the arguments. Thus, higher-arity functions are easily
--   distinguished.
--   
--   <pre>
--   type NoCurry = (A, B) -&gt; C
--   type Curry   = (A) -&gt; (B) -&gt; C
--   </pre>
--   
--   Compound types are written in a uniform manner:
--   
--   <pre>
--   type IntCounter = struct { a : Int, b : Int -&gt; Int }
--   type NumValue   = union { left : Int, right : Float }
--   type Color      = enum { Red, Green, Blue }
--   </pre>
--   
--   The following primitive types are provided:
--   
--   <pre>
--   Void Size Ptrdiff Intptr UIntptr 
--   Char Short Int Long LongLong
--   UChar UShort UInt ULong ULongLong
--   Float Double LongDouble
--   Int8 Int16 Int32 Int64 UInt8 UInt16 UInt32 UInt64
--   </pre>
module Language.Modulo

-- | A module is a named container of imports and declarations.
--   
--   Each module can depend on a set of other modules (translated as
--   include directives). Recursive dependencies are not allowed for now.
data Module
Module :: ModuleName -> ModuleOptions -> Doc -> [(ModuleName, Maybe String)] -> [(Doc, Decl)] -> Module

-- | Name of module
modName :: Module -> ModuleName

-- | Module options.
modOptions :: Module -> ModuleOptions

-- | Module documentation.
modDoc :: Module -> Doc

-- | Imports with optional import conventions
modImports :: Module -> [(ModuleName, Maybe String)]

-- | List of declarations
modDecls :: Module -> [(Doc, Decl)]
data ModuleOptions
ModuleOptions :: Bool -> ModuleOptions

-- | If true, this module does not incur any C prefix.
optTransient :: ModuleOptions -> Bool

-- | A module name is a non-empty list of strings.
newtype ModuleName
ModuleName :: (NonEmpty String) -> ModuleName
getModuleName :: ModuleName -> (NonEmpty String)
toModuleName :: [String] -> ModuleName
getModuleNameList :: ModuleName -> [String]
newtype Doc
Doc :: String -> Doc
getDoc :: Doc -> String

-- | Name of a type, function or constant value.
--   
--   Note that any Unicode string may be used as a name.
data Name
Name :: String -> Name
QName :: ModuleName -> String -> Name
getName :: Name -> String

-- | An declaration maps a name to type and optionally a value.
data Decl

-- | Declares a type or opaque.
TypeDecl :: Name -> (Maybe Type) -> Decl

-- | Declares a function.
FunctionDecl :: Name -> FunType -> Decl

-- | Declares a struct or enum tag.
TagDecl :: Type -> Decl

-- | Declares a constant value.
ConstDecl :: Name -> (Maybe Value) -> Type -> Decl

-- | Declares a global variable.
GlobalDecl :: Name -> (Maybe Value) -> Type -> Decl
getDeclName :: Decl -> Maybe Name

-- | A value is anything that can be declared as a C constant.
data Value
CInt :: Integer -> Value
CFloat :: Double -> Value
CStr :: String -> Value
CWStr :: String -> Value
CInitList :: [Value] -> Value

-- | A type is either an alias, a primitive or a compound type.
data Type

-- | An alias, introduced by a former type declaration.
AliasType :: Name -> Type
PrimType :: PrimType -> Type
RefType :: RefType -> Type
FunType :: FunType -> Type
CompType :: CompType -> Type

-- | A primitive type.
data PrimType
Void :: PrimType
Size :: PrimType
Ptrdiff :: PrimType
Intptr :: PrimType
UIntptr :: PrimType
Char :: PrimType
Short :: PrimType
Int :: PrimType
Long :: PrimType
LongLong :: PrimType
SChar :: PrimType
Bool :: PrimType
UChar :: PrimType
UShort :: PrimType
UInt :: PrimType
ULong :: PrimType
ULongLong :: PrimType
Float :: PrimType
Double :: PrimType
LongDouble :: PrimType
Int8 :: PrimType
Int16 :: PrimType
Int32 :: PrimType
Int64 :: PrimType
UInt8 :: PrimType
UInt16 :: PrimType
UInt32 :: PrimType
UInt64 :: PrimType
data RefType

-- | The C pointer type <tt>t*</tt>.
Pointer :: Type -> RefType

-- | The C array type <tt>t[n]</tt>.
Array :: Type -> Natural -> RefType

-- | A function type.
data FunType

-- | The C function type <tt>Tn(T1, ... Tn-1)</tt>.
Function :: [(Maybe Name, Type)] -> Type -> FunType
data CompType

-- | A C enum type.
Enum :: (NonEmpty Name) -> CompType

-- | A C struct type.
Struct :: (NonEmpty (Name, Type)) -> CompType

-- | A C union type.
Union :: (NonEmpty (Name, Type)) -> CompType

-- | A C bitfield type.
BitField :: (NonEmpty (Name, Type, Natural)) -> CompType
instance Eq Doc
instance Ord Doc
instance Show Doc
instance IsString Doc
instance Eq ModuleOptions
instance Ord ModuleOptions
instance Show ModuleOptions
instance Eq ModuleName
instance Ord ModuleName
instance Eq Name
instance Ord Name
instance Eq Value
instance Show Value
instance Eq PrimType
instance Show PrimType
instance Eq CompType
instance Show CompType
instance Eq Type
instance Show Type
instance Eq FunType
instance Show FunType
instance Eq RefType
instance Show RefType
instance Eq Decl
instance Show Decl
instance Eq Module
instance Show Module
instance Show Name
instance Show ModuleName
instance Ord Module
instance Default ModuleOptions


-- | Renders module descriptions as C header files.
module Language.Modulo.C
data GuardStyle

-- | Write pragma guards
Pragma :: GuardStyle

-- | Write conditional guards
Ifndef :: GuardStyle
data ImportStyle

-- | Import external modules using system paths
SystemPath :: ImportStyle

-- | Import external modules using local paths
LocalPath :: ImportStyle
data CStyle
CStyle :: GuardStyle -> ImportStyle -> String -> ([String] -> String) -> ([String] -> String -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> ([String] -> String) -> Maybe (String, String) -> CStyle

-- | How to write guards
guardStyle :: CStyle -> GuardStyle

-- | How to write import declarations
includeStyle :: CStyle -> ImportStyle

-- | Import directive, usually <tt>include</tt>.
includeDirective :: CStyle -> String

-- | Mangler for names of header guards
guardMangler :: CStyle -> [String] -> String

-- | Inner header mangler (receives module name, documentation)
innerHeader :: CStyle -> [String] -> String -> String

-- | Inner footer mangler (receives module name)
innerFooter :: CStyle -> [String] -> String

-- | Prefix for types
typePrefixMangler :: CStyle -> [String] -> String

-- | Prefix for values
valuePrefixMangler :: CStyle -> [String] -> String

-- | Mangler for implementation struct names
typeMangler :: CStyle -> [String] -> String

-- | Mangler for struct fields
structFieldMangler :: CStyle -> [String] -> String

-- | Mangler for union fields
unionFieldMangler :: CStyle -> [String] -> String

-- | Mangler for enum fields
enumFieldMangler :: CStyle -> [String] -> String

-- | Mangler for constant values
constMangler :: CStyle -> [String] -> String

-- | Mangler for global variables
globalMangler :: CStyle -> [String] -> String

-- | Mangler for global functions
funcMangler :: CStyle -> [String] -> String
funcAttr :: CStyle -> Maybe (String, String)

-- | Style used in the C standard library.
--   
--   <ul>
--   <li>Types: <tt> foo_bar_type_t </tt></li>
--   <li>Functions: <tt> foo_bar_func </tt></li>
--   <li>Constants: <tt> FOO_BAR_VAL </tt></li>
--   <li>Fields: <tt> foo_bar </tt></li>
--   </ul>
stdStyle :: CStyle

-- | Style used in Cairo.
--   
--   <ul>
--   <li>Types: <tt> p_foo_bar_t </tt></li>
--   <li>Opaques: <tt> _p_foo_bar_t </tt></li>
--   <li>Functions: <tt> p_foo_bar </tt></li>
--   <li>Constants: <tt> P_FOO_BAR </tt></li>
--   <li>Fields: <tt> foo_bar </tt></li>
--   </ul>
cairoStyle :: CStyle

-- | Style used in GTK.
--   
--   <ul>
--   <li>Types: <tt> PFooBar </tt></li>
--   <li>Opaques: <tt> _PFooBar </tt></li>
--   <li>Functions: <tt> p_foo_bar </tt></li>
--   <li>Constants: <tt> P_FOO_BAR </tt></li>
--   <li>Fields: <tt> foo_bar </tt></li>
--   </ul>
gtkStyle :: CStyle

-- | Style used in Apple Frameworks.
--   
--   <ul>
--   <li>Types: <tt> PFooBar </tt></li>
--   <li>Opaques: <tt> PFooBarOpaque </tt></li>
--   <li>Functions: <tt> PFooBar </tt></li>
--   <li>Constants: <tt> kPFooBar </tt></li>
--   <li>Fields: <tt> mFooBar </tt></li>
--   </ul>
appleStyle :: CStyle

-- | Style similar to Haskell conventions.
--   
--   <ul>
--   <li>Types: <tt> PFooBar </tt></li>
--   <li>Opaques: <tt> PFooBarOpaque </tt></li>
--   <li>Functions: <tt> pfooBar </tt></li>
--   <li>Constants: <tt> pfooBar </tt></li>
--   <li>Fields: <tt> pfooBar </tt></li>
--   </ul>
haskellStyle :: CStyle
translType :: CStyle -> Name -> Name
translFun :: CStyle -> Name -> Name
translConst :: CStyle -> Name -> Name
translGlobal :: CStyle -> Name -> Name
translStructField :: CStyle -> Name -> Name
translUnionField :: CStyle -> Name -> Name
translEnumField :: CStyle -> Name -> Name

-- | Print a module using the default style.
printModule :: Module -> String

-- | Render a module using the default style.
--   
--   Returns a C header file, represented as a <a>CTranslUnit</a> with
--   enclosing header and footer strings.
renderModule :: Module -> (String, CTranslUnit, String)

-- | Print a module using the specified style.
printModuleStyle :: CStyle -> Module -> String

-- | Render a module using the specified style.
--   
--   Returns a C header file, represented as a <a>CTranslUnit</a> with
--   enclosing header and footer strings.
renderModuleStyle :: CStyle -> Module -> (String, CTranslUnit, String)

-- | Print a module using the default style.
printModuleComm :: Module -> String

-- | Print a module using the specified style.
printModuleStyleComm :: CStyle -> Module -> String
instance Num CInteger
instance Monoid CStyle
instance Semigroup CStyle
instance Default CStyle


-- | Renders module descriptions as Common Lisp (CFFI) declarations.
module Language.Modulo.Lisp
data LispStyle
LispStyle :: CStyle -> String -> ([String] -> [String]) -> Bool -> Maybe PrimType -> LispStyle

-- | For generating foreign declarations
cStyle :: LispStyle -> CStyle

-- | Package in which to generate definitions
package :: LispStyle -> String

-- | A mangler for prefixes.
prefixMangler :: LispStyle -> [String] -> [String]

-- | If true, generate a wrapper class for each opaque type.
safeOpaque :: LispStyle -> Bool

-- | Type of primitive booleans (default Int).
primBoolType :: LispStyle -> Maybe PrimType
stdLispStyle :: LispStyle

-- | Print a module using the default style.
printModuleLisp :: Module -> String

-- | Render a module using the default style.
--   
--   Returns a Lisp file, represented as a sequence of S-expressions.
renderModuleLisp :: Module -> [Lisp]

-- | Print a module using the specified style.
printModuleLispStyle :: LispStyle -> Module -> String

-- | Render a module using the specified style.
--   
--   Returns a Lisp file, represented as a sequence of S-expressions.
renderModuleLispStyle :: LispStyle -> Module -> [Lisp]
convertName :: LispStyle -> Name -> String
convertType :: LispStyle -> Type -> Lisp
instance Monoid Lisp
instance Semigroup Lisp
instance Default Lisp
instance Monoid LispStyle
instance Semigroup LispStyle
instance Default LispStyle


-- | Renders module descriptions as Haskell 2010 foreign declarations.
module Language.Modulo.Haskell
data HaskellStyle
HaskellStyle :: CStyle -> HaskellStyle

-- | For generating foreign declarations
cStyle :: HaskellStyle -> CStyle
stdHaskellStyle :: HaskellStyle

-- | Print a module using the default style.
printModuleHaskell :: Module -> String

-- | Render a module using the default style.
--   
--   Returns a Haskell file, represented as a syntax tree.
renderModuleHaskell :: Module -> HsModule

-- | Print a module using the specified style.
printModuleHaskellStyle :: HaskellStyle -> Module -> String

-- | Render a module using the specified style.
--   
--   Returns a Haskell file, represented as a syntax tree.
renderModuleHaskellStyle :: HaskellStyle -> Module -> HsModule
instance Default SrcLoc
instance IsString Module
instance IsString HsName
instance Monoid HaskellStyle
instance Semigroup HaskellStyle
instance Default HaskellStyle


-- | Parser for the module language, as described in
--   <a>Language.Modulo</a>.
module Language.Modulo.Parse

-- | Parse a module description, returning an error if unsuccessful.
parse :: String -> Either ParseError Module

-- | Parse a qualified name, returning an error if unsuccessful.
parseName :: String -> Either ParseError Name

-- | Parse a primitive type, returning an error if unsuccessful.
parsePrimType :: String -> Either ParseError PrimType

-- | Parse a primitive type, returning an error if unsuccessful.
parsePrimTypeMaybe :: String -> Maybe PrimType

-- | Parse a module description from the given file, or fail if
--   unsuccessful.
--   
--   This unsafe function should not be used in production code.
unsafeParseFile :: FilePath -> IO Module


module Language.Modulo.Load

-- | Path where modules are stored.
type ModulePath = FilePath

-- | Converts a module name to a relative path.
relativePath :: ModuleName -> FilePath

-- | Converts a module name to a list of absolute paths, in order of
--   preference.
absolutePaths :: [ModulePath] -> ModuleName -> [FilePath]

-- | Module paths, in order of preference.
stdModulePaths :: [ModulePath]

-- | Append the standard paths to the given paths.
--   
--   That is, the given paths take precedence over the standards.
withStdModulePaths :: [ModulePath] -> [ModulePath]

-- | Load a module of the given name.
--   
--   Dependencies of the loaded modules are loaded transitively. This
--   function blocks if a recursive dependency is encountered.
loadModule :: [ModulePath] -> ModuleName -> IO [Module]

-- | Load the dependencies of the given module.
--   
--   Dependencies of the loaded modules are loaded transitively. This
--   function blocks if a recursive dependency is encountered.
loadDependencies :: [ModulePath] -> Module -> IO [Module]


module Language.Modulo.Rename

-- | Add default parameter names to functions. (Replaces <a>Nothing</a>
--   with the unqualified type name).
--   
--   Mainly useful for documentation.
addParams :: Module -> Module

-- | Rewrite all unqualified names as qualified names.
--   
--   This function is partial with the following invariants:
--   
--   <ul>
--   <li>Received module has no QName constructors</li>
--   <li>Returned module has no Name constructors</li>
--   </ul>
rename :: [Module] -> Module -> Module
