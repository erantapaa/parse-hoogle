-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A collection of tools for processing PDF files
--   
@package pdf-toolbox-content
@version 0.0.3.3


-- | Content stream operators
module Pdf.Toolbox.Content.Ops

-- | Content stream operators
data Op

-- | Graphics State Operators
Op_q :: Op
Op_Q :: Op
Op_cm :: Op
Op_w :: Op
Op_J :: Op
Op_j :: Op
Op_M :: Op
Op_d :: Op
Op_ri :: Op
Op_i :: Op
Op_gs :: Op

-- | Path Construction Operators
Op_m :: Op
Op_l :: Op
Op_c :: Op
Op_v :: Op
Op_y :: Op
Op_h :: Op
Op_re :: Op

-- | Path Painting Operators
Op_S :: Op
Op_s :: Op
Op_f :: Op
Op_F :: Op
Op_f_star :: Op
Op_B :: Op
Op_B_star :: Op
Op_b :: Op
Op_b_star :: Op
Op_n :: Op

-- | Clipping Path Operators
Op_W :: Op
Op_W_star :: Op

-- | Text Object Operators
Op_BT :: Op
Op_ET :: Op

-- | Text State Operators
Op_Tc :: Op
Op_Tw :: Op
Op_Tz :: Op
Op_TL :: Op
Op_Tf :: Op
Op_Tr :: Op
Op_Ts :: Op

-- | Text Positioning Operators
Op_Td :: Op
Op_TD :: Op
Op_Tm :: Op
Op_T_star :: Op

-- | Text Showing Operators
Op_Tj :: Op
Op_apostrophe :: Op
Op_quote :: Op
Op_TJ :: Op

-- | Type 3 Font Operators
Op_d0 :: Op
Op_d1 :: Op

-- | Color Operators
Op_CS :: Op
Op_cs :: Op
Op_SC :: Op
Op_SCN :: Op
Op_sc :: Op
Op_scn :: Op
Op_G :: Op
Op_g :: Op
Op_RG :: Op
Op_rg :: Op
Op_K :: Op
Op_k :: Op

-- | Shading Operator
Op_sh :: Op

-- | Inline Image Operators
Op_BI :: Op
Op_ID :: Op
Op_EI :: Op

-- | XObject Operator
Op_Do :: Op

-- | Marked Content Operators
Op_MP :: Op
Op_DP :: Op
Op_BMC :: Op
Op_BDC :: Op
Op_EMC :: Op

-- | Compatibility Operators
Op_BX :: Op
Op_EX :: Op

-- | Unknown
UnknownOp :: ByteString -> Op

-- | Expression is a regular objects or an operators
data Expr
Obj :: (Object ()) -> Expr
Op :: Op -> Expr

-- | Operator with arguments
type Operator = (Op, [Object ()])

-- | Conversion to operator
toOp :: ByteString -> Op
instance Show Op
instance Eq Op
instance Show Expr
instance Eq Expr


-- | Parse content stream
module Pdf.Toolbox.Content.Parser

-- | Parse content streams for a page
--   
--   Note: we need content stream ref to be able to decrypt stream content.
--   We need stream length because it can be an indirect object in stream
--   dictionary
parseContentStream :: MonadIO m => RIS -> [StreamFilter] -> (Ref -> IS -> IO IS) -> [(Stream Int64, Ref, Int)] -> PdfE m (InputStream Expr)

-- | Read the next operator if any
readNextOperator :: MonadIO m => InputStream Expr -> PdfE m (Maybe Operator)


-- | Unicode CMap defines mapping from glyphs to text
module Pdf.Toolbox.Content.UnicodeCMap

-- | Unicode character map
--   
--   Font dictionary can contain "ToUnicode" key -- reference to a stream
--   with unicode CMap
data UnicodeCMap
UnicodeCMap :: [(ByteString, ByteString)] -> Map Int Text -> [(Int, Int, Char)] -> UnicodeCMap
unicodeCMapCodeRanges :: UnicodeCMap -> [(ByteString, ByteString)]
unicodeCMapChars :: UnicodeCMap -> Map Int Text
unicodeCMapRanges :: UnicodeCMap -> [(Int, Int, Char)]

-- | Parse content of unicode CMap
parseUnicodeCMap :: ByteString -> Either String UnicodeCMap

-- | Take the next glyph code from string, also returns the rest of the
--   string
unicodeCMapNextGlyph :: UnicodeCMap -> ByteString -> Maybe (Int, ByteString)

-- | Convert glyph to text
--   
--   Note: one glyph can represent more then one char, e.g. for ligatures
unicodeCMapDecodeGlyph :: UnicodeCMap -> Int -> Maybe Text
instance Show UnicodeCMap


-- | 2d affine transform
module Pdf.Toolbox.Content.Transform

-- | Affine transform
data Transform a
Transform :: a -> a -> a -> a -> a -> a -> Transform a

-- | 2d vector/point
data Vector a
Vector :: a -> a -> Vector a

-- | Identity transform
identity :: Num a => Transform a

-- | Translation
translation :: Num a => a -> a -> Transform a

-- | Scale
scale :: Num a => a -> a -> Transform a

-- | Apply transformation to vector
transform :: Num a => Transform a -> Vector a -> Vector a

-- | Translate
translate :: Num a => a -> a -> Transform a -> Transform a

-- | Combine two transformations
multiply :: Num a => Transform a -> Transform a -> Transform a
instance Show a => Show (Transform a)
instance Show a => Show (Vector a)


-- | Process content stream operators maintaining graphics state
--   
--   It is pretty experimental
module Pdf.Toolbox.Content.Processor

-- | Processor maintains graphics state
data Processor
Processor :: GraphicsState -> [GraphicsState] -> GlyphDecoder -> [[Glyph]] -> Processor
prState :: Processor -> GraphicsState
prStateStack :: Processor -> [GraphicsState]
prGlyphDecoder :: Processor -> GlyphDecoder

-- | Each element is a list of glyphs, drawn in one shot
prGlyphs :: Processor -> [[Glyph]]

-- | Graphics state
data GraphicsState
GraphicsState :: Bool -> Transform Double -> Maybe Name -> Maybe Double -> Transform Double -> Transform Double -> Double -> Double -> Double -> GraphicsState

-- | Indicates that we are inside text object
gsInText :: GraphicsState -> Bool
gsCurrentTransformMatrix :: GraphicsState -> Transform Double
gsFont :: GraphicsState -> Maybe Name
gsFontSize :: GraphicsState -> Maybe Double

-- | Defined only inside text object
gsTextMatrix :: GraphicsState -> Transform Double

-- | Defined only inside text object
gsTextLineMatrix :: GraphicsState -> Transform Double
gsTextLeading :: GraphicsState -> Double
gsTextCharSpacing :: GraphicsState -> Double
gsTextWordSpacing :: GraphicsState -> Double

-- | Given font name and string, it should return list of glyphs and their
--   widths.
--   
--   Note: it should not try to position or scale glyphs to user space,
--   bounding boxes should be defined in glyph space.
--   
--   Note: glyph width is a distance between the glyph's origin and the
--   next glyph's origin, so it generally can't be calculated from bounding
--   box
--   
--   Note: the <a>Processor</a> actually doesn't cares about glyph's
--   bounding box, so you can return anything you want
type GlyphDecoder = Name -> Str -> [(Glyph, Double)]

-- | Glyph
data Glyph
Glyph :: Int -> Vector Double -> Vector Double -> Maybe Text -> Glyph

-- | The code as read from content stream
glyphCode :: Glyph -> Int

-- | Top-left corner of glyph's bounding box
glyphTopLeft :: Glyph -> Vector Double

-- | Bottom-right corner of glyph's bounding box
glyphBottomRight :: Glyph -> Vector Double

-- | Text ectracted from the glyph
glyphText :: Glyph -> Maybe Text

-- | Empty graphics state
initialGraphicsState :: GraphicsState

-- | Create processor in initial state
mkProcessor :: Processor

-- | Process one operation
processOp :: Monad m => Operator -> Processor -> PdfE m Processor
instance Show Glyph
instance Show GraphicsState


-- | Mapping from glyph names to unicode characters
module Pdf.Toolbox.Content.GlyphList

-- | Glyph list
adobeGlyphList :: Map ByteString Char


-- | Mapping from glyph names to unicode characters for TeX fonts
module Pdf.Toolbox.Content.TexGlyphList

-- | Glyph list
texGlyphList :: Map ByteString Char

module Pdf.Toolbox.Content.Encoding.WinAnsi
encoding :: Map Word8 Text

module Pdf.Toolbox.Content.Encoding.MacRoman
encoding :: Map Word8 Text


-- | Font info contains information, extracted from font, that may be
--   needed when processing content stream
module Pdf.Toolbox.Content.FontInfo

-- | Font info
data FontInfo
FontInfoSimple :: FISimple -> FontInfo
FontInfoComposite :: FIComposite -> FontInfo

-- | Font info for simple fonts
data FISimple
FISimple :: Maybe UnicodeCMap -> Maybe SimpleFontEncoding -> Maybe (Int, Int, [Double]) -> Transform Double -> FISimple
fiSimpleUnicodeCMap :: FISimple -> Maybe UnicodeCMap
fiSimpleEncoding :: FISimple -> Maybe SimpleFontEncoding

-- | FirstChar, LastChar, list of widths
fiSimpleWidths :: FISimple -> Maybe (Int, Int, [Double])
fiSimpleFontMatrix :: FISimple -> Transform Double

-- | Standard encoding, other encodings are based on them
data FontBaseEncoding
FontBaseEncodingWinAnsi :: FontBaseEncoding
FontBaseEncodingMacRoman :: FontBaseEncoding

-- | Encoding fo simple font
data SimpleFontEncoding
SimpleFontEncoding :: FontBaseEncoding -> [(Word8, ByteString)] -> SimpleFontEncoding
simpleFontBaseEncoding :: SimpleFontEncoding -> FontBaseEncoding

-- | Mapping from glyph code to glyph name for cases when it is different
--   from base encoding
simpleFontDifferences :: SimpleFontEncoding -> [(Word8, ByteString)]

-- | Font info for Type0 font
data FIComposite
FIComposite :: Maybe UnicodeCMap -> CIDFontWidths -> Double -> FIComposite
fiCompositeUnicodeCMap :: FIComposite -> Maybe UnicodeCMap
fiCompositeWidths :: FIComposite -> CIDFontWidths
fiCompositeDefaultWidth :: FIComposite -> Double

-- | Glyph widths for CID fonts
data CIDFontWidths
CIDFontWidths :: Map Int Double -> [(Int, Int, Double)] -> CIDFontWidths
cidFontWidthsChars :: CIDFontWidths -> Map Int Double
cidFontWidthsRanges :: CIDFontWidths -> [(Int, Int, Double)]

-- | Make <a>CIDFontWidths</a> from value of "W" key in descendant font
makeCIDFontWidths :: Monad m => Array -> PdfE m CIDFontWidths

-- | Get glyph width by glyph code
cidFontGetWidth :: CIDFontWidths -> Int -> Maybe Double

-- | Decode string into list of glyphs and their widths
fontInfoDecodeGlyphs :: FontInfo -> Str -> [(Glyph, Double)]
instance Show FontBaseEncoding
instance Show SimpleFontEncoding
instance Show FISimple
instance Show CIDFontWidths
instance Show FIComposite
instance Show FontInfo
instance Monoid CIDFontWidths


-- | Low level tools for processing PDF page content stream.
module Pdf.Toolbox.Content
