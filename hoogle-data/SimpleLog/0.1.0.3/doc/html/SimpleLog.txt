-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple, configurable logging
--   
--   SimpleLog allows configurable multi-threaded logging
@package SimpleLog
@version 0.1.0.3


-- | This module defines the <a>Format</a> datatype that describes how to
--   format a log line. It also defines a template function <tt>$(format _)
--   :: <a>Format</a></tt> that allows C-style string formatting. The
--   format string is thus parsed at compile time.
--   
--   The format string may contain the following elements:
--   
--   <ul>
--   <li>%m - The logged message</li>
--   <li>%s - The severity of the message</li>
--   <li>%t - The name of the logging thread</li>
--   <li>%d(FORMAT) - A timestamp, formatted with FORMAT.</li>
--   </ul>
--   
--   The datetime FORMAT is a UNIX style format string detailed in
--   <a>Data.Time.Format</a>. The only difference is that closing brackets
--   ')' inside the datetime format must be escaped with a backslash.
--   
--   Example:
--   
--   <pre>
--   logFormat = $(format "%d(%T) (%s) %t: %m")
--     
--   </pre>
--   
--   Which when logging with <tt><a>logI</a> "Something"</tt> will produce
--   something like:
--   
--   <pre>
--   14:49:06 (INFO   ) main: Something
--     
--   </pre>
--   
--   Example for escaping ')' in the datetime format string:
--   
--   <pre>
--   logFormat = $(format "%d((%F\\)(%T\\)) %m")
--     
--   </pre>
--   
--   Which when logging with <tt><a>logI</a> "Something"</tt> will produce:
--   
--   <pre>
--   (2013-10-02)(16:26:21) Something
--     
--   </pre>
--   
--   Note how we need an additional '\' because of Haskell strings
module System.Log.SLog.Format

-- | A <a>FormatElem</a> is a formatting element
data FormatElem
MessageElem :: FormatElem
SeverityElem :: FormatElem
StringElem :: Text -> FormatElem
DateTimeElem :: (ZonedTime -> Text) -> FormatElem
ThreadElem :: FormatElem

-- | <a>Format</a> is the type of a full format. It is simply a list of
--   <a>FormatElem</a>s
type Format = [FormatElem]

-- | <tt>$(<a>format</a> _) :: <a>Format</a></tt> is a template function
--   that parses the passed in format string, then finalises it and returns
--   a <a>Format</a>.
format :: String -> ExpQ
instance Show FormatElemTH
instance Lift Text


-- | SimpleLog is a library for convenient and configurable logging. It
--   uses the usual monad transformer + associated class design:
--   <a>SLogT</a> and <a>MonadSLog</a>.
--   
--   Example usage:
--   
--   <pre>
--   import System.Log.SLog
--   
--   main = simpleLog "Example.log" $ do
--       logD "Some debugging information"
--       logI "This is some other information"
--       logW "Something bad is about to happen"
--       logE "Something bad happened"
--     
--   </pre>
--   
--   The above sample code when run will produce output similar to this:
--   
--   <pre>
--   2013-10-02 14:17:40 | INFO    | [ThreadId 58] This is some other information
--   2013-10-02 14:17:40 | WARNING | [ThreadId 58] Something bad is about to happen
--   2013-10-02 14:17:40 | ERROR   | [ThreadId 58] Something bad happened
--     
--   </pre>
--   
--   Note how the debug line is not displayed. This is because the default
--   configuration (<a>defaultLogConfig</a>) only logs to stdout when the
--   severity is &gt;= <a>INFO</a>. The above code will also append the log
--   lines to the file <tt>"Example.log"</tt>, including the debug line.
--   
--   The following example shows how one can fine tune SimpleLog as well as
--   how to fork other logging threads.
--   
--   <pre>
--   -- Our log configuration specifies that no ANSI colouring should be used, all log lines
--   -- should be written to the TChan, and &gt;= INFO severity lines should be written to the
--   -- stdout synchronously.
--   logConfig :: TChan LogLine -&gt; LogConfig
--   logConfig tchan
--       = LogConfig { ansiColours = False
--                   , loggers = [ (anySev, TChanLogger tchan)
--                               , ((&gt;= INFO), StdoutLogger Sync)
--                               ] }
--   
--   
--   -- Our custom logging format
--   logFormat :: Format
--   logFormat = $(format "%d(%T) (%s) %t: %m")
--   
--   -- The main thread will fork a child thread, then wait until everything is flushed, then
--   -- count how many messages have been written in total to the TChan (which will be all
--   -- messages as our filter passes through everything)
--   main :: IO ()
--   main = do
--     tchan &lt;- newTChanIO
--     (_, fkey) &lt;- runSLogT (logConfig tchan) logFormat "main" $ do
--       logS "Main thread started successfully"
--       logD "This will not appear on stdout"
--       _ &lt;- forkSLog "child" $ do
--         logS "I am the child"
--         liftIO $ threadDelay 5000000
--         logW "CHILD SHUTTING DOWN"
--       logI "Exiting main thread"
--     waitFlush fkey
--     c &lt;- countTChan tchan
--     putStrLn $ show c ++ " messages have been logged in total"
--   
--   -- Counts the number of elements in the TChan (and pops them all)
--   countTChan :: TChan a -&gt; IO Int
--   countTChan tchan = do
--     let count = do
--           em &lt;- isEmptyTChan tchan
--           if em then return 0
--           else readTChan tchan &gt;&gt; (1 +) &lt;$&gt; count
--     atomically count
--     
--   </pre>
--   
--   The above code when run will produce something like this:
--   
--   <pre>
--   17:35:15 (SUCCESS) main: Main thread started successfully
--   17:35:15 (SUCCESS) child: I am the child, waiting for 5 seconds...
--   17:35:15 (INFO   ) main: Exiting main thread
--   17:35:20 (WARNING) child: CHILD SHUTTING DOWN
--   5 messages have been logged in total
--     
--   </pre>
module System.Log.SLog

-- | The SLogT monad transformer is simply a <a>ResourceT</a> with an
--   environment
data SLogT m a

-- | This is a simple monad for the bottom of one's monad stack.
type SLog = SLogT IO

-- | <a>runSLogT</a> runs an <a>SLogT</a> given a <a>LogConfig</a>,
--   <a>Format</a> and the current thread's name. It returns a
--   <a>FlushKey</a> besides the usual return value.
runSLogT :: (MonadResource m, MonadBaseControl IO m) => LogConfig -> Format -> String -> SLogT m a -> m (a, FlushKey)

-- | <a>simpleLog</a> uses the default configuration with the specified log
--   file name. It also waits using <a>waitFlush</a> until all resources
--   have been released.
simpleLog :: (MonadResource m, MonadBaseControl IO m) => FilePath -> SLogT m a -> m a

-- | A <a>FlushKey</a> is returned when an <a>SLogT</a> is run. You may
--   wait on it with <a>waitFlush</a>.
data FlushKey

-- | <a>waitFlush</a> will only return when all resources have been
--   released and all streams have been flushed. Note that this includes
--   resources allocated by the user using the exposed <a>MonadResource</a>
--   instance.
--   
--   All threads internally accounted for are signaled to exit (they will
--   first finish processing of all remaining jobs) when the <a>SLogT</a>
--   is run, however it is the user's responsibility to shut down threads
--   forked with <a>forkSLog</a> or <a>fork</a> before <a>waitFlush</a> can
--   return.
waitFlush :: FlushKey -> IO ()

-- | The class of monads that can perform logging
class MonadIO m => MonadSLog m where log sev = lift . log sev
log :: MonadSLog m => Severity -> Text -> m ()

-- | Log a <a>DEBUG</a> message
logD :: MonadSLog m => String -> m ()

-- | Log an <a>INFO</a> message
logI :: MonadSLog m => String -> m ()

-- | Log a <a>SUCCESS</a> message
logS :: MonadSLog m => String -> m ()

-- | Log a <a>WARNING</a> message
logW :: MonadSLog m => String -> m ()

-- | Log an <a>ERROR</a> message
logE :: MonadSLog m => String -> m ()

-- | The <a>Logger</a> type specifies the types of sinks we can log to.
data Logger

-- | <a>FileLogger</a> specifies a file to be logged in. Note that symbolic
--   links will be resolved using <a>canonicalizePath</a> when deciding
--   whether two <a>FileLogger</a>s point to the same file.
FileLogger :: Sync -> FilePath -> Logger

-- | <a>StdoutLogger</a> logs to the stdout
StdoutLogger :: Sync -> Logger

-- | <a>StderrLogger</a> logs to the stderr
StderrLogger :: Sync -> Logger

-- | <a>TChanLogger</a> logs to a specified <a>TChan</a>. Note that
--   <a>LogLine</a>s are written instead of the final formatted text. If
--   you wish to use the final text use <a>formatLine</a>.
TChanLogger :: (TChan LogLine) -> Logger

-- | <a>Sync</a> is a type to specify whether a logger should log
--   synchronously or asynchronously. Syncronous logging means that the
--   logging thread will block until the message has been written and
--   flushed to the sink. Asynchronous logging means that the logging
--   thread will write to a work queue and move on. The work queue will be
--   read by a dedicated thread that is forked for each sink.
data Sync
Sync :: Sync
Async :: Sync

-- | <a>LogLine</a> is a log message together with the severity, time of
--   logging and the logging thread's name.
data LogLine
LogLine :: Severity -> Text -> ZonedTime -> Text -> LogLine
logSeverity :: LogLine -> Severity
logMessage :: LogLine -> Text
logTimestamp :: LogLine -> ZonedTime
logThread :: LogLine -> Text

-- | The type of severities with increasing importance
data Severity
DEBUG :: Severity
INFO :: Severity
SUCCESS :: Severity
WARNING :: Severity
ERROR :: Severity

-- | <a>Filter</a> is the type of logging filters. <a>Filter</a>s may only
--   depend on the <a>Severity</a>.
type Filter = Severity -> Bool

-- | <a>anySev</a> allows all lines to be logged.
anySev :: Filter

-- | <a>LogConfig</a> is the configuration of <a>SLogT</a>
data LogConfig
LogConfig :: Bool -> [(Filter, Logger)] -> LogConfig

-- | Specifies whether ANSI colouring should be used when logging to
--   stdout/stderr
ansiColours :: LogConfig -> Bool

-- | The list of loggers together with the associated filters
loggers :: LogConfig -> [(Filter, Logger)]

-- | <a>defaultLogConfig</a> is the default log configuration. It writes
--   all non-DEBUG messages to the stdout synchronously and all messages to
--   a specified file asynchronously.
defaultLogConfig :: FilePath -> LogConfig

-- | The default log format, which currently is <tt>$(format "%d(%F %T) |
--   %s | [%t] %m")</tt>. See <a>System.Log.SLog.Format</a> for more
--   details on format strings.
defaultLogFormat :: Format

-- | <a>forkSLog</a> forks an <a>SLogT</a> thread with the specified thread
--   name.
forkSLog :: (MonadBaseControl IO m, MonadIO m) => String -> SLogT m () -> SLogT m ThreadId

-- | <a>formatLine</a> formats the given <a>LogLine</a> using the specified
--   <a>Format</a>. The <a>Bool</a>ean determines whether <a>formatLine</a>
--   should insert ANSI colour codes or not.
formatLine :: Bool -> Format -> LogLine -> Text

-- | <tt>unsafeUnliftSLog</tt> gives you an unsafe unlift of an SLogT by
--   assuming that any unlifted computation will finish earlier than the
--   runSLogT of the calling thread. It is unsafe because if the unlifted
--   computation doesn't finish earlier then it may access deallocated
--   resources. This is useful when a library is implicitly forking but we
--   still need to log in the forked threads, and we know that the child
--   threads will finish earlier than the parent. An example is
--   Network.WebSockets
unsafeUnliftSLogT :: (Monad m, MonadBaseControl IO m) => ((forall a. SLogT m a -> m a) -> SLogT m b) -> SLogT m b
instance (MonadBase IO m, MonadThrow m, MonadIO m) => MonadResource (SLogT m)
instance MonadBase IO m => MonadBase IO (SLogT m)
instance Show Severity
instance Read Severity
instance Eq Severity
instance Ord Severity
instance Eq Sync
instance Eq Logger
instance Functor m => Functor (SLogT m)
instance Monad m => Monad (SLogT m)
instance MonadIO m => MonadIO (SLogT m)
instance Applicative m => Applicative (SLogT m)
instance MonadThrow m => MonadThrow (SLogT m)
instance MonadIO m => MonadSLog (SLogT m)
instance (MonadBaseControl IO m, MonadIO m) => Forkable (SLogT m) (SLogT m)
instance Semigroup InitLogger
instance MonadTrans SLogT
instance MonadBaseControl IO m => MonadBaseControl IO (SLogT m)
instance MonadTransControl SLogT
instance MonadSLog m => MonadSLog (ResourceT m)
instance MonadSLog m => MonadSLog (ContT r m)
instance (MonadSLog m, Error e) => MonadSLog (ErrorT e m)
instance MonadSLog m => MonadSLog (ReaderT s m)
instance MonadSLog m => MonadSLog (StateT s m)
