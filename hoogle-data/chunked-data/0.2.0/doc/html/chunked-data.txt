-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeclasses for dealing with various chunked data representations
--   
@package chunked-data
@version 0.2.0


-- | Various zipping and unzipping functions for chunked data structures.
module Data.ChunkedZip
class Functor f => Zip f where zip = zipWith (,) zap = zipWith id unzip = fmap fst &&& fmap snd
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
unzip :: Zip f => f (a, b) -> (f a, f b)
class Functor f => Zip3 f where zip3 = zipWith3 (\ x y z -> (x, y, z)) zap3 = zipWith3 id
zipWith3 :: Zip3 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zip3 :: Zip3 f => f a -> f b -> f c -> f (a, b, c)
zap3 :: Zip3 f => f (a -> b -> c) -> f a -> f b -> f c
unzip3 :: Zip3 f => f (a, b, c) -> (f a, f b, f c)
class Functor f => Zip4 f where zip4 = zipWith4 (\ w x y z -> (w, x, y, z)) zap4 = zipWith4 id
zipWith4 :: Zip4 f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zip4 :: Zip4 f => f a -> f b -> f c -> f d -> f (a, b, c, d)
zap4 :: Zip4 f => f (a -> b -> c -> d) -> f a -> f b -> f c -> f d
unzip4 :: Zip4 f => f (a, b, c, d) -> (f a, f b, f c, f d)
class Functor f => Zip5 f where zip5 = zipWith5 (\ v w x y z -> (v, w, x, y, z)) zap5 = zipWith5 id
zipWith5 :: Zip5 f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
zip5 :: Zip5 f => f a -> f b -> f c -> f d -> f e -> f (a, b, c, d, e)
zap5 :: Zip5 f => f (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
unzip5 :: Zip5 f => f (a, b, c, d, e) -> (f a, f b, f c, f d, f e)
class Functor f => Zip6 f where zip6 = zipWith6 (\ u v w x y z -> (u, v, w, x, y, z)) zap6 = zipWith6 id
zipWith6 :: Zip6 f => (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
zip6 :: Zip6 f => f a -> f b -> f c -> f d -> f e -> f g -> f (a, b, c, d, e, g)
zap6 :: Zip6 f => f (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
unzip6 :: Zip6 f => f (a, b, c, d, e, g) -> (f a, f b, f c, f d, f e, f g)
class Functor f => Zip7 f where zip7 = zipWith7 (\ t u v w x y z -> (t, u, v, w, x, y, z)) zap7 = zipWith7 id
zipWith7 :: Zip7 f => (a -> b -> c -> d -> e -> g -> h -> i) -> f a -> f b -> f c -> f d -> f e -> f g -> f h -> f i
zip7 :: Zip7 f => f a -> f b -> f c -> f d -> f e -> f g -> f h -> f (a, b, c, d, e, g, h)
zap7 :: Zip7 f => f (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
unzip7 :: Zip7 f => f (a, b, c, d, e, g, h) -> (f a, f b, f c, f d, f e, f g, f h)
instance Zip7 []
instance Zip6 Vector
instance Zip6 []
instance Zip5 Vector
instance Zip5 []
instance Zip4 Seq
instance Zip4 Vector
instance Zip4 []
instance Zip3 Seq
instance Zip3 Vector
instance Zip3 []
instance (Zip f, Zip g) => Zip (Compose f g)
instance Zip IntMap
instance Zip m => Zip (ReaderT e m)
instance Zip ((->) a)
instance Zip m => Zip (IdentityT m)
instance Zip Vector
instance Zip Tree
instance Zip Seq
instance Zip NonEmpty
instance Zip []


-- | Abstraction for different kinds of builders.
--   
--   Note that whenever a character encoding is used, it will be UTF8. For
--   different behavior, please use the underlying library.
module Data.Builder

-- | Since 0.1.0.0
type TextBuilder = Builder

-- | Since 0.1.0.0
type BlazeBuilder = Builder

-- | Since 0.1.0.0
class Monoid builder => Builder builder lazy | builder -> lazy, lazy -> builder
builderToLazy :: Builder builder lazy => builder -> lazy
flushBuilder :: Builder builder lazy => builder

-- | Since 0.1.0.0
class ToBuilder value builder
toBuilder :: ToBuilder value builder => value -> builder

-- | Provided for type disambiguation in the presence of OverloadedStrings.
--   
--   Since 0.1.0.0
textToBuilder :: ToBuilder Text builder => Text -> builder
instance ToBuilder ByteString Builder
instance ToBuilder ByteString Builder
instance a ~ Char => ToBuilder [a] Builder
instance ToBuilder Char Builder
instance ToBuilder Text Builder
instance ToBuilder Text Builder
instance ToBuilder Builder Builder
instance a ~ Char => ToBuilder [a] Builder
instance ToBuilder Char Builder
instance ToBuilder Text Builder
instance ToBuilder Text Builder
instance ToBuilder Builder Builder
instance Builder Builder ByteString
instance Builder Builder Text

module Data.Textual.Encoding

-- | Textual data which can be encoded to and decoded from UTF8.
class (Textual textual, IsSequence binary) => Utf8 textual binary | textual -> binary, binary -> textual
encodeUtf8 :: Utf8 textual binary => textual -> binary
decodeUtf8 :: Utf8 textual binary => binary -> textual
instance Utf8 Text ByteString
instance Utf8 Text ByteString
instance (c ~ Char, w ~ Word8) => Utf8 [c] [w]

module Data.Sequences.Lazy

-- | Lazy sequences containing strict chunks of data.
class (IsSequence lazy, IsSequence strict) => LazySequence lazy strict | lazy -> strict, strict -> lazy
toChunks :: LazySequence lazy strict => lazy -> [strict]
fromChunks :: LazySequence lazy strict => [strict] -> lazy
toStrict :: LazySequence lazy strict => lazy -> strict
fromStrict :: LazySequence lazy strict => strict -> lazy
instance LazySequence Text Text
instance LazySequence ByteString ByteString

module Data.IOData

-- | Data which can be read to and from files and handles.
--   
--   Note that, for lazy sequences, these operations may perform lazy I/O.
class IsSequence a => IOData a
readFile :: (IOData a, MonadIO m) => FilePath -> m a
writeFile :: (IOData a, MonadIO m) => FilePath -> a -> m ()
getLine :: (IOData a, MonadIO m) => m a
hGetContents :: (IOData a, MonadIO m) => Handle -> m a
hGetLine :: (IOData a, MonadIO m) => Handle -> m a
hPut :: (IOData a, MonadIO m) => Handle -> a -> m ()
hPutStrLn :: (IOData a, MonadIO m) => Handle -> a -> m ()
hGetChunk :: (IOData a, MonadIO m) => Handle -> m a
instance Char ~ c => IOData [c]
instance IOData Text
instance IOData Text
instance IOData ByteString
instance IOData ByteString
