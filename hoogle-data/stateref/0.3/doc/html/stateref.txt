-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstraction for things that work like IORef.
--   
--   A collection of type-classes generalizing the read/write/modify
--   operations for stateful variables provided by things like IORef, TVar,
--   &amp;c. Note that The interface has changed a bit from the 0.2.*
--   version. "*Ref" functions are now called "*Reference" and new "*Ref"
--   function exist with simpler signatures. The new <a>Ref</a> existential
--   type provides a convenient monad-indexed reference type, and the
--   HasRef class indicates monads for which there is a default reference
--   type for every referent.
@package stateref
@version 0.3


-- | This module defines the "MRef" abstraction, which is a set of
--   type-classes for things that behave like
--   <tt>Control.Concurrent.MVar.MVar</tt>s. See the documentation there
--   for more info.
--   
--   This interface may be subject to future expansion. Presently, rather
--   than providing something like
--   <tt>Control.Concurrent.MVar.tryTakeMVar</tt>, instances for
--   "<tt>Data.StateRef.Types.ReadRef</tt> sr m (<a>Maybe</a> a)" are
--   provided, giving <tt>Data.StateRef.Types.readReference</tt> the same
--   type tryTakeMRef would have if it existed. There is currently nothing
--   like <tt>Control.Concurrent.MVar.tryPutMVar</tt>, though. Perhaps
--   there should be. Or, perhaps this is the sort of thing the weird (to
--   me) signature of <tt>Data.IORef.atomicModifyIORef</tt> is for, and an
--   argument for a similar signature for
--   <tt>Data.StateRef.Types.modifyStateRef</tt> or the addition of a new
--   atomicModifyStateRef function.
--   
--   I would like to resolve these questions in version 0.3 of this
--   package.
module Data.MRef.Types
data MRef m a
MRef :: !sr -> MRef m a
class HasMRef m
newMRef :: HasMRef m => a -> m (MRef m a)
newEmptyMRef :: HasMRef m => m (MRef m a)
class Monad m => NewMRef sr m a | sr -> a
newMReference :: NewMRef sr m a => a -> m sr
newEmptyMReference :: NewMRef sr m a => m sr
class Monad m => TakeMRef sr m a | sr -> a
takeMReference :: TakeMRef sr m a => sr -> m a
class Monad m => PutMRef sr m a | sr -> a
putMReference :: PutMRef sr m a => sr -> a -> m ()

module Data.StateRef.Types

-- | A simple reference type, hiding the complexity of all these type
--   classes, since most of the time the only thing you care about is that
--   you want a reference. The full complexity is still there, though, so
--   FFI types or other reference-like things can still be made into
--   <a>Ref</a>s.
data Ref m a
Ref :: !sr -> Ref m a
class WriteRef sr m a | sr -> a
writeReference :: WriteRef sr m a => sr -> a -> m ()
class ReadRef sr m a | sr -> a
readReference :: ReadRef sr m a => sr -> m a
class (ReadRef sr m a, WriteRef sr m a) => ModifyRef sr m a | sr -> a
atomicModifyReference :: ModifyRef sr m a => sr -> (a -> (a, b)) -> m b
modifyReference :: ModifyRef sr m a => sr -> (a -> a) -> m ()

-- | Default implementation of atomicModifyReference in terms of
--   readReference and writeReference
--   
--   Default implementation of modifyReference in terms of readReference
--   and writeReference
class NewRef sr m a | sr -> a
newReference :: NewRef sr m a => a -> m sr
class HasRef m
newRef :: HasRef m => a -> m (Ref m a)


-- | This module exports no new symbols of its own. It defines several
--   basic class instances for creating, reading, and writing standard
--   reference types, and re-exports the types for which it defines
--   instances.
--   
--   TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at a
--   minimum.
module Data.StateRef.Instances

-- | A mutable variable in the <a>IO</a> monad
data IORef a :: * -> *

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a a box, which may be empty or full.
data MVar a :: * -> *

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO m :: (* -> *)
liftIO :: MonadIO m => IO a -> m a

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
data STRef s a :: * -> * -> *

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of
--   <tt>Control.Monad.ST.stToIO</tt>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <tt>Control.Monad.ST.stToIO</tt>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a :: * -> * -> *

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a :: * -> *

-- | A monad supporting atomic memory transactions.
data STM a :: * -> *

-- | Shared memory locations that support atomic memory transactions.
data TVar a :: * -> *

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a :: * -> *

-- | Perform a series of STM actions atomically.
--   
--   You cannot use <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>. Any attempt to do so will result in a
--   runtime error. (Reason: allowing this would effectively allow a
--   transaction inside a transaction, depending on exactly when the thunk
--   is evaluated.)
--   
--   However, see <a>newTVarIO</a>, which can be called inside
--   <a>unsafePerformIO</a>, and which allows top-level TVars to be
--   allocated.
atomically :: STM a -> IO a

-- | Wrap a state reference that supports reading and writing, and add a
--   potentially thread-unsafe <a>ModifyRef</a> instance.
newtype UnsafeModifyRef sr
UnsafeModifyRef :: sr -> UnsafeModifyRef sr
instance (Storable a, MonadIO m) => ModifyRef (ForeignPtr a) m a
instance (Storable a, MonadIO m) => WriteRef (ForeignPtr a) m a
instance (Storable a, MonadIO m) => ReadRef (ForeignPtr a) m a
instance (Storable a, MonadIO m) => NewRef (ForeignPtr a) m a
instance MonadIO m => NewRef (MVar a) m (Maybe a)
instance ModifyRef (STRef s a) (ST s) a
instance WriteRef (STRef s a) (ST s) a
instance ReadRef (STRef s a) (ST s) a
instance NewRef (STRef s a) (ST s) a
instance HasRef (ST s)
instance ModifyRef (STRef RealWorld a) IO a
instance WriteRef (STRef RealWorld a) IO a
instance ReadRef (STRef RealWorld a) IO a
instance NewRef (STRef RealWorld a) IO a
instance ModifyRef (STRef s a) (ST s) a
instance WriteRef (STRef s a) (ST s) a
instance ReadRef (STRef s a) (ST s) a
instance NewRef (STRef s a) (ST s) a
instance HasRef (ST s)
instance MonadIO m => ModifyRef (IORef a) m a
instance MonadIO m => WriteRef (IORef a) m a
instance MonadIO m => ReadRef (IORef a) m a
instance MonadIO m => NewRef (IORef a) m a
instance HasRef IO
instance MonadIO m => ReadRef (ST RealWorld a) m a
instance ReadRef (ST s a) (ST s) a
instance Monad m => NewRef (ST s a) m a
instance MonadIO m => ReadRef (IO a) m a
instance Monad m => NewRef (IO a) m a
instance ModifyRef (Ref m a) m a
instance WriteRef (Ref m a) m a
instance ReadRef (Ref m a) m a
instance HasRef m => NewRef (Ref m a) m a

module Data.Accessor
newtype Getter m a
Getter :: (m a) -> Getter m a
newtype Setter m a
Setter :: (a -> m ()) -> Setter m a
newtype Accessor m a
Accessor :: (Getter m a, Setter m a) -> Accessor m a
instance Monad m => WriteRef (Accessor m a) m a
instance Monad m => ReadRef (Accessor m a) m a
instance Monad m => WriteRef (Setter m a) m a
instance Monad m => ReadRef (Getter m a) m a


-- | This module provides classes and instances for mutable state
--   references. Various implementation exist in common usage, but no way
--   (until now ;-) to define functions using state references which don't
--   depend on the specific monad or reference type in use.
--   
--   These modules use several language extensions, including
--   multi-parameter type classes and functional dependencies.
module Data.StateRef

-- | Read a <a>Ref</a>. See <a>readReference</a>.
readRef :: Ref m a -> m a

-- | Write a <a>Ref</a>. See <a>writeReference</a>
writeRef :: Ref m a -> a -> m ()

-- | Modify a <a>Ref</a>. See <a>modifyReference</a>.
atomicModifyRef :: Ref m a -> (a -> (a, b)) -> m b

-- | Modify a <a>Ref</a>. See <a>modifyReference</a>.
modifyRef :: Ref m a -> (a -> a) -> m ()

-- | Essentially the same concept as <tt>Control.Monad.State.gets</tt>,
--   <tt>Control.Monad.State.asks</tt>, et al. Typically useful to read a
--   field of a referenced ADT by passing a record selector as the second
--   argument.
readsRef :: (ReadRef sr m a, Monad m) => sr -> (a -> b) -> m b

-- | Construct a counter - a monadic value which, each time it is
--   evaluated, returns the <a>succ</a> of the previous value returned.
newCounter :: (HasRef m, Monad m, Enum a) => a -> m (m a)

-- | Create a "lapse reader" (suggestions for better terminology are more
--   than welcome), a sort of a time-lapse of the variable. The first
--   motivating instance for this operation was a clock in a simple
--   simulation application. Given a <a>TVar</a> <a>Double</a> called
--   "clock", a useful value "dT" is yielded by the expression:
--   <a>mkLapseReader</a> clock (-)
mkLapseReader :: (ReadRef sr m a, HasRef m, Monad m) => sr -> (a -> a -> b) -> m (m b)


-- | This module exports no new symbols of its own. It defines basic class
--   instances for creating, reading, and writing <a>MVar</a>s, and
--   re-exports <a>MVar</a>.
module Data.MRef.Instances

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a a box, which may be empty or full.
data MVar a :: * -> *

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO m :: (* -> *)
liftIO :: MonadIO m => IO a -> m a

-- | A monad supporting atomic memory transactions.
data STM a :: * -> *

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a :: * -> *

-- | Shared memory locations that support atomic memory transactions.
data TVar a :: * -> *

-- | Perform a series of STM actions atomically.
--   
--   You cannot use <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>. Any attempt to do so will result in a
--   runtime error. (Reason: allowing this would effectively allow a
--   transaction inside a transaction, depending on exactly when the thunk
--   is evaluated.)
--   
--   However, see <a>newTVarIO</a>, which can be called inside
--   <a>unsafePerformIO</a>, and which allows top-level TVars to be
--   allocated.
atomically :: STM a -> IO a
instance MonadIO m => PutMRef (MVar a) m a
instance MonadIO m => TakeMRef (MVar a) m a
instance MonadIO m => NewMRef (MVar a) m a
instance HasMRef IO

module Data.MRef

-- | See <a>takeMRef</a>.
takeMRef :: MRef m a -> m a

-- | See <a>putMRef</a>.
putMRef :: MRef m a -> a -> m ()
