-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinator parsing with Data.ByteString.Lazy
--   
--   Combinator parsing with Data.ByteString.Lazy
@package bytestringparser
@version 0.3


-- | Simple, efficient parser combinators for lazy <a>ByteString</a>
--   strings, loosely based on Text.ParserCombinators.Parsec.
module Data.ParserCombinators.Attoparsec.Internal
type ParseError = String
data Parser a

-- | Run a parser.
parse :: Parser a -> ByteString -> (ByteString, Either ParseError a)
parseAt :: Parser a -> ByteString -> Int64 -> (ByteString, Either ParseError (a, Int64))
parseTest :: (Show a) => Parser a -> ByteString -> IO ()

-- | Name the parser.
(<?>) :: Parser a -> String -> Parser a
try :: Parser a -> Parser a
manyTill :: Parser a -> Parser b -> Parser [a]

-- | Detect 'end of file'.
eof :: Parser ()

-- | <a>skipMany</a> - skip zero or many instances of the parser
skipMany :: Parser a -> Parser ()

-- | <a>skipMany1</a> - skip one or many instances of the parser
skipMany1 :: Parser a -> Parser ()

-- | Apply the given parser repeatedly, returning every parse result.
count :: Int -> Parser a -> Parser [a]
lookAhead :: Parser a -> Parser a
peek :: Parser a -> Parser (Maybe a)
sepBy :: Parser a -> Parser s -> Parser [a]
sepBy1 :: Parser a -> Parser s -> Parser [a]

-- | Character parser.
satisfy :: (Word8 -> Bool) -> Parser Word8
anyWord8 :: Parser Word8

-- | Satisfy a specific character.
word8 :: Word8 -> Parser Word8

-- | Satisfy a specific character.
notWord8 :: Word8 -> Parser Word8

-- | Satisfy a literal string.
string :: ByteString -> Parser ByteString

-- | Satisfy a literal string, after applying a transformation to both it
--   and the matching text.
stringTransform :: (ByteString -> ByteString) -> ByteString -> Parser ByteString
eitherP :: Parser a -> Parser b -> Parser (Either a b)

-- | Get remaining input.
getInput :: Parser ByteString

-- | Get number of bytes consumed so far.
getConsumed :: Parser Int64

-- | Consume characters while the predicate is true.
takeWhile :: (Word8 -> Bool) -> Parser ByteString
takeWhile1 :: (Word8 -> Bool) -> Parser ByteString
takeTill :: (Word8 -> Bool) -> Parser ByteString
takeAll :: Parser ByteString

-- | Skip over characters while the predicate is true.
skipWhile :: (Word8 -> Bool) -> Parser ()

-- | Test that a parser returned a non-null ByteString.
notEmpty :: Parser ByteString -> Parser ByteString

-- | Parse some input with the given parser and return that input without
--   copying it.
match :: Parser a -> Parser ByteString
instance Alternative Parser
instance Applicative Parser
instance MonadPlus Parser
instance MonadFix Parser
instance Monad Parser
instance Functor Parser


-- | Fast 8-bit character set membership.
module Data.ParserCombinators.Attoparsec.FastSet
data FastSet

-- | Create a character set.
set :: ByteString -> FastSet

-- | Check the table for membership.
memberChar :: Char -> FastSet -> Bool

-- | Check the table for membership.
memberWord8 :: Word8 -> FastSet -> Bool
fromSet :: FastSet -> ByteString
instance Eq FastSet
instance Ord FastSet
instance Show FastSet


-- | Simple, efficient parser combinators for lazy <a>ByteString</a>
--   strings, loosely based on Text.ParserCombinators.Parsec.
module Data.ParserCombinators.Attoparsec.Char8
type ParseError = String
data Parser a

-- | Run a parser.
parse :: Parser a -> ByteString -> (ByteString, Either ParseError a)
parseAt :: Parser a -> ByteString -> Int64 -> (ByteString, Either ParseError (a, Int64))
parseTest :: (Show a) => Parser a -> ByteString -> IO ()

-- | Name the parser.
(<?>) :: Parser a -> String -> Parser a
try :: Parser a -> Parser a
manyTill :: Parser a -> Parser b -> Parser [a]

-- | Detect 'end of file'.
eof :: Parser ()

-- | <a>skipMany</a> - skip zero or many instances of the parser
skipMany :: Parser a -> Parser ()

-- | <a>skipMany1</a> - skip one or many instances of the parser
skipMany1 :: Parser a -> Parser ()

-- | Apply the given parser repeatedly, returning every parse result.
count :: Int -> Parser a -> Parser [a]
lookAhead :: Parser a -> Parser a
peek :: Parser a -> Parser (Maybe a)
sepBy :: Parser a -> Parser s -> Parser [a]
sepBy1 :: Parser a -> Parser s -> Parser [a]

-- | Character parser.
satisfy :: (Char -> Bool) -> Parser Char
letter :: Parser Char
digit :: Parser Char
anyChar :: Parser Char
space :: Parser Char

-- | Satisfy a specific character.
char :: Char -> Parser Char

-- | Satisfy a specific character.
notChar :: Char -> Parser Char

-- | Satisfy a literal string.
string :: ByteString -> Parser ByteString

-- | Satisfy a literal string, ignoring case.
stringCI :: ByteString -> Parser ByteString
eitherP :: Parser a -> Parser b -> Parser (Either a b)

-- | Get remaining input.
getInput :: Parser ByteString

-- | Get number of bytes consumed so far.
getConsumed :: Parser Int64

-- | Consume characters while the predicate is true.
takeWhile :: (Char -> Bool) -> Parser ByteString
takeWhile1 :: (Char -> Bool) -> Parser ByteString
takeTill :: (Char -> Bool) -> Parser ByteString
takeAll :: Parser ByteString

-- | Skip over characters while the predicate is true.
skipWhile :: (Char -> Bool) -> Parser ()

-- | Skip over white space.
skipSpace :: Parser ()

-- | Test that a parser returned a non-null ByteString.
notEmpty :: Parser ByteString -> Parser ByteString

-- | Parse some input with the given parser and return that input without
--   copying it.
match :: Parser a -> Parser ByteString
inClass :: String -> Char -> Bool
notInClass :: String -> Char -> Bool


-- | Simple, efficient parser combinators for lazy LB.ByteString strings,
--   loosely based on Text.ParserCombinators.Parsec.
module Data.ParserCombinators.Attoparsec
type ParseError = String
data Parser a

-- | Run a parser.
parse :: Parser a -> ByteString -> (ByteString, Either ParseError a)
parseAt :: Parser a -> ByteString -> Int64 -> (ByteString, Either ParseError (a, Int64))
parseTest :: (Show a) => Parser a -> ByteString -> IO ()

-- | Name the parser.
(<?>) :: Parser a -> String -> Parser a
try :: Parser a -> Parser a
manyTill :: Parser a -> Parser b -> Parser [a]

-- | Detect 'end of file'.
eof :: Parser ()

-- | <a>skipMany</a> - skip zero or many instances of the parser
skipMany :: Parser a -> Parser ()

-- | <a>skipMany1</a> - skip one or many instances of the parser
skipMany1 :: Parser a -> Parser ()

-- | Apply the given parser repeatedly, returning every parse result.
count :: Int -> Parser a -> Parser [a]
lookAhead :: Parser a -> Parser a
peek :: Parser a -> Parser (Maybe a)
sepBy :: Parser a -> Parser s -> Parser [a]
sepBy1 :: Parser a -> Parser s -> Parser [a]

-- | Character parser.
satisfy :: (Word8 -> Bool) -> Parser Word8
anyWord8 :: Parser Word8

-- | Satisfy a specific character.
word8 :: Word8 -> Parser Word8

-- | Satisfy a specific character.
notWord8 :: Word8 -> Parser Word8

-- | Satisfy a literal string.
string :: ByteString -> Parser ByteString

-- | Satisfy a literal string, after applying a transformation to both it
--   and the matching text.
stringTransform :: (ByteString -> ByteString) -> ByteString -> Parser ByteString
eitherP :: Parser a -> Parser b -> Parser (Either a b)

-- | Get remaining input.
getInput :: Parser ByteString

-- | Get number of bytes consumed so far.
getConsumed :: Parser Int64

-- | Consume characters while the predicate is true.
takeWhile :: (Word8 -> Bool) -> Parser ByteString
takeWhile1 :: (Word8 -> Bool) -> Parser ByteString
takeTill :: (Word8 -> Bool) -> Parser ByteString
takeAll :: Parser ByteString

-- | Skip over characters while the predicate is true.
skipWhile :: (Word8 -> Bool) -> Parser ()

-- | Test that a parser returned a non-null ByteString.
notEmpty :: Parser ByteString -> Parser ByteString

-- | Parse some input with the given parser and return that input without
--   copying it.
match :: Parser a -> Parser ByteString
