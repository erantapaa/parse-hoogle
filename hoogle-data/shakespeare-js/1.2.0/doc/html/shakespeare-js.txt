-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stick your haskell variables into javascript/coffeescript at compile time.
--   
--   Shakespeare is a template family for type-safe, efficient templates
--   with simple variable interpolation. Shakespeare templates can be used
--   inline with a quasi-quoter or in an external file. Shakespeare
--   interpolates variables according to the type being inserted. In this
--   case, the variable type needs a ToJavascript instance.
--   
--   shakespeare-javascript is alson known as Julius, and passes through
--   plain javascript
--   
--   There is also a shakespeare version for CoffeeScript, TypeScript, and
--   Roy, all languages that compile down to Javascript. They all expect
--   you to have the appropriate compiler in your path.
--   
--   shakespeare originated from the hamlet template package. Please see
--   http:<i></i>www.yesodweb.com<i>book</i>shakespearean-templates for a
--   more thorough description and examples
@package shakespeare-js
@version 1.2.0


-- | A Shakespearean module for Javascript templates, introducing
--   type-safe, compile-time variable and url interpolation.--
--   
--   You might consider trying <a>Typescript</a> or <a>Coffee</a> which
--   compile down to Javascript.
--   
--   Further reading: <a>http://www.yesodweb.com/book/templates</a>
module Text.Julius
js :: QuasiQuoter
julius :: QuasiQuoter
juliusFile :: FilePath -> Q Exp
jsFile :: FilePath -> Q Exp

-- | <i>Deprecated: Please use juliusFileReload instead. </i>
juliusFileDebug :: FilePath -> Q Exp

-- | <i>Deprecated: Please use jsFileReload instead. </i>
jsFileDebug :: FilePath -> Q Exp
juliusFileReload :: FilePath -> Q Exp
jsFileReload :: FilePath -> Q Exp

-- | Return type of template-reading functions.
type JavascriptUrl url = (url -> [(Text, Text)] -> Text) -> Javascript

-- | Newtype wrapper of <a>Builder</a>.
newtype Javascript
Javascript :: Builder -> Javascript
unJavascript :: Javascript -> Builder
newtype RawJavascript
RawJavascript :: Builder -> RawJavascript

-- | A typeclass for types that can be interpolated in CoffeeScript
--   templates.
class ToJavascript a
toJavascript :: ToJavascript a => a -> Javascript
class RawJS a
rawJS :: RawJS a => a -> RawJavascript
renderJavascript :: Javascript -> Text

-- | render with route interpolation. If using this module standalone,
--   apart from type-safe routes, a dummy renderer can be used:
--   
--   <pre>
--   renderJavascriptUrl (\_ _ -&gt; undefined) javascriptUrl
--   </pre>
--   
--   When using Yesod, a renderer is generated for you, which can be
--   accessed within the GHandler monad: <a>getUrlRenderParams</a>.
renderJavascriptUrl :: (url -> [(Text, Text)] -> Text) -> JavascriptUrl url -> Text
javascriptSettings :: Q ShakespeareSettings

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
juliusUsedIdentifiers :: String -> [(Deref, VarType)]
instance Monoid Javascript
instance RawJS Bool
instance RawJS Builder
instance RawJS Text
instance RawJS Text
instance RawJS [Char]
instance ToJavascript RawJavascript
instance ToJavascript Value
instance ToJavascript Bool


-- | A Shakespearean module for CoffeeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>coffee</tt>.
--   
--   To use this module, <tt>coffee</tt> must be installed on your system.
--   
--   <tt>#{...}</tt> is the Shakespearean standard for variable
--   interpolation, but CoffeeScript already uses that sequence for string
--   interpolation. Therefore, Shakespearean interpolation is introduced
--   with <tt>%{...}</tt>.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>coffee</tt>, and then the value of
--   the variables are applied to the function. This means that in
--   production the template can be compiled once at compile time and there
--   will be no dependency in your production system on <tt>coffee</tt>.
--   
--   Your code:
--   
--   <pre>
--   b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Function wrapper added to your coffeescript code:
--   
--   <pre>
--   ((shakespeare_var_a) =&gt;
--     b = 1
--     console.log(shakespeare_var_a + b)
--   )
--   </pre>
--   
--   This is then compiled down to javascript, and the variables are
--   applied:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>CoffeeScript: <a>http://coffeescript.org/</a></li>
--   </ol>
module Text.Coffee

-- | Read inline, quasiquoted CoffeeScript.
coffee :: QuasiQuoter

-- | Read in a CoffeeScript template file. This function reads the file
--   once, at compile time.
coffeeFile :: FilePath -> Q Exp

-- | Read in a CoffeeScript template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
coffeeFileReload :: FilePath -> Q Exp

-- | Deprecated synonym for <a>coffeeFileReload</a>

-- | <i>Deprecated: Please use coffeeFileReload instead. </i>
coffeeFileDebug :: FilePath -> Q Exp


-- | A Shakespearean module for Roy, introducing type-safe, compile-time
--   variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>roy</tt>.
--   
--   To use this module, <tt>roy</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>roy</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>roy</tt>.
--   
--   Your code:
--   
--   <pre>
--   let b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>Roy: <a>http://http://roy.brianmckenna.org/</a></li>
--   </ol>
module Text.Roy

-- | Read inline, quasiquoted Roy.
roy :: QuasiQuoter

-- | Read in a Roy template file. This function reads the file once, at
--   compile time.
royFile :: FilePath -> Q Exp

-- | Read in a Roy template file. This impure function uses unsafePerformIO
--   to re-read the file on every call, allowing for rapid iteration.
royFileReload :: FilePath -> Q Exp


-- | A Shakespearean module for TypeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>tsc</tt>.
--   
--   To use this module, <tt>tsc</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>tsc</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>tsc</tt>.
--   
--   Your code:
--   
--   <pre>
--   var b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Important Warnings! This integration is not ideal.
--   
--   Due to the function wrapper, all type declarations must be in separate
--   .d.ts files. However, if you don't interpolate variables, no function
--   wrapper will be created, and you can make type declarations in the
--   same file.
--   
--   This does not work cross-platform!
--   
--   Unfortunately tsc does not support stdin and stdout. So a hack of
--   writing to temporary files using the mktemp command is used. This
--   works on my version of Linux, but not for windows unless perhaps you
--   install a mktemp utility, which I have not tested. Please vote up this
--   bug: <a>http://typescript.codeplex.com/workitem/600</a>
--   
--   Making this work on Windows would not be very difficult, it will just
--   require a new package with a dependency on a package like temporary.
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>http://www.yesodweb.com/book/templates</a></li>
--   <li>TypeScript: <a>http://typescript.codeplex.com/</a></li>
--   </ol>
module Text.TypeScript

-- | Read inline, quasiquoted TypeScript
tsc :: QuasiQuoter

-- | Read in a TypeScript template file. This function reads the file once,
--   at compile time.
typeScriptFile :: FilePath -> Q Exp

-- | Read in a Roy template file. This impure function uses unsafePerformIO
--   to re-read the file on every call, allowing for rapid iteration.
typeScriptFileReload :: FilePath -> Q Exp
