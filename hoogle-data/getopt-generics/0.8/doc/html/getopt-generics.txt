-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple command line argument parsing
--   
@package getopt-generics
@version 0.8


-- | <tt>getopt-generics</tt> tries to make it very simple to create
--   command line argument parsers. An introductory example can be found in
--   the <a>README</a>.
module System.Console.GetOpt.Generics

-- | Parses command line arguments (gotten from <a>withArgs</a>) and
--   returns the parsed value. This function should be enough for simple
--   use-cases.
--   
--   May throw the following exceptions:
--   
--   <ul>
--   <li><tt><tt>ExitFailure</tt> 1</tt> in case of invalid options. Error
--   messages are written to <tt>stderr</tt>.</li>
--   <li><tt><tt>ExitSuccess</tt></tt> in case <tt>--help</tt> is given.
--   (<tt><tt>ExitSuccess</tt></tt> behaves like a normal exception, except
--   that -- if uncaught -- the process will exit with exit-code
--   <tt>0</tt>.) Help output is written to <tt>stdout</tt>.</li>
--   </ul>
getArguments :: (Generic a, HasDatatypeInfo a, All2 Option (Code a)) => IO a

-- | Like <a>getArguments</a> but allows you to pass in <a>Modifier</a>s.
modifiedGetArguments :: (Generic a, HasDatatypeInfo a, All2 Option (Code a)) => [Modifier] -> IO a

-- | Pure variant of <a>getArguments</a>.
--   
--   Does not throw any exceptions.
parseArguments :: (Generic a, HasDatatypeInfo a, All2 Option (Code a)) => String -> [Modifier] -> [String] -> Result a

-- | Type to wrap results from the pure parsing functions.
data Result a

-- | The CLI was used correctly and a value of type <tt>a</tt> was
--   successfully constructed.
Success :: a -> Result a

-- | The CLI was used incorrectly. The <a>Result</a> contains a list of
--   error messages.
--   
--   It can also happen that the data type you're trying to use isn't
--   supported. See the <a>README</a> for details.
Errors :: [String] -> Result a

-- | The CLI was used with <tt>--help</tt>. The <a>Result</a> contains the
--   help message.
OutputAndExit :: String -> Result a

-- | <a>Modifier</a>s can be used to customize the command line parser.
data Modifier

-- | <tt>AddShortOption fieldName c</tt> adds the <a>Char</a> <tt>c</tt> as
--   a short option for the field addressed by <tt>fieldName</tt>.
AddShortOption :: String -> Char -> Modifier

-- | <tt>RenameOption fieldName customName</tt> renames the option
--   generated through the <tt>fieldName</tt> by <tt>customName</tt>.
RenameOption :: String -> String -> Modifier

-- | <tt>RenameOptions f</tt> renames all options with the given functions.
--   In case the function returns <tt>Nothing</tt> the original field name
--   is used.
--   
--   Can be used together with <a>stripPrefix</a>.
RenameOptions :: (String -> Maybe String) -> Modifier

-- | <tt>UseForPositionalArguments fieldName argumentType</tt> fills the
--   field addressed by <tt>fieldName</tt> with the positional arguments
--   (i.e. arguments that don't correspond to a flag). The field has to
--   have type <tt>[<a>String</a>]</tt>.
--   
--   <tt>argumentType</tt> is used as the type of the positional arguments
--   in the help output.
UseForPositionalArguments :: String -> String -> Modifier

-- | <tt>AddOptionHelp fieldName helpText</tt> adds a help text for the
--   option <tt>fieldName</tt>.
AddOptionHelp :: String -> String -> Modifier

-- | <tt>AddVersionFlag version</tt> adds a <tt>--version</tt> flag.
AddVersionFlag :: String -> Modifier

-- | Derives <a>AddShortOption</a>s for all fields of the datatype that
--   start with a unique character.
deriveShortOptions :: (HasDatatypeInfo a, SingI (Code a)) => Proxy a -> [Modifier]

-- | Type class for all allowed field types.
--   
--   If you want to use custom field types you should implement an
--   <tt>instance Option YourCustomType</tt> containing implementations of
--   <a>argumentType</a> and <a>parseArgument</a> (the minimal complete
--   definition). For an example see the <a>README</a>.
class Typeable a => Option a where _toOption = ReqArg parseAsFieldState (argumentType (Proxy :: Proxy a)) _emptyOption modifiers flagName = Unset ("missing option: --" ++ mkLongOption modifiers flagName ++ "=" ++ argumentType (Proxy :: Proxy a)) _accumulate _ x = x
argumentType :: Option a => Proxy a -> String
parseArgument :: Option a => String -> Maybe a
_toOption :: Option a => ArgDescr (FieldState a)
_emptyOption :: Option a => Modifiers -> FieldString -> FieldState a
_accumulate :: Option a => a -> a -> a

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of are datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (SingI [[*]] (Code a), All [*] (SingI [*]) (Code a)) => Generic a where type family Code a :: [[*]]

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class HasDatatypeInfo a

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the innert lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.

-- | The code of a datatype.
--   
--   This is a list of lists of its components. The outer list contains one
--   element per constructor. The inner list contains one element per
--   constructor argument (field).
--   
--   <i>Example:</i> The datatype
--   
--   <pre>
--   data Tree = Leaf Int | Node Tree Tree
--   </pre>
--   
--   is supposed to have the following code:
--   
--   <pre>
--   type instance Code (Tree a) =
--     '[ '[ Int ]
--      , '[ Tree, Tree ]
--      ]
--   </pre>

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
instance [overlap ok] Typeable FieldState
instance [overlap ok] Eq OutputInfoFlag
instance [overlap ok] Ord OutputInfoFlag
instance [overlap ok] Option Double
instance [overlap ok] Option Float
instance [overlap ok] Option Integer
instance [overlap ok] Option Int
instance [overlap ok] Option String
instance [overlap ok] Option Bool
instance [overlap ok] Option a => Option (Maybe a)
instance [overlap ok] Option a => Option [a]
