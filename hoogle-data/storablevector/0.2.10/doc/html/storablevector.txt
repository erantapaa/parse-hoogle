-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast, packed, strict storable arrays with a list interface like ByteString
--   
--   Fast, packed, strict storable arrays with a list interface, a chunky
--   lazy list interface with variable chunk size and an interface for
--   write access via the <tt>ST</tt> monad. This is much like
--   <tt>bytestring</tt> and <tt>binary</tt> but can be used for every
--   <a>Foreign.Storable.Storable</a> type. See also package
--   <a>http://hackage.haskell.org/package/vector</a> with a similar
--   intention.
--   
--   We do not provide advanced fusion optimization, since especially for
--   lazy vectors this would either be incorrect or not applicable. However
--   we provide fusion with lazy lists in the package
--   <a>http://hackage.haskell.org/package/storablevector-streamfusion</a>.
@package storablevector
@version 0.2.10


-- | A module containing semi-public StorableVector internals. This exposes
--   the StorableVector representation and low level construction
--   functions. Modules which extend the StorableVector system will need to
--   use this module while ideally most users will be able to make do with
--   the public interface modules.
module Data.StorableVector.Base

-- | A space-efficient representation of a vector, supporting many
--   efficient operations.
--   
--   Instances of Eq, Ord, Read, Show, Data, Typeable
data Vector a
SV :: {-# UNPACK #-} !(ForeignPtr a) -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Vector a

-- | A variety of <a>head</a> for non-empty Vectors. <a>unsafeHead</a>
--   omits the check for the empty case, so there is an obligation on the
--   programmer to provide a proof that the Vector is non-empty.
unsafeHead :: Storable a => Vector a -> a

-- | A variety of <a>tail</a> for non-empty Vectors. <a>unsafeTail</a>
--   omits the check for the empty case. As with <a>unsafeHead</a>, the
--   programmer must provide a separate proof that the Vector is non-empty.
unsafeTail :: Storable a => Vector a -> Vector a

-- | A variety of <a>last</a> for non-empty Vectors. <a>unsafeLast</a>
--   omits the check for the empty case, so there is an obligation on the
--   programmer to provide a proof that the Vector is non-empty.
unsafeLast :: Storable a => Vector a -> a

-- | A variety of <a>init</a> for non-empty Vectors. <a>unsafeInit</a>
--   omits the check for the empty case. As with <a>unsafeLast</a>, the
--   programmer must provide a separate proof that the Vector is non-empty.
unsafeInit :: Storable a => Vector a -> Vector a

-- | Unsafe <a>Vector</a> index (subscript) operator, starting from 0,
--   returning a single element. This omits the bounds check, which means
--   there is an accompanying obligation on the programmer to ensure the
--   bounds are checked in some other way.
unsafeIndex :: Storable a => Vector a -> Int -> a

-- | A variety of <a>take</a> which omits the checks on <tt>n</tt> so there
--   is an obligation on the programmer to provide a proof that <tt>0 &lt;=
--   n &lt;= <a>length</a> xs</tt>.
unsafeTake :: Storable a => Int -> Vector a -> Vector a

-- | A variety of <a>drop</a> which omits the checks on <tt>n</tt> so there
--   is an obligation on the programmer to provide a proof that <tt>0 &lt;=
--   n &lt;= <a>length</a> xs</tt>.
unsafeDrop :: Storable a => Int -> Vector a -> Vector a

-- | Wrapper of mallocForeignPtrArray.
create :: Storable a => Int -> (Ptr a -> IO ()) -> IO (Vector a)

-- | Given the maximum size needed and a function to make the contents of a
--   Vector, createAndTrim makes the <a>Vector</a>. The generating function
--   is required to return the actual final size (&lt;= the maximum size),
--   and the resulting byte array is realloced to this size.
--   
--   createAndTrim is the main mechanism for creating custom, efficient
--   Vector functions, using Haskell or C functions to fill the space.
createAndTrim :: Storable a => Int -> (Ptr a -> IO Int) -> IO (Vector a)
createAndTrim' :: Storable a => Int -> (Ptr a -> IO (Int, Int, b)) -> IO (Vector a, b)

-- | A way of creating Vectors outside the IO monad. The <tt>Int</tt>
--   argument gives the final size of the Vector. Unlike
--   <a>createAndTrim</a> the Vector is not reallocated if the final size
--   is less than the estimated size.
unsafeCreate :: Storable a => Int -> (Ptr a -> IO ()) -> Vector a

-- | <i>O(1)</i> Build a Vector from a ForeignPtr
fromForeignPtr :: ForeignPtr a -> Int -> Vector a

-- | <i>O(1)</i> Deconstruct a ForeignPtr from a Vector
toForeignPtr :: Vector a -> (ForeignPtr a, Int, Int)

-- | Run an action that is initialized with a pointer to the first element
--   to be used.
withStartPtr :: Storable a => Vector a -> (Ptr a -> Int -> IO b) -> IO b
incPtr :: Storable a => Ptr a -> Ptr a

-- | Just like Unsafe.performIO, but we inline it. Big performance gains as
--   it exposes lots of things to further inlining. <i>Very unsafe</i>. In
--   particular, you should do no memory allocation inside an
--   <a>inlinePerformIO</a> block. On Hugs this is just
--   <tt>Unsafe.performIO</tt>.
inlinePerformIO :: IO a -> a
instance Typeable Vector
instance Data a => Data (Vector a)
instance (Storable a, Show a) => Show (Vector a)


-- | In principle you can traverse through a storable vector using repeated
--   calls to <tt>viewL</tt> or using <tt>index</tt>. However this needs a
--   bit of pointer arrangement and allocation. This data structure should
--   make loops optimally fast.
module Data.StorableVector.Pointer

-- | We might have name the data type iterator.
data Pointer a
Pointer :: {-# UNPACK #-} !(ForeignPtr a) -> {-# UNPACK #-} !(Ptr a) -> {-# UNPACK #-} !Int -> Pointer a
fptr :: Pointer a -> {-# UNPACK #-} !(ForeignPtr a)
ptr :: Pointer a -> {-# UNPACK #-} !(Ptr a)
left :: Pointer a -> {-# UNPACK #-} !Int
cons :: Storable a => Vector a -> Pointer a
viewL :: Storable a => Pointer a -> Maybe (a, Pointer a)
switchL :: Storable a => b -> (a -> Pointer a -> b) -> Pointer a -> b


-- | A time and space-efficient implementation of vectors using packed
--   arrays, suitable for high performance use, both in terms of large data
--   quantities, or high speed requirements. Vectors are encoded as strict
--   arrays, held in a <a>ForeignPtr</a>, and can be passed between C and
--   Haskell with little effort.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. eg.
--   
--   <pre>
--   import qualified Data.StorableVector as V
--   </pre>
--   
--   Original GHC implementation by Bryan O'Sullivan. Rewritten to use
--   UArray by Simon Marlow. Rewritten to support slices and use ForeignPtr
--   by David Roundy. Polished and extended by Don Stewart. Generalized to
--   any Storable value by Spencer Janssen. Chunky lazy stream, also with
--   chunk pattern control, mutable access in ST monad, Builder monoid by
--   Henning Thieleman.
module Data.StorableVector

-- | A space-efficient representation of a vector, supporting many
--   efficient operations.
--   
--   Instances of Eq, Ord, Read, Show, Data, Typeable
data Vector a

-- | <i>O(1)</i> The empty <a>Vector</a>
empty :: Storable a => Vector a

-- | <i>O(1)</i> Construct a <a>Vector</a> containing a single element
singleton :: Storable a => a -> Vector a

-- | <i>O(n)</i> Convert a '[a]' into a 'Vector a'.
pack :: Storable a => [a] -> Vector a

-- | <i>O(n)</i> Converts a 'Vector a' to a '[a]'.
unpack :: Storable a => Vector a -> [a]

-- | <i>O(n)</i> Convert first <tt>n</tt> elements of a '[a]' into a
--   'Vector a'.
packN :: Storable a => Int -> [a] -> (Vector a, [a])

-- | <i>O(n)</i> Convert a list into a <a>Vector</a> using a conversion
--   function
packWith :: Storable b => (a -> b) -> [a] -> Vector b

-- | <i>O(n)</i> Convert a <a>Vector</a> into a list using a conversion
--   function
unpackWith :: Storable a => (a -> b) -> Vector a -> [b]

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires a memcpy.
cons :: Storable a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element to the end of a <a>Vector</a>
snoc :: Storable a => Vector a -> a -> Vector a

-- | <i>O(n)</i> Append two Vectors
append :: Storable a => Vector a -> Vector a -> Vector a

-- | <i>O(1)</i> Extract the first element of a <a>Vector</a>, which must
--   be non-empty. It is a checked error to pass an empty <a>Vector</a>.
head :: Storable a => Vector a -> a

-- | <i>O(1)</i> Extract the last element of a <a>Vector</a>, which must be
--   finite and non-empty. It is a checked error to pass an empty
--   <a>Vector</a>.
last :: Storable a => Vector a -> a

-- | <i>O(1)</i> Extract the elements after the head of a <a>Vector</a>,
--   which must be non-empty. It is a checked error to pass an empty
--   <a>Vector</a>.
tail :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Return all the elements of a <a>Vector</a> except the last
--   one. It is a checked error to pass an empty <a>Vector</a>.
init :: Vector a -> Vector a

-- | <i>O(1)</i> Test whether a <a>Vector</a> is empty.
null :: Vector a -> Bool

-- | <i>O(1)</i> <a>length</a> returns the length of a <a>Vector</a> as an
--   <a>Int</a>.
length :: Vector a -> Int
viewL :: Storable a => Vector a -> Maybe (a, Vector a)
viewR :: Storable a => Vector a -> Maybe (Vector a, a)
switchL :: Storable a => b -> (a -> Vector a -> b) -> Vector a -> b
switchR :: Storable a => b -> (Vector a -> a -> b) -> Vector a -> b

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the <a>Vector</a> obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>.
map :: (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> <a>reverse</a> <tt>xs</tt> efficiently returns the
--   elements of <tt>xs</tt> in reverse order.
reverse :: Storable a => Vector a -> Vector a

-- | <i>O(n)</i> The <a>intersperse</a> function takes a element and a
--   <a>Vector</a> and `intersperses' that element between the elements of
--   the <a>Vector</a>. It is analogous to the intersperse function on
--   Lists.
intersperse :: Storable a => a -> Vector a -> Vector a

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>Vector</a> argument.
transpose :: Storable a => [Vector a] -> [Vector a]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a Vector, reduces
--   the <a>Vector</a> using the binary operator, from left to right.
foldl :: Storable a => (b -> a -> b) -> b -> Vector a -> b

-- | 'foldl\'' is like <a>foldl</a>, but strict in the accumulator.
foldl' :: Storable a => (b -> a -> b) -> b -> Vector a -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>Vector</a>s. It is
--   a checked error to pass an empty <a>Vector</a>.
foldl1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | 'foldl1\'' is like <a>foldl1</a>, but strict in the accumulator. It is
--   a checked error to pass an empty <a>Vector</a>.
foldl1' :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a <a>Vector</a>,
--   reduces the <a>Vector</a> using the binary operator, from right to
--   left. However, it is not the same as <a>foldl</a> applied to the
--   reversed vector. Actually <a>foldr</a> starts processing with the
--   first element, and thus can be used for efficiently building a singly
--   linked list by <tt>foldr (:) [] vec</tt>. Unfortunately <a>foldr</a>
--   is quite slow for low-level loops, since GHC (up to 6.12.1) cannot
--   detect the loop.
foldr :: Storable a => (a -> b -> b) -> b -> Vector a -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>Vector</a>s It is a
--   checked error to pass an empty <a>Vector</a>.
foldr1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Concatenate a list of <a>Vector</a>s.
concat :: Storable a => [Vector a] -> Vector a

-- | Map a function over a <a>Vector</a> and concatenate the results
concatMap :: (Storable a, Storable b) => (a -> Vector b) -> Vector a -> Vector b

-- | This is like <tt>mconcat . map f</tt>, but in many cases the result of
--   <tt>f</tt> will not be storable.
monoidConcatMap :: (Storable a, Monoid m) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Applied to a predicate and a <a>Vector</a>, <a>any</a>
--   determines if any element of the <a>Vector</a> satisfies the
--   predicate.
any :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Applied to a predicate and a <a>Vector</a>, <a>all</a>
--   determines if all elements of the <a>Vector</a> satisfy the predicate.
all :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>Vector</a> This function will fuse. It is a checked error to pass
--   an empty <a>Vector</a>.
maximum :: (Storable a, Ord a) => Vector a -> a

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>Vector</a> This function will fuse. It is a checked error to pass
--   an empty <a>Vector</a>.
minimum :: (Storable a, Ord a) => Vector a -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left. This function will fuse.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument. This function will fuse.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | scanr is the right-to-left dual of scanl.
scanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   <a>Vector</a>, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   list.
mapAccumL :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   <a>Vector</a>, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   <a>Vector</a>.
mapAccumR :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)

-- | <i>O(n)</i> map functions, provided with the index at each position
mapIndexed :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a <a>Vector</a> of length
--   <tt>n</tt> with <tt>x</tt> the value of every element.
replicate :: Storable a => Int -> a -> Vector a

-- | <i>O(n)</i> <a>iterateN</a> <tt>n f x</tt> is a <a>Vector</a> of
--   length <tt>n</tt> where the elements of <tt>x</tt> are generated by
--   repeated application of <tt>f</tt>.
iterateN :: Storable a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a <a>Vector</a> from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the 'Vector or returns <a>Just</a> <tt>(a,b)</tt>, in which case,
--   <tt>a</tt> is the next element in the <a>Vector</a>, and <tt>b</tt> is
--   the seed value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: Storable b => (a -> Maybe (b, a)) -> a -> Vector b

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a
--   <a>Vector</a> from a seed value. However, the length of the result is
--   limited by the first argument to <a>unfoldrN</a>. This function is
--   more efficient than <a>unfoldr</a> when the maximum length of the
--   result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Storable b => Int -> (a -> Maybe (b, a)) -> a -> (Vector b, Maybe a)

-- | <i>O(n)</i> Like <a>unfoldrN</a> this function builds a <a>Vector</a>
--   from a seed value with limited size. Additionally it returns a value,
--   that depends on the state, but is not necessarily the state itself. If
--   end of vector and end of the generator coincide, then the result is as
--   if only the end of vector is reached.
--   
--   Example:
--   
--   <pre>
--   unfoldrResultN 30 Char.ord (\c -&gt; if c&gt;'z' then Left 1000 else Right (c, succ c)) 'a'
--   </pre>
--   
--   The following equation relates <a>unfoldrN</a> and
--   <a>unfoldrResultN</a>:
--   
--   <pre>
--   unfoldrN n f s ==
--      unfoldrResultN n Just
--         (maybe (Left Nothing) Right . f) s
--   </pre>
--   
--   It is not possible to express <a>unfoldrResultN</a> in terms of
--   <a>unfoldrN</a>.
unfoldrResultN :: Storable b => Int -> (a -> c) -> (a -> Either c (b, a)) -> a -> (Vector b, c)

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. This function
--   constructs a vector by evaluating a function that depends on the
--   element index. It is a special case of <a>unfoldrN</a> and can in
--   principle be parallelized.
--   
--   Examples:
--   
--   <pre>
--      sample 26 (\x -&gt; chr(ord 'a'+x))
--   == pack "abcdefghijklmnopqrstuvwxyz"
--   </pre>
sample :: Storable a => Int -> (Int -> a) -> Vector a

-- | <i>O(1)</i> <a>take</a> <tt>n</tt>, applied to a <a>Vector</a>
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <a>empty</a> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Storable a => Int -> Vector a -> (Vector a, Vector a)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   <a>Vector</a> <tt>xs</tt>, returns the longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <a>span</a> <tt>p xs</tt> breaks the <a>Vector</a> into two segments.
--   It is equivalent to <tt>(<a>takeWhile</a> p xs, <a>dropWhile</a> p
--   xs)</tt>
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <a>spanEnd</a> behaves like <a>span</a> but from the end of the
--   <a>Vector</a>. We have
--   
--   <pre>
--   spanEnd (not.isSpace) "x y z" == ("x y ","z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) ps
--      ==
--   let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
--   </pre>
spanEnd :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <a>breakEnd</a> behaves like <a>break</a> but from the end of the
--   <a>Vector</a>
--   
--   breakEnd p == spanEnd (not.p)
breakEnd :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | The <a>group</a> function takes a <a>Vector</a> and returns a list of
--   <a>Vector</a>s such that the concatenation of the result is equal to
--   the argument. Moreover, each sublist in the result contains only equal
--   elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test. It is about 40% faster than <i>groupBy
--   (==)</i>
group :: (Storable a, Eq a) => Vector a -> [Vector a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: Storable a => (a -> a -> Bool) -> Vector a -> [Vector a]

-- | <i>O(n)</i> Return all initial segments of the given <a>Vector</a>,
--   shortest first.
inits :: Storable a => Vector a -> [Vector a]

-- | <i>O(n)</i> Return all final segments of the given <a>Vector</a>,
--   longest first.
tails :: Storable a => Vector a -> [Vector a]

-- | <i>O(n)</i> Break a <a>Vector</a> into pieces separated by the
--   argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--   split 'a'  "aXaXaXa"    == ["","X","X","X"]
--   split 'x'  "x"          == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   join [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>Vector</a>s that are
--   slices of the original.
split :: (Storable a, Eq a) => a -> Vector a -> [Vector a]

-- | <i>O(n)</i> Splits a <a>Vector</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--   splitWith (=='a') []        == []
--   </pre>
splitWith :: Storable a => (a -> Bool) -> Vector a -> [Vector a]

-- | Like <a>splitWith</a>, except that sequences of adjacent separators
--   are treated as a single separator. eg.
--   
--   <pre>
--   tokens (=='a') "aabbaca" == ["bb","c"]
--   </pre>
tokens :: Storable a => (a -> Bool) -> Vector a -> [Vector a]

-- | <a>sliceVertical</a> <tt>n xs</tt> divides vector in chunks of size
--   <tt>n</tt>. Requires time proportionally to length of result list,
--   i.e. <tt>ceiling (length xs / n)</tt>.
sliceVertical :: Storable a => Int -> Vector a -> [Vector a]

-- | <i>O(n)</i> The <a>join</a> function takes a <a>Vector</a> and a list
--   of <a>Vector</a>s and concatenates the list after interspersing the
--   first argument between each element of the list.
join :: Storable a => Vector a -> [Vector a] -> Vector a

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two <a>Vector</a> and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: (Storable a, Eq a) => Vector a -> Vector a -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two <a>Vector</a>s
--   and returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: (Storable a, Eq a) => Vector a -> Vector a -> Bool

-- | <i>O(n)</i> <a>elem</a> is the <a>Vector</a> membership predicate.
elem :: (Storable a, Eq a) => a -> Vector a -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: (Storable a, Eq a) => a -> Vector a -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>Vector</a>, and returns the first element in matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p ! n) ; _ -&gt; Nothing
--   </pre>
find :: Storable a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a <a>Vector</a>,
--   returns a <a>Vector</a> containing those elements that satisfy the
--   predicate.
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(1)</i> <a>Vector</a> index (subscript) operator, starting from 0.
index :: Storable a => Vector a -> Int -> a

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>Vector</a> which is equal to the query
--   element, or <a>Nothing</a> if there is no such element.
elemIndex :: (Storable a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order.
elemIndices :: (Storable a, Eq a) => a -> Vector a -> [Int]

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>Vector</a> which is equal to the query
--   element, or <a>Nothing</a> if there is no such element. The following
--   holds:
--   
--   <pre>
--   elemIndexEnd c xs ==
--   (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--   </pre>
elemIndexEnd :: (Storable a, Eq a) => a -> Vector a -> Maybe Int

-- | The <a>findIndex</a> function takes a predicate and a <a>Vector</a>
--   and returns the index of the first element in the <a>Vector</a>
--   satisfying the predicate.
findIndex :: Storable a => (a -> Bool) -> Vector a -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: Storable a => (a -> Bool) -> Vector a -> [Int]

-- | count returns the number of times its argument appears in the
--   <a>Vector</a>
--   
--   <pre>
--   count = length . elemIndices
--   </pre>
--   
--   But more efficiently than using length on the intermediate list.
count :: (Storable a, Eq a) => a -> Vector a -> Int

-- | <a>findIndexOrEnd</a> is a variant of findIndex, that returns the
--   length of the string if no element is found, rather than Nothing.
findIndexOrEnd :: Storable a => (a -> Bool) -> Vector a -> Int

-- | <i>O(n)</i> <a>zip</a> takes two <a>Vector</a>s and returns a list of
--   corresponding pairs of elements. If one input <a>Vector</a> is short,
--   excess elements of the longer <a>Vector</a> are discarded. This is
--   equivalent to a pair of <a>unpack</a> operations.
zip :: (Storable a, Storable b) => Vector a -> Vector b -> [(a, b)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two <a>Vector</a>s
--   to produce the list of corresponding sums.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Like <a>zipWith</a> but for three input vectors
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d

-- | Like <a>zipWith</a> but for four input vectors If you need even more
--   input vectors, you might write a function yourselve using unfoldrN and
--   viewL.
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of elements into a
--   pair of <a>Vector</a>s. Note that this performs two <a>pack</a>
--   operations.
unzip :: (Storable a, Storable b) => [(a, b)] -> (Vector a, Vector b)

-- | <i>O(n)</i> Make a copy of the <a>Vector</a> with its own storage.
--   This is mainly useful to allow the rest of the data pointed to by the
--   <a>Vector</a> to be garbage collected, for example if a large string
--   has been read in, and only a small part of it is needed in the rest of
--   the program.
copy :: Storable a => Vector a -> Vector a

-- | <i>O(l</i>n)/ <a>sieve</a> selects every <tt>n</tt>th element.
sieve :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(n)</i> Returns n sieved vectors with successive starting
--   elements. <tt>deinterleave 3 (pack ['a'..'k']) = [pack "adgj", pack
--   "behk", pack "cfi"]</tt> This is the same as <a>sliceHorizontal</a>.
deinterleave :: Storable a => Int -> Vector a -> [Vector a]

-- | <i>O(n)</i> Almost the inverse of deinterleave. Restriction is that
--   all input vector must have equal length. <tt>interleave [pack "adgj",
--   pack "behk", pack "cfil"] = pack ['a'..'l']</tt>
interleave :: Storable a => [Vector a] -> Vector a

-- | Read a <a>Vector</a> directly from the specified <a>Handle</a>. This
--   is far more efficient than reading the characters into a list and then
--   using <a>pack</a>.
hGet :: Storable a => Handle -> Int -> IO (Vector a)

-- | Outputs a <a>Vector</a> to the specified <a>Handle</a>.
hPut :: Storable a => Handle -> Vector a -> IO ()

-- | Read an entire file strictly into a <a>Vector</a>. This is far more
--   efficient than reading the characters into a <a>String</a> and then
--   using <a>pack</a>. It also may be more efficient than opening the file
--   and reading it using hGet. Files are read using 'binary mode' on
--   Windows.
readFile :: Storable a => FilePath -> IO (Vector a)

-- | Write a <a>Vector</a> to a file.
writeFile :: Storable a => FilePath -> Vector a -> IO ()

-- | Append a <a>Vector</a> to a file.
appendFile :: Storable a => FilePath -> Vector a -> IO ()
instance (Storable a, Arbitrary a) => Arbitrary (Vector a)
instance Storable a => Monoid (Vector a)
instance (Storable a, Eq a) => Eq (Vector a)


-- | Chunky signal stream build on StorableVector.
--   
--   Hints for fusion: - Higher order functions should always be inlined in
--   the end in order to turn them into machine loops instead of calling a
--   function in an inner loop.
module Data.StorableVector.Lazy
newtype Vector a
SV :: [Vector a] -> Vector a
chunks :: Vector a -> [Vector a]
newtype ChunkSize
ChunkSize :: Int -> ChunkSize
chunkSize :: Int -> ChunkSize
defaultChunkSize :: ChunkSize
empty :: Storable a => Vector a
singleton :: Storable a => a -> Vector a
fromChunks :: Storable a => [Vector a] -> Vector a
pack :: Storable a => ChunkSize -> [a] -> Vector a
unpack :: Storable a => Vector a -> [a]
packWith :: Storable b => ChunkSize -> (a -> b) -> [a] -> Vector b
unpackWith :: Storable a => (a -> b) -> Vector a -> [b]
unfoldr :: Storable b => ChunkSize -> (a -> Maybe (b, a)) -> a -> Vector b

-- | Example:
--   
--   <pre>
--   *Data.StorableVector.Lazy&gt; unfoldrResult (ChunkSize 5) (\c -&gt; if c&gt;'z' then Left (Char.ord c) else Right (c, succ c)) 'a'
--   (VectorLazy.fromChunks [Vector.pack "abcde",Vector.pack "fghij",Vector.pack "klmno",Vector.pack "pqrst",Vector.pack "uvwxy",Vector.pack "z"],123)
--   </pre>
unfoldrResult :: Storable b => ChunkSize -> (a -> Either c (b, a)) -> a -> (Vector b, c)
sample :: Storable a => ChunkSize -> (Int -> a) -> Vector a
sampleN :: Storable a => ChunkSize -> Int -> (Int -> a) -> Vector a
iterate :: Storable a => ChunkSize -> (a -> a) -> a -> Vector a
repeat :: Storable a => ChunkSize -> a -> Vector a
cycle :: Storable a => Vector a -> Vector a
replicate :: Storable a => ChunkSize -> Int -> a -> Vector a
null :: Storable a => Vector a -> Bool
length :: Vector a -> Int
equal :: (Storable a, Eq a) => Vector a -> Vector a -> Bool
index :: Storable a => Vector a -> Int -> a
cons :: Storable a => a -> Vector a -> Vector a
append :: Storable a => Vector a -> Vector a -> Vector a

-- | <tt>extendL size x y</tt> prepends the chunk <tt>x</tt> and merges it
--   with the first chunk of <tt>y</tt> if the total size is at most
--   <tt>size</tt>. This way you can prepend small chunks while asserting a
--   reasonable average size for chunks.
extendL :: Storable a => ChunkSize -> Vector a -> Vector a -> Vector a
concat :: Storable a => [Vector a] -> Vector a
sliceVertical :: Storable a => Int -> Vector a -> [Vector a]
map :: (Storable x, Storable y) => (x -> y) -> Vector x -> Vector y
reverse :: Storable a => Vector a -> Vector a
foldl :: Storable b => (a -> b -> a) -> a -> Vector b -> a
foldl' :: Storable b => (a -> b -> a) -> a -> Vector b -> a
foldr :: Storable b => (b -> a -> a) -> a -> Vector b -> a
monoidConcatMap :: (Storable a, Monoid m) => (a -> m) -> Vector a -> m
any :: Storable a => (a -> Bool) -> Vector a -> Bool
all :: Storable a => (a -> Bool) -> Vector a -> Bool
maximum :: (Storable a, Ord a) => Vector a -> a
minimum :: (Storable a, Ord a) => Vector a -> a
pointer :: Storable a => Vector a -> Pointer a
viewL :: Storable a => Vector a -> Maybe (a, Vector a)
viewR :: Storable a => Vector a -> Maybe (Vector a, a)
switchL :: Storable a => b -> (a -> Vector a -> b) -> Vector a -> b
switchR :: Storable a => b -> (Vector a -> a -> b) -> Vector a -> b
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
mapAccumL :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)
mapAccumR :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)
crochetLChunk :: (Storable x, Storable y) => (x -> acc -> Maybe (y, acc)) -> acc -> Vector x -> (Vector y, Maybe acc)
crochetL :: (Storable x, Storable y) => (x -> acc -> Maybe (y, acc)) -> acc -> Vector x -> Vector y
take :: Storable a => Int -> Vector a -> Vector a

-- | Take n values from the end of the vector in a memory friendly way.
--   <tt>takeEnd n xs</tt> should perform the same as <tt>drop (length xs -
--   n) xs</tt>, but the latter one would have to materialise <tt>xs</tt>
--   completely. In contrast to that <tt>takeEnd</tt> should hold only
--   chunks of about <tt>n</tt> elements at any time point.
takeEnd :: Storable a => Int -> Vector a -> Vector a
drop :: Storable a => Int -> Vector a -> Vector a
splitAt :: Storable a => Int -> Vector a -> (Vector a, Vector a)

-- | <tt>dropMarginRem n m xs</tt> drops at most the first <tt>m</tt>
--   elements of <tt>xs</tt> and ensures that <tt>xs</tt> still contains
--   <tt>n</tt> elements. Additionally returns the number of elements that
--   could not be dropped due to the margin constraint. That is
--   <tt>dropMarginRem n m xs == (k,ys)</tt> implies <tt>length xs - m ==
--   length ys - k</tt>. Requires <tt>length xs &gt;= n</tt>.
dropMarginRem :: Storable a => Int -> Int -> Vector a -> (Int, Vector a)
dropMargin :: Storable a => Int -> Int -> Vector a -> Vector a
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | Generates laziness breaks wherever one of the input signals has a
--   chunk boundary.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e

-- | Preserves chunk pattern of the last argument.
zipWithLastPattern :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Preserves chunk pattern of the last argument.
zipWithLastPattern3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> (Vector a -> Vector b -> Vector c -> Vector d)

-- | Preserves chunk pattern of the last argument.
zipWithLastPattern4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> (Vector a -> Vector b -> Vector c -> Vector d -> Vector e)
zipWithSize :: (Storable a, Storable b, Storable c) => ChunkSize -> (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWithSize3 :: (Storable a, Storable b, Storable c, Storable d) => ChunkSize -> (a -> b -> c -> d) -> (Vector a -> Vector b -> Vector c -> Vector d)
zipWithSize4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => ChunkSize -> (a -> b -> c -> d -> e) -> (Vector a -> Vector b -> Vector c -> Vector d -> Vector e)
sieve :: Storable a => Int -> Vector a -> Vector a
deinterleave :: Storable a => Int -> Vector a -> [Vector a]

-- | Interleave lazy vectors while maintaining the chunk pattern of the
--   first vector. All input vectors must have the same length.
interleaveFirstPattern :: Storable a => [Vector a] -> Vector a

-- | Ensure a minimal length of the list by appending pad values.
pad :: Storable a => ChunkSize -> a -> Int -> Vector a -> Vector a
padAlt :: Storable a => ChunkSize -> a -> Int -> Vector a -> Vector a
cancelNullVector :: (Vector a, b) -> Maybe (Vector a, b)
fromChunk :: Storable a => Vector a -> Vector a

-- | Read the rest of a file lazily and provide the reason of termination
--   as IOError. If IOError is EOF (check with <tt>System.Error.isEOFError
--   err</tt>), then the file was read successfully. Only access the final
--   IOError after you have consumed the file contents, since finding out
--   the terminating reason forces to read the entire file. Make also sure
--   you read the file completely, because it is only closed when the file
--   end is reached (or an exception is encountered).
--   
--   TODO: In ByteString.Lazy the chunk size is reduced if data is not
--   immediately available. Maybe we should adapt that behaviour but when
--   working with realtime streams that may mean that the chunks are very
--   small.
hGetContentsAsync :: Storable a => ChunkSize -> Handle -> IO (IOError, Vector a)
hGetContentsSync :: Storable a => ChunkSize -> Handle -> IO (Vector a)
hPut :: Storable a => Handle -> Vector a -> IO ()

-- | The file can only closed after all values are consumed. That is you
--   must always assert that you consume all elements of the stream, and
--   that no values are missed due to lazy evaluation. This requirement
--   makes this function useless in many applications.
readFileAsync :: Storable a => ChunkSize -> FilePath -> IO (IOError, Vector a)
writeFile :: Storable a => FilePath -> Vector a -> IO ()
appendFile :: Storable a => FilePath -> Vector a -> IO ()
moduleError :: String -> String -> a
instance Eq ChunkSize
instance Ord ChunkSize
instance Show ChunkSize
instance C ChunkSize
instance Monoid ChunkSize
instance Num ChunkSize
instance Arbitrary ChunkSize
instance (Storable a, Arbitrary a) => Arbitrary (Vector a)
instance (Storable a, Show a) => Show (Vector a)
instance (Storable a, Eq a) => Eq (Vector a)
instance Storable a => Monoid (Vector a)


-- | In principle you can traverse through a lazy storable vector using
--   repeated calls to <tt>viewL</tt>. However this needs a bit of pointer
--   arrangement and allocation. This data structure makes the inner loop
--   faster, that consists of traversing through a chunk.
module Data.StorableVector.Lazy.Pointer
data Pointer a
cons :: Storable a => Vector a -> Pointer a
viewL :: Storable a => Pointer a -> Maybe (a, Pointer a)
switchL :: Storable a => b -> (a -> Pointer a -> b) -> Pointer a -> b


-- | Tested with : GHC 6.4.1
--   
--   Interface for access to a mutable StorableVector.
module Data.StorableVector.ST.Strict
data Vector s a
new :: Storable e => Int -> e -> ST s (Vector s e)
new_ :: Storable e => Int -> ST s (Vector s e)

-- | <pre>
--   Control.Monad.ST.runST (do arr &lt;- new_ 10; Monad.zipWithM_ (write arr) [9,8..0] ['a'..]; read arr 3)
--   </pre>
read :: Storable e => Vector s e -> Int -> ST s e

-- | <pre>
--   VS.unpack $ runSTVector (do arr &lt;- new_ 10; Monad.zipWithM_ (write arr) [9,8..0] ['a'..]; return arr)
--   </pre>
write :: Storable e => Vector s e -> Int -> e -> ST s ()

-- | <pre>
--   VS.unpack $ runSTVector (do arr &lt;- new 10 'a'; Monad.mapM_ (\n -&gt; modify arr (mod n 8) succ) [0..10]; return arr)
--   </pre>
modify :: Storable e => Vector s e -> Int -> (e -> e) -> ST s ()

-- | Returns <tt>Just e</tt>, when the element <tt>e</tt> could be read and
--   <a>Nothing</a> if the index was out of range. This way you can avoid
--   duplicate index checks that may be needed when using <a>read</a>.
--   
--   <pre>
--   Control.Monad.ST.runST (do arr &lt;- new_ 10; Monad.zipWithM_ (write arr) [9,8..0] ['a'..]; read arr 3)
--   </pre>
--   
--   In future <a>maybeRead</a> will replace <a>read</a>.
maybeRead :: Storable e => Vector s e -> Int -> ST s (Maybe e)

-- | Returns <a>True</a> if the element could be written and <a>False</a>
--   if the index was out of range.
--   
--   <pre>
--   runSTVector (do arr &lt;- new_ 10; foldr (\c go i -&gt; maybeWrite arr i c &gt;&gt;= \cont -&gt; if cont then go (succ i) else return arr) (error "unreachable") ['a'..] 0)
--   </pre>
--   
--   In future <a>maybeWrite</a> will replace <a>write</a>.
maybeWrite :: Storable e => Vector s e -> Int -> e -> ST s Bool

-- | Similar to <a>maybeWrite</a>.
--   
--   In future <a>maybeModify</a> will replace <a>modify</a>.
maybeModify :: Storable e => Vector s e -> Int -> (e -> e) -> ST s Bool
unsafeRead :: Storable e => Vector s e -> Int -> ST s e
unsafeWrite :: Storable e => Vector s e -> Int -> e -> ST s ()
unsafeModify :: Storable e => Vector s e -> Int -> (e -> e) -> ST s ()
freeze :: Storable e => Vector s e -> ST s (Vector e)

-- | This is like <a>freeze</a> but it does not copy the vector. You must
--   make sure that you never write again to the array. It is best to use
--   <a>unsafeFreeze</a> only at the end of a block, that is run by
--   <a>runST</a>.
unsafeFreeze :: Storable e => Vector s e -> ST s (Vector e)
thaw :: Storable e => Vector e -> ST s (Vector s e)
length :: Vector s e -> Int
runSTVector :: Storable e => (forall s. ST s (Vector s e)) -> Vector e

-- | <pre>
--   :module + Data.STRef
--   VS.unpack $ Control.Monad.ST.runST (do ref &lt;- newSTRef 'a'; mapST (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VS.pack [1,2,3,4::Data.Int.Int16]))
--   </pre>
mapST :: (Storable a, Storable b) => (a -> ST s b) -> Vector a -> ST s (Vector b)

-- | <pre>
--   *Data.StorableVector.ST.Strict Data.STRef&gt; VL.unpack $ Control.Monad.ST.runST (do ref &lt;- newSTRef 'a'; mapSTLazy (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VL.pack VL.defaultChunkSize [1,2,3,4::Data.Int.Int16]))
--   "abcd"
--   </pre>
--   
--   The following should not work on infinite streams, since we are in
--   <a>ST</a> with strict <a>&gt;&gt;=</a>. But it works. Why?
--   
--   <pre>
--   *Data.StorableVector.ST.Strict Data.STRef&gt; VL.unpack $ Control.Monad.ST.runST (do ref &lt;- newSTRef 'a'; mapSTLazy (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VL.pack VL.defaultChunkSize [0::Data.Int.Int16 ..]))
--   "Interrupted.
--   </pre>
mapSTLazy :: (Storable a, Storable b) => (a -> ST s b) -> Vector a -> ST s (Vector b)


-- | Build a lazy storable vector by incrementally adding an element. This
--   is analogous to Data.Binary.Builder for Data.ByteString.Lazy.
--   
--   Attention: This implementation is still almost 3 times slower than
--   constructing a lazy storable vector using unfoldr in our Chorus speed
--   test.
module Data.StorableVector.Lazy.Builder
data Builder a

-- | <pre>
--   toLazyStorableVector (ChunkSize 7) $ Data.Monoid.mconcat $ map put ['a'..'z']
--   </pre>
toLazyStorableVector :: Storable a => ChunkSize -> Builder a -> Vector a
put :: Storable a => a -> Builder a

-- | Set a laziness break.
flush :: Storable a => Builder a
instance Storable a => Monoid (Builder a)


-- | Functions for <tt>StorableVector</tt> that allow control of the size
--   of individual chunks.
--   
--   This is import for an application like the following: You want to mix
--   audio signals that are relatively shifted. The structure of chunks of
--   three streams may be illustrated as:
--   
--   <pre>
--   [____] [____] [____] [____] ...
--     [____] [____] [____] [____] ...
--       [____] [____] [____] [____] ...
--   </pre>
--   
--   When we mix the streams (<tt>zipWith3 (x y z -&gt; x+y+z)</tt>) with
--   respect to the chunk structure of the first signal, computing the
--   first chunk requires full evaluation of all leading chunks of the
--   stream. However the last value of the third leading chunk is much
--   later in time than the last value of the first leading chunk. We like
--   to reduce these dependencies using a different chunk structure, say
--   
--   <pre>
--   [____] [____] [____] [____] ...
--     [__] [____] [____] [____] ...
--       [] [____] [____] [____] ...
--   </pre>
module Data.StorableVector.Lazy.Pattern
data Vector a
data ChunkSize
chunkSize :: Int -> ChunkSize
defaultChunkSize :: ChunkSize
type LazySize = T ChunkSize
empty :: Storable a => Vector a
singleton :: Storable a => a -> Vector a
pack :: Storable a => LazySize -> [a] -> Vector a
unpack :: Storable a => Vector a -> [a]
packWith :: Storable b => LazySize -> (a -> b) -> [a] -> Vector b
unpackWith :: Storable a => (a -> b) -> Vector a -> [b]
unfoldrN :: Storable b => LazySize -> (a -> Maybe (b, a)) -> a -> (Vector b, Maybe a)
iterateN :: Storable a => LazySize -> (a -> a) -> a -> Vector a
cycle :: Storable a => Vector a -> Vector a
replicate :: Storable a => LazySize -> a -> Vector a
null :: Storable a => Vector a -> Bool
length :: Vector a -> LazySize
cons :: Storable a => a -> Vector a -> Vector a
append :: Storable a => Vector a -> Vector a -> Vector a
concat :: Storable a => [Vector a] -> Vector a
map :: (Storable x, Storable y) => (x -> y) -> Vector x -> Vector y
reverse :: Storable a => Vector a -> Vector a
foldl :: Storable b => (a -> b -> a) -> a -> Vector b -> a
foldl' :: Storable b => (a -> b -> a) -> a -> Vector b -> a
any :: Storable a => (a -> Bool) -> Vector a -> Bool
all :: Storable a => (a -> Bool) -> Vector a -> Bool
maximum :: (Storable a, Ord a) => Vector a -> a
minimum :: (Storable a, Ord a) => Vector a -> a
viewL :: Storable a => Vector a -> Maybe (a, Vector a)
viewR :: Storable a => Vector a -> Maybe (Vector a, a)
switchL :: Storable a => b -> (a -> Vector a -> b) -> Vector a -> b
switchR :: Storable a => b -> (Vector a -> a -> b) -> Vector a -> b
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a
mapAccumL :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)
mapAccumR :: (Storable a, Storable b) => (acc -> a -> (acc, b)) -> acc -> Vector a -> (acc, Vector b)
crochetL :: (Storable x, Storable y) => (x -> acc -> Maybe (y, acc)) -> acc -> Vector x -> Vector y

-- | Generates laziness breaks wherever either the lazy length number or
--   the vector has a chunk boundary.
take :: Storable a => LazySize -> Vector a -> Vector a
drop :: Storable a => LazySize -> Vector a -> Vector a
splitAt :: Storable a => LazySize -> Vector a -> (Vector a, Vector a)

-- | Preserves the chunk pattern of the lazy vector.
takeVectorPattern :: Storable a => LazySize -> Vector a -> Vector a
splitAtVectorPattern :: Storable a => LazySize -> Vector a -> (Vector a, Vector a)

-- | <tt>dropMarginRem n m xs</tt> drops at most the first <tt>m</tt>
--   elements of <tt>xs</tt> and ensures that <tt>xs</tt> still contains
--   <tt>n</tt> elements. Additionally returns the number of elements that
--   could not be dropped due to the margin constraint. That is
--   <tt>dropMarginRem n m xs == (k,ys)</tt> implies <tt>length xs - m ==
--   length ys - k</tt>. Requires <tt>length xs &gt;= n</tt>.
dropMarginRem :: Storable a => Int -> Int -> Vector a -> (Int, Vector a)
dropMargin :: Storable a => Int -> Int -> Vector a -> Vector a
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | Generates laziness breaks wherever one of the input signals has a
--   chunk boundary.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWithSize :: (Storable a, Storable b, Storable c) => LazySize -> (a -> b -> c) -> Vector a -> Vector b -> Vector c
zipWithSize3 :: (Storable a, Storable b, Storable c, Storable d) => LazySize -> (a -> b -> c -> d) -> (Vector a -> Vector b -> Vector c -> Vector d)
zipWithSize4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => LazySize -> (a -> b -> c -> d -> e) -> (Vector a -> Vector b -> Vector c -> Vector d -> Vector e)


-- | Tested with : GHC 6.4.1
--   
--   Interface for access to a mutable StorableVector.
module Data.StorableVector.ST.Lazy
data Vector s a
new :: Storable e => Int -> e -> ST s (Vector s e)
new_ :: Storable e => Int -> ST s (Vector s e)

-- | <pre>
--   Control.Monad.ST.runST (do arr &lt;- new_ 10; Monad.zipWithM_ (write arr) [9,8..0] ['a'..]; read arr 3)
--   </pre>
read :: Storable e => Vector s e -> Int -> ST s e

-- | <pre>
--   VS.unpack $ runSTVector (do arr &lt;- new_ 10; Monad.zipWithM_ (write arr) [9,8..0] ['a'..]; return arr)
--   </pre>
write :: Storable e => Vector s e -> Int -> e -> ST s ()
modify :: Storable e => Vector s e -> Int -> (e -> e) -> ST s ()
unsafeRead :: Storable e => Vector s e -> Int -> ST s e
unsafeWrite :: Storable e => Vector s e -> Int -> e -> ST s ()
unsafeModify :: Storable e => Vector s e -> Int -> (e -> e) -> ST s ()
freeze :: Storable e => Vector s e -> ST s (Vector e)
unsafeFreeze :: Storable e => Vector s e -> ST s (Vector e)
thaw :: Storable e => Vector e -> ST s (Vector s e)
length :: Vector s e -> Int
runSTVector :: Storable e => (forall s. ST s (Vector s e)) -> Vector e

-- | <pre>
--   :module + Data.STRef
--   VS.unpack $ Control.Monad.ST.runST (do ref &lt;- newSTRef 'a'; mapST (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VS.pack [1,2,3,4::Data.Int.Int16]))
--   </pre>
mapST :: (Storable a, Storable b) => (a -> ST s b) -> Vector a -> ST s (Vector b)

-- | <pre>
--   *Data.StorableVector.ST.Strict Data.STRef&gt; VL.unpack $ Control.Monad.ST.runST (do ref &lt;- newSTRef 'a'; mapSTLazy (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VL.pack VL.defaultChunkSize [1,2,3,4::Data.Int.Int16]))
--   "abcd"
--   </pre>
--   
--   The following should not work on infinite streams, since we are in
--   <a>ST</a> with strict <a>&gt;&gt;=</a>. But it works. Why?
--   
--   <pre>
--   *Data.StorableVector.ST.Strict Data.STRef.Lazy&gt; VL.unpack $ Control.Monad.ST.Lazy.runST (do ref &lt;- newSTRef 'a'; mapSTLazy (\ _n -&gt; do c &lt;- readSTRef ref; modifySTRef ref succ; return c) (VL.pack VL.defaultChunkSize [0::Data.Int.Int16 ..]))
--   "Interrupted.
--   </pre>
mapSTLazy :: (Storable a, Storable b) => (a -> ST s b) -> Vector a -> ST s (Vector b)
