-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Datatype-generic rewriting with preconditions
--   
--   This package provides rewriting functionality for datatypes. Most
--   forms of datatypes are supported, including parametrized and
--   mutually-recursive.
--   
--   This library has been described in the paper:
--   
--   <ul>
--   <li>Thomas van Noort, Alexey Rodriguez Yakushev, Stefan Holdermans,
--   Johan Jeuring, Bastiaan Heeren, Jose Pedro Magalhaes. <i>A Lightweight
--   Approach to Datatype-Generic Rewriting.</i> Journal of Functional
--   Programming, Special Issue on Generic Programming, 2010.</li>
--   </ul>
--   
--   More information about this library can be found at
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/GuardedRewriting</a>.
@package guarded-rewriting
@version 0.1


-- | This is the top module for the rewriting library. All functionality is
--   implemented in this module. For examples of how to use the library,
--   see the included files in the directory examples, or the benchmark in
--   the directory performance.
module Generics.Instant.Rewriting

-- | The <a>Rewritable</a> class is used to signal types that can be
--   rewritten and to ``tie the recursive knot'' of the generic functions.
class (Representable a, Typeable a, Eq a, Empty (Rep a), Extensible (Rep a), Matchable (Rep a), Substitutable (Rep a), Sampleable (Rep a), Diffable (Rep a), Validatable (Rep a)) => Rewritable a

-- | Rewrite a term. The term is unchanged if the rule cannot be applied.
rewrite :: Rewritable a => Rule a -> a -> a

-- | Rewrite a term. Monad <a>fail</a> is used if the rule cannot be
--   applied.
rewriteM :: (Rewritable a, Monad m) => Rule a -> a -> m a

-- | Validate a rewrite rule
validate :: Rewritable a => Rule a -> Bool

-- | Synthesise a function into a rewrite rule
synthesise :: (IsRule a, Nillable (Env a), Recordable (Env a), Testable (Env a), (FiniteEnv (Env a)) ~ True) => a -> Rule (Obj a)

-- | Templates
data Template a
Template :: a -> a -> Bool -> Template a
(+->) :: a -> a -> Template a
(//) :: Template a -> Bool -> Template a

-- | Rules
data Rule a

-- | Schemes
class Extensible a where { data family Ext a :: * -> *; }
toExt :: Extensible a => a -> Ext a U

-- | Matching
class Matchable a
match' :: (Matchable a, Nillable gam, Monad m) => Ext a gam -> a -> m (Subst gam)

-- | Substituting
class Substitutable a
subst' :: (Substitutable a, Monad m) => Subst gam -> Ext a gam -> m a

-- | Sampling
class Sampleable a
left' :: Sampleable a => a
right' :: Sampleable a => a

-- | Type level validation for the datatypes to be rewritten: there can be
--   no recursive calls on the leftmost constructor
class Empty a
empty' :: Empty a => a
class HasRec a
hasRec' :: HasRec a => a -> Bool
data True
data False

-- | Diff
class Diffable a
diff' :: (Diffable a, Typeable b) => Ext a gam -> Ext a gam -> Maybe (Ext a (b :*: gam))

-- | Validating synthesised rules
class Validatable a
record :: Validatable a => Ext a gam -> Record gam -> Record gam
class Nillable gam
empty :: Nillable gam => Subst gam

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a
instance [overlap ok] HasRec Char
instance [overlap ok] HasRec Float
instance [overlap ok] HasRec Int
instance [overlap ok] HasRec (Rec a)
instance [overlap ok] HasRec a => HasRec (C c a)
instance [overlap ok] (HasRec a, HasRec b) => HasRec (a :+: b)
instance [overlap ok] (HasRec a, HasRec b) => HasRec (a :*: b)
instance [overlap ok] HasRec (Var a)
instance [overlap ok] HasRec U
instance [overlap ok] Empty Char
instance [overlap ok] Empty Float
instance [overlap ok] Empty Int
instance [overlap ok] Rewritable a => Empty (Rec a)
instance [overlap ok] Rewritable a => Empty (Var a)
instance [overlap ok] Empty a => Empty (C c a)
instance [overlap ok] (Empty a, Empty b) => Empty (a :*: b)
instance [overlap ok] (HasRec a, Empty a, Empty b) => Empty (a :+: b)
instance [overlap ok] Empty U
instance [overlap ok] Validatable a => Validatable (C c a)
instance [overlap ok] Rewritable a => Validatable (Var a)
instance [overlap ok] Rewritable a => Validatable (Rec a)
instance [overlap ok] (Validatable a, Validatable b) => Validatable (a :*: b)
instance [overlap ok] (Validatable a, Validatable b) => Validatable (a :+: b)
instance [overlap ok] Validatable U
instance [overlap ok] Validatable Char
instance [overlap ok] Validatable Float
instance [overlap ok] Validatable Int
instance [overlap ok] Recordable gam => Recordable (a :*: gam)
instance [overlap ok] Recordable U
instance [overlap ok] (Rewritable a, IsRule b) => IsRule (a -> b)
instance [overlap ok] Rewritable a => IsRule (Template a)
instance [overlap ok] Diffable a => Diffable (C c a)
instance [overlap ok] Rewritable a => Diffable (Var a)
instance [overlap ok] Rewritable a => Diffable (Rec a)
instance [overlap ok] Diffable U
instance [overlap ok] (Diffable a, Diffable b) => Diffable (a :*: b)
instance [overlap ok] (Diffable a, Diffable b) => Diffable (a :+: b)
instance [overlap ok] Diffable Float
instance [overlap ok] Diffable Char
instance [overlap ok] Diffable Int
instance [overlap ok] Sampleable a => Sampleable (C c a)
instance [overlap ok] Rewritable a => Sampleable (Var a)
instance [overlap ok] Rewritable a => Sampleable (Rec a)
instance [overlap ok] Sampleable U
instance [overlap ok] (Sampleable a, Sampleable b) => Sampleable (a :*: b)
instance [overlap ok] (Representable a, Empty (Rep a), Representable b, Empty (Rep b)) => Sampleable (a :+: b)
instance [overlap ok] Sampleable Float
instance [overlap ok] Bounded a => Sampleable a
instance [overlap ok] Testable gam => Testable (a :*: gam)
instance [overlap ok] Testable U
instance [overlap ok] Substitutable a => Substitutable (C c a)
instance [overlap ok] Rewritable a => Substitutable (Var a)
instance [overlap ok] Rewritable a => Substitutable (Rec a)
instance [overlap ok] Substitutable U
instance [overlap ok] (Substitutable a, Substitutable b) => Substitutable (a :*: b)
instance [overlap ok] (Substitutable a, Substitutable b) => Substitutable (a :+: b)
instance [overlap ok] Substitutable Float
instance [overlap ok] Substitutable Char
instance [overlap ok] Substitutable Int
instance [overlap ok] Matchable a => Matchable (C c a)
instance [overlap ok] Rewritable a => Matchable (Rec a)
instance [overlap ok] Rewritable a => Matchable (Var a)
instance [overlap ok] Matchable U
instance [overlap ok] (Matchable a, Matchable b) => Matchable (a :*: b)
instance [overlap ok] (Matchable a, Matchable b) => Matchable (a :+: b)
instance [overlap ok] Matchable Float
instance [overlap ok] Matchable Char
instance [overlap ok] Matchable Int
instance [overlap ok] (Rewritable a, Nillable gam) => Nillable (a :*: gam)
instance [overlap ok] Nillable U
instance [overlap ok] Extensible a => Extensible (C c a)
instance [overlap ok] Rewritable a => Extensible (Var a)
instance [overlap ok] Rewritable a => Extensible (Rec a)
instance [overlap ok] Extensible U
instance [overlap ok] (Extensible a, Extensible b) => Extensible (a :*: b)
instance [overlap ok] (Extensible a, Extensible b) => Extensible (a :+: b)
instance [overlap ok] Extensible Char
instance [overlap ok] Extensible Float
instance [overlap ok] Extensible Int
instance [overlap ok] Rewritable Char
instance [overlap ok] Rewritable Float
instance [overlap ok] Rewritable Int
instance [overlap ok] Eq (Ref a gam)
