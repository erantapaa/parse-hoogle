-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A portable and extensible sockets library.
--   
@package socket
@version 0.5.2.0

module System.Socket.Protocol
class Protocol p
protocolNumber :: Protocol p => p -> CInt
instance Protocol ()

module System.Socket.Protocol.UDP
data UDP
instance Protocol UDP

module System.Socket.Protocol.TCP
data TCP
instance Protocol TCP

module System.Socket.Type
class Type t
typeNumber :: Type t => t -> CInt

module System.Socket.Type.Datagram
data Datagram
instance Type Datagram

module System.Socket.Type.Raw
data Raw
instance Type Raw

module System.Socket.Type.SequentialPacket
data SequentialPacket
instance Type SequentialPacket

module System.Socket.Type.Stream
data Stream
instance Type Stream

module System.Socket.Family
class Storable (SocketAddress f) => Family f where type family SocketAddress f
familyNumber :: Family f => f -> CInt

module System.Socket.Unsafe
unsafeSend :: Socket a t p -> Ptr a -> CSize -> MessageFlags -> IO CInt
unsafeSendTo :: Socket f t p -> Ptr b -> CSize -> MessageFlags -> Ptr (SocketAddress f) -> CInt -> IO CInt
unsafeReceive :: Socket a t p -> Ptr b -> CSize -> MessageFlags -> IO CInt
unsafeReceiveFrom :: Socket f t p -> Ptr b -> CSize -> MessageFlags -> Ptr (SocketAddress f) -> Ptr CInt -> IO CInt
unsafeGetSocketOption :: Storable a => Socket f t p -> CInt -> CInt -> IO a
unsafeSetSocketOption :: Storable a => Socket f t p -> CInt -> CInt -> a -> IO ()

-- | Blocks until a socket should be tried for reading.
--   
--   <pre>
--   safeSocketWaitRead = do
--     wait &lt;- withMVar msock $ \sock-&gt; do
--       -- Register while holding a lock on the socket descriptor.
--       unsafeSocketWaitRead sock 0 
--     -- Do the waiting without keeping the socket descriptor locked.
--     wait
--   </pre>
unsafeSocketWaitRead :: Fd -> Int -> IO (IO ())
unsafeSocketWaitWrite :: Fd -> Int -> IO (IO ())
tryWaitRetryLoop :: Socket f t p -> (Fd -> Int -> IO (IO ())) -> (Fd -> IO CInt) -> IO CInt

module System.Socket.Family.Inet
data Inet
data SocketAddressInet
SocketAddressInet :: Address -> Port -> SocketAddressInet
address :: SocketAddressInet -> Address
port :: SocketAddressInet -> Port

-- | To avoid errors with endianess it was decided to keep this type
--   abstract.
--   
--   Hint: Use the <a>Storable</a> instance if you really need to access.
--   It exposes it exactly as found within an IP packet (big endian if you
--   insist on interpreting it as a number).
--   
--   Another hint: Use <a>getAddressInfo</a> for parsing and suppress
--   nameserver lookups:
--   
--   <pre>
--   &gt; getAddressInfo (Just "127.0.0.1") Nothing aiNumericHost :: IO [AddressInfo Inet Stream TCP]
--   [AddressInfo {addressInfoFlags = AddressInfoFlags 4, socketAddress = SocketAddressInet { address = 127.0.0.1, port = 0}, canonicalName = Nothing}]
--   </pre>
data Address
newtype Port
Port :: Word16 -> Port

-- | <pre>
--   224.0.0.1
--   </pre>
allHostsGroup :: Address

-- | <pre>
--   0.0.0.0
--   </pre>
any :: Address

-- | <pre>
--   255.255.255.255
--   </pre>
broadcast :: Address

-- | <pre>
--   127.0.0.1
--   </pre>
loopback :: Address

-- | <pre>
--   224.0.0.255
--   </pre>
maxLocalGroup :: Address

-- | <pre>
--   255.255.255.255
--   </pre>
none :: Address

-- | <pre>
--   224.0.0.0
--   </pre>
unspecificGroup :: Address
instance Eq Port
instance Ord Port
instance Num Port
instance Eq Address
instance Eq SocketAddressInet
instance Show SocketAddressInet
instance Storable SocketAddressInet
instance Storable Address
instance Show Address
instance Show Port
instance Family Inet

module System.Socket.Family.Inet6
data Inet6

-- | Example:
--   
--   <pre>
--   SocketAddressInet6 loopback 8080 mempty 0
--   </pre>
data SocketAddressInet6
SocketAddressInet6 :: Address -> Port -> FlowInfo -> ScopeId -> SocketAddressInet6
address :: SocketAddressInet6 -> Address
port :: SocketAddressInet6 -> Port
flowInfo :: SocketAddressInet6 -> FlowInfo
scopeId :: SocketAddressInet6 -> ScopeId

-- | To avoid errors with endianess it was decided to keep this type
--   abstract.
--   
--   Hint: Use the <a>Storable</a> instance if you really need to access.
--   It exposes it exactly as found within an IP packet (big endian if you
--   insist on interpreting it as a number).
--   
--   Another hint: Use <a>getAddressInfo</a> for parsing and suppress
--   nameserver lookups:
--   
--   <pre>
--   &gt; getAddressInfo (Just "::1") Nothing aiNumericHost :: IO [AddressInfo SocketAddressInet6 Stream TCP]
--   [AddressInfo {
--      addressInfoFlags = AddressInfoFlags 4, 
--      socketAddress    = SocketAddressInet6 {address = 0000:0000:0000:0000:0000:0000:0000:0001, port = 0, flowInfo = mempty, scopeId = 0},
--      canonicalName    = Nothing }]
--   </pre>
data Address
newtype Port
Port :: Word16 -> Port
newtype FlowInfo
FlowInfo :: Word32 -> FlowInfo
newtype ScopeId
ScopeId :: Word32 -> ScopeId

-- | <pre>
--   ::
--   </pre>
any :: Address

-- | <pre>
--   ::1
--   </pre>
loopback :: Address

-- | <pre>
--   IPV6_V6ONLY
--   </pre>
data V6Only
V6Only :: Bool -> V6Only
instance Eq Port
instance Ord Port
instance Num Port
instance Eq Address
instance Eq FlowInfo
instance Ord FlowInfo
instance Bits FlowInfo
instance Eq ScopeId
instance Ord ScopeId
instance Num ScopeId
instance Eq SocketAddressInet6
instance Show SocketAddressInet6
instance Eq V6Only
instance Ord V6Only
instance Show V6Only
instance SetSocketOption V6Only
instance GetSocketOption V6Only
instance Storable SocketAddressInet6
instance Storable Address
instance Show Address
instance Show ScopeId
instance Monoid FlowInfo
instance Show FlowInfo
instance Show Port
instance Family Inet6


-- | This starts a TCP server on localhost, sends <tt>"Hello world!"</tt>
--   to connecting peers and closes the connection immediately.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   module Main where
--   
--   import System.Socket
--   import System.Socket.Family.Inet as Inet
--   import Data.Monoid
--   import Data.ByteString
--   import Control.Monad
--   import Control.Concurrent
--   import Control.Exception
--   
--   main :: IO ()
--   main = do
--     s &lt;- socket :: IO (Socket Inet Stream TCP)
--     setSocketOption s (ReuseAddress True)
--     bind s addr
--     listen s 5
--     forever $ do
--       (peer,_) &lt;- accept s
--       forkIO $ do
--         sendAll peer "Hello world!" msgNoSignal `finally` close peer
--     where
--       addr = SocketAddressInet Inet.loopback 8080
--   </pre>
--   
--   This downloads the Haskell website and prints it to stdout. Note the
--   use of IPv4-mapped <a>Inet6</a> addresses: This will work even if you
--   don't have IPv6 connectivity yet and is the preferred method when
--   writing new applications.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   module Main where
--   
--   import Data.Monoid
--   import Data.ByteString.Lazy as B
--   import System.Socket
--   
--   main :: IO ()
--   main = do
--     withConnectedSocket "www.haskell.org" "80" (aiAll `mappend` aiV4Mapped) $ \sock-&gt; do
--       let _ = sock :: Socket Inet6 Stream TCP
--       sendAll sock "GET / HTTP/1.0\r\nHost: www.haskell.org\r\n\r\n" msgNoSignal
--       x &lt;- receiveAll sock (1024*1024*1024) mempty
--       B.putStr x
--   </pre>
module System.Socket
data AddressInfo f t p
AddressInfo :: AddressInfoFlags -> SocketAddress f -> Maybe ByteString -> AddressInfo f t p
addressInfoFlags :: AddressInfo f t p -> AddressInfoFlags
socketAddress :: AddressInfo f t p -> SocketAddress f
canonicalName :: AddressInfo f t p -> Maybe ByteString
class Family f => GetAddressInfo f
getAddressInfo :: (GetAddressInfo f, Type t, Protocol p) => Maybe ByteString -> Maybe ByteString -> AddressInfoFlags -> IO [AddressInfo f t p]

-- | Maps addresss to readable host- and service names.
--   
--   The operation throws <a>AddressInfoException</a>s.
--   
--   <pre>
--   &gt; getNameInfo (SocketAddressInet loopback 80) mempty
--   ("localhost.localdomain","http")
--   </pre>
class Family f => GetNameInfo f
getNameInfo :: GetNameInfo f => SocketAddress f -> NameInfoFlags -> IO (ByteString, ByteString)

-- | Creates a new socket.
--   
--   Whereas the underlying POSIX socket operation takes 3 parameters, this
--   library encodes this information in the type variables. This rules out
--   several kinds of errors and escpecially simplifies the handling of
--   addresses (by using associated type families). Examples:
--   
--   <pre>
--   -- create a IPv4-UDP-datagram socket
--   sock &lt;- socket :: IO (Socket Inet Datagram UDP)
--   -- create a IPv6-TCP-streaming socket
--   sock6 &lt;- socket :: IO (Socket Inet6 Stream TCP)
--   </pre>
--   
--   <ul>
--   <li>This operation sets up a finalizer that automatically closes the
--   socket when the garbage collection decides to collect it. This is just
--   a fail-safe. You might still run out of file descriptors as there's no
--   guarantee about when the finalizer is run. You're advised to manually
--   <a>close</a> the socket when it's no longer needed. If possible, use
--   <a>bracket</a> to reliably close the socket descriptor on exception or
--   regular termination of your computation:<pre>result &lt;- bracket
--   (socket :: IO (Socket Inet6 Stream TCP)) close $ \sock-&gt; do
--   somethingWith sock -- your computation here return
--   somethingelse</pre></li>
--   <li>This operation configures the socket non-blocking to work
--   seamlessly with the runtime system's event notification
--   mechanism.</li>
--   <li>This operation can safely deal with asynchronous exceptions
--   without leaking file descriptors.</li>
--   <li>This operation throws <a>SocketException</a>s. Consult your
--   <tt>man</tt> page for details and specific <tt>errno</tt>s.</li>
--   </ul>
socket :: (Family f, Type t, Protocol p) => IO (Socket f t p)

-- | Connects to an remote address.
--   
--   <ul>
--   <li>Calling <a>connect</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>This operation returns as soon as a connection has been
--   established (as if the socket were blocking). The connection attempt
--   has either failed or succeeded after this operation threw an exception
--   or returned.</li>
--   <li>The operation might throw <a>SocketException</a>s. Due to
--   implementation quirks the socket should be considered in an undefined
--   state when this operation failed. It should be closed then.</li>
--   <li>Also see [these
--   considerations](http:/<i>cr.yp.to</i>docs/connect.html) on the
--   problems with connecting non-blocking sockets.</li>
--   </ul>
connect :: Family f => Socket f t p -> SocketAddress f -> IO ()

-- | Bind a socket to an address.
--   
--   <ul>
--   <li>Calling <a>bind</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>It is assumed that <a>c_bind</a> never blocks and therefore
--   <a>eInProgress</a>, <a>eAlready</a> and <a>eInterrupted</a> don't
--   occur. This assumption is supported by the fact that the Linux manpage
--   doesn't mention any of these errors, the Posix manpage doesn't mention
--   the last one and even MacOS' implementation will never fail with any
--   of these when the socket is configured non-blocking as [argued
--   here](http:/<i>stackoverflow.com</i>a/14485305).</li>
--   <li>This operation throws <a>SocketException</a>s. Consult your
--   <tt>man</tt> page for details and specific <tt>errno</tt>s.</li>
--   </ul>
bind :: Family f => Socket f t p -> SocketAddress f -> IO ()

-- | Starts listening and queueing connection requests on a connection-mode
--   socket.
--   
--   <ul>
--   <li>Calling <a>listen</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>The second parameter is called <i>backlog</i> and sets a limit on
--   how many unaccepted connections the socket implementation shall queue.
--   A value of <tt>0</tt> leaves the decision to the implementation.</li>
--   <li>This operation throws <a>SocketException</a>s. Consult your
--   <tt>man</tt> page for details and specific <tt>errno</tt>s.</li>
--   </ul>
listen :: Socket f t p -> Int -> IO ()

-- | Accept a new connection.
--   
--   <ul>
--   <li>Calling <a>accept</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>This operation configures the new socket non-blocking (TODO: use
--   <tt>accept4</tt> if available).</li>
--   <li>This operation sets up a finalizer for the new socket that
--   automatically closes the new socket when the garbage collection
--   decides to collect it. This is just a fail-safe. You might still run
--   out of file descriptors as there's no guarantee about when the
--   finalizer is run. You're advised to manually <a>close</a> the socket
--   when it's no longer needed.</li>
--   <li>This operation throws <a>SocketException</a>s. Consult your
--   <tt>man</tt> page for details and specific <tt>errno</tt>s.</li>
--   <li>This operation catches <a>eAgain</a>, <a>eWouldBlock</a> and
--   <a>eInterrupted</a> internally and retries automatically.</li>
--   </ul>
accept :: Family f => Socket f t p -> IO (Socket f t p, SocketAddress f)

-- | Send a message on a connected socket.
--   
--   <ul>
--   <li>Calling <a>send</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>The operation returns the number of bytes sent. On <a>Datagram</a>
--   and <a>SequentialPacket</a> sockets certain assurances on atomicity
--   exist and <a>eAgain</a> or <a>eWouldBlock</a> are returned until the
--   whole message would fit into the send buffer.</li>
--   <li>This operation throws <a>SocketException</a>s. Consult <tt>man 3p
--   send</tt> for details and specific <tt>errno</tt>s.</li>
--   <li><a>eAgain</a>, <a>eWouldBlock</a> and <a>eInterrupted</a> and
--   handled internally and won't be thrown. For performance reasons the
--   operation first tries a write on the socket and then waits when it got
--   <a>eAgain</a> or <a>eWouldBlock</a>.</li>
--   </ul>
send :: Socket f t p -> ByteString -> MessageFlags -> IO Int

-- | Like <a>send</a>, but allows for specifying a destination address.
sendTo :: Family f => Socket f t p -> ByteString -> MessageFlags -> SocketAddress f -> IO Int

-- | Receive a message on a connected socket.
--   
--   <ul>
--   <li>Calling <a>receive</a> on a <a>close</a>d socket throws
--   <a>eBadFileDescriptor</a> even if the former file descriptor has been
--   reassigned.</li>
--   <li>The operation takes a buffer size in bytes a first parameter which
--   limits the maximum length of the returned <a>ByteString</a>.</li>
--   <li>This operation throws <a>SocketException</a>s. Consult <tt>man 3p
--   receive</tt> for details and specific <tt>errno</tt>s.</li>
--   <li><a>eAgain</a>, <a>eWouldBlock</a> and <a>eInterrupted</a> and
--   handled internally and won't be thrown. For performance reasons the
--   operation first tries a read on the socket and then waits when it got
--   <a>eAgain</a> or <a>eWouldBlock</a>.</li>
--   </ul>
receive :: Socket f t p -> Int -> MessageFlags -> IO ByteString

-- | Like <a>receive</a>, but additionally yields the peer address.
receiveFrom :: Family f => Socket f t p -> Int -> MessageFlags -> IO (ByteString, SocketAddress f)

-- | Closes a socket.
--   
--   <ul>
--   <li>This operation is idempotent and thus can be performed more than
--   once without throwing an exception. If it throws an exception it is
--   presumably a not recoverable situation and the process should
--   exit.</li>
--   <li>This operation does not block.</li>
--   <li>This operation wakes up all threads that are currently blocking on
--   this socket. All other threads are guaranteed not to block on
--   operations on this socket in the future. Threads that perform
--   operations other than <a>close</a> on this socket will fail with
--   <a>eBadFileDescriptor</a> after the socket has been closed
--   (<a>close</a> replaces the <a>Fd</a> in the <a>MVar</a> with
--   <tt>-1</tt> to reliably avoid use-after-free situations).</li>
--   <li>This operation potentially throws <a>SocketException</a>s (only
--   <tt>EIO</tt> is documented). <a>eInterrupted</a> is catched internally
--   and retried automatically, so won't be thrown.</li>
--   </ul>
close :: Socket f t p -> IO ()

-- | Looks up a name and executes an supplied action with a connected
--   socket.
--   
--   <ul>
--   <li>The addresses returned by <a>getAddressInfo</a> are tried in
--   sequence until a connection has been established or all have been
--   tried.</li>
--   <li>If <a>connect</a> fails on all addresses the exception that
--   occured on the last connection attempt is thrown.</li>
--   <li>The supplied action is executed at most once with the first
--   established connection.</li>
--   <li>If the address family is <a>Inet6</a>, <a>V6Only</a> is set to
--   <a>False</a> which means the other end may be both IPv4 or IPv6.</li>
--   <li>All sockets created by this operation get closed
--   automatically.</li>
--   <li>This operation throws <a>AddressInfoException</a>s,
--   <a>SocketException</a>s and all exceptions that that the supplied
--   action might throw.</li>
--   </ul>
--   
--   <pre>
--   withConnectedSocket "wwww.haskell.org" "80" (aiAll `mappend` aiV4Mapped) $ \sock-&gt; do
--     let _ = sock :: Socket Inet6 Stream TCP
--     doSomethingWithSocket sock
--   </pre>
withConnectedSocket :: (GetAddressInfo f, Type t, Protocol p) => ByteString -> ByteString -> AddressInfoFlags -> (Socket f t p -> IO a) -> IO a

-- | Like <a>send</a>, but operates on lazy <a>ByteString</a>s and
--   continues until all data has been sent or an exception occured.
sendAll :: Socket f Stream p -> ByteString -> MessageFlags -> IO ()

-- | Like <a>receive</a>, but operates on lazy <a>ByteString</a>s and
--   continues until either an empty part has been received (peer closed
--   the connection) or given buffer limit has been exceeded or an
--   exception occured.
--   
--   <ul>
--   <li>The <a>Int64</a> parameter is a soft limit on how many bytes to
--   receive. Collection is stopped if the limit has been exceeded. The
--   result might be up to one internal buffer size longer than the given
--   limit. If the returned <a>ByteString</a>s length is lower or eqal than
--   the limit, the data has not been truncated and the transmission is
--   complete.</li>
--   </ul>
receiveAll :: Socket f Stream p -> Int64 -> MessageFlags -> IO ByteString

-- | A generic socket type. Also see <tt>socket</tt> for details.
--   
--   The socket is just an <a>MVar</a>-wrapped file descriptor. It is
--   exposed in order to make this library easily extensible, but it is
--   usually not necessary nor advised to work directly on the file
--   descriptor. If you do, the following rules must be obeyed:
--   
--   <ul>
--   <li>Make sure not to deadlock. Use <a>withMVar</a> or similar.</li>
--   <li>The lock <b>must not</b> be held during a blocking call. This
--   would make it impossible to send and receive simultaneously or to
--   close the socket.</li>
--   <li>The lock <b>must</b> be held when calling operations that use the
--   file descriptor. Otherwise the socket might get closed or even reused
--   by another thread/capability which might result in reading from or
--   writing totally different connection. This is a security
--   nightmare!</li>
--   <li>The socket is non-blocking and all the code relies on that
--   assumption. You need to use GHC's eventing mechanism primitives to
--   block until something happens. The former rules forbid to use
--   <a>threadWaitRead</a> as it does not seperate between registering the
--   file descriptor (for which the lock <b>must</b> be held) and the
--   actual waiting (for which you must <b>not</b> hold the lock). Also see
--   [this](https:/<i>mail.haskell.org</i>pipermail<i>haskell-cafe</i>2014-September/115823.html)
--   thread and read the library code to see how the problem is currently
--   circumvented.</li>
--   </ul>
newtype Socket f t p
Socket :: (MVar Fd) -> Socket f t p
class Storable (SocketAddress f) => Family f where type family SocketAddress f
familyNumber :: Family f => f -> CInt
data Inet
data Inet6
class Type t
typeNumber :: Type t => t -> CInt
data Datagram
data Raw
data SequentialPacket
data Stream
class Protocol p
protocolNumber :: Protocol p => p -> CInt
data UDP
data TCP
newtype SocketException
SocketException :: CInt -> SocketException
eOk :: SocketException
eInterrupted :: SocketException
eAgain :: SocketException
eWouldBlock :: SocketException
eBadFileDescriptor :: SocketException
eInProgress :: SocketException
eProtocolNotSupported :: SocketException
eInvalid :: SocketException
eConnectionRefused :: SocketException
eNetworkUnreachable :: SocketException
eNotConnected :: SocketException
eAlready :: SocketException
eIsConnected :: SocketException
eTimedOut :: SocketException
ePipe :: SocketException

-- | Contains the error code that can be matched against. Use <a>show</a>
--   to get a human readable explanation of the error.
newtype AddressInfoException
AddressInfoException :: CInt -> AddressInfoException

-- | <pre>
--   AddressInfoException "Temporary failure in name resolution"
--   </pre>
eaiAgain :: AddressInfoException

-- | <pre>
--   AddressInfoException "Bad value for ai_flags"
--   </pre>
eaiBadFlags :: AddressInfoException

-- | <pre>
--   AddressInfoException "Non-recoverable failure in name resolution"
--   </pre>
eaiFail :: AddressInfoException

-- | <pre>
--   AddressInfoException "ai_family not supported"
--   </pre>
eaiFamily :: AddressInfoException

-- | <pre>
--   AddressInfoException "Memory allocation failure"
--   </pre>
eaiMemory :: AddressInfoException

-- | <pre>
--   AddressInfoException "No such host is known"
--   </pre>
eaiNoName :: AddressInfoException

-- | <pre>
--   AddressInfoException "ai_socktype not supported"
--   </pre>
eaiSocketType :: AddressInfoException

-- | <pre>
--   AddressInfoException "Servname not supported for ai_socktype"
--   </pre>
eaiService :: AddressInfoException

-- | <pre>
--   AddressInfoException "System error"
--   </pre>
eaiSystem :: AddressInfoException
class GetSocketOption o
getSocketOption :: GetSocketOption o => Socket f t p -> IO o
class SetSocketOption o
setSocketOption :: SetSocketOption o => Socket f t p -> o -> IO ()

-- | <pre>
--   SO_ERROR
--   </pre>
data Error
Error :: SocketException -> Error

-- | <pre>
--   SO_REUSEADDR
--   </pre>
data ReuseAddress
ReuseAddress :: Bool -> ReuseAddress

-- | Use the <a>Monoid</a> instance to combine several flags:
--   
--   <pre>
--   mconcat [msgNoSignal, msgWaitAll]
--   </pre>
--   
--   Use the <a>Bits</a> instance to check whether a flag is set:
--   
--   <pre>
--   if flags .&amp;. msgEndOfRecord /= mempty then ...
--   </pre>
newtype MessageFlags
MessageFlags :: CInt -> MessageFlags

-- | <pre>
--   MSG_EOR
--   </pre>
msgEndOfRecord :: MessageFlags

-- | <pre>
--   MSG_NOSIGNAL
--   </pre>
--   
--   Suppresses the generation of <tt>PIPE</tt> signals when writing to a
--   socket that is no longer connected.
--   
--   Although this flag is POSIX, it is not available on all platforms. Try
--   
--   <pre>
--   msgNoSignal /= mempty
--   </pre>
--   
--   in order to check whether this flag is defined on a certain platform.
--   It is safe to just use this constant even if it might not have effect
--   on a certain target platform. The platform independence of this flag
--   is therefore fulfilled to some extent.
--   
--   Some more explanation on the platform specific behaviour:
--   
--   <ul>
--   <li>Linux defines and supports <tt>MSG_NOSIGNAL</tt> and properly
--   suppresses the generation of broken pipe-related signals.</li>
--   <li>Windows does not define it, but does not generate signals
--   either.</li>
--   <li>OSX does not define it, but generates <tt>PIPE</tt> signals. The
--   GHC runtime ignores them if you don't hook them explicitly. The
--   non-portable socket option <tt>SO_NOSIGPIPE</tt> may be used disable
--   signals on a per-socket basis.</li>
--   </ul>
msgNoSignal :: MessageFlags

-- | <pre>
--   MSG_OOB
--   </pre>
msgOutOfBand :: MessageFlags

-- | <pre>
--   MSG_WAITALL
--   </pre>
msgWaitAll :: MessageFlags

-- | Use the <a>Monoid</a> instance to combine several flags:
--   
--   <pre>
--   mconcat [aiAddressConfig, aiV4Mapped]
--   </pre>
newtype AddressInfoFlags
AddressInfoFlags :: CInt -> AddressInfoFlags

-- | <tt>AI_ADDRCONFIG</tt>:
aiAddressConfig :: AddressInfoFlags

-- | <tt>AI_ALL</tt>: Return both IPv4 (as mapped
--   <a>SocketAddressInet6</a>) and IPv6 addresses when <a>aiV4Mapped</a>
--   is set independent of whether IPv6 addresses exist for this name.
aiAll :: AddressInfoFlags

-- | <tt>AI_CANONNAME</tt>:
aiCanonicalName :: AddressInfoFlags

-- | <tt>AI_NUMERICHOST</tt>:
aiNumericHost :: AddressInfoFlags

-- | <tt>AI_NUMERICSERV</tt>:
aiNumericService :: AddressInfoFlags

-- | <tt>AI_PASSIVE</tt>:
aiPassive :: AddressInfoFlags

-- | <tt>AI_V4MAPPED</tt>: Return mapped IPv4 addresses if no IPv6
--   addresses could be found or if <a>aiAll</a> flag is set.
aiV4Mapped :: AddressInfoFlags

-- | Use the <a>Monoid</a> instance to combine several flags:
--   
--   <pre>
--   mconcat [niNameRequired, niNoFullyQualifiedDomainName]
--   </pre>
newtype NameInfoFlags
NameInfoFlags :: CInt -> NameInfoFlags

-- | <tt>NI_NAMEREQD</tt>: Throw an exception if the hostname cannot be
--   determined.
niNameRequired :: NameInfoFlags

-- | <tt>NI_DGRAM</tt>: Service is datagram based (i.e. <a>UDP</a>) rather
--   than stream based (i.e. <a>TCP</a>).
niDatagram :: NameInfoFlags

-- | <tt>NI_NOFQDN</tt>: Return only the hostname part of the fully
--   qualified domain name for local hosts.
niNoFullyQualifiedDomainName :: NameInfoFlags

-- | <tt>NI_NUMERICHOST</tt>: Return the numeric form of the host address.
niNumericHost :: NameInfoFlags

-- | <tt>NI_NUMERICSERV</tt>: Return the numeric form of the service
--   address.
niNumericService :: NameInfoFlags
