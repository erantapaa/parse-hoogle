-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Directed acyclic word graphs
--   
--   The library implements <i>directed acyclic word graphs</i> (DAWGs)
--   internally represented as <i>minimal acyclic deterministic
--   finite-state automata</i>.
--   
--   The <a>Data.DAWG.Dynamic</a> module provides fast insert and delete
--   operations which can be used to build the automaton on-the-fly. The
--   automaton from the <a>Data.DAWG.Static</a> module has lower memory
--   footprint and provides static hashing functionality.
@package dawg
@version 0.11


-- | The module implements <i>directed acyclic word graphs</i> (DAWGs)
--   internaly represented as <i>minimal acyclic deterministic finite-state
--   automata</i>. The implementation provides fast insert and delete
--   operations which can be used to build the DAWG structure incrementaly.
module Data.DAWG.Dynamic

-- | A directed acyclic word graph with phantom type <tt>a</tt>
--   representing type of alphabet elements.
data DAWG a b

-- | Find value associated with the key.
lookup :: (Enum a, Ord b) => [a] -> DAWG a b -> Maybe b

-- | Number of states in the automaton.
numStates :: DAWG a b -> Int

-- | Number of edges in the automaton.
numEdges :: DAWG a b -> Int

-- | Empty DAWG.
empty :: Ord b => DAWG a b

-- | Construct DAWG from the list of (word, value) pairs.
fromList :: (Enum a, Ord b) => [([a], b)] -> DAWG a b

-- | Construct DAWG from the list of (word, value) pairs with a combining
--   function. The combining function is applied strictly.
fromListWith :: (Enum a, Ord b) => (b -> b -> b) -> [([a], b)] -> DAWG a b

-- | Make DAWG from the list of words. Annotate each word with the
--   <tt>()</tt> value.
fromLang :: Enum a => [[a]] -> DAWG a ()

-- | Insert the (key, value) pair into the DAWG.
insert :: (Enum a, Ord b) => [a] -> b -> DAWG a b -> DAWG a b

-- | Insert with a function, combining new value and old value.
--   <a>insertWith</a> f key value d will insert the pair (key, value) into
--   d if key does not exist in the DAWG. If the key does exist, the
--   function will insert the pair (key, f new_value old_value).
insertWith :: (Enum a, Ord b) => (b -> b -> b) -> [a] -> b -> DAWG a b -> DAWG a b

-- | Delete the key from the DAWG.
delete :: (Enum a, Ord b) => [a] -> DAWG a b -> DAWG a b

-- | Return all key/value pairs in the DAWG in ascending key order.
assocs :: (Enum a, Ord b) => DAWG a b -> [([a], b)]

-- | Return all keys of the DAWG in ascending order.
keys :: (Enum a, Ord b) => DAWG a b -> [[a]]

-- | Return all elements of the DAWG in the ascending order of their keys.
elems :: Ord b => DAWG a b -> [b]


-- | The module implements <i>directed acyclic word graphs</i> (DAWGs)
--   internaly represented as <i>minimal acyclic deterministic finite-state
--   automata</i>.
--   
--   In comparison to <a>Data.DAWG.Dynamic</a> module the automaton
--   implemented here:
--   
--   <ul>
--   <li>Keeps all nodes in one array and therefore uses less memory,</li>
--   <li>When <a>weigh</a>ed, it can be used to perform static hashing with
--   <a>index</a> and <a>byIndex</a> functions,</li>
--   <li>Doesn't provide insert/delete family of operations.</li>
--   </ul>
module Data.DAWG.Static

-- | <tt>DAWG a b c</tt> constitutes an automaton with alphabet symbols of
--   type <i>a</i>, transition labels of type <i>b</i> and node values of
--   type <i>Maybe c</i>. All nodes are stored in a <a>Vector</a> with
--   positions of nodes corresponding to their <a>ID</a>s.
data DAWG a b c

-- | Node identifier.
type ID = Int

-- | The actual DAWG root has the 0 ID. Thanks to the <a>rootID</a>
--   attribute, we can represent a submap of a DAWG.
rootID :: DAWG a b c -> ID

-- | Retrieve sub-DAWG with a given ID (or <a>Nothing</a>, if there's no
--   such DAWG). This function can be used, together with the <tt>root</tt>
--   function, to store IDs rather than entire DAWGs in a data structure.
byID :: ID -> DAWG a b c -> Maybe (DAWG a b c)

-- | Find value associated with the key.
lookup :: (Enum a, Unbox b) => [a] -> DAWG a b c -> Maybe c

-- | A list of outgoing edges.
edges :: Enum a => DAWG a b c -> [(a, DAWG a b c)]

-- | Return the sub-DAWG containing all keys beginning with a prefix. The
--   in-memory representation of the resultant DAWG is the same as of the
--   original one, only the pointer to the DAWG root will be different.
submap :: (Enum a, Unbox b) => [a] -> DAWG a b c -> DAWG a b c

-- | Number of states in the automaton. TODO: The function ignores the
--   <a>rootID</a> value, it won't work properly after using the
--   <a>submap</a> function.
numStates :: DAWG a b c -> Int

-- | Number of edges in the automaton. TODO: The function ignores the
--   <a>rootID</a> value, it won't work properly after using the
--   <a>submap</a> function.
numEdges :: DAWG a b c -> Int

-- | Weight of a node corresponds to the number of final states reachable
--   from the node. Weight of an edge is a sum of weights of preceding
--   nodes outgoing from the same parent node.
type Weight = Int

-- | Compute node weights and store corresponding values in transition
--   labels. Be aware, that the entire DAWG will be weighted, even when
--   (because of the use of the <a>submap</a> function) only a part of the
--   DAWG is currently selected.
weigh :: DAWG a b c -> DAWG a Weight c

-- | A number of distinct (key, value) pairs in the weighted DAWG.
size :: DAWG a Weight c -> Int

-- | Position in a set of all dictionary entries with respect to the
--   lexicographic order.
index :: Enum a => [a] -> DAWG a Weight c -> Maybe Int

-- | Find dictionary entry given its index with respect to the
--   lexicographic order.
byIndex :: Enum a => Int -> DAWG a Weight c -> Maybe [a]

-- | Empty DAWG.
empty :: Unbox b => DAWG a b c

-- | Construct <a>DAWG</a> from the list of (word, value) pairs. First a
--   <a>DAWG</a> is created and then it is frozen using the <a>freeze</a>
--   function.
fromList :: (Enum a, Ord b) => [([a], b)] -> DAWG a () b

-- | Construct DAWG from the list of (word, value) pairs with a combining
--   function. The combining function is applied strictly. First a
--   <a>DAWG</a> is created and then it is frozen using the <a>freeze</a>
--   function.
fromListWith :: (Enum a, Ord b) => (b -> b -> b) -> [([a], b)] -> DAWG a () b

-- | Make DAWG from the list of words. Annotate each word with the
--   <tt>()</tt> value. First a <a>DAWG</a> is created and then it is
--   frozen using the <a>freeze</a> function.
fromLang :: Enum a => [[a]] -> DAWG a () ()

-- | Return all (key, value) pairs in the DAWG in ascending key order.
assocs :: (Enum a, Unbox b) => DAWG a b c -> [([a], c)]

-- | Return all keys of the DAWG in ascending order.
keys :: (Enum a, Unbox b) => DAWG a b c -> [[a]]

-- | Return all elements of the DAWG in the ascending order of their keys.
elems :: Unbox b => DAWG a b c -> [c]

-- | Construct immutable version of the automaton.
freeze :: DAWG a b -> DAWG a () b
instance (Show b, Show c, Unbox b) => Show (DAWG a b c)
instance (Eq b, Eq c, Unbox b) => Eq (DAWG a b c)
instance (Ord b, Ord c, Unbox b) => Ord (DAWG a b c)
instance (Binary b, Binary c, Unbox b) => Binary (DAWG a b c)
