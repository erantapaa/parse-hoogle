-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A low-dimensional linear algebra library, tailored to computer graphics.
--   
--   A low-dimensional (2, 3 and 4) linear algebra library, with lots of
--   useful functions. Intended usage is primarily computer graphics (basic
--   OpenGL support is included as a separate package). Projective 4
--   dimensional operations, as used in eg. OpenGL, are also supported; and
--   so are quaternions. The base field is either Float or Double.
@package vect
@version 0.4.7

module Data.Vect.Double.Base
class AbelianGroup g
(&+) :: AbelianGroup g => g -> g -> g
(&-) :: AbelianGroup g => g -> g -> g
neg :: AbelianGroup g => g -> g
zero :: AbelianGroup g => g
vecSum :: AbelianGroup g => [g] -> g
class MultSemiGroup r
(.*.) :: MultSemiGroup r => r -> r -> r
one :: MultSemiGroup r => r
class (AbelianGroup r, MultSemiGroup r) => Ring r
semigroupProduct :: MultSemiGroup r => [r] -> r
class LeftModule r m
lmul :: LeftModule r m => r -> m -> m
(*.) :: LeftModule r m => r -> m -> m
class RightModule m r
rmul :: RightModule m r => m -> r -> m
(.*) :: RightModule m r => m -> r -> m
class AbelianGroup v => Vector v
mapVec :: Vector v => (Double -> Double) -> v -> v
scalarMul :: Vector v => Double -> v -> v
(*&) :: Vector v => Double -> v -> v
(&*) :: Vector v => v -> Double -> v
class DotProd v
(&.) :: DotProd v => v -> v -> Double
norm :: DotProd v => v -> Double
normsqr :: DotProd v => v -> Double
len :: DotProd v => v -> Double
lensqr :: DotProd v => v -> Double
dotprod :: DotProd v => v -> v -> Double

-- | Cross product
class CrossProd v
crossprod :: CrossProd v => v -> v -> v
(&^) :: CrossProd v => v -> v -> v
normalize :: (Vector v, DotProd v) => v -> v
distance :: (Vector v, DotProd v) => v -> v -> Double

-- | the angle between two vectors
angle :: (Vector v, DotProd v) => v -> v -> Double

-- | the angle between two unit vectors
angle' :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Double
class (Vector v, DotProd v) => UnitVector v u | v -> u, u -> v
mkNormal :: UnitVector v u => v -> u
toNormalUnsafe :: UnitVector v u => v -> u
fromNormal :: UnitVector v u => u -> v
fromNormalRadius :: UnitVector v u => Double -> u -> v

-- | Pointwise multiplication
class Pointwise v
pointwise :: Pointwise v => v -> v -> v
(&!) :: Pointwise v => v -> v -> v

-- | conversion between vectors (and matrices) of different dimensions
class Extend u v
extendZero :: Extend u v => u -> v
extendWith :: Extend u v => Double -> u -> v
trim :: Extend u v => v -> u
class HasCoordinates v x | v -> x
_1 :: HasCoordinates v x => v -> x
_2 :: HasCoordinates v x => v -> x
_3 :: HasCoordinates v x => v -> x
_4 :: HasCoordinates v x => v -> x
class Dimension a
dim :: Dimension a => a -> Int
class Matrix m
transpose :: Matrix m => m -> m
inverse :: Matrix m => m -> m
idmtx :: Matrix m => m

-- | Outer product (could be unified with Diagonal?)
class Tensor t v | t -> v
outer :: Tensor t v => v -> v -> t

-- | makes a diagonal matrix from a vector
class Diagonal s t | t -> s
diag :: Diagonal s t => s -> t
class Determinant m
det :: Determinant m => m -> Double
class Matrix m => Orthogonal m o | m -> o, o -> m
fromOrtho :: Orthogonal m o => o -> m
toOrthoUnsafe :: Orthogonal m o => m -> o

-- | "Projective" matrices have the following form: the top left corner is
--   an any matrix, the bottom right corner is 1, and the top-right column
--   is zero. These describe the affine orthogonal transformation of the
--   space one dimension less.
class (Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p | m -> p, p -> m, p -> o, o -> p, p -> n, n -> p, p -> v, v -> p, n -> o, n -> v, v -> n
fromProjective :: Projective v n o m p => p -> m
toProjectiveUnsafe :: Projective v n o m p => m -> p
orthogonal :: Projective v n o m p => o -> p
linear :: Projective v n o m p => n -> p
translation :: Projective v n o m p => v -> p
scaling :: Projective v n o m p => v -> p
class (AbelianGroup m, Matrix m) => MatrixNorms m
frobeniusNorm :: MatrixNorms m => m -> Double
matrixDistance :: MatrixNorms m => m -> m -> Double
operatorNorm :: MatrixNorms m => m -> Double
data Vec2
Vec2 :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Vec2
data Vec3
Vec3 :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Vec3
data Vec4
Vec4 :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Vec4

-- | The components are <i>row</i> vectors
data Mat2
Mat2 :: !Vec2 -> !Vec2 -> Mat2
data Mat3
Mat3 :: !Vec3 -> !Vec3 -> !Vec3 -> Mat3
data Mat4
Mat4 :: !Vec4 -> !Vec4 -> !Vec4 -> !Vec4 -> Mat4

-- | Orthogonal matrices.
--   
--   Note: the <a>Random</a> instances generates orthogonal matrices with
--   determinant 1 (that is, orientation-preserving orthogonal
--   transformations)!
data Ortho2
data Ortho3
data Ortho4

-- | The assumption when dealing with these is always that they are of unit
--   length. Also, interpolation works differently.
data Normal2
data Normal3
data Normal4

-- | Projective matrices, encoding affine transformations in dimension one
--   less.
data Proj3
data Proj4
mkVec2 :: (Double, Double) -> Vec2
mkVec3 :: (Double, Double, Double) -> Vec3
mkVec4 :: (Double, Double, Double, Double) -> Vec4
project :: (Vector v, DotProd v) => v -> v -> v

-- | Projects the first vector down to the hyperplane orthogonal to the
--   second (unit) vector
project' :: (Vector v, UnitVector v u, DotProd v) => v -> u -> v

-- | Direction (second argument) is assumed to be a <i>unit</i> vector!
projectUnsafe :: (Vector v, DotProd v) => v -> v -> v

-- | Since unit vectors are not a group, we need a separate function.
flipNormal :: UnitVector v n => n -> n

-- | Householder matrix, see
--   <a>http://en.wikipedia.org/wiki/Householder_transformation</a>. In
--   plain words, it is the reflection to the hyperplane orthogonal to the
--   input vector.
householder :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
householderOrtho :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
instance Read Vec2
instance Show Vec2
instance Read Vec3
instance Show Vec3
instance Read Vec4
instance Show Vec4
instance Read Mat2
instance Show Mat2
instance Read Mat3
instance Show Mat3
instance Read Mat4
instance Show Mat4
instance Read Normal2
instance Show Normal2
instance Storable Normal2
instance DotProd Normal2
instance Dimension Normal2
instance Read Normal3
instance Show Normal3
instance Storable Normal3
instance DotProd Normal3
instance Dimension Normal3
instance Read Normal4
instance Show Normal4
instance Storable Normal4
instance DotProd Normal4
instance Dimension Normal4
instance Read Ortho2
instance Show Ortho2
instance Storable Ortho2
instance MultSemiGroup Ortho2
instance Determinant Ortho2
instance Dimension Ortho2
instance Read Ortho3
instance Show Ortho3
instance Storable Ortho3
instance MultSemiGroup Ortho3
instance Determinant Ortho3
instance Dimension Ortho3
instance Read Ortho4
instance Show Ortho4
instance Storable Ortho4
instance MultSemiGroup Ortho4
instance Determinant Ortho4
instance Dimension Ortho4
instance Read Proj3
instance Show Proj3
instance Storable Proj3
instance MultSemiGroup Proj3
instance Read Proj4
instance Show Proj4
instance Storable Proj4
instance MultSemiGroup Proj4
instance Extend Mat3 Mat4
instance Extend Mat2 Mat4
instance Extend Mat2 Mat3
instance Extend Vec3 Vec4
instance Extend Vec2 Vec4
instance Extend Vec2 Vec3
instance Pointwise Mat4
instance MatrixNorms Mat4
instance Dimension Mat4
instance Random Mat4
instance Storable Mat4
instance Determinant Mat4
instance Tensor Mat4 Vec4
instance Diagonal Vec4 Mat4
instance RightModule Vec4 Mat4
instance LeftModule Mat4 Vec4
instance Ring Mat4
instance MultSemiGroup Mat4
instance Vector Mat4
instance AbelianGroup Mat4
instance Matrix Mat4
instance HasCoordinates Mat4 Vec4
instance Dimension Vec4
instance Storable Vec4
instance Random Vec4
instance Pointwise Vec4
instance DotProd Vec4
instance Vector Vec4
instance AbelianGroup Vec4
instance HasCoordinates Vec4 Double
instance Pointwise Mat3
instance MatrixNorms Mat3
instance Dimension Mat3
instance Random Mat3
instance Storable Mat3
instance Determinant Mat3
instance Tensor Mat3 Vec3
instance Diagonal Vec3 Mat3
instance RightModule Vec3 Mat3
instance LeftModule Mat3 Vec3
instance Ring Mat3
instance MultSemiGroup Mat3
instance Vector Mat3
instance AbelianGroup Mat3
instance Matrix Mat3
instance HasCoordinates Mat3 Vec3
instance Dimension Vec3
instance Storable Vec3
instance Determinant (Vec3, Vec3, Vec3)
instance CrossProd Vec3
instance Random Vec3
instance Pointwise Vec3
instance DotProd Vec3
instance Vector Vec3
instance AbelianGroup Vec3
instance HasCoordinates Vec3 Double
instance Pointwise Mat2
instance MatrixNorms Mat2
instance Dimension Mat2
instance Random Mat2
instance Storable Mat2
instance Determinant Mat2
instance Tensor Mat2 Vec2
instance Diagonal Vec2 Mat2
instance RightModule Vec2 Mat2
instance LeftModule Mat2 Vec2
instance Ring Mat2
instance MultSemiGroup Mat2
instance Vector Mat2
instance AbelianGroup Mat2
instance Matrix Mat2
instance HasCoordinates Mat2 Vec2
instance Dimension Vec2
instance Storable Vec2
instance Random Vec2
instance Determinant (Vec2, Vec2)
instance Pointwise Vec2
instance DotProd Vec2
instance Vector Vec2
instance AbelianGroup Vec2
instance HasCoordinates Vec2 Double
instance Matrix Proj4
instance Matrix Proj3
instance Projective Vec3 Mat3 Ortho3 Mat4 Proj4
instance Projective Vec2 Mat2 Ortho2 Mat3 Proj3
instance Random Ortho4
instance Random Ortho3
instance Random Ortho2
instance Matrix Ortho4
instance Matrix Ortho3
instance Matrix Ortho2
instance Orthogonal Mat4 Ortho4
instance Orthogonal Mat3 Ortho3
instance Orthogonal Mat2 Ortho2
instance CrossProd Normal3
instance Random Normal4
instance Random Normal3
instance Random Normal2
instance UnitVector Vec4 Normal4
instance UnitVector Vec3 Normal3
instance UnitVector Vec2 Normal2

module Data.Vect.Double.Util.Dim2

-- | Example: <tt>structVec2 [1,2,3,4] = [ Vec2 1 2 , Vec2 3 4 ]</tt>.
structVec2 :: [Double] -> [Vec2]

-- | The opposite of <a>structVec2</a>.
destructVec2 :: [Vec2] -> [Double]
det2 :: Vec2 -> Vec2 -> Double
vec2X :: Vec2
vec2Y :: Vec2
translate2X :: Double -> Vec2 -> Vec2
translate2Y :: Double -> Vec2 -> Vec2

-- | unit vector with given angle relative to the positive X axis (in the
--   positive direction, that is, CCW). A more precise name would be
--   <tt>cosSin</tt>, but that sounds bad :)
sinCos :: Double -> Vec2
sinCos' :: Double -> Normal2
sinCosRadius :: Double -> Double -> Vec2

-- | The angle relative to the positive X axis
angle2 :: Vec2 -> Double
angle2' :: Normal2 -> Double

-- | Rotation matrix by a given angle (in radians), counterclockwise.
rotMatrix2 :: Double -> Mat2
rotMatrixOrtho2 :: Double -> Ortho2
rotate2 :: Double -> Vec2 -> Vec2

-- | Rotates counterclockwise by 90 degrees.
rotateCCW :: Vec2 -> Vec2

-- | Rotates clockwise by 90 degrees.
rotateCW :: Vec2 -> Vec2

module Data.Vect.Double.Util.Dim3

-- | Example: <tt>structVec3 [1,2,3,4,5,6] = [ Vec3 1 2 3 , Vec3 4 5
--   6]</tt>.
structVec3 :: [Double] -> [Vec3]

-- | The opposite of <a>structVec3</a>.
destructVec3 :: [Vec3] -> [Double]
det3 :: Vec3 -> Vec3 -> Vec3 -> Double
translate3X :: Double -> Vec3 -> Vec3
translate3Y :: Double -> Vec3 -> Vec3
translate3Z :: Double -> Vec3 -> Vec3
vec3X :: Vec3
vec3Y :: Vec3
vec3Z :: Vec3
rotMatrixZ :: Double -> Mat3
rotMatrixY :: Double -> Mat3
rotMatrixX :: Double -> Mat3
rotate3' :: Double -> Normal3 -> Vec3 -> Vec3
rotate3 :: Double -> Vec3 -> Vec3 -> Vec3

-- | Rotation around an arbitrary 3D vector. The resulting 3x3 matrix is
--   intended for multiplication on the <i>right</i>.
rotMatrix3 :: Vec3 -> Double -> Mat3
rotMatrixOrtho3 :: Vec3 -> Double -> Ortho3

-- | Rotation around an arbitrary 3D <i>unit</i> vector. The resulting 3x3
--   matrix is intended for multiplication on the <i>right</i>.
rotMatrix3' :: Normal3 -> Double -> Mat3
rotMatrixOrtho3' :: Normal3 -> Double -> Ortho3

-- | Reflects a vector to an axis: that is, the result of <tt>reflect n
--   v</tt> is 2&lt;n,v&gt;n - v
reflect :: Normal3 -> Vec3 -> Vec3
reflect' :: Normal3 -> Normal3 -> Normal3
refract :: Double -> Normal3 -> Vec3 -> Vec3

-- | Refraction. First parameter (<tt>eta</tt>) is the relative refraction
--   index
--   
--   <pre>
--          refl_inside
--   eta = --------------
--          refl_outside
--   </pre>
--   
--   where "inside" is the direction of the second argument (to vector
--   normal to plane which models the boundary between the two materials).
--   That is, total internal reflection can occur when <tt>eta&gt;1</tt>.
--   
--   The convention is that the origin is the point of intersection of the
--   ray and the surface, and all the vectors "point away" from here
--   (unlike, say, GLSL's <tt>refract</tt>, where the incident vector
--   "points towards" the material)
refract' :: Double -> Normal3 -> Normal3 -> Normal3

-- | When total internal reflection would occur, we return <a>Nothing</a>.
refractOnly' :: Double -> Normal3 -> Normal3 -> Maybe Normal3


-- | Interpolation of vectors. Note: we interpolate unit vectors
--   differently from ordinary vectors.
module Data.Vect.Double.Interpolate
class Interpolate v
interpolate :: Interpolate v => Double -> v -> v -> v

-- | Spherical linear interpolation. See
--   <a>http://en.wikipedia.org/wiki/Slerp</a>
slerp :: (Interpolate v, UnitVector v u) => Double -> u -> u -> u
instance Interpolate Normal4
instance Interpolate Normal3
instance Interpolate Normal2
instance Interpolate Vec4
instance Interpolate Vec3
instance Interpolate Vec2
instance Interpolate Double


-- | Gram-Schmidt orthogonalization. This module is not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Double.GramSchmidt

-- | produces orthogonal/orthonormal vectors from a set of vectors
class GramSchmidt a
gramSchmidt :: GramSchmidt a => a -> a
gramSchmidtNormalize :: GramSchmidt a => a -> a
instance GramSchmidt (Normal4, Normal4, Normal4, Normal4)
instance GramSchmidt (Vec4, Vec4, Vec4, Vec4)
instance GramSchmidt (Normal4, Normal4, Normal4)
instance GramSchmidt (Normal3, Normal3, Normal3)
instance GramSchmidt (Vec4, Vec4, Vec4)
instance GramSchmidt (Vec3, Vec3, Vec3)
instance GramSchmidt (Normal4, Normal4)
instance GramSchmidt (Normal3, Normal3)
instance GramSchmidt (Normal2, Normal2)
instance GramSchmidt (Vec4, Vec4)
instance GramSchmidt (Vec3, Vec3)
instance GramSchmidt (Vec2, Vec2)


-- | Rotation around an arbitrary plane in four dimensions, and other
--   miscellanea. Not very useful for most people, and not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Double.Util.Dim4
structVec4 :: [Double] -> [Vec4]
destructVec4 :: [Vec4] -> [Double]
translate4X :: Double -> Vec4 -> Vec4
translate4Y :: Double -> Vec4 -> Vec4
translate4Z :: Double -> Vec4 -> Vec4
translate4W :: Double -> Vec4 -> Vec4
vec4X :: Vec4
vec4Y :: Vec4
vec4Z :: Vec4
vec4W :: Vec4

-- | If <tt>(x,y,u,v)</tt> is an orthonormal system, then (written in
--   pseudo-code) <tt>biVector4 (x,y) = plusMinus (reverse $ biVector4
--   (u,v))</tt>. This is a helper function for the 4 dimensional rotation
--   code. If <tt>(x,y,z,p,q,r) = biVector4 a b</tt>, then the
--   corresponding antisymmetric tensor is
--   
--   <pre>
--   [  0  r  q  p ]
--   [ -r  0  z -y ]
--   [ -q -z  0  x ]
--   [ -p  y -x  0 ]
--   </pre>
biVector4 :: Vec4 -> Vec4 -> (Double, Double, Double, Double, Double, Double)

-- | the corresponding antisymmetric tensor
biVector4AsTensor :: Vec4 -> Vec4 -> Mat4

-- | We assume that the axes are normalized and <i>orthogonal</i> to each
--   other!
rotate4' :: Double -> (Normal4, Normal4) -> Vec4 -> Vec4

-- | We assume only that the axes are independent vectors.
rotate4 :: Double -> (Vec4, Vec4) -> Vec4 -> Vec4

-- | Rotation matrix around a plane specified by two normalized and
--   <i>orthogonal</i> vectors. Intended for multiplication on the
--   <i>right</i>!
rotMatrix4' :: Double -> (Normal4, Normal4) -> Mat4

-- | We assume only that the axes are independent vectors.
rotMatrix4 :: Double -> (Vec4, Vec4) -> Mat4


-- | Classic 4x4 projective matrices, encoding the affine transformations
--   of R^3. Our convention is that they are intended for multiplication on
--   the <i>right</i>, that is, they are of the form
--   
--   <pre>
--       _____
--   [  |     |  0  ]
--   [  | 3x3 |  0  ]
--   [  |_____|  0  ]
--   [  p  q  r  1  ]
--   </pre>
--   
--   Please note that by default, OpenGL stores the matrices (in memory) by
--   columns, while we store them by rows; but OpenGL also use the opposite
--   convention (so the OpenGL projective matrices are intended for
--   multiplication on the <i>left</i>). So in effect, they are the same
--   when stored in the memory, say with <tt>poke :: Ptr Mat4 -&gt; Mat4
--   -&gt; IO ()</tt>.
--   
--   Warning: The naming conventions will probably change in the future.
module Data.Vect.Double.Util.Projective
rotMatrixProj4' :: Double -> Normal3 -> Proj4
rotMatrixProj4 :: Double -> Vec3 -> Proj4

-- | synonym for <a>rotateAfterProj4</a>
rotateProj4 :: Double -> Normal3 -> Proj4 -> Proj4

-- | Synonym for <tt>m -&gt; m .*. rotMatrixProj4 angle axis</tt>.
rotateAfterProj4 :: Double -> Normal3 -> Proj4 -> Proj4

-- | Synonym for <tt>m -&gt; rotMatrixProj4 angle axis .*. m</tt>.
rotateBeforeProj4 :: Double -> Normal3 -> Proj4 -> Proj4
scalingUniformProj4 :: Double -> Proj4

-- | Equivalent to <tt>m -&gt; scaling v .*. m</tt>.
scaleBeforeProj4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; m .*. scaling v</tt>.
scaleAfterProj4 :: Vec3 -> Proj4 -> Proj4

-- | Synonym for <a>translateAfter4</a>
translate4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; m .*. translation v</tt>.
translateAfter4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; translation v .*. m</tt>.
translateBefore4 :: Vec3 -> Proj4 -> Proj4


-- | The unit sphere in the space of quaternions has the group structure
--   SU(2) coming from the quaternion multiplication, which is the double
--   cover of the group SO(3) of rotations in R^3. Thus, unit quaternions
--   can be used to encode rotations in 3D, which is a more compact
--   encoding (4 floats) than a 3x3 matrix; however, there are <i>two</i>
--   quaternions corresponding to each rotation.
--   
--   See <a>http://en.wikipedia.org/wiki/Quaternion</a> and
--   <a>http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a>
--   for more information.
module Data.Vect.Double.Util.Quaternion

-- | The type for quaternions.
newtype Quaternion
Q :: Vec4 -> Quaternion

-- | The type for unit quaternions.
newtype UnitQuaternion
U :: Vec4 -> UnitQuaternion

-- | An abbreviated type synonym for quaternions
type Q = Quaternion

-- | An abbreviated type synonym for unit quaternions
type U = UnitQuaternion
unitQ :: Q
zeroQ :: Q
multQ :: Q -> Q -> Q
negQ :: Q -> Q
normalizeQ :: Q -> Q

-- | The inverse quaternion
invQ :: Q -> Q
fromQ :: Q -> Vec4
toQ :: Vec4 -> Q
unitU :: U
multU :: U -> U -> U

-- | The opposite quaternion (which encodes the same rotation)
negU :: U -> U

-- | This is no-op, up to numerical imprecision. However, if you multiply
--   together a large number of unit quaternions, it may be a good idea to
--   normalize the end result.
normalizeU :: U -> U

-- | The inverse of a unit quaternion
invU :: U -> U
fromU :: U -> Vec4
fromU' :: U -> Normal4
mkU :: Vec4 -> U
toU :: Normal4 -> U
unsafeToU :: Vec4 -> U

-- | The <i>left</i> action of unit quaternions on 3D vectors. That is,
--   
--   <pre>
--   actU q1 $ actU q2 v  ==  actU (q1 `multU` q2) v 
--   </pre>
actU :: U -> Vec3 -> Vec3

-- | The quaternion to encode rotation around an axis. Please note that
--   quaternions act on the <i>left</i>, that is
--   
--   <pre>
--   rotU axis1 angl1 *. rotU axis2 angl2 *. v  ==  (rotU axis1 angl1 .*. rotU axis2 angl2) *. v 
--   </pre>
rotU :: Vec3 -> Double -> U
rotU' :: Normal3 -> Double -> U

-- | Interpolation of unit quaternions. Note that when applied to
--   rotations, this may be not what you want, since it is possible that
--   the shortest path in the space of unit quaternions is not the shortest
--   path in the space of rotations; see <a>slerpU</a>!
longSlerpU :: Double -> U -> U -> U

-- | This is shortest path interpolation in the space of rotations; however
--   this is achieved by possibly flipping the first endpoint in the space
--   of quaternions. Thus <tt>slerpU 0.001 q1 q2</tt> may be very far from
--   <tt>q1</tt> (and very close to <tt>negU q1</tt>) in the space of
--   quaternions (but they are very close in the space of rotations).
slerpU :: Double -> U -> U -> U

-- | Makes a rotation matrix (to be multiplied with on the <i>right</i>)
--   out of a unit quaternion:
--   
--   <pre>
--   v .* rightOrthoU (rotU axis angl)  ==  v .* rotMatrix3 axis angl
--   </pre>
--   
--   Please note that while these matrices act on the <i>right</i>,
--   quaternions act on the <i>left</i>; thus
--   
--   <pre>
--   rightOrthoU q1 .*. rightOrthoU q2  ==  rightOrthoU (q2 .*. q1)
--   </pre>
rightOrthoU :: U -> Ortho3

-- | Makes a rotation matrix (to be multiplied with on the <i>left</i>) out
--   of a unit quaternion.
--   
--   <pre>
--   leftOrthoU (rotU axis angl) *. v  ==  v .* rotMatrix3 axis angl
--   </pre>
leftOrthoU :: U -> Ortho3
instance Read Quaternion
instance Show Quaternion
instance Storable Quaternion
instance AbelianGroup Quaternion
instance Vector Quaternion
instance DotProd Quaternion
instance Random Quaternion
instance Interpolate Quaternion
instance Read UnitQuaternion
instance Show UnitQuaternion
instance Storable UnitQuaternion
instance DotProd UnitQuaternion
instance Random UnitQuaternion
instance LeftModule UnitQuaternion Vec3
instance MultSemiGroup UnitQuaternion
instance MultSemiGroup Quaternion
instance UnitVector Quaternion UnitQuaternion


-- | <a>Eq</a>, <a>Num</a> and <a>Fractional</a> instances for vectors and
--   matrices. These make writing code much more convenient, but also much
--   more dangerous; thus you have to import this module explicitely.
--   
--   In the case of Vector instances, all operations are pointwise
--   (including multiplication and division), and scalars are implicitly
--   converted to vectors so that all components of the resulting vectors
--   are the equal to the given scalar. This gives a set of consistent
--   instances.
--   
--   In the case of Matrices, multiplication is usual matrix
--   multiplication, division is not implemented, and scalars are converted
--   to diagonal matrices.
--   
--   <a>abs</a> and <a>signum</a> are implemented to be <a>normalize</a>
--   and <a>norm</a> (in the case of matrices, Frobenius norm).
module Data.Vect.Double.Instances
instance Fractional Mat4
instance Num Mat4
instance Eq Mat4
instance Fractional Mat3
instance Num Mat3
instance Eq Mat3
instance Fractional Mat2
instance Num Mat2
instance Eq Mat2
instance Fractional Vec4
instance Num Vec4
instance Eq Vec4
instance Fractional Vec3
instance Num Vec3
instance Eq Vec3
instance Fractional Vec2
instance Num Vec2
instance Eq Vec2

module Data.Vect.Double

module Data.Vect.Float.Base
class AbelianGroup g
(&+) :: AbelianGroup g => g -> g -> g
(&-) :: AbelianGroup g => g -> g -> g
neg :: AbelianGroup g => g -> g
zero :: AbelianGroup g => g
vecSum :: AbelianGroup g => [g] -> g
class MultSemiGroup r
(.*.) :: MultSemiGroup r => r -> r -> r
one :: MultSemiGroup r => r
class (AbelianGroup r, MultSemiGroup r) => Ring r
semigroupProduct :: MultSemiGroup r => [r] -> r
class LeftModule r m
lmul :: LeftModule r m => r -> m -> m
(*.) :: LeftModule r m => r -> m -> m
class RightModule m r
rmul :: RightModule m r => m -> r -> m
(.*) :: RightModule m r => m -> r -> m
class AbelianGroup v => Vector v
mapVec :: Vector v => (Float -> Float) -> v -> v
scalarMul :: Vector v => Float -> v -> v
(*&) :: Vector v => Float -> v -> v
(&*) :: Vector v => v -> Float -> v
class DotProd v
(&.) :: DotProd v => v -> v -> Float
norm :: DotProd v => v -> Float
normsqr :: DotProd v => v -> Float
len :: DotProd v => v -> Float
lensqr :: DotProd v => v -> Float
dotprod :: DotProd v => v -> v -> Float

-- | Cross product
class CrossProd v
crossprod :: CrossProd v => v -> v -> v
(&^) :: CrossProd v => v -> v -> v
normalize :: (Vector v, DotProd v) => v -> v
distance :: (Vector v, DotProd v) => v -> v -> Float

-- | the angle between two vectors
angle :: (Vector v, DotProd v) => v -> v -> Float

-- | the angle between two unit vectors
angle' :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Float
class (Vector v, DotProd v) => UnitVector v u | v -> u, u -> v
mkNormal :: UnitVector v u => v -> u
toNormalUnsafe :: UnitVector v u => v -> u
fromNormal :: UnitVector v u => u -> v
fromNormalRadius :: UnitVector v u => Float -> u -> v

-- | Pointwise multiplication
class Pointwise v
pointwise :: Pointwise v => v -> v -> v
(&!) :: Pointwise v => v -> v -> v

-- | conversion between vectors (and matrices) of different dimensions
class Extend u v
extendZero :: Extend u v => u -> v
extendWith :: Extend u v => Float -> u -> v
trim :: Extend u v => v -> u
class HasCoordinates v x | v -> x
_1 :: HasCoordinates v x => v -> x
_2 :: HasCoordinates v x => v -> x
_3 :: HasCoordinates v x => v -> x
_4 :: HasCoordinates v x => v -> x
class Dimension a
dim :: Dimension a => a -> Int
class Matrix m
transpose :: Matrix m => m -> m
inverse :: Matrix m => m -> m
idmtx :: Matrix m => m

-- | Outer product (could be unified with Diagonal?)
class Tensor t v | t -> v
outer :: Tensor t v => v -> v -> t

-- | makes a diagonal matrix from a vector
class Diagonal s t | t -> s
diag :: Diagonal s t => s -> t
class Determinant m
det :: Determinant m => m -> Float
class Matrix m => Orthogonal m o | m -> o, o -> m
fromOrtho :: Orthogonal m o => o -> m
toOrthoUnsafe :: Orthogonal m o => m -> o

-- | "Projective" matrices have the following form: the top left corner is
--   an any matrix, the bottom right corner is 1, and the top-right column
--   is zero. These describe the affine orthogonal transformation of the
--   space one dimension less.
class (Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p | m -> p, p -> m, p -> o, o -> p, p -> n, n -> p, p -> v, v -> p, n -> o, n -> v, v -> n
fromProjective :: Projective v n o m p => p -> m
toProjectiveUnsafe :: Projective v n o m p => m -> p
orthogonal :: Projective v n o m p => o -> p
linear :: Projective v n o m p => n -> p
translation :: Projective v n o m p => v -> p
scaling :: Projective v n o m p => v -> p
class (AbelianGroup m, Matrix m) => MatrixNorms m
frobeniusNorm :: MatrixNorms m => m -> Float
matrixDistance :: MatrixNorms m => m -> m -> Float
operatorNorm :: MatrixNorms m => m -> Float
data Vec2
Vec2 :: {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> Vec2
data Vec3
Vec3 :: {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> Vec3
data Vec4
Vec4 :: {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> {-# UNPACK #-} !Float -> Vec4

-- | The components are <i>row</i> vectors
data Mat2
Mat2 :: !Vec2 -> !Vec2 -> Mat2
data Mat3
Mat3 :: !Vec3 -> !Vec3 -> !Vec3 -> Mat3
data Mat4
Mat4 :: !Vec4 -> !Vec4 -> !Vec4 -> !Vec4 -> Mat4

-- | Orthogonal matrices.
--   
--   Note: the <a>Random</a> instances generates orthogonal matrices with
--   determinant 1 (that is, orientation-preserving orthogonal
--   transformations)!
data Ortho2
data Ortho3
data Ortho4

-- | The assumption when dealing with these is always that they are of unit
--   length. Also, interpolation works differently.
data Normal2
data Normal3
data Normal4

-- | Projective matrices, encoding affine transformations in dimension one
--   less.
data Proj3
data Proj4
mkVec2 :: (Float, Float) -> Vec2
mkVec3 :: (Float, Float, Float) -> Vec3
mkVec4 :: (Float, Float, Float, Float) -> Vec4
project :: (Vector v, DotProd v) => v -> v -> v

-- | Projects the first vector down to the hyperplane orthogonal to the
--   second (unit) vector
project' :: (Vector v, UnitVector v u, DotProd v) => v -> u -> v

-- | Direction (second argument) is assumed to be a <i>unit</i> vector!
projectUnsafe :: (Vector v, DotProd v) => v -> v -> v

-- | Since unit vectors are not a group, we need a separate function.
flipNormal :: UnitVector v n => n -> n

-- | Householder matrix, see
--   <a>http://en.wikipedia.org/wiki/Householder_transformation</a>. In
--   plain words, it is the reflection to the hyperplane orthogonal to the
--   input vector.
householder :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
householderOrtho :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
instance Read Vec2
instance Show Vec2
instance Read Vec3
instance Show Vec3
instance Read Vec4
instance Show Vec4
instance Read Mat2
instance Show Mat2
instance Read Mat3
instance Show Mat3
instance Read Mat4
instance Show Mat4
instance Read Normal2
instance Show Normal2
instance Storable Normal2
instance DotProd Normal2
instance Dimension Normal2
instance Read Normal3
instance Show Normal3
instance Storable Normal3
instance DotProd Normal3
instance Dimension Normal3
instance Read Normal4
instance Show Normal4
instance Storable Normal4
instance DotProd Normal4
instance Dimension Normal4
instance Read Ortho2
instance Show Ortho2
instance Storable Ortho2
instance MultSemiGroup Ortho2
instance Determinant Ortho2
instance Dimension Ortho2
instance Read Ortho3
instance Show Ortho3
instance Storable Ortho3
instance MultSemiGroup Ortho3
instance Determinant Ortho3
instance Dimension Ortho3
instance Read Ortho4
instance Show Ortho4
instance Storable Ortho4
instance MultSemiGroup Ortho4
instance Determinant Ortho4
instance Dimension Ortho4
instance Read Proj3
instance Show Proj3
instance Storable Proj3
instance MultSemiGroup Proj3
instance Read Proj4
instance Show Proj4
instance Storable Proj4
instance MultSemiGroup Proj4
instance Extend Mat3 Mat4
instance Extend Mat2 Mat4
instance Extend Mat2 Mat3
instance Extend Vec3 Vec4
instance Extend Vec2 Vec4
instance Extend Vec2 Vec3
instance Pointwise Mat4
instance MatrixNorms Mat4
instance Dimension Mat4
instance Random Mat4
instance Storable Mat4
instance Determinant Mat4
instance Tensor Mat4 Vec4
instance Diagonal Vec4 Mat4
instance RightModule Vec4 Mat4
instance LeftModule Mat4 Vec4
instance Ring Mat4
instance MultSemiGroup Mat4
instance Vector Mat4
instance AbelianGroup Mat4
instance Matrix Mat4
instance HasCoordinates Mat4 Vec4
instance Dimension Vec4
instance Storable Vec4
instance Random Vec4
instance Pointwise Vec4
instance DotProd Vec4
instance Vector Vec4
instance AbelianGroup Vec4
instance HasCoordinates Vec4 Float
instance Pointwise Mat3
instance MatrixNorms Mat3
instance Dimension Mat3
instance Random Mat3
instance Storable Mat3
instance Determinant Mat3
instance Tensor Mat3 Vec3
instance Diagonal Vec3 Mat3
instance RightModule Vec3 Mat3
instance LeftModule Mat3 Vec3
instance Ring Mat3
instance MultSemiGroup Mat3
instance Vector Mat3
instance AbelianGroup Mat3
instance Matrix Mat3
instance HasCoordinates Mat3 Vec3
instance Dimension Vec3
instance Storable Vec3
instance Determinant (Vec3, Vec3, Vec3)
instance CrossProd Vec3
instance Random Vec3
instance Pointwise Vec3
instance DotProd Vec3
instance Vector Vec3
instance AbelianGroup Vec3
instance HasCoordinates Vec3 Float
instance Pointwise Mat2
instance MatrixNorms Mat2
instance Dimension Mat2
instance Random Mat2
instance Storable Mat2
instance Determinant Mat2
instance Tensor Mat2 Vec2
instance Diagonal Vec2 Mat2
instance RightModule Vec2 Mat2
instance LeftModule Mat2 Vec2
instance Ring Mat2
instance MultSemiGroup Mat2
instance Vector Mat2
instance AbelianGroup Mat2
instance Matrix Mat2
instance HasCoordinates Mat2 Vec2
instance Dimension Vec2
instance Storable Vec2
instance Random Vec2
instance Determinant (Vec2, Vec2)
instance Pointwise Vec2
instance DotProd Vec2
instance Vector Vec2
instance AbelianGroup Vec2
instance HasCoordinates Vec2 Float
instance Matrix Proj4
instance Matrix Proj3
instance Projective Vec3 Mat3 Ortho3 Mat4 Proj4
instance Projective Vec2 Mat2 Ortho2 Mat3 Proj3
instance Random Ortho4
instance Random Ortho3
instance Random Ortho2
instance Matrix Ortho4
instance Matrix Ortho3
instance Matrix Ortho2
instance Orthogonal Mat4 Ortho4
instance Orthogonal Mat3 Ortho3
instance Orthogonal Mat2 Ortho2
instance CrossProd Normal3
instance Random Normal4
instance Random Normal3
instance Random Normal2
instance UnitVector Vec4 Normal4
instance UnitVector Vec3 Normal3
instance UnitVector Vec2 Normal2

module Data.Vect.Float.Util.Dim2

-- | Example: <tt>structVec2 [1,2,3,4] = [ Vec2 1 2 , Vec2 3 4 ]</tt>.
structVec2 :: [Float] -> [Vec2]

-- | The opposite of <a>structVec2</a>.
destructVec2 :: [Vec2] -> [Float]
det2 :: Vec2 -> Vec2 -> Float
vec2X :: Vec2
vec2Y :: Vec2
translate2X :: Float -> Vec2 -> Vec2
translate2Y :: Float -> Vec2 -> Vec2

-- | unit vector with given angle relative to the positive X axis (in the
--   positive direction, that is, CCW). A more precise name would be
--   <tt>cosSin</tt>, but that sounds bad :)
sinCos :: Float -> Vec2
sinCos' :: Float -> Normal2
sinCosRadius :: Float -> Float -> Vec2

-- | The angle relative to the positive X axis
angle2 :: Vec2 -> Float
angle2' :: Normal2 -> Float

-- | Rotation matrix by a given angle (in radians), counterclockwise.
rotMatrix2 :: Float -> Mat2
rotMatrixOrtho2 :: Float -> Ortho2
rotate2 :: Float -> Vec2 -> Vec2

-- | Rotates counterclockwise by 90 degrees.
rotateCCW :: Vec2 -> Vec2

-- | Rotates clockwise by 90 degrees.
rotateCW :: Vec2 -> Vec2

module Data.Vect.Float.Util.Dim3

-- | Example: <tt>structVec3 [1,2,3,4,5,6] = [ Vec3 1 2 3 , Vec3 4 5
--   6]</tt>.
structVec3 :: [Float] -> [Vec3]

-- | The opposite of <a>structVec3</a>.
destructVec3 :: [Vec3] -> [Float]
det3 :: Vec3 -> Vec3 -> Vec3 -> Float
translate3X :: Float -> Vec3 -> Vec3
translate3Y :: Float -> Vec3 -> Vec3
translate3Z :: Float -> Vec3 -> Vec3
vec3X :: Vec3
vec3Y :: Vec3
vec3Z :: Vec3
rotMatrixZ :: Float -> Mat3
rotMatrixY :: Float -> Mat3
rotMatrixX :: Float -> Mat3
rotate3' :: Float -> Normal3 -> Vec3 -> Vec3
rotate3 :: Float -> Vec3 -> Vec3 -> Vec3

-- | Rotation around an arbitrary 3D vector. The resulting 3x3 matrix is
--   intended for multiplication on the <i>right</i>.
rotMatrix3 :: Vec3 -> Float -> Mat3
rotMatrixOrtho3 :: Vec3 -> Float -> Ortho3

-- | Rotation around an arbitrary 3D <i>unit</i> vector. The resulting 3x3
--   matrix is intended for multiplication on the <i>right</i>.
rotMatrix3' :: Normal3 -> Float -> Mat3
rotMatrixOrtho3' :: Normal3 -> Float -> Ortho3

-- | Reflects a vector to an axis: that is, the result of <tt>reflect n
--   v</tt> is 2&lt;n,v&gt;n - v
reflect :: Normal3 -> Vec3 -> Vec3
reflect' :: Normal3 -> Normal3 -> Normal3
refract :: Float -> Normal3 -> Vec3 -> Vec3

-- | Refraction. First parameter (<tt>eta</tt>) is the relative refraction
--   index
--   
--   <pre>
--          refl_inside
--   eta = --------------
--          refl_outside
--   </pre>
--   
--   where "inside" is the direction of the second argument (to vector
--   normal to plane which models the boundary between the two materials).
--   That is, total internal reflection can occur when <tt>eta&gt;1</tt>.
--   
--   The convention is that the origin is the point of intersection of the
--   ray and the surface, and all the vectors "point away" from here
--   (unlike, say, GLSL's <tt>refract</tt>, where the incident vector
--   "points towards" the material)
refract' :: Float -> Normal3 -> Normal3 -> Normal3

-- | When total internal reflection would occur, we return <a>Nothing</a>.
refractOnly' :: Float -> Normal3 -> Normal3 -> Maybe Normal3


-- | Interpolation of vectors. Note: we interpolate unit vectors
--   differently from ordinary vectors.
module Data.Vect.Float.Interpolate
class Interpolate v
interpolate :: Interpolate v => Float -> v -> v -> v

-- | Spherical linear interpolation. See
--   <a>http://en.wikipedia.org/wiki/Slerp</a>
slerp :: (Interpolate v, UnitVector v u) => Float -> u -> u -> u
instance Interpolate Normal4
instance Interpolate Normal3
instance Interpolate Normal2
instance Interpolate Vec4
instance Interpolate Vec3
instance Interpolate Vec2
instance Interpolate Float


-- | Gram-Schmidt orthogonalization. This module is not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Float.GramSchmidt

-- | produces orthogonal/orthonormal vectors from a set of vectors
class GramSchmidt a
gramSchmidt :: GramSchmidt a => a -> a
gramSchmidtNormalize :: GramSchmidt a => a -> a
instance GramSchmidt (Normal4, Normal4, Normal4, Normal4)
instance GramSchmidt (Vec4, Vec4, Vec4, Vec4)
instance GramSchmidt (Normal4, Normal4, Normal4)
instance GramSchmidt (Normal3, Normal3, Normal3)
instance GramSchmidt (Vec4, Vec4, Vec4)
instance GramSchmidt (Vec3, Vec3, Vec3)
instance GramSchmidt (Normal4, Normal4)
instance GramSchmidt (Normal3, Normal3)
instance GramSchmidt (Normal2, Normal2)
instance GramSchmidt (Vec4, Vec4)
instance GramSchmidt (Vec3, Vec3)
instance GramSchmidt (Vec2, Vec2)


-- | Rotation around an arbitrary plane in four dimensions, and other
--   miscellanea. Not very useful for most people, and not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Float.Util.Dim4
structVec4 :: [Float] -> [Vec4]
destructVec4 :: [Vec4] -> [Float]
translate4X :: Float -> Vec4 -> Vec4
translate4Y :: Float -> Vec4 -> Vec4
translate4Z :: Float -> Vec4 -> Vec4
translate4W :: Float -> Vec4 -> Vec4
vec4X :: Vec4
vec4Y :: Vec4
vec4Z :: Vec4
vec4W :: Vec4

-- | If <tt>(x,y,u,v)</tt> is an orthonormal system, then (written in
--   pseudo-code) <tt>biVector4 (x,y) = plusMinus (reverse $ biVector4
--   (u,v))</tt>. This is a helper function for the 4 dimensional rotation
--   code. If <tt>(x,y,z,p,q,r) = biVector4 a b</tt>, then the
--   corresponding antisymmetric tensor is
--   
--   <pre>
--   [  0  r  q  p ]
--   [ -r  0  z -y ]
--   [ -q -z  0  x ]
--   [ -p  y -x  0 ]
--   </pre>
biVector4 :: Vec4 -> Vec4 -> (Float, Float, Float, Float, Float, Float)

-- | the corresponding antisymmetric tensor
biVector4AsTensor :: Vec4 -> Vec4 -> Mat4

-- | We assume that the axes are normalized and <i>orthogonal</i> to each
--   other!
rotate4' :: Float -> (Normal4, Normal4) -> Vec4 -> Vec4

-- | We assume only that the axes are independent vectors.
rotate4 :: Float -> (Vec4, Vec4) -> Vec4 -> Vec4

-- | Rotation matrix around a plane specified by two normalized and
--   <i>orthogonal</i> vectors. Intended for multiplication on the
--   <i>right</i>!
rotMatrix4' :: Float -> (Normal4, Normal4) -> Mat4

-- | We assume only that the axes are independent vectors.
rotMatrix4 :: Float -> (Vec4, Vec4) -> Mat4


-- | Classic 4x4 projective matrices, encoding the affine transformations
--   of R^3. Our convention is that they are intended for multiplication on
--   the <i>right</i>, that is, they are of the form
--   
--   <pre>
--       _____
--   [  |     |  0  ]
--   [  | 3x3 |  0  ]
--   [  |_____|  0  ]
--   [  p  q  r  1  ]
--   </pre>
--   
--   Please note that by default, OpenGL stores the matrices (in memory) by
--   columns, while we store them by rows; but OpenGL also use the opposite
--   convention (so the OpenGL projective matrices are intended for
--   multiplication on the <i>left</i>). So in effect, they are the same
--   when stored in the memory, say with <tt>poke :: Ptr Mat4 -&gt; Mat4
--   -&gt; IO ()</tt>.
--   
--   Warning: The naming conventions will probably change in the future.
module Data.Vect.Float.Util.Projective
rotMatrixProj4' :: Float -> Normal3 -> Proj4
rotMatrixProj4 :: Float -> Vec3 -> Proj4

-- | synonym for <a>rotateAfterProj4</a>
rotateProj4 :: Float -> Normal3 -> Proj4 -> Proj4

-- | Synonym for <tt>m -&gt; m .*. rotMatrixProj4 angle axis</tt>.
rotateAfterProj4 :: Float -> Normal3 -> Proj4 -> Proj4

-- | Synonym for <tt>m -&gt; rotMatrixProj4 angle axis .*. m</tt>.
rotateBeforeProj4 :: Float -> Normal3 -> Proj4 -> Proj4
scalingUniformProj4 :: Float -> Proj4

-- | Equivalent to <tt>m -&gt; scaling v .*. m</tt>.
scaleBeforeProj4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; m .*. scaling v</tt>.
scaleAfterProj4 :: Vec3 -> Proj4 -> Proj4

-- | Synonym for <a>translateAfter4</a>
translate4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; m .*. translation v</tt>.
translateAfter4 :: Vec3 -> Proj4 -> Proj4

-- | Equivalent to <tt>m -&gt; translation v .*. m</tt>.
translateBefore4 :: Vec3 -> Proj4 -> Proj4


-- | The unit sphere in the space of quaternions has the group structure
--   SU(2) coming from the quaternion multiplication, which is the double
--   cover of the group SO(3) of rotations in R^3. Thus, unit quaternions
--   can be used to encode rotations in 3D, which is a more compact
--   encoding (4 floats) than a 3x3 matrix; however, there are <i>two</i>
--   quaternions corresponding to each rotation.
--   
--   See <a>http://en.wikipedia.org/wiki/Quaternion</a> and
--   <a>http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a>
--   for more information.
module Data.Vect.Float.Util.Quaternion

-- | The type for quaternions.
newtype Quaternion
Q :: Vec4 -> Quaternion

-- | The type for unit quaternions.
newtype UnitQuaternion
U :: Vec4 -> UnitQuaternion

-- | An abbreviated type synonym for quaternions
type Q = Quaternion

-- | An abbreviated type synonym for unit quaternions
type U = UnitQuaternion
unitQ :: Q
zeroQ :: Q
multQ :: Q -> Q -> Q
negQ :: Q -> Q
normalizeQ :: Q -> Q

-- | The inverse quaternion
invQ :: Q -> Q
fromQ :: Q -> Vec4
toQ :: Vec4 -> Q
unitU :: U
multU :: U -> U -> U

-- | The opposite quaternion (which encodes the same rotation)
negU :: U -> U

-- | This is no-op, up to numerical imprecision. However, if you multiply
--   together a large number of unit quaternions, it may be a good idea to
--   normalize the end result.
normalizeU :: U -> U

-- | The inverse of a unit quaternion
invU :: U -> U
fromU :: U -> Vec4
fromU' :: U -> Normal4
mkU :: Vec4 -> U
toU :: Normal4 -> U
unsafeToU :: Vec4 -> U

-- | The <i>left</i> action of unit quaternions on 3D vectors. That is,
--   
--   <pre>
--   actU q1 $ actU q2 v  ==  actU (q1 `multU` q2) v 
--   </pre>
actU :: U -> Vec3 -> Vec3

-- | The quaternion to encode rotation around an axis. Please note that
--   quaternions act on the <i>left</i>, that is
--   
--   <pre>
--   rotU axis1 angl1 *. rotU axis2 angl2 *. v  ==  (rotU axis1 angl1 .*. rotU axis2 angl2) *. v 
--   </pre>
rotU :: Vec3 -> Float -> U
rotU' :: Normal3 -> Float -> U

-- | Interpolation of unit quaternions. Note that when applied to
--   rotations, this may be not what you want, since it is possible that
--   the shortest path in the space of unit quaternions is not the shortest
--   path in the space of rotations; see <a>slerpU</a>!
longSlerpU :: Float -> U -> U -> U

-- | This is shortest path interpolation in the space of rotations; however
--   this is achieved by possibly flipping the first endpoint in the space
--   of quaternions. Thus <tt>slerpU 0.001 q1 q2</tt> may be very far from
--   <tt>q1</tt> (and very close to <tt>negU q1</tt>) in the space of
--   quaternions (but they are very close in the space of rotations).
slerpU :: Float -> U -> U -> U

-- | Makes a rotation matrix (to be multiplied with on the <i>right</i>)
--   out of a unit quaternion:
--   
--   <pre>
--   v .* rightOrthoU (rotU axis angl)  ==  v .* rotMatrix3 axis angl
--   </pre>
--   
--   Please note that while these matrices act on the <i>right</i>,
--   quaternions act on the <i>left</i>; thus
--   
--   <pre>
--   rightOrthoU q1 .*. rightOrthoU q2  ==  rightOrthoU (q2 .*. q1)
--   </pre>
rightOrthoU :: U -> Ortho3

-- | Makes a rotation matrix (to be multiplied with on the <i>left</i>) out
--   of a unit quaternion.
--   
--   <pre>
--   leftOrthoU (rotU axis angl) *. v  ==  v .* rotMatrix3 axis angl
--   </pre>
leftOrthoU :: U -> Ortho3
instance Read Quaternion
instance Show Quaternion
instance Storable Quaternion
instance AbelianGroup Quaternion
instance Vector Quaternion
instance DotProd Quaternion
instance Random Quaternion
instance Interpolate Quaternion
instance Read UnitQuaternion
instance Show UnitQuaternion
instance Storable UnitQuaternion
instance DotProd UnitQuaternion
instance Random UnitQuaternion
instance LeftModule UnitQuaternion Vec3
instance MultSemiGroup UnitQuaternion
instance MultSemiGroup Quaternion
instance UnitVector Quaternion UnitQuaternion


-- | <a>Eq</a>, <a>Num</a> and <a>Fractional</a> instances for vectors and
--   matrices. These make writing code much more convenient, but also much
--   more dangerous; thus you have to import this module explicitely.
--   
--   In the case of Vector instances, all operations are pointwise
--   (including multiplication and division), and scalars are implicitly
--   converted to vectors so that all components of the resulting vectors
--   are the equal to the given scalar. This gives a set of consistent
--   instances.
--   
--   In the case of Matrices, multiplication is usual matrix
--   multiplication, division is not implemented, and scalars are converted
--   to diagonal matrices.
--   
--   <a>abs</a> and <a>signum</a> are implemented to be <a>normalize</a>
--   and <a>norm</a> (in the case of matrices, Frobenius norm).
module Data.Vect.Float.Instances
instance Fractional Mat4
instance Num Mat4
instance Eq Mat4
instance Fractional Mat3
instance Num Mat3
instance Eq Mat3
instance Fractional Mat2
instance Num Mat2
instance Eq Mat2
instance Fractional Vec4
instance Num Vec4
instance Eq Vec4
instance Fractional Vec3
instance Num Vec3
instance Eq Vec3
instance Fractional Vec2
instance Num Vec2
instance Eq Vec2

module Data.Vect.Float


-- | Importing this module is equivalent to importing
--   <a>Data.Vect.Float</a>.
module Data.Vect
