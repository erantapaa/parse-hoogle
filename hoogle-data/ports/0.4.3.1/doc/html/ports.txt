-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Haskell Ports Library
--   
--   The Haskell Ports Library (HPL) supports <i>concurrent</i> and
--   <i>distributed Haskell</i> programming in the IO monad _without_
--   relying on mutable variables. Instead, it supplies monotone
--   single-assignment variable and ports abstractions.
@package ports
@version 0.4.3.1

module Control.Concurrent.PortsConfig
debug :: Bool

module Control.Concurrent.PortsVersion
version :: [Char]
copyright :: [Char]
disclaimer :: [Char]

module Control.Concurrent.ThreadUtils
(<&>) :: IO (a -> b) -> IO a -> IO b
(&>) :: (a -> b) -> (IO a -> IO b)
(&) :: IO a -> IO b -> IO (a, b)

-- | Sparks off a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight thread; if you want to use a
--   foreign library that uses thread-local storage, use
--   Control.Concurrent.forkOS instead.
--   
--   GHC note: the new thread inherits the <i>blocked</i> state of the
--   parent (see Control.Exception.block).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions BlockedOnDeadMVar, BlockedIndefinitely, and
--   <a>ThreadKilled</a>, and passes all other exceptions to the uncaught
--   exception handler (see <a>setUncaughtExceptionHandler</a>).
forkIO :: IO () -> IO ThreadId

module Control.Concurrent.SVars
data V a
newV :: IO (V a)
valV :: V a -> a
(<<) :: V a -> a -> IO ()

module Control.Concurrent.Ports
type PortFilter a = a -> a -> Maybe a
type PortNotifier a = a -> IO ()
data Port a
withPorts :: [(String, IO ())] -> ([String] -> IO ()) -> IO ()
newPort :: a -> IO (Port a)
listenToNewPort :: a -> IO (Port a, [a])
newFilteringPort :: a -> PortFilter a -> IO (Port a)
newProxyPort :: a -> PortNotifier a -> IO (Port a, PortNotifier a)

-- | Open given port another time to allow for repeated closing.
--   
--   FIXME: Should this better pass out a new port value? Then, closing
--   that new port handle while not closing the whole port should
--   invalidate that new handle. (Would probably, at least, be nicer for
--   debugging.)
openPort :: Port a -> IO ()

-- | Close a port.
--   
--   <ul>
--   <li>If the port has been opened multiple times, it can be closed the
--   corresponding number of times before it will be irrevocably shut,
--   whereby creation of a port counts as one opening.</li>
--   <li>Closing an already closed port is a no-op.</li>
--   </ul>
closePort :: Port a -> IO ()

-- | Check whether a given port is closed.
--   
--   <ul>
--   <li>ATTENTION: This routine is a potential source of race conditions.
--   Use with care. If this routine returns <a>False</a>, the state of the
--   port may have changed by the time the return value is inspected.</li>
--   </ul>
isClosedPort :: Port a -> IO Bool
waitUntilClosedPort :: Port a -> IO ()
keepAlivePort :: Port a -> IO ()

-- | Associate a thread with a port
--   
--   <ul>
--   <li>Sets the thread id and a synchronisation variable that will be set
--   by the thread when it terminates</li>
--   </ul>
setThreadInfo :: Port a -> ThreadId -> MVar () -> IO ()

-- | Synchronise on the synchronisation variable in a port's thread info,
--   which is set as soon as the thread terminates.
--   
--   <ul>
--   <li>If a thread is associate with more than one port, waiting for any
--   or all ports will have the same effect</li>
--   </ul>
--   
--   FIXME: should we also wait until the port is closed? (if the thread
--   traverses the whole port stream stream, it won't terminate until the
--   port is closed anyway)
waitForThread :: Port a -> IO ()

-- | Synchronise on a port being closed.
--   
--   FIXME: It would be more efficient if a port would keep a list of
--   threads to notify when a port is being closed.
waitForPort :: Port a -> IO ()

-- | Wait until both the port is closed and the corresponding thread has
--   terminated.
waitForPortThread :: Port a -> IO ()

-- | Ensure that the port is closed before waiting for the associated
--   thread to terminate.
closeAndWaitForPort :: Port a -> IO ()
listenToPort :: Port a -> IO [a]
(<--) :: Port a -> a -> IO ()
(<==) :: Port a -> [a] -> IO ()
(<-$) :: Port a -> (a -> a) -> IO ()
chainPorts :: (a -> b) -> Port a -> Port b -> IO ()
linkPorts :: (a -> b) -> (b -> a) -> Port a -> Port b -> IO ()
(<->) :: Port a -> Port a -> IO ()
peekIntoPort :: Port a -> IO (Maybe a)
keepAliveForkIO :: IO () -> IO ThreadId
instance Eq MsgKind


-- | Haskell Ports Library: ports consumed in a specific thread
--   
--   Author : Manuel M T Chakravarty Created: 18 June 2003
--   
--   Version $Revision: 1.1 $ from $Date: 2003<i>06</i>22 15:25:32 $
--   
--   Copyright (c) 2003 Manuel M T Chakravarty
--   
--   This library is free software; you can redistribute it and/or modify
--   it under the terms of the GNU Library General Public License as
--   published by the Free Software Foundation; either version 2 of the
--   License, or (at your option) any later version.
--   
--   This library is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   Library General Public License for more details.
module Control.Concurrent.PortThreads

-- | Fork a thread listening to a newly generated port
--   
--   FIXME: should this be called newPort?
spawn :: a -> ([a] -> IO ()) -> IO (Port a)
spawn_ :: ([a] -> IO ()) -> IO (Port a)
spawn2 :: a -> b -> ([a] -> [b] -> IO ()) -> IO (Port a, Port b)
spawn2_ :: ([a] -> [b] -> IO ()) -> IO (Port a, Port b)

module Control.Concurrent.Processes
type Proc = String -> Port Char -> Port Char -> IO ProcId
data ProcId
toProc :: (String -> String) -> Proc

-- | Execute a sub-process asynchronously.
--   
--   <ul>
--   <li>The sub-process reads stdin from a lazy list and writes stdout and
--   stderr to a port. These two ports are closed when the stdout and
--   stderr streams are closed.</li>
--   <li>The executable is searched for in the current PATH.</li>
--   </ul>
proc :: FilePath -> [String] -> Proc

-- | Execute a sub-process asynchronously in it's own process group.
--   
--   <ul>
--   <li>The sub-process reads stdin from a lazy list and writes stdout and
--   stderr to a port. These two ports are closed when the stdout and
--   stderr streams are closed.</li>
--   <li>The executable is searched for in the current PATH.</li>
--   <li>The process group id is the same as the new process' process
--   id.</li>
--   </ul>
procGrp :: FilePath -> [String] -> Proc
(>|) :: Proc -> Proc -> Proc

-- | Process operators ------------------
--   
--   Returns the exit status of the given process (group).
--   
--   <ul>
--   <li>Blocks until the value is available.</li>
--   <li>In case of a <a>NoProcId</a>, the availability of the unit
--   argument implements a synchronisation point.</li>
--   <li>In case of a process group, the status is <a>ExitSuccess</a> iff
--   the exit status of all processes is <a>ExitSuccess</a>; otherwise, it
--   is the failure status of any of the failed processes (it is, of
--   course, always deterministically the same, which is picked).</li>
--   </ul>
procStatus :: ProcId -> ExitCode

-- | Signal a process.
procKill :: Signal -> ProcId -> IO ()

-- | Signal a process group.
procGrpKill :: Signal -> ProcId -> IO ()


-- | Haskell Ports Library: main interface to the outside world
--   
--   Author : Manuel M. T. Chakravarty Created: 14 May 2001
--   
--   Version $Revision: 1.3 $ from $Date: 2003<i>06</i>22 15:25:32 $
--   
--   Copyright (c) 2001 Manuel M. T. Chakravarty
--   
--   This file is free software; you can redistribute it and/or modify it
--   under the terms of the GNU General Public License as published by the
--   Free Software Foundation; either version 2 of the License, or (at your
--   option) any later version.
--   
--   This file is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   General Public License for more details.
module Control.Concurrent.HPL
version :: [Char]
copyright :: [Char]
disclaimer :: [Char]
