-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A file-finding conduit that allows user control over traversals.
--   
@package find-conduit
@version 0.4.4

module Data.Cond

-- | <a>CondT</a> is a kind of <tt>StateT a (MaybeT m) b</tt>, which uses a
--   special <a>Result</a> type instead of <a>Maybe</a> to express whether
--   recursion should be performed from the item under consideration. This
--   is used to build predicates that can guide recursive traversals.
--   
--   Several different types may be promoted to <a>CondT</a>:
--   
--   <ul>
--   <li><i><tt>Bool</tt></i> Using <a>guard</a></li>
--   <li><i><tt>m Bool</tt></i> Using <a>guardM</a></li>
--   <li><i><tt>a -&gt; Bool</tt></i> Using <a>guard_</a></li>
--   <li><i><tt>a -&gt; m Bool</tt></i> Using <a>guardM_</a></li>
--   <li><i><tt>a -&gt; m (Maybe b)</tt></i> Using <a>apply</a></li>
--   <li><i><tt>a -&gt; m (Maybe (b, a))</tt></i> Using
--   <a>consider</a></li>
--   </ul>
--   
--   Here is a trivial example:
--   
--   <pre>
--   flip runCondT 42 $ do
--     guard_ even
--     liftIO $ putStrLn "42 must be even to reach here"
--     guard_ odd &lt;|&gt; guard_ even
--     guard_ (== 42)
--   </pre>
--   
--   If <a>CondT</a> is executed using <a>runCondT</a>, it return a
--   <tt>Maybe b</tt> if the predicate matched. It can also be run with
--   <a>applyCondT</a>, which does case analysis on the <a>Result</a>,
--   specifying how recursion should be performed from the given <tt>a</tt>
--   value.
newtype CondT a m b
CondT :: StateT a m (Result a m b) -> CondT a m b
getCondT :: CondT a m b -> StateT a m (Result a m b)
type Cond a = CondT a Identity
runCondT :: Monad m => CondT a m b -> a -> m (Maybe b)
runCond :: Cond a b -> a -> Maybe b

-- | Case analysis of applying a condition to an input value. The result is
--   a pair whose first part is a pair of Maybes specifying if the input
--   matched and if recursion is expected from this value, and whose second
--   part is the (possibly) mutated input value.
applyCondT :: Monad m => a -> CondT a m b -> m ((Maybe b, Maybe (CondT a m b)), a)

-- | Case analysis of applying a pure condition to an input value. The
--   result is a pair whose first part is a pair of Maybes specifying if
--   the input matched and if recursion is expected from this value, and
--   whose second part is the (possibly) mutated input value.
applyCond :: a -> Cond a b -> ((Maybe b, Maybe (Cond a b)), a)
guardM :: Monad m => m Bool -> CondT a m ()
guard_ :: Monad m => (a -> Bool) -> CondT a m ()
guardM_ :: Monad m => (a -> m Bool) -> CondT a m ()
apply :: Monad m => (a -> m (Maybe b)) -> CondT a m b
consider :: Monad m => (a -> m (Maybe (b, a))) -> CondT a m b

-- | Return True or False depending on whether the given condition matches
--   or not. This differs from simply stating the condition in that it
--   itself always succeeds.
--   
--   <pre>
--   &gt;&gt;&gt; flip runCond "foo.hs" $ matches (guard =&lt;&lt; asks (== "foo.hs"))
--   Just True
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ matches (guard =&lt;&lt; asks (== "foo.hi"))
--   Just False
--   </pre>
matches :: Monad m => CondT a m b -> CondT a m Bool

-- | A variant of ifM which branches on whether the condition succeeds or
--   not. Note that <tt>if_ x</tt> is equivalent to <tt>ifM (matches
--   x)</tt>, and is provided solely for convenience.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ if_ good (return "Success") (return "Failure")
--   Just "Success"
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ if_ bad (return "Success") (return "Failure")
--   Just "Failure"
--   </pre>
if_ :: Monad m => CondT a m r -> CondT a m b -> CondT a m b -> CondT a m b

-- | <a>when_</a> is just like <a>when</a>, except that it executes the
--   body if the condition passes, rather than based on a Bool value.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ when_ good ignore
--   Nothing
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ when_ bad ignore
--   Just ()
--   </pre>
when_ :: Monad m => CondT a m r -> CondT a m () -> CondT a m ()

-- | <a>when_</a> is just like <a>when</a>, except that it executes the
--   body if the condition fails, rather than based on a Bool value.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ unless_ bad ignore
--   Nothing
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ unless_ good ignore
--   Just ()
--   </pre>
unless_ :: Monad m => CondT a m r -> CondT a m () -> CondT a m ()

-- | Check whether at least one of the given conditions is true. This is a
--   synonym for <a>asum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ or_ [bad, good]
--   Just ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ or_ [bad]
--   Nothing
--   </pre>
or_ :: Monad m => [CondT a m b] -> CondT a m b

-- | Check that all of the given conditions are true. This is a synonym for
--   <a>sequence_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ and_ [bad, good]
--   Nothing
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ and_ [good]
--   Just ()
--   </pre>
and_ :: Monad m => [CondT a m b] -> CondT a m ()

-- | <a>not_</a> inverts the meaning of the given predicate.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ not_ bad &gt;&gt; return "Success"
--   Just "Success"
--   
--   &gt;&gt;&gt; flip runCond "foo.hs" $ not_ good &gt;&gt; return "Shouldn't reach here"
--   Nothing
--   </pre>
not_ :: Monad m => CondT a m b -> CondT a m ()

-- | <a>ignore</a> ignores the current entry, but allows recursion into its
--   descendents. This is the same as <a>mzero</a>.
ignore :: Monad m => CondT a m b

-- | <a>norecurse</a> prevents recursion into the current entry's
--   descendents, but does not ignore the entry itself.
norecurse :: Monad m => CondT a m ()

-- | <a>prune</a> is a synonym for both ignoring an entry and its
--   descendents. It is the same as <tt>ignore &gt;&gt; norecurse</tt>.
prune :: Monad m => CondT a m b

-- | <a>recurse</a> changes the recursion predicate for any child elements.
--   For example, the following file-finding predicate looks for all
--   <tt>*.hs</tt> files, but under any <tt>.git</tt> directory looks only
--   for a file named <tt>config</tt>:
--   
--   <pre>
--   if_ (name_ ".git" &gt;&gt; directory)
--       (ignore &gt;&gt; recurse (name_ "config"))
--       (glob "*.hs")
--   </pre>
--   
--   NOTE: If this code had used <tt>recurse (glob "*.hs"))</tt> instead in
--   the else case, it would have meant that <tt>.git</tt> is only looked
--   for at the top-level of the search (i.e., the top-most element).
recurse :: Monad m => CondT a m b -> CondT a m b

-- | A specialized variant of <a>runCondT</a> that simply returns True or
--   False.
--   
--   <pre>
--   &gt;&gt;&gt; let good = guard_ (== "foo.hs") :: Cond String ()
--   
--   &gt;&gt;&gt; let bad  = guard_ (== "foo.hi") :: Cond String ()
--   
--   &gt;&gt;&gt; runIdentity $ test "foo.hs" $ not_ bad &gt;&gt; return "Success"
--   True
--   
--   &gt;&gt;&gt; runIdentity $ test "foo.hs" $ not_ good &gt;&gt; return "Shouldn't reach here"
--   False
--   </pre>
test :: Monad m => a -> CondT a m b -> m Bool

-- | This type is for documentation only, and shows the isomorphism between
--   <a>CondT</a> and <a>CondEitherT</a>. The reason for using
--   <a>Result</a> is that it makes meaning of the constructors more
--   explicit.
newtype CondEitherT a m b
CondEitherT :: (StateT a (EitherT (Maybe (Maybe (CondEitherT a m b))) m) (b, Maybe (Maybe (CondEitherT a m b)))) -> CondEitherT a m b

-- | Witness one half of the isomorphism from <a>CondT</a> to
--   <a>CondEitherT</a>.
fromCondT :: Monad m => CondT a m b -> CondEitherT a m b

-- | Witness the other half of the isomorphism from <a>CondEitherT</a> to
--   <a>CondT</a>.
toCondT :: Monad m => CondEitherT a m b -> CondT a m b
instance MFunctor (CondT a)
instance MonadBaseControl b m => MonadBaseControl b (CondT r m)
instance MonadTrans (CondT a)
instance MonadIO m => MonadIO (CondT a m)
instance MonadBase b m => MonadBase b (CondT a m)
instance MonadMask m => MonadMask (CondT a m)
instance MonadCatch m => MonadCatch (CondT a m)
instance MonadThrow m => MonadThrow (CondT a m)
instance Monad m => MonadPlus (CondT a m)
instance Monad m => Alternative (CondT a m)
instance Monad m => MonadState a (CondT a m)
instance Monad m => MonadReader a (CondT a m)
instance Monad m => Monad (CondT a m)
instance Monad m => Applicative (CondT a m)
instance Monad m => Functor (CondT a m)
instance (Monad m, Monoid b) => Monoid (CondT a m b)
instance (Monad m, Semigroup b) => Semigroup (CondT a m b)
instance Show (CondT a m b)
instance Monoid b => Monoid (Result a m b)
instance Semigroup (Result a m b)
instance MFunctor (Result a)
instance Monad m => Functor (Result a m)
instance Show b => Show (Result a m b)

module Data.Conduit.Find

-- | Find file entries in a directory tree, recursively, applying the given
--   recursion predicate to the search. This conduit yields pairs of type
--   <tt>(FileEntry, a)</tt>, where is the return value from the predicate
--   at each step.
sourceFindFiles :: (MonadIO m, MonadResource m) => FindOptions -> FilePath -> CondT FileEntry m a -> Producer m (FileEntry, a)

-- | Calls <a>findFilePaths</a> with the default set of finding options.
--   Equivalent to <tt>findFilePaths defaultFindOptions</tt>.
find :: (MonadIO m, MonadResource m) => FilePath -> CondT FileEntry m a -> Producer m FilePath
findFiles :: (MonadIO m, MonadBaseControl IO m, MonadThrow m) => FindOptions -> FilePath -> CondT FileEntry m a -> m ()

-- | A simpler version of <a>findFiles</a>, which yields only
--   <a>FilePath</a> values, and ignores any values returned by the
--   predicate action.
findFilePaths :: (MonadIO m, MonadResource m) => FindOptions -> FilePath -> CondT FileEntry m a -> Producer m FilePath
data FindOptions
FindOptions :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> FindOptions
findFollowSymlinks :: FindOptions -> !Bool
findContentsFirst :: FindOptions -> !Bool
findIgnoreErrors :: FindOptions -> !Bool
findIgnoreResults :: FindOptions -> !Bool
findLeafOptimization :: FindOptions -> !Bool
defaultFindOptions :: FindOptions

-- | Test a file path using the same type of predicate that is accepted by
--   <a>findFiles</a>.
test :: MonadIO m => CondT FileEntry m () -> FilePath -> m Bool

-- | Test a file path using the same type of predicate that is accepted by
--   <a>findFiles</a>, but do not follow symlinks.
ltest :: MonadIO m => CondT FileEntry m () -> FilePath -> m Bool
stat :: MonadIO m => CondT FileEntry m FileStatus
lstat :: MonadIO m => CondT FileEntry m FileStatus
hasStatus :: MonadIO m => (FileStatus -> Bool) -> CondT FileEntry m ()

-- | Find every entry whose filename part matching the given filename
--   globbing expression. For example: <tt>glob "*.hs"</tt>.
glob :: Monad m => String -> CondT FileEntry m ()
regex :: Monad m => String -> CondT FileEntry m ()

-- | Return all entries, except for those within version-control metadata
--   directories (and not including the version control directory itself
--   either).
ignoreVcs :: Monad m => CondT FileEntry m ()
depth_ :: Monad m => CondT FileEntry m ()
follow_ :: Monad m => CondT FileEntry m ()
noleaf_ :: Monad m => CondT FileEntry m ()
prune_ :: Monad m => CondT a m ()
maxdepth_ :: Monad m => Int -> CondT FileEntry m ()
mindepth_ :: Monad m => Int -> CondT FileEntry m ()
ignoreErrors_ :: Monad m => CondT FileEntry m ()
noIgnoreErrors_ :: Monad m => CondT FileEntry m ()
amin_ :: MonadIO m => Int -> CondT FileEntry m ()
atime_ :: MonadIO m => Int -> CondT FileEntry m ()
anewer_ :: MonadIO m => FilePath -> CondT FileEntry m ()
empty_ :: MonadIO m => CondT FileEntry m ()
executable_ :: MonadIO m => CondT FileEntry m ()
gid_ :: MonadIO m => Int -> CondT FileEntry m ()
name_ :: Monad m => FilePath -> CondT FileEntry m ()
getDepth :: Monad m => CondT FileEntry m Int
filename_ :: Monad m => (FilePath -> Bool) -> CondT FileEntry m ()
pathname_ :: Monad m => (FilePath -> Bool) -> CondT FileEntry m ()
getFilePath :: Monad m => CondT FileEntry m FilePath
regular :: MonadIO m => CondT FileEntry m ()
directory :: MonadIO m => CondT FileEntry m ()
hasMode :: MonadIO m => FileMode -> CondT FileEntry m ()
executable :: MonadIO m => CondT FileEntry m ()
lastAccessed_ :: MonadIO m => (UTCTime -> Bool) -> CondT FileEntry m ()
lastModified_ :: MonadIO m => (UTCTime -> Bool) -> CondT FileEntry m ()
(=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
data FileEntry
FileEntry :: !FilePath -> !Int -> !FindOptions -> !(Maybe FileStatus) -> FileEntry
entryPath :: FileEntry -> !FilePath
entryDepth :: FileEntry -> !Int
entryFindOptions :: FileEntry -> !FindOptions

-- | This is Nothing until we determine stat should be called.
entryStatus :: FileEntry -> !(Maybe FileStatus)
instance Show FileEntry
