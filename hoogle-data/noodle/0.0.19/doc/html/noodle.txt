-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | the noodle programming language
--   
--   The <tt>noodle</tt> Programming Language Interpreter
--   
--   Noodle is two things. It is a programming language, and it is this
--   implementation of that programming language.
--   
--   <i>Briefly...</i>
--   
--   Noodle (the language) is functional, latently typed, and statically
--   scoped. Noodle has no language level concept of mutable state. Data
--   abstraction is handled with 'scope bound' wrappers that prevent
--   pattern matching on some value outside of some mutually recursive
--   scope. Numbers are arbitrary precision integer ratios. Operators are
--   (possibly) high order functions with special application rules that
--   omit evaluation of the right operand if their application to the left
--   operand does not return a function. Modules are mutually recursive
--   internally, are first class, and can be parameterized by constructing
--   them with functions. Rather than arrays or linked lists, the most
--   basic compound data structure in noodle is a binary tree, or
--   <a>product</a>.
--   
--   the primary points of interest in this package are:
--   
--   <ul>
--   <li><i><tt>noodle</tt></i> the option directed command line
--   interface</li>
--   <li><i><tt>noodle-repl</tt></i> the read-eval-print-loop</li>
--   <li><i><tt>noodle-eval</tt></i> an interface for evaluating a single
--   noodle expression (computation) from stdin</li>
--   </ul>
--   
--   You may also incorporate noodle into your own program as a library,
--   but this is <i>even less documented</i> than the <i>completely
--   undocumented</i> command line interface... so I don't know why you
--   would want to do this.
@package noodle
@version 0.0.19


-- | GParser is a generalized backtracking parser combinator with state,
--   error propogation and easy to use associativity primitves.
module Language.Noodle.Parsing.Generic

-- | <a>Result</a> encompases error propogation, parameterized over
--   <tt>st</tt> state type, <tt>tok</tt> token type, and <tt>res</tt> the
--   monadic return value
data Result st tok res

-- | 'Success result state token_stream'
Success :: res -> st -> [tok] -> Result st tok res

-- | 'Failure error_message state'
Failure :: String -> st -> Result st tok res

-- | a <a>GParser</a> computes some result <tt>res</tt>, based on a stream
--   of tokens <tt>tok</tt> having a state of type <tt>st</tt>
newtype GParser st tok res
P :: ((st, [tok]) -> Result st tok res) -> GParser st tok res

-- | consume one token and return it
getTok :: GParser st tok tok

-- | lookahead at the rest of the tokens left in the input
lookToks :: GParser st tok [tok]

-- | consume one token and return it if the result of applying the
--   predicate to it is true, otherwise fail with 'unexpected token'
getTokIf :: (tok -> Bool) -> GParser st tok tok

-- | succeed if all of the input has been consumed, otherwise complain
--   about expecting the end of the input
inputEnd :: GParser st tok ()

-- | return the current state
getSt :: GParser st tok st

-- | change the value of the current state
putSt :: st -> GParser st tok ()

-- | apply some update function to the current state
modSt :: (st -> st) -> GParser st tok ()

-- | apply the parser as many times as is possible, and return a list of
--   the results
many :: GParser st tok res -> GParser st tok [res]

-- | apply the parser one or more times, and return a list of the results.
--   Fails the first application fails
many1 :: GParser st tok res -> GParser st tok [res]

-- | parse many1 p's seperated by sep
sepBy1 :: GParser st tok res -> GParser st tok b -> GParser st tok [res]

-- | parse many p's seperated by sep
sepBy :: GParser st tok res -> GParser st tok b -> GParser st tok [res]

-- | if the left operand <a>|</a> results in failure, apply the right
--   operand. state and token stream changes are not carried over to right
--   operand
(<|>) :: GParser st tok res -> GParser st tok res -> GParser st tok res

-- | the first successful parser to succeed is parsed, if none, fail
choice :: [GParser st tok res] -> GParser st tok res

-- | try to apply parser p, return Just res on success, or Nothing on fail
pMaybe :: GParser st tok res -> GParser st tok (Maybe res)

-- | try to parse either p1 or p2, returning Left a for p1, or Right b for
--   p2
pEither :: GParser st tok a -> GParser st tok b -> GParser st tok (Either a b)

-- | apply a <a>GParser</a> computation to state and a token stream,
--   returning a value of type <a>Result</a>
runp :: GParser st tok res -> st -> [tok] -> Result st tok res
instance Monad (GParser s t)
instance (Show st, Show tok, Show res) => Show (Result st tok res)

module Language.Noodle.Parsing.Positional
getSt :: PosParser st tok st
putSt :: st -> PosParser st tok ()
modSt :: (st -> st) -> PosParser st tok ()
startPos :: Position
getPos :: PosParser st tok Position
incPos :: PosParser st tok ()
incLine :: PosParser st tok ()
type Position = (Int, Int, Int)
type PosParser st tok res = GParser (PosSt st) tok res

module Language.Noodle.Parsing.String
type Parser st res = PosParser st Char res
char :: Char -> Parser st Char
satisfy :: (Char -> Bool) -> Parser st Char
oneOf :: [Char] -> Parser st Char
string :: String -> Parser st String
whiteChar :: Parser st Char
whiteSpace :: Parser st String
alphaLower :: Parser st Char
alphaUpper :: Parser st Char
digit :: Parser st Char

module Language.Noodle.Syntax
data Decl
IntThunk :: String -> Comp -> Decl
IntFun :: Pattern -> String -> Comp -> Decl
IntOp :: Pattern -> String -> Pattern -> Comp -> Decl
IntMod :: String -> Decls -> Decl
data Decls
Decls :: [Decl] -> Decls
toDecList :: Decls -> [Decl]
data Comp
In :: Decls -> Comp -> Comp
With :: Comp -> Comp -> Comp
PatMatch :: Pattern -> Comp -> Comp -> Comp
Handler :: Comp -> Comp -> Comp
ExprComp :: Expr -> Comp
data Expr
ExprApp :: Expr -> Expr -> Expr
ExprOp :: Expr -> String -> Expr -> Expr
ModRef :: String -> Expr
Lit :: (Literal Comp) -> Expr
showClause :: (String, String) -> String
newtype Pattern
Pat :: (Literal Pattern) -> Pattern
data Literal a
Numb :: Integer -> Literal a
Ident :: String -> Literal a
Symb :: String -> Literal a
StrLit :: String -> Literal a
ProdLit :: a -> a -> [a] -> Literal a
Abs :: a -> Literal a
Paren :: a -> Literal a
instance Show a => Show (Literal a)
instance Show Pattern
instance Show Decls
instance Show Decl
instance Show Comp
instance Show Expr

module Language.Noodle.Parsing.Noodle
type NParser a = Parser () a
topDecls :: NParser Decls
decls :: NParser Decls
decl :: NParser Decl
comp :: NParser Comp
clause :: NParser a -> NParser b -> NParser (a, b)
block :: NParser a -> NParser a
expr :: GParser (PosSt ()) Char Expr
exprOp :: GParser (PosSt ()) Char Expr
exprApp :: GParser (PosSt ()) Char Expr
modRef :: GParser (PosSt ()) Char Expr
exprLit :: GParser (PosSt ()) Char Expr
pattern :: NParser Pattern
literal :: NParser a -> NParser (Literal a)
identifier :: GParser (PosSt ()) Char (Literal a)
number :: GParser (PosSt ()) Char (Literal a)
paren :: GParser (PosSt ()) Char a -> GParser (PosSt ()) Char (Literal a)
isReserved :: String -> Bool
reserved :: String -> NParser ()
lBrace :: NParser ()
rBrace :: NParser ()
lParen :: NParser ()
rParen :: NParser ()
ident :: NParser String
symbLit :: NParser (Literal a)
prodLit :: NParser a -> NParser (Literal a)
absLit :: GParser (PosSt ()) Char a -> GParser (PosSt ()) Char (Literal a)
oper :: NParser String
numeric :: NParser String
opChar :: NParser Char
opChars :: GParser (PosSt ()) Char [Char]
stringLit :: NParser (Literal a)
notcode :: NParser ()
comment :: NParser String

module Language.Noodle.DepTree
data SourceFile
SF :: FilePath -> FilePath -> String -> [SourceFile] -> SourceFile
srcName :: SourceFile -> FilePath
srcDir :: SourceFile -> FilePath
srcBody :: SourceFile -> String
srcDeps :: SourceFile -> [SourceFile]
parseDeps :: [FilePath] -> FilePath -> IO (Either String SourceFile)
instance Show SourceFile

module Language.Noodle.Evaluation
compile :: Env -> String -> Val
compileFile :: Env -> FilePath -> IO Val
compute :: Env -> Comp -> IO Val
declare :: Env -> Decls -> IO (Either String Env)
extfun :: (Val -> IO Val) -> Val
extop :: (Val -> Val -> IO Val) -> Val
extenv :: [(String, Val)] -> Env
extmod :: Env -> Val
showAst :: String -> String
rtError :: Val -> Val
srtError :: String -> Val
data Error
BadParse :: String -> Int -> Int -> String -> Error
data Env
Env :: Unique -> Env -> [(Name, Val)] -> Env
Bar :: Env -> Env
Top :: Env
type Name = String
data Val
Function :: (Val -> IO Val) -> Val
Thunk :: (IO Val) -> Val
Module :: (IO Env) -> Val
Error :: Error -> Val
Number :: Rational -> Val
Symbol :: String -> Val
Str :: String -> Val
Prod :: Val -> Val -> Val
Extern :: Dynamic -> Val
Abst :: (Maybe Unique) -> Val -> Val
Nil :: Val
instance Eq Env
instance Eq Val
instance Show Error
instance Show Val

module Language.Noodle.Lib.String
env :: Env
decls :: [([Char], Val)]

module Language.Noodle.Lib.Boolean
env :: Env
decls :: [([Char], Val)]

module Language.Noodle.Lib.Math
env :: Env
decls :: [([Char], Val)]

module Language.Noodle.Lib.IO
decls :: [([Char], Val)]
env :: Env

module Language.Noodle.Lib.Prod
env :: Env
decls :: [([Char], Val)]

module Language.Noodle.Lib.Function
env :: Env
decls :: [([Char], Val)]

module Language.Noodle.Lib.Basic
env :: Env
decls :: [(String, Val)]

module Language.Noodle.Banner
text :: [Char]
