-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A truth table generator for classical propositional logic.
--   
--   Hatt is a command-line program which prints truth tables for
--   expressions in classical propositional logic, and a library allowing
--   its parser, evaluator and truth table generator to be used in other
--   programs. It includes support for converting logical expressions into
--   several normal forms.
@package hatt
@version 1.5.0.3


-- | This module contains the truth table generating functionality of Hatt.
--   The core function it exports is <a>truthTable</a> which prints the
--   truth table of the given expression. <a>truthTableP</a> is a
--   configurable version which allows one to select how to print
--   expressions and truth values. This gives one the option of, for
--   example, colouring outputs and changing the symbols used to represent
--   the logical connectives.
module Data.Logic.Propositional.Tables
type Printer = (Expr -> String, Bool -> String)

-- | Prints a green <tt>T</tt> for <a>True</a> and a red <tt>F</tt> for
--   <a>False</a>. This is used when producing a string representation of a
--   truth table with <a>truthTable</a>. It can also be used as (as the
--   second component of a <a>Printer</a> pair) as an argument to the
--   configurable <a>truthTableP</a> function.
colourBool :: Bool -> String

-- | Prints <tt>T</tt> for <a>True</a> and <tt>F</tt> for <a>False</a>.
showBool :: Bool -> String

-- | The <a>truthTable</a> function produces a truth table for the given
--   expression.
truthTable :: Expr -> String

-- | The <a>truthTableP</a> is a configurable version of <a>truthTable</a>
--   which allows a printer function to be selected, so for example one can
--   print ASCII truth tables by passing <a>showAscii</a> to
--   <a>truthTableP</a> instead of <a>show</a>.
truthTableP :: Printer -> Expr -> String


-- | The functions exposed by this module convert expressions of type
--   <a>Expr</a> into different normal forms: negation normal form via
--   <a>toNNF</a>, conjunctive normal form via <a>toCNF</a> and disjunctive
--   normal form via <a>toDNF</a>. All these functions are total.
module Data.Logic.Propositional.NormalForms

-- | The <a>toNNF</a> function converts expressions to negation normal
--   form. This function is total: it's defined for all expressions, not
--   just those which only use negation, conjunction and disjunction,
--   although all expressions in negation normal form do in fact only use
--   those connectives.
--   
--   The conversion is carried out by replacing any condtitionals or
--   biconditionals with equivalent expressions using only negation,
--   conjunction and disjunction. Then de Morgan's laws are applied to
--   convert negated conjunctions and disjunctions into the conjunction or
--   disjunction of the negation of their conjuncts: <tt>¬(φ ∧ ψ)</tt> is
--   converted to <tt>(¬φ ∨ ¬ψ)</tt> while <tt>¬(φ ∨ ψ)</tt> becomes
--   <tt>(¬φ ∧ ¬ψ)</tt>.
toNNF :: Expr -> Expr

-- | The <a>toCNF</a> function converts expressions to conjunctive normal
--   form: a conjunction of clauses, where a clause is a disjunction of
--   literals (variables and negated variables).
--   
--   The conversion is carried out by first converting the expression into
--   negation normal form, and then applying the distributive law.
--   
--   Because it first applies <a>toNNF</a>, it is a total function and can
--   handle expressions which include conditionals and biconditionals.
toCNF :: Expr -> Expr

-- | The <a>toDNF</a> function converts expressions to disjunctive normal
--   form: a disjunction of clauses, where a clause is a conjunction of
--   literals (variables and negated variables).
--   
--   The conversion is carried out by first converting the expression into
--   negation normal form, and then applying the distributive law.
--   
--   Because it first applies <a>toNNF</a>, it is a total function and can
--   handle expressions which include conditionals and biconditionals.
toDNF :: Expr -> Expr


-- | The <a>Data.Logic.Propositional</a> module provides a set of functions
--   for parsing, manipulating and generating truth tables for expressions
--   in classical propositional logic.
--   
--   The core of the API is the <a>Expr</a> data type, which has
--   constructors for all the usual expression forms: variables, standing
--   for atomic propositions; negation, the only unary connective; and the
--   binary connectives of conjunction, disjunction, material implication
--   and logical equivalence.
module Data.Logic.Propositional
data Expr
Variable :: Var -> Expr
Negation :: Expr -> Expr
Conjunction :: Expr -> Expr -> Expr
Disjunction :: Expr -> Expr -> Expr
Conditional :: Expr -> Expr -> Expr
Biconditional :: Expr -> Expr -> Expr
newtype Var
Var :: Char -> Var
type Mapping = Map Var Bool

-- | Determines whether two expressions are extensionally equivalent (that
--   is, have the same values under all interpretations).
equivalent :: Expr -> Expr -> Bool

-- | In order to interpret an expression, a mapping from variables to truth
--   values needs to be provided. Truth values are compositional; that's to
--   say, the value of a composite expression (any expression which is not
--   atomic) depends on the truth values of its component parts. For
--   example, the Haskell expression below would evaluate to
--   <tt>False</tt>.
--   
--   <pre>
--   interpret
--       (Conjunction (Variable "A") (Variable "B"))
--       (fromList [("A", True), ("B", False)])
--   </pre>
interpret :: Expr -> Mapping -> Bool

-- | Generates the possible assignments of variables in an expression.
assignments :: Expr -> [Mapping]

-- | Lists the values of an expression under all interpretations (that is,
--   all assignments of values to variables).
values :: Expr -> [Bool]

-- | Lists the names of variables present in an expression.
variables :: Expr -> [Var]

-- | Determines whether an expression is contingent (that is, true in at
--   least one interpretation and false in at least one interpretation).
isContingent :: Expr -> Bool

-- | Determines whether an expression is contradictory.
isContradiction :: Expr -> Bool

-- | Determines whether an expression is tautological.
isTautology :: Expr -> Bool

-- | The <a>parseExpr</a> function accepts the name of a source, and a
--   string to be parsed, and attempts to parse the string as a logical
--   expression of the following forms, where <tt>φ</tt> and <tt>ψ</tt> are
--   metalinguistic variables standing for any valid expression.
--   
--   <ul>
--   <li>Variables: <tt>"P"</tt>, <tt>"Q"</tt>, <tt>"a"</tt>, <tt>"b"</tt>
--   etc.; basically anything in the character class <tt>[a-zA-Z]</tt></li>
--   <li>Negation: <tt>"~φ"</tt></li>
--   <li>Conjunction: <tt>"(φ &amp; ψ)"</tt></li>
--   <li>Disjunction: <tt>"(φ | ψ)"</tt></li>
--   <li>Conditional: <tt>"(φ -&gt; ψ)"</tt></li>
--   <li>Biconditional: <tt>"(φ &lt;-&gt; ψ)"</tt></li>
--   </ul>
--   
--   Top-level expressions where the primary connective is a binary one do
--   not need to be parenthesised. For example, <tt>"p -&gt; (q &amp;
--   r)"</tt> is a valid expression, although <tt>"(p -&gt; (q &amp;
--   r))"</tt> is also fine.
parseExpr :: SourceName -> String -> Either ParseError Expr

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | Represents expressions using only ASCII characters (the <a>show</a>
--   function pretty-prints expressions using logical symbols only present
--   in extended character sets).
showAscii :: Expr -> String

-- | The <a>truthTable</a> function produces a truth table for the given
--   expression.
truthTable :: Expr -> String

-- | The <a>truthTableP</a> is a configurable version of <a>truthTable</a>
--   which allows a printer function to be selected, so for example one can
--   print ASCII truth tables by passing <a>showAscii</a> to
--   <a>truthTableP</a> instead of <a>show</a>.
truthTableP :: Printer -> Expr -> String
