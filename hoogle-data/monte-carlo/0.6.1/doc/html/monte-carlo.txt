-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad and transformer for Monte Carlo calculations.
--   
--   A monad and transformer for performing Monte Carlo calculations. This
--   monad carries and provides access to a pseudo-random number generator.
--   Internally, the monad mutates rather than copies the random gnerator
--   state. By avoiding copies, it can deliver faster performance than many
--   pure random number implementations. The package is built around the
--   facilities provided by the GNU Scientific Library (GSL).
@package monte-carlo
@version 0.6.1


-- | Summary statistics for <tt>Double</tt>s.
module Data.Summary.Double

-- | A type for storing summary statistics for a data set including sample
--   size, min and max values, and first and second moments.
data Summary

-- | Number of observations.
size :: Summary -> Int

-- | Sum of values.
sum :: Summary -> Double

-- | Sum of squared errors <tt>(x[i] - mean)^2</tt>.
sumSquaredErrors :: Summary -> Double

-- | Mean value.
mean :: Summary -> Double

-- | Standard error of the mean.
meanSE :: Summary -> Double

-- | Get a Central Limit Theorem based confidence interval for the
--   population mean with the specified coverage level. The level must be
--   in the range <tt>(0,1)</tt>.
meanCI :: Double -> Summary -> (Double, Double)

-- | Sample standard deviation.
stddev :: Summary -> Double

-- | Sample variance.
variance :: Summary -> Double

-- | Maximum value.
maximum :: Summary -> Double

-- | Minimum value.
minimum :: Summary -> Double

-- | An empty summary.
empty :: Summary

-- | Summarize a single value.
singleton :: Double -> Summary

-- | Update the summary with a data point. Running mean and variance
--   computed as in Knuth, Vol 2, page 232, 3rd edition, see
--   <a>http://www.johndcook.com/standard_deviation.html</a> for a
--   description.
insert :: Double -> Summary -> Summary

-- | Apply a function and update the summary with the result.
insertWith :: (a -> Double) -> a -> Summary -> Summary

-- | Take the union of two summaries. Use the updating rules from Chan et
--   al. "Updating Formulae and a Pairwise Algorithm for Computing Sample
--   Variances," available at
--   <a>http://infolab.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf</a>.
union :: Summary -> Summary -> Summary

-- | Take the union of a list of summaries.
unions :: [Summary] -> Summary

-- | Get a summary of a list of values.
fromList :: [Double] -> Summary

-- | Map a function over a list of values and summarize the results.
fromListWith :: (a -> Double) -> [a] -> Summary

-- | Convert to (size, mean, sumSquaredErrors, minimum, maximum).
toStats :: Summary -> (Int, Double, Double, Double, Double)

-- | Convert from (size, mean, sumSquaredErrors, minimum, maximum). No
--   validation is performed.
fromStats :: Int -> Double -> Double -> Double -> Double -> Summary
instance Typeable Summary
instance Eq Summary
instance Data Summary
instance Monoid Summary
instance Show Summary


-- | Summary statistics for <tt>Bool</tt>s.
module Data.Summary.Bool

-- | A type for storing summary statistics for a data set of booleans.
--   Specifically, this just keeps track of the number of <a>True</a>
--   events and gives estimates for the success probability. <a>True</a> is
--   interpreted as a one, and <a>False</a> is interpreted as a zero.
data Summary

-- | Number of observations.
size :: Summary -> Int

-- | Number of <a>True</a> values.
sum :: Summary -> Int

-- | Proportion of <a>True</a> values.
mean :: Summary -> Double

-- | Standard error for the mean (proportion of <a>True</a> values).
meanSE :: Summary -> Double

-- | Central Limit Theorem based confidence interval for the population
--   mean (proportion) at the specified coverage level. The level must be
--   in the range <tt>(0,1)</tt>.
meanCI :: Double -> Summary -> (Double, Double)

-- | Get an empty summary.
empty :: Summary

-- | Summarize a single value.
singleton :: Bool -> Summary

-- | Update the summary with a data point.
insert :: Bool -> Summary -> Summary

-- | Apply a function and update the summary with the result.
insertWith :: (a -> Bool) -> a -> Summary -> Summary

-- | Take the union of two summaries.
union :: Summary -> Summary -> Summary

-- | Take the union of a list of summaries.
unions :: [Summary] -> Summary

-- | Get a summary of a list of values.
fromList :: [Bool] -> Summary

-- | Map a function over a list of values and summarize the results.
fromListWith :: (a -> Bool) -> [a] -> Summary

-- | Convert to (size,sum).
toStats :: Summary -> (Int, Int)

-- | Convert from (size,sum). No validation is performed.
fromStats :: Int -> Int -> Summary
instance Typeable Summary
instance Eq Summary
instance Data Summary
instance Monoid Summary
instance Show Summary


-- | A monad and monad transformer for Monte Carlo computations.
module Control.Monad.MC

-- | A Monte Carlo monad transformer. This type provides access to a random
--   number generator while allowing operations in a base monad,
--   <tt>m</tt>.
newtype MC m a
MC :: (RNG (PrimState m) -> m a) -> MC m a
runMC :: MC m a -> RNG (PrimState m) -> m a

-- | Type alias for when the base monad is <a>ST</a>.
type STMC s a = MC (ST s) a

-- | Type alias for when the base monad is <a>IO</a>.
type IOMC a = MC IO a

-- | Evaluate the result of a Monte Carlo computation using the given
--   random number generator.
evalMC :: (forall s. STMC s a) -> (forall s. ST s (STRNG s)) -> a

-- | The random number generator type.
data RNG s

-- | A shorter name for RNG in the <a>IO</a> monad.
type IORNG = RNG (PrimState IO)

-- | A shorter name for RNG in the <a>ST</a> monad.
type STRNG s = RNG (PrimState (ST s))

-- | The seed type for the random number generators.
type Seed = Word64

-- | Create a Mersenne Twister random number generator seeded with the
--   given value.
mt19937 :: PrimMonad m => Seed -> m (RNG (PrimState m))

-- | Create a Mersenne Twister seeded with the given state.
mt19937WithState :: PrimMonad m => [Word8] -> m (RNG (PrimState m))

-- | Get the name of the random number generator algorithm.
getRNGName :: PrimMonad m => RNG (PrimState m) -> m String

-- | Get the size of the generator state, in bytes.
getRNGSize :: PrimMonad m => RNG (PrimState m) -> m Int

-- | Get the state of the generator.
getRNGState :: PrimMonad m => RNG (PrimState m) -> m [Word8]

-- | Set the state of the generator.
setRNGState :: PrimMonad m => RNG (PrimState m) -> [Word8] -> m ()

-- | <tt>uniform a b</tt> generates a value uniformly distributed in
--   <tt>[a,b)</tt>.
uniform :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>uniformInt n</tt> generates an integer uniformly in the range
--   <tt>[0,n-1]</tt>. It is an error to call this function with a
--   non-positive value.
uniformInt :: PrimMonad m => Int -> MC m Int

-- | <tt>normal mu sigma</tt> generates a Normal random variable with mean
--   <tt>mu</tt> and standard deviation <tt>sigma</tt>.
normal :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>exponential mu</tt> generates an Exponential variate with mean
--   <tt>mu</tt>.
exponential :: PrimMonad m => Double -> MC m Double

-- | <tt>gamma a b</tt> generates a gamma random variable with parameters
--   <tt>a</tt> and <tt>b</tt>.
gamma :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>cauchy a</tt> generates a Cauchy random variable with scale
--   parameter <tt>a</tt>.
cauchy :: PrimMonad m => Double -> MC m Double

-- | <tt>levy c alpha</tt> gets a Levy alpha-stable variate with scale
--   <tt>c</tt> and exponent <tt>alpha</tt>. The algorithm only works for
--   <tt>0 &lt; alpha &lt;= 2</tt>.
levy :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>levySkew c alpha beta </tt> gets a skew Levy alpha-stable variate
--   with scale <tt>c</tt>, exponent <tt>alpha</tt>, and skewness
--   <tt>beta</tt>. The skew parameter must lie in the range
--   <tt>[-1,1]</tt>. The algorithm only works for <tt>0 &lt; alpha &lt;=
--   2</tt>.
levySkew :: PrimMonad m => Double -> Double -> Double -> MC m Double

-- | <tt>pareto a b</tt> generates a Pareto random variable with exponent
--   <tt>a</tt> and scale <tt>b</tt>.
pareto :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>weibull a b</tt> generates a Weibull random variable with scale
--   <tt>a</tt> and exponent <tt>b</tt>.
weibull :: PrimMonad m => Double -> Double -> MC m Double

-- | <tt>logistic a</tt> generates a logistic random variable with
--   parameter <tt>a</tt>.
logistic :: PrimMonad m => Double -> MC m Double

-- | <tt>beta a b</tt> generates a beta random variable with parameters
--   <tt>a</tt> and <tt>b</tt>.
beta :: PrimMonad m => Double -> Double -> MC m Double

-- | Generate <a>True</a> events with the given probability.
bernoulli :: PrimMonad m => Double -> MC m Bool

-- | <tt>poisson mu</tt> generates a Poisson random variable with mean
--   <tt>mu</tt>.
poisson :: PrimMonad m => Double -> MC m Int

-- | <tt>dirichlet alphas</tt> generates a Dirichlet random variable with
--   parameters <tt>alphas</tt>.
dirichlet :: PrimMonad m => Vector Double -> MC m (Vector Double)

-- | <tt>multinomial n ps</tt> generates a multinomial random variable with
--   parameters <tt>ps</tt> formed by <tt>n</tt> trials.
multinomial :: PrimMonad m => Int -> Vector Double -> MC m (Vector Int)

-- | <tt>sample xs</tt> samples a value uniformly from the elements of
--   <tt>xs</tt>. The results are undefined if <tt>length xs</tt> is zero.
sample :: PrimMonad m => [a] -> MC m a

-- | <tt>sampleWithWeights wxs</tt> samples a value from the list with the
--   given weight.
sampleWithWeights :: PrimMonad m => [(Double, a)] -> MC m a

-- | <tt>sampleSubset xs k</tt> samples a subset of size <tt>k</tt> from
--   <tt>xs</tt> by sampling without replacement. The return value is a
--   list of length <tt>k</tt> with the elements in the subset in the order
--   that they were sampled.
sampleSubset :: PrimMonad m => [a] -> Int -> MC m [a]

-- | Sample a subset of the elements with the given weights. Return the
--   elements of the subset in the order they were sampled.
sampleSubsetWithWeights :: PrimMonad m => [(Double, a)] -> Int -> MC m [a]

-- | <tt>shuffle xs</tt> randomly permutes the list <tt>xs</tt> and returns
--   the result. All permutations of the elements of <tt>xs</tt> are
--   equally likely.
shuffle :: PrimMonad m => [a] -> MC m [a]

-- | <tt>sampleInt n</tt> samples integers uniformly from <tt>[ 0..n-1
--   ]</tt>. It is an error to call this function with a non-positive
--   <tt>n</tt>.
sampleInt :: PrimMonad m => Int -> MC m Int

-- | <tt>sampleIntWithWeights ws n</tt> samples integers from <tt>[ 0..n-1
--   ]</tt> with the probability of choosing <tt>i</tt> proportional to
--   <tt>ws !! i</tt>. The list <tt>ws</tt> must have length equal to
--   <tt>n</tt>. Also, the elements of <tt>ws</tt> must be non-negative
--   with at least one nonzero entry.
sampleIntWithWeights :: PrimMonad m => [Double] -> Int -> MC m Int

-- | <tt>sampleIntSubset n k</tt> samples a subset of size <tt>k</tt> by
--   sampling without replacement from the integers <tt>{ 0, ..., n-1
--   }</tt>. The return value is a list of length <tt>k</tt> with the
--   elements in the subset in the order that they were sampled.
sampleIntSubset :: PrimMonad m => Int -> Int -> MC m [Int]

-- | <tt>sampleIntSubsetWithWeights ws n k</tt> samplea size <tt>k</tt>
--   subset of <tt>{ 0, ..., n-1 }</tt> with the given weights by sampling
--   elements without replacement. It returns the elements of the subset in
--   the order they were sampled.
sampleIntSubsetWithWeights :: PrimMonad m => [Double] -> Int -> Int -> MC m [Int]

-- | <tt>shuffleInt n</tt> randomly permutes the elements of the list <tt>[
--   0..n-1 ]</tt>.
shuffleInt :: PrimMonad m => Int -> MC m [Int]

-- | Generate a sequence of replicates and incrementally consume them via a
--   left fold.
--   
--   This fold is <i>not</i> strict. The replicate consumer is responsible
--   for forcing the evaluation of its result to avoid space leaks.
foldMC :: PrimMonad m => (a -> b -> MC m a) -> a -> Int -> MC m b -> MC m a

-- | Produce a lazy infinite list of replicates from the given random
--   number generator and Monte Carlo procedure.
repeatMC :: (forall s. STMC s a) -> (forall s. ST s (STRNG s)) -> [a]

-- | Produce a lazy list of the given length using the specified random
--   number genrator and Monte Carlo procedure.
replicateMC :: Int -> (forall s. STMC s a) -> (forall s. ST s (STRNG s)) -> [a]
