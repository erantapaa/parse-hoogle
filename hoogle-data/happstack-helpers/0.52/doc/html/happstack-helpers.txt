-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convenience functions for Happstack.
--   
--   Functions I found I was using repeatedly when programming Happstack
--   based web-apps. I'll deprecate whatever bits of this make their way
--   into the Happstack core on hackage.
@package happstack-helpers
@version 0.52

module Happstack.Data.IxSet.Helpers

-- | Sort of like a foreign key constraint, if macid were a normal rdbms.
--   
--   Eg, say you have a table called RepoUsers. When a user (or repo) is
--   deleted , all the RepoUsers that match it should also be deleted
deleteWhere :: (Typeable k, Indexable a b, Ord a, Data a) => k -> IxSet a -> IxSet a


-- | Simple stupid output of common types of html
module Happstack.Helpers.HtmlOutput.Common

-- | fullUrlLink "http:<i></i>www.google.com" | for when you want a link
--   that the anchor text is the full url. eg, for displaying a url for
--   darcs get.
fullUrlLink :: FilePath -> String

-- | simpleLink ("http:<i></i>www.google.com","google is a nice way to look
--   for information")
simpleLink :: (FilePath, String) -> String

-- | like simpleLink, but a link tag is class=attention
--   
--   if class attention is defined via css you can get some useful
--   behavior. I typically do something like the following, in a global css
--   file:
--   
--   a.attention:link {color: orange}
--   
--   a.attention:active {color: orange}
--   
--   a.attention:visited {color: orange}
--   
--   a.attention:hover {color: orange}
simpleAttentionLink :: (String, String) -> String

-- | width and height args blank blank if you don't want to specify this
--   
--   simpleImage (url, alttext) (width, height) = ...
simpleImage :: (FilePath, String) -> (String, String) -> String

-- | format a list of text vertically by putting list items in paragraphs
paintVHtml :: [String] -> String

-- | paintTable mbHeaderCells datacells mbPagination = ...
--   
--   mbHeaderCells: text for header cells, if you want them. Can use html
--   formatting if desired.
--   
--   pagination also optional
paintTable :: Maybe [String] -> [[String]] -> Maybe Pagination -> String

-- | paintTable' tableF trF spacerRow mbHeaderStuff datacells mbPagination
--   =
--   
--   helper function for a table with pagination
--   
--   see paintTable for an example of how this can be used
paintTable' :: (String -> String) -> ([String] -> String) -> (String, Bool) -> Maybe ([String], [String] -> String) -> [[String]] -> Maybe Pagination -> String
data Pagination
Pagination :: Int -> Int -> Int -> Int -> String -> String -> Pagination
currentbar :: Pagination -> Int
resultsPerBar :: Pagination -> Int
currentpage :: Pagination -> Int
resultsPerPage :: Pagination -> Int
baselink :: Pagination -> String
paginationtitle :: Pagination -> String
paintPaginationBar :: [[String]] -> Pagination -> String
getPaginatedCells :: [[String]] -> Pagination -> [[String]]

-- | substitute newlines with <a>br</a>
newlinesToHtmlLines :: String -> String

-- | The checkbox form element has optional attribute <a>checked</a>.
--   
--   If this attribute is present, readcheckbox returns true, otherwise
--   false.
--   
--   use in conjunction with checkStringIfTrue, when, eg, writing
--   StringTemplate code that renders a from with a box that might or not
--   be checked. Something like:
--   
--   attrs = [ ... , (<a>somethingIsChecked</a>, checkedStringIfTrue $
--   someBoolVal ) ... ]
readcheckbox :: String -> RqData Bool

-- | useful hack for dealing with checkboxes in HAppS. Maybe there's a
--   better way?
--   
--   checkedStringIfTrue p = if p then "checked" else ""
checkedStringIfTrue :: Bool -> String

-- | Render a list of strings as an unordered list (<a>ul</a>...<a>/ul</a>)
paintVUL :: [String] -> String

-- | Render a list of strings as an ordered list (<a>ol</a>...<a>/ol</a>)
paintVOL :: [String] -> String

-- | render a list of strings horizontally, separated by " | "
paintHBars :: [String] -> String
newtype HtmlString
HtmlString :: String -> HtmlString
newtype HtmlText
HtmlText :: Text -> HtmlText
instance ToMessage HtmlText
instance ToMessage HtmlString

module Happstack.Helpers.HtmlOutput.Menu

-- | Render a link which changes color when the current page is active,
--   modulo css.
--   
--   menuLink rq (url,anchortext)
--   
--   similar to simpleLink, outputs an html link. However, menuLink looks
--   at the request to determine if the page being linked to is the current
--   page. If it is, it's in class menuitemSelected, otherwise class
--   menuitem. if the url is blank, the link is unclickable, just displayed
--   gray (e.g., features that haven't been enabled but are coming soon).
--   You need to define the classes described here via css for these
--   features to be useful. I usually do something like in a global css
--   file:
--   
--   a.menuitem:link {color: blue}
--   
--   a.menuitem:active {color: blue}
--   
--   a.menuitem:visited {color: blue}
--   
--   a.menuitem:hover {color: blue}
--   
--   a.menuitemSelected:link {color: purple}
--   
--   a.menuitemSelected:active {color: purple}
--   
--   a.menuitemSelected:visited {color: purple}
--   
--   a.menuitemSelected:hover {color: purple}
menuLink :: Request -> (String, String) -> String

-- | menuLink' classSelected classUnselected rq (url,anchortext) = ...
menuLink' :: String -> String -> Request -> (String, String) -> String
vMenuOL :: Request -> [(String, String)] -> String
vMenuUL :: Request -> [(String, String)] -> String

-- | hMenuBars rq = paintHBars . map (menuLink rq)
hMenuBars :: Request -> [(String, String)] -> String

module Happstack.Server.Helpers
exactdir :: (Monad m) => String -> ServerPartT m a -> ServerPartT m a
spsIf :: (Monad m) => (Request -> Bool) -> ServerPartT m a -> ServerPartT m a
getData' :: (ServerMonad m, FromData a, MonadPlus m) => m a

-- | multiple vhosts to a server, eg | vhosts
--   [(<a>mysite.com</a>,80),(<a>www.mysite.com</a>,80)] mySiteController
--   
--   vhost doms h = msum . map (d -&gt; site d h) doms similar to apache
--   vhost. given (domain,port) and a main request handler, handle requests
--   if it's the specified domain and port vhost (<a>mysite.com</a>,80)
--   mySiteController
vhost :: (String, Int) -> ServerPartT IO Response -> ServerPartT IO Response


module Happstack.Data.User.Password
newtype Salt
Salt :: String -> Salt
newtype PasswordHash
PasswordHash :: [Word8] -> PasswordHash
data Password
Password :: Salt -> PasswordHash -> Password
dataType[ahv9] :: DataType
constr[ahva] :: Constr
dataType[ahuZ] :: DataType
constr[ahv0] :: Constr
dataType[ahuO] :: DataType
constr[ahuP] :: Constr

-- | check if the submitted password matches the stored password
checkPassword :: Password -> String -> Bool

-- | hash a password using the supplied salt Originally implemented using
--   SHA1. By switching to pbkdf2, we don't rely on implementation of
--   randomIO being cryptographically secure.
doHash :: Salt -> String -> PasswordHash

-- | changepass oldpassTryString newpassString p@(Password salt hash) = ...
--   Change password, requires old password as an additional security
--   measure
changepass :: (Monad m) => String -> String -> Password -> m Password

-- | generate some random salt returns 4 <a>Char</a> of salt.
genSalt :: (MonadIO m) => m Salt

-- | generate a new salted/hashed <a>Password</a> from the given input
--   string
newPassword :: (MonadIO m) => String -> m Password
instance Version Salt
instance Serialize Salt
instance Version PasswordHash
instance Serialize PasswordHash
instance Version Password
instance Serialize Password
instance Data Salt
instance Ord Salt
instance Eq Salt
instance Read Salt
instance Show Salt
instance Data PasswordHash
instance Ord PasswordHash
instance Eq PasswordHash
instance Read PasswordHash
instance Show PasswordHash
instance Data Password
instance Ord Password
instance Eq Password
instance Read Password
instance Show Password
instance (Data ctx String, Sat (ctx Salt), Sat (ctx String)) => Data ctx Salt
instance Typeable Salt
instance (Data ctx [Word8], Sat (ctx PasswordHash), Sat (ctx [Word8])) => Data ctx PasswordHash
instance Typeable PasswordHash
instance (Data ctx Salt, Data ctx PasswordHash, Sat (ctx Password), Sat (ctx Salt), Sat (ctx PasswordHash)) => Data ctx Password
instance Typeable Password
instance Default Salt
instance Default PasswordHash
instance Default Password

module Happstack.Helpers.ParseRequest

-- | <pre>
--   case modRewriteAppUrl "tutorial/registered" of 
--     Left e -&gt; ...
--     Right page -&gt; ... 
--   </pre>
--   
--   Given a page path, try to return the <a>home page</a> of a happs
--   server, basically, the host plus an optional path. At the same time,
--   try to deal sanely with HAppS serving behind apache mod rewrite, a
--   common situation for me at least because it lets you have multiple
--   happs servers listening on different ports, all looking to the casual
--   user like they are being served on port 80, and also unblocked by
--   firewalls.
--   
--   Can fail monadically
modRewriteAppUrl :: String -> Request -> Either String String

-- | getHost = getHeaderVal "host"
--   
--   returns host with port numbers, if anything other than default 80
getHost :: Request -> Either String String

-- | retrieve val of header for key supplied, or an error message if the
--   key isn't found
getHeaderVal :: String -> Request -> Either String String

-- | host with port number stripped out, if any.
--   
--   Useful, for example, for getting the right address to ssh to.
getDomain :: Request -> Either String String

module Happstack.Helpers.Redirect

-- | redirectPath def path rq = ...
--   
--   eg, redirectPath (fail <a>horribly) </a><i>path</i>to<i>page" will
--   redirect to http:</i><i>myserver.com</i>path<i>to</i>page or
--   http:<i></i>localhost:5001<i>path</i>to/page depending on whether it
--   is servin in online environemnt or for local development on port 5001
--   Could produce an error if the hostname can't be determined for some
--   reason (malformed headers?)
redirectPath :: (MonadIO m) => WebT m Response -> String -> Request -> WebT m Response

-- | Escape a serverPartT handler by redirecting somewhere
--   
--   Basically a wrapper around supplied seeOther function, which doesn't
--   quite do what I want
redirectToUrl :: (MonadIO m) => String -> WebT m Response

module Happstack.Helpers.HtmlOutput
directoryGroupsHAppS :: (Stringable a) => FilePath -> IO (Map FilePath (STGroup a))


-- | Directory browsing for HAppS
--   
--   browsedir "someDirectory"
module Happstack.Helpers.DirBrowse

-- | browsedir = browsedir' defPaintdir defPaintfile
--   
--   define a ServerPartT value with something like
--   
--   sp = browsedir "projectroot" "."
--   
--   where projectroot is an alias (what you see in the url) and <a>.</a>
--   is the path relative to the executable running
--   
--   the happs server
browsedir :: (MonadIO m) => FilePath -> FilePath -> ServerPartT m Response

-- | like browsedir, but haskell files are rendered through hscolour
--   
--   browsedirHS = browsedir' defPaintdir hsPaintfile
browsedirHS :: (MonadIO m) => FilePath -> FilePath -> ServerPartT m Response

-- | browsedir' paintdir paintfile diralias syspath
--   
--   paintdir/paintfile are rendering functions
--   
--   diralias: path that will appear in browser
--   
--   syspath: real system path
browsedir' :: (ToMessage a, ToMessage b, MonadIO m) => (String -> [FilePath] -> a) -> (String -> String -> b) -> FilePath -> FilePath -> ServerPartT m Response
instance ToMessage BrowseHtmlString

module Happstack.Helpers
