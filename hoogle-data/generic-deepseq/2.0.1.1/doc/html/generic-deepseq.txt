-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic deep evaluation of data structures
--   
--   This package provides a <a>deepseq</a> function analogous to
--   <a>seq</a>, except that it traverses the entire data structure,
--   evaluating it fully, and not just up to head normal form.
--   
--   Using lists as an example:
--   
--   <pre>
--   &gt; [1,2,undefined] `seq` 3
--   3
--   </pre>
--   
--   Whereas with <a>deepseq</a>:
--   
--   <pre>
--   &gt; [1,2,undefined] `deepseq` 3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   Unlike the <tt>deepseq</tt> package, this implementation is based on
--   the <a>GHC.Generics</a> framework as found in GHC &gt;= 7.2, so that
--   it can generate instances automatically for any datatype that has a
--   <a>Generic</a> instance, without further code.
--   
--   <pre>
--   data MyType = MyType String Int (Maybe Double)
--     deriving Generic
--   instance DeepSeq MyType
--   </pre>
--   
--   Changes in version 2.0.0.0:
--   
--   <ul>
--   <li>Vastly improved performance. As a consequence of these changes,
--   the member function of the DeepSeq class is now <a>rnf</a>, instead of
--   <a>deepseq</a>.</li>
--   <li>New instances for functions, Ratio and Complex types.</li>
--   </ul>
--   
--   Changes in version 2.0.1.0:
--   
--   <ul>
--   <li>Fix the U1 and V1 instances.</li>
--   </ul>
--   
--   Changes in version 2.0.1.1:
--   
--   <ul>
--   <li>No functional changes, updated to correct the URLs of the
--   repository and the issue tracker.</li>
--   </ul>
@package generic-deepseq
@version 2.0.1.1


-- | This module provides a <a>deepseq</a> function for fully evaluating
--   data structures (that is, evaluating to "Normal Form", and not just up
--   to "Head Normal Form" like <a>seq</a> does).
--   
--   It uses the <a>GHC.Generics</a> framework so that you can generate
--   instances for your datatypes without having to provide an
--   implementation.
module Control.DeepSeq
class DeepSeq a where rnf = grnf . from
rnf :: DeepSeq a => a -> ()

-- | Evaluates its first argument to normal form, and then returns its
--   second argument as the result.
deepseq :: DeepSeq a => a -> b -> b

-- | The deep analogue of <a>$!</a>.
($!!) :: DeepSeq a => (a -> b) -> a -> b

-- | Evaluates its argument to normal form, and then return it.
force :: DeepSeq a => a -> a
instance (GDeepSeq a, GDeepSeq b) => GDeepSeq (a :+: b)
instance (GDeepSeq a, GDeepSeq b) => GDeepSeq (a :*: b)
instance GDeepSeq a => GDeepSeq (M1 i c a)
instance DeepSeq a => GDeepSeq (K1 i a)
instance GDeepSeq U1
instance GDeepSeq V1
instance DeepSeq a => DeepSeq (Complex a)
instance (Integral a, DeepSeq a) => DeepSeq (Ratio a)
instance (DeepSeq a, DeepSeq b) => DeepSeq (Either a b)
instance DeepSeq a => DeepSeq (Maybe a)
instance DeepSeq a => DeepSeq [a]
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e, DeepSeq f, DeepSeq g) => DeepSeq (a, b, c, d, e, f, g)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e, DeepSeq f) => DeepSeq (a, b, c, d, e, f)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d, DeepSeq e) => DeepSeq (a, b, c, d, e)
instance (DeepSeq a, DeepSeq b, DeepSeq c, DeepSeq d) => DeepSeq (a, b, c, d)
instance (DeepSeq a, DeepSeq b, DeepSeq c) => DeepSeq (a, b, c)
instance (DeepSeq a, DeepSeq b) => DeepSeq (a, b)
instance DeepSeq (a -> b)
instance DeepSeq Word64
instance DeepSeq Word32
instance DeepSeq Word16
instance DeepSeq Word8
instance DeepSeq Int64
instance DeepSeq Int32
instance DeepSeq Int16
instance DeepSeq Int8
instance DeepSeq ()
instance DeepSeq Ordering
instance DeepSeq Integer
instance DeepSeq Word
instance DeepSeq Int
instance DeepSeq Float
instance DeepSeq Double
instance DeepSeq Char
instance DeepSeq Bool
