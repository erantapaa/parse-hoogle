-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure
--   
--   This is a wrapper to HaXML and HXT (Haskell XML Toolbox). It's my
--   work-around for the unfortunate situation that both toolboxes have
--   different functionality, none is the superset of the other. Both of
--   them rely on data structures, which look unnatural to me. Additionally
--   they provide combinator functions that are actually weakly typed, they
--   are all of type <tt>(a -&gt; [a])</tt>, instead of being
--   differentiated into <tt>(a -&gt; Bool)</tt>, <tt>(a -&gt; a)</tt> and
--   <tt>(a -&gt; [a])</tt>. HXT is even weaker in type safety than HaXML
--   since it allows complete XML trees even in attribute values. I didn't
--   want to write another XML toolbox with parsers, HTML support and so
--   on, however in the meantime I came close to it.
--   
--   I decided to do some wrapping in order to use as much as possible
--   functionality from HaXML and HXT. I provide my own XML tree data
--   structure with according operations. Conversions between HaXML or HXT
--   trees and my own ones are implemented. So I can use the parser and
--   pretty printer of both HaXML and HXT while processing trees the way I
--   find more natural. TagSoups can also be converted to XML trees. All
--   conversions are lazy.
--   
--   I have a special XML string structure. (<a>Text.XML.WraXML.String</a>)
--   XML strings consist of ASCII characters and XML references. My XML
--   tree is built on top of a very general tree structure, which
--   distinguishs between leafs and inner branches.
--   (<a>Data.Tree.BranchLeafLabel</a>) Each element of a tree is labeled
--   with some information. Branches are then used for tags, leafs for XML
--   strings and special tags, and the labels for pointers to positions in
--   the source file. (<a>Text.XML.WraXML.Tree</a>)
@package wraxml
@version 0.4.3


-- | Conversion from HaXml position to our Position type. We cannot convert
--   back efficiently, since we would have to increment the line number
--   repeatedly. Thus such a conversion is missing.
module Text.XML.WraXML.Position.HaXml
toPosition :: Posn -> T

module Text.HTML.WraXML.Entity
type Name = String
mapNameToChar :: Map Name Char
mapCharToName :: Map Char Name

module Text.XML.WraXML.Element
data T name str
Cons :: Name name -> [T name str] -> T name str
name_ :: T name str -> Name name
attributes_ :: T name str -> [T name str]
type Filter name str = T name str -> T name str
cons :: (Tag name, Attribute name) => Name name -> [T name str] -> T name str
name :: T (T name str) (Name name)
attributes :: T (T name str) [T name str]
checkName :: (Name name -> Bool) -> (T name str -> Bool)
checkAttributes :: ([T name str] -> Bool) -> (T name str -> Bool)
lift :: (Name name -> [T name str] -> (Name name, [T name str])) -> (Filter name str)

-- | process the attribute list of a specific tag
processAttrs :: (Tag name, Attribute name) => (Name name -> Bool) -> ([T name str] -> [T name str]) -> (Filter name str)
processAttrValue :: (Tag name, Attribute name) => (Name name, Name name) -> (str -> str) -> (Filter name str)
processAttrValueCond :: (Tag name, Attribute name) => (Name name, Name name) -> ([T name str] -> Bool) -> (str -> str) -> (Filter name str)

-- | process the attribute list of a specific tag
processAttrsA :: (Tag name, Attribute name, Applicative m) => (Name name -> Bool) -> ([T name str] -> m [T name str]) -> (T name str -> m (T name str))
processAttrValueA :: (Tag name, Attribute name, Applicative m) => (Name name, Name name) -> (str -> m str) -> (T name str -> m (T name str))
processAttrValueCondA :: (Tag name, Attribute name, Applicative m) => (Name name, Name name) -> ([T name str] -> Bool) -> (str -> m str) -> (T name str -> m (T name str))
liftA :: (Tag name, Attribute name, Applicative m) => (Name name -> [T name str] -> m (Name name, [T name str])) -> (T name str -> m (T name str))
format :: (Tag name, Attribute name, C string) => (Name name -> Bool) -> ShowS -> T name string -> [ShowS] -> ShowS
instance (Show name, Show str, Attribute name) => Show (T name str)
instance Traversable (T name)
instance Foldable (T name)
instance Functor (T name)

module Text.XML.WraXML.String
type T = [Atom]
type EmbeddedExceptions = [Exceptional String Char]
type Atom = T

-- | should be an abstract type
type Encoding = String

-- | should be [Word8]
type Encoded = String

-- | Literal translation from pure strings. This can only work, if the
--   string does not contain special characters.
fromString :: String -> T
diffFromString :: String -> T -> T

-- | default routine
fromUnicodeString :: String -> T
toUnicodeStringOrFormat :: T -> String
toUnicodeStringEmbedMessage :: T -> String

-- | Errors in on resolution of references yield undefined elements.
toUnicodeString :: T -> String
toUnicodeStringEmbedException :: T -> EmbeddedExceptions

-- | Interpret the XML string as mixture of ISO-Latin-1 characters and XML
--   entities and convert that to a Unicode string.
isoLatin1ToUnicodeString :: T -> String

-- | Interpret the XML string as mixture of UTF-8 characters and XML
--   entities and convert that to a Unicode string.
utf8ToUnicodeString :: T -> String
readHex :: (Num a) => String -> a

-- | Caution: There is a memory leak for the case that entity references
--   are huge.
parse :: String -> T
parseAux :: (Char -> Bool) -> (String -> T) -> String -> String -> T
reduceRefs :: T -> T

-- | Consider the XmlString as a mixture of XML entities and UTF-8
--   characters. Replace UTF-8 characters by Unicode representations.
replaceUTF8ByUnicode :: T -> T
mapUnicodeRuns :: (String -> String) -> T -> T
uStringWithErrorsMergePlainChars :: EmbeddedExceptions -> [Exceptional String String]
evalDecodeAdaptive :: State (Encoded -> String) a -> a
liftFromUnicode :: (String -> String) -> (T -> T)
liftFromUnicodeA :: (Applicative m) => (String -> m String) -> (T -> m T)

module Text.HTML.WraXML.Element
decodeAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> T name [T] -> State (Encoded -> String) (T name String)
data T name str
name_ :: T name str -> Name name
attributes_ :: T name str -> [T name str]
cons :: (Tag name, Attribute name) => Name name -> [T name str] -> T name str
name :: T (T name str) (Name name)
attributes :: T (T name str) [T name str]
checkName :: (Name name -> Bool) -> (T name str -> Bool)
format :: (Tag name, Attribute name, C string) => (Name name -> Bool) -> ShowS -> T name string -> [ShowS] -> ShowS

module Text.HTML.WraXML.String
type T = [Atom]
type Atom = T

-- | Literal translation from pure strings. This can only work, if the
--   string does not contain special characters.
fromString :: String -> T

-- | default routine
fromUnicodeString :: String -> T
fromUnicodeStringInternetExploder :: String -> T
toUnicodeStringOrFormat :: T -> String
toUnicodeString :: T -> String

-- | Decode plain characters using the given decoder, and decode entities
--   by HXT's XML entity table. Decoding errors for both conversions are
--   embedded where they occur.
toUnicodeStringDecodingEmbedError :: DecodingFctEmbedErrors -> T -> EmbeddedExceptions

-- | Convert characters to lower case. This uses ISO latin encoding and may
--   fail for exotic characters.
toLower :: T -> T
toUpper :: T -> T
toCanonicalUnicodeString :: T -> String
equalIgnoreCase :: T -> T -> Bool
elemIgnoreCase :: T -> [T] -> Bool

module Text.XML.WraXML.String.HaXml
toXmlString :: AttValue -> T
fromXmlString :: T -> AttValue
lift :: (T -> T) -> (AttValue -> AttValue)
refToXmlAtom :: Reference -> Atom
charFromXmlAtom' :: T -> Either Char Reference
charFromXmlAtom :: T -> Either Char Reference

module Text.XML.WraXML.String.HXT
toXmlString :: XmlTrees -> T
toXmlString' :: XmlTree -> T
fromXmlString :: T -> XmlTrees

module Data.Tree.BranchLeaf
data T branch leaf
Branch :: branch -> [T branch leaf] -> T branch leaf
Leaf :: leaf -> T branch leaf
map :: (branch0 -> branch1) -> (leaf0 -> leaf1) -> (T branch0 leaf0 -> T branch1 leaf1)
mapCond :: (branch -> Bool) -> (branch -> branch) -> (leaf -> leaf) -> (T branch leaf -> T branch leaf)
fold :: (branch -> [a] -> a) -> (leaf -> a) -> (T branch leaf -> a)
switch :: (branch -> [T branch leaf] -> a) -> (leaf -> a) -> (T branch leaf -> a)
allSubTrees :: T branch leaf -> [T branch leaf]
mapA :: (Applicative m) => (branch0 -> m branch1) -> (leaf0 -> m leaf1) -> (T branch0 leaf0 -> m (T branch1 leaf1))
foldA :: (Applicative m) => (branch -> m ([a] -> a)) -> (leaf -> m a) -> (T branch leaf -> m a)
foldM :: (Monad m) => (branch -> [a] -> m a) -> (leaf -> m a) -> (T branch leaf -> m a)
instance (Show branch, Show leaf) => Show (T branch leaf)

module Data.Tree.BranchLeafLabel
type T i branch leaf = (i, Elem i branch leaf)
data Elem i branch leaf
Branch :: branch -> [T i branch leaf] -> Elem i branch leaf
Leaf :: leaf -> Elem i branch leaf
map :: (branch0 -> branch1) -> (leaf0 -> leaf1) -> (T i branch0 leaf0 -> T i branch1 leaf1)
mapLabel :: (i -> j) -> (T i branch leaf -> T j branch leaf)
mapCond :: (branch -> Bool) -> (branch -> branch) -> (leaf -> leaf) -> (T i branch leaf -> T i branch leaf)

-- | Process the subtrees for which the predicate holds. If the predicate
--   matches subtrees of a matching subtree, the sub-subtrees are not
--   mapped.
mapSubTrees :: (branch -> Bool) -> ((branch, [T i branch leaf]) -> (branch, [T i branch leaf])) -> (T i branch leaf -> T i branch leaf)
filterBranch :: (branch -> Bool) -> (T i branch leaf -> [T i branch leaf])
fold :: (i -> a -> b) -> (branch -> [b] -> a) -> (leaf -> a) -> (T i branch leaf -> b)
switch :: (i -> a -> b) -> (branch -> [T i branch leaf] -> a) -> (leaf -> a) -> (T i branch leaf -> b)
foldLabel :: (i -> branch -> [b] -> b) -> (i -> leaf -> b) -> (T i branch leaf -> b)
foldLabelAlt :: (i -> branch -> [b] -> b) -> (i -> leaf -> b) -> (T i branch leaf -> b)
switchLabel :: (i -> branch -> [T i branch leaf] -> b) -> (i -> leaf -> b) -> (T i branch leaf -> b)
switchElem :: (branch -> [T i branch leaf] -> a) -> (leaf -> a) -> (Elem i branch leaf -> a)
allSubTrees :: T i branch leaf -> [T i branch leaf]
mapA :: (Applicative m) => (branch0 -> m branch1) -> (leaf0 -> m leaf1) -> (T i branch0 leaf0 -> m (T i branch1 leaf1))
mapCondA :: (Applicative m) => (branch -> Bool) -> (branch -> m branch) -> (leaf -> m leaf) -> (T i branch leaf -> m (T i branch leaf))
foldA :: (Applicative m) => (i -> m (a -> b)) -> (branch -> m ([b] -> a)) -> (leaf -> m a) -> (T i branch leaf -> m b)
foldM :: (Monad m) => (i -> a -> m b) -> (branch -> [b] -> m a) -> (leaf -> m a) -> (T i branch leaf -> m b)
instance (Show i, Show branch, Show leaf) => Show (Elem i branch leaf)

module Text.XML.WraXML.Tree
newtype T i name str
Cons :: T i (Branch name str) (Leaf name str) -> T i name str
unwrap :: T i name str -> T i (Branch name str) (Leaf name str)
data Branch name str
Tag :: T name str -> Branch name str
getElement :: Branch name str -> T name str
data Leaf name str
Text :: Bool -> str -> Leaf name str
Comment :: String -> Leaf name str
CData :: String -> Leaf name str
PI :: (Name name) -> (T name str) -> Leaf name str
Warning :: String -> Leaf name str
type AttributePlain = (String, String)
wrap :: T i (Branch name str) (Leaf name str) -> T i name str
wrap2 :: i -> Elem i (Branch name str) (Leaf name str) -> T i name str
lift :: (T i (Branch name str0) (Leaf name str0) -> T j (Branch name str1) (Leaf name str1)) -> (T i name str0 -> T j name str1)
liftA :: (Applicative m) => (T i (Branch name str0) (Leaf name str0) -> m (T i (Branch name str1) (Leaf name str1))) -> (T i name str0 -> m (T i name str1))

-- | Build some textual content.
literal :: str -> T i name str
literalIndex :: i -> str -> T i name str
comment :: String -> T i name str
commentIndex :: i -> String -> T i name str
warning :: String -> T i name str
warningIndex :: i -> String -> T i name str
cdata :: String -> T i name str
cdataIndex :: i -> String -> T i name str
processing :: Name name -> T name str -> T i name str
processingIndex :: i -> Name name -> T name str -> T i name str
tag :: Name name -> [T i name str] -> T i name str
tagAttr :: Name name -> [T name str] -> [T i name str] -> T i name str
tagIndexAttr :: i -> Name name -> [T name str] -> [T i name str] -> T i name str
liftTrans :: (a -> b) -> (a -> [b])
liftText :: (String -> String) -> (Leaf name String -> Leaf name String)
liftTextA :: (Applicative m) => (String -> m String) -> (Leaf name String -> m (Leaf name String))
liftElement :: (T name str0 -> T name str1) -> (Branch name str0 -> Branch name str1)
liftElementA :: (Applicative m) => (T name str0 -> m (T name str1)) -> (Branch name str0 -> m (Branch name str1))

-- | If the Tree is a Leaf, then return False. Otherwise return the result
--   of the predicate.
checkTag :: (T name str -> Bool) -> (T i name str -> Bool)
maybeTag :: T i name str -> Maybe (T name str, [T i name str])
maybeText :: T i name str -> Maybe str
maybeTextLeaf :: Leaf name str -> Maybe str
maybeCommentLeaf :: Leaf name str -> Maybe String
maybeCDataLeaf :: Leaf name str -> Maybe String
maybeProcessingLeaf :: Leaf name str -> Maybe (Name name, T name str)
maybeWarningLeaf :: Leaf name str -> Maybe String
fold :: (i -> a -> b) -> (T name str -> [b] -> a) -> (Leaf name str -> a) -> (T i name str -> b)
switch :: (i -> a -> b) -> (T name str -> [T i name str] -> a) -> (Leaf name str -> a) -> (T i name str -> b)
type Filter i name str = T i name str -> T i name str
type FilterA m i name str = T i name str -> m (T i name str)
mapText :: (String -> String) -> (T i name String -> T i name String)
mapIndex :: (i -> j) -> T i name str -> T j name str
mapTag :: (Filter name str) -> (Filter i name str)

-- | Convert all CData sections to plain text.
textFromCData :: T i name String -> T i name String

-- | You can e.g. filter <tt>text1 <a>b&gt; text2 &lt;/b</a> text3</tt> to
--   <tt>text1 text2 text3</tt> by <tt>filterTag (checkTagName
--   (<a>b</a>/=))</tt>.
filterTag :: (T name str -> Bool) -> (T i name str -> [T i name str])
mapCond :: (T name str -> Bool) -> (Filter name str) -> (Leaf name str -> Leaf name str) -> (Filter i name str)

-- | Find all branches where the predicate applies and return a list of
--   matching sub-trees in depth-first order.
--   
--   Example: <tt>filterTagsFlatten (checkTagName (<a>meta</a>==))</tt>
filterTagsFlatten :: (T name str -> Bool) -> T i name str -> [(T name str, [T i name str])]
filterElementsFlatten :: (T name str -> Bool) -> T i name str -> [T name str]
allSubTrees :: T i name str -> [T i name str]

-- | merge subsequent string leafs
mergeStrings :: (Monoid str) => Filter i name str
mergeTopStrings :: (Monoid str) => [T i name str] -> [T i name str]

-- | Process all sub-tree lists in bottom-up order.
processAllSubTrees :: ([T i name str] -> [T i name str]) -> Filter i name str
processSubTrees :: (Name name -> Bool) -> ([T i name str] -> [T i name str]) -> Filter i name str
processSubTreesAttrs :: (Name name -> Bool) -> (([T name str], [T i name str]) -> ([T name str], [T i name str])) -> Filter i name str
mapTextA :: (Applicative m) => (String -> m String) -> (FilterA m i name String)
mapCondA :: (Applicative m) => (T name str -> Bool) -> (T name str -> m (T name str)) -> (Leaf name str -> m (Leaf name str)) -> (FilterA m i name str)
unescape :: T i name T -> T i name String

-- | Use ASCII characters, XML entity references and character references
--   for representing strings. That's not human readable, but portable.
escape :: T i name String -> T i name T

-- | Decode characters like those from UTF-8 scheme.
decodeSpecialChars :: (Tag name, Attribute name) => String -> T i name T -> [T i name String]
maybeDecodeSpecialChars :: (Tag name, Attribute name) => String -> T i name T -> Maybe [T i name String]

-- | Conversion errors are appended as warnings to the tree.
decodeSpecialCharsDecoder :: (Tag name, Attribute name) => DecodingFctEmbedErrors -> T i name T -> [T i name String]
decodeAttrs :: (Tag name, Attribute name) => (T -> EmbeddedExceptions) -> [T name T] -> Writer [String] [T name String]
decodeAttr :: (Tag name, Attribute name) => (T -> EmbeddedExceptions) -> Name name -> T -> Writer [String] String
maybeDecodeUTF8Chars :: String -> T i name T -> Maybe (T i name String)
formatMany :: (Tag name, Attribute name, C string) => [T i name string] -> ShowS
format :: (Tag name, Attribute name, C string) => T i name string -> ShowS
formatBranch :: (Tag name, Attribute name, C string) => Branch name string -> [ShowS] -> ShowS
formatLeaf :: (Tag name, Attribute name, C string) => Leaf name string -> ShowS
instance (Show name, Show str, Attribute name) => Show (Branch name str)
instance (Show i, Show name, Show str, Attribute name) => Show (T i name str)
instance (Tag name, Attribute name, C string) => C (Leaf name string)
instance (Tag name, Attribute name, C string) => C (T i name string)
instance Traversable (T i name)
instance Foldable (T i name)
instance Functor (T i name)
instance Traversable (Leaf name)
instance Foldable (Leaf name)
instance Functor (Leaf name)
instance (Attribute name, Show name, Show str) => Show (Leaf name str)

module Text.HTML.WraXML.Tree
findMetaEncoding :: (Tag name, Attribute name) => T i name String -> Maybe String

-- | Extract META tags which contain HTTP-EQUIV attribute and present these
--   values like HTTP headers.
getMetaHTTPHeaders :: (Tag name, Attribute name) => T i name String -> [(String, String)]

-- | Decode strings in a HTML tree. Switch decoding on every occurence of a
--   content-type meta-tag. This must operate on <tt>HtmlString</tt>s, that
--   is before reference resolution, since after reference resolution
--   Unicode characters may clash with encoded characters.
decodeAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> T i name [T] -> State (Encoded -> String) (T i name String)
decodeLeafAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> Leaf name [T] -> State (Encoded -> String) (Leaf name String)

-- | Convert special characters of XmlString into Unicode according to the
--   encoding given in a META HTTP-EQUIV tag.
decodeSpecialCharsMetaEncoding :: (Tag name, Attribute name) => T i name T -> [T i name String]
formatMany :: (Tag name, Attribute name, C string) => [T i name string] -> ShowS
format :: (Tag name, Attribute name, C string) => T i name string -> ShowS
formatBranch :: (Tag name, Attribute name, C string) => Branch name string -> [ShowS] -> ShowS
formatManyXHTML :: (Tag name, Attribute name, C string) => [T i name string] -> ShowS
formatXHTML :: (Tag name, Attribute name, C string) => T i name string -> ShowS
formatBranchXHTML :: (Tag name, Attribute name, C string) => Branch name string -> [ShowS] -> ShowS

-- | <tt>not xhtml</tt>: show <tt><a>br</a></tt> <tt>xhtml</tt>: show
--   <tt><a>br/</a></tt> Unfortunately we cannot generally merge
--   <tt><a>tag&gt;&lt;/tag&gt;@ to @&lt;tag/</a></tt> since browsers
--   expect e.g. separated <tt><a>div&gt;&lt;/div</a></tt>.
formatBranchGen :: (Tag name, Attribute name, C string) => Bool -> Branch name string -> [ShowS] -> ShowS

module Text.XML.WraXML.Document
data T i name str
Cons :: Maybe [T name str] -> Maybe String -> [T i name str] -> T i name str
xmlDeclaration :: T i name str -> Maybe [T name str]
docType :: T i name str -> Maybe String
content :: T i name str -> [T i name str]
lift :: (Tag name, Attribute name) => (str0 -> str1) -> ([T i name str0] -> [T i name str1]) -> T i name str0 -> T i name str1
liftA :: (Tag name, Attribute name, Applicative m) => (str0 -> m str1) -> ([T i name str0] -> m [T i name str1]) -> T i name str0 -> m (T i name str1)
formatXMLDeclaration :: (Tag name, Attribute name, C string) => [T name string] -> ShowS
formatDocType :: String -> ShowS
format :: (Tag name, Attribute name, C string) => T i name string -> ShowS
instance (Show i, Show name, Show str, Attribute name) => Show (T i name str)
instance (Tag name, Attribute name, C string) => C (T i name string)
instance (Tag name, Attribute name) => Functor (T i name)

module Text.HTML.WraXML.Document
data T i name str
Cons :: Maybe [T name str] -> Maybe String -> [T i name str] -> T i name str
xmlDeclaration :: T i name str -> Maybe [T name str]
docType :: T i name str -> Maybe String
content :: T i name str -> [T i name str]
lift :: (Tag name, Attribute name) => (str0 -> str1) -> ([T i name str0] -> [T i name str1]) -> T i name str0 -> T i name str1
decodeAdaptive :: (Attribute name, Tag name) => (Encoding -> Encoded -> String) -> T i name [T] -> State (Encoded -> String) (T i name String)
format :: (Tag name, Attribute name, C string) => T i name string -> ShowS

module Text.HTML.WraXML.Table
type T i name str = [[[T i name str]]]

-- | Ignores all non-table-row-tags and all non-table-cell-tags.
simpleFromRows :: (Tag name) => [T i name str] -> T i name str
simpleFromRow :: (Tag name) => [T i name str] -> [[T i name str]]


-- | This module allows construction of XML trees using String literals
--   instead of names.
module Text.XML.WraXML.Tree.Literal
data T i name str
processing :: (Tag name, Attribute name) => String -> T name str -> T i name str
processingIndex :: (Tag name, Attribute name) => i -> String -> T name str -> T i name str
tag :: (Tag name, Attribute name) => String -> [T i name str] -> T i name str
tagAttr :: (Tag name, Attribute name) => String -> [(String, str)] -> [T i name str] -> T i name str
tagIndexAttr :: (Tag name, Attribute name) => i -> String -> [(String, str)] -> [T i name str] -> T i name str

-- | Build some textual content.
literal :: str -> T i name str
literalIndex :: i -> str -> T i name str
comment :: String -> T i name str
commentIndex :: i -> String -> T i name str
warning :: String -> T i name str
warningIndex :: i -> String -> T i name str
cdata :: String -> T i name str
cdataIndex :: i -> String -> T i name str


-- | Very lazy HTML tree parser using TagSoup as lexer.
module Text.XML.WraXML.Tree.TagSoup
type PosTag = (T, Tag)
defaultFilename :: String
attachPos :: [Tag] -> [PosTag]
removeMetaPos :: [PosTag] -> [PosTag]
type XmlTree name string = T T name string

-- | A TagSoup could represent multiple HTML trees, e.g. with some
--   introducing comments.
toXmlTreesString :: (Tag name, Attribute name) => [Tag] -> [XmlTree name String]
toXmlTreesAux :: (Tag name, Attribute name) => [PosTag] -> [XmlTree name String]
type Parser i a = Parser (i, Tag) a
parseBranch :: (Tag name, Attribute name) => Parser i (T i name String)
parseSubTrees :: (Tag name, Attribute name) => T i name String -> Name name -> Parser i [T i name String]
parseTerminator :: (Tag name, Attribute name) => Name name -> Parser i [T i name String]
parseOptions :: ParseOptions
example :: [XmlTree T String]

module Text.XML.WraXML.Document.TagSoup
dropSpace :: [PosTag] -> [PosTag]
withoutLeadingSpace :: ([PosTag] -> (a, [PosTag])) -> State [PosTag] a
toXmlDocument :: (Tag name, Attribute name) => [Tag] -> T T name String
toXmlDocumentString :: (Tag name, Attribute name) => [Tag] -> T T name String
example :: IO ()

module Text.XML.WraXML.Tree.HXT
fromXmlTree :: (Tag name, Attribute name) => T i name T -> XmlTree
toXmlTree :: (Tag name, Attribute name) => XmlTree -> T () name T
lift :: (Tag name, Attribute name) => Filter () name T -> (XmlTree -> XmlTree)

-- | Lift our XML filters to HXT document processors.
liftFilterToDocument :: (Tag name, Attribute name) => String -> Filter () name T -> (XmlTree -> XmlTree)
checkTagName :: String -> XNode -> Bool

module Text.HTML.WraXML.Tree.HXT

-- | Tidy a piece of HTML code. &amp; -&gt; &amp;amp; <a> -</a> &amp;lt;
--   unquoted tag attribute values: size=-1 -&gt; size=<a>-1</a> insert
--   omitted closing tags
tidy :: String -> IO String

-- | Like Text.XML.HXT.DOM.XmlTreeFunctions.xshow but it shows empty tags
--   the HTML way. E.g. it emits <tt><a>br&gt;@ instead of
--   @&lt;br\/</a></tt>, <tt><a>noscript&gt;&lt;\/noscript&gt;@ instead of
--   @&lt;noscript\/</a></tt>. Many browsers prefer that.
format :: XmlTree -> String
fromHTMLString :: String -> IO XmlTree

-- | Guess the encoding from the META-HTTP-EQUIV attribute, if available.
--   Otherwise fall back to ISO-Latin-1.
fromHTMLStringMetaEncoding :: String -> IO XmlTree
errorAnnFromHTMLStringMetaEncoding :: String -> IO (XmlTree, [ErrorMsg], Int)

-- | Adaption of Text.XML.HXT.Parser.MainFunctions.getXmlDocument
errorAnnFromHTMLStringOpt :: Attributes -> String -> IO (XmlTree, [ErrorMsg], Int)
type ErrorMsg = (Int, String)
getMetaHTTPHeaders :: String -> IO [(String, String)]

module Text.XML.WraXML.Tree.HaXml
fromXmlTree :: (Tag name, Attribute name) => T i name T -> Content i
multiFromXmlTree :: (Tag name, Attribute name) => T i name T -> [Content i]
toXmlTree' :: (Tag name, Attribute name) => Content i -> T i name T
toXmlTree :: (Tag name, Attribute name) => Content i -> T i name T
lift :: (Tag name, Attribute name) => Filter i name T -> (Content i -> Content i)

-- | Lift a filter of HaXml trees to a processor of a HaXml document.
--   
--   cf. Text.XML.HaXml.Wrappers.onContent
onContent :: FilePath -> (Content Posn -> Content Posn) -> (Document Posn -> Document Posn)
liftFilterToDocument :: (Tag name, Attribute name) => FilePath -> Filter Posn name T -> (Document Posn -> Document Posn)
processWith :: (Tag name, Attribute name) => Filter Posn name T -> IO ()


-- | Very lazy HTML tree parser using TagSoup as lexer.
module Text.XML.WraXML.Tree.Tagchup

-- | A TagSoup could represent multiple HTML trees, e.g. with some
--   introducing comments.
toXmlTrees :: (Tag name, Attribute name) => [T name string] -> [T T name string]
fromXmlTree :: (Tag name, Attribute name) => T T name string -> [T name string]
fromElement :: (Tag name, Attribute name) => T name string -> T name string
fromLeaf :: (Tag name, Attribute name) => Leaf name string -> T name string
liftElementFilter :: (Tag name, Attribute name) => (T name str -> T name str) -> T name str -> T name str
liftElementCheck :: (T name string -> Bool) -> (T name string -> Bool)
example :: [XmlTree T String]

module Text.XML.WraXML.Document.Tagchup
type XmlDoc = T T
class (CharType char) => CharSpace char
isSpace :: (CharSpace char) => char -> Bool
class StringSpace string
isAllSpace :: (StringSpace string) => string -> Bool
dropSpace :: (StringSpace string) => [T name string] -> [T name string]
withoutLeadingSpace :: (StringSpace string) => ([T name string] -> (a, [T name string])) -> State [T name string] a
toXmlDocument :: (Tag name, Attribute name, StringSpace string) => [T name string] -> XmlDoc name string
example :: IO ()
instance (CharSpace char) => StringSpace [char]
instance CharSpace T
instance CharSpace Char
