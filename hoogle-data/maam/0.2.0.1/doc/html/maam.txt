-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An application of the Galois Transformers framework to two example semantics.
--   
@package maam
@version 0.2.0.1

module FP.GHCI

module FP.Core
data P a
P :: P a
data W (c :: Constraint)
W :: W c
with :: W c -> (c => a) -> a
class Universal a
class (c1 a, c2 a) => (::*::) c1 c2 a
class t (u a) => (::.::) t u a
class (::=>::) c1 c2
impl :: ((::=>::) c1 c2, c1) => W c2
class Functorial c t
functorial :: (Functorial c t, c a) => W (c (t a))
class Bifunctorial c t
bifunctorial :: (Bifunctorial c t, c a, c b) => W (c (t a b))
class ToInteger a
toInteger :: ToInteger a => a -> Integer
class FromInteger a
fromInteger :: FromInteger a => Integer -> a
class ToInt a
toInt :: ToInt a => a -> Int
class FromInt a
fromInt :: FromInt a => Int -> a
class ToRational a
toRational :: ToRational a => a -> Rational
class FromRational a
fromRational :: FromRational a => Rational -> a
class ToDouble a
toDouble :: ToDouble a => a -> Double
class FromDouble a
fromDouble :: FromDouble a => Double -> a
class ToString a
toString :: ToString a => a -> String
class Peano a
zer :: Peano a => a
suc :: Peano a => a -> a
piter :: (Eq a, Peano a) => (b -> b) -> b -> a -> b
piterOn :: (Eq a, Peano a) => a -> b -> (b -> b) -> b
class Peano a => Additive a
zero :: Additive a => a
(+) :: Additive a => a -> a -> a
class Additive a => Subtractive a
(-) :: Subtractive a => a -> a -> a
class Additive a => Multiplicative a
one :: Multiplicative a => a
(*) :: Multiplicative a => a -> a -> a
class Multiplicative a => Divisible a
(/) :: Divisible a => a -> a -> a
class Multiplicative a => TruncateDivisible a
(//) :: TruncateDivisible a => a -> a -> a
class (TruncateDivisible a, ToInteger a, FromInteger a, ToInt a, FromInt a, ToRational a, ToDouble a) => Integral a
class (Divisible a, ToRational a, FromRational a, ToDouble a, FromDouble a, FromInteger a, FromInt a) => Fractional a
negate :: Subtractive a => a -> a
inverse :: Divisible a => a -> a
data POrdering
PEQ :: POrdering
PLT :: POrdering
PGT :: POrdering
PUN :: POrdering
class PartialOrder a where pcompare x y = case (x ⊑ y, y ⊑ x) of { (True, True) -> PEQ (True, False) -> PLT (False, True) -> PGT (False, False) -> PUN } x ⊑ y = case pcompare x y of { PLT -> True PEQ -> True _ -> False } x ⊏ y = case pcompare x y of { PLT -> True _ -> False }
pcompare :: PartialOrder a => a -> a -> POrdering
(⊑) :: PartialOrder a => a -> a -> Bool
(⊏) :: PartialOrder a => a -> a -> Bool
(⋚) :: Ord a => a -> a -> Ordering
(⋈) :: PartialOrder a => a -> a -> POrdering
(⊒) :: PartialOrder a => a -> a -> Bool
(⊐) :: PartialOrder a => a -> a -> Bool
fromOrdering :: Ordering -> POrdering
discreteOrder :: Eq a => a -> a -> POrdering
findMax :: (Iterable a t, PartialOrder b) => (a -> b) -> a -> t -> a
findMaxFrom :: (Iterable a t, PartialOrder b) => a -> (a -> b) -> t -> a
poiter :: PartialOrder a => (a -> a) -> a -> a
poiterHistory :: PartialOrder a => (a -> a) -> a -> [a]
class Category t
catid :: Category t => t a a
(<.>) :: Category t => t b c -> t a b -> t a c
type (~>) m n = forall a. m a -> n a
type (~~>) t u = forall m. t m ~> u m
class Morphism a b
morph :: Morphism a b => a -> b
class Morphism2 m n
morph2 :: Morphism2 m n => m ~> n
class Morphism3 t u
morph3 :: Morphism3 t u => t ~~> u
class (Morphism a b, Morphism b a) => Isomorphism a b
isoto :: Isomorphism a b => a -> b
isofrom :: Isomorphism a b => b -> a
class (Morphism2 t u, Morphism2 u t) => Isomorphism2 t u
isoto2 :: Isomorphism2 t u => t ~> u
isofrom2 :: Isomorphism2 t u => u ~> t
onIso2 :: Isomorphism2 t u => (u a -> u b) -> t a -> t b
class (Morphism3 v w, Morphism3 w v) => Isomorphism3 v w
isoto3 :: Isomorphism3 v w => v ~~> w
isofrom3 :: Isomorphism3 v w => w ~~> v
class Monoid a
null :: Monoid a => a
(++) :: Monoid a => a -> a -> a
iterAppend :: (Monoid a, Eq n, Peano n) => n -> a -> a
concat :: (Iterable a t, Monoid a) => t -> a
class Bot a
bot :: Bot a => a
class Join a
(\/) :: Join a => a -> a -> a
class Top a
top :: Top a => a
class Meet a
(/\) :: Meet a => a -> a -> a
class Neg a
neg :: Neg a => a -> a
class Difference a
(\\) :: Difference a => a -> a -> a
class (Bot a, Join a) => JoinLattice a
class (Top a, Meet a) => MeetLattice a
class (JoinLattice a, MeetLattice a) => Lattice a
class (Lattice a, Neg a) => NegLattice a
joins :: (Iterable a t, JoinLattice a) => t -> a
meets :: (Iterable a t, MeetLattice a) => t -> a
collect :: (Join a, PartialOrder a) => (a -> a) -> a -> a
collectN :: (Join a, PartialOrder a, Eq n, Peano n) => n -> (a -> a) -> a -> a
collectHistory :: (Join a, PartialOrder a) => (a -> a) -> a -> [a]
diffs :: (JoinLattice a, Difference a) => [a] -> [a]
collectDiffs :: (PartialOrder a, JoinLattice a, Difference a) => (a -> a) -> a -> [a]
class Commute t u
commute :: Commute t u => t (u a) -> u (t a)
class Unit (t :: * -> *)
unit :: Unit t => a -> t a
class Functor (t :: * -> *)
map :: Functor t => (a -> b) -> (t a -> t b)
mapOn :: Functor t => t a -> (a -> b) -> t b
(^@) :: Functor t => (a -> b) -> t a -> t b
(^$) :: Functor t => (a -> b) -> t a -> t b
(^.) :: Functor t => (b -> c) -> (a -> t b) -> a -> t c
(.^) :: Functor t => (t b -> c) -> (a -> b) -> t a -> c
(^.:) :: Functor t => (c -> d) -> (a -> b -> t c) -> a -> b -> t d
(^..:) :: Functor t => (d -> e) -> (a -> b -> c -> t d) -> a -> b -> c -> t e
(^^.) :: (Functor t, Functor u) => (b -> c) -> (a -> t (u b)) -> a -> (t (u c))
class FunctorM (t :: * -> *)
mapM :: (FunctorM t, Monad m) => (a -> m b) -> t a -> m (t b)
mapOnM :: (FunctorM t, Monad m) => t a -> (a -> m b) -> m (t b)
sequence :: (FunctorM t, Monad m) => t (m a) -> m (t a)
(^*@) :: (FunctorM t, Monad m) => (a -> m b) -> t a -> m (t b)
(^*$) :: (FunctorM t, Monad m) => (a -> m b) -> t a -> m (t b)
(^*.) :: (FunctorM t, Monad m) => (b -> m c) -> (a -> m b) -> t a -> m (t c)
class (Unit t, Functor t) => Applicative (t :: * -> *)
(<@>) :: Applicative t => t (a -> b) -> t a -> t b
pure :: Applicative t => a -> t a
(<$>) :: Applicative t => t (a -> b) -> t a -> t b
apair :: Applicative t => t a -> t b -> t (a, b)
class Product (t :: * -> *)
(<*>) :: Product t => t a -> t b -> t (a, b)
class Product m => Bind (m :: * -> *)
(>>=) :: Bind m => m a -> (a -> m b) -> m b
class (Applicative m, Bind m) => Monad (m :: * -> *)
fail :: Chars -> m a
return :: Monad m => a -> m a
kleisli :: Monad m => (a -> b) -> (a -> m b)
(>>) :: Bind m => m a -> m b -> m b
extend :: Bind m => (a -> m b) -> (m a -> m b)
void :: Functor m => m a -> m ()
(*@) :: Bind m => (a -> m b) -> (m a -> m b)
(*$) :: Bind m => (a -> m b) -> (m a -> m b)
(*.) :: Bind m => (b -> m c) -> (a -> m b) -> (a -> m c)
mjoin :: Bind m => m (m a) -> m a
mmap :: Monad m => (a -> b) -> m a -> m b
mpair :: Monad m => m a -> m b -> m (a, b)
mapply :: Monad m => m (a -> b) -> m a -> m b
when :: Monad m => Bool -> m () -> m ()
traverse :: (Iterable a t, Monad m) => (a -> m ()) -> t -> m ()
traverseOn :: (Iterable a t, Monad m) => t -> (a -> m ()) -> m ()
exec :: (Iterable (m ()) t, Monad m) => t -> m ()
class Unit2 (t :: (* -> *) -> (* -> *))
unit2 :: Unit2 t => m ~> t m
class Join2 (t :: (* -> *) -> (* -> *))
join2 :: Join2 t => t (t m) ~> t m
class Functor2 (t :: (* -> *) -> (* -> *))
map2 :: Functor2 t => (m ~> n) -> (t m ~> t n)
class IsoFunctor2 (t :: (* -> *) -> (* -> *))
isoMap2 :: IsoFunctor2 t => (m ~> n, n ~> m) -> (t m ~> t n)
class FunctorUnit2 (t :: (* -> *) -> (* -> *))
funit2 :: (FunctorUnit2 t, Functor m) => m ~> t m
class FunctorJoin2 (t :: (* -> *) -> (* -> *))
fjoin2 :: (FunctorJoin2 t, Functor m) => t (t m) ~> t m
class FunctorFunctor2 (t :: (* -> *) -> (* -> *))
fmap2 :: (FunctorFunctor2 t, Functor m, Functor n) => (m ~> n) -> (t m ~> t n)
class FunctorIsoFunctor2 (t :: (* -> *) -> (* -> *))
fisoMap2 :: (FunctorIsoFunctor2 t, Functor m, Functor n) => (m ~> n, n ~> m) -> (t m ~> t n)
class MonadUnit2 (t :: (* -> *) -> (* -> *))
munit2 :: (MonadUnit2 t, Monad m) => m ~> t m
class MonadJoin2 (t :: (* -> *) -> (* -> *))
mjoin2 :: (MonadJoin2 t, Monad m) => t (t m) ~> t m
class MonadFunctor2 (t :: (* -> *) -> (* -> *))
mmap2 :: (MonadFunctor2 t, Monad m, Monad n) => (m ~> n) -> (t m ~> t n)
class MonadIsoFunctor2 (t :: (* -> *) -> (* -> *))
misoMap2 :: (MonadIsoFunctor2 t, Monad m, Monad n) => (m ~> n, n ~> m) -> (t m ~> t n)
class MonadIO m
io :: MonadIO m => IO ~> m
class MonadQ m
liftQ :: MonadQ m => Q ~> m
class MonadBot (m :: * -> *)
mbot :: MonadBot m => m a
class MonadTop (m :: * -> *)
mtop :: MonadTop m => m a
class MonadBot m => MonadAppend (m :: * -> *)
(<++>) :: MonadAppend m => m a -> m a -> m a
class MonadBot m => MonadPlus (m :: * -> *)
(<+>) :: MonadPlus m => m a -> m a -> m a
guard :: (Monad m, MonadBot m) => Bool -> m ()
maybeZero :: (Monad m, MonadBot m) => Maybe a -> m a
mconcat :: (Iterable (m a) t, MonadAppend m) => t -> m a
mlist :: (Iterable a t, Monad m, MonadAppend m) => t -> m a
msum :: (Iterable (m a) t, MonadPlus m) => t -> m a
mset :: (Iterable a t, Monad m, MonadPlus m) => t -> m a
many :: (Monad m, MonadAppend m) => m a -> m [a]
oneOrMore :: (Monad m, MonadAppend m) => m a -> m (a, [a])
twoOrMore :: (Monad m, MonadAppend m) => m a -> m (a, a, [a])
oneOrMoreList :: (Monad m, MonadAppend m) => m a -> m [a]
newtype MaybeT m a
MaybeT :: m (Maybe a) -> MaybeT m a
unMaybeT :: MaybeT m a -> m (Maybe a)
class MonadMaybe (m :: * -> *)
maybeI :: MonadMaybe m => m ~> MaybeT m
maybeE :: MonadMaybe m => MaybeT m ~> m
obsMaybe :: MonadMaybe m => m a -> m (Maybe a)
effMaybe :: MonadMaybe m => m (Maybe a) -> m a
abort :: (Monad m, MonadMaybe m) => m a
mtry :: (Monad m, MonadMaybe m, Iterable (m a) t) => t -> m a
(<|>) :: (Monad m, MonadMaybe m) => m a -> m a -> m a
newtype ErrorT e m a
ErrorT :: m (e :+: a) -> ErrorT e m a
unErrorT :: ErrorT e m a -> m (e :+: a)
class MonadError e (m :: * -> *) | m -> e
errorI :: MonadError e m => m ~> ErrorT e m
errorE :: MonadError e m => ErrorT e m ~> m
obsError :: MonadError e m => m a -> m (e :+: a)
effError :: MonadError e m => m (e :+: a) -> m a
sumError :: (Monad m, MonadError e m) => e :+: a -> m a
throw :: (Monad m, MonadError e m) => e -> m a
catch :: (Monad m, MonadError e m) => m a -> (e -> m a) -> m a
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
unReaderT :: ReaderT r m a -> r -> m a
class MonadReader r (m :: * -> *) | m -> r
readerI :: MonadReader r m => m ~> ReaderT r m
readerE :: MonadReader r m => ReaderT r m ~> m
runReaderT :: r -> ReaderT r m a -> m a
obsReader :: MonadReader r m => m a -> (r -> m a)
effReader :: MonadReader r m => (r -> m a) -> m a
ask :: (Monad m, MonadReader r m) => m r
local :: MonadReader r m => (r -> r) -> m a -> m a
localSet :: MonadReader r m => r -> m a -> m a
askL :: (Monad m, MonadReader r m) => Lens r a -> m a
localL :: MonadReader r m => Lens r b -> (b -> b) -> m a -> m a
localSetL :: MonadReader r m => Lens r b -> b -> m a -> m a
newtype WriterT o m a
WriterT :: m (o, a) -> WriterT o m a
unWriterT :: WriterT o m a -> m (o, a)
class MonadWriter o m | m -> o
writerI :: MonadWriter o m => m ~> WriterT o m
writerE :: MonadWriter o m => WriterT o m ~> m
obsWriter :: MonadWriter o m => m a -> m (o, a)
effWriter :: MonadWriter o m => m (o, a) -> m a
tell :: (Monad m, MonadWriter o m) => o -> m ()
hijack :: MonadWriter o m => m a -> m (o, a)
newtype StateT s m a
StateT :: (s -> m (s, a)) -> StateT s m a
unStateT :: StateT s m a -> s -> m (s, a)
class MonadState s m | m -> s
stateI :: MonadState s m => m ~> StateT s m
stateE :: MonadState s m => StateT s m ~> m
obsState :: MonadState s m => m a -> (s -> m (s, a))
effState :: MonadState s m => (s -> m (s, a)) -> m a
get :: (Monad m, MonadState s m) => m s
put :: (Monad m, MonadState s m) => s -> m ()
modify :: (Monad m, MonadState s m) => (s -> s) -> m ()
modifyM :: (Monad m, MonadState s m) => (s -> m s) -> m ()
getL :: (Monad m, MonadState s m) => Lens s a -> m a
putL :: (Monad m, MonadState s m) => Lens s a -> a -> m ()
modifyL :: (Monad m, MonadState s m) => Lens s a -> (a -> a) -> m ()
modifyLM :: (Monad m, MonadState s m) => Lens s a -> (a -> m a) -> m ()
next :: (Monad m, MonadState s m, Peano s) => m s
nextL :: (Monad m, MonadState s m, Peano a) => Lens s a -> m a
bumpL :: (Monad m, MonadState s m, Peano a) => Lens s a -> m ()
newtype RWST r o s m a
RWST :: ReaderT r (WriterT o (StateT s m)) a -> RWST r o s m a
unRWST :: RWST r o s m a -> ReaderT r (WriterT o (StateT s m)) a
class (MonadReader r m, MonadWriter o m, MonadState s m) => MonadRWS r o s m
rwsI :: MonadRWS r o s m => m ~> RWST r o s m
rwsE :: MonadRWS r o s m => RWST r o s m ~> m
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
unContT :: ContT r m a -> (a -> m r) -> m r
class MonadCont r m | m -> r
contI :: MonadCont r m => m ~> ContT r m
contE :: MonadCont r m => ContT r m ~> m
obsCont :: MonadCont r m => m a -> ((a -> m r) -> m r)
effCont :: MonadCont r m => ((a -> m r) -> m r) -> m a
callCC :: MonadCont r m => ((a -> m r) -> m r) -> m a
withC :: MonadCont r m => (a -> m r) -> m a -> m r
reset :: (Monad m, MonadCont r m) => m r -> m r
modifyC :: (Monad m, MonadCont r m) => (r -> m r) -> m a -> m a
newtype OpaqueContT k r m a
OpaqueContT :: (k r m a -> m r) -> OpaqueContT k r m a
unOpaqueContT :: OpaqueContT k r m a -> k r m a -> m r
class MonadOpaqueCont k r m | m -> k, m -> r
opaqueContI :: MonadOpaqueCont k r m => m ~> OpaqueContT k r m
opaqueContE :: MonadOpaqueCont k r m => OpaqueContT k r m ~> m
obsOpaqueCont :: MonadOpaqueCont k r m => m a -> (k r m a -> m r)
effOpaqueCont :: MonadOpaqueCont k r m => (k r m a -> m r) -> m a
opaqueWithC :: MonadOpaqueCont k r m => k r m a -> m a -> m r
opaqueCallCC :: MonadOpaqueCont k r m => (k r m a -> m r) -> m a
class Container e t | t -> e
(?) :: Container e t => t -> e -> Bool
elem :: Container e t => e -> t -> Bool
class Indexed k v t | t -> k, t -> v
(#) :: Indexed k v t => t -> k -> Maybe v
index :: Indexed k v t => t -> k -> Maybe v
(#!) :: Indexed k v t => t -> k -> v
lookup :: Indexed k v t => k -> t -> Maybe v
class Iterable a t | t -> a where foldlk f i0 t = foldl (\ (iK :: (b -> b) -> b) (a :: a) (k :: b -> b) -> iK $ \ i -> f i a k) ($ i0) t id foldl f = foldlk $ \ i a k -> let i' = f i a in i' `seq` k i' foldr f = foldlk $ \ i a k -> f a $ k i iter = foldl . flip size = iter (const suc) 0
foldlk :: Iterable a t => (b -> a -> (b -> b) -> b) -> b -> t -> b
foldl :: Iterable a t => (b -> a -> b) -> b -> t -> b
foldr :: Iterable a t => (a -> b -> b) -> b -> t -> b
iter :: Iterable a t => (a -> b -> b) -> b -> t -> b
size :: (Iterable a t, Integral n) => t -> n
foldlOn :: Iterable a t => t -> b -> (b -> a -> b) -> b
foldlFrom :: Iterable a t => b -> (b -> a -> b) -> t -> b
foldrOn :: Iterable a t => t -> b -> (a -> b -> b) -> b
foldrFrom :: Iterable a t => b -> (a -> b -> b) -> t -> b
iterOn :: Iterable a t => t -> b -> (a -> b -> b) -> b
iterFrom :: Iterable a t => b -> (a -> b -> b) -> t -> b
isElem :: (Iterable a t, Eq a) => a -> t -> Bool
elemAtN :: (Iterable a t, Peano n, Eq n) => n -> t -> Maybe a
toList :: Iterable a t => t -> [a]
toSet :: (Ord a, Iterable a t) => t -> Set a
toMap :: (Ord k, Iterable (k, v) t) => t -> Map k v
toMapJoin :: (Ord k, Iterable (k, v) t, Join v) => t -> Map k v
class Buildable a t | t -> a
nil :: Buildable a t => t
(&) :: Buildable a t => a -> t -> t
build :: Buildable a t => [a] -> t
single :: Buildable a t => a -> t
filter :: (Iterable a t, Buildable a t) => (a -> Bool) -> t -> t
reverse :: (Iterable a t, Buildable a t) => t -> t
uniques :: (Eq a, Iterable a t, Buildable a t) => t -> t
replicate :: (Eq n, Peano n, Iterable a t, Buildable a t) => n -> a -> t
fromList :: Buildable a t => [a] -> t
fromSet :: Buildable a t => Set a -> t
fromMap :: Buildable (k, v) t => Map k v -> t
applyTo :: a -> (a -> b) -> b
(.:) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
(..:) :: (d -> e) -> (a -> b -> c -> d) -> (a -> b -> c -> e)
(...:) :: (e -> f) -> (a -> b -> c -> d -> e) -> (a -> b -> c -> d -> f)
(....:) :: (f -> g) -> (a -> b -> c -> d -> e -> f) -> (a -> b -> c -> d -> e -> g)
rotateR :: (a -> b -> c -> d) -> (c -> a -> b -> d)
rotateL :: (a -> b -> c -> d) -> (b -> c -> a -> d)
mirror :: (a -> b -> c -> d) -> (c -> b -> a -> d)
on :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)
composition :: [a -> a] -> a -> a
data Endo a
Endo :: (a -> a) -> Endo a
unEndo :: Endo a -> a -> a
runEndo :: a -> Endo a -> a
data KleisliEndo m a
KleisliEndo :: (a -> m a) -> KleisliEndo m a
unKleisliEndo :: KleisliEndo m a -> a -> m a
runKleisliEndo :: a -> KleisliEndo m a -> m a
ifThenElse :: Bool -> a -> a -> a
fif :: Bool -> a -> a -> a
cond :: (a -> Bool) -> c -> c -> (a -> c)
type String = Text
type Chars = [Char]
fromChars :: Chars -> String
fromString :: Chars -> String
toChars :: String -> Chars
error :: String -> a
show :: Show a => a -> String
read :: Read a => String -> a
data Cursor a b
Cursor :: a -> (a -> b) -> Cursor a b
focus :: Cursor a b -> a
construct :: Cursor a b -> a -> b
data Lens a b
Lens :: (a -> Cursor b a) -> Lens a b
unLens :: Lens a b -> a -> Cursor b a
lens :: (a -> b) -> (a -> b -> a) -> Lens a b
isoLens :: (a -> b) -> (b -> a) -> Lens a b
update :: Lens a b -> (b -> b) -> a -> a
updateM :: Monad m => Lens a b -> (b -> m b) -> a -> m a
access :: Lens a b -> a -> b
(~:) :: Lens a b -> (b -> b) -> a -> a
set :: Lens a b -> b -> a -> a
(=:) :: Lens a b -> b -> a -> a
(|:) :: a -> (a -> a) -> a
data Prism a b
Prism :: (b -> a) -> (a -> Maybe b) -> Prism a b
inject :: Prism a b -> b -> a
view :: Prism a b -> a -> Maybe b
prism :: (b -> a) -> (a -> Maybe b) -> Prism a b
isoPrism :: (b -> a) -> (a -> b) -> Prism a b
unsafe_coerce :: Prism a b -> a -> b
is :: Prism a b -> a -> Bool
alter :: Prism a b -> (b -> b) -> a -> a
(~^) :: Prism a b -> (b -> b) -> a -> a
pset :: Prism a b -> b -> a -> a
(=^) :: Prism a b -> b -> a -> a
newtype (:.:) t u a
Compose :: t (u a) -> (:.:) t u a
unCompose :: (:.:) t u a -> t (u a)
onComposeIso :: (t (u a) -> t (u b)) -> (t :.: u) a -> (t :.: u) b
swap :: (a, b) -> (b, a)
fstL :: Lens (a, b) a
sndL :: Lens (a, b) b
mapFst :: (a -> a') -> (a, b) -> (a', b)
mapSnd :: (b -> b') -> (a, b) -> (a, b')
data (:+:) a b
Inl :: a -> (:+:) a b
Inr :: b -> (:+:) a b
sumElim :: (a -> c) -> (b -> c) -> a :+: b -> c
inlL :: Prism (a :+: b) a
inrL :: Prism (a :+: b) b
mapInl :: (a -> a') -> a :+: b -> a' :+: b
mapInr :: (b -> b') -> a :+: b -> a :+: b'
mapSum :: (a -> a') -> (b -> b') -> a :+: b -> a' :+: b'
maybeElim :: b -> (a -> b) -> Maybe a -> b
nothingL :: Prism (Maybe a) ()
justL :: Prism (Maybe a) a
maybeElimOn :: Maybe a -> b -> (a -> b) -> b
maybeNot :: a -> Maybe a -> a
nilL :: Prism [a] ()
consL :: Prism [a] (a, [a])
singleL :: Prism [a] a
length :: Peano n => [a] -> n
mapHead :: (a -> a) -> [a] -> [a]
mapTail :: (a -> a) -> [a] -> [a]
head :: [a] -> Maybe a
tail :: [a] -> Maybe [a]
zip :: [a] -> [b] -> Maybe [(a, b)]
unzip :: [(a, b)] -> ([a], [b])
firstN :: (Eq n, Integral n) => n -> [a] -> [a]
intersperse :: a -> [a] -> [a]
pluck :: [a] -> [[a]] -> Maybe ([a], [[a]])
transpose :: [[a]] -> [[a]]
bigProduct :: [[a]] -> [[a]]
data Set a
EmptySet :: Set a
Set :: Set a -> Set a
setPrimElim :: b -> (Ord a => Set a -> b) -> Set a -> b
setPrimElimOn :: Set a -> b -> (Ord a => Set a -> b) -> b
setPrimElim2 :: b -> (Ord a => Set a -> b) -> (Ord a => Set a -> b) -> (Ord a => Set a -> Set a -> b) -> Set a -> Set a -> b
setPrimElim2' :: b -> (Ord a => Set a -> b) -> (Ord a => Set a -> Set a -> b) -> Set a -> Set a -> b
toPrimSet :: Set a -> Set a
learnSet :: Set a -> b -> (Ord a => b) -> b
empty :: Set a
isEmpty :: Set a -> Bool
insert :: Ord a => a -> Set a -> Set a
union :: Set a -> Set a -> Set a
intersection :: Set a -> Set a -> Set a
remove :: Set a -> Maybe (a, Set a)
setDiff :: Set a -> Set a -> Set a
setMap :: Ord b => (a -> b) -> Set a -> Set b
setMapOn :: Ord b => Set a -> (a -> b) -> Set b
maybeSet :: Ord a => Maybe a -> Set a
setTranspose :: Set (Set a) -> Set (Set a)
setBigProduct :: Set (Set a) -> Set (Set a)
data Map k v
EmptyMap :: Map k v
Map :: Map k v -> Map k v
type Old v = v
type New v = v
mapPrimElim :: b -> (Ord k => Map k v -> b) -> Map k v -> b
mapPrimElimOn :: Map k v -> b -> (Ord k => Map k v -> b) -> b
mapPrimElim2 :: b -> (Ord k => Map k v -> b) -> (Ord k => Map k v -> b) -> (Ord k => Map k v -> Map k v -> b) -> Map k v -> Map k v -> b
mapPrimElim2' :: b -> (Ord k => Map k v -> b) -> (Ord k => Map k v -> Map k v -> b) -> Map k v -> Map k v -> b
toPrimMap :: Map k v -> Map k v
learnMap :: Map k v -> b -> (Ord k => b) -> b
mapEmpty :: Map k v
mapIsEmpty :: Map k v -> Bool
mapKeys :: Map k v -> Set k
mapInsert :: Ord k => k -> v -> Map k v -> Map k v
mapSingleton :: Ord k => k -> v -> Map k v
mapInsertWith :: Ord k => (Old v -> New v -> v) -> k -> v -> Map k v -> Map k v
mapRemove :: Map k v -> Maybe ((k, v), Map k v)
mapUnionWith :: (Old v -> New v -> v) -> Map k v -> Map k v -> Map k v
mapIntersectionWith :: (Old v -> New v -> v) -> Map k v -> Map k v -> Map k v
mapModify :: (v -> v) -> k -> Map k v -> Map k v
onlyKeys :: Ord k => Set k -> Map k v -> Map k v
mapFilter :: (v -> Bool) -> Map k v -> Map k v
mapNoBot :: (Bot v, Eq v) => Map k v -> Map k v
newtype ListSet a
ListSet :: [a] -> ListSet a
unListSet :: ListSet a -> [a]
listSetTranspose :: ListSet (ListSet a) -> ListSet (ListSet a)
print :: MonadIO m => String -> m ()
failIO :: MonadIO m => String -> m a
data Stamped a f
Stamped :: a -> f -> Stamped a f
stampedID :: Stamped a f -> a
stamped :: Stamped a f -> f
newtype Fix f
Fix :: f (Fix f) -> Fix f
unFix :: Fix f -> f (Fix f)
data StampedFix a f
StampedFix :: a -> f (StampedFix a f) -> StampedFix a f
stampedFixID :: StampedFix a f -> a
stampedFix :: StampedFix a f -> f (StampedFix a f)
stripStampedFix :: Functor f => StampedFix a f -> Fix f
data Annotated ann a
Annotated :: ann -> a -> Annotated ann a
annotation :: Annotated ann a -> ann
annValue :: Annotated ann a -> a
data ListSetWithTop a
ListSetTop :: ListSetWithTop a
ListSetNotTop :: (ListSet a) -> ListSetWithTop a
listSetWithTopElim :: b -> (ListSet a -> b) -> ListSetWithTop a -> b
listSetWithTopTranspose :: ListSetWithTop (ListSetWithTop a) -> ListSetWithTop (ListSetWithTop a)
data SetWithTop a
SetTop :: SetWithTop a
SetNotTop :: (Set a) -> SetWithTop a
setWithTopElim :: b -> (Set a -> b) -> SetWithTop a -> b
setFromListWithTop :: Ord a => ListSetWithTop a -> SetWithTop a
listFromSetWithTop :: SetWithTop a -> ListSetWithTop a
data ConstructiveClassical a
Constructive :: (Set a) -> ConstructiveClassical a
Classical :: (a -> Bool) -> ConstructiveClassical a
conClaPartition :: [ConstructiveClassical a] -> ([Set a], [a -> Bool])
conClaBigProduct :: Ord a => [ConstructiveClassical a] -> ListSetWithTop a
newtype SumOfProd a
SumOfProd :: Set (Set a) -> SumOfProd a
unSumOfProd :: SumOfProd a -> Set (Set a)
sumOfProdMap :: Ord b => (a -> b) -> SumOfProd a -> SumOfProd b
sumOfProdConcretize :: Ord b => (a -> ConstructiveClassical b) -> SumOfProd a -> SetWithTop b
instance Eq (t (u a)) => Eq ((:.:) t u a)
instance Ord (t (u a)) => Ord ((:.:) t u a)
instance Bot (t (u a)) => Bot ((:.:) t u a)
instance Join (t (u a)) => Join ((:.:) t u a)
instance JoinLattice (t (u a)) => JoinLattice ((:.:) t u a)
instance Top (t (u a)) => Top ((:.:) t u a)
instance Meet (t (u a)) => Meet ((:.:) t u a)
instance MeetLattice (t (u a)) => MeetLattice ((:.:) t u a)
instance Lattice (t (u a)) => Lattice ((:.:) t u a)
instance PartialOrder (t (u a)) => PartialOrder ((:.:) t u a)
instance (Eq a, Eq b) => Eq (a :+: b)
instance (Ord a, Ord b) => Ord (a :+: b)
instance Eq a => Container a (ListSet a)
instance Iterable a (ListSet a)
instance Buildable a (ListSet a)
instance Monoid (ListSet a)
instance Unit ListSet
instance Functor ListSet
instance Applicative ListSet
instance Product ListSet
instance Bind ListSet
instance Monad ListSet
instance Eq (SetWithTop a)
instance Ord (SetWithTop a)
instance Eq (SumOfProd a)
instance Ord (SumOfProd a)
instance JoinLattice (SumOfProd a)
instance (Ord a, Neg a) => Neg (SumOfProd a)
instance Meet (SumOfProd a)
instance Join (SumOfProd a)
instance Bot (SumOfProd a)
instance Ord a => Buildable a (SumOfProd a)
instance MeetLattice (SetWithTop a)
instance JoinLattice (SetWithTop a)
instance Bind SetWithTop
instance Product SetWithTop
instance MonadTop SetWithTop
instance MonadPlus SetWithTop
instance MonadBot SetWithTop
instance Meet (SetWithTop a)
instance Top (SetWithTop a)
instance Join (SetWithTop a)
instance Difference (SetWithTop a)
instance Ord a => Buildable a (SetWithTop a)
instance Bot (SetWithTop a)
instance Ord a => PartialOrder (SetWithTop a)
instance Monad ListSetWithTop
instance Applicative ListSetWithTop
instance Product ListSetWithTop
instance Functor ListSetWithTop
instance Bind ListSetWithTop
instance Unit ListSetWithTop
instance MonadAppend ListSetWithTop
instance MonadTop ListSetWithTop
instance MonadPlus ListSetWithTop
instance MonadBot ListSetWithTop
instance MeetLattice (ListSetWithTop a)
instance JoinLattice (ListSetWithTop a)
instance Monoid (ListSetWithTop a)
instance Ord a => Difference (ListSetWithTop a)
instance Meet (ListSetWithTop a)
instance Top (ListSetWithTop a)
instance Join (ListSetWithTop a)
instance Bot (ListSetWithTop a)
instance Buildable a (ListSetWithTop a)
instance Ord a => PartialOrder (ListSetWithTop a)
instance PartialOrder a => PartialOrder (StampedFix a f)
instance Ord a => Ord (StampedFix a f)
instance Eq a => Eq (StampedFix a f)
instance (Functorial Eq f, Functorial Ord f) => Ord (Fix f)
instance Functorial Eq f => Eq (Fix f)
instance Ord a => Ord (Stamped a f)
instance Eq a => Eq (Stamped a f)
instance Monad Q
instance MonadBot Q
instance MonadQ Q
instance Bind Q
instance Product Q
instance Applicative Q
instance Functor Q
instance Unit Q
instance Monad IO
instance MonadIO IO
instance Bind IO
instance Product IO
instance Applicative IO
instance Functor IO
instance Unit IO
instance JoinLattice (ListSet a)
instance MonadPlus ListSet
instance MonadBot ListSet
instance Join (ListSet a)
instance Bot (ListSet a)
instance Ord a => PartialOrder (ListSet a)
instance FunctorM ListSet
instance Functor (Map k)
instance JoinLattice v => JoinLattice (Map k v)
instance Difference v => Difference (Map k v)
instance Monoid v => Monoid (Map k v)
instance Join v => Join (Map k v)
instance Bot (Map k v)
instance Ord k => Buildable (k, v) (Map k v)
instance Eq v => Container (k, v) (Map k v)
instance Indexed k v (Map k v)
instance (Ord k, PartialOrder v) => PartialOrder (Map k v)
instance (Ord k, Ord v) => Ord (Map k v)
instance (Eq k, Eq v) => Eq (Map k v)
instance Iterable (k, v) (Map k v)
instance JoinLattice (Set a)
instance Difference (Set a)
instance Monoid (Set a)
instance Meet (Set a)
instance Join (Set a)
instance Bot (Set a)
instance MonadAppend Set
instance MonadPlus Set
instance MonadBot Set
instance Bind Set
instance Product Set
instance PartialOrder (Set a)
instance Ord (Set a)
instance Eq (Set a)
instance Ord a => Buildable a (Set a)
instance Iterable a (Set a)
instance Container a (Set a)
instance Monad []
instance Functorial Ord []
instance Functorial Eq []
instance Functorial Monoid []
instance MonadAppend []
instance MonadBot []
instance Applicative []
instance Product []
instance Functor []
instance Unit []
instance Monoid [a]
instance Buildable a [a]
instance Eq a => Container a [a]
instance FunctorM []
instance Bind []
instance Eq k => Indexed k v [(k, v)]
instance Iterable a [a]
instance Monad Maybe
instance MonadAppend Maybe
instance MonadBot Maybe
instance Product Maybe
instance Applicative Maybe
instance Functor Maybe
instance Unit Maybe
instance Bind Maybe
instance Monoid (Maybe a)
instance MonadMaybe Maybe
instance Monad ((:+:) a)
instance Bind ((:+:) a)
instance Applicative ((:+:) a)
instance Product ((:+:) a)
instance Functor ((:+:) a)
instance Unit ((:+:) a)
instance MonadError a ((:+:) a)
instance Bifunctorial Ord (,)
instance Bifunctorial Eq (,)
instance (Difference a, Difference b) => Difference (a, b)
instance JoinLattice a => Functorial JoinLattice ((,) a)
instance (JoinLattice a, JoinLattice b, JoinLattice c, JoinLattice d, JoinLattice e) => JoinLattice (a, b, c, d, e)
instance (Join a, Join b, Join c, Join d, Join e) => Join (a, b, c, d, e)
instance (Bot a, Bot b, Bot c, Bot d, Bot e) => Bot (a, b, c, d, e)
instance (JoinLattice a, JoinLattice b, JoinLattice c) => JoinLattice (a, b, c)
instance (Join a, Join b, Join c) => Join (a, b, c)
instance (Bot a, Bot b, Bot c) => Bot (a, b, c)
instance (JoinLattice a, JoinLattice b) => JoinLattice (a, b)
instance (Join a, Join b) => Join (a, b)
instance (Bot a, Bot b) => Bot (a, b)
instance (Monoid a, Monoid b) => Monoid (a, b)
instance (PartialOrder a, PartialOrder b, PartialOrder c, PartialOrder d, PartialOrder e) => PartialOrder (a, b, c, d, e)
instance (PartialOrder a, PartialOrder b, PartialOrder c) => PartialOrder (a, b, c)
instance (PartialOrder a, PartialOrder b) => PartialOrder (a, b)
instance (Functorial JoinLattice t, Functorial JoinLattice u) => Functorial JoinLattice (t :.: u)
instance (Functor t, Functor u) => Functor (t :.: u)
instance Category Prism
instance Category Lens
instance Iterable Char String
instance Container Char String
instance ToString String
instance Monoid String
instance ToString Char
instance Fractional Double
instance Monoid Double
instance Neg Double
instance Meet Double
instance Join Double
instance PartialOrder Double
instance Divisible Double
instance Multiplicative Double
instance Subtractive Double
instance Additive Double
instance Peano Double
instance ToString Double
instance FromDouble Double
instance ToDouble Double
instance FromRational Double
instance ToRational Double
instance FromInt Double
instance FromInteger Double
instance Fractional Rational
instance Monoid Rational
instance Neg Rational
instance Meet Rational
instance Join Rational
instance PartialOrder Rational
instance Divisible Rational
instance Multiplicative Rational
instance Subtractive Rational
instance Additive Rational
instance Peano Rational
instance ToString Rational
instance FromDouble Rational
instance ToDouble Rational
instance FromRational Rational
instance ToRational Rational
instance FromInt Rational
instance FromInteger Rational
instance NegLattice Int
instance Lattice Int
instance MeetLattice Int
instance JoinLattice Int
instance Integral Int
instance Monoid Int
instance Neg Int
instance Meet Int
instance Top Int
instance Join Int
instance Bot Int
instance PartialOrder Int
instance TruncateDivisible Int
instance Multiplicative Int
instance Subtractive Int
instance Additive Int
instance Peano Int
instance ToString Int
instance ToDouble Int
instance ToRational Int
instance FromInt Int
instance ToInt Int
instance FromInteger Int
instance ToInteger Int
instance Integral Integer
instance Monoid Integer
instance Neg Integer
instance Meet Integer
instance Join Integer
instance PartialOrder Integer
instance TruncateDivisible Integer
instance Multiplicative Integer
instance Subtractive Integer
instance Additive Integer
instance Peano Integer
instance ToString Integer
instance ToDouble Integer
instance ToRational Integer
instance FromInt Integer
instance ToInt Integer
instance FromInteger Integer
instance ToInteger Integer
instance Lattice Bool
instance MeetLattice Bool
instance JoinLattice Bool
instance ToString Bool
instance Monoid Bool
instance Meet Bool
instance Top Bool
instance Join Bool
instance Bot Bool
instance Monad m => Monoid (KleisliEndo m a)
instance Monoid (Endo a)
instance NegLattice b => NegLattice (a -> b)
instance Lattice b => Lattice (a -> b)
instance MeetLattice b => MeetLattice (a -> b)
instance JoinLattice b => JoinLattice (a -> b)
instance Neg b => Neg (a -> b)
instance Meet b => Meet (a -> b)
instance Top b => Top (a -> b)
instance Join b => Join (a -> b)
instance Bot b => Bot (a -> b)
instance Monoid b => Monoid (a -> b)
instance Functor ((->) a)
instance Category (->)
instance (t (u a)) => (::.::) t u a
instance (c1 a, c2 a) => (::*::) c1 c2 a
instance Universal a

module FP.Free
data FreeMonoid a
MonoidElem :: a -> FreeMonoid a
Null :: FreeMonoid a
(:++:) :: FreeMonoid a -> FreeMonoid a -> FreeMonoid a
data FreeFunctor f a
FunctorElem :: a -> FreeFunctor f a
Apply :: (f (FreeFunctor f a)) -> FreeFunctor f a
data FreeMonoidFunctor f a
MonoidFunctorElem :: a -> FreeMonoidFunctor f a
MFNull :: FreeMonoidFunctor f a
(:+++:) :: FreeMonoidFunctor f a -> FreeMonoidFunctor f a -> FreeMonoidFunctor f a
MFApply :: (f (FreeMonoidFunctor f a)) -> FreeMonoidFunctor f a
instance Functor f => Functor (FreeMonoidFunctor f)
instance Monoid (FreeMonoidFunctor f a)
instance Unit (FreeMonoidFunctor f)
instance Functor f => Functor (FreeFunctor f)
instance Unit (FreeFunctor f)
instance Functor FreeMonoid
instance Monoid (FreeMonoid a)
instance Unit FreeMonoid

module FP.Monads
newtype ID a
ID :: a -> ID a
unID :: ID a -> a
newtype IDT m a
IDT :: m a -> IDT m a
unIDT :: IDT m a -> m a
maybeCommute :: Functor m => MaybeT (MaybeT m) ~> MaybeT (MaybeT m)
mapError :: Functor m => (e1 -> e2) -> ErrorT e1 m a -> ErrorT e2 m a
errorCommute :: Functor m => ErrorT e (ErrorT e m) ~> ErrorT e (ErrorT e m)
type Reader r = ReaderT r ID
runReader :: r -> Reader r a -> a
readerCommute :: ReaderT r1 (ReaderT r2 m) ~> ReaderT r2 (ReaderT r1 m)
execWriterT :: Functor m => WriterT o m a -> m o
mapOutput :: Functor m => (o1 -> o2) -> WriterT o1 m a -> WriterT o2 m a
writerCommute :: Functor m => WriterT o1 (WriterT o2 m) ~> WriterT o2 (WriterT o1 m)
runStateT :: s -> StateT s m a -> m (s, a)
evalStateT :: Functor m => s -> StateT s m a -> m a
execStateT :: Functor m => s -> StateT s m a -> m s
mapStateT :: Functor m => (s1 -> s2) -> (s2 -> s1) -> StateT s1 m a -> StateT s2 m a
type State s = StateT s ID
runState :: s -> State s a -> (s, a)
evalState :: s -> State s a -> a
execState :: s -> State s a -> s
stateCommute :: Functor m => StateT s1 (StateT s2 m) ~> StateT s2 (StateT s1 m)
stateLens :: Functor m => Lens s1 s2 -> StateT s2 m ~> StateT s1 m
stateLensE :: (MonadState s1 m, Monad m) => Lens s1 s2 -> (StateT s2 m ~> m)
newtype AddStateT s12 s1 m a
AddStateT :: StateT s1 m a -> AddStateT s12 s1 m a
runAddStateT :: AddStateT s12 s1 m a -> StateT s1 m a
mergeState :: Functor m => StateT s1 (StateT s2 m) a -> StateT (s1, s2) m a
splitState :: Functor m => StateT (s1, s2) m a -> StateT s1 (StateT s2 m) a
runRWST :: Functor m => r -> s -> RWST r o s m a -> m (s, o, a)
rwsCommute :: (Monad m, Monoid o1, Monoid o2) => RWST r1 o1 s1 (RWST r2 o2 s2 m) ~> RWST r2 o2 s2 (RWST r1 o1 s1 m)
newtype ListT m a
ListT :: m [a] -> ListT m a
unListT :: ListT m a -> m [a]
listCommute :: Functor m => ListT (ListT m) ~> ListT (ListT m)
maybeToList :: Functor m => MaybeT m a -> ListT m a
newtype ListSetT m a
ListSetT :: m (ListSet a) -> ListSetT m a
unListSetT :: ListSetT m a -> m (ListSet a)
listSetCommute :: Functor m => ListSetT (ListSetT m) ~> ListSetT (ListSetT m)
newtype ListSetWithTopT m a
ListSetWithTopT :: m (ListSetWithTop a) -> ListSetWithTopT m a
unListSetWithTopT :: ListSetWithTopT m a -> m (ListSetWithTop a)
listSetWithTopCommute :: Functor m => ListSetWithTopT (ListSetWithTopT m) ~> ListSetWithTopT (ListSetWithTopT m)
newtype SetT m a
SetT :: m (Set a) -> SetT m a
unSetT :: SetT m a -> m (Set a)
mapSetT :: (m (Set a) -> m (Set b)) -> SetT m a -> SetT m b
setCommute :: Functor m => SetT (SetT m) ~> SetT (SetT m)
evalKonT :: Unit m => ContT r m r -> m r
type Kon r = ContT r ID
runKon :: Kon r a -> (a -> r) -> r
evalKon :: Kon r r -> r
newtype ContFun r m a
ContFun :: (a -> m r) -> ContFun r m a
unContFun :: ContFun r m a -> a -> m r
type OpaqueKon k r = OpaqueContT k r ID
runOpaqueKonTWith :: k r m a -> OpaqueContT k r m a -> m r
makeMetaKonT :: Morphism3 (k r) (ContFun r) => ((a -> m r) -> m r) -> OpaqueContT k r m a
runMetaKonT :: Morphism3 (ContFun r) (k r) => OpaqueContT k r m a -> (a -> m r) -> m r
runMetaKonTWith :: Morphism3 (ContFun r) (k r) => (a -> m r) -> OpaqueContT k r m a -> m r
evalOpaqueKonT :: (Unit m, Morphism3 (ContFun r) (k r)) => OpaqueContT k r m r -> m r
makeOpaqueKon :: (k r ID a -> r) -> OpaqueKon k r a
makeMetaKon :: Morphism3 (k r) (ContFun r) => ((a -> r) -> r) -> OpaqueKon k r a
runOpaqueKon :: OpaqueKon k r a -> k r ID a -> r
runMetaKon :: Morphism3 (ContFun r) (k r) => OpaqueKon k r a -> (a -> r) -> r
evalOpaqueKon :: Morphism3 (ContFun r) (k r) => OpaqueKon k r r -> r
metaKonT :: Morphism3 (ContFun r) (k r) => OpaqueContT k r m ~> ContT r m
opaqueContT :: Morphism3 (k r) (ContFun r) => ContT r m ~> OpaqueContT k r m
class Balloon k r | k -> r
inflate :: (Balloon k r, Monad m) => k r m ~> k r (OpaqueContT k r m)
deflate :: (Balloon k r, Monad m) => k r (OpaqueContT k r m) ~> k r m
maybeReaderCommute :: Functor m => MaybeT (ReaderT r m) ~> ReaderT r (MaybeT m)
readerMaybeCommute :: Functor m => ReaderT r (MaybeT m) ~> MaybeT (ReaderT r m)
writerMaybeCommute :: (Monoid w, Functor m) => WriterT w (MaybeT m) ~> MaybeT (WriterT w m)
maybeWriterCommute :: Functor m => MaybeT (WriterT w m) ~> WriterT w (MaybeT m)
maybeStateCommute :: Functor m => MaybeT (StateT s m) ~> StateT s (MaybeT m)
stateMaybeCommute :: Functor m => StateT s (MaybeT m) ~> MaybeT (StateT s m)
errorReaderCommute :: ErrorT e (ReaderT r m) ~> ReaderT r (ErrorT e m)
readerErrorCommute :: ReaderT r (ErrorT e m) ~> ErrorT e (ReaderT r m)
errorStateCommute :: Functor m => ErrorT e (StateT s m) ~> StateT s (ErrorT e m)
stateErrorCommute :: Functor m => StateT s (ErrorT e m) ~> ErrorT e (StateT s m)
readerWriterCommute :: ReaderT r (WriterT w m) ~> WriterT w (ReaderT r m)
writerReaderCommute :: WriterT w (ReaderT r m) ~> ReaderT r (WriterT w m)
readerStateCommute :: Functor m => ReaderT r (StateT s m) ~> StateT s (ReaderT r m)
stateReaderCommute :: Functor m => StateT s (ReaderT r m) ~> ReaderT r (StateT s m)
readerRWSCommute :: (Monad m, Monoid o) => ReaderT r1 (RWST r2 o s m) ~> RWST r2 o s (ReaderT r1 m)
rwsReaderCommute :: (Monad m, Monoid o) => RWST r1 o s (ReaderT r2 m) ~> ReaderT r2 (RWST r1 o s m)
writerStateCommute :: Functor m => WriterT w (StateT s m) ~> StateT s (WriterT w m)
stateWriterCommute :: Functor m => StateT s (WriterT w m) ~> WriterT w (StateT s m)
writerRWSCommute :: (Monad m, Monoid o1, Monoid o2) => WriterT o1 (RWST r o2 s m) ~> RWST r o2 s (WriterT o1 m)
rwsWriterCommute :: (Monad m, Monoid o1, Monoid o2) => RWST r o1 s (WriterT o2 m) ~> WriterT o2 (RWST r o1 s m)
stateRWSCommute :: (Monad m, Monoid o) => StateT s1 (RWST r o s2 m) ~> RWST r o s2 (StateT s1 m)
rwsStateCommute :: (Monad m, Monoid o) => RWST r o s1 (StateT s2 m) ~> StateT s2 (RWST r o s1 m)
stateListCommute :: (Functor m, Monoid s) => StateT s (ListT m) ~> ListT (StateT s m)
listStateCommute :: Functor m => ListT (StateT s m) ~> StateT s (ListT m)
stateListSetCommute :: (Functor m, JoinLattice s) => StateT s (ListSetT m) ~> ListSetT (StateT s m)
listSetStateCommute :: Functor m => ListSetT (StateT s m) ~> StateT s (ListSetT m)
stateKonCommute :: StateT s (ContT (s, r) m) ~> ContT r (StateT s m)
konStateCommute :: ContT r (StateT s m) ~> StateT s (ContT (s, r) m)
instance (Functor m, MonadMaybe m, Monoid o) => MonadMaybe (RWST r o s m)
instance (MonadBot m, Monoid o) => MonadBot (RWST r o s m)
instance (Monad m, Monoid o) => MonadState s (RWST r o s m)
instance (Monad m, Monoid o) => MonadWriter o (RWST r o s m)
instance (Monad m, Monoid o) => MonadReader r (RWST r o s m)
instance (Monad m, Monoid o) => Monad (RWST r o s m)
instance (Monad m, Monoid o) => Bind (RWST r o s m)
instance (Monad m, Monoid o) => Applicative (RWST r o s m)
instance (Monad m, Monoid o) => Product (RWST r o s m)
instance Functor m => Functor (RWST r o s m)
instance (Unit m, Monoid o) => Unit (RWST r o s m)
instance Eq a => Eq (ID a)
instance Ord a => Ord (ID a)
instance PartialOrder a => PartialOrder (ID a)
instance Monoid a => Monoid (ID a)
instance Bot a => Bot (ID a)
instance Top a => Top (ID a)
instance Join a => Join (ID a)
instance JoinLattice a => JoinLattice (ID a)
instance Unit m => Unit (AddStateT s12 s1 m)
instance Functor m => Functor (AddStateT s12 s1 m)
instance Monad m => Product (AddStateT s12 s1 m)
instance Monad m => Applicative (AddStateT s12 s1 m)
instance Monad m => Bind (AddStateT s12 s1 m)
instance Monad m => Monad (AddStateT s12 s1 m)
instance MonadBot m => MonadBot (AddStateT s12 s1 m)
instance MonadPlus m => MonadPlus (AddStateT s12 s1 m)
instance MonadAppend m => MonadAppend (AddStateT s12 s1 m)
instance (MonadReader r m, Functor m) => MonadReader r (AddStateT s12 s1 m)
instance (MonadWriter o m, Functor m, Monoid o) => MonadWriter o (AddStateT s12 s1 m)
instance (Monad m, MonadState s m, Isomorphism3 (ContFun r) (k r)) => MonadState s (OpaqueContT k r m)
instance (Monad m, MonadState s m) => MonadState s (ContT r m)
instance (Functor m, MonadState s m, Functorial JoinLattice m, JoinLattice s) => MonadState s (ListSetT m)
instance (Functor m, MonadState s m, Functorial Monoid m, Monoid s) => MonadState s (ListT m)
instance (Monoid w, Functor m, MonadWriter w m) => MonadWriter w (StateT s m)
instance (Functor m, Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Functor m, MonadReader r m) => MonadReader r (StateT s m)
instance (Functor m, MonadState s m) => MonadState s (ReaderT r m)
instance (Monoid w, Functor m, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, Functor m, MonadWriter w m) => MonadWriter w (ReaderT r m)
instance (Functor m, MonadError e m) => MonadError e (StateT s m)
instance (Functor m, MonadState s m) => MonadState s (ErrorT e m)
instance (Functor m, MonadError e m) => MonadError e (ReaderT r m)
instance (Functor m, MonadReader r m) => MonadReader r (ErrorT e m)
instance (Functor m, MonadMaybe m) => MonadMaybe (StateT s m)
instance (Functor m, MonadState s m) => MonadState s (MaybeT m)
instance (Monoid w, Functor m, MonadMaybe m) => MonadMaybe (WriterT w m)
instance (Monoid w, Functor m, MonadWriter w m) => MonadWriter w (MaybeT m)
instance (Functor m, MonadMaybe m) => MonadMaybe (ReaderT r m)
instance (Functor m, MonadReader r m) => MonadReader r (MaybeT m)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => MonadCont r (OpaqueContT k r m)
instance (Monad m, Isomorphism3 (ContFun r) (k r), Balloon k r) => MonadOpaqueCont k r (OpaqueContT k r m)
instance Isomorphism3 (k r) (ContFun r) => MonadIsoFunctor2 (OpaqueContT k r)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => Monad (OpaqueContT k r m)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => Bind (OpaqueContT k r m)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => Product (OpaqueContT k r m)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => Applicative (OpaqueContT k r m)
instance (Monad m, Isomorphism3 (ContFun r) (k r)) => Functor (OpaqueContT k r m)
instance Morphism3 (k1 r) (ContFun r) => Unit (OpaqueContT k1 r m)
instance Monad m => MonadCont r (ContT r m)
instance MonadIsoFunctor2 (ContT r)
instance Unit m => Monad (ContT r m)
instance Unit m => Bind (ContT r m)
instance Unit m => Functor (ContT r m)
instance Unit m => Product (ContT r m)
instance Unit m => Applicative (ContT r m)
instance Unit m => Unit (ContT r m)
instance Functorial JoinLattice m => MonadPlus (SetT m)
instance Functorial JoinLattice m => MonadBot (SetT m)
instance (Functorial JoinLattice m, Monad m) => Bind (SetT m)
instance (Functor m, Product m) => Product (SetT m)
instance Functorial JoinLattice m => MonadPlus (ListSetWithTopT m)
instance Functorial Top m => MonadTop (ListSetWithTopT m)
instance Functorial JoinLattice m => MonadBot (ListSetWithTopT m)
instance FunctorFunctor2 ListSetWithTopT
instance FunctorJoin2 ListSetWithTopT
instance FunctorUnit2 ListSetWithTopT
instance (Monad m, Functorial JoinLattice m, Functorial Top m) => Monad (ListSetWithTopT m)
instance (Monad m, Functorial JoinLattice m, Functorial Top m) => Bind (ListSetWithTopT m)
instance (Monad m, Functorial JoinLattice m, Functorial Top m) => Applicative (ListSetWithTopT m)
instance (Monad m, Functorial JoinLattice m, Functorial Top m) => Product (ListSetWithTopT m)
instance Functor m => Functor (ListSetWithTopT m)
instance Unit m => Unit (ListSetWithTopT m)
instance Functorial JoinLattice m => MonadPlus (ListSetT m)
instance Functorial JoinLattice m => MonadBot (ListSetT m)
instance FunctorFunctor2 ListSetT
instance FunctorJoin2 ListSetT
instance FunctorUnit2 ListSetT
instance (Monad m, Functorial JoinLattice m) => Monad (ListSetT m)
instance (Monad m, Functorial JoinLattice m) => Bind (ListSetT m)
instance (Monad m, Functorial JoinLattice m) => Applicative (ListSetT m)
instance (Monad m, Functorial JoinLattice m) => Product (ListSetT m)
instance Functor m => Functor (ListSetT m)
instance Unit m => Unit (ListSetT m)
instance Functorial Monoid m => MonadAppend (ListT m)
instance Functorial Monoid m => MonadBot (ListT m)
instance Functorial Monoid m => Functorial Monoid (ListT m)
instance Functorial Monoid m => Monoid (ListT m a)
instance FunctorFunctor2 ListT
instance FunctorJoin2 ListT
instance FunctorUnit2 ListT
instance (Monad m, Functorial Monoid m) => Monad (ListT m)
instance (Monad m, Functorial Monoid m) => Bind (ListT m)
instance (Monad m, Functorial Monoid m) => Applicative (ListT m)
instance (Monad m, Functorial Monoid m) => Product (ListT m)
instance Functor m => Functor (ListT m)
instance Unit m => Unit (ListT m)
instance (Monad m, Monoid o) => MonadRWS r o s (RWST r o s m)
instance Monoid o => MonadFunctor2 (RWST r o s)
instance Monoid o => MonadJoin2 (RWST r o s)
instance Monoid o => MonadUnit2 (RWST r o s)
instance (Functor m, MonadState s2 m, Isomorphism s12 (s1, s2)) => MonadState s12 (AddStateT s12 s1 m)
instance Functor m => MonadState s (StateT s m)
instance (Functorial Bot m, Functorial Join m, JoinLattice s) => Functorial JoinLattice (StateT s m)
instance (Functorial Bot m, Functorial Join m, JoinLattice s, JoinLattice a) => JoinLattice (StateT s m a)
instance (Functorial Join m, Join s, Join a) => Join (StateT s m a)
instance (Functorial Bot m, Bot s, Bot a) => Bot (StateT s m a)
instance (Functorial Monoid m, Monoid s) => Functorial Monoid (StateT s m)
instance (Functorial Monoid m, Monoid s, Monoid a) => Monoid (StateT s m a)
instance MonadAppend m => MonadAppend (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
instance MonadTop m => MonadTop (StateT s m)
instance MonadBot m => MonadBot (StateT s m)
instance FunctorFunctor2 (StateT s)
instance FunctorJoin2 (StateT s)
instance FunctorUnit2 (StateT s)
instance Monad m => Monad (StateT s m)
instance Monad m => Bind (StateT s m)
instance Monad m => Applicative (StateT s m)
instance Monad m => Product (StateT s m)
instance Functor m => Functor (StateT s m)
instance Unit m => Unit (StateT s m)
instance (MonadBot m, Monoid o) => MonadBot (WriterT o m)
instance (Functor m, Monoid o) => MonadWriter o (WriterT o m)
instance FunctorFunctor2 (WriterT w)
instance FunctorJoin2 (WriterT w)
instance Monoid w => FunctorUnit2 (WriterT w)
instance (Monad m, Monoid o) => Monad (WriterT o m)
instance (Monad m, Monoid o) => Bind (WriterT o m)
instance (Functor m, Applicative m, Monoid o) => Applicative (WriterT o m)
instance (Functor m, Product m, Monoid o) => Product (WriterT o m)
instance Functor m => Functor (WriterT o m)
instance (Unit m, Monoid o) => Unit (WriterT o m)
instance MonadAppend m => MonadAppend (ReaderT r m)
instance MonadBot m => MonadBot (ReaderT r m)
instance Functor m => MonadReader r (ReaderT r m)
instance FunctorFunctor2 (ReaderT r)
instance FunctorJoin2 (ReaderT r)
instance FunctorUnit2 (ReaderT r)
instance Monad m => Monad (ReaderT r m)
instance Bind m => Bind (ReaderT r m)
instance Applicative m => Applicative (ReaderT r m)
instance Product m => Product (ReaderT r m)
instance Functor m => Functor (ReaderT r m)
instance Unit m => Unit (ReaderT r m)
instance Functor m => MonadError e (ErrorT e m)
instance FunctorFunctor2 (ErrorT e)
instance FunctorJoin2 (ErrorT e)
instance FunctorUnit2 (ErrorT e)
instance Monad m => Monad (ErrorT e m)
instance (Unit m, Functor m, Bind m) => Bind (ErrorT e m)
instance (Functor m, Applicative m) => Applicative (ErrorT e m)
instance (Functor m, Product m) => Product (ErrorT e m)
instance Functor m => Functor (ErrorT e m)
instance Unit m => Unit (ErrorT e m)
instance Functor m => MonadMaybe (MaybeT m)
instance FunctorFunctor2 MaybeT
instance FunctorJoin2 MaybeT
instance FunctorUnit2 MaybeT
instance Monad m => Monad (MaybeT m)
instance Monad m => Bind (MaybeT m)
instance (Functor m, Applicative m) => Applicative (MaybeT m)
instance (Functor m, Product m) => Product (MaybeT m)
instance Functor m => Functor (MaybeT m)
instance Unit m => Unit (MaybeT m)
instance Functorial Monoid ID
instance Functorial JoinLattice ID
instance Functorial Join ID
instance Functorial Top ID
instance Functorial Bot ID
instance Monad ID
instance Bind ID
instance Applicative ID
instance Product ID
instance FunctorM ID
instance Functor ID
instance Unit ID

module FP.IO
readFile :: String -> IO String
writeFile :: String -> String -> IO ()

module FP.Compat
instance [overlap ok] Monad m => Monad m

module FP.TH
class THApp e
(#@) :: THApp e => e -> e -> e
class THTup e
tup :: THTup e => [e] -> e
(#@|) :: THApp e => e -> [e] -> e
app :: THApp e => e -> [e] -> e
(==>) :: Type -> Type -> Type
makeList :: [Exp] -> Exp
makeString :: String -> Exp
conName :: Con -> Name
tyVarBndrName :: TyVarBndr -> Name
sclause :: [Pat] -> Exp -> Clause
smatch :: Pat -> Exp -> Match
coerceSimpleCon :: Con -> Maybe (Name, [Type])
tyConIL :: Prism Info Dec
dataDL :: Prism Dec (Cxt, Name, [TyVarBndr], [Con], [Name])
newtypeDL :: Prism Dec (Cxt, Name, [TyVarBndr], Con, [Name])
coerceADT :: Dec -> Maybe (Cxt, Name, [TyVarBndr], [Con], [Name])
coerceSingleConADT :: Dec -> Maybe (Cxt, Name, [TyVarBndr], Con, [Name])
recCL :: Prism Con (Name, [VarStrictType])
instance THTup Pat
instance THTup Type
instance THApp Type
instance THTup Exp
instance THApp Exp

module FP.DerivingLens

-- | ]
makeLensLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> Name -> Type -> m [Dec]
makeLenses :: Name -> Q [Dec]

module FP.DerivingPrism

-- | ]
makePrismLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> Name -> [Type] -> Int -> m [Dec]
makePrisms :: Name -> Q [Dec]

module FP.DerivingMonoid

-- | ]
makeMonoidLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> Name -> [Type] -> m [Dec]
makeMonoid :: Name -> Q [Dec]

module FP.Pretty
newtype Color256
Color256 :: Int -> Color256
color256Raw :: Color256 -> Int
data Format
Format :: Maybe Color256 -> Maybe Color256 -> Bool -> Bool -> Format
foreground :: Format -> Maybe Color256
background :: Format -> Maybe Color256
underline :: Format -> Bool
bold :: Format -> Bool
setFG :: Color256 -> Format
setBG :: Color256 -> Format
setUL :: Format
setBD :: Format
data Chunk
Text :: String -> Chunk
Newline :: Chunk
type POut = FreeMonoidFunctor ((,) Format) Chunk
data Layout
Flat :: Layout
Break :: Layout
data Failure
CanFail :: Failure
CantFail :: Failure
data PEnv
PEnv :: Int -> Int -> Layout -> Failure -> Int -> Int -> Bool -> PEnv
maxColumnWidth :: PEnv -> Int
maxRibbonWidth :: PEnv -> Int
layout :: PEnv -> Layout
failure :: PEnv -> Failure
nesting :: PEnv -> Int
level :: PEnv -> Int
bumped :: PEnv -> Bool
bumpedL :: Lens PEnv Bool
levelL :: Lens PEnv Int
nestingL :: Lens PEnv Int
failureL :: Lens PEnv Failure
layoutL :: Lens PEnv Layout
maxRibbonWidthL :: Lens PEnv Int
maxColumnWidthL :: Lens PEnv Int
env0 :: PEnv
data PState
PState :: Int -> Int -> PState
column :: PState -> Int
ribbon :: PState -> Int
ribbonL :: Lens PState Int
columnL :: Lens PState Int
state0 :: PState
type MonadPretty m = (Monad m, MonadReader PEnv m, MonadWriter POut m, MonadState PState m, MonadMaybe m)
text :: MonadPretty m => String -> m ()
space :: MonadPretty m => Int -> m ()
ifFlat :: MonadPretty m => m a -> m a -> m a
whenFlat :: MonadPretty m => m () -> m ()
whenBreak :: MonadPretty m => m () -> m ()
mustBreak :: MonadPretty m => m () -> m ()
hardLine :: MonadPretty m => m ()
newline :: MonadPretty m => m ()
flat :: MonadPretty m => m a -> m a
canFail :: MonadPretty m => m a -> m a
nest :: MonadPretty m => Int -> m a -> m a
group :: (MonadMaybe m, MonadPretty m) => m a -> m a
align :: MonadPretty m => m a -> m a
format :: MonadPretty m => Format -> m a -> m a
hsep :: MonadPretty m => [m ()] -> m ()
vsep :: MonadPretty m => [m ()] -> m ()
hvsep :: MonadPretty m => [m ()] -> m ()
hsepTight :: MonadPretty m => [m ()] -> m ()
hvsepTight :: MonadPretty m => [m ()] -> m ()
botLevel :: MonadPretty m => m () -> m ()
closed :: MonadPretty m => m () -> m () -> m () -> m ()
parens :: MonadPretty m => m () -> m ()
atLevel :: MonadPretty m => Int -> m () -> m ()
bump :: MonadPretty m => m a -> m a
inf :: MonadPretty m => Int -> m () -> m () -> m () -> m ()
infl :: MonadPretty m => Int -> m () -> m () -> m () -> m ()
infr :: MonadPretty m => Int -> m () -> m () -> m () -> m ()
pre :: MonadPretty m => Int -> m () -> m () -> m ()
post :: MonadPretty m => Int -> m () -> m () -> m ()
app :: MonadPretty m => m () -> [m ()] -> m ()
collection :: MonadPretty m => String -> String -> String -> [m ()] -> m ()
keyPunFmt :: Format
keyPun :: MonadPretty m => String -> m ()
keyFmt :: Format
key :: MonadPretty m => String -> m ()
conFmt :: Format
con :: MonadPretty m => String -> m ()
bdrFmt :: Format
bdr :: MonadPretty m => String -> m ()
litFmt :: Format
lit :: MonadPretty m => String -> m ()
punFmt :: Format
pun :: MonadPretty m => String -> m ()
hlFmt :: Format
hl :: MonadPretty m => String -> m ()
headingFmt :: Format
heading :: MonadPretty m => String -> m ()
op :: MonadPretty m => String -> m ()
newtype DocM a
DocM :: RWST PEnv POut PState Maybe a -> DocM a
unDocM :: DocM a -> RWST PEnv POut PState Maybe a
runDocM :: PEnv -> PState -> DocM a -> Maybe (PState, POut, a)
execDoc :: Doc -> POut
type Doc = DocM ()
class Pretty a
pretty :: Pretty a => a -> Doc
class PrettyM m a
prettyM :: PrettyM m a => a -> m Doc
formatChunk :: Chunk -> String
noFormatOut :: POut -> String
ptoString :: Pretty a => a -> String
instance Unit DocM
instance Functor DocM
instance Product DocM
instance Applicative DocM
instance Bind DocM
instance Monad DocM
instance MonadReader PEnv DocM
instance MonadWriter POut DocM
instance MonadState PState DocM
instance MonadMaybe DocM
instance Pretty a => Pretty (SumOfProd a)
instance (Functorial Pretty m, Pretty a) => Pretty (ListT m a)
instance (Functorial Pretty m, Pretty e, Pretty a) => Pretty (ErrorT e m a)
instance Functorial Pretty ID
instance Pretty a => Pretty (ID a)
instance (Pretty a, Functorial Pretty f) => Pretty (StampedFix a f)
instance (Pretty a, Pretty f) => Pretty (Stamped a f)
instance Functorial Pretty f => Pretty (Fix f)
instance (Ord a, Pretty a) => Pretty (ListSetWithTop a)
instance (Ord a, Pretty a) => Pretty (ListSet a)
instance (Pretty k, Pretty v) => Pretty (Map k v)
instance Pretty a => Pretty (SetWithTop a)
instance Functorial Pretty Set
instance Pretty a => Pretty (Set a)
instance Functorial Pretty []
instance Pretty a => Pretty [a]
instance Pretty a => Pretty (Maybe a)
instance (Pretty a, Pretty b) => Pretty (a :+: b)
instance Bifunctorial Pretty (,)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance (Pretty a, Pretty b) => Pretty (a, b)
instance Pretty ()
instance Pretty Double
instance Pretty String
instance Pretty Char
instance Pretty Integer
instance Pretty Int
instance Pretty Bool
instance Pretty Doc
instance Monoid Doc
instance Eq Layout
instance Ord Layout
instance Eq Failure
instance Ord Failure
instance (Monoid (Maybe Color256), Monoid Bool) => Monoid Format
instance ToInteger Color256
instance ToString Color256
instance FromInteger Color256

module FP.DerivingJoinLattice

-- | ]
makeJoinLatticeLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> Name -> [Type] -> m [Dec]
makeJoinLattice :: Name -> Q [Dec]

module FP.DerivingPretty

-- | ]
makePrettySumLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> [(Name, [Type])] -> m [Dec]

-- | ]
makePrettyUnionLogic :: (Monad m, MonadQ m) => Cxt -> Name -> [TyVarBndr] -> [(Name, [Type])] -> m [Dec]
makePrettySum :: Name -> Q [Dec]
makePrettyUnion :: Name -> Q [Dec]

module FP.Parser
data ParserState t
ParserState :: [t] -> Int -> ParserState t
parserStateStream :: ParserState t -> [t]
parserStateConsumed :: ParserState t -> Int
parserStateConsumedL :: Lens (ParserState t_aSe4) Int
parserStateStreamL :: Lens (ParserState t_aSe4) [t_aSe4]
class (Monad m, MonadBot m, MonadAppend m, MonadState (ParserState t) m) => MonadParser t m | m -> t
end :: MonadParser t m => m ()
final :: MonadParser t m => m a -> m a
satisfies :: MonadParser t m => (t -> Bool) -> m t
pluck :: MonadParser t m => m t
lit :: (MonadParser t m, Eq t) => t -> m t
word :: (MonadParser t m, Eq t) => [t] -> m [t]
string :: MonadParser Char m => String -> m String
newtype Parser t a
Parser :: StateT (ParserState t) (ListT ID) a -> Parser t a
unParser :: Parser t a -> StateT (ParserState t) (ListT ID) a
runParser :: [t] -> Parser t a -> [(ParserState t, a)]
data ParseError t a
ParsingError :: ParseError t a
AmbiguousParse :: [a] -> ParseError t a
parseFinal :: Parser t a -> [t] -> ParseError t a :+: a
parseFinalOn :: [t] -> Parser t a -> ParseError t a :+: a
tokenize :: Parser c a -> [c] -> [c] :+: [a]
data LexParseError c t a
LexingError :: [c] -> LexParseError c t a
LexParsingError :: [t] -> LexParseError c t a
LexAmbiguousParse :: ([t], [a]) -> LexParseError c t a
lexParseFinal :: (Pretty c, Pretty t) => Parser c t -> (t -> Bool) -> Parser t a -> [c] -> LexParseError c t a :+: a
data Mix m a
Pre :: (m (a -> a)) -> Mix m a
Post :: (m (a -> a)) -> Mix m a
Inf :: (m (a -> a -> a)) -> Mix m a
InfL :: (m (a -> a -> a)) -> Mix m a
InfR :: (m (a -> a -> a)) -> Mix m a
infRL :: Prism (Mix m_aSEq a_aSEr) (m_aSEq (a_aSEr -> a_aSEr -> a_aSEr))
infLL :: Prism (Mix m_aSEq a_aSEr) (m_aSEq (a_aSEr -> a_aSEr -> a_aSEr))
infL :: Prism (Mix m_aSEq a_aSEr) (m_aSEq (a_aSEr -> a_aSEr -> a_aSEr))
postL :: Prism (Mix m_aSEq a_aSEr) (m_aSEq (a_aSEr -> a_aSEr))
preL :: Prism (Mix m_aSEq a_aSEr) (m_aSEq (a_aSEr -> a_aSEr))
data Level m a
Level :: m (a -> a) -> m (a -> a) -> m (a -> a -> a) -> m (a -> a -> a) -> m (a -> a -> a) -> Level m a
levelPre :: Level m a -> m (a -> a)
levelPost :: Level m a -> m (a -> a)
levelInf :: Level m a -> m (a -> a -> a)
levelInfL :: Level m a -> m (a -> a -> a)
levelInfR :: Level m a -> m (a -> a -> a)
splitMixes :: MonadParser t m => [Mix m a] -> Level m a
pre :: Monad m => (b -> a -> a) -> m b -> Mix m a
post :: Monad m => (a -> b -> a) -> m b -> Mix m a
inf' :: Monad m => (a -> b -> a -> a) -> m b -> m (a -> a -> a)
inf :: Monad m => (a -> b -> a -> a) -> m b -> Mix m a
infl :: Monad m => (a -> b -> a -> a) -> m b -> Mix m a
infr :: Monad m => (a -> b -> a -> a) -> m b -> Mix m a
between :: MonadParser t m => m () -> m () -> m a -> m a
buildMix :: MonadParser t m => [m a] -> Map Int [Mix m a] -> m a
buildLevel :: MonadParser t m => m a -> Level m a -> m a
buildMixPre :: MonadParser t m => m a -> m (a -> a) -> m a
buildMixPost :: MonadParser t m => m (a -> a) -> m (a -> a)
buildMixInf :: MonadParser t m => m a -> m (a -> a -> a) -> m (a -> a)
buildMixInfL :: MonadParser t m => m a -> m (a -> a -> a) -> m (a -> a)
buildMixInfR :: MonadParser t m => m a -> m (a -> a -> a) -> m (a -> a)
instance (Pretty [c0], Pretty [t0], Pretty ([t0], [a0])) => Pretty (LexParseError c0 t0 a0)
instance Pretty [a0] => Pretty (ParseError t0 a0)
instance Unit (Parser t)
instance Functor (Parser t)
instance Product (Parser t)
instance Applicative (Parser t)
instance Bind (Parser t)
instance Monad (Parser t)
instance MonadBot (Parser t)
instance MonadAppend (Parser t)
instance MonadState (ParserState t) (Parser t)
instance MonadParser t (Parser t)
instance Monoid (ParserState t)
instance (Pretty [t0], Pretty Int) => Pretty (ParserState t0)

module FP.Console
leader :: String
sgrCloser :: String
reset :: String
fgCode :: Color256 -> String
bgCode :: Color256 -> String
ulCode :: String
bdCode :: String
applyFormat :: Format -> String -> String
formatOut :: POut -> String
pprintWith :: Pretty a => (Doc -> Doc) -> a -> IO ()
pprintWidth :: Pretty a => Int -> a -> IO ()
pprintRibbon :: Pretty a => Int -> a -> IO ()
pprint :: Pretty a => a -> IO ()
pprintDoc :: Doc -> IO ()
ptrace :: Pretty a => a -> b -> b
htmlColorFrom256 :: [(Int, String)]
htmlFGCode :: Color256 -> String -> String
htmlBGCode :: Color256 -> String -> String
htmlULCode :: String -> String
htmlBDCode :: String -> String

module FP

module Lang.Hask.Compat
installCoreToDosL :: Lens Plugin ([CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo])
mg_dependent_filesL :: Lens ModGuts [FilePath]
mg_trust_pkgL :: Lens ModGuts Bool
mg_safe_haskellL :: Lens ModGuts SafeHaskellMode
mg_fam_inst_envL :: Lens ModGuts FamInstEnv
mg_inst_envL :: Lens ModGuts InstEnv
mg_vect_infoL :: Lens ModGuts VectInfo
mg_vect_declsL :: Lens ModGuts [CoreVect]
mg_modBreaksL :: Lens ModGuts ModBreaks
mg_hpc_infoL :: Lens ModGuts HpcInfo
mg_annsL :: Lens ModGuts [Annotation]
mg_warnsL :: Lens ModGuts Warnings
mg_foreignL :: Lens ModGuts ForeignStubs
mg_bindsL :: Lens ModGuts CoreProgram
mg_rulesL :: Lens ModGuts [CoreRule]
mg_patsynsL :: Lens ModGuts [PatSyn]
mg_fam_instsL :: Lens ModGuts [FamInst]
mg_instsL :: Lens ModGuts [ClsInst]
mg_tcsL :: Lens ModGuts [TyCon]
mg_fix_envL :: Lens ModGuts FixityEnv
mg_rdr_envL :: Lens ModGuts GlobalRdrEnv
mg_used_thL :: Lens ModGuts Bool
mg_used_namesL :: Lens ModGuts NameSet
mg_dir_impsL :: Lens ModGuts ImportedMods
mg_depsL :: Lens ModGuts Dependencies
mg_exportsL :: Lens ModGuts [AvailInfo]
mg_bootL :: Lens ModGuts IsBootInterface
mg_moduleL :: Lens ModGuts Module
dEFAULTL :: Prism AltCon ()
litAltL :: Prism AltCon Literal
dataAltL :: Prism AltCon DataCon
globalDynFlags :: IORef DynFlags
initGlobalDynFlags :: DynFlags -> IO ()
dynFlags :: () -> DynFlags
instance MonadIO CoreM
instance Monad CoreM
instance Applicative CoreM
instance Bind CoreM
instance Product CoreM
instance Unit CoreM
instance Functor CoreM

module Lang.Hask.CPS
data Pico
Var :: Name -> Pico
Lit :: Literal -> Pico
Type :: Pico
data PreAtom e
Pico :: Pico -> PreAtom e
LamF :: Name -> Name -> e -> PreAtom e
LamK :: Name -> e -> PreAtom e
Thunk :: Name -> Int -> Name -> Name -> Pico -> Pico -> PreAtom e
type Atom = PreAtom Call
data PreCaseBranch e
CaseBranch :: AltCon -> [Name] -> e -> PreCaseBranch e
caseBranchCon :: PreCaseBranch e -> AltCon
caseBranchArgs :: PreCaseBranch e -> [Name]
caseBranchCall :: PreCaseBranch e -> e
type CaseBranch = PreCaseBranch Call
data PreCall e
Let :: Name -> (PreAtom e) -> e -> PreCall e
Rec :: [(Name, Name)] -> e -> PreCall e
Letrec :: [(Name, PreAtom e)] -> e -> PreCall e
AppK :: Pico -> Pico -> PreCall e
AppF :: Int -> Name -> Pico -> Pico -> Pico -> PreCall e
Case :: Int -> Name -> Pico -> [PreCaseBranch e] -> PreCall e
Halt :: Pico -> PreCall e
type Call = StampedFix Int PreCall
data CPSKon r m a
MetaKon :: (a -> m r) -> CPSKon r m a
ObjectKon :: Pico -> (Pico -> m Call) -> CPSKon Call m Pico
data CPS𝒮
CPS𝒮 :: UniqSupply -> Int -> CPS𝒮
cps𝒮UniqSupply :: CPS𝒮 -> UniqSupply
cps𝒮ProgLoc :: CPS𝒮 -> Int
cps𝒮ProgLocL :: Lens CPS𝒮 Int
cps𝒮UniqSupplyL :: Lens CPS𝒮 UniqSupply
type CPSM m = (Monad m, MonadCont Call m, MonadOpaqueCont CPSKon Call m, MonadState CPS𝒮 m)
fresh :: CPSM m => String -> m Name
stamp :: (Monad m, MonadState CPS𝒮 m) => PreCall Call -> m Call
atom :: CPSM m => Atom -> m Pico
letAtom :: CPSM m => Name -> Atom -> m ()
rec :: CPSM m => [Name] -> m ()
letrec :: CPSM m => [(Name, Atom)] -> m ()
reify :: CPSM m => CPSKon Call m Pico -> m Pico
reflect :: CPSM m => Pico -> CPSKon Call m Pico
cpsAtom :: CPSM m => Expr Var -> m Atom
cpsM :: CPSM m => Expr Var -> m Pico
cps :: (Monad m, MonadReader UniqSupply m) => Expr Var -> m Call
instance Eq Pico
instance Ord Pico
instance Eq e => Eq (PreAtom e)
instance Ord e => Ord (PreAtom e)
instance Eq e => Eq (PreCaseBranch e)
instance Ord e => Ord (PreCaseBranch e)
instance Eq e => Eq (PreCall e)
instance Ord e => Ord (PreCall e)
instance Balloon CPSKon Call
instance Isomorphism3 (ContFun r) (CPSKon r)
instance Morphism3 (CPSKon r) (ContFun r)
instance Morphism3 (ContFun r) (CPSKon r)
instance Functorial Ord PreCall
instance Functorial Eq PreCall

module Lang.Hask.Time
class Time ψ τ | τ -> ψ
tzero :: Time ψ τ => τ
tick :: Time ψ τ => ψ -> τ -> τ
newtype Cτ ψ
Cτ :: [ψ] -> Cτ ψ
cτ :: P Cτ
newtype Kτ (k :: Nat) ψ
Kτ :: [ψ] -> Kτ ψ
kτ :: P (Kτ 1)
data Zτ ψ
Zτ :: Zτ ψ
zτ :: P Zτ
instance Eq ψ => Eq (Cτ ψ)
instance Ord ψ => Ord (Cτ ψ)
instance Pretty ψ => Pretty (Cτ ψ)
instance Eq ψ => Container ψ (Cτ ψ)
instance Iterable ψ (Cτ ψ)
instance Buildable ψ (Cτ ψ)
instance Eq ψ => Eq (Kτ k ψ)
instance Ord ψ => Ord (Kτ k ψ)
instance Pretty ψ => Pretty (Kτ k ψ)
instance Eq ψ => Container ψ (Kτ k ψ)
instance Iterable ψ (Kτ k ψ)
instance Buildable ψ (Kτ k ψ)
instance Eq (Zτ ψ)
instance Ord (Zτ ψ)
instance Time ψ (Zτ ψ)
instance Bot (Zτ ψ)
instance Pretty (Zτ a)
instance KnownNat k => Time ψ (Kτ k ψ)
instance Bot (Kτ k ψ)
instance Time ψ (Cτ ψ)
instance Bot (Cτ ψ)

module Lang.Hask.Semantics
data Moment lτ dτ
Moment :: lτ -> dτ -> Moment lτ dτ
timeLex :: Moment lτ dτ -> lτ
timeDyn :: Moment lτ dτ -> dτ
timeDynL :: Lens (Moment lτ_a1cHp dτ_a1cHq) dτ_a1cHq
timeLexL :: Lens (Moment lτ_a1cHp dτ_a1cHq) lτ_a1cHp
data Addr lτ dτ
Addr :: Name -> Moment lτ dτ -> Addr lτ dτ
addrName :: Addr lτ dτ -> Name
addrTime :: Addr lτ dτ -> Moment lτ dτ
type Env lτ dτ = Map Name (Addr lτ dτ)
type Store ν lτ dτ = Map (Addr lτ dτ) (ν lτ dτ)
data ArgVal lτ dτ
AddrVal :: (Addr lτ dτ) -> ArgVal lτ dτ
LitVal :: Literal -> ArgVal lτ dτ
TypeVal :: ArgVal lτ dτ
data Data lτ dτ
Data :: DataCon -> [ArgVal lτ dτ] -> Data lτ dτ
dataCon :: Data lτ dτ -> DataCon
dataArgs :: Data lτ dτ -> [ArgVal lτ dτ]
data FunClo lτ dτ
FunClo :: Name -> Name -> Call -> Env lτ dτ -> lτ -> FunClo lτ dτ
funCloLamArg :: FunClo lτ dτ -> Name
funCloKonArg :: FunClo lτ dτ -> Name
funCloBody :: FunClo lτ dτ -> Call
funCloEnv :: FunClo lτ dτ -> Env lτ dτ
funCloTime :: FunClo lτ dτ -> lτ
data Ref lτ dτ
Ref :: Addr lτ dτ -> Ref lτ dτ
refAddr :: Ref lτ dτ -> Addr lτ dτ
data KonClo lτ dτ
KonClo :: Name -> Call -> Env lτ dτ -> KonClo lτ dτ
konCloArg :: KonClo lτ dτ -> Name
konCloBody :: KonClo lτ dτ -> Call
konCloEnv :: KonClo lτ dτ -> Env lτ dτ
data ThunkClo lτ dτ
ThunkClo :: Int -> Name -> Name -> Pico -> Pico -> Env lτ dτ -> lτ -> ThunkClo lτ dτ
thunkCloKonXLoc :: ThunkClo lτ dτ -> Int
thunkCloKonXArg :: ThunkClo lτ dτ -> Name
thunkCloKonKArg :: ThunkClo lτ dτ -> Name
thunkCloFun :: ThunkClo lτ dτ -> Pico
thunkCloArg :: ThunkClo lτ dτ -> Pico
thunkCloEnv :: ThunkClo lτ dτ -> Env lτ dτ
thunkCloTime :: ThunkClo lτ dτ -> lτ
data KonMemoClo lτ dτ
KonMemoClo :: Addr lτ dτ -> ThunkClo lτ dτ -> Name -> Call -> Env lτ dτ -> KonMemoClo lτ dτ
konMemoCloLoc :: KonMemoClo lτ dτ -> Addr lτ dτ
konMemoCloThunk :: KonMemoClo lτ dτ -> ThunkClo lτ dτ
konMemoCloArg :: KonMemoClo lτ dτ -> Name
konMemoCloBody :: KonMemoClo lτ dτ -> Call
konMemoCloEnv :: KonMemoClo lτ dτ -> Env lτ dτ
data Forced lτ dτ
Forced :: ArgVal lτ dτ -> Forced lτ dτ
forcedVal :: Forced lτ dτ -> ArgVal lτ dτ
class Val lτ dτ γν αν | αν -> γν
botI :: Val lτ dτ γν αν => αν lτ dτ
litI :: Val lτ dτ γν αν => Literal -> αν lτ dτ
litTestE :: Val lτ dτ γν αν => Literal -> αν lτ dτ -> γν Bool
dataI :: Val lτ dτ γν αν => Data lτ dτ -> αν lτ dτ
dataAnyI :: Val lτ dτ γν αν => DataCon -> αν lτ dτ
dataE :: Val lτ dτ γν αν => αν lτ dτ -> γν (Data lτ dτ)
funCloI :: Val lτ dτ γν αν => FunClo lτ dτ -> αν lτ dτ
funCloE :: Val lτ dτ γν αν => αν lτ dτ -> γν (FunClo lτ dτ)
refI :: Val lτ dτ γν αν => Ref lτ dτ -> αν lτ dτ
refAnyI :: Val lτ dτ γν αν => αν lτ dτ
refE :: Val lτ dτ γν αν => αν lτ dτ -> γν (Ref lτ dτ)
konCloI :: Val lτ dτ γν αν => KonClo lτ dτ -> αν lτ dτ
konCloE :: Val lτ dτ γν αν => αν lτ dτ -> γν (KonClo lτ dτ)
konMemoCloI :: Val lτ dτ γν αν => KonMemoClo lτ dτ -> αν lτ dτ
konMemoCloE :: Val lτ dτ γν αν => αν lτ dτ -> γν (KonMemoClo lτ dτ)
thunkCloI :: Val lτ dτ γν αν => ThunkClo lτ dτ -> αν lτ dτ
thunkCloE :: Val lτ dτ γν αν => αν lτ dτ -> γν (ThunkClo lτ dτ)
forcedI :: Val lτ dτ γν αν => Forced lτ dτ -> αν lτ dτ
forcedE :: Val lτ dτ γν αν => αν lτ dτ -> γν (Forced lτ dτ)
data 𝒮 ν lτ dτ
𝒮 :: Env lτ dτ -> Store ν lτ dτ -> Moment lτ dτ -> 𝒮 ν lτ dτ
𝓈Env :: 𝒮 ν lτ dτ -> Env lτ dτ
𝓈Store :: 𝒮 ν lτ dτ -> Store ν lτ dτ
𝓈Time :: 𝒮 ν lτ dτ -> Moment lτ dτ
𝓈TimeL :: Lens (𝒮 ν_a1cLu lτ_a1cLv dτ_a1cLw) (Moment lτ_a1cLv dτ_a1cLw)
𝓈StoreL :: Lens (𝒮 ν_a1cLu lτ_a1cLv dτ_a1cLw) (Store ν_a1cLu lτ_a1cLv dτ_a1cLw)
𝓈EnvL :: Lens (𝒮 ν_a1cLu lτ_a1cLv dτ_a1cLw) (Env lτ_a1cLv dτ_a1cLw)
type TimeC lτ dτ = (Ord lτ, Ord dτ, Time Int lτ, Time Int dτ)
type ValC ν lτ dτ = (JoinLattice (ν lτ dτ), Meet (ν lτ dτ), Neg (ν lτ dτ), Val lτ dτ SetWithTop ν)
type MonadC ν lτ dτ m = (Monad m, MonadBot m, MonadTop m, MonadPlus m, MonadState (𝒮 ν lτ dτ) m)
class (MonadC ν lτ dτ m, ValC ν lτ dτ, TimeC lτ dτ) => Analysis ν lτ dτ m | m -> ν, m -> lτ, m -> dτ
tickLex :: Analysis ν lτ dτ m => Call -> m ()
tickDyn :: Analysis ν lτ dτ m => Call -> m ()
alloc :: Analysis ν lτ dτ m => Name -> m (Addr lτ dτ)
bindJoin :: Analysis ν lτ dτ m => Name -> ν lτ dτ -> m ()
updateRef :: Analysis ν lτ dτ m => Addr lτ dτ -> ν lτ dτ -> ν lτ dτ -> m ()
refine :: Analysis ν lτ dτ m => ArgVal lτ dτ -> ν lτ dτ -> m ()
extract :: Analysis ν lτ dτ m => (a -> ν lτ dτ) -> (ν lτ dτ -> SetWithTop a) -> ArgVal lτ dτ -> m a
extractIsLit :: Analysis ν lτ dτ m => Literal -> ArgVal lτ dτ -> m ()
addr :: Analysis ν lτ dτ m => Addr lτ dτ -> m (ν lτ dτ)
argVal :: Analysis ν lτ dτ m => ArgVal lτ dτ -> m (ν lτ dτ)
varAddr :: Analysis ν lτ dτ m => Name -> m (Addr lτ dτ)
var :: Analysis ν lτ dτ m => Name -> m (ν lτ dτ)
pico :: Analysis ν lτ dτ m => Pico -> m (ν lτ dτ)
picoArg :: Analysis ν lτ dτ m => Pico -> m (ArgVal lτ dτ)
atom :: Analysis ν lτ dτ m => Atom -> m (ν lτ dτ)
forceThunk :: Analysis ν lτ dτ m => Name -> ArgVal lτ dτ -> Call -> m Call
call :: Analysis ν lτ dτ m => Call -> m Call
instance (Eq lτ, Eq dτ) => Eq (Addr lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Addr lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (ArgVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (ArgVal lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Data lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Data lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (FunClo lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (FunClo lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Ref lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Ref lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (KonClo lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (KonClo lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (ThunkClo lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (ThunkClo lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (KonMemoClo lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (KonMemoClo lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Forced lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Forced lτ dτ)
instance (Eq lτ, Eq dτ, Eq (ν lτ dτ)) => Eq (𝒮 ν lτ dτ)
instance (Ord lτ, Ord dτ, Ord (ν lτ dτ)) => Ord (𝒮 ν lτ dτ)
instance (Time ψ lτ, Time ψ dτ) => Bot (𝒮 ν lτ dτ)
instance (Time ψ lτ, Time ψ dτ) => Bot (Moment lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Moment lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Moment lτ dτ)

module Lang.Hask

module Lang.Hask.Pretty
data VarLam n e
VarLam :: [n] -> e -> VarLam n e
instance Functorial Pretty PreCall
instance Pretty e => Pretty (PreCall e)
instance Pretty e => Pretty (PreCaseBranch e)
instance Pretty e => Pretty (PreAtom e)
instance (Pretty n, Pretty e) => Pretty (VarLam n e)
instance Pretty AltCon
instance Pretty DataCon
instance Pretty Literal
instance Pretty Name
instance (Pretty (Env lτ0 dτ0), Pretty (Store ν0 lτ0 dτ0), Pretty (Moment lτ0 dτ0)) => Pretty (𝒮 ν0 lτ0 dτ0)
instance Pretty (ArgVal lτ0 dτ0) => Pretty (Forced lτ0 dτ0)
instance (Pretty (Addr lτ0 dτ0), Pretty (ThunkClo lτ0 dτ0), Pretty Name, Pretty Call, Pretty (Env lτ0 dτ0)) => Pretty (KonMemoClo lτ0 dτ0)
instance (Pretty Int, Pretty Name, Pretty Pico, Pretty (Env lτ0 dτ0), Pretty lτ0) => Pretty (ThunkClo lτ0 dτ0)
instance (Pretty Name, Pretty Call, Pretty (Env lτ0 dτ0)) => Pretty (KonClo lτ0 dτ0)
instance Pretty (Addr lτ0 dτ0) => Pretty (Ref lτ0 dτ0)
instance (Pretty Name, Pretty Call, Pretty (Env lτ0 dτ0), Pretty lτ0) => Pretty (FunClo lτ0 dτ0)
instance (Pretty DataCon, Pretty [ArgVal lτ0 dτ0]) => Pretty (Data lτ0 dτ0)
instance (Pretty (Addr lτ0 dτ0), Pretty Literal) => Pretty (ArgVal lτ0 dτ0)
instance (Pretty Name, Pretty (Moment lτ0 dτ0)) => Pretty (Addr lτ0 dτ0)
instance (Pretty lτ0, Pretty dτ0) => Pretty (Moment lτ0 dτ0)
instance (Pretty Name, Pretty Literal) => Pretty Pico

module Lang.Hask.GHCPlugin
plugin :: Plugin
maamAnalyze :: ModGuts -> CoreM ModGuts

module Lang.Hask.SumOfProdVal
newtype SumOfProdVal ν lτ dτ
SumOfProdVal :: SumOfProd (ν lτ dτ) -> SumOfProdVal ν lτ dτ
unSumOfProdVal :: SumOfProdVal ν lτ dτ -> SumOfProd (ν lτ dτ)
sumOfProdValConcretize :: Ord b => (ν lτ dτ -> ConstructiveClassical b) -> SumOfProdVal ν lτ dτ -> SetWithTop b
instance Eq (SumOfProdVal ν lτ dτ)
instance Ord (SumOfProdVal ν lτ dτ)
instance Ord (ν lτ dτ) => Buildable (ν lτ dτ) (SumOfProdVal ν lτ dτ)
instance Bot (SumOfProdVal ν lτ dτ)
instance Join (SumOfProdVal ν lτ dτ)
instance JoinLattice (SumOfProdVal ν lτ dτ)
instance Meet (SumOfProdVal ν lτ dτ)
instance (Ord (ν lτ dτ), Neg (ν lτ dτ)) => Neg (SumOfProdVal ν lτ dτ)
instance Pretty (ν lτ dτ) => Pretty (SumOfProdVal ν lτ dτ)
instance (Ord lτ, Ord dτ, Ord (ν lτ dτ), Val lτ dτ ConstructiveClassical ν) => Val lτ dτ SetWithTop (SumOfProdVal ν)

module Lang.Hask.ValConcrete
data CVal lτ dτ
CBot :: CVal lτ dτ
CLit :: Literal -> CVal lτ dτ
CData :: (Data lτ dτ) -> CVal lτ dτ
CDataAny :: DataCon -> CVal lτ dτ
CFunClo :: (FunClo lτ dτ) -> CVal lτ dτ
CThunkClo :: (ThunkClo lτ dτ) -> CVal lτ dτ
CForced :: (Forced lτ dτ) -> CVal lτ dτ
CRef :: (Ref lτ dτ) -> CVal lτ dτ
CRefAny :: CVal lτ dτ
CKonClo :: (KonClo lτ dτ) -> CVal lτ dτ
CKonMemoClo :: (KonMemoClo lτ dτ) -> CVal lτ dτ
cKonMemoCloL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (KonMemoClo lτ_a1nZ3 dτ_a1nZ4)
cKonCloL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (KonClo lτ_a1nZ3 dτ_a1nZ4)
cRefAnyL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) ()
cRefL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (Ref lτ_a1nZ3 dτ_a1nZ4)
cForcedL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (Forced lτ_a1nZ3 dτ_a1nZ4)
cThunkCloL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (ThunkClo lτ_a1nZ3 dτ_a1nZ4)
cFunCloL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (FunClo lτ_a1nZ3 dτ_a1nZ4)
cDataAnyL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) DataCon
cDataL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) (Data lτ_a1nZ3 dτ_a1nZ4)
cLitL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) Literal
cBotL :: Prism (CVal lτ_a1nZ3 dτ_a1nZ4) ()
cν :: P CVal
data OCVal lτ dτ
Pos :: (CVal lτ dτ) -> OCVal lτ dτ
Neg :: (CVal lτ dτ) -> OCVal lτ dτ
discreteE :: Ord b => Prism (CVal lτ dτ) b -> OCVal lτ dτ -> ConstructiveClassical b
instance (Ord lτ, Ord dτ) => Val lτ dτ ConstructiveClassical OCVal
instance Neg (OCVal lτ dτ)
instance Pretty (CVal lτ0 dτ0) => Pretty (OCVal lτ0 dτ0)
instance (Eq lτ, Eq dτ) => Eq (OCVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (OCVal lτ dτ)
instance (Pretty Literal, Pretty (Data lτ0 dτ0), Pretty DataCon, Pretty (FunClo lτ0 dτ0), Pretty (ThunkClo lτ0 dτ0), Pretty (Forced lτ0 dτ0), Pretty (Ref lτ0 dτ0), Pretty (KonClo lτ0 dτ0), Pretty (KonMemoClo lτ0 dτ0)) => Pretty (CVal lτ0 dτ0)
instance (Eq lτ, Eq dτ) => Eq (CVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (CVal lτ dτ)

module Lang.LamIf.Syntax
newtype RawName
RawName :: String -> RawName
getRawName :: RawName -> String
type SRawName = Stamped BdrNum RawName
data GenName
GenName :: Maybe Int -> RawName -> GenName
genNameMark :: GenName -> Maybe Int
genNameRawName :: GenName -> RawName
newtype LocNum
LocNum :: Int -> LocNum
newtype BdrNum
BdrNum :: Int -> BdrNum
type Name = Stamped BdrNum GenName
srawNameToName :: SRawName -> Name
data Lit
I :: Int -> Lit
B :: Bool -> Lit
bL :: Prism Lit Bool
iL :: Prism Lit Int
data BinOp
Add :: BinOp
Sub :: BinOp
GTE :: BinOp
data LBinOp
LBinOp :: BinOp -> Int -> LBinOp
lbinOpOp :: LBinOp -> BinOp
lbinOpLevel :: LBinOp -> Int
data PreExp n e
Lit :: Lit -> PreExp n e
Var :: n -> PreExp n e
Lam :: n -> e -> PreExp n e
Prim :: LBinOp -> e -> e -> PreExp n e
Let :: n -> e -> e -> PreExp n e
App :: e -> e -> PreExp n e
If :: e -> e -> e -> PreExp n e
Tup :: e -> e -> PreExp n e
Pi1 :: e -> PreExp n e
Pi2 :: e -> PreExp n e
type RawExp = Fix (PreExp RawName)
type Exp = StampedFix LocNum (PreExp SRawName)
instance Eq BinOp
instance Ord BinOp
instance Eq LBinOp
instance Ord LBinOp
instance (Eq n, Eq e) => Eq (PreExp n e)
instance (Ord n, Ord e) => Ord (PreExp n e)
instance PartialOrder BinOp
instance Eq RawName
instance Ord RawName
instance Eq GenName
instance Ord GenName
instance Eq LocNum
instance Ord LocNum
instance PartialOrder LocNum
instance Peano LocNum
instance Eq BdrNum
instance Ord BdrNum
instance PartialOrder BdrNum
instance Peano BdrNum
instance Eq Lit
instance Ord Lit
instance PartialOrder Lit

module Lang.LamIf.CPS
data PrePico n
Lit :: Lit -> PrePico n
Var :: n -> PrePico n
type Pico = PrePico Name
data PreAtom n c
Pico :: (PrePico n) -> PreAtom n c
Prim :: LBinOp -> (PrePico n) -> (PrePico n) -> PreAtom n c
LamF :: n -> n -> c -> PreAtom n c
LamK :: n -> c -> PreAtom n c
Tup :: (PrePico n) -> (PrePico n) -> PreAtom n c
Pi1 :: (PrePico n) -> PreAtom n c
Pi2 :: (PrePico n) -> PreAtom n c
type Atom = Stamped LocNum (PreAtom Name Call)
data PreCall n c
Let :: n -> (Stamped LocNum (PreAtom n c)) -> c -> PreCall n c
If :: (PrePico n) -> c -> c -> PreCall n c
AppF :: (PrePico n) -> (PrePico n) -> (PrePico n) -> PreCall n c
AppK :: (PrePico n) -> (PrePico n) -> PreCall n c
Halt :: (PrePico n) -> PreCall n c
type Call = StampedFix LocNum (PreCall Name)
haltL :: Prism (PreCall n_a1slR c_a1slS) (PrePico n_a1slR)
appKL :: Prism (PreCall n_a1slR c_a1slS) (PrePico n_a1slR, PrePico n_a1slR)
appFL :: Prism (PreCall n_a1slR c_a1slS) (PrePico n_a1slR, PrePico n_a1slR, PrePico n_a1slR)
ifL :: Prism (PreCall n_a1slR c_a1slS) (PrePico n_a1slR, c_a1slS, c_a1slS)
letL :: Prism (PreCall n_a1slR c_a1slS) (n_a1slR, Stamped LocNum (PreAtom n_a1slR c_a1slS), c_a1slS)
freeVarsLam :: Set Name -> [Name] -> Call -> Set Name
freeVarsPico :: Set Name -> Pico -> Set Name
freeVarsAtom :: Set Name -> Atom -> Set Name
freeVarsCall :: Set Name -> Call -> Set Name
instance Eq n => Eq (PrePico n)
instance Ord n => Ord (PrePico n)
instance (Eq n, Eq c) => Eq (PreAtom n c)
instance (Ord n, Ord c) => Ord (PreAtom n c)
instance (Eq n, Eq c) => Eq (PreCall n c)
instance (Ord n, Ord c) => Ord (PreCall n c)
instance (Eq n, Eq c) => PartialOrder (PreCall n c)
instance (Eq n, Eq c) => PartialOrder (PreAtom n c)

module Lang.LamIf.Passes
data StampSt
StampSt :: LocNum -> BdrNum -> StampSt
stampExpID :: StampSt -> LocNum
stampBdrID :: StampSt -> BdrNum
stampBdrIDL :: Lens StampSt BdrNum
stampExpIDL :: Lens StampSt LocNum
stampSt0 :: StampSt
data Env
Env :: Map RawName BdrNum -> Env
bdrEnv :: Env -> Map RawName BdrNum
bdrEnvL :: Lens Env (Map RawName BdrNum)
stampEnv0 :: Env
type StampM m = (Monad m, MonadState StampSt m, MonadReader Env m)
lookupName :: StampM m => RawName -> m SRawName
stampM :: StampM m => Fix (PreExp RawName) -> m Exp
stamp :: Fix (PreExp RawName) -> StampedFix LocNum (PreExp SRawName)
data CPSSt
CPSSt :: LocNum -> BdrNum -> Int -> CPSSt
cpsExpID :: CPSSt -> LocNum
cpsBdrID :: CPSSt -> BdrNum
cpsGenID :: CPSSt -> Int
cpsGenIDL :: Lens CPSSt Int
cpsBdrIDL :: Lens CPSSt BdrNum
cpsExpIDL :: Lens CPSSt LocNum
stampL :: Lens CPSSt StampSt
cpsSt0 :: CPSSt
type CPSM m = (Monad m, MonadCont Call m, MonadOpaqueCont CPSKon Call m, MonadState CPSSt m)
fresh :: CPSM m => String -> m Name
data CPSKon r m a
MetaKon :: (a -> m r) -> CPSKon r m a
ObjectKon :: Pico -> (Pico -> m Call) -> CPSKon Call m Pico
letAtom :: CPSM m => String -> Atom -> m Pico
reify :: CPSM m => CPSKon Call m Pico -> m Pico
reflect :: CPSM m => Pico -> CPSKon Call m Pico
cpsM :: CPSM m => Exp -> m Pico
cpsAtomM :: CPSM m => Exp -> m Atom
stampCPS :: Fix (PreExp RawName) -> (Exp, Call)
cps :: Fix (PreExp RawName) -> Call
instance Balloon CPSKon Call
instance Isomorphism3 (ContFun r) (CPSKon r)
instance Morphism3 (CPSKon r) (ContFun r)
instance Morphism3 (ContFun r) (CPSKon r)

module Lang.LamIf.StateSpace
data Addr lτ dτ
Addr :: Name -> lτ -> dτ -> Addr lτ dτ
addrLocation :: Addr lτ dτ -> Name
addrLexicalTime :: Addr lτ dτ -> lτ
addrDynamicTime :: Addr lτ dτ -> dτ
type Env lτ dτ = Map Name (Addr lτ dτ)
type Store val lτ dτ = Map (Addr lτ dτ) val
data 𝒮Cxt lτ dτ
𝒮Cxt :: lτ -> dτ -> Env lτ dτ -> 𝒮Cxt lτ dτ
𝓈Cxtlτ :: 𝒮Cxt lτ dτ -> lτ
𝓈Cxtdτ :: 𝒮Cxt lτ dτ -> dτ
𝓈Cxtρ :: 𝒮Cxt lτ dτ -> Env lτ dτ
𝓈CxtρL :: Lens (𝒮Cxt lτ_a1w2k dτ_a1w2l) (Env lτ_a1w2k dτ_a1w2l)
𝓈CxtdτL :: Lens (𝒮Cxt lτ_a1w2k dτ_a1w2l) dτ_a1w2l
𝓈CxtlτL :: Lens (𝒮Cxt lτ_a1w2k dτ_a1w2l) lτ_a1w2k
data 𝒮 val lτ dτ
𝒮 :: 𝒮Cxt lτ dτ -> Store val lτ dτ -> 𝒮 val lτ dτ
𝓈Cxt :: 𝒮 val lτ dτ -> 𝒮Cxt lτ dτ
𝓈σ :: 𝒮 val lτ dτ -> Store val lτ dτ
𝓈σL :: Lens (𝒮 val_a1w9R lτ_a1w9S dτ_a1w9T) (Store val_a1w9R lτ_a1w9S dτ_a1w9T)
𝓈CxtL :: Lens (𝒮 val_a1w9R lτ_a1w9S dτ_a1w9T) (𝒮Cxt lτ_a1w9S dτ_a1w9T)
𝓈lτL :: Lens (𝒮 val lτ dτ) lτ
𝓈dτL :: Lens (𝒮 val lτ dτ) dτ
𝓈ρL :: Lens (𝒮 val lτ dτ) (Env lτ dτ)
data Clo lτ dτ
Clo :: LocNum -> [Name] -> Call -> Env lτ dτ -> lτ -> Clo lτ dτ
cloLoc :: Clo lτ dτ -> LocNum
cloArgs :: Clo lτ dτ -> [Name]
cloCall :: Clo lτ dτ -> Call
cloEnv :: Clo lτ dτ -> Env lτ dτ
cloTime :: Clo lτ dτ -> lτ
data PicoVal lτ dτ
LitPicoVal :: Lit -> PicoVal lτ dτ
AddrPicoVal :: (Addr lτ dτ) -> PicoVal lτ dτ
class Val lτ dτ val | val -> lτ, val -> dτ
lit :: Val lτ dτ val => Lit -> val
clo :: Val lτ dτ val => Clo lτ dτ -> val
binop :: Val lτ dτ val => BinOp -> val -> val -> val
tup :: Val lτ dτ val => (PicoVal lτ dτ, PicoVal lτ dτ) -> val
elimBool :: Val lτ dτ val => val -> Set Bool
elimClo :: Val lτ dτ val => val -> Set (Clo lτ dτ)
elimTup :: Val lτ dτ val => val -> Set (PicoVal lτ dτ, PicoVal lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Clo lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Clo lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (PicoVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (PicoVal lτ dτ)
instance (Bot lτ, Bot dτ) => Bot (𝒮 val lτ dτ)
instance (Eq val, Eq lτ, Eq dτ) => Eq (𝒮 val lτ dτ)
instance (Ord val, Ord lτ, Ord dτ) => Ord (𝒮 val lτ dτ)
instance (Bot lτ, Bot dτ) => Bot (𝒮Cxt lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (Addr lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (Addr lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (𝒮Cxt lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (𝒮Cxt lτ dτ)

module Lang.LamIf.Val
data CVal lτ dτ
LitC :: Lit -> CVal lτ dτ
CloC :: (Clo lτ dτ) -> CVal lτ dτ
TupC :: (PicoVal lτ dτ, PicoVal lτ dτ) -> CVal lτ dτ
BotC :: CVal lτ dτ
botCL :: Prism (CVal lτ_a1yKI dτ_a1yKJ) ()
tupCL :: Prism (CVal lτ_a1yKI dτ_a1yKJ) (PicoVal lτ_a1yKI dτ_a1yKJ, PicoVal lτ_a1yKI dτ_a1yKJ)
cloCL :: Prism (CVal lτ_a1yKI dτ_a1yKJ) (Clo lτ_a1yKI dτ_a1yKJ)
litCL :: Prism (CVal lτ_a1yKI dτ_a1yKJ) Lit
data AVal lτ dτ
LitA :: Lit -> AVal lτ dτ
IA :: AVal lτ dτ
BA :: AVal lτ dτ
CloA :: (Clo lτ dτ) -> AVal lτ dτ
TupA :: (PicoVal lτ dτ, PicoVal lτ dτ) -> AVal lτ dτ
BotA :: AVal lτ dτ
botAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) ()
tupAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) (PicoVal lτ_a1yOv dτ_a1yOw, PicoVal lτ_a1yOv dτ_a1yOw)
cloAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) (Clo lτ_a1yOv dτ_a1yOw)
bAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) ()
iAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) ()
litAL :: Prism (AVal lτ_a1yOv dτ_a1yOw) Lit
newtype Power val lτ dτ
Power :: Set (val lτ dτ) -> Power val lτ dτ
runPower :: Power val lτ dτ -> Set (val lτ dτ)
instance Eq (Power val lτ dτ)
instance Ord (Power val lτ dτ)
instance PartialOrder (Power val lτ dτ)
instance Bot (Power val lτ dτ)
instance Join (Power val lτ dτ)
instance JoinLattice (Power val lτ dτ)
instance Difference (Power val lτ dτ)
instance Iterable (val lτ dτ) (Power val lτ dτ)
instance Container (val lτ dτ) (Power val lτ dτ)
instance Ord (val lτ dτ) => Buildable (val lτ dτ) (Power val lτ dτ)
instance (Ord lτ, Ord dτ) => Val lτ dτ (Power AVal lτ dτ)
instance (Ord lτ, Ord dτ) => Val lτ dτ (Power CVal lτ dτ)
instance (Ord lτ, Ord dτ) => Val lτ dτ (AVal lτ dτ)
instance (Eq lτ, Eq dτ) => PartialOrder (AVal lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (AVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (AVal lτ dτ)
instance (Ord lτ, Ord dτ) => Val lτ dτ (CVal lτ dτ)
instance (Eq lτ, Eq dτ) => PartialOrder (CVal lτ dτ)
instance (Eq lτ, Eq dτ) => Eq (CVal lτ dτ)
instance (Ord lτ, Ord dτ) => Ord (CVal lτ dτ)

module Lang.LamIf.Pretty
data VarLam n e
VarLam :: [n] -> e -> VarLam n e
instance Pretty (val lτ dτ) => Pretty (Power val lτ dτ)
instance (Pretty lτ, Pretty dτ) => Pretty (AVal lτ dτ)
instance (Pretty lτ, Pretty dτ) => Pretty (CVal lτ dτ)
instance (Pretty Lit, Pretty (Addr lτ0 dτ0)) => Pretty (PicoVal lτ0 dτ0)
instance (Pretty (𝒮Cxt lτ0 dτ0), Pretty (Store val0 lτ0 dτ0)) => Pretty (𝒮 val0 lτ0 dτ0)
instance (Pretty lτ0, Pretty dτ0, Pretty (Env lτ0 dτ0)) => Pretty (𝒮Cxt lτ0 dτ0)
instance (Pretty lτ, Pretty dτ) => Pretty (Clo lτ dτ)
instance (Pretty lτ, Pretty dτ) => Pretty (Addr lτ dτ)
instance Pretty n => Functorial Pretty (PreCall n)
instance (Pretty n, Pretty c) => Pretty (PreCall n c)
instance (Pretty n, Pretty c) => Pretty (PreAtom n c)
instance Pretty n => Pretty (PrePico n)
instance Pretty n => Functorial Pretty (PreExp n)
instance (Pretty n, Pretty e) => Pretty (PreExp n e)
instance (Pretty n, Pretty e) => Pretty (VarLam n e)
instance Pretty BinOp
instance Pretty Lit
instance Pretty GenName
instance Pretty BdrNum
instance Pretty LocNum
instance Pretty RawName

module Lang.LamIf.Parser
data TokenType
White :: TokenType
Num :: TokenType
Key :: TokenType
Id :: TokenType
data Token
Token :: TokenType -> String -> Token
tokenType :: Token -> TokenType
tokenVal :: Token -> String
white :: Parser Char String
litTok :: String -> Parser Char String
numLit :: Parser Char String
ident :: Parser Char String
token :: Parser Char Token
key :: String -> Parser Token ()
litExp :: Parser Token Lit
nameExp :: Parser Token RawName
letExp :: Mix (Parser Token) RawExp
lamExp :: Mix (Parser Token) RawExp
ifExp :: Mix (Parser Token) RawExp
appExp :: Mix (Parser Token) RawExp
tupExp :: Parser Token (RawExp, RawExp)
fstExp :: Mix (Parser Token) RawExp
sndExp :: Mix (Parser Token) RawExp
exp :: Parser Token RawExp
testp0 :: String
testp1 :: String
par :: String -> LexParseError Char Token RawExp :+: RawExp
whitespaceFilter :: Token -> Bool
parseExp :: String -> LexParseError Char Token RawExp :+: RawExp
parseFile :: String -> IO RawExp
instance (Pretty TokenType, Pretty String) => Pretty Token
instance Eq TokenType
instance Ord TokenType
instance Eq Token
instance Ord Token
instance Pretty TokenType

module MAAM.Inject
class Inject ς
inj :: Inject ς => a -> ς a
instance (Inject t, Inject u) => Inject (t :.: u)
instance Bot 𝓈 => Inject ((,) 𝓈)
instance Inject ListSetWithTop
instance Inject ListSet
instance Inject ID

module MAAM.MonadStep
class MonadStep ς m | m -> ς
mstepγ :: MonadStep ς m => (a -> m b) -> ς a -> ς b
mstepγP :: MonadStep ς m => P m -> (a -> m b) -> ς a -> ς b
newtype IsoMonadStep ς1 ς2 m a
IsoMonadStep :: m a -> IsoMonadStep ς1 ς2 m a
runIsoMonadStep :: IsoMonadStep ς1 ς2 m a -> m a
instance (MonadStep ς m, Functor m) => MonadStep (ς :.: (,) 𝓈1) (AddStateT 𝓈12 𝓈1 m)
instance Unit m => Unit (IsoMonadStep ς1 ς2 m)
instance Functor m => Functor (IsoMonadStep ς1 ς2 m)
instance Product m => Product (IsoMonadStep ς1 ς2 m)
instance Applicative m => Applicative (IsoMonadStep ς1 ς2 m)
instance Bind m => Bind (IsoMonadStep ς1 ς2 m)
instance Monad m => Monad (IsoMonadStep ς1 ς2 m)
instance MonadBot m => MonadBot (IsoMonadStep ς1 ς2 m)
instance MonadPlus m => MonadPlus (IsoMonadStep ς1 ς2 m)
instance MonadTop m => MonadTop (IsoMonadStep ς1 ς2 m)
instance MonadState s m => MonadState s (IsoMonadStep ς1 ς2 m)
instance (MonadStep ς2 m, Isomorphism2 ς1 ς2) => MonadStep ς1 (IsoMonadStep ς1 ς2 m)
instance (Commute t ListSet, Commute u ListSet, Functor t) => Commute (t :.: u) ListSet
instance JoinLattice 𝓈 => Commute ((,) 𝓈) ListSet
instance Commute ID ListSet
instance (MonadStep ς m, Functorial JoinLattice m, Functorial Top m) => MonadStep (ς :.: ListSetWithTop) (ListSetWithTopT m)
instance (MonadStep ς m, Functorial JoinLattice m) => MonadStep (ς :.: ListSet) (ListSetT m)
instance (MonadStep ς m, Functor m) => MonadStep (ς :.: (,) 𝓈) (StateT 𝓈 m)
instance MonadStep ID ID

module MAAM.Time
class Time ψ τ | τ -> ψ
tzero :: Time ψ τ => τ
tick :: Time ψ τ => ψ -> τ -> τ
newtype Cτ ψ
Cτ :: [ψ] -> Cτ ψ
newtype Kτ (k :: Nat) ψ
Kτ :: [ψ] -> Kτ ψ
data Zτ ψ
Zτ :: Zτ ψ
instance Eq ψ => Eq (Cτ ψ)
instance Ord ψ => Ord (Cτ ψ)
instance Pretty ψ => Pretty (Cτ ψ)
instance Eq ψ => Container ψ (Cτ ψ)
instance Iterable ψ (Cτ ψ)
instance Buildable ψ (Cτ ψ)
instance Eq ψ => Eq (Kτ k ψ)
instance Ord ψ => Ord (Kτ k ψ)
instance Pretty ψ => Pretty (Kτ k ψ)
instance Eq ψ => Container ψ (Kτ k ψ)
instance Iterable ψ (Kτ k ψ)
instance Buildable ψ (Kτ k ψ)
instance Eq (Zτ ψ)
instance Ord (Zτ ψ)
instance Time ψ (Zτ ψ)
instance Bot (Zτ ψ)
instance Functorial Pretty Zτ
instance Functorial Ord Zτ
instance Functorial Eq Zτ
instance Pretty (Zτ a)
instance KnownNat k => Time ψ (Kτ k ψ)
instance Bot (Kτ k ψ)
instance Functorial Pretty (Kτ k)
instance Functorial Ord (Kτ k)
instance Functorial Eq (Kτ k)
instance Time ψ (Cτ ψ)
instance Bot (Cτ ψ)
instance Functorial Pretty Cτ
instance Functorial Ord Cτ
instance Functorial Eq Cτ

module MAAM

module Lang.Hask.Execution
class (PartialOrder (ς Call), JoinLattice (ς Call), Difference (ς Call), Inject ς', MonadStep ς' m, Isomorphism (ς' Call) (ς Call)) => Execution ς ς' m | m -> ς, m -> ς'
exec :: (Analysis ν lτ dτ m, Execution ς ς' m) => P m -> Call -> ς Call
execDiffs :: (Analysis ν lτ dτ m, Execution ς ς' m) => P m -> Call -> [ς Call]

module Lang.Hask.Monads
type PSΣ' ν lτ dτ = (ID :.: ListSetWithTop) :.: (,) (𝒮 ν lτ dτ)
newtype PSΣ ν lτ dτ a
PSΣ :: ListSetWithTop (a, 𝒮 ν lτ dτ) -> PSΣ ν lτ dτ a
runPSΣ :: PSΣ ν lτ dτ a -> ListSetWithTop (a, 𝒮 ν lτ dτ)
newtype PSΣ𝒫 ν lτ dτ a
PSΣ𝒫 :: SetWithTop (a, 𝒮 ν lτ dτ) -> PSΣ𝒫 ν lτ dτ a
runPSΣ𝒫 :: PSΣ𝒫 ν lτ dτ a -> SetWithTop (a, 𝒮 ν lτ dτ)
newtype PS ν lτ dτ a
FSPS :: IsoMonadStep (PSΣ ν lτ dτ) (PSΣ' ν lτ dτ) (StateT (𝒮 ν lτ dτ) (ListSetWithTopT ID)) a -> PS ν lτ dτ a
runPS :: PS ν lτ dτ a -> IsoMonadStep (PSΣ ν lτ dτ) (PSΣ' ν lτ dτ) (StateT (𝒮 ν lτ dτ) (ListSetWithTopT ID)) a
psm :: P lτ -> P dτ -> P ν -> P (PS ν lτ dτ)
instance (Ord lτ, Ord dτ, Ord a, Ord (ν lτ dτ)) => PartialOrder (PSΣ ν lτ dτ a)
instance Bot (PSΣ ν lτ dτ a)
instance Join (PSΣ ν lτ dτ a)
instance JoinLattice (PSΣ ν lτ dτ a)
instance (Ord lτ, Ord dτ, Ord a, Ord (ν lτ dτ)) => PartialOrder (PSΣ𝒫 ν lτ dτ a)
instance Bot (PSΣ𝒫 ν lτ dτ a)
instance Join (PSΣ𝒫 ν lτ dτ a)
instance JoinLattice (PSΣ𝒫 ν lτ dτ a)
instance Difference (PSΣ𝒫 ν lτ dτ a)
instance (Pretty lτ, Pretty dτ, Pretty a, Pretty (ν lτ dτ)) => Pretty (PSΣ𝒫 ν lτ dτ a)
instance Unit (PS ν lτ dτ)
instance Functor (PS ν lτ dτ)
instance Product (PS ν lτ dτ)
instance Applicative (PS ν lτ dτ)
instance Bind (PS ν lτ dτ)
instance Monad (PS ν lτ dτ)
instance MonadBot (PS ν lτ dτ)
instance MonadPlus (PS ν lτ dτ)
instance MonadTop (PS ν lτ dτ)
instance MonadState (𝒮 ν lτ dτ) (PS ν lτ dτ)
instance MonadStep (PSΣ ν lτ dτ) (PS ν lτ dτ)
instance (TimeC lτ dτ, Ord (ν lτ dτ)) => Execution (PSΣ𝒫 ν lτ dτ) (PSΣ ν lτ dτ) (PS ν lτ dτ)
instance (TimeC lτ dτ, ValC ν lτ dτ) => Analysis ν lτ dτ (PS ν lτ dτ)
instance (Ord (ν lτ dτ), Ord lτ, Ord dτ, Ord a) => Isomorphism (PSΣ ν lτ dτ a) (PSΣ𝒫 ν lτ dτ a)
instance (Ord (ν lτ dτ), Ord lτ, Ord dτ, Ord a) => Morphism (PSΣ𝒫 ν lτ dτ a) (PSΣ ν lτ dτ a)
instance (Ord (ν lτ dτ), Ord lτ, Ord dτ, Ord a) => Morphism (PSΣ ν lτ dτ a) (PSΣ𝒫 ν lτ dτ a)
instance Isomorphism2 (PSΣ ν lτ dτ) (PSΣ' ν lτ dτ)
instance (TimeC lτ dτ) => Inject (PSΣ ν lτ dτ)
instance Morphism2 (PSΣ' ν lτ dτ) (PSΣ ν lτ dτ)
instance Morphism2 (PSΣ ν lτ dτ) (PSΣ' ν lτ dτ)

module Lang.LamIf.Semantics
type Ψ = LocNum
type TimeC τ = (Time Ψ τ, Bot τ, Ord τ, Pretty τ)
type ValC lτ dτ val = (Val lτ dτ val, Ord val, PartialOrder val, JoinLattice val, Difference val, Pretty val)
type MonadC val lτ dτ m = (Monad m, MonadBot m, MonadPlus m, MonadState (𝒮 val lτ dτ) m)
class (TimeC lτ, TimeC dτ, ValC lτ dτ val, MonadC val lτ dτ m) => Analysis val lτ dτ m | m -> val, m -> lτ, m -> dτ
type GC m = Call -> m ()
type CreateClo lτ dτ m = LocNum -> [Name] -> Call -> m (Clo lτ dτ)
type TimeFilter = Call -> Bool
new :: Analysis val lτ dτ m => Name -> m (Addr lτ dτ)
bind :: Analysis val lτ dτ m => Name -> val -> Map Name (Addr lτ dτ) -> m (Map Name (Addr lτ dτ))
bindM :: Analysis val lτ dτ m => Name -> val -> m ()
rebind :: Analysis val lτ dτ m => Name -> val -> m ()
rebindPico :: Analysis val lτ dτ m => PrePico Name -> val -> m ()
addr :: Analysis val lτ dτ m => Addr lτ dτ -> m val
var :: Analysis val lτ dτ m => Name -> m val
lam :: Analysis val lτ dτ m => CreateClo lτ dτ m -> LocNum -> [Name] -> Call -> m val
picoRef :: Analysis val lτ dτ m => Pico -> m (PicoVal lτ dτ)
picoVal :: Analysis val lτ dτ m => PicoVal lτ dτ -> m val
pico :: Analysis val lτ dτ m => Pico -> m val
atom :: Analysis val lτ dτ m => CreateClo lτ dτ m -> Atom -> m val
apply :: Analysis val lτ dτ m => TimeFilter -> Call -> PrePico Name -> val -> [val] -> m Call
call :: Analysis val lτ dτ m => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> m Call
onlyStuck :: (MonadStep ς m, Analysis val lτ dτ m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> m Call
type StateSpaceC ς' = (PartialOrder (ς' Call), JoinLattice (ς' Call), Difference (ς' Call), Pretty (ς' Call))
class (MonadStep ς m, Inject ς, Isomorphism (ς Call) (ς' Call), StateSpaceC ς') => Execution ς ς' m | m -> ς, m -> ς'
liftς :: Execution ς ς' m => (Call -> m Call) -> (ς' Call -> ς' Call)
injectς :: (Inject ς, Isomorphism (ς a) (ς' a)) => P ς -> a -> ς' a
execς :: (Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> ς' Call
execCollect :: (Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> ς' Call
execCollectHistory :: (Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> [ς' Call]
execCollectDiffs :: (Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> [ς' Call]
execOnlyStuck :: (Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> Call -> ς' Call
nogc :: Monad m => Call -> m ()
yesgc :: Analysis val lτ dτ m => Call -> m ()
callTouched :: (TimeC lτ, TimeC dτ) => Env lτ dτ -> Set Name -> Set (Addr lτ dτ)
closureTouched :: (TimeC lτ, TimeC dτ) => Clo lτ dτ -> Set (Addr lτ dτ)
picoValTouched :: (TimeC lτ, TimeC dτ) => PicoVal lτ dτ -> Set (Addr lτ dτ)
tupleTouched :: (TimeC lτ, TimeC dτ) => (PicoVal lτ dτ, PicoVal lτ dτ) -> Set (Addr lτ dτ)
addrTouched :: (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Map (Addr lτ dτ) val -> Addr lτ dτ -> Set (Addr lτ dτ)
linkClo :: Analysis val lτ dτ m => LocNum -> [Name] -> Call -> m (Clo lτ dτ)
copyClo :: Analysis val lτ dτ m => LocNum -> [Name] -> Call -> m (Clo lτ dτ)
type UniTime τ = W (TimeC τ)
data ExTime
ExTime :: UniTime τ -> ExTime
type UniVal val = forall lτ dτ. (TimeC lτ, TimeC dτ) => W (ValC lτ dτ (val lτ dτ))
data ExVal
ExVal :: UniVal val -> ExVal
type UniMonad ς ς' m = forall val lτ dτ. (TimeC lτ, TimeC dτ, ValC lτ dτ val) => W (Analysis val lτ dτ (m val lτ dτ), Execution (ς val lτ dτ) (ς' val lτ dτ) (m val lτ dτ))
data ExMonad
ExMonad :: UniMonad ς ς' m -> ExMonad
newtype AllGC
AllGC :: (forall val lτ dτ m. Analysis val lτ dτ m => GC m) -> AllGC
runAllGC :: AllGC -> forall val lτ dτ m. Analysis val lτ dτ m => GC m
newtype AllCreateClo
AllCreateClo :: (forall val lτ dτ m. Analysis val lτ dτ m => CreateClo lτ dτ m) -> AllCreateClo
runAllCreateClo :: AllCreateClo -> forall val lτ dτ m. Analysis val lτ dτ m => CreateClo lτ dτ m
data Options
Options :: ExTime -> ExTime -> ExVal -> ExMonad -> AllGC -> AllCreateClo -> TimeFilter -> TimeFilter -> Options
ltimeOp :: Options -> ExTime
dtimeOp :: Options -> ExTime
valOp :: Options -> ExVal
monadOp :: Options -> ExMonad
gcOp :: Options -> AllGC
createCloOp :: Options -> AllCreateClo
ltimeFilterOp :: Options -> TimeFilter
dtimeFilterOp :: Options -> TimeFilter
withOptions :: Options -> ((Analysis val lτ dτ m, Execution ς ς' m) => GC m -> CreateClo lτ dτ m -> TimeFilter -> TimeFilter -> a) -> a

module Lang.LamIf.Monads
type PSΣ' val lτ dτ = (ID :.: ListSet) :.: (,) (𝒮 val lτ dτ)
newtype PSΣ val lτ dτ a
PSΣ :: ListSet (a, 𝒮 val lτ dτ) -> PSΣ val lτ dτ a
unPSΣ :: PSΣ val lτ dτ a -> ListSet (a, 𝒮 val lτ dτ)
newtype PSΣ𝒫 val lτ dτ a
PSΣ𝒫 :: Set (a, 𝒮 val lτ dτ) -> PSΣ𝒫 val lτ dτ a
unPSΣ𝒫 :: PSΣ𝒫 val lτ dτ a -> Set (a, 𝒮 val lτ dτ)
newtype PS val lτ dτ a
FSPS :: IsoMonadStep (PSΣ val lτ dτ) (PSΣ' val lτ dτ) (StateT (𝒮 val lτ dτ) (ListSetT ID)) a -> PS val lτ dτ a
unPS :: PS val lτ dτ a -> IsoMonadStep (PSΣ val lτ dτ) (PSΣ' val lτ dτ) (StateT (𝒮 val lτ dτ) (ListSetT ID)) a
type FSΣ' val lτ dτ = (ID :.: ListSet) :.: (,) (𝒮 val lτ dτ)
newtype FSΣ val lτ dτ a
FSΣ :: ListSet (a, 𝒮 val lτ dτ) -> FSΣ val lτ dτ a
unFSΣ :: FSΣ val lτ dτ a -> ListSet (a, 𝒮 val lτ dτ)
newtype FSΣ𝒫 val lτ dτ a
FSΣ𝒫 :: Map a (Set (𝒮Cxt lτ dτ), Store val lτ dτ) -> FSΣ𝒫 val lτ dτ a
unFSΣ𝒫 :: FSΣ𝒫 val lτ dτ a -> Map a (Set (𝒮Cxt lτ dτ), Store val lτ dτ)
newtype FS val lτ dτ a
FS :: IsoMonadStep (FSΣ val lτ dτ) (FSΣ' val lτ dτ) (StateT (𝒮 val lτ dτ) (ListSetT ID)) a -> FS val lτ dτ a
unFS :: FS val lτ dτ a -> IsoMonadStep (FSΣ val lτ dτ) (FSΣ' val lτ dτ) (StateT (𝒮 val lτ dτ) (ListSetT ID)) a
type FIΣ' val lτ dτ = ((ID :.: (,) (Store val lτ dτ)) :.: ListSet) :.: (,) (𝒮Cxt lτ dτ)
newtype FIΣ val lτ dτ a
FIΣ :: (ListSet (a, 𝒮Cxt lτ dτ), Store val lτ dτ) -> FIΣ val lτ dτ a
unFIΣ :: FIΣ val lτ dτ a -> (ListSet (a, 𝒮Cxt lτ dτ), Store val lτ dτ)
newtype FIΣ𝒫 val lτ dτ a
FIΣ𝒫 :: (Set (a, 𝒮Cxt lτ dτ), Store val lτ dτ) -> FIΣ𝒫 val lτ dτ a
unFIΣ𝒫 :: FIΣ𝒫 val lτ dτ a -> (Set (a, 𝒮Cxt lτ dτ), Store val lτ dτ)
newtype FI val lτ dτ a
FIPI :: IsoMonadStep (FIΣ val lτ dτ) (FIΣ' val lτ dτ) (AddStateT (𝒮 val lτ dτ) (𝒮Cxt lτ dτ) (ListSetT (StateT (Store val lτ dτ) ID))) a -> FI val lτ dτ a
unFI :: FI val lτ dτ a -> IsoMonadStep (FIΣ val lτ dτ) (FIΣ' val lτ dτ) (AddStateT (𝒮 val lτ dτ) (𝒮Cxt lτ dτ) (ListSetT (StateT (Store val lτ dτ) ID))) a
instance (Ord val, Ord lτ, Ord dτ, Ord a) => PartialOrder (PSΣ val lτ dτ a)
instance Bot (PSΣ val lτ dτ a)
instance Join (PSΣ val lτ dτ a)
instance JoinLattice (PSΣ val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a, Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (PSΣ val lτ dτ a)
instance PartialOrder (PSΣ𝒫 val lτ dτ a)
instance Bot (PSΣ𝒫 val lτ dτ a)
instance Join (PSΣ𝒫 val lτ dτ a)
instance JoinLattice (PSΣ𝒫 val lτ dτ a)
instance (Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (PSΣ𝒫 val lτ dτ a)
instance Difference (PSΣ𝒫 val lτ dτ a)
instance Unit (PS val lτ dτ)
instance Functor (PS val lτ dτ)
instance Product (PS val lτ dτ)
instance Applicative (PS val lτ dτ)
instance Bind (PS val lτ dτ)
instance Monad (PS val lτ dτ)
instance MonadBot (PS val lτ dτ)
instance MonadPlus (PS val lτ dτ)
instance MonadState (𝒮 val lτ dτ) (PS val lτ dτ)
instance MonadStep (PSΣ val lτ dτ) (PS val lτ dτ)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => PartialOrder (FSΣ val lτ dτ a)
instance Bot (FSΣ val lτ dτ a)
instance Join (FSΣ val lτ dτ a)
instance JoinLattice (FSΣ val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a, Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (FSΣ val lτ dτ a)
instance (Ord lτ, Ord dτ, Ord a, PartialOrder val) => PartialOrder (FSΣ𝒫 val lτ dτ a)
instance Bot (FSΣ𝒫 val lτ dτ a)
instance Join val => Join (FSΣ𝒫 val lτ dτ a)
instance JoinLattice val => JoinLattice (FSΣ𝒫 val lτ dτ a)
instance (Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (FSΣ𝒫 val lτ dτ a)
instance Difference val => Difference (FSΣ𝒫 val lτ dτ a)
instance Unit (FS val lτ dτ)
instance Functor (FS val lτ dτ)
instance Product (FS val lτ dτ)
instance Applicative (FS val lτ dτ)
instance Bind (FS val lτ dτ)
instance Monad (FS val lτ dτ)
instance MonadBot (FS val lτ dτ)
instance MonadPlus (FS val lτ dτ)
instance MonadState (𝒮 val lτ dτ) (FS val lτ dτ)
instance MonadStep (FSΣ val lτ dτ) (FS val lτ dτ)
instance (Ord lτ, Ord dτ, Ord a, PartialOrder val) => PartialOrder (FIΣ val lτ dτ a)
instance Bot (FIΣ val lτ dτ a)
instance Join val => Join (FIΣ val lτ dτ a)
instance JoinLattice val => JoinLattice (FIΣ val lτ dτ a)
instance (Ord lτ, Ord dτ, Ord a, Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (FIΣ val lτ dτ a)
instance (Ord lτ, Ord dτ, PartialOrder val) => PartialOrder (FIΣ𝒫 val lτ dτ a)
instance Bot (FIΣ𝒫 val lτ dτ a)
instance Join val => Join (FIΣ𝒫 val lτ dτ a)
instance JoinLattice val => JoinLattice (FIΣ𝒫 val lτ dτ a)
instance Difference val => Difference (FIΣ𝒫 val lτ dτ a)
instance (Pretty val, Pretty lτ, Pretty dτ, Pretty a) => Pretty (FIΣ𝒫 val lτ dτ a)
instance Unit (FI val lτ dτ)
instance Functor (FI val lτ dτ)
instance JoinLattice val => Product (FI val lτ dτ)
instance JoinLattice val => Applicative (FI val lτ dτ)
instance JoinLattice val => Bind (FI val lτ dτ)
instance JoinLattice val => Monad (FI val lτ dτ)
instance JoinLattice val => MonadBot (FI val lτ dτ)
instance JoinLattice val => MonadPlus (FI val lτ dτ)
instance JoinLattice val => MonadState (𝒮 val lτ dτ) (FI val lτ dτ)
instance JoinLattice val => MonadStep (FIΣ val lτ dτ) (FI val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Execution (FIΣ val lτ dτ) (FIΣ𝒫 val lτ dτ) (FI val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Analysis val lτ dτ (FI val lτ dτ)
instance (TimeC lτ, TimeC dτ) => Inject (FIΣ val lτ dτ)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Isomorphism (FIΣ val lτ dτ a) (FIΣ𝒫 val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Morphism (FIΣ𝒫 val lτ dτ a) (FIΣ val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Morphism (FIΣ val lτ dτ a) (FIΣ𝒫 val lτ dτ a)
instance Isomorphism2 (FIΣ val lτ dτ) (FIΣ' val lτ dτ)
instance Morphism2 (FIΣ' val lτ dτ) (FIΣ val lτ dτ)
instance Morphism2 (FIΣ val lτ dτ) (FIΣ' val lτ dτ)
instance Isomorphism (𝒮 val lτ dτ) (𝒮Cxt lτ dτ, Store val lτ dτ)
instance Morphism (𝒮Cxt lτ dτ, Store val lτ dτ) (𝒮 val lτ dτ)
instance Morphism (𝒮 val lτ dτ) (𝒮Cxt lτ dτ, Store val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Execution (FSΣ val lτ dτ) (FSΣ𝒫 val lτ dτ) (FS val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Analysis val lτ dτ (FS val lτ dτ)
instance (Ord val, Join val, Ord lτ, Ord dτ, Ord a) => Isomorphism (FSΣ val lτ dτ a) (FSΣ𝒫 val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Morphism (FSΣ𝒫 val lτ dτ a) (FSΣ val lτ dτ a)
instance (Ord val, Join val, Ord lτ, Ord dτ, Ord a) => Morphism (FSΣ val lτ dτ a) (FSΣ𝒫 val lτ dτ a)
instance (TimeC lτ, TimeC dτ) => Inject (FSΣ val lτ dτ)
instance Isomorphism2 (FSΣ val lτ dτ) (FSΣ' val lτ dτ)
instance Morphism2 (FSΣ' val lτ dτ) (FSΣ val lτ dτ)
instance Morphism2 (FSΣ val lτ dτ) (FSΣ' val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Execution (PSΣ val lτ dτ) (PSΣ𝒫 val lτ dτ) (PS val lτ dτ)
instance (TimeC lτ, TimeC dτ, ValC lτ dτ val) => Analysis val lτ dτ (PS val lτ dτ)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Isomorphism (PSΣ val lτ dτ a) (PSΣ𝒫 val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Morphism (PSΣ𝒫 val lτ dτ a) (PSΣ val lτ dτ a)
instance (Ord val, Ord lτ, Ord dτ, Ord a) => Morphism (PSΣ val lτ dτ a) (PSΣ𝒫 val lτ dτ a)
instance (TimeC lτ, TimeC dτ) => Inject (PSΣ val lτ dτ)
instance Isomorphism2 (PSΣ val lτ dτ) (PSΣ' val lτ dτ)
instance Morphism2 (PSΣ' val lτ dτ) (PSΣ val lτ dτ)
instance Morphism2 (PSΣ val lτ dτ) (PSΣ' val lτ dτ)

module Lang.LamIf.Analyses
timeChoices :: [(String, ExTime)]
valChoices :: [(String, ExVal)]
monadChoices :: [(String, ExMonad)]
gcChoices :: [(String, AllGC)]
closureChoices :: [(String, AllCreateClo)]
timeFilterChoices :: [(String, TimeFilter)]

module Lang.LamIf

module Lang.LamIf.Examples
examplesMain :: IO ()
makeOptions :: [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [(Doc, Options)]
runOptions :: [(Doc, Options)] -> RawExp -> Doc
flowSensitivityMain :: IO ()
callSiteSensitivityMain :: IO ()
objectSensitivityMain :: IO ()
