-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Attribute Grammars in the form of an EDSL
--   
--   Library of strongly typed Attribute Grammars implemented using
--   type-level programming
@package AspectAG
@version 0.3.6.1


-- | Library for First-Class Attribute Grammars.
--   
--   The library is documented in the paper: <i>Attribute Grammars Fly
--   First-Class. How to do aspect oriented programming in Haskell</i>
--   
--   For more documentation see the AspectAG webpage:
--   <a>http://www.cs.uu.nl/wiki/bin/view/Center/AspectAG</a>.
module Language.Grammars.AspectAG

-- | Field of an attribution.
type Att att val = LVPair att val

-- | A Family <a>Fam</a> contains a single attribution <tt>p</tt> for the
--   parent, <tt>l</tt> for local attributes, <tt>ho</tt> for higer-order
--   attributes and a collection of attributions <tt>c</tt> for the
--   children.
data Fam l ho c p
Fam :: l -> ho -> c -> p -> Fam l ho c p

-- | Field of the record of attributions for the children.
type Chi ch atts = LVPair ch atts

-- | The type <a>Rule</a> states that a rule takes as input the local
--   attributes <tt>lf</tt>, the higher-order attributes <tt>hof</tt>, the
--   synthesized attributes of the children <tt>sc</tt> and the inherited
--   attributes of the parent <tt>ip</tt> and returns a function from the
--   output constructed thus far (local attributes <tt>l</tt>, higher-order
--   attributes <tt>ho</tt>, inherited attributes of the children
--   <tt>ic</tt> and synthesized attributes of the parent <tt>sp</tt>) to
--   the extended output.
type Rule lf hof sc ip l ho ic sp l' ho' ic' sp' = Fam lf hof sc ip -> Fam l ho ic sp -> Fam l' ho' ic' sp'

-- | An <a>emptyRule</a> does not introduce any new attribute.
emptyRule :: Rule lf hof sc ip l ho ic sp l ho ic sp

-- | The function <a>instdef</a> adds the definition of a higher-order
--   attribute. It takes a label <tt>att</tt> representing the name of the
--   new attribute, a value <tt>val</tt> to be assigned to this attribute,
--   and it builds a function which updates the output constructed thus
--   far.
instdef :: HExtend (Att att val) ho ho' => att -> val -> (Fam l ho ic sp -> Fam l ho' ic sp)

-- | The function <a>locdef</a> adds the definition of a local attribute.
--   It takes a label <tt>att</tt> representing the name of the new
--   attribute, a value <tt>val</tt> to be assigned to this attribute, and
--   it builds a function which updates the output constructed thus far.
locdef :: HExtend (Att att val) l l' => att -> val -> (Fam l ho ic sp -> Fam l' ho ic sp)

-- | The function <a>inhdef</a> introduces a new inherited attribute for a
--   collection of non-terminals. It takes the following parameters:
--   <tt>att</tt>: the attribute which is being defined, <tt>nts</tt>: the
--   non-terminals with which this attribute is being associated, and
--   <tt>vals</tt>: a record labelled with child names and containing
--   values, describing how to compute the attribute being defined at each
--   of the applicable child positions. It builds a function which updates
--   the output constructed thus far.
inhdef :: Defs att nts vals ic ic' => att -> nts -> vals -> (Fam l ho ic sp -> Fam l ho ic' sp)

-- | The function <a>syndef</a> adds the definition of a synthesized
--   attribute. It takes a label <tt>att</tt> representing the name of the
--   new attribute, a value <tt>val</tt> to be assigned to this attribute,
--   and it builds a function which updates the output constructed thus
--   far.
syndef :: HExtend (Att att val) sp sp' => att -> val -> (Fam l ho ic sp -> Fam l ho ic sp')

-- | The function <a>inhmod</a> modifies an inherited attribute for a
--   collection of non-terminals. It takes the following parameters:
--   <tt>att</tt>: the attribute which is being defined, <tt>nts</tt>: the
--   non-terminals with which this attribute is being associated, and
--   <tt>vals</tt>: a record labelled with child names and containing
--   values, describing how to compute the attribute being defined at each
--   of the applicable child positions. It builds a function which updates
--   the output constructed thus far.||
inhmod :: Mods att nts vals ic ic' => att -> nts -> vals -> (Fam l ho ic sp -> Fam l ho ic' sp)

-- | The function <a>synmod</a> modifies the definition of a synthesized
--   attribute. It takes a label <tt>att</tt> representing the name of the
--   attribute, a value <tt>val</tt> to be assigned to this attribute, and
--   it builds a function which updates the output constructed thus far.
synmod :: HUpdateAtLabel att val sp sp' => att -> val -> Fam l ho ic sp -> Fam l ho ic sp'
inhupd :: Upds att nts vals ic ic' => att -> nts -> vals -> (Fam l ho ic sp -> Fam l ho ic' sp)
synupd :: (HasField att sp val, HUpdateAtLabel att val' sp sp') => att -> (val -> val') -> Fam l ho ic sp -> Fam l ho ic sp'
class At l m v | l -> v
at :: At l m v => l -> m v
lhs :: Proxy Lhs
loc :: Proxy Loc
def :: Reader (Fam l ho chi par) a -> ((Fam l ho chi par) -> a)
instdefM :: HExtend (Att att a) ho ho' => att -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho' ic sp
locdefM :: HExtend (Att att a) l l' => att -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l' ho ic sp
inhdefM :: Defs att nts a ic ic' => att -> nts -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho ic' sp
syndefM :: HExtend (Att att a) sp sp' => att -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho ic sp'
inh :: Defs att nts a ic ic' => att -> nts -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho ic' sp
syn :: HExtend (Att att a) sp sp' => att -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho ic sp'
inhmodM :: Mods att nts a ic ic' => att -> nts -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic sp l ho ic' sp
synmodM :: (HUpdateAtHNat n (Att att a) sp sp', HFind att ls n, RecordLabels sp ls) => att -> Reader (Fam lf hof sc ip) a -> Rule lf hof sc ip l ho ic (Record sp) l ho ic (Record sp')
inhupdM :: Upds att nts vals ic ic' => att -> nts -> Reader (Fam l1 ho1 chi par) vals -> Fam l1 ho1 chi par -> Fam l ho ic sp -> Fam l ho ic' sp
synupdM :: (HasField att sp val, HUpdateAtLabel att val' sp sp') => att -> Reader (Fam l1 ho1 chi par) (val -> val') -> Fam l1 ho1 chi par -> Fam l ho ic sp -> Fam l ho ic sp'

-- | Composition of two rules.
ext :: Rule lf hof sc ip l' ho' ic' sp' l'' ho'' ic'' sp'' -> Rule lf hof sc ip l ho ic sp l' ho' ic' sp' -> Rule lf hof sc ip l ho ic sp l'' ho'' ic'' sp''

-- | Adaption of the childen of a rule.
adapt :: Rule lf hof sc ip li hoi ici spi lo hoo ico spo -> (sc' -> sc) -> (ici' -> ici) -> (ico -> ico') -> Rule lf hof sc' ip li hoi ici' spi lo hoo ico' spo

-- | Children renaming.
rename :: (RenRL s sc' sc, RenRL s ici' ici, RenLR s ico ico') => Rule lf hof sc ip li hoi ici spi lo hoo ico spo -> s -> Rule lf hof sc' ip li hoi ici' spi lo hoo ico' spo

-- | Children mapping.
mapChildren :: (MapRL s sc' sc, MapRL s ici' ici, MapLR s ico ico') => Rule lf hof sc ip li hoi ici spi lo hoo ico spo -> s -> Rule lf hof sc' ip li hoi ici' spi lo hoo ico' spo

-- | Fixing a constant as a child.
fixCst :: (RecordLabels r ls, HRLabelSet (HCons (LVPair l (Record HNil)) r), HExtend (LVPair l v) t2 l', HRearrange ls r1 r', HLabelSet ls, H2ProjectByLabels (HCons l HNil) t10 t11 r1) => (Fam t t1 l' t3 -> Fam t4 t5 (Record (HCons (LVPair l (Record HNil)) r)) t6 -> Fam t7 t8 (Record t10) t9) -> l -> v -> Fam t t1 t2 t3 -> Fam t4 t5 (Record r) t6 -> Fam t7 t8 (Record r') t9

-- | Grafting one tree as a child of the other.
graft :: (HasField' b e (HCons (LVPair e v2) a3) v, HasField' b e (HCons (LVPair e (Record HNil)) a2) v1, HasField e t2 ip1, RecordLabels t ls2, HEq e e b, HRLabelSet a1, HRLabelSet (HCons (LVPair e (Record HNil)) a2), HRLabelSet a3, HRLabelSet (HCons (LVPair e e) r1), HRLabelSet (HCons (LVPair e v2) a3), HRLabelSet (HCons (LVPair e v) r'), HRLabelSet (HCons (LVPair e v1) r'1), HRLabelSet a2, HRLabelSet a, MapLR r ico1 r3, MapLR (HCons (LVPair e e) r1) ico (Record t2), MapRL r1 (Record (HCons (LVPair e (Record HNil)) a2)) (Record r'1), MapRL r (Record a1) sc, MapRL r (Record a) ici, MapRL r1 (Record (HCons (LVPair e v2) a3)) (Record r'), H2ProjectByLabels ls t1 a1 b2, H2ProjectByLabels ls1 t1 a3 b4, H2ProjectByLabels (HCons e HNil) t2 t3 t4, H2ProjectByLabels ls1 t a2 b3, H2ProjectByLabels ls t a b1, RecordValues r1 ls1, RecordValues r ls, HLeftUnion r3 (Record t4) (Record r2), HRearrange ls2 r2 r'2, HLabelSet ls2) => Rule lf hof (Record (HCons (LVPair e v) r')) ip li hoi (Record (HCons (LVPair e v1) r'1)) spi li1 hoi1 ico p -> Record r1 -> e -> Rule lf hof sc ip1 li1 hoi1 ici (Record HNil) l ho ico1 v2 -> Record r -> Fam lf hof (Record t1) ip -> Fam li hoi (Record t) spi -> Fam l ho (Record r'2) p

-- | A generalized version of <a>graft</a> that grafts into or maps every
--   children.
agMacro :: (RecordLabels r ls, HRearrange ls r1 r', HLabelSet ls) => (Fam l1 ho1 c p1 -> Fam l ho c1 p -> Fam t t1 t2 p2, (l1, ho1, c2, Record r) -> (t, t1, t2, Record HNil, Record HNil) -> (l2, ho2, Record r1, c1, c)) -> Fam l1 ho1 c2 p1 -> Fam l ho (Record r) p -> Fam l2 ho2 (Record r') p2

-- | Child mapping definition, it reads <i>replaced by the constant</i>.
(~~>) :: (HExtend (LVPair e (Record HNil)) l1 t9, HExtend (LVPair e v) l t10, H2ProjectByLabels (HCons e HNil) t4 t5 t6) => e -> v -> (t, t1, t2, t3) -> (t7, t8, Record t4, l1, l) -> (t7, t8, Record t6, t9, t10)

-- | Child mapping definition, it reads <i>replaced by</i>.
(==>) :: (HExtend (LVPair l3 v) l2 t14, HExtend (LVPair l3 (Record HNil)) l t13, HasField l3 t7 p, H2ProjectByLabels (HCons l3 HNil) t7 t8 t9, HLeftUnion r (Record t9) t12) => l3 -> (Fam t t1 c p -> Fam l1 ho c1 (Record HNil) -> Fam t4 t5 t6 v, (t, t1, t2, t3) -> (t4, t5, t6, Record HNil, Record HNil) -> (t10, t11, r, c1, c)) -> (t, t1, t2, t3) -> (l1, ho, Record t7, l, l2) -> (t10, t11, t12, t13, t14)

-- | Child mapping definition, it reads <i>binds to</i>.
(-->) :: (HasField l2 t2 v2, HasField l3 r1 v1, HasField l3 r v, HRLabelSet (HCons (LVPair l3 v2) t6), H2ProjectByLabels (HCons l2 HNil) t2 t3 t4, H2ProjectByLabels (HCons l3 HNil) t4 t5 t6, HExtend (LVPair l2 v1) l1 t9, HExtend (LVPair l2 v) l t10) => l2 -> l3 -> (t, t1, r, r1) -> (t7, t8, Record t2, l1, l) -> (t7, t8, Record (HCons (LVPair l3 v2) t6), t9, t10)

-- | Composition of children mapping definitions for the function
--   <tt>macro</tt>.
(<.>) :: ((lf, hof, sc, ici) -> (l2, ho2, ico1', ici1', sc1') -> (l3, ho3, ico1'', ici1'', sc1'')) -> ((lf, hof, sc, ici) -> (l1, ho1, ico1, ici1, sc1) -> (l2, ho2, ico1', ici1', sc1')) -> (lf, hof, sc, ici) -> (l1, ho1, ico1, ici1, sc1) -> (l3, ho3, ico1'', ici1'', sc1'')
ignore :: HExtend (LVPair lch (Record HNil)) l t6 => lch -> (t, t1, t2, t3) -> (t4, t5, l, t7, t8) -> (t4, t5, t6, t7, t8)
noChild :: (t, t1, t2, t3) -> (t4, t5, t6, t7, t8) -> (t4, t5, t6, t7, t8)
withChild :: HasField lch sc v => lch -> (v -> Rule lf hof sc ip l ho ic sp l' ho' ic' sp') -> Rule lf hof sc ip l ho ic sp l' ho' ic' sp'
withChildAtt :: (HasField lch sc r, HasField att r v) => lch -> att -> (v -> Rule lf hof sc ip l ho ic sp l' ho' ic' sp') -> Rule lf hof sc ip l ho ic sp l' ho' ic' sp'

-- | Field of an aspect. It associates a production <tt>prd</tt> with a
--   rule <tt>rule</tt>.
type Prd prd rule = LVPair prd rule
(.+.) :: Com r r' r'' => r -> r' -> r''

-- | Semantic function of a terminal
sem_Lit :: a -> Record HNil -> a

-- | The function <a>knit</a> takes the combined rules for a node and the
--   semantic functions of the children, and builds a function from the
--   inherited attributes of the parent to its synthesized attributes.
knit :: (HLeftUnion fc ho fc', Kn fc' ic sc, Empties fc' ec) => Rule l ho sc ip (Record HNil) (Record HNil) ec (Record HNil) l ho ic sp -> fc -> ip -> sp
class SemType t nt | t -> nt

-- | A <i>copy</i> rule copies an inherited attribute from the parent to
--   all its children. The function <a>copy</a> takes the name of an
--   attribute <tt>att</tt> and an heterogeneous list of non-terminals
--   <tt>nts</tt> for which the attribute has to be defined, and generates
--   a copy rule for this.
copy :: (Copy att nts vp ic ic', HasField att ip vp) => att -> nts -> Rule lf hof sc ip l ho ic sp l ho ic' sp

-- | A <i>use</i> rule declares a synthesized attribute that collects
--   information from some of the children. The function <a>use</a> takes
--   the following arguments: the attribute to be defined, the list of
--   non-terminals for which the attribute is defined, a monoidal operator
--   which combines the attribute values, and a unit value to be used in
--   those cases where none of the children has such an attribute.
use :: (Use att nts a sc, HExtend (Att att a) sp sp') => att -> nts -> (a -> a -> a) -> a -> Rule lf hof sc ip l ho ic sp l ho ic sp'

-- | In the <i>chain</i> rule a value is threaded in a depth-first way
--   through the tree, being updated every now and then. For this we have
--   chained attributes (both inherited and synthesized). If a definition
--   for a synthesized attribute of the parent with this name is missing we
--   look for the right-most child with a synthesized attribute of this
--   name. If we are missing a definition for one of the children, we look
--   for the right-most of its left siblings which can provide such a
--   value, and if we cannot find it there, we look at the inherited
--   attributes of the father.
chain :: (Chain att nts val sc l ho ic sp ic' sp', HasField att ip val) => att -> nts -> Rule lf hof sc ip l ho ic sp l ho ic' sp'

-- | The function <a>inhAspect</a> defines an inherited attribute aspect.
--   It takes as arguments: the name of the attribute <tt>att</tt>, the
--   list <tt>nts</tt> of non-terminals where the attribute is defined, the
--   list <tt>cpys</tt> of productions where the copy rule has to be
--   applied, and a record <a>defs</a> containing the explicit definitions
--   for some productions.
inhAspect :: (AttAspect (FnInh att nts) defs defasp, DefAspect (FnCpy att nts) cpys cpyasp, Com cpyasp defasp inhasp) => att -> nts -> cpys -> defs -> inhasp

-- | The function <a>synAspect</a> defines a synthesized attribute aspect.
synAspect :: (AttAspect (FnSyn att) defs defasp, DefAspect (FnUse att nts op unit) uses useasp, Com useasp defasp synasp) => att -> nts -> op -> unit -> uses -> defs -> synasp

-- | A chained attribute definition introduces both an inherited and a
--   synthesized attribute. In this case the pattern to be applied is the
--   chain rule.
chnAspect :: (DefAspect (FnChn att nts) chns chnasp, AttAspect (FnInh att nts) inhdefs inhasp, Com chnasp inhasp asp, AttAspect (FnSyn att) syndefs synasp, Com asp synasp asp') => att -> nts -> chns -> inhdefs -> syndefs -> asp'
attAspect :: AttAspect rdef defs rules => rdef -> defs -> rules
defAspect :: DefAspect deff prds rules => deff -> prds -> rules

-- | The class <a>Defs</a> is defined by induction over the record
--   <tt>vals</tt> containing the new definitions. The function <a>defs</a>
--   inserts each definition into the attribution of the corresponding
--   child.
class Defs att nts vals ic ic' | vals ic -> ic'
defs :: Defs att nts vals ic ic' => att -> nts -> vals -> ic -> ic'
class ListNT nt tHd tTl where ch_hd = proxy ch_tl = proxy
ch_hd :: ListNT nt tHd tTl => Proxy (tHd, nt)
ch_tl :: ListNT nt tHd tTl => Proxy (tTl, [nt])
instance (RecordLabels r ls, HFind l ls n, HUpdateAtHNat n (LVPair l v) r r') => HUpdateAtLabel l v (Record r) (Record r')
instance HasLabel l HNil HFalse
instance (HEq l lp b, HasLabel l r b', HOr b b' b'') => HasLabel l (HCons (LVPair lp vp) r) b''
instance HasLabel l r b => HasLabel l (Record r) b
instance (Chain att nts val sc l ho ic sp ic' sp', HasLabel att sp msp, Chain' msp att nts val sc l ho ic sp ic' sp', HasField att ip val, TypeCast (Rule lf hof sc ip l ho ic sp l ho ic' sp') r) => Poly (FnChn att nts) r
instance (Use att nts a sc, HExtend (LVPair att a) sp sp', TypeCast (Rule lf hof sc ip l ho ic sp l ho ic sp') r) => Poly (FnUse att nts (a -> a -> a) a) r
instance (Copy att nts vp ic ic', HasField att ip vp, TypeCast (Rule lf hof sc ip l ho ic sp l ho ic' sp) r) => Poly (FnCpy att nts) r
instance (Poly deff deff', DefAspect deff prds rules, HExtend (Prd prd deff') rules rules') => DefAspect deff (HCons prd prds) rules'
instance DefAspect deff HNil (Record HNil)
instance Defs att nts vals ic ic' => Apply (FnInh att nts) (Fam lf hof sc ip -> vals) (Rule lf hof sc ip l ho ic sp l ho ic' sp)
instance HExtend (LVPair att val) sp sp' => Apply (FnSyn att) (Fam lf hof sc ip -> val) (Rule lf hof sc ip l ho ic sp l ho ic sp')
instance AttAspect rdef (Record HNil) (Record HNil)
instance (AttAspect rdef (Record defs) rules, Apply rdef def rule, HExtend (Prd lprd rule) rules rules') => AttAspect rdef (Record (HCons (Prd lprd def) defs)) rules'
instance (HasField att sch val, HExtend (Att att val) ich ich') => ChnChi'' HTrue HFalse att val (Chi lch sch) (Chi lch ich) (Chi lch ich')
instance HasField att sch val => ChnChi'' HTrue HTrue att val (Chi lch sch) ich ich
instance Fail (IncorrectDef att lch (UndefAtt att)) => ChnChi'' HFalse HFalse att val sch (Chi lch ich) ich'
instance Fail (IncorrectDef att lch (UndefAtt att)) => ChnChi'' HFalse HTrue att val sch (Chi lch ich) ich'
instance (HasLabel att sch msch, HasLabel att ich mich, ChnChi'' msch mich att val (Chi (Proxy (lch, t)) sch) (Chi (Proxy (lch, t)) ich) pch) => ChnChi' HTrue att val (Chi (Proxy (lch, t)) sch) (Chi (Proxy (lch, t)) ich) pch
instance ChnChi' HFalse att val sch ich ich
instance (ChnChi att nts val (Record scs) (Record ics) ics', HMember (Proxy t) nts mnts, ChnChi' mnts att val (Chi (Proxy (lch, t)) sch) (Chi (Proxy (lch, t)) ich) pch, HExtend pch ics' ic) => ChnChi att nts val (Record (HCons (Chi (Proxy (lch, t)) sch) scs)) (Record (HCons (Chi (Proxy (lch, t)) ich) ics)) ic
instance ChnChi att nts val (Record HNil) (Record HNil) (Record HNil)
instance ChnChi att nts val sc ic ic' => Chain' HTrue att nts val sc l ho ic sp ic' sp
instance (ChnChi att nts val sc ic ic', HExtend (Att att val) sp sp') => Chain' HFalse att nts val sc l ho ic sp ic' sp'
instance (Chain' msp att nts val sc l ho ic sp ic' sp', HasLabel att sp msp) => Chain att nts val sc l ho ic sp ic' sp'
instance Use att nts a scr => Use' HFalse att nts a (HCons (LVPair lch b) scr)
instance (HasField att (Record vch) a, Use att nts a scr) => Use' HTrue att nts a (HCons (LVPair lch (Record vch)) scr)
instance (HMember (Proxy t) nts mnts, Use' mnts att nts a (HCons (LVPair (Proxy (lch, t)) vch) scr)) => Use att nts a (HCons (LVPair (Proxy (lch, t)) vch) scr)
instance Use l nt a HNil
instance Use att nts a sc => Use att nts a (Record sc)
instance HExtend (Att att vp) vch vch' => Copy' HTrue HFalse att vp (Chi lch vch) (Chi lch vch')
instance Copy' HTrue HTrue att vp pch pch
instance Copy' HFalse mvch att vp pch pch
instance (Copy att nts vp (Record ics) ics', HMember (Proxy t) nts mnts, HasLabel att vch mvch, Copy' mnts mvch att vp (Chi (Proxy (lch, t)) vch) pch, HExtend pch ics' ic) => Copy att nts vp (Record (HCons (Chi (Proxy (lch, t)) vch) ics)) ic
instance Copy att nts vp (Record HNil) (Record HNil)
instance Empties HNil HNil
instance Empties fcr ecr => Empties (HCons (Chi lch fch) fcr) (HCons (Chi lch (Record HNil)) ecr)
instance Empties fc ec => Empties (Record fc) (Record ec)
instance Kn fcr icr scr => Kn (HCons (Chi lch (ich -> sch)) fcr) (HCons (Chi lch ich) icr) (HCons (Chi lch sch) scr)
instance Kn HNil HNil HNil
instance Kn fc ic sc => Kn (Record fc) (Record ic) (Record sc)
instance ComSingle HFalse f (Record r) (Record (HCons f r))
instance (HasField lprd r (Rule lf hof sc ip l' ho' ic' sp' l'' ho'' ic'' sp''), HUpdateAtLabel lprd (Rule lf hof sc ip l ho ic sp l'' ho'' ic'' sp'') r r') => ComSingle HTrue (Prd lprd (Rule lf hof sc ip l ho ic sp l' ho' ic' sp')) r r'
instance (HasLabel lprd r b, ComSingle b (Prd lprd rprd) r r''', Com r''' (Record r') r'') => Com r (Record (HCons (Prd lprd rprd) r')) r''
instance Com r (Record HNil) r
instance MonadReader (Fam l ho chi par) m => At (chi -> v) m v
instance MonadReader (Fam l ho chi par) m => At (Proxy Loc) m l
instance MonadReader (Fam l ho chi par) m => At (Proxy Lhs) m par
instance (HasField (Proxy (lch, nt)) chi v, MonadReader (Fam l ho chi par) m) => At (Proxy (lch, nt)) m v
instance (MapRL s (Record r) (Record r'), HRLabelSet (HCons (LVPair lr' v) r'), HasField lr r v) => MapRL (HCons (LVPair lr' lr) s) (Record r) (Record (HCons (LVPair lr' v) r'))
instance MapRL HNil r (Record HNil)
instance MapRL l r r' => MapRL (Record l) r r'
instance MapLRB HTrue (LVPair lr lr') (Record r) (Record r') (Record r')
instance (HRLabelSet (HCons (LVPair lr' v) r'), HasField lr r v) => MapLRB HFalse (LVPair lr lr') (Record r) (Record r') (Record (HCons (LVPair lr' v) r'))
instance (MapLR s (Record r) (Record r'), RecordLabels r' ls, HMember lr' ls b, MapLRB b (LVPair lr lr') (Record r) (Record r') (Record r'')) => MapLR (HCons (LVPair lr lr') s) (Record r) (Record r'')
instance MapLR HNil r (Record HNil)
instance MapLR l r r' => MapLR (Record l) r r'
instance (RenRL s (Record r') (Record r''), HRLabelSet (HCons (LVPair lr' v) r''), HasField lr r v, H2ProjectByLabels (HCons lr HNil) r t r') => RenRL (HCons (LVPair lr' lr) s) (Record r) (Record (HCons (LVPair lr' v) r''))
instance RenRL HNil r r
instance (RenLR s (Record r') (Record r''), HRLabelSet (HCons (LVPair lr' v) r''), HasField lr r v, H2ProjectByLabels (HCons lr HNil) r t r') => RenLR (HCons (LVPair lr lr') s) (Record r) (Record (HCons (LVPair lr' v) r''))
instance RenLR HNil r r
instance (HasField lch ic och, HasField att och vch, HUpdateAtLabel att vch' och och', HUpdateAtLabel lch och' ic ic') => SingleUpd HTrue HTrue att (Chi lch (vch -> vch')) ic ic'
instance Fail (IncorrectUpd l lch (UndefProd (lch, t))) => SingleUpd HFalse HTrue (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance Fail (IncorrectUpd l lch (UndefNT t)) => SingleUpd HTrue HFalse (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance (Upds att nts (Record vs) ic ic', HasLabel (Proxy (lch, t)) ic' mch, HMember (Proxy t) nts mnts, SingleUpd mch mnts att (Chi (Proxy (lch, t)) vch) ic' ic'') => Upds att nts (Record (HCons (Chi (Proxy (lch, t)) vch) vs)) ic ic''
instance Upds att nts (Record HNil) ic ic
instance (HasField lch ic och, HUpdateAtLabel att vch och och', HUpdateAtLabel lch och' ic ic') => SingleMod HTrue HTrue att (Chi lch vch) ic ic'
instance Fail (IncorrectMod l lch (UndefProd (lch, t))) => SingleMod HFalse HTrue (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance Fail (IncorrectMod l lch (UndefNT t)) => SingleMod HTrue HFalse (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance (Mods att nts (Record vs) ic ic', HasLabel (Proxy (lch, t)) ic' mch, HMember (Proxy t) nts mnts, SingleMod mch mnts att (Chi (Proxy (lch, t)) vch) ic' ic'') => Mods att nts (Record (HCons (Chi (Proxy (lch, t)) vch) vs)) ic ic''
instance Mods att nts (Record HNil) ic ic
instance (HasField lch ic och, HExtend (Att att vch) och och', HUpdateAtLabel lch och' ic ic') => SingleDef HTrue HTrue att (Chi lch vch) ic ic'
instance Fail (IncorrectDef l lch (UndefProd (lch, t))) => SingleDef HFalse HTrue (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance Fail (IncorrectDef l lch (UndefNT t)) => SingleDef HTrue HFalse (Proxy l) (LVPair (Proxy (lch, t)) c) r r'
instance (Defs att nts (Record vs) ic ic', HasLabel (Proxy (lch, t)) ic' mch, HMember (Proxy t) nts mnts, SingleDef mch mnts att (Chi (Proxy (lch, t)) vch) ic' ic'') => Defs att nts (Record (HCons (Chi (Proxy (lch, t)) vch) vs)) ic ic''
instance Defs att nts (Record HNil) ic ic

module Language.Grammars.AspectAG.Derive
deriveAG :: Name -> Q [Dec]
extendAG :: Name -> [Name] -> Q [Dec]
deriveLang :: String -> [Name] -> Q [Dec]
addNT :: String -> Q [Dec]
addProd :: String -> [(String, Name)] -> Q [Dec]
attLabel :: String -> Q [Dec]
attLabels :: [String] -> Q [Dec]
chLabel :: String -> Name -> Q [Dec]
chLabels :: [String] -> Name -> Q [Dec]
