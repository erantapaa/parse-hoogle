-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A quasi quotes for using Egison expression in Haskell code
--   
--   A quasi quotes for using Egison expression in Haskell code. Egison is
--   a purely functional language featured strong pattern matching faculty.
--   This package enable us to use (restricted) Egison expression in
--   Haskell source code.
@package egison-quote
@version 0.2


-- | The quasi quotes for egison expression
module Language.Egison.Quote

-- | QuasiQuoter for egison expression
--   
--   The format is:
--   
--   <pre>
--   expr := [egison | &lt;egison-expression&gt; :: &lt;type-signature&gt; |]
--   </pre>
--   
--   For example, with Egison pattern matching, <i>powerset function</i>
--   can be expressed easily as follows.
--   
--   <pre>
--   &gt;&gt;&gt; [egison|(lambda [$l] (match-all l (Multiset Integer) [&lt;join $l _&gt; l])) :: [Int] -&gt; [[Int]]|] [1..3]
--   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
--   </pre>
--   
--   Type signature is defined as follows
--   
--   <pre>
--   &lt;Typ&gt; = Bool | Int | Double | Float | Char | String | [&lt;Typ&gt;] | (&lt;Typ&gt;, &lt;Typ&gt;, ..., &lt;Typ&gt;) | &lt;Typ&gt; -&gt; &lt;Typ&gt; -&gt; ... &lt;Typ&gt;
--   </pre>
--   
--   Embedded Egison expression is run-time evaluated by using <a>eval</a>
--   and <a>unsafePerformIO</a>. For more detailed usage, please refer to
--   <a>https://github.com/xenophobia/Egison-Quote</a>.
egison :: QuasiQuoter

-- | Parser for TypeSignature
parseType :: Parser Type

-- | Pick up antiquoted variables and delete notation <tt>#{~}</tt>
--   
--   <pre>
--   "(+ #{x} y)"  ---&gt; ([x], "(+ x y)")
--   </pre>
pickupAntiquote :: String -> ([String], String)

-- | Parser for <a>pickupAntiquote</a>
parseAntiquote :: Parser ([String], String)

-- | Parser for egison-quote
parseQuote :: Parser (EgisonExpr, Type)

-- | Read function for egison-quote
readQuote :: String -> ThrowsError (EgisonExpr, Type)

-- | construct Exp from Egison-expression and type signature
toHaskellExp :: EgisonExpr -> [String] -> Type -> ExpQ
evalEgisonTopLevel :: EgisonExpr -> [String] -> [ExpQ] -> ExpQ
instance [incoherent] Lift EgisonExpr
instance [incoherent] Lift Args
instance [incoherent] Lift ArrayElementExpr
instance [incoherent] Lift InnerExpr
instance [incoherent] (IsEgisonExpr a, IsEgisonExpr b, IsEgisonExpr c, IsEgisonExpr d) => IsEgisonExpr (a, b, c, d)
instance [incoherent] (IsEgisonExpr a, IsEgisonExpr b, IsEgisonExpr c) => IsEgisonExpr (a, b, c)
instance [incoherent] (IsEgisonExpr a, IsEgisonExpr b) => IsEgisonExpr (a, b)
instance [incoherent] IsEgisonExpr a => IsEgisonExpr [a]
instance [incoherent] IsEgisonExpr String
instance [incoherent] IsEgisonExpr Double
instance [incoherent] IsEgisonExpr Float
instance [incoherent] IsEgisonExpr Bool
instance [incoherent] IsEgisonExpr Char
instance [incoherent] IsEgisonExpr Integer
instance [incoherent] IsEgisonExpr Int
