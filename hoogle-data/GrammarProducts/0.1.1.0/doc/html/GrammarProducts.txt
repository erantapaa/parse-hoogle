-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Grammar products and higher-dimensional grammars
--   
@package GrammarProducts
@version 0.1.1.0

module FormalLanguage.GrammarProduct.Op.Common

-- | Collect all terminal symbols from a set of rules.
--   
--   TODO move to FormalGrammars library
--   
--   TODO i guess, this collects multidim stuff for now!!!
collectTerminals :: Set Rule -> Set Symbol

-- | Collect all non-terminal symbols from a set of rules.
--   
--   TODO move to FormalGrammars library
collectNonTerminals :: Set Rule -> Set Symbol

-- | TODO not needed anymore ?!
collectEpsilons :: Set Rule -> Set SynTermEps

-- | Generate a multidim epsilon symbol of the same length as the given
--   symbol.
genEps :: Symbol -> Symbol

-- | Generate a multidim <tt>Deletion</tt> symbol of the same length as the
--   given symbol.
genDel :: Symbol -> Symbol

-- | Checks if two grammars are compatible.
--   
--   TODO different inside/outside status might not be a big problem!
opCompatible :: Grammar -> Grammar -> Either String ()

module FormalLanguage.GrammarProduct.Op.Power
power :: Grammar -> Integer -> Grammar

module FormalLanguage.GrammarProduct.Op.Subtract

-- | Subtract two grammars.
subtract :: Grammar -> Grammar -> Grammar

module FormalLanguage.GrammarProduct.Op.Add
add :: Grammar -> Grammar -> Grammar

-- | Add two grammars. Implemented as the union of production rules without
--   any renaming.
newtype Add a
Add :: a -> Add a
runAdd :: Add a -> a

-- | Note that the semigroup on Add will create a new rule S_gh -&gt; S_g |
--   S_h in case two start symbols with different rhs exist (If S_g, S_h
--   are the same, there is no problem).
instance Monoid (Add Grammar)
instance Semigroup (Add Grammar)


-- | Direct product of two grammars.
--   
--   Currently implemented for linear grammars. Once we move to
--   context-free grammars with more than one non-terminal on the RHS,
--   things become interesting.
module FormalLanguage.GrammarProduct.Op.Linear
directProduct :: Semigroup (Linear a) => a -> a -> a
newtype Linear a
Linear :: a -> Linear a
runLinear :: Linear a -> a

-- | Merges right-hand sides in a linear direct product. For full-fledged
--   CFGs in different normal forms, see the GNF and CNF implementations.
mergeRHS :: [Symbol] -> [Symbol] -> [Symbol]
groupRHS :: [Symbol] -> [[Symbol]]
instance Monoid (Linear Grammar)
instance Semigroup (Linear Grammar)

module FormalLanguage.GrammarProduct.Op.Chomsky

module FormalLanguage.GrammarProduct.Op.Chomsky.Proof

module FormalLanguage.GrammarProduct.Op.Greibach

module FormalLanguage.GrammarProduct.Op.Greibach.Proof

module FormalLanguage.GrammarProduct.Op
gAdd :: Monoid (Add a) => a -> a -> a
gSubtract :: Grammar -> Grammar -> Grammar
gPower :: Grammar -> Integer -> Grammar

-- | The product of two grammars.
--   
--   In general, it is quite hard to define the product of two context-free
--   grammars in a way that keeps associativity and also "does what we want
--   it to do" (see paper). For linear grammars it is much easier. Also,
--   for grammars in certain normal forms, a simpler definition is
--   possible. Due to this, we make the choice of the actual way on how to
--   multiply based on the type of grammars given. This, however, should
--   only affect the resulting rules, not the (multi-tape) language that
--   the operations yields.
--   
--   TODO I think, left-linear could reasonably be expanded to both, left-
--   and right-linear and maybe linear in general.
--   
--   NOTE A proof for associativity is possible, but generally hard, so we
--   prefer to let the framework perform the proof for us.
(><) :: Grammar -> Grammar -> Grammar

-- | The addition operation defined for two grammars of the same dimension.
--   It forms a monoid under the <a>Add</a> newtype.
(.+) :: Grammar -> Grammar -> Grammar


-- | This parser extends the <tt>FormalLanguage.Parser</tt> parser of
--   single- and multi-dim grammars to accept grammar product definitions
--   as well.
--   
--   TODO display function names like this: <a>fun,fun,fun</a>
module FormalLanguage.GrammarProduct.Parser

-- | The top-level parser for a grammar product. It can be used as one of
--   the additional parser arguments, the formal grammars parser accepts.
parseGrammarProduct :: Parse m ()

-- | Performs the actual parsing of a product string. Uses an expression
--   parser internally.
parseProductString :: Parse m Grammar
data ExprGrammar
ExprGrammar :: Grammar -> ExprGrammar
getGrammar :: ExprGrammar -> Grammar
ExprNumber :: Integer -> ExprGrammar
getNumber :: ExprGrammar -> Integer

module FormalLanguage.GrammarProduct.QQ
grammarProductF :: QuasiQuoter
grammarProduct :: QuasiQuoter


-- | This module contains the top-level functionality required to define
--   "products of grammars" (or more sloppily "how to multiply dynamic
--   programming algorithms"). Some operators (like '(&gt;&lt;)') will
--   check if both grammars are compatible with the operation and fail if
--   not.
--   
--   TODO Later on we probably will be able to multiply without
--   restrictions.
module FormalLanguage.GrammarProduct
