-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fork of resource-pool, with a MonadCatchIO constraint
--   
--   This is a fork of Bryan O<a>Sullivan</a>s resource-pool package. The
--   only difference is that it relies on MonadCatchIO, rather than
--   MonadControlIO. If you do not strictly need the MonadCatchIO support,
--   please use Bryan's original package instead. A high-performance
--   striped pooling abstraction for managing flexibly-sized collections of
--   resources such as database connections.
@package resource-pool-catchio
@version 0.2.1.0


-- | A high-performance striped pooling abstraction for managing
--   flexibly-sized collections of resources such as database connections.
--   
--   "Striped" means that a single <a>Pool</a> consists of several
--   sub-pools, each managed independently. A stripe size of 1 is fine for
--   many applications, and probably what you should choose by default.
--   Larger stripe sizes will lead to reduced contention in
--   high-performance multicore applications, at a trade-off of causing the
--   maximum number of simultaneous resources in use to grow.
module Data.Pool
data Pool a

-- | A single striped pool.
data LocalPool a
createPool :: IO a -> (a -> IO ()) -> Int -> NominalDiffTime -> Int -> IO (Pool a)

-- | Temporarily take a resource from a <a>Pool</a>, perform an action with
--   it, and return it to the pool afterwards.
--   
--   <ul>
--   <li>If the pool has an idle resource available, it is used
--   immediately.</li>
--   <li>Otherwise, if the maximum number of resources has not yet been
--   reached, a new resource is created and used.</li>
--   <li>If the maximum number of resources has been reached, this function
--   blocks until a resource becomes available.</li>
--   </ul>
--   
--   If the action throws an exception of any type, the resource is
--   destroyed, and not returned to the pool.
--   
--   It probably goes without saying that you should never manually destroy
--   a pooled resource, as doing so will almost certainly cause a
--   subsequent user (who expects the resource to be valid) to throw an
--   exception.
withResource :: MonadCatchIO m => Pool a -> (a -> m b) -> m b

-- | Take a resource from the pool, following the same results as
--   <a>withResource</a>. Note that this function should be used with
--   caution, as improper exception handling can lead to leaked resources.
--   
--   This function returns both a resource and the <tt>LocalPool</tt> it
--   came from so that it may either be destroyed (via
--   <a>destroyResource</a>) or returned to the pool (via
--   <a>putResource</a>).
takeResource :: Pool a -> IO (a, LocalPool a)

-- | Destroy a resource. Note that this will ignore any exceptions in the
--   destroy function.
destroyResource :: Pool a -> LocalPool a -> a -> IO ()

-- | Return a resource to the given <a>LocalPool</a>.
putResource :: LocalPool a -> a -> IO ()
instance Show (Pool a)
