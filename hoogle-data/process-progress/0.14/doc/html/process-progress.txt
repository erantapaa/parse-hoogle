-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Run a process and do reportsing on its progress.
--   
--   Function to run a process and wrappers to provide different types of
--   feedback while it executes.
@package process-progress
@version 0.14

module System.Process.Read.Convenience
isResult :: ListLikePlus a c => Chunk a -> Bool
isStdout :: ListLikePlus a c => Chunk a -> Bool
isStderr :: ListLikePlus a c => Chunk a -> Bool
isOutput :: ListLikePlus a c => Chunk a -> Bool
isException :: ListLikePlus a c => Chunk a -> Bool
isHandle :: ListLikePlus a c => Chunk a -> Bool
discardStdout :: ListLikePlus a c => [Chunk a] -> [Chunk a]
discardStderr :: ListLikePlus a c => [Chunk a] -> [Chunk a]
discardOutput :: ListLikePlus a c => [Chunk a] -> [Chunk a]
discardExceptions :: ListLikePlus a c => [Chunk a] -> [Chunk a]
discardResult :: ListLikePlus a c => [Chunk a] -> [Chunk a]
keepStdout :: ListLikePlus a c => [Chunk a] -> [a]
keepStderr :: ListLikePlus a c => [Chunk a] -> [a]
keepOutput :: ListLikePlus a c => [Chunk a] -> [a]
keepExceptions :: ListLikePlus a c => [Chunk a] -> [IOError]
keepResult :: ListLikePlus a c => [Chunk a] -> [ExitCode]
mergeToStdout :: ListLikePlus a c => [Chunk a] -> [Chunk a]
mergeToStderr :: ListLikePlus a c => [Chunk a] -> [Chunk a]
mapMaybeResult :: ListLikePlus a c => (ExitCode -> Maybe (Chunk a)) -> [Chunk a] -> [Chunk a]
mapMaybeStdout :: ListLikePlus a c => (a -> Maybe (Chunk a)) -> [Chunk a] -> [Chunk a]
mapMaybeStderr :: ListLikePlus a c => (a -> Maybe (Chunk a)) -> [Chunk a] -> [Chunk a]
mapMaybeException :: ListLikePlus a c => (IOError -> Maybe (Chunk a)) -> [Chunk a] -> [Chunk a]
collectOutputs :: ListLikePlus a c => [Chunk a] -> ([ExitCode], a, a, [IOError])
ePutStr :: MonadIO m => String -> m ()
ePutStrLn :: MonadIO m => String -> m ()
eMessage :: MonadIO m => String -> a -> m a
eMessageLn :: MonadIO m => String -> a -> m a
foldException :: ListLikePlus a c => (IOError -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldChars :: ListLikePlus a c => (a -> IO (Chunk a)) -> (a -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldStdout :: ListLikePlus a c => (a -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldStderr :: ListLikePlus a c => (a -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldResult :: ListLikePlus a c => (ExitCode -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldSuccess :: ListLikePlus a c => IO (Chunk a) -> [Chunk a] -> IO [Chunk a]
foldFailure :: ListLikePlus a c => (Int -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
foldFailure' :: ListLikePlus a c => (Int -> IO (Chunk a)) -> [Chunk a] -> IO [Chunk a]
doException :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]
doOutput :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]
doStdout :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]
doStderr :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]

-- | I don't see much use for this.
doExit :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]
doAll :: ListLikePlus a c => [Chunk a] -> IO [Chunk a]
dots :: (ListLikePlus a c, c ~ Char) => Int -> [Chunk a] -> IO [Chunk a]

-- | Output the stream with a prefix added at the beginning of each line of
--   stdout and stderr.
prefixed :: (Enum c, ListLikePlus a c) => a -> a -> [Chunk a] -> IO [Chunk a]


-- | Some functions brought over from my obsolete progress packages.
module System.Process.Read.Compat

-- | Output a description of a command and then run it.
echo :: CmdSpec -> IO () -> IO ()

-- | Extract the result code of an output stream, throw an error if there
--   isn't exactly one of them.
oneResult :: ListLikePlus a c => [Chunk a] -> ExitCode

-- | Run a task and return the elapsed time along with its result.
timeTask :: IO a -> IO (a, NominalDiffTime)


-- | A perhaps over-engineered set of wrappers around readProcessChunks to
--   run processes with a variety of echoing options and responses to
--   failure.
module System.Process.Read.Monad

-- | Run silently
runProcessS :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Command line trace only.
runProcessQ :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Dot output
runProcessD :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Echo output
runProcessV :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Exception on failure
runProcessSF :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]
runProcessQF :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Dot output and exception on failure
runProcessDF :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Echo output and exception on failure
runProcessVF :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => CreateProcess -> a -> m [Chunk a]

-- | Exception and echo on failure
runProcessSE :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => Maybe (a, a) -> CreateProcess -> a -> m [Chunk a]

-- | Exception and echo on failure
runProcessQE :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => Maybe (a, a) -> CreateProcess -> a -> m [Chunk a]

-- | Dot output, exception on failure, echo on failure. Note that
--   runProcessVE isn't a useful option, you get the output twice. VF makes
--   more sense.
runProcessDE :: (ListLikePlus a c, Enum c, MonadIO m, c ~ Word8) => Maybe (a, a) -> CreateProcess -> a -> m [Chunk a]
instance Show s => Show (RunState s)


-- | `Functions to run a process and manage the type and amount of output
--   it generates.
module System.Process.Progress

module System.Posix.EnvPlus

-- | Generalization of Posix setEnv/unSetEnv.
modifyEnv :: String -> (Maybe String -> Maybe String) -> IO ()
