-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extract the heap representation of Haskell values and thunks
--   
@package ghc-heap-view
@version 0.5.4


-- | A disassembler for ByteCode objects as used by GHCi.
module GHC.Disassembler

-- | Converts the first <tt>n</tt> bytes of this list of Words to a
--   ByteString.
toBytes :: Word -> [Word] -> ByteString

-- | Given a list of pointers, a list of literals and a ByteString
--   containing byte code instructions, disassembles them into a list of
--   byte code instructions.
disassemble :: [box] -> [Word] -> ByteString -> [BCI box]

-- | The various byte code instructions that GHCi supports.
data BCI box
BCISTKCHECK :: Word -> BCI box
BCIPUSH_L :: Word16 -> BCI box
BCIPUSH_LL :: Word16 -> Word16 -> BCI box
BCIPUSH_LLL :: Word16 -> Word16 -> Word16 -> BCI box
BCIPUSH_G :: box -> BCI box
BCIPUSH_ALTS :: box -> BCI box
BCIPUSH_ALTS_P :: box -> BCI box
BCIPUSH_ALTS_N :: box -> BCI box
BCIPUSH_ALTS_F :: box -> BCI box
BCIPUSH_ALTS_D :: box -> BCI box
BCIPUSH_ALTS_L :: box -> BCI box
BCIPUSH_ALTS_V :: box -> BCI box
BCIPUSH_UBX :: [Word] -> BCI box
BCIPUSH_APPLY_N :: BCI box
BCIPUSH_APPLY_F :: BCI box
BCIPUSH_APPLY_D :: BCI box
BCIPUSH_APPLY_L :: BCI box
BCIPUSH_APPLY_V :: BCI box
BCIPUSH_APPLY_P :: BCI box
BCIPUSH_APPLY_PP :: BCI box
BCIPUSH_APPLY_PPP :: BCI box
BCIPUSH_APPLY_PPPP :: BCI box
BCIPUSH_APPLY_PPPPP :: BCI box
BCIPUSH_APPLY_PPPPPP :: BCI box
BCISLIDE :: Word16 -> Word16 -> BCI box
BCIALLOC_AP :: Word16 -> BCI box
BCIALLOC_AP_NOUPD :: Word16 -> BCI box
BCIALLOC_PAP :: Word16 -> Word16 -> BCI box
BCIMKAP :: Word16 -> Word16 -> BCI box
BCIMKPAP :: Word16 -> Word16 -> BCI box
BCIUNPACK :: Word16 -> BCI box
BCIPACK :: Word -> Word16 -> BCI box
BCITESTLT_I :: Int -> Int -> BCI box
BCITESTEQ_I :: Int -> Int -> BCI box
BCITESTLT_F :: Word -> Int -> BCI box
BCITESTEQ_F :: Word -> Int -> BCI box
BCITESTLT_D :: Word -> Int -> BCI box
BCITESTEQ_D :: Word -> Int -> BCI box
BCITESTLT_P :: Word16 -> Int -> BCI box
BCITESTEQ_P :: Word16 -> Int -> BCI box
BCICASEFAIL :: BCI box
BCIJMP :: BCI box
BCICCALL :: Word -> BCI box
BCISWIZZLE :: Word16 -> Int16 -> BCI box
BCIENTER :: BCI box
BCIRETURN :: BCI box
BCIRETURN_P :: BCI box
BCIRETURN_N :: BCI box
BCIRETURN_F :: BCI box
BCIRETURN_D :: BCI box
BCIRETURN_L :: BCI box
BCIRETURN_V :: BCI box

-- | We do not parse this opcode's arguments
BCIBRK_FUN :: BCI box
BCITESTLT_W :: Word -> Int -> BCI box
BCITESTEQ_W :: Word -> Int -> BCI box
instance Show box => Show (BCI box)
instance Functor BCI
instance Traversable BCI
instance Foldable BCI


-- | With this module, you can investigate the heap representation of
--   Haskell values, i.e. to investigate sharing and lazy evaluation.
module GHC.HeapView

-- | This is the main data type of this module, representing a Haskell
--   value on the heap. This reflects
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by the type to store references in,
--   which is usually a <a>Box</a> with appropriate type synonym
--   <a>Closure</a>.
data GenClosure b
ConsClosure :: StgInfoTable -> [b] -> [Word] -> String -> String -> String -> GenClosure b
info :: GenClosure b -> StgInfoTable
ptrArgs :: GenClosure b -> [b]
dataArgs :: GenClosure b -> [Word]
pkg :: GenClosure b -> String
modl :: GenClosure b -> String
name :: GenClosure b -> String
ThunkClosure :: StgInfoTable -> [b] -> [Word] -> GenClosure b
info :: GenClosure b -> StgInfoTable
ptrArgs :: GenClosure b -> [b]
dataArgs :: GenClosure b -> [Word]
SelectorClosure :: StgInfoTable -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
selectee :: GenClosure b -> b
IndClosure :: StgInfoTable -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
indirectee :: GenClosure b -> b
BlackholeClosure :: StgInfoTable -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
indirectee :: GenClosure b -> b
APClosure :: StgInfoTable -> HalfWord -> HalfWord -> b -> [b] -> GenClosure b
info :: GenClosure b -> StgInfoTable
arity :: GenClosure b -> HalfWord
n_args :: GenClosure b -> HalfWord
fun :: GenClosure b -> b
payload :: GenClosure b -> [b]
PAPClosure :: StgInfoTable -> HalfWord -> HalfWord -> b -> [b] -> GenClosure b
info :: GenClosure b -> StgInfoTable
arity :: GenClosure b -> HalfWord
n_args :: GenClosure b -> HalfWord
fun :: GenClosure b -> b
payload :: GenClosure b -> [b]
APStackClosure :: StgInfoTable -> b -> [b] -> GenClosure b
info :: GenClosure b -> StgInfoTable
fun :: GenClosure b -> b
payload :: GenClosure b -> [b]
BCOClosure :: StgInfoTable -> b -> b -> b -> HalfWord -> HalfWord -> Word -> GenClosure b
info :: GenClosure b -> StgInfoTable
instrs :: GenClosure b -> b
literals :: GenClosure b -> b
bcoptrs :: GenClosure b -> b
arity :: GenClosure b -> HalfWord
size :: GenClosure b -> HalfWord
bitmap :: GenClosure b -> Word
ArrWordsClosure :: StgInfoTable -> Word -> [Word] -> GenClosure b
info :: GenClosure b -> StgInfoTable
bytes :: GenClosure b -> Word
arrWords :: GenClosure b -> [Word]
MutArrClosure :: StgInfoTable -> Word -> Word -> [b] -> GenClosure b
info :: GenClosure b -> StgInfoTable
mccPtrs :: GenClosure b -> Word
mccSize :: GenClosure b -> Word
mccPayload :: GenClosure b -> [b]
MutVarClosure :: StgInfoTable -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
var :: GenClosure b -> b
MVarClosure :: StgInfoTable -> b -> b -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
queueHead :: GenClosure b -> b
queueTail :: GenClosure b -> b
value :: GenClosure b -> b
FunClosure :: StgInfoTable -> [b] -> [Word] -> GenClosure b
info :: GenClosure b -> StgInfoTable
ptrArgs :: GenClosure b -> [b]
dataArgs :: GenClosure b -> [Word]
BlockingQueueClosure :: StgInfoTable -> b -> b -> b -> b -> GenClosure b
info :: GenClosure b -> StgInfoTable
link :: GenClosure b -> b
blackHole :: GenClosure b -> b
owner :: GenClosure b -> b
queue :: GenClosure b -> b
OtherClosure :: StgInfoTable -> [b] -> [Word] -> GenClosure b
info :: GenClosure b -> StgInfoTable
hvalues :: GenClosure b -> [b]
rawWords :: GenClosure b -> [Word]
UnsupportedClosure :: StgInfoTable -> GenClosure b
info :: GenClosure b -> StgInfoTable
type Closure = GenClosure Box

-- | For generic code, this function returns all referenced closures.
allPtrs :: GenClosure b -> [b]

-- | A closure type enumeration, in order matching the actual value on the
--   heap. Needs to be synchronized with
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/ClosureTypes.h</a>
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_STATIC :: ClosureType
CONSTR_NOCAF_STATIC :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_PERM :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN0 :: ClosureType
MUT_ARR_PTRS_FROZEN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType

-- | This is a somewhat faithful representation of an info table. See
--   <a>http://hackage.haskell.org/trac/ghc/browser/includes/rts/storage/InfoTables.h</a>
--   for more details on this data structure. Note that the <a>Storable</a>
--   instance provided here does _not_ support writing.
data StgInfoTable
StgInfoTable :: HalfWord -> HalfWord -> ClosureType -> HalfWord -> StgInfoTable
ptrs :: StgInfoTable -> HalfWord
nptrs :: StgInfoTable -> HalfWord
tipe :: StgInfoTable -> ClosureType
srtlen :: StgInfoTable -> HalfWord
type HalfWord = Word32

-- | This function returns parsed heap representation of the argument _at
--   this moment_, even if it is unevaluated or an indirection or other
--   exotic stuff. Beware when passing something to this function, the same
--   caveats as for <a>asBox</a> apply.
getClosureData :: a -> IO Closure

-- | Like <a>getClosureData</a>, but taking a <a>Box</a>, so it is easier
--   to work with.
getBoxedClosureData :: Box -> IO Closure

-- | This returns the raw representation of the given argument. The second
--   component of the triple are the words on the heap, and the third
--   component are those words that are actually pointers. Once back in
--   Haskell word, the <a>Word</a> may be outdated after a garbage
--   collector run, but the corresponding <a>Box</a> will still point to
--   the correct value.
getClosureRaw :: a -> IO (Ptr StgInfoTable, [Word], [Box])

-- | A pretty-printer that tries to generate valid Haskell for evalutated
--   data. It assumes that for the included boxes, you already replaced
--   them by Strings using <a>map</a> or, if you need to do IO,
--   <a>mapM</a>.
--   
--   The parameter gives the precedendence, to avoid avoidable
--   parenthesises.
ppClosure :: (Int -> b -> String) -> Int -> GenClosure b -> String

-- | Heap maps as tree, i.e. no sharing, no cycles.
data HeapTree
HeapTree :: Box -> (GenClosure HeapTree) -> HeapTree
EndOfHeapTree :: HeapTree

-- | Constructing an <a>HeapTree</a> from a boxed value. It takes a depth
--   parameter that prevents it from running ad infinitum for cyclic or
--   infinite structures.
buildHeapTree :: Int -> Box -> IO HeapTree

-- | Pretty-Printing a heap Tree
--   
--   Example output for <tt>[Just 4, Nothing, *something*]</tt>, where
--   *something* is an unevaluated expression depending on the command line
--   argument.
--   
--   <pre>
--   [Just (I# 4),Nothing,Just (_thunk ["arg1","arg2"])]
--   </pre>
ppHeapTree :: HeapTree -> String

-- | For heap graphs, i.e. data structures that also represent sharing and
--   cyclic structures, these are the entries. If the referenced value is
--   <tt>Nothing</tt>, then we do not have that value in the map, most
--   likely due to exceeding the recursion bound passed to
--   <a>buildHeapGraph</a>.
--   
--   Besides a pointer to the stored value and the closure representation
--   we also keep track of whether the value was still alive at the last
--   update of the heap graph. In addition we have a slot for arbitrary
--   data, for the user's convenience.
data HeapGraphEntry a
HeapGraphEntry :: Box -> GenClosure (Maybe HeapGraphIndex) -> Bool -> a -> HeapGraphEntry a
hgeBox :: HeapGraphEntry a -> Box
hgeClosure :: HeapGraphEntry a -> GenClosure (Maybe HeapGraphIndex)
hgeLive :: HeapGraphEntry a -> Bool
hgeData :: HeapGraphEntry a -> a
type HeapGraphIndex = Int

-- | The whole graph. The suggested interface is to only use
--   <a>lookupHeapGraph</a>, as the internal representation may change.
--   Nevertheless, we export it here: Sometimes the user knows better what
--   he needs than we do.
newtype HeapGraph a
HeapGraph :: (IntMap (HeapGraphEntry a)) -> HeapGraph a
lookupHeapGraph :: HeapGraphIndex -> (HeapGraph a) -> Maybe (HeapGraphEntry a)
heapGraphRoot :: HeapGraphIndex

-- | Creates a <a>HeapGraph</a> for the value in the box, but not recursing
--   further than the given limit. The initial value has index
--   <a>heapGraphRoot</a>.
buildHeapGraph :: Monoid a => Int -> a -> Box -> IO (HeapGraph a)

-- | Creates a <a>HeapGraph</a> for the values in multiple boxes, but not
--   recursing further than the given limit.
--   
--   Returns the <a>HeapGraph</a> and the indices of initial values. The
--   arbitrary type <tt>a</tt> can be used to make the connection between
--   the input and the resulting list of indices, and to store additional
--   data.
multiBuildHeapGraph :: Monoid a => Int -> [(a, Box)] -> IO (HeapGraph a, [(a, HeapGraphIndex)])

-- | Adds an entry to an existing <a>HeapGraph</a>.
--   
--   Returns the updated <a>HeapGraph</a> and the index of the added value.
addHeapGraph :: Monoid a => Int -> a -> Box -> HeapGraph a -> IO (HeapGraphIndex, HeapGraph a)

-- | Adds the given annotation to the entry at the given index, using the
--   <tt>mappend</tt> operation of its <a>Monoid</a> instance.
annotateHeapGraph :: Monoid a => a -> HeapGraphIndex -> HeapGraph a -> HeapGraph a

-- | This function updates a heap graph to reflect the current state of
--   closures on the heap, conforming to the following specification.
--   
--   <ul>
--   <li>Every entry whose value has been garbage collected by now is
--   marked as dead by setting <a>hgeLive</a> to <tt>False</tt></li>
--   <li>Every entry whose value is still live gets the <a>hgeClosure</a>
--   field updated and newly referenced closures are, up to the given
--   depth, added to the graph.</li>
--   <li>A map mapping previous indicies to the corresponding new indicies
--   is returned as well.</li>
--   <li>The closure at <a>heapGraphRoot</a> stays at
--   <a>heapGraphRoot</a></li>
--   </ul>
updateHeapGraph :: Monoid a => Int -> HeapGraph a -> IO (HeapGraph a, HeapGraphIndex -> HeapGraphIndex)

-- | Pretty-prints a HeapGraph. The resulting string contains newlines.
--   Example for <tt>let s = "Ki" in (s, s, cycle "Ho")</tt>:
--   
--   <pre>
--   let x1 = "Ki"
--       x6 = C# 'H' : C# 'o' : x6
--   in (x1,x1,x6)
--   </pre>
ppHeapGraph :: HeapGraph a -> String

-- | An arbitrarily Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <a>getBoxedClosureData</a>, the function knows how
--   far it has to evalue the argument.
data Box
Box :: Any -> Box

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list) 
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool

-- | This function integrates the disassembler in <a>GHC.Disassembler</a>.
--   The first argument should a function that dereferences the pointer in
--   the closure to a closure.
--   
--   If any of these return <a>Nothing</a>, then <a>disassembleBCO</a>
--   returns Nothing
disassembleBCO :: (a -> Maybe (GenClosure b)) -> GenClosure a -> Maybe [BCI b]
instance Show ClosureType
instance Eq ClosureType
instance Enum ClosureType
instance Ord ClosureType
instance Show StgInfoTable
instance Show b => Show (GenClosure b)
instance Functor GenClosure
instance Foldable GenClosure
instance Traversable GenClosure
instance Show a => Show (HeapGraphEntry a)
instance Functor HeapGraphEntry
instance Show a => Show (HeapGraph a)
instance Storable StgInfoTable
instance Show Box


-- | To avoid space leaks and unwanted evaluation behaviour, the programmer
--   might want his data to be fully evaluated at certians positions in the
--   code. This can be enforced, for example, by ample use of
--   <a>Control.DeepSeq</a>, but this comes at a cost.
--   
--   Experienced users hence use <a>deepseq</a> only to find out about the
--   existance of space leaks and optimize their code to not create the
--   thunks in the first place, until the code no longer shows better
--   performance with <tt>deepseq</tt>.
--   
--   This module provides an alternative approach: An explicit assertion
--   about the evaluation state. If the programmer expect a certain value
--   to be fully evaluated at a specific point of the program (e.g. before
--   a call to <a>writeIORef</a>), he can state that, and as long as
--   assertions are enabled, this statement will be checked. In the
--   production code the assertions can be disabled, to avoid the run-time
--   cost.
module GHC.AssertNF

-- | The function <a>assertNF</a> checks whether its argument is fully
--   evaluated and deeply evaluated. If this is not the case, a warning is
--   printed to the standard output, giving the number of thunks found and
--   printing the shape of the unevaluated object:
--   
--   <pre>
--   &gt; let x = 1 + 2
--   &gt; let y = (x,x)
--   &gt; assertNF y
--   Parameter not in normal form: 2 thunks found:
--   let t1 = _bco
--   in (t1,t1)
--   &gt; x
--   3
--   &gt; assertNF y
--   &gt;
--   </pre>
assertNF :: a -> IO ()

-- | In order to better identify the source of error messages from
--   <a>assertNF</a>, this variant allows you to include a name that is
--   printed in the output:
--   
--   <pre>
--   &gt; assertNFNamed "y" y
--   y not in normal form: 2 thunks found:
--   let t1 = _bco
--   in (t1,t1)
--   </pre>
assertNFNamed :: String -> a -> IO ()

-- | This function, when called as <tt>$assertNFHere</tt> in a module with
--   <tt>-XTemplateHaskell</tt> enabled, will cause the current filename
--   and position be included in the error message:
--   
--   <pre>
--   Parameter at Test.hs:18:1 not in normal form: 2 thunks found:
--   let t1 = _bco
--   in (t1,t1)
--   </pre>
assertNFHere :: Q Exp

-- | Invoke this function at the top of your <tt>main</tt> method to turn
--   every call to <a>assertNF</a> and its variants to noops.
disableAssertNF :: IO ()

-- | A variant of <a>assertNF</a> that does not print anything and just
--   returns <a>True</a> if the value is in normal form, or <a>False</a>
--   otherwise. This function is not affected by <a>disableAssertNF</a>.
isNF :: a -> IO Bool


-- | Utilities to debug <a>GHC.HeapView</a>.
module GHC.HeapView.Debug

-- | This functions walks the heap referenced by the argument, printing the
--   "path", i.e. the pointer indices from the initial to the current
--   closure and the closure itself. When the runtime crashes, the problem
--   is likely related to one of the earlier steps.
walkHeap :: Bool -> Bool -> Box -> IO ()
walkPrefix :: [Int] -> a -> IO Box
findM :: (a -> IO Bool) -> [a] -> IO (Maybe a)
isCharCons :: GenClosure Box -> IO Bool
isCons :: GenClosure b -> Maybe (b, b)
isChar :: GenClosure b -> Maybe Char
