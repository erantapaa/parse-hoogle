-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A probabilistic programming embedded DSL
--   
@package hakaru
@version 0.1.4

module Language.Hakaru.Util.Coda
effectiveSampleSize :: [Double] -> Double
meanVariance :: Fractional a => [a] -> (a, a)

module Language.Hakaru.Util.Visual
plot :: Show a => [a] -> String -> IO ()
batchPrint :: Show a => Int -> [a] -> IO ()
viz :: ToJSON a => Int -> [String] -> [[a]] -> IO ()
viz' :: ToJSON a => Int -> Int -> Int -> [String] -> [[a]] -> IO ()


-- | Functions on lists and sequences. Some of the functions follow the
--   style of Data.Random.Extras (from the random-extras package), but are
--   written for use with PRNGs from the "mwc-random" package rather than
--   from the "random-fu" package.
module Language.Hakaru.Util.Extras
extract :: Seq a -> Int -> Maybe (Seq a, a)
randomExtract :: Seq a -> GenIO -> IO (Maybe (Seq a, a))

-- | Given a sequence, return a *sorted* sequence of n randomly selected
--   elements from *distinct positions* in the sequence
randomElems :: Ord a => Seq a -> Int -> IO (Seq a)
randomElemsTR :: Ord a => Seq a -> Seq a -> GenIO -> Int -> IO (Seq a)

-- | Chop a sequence at the given indices. Assume number of indices given
--   &lt; length of sequence to be chopped
pieces :: Seq a -> Seq Int -> [Seq a]

-- | Given n, chop a sequence at m random points where m = min (length-1,
--   n-1)
randomPieces :: Int -> Seq a -> IO [Seq a]

-- | <pre>
--   pairs [1,2,3,4]
--   </pre>
--   
--   <ul>
--   <li><i>(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)</i> &gt; pairs
--   [1,2,4,4]</li>
--   <li><i>(1,2),(1,4),(1,4),(2,4),(2,4),(4,4)</i></li>
--   </ul>
pairs :: [a] -> [(a, a)]
l2Norm :: Floating a => [a] -> a

module Language.Hakaru.Util.Csv
data (:::) a b
(:::) :: a -> b -> (:::) a b
decodeFile :: FromRecord a => FilePath -> IO [a]
decodeGZipFile :: FromRecord a => FilePath -> IO [a]
decodeFileStream :: FromRecord a => FilePath -> IO [a]
decodeGZipFileStream :: FromRecord a => FilePath -> IO [a]
instance (Eq a, Eq b) => Eq (a ::: b)
instance (Ord a, Ord b) => Ord (a ::: b)
instance (Read a, Read b) => Read (a ::: b)
instance (Show a, Show b) => Show (a ::: b)
instance (ToField a, ToRecord b) => ToRecord (a ::: b)
instance (FromField a, FromRecord b) => FromRecord (a ::: b)

module Language.Hakaru.Lambda
lit :: Eq a => a -> a
dbl :: Double -> Double
lam :: (a -> b) -> (a -> b)
app :: (a -> b) -> a -> b
fix :: ((a -> b) -> (a -> b)) -> (a -> b)
ifThenElse :: Bool -> a -> a -> a

module Language.Hakaru.Mixture
type Prob = LogFloat
point :: k -> Prob -> Mixture k
empty :: Mixture k
scale :: Prob -> Mixture k -> Mixture k
newtype Mixture k
Mixture :: Map k Prob -> Mixture k
unMixture :: Mixture k -> Map k Prob
toList :: Mixture k -> [(k, Prob)]
mnull :: Mixture k -> Bool
mmap :: Ord k2 => (k1 -> k2) -> Mixture k1 -> Mixture k2
cross :: Ord k => (k1 -> k2 -> k) -> Mixture k1 -> Mixture k2 -> Mixture k
mode :: Mixture k -> (k, Prob)
instance Ord k => Monoid (Mixture k)
instance Show k => Show (Mixture k)

module Language.Hakaru.Symbolic
data Real
data Prob
data Measure a
data Dist a
data Exact
class IntComp repr
int :: IntComp repr => Integer -> repr Integer
class BoolComp repr
bool :: BoolComp repr => Bool -> repr Bool
class RealComp repr
real :: RealComp repr => Rational -> repr Real
exp :: RealComp repr => repr Real -> repr Real -> repr Real
sqrt, sin, cos :: RealComp repr => repr Real -> repr Real
class SymbComp repr
add, mul, minus :: SymbComp repr => repr a -> repr a -> repr a
pow :: SymbComp repr => repr Real -> repr Integer -> repr Real
scale :: SymbComp repr => repr Integer -> repr Real -> repr Real
class MeasMonad repr
bind :: MeasMonad repr => repr (Measure a) -> (repr a -> repr (Measure b)) -> repr (Measure b)
ret :: MeasMonad repr => repr a -> repr (Measure a)
class Distrib repr
uniform, normal :: Distrib repr => repr Real -> repr Real -> repr (Dist Real)
uniformD :: Distrib repr => repr Integer -> repr Integer -> repr (Dist Integer)
class Conditioning repr
conditioned, unconditioned :: Conditioning repr => repr (Dist a) -> repr (Measure a)
data Pos
Front :: Pos
Back :: Pos
type VarCounter = Int
newtype Maple a
Maple :: (Pos -> VarCounter -> String) -> Maple a
unMaple :: Maple a -> Pos -> VarCounter -> String
pure :: Show (MPL a) => MPL a -> Maple a
liftA1 :: (String -> String) -> Maple a -> Maple a
liftA2 :: (String -> String -> String) -> Maple a -> Maple a -> Maple a
liftA1M :: (String -> String) -> Maple a -> Maple (Measure a)
liftA2aba :: (String -> String -> String) -> Maple a -> Maple b -> Maple a
liftA2baa :: (String -> String -> String) -> Maple b -> Maple a -> Maple a
mkPr :: String -> (String -> String)
d2m :: Maple (Dist a) -> Maple (Measure a)
infixPr :: String -> (String -> String -> String)
reify :: Read a => Pos -> VarCounter -> Maple a -> a
name :: String -> VarCounter -> String
var :: String -> VarCounter -> Maple a
binder :: (String -> String -> Maybe String) -> (String -> String -> VarCounter -> Maybe String) -> String -> Maple a -> Maple a -> Maple (Dist a)
view :: Maple a -> String
lift :: Maple Integer -> Maple Real
exp1 :: Maple (Measure Real)
exp4 :: Maple (Measure Real)
exp3 :: Maple (Measure Real)
exp2 :: Maple (Measure Real)
test :: String
test4 :: String
test3 :: String
test2 :: String
instance Conditioning Maple
instance Distrib Maple
instance MeasMonad Maple
instance BoolComp Maple
instance IntComp Maple
instance SymbComp Maple
instance RealComp Maple

module Language.Hakaru.Types
type PRNG m = Gen (PrimState m)
data Density a
Lebesgue :: !a -> Density a
Discrete :: !a -> Density a
type Cond = Maybe Dynamic
fromDiscrete :: Density t -> t
fromLebesgue :: Density t -> t
fromDensity :: Density t -> t
type LogLikelihood = Double
data Dist a
Dist :: (Density a -> LogLikelihood) -> (forall m. PrimMonad m => PRNG m -> m (Density a)) -> Dist a
logDensity :: Dist a -> Density a -> LogLikelihood
distSample :: Dist a -> forall m. PrimMonad m => PRNG m -> m (Density a)
instance Typeable Density
instance Typeable Dist

module Language.Hakaru.Arrow
type (~~>) a b = a -> Dist b

module Language.Hakaru.Distribution
mapFst :: (t -> s) -> (t, u) -> (s, u)
dirac :: Eq a => a -> Dist a
bern :: Double -> Dist Bool
uniform :: Double -> Double -> Dist Double
uniformD :: (Ix a, Variate a) => a -> a -> Dist a
marsaglia :: (Variate a, Ord a, Floating a, PrimMonad m) => PRNG m -> m (a, a)
choose :: PrimMonad m => Mixture k -> PRNG m -> m (k, Prob)
chooseIndex :: PrimMonad m => [Double] -> PRNG m -> m Int
normal_rng :: (Real a, Floating a, Variate a, PrimMonad m) => a -> a -> PRNG m -> m a
normalLogDensity :: Floating a => a -> a -> a -> a
normal :: Double -> Double -> Dist Double
categoricalLogDensity :: (Eq b, Floating a) => [(b, a)] -> b -> a
categoricalSample :: (Num b, Ord b, PrimMonad m, Variate b) => [(t, b)] -> PRNG m -> m t
categorical :: Eq a => [(a, Double)] -> Dist a
lnFact :: Int -> Double
poisson_rng :: PrimMonad m => Double -> PRNG m -> m Int
poisson :: Double -> Dist Int
gamma_rng :: PrimMonad m => Double -> Double -> PRNG m -> m Double
gammaLogDensity :: Double -> Double -> Double -> Double
gamma :: Double -> Double -> Dist Double
beta_rng :: PrimMonad m => Double -> Double -> PRNG m -> m Double
betaLogDensity :: Double -> Double -> Double -> Double
beta :: Double -> Double -> Dist Double
laplace_rng :: PrimMonad m => Double -> Double -> PRNG m -> m Double
laplaceLogDensity :: Floating a => a -> a -> a -> a
laplace :: Double -> Double -> Dist Double
dirichlet_rng :: PrimMonad m => Int -> Double -> PRNG m -> m [Double]
dirichletLogDensity :: [Double] -> [Double] -> Double

module Language.Hakaru.Sampler
type Sampler a = PrimMonad m => PRNG m -> m (Mixture a)
deterministic :: Mixture a -> Sampler a
sbind :: Sampler a -> (a -> Sampler b) -> Sampler b
smap :: (a -> b) -> Sampler a -> Sampler b

module Language.Hakaru.ImportanceSampler
newtype Measure a
Measure :: ([Cond] -> Sampler (a, [Cond])) -> Measure a
unMeasure :: Measure a -> [Cond] -> Sampler (a, [Cond])
bind :: Measure a -> (a -> Measure b) -> Measure b
updateMixture :: Typeable a => Cond -> Dist a -> Sampler a
conditioned :: Typeable a => Dist a -> Measure a
unconditioned :: Typeable a => Dist a -> Measure a
factor :: Prob -> Measure ()
condition :: Eq b => Measure (a, b) -> b -> Measure a
finish :: Mixture (a, [Cond]) -> Mixture a
empiricalMeasure :: (PrimMonad m, Ord a) => Int -> Measure a -> [Cond] -> m (Mixture a)
sample :: Measure a -> [Cond] -> IO [(a, Prob)]
logit :: Floating a => a -> a
instance Monad Measure

module Language.Hakaru.Metropolis
type DistVal = Dynamic
data XRP
XRP :: (Density e, Dist e) -> XRP
unXRP :: Typeable a => XRP -> Maybe (Density a, Dist a)
type Visited = Bool
type Observed = Bool
type LL = LogLikelihood
type LL2 = (LL, LL)
type Subloc = Int
type Name = [Subloc]
data DBEntry
DBEntry :: XRP -> LL -> Visited -> Observed -> DBEntry
xrp :: DBEntry -> XRP
llhd :: DBEntry -> LL
vis :: DBEntry -> Visited
observed :: DBEntry -> Observed
type Database = Map Name DBEntry
data SamplerState
S :: Database -> {-# UNPACK #-} !LL2 -> [Cond] -> SamplerState
ldb :: SamplerState -> Database
llh2 :: SamplerState -> {-# UNPACK #-} !LL2
cnds :: SamplerState -> [Cond]
type Sampler a = PrimMonad m => SamplerState -> PRNG m -> m (a, SamplerState)
sreturn :: a -> Sampler a
sbind :: Sampler a -> (a -> Sampler b) -> Sampler b
smap :: (a -> b) -> Sampler a -> Sampler b
newtype Measure a
Measure :: (Name -> Sampler a) -> Measure a
unMeasure :: Measure a -> Name -> Sampler a
return_ :: a -> Measure a
updateXRP :: Typeable a => Name -> Cond -> Dist a -> Sampler a
updateLogLikelihood :: LL2 -> LL2 -> LL2
factor :: LL -> Measure ()
condition :: Eq b => Measure (a, b) -> b -> Measure a
bind :: Measure a -> (a -> Measure b) -> Measure b
conditioned :: Typeable a => Dist a -> Measure a
unconditioned :: Typeable a => Dist a -> Measure a
sapp :: (Sampler (a -> b)) -> Sampler a -> Sampler b
app :: Measure (a -> b) -> Measure a -> Measure b
run :: Measure a -> [Cond] -> IO (a, Database, LL)
traceUpdate :: PrimMonad m => Measure a -> Database -> [Cond] -> PRNG m -> m (a, Database, LL, LL, LL)
initialStep :: Measure a -> [Cond] -> PRNG IO -> IO (a, Database, LL, LL, LL)
resample :: PrimMonad m => Name -> Database -> Observed -> XRP -> PRNG m -> m (Database, LL, LL, LL)
transition :: Typeable a => Measure a -> [Cond] -> a -> Database -> LL -> PRNG IO -> IO [a]
mcmc :: Typeable a => Measure a -> [Cond] -> IO [a]
sample :: Typeable a => Measure a -> [Cond] -> IO [(a, Double)]
instance Typeable Measure
instance Applicative Measure
instance Functor Measure
instance Monad Measure
