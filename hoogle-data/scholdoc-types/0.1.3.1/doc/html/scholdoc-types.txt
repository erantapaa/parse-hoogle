-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Scholdoc fork of pandoc-types
--   
@package scholdoc-types
@version 0.1.3.1


-- | Generic functions for manipulating <tt>Pandoc</tt> documents. (Note:
--   the functions defined in <tt>Text.Pandoc.Walk</tt> should be used
--   instead, when possible, as they are much faster.)
--   
--   Here's a simple example, defining a function that replaces all the
--   level 3+ headers in a document with regular paragraphs in ALL CAPS:
--   
--   <pre>
--   import Text.Pandoc.Definition
--   import Text.Pandoc.Generic
--   import Data.Char (toUpper)
--   
--   modHeader :: Block -&gt; Block
--   modHeader (Header n _ xs) | n &gt;= 3 = Para $ bottomUp allCaps xs
--   modHeader x = x
--   
--   allCaps :: Inline -&gt; Inline
--   allCaps (Str xs) = Str $ map toUpper xs
--   allCaps x = x
--   
--   changeHeaders :: Pandoc -&gt; Pandoc
--   changeHeaders = bottomUp modHeader
--   </pre>
--   
--   <a>bottomUp</a> is so called because it traverses the <tt>Pandoc</tt>
--   structure from bottom up. <a>topDown</a> goes the other way. The
--   difference between them can be seen from this example:
--   
--   <pre>
--   normal :: [Inline] -&gt; [Inline]
--   normal (Space : Space : xs) = Space : xs
--   normal (Emph xs : Emph ys : zs) = Emph (xs ++ ys) : zs
--   normal xs = xs
--   
--   myDoc :: Pandoc
--   myDoc =  Pandoc nullMeta
--    [ Para [Str "Hi",Space,Emph [Str "world",Space],Emph [Space,Str "emphasized"]]]
--   </pre>
--   
--   Here we want to use <a>topDown</a> to lift <tt>normal</tt> to
--   <tt>Pandoc -&gt; Pandoc</tt>. The top down strategy will collapse the
--   two adjacent <tt>Emph</tt>s first, then collapse the resulting
--   adjacent <tt>Space</tt>s, as desired. If we used <a>bottomUp</a>, we
--   would end up with two adjacent <tt>Space</tt>s, since the contents of
--   the two <tt>Emph</tt> inlines would be processed before the
--   <tt>Emph</tt>s were collapsed into one.
--   
--   <pre>
--   topDown normal myDoc ==
--     Pandoc nullMeta
--      [Para [Str "Hi",Space,Emph [Str "world",Space,Str "emphasized"]]]
--   
--   bottomUp normal myDoc ==
--     Pandoc nullMeta
--      [Para [Str "Hi",Space,Emph [Str "world",Space,Space,Str "emphasized"]]]
--   </pre>
--   
--   <a>bottomUpM</a> is a monadic version of <a>bottomUp</a>. It could be
--   used, for example, to replace the contents of delimited code blocks
--   with attribute <tt>include=FILENAME</tt> with the contents of
--   <tt>FILENAME</tt>:
--   
--   <pre>
--   doInclude :: Block -&gt; IO Block
--   doInclude cb@(CodeBlock (id, classes, namevals) contents) =
--     case lookup "include" namevals of
--          Just f  -&gt; return . (CodeBlock (id, classes, namevals)) =&lt;&lt; readFile f
--          Nothing -&gt; return cb
--   doInclude x = return x
--   
--   processIncludes :: Pandoc -&gt; IO Pandoc
--   processIncludes = bottomUpM doInclude
--   </pre>
--   
--   <a>queryWith</a> can be used, for example, to compile a list of URLs
--   linked to in a document:
--   
--   <pre>
--   extractURL :: Inline -&gt; [String]
--   extractURL (Link _ (u,_)) = [u]
--   extractURL (Image _ (u,_)) = [u]
--   extractURL _ = []
--   
--   extractURLs :: Pandoc -&gt; [String]
--   extractURLs = queryWith extractURL
--   </pre>
module Text.Pandoc.Generic

-- | Applies a transformation on <tt>a</tt>s to matching elements in a
--   <tt>b</tt>, moving from the bottom of the structure up.
bottomUp :: (Data a, Data b) => (a -> a) -> b -> b

-- | Applies a transformation on <tt>a</tt>s to matching elements in a
--   <tt>b</tt>, moving from the top of the structure down.
topDown :: (Data a, Data b) => (a -> a) -> b -> b

-- | Like <a>bottomUp</a>, but with monadic transformations.
bottomUpM :: (Monad m, Data a, Data b) => (a -> m a) -> b -> m b

-- | Runs a query on matching <tt>a</tt> elements in a <tt>c</tt>. The
--   results of the queries are combined using <a>mappend</a>.
queryWith :: (Data a, Monoid b, Data c) => (a -> b) -> c -> b


-- | Definition of <a>Pandoc</a> data structure for format-neutral
--   representation of documents.
module Text.Pandoc.Definition
data Pandoc
Pandoc :: Meta -> [Block] -> Pandoc

-- | Metadata for the document: title, authors, date.
newtype Meta
Meta :: Map String MetaValue -> Meta
unMeta :: Meta -> Map String MetaValue
data MetaValue
MetaMap :: (Map String MetaValue) -> MetaValue
MetaList :: [MetaValue] -> MetaValue
MetaBool :: Bool -> MetaValue
MetaString :: String -> MetaValue
MetaInlines :: [Inline] -> MetaValue
MetaBlocks :: [Block] -> MetaValue
nullMeta :: Meta
isNullMeta :: Meta -> Bool

-- | Retrieve the metadata value for a given <tt>key</tt>.
lookupMeta :: String -> Meta -> Maybe MetaValue

-- | Extract document title from metadata; works just like the old
--   <tt>docTitle</tt>.
docTitle :: Meta -> [Inline]

-- | Extract document authors from metadata; works just like the old
--   <tt>docAuthors</tt>.
docAuthors :: Meta -> [[Inline]]

-- | Extract date from metadata; works just like the old <tt>docDate</tt>.
docDate :: Meta -> [Inline]

-- | Block element.
data Block

-- | Plain text, not a paragraph
Plain :: [Inline] -> Block

-- | Paragraph
Para :: [Inline] -> Block

-- | Code block (literal) with attributes
CodeBlock :: Attr -> String -> Block

-- | Raw block
RawBlock :: Format -> String -> Block

-- | Block quote (list of blocks)
BlockQuote :: [Block] -> Block

-- | Ordered list (attributes and a list of items, each a list of blocks)
OrderedList :: ListAttributes -> [[Block]] -> Block

-- | Bullet list (list of items, each a list of blocks)
BulletList :: [[Block]] -> Block

-- | Definition list Each list item is a pair consisting of a term (a list
--   of inlines) and one or more definitions (each a list of blocks)
DefinitionList :: [([Inline], [[Block]])] -> Block

-- | Header - level (integer) and text (inlines)
Header :: Int -> Attr -> [Inline] -> Block

-- | Horizontal rule
HorizontalRule :: Block

-- | Table, with caption, column alignments (required), relative column
--   widths (0 = default), column headers (each a list of blocks), and rows
--   (each a list of lists of blocks)
Table :: [Inline] -> [Alignment] -> [Double] -> [TableCell] -> [[TableCell]] -> Block

-- | A floating figure, containing for example images, tables, highlighted
--   code, pseudocode, etc. Differentiated by FigureType. Has attribures,
--   list of float content (typically just 1), a FloatFallback for
--   "pre-compiled" float content,and a caption (inlines) for the whole
--   figure.
Figure :: FigureType -> Attr -> [Block] -> PreparedContent -> [Inline] -> Block

-- | ImageGrid, containing rows of images, intended to be used primarily in
--   Floats. In this context, alt texts will be treated as captions for
--   each individual image.
ImageGrid :: [[Inline]] -> Block

-- | Standalone statements, can be sequentially numbered and
--   cross-referenced, and optinally may have a Proof block inside its
--   body.
Statement :: StatementAttr -> [Block] -> Block

-- | Proofs (AMS-style), with an optional alternate title, and proof text
Proof :: [Inline] -> [Block] -> Block

-- | Generic block container with attributes
Div :: Attr -> [Block] -> Block

-- | Nothing
Null :: Block

-- | Inline elements.
data Inline

-- | Text (string)
Str :: String -> Inline

-- | Emphasized text (list of inlines)
Emph :: [Inline] -> Inline

-- | Strongly emphasized text (list of inlines)
Strong :: [Inline] -> Inline

-- | Strikeout text (list of inlines)
Strikeout :: [Inline] -> Inline

-- | Superscripted text (list of inlines)
Superscript :: [Inline] -> Inline

-- | Subscripted text (list of inlines)
Subscript :: [Inline] -> Inline

-- | Small caps text (list of inlines)
SmallCaps :: [Inline] -> Inline

-- | Quoted text (list of inlines)
Quoted :: QuoteType -> [Inline] -> Inline

-- | Citation (list of inlines)
Cite :: [Citation] -> [Inline] -> Inline

-- | Reference (literal)
NumRef :: NumberedReference -> String -> Inline

-- | Inline code (literal)
Code :: Attr -> String -> Inline

-- | Inter-word space
Space :: Inline

-- | Hard line break
LineBreak :: Inline

-- | TeX math (literal)
Math :: MathType -> String -> Inline

-- | Raw inline
RawInline :: Format -> String -> Inline

-- | Hyperlink: text (list of inlines), target
Link :: [Inline] -> Target -> Inline

-- | Image alt text (list of inlines), target
Image :: Attr -> [Inline] -> Target -> Inline

-- | Footnote or endnote
Note :: [Block] -> Inline

-- | Generic inline container with attributes
Span :: Attr -> [Inline] -> Inline

-- | Alignment of a table column.
data Alignment
AlignLeft :: Alignment
AlignRight :: Alignment
AlignCenter :: Alignment
AlignDefault :: Alignment

-- | List attributes.
type ListAttributes = (Int, ListNumberStyle, ListNumberDelim)

-- | Style of list numbers.
data ListNumberStyle
DefaultStyle :: ListNumberStyle
Example :: ListNumberStyle
Decimal :: ListNumberStyle
LowerRoman :: ListNumberStyle
UpperRoman :: ListNumberStyle
LowerAlpha :: ListNumberStyle
UpperAlpha :: ListNumberStyle

-- | Delimiter of list numbers.
data ListNumberDelim
DefaultDelim :: ListNumberDelim
Period :: ListNumberDelim
OneParen :: ListNumberDelim
TwoParens :: ListNumberDelim

-- | Formats for raw blocks
newtype Format
Format :: String -> Format

-- | Attributes: identifier, classes, key-value pairs
type Attr = (String, [String], [(String, String)])
nullAttr :: Attr

-- | Table cells are list of Blocks
type TableCell = [Block]

-- | Type of quotation marks to use in Quoted inline.
data QuoteType
SingleQuote :: QuoteType
DoubleQuote :: QuoteType

-- | Link target (URL, title).
type Target = (String, String)

-- | Type of math element (display or inline).
data MathType
DisplayMath :: Attr -> MathType
InlineMath :: MathType

-- | Type of figure, mainly used to differentiate content (i.e., images vs
--   tables). ImageFigure contains a ImageGrid. TableFigure contains one or
--   more Tables. LineBlockFigure contains one or more Paras (intended for
--   algorithms and poetry). ListingFigure contains one or more CodeBlocks.
data FigureType
ImageFigure :: FigureType
TableFigure :: FigureType
LineBlockFigure :: FigureType
ListingFigure :: FigureType

-- | Pre-rendered figure content intended to archive final, professionally
--   typeset or drawn figures from content already described in markdown
--   format (an image and/or latex code)
data PreparedContent
PreparedContent :: Inline -> String -> PreparedContent
preparedImageContent :: PreparedContent -> Inline
preparedLaTeXContent :: PreparedContent -> String
noPrepContent :: PreparedContent

-- | Statement Attributes: identifier, label (inlines with raw), name of
--   counter, hiearchy level, pre-computed numerical label, caption,
data StatementAttr
StatementAttr :: String -> StatementStyle -> ([Inline], String) -> String -> Int -> String -> [Inline] -> StatementAttr
statementId :: StatementAttr -> String
statementStyle :: StatementAttr -> StatementStyle
statementLabel :: StatementAttr -> ([Inline], String)
statementCounter :: StatementAttr -> String
statementLevel :: StatementAttr -> Int
statementNum :: StatementAttr -> String
statementCaption :: StatementAttr -> [Inline]

-- | Type of statement, rought equivalent to <tt>amsthm</tt> plain,
--   defninition, and remark
data StatementStyle
Theorem :: StatementStyle
Standard :: StatementStyle
Remark :: StatementStyle
Other :: String -> StatementStyle
data Citation
Citation :: String -> [Inline] -> [Inline] -> CitationMode -> Int -> Int -> Citation
citationId :: Citation -> String
citationPrefix :: Citation -> [Inline]
citationSuffix :: Citation -> [Inline]
citationMode :: Citation -> CitationMode
citationNoteNum :: Citation -> Int
citationHash :: Citation -> Int
data CitationMode
AuthorInText :: CitationMode
SuppressAuthor :: CitationMode
NormalCitation :: CitationMode
data NumberedReference
NumberedReference :: String -> NumberedReferenceStyle -> [Inline] -> NumberedReference
numRefId :: NumberedReference -> String
numRefStyle :: NumberedReference -> NumberedReferenceStyle
numRefLabel :: NumberedReference -> [Inline]
data NumberedReferenceStyle
PlainNumRef :: NumberedReferenceStyle
ParenthesesNumRef :: NumberedReferenceStyle
instance Typeable Alignment
instance Typeable ListNumberStyle
instance Typeable ListNumberDelim
instance Typeable Format
instance Typeable FigureType
instance Typeable QuoteType
instance Typeable MathType
instance Typeable StatementStyle
instance Typeable CitationMode
instance Typeable NumberedReferenceStyle
instance Typeable NumberedReference
instance Typeable Inline
instance Typeable Citation
instance Typeable Block
instance Typeable StatementAttr
instance Typeable PreparedContent
instance Typeable MetaValue
instance Typeable Meta
instance Typeable Pandoc
instance Eq Alignment
instance Ord Alignment
instance Show Alignment
instance Read Alignment
instance Data Alignment
instance Generic Alignment
instance Eq ListNumberStyle
instance Ord ListNumberStyle
instance Show ListNumberStyle
instance Read ListNumberStyle
instance Data ListNumberStyle
instance Generic ListNumberStyle
instance Eq ListNumberDelim
instance Ord ListNumberDelim
instance Show ListNumberDelim
instance Read ListNumberDelim
instance Data ListNumberDelim
instance Generic ListNumberDelim
instance Read Format
instance Show Format
instance Data Format
instance Generic Format
instance Show FigureType
instance Eq FigureType
instance Ord FigureType
instance Read FigureType
instance Data FigureType
instance Generic FigureType
instance Show QuoteType
instance Eq QuoteType
instance Ord QuoteType
instance Read QuoteType
instance Data QuoteType
instance Generic QuoteType
instance Show MathType
instance Eq MathType
instance Ord MathType
instance Read MathType
instance Data MathType
instance Generic MathType
instance Show StatementStyle
instance Eq StatementStyle
instance Ord StatementStyle
instance Read StatementStyle
instance Data StatementStyle
instance Generic StatementStyle
instance Show CitationMode
instance Eq CitationMode
instance Ord CitationMode
instance Read CitationMode
instance Data CitationMode
instance Generic CitationMode
instance Show NumberedReferenceStyle
instance Eq NumberedReferenceStyle
instance Ord NumberedReferenceStyle
instance Read NumberedReferenceStyle
instance Data NumberedReferenceStyle
instance Generic NumberedReferenceStyle
instance Show NumberedReference
instance Eq NumberedReference
instance Read NumberedReference
instance Data NumberedReference
instance Generic NumberedReference
instance Show Inline
instance Eq Inline
instance Ord Inline
instance Read Inline
instance Data Inline
instance Generic Inline
instance Show Citation
instance Eq Citation
instance Read Citation
instance Data Citation
instance Generic Citation
instance Eq Block
instance Ord Block
instance Read Block
instance Show Block
instance Data Block
instance Generic Block
instance Show StatementAttr
instance Eq StatementAttr
instance Read StatementAttr
instance Data StatementAttr
instance Generic StatementAttr
instance Show PreparedContent
instance Eq PreparedContent
instance Ord PreparedContent
instance Read PreparedContent
instance Data PreparedContent
instance Generic PreparedContent
instance Eq MetaValue
instance Ord MetaValue
instance Show MetaValue
instance Read MetaValue
instance Data MetaValue
instance Generic MetaValue
instance Eq Meta
instance Ord Meta
instance Show Meta
instance Read Meta
instance Data Meta
instance Generic Meta
instance Eq Pandoc
instance Ord Pandoc
instance Read Pandoc
instance Show Pandoc
instance Data Pandoc
instance Generic Pandoc
instance Datatype D1Alignment
instance Constructor C1_0Alignment
instance Constructor C1_1Alignment
instance Constructor C1_2Alignment
instance Constructor C1_3Alignment
instance Datatype D1ListNumberStyle
instance Constructor C1_0ListNumberStyle
instance Constructor C1_1ListNumberStyle
instance Constructor C1_2ListNumberStyle
instance Constructor C1_3ListNumberStyle
instance Constructor C1_4ListNumberStyle
instance Constructor C1_5ListNumberStyle
instance Constructor C1_6ListNumberStyle
instance Datatype D1ListNumberDelim
instance Constructor C1_0ListNumberDelim
instance Constructor C1_1ListNumberDelim
instance Constructor C1_2ListNumberDelim
instance Constructor C1_3ListNumberDelim
instance Datatype D1Format
instance Constructor C1_0Format
instance Datatype D1FigureType
instance Constructor C1_0FigureType
instance Constructor C1_1FigureType
instance Constructor C1_2FigureType
instance Constructor C1_3FigureType
instance Datatype D1QuoteType
instance Constructor C1_0QuoteType
instance Constructor C1_1QuoteType
instance Datatype D1MathType
instance Constructor C1_0MathType
instance Constructor C1_1MathType
instance Datatype D1StatementStyle
instance Constructor C1_0StatementStyle
instance Constructor C1_1StatementStyle
instance Constructor C1_2StatementStyle
instance Constructor C1_3StatementStyle
instance Datatype D1CitationMode
instance Constructor C1_0CitationMode
instance Constructor C1_1CitationMode
instance Constructor C1_2CitationMode
instance Datatype D1NumberedReferenceStyle
instance Constructor C1_0NumberedReferenceStyle
instance Constructor C1_1NumberedReferenceStyle
instance Datatype D1NumberedReference
instance Constructor C1_0NumberedReference
instance Selector S1_0_0NumberedReference
instance Selector S1_0_1NumberedReference
instance Selector S1_0_2NumberedReference
instance Datatype D1Inline
instance Constructor C1_0Inline
instance Constructor C1_1Inline
instance Constructor C1_2Inline
instance Constructor C1_3Inline
instance Constructor C1_4Inline
instance Constructor C1_5Inline
instance Constructor C1_6Inline
instance Constructor C1_7Inline
instance Constructor C1_8Inline
instance Constructor C1_9Inline
instance Constructor C1_10Inline
instance Constructor C1_11Inline
instance Constructor C1_12Inline
instance Constructor C1_13Inline
instance Constructor C1_14Inline
instance Constructor C1_15Inline
instance Constructor C1_16Inline
instance Constructor C1_17Inline
instance Constructor C1_18Inline
instance Datatype D1Citation
instance Constructor C1_0Citation
instance Selector S1_0_0Citation
instance Selector S1_0_1Citation
instance Selector S1_0_2Citation
instance Selector S1_0_3Citation
instance Selector S1_0_4Citation
instance Selector S1_0_5Citation
instance Datatype D1Block
instance Constructor C1_0Block
instance Constructor C1_1Block
instance Constructor C1_2Block
instance Constructor C1_3Block
instance Constructor C1_4Block
instance Constructor C1_5Block
instance Constructor C1_6Block
instance Constructor C1_7Block
instance Constructor C1_8Block
instance Constructor C1_9Block
instance Constructor C1_10Block
instance Constructor C1_11Block
instance Constructor C1_12Block
instance Constructor C1_13Block
instance Constructor C1_14Block
instance Constructor C1_15Block
instance Constructor C1_16Block
instance Datatype D1StatementAttr
instance Constructor C1_0StatementAttr
instance Selector S1_0_0StatementAttr
instance Selector S1_0_1StatementAttr
instance Selector S1_0_2StatementAttr
instance Selector S1_0_3StatementAttr
instance Selector S1_0_4StatementAttr
instance Selector S1_0_5StatementAttr
instance Selector S1_0_6StatementAttr
instance Datatype D1PreparedContent
instance Constructor C1_0PreparedContent
instance Selector S1_0_0PreparedContent
instance Selector S1_0_1PreparedContent
instance Datatype D1MetaValue
instance Constructor C1_0MetaValue
instance Constructor C1_1MetaValue
instance Constructor C1_2MetaValue
instance Constructor C1_3MetaValue
instance Constructor C1_4MetaValue
instance Constructor C1_5MetaValue
instance Datatype D1Meta
instance Constructor C1_0Meta
instance Selector S1_0_0Meta
instance Datatype D1Pandoc
instance Constructor C1_0Pandoc
instance NFData Pandoc
instance NFData Block
instance NFData ListNumberStyle
instance NFData ListNumberDelim
instance NFData QuoteType
instance NFData NumberedReferenceStyle
instance NFData NumberedReference
instance NFData CitationMode
instance NFData Format
instance NFData StatementStyle
instance NFData StatementAttr
instance NFData PreparedContent
instance NFData MathType
instance NFData FigureType
instance NFData Inline
instance NFData Alignment
instance NFData Citation
instance NFData Meta
instance NFData MetaValue
instance ToJSON Pandoc
instance FromJSON Pandoc
instance ToJSON Block
instance FromJSON Block
instance ToJSON Inline
instance FromJSON Inline
instance ToJSON Format
instance FromJSON Format
instance ToJSON Alignment
instance FromJSON Alignment
instance ToJSON ListNumberDelim
instance FromJSON ListNumberDelim
instance ToJSON ListNumberStyle
instance FromJSON ListNumberStyle
instance ToJSON MathType
instance FromJSON MathType
instance ToJSON QuoteType
instance FromJSON QuoteType
instance ToJSON StatementStyle
instance FromJSON StatementStyle
instance ToJSON StatementAttr
instance FromJSON StatementAttr
instance ToJSON PreparedContent
instance FromJSON PreparedContent
instance ToJSON FigureType
instance FromJSON FigureType
instance ToJSON NumberedReference
instance FromJSON NumberedReference
instance ToJSON NumberedReferenceStyle
instance FromJSON NumberedReferenceStyle
instance ToJSON Citation
instance FromJSON Citation
instance ToJSON CitationMode
instance FromJSON CitationMode
instance ToJSON Meta
instance FromJSON Meta
instance ToJSON MetaValue
instance FromJSON MetaValue
instance Ord NumberedReference
instance Ord Citation
instance Ord StatementAttr
instance Ord Format
instance Eq Format
instance IsString Format
instance Monoid Meta
instance Monoid Pandoc


-- | Convenience functions for building pandoc documents programmatically.
--   
--   Example of use (with <tt>OverloadedStrings</tt> pragma):
--   
--   <pre>
--   import Text.Pandoc.Builder
--   
--   myDoc :: Pandoc
--   myDoc = setTitle "My title" $ doc $
--     para "This is the first paragraph" &lt;&gt;
--     para ("And " &lt;&gt; emph "another" &lt;&gt; ".") &lt;&gt;
--     bulletList [ para "item one" &lt;&gt; para "continuation"
--                , plain ("item two and a " &lt;&gt;
--                    link "/url" "go to url" "link")
--                ]
--   </pre>
--   
--   Isn't that nicer than writing the following?
--   
--   <pre>
--   import Text.Pandoc.Definition
--   import Data.Map (fromList)
--   
--   myDoc :: Pandoc
--   myDoc = Pandoc (Meta {unMeta = fromList [("title",
--             MetaInlines [Str "My",Space,Str "title"])]})
--           [Para [Str "This",Space,Str "is",Space,Str "the",Space,Str "first",
--            Space,Str "paragraph"],Para [Str "And",Space,Emph [Str "another"],
--            Str "."]
--           ,BulletList [
--             [Para [Str "item",Space,Str "one"]
--             ,Para [Str "continuation"]]
--            ,[Plain [Str "item",Space,Str "two",Space,Str "and",Space,
--                     Str "a",Space,Link [Str "link"] ("/url","go to url")]]]]
--   </pre>
--   
--   And of course, you can use Haskell to define your own builders:
--   
--   <pre>
--   import Text.Pandoc.Builder
--   import Text.JSON
--   import Control.Arrow ((***))
--   import Data.Monoid (mempty)
--   
--   -- | Converts a JSON document into 'Blocks'.
--   json :: String -&gt; Blocks
--   json x =
--     case decode x of
--          Ok y    -&gt; jsValueToBlocks y
--          Error y -&gt; error y
--      where jsValueToBlocks x =
--             case x of
--              JSNull         -&gt; mempty
--              JSBool x       -&gt; plain $ text $ show x
--              JSRational _ x -&gt; plain $ text $ show x
--              JSString x     -&gt; plain $ text $ fromJSString x
--              JSArray xs     -&gt; bulletList $ map jsValueToBlocks xs
--              JSObject x     -&gt; definitionList $
--                                 map (text *** (:[]) . jsValueToBlocks) $
--                                 fromJSObject x
--   </pre>
module Text.Pandoc.Builder
newtype Many a
Many :: Seq a -> Many a
unMany :: Many a -> Seq a
type Inlines = Many Inline
type Blocks = Many Block

-- | An infix synonym for <a>mappend</a>.
--   
--   <i>Since: 4.5.0.0</i>
(<>) :: Monoid m => m -> m -> m
singleton :: a -> Many a
toList :: Many a -> [a]
fromList :: [a] -> Many a
isNull :: Many a -> Bool
doc :: Blocks -> Pandoc
class ToMetaValue a
toMetaValue :: ToMetaValue a => a -> MetaValue
class HasMeta a
setMeta :: (HasMeta a, ToMetaValue b) => String -> b -> a -> a
deleteMeta :: HasMeta a => String -> a -> a
setTitle :: Inlines -> Pandoc -> Pandoc
setAuthors :: [Inlines] -> Pandoc -> Pandoc
setDate :: Inlines -> Pandoc -> Pandoc

-- | Convert a <a>String</a> to <a>Inlines</a>, treating interword spaces
--   as <a>Space</a>s. If you want a <a>Str</a> with literal spaces, use
--   <a>str</a>.
text :: String -> Inlines
str :: String -> Inlines
emph :: Inlines -> Inlines
strong :: Inlines -> Inlines
strikeout :: Inlines -> Inlines
superscript :: Inlines -> Inlines
subscript :: Inlines -> Inlines
smallcaps :: Inlines -> Inlines
singleQuoted :: Inlines -> Inlines
doubleQuoted :: Inlines -> Inlines
cite :: [Citation] -> Inlines -> Inlines
numRef :: NumberedReference -> String -> Inlines

-- | Inline code with attributes.
codeWith :: Attr -> String -> Inlines

-- | Plain inline code.
code :: String -> Inlines
space :: Inlines
linebreak :: Inlines

-- | Inline math
math :: String -> Inlines

-- | Display math
displayMath :: String -> Inlines

-- | Display math with attributes
displayMathWith :: Attr -> String -> Inlines
rawInline :: String -> String -> Inlines
link :: String -> String -> Inlines -> Inlines
image :: String -> String -> Inlines -> Inlines

-- | Image element with additional attributes
imageWith :: Attr -> String -> String -> Inlines -> Inlines
note :: Blocks -> Inlines
spanWith :: Attr -> Inlines -> Inlines

-- | Trim leading and trailing Sp (spaces) from an Inlines.
trimInlines :: Inlines -> Inlines
para :: Inlines -> Blocks
plain :: Inlines -> Blocks

-- | A code block with attributes.
codeBlockWith :: Attr -> String -> Blocks

-- | A plain code block.
codeBlock :: String -> Blocks
rawBlock :: String -> String -> Blocks
blockQuote :: Blocks -> Blocks
bulletList :: [Blocks] -> Blocks

-- | Ordered list with attributes.
orderedListWith :: ListAttributes -> [Blocks] -> Blocks

-- | Ordered list with default attributes.
orderedList :: [Blocks] -> Blocks
definitionList :: [(Inlines, [Blocks])] -> Blocks
header :: Int -> Inlines -> Blocks
headerWith :: Attr -> Int -> Inlines -> Blocks
horizontalRule :: Blocks
table :: Inlines -> [(Alignment, Double)] -> [Blocks] -> [[Blocks]] -> Blocks

-- | A simple table without a caption.
simpleTable :: [Blocks] -> [[Blocks]] -> Blocks

-- | A column of rows of images, forming a grid (used for figures)
imageGrid :: [Inlines] -> Blocks

-- | Generic figure builder for all figure types
figure :: FigureType -> Attr -> PreparedContent -> Blocks -> Inlines -> Blocks

-- | Statements (theorem, lemma, definiton, example, etc)
statement :: String -> StatementStyle -> (Inlines, String) -> String -> Int -> String -> Inlines -> Blocks -> Blocks
proof :: Inlines -> Blocks -> Blocks
divWith :: Attr -> Blocks -> Blocks
instance Typeable Many
instance Monoid (Many Block)
instance Generic (Many a)
instance Data a => Data (Many a)
instance Ord a => Ord (Many a)
instance Eq a => Eq (Many a)
instance Foldable Many
instance Traversable Many
instance Functor Many
instance Show a => Show (Many a)
instance Read a => Read (Many a)
instance Datatype D1Many
instance Constructor C1_0Many
instance Selector S1_0_0Many
instance HasMeta Pandoc
instance HasMeta Meta
instance ToMetaValue a => ToMetaValue (Map String a)
instance ToMetaValue a => ToMetaValue [a]
instance ToMetaValue Bool
instance ToMetaValue Inlines
instance ToMetaValue Blocks
instance ToMetaValue MetaValue
instance IsString Inlines
instance Monoid Inlines


-- | Functions for manipulating <a>Pandoc</a> documents or extracting
--   information from them by walking the <a>Pandoc</a> structure (or
--   intermediate structures like '[Block]' or '[Inline]'. These are faster
--   (by a factor of four or five) than the generic functions defined in
--   <tt>Text.Pandoc.Generic</tt>.
--   
--   Here's a simple example, defining a function that replaces all the
--   level 3+ headers in a document with regular paragraphs in ALL CAPS:
--   
--   <pre>
--   import Text.Pandoc.Definition
--   import Text.Pandoc.Walk
--   import Data.Char (toUpper)
--   
--   modHeader :: Block -&gt; Block
--   modHeader (Header n _ xs) | n &gt;= 3 = Para $ walk allCaps xs
--   modHeader x = x
--   
--   allCaps :: Inline -&gt; Inline
--   allCaps (Str xs) = Str $ map toUpper xs
--   allCaps x = x
--   
--   changeHeaders :: Pandoc -&gt; Pandoc
--   changeHeaders = walk modHeader
--   </pre>
--   
--   <a>query</a> can be used, for example, to compile a list of URLs
--   linked to in a document:
--   
--   <pre>
--   extractURL :: Inline -&gt; [String]
--   extractURL (Link _ (u,_)) = [u]
--   extractURL (Image _ (u,_)) = [u]
--   extractURL _ = []
--   
--   extractURLs :: Pandoc -&gt; [String]
--   extractURLs = query extractURL
--   </pre>
module Text.Pandoc.Walk
class Walkable a b
walk :: Walkable a b => (a -> a) -> b -> b
walkM :: (Walkable a b, Monad m, Functor m) => (a -> m a) -> b -> m b
query :: (Walkable a b, Monoid c) => (a -> c) -> b -> c
instance [overlap ok] Walkable a b => Walkable a [b]
instance [overlap ok] Walkable Block Citation
instance [overlap ok] Walkable Inline Citation
instance [overlap ok] Walkable Block MetaValue
instance [overlap ok] Walkable Inline MetaValue
instance [overlap ok] Walkable Block Meta
instance [overlap ok] Walkable Inline Meta
instance [overlap ok] Walkable Meta Meta
instance [overlap ok] Walkable Pandoc Pandoc
instance [overlap ok] Walkable Inline Pandoc
instance [overlap ok] Walkable Block Pandoc
instance [overlap ok] Walkable Block Inline
instance [overlap ok] Walkable Block Block
instance [overlap ok] Walkable Inline Block
instance [overlap ok] Walkable Inline Inline
instance [overlap ok] (Walkable a b, Walkable a c) => Walkable a (b, c)
instance [overlap ok] (Foldable t, Traversable t, Walkable a b) => Walkable a (t b)


-- | Functions for serializing the Pandoc AST to JSON and deserializing
--   from JSON.
--   
--   Example of use: The following script (<tt>capitalize.hs</tt>) reads
--   reads a JSON representation of a Pandoc document from stdin, and
--   writes a JSON representation of a Pandoc document to stdout. It
--   changes all regular text in the document to uppercase, without
--   affecting URLs, code, tags, etc. Run the script with
--   
--   <pre>
--   pandoc -t json | runghc capitalize.hs | pandoc -f json
--   </pre>
--   
--   or (making capitalize.hs executable)
--   
--   <pre>
--   pandoc --filter ./capitalize.hs
--   </pre>
--   
--   <pre>
--   #!/usr/bin/env runghc
--   import Text.Pandoc.JSON
--   import Data.Char (toUpper)
--   
--   main :: IO ()
--   main = toJSONFilter capitalizeStrings
--   
--   capitalizeStrings :: Inline -&gt; Inline
--   capitalizeStrings (Str s) = Str $ map toUpper s
--   capitalizeStrings x       = x
--   </pre>
module Text.Pandoc.JSON

-- | <a>toJSONFilter</a> convert a function into a filter that reads
--   pandoc's JSON serialized output from stdin, transforms it by walking
--   the AST and applying the specified function, and serializes the result
--   as JSON to stdout.
--   
--   For a straight transformation, use a function of type <tt>a -&gt;
--   a</tt> or <tt>a -&gt; IO a</tt> where <tt>a</tt> = <a>Block</a>,
--   <a>Inline</a>,<a>Pandoc</a>, <a>Meta</a>, or <a>MetaValue</a>.
--   
--   If your transformation needs to be sensitive to the script's
--   arguments, use a function of type <tt>[String] -&gt; a -&gt; a</tt>
--   (with <tt>a</tt> constrained as above). The <tt>[String]</tt> will be
--   populated with the script's arguments.
--   
--   An alternative is to use the type <tt>Maybe Format -&gt; a -&gt;
--   a</tt>. This is appropriate when the first argument of the script (if
--   present) will be the target format, and allows scripts to behave
--   differently depending on the target format. The pandoc executable
--   automatically provides the target format as argument when scripts are
--   called using the `--filter` option.
class ToJSONFilter a
toJSONFilter :: ToJSONFilter a => a -> IO ()
instance ToJSONFilter a => ToJSONFilter (Maybe Format -> a)
instance ToJSONFilter a => ToJSONFilter ([String] -> a)
instance Data a => ToJSONFilter (a -> IO [a])
instance Data a => ToJSONFilter (a -> [a])
instance Walkable a Pandoc => ToJSONFilter (a -> IO a)
instance Walkable a Pandoc => ToJSONFilter (a -> a)
