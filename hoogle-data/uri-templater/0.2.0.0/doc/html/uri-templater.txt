-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing & Quasiquoting for RFC 6570 URI Templates
--   
--   Parsing &amp; Quasiquoting for RFC 6570 URI Templates
@package uri-templater
@version 0.2.0.0

module Network.URI.Template.Types
data Single
data Associative
data List
data TemplateValue a
Single :: String -> TemplateValue Single
Associative :: [(TemplateValue Single, TemplateValue Single)] -> TemplateValue Associative
List :: [TemplateValue Single] -> TemplateValue List
data WrappedValue
WrappedValue :: TemplateValue a -> WrappedValue
newtype TemplateString
String :: String -> TemplateString
fromString :: TemplateString -> String
newtype AList k v
AList :: [(k, v)] -> AList k v
fromAList :: AList k v -> [(k, v)]
class ToTemplateValue a where type family TemplateRep a
toTemplateValue :: ToTemplateValue a => a -> TemplateValue (TemplateRep a)
data ValueModifier
Normal :: ValueModifier
Explode :: ValueModifier
MaxLength :: Int -> ValueModifier
data Variable
Variable :: String -> ValueModifier -> Variable
variableName :: Variable -> String
variableValueModifier :: Variable -> ValueModifier
data TemplateSegment
Literal :: String -> TemplateSegment
Embed :: Modifier -> [Variable] -> TemplateSegment
type UriTemplate = [TemplateSegment]
data Modifier
Simple :: Modifier
Reserved :: Modifier
Fragment :: Modifier
Label :: Modifier
PathSegment :: Modifier
PathParameter :: Modifier
Query :: Modifier
QueryContinuation :: Modifier
Alias :: Modifier
instance [overlap ok] Read TemplateString
instance [overlap ok] Show TemplateString
instance [overlap ok] Eq TemplateString
instance [overlap ok] IsString TemplateString
instance [overlap ok] Read ValueModifier
instance [overlap ok] Show ValueModifier
instance [overlap ok] Eq ValueModifier
instance [overlap ok] Read Variable
instance [overlap ok] Show Variable
instance [overlap ok] Eq Variable
instance [overlap ok] Read Modifier
instance [overlap ok] Show Modifier
instance [overlap ok] Eq Modifier
instance [overlap ok] Read TemplateSegment
instance [overlap ok] Show TemplateSegment
instance [overlap ok] Eq TemplateSegment
instance [overlap ok] (ToTemplateValue k, TemplateRep k ~ Single, ToTemplateValue v, TemplateRep v ~ Single) => ToTemplateValue (Map k v)
instance [overlap ok] (ToTemplateValue k, TemplateRep k ~ Single, ToTemplateValue v, TemplateRep v ~ Single) => ToTemplateValue (HashMap k v)
instance [overlap ok] ToTemplateValue Text
instance [overlap ok] ToTemplateValue Text
instance [overlap ok] (ToTemplateValue a, TemplateRep a ~ Single) => ToTemplateValue (Vector a)
instance [overlap ok] (ToTemplateValue k, TemplateRep k ~ Single, ToTemplateValue v, TemplateRep v ~ Single) => ToTemplateValue (AList k v)
instance [overlap ok] (ToTemplateValue a, TemplateRep a ~ Single) => ToTemplateValue [a]
instance [overlap ok] ToTemplateValue TemplateString
instance [overlap ok] ToTemplateValue Int
instance [overlap ok] Show (TemplateValue a)

module Network.URI.Template.Parser
range :: Char -> Char -> Parser Char
ranges :: [(Char, Char)] -> Parser Char
ucschar :: Parser Char
iprivate :: Parser Char
pctEncoded :: Parser String
literalChar :: Parser Char
literal :: Parser TemplateSegment
variables :: Parser TemplateSegment
means :: Parser a -> b -> Parser b
charMeans :: Char -> b -> Parser b
modifier :: Parser Modifier
variable :: Parser Variable
embed :: Parser TemplateSegment
uriTemplate :: Parser UriTemplate
parseTemplate :: String -> Either Doc UriTemplate

module Network.URI.Template.Internal
type StringBuilder = Writer (DList Char)
addChar :: Char -> StringBuilder ()
addString :: String -> StringBuilder ()
data Allow
Unreserved :: Allow
UnreservedOrReserved :: Allow
allowEncoder :: Allow -> String -> String
data ProcessingOptions
ProcessingOptions :: Maybe Char -> Char -> Bool -> Maybe Char -> Allow -> ProcessingOptions
modifierPrefix :: ProcessingOptions -> Maybe Char
modifierSeparator :: ProcessingOptions -> Char
modifierSupportsNamed :: ProcessingOptions -> Bool
modifierIfEmpty :: ProcessingOptions -> Maybe Char
modifierAllow :: ProcessingOptions -> Allow
type BoundValue = (String, WrappedValue)
option :: Maybe Char -> Char -> Bool -> Maybe Char -> Allow -> ProcessingOptions
options :: Modifier -> ProcessingOptions
templateValueIsEmpty :: TemplateValue a -> Bool
namePrefix :: ProcessingOptions -> String -> TemplateValue a -> StringBuilder ()
processVariable :: Modifier -> Bool -> Variable -> WrappedValue -> StringBuilder ()
processVariables :: [(String, WrappedValue)] -> Modifier -> [Variable] -> StringBuilder ()
render :: UriTemplate -> [BoundValue] -> String
render' :: UriTemplate -> [BoundValue] -> String

module Network.URI.Template.TH
variableNames :: UriTemplate -> [String]
segmentToExpr :: TemplateSegment -> Q Exp
templateToExp :: UriTemplate -> Q Exp
quasiEval :: String -> Q Exp
uri :: QuasiQuoter

module Network.URI.Template
uri :: QuasiQuoter
render :: UriTemplate -> [BoundValue] -> String
parseTemplate :: String -> Either Doc UriTemplate
type UriTemplate = [TemplateSegment]
data TemplateSegment
Literal :: String -> TemplateSegment
Embed :: Modifier -> [Variable] -> TemplateSegment
data Modifier
Simple :: Modifier
Reserved :: Modifier
Fragment :: Modifier
Label :: Modifier
PathSegment :: Modifier
PathParameter :: Modifier
Query :: Modifier
QueryContinuation :: Modifier
Alias :: Modifier
data ValueModifier
Normal :: ValueModifier
Explode :: ValueModifier
MaxLength :: Int -> ValueModifier
data TemplateValue a
Single :: String -> TemplateValue Single
Associative :: [(TemplateValue Single, TemplateValue Single)] -> TemplateValue Associative
List :: [TemplateValue Single] -> TemplateValue List
class ToTemplateValue a where type family TemplateRep a
toTemplateValue :: ToTemplateValue a => a -> TemplateValue (TemplateRep a)
newtype AList k v
AList :: [(k, v)] -> AList k v
fromAList :: AList k v -> [(k, v)]
newtype TemplateString
String :: String -> TemplateString
fromString :: TemplateString -> String
