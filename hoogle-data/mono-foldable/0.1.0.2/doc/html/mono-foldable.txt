-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Folds for monomorphic containers
--   
--   Like Data.Foldable, but works with ByteStrings too
@package mono-foldable
@version 0.1.0.2

module Data.Foldable.Mono

-- | Monomorphic data structures that can be folded Minimal complete
--   definition: <a>foldMap</a> or <a>foldr</a>
class MFoldable t where type family Elem t :: * foldMap f = foldr (mappend . f) mempty foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z foldl' f a xs = foldr f' id xs a where f' x k z = k $! f z x foldl1 f xs = fromMaybe (error "fold1: empty structure") (foldl mf Nothing xs) where mf Nothing y = Just y mf (Just x) y = Just (f x y) foldr f z t = appEndo (foldMap (Endo . f) t) z foldr' f a xs = foldl f' id xs a where f' k x z = k $! f x z foldr1 f xs = fromMaybe (error "foldr1: empty structure") (foldr mf Nothing xs) where mf x Nothing = Just x mf x (Just y) = Just (f x y) foldM f z xs = foldr (\ x rest a -> f a x >>= rest) return xs z mapM_ f = foldr ((>>) . f) (return ())
foldMap :: (MFoldable t, Monoid m) => (Elem t -> m) -> t -> m
foldl :: MFoldable t => (a -> Elem t -> a) -> a -> t -> a
foldl' :: MFoldable t => (a -> Elem t -> a) -> a -> t -> a
foldl1 :: MFoldable t => (Elem t -> Elem t -> Elem t) -> t -> Elem t
foldr :: MFoldable t => (Elem t -> b -> b) -> b -> t -> b
foldr' :: MFoldable t => (Elem t -> b -> b) -> b -> t -> b
foldr1 :: MFoldable t => (Elem t -> Elem t -> Elem t) -> t -> Elem t
foldM :: (MFoldable t, Monad m, MFoldable t) => (a -> Elem t -> m a) -> a -> t -> m a
mapM_ :: (MFoldable t, MFoldable t, Monad m) => (Elem t -> m b) -> t -> m ()
instance [overlap ok] Unbox a => MFoldable (Vector a)
instance [overlap ok] Storable a => MFoldable (Vector a)
instance [overlap ok] MFoldable (Vector a)
instance [overlap ok] MFoldable Text
instance [overlap ok] MFoldable ByteString
instance [overlap ok] Foldable t => MFoldable (t a)
