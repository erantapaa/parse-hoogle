-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lift control operations like exception catching through monad transformers
--   
@package monad-peel
@version 0.2


-- | This module defines the class <a>MonadTransPeel</a> of monad
--   transformers through which control operations can be lifted. Instances
--   are included for all the standard monad transformers from the
--   <tt>transformers</tt> library except <tt>ContT</tt>.
--   
--   <a>idPeel</a> and <a>liftPeel</a> are provided to assist creation of
--   <tt>MonadPeelIO</tt>-like classes (see <a>Control.Monad.IO.Peel</a>)
--   based on core monads other than <a>IO</a>.
--   
--   <a>liftOp</a> and <a>liftOp_</a> enable convenient lifting of two
--   common special cases of control operation types.
module Control.Monad.Trans.Peel

-- | <tt>MonadTransPeel</tt> is the class of monad transformers supporting
--   an extra operation <a>peel</a>, enabling control operations (functions
--   that use monadic actions as input instead of just output) to be lifted
--   through the transformer.
class MonadTrans t => MonadTransPeel t
peel :: (MonadTransPeel t, Monad m, Monad n, Monad o) => t n (t m a -> m (t o a))

-- | <tt>idPeel</tt> acts as the "identity" <a>peel</a> operation from a
--   monad <tt>m</tt> to itself.
--   
--   <pre>
--   <a>idPeel</a> = <a>return</a> $ <a>liftM</a> <a>return</a>
--   </pre>
--   
--   It serves as the base case for a class like <tt>MonadPeelIO</tt>,
--   which allows control operations in some base monad (here <tt>IO</tt>)
--   to be lifted through arbitrary stacks of zero or more monad
--   transformers in one call. For example, <a>Control.Monad.IO.Peel</a>
--   defines
--   
--   <pre>
--   class <tt>MonadIO</tt> m =&gt; MonadPeelIO m where
--     peelIO :: m (m a -&gt; <a>IO</a> (m a))
--   instance MonadPeelIO <a>IO</a> where
--     peelIO = <a>idPeel</a>
--   </pre>
idPeel :: (Monad m, Monad n, Monad o) => n (m a -> m (o a))

-- | <tt>liftPeel</tt> is used to compose two <a>peel</a> operations: the
--   outer provided by a <a>MonadTransPeel</a> instance, and the inner
--   provided as the argument.
--   
--   It satisfies <tt><a>liftPeel</a> <a>idPeel</a> == <a>peel</a></tt>.
--   
--   It serves as the induction step of a <tt>MonadPeelIO</tt>-like class.
--   For example, <a>Control.Monad.IO.Peel</a> defines
--   
--   <pre>
--   instance MonadPeelIO m =&gt; MonadPeelIO (<a>StateT</a> s m) where
--     peelIO = <a>liftPeel</a> peelIO
--   </pre>
--   
--   using the <a>MonadTransPeel</a> instance of <tt><a>StateT</a> s</tt>.
liftPeel :: (MonadTransPeel t, Monad m, Monad m', Monad n', Monad (t n'), Monad o', Monad (t o')) => n' (m' (t o' a) -> m (o' (t o' a))) -> t n' (t m' a -> m (t o' a))

-- | <tt>liftOp</tt> is a particular application of <a>peel</a> that allows
--   lifting control operations of type <tt>(a -&gt; m b) -&gt; m b</tt> to
--   <tt><a>MonadTransPeel</a> t =&gt; (a -&gt; t m b) -&gt; t m b</tt>.
--   
--   <pre>
--   <a>liftOp</a> f g = do
--     k &lt;- <a>peel</a>
--     <a>join</a> $ <a>lift</a> $ f (k . g)
--   </pre>
liftOp :: (MonadTransPeel t, Monad m, Monad n, Monad o, Monad (t n)) => ((a -> m (t o b)) -> n (t n c)) -> (a -> t m b) -> t n c

-- | <tt>liftOp_</tt> is a particular application of <a>peel</a> that
--   allows lifting control operations of type <tt>m a -&gt; m a</tt> to
--   <tt><a>MonadTransPeel</a> m =&gt; t m a -&gt; t m a</tt>.
--   
--   It can be thought of as a generalization of <tt>mapReaderT</tt>,
--   <tt>mapStateT</tt>, etc.
--   
--   <pre>
--   <a>liftOp_</a> f m = do
--     k &lt;- <a>peel</a>
--     <a>join</a> $ <a>lift</a> $ f (k m)
--   </pre>
liftOp_ :: (MonadTransPeel t, Monad m, Monad n, Monad o, Monad (t n)) => (m (t o a) -> n (t n b)) -> t m a -> t n b
instance Monoid w => MonadTransPeel (RWST r w s)
instance Monoid w => MonadTransPeel (RWST r w s)
instance Monoid w => MonadTransPeel (WriterT w)
instance Monoid w => MonadTransPeel (WriterT w)
instance MonadTransPeel (StateT s)
instance MonadTransPeel (StateT s)
instance MonadTransPeel (ReaderT r)
instance Error e => MonadTransPeel (ErrorT e)
instance MonadTransPeel MaybeT
instance MonadTransPeel ListT
instance MonadTransPeel IdentityT


-- | This module defines the class <a>MonadPeelIO</a> of <a>IO</a>-based
--   monads into which control operations on <a>IO</a> (such as exception
--   catching; see <a>Control.Exception.Peel</a>) can be lifted.
--   
--   <a>liftIOOp</a> and <a>liftIOOp_</a> enable convenient lifting of two
--   common special cases of control operation types.
module Control.Monad.IO.Peel

-- | <tt>MonadPeelIO</tt> is the class of <a>IO</a>-based monads supporting
--   an extra operation <a>peelIO</a>, enabling control operations on
--   <a>IO</a> to be lifted into the monad.
class MonadIO m => MonadPeelIO m
peelIO :: MonadPeelIO m => m (m a -> IO (m a))

-- | <tt>liftIOOp</tt> is a particular application of <a>peelIO</a> that
--   allows lifting control operations of type <tt>(a -&gt; <a>IO</a> b)
--   -&gt; <a>IO</a> b</tt> (e.g. <tt>alloca</tt>, <tt>withMVar v</tt>) to
--   <tt><a>MonadPeelIO</a> m =&gt; (a -&gt; m b) -&gt; m b</tt>.
--   
--   <pre>
--   <a>liftIOOp</a> f g = do
--     k &lt;- <a>peelIO</a>
--     <a>join</a> $ <a>liftIO</a> $ f (k . g)
--   </pre>
liftIOOp :: MonadPeelIO m => ((a -> IO (m b)) -> IO (m c)) -> (a -> m b) -> m c

-- | <tt>liftIOOp_</tt> is a particular application of <a>peelIO</a> that
--   allows lifting control operations of type <tt><a>IO</a> a -&gt;
--   <a>IO</a> a</tt> (e.g. <tt>block</tt>) to <tt><a>MonadPeelIO</a> m
--   =&gt; m a -&gt; m a</tt>.
--   
--   <pre>
--   <a>liftIOOp_</a> f m = do
--     k &lt;- <a>peelIO</a>
--     <a>join</a> $ <a>liftIO</a> $ f (k m)
--   </pre>
liftIOOp_ :: MonadPeelIO m => (IO (m a) -> IO (m b)) -> m a -> m b
instance (Monoid w, MonadPeelIO m) => MonadPeelIO (RWST r w s m)
instance (Monoid w, MonadPeelIO m) => MonadPeelIO (RWST r w s m)
instance (Monoid w, MonadPeelIO m) => MonadPeelIO (WriterT w m)
instance (Monoid w, MonadPeelIO m) => MonadPeelIO (WriterT w m)
instance MonadPeelIO m => MonadPeelIO (StateT s m)
instance MonadPeelIO m => MonadPeelIO (StateT s m)
instance MonadPeelIO m => MonadPeelIO (ReaderT r m)
instance (Error e, MonadPeelIO m) => MonadPeelIO (ErrorT e m)
instance MonadPeelIO m => MonadPeelIO (MaybeT m)
instance MonadPeelIO m => MonadPeelIO (ListT m)
instance MonadPeelIO m => MonadPeelIO (IdentityT m)
instance MonadPeelIO IO


-- | This is a wrapped version of Control.Exception with types generalized
--   from <a>IO</a> to all monads in <a>MonadPeelIO</a>.
module Control.Exception.Peel

-- | Generalized version of <a>throwIO</a>.
throwIO :: (MonadIO m, Exception e) => e -> m a

-- | Generalized version of <a>ioError</a>.
ioError :: MonadIO m => IOError -> m a

-- | Generalized version of <a>catch</a>.
catch :: (MonadPeelIO m, Exception e) => m a -> (e -> m a) -> m a

-- | Generalized version of <a>catches</a>.
catches :: MonadPeelIO m => m a -> [Handler m a] -> m a

-- | Generalized version of <a>Handler</a>.
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Generalized version of <a>catchJust</a>.
catchJust :: (MonadPeelIO m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Generalized version of <a>handle</a>.
handle :: (MonadPeelIO m, Exception e) => (e -> m a) -> m a -> m a

-- | Generalized version of <a>handleJust</a>.
handleJust :: (MonadPeelIO m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Generalized version of <a>try</a>.
try :: (MonadPeelIO m, Exception e) => m a -> m (Either e a)

-- | Generalized version of <a>tryJust</a>.
tryJust :: (MonadPeelIO m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Generalized version of <a>evaluate</a>.
evaluate :: MonadIO m => a -> m a

-- | Generalized version of <a>bracket</a>. Note, any monadic side effects
--   in <tt>m</tt> of the "release" computation will be discarded; it is
--   run only for its side effects in <tt>IO</tt>.
bracket :: MonadPeelIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalized version of <a>bracket_</a>. Note, any monadic side effects
--   in <tt>m</tt> of <i>both</i> the "acquire" and "release" computations
--   will be discarded. To keep the monadic side effects of the "acquire"
--   computation, use <a>bracket</a> with constant functions instead.
bracket_ :: MonadPeelIO m => m a -> m b -> m c -> m c

-- | Generalized version of <a>bracketOnError</a>.
bracketOnError :: MonadPeelIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalized version of <a>finally</a>. Note, any monadic side effects
--   in <tt>m</tt> of the "afterward" computation will be discarded.
finally :: MonadPeelIO m => m a -> m b -> m a

-- | Generalized version of <a>onException</a>.
onException :: MonadPeelIO m => m a -> m b -> m a
