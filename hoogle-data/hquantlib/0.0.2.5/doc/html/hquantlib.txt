-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HQuantLib is a port of essencial parts of QuantLib to Haskell
--   
@package hquantlib
@version 0.0.2.5

module QuantLib.Math.Copulas

-- | Copula type class. -| Normally instance should implement only
--   copulaFunc. -| Method copula provides a precheck for [0..1] range for
--   x and y but real implementation is in copulaFunc
class Copula a where copula t = precheckRange (copulaFunc t)

-- | Copula data types with parameters required by the concrete copula
--   definition
data Copulas

-- | Clayton copula
ClaytonCopula :: Double -> Copulas

-- | Min copula
MinCopula :: Copulas

-- | Max copula
MaxCopula :: Copulas

-- | Ali-Mikhail-Haq copula
AliMikhailHaqCopula :: Double -> Copulas

-- | Farlie-Gumbel-Morgenstern copula
FarlieGumbelMorgensternCopula :: Double -> Copulas

-- | Frank copula
FrankCopula :: Double -> Copulas

-- | Galambos copula
GalambosCopula :: Double -> Copulas

-- | Gaussian copula <i>Not implemented yet!</i>
GaussianCopula :: Double -> Copulas

-- | Gumbel copula
GumbelCopula :: Double -> Copulas

-- | Husler-Reiss copula <i>Not implemented yet!</i>
HuslerReissCopula :: Double -> Copulas

-- | Independent copula
IndependentCopula :: Copulas

-- | Marshall-Olkin copula
MarshallOlkinCopula :: Double -> Double -> Copulas

-- | Plackett copula
PlackettCopula :: Double -> Copulas
instance Copula Copulas

module QuantLib.Options
data OptionType
Call :: OptionType
Put :: OptionType
toInt :: OptionType -> Int
toDouble :: OptionType -> Double
instance Show OptionType
instance Eq OptionType

module QuantLib.PricingEngines.BlackFormula
blackFormulaImpliedStdDev :: OptionType -> Double -> Double -> Double -> Double -> Double -> Maybe Double -> Double -> Int -> Maybe Double

module QuantLib.Quotes

-- | Base type class for market observables
class Quote a where pureValue x = fromMaybe 0.0 (qValue x)
qValue :: Quote a => a -> Maybe Double
pureValue :: Quote a => a -> Double

-- | Market element returning a stored value
data SimpleQuote
SimpleQuote :: (Maybe Double) -> SimpleQuote

-- | Market element whose value depends on two other market elements
data CompositeQuote a
CompositeQuote :: a -> a -> (a -> a -> Maybe Double) -> CompositeQuote a

-- | First element
cqQuote1 :: CompositeQuote a -> a

-- | Second element
cqQuote2 :: CompositeQuote a -> a

-- | Composition function
cqComposite :: CompositeQuote a -> a -> a -> Maybe Double

-- | Market element whose value depends on another quote
data DerivedQuote a
DerivedQuote :: a -> (a -> Maybe Double) -> DerivedQuote a
dqQuote :: DerivedQuote a -> a
dqDerivateFunc :: DerivedQuote a -> a -> Maybe Double

-- | Quote for the implied standard deviation of an underlying
data ImpliedStdDevQuote a
ImpliedStdDevQuote :: OptionType -> a -> a -> Double -> Maybe Double -> ImpliedStdDevQuote a
isdqOptionType :: ImpliedStdDevQuote a -> OptionType
isdqForward :: ImpliedStdDevQuote a -> a
isdqPrice :: ImpliedStdDevQuote a -> a
isdqStrike :: ImpliedStdDevQuote a -> Double
isdqGuess :: ImpliedStdDevQuote a -> Maybe Double

-- | Quote for the Eurodollar-future implied standard deviation
data EurodollarFutureQuote a
EurodollarFutureQuote :: a -> a -> a -> Double -> Maybe Double -> EurodollarFutureQuote a
efqForward :: EurodollarFutureQuote a -> a
efqCallPrice :: EurodollarFutureQuote a -> a
efqPutPrice :: EurodollarFutureQuote a -> a
efqStrike :: EurodollarFutureQuote a -> Double
efqGuess :: EurodollarFutureQuote a -> Maybe Double
instance Show SimpleQuote
instance Eq SimpleQuote
instance Show a => Show (ImpliedStdDevQuote a)
instance Show a => Show (EurodollarFutureQuote a)
instance Quote a => Quote (EurodollarFutureQuote a)
instance Quote a => Quote (ImpliedStdDevQuote a)
instance Quote (DerivedQuote a)
instance Quote (CompositeQuote a)
instance Quote SimpleQuote

module QuantLib.Priceable

-- | All instruments and events have a net present value
class Priceable a
npv :: Priceable a => a -> Double
errorEstimate :: Priceable a => a -> Double

module QuantLib.Methods.MonteCarlo

-- | Summary type class aggregates all priced values of paths
class PathPricer p => Summary m p | m -> p
sSummarize :: Summary m p => m -> [p] -> m
sNorm :: Summary m p => m -> m -> Double

-- | Path generator is a stochastic path generator
class PathGenerator m
pgMkNew :: PathGenerator m => m -> IO m
pgGenerate :: PathGenerator m => m -> IO Path

-- | Path pricer provides a price for given path
class PathPricer m
ppPrice :: PathPricer m => m -> Path -> m

-- | Monte Carlo engine function
monteCarlo :: (Summary s p, PathPricer p, PathGenerator g) => PathMonteCarlo s p g -> Int -> IO s

-- | Monte Carlo engine function. Parallelized version
monteCarloParallel :: (Summary s p, PathPricer p, PathGenerator g) => PathMonteCarlo s p g -> Int -> IO s

-- | Path-dependant Monte Carlo engine
data PathMonteCarlo s p g
PathMonteCarlo :: s -> p -> g -> PathMonteCarlo s p g
pmcSummary :: PathMonteCarlo s p g -> s
pmcPricer :: PathMonteCarlo s p g -> p
pmcGenerator :: PathMonteCarlo s p g -> g

-- | This pricer gets the last point of path
data LastPointPricer
LastPointPricer :: Dot -> LastPointPricer

-- | Stochastic process generator
data ProcessGenerator sp b d
ProcessGenerator :: Dot -> Int -> sp -> b -> d -> ProcessGenerator sp b d
pgStart :: ProcessGenerator sp b d -> Dot
pgLength :: ProcessGenerator sp b d -> Int
pgProcess :: ProcessGenerator sp b d -> sp
pgGenerator :: ProcessGenerator sp b d -> b
pgDiscretize :: ProcessGenerator sp b d -> d
instance (StochasticProcess sp, NormalGenerator b, Discretize d) => PathGenerator (ProcessGenerator sp b d)
instance PathPricer LastPointPricer

module QuantLib.Currencies

module QuantLib.Instruments

-- | Instrument type class
class Instrument a
iDate :: Instrument a => a -> LocalTime
iIsExpired :: Instrument a => a -> Bool

-- | Composite instrument is an aggregate of other instruments.
data CompositeInstrument
CompositeInstrument :: (Map a Double) -> CompositeInstrument

-- | Single stock instrument
data Stock
Stock :: Double -> LocalTime -> Stock
sQuote :: Stock -> Double
sDate :: Stock -> LocalTime

module QuantLib.Time

-- | Business Day conventions - These conventions specify the algorithm
--   used to adjust a date in case it is not a valid business day.
data BusinessDayConvention
Following :: BusinessDayConvention
ModifiedFollowing :: BusinessDayConvention
Preceding :: BusinessDayConvention
ModifiedPreceding :: BusinessDayConvention
Unadjusted :: BusinessDayConvention

-- | Week days
data WeekDay
Monday :: WeekDay
Tuesday :: WeekDay
Wednesday :: WeekDay
Thursday :: WeekDay
Friday :: WeekDay
Saturday :: WeekDay
Sunday :: WeekDay

-- | Date
type Date = Day

-- | Defines a holidays for given calendar. Corresponds to calendar class
--   in QuantLib
class Holiday m where isBusinessDay m d = not (isHoliday m $ toGregorian d) hBusinessDayBetween m (fd, td) = foldl countDays 0 listOfDates where countDays counter x = counter + fromEnum (isBusinessDay m x) listOfDates = getDaysBetween (fd, td)
isHoliday :: Holiday m => m -> (Integer, Int, Int) -> Bool
isBusinessDay :: Holiday m => m -> Date -> Bool
hBusinessDayBetween :: Holiday m => m -> (Date, Date) -> Int

-- | Gets a week day
getWeekDay :: Date -> WeekDay

-- | Generate a list of all dates inbetween
getDaysBetween :: (Day, Day) -> [Day]

-- | Checks if the day is a weekend, i.e. Saturday or Sunday
isWeekEnd :: Date -> Bool

-- | Gets the next working day
getNextBusinessDay :: Holiday a => a -> Date -> Date

-- | Day counter type class
class DayCounter m
dcName :: DayCounter m => m -> String
dcCount :: DayCounter m => m -> Date -> Date -> Int
dcYearFraction :: DayCounter m => m -> Date -> Date -> Double

-- | Thirty day counters as in QuantLib
data Thirty360
ThirtyUSA :: Thirty360
ThirtyEuropean :: Thirty360
ThirtyItalian :: Thirty360
intGregorian :: Day -> (Int, Int, Int)

module QuantLib.Math

-- | Computes the inverse cumulative standard normal distribution N(0, 1)
inverseNormal :: Double -> Double

module QuantLib.Prices

-- | Price types
data PriceType
Bid :: PriceType
Ask :: PriceType
Last :: PriceType
Close :: PriceType
Mid :: PriceType
MidEq :: PriceType
MidSafe :: PriceType

-- | Call price
data CallPrice
DirtyPrice :: Double -> CallPrice
cpPrice :: CallPrice -> Double
CleanPrice :: Double -> CallPrice
cpPrice :: CallPrice -> Double

-- | Interval price
data IntervalPrice
IntervalPrice :: Double -> Double -> Double -> Double -> IntervalPrice
ipOpen :: IntervalPrice -> Double
ipHigh :: IntervalPrice -> Double
ipLow :: IntervalPrice -> Double
ipClose :: IntervalPrice -> Double
instance Show PriceType
instance Eq PriceType
instance Show CallPrice
instance Eq CallPrice
instance Ord CallPrice
instance Show IntervalPrice
instance Eq IntervalPrice

module QuantLib.Event
class Event a where evOccured event date = evDate event < date evOccuredInclude event date = evDate event <= date evCompare x y | evDate x == evDate y = EQ | evDate x <= evDate y = LT | otherwise = GT evEqual x y = evDate x == evDate y
evDate :: Event a => a -> Date
evOccured :: Event a => a -> Date -> Bool
evOccuredInclude :: Event a => a -> Date -> Bool
evCompare :: Event a => a -> a -> Ordering
evEqual :: Event a => a -> a -> Bool

-- | Cash flows data type
data CashFlow
CashFlow :: Date -> Double -> CashFlow
cfDate :: CashFlow -> Date
cfAmount :: CashFlow -> Double

-- | Sequence of cash-flows
type Leg = [CashFlow]
data Callability
Call :: CallPrice -> Date -> Callability
cPrice :: Callability -> CallPrice
cDate :: Callability -> Date
Put :: CallPrice -> Date -> Callability
cPrice :: Callability -> CallPrice
cDate :: Callability -> Date
instance Show CashFlow
instance Show Callability
instance Ord Callability
instance Eq Callability
instance Event Callability
instance Ord CashFlow
instance Eq CashFlow
instance Event CashFlow

module QuantLib.PricingEngines
class Event e => PricingEngine a e
peCalculate :: PricingEngine a e => e -> a -> e

module QuantLib.TimeSeries

-- | Time series
type TimeSeries m = Map LocalTime m

-- | Interval price time series
type IntervalPriceSeries = TimeSeries IntervalPrice

module QuantLib.Models.Volatility

-- | Volatility type
type Volatility = Double

-- | Estimation type with strictness as it is usually required only one
--   <a>Double</a> to process
data Estimation
Estimation :: {-# UNPACK #-} !Volatility -> Estimation

-- | Type class of volatility estimators
class VolatilityEstimator algorithm
estimate :: VolatilityEstimator algorithm => algorithm -> IntervalPriceSeries -> Estimation
data VolatilityEstimatorAlgorithm

-- | Simple estimator with drift
SimpleEstimator :: VolatilityEstimatorAlgorithm

-- | Simple estimator without drift
SimpleDriftLessEstimator :: VolatilityEstimatorAlgorithm

-- | Parkinson number
ParkinsonEstimator :: VolatilityEstimatorAlgorithm

-- | Garman-Klass estimator
GarmanKlass5Estimator :: VolatilityEstimatorAlgorithm

-- | Rogers-Stachel estimator
RogersSatchelEstimator :: VolatilityEstimatorAlgorithm

-- | Yang-Zhang estimator
YangZhangEstimator :: VolatilityEstimatorAlgorithm
instance Show Estimation
instance Eq Estimation
instance Show VolatilityEstimatorAlgorithm
instance Eq VolatilityEstimatorAlgorithm
instance Enum VolatilityEstimatorAlgorithm
instance VolatilityEstimator VolatilityEstimatorAlgorithm

module QuantLib.Models

module QuantLib.Position

-- | Position types
data Position
Long :: Position
Short :: Position
instance Show Position
instance Eq Position

module QuantLib.Money

-- | Amount of cash. Please, note that currency conversion is not
--   implemented yet.
data Money
Money :: Double -> Currency -> Money
mValue :: Money -> Double
mCurrency :: Money -> Currency
instance Eq Money
instance Num Money
instance Show Money

module QuantLib.Stochastic

module QuantLib
