-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A free monad based on the Wadler/Leijen pretty printer
--   
@package wl-pprint-extras
@version 3.5.0.5


-- | Pretty print module based on Daan Leijen's implementation of Philip
--   Wadler's "prettier printer"
--   
--   <pre>
--   "A prettier printer"
--   Draft paper, April 1997, revised March 1998.
--   <a>http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf</a>
--   </pre>
--   
--   This is an implementation of the pretty printing combinators described
--   by Philip Wadler (1997). In their bare essence, the combinators of
--   Wadler are not expressive enough to describe some commonly occurring
--   layouts. The PPrint library adds new primitives to describe these
--   layouts and works well in practice.
--   
--   The library is based on a single way to concatenate documents, which
--   is associative and has both a left and right unit. This simple design
--   leads to an efficient and short implementation. The simplicity is
--   reflected in the predictable behaviour of the combinators which make
--   them easy to use in practice.
--   
--   A thorough description of the primitive combinators and their
--   implementation can be found in Philip Wadler's paper (1997). Additions
--   and the main differences with his original paper are:
--   
--   <ul>
--   <li>The nil document is called empty.</li>
--   <li>The operator <a>&lt;/&gt;</a> is used for soft line breaks.</li>
--   <li>There are three new primitives: <a>align</a>, <a>fill</a> and
--   <a>fillBreak</a>. These are very useful in practice.</li>
--   <li>Lots of other useful combinators, like <a>fillSep</a> and
--   <a>list</a>.</li>
--   <li>There are two renderers, <a>renderPretty</a> for pretty printing
--   and <a>renderCompact</a> for compact output. The pretty printing
--   algorithm also uses a ribbon-width now for even prettier output.</li>
--   <li>There are two display routines, <a>displayS</a> for strings and
--   <a>displayIO</a> for file based output.</li>
--   <li>There is a <a>Pretty</a> class.</li>
--   <li>The implementation uses optimised representations and strictness
--   annotations.</li>
--   <li>A type argument has been added and embedded <tt>effects</tt> can
--   be seen in the SimpleDoc type.</li>
--   </ul>
module Text.PrettyPrint.Free.Internal

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" `above` text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc e
Fail :: Doc e
Empty :: Doc e
Char :: {-# UNPACK #-} !Char -> Doc e
Text :: {-# UNPACK #-} !Int -> String -> Doc e
Line :: Doc e
FlatAlt :: (Doc e) -> (Doc e) -> Doc e
Cat :: (Doc e) -> (Doc e) -> Doc e
Nest :: {-# UNPACK #-} !Int -> (Doc e) -> Doc e
Union :: (Doc e) -> (Doc e) -> Doc e
Effect :: e -> Doc e
Column :: (Int -> Doc e) -> Doc e
Nesting :: (Int -> Doc e) -> Doc e
Columns :: (Int -> Doc e) -> Doc e
Ribbon :: (Int -> Doc e) -> Doc e

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 100 characters and a
--   ribbon width of 40 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
putDoc :: Doc e -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 100 characters
--   and a ribbon width of 40 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
hPutDoc :: Handle -> Doc e -> IO ()

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc e

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function
--   <tt>string</tt> should be used.
text :: String -> Doc e

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" `above` text "world") `above` text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc e -> Doc e

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc e

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc e

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc e -> Doc e

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc e

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc e

-- | A linebreak that can not be flattened; it is guaranteed to be rendered
--   as a newline.
hardline :: Doc e

-- | <tt>flatAlt</tt> creates a document that changes when flattened;
--   normally it is rendered as the first argument, but when flattened is
--   rendered as the second.
flatAlt :: Doc e -> Doc e -> Doc e
flatten :: Doc e -> Doc e

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (above x y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc e -> Doc e

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc e -> Doc e

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc e -> Doc e

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10, 200, 3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [ 10
--        , 200
--        , 3000 ]
--   </pre>
encloseSep :: Foldable f => Doc e -> Doc e -> Doc e -> f (Doc e) -> Doc e

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semi colons and encloses them in braces. The
--   documents are rendered horizontally if that fits the page. Otherwise
--   they are aligned vertically. All semi colons are put in front of the
--   elements.
semiBraces :: Foldable f => f (Doc e) -> Doc e
(<+>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>above x y</tt> concatenates document <tt>x</tt> and
--   <tt>y</tt> with a <a>line</a> in between. (infixr 5)
above :: Doc e -> Doc e -> Doc e

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>aboveBreak x y</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>linebreak</tt> in between. (infixr 5)
aboveBreak :: Doc e -> Doc e -> Doc e

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>above</tt>. If a <a>group</a> undoes the line
--   breaks inserted by <tt>vsep</tt>, all documents are separated with a
--   space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>above</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>aboveBreak</tt>. If a <a>group</a> undoes the line
--   breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>aboveBreak</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: Foldable f => f (Doc e) -> Doc e

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Traversable f => Doc e -> f (Doc e) -> f (Doc e)

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It then
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc e")
--            ,("nest","Int -&gt; Doc e -&gt; Doc e")
--            ,("linebreak","Doc e")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc e
--       nest   :: Int -&gt; Doc e -&gt; Doc e
--       linebreak :: Doc e
--   </pre>
fill :: Int -> Doc e -> Doc e

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It then appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc e
--       nest   :: Int -&gt; Doc e -&gt; Doc e
--       linebreak
--              :: Doc e
--   </pre>
fillBreak :: Int -> Doc e -> Doc e

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc e -> Doc e -> Doc e -> Doc e

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc e -> Doc e

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc e -> Doc e

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc e -> Doc e

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc e -> Doc e

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc e -> Doc e

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc e -> Doc e

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc e

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc e

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc e

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc e

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc e

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc e

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc e

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc e

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc e

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc e

-- | The document <tt>semi</tt> contains a semi colon, ";".
semi :: Doc e

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc e

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc e

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc e

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc e

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc e

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc e

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a where prettyList = list . map pretty
pretty :: Pretty a => a -> Doc e
prettyList :: Pretty a => [a] -> Doc e

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc e
SFail :: SimpleDoc e
SEmpty :: SimpleDoc e
SChar :: {-# UNPACK #-} !Char -> (SimpleDoc e) -> SimpleDoc e
SText :: {-# UNPACK #-} !Int -> String -> (SimpleDoc e) -> SimpleDoc e
SLine :: {-# UNPACK #-} !Int -> (SimpleDoc e) -> SimpleDoc e
SEffect :: e -> (SimpleDoc e) -> SimpleDoc e

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc e -> SimpleDoc e

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc e -> SimpleDoc e

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures. For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20c as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check the potential
--   document up to the end of the indentation level. Thus, it will format
--   the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. mark. In addition, <tt>renderSmart</tt>
--   uses this lookahead to minimize the number of lines printed, leading
--   to more compact and visually appealing output. Consider this example
--   using the same syntax as above: <tt>aaaaaaaaaaa([abc, def, ghi])</tt>
--   When rendered with <tt>renderPretty</tt> and a page width of 20c, we
--   get: <tt> aaaaaaaaaaa([ abc , def , ghi ]) </tt> Whereas when rendered
--   with <tt>renderSmart</tt> and a page width of 20c, we get: <tt>
--   aaaaaaaaaaa( [abc, def, ghi]) </tt>
renderSmart :: Int -> Doc e -> SimpleDoc e

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
displayS :: SimpleDoc e -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc e -> IO ()
column :: (Int -> Doc e) -> Doc e
nesting :: (Int -> Doc e) -> Doc e
width :: Doc e -> (Int -> Doc e) -> Doc e
columns :: (Int -> Doc e) -> Doc e
ribbon :: (Int -> Doc e) -> Doc e

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. f a

-- | An associative operation.
--   
--   <pre>
--   (a <a>&lt;&gt;</a> b) <a>&lt;&gt;</a> c = a <a>&lt;&gt;</a> (b <a>&lt;&gt;</a> c)
--   </pre>
--   
--   If <tt>a</tt> is also a <a>Monoid</a> we further require
--   
--   <pre>
--   (<a>&lt;&gt;</a>) = <a>mappend</a>
--   </pre>
(<>) :: Semigroup a => a -> a -> a
instance Show (Doc e)
instance Traversable SimpleDoc
instance Foldable SimpleDoc
instance Functor SimpleDoc
instance MonadPlus Doc
instance Alternative Doc
instance Plus Doc
instance Alt Doc
instance Monad Doc
instance Bind Doc
instance Applicative Doc
instance Apply Doc
instance Functor Doc
instance Pretty a => Pretty (Maybe a)
instance (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance (Pretty a, Pretty b) => Pretty (a, b)
instance Pretty (Doc a)
instance Pretty Double
instance Pretty Float
instance Pretty Natural
instance Pretty Integer
instance Pretty Word64
instance Pretty Word32
instance Pretty Word16
instance Pretty Word8
instance Pretty Word
instance Pretty Int64
instance Pretty Int32
instance Pretty Int16
instance Pretty Int8
instance Pretty Int
instance Pretty a => Pretty (NonEmpty a)
instance Pretty a => Pretty (Seq a)
instance Pretty Char
instance Pretty Bool
instance Pretty ()
instance Pretty Text
instance Pretty Text
instance Pretty ByteString
instance Pretty ByteString
instance Pretty a => Pretty [a]
instance IsString (Doc e)
instance Monoid (Doc e)
instance Semigroup (Doc e)


-- | Pretty print module based on Daan Leijen's implementation of Philip
--   Wadler's "prettier printer"
--   
--   <pre>
--   "A prettier printer"
--   Draft paper, April 1997, revised March 1998.
--   <a>http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf</a>
--   </pre>
--   
--   This is an implementation of the pretty printing combinators described
--   by Philip Wadler (1997). In their bare essence, the combinators of
--   Wadler are not expressive enough to describe some commonly occurring
--   layouts. The PPrint library adds new primitives to describe these
--   layouts and works well in practice.
--   
--   The library is based on a single way to concatenate documents, which
--   is associative and has both a left and right unit. This simple design
--   leads to an efficient and short implementation. The simplicity is
--   reflected in the predictable behaviour of the combinators which make
--   them easy to use in practice.
--   
--   A thorough description of the primitive combinators and their
--   implementation can be found in Philip Wadler's paper (1997). Additions
--   and the main differences with his original paper are:
--   
--   <ul>
--   <li>The nil document is called empty.</li>
--   <li>The operator <a>&lt;/&gt;</a> is used for soft line breaks.</li>
--   <li>There are three new primitives: <a>align</a>, <a>fill</a> and
--   <a>fillBreak</a>. These are very useful in practice.</li>
--   <li>Lots of other useful combinators, like <a>fillSep</a> and
--   <a>list</a>.</li>
--   <li>There are two renderers, <a>renderPretty</a> for pretty printing
--   and <a>renderCompact</a> for compact output. The pretty printing
--   algorithm also uses a ribbon-width now for even prettier output.</li>
--   <li>There are two displayers, <a>displayS</a> for strings and
--   <a>displayIO</a> for file based output.</li>
--   <li>There is a <a>Pretty</a> class.</li>
--   <li>The implementation uses optimised representations and strictness
--   annotations.</li>
--   <li>A type argument has been added and embedded <tt>effects</tt> can
--   be seen in the SimpleDoc type.</li>
--   </ul>
module Text.PrettyPrint.Free

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" `above` text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc e

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 100 characters and a
--   ribbon width of 40 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
putDoc :: Doc e -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 100 characters
--   and a ribbon width of 40 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
hPutDoc :: Handle -> Doc e -> IO ()

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc e

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function
--   <tt>string</tt> should be used.
text :: String -> Doc e

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" `above` text "world") `above` text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc e -> Doc e

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc e

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc e

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc e -> Doc e

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc e

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc e

-- | A linebreak that can not be flattened; it is guaranteed to be rendered
--   as a newline.
hardline :: Doc e

-- | <tt>flatAlt</tt> creates a document that changes when flattened;
--   normally it is rendered as the first argument, but when flattened is
--   rendered as the second.
flatAlt :: Doc e -> Doc e -> Doc e
flatten :: Doc e -> Doc e

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (above x y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc e -> Doc e

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc e -> Doc e

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc e -> Doc e

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10, 200, 3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [ 10
--        , 200
--        , 3000 ]
--   </pre>
encloseSep :: Foldable f => Doc e -> Doc e -> Doc e -> f (Doc e) -> Doc e

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semi colons and encloses them in braces. The
--   documents are rendered horizontally if that fits the page. Otherwise
--   they are aligned vertically. All semi colons are put in front of the
--   elements.
semiBraces :: Foldable f => f (Doc e) -> Doc e
(<+>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>above x y</tt> concatenates document <tt>x</tt> and
--   <tt>y</tt> with a <a>line</a> in between. (infixr 5)
above :: Doc e -> Doc e -> Doc e

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>aboveBreak x y</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>linebreak</tt> in between. (infixr 5)
aboveBreak :: Doc e -> Doc e -> Doc e

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc e -> Doc e -> Doc e

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>above</tt>. If a <a>group</a> undoes the line
--   breaks inserted by <tt>vsep</tt>, all documents are separated with a
--   space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>above</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>aboveBreak</tt>. If a <a>group</a> undoes the line
--   breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: Foldable f => f (Doc e) -> Doc e

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>aboveBreak</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: Foldable f => f (Doc e) -> Doc e

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Traversable f => Doc e -> f (Doc e) -> f (Doc e)

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It then
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc e")
--            ,("nest","Int -&gt; Doc e -&gt; Doc e")
--            ,("linebreak","Doc e")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc e
--       nest   :: Int -&gt; Doc e -&gt; Doc e
--       linebreak :: Doc e
--   </pre>
fill :: Int -> Doc e -> Doc e

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It then appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc e
--       nest   :: Int -&gt; Doc e -&gt; Doc e
--       linebreak
--              :: Doc e
--   </pre>
fillBreak :: Int -> Doc e -> Doc e

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc e -> Doc e -> Doc e -> Doc e

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc e -> Doc e

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc e -> Doc e

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc e -> Doc e

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc e -> Doc e

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc e -> Doc e

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc e -> Doc e

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc e

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc e

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc e

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc e

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc e

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc e

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc e

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc e

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc e

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc e

-- | The document <tt>semi</tt> contains a semi colon, ";".
semi :: Doc e

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc e

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc e

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc e

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc e

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc e

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc e

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a where prettyList = list . map pretty
pretty :: Pretty a => a -> Doc e
prettyList :: Pretty a => [a] -> Doc e

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc e
SFail :: SimpleDoc e
SEmpty :: SimpleDoc e
SChar :: {-# UNPACK #-} !Char -> (SimpleDoc e) -> SimpleDoc e
SText :: {-# UNPACK #-} !Int -> String -> (SimpleDoc e) -> SimpleDoc e
SLine :: {-# UNPACK #-} !Int -> (SimpleDoc e) -> SimpleDoc e
SEffect :: e -> (SimpleDoc e) -> SimpleDoc e

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc e -> SimpleDoc e

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc e -> SimpleDoc e

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures. For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20c as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check the potential
--   document up to the end of the indentation level. Thus, it will format
--   the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. mark. In addition, <tt>renderSmart</tt>
--   uses this lookahead to minimize the number of lines printed, leading
--   to more compact and visually appealing output. Consider this example
--   using the same syntax as above: <tt>aaaaaaaaaaa([abc, def, ghi])</tt>
--   When rendered with <tt>renderPretty</tt> and a page width of 20c, we
--   get: <tt> aaaaaaaaaaa([ abc , def , ghi ]) </tt> Whereas when rendered
--   with <tt>renderSmart</tt> and a page width of 20c, we get: <tt>
--   aaaaaaaaaaa( [abc, def, ghi]) </tt>
renderSmart :: Int -> Doc e -> SimpleDoc e

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
displayS :: SimpleDoc e -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc e -> IO ()
column :: (Int -> Doc e) -> Doc e
nesting :: (Int -> Doc e) -> Doc e
width :: Doc e -> (Int -> Doc e) -> Doc e
columns :: (Int -> Doc e) -> Doc e

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. f a

-- | An associative operation.
--   
--   <pre>
--   (a <a>&lt;&gt;</a> b) <a>&lt;&gt;</a> c = a <a>&lt;&gt;</a> (b <a>&lt;&gt;</a> c)
--   </pre>
--   
--   If <tt>a</tt> is also a <a>Monoid</a> we further require
--   
--   <pre>
--   (<a>&lt;&gt;</a>) = <a>mappend</a>
--   </pre>
(<>) :: Semigroup a => a -> a -> a
