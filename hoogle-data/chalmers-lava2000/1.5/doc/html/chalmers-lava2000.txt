-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hardware description EDSL
--   
@package chalmers-lava2000
@version 1.5

module Lava.LavaRandom
type Rnd = StdGen
newRnd :: IO StdGen

-- | The <a>next</a> operation returns an <a>Int</a> that is uniformly
--   distributed in the range returned by <a>genRange</a> (including both
--   end points), and a new generator.
next :: RandomGen g => g -> (Int, g)

-- | The <a>split</a> operation allows one to obtain two distinct random
--   number generators. This is very useful in functional programs (for
--   example, when passing a random number generator down to recursive
--   calls), but very little work has been done on statistically robust
--   implementations of <a>split</a> ([<a>System.Random\#Burton</a>,
--   <a>System.Random\#Hellekalek</a>] are the only examples we know of).
split :: RandomGen g => g -> (g, g)

module Lava.MyST
data ST s a
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
runST :: (forall s. ST s a) -> a
fixST :: (a -> ST s a) -> ST s a
unsafePerformST :: ST s a -> a
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOtoST :: IO a -> ST s a
instance Eq (STRef s a)
instance Monad (ST s)
instance Applicative (ST s)
instance Functor (ST s)

module Lava.Ref
data Ref a
ref :: a -> Ref a
deref :: Ref a -> a
memoRef :: (Ref a -> b) -> (Ref a -> b)
data TableIO a b
tableIO :: IO (TableIO a b)
extendIO :: TableIO a b -> Ref a -> b -> IO ()
findIO :: TableIO a b -> Ref a -> IO (Maybe b)
memoRefIO :: (Ref a -> IO b) -> (Ref a -> IO b)
data TableST s a b
tableST :: ST s (TableST s a b)
extendST :: TableST s a b -> Ref a -> b -> ST s ()
findST :: TableST s a b -> Ref a -> ST s (Maybe b)
memoRefST :: (Ref a -> ST s b) -> (Ref a -> ST s b)
instance Eq (TableIO a b)
instance Eq (TableST s a b)
instance Show a => Show (Ref a)
instance Eq (Ref a)

module Lava.SignalTry
data Signal a
Value :: a -> Signal a
Symbol :: (Ref (Symbol a)) -> Signal a
data Symbol a
Function :: String -> ([x] -> [y] -> a) -> [Signal x] -> [Signal y] -> Symbol a
Delay :: (Signal a) -> (Signal a) -> Symbol a
Variable :: String -> Symbol a
and2 :: (Signal Bool, Signal Bool) -> Signal Bool

module Lava.IOBuffering
noBuffering :: IO ()

module Lava.LavaDir
getLavaDir :: IO FilePath

module Lava.Error
data Error
DelayEval :: Error
VarEval :: Error
CombinationalLoop :: Error
BadCombinationalLoop :: Error
UndefinedWire :: Error
IncompatibleStructures :: Error
NoEquality :: Error
NoArithmetic :: Error
EnumOnSymbols :: Error
Internal_OptionNotFound :: Error
wrong :: Error -> a
instance Eq Error
instance Show Error

module Lava.Sequent
class Functor s => Sequent s
sequent :: (Sequent s, Monad m) => s (m a) -> m (s a)
mmap :: (Monad m, Sequent s) => (a -> m b) -> s a -> m (s b)
instance Sequent []

module Lava.Signal
newtype Signal a
Signal :: Symbol -> Signal a
newtype Symbol
Symbol :: (Ref (S Symbol)) -> Symbol
data S s
Bool :: Bool -> S s
Inv :: s -> S s
And :: [s] -> S s
Or :: [s] -> S s
Xor :: [s] -> S s
VarBool :: String -> S s
DelayBool :: s -> s -> S s
Int :: Int -> S s
Neg :: s -> S s
Div :: s -> s -> S s
Mod :: s -> s -> S s
Plus :: [s] -> S s
Times :: [s] -> S s
Gte :: s -> s -> S s
Equal :: [s] -> S s
If :: s -> s -> s -> S s
VarInt :: String -> S s
DelayInt :: s -> s -> S s
symbol :: S Symbol -> Symbol
unsymbol :: Symbol -> S Symbol
bool :: Bool -> Signal Bool
low :: Signal Bool
high :: Signal Bool
inv :: Signal Bool -> Signal Bool
andl :: [Signal Bool] -> Signal Bool
xorl :: [Signal Bool] -> Signal Bool
orl :: [Signal Bool] -> Signal Bool
equalBool :: Signal Bool -> Signal Bool -> Signal Bool
ifBool :: Signal Bool -> (Signal Bool, Signal Bool) -> Signal Bool
delayBool :: Signal Bool -> Signal Bool -> Signal Bool
varBool :: String -> Signal Bool
int :: Int -> Signal Int
neg :: Signal Int -> Signal Int
divide :: Signal Int -> Signal Int -> Signal Int
modulo :: Signal Int -> Signal Int -> Signal Int
plusl :: [Signal Int] -> Signal Int
timesl :: [Signal Int] -> Signal Int
equall :: [Signal Int] -> Signal Bool
gteInt :: Signal Int -> Signal Int -> Signal Bool
equalInt :: Signal Int -> Signal Int -> Signal Bool
ifInt :: Signal Bool -> (Signal Int, Signal Int) -> Signal a
delayInt :: Signal Int -> Signal Int -> Signal Int
varInt :: String -> Signal Int
lift0 :: S Symbol -> Signal a
lift1 :: (Symbol -> S Symbol) -> Signal a -> Signal b
lift2 :: (Symbol -> Symbol -> S Symbol) -> Signal a -> Signal b -> Signal c
lift3 :: (Symbol -> Symbol -> Symbol -> S Symbol) -> Signal a -> Signal b -> Signal c -> Signal d
liftl :: ([Symbol] -> S Symbol) -> [Signal a] -> Signal c
eval :: S (S a) -> S a
evalLazy :: S (Maybe (S a)) -> Maybe (S a)
arguments :: S a -> [a]
zips :: S [a] -> [S a]
instance Show a => Show (S a)
instance Show Symbol
instance Show (Signal a)
instance Sequent S
instance Functor S
instance Eq (Signal a)

module Lava.Generic
data Struct a
Compound :: [Struct a] -> Struct a
Object :: a -> Struct a
flatten :: Struct a -> [a]
transStruct :: Struct [a] -> [Struct a]
class Generic a
struct :: Generic a => a -> Struct Symbol
construct :: Generic a => Struct Symbol -> a
data Ops
Ops :: (Symbol -> Symbol -> Signal Bool) -> (Symbol -> Symbol -> Symbol) -> (Signal Bool -> (Symbol, Symbol) -> Symbol) -> (String -> Symbol) -> Symbol -> Ops
equalSymbol :: Ops -> Symbol -> Symbol -> Signal Bool
delaySymbol :: Ops -> Symbol -> Symbol -> Symbol
ifSymbol :: Ops -> Signal Bool -> (Symbol, Symbol) -> Symbol
varSymbol :: Ops -> String -> Symbol
zeroSymbol :: Ops -> Symbol
opsBool :: Ops
opsInt :: Ops
unSignal :: Signal a -> Symbol
ops :: Symbol -> Ops
equal :: Generic a => (a, a) -> Signal Bool
delay :: Generic a => a -> a -> a
zeroify :: Generic a => a -> a
symbolize :: Generic a => String -> a -> a
pickSymbol :: Generic a => String -> a -> Symbol
class ConstructiveSig a
zeroSig :: ConstructiveSig a => Signal a
varSig :: ConstructiveSig a => String -> Signal a
randomSig :: ConstructiveSig a => Rnd -> Signal a
class Generic a => Constructive a
zero :: Constructive a => a
var :: Constructive a => String -> a
random :: Constructive a => Rnd -> a
zeroList :: Constructive a => Int -> [a]
varList :: Constructive a => Int -> String -> [a]
randomList :: Constructive a => Int -> Rnd -> [a]
splitRndList :: Rnd -> [Rnd]
valRnd :: Rnd -> Int
class ConstructiveSig a => FiniteSig a
domainSig :: FiniteSig a => [Signal a]
class Constructive a => Finite a
domain :: Finite a => [a]
domainList :: Finite a => Int -> [[a]]
class Choice a
ifThenElse :: Choice a => Signal Bool -> (a, a) -> a
mux :: Choice a => (Signal Bool, (a, a)) -> a
strongZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
lazyZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
instance Eq a => Eq (Struct a)
instance Show a => Show (Struct a)
instance Choice b => Choice (a -> b)
instance (Choice a, Choice b, Choice c, Choice d, Choice e, Choice f, Choice g) => Choice (a, b, c, d, e, f, g)
instance (Choice a, Choice b, Choice c, Choice d, Choice e, Choice f) => Choice (a, b, c, d, e, f)
instance (Choice a, Choice b, Choice c, Choice d, Choice e) => Choice (a, b, c, d, e)
instance (Choice a, Choice b, Choice c, Choice d) => Choice (a, b, c, d)
instance (Choice a, Choice b, Choice c) => Choice (a, b, c)
instance (Choice a, Choice b) => Choice (a, b)
instance Choice a => Choice [a]
instance Choice ()
instance Choice (Signal a)
instance Choice Symbol
instance (Finite a, Finite b, Finite c, Finite d, Finite e, Finite f, Finite g) => Finite (a, b, c, d, e, f, g)
instance (Finite a, Finite b, Finite c, Finite d, Finite e, Finite f) => Finite (a, b, c, d, e, f)
instance (Finite a, Finite b, Finite c, Finite d, Finite e) => Finite (a, b, c, d, e)
instance (Finite a, Finite b, Finite c, Finite d) => Finite (a, b, c, d)
instance (Finite a, Finite b, Finite c) => Finite (a, b, c)
instance (Finite a, Finite b) => Finite (a, b)
instance Finite ()
instance FiniteSig a => Finite (Signal a)
instance FiniteSig Bool
instance (Constructive a, Constructive b, Constructive c, Constructive d, Constructive e, Constructive f, Constructive g) => Constructive (a, b, c, d, e, f, g)
instance (Constructive a, Constructive b, Constructive c, Constructive d, Constructive e, Constructive f) => Constructive (a, b, c, d, e, f)
instance (Constructive a, Constructive b, Constructive c, Constructive d, Constructive e) => Constructive (a, b, c, d, e)
instance (Constructive a, Constructive b, Constructive c, Constructive d) => Constructive (a, b, c, d)
instance (Constructive a, Constructive b, Constructive c) => Constructive (a, b, c)
instance (Constructive a, Constructive b) => Constructive (a, b)
instance Constructive ()
instance ConstructiveSig a => Constructive (Signal a)
instance ConstructiveSig Int
instance ConstructiveSig Bool
instance (Generic a, Generic b, Generic c, Generic d, Generic e, Generic f, Generic g) => Generic (a, b, c, d, e, f, g)
instance (Generic a, Generic b, Generic c, Generic d, Generic e, Generic f) => Generic (a, b, c, d, e, f)
instance (Generic a, Generic b, Generic c, Generic d, Generic e) => Generic (a, b, c, d, e)
instance (Generic a, Generic b, Generic c, Generic d) => Generic (a, b, c, d)
instance (Generic a, Generic b, Generic c) => Generic (a, b, c)
instance (Generic a, Generic b) => Generic (a, b)
instance Generic a => Generic [a]
instance Generic ()
instance Generic (Signal a)
instance Generic Symbol
instance Sequent Struct
instance Functor Struct

module Lava.Operators
and2 :: (Signal Bool, Signal Bool) -> Signal Bool
or2 :: (Signal Bool, Signal Bool) -> Signal Bool
xor2 :: (Signal Bool, Signal Bool) -> Signal Bool
nand2 :: (Signal Bool, Signal Bool) -> Signal Bool
nor2 :: (Signal Bool, Signal Bool) -> Signal Bool
xnor2 :: (Signal Bool, Signal Bool) -> Signal Bool
equiv :: (Signal Bool, Signal Bool) -> Signal Bool
impl :: (Signal Bool, Signal Bool) -> Signal Bool
nandl :: [Signal Bool] -> Signal Bool
norl :: [Signal Bool] -> Signal Bool
plus :: (Signal Int, Signal Int) -> Signal Int
sub :: (Signal Int, Signal Int) -> Signal Int
times :: (Signal Int, Signal Int) -> Signal Int
imod :: (Signal Int, Signal Int) -> Signal Int
idiv :: (Signal Int, Signal Int) -> Signal Int
(|->) :: Generic a => a -> a -> a
(<==>) :: Generic a => a -> a -> Signal Bool
(<&>) :: Signal Bool -> Signal Bool -> Signal Bool
(<|>) :: Signal Bool -> Signal Bool -> Signal Bool
(<#>) :: Signal Bool -> Signal Bool -> Signal Bool
(<=>) :: Signal Bool -> Signal Bool -> Signal Bool
(==>) :: Signal Bool -> Signal Bool -> Signal Bool
(<==) :: Signal Bool -> Signal Bool -> Signal Bool
(%%) :: Signal Int -> Signal Int -> Signal Int
gte :: (Signal Int, Signal Int) -> Signal Bool
(>>==) :: Signal Int -> Signal Int -> Signal Bool
imin :: (Signal Int, Signal Int) -> Signal Int
imax :: (Signal Int, Signal Int) -> Signal Int
class SignalInt a
toSignalInt :: SignalInt a => Signal a -> Signal Int
fromSignalInt :: SignalInt a => Signal Int -> Signal a
int2bit :: Signal Int -> Signal Bool
bit2int :: Signal Bool -> Signal Int
instance SignalInt a => Ord (Signal a)
instance SignalInt a => Enum (Signal a)
instance SignalInt a => Fractional (Signal a)
instance SignalInt a => Num (Signal a)
instance SignalInt Int

module Lava.ConstructiveAnalysis
constructive :: (Generic a, Generic b) => (a -> b) -> (a -> Signal Bool)

module Lava.Property
data Gen a
generate :: Gen a -> IO a
class ChoiceWithSig a
class Fresh a
fresh :: Fresh a => Gen a
class CoFresh a
cofresh :: (CoFresh a, Choice b, Fresh b) => Gen b -> Gen (a -> b)
double :: Gen a -> Gen (a, a)
triple :: Gen a -> Gen (a, a, a)
list :: Fresh a => Int -> Gen [a]
listOf :: Int -> Gen a -> Gen [a]
results :: Int -> Gen (a -> b) -> Gen (a -> [b])
sequential :: (CoFresh a, Fresh b, Choice b) => Int -> Gen (a -> b)
forAll :: (ShowModel a, Checkable b) => Gen a -> (a -> b) -> Property
newtype Property
P :: (Gen ([Signal Bool], Model -> [[String]])) -> Property
class Checkable a
property :: Checkable a => a -> Property
class ShowModel a
showModel :: ShowModel a => Model -> a -> [String]
type Model = [(String, [String])]
properties :: Checkable a => a -> IO ([Signal Bool], Model -> [[String]])
instance ShowModel (a -> b)
instance ShowModel a => ShowModel [a]
instance (ShowModel a, ShowModel b, ShowModel c, ShowModel d, ShowModel e, ShowModel f, ShowModel g) => ShowModel (a, b, c, d, e, f, g)
instance (ShowModel a, ShowModel b, ShowModel c, ShowModel d, ShowModel e, ShowModel f) => ShowModel (a, b, c, d, e, f)
instance (ShowModel a, ShowModel b, ShowModel c, ShowModel d, ShowModel e) => ShowModel (a, b, c, d, e)
instance (ShowModel a, ShowModel b, ShowModel c, ShowModel d) => ShowModel (a, b, c, d)
instance (ShowModel a, ShowModel b, ShowModel c) => ShowModel (a, b, c)
instance (ShowModel a, ShowModel b) => ShowModel (a, b)
instance ShowModel ()
instance ShowModel (Signal a)
instance (Fresh a, ShowModel a, Checkable b) => Checkable (a -> b)
instance Checkable a => Checkable (Gen a)
instance Checkable a => Checkable [a]
instance Checkable a => Checkable (Signal a)
instance Checkable Bool
instance Checkable Property
instance (Finite a, CoFresh b) => CoFresh (a -> b)
instance CoFresh a => CoFresh [a]
instance (CoFresh a, Choice b, Fresh b) => Fresh (a -> b)
instance (CoFresh a, CoFresh b, CoFresh c, CoFresh d, CoFresh e, CoFresh f, CoFresh g) => CoFresh (a, b, c, d, e, f, g)
instance (CoFresh a, CoFresh b, CoFresh c, CoFresh d, CoFresh e, CoFresh f) => CoFresh (a, b, c, d, e, f)
instance (CoFresh a, CoFresh b, CoFresh c, CoFresh d, CoFresh e) => CoFresh (a, b, c, d, e)
instance (CoFresh a, CoFresh b, CoFresh c, CoFresh d) => CoFresh (a, b, c, d)
instance (CoFresh a, CoFresh b, CoFresh c) => CoFresh (a, b, c)
instance (CoFresh a, CoFresh b) => CoFresh (a, b)
instance ChoiceWithSig a => CoFresh (Signal a)
instance CoFresh ()
instance ChoiceWithSig Bool
instance (Fresh a, Fresh b, Fresh c, Fresh d, Fresh e, Fresh f, Fresh g) => Fresh (a, b, c, d, e, f, g)
instance (Fresh a, Fresh b, Fresh c, Fresh d, Fresh e, Fresh f) => Fresh (a, b, c, d, e, f)
instance (Fresh a, Fresh b, Fresh c, Fresh d, Fresh e) => Fresh (a, b, c, d, e)
instance (Fresh a, Fresh b, Fresh c, Fresh d) => Fresh (a, b, c, d)
instance (Fresh a, Fresh b, Fresh c) => Fresh (a, b, c)
instance (Fresh a, Fresh b) => Fresh (a, b)
instance ConstructiveSig a => Fresh (Signal a)
instance Fresh ()
instance Monad Gen
instance Applicative Gen
instance Functor Gen

module Lava.Netlist
netlist :: Functor f => (S a -> a) -> f Symbol -> f a
netlistIO :: Sequent f => IO v -> (v -> S v -> IO ()) -> f Symbol -> IO (f v)
netlistST :: Sequent f => ST s v -> (v -> S v -> ST s ()) -> f Symbol -> ST s (f v)

module Lava.Combinational
simulate :: Generic b => (a -> b) -> a -> b

module Lava.Sequential
simulateSeq :: (Generic a, Generic b) => (a -> b) -> [a] -> [b]

module Lava.Test
test :: (Constructive a, Show b, Generic b) => (a -> b) -> IO [b]

module Lava.SequentialConstructive
simulateCon :: (Generic a, Generic b) => (a -> b) -> [a] -> [b]

module Lava.Verification
data Option
Name :: String -> Option
ShowTime :: Option
Sat :: Int -> Option
NoBacktracking :: Option
Depth :: Int -> Option
Increasing :: Option
RestrictStates :: Option
verify :: Checkable a => a -> IO ProofResult
verifyWith :: Checkable a => [Option] -> a -> IO ProofResult
data ProofResult
Valid :: ProofResult
Falsifiable :: ProofResult
Indeterminate :: ProofResult
verifyDir :: FilePath
checkVerifyDir :: IO ()
instance Eq Option
instance Show Option
instance Eq ProofResult
instance Show ProofResult
instance Show Indexed
instance Show Timed

module Lava.Vis
vis :: Checkable a => a -> IO ProofResult
writeVis :: (Constructive a, Generic b) => String -> (a -> b) -> IO ()
writeVisInput :: (Generic a, Generic b) => String -> (a -> b) -> a -> IO ()
writeVisInputOutput :: (Generic a, Generic b) => String -> (a -> b) -> a -> b -> IO ()
equivCheckVisInput :: (Generic b1, Generic a, Generic b) => (a -> b) -> (a -> b1) -> a -> IO ProofResult

module Lava.Fixit
fixit :: Checkable a => a -> IO ProofResult

module Lava.Smv
smv :: Checkable a => a -> IO ProofResult

module Lava.Satzoo
satzoo :: Checkable a => a -> IO ProofResult

module Lava.Retime
timeTransform :: (Generic a, Generic b) => (a -> b) -> ([a] -> [b])

module Lava.Vhdl
writeVhdl :: (Constructive a, Generic b) => String -> (a -> b) -> IO ()
writeVhdlInput :: (Generic a, Generic b) => String -> (a -> b) -> a -> IO ()
writeVhdlInputOutput :: (Generic a, Generic b) => String -> (a -> b) -> a -> b -> IO ()

module Lava.Captain
captain :: Checkable a => a -> IO ProofResult

module Lava.Eprover
eprover :: Checkable a => a -> IO ProofResult

module Lava.HeerHugo
heerhugo :: Checkable a => a -> IO ProofResult

module Lava.Isc
data IscMethod
StepMin :: IscMethod
StepMax :: IscMethod
Mixed :: IscMethod
Bmc :: IscMethod
isc :: Checkable a => a -> IO ProofResult
iscWith :: Checkable a => IscMethod -> Int -> a -> IO ProofResult
instance Show a => Show (Sign a)
instance Read a => Read (Sign a)
instance Functor Sign

module Lava.Limmat
limmat :: Checkable a => a -> IO ProofResult

module Lava.Modoc
modoc :: Checkable a => a -> IO ProofResult

module Lava.Satnik
satnik :: Checkable a => a -> IO ProofResult

module Lava.Stable
stable :: Generic a => a -> Signal Bool

module Lava.Table
table :: Sequent f => f Symbol -> ([(Int, S Int)], f Int)
tableProp :: Checkable a => a -> IO ([(Int, S Int)], [Int])

module Lava.Zchaff
zchaff :: Checkable a => a -> IO ProofResult

module Lava

module Lava.Patterns
swap :: (t1, t) -> (t, t1)
swapl :: [t] -> [t]
copy :: t -> (t, t)
riffle :: [a] -> [a]
unriffle :: [t] -> [t]
zipp :: ([t], [t1]) -> [(t, t1)]
unzipp :: [(t, t1)] -> ([t], [t1])
pair :: [t] -> [(t, t)]
unpair :: [(a, a)] -> [a]
halveList :: [a] -> ([a], [a])
append :: ([a], [a]) -> [a]
serial :: (a -> b) -> (b -> c) -> a -> c
(->-) :: (a -> b) -> (b -> c) -> a -> c
compose :: [b -> b] -> b -> b
composeN :: Int -> (b -> b) -> b -> b
par :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
(-|-) :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
parl :: ([a] -> [a1]) -> ([a] -> [a1]) -> [a] -> [a1]
two :: ([a] -> [a1]) -> [a] -> [a1]
ilv :: ([t] -> [a]) -> [t] -> [a]
iter :: (Num a, Eq a) => a -> (t -> t) -> t -> t
twoN :: (Num a, Eq a) => a -> ([a1] -> [a2]) -> [a1] -> [a2]
ilvN :: (Num a, Eq a) => a -> ([t] -> [a1]) -> [t] -> [a1]
bfly :: (Num a1, Eq a1) => a1 -> ([a] -> [a]) -> [a] -> [a]
pmap :: ((t, t) -> (a, a)) -> [t] -> [a]
tri :: (a -> a) -> [a] -> [a]
mirror :: ((t, t1) -> (t3, t2)) -> (t1, t) -> (t2, t3)
row :: ((t2, t1) -> (t, t2)) -> (t2, [t1]) -> ([t], t2)
column :: ((t2, t) -> (t, t1)) -> ([t2], t) -> (t, [t1])
grid :: ((t1, t) -> (t, t1)) -> ([t1], [t]) -> ([t], [t1])

module Lava.Arithmetic
halfAdd :: (Signal Bool, Signal Bool) -> (Signal Bool, Signal Bool)
fullAdd :: (Signal Bool, (Signal Bool, Signal Bool)) -> (Signal Bool, Signal Bool)
bitAdder :: (Signal Bool, [Signal Bool]) -> ([Signal Bool], Signal Bool)
adder :: (Signal Bool, ([Signal Bool], [Signal Bool])) -> ([Signal Bool], Signal Bool)
binAdder :: ([Signal Bool], [Signal Bool]) -> [Signal Bool]
bitMulti :: (Signal Bool, [Signal Bool]) -> [Signal Bool]
multi :: ([Signal Bool], [Signal Bool]) -> [Signal Bool]
numBreak :: Signal Int -> (Signal Bool, Signal Int)
int2bin :: (Num a, Eq a) => a -> Signal Int -> [Signal Bool]
bin2int :: [Signal Bool] -> Signal Int

module Lava.SequentialCircuits
edge :: Signal Bool -> Signal Bool
toggle :: Signal Bool -> Signal Bool
delayClk :: (Generic a, Choice a) => a -> (Signal Bool, a) -> a
delayN :: (Generic a1, Num a, Eq a) => a -> a1 -> a1 -> a1
always :: Signal Bool -> Signal Bool
constant :: Constructive a => a -> Signal Bool
puls :: (Num a, Eq a) => a -> () -> Signal Bool
outputList :: Generic b => [b] -> () -> b
rowSeq :: Constructive t1 => ((t1, t2) -> (t, t1)) -> t2 -> t
rowSeqReset :: (Constructive t1, Choice t1) => ((t1, t2) -> (t, t1)) -> (Signal Bool, t2) -> t
rowSeqPeriod :: (Constructive t1, Choice t1, Num a, Eq a) => a -> ((t1, t2) -> (t, t1)) -> t2 -> t
