-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FoldMap lists
--   
--   FoldMap lists are lists represented by their foldMap function. FoldMap
--   lists have O(1) cons, snoc and append, just like DLists, but other
--   operations might have favorable performance characteristics as well.
--   These wild claims are still completely unverified though.
@package fmlist
@version 0.9


-- | FoldMap lists: lists represented by their <a>foldMap</a> function.
--   
--   Examples:
--   
--   <pre>
--   -- A right-infinite list
--   c = 1 `cons` c
--   </pre>
--   
--   <pre>
--   -- A left-infinite list
--   d = d `snoc` 2
--   </pre>
--   
--   <pre>
--   -- A middle-infinite list ??
--   e = c `append` d
--   </pre>
--   
--   <pre>
--   *&gt; head e
--   1
--   *&gt; last e
--   2
--   </pre>
module Data.FMList

-- | <a>FMList</a> is a <a>foldMap</a> function wrapped up in a newtype.
newtype FMList a
FM :: (forall m. Monoid m => (a -> m) -> m) -> FMList a
unFM :: FMList a -> forall m. Monoid m => (a -> m) -> m

-- | The function <a>transform</a> transforms a list by changing the map
--   function that is passed to <a>foldMap</a>.
--   
--   It has the following property:
--   
--   <pre>
--   transform a . transform b = transform (b . a)
--   </pre>
--   
--   For example:
--   
--   <ul>
--   <li><pre> m &gt;&gt;= g</pre></li>
--   <li><pre>= flatten (fmap g m)</pre></li>
--   <li><pre>= flatten . fmap g $ m</pre></li>
--   <li><pre>= transform foldMap . transform (. g) $ m</pre></li>
--   <li><pre>= transform ((. g) . foldMap) m</pre></li>
--   <li><pre>= transform (\f -&gt; foldMap f . g) m</pre></li>
--   </ul>
transform :: (forall m. Monoid m => (a -> m) -> (b -> m)) -> FMList b -> FMList a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => forall a. f a
singleton :: a -> FMList a
cons :: a -> FMList a -> FMList a
snoc :: FMList a -> a -> FMList a
pair :: a -> a -> FMList a
append :: FMList a -> FMList a -> FMList a
fromList :: [a] -> FMList a
fromFoldable :: Foldable f => f a -> FMList a
null :: FMList a -> Bool
length :: FMList a -> Int
genericLength :: Num b => FMList a -> b
head :: FMList a -> a
tail :: FMList a -> FMList a
last :: FMList a -> a
init :: FMList a -> FMList a
reverse :: FMList a -> FMList a

-- | List of elements of a structure.
toList :: Foldable t => t a -> [a]
flatten :: Foldable t => FMList (t a) -> FMList a

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and concat the monoid results.
foldMapA :: (Foldable t, Applicative f, Monoid m) => (a -> f m) -> t a -> f m
filter :: (a -> Bool) -> FMList a -> FMList a
take :: (Ord n, Num n) => n -> FMList a -> FMList a
drop :: (Ord n, Num n) => n -> FMList a -> FMList a
takeWhile :: (a -> Bool) -> FMList a -> FMList a
dropWhile :: (a -> Bool) -> FMList a -> FMList a
zip :: FMList a -> FMList b -> FMList (a, b)
zipWith :: (a -> b -> c) -> FMList a -> FMList b -> FMList c
iterate :: (a -> a) -> a -> FMList a

-- | <a>repeat</a> buids an infinite list of a single value. While
--   infinite, the result is still accessible from both the start and end.
repeat :: a -> FMList a

-- | <a>cycle</a> repeats a list to create an infinite list. It is also
--   accessible from the end, where <tt>last (cycle l)</tt> equals <tt>last
--   l</tt>.
cycle :: FMList a -> FMList a

-- | <a>unfold</a> builds a list from a seed value. The function takes the
--   seed and returns an <a>FMList</a> of values. If the value is
--   <a>Right</a> <tt>a</tt>, then <tt>a</tt> is appended to the result,
--   and if the value is <a>Left</a> <tt>b</tt>, then <tt>b</tt> is used as
--   seed value in a recursive call.
--   
--   A simple use of <a>unfold</a> (simulating unfoldl):
--   
--   <pre>
--   *&gt; unfold (\b -&gt; if b == 0 then empty else Left (b-1) `pair` Right b) 10
--   fromList [1,2,3,4,5,6,7,8,9,10]
--   </pre>
unfold :: (b -> FMList (Either b a)) -> b -> FMList a

-- | <a>unfoldr</a> builds an <a>FMList</a> from a seed value from left to
--   right. The function takes the element and returns <a>Nothing</a> if it
--   is done producing the list or returns <a>Just</a> <tt>(a,b)</tt>, in
--   which case, <tt>a</tt> is a appended to the result and <tt>b</tt> is
--   used as the next seed value in a recursive call.
--   
--   A simple use of <a>unfoldr</a>:
--   
--   <pre>
--   *&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   fromList [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> FMList a
instance Show a => Show (FMList a)
instance Alternative FMList
instance MonadPlus FMList
instance Monoid (FMList a)
instance Applicative FMList
instance Monad FMList
instance Traversable FMList
instance Foldable FMList
instance Functor FMList
instance (Applicative f, Monoid m) => Monoid (WrapApp f m)
