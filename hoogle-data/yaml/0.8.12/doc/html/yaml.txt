-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for parsing and rendering YAML documents.
--   
@package yaml
@version 0.8.12


-- | Low-level, streaming YAML interface. For a higher-level interface, see
--   <a>Data.Yaml</a>.
module Text.Libyaml
data Event
EventStreamStart :: Event
EventStreamEnd :: Event
EventDocumentStart :: Event
EventDocumentEnd :: Event
EventAlias :: !AnchorName -> Event
EventScalar :: !ByteString -> !Tag -> !Style -> !Anchor -> Event
EventSequenceStart :: !Anchor -> Event
EventSequenceEnd :: Event
EventMappingStart :: !Anchor -> Event
EventMappingEnd :: Event
data Style
Any :: Style
Plain :: Style
SingleQuoted :: Style
DoubleQuoted :: Style
Literal :: Style
Folded :: Style
PlainNoTag :: Style
data Tag
StrTag :: Tag
FloatTag :: Tag
NullTag :: Tag
BoolTag :: Tag
SetTag :: Tag
IntTag :: Tag
SeqTag :: Tag
MapTag :: Tag
UriTag :: String -> Tag
NoTag :: Tag
type AnchorName = String
type Anchor = Maybe AnchorName
encode :: MonadResource m => Consumer Event m ByteString
decode :: MonadResource m => ByteString -> Producer m Event
encodeFile :: MonadResource m => FilePath -> Consumer Event m ()
decodeFile :: MonadResource m => FilePath -> Producer m Event
data YamlException
YamlException :: String -> YamlException

-- | problem, context, index, position line, position column
YamlParseException :: String -> String -> YamlMark -> YamlException
yamlProblem :: YamlException -> String
yamlContext :: YamlException -> String
yamlProblemMark :: YamlException -> YamlMark

-- | The pointer position
data YamlMark
YamlMark :: Int -> Int -> Int -> YamlMark
yamlIndex :: YamlMark -> Int
yamlLine :: YamlMark -> Int
yamlColumn :: YamlMark -> Int
instance Typeable Style
instance Typeable Tag
instance Typeable ToEventRawException
instance Typeable YamlException
instance Show Style
instance Read Style
instance Eq Style
instance Enum Style
instance Bounded Style
instance Ord Style
instance Data Style
instance Show Tag
instance Eq Tag
instance Read Tag
instance Data Tag
instance Show Event
instance Eq Event
instance Enum EventType
instance Show EventType
instance Show ToEventRawException
instance Show YamlMark
instance Show YamlException
instance Exception YamlException
instance Exception ToEventRawException


-- | Provides a high-level interface for processing YAML files.
--   
--   This module reuses most of the infrastructure from the <tt>aeson</tt>
--   package. This means that you can use all of the existing tools for
--   JSON processing for processing YAML files. As a result, much of the
--   documentation below mentions JSON; do not let that confuse you, it's
--   intentional.
--   
--   For the most part, YAML content translates directly into JSON, and
--   therefore there is very little data loss. If you need to deal with
--   YAML more directly (e.g., directly deal with aliases), you should use
--   the <a>Text.Libyaml</a> module instead.
--   
--   For documentation on the <tt>aeson</tt> types, functions, classes, and
--   operators, please see the <tt>Data.Aeson</tt> module of the
--   <tt>aeson</tt> package.
module Data.Yaml

-- | A JSON value represented as a Haskell value.
data Value :: *
Object :: SrictNotUnpackedObject -> Value
Array :: SrictNotUnpackedArray -> Value
String :: SrictNotUnpackedText -> Value
Number :: SrictNotUnpackedScientific -> Value
Bool :: SrictNotUnpackedBool -> Value
Null :: Value

-- | A continuation-based parser type.
data Parser a :: * -> *

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | A JSON "array" (sequence).
type Array = Vector Value
data ParseException
NonScalarKey :: ParseException
UnknownAlias :: AnchorName -> ParseException
_anchorName :: ParseException -> AnchorName
UnexpectedEvent :: Maybe Event -> Maybe Event -> ParseException
_received :: ParseException -> Maybe Event
_expected :: ParseException -> Maybe Event
InvalidYaml :: (Maybe YamlException) -> ParseException
AesonException :: String -> ParseException
OtherParseException :: SomeException -> ParseException
NonStringKeyAlias :: AnchorName -> Value -> ParseException
CyclicIncludes :: ParseException

-- | Alternative to <a>show</a> to display a <a>ParseException</a> on the
--   screen. Instead of displaying the data constructors applied to their
--   arguments, a more textual output is returned. For example, instead of
--   printing:
--   
--   <pre>
--   AesonException "The key \"foo\" was not found"
--   </pre>
--   
--   It looks more pleasant to print:
--   
--   <pre>
--   Aeson exception: The key "foo" was not found
--   </pre>
--   
--   Since 0.8.11
prettyPrintParseException :: ParseException -> String
data YamlException
YamlException :: String -> YamlException

-- | problem, context, index, position line, position column
YamlParseException :: String -> String -> YamlMark -> YamlException
yamlProblem :: YamlException -> String
yamlContext :: YamlException -> String
yamlProblemMark :: YamlException -> YamlMark

-- | The pointer position
data YamlMark
YamlMark :: Int -> Int -> Int -> YamlMark
yamlIndex :: YamlMark -> Int
yamlLine :: YamlMark -> Int
yamlColumn :: YamlMark -> Int

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value
array :: [Value] -> Value

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a
parseMonad :: Monad m => (a -> Parser b) -> a -> m b

-- | Run a <a>Parser</a> with an <a>Either</a> result type.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
encode :: ToJSON a => a -> ByteString
encodeFile :: ToJSON a => FilePath -> a -> IO ()
decode :: FromJSON a => ByteString -> Maybe a
decodeFile :: FromJSON a => FilePath -> IO (Maybe a)
decodeEither :: FromJSON a => ByteString -> Either String a

-- | More helpful version of <a>decodeEither</a> which returns the
--   <a>YamlException</a>.
--   
--   Since 0.8.3
decodeEither' :: FromJSON a => ByteString -> Either ParseException a

-- | A version of <a>decodeFile</a> which should not throw runtime
--   exceptions.
--   
--   Since 0.8.4
decodeFileEither :: FromJSON a => FilePath -> IO (Either ParseException a)
decodeHelper :: FromJSON a => Source Parse Event -> IO (Either ParseException (Either String a))


-- | Just a re-export of <tt>Data.Yaml</tt>. In the future, this will be
--   the canonical name for that module's contents.
module Data.Yaml.Aeson


-- | NOTE: This module is a highly experimental preview release. It may
--   change drastically, or be entirely removed, in a future release.
module Data.Yaml.Builder
newtype YamlBuilder
YamlBuilder :: ([Event] -> [Event]) -> YamlBuilder
unYamlBuilder :: YamlBuilder -> [Event] -> [Event]
class ToYaml a
toYaml :: ToYaml a => a -> YamlBuilder
mapping :: [(Text, YamlBuilder)] -> YamlBuilder
array :: [YamlBuilder] -> YamlBuilder
string :: Text -> YamlBuilder
toByteString :: ToYaml a => a -> ByteString
writeYamlFile :: ToYaml a => FilePath -> a -> IO ()
(.=) :: ToYaml a => Text -> a -> (Text, YamlBuilder)
instance ToYaml Int
instance ToYaml Text
instance ToYaml a => ToYaml [a]
instance ToYaml a => ToYaml [(Text, a)]
instance ToYaml YamlBuilder


-- | NOTE: This module is a highly experimental preview release. It may
--   change drastically, or be entirely removed, in a future release.
module Data.Yaml.Parser
newtype YamlParser a
YamlParser :: (AnchorMap -> Either Text a) -> YamlParser a
unYamlParser :: YamlParser a -> AnchorMap -> Either Text a
lookupAnchor :: AnchorName -> YamlParser (Maybe YamlValue)
withAnchor :: AnchorName -> Text -> (YamlValue -> YamlParser a) -> YamlParser a
withMapping :: Text -> ([(Text, YamlValue)] -> YamlParser a) -> YamlValue -> YamlParser a
withSequence :: Text -> ([YamlValue] -> YamlParser a) -> YamlValue -> YamlParser a
withText :: Text -> (Text -> YamlParser a) -> YamlValue -> YamlParser a
typeMismatch :: Text -> YamlValue -> YamlParser a
class FromYaml a
fromYaml :: FromYaml a => YamlValue -> YamlParser a
data YamlValue
Mapping :: [(Text, YamlValue)] -> Anchor -> YamlValue
Sequence :: [YamlValue] -> Anchor -> YamlValue
Scalar :: ByteString -> Tag -> Style -> Anchor -> YamlValue
Alias :: AnchorName -> YamlValue
type AnchorMap = Map AnchorName YamlValue
data RawDoc
RawDoc :: YamlValue -> AnchorMap -> RawDoc
parseRawDoc :: (FromYaml a, MonadThrow m) => RawDoc -> m a
(.:) :: FromYaml a => [(Text, YamlValue)] -> Text -> YamlParser a
data YamlParseException
UnexpectedEndOfEvents :: YamlParseException
UnexpectedEvent :: Event -> YamlParseException
FromYamlException :: Text -> YamlParseException
sinkValue :: MonadThrow m => Consumer Event (WriterT AnchorMap m) YamlValue
sinkRawDoc :: MonadThrow m => Consumer Event m RawDoc
readYamlFile :: FromYaml a => FilePath -> IO a
instance Typeable YamlParseException
instance Show YamlValue
instance Show RawDoc
instance Show YamlParseException
instance Exception YamlParseException
instance FromYaml Int
instance FromYaml Text
instance FromYaml a => FromYaml [a]
instance FromYaml YamlValue
instance MonadPlus YamlParser
instance Monad YamlParser
instance Monoid (YamlParser a)
instance Alternative YamlParser
instance Applicative YamlParser
instance Functor YamlParser

module Data.Yaml.Include

-- | Like <a>decodeFile</a> but with support for relative and absolute
--   includes.
--   
--   The syntax for includes follows the form:
--   
--   <pre>
--   somekey: !include ./somefile.yaml
--   </pre>
decodeFile :: FromJSON a => FilePath -> IO (Maybe a)

-- | Like <a>decodeFileEither</a> but with support for relative and
--   absolute includes.
--   
--   The syntax for includes follows the form:
--   
--   <pre>
--   somekey: !include ./somefile.yaml
--   </pre>
decodeFileEither :: FromJSON a => FilePath -> IO (Either ParseException a)
