-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Lazy Virtual Machine (LVM).
--   
--   The Lazy Virtual Machine (LVM) defines a portable instruction set and
--   file format. It is specifically designed to execute languages with
--   non-strict (or lazy) semantics. This cabal package defines the core
--   assembler (coreasm) for compiling core programs into LVM instructions
--   and a library. The LVM is used as a backend for the Helium compiler.
--   At the moment, one LVM runtime implementation is available (written in
--   C). More information about LVM can be found in Chapter 6 of Daan
--   Leijen's PhD Thesis, The Lambda Abroad.
@package lvmlib
@version 1.1

module Lvm.Path
searchPath :: [String] -> String -> String -> IO String
searchPathMaybe :: [String] -> String -> String -> IO (Maybe String)
explodePath :: String -> [String]
slashify :: String -> String
splitFilePath :: String -> (String, String, String)
getLvmPath :: IO [String]

module Lvm.Core.Parsing.Token
type Token = (Pos, Lexeme)
data Lexeme
LexUnknown :: Char -> Lexeme
LexError :: String -> Lexeme
LexChar :: Char -> Lexeme
LexString :: String -> Lexeme
LexInt :: Integer -> Lexeme
LexFloat :: Double -> Lexeme
LexId :: String -> Lexeme
LexQualId :: String -> String -> Lexeme
LexOp :: String -> Lexeme
LexCon :: String -> Lexeme
LexQualCon :: String -> String -> Lexeme
LexConOp :: String -> Lexeme
LexCOMMA :: Lexeme
LexQUOTE :: Lexeme
LexSEMI :: Lexeme
LexBSLASH :: Lexeme
LexASG :: Lexeme
LexCOLON :: Lexeme
LexCOLCOL :: Lexeme
LexDOT :: Lexeme
LexDOTDOT :: Lexeme
LexBAR :: Lexeme
LexLARROW :: Lexeme
LexRARROW :: Lexeme
LexTILDE :: Lexeme
LexARROW :: Lexeme
LexAT :: Lexeme
LexEXCL :: Lexeme
LexDASH :: Lexeme
LexLPAREN :: Lexeme
LexRPAREN :: Lexeme
LexLBRACKET :: Lexeme
LexRBRACKET :: Lexeme
LexLBRACE :: Lexeme
LexRBRACE :: Lexeme
LexLET :: Lexeme
LexIN :: Lexeme
LexDO :: Lexeme
LexWHERE :: Lexeme
LexCASE :: Lexeme
LexOF :: Lexeme
LexIF :: Lexeme
LexTHEN :: Lexeme
LexELSE :: Lexeme
LexDATA :: Lexeme
LexTYPE :: Lexeme
LexMODULE :: Lexeme
LexIMPORT :: Lexeme
LexEOF :: Lexeme
LexLETSTRICT :: Lexeme
LexMATCH :: Lexeme
LexWITH :: Lexeme
LexPRIVATE :: Lexeme
LexPUBLIC :: Lexeme
LexDEFAULT :: Lexeme
LexCON :: Lexeme
LexABSTRACT :: Lexeme
LexINSTR :: Lexeme
LexEXTERN :: Lexeme
LexNOTHING :: Lexeme
LexCUSTOM :: Lexeme
LexSTATIC :: Lexeme
LexDYNAMIC :: Lexeme
LexRUNTIME :: Lexeme
LexCCALL :: Lexeme
LexSTDCALL :: Lexeme
LexINSTRCALL :: Lexeme
LexDECORATE :: Lexeme
LexORDINAL :: Lexeme
type Pos = (Int, Int)
incpos :: Pos -> Int -> Pos
newpos :: Pos -> Char -> Pos
instance Eq Lexeme
instance Show Lexeme
instance Pretty Lexeme

module Lvm.Core.Parsing.Lexer
lexer :: Lexer

module Lvm.Core.Parsing.Layout
layout :: [Token] -> [Token]
instance Eq Layout
instance Show Layout

module Lvm.Common.Id
data Id
stringFromId :: Id -> String
idFromString :: String -> Id
idFromStringEx :: Enum a => a -> String -> Id
dummyId :: Id
freshIdFromId :: Id -> NameSupply -> (Id, NameSupply)
getNameSpace :: Enum a => Id -> a
setNameSpace :: Enum a => a -> Id -> Id
data NameSupply
newNameSupply :: IO NameSupply
splitNameSupply :: NameSupply -> (NameSupply, NameSupply)
splitNameSupplies :: NameSupply -> [NameSupply]
freshId :: NameSupply -> (Id, NameSupply)
mapWithSupply :: (NameSupply -> a -> b) -> NameSupply -> [a] -> [b]
intFromId :: Id -> Int
idFromInt :: Int -> Id
instance Pretty Id
instance Show Id
instance Ord Id
instance Eq Id

module Lvm.Common.IdMap
data IdMap a
data Id
emptyMap :: IdMap a
singleMap :: Id -> a -> IdMap a
elemMap :: Id -> IdMap a -> Bool
mapMap :: (a -> b) -> IdMap a -> IdMap b
insertMap :: Id -> a -> IdMap a -> IdMap a
extendMap :: Id -> a -> IdMap a -> IdMap a
insertMapWith :: Id -> a -> (a -> a) -> IdMap a -> IdMap a
lookupMap :: Id -> IdMap a -> Maybe a
findMap :: Id -> IdMap a -> a
filterMap :: (a -> Bool) -> IdMap a -> IdMap a
listFromMap :: IdMap a -> [(Id, a)]
mapMapWithId :: (Id -> a -> b) -> IdMap a -> IdMap b
unionMap :: IdMap a -> IdMap a -> IdMap a
unionMapWith :: (a -> a -> a) -> IdMap a -> IdMap a -> IdMap a
updateMap :: Id -> a -> IdMap a -> IdMap a
foldMap :: (a -> b -> b) -> b -> IdMap a -> b
deleteMap :: Id -> IdMap a -> IdMap a
filterMapWithId :: (Id -> a -> Bool) -> IdMap a -> IdMap a
mapFromList :: [(Id, a)] -> IdMap a
unionMaps :: [IdMap a] -> IdMap a
diffMap :: IdMap a -> IdMap a -> IdMap a
unionlMap :: IdMap a -> IdMap a -> IdMap a
foldMapWithId :: (Id -> a -> b -> b) -> b -> IdMap a -> b
isEmptyMap :: IdMap a -> Bool
sizeMap :: IdMap a -> Int

module Lvm.Common.IdSet
data IdSet
data Id
emptySet :: IdSet
singleSet :: Id -> IdSet
elemSet :: Id -> IdSet -> Bool
filterSet :: (Id -> Bool) -> IdSet -> IdSet
foldSet :: (Id -> a -> a) -> a -> IdSet -> a
insertSet :: Id -> IdSet -> IdSet
deleteSet :: Id -> IdSet -> IdSet
unionSet :: IdSet -> IdSet -> IdSet
unionSets :: [IdSet] -> IdSet
diffSet :: IdSet -> IdSet -> IdSet
listFromSet :: IdSet -> [Id]
setFromList :: [Id] -> IdSet
sizeSet :: IdSet -> Int
isEmptySet :: IdSet -> Bool

module Lvm.Core.PrettyId
ppId :: Id -> Doc
ppVarId :: Id -> Doc
ppConId :: Id -> Doc
ppQualId :: Id -> Id -> Doc
ppQualCon :: Id -> Id -> Doc
ppString :: String -> Doc

module Lvm.Core.Type
data Type
TFun :: Type -> Type -> Type
TAp :: Type -> Type -> Type
TForall :: Id -> Type -> Type
TExist :: Id -> Type -> Type
TStrict :: Type -> Type
TVar :: Id -> Type
TCon :: Id -> Type
TAny :: Type
TString :: String -> Type
data Kind
KFun :: Kind -> Kind -> Kind
kind1 :: Kind -> Kind
kind2 :: Kind -> Kind
KStar :: Kind
KString :: String -> Kind
kindString :: Kind -> String
addForall :: Type -> Type
arityFromType :: Type -> Int
instance Pretty Kind
instance Pretty Type
instance Show Kind
instance Show Type

module Lvm.Common.Byte
type Byte = Word8
data Bytes

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
unit :: Byte -> Bytes
isEmpty :: Bytes -> Bool
bytesLength :: Bytes -> Int
writeBytes :: FilePath -> Bytes -> IO ()
bytesFromList :: [Byte] -> Bytes
listFromBytes :: Bytes -> [Byte]
bytesFromString :: String -> Bytes
stringFromBytes :: Bytes -> String
bytesFromInt32 :: Int -> Bytes
byteFromInt8 :: Int -> Byte
readByteList :: FilePath -> IO [Byte]
int32FromByteList :: [Byte] -> (Int, [Byte])
stringFromByteList :: [Byte] -> String
bytesFromByteList :: [Byte] -> Bytes
instance Monoid Bytes
instance Eq Bytes
instance Show Bytes

module Lvm.Instr.Data
data Instr
VAR :: !Id -> Instr
PARAM :: !Id -> Instr
USE :: !Id -> Instr
NOP :: Instr
ATOM :: ![Instr] -> Instr
INIT :: ![Instr] -> Instr
CATCH :: ![Instr] -> Instr
EVAL :: !Depth -> ![Instr] -> Instr
RESULT :: ![Instr] -> Instr
MATCH :: ![Alt] -> Instr
MATCHCON :: ![Alt] -> Instr
SWITCHCON :: ![Alt] -> Instr
MATCHINT :: ![Alt] -> Instr
PUSHVAR :: !Var -> Instr
PUSHINT :: !Int -> Instr
PUSHBYTES :: !Bytes -> !Index -> Instr
PUSHFLOAT :: !Double -> Instr
PUSHCODE :: !Global -> Instr
PUSHCONT :: !Offset -> Instr
PUSHCATCH :: Instr
ARGCHK :: !Arity -> Instr
SLIDE :: !Int -> !Int -> !Depth -> Instr
STUB :: !Var -> Instr
ENTER :: Instr
RAISE :: Instr
CALL :: !Global -> Instr
ENTERCODE :: !Global -> Instr
EVALVAR :: !Var -> Instr
RETURN :: Instr
RETURNCON :: !Con -> Instr
RETURNINT :: !Int -> Instr
ALLOCAP :: !Arity -> Instr
PACKAP :: !Var -> !Arity -> Instr
PACKNAP :: !Var -> !Arity -> Instr
NEWAP :: !Arity -> Instr
NEWNAP :: !Arity -> Instr
ALLOCCON :: !Con -> Instr
PACKCON :: !Con -> !Var -> Instr
NEWCON :: !Con -> Instr
ALLOC :: Instr
NEW :: !Arity -> Instr
PACK :: !Arity -> !Var -> Instr
UNPACK :: !Arity -> Instr
GETFIELD :: Instr
SETFIELD :: Instr
GETTAG :: Instr
GETSIZE :: Instr
UPDFIELD :: Instr
ADDINT :: Instr
SUBINT :: Instr
MULINT :: Instr
DIVINT :: Instr
MODINT :: Instr
QUOTINT :: Instr
REMINT :: Instr
ANDINT :: Instr
XORINT :: Instr
ORINT :: Instr
SHRINT :: Instr
SHLINT :: Instr
SHRNAT :: Instr
NEGINT :: Instr
EQINT :: Instr
NEINT :: Instr
LTINT :: Instr
GTINT :: Instr
LEINT :: Instr
GEINT :: Instr
ADDFLOAT :: Instr
SUBFLOAT :: Instr
MULFLOAT :: Instr
DIVFLOAT :: Instr
NEGFLOAT :: Instr
EQFLOAT :: Instr
NEFLOAT :: Instr
LTFLOAT :: Instr
GTFLOAT :: Instr
LEFLOAT :: Instr
GEFLOAT :: Instr
PUSHVAR0 :: Instr
PUSHVAR1 :: Instr
PUSHVAR2 :: Instr
PUSHVAR3 :: Instr
PUSHVAR4 :: Instr
PUSHVARS2 :: !Var -> !Var -> Instr
NEWAP2 :: Instr
NEWAP3 :: Instr
NEWAP4 :: Instr
NEWNAP2 :: Instr
NEWNAP3 :: Instr
NEWNAP4 :: Instr
NEWCON0 :: !Con -> Instr
NEWCON1 :: !Con -> Instr
NEWCON2 :: !Con -> Instr
NEWCON3 :: !Con -> Instr
RETURNCON0 :: !Con -> Instr
data Var
Var :: !Id -> !Offset -> !Depth -> Var
idFromVar :: Var -> !Id
offsetFromVar :: Var -> !Offset
depthFromVar :: Var -> !Depth
data Con
Con :: !Id -> Index -> !Arity -> !Tag -> Con
idFromCon :: Con -> !Id
indexFromCon :: Con -> Index
arityFromCon :: Con -> !Arity
tagFromCon :: Con -> !Tag
data Global
Global :: !Id -> Index -> !Arity -> Global
idFromGlobal :: Global -> !Id
indexFromGlobal :: Global -> Index
arityFromGlobal :: Global -> !Arity
data Alt
Alt :: !Pat -> ![Instr] -> Alt
data Pat
PatCon :: !Con -> Pat
PatInt :: !Int -> Pat
PatTag :: !Tag -> !Arity -> Pat
PatDefault :: Pat
type Offset = Int
type Depth = Int
type Index = Int
type Tag = Int
type Arity = Int
opcodeFromInstr :: Instr -> Int
instrFromOpcode :: Int -> Instr
instrFromName :: String -> Instr
nameFromInstr :: Instr -> String
isCATCH :: Instr -> Bool
strictResult :: Instr -> Bool
instance Show Global
instance Show Con
instance Show Var
instance Show Pat
instance Show Instr
instance Show Alt
instance Ord Instr
instance Eq Instr
instance Enum Instr
instance Pretty Var
instance Pretty Global
instance Pretty Con
instance Pretty Pat
instance Pretty Alt
instance Pretty Instr

module Lvm.Core.Module
data Module v
Module :: Id -> !Int -> !Int -> ![Decl v] -> Module v
moduleName :: Module v -> Id
moduleMajorVer :: Module v -> !Int
moduleMinorVer :: Module v -> !Int
moduleDecls :: Module v -> ![Decl v]
data Decl v
DeclValue :: Id -> !Access -> Maybe Id -> v -> ![Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
valueEnc :: Decl v -> Maybe Id
valueValue :: Decl v -> v
declCustoms :: Decl v -> ![Custom]
DeclAbstract :: Id -> !Access -> !Arity -> ![Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
declArity :: Decl v -> !Arity
declCustoms :: Decl v -> ![Custom]
DeclCon :: Id -> !Access -> !Arity -> !Tag -> [Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
declArity :: Decl v -> !Arity
conTag :: Decl v -> !Tag
declCustoms :: Decl v -> [Custom]
DeclExtern :: Id -> !Access -> !Arity -> !String -> !LinkConv -> !CallConv -> !String -> !ExternName -> ![Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
declArity :: Decl v -> !Arity
externType :: Decl v -> !String
externLink :: Decl v -> !LinkConv
externCall :: Decl v -> !CallConv
externLib :: Decl v -> !String
externName :: Decl v -> !ExternName
declCustoms :: Decl v -> ![Custom]
DeclCustom :: Id -> !Access -> !DeclKind -> ![Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
declKind :: Decl v -> !DeclKind
declCustoms :: Decl v -> ![Custom]
DeclImport :: Id -> !Access -> ![Custom] -> Decl v
declName :: Decl v -> Id
declAccess :: Decl v -> !Access
declCustoms :: Decl v -> ![Custom]
data Custom
CustomInt :: !Int -> Custom
CustomBytes :: !Bytes -> Custom
CustomName :: Id -> Custom
CustomLink :: Id -> !DeclKind -> Custom
CustomDecl :: !DeclKind -> ![Custom] -> Custom
CustomNothing :: Custom
data DeclKind
DeclKindName :: DeclKind
DeclKindKind :: DeclKind
DeclKindBytes :: DeclKind
DeclKindCode :: DeclKind
DeclKindValue :: DeclKind
DeclKindCon :: DeclKind
DeclKindImport :: DeclKind
DeclKindModule :: DeclKind
DeclKindExtern :: DeclKind
DeclKindExternType :: DeclKind
DeclKindCustom :: !Id -> DeclKind
type Arity = Int
type Tag = Int
data Access
Defined :: !Bool -> Access
accessPublic :: Access -> !Bool
Imported :: !Bool -> Id -> Id -> !DeclKind -> !Int -> !Int -> Access
accessPublic :: Access -> !Bool
importModule :: Access -> Id
importName :: Access -> Id
importKind :: Access -> !DeclKind
importMajorVer :: Access -> !Int
importMinorVer :: Access -> !Int
data ExternName
Plain :: !String -> ExternName
Decorate :: !String -> ExternName
Ordinal :: !Int -> ExternName
data CallConv
CallC :: CallConv
CallStd :: CallConv
CallInstr :: CallConv
data LinkConv
LinkStatic :: LinkConv
LinkDynamic :: LinkConv
LinkRuntime :: LinkConv
globalNames :: Module v -> IdSet
externNames :: Module v -> IdSet
filterPublic :: Module v -> Module v
mapDecls :: (Decl v -> Decl w) -> Module v -> Module w
customDeclKind :: String -> DeclKind
customData :: DeclKind
customTypeDecl :: DeclKind
modulePublic :: Bool -> (IdSet, IdSet, IdSet, IdSet, IdSet) -> Module v -> Module v
declKindFromDecl :: Decl a -> DeclKind
shallowKindFromDecl :: Decl a -> DeclKind
makeDeclKind :: Id -> DeclKind
isDeclValue :: Decl a -> Bool
isDeclAbstract :: Decl a -> Bool
isDeclCon :: Decl a -> Bool
isDeclExtern :: Decl a -> Bool
isDeclImport :: Decl a -> Bool
isDeclGlobal :: Decl a -> Bool
public :: Access
private :: Access
instance Eq DeclKind
instance Show DeclKind
instance Show ExternName
instance Show CallConv
instance Eq CallConv
instance Enum CallConv
instance Show LinkConv
instance Eq LinkConv
instance Enum LinkConv
instance Pretty DeclKind
instance Pretty Custom
instance Pretty CallConv
instance Pretty LinkConv
instance Pretty a => Pretty (Decl a)
instance Pretty a => Pretty (Module a)
instance Functor Decl
instance Functor Module
instance Enum DeclKind
instance Ord DeclKind

module Lvm.Data
type LvmModule = Module [Instr]
type LvmDecl = Decl [Instr]
recHeader :: Int
recFooter :: Int

module Lvm.Instr.Resolve
instrResolve :: [Instr] -> [Instr]
instance Monad Resolve
instance Functor Resolve

module Lvm.Instr.Rewrite
instrRewrite :: [Instr] -> [Instr]

module Lvm.Core.Expr
type CoreModule = Module Expr
type CoreDecl = Decl Expr
data Expr
Let :: !Binds -> Expr -> Expr
Match :: !Id -> Alts -> Expr
Ap :: Expr -> Expr -> Expr
Lam :: !Id -> Expr -> Expr
Con :: !(Con Expr) -> Expr
Var :: !Id -> Expr
Lit :: !Literal -> Expr
data Binds
Rec :: ![Bind] -> Binds
Strict :: !Bind -> Binds
NonRec :: !Bind -> Binds
data Bind
Bind :: !Id -> Expr -> Bind
type Alts = [Alt]
data Alt
Alt :: !Pat -> Expr -> Alt
data Pat
PatCon :: !(Con Tag) -> ![Id] -> Pat
PatLit :: !Literal -> Pat
PatDefault :: Pat
data Literal
LitInt :: !Int -> Literal
LitDouble :: !Double -> Literal
LitBytes :: !Bytes -> Literal
data Con tag
ConId :: !Id -> Con tag
ConTag :: tag -> !Arity -> Con tag
instance Pretty Literal
instance Pretty Pat
instance Pretty Alt
instance Pretty Bind
instance Pretty a => Pretty (Con a)
instance Pretty Expr

module Lvm.Core.FreeVar
class FreeVar a
freeVar :: FreeVar a => a -> IdSet
class Binder a
binder :: Binder a => a -> IdSet
instance Binder Binds
instance Binder Bind
instance Binder Pat
instance Binder a => Binder [a]
instance FreeVar a => FreeVar (Con a)
instance FreeVar Bind
instance FreeVar Binds
instance FreeVar Alt
instance FreeVar Expr
instance FreeVar a => FreeVar [a]

module Lvm.Core.Utils
listFromBinds :: Binds -> [Bind]
unzipBinds :: [Bind] -> ([Id], [Expr])
mapBinds :: (Id -> Expr -> Bind) -> Binds -> Binds
mapAccumBinds :: (a -> Id -> Expr -> (Bind, a)) -> a -> Binds -> (Binds, a)
zipBindsWith :: (a -> Id -> Expr -> Bind) -> [a] -> Binds -> Binds
mapAlts :: (Pat -> Expr -> Alt) -> Alts -> Alts
zipAltsWith :: (a -> Pat -> Expr -> Alt) -> [a] -> Alts -> Alts
mapExprWithSupply :: (NameSupply -> Expr -> Expr) -> NameSupply -> CoreModule -> CoreModule
mapAccum :: (a -> b -> (c, a)) -> a -> [b] -> ([c], a)

module Lvm.Core.LetSort
coreLetSort :: CoreModule -> CoreModule

module Lvm.Core.Lift
coreLift :: CoreModule -> CoreModule

module Lvm.Core.NoShadow
coreNoShadow :: NameSupply -> CoreModule -> CoreModule
coreRename :: NameSupply -> CoreModule -> CoreModule

module Lvm.Core.Normalize
coreNormalize :: NameSupply -> CoreModule -> CoreModule

module Lvm.Core.RemoveDead
coreRemoveDead :: CoreModule -> CoreModule

module Lvm.Core.Saturate
coreSaturate :: NameSupply -> CoreModule -> CoreModule

module Lvm.Core.Parsing.Parser
parseModuleExport :: FilePath -> [Token] -> IO (CoreModule, Bool, (IdSet, IdSet, IdSet, IdSet, IdSet))
parseModule :: FilePath -> [Token] -> IO CoreModule

module Lvm.Read
lvmReadFile :: FilePath -> IO (Module v)
lvmRead :: NameSupply -> FilePath -> [Byte] -> Module v
instance Monad (Read v)
instance Functor (Read v)

module Lvm.Import
lvmImport :: (Id -> IO FilePath) -> Module v -> IO (Module v)
lvmImportDecls :: (Id -> IO FilePath) -> [Decl v] -> IO [[Decl v]]

module Lvm.Write
lvmWriteFile :: FilePath -> LvmModule -> IO ()
lvmToBytes :: LvmModule -> Bytes
instance Monad Emit
instance Functor Emit

module Lvm.Asm.Data
type AsmModule = Module Top
type AsmDecl = Decl Top
data Top
Top :: ![Id] -> Expr -> Top
type Atom = Expr
data Expr
Eval :: !Id -> Expr -> Expr -> Expr
Match :: !Id -> ![Alt] -> Expr
Prim :: !Id -> ![Atom] -> Expr
LetRec :: ![(Id, Atom)] -> Expr -> Expr
Let :: !Id -> Atom -> Expr -> Expr
Ap :: !Id -> ![Atom] -> Expr
Con :: !(Con Atom) -> ![Atom] -> Expr
Lit :: !Lit -> Expr
Note :: !Note -> !Expr -> Expr
data Note
Occur :: !Occur -> Note
data Occur
Never :: Occur
Once :: Occur
Many :: Occur
data Lit
LitInt :: !Int -> Lit
LitFloat :: !Double -> Lit
LitBytes :: !Bytes -> Lit
data Alt
Alt :: !Pat -> Expr -> Alt
data Pat
PatVar :: !Id -> Pat
PatCon :: !(Con Int) -> ![Id] -> Pat
PatLit :: !Lit -> Pat
data Con tag
ConId :: !Id -> Con tag
ConTag :: tag -> !Arity -> Con tag
instance Pretty Lit
instance Pretty Pat
instance Pretty Alt
instance Pretty Occur
instance Pretty Note
instance Pretty a => Pretty (Con a)
instance Pretty Expr
instance Pretty Top

module Lvm.Asm.Occur
asmOccur :: AsmModule -> AsmModule

module Lvm.Asm.Inline
asmInline :: AsmModule -> AsmModule

module Lvm.Asm.ToLvm
asmToLvm :: AsmModule -> LvmModule

module Lvm.Core.ToAsm
coreToAsm :: NameSupply -> CoreModule -> AsmModule
