-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell implementation of MessagePack
--   
@package msgpack
@version 1.0.0


-- | MessagePack Serializer using <tt>Data.Binary</tt>
module Data.MessagePack.Put
putNil :: Put
putBool :: Bool -> Put
putInt :: Int -> Put
putFloat :: Float -> Put
putDouble :: Double -> Put
putStr :: Text -> Put
putBin :: ByteString -> Put
putArray :: (a -> Put) -> Vector a -> Put
putMap :: (a -> Put) -> (b -> Put) -> Vector (a, b) -> Put
putExt :: Word8 -> ByteString -> Put


-- | MessagePack Deserializer using <tt>Data.Binary</tt>
module Data.MessagePack.Get
getNil :: Get ()
getBool :: Get Bool
getInt :: Get Int
getFloat :: Get Float
getDouble :: Get Double
getStr :: Get Text
getBin :: Get ByteString
getArray :: Get a -> Get (Vector a)
getMap :: Get a -> Get b -> Get (Vector (a, b))
getExt :: Get (Word8, ByteString)


-- | MessagePack map labeling type
module Data.MessagePack.Assoc
newtype Assoc a
Assoc :: a -> Assoc a
unAssoc :: Assoc a -> a
instance Typeable Assoc
instance Show a => Show (Assoc a)
instance Eq a => Eq (Assoc a)
instance Ord a => Ord (Assoc a)
instance NFData a => NFData (Assoc a)


-- | MessagePack object definition
module Data.MessagePack.Object

-- | Object Representation of MessagePack data.
data Object

-- | represents nil
ObjectNil :: Object

-- | represents true or false
ObjectBool :: !Bool -> Object

-- | represents an integer
ObjectInt :: {-# UNPACK #-} !Int -> Object

-- | represents a floating point number
ObjectFloat :: {-# UNPACK #-} !Float -> Object

-- | represents a floating point number
ObjectDouble :: {-# UNPACK #-} !Double -> Object

-- | extending Raw type represents a UTF-8 string
ObjectStr :: !Text -> Object

-- | extending Raw type represents a byte array
ObjectBin :: !ByteString -> Object

-- | represents a sequence of objects
ObjectArray :: !(Vector Object) -> Object

-- | represents key-value pairs of objects
ObjectMap :: !(Vector (Object, Object)) -> Object

-- | represents a tuple of an integer and a byte array where the integer
--   represents type information and the byte array represents data.
ObjectExt :: {-# UNPACK #-} !Word8 -> !ByteString -> Object
class MessagePack a
toObject :: MessagePack a => a -> Object
fromObject :: MessagePack a => Object -> Maybe a
instance [incoherent] Typeable Object
instance [incoherent] Show Object
instance [incoherent] Eq Object
instance [incoherent] Ord Object
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4, MessagePack a5, MessagePack a6, MessagePack a7, MessagePack a8, MessagePack a9) => MessagePack (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4, MessagePack a5, MessagePack a6, MessagePack a7, MessagePack a8) => MessagePack (a1, a2, a3, a4, a5, a6, a7, a8)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4, MessagePack a5, MessagePack a6, MessagePack a7) => MessagePack (a1, a2, a3, a4, a5, a6, a7)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4, MessagePack a5, MessagePack a6) => MessagePack (a1, a2, a3, a4, a5, a6)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4, MessagePack a5) => MessagePack (a1, a2, a3, a4, a5)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3, MessagePack a4) => MessagePack (a1, a2, a3, a4)
instance [incoherent] (MessagePack a1, MessagePack a2, MessagePack a3) => MessagePack (a1, a2, a3)
instance [incoherent] (MessagePack a1, MessagePack a2) => MessagePack (a1, a2)
instance [incoherent] (MessagePack k, MessagePack v, Hashable k, Eq k) => MessagePack (HashMap k v)
instance [incoherent] MessagePack v => MessagePack (IntMap v)
instance [incoherent] (MessagePack k, MessagePack v, Ord k) => MessagePack (Map k v)
instance [incoherent] (MessagePack k, MessagePack v) => MessagePack (Assoc [(k, v)])
instance [incoherent] MessagePack a => MessagePack [a]
instance [incoherent] MessagePack Text
instance [incoherent] MessagePack Text
instance [incoherent] MessagePack ByteString
instance [incoherent] MessagePack a => MessagePack (Maybe a)
instance [incoherent] (MessagePack a, MessagePack b) => MessagePack (Assoc (Vector (a, b)))
instance [incoherent] MessagePack a => MessagePack (Vector a)
instance [incoherent] MessagePack String
instance [incoherent] MessagePack ByteString
instance [incoherent] MessagePack Double
instance [incoherent] MessagePack Float
instance [incoherent] MessagePack Bool
instance [incoherent] MessagePack Int
instance [incoherent] MessagePack ()
instance [incoherent] MessagePack Object
instance [incoherent] Binary Object
instance [incoherent] NFData Object


-- | Simple interface to pack and unpack MessagePack data.
module Data.MessagePack

-- | Pack a Haskell value to MessagePack binary.
pack :: MessagePack a => a -> ByteString

-- | Unpack MessagePack binary to a Haskell value. If it fails, it returns
--   Nothing.
unpack :: MessagePack a => ByteString -> Maybe a
