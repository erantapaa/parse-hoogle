-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | MUtually Recursive Definitions Explicitly Represented
--   
--   The murder library is an EDSL for grammar fragments as first-class
--   values. It provides combinators to define and extend grammars, and
--   produce compilers out of them.
@package murder
@version 1.3.2

module Language.Grammars.Murder.Scanner
scanHandle :: ScanOpts -> FilePath -> Handle -> IO [Token]
scanFile :: ScanOpts -> FilePath -> IO [Token]
scan :: ScanOpts -> Pos -> String -> [Token]
getRational :: String -> (String, Maybe String, Maybe (Maybe String, String))
getBaseNumber :: Integer -> [Char] -> Integer
type Token = GenToken String EnumValToken String
data EnumValToken
TkVarid :: EnumValToken
TkConid :: EnumValToken
TkOp :: EnumValToken
TkConOp :: EnumValToken
TkQVarid :: EnumValToken
TkQConid :: EnumValToken
TkQOp :: EnumValToken
TkQConOp :: EnumValToken
TkString :: EnumValToken
TkChar :: EnumValToken
TkInteger8 :: EnumValToken
TkInteger10 :: EnumValToken
TkInteger16 :: EnumValToken
TkFraction :: EnumValToken
TkTextnm :: EnumValToken
TkTextln :: EnumValToken
TkError :: EnumValToken
reserved :: String -> Pos -> Token
valueToken :: EnumValToken -> String -> Pos -> Token
errToken :: String -> Pos -> Token
tokTpIsInt :: EnumValToken -> Bool
tokTpIsId :: EnumValToken -> Bool
tokTpQual :: EnumValToken -> EnumValToken
pKeyPos :: IsParser p Token => String -> p Pos
pSpecPos :: IsParser p Token => Char -> p Pos
pKey :: IsParser p Token => String -> p String
pSpec :: IsParser p Token => Char -> p String
pStringPos :: IsParser p Token => p (String, Pos)
pConsymPos :: IsParser p Token => p (String, Pos)
pVarsymPos :: IsParser p Token => p (String, Pos)
pIntegerPos :: IsParser p Token => p (String, Pos)
pTextlnPos :: IsParser p Token => p (String, Pos)
pTextnmPos :: IsParser p Token => p (String, Pos)
pConidPos :: IsParser p Token => p (String, Pos)
pVaridPos :: IsParser p Token => p (String, Pos)
pFractionPos :: IsParser p Token => p (String, Pos)
pInteger16Pos :: IsParser p Token => p (String, Pos)
pInteger10Pos :: IsParser p Token => p (String, Pos)
pInteger8Pos :: IsParser p Token => p (String, Pos)
pCharPos :: IsParser p Token => p (String, Pos)
pString :: IsParser p Token => p String
pConsym :: IsParser p Token => p String
pVarsym :: IsParser p Token => p String
pInteger :: IsParser p Token => p String
pTextln :: IsParser p Token => p String
pTextnm :: IsParser p Token => p String
pConid :: IsParser p Token => p String
pVarid :: IsParser p Token => p String
pFraction :: IsParser p Token => p String
pInteger16 :: IsParser p Token => p String
pInteger10 :: IsParser p Token => p String
pInteger8 :: IsParser p Token => p String
pChar :: IsParser p Token => p String
pComma :: IsParser p Token => p String
pCCurly :: IsParser p Token => p String
pOCurly :: IsParser p Token => p String
pCBrack :: IsParser p Token => p String
pOBrack :: IsParser p Token => p String
pCParen :: IsParser p Token => p String
pOParen :: IsParser p Token => p String
pSemi :: IsParser p Token => p String
pCommaPos :: IsParser p Token => p Pos
pCCurlyPos :: IsParser p Token => p Pos
pOCurlyPos :: IsParser p Token => p Pos
pCBrackPos :: IsParser p Token => p Pos
pOBrackPos :: IsParser p Token => p Pos
pCParenPos :: IsParser p Token => p Pos
pOParenPos :: IsParser p Token => p Pos
pSemiPos :: IsParser p Token => p Pos
pCommas :: IsParser p Token => p a -> p [a]
pSemics :: IsParser p Token => p a -> p [a]
pParens :: IsParser p Token => p a -> p a
pBracks :: IsParser p Token => p a -> p a
pCurly :: IsParser p Token => p a -> p a
pParens_pCommas :: IsParser p Token => p a -> p [a]
pBracks_pCommas :: IsParser p Token => p a -> p [a]
pCurly_pSemics :: IsParser p Token => p a -> p [a]
data ScanOpts
ScanOpts :: !(Set String) -> !(Set String) -> !(Set String) -> !(Set Char) -> !(Set Char) -> !(Set String) -> !Bool -> ![String] -> !String -> !String -> !String -> !Bool -> ![(String, String)] -> !Bool -> ScanOpts
scoKeywordsTxt :: ScanOpts -> !(Set String)
scoCommandsTxt :: ScanOpts -> !(Set String)
scoKeywordsOps :: ScanOpts -> !(Set String)
scoSpecChars :: ScanOpts -> !(Set Char)
scoOpChars :: ScanOpts -> !(Set Char)
scoSpecPairs :: ScanOpts -> !(Set String)
scoDollarIdent :: ScanOpts -> !Bool
scoOffsideTrigs :: ScanOpts -> ![String]
scoOffsideModule :: ScanOpts -> !String
scoOffsideOpen :: ScanOpts -> !String
scoOffsideClose :: ScanOpts -> !String
scoLitmode :: ScanOpts -> !Bool
scoVerbOpenClose :: ScanOpts -> ![(String, String)]
scoAllowQualified :: ScanOpts -> !Bool
defaultScanOpts :: ScanOpts
isNoPos :: Pos -> Bool
posIs1stColumn :: Pos -> Bool
data InFilePos
InFilePos :: Int -> Int -> InFilePos
infpLine :: InFilePos -> Int
infpColumn :: InFilePos -> Int
infpStart :: InFilePos
infpNone :: InFilePos
infpAdvCol :: Int -> InFilePos -> InFilePos
infpAdvLine :: Int -> InFilePos -> InFilePos
infpAdv1Line :: InFilePos -> InFilePos
infpAdvStr :: String -> InFilePos -> InFilePos
genTokVal :: GenToken v t v -> v
genTokTp :: GenToken k t v -> Maybe t
genTokMap :: (a -> b) -> GenToken a t a -> GenToken b t b
isLF :: Char -> Bool
isStr :: Char -> Bool
isStrQuote :: Char -> Bool
isWhite :: Char -> Bool
isBlack :: Char -> Bool
isVarStart :: Char -> Bool
isVarRest :: Char -> Bool

module Language.Grammars.Murder.Derive
csLabel :: String -> Q [Dec]
csLabels :: [String] -> Q [Dec]

module Language.Grammars.Grammar
data TL
data FL a
data NF
data Grammar a
Grammar :: (Ref a env) -> (FinalEnv (Productions NF) env) -> Grammar a
newtype Productions l a env
PS :: [Prod l a env] -> Productions l a env
unPS :: Productions l a env -> [Prod l a env]
data Prod l a env
Star :: Prod l (a -> b) env -> Prod l a env -> Prod l b env
FlipStar :: Prod NF a env -> Prod NF (a -> b) env -> Prod NF b env
Sym :: Symbol a t env -> Prod l a env
Pure :: a -> Prod l a env
Fix :: Productions (FL a) a env -> Prod TL a env
Var :: Prod (FL a) a env
type GramEnv = Env (Productions NF)
type PreGramEnv = Env (Productions TL)
newtype PreProductions l env a
PP :: [Prod l a env] -> PreProductions l env a
unPP :: PreProductions l env a -> [Prod l a env]
type Line = Int
type Column = Int
type Filename = String
data Pos
Pos :: !Line -> !Column -> Pos
PosFile :: !Line -> !Column -> Filename -> Pos
data DTerm a
DTerm :: Pos -> a -> DTerm a
pos :: DTerm a -> Pos
value :: DTerm a -> a
mkDTerm :: a -> DTerm a
data TTerm
data TNonT
data TAttT
data Symbol a t env
Term :: String -> Symbol (DTerm String) TTerm env
Nont :: Ref a env -> Symbol a TNonT env
TermInt :: Symbol (DTerm Int) TAttT env
TermChar :: Symbol (DTerm Char) TAttT env
TermVarid :: Symbol (DTerm String) TAttT env
TermConid :: Symbol (DTerm String) TAttT env
TermOp :: Symbol (DTerm String) TAttT env
getRefNT :: Symbol a TNonT env -> Ref a env
pairEq :: Maybe (Equal a b) -> Maybe (Equal (a, t) (b, t))
matchSym :: Symbol a t1 env -> Symbol b t2 env -> Maybe (Equal (a, t1) (b, t2))
int :: Symbol (DTerm Int) TAttT env
char :: Symbol (DTerm Char) TAttT env
var :: Symbol (DTerm String) TAttT env
con :: Symbol (DTerm String) TAttT env
op :: Symbol (DTerm String) TAttT env
sym :: Symbol a t env -> PreProductions l env a
nt :: Symbol a TNonT env -> PreProductions l env a
ntPrd :: Symbol a TNonT env -> PreProductions l env a
tr :: String -> PreProductions l env (DTerm String)
prod :: PreProductions l env a -> Productions l a env
varPrd :: PreProductions (FL a) env a
fixPrd :: PreProductions (FL a) env a -> PreProductions TL env a
pSome :: PreProductions (FL [a]) env a -> PreProductions TL env [a]
pMany :: PreProductions (FL [a]) env a -> PreProductions TL env [a]
opt :: PreProductions l env a -> a -> PreProductions l env a
pMaybe :: (b, a -> b) -> PreProductions TL env a -> PreProductions TL env b
pFoldr :: (a -> b -> b, b) -> PreProductions (FL b) env a -> PreProductions TL env b

-- | The <a>Ii</a> is to be pronounced as <tt>stop</tt>
data Ii
Ii :: Ii

-- | The function <a>iI</a> is to be pronounced as <tt>start</tt>
iI :: Idiomatic l env (a -> a) g => g
class Idiomatic l env f g | g -> f l env
idiomatic :: Idiomatic l env f g => PreProductions l env f -> g
data Kw
Kw :: String -> Kw
kw :: String -> Kw
instance Eq Pos
instance Show a => Show (DTerm a)
instance Eq a => Eq (DTerm a)
instance Idiomatic l env f g => Idiomatic l env f (String -> g)
instance Idiomatic l env f g => Idiomatic l env ((a -> b) -> f) ((a -> b) -> g)
instance Idiomatic l env f g => Idiomatic l env (a -> f) (Symbol a TNonT env -> g)
instance Idiomatic l env f g => Idiomatic l env (a -> f) (PreProductions l env a -> g)
instance Idiomatic l env x (Ii -> PreProductions l env x)
instance Alternative (PreProductions l env)
instance Applicative (PreProductions l env)
instance Functor (PreProductions l env)
instance Show Pos

module Language.Grammars.Grammar.AspectAG
instance Idiomatic l env f g => Idiomatic l env ((Record HNil -> DTerm String) -> f) (Kw -> g)
instance Idiomatic l env f g => Idiomatic l env ((Record HNil -> a) -> f) (Symbol a TAttT env -> g)

module Language.Grammars.Grammar.AG
newtype SF a
SF :: a -> SF a
unSF :: SF a -> a
instance Idiomatic l env f g => Idiomatic l env (a -> f) (SF a -> g)
instance Idiomatic l env f g => Idiomatic l env (DTerm String -> f) (Kw -> g)
instance Idiomatic l env f g => Idiomatic l env (a -> f) (Symbol a TAttT env -> g)

module Language.Grammars.Murder.UUParsing
type Parser a = P (Str Char String LineCol) a
pInt :: Parser Int
pChr :: Parser Char
pVar' :: Parser String
pVar :: Set String -> Parser String
pCon' :: Parser String
pCon :: Set String -> Parser String
pIdChar :: Parser Char
pOp :: Parser String
pTerm :: String -> Parser String
pSpaces' :: Parser String
lc2Pos :: LineCol -> Pos
newtype Const f a s
C :: f a -> Const f a s
unC :: Const f a s -> f a

-- | The function <a>compile</a> generates a parser out of a closed grammar
compile :: Grammar a -> Parser a

-- | The function <a>compileKws</a> generates a parser out of a closed
--   grammar, restricting the identifiers to not belong to the list of
--   reserved words
compileKws :: Set String -> Grammar a -> Parser a
mapEnv :: (forall a. f a s -> g a s) -> Env f s env -> Env g s env
generate :: Set String -> Grammar a -> Parser a
data ParseResult a
Ok :: a -> ParseResult a
Rep :: a -> [Error LineCol] -> ParseResult a
nuberror :: Error a -> Error a

-- | The function <a>parse</a> runs the parser for an input.
parse :: Parser a -> String -> ParseResult a
instance Show a => Show (ParseResult a)

module Language.Grammars.Murder.UULib
toPos :: Pos -> Pos
toDTerm :: (a -> b) -> (a, Pos) -> DTerm b
pChr :: Parser Token (DTerm Char)
pInt :: Parser Token (DTerm Int)
pCon :: Parser Token (DTerm String)
pVar :: Parser Token (DTerm String)
pOp :: Parser Token (DTerm String)
pTerm :: IsParser p Token => String -> p (DTerm String)
newtype Const f a s
C :: f a -> Const f a s
unC :: Const f a s -> f a
compile :: Grammar a -> Parser Token a
mapEnv :: (forall a. f a s -> g a s) -> Env f s env -> Env g s env
type ParseMsg = Message Token (Maybe Token)
data ParseResult a
Ok :: a -> ParseResult a
Rep :: a -> [ParseMsg] -> ParseResult a
parse :: Parser Token a -> [Token] -> ParseResult a
rparse :: Parser Token a -> [Token] -> (a, [ParseMsg])
instance Show a => Show (ParseResult a)

module Language.Grammars.Murder
type GramTrafo = Trafo Unit (Productions NF)
type PreGramTrafo = Trafo Unit (Productions TL)
type ExtGram env start nts = PreGramTrafo env () (Export start nts env)
type GramExt env start nts start' nts' = PreGramTrafo env (Export start nts env) (Export start' nts' env)
data Export start nts env
Export :: (Symbol start TNonT env) -> (nts env) -> Export start nts env
addNT :: PreGramTrafo env (PreProductions TL env a) (Symbol a TNonT env)
addProds :: PreGramTrafo env (Symbol a TNonT env, PreProductions TL env a) ()
updProds :: PreGramTrafo env (Symbol a TNonT env, PreProductions TL env a -> PreProductions TL env a) ()
replaceProds :: PreGramTrafo env (Symbol a TNonT env, PreProductions TL env a) ()
closeGram :: (forall env. ExtGram env a nts) -> Grammar a
extendGram :: (NTRecord (nts env), NTRecord (nts' env)) => ExtGram env start nts -> GramExt env start nts start' nts' -> ExtGram env start' nts'
(+>>) :: (NTRecord (nts env), NTRecord (nts' env)) => ExtGram env start nts -> GramExt env start nts start' nts' -> ExtGram env start' nts'
exportNTs :: NTRecord (nts env) => PreGramTrafo env (Export start nts env) (Export start nts env)
newtype LSPair nt a t env
LSPair :: (Symbol a t env) -> LSPair nt a t env
symLSPair :: LSPair nt a t env -> (Symbol a t env)
labelLSPair :: LSPair nt a t env -> nt
(^=) :: nt -> Symbol a t env -> LSPair nt a t env
data NTCons nt v l env
NTCons :: (LSPair nt v TNonT env) -> (l env) -> NTCons nt v l env
data NTNil env
NTNil :: NTNil env
class NTRecord r
class Fail err
data Duplicated nt
class NotDuplicated nt r
ntNil :: NTNil env
(^|) :: NTRecord (NTCons nt a l env) => LSPair nt a TNonT env -> l env -> NTCons nt a l env
class TypeEq x y b | x y -> b
data HTrue
data HFalse
typeEq :: TypeEq x y b => x -> y -> b
class GetNT nt r v | nt r -> v
getNT :: GetNT nt r v => nt -> r -> v
class GetNTLabel nt r v tenv | nt r -> v
getNTLabel :: GetNTLabel nt r v tenv => tenv -> nt -> r -> v
class GetNTBool b nt r v tenv | b nt r -> v
getNTBool :: GetNTBool b nt r v tenv => b -> tenv -> nt -> r -> v
data NotFound nt tenv
getStart :: Export start nts env -> (Symbol start TNonT env)
exportList :: Symbol start TNonT env -> (NTNil env -> nts env) -> Export start nts env
export :: (NTRecord (l env), NotDuplicated nt (l env)) => nt -> Symbol a TNonT env -> l env -> NTCons nt a l env
extendExport :: Export start t env -> (t env -> nts env) -> Export start nts env
instance [overlap ok] GetNTLabel nt1 (l env) r (tenv env) => GetNTBool HFalse nt1 (NTCons nt2 v l env) r (tenv env)
instance [overlap ok] GetNTBool HTrue nt1 (NTCons nt1 v l env) (Symbol v TNonT env) (tenv env)
instance [overlap ok] (TypeEq nt1 nt2 b, GetNTBool b nt1 (NTCons nt2 v l env) r (tenv env)) => GetNTLabel nt1 (NTCons nt2 v l env) r (tenv env)
instance [overlap ok] Fail (NotFound nt (tenv env)) => GetNTLabel nt (NTNil env) r (tenv env)
instance [overlap ok] GetNTLabel nt (nts env) (Symbol a TNonT env) (nts env) => GetNT nt (Export start nts env) (Symbol a TNonT env)
instance [overlap ok] HFalse ~ b => TypeEq x y b
instance [overlap ok] TypeEq x x HTrue
instance [overlap ok] NotDuplicated nt1 (l env) => NotDuplicated nt1 (NTCons nt2 v l env)
instance [overlap ok] Fail (Duplicated nt) => NotDuplicated nt (NTCons nt v l env)
instance [overlap ok] NotDuplicated nt (NTNil env)
instance [overlap ok] (NTRecord (l env), NotDuplicated nt (l env)) => NTRecord (NTCons nt v l env)
instance [overlap ok] NTRecord (NTNil env)
