-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Acceptance test framework for web applications
--   
--   <i>About</i>
--   
--   Happybara is an acceptance test framework inspired by the popular Ruby
--   library "Capybara". A short example of Happybara's expressive DSL:
--   
--   <pre>
--   visit "http://happybara-is-awesome.com"
--   within $ xpath "//form[@id='vote-for-happybara']" $ do
--      fillIn (fillableField "First Name" [ ]) "Bob"
--      fillIn (fillableField "Last Name"  [ ]) "Smith"
--   
--      click $ button "Vote!" [ disabled False ]
--   </pre>
--   
--   <i>Learning Happybara</i>
--   
--   I would suggest start with these resources (in order):
--   
--   <ul>
--   <li><a>The Happybara Readme</a></li>
--   <li><a>The Happybara Module docs</a></li>
--   </ul>
--   
--   Happy web testing!
@package happybara
@version 0.0.1


-- | This module provides XPath constructors for common HTML queries. The
--   <a>Text</a> argument is the locator (e.g. id, type, href, etc), and
--   the <a>Bool</a> argument indicates whether the generated XPath should
--   match exactly or inexactly.
--   
--   XPath string literals can be properly quoted and escaped using
--   <a>stringLiteral</a>.
--   
--   <i>Note:</i> These functions are mostly meant for internal use; you
--   probably want to use the queries in <a>Happybara.Query</a>.
module Happybara.XPath
normalizeSpace :: Text -> Text
stringLiteral :: Text -> Text
link :: Text -> Bool -> Text
button :: Text -> Bool -> Text
linkOrButton :: Text -> Bool -> Text
fieldset :: Text -> Bool -> Text
field :: Text -> Bool -> Text
fillableField :: Text -> Bool -> Text
select :: Text -> Bool -> Text
checkbox :: Text -> Bool -> Text
radioButton :: Text -> Bool -> Text
fileField :: Text -> Bool -> Text
optgroup :: Text -> Bool -> Text
option :: Text -> Bool -> Text
table :: Text -> Bool -> Text
definitionDescription :: Text -> Text


module Happybara.Exceptions
data HappybaraException
HappybaraException :: e -> HappybaraException
data InvalidElementException
InvalidElementException :: e -> InvalidElementException
data ExpectationNotMetException
ExpectationNotMetException :: ExpectationNotMetException
data ElementNotFoundException
ElementNotFoundException :: ElementNotFoundException
data AmbiguousElementException
AmbiguousElementException :: AmbiguousElementException
instance Typeable HappybaraException
instance Typeable InvalidElementException
instance Typeable ExpectationNotMetException
instance Typeable ElementNotFoundException
instance Typeable AmbiguousElementException
instance Show ExpectationNotMetException
instance Show ElementNotFoundException
instance Show AmbiguousElementException
instance Exception AmbiguousElementException
instance Exception ElementNotFoundException
instance Exception ExpectationNotMetException
instance Exception InvalidElementException
instance Show InvalidElementException
instance Exception HappybaraException
instance Show HappybaraException


module Happybara.Driver
data NodeValue
SingleValue :: Text -> NodeValue
MultiValue :: [Text] -> NodeValue
data FrameSelector
FrameIndex :: Int -> FrameSelector
FrameName :: Text -> FrameSelector
DefaultFrame :: FrameSelector
class Driver sess where data family Node sess :: *
currentUrl :: Driver sess => sess -> IO Text
visit :: Driver sess => sess -> Text -> IO ()
findXPath :: Driver sess => sess -> Text -> IO [Node sess]
findCSS :: Driver sess => sess -> Text -> IO [Node sess]
html :: Driver sess => sess -> IO Text
goBack :: Driver sess => sess -> IO ()
goForward :: Driver sess => sess -> IO ()
executeScript :: Driver sess => sess -> Text -> IO ()
evaluateScript :: Driver sess => sess -> Text -> IO Value
saveScreenshot :: Driver sess => sess -> Text -> Int -> Int -> IO ()
responseHeaders :: Driver sess => sess -> IO ResponseHeaders
statusCode :: Driver sess => sess -> IO Status
setFrameFocus :: Driver sess => sess -> FrameSelector -> IO ()
setWindowFocus :: Driver sess => sess -> Text -> IO ()
reset :: Driver sess => sess -> IO ()
findXPathRel :: Driver sess => sess -> Node sess -> Text -> IO [Node sess]
findCSSRel :: Driver sess => sess -> Node sess -> Text -> IO [Node sess]
allText :: Driver sess => sess -> Node sess -> IO Text
visibleText :: Driver sess => sess -> Node sess -> IO Text
attr :: Driver sess => sess -> Node sess -> Text -> IO (Maybe Text)
getValue :: Driver sess => sess -> Node sess -> IO NodeValue
setValue :: Driver sess => sess -> Node sess -> NodeValue -> IO ()
selectOption :: Driver sess => sess -> Node sess -> IO ()
unselectOption :: Driver sess => sess -> Node sess -> IO ()
click :: Driver sess => sess -> Node sess -> IO ()
rightClick :: Driver sess => sess -> Node sess -> IO ()
doubleClick :: Driver sess => sess -> Node sess -> IO ()
hover :: Driver sess => sess -> Node sess -> IO ()
dragTo :: Driver sess => sess -> Node sess -> Node sess -> IO ()
tagName :: Driver sess => sess -> Node sess -> IO Text
isVisible :: Driver sess => sess -> Node sess -> IO Bool
isChecked :: Driver sess => sess -> Node sess -> IO Bool
isSelected :: Driver sess => sess -> Node sess -> IO Bool
isDisabled :: Driver sess => sess -> Node sess -> IO Bool
path :: Driver sess => sess -> Node sess -> IO Text
trigger :: Driver sess => sess -> Node sess -> Text -> IO ()
nodeEq :: Driver sess => sess -> Node sess -> Node sess -> IO Bool
instance Eq NodeValue
instance Show NodeValue
instance Eq FrameSelector
instance Show FrameSelector


module Happybara.Monad

-- | The Happybara monad transformer.
--   
--   Requirements:
--   
--   <ul>
--   <li>The <i>sess</i> session type must be an instance of
--   <a>Driver</a>.</li>
--   <li>The inner monad <i>m</i> must be an instance of <a>MonadBase</a>
--   <a>IO</a> <i>m</i>, <a>MonadIO</a> <i>m</i>, and
--   <a>MonadBaseControl</a> <a>IO</a> <i>m</i>.</li>
--   </ul>
newtype HappybaraT sess m a
HappybaraT :: StateT (HappybaraState sess) m a -> HappybaraT sess m a
unHappybaraT :: HappybaraT sess m a -> StateT (HappybaraState sess) m a

-- | If you don't want to transform an existing monad, this type synonym
--   conveniently sets the inner monad to <a>IO</a>.
type Happybara sess a = HappybaraT sess IO a

-- | Evaluate the happybara computation.
runHappybaraT :: (Driver sess, MonadIO m, MonadBase IO m, MonadBaseControl IO m) => sess -> HappybaraT sess m a -> m a

-- | Evaluate the happybara computation.
runHappybara :: Driver sess => sess -> Happybara sess a -> IO a

-- | The exactness requirement when using the <a>Query</a> DSL.
data Exactness

-- | Find elements that match exactly.
Exact :: Exactness

-- | First try to find exact matches; if that fails, fall back to inexact
--   matches.
PreferExact :: Exactness

-- | Find all elements that partially match - e.g. the given string is
--   infix of (but not necessarily equal to) whatever property (id,
--   attribute, etc) is being queried over.
Inexact :: Exactness

-- | This controls the <a>Query</a> behavior of <a>findOrFail</a> in the
--   presence of multiple matches.
data SingleMatchStrategy

-- | If no elements matched, throw <a>ElementNotFoundException</a>;
--   otherwise, return the first matching element.
MatchFirst :: SingleMatchStrategy

-- | If no elements matched, throw <a>ElementNotFoundException</a>; if more
--   than element matches, throw <a>AmbiguousElementException</a>.
MatchOne :: SingleMatchStrategy

-- | Set the number of seconds to wait between retrying an action. See
--   <a>synchronize</a>.
setWait :: Monad m => Double -> HappybaraT sess m ()

-- | Get the number of seconds to wait between retrying an action. See
--   <a>synchronize</a>.
getWait :: (Functor m, Monad m) => HappybaraT sess m Double

-- | Set the required level of exactness for queries. See <a>Exactness</a>.
setExactness :: Monad m => Exactness -> HappybaraT sess m ()

-- | Get the required level of exactness for queries. See <a>Exactness</a>.
getExactness :: (Functor m, Monad m) => HappybaraT sess m Exactness

-- | Set the query matching strategy. See <a>SingleMatchStrategy</a>.
setSingleMatchStrategy :: Monad m => SingleMatchStrategy -> HappybaraT sess m ()

-- | Get the query matching strategy. See <a>SingleMatchStrategy</a>.
getSingleMatchStrategy :: (Functor m, Monad m) => HappybaraT sess m SingleMatchStrategy
getDriver :: (Functor m, Monad m) => HappybaraT sess m sess

-- | Use a different driver for the given action.
--   
--   <i>Note:</i> This sets the current scope via <a>withinPage</a> before
--   invoking the action, because the current node was acquired from a
--   different driver instance. Similarly, it's a bad idea to return a
--   <a>Node</a> from this new driver, as you might try to use it with the
--   wrong driver instance.
withDriver :: (Driver sess, Functor m, Monad m) => sess -> HappybaraT sess m a -> HappybaraT sess m a

-- | Get the node that all queries are currently relative to.
getCurrentNode :: (Driver sess, Functor m, Monad m) => HappybaraT sess m (Maybe (Node sess))
data HappybaraState sess
HappybaraState :: sess -> Double -> Exactness -> Bool -> SingleMatchStrategy -> Maybe (Node sess) -> HappybaraState sess
hsDriver :: HappybaraState sess -> sess
hsWait :: HappybaraState sess -> Double
hsExactness :: HappybaraState sess -> Exactness
hsIsSynced :: HappybaraState sess -> Bool
hsSingleMatchStrategy :: HappybaraState sess -> SingleMatchStrategy
hsCurrentNode :: HappybaraState sess -> Maybe (Node sess)
visit :: (Driver sess, Monad m, MonadBase IO m) => Text -> HappybaraT sess m ()
currentUrl :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m Text
responseHeaders :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m ResponseHeaders
statusCode :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m Status
html :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m Text
goBack :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m ()
goForward :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m ()
reset :: (Driver sess, Monad m, MonadBase IO m) => HappybaraT sess m ()
saveScreenshot :: (Driver sess, Monad m, MonadBase IO m) => Text -> Int -> Int -> HappybaraT sess m ()

-- | Make all queries relative to the supplied node within the given
--   action.
withinNode :: (Driver sess, Functor m, Monad m) => Node sess -> HappybaraT sess m a -> HappybaraT sess m a

-- | Make all queries relative to the document in the given action.
withinPage :: (Driver sess, Functor m, Monad m) => HappybaraT sess m a -> HappybaraT sess m a
withinFrame :: (Driver sess, Monad m, MonadBase IO m, MonadBaseControl IO m) => FrameSelector -> HappybaraT sess m Status -> HappybaraT sess m Status
withinWindow :: (Driver sess, Monad m, MonadBase IO m, MonadBaseControl IO m) => FrameSelector -> HappybaraT sess m Status -> HappybaraT sess m Status
executeScript :: (Driver sess, Monad m, MonadBase IO m) => Text -> HappybaraT sess m ()
evaluateScript :: (Driver sess, Monad m, MonadBase IO m) => Text -> HappybaraT sess m Value
findXPath :: (Driver sess, Monad m, MonadBase IO m) => Text -> HappybaraT sess m [Node sess]
findCSS :: (Driver sess, Monad m, MonadBase IO m) => Text -> HappybaraT sess m [Node sess]
allText :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Text
visibleText :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Text
attr :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> Text -> HappybaraT sess m (Maybe Text)
getValue :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m NodeValue
setValue :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> NodeValue -> HappybaraT sess m ()
selectOption :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
unselectOption :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
click :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
rightClick :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
doubleClick :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
hover :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m ()
dragTo :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> Node sess -> HappybaraT sess m ()
tagName :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Text
isVisible :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Bool
isChecked :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Bool
isSelected :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Bool
isDisabled :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Bool
path :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> HappybaraT sess m Text
trigger :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> Text -> HappybaraT sess m ()
nodeEq :: (Driver sess, Monad m, MonadBase IO m) => Node sess -> Node sess -> HappybaraT sess m Bool

-- | Invoke the given action until:
--   
--   <ul>
--   <li>The action no longer throws <a>InvalidElementException</a>,
--   or</li>
--   <li>The total duration of the attempts excedes the number of seconds
--   specified by <a>getWait</a>, in which case the exception is
--   rethrown.</li>
--   </ul>
--   
--   A couple notes:
--   
--   <ul>
--   <li>The action is retried every 0.05 seconds.</li>
--   <li>To prevent exponential retrying, any inner calls to
--   <a>synchronize</a> are ignored.</li>
--   <li>Unless you're doing something advanced, like implementing custom
--   <a>Query</a> instances, you probably don't need to invoke this
--   directly.</li>
--   </ul>
synchronize :: (Functor m, Monad m, MonadIO m, MonadBase IO m, MonadBaseControl IO m) => HappybaraT sess m a -> HappybaraT sess m a
instance Eq Exactness
instance Ord Exactness
instance Show Exactness
instance Functor m => Functor (HappybaraT sess m)
instance (Monad m, Functor m) => Applicative (HappybaraT sess m)
instance Monad m => Monad (HappybaraT sess m)
instance MonadTrans (HappybaraT sess)
instance MonadIO m => MonadIO (HappybaraT sess m)
instance MonadBaseControl b m => MonadBaseControl b (HappybaraT sess m)
instance MonadTransControl (HappybaraT sess)
instance MonadBase b m => MonadBase b (HappybaraT sess m)


module Happybara.Query

-- | This class is the backbone of Happybara's DOM querying DSL. While
--   Happybara includes support for a number of common queries, you're more
--   than welcome to implement your own <a>Query</a> instances, thus
--   extending the DSL.
--   
--   Queries are scoped to the current node as given by
--   <a>getCurrentNode</a>, and a new scope can be specified via
--   <a>within</a>.
--   
--   Note that the behavior of a query is dependent on the current
--   <a>Exactness</a> setting:
--   
--   <ul>
--   <li><a>Exact</a> - Find elements that match exactly.</li>
--   <li><a>PreferExact</a> - First try to find exact matches; if that
--   fails, fall back to inexact matches.</li>
--   <li><a>Inexact</a> - Find all elements that partially match - e.g. the
--   given string is infix of (but not necessarily equal to) whatever
--   property (id, attribute, etc) is being queried over.</li>
--   </ul>
--   
--   When locating a single item, the failure mode depends on the current
--   <a>SingleMatchStrategy</a> setting:
--   
--   <ul>
--   <li><a>MatchFirst</a> - If no elements matched, throw
--   <a>ElementNotFoundException</a>; otherwise, return the first matching
--   element.</li>
--   <li><a>MatchOne</a> - If no elements matched, throw
--   <a>ElementNotFoundException</a>; if more than element matches, throw
--   <a>AmbiguousElementException</a>.</li>
--   </ul>
--   
--   To set the current <a>Exactness</a>, use <a>setExactness</a>. To set
--   the current <a>SingleMatchStrategy</a>, use
--   <a>setSingleMatchStrategy</a>.
class (Driver sess, MonadIO m, MonadBase IO m, MonadBaseControl IO m) => Query q sess m
find :: Query q sess m => q sess m -> HappybaraT sess m (Maybe (Node sess))
findOrFail :: Query q sess m => q sess m -> HappybaraT sess m (Node sess)
findAll :: Query q sess m => q sess m -> HappybaraT sess m [Node sess]

-- | Set the current element scope to the element given by the query.
within :: (Query q sess m, Driver sess, Functor m, Monad m) => q sess m -> HappybaraT sess m a -> HappybaraT sess m a

-- | For each element given by the query, set the current scope accordingly
--   and invoke the monadic action, yielding each result.
withinAll :: (Query q sess m, Driver sess, Functor m, Monad m) => q sess m -> HappybaraT sess m a -> HappybaraT sess m [a]
link :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
button :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
linkOrButton :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
fieldset :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
field :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
fillableField :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
select :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
checkbox :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
radioButton :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
fileField :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
optgroup :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
option :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
table :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
definitionDescription :: Driver sess => Text -> [Node sess -> HappybaraT sess m Bool] -> SimpleQuery sess m
href :: (Driver sess, MonadBase IO m) => Text -> Node sess -> HappybaraT sess m Bool
checked :: (Driver sess, MonadBase IO m) => Bool -> Node sess -> HappybaraT sess m Bool
unchecked :: (Driver sess, MonadBase IO m) => Bool -> Node sess -> HappybaraT sess m Bool
disabled :: (Driver sess, MonadBase IO m) => Bool -> Node sess -> HappybaraT sess m Bool
selected :: (Driver sess, MonadBase IO m) => NodeValue -> Node sess -> HappybaraT sess m Bool
options :: (Driver sess, MonadBase IO m) => [Text] -> Node sess -> HappybaraT sess m Bool
elemType :: (Driver sess, MonadBase IO m) => Text -> Node sess -> HappybaraT sess m Bool
data SimpleQuery sess m
SimpleQuery :: (Bool -> Text) -> [(Node sess) -> HappybaraT sess m Bool] -> Text -> SimpleQuery sess m
sqXPath :: SimpleQuery sess m -> (Bool -> Text)
sqPredicates :: SimpleQuery sess m -> [(Node sess) -> HappybaraT sess m Bool]
sqDescription :: SimpleQuery sess m -> Text
instance (Driver sess, MonadIO m, MonadBase IO m, MonadBaseControl IO m) => Query SimpleQuery sess m


module Happybara
