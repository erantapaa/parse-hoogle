-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Encapsulate multiple web encoding in a single package. (deprecated)
--   
--   The idea is to minimize external dependencies so this is usable in
--   just about any context.
@package web-encodings
@version 0.3.0.9

module Web.Encodings.ListHelper
cons :: a -> [a] -> [a]

module Web.Encodings.StringLike
class (Eq a, Show a) => StringLike a where dropPrefix porig sorig = helper porig sorig where helper p s | null p && null s = Just empty | null p = Just s | null s = Nothing | head p == head s = helper (tail p) (tail s) | otherwise = Nothing dropPrefix' p c = case dropPrefix p c of { Just x -> x Nothing -> c } dropQuotes s | lengthGE 2 s && head s == '"' && last s == '"' = tail $ init s | otherwise = s chomp s | null s = s chomp s = case last s of { '\n' -> chomp $ init s '\r' -> chomp $ init s _ -> s } chompStart s = case uncons s of { Just ('\r', rest) -> case uncons rest of { Just ('\n', rest') -> rest' _ -> s } Just ('\n', rest) -> rest _ -> s } split c s = let (next, rest) = breakChar c s in if null next then (if null rest then [] else [rest]) else next : split c rest splitOneOf cs s = let (next, rest) = breakChars cs s in if null next then (if null rest then [] else [rest]) else next : splitOneOf cs rest breakCharsMaybe c s | null s = Nothing | head s `elem` c = Just (empty, tail s) | otherwise = do { (next, rest) <- breakCharsMaybe c (tail s); Just (cons (head s) next, rest) } breakCharMaybe c s | null s = Nothing | c == head s = Just (empty, tail s) | otherwise = do { (next, rest) <- breakCharMaybe c (tail s); Just (cons (head s) next, rest) } breakChar c s = fromMaybe (s, empty) $ breakCharMaybe c s breakChars c s = fromMaybe (s, empty) $ breakCharsMaybe c s breakString _ c | null c = (empty, empty) breakString p c = case dropPrefix p c of { Just x -> (empty, x) Nothing -> let x = head c xs = tail c (next, rest) = breakString p xs in (cons x next, rest) } takeLine a = let (x, y) = breakChar '\n' a x' = chomp x in (x', y) takeLineMaybe a = do { (x, y) <- breakCharMaybe '\n' a; Just (chomp x, y) } takeUntilBlank a = let (next, rest) = takeLine a in if null next then ([], rest) else let (nexts, rest') = takeUntilBlank rest in (next : nexts, rest') takeUntilBlankMaybe a = do { (next, rest) <- takeLineMaybe a; if null next then Just ([], rest) else do { (nexts, rest') <- takeUntilBlankMaybe rest; Just (next : nexts, rest') } } lengthLT i _ | i <= 0 = False lengthLT i a | null a = True | otherwise = lengthLT (i - 1) $ tail a lengthGE i = not . lengthLT i
span :: StringLike a => (Char -> Bool) -> a -> (a, a)
null :: StringLike a => a -> Bool
concatMap :: StringLike a => (Char -> String) -> a -> a
dropWhile :: StringLike a => (Char -> Bool) -> a -> a
break :: StringLike a => (Char -> Bool) -> a -> (a, a)
cons :: StringLike a => Char -> a -> a
uncons :: StringLike a => a -> Maybe (Char, a)
append :: StringLike a => a -> a -> a
intercalate :: StringLike a => a -> [a] -> a
isPrefixOf :: StringLike a => a -> a -> Bool
take :: StringLike a => Int -> a -> a
head :: StringLike a => a -> Char
tail :: StringLike a => a -> a
init :: StringLike a => a -> a
last :: StringLike a => a -> Char
empty :: StringLike a => a
pack :: StringLike a => String -> a
unpack :: StringLike a => a -> String
packUtf8 :: StringLike a => String -> a
unpackUtf8 :: StringLike a => ByteString -> Maybe a
dropPrefix :: StringLike a => a -> a -> Maybe a
dropPrefix' :: StringLike a => a -> a -> a
dropQuotes :: StringLike a => a -> a
chomp :: StringLike a => a -> a
chompStart :: StringLike a => a -> a
split :: StringLike a => Char -> a -> [a]
splitOneOf :: StringLike a => [Char] -> a -> [a]
breakCharsMaybe :: StringLike a => [Char] -> a -> Maybe (a, a)
breakCharMaybe :: StringLike a => Char -> a -> Maybe (a, a)
breakChar :: StringLike a => Char -> a -> (a, a)
breakChars :: StringLike a => [Char] -> a -> (a, a)
breakString :: StringLike a => a -> a -> (a, a)
takeLine :: StringLike a => a -> (a, a)
takeLineMaybe :: StringLike a => a -> Maybe (a, a)
takeUntilBlank :: StringLike a => a -> ([a], a)
takeUntilBlankMaybe :: StringLike a => a -> Maybe ([a], a)
lengthLT :: StringLike a => Int -> a -> Bool
lengthGE :: StringLike a => Int -> a -> Bool
concatMapUtf8 :: StringLike a => (Char -> String) -> a -> a
instance StringLike Text
instance StringLike Text
instance StringLike ByteString
instance StringLike ByteString
instance StringLike [Char]


-- | Functions for parsing MIME headers (Key: value; k1=v1; k2=v2)
module Web.Encodings.MimeHeader

-- | A single MIME header. type Header = (B8.ByteString, B8.ByteString,
--   BSMap)
type Header a = (a, a, SomeMap a)

-- | Parse a header line in the format:
--   
--   Name: value; attkey=attval; attkey2=attval2.
parseHeader :: StringLike a => a -> Header a
lookupHeader :: (StringLike s, Failure (HeaderNotFound s) m, Eq s, Monad m) => s -> [Header s] -> m s
lookupHeaderAttr :: (Failure (AttributeNotFound s) m, StringLike s, Eq s, Monad m) => s -> s -> [Header s] -> m s
data AttributeNotFound s
AttributeNotFound :: s -> s -> AttributeNotFound s
data HeaderNotFound s
HeaderNotFound :: s -> HeaderNotFound s
instance Typeable1 AttributeNotFound
instance Typeable1 HeaderNotFound
instance Show s => Show (AttributeNotFound s)
instance Show s => Show (HeaderNotFound s)
instance (Show s, Typeable s) => Exception (HeaderNotFound s)
instance (Typeable s, Show s) => Exception (AttributeNotFound s)


-- | Various web encodings.
module Web.Encodings

-- | Encode all but unreserved characters with percentage encoding.
--   
--   This function implicitly converts the given value to a UTF-8
--   bytestream.
encodeUrl :: StringLike a => a -> a

-- | Decode percentage encoding. Assumes use of UTF-8 character encoding.
--   
--   If there are any parse errors, this returns the original input. If you
--   would like to be alerted more directly of errors, use
--   <a>decodeUrlFailure</a>.
decodeUrl :: StringLike s => s -> s

-- | Same as <a>decodeUrl</a>, but <a>failure</a>s on either invalid
--   percent or UTF8 encoding.
decodeUrlFailure :: (Failure DecodeUrlException m, StringLike s, Monad m) => s -> m s
data DecodeUrlException
InvalidPercentEncoding :: DecodeUrlException
InvalidUtf8Encoding :: DecodeUrlException

-- | Escape special HTML characters.
encodeHtml :: StringLike s => s -> s

-- | Decode HTML-encoded content into plain content.
--   
--   Note: this does not support all HTML entities available. It also
--   swallows all failures.
decodeHtml :: StringLike s => s -> s

-- | Perform JSON-encoding on a string. Does not wrap in quotation marks.
--   Taken from json package by Sigbjorn Finne.
encodeJson :: StringLike s => s -> s
decodeJson :: StringLike s => s -> s

-- | Convert a list of key-values pairs into a query string. Does not
--   include the question mark at the beginning.
encodeUrlPairs :: StringLike s => [(s, s)] -> s

-- | Convert into key-value pairs. Strips the leading ? if necesary.
decodeUrlPairs :: StringLike s => s -> [(s, s)]

-- | Convert into key-value pairs. Strips the leading ? if necesary.
--   <a>failure</a>s as necesary for invalid encodings.
decodeUrlPairsFailure :: (StringLike s, Failure DecodeUrlException m, Monad m) => s -> m [(s, s)]

-- | Information on an uploaded file.
data FileInfo s c
FileInfo :: s -> s -> c -> FileInfo s c
fileName :: FileInfo s c -> s
fileContentType :: FileInfo s c -> s
fileContent :: FileInfo s c -> c

-- | Parse a multipart form into parameters and files.
parseMultipart :: StringLike s => String -> s -> ([(s, s)], [(s, FileInfo s s)])

-- | Parse a post request. This function determines the correct decoding
--   function to use.
parsePost :: StringLike s => String -> String -> s -> ([(s, s)], [(s, FileInfo s s)])

-- | Deprecate alias for <a>parseCookies</a>.
decodeCookies :: StringLike s => s -> [(s, s)]

-- | Decode the value of an HTTP_COOKIE header into key/value pairs.
parseCookies :: StringLike s => s -> [(s, s)]

-- | Parse the HTTP accept string to determine supported content types.
parseHttpAccept :: StringLike s => s -> [s]

-- | Format a <a>UTCTime</a> in W3 format; useful for setting cookies.
formatW3 :: UTCTime -> String

-- | A destination for data, the opposite of a <tt>Source</tt>.
data Sink x y
Sink :: IO x -> (x -> ByteString -> IO x) -> (x -> IO y) -> (y -> IO ()) -> Sink x y
sinkInit :: Sink x y -> IO x
sinkAppend :: Sink x y -> x -> ByteString -> IO x
sinkClose :: Sink x y -> x -> IO y
sinkFinalize :: Sink x y -> y -> IO ()
lbsSink :: Sink ([ByteString] -> [ByteString]) ByteString
tempFileSink :: Sink (FilePath, Handle) FilePath
instance Typeable DecodeUrlException
instance Show DecodeUrlException
instance (Eq s, Eq c) => Eq (FileInfo s c)
instance (Show s, Show c) => Show (FileInfo s c)
instance Show (ParseState x)
instance Exception DecodeUrlException
