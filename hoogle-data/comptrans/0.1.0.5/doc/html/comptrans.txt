-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatically converting ASTs into compositional data types
--   
@package comptrans
@version 0.1.0.5


-- | GHC has a phase restriction which prevents code generated by Template
--   Haskell being referred to by Template Haskell in the same file. Thus,
--   when using this library, you will need to spread invocations out over
--   several files.
--   
--   We will refer to the following example in the documentation:
--   
--   <pre>
--   module Foo where
--   data Arith = Add Atom Atom
--   data Atom = Var String | Const Lit
--   data Lit = Lit Int
--   </pre>
module Data.Comp.Trans

-- | Declares a multi-sorted compositional datatype isomorphic to the given
--   ADT.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   import qualified Foo as F
--   deriveMultiComp ''F.Arith
--   </pre>
--   
--   will create
--   
--   <pre>
--   data ArithL
--   data AtomL
--   data LitL
--   
--   data Arith e l where
--     Add :: e AtomL -&gt; e AtomL -&gt; Arith e ArithL
--   
--   data Atom e l where
--     Var :: String -&gt; Atom e AtomL
--     Const :: e LitL -&gt; Atom e AtomL
--   
--   data Lit (e :: * -&gt; *) l where
--     Lit :: Int -&gt; Lit e LitL
--   </pre>
deriveMultiComp :: Name -> Q [Dec]

-- | <i>e.g.</i>
--   
--   <pre>
--   generateNameLists ''Arith
--   </pre>
--   
--   will create
--   
--   <pre>
--   origASTTypes = [mkName <a>Foo.Arith</a>, mkName <a>Foo.Atom</a>, mkName <a>Foo.Lit</a>]
--   newASTTypes  = [mkName <a>Arith</a>, mkName <a>Atom</a>, mkName <a>Lit</a>]
--   newASTLabels = map ConT [mkName <a>ArithL</a>, mkName "AtomL', mkName <a>LitL</a>]
--   </pre>
generateNameLists :: Name -> Q [Dec]

-- | Folds together names with <tt>(<a>:+:</a>)</tt>.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   import qualified Foo as F
--   deriveMult ''F.Arith
--   makeSumType "ArithSig" [''Arith, ''Atom, ''Lit]
--   </pre>
--   
--   will create
--   
--   <pre>
--   type ArithSig = Arith :+: Atom :+: Lit
--   </pre>
--   
--   You can use <a>generateNameLists</a> to avoid spelling out the names
--   manually
makeSumType :: String -> [Name] -> Q [Dec]
getLabels :: [Name] -> Q [Type]

-- | Creates a functions translating from an ADT to its isomorphic
--   multi-sorted compositional data type
--   
--   <pre>
--   import qualified Foo as F
--   ...
--   type ArithTerm = Term Arith
--   deriveTrans ''Arith [''Arith, ''Atom, ''Lit] ArithTerm
--   </pre>
--   
--   will create
--   
--   <pre>
--   translate :: F.Arith -&gt; ArithTerm ArithL
--   translate = trans
--   
--   
--   class Trans a l where
--     trans a -&gt; ArithTerm l
--   
--   instance Trans F.Arith ArithL where
--     trans (F.Add x y) = iAdd (trans x) (trans y)
--   
--   instance Trans F.Atom AtomL where
--     trans (F.Var s)   = iVar s
--     trans (F.Const x) = iConst (trans x)
--   
--   instance Trans F.Lit LitL where
--     trans (F.Lit n) = iLit n
--   </pre>
deriveTrans :: Name -> [Name] -> Type -> Q [Dec]

-- | Creates an <tt>untranslate</tt> function inverting the
--   <tt>translate</tt> function created by <tt>deriveTrans</tt>.
--   
--   <pre>
--   import qualified Foo as F
--   type ArithTerm = Term (Arith :+: Atom :+: Lit)
--   deriveUntrans [''F.Arith, ''F.Atom, ''F.Lit] (TH.ConT ''ArithTerm)
--   </pre>
--   
--   will create
--   
--   <pre>
--   type family Targ l
--   newtype T l = T {t :: Targ l}
--   
--   class Untrans f where
--     untrans :: Alg f t
--   
--   untranslate :: ArithTerm l -&gt; Targ l
--   untranslate = t . cata untrans
--   
--   type instance Targ ArithL = F.Arith
--   instance Untrans Arith where
--     untrans (Add x y) = T $ F.Add (t x) (t y)
--   
--   type instance Targ AtomL = F.Atom
--   instance Untrans Atom where
--     untrans (Var s)   = T $ F.Var s
--     untrans (Const x) = T $ F.Const (t x)
--   
--   type instance Targ LitL = F.Lit
--   instance Untrans Lit where
--     untrans (Lit n) = T $ F.Lit n
--   </pre>
--   
--   Note that you will need to manually provide an instance <tt>(Untrans
--   f, Untrans g) =&gt; Untrans (f :+: g)</tt> due to phase issues.
deriveUntrans :: [Name] -> Type -> Q [Dec]


-- | Allows you to derive instances of GHC.Generics for compositional data
--   types. Warning: May slaughter your compile times.
module Data.Comp.Derive.Generic
makeGeneric :: [Name] -> [Type] -> Q [Dec]
makeInstancesLike :: [Name] -> [Type] -> Q [Dec] -> Q [Dec]
data GenericExample
instance [overlap ok] Generic (f e l) => Generic ((:&:) f p e l)
instance [overlap ok] Generic (f (Term f) l) => Generic (Term f l)
instance [overlap ok] (Generic (f e l), Generic (g e l)) => Generic ((:+:) f g e l)
