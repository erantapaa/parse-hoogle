-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate a web service for servant 'Resource's using scotty and JSON
--   
--   Generate a web service for servant <a>Resource</a>s using scotty and
--   JSON
@package servant-scotty
@version 0.1.1


-- | This module exports the <a>Response</a> class and a handy
--   <a>respond</a> function that you can use when defining handlers for
--   your own operations.
module Servant.Scotty.Response

-- | Given the result of some operation, it picks the appropriate response
--   type and uses <a>toResponse</a> to convert the result to a
--   JSON-encodable value along with a status code, both used to then send
--   a response to the client.
respond :: (Response resp x, ScottyError e, Monad m) => x -> ActionT e m ()


-- | Functions and typeclasses for automatically fetching the arguments of
--   the "database operations" from either the request path or from the
--   request body, by decoding it from JSON to your type.
module Servant.Scotty.Arguments

-- | What it means for a scotty <a>Resource</a> to have an index type.
--   
--   <ul>
--   <li><a>idx</a> should lookup in the request path whatever is necessary
--   to get the <tt>i</tt> of <tt>Resource c a i r e ops</tt>, for
--   operations that take it as an argument, e.g <i>Delete</i>,
--   <i>Update</i> or <i>View</i>.</li>
--   <li><a>route</a> should return a <a>String</a> that'll be passed to
--   <a>capture</a>. You may use one or more "path parameters" (calls to
--   <a>param</a>, instances of <a>Param</a>) to compute your value of type
--   <tt>k</tt>. You probably want to use <a>name</a> on the
--   <a>Resource</a> to generate the beginning of the path.</li>
--   </ul>
class Index k
idx :: (Index k, Functor m, MonadIO m, ScottyError e) => ActionT e m k
route :: Index k => Resource c a k r e ops -> String

-- | Simply gets the request's body as JSON (or raises an exception if the
--   decoding fails)
js :: (MonadIO m, ScottyError e, FromJSON a) => ActionT e m a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--      parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                             v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                             v <tt>.:</tt> "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--      parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a


-- | This module contains the class that you must implement if you want
--   some operation supported by the scotty backend and some utilities
--   you'll most likely need if you want to define your own instances.
--   
--   Import <tt>Servant.Scotty.Prelude</tt> if you want instances for the
--   REST-y operations defined in <tt>Servant.Prelude</tt>.
module Servant.Scotty.Op

-- | A class that lets you define one or more handler(s) for an operation
--   <tt>o</tt>.
class ScottyOp o where type family Suitable o a i (r :: * -> *) :: Constraint
runOperation :: (ScottyOp o, Functor m, MonadIO m, ScottyError e, Suitable o a i r) => Resource c a i r e (o : ops) -> Operation o c a i r -> ScottyT e m ()

-- | This is a function you'll want to use when defining your own
--   operations.
--   
--   It runs the second argument to get the operation to run, and feeds it
--   the <a>Resource</a> argument's context and extracts the result.
--   
--   Intended to be used in <a>runOperation</a> in a way similar to
--   
--   <pre>
--   -- example: for the 'Delete' operation
--   runOperation res op =
--     delete (capture $ "/" ++ name res ++ route res) $ do
--       result &lt;- safely res $ op &lt;$&gt; idx
--       respond result
--   </pre>
--   
--   Here we just take the particular delete operation for the client
--   code's type, lookup the <a>Index</a> argument it takes from the
--   request path and run the operation <a>safely</a>, eventually
--   converting its result to an appropriate response.
safely :: (MonadIO m, ScottyError e) => Resource c a i r e ops -> ActionT e m (c -> IO x) -> ActionT e m x

-- | A class that ties return types of your database operations and the
--   output that will be generated to communicate the result.
--   
--   <ul>
--   <li>The first type, <tt>resp</tt>, is the response type that will be
--   encoded in JSON and sent as the response body.</li>
--   <li>The second type, <tt>result</tt>, is the result type of your
--   "database" or "context" operation.</li>
--   </ul>
--   
--   For example, if you're adding an item, and if you're using
--   postgresql-simple, you'll probably want to use the <a>Response</a>
--   instances defined in the servant-postgresql package, in the
--   <tt>Servant.PostgreSQL.Prelude</tt> module.
--   
--   It lets you specify, given a value of your result, if no exception is
--   thrown, what response should be sent as JSON to the client along with
--   what HTTP status.
--   
--   There's a functional dependency at play: the result type of a database
--   operation determines the representation that'll be picked for
--   generating the json output.
class ToJSON resp => Response resp result | result -> resp
toResponse :: Response resp result => result -> (resp, Status)

-- | Given the result of some operation, it picks the appropriate response
--   type and uses <a>toResponse</a> to convert the result to a
--   JSON-encodable value along with a status code, both used to then send
--   a response to the client.
respond :: (Response resp x, ScottyError e, Monad m) => x -> ActionT e m ()

-- | What it means for a scotty <a>Resource</a> to have an index type.
--   
--   <ul>
--   <li><a>idx</a> should lookup in the request path whatever is necessary
--   to get the <tt>i</tt> of <tt>Resource c a i r e ops</tt>, for
--   operations that take it as an argument, e.g <i>Delete</i>,
--   <i>Update</i> or <i>View</i>.</li>
--   <li><a>route</a> should return a <a>String</a> that'll be passed to
--   <a>capture</a>. You may use one or more "path parameters" (calls to
--   <a>param</a>, instances of <a>Param</a>) to compute your value of type
--   <tt>k</tt>. You probably want to use <a>name</a> on the
--   <a>Resource</a> to generate the beginning of the path.</li>
--   </ul>
class Index k
idx :: (Index k, Functor m, MonadIO m, ScottyError e) => ActionT e m k
route :: Index k => Resource c a k r e ops -> String

-- | Simply gets the request's body as JSON (or raises an exception if the
--   decoding fails)
js :: (MonadIO m, ScottyError e, FromJSON a) => ActionT e m a


-- | Instances of <a>ScottyOp</a> for the operations defined in
--   <a>Servant.Prelude</a>, along with some reusable types necessary for
--   the instances.
module Servant.Scotty.Prelude

-- | A class that lets you define one or more handler(s) for an operation
--   <tt>o</tt>.
class ScottyOp o where type family Suitable o a i (r :: * -> *) :: Constraint
runOperation :: (ScottyOp o, Functor m, MonadIO m, ScottyError e, Suitable o a i r) => Resource c a i r e (o : ops) -> Operation o c a i r -> ScottyT e m ()
instance ScottyOp View
instance ScottyOp Update
instance ScottyOp ListAll
instance ScottyOp Delete
instance ScottyOp Add


-- | Module for defining a <a>scotty</a> webservice from <a>Resource</a>s.
--   
--   <pre>
--   EXAMPLE HERE
--   </pre>
module Servant.Scotty

-- | Internal class used to drive the recursion on the list of operations
--   when generating all the endpoints and handlers.
--   
--   This lets everyone care only about the specific behavior of their
--   operations, this class will make sure all the operations of your
--   <a>Resource</a> have an implementation.
--   
--   Regardless of what's specific about each operation, we just
--   recursively go through all the operations and call <a>runOperation</a>
--   for each of them.
class Runnable ops
runResource :: (Runnable ops, Functor m, MonadIO m, ScottyError e, Suitables ops a i r) => Resource c a i r e ops -> ScottyT e m ()

-- | A class that lets you define one or more handler(s) for an operation
--   <tt>o</tt>.
class ScottyOp o where type family Suitable o a i (r :: * -> *) :: Constraint
runOperation :: (ScottyOp o, Functor m, MonadIO m, ScottyError e, Suitable o a i r) => Resource c a i r e (o : ops) -> Operation o c a i r -> ScottyT e m ()

-- | What it means for a scotty <a>Resource</a> to have an index type.
--   
--   <ul>
--   <li><a>idx</a> should lookup in the request path whatever is necessary
--   to get the <tt>i</tt> of <tt>Resource c a i r e ops</tt>, for
--   operations that take it as an argument, e.g <i>Delete</i>,
--   <i>Update</i> or <i>View</i>.</li>
--   <li><a>route</a> should return a <a>String</a> that'll be passed to
--   <a>capture</a>. You may use one or more "path parameters" (calls to
--   <a>param</a>, instances of <a>Param</a>) to compute your value of type
--   <tt>k</tt>. You probably want to use <a>name</a> on the
--   <a>Resource</a> to generate the beginning of the path.</li>
--   </ul>
class Index k
idx :: (Index k, Functor m, MonadIO m, ScottyError e) => ActionT e m k
route :: Index k => Resource c a k r e ops -> String

-- | Simply gets the request's body as JSON (or raises an exception if the
--   decoding fails)
js :: (MonadIO m, ScottyError e, FromJSON a) => ActionT e m a

-- | This is a function you'll want to use when defining your own
--   operations.
--   
--   It runs the second argument to get the operation to run, and feeds it
--   the <a>Resource</a> argument's context and extracts the result.
--   
--   Intended to be used in <a>runOperation</a> in a way similar to
--   
--   <pre>
--   -- example: for the 'Delete' operation
--   runOperation res op =
--     delete (capture $ "/" ++ name res ++ route res) $ do
--       result &lt;- safely res $ op &lt;$&gt; idx
--       respond result
--   </pre>
--   
--   Here we just take the particular delete operation for the client
--   code's type, lookup the <a>Index</a> argument it takes from the
--   request path and run the operation <a>safely</a>, eventually
--   converting its result to an appropriate response.
safely :: (MonadIO m, ScottyError e) => Resource c a i r e ops -> ActionT e m (c -> IO x) -> ActionT e m x

-- | A class that ties return types of your database operations and the
--   output that will be generated to communicate the result.
--   
--   <ul>
--   <li>The first type, <tt>resp</tt>, is the response type that will be
--   encoded in JSON and sent as the response body.</li>
--   <li>The second type, <tt>result</tt>, is the result type of your
--   "database" or "context" operation.</li>
--   </ul>
--   
--   For example, if you're adding an item, and if you're using
--   postgresql-simple, you'll probably want to use the <a>Response</a>
--   instances defined in the servant-postgresql package, in the
--   <tt>Servant.PostgreSQL.Prelude</tt> module.
--   
--   It lets you specify, given a value of your result, if no exception is
--   thrown, what response should be sent as JSON to the client along with
--   what HTTP status.
--   
--   There's a functional dependency at play: the result type of a database
--   operation determines the representation that'll be picked for
--   generating the json output.
class ToJSON resp => Response resp result | result -> resp
toResponse :: Response resp result => result -> (resp, Status)

-- | Given the result of some operation, it picks the appropriate response
--   type and uses <a>toResponse</a> to convert the result to a
--   JSON-encodable value along with a status code, both used to then send
--   a response to the client.
respond :: (Response resp x, ScottyError e, Monad m) => x -> ActionT e m ()
instance (ScottyOp o, Runnable ops) => Runnable ((':) * o ops)
instance Runnable ('[] *)
