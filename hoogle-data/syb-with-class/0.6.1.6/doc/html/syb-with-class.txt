-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Scrap Your Boilerplate With Class
--   
@package syb-with-class
@version 0.6.1.6

module Data.Generics.SYB.WithClass.Context
class Sat a
dict :: Sat a => a
data NoCtx a
noCtx :: NoCtx ()
data PairCtx l r a
PairCtx :: l a -> r a -> PairCtx l r a
leftCtx :: PairCtx l r a -> l a
rightCtx :: PairCtx l r a -> r a
pairCtx :: l () -> r () -> PairCtx l r ()
instance [overlap ok] (Sat (l a), Sat (r a)) => Sat (PairCtx l r a)
instance [overlap ok] Sat (NoCtx a)

module Data.Generics.SYB.WithClass.Basics
data Proxy (a :: * -> *)
class (Typeable a, Sat (ctx a)) => Data ctx a where gfoldl _ _ z = z gunfold _ _ _ _ = undefined dataTypeOf _ _ = undefined dataCast1 _ _ = Nothing dataCast2 _ _ = Nothing
gfoldl :: Data ctx a => Proxy ctx -> (forall b c. Data ctx b => w (b -> c) -> b -> w c) -> (forall g. g -> w g) -> a -> w a
gunfold :: Data ctx a => Proxy ctx -> (forall b r. Data ctx b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
toConstr :: Data ctx a => Proxy ctx -> a -> Constr
dataTypeOf :: Data ctx a => Proxy ctx -> a -> DataType
dataCast1 :: (Data ctx a, Typeable1 t) => Proxy ctx -> (forall b. Data ctx b => w (t b)) -> Maybe (w a)
dataCast2 :: (Data ctx a, Typeable2 t) => Proxy ctx -> (forall b c. (Data ctx b, Data ctx c) => w (t b c)) -> Maybe (w a)
type GenericT ctx = forall a. Data ctx a => a -> a
gmapT :: Proxy ctx -> GenericT ctx -> GenericT ctx
newtype ID x
ID :: x -> ID x
unID :: ID x -> x
type GenericM m ctx = forall a. Data ctx a => a -> m a
gmapM :: Monad m => Proxy ctx -> GenericM m ctx -> GenericM m ctx
type GenericQ ctx r = forall a. Data ctx a => a -> r
gmapQ :: Proxy ctx -> GenericQ ctx r -> GenericQ ctx [r]
gmapQr :: Data ctx a => Proxy ctx -> (r' -> r -> r) -> r -> GenericQ ctx r' -> a -> r
newtype Qr r a
Qr :: (r -> r) -> Qr r a
unQr :: Qr r a -> r -> r

-- | Build a term skeleton
fromConstr :: Data ctx a => Proxy ctx -> Constr -> a

-- | Build a term and use a generic function for subterms
fromConstrB :: Data ctx a => Proxy ctx -> (forall b. Data ctx b => b) -> Constr -> a

-- | Monadic variation on "fromConstrB"
fromConstrM :: (Monad m, Data ctx a) => Proxy ctx -> (forall b. Data ctx b => m b) -> Constr -> m a

-- | Representation of datatypes. | A package of constructor
--   representations with names of type and module. | The list of
--   constructors could be an array, a balanced tree, or others.
data DataType
DataType :: String -> DataRep -> DataType
tycon :: DataType -> String
datarep :: DataType -> DataRep

-- | Representation of constructors
data Constr
Constr :: ConstrRep -> String -> [String] -> Fixity -> DataType -> Constr
conrep :: Constr -> ConstrRep
constring :: Constr -> String
confields :: Constr -> [String]
confixity :: Constr -> Fixity
datatype :: Constr -> DataType

-- | Equality of constructors

-- | Public representation of datatypes
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
StringRep :: DataRep
NoRep :: DataRep

-- | Public representation of constructors
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Double -> ConstrRep
StringConstr :: String -> ConstrRep

-- | Unique index for datatype constructors. | Textual order is respected.
--   Starts at 1.
type ConIndex = Int

-- | Fixity of constructors
data Fixity
Prefix :: Fixity
Infix :: Fixity

-- | Gets the type constructor including the module
dataTypeName :: DataType -> String

-- | Gets the public presentation of datatypes
dataTypeRep :: DataType -> DataRep

-- | Gets the datatype of a constructor
constrType :: Constr -> DataType

-- | Gets the public presentation of constructors
constrRep :: Constr -> ConstrRep

-- | Look up a constructor by its representation
repConstr :: DataType -> ConstrRep -> Constr

-- | Constructs an algebraic datatype
mkDataType :: String -> [Constr] -> DataType

-- | Constructs a constructor
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr

-- | Gets the constructors
dataTypeConstrs :: DataType -> [Constr]

-- | Gets the field labels of a constructor
constrFields :: Constr -> [String]

-- | Gets the fixity of a constructor
constrFixity :: Constr -> Fixity

-- | Gets the string for a constructor
showConstr :: Constr -> String

-- | Lookup a constructor via a string
readConstr :: DataType -> String -> Maybe Constr

-- | Test for an algebraic type
isAlgType :: DataType -> Bool

-- | Gets the constructor for an index
indexConstr :: DataType -> ConIndex -> Constr

-- | Gets the index of a constructor
constrIndex :: Constr -> ConIndex

-- | Gets the maximum constructor index
maxConstrIndex :: DataType -> ConIndex

-- | Constructs the Int type
mkIntType :: String -> DataType

-- | Constructs the Float type
mkFloatType :: String -> DataType

-- | Constructs the String type
mkStringType :: String -> DataType

-- | Helper for mkIntType, mkFloatType, mkStringType
mkPrimType :: DataRep -> String -> DataType
mkPrimCon :: DataType -> String -> ConstrRep -> Constr
mkIntConstr :: DataType -> Integer -> Constr
mkFloatConstr :: DataType -> Double -> Constr
mkStringConstr :: DataType -> String -> Constr

-- | Constructs a non-representation
mkNorepType :: String -> DataType

-- | Test for a non-representable type
isNorepType :: DataType -> Bool
instance [overlap ok] Eq ConstrRep
instance [overlap ok] Show ConstrRep
instance [overlap ok] Eq Fixity
instance [overlap ok] Show Fixity
instance [overlap ok] Show DataType
instance [overlap ok] Eq DataRep
instance [overlap ok] Show DataRep
instance [overlap ok] Eq Constr
instance [overlap ok] Show Constr

module Data.Generics.SYB.WithClass.Derive

-- | Takes the name of an algebraic data type, the number of type
--   parameters it has and creates a Typeable instance for it.
deriveTypeablePrim :: Name -> Int -> Q [Dec]
type Constructor = (Name, Int, Maybe [Name], [Type])
escape :: String -> String

-- | Takes a name of a algebraic data type, the number of parameters it has
--   and a list of constructor pairs. Each one of these constructor pairs
--   consists of a constructor name and the number of type parameters it
--   has. The function returns an automatically generated instance
--   declaration for the Data class.
--   
--   Doesn't do gunfold, dataCast1 or dataCast2
deriveDataPrim :: Name -> [Type] -> [Constructor] -> Q [Dec]
deriveMinimalData :: Name -> Int -> Q [Dec]
typeInfo :: Dec -> Q (Name, [Name], [Constructor])

-- | Derives the Data and Typeable instances for a single given data type.
deriveOne :: Name -> Q [Dec]
deriveOneDec :: Dec -> Q [Dec]
deriveOneData :: Name -> Q [Dec]

-- | Derives Data and Typeable instances for a list of data types. Order is
--   irrelevant. This should be used in favour of deriveOne since Data and
--   Typeable instances can often depend on other Data and Typeable
--   instances - e.g. if you are deriving a large, mutually recursive data
--   type. If you splice the derived instances in one by one you will need
--   to do it in depedency order which is difficult in most cases and
--   impossible in the mutually recursive case. It is better to bring all
--   the instances into scope at once.
--   
--   e.g. if data Foo = Foo Int is declared in an imported module then
--   $(derive [''Foo]) will derive the instances for it
derive :: [Name] -> Q [Dec]
deriveDec :: [Dec] -> Q [Dec]
deriveData :: [Name] -> Q [Dec]
deriveTypeable :: [Name] -> Q [Dec]
deriveOneTypeable :: Name -> Q [Dec]

-- | This function is much like deriveOne except that it brings into scope
--   an instance of Data with minimal definitions. gfoldl will essentially
--   leave a data structure untouched while gunfoldl, toConstr and
--   dataTypeOf will yield errors.
--   
--   This function is useful when you are certain that you will never wish
--   to transform a particular data type. For instance you may be
--   transforming another data type that contains other data types, some of
--   which you wish to transform (perhaps recursively) and some which you
--   just wish to return unchanged.
--   
--   Sometimes you will be forced to use deriveMinimalOne because you do
--   not have access to the contructors of the data type (perhaps because
--   it is an Abstract Data Type). However, should the interface to the ADT
--   be sufficiently rich it is possible to define you're own Data and
--   Typeable instances.
deriveMinimalOne :: Name -> Q [Dec]
deriveMinimal :: [Name] -> Q [Dec]

module Data.Generics.SYB.WithClass.Instances
instance [overlap ok] (Data ctx ByteString, Sat (ctx ByteString), Sat (ctx ByteString)) => Data ctx ByteString
instance [overlap ok] (Data ctx (ForeignPtr Word8), Data ctx Int, Sat (ctx ByteString), Sat (ctx (ForeignPtr Word8)), Sat (ctx Int)) => Data ctx ByteString
instance [overlap ok] Typeable DataType
instance [overlap ok] (Sat (ctx (Set a)), Data ctx a, Ord a) => Data ctx (Set a)
instance [overlap ok] (Sat (ctx (Map a b)), Data ctx a, Data ctx b, Ord a) => Data ctx (Map a b)
instance [overlap ok] (Sat (ctx [b]), Sat (ctx (Array a b)), Typeable a, Data ctx b, Data ctx [b], Ix a) => Data ctx (Array a b)
instance [overlap ok] (Sat (ctx (MVar a)), Typeable a) => Data ctx (MVar a)
instance [overlap ok] (Sat (ctx (ST s a)), Typeable s, Typeable a) => Data ctx (ST s a)
instance [overlap ok] (Sat (ctx (ForeignPtr a)), Typeable a) => Data ctx (ForeignPtr a)
instance [overlap ok] (Sat (ctx (IORef a)), Typeable a) => Data ctx (IORef a)
instance [overlap ok] (Sat (ctx (StablePtr a)), Typeable a) => Data ctx (StablePtr a)
instance [overlap ok] (Sat (ctx (Ptr a)), Typeable a) => Data ctx (Ptr a)
instance [overlap ok] Sat (ctx Handle) => Data ctx Handle
instance [overlap ok] (Sat (ctx (IO a)), Typeable a) => Data ctx (IO a)
instance [overlap ok] Sat (ctx DataType) => Data ctx DataType
instance [overlap ok] Sat (ctx TyCon) => Data ctx TyCon
instance [overlap ok] Sat (ctx TypeRep) => Data ctx TypeRep
instance [overlap ok] (Sat (ctx (a, b, c, d, e, f, g)), Data ctx a, Data ctx b, Data ctx c, Data ctx d, Data ctx e, Data ctx f, Data ctx g) => Data ctx (a, b, c, d, e, f, g)
instance [overlap ok] (Sat (ctx (a, b, c, d, e, f)), Data ctx a, Data ctx b, Data ctx c, Data ctx d, Data ctx e, Data ctx f) => Data ctx (a, b, c, d, e, f)
instance [overlap ok] (Sat (ctx (a, b, c, d, e)), Data ctx a, Data ctx b, Data ctx c, Data ctx d, Data ctx e) => Data ctx (a, b, c, d, e)
instance [overlap ok] (Sat (ctx (a, b, c, d)), Data ctx a, Data ctx b, Data ctx c, Data ctx d) => Data ctx (a, b, c, d)
instance [overlap ok] (Sat (ctx (a, b, c)), Data ctx a, Data ctx b, Data ctx c) => Data ctx (a, b, c)
instance [overlap ok] (Sat (ctx (a, b)), Data ctx a, Data ctx b) => Data ctx (a, b)
instance [overlap ok] Sat (ctx ()) => Data ctx ()
instance [overlap ok] (Sat (ctx (a -> b)), Data ctx a, Data ctx b) => Data ctx (a -> b)
instance [overlap ok] (Sat (ctx (Either a b)), Data ctx a, Data ctx b) => Data ctx (Either a b)
instance [overlap ok] Sat (ctx Ordering) => Data ctx Ordering
instance [overlap ok] (Sat (ctx (Maybe a)), Data ctx a) => Data ctx (Maybe a)
instance [overlap ok] (Sat (ctx [a]), Data ctx a) => Data ctx [a]
instance [overlap ok] (Sat (ctx (Ratio a)), Data ctx a, Integral a) => Data ctx (Ratio a)
instance [overlap ok] Sat (ctx Word64) => Data ctx Word64
instance [overlap ok] Sat (ctx Word32) => Data ctx Word32
instance [overlap ok] Sat (ctx Word16) => Data ctx Word16
instance [overlap ok] Sat (ctx Word8) => Data ctx Word8
instance [overlap ok] Sat (ctx Word) => Data ctx Word
instance [overlap ok] Sat (ctx Int64) => Data ctx Int64
instance [overlap ok] Sat (ctx Int32) => Data ctx Int32
instance [overlap ok] Sat (ctx Int16) => Data ctx Int16
instance [overlap ok] Sat (ctx Int8) => Data ctx Int8
instance [overlap ok] Sat (ctx Integer) => Data ctx Integer
instance [overlap ok] Sat (ctx Int) => Data ctx Int
instance [overlap ok] Sat (ctx Double) => Data ctx Double
instance [overlap ok] Sat (ctx Float) => Data ctx Float
instance [overlap ok] Sat (ctx Char) => Data ctx Char
instance [overlap ok] Sat (ctx Bool) => Data ctx Bool
