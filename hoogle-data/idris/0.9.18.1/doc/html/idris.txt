-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional Programming Language with Dependent Types
--   
@package idris
@version 0.9.18.1

module IRTS.JavaScript.AST
data JSType
JSIntTy :: JSType
JSStringTy :: JSType
JSIntegerTy :: JSType
JSFloatTy :: JSType
JSCharTy :: JSType
JSPtrTy :: JSType
JSForgotTy :: JSType
data JSInteger
JSBigZero :: JSInteger
JSBigOne :: JSInteger
JSBigInt :: Integer -> JSInteger
JSBigIntExpr :: JS -> JSInteger
data JSNum
JSInt :: Int -> JSNum
JSFloat :: Double -> JSNum
JSInteger :: JSInteger -> JSNum
data JSWord
JSWord8 :: Word8 -> JSWord
JSWord16 :: Word16 -> JSWord
JSWord32 :: Word32 -> JSWord
JSWord64 :: Word64 -> JSWord
data JSAnnotation
JSConstructor :: JSAnnotation
data JS
JSRaw :: String -> JS
JSIdent :: String -> JS
JSFunction :: [String] -> JS -> JS
JSType :: JSType -> JS
JSSeq :: [JS] -> JS
JSReturn :: JS -> JS
JSApp :: JS -> [JS] -> JS
JSNew :: String -> [JS] -> JS
JSError :: String -> JS
JSBinOp :: String -> JS -> JS -> JS
JSPreOp :: String -> JS -> JS
JSPostOp :: String -> JS -> JS
JSProj :: JS -> String -> JS
JSNull :: JS
JSUndefined :: JS
JSThis :: JS
JSTrue :: JS
JSFalse :: JS
JSArray :: [JS] -> JS
JSString :: String -> JS
JSNum :: JSNum -> JS
JSWord :: JSWord -> JS
JSAssign :: JS -> JS -> JS
JSAlloc :: String -> (Maybe JS) -> JS
JSIndex :: JS -> JS -> JS
JSSwitch :: JS -> [(JS, JS)] -> (Maybe JS) -> JS
JSCond :: [(JS, JS)] -> JS
JSTernary :: JS -> JS -> JS -> JS
JSParens :: JS -> JS
JSWhile :: JS -> JS -> JS
JSFFI :: String -> [JS] -> JS
JSAnnotation :: JSAnnotation -> JS -> JS
JSNoop :: JS
data FFI
FFICode :: Char -> FFI
FFIArg :: Int -> FFI
FFIError :: String -> FFI
ffi :: String -> [String] -> Text
compileJS :: JS -> Text
compileJS' :: Int -> JS -> Text
jsInstanceOf :: JS -> String -> JS
jsOr :: JS -> JS -> JS
jsAnd :: JS -> JS -> JS
jsMeth :: JS -> String -> [JS] -> JS
jsCall :: String -> [JS] -> JS
jsTypeOf :: JS -> JS
jsEq :: JS -> JS -> JS
jsNotEq :: JS -> JS -> JS
jsIsNumber :: JS -> JS
jsIsNull :: JS -> JS
jsBigInt :: JS -> JS
jsUnPackBits :: JS -> JS
jsPackUBits8 :: JS -> JS
jsPackUBits16 :: JS -> JS
jsPackUBits32 :: JS -> JS
jsPackSBits8 :: JS -> JS
jsPackSBits16 :: JS -> JS
jsPackSBits32 :: JS -> JS
instance Eq JSType
instance Eq JSWord
instance Eq JSAnnotation
instance Eq JS
instance Eq JSNum
instance Eq JSInteger
instance Show JSAnnotation

module Idris.Help
data CmdArg

-- | The command takes an expression
ExprArg :: CmdArg

-- | The command takes a name
NameArg :: CmdArg

-- | The command takes a file
FileArg :: CmdArg

-- | The command takes a module name
ModuleArg :: CmdArg

-- | The command takes a list of package names
PkgArgs :: CmdArg

-- | The command takes a number
NumberArg :: CmdArg

-- | The command takes a namespace name
NamespaceArg :: CmdArg

-- | The command takes an option
OptionArg :: CmdArg

-- | The command takes a metavariable
MetaVarArg :: CmdArg

-- | The command is the colour-setting command
ColourArg :: CmdArg

-- | No completion (yet!?)
NoArg :: CmdArg

-- | do not use
SpecialHeaderArg :: CmdArg

-- | The width of the console
ConsoleWidthArg :: CmdArg

-- | An Idris declaration, as might be contained in a file
DeclArg :: CmdArg

-- | Zero or more of one kind of argument
ManyArgs :: CmdArg -> CmdArg

-- | Zero or one of one kind of argument
OptionalArg :: CmdArg -> CmdArg

-- | One kind of argument followed by another
SeqArgs :: CmdArg -> CmdArg -> CmdArg

-- | Use these for completion, but don't show them in :help
extraHelp :: [([String], CmdArg, String)]
instance Show CmdArg

module Util.ScreenSize
getScreenWidth :: IO Int

module Idris.Colours
data IdrisColour
IdrisColour :: Maybe Color -> Bool -> Bool -> Bool -> Bool -> IdrisColour
colour :: IdrisColour -> Maybe Color
vivid :: IdrisColour -> Bool
underline :: IdrisColour -> Bool
bold :: IdrisColour -> Bool
italic :: IdrisColour -> Bool
data ColourTheme
ColourTheme :: IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> ColourTheme
keywordColour :: ColourTheme -> IdrisColour
boundVarColour :: ColourTheme -> IdrisColour
implicitColour :: ColourTheme -> IdrisColour
functionColour :: ColourTheme -> IdrisColour
typeColour :: ColourTheme -> IdrisColour
dataColour :: ColourTheme -> IdrisColour
promptColour :: ColourTheme -> IdrisColour
postulateColour :: ColourTheme -> IdrisColour

-- | Idris's default console colour theme
defaultTheme :: ColourTheme
colouriseKwd :: ColourTheme -> String -> String
colouriseBound :: ColourTheme -> String -> String
colouriseImplicit :: ColourTheme -> String -> String
colourisePostulate :: ColourTheme -> String -> String
colouriseType :: ColourTheme -> String -> String
colouriseFun :: ColourTheme -> String -> String
colouriseData :: ColourTheme -> String -> String
colouriseKeyword :: ColourTheme -> String -> String
colourisePrompt :: ColourTheme -> String -> String

-- | Set the colour of a string using POSIX escape codes
colourise :: IdrisColour -> String -> String
data ColourType
KeywordColour :: ColourType
BoundVarColour :: ColourType
ImplicitColour :: ColourType
FunctionColour :: ColourType
TypeColour :: ColourType
DataColour :: ColourType
PromptColour :: ColourType
PostulateColour :: ColourType
instance Eq IdrisColour
instance Show IdrisColour
instance Eq ColourTheme
instance Show ColourTheme
instance Eq ColourType
instance Show ColourType
instance Bounded ColourType
instance Enum ColourType

module Util.System
tempfile :: IO (FilePath, Handle)
withTempdir :: String -> (FilePath -> IO a) -> IO a
rmFile :: FilePath -> IO ()
catchIO :: IO a -> (IOError -> IO a) -> IO a
isWindows :: Bool

-- | Write a source file, same as writeFile except the encoding is set to
--   utf-8
writeSource :: FilePath -> String -> IO ()

-- | Read a source file, same as readFile but make sure the encoding is
--   utf-8.
readSource :: FilePath -> IO String
setupBundledCC :: IO ()

module IRTS.System
getDataFileName :: FilePath -> IO FilePath
getDataDir :: IO FilePath
getTargetDir :: IO String
getCC :: IO String
getLibFlags :: IO [[Char]]
getIdrisLibDir :: IO FilePath
getIncFlags :: IO [[Char]]
getEnvFlags :: IO [String]
getMvn :: IO String
getExecutablePom :: IO FilePath
version :: Version


-- | Platform-specific dynamic linking support. Add new platforms to this
--   file through conditional compilation.
module Util.DynamicLinker
data ForeignFun
Fun :: String -> () -> ForeignFun
fun_name :: ForeignFun -> String
fun_handle :: ForeignFun -> ()
data DynamicLib
Lib :: String -> () -> DynamicLib
lib_name :: DynamicLib -> String
lib_handle :: DynamicLib -> ()
tryLoadLib :: [FilePath] -> String -> IO (Maybe DynamicLib)
tryLoadFn :: String -> DynamicLib -> IO (Maybe ForeignFun)
instance Eq DynamicLib


-- | TT is the core language of Idris. The language has:
--   
--   <ul>
--   <li>Full dependent types</li>
--   <li>A hierarchy of universes, with cumulativity: Type : Type1, Type1 :
--   Type2, ...</li>
--   <li>Pattern matching letrec binding</li>
--   <li>(primitive types defined externally)</li>
--   </ul>
--   
--   Some technical stuff:
--   
--   <ul>
--   <li>Typechecker is kept as simple as possible - no unification, just a
--   checker for incomplete terms.</li>
--   <li>We have a simple collection of tactics which we use to elaborate
--   source programs with implicit syntax into fully explicit terms.</li>
--   </ul>
module Idris.Core.TT
data Option
TTypeInTType :: Option
CheckConv :: Option

-- | Source location. These are typically produced by the parser
--   <a>getFC</a>
data FC
FC :: String -> (Int, Int) -> (Int, Int) -> FC

-- | Filename
_fc_fname :: FC -> String

-- | Line and column numbers for the start of the location span
_fc_start :: FC -> (Int, Int)

-- | Line and column numbers for the end of the location span
_fc_end :: FC -> (Int, Int)

-- | Locations for machine-generated terms
NoFC :: FC

-- | Locations with file only
FileFC :: String -> FC

-- | Filename
_fc_fname :: FC -> String

-- | Give a notion of filename associated with an FC
fc_fname :: FC -> String

-- | Give a notion of start location associated with an FC
fc_start :: FC -> (Int, Int)

-- | Give a notion of end location associated with an FC
fc_end :: FC -> (Int, Int)

-- | Get the largest span containing the two FCs
spanFC :: FC -> FC -> FC

-- | Ignore source location equality (so deriving classes do not compare
--   FCs)

-- | FC with equality
newtype FC'
FC' :: FC -> FC'
unwrapFC :: FC' -> FC

-- | Empty source location
emptyFC :: FC

-- | Source location with file only
fileFC :: String -> FC

-- | Output annotation for pretty-printed name - decides colour
data NameOutput
TypeOutput :: NameOutput
FunOutput :: NameOutput
DataOutput :: NameOutput
MetavarOutput :: NameOutput
PostulateOutput :: NameOutput

-- | Text formatting output
data TextFormatting
BoldText :: TextFormatting
ItalicText :: TextFormatting
UnderlineText :: TextFormatting

-- | Output annotations for pretty-printing
data OutputAnnotation

-- | ^ The name, classification, docs overview, and pretty-printed type
AnnName :: Name -> (Maybe NameOutput) -> (Maybe String) -> (Maybe String) -> OutputAnnotation

-- | ^ The name and whether it is implicit
AnnBoundName :: Name -> Bool -> OutputAnnotation
AnnConst :: Const -> OutputAnnotation

-- | type, doc overview
AnnData :: String -> String -> OutputAnnotation

-- | name, doc overview
AnnType :: String -> String -> OutputAnnotation
AnnKeyword :: OutputAnnotation
AnnFC :: FC -> OutputAnnotation
AnnTextFmt :: TextFormatting -> OutputAnnotation

-- | pprint bound vars, original term
AnnTerm :: [(Name, Bool)] -> (TT Name) -> OutputAnnotation

-- | more general, isomorphic, or more specific
AnnSearchResult :: Ordering -> OutputAnnotation
AnnErr :: Err -> OutputAnnotation

-- | A namespace (e.g. on an import line or in a namespace declaration).
--   Stored starting at the root, with the hierarchy fully resolved. If a
--   file path is present, then the namespace represents a module imported
--   from that file.
AnnNamespace :: [Text] -> (Maybe FilePath) -> OutputAnnotation

-- | Used for error reflection
data ErrorReportPart
TextPart :: String -> ErrorReportPart
NamePart :: Name -> ErrorReportPart
TermPart :: Term -> ErrorReportPart
SubReport :: [ErrorReportPart] -> ErrorReportPart
data Provenance
ExpectedType :: Provenance
TooManyArgs :: Term -> Provenance
InferredVal :: Provenance
GivenVal :: Provenance
SourceTerm :: Term -> Provenance

-- | Idris errors. Used as exceptions in the compiler, but reported to
--   users if they reach the top level.
data Err' t
Msg :: String -> Err' t
InternalMsg :: String -> Err' t
CantUnify :: Bool -> (t, Maybe Provenance) -> (t, Maybe Provenance) -> (Err' t) -> [(Name, t)] -> Int -> Err' t
InfiniteUnify :: Name -> t -> [(Name, t)] -> Err' t
CantConvert :: t -> t -> [(Name, t)] -> Err' t
CantSolveGoal :: t -> [(Name, t)] -> Err' t
UnifyScope :: Name -> Name -> t -> [(Name, t)] -> Err' t
CantInferType :: String -> Err' t
NonFunctionType :: t -> t -> Err' t
NotEquality :: t -> t -> Err' t
TooManyArguments :: Name -> Err' t
CantIntroduce :: t -> Err' t
NoSuchVariable :: Name -> Err' t
WithFnType :: t -> Err' t
NoTypeDecl :: Name -> Err' t
NotInjective :: t -> t -> t -> Err' t
CantResolve :: Bool -> t -> Err' t
InvalidTCArg :: Name -> t -> Err' t
CantResolveAlts :: [Name] -> Err' t
IncompleteTerm :: t -> Err' t
NoEliminator :: String -> t -> Err' t

-- | Location, bad universe, old domain, new domain, suspects
UniverseError :: FC -> UExp -> (Int, Int) -> (Int, Int) -> [ConstraintFC] -> Err' t
UniqueError :: Universe -> Name -> Err' t
UniqueKindError :: Universe -> Name -> Err' t
ProgramLineComment :: Err' t
Inaccessible :: Name -> Err' t
UnknownImplicit :: Name -> Name -> Err' t
CantMatch :: t -> Err' t
NonCollapsiblePostulate :: Name -> Err' t
AlreadyDefined :: Name -> Err' t
ProofSearchFail :: (Err' t) -> Err' t
NoRewriting :: t -> Err' t
At :: FC -> (Err' t) -> Err' t
Elaborating :: String -> Name -> (Err' t) -> Err' t
ElaboratingArg :: Name -> Name -> [(Name, Name)] -> (Err' t) -> Err' t
ProviderError :: String -> Err' t
LoadingFailed :: String -> (Err' t) -> Err' t
ReflectionError :: [[ErrorReportPart]] -> (Err' t) -> Err' t
ReflectionFailed :: String -> (Err' t) -> Err' t

-- | User-specified message, proof term, goals with context (first goal is
--   focused)
ElabScriptDebug :: (Maybe String) -> t -> [(Name, t, [(Name, Binder t)])] -> Err' t
ElabScriptStuck :: t -> Err' t
type Err = Err' Term
data TC a
OK :: !a -> TC a
Error :: Err -> TC a
bindTC :: TC a -> (a -> TC b) -> TC b
score :: Err -> Int
tfail :: Err -> TC a
failMsg :: String -> TC a
trun :: FC -> TC a -> TC a
discard :: Monad m => m a -> m ()
showSep :: String -> [String] -> String
pmap :: (t -> t1) -> (t, t) -> (t1, t1)
traceWhen :: Bool -> String -> a -> a

-- | Names are hierarchies of strings, describing scope (so no danger of
--   duplicate names, but need to be careful on lookup).
data Name

-- | User-provided name
UN :: Text -> Name

-- | Root, namespaces
NS :: Name -> [Text] -> Name

-- | Machine chosen names
MN :: Int -> Text -> Name

-- | Name of something which is never used in scope
NErased :: Name

-- | Decorated function names
SN :: SpecialName -> Name

-- | Reference to IBC file symbol table (used during serialisation)
SymRef :: Int -> Name
txt :: String -> Text
str :: Text -> String
tnull :: Text -> Bool
thead :: Text -> Char
sUN :: String -> Name
sNS :: Name -> [String] -> Name
sMN :: Int -> String -> Name
data SpecialName
WhereN :: Int -> Name -> Name -> SpecialName
WithN :: Int -> Name -> SpecialName
InstanceN :: Name -> [Text] -> SpecialName
ParentN :: Name -> Text -> SpecialName
MethodN :: Name -> SpecialName
CaseN :: Name -> SpecialName
ElimN :: Name -> SpecialName
InstanceCtorN :: Name -> SpecialName
MetaN :: Name -> Name -> SpecialName
sInstanceN :: Name -> [String] -> SpecialName
sParentN :: Name -> String -> SpecialName
showCG :: Name -> String

-- | Contexts allow us to map names to things. A root name maps to a
--   collection of things in different namespaces with that name.
type Ctxt a = Map Name (Map Name a)
emptyContext :: Map k a
mapCtxt :: (a -> b) -> Ctxt a -> Ctxt b

-- | Return True if the argument <a>Name</a> should be interpreted as the
--   name of a typeclass.
tcname :: Name -> Bool
implicitable :: Name -> Bool
nsroot :: Name -> Name
addDef :: Name -> a -> Ctxt a -> Ctxt a

-- | Look up a name in the context, given an optional namespace. The name
--   (n) may itself have a (partial) namespace given.
--   
--   Rules for resolution:
--   
--   <ul>
--   <li>if an explicit namespace is given, return the names which match
--   it. If none match, return all names.<ul><li>if the name has has
--   explicit namespace given, return the names which match it and ignore
--   the given namespace.</li><li>otherwise, return all
--   names.</li></ul></li>
--   </ul>
lookupCtxtName :: Name -> Ctxt a -> [(Name, a)]
lookupCtxt :: Name -> Ctxt a -> [a]
lookupCtxtExact :: Name -> Ctxt a -> Maybe a
deleteDefExact :: Name -> Ctxt a -> Ctxt a
updateDef :: Name -> (a -> a) -> Ctxt a -> Ctxt a
toAlist :: Ctxt a -> [(Name, a)]
addAlist :: [(Name, a)] -> Ctxt a -> Ctxt a
data NativeTy
IT8 :: NativeTy
IT16 :: NativeTy
IT32 :: NativeTy
IT64 :: NativeTy
data IntTy
ITFixed :: NativeTy -> IntTy
ITNative :: IntTy
ITBig :: IntTy
ITChar :: IntTy
intTyName :: IntTy -> String
data ArithTy
ATInt :: IntTy -> ArithTy
ATFloat :: ArithTy
nativeTyWidth :: NativeTy -> Int

-- | <i>Deprecated: Non-total function, use nativeTyWidth and appropriate
--   casing</i>
intTyWidth :: IntTy -> Int
data Const
I :: Int -> Const
BI :: Integer -> Const
Fl :: Double -> Const
Ch :: Char -> Const
Str :: String -> Const
B8 :: Word8 -> Const
B16 :: Word16 -> Const
B32 :: Word32 -> Const
B64 :: Word64 -> Const
AType :: ArithTy -> Const
StrType :: Const
WorldType :: Const
TheWorld :: Const
VoidType :: Const
Forgot :: Const
isTypeConst :: Const -> Bool

-- | Determines whether the input constant represents a type
constIsType :: Const -> Bool

-- | Get the docstring for a Const
constDocs :: Const -> String
data Universe
NullType :: Universe
UniqueType :: Universe
AllTypes :: Universe
data Raw
Var :: Name -> Raw
RBind :: Name -> (Binder Raw) -> Raw -> Raw
RApp :: Raw -> Raw -> Raw
RType :: Raw
RUType :: Universe -> Raw
RForce :: Raw -> Raw
RConstant :: Const -> Raw
data ImplicitInfo
Impl :: Bool -> ImplicitInfo
tcinstance :: ImplicitInfo -> Bool

-- | All binding forms are represented in a uniform fashion. This type only
--   represents the types of bindings (and their values, if any); the
--   attached identifiers are part of the <a>Bind</a> constructor for the
--   <a>TT</a> type.
data Binder b
Lam :: !b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b

-- | A binding that occurs in a function type expression, e.g. <tt>(x:Int)
--   -&gt; ...</tt> The <a>binderImpl</a> flag says whether it was a scoped
--   implicit (i.e. forall bound) in the high level Idris, but otherwise
--   has no relevance in TT.
Pi :: Maybe ImplicitInfo -> !b -> !b -> Binder b
binderImpl :: Binder b -> Maybe ImplicitInfo

-- | type annotation for bound variable
binderTy :: Binder b -> !b
binderKind :: Binder b -> !b

-- | A binding that occurs in a <tt>let</tt> expression
Let :: !b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b

-- | value for bound variable
binderVal :: Binder b -> b
NLet :: !b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b

-- | value for bound variable
binderVal :: Binder b -> b
Hole :: !b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b
GHole :: Int -> !b -> Binder b
envlen :: Binder b -> Int

-- | type annotation for bound variable
binderTy :: Binder b -> !b
Guess :: !b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b

-- | value for bound variable
binderVal :: Binder b -> b

-- | A pattern variable
PVar :: !b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b
PVTy :: !b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> !b
fmapMB :: Monad m => (a -> m b) -> Binder a -> m (Binder b)
raw_apply :: Raw -> [Raw] -> Raw
raw_unapply :: Raw -> (Raw, [Raw])

-- | Universe expressions for universe checking
data UExp

-- | universe variable
UVar :: Int -> UExp

-- | explicit universe level
UVal :: Int -> UExp

-- | Universe constraints
data UConstraint

-- | Strictly less than
ULT :: UExp -> UExp -> UConstraint

-- | Less than or equal to
ULE :: UExp -> UExp -> UConstraint
data ConstraintFC
ConstraintFC :: UConstraint -> FC -> ConstraintFC
uconstraint :: ConstraintFC -> UConstraint
ufc :: ConstraintFC -> FC
type UCs = (Int, [UConstraint])
data NameType
Bound :: NameType
Ref :: NameType

-- | Data constructor
DCon :: Int -> Int -> Bool -> NameType
nt_tag :: NameType -> Int
nt_arity :: NameType -> Int
nt_unique :: NameType -> Bool

-- | Type constructor
TCon :: Int -> Int -> NameType
nt_tag :: NameType -> Int
nt_arity :: NameType -> Int
data AppStatus n
Complete :: AppStatus n
MaybeHoles :: AppStatus n
Holes :: [n] -> AppStatus n

-- | Terms in the core language. The type parameter is the type of
--   identifiers used for bindings and explicit named references; usually
--   we use <tt>TT <a>Name</a></tt>.
data TT n

-- | named references with type (P for <a>Parameter</a>, motivated by
--   McKinna and Pollack's Pure Type Systems Formalized)
P :: NameType -> n -> (TT n) -> TT n

-- | a resolved de Bruijn-indexed variable
V :: !Int -> TT n

-- | a binding
Bind :: n -> !(Binder (TT n)) -> (TT n) -> TT n

-- | function, function type, arg
App :: (AppStatus n) -> !(TT n) -> (TT n) -> TT n

-- | constant
Constant :: Const -> TT n

-- | argument projection; runtime only (-1) is a special case for 'subtract
--   one from BI'
Proj :: (TT n) -> !Int -> TT n

-- | an erased term
Erased :: TT n

-- | special case for totality checking
Impossible :: TT n

-- | the type of types at some level
TType :: UExp -> TT n

-- | Uniqueness type universe (disjoint from TType)
UType :: Universe -> TT n
class TermSize a
termsize :: TermSize a => Name -> a -> Int
type EnvTT n = [(n, Binder (TT n))]
data Datatype n
Data :: n -> Int -> (TT n) -> Bool -> [(n, TT n)] -> Datatype n
d_typename :: Datatype n -> n
d_typetag :: Datatype n -> Int
d_type :: Datatype n -> (TT n)
d_unique :: Datatype n -> Bool
d_cons :: Datatype n -> [(n, TT n)]

-- | Data declaration options
data DataOpt

-- | Set if the the data-type is coinductive
Codata :: DataOpt

-- | Set if an eliminator should be generated for data type
DefaultEliminator :: DataOpt

-- | Set if a case function should be generated for data type
DefaultCaseFun :: DataOpt
DataErrRev :: DataOpt
type DataOpts = [DataOpt]
data TypeInfo
TI :: [Name] -> Bool -> DataOpts -> [Int] -> [Name] -> TypeInfo
con_names :: TypeInfo -> [Name]
codata :: TypeInfo -> Bool
data_opts :: TypeInfo -> DataOpts
param_pos :: TypeInfo -> [Int]
mutual_types :: TypeInfo -> [Name]

-- | A term is injective iff it is a data constructor, type constructor,
--   constant, the type Type, pi-binding, or an application of an injective
--   term.
isInjective :: TT n -> Bool

-- | Count the number of instances of a de Bruijn index in a term
vinstances :: Int -> TT n -> Int

-- | Replace the outermost (index 0) de Bruijn variable with the given term
instantiate :: TT n -> TT n -> TT n

-- | As <a>instantiate</a>, but also decrement the indices of all de Bruijn
--   variables remaining in the term, so that there are no more references
--   to the variable that has been substituted.
substV :: TT n -> TT n -> TT n

-- | Replace all non-free de Bruijn references in the given term with
--   references to the name of their binding.
explicitNames :: TT n -> TT n

-- | Replace references to the given <a>Name</a>-like id with references to
--   de Bruijn index 0.
pToV :: Eq n => n -> TT n -> TT n
pToV' :: Eq n => n -> Int -> TT n -> TT n
addBinder :: TT n -> TT n

-- | Convert several names. First in the list comes out as V 0
pToVs :: Eq n => [n] -> TT n -> TT n

-- | Replace de Bruijn indices in the given term with explicit references
--   to the names of the bindings they refer to. It is an error if the
--   given term contains free de Bruijn indices.
vToP :: TT n -> TT n

-- | Replace every non-free reference to the name of a binding in the given
--   term with a de Bruijn index.
finalise :: Eq n => TT n -> TT n
pEraseType :: TT n -> TT n

-- | As <a>instantiate</a>, but in addition to replacing <tt><a>V</a>
--   0</tt>, replace references to the given <a>Name</a>-like id.
subst :: Eq n => n -> TT n -> TT n -> TT n
psubst :: Eq n => n -> TT n -> TT n -> TT n

-- | As <a>subst</a>, but takes a list of (name, substitution) pairs
--   instead of a single name and substitution
substNames :: Eq n => [(n, TT n)] -> TT n -> TT n

-- | Replaces all terms equal (in the sense of <tt>(==)</tt>) to the old
--   term with the new term.
substTerm :: Eq n => TT n -> TT n -> TT n -> TT n

-- | Return number of occurrences of V 0 or bound name i the term
occurrences :: Eq n => n -> TT n -> Int

-- | Returns true if V 0 and bound name n do not occur in the term
noOccurrence :: Eq n => n -> TT n -> Bool

-- | Returns all names used free in the term
freeNames :: Eq n => TT n -> [n]

-- | Return the arity of a (normalised) type
arity :: TT n -> Int

-- | Deconstruct an application; returns the function and a list of
--   arguments
unApply :: TT n -> (TT n, [TT n])

-- | Returns a term representing the application of the first argument (a
--   function) to every element of the second argument.
mkApp :: TT n -> [TT n] -> TT n
unList :: Term -> Maybe [Term]

-- | Cast a <a>TT</a> term to a <a>Raw</a> value, discarding universe
--   information and the types of named references and replacing all de
--   Bruijn indices with the corresponding name. It is an error if there
--   are free de Bruijn indices.
forget :: TT Name -> Raw
safeForget :: TT Name -> Maybe Raw
forgetEnv :: [Name] -> TT Name -> Raw
safeForgetEnv :: [Name] -> TT Name -> Maybe Raw

-- | Introduce a <a>Bind</a> into the given term for each element of the
--   given list of (name, binder) pairs.
bindAll :: [(n, Binder (TT n))] -> TT n -> TT n

-- | Like <a>bindAll</a>, but the <a>Binder</a>s are <a>TT</a> terms
--   instead. The first argument is a function to map <tt>TT</tt> terms to
--   <tt>Binder</tt>s. This function might often be something like
--   <a>Lam</a>, which directly constructs a <tt>Binder</tt> from a
--   <tt>TT</tt> term.
bindTyArgs :: (TT n -> Binder (TT n)) -> [(n, TT n)] -> TT n -> TT n

-- | Return a list of pairs of the names of the outermost <a>Pi</a>-bound
--   variables in the given term, together with their types.
getArgTys :: TT n -> [(n, TT n)]
getRetTy :: TT n -> TT n
uniqueNameFrom :: [Name] -> [Name] -> Name
uniqueName :: Name -> [Name] -> Name
uniqueNameSet :: Name -> Set Name -> Name
uniqueBinders :: [Name] -> TT Name -> TT Name
nextName :: Name -> Name
type Term = TT Name
type Type = Term
type Env = EnvTT Name

-- | an environment with de Bruijn indices <tt>normalised</tt> so that they
--   all refer to this environment
newtype WkEnvTT n
Wk :: (EnvTT n) -> WkEnvTT n
type WkEnv = WkEnvTT Name
itBitsName :: NativeTy -> [Char]
showEnv :: (Eq n, Show n) => EnvTT n -> TT n -> String
showEnvDbg :: (Show a, Eq a) => [(a, Binder (TT a))] -> TT a -> [Char]
prettyEnv :: Env -> Term -> Doc OutputAnnotation
showEnv' :: (Show a, Eq a) => [(a, Binder (TT a))] -> TT a -> Bool -> [Char]

-- | Check whether a term has any hole bindings in it - impure if so
pureTerm :: TT Name -> Bool

-- | Weaken a term by adding i to each de Bruijn index (i.e. lift it over i
--   bindings)
weakenTm :: Int -> TT n -> TT n

-- | Weaken an environment so that all the de Bruijn indices are correct
--   according to the latest bound variable
weakenEnv :: EnvTT n -> EnvTT n

-- | Weaken every term in the environment by the given amount
weakenTmEnv :: Int -> EnvTT n -> EnvTT n

-- | Gather up all the outer <a>PVar</a>s and <a>Hole</a>s in an expression
--   and reintroduce them in a canonical order
orderPats :: Term -> Term
refsIn :: TT Name -> [Name]
liftPats :: Term -> Term
allTTNames :: Eq n => TT n -> [n]

-- | Pretty-print a term
pprintTT :: [Name] -> TT Name -> Doc OutputAnnotation

-- | Pretty-printer helper for the binding site of a name
bindingOf :: Name -> Bool -> Doc OutputAnnotation
instance Typeable FC
instance Typeable SpecialName
instance Typeable Name
instance Typeable NativeTy
instance Typeable IntTy
instance Typeable ArithTy
instance Typeable Const
instance Typeable Universe
instance Typeable ImplicitInfo
instance Typeable Binder
instance Typeable Raw
instance Typeable UExp
instance Typeable UConstraint
instance Typeable ConstraintFC
instance Typeable NameType
instance Typeable AppStatus
instance Typeable TT
instance Typeable Provenance
instance Typeable ErrorReportPart
instance Typeable Err'
instance Eq Option
instance Data FC
instance Ord FC
instance Show NameOutput
instance Show TextFormatting
instance Eq SpecialName
instance Ord SpecialName
instance Data SpecialName
instance Eq Name
instance Ord Name
instance Data Name
instance Show NativeTy
instance Eq NativeTy
instance Ord NativeTy
instance Enum NativeTy
instance Data NativeTy
instance Show IntTy
instance Eq IntTy
instance Ord IntTy
instance Data IntTy
instance Show ArithTy
instance Eq ArithTy
instance Ord ArithTy
instance Data ArithTy
instance Eq Const
instance Ord Const
instance Data Const
instance Eq Universe
instance Ord Universe
instance Data Universe
instance Show ImplicitInfo
instance Eq ImplicitInfo
instance Ord ImplicitInfo
instance Data ImplicitInfo
instance Show b => Show (Binder b)
instance Eq b => Eq (Binder b)
instance Ord b => Ord (Binder b)
instance Functor Binder
instance Foldable Binder
instance Traversable Binder
instance Data b => Data (Binder b)
instance Show Raw
instance Eq Raw
instance Data Raw
instance Eq UExp
instance Ord UExp
instance Data UExp
instance Eq UConstraint
instance Ord UConstraint
instance Data UConstraint
instance Show ConstraintFC
instance Data ConstraintFC
instance Show NameType
instance Ord NameType
instance Data NameType
instance Eq n => Eq (AppStatus n)
instance Ord n => Ord (AppStatus n)
instance Functor AppStatus
instance Data n => Data (AppStatus n)
instance Show n => Show (AppStatus n)
instance Ord n => Ord (TT n)
instance Functor TT
instance Data n => Data (TT n)
instance (Eq n, Show n) => Show (Datatype n)
instance Functor Datatype
instance Eq n => Eq (Datatype n)
instance Show DataOpt
instance Eq DataOpt
instance Show TypeInfo
instance Show Provenance
instance Eq Provenance
instance Data Provenance
instance Show ErrorReportPart
instance Eq ErrorReportPart
instance Data ErrorReportPart
instance Eq t => Eq (Err' t)
instance Functor Err'
instance Data t => Data (Err' t)
instance Eq a => Eq (TC a)
instance Functor TC
instance Show OutputAnnotation
instance Show Const
instance (Eq n, Show n) => Show (TT n)
instance Eq n => Eq (TT n)
instance Pretty a o => Pretty (TT a) o
instance Sized a => Sized (TT a)
instance Sized Universe
instance TermSize (TT Name)
instance TermSize a => TermSize [a]
instance Eq NameType
instance Pretty NameType OutputAnnotation
instance Sized NameType
instance Show UConstraint
instance Ord ConstraintFC
instance Eq ConstraintFC
instance Show UExp
instance Sized UExp
instance Sized a => Sized (Binder a)
instance Pretty Raw OutputAnnotation
instance Sized Raw
instance Show Universe
instance Pretty Const OutputAnnotation
instance Sized Const
instance Pretty ArithTy OutputAnnotation
instance Pretty NativeTy OutputAnnotation
instance Show SpecialName
instance Show Name
instance Pretty [Name] OutputAnnotation
instance Pretty Name OutputAnnotation
instance Sized Name
instance Show a => Show (TC a)
instance Pretty a OutputAnnotation => Pretty (TC a) OutputAnnotation
instance Pretty Err OutputAnnotation
instance Show Err
instance Sized Err
instance Sized ErrorReportPart
instance Alternative TC
instance Applicative TC
instance MonadPlus TC
instance Monad TC
instance Show FC
instance Sized FC
instance Eq FC'
instance Eq FC

module Idris.Core.CaseTree
data CaseDef
CaseDef :: [Name] -> !SC -> [Term] -> CaseDef
type SC = SC' Term
data SC' t

-- | invariant: lowest tags first
Case :: CaseType -> Name -> [CaseAlt' t] -> SC' t

-- | special case for projections/thunk-forcing before inspection
ProjCase :: t -> [CaseAlt' t] -> SC' t
STerm :: !t -> SC' t

-- | error message
UnmatchedCase :: String -> SC' t

-- | already checked to be impossible
ImpossibleCase :: SC' t
type CaseAlt = CaseAlt' Term
data CaseAlt' t
ConCase :: Name -> Int -> [Name] -> !(SC' t) -> CaseAlt' t

-- | reflection function
FnCase :: Name -> [Name] -> !(SC' t) -> CaseAlt' t
ConstCase :: Const -> !(SC' t) -> CaseAlt' t
SucCase :: Name -> !(SC' t) -> CaseAlt' t
DefaultCase :: !(SC' t) -> CaseAlt' t
type ErasureInfo = Name -> [Int]
data Phase
CompileTime :: Phase
RunTime :: Phase
type CaseTree = SC
data CaseType
Updatable :: CaseType
Shared :: CaseType
simpleCase :: Bool -> SC -> Bool -> Phase -> FC -> [Int] -> [Type] -> [([Name], Term, Term)] -> ErasureInfo -> TC CaseDef
small :: Name -> [Name] -> SC -> Bool
namesUsed :: SC -> [Name]

-- | Return all called functions, and which arguments are used in each
--   argument position for the call, in order to help reduce compilation
--   time, and trace all unused arguments
findCalls :: SC -> [Name] -> [(Name, [[Name]])]
findUsedArgs :: SC -> [Name] -> [Name]
substSC :: Name -> Name -> SC -> SC
substAlt :: Name -> Name -> CaseAlt -> CaseAlt
mkForce :: Name -> Name -> SC -> SC
instance Eq CaseType
instance Ord CaseType
instance Show CaseType
instance Show t => Show (CaseAlt' t)
instance Eq t => Eq (CaseAlt' t)
instance Ord t => Ord (CaseAlt' t)
instance Functor CaseAlt'
instance Eq t => Eq (SC' t)
instance Ord t => Ord (SC' t)
instance Functor SC'
instance Show CaseDef
instance Show Phase
instance Eq Phase
instance Show Pat
instance Show Partition
instance Show ConType
instance Eq ConType
instance Show Group
instance TermSize CaseAlt
instance TermSize SC
instance Show t => Show (SC' t)


-- | Check universe constraints.
module Idris.Core.Constraints

-- | Check that a list of universe constraints can be satisfied.
ucheck :: Set ConstraintFC -> TC ()
instance Eq Var
instance Ord Var
instance Show Var
instance Eq Domain
instance Ord Domain
instance Show Domain

module Idris.Core.Evaluate
normalise :: Context -> Env -> TT Name -> TT Name
normaliseTrace :: Bool -> Context -> Env -> TT Name -> TT Name

-- | Normalise fully type checked terms (so, assume all names/let bindings
--   resolved)
normaliseC :: Context -> Env -> TT Name -> TT Name
normaliseAll :: Context -> Env -> TT Name -> TT Name

-- | Simplify for run-time (i.e. basic inlining)
rt_simplify :: Context -> Env -> TT Name -> TT Name

-- | Like normalise, but we only reduce functions that are marked as okay
--   to inline (and probably shouldn't reduce lets?) 20130908: now only
--   used to reduce for totality checking. Inlining should be done
--   elsewhere.
simplify :: Context -> Env -> TT Name -> TT Name
specialise :: Context -> Env -> [(Name, Int)] -> TT Name -> (TT Name, [(Name, Int)])

-- | Reduce a term to head normal form
hnf :: Context -> Env -> TT Name -> TT Name
convEq :: Context -> [Name] -> TT Name -> TT Name -> StateT UCs TC Bool
convEq' :: Context -> [Name] -> TT Name -> TT Name -> TC Bool

-- | A definition is either a simple function (just an expression with a
--   type), a constant, which could be a data or type constructor, an axiom
--   or as an yet undefined function, or an Operator. An Operator is a
--   function which explains how to reduce. A CaseOp is a function defined
--   by a simple case tree
data Def
Function :: !Type -> !Term -> Def
TyDecl :: NameType -> !Type -> Def
Operator :: Type -> Int -> ([Value] -> Maybe Value) -> Def
CaseOp :: CaseInfo -> !Type -> ![Type] -> ![Either Term (Term, Term)] -> ![([Name], Term, Term)] -> !CaseDefs -> Def
data CaseInfo
CaseInfo :: Bool -> Bool -> Bool -> CaseInfo
case_inlinable :: CaseInfo -> Bool
case_alwaysinline :: CaseInfo -> Bool
tc_dictionary :: CaseInfo -> Bool
data CaseDefs
CaseDefs :: !([Name], SC) -> !([Name], SC) -> !([Name], SC) -> !([Name], SC) -> CaseDefs
cases_totcheck :: CaseDefs -> !([Name], SC)
cases_compiletime :: CaseDefs -> !([Name], SC)
cases_inlined :: CaseDefs -> !([Name], SC)
cases_runtime :: CaseDefs -> !([Name], SC)
data Accessibility
Public :: Accessibility
Frozen :: Accessibility
Hidden :: Accessibility

-- | The result of totality checking
data Totality

-- | well-founded arguments
Total :: [Int] -> Totality

-- | productive
Productive :: Totality
Partial :: PReason -> Totality
Unchecked :: Totality

-- | Reasons why a function may not be total
data PReason
Other :: [Name] -> PReason
Itself :: PReason
NotCovering :: PReason
NotPositive :: PReason
UseUndef :: Name -> PReason
ExternalIO :: PReason
BelieveMe :: PReason
Mutual :: [Name] -> PReason
NotProductive :: PReason
data MetaInformation

-- | No meta-information
EmptyMI :: MetaInformation

-- | Meta information for a data declaration with position of parameters
DataMI :: [Int] -> MetaInformation

-- | Contexts used for global definitions and for proof state. They contain
--   universe constraints and existing definitions.
data Context

-- | The initial empty context
initContext :: Context

-- | Get the definitions from a context
ctxtAlist :: Context -> [(Name, Def)]
next_tvar :: Context -> Int
addToCtxt :: Name -> Term -> Type -> Context -> Context
setAccess :: Name -> Accessibility -> Context -> Context
setTotal :: Name -> Totality -> Context -> Context
setMetaInformation :: Name -> MetaInformation -> Context -> Context
addCtxtDef :: Name -> Def -> Context -> Context
addTyDecl :: Name -> NameType -> Type -> Context -> Context
addDatatype :: Datatype Name -> Context -> Context
addCasedef :: Name -> ErasureInfo -> CaseInfo -> Bool -> SC -> Bool -> Bool -> [Type] -> [Int] -> [Either Term (Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> Type -> Context -> Context
simplifyCasedef :: Name -> ErasureInfo -> Context -> Context
addOperator :: Name -> Type -> Int -> ([Value] -> Maybe Value) -> Context -> Context
lookupNames :: Name -> Context -> [Name]

-- | Get the list of pairs of fully-qualified names and their types that
--   match some name
lookupTyName :: Name -> Context -> [(Name, Type)]

-- | Get the pair of a fully-qualified name and its type, if there is a
--   unique one matching the name used as a key.
lookupTyNameExact :: Name -> Context -> Maybe (Name, Type)

-- | Get the types that match some name
lookupTy :: Name -> Context -> [Type]

-- | Get the single type that matches some name precisely
lookupTyExact :: Name -> Context -> Maybe Type
lookupP :: Name -> Context -> [Term]
lookupP_all :: Bool -> Bool -> Name -> Context -> [Term]
lookupDef :: Name -> Context -> [Def]
lookupNameDef :: Name -> Context -> [(Name, Def)]
lookupDefExact :: Name -> Context -> Maybe Def
lookupDefAcc :: Name -> Bool -> Context -> [(Def, Accessibility)]
lookupDefAccExact :: Name -> Bool -> Context -> Maybe (Def, Accessibility)
lookupVal :: Name -> Context -> [Value]
mapDefCtxt :: (Def -> Def) -> Context -> Context
lookupTotal :: Name -> Context -> [Totality]
lookupNameTotal :: Name -> Context -> [(Name, Totality)]
lookupMetaInformation :: Name -> Context -> [MetaInformation]
lookupTyEnv :: Name -> Env -> Maybe (Int, Type)
isTCDict :: Name -> Context -> Bool

-- | Check whether a resolved name is certainly a data constructor
isDConName :: Name -> Context -> Bool

-- | Check whether any overloading of a name is a data constructor
canBeDConName :: Name -> Context -> Bool
isTConName :: Name -> Context -> Bool
isConName :: Name -> Context -> Bool
isFnName :: Name -> Context -> Bool

-- | A HOAS representation of values
data Value
VP :: NameType -> Name -> Value -> Value
VV :: Int -> Value
VBind :: Bool -> Name -> (Binder Value) -> (Value -> Eval Value) -> Value
VBLet :: Int -> Name -> Value -> Value -> Value -> Value
VApp :: Value -> Value -> Value
VType :: UExp -> Value
VUType :: Universe -> Value
VErased :: Value
VImpossible :: Value
VConstant :: Const -> Value
VProj :: Value -> Int -> Value
VTmp :: Int -> Value
class Quote a
quote :: Quote a => Int -> a -> Eval (TT Name)
initEval :: EvalState

-- | Create a unique name given context and other existing names
uniqueNameCtxt :: Context -> Name -> [Name] -> Name
uniqueBindersCtxt :: Context -> [Name] -> TT Name -> TT Name
definitions :: Context -> Ctxt (Def, Accessibility, Totality, MetaInformation)
isUniverse :: Term -> Bool
instance Show EvalState
instance Show EvalOpt
instance Eq EvalOpt
instance Show Accessibility
instance Eq Accessibility
instance Show PReason
instance Eq PReason
instance Eq Totality
instance Eq MetaInformation
instance Show MetaInformation
instance Show Context
instance Show Totality
instance Show Def
instance Quote Value
instance Eq Value
instance Show (a -> b)
instance Show Value

module Idris.Core.DeepSeq
instance NFData t => NFData (CaseAlt' t)
instance NFData t => NFData (SC' t)
instance NFData CaseDefs
instance NFData CaseInfo
instance NFData Def
instance NFData MetaInformation
instance NFData PReason
instance NFData Totality
instance NFData Accessibility
instance NFData n => NFData (TT n)
instance NFData Const
instance NFData ArithTy
instance NFData IntTy
instance NFData NativeTy
instance NFData NameType
instance NFData UExp
instance NFData b => NFData (Binder b)
instance NFData ImplicitInfo
instance NFData Err
instance NFData ConstraintFC
instance NFData UConstraint
instance NFData Provenance
instance NFData FC
instance NFData Raw
instance NFData Universe
instance NFData SpecialName
instance NFData Name

module Idris.Core.Typecheck
convertsC :: Context -> Env -> Term -> Term -> StateT UCs TC ()
converts :: Context -> Env -> Term -> Term -> TC ()
isHole :: (t, Binder t1) -> Bool
errEnv :: [(t, Binder t1)] -> [(t, t1)]
isType :: Context -> Env -> Term -> TC ()
recheck :: Context -> Env -> Raw -> Term -> TC (Term, Type, UCs)
recheck_borrowing :: Bool -> [Name] -> Context -> Env -> Raw -> Term -> TC (Term, Type, UCs)
check :: Context -> Env -> Raw -> TC (Term, Type)
check' :: Bool -> Context -> Env -> Raw -> StateT UCs TC (Term, Type)
data UniqueUse
Never :: UniqueUse
Once :: UniqueUse
LendOnly :: UniqueUse
Many :: UniqueUse
checkUnique :: [Name] -> Context -> Env -> Term -> TC ()
instance Eq UniqueUse


-- | Implements a proof state, some primitive tactics for manipulating
--   proofs, and some high level commands for introducing new theorems,
--   evaluation/checking inside the proof system, etc.
module Idris.Core.ProofTerm
data ProofTerm
data Goal
GD :: Env -> Binder Term -> Goal
premises :: Goal -> Env
goalType :: Goal -> Binder Term
mkProofTerm :: Term -> ProofTerm
getProofTerm :: ProofTerm -> Term
updateSolved :: [(Name, Term)] -> ProofTerm -> ProofTerm

-- | Given a list of solved holes, fill out the solutions in a term
updateSolvedTerm :: [(Name, Term)] -> Term -> Term

-- | Given a list of solved holes, fill out the solutions in a term. Return
--   whether updates were performed, to facilitate sharing when there are
--   no updates.
updateSolvedTerm' :: [(Name, Term)] -> Term -> (Term, Bool)
bound_in :: ProofTerm -> [Name]
bound_in_term :: Term -> [Name]

-- | Refocus the proof term zipper on a particular hole, if it exists. If
--   not, return the original proof term.
refocus :: Hole -> ProofTerm -> ProofTerm

-- | As <a>subst</a>, in TT, but takes advantage of knowing not to
--   substitute under Complete applications.
updsubst :: Eq n => n -> TT n -> TT n -> TT n
type Hole = Maybe Name
type RunTactic' a = Context -> Env -> Term -> StateT a TC Term
goal :: Hole -> ProofTerm -> TC Goal
atHole :: Hole -> RunTactic' a -> Context -> Env -> ProofTerm -> StateT a TC (ProofTerm, Bool)
instance Show BinderPath
instance Show TermPath
instance Show ProofTerm

module Idris.Core.Unify
match_unify :: Context -> Env -> (TT Name, Maybe Provenance) -> (TT Name, Maybe Provenance) -> [Name] -> [Name] -> [FailContext] -> TC [(Name, TT Name)]
unify :: Context -> Env -> (TT Name, Maybe Provenance) -> (TT Name, Maybe Provenance) -> [Name] -> [Name] -> [Name] -> [FailContext] -> TC ([(Name, TT Name)], Fails)
type Fails = [(TT Name, TT Name, Bool, Env, Err, [FailContext], FailAt)]
data FailContext
FailContext :: FC -> Name -> Name -> FailContext
fail_sourceloc :: FailContext -> FC
fail_fn :: FailContext -> Name
fail_param :: FailContext -> Name
data FailAt
Match :: FailAt
Unify :: FailAt
unrecoverable :: Fails -> Bool
instance Show FailAt
instance Eq FailAt
instance Eq FailContext
instance Show FailContext
instance Show UInfo

module Idris.Core.ProofState
data ProofState
PS :: Name -> [Name] -> [Name] -> Int -> ProofTerm -> Type -> [Name] -> (Name, [(Name, Term)]) -> [(Name, Term)] -> [(Name, [Name])] -> Maybe (Name, Term) -> Fails -> [Name] -> [Name] -> [Name] -> [(Name, [Name])] -> Maybe ProofState -> Context -> Ctxt TypeInfo -> String -> Bool -> Bool -> [Name] -> [FailContext] -> ProofState
thname :: ProofState -> Name

-- | holes still to be solved
holes :: ProofState -> [Name]

-- | used names, don't use again
usedns :: ProofState -> [Name]

-- | name supply
nextname :: ProofState -> Int

-- | current proof term
pterm :: ProofState -> ProofTerm

-- | original goal
ptype :: ProofState -> Type

-- | explicitly given by programmer, leave it
dontunify :: ProofState -> [Name]
unified :: ProofState -> (Name, [(Name, Term)])
notunified :: ProofState -> [(Name, Term)]

-- | dot pattern holes + environment either hole or something in env must
--   turn up in the <a>notunified</a> list during elaboration
dotted :: ProofState -> [(Name, [Name])]
solved :: ProofState -> Maybe (Name, Term)
problems :: ProofState -> Fails
injective :: ProofState -> [Name]

-- | names we'll need to define
deferred :: ProofState -> [Name]

-- | instance arguments (for type classes)
instances :: ProofState -> [Name]

-- | unsolved <tt>auto</tt> implicits with their holes
autos :: ProofState -> [(Name, [Name])]

-- | for undo
previous :: ProofState -> Maybe ProofState
context :: ProofState -> Context
datatypes :: ProofState -> Ctxt TypeInfo
plog :: ProofState -> String
unifylog :: ProofState -> Bool
done :: ProofState -> Bool
recents :: ProofState -> [Name]
while_elaborating :: ProofState -> [FailContext]
newProof :: Name -> Context -> Ctxt TypeInfo -> Type -> ProofState
envAtFocus :: ProofState -> TC Env
goalAtFocus :: ProofState -> TC (Binder Type)
data Tactic
Attack :: Tactic
Claim :: Name -> Raw -> Tactic
ClaimFn :: Name -> Name -> Raw -> Tactic
Reorder :: Name -> Tactic
Exact :: Raw -> Tactic
Fill :: Raw -> Tactic
MatchFill :: Raw -> Tactic
PrepFill :: Name -> [Name] -> Tactic
CompleteFill :: Tactic
Regret :: Tactic
Solve :: Tactic
StartUnify :: Name -> Tactic
EndUnify :: Tactic
UnifyAll :: Tactic
Compute :: Tactic
ComputeLet :: Name -> Tactic
Simplify :: Tactic
HNF_Compute :: Tactic
EvalIn :: Raw -> Tactic
CheckIn :: Raw -> Tactic
Intro :: (Maybe Name) -> Tactic
IntroTy :: Raw -> (Maybe Name) -> Tactic
Forall :: Name -> (Maybe ImplicitInfo) -> Raw -> Tactic
LetBind :: Name -> Raw -> Raw -> Tactic
ExpandLet :: Name -> Term -> Tactic
Rewrite :: Raw -> Tactic
Induction :: Raw -> Tactic
CaseTac :: Raw -> Tactic
Equiv :: Raw -> Tactic
PatVar :: Name -> Tactic
PatBind :: Name -> Tactic
Focus :: Name -> Tactic
Defer :: [Name] -> Name -> Tactic
DeferType :: Name -> Raw -> [Name] -> Tactic
Instance :: Name -> Tactic
AutoArg :: Name -> Tactic
SetInjective :: Name -> Tactic
MoveLast :: Name -> Tactic
MatchProblems :: Bool -> Tactic
UnifyProblems :: Tactic
UnifyGoal :: Raw -> Tactic
ProofState :: Tactic
Undo :: Tactic
QED :: Tactic
data Goal
GD :: Env -> Binder Term -> Goal
premises :: Goal -> Env
goalType :: Goal -> Binder Term
processTactic :: Tactic -> ProofState -> TC (ProofState, String)
nowElaboratingPS :: FC -> Name -> Name -> ProofState -> ProofState
doneElaboratingAppPS :: Name -> ProofState -> ProofState
doneElaboratingArgPS :: Name -> Name -> ProofState -> ProofState
dropGiven :: Eq a => [a] -> [(a, TT a)] -> [a] -> [(a, TT a)]
keepGiven :: Eq a => [a] -> [(a, TT a)] -> [a] -> [(a, TT a)]
getProvenance :: Err -> (Maybe Provenance, Maybe Provenance)
instance Show Tactic
instance Pretty ProofState OutputAnnotation
instance Show ProofState

module Idris.Core.Elaborate
data ElabState aux
ES :: (ProofState, aux) -> String -> (Maybe (ElabState aux)) -> ElabState aux
type Elab' aux a = StateT (ElabState aux) TC a
type Elab a = Elab' () a
proof :: ElabState aux -> ProofState
proofFail :: Elab' aux a -> Elab' aux a
explicit :: Name -> Elab' aux ()
saveState :: Elab' aux ()
loadState :: Elab' aux ()
getNameFrom :: Name -> Elab' aux Name
setNextName :: Elab' aux ()
initNextNameFrom :: [Name] -> Elab' aux ()
errAt :: String -> Name -> Elab' aux a -> Elab' aux a
erun :: FC -> Elab' aux a -> Elab' aux a
runElab :: aux -> Elab' aux a -> ProofState -> TC (a, ElabState aux)
execElab :: aux -> Elab' aux a -> ProofState -> TC (ElabState aux)
initElaborator :: Name -> Context -> Ctxt TypeInfo -> Type -> ProofState
elaborate :: Context -> Ctxt TypeInfo -> Name -> Type -> aux -> Elab' aux a -> TC (a, String)

-- | Modify the auxiliary state
updateAux :: (aux -> aux) -> Elab' aux ()

-- | Get the auxiliary state
getAux :: Elab' aux aux

-- | Set whether to show the unifier log
unifyLog :: Bool -> Elab' aux ()
getUnifyLog :: Elab' aux Bool

-- | Process a tactic within the current elaborator state
processTactic' :: Tactic -> Elab' aux ()
updatePS :: (ProofState -> ProofState) -> Elab' aux ()
now_elaborating :: FC -> Name -> Name -> Elab' aux ()
done_elaborating_app :: Name -> Elab' aux ()
done_elaborating_arg :: Name -> Name -> Elab' aux ()
elaborating_app :: Elab' aux [(FC, Name, Name)]

-- | Get the global context
get_context :: Elab' aux Context

-- | Update the context. (should only be used for adding temporary
--   definitions or all sorts of stuff could go wrong)
set_context :: Context -> Elab' aux ()
get_datatypes :: Elab' aux (Ctxt TypeInfo)
set_datatypes :: Ctxt TypeInfo -> Elab' aux ()

-- | get the proof term
get_term :: Elab' aux Term

-- | modify the proof term
update_term :: (Term -> Term) -> Elab' aux ()

-- | get the local context at the currently in focus hole
get_env :: Elab' aux Env
get_inj :: Elab' aux [Name]
get_holes :: Elab' aux [Name]
get_probs :: Elab' aux Fails

-- | Return recently solved names (that is, the names solved since the last
--   call to get_recents)
get_recents :: Elab' aux [Name]

-- | get the current goal type
goal :: Elab' aux Type
is_guess :: Elab' aux Bool

-- | Get the guess at the current hole, if there is one
get_guess :: Elab' aux Term

-- | Typecheck locally
get_type :: Raw -> Elab' aux Type
get_type_val :: Raw -> Elab' aux (Term, Type)

-- | get holes we've deferred for later definition
get_deferred :: Elab' aux [Name]
checkInjective :: (Term, Term, Term) -> Elab' aux ()

-- | get instance argument names
get_instances :: Elab' aux [Name]

-- | get auto argument names
get_autos :: Elab' aux [(Name, [Name])]

-- | given a desired hole name, return a unique hole name
unique_hole :: Name -> Elab' aux Name
unique_hole' :: Bool -> Name -> Elab' aux Name
elog :: String -> Elab' aux ()
getLog :: Elab' aux String
attack :: Elab' aux ()
claim :: Name -> Raw -> Elab' aux ()
claimFn :: Name -> Name -> Raw -> Elab' aux ()
unifyGoal :: Raw -> Elab' aux ()
exact :: Raw -> Elab' aux ()
fill :: Raw -> Elab' aux ()
match_fill :: Raw -> Elab' aux ()
prep_fill :: Name -> [Name] -> Elab' aux ()
complete_fill :: Elab' aux ()
solve :: Elab' aux ()
start_unify :: Name -> Elab' aux ()
end_unify :: Elab' aux ()
unify_all :: Elab' aux ()
regret :: Elab' aux ()
compute :: Elab' aux ()
computeLet :: Name -> Elab' aux ()
simplify :: Elab' aux ()
hnf_compute :: Elab' aux ()
eval_in :: Raw -> Elab' aux ()
check_in :: Raw -> Elab' aux ()
intro :: Maybe Name -> Elab' aux ()
introTy :: Raw -> Maybe Name -> Elab' aux ()
forall :: Name -> Maybe ImplicitInfo -> Raw -> Elab' aux ()
letbind :: Name -> Raw -> Raw -> Elab' aux ()
expandLet :: Name -> Term -> Elab' aux ()
rewrite :: Raw -> Elab' aux ()
induction :: Raw -> Elab' aux ()
casetac :: Raw -> Elab' aux ()
equiv :: Raw -> Elab' aux ()

-- | Turn the current hole into a pattern variable with the provided name,
--   made unique if MN
patvar :: Name -> Elab' aux ()
patbind :: Name -> Elab' aux ()
focus :: Name -> Elab' aux ()
movelast :: Name -> Elab' aux ()
dotterm :: Elab' aux ()
get_dotterm :: Elab' aux [(Name, [Name])]

-- | Set the zipper in the proof state to point at the current sub term
--   (This currently happens automatically, so this will have no effect...)
zipHere :: Elab' aux ()
matchProblems :: Bool -> Elab' aux ()
unifyProblems :: Elab' aux ()
defer :: [Name] -> Name -> Elab' aux ()
deferType :: Name -> Raw -> [Name] -> Elab' aux ()
instanceArg :: Name -> Elab' aux ()
autoArg :: Name -> Elab' aux ()
setinj :: Name -> Elab' aux ()
proofstate :: Elab' aux ()
reorder_claims :: Name -> Elab' aux ()
qed :: Elab' aux Term
undo :: Elab' aux ()

-- | Prepare to apply a function by creating holes to be filled by the
--   arguments
prepare_apply :: Raw -> [Bool] -> Elab' aux [(Name, Name)]
apply :: Raw -> [(Bool, Int)] -> Elab' aux [(Name, Name)]
match_apply :: Raw -> [(Bool, Int)] -> Elab' aux [(Name, Name)]
apply' :: (Raw -> Elab' aux ()) -> Raw -> [(Bool, Int)] -> Elab' aux [(Name, Name)]
apply2 :: Raw -> [Maybe (Elab' aux ())] -> Elab' aux ()
apply_elab :: Name -> [Maybe (Int, Elab' aux ())] -> Elab' aux ()
checkPiGoal :: Name -> Elab' aux ()
simple_app :: Bool -> Elab' aux () -> Elab' aux () -> String -> Elab' aux ()
arg :: Name -> Maybe ImplicitInfo -> Name -> Elab' aux ()
no_errors :: Elab' aux () -> Maybe Err -> Elab' aux ()
try :: Elab' aux a -> Elab' aux a -> Elab' aux a
handleError :: (Err -> Bool) -> Elab' aux a -> Elab' aux a -> Elab' aux a
try' :: Elab' aux a -> Elab' aux a -> Bool -> Elab' aux a
tryCatch :: Elab' aux a -> (Err -> Elab' aux a) -> Elab' aux a
tryWhen :: Bool -> Elab' aux a -> Elab' aux a -> Elab' aux a
tryAll :: [(Elab' aux a, Name)] -> Elab' aux a
prunStateT :: Int -> Bool -> [a] -> StateT (ElabState t) TC t1 -> ElabState t -> TC ((t1, Int, Fails), ElabState t)
debugElaborator :: Maybe String -> Elab' aux a
qshow :: Fails -> String
dumpprobs :: Show a => [(t, t1, t2, a)] -> [Char]
instance Show aux => Show (ElabState aux)

module IRTS.Lang
data Endianness
Native :: Endianness
BE :: Endianness
LE :: Endianness
data LVar
Loc :: Int -> LVar
Glob :: Name -> LVar
data LExp
LV :: LVar -> LExp
LApp :: Bool -> LExp -> [LExp] -> LExp
LLazyApp :: Name -> [LExp] -> LExp
LLazyExp :: LExp -> LExp
LForce :: LExp -> LExp
LLet :: Name -> LExp -> LExp -> LExp
LLam :: [Name] -> LExp -> LExp
LProj :: LExp -> Int -> LExp
LCon :: (Maybe LVar) -> Int -> Name -> [LExp] -> LExp
LCase :: CaseType -> LExp -> [LAlt] -> LExp
LConst :: Const -> LExp
LForeign :: FDesc -> FDesc -> [(FDesc, LExp)] -> LExp
LOp :: PrimFn -> [LExp] -> LExp
LNothing :: LExp
LError :: String -> LExp
data FDesc
FCon :: Name -> FDesc
FStr :: String -> FDesc
FUnknown :: FDesc
FIO :: FDesc -> FDesc
FApp :: Name -> [FDesc] -> FDesc
data Export
ExportData :: FDesc -> Export
ExportFun :: Name -> FDesc -> FDesc -> [FDesc] -> Export
data ExportIFace
Export :: Name -> String -> [Export] -> ExportIFace
data PrimFn
LPlus :: ArithTy -> PrimFn
LMinus :: ArithTy -> PrimFn
LTimes :: ArithTy -> PrimFn
LUDiv :: IntTy -> PrimFn
LSDiv :: ArithTy -> PrimFn
LURem :: IntTy -> PrimFn
LSRem :: ArithTy -> PrimFn
LAnd :: IntTy -> PrimFn
LOr :: IntTy -> PrimFn
LXOr :: IntTy -> PrimFn
LCompl :: IntTy -> PrimFn
LSHL :: IntTy -> PrimFn
LLSHR :: IntTy -> PrimFn
LASHR :: IntTy -> PrimFn
LEq :: ArithTy -> PrimFn
LLt :: IntTy -> PrimFn
LLe :: IntTy -> PrimFn
LGt :: IntTy -> PrimFn
LGe :: IntTy -> PrimFn
LSLt :: ArithTy -> PrimFn
LSLe :: ArithTy -> PrimFn
LSGt :: ArithTy -> PrimFn
LSGe :: ArithTy -> PrimFn
LSExt :: IntTy -> IntTy -> PrimFn
LZExt :: IntTy -> IntTy -> PrimFn
LTrunc :: IntTy -> IntTy -> PrimFn
LStrConcat :: PrimFn
LStrLt :: PrimFn
LStrEq :: PrimFn
LStrLen :: PrimFn
LIntFloat :: IntTy -> PrimFn
LFloatInt :: IntTy -> PrimFn
LIntStr :: IntTy -> PrimFn
LStrInt :: IntTy -> PrimFn
LFloatStr :: PrimFn
LStrFloat :: PrimFn
LChInt :: IntTy -> PrimFn
LIntCh :: IntTy -> PrimFn
LBitCast :: ArithTy -> ArithTy -> PrimFn
LFExp :: PrimFn
LFLog :: PrimFn
LFSin :: PrimFn
LFCos :: PrimFn
LFTan :: PrimFn
LFASin :: PrimFn
LFACos :: PrimFn
LFATan :: PrimFn
LFSqrt :: PrimFn
LFFloor :: PrimFn
LFCeil :: PrimFn
LFNegate :: PrimFn
LStrHead :: PrimFn
LStrTail :: PrimFn
LStrCons :: PrimFn
LStrIndex :: PrimFn
LStrRev :: PrimFn
LReadStr :: PrimFn
LWriteStr :: PrimFn
LSystemInfo :: PrimFn
LFork :: PrimFn
LPar :: PrimFn
LExternal :: Name -> PrimFn
LNoOp :: PrimFn
data FCallType
FStatic :: FCallType
FObject :: FCallType
FConstructor :: FCallType
data FType
FArith :: ArithTy -> FType
FFunction :: FType
FFunctionIO :: FType
FString :: FType
FUnit :: FType
FPtr :: FType
FManagedPtr :: FType
FAny :: FType
data LAlt' e
LConCase :: Int -> Name -> [Name] -> e -> LAlt' e
LConstCase :: Const -> e -> LAlt' e
LDefaultCase :: e -> LAlt' e
type LAlt = LAlt' LExp
data LDecl
LFun :: [LOpt] -> Name -> [Name] -> LExp -> LDecl
LConstructor :: Name -> Int -> Int -> LDecl
type LDefs = Ctxt LDecl
data LOpt
Inline :: LOpt
NoInline :: LOpt
addTags :: Int -> [(Name, LDecl)] -> (Int, [(Name, LDecl)])
data LiftState
LS :: Name -> Int -> [(Name, LDecl)] -> LiftState
lname :: Name -> Int -> Name
liftAll :: [(Name, LDecl)] -> [(Name, LDecl)]
lambdaLift :: Name -> LDecl -> [(Name, LDecl)]
getNextName :: State LiftState Name
addFn :: Name -> LDecl -> State LiftState ()
lift :: [Name] -> LExp -> State LiftState LExp
allocUnique :: LDefs -> (Name, LDecl) -> (Name, LDecl)
usedArg :: Eq t => [t] -> t -> [t]
usedIn :: [Name] -> LExp -> [Name]
instance Show Endianness
instance Eq Endianness
instance Show LVar
instance Eq LVar
instance Show FDesc
instance Eq FDesc
instance Show Export
instance Eq Export
instance Show ExportIFace
instance Eq ExportIFace
instance Show PrimFn
instance Eq PrimFn
instance Show FCallType
instance Eq FCallType
instance Show FType
instance Eq FType
instance Show e => Show (LAlt' e)
instance Eq e => Eq (LAlt' e)
instance Functor LAlt'
instance Eq LExp
instance Show LOpt
instance Eq LOpt
instance Show LDecl
instance Eq LDecl
instance Show LExp


-- | Wrapper around Markdown library
module Idris.Docstrings

-- | Representation of Idris's inline documentation. The type paramter
--   represents the type of terms that are associated with code blocks.
data Docstring a
DocString :: Options -> (Blocks a) -> Docstring a

-- | Block-level elements.
data Block a
Para :: (Inlines a) -> Block a
Header :: Int -> (Inlines a) -> Block a
Blockquote :: (Blocks a) -> Block a
List :: Bool -> ListType -> [Blocks a] -> Block a
CodeBlock :: CodeAttr -> Text -> a -> Block a
HtmlBlock :: Text -> Block a
HRule :: Block a
data Inline a
Str :: Text -> Inline a
Space :: Inline a
SoftBreak :: Inline a
LineBreak :: Inline a
Emph :: (Inlines a) -> Inline a
Strong :: (Inlines a) -> Inline a
Code :: Text -> a -> Inline a
Link :: (Inlines a) -> Text -> Text -> Inline a
Image :: (Inlines a) -> Text -> Text -> Inline a
Entity :: Text -> Inline a
RawHtml :: Text -> Inline a

-- | Construct a docstring from a Text that contains Markdown-formatted
--   docs
parseDocstring :: Text -> Docstring ()

-- | Convert a docstring to be shown by the pretty-printer
renderDocstring :: (a -> String -> Doc OutputAnnotation) -> Docstring a -> Doc OutputAnnotation

-- | The empty docstring
emptyDocstring :: Docstring a

-- | Check whether a docstring is emtpy
nullDocstring :: Docstring a -> Bool

-- | Empty documentation for a definition
noDocs :: (Docstring a, [(Name, Docstring a)])

-- | Construct a docstring consisting of the first block-level element of
--   the argument docstring, for use in summaries.
overview :: Docstring a -> Docstring a

-- | Does a string occur in the docstring?
containsText :: Text -> Docstring a -> Bool
renderHtml :: Docstring DocTerm -> Html

-- | Annotate the code samples in a docstring
annotCode :: (String -> b) -> Docstring a -> Docstring b

-- | The various kinds of code samples that can be embedded in docs
data DocTerm
Unchecked :: DocTerm
Checked :: Term -> DocTerm
Example :: Term -> DocTerm
Failing :: Err -> DocTerm

-- | Render a term in the documentation
renderDocTerm :: (Term -> Doc OutputAnnotation) -> (Term -> Term) -> DocTerm -> String -> Doc OutputAnnotation

-- | Run some kind of processing step over code in a Docstring. The code
--   processor gets the language and annotations as parameters, along with
--   the source and the original annotation.
checkDocstring :: (String -> [String] -> String -> a -> b) -> Docstring a -> Docstring b
instance Show DocTerm
instance Show a => Show (Inline a)
instance Functor Inline
instance Foldable Inline
instance Traversable Inline
instance Show a => Show (Block a)
instance Functor Block
instance Foldable Block
instance Traversable Block
instance Show a => Show (Docstring a)
instance Functor Docstring
instance Foldable Docstring
instance Traversable Docstring

module Idris.Unlit
unlit :: FilePath -> String -> TC String

module IRTS.Defunctionalise
data DExp
DV :: LVar -> DExp
DApp :: Bool -> Name -> [DExp] -> DExp
DLet :: Name -> DExp -> DExp -> DExp
DUpdate :: Name -> DExp -> DExp
DProj :: DExp -> Int -> DExp
DC :: (Maybe LVar) -> Int -> Name -> [DExp] -> DExp
DCase :: CaseType -> DExp -> [DAlt] -> DExp
DChkCase :: DExp -> [DAlt] -> DExp
DConst :: Const -> DExp
DForeign :: FDesc -> FDesc -> [(FDesc, DExp)] -> DExp
DOp :: PrimFn -> [DExp] -> DExp
DNothing :: DExp
DError :: String -> DExp
data DAlt
DConCase :: Int -> Name -> [Name] -> DExp -> DAlt
DConstCase :: Const -> DExp -> DAlt
DDefaultCase :: DExp -> DAlt
data DDecl
DFun :: Name -> [Name] -> DExp -> DDecl
DConstructor :: Name -> Int -> Int -> DDecl
type DDefs = Ctxt DDecl
defunctionalise :: Int -> LDefs -> DDefs
getFn :: [(Name, LDecl)] -> [(Name, Int)]
addApps :: LDefs -> (Name, LDecl) -> State ([Name], [(Name, Int)]) (Name, DDecl)
eEVAL :: DExp -> DExp
data EvalApply a
EvalCase :: (Name -> a) -> EvalApply a
ApplyCase :: a -> EvalApply a
toCons :: [Name] -> (Name, Int) -> [(Name, Int, EvalApply DAlt)]
toConsA :: [(Name, Int)] -> (Name, Int) -> [(Name, Int, EvalApply DAlt)]
mkApplyCase :: Name -> Int -> Int -> [(Name, Int, EvalApply DAlt)]
mkEval :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
mkApply :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
declare :: Int -> [(Name, Int, EvalApply DAlt)] -> [(Name, DDecl)]
genArgs :: Int -> [Name]
mkFnCon :: Show a => a -> Name
mkUnderCon :: Name -> Int -> Name
mkBigCase :: t -> Int -> DExp -> [DAlt] -> DExp
groupsOf :: Int -> [DAlt] -> [[DAlt]]
dumpDefuns :: DDefs -> String
instance Show DAlt
instance Eq DAlt
instance Eq DExp
instance Show DDecl
instance Eq DDecl
instance Show DExp

module IRTS.Simplified
simplifyDefs :: DDefs -> [(Name, DDecl)] -> TC [(Name, SDecl)]
data SDecl
SFun :: Name -> [Name] -> Int -> SExp -> SDecl
data SExp
SV :: LVar -> SExp
SApp :: Bool -> Name -> [LVar] -> SExp
SLet :: LVar -> SExp -> SExp -> SExp
SUpdate :: LVar -> SExp -> SExp
SCon :: (Maybe LVar) -> Int -> Name -> [LVar] -> SExp
SCase :: CaseType -> LVar -> [SAlt] -> SExp
SChkCase :: LVar -> [SAlt] -> SExp
SProj :: LVar -> Int -> SExp
SConst :: Const -> SExp
SForeign :: FDesc -> FDesc -> [(FDesc, LVar)] -> SExp
SOp :: PrimFn -> [LVar] -> SExp
SNothing :: SExp
SError :: String -> SExp
data SAlt
SConCase :: Int -> Int -> Name -> [Name] -> SExp -> SAlt
SConstCase :: Const -> SExp -> SAlt
SDefaultCase :: SExp -> SAlt
instance Show SAlt
instance Show SExp
instance Show SDecl

module IRTS.CodegenCommon
data DbgLevel
NONE :: DbgLevel
DEBUG :: DbgLevel
TRACE :: DbgLevel
data OutputType
Raw :: OutputType
Object :: OutputType
Executable :: OutputType
MavenProject :: OutputType
environment :: String -> IO (Maybe String)
data CodegenInfo
CodegenInfo :: String -> OutputType -> String -> String -> [FilePath] -> [FilePath] -> [String] -> [String] -> [String] -> DbgLevel -> [(Name, SDecl)] -> [(Name, DDecl)] -> [(Name, LDecl)] -> Bool -> [ExportIFace] -> CodegenInfo
outputFile :: CodegenInfo -> String
outputType :: CodegenInfo -> OutputType
targetTriple :: CodegenInfo -> String
targetCPU :: CodegenInfo -> String
includes :: CodegenInfo -> [FilePath]
importDirs :: CodegenInfo -> [FilePath]
compileObjs :: CodegenInfo -> [String]
compileLibs :: CodegenInfo -> [String]
compilerFlags :: CodegenInfo -> [String]
debugLevel :: CodegenInfo -> DbgLevel
simpleDecls :: CodegenInfo -> [(Name, SDecl)]
defunDecls :: CodegenInfo -> [(Name, DDecl)]
liftDecls :: CodegenInfo -> [(Name, LDecl)]
interfaces :: CodegenInfo -> Bool
exportDecls :: CodegenInfo -> [ExportIFace]
type CodeGenerator = CodegenInfo -> IO ()
instance Eq DbgLevel
instance Eq OutputType
instance Show OutputType

module Idris.AbsSyntaxTree
data ElabWhat
ETypes :: ElabWhat
EDefns :: ElabWhat
EAll :: ElabWhat
data ElabInfo
EInfo :: [(Name, PTerm)] -> Ctxt [Name] -> (Name -> Name) -> Maybe [String] -> Maybe FC -> (ElabWhat -> ElabInfo -> PDecl -> Idris ()) -> ElabInfo
params :: ElabInfo -> [(Name, PTerm)]
inblock :: ElabInfo -> Ctxt [Name]
liftname :: ElabInfo -> Name -> Name
namespace :: ElabInfo -> Maybe [String]
elabFC :: ElabInfo -> Maybe FC
rec_elabDecl :: ElabInfo -> ElabWhat -> ElabInfo -> PDecl -> Idris ()
toplevel :: ElabInfo
eInfoNames :: ElabInfo -> [Name]
data IOption
IOption :: Int -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Codegen -> OutputType -> FilePath -> [FilePath] -> String -> String -> [Opt] -> Bool -> Bool -> [FilePath] -> [Optimisation] -> IOption
opt_logLevel :: IOption -> Int
opt_typecase :: IOption -> Bool
opt_typeintype :: IOption -> Bool
opt_coverage :: IOption -> Bool

-- | ^ show implicits
opt_showimp :: IOption -> Bool
opt_errContext :: IOption -> Bool
opt_repl :: IOption -> Bool
opt_verbose :: IOption -> Bool
opt_nobanner :: IOption -> Bool
opt_quiet :: IOption -> Bool
opt_codegen :: IOption -> Codegen
opt_outputTy :: IOption -> OutputType
opt_ibcsubdir :: IOption -> FilePath
opt_importdirs :: IOption -> [FilePath]
opt_triple :: IOption -> String
opt_cpu :: IOption -> String
opt_cmdline :: IOption -> [Opt]
opt_origerr :: IOption -> Bool

-- | automatically apply "solve" tactic in prover
opt_autoSolve :: IOption -> Bool

-- | e.g. Builtins+Prelude
opt_autoImport :: IOption -> [FilePath]
opt_optimise :: IOption -> [Optimisation]
defaultOpts :: IOption
data PPOption
PPOption :: Bool -> PPOption

-- | ^ whether to show implicits
ppopt_impl :: PPOption -> Bool
data Optimisation
PETransform :: Optimisation
defaultOptimise :: [Optimisation]

-- | Pretty printing options with default verbosity.
defaultPPOption :: PPOption

-- | Pretty printing options with the most verbosity.
verbosePPOption :: PPOption

-- | Get pretty printing options from the big options record.
ppOption :: IOption -> PPOption

-- | Get pretty printing options from an idris state record.
ppOptionIst :: IState -> PPOption
data LanguageExt
TypeProviders :: LanguageExt
ErrorReflection :: LanguageExt

-- | The output mode in use
data OutputMode

-- | Print user output directly to the handle
RawOutput :: Handle -> OutputMode

-- | Send IDE output for some request ID to the handle
IdeMode :: Integer -> Handle -> OutputMode

-- | How wide is the console?
data ConsoleWidth

-- | Have pretty-printer assume that lines should not be broken
InfinitelyWide :: ConsoleWidth

-- | Manually specified - must be positive
ColsWide :: Int -> ConsoleWidth

-- | Attempt to determine width, or 80 otherwise
AutomaticWidth :: ConsoleWidth

-- | The global state used in the Idris monad
data IState
IState :: Context -> Set ConstraintFC -> [FixDecl] -> Ctxt [PArg] -> Ctxt [Bool] -> Ctxt ClassInfo -> Ctxt DSL -> Ctxt OptInfo -> Ctxt TypeInfo -> Ctxt [Name] -> Ctxt ([([Name], Term, Term)], [PTerm]) -> Ctxt [FnOpt] -> Ctxt CGInfo -> Ctxt [Name] -> Ctxt (Docstring DocTerm, [(Name, Docstring DocTerm)]) -> Ctxt (Docstring DocTerm) -> Ctxt TIData -> Ctxt FnInfo -> Ctxt [(Term, Term)] -> Ctxt [Name] -> [(FC, Name)] -> [(FC, Name)] -> [(FC, String)] -> IOption -> Int -> [((FilePath, Int), PTerm)] -> [(Name, (Maybe Name, Int, Bool))] -> [Name] -> [(Term, Term)] -> SyntaxRules -> [String] -> [FilePath] -> [(Name, (Int, PrimFn))] -> [(Codegen, FilePath)] -> [(Codegen, String)] -> [(Codegen, String)] -> [(Codegen, String)] -> [(FilePath, Bool)] -> [(Name, [String])] -> Maybe FC -> [(FC, Err)] -> Maybe Name -> [Int] -> [Maybe Int] -> Maybe FC -> Maybe FC -> [(Name, Maybe Accessibility)] -> Accessibility -> Bool -> [IBCWrite] -> Maybe String -> [DynamicLib] -> [LanguageExt] -> OutputMode -> Bool -> ColourTheme -> [Name] -> (Int, Ctxt (Int, Name)) -> Ctxt (Map Name (Set Name)) -> Map [Text] [Text] -> ConsoleWidth -> Set Name -> Set (Name, Int) -> [(Name, Int)] -> Maybe (Map Name [Name]) -> Maybe (Map Name [Name]) -> [Name] -> [(Name, Bool)] -> Map Name Name -> [Name] -> IState

-- | All the currently defined names and their terms
tt_ctxt :: IState -> Context

-- | A list of universe constraints and their corresponding source
--   locations
idris_constraints :: IState -> Set ConstraintFC

-- | Currently defined infix operators
idris_infixes :: IState -> [FixDecl]
idris_implicits :: IState -> Ctxt [PArg]
idris_statics :: IState -> Ctxt [Bool]
idris_classes :: IState -> Ctxt ClassInfo
idris_dsls :: IState -> Ctxt DSL
idris_optimisation :: IState -> Ctxt OptInfo
idris_datatypes :: IState -> Ctxt TypeInfo
idris_namehints :: IState -> Ctxt [Name]

-- | list of lhs/rhs, and a list of missing clauses
idris_patdefs :: IState -> Ctxt ([([Name], Term, Term)], [PTerm])
idris_flags :: IState -> Ctxt [FnOpt]
idris_callgraph :: IState -> Ctxt CGInfo
idris_calledgraph :: IState -> Ctxt [Name]
idris_docstrings :: IState -> Ctxt (Docstring DocTerm, [(Name, Docstring DocTerm)])

-- | module documentation is saved in a special MN so the context mechanism
--   can be used for disambiguation
idris_moduledocs :: IState -> Ctxt (Docstring DocTerm)
idris_tyinfodata :: IState -> Ctxt TIData
idris_fninfo :: IState -> Ctxt FnInfo
idris_transforms :: IState -> Ctxt [(Term, Term)]
idris_autohints :: IState -> Ctxt [Name]
idris_totcheck :: IState -> [(FC, Name)]
idris_defertotcheck :: IState -> [(FC, Name)]
idris_totcheckfail :: IState -> [(FC, String)]
idris_options :: IState -> IOption
idris_name :: IState -> Int

-- | Full application LHS on source line
idris_lineapps :: IState -> [((FilePath, Int), PTerm)]

-- | The currently defined but not proven metavariables. The Int is the
--   number of vars to display as a context, the Maybe Name is its
--   top-level function, and the Bool is whether :p is allowed
idris_metavars :: IState -> [(Name, (Maybe Name, Int, Bool))]
idris_coercions :: IState -> [Name]
idris_errRev :: IState -> [(Term, Term)]
syntax_rules :: IState -> SyntaxRules
syntax_keywords :: IState -> [String]

-- | The imported modules
imported :: IState -> [FilePath]
idris_scprims :: IState -> [(Name, (Int, PrimFn))]
idris_objs :: IState -> [(Codegen, FilePath)]
idris_libs :: IState -> [(Codegen, String)]
idris_cgflags :: IState -> [(Codegen, String)]
idris_hdrs :: IState -> [(Codegen, String)]

-- | Imported ibc file names, whether public
idris_imported :: IState -> [(FilePath, Bool)]
proof_list :: IState -> [(Name, [String])]
errSpan :: IState -> Maybe FC
parserWarnings :: IState -> [(FC, Err)]
lastParse :: IState -> Maybe Name
indent_stack :: IState -> [Int]
brace_stack :: IState -> [Maybe Int]

-- | What was the span of the latest token parsed?
lastTokenSpan :: IState -> Maybe FC
idris_parsedSpan :: IState -> Maybe FC
hide_list :: IState -> [(Name, Maybe Accessibility)]
default_access :: IState -> Accessibility
default_total :: IState -> Bool
ibc_write :: IState -> [IBCWrite]
compiled_so :: IState -> Maybe String
idris_dynamic_libs :: IState -> [DynamicLib]
idris_language_extensions :: IState -> [LanguageExt]
idris_outputmode :: IState -> OutputMode
idris_colourRepl :: IState -> Bool
idris_colourTheme :: IState -> ColourTheme

-- | Global error handlers
idris_errorhandlers :: IState -> [Name]
idris_nameIdx :: IState -> (Int, Ctxt (Int, Name))

-- | Specific error handlers
idris_function_errorhandlers :: IState -> Ctxt (Map Name (Set Name))
module_aliases :: IState -> Map [Text] [Text]

-- | How many chars wide is the console?
idris_consolewidth :: IState -> ConsoleWidth
idris_postulates :: IState -> Set Name
idris_externs :: IState -> Set (Name, Int)

-- | Function/constructor name, argument position is used
idris_erasureUsed :: IState -> [(Name, Int)]
idris_whocalls :: IState -> Maybe (Map Name [Name])
idris_callswho :: IState -> Maybe (Map Name [Name])

-- | List of names that were defined in the repl, and can be re-/un-defined
idris_repl_defs :: IState -> [Name]

-- | Stack of names currently being elaborated, Bool set if it's an
--   instance (instances appear twice; also as a funtion name)
elab_stack :: IState -> [(Name, Bool)]

-- | Symbol table (preserves sharing of names)
idris_symbols :: IState -> Map Name Name

-- | Functions with ExportList
idris_exports :: IState -> [Name]
data SizeChange
Smaller :: SizeChange
Same :: SizeChange
Bigger :: SizeChange
Unknown :: SizeChange
type SCGEntry = (Name, [Maybe (Int, SizeChange)])
type UsageReason = (Name, Int)
data CGInfo
CGInfo :: [Name] -> [(Name, [[Name]])] -> [SCGEntry] -> [Name] -> [(Int, [UsageReason])] -> CGInfo
argsdef :: CGInfo -> [Name]
calls :: CGInfo -> [(Name, [[Name]])]
scg :: CGInfo -> [SCGEntry]
argsused :: CGInfo -> [Name]
usedpos :: CGInfo -> [(Int, [UsageReason])]
primDefs :: [Name]
data IBCWrite
IBCFix :: FixDecl -> IBCWrite
IBCImp :: Name -> IBCWrite
IBCStatic :: Name -> IBCWrite
IBCClass :: Name -> IBCWrite
IBCInstance :: Bool -> Bool -> Name -> Name -> IBCWrite
IBCDSL :: Name -> IBCWrite
IBCData :: Name -> IBCWrite
IBCOpt :: Name -> IBCWrite
IBCMetavar :: Name -> IBCWrite
IBCSyntax :: Syntax -> IBCWrite
IBCKeyword :: String -> IBCWrite
IBCImport :: (Bool, FilePath) -> IBCWrite
IBCImportDir :: FilePath -> IBCWrite
IBCObj :: Codegen -> FilePath -> IBCWrite
IBCLib :: Codegen -> String -> IBCWrite
IBCCGFlag :: Codegen -> String -> IBCWrite
IBCDyLib :: String -> IBCWrite
IBCHeader :: Codegen -> String -> IBCWrite
IBCAccess :: Name -> Accessibility -> IBCWrite
IBCMetaInformation :: Name -> MetaInformation -> IBCWrite
IBCTotal :: Name -> Totality -> IBCWrite
IBCFlags :: Name -> [FnOpt] -> IBCWrite
IBCFnInfo :: Name -> FnInfo -> IBCWrite
IBCTrans :: Name -> (Term, Term) -> IBCWrite
IBCErrRev :: (Term, Term) -> IBCWrite
IBCCG :: Name -> IBCWrite
IBCDoc :: Name -> IBCWrite
IBCCoercion :: Name -> IBCWrite
IBCDef :: Name -> IBCWrite
IBCNameHint :: (Name, Name) -> IBCWrite
IBCLineApp :: FilePath -> Int -> PTerm -> IBCWrite
IBCErrorHandler :: Name -> IBCWrite
IBCFunctionErrorHandler :: Name -> Name -> Name -> IBCWrite
IBCPostulate :: Name -> IBCWrite
IBCExtern :: (Name, Int) -> IBCWrite
IBCTotCheckErr :: FC -> String -> IBCWrite
IBCParsedRegion :: FC -> IBCWrite

-- | The name is the special name used to track module docs
IBCModDocs :: Name -> IBCWrite
IBCUsage :: (Name, Int) -> IBCWrite
IBCExport :: Name -> IBCWrite
IBCAutoHint :: Name -> Name -> IBCWrite

-- | The initial state for the compiler
idrisInit :: IState

-- | The monad for the main REPL - reading and processing files and
--   updating global state (hence the IO inner monad). type Idris = WriterT
--   [Either String (IO ())] (State IState a))
type Idris = StateT IState (ExceptT Err IO)
catchError :: Idris a -> (Err -> Idris a) -> Idris a
throwError :: Err -> Idris a
data Codegen
Via :: String -> Codegen
Bytecode :: Codegen
data HowMuchDocs
FullDocs :: HowMuchDocs
OverviewDocs :: HowMuchDocs

-- | REPL commands
data Command
Quit :: Command
Help :: Command
Eval :: PTerm -> Command

-- | Each <a>PDecl</a> should be either a type declaration (at most one) or
--   a clause defining the same name.
NewDefn :: [PDecl] -> Command
Undefine :: [Name] -> Command
Check :: PTerm -> Command
Core :: PTerm -> Command
DocStr :: (Either Name Const) -> HowMuchDocs -> Command
TotCheck :: Name -> Command
Reload :: Command
Load :: FilePath -> (Maybe Int) -> Command
ChangeDirectory :: FilePath -> Command
ModImport :: String -> Command
Edit :: Command
Compile :: Codegen -> String -> Command
Execute :: PTerm -> Command
ExecVal :: PTerm -> Command
Metavars :: Command
Prove :: Name -> Command
AddProof :: (Maybe Name) -> Command
RmProof :: Name -> Command
ShowProof :: Name -> Command
Proofs :: Command
Universes :: Command
LogLvl :: Int -> Command
Spec :: PTerm -> Command
HNF :: PTerm -> Command
TestInline :: PTerm -> Command
Defn :: Name -> Command
Missing :: Name -> Command
DynamicLink :: FilePath -> Command
ListDynamic :: Command
Pattelab :: PTerm -> Command
Search :: [String] -> PTerm -> Command
CaseSplitAt :: Bool -> Int -> Name -> Command
AddClauseFrom :: Bool -> Int -> Name -> Command
AddProofClauseFrom :: Bool -> Int -> Name -> Command
AddMissing :: Bool -> Int -> Name -> Command
MakeWith :: Bool -> Int -> Name -> Command
MakeLemma :: Bool -> Int -> Name -> Command

-- | the first bool is whether to update, the second is whether to search
--   recursively (i.e. for the arguments)
DoProofSearch :: Bool -> Bool -> Int -> Name -> [Name] -> Command
SetOpt :: Opt -> Command
UnsetOpt :: Opt -> Command
NOP :: Command
SetColour :: ColourType -> IdrisColour -> Command
ColourOn :: Command
ColourOff :: Command
ListErrorHandlers :: Command
SetConsoleWidth :: ConsoleWidth -> Command
Apropos :: [String] -> String -> Command
WhoCalls :: Name -> Command
CallsWho :: Name -> Command
Browse :: [String] -> Command
MakeDoc :: String -> Command
Warranty :: Command
PrintDef :: Name -> Command
PPrint :: OutputFmt -> Int -> PTerm -> Command
TransformInfo :: Name -> Command
DebugInfo :: Name -> Command
DebugUnify :: PTerm -> PTerm -> Command
data OutputFmt
HTMLOutput :: OutputFmt
LaTeXOutput :: OutputFmt
data Opt
Filename :: String -> Opt
Quiet :: Opt
NoBanner :: Opt
ColourREPL :: Bool -> Opt
Idemode :: Opt
IdemodeSocket :: Opt
ShowLibs :: Opt
ShowLibdir :: Opt
ShowIncs :: Opt
ShowPkgs :: Opt
NoBasePkgs :: Opt
NoPrelude :: Opt
NoBuiltins :: Opt
NoREPL :: Opt
OLogging :: Int -> Opt
Output :: String -> Opt
Interface :: Opt
TypeCase :: Opt
TypeInType :: Opt
DefaultTotal :: Opt
DefaultPartial :: Opt
WarnPartial :: Opt
WarnReach :: Opt
NoCoverage :: Opt
ErrContext :: Opt
ShowImpl :: Opt
Verbose :: Opt
Port :: String -> Opt
IBCSubDir :: String -> Opt
ImportDir :: String -> Opt
PkgBuild :: String -> Opt
PkgInstall :: String -> Opt
PkgClean :: String -> Opt
PkgCheck :: String -> Opt
PkgREPL :: String -> Opt
PkgMkDoc :: String -> Opt
PkgTest :: String -> Opt
PkgIndex :: FilePath -> Opt
WarnOnly :: Opt
Pkg :: String -> Opt
BCAsm :: String -> Opt
DumpDefun :: String -> Opt
DumpCases :: String -> Opt
UseCodegen :: Codegen -> Opt
OutputTy :: OutputType -> Opt
Extension :: LanguageExt -> Opt
InterpretScript :: String -> Opt
EvalExpr :: String -> Opt
TargetTriple :: String -> Opt
TargetCPU :: String -> Opt
OptLevel :: Int -> Opt
AddOpt :: Optimisation -> Opt
RemoveOpt :: Optimisation -> Opt
Client :: String -> Opt
ShowOrigErr :: Opt

-- | Automatically adjust terminal width
AutoWidth :: Opt

-- | Automatically issue "solve" tactic in interactive prover
AutoSolve :: Opt
UseConsoleWidth :: ConsoleWidth -> Opt
data Fixity
Infixl :: Int -> Fixity
prec :: Fixity -> Int
Infixr :: Int -> Fixity
prec :: Fixity -> Int
InfixN :: Int -> Fixity
prec :: Fixity -> Int
PrefixN :: Int -> Fixity
prec :: Fixity -> Int
data FixDecl
Fix :: Fixity -> String -> FixDecl
data Static
Static :: Static
Dynamic :: Static
data Plicity
Imp :: [ArgOpt] -> Static -> Bool -> Maybe ImplicitInfo -> Plicity
pargopts :: Plicity -> [ArgOpt]
pstatic :: Plicity -> Static
pparam :: Plicity -> Bool
pscoped :: Plicity -> Maybe ImplicitInfo
Exp :: [ArgOpt] -> Static -> Bool -> Plicity
pargopts :: Plicity -> [ArgOpt]
pstatic :: Plicity -> Static
pparam :: Plicity -> Bool
Constraint :: [ArgOpt] -> Static -> Plicity
pargopts :: Plicity -> [ArgOpt]
pstatic :: Plicity -> Static
TacImp :: [ArgOpt] -> Static -> PTerm -> Plicity
pargopts :: Plicity -> [ArgOpt]
pstatic :: Plicity -> Static
pscript :: Plicity -> PTerm
is_scoped :: Plicity -> Maybe ImplicitInfo
impl :: Plicity
forall_imp :: Plicity
forall_constraint :: Plicity
expl :: Plicity
expl_param :: Plicity
constraint :: Plicity
tacimpl :: PTerm -> Plicity
data FnOpt
Inlinable :: FnOpt
TotalFn :: FnOpt
PartialFn :: FnOpt
CoveringFn :: FnOpt
Coinductive :: FnOpt
AssertTotal :: FnOpt
Dictionary :: FnOpt
Implicit :: FnOpt
NoImplicit :: FnOpt
CExport :: String -> FnOpt

-- | ^ an error handler for use with the ErrorReflection extension
ErrorHandler :: FnOpt

-- | ^ attempt to reverse normalise before showing in error
ErrorReverse :: FnOpt
Reflection :: FnOpt
Specialise :: [(Name, Maybe Int)] -> FnOpt
Constructor :: FnOpt
AutoHint :: FnOpt
type FnOpts = [FnOpt]
inlinable :: FnOpts -> Bool
dictionary :: FnOpts -> Bool

-- | Type provider - what to provide
data ProvideWhat' t

-- | the first is the goal type, the second is the term
ProvTerm :: t -> t -> ProvideWhat' t

-- | goal type must be Type, so only term
ProvPostulate :: t -> ProvideWhat' t
type ProvideWhat = ProvideWhat' PTerm

-- | Top-level declarations such as compiler directives, definitions,
--   datatypes and typeclasses.
data PDecl' t

-- | Fixity declaration
PFix :: FC -> Fixity -> [String] -> PDecl' t

-- | Type declaration (last FC is precise name location)
PTy :: (Docstring (Either Err PTerm)) -> [(Name, Docstring (Either Err PTerm))] -> SyntaxInfo -> FC -> FnOpts -> Name -> FC -> t -> PDecl' t

-- | Postulate
PPostulate :: Bool -> (Docstring (Either Err PTerm)) -> SyntaxInfo -> FC -> FnOpts -> Name -> t -> PDecl' t

-- | Pattern clause
PClauses :: FC -> FnOpts -> Name -> [PClause' t] -> PDecl' t

-- | Top level constant
PCAF :: FC -> Name -> t -> PDecl' t

-- | Data declaration.
PData :: (Docstring (Either Err PTerm)) -> [(Name, Docstring (Either Err PTerm))] -> SyntaxInfo -> FC -> DataOpts -> (PData' t) -> PDecl' t

-- | Params block
PParams :: FC -> [(Name, t)] -> [PDecl' t] -> PDecl' t

-- | New namespace, where FC is accurate location of the namespace in the
--   file
PNamespace :: String -> FC -> [PDecl' t] -> PDecl' t

-- | Record declaration
PRecord :: (Docstring (Either Err PTerm)) -> SyntaxInfo -> FC -> DataOpts -> Name -> FC -> [(Name, FC, Plicity, t)] -> [(Name, Docstring (Either Err PTerm))] -> [(Maybe (Name, FC), Plicity, t, Maybe (Docstring (Either Err PTerm)))] -> (Maybe (Name, FC)) -> (Docstring (Either Err PTerm)) -> SyntaxInfo -> PDecl' t

-- | Type class: arguments are documentation, syntax info, source location,
--   constraints, class name, class name location, parameters, method
--   declarations, optional constructor name
PClass :: (Docstring (Either Err PTerm)) -> SyntaxInfo -> FC -> [(Name, t)] -> Name -> FC -> [(Name, FC, t)] -> [(Name, Docstring (Either Err PTerm))] -> [(Name, FC)] -> [PDecl' t] -> (Maybe (Name, FC)) -> (Docstring (Either Err PTerm)) -> PDecl' t

-- | Instance declaration: arguments are documentation, syntax info, source
--   location, constraints, class name, parameters, full instance type,
--   optional explicit name, and definitions
PInstance :: (Docstring (Either Err PTerm)) -> [(Name, Docstring (Either Err PTerm))] -> SyntaxInfo -> FC -> [(Name, t)] -> Name -> FC -> [t] -> t -> (Maybe Name) -> [PDecl' t] -> PDecl' t

-- | DSL declaration
PDSL :: Name -> (DSL' t) -> PDecl' t

-- | Syntax definition
PSyntax :: FC -> Syntax -> PDecl' t

-- | Mutual block
PMutual :: FC -> [PDecl' t] -> PDecl' t

-- | Compiler directive.
PDirective :: Directive -> PDecl' t

-- | Type provider. The first t is the type, the second is the term
PProvider :: (Docstring (Either Err PTerm)) -> SyntaxInfo -> FC -> (ProvideWhat' t) -> Name -> PDecl' t

-- | Source-to-source transformation rule. If bool is True, lhs and rhs
--   must be convertible
PTransform :: FC -> Bool -> t -> t -> PDecl' t

-- | The set of source directives
data Directive
DLib :: Codegen -> String -> Directive
DLink :: Codegen -> String -> Directive
DFlag :: Codegen -> String -> Directive
DInclude :: Codegen -> String -> Directive
DHide :: Name -> Directive
DFreeze :: Name -> Directive
DAccess :: Accessibility -> Directive
DDefault :: Bool -> Directive
DLogging :: Integer -> Directive
DDynamicLibs :: [String] -> Directive
DNameHint :: Name -> [Name] -> Directive
DErrorHandlers :: Name -> Name -> [Name] -> Directive
DLanguage :: LanguageExt -> Directive
DUsed :: FC -> Name -> Name -> Directive

-- | A set of instructions for things that need to happen in IState after a
--   term elaboration when there's been reflected elaboration.
data RDeclInstructions
RTyDeclInstrs :: Name -> FC -> [PArg] -> Type -> RDeclInstructions
RClausesInstrs :: Name -> [([Name], Term, Term)] -> RDeclInstructions
RAddInstance :: Name -> Name -> RDeclInstructions

-- | For elaborator state
data EState
EState :: [(Name, PDecl)] -> [(Int, Elab' EState ())] -> [RDeclInstructions] -> [(FC, OutputAnnotation)] -> EState
case_decls :: EState -> [(Name, PDecl)]
delayed_elab :: EState -> [(Int, Elab' EState ())]
new_tyDecls :: EState -> [RDeclInstructions]
highlighting :: EState -> [(FC, OutputAnnotation)]
initEState :: EState
type ElabD a = Elab' EState a
highlightSource :: FC -> OutputAnnotation -> ElabD ()

-- | One clause of a top-level definition. Term arguments to constructors
--   are:
--   
--   <ol>
--   <li>The whole application (missing for PClauseR and PWithR because
--   they're within a "with" clause)</li>
--   <li>The list of extra <tt>with</tt> patterns</li>
--   <li>The right-hand side</li>
--   <li>The where block (PDecl' t)</li>
--   </ol>
data PClause' t

-- | A normal top-level definition.
PClause :: FC -> Name -> t -> [t] -> t -> [PDecl' t] -> PClause' t
PWith :: FC -> Name -> t -> [t] -> t -> (Maybe (Name, FC)) -> [PDecl' t] -> PClause' t
PClauseR :: FC -> [t] -> t -> [PDecl' t] -> PClause' t
PWithR :: FC -> [t] -> t -> (Maybe (Name, FC)) -> [PDecl' t] -> PClause' t

-- | Data declaration
data PData' t

-- | Data declaration
PDatadecl :: Name -> FC -> t -> [(Docstring (Either Err PTerm), [(Name, Docstring (Either Err PTerm))], Name, FC, t, FC, [Name])] -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | The precise location of the type constructor name
d_name_fc :: PData' t -> FC

-- | Type constructor
d_tcon :: PData' t -> t

-- | Constructors
d_cons :: PData' t -> [(Docstring (Either Err PTerm), [(Name, Docstring (Either Err PTerm))], Name, FC, t, FC, [Name])]

-- | <a>Placeholder</a> for data whose constructors are defined later
PLaterdecl :: Name -> FC -> t -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | The precise location of the type constructor name
d_name_fc :: PData' t -> FC

-- | Type constructor
d_tcon :: PData' t -> t
type PDecl = PDecl' PTerm
type PData = PData' PTerm
type PClause = PClause' PTerm
declared :: PDecl -> [Name]
tldeclared :: PDecl -> [Name]
defined :: PDecl -> [Name]
updateN :: [(Name, Name)] -> Name -> Name
updateNs :: [(Name, Name)] -> PTerm -> PTerm
data PunInfo
IsType :: PunInfo
IsTerm :: PunInfo
TypeOrTerm :: PunInfo

-- | High level language terms
data PTerm

-- | Inclusion of a core term into the high-level language
PQuote :: Raw -> PTerm

-- | A reference to a variable
PRef :: FC -> Name -> PTerm

-- | A name to be defined later
PInferRef :: FC -> Name -> PTerm

-- | A pattern variable
PPatvar :: FC -> Name -> PTerm

-- | A lambda abstraction. Second FC is name span.
PLam :: FC -> Name -> FC -> PTerm -> PTerm -> PTerm

-- | (n : t1) -&gt; t2, where the FC is for the precise location of the
--   variable
PPi :: Plicity -> Name -> FC -> PTerm -> PTerm -> PTerm

-- | A let binding (second FC is precise name location)
PLet :: FC -> Name -> FC -> PTerm -> PTerm -> PTerm -> PTerm

-- | Term with explicit type
PTyped :: PTerm -> PTerm -> PTerm

-- | e.g. IO (), List Char, length x
PApp :: FC -> PTerm -> [PArg] -> PTerm

-- | Implicit argument application (introduced during elaboration only)
PAppImpl :: PTerm -> [ImplicitInfo] -> PTerm

-- | implicitly bound application
PAppBind :: FC -> PTerm -> [PArg] -> PTerm

-- | Make an application by type matching
PMatchApp :: FC -> Name -> PTerm

-- | Conditional expressions - elaborated to an overloading of ifThenElse
PIfThenElse :: FC -> PTerm -> PTerm -> PTerm -> PTerm

-- | A case expression. Args are source location, scrutinee, and a list of
--   pattern/RHS pairs
PCase :: FC -> PTerm -> [(PTerm, PTerm)] -> PTerm

-- | Unit type..?
PTrue :: FC -> PunInfo -> PTerm

-- | Solve this dictionary by type class resolution
PResolveTC :: FC -> PTerm

-- | "rewrite" syntax, with optional result type
PRewrite :: FC -> PTerm -> PTerm -> (Maybe PTerm) -> PTerm

-- | A pair (a, b) and whether it's a product type or a pair (solved by
--   elaboration)
PPair :: FC -> PunInfo -> PTerm -> PTerm -> PTerm

-- | A dependent pair (tm : a ** b) and whether it's a sigma type or a pair
--   that inhabits one (solved by elaboration)
PDPair :: FC -> PunInfo -> PTerm -> PTerm -> PTerm -> PTerm

-- | @-pattern, valid LHS only
PAs :: FC -> Name -> PTerm -> PTerm

-- | True if only one may work. (| A, B, C|)
PAlternative :: PAltType -> [PTerm] -> PTerm

-- | Irrelevant or hidden pattern
PHidden :: PTerm -> PTerm

-- | <a>Type</a> type
PType :: FC -> PTerm

-- | Some universe
PUniverse :: Universe -> PTerm

-- | quoteGoal, used for %reflection functions
PGoal :: FC -> PTerm -> Name -> PTerm -> PTerm

-- | Builtin types
PConstant :: FC -> Const -> PTerm

-- | Underscore
Placeholder :: PTerm

-- | Do notation
PDoBlock :: [PDo] -> PTerm

-- | Idiom brackets
PIdiom :: FC -> PTerm -> PTerm
PReturn :: FC -> PTerm

-- | A metavariable, ?name, and its precise location
PMetavar :: FC -> Name -> PTerm

-- | Proof script
PProof :: [PTactic] -> PTerm

-- | As PProof, but no auto solving
PTactics :: [PTactic] -> PTerm

-- | Error to report on elaboration
PElabError :: Err -> PTerm

-- | Special case for declaring when an LHS can't typecheck
PImpossible :: PTerm

-- | To mark a coerced argument, so as not to coerce twice
PCoerced :: PTerm -> PTerm

-- | Preferences for explicit namespaces
PDisamb :: [[Text]] -> PTerm -> PTerm

-- | dump a trace of unifications when building term
PUnifyLog :: PTerm -> PTerm

-- | never run implicit converions on the term
PNoImplicits :: PTerm -> PTerm

-- | `(Term [: Term])
PQuasiquote :: PTerm -> (Maybe PTerm) -> PTerm

-- | ~Term
PUnquote :: PTerm -> PTerm

-- | `{n}
PQuoteName :: Name -> PTerm

-- | %runElab tm - New-style proof script
PRunElab :: FC -> PTerm -> PTerm
data PAltType

-- | flag sets whether delay is allowed
ExactlyOne :: Bool -> PAltType
FirstSuccess :: PAltType
mapPT :: (PTerm -> PTerm) -> PTerm -> PTerm
data PTactic' t
Intro :: [Name] -> PTactic' t
Intros :: PTactic' t
Focus :: Name -> PTactic' t
Refine :: Name -> [Bool] -> PTactic' t
Rewrite :: t -> PTactic' t
DoUnify :: PTactic' t
Induction :: t -> PTactic' t
CaseTac :: t -> PTactic' t
Equiv :: t -> PTactic' t
Claim :: Name -> t -> PTactic' t
Unfocus :: PTactic' t
MatchRefine :: Name -> PTactic' t
LetTac :: Name -> t -> PTactic' t
LetTacTy :: Name -> t -> t -> PTactic' t
Exact :: t -> PTactic' t
Compute :: PTactic' t
Trivial :: PTactic' t
TCInstance :: PTactic' t

-- | the bool is whether to search recursively
ProofSearch :: Bool -> Bool -> Int -> (Maybe Name) -> [Name] -> PTactic' t
Solve :: PTactic' t
Attack :: PTactic' t
ProofState :: PTactic' t
ProofTerm :: PTactic' t
Undo :: PTactic' t
Try :: (PTactic' t) -> (PTactic' t) -> PTactic' t
TSeq :: (PTactic' t) -> (PTactic' t) -> PTactic' t
ApplyTactic :: t -> PTactic' t
ByReflection :: t -> PTactic' t
Reflect :: t -> PTactic' t
Fill :: t -> PTactic' t
GoalType :: String -> (PTactic' t) -> PTactic' t
TCheck :: t -> PTactic' t
TEval :: t -> PTactic' t
TDocStr :: (Either Name Const) -> PTactic' t
TSearch :: t -> PTactic' t
Skip :: PTactic' t
TFail :: [ErrorReportPart] -> PTactic' t
Qed :: PTactic' t
Abandon :: PTactic' t
SourceFC :: PTactic' t
type PTactic = PTactic' PTerm
data PDo' t
DoExp :: FC -> t -> PDo' t

-- | second FC is precise name location
DoBind :: FC -> Name -> FC -> t -> PDo' t
DoBindP :: FC -> t -> t -> [(t, t)] -> PDo' t

-- | second FC is precise name location
DoLet :: FC -> Name -> FC -> t -> t -> PDo' t
DoLetP :: FC -> t -> t -> PDo' t
type PDo = PDo' PTerm
data PArg' t
PImp :: Int -> Bool -> [ArgOpt] -> Name -> t -> PArg' t
priority :: PArg' t -> Int
machine_inf :: PArg' t -> Bool
argopts :: PArg' t -> [ArgOpt]
pname :: PArg' t -> Name
getTm :: PArg' t -> t
PExp :: Int -> [ArgOpt] -> Name -> t -> PArg' t
priority :: PArg' t -> Int
argopts :: PArg' t -> [ArgOpt]
pname :: PArg' t -> Name
getTm :: PArg' t -> t
PConstraint :: Int -> [ArgOpt] -> Name -> t -> PArg' t
priority :: PArg' t -> Int
argopts :: PArg' t -> [ArgOpt]
pname :: PArg' t -> Name
getTm :: PArg' t -> t
PTacImplicit :: Int -> [ArgOpt] -> Name -> t -> t -> PArg' t
priority :: PArg' t -> Int
argopts :: PArg' t -> [ArgOpt]
pname :: PArg' t -> Name
getScript :: PArg' t -> t
getTm :: PArg' t -> t
data ArgOpt
AlwaysShow :: ArgOpt
HideDisplay :: ArgOpt
InaccessibleArg :: ArgOpt
UnknownImp :: ArgOpt
pimp :: Name -> t -> Bool -> PArg' t
pexp :: t -> PArg' t
pconst :: t -> PArg' t
ptacimp :: Name -> t -> t -> PArg' t
type PArg = PArg' PTerm

-- | Get the highest FC in a term, if one exists
highestFC :: PTerm -> Maybe FC
data ClassInfo
CI :: Name -> [(Name, (FnOpts, PTerm))] -> [(Name, (Name, PDecl))] -> [PDecl] -> [Name] -> [(Name, Bool)] -> [Int] -> ClassInfo
instanceCtorName :: ClassInfo -> Name
class_methods :: ClassInfo -> [(Name, (FnOpts, PTerm))]
class_defaults :: ClassInfo -> [(Name, (Name, PDecl))]
class_default_superclasses :: ClassInfo -> [PDecl]
class_params :: ClassInfo -> [Name]
class_instances :: ClassInfo -> [(Name, Bool)]
class_determiners :: ClassInfo -> [Int]
data TIData

-- | a function with a partially defined type
TIPartial :: TIData

-- | possible solutions to a metavariable in a type
TISolution :: [Term] -> TIData

-- | Miscellaneous information about functions
data FnInfo
FnInfo :: [Int] -> FnInfo
fn_params :: FnInfo -> [Int]
data OptInfo
Optimise :: [(Int, Name)] -> Bool -> OptInfo
inaccessible :: OptInfo -> [(Int, Name)]
detaggable :: OptInfo -> Bool

-- | Syntactic sugar info
data DSL' t
DSL :: t -> t -> t -> t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> DSL' t
dsl_bind :: DSL' t -> t
dsl_return :: DSL' t -> t
dsl_apply :: DSL' t -> t
dsl_pure :: DSL' t -> t
dsl_var :: DSL' t -> Maybe t
index_first :: DSL' t -> Maybe t
index_next :: DSL' t -> Maybe t
dsl_lambda :: DSL' t -> Maybe t
dsl_let :: DSL' t -> Maybe t
dsl_pi :: DSL' t -> Maybe t
type DSL = DSL' PTerm
data SynContext
PatternSyntax :: SynContext
TermSyntax :: SynContext
AnySyntax :: SynContext
data Syntax
Rule :: [SSymbol] -> PTerm -> SynContext -> Syntax
syntaxNames :: Syntax -> [Name]
syntaxSymbols :: Syntax -> [SSymbol]
data SSymbol
Keyword :: Name -> SSymbol
Symbol :: String -> SSymbol
Binding :: Name -> SSymbol
Expr :: Name -> SSymbol
SimpleExpr :: Name -> SSymbol
newtype SyntaxRules
SyntaxRules :: [Syntax] -> SyntaxRules
syntaxRulesList :: SyntaxRules -> [Syntax]
emptySyntaxRules :: SyntaxRules
updateSyntaxRules :: [Syntax] -> SyntaxRules -> SyntaxRules
initDSL :: DSL' PTerm
data Using
UImplicit :: Name -> PTerm -> Using
UConstraint :: Name -> [Name] -> Using
data SyntaxInfo
Syn :: [Using] -> [(Name, PTerm)] -> [String] -> [Name] -> [Name] -> (Name -> Name) -> Bool -> Bool -> Maybe Int -> Int -> DSL -> Int -> SyntaxInfo
using :: SyntaxInfo -> [Using]
syn_params :: SyntaxInfo -> [(Name, PTerm)]
syn_namespace :: SyntaxInfo -> [String]
no_imp :: SyntaxInfo -> [Name]
imp_methods :: SyntaxInfo -> [Name]
decoration :: SyntaxInfo -> Name -> Name
inPattern :: SyntaxInfo -> Bool
implicitAllowed :: SyntaxInfo -> Bool
maxline :: SyntaxInfo -> Maybe Int
mut_nesting :: SyntaxInfo -> Int
dsl_info :: SyntaxInfo -> DSL
syn_in_quasiquote :: SyntaxInfo -> Int
defaultSyntax :: SyntaxInfo
expandNS :: SyntaxInfo -> Name -> Name
bi :: FC
inferTy :: Name
inferCon :: Name
inferDecl :: PData' PTerm
inferOpts :: [t]
infTerm :: PTerm -> PTerm
infP :: TT Name
getInferTerm :: Term -> Term
getInferType :: Term -> Term
primNames :: [Name]
unitTy :: Name
unitCon :: Name
falseDoc :: Docstring (Err' t)
falseTy :: Name
pairTy :: Name
pairCon :: Name
upairTy :: Name
upairCon :: Name
eqTy :: Name
eqCon :: Name
eqDoc :: Docstring (Either (Err' t) b)
eqDecl :: PData' PTerm
eqParamDoc :: [(Name, Docstring (Either (Err' t) b))]
eqOpts :: [t]

-- | The special name to be used in the module documentation context - not
--   for use in the main definition context. The namespace around it will
--   determine the module to which the docs adhere.
modDocName :: Name
sigmaTy :: Name
sigmaCon :: Name
piBind :: [(Name, PTerm)] -> PTerm -> PTerm
piBindp :: Plicity -> [(Name, PTerm)] -> PTerm -> PTerm

-- | Colourise annotations according to an Idris state. It ignores the
--   names in the annotation, as there's no good way to show extended
--   information on a terminal.
consoleDecorate :: IState -> OutputAnnotation -> String -> String
isPostulateName :: Name -> IState -> Bool

-- | Pretty-print a high-level closed Idris term with no information about
--   precedence/associativity
prettyImp :: PPOption -> PTerm -> Doc OutputAnnotation

-- | Serialise something to base64 using its Binary instance.
--   
--   Do the right thing for rendering a term in an IState
prettyIst :: IState -> PTerm -> Doc OutputAnnotation

-- | Pretty-print a high-level Idris term in some bindings context with
--   infix info
pprintPTerm :: PPOption -> [(Name, Bool)] -> [Name] -> [FixDecl] -> PTerm -> Doc OutputAnnotation

-- | Strip away namespace information
basename :: Name -> Name

-- | Determine whether a name was the one inserted for a hole or guess by
--   the delaborator
isHoleName :: Name -> Bool

-- | Check whether a PTerm has been delaborated from a Term containing a
--   Hole or Guess
containsHole :: PTerm -> Bool

-- | Pretty-printer helper for names that attaches the correct annotations
prettyName :: Bool -> Bool -> [(Name, Bool)] -> Name -> Doc OutputAnnotation
showCImp :: PPOption -> PClause -> Doc OutputAnnotation
showDImp :: PPOption -> PData -> Doc OutputAnnotation
showDecls :: PPOption -> [PDecl] -> Doc OutputAnnotation
showDeclImp :: PPOption -> PDecl' PTerm -> Doc OutputAnnotation
getImps :: [PArg] -> [(Name, PTerm)]
getExps :: [PArg] -> [PTerm]
getShowArgs :: [PArg] -> [PArg]
getConsts :: [PArg] -> [PTerm]
getAll :: [PArg] -> [PTerm]

-- | Show Idris name
showName :: Maybe IState -> [(Name, Bool)] -> PPOption -> Bool -> Name -> String
showTm :: IState -> PTerm -> String

-- | Show a term with implicits, no colours
showTmImpls :: PTerm -> String
getPArity :: PTerm -> Int
allNamesIn :: PTerm -> [Name]
boundNamesIn :: PTerm -> [Name]
implicitNamesIn :: [Name] -> IState -> PTerm -> [Name]
namesIn :: [(Name, PTerm)] -> IState -> PTerm -> [Name]
usedNamesIn :: [Name] -> IState -> PTerm -> [Name]
getErasureInfo :: IState -> Name -> [Int]
instance Typeable Static
instance Typeable PunInfo
instance Typeable PAltType
instance Typeable PTactic'
instance Typeable PDo'
instance Typeable ArgOpt
instance Typeable PArg'
instance Typeable PTerm
instance Typeable Plicity
instance Show ElabWhat
instance Eq ElabWhat
instance Show PPOption
instance Show Optimisation
instance Eq Optimisation
instance Show LanguageExt
instance Eq LanguageExt
instance Read LanguageExt
instance Ord LanguageExt
instance Show OutputMode
instance Show ConsoleWidth
instance Eq ConsoleWidth
instance Show SizeChange
instance Eq SizeChange
instance Show CGInfo
instance Show Codegen
instance Eq Codegen
instance Show Opt
instance Eq Opt
instance Show IOption
instance Eq IOption
instance Eq Fixity
instance Eq FixDecl
instance Show Static
instance Eq Static
instance Data Static
instance Show FnOpt
instance Eq FnOpt
instance Show t => Show (ProvideWhat' t)
instance Eq t => Eq (ProvideWhat' t)
instance Functor ProvideWhat'
instance Eq PunInfo
instance Show PunInfo
instance Data PunInfo
instance Eq PAltType
instance Data PAltType
instance Show t => Show (PTactic' t)
instance Eq t => Eq (PTactic' t)
instance Functor PTactic'
instance Foldable PTactic'
instance Traversable PTactic'
instance Data t => Data (PTactic' t)
instance Eq t => Eq (PDo' t)
instance Functor PDo'
instance Data t => Data (PDo' t)
instance Show ArgOpt
instance Eq ArgOpt
instance Data ArgOpt
instance Show t => Show (PArg' t)
instance Eq t => Eq (PArg' t)
instance Functor PArg'
instance Data t => Data (PArg' t)
instance Eq PTerm
instance Data PTerm
instance Show Plicity
instance Eq Plicity
instance Data Plicity
instance Functor PData'
instance Show TIData
instance Show FnInfo
instance Show OptInfo
instance Show t => Show (DSL' t)
instance Functor DSL'
instance Show SynContext
instance Show SSymbol
instance Eq SSymbol
instance Show Syntax
instance Show IBCWrite
instance Show Using
instance Eq Using
instance Show SyntaxInfo
instance Functor PDecl'
instance Functor PClause'
instance Show ClassInfo
instance Sized PTerm
instance Pretty PTerm OutputAnnotation
instance Show PData
instance Show PClause
instance Show PDecl
instance Show PTerm
instance Sized a => Sized (PArg' a)
instance Sized a => Sized (PDo' a)
instance Sized a => Sized (PTactic' a)
instance Ord FixDecl
instance Show FixDecl
instance Show Fixity
instance Show IState

module Idris.DeepSeq
instance NFData SyntaxInfo
instance NFData Using
instance NFData SSymbol
instance NFData Syntax
instance NFData SynContext
instance NFData t => NFData (DSL' t)
instance NFData TypeInfo
instance NFData OptInfo
instance NFData ClassInfo
instance NFData t => NFData (PArg' t)
instance NFData t => NFData (PDo' t)
instance NFData ErrorReportPart
instance NFData t => NFData (PTactic' t)
instance NFData PAltType
instance NFData PTerm
instance NFData t => NFData (PData' t)
instance NFData t => NFData (PClause' t)
instance NFData PunInfo
instance NFData t => NFData (ProvideWhat' t)
instance NFData t => NFData (PDecl' t)
instance NFData DataOpt
instance NFData FnOpt
instance NFData Plicity
instance NFData ArgOpt
instance NFData Static
instance NFData FixDecl
instance NFData Fixity
instance NFData CGInfo
instance NFData Codegen
instance NFData FnInfo
instance NFData SizeChange
instance NFData DocTerm
instance NFData NumWrapper
instance NFData CodeAttr
instance NFData ListType
instance NFData a => NFData (Inline a)
instance NFData a => NFData (Block a)
instance NFData Options
instance NFData a => NFData (Docstring a)

module Idris.ASTUtils
data Field rec fld
Field :: (rec -> fld) -> (fld -> rec -> rec) -> Field rec fld
fget :: Field rec fld -> rec -> fld
fset :: Field rec fld -> fld -> rec -> rec
fmodify :: Field rec fld -> (fld -> fld) -> rec -> rec
fgetState :: MonadState s m => Field s a -> m a
fputState :: MonadState s m => Field s a -> a -> m ()
fmodifyState :: MonadState s m => Field s a -> (a -> a) -> m ()
ctxt_lookup :: Name -> Field (Ctxt a) (Maybe a)
maybe_default :: a -> Field (Maybe a) a
ist_optimisation :: Name -> Field IState OptInfo
opt_inaccessible :: Field OptInfo [(Int, Name)]
opt_detaggable :: Field OptInfo Bool
ist_callgraph :: Name -> Field IState CGInfo
cg_usedpos :: Field CGInfo [(Int, [UsageReason])]
opts_idrisCmdline :: Field IState [Opt]
known_terms :: Field IState (Ctxt (Def, Accessibility, Totality, MetaInformation))
known_classes :: Field IState (Ctxt ClassInfo)
repl_definitions :: Field IState [Name]
idris_fixities :: Field IState [FixDecl]
instance Category Field

module IRTS.BCImp
data Reg
RVal :: Reg
L :: Int -> Reg
data BC
NOP :: BC
toBC :: (Name, SDecl) -> (Name, [BC])
bc :: Reg -> SExp -> [BC]

module IRTS.Bytecode
data Reg
RVal :: Reg
L :: Int -> Reg
T :: Int -> Reg
Tmp :: Reg
data BC
ASSIGN :: Reg -> Reg -> BC
ASSIGNCONST :: Reg -> Const -> BC
UPDATE :: Reg -> Reg -> BC
MKCON :: Reg -> (Maybe Reg) -> Int -> [Reg] -> BC
CASE :: Bool -> Reg -> [(Int, [BC])] -> (Maybe [BC]) -> BC
PROJECT :: Reg -> Int -> Int -> BC
PROJECTINTO :: Reg -> Reg -> Int -> BC
CONSTCASE :: Reg -> [(Const, [BC])] -> (Maybe [BC]) -> BC
CALL :: Name -> BC
TAILCALL :: Name -> BC
FOREIGNCALL :: Reg -> FDesc -> FDesc -> [(FDesc, Reg)] -> BC
SLIDE :: Int -> BC
REBASE :: BC
RESERVE :: Int -> BC
ADDTOP :: Int -> BC
TOPBASE :: Int -> BC
BASETOP :: Int -> BC
STOREOLD :: BC
OP :: Reg -> PrimFn -> [Reg] -> BC
NULL :: Reg -> BC
ERROR :: String -> BC
toBC :: (Name, SDecl) -> (Name, [BC])
clean :: Bool -> [BC]
bc :: Reg -> SExp -> Bool -> [BC]
isConst :: [SAlt] -> Bool
moveReg :: Int -> [LVar] -> [BC]
assign :: Reg -> Reg -> [BC]
conCase :: Bool -> Reg -> Reg -> [SAlt] -> Bool -> [BC]
constCase :: Reg -> Reg -> [SAlt] -> Bool -> [BC]
caseAlt :: Reg -> Reg -> Bool -> SAlt -> Maybe (Int, [BC])
constAlt :: t -> Reg -> Bool -> SAlt -> Maybe (Const, [BC])
defaultAlt :: Reg -> [SAlt] -> Bool -> Maybe [BC]
instance Show Reg
instance Eq Reg
instance Show BC

module IRTS.LangOpts
inlineAll :: [(Name, LDecl)] -> [(Name, LDecl)]
nextN :: State Int Name
doInline :: LDefs -> LDecl -> LDecl

module IRTS.DumpBC
interMap :: [a] -> [b] -> (a -> [b]) -> [b]
indent :: Int -> String
serializeReg :: Reg -> String
serializeCase :: Show a => Int -> (a, [BC]) -> String
serializeDefault :: Int -> [BC] -> String
serializeBC :: Int -> BC -> String
serialize :: [(Name, [BC])] -> String
dumpBC :: [(Name, SDecl)] -> String -> IO ()

module IRTS.Inliner
inline :: DDefs -> DDefs
inl :: DDefs -> (Name, DDecl) -> (Name, DDecl)
evalD :: t -> a -> Maybe a


-- | Binary instances for the core datatypes
module Idris.Core.Binary
instance Binary (TT Name)
instance Binary UExp
instance Binary NameType
instance Binary Universe
instance Binary b => Binary (Binder b)
instance Binary ImplicitInfo
instance Binary Raw
instance Binary Const
instance Binary SpecialName
instance Binary Name
instance Binary FC
instance Binary a => Binary (Err' a)
instance Binary ConstraintFC
instance Binary UConstraint
instance Binary Provenance
instance Binary ErrorReportPart

module Idris.IdeMode
parseMessage :: String -> Either Err (SExp, Integer)
convSExp :: SExpable a => String -> a -> Integer -> String
data WhatDocs
Overview :: WhatDocs
Full :: WhatDocs
data IdeModeCommand
REPLCompletions :: String -> IdeModeCommand
Interpret :: String -> IdeModeCommand
TypeOf :: String -> IdeModeCommand
CaseSplit :: Int -> String -> IdeModeCommand
AddClause :: Int -> String -> IdeModeCommand
AddProofClause :: Int -> String -> IdeModeCommand
AddMissing :: Int -> String -> IdeModeCommand
MakeWithBlock :: Int -> String -> IdeModeCommand

-- | ^ Recursive?, line, name, hints, depth
ProofSearch :: Bool -> Int -> String -> [String] -> (Maybe Int) -> IdeModeCommand
MakeLemma :: Int -> String -> IdeModeCommand
LoadFile :: String -> (Maybe Int) -> IdeModeCommand
DocsFor :: String -> WhatDocs -> IdeModeCommand
Apropos :: String -> IdeModeCommand
GetOpts :: IdeModeCommand
SetOpt :: Opt -> Bool -> IdeModeCommand

-- | ^ the Int is the column count for pretty-printing
Metavariables :: Int -> IdeModeCommand
WhoCalls :: String -> IdeModeCommand
CallsWho :: String -> IdeModeCommand
BrowseNS :: String -> IdeModeCommand
TermNormalise :: [(Name, Bool)] -> Term -> IdeModeCommand
TermShowImplicits :: [(Name, Bool)] -> Term -> IdeModeCommand
TermNoImplicits :: [(Name, Bool)] -> Term -> IdeModeCommand
TermElab :: [(Name, Bool)] -> Term -> IdeModeCommand
PrintDef :: String -> IdeModeCommand
ErrString :: Err -> IdeModeCommand
ErrPPrint :: Err -> IdeModeCommand
GetIdrisVersion :: IdeModeCommand
sexpToCommand :: SExp -> Maybe IdeModeCommand
data SExp
SexpList :: [SExp] -> SExp
StringAtom :: String -> SExp
BoolAtom :: Bool -> SExp
IntegerAtom :: Integer -> SExp
SymbolAtom :: String -> SExp
class SExpable a
toSExp :: SExpable a => a -> SExp
data Opt
ShowImpl :: Opt
ErrContext :: Opt

-- | The version of the IDE mode command set. Increment this when you
--   change it so clients can adapt.
ideModeEpoch :: Int
getLen :: Handle -> IO (Either Err Int)
getNChar :: Handle -> Int -> String -> IO (String)
instance [incoherent] Eq SExp
instance [incoherent] Show SExp
instance [incoherent] Show Opt
instance [incoherent] SExpable FC
instance [incoherent] SExpable OutputAnnotation
instance [incoherent] SExpable NameOutput
instance [incoherent] (SExpable a, SExpable b, SExpable c, SExpable d, SExpable e) => SExpable (a, b, c, d, e)
instance [incoherent] (SExpable a, SExpable b, SExpable c, SExpable d) => SExpable (a, b, c, d)
instance [incoherent] (SExpable a, SExpable b, SExpable c) => SExpable (a, b, c)
instance [incoherent] (SExpable a, SExpable b) => SExpable (a, b)
instance [incoherent] SExpable a => SExpable [a]
instance [incoherent] SExpable a => SExpable (Maybe a)
instance [incoherent] SExpable Name
instance [incoherent] SExpable Int
instance [incoherent] SExpable Integer
instance [incoherent] SExpable String
instance [incoherent] SExpable Bool
instance [incoherent] SExpable SExp

module Idris.AbsSyntax
getContext :: Idris Context
forCodegen :: Codegen -> [(Codegen, a)] -> [a]
getObjectFiles :: Codegen -> Idris [FilePath]
addObjectFile :: Codegen -> FilePath -> Idris ()
getLibs :: Codegen -> Idris [String]
addLib :: Codegen -> String -> Idris ()
getFlags :: Codegen -> Idris [String]
addFlag :: Codegen -> String -> Idris ()
addDyLib :: [String] -> Idris (Either DynamicLib String)
getAutoImports :: Idris [FilePath]
addAutoImport :: FilePath -> Idris ()
addHdr :: Codegen -> String -> Idris ()
addImported :: Bool -> FilePath -> Idris ()
addLangExt :: LanguageExt -> Idris ()
addTrans :: Name -> (Term, Term) -> Idris ()
addErrRev :: (Term, Term) -> Idris ()
addErasureUsage :: Name -> Int -> Idris ()
addExport :: Name -> Idris ()
addUsedName :: FC -> Name -> Name -> Idris ()
getErasureUsage :: Idris [(Name, Int)]
getExports :: Idris [Name]
totcheck :: (FC, Name) -> Idris ()
defer_totcheck :: (FC, Name) -> Idris ()
clear_totcheck :: Idris ()
setFlags :: Name -> [FnOpt] -> Idris ()
setFnInfo :: Name -> FnInfo -> Idris ()
setAccessibility :: Name -> Accessibility -> Idris ()
setTotality :: Name -> Totality -> Idris ()
getTotality :: Name -> Idris Totality
getCoercionsTo :: IState -> Type -> [Name]
addToCG :: Name -> CGInfo -> Idris ()
addTyInferred :: Name -> Idris ()
addTyInfConstraints :: FC -> [(Term, Term)] -> Idris ()
isTyInferred :: Name -> Idris Bool

-- | Adds error handlers for a particular function and argument. If names
--   are ambiguous, all matching handlers are updated.
addFunctionErrorHandlers :: Name -> Name -> [Name] -> Idris ()
getFunctionErrorHandlers :: Name -> Name -> Idris [Name]
getAllNames :: Name -> Idris [Name]
allNames :: [Name] -> Name -> Idris [Name]
addCoercion :: Name -> Idris ()
addDocStr :: Name -> Docstring DocTerm -> [(Name, Docstring DocTerm)] -> Idris ()
addNameHint :: Name -> Name -> Idris ()
getNameHints :: IState -> Name -> [Name]
addToCalledG :: Name -> [Name] -> Idris ()
push_estack :: Name -> Bool -> Idris ()
pop_estack :: Idris ()

-- | Add a class instance function.
--   
--   Precondition: the instance should have the correct type.
--   
--   Dodgy hack 1: Put integer instances first in the list so they are
--   resolved by default.
--   
--   Dodgy hack 2: put constraint chasers (@@) last
addInstance :: Bool -> Bool -> Name -> Name -> Idris ()
addClass :: Name -> ClassInfo -> Idris ()
addAutoHint :: Name -> Name -> Idris ()
getAutoHints :: Name -> Idris [Name]
addIBC :: IBCWrite -> Idris ()
clearIBC :: Idris ()
resetNameIdx :: Idris ()
addNameIdx :: Name -> Idris (Int, Name)
addNameIdx' :: IState -> Name -> (IState, (Int, Name))
getSymbol :: Name -> Idris Name
getHdrs :: Codegen -> Idris [String]
getImported :: Idris [(FilePath, Bool)]
setErrSpan :: FC -> Idris ()
clearErr :: Idris ()
getSO :: Idris (Maybe String)
setSO :: Maybe String -> Idris ()
getIState :: Idris IState
putIState :: IState -> Idris ()
updateIState :: (IState -> IState) -> Idris ()
withContext :: (IState -> Ctxt a) -> Name -> b -> (a -> Idris b) -> Idris b
withContext_ :: (IState -> Ctxt a) -> Name -> (a -> Idris ()) -> Idris ()

-- | A version of liftIO that puts errors into the exception type of the
--   Idris monad
runIO :: IO a -> Idris a
getName :: Idris Int
addInternalApp :: FilePath -> Int -> PTerm -> Idris ()
getInternalApp :: FilePath -> Int -> Idris PTerm
clearOrigPats :: Idris ()
clearPTypes :: Idris ()
checkUndefined :: FC -> Name -> Idris ()
isUndefined :: FC -> Name -> Idris Bool
setContext :: Context -> Idris ()
updateContext :: (Context -> Context) -> Idris ()
addConstraints :: FC -> (Int, [UConstraint]) -> Idris ()
addDeferred :: [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()
addDeferredTyCon :: [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()

-- | Save information about a name that is not yet defined
addDeferred' :: NameType -> [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()
solveDeferred :: Name -> Idris ()
getUndefined :: Idris [Name]
isMetavarName :: Name -> IState -> Bool
getWidth :: Idris ConsoleWidth
setWidth :: ConsoleWidth -> Idris ()
type1Doc :: Doc OutputAnnotation
isetPrompt :: String -> Idris ()

-- | Tell clients how much was parsed and loaded
isetLoadedRegion :: Idris ()
setLogLevel :: Int -> Idris ()
setCmdLine :: [Opt] -> Idris ()
getCmdLine :: Idris [Opt]
getDumpDefun :: Idris (Maybe FilePath)
getDumpCases :: Idris (Maybe FilePath)
logLevel :: Idris Int
setErrContext :: Bool -> Idris ()
errContext :: Idris Bool
getOptimise :: Idris [Optimisation]
setOptimise :: [Optimisation] -> Idris ()
addOptimise :: Optimisation -> Idris ()
removeOptimise :: Optimisation -> Idris ()
setOptLevel :: Int -> Idris ()
useREPL :: Idris Bool
setREPL :: Bool -> Idris ()
showOrigErr :: Idris Bool
setShowOrigErr :: Bool -> Idris ()
setAutoSolve :: Bool -> Idris ()
setNoBanner :: Bool -> Idris ()
getNoBanner :: Idris Bool
setQuiet :: Bool -> Idris ()
getQuiet :: Idris Bool
setCodegen :: Codegen -> Idris ()
codegen :: Idris Codegen
setOutputTy :: OutputType -> Idris ()
outputTy :: Idris OutputType
setIdeMode :: Bool -> Handle -> Idris ()
setTargetTriple :: String -> Idris ()
targetTriple :: Idris String
setTargetCPU :: String -> Idris ()
targetCPU :: Idris String
verbose :: Idris Bool
setVerbose :: Bool -> Idris ()
typeInType :: Idris Bool
setTypeInType :: Bool -> Idris ()
coverage :: Idris Bool
setCoverage :: Bool -> Idris ()
setIBCSubDir :: FilePath -> Idris ()
valIBCSubDir :: IState -> Idris FilePath
addImportDir :: FilePath -> Idris ()
setImportDirs :: [FilePath] -> Idris ()
allImportDirs :: Idris [FilePath]
colourise :: Idris Bool
setColourise :: Bool -> Idris ()
impShow :: Idris Bool
setImpShow :: Bool -> Idris ()
setColour :: ColourType -> IdrisColour -> Idris ()
logLvl :: Int -> String -> Idris ()
cmdOptType :: Opt -> Idris Bool
iLOG :: String -> Idris ()
noErrors :: Idris Bool
setTypeCase :: Bool -> Idris ()
expandParams :: (Name -> Name) -> [(Name, PTerm)] -> [Name] -> [Name] -> PTerm -> PTerm
expandParamsD :: Bool -> IState -> (Name -> Name) -> [(Name, PTerm)] -> [Name] -> PDecl -> PDecl
mapsnd :: (t -> t2) -> (t1, t) -> (t1, t2)
getPriority :: IState -> PTerm -> Int
addStatics :: Name -> Term -> PTerm -> Idris ()
addToUsing :: [Using] -> [(Name, PTerm)] -> [Using]
addUsingConstraints :: SyntaxInfo -> FC -> PTerm -> Idris PTerm
addUsingImpls :: SyntaxInfo -> Name -> FC -> PTerm -> Idris PTerm
getUnboundImplicits :: IState -> Type -> PTerm -> [(Bool, PArg)]
implicit :: ElabInfo -> SyntaxInfo -> Name -> PTerm -> Idris PTerm
implicit' :: ElabInfo -> SyntaxInfo -> [Name] -> Name -> PTerm -> Idris PTerm
implicitise :: SyntaxInfo -> [Name] -> IState -> PTerm -> (PTerm, [PArg])
addImplPat :: IState -> PTerm -> PTerm
addImplBound :: IState -> [Name] -> PTerm -> PTerm
addImplBoundInf :: IState -> [Name] -> [Name] -> PTerm -> PTerm

-- | Add the implicit arguments to applications in the term [Name] gives
--   the names to always expend, even when under a binder of that name
--   (this is to expand methods with implicit arguments in dependent type
--   classes).
addImpl :: [Name] -> IState -> PTerm -> PTerm
addImpl' :: Bool -> [Name] -> [Name] -> [Name] -> IState -> PTerm -> PTerm
aiFn :: Bool -> Bool -> Bool -> [Name] -> IState -> FC -> Name -> FC -> [[Text]] -> [PArg] -> Either Err PTerm
impIn :: [PArg] -> PArg -> Bool
expArg :: PArg' t -> Bool
stripLinear :: IState -> PTerm -> PTerm

-- | Remove functions which aren't applied to anything, which must then be
--   resolved by unification. Assume names resolved and alternatives filled
--   in (so no ambiguity).
stripUnmatchable :: IState -> PTerm -> PTerm
mkPApp :: FC -> Int -> PTerm -> [PArg] -> PTerm
findStatics :: IState -> PTerm -> (PTerm, [Bool])
data EitherErr a b
LeftErr :: a -> EitherErr a b
RightOK :: b -> EitherErr a b
toEither :: EitherErr a b -> Either a b

-- | Syntactic match of a against b, returning pair of variables in a and
--   what they match. Returns the pair that failed if not a match.
matchClause :: IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
matchClause' :: Bool -> IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
substMatches :: [(Name, PTerm)] -> PTerm -> PTerm
substMatchesShadow :: [(Name, PTerm)] -> [Name] -> PTerm -> PTerm
substMatch :: Name -> PTerm -> PTerm -> PTerm
substMatchShadow :: Name -> [Name] -> PTerm -> PTerm -> PTerm
shadow :: Name -> Name -> PTerm -> PTerm
mkUniqueNames :: [Name] -> PTerm -> PTerm
instance Functor (EitherErr a)
instance Monad (EitherErr a)
instance Applicative (EitherErr a)

module Idris.Primitives
primitives :: [Prim]
data Prim
Prim :: Name -> Type -> Int -> ([Const] -> Maybe Const) -> (Int, PrimFn) -> Totality -> Prim
p_name :: Prim -> Name
p_type :: Prim -> Type
p_arity :: Prim -> Int
p_def :: Prim -> [Const] -> Maybe Const
p_lexp :: Prim -> (Int, PrimFn)
p_total :: Prim -> Totality

module Idris.DSL
debindApp :: SyntaxInfo -> PTerm -> PTerm
dslify :: SyntaxInfo -> IState -> PTerm -> PTerm
desugar :: SyntaxInfo -> IState -> PTerm -> PTerm
mkTTName :: FC -> Name -> PTerm
expandSugar :: DSL -> PTerm -> PTerm

-- | Replace DSL-bound variable in a term
var :: DSL -> Name -> PTerm -> Int -> PTerm
unIdiom :: PTerm -> PTerm -> FC -> PTerm -> PTerm
debind :: PTerm -> PTerm -> PTerm

module Idris.DataOpts
class Optimisable term
applyOpts :: Optimisable term => term -> Idris term
prel :: [Text]
applyDataOptRT :: Name -> Int -> Int -> Bool -> [Term] -> Term
instance Optimisable (TT Name)
instance Optimisable (Binder Raw)
instance Optimisable (Binder (TT Name))
instance Optimisable Raw
instance Optimisable a => Optimisable (Either a (a, a))
instance Optimisable a => Optimisable [a]
instance (Optimisable a, Optimisable b) => Optimisable (vs, a, b)
instance (Optimisable a, Optimisable b) => Optimisable (a, b)

module Idris.Inliner
inlineDef :: IState -> [([Name], Term, Term)] -> [([Name], Term, Term)]
inlineTerm :: IState -> Term -> Term

module Idris.Elab.AsPat

-- | Desugar by changing x@y on lhs to let x = y in ... or rhs
desugarAs :: PTerm -> PTerm -> (PTerm, PTerm)

module Idris.Transforms
transformPats :: IState -> [Either Term (Term, Term)] -> [Either Term (Term, Term)]
transformPatsWith :: [(Term, Term)] -> [Either Term (Term, Term)] -> [Either Term (Term, Term)]
applyTransRulesWith :: [(Term, Term)] -> Term -> Term
applyTransRules :: IState -> Term -> Term

module Idris.ErrReverse
errReverse :: IState -> Term -> Term

module Idris.Delaborate
annName :: Name -> Doc OutputAnnotation
bugaddr :: [Char]
delab :: IState -> Term -> PTerm
delab' :: IState -> Term -> Bool -> Bool -> PTerm
delabMV :: IState -> Term -> PTerm
delabTy :: IState -> Name -> PTerm
delabTy' :: IState -> [PArg] -> Term -> Bool -> Bool -> PTerm

-- | Add extra metadata to an output annotation, optionally marking
--   metavariables.
fancifyAnnots :: IState -> Bool -> OutputAnnotation -> OutputAnnotation

-- | Pretty-print a core term using delaboration
pprintDelab :: IState -> Term -> Doc OutputAnnotation

-- | Pretty-print the type of some name
pprintDelabTy :: IState -> Name -> Doc OutputAnnotation
pprintErr :: IState -> Err -> Doc OutputAnnotation

module Idris.PartialEval

-- | Partially evaluates given terms under the given context. It is an
--   error if partial evaluation fails to make any progress. Making
--   progress is defined as: all of the names given with explicit reduction
--   limits (in practice, the function being specialised) must have reduced
--   at least once. If we don't do this, we might end up making an infinite
--   function after applying the transformation.
partial_eval :: Context -> [(Name, Maybe Int)] -> [Either Term (Term, Term)] -> Maybe [Either Term (Term, Term)]

-- | Get specialised applications for a given function
getSpecApps :: IState -> [Name] -> Term -> [(Name, [(PEArgType, Term)])]

-- | Specialises the type of a partially evaluated TT function returning a
--   pair of the specialised type and the types of expected arguments.
specType :: [(PEArgType, Term)] -> Type -> (Type, [(PEArgType, Term)])

-- | Creates an Idris type declaration given current state and a
--   specialised TT function application type. Can be used in combination
--   with the output of <a>specType</a>.
--   
--   This should: specialise any static argument position, then generalise
--   over any function applications in the result.
mkPE_TyDecl :: IState -> [(PEArgType, Term)] -> Type -> PTerm

-- | Creates a new declaration for a specialised function application.
--   Simple version at the moment: just create a version which is a direct
--   application of the function to be specialised. More complex version to
--   do: specialise the definition clause by clause
mkPE_TermDecl :: IState -> Name -> Name -> [(PEArgType, Term)] -> PEDecl

-- | Data type representing binding-time annotations for partial evaluation
--   of arguments
data PEArgType

-- | Implicit static argument
ImplicitS :: PEArgType

-- | Implicit dynamic argument
ImplicitD :: PEArgType

-- | Explicit static argument
ExplicitS :: PEArgType

-- | Explicit dynamic argument
ExplicitD :: PEArgType

-- | Erasable dynamic argument (found under unification)
UnifiedD :: PEArgType
pe_app :: PEDecl -> PTerm
pe_def :: PEDecl -> PTerm
pe_clauses :: PEDecl -> [(PTerm, PTerm)]
pe_simple :: PEDecl -> Bool
instance Eq PEArgType
instance Show PEArgType


-- | Code related to Idris's reflection system. This module contains
--   quoters and unquoters along with some supporting datatypes.
module Idris.Reflection
data RArg
RExplicit :: Name -> Raw -> RArg
argName :: RArg -> Name
argTy :: RArg -> Raw
RImplicit :: Name -> Raw -> RArg
argName :: RArg -> Name
argTy :: RArg -> Raw
RConstraint :: Name -> Raw -> RArg
argName :: RArg -> Name
argTy :: RArg -> Raw
data RTyDecl
RDeclare :: Name -> [RArg] -> Raw -> RTyDecl
data RTyConArg
RParameter :: Name -> Raw -> RTyConArg
tcArgName :: RTyConArg -> Name
tcArgTy :: RTyConArg -> Raw
RIndex :: Name -> Raw -> RTyConArg
tcArgName :: RTyConArg -> Name
tcArgTy :: RTyConArg -> Raw
data RDatatype
RDatatype :: Name -> [RTyConArg] -> Raw -> [(Name, Raw)] -> RDatatype
rArgToPArg :: RArg -> PArg
data RFunClause
RMkFunClause :: Raw -> Raw -> RFunClause
RMkImpossibleClause :: Raw -> RFunClause
data RFunDefn
RDefineFun :: Name -> [RFunClause] -> RFunDefn

-- | Prefix a name with the <a>Language.Reflection</a> namespace
reflm :: String -> Name

-- | Prefix a name with the <a>Language.Reflection.Elab</a> namespace
tacN :: String -> Name

-- | Reify tactics from their reflected representation
reify :: IState -> Term -> ElabD PTactic
reifyApp :: IState -> Name -> [Term] -> ElabD PTactic
reifyReportParts :: Term -> ElabD [ErrorReportPart]

-- | Reify terms from their reflected representation
reifyTT :: Term -> ElabD Term
reifyTTApp :: Name -> [Term] -> ElabD Term

-- | Reify raw terms from their reflected representation
reifyRaw :: Term -> ElabD Raw
reifyRawApp :: Name -> [Term] -> ElabD Raw
reifyTTName :: Term -> ElabD Name
reifyTTNameApp :: Name -> [Term] -> ElabD Name
reifyTTNamespace :: Term -> ElabD [String]
reifyTTNameType :: Term -> ElabD NameType
reifyTTBinder :: (Term -> ElabD a) -> Name -> Term -> ElabD (Binder a)
reifyTTBinderApp :: (Term -> ElabD a) -> Name -> [Term] -> ElabD (Binder a)
reifyTTConst :: Term -> ElabD Const
reifyTTConstApp :: Name -> Term -> ElabD Const
reifyArithTy :: Term -> ElabD ArithTy
reifyNativeTy :: Term -> ElabD NativeTy
reifyIntTy :: Term -> ElabD IntTy
reifyTTUExp :: Term -> ElabD UExp

-- | Create a reflected call to a named function/constructor
reflCall :: String -> [Raw] -> Raw

-- | Lift a term into its Language.Reflection.TT representation
reflect :: Term -> Raw

-- | Lift a term into its Language.Reflection.Raw representation
reflectRaw :: Raw -> Raw
claimTT :: Name -> ElabD Name

-- | Convert a reflected term to a more suitable form for pattern-matching.
--   In particular, the less-interesting bits are elaborated to _ patterns.
--   This happens to NameTypes, universe levels, names that are bound but
--   not used, and the type annotation field of the P constructor.
reflectTTQuotePattern :: [Name] -> Term -> ElabD ()
reflectRawQuotePattern :: [Name] -> Raw -> ElabD ()
reflectBinderQuotePattern :: ([Name] -> a -> ElabD ()) -> [Name] -> Binder a -> ElabD ()
reflectUniverse :: Universe -> Raw

-- | Create a reflected TT term, but leave refs to the provided name intact
reflectTTQuote :: [Name] -> Term -> Raw
reflectRawQuote :: [Name] -> Raw -> Raw
reflectNameType :: NameType -> Raw
reflectName :: Name -> Raw
reflectSpecialName :: SpecialName -> Raw

-- | Elaborate a name to a pattern. This means that NS and UN will be
--   intact. MNs corresponding to will care about the string but not the
--   number. All others become _.
reflectNameQuotePattern :: Name -> ElabD ()
reflectBinder :: Binder Term -> Raw
reflectBinderQuote :: ([Name] -> a -> Raw) -> Name -> [Name] -> Binder a -> Raw
mkList :: Raw -> [Raw] -> Raw
reflectConstant :: Const -> Raw
reflectUExp :: UExp -> Raw

-- | Reflect the environment of a proof into a List (TTName, Binder TT)
reflectEnv :: Env -> Raw

-- | Reflect an error into the internal datatype of Idris -- TODO
rawBool :: Bool -> Raw
rawNil :: Raw -> Raw
rawCons :: Raw -> Raw -> Raw -> Raw
rawList :: Raw -> [Raw] -> Raw
rawPairTy :: Raw -> Raw -> Raw
rawPair :: (Raw, Raw) -> (Raw, Raw) -> Raw
reflectCtxt :: [(Name, Type)] -> Raw
reflectErr :: Err -> Raw

-- | Reflect a file context
reflectFC :: FC -> Raw
fromTTMaybe :: Term -> Maybe Term
reflErrName :: String -> Name

-- | Attempt to reify a report part from TT to the internal representation.
--   Not in Idris or ElabD monads because it should be usable from either.
reifyReportPart :: Term -> Either Err ErrorReportPart
reifyTyDecl :: Term -> ElabD RTyDecl
reifyFunDefn :: Term -> ElabD RFunDefn
envTupleType :: Raw

-- | Build the reflected datatype definition(s) that correspond(s) to a
--   provided unqualified name
buildDatatypes :: Context -> Ctxt TypeInfo -> Name -> [RDatatype]
reflectDatatype :: RDatatype -> Raw
instance Show RArg
instance Show RTyDecl
instance Show RTyConArg
instance Show RDatatype
instance Show RFunClause
instance Show RFunDefn

module Idris.ElabQuasiquote
extractUnquotes :: Int -> PTerm -> Elab' aux (PTerm, [(Name, PTerm)])

module Idris.REPL.Browse

-- | Find the sub-namespaces of a given namespace. The components should be
--   in display order rather than the order that they are in inside of NS
--   constructors.
namespacesInNS :: [String] -> Idris [[String]]

-- | Find the user-accessible names that occur directly within a given
--   namespace. The components should be in display order rather than the
--   order that they are in inside of NS constructors.
namesInNS :: [String] -> Idris [Name]

module Idris.Apropos

-- | Find definitions that are relevant to all space-delimited components
--   of some string. Relevance is one or more of the following:
--   
--   <ul>
--   <li>the string is a substring of the name</li>
--   <li>the string occurs in the documentation string</li>
--   <li>the type of the definition is apropos</li>
--   </ul>
apropos :: IState -> Text -> [Name]

-- | Find modules whose names or docstrings contain all the space-delimited
--   components of some string.
aproposModules :: IState -> Text -> [(String, Docstring DocTerm)]
instance Apropos a => Apropos [a]
instance Apropos a => Apropos (Maybe a)
instance (Apropos a, Apropos b) => Apropos (a, b)
instance Apropos (Docstring a)
instance Apropos Const
instance Apropos (TT Name)
instance Apropos (Binder (TT Name))
instance Apropos Def
instance Apropos Name

module Idris.Docs
pprintDocs :: IState -> Docs -> Doc OutputAnnotation

-- | Given a fully-qualified, disambiguated name, construct the
--   documentation object for it
getDocs :: Name -> HowMuchDocs -> Idris Docs
pprintConstDocs :: IState -> Const -> String -> Doc OutputAnnotation
type FunDoc = FunDoc' (Docstring DocTerm)
data FunDoc' d
FD :: Name -> d -> [(Name, PTerm, Plicity, Maybe d)] -> PTerm -> (Maybe Fixity) -> FunDoc' d
type Docs = Docs' (Docstring DocTerm)
data Docs' d
FunDoc :: (FunDoc' d) -> Docs' d
DataDoc :: (FunDoc' d) -> [FunDoc' d] -> Docs' d
ClassDoc :: Name -> d -> [FunDoc' d] -> [(Name, Maybe d)] -> [(Maybe Name, PTerm, (d, [(Name, d)]))] -> [PTerm] -> [PTerm] -> (Maybe (FunDoc' d)) -> Docs' d
NamedInstanceDoc :: Name -> (FunDoc' d) -> Docs' d
ModDoc :: [String] -> d -> Docs' d
instance Functor FunDoc'
instance Functor Docs'

module Idris.WhoCalls
whoCalls :: Name -> Idris [(Name, [Name])]
callsWho :: Name -> Idris [(Name, [Name])]

module IRTS.CodegenC
codegenC :: CodeGenerator

module IRTS.CodegenJavaScript
codegenJavaScript :: CodeGenerator
codegenNode :: CodeGenerator
data JSTarget
Node :: JSTarget
JavaScript :: JSTarget
instance Eq JSTarget

module Idris.Output
pshow :: IState -> Err -> String
iWarn :: FC -> Doc OutputAnnotation -> Idris ()
iRender :: Doc a -> Idris (SimpleDoc a)

-- | Write a pretty-printed term to the console with semantic coloring
consoleDisplayAnnotated :: Handle -> Doc OutputAnnotation -> Idris ()
iPrintTermWithType :: Doc OutputAnnotation -> Doc OutputAnnotation -> Idris ()

-- | Pretty-print a collection of overloadings to REPL or IDEMode -
--   corresponds to :t name
iPrintFunTypes :: [(Name, Bool)] -> Name -> [(Name, Doc OutputAnnotation)] -> Idris ()
iRenderOutput :: Doc OutputAnnotation -> Idris ()
iRenderResult :: Doc OutputAnnotation -> Idris ()
ideModeReturnWithStatus :: String -> Integer -> Handle -> Doc OutputAnnotation -> Idris ()

-- | Write pretty-printed output to IDEMode with semantic annotations
ideModeReturnAnnotated :: Integer -> Handle -> Doc OutputAnnotation -> Idris ()

-- | Show an error with semantic highlighting
iRenderError :: Doc OutputAnnotation -> Idris ()
iPrintWithStatus :: String -> String -> Idris ()
iPrintResult :: String -> Idris ()
iPrintError :: String -> Idris ()
iputStrLn :: String -> Idris ()
idemodePutSExp :: SExpable a => String -> a -> Idris ()
iputGoal :: SimpleDoc OutputAnnotation -> Idris ()

-- | Warn about totality problems without failing to compile
warnTotality :: Idris ()
printUndefinedNames :: [Name] -> Doc OutputAnnotation
prettyDocumentedIst :: IState -> (Name, PTerm, Maybe (Docstring DocTerm)) -> Doc OutputAnnotation
sendHighlighting :: [(FC, OutputAnnotation)] -> Idris ()
renderExternal :: OutputFmt -> Int -> Doc OutputAnnotation -> Idris String
instance MonadException m => MonadException (ExceptT Err m)

module Idris.Error
iucheck :: Idris ()
showErr :: Err -> Idris String
report :: IOError -> String
idrisCatch :: Idris a -> (Err -> Idris a) -> Idris a
setAndReport :: Err -> Idris ()
ifail :: String -> Idris a
ierror :: Err -> Idris a
tclift :: TC a -> Idris a
tctry :: TC a -> TC a -> Idris a
getErrSpan :: Err -> FC

-- | Issue a warning on "with"-terms whose namespace is empty or
--   nonexistent
warnDisamb :: IState -> PTerm -> Idris ()

module Idris.Core.Execute
execute :: Term -> Idris Term

module Idris.Elab.Utils
recheckC :: FC -> (Err' (TT Name) -> Err) -> Env -> TT Name -> StateT IState (ExceptT Err IO) (Term, Type)
recheckC_borrowing :: Bool -> [Name] -> FC -> (Err' (TT Name) -> Err) -> Env -> TT Name -> StateT IState (ExceptT Err IO) (Term, Type)
iderr :: Name -> Err -> Err
checkDef :: FC -> (Name -> Err -> Err) -> [(Name, (Int, Maybe Name, Type))] -> Idris [(Name, (Int, Maybe Name, Type))]
checkAddDef :: Bool -> Bool -> FC -> (Name -> Err -> Err) -> [(Name, (Int, Maybe Name, Type))] -> Idris [(Name, (Int, Maybe Name, Type))]

-- | Get the list of (index, name) of inaccessible arguments from an
--   elaborated type
inaccessibleImps :: Int -> Type -> [Bool] -> [(Int, Name)]

-- | Get the list of (index, name) of inaccessible arguments from the type.
inaccessibleArgs :: Int -> PTerm -> [(Int, Name)]
elabCaseBlock :: ElabInfo -> FnOpts -> PDecl -> Idris ()

-- | Check that the result of type checking matches what the programmer
--   wrote (i.e. - if we inferred any arguments that the user provided,
--   make sure they are the same!)
checkInferred :: FC -> PTerm -> PTerm -> Idris ()

-- | Return whether inferred term is different from given term (as above,
--   but return a Bool)
inferredDiff :: FC -> PTerm -> PTerm -> Idris Bool

-- | Check a PTerm against documentation and ensure that every documented
--   argument actually exists. This must be run _after_ implicits have been
--   found, or it will give spurious errors.
checkDocs :: FC -> [(Name, Docstring a)] -> PTerm -> Idris ()
decorateid :: (Name -> Name) -> PDecl' PTerm -> PDecl' PTerm
pbinds :: IState -> Term -> ElabD ()
pbty :: TT n -> TT n -> TT n
getPBtys :: TT t -> [(t, TT t)]
psolve :: TT t -> StateT (ElabState aux) TC ()
pvars :: IState -> TT Name -> [(Name, PTerm)]
getFixedInType :: IState -> [Name] -> [PArg' t] -> TT Name -> [Name]
getFlexInType :: IState -> [Name] -> [Name] -> TT Name -> [Name]

-- | Treat a name as a parameter if it appears in parameter positions in
--   types, and never in a non-parameter position in a (non-param) argument
--   type.
getParamsInType :: IState -> [Name] -> [PArg] -> Type -> [Name]
paramNames :: Eq t => [TT t] -> [t] -> [Int] -> [t]
getUniqueUsed :: Context -> Term -> [Name]
getStaticNames :: IState -> Term -> [Name]
getStatics :: [Name] -> Term -> [Bool]
mkStatic :: [Name] -> PDecl -> PDecl
mkStaticTy :: [Name] -> PTerm -> PTerm

module Idris.Imports
data IFileType
IDR :: FilePath -> IFileType
LIDR :: FilePath -> IFileType
IBC :: FilePath -> IFileType -> IFileType

-- | Get the index file name for a package name
pkgIndex :: String -> FilePath
srcPath :: FilePath -> FilePath
lsrcPath :: FilePath -> FilePath
ibcPath :: FilePath -> Bool -> FilePath -> FilePath
ibcPathWithFallback :: FilePath -> FilePath -> IO FilePath
ibcPathNoFallback :: FilePath -> FilePath -> FilePath
findImport :: [FilePath] -> FilePath -> FilePath -> Idris IFileType
findInPath :: [FilePath] -> FilePath -> IO FilePath
findPkgIndex :: String -> Idris FilePath
installedPackages :: IO [String]
doesFileExist' :: FilePath -> IO Bool
doesDirectoryExist' :: FilePath -> IO Bool
caseSensitive :: (FilePath -> IO Bool) -> FilePath -> IO Bool
instance Show IFileType
instance Eq IFileType

module Idris.Directives

-- | Run the action corresponding to a directive
directiveAction :: Directive -> Idris ()
disambiguate :: Name -> Idris Name

module Idris.Providers

-- | Wrap a type provider in the type of type providers
providerTy :: FC -> PTerm -> PTerm

-- | Handle an error, if the type provider returned an error. Otherwise
--   return the provided term.
getProvided :: FC -> TT Name -> Idris (Provided (TT Name))
data Provided a
Provide :: a -> Provided a
instance Show a => Show (Provided a)
instance Eq a => Eq (Provided a)
instance Functor Provided

module Idris.ProofSearch
trivial :: (PTerm -> ElabD ()) -> IState -> ElabD ()
trivialHoles :: [(Name, Int)] -> (PTerm -> ElabD ()) -> IState -> ElabD ()
proofSearch :: Bool -> Bool -> Bool -> Bool -> Int -> (PTerm -> ElabD ()) -> Maybe Name -> Name -> [Name] -> IState -> ElabD ()

module Idris.Erasure
performUsageAnalysis :: [Name] -> Idris [Name]
mkFieldName :: Name -> Int -> Name
instance Eq Arg
instance Ord Arg
instance Show VarInfo
instance Show Arg

module IRTS.Exports
findExports :: Idris [ExportIFace]
getExpNames :: [ExportIFace] -> [Name]

module IRTS.Compiler

-- | Given a <tt>main</tt> term to compiler, return the IRs which can be
--   used to generate code.
compile :: Codegen -> FilePath -> Maybe Term -> Idris CodegenInfo
generate :: Codegen -> FilePath -> CodegenInfo -> IO ()
instance Show VarInfo


-- | The coverage and totality checkers for Idris are in this module.
module Idris.Coverage

-- | Generate a pattern from an <tt>impossible</tt> LHS.
--   
--   We need this to eliminate the pattern clauses which have been provided
--   explicitly from new clause generation.
mkPatTm :: PTerm -> Idris Term

-- | Given a list of LHSs, generate a extra clauses which cover the
--   remaining cases. The ones which haven't been provided are marked
--   <tt>absurd</tt> so that the checker will make sure they can't happen.
--   
--   This will only work after the given clauses have been typechecked and
--   the names are fully explicit!
genClauses :: FC -> Name -> [Term] -> [PTerm] -> Idris [PTerm]

-- | Does this error result rule out a case as valid when coverage
--   checking?
validCoverageCase :: Context -> Err -> Bool

-- | Check whether an error is recoverable in the sense needed for coverage
--   checking.
recoverableCoverage :: Context -> Err -> Bool
genAll :: IState -> [PTerm] -> [PTerm]
upd :: t -> PArg' t -> PArg' t
checkAllCovering :: FC -> [Name] -> Name -> Name -> Idris ()
checkPositive :: [Name] -> (Name, Type) -> Idris Totality
calcProd :: IState -> FC -> Name -> [([Name], Term, Term)] -> Idris Totality

-- | Calculate the totality of a function from its patterns. Either follow
--   the size change graph (if inductive) or check for productivity (if
--   coinductive)
calcTotality :: FC -> Name -> [([Name], Term, Term)] -> Idris Totality
checkTotality :: [Name] -> FC -> Name -> Idris Totality
checkDeclTotality :: (FC, Name) -> Idris Totality

-- | Calculate the size change graph for this definition
--   
--   SCG for a function f consists of a list of: (g, [(a1, sizechange1),
--   (a2, sizechange2), ..., (an, sizechangen)])
--   
--   where g is a function called a1 ... an are the arguments of f in
--   positions 1..n of g sizechange1 ... sizechange2 is how their size has
--   changed wrt the input to f Nothing, if the argument is unrelated to
--   the input
buildSCG :: (FC, Name) -> Idris ()
delazy :: TT Name -> TT Name
delazy' :: Bool -> TT Name -> TT Name
data Guardedness
Toplevel :: Guardedness
Unguarded :: Guardedness
Guarded :: Guardedness
buildSCG' :: IState -> [(Term, Term)] -> [Name] -> [SCGEntry]
checkSizeChange :: Name -> Idris Totality
type MultiPath = [SCGEntry]
mkMultiPaths :: IState -> MultiPath -> [SCGEntry] -> [MultiPath]
checkMP :: IState -> Int -> MultiPath -> Totality
allNothing :: [Maybe a] -> Bool
collapseNothing :: [(Maybe a, b)] -> [(Maybe a, b)]
noPartial :: [Totality] -> Totality
collapse :: [Totality] -> Totality
collapse' :: Totality -> [Totality] -> Totality
instance Show Guardedness

module Idris.Elab.Term
data ElabMode
ETyDecl :: ElabMode
ELHS :: ElabMode
ERHS :: ElabMode
data ElabResult
ElabResult :: Term -> [(Name, (Int, Maybe Name, Type))] -> [PDecl] -> Context -> [RDeclInstructions] -> [(FC, OutputAnnotation)] -> ElabResult

-- | The term resulting from elaboration
resultTerm :: ElabResult -> Term

-- | Information about new metavariables
resultMetavars :: ElabResult -> [(Name, (Int, Maybe Name, Type))]

-- | Deferred declarations as the meaning of case blocks
resultCaseDecls :: ElabResult -> [PDecl]

-- | The potentially extended context from new definitions
resultContext :: ElabResult -> Context

-- | Meta-info about the new type declarations
resultTyDecls :: ElabResult -> [RDeclInstructions]
resultHighlighting :: ElabResult -> [(FC, OutputAnnotation)]
build :: IState -> ElabInfo -> ElabMode -> FnOpts -> Name -> PTerm -> ElabD ElabResult
buildTC :: IState -> ElabInfo -> ElabMode -> FnOpts -> Name -> PTerm -> ElabD ElabResult
getUnmatchable :: Context -> Name -> [Bool]
data ElabCtxt
ElabCtxt :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ElabCtxt
e_inarg :: ElabCtxt -> Bool

-- | Function part of application
e_isfn :: ElabCtxt -> Bool
e_guarded :: ElabCtxt -> Bool
e_intype :: ElabCtxt -> Bool
e_qq :: ElabCtxt -> Bool

-- | can't pattern match
e_nomatching :: ElabCtxt -> Bool
initElabCtxt :: ElabCtxt
goal_polymorphic :: ElabD Bool

-- | Returns the set of declarations we need to add to complete the
--   definition (most likely case blocks to elaborate) as well as
--   declarations resulting from user tactic scripts (%runElab)
elab :: IState -> ElabInfo -> ElabMode -> FnOpts -> Name -> PTerm -> ElabD ()
pruneAlt :: [PTerm] -> [PTerm]
pruneByType :: [Name] -> Term -> Context -> [PTerm] -> [PTerm]

-- | Use the local elab context to work out the highlighting for a name
findHighlight :: Name -> ElabD OutputAnnotation

-- | Find the names of instances that have been designeated for searching
--   (i.e. non-named instances or instances from Elab scripts)
findInstances :: IState -> Term -> [Name]
solveAuto :: IState -> Name -> Bool -> Name -> ElabD ()
solveAutos :: IState -> Name -> Bool -> ElabD ()
trivial' :: IState -> ElabD ()
trivialHoles' :: [(Name, Int)] -> IState -> ElabD ()
proofSearch' :: IState -> Bool -> Bool -> Int -> Bool -> Maybe Name -> Name -> [Name] -> StateT (ElabState EState) TC ()

-- | Resolve type classes. This will only pick up <tt>normal</tt>
--   instances, never named instances (which is enforced by
--   <a>findInstances</a>).
resolveTC :: Bool -> Bool -> Int -> Term -> Name -> IState -> ElabD ()
resTC' :: (Num a, Eq a) => [TT Name] -> Bool -> [Name] -> a -> Term -> Name -> IState -> StateT (ElabState EState) TC ()
collectDeferred :: Maybe Name -> [Name] -> Context -> Term -> State [(Name, (Int, Maybe Name, Type))] Term
case_ :: Bool -> Bool -> IState -> Name -> PTerm -> ElabD ()
runTactical :: IState -> FC -> Env -> Term -> ElabD ()
runTac :: Bool -> IState -> Maybe FC -> Name -> PTactic -> ElabD ()
elaboratingArgErr :: [(Name, Name)] -> Err -> Err
withErrorReflection :: Idris a -> Idris a
solveAll :: Elab' aux ()

-- | Do the left-over work after creating declarations in reflected
--   elaborator scripts
processTacticDecls :: ElabInfo -> [RDeclInstructions] -> Idris ()
instance Eq ElabMode

module Idris.Elab.Value
elabVal :: ElabInfo -> ElabMode -> PTerm -> Idris (Term, Type)
elabValBind :: ElabInfo -> ElabMode -> Bool -> PTerm -> Idris (Term, Type, [(Name, Type)])
elabDocTerms :: ElabInfo -> Docstring (Either Err PTerm) -> Idris (Docstring DocTerm)
elabExec :: FC -> PTerm -> PTerm

module Idris.Elab.Type
buildType :: ElabInfo -> SyntaxInfo -> FC -> FnOpts -> Name -> PTerm -> Idris (Type, Type, PTerm, [(Int, Name)])

-- | Elaborate a top-level type declaration - for example, "foo : Int -&gt;
--   Int".
elabType :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> [(Name, Docstring (Either Err PTerm))] -> FC -> FnOpts -> Name -> FC -> PTerm -> Idris Type
elabType' :: Bool -> ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> [(Name, Docstring (Either Err PTerm))] -> FC -> FnOpts -> Name -> FC -> PTerm -> Idris Type
elabPostulate :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> FC -> FnOpts -> Name -> PTerm -> Idris ()
elabExtern :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> FC -> FnOpts -> Name -> PTerm -> Idris ()

module Idris.Elab.Transform
elabTransform :: ElabInfo -> FC -> Bool -> PTerm -> PTerm -> Idris (Term, Term)

module Idris.Elab.Clause

-- | Elaborate a collection of left-hand and right-hand pairs - that is, a
--   top-level definition.
elabClauses :: ElabInfo -> FC -> FnOpts -> Name -> [PClause] -> Idris ()

-- | Find <tt>static</tt> applications in a term and partially evaluate
--   them. Return any new transformation rules
elabPE :: ElabInfo -> FC -> Name -> Term -> Idris [(Term, Term)]

-- | Checks if the clause is a possible left hand side.
checkPossible :: ElabInfo -> FC -> Bool -> Name -> PTerm -> Idris Bool
propagateParams :: IState -> [Name] -> Type -> PTerm -> PTerm
findUnique :: Context -> Env -> Term -> [Name]
elabClause :: ElabInfo -> FnOpts -> (Int, PClause) -> Idris (Either Term (Term, Term), PTerm)

module Idris.Elab.Data
elabData :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> [(Name, Docstring (Either Err PTerm))] -> FC -> DataOpts -> PData -> Idris ()

module Idris.Elab.Class
elabClass :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> FC -> [(Name, PTerm)] -> Name -> FC -> [(Name, FC, PTerm)] -> [(Name, Docstring (Either Err PTerm))] -> [(Name, FC)] -> [PDecl] -> Maybe (Name, FC) -> Docstring (Either Err PTerm) -> Idris ()
instance Show MArgTy

module Idris.Elab.Instance
elabInstance :: ElabInfo -> SyntaxInfo -> Docstring (Either Err PTerm) -> [(Name, Docstring (Either Err PTerm))] -> ElabWhat -> FC -> [(Name, PTerm)] -> Name -> FC -> [PTerm] -> PTerm -> Maybe Name -> [PDecl] -> Idris ()

module Idris.Elab.Provider

-- | Elaborate a type provider
elabProvider :: Docstring (Either Err PTerm) -> ElabInfo -> SyntaxInfo -> FC -> ProvideWhat -> Name -> Idris ()

module Idris.ParseHelpers

-- | Idris parser with state used during parsing
type IdrisParser = StateT IState IdrisInnerParser
newtype IdrisInnerParser a
IdrisInnerParser :: Parser a -> IdrisInnerParser a
runInnerParser :: IdrisInnerParser a -> Parser a

-- | Generalized monadic parsing constraint type
type MonadicParsing m = (DeltaParsing m, LookAheadParsing m, TokenParsing m, Monad m)
class HasLastTokenSpan m
getLastTokenSpan :: HasLastTokenSpan m => m (Maybe FC)

-- | Helper to run Idris inner parser based stateT parsers
runparser :: StateT st IdrisInnerParser res -> st -> String -> String -> Result res
noDocCommentHere :: String -> IdrisParser ()
clearParserWarnings :: Idris ()
reportParserWarnings :: Idris ()

-- | Consumes any simple whitespace (any character which satisfies
--   Char.isSpace)
simpleWhiteSpace :: MonadicParsing m => m ()

-- | Checks if a charcter is end of line
isEol :: Char -> Bool

-- | A parser that succeeds at the end of the line
eol :: MonadicParsing m => m ()

-- | Consumes a single-line comment
--   
--   <pre>
--   SingleLineComment_t ::= '--' ~EOL_t* EOL_t ;
--   </pre>
singleLineComment :: MonadicParsing m => m ()

-- | Consumes a multi-line comment
--   
--   <pre>
--   MultiLineComment_t ::=
--      '{ -- }'
--    | '{ -' InCommentChars_t
--   ;
--   </pre>
--   
--   <pre>
--   InCommentChars_t ::=
--    '- }'
--    | MultiLineComment_t InCommentChars_t
--    | ~'- }'+ InCommentChars_t
--   ;
--   </pre>
multiLineComment :: MonadicParsing m => m ()

-- | Parses a documentation comment
--   
--   <pre>
--   DocComment_t ::=   <tt>|||</tt> ~EOL_t* EOL_t
--                  ;
--   </pre>
docComment :: IdrisParser (Docstring (), [(Name, Docstring ())])

-- | Parses some white space
whiteSpace :: MonadicParsing m => m ()

-- | Parses a string literal
stringLiteral :: (MonadicParsing m, HasLastTokenSpan m) => m (String, FC)

-- | Parses a char literal
charLiteral :: (MonadicParsing m, HasLastTokenSpan m) => m (Char, FC)

-- | Parses a natural number
natural :: (MonadicParsing m, HasLastTokenSpan m) => m (Integer, FC)

-- | Parses an integral number
integer :: MonadicParsing m => m Integer

-- | Parses a floating point number
float :: (MonadicParsing m, HasLastTokenSpan m) => m (Double, FC)

-- | Idris Style for parsing identifiers/reserved keywords
idrisStyle :: MonadicParsing m => IdentifierStyle m
char :: MonadicParsing m => Char -> m Char
string :: MonadicParsing m => String -> m String

-- | Parses a character as a token
lchar :: MonadicParsing m => Char -> m Char

-- | Parses string as a token
symbol :: MonadicParsing m => String -> m String

-- | Parses a reserved identifier
reserved :: MonadicParsing m => String -> m ()

-- | Parses a reserved identifier, computing its span. Assumes that
--   reserved identifiers never contain line breaks.
reservedFC :: MonadicParsing m => String -> m FC

-- | Parses a reserved operator
reservedOp :: MonadicParsing m => String -> m ()
reservedOpFC :: MonadicParsing m => String -> m FC

-- | Parses an identifier as a token
identifier :: MonadicParsing m => m (String, FC)

-- | Parses an identifier with possible namespace as a name
iName :: (MonadicParsing m, HasLastTokenSpan m) => [String] -> m (Name, FC)

-- | Parses an string possibly prefixed by a namespace
maybeWithNS :: (MonadicParsing m, HasLastTokenSpan m) => m (String, FC) -> Bool -> [String] -> m (Name, FC)

-- | Parses a name
name :: IdrisParser (Name, FC)

-- | List of all initial segments in ascending order of a list. Every such
--   initial segment ends right before an element satisfying the given
--   condition.
initsEndAt :: (a -> Bool) -> [a] -> [[a]]

-- | Create a <a>Name</a> from a pair of strings representing a base name
--   and its namespace.
mkName :: (String, String) -> Name
opChars :: String
operatorLetter :: MonadicParsing m => m Char
commentMarkers :: [String]
invalidOperators :: [String]

-- | Parses an operator
operator :: MonadicParsing m => m String

-- | Parses an operator
operatorFC :: MonadicParsing m => m (String, FC)

-- | Get filename from position (returns "(interactive)" when no source
--   file is given)
fileName :: Delta -> String

-- | Get line number from position
lineNum :: Delta -> Int

-- | Get column number from position
columnNum :: Delta -> Int

-- | Get file position as FC
getFC :: MonadicParsing m => m FC

-- | Bind constraints to term
bindList :: (Name -> FC -> PTerm -> PTerm -> PTerm) -> [(Name, FC, PTerm)] -> PTerm -> PTerm

-- | Push indentation to stack
pushIndent :: IdrisParser ()

-- | Pops indentation from stack
popIndent :: IdrisParser ()

-- | Gets current indentation
indent :: IdrisParser Int

-- | Gets last indentation
lastIndent :: IdrisParser Int

-- | Applies parser in an indented position
indented :: IdrisParser a -> IdrisParser a

-- | Applies parser to get a block (which has possibly indented statements)
indentedBlock :: IdrisParser a -> IdrisParser [a]

-- | Applies parser to get a block with at least one statement (which has
--   possibly indented statements)
indentedBlock1 :: IdrisParser a -> IdrisParser [a]

-- | Applies parser to get a block with exactly one (possibly indented)
--   statement
indentedBlockS :: IdrisParser a -> IdrisParser a

-- | Checks if the following character matches provided parser
lookAheadMatches :: MonadicParsing m => m a -> m Bool

-- | Parses a start of block
openBlock :: IdrisParser ()

-- | Parses an end of block
closeBlock :: IdrisParser ()

-- | Parses a terminator
terminator :: IdrisParser ()

-- | Parses and keeps a terminator
keepTerminator :: IdrisParser ()

-- | Checks if application expression does not end
notEndApp :: IdrisParser ()

-- | Checks that it is not end of block
notEndBlock :: IdrisParser ()

-- | Representation of an operation that can compare the current
--   indentation with the last indentation, and an error message if it
--   fails
data IndentProperty
IndentProperty :: (Int -> Int -> Bool) -> String -> IndentProperty

-- | Allows comparison of indent, and fails if property doesn't hold
indentPropHolds :: IndentProperty -> IdrisParser ()

-- | Greater-than indent property
gtProp :: IndentProperty

-- | Greater-than or equal to indent property
gteProp :: IndentProperty

-- | Equal indent property
eqProp :: IndentProperty

-- | Less-than indent property
ltProp :: IndentProperty

-- | Less-than or equal to indent property
lteProp :: IndentProperty

-- | Checks that there are no braces that are not closed
notOpenBraces :: IdrisParser ()

-- | Parses an accessibilty modifier (e.g. public, private)
accessibility :: IdrisParser Accessibility

-- | Adds accessibility option for function
addAcc :: Name -> Maybe Accessibility -> IdrisParser ()

-- | Add accessbility option for data declarations (works for classes too -
--   <tt>abstract</tt> means the data/class is visible but members not)
accData :: Maybe Accessibility -> Name -> [Name] -> IdrisParser ()

-- | Error message with possible fixes list
fixErrorMsg :: String -> [String] -> String

-- | Collect <a>PClauses</a> with the same function name
collect :: [PDecl] -> [PDecl]
instance [overlap ok] Parsing IdrisInnerParser
instance [overlap ok] Monad IdrisInnerParser
instance [overlap ok] Functor IdrisInnerParser
instance [overlap ok] MonadPlus IdrisInnerParser
instance [overlap ok] Applicative IdrisInnerParser
instance [overlap ok] Alternative IdrisInnerParser
instance [overlap ok] CharParsing IdrisInnerParser
instance [overlap ok] LookAheadParsing IdrisInnerParser
instance [overlap ok] DeltaParsing IdrisInnerParser
instance [overlap ok] MarkParsing Delta IdrisInnerParser
instance [overlap ok] Monoid a => Monoid (IdrisInnerParser a)
instance [overlap ok] TokenParsing IdrisInnerParser
instance [overlap ok] HasLastTokenSpan IdrisParser
instance [overlap ok] TokenParsing IdrisParser


-- | Generation of HTML documentation for Idris code
module Idris.IdrisDoc

-- | Generates HTML documentation for a series of loaded namespaces and
--   their dependencies.
generateDocs :: IState -> [Name] -> FilePath -> IO (Either String ())

module Idris.ParseOps

-- | Creates table for fixity declarations to build expression parser using
--   pre-build and user-defined operator/fixity declarations
table :: [FixDecl] -> OperatorTable IdrisParser PTerm

-- | Calculates table for fixity declarations
toTable :: [FixDecl] -> OperatorTable IdrisParser PTerm

-- | Binary operator
binary :: String -> (FC -> PTerm -> PTerm -> PTerm) -> Assoc -> Operator IdrisParser PTerm

-- | Prefix operator
prefix :: String -> (FC -> PTerm -> PTerm) -> Operator IdrisParser PTerm

-- | Backtick operator
backtick :: Operator IdrisParser PTerm

-- | Operator without fixity (throws an error)
nofixityoperator :: Operator IdrisParser PTerm

-- | Parses an operator in function position i.e. enclosed by `()', with an
--   optional namespace
--   
--   <pre>
--   OperatorFront ::=
--     '(' '=' ')'
--     | (Identifier_t <a>.</a>)? '(' Operator_t ')'
--     ;
--   </pre>
operatorFront :: IdrisParser (Name, FC)

-- | Parses a function (either normal name or operator)
--   
--   <pre>
--   FnName ::= Name | OperatorFront;
--   </pre>
fnName :: IdrisParser (Name, FC)

-- | Parses a fixity declaration <tt> Fixity ::= FixityType Natural_t
--   OperatorList Terminator ; </tt>
fixity :: IdrisParser PDecl

-- | Parses a fixity declaration type (i.e. infix or prefix, associtavity)
--   <tt> FixityType ::= 'infixl' | 'infixr' | 'infix' | <a>prefix</a> ;
--   </tt>
fixityType :: IdrisParser (Int -> Fixity)

module Idris.ParseExpr

-- | Allow implicit type declarations
allowImp :: SyntaxInfo -> SyntaxInfo

-- | Disallow implicit type declarations
disallowImp :: SyntaxInfo -> SyntaxInfo

-- | Parses an expression as a whole <tt> FullExpr ::= Expr EOF_t; </tt>
fullExpr :: SyntaxInfo -> IdrisParser PTerm
tryFullExpr :: SyntaxInfo -> IState -> String -> Either Err PTerm

-- | Parses an expression <tt> Expr ::= Pi </tt>
expr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an expression with possible operator applied <tt> OpExpr ::= ;
--   </tt>
opExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses either an internally defined expression or a user-defined one
--   <tt> Expr' ::= "External (User-defined) Syntax" | InternalExpr; </tt>
expr' :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a user-defined expression
externalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a simple user-defined expression
simpleExternalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Tries to parse a user-defined expression given a list of syntactic
--   extensions
extensions :: SyntaxInfo -> [Syntax] -> IdrisParser PTerm
data SynMatch
SynTm :: PTerm -> SynMatch
SynBind :: Name -> SynMatch
extension :: SyntaxInfo -> [Maybe (Name, SynMatch)] -> [Syntax] -> IdrisParser PTerm

-- | Parses a (normal) built-in expression <tt> InternalExpr ::= UnifyLog |
--   RecordType | SimpleExpr | Lambda | QuoteGoal | Let | If | RewriteTerm
--   | CaseExpr | DoBlock | App ; </tt>
internalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses the "impossible" keyword <tt> Impossible ::= <a>impossible</a>
--   </tt>
impossible :: IdrisParser PTerm

-- | Parses a case expression <tt> CaseExpr ::= 'case' Expr 'of' OpenBlock
--   CaseOption+ CloseBlock; </tt>
caseExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a case in a case expression <tt> CaseOption ::= Expr
--   (Impossible | '=&gt;' Expr) Terminator ; </tt>
caseOption :: SyntaxInfo -> IdrisParser (PTerm, PTerm)

-- | Parses a proof block <tt> ProofExpr ::= <tt>proof</tt> OpenBlock
--   Tactic'* CloseBlock ; </tt>
proofExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a tactics block <tt> TacticsExpr := <a>tactics</a> OpenBlock
--   Tactic'* CloseBlock ; </tt>
tacticsExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a simple expression @ SimpleExpr ::=
--   
--   | <tt>?</tt> Name | % 'instance' | <tt>Refl</tt> ('{' Expr '}')? |
--   ProofExpr | TacticsExpr | FnName | Idiom | List | Alt | Bracketed |
--   Constant | Type | <tt>Void</tt> | Quasiquote | NameQuote | Unquote |
--   '_' ; @
simpleExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an expression in braces <tt> Bracketed ::= '(' Bracketed' </tt>
bracketed :: SyntaxInfo -> IdrisParser PTerm

-- | Parses the rest of an expression in braces <tt> Bracketed' ::= ')' |
--   Expr ')' | ExprList ')' | Expr <a>**</a> Expr ')' | Operator Expr ')'
--   | Expr Operator ')' | Name <tt>:</tt> Expr <a>**</a> Expr ')' ; </tt>
bracketed' :: FC -> SyntaxInfo -> IdrisParser PTerm
bracketedExpr :: SyntaxInfo -> PTerm -> IdrisParser PTerm

-- | Finds optimal type for integer constant
modifyConst :: SyntaxInfo -> FC -> PTerm -> PTerm

-- | Parses an alternative expression @ Alt ::= '(|' Expr_List '|)';
--   
--   Expr_List ::= Expr' | Expr' ',' Expr_List ; @
alt :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a possibly hidden simple expression <tt> HSimpleExpr ::=
--   <a>.</a> SimpleExpr | SimpleExpr ; </tt>
hsimpleExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a unification log expression UnifyLog ::= <tt>%</tt>
--   <a>unifyLog</a> SimpleExpr ;
unifyLog :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a new-style tactics expression RunTactics ::= <tt>%</tt>
--   <a>runElab</a> SimpleExpr ;
runElab :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a disambiguation expression Disamb ::= <tt>%</tt> <a>disamb</a>
--   NameList Expr ;
disamb :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a no implicits expression <tt> NoImplicits ::= <tt>%</tt>
--   <a>noImplicits</a> SimpleExpr ; </tt>
noImplicits :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a function application expression <tt> App ::=
--   <tt>mkForeign</tt> Arg Arg* | MatchApp | SimpleExpr Arg* ; MatchApp
--   ::= SimpleExpr <tt>&lt;==</tt> FnName ; </tt>
app :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a function argument <tt> Arg ::= ImplicitArg | ConstraintArg |
--   SimpleExpr ; </tt>
arg :: SyntaxInfo -> IdrisParser PArg

-- | Parses an implicit function argument <tt> ImplicitArg ::= '{' Name
--   ('=' Expr)? '}' ; </tt>
implicitArg :: SyntaxInfo -> IdrisParser PArg

-- | Parses a constraint argument (for selecting a named type class
--   instance)
--   
--   <pre>
--   ConstraintArg ::=
--     '@{' Expr '}'
--     ;
--   </pre>
constraintArg :: SyntaxInfo -> IdrisParser PArg

-- | Parses a quasiquote expression (for building reflected terms using the
--   elaborator)
--   
--   <pre>
--   Quasiquote ::= '`(' Expr ')'
--   </pre>
quasiquote :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an unquoting inside a quasiquotation (for building reflected
--   terms using the elaborator)
--   
--   <pre>
--   Unquote ::= ',' Expr
--   </pre>
unquote :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a quotation of a name (for using the elaborator to resolve
--   boring details)
--   
--   <pre>
--   NameQuote ::= '`{' Name '}'
--   </pre>
namequote :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a record field setter expression <tt> RecordType ::=
--   <tt>record</tt> '{' FieldTypeList '}'; </tt> <tt> FieldTypeList ::=
--   FieldType | FieldType ',' FieldTypeList ; </tt> <tt> FieldType ::=
--   FnName '=' Expr ; </tt>
recordType :: SyntaxInfo -> IdrisParser PTerm

-- | Creates setters for record types on necessary functions
mkType :: Name -> Name

-- | Parses a type signature <tt> TypeSig ::= <tt>:</tt> Expr ; </tt> <tt>
--   TypeExpr ::= ConstraintList? Expr; </tt>
typeExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a lambda expression <tt> Lambda ::= <a>\\</a> TypeOptDeclList
--   LambdaTail | <a>\\</a> SimpleExprList LambdaTail ; </tt> <tt>
--   SimpleExprList ::= SimpleExpr | SimpleExpr ',' SimpleExprList ; </tt>
--   <tt> LambdaTail ::= Impossible | '=&gt;' Expr </tt>
lambda :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a term rewrite expression <tt> RewriteTerm ::= <tt>rewrite</tt>
--   Expr (<tt>==&gt;</tt> Expr)? 'in' Expr ; </tt>
rewriteTerm :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a let binding @ Let ::= 'let' Name TypeSig'? '=' Expr 'in' Expr
--   | 'let' Expr' '=' Expr' 'in' Expr
--   
--   TypeSig' ::= <tt>:</tt> Expr' ; @
let_ :: SyntaxInfo -> IdrisParser PTerm
let_binding :: SyntaxInfo -> StateT IState IdrisInnerParser (FC, PTerm, PTerm, PTerm, [(PTerm, PTerm)])

-- | Parses a conditional expression <tt> If ::= 'if' Expr 'then' Expr
--   'else' Expr </tt>
if_ :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a quote goal
--   
--   <pre>
--   QuoteGoal ::=
--     <a>quoteGoal</a> Name <tt>by</tt> Expr 'in' Expr
--     ;
--   </pre>
quoteGoal :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a dependent type signature
--   
--   <pre>
--   Pi ::= PiOpts Static? Pi'
--   </pre>
--   
--   <pre>
--   Pi' ::=
--       OpExpr ('-&gt;' Pi)?
--     | '(' TypeDeclList           ')'            '-&gt;' Pi
--     | '{' TypeDeclList           '}'            '-&gt;' Pi
--     | '{' <tt>auto</tt>    TypeDeclList '}'            '-&gt;' Pi
--     | '{' 'default' SimpleExpr TypeDeclList '}' '-&gt;' Pi
--     ;
--   </pre>
bindsymbol :: (DeltaParsing m, LookAheadParsing m) => [ArgOpt] -> Static -> t -> m Plicity
explicitPi :: [ArgOpt] -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
autoImplicit :: t -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
defaultImplicit :: t -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
normalImplicit :: [ArgOpt] -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
implicitPi :: [ArgOpt] -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
unboundPi :: [ArgOpt] -> Static -> SyntaxInfo -> StateT IState IdrisInnerParser PTerm
pi :: SyntaxInfo -> IdrisParser PTerm

-- | Parses Possible Options for Pi Expressions <tt> PiOpts ::= <a>.</a>?
--   </tt>
piOpts :: SyntaxInfo -> IdrisParser [ArgOpt]

-- | Parses a type constraint list
--   
--   <pre>
--   ConstraintList ::=
--       '(' Expr_List ')' '=&gt;'
--     | Expr              '=&gt;'
--     ;
--   </pre>
constraintList :: SyntaxInfo -> IdrisParser [(Name, FC, PTerm)]
constraintList1 :: SyntaxInfo -> IdrisParser [(Name, FC, PTerm)]

-- | Parses a type declaration list <tt> TypeDeclList ::=
--   FunctionSignatureList | NameList TypeSig ; </tt>
--   
--   <pre>
--   FunctionSignatureList ::=
--       Name TypeSig
--     | Name TypeSig ',' FunctionSignatureList
--     ;
--   </pre>
typeDeclList :: SyntaxInfo -> IdrisParser [(Name, FC, PTerm)]

-- | Parses a type declaration list with optional parameters <tt>
--   TypeOptDeclList ::= NameOrPlaceholder TypeSig? | NameOrPlaceholder
--   TypeSig? ',' TypeOptDeclList ; </tt>
--   
--   <pre>
--   NameOrPlaceHolder ::= Name | '_';
--   </pre>
tyOptDeclList :: SyntaxInfo -> IdrisParser [(Name, FC, PTerm)]

-- | Parses a list literal expression e.g. [1,2,3] or a comprehension [ (x,
--   y) | x &lt;- xs , y &lt;- ys ] <tt> ListExpr ::= '[' ']' | '[' Expr
--   '|' DoList ']' | '[' ExprList ']' ; </tt> <tt> DoList ::= Do | Do ','
--   DoList ; </tt> <tt> ExprList ::= Expr | Expr ',' ExprList ; </tt>
listExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a do-block <tt> Do' ::= Do KeepTerminator; </tt>
--   
--   <pre>
--   DoBlock ::=
--     'do' OpenBlock Do'+ CloseBlock
--     ;
--   </pre>
doBlock :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an expression inside a do block <tt> Do ::= 'let' Name
--   TypeSig'? '=' Expr | 'let' Expr' '=' Expr | Name '&lt;-' Expr | Expr'
--   '&lt;-' Expr | Expr ; </tt>
do_ :: SyntaxInfo -> IdrisParser PDo
do_alt :: SyntaxInfo -> StateT IState IdrisInnerParser (PTerm, PTerm)

-- | Parses an expression in idiom brackets <tt> Idiom ::= '[|' Expr '|]';
--   </tt>
idiom :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a constant or literal expression
--   
--   <pre>
--   Constant ::=
--       <a>Integer</a>
--     | <a>Int</a>
--     | <a>Char</a>
--     | <a>Double</a>
--     | <a>String</a>
--     | <tt>Bits8</tt>
--     | <tt>Bits16</tt>
--     | <tt>Bits32</tt>
--     | <tt>Bits64</tt>
--     | Float_t
--     | Natural_t
--     | VerbatimString_t
--     | String_t
--     | Char_t
--     ;
--   </pre>
constants :: [(String, Const)]

-- | Parse a constant and its source span
constant :: IdrisParser (Const, FC)

-- | Parses a verbatim multi-line string literal (triple-quoted)
--   
--   <pre>
--   VerbatimString_t ::=
--     '"""' ~'"""' '"""'
--   ;
--   </pre>
verbatimStringLiteral :: MonadicParsing m => m (String, FC)

-- | Parses a static modifier
--   
--   <pre>
--   Static ::=
--     '[' static ']'
--   ;
--   </pre>
static :: IdrisParser Static

-- | Parses a tactic script
--   
--   <pre>
--   Tactic ::= <tt>intro</tt> NameList?
--          |   <tt>intros</tt>
--          |   <tt>refine</tt>      Name Imp+
--          |   <tt>mrefine</tt>     Name
--          |   <tt>rewrite</tt>     Expr
--          |   <tt>induction</tt>   Expr
--          |   <tt>equiv</tt>       Expr
--          |   'let'         Name <tt>:</tt> Expr' '=' Expr
--          |   'let'         Name           '=' Expr
--          |   <tt>focus</tt>       Name
--          |   <tt>exact</tt>       Expr
--          |   <tt>applyTactic</tt> Expr
--          |   <tt>reflect</tt>     Expr
--          |   <tt>fill</tt>        Expr
--          |   <a>try</a>         Tactic '|' Tactic
--          |   '{' TacticSeq '}'
--          |   <tt>compute</tt>
--          |   <tt>trivial</tt>
--          |   <tt>solve</tt>
--          |   <tt>attack</tt>
--          |   <a>state</a>
--          |   <tt>term</tt>
--          |   <tt>undo</tt>
--          |   <tt>qed</tt>
--          |   <tt>abandon</tt>
--          |   <tt>:</tt> <tt>q</tt>
--          ;
--   
--   Imp ::= <tt>?</tt> | '_';
--   
--   TacticSeq ::=
--       Tactic ';' Tactic
--     | Tactic ';' TacticSeq
--     ;
--   </pre>
--   
--   A specification of the arguments that tactics can take
data TacticArg

-- | Names: n1, n2, n3, ... n
NameTArg :: TacticArg
ExprTArg :: TacticArg
AltsTArg :: TacticArg
StringLitTArg :: TacticArg

-- | A list of available tactics and their argument requirements
tactics :: [([String], Maybe TacticArg, SyntaxInfo -> IdrisParser PTactic)]
tactic :: SyntaxInfo -> IdrisParser PTactic

-- | Parses a tactic as a whole
fullTactic :: SyntaxInfo -> IdrisParser PTactic

module Idris.Elab.Record

-- | Elaborate a record declaration
elabRecord :: ElabInfo -> (Docstring (Either Err PTerm)) -> SyntaxInfo -> FC -> DataOpts -> Name -> FC -> [(Name, FC, Plicity, PTerm)] -> [(Name, Docstring (Either Err PTerm))] -> [(Maybe (Name, FC), Plicity, PTerm, Maybe (Docstring (Either Err PTerm)))] -> Maybe (Name, FC) -> (Docstring (Either Err PTerm)) -> SyntaxInfo -> Idris ()

module Idris.ElabDecls
recinfo :: ElabInfo

-- | Return the elaborated term which calls <tt>main</tt>
elabMain :: Idris Term

-- | Elaborate primitives
elabPrims :: Idris ()
elabDecls :: ElabInfo -> [PDecl] -> Idris ()
elabDecl :: ElabWhat -> ElabInfo -> PDecl -> Idris ()
elabDecl' :: ElabWhat -> ElabInfo -> PDecl' PTerm -> StateT IState (ExceptT Err IO) ()

module Idris.ParseData

-- | Parses a record type declaration Record ::= DocComment Accessibility?
--   <a>record</a> FnName TypeSig 'where' OpenBlock Constructor
--   KeepTerminator CloseBlock;
record :: SyntaxInfo -> IdrisParser PDecl
recordParameter :: SyntaxInfo -> IdrisParser (Name, FC, Plicity, PTerm)

-- | Parses data declaration type (normal or codata) DataI ::= 'data' |
--   <a>codata</a>;
dataI :: IdrisParser DataOpts
recordI :: IdrisParser DataOpts

-- | Parses if a data should not have a default eliminator
--   DefaultEliminator ::= <tt>noelim</tt>?
dataOpts :: DataOpts -> IdrisParser DataOpts

-- | Parses a data type declaration Data ::= DocComment? Accessibility?
--   DataI DefaultEliminator FnName TypeSig ExplicitTypeDataRest? |
--   DocComment? Accessibility? DataI DefaultEliminator FnName Name*
--   DataRest? ; Constructor' ::= Constructor KeepTerminator;
--   ExplicitTypeDataRest ::= 'where' OpenBlock Constructor'* CloseBlock;
--   
--   DataRest ::= '=' SimpleConstructorList Terminator | 'where'! ;
--   SimpleConstructorList ::= SimpleConstructor | SimpleConstructor '|'
--   SimpleConstructorList ;
data_ :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a type constructor declaration Constructor ::= DocComment?
--   FnName TypeSig;
constructor :: SyntaxInfo -> IdrisParser (Docstring (Either Err PTerm), [(Name, Docstring (Either Err PTerm))], Name, FC, PTerm, FC, [Name])

-- | Parses a constructor for simple discriminated union data types
--   SimpleConstructor ::= FnName SimpleExpr* DocComment?
simpleConstructor :: SyntaxInfo -> IdrisParser (Docstring (Either Err PTerm), [(Name, Docstring (Either Err PTerm))], Name, FC, [PTerm], FC, [Name])

-- | Parses a dsl block declaration DSL ::= <a>dsl</a> FnName OpenBlock
--   Overload'+ CloseBlock;
dsl :: SyntaxInfo -> IdrisParser PDecl

-- | Checks DSL for errors
checkDSL :: DSL -> IdrisParser ()

-- | Parses a DSL overload declaration OverloadIdentifier ::= 'let' |
--   Identifier; Overload ::= OverloadIdentifier '=' Expr;
overload :: SyntaxInfo -> IdrisParser (String, PTerm)

module Idris.IBC
loadIBC :: Bool -> FilePath -> Idris ()

-- | Load an entire package from its index file
loadPkgIndex :: String -> Idris ()
writeIBC :: FilePath -> FilePath -> Idris ()
writePkgIndex :: FilePath -> Idris ()
instance Show IBCFile
instance Binary Codegen
instance Binary SSymbol
instance Binary t => Binary (DSL' t)
instance Binary Syntax
instance Binary SynContext
instance Binary TypeInfo
instance Binary FnInfo
instance Binary OptInfo
instance Binary ClassInfo
instance Binary t => Binary (PArg' t)
instance Binary t => Binary (PDo' t)
instance Binary t => Binary (PTactic' t)
instance Binary PAltType
instance Binary PTerm
instance Binary PunInfo
instance Binary t => Binary (PData' t)
instance Binary t => Binary (PClause' t)
instance Binary SyntaxInfo
instance Binary Using
instance Binary t => Binary (ProvideWhat' t)
instance Binary t => Binary (PDecl' t)
instance Binary Plicity
instance Binary Static
instance Binary ArgOpt
instance Binary FixDecl
instance Binary Fixity
instance Binary FnOpt
instance Binary DataOpt
instance Binary MetaInformation
instance Binary Totality
instance Binary PReason
instance Binary Accessibility
instance Binary Def
instance Binary CaseInfo
instance Binary CaseDefs
instance Binary CaseAlt
instance Binary SC
instance Binary CaseType
instance Binary CGInfo
instance Binary SizeChange
instance Binary NumWrapper
instance Binary CodeAttr
instance Binary ListType
instance Binary a => Binary (Inline a)
instance Binary a => Binary (Block a)
instance Binary DocTerm
instance Binary Options
instance Binary a => Binary (Docstring a)

module Idris.Parser

-- | Parses module definition
--   
--   <pre>
--   ModuleHeader ::= DocComment_t? 'module' Identifier_t ';'?;
--   </pre>
moduleHeader :: IdrisParser (Maybe (Docstring ()), [String], [(FC, OutputAnnotation)])
data ImportInfo
ImportInfo :: Bool -> FilePath -> Maybe (String, FC) -> [Text] -> FC -> FC -> ImportInfo
import_reexport :: ImportInfo -> Bool
import_path :: ImportInfo -> FilePath
import_rename :: ImportInfo -> Maybe (String, FC)
import_namespace :: ImportInfo -> [Text]
import_location :: ImportInfo -> FC
import_modname_location :: ImportInfo -> FC

-- | Parses an import statement
--   
--   <pre>
--   Import ::= 'import' Identifier_t ';'?;
--   </pre>
import_ :: IdrisParser ImportInfo

-- | Parses program source
--   
--   <pre>
--   Prog ::= Decl* EOF;
--   </pre>
prog :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a top-level declaration
--   
--   <pre>
--   Decl ::=
--       Decl'
--     | Using
--     | Params
--     | Mutual
--     | Namespace
--     | Class
--     | Instance
--     | DSL
--     | Directive
--     | Provider
--     | Transform
--     | Import!
--     ;
--   </pre>
decl :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a top-level declaration with possible syntax sugar
--   
--   <pre>
--   Decl' ::=
--       Fixity
--     | FunDecl'
--     | Data
--     | Record
--     | SyntaxDecl
--     ;
--   </pre>
decl' :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a syntax extension declaration (and adds the rule to parser
--   state)
--   
--   <pre>
--   SyntaxDecl ::= SyntaxRule;
--   </pre>
syntaxDecl :: SyntaxInfo -> IdrisParser PDecl

-- | Extend an <a>IState</a> with a new syntax extension. See also
--   <a>addReplSyntax</a>.
addSyntax :: IState -> Syntax -> IState

-- | Like <a>addSyntax</a>, but no effect on the IBC.
addReplSyntax :: IState -> Syntax -> IState

-- | Parses a syntax extension declaration
--   
--   <pre>
--   SyntaxRuleOpts ::= <tt>term</tt> | <a>pattern</a>;
--   </pre>
--   
--   <pre>
--   SyntaxRule ::=
--     SyntaxRuleOpts? <tt>syntax</tt> SyntaxSym+ '=' TypeExpr Terminator;
--   </pre>
--   
--   <pre>
--   SyntaxSym ::=   '[' Name_t ']'
--                |  '{' Name_t '}'
--                |  Name_t
--                |  StringLiteral_t
--                ;
--   </pre>
syntaxRule :: SyntaxInfo -> IdrisParser Syntax

-- | Parses a syntax symbol (either binding variable, keyword or
--   expression)
--   
--   <pre>
--   SyntaxSym ::=   '[' Name_t ']'
--                |  '{' Name_t '}'
--                |  Name_t
--                |  StringLiteral_t
--                ;
--   </pre>
syntaxSym :: IdrisParser SSymbol

-- | Parses a function declaration with possible syntax sugar
--   
--   <pre>
--   FunDecl ::= FunDecl';
--   </pre>
fnDecl :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a function declaration
--   
--   <pre>
--   FunDecl' ::=
--    DocComment_t? FnOpts* Accessibility? FnOpts* FnName TypeSig Terminator
--    | Postulate
--    | Pattern
--    | CAF
--    ;
--   </pre>
fnDecl' :: SyntaxInfo -> IdrisParser PDecl

-- | Parses function options given initial options
--   
--   <pre>
--   FnOpts ::= <tt>total</tt>
--     | <tt>partial</tt>
--     | <tt>covering</tt>
--     | <a>implicit</a>
--     | <tt>%</tt> <tt>no_implicit</tt>
--     | <tt>%</tt> <tt>assert_total</tt>
--     | <tt>%</tt> <tt>error_handler</tt>
--     | <tt>%</tt> <tt>reflection</tt>
--     | <tt>%</tt> <a>specialise</a> '[' NameTimesList? ']'
--     ;
--   </pre>
--   
--   <pre>
--   NameTimes ::= FnName Natural?;
--   </pre>
--   
--   <pre>
--   NameTimesList ::=
--     NameTimes
--     | NameTimes ',' NameTimesList
--     ;
--   </pre>
fnOpts :: [FnOpt] -> IdrisParser [FnOpt]

-- | Parses a postulate
--   
--   <pre>
--   Postulate ::=
--     DocComment_t? <a>postulate</a> FnOpts* Accesibility? FnOpts* FnName TypeSig Terminator
--     ;
--   </pre>
postulate :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a using declaration
--   
--   <pre>
--   Using ::=
--     <a>using</a> '(' UsingDeclList ')' OpenBlock Decl* CloseBlock
--     ;
--   </pre>
using_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a parameters declaration
--   
--   <pre>
--   Params ::=
--     <tt>parameters</tt> '(' TypeDeclList ')' OpenBlock Decl* CloseBlock
--     ;
--   </pre>
params :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a mutual declaration (for mutually recursive functions)
--   
--   <pre>
--   Mutual ::=
--     <a>mutual</a> OpenBlock Decl* CloseBlock
--     ;
--   </pre>
mutual :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a namespace declaration
--   
--   <pre>
--   Namespace ::=
--     <a>namespace</a> identifier OpenBlock Decl+ CloseBlock
--     ;
--   </pre>
namespace :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a methods block (for instances)
--   
--   <pre>
--   InstanceBlock ::= 'where' OpenBlock FnDecl* CloseBlock
--   </pre>
instanceBlock :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a methods and instances block (for type classes)
--   
--   <pre>
--   MethodOrInstance ::=
--      FnDecl
--      | Instance
--      ;
--   </pre>
--   
--   <pre>
--   ClassBlock ::=
--     'where' OpenBlock Constructor? MethodOrInstance* CloseBlock
--     ;
--   </pre>
classBlock :: SyntaxInfo -> IdrisParser (Maybe (Name, FC), Docstring (Either Err PTerm), [PDecl])

-- | Parses a type class declaration
--   
--   <pre>
--   ClassArgument ::=
--      Name
--      | '(' Name <tt>:</tt> Expr ')'
--      ;
--   </pre>
--   
--   <pre>
--   Class ::=
--     DocComment_t? Accessibility? 'class' ConstraintList? Name ClassArgument* ClassBlock?
--     ;
--   </pre>
class_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a type class instance declaration
--   
--   <pre>
--   Instance ::=
--     DocComment_t? 'instance' InstanceName? ConstraintList? Name SimpleExpr* InstanceBlock?
--     ;
--   </pre>
--   
--   <pre>
--   InstanceName ::= '[' Name ']';
--   </pre>
instance_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parse a docstring
docstring :: SyntaxInfo -> IdrisParser (Docstring (Either Err PTerm), [(Name, Docstring (Either Err PTerm))])

-- | Parses a using declaration list
--   
--   <pre>
--   UsingDeclList ::=
--     UsingDeclList'
--     | NameList TypeSig
--     ;
--   </pre>
--   
--   <pre>
--   UsingDeclList' ::=
--     UsingDecl
--     | UsingDecl ',' UsingDeclList'
--     ;
--   </pre>
--   
--   <pre>
--   NameList ::=
--     Name
--     | Name ',' NameList
--     ;
--   </pre>
usingDeclList :: SyntaxInfo -> IdrisParser [Using]

-- | Parses a using declaration
--   
--   <pre>
--   UsingDecl ::=
--     FnName TypeSig
--     | FnName FnName+
--     ;
--   </pre>
usingDecl :: SyntaxInfo -> IdrisParser Using

-- | Parse a clause with patterns
--   
--   <pre>
--   Pattern ::= Clause;
--   </pre>
pattern :: SyntaxInfo -> IdrisParser PDecl

-- | Parse a constant applicative form declaration
--   
--   <pre>
--   CAF ::= 'let' FnName '=' Expr Terminator;
--   </pre>
caf :: SyntaxInfo -> IdrisParser PDecl

-- | Parse an argument expression
--   
--   <pre>
--   ArgExpr ::= HSimpleExpr | ;
--   </pre>
argExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parse a right hand side of a function
--   
--   <pre>
--   RHS ::= '='            Expr
--        |  <tt>?=</tt>  RHSName? Expr
--        |  Impossible
--        ;
--   </pre>
--   
--   <pre>
--   RHSName ::= '{' FnName '}';
--   </pre>
rhs :: SyntaxInfo -> Name -> IdrisParser PTerm

-- | Parses a function clause
--   
--   <pre>
--   RHSOrWithBlock ::= RHS WhereOrTerminator
--                  | <tt>with</tt> SimpleExpr OpenBlock FnDecl+ CloseBlock
--                  ;
--   </pre>
--   
--   <pre>
--   Clause ::=                                                               WExpr+ RHSOrWithBlock
--          |   SimpleExpr <tt>&lt;==</tt>  FnName                                             RHS WhereOrTerminator
--          |   ArgExpr Operator ArgExpr                                      WExpr* RHSOrWithBlock 
--          |                     FnName ConstraintArg* ImplicitOrArgExpr*    WExpr* RHSOrWithBlock
--          ;
--   </pre>
--   
--   <pre>
--   ImplicitOrArgExpr ::= ImplicitArg | ArgExpr;
--   </pre>
--   
--   <pre>
--   WhereOrTerminator ::= WhereBlock | Terminator;
--   </pre>
clause :: SyntaxInfo -> IdrisParser PClause

-- | Parses with pattern
--   
--   <pre>
--   WExpr ::= '|' Expr';
--   </pre>
wExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a where block
--   
--   <pre>
--   WhereBlock ::= 'where' OpenBlock Decl+ CloseBlock;
--   </pre>
whereBlock :: Name -> SyntaxInfo -> IdrisParser ([PDecl], [(Name, Name)])

-- | Parses a code generation target language name
--   
--   <pre>
--   Codegen ::= <tt>C</tt>
--           |   <tt>Java</tt>
--           |   <tt>JavaScript</tt>
--           |   <tt>Node</tt>
--           |   <tt>LLVM</tt>
--           |   <a>Bytecode</a>
--           ;
--   </pre>
codegen_ :: IdrisParser Codegen

-- | Parses a compiler directive <tt> StringList ::= String | String ','
--   StringList ; </tt>
--   
--   <pre>
--   Directive ::= <tt>%</tt> Directive';
--   </pre>
--   
--   <pre>
--   Directive' ::= <tt>lib</tt>            CodeGen String_t
--              |   <tt>link</tt>           CodeGen String_t
--              |   <tt>flag</tt>           CodeGen String_t
--              |   <tt>include</tt>        CodeGen String_t
--              |   <tt>hide</tt>           Name
--              |   <tt>freeze</tt>         Name
--              |   <tt>access</tt>         Accessibility
--              |   'default'        Totality
--              |   <tt>logging</tt>        Natural
--              |   <tt>dynamic</tt>        StringList
--              |   <a>name</a>           Name NameList
--              |   <tt>error_handlers</tt> Name NameList
--              |   <tt>language</tt>       <a>TypeProviders</a>
--              |   <tt>language</tt>       <a>ErrorReflection</a>
--              ;
--   </pre>
directive :: SyntaxInfo -> IdrisParser [PDecl]
pLangExt :: IdrisParser LanguageExt

-- | Parses a totality
--   
--   <pre>
--   Totality ::= <tt>partial</tt> | <tt>total</tt>
--   </pre>
totality :: IdrisParser Bool

-- | Parses a type provider
--   
--   <pre>
--   Provider ::= DocComment_t? <tt>%</tt> <tt>provide</tt> Provider_What? '(' FnName TypeSig ')' <tt>with</tt> Expr;
--   ProviderWhat ::= <tt>proof</tt> | <tt>term</tt> | 'type' | <a>postulate</a>
--   </pre>
provider :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a transform
--   
--   <pre>
--   Transform ::= <tt>%</tt> <a>transform</a> Expr <tt>==&gt;</tt> Expr
--   </pre>
transform :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses an expression from input
parseExpr :: IState -> String -> Result PTerm

-- | Parses a constant form input
parseConst :: IState -> String -> Result Const

-- | Parses a tactic from input
parseTactic :: IState -> String -> Result PTactic

-- | Parse module header and imports
parseImports :: FilePath -> String -> Idris (Maybe (Docstring ()), [String], [ImportInfo], Maybe Delta)

-- | There should be a better way of doing this...
findFC :: Doc -> (FC, String)

-- | Check if the coloring matches the options and corrects if necessary
fixColour :: Bool -> Doc -> Doc

-- | A program is a list of declarations, possibly with associated
--   documentation strings.
parseProg :: SyntaxInfo -> FilePath -> String -> Maybe Delta -> Idris [PDecl]

-- | Load idris module and show error if something wrong happens
loadModule :: FilePath -> Idris (Maybe String)

-- | Load idris module
loadModule' :: FilePath -> Idris (Maybe String)

-- | Load idris code from file
loadFromIFile :: Bool -> IFileType -> Maybe Int -> Idris ()

-- | Load idris source code and show error if something wrong happens
loadSource' :: Bool -> FilePath -> Maybe Int -> Idris ()

-- | Load Idris source code
loadSource :: Bool -> FilePath -> Maybe Int -> Idris ()

-- | Adds names to hide list
addHides :: [(Name, Maybe Accessibility)] -> Idris ()

module Idris.CaseSplit
splitOnLine :: Int -> Name -> FilePath -> Idris [[(Name, PTerm)]]
replaceSplits :: String -> [[(Name, PTerm)]] -> Idris [String]
getClause :: Int -> Name -> FilePath -> Idris String
getProofClause :: Int -> Name -> FilePath -> Idris String
mkWith :: String -> Name -> String
nameMissing :: [PTerm] -> Idris [PTerm]
getUniq :: (Show t, Num t) => [Char] -> t -> Idris ([Char], t)
nameRoot :: [String] -> [Char] -> String

module Idris.Interactive
caseSplitAt :: FilePath -> Bool -> Int -> Name -> Idris ()
addClauseFrom :: FilePath -> Bool -> Int -> Name -> Idris ()
addProofClauseFrom :: FilePath -> Bool -> Int -> Name -> Idris ()
addMissing :: FilePath -> Bool -> Int -> Name -> Idris ()
makeWith :: FilePath -> Bool -> Int -> Name -> Idris ()
doProofSearch :: FilePath -> Bool -> Bool -> Int -> Name -> [Name] -> Maybe Int -> Idris ()
makeLemma :: FilePath -> Bool -> Int -> Name -> Idris ()

module Idris.REPLParser
parseCmd :: IState -> String -> String -> Result (Either String Command)
help :: [([String], CmdArg, String)]
allHelp :: [([String], CmdArg, String)]


-- | Support for command-line completion at the REPL and in the prover
module Idris.Completion

-- | Complete REPL commands and defined identifiers
replCompletion :: CompletionFunc Idris

-- | Complete tactics and their arguments
proverCompletion :: [String] -> CompletionFunc Idris

module Idris.Chaser
buildTree :: [FilePath] -> FilePath -> Idris [ModuleTree]
getModuleFiles :: [ModuleTree] -> [IFileType]
data ModuleTree
MTree :: IFileType -> Bool -> UTCTime -> [ModuleTree] -> ModuleTree
mod_path :: ModuleTree -> IFileType
mod_needsRecheck :: ModuleTree -> Bool
mod_time :: ModuleTree -> UTCTime
mod_deps :: ModuleTree -> [ModuleTree]
instance Show ModuleTree

module Idris.TypeSearch
searchByType :: [String] -> PTerm -> Idris ()

-- | Our default search predicate.
searchPred :: IState -> Type -> [(Name, Type)] -> [(Name, Score)]

-- | Convert a <a>Score</a> to an <a>Int</a> to provide an order for search
--   results. Lower scores are better.
defaultScoreFunction :: Score -> Int
instance Eq AsymMods
instance Show AsymMods
instance Eq a => Eq (Sided a)
instance Show a => Show (Sided a)
instance Eq Score
instance Show Score
instance Show State
instance Monoid Score
instance Monoid AsymMods
instance Monoid a => Monoid (Sided a)
instance Ord Score

module Idris.Prover
prover :: Bool -> Name -> Idris ()
showProof :: Bool -> Name -> [String] -> String
proverSettings :: ElabState EState -> Settings Idris
assumptionNames :: ElabState EState -> [String]
prove :: Ctxt OptInfo -> Context -> Bool -> Name -> Type -> Idris ()
elabStep :: ElabState EState -> ElabD a -> Idris (a, ElabState EState)
dumpState :: IState -> ProofState -> Idris ()
lifte :: ElabState EState -> ElabD a -> Idris a
receiveInput :: Handle -> ElabState EState -> Idris (Maybe String)
ploop :: Name -> Bool -> String -> [String] -> ElabState EState -> Maybe History -> Idris (Term, [String])

module Idris.REPL

-- | Run the REPL
repl :: IState -> [FilePath] -> FilePath -> InputT Idris ()

-- | Run the REPL server
startServer :: PortID -> IState -> [FilePath] -> Idris ()
processNetCmd :: IState -> IState -> Handle -> FilePath -> String -> IO (IState, FilePath)

-- | Run a command on the server on localhost
runClient :: PortID -> String -> IO ()
initIdemodeSocket :: IO Handle

-- | Run the IdeMode
idemodeStart :: Bool -> IState -> [FilePath] -> Idris ()
idemode :: Handle -> IState -> [FilePath] -> Idris ()

-- | Run IDEMode commands
runIdeModeCommand :: Handle -> Integer -> IState -> FilePath -> [FilePath] -> IdeModeCommand -> Idris ()

-- | Show a term for IDEMode with the specified implicitness
ideModeForceTermImplicits :: Handle -> Integer -> [(Name, Bool)] -> Bool -> Term -> Idris ()
splitName :: String -> Either String Name
idemodeProcess :: FilePath -> Command -> Idris ()

-- | The prompt consists of the currently loaded modules, or <a>Idris</a>
--   if there are none
mkPrompt :: [FilePath] -> [Char]

-- | Determine whether a file uses literate syntax
lit :: FilePath -> Bool
processInput :: String -> IState -> [FilePath] -> FilePath -> Idris (Maybe [FilePath])
resolveProof :: Name -> Idris Name
removeProof :: Name -> Idris ()
edit :: FilePath -> IState -> Idris ()
proofs :: IState -> Idris ()
insertScript :: String -> [String] -> [String]
process :: FilePath -> Command -> Idris ()
showTotal :: Totality -> IState -> Doc OutputAnnotation
showTotalN :: IState -> Name -> Doc OutputAnnotation
displayHelp :: [Char]
pprintDef :: Name -> Idris [Doc OutputAnnotation]
helphead :: [([[Char]], CmdArg, [Char])]
replSettings :: Maybe FilePath -> Settings Idris

-- | Invoke as if from command line. It is an error if there are unresolved
--   totality problems.
idris :: [Opt] -> IO (Maybe IState)
loadInputs :: [FilePath] -> Maybe Int -> Idris [FilePath]
idrisMain :: [Opt] -> Idris ()
runMain :: Idris () -> IO ()
execScript :: String -> Idris ()

-- | Get the platform-specific, user-specific Idris dir
getIdrisUserDataDir :: Idris FilePath

-- | Locate the platform-specific location for the init script
getInitScript :: Idris FilePath

-- | Run the initialisation script
initScript :: Idris ()
getFile :: Opt -> Maybe String
getBC :: Opt -> Maybe String
getOutput :: Opt -> Maybe String
getIBCSubDir :: Opt -> Maybe String
getImportDir :: Opt -> Maybe String
getPkgDir :: Opt -> Maybe String
getPkg :: Opt -> Maybe (Bool, String)
getPkgClean :: Opt -> Maybe String
getPkgREPL :: Opt -> Maybe String
getPkgCheck :: Opt -> Maybe String

-- | Returns None if given an Opt which is not PkgMkDoc Otherwise returns
--   Just x, where x is the contents of PkgMkDoc
getPkgMkDoc :: Opt -> Maybe String
getPkgTest :: Opt -> Maybe String
getCodegen :: Opt -> Maybe Codegen
getConsoleWidth :: Opt -> Maybe ConsoleWidth
getExecScript :: Opt -> Maybe String
getPkgIndex :: Opt -> Maybe FilePath
getEvalExpr :: Opt -> Maybe String
getOutputTy :: Opt -> Maybe OutputType
getLanguageExt :: Opt -> Maybe LanguageExt
getTriple :: Opt -> Maybe String
getCPU :: Opt -> Maybe String
getOptLevel :: Opt -> Maybe Int
getOptimisation :: Opt -> Maybe (Idris ())
getColour :: Opt -> Maybe Bool
getClient :: Opt -> Maybe String
getPort :: [Opt] -> PortID
opt :: (Opt -> Maybe a) -> [Opt] -> [a]
ver :: [Char]
defaultPort :: PortID
banner :: [Char]
warranty :: [Char]

module Idris.CmdOptions
runArgParser :: IO [Opt]
pureArgParser :: [String] -> [Opt]
parser :: Parser [Opt]
parseFlags :: Parser [Opt]
parseVersion :: Parser (a -> a)
preProcOpts :: [Opt] -> [Opt] -> [Opt]
parseCodegen :: String -> Codegen
parseConsoleWidth :: Monad m => String -> m ConsoleWidth
integerReader :: ReadP Int

module Pkg.Package

-- | Run the package through the idris compiler.
buildPkg :: Bool -> (Bool, FilePath) -> IO ()

-- | Type check packages only
--   
--   This differs from build in that executables are not built, if the
--   package contains an executable.
checkPkg :: Bool -> Bool -> FilePath -> IO ()

-- | Check a package and start a REPL
replPkg :: FilePath -> Idris ()

-- | Clean Package build files
cleanPkg :: FilePath -> IO ()

-- | Generate IdrisDoc for package TODO: Handle case where module does not
--   contain a matching namespace E.g. from prelude.ipkg: IO,
--   Prelude.Chars, Builtins
--   
--   Issue number #1572 on the issue tracker
--   <a>https://github.com/idris-lang/Idris-dev/issues/1572</a>
documentPkg :: FilePath -> IO ()

-- | Build a package with a sythesized main function that runs the tests
testPkg :: FilePath -> IO ()

-- | Install package
installPkg :: PkgDesc -> IO ()
buildMods :: [Opt] -> [Name] -> IO (Maybe IState)
testLib :: Bool -> String -> String -> IO Bool
rmIBC :: Name -> IO ()
rmIdx :: String -> IO ()
toIBCFile :: Name -> [Char]
installIBC :: String -> Name -> IO ()
installIdx :: String -> IO ()
installObj :: String -> String -> IO ()
mkDirCmd :: [Char]

-- | Invoke a Makefile's default target.
make :: Maybe String -> IO ()

-- | Invoke a Makefile's clean target.
clean :: Maybe String -> IO ()
