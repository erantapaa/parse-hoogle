-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Incremental computing
--   
@package incremental-computing
@version 0.0.0.0

module Data.Incremental
class Change p where type family Value p :: *
($$) :: Change p => p -> Value p -> Value p
data PrimitiveChange a
Keep :: PrimitiveChange a
ReplaceBy :: a -> PrimitiveChange a
data Trans p q
type TransProc m p q = Value p -> m (Value q, p -> m q)
simpleTrans :: (Value p -> Value q) -> (p -> q) -> Trans p q
stateTrans :: (Value p -> (Value q, s)) -> (p -> s -> (q, s)) -> Trans p q
stTrans :: (forall s. TransProc (ST s) p q) -> Trans p q
trans :: (forall r. (forall m. Monad m => TransProc m p q -> m r) -> r) -> Trans p q
runTrans :: Trans p q -> (Value p, [p]) -> (Value q, [q])
toFunction :: Trans p q -> (Value p -> Value q)
toSTProc :: Trans p q -> TransProc (ST s) p q
const :: Monoid q => Value q -> Trans p q
fromFunction :: (a -> b) -> Trans (PrimitiveChange a) (PrimitiveChange b)
sanitize :: Eq a => Trans (PrimitiveChange a) (PrimitiveChange a)
class (Monoid (DefaultChange a), Change (DefaultChange a), Value (DefaultChange a) ~ a) => Changeable a where type family DefaultChange a :: * type instance DefaultChange a = PrimitiveChange a
type (->>) a b = Trans (DefaultChange a) (DefaultChange b)
instance Typeable Change
instance Typeable Trans
instance Typeable Changeable
instance Typeable Cell
instance Show a => Show (PrimitiveChange a)
instance Read a => Read (PrimitiveChange a)
instance Changeable Int
instance Changeable Bool
instance Category Trans
instance Change (PrimitiveChange a)
instance Monoid (PrimitiveChange a)
instance Functor PrimitiveChange

module Data.MultiChange
data MultiChange p
singleton :: p -> MultiChange p
fromList :: [p] -> MultiChange p
map :: Trans p q -> Trans (MultiChange p) (MultiChange q)
return :: Trans p (MultiChange p)
join :: Trans (MultiChange (MultiChange p)) (MultiChange p)
bind :: Trans p (MultiChange q) -> Trans (MultiChange p) (MultiChange q)
compose :: Monoid p => Trans (MultiChange p) p
composeMap :: Monoid q => Trans p q -> Trans (MultiChange p) q
instance Monoid (MultiChange p)
instance Change p => Change (MultiChange p)
instance Foldable MultiChange
instance Read p => Read (MultiChange p)
instance Show p => Show (MultiChange p)

module Data.Incremental.Tuple
first :: DefaultChange a -> DefaultChange (a, b)
second :: DefaultChange b -> DefaultChange (a, b)
data AtomicChange a b
First :: (DefaultChange a) -> AtomicChange a b
Second :: (DefaultChange b) -> AtomicChange a b
(&&&) :: (Changeable a, Changeable b, Changeable c) => (a ->> b) -> (a ->> c) -> (a ->> (b, c))
fst :: (Changeable a, Changeable b) => (a, b) ->> a
snd :: (Changeable a, Changeable b) => (a, b) ->> b
swap :: (Changeable a, Changeable b) => (a, b) ->> (b, a)
instance Typeable AtomicChange
instance (Changeable a, Changeable b) => Change (AtomicChange a b)
instance (Changeable a, Changeable b) => Changeable (a, b)

module Data.Incremental.Sequence

-- | General-purpose finite sequences.
data Seq a :: * -> *
insert :: Int -> Seq a -> DefaultChange (Seq a)
delete :: Int -> Int -> DefaultChange (Seq a)
shift :: Int -> Int -> Int -> DefaultChange (Seq a)
changeAt :: Int -> DefaultChange a -> DefaultChange (Seq a)
data AtomicChange a
Insert :: !Int -> (Seq a) -> AtomicChange a
Delete :: !Int -> !Int -> AtomicChange a
Shift :: !Int -> !Int -> !Int -> AtomicChange a
ChangeAt :: !Int -> (DefaultChange a) -> AtomicChange a
normalizeAtomicChange :: Int -> AtomicChange a -> AtomicChange a
singleton :: Changeable a => a ->> Seq a
fromPair :: Changeable a => (a, a) ->> Seq a
cat :: Changeable a => (Seq a, Seq a) ->> Seq a
null :: Changeable a => Seq a ->> Bool
length :: Changeable a => Seq a ->> Int
map :: (Changeable a, Changeable b) => (a ->> b) -> Seq a ->> Seq b
map' :: (Changeable a, DefaultChange a ~ PrimitiveChange a, Changeable b, DefaultChange b ~ PrimitiveChange b) => (a -> b) -> Seq a ->> Seq b
concat :: Changeable a => Seq (Seq a) ->> Seq a
concatMap :: (Changeable a, Changeable b) => (a ->> Seq b) -> Seq a ->> Seq b
gate :: Changeable a => (a ->> Bool) -> a ->> Seq a
gate' :: (Changeable a, DefaultChange a ~ PrimitiveChange a) => (a -> Bool) -> a ->> Seq a
filter :: Changeable a => (a ->> Bool) -> Seq a ->> Seq a
filter' :: (Changeable a, DefaultChange a ~ PrimitiveChange a) => (a -> Bool) -> Seq a ->> Seq a
reverse :: Changeable a => Seq a ->> Seq a
sort :: (Ord a, Changeable a) => Seq a ->> Seq a
sortBy :: Changeable a => (a -> a -> Ordering) -> Seq a ->> Seq a
instance Typeable AtomicChange
instance Typeable ConcatStateElement
instance Typeable ConcatStateMeasure
instance Typeable OrderValue
instance Monoid p => Monoid (OrderChange p)
instance Changeable a => Changeable (OrderValue a)
instance Change p => Change (OrderChange p)
instance Ord (OrderValue a)
instance Eq (OrderValue a)
instance Measured ConcatStateMeasure ConcatStateElement
instance Monoid ConcatStateMeasure
instance Changeable a => Change (AtomicChange a)
instance Changeable a => Changeable (Seq a)
