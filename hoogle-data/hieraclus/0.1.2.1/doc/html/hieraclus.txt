-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automated clustering of arbitrary elements in Haskell.
--   
--   Hieraclus is a library that supports clustering of arbitrary elements
--   in haskell. The difference to the already existing cluster library
--   <a>hierarchical-clustering</a> is the ability to work with abort
--   criterias which allow an <a>intelligent</a> clustering. With the help
--   of abort criterias the user can specify conditions that must be
--   fulfilled in order to stop the clustering process.
@package hieraclus
@version 0.1.2.1


-- | A library providing basic vector operations for the clustering module
module Numeric.Statistics.Clustering.VectorUtils

-- | a vector is represented as an ordinary list
type Vector a = [a]

-- | maps an element into a one element vector
singleton :: a -> Vector a

-- | creates an empty vector
emptyVector :: [a]

-- | converts every element of a given list into a one element vector
fromList :: [a] -> [Vector a]

-- | adds two given vectors
addV :: Num a => [a] -> [a] -> [a]

-- | subtracts two given vectors
subV :: Num a => [a] -> [a] -> [a]

-- | calculates the vector product of two given vectors
mulV :: Num a => [a] -> [a] -> [a]

-- | divides two given vectors
divV :: Fractional a => [a] -> [a] -> [a]

-- | calculates the sum of a given list of vectors
sumV :: Num a => [[a]] -> [a]
euklideanDistance :: Floating a => Vector a -> Vector a -> a
qeuklideanDistance :: Floating a => [a] -> [a] -> a
norm :: Floating a => Vector a -> a
meanSquareV :: Floating a => [Vector a] -> a
average :: Floating a => [a] -> a
devsq :: Floating a => [a] -> a


-- | Hieraclus is a library that supports clustering of arbitrary elements
--   in haskell. The difference to the already existing cluster library
--   <i>hierarchical-clustering</i> is the ability to work with abort
--   criterias which allow an "intelligent" clustering. With the help of
--   abort criterias the user can specify conditions that must be fulfilled
--   in order to stop the clustering process.
--   
--   Another motivation of creating this library was to make the cluster
--   process run in <i>O(n^2)</i>. However, the current implementation runs
--   in <i>O(n^2 * log n)</i>. It has to be mentioned that the real runtime
--   complexity tends to grow faster due to memory management, I guess.
--   Some profiling showed that there is quite a big amount of memory spent
--   managing the maps. The principle idea was not to work with a matrix,
--   but with two maps instead. The first map holds the mappings from
--   cluster pairs to distances, the second map vice versa, thus allowing
--   to find the minimal distance in <i>O(log n)</i> and not in
--   <i>O(n^2)</i>. Two make things more efficient the data to be clustered
--   initially is transformed to vector space, as all clutering operations
--   work in vector space. The actual clustering thus is done with the
--   vector representations of the input data, which finally are
--   transformed back.
--   
--   The above mentioned information for the abort criterias, the maps and
--   the element-mappings are carried through the cluster process in a
--   cluster state. So the actual cluster process takes place within the
--   state monad. However, the library offers a function <a>cluster</a>
--   that is purely functional as it returns a tuple. First element of the
--   tuple is the cluster result - simply implemented as list of list. The
--   second element of the tuple holds the cluster information used by the
--   abort criterias.
module Numeric.Statistics.Clustering.Clustering

-- | the cluster state contains information about all relevant maps that
--   are needed for the clustering and information about the clustering
--   process. The ClusterState is passed around withing the state monad
data ClusterState a b
CS :: MinimumMap a -> CombinationMap a -> ClusterInfo a b -> ClusterState a b

-- | holds the mappings from distances to pairs
minmap :: ClusterState a b -> MinimumMap a

-- | holds the mappings from pairs to distances
combis :: ClusterState a b -> CombinationMap a

-- | holds information of the clustering process that is needed by the
--   Abort Criterias
cinfo :: ClusterState a b -> ClusterInfo a b

-- | the cluster process produces information about the clustering after
--   each step. these information are given to functions that decide if the
--   cluster process may continue or stop and return the results
data ClusterInfo a b
CI :: Map (Vector a) b -> Int -> (Cluster a, [Cluster a]) -> a -> a -> Int -> [a] -> ClusterInfo a b

-- | holds the mapping from the representation vectors to its actual
--   objects
idents :: ClusterInfo a b -> Map (Vector a) b

-- | the number of elements to be clustered
nElems :: ClusterInfo a b -> Int

-- | the new created cluster and the all other clusters
cNew :: ClusterInfo a b -> (Cluster a, [Cluster a])

-- | a quality factor of the current combining that indicates the "costs"
--   of cNew
costs :: ClusterInfo a b -> a

-- | the accmulated costs
total :: ClusterInfo a b -> a

-- | the current clustering step
cStep :: ClusterInfo a b -> Int

-- | holds a history of all costs
cHistory :: ClusterInfo a b -> [a]

-- | the resulting clusters are represented as a lists
type ClusterResult a = [[a]]

-- | a Cluster is represented as a list of Vectors
newtype Cluster a
Cluster :: [Vector a] -> Cluster a
vals :: Cluster a -> [Vector a]

-- | the Cluster map serves to represent unions of elements. Therefore it
--   maps IDs to clusters.
type ClusterMap a = IntMap (Cluster a)

-- | Unique ID for a cluster
type ID = Key

-- | <i>O(1)</i> creates a cluster with only one element
singleton :: Maybe (Vector a) -> Cluster a

-- | <i>O(n)</i> creates clusters by a given map
fromList :: [Vector a] -> ClusterMap a
getCluster :: ClusterMap a -> ID -> Maybe (Cluster a)
getClusterUnsafe :: ClusterMap a -> ID -> (Cluster a)

-- | merge two clusters given by their ids and return a tuple. The first
--   element of the tuple is the new created cluster. The second element is
--   the new resulting cluster structure
mergeClusters :: ID -> ID -> ClusterMap a -> State (ClusterState a b) (Cluster a, ClusterMap a, ClusterMap a)

-- | extracts the original values from the cluster map. It runs in the
--   state monad as it needs the mapping of vectors to original values.
extractClusterElements :: Ord a => ClusterMap a -> State (ClusterState a b) [[b]]

-- | the minimum map saves the distance matrix as a multi set, because a
--   distance can occur more than one times. The set allows to find a
--   distance pair by its ids and is used to find the minimum distance in
--   <i>O(log n)</i> Note: Alternatively one could use kind of a binary
--   heap to find the minimum distance in <i>O(1)</i> Storage complexity is
--   <i>O(n^2)</i>
type MinimumMap a = MultiSet (a, Pair ID)

-- | Like the minimum map but with the pairs as the keys, thus allowing to
--   find the distance of a given pair in <i>O(log n)</i>. Storage
--   complexity is <i>O(n^2)</i>
type CombinationMap a = Map (Pair ID) a

-- | a pair of ID is used for mappings from and to distances between two
--   clusters.
type Pair a = (a, a)

-- | no abortion means that the cluster process is only limited by its
--   maximum number of possible steps that is: <i>n</i> - 1 where <i>n</i>
--   is the number of elements to be clustered
noAbort :: AbortCriterium a b

-- | defines the max. "costs" of a further combining of two clusters. This
--   can be the increase of the euclidean distance e.g. as well as the
--   varianceSum
maxTotal :: Ord a => a -> AbortCriterium a b

-- | sets a max. number of clusters
nCluster :: Int -> AbortCriterium a b

-- | sets a number of steps that has to be done
nSteps :: Int -> AbortCriterium a b

-- | defines a tolerance for the homogeneity of the clusters that is the
--   relation of the inner varianceSum of the recently created cluster and
--   the outer varianceSum of all other clusters Developed by Calinski and
--   Habarasz, see:
calinski :: (Ord a, Floating a) => a -> AbortCriterium a b

-- | calculates the ellbow criterium that is to find a cluster steps which
--   costs are above average. The first parameter gives a number of steps
--   that are tolerated as a kind of stabilization phase. So if minSteps is
--   set to k than ellbow criterium starts calculation average at step k+1.
--   The second parameter gives the max. allowed multiple of average
--   inclination
ellbow :: (Ord a, Num a, Floating a) => Int -> a -> AbortCriterium a b

-- | a distance function determines how to calculate the distance between
--   two vectors
type DistanceFunction a = Vector a -> Vector a -> a

-- | calculates the difference of two clusters by comparing them as a
--   whole, e.g. the sum of variances of the clusters can be used
type SimilarityFunction a = [Vector a] -> a

-- | <i>O(n^2 log n)</i>. Uses the single linkage method for clustering
singleLinkage :: (Ord a, Eq a) => DistanceFunction a -> ClusterFunction a

-- | <i>O(n^2 log n)</i>. Uses the complete linkage method for clustering
completeLinkage :: (Ord a, Eq a) => DistanceFunction a -> ClusterFunction a

-- | <i>O(n^2 log n)</i>. Uses the average linkage method for clustering
averageLinkage :: (Ord a, Floating a) => DistanceFunction a -> ClusterFunction a

-- | <i>O(n^2 log n)</i>. Uses the ward linkage method for clustering
wardLinkage :: Ord a => SimilarityFunction a -> ClusterFunction a
pairwise :: Ord a => DistanceFunction a -> Cluster a -> Cluster a -> [a]
clusterwise :: SimilarityFunction a -> ClusterFunction a
addition :: Num a => CostFunction a
varianceSum :: Floating a => CostFunction a

-- | transforms the input data into a vector representation
type Transformation a b = a -> Vector b
cluster :: (Ord a, Num a) => Transformation b a -> ClusterFunction a -> CostFunction a -> [AbortCriterium a b] -> [b] -> (ClusterResult b, ClusterInfo a b)

-- | a wrapper for the acutal clustering function running in the state
--   monad receiving the needed parameters to transform them for it
runCluster :: (Ord a, Num a) => (b -> Vector a) -> ClusterFunction a -> CostFunction a -> [AbortCriterium a b] -> [b] -> State (ClusterState a b) (ClusterMap a)
instance Show a => Show (Cluster a)
instance (Show a, Show b) => Show (ClusterInfo a b)
instance (Show a, Show b) => Show (ClusterState a b)
