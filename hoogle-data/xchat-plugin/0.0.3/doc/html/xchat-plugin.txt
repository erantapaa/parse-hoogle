-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | XChat
--   
--   This package adds bindings to the plugins system of XChat to Haskell.
--   Refer to the README file.
@package xchat-plugin
@version 0.0.3

module Network.IRC.XChat.Plugin

-- | The plugin descriptor
data PluginDescriptor
PluginDescriptor :: String -> String -> String -> PluginDescriptor
pluginName :: PluginDescriptor -> String
pluginDescription :: PluginDescriptor -> String
pluginVersion :: PluginDescriptor -> String
data XchatPlugin a

-- | The type of plugins; it is associated to a memory which can be used
--   and modified by the hooked callbacks.
--   
--   All the following functions needs a <tt><a>XChatPlugin</a></tt> as
--   argument. In fact it is a handle which needs to be initialized by the
--   <tt>init</tt> function, and will be freed by an optional
--   <tt>deinit</tt> function.
data XChatPlugin a

-- | The plugin initializer. NEVER call it, it is only used by
--   <tt>hsxchat</tt>.
xChatPluginInit :: Ptr (XchatPlugin a) -> a -> IO (XChatPlugin a)
xChatGetChanList :: XChatPlugin a -> IO [Chan]
data ChanFlgs
ChanFlgs :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ChanFlgs

-- | Already connected
connected :: ChanFlgs -> Bool

-- | Connecting in progress
connecting :: ChanFlgs -> Bool

-- | You are away
away :: ChanFlgs -> Bool

-- | Login complete
logged :: ChanFlgs -> Bool

-- | Has WHOX (ircu)
whox :: ChanFlgs -> Bool

-- | Has IDMSG (FreeNode)
idmsg :: ChanFlgs -> Bool

-- | Hide Join/Part messages unused flag not figuring in the ChanFlgs
jPmsg :: ChanFlgs -> Bool

-- | Beep on message
beep :: ChanFlgs -> Bool

-- | Blink tray
blinkTray :: ChanFlgs -> Bool

-- | Blink task bar
blinkTask :: ChanFlgs -> Bool
data ChanType
ChanServer :: ChanType
ChanChannel :: ChanType
ChanDialog :: ChanType
data Chan
Chan :: String -> String -> XChatContext -> ChanFlgs -> Int32 -> Int32 -> Int32 -> String -> String -> String -> Int32 -> String -> ChanType -> Int32 -> Chan

-- | Channel or query name
cChannel :: Chan -> String

-- | Channel type e.g. "#!&amp;"
cChantypes :: Chan -> String

-- | Context of the channel
cContext :: Chan -> XChatContext

-- | Server/Channel bits
cFlags :: Chan -> ChanFlgs

-- | Unique server ID
cId :: Chan -> Int32

-- | Lag in milliseconds
cLag :: Chan -> Int32

-- | Maximum modes per line
cMaxmodes :: Chan -> Int32

-- | Network name of the channel
cNetwork :: Chan -> String

-- | Nickname prefixes e.g. "@+"
cNickprefixes :: Chan -> String

-- | Nickname mod chars e.g. "ov"
cNickmodes :: Chan -> String

-- | Number of bytes in send-queue
cQueue :: Chan -> Int32

-- | Server name of the channel
cServer :: Chan -> String

-- | Type of context
cType :: Chan -> ChanType

-- | Number of users in the channel
cUsers :: Chan -> Int32
xChatGetDccList :: XChatPlugin a -> IO [Dcc]
data DccStatus
DccQueued :: DccStatus
DccActive :: DccStatus
DccFailed :: DccStatus
DccDone :: DccStatus
DccConnecting :: DccStatus
DccAborted :: DccStatus
data DccType
DccSend :: DccType
DccReceive :: DccType
DccChatRecv :: DccType
DccChatSend :: DccType
data Dcc
Dcc :: Int32 -> Int32 -> String -> String -> String -> Int32 -> Int32 -> Int32 -> Int64 -> DccStatus -> DccType -> Dcc

-- | ipv4 address of remote user (dunno how to have ipv6)
dAddress32 :: Dcc -> Int32

-- | Bytes per seconds
dCps :: Dcc -> Int32

-- | Destination full pathname
dDestfile :: Dcc -> String

-- | File name
dFile :: Dcc -> String

-- | Nickname of the person who the file is from/to (Receive/Send mode)
dNick :: Dcc -> String

-- | TCP port number
dPort :: Dcc -> Int32

-- | Bytes send/received up to now for the current transfert
dPos :: Dcc -> Int32

-- | Offset of file from which it is resumed (0 if not resumed)
dResume :: Dcc -> Int32

-- | File size in bytes
dSize :: Dcc -> Int64

-- | Status of the DCC transfert
dStatus :: Dcc -> DccStatus

-- | Type of the DCC transfert
dType :: Dcc -> DccType
xChatGetIgnList :: XChatPlugin a -> IO [Ign]
data IgnFlgs
IgnFlgs :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IgnFlgs
private :: IgnFlgs -> Bool
notice :: IgnFlgs -> Bool
channel :: IgnFlgs -> Bool
ctcp :: IgnFlgs -> Bool
invite :: IgnFlgs -> Bool
unIgnore :: IgnFlgs -> Bool
noSave :: IgnFlgs -> Bool
dcc :: IgnFlgs -> Bool
data Ign
Ign :: String -> IgnFlgs -> Ign

-- | Ignore mask. .e.g: *!*@*.aol.com
iMask :: Ign -> String

-- | Flags
iFlags :: Ign -> IgnFlgs
xChatGetNotifyList :: XChatPlugin a -> IO [Notify]
data Notify
Notify :: [String] -> String -> Bool -> Int32 -> Int32 -> Int32 -> Notify

-- | Networks to which this nick applies
nNetworks :: Notify -> [String]

-- | Nickname
nNick :: Notify -> String

-- | Currently on-line
nOnline :: Notify -> Bool

-- | Time when nick came online
nOn :: Notify -> Int32

-- | Time when nick went offline
nOff :: Notify -> Int32

-- | Time when nick was last seen
nSeen :: Notify -> Int32
xChatGetUserList :: XChatPlugin a -> IO [User]
data User
User :: Bool -> Int32 -> String -> Maybe String -> String -> Maybe String -> Bool -> User

-- | Away status
uAway :: User -> Bool

-- | Last time when user talked
uLasttalk :: User -> Int32

-- | Nickname
uNick :: User -> String

-- | Host name, <i>user</i>@<i>host</i>
uHost :: User -> Maybe String

-- | e.g. @ or +
uPrefix :: User -> String

-- | Real name
uRealname :: User -> Maybe String

-- | If user belongs to the focused tab
uSelected :: User -> Bool

-- | The type of hooks; it has three type arguments.
--   
--   <ul>
--   <li>The first is the type of the plugin memory</li>
--   <li>The second one is the type returned at hook creation, it can be
--   used to restore the memory at unhooking time, or to print some
--   debugging information.</li>
--   <li>The third one is the type returned at unhooking time, it can be
--   used to display debugging information.</li>
--   </ul>
data XChatHook a b c

-- | The way callbacks are managed; a callback function can be eat an
--   event, that is make the event unprocessable, either to XChat or to the
--   other plgins.
data Eating
Eating :: Bool -> Bool -> Eating
eatXChat :: Eating -> Bool
eatPlugin :: Eating -> Bool

-- | The returned type of all hooking functions; if <i>f</i> is a
--   <tt><a>Hook</a> <i>a</i> <i>b</i> <i>c</i> <i>d</i></tt> hooking
--   function, then:
--   
--   <pre>
--   <i>f</i> <i>ph</i> <i>cb</i> <i>init</i>
--   </pre>
--   
--   means that a new <tt><a>XChatHook</a> <i>a</i> <i>b</i> <i>c</i></tt>
--   hook using the callback <tt><i>cb</i></tt> function is created for the
--   <tt><i>ph</i></tt> plugin; the hooking modifies the <tt><i>a</i></tt>
--   plugin memory according to <tt><i>init</i></tt>, and returns the
--   <tt><i>b</i></tt> returned by <tt><i>init</i></tt> as well as the
--   created hook.
--   
--   The callback function itself is a function which takes some
--   <tt><i>d</i></tt> data, the <tt><i>a</i></tt> plugin memory at the
--   moment when the callback function is called and returns how the event
--   which triggered the callback call is eaten as well as the new
--   <tt><i>a</i></tt> plugin memory.
type Hook a b c d = XChatPlugin a -> (d -> a -> IO (Eating, a)) -> (a -> IO (b, a)) -> IO (b, XChatHook a b c)

-- | a concrete type to define the priority of a command
data PriorityC

-- | Highest priority (127)
Highest :: PriorityC

-- | High priority (64)
High :: PriorityC

-- | Normal priority (0)
Norm :: PriorityC

-- | Low priority (-64)
Low :: PriorityC

-- | Lowest priority (-128)
Lowest :: PriorityC

-- | Custom, is normalized when cast to <a>PriorityA</a>
Custom :: Int32 -> PriorityC

-- | an abstract type to define the priority of a command
data PriorityA

-- | to get a (normalized) abstract priority from a concrete one
abstractPriority :: PriorityC -> PriorityA

-- | to get a concrete priority from an abstract one
concretePriority :: PriorityA -> PriorityC

-- | flags for file descriptors
data Flags
Flags :: Bool -> Bool -> Bool -> Bool -> Flags
fgRead :: Flags -> Bool
fgWrite :: Flags -> Bool
fgExn :: Flags -> Bool
fgNsock :: Flags -> Bool

-- | <pre>
--   <a>xChatHookCommand</a> <i>cmd</i> <i>pri</i> <i>help</i>
--   </pre>
--   
--   <i>Description:</i>
--   
--   Hooking to the <tt>/<i>cmd</i></tt> input box command at priority
--   <tt><i>pri</i></tt> with an optional <tt><i>help</i></tt> message.
--   
--   To capture text without a '<tt>/</tt>' at the start (non-commands),
--   you may hook a special name of "" as in:
--   
--   <pre>
--   let eatAll           = <a>Eating</a> { <a>eatXChat</a> = <a>True</a>, <a>eatPlugin</a> = <a>True</a> }
--       startWithYou s a = <a>xChatPrint</a> p ("you: "<a>++</a>s) <a>&gt;&gt;</a> <a>return</a> (eatAll, a)
--   in  <a>xChatHookCommand</a> "" <a>Norm</a> <a>Nothing</a> p startWithYou ()
--   </pre>
--   
--   which automatically adds "<tt>you: </tt>" at the beginning of each
--   sentence you type (and is undocumented as the help message argument is
--   <tt><a>Nothing</a></tt>).
--   
--   Commands hooked that begin with a period ('.') will be hidden in
--   <tt>/HELP</tt> and <tt>/HELP -l</tt>.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>cmd</i> The command (without the forward slash) with some
--   special treatment if it is the empty string or if it begins with a
--   dot</li>
--   <li><i>pri</i> Priority of the hook, you should probably use
--   <a>Norm</a></li>
--   <li><i>help</i> Optionnal help message, displayed at <tt>/HELP
--   <i>cmd</i></tt> command</li>
--   </ul>
--   
--   <i>Callback Function Main Argument:</i>
--   
--   The callback function expects a string containing all the arguments
--   passed to the command.
xChatHookCommand :: String -> PriorityA -> Maybe String -> Hook a b c String

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatHookServer</a> <i>ev</i> <i>pri</i>
--   </pre>
--   
--   Hooking to the server event <tt><i>ev</i></tt> at priority
--   <tt><i>pri</i></tt>.
--   
--   To capture all server events, use <tt>"RAW LINE"</tt>.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ev</i> The server event to be captured</li>
--   <li><i>pri</i> Priority of the hook, you should probably use
--   <a>Norm</a></li>
--   </ul>
--   
--   <i>Callback Function Main Argument:</i>
--   
--   The callback function expects a string containing all the arguments of
--   the captured server event.
xChatHookServer :: String -> PriorityA -> Hook a b c String

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatHookPrint</a> <i>prev</i> <i>pri</i>
--   </pre>
--   
--   Hooking to the print event <tt><i>prev</i></tt> at priority
--   <tt><i>pri</i></tt>.
--   
--   Available events are those in "Advanced &gt; Text Events" plus these
--   ones:
--   
--   <ul>
--   <li><i><tt>"Open Context"</tt></i> Called when a new
--   <a>XChatContext</a> is created.</li>
--   <li><i><tt>"Close Context"</tt></i> Called when a xchat_context
--   pointer is closed.</li>
--   <li><i><tt>"Focus Tab"</tt></i> Called when a tab is brought to
--   front.</li>
--   <li><i><tt>"Focus Window"</tt></i> Called a toplevel window is
--   focused, or the main tab-window is focused by the window manager.</li>
--   <li><i><tt>"DCC Chat Text"</tt></i> Called when some text from a DCC
--   Chat arrives. It provides these arguments for the callback function:
--   <tt>[_, Address, Port, Nick, The Message]</tt></li>
--   <li><i><tt>"Key Press"</tt></i> Called when some keys are pressed in
--   the input-box. It provides these arguments for the callback function:
--   <tt>[_, Key Value, State Bitfield (shift, capslock, alt), String
--   version of the key, Length of the string (may be 0 for unprintable
--   keys)]</tt></li>
--   </ul>
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>prev</i> The print event to be captured</li>
--   <li><i>pri</i> Priority of the hook, you should probably use
--   <a>Norm</a></li>
--   </ul>
--   
--   <i>Callback Function Main Argument:</i>
--   
--   The callback function expects a list of strings containing all the
--   arguments of the captured print event.
xChatHookPrint :: String -> PriorityA -> Hook a b c [String]

-- | <i>Description:</i>
--   
--   <pre>
--   <tt>xChatHookTimeout</tt> <i>timeout</i>
--   </pre>
--   
--   Hooking to call a function every <tt><i>timeout</i></tt> milliseconds.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>timeout</i> The time(ms) to wait before the next triggering of
--   the callback.</li>
--   </ul>
--   
--   <i>Callback Function Main Argument:</i>
--   
--   The callback function expects just a unit type.
xChatHookTimer :: Int32 -> Hook a b c ()

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatHookFd</a> <i>fd</i> <i>flgs</i>
--   </pre>
--   
--   Hooking to the file descriptor <tt><i>fd</i></tt> with flags
--   <tt><i>flgs</i></tt>. The callback function is called every time the
--   file descriptor is available to an action described by the flags.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>fd</i> The file descriptor or socket</li>
--   <li><i>flgs</i> The flags of the file descriptor</li>
--   </ul>
--   
--   <i>Callback Function Main Argument:</i>
--   
--   The callback function expects a file descriptor and a flag (that may
--   be removed in a newer version).
xChatHookFd :: Fd -> Flags -> Hook a b c (Fd, Flags)

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatUnhook</a> <i>ph</i> <i>hook</i> <i>restore</i>
--   </pre>
--   
--   Unhooking of the given <tt><i>hook</i></tt>. According to the xchat
--   plugin documentation, hooks are automatically removed at deinit time.
--   But you may wish for some reason to hook or unhook dynamically some
--   function. There is an argument that allows you to modify the memory at
--   unhook time. For example, if you have a counter, your memory could be
--   a <tt><a>Maybe</a> <a>Int</a></tt>. When you hook, you may want to put
--   it <tt><a>Just</a> 0</tt> and when you unhook to put it back to
--   <tt><a>Nothing</a></tt>.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle of which we want to unhook.</li>
--   <li><i>hook</i> The hook to remove from the plugin.</li>
--   <li><i>restore</i> The function to be called on the memory of the
--   plugin.</li>
--   </ul>
xChatUnhook :: XChatPlugin a -> XChatHook a b c -> (a -> IO (c, a)) -> IO c

-- | the type of contexts
data XChatContext

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatSetContext</a> <i>ph</i> <i>ctx</i>
--   </pre>
--   
--   Changes the current context.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle whose context is to be changed.</li>
--   <li><i>ctx</i> Context (given by <tt><a>xChatGetContext</a></tt> or
--   <tt><a>xChatFindContext</a></tt>).</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   <tt><a>True</a></tt> if successful, <tt><a>False</a></tt> else.
xChatSetContext :: XChatPlugin a -> XChatContext -> IO Bool

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatFindContext</a> <i>ph</i> <i>servname</i> <i>channel</i>
--   </pre>
--   
--   Finds a context based on a channel and servername.
--   
--   If <tt><i>servname</i></tt> is <tt><a>Nothing</a></tt>, it finds the
--   channel (or query) by the given name in the same server group as the
--   current context. If that doesn't exists then find any by the given
--   name.
--   
--   If channel is <tt><a>Nothing</a></tt>, it finds the front-most
--   tab/window of the given servname.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle.</li>
--   <li><i>servname</i> Servername.</li>
--   <li><i>channel</i> Channelname.</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   Context (for use with xChatSetContext).
xChatFindContext :: XChatPlugin a -> Maybe String -> Maybe String -> IO XChatContext

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatGetContext</a> <i>ph</i>
--   </pre>
--   
--   Get the current context.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle whose context is to be taken.</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   The current context.
xChatGetContext :: XChatPlugin a -> IO XChatContext

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatPrint</a> <i>ph</i> <i>text</i>
--   </pre>
--   
--   Displays some text in the xchat window.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle which manages the printing.</li>
--   <li><i>text</i> The text to display. May contain mIRC color
--   codes.</li>
--   </ul>
xChatPrint :: XChatPlugin a -> String -> IO ()

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatCommand</a> <i>ph</i> <i>cmd</i>
--   </pre>
--   
--   Executes a command as if it were typed in xchat's input box.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle which manages the command.</li>
--   <li><i>text</i> The command to execute without the heading '/'.</li>
--   </ul>
xChatCommand :: XChatPlugin a -> String -> IO ()

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatNickcmp</a> <i>ph</i> <i>s1</i> <i>s2</i>
--   </pre>
--   
--   Performs a nick name comparision, based on the current server
--   connection. This might be a RFC1459 compliant string compare, or plain
--   ascii (in the case of DALNet). Use this to compare channels and
--   nicknames. The function works the same way as strcasecmp.
--   
--   <i>Quote from RFC1459:</i>
--   
--   Because of IRC's scandanavian origin, the characters {}| are
--   considered to be the lower case equivalents of the characters []\,
--   respectively. This is a critical issue when determining the
--   equivalence of two nicknames.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle whose context is to be taken.</li>
--   <li><i>s1</i> 1st string to compare</li>
--   <li><i>s2</i> 2nd string to compare</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   The comparison of the two strings.
xChatNickcmp :: XChatPlugin a -> String -> String -> IO Ordering

-- | The result of a setting request
data SettingResult
SetFailure :: SettingResult
SetString :: String -> SettingResult
SetBool :: Bool -> SettingResult
SetInt :: Int32 -> SettingResult

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatGetPrefs</a> <i>ph</i> <i>pref</i>
--   </pre>
--   
--   Provides xchat's setting information (that which is available through
--   the "/set" command). A few extra bits of information are available
--   that don't appear in the "/set list", currently they are:
--   
--   <ul>
--   <li><i>state_cursor</i> Current input-box cursor position (characters,
--   not bytes).</li>
--   <li><i>id</i> Unique server id.</li>
--   </ul>
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle.</li>
--   <li><i>pref</i> Setting name required.</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   A failure, a <tt><a>String</a></tt>, a <tt><a>Bool</a></tt> or an
--   <tt><a>Int32</a></tt> according to the <tt><a>SettingResult</a></tt>
--   case.
xChatGetPrefs :: XChatPlugin a -> String -> IO SettingResult

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatGetInfo</a> <i>ph</i> <i>info</i>
--   </pre>
--   
--   Returns information based on your current context.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle.</li>
--   <li><i>id</i> ID of the information you want. Currently supported IDs
--   are (case sensitive):</li>
--   </ul>
--   
--   <ul>
--   <li>[away] away reason or <tt><a>Nothing</a></tt> if you are not
--   away.</li>
--   <li>[channel] current channel name.</li>
--   <li>[charset] character-set used in the current context.</li>
--   <li>[event_text] text event format string for name.</li>
--   <li>[host] real hostname of the server you connected to.</li>
--   <li>[inputbox] the input-box contents, what the user has typed.</li>
--   <li>[libdirfs] library directory. e.g. /usr/lib/xchat. The same
--   directory used for auto-loading plugins. This string isn't necessarily
--   UTF-8, but local file system encoding.</li>
--   <li>[modes] channel modes, if known, or <tt><a>Nothing</a></tt>.</li>
--   <li>[network] current network name or <tt><a>Nothing</a></tt>.</li>
--   <li>[nick] your current nick name.</li>
--   <li>[nickserv] nickserv password for this network or
--   <tt><a>Nothing</a></tt>.</li>
--   <li>[server] current server name (what the server claims to be).
--   <tt><a>Nothing</a></tt> if you are not connected.</li>
--   <li>[topic] current channel topic.</li>
--   <li>[version] xchat version number.</li>
--   <li>[win_ptr] native window pointer. Unix: (GtkWindow *) Win32:
--   HWND.</li>
--   <li>[win_status] window status: "active", "hidden" or "normal".</li>
--   <li>[xchatdir] xchat config directory, e.g.: /home/user/.xchat2 This
--   string is encoded in UTF-8, which means you _should_ convert it to
--   "locale" encoding before using functions like open() or OpenFile().
--   For best Unicode support on Linux, convert this string using
--   g_filename_from_utf8 and on Windows convert this string to UTF-16LE
--   (wide) and use OpenFileW() etc.</li>
--   <li>[xchatdirfs] xchat config directory, e.g.: /home/user/.xchat2.
--   This string is encoded in local file system encoding, making it ideal
--   for direct use with functions like open() or OpenFile(). For real
--   Unicode support on Windows, it's best not to use xchatdirfs, but
--   xchatdir instead.</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   A string of the requested information, or <tt><a>Nothing</a></tt>.
xChatGetInfo :: XChatPlugin a -> String -> IO (Maybe String)

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatEmitPrint</a> <i>ph</i> <i>ev</i> <i>args</i>
--   </pre>
--   
--   Generates a print event. This can be any event found in the
--   Preferences &gt; Advanced &gt; Text Events window. The
--   <tt><i>args</i></tt> are the arguments of the event. Special care
--   should be taken when calling this function inside a print callback
--   (from <tt><a>xChatHookPrint</a></tt>), as not to cause endless
--   recursion.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> Plugin handle.</li>
--   <li><i>ev</i> Text event to print.</li>
--   <li><i>args</i> Arguments of the event to print.</li>
--   </ul>
--   
--   <i>Returns:</i>
--   
--   <tt><a>True</a></tt> in case of success <tt><a>False</a></tt> else.
--   
--   <i>Example:</i>
--   
--   <pre>
--   <a>xChatEmitPrint</a> "Channel Message" ["John", "Hi there", "@"]
--   </pre>
xChatEmitPrint :: XChatPlugin a -> String -> [String] -> IO Bool

-- | <i>Description:</i>
--   
--   <tt> <a>xChatSendModes</a> <i>ph</i> <i>str_list</i> <i>mpl</i>
--   <i>sgn</i> <i>mode</i> </tt> Sends a number of channel mode changes to
--   the current channel. For example, you can Op a whole group of people
--   in one go. It may send multiple MODE lines if the request doesn't fit
--   on one. Pass <tt><a>Nothing</a></tt> for <i>mpl</i> to use the current
--   server's maximum possible. This function should only be called while
--   in a channel context.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle</li>
--   <li><i>str_list</i> The targets</li>
--   <li><i>mpl</i> The number of modes per line</li>
--   <li><i>sgn</i> The sign (<tt>True</tt> is '+', <tt>False</tt> is
--   '-')</li>
--   <li><i>mode</i> The mode char, e.g. 'o' for Ops</li>
--   </ul>
--   
--   <i>Example:</i>
--   
--   <pre>
--   <a>xChatSendModes</a> "Alice":"Bob":[] 3 True 'o'
--   </pre>
xChatSendModes :: XChatPlugin a -> [String] -> Maybe Int32 -> Bool -> Char -> IO ()

-- | flags on how to strip rules
data StripRules
StripRules :: Bool -> Bool -> StripRules
noColor :: StripRules -> Bool
noAttribute :: StripRules -> Bool

-- | <i>Description:</i>
--   
--   <pre>
--   <a>xChatStrip</a> <i>str</i> <i>rules</i>
--   </pre>
--   
--   Strips mIRC color codes and/or text attributes (bold, underlined etc)
--   from the given string and returns a new string. The original function
--   had an unused plugin handle.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>str</i> The string to strip</li>
--   <li><i>rules</i> The description of the plugin to add</li>
--   </ul>
xChatStrip :: String -> StripRules -> IO String

-- | <ul>
--   <li><i>Undocumented</i></li>
--   </ul>
--   
--   <i>Description:</i>
--   
--   <pre>
--   <a>xChatPluginguiAdd</a> <i>ph</i> <i>filename</i> <i>pdesc</i>
--   </pre>
--   
--   Add of a new GUI plugin to the list of the current plugins. Due to
--   lack of documentation, it is not further documented. In the original
--   source code, such added plugins are tagged 'fake'. It seems that
--   beside their name, file name, version, description and position in the
--   list, there is no memory allocation. Furthermore, the original code
--   had an extra unused argument.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle to be used by default if the
--   USE_PLUGIN directive was not given at compile time for XChat, if the
--   USE_PLUGIN directive was provided, a new plugin handle is created,
--   with the data of [ph] passed by</li>
--   <li><i>filename</i> The path name of the file containing the plugin to
--   add</li>
--   <li><i>pdesc</i> The description of the plugin to add</li>
--   </ul>
xChatPluginguiAdd :: XChatPlugin a -> String -> PluginDescriptor -> IO (XChatPlugin a)

-- | <ul>
--   <li><i>Undocumented</i></li>
--   </ul>
--   
--   <i>Description:</i>
--   
--   <pre>
--   <a>xChatPluginguiRemove</a> <i>ph</i>
--   </pre>
--   
--   The counterpart of <tt><a>xChatPluginguiAdd</a></tt> function. So it
--   is used to remove 'fake' plugins. Once again, one of the arguments is
--   unused in the original source code, so I removed it.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>ph</i> The plugin handle to be removed</li>
--   </ul>
xChatPluginguiRemove :: XChatPlugin a -> IO ()

-- | <ul>
--   <li><i>Undocumented</i></li>
--   </ul>
--   
--   <i>Description:</i>
--   
--   <pre>
--   <a>xChatGettext</a> <i>str</i>
--   </pre>
--   
--   Converts a string to its internal XChat representation. I
--   automatically free it to avoid memory leak, although as I don't know
--   what it really does, it may be a bad idea. The original code had an
--   unused plugin handle.
--   
--   <i>Arguments:</i>
--   
--   <ul>
--   <li><i>str</i> The string to convert</li>
--   </ul>
xChatGettext :: String -> IO String
instance Eq PriorityA
instance Ord PriorityA


-- | A sample module, to test the plugin compiler
module Network.IRC.XChat.Examples.AutoOp
pluginInit :: (NBool -> IO (XChatPlugin NBool)) -> IO PluginDescriptor
type NBool = Bool


module Network.IRC.XChat.Examples.CountDown
pluginInit :: (Memo -> IO (XChatPlugin Memo)) -> IO PluginDescriptor
data Memo
