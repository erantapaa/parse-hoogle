-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient hash-consing for arbitrary data types
--   
--   Changes from 0.8 to 0.9
--   
--   <ul>
--   <li>Removed <a>identity</a> from the Interned class, to support
--   applications where the identity is obtained by other means (e.g. a
--   unique Ptr value)</li>
--   </ul>
--   
--   Changes from 0.7 to 0.8
--   
--   <ul>
--   <li>Disabled cache removal as it was causing problems on large data
--   sets. There is no good way to ensure that both references remain alive
--   long enough to finish comparisons.</li>
--   <li>Switched to IORef from MVar</li>
--   </ul>
--   
--   Changes from 0.6 to 0.7
--   
--   <ul>
--   <li>Fixed problem where comparisons could happen between data
--   structures while one was still a thunk, leading to equal structures
--   comparing as inequal in limited circumstances, by appropriately using
--   strictness annotations.</li>
--   </ul>
--   
--   Efficient hash-consing for arbitrary data types
--   
--   Changes from 0.5.2 to 0.6
--   
--   <ul>
--   <li>Widened the caches so they don't go through a single MVar per
--   type. This has made a dramatic impact on performance. However, this
--   broke the previous invariant that newer entries always had higher Ids
--   than older entries.</li>
--   </ul>
--   
--   Changes from 0.5.1 to 0.5.2
--   
--   <ul>
--   <li>Added Data.Interned.IntSet</li>
--   </ul>
@package intern
@version 0.9.1.4

module Data.Interned.Internal
class (Eq (Description t), Hashable (Description t)) => Interned t where data family Description t type family Uninterned t seedIdentity _ = 0 cacheWidth _ = defaultCacheWidth modifyAdvice = id
describe :: Interned t => Uninterned t -> Description t
identify :: Interned t => Id -> Uninterned t -> t
seedIdentity :: Interned t => p t -> Id
cacheWidth :: Interned t => p t -> Int
modifyAdvice :: Interned t => IO t -> IO t
cache :: Interned t => Cache t
class Interned t => Uninternable t
unintern :: Uninternable t => t -> Uninterned t
mkCache :: Interned t => Cache t
newtype Cache t
Cache :: Array Int (IORef (CacheState t)) -> Cache t
getCache :: Cache t -> Array Int (IORef (CacheState t))
data CacheState t
CacheState :: {-# UNPACK #-} !Id -> !(HashMap (Description t) t) -> CacheState t
fresh :: CacheState t -> {-# UNPACK #-} !Id
content :: CacheState t -> !(HashMap (Description t) t)
cacheSize :: Cache t -> IO Int
type Id = Int
intern :: Interned t => Uninterned t -> t
recover :: Interned t => Description t -> IO (Maybe t)


-- | An efficient implementation of integer sets.
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Data.IntSet (IntSet)
--   import qualified Data.IntSet as IntSet
--   </pre>
--   
--   The implementation is based on <i>big-endian patricia trees</i>. This
--   data structure performs especially well on binary operations like
--   <a>union</a> and <a>intersection</a>. However, my benchmarks show that
--   it is also (much) faster on insertions and deletions when compared to
--   a generic size-balanced set implementation (see <a>Data.Set</a>).
--   
--   <ul>
--   <li>Chris Okasaki and Andy Gill, "<i>Fast Mergeable Integer Maps</i>",
--   Workshop on ML, September 1998, pages 77-86,
--   <a>http://citeseer.ist.psu.edu/okasaki98fast.html</a><ul><li>D.R.
--   Morrison, "/PATRICIA -- Practical Algorithm To Retrieve Information
--   Coded In Alphanumeric/", Journal of the ACM, 15(4), October 1968,
--   pages 514-534.</li></ul></li>
--   </ul>
--   
--   Many operations have a worst-case complexity of <i>O(min(n,W))</i>.
--   This means that the operation can become linear in the number of
--   elements with a maximum of <i>W</i> -- the number of bits in an
--   <a>Int</a> (32 or 64).
--   
--   Unlike the reference implementation in Data.IntSet,
--   Data.Interned.IntSet uses hash consing to ensure that there is only
--   ever one copy of any given IntSet in memory. This is enabled by the
--   normal form of the PATRICIA trie.
--   
--   This can mean a drastic reduction in the memory footprint of a program
--   in exchange for much more costly set manipulation.
module Data.Interned.IntSet

-- | A set of integers.
data IntSet

-- | <i>O(n+m)</i>. See <a>difference</a>.
(\\) :: IntSet -> IntSet -> IntSet

-- | <i>O(1)</i>. Is the set empty?
null :: IntSet -> Bool

-- | <i>O(1)</i>. Cardinality of the set.
size :: IntSet -> Int

-- | <i>O(min(n,W))</i>. Is the value a member of the set?
member :: Int -> IntSet -> Bool

-- | <i>O(min(n,W))</i>. Is the element not in the set?
notMember :: Int -> IntSet -> Bool

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: IntSet -> IntSet -> Bool

-- | <i>O(n+m)</i>. Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: IntSet -> IntSet -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: IntSet

-- | <i>O(1)</i>. A set of one element.
singleton :: Int -> IntSet

-- | <i>O(min(n,W))</i>. Add a value to the set. When the value is already
--   an element of the set, it is replaced by the new one, ie.
--   <a>insert</a> is left-biased.
insert :: Int -> IntSet -> IntSet

-- | <i>O(min(n,W))</i>. Delete a value in the set. Returns the original
--   set when the value was not present.
delete :: Int -> IntSet -> IntSet

-- | <i>O(n+m)</i>. The union of two sets.
union :: IntSet -> IntSet -> IntSet

-- | The union of a list of sets.
unions :: [IntSet] -> IntSet

-- | <i>O(n+m)</i>. Difference between two sets.
difference :: IntSet -> IntSet -> IntSet

-- | <i>O(n+m)</i>. The intersection of two sets.
intersection :: IntSet -> IntSet -> IntSet

-- | <i>O(n)</i>. Filter all elements that satisfy some predicate.
filter :: (Int -> Bool) -> IntSet -> IntSet

-- | <i>O(n)</i>. partition the set according to some predicate.
partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)

-- | <i>O(min(n,W))</i>. The expression (<tt><a>split</a> x set</tt>) is a
--   pair <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements
--   of <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Int -> IntSet -> (IntSet, IntSet)

-- | <i>O(min(n,W))</i>. Performs a <a>split</a> but also returns whether
--   the pivot element was found in the original set.
splitMember :: Int -> IntSet -> (IntSet, Bool, IntSet)

-- | <i>O(min(n,W))</i>. The minimal element of the set.
findMin :: IntSet -> Int

-- | <i>O(min(n,W))</i>. The maximal element of a set.
findMax :: IntSet -> Int

-- | <i>O(min(n,W))</i>. Delete the minimal element.
deleteMin :: IntSet -> IntSet

-- | <i>O(min(n,W))</i>. Delete the maximal element.
deleteMax :: IntSet -> IntSet

-- | <i>O(min(n,W))</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: IntSet -> (Int, IntSet)

-- | <i>O(min(n,W))</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: IntSet -> (Int, IntSet)

-- | <i>O(min(n,W))</i>. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: IntSet -> Maybe (Int, IntSet)

-- | <i>O(min(n,W))</i>. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: IntSet -> Maybe (Int, IntSet)

-- | <i>O(n*min(n,W))</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Int -> Int) -> IntSet -> IntSet

-- | <i>O(n)</i>. Fold over the elements of a set in an unspecified order.
--   
--   <pre>
--   sum set   == fold (+) 0 set
--   elems set == fold (:) [] set
--   </pre>
fold :: (Int -> b -> b) -> b -> IntSet -> b

-- | <i>O(n)</i>. The elements of a set. (For sets, this is equivalent to
--   toList)
elems :: IntSet -> [Int]

-- | <i>O(n)</i>. Convert the set to a list of elements.
toList :: IntSet -> [Int]

-- | <i>O(n*min(n,W))</i>. Create a set from a list of integers.
fromList :: [Int] -> IntSet

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: IntSet -> [Int]

-- | <i>O(n)</i>. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Int] -> IntSet

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Int] -> IntSet

-- | <i>O(n)</i>. Show the tree that implements the set. The tree is shown
--   in a compressed, hanging format.
showTree :: IntSet -> String

-- | <i>O(n)</i>. The expression (<tt><a>showTreeWith</a> hang wide
--   map</tt>) shows the tree that implements the set. If <tt>hang</tt> is
--   <a>True</a>, a <i>hanging</i> tree is shown otherwise a rotated tree
--   is shown. If <tt>wide</tt> is <a>True</a>, an extra wide version is
--   shown.
showTreeWith :: Bool -> Bool -> IntSet -> String
instance Eq (Description IntSet)
instance Read IntSet
instance Show IntSet
instance Ord IntSet
instance Eq IntSet
instance Monoid IntSet
instance Uninternable IntSet
instance Hashable (Description IntSet)
instance Interned IntSet

module Data.Interned
class (Eq (Description t), Hashable (Description t)) => Interned t where data family Description t type family Uninterned t seedIdentity _ = 0 cacheWidth _ = defaultCacheWidth modifyAdvice = id
describe :: Interned t => Uninterned t -> Description t
identify :: Interned t => Id -> Uninterned t -> t
seedIdentity :: Interned t => p t -> Id
cacheWidth :: Interned t => p t -> Int
modifyAdvice :: Interned t => IO t -> IO t
cache :: Interned t => Cache t
class Interned t => Uninternable t
unintern :: Uninternable t => t -> Uninterned t
mkCache :: Interned t => Cache t
data Cache t
cacheSize :: Cache t -> IO Int
type Id = Int
intern :: Interned t => Uninterned t -> t

module Data.Interned.Internal.ByteString
data InternedByteString
InternedByteString :: {-# UNPACK #-} !Id -> {-# UNPACK #-} !ByteString -> InternedByteString
internedByteStringId :: InternedByteString -> {-# UNPACK #-} !Id
uninternByteString :: InternedByteString -> {-# UNPACK #-} !ByteString
instance Eq (Description InternedByteString)
instance Hashable (Description InternedByteString)
instance Uninternable InternedByteString
instance Interned InternedByteString
instance Show InternedByteString
instance Ord InternedByteString
instance Eq InternedByteString
instance IsString InternedByteString

module Data.Interned.ByteString
data InternedByteString

module Data.Interned.Internal.String
data InternedString
IS :: {-# UNPACK #-} !Id -> String -> InternedString
internedStringId :: InternedString -> {-# UNPACK #-} !Id
uninternString :: InternedString -> String
instance Eq (Description InternedString)
instance Hashable (Description InternedString)
instance Uninternable InternedString
instance Interned InternedString
instance Show InternedString
instance Ord InternedString
instance Eq InternedString
instance IsString InternedString

module Data.Interned.String
data InternedString

module Data.Interned.Internal.Text
data InternedText
InternedText :: {-# UNPACK #-} !Id -> {-# UNPACK #-} !Text -> InternedText
internedTextId :: InternedText -> {-# UNPACK #-} !Id
uninternedText :: InternedText -> {-# UNPACK #-} !Text
instance Eq (Description InternedText)
instance Hashable (Description InternedText)
instance Uninternable InternedText
instance Interned InternedText
instance Show InternedText
instance Ord InternedText
instance Eq InternedText
instance IsString InternedText

module Data.Interned.Text
data InternedText
