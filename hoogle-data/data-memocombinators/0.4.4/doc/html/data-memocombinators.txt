-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for building memo tables.
--   
--   Combinators for building memo tables.
@package data-memocombinators
@version 0.4.4


-- | This module provides combinators for building memo tables over various
--   data types, so that the type of table can be customized depending on
--   the application.
--   
--   This module is designed to be imported <i>qualified</i>, eg.
--   
--   <pre>
--   import qualified Data.MemoCombinators as Memo
--   </pre>
--   
--   Usage is straightforward: apply an object of type <tt>Memo a</tt> to a
--   function of type <tt>a -&gt; b</tt>, and get a memoized function of
--   type <tt>a -&gt; b</tt>. For example:
--   
--   <pre>
--   fib = Memo.integral fib'
--      where
--      fib' 0 = 0
--      fib' 1 = 1
--      fib' x = fib (x-1) + fib (x-2)
--   </pre>
module Data.MemoCombinators

-- | The type of a memo table for functions of a.
type Memo a = forall r. (a -> r) -> (a -> r)

-- | Given a memoizer for a and an isomorphism between a and b, build a
--   memoizer for b.
wrap :: (a -> b) -> (b -> a) -> Memo a -> Memo b

-- | Memoize a two argument function (just apply the table directly for
--   single argument functions).
memo2 :: Memo a -> Memo b -> (a -> b -> r) -> (a -> b -> r)

-- | Memoize a three argument function.
memo3 :: Memo a -> Memo b -> Memo c -> (a -> b -> c -> r) -> (a -> b -> c -> r)

-- | Memoize the second argument of a function.
memoSecond :: Memo b -> (a -> b -> r) -> (a -> b -> r)

-- | Memoize the third argument of a function.
memoThird :: Memo c -> (a -> b -> c -> r) -> (a -> b -> c -> r)
bool :: Memo Bool
char :: Memo Char
list :: Memo a -> Memo [a]

-- | Build a table which memoizes all lists of less than the given length.
boundedList :: Int -> Memo a -> Memo [a]
either :: Memo a -> Memo b -> Memo (Either a b)
maybe :: Memo a -> Memo (Maybe a)
unit :: Memo ()
pair :: Memo a -> Memo b -> Memo (a, b)

-- | Memoize an integral type.
integral :: Integral a => Memo a

-- | Memoize an ordered type with a bits instance.
bits :: (Num a, Ord a, Bits a) => Memo a

-- | <tt>switch p a b</tt> uses the memo table a whenever p gives true and
--   the memo table b whenever p gives false.
switch :: (a -> Bool) -> Memo a -> Memo a -> Memo a

-- | The type of builders for ranged tables; takes a lower bound and an
--   upper bound, and returns a memo table for that range.
type RangeMemo a = (a, a) -> Memo a

-- | Build a memo table for a range using a flat array. If items are given
--   outside the range, don't memoize.
arrayRange :: Ix a => RangeMemo a

-- | Build a memo table for a range using a flat array. If items are given
--   outside the range, behavior is undefined.
unsafeArrayRange :: Ix a => RangeMemo a

-- | Given a list of ranges, (lazily) build a memo table for each one and
--   combine them using linear search.
chunks :: Ix a => RangeMemo a -> [(a, a)] -> Memo a
