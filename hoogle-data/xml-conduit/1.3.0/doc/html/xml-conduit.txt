-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure-Haskell utilities for dealing with XML with the conduit package.
--   
@package xml-conduit
@version 1.3.0


-- | Generalized cursors to be applied to different nodes.
module Text.XML.Cursor.Generic

-- | A cursor: contains an XML <tt>Node</tt> and pointers to its children,
--   ancestors and siblings.
data Cursor node
type Axis node = Cursor node -> [Cursor node]
toCursor :: (node -> [node]) -> node -> Cursor node

-- | The current node.
node :: Cursor node -> node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
instance Show node => Show (Cursor node)


-- | <tt>Enumeratee</tt>s to render XML <a>Event</a>s. Unlike
--   libxml-enumerator and expat-enumerator, this module does not provide
--   IO and ST variants, since the underlying rendering operations are pure
--   functions.
module Text.XML.Stream.Render

-- | Render a stream of <a>Event</a>s into a stream of <a>Builder</a>s.
--   Builders are from the blaze-builder package, and allow the create of
--   optimally sized <a>ByteString</a>s with minimal buffer copying.
renderBuilder :: Monad m => RenderSettings -> Conduit Event m Builder

-- | Render a stream of <a>Event</a>s into a stream of <a>ByteString</a>s.
--   This function wraps around <a>renderBuilder</a> and
--   <a>builderToByteString</a>, so it produces optimally sized
--   <a>ByteString</a>s with minimal buffer copying.
--   
--   The output is UTF8 encoded. renderBytes :: Monad m =&gt;
--   RenderSettings -&gt; Conduit Event m ByteString
renderBytes :: (PrimMonad base, MonadBase base m) => RenderSettings -> ConduitM Event ByteString m ()

-- | Render a stream of <a>Event</a>s into a stream of <a>Text</a>s. This
--   function wraps around <a>renderBuilder</a>, <a>builderToByteString</a>
--   and <a>renderBytes</a>, so it produces optimally sized <a>Text</a>s
--   with minimal buffer copying.
renderText :: (PrimMonad base, MonadBase base m, MonadThrow m) => RenderSettings -> ConduitM Event Text m ()

-- | Convert a stream of <a>Event</a>s into a prettified one, adding extra
--   whitespace. Note that this can change the meaning of your XML.
prettify :: Monad m => Conduit Event m Event
data RenderSettings

-- | The default value for this type.
def :: Default a => a
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]

-- | Generate a complete XML <tt>Element</tt>.
tag :: Monad m => Name -> Attributes -> Source m Event -> Source m Event

-- | Generate a textual <a>EventContent</a>.
content :: Monad m => Text -> Source m Event

-- | A list of attributes.
data Attributes

-- | Generate a single attribute.
attr :: Name -> Text -> Attributes

-- | Helper function that generates a valid attribute if input isn't
--   <a>Nothing</a>, or <a>mempty</a> otherwise.
optionalAttr :: Name -> Maybe Text -> Attributes
instance Monoid Attributes
instance Default RenderSettings


-- | This module provides both a native Haskell solution for parsing XML
--   documents into a stream of events, and a set of parser combinators for
--   dealing with a stream of events.
--   
--   As a simple example, if you have the following XML file:
--   
--   <pre>
--   &lt;?xml version="1.0" encoding="utf-8"?&gt;
--   &lt;people&gt;
--       &lt;person age="25"&gt;Michael&lt;/person&gt;
--       &lt;person age="2"&gt;Eliezer&lt;/person&gt;
--   &lt;/people&gt;
--   </pre>
--   
--   Then this code:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Control.Monad.Trans.Resource
--   import Data.Conduit (($$))
--   import Data.Text (Text, unpack)
--   import Text.XML.Stream.Parse
--   
--   data Person = Person Int Text
--       deriving Show
--   
--   parsePerson = tagName "person" (requireAttr "age") $ \age -&gt; do
--       name &lt;- content
--       return $ Person (read $ unpack age) name
--   
--   parsePeople = tagNoAttr "people" $ many parsePerson
--   
--   main = do
--       people &lt;- runResourceT $
--               parseFile def "people.xml" $$ force "people required" parsePeople
--       print people
--   </pre>
--   
--   will produce:
--   
--   <pre>
--   [Person {age = 25, name = "Michael"},Person {age = 2, name = "Eliezer"}]
--   </pre>
--   
--   Previous versions of this module contained a number of more
--   sophisticated functions written by Aristid Breitkreuz and Dmitry
--   Olshansky. To keep this package simpler, those functions are being
--   moved to a separate package. This note will be updated with the name
--   of the package(s) when available.
module Text.XML.Stream.Parse

-- | Parses a byte stream into <a>Event</a>s. This function is implemented
--   fully in Haskell using attoparsec-text for parsing. The produced error
--   messages do not give line/column information, so you may prefer to
--   stick with the parser provided by libxml-enumerator. However, this has
--   the advantage of not relying on any C libraries.
--   
--   This relies on <a>detectUtf</a> to determine character encoding, and
--   <a>parseText'</a> to do the actual parsing.
parseBytes :: MonadThrow m => ParseSettings -> Conduit ByteString m Event
parseBytesPos :: MonadThrow m => ParseSettings -> Conduit ByteString m EventPos

-- | Parses a character stream into <a>Event</a>s. This function is
--   implemented fully in Haskell using attoparsec-text for parsing. The
--   produced error messages do not give line/column information, so you
--   may prefer to stick with the parser provided by libxml-enumerator.
--   However, this has the advantage of not relying on any C libraries.
--   
--   Since 1.2.4
parseText' :: MonadThrow m => ParseSettings -> Conduit Text m Event

-- | <i>Deprecated: Please use <a>parseText'</a> or
--   <a>parseTextPos</a>.</i>
parseText :: MonadThrow m => ParseSettings -> Conduit Text m EventPos

-- | Same as <a>parseText'</a>, but includes the position of each event.
--   
--   Since 1.2.4
parseTextPos :: MonadThrow m => ParseSettings -> Conduit Text m EventPos

-- | Automatically determine which UTF variant is being used. This function
--   first checks for BOMs, removing them as necessary, and then check for
--   the equivalent of &lt;?xml for each of UTF-8, UTF-16LE<i>BE, and
--   UTF-32LE</i>BE. It defaults to assuming UTF-8.
detectUtf :: MonadThrow m => Conduit ByteString m Text

-- | A helper function which reads a file from disk using
--   <tt>enumFile</tt>, detects character encoding using <a>detectUtf</a>,
--   parses the XML using <a>parseBytes</a>, and then hands off control to
--   your supplied parser.
parseFile :: MonadResource m => ParseSettings -> FilePath -> Producer m Event

-- | Parse an event stream from a lazy <a>ByteString</a>.
parseLBS :: MonadThrow m => ParseSettings -> ByteString -> Producer m Event
data ParseSettings

-- | The default value for this type.
def :: Default a => a
type DecodeEntities = Text -> Content
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Default implementation of <a>DecodeEntities</a>: handles numeric
--   entities and the five standard character entities (lt, gt, amp, quot,
--   apos).
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles numerics, the five standard
--   character entities, and the additional 248 entities defined by HTML 4
--   and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities

-- | The most generic way to parse a tag. It takes a predicate for checking
--   if this is the correct tag name, an <a>AttrParser</a> for handling
--   attributes, and then a parser for dealing with content.
--   
--   This function automatically absorbs its balancing closing tag, and
--   will throw an exception if not all of the attributes or child elements
--   are consumed. If you want to allow extra attributes, see
--   <a>ignoreAttrs</a>.
--   
--   This function automatically ignores comments, instructions and
--   whitespace.
tag :: MonadThrow m => (Name -> Maybe a) -> (a -> AttrParser b) -> (b -> ConduitM Event o m c) -> ConduitM Event o m (Maybe c)

-- | A simplified version of <a>tag</a> which matches against boolean
--   predicates.
tagPredicate :: MonadThrow m => (Name -> Bool) -> AttrParser a -> (a -> ConduitM Event o m b) -> ConduitM Event o m (Maybe b)

-- | A simplified version of <a>tag</a> which matches for specific tag
--   names instead of taking a predicate function. This is often
--   sufficient, and when combined with OverloadedStrings and the IsString
--   instance of <a>Name</a>, can prove to be very concise. . Note that
--   <tt>Name</tt> is namespace sensitive. When using the <tt>IsString</tt>
--   instance of name, use &gt; "{http:/<i>a</i>b}c" :: Name to match the
--   tag <tt>c</tt> in the XML namespace <tt><a>http://a/b</a></tt>
tagName :: MonadThrow m => Name -> AttrParser a -> (a -> ConduitM Event o m b) -> ConduitM Event o m (Maybe b)

-- | A further simplified tag parser, which requires that no attributes
--   exist.
tagNoAttr :: MonadThrow m => Name -> ConduitM Event o m a -> ConduitM Event o m (Maybe a)

-- | Grabs the next piece of content. If none if available, returns
--   <a>empty</a>. This is simply a wrapper around <a>contentMaybe</a>.
content :: MonadThrow m => Consumer Event m Text

-- | Grabs the next piece of content if available. This function skips over
--   any comments and instructions and concatenates all content until the
--   next start or end tag.
contentMaybe :: MonadThrow m => Consumer Event m (Maybe Text)

-- | A monad for parsing attributes. By default, it requires you to deal
--   with all attributes present on an element, and will throw an exception
--   if there are unhandled attributes. Use the <a>requireAttr</a>,
--   <a>optionalAttr</a> et al functions for handling an attribute, and
--   <a>ignoreAttrs</a> if you would like to skip the rest of the
--   attributes on an element.
--   
--   <a>Alternative</a> instance behave like <tt>First</tt> monoid. It
--   chooses first parser which doesn't fail.
data AttrParser a

-- | Return the value for an attribute if present.
attr :: Name -> AttrParser (Maybe Text)

-- | Shortcut composition of <a>force</a> and <a>attr</a>.
requireAttr :: Name -> AttrParser Text

-- | <i>Deprecated: Please use <a>attr</a>.</i>
optionalAttr :: Name -> AttrParser (Maybe Text)
requireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b
optionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)

-- | Skip the remaining attributes on an element. Since this will clear the
--   list of attributes, you must call this <i>after</i> any calls to
--   <a>requireAttr</a>, <a>optionalAttr</a>, etc.
ignoreAttrs :: AttrParser ()

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <tt>Just</tt>), this function returns
--   <a>Nothing</a>.
--   
--   <pre>
--   orE a b = choose [a, b]
--   </pre>
orE :: Monad m => Consumer Event m (Maybe a) -> Consumer Event m (Maybe a) -> Consumer Event m (Maybe a)

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <a>Just</a>), this function returns
--   <a>Nothing</a>.
choose :: Monad m => [Consumer Event m (Maybe a)] -> Consumer Event m (Maybe a)

-- | Keep parsing elements as long as the parser returns <a>Just</a>.
many :: Monad m => Consumer Event m (Maybe a) -> Consumer Event m [a]

-- | Force an optional parser into a required parser. All of the <a>tag</a>
--   functions, <a>attr</a>, <a>choose</a> and <a>many</a> deal with
--   <a>Maybe</a> parsers. Use this when you want to finally force
--   something to happen.
force :: MonadThrow m => String -> m (Maybe a) -> m a
data XmlException
XmlException :: String -> Maybe Event -> XmlException
xmlErrorMessage :: XmlException -> String
xmlBadInput :: XmlException -> Maybe Event
InvalidEndElement :: Name -> XmlException
InvalidEntity :: Text -> XmlException
UnparsedAttributes :: [(Name, [Content])] -> XmlException
data PositionRange :: *
type EventPos = (Maybe PositionRange, Event)
instance Typeable XmlException
instance Show XmlException
instance MonadThrow AttrParser
instance Alternative AttrParser
instance Applicative AttrParser
instance Functor AttrParser
instance Monad AttrParser
instance Exception XmlException
instance Default ParseSettings


-- | DOM-based XML parsing and rendering.
--   
--   In this module, attribute values and content nodes can contain either
--   raw text or entities. In most cases, these can be fully resolved at
--   parsing. If that is the case for your documents, the <a>Text.XML</a>
--   module provides simplified datatypes that only contain raw text.
module Text.XML.Unresolved
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
readFile :: ParseSettings -> FilePath -> IO Document
renderLBS :: RenderSettings -> Document -> ByteString
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> Consumer Text m Document
sinkDoc :: MonadThrow m => ParseSettings -> Consumer ByteString m Document
toEvents :: Document -> [Event]
fromEvents :: MonadThrow m => Consumer EventPos m Document
renderBuilder :: Monad m => RenderSettings -> Document -> Producer m Builder
renderBytes :: (PrimMonad base, MonadBase base m) => RenderSettings -> Document -> ConduitM a ByteString m ()
renderText :: (PrimMonad base, MonadBase base m, MonadThrow m) => RenderSettings -> Document -> ConduitM a Text m ()
data InvalidEventStream
ContentAfterRoot :: EventPos -> InvalidEventStream
MissingRootElement :: InvalidEventStream
InvalidInlineDoctype :: EventPos -> InvalidEventStream
MissingEndElement :: Name -> (Maybe EventPos) -> InvalidEventStream
UnterminatedInlineDoctype :: InvalidEventStream

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]
instance Typeable InvalidEventStream
instance Show InvalidEventStream
instance Exception InvalidEventStream


-- | DOM-based parsing and rendering.
--   
--   This module requires that all entities be resolved at parsing. If you
--   need to interact with unresolved entities, please use
--   <a>Text.XML.Unresolved</a>. This is the recommended module for most
--   uses cases.
--   
--   While many of the datatypes in this module are simply re-exported from
--   <tt>Data.XML.Types</tt>, <a>Document</a>, <a>Node</a> and
--   <a>Element</a> are all redefined here to disallow the possibility of
--   unresolved entities. Conversion functions are provided to switch
--   between the two sets of datatypes.
--   
--   For simpler, bidirectional traversal of the DOM tree, see the
--   <a>Text.XML.Cursor</a> module.
module Text.XML
data Document
Document :: Prologue -> Element -> [Miscellaneous] -> Document
documentPrologue :: Document -> Prologue
documentRoot :: Document -> Element
documentEpilogue :: Document -> [Miscellaneous]
data Prologue :: *
Prologue :: [Miscellaneous] -> Maybe Doctype -> [Miscellaneous] -> Prologue
prologueBefore :: Prologue -> [Miscellaneous]
prologueDoctype :: Prologue -> Maybe Doctype
prologueAfter :: Prologue -> [Miscellaneous]
data Instruction :: *
Instruction :: Text -> Text -> Instruction
instructionTarget :: Instruction -> Text
instructionData :: Instruction -> Text
data Miscellaneous :: *
MiscInstruction :: Instruction -> Miscellaneous
MiscComment :: Text -> Miscellaneous
data Node
NodeElement :: Element -> Node
NodeInstruction :: Instruction -> Node
NodeContent :: Text -> Node
NodeComment :: Text -> Node
data Element
Element :: Name -> Map Name Text -> [Node] -> Element
elementName :: Element -> Name
elementAttributes :: Element -> Map Name Text
elementNodes :: Element -> [Node]

-- | A fully qualified name.
--   
--   Prefixes are not semantically important; they are included only to
--   simplify pass-through parsing. When comparing names with <a>Eq</a> or
--   <a>Ord</a> methods, prefixes are ignored.
--   
--   The <tt>IsString</tt> instance supports Clark notation; see
--   <a>http://www.jclark.com/xml/xmlns.htm</a> and
--   <a>http://infohost.nmt.edu/tcc/help/pubs/pylxml/etree-QName.html</a>.
--   Use the <tt>OverloadedStrings</tt> language extension for very simple
--   <tt>Name</tt> construction:
--   
--   <pre>
--   myname :: Name
--   myname = "{http://example.com/ns/my-namespace}my-name"
--   </pre>
data Name :: *
Name :: Text -> Maybe Text -> Maybe Text -> Name
nameLocalName :: Name -> Text
nameNamespace :: Name -> Maybe Text
namePrefix :: Name -> Maybe Text

-- | Note: due to the incredible complexity of DTDs, this type only
--   supports external subsets. I've tried adding internal subset types,
--   but they quickly gain more code than the rest of this module put
--   together.
--   
--   It is possible that some future version of this library might support
--   internal subsets, but I am no longer actively working on adding them.
data Doctype :: *
Doctype :: Text -> Maybe ExternalID -> Doctype
doctypeName :: Doctype -> Text
doctypeID :: Doctype -> Maybe ExternalID
data ExternalID :: *
SystemID :: Text -> ExternalID
PublicID :: Text -> Text -> ExternalID
readFile :: ParseSettings -> FilePath -> IO Document
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
sinkDoc :: MonadThrow m => ParseSettings -> Consumer ByteString m Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> Consumer Text m Document
fromEvents :: MonadThrow m => Consumer EventPos m Document
data UnresolvedEntityException
UnresolvedEntityException :: (Set Text) -> UnresolvedEntityException
data XMLException
InvalidXMLFile :: FilePath -> SomeException -> XMLException
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
renderLBS :: RenderSettings -> Document -> ByteString
renderText :: RenderSettings -> Document -> Text
renderBytes :: (PrimMonad base, MonadBase base m) => RenderSettings -> Document -> ConduitM a ByteString m ()

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Default implementation of <a>DecodeEntities</a>: handles numeric
--   entities and the five standard character entities (lt, gt, amp, quot,
--   apos).
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles numerics, the five standard
--   character entities, and the additional 248 entities defined by HTML 4
--   and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]
toXMLDocument :: Document -> Document
fromXMLDocument :: Document -> Either (Set Text) Document
toXMLNode :: Node -> Node
fromXMLNode :: Node -> Either (Set Text) Node
toXMLElement :: Element -> Element
fromXMLElement :: Element -> Either (Set Text) Element
instance Typeable Element
instance Typeable Node
instance Typeable Document
instance Typeable XMLException
instance Typeable UnresolvedEntityException
instance Show Element
instance Eq Element
instance Ord Element
instance Data Element
instance Show Node
instance Eq Node
instance Ord Node
instance Data Node
instance Show Document
instance Eq Document
instance Data Document
instance Show UnresolvedEntityException
instance ToMarkup Node
instance ToMarkup Element
instance ToMarkup Document
instance Exception UnresolvedEntityException
instance Exception XMLException
instance Show XMLException
instance NFData Element
instance NFData Node
instance NFData Document


-- | This module provides for simple DOM traversal. It is inspired by
--   XPath. There are two central concepts here:
--   
--   <ul>
--   <li>A <a>Cursor</a> represents a node in the DOM. It also contains
--   information on the node's <i>location</i>. While the <a>Node</a>
--   datatype will only know of its children, a <tt>Cursor</tt> knows about
--   its parent and siblings as well. (The underlying mechanism allowing
--   this is called a zipper, see
--   <a>http://www.haskell.org/haskellwiki/Zipper</a> and
--   <a>http://www.haskell.org/haskellwiki/Tying_the_Knot</a>.)</li>
--   <li>An <a>Axis</a>, in its simplest form, takes a <tt>Cursor</tt> and
--   returns a list of <tt>Cursor</tt>s. It is used for selections, such as
--   finding children, ancestors, etc. Axes can be chained together to
--   express complex rules, such as all children named <i>foo</i>.</li>
--   </ul>
--   
--   The terminology used in this module is taken directly from the XPath
--   specification: <a>http://www.w3.org/TR/xpath/</a>. For those familiar
--   with XPath, the one major difference is that attributes are not
--   considered nodes in this module.
module Text.XML.Cursor

-- | A cursor: contains an XML <a>Node</a> and pointers to its children,
--   ancestors and siblings.
type Cursor = Cursor Node

-- | The type of an Axis that returns a list of Cursors. They are roughly
--   modeled after <a>http://www.w3.org/TR/xpath/#axes</a>.
--   
--   Axes can be composed with <a>&gt;=&gt;</a>, where e.g. <tt>f &gt;=&gt;
--   g</tt> means that on all results of the <tt>f</tt> axis, the
--   <tt>g</tt> axis will be applied, and all results joined together.
--   Because Axis is just a type synonym for <tt>Cursor -&gt;
--   [Cursor]</tt>, it is possible to use other standard functions like
--   <a>&gt;&gt;=</a> or <a>concatMap</a> similarly.
--   
--   The operators <tt>&amp;|</tt>, <tt>&amp;/</tt>, <tt>&amp;//</tt> and
--   <tt>&amp;.//</tt> can be used to combine axes so that the second axis
--   works on the context nodes, children, descendants, respectively the
--   context node as well as its descendants of the results of the first
--   axis.
--   
--   The operators <tt>$|</tt>, <tt>$/</tt>, <tt>$//</tt> and <tt>$.//</tt>
--   can be used to apply an axis (right-hand side) to a cursor so that it
--   is applied on the cursor itself, its children, its descendants,
--   respectively itself and its descendants.
--   
--   Note that many of these operators also work on <i>generalised Axes</i>
--   that can return lists of something other than Cursors, for example
--   Content elements.
type Axis = Cursor -> [Cursor]

-- | Convert a <a>Document</a> to a <a>Cursor</a>. It will point to the
--   document root.
fromDocument :: Document -> Cursor

-- | Convert a <a>Node</a> to a <a>Cursor</a> (without parents).
fromNode :: Node -> Cursor

-- | Cut a cursor off from its parent. The idea is to allow restricting the
--   scope of queries on it.
cut :: Cursor -> Cursor

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The current node.
node :: Cursor node -> node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | Filter cursors that don't pass a check.
check :: Boolean b => (Cursor -> b) -> Axis

-- | Filter nodes that don't pass a check.
checkNode :: Boolean b => (Node -> b) -> Axis

-- | Filter elements that don't pass a check, and remove all non-elements.
checkElement :: Boolean b => (Element -> b) -> Axis

-- | Filter elements that don't pass a name check, and remove all
--   non-elements.
checkName :: Boolean b => (Name -> b) -> Axis

-- | Remove all non-elements. Compare roughly to XPath: <i>A node test * is
--   true for any node of the principal node type. For example, child::*
--   will select all element children of the context node [...]</i>.
anyElement :: Axis

-- | Select only those elements with a matching tag name. XPath: <i>A node
--   test that is a QName is true if and only if the type of the node (see
--   [5 Data Model]) is the principal node type and has an expanded-name
--   equal to the expanded-name specified by the QName.</i>
element :: Name -> Axis

-- | Select only those elements with a loosely matching tag name. Namespace
--   and case are ignored. XPath: <i>A node test that is a QName is true if
--   and only if the type of the node (see [5 Data Model]) is the principal
--   node type and has an expanded-name equal to the expanded-name
--   specified by the QName.</i>
laxElement :: Text -> Axis

-- | Select only text nodes, and directly give the <tt>Content</tt> values.
--   XPath: <i>The node test text() is true for any text node.</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
content :: Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). XPath: <i>the attribute axis contains the attributes of the
--   context node; the axis will be empty unless the context node is an
--   element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
attribute :: Name -> Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). Namespace and case are ignored. XPath: <i>the attribute axis
--   contains the attributes of the context node; the axis will be empty
--   unless the context node is an element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
laxAttribute :: Text -> Cursor -> [Text]

-- | Select only those element nodes with the given attribute.
hasAttribute :: Name -> Axis

-- | Select only those element nodes containing the given attribute
--   key/value pair.
attributeIs :: Name -> Text -> Axis

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Something that can be used in a predicate check as a boolean.
class Boolean a
bool :: Boolean a => a -> Bool
force :: (Exception e, MonadThrow f) => e -> [a] -> f a
forceM :: (Exception e, MonadThrow f) => e -> [f a] -> f a
instance Boolean (Either a b)
instance Boolean (Maybe a)
instance Boolean [a]
instance Boolean Bool
