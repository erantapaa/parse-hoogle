-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A completely type-safe library for linear algebra
--   
--   This library defines data types and classes for fixed dimension
--   vectors and tensors. See the homepage <a>http://noaxiom.org/tensor</a>
--   for more details, or <tt><a>Data.Tensor.Examples</a></tt> for a short
--   tutorial.
@package tensor
@version 0.3.0


-- | This library defines data types and classes for fixed dimension
--   vectors and tensors. The main objects are:
--   
--   <ul>
--   <li><i><tt><a>Ordinal</a></tt></i> A totally ordered set with fixed
--   size. The <tt><a>Ordinal</a></tt> type <tt><a>One</a></tt> contains 1
--   element, <tt><a>Succ</a> <a>One</a></tt> contains 2 elements,
--   <tt><a>Succ</a> <a>Succ</a> <a>One</a></tt> contains 3 elements, and
--   so on (see <a>Data.Ordinal</a> for more details). The type
--   <tt><a>Two</a></tt> is an alias for <tt><a>Succ</a> <a>One</a></tt>,
--   <tt><a>Three</a></tt> is an alias for <tt><a>Succ</a> <a>Succ</a>
--   <a>One</a></tt>, and so on.</li>
--   <li><i><tt><a>MultiIndex</a></tt></i> The index set. It can be linear,
--   rectangular, parallelepipedal, etc. The dimensions of the sides are
--   expressed using <tt><a>Ordinal</a></tt> types and the type constructor
--   <tt><a>:|:</a></tt>, e.g. <tt>(<a>Two</a> <a>:|:</a> (<a>Three</a>
--   <a>:|:</a> <a>Nil</a>))</tt> is a rectangular index set with 2 rows
--   and 3 columns. The index set also contains elements, for example
--   <tt>(<a>Two</a> <a>:|:</a> (<a>Three</a> <a>:|:</a> <a>Nil</a>))</tt>
--   contains all the pairs <tt>(i <a>:|:</a> (j <a>:|:</a> Nil))</tt>
--   where i is in <tt><a>Two</a></tt> and j is in <tt><a>Three</a></tt>.
--   See <a>Data.TypeList.MultiIndex</a> for more details.</li>
--   <li><i><tt><a>Tensor</a></tt></i> It is an assignment of elements to
--   each element of its <tt><a>MultiIndex</a></tt>.</li>
--   </ul>
--   
--   Objects like vectors and matrices are special cases of tensors. Most
--   of the functions to manipulate tensors are grouped into type classes.
--   This allow the possibility of having different internal
--   representations (backends) of a tensor, and act on these with the same
--   functions. At the moment we provide two backends: one in
--   <a>Data.Tensor.Pure</a> (not complete) that uses a recursive
--   definition, and another in <a>Data.Tensor.Vector</a> that is based on
--   <a>http://hackage.haskell.org/package/vector</a> and is faster. More
--   backends (e.g. one based on
--   <a>http://hackage.haskell.org/package/repa</a>) are planned for future
--   releases.
--   
--   Here is a usage example (start <tt>ghci</tt> with the option
--   <tt>-XTypeOperators</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Tensor.Vector
--   
--   &gt;&gt;&gt; fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Tensor (Four :|: Three :|: Nil) Int
--   [[2,3,5],[1,3,6],[0,5,4],[2,1,3]]
--   </pre>
--   
--   The above defines a tensor with 4 rows and 3 columns (a matrix) and
--   <tt><a>Int</a></tt> coefficients. The entries of this matrix are taken
--   from a list using <tt><a>fromList</a></tt> which is a method of the
--   class <tt><a>FromList</a></tt>. Notice the output: the
--   <tt><a>Show</a></tt> instance is defined in such a way to give a
--   readable representation as list of lists. The is equivalent but
--   slightly more readable code:
--   
--   <pre>
--   &gt;&gt;&gt; fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int
--   [[2,3,5],[1,3,6],[0,5,4],[2,1,3]]
--   </pre>
--   
--   Analogously
--   
--   <pre>
--   &gt;&gt;&gt; fromList [7,3,-6] :: Tensor (Three :|: Nil) Int
--   [7,3,-6]
--   </pre>
--   
--   and
--   
--   <pre>
--   &gt;&gt;&gt; fromList [7,3,-6] :: Vector Three Int
--   [7,3,-6]
--   </pre>
--   
--   are the same. In order to access an entry of a <tt><a>Tensor</a></tt>
--   we use the <tt><a>!</a></tt> operator, which takes the same
--   <tt><a>MultiIndex</a></tt> of the <tt><a>Tensor</a></tt> as its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int
--   
--   &gt;&gt;&gt; let b = fromList [7,3,-6] :: Vector Three Int
--   
--   &gt;&gt;&gt; a ! (toMultiIndex [1,3] :: (Four :|: Three :|: Nil))
--   5
--   
--   &gt;&gt;&gt; b ! (toMultiIndex [2] :: (Three :|: Nil))
--   3
--   </pre>
--   
--   it returns the element at the coordinate (1,3) of the matrix
--   <tt>a</tt>, and the element at the coordinate 2 of the vector b. In
--   fact, thanks to type inference, we could simply write
--   
--   <pre>
--   &gt;&gt;&gt; a ! toMultiIndex [1,3]
--   5
--   
--   &gt;&gt;&gt; b ! toMultiIndex [2]
--   2
--   </pre>
--   
--   And now a couple of examples of algebraic operations (requires adding
--   <tt><a>Data.Tensor.LinearAlgebra</a></tt> to the import list):
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Tensor.Vector
--   
--   &gt;&gt;&gt; import Data.Tensor.LinearAlgebra hiding (Matrix)
--   
--   &gt;&gt;&gt; let a = fromList [2,3,5,1,3,6,0,5,4,2,1,3] :: Matrix Four Three Int
--   
--   &gt;&gt;&gt; let b = fromList [7,3,-6] :: Vector Three Int
--   
--   &gt;&gt;&gt; a .*. b
--   [-7,-20,-9,-1]
--   </pre>
--   
--   is the product of matrix <tt>a</tt> and vector <tt>b</tt>, while
--   
--   <pre>
--   &gt;&gt;&gt; let c = fromList [3,4,0,-1,4,5,6,2,1] :: Matrix Three Three Int
--   
--   &gt;&gt;&gt; c
--   [[3,4,0],[-1,4,5],[6,2,1]]
--   
--   &gt;&gt;&gt; charPoly c
--   [106,13,8]
--   </pre>
--   
--   gives the coefficients of the characteristic polynomial of the matrix
--   <tt>c</tt>.
module Data.Tensor.Examples

module Data.Tensor

-- | A <tt><a>Tensor</a></tt> is a map from an <tt><a>Index</a></tt> type
--   (which should be a <tt><tt>MultiIndex</tt></tt>) to an
--   <tt><a>Elem</a></tt>ent type.
class Tensor t where type family Index t type family Elem t
(!) :: Tensor t => t -> Index t -> Elem t
generate :: Tensor t => (Index t -> Elem t) -> t
generateM :: (Tensor t, Monad m) => (Index t -> m (Elem t)) -> m t

-- | Generates a <tt><a>Tensor</a></tt> consisting of the same
--   <tt><a>Elem</a></tt>ent repeated.
replicate :: Tensor t => Elem t -> t
replicateM :: (Monad m, Tensor t) => m (Elem t) -> m t

-- | <tt><a>elemMap</a> f t</tt> applies <tt>f</tt> to every
--   <tt><a>Elem</a></tt>ent of <tt>t</tt>.
elemMap :: (Tensor t1, Tensor t2, Index t1 ~ Index t2) => (Elem t1 -> Elem t2) -> t1 -> t2

-- | In <tt><a>indexMap</a> f t</tt>, the <tt><a>Elem</a></tt>ent
--   corresponding to the <tt><a>Index</a></tt> <tt>i</tt> is the
--   <tt><a>Elem</a></tt>ent that <tt>t</tt> assignes to the
--   <tt><a>Index</a></tt> <tt>f i</tt>.
indexMap :: (Tensor t1, Tensor t2, Elem t1 ~ Elem t2) => (Index t1 -> Index t2) -> t2 -> t1
class FromList t
fromList :: FromList t => [e] -> t e
class DirectSum n t1 t2 where type family SumSpace n t1 t2
directSum :: DirectSum n t1 t2 => n -> t1 -> t2 -> SumSpace n t1 t2
split :: DirectSum n t1 t2 => n -> SumSpace n t1 t2 -> (t1, t2)
class Transpose t where type family TransposeSpace t
transpose :: Transpose t => t -> TransposeSpace t

-- | Slices the <tt><a>Tensor</a></tt> <tt>t</tt> by dropping <tt>i</tt> at
--   the beginning of its <tt><a>Index</a></tt> and <tt>j</tt> at the end.
--   The result has type <tt><a>Slice</a> i j t</tt>.
class Sliceable i j t where type family Slice i j t
slice :: Sliceable i j t => i -> j -> t -> Slice i j t

module Data.TypeAlgebra

-- | Sum of types.
class Sum a b where type family (:+:) a b
(<+>) :: Sum a b => a -> b -> a :+: b

-- | Product of types.
class Prod a b where type family (:*:) a b
(<*>) :: Prod a b => a -> b -> a :*: b

module Data.Cardinal
data Zero

-- | Cardinal number as a type. The associated data type <tt><a>Succ</a>
--   a</tt> provides the next cardinal type. The method
--   <tt><a>fromCardinal</a></tt> provides a numeric representation of the
--   cardinal number; it should be independent on the argument and work on
--   <tt><a>undefined</a></tt>.
class Cardinal a where data family Succ a
fromCardinal :: (Cardinal a, Num i) => a -> i
type C0 = Zero
type C1 = Succ C0
type C2 = Succ C1
type C3 = Succ C2
type C4 = Succ C3
type C5 = Succ C4
type C6 = Succ C5
type C7 = Succ C6
type C8 = Succ C7
type C9 = Succ C8
type C10 = Succ C9

-- | The cardinality of a type is defined by its <tt><a>Cardinal</a></tt>
--   type <tt><a>Card</a> a</tt>.
class Cardinal (Card a) => Cardinality a where type family Card a

-- | The numeric cardinality of a type. <tt><a>card</a></tt> is independent
--   on its argument.
card :: (Cardinality a, Num i) => a -> i
class GCardinality a where type family GCard a
instance Generic Zero
instance Datatype D1Zero
instance (GCardinality (f p), GCardinality (g p)) => GCardinality ((:*:) f g p)
instance (GCardinality (f p), GCardinality (g p)) => GCardinality ((:+:) f g p)
instance GCardinality (f p) => GCardinality (M1 i c f p)
instance Cardinality a => GCardinality (K1 i a p)
instance GCardinality (U1 p)
instance GCardinality (V1 p)
instance (Cardinal a, Prod a b) => Prod a (Succ b)
instance Cardinal a => Prod a Zero
instance (Cardinal a, Cardinal b, Sum a b) => Sum a (Succ b)
instance Cardinal a => Sum a Zero
instance Cardinal a => Show (Succ a)
instance Show Zero
instance Cardinal a => Cardinal (Succ a)
instance Cardinal Zero


-- | In this module we provide a way to canonically define a totally
--   ordered set with a given number of elements. These types have a custom
--   <tt><a>Show</a></tt> instances so that their elements are displayed
--   with usual decimal number.
--   
--   <tt><a>One</a></tt> = {<a>One</a>} = {1}
--   
--   <tt><a>Succ</a> <a>One</a></tt> = {<tt><a>First</a></tt>,
--   <tt><a>Succ</a> <a>One</a></tt>} = {1,2}
--   
--   <tt><a>Succ</a> <a>Succ</a> <a>One</a></tt> = {<tt><a>First</a></tt>,
--   <tt><a>Succ</a> <a>First</a></tt>, <tt><a>Succ</a> <a>Succ</a>
--   <a>One</a></tt>} = {1,2,3}
--   
--   ...
module Data.Ordinal

-- | A set with one element.
data One
One :: One

-- | If <tt>n</tt> is a set with n elements, <tt><a>Succ</a> n</tt> is a
--   set with n+1 elements.
data Succ n

-- | The first element of the type.
First :: Succ n

-- | The last <tt>n</tt> elements.
Succ :: n -> Succ n
type Two = Succ One
type Three = Succ Two
type Four = Succ Three
type Five = Succ Four
type Six = Succ Five
type Seven = Succ Six
type Eight = Succ Seven
type Nine = Succ Eight
type Ten = Succ Nine

-- | Class of ordered sets with n elements. The methods in this class
--   provide a convenient way to convert to and from a numeric type.
class (Cardinality n, Ord n) => Ordinal n
fromOrdinal :: (Ordinal n, Num i) => n -> i
toOrdinal :: (Ordinal n, Eq i, Num i) => i -> n
instance Eq One
instance Generic One
instance Eq n => Eq (Succ n)
instance Generic (Succ n)
instance Datatype D1One
instance Constructor C1_0One
instance Datatype D1Succ
instance Constructor C1_0Succ
instance Constructor C1_1Succ
instance (Ordinal m, Ordinal n, Prod m n, Sum m (m :*: n), Ordinal (m :+: (m :*: n))) => Prod m (Succ n)
instance Ordinal m => Prod m One
instance (Ordinal m, Ordinal n, Ordinal (m :+: n), Sum m n) => Sum m (Succ n)
instance Ordinal m => Sum m One
instance Cardinality n => Cardinality (Succ n)
instance Cardinality One
instance Monad Succ
instance Functor Succ
instance Ordinal n => Show (Succ n)
instance (Bounded n, Enum n, Ordinal n) => Enum (Succ n)
instance (Bounded n, Ordinal n) => Random (Succ n)
instance Ordinal n => Ordinal (Succ n)
instance Ord n => Ord (Succ n)
instance Bounded n => Bounded (Succ n)
instance Random One
instance Show One
instance Enum One
instance Ordinal One
instance Ord One
instance Bounded One


-- | The Module <tt><a>Data.TypeList</a></tt> is a collection of classes to
--   manipulate lists of types, a.k.a. heterogeneous lists. Check the
--   module <tt><a>Data.TypeList.MultiIndex</a></tt> for a concrete
--   implementation of <tt><a>TypeList</a></tt>.
module Data.TypeList

-- | Every <tt><a>TypeList</a></tt> has a <tt><a>Length</a></tt>. The
--   <tt><a>Length</a></tt> is actually a type, and should be a
--   <tt><a>Cardinal</a></tt> (see <tt><a>Data.Cardinal</a></tt>).
class TypeList l where type family Length l length _ = undefined
length :: TypeList l => l -> Length l
class TypeList l => HeadTail l where type family Head l type family Tail l
head :: HeadTail l => l -> Head l
tail :: HeadTail l => l -> Tail l
(.|.) :: HeadTail l => Head l -> Tail l -> l

-- | Extracts the <tt>n</tt>-th component of the list <tt>l</tt>
class Component l n where type family (:!!:) l n
(!!) :: Component l n => l -> n -> l :!!: n
partialMap :: Component l n => n -> (l :!!: n -> l :!!: n) -> l -> l

-- | A class for appending two <tt><a>TypeList</a></tt>s. The result of
--   appending <tt>l</tt> and <tt>l'</tt> has type <tt>l <a>:++:</a>
--   l'</tt>.
class (TypeList l, TypeList l') => AppendList l l' where type family (:++:) l l'
(<++>) :: AppendList l l' => l -> l' -> l :++: l'

-- | This is does for <tt><a>TakeList</a></tt> what <tt><a>take</a></tt>
--   does for ordinary lists.
class (Cardinal n, TypeList l) => TakeList n l where type family Take n l
take :: TakeList n l => n -> l -> Take n l

-- | This is does for <tt><a>TakeList</a></tt> what <tt><a>drop</a></tt>
--   does for ordinary lists.
class (Cardinal n, TypeList l) => DropList n l where type family Drop n l
drop :: DropList n l => n -> l -> Drop n l

-- | Reverse <tt>l</tt> and append it in front of <tt>l'</tt>.
class (TypeList l, TypeList l') => TailRevList l l' where type family TailRev l l'
rev :: TailRevList l l' => l -> l' -> TailRev l l'

-- | Reverse the <tt><a>TypeList</a></tt> <tt>l</tt>, and get
--   <tt><a>Reverse</a> l</tt>.
class TypeList l => ReverseList l where type family Reverse l
reverse :: ReverseList l => l -> Reverse l

-- | Join together <tt><a>TypeList</a></tt>s <tt>l</tt> and <tt>l'</tt>
--   where the last <tt>n</tt> types of <tt>l</tt> coincide with the first
--   <tt>n</tt> types of <tt>l'</tt>. The result has a the common
--   <tt>n</tt> types eliminated.
class JoinList n l l' where type family Join n l l'
join :: JoinList n l l' => n -> l -> l' -> Join n l l'

-- | Extend the list <tt>l</tt> to <tt>l'</tt> by adding the necessary
--   extension <tt><a>Ext</a> l l'</tt>.
class Extend l l' where type family Ext l l'
extend :: Extend l l' => l -> Ext l l' -> l'
instance (ReverseList (Drop n (Reverse l)), DropList n (Reverse l), ReverseList l, AppendList (Reverse (Drop n (Reverse l))) (Drop n l'), DropList n l', Reverse (Take n (Reverse l)) ~ Take n l') => JoinList n l l'
instance (HeadTail l, Component (Tail l) n) => Component l (Succ n)
instance HeadTail l => Component l Zero


-- | We define the a multidimensional array of indices called
--   <tt><a>MultiIndex</a></tt>. The canonical implementation of a
--   <tt><a>MultiIndex</a></tt> is an heterogeneous list of
--   <tt><a>Ordinal</a></tt>s. Below we illustrate some example of
--   <tt><a>MultiIndex</a></tt> types and the elements they contain.
--   
--   <tt><a>Three</a> <a>:|:</a> <a>Nil</a></tt> = {(1),(2),(3)}
--   
--   <tt><a>Three</a> <a>:|:</a> (<a>Two</a> <a>:|:</a> <a>Nil</a>)</tt> =
--   {(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)}
--   
--   <tt><a>Three</a> <a>:|:</a> (<a>Two</a> <a>:|:</a> (<a>Two</a>
--   <a>:|:</a> <a>Nil</a>))</tt> =
--   {(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,1),(2,1,2),(2,2,1),(2,2,2),(3,1,1),(3,1,2),(3,2,1),(3,2,2)}
module Data.TypeList.MultiIndex
data Nil
Nil :: Nil

-- | This is the constructor for heterogeneous lists, equivalent to
--   <tt><tt>:</tt></tt> for standard lists. <tt><a>Nil</a></tt> is used to
--   end the lists, just like <tt>'[]'</tt>.
data (:|:) a b
(:|:) :: a -> b -> :|: a b
class (Dimensions i, TypeList i) => MultiIndex i
fromMultiIndex :: (MultiIndex i, Num n) => i -> [n]
toMultiIndex :: (MultiIndex i, Eq n, Num n) => [n] -> i
multiIndex2Linear :: (MultiIndex i, Num n) => i -> n

-- | Class for types having multiple dimensions, like
--   <tt><a>MultiIndex</a></tt>es or <tt><tt>Tensor</tt></tt>s.
class Dimensions i
dimensions :: (Dimensions i, Num n) => i -> [n]
class (Cardinal n, MultiIndex is, MultiIndex js) => MultiIndexConcat n is js where type family Concat n is js
instance Eq Nil
instance Generic Nil
instance (Eq a, Eq b) => Eq (a :|: b)
instance Generic (a :|: b)
instance Datatype D1Nil
instance Constructor C1_0Nil
instance Datatype D1:|:
instance Constructor C1_0:|:
instance Extend l l' => Extend (e :|: l) (e :|: l')
instance Extend Nil l'
instance (Random e, Random l) => Random (e :|: l)
instance (Bounded e, Bounded l) => Bounded (e :|: l)
instance Random Nil
instance Bounded Nil
instance (Cardinal n, Ordinal i, MultiIndex js, MultiIndex ks, MultiIndexConcat n js ks) => MultiIndexConcat (Succ n) (i :|: js) (i :|: ks)
instance (Ordinal i1, Ordinal i2, Sum i1 i2, MultiIndex is) => MultiIndexConcat Zero (i1 :|: is) (i2 :|: is)
instance (Ordinal i, Dimensions is) => Dimensions (i :|: is)
instance Dimensions Nil
instance (Ordinal i, MultiIndex is) => Show (i :|: is)
instance (Ordinal i, MultiIndex is) => MultiIndex (i :|: is)
instance Show Nil
instance MultiIndex Nil
instance (TailRevList l Nil, TailRevList (e :|: l) Nil) => ReverseList (e :|: l)
instance ReverseList Nil
instance (TailRevList l (e :|: l'), TypeList l') => TailRevList (e :|: l) l'
instance TypeList l => TailRevList Nil l
instance DropList n l => DropList (Succ n) (e :|: l)
instance DropList Zero l => DropList Zero (e :|: l)
instance DropList Zero Nil
instance TakeList n l => TakeList (Succ n) (e :|: l)
instance TakeList Zero l => TakeList Zero (e :|: l)
instance TakeList Zero Nil
instance AppendList l l' => AppendList (e :|: l) l'
instance TypeList l => AppendList Nil l
instance TypeList l => HeadTail (e :|: l)
instance TypeList l => TypeList (e :|: l)
instance TypeList Nil
instance (Cardinality e, Cardinality l, Cardinal (Card e :*: Card l)) => Cardinality (e :|: l)
instance Cardinality Nil

module Data.Tensor.LinearAlgebra
class VectorSpace v
zero :: (VectorSpace v, Num e) => v e
(*.) :: (VectorSpace v, Num e) => e -> v e -> v e
(.+.) :: (VectorSpace v, Num e) => v e -> v e -> v e

-- | A general form of product between two tensors, in which the last
--   <tt>n</tt> dimensions of <tt>t1</tt> are contracted with the first
--   <tt>n</tt> dimensions of <tt>t2</tt>. The resulting tensor belongs to
--   the space <tt><a>ProdSpace</a> n t1 t2</tt>. The operators
--   <tt><a>.*.</a></tt> and <tt>⊗</tt> below are particular cases where
--   <tt>n</tt> is equal to 1 and 0 respectively.
class Cardinal n => Product n t1 t2 where type family ProdSpace n t1 t2
prod :: Product n t1 t2 => n -> t1 -> t2 -> ProdSpace n t1 t2
type MatrixProductSpace t1 t2 = ProdSpace (Succ Zero) t1 t2

-- | It is the product of the last dimension of <tt>t1</tt> with the first
--   dimension of <tt>t2</tt>. In the case where <tt>t1</tt> and
--   <tt>t2</tt> are matrices this coincide with the ordinary matrix
--   product.
(.*.) :: Product (Succ Zero) t1 t2 => t1 -> t2 -> MatrixProductSpace t1 t2
type (:⊗:) t1 t2 = ProdSpace C0 t1 t2

-- | Tensor product of <tt>t1</tt> and <tt>t2</tt>.
(⊗) :: Product C0 t1 t2 => t1 -> t2 -> t1 :⊗: t2
class DotProduct t
dot :: (DotProduct t, Num e) => t e -> t e -> e

-- | A matrix with <tt>i</tt> rows and <tt>j</tt> columns.
class (Tensor t, (Index t) ~ (i :|: (j :|: Nil))) => Matrix i j t
rowSwitch :: Matrix i j t => i -> i -> t -> t
rowMult :: (Matrix i j t, Num e, (Elem t) ~ e) => i -> (Elem t) -> t -> t
rowAdd :: (Matrix i j t, Num e, (Elem t) ~ e) => i -> (Elem t) -> i -> t -> t
colSwitch :: Matrix i j t => j -> j -> t -> t
colMult :: (Matrix i j t, Num e, (Elem t) ~ e) => j -> (Elem t) -> t -> t
colAdd :: (Matrix i j t, Num e, (Elem t) ~ e) => j -> (Elem t) -> j -> t -> t
rowEchelonForm :: (Matrix i j t, Eq e, Fractional e, (Elem t) ~ e) => t -> t

-- | Solves linear systems <tt>AX=B</tt>; <tt>t1</tt> is the type of
--   <tt>A</tt>, <tt>t2</tt> is the type of <tt>B</tt>, and
--   <tt><a>SolSpace</a> t1 t2</tt> is the type of the solution <tt>X</tt>.
class LinearSystem t1 t2 where type family SolSpace t1 t2
triangularSolve :: LinearSystem t1 t2 => t1 -> t2 -> (t1, t2)
parametricSolve :: LinearSystem t1 t2 => t1 -> t2 -> Maybe (SolSpace t1 t2, [SolSpace t1 t2])
class SquareMatrix t where tr = last . charPoly det = head . charPoly
unit :: (SquareMatrix t, Num e) => t e
inverse :: (SquareMatrix t, Eq e, Fractional e) => t e -> Maybe (t e)
tr :: (SquareMatrix t, Num e) => t e -> e
charPoly :: (SquareMatrix t, Num e) => t e -> [e]
minPoly :: (SquareMatrix t, Eq e, Fractional e) => t e -> [e]
det :: (SquareMatrix t, Num e) => t e -> e
polyEval :: (SquareMatrix t, Num e) => t e -> [e] -> t e

module Data.Tensor.Pure
type Vector i = Tensor (i :|: Nil)
type Matrix i j = Tensor (i :|: (j :|: Nil))
instance Eq e => Eq (Tensor Nil e)
instance (MultiIndex is, Ordinal n, Tensor (Tensor is e), Tensor (Tensor (n :|: is) e), e ~ Elem (Tensor is e), is ~ Index (Tensor is e), e ~ Elem (Tensor (n :|: is) e), Index (Tensor (n :|: is) e) ~ (n :|: is)) => Tensor (Tensor (Succ n :|: is) e)
instance (MultiIndex is, Ordinal n, Show (Tensor is e), Show (Tensor (n :|: is) e)) => Show (Tensor (Succ n :|: is) e)
instance (MultiIndex is, Ordinal n, Applicative (Tensor is), Applicative (Tensor (n :|: is))) => Applicative (Tensor (Succ n :|: is))
instance (MultiIndex is, Ordinal n, Functor (Tensor is), Functor (Tensor (n :|: is))) => Functor (Tensor (Succ n :|: is))
instance (FromList (Tensor is), FromList (Tensor (n :|: is)), Ordinal n, MultiIndex is) => FromList (Tensor (Succ n :|: is))
instance Dimensions (Tensor (n :|: is) e) => Dimensions (Tensor (Succ n :|: is) e)
instance (MultiIndex is, Ordinal n, Eq (Tensor is e), Eq (Tensor (n :|: is) e)) => Eq (Tensor (Succ n :|: is) e)
instance (MultiIndex is, Tensor (Tensor is e), e ~ Elem (Tensor is e), is ~ Index (Tensor is e)) => Tensor (Tensor (One :|: is) e)
instance (MultiIndex is, Show (Tensor is e)) => Show (Tensor (One :|: is) e)
instance (MultiIndex is, Applicative (Tensor is)) => Applicative (Tensor (One :|: is))
instance (MultiIndex is, Functor (Tensor is)) => Functor (Tensor (One :|: is))
instance (FromList (Tensor is), MultiIndex is) => FromList (Tensor (One :|: is))
instance Dimensions (Tensor is e) => Dimensions (Tensor (One :|: is) e)
instance (MultiIndex is, Eq (Tensor is e)) => Eq (Tensor (One :|: is) e)
instance Tensor (Tensor Nil e)
instance Show e => Show (Tensor Nil e)
instance Applicative (Tensor Nil)
instance Functor (Tensor Nil)
instance FromList (Tensor Nil)
instance Dimensions (Tensor Nil e)


-- | This module define a datatype <tt><a>Tensor</a></tt> which implements
--   the classes and methods defined in <a>Data.Tensor</a> and
--   <a>Data.Tensor.LinearAlgebra</a>. It is represented internally as a
--   <tt><a>Vector</a></tt>.
module Data.Tensor.Vector
data Tensor i e
type Vector n = Tensor (n :|: Nil)
type Matrix m n = Tensor (m :|: (n :|: Nil))
type ColumnVector n = Matrix n One
vector2ColumnVector :: Vector n e -> ColumnVector n e
columnVector2Vector :: ColumnVector n e -> Vector n e
type RowVector n = Matrix One n
vector2RowVector :: Vector n e -> RowVector n e
rowVector2Vector :: RowVector n e -> Vector n e
fromVector :: MultiIndex i => Vector e -> (Tensor i e)
