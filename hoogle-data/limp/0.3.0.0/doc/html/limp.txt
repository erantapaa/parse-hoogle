-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | representation of Integer Linear Programs
--   
@package limp
@version 0.3.0.0


-- | Representation of integers (Z) and reals (R) of similar precision.
--   Programs are abstracted over this, so that ideally in the future we
--   could have a solver that produces Integers and Rationals, instead of
--   just Ints and Doubles.
--   
--   We bundle Z and R up into a single representation instead of
--   abstracting over both, because we must be able to convert from Z to R
--   without loss.
module Numeric.Limp.Rep

-- | The Representation class. Requires its members <tt>Z c</tt> and <tt>R
--   c</tt> to be <tt>Num</tt>, <tt>Ord</tt> and <tt>Eq</tt>.
--   
--   For some reason, for type inference to work, the members must be
--   <tt>data</tt> instead of <tt>type</tt>. This gives some minor
--   annoyances when unpacking them. See <a>unwrapR</a> below.
class (Num (Z c), Ord (Z c), Eq (Z c), Integral (Z c), Num (R c), Ord (R c), Eq (R c), RealFrac (R c)) => Rep c where data family Z c data family R c fromZ = fromIntegral
fromZ :: Rep c => Z c -> R c

-- | An assignment from variables to values. Maps integer variables to
--   integers, and real variables to reals.
data Assignment z r c
Assignment :: (Map z (Z c)) -> (Map r (R c)) -> Assignment z r c

-- | Retrieve value of integer variable - or 0, if there is no value.
zOf :: (Rep c, Ord z) => Assignment z r c -> z -> Z c

-- | Retrieve value of real variable - or 0, if there is no value.
rOf :: (Rep c, Ord r) => Assignment z r c -> r -> R c

-- | Retrieve value of an integer or real variable, with result cast to a
--   real regardless.
zrOf :: (Rep c, Ord z, Ord r) => Assignment z r c -> Either z r -> R c

-- | A representation that uses native 64-bit ints and 64-bit doubles.
--   Really, this should be 32-bit ints.
data IntDouble

-- | Define show manually, so we can strip out the <a>Z</a> and <a>R</a>
--   prefixes.

-- | Convert a wrapped (R IntDouble) to an actual Double.
unwrapR :: R IntDouble -> Double
instance (Show (Z c), Show (R c), Show z, Show r) => Show (Assignment z r c)
instance Ord (Z IntDouble)
instance Eq (Z IntDouble)
instance Integral (Z IntDouble)
instance Real (Z IntDouble)
instance Num (Z IntDouble)
instance Enum (Z IntDouble)
instance Ord (R IntDouble)
instance Eq (R IntDouble)
instance Num (R IntDouble)
instance Enum (R IntDouble)
instance Fractional (R IntDouble)
instance Real (R IntDouble)
instance RealFrac (R IntDouble)
instance Show (R IntDouble)
instance Show (Z IntDouble)
instance Rep IntDouble


-- | Define upper and lower bounds of program variables.
module Numeric.Limp.Program.Bounds

-- | Define upper and lower bounds of program variables. Bounds may be
--   specified multiple times: the intersection of all bounds is used.
data Bounds z r c
BoundZ :: (B (Z c) z) -> Bounds z r c
BoundR :: (B (R c) r) -> Bounds z r c

-- | Maybe a lower bound, the variable's name, and maybe an upper bound.
type B rep v = (Maybe rep, v, Maybe rep)

-- | Create a lower and upper bound for an integer variable.
lowerUpperZ :: Rep c => Z c -> z -> Z c -> Bounds z r c

-- | Create only a lower bound for an integer variable.
lowerZ :: Rep c => Z c -> z -> Bounds z r c

-- | Create only an upper bound for an integer variable.
upperZ :: Rep c => z -> Z c -> Bounds z r c

-- | A binary integer variable: can only be <tt>0</tt> or <tt>1</tt>.
binary :: Rep c => z -> Bounds z r c

-- | Create a lower and upper bound for a real variable.
lowerUpperR :: Rep c => R c -> r -> R c -> Bounds z r c

-- | Create only a lower bound for a real variable.
lowerR :: Rep c => R c -> r -> Bounds z r c

-- | Create only an upper bound for a real variable.
upperR :: Rep c => r -> R c -> Bounds z r c


-- | Type-level functions on result types.
--   
--   Linear functions are classified as either int-valued or real-valued,
--   so we define <tt>KZ</tt> and <tt>KR</tt> as data kinds to denote this
--   in the type.
module Numeric.Limp.Program.ResultKind

-- | Classify the result type of a linear function to either integral or
--   real:
data K

-- | Integral <tt>Z</tt>
KZ :: K

-- | Real or mixed <tt>R</tt>
KR :: K

-- | Representation of either integral of real linear functions: a list of
--   variables with coefficients, plus a constant summand.
data Linear z r c k
LZ :: [(z, Z c)] -> (Z c) -> Linear z r c KZ
LR :: [(Either z r, R c)] -> (R c) -> Linear z r c KR

-- | Find the result type of merging, or adding, two linear functions:
--   adding two integers produces an integer, while adding a real on either
--   side produces a real.

-- | Convert a <tt>K</tt> to its actual representation (<tt>Z</tt> or
--   <tt>R</tt>).


-- | Representation, constructors and limited arithmetic on linear
--   functions.
--   
--   The linear function is indexed by its result type: either purely
--   integer (<tt>KZ</tt>) or mixed/real (<tt>KR</tt>). This index is used
--   to allow strictly-less-than constraints only on integer functions, and
--   to allow retrieving integer values from purely integer functions.
module Numeric.Limp.Program.Linear

-- | Representation of either integral of real linear functions: a list of
--   variables with coefficients, plus a constant summand.
data Linear z r c k
LZ :: [(z, Z c)] -> (Z c) -> Linear z r c KZ
LR :: [(Either z r, R c)] -> (R c) -> Linear z r c KR

-- | Any linear function can be converted into a real linear function.
toR :: Rep c => Linear z r c k -> Linear z r c KR

-- | Integral variable
z :: Rep c => z -> Z c -> Linear z r c KZ

-- | Integral variable with coefficient 1
z1 :: Rep c => z -> Linear z r c KZ

-- | Real variable
r :: Rep c => r -> R c -> Linear z r c KR

-- | Real variable with coefficient 1
r1 :: Rep c => r -> Linear z r c KR

-- | An integral constant summand
con :: Rep c => Z c -> Linear z r c KZ

-- | An integral constant summand
conZ :: Rep c => Z c -> Linear z r c KZ

-- | A real constant
conR :: Rep c => R c -> Linear z r c KR

-- | Constant <tt>0</tt>
c0 :: Rep c => Linear z r c KZ

-- | Constant <tt>1</tt>
c1 :: Rep c => Linear z r c KZ

-- | Negate a linear function. Negation does not change the kind.
neg :: Rep c => Linear z r c k -> Linear z r c k

-- | Multiply a linear function by some constant.
--   
--   Note that you cannot multiply a linear function by another linear
--   function, as the result would likely be non-linear!
(.*) :: Rep c => Linear z r c k -> KRep k c -> Linear z r c k

-- | Multiply a linear function by some constant.
(*.) :: Rep c => KRep k c -> Linear z r c k -> Linear z r c k

-- | Add two linear functions together. They can have different result
--   types.
(.+.) :: Rep c => Linear z r c k1 -> Linear z r c k2 -> Linear z r c (KMerge k1 k2)

-- | Subtract one linear function from another. They can have different
--   result types.
(.-.) :: Rep c => Linear z r c k1 -> Linear z r c k2 -> Linear z r c (KMerge k1 k2)

module Numeric.Limp.Program.Constraint

-- | Different kind of constraints.
--   
--   These are not all necessary, but I have a hunch that keeping some
--   structure may be helpful in the future.
--   
--   Constructors:
--   
--   <ul>
--   <li><i><tt>:==</tt></i> Equality constraint</li>
--   <li><i><tt>:&lt;=</tt></i> Less than or equal</li>
--   <li><i><tt>:&lt;</tt></i> Strictly less than: this is only allowed for
--   purely integer functions</li>
--   <li><i><tt>:&gt;=</tt></i> Greater than or equal</li>
--   <li><i><tt>:&gt;</tt></i> Strictly greater than: this is only allowed
--   for purely integer functions</li>
--   <li><i><tt>Between</tt></i> <tt>Between a b c</tt> is equivalent to
--   <tt>a :&lt;= b :&amp;&amp; b :&lt;= c</tt></li>
--   <li><i><tt>:&amp;&amp;</tt></i> Conjunction of two constraints</li>
--   <li><i><tt>:!</tt></i> <tt>"name" :! constr</tt> Annotate a constraint
--   with a name, or other useless information</li>
--   <li><i><tt>CTrue</tt></i> Trivially true constraint</li>
--   </ul>
data Constraint z r c
(:==) :: Linear z r c k1 -> Linear z r c k2 -> Constraint z r c
(:<=) :: Linear z r c k1 -> Linear z r c k2 -> Constraint z r c
(:<) :: Linear z r c KZ -> Linear z r c KZ -> Constraint z r c
(:>=) :: Linear z r c k1 -> Linear z r c k2 -> Constraint z r c
(:>) :: Linear z r c KZ -> Linear z r c KZ -> Constraint z r c
Between :: Linear z r c k1 -> Linear z r c k2 -> Linear z r c k3 -> Constraint z r c
(:&&) :: Constraint z r c -> Constraint z r c -> Constraint z r c
(:!) :: String -> Constraint z r c -> Constraint z r c
CTrue :: Constraint z r c
instance Monoid (Constraint z r c)


-- | Functions for evaluating linear functions and checking constraints.
module Numeric.Limp.Program.Eval

-- | Evaluate a linear function with given assignment. If the linear
--   function is purely integral, a <tt>Z</tt> will be returned; otherwise,
--   <tt>R</tt>.
eval :: (Rep c, Ord z, Ord r) => Assignment z r c -> Linear z r c k -> KRep k c

-- | Evaluate a linear function with given assignment, returning real
--   value.
evalR :: (Rep c, Ord z, Ord r) => Assignment z r c -> Linear z r c k -> R c

-- | Check whether assignment satisfies constraint.
check :: (Rep c, Ord z, Ord r) => Assignment z r c -> Constraint z r c -> Bool


-- | Definition of a whole program
module Numeric.Limp.Program.Program

-- | Direction to optimise program in: minimise or maximise.
data Direction
Minimise :: Direction
Maximise :: Direction

-- | Whole program, parameterised by:
--   
--   <ul>
--   <li><i><tt>z</tt></i> type of integer variables</li>
--   <li><i><tt>r</tt></i> type of real variables</li>
--   <li><i><tt>c</tt></i> representation of integers and reals (see
--   <a>Rep</a>)</li>
--   </ul>
data Program z r c
Program :: Direction -> Linear z r c KR -> Constraint z r c -> [Bounds z r c] -> Program z r c

-- | Optimisation direction
_direction :: Program z r c -> Direction

-- | The objective function
_objective :: Program z r c -> Linear z r c KR

-- | All constraints bundled up with <tt>:&amp;&amp;</tt>.
_constraints :: Program z r c -> Constraint z r c

-- | Upper and lower bounds of variables. Not all variables need to be
--   mentioned, and if variables are mentioned multiple times, the
--   intersection is used.
_bounds :: Program z r c -> [Bounds z r c]
program :: Rep c => Direction -> Linear z r c k -> Constraint z r c -> [Bounds z r c] -> Program z r c
minimise :: Rep c => Linear z r c k -> Constraint z r c -> [Bounds z r c] -> Program z r c
maximise :: Rep c => Linear z r c k -> Constraint z r c -> [Bounds z r c] -> Program z r c


-- | Front-end representation of programs. See <a>Program</a> for the
--   entire program; <a>Constraint</a> for constraints such as less than or
--   equal, greater than, etc; and <a>Linear</a> for linear functions.
module Numeric.Limp.Program


-- | Representation of subset of linear functions: only variables and
--   coefficients, no constant summand
module Numeric.Limp.Canon.Linear

-- | Linear function is represented as a map from either a integral
--   variable or an real variable, to a real coefficient.
data Linear z r c
Linear :: (Map (Either z r) (R c)) -> Linear z r c

-- | Create linear function from list of variables and coefficients
mkLinear :: (Ord z, Ord r) => [(Either z r, R c)] -> Linear z r c

-- | Evaluate linear function with given assignment
evalR :: (Rep c, Ord z, Ord r) => Assignment z r c -> Linear z r c -> R c

-- | Find set of all variables mentioned in function
varsOfLinear :: (Ord z, Ord r) => Linear z r c -> Set (Either z r)


-- | Representation of linear constraints
module Numeric.Limp.Canon.Constraint

-- | Conjunction of simple constraints
data Constraint z r c
Constraint :: [Constraint1 z r c] -> Constraint z r c

-- | A simple constraint
data Constraint1 z r c

-- | Maybe a lower bound, a linear function, and maybe an upper bound.
--   
--   In order to be meaningful, at least one of lower or upper bound should
--   be <tt>Just</tt>.
C1 :: (Maybe (R c)) -> (Linear z r c) -> (Maybe (R c)) -> Constraint1 z r c

-- | Check whether an assignment satisfies the constraint
check :: (Rep c, Ord z, Ord r) => Assignment z r c -> Constraint z r c -> Bool

-- | Get set of variables in constraint
varsOfConstraint :: (Ord z, Ord r) => Constraint z r c -> Set (Either z r)


-- | Canon representation of linear program
module Numeric.Limp.Canon.Program

-- | A program represented by objective, constraints and bounds. There is
--   no need for an optimisation direction; the objective is just negated.
data Program z r c
Program :: Linear z r c -> Constraint z r c -> Map (Either z r) (Maybe (R c), Maybe (R c)) -> Program z r c
_objective :: Program z r c -> Linear z r c
_constraints :: Program z r c -> Constraint z r c
_bounds :: Program z r c -> Map (Either z r) (Maybe (R c), Maybe (R c))

-- | Find set of all variables mentioned in program
varsOfProgram :: (Ord z, Ord r) => Program z r c -> Set (Either z r)


-- | Convert from <a>Numeric.Limp.Program</a> representation to simpler,
--   so-called canonical representation.
module Numeric.Limp.Canon.Convert

-- | Convert a Frontend <a>Linear</a> into a Canon <a>Linear</a>. Returns
--   the constant summand as well, as Canon Linear do not have these.
--   
--   Should satisfy that <tt>forall a l. P.evalR a l == evalR a (fst $
--   linear l) + (snd $ linear l)</tt>
linear :: (Rep c, Ord z, Ord r) => Linear z r c k -> (Linear z r c, R c)

-- | Convert a Frontend <a>Constraint</a> into a Canon <a>Constraint</a>.
--   
--   Should satisfy that <tt>forall a c. P.check a c == check a (constraint
--   c)</tt>
constraint :: (Rep c, Ord z, Ord r) => Constraint z r c -> Constraint z r c

-- | Convert a Frontend <a>Program</a> into a Canon <a>Program</a>.
--   
--   If we had a solve function that worked on either, it would ideally
--   satisfy <tt>forall p. P.solve p == solve (program p)</tt>
--   
--   However, due to potential non-determinism in solving functions, it
--   could be possible to get a different, but still optimal, solution:
--   
--   <pre>
--   forall p. let aP = P.solve p
--                  p' = program p
--                  a  =   solve p'
--              in P.eval aP (P._objective p) == eval a (_objective p')
--              &amp;&amp;  check a (P._constraints p) &amp;&amp; check ...
--   </pre>
program :: (Rep c, Ord z, Ord r) => Program z r c -> Program z r c


-- | A simpler representation of programs. The frontend representation
--   (<a>Numeric.Limp.Program</a>) has many different kinds of constraints
--   (<tt>&lt;=</tt>, <tt>&lt;</tt>, <tt>==</tt>, <tt>between</tt>), as
--   well as constant additions on each linear function (eg. <tt>x + 2y +
--   5</tt>). The so-called canonical representation removes the constant
--   addition from each linear constraint, and converts each constraint
--   (<tt>Lin Op Lin</tt>) to (<tt>Num &lt;= Lin &lt;= Num</tt>).
--   
--   The most interesting function here is <a>program</a> for converting
--   from Program representation to Canon.
module Numeric.Limp.Canon
