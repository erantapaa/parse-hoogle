-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for safely freezing multiple arrays in the ST monad.
--   
--   Support for safely freezing multiple arrays in the ST monad. Developed
--   in
--   <a>http://haskell.reinerpope.com/2009/09/making-runstarray-more-flexible-or.html</a>.
--   
--   The new monad is defined in Control.Monad.ST.Freeze. An example of its
--   use is given in Data.Vector.Generic.Mutable.STFreeze. The module
--   Data.STRef.Freeze is a reexports of Data.STRef but lifted to the new
--   ST monad.
@package safe-freeze
@version 0.2.1


-- | An indexed version of the ST monad with support for safely freezing
--   multiple arrays. Compare to the usual ST monad, where the only support
--   for safely freezing arrays is runSTUArray -- only one array may be
--   frozen.
--   
--   This version of the ST monad has two distinct stages of processing:
--   the <i>normal</i> stage, and the <i>freeze</i> stage. Reading and
--   writing are permitted in the normal stage; reading and freezing are
--   permitted in the freeze stage. This policy ensures that no writes
--   occur after the arrays have been frozen.
--   
--   This ST is an <i>indexed</i> monad (see <a>Control.Monad.Indexed</a>)
--   as well as a normal monad. That is, each monadic value will have an
--   "ingoing" state thread as well as an "outgoing" state thread. These
--   state threads are similar to the ST monad's state thread, except that
--   they are now annotated with a stage name: either <a>Normal</a> or
--   <a>Freeze</a>.
module Control.Monad.ST.Freeze
data Normal s
data Freeze s
class IxMonad st => MonadST st
liftST :: MonadST st => ST s a -> STNormal st s a
liftRead :: MonadST st => ST s a -> STRead st s a
liftUnsafeFreeze :: MonadST st => ST s a -> STFreeze st s a

-- | A computation containing some writes but no freezes: it starts | and
--   ends in the <a>Normal</a> stage.
type STNormal st s a = st (Normal s) (Normal s) a

-- | A computation containing some freezes but no writes: it starts in |
--   any stage, but ends in the Freeze stage.
type STFreeze st s a = forall stg. st (stg s) (Freeze s) a

-- | A computation containing only reads: it starts and ends in any stage,
--   but does not change stage. (Note that there would be no loss of safety
--   in allowing the stage to change, but it may result in ambiguous types,
--   or extra type annotations being required.)
type STRead st s a = forall stg. st (stg s) (stg s) a
type ST = STT Identity

-- | <pre>
--   runST = <a>runIdentity</a> . <a>runSTT</a>
--   </pre>
runST :: (forall s. STT Identity (stg1 s) (stg2 s) a) -> a

-- | An ST monad transformer. However, this is not a genuine monad
--   transformer, as that would be unsafe (see
--   <a>http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016554.html</a>).
--   To retain safety, it may only act as a monad transformer over the
--   <a>Identity</a> and <a>IO</a> monads, enforced by the <a>STTBase</a>
--   typeclass.
--   
--   Defining <a>STT</a> as a monad transformer rather than just a monad
--   allows ST arrays to be used in the <a>IO</a> monad, bringing safe
--   freezing also to the <a>IO</a> monad.
data STT (m :: * -> *) s t a
class STTBase m
runSTT :: STTBase m => (forall s. STT m (stg1 s) (stg2 s) a) -> m a
lift :: STTBase m => m a -> STT m (stg s) (stg s) a
instance Monad (STT m s s)
instance Applicative (STT m s s)
instance Functor (STT m s t)
instance MonadST (STT m)
instance IxMonad (STT m)
instance IxApplicative (STT m)
instance IxPointed (STT m)
instance IxFunctor (STT m)
instance STTBase Identity
instance STTBase IO


-- | Description of this module goes here.
module Data.STRef.Freeze

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
data STRef s a :: * -> * -> *
newSTRef :: MonadST st => a -> STNormal st s (STRef s a)
readSTRef :: MonadST st => STRef s a -> STRead st s a
writeSTRef :: MonadST st => STRef s a -> a -> STNormal st s ()
modifySTRef :: MonadST st => STRef s a -> (a -> a) -> STNormal st s ()


-- | Proof-of-concept support for using vector's <tt>MVector</tt>s in the
--   new ST monad. Reexports only a minimal API from
--   <a>Data.Vector.Generic.Mutable</a>, with all ST operations done in the
--   new ST (indexed) monad.
--   
--   Notable differences in API:
--   
--   <ul>
--   <li>the former <tt>unsafeFreeze</tt> is in fact safe, and is now named
--   <a>freeze</a>.</li>
--   </ul>
--   
--   Example demonstration of using the new ST monad:
--   
--   <pre>
--   foo :: forall v. Vector v Int =&gt; (v Int, v Int)
--   foo = <a>runST</a> go where
--     go :: forall s. <a>ST</a> (<a>Normal</a> s) (<a>Freeze</a> s) (v Int, v Int)
--     go = new 5 &gt;&gt;&gt;= a1 -&gt;
--          new 6 &gt;&gt;&gt;= a2 -&gt;
--          write a1 0 3 &gt;&gt;&gt;= () -&gt;
--          write a2 1 2 &gt;&gt;&gt;= () -&gt;
--          freeze a1 &gt;&gt;&gt;= v1 -&gt;
--          freeze a2 &gt;&gt;&gt;= v2 -&gt;
--          return (v1,v2)
--   </pre>
module Data.Vector.Generic.Mutable.STFreeze
new :: (MVector v a, MonadST st) => Int -> STNormal st s (v s a)
read :: (MVector v a, MonadST st) => v s a -> Int -> STRead st s a
write :: (MVector v a, MonadST st) => v s a -> Int -> a -> STNormal st s ()
copy :: (MVector v a, MonadST st) => v s a -> v s a -> STNormal st s ()
freeze :: (Vector v a, MonadST st) => (Mutable v) s a -> STFreeze st s (v a)
