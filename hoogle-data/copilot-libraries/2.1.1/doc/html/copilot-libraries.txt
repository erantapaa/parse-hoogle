-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell-embedded DSL for monitoring hard real-time
distributed systems.
--   
--   Libraries for the Copilot language.
--   
--   Copilot is a stream (i.e., infinite lists) domain-specific language
--   (DSL) in Haskell that compiles into embedded C. Copilot contains an
--   interpreter, multiple back-end compilers, and other verification
--   tools. A tutorial, bug reports, and todos are available at
--   <a>https://github.com/leepike/copilot-discussion</a>.
--   
--   Examples are available at
--   <a>https://github.com/leepike/Copilot/tree/master/Examples</a>.
@package copilot-libraries
@version 2.1.1


-- | Stack machine.
module Copilot.Library.Stacks
stack :: (Integral a, Typed b) => a -> b -> PopSignal -> PushSignal -> PushStream b -> StackTop b
stack' :: (Integral a, Typed b) => a -> b -> PopSignal -> PushSignal -> PushStream b -> StackTop b


-- | An implementation of the Boyer-Moore Majority Vote Algorithm for
--   Copilot.
--   
--   For details of the Boyer-Moore Majority Vote Algorithm see the
--   following papers:
--   
--   <ul>
--   <li>Wim H. Hesselink, "The Boyer-Moore Majority Vote Algorithm",
--   2005</li>
--   <li>Robert S. Boyer and J Strother Moore, "MJRTY - A Fast Majority
--   Vote Algorithm", 1982</li>
--   </ul>
module Copilot.Library.Voting
majority :: (Eq a, Typed a) => [Stream a] -> Stream a
aMajority :: (Eq a, Typed a) => [Stream a] -> Stream a -> Stream Bool


-- | Utility bounded-list functions (e.g., folds, scans, etc.)
module Copilot.Library.Utils
take :: (Integral a, Typed b) => a -> Stream b -> [Stream b]

-- | functions similar to the Prelude functions on lists
tails :: Typed a => Stream a -> [Stream a]
nfoldl :: (Typed a, Typed b) => Int -> (Stream a -> Stream b -> Stream a) -> Stream a -> Stream b -> Stream a
nfoldl1 :: Typed a => Int -> (Stream a -> Stream a -> Stream a) -> Stream a -> Stream a
nfoldr :: (Typed a, Typed b) => Int -> (Stream a -> Stream b -> Stream b) -> Stream b -> Stream a -> Stream b
nfoldr1 :: Typed a => Int -> (Stream a -> Stream a -> Stream a) -> Stream a -> Stream a
nscanl :: (Typed a, Typed b) => Int -> (Stream a -> Stream b -> Stream a) -> Stream a -> Stream b -> [Stream a]
nscanr :: Typed a => Int -> (Stream a -> Stream b -> Stream b) -> Stream b -> Stream a -> [Stream b]
nscanl1 :: Typed a => Int -> (Stream a -> Stream a -> Stream a) -> Stream a -> [Stream a]
nscanr1 :: Typed a => Int -> (Stream a -> Stream a -> Stream a) -> Stream a -> [Stream a]
case' :: Typed a => [Stream Bool] -> [Stream a] -> Stream a

-- | Index. WARNING: very expensive! Consider using this only for very
--   short lists.
(!!) :: (Typed a, Integral a) => [Stream a] -> Stream a -> Stream a
cycle :: Typed a => [a] -> Stream a


-- | A regular expression librariy.
module Copilot.Library.RegExp
copilotRegexp :: (Typed t, SymbolParser t, Eq t) => Stream t -> SourceName -> Stream Bool -> Stream Bool
copilotRegexpB :: SourceName -> [(StreamName, Stream Bool)] -> Stream Bool -> Stream Bool
instance Eq t => Eq (Sym t)
instance Ord t => Ord (Sym t)
instance Show t => Show (Sym t)
instance Eq t => Eq (NumSym t)
instance Show t => Show (NumSym t)
instance Show t => Show (RegExp t)
instance Eq P
instance SymbolParser P
instance SymbolParser Int64
instance SymbolParser Int32
instance SymbolParser Int16
instance SymbolParser Int8
instance SymbolParser Word64
instance SymbolParser Word32
instance SymbolParser Word16
instance SymbolParser Word8
instance SymbolParser Bool


-- | Basic bounded statistics. In the following, a bound <tt>n</tt> is
--   given stating the number of periods over which to compute the
--   statistic (<tt>n == 1</tt> computes it only over the current period).
module Copilot.Library.Statistics

-- | Maximum value.
max :: (Typed a, Ord a) => Int -> Stream a -> Stream a

-- | Minimum value.
min :: (Typed a, Ord a) => Int -> Stream a -> Stream a

-- | Summation.
sum :: (Typed a, Num a, Eq a) => Int -> Stream a -> Stream a

-- | Mean value. <tt>n</tt> must not overflow for word size <tt>a</tt> for
--   streams over which computation is peformed.
mean :: (Typed a, Eq a, Fractional a) => Int -> Stream a -> Stream a

-- | Mean value over the current set of streams passed in.
meanNow :: (Typed a, Integral a) => [Stream a] -> Stream a


-- | Provides past-time linear-temporal logic (ptLTL operators).
--   
--   Interface: see Examples/PTLTLExamples.hs. You can embed a ptLTL
--   specification within a Copilot specification using the form: <tt>
--   operator stream </tt>
module Copilot.Library.PTLTL

-- | Once <tt>s2</tt> holds, in the following state (period), does
--   <tt>s1</tt> continuously hold?
since :: Stream Bool -> Stream Bool -> Stream Bool

-- | Has <tt>s</tt> always held (up to and including the current state)?
alwaysBeen :: Stream Bool -> Stream Bool

-- | Did <tt>s</tt> hold at some time in the past (including the current
--   state)?
eventuallyPrev :: Stream Bool -> Stream Bool

-- | Did <tt>s</tt> hold in the previous period?
previous :: Stream Bool -> Stream Bool


-- | Bounded Linear Temporal Logic (LTL) operators. For a bound <tt>n</tt>,
--   a property <tt>p</tt> holds if it holds on the next <tt>n</tt>
--   transitions (between periods). If <tt>n == 0</tt>, then the trace
--   includes only the current period. For example, <tt> eventually 3 p
--   </tt> holds if <tt>p</tt> holds at least once every four periods (3
--   transitions).
--   
--   Interface: see Examples/LTLExamples.hs You can embed an LTL
--   specification within a Copilot specification using the form: <tt>
--   operator spec </tt>
--   
--   For some properties, stream dependencies may not allow their
--   specification. In particular, you cannot determine the <a>future</a>
--   value of an external variable. In general, the ptLTL library is
--   probaby more useful.
module Copilot.Library.LTL

-- | Property <tt>s</tt> holds at the next period. For example: <tt> 0 1 2
--   3 4 5 6 7 s =&gt; F F F T F F T F ... next s =&gt; F F T F F T F ...
--   </tt> Note: s must have sufficient history to drop a value from it.
next :: Stream Bool -> Stream Bool

-- | Property <tt>s</tt> holds at some period in the next <tt>n</tt>
--   periods. If <tt>n == 0</tt>, then <tt>s</tt> holds in the current
--   period. We require <tt>n &gt;= 0</tt>. E.g., if <tt>p = eventually 2
--   s</tt>, then we have the following relationship between the streams
--   generated: <tt> s =&gt; F F F T F F F T ... p =&gt; F T T T F T T T
--   ... </tt>
eventually :: Integral a => a -> Stream Bool -> Stream Bool

-- | Property <tt>s</tt> holds for the next <tt>n</tt> periods. We require
--   <tt>n &gt;= 0</tt>. If <tt>n == 0</tt>, then <tt>s</tt> holds in the
--   current period. E.g., if <tt>p = always 2 s</tt>, then we have the
--   following relationship between the streams generated: <tt> 0 1 2 3 4 5
--   6 7 s =&gt; T T T F T T T T ... p =&gt; T F F F T T ... </tt>
always :: Integral a => a -> Stream Bool -> Stream Bool

-- | <tt>until n s0 s1</tt> means that <tt>eventually n s1</tt>, and up
--   until at least the period before <tt>s1</tt> holds, <tt>s0</tt>
--   continuously holds.
until :: Integral a => a -> Stream Bool -> Stream Bool -> Stream Bool

-- | <tt>release n s0 s1</tt> means that either <tt>always n s1</tt>, or
--   <tt>s1</tt> holds up to and including the period at which <tt>s0</tt>
--   becomes true.
release :: Integral a => a -> Stream Bool -> Stream Bool -> Stream Bool


-- | A library that generates new clocks based on a base period. Usage,
--   supposing <tt>v</tt> is a Copilot variable, then <tt> clk ( period 3 )
--   ( phase 1 ) </tt> is equivalent to a stream of values like: <tt> cycle
--   [False, True, False] </tt> that generates a stream of values <tt>
--   False True False False True False False True False ... 0 1 2 3 4 5 6 7
--   8 </tt> That is true every 3 ticks (the period) starting on the 1st
--   tick (the phase). Constraints: The period must be greater than 0. The
--   phase must be greater than or equal to 0. The phase must be less than
--   the period.
module Copilot.Library.Clocks
clk :: Integral a => Period a -> Phase a -> Stream Bool
clk1 :: (Integral a, Typed a) => Period a -> Phase a -> Stream Bool
period :: Integral a => a -> Period a
phase :: Integral a => a -> Phase a


-- | Main import module for the front-end lanugage.
module Copilot.Library.Libraries
