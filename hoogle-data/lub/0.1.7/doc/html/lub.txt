-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | information operators: least upper bound (lub) and greatest lower bound (glb)
--   
--   Lub is an experiment in computing least upper information bounds on
--   (partially defined) functional values. It provides a <a>lub</a>
--   function that is consistent with the <a>unamb</a> operator but has a
--   more liberal precondition. Where <a>unamb</a> requires its arguments
--   to equal when neither is bottom, <a>lub</a> is able to synthesize a
--   value from the partial information contained in both of its arguments.
--   
--   This module also defines <a>glb</a>, which intersects information.
--   
--   Project wiki page: <a>http://haskell.org/haskellwiki/lub</a>
--   
--   Â© 2008 by Conal Elliott; BSD3 license.
@package lub
@version 0.1.7


-- | Compute least upper bounds (lub / join) of two values
--   
--   This version uses associated types for HasRepr
module Data.Repr

-- | A data type representation, in terms of standard data types. Requires
--   that <tt><a>unrepr</a> . <a>repr</a> == <a>id</a></tt>.
class HasRepr t r | t -> r
repr :: HasRepr t r => t -> r
unrepr :: HasRepr t r => r -> t

-- | Apply a binary function on a repr
onRepr :: (HasRepr a ra, HasRepr b rb) => (ra -> rb) -> (a -> b)

-- | Apply a binary function on a repr
onRepr2 :: (HasRepr a ra, HasRepr b rb, HasRepr c rc) => (ra -> rb -> rc) -> (a -> b -> c)
instance HasRepr [a] (Either () (a, [a]))
instance HasRepr (Maybe a) (Either () a)


-- | Compute least upper bound (<a>lub</a>) of two values, with respect to
--   information content. I.e., merge the information available in each.
--   For flat types (in which all values are either bottom or fully
--   defined), <a>lub</a> is equivalent to <a>unamb</a>.
module Data.Lub

-- | Types that support information merging (<a>lub</a>)
class HasLub a where lubs = foldr lub undefined
lub :: HasLub a => a -> a -> a
lubs :: HasLub a => [a] -> a

-- | A <a>lub</a> for flat domains. Equivalent to <a>unamb</a>. Handy for
--   defining <a>HasLub</a> instances, e.g.,
--   
--   <pre>
--   instance HasLub Integer where lub = flatLub
--   </pre>
flatLub :: a -> a -> a

-- | Turn a binary commutative operation into that tries both orders in
--   parallel, <a>lub</a>-merging the results. Useful when there are
--   special cases that don't require evaluating both arguments.
--   
--   Similar to parCommute from Unamb, but uses <a>lub</a> instead of
--   <a>unamb</a>.
parCommute :: HasLub b => (a -> a -> b) -> (a -> a -> b)

-- | Multiplication optimized for either argument being zero or one, where
--   the other might be expensive/delayed.
ptimes :: (HasLub a, Eq a, Num a) => a -> a -> a
instance HasLub a => HasLub [a]
instance HasLub a => HasLub (Maybe a)
instance (HasLub a, HasLub b) => HasLub (Either a b)
instance HasLub b => HasLub (a -> b)
instance (HasLub a, HasLub b) => HasLub (a, b)
instance HasLub Double
instance HasLub Float
instance HasLub Integer
instance HasLub Int
instance HasLub Char
instance HasLub Bool
instance HasLub ()


-- | Greatest lower bound
module Data.Glb

-- | Types that support information intersection (<a>glb</a>)
class HasGlb a where glbs1 = foldr1 glb
glb :: HasGlb a => a -> a -> a
glbs1 :: HasGlb a => [a] -> a

-- | Bottom for a <a>glb</a>. In the form of <tt>error "glb: bottom
--   (&lt;reason&gt;)"</tt>, though not really an error.
glbBottom :: String -> a

-- | <a>glb</a> on flat types with equality. Gives bottom for unequal
--   arguments.
flatGlb :: Eq a => a -> a -> a
instance HasGlb a => HasGlb [a]
instance HasGlb a => HasGlb (Maybe a)
instance (HasGlb a, HasGlb b) => HasGlb (Either a b)
instance HasGlb b => HasGlb (a -> b)
instance (HasGlb a, HasGlb b) => HasGlb (a, b)
instance HasGlb Double
instance HasGlb Float
instance HasGlb Integer
instance HasGlb Int
instance HasGlb Char
instance HasGlb Bool
instance HasGlb ()


-- | Some laxer operations. See
--   <a>http://conal.net/blog/posts/lazier-functional-programming-part-2/</a>
module Data.Laxer

-- | Laxer variant of <a>either</a>
eitherL :: (HasLub c, HasGlb c) => (a -> c) -> (b -> c) -> (Either a b -> c)

-- | Laxer if-then-else, due to Luke Palmer
condL :: (HasLub a, HasGlb a) => a -> a -> Bool -> a
