-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Numeric Linear Algebra
--   
@package hmatrix
@version 0.16.1.5


-- | The library can be easily extended using the tools in this module.
module Numeric.LinearAlgebra.Devel

-- | Only useful since it is left associated with a precedence of 1, unlike
--   <a>$</a>, which is right associative. e.g.
--   
--   <pre>
--   someFunction
--       `appMatrixLen` m
--       `appVectorLen` v
--       `app` other
--       `app` arguments
--       `app` go here
--   </pre>
--   
--   One could also write:
--   
--   <pre>
--   (someFunction 
--       `appMatrixLen` m
--       `appVectorLen` v) 
--       other 
--       arguments 
--       (go here)
--   </pre>
app :: (a -> b) -> a -> b
appVector :: Storable a => (Ptr a -> b) -> Vector a -> b
appVectorLen :: Storable a => (CInt -> Ptr a -> b) -> Vector a -> b
appMatrix :: Element a => (Ptr a -> b) -> Matrix a -> b
appMatrixLen :: Element a => (CInt -> CInt -> Ptr a -> b) -> Matrix a -> b
appMatrixRaw :: Storable a => (Ptr a -> b) -> Matrix a -> b
appMatrixRawLen :: Element a => (CInt -> CInt -> Ptr a -> b) -> Matrix a -> b

-- | This will disregard the order of the matrix, and simply return it
--   as-is. If the order of the matrix is RowMajor, this function is
--   identical to <a>flatten</a>.
unsafeMatrixToVector :: Matrix a -> Vector a
unsafeMatrixToForeignPtr :: Storable a => Matrix a -> (ForeignPtr a, Int)
createVector :: Storable a => Int -> IO (Vector a)
createMatrix :: Storable a => MatrixOrder -> Int -> Int -> IO (Matrix a)
vec :: Storable t => Vector t -> (((CInt -> Ptr t -> t1) -> t1) -> IO b) -> IO b
mat :: Storable t => Matrix t -> (((CInt -> CInt -> Ptr t -> t1) -> t1) -> IO b) -> IO b
app1 :: f -> Adapt1 f t1
app2 :: f -> Adapt2 f t1 r1 t2
app3 :: f -> Adapt3 f t1 r1 t2 r2 t3
app4 :: f -> Adapt4 f t1 r1 t2 r2 t3 r3 t4
app5 :: f -> Adapt5 f t1 r1 t2 r2 t3 r3 t4 r4 t5
app6 :: f -> Adapt6 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6
app7 :: f -> Adapt7 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7
app8 :: f -> Adapt8 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8
app9 :: f -> Adapt9 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8 r8 t9
app10 :: f -> Adapt10 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8 r8 t9 r9 t10
data MatrixOrder
RowMajor :: MatrixOrder
ColumnMajor :: MatrixOrder
orderOf :: Matrix t -> MatrixOrder
cmat :: Element t => Matrix t -> Matrix t
fmat :: Element t => Matrix t -> Matrix t
matrixFromVector :: Storable t => MatrixOrder -> Int -> Int -> Vector t -> Matrix t

-- | <i>O(1)</i> Create a vector from a <a>ForeignPtr</a> with an offset
--   and a length.
--   
--   The data may not be modified through the <a>ForeignPtr</a> afterwards.
--   
--   If your offset is 0 it is more efficient to use
--   <a>unsafeFromForeignPtr0</a>.
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> Vector a

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with the
--   offset to the data and its length. The data may not be modified
--   through the <a>ForeignPtr</a>.
unsafeToForeignPtr :: Storable a => Vector a -> (ForeignPtr a, Int, Int)

-- | check the error code
check :: String -> IO CInt -> IO ()

-- | postfix function application (<tt>flip ($)</tt>)
(//) :: x -> (x -> y) -> y

-- | access to Vector elements without range checking
at' :: Storable a => Vector a -> Int -> a
atM' :: Storable a => Matrix a -> Int -> Int -> a

-- | specialized fromIntegral
fi :: Int -> CInt
data STVector s t
newVector :: Storable t => t -> Int -> ST s (STVector s t)
thawVector :: Storable t => Vector t -> ST s (STVector s t)
freezeVector :: Storable t => STVector s1 t -> ST s2 (Vector t)
runSTVector :: Storable t => (forall s. ST s (STVector s t)) -> Vector t
readVector :: Storable t => STVector s t -> Int -> ST s t
writeVector :: Storable t => STVector s t -> Int -> t -> ST s ()
modifyVector :: Storable t => STVector s t -> Int -> (t -> t) -> ST s ()
liftSTVector :: Storable t => (Vector t -> a) -> STVector s1 t -> ST s2 a
data STMatrix s t
newMatrix :: Storable t => t -> Int -> Int -> ST s (STMatrix s t)
thawMatrix :: Storable t => Matrix t -> ST s (STMatrix s t)
freezeMatrix :: Storable t => STMatrix s1 t -> ST s2 (Matrix t)
runSTMatrix :: Storable t => (forall s. ST s (STMatrix s t)) -> Matrix t
readMatrix :: Storable t => STMatrix s t -> Int -> Int -> ST s t
writeMatrix :: Storable t => STMatrix s t -> Int -> Int -> t -> ST s ()
modifyMatrix :: Storable t => STMatrix s t -> Int -> Int -> (t -> t) -> ST s ()
liftSTMatrix :: Storable t => (Matrix t -> a) -> STMatrix s1 t -> ST s2 a
newUndefinedVector :: Storable t => Int -> ST s (STVector s t)
unsafeReadVector :: Storable t => STVector s t -> Int -> ST s t
unsafeWriteVector :: Storable t => STVector s t -> Int -> t -> ST s ()
unsafeThawVector :: Storable t => Vector t -> ST s (STVector s t)
unsafeFreezeVector :: Storable t => STVector s1 t -> ST s2 (Vector t)
newUndefinedMatrix :: Storable t => MatrixOrder -> Int -> Int -> ST s (STMatrix s t)
unsafeReadMatrix :: Storable t => STMatrix s t -> Int -> Int -> ST s t
unsafeWriteMatrix :: Storable t => STMatrix s t -> Int -> Int -> t -> ST s ()
unsafeThawMatrix :: Storable t => Matrix t -> ST s (STMatrix s t)
unsafeFreezeMatrix :: Storable t => STMatrix s1 t -> ST s2 (Matrix t)
mapVectorWithIndex :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b

-- | zip for Vectors
zipVector :: (Storable a, Storable b, Storable (a, b)) => Vector a -> Vector b -> Vector (a, b)

-- | zipWith for Vectors
zipVectorWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | unzip for Vectors
unzipVector :: (Storable a, Storable b, Storable (a, b)) => Vector (a, b) -> (Vector a, Vector b)

-- | unzipWith for Vectors
unzipVectorWith :: (Storable (a, b), Storable c, Storable d) => ((a, b) -> (c, d)) -> Vector (a, b) -> (Vector c, Vector d)

-- | monadic map over Vectors the monad <tt>m</tt> must be strict
mapVectorM :: (Storable a, Storable b, Monad m) => (a -> m b) -> Vector a -> m (Vector b)

-- | monadic map over Vectors
mapVectorM_ :: (Storable a, Monad m) => (a -> m ()) -> Vector a -> m ()

-- | monadic map over Vectors with the zero-indexed index passed to the
--   mapping function the monad <tt>m</tt> must be strict
mapVectorWithIndexM :: (Storable a, Storable b, Monad m) => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | monadic map over Vectors with the zero-indexed index passed to the
--   mapping function
mapVectorWithIndexM_ :: (Storable a, Monad m) => (Int -> a -> m ()) -> Vector a -> m ()
foldLoop :: (Int -> t -> t) -> t -> Int -> t
foldVector :: Storable a => (a -> b -> b) -> b -> Vector a -> b
foldVectorG :: Storable t1 => (Int -> (Int -> t1) -> t -> t) -> t -> Vector t1 -> t
foldVectorWithIndex :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <pre>
--   &gt;&gt;&gt; mapMatrixWithIndex (\(i,j) v -&gt; 100*v + 10*fromIntegral i + fromIntegral j) (ident 3:: Matrix Double)
--   (3&gt;&lt;3)
--    [ 100.0,   1.0,   2.0
--    ,  10.0, 111.0,  12.0
--    ,  20.0,  21.0, 122.0 ]
--   </pre>
mapMatrixWithIndex :: (Element a, Storable b) => ((Int, Int) -> a -> b) -> Matrix a -> Matrix b

-- | <pre>
--   &gt;&gt;&gt; mapMatrixWithIndexM (\(i,j) v -&gt; Just $ 100*v + 10*fromIntegral i + fromIntegral j) (ident 3:: Matrix Double)
--   Just (3&gt;&lt;3)
--    [ 100.0,   1.0,   2.0
--    ,  10.0, 111.0,  12.0
--    ,  20.0,  21.0, 122.0 ]
--   </pre>
mapMatrixWithIndexM :: (Element a, Storable b, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m (Matrix b)

-- | <pre>
--   &gt;&gt;&gt; mapMatrixWithIndexM_ (\(i,j) v -&gt; printf "m[%d,%d] = %.f\n" i j v :: IO()) ((2&gt;&lt;3)[1 :: Double ..])
--   m[0,0] = 1
--   m[0,1] = 2
--   m[0,2] = 3
--   m[1,0] = 4
--   m[1,1] = 5
--   m[1,2] = 6
--   </pre>
mapMatrixWithIndexM_ :: (Element a, Num a, Monad m) => ((Int, Int) -> a -> m ()) -> Matrix a -> m ()

-- | application of a vector function on the flattened matrix elements
liftMatrix :: (Storable a, Storable b) => (Vector a -> Vector b) -> Matrix a -> Matrix b

-- | application of a vector function on the flattened matrices elements
liftMatrix2 :: (Element t, Element a, Element b) => (Vector a -> Vector b -> Vector t) -> Matrix a -> Matrix b -> Matrix t

-- | A version of <a>liftMatrix2</a> which automatically adapt matrices
--   with a single row or column to match the dimensions of the other
--   matrix.
liftMatrix2Auto :: (Element t, Element a, Element b) => (Vector a -> Vector b -> Vector t) -> Matrix a -> Matrix b -> Matrix t
data CSR
CSR :: Vector Double -> Vector CInt -> Vector CInt -> Int -> Int -> CSR
csrVals :: CSR -> Vector Double
csrCols :: CSR -> Vector CInt
csrRows :: CSR -> Vector CInt
csrNRows :: CSR -> Int
csrNCols :: CSR -> Int
fromCSR :: CSR -> GMatrix
mkCSR :: AssocMatrix -> CSR

-- | General matrix with specialized internal representations for dense,
--   sparse, diagonal, banded, and constant elements.
--   
--   <pre>
--   &gt;&gt;&gt; let m = mkSparse [((0,999),1.0),((1,1999),2.0)]
--   
--   &gt;&gt;&gt; m
--   SparseR {gmCSR = CSR {csrVals = fromList [1.0,2.0],
--                         csrCols = fromList [1000,2000],
--                         csrRows = fromList [1,2,3],
--                         csrNRows = 2,
--                         csrNCols = 2000},
--                         nRows = 2,
--                         nCols = 2000}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let m = mkDense (mat 2 [1..4])
--   
--   &gt;&gt;&gt; m
--   Dense {gmDense = (2&gt;&lt;2)
--    [ 1.0, 2.0
--    , 3.0, 4.0 ], nRows = 2, nCols = 2}
--   </pre>
data GMatrix
SparseR :: CSR -> Int -> Int -> GMatrix
gmCSR :: GMatrix -> CSR
nRows :: GMatrix -> Int
nCols :: GMatrix -> Int
SparseC :: CSC -> Int -> Int -> GMatrix
gmCSC :: GMatrix -> CSC
nRows :: GMatrix -> Int
nCols :: GMatrix -> Int
Diag :: Vector Double -> Int -> Int -> GMatrix
diagVals :: GMatrix -> Vector Double
nRows :: GMatrix -> Int
nCols :: GMatrix -> Int
Dense :: Matrix Double -> Int -> Int -> GMatrix
gmDense :: GMatrix -> Matrix Double
nRows :: GMatrix -> Int
nCols :: GMatrix -> Int
toByteString :: Storable t => Vector t -> ByteString
fromByteString :: Storable t => ByteString -> Vector t


-- | Basic data processing.
module Numeric.LinearAlgebra.Data

-- | create a real vector
--   
--   <pre>
--   &gt;&gt;&gt; vector [1..5]
--   fromList [1.0,2.0,3.0,4.0,5.0]
--   </pre>
vector :: [ℝ] -> Vector ℝ

-- | Create a vector from a list of elements and explicit dimension. The
--   input list is explicitly truncated if it is too long, so it may safely
--   be used, for instance, with infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; 5 |&gt; [1..]
--   fromList [1.0,2.0,3.0,4.0,5.0]
--   </pre>
(|>) :: Storable a => Int -> [a] -> Vector a

-- | create a real matrix
--   
--   <pre>
--   &gt;&gt;&gt; matrix 5 [1..15]
--   (3&gt;&lt;5)
--    [  1.0,  2.0,  3.0,  4.0,  5.0
--    ,  6.0,  7.0,  8.0,  9.0, 10.0
--    , 11.0, 12.0, 13.0, 14.0, 15.0 ]
--   </pre>
matrix :: Int -> [ℝ] -> Matrix ℝ

-- | create a general matrix
--   
--   <pre>
--   &gt;&gt;&gt; (2&gt;&lt;3) [2, 4, 7+2*𝑖,   -3, 11, 0]
--   (2&gt;&lt;3)
--    [       2.0 :+ 0.0,  4.0 :+ 0.0, 7.0 :+ 2.0
--    , (-3.0) :+ (-0.0), 11.0 :+ 0.0, 0.0 :+ 0.0 ]
--   </pre>
--   
--   The input list is explicitly truncated, so that it can safely be used
--   with lists that are too long (like infinite lists).
--   
--   <pre>
--   &gt;&gt;&gt; (2&gt;&lt;3)[1..]
--   (2&gt;&lt;3)
--    [ 1.0, 2.0, 3.0
--    , 4.0, 5.0, 6.0 ]
--   </pre>
--   
--   This is the format produced by the instances of Show (Matrix a), which
--   can also be used for input.
(><) :: Storable a => Int -> Int -> [a] -> Matrix a

-- | (conjugate) transpose
tr :: Transposable m mt => m -> mt

-- | <pre>
--   &gt;&gt;&gt; size $ fromList[1..10::Double]
--   10
--   
--   &gt;&gt;&gt; size $ (2&gt;&lt;5)[1..10::Double]
--   (2,5)
--   </pre>
size :: Container c t => c t -> IndexOf c

-- | <pre>
--   &gt;&gt;&gt; vect [1..10] ! 3
--   4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mat 5 [1..15] ! 1
--   fromList [6.0,7.0,8.0,9.0,10.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mat 5 [1..15] ! 1 ! 3
--   9.0
--   </pre>
class Indexable c t | c -> t, t -> c
(!) :: Indexable c t => c -> Int -> t

-- | create a structure with a single element
--   
--   <pre>
--   &gt;&gt;&gt; let v = fromList [1..3::Double]
--   
--   &gt;&gt;&gt; v / scalar (norm2 v)
--   fromList [0.2672612419124244,0.5345224838248488,0.8017837257372732]
--   </pre>
scalar :: Container c e => e -> c e
class Konst e d c | d -> c, c -> d
konst :: Konst e d c => e -> d -> c e
class Build d f c e | d -> c, c -> d, f -> e, f -> d, f -> c, c e -> f, d e -> f
build :: Build d f c e => d -> f -> c e

-- | Create a structure from an association list
--   
--   <pre>
--   &gt;&gt;&gt; assoc 5 0 [(3,7),(1,4)] :: Vector Double
--   fromList [0.0,4.0,0.0,7.0,0.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; assoc (2,3) 0 [((0,2),7),((1,0),2*i-3)] :: Matrix (Complex Double)
--   (2&gt;&lt;3)
--    [    0.0 :+ 0.0, 0.0 :+ 0.0, 7.0 :+ 0.0
--    , (-3.0) :+ 2.0, 0.0 :+ 0.0, 0.0 :+ 0.0 ]
--   </pre>
assoc :: Container c e => IndexOf c -> e -> [(IndexOf c, e)] -> c e

-- | Modify a structure using an update function
--   
--   <pre>
--   &gt;&gt;&gt; accum (ident 5) (+) [((1,1),5),((0,3),3)] :: Matrix Double
--   (5&gt;&lt;5)
--    [ 1.0, 0.0, 0.0, 3.0, 0.0
--    , 0.0, 6.0, 0.0, 0.0, 0.0
--    , 0.0, 0.0, 1.0, 0.0, 0.0
--    , 0.0, 0.0, 0.0, 1.0, 0.0
--    , 0.0, 0.0, 0.0, 0.0, 1.0 ]
--   </pre>
--   
--   computation of histogram:
--   
--   <pre>
--   &gt;&gt;&gt; accum (konst 0 7) (+) (map (flip (,) 1) [4,5,4,1,5,2,5]) :: Vector Double
--   fromList [0.0,1.0,1.0,0.0,2.0,3.0,0.0]
--   </pre>
accum :: Container c e => c e -> (e -> e -> e) -> [(IndexOf c, e)] -> c e

-- | Creates a real vector containing a range of values:
--   
--   <pre>
--   &gt;&gt;&gt; linspace 5 (-3,7::Double)
--   fromList [-3.0,-0.5,2.0,4.5,7.0]@
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linspace 5 (8,2+i) :: Vector (Complex Double)
--   fromList [8.0 :+ 0.0,6.5 :+ 0.25,5.0 :+ 0.5,3.5 :+ 0.75,2.0 :+ 1.0]
--   </pre>
--   
--   Logarithmic spacing can be defined as follows:
--   
--   <pre>
--   logspace n (a,b) = 10 ** linspace n (a,b)
--   </pre>
linspace :: Container Vector e => Int -> (e, e) -> Vector e

-- | creates the identity matrix of given dimension
ident :: (Num a, Element a) => Int -> Matrix a

-- | Creates a square matrix with a given diagonal.
diag :: (Num a, Element a) => Vector a -> Matrix a

-- | create a real diagonal matrix from a list
--   
--   <pre>
--   &gt;&gt;&gt; diagl [1,2,3]
--   (3&gt;&lt;3)
--    [ 1.0, 0.0, 0.0
--    , 0.0, 2.0, 0.0
--    , 0.0, 0.0, 3.0 ]
--   </pre>
diagl :: [Double] -> Matrix Double

-- | creates a rectangular diagonal matrix:
--   
--   <pre>
--   &gt;&gt;&gt; diagRect 7 (fromList [10,20,30]) 4 5 :: Matrix Double
--   (4&gt;&lt;5)
--    [ 10.0,  7.0,  7.0, 7.0, 7.0
--    ,  7.0, 20.0,  7.0, 7.0, 7.0
--    ,  7.0,  7.0, 30.0, 7.0, 7.0
--    ,  7.0,  7.0,  7.0, 7.0, 7.0 ]
--   </pre>
diagRect :: Storable t => t -> Vector t -> Int -> Int -> Matrix t

-- | extracts the diagonal from a rectangular matrix
takeDiag :: Element t => Matrix t -> Vector t

-- | <i>O(n)</i> Convert a list to a vector
fromList :: Storable a => [a] -> Vector a

-- | extracts the Vector elements to a list
--   
--   <pre>
--   &gt;&gt;&gt; toList (linspace 5 (1,10))
--   [1.0,3.25,5.5,7.75,10.0]
--   </pre>
toList :: Storable a => Vector a -> [a]

-- | takes a number of consecutive elements from a Vector
--   
--   <pre>
--   &gt;&gt;&gt; subVector 2 3 (fromList [1..10])
--   fromList [3.0,4.0,5.0]
--   </pre>
subVector :: Storable t => Int -> Int -> Vector t -> Vector t

-- | Extract consecutive subvectors of the given sizes.
--   
--   <pre>
--   &gt;&gt;&gt; takesV [3,4] (linspace 10 (1,10::Double))
--   [fromList [1.0,2.0,3.0],fromList [4.0,5.0,6.0,7.0]]
--   </pre>
takesV :: Storable t => [Int] -> Vector t -> [Vector t]

-- | concatenate a list of vectors
--   
--   <pre>
--   &gt;&gt;&gt; vjoin [fromList [1..5::Double], konst 1 3]
--   fromList [1.0,2.0,3.0,4.0,5.0,1.0,1.0,1.0]
--   </pre>
vjoin :: Storable t => [Vector t] -> Vector t

-- | Creates a vector by concatenation of rows. If the matrix is
--   ColumnMajor, this operation requires a transpose.
--   
--   <pre>
--   &gt;&gt;&gt; flatten (ident 3)
--   fromList [1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0]
--   </pre>
flatten :: Element t => Matrix t -> Vector t

-- | Creates a matrix from a vector by grouping the elements in rows with
--   the desired number of columns. (GNU-Octave groups by columns. To do it
--   you can define <tt>reshapeF r = trans . reshape r</tt> where r is the
--   desired number of rows.)
--   
--   <pre>
--   &gt;&gt;&gt; reshape 4 (fromList [1..12])
--   (3&gt;&lt;4)
--    [ 1.0,  2.0,  3.0,  4.0
--    , 5.0,  6.0,  7.0,  8.0
--    , 9.0, 10.0, 11.0, 12.0 ]
--   </pre>
reshape :: Storable t => Int -> Vector t -> Matrix t

-- | creates a 1-row matrix from a vector
--   
--   <pre>
--   &gt;&gt;&gt; asRow (fromList [1..5])
--    (1&gt;&lt;5)
--     [ 1.0, 2.0, 3.0, 4.0, 5.0 ]
--   </pre>
asRow :: Storable a => Vector a -> Matrix a

-- | creates a 1-column matrix from a vector
--   
--   <pre>
--   &gt;&gt;&gt; asColumn (fromList [1..5])
--   (5&gt;&lt;1)
--    [ 1.0
--    , 2.0
--    , 3.0
--    , 4.0
--    , 5.0 ]
--   </pre>
asColumn :: Storable a => Vector a -> Matrix a

-- | create a single row real matrix from a list
row :: [Double] -> Matrix Double

-- | create a single column real matrix from a list
col :: [Double] -> Matrix Double

-- | Create a matrix from a list of vectors. All vectors must have the same
--   dimension, or dimension 1, which is are automatically expanded.
fromRows :: Element t => [Vector t] -> Matrix t

-- | extracts the rows of a matrix as a list of vectors
toRows :: Element t => Matrix t -> [Vector t]

-- | Creates a matrix from a list of vectors, as columns
fromColumns :: Element t => [Vector t] -> Matrix t

-- | Creates a list of vectors from the columns of a matrix
toColumns :: Element t => Matrix t -> [Vector t]

-- | Creates a <a>Matrix</a> from a list of lists (considered as rows).
--   
--   <pre>
--   &gt;&gt;&gt; fromLists [[1,2],[3,4],[5,6]]
--   (3&gt;&lt;2)
--    [ 1.0, 2.0
--    , 3.0, 4.0
--    , 5.0, 6.0 ]
--   </pre>
fromLists :: Element t => [[t]] -> Matrix t

-- | the inverse of <a>fromLists</a>
toLists :: Element t => Matrix t -> [[t]]
fromArray2D :: Storable e => Array (Int, Int) e -> Matrix e

-- | Creates a matrix with the first n rows of another matrix
takeRows :: Element t => Int -> Matrix t -> Matrix t

-- | Creates a copy of a matrix without the first n rows
dropRows :: Element t => Int -> Matrix t -> Matrix t

-- | Creates a matrix with the first n columns of another matrix
takeColumns :: Element t => Int -> Matrix t -> Matrix t

-- | Creates a copy of a matrix without the first n columns
dropColumns :: Element t => Int -> Matrix t -> Matrix t

-- | Extracts a submatrix from a matrix.
subMatrix :: Element a => (Int, Int) -> (Int, Int) -> Matrix a -> Matrix a

-- | extract rows
--   
--   <pre>
--   &gt;&gt;&gt; (20&gt;&lt;4) [1..] ? [2,1,1]
--   (3&gt;&lt;4)
--    [ 9.0, 10.0, 11.0, 12.0
--    , 5.0,  6.0,  7.0,  8.0
--    , 5.0,  6.0,  7.0,  8.0 ]
--   </pre>
(?) :: Element t => Matrix t -> [Int] -> Matrix t

-- | extract columns
--   
--   (unicode 0x00bf, inverted question mark, Alt-Gr ?)
--   
--   <pre>
--   &gt;&gt;&gt; (3&gt;&lt;4) [1..] ¿ [3,0]
--   (3&gt;&lt;2)
--    [  4.0, 1.0
--    ,  8.0, 5.0
--    , 12.0, 9.0 ]
--   </pre>
(¿) :: Element t => Matrix t -> [Int] -> Matrix t

-- | Reverse columns
fliprl :: Element t => Matrix t -> Matrix t

-- | Reverse rows
flipud :: Element t => Matrix t -> Matrix t

-- | Create a matrix from blocks given as a list of lists of matrices.
--   
--   Single row-column components are automatically expanded to match the
--   corresponding common row and column:
--   
--   <pre>
--   disp = putStr . dispf 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp $ fromBlocks [[ident 5, 7, row[10,20]], [3, diagl[1,2,3], 0]]
--   8x10
--   1  0  0  0  0  7  7  7  10  20
--   0  1  0  0  0  7  7  7  10  20
--   0  0  1  0  0  7  7  7  10  20
--   0  0  0  1  0  7  7  7  10  20
--   0  0  0  0  1  7  7  7  10  20
--   3  3  3  3  3  1  0  0   0   0
--   3  3  3  3  3  0  2  0   0   0
--   3  3  3  3  3  0  0  3   0   0
--   </pre>
fromBlocks :: Element t => [[Matrix t]] -> Matrix t

-- | horizontal concatenation of real matrices
--   
--   <pre>
--   &gt;&gt;&gt; ident 3 ||| konst 7 (3,4)
--   (3&gt;&lt;7)
--    [ 1.0, 0.0, 0.0, 7.0, 7.0, 7.0, 7.0
--    , 0.0, 1.0, 0.0, 7.0, 7.0, 7.0, 7.0
--    , 0.0, 0.0, 1.0, 7.0, 7.0, 7.0, 7.0 ]
--   </pre>
(|||) :: Matrix Double -> Matrix Double -> Matrix Double

-- | vertical concatenation of real matrices
(===) :: Matrix Double -> Matrix Double -> Matrix Double

-- | create a block diagonal matrix
--   
--   <pre>
--   &gt;&gt;&gt; disp 2 $ diagBlock [konst 1 (2,2), konst 2 (3,5), col [5,7]]
--   7x8
--   1  1  0  0  0  0  0  0
--   1  1  0  0  0  0  0  0
--   0  0  2  2  2  2  2  0
--   0  0  2  2  2  2  2  0
--   0  0  2  2  2  2  2  0
--   0  0  0  0  0  0  0  5
--   0  0  0  0  0  0  0  7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; diagBlock [(0&gt;&lt;4)[], konst 2 (2,3)]  :: Matrix Double
--   (2&gt;&lt;7)
--    [ 0.0, 0.0, 0.0, 0.0, 2.0, 2.0, 2.0
--    , 0.0, 0.0, 0.0, 0.0, 2.0, 2.0, 2.0 ]
--   </pre>
diagBlock :: (Element t, Num t) => [Matrix t] -> Matrix t

-- | creates matrix by repetition of a matrix a given number of rows and
--   columns
--   
--   <pre>
--   &gt;&gt;&gt; repmat (ident 2) 2 3
--   (4&gt;&lt;6)
--    [ 1.0, 0.0, 1.0, 0.0, 1.0, 0.0
--    , 0.0, 1.0, 0.0, 1.0, 0.0, 1.0
--    , 1.0, 0.0, 1.0, 0.0, 1.0, 0.0
--    , 0.0, 1.0, 0.0, 1.0, 0.0, 1.0 ]
--   </pre>
repmat :: Element t => Matrix t -> Int -> Int -> Matrix t

-- | Partition a matrix into blocks with the given numbers of rows and
--   columns. The remaining rows and columns are discarded.
toBlocks :: Element t => [Int] -> [Int] -> Matrix t -> [[Matrix t]]

-- | Fully partition a matrix into blocks of the same size. If the
--   dimensions are not a multiple of the given size the last blocks will
--   be smaller.
toBlocksEvery :: Element t => Int -> Int -> Matrix t -> [[Matrix t]]

-- | complex conjugate
conj :: Container c e => c e -> c e

-- | like <a>fmap</a> (cannot implement instance Functor because of Element
--   class constraint)
cmap :: (Element b, Container c e) => (e -> b) -> c e -> c b

-- | A more efficient implementation of <tt>cmap (\x -&gt; if x&gt;0 then 1
--   else 0)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; step $ linspace 5 (-1,1::Double)
--   5 |&gt; [0.0,0.0,0.0,1.0,1.0]
--   </pre>
step :: (RealElement e, Container c e) => c e -> c e

-- | Element by element version of <tt>case compare a b of {LT -&gt; l; EQ
--   -&gt; e; GT -&gt; g}</tt>.
--   
--   Arguments with any dimension = 1 are automatically expanded:
--   
--   <pre>
--   &gt;&gt;&gt; cond ((1&gt;&lt;4)[1..]) ((3&gt;&lt;1)[1..]) 0 100 ((3&gt;&lt;4)[1..]) :: Matrix Double
--   (3&gt;&lt;4)
--   [ 100.0,   2.0,   3.0,  4.0
--   ,   0.0, 100.0,   7.0,  8.0
--   ,   0.0,   0.0, 100.0, 12.0 ]
--   </pre>
cond :: (RealElement e, Container c e) => c e -> c e -> c e -> c e -> c e -> c e

-- | Find index of elements which satisfy a predicate
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt;0) (ident 3 :: Matrix Double)
--   [(0,0),(1,1),(2,2)]
--   </pre>
find :: Container c e => (e -> Bool) -> c e -> [IndexOf c]

-- | index of maximum element
maxIndex :: Container c e => c e -> IndexOf c

-- | index of minimum element
minIndex :: Container c e => c e -> IndexOf c

-- | value of maximum element
maxElement :: Container c e => c e -> e

-- | value of minimum element
minElement :: Container c e => c e -> e

-- | indexing function
atIndex :: Container c e => c e -> IndexOf c -> e
sortVector :: Vector Double -> Vector Double
type AssocMatrix = [((Int, Int), Double)]
toDense :: AssocMatrix -> Matrix Double
mkSparse :: AssocMatrix -> GMatrix
mkDiagR :: Int -> Int -> Vector Double -> GMatrix
mkDense :: Matrix Double -> GMatrix

-- | print a real matrix with given number of digits after the decimal
--   point
--   
--   <pre>
--   &gt;&gt;&gt; disp 5 $ ident 2 / 3
--   2x2
--   0.33333  0.00000
--   0.00000  0.33333
--   </pre>
disp :: Int -> Matrix Double -> IO ()

-- | load a matrix from an ASCII file formatted as a 2D table.
loadMatrix :: FilePath -> IO (Matrix Double)
loadMatrix' :: FilePath -> IO (Maybe (Matrix Double))

-- | save a matrix as a 2D ASCII table
saveMatrix :: FilePath -> String -> Matrix Double -> IO ()

-- | Tool to display matrices with latex syntax.
--   
--   <pre>
--   &gt;&gt;&gt; latexFormat "bmatrix" (dispf 2 $ ident 2)
--   "\\begin{bmatrix}\n1  &amp;  0\n\\\\\n0  &amp;  1\n\\end{bmatrix}"
--   </pre>
latexFormat :: String -> String -> String

-- | Show a matrix with a given number of decimal places.
--   
--   <pre>
--   &gt;&gt;&gt; dispf 2 (1/3 + ident 3)
--   "3x3\n1.33  0.33  0.33\n0.33  1.33  0.33\n0.33  0.33  1.33\n"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . dispf 2 $ (3&gt;&lt;4)[1,1.5..]
--   3x4
--   1.00  1.50  2.00  2.50
--   3.00  3.50  4.00  4.50
--   5.00  5.50  6.00  6.50
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . unlines . tail . lines . dispf 2 . asRow $ linspace 10 (0,1)
--   0.00  0.11  0.22  0.33  0.44  0.56  0.67  0.78  0.89  1.00
--   </pre>
dispf :: Int -> Matrix Double -> String

-- | Show a matrix with "autoscaling" and a given number of decimal places.
--   
--   <pre>
--   &gt;&gt;&gt; putStr . disps 2 $ 120 * (3&gt;&lt;4) [1..]
--   3x4  E3
--    0.12  0.24  0.36  0.48
--    0.60  0.72  0.84  0.96
--    1.08  1.20  1.32  1.44
--   </pre>
disps :: Int -> Matrix Double -> String

-- | Pretty print a complex matrix with at most n decimal digits.
dispcf :: Int -> Matrix (Complex Double) -> String

-- | Creates a string from a matrix given a separator and a function to
--   show each entry. Using this function the user can easily define any
--   desired display function:
--   
--   <pre>
--   import Text.Printf(printf)
--   </pre>
--   
--   <pre>
--   disp = putStr . format "  " (printf "%.2f")
--   </pre>
format :: Element t => String -> (t -> String) -> Matrix t -> String
dispDots :: Int -> Matrix Double -> IO ()
dispBlanks :: Int -> Matrix Double -> IO ()
dispShort :: Int -> Int -> Int -> Matrix Double -> IO ()
class Convert t
real :: (Convert t, Container c t) => c (RealOf t) -> c t
complex :: (Convert t, Container c t) => c t -> c (ComplexOf t)
single :: (Convert t, Container c t) => c t -> c (SingleOf t)
double :: (Convert t, Container c t) => c t -> c (DoubleOf t)
toComplex :: (Convert t, Container c t, RealElement t) => (c t, c t) -> c (Complex t)
fromComplex :: (Convert t, Container c t, RealElement t) => c (Complex t) -> (c t, c t)
roundVector :: Vector Double -> Vector Double
arctan2 :: Container c e => c e -> c e -> c e
rows :: Matrix t -> Int
cols :: Matrix t -> Int

-- | matrix computation implemented as separated vector operations by rows
--   and columns.
separable :: Element t => (Vector t -> Vector t) -> Matrix t -> Matrix t

-- | a synonym for (<a>|||</a>) (unicode 0x00a6, broken bar)
(¦) :: Matrix Double -> Matrix Double -> Matrix Double

-- | a synonym for (<a>===</a>) (unicode 0x2014, em dash)
(——) :: Matrix Double -> Matrix Double -> Matrix Double

-- | <a>Storable</a>-based vectors
data Vector a :: * -> *

-- | Matrix representation suitable for BLAS/LAPACK computations.
--   
--   The elements are stored in a continuous memory array.
data Matrix t

-- | General matrix with specialized internal representations for dense,
--   sparse, diagonal, banded, and constant elements.
--   
--   <pre>
--   &gt;&gt;&gt; let m = mkSparse [((0,999),1.0),((1,1999),2.0)]
--   
--   &gt;&gt;&gt; m
--   SparseR {gmCSR = CSR {csrVals = fromList [1.0,2.0],
--                         csrCols = fromList [1000,2000],
--                         csrRows = fromList [1,2,3],
--                         csrNRows = 2,
--                         csrNCols = 2000},
--                         nRows = 2,
--                         nCols = 2000}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let m = mkDense (mat 2 [1..4])
--   
--   &gt;&gt;&gt; m
--   Dense {gmDense = (2&gt;&lt;2)
--    [ 1.0, 2.0
--    , 3.0, 4.0 ], nRows = 2, nCols = 2}
--   </pre>
data GMatrix
nRows :: GMatrix -> Int
nCols :: GMatrix -> Int


module Numeric.LinearAlgebra.HMatrix
dot :: Numeric t => Vector t -> Vector t -> t

-- | infix synonym for <a>dot</a>
--   
--   <pre>
--   &gt;&gt;&gt; vector [1,2,3,4] &lt;·&gt; vector [-2,0,1,1]
--   5.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let 𝑖 = 0:+1 :: ℂ
--   
--   &gt;&gt;&gt; fromList [1+𝑖,1] &lt;·&gt; fromList [1,1+𝑖]
--   2.0 :+ 0.0
--   </pre>
--   
--   (the dot symbol "·" is obtained by Alt-Gr .)
(<·>) :: Numeric t => Vector t -> Vector t -> t

-- | dense matrix-vector product
app :: Numeric t => Matrix t -> Vector t -> Vector t

-- | infix synonym for <a>app</a>
--   
--   <pre>
--   &gt;&gt;&gt; let m = (2&gt;&lt;3) [1..]
--   
--   &gt;&gt;&gt; m
--   (2&gt;&lt;3)
--    [ 1.0, 2.0, 3.0
--    , 4.0, 5.0, 6.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let v = vector [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m #&gt; v
--   fromList [140.0,320.0]
--   </pre>
(#>) :: Numeric t => Matrix t -> Vector t -> Vector t

-- | general matrix - vector product
--   
--   <pre>
--   &gt;&gt;&gt; let m = mkSparse [((0,999),1.0),((1,1999),2.0)]
--   
--   &gt;&gt;&gt; m !#&gt; vector [1..2000]
--   fromList [1000.0,4000.0]
--   </pre>
(!#>) :: GMatrix -> Vector Double -> Vector Double

-- | dense matrix product
mul :: Numeric t => Matrix t -> Matrix t -> Matrix t

-- | infix synonym of <a>mul</a>
--   
--   <pre>
--   &gt;&gt;&gt; let a = (3&gt;&lt;5) [1..]
--   
--   &gt;&gt;&gt; a
--   (3&gt;&lt;5)
--    [  1.0,  2.0,  3.0,  4.0,  5.0
--    ,  6.0,  7.0,  8.0,  9.0, 10.0
--    , 11.0, 12.0, 13.0, 14.0, 15.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b = (5&gt;&lt;2) [1,3, 0,2, -1,5, 7,7, 6,0]
--   
--   &gt;&gt;&gt; b
--   (5&gt;&lt;2)
--    [  1.0, 3.0
--    ,  0.0, 2.0
--    , -1.0, 5.0
--    ,  7.0, 7.0
--    ,  6.0, 0.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;&gt; b
--   (3&gt;&lt;2)
--    [  56.0,  50.0
--    , 121.0, 135.0
--    , 186.0, 220.0 ]
--   </pre>
(<>) :: Numeric t => Matrix t -> Matrix t -> Matrix t

-- | Outer product of two vectors.
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3] `outer` fromList [5,2,3]
--   (3&gt;&lt;3)
--    [  5.0, 2.0, 3.0
--    , 10.0, 4.0, 6.0
--    , 15.0, 6.0, 9.0 ]
--   </pre>
outer :: Product t => Vector t -> Vector t -> Matrix t

-- | Kronecker product of two matrices.
--   
--   <pre>
--   m1=(2&gt;&lt;3)
--    [ 1.0,  2.0, 0.0
--    , 0.0, -1.0, 3.0 ]
--   m2=(4&gt;&lt;3)
--    [  1.0,  2.0,  3.0
--    ,  4.0,  5.0,  6.0
--    ,  7.0,  8.0,  9.0
--    , 10.0, 11.0, 12.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kronecker m1 m2
--   (8&gt;&lt;9)
--    [  1.0,  2.0,  3.0,   2.0,   4.0,   6.0,  0.0,  0.0,  0.0
--    ,  4.0,  5.0,  6.0,   8.0,  10.0,  12.0,  0.0,  0.0,  0.0
--    ,  7.0,  8.0,  9.0,  14.0,  16.0,  18.0,  0.0,  0.0,  0.0
--    , 10.0, 11.0, 12.0,  20.0,  22.0,  24.0,  0.0,  0.0,  0.0
--    ,  0.0,  0.0,  0.0,  -1.0,  -2.0,  -3.0,  3.0,  6.0,  9.0
--    ,  0.0,  0.0,  0.0,  -4.0,  -5.0,  -6.0, 12.0, 15.0, 18.0
--    ,  0.0,  0.0,  0.0,  -7.0,  -8.0,  -9.0, 21.0, 24.0, 27.0
--    ,  0.0,  0.0,  0.0, -10.0, -11.0, -12.0, 30.0, 33.0, 36.0 ]
--   </pre>
kronecker :: Product t => Matrix t -> Matrix t -> Matrix t

-- | cross product (for three-element real vectors)
cross :: Vector Double -> Vector Double -> Vector Double

-- | multiplication by scalar
scale :: Container c e => e -> c e -> c e

-- | the sum of elements
sumElements :: Container c e => c e -> e

-- | the product of elements
prodElements :: Container c e => c e -> e

-- | Least squares solution of a linear system, similar to the \ operator
--   of Matlab/Octave (based on linearSolveSVD)
--   
--   <pre>
--   a = (3&gt;&lt;2)
--    [ 1.0,  2.0
--    , 2.0,  4.0
--    , 2.0, -1.0 ]
--   </pre>
--   
--   <pre>
--   v = vector [13.0,27.0,1.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let x = a &lt;\&gt; v
--   
--   &gt;&gt;&gt; x
--   fromList [3.0799999999999996,5.159999999999999]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a #&gt; x
--   fromList [13.399999999999999,26.799999999999997,1.0]
--   </pre>
--   
--   It also admits multiple right-hand sides stored as columns in a
--   matrix.
(<\>) :: (LSDiv c, Field t) => Matrix t -> c t -> c t

-- | Solve a linear system (for square coefficient matrix and several
--   right-hand sides) using the LU decomposition, returning Nothing for a
--   singular system. For underconstrained or overconstrained systems use
--   <a>linearSolveLS</a> or <a>linearSolveSVD</a>.
--   
--   <pre>
--   a = (2&gt;&lt;2)
--    [ 1.0, 2.0
--    , 3.0, 5.0 ]
--   </pre>
--   
--   <pre>
--   b = (2&gt;&lt;3)
--    [  6.0, 1.0, 10.0
--    , 15.0, 3.0, 26.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linearSolve a b
--   Just (2&gt;&lt;3)
--    [ -1.4802973661668753e-15,     0.9999999999999997, 1.999999999999997
--    ,       3.000000000000001, 1.6653345369377348e-16, 4.000000000000002 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Just x = it
--   
--   &gt;&gt;&gt; disp 5 x
--   2x3
--   -0.00000  1.00000  2.00000
--    3.00000  0.00000  4.00000
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;&gt; x
--   (2&gt;&lt;3)
--    [  6.0, 1.0, 10.0
--    , 15.0, 3.0, 26.0 ]
--   </pre>
linearSolve :: Field t => Matrix t -> Matrix t -> Maybe (Matrix t)

-- | Least squared error solution of an overconstrained linear system, or
--   the minimum norm solution of an underconstrained system. For
--   rank-deficient systems use <a>linearSolveSVD</a>.
linearSolveLS :: Field t => Matrix t -> Matrix t -> Matrix t

-- | Minimum norm solution of a general linear least squares problem Ax=B
--   using the SVD. Admits rank-deficient systems but it is slower than
--   <a>linearSolveLS</a>. The effective rank of A is determined by
--   treating as zero those singular valures which are less than <a>eps</a>
--   times the largest singular value.
linearSolveSVD :: Field t => Matrix t -> Matrix t -> Matrix t

-- | Solution of a linear system (for several right hand sides) from the
--   precomputed LU factorization obtained by <a>luPacked</a>.
luSolve :: Field t => (Matrix t, [Int]) -> Matrix t -> Matrix t

-- | Solve a symmetric or Hermitian positive definite linear system using a
--   precomputed Cholesky decomposition obtained by <a>chol</a>.
cholSolve :: Field t => Matrix t -> Matrix t -> Matrix t
cgSolve :: Bool -> GMatrix -> Vector Double -> Vector Double
cgSolve' :: Bool -> R -> R -> Int -> GMatrix -> V -> V -> [CGState]

-- | Inverse of a square matrix. See also <a>invlndet</a>.
inv :: Field t => Matrix t -> Matrix t

-- | Pseudoinverse of a general matrix with default tolerance
--   (<a>pinvTol</a> 1, similar to GNU-Octave).
pinv :: Field t => Matrix t -> Matrix t

-- | <tt>pinvTol r</tt> computes the pseudoinverse of a matrix with
--   tolerance <tt>tol=r*g*eps*(max rows cols)</tt>, where g is the
--   greatest singular value.
--   
--   <pre>
--   m = (3&gt;&lt;3) [ 1, 0,    0
--              , 0, 1,    0
--              , 0, 0, 1e-10] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pinv m
--   1. 0.           0.
--   0. 1.           0.
--   0. 0. 10000000000.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pinvTol 1E8 m
--   1. 0. 0.
--   0. 1. 0.
--   0. 0. 1.
--   </pre>
pinvTol :: Field t => Double -> Matrix t -> Matrix t

-- | Reciprocal of the 2-norm condition number of a matrix, computed from
--   the singular values.
rcond :: Field t => Matrix t -> Double

-- | Number of linearly independent rows or columns. See also <a>ranksv</a>
rank :: Field t => Matrix t -> Int

-- | Determinant of a square matrix. To avoid possible overflow or
--   underflow use <a>invlndet</a>.
det :: Field t => Matrix t -> t

-- | Joint computation of inverse and logarithm of determinant of a square
--   matrix.
invlndet :: Field t => Matrix t -> (Matrix t, (t, t))
class Normed a
norm_0 :: Normed a => a -> ℝ
norm_1 :: Normed a => a -> ℝ
norm_2 :: Normed a => a -> ℝ
norm_Inf :: Normed a => a -> ℝ
norm_Frob :: (Normed (Vector t), Element t) => Matrix t -> ℝ
norm_nuclear :: Field t => Matrix t -> ℝ

-- | return an orthonormal basis of the range space of a matrix. See also
--   <a>orthSVD</a>.
orth :: Field t => Matrix t -> Matrix t

-- | return an orthonormal basis of the null space of a matrix. See also
--   <a>nullspaceSVD</a>.
nullspace :: Field t => Matrix t -> Matrix t

-- | solution of overconstrained homogeneous linear system
null1 :: Matrix Double -> Vector Double

-- | solution of overconstrained homogeneous symmetric linear system
null1sym :: Matrix Double -> Vector Double

-- | Full singular value decomposition.
--   
--   <pre>
--   a = (5&gt;&lt;3)
--    [  1.0,  2.0,  3.0
--    ,  4.0,  5.0,  6.0
--    ,  7.0,  8.0,  9.0
--    , 10.0, 11.0, 12.0
--    , 13.0, 14.0, 15.0 ] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (u,s,v) = svd a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 u
--   5x5
--   -0.101   0.768   0.614   0.028  -0.149
--   -0.249   0.488  -0.503   0.172   0.646
--   -0.396   0.208  -0.405  -0.660  -0.449
--   -0.543  -0.072  -0.140   0.693  -0.447
--   -0.690  -0.352   0.433  -0.233   0.398
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s
--   fromList [35.18264833189422,1.4769076999800903,1.089145439970417e-15]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 v
--   3x3
--   -0.519  -0.751   0.408
--   -0.576  -0.046  -0.816
--   -0.632   0.659   0.408
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let d = diagRect 0 s 5 3
--   
--   &gt;&gt;&gt; disp 3 d
--   5x3
--   35.183  0.000  0.000
--    0.000  1.477  0.000
--    0.000  0.000  0.000
--    0.000  0.000  0.000
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 $ u &lt;&gt; d &lt;&gt; tr v
--   5x3
--    1.000   2.000   3.000
--    4.000   5.000   6.000
--    7.000   8.000   9.000
--   10.000  11.000  12.000
--   13.000  14.000  15.000
--   </pre>
svd :: Field t => Matrix t -> (Matrix t, Vector Double, Matrix t)

-- | A version of <a>svd</a> which returns only the <tt>min (rows m) (cols
--   m)</tt> singular vectors of <tt>m</tt>.
--   
--   If <tt>(u,s,v) = thinSVD m</tt> then <tt>m == u &lt;&gt; diag s
--   &lt;&gt; tr v</tt>.
--   
--   <pre>
--   a = (5&gt;&lt;3)
--    [  1.0,  2.0,  3.0
--    ,  4.0,  5.0,  6.0
--    ,  7.0,  8.0,  9.0
--    , 10.0, 11.0, 12.0
--    , 13.0, 14.0, 15.0 ] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (u,s,v) = thinSVD a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 u
--   5x3
--   -0.101   0.768   0.614
--   -0.249   0.488  -0.503
--   -0.396   0.208  -0.405
--   -0.543  -0.072  -0.140
--   -0.690  -0.352   0.433
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s
--   fromList [35.18264833189422,1.4769076999800903,1.089145439970417e-15]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 v
--   3x3
--   -0.519  -0.751   0.408
--   -0.576  -0.046  -0.816
--   -0.632   0.659   0.408
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 $ u &lt;&gt; diag s &lt;&gt; tr v
--   5x3
--    1.000   2.000   3.000
--    4.000   5.000   6.000
--    7.000   8.000   9.000
--   10.000  11.000  12.000
--   13.000  14.000  15.000
--   </pre>
thinSVD :: Field t => Matrix t -> (Matrix t, Vector Double, Matrix t)

-- | Similar to <a>thinSVD</a>, returning only the nonzero singular values
--   and the corresponding singular vectors.
--   
--   <pre>
--   a = (5&gt;&lt;3)
--    [  1.0,  2.0,  3.0
--    ,  4.0,  5.0,  6.0
--    ,  7.0,  8.0,  9.0
--    , 10.0, 11.0, 12.0
--    , 13.0, 14.0, 15.0 ] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (u,s,v) = compactSVD a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 u
--   5x2
--   -0.101   0.768
--   -0.249   0.488
--   -0.396   0.208
--   -0.543  -0.072
--   -0.690  -0.352
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s
--   fromList [35.18264833189422,1.4769076999800903]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 u
--   5x2
--   -0.101   0.768
--   -0.249   0.488
--   -0.396   0.208
--   -0.543  -0.072
--   -0.690  -0.352
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 $ u &lt;&gt; diag s &lt;&gt; tr v
--   5x3
--    1.000   2.000   3.000
--    4.000   5.000   6.000
--    7.000   8.000   9.000
--   10.000  11.000  12.000
--   13.000  14.000  15.000
--   </pre>
compactSVD :: Field t => Matrix t -> (Matrix t, Vector Double, Matrix t)

-- | Singular values only.
singularValues :: Field t => Matrix t -> Vector Double

-- | Singular values and all left singular vectors (as columns).
leftSV :: Field t => Matrix t -> (Matrix t, Vector Double)

-- | Singular values and all right singular vectors (as columns).
rightSV :: Field t => Matrix t -> (Vector Double, Matrix t)

-- | Eigenvalues (not ordered) and eigenvectors (as columns) of a general
--   square matrix.
--   
--   If <tt>(s,v) = eig m</tt> then <tt>m &lt;&gt; v == v &lt;&gt; diag
--   s</tt>
--   
--   <pre>
--   a = (3&gt;&lt;3)
--    [ 3, 0, -2
--    , 4, 5, -1
--    , 3, 1,  0 ] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (l, v) = eig a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . dispcf 3 . asRow $ l
--   1x3
--   1.925+1.523i  1.925-1.523i  4.151
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . dispcf 3 $ v
--   3x3
--   -0.455+0.365i  -0.455-0.365i   0.181
--           0.603          0.603  -0.978
--    0.033+0.543i   0.033-0.543i  -0.104
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . dispcf 3 $ complex a &lt;&gt; v
--   3x3
--   -1.432+0.010i  -1.432-0.010i   0.753
--    1.160+0.918i   1.160-0.918i  -4.059
--   -0.763+1.096i  -0.763-1.096i  -0.433
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr . dispcf 3 $ v &lt;&gt; diag l
--   3x3
--   -1.432+0.010i  -1.432-0.010i   0.753
--    1.160+0.918i   1.160-0.918i  -4.059
--   -0.763+1.096i  -0.763-1.096i  -0.433
--   </pre>
eig :: Field t => Matrix t -> (Vector (Complex Double), Matrix (Complex Double))

-- | Eigenvalues and eigenvectors (as columns) of a complex hermitian or
--   real symmetric matrix, in descending order.
--   
--   If <tt>(s,v) = eigSH m</tt> then <tt>m == v &lt;&gt; diag s &lt;&gt;
--   tr v</tt>
--   
--   <pre>
--   a = (3&gt;&lt;3)
--    [ 1.0, 2.0, 3.0
--    , 2.0, 4.0, 5.0
--    , 3.0, 5.0, 6.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (l, v) = eigSH a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; l
--   fromList [11.344814282762075,0.17091518882717918,-0.5157294715892575]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 $ v &lt;&gt; diag l &lt;&gt; tr v
--   3x3
--   1.000  2.000  3.000
--   2.000  4.000  5.000
--   3.000  5.000  6.000
--   </pre>
eigSH :: Field t => Matrix t -> (Vector Double, Matrix t)

-- | Similar to <a>eigSH</a> without checking that the input matrix is
--   hermitian or symmetric. It works with the upper triangular part.
eigSH' :: Field t => Matrix t -> (Vector Double, Matrix t)

-- | Eigenvalues (not ordered) of a general square matrix.
eigenvalues :: Field t => Matrix t -> Vector (Complex Double)

-- | Eigenvalues (in descending order) of a complex hermitian or real
--   symmetric matrix.
eigenvaluesSH :: Field t => Matrix t -> Vector Double

-- | Similar to <a>eigenvaluesSH</a> without checking that the input matrix
--   is hermitian or symmetric. It works with the upper triangular part.
eigenvaluesSH' :: Field t => Matrix t -> Vector Double

-- | Generalized symmetric positive definite eigensystem Av = lBv, for A
--   and B symmetric, B positive definite (conditions not checked).
geigSH' :: Field t => Matrix t -> Matrix t -> (Vector Double, Matrix t)

-- | QR factorization.
--   
--   If <tt>(q,r) = qr m</tt> then <tt>m == q &lt;&gt; r</tt>, where q is
--   unitary and r is upper triangular.
qr :: Field t => Matrix t -> (Matrix t, Matrix t)

-- | RQ factorization.
--   
--   If <tt>(r,q) = rq m</tt> then <tt>m == r &lt;&gt; q</tt>, where q is
--   unitary and r is upper triangular.
rq :: Field t => Matrix t -> (Matrix t, Matrix t)
qrRaw :: Field t => Matrix t -> (Matrix t, Vector t)

-- | generate a matrix with k orthogonal columns from the output of qrRaw
qrgr :: Field t => Int -> (Matrix t, Vector t) -> Matrix t

-- | Cholesky factorization of a positive definite hermitian or symmetric
--   matrix.
--   
--   If <tt>c = chol m</tt> then <tt>c</tt> is upper triangular and <tt>m
--   == ctrans c &lt;&gt; c</tt>.
chol :: Field t => Matrix t -> Matrix t

-- | Similar to <a>chol</a>, without checking that the input matrix is
--   hermitian or symmetric. It works with the upper triangular part.
cholSH :: Field t => Matrix t -> Matrix t

-- | Similar to <a>cholSH</a>, but instead of an error (e.g., caused by a
--   matrix not positive definite) it returns <a>Nothing</a>.
mbCholSH :: Field t => Matrix t -> Maybe (Matrix t)

-- | Hessenberg factorization.
--   
--   If <tt>(p,h) = hess m</tt> then <tt>m == p &lt;&gt; h &lt;&gt; ctrans
--   p</tt>, where p is unitary and h is in upper Hessenberg form (it has
--   zero entries below the first subdiagonal).
hess :: Field t => Matrix t -> (Matrix t, Matrix t)

-- | Schur factorization.
--   
--   If <tt>(u,s) = schur m</tt> then <tt>m == u &lt;&gt; s &lt;&gt; ctrans
--   u</tt>, where u is unitary and s is a Shur matrix. A complex Schur
--   matrix is upper triangular. A real Schur matrix is upper triangular in
--   2x2 blocks.
--   
--   "Anything that the Jordan decomposition can do, the Schur
--   decomposition can do better!" (Van Loan)
schur :: Field t => Matrix t -> (Matrix t, Matrix t)

-- | Explicit LU factorization of a general matrix.
--   
--   If <tt>(l,u,p,s) = lu m</tt> then <tt>m == p &lt;&gt; l &lt;&gt;
--   u</tt>, where l is lower triangular, u is upper triangular, p is a
--   permutation matrix and s is the signature of the permutation.
lu :: Field t => Matrix t -> (Matrix t, Matrix t, Matrix t, t)

-- | Obtains the LU decomposition of a matrix in a compact data structure
--   suitable for <a>luSolve</a>.
luPacked :: Field t => Matrix t -> (Matrix t, [Int])

-- | Matrix exponential. It uses a direct translation of Algorithm 11.3.1
--   in Golub &amp; Van Loan, based on a scaled Pade approximation.
expm :: Field t => Matrix t -> Matrix t

-- | Matrix square root. Currently it uses a simple iterative algorithm
--   described in Wikipedia. It only works with invertible matrices that
--   have a real solution.
--   
--   <pre>
--   m = (2&gt;&lt;2) [4,9
--              ,0,4] :: Matrix Double
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sqrtm m
--   (2&gt;&lt;2)
--    [ 2.0, 2.25
--    , 0.0,  2.0 ]
--   </pre>
--   
--   For diagonalizable matrices you can try <a>matFunc</a> <tt>sqrt</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; matFunc sqrt ((2&gt;&lt;2) [1,0,0,-1])
--   (2&gt;&lt;2)
--    [ 1.0 :+ 0.0, 0.0 :+ 0.0
--    , 0.0 :+ 0.0, 0.0 :+ 1.0 ]
--   </pre>
sqrtm :: Field t => Matrix t -> Matrix t

-- | Generic matrix functions for diagonalizable matrices. For instance:
--   
--   <pre>
--   logm = matFunc log
--   </pre>
matFunc :: (Complex Double -> Complex Double) -> Matrix (Complex Double) -> Matrix (Complex Double)

-- | correlation
--   
--   <pre>
--   &gt;&gt;&gt; corr (fromList[1,2,3]) (fromList [1..10])
--   fromList [14.0,20.0,26.0,32.0,38.0,44.0,50.0,56.0]
--   </pre>
corr :: (Container Vector t, Product t) => Vector t -> Vector t -> Vector t

-- | convolution (<a>corr</a> with reversed kernel and padded input,
--   equivalent to polynomial product)
--   
--   <pre>
--   &gt;&gt;&gt; conv (fromList[1,1]) (fromList [-1,1])
--   fromList [-1.0,0.0,1.0]
--   </pre>
conv :: (Container Vector t, Product t, Num t) => Vector t -> Vector t -> Vector t

-- | similar to <a>corr</a>, using <a>min</a> instead of (*)
corrMin :: (Container Vector t, RealElement t, Product t) => Vector t -> Vector t -> Vector t

-- | 2D correlation (without padding)
--   
--   <pre>
--   &gt;&gt;&gt; disp 5 $ corr2 (konst 1 (3,3)) (ident 10 :: Matrix Double)
--   8x8
--   3  2  1  0  0  0  0  0
--   2  3  2  1  0  0  0  0
--   1  2  3  2  1  0  0  0
--   0  1  2  3  2  1  0  0
--   0  0  1  2  3  2  1  0
--   0  0  0  1  2  3  2  1
--   0  0  0  0  1  2  3  2
--   0  0  0  0  0  1  2  3
--   </pre>
corr2 :: Product a => Matrix a -> Matrix a -> Matrix a

-- | 2D convolution
--   
--   <pre>
--   &gt;&gt;&gt; disp 5 $ conv2 (konst 1 (3,3)) (ident 10 :: Matrix Double)
--   12x12
--   1  1  1  0  0  0  0  0  0  0  0  0
--   1  2  2  1  0  0  0  0  0  0  0  0
--   1  2  3  2  1  0  0  0  0  0  0  0
--   0  1  2  3  2  1  0  0  0  0  0  0
--   0  0  1  2  3  2  1  0  0  0  0  0
--   0  0  0  1  2  3  2  1  0  0  0  0
--   0  0  0  0  1  2  3  2  1  0  0  0
--   0  0  0  0  0  1  2  3  2  1  0  0
--   0  0  0  0  0  0  1  2  3  2  1  0
--   0  0  0  0  0  0  0  1  2  3  2  1
--   0  0  0  0  0  0  0  0  1  2  2  1
--   0  0  0  0  0  0  0  0  0  1  1  1
--   </pre>
conv2 :: (Num (Matrix a), Product a, Container Vector a) => Matrix a -> Matrix a -> Matrix a
type Seed = Int
data RandDist

-- | uniform distribution in [0,1)
Uniform :: RandDist

-- | normal distribution with mean zero and standard deviation one
Gaussian :: RandDist

-- | Obtains a vector of pseudorandom elements (use randomIO to get a
--   random seed).
randomVector :: Seed -> RandDist -> Int -> Vector Double

-- | pseudorandom matrix with uniform elements between 0 and 1
rand :: Int -> Int -> IO (Matrix Double)

-- | pseudorandom matrix with normal elements
--   
--   <pre>
--   &gt;&gt;&gt; disp 3 =&lt;&lt; randn 3 5
--   3x5
--   0.386  -1.141   0.491  -0.510   1.512
--   0.069  -0.919   1.022  -0.181   0.745
--   0.313  -0.670  -0.097  -1.575  -0.583
--   </pre>
randn :: Int -> Int -> IO (Matrix Double)

-- | Obtains a matrix whose rows are pseudorandom samples from a
--   multivariate Gaussian distribution.
gaussianSample :: Seed -> Int -> Vector Double -> Matrix Double -> Matrix Double

-- | Obtains a matrix whose rows are pseudorandom samples from a
--   multivariate uniform distribution.
uniformSample :: Seed -> Int -> [(Double, Double)] -> Matrix Double

-- | Compute mean vector and covariance matrix of the rows of a matrix.
--   
--   <pre>
--   &gt;&gt;&gt; meanCov $ gaussianSample 666 1000 (fromList[4,5]) (diagl[2,3])
--   (fromList [4.010341078059521,5.0197204699640405],
--   (2&gt;&lt;2)
--    [     1.9862461923890056, -1.0127225830525157e-2
--    , -1.0127225830525157e-2,     3.0373954915729318 ])
--   </pre>
meanCov :: Matrix Double -> (Vector Double, Matrix Double)

-- | outer products of rows
--   
--   <pre>
--   &gt;&gt;&gt; a
--   (3&gt;&lt;2)
--    [   1.0,   2.0
--    ,  10.0,  20.0
--    , 100.0, 200.0 ]
--   
--   &gt;&gt;&gt; b
--   (3&gt;&lt;3)
--    [ 1.0, 2.0, 3.0
--    , 4.0, 5.0, 6.0
--    , 7.0, 8.0, 9.0 ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rowOuters a (b ||| 1)
--   (3&gt;&lt;8)
--    [   1.0,   2.0,   3.0,   1.0,    2.0,    4.0,    6.0,   2.0
--    ,  40.0,  50.0,  60.0,  10.0,   80.0,  100.0,  120.0,  20.0
--    , 700.0, 800.0, 900.0, 100.0, 1400.0, 1600.0, 1800.0, 200.0 ]
--   </pre>
rowOuters :: Matrix Double -> Matrix Double -> Matrix Double

-- | 1 + 0.5*peps == 1, 1 + 0.6*peps /= 1
peps :: RealFloat x => x
relativeError :: (Normed c t, Num (c t)) => NormType -> c t -> c t -> Double
haussholder :: Field a => a -> Vector a -> Matrix a
optimiseMult :: Monoid (Matrix t) => [Matrix t] -> Matrix t

-- | unconjugated dot product
udot :: Product e => Vector e -> Vector e -> e

-- | The nullspace of a matrix from its precomputed SVD decomposition.
nullspaceSVD :: Field t => Either Double Int -> Matrix t -> (Vector Double, Matrix t) -> Matrix t

-- | The range space a matrix from its precomputed SVD decomposition.
orthSVD :: Field t => Either Double Int -> Matrix t -> (Matrix t, Vector Double) -> Matrix t

-- | Numeric rank of a matrix from its singular values.
ranksv :: Double -> Int -> [Double] -> Int
type ℝ = Double
type ℂ = Complex Double

-- | imaginary unit
iC :: ℂ

-- | Supported matrix elements.
--   
--   This class provides optimized internal operations for selected element
--   types. It provides unoptimised defaults for any <a>Storable</a> type,
--   so you can create instances simply as:
--   
--   <pre>
--   instance Element Foo
--   </pre>
class Storable a => Element a where subMatrixD = subMatrix' transdata = transdataP constantD = constantP

-- | Basic element-by-element functions for numeric containers
class (Complexable c, Fractional e, Element e) => Container c e

-- | Matrix product and related functions
class (Num e, Element e) => Product e
class (Container Vector t, Container Matrix t, Konst t Int Vector, Konst t (Int, Int) Matrix, Product t) => Numeric t
class LSDiv c

-- | Structures that may contain complex numbers
class Complexable c

-- | Supported real types
class (Element t, Element (Complex t), RealFloat t) => RealElement t

-- | Generic linear algebra functions for double precision real and complex
--   matrices.
--   
--   (Single precision data can be converted using <a>single</a> and
--   <a>double</a>).
class (Product t, Convert t, Container Vector t, Container Matrix t, Normed Matrix t, Normed Vector t, Floating t, RealOf t ~ Double) => Field t
class Transposable m mt | m -> mt, mt -> m
tr :: Transposable m mt => m -> mt
data CGState
CGState :: V -> V -> R -> V -> R -> CGState

-- | conjugate gradient
cgp :: CGState -> V

-- | residual
cgr :: CGState -> V

-- | squared norm of residual
cgr2 :: CGState -> R

-- | current solution
cgx :: CGState -> V

-- | normalized size of correction
cgdx :: CGState -> R
class Testable t where ioCheckT = return . checkT
checkT :: Testable t => t -> (Bool, IO ())
ioCheckT :: Testable t => t -> IO (Bool, IO ())


-- | Experimental interface with statically checked dimensions.
--   
--   This module is under active development and the interface is subject
--   to changes.
module Numeric.LinearAlgebra.Static
type ℝ = Double
data R n
vec2 :: ℝ -> ℝ -> R 2
vec3 :: ℝ -> ℝ -> ℝ -> R 3
vec4 :: ℝ -> ℝ -> ℝ -> ℝ -> R 4
(&) :: (KnownNat n, 1 <= n) => R n -> ℝ -> R (n + 1)
(#) :: (KnownNat n, KnownNat m) => R n -> R m -> R (n + m)
split :: (KnownNat p, KnownNat n, p <= n) => R n -> (R p, R (n - p))
headTail :: (KnownNat n, 1 <= n) => R n -> (ℝ, R (n - 1))
vector :: KnownNat n => [ℝ] -> R n
linspace :: KnownNat n => (ℝ, ℝ) -> R n
range :: KnownNat n => R n
dim :: KnownNat n => R n
data L m n
type Sq n = L n n
build :: (KnownNat n, KnownNat m) => (ℝ -> ℝ -> ℝ) -> L m n
row :: R n -> L 1 n
col :: KnownNat n => R n -> L n 1
(¦) :: (KnownNat ((+) r1 r2), KnownNat r2, KnownNat c, KnownNat r1) => L c r1 -> L c r2 -> L c ((+) r1 r2)
(——) :: (KnownNat r1, KnownNat r2, KnownNat c) => L r1 c -> L r2 c -> L (r1 + r2) c
splitRows :: (KnownNat p, KnownNat m, KnownNat n, p <= m) => L m n -> (L p n, L (m - p) n)
splitCols :: (KnownNat p, KnownNat m, KnownNat n, KnownNat (n - p), p <= n) => L m n -> (L m p, L m (n - p))
unrow :: L 1 n -> R n
uncol :: KnownNat n => L n 1 -> R n

-- | (conjugate) transpose
tr :: Transposable m mt => m -> mt
eye :: KnownNat n => Sq n
diag :: KnownNat n => R n -> Sq n
blockAt :: (KnownNat m, KnownNat n) => ℝ -> Int -> Int -> Matrix Double -> L m n
matrix :: (KnownNat m, KnownNat n) => [ℝ] -> L m n
data C n
data M m n
data Her n
her :: KnownNat n => M n n -> Her n
𝑖 :: Sized ℂ s c => s
(<>) :: (KnownNat m, KnownNat k, KnownNat n) => L m k -> L k n -> L m n
(#>) :: (KnownNat m, KnownNat n) => L m n -> R n -> R m
(<·>) :: R n -> R n -> ℝ
linSolve :: (KnownNat m, KnownNat n) => L m m -> L m n -> Maybe (L m n)
(<\>) :: (KnownNat m, KnownNat n, KnownNat r) => L m n -> L m r -> L n r
svd :: (KnownNat m, KnownNat n) => L m n -> (L m m, R n, L n n)
withCompactSVD :: (KnownNat m, KnownNat n) => L m n -> (forall k. KnownNat k => (L m k, R k, L n k) -> z) -> z
svdTall :: (KnownNat m, KnownNat n, n <= m) => L m n -> (L m n, R n, L n n)
svdFlat :: (KnownNat m, KnownNat n, m <= n) => L m n -> (L m m, R m, L n m)
class Eigen m l v | m -> l, m -> v
eigensystem :: Eigen m l v => m -> (l, v)
eigenvalues :: Eigen m l v => m -> l
withNullspace :: (KnownNat m, KnownNat n) => L m n -> (forall k. KnownNat k => L n k -> z) -> z
qr :: (KnownNat m, KnownNat n) => L m n -> (L m m, L m n)
chol :: KnownNat n => Sym n -> Sq n
mean :: (KnownNat n, 1 <= n) => R n -> ℝ
class Disp t
disp :: Disp t => Int -> t -> IO ()
class Domain field vec mat | mat -> vec field, vec -> mat field, field -> mat vec
mul :: (Domain field vec mat, KnownNat m, KnownNat k, KnownNat n) => mat m k -> mat k n -> mat m n
app :: (Domain field vec mat, KnownNat m, KnownNat n) => mat m n -> vec n -> vec m
dot :: (Domain field vec mat, KnownNat n) => vec n -> vec n -> field
cross :: Domain field vec mat => vec 3 -> vec 3 -> vec 3
diagR :: (Domain field vec mat, KnownNat m, KnownNat n, KnownNat k) => field -> vec k -> mat m n
withVector :: Vector ℝ -> (forall n. KnownNat n => R n -> z) -> z
withMatrix :: Matrix ℝ -> (forall m n. (KnownNat m, KnownNat n) => L m n -> z) -> z
toRows :: (KnownNat m, KnownNat n) => L m n -> [R n]
toColumns :: (KnownNat m, KnownNat n) => L m n -> [R m]
class Num t => Sized t s d | s -> t, s -> d
konst :: Sized t s d => t -> s
unwrap :: Sized t s d => s -> d t
fromList :: Sized t s d => [t] -> s
extract :: Sized t s d => s -> d t
create :: Sized t s d => d t -> Maybe s
size :: Sized t s d => s -> IndexOf d
class Diag m d | m -> d
takeDiag :: Diag m d => m -> d
data Sym n
sym :: KnownNat n => Sq n -> Sym n
mTm :: (KnownNat m, KnownNat n) => L m n -> Sym n
unSym :: Sym n -> Sq n
instance [overlap ok] KnownNat n => Show (Sym n)
instance [overlap ok] (KnownNat n', KnownNat m') => Testable (L n' m')
instance [overlap ok] Domain ℂ C M
instance [overlap ok] Domain ℝ R L
instance [overlap ok] KnownNat n => Eigen (Sq n) (C n) (M n n)
instance [overlap ok] KnownNat n => Eigen (Sym n) (R n) (L n n)
instance [overlap ok] (KnownNat m, KnownNat n, n <= (m + 1)) => Diag (L m n) (R n)
instance [overlap ok] (KnownNat m, KnownNat n, m <= (n + 1)) => Diag (L m n) (R m)
instance [overlap ok] KnownNat n => Diag (L n n) (R n)
