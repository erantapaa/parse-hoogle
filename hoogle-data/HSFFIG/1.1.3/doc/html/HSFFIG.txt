-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate FFI import declarations from C include files
--   
--   Haskell FFI Binding Modules Generator (HSFFIG) is a tool that parses C
--   library include files (.h) and generates Haskell Foreign Functions
--   Interface import declarations for all functions, #define'd constants
--   (where possible), enumerations, and structures/unions (to access their
--   members). It is assumed that the GNU C Compiler and Preprocessor are
--   used. Auto-generated Haskell modules may be imported into an
--   application to get access to the foreign library's functions and
--   variables.
--   
--   The package provides a small library that programs using
--   auto-generated imports have to link to (specify HSFFIG as one of
--   build-depends), and two executable programs:
--   
--   <ul>
--   <li>hsffig: a filter program reading pre-processed include files from
--   standard input, and producing one large .hsc file to be processed by
--   <tt>hsc2hs</tt>, and possibly cut into pieces by <tt>modsplit</tt>.
--   See <a>http://www.haskell.org/haskellwiki/HSFFIG/Tutorial</a> for more
--   information.</li>
--   <li>ffipkg: a wrapper over <tt>hsffig</tt> which automates the process
--   of building a Cabal package out of C include files provided by running
--   the preprocessor, <tt>hsffig</tt>, the splitter, and preparing the
--   files necessary to build a package. See
--   <a>http://www.haskell.org/haskellwiki/FFI_imports_packaging_utility</a>
--   for more information.</li>
--   </ul>
--   
--   Please note that <tt>hsffig</tt> and <tt>ffipkg</tt> will likely not
--   work properly with C++ include files.
@package HSFFIG
@version 1.1.3

module HSFFIG.FieldAccess

-- | A multi-parameter class with functional dependencies is declared to
--   enable access to structures/unions members. The functional
--   dependencies <tt>a b c | a c -&gt; b</tt> specify that type of
--   <i>b</i> (type of the member) depends entirely on the types <i>a</i>
--   (phantom type identifying structure/union) and <i>c</i> (phantom type
--   identifying the member, a.k.a. member selector), and there may be only
--   one type of <i>b</i> for every possible combination of <i>a</i> and
--   <i>c</i>.
--   
--   Indeed:
--   
--   <pre>
--   struct a {
--     int x;
--   };
--   struct b {
--     float x;
--   };
--   </pre>
--   
--   both structures contain a member with the same name, but different
--   types.
--   
--   HSFFIG will generate the following instances for the structures above:
--   
--   <pre>
--   instance HSFFIG.FieldAccess.FieldAccess S_a ((CInt)) V_x where
--     z --&gt; V_x = (#peek __quote__(struct a), x) z
--     (z, V_x) &lt;-- v = (#poke __quote__(struct a), x) z v
--   ...
--   instance HSFFIG.FieldAccess.FieldAccess S_b ((CFloat)) V_x where
--    z --&gt; V_x = (#peek __quote__(struct b), x) z
--    (z, V_x) &lt;-- v = (#poke __quote__(struct b), x) z v
--   </pre>
--   
--   That is, when the member identified by selector <tt>V_x</tt> is
--   fetched from <tt>struct a</tt> (<tt>S_a</tt>), an integer value is
--   returned. But when the member with the same name is retrieved from
--   <tt>struct b</tt>, a float value is returned.
class FieldAccess a b c | a c -> b
(==>) :: FieldAccess a b c => Ptr a -> c -> b
(-->) :: FieldAccess a b c => Ptr a -> c -> IO b
(<--) :: FieldAccess a b c => (Ptr a, c) -> b -> IO ()
