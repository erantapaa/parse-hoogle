-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Almost but not quite entirely unlike FRP
--   
--   Buster is best described by the following blog post:
--   http://vis.renci.org/jeff/2009/03/31/almost-but-not-quite-entirely-like-frp/
--   
--   It is an engine for orchestrating large, complex, and multifaceted
--   applications by couching them in terms of time, events, a bus,
--   behaviours, and widgets. Time is continuous and infininte. Events are
--   discrete and exist for a particular time. The bus is a discrete sample
--   of time made available to behaviours. Behaviours are continuous and
--   exist for all time, but sample time via the bus. They filter Events to
--   determine what is on the bus at future times. Widgets are input-only
--   objects that sample the outside world and assign events to discrete
--   portions of time.
--   
--   Buster is designed to be flexible, with a flexible event model and the
--   ability to add custom data to events, and designed to be high
--   performance. It is simple to integrate with Gtk while at the same time
--   able to handle other kinds of resources, like files and sockets.
@package buster
@version 2.51


-- | Not exactly the FRP model, but rather a model of a large application
--   with heterogenous data and many inputs and outputs. An application is
--   in its essence a collection of widgets and behaviours and events with
--   a bus. The bus holds events and manages the event timeline. Behaviours
--   and widgets are continuous. Widgets applied to the bus make insertions
--   and never deletions. Behaviours applied to the bus make insertions and
--   deletions.
--   
--   Behaviours are composable using combinators that set one Behaviour as
--   either behind, in front, or beside another behaviour on the bus. The
--   in front and behind combinators establish that the behaviour
--   <a>behind</a> the others sees the results of the other behaviours'
--   application to the bus. The beside combinator says that the
--   combinators see the same bus.
module App.DebugEventBus
data BusIterationChanges
Deleted :: String -> String -> String -> String -> String -> BusIterationChanges
Inserted :: String -> String -> String -> String -> String -> BusIterationChanges
Click :: BusIterationChanges

-- | Defines the amount of time that an event exists.
data TimeSpan

-- | The event exists forever
Persistent :: TimeSpan

-- | The event exists for a specified amount of real time
Time :: DiffTime -> TimeSpan

-- | The event exists for a certain number of samples of time from its
--   inception.
Iterations :: Int -> TimeSpan
seconds :: Integer -> TimeSpan
minutes :: Integer -> TimeSpan
hours :: Integer -> TimeSpan
days :: Integer -> TimeSpan
once :: TimeSpan

-- | Defines time in terms of the differences from time t0 to the next
--   instant. This is the type returned by Behaviours to describe time
--   directly after the Behaviour.
data Diff a

-- | Time t1 contains all events at time t0 plus this event.
Insertion :: (Event a) -> Diff a

-- | Time t1 contains all events at time t0 minus this event.
Deletion :: (Event a) -> Diff a
InstrumentedBehaviour :: String -> Diff a

-- | Defines the data attachable to events.
data EData a
EString :: String -> EData a
EByteString :: ByteString -> EData a
EByteStringL :: [ByteString] -> EData a
ELByteString :: ByteString -> EData a
ELByteStringL :: [ByteString] -> EData a
EChar :: Char -> EData a
EDouble :: Double -> EData a
EInt :: Int -> EData a
EBool :: Bool -> EData a
EStringL :: [String] -> EData a
EDoubleL :: [Double] -> EData a
EIntL :: [Int] -> EData a
EBoolL :: [Bool] -> EData a
EOther :: a -> EData a
EAssoc :: (String, EData a) -> EData a
EAssocL :: [(String, EData a)] -> EData a
EOtherL :: [a] -> EData a

-- | Show without risking running into an unshowable type.
safeShow :: Maybe Int -> EData a -> String

-- | An discrete event in time
data Event a

-- | The time of the event's inception.
Event :: String -> String -> TimeSpan -> a -> String -> UTCTime -> Event a

-- | The unique name of an event. Group + src + name = the fully qualified
--   name FQN of the event.
ename :: Event a -> String

-- | The group of an event.
group :: Event a -> String

-- | The timespan from <a>time</a> that an event exists.
timespan :: Event a -> TimeSpan

-- | The data attached to the event.
eventdata :: Event a -> a

-- | The behaviour or widget that assigned the event to time.
src :: Event a -> String
time :: Event a -> UTCTime

-- | The type of a discrete sample of continuous time.
data Bus a
Bus :: Map String (Set (Event a)) -> Map String (Set (Event a)) -> Map String (Set (Event a)) -> Map (String, String, String) (Event a) -> Maybe String -> Handle -> Bus a

-- | The map of just Event.name to events.
nameMap :: Bus a -> Map String (Set (Event a))

-- | The map of just Event.src to events.
srcMap :: Bus a -> Map String (Set (Event a))

-- | The map of just Event.group to events.
groupMap :: Bus a -> Map String (Set (Event a))

-- | The map of FQNs to events.
fullyQualifiedMap :: Bus a -> Map (String, String, String) (Event a)
currentProducerConsumer :: Bus a -> Maybe String
debugout :: Bus a -> Handle
eventsByName :: String -> Bus a -> Set (Event a)
eventsBySource :: String -> Bus a -> Set (Event a)
eventsByGroup :: String -> Bus a -> Set (Event a)
eventByQName :: String -> String -> String -> Bus a -> Maybe (Event a)

-- | The empty bus
emptyBus :: Bus a

-- | Add an event to time within the bus
addEvent :: Event a -> Bus a -> Bus a

-- | The type of widgets. A widget is an input-only way to assign Events to
--   time. A mouse is a widget. A keyboard is a widget. A webcam is a
--   widget, and so on.
type Widget a = MVar (Bus a) -> IO ()

-- | The type of future events.. A behaviour doesn't know about the time
--   that it assigns events, only that they exist at some point after the
--   time that the Behaviour sampled.
type Future a = IO (Bus a, MVar [Diff a])

-- | An IO action sometime in the future.
future :: Bus a -> IO [Diff a] -> Future a

-- | Obtain the final value of a Future. Blocks until the value is
--   available
--   
--   The type of a Behaviour. A behaviour maps the bus to a list of
--   differences to apply to the bus before the next Behaviour's sample of
--   time.
type Behaviour a = Bus a -> Future a

-- | The null Behaviour. Samples the bus and adds and deletes nothing.
passthrough :: Behaviour a

-- | the in front of behaviour combinator. behaviour 1 is in front of
--   behaviour 0, so behavour 0 will see the bus filtered through behaviour
--   1
(<~<) :: Behaviour a -> Behaviour a -> Behaviour a

-- | the behind behaviour combinator. behaviour 0 is behind behaviour 1, so
--   behaviour 0 will see the bus filtered through behaviour 1
(>~>) :: Behaviour a -> Behaviour a -> Behaviour a

-- | the beside behaviour combinator. All behaviours that are side-by-side
--   see the same bus.
(|~|) :: Behaviour a -> Behaviour a -> Behaviour a

-- | An infinite loop of behaviours and widgets over time, sampled forward.
bus :: [Widget a] -> IO b -> Behaviour a -> IO ()

-- | Sample time and apply the behaviour to that sample.
busIteration :: MVar (Bus a) -> Behaviour a -> IO ()

-- | Assign an event to time given some event data and a TimeSpan.
--   
--   <pre>
--   produce group source nm timetolive edata
--   </pre>
produce :: String -> String -> String -> TimeSpan -> a -> IO (Diff a)

-- | Assign an event to time from a widget.
--   
--   <pre>
--   produce' group source nm timetolive edata bus
--   </pre>
produce' :: String -> String -> String -> TimeSpan -> a -> MVar (Bus a) -> IO ()

-- | Sample all events with a given name at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeNamedEventsCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeNamedEvents :: String -> Behaviour a
consumeEventGroup :: String -> Behaviour a
consumeEventsFromSource :: String -> Behaviour a
consumeFullyQualifiedEvent :: String -> String -> String -> Behaviour a
modifyEventData :: Event a -> (a -> a) -> [Diff a]
modifyEvent :: Event a -> (Event a -> Event a) -> [Diff a]
consumeNamedEventsWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given group at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeEventGroupCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeEventGroupWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given source at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeEventsFromSourceCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeEventsFromSourceWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample a single fully qualified event at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour. Parameter order is bus, group, source, name
consumeFullyQualifiedEventWith :: Bus a -> String -> String -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given name and apply a Behaviour
pollNamedEventsCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a given name and apply a Behaviour to each
pollNamedEventsWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given group and apply a Behaviour
pollEventGroupCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a gien group and apply a Behaviour to each.
pollEventGroupWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given source and apply a Behaviour
pollEventsFromSourceCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a given source and apply a Behaviour to each.
pollEventsFromSourceWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample a single fully qualified event and output some Diffs. Parameter
--   order is bus, group, source, name.
pollFullyQualifiedEventWith :: Bus a -> String -> String -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Apply a behaviour to all events in the bus, one event at a time.
pollAllEventsWith :: Bus a -> (Event a -> IO [Diff a]) -> Future a

-- | Apply a behaviour to the collection of all events on the bus at once
pollAllEventsCollectivelyWith :: Bus a -> (Set (Event a) -> IO [Diff a]) -> Future a
instance (Eq a) => Eq (EData a)
instance (Show a) => Show (EData a)
instance (Read a) => Read (EData a)
instance Eq TimeSpan
instance Ord TimeSpan
instance Show TimeSpan
instance Eq BusIterationChanges
instance Show BusIterationChanges
instance Read BusIterationChanges
instance Monoid (Behaviour a)
instance Monoid (Bus a)
instance Show (Bus a)
instance Eq (Event a)
instance Ord (Event a)
instance Show (Diff a)


-- | Not exactly the FRP model, but rather a model of a large application
--   with heterogenous data and many inputs and outputs. An application is
--   in its essence a collection of widgets and behaviours and events with
--   a bus. The bus holds events and manages the event timeline. Behaviours
--   and widgets are continuous. Widgets applied to the bus make insertions
--   and never deletions. Behaviours applied to the bus make insertions and
--   deletions.
--   
--   Behaviours are composable using combinators that set one Behaviour as
--   either behind, in front, or beside another behaviour on the bus. The
--   in front and behind combinators establish that the behaviour
--   <a>behind</a> the others sees the results of the other behaviours'
--   application to the bus. The beside combinator says that the
--   combinators see the same bus.
module App.EventBus

-- | Defines the amount of time that an event exists.
data TimeSpan

-- | The event exists forever
Persistent :: TimeSpan

-- | The event exists for a specified amount of real time
Time :: DiffTime -> TimeSpan

-- | The event exists for a certain number of samples of time from its
--   inception.
Iterations :: Int -> TimeSpan
seconds :: Integer -> TimeSpan
minutes :: Integer -> TimeSpan
hours :: Integer -> TimeSpan
days :: Integer -> TimeSpan
once :: TimeSpan

-- | Defines time in terms of the differences from time t0 to the next
--   instant. This is the type returned by Behaviours to describe time
--   directly after the Behaviour.
data Diff a

-- | Time t1 contains all events at time t0 plus this event.
Insertion :: (Event a) -> Diff a

-- | Time t1 contains all events at time t0 minus this event.
Deletion :: (Event a) -> Diff a

-- | Defines the data attachable to events.
data EData a
EString :: String -> EData a
EByteString :: ByteString -> EData a
EByteStringL :: [ByteString] -> EData a
ELByteString :: ByteString -> EData a
ELByteStringL :: [ByteString] -> EData a
EChar :: Char -> EData a
EDouble :: Double -> EData a
EInt :: Int -> EData a
EBool :: Bool -> EData a
EStringL :: [String] -> EData a
EDoubleL :: [Double] -> EData a
EIntL :: [Int] -> EData a
EBoolL :: [Bool] -> EData a
EOther :: a -> EData a
EAssoc :: (String, EData a) -> EData a
EAssocL :: [(String, EData a)] -> EData a
EOtherL :: [a] -> EData a

-- | Show without risking running into an unshowable type.
safeShow :: Maybe Int -> EData a -> String

-- | An discrete event in time
data Event a

-- | The time of the event's inception.
Event :: String -> String -> TimeSpan -> a -> String -> UTCTime -> Event a

-- | The unique name of an event. Group + src + name = the fully qualified
--   name FQN of the event.
ename :: Event a -> String

-- | The group of an event.
group :: Event a -> String

-- | The timespan from <a>time</a> that an event exists.
timespan :: Event a -> TimeSpan

-- | The data attached to the event.
eventdata :: Event a -> a

-- | The behaviour or widget that assigned the event to time.
src :: Event a -> String
time :: Event a -> UTCTime

-- | The type of a discrete sample of continuous time.
data Bus a

-- | The map of FQNs to events.
Bus :: Map String (Set (Event a)) -> Map String (Set (Event a)) -> Map String (Set (Event a)) -> Map (String, String, String) (Event a) -> Bus a

-- | The map of just Event.name to events.
nameMap :: Bus a -> Map String (Set (Event a))

-- | The map of just Event.src to events.
srcMap :: Bus a -> Map String (Set (Event a))

-- | The map of just Event.group to events.
groupMap :: Bus a -> Map String (Set (Event a))
fullyQualifiedMap :: Bus a -> Map (String, String, String) (Event a)
eventsByName :: String -> Bus a -> Set (Event a)
eventsBySource :: String -> Bus a -> Set (Event a)
eventsByGroup :: String -> Bus a -> Set (Event a)
eventByQName :: String -> String -> String -> Bus a -> Maybe (Event a)

-- | The empty bus
emptyBus :: Bus a

-- | Add an event to time within the bus
addEvent :: Event a -> Bus a -> Bus a

-- | The type of widgets. A widget is an input-only way to assign Events to
--   time. A mouse is a widget. A keyboard is a widget. A webcam is a
--   widget, and so on.
type Widget a = MVar (Bus a) -> IO ()

-- | The type of future events.. A behaviour doesn't know about the time
--   that it assigns events, only that they exist at some point after the
--   time that the Behaviour sampled.
type Future a = IO (Bus a, MVar [Diff a])

-- | An IO action sometime in the future.
future :: Bus a -> IO [Diff a] -> Future a

-- | Obtain the final value of a Future. Blocks until the value is
--   available
--   
--   The type of a Behaviour. A behaviour maps the bus to a list of
--   differences to apply to the bus before the next Behaviour's sample of
--   time.
type Behaviour a = Bus a -> Future a

-- | The null Behaviour. Samples the bus and adds and deletes nothing.
passthrough :: Behaviour a

-- | the in front of behaviour combinator. behaviour 1 is in front of
--   behaviour 0, so behavour 0 will see the bus filtered through behaviour
--   1
(<~<) :: Behaviour a -> Behaviour a -> Behaviour a

-- | the behind behaviour combinator. behaviour 0 is behind behaviour 1, so
--   behaviour 0 will see the bus filtered through behaviour 1
(>~>) :: Behaviour a -> Behaviour a -> Behaviour a

-- | the beside behaviour combinator. All behaviours that are side-by-side
--   see the same bus.
(|~|) :: Behaviour a -> Behaviour a -> Behaviour a

-- | An infinite loop of behaviours and widgets over time, sampled forward.
bus :: [Widget a] -> IO b -> Behaviour a -> IO ()

-- | Sample time and apply the behaviour to that sample.
busIteration :: MVar (Bus a) -> Behaviour a -> IO ()

-- | Assign an event to time given some event data and a TimeSpan.
--   
--   <pre>
--   produce group source nm timetolive edata
--   </pre>
produce :: String -> String -> String -> TimeSpan -> a -> IO (Diff a)

-- | Assign an event to time from a widget.
--   
--   <pre>
--   produce' group source nm timetolive edata bus
--   </pre>
produce' :: String -> String -> String -> TimeSpan -> a -> MVar (Bus a) -> IO ()

-- | Sample all events with a given name at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeNamedEventsCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeNamedEvents :: String -> Behaviour a
consumeEventGroup :: String -> Behaviour a
consumeEventsFromSource :: String -> Behaviour a
consumeFullyQualifiedEvent :: String -> String -> String -> Behaviour a
modifyEventData :: Event a -> (a -> a) -> [Diff a]
modifyEvent :: Event a -> (Event a -> Event a) -> [Diff a]
consumeNamedEventsWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given group at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeEventGroupCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeEventGroupWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given source at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour.
consumeEventsFromSourceCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a
consumeEventsFromSourceWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample a single fully qualified event at the current time and output
--   their deletions as Diffs as well as any additional Diffs returned by
--   the behaviour. Parameter order is bus, group, source, name
consumeFullyQualifiedEventWith :: Bus a -> String -> String -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given name and apply a Behaviour
pollNamedEventsCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a given name and apply a Behaviour to each
pollNamedEventsWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given group and apply a Behaviour
pollEventGroupCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a gien group and apply a Behaviour to each.
pollEventGroupWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample all events with a given source and apply a Behaviour
pollEventsFromSourceCollectivelyWith :: Bus a -> String -> (Set (Event a) -> IO [Diff a]) -> Future a

-- | Sample all events with a given source and apply a Behaviour to each.
pollEventsFromSourceWith :: Bus a -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Sample a single fully qualified event and output some Diffs. Parameter
--   order is bus, group, source, name.
pollFullyQualifiedEventWith :: Bus a -> String -> String -> String -> (Event a -> IO [Diff a]) -> Future a

-- | Apply a behaviour to all events in the bus, one event at a time.
pollAllEventsWith :: Bus a -> (Event a -> IO [Diff a]) -> Future a

-- | Apply a behaviour to the collection of all events on the bus at once
pollAllEventsCollectivelyWith :: Bus a -> (Set (Event a) -> IO [Diff a]) -> Future a
instance (Eq a) => Eq (EData a)
instance (Show a) => Show (EData a)
instance (Read a) => Read (EData a)
instance Eq TimeSpan
instance Ord TimeSpan
instance Show TimeSpan
instance Monoid (Behaviour a)
instance Monoid (Bus a)
instance Show (Bus a)
instance Eq (Event a)
instance Ord (Event a)
instance Show (Diff a)

module App.Behaviours.PrintEvents
printEventsBehaviour :: Behaviour [EData a]
printEventGroupBehaviour :: String -> Behaviour [EData a]
printEventNameBehaviour :: String -> Behaviour [EData a]
printEventSourceBehaviour :: String -> Behaviour [EData a]
printQNameBehaviour :: Behaviour a
checkpoint :: String -> Behaviour a
logEventsBehaviour :: Handle -> Behaviour [EData a]
logEventGroupBehaviour :: Handle -> String -> Behaviour [EData a]
logEventNameBehaviour :: Handle -> String -> Behaviour [EData a]
logEventSourceBehaviour :: Handle -> String -> Behaviour [EData a]


-- | Handle exceptions slightly more gracefully than the Haskell runtime
--   does.
module App.Behaviours.Exception

-- | Bork the program when an unhandled exception makes it to this
--   behaviour. Catches all events with the group "Exception" and throws
--   them as one big exception.
unhandledExceptionBehaviour :: Behaviour [EData a]

-- | Handle exceptions by completely ignoring them. Not recommended,
--   really, but hey, who am I to judge?
disregardExceptionsFromSource :: String -> Behaviour [EData a]

-- | Handle exceptions by completely ignoring them. Not recommended,
--   really, but hey, who am I to judge?
disregardExceptionsNamed :: String -> Behaviour [EData a]

-- | Handle exceptions by printing them to stdout and then completely
--   ignoring them.
printAndDisregardExceptionsFromSource :: String -> Behaviour [EData a]

-- | Handle exceptions by printing them to stdout and then completely
--   ignoring them
printAndDisregardExceptionsNamed :: String -> Behaviour [EData a]

-- | Handle exceptions by printing them to a handle and then completely
--   ignoring them.
logAndDisregardExceptionsFromSource :: Handle -> String -> Behaviour [EData a]

-- | Handle exceptions by printing them to handle and then completely
--   ignoring them
logAndDisregardExceptionsNamed :: Handle -> String -> Behaviour [EData a]


-- | This module handles read, write, encode, and decode of files. It also
--   cleanly handles exceptions by introducing Exception events that are
--   handlable by the behaviours in <a>App.Behaviours.Exception</a> which
--   exit your program gracefully, or by your own user defined exception
--   handlers.
--   
--   It can handle datatypes <tt>EData a</tt> with Binary, Show, and Read
--   instances as well.
module App.Behaviours.FileOps

-- | <tt>readFileBehaviour name datatype</tt> looks for any event with the
--   name <i>name</i> and reads the file into an event following the
--   pattern:
--   
--   <ul>
--   <li>name: same as filename.</li>
--   <li>group: same as name of the behaviour, <tt>name</tt></li>
--   <li>source: "ReadSource"</li>
--   <li>timespan: Persistent</li>
--   <li>eventdata: the file, read in and processed using <tt>read</tt> to
--   be of the datatype that corresponds to the constructor in the
--   <tt>datatype</tt> parameter.</li>
--   </ul>
--   
--   NOTE: This function can only be used with <tt>EData a</tt> where
--   <tt>a</tt> has a <a>Read</a> instance. For event data without a read
--   instance, use <a>readFileBehaviourNR</a>
readFileBehaviour :: (Read a) => String -> EData a -> Behaviour [EData a]

-- | <tt>readFileBehaviourNR name datatype</tt> looks for any event with
--   the name <i>name</i> and reads the file into an event following the
--   pattern:
--   
--   <ul>
--   <li>name: same as filename.</li>
--   <li>group: same as name of the behaviour, <tt>name</tt></li>
--   <li>source: "ReadSource"</li>
--   <li>timespan: Persistent</li>
--   <li>eventdata: the file, read in and processed using <a>read</a> to be
--   of the datatype that corresponds to the constructor in the
--   <tt>datatype</tt> parameter. The constructor itself should not be
--   serialized.</li>
--   </ul>
--   
--   NOTE: Attempting to read datatype <tt>EOther a</tt> using this will
--   cause the program to emit an event with "Exception" as the group and
--   <i>name</i> as the source.
readFileBehaviourNR :: String -> EData a -> Behaviour [EData a]

-- | <tt>decodeFileBehaviour name datatype</tt> looks for any event with
--   the name <i>name</i> and reads the file into an event following the
--   pattern:
--   
--   <ul>
--   <li>name: same as filename.</li>
--   <li>group: same as name of the behaviour, <tt>name</tt></li>
--   <li>source: "ReadSource"</li>
--   <li>timespan: Persistent</li>
--   <li>eventdata: the file, read in and processed using <a>decodeFile</a>
--   to be of the datatype that corresponds to the constructor in the
--   <tt>datatype</tt> parameter. The constructor itself need not be
--   serialized.</li>
--   </ul>
--   
--   NOTE: This function can only be used with <tt>EData a</tt> where
--   <tt>a</tt> has a <a>Binary</a> instance. For event data without a read
--   instance, use <a>decodeFileBehaviourNB</a>
decodeFileBehaviour :: (Binary a) => String -> EData a -> Behaviour [EData a]

-- | <tt>readFileBehaviour name datatype</tt> looks for any event with the
--   name <i>name</i> and reads the file into an event following the
--   pattern:
--   
--   <ul>
--   <li>name: same as filename.</li>
--   <li>group: same as name of the behaviour, <tt>name</tt></li>
--   <li>source: "ReadSource"</li>
--   <li>timespan: Persistent</li>
--   <li>eventdata: the file, read in and processed using <tt>read</tt> to
--   be of the datatype that corresponds to the constructor in the
--   <tt>datatype</tt> parameter.</li>
--   </ul>
--   
--   NOTE: Attempting to read datatype <tt>EOther a</tt> using this will
--   cause the program to raise an Event with "Exception" as the group.
decodeFileBehaviourNB :: String -> EData a -> Behaviour [EData a]

-- | <tt>writeFileBehaviour</tt> looks for "WriteFile" named events with
--   event data corresponding to <tt>[EString filepath,</tt> <i>data
--   constructor</i> <tt>contents]</tt> and removes them from the bus,
--   writing the file named <tt>filepath</tt>. Any error is placed on the
--   bus with an Exception event with "WriteFile" as the source.
writeFileBehaviourNS :: Behaviour [EData a]

-- | <tt>writeFileBehaviour</tt> looks for "WriteFile" named events with
--   event data corresponding to <tt>[EString filepath,</tt> <i>data
--   constructor</i> <tt>contents]</tt> and removes them from the bus,
--   writing the file named <tt>filepath</tt>. Any error is placed on the
--   bus with an Exception event with "WriteFile" as the source.
--   
--   NOTE: Attempting to encode 'EOther a' using this will raise an
--   Exception.
writeFileBehaviour :: (Show a) => Behaviour [EData a]

-- | <tt>writeFileBehaviour</tt> looks for "WriteFile" named events with
--   event data corresponding to <tt>[EString filepath,</tt> <i>data
--   constructor</i> <tt>contents]</tt> and removes them from the bus,
--   writing the file named <tt>filepath</tt>. Any error is placed on the
--   bus with an Exception event with "WriteFile" as the source.
--   
--   NOTE: Attempting to encode 'EOther a' using this will raise an
--   Exception.
encodeFileBehaviourNB :: Behaviour [EData a]

-- | <tt>writeFileBehaviour</tt> looks for "WriteFile" named events with
--   event data corresponding to <tt>[EString filepath,</tt> <i>data
--   constructor</i> <tt>contents]</tt> and removes them from the bus,
--   writing the file named <tt>filepath</tt>. Any error is placed on the
--   bus with an Exception event with "WriteFile" as the source.
--   
--   NOTE: This can only be used with an EData a where a has a
--   <a>Binary</a> instance.
encodeFileBehaviour :: (Binary a) => Behaviour [EData a]


-- | Widgets for sending a heartbeat out onto the bus to be caught by other
--   behaviours.
module App.Widgets.Pacer

-- | <tt>paceMicrosecondsWidget timeout timername bus</tt> | | Send a
--   heartbeat event out every <i>timeout</i> microseconds to the bus
paceMicrosecondsWidget :: Int -> String -> Widget [a]

-- | <tt>paceMillisecondsWidget timeout timername bus</tt> | | Send a
--   heartbeat event out every <i>timeout</i> milliseconds to the bus
paceMillisecondsWidget :: Int -> String -> Widget [a]

-- | <tt>paceSecondsWidget timeout timername bus</tt> | | Send a heartbeat
--   event out every <i>timeout</i> seconds to the bus
paceSecondsWidget :: Double -> String -> Widget [a]

module App.Widgets.Environment

-- | Place the command line arguments on the bus as an Event following the
--   pattern
--   
--   <ul>
--   <li>name : argv</li>
--   <li>group : Environment</li>
--   <li>source : CommandLineArgsWidget</li>
--   <li>timespan : Persistent</li>
--   <li>data : EStringL of the command line args</li>
--   </ul>
commandLineArgsWidget :: Widget [EData a]

-- | Read a config file and place it on the bus as individual events for
--   each config item following the pattern:
--   
--   <ul>
--   <li>name : config item name</li>
--   <li>group : Environment</li>
--   <li>source : <i>filename</i>.ConfigFileWidget</li>
--   <li>timespan : Persistent</li>
--   <li>data : EString config item value</li>
--   </ul>
--   
--   Config files follow a fairly simple grammar:
--   
--   ConfigFile := [ConfigLine]
--   
--   ConfigLine := <a>key</a> spaces = spaces <a>value</a> endl |
--   CommentLine | BlankLine
--   
--   CommentLine := # anychars endl
--   
--   BlankLine := spaces endl
configFileWidget :: String -> Widget [EData a]

-- | Read in all environment variables and place them on the bus
--   individually as events following the pattern:
--   
--   <ul>
--   <li>name : variable name</li>
--   <li>group : Environment</li>
--   <li>source : EnvironmentWidget</li>
--   <li>timespan : Persistent</li>
--   <li>data : EString variable value</li>
--   </ul>
environmentWidget :: Widget [EData a]

-- | Set the program name as an event on the bus using the following
--   pattern:
--   
--   <ul>
--   <li>name : ProgramName</li>
--   <li>group : Environment</li>
--   <li>source : ProgramNameWidget</li>
--   <li>timespan : Persistent</li>
--   <li>data : EString progran name</li>
--   </ul>
progNameWidget :: Widget [EData a]
