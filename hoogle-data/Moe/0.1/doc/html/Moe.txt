-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A FRP library based on signal functions.
--   
--   A FRP library based on signal functions.
@package Moe
@version 0.1

module FRP.Moe.Core
type DTime = Double

-- | SF a b can be seen as a function from [x1, x2, ...] to [y1, y2, ...],
--   in which
--   
--   x1, x2, ... have the type of a, and y1, y2, ... have the type of b.
--   Notice that
--   
--   each value is in fact a sample of a continuous temporal function of
--   values in
--   
--   some certain time. The time stamps are omitted in most of the
--   comments.
newtype SF a b
MkSF :: (DTime -> a -> (b, SF a b)) -> SF a b
runSF :: SF a b -> DTime -> a -> (b, SF a b)

-- | Input: [x1, x2, ...]
--   
--   Output: [x1, x2, ...]
sfId :: SF a a

-- | Input: [x1, x2, ...]
--   
--   Output: [f x1, f x2, ...]
sfArr :: (a -> b) -> SF a b

-- | Input of sf1: [y1, y2, ...]
--   
--   Output of sf1: [z1, z2, ...]
--   
--   Input of sf2: [x1, x2, ...]
--   
--   Output of sf2: [y1, y2, ...]
--   
--   Input: [x1, x2, ...]
--   
--   Output: [z1, z2, ...]
sfComp :: SF b c -> SF a b -> SF a c

-- | Returns a signal function that:
--   
--   Input: [x1, x2, ...]
--   
--   Output: [y1, y2, ...]
--   
--   whenever the following property holds for sf:
--   
--   Input of sf: [(x1, z1), (x2, z2), ...]
--   
--   Output of sf: [(y1, z1), (y2, z2), ...]
sfLoop :: SF (a, c) (b, c) -> SF a b

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [y1, y2, ...]
--   
--   Input: [(x1, z1), (x2, z2), ...]
--   
--   Output: [(y1, z1), (y2, z2), ...]
sfFirst :: SF a b -> SF (a, c) (b, c)

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [y1, y2, ...]
--   
--   Input: [(z1, x1), (z2, x2), ...]
--   
--   Output: [(z1, y1), (z2, y2), ...]
sfSecond :: SF a b -> SF (c, a) (c, b)

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [y1, y2, ...]
--   
--   Input: [Left x1, Right z1, Left x2, ...]
--   
--   Output: [Left y1, Right z1, Left y2, ...]
sfLeft :: SF a b -> SF (Either a c) (Either b c)

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [y1, y2, ...]
--   
--   Input: [Right x1, Left z1, Right x2, ...]
--   
--   Output: [Right y1, Left z2, Right y2, ...]
sfRight :: SF a b -> SF (Either c a) (Either c b)

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [x0, x1, x2, ...]
sfDelay :: a -> SF a a

-- | Input of sf: [x1, x2, ...]
--   
--   Output of sf: [dt1, dt2, ...] (dt_i is the time interval between
--   x_(i-1) and x_i)
dTime :: SF () DTime
class Arrow a => ArrowDelay a
delay :: ArrowDelay a => b -> a b b
data Event a
Event :: a -> Event a
NoEvent :: Event a

-- | Input of sf: [x1, x2, x3, ...]
--   
--   Output of sf: [(y1, NoEvent), (y2, Event e1), (y3, NoEvent), ...]
--   
--   Input of (gen e): [x2, x3, ...]
--   
--   Output of (gen e): [y(e1)1, y(e1)2, ...]
--   
--   Input: [x1, x2, x3, ...]
--   
--   Output: [y1, y(e1)1, y(e1)2, ...]
switch :: SF b (c, Event d) -> (d -> SF b c) -> SF b c

-- | Input of sf: [x1, x2, x3, ...]
--   
--   Output of sf: [(y1, NoEvent), (y2, Event e1), (y3, NoEvent), ...]
--   
--   Input of (gen e): [x2, x3, ...]
--   
--   Output of (gen e): [y(e1)1, y(e1)2, ...]
--   
--   Input: [x1, x2, x3, ...]
--   
--   Output: [y1, y2, y(e1)2, ...]
dswitch :: SF b (c, Event d) -> (d -> SF b c) -> SF b c

-- | Input of sf: [x1, x2, x3, ...]
--   
--   Output of sf: [y1, y2, y3, ...]
--   
--   Input of sfe: [(x1, y1), (x2, y2), (x3, y3), ...]
--   
--   Output of sfe: [NoEvent, Event e1, NoEvent, ...]
--   
--   Input of (gen sf3 e1): [x2, x3, ...]
--   
--   Output of (gen sf3 e1): [y(sf3,e1)1, y(sf3,e1)2, ...]
--   
--   Input: [x1, x2, x3, ...]
--   
--   Output: [y1, y(sf3,e1)1, y(sf3,e2)2, ...]
--   
--   where sf1 = [x1, x2, x3, ...] -- ^&gt; [y1, y2, y3, ...]
--   
--   sf2 = [x2, x3, ...] -- ^&gt; [y2, y3, ...]
--   
--   sf3 = [x3, ...] -- ^&gt; [y3, ...]
--   
--   ...
kswitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b

-- | Input of sf: [x1, x2, x3, ...]
--   
--   Output of sf: [y1, y2, y3, ...]
--   
--   Input of sfe: [(x1, y1), (x2, y2), (x3, y3), ...]
--   
--   Output of sfe: [NoEvent, Event e1, NoEvent, ...]
--   
--   Input of (gen sf3 e1): [x2, x3, ...]
--   
--   Output of (gen sf3 e1): [y(sf3,e1)1, y(sf3,e1)2, ...]
--   
--   Input: [x1, x2, x3, ...]
--   
--   Output: [y1, y2, y(sf3,e2)2, ...]
--   
--   where sf1 = [x1, x2, x3, ...] -- ^&gt; [y1, y2, y3, ...]
--   
--   sf2 = [x2, x3, ...] -- ^&gt; [y2, y3, ...]
--   
--   sf3 = [x3, ...] -- ^&gt; [y3, ...]
--   
--   ...
dkswitch :: SF a b -> SF (a, b) (Event c) -> (SF a b -> c -> SF a b) -> SF a b
pswitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
dpswitch :: Functor col => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)

-- | Get the element (x_n) the output [y1, y2, ...] of sf.
--   
--   Time interval is fixed to (dt).
nth :: Int -> DTime -> SF () a -> a

-- | Turn sf into a stream function.
gen :: SF a b -> [(DTime, a)] -> [b]
instance ArrowChoice SF
instance ArrowDelay SF
instance ArrowLoop SF
instance Arrow SF
instance Category SF
instance Applicative (SF a)
instance Functor (SF a)
instance Monoid b => Monoid (SF a b)

module FRP.Moe.Combinators

-- | Input: <a>i1, i2, ...</a> (ignored)
--   
--   Output: <a>x, x, ...</a>
sfConst :: a -> SF b a

-- | Input: <a>(), (), ...</a>
--   
--   Outputs the sequence of the current time at each sample point
time :: SF () Double

-- | Input: <a>i1, i2, ...</a> (ignored)
--   
--   Outputs a sequence of random generated numbers using g0
noise :: (Random a, RandomGen b) => b -> SF () a

-- | Input: <a>i1, i2, ...</a> (ignored)
--   
--   Outputs a sequence of random generated numbers using g0, with lh
--   
--   indicating the minimum and maximum numbers that are allowed.
noiseR :: (Random a, RandomGen b) => (a, a) -> b -> SF () a

-- | rep n sf = sf &gt;&gt;&gt; sf &gt;&gt;&gt; ... &gt;&gt;&gt; sf (n
--   times)
rep :: Int -> SF a a -> SF a a

-- | xs: [x1, x2, x3]
--   
--   Input: <a>(), (), (), (), (), ...</a>
--   
--   Output: <a>x1, x2, x3, x1, x2, ...</a>
cycle :: [a] -> SF () a
timedCycle :: [(DTime, a)] -> SF () a
data MemOp a
Read :: MemOp a
Write :: a -> MemOp a

-- | Input: <a>Read, Write x1, Read, ...</a>
--   
--   Output: <a>x0, x1, x1, ...</a>
memory :: a -> SF (MemOp a) a

-- | Input: <a>(), (), (), ...</a>
--   
--   Output: <a>x0, f x0, f (f x0), ...</a>
stateful :: (a -> a) -> a -> SF () a

-- | Input: <a>i1, i2, i3, ...</a>
--   
--   Output: <a>x0, f x0 i1, f (f x0 i1) i2, ...</a>
stateful2 :: (a -> b -> a) -> a -> SF b a

-- | Simple integration
integral :: SF Double Double
broadcast :: Functor col => col sf -> a -> col (a, sf)

module FRP.MoePure

module FRP.MoeGLUT
type Time = Int
type Input = Maybe (Key, KeyState, Modifiers, Position)
type Prog b = SF Input b
type Handle b = IORef (Prog b, Time, b)
timer :: Handle b -> Int -> (b -> IO ()) -> IdleCallback
keyMouse :: Handle b -> KeyboardMouseCallback
defaultReshape :: ReshapeCallback
data DisplaySetup
DisplaySetup :: String -> [DisplayMode] -> Size -> Position -> Color4 GLclampf -> ReshapeCallback -> ((String, [String]) -> IO ()) -> DisplaySetup
displayTitle :: DisplaySetup -> String
displayMode :: DisplaySetup -> [DisplayMode]
displaySize :: DisplaySetup -> Size
displayPosition :: DisplaySetup -> Position
displayColor :: DisplaySetup -> Color4 GLclampf
displayReshape :: DisplaySetup -> ReshapeCallback
displayInit :: DisplaySetup -> (String, [String]) -> IO ()
startProg :: DisplaySetup -> Int -> Prog b -> b -> (b -> IO ()) -> IO ()

module FRP.Moe
