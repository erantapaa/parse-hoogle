-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interpreter and language infrastructure for Boogie.
--   
--   Boogaloo is an interpreter and run-time assertion checker for the
--   Boogie intermediate verification language. The package also provides a
--   language infrastructure library, including a Boogie AST, parser, type
--   checker, and pretty-printer.
@package language-boogie
@version 0.2


-- | Deterministic and non-deterministic input generators
module Language.Boogie.Generator

-- | Input generator
data Generator m
Generator :: m Bool -> m Integer -> (Int -> m Int) -> Generator m
genBool :: Generator m -> m Bool
genInteger :: Generator m -> m Integer
genIndex :: Generator m -> Int -> m Int

-- | Always generates the same default value
defaultGenerator :: Generator Identity

-- | Generates all possible values once, in a predefined order
exhaustiveGenerator :: Maybe Integer -> Generator Stream

-- | Generated values randomly; the same value can be generated multiple
--   times
randomGenerator :: StdGen -> Maybe Integer -> Generator Stream

-- | <a>intInterval</a> <tt>n</tt>: interval centered around 0 of size n
intInterval :: Integral t => t -> (t, t)

-- | <a>natInterval</a> <tt>n</tt>: interval starting from 0 of size n
natInterval :: (Num t, Num t1) => t1 -> (t, t1)

-- | Convert a (possibly infinite) nonempty list into a stream
fromList :: [a] -> Stream a


-- | Lattice of integer intervals
module Language.Boogie.Intervals

-- | Lattice type class
class Eq a => Lattice a where x <: y = meet x y == x
top :: Lattice a => a
bot :: Lattice a => a
(<:) :: Lattice a => a -> a -> Bool
join :: Lattice a => a -> a -> a
meet :: Lattice a => a -> a -> a

-- | Integers extended with infinity
data Extended
NegInf :: Extended
Finite :: Integer -> Extended
Inf :: Extended

-- | <a>extDiv</a> <tt>r a b</tt> : result of dividing <tt>a</tt> by
--   <tt>b</tt>, rounded with <tt>r</tt> in the finite case; dividing
--   infinty by infinity yields <a>Nothing</a>.
extDiv :: (Ratio Integer -> Integer) -> Extended -> Extended -> Maybe Extended

-- | Integer intervals
data Interval
Interval :: Extended -> Extended -> Interval
lower :: Interval -> Extended
upper :: Interval -> Extended

-- | Is interval empty?
isBottom :: Interval -> Bool

-- | Are both bounds of the interval finite?
isBounded :: Interval -> Bool

-- | All positive integers
positives :: Interval

-- | All negative integers
negatives :: Interval

-- | All positive integers and 0
nonNegatives :: Interval

-- | All netaive integers and 0
nonPositives :: Interval

-- | Apply function to all pairs of bounds coming from two different
--   intervals
mapBounds :: (Extended -> Extended -> t) -> Interval -> Interval -> [t]

-- | Division on integer intervals
(//) :: Interval -> Interval -> Interval
instance Eq Extended
instance Num Interval
instance Lattice Interval
instance Eq Interval
instance Show Interval
instance Ord Extended
instance Num Extended
instance Show Extended


-- | This monad transformer adds the ability to accumulate errors from
--   several ErrorT computations and report them all at once.
module Language.Boogie.ErrorAccum

-- | Error accumulator: used in combination with ErrorT to store
--   intermediate computation results, when errors should be accumulated
--   rather than reported immediately
newtype ErrorAccumT e m a
ErrorAccumT :: m ([e], a) -> ErrorAccumT e m a
runErrorAccumT :: ErrorAccumT e m a -> m ([e], a)

-- | Transform an error computation and default value into an error
--   accumlator
accum :: (ErrorList e, Monad m) => ErrorT [e] m a -> a -> ErrorAccumT e m a

-- | Transform an error accumlator back into a regular error computation
report :: (ErrorList e, Monad m) => ErrorAccumT e m a -> ErrorT [e] m a

-- | <a>mapAccum</a> <tt>f def xs</tt> : Apply <tt>f</tt> to all
--   <tt>xs</tt>, accumulating errors and reporting them at the end
mapAccum :: (ErrorList e, Monad m) => (a -> ErrorT [e] m b) -> b -> [a] -> ErrorT [e] m [b]

-- | <a>mapAccumA_</a> <tt>f xs</tt> : Apply <tt>f</tt> to all <tt>xs</tt>
--   throwing away the result, accumulating errors
mapAccumA_ :: (ErrorList e, Monad m) => (a -> ErrorT [e] m ()) -> [a] -> ErrorAccumT e m ()

-- | Same as <a>mapAccumA_</a>, but reporting errors at the end
mapAccum_ :: (ErrorList e, Monad m) => (a -> ErrorT [e] m ()) -> [a] -> ErrorT [e] m ()

-- | <a>zipWithAccum_</a> <tt>f xs ys</tt> : Apply type checking <tt>f</tt>
--   to all <tt>xs</tt> and <tt>ys</tt> throwing away the result,
--   accumulating errors and reporting them at the end
zipWithAccum_ :: (ErrorList e, Monad m) => (a -> b -> ErrorT [e] m ()) -> [a] -> [b] -> ErrorT [e] m ()
instance ErrorList e => MonadTrans (ErrorAccumT e)
instance (ErrorList e, Monad m) => Monad (ErrorAccumT e m)


-- | Utility for attaching source code positions to AST nodes
module Language.Boogie.Position

-- | Anything with a source position attached
data Pos a
Pos :: SourcePos -> a -> Pos a
position :: Pos a -> SourcePos
node :: Pos a -> a

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos :: *

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Dummy source position
noPos :: SourcePos

-- | Attach position to a node
attachPos :: SourcePos -> a -> Pos a

-- | Attach dummy position to a node
gen :: a -> Pos a

-- | <a>attachPosBefore</a> <tt>p</tt> : parser that behaves like
--   <tt>p</tt>, but also attaches the source position before the first
--   token it parsed to the result
attachPosBefore :: Parser a -> Parser (Pos a)

-- | <a>inheritPos</a> <tt>f a</tt> : apply <tt>f</tt> to <tt>a</tt> and
--   attach <tt>a</tt>'s position to the result
inheritPos :: (Pos a -> b) -> Pos a -> Pos b

-- | <a>inheritPos2</a> <tt>f a b</tt> : apply <tt>f</tt> to <tt>a</tt> and
--   <tt>b</tt> and attach <tt>a</tt>'s position to the result
inheritPos2 :: (Pos a -> Pos b -> c) -> Pos a -> Pos b -> Pos c
instance Functor Pos
instance Show a => Show (Pos a)
instance Eq a => Eq (Pos a)


-- | Abstract syntax tree for Boogie 2
module Language.Boogie.AST

-- | Program: a list of top-level declarations
newtype Program
Program :: [Decl] -> Program

-- | Type
data Type

-- | bool
BoolType :: Type

-- | int
IntType :: Type
MapType :: [Id] -> [Type] -> Type -> Type
IdType :: Id -> [Type] -> Type

-- | <a>nullaryType</a> <tt>id</tt> : type denoted by <tt>id</tt> without
--   arguments
nullaryType :: Id -> Type

-- | Dummy type used during type checking to denote error
noType :: Type

-- | Unary operators
data UnOp
Neg :: UnOp
Not :: UnOp

-- | Binary operators
data BinOp
Plus :: BinOp
Minus :: BinOp
Times :: BinOp
Div :: BinOp
Mod :: BinOp
And :: BinOp
Or :: BinOp
Implies :: BinOp
Explies :: BinOp
Equiv :: BinOp
Eq :: BinOp
Neq :: BinOp
Lc :: BinOp
Ls :: BinOp
Leq :: BinOp
Gt :: BinOp
Geq :: BinOp

-- | Quantifiers
data QOp
Forall :: QOp
Exists :: QOp
Lambda :: QOp

-- | Expression with a source position attached
type Expression = Pos BareExpression

-- | Expression
data BareExpression

-- | false
FF :: BareExpression

-- | true
TT :: BareExpression

-- | <a>Numeral</a> <tt>value</tt>
Numeral :: Integer -> BareExpression

-- | <a>Var</a> <tt>name</tt>
Var :: Id -> BareExpression

-- | <a>Application</a> <tt>f args</tt>
Application :: Id -> [Expression] -> BareExpression

-- | <a>MapSelection</a> <tt>map indexes</tt>
MapSelection :: Expression -> [Expression] -> BareExpression

-- | <a>MapUpdate</a> <tt>map indexes rhs</tt>
MapUpdate :: Expression -> [Expression] -> Expression -> BareExpression
Old :: Expression -> BareExpression

-- | <a>IfExpr</a> <tt>cond eThen eElse</tt>
IfExpr :: Expression -> Expression -> Expression -> BareExpression
Coercion :: Expression -> Type -> BareExpression
UnaryExpression :: UnOp -> Expression -> BareExpression
BinaryExpression :: BinOp -> Expression -> Expression -> BareExpression

-- | <a>Quantified</a> <tt>qop type_vars bound_vars expr</tt>
Quantified :: QOp -> [Id] -> [IdType] -> Expression -> BareExpression

-- | <a>mapSelectExpr</a> <tt>m args</tt> : map selection expression with
--   position of <tt>m</tt> attached
mapSelectExpr :: Pos BareExpression -> [Expression] -> Pos BareExpression

-- | Wildcard or expression
data WildcardExpression
Wildcard :: WildcardExpression
Expr :: Expression -> WildcardExpression

-- | Statement with a source position attached
type Statement = Pos BareStatement

-- | Statement
data BareStatement

-- | Predicate statement (assume or assert)
Predicate :: SpecClause -> BareStatement

-- | <a>Havoc</a> <tt>var_names</tt>
Havoc :: [Id] -> BareStatement

-- | <a>Assign</a> <tt>var_map_selects rhss</tt>
Assign :: [(Id, [[Expression]])] -> [Expression] -> BareStatement

-- | <a>Call</a> <tt>lhss proc_name args</tt>
Call :: [Id] -> Id -> [Expression] -> BareStatement

-- | <a>CallForall</a> <tt>proc_name args</tt>
CallForall :: Id -> [WildcardExpression] -> BareStatement

-- | <a>If</a> <tt>wild_or_expr then_block else_block</tt>
If :: WildcardExpression -> Block -> (Maybe Block) -> BareStatement

-- | <a>While</a> <tt>wild_or_expr free_loop_inv loop_body</tt>
While :: WildcardExpression -> [SpecClause] -> Block -> BareStatement

-- | <a>Break</a> <tt>label</tt>
Break :: (Maybe Id) -> BareStatement
Return :: BareStatement

-- | <a>Goto</a> <tt>labels</tt>
Goto :: [Id] -> BareStatement

-- | only used at the end of a block
Skip :: BareStatement

-- | Statement labeled by multiple labels with a source position attached
type LStatement = Pos BareLStatement

-- | Statement labeled by multiple labels
type BareLStatement = ([Id], Statement)

-- | Statement block
type Block = [LStatement]

-- | Block consisting of a single non-labeled statement
singletonBlock :: Pos a -> [Pos ([a1], Pos a)]

-- | Procedure body: consists of local variable declarations and a
--   statement block
type Body = ([[IdTypeWhere]], Block)

-- | Basic block is a list of statements labeled by a single label; the
--   list contains no jump, if or while statements, except for the last
--   statement, which can be a goto or return
type BasicBlock = (Id, [Statement])

-- | Procedure body transformed to basic blocks: consists of local variable
--   declarations and a set of basic blocks (represented as a map from
--   their labels to statement lists)
type BasicBody = ([IdTypeWhere], Map Id [Statement])

-- | Types of specification clauses
data SpecType
Inline :: SpecType
Precondition :: SpecType
Postcondition :: SpecType
LoopInvariant :: SpecType
Where :: SpecType
Axiom :: SpecType

-- | Specification clause
data SpecClause
SpecClause :: SpecType -> Bool -> Expression -> SpecClause

-- | Source of the clause
specType :: SpecClause -> SpecType

-- | Is it free (assumption) or checked (assertions)?
specFree :: SpecClause -> Bool

-- | Boolean expression
specExpr :: SpecClause -> Expression

-- | Procedure contract clause
data Contract

-- | <a>Requires</a> <tt>e free</tt>
Requires :: Bool -> Expression -> Contract

-- | <a>Modifies</a> <tt>var_names free</tt>
Modifies :: Bool -> [Id] -> Contract

-- | <a>Ensures</a> <tt>e free</tt>
Ensures :: Bool -> Expression -> Contract

-- | Top-level declaration with a source position attached
type Decl = Pos BareDecl

-- | Top-level declaration
data BareDecl
TypeDecl :: [NewType] -> BareDecl

-- | <a>ConstantDecl</a> <tt>unique names type orderSpec complete</tt>
ConstantDecl :: Bool -> [Id] -> Type -> ParentInfo -> Bool -> BareDecl

-- | <a>FunctionDecl</a> <tt>name type_args formals ret body</tt>
FunctionDecl :: Id -> [Id] -> [FArg] -> FArg -> (Maybe Expression) -> BareDecl
AxiomDecl :: Expression -> BareDecl
VarDecl :: [IdTypeWhere] -> BareDecl

-- | <a>ProcedureDecl</a> <tt>name type_args formals rets contract
--   body</tt>
ProcedureDecl :: Id -> [Id] -> [IdTypeWhere] -> [IdTypeWhere] -> [Contract] -> (Maybe Body) -> BareDecl

-- | <a>ImplementationDecl</a> <tt>name type_args formals rets body</tt>
ImplementationDecl :: Id -> [Id] -> [IdType] -> [IdType] -> [Body] -> BareDecl

-- | Identifier
type Id = String

-- | Definition of a type
data NewType
NewType :: Id -> [Id] -> Maybe Type -> NewType
tId :: NewType -> Id
tArgs :: NewType -> [Id]
tValue :: NewType -> Maybe Type

-- | Name declaration (identifier, type)
type IdType = (Id, Type)

-- | Name declaration with a where clause
data IdTypeWhere
IdTypeWhere :: Id -> Type -> Expression -> IdTypeWhere
itwId :: IdTypeWhere -> Id
itwType :: IdTypeWhere -> Type
itwWhere :: IdTypeWhere -> Expression

-- | Strip the where clause
noWhere :: IdTypeWhere -> (Id, Type)

-- | Formal argument of a function
type FArg = (Maybe Id, Type)

-- | Argument name used for unnamed function arguments (does not matter,
--   because it is never referred to from function's body)
dummyFArg :: [Char]

-- | Parent edge of a constant declaration (uniqueness, parent name)
type ParentEdge = (Bool, Id)

-- | Parent information in a constant declaration (Nothing means no
--   information, while empty list means no parents)
type ParentInfo = Maybe [ParentEdge]
instance Eq UnOp
instance Eq BinOp
instance Eq QOp
instance Eq SpecType
instance Eq Type
instance Eq NewType
instance Eq BareExpression
instance Eq Contract
instance Eq SpecClause
instance Eq WildcardExpression
instance Eq BareStatement
instance Eq IdTypeWhere
instance Eq BareDecl
instance Eq Program


-- | Tokens used in Boogie 2
module Language.Boogie.Tokens

-- | Keywords
keywords :: [String]

-- | <a>opName</a> <tt>op table</tt> : lookup operator name in
--   <tt>table</tt>
opName :: Eq a1 => a1 -> [(a1, a)] -> a

-- | Names of unary operators
unOpTokens :: [(UnOp, String)]

-- | Names of binary operators
binOpTokens :: [(BinOp, String)]

-- | Names of quantifiers
qOpTokens :: [(QOp, String)]

-- | Other operators
otherOps :: [String]

-- | Characters allowed in identifiers (in addition to letters and digits)
identifierChars :: [Char]

-- | Start of a multi-line comment
commentStart :: [Char]

-- | End of a multi-line comment
commentEnd :: [Char]

-- | Start of a single-line comment
commentLine :: [Char]

-- | A character that is not allowed in identifiers (used for generating
--   unique names)
nonIdChar :: Char


-- | Various properties and transformations of Boogie program elements
module Language.Boogie.Util

-- | Mapping from type variables to types
type TypeBinding = Map Id Type

-- | <a>typeSubst</a> <tt>binding t</tt> : Substitute all free type
--   variables in <tt>t</tt> according to binding; all variables in the
--   domain of <tt>bindings</tt> are considered free if not explicitly
--   bound
typeSubst :: TypeBinding -> Type -> Type

-- | <a>renameTypeVars</a> <tt>tv newTV binding</tt> : <tt>binding</tt>
--   with each occurrence of one of <tt>tv</tt> replaced with corresponding
--   <tt>newTV</tt> (in both domain and range)
renameTypeVars :: [Id] -> [Id] -> TypeBinding -> TypeBinding

-- | <a>fromTVNames</a> <tt>tvs tvs'</tt> : type binding that replaces type
--   variables <tt>tvs</tt> with type variables <tt>tvs'</tt>
fromTVNames :: [Id] -> [Id] -> TypeBinding

-- | <tt>x</tt> <a>isFreeIn</a> <tt>t</tt> : does <tt>x</tt> occur free in
--   <tt>t</tt>?
isFreeIn :: Id -> Type -> Bool

-- | <a>isTypeVar</a> <tt>contextTypeVars v</tt> : Is <tt>v</tt> either one
--   of <tt>contextTypeVars</tt> or a freash type variable generated by
--   <a>freshTVName</a>?
isTypeVar :: [Id] -> Id -> Bool

-- | <a>unifier</a> <tt>fv xs ys</tt> : most general unifier of <tt>xs</tt>
--   and <tt>ys</tt> with shared free type variables of the context
--   <tt>fv</tt>
unifier :: [Id] -> [Type] -> [Type] -> Maybe TypeBinding

-- | 'freshTVName <tt>n</tt> : Fresh type variable with a unique identifier
--   n
freshTVName :: Show a => a -> [Char]

-- | Internal tuple type constructor (used for representing procedure
--   returns as a single type)
tupleType :: [Type] -> Type

-- | Free variables in an expression, referred to in current state and old
--   state
freeVarsTwoState :: Expression -> ([Id], [Id])

-- | Free variables in an expression, in current state
freeVars :: Expression -> [Id]

-- | Free variables in an expression, in old state
freeOldVars :: Expression -> [Id]

-- | Mapping from variables to expressions
type VarBinding = Map Id BareExpression

-- | <a>exprSubst</a> <tt>binding e</tt> : substitute all free variables in
--   <tt>e</tt> according to <tt>binding</tt>; all variables in the domain
--   of <tt>bindings</tt> are considered free if not explicitly bound
exprSubst :: VarBinding -> Expression -> Expression

-- | <a>paramSubst</a> <tt>sig def</tt> : Substitute parameter names from
--   <tt>sig</tt> in an expression with their equivalents from <tt>def</tt>
paramSubst :: PSig -> PDef -> Expression -> Expression

-- | <a>freeSelections</a> <tt>expr</tt> : all map selections that occur in
--   <tt>expr</tt>, where the map is a free variable
freeSelections :: Expression -> [(Id, [Expression])]

-- | <a>applications</a> <tt>expr</tt> : all function applications that
--   occur in <tt>expr</tt>
applications :: Expression -> [(Id, [Expression])]

-- | <a>preconditions</a> <tt>specs</tt> : all precondition clauses in
--   <tt>specs</tt>
preconditions :: [Contract] -> [SpecClause]

-- | <a>postconditions</a> <tt>specs</tt> : all postcondition clauses in
--   <tt>specs</tt>
postconditions :: [Contract] -> [SpecClause]

-- | <a>modifies</a> <tt>specs</tt> : all modifies clauses in
--   <tt>specs</tt>
modifies :: [Contract] -> [Id]

-- | Make all preconditions in contracts free
assumePreconditions :: PSig -> PSig

-- | Make all postconditions in contracts free
assumePostconditions :: PSig -> PSig

-- | Function signature
data FSig
FSig :: Id -> [Id] -> [Type] -> Type -> FSig

-- | Function name
fsigName :: FSig -> Id

-- | Type variables
fsigTypeVars :: FSig -> [Id]

-- | Argument types
fsigArgTypes :: FSig -> [Type]

-- | Return type
fsigRetType :: FSig -> Type

-- | Function signature as a map type
fsigType :: FSig -> Type

-- | Map type as a function signature
fsigFromType :: Type -> FSig

-- | Function definition
data FDef
FDef :: Id -> [Id] -> [IdType] -> Expression -> Expression -> FDef

-- | Entity to which the definition belongs
fdefName :: FDef -> Id

-- | Type variables
fdefTV :: FDef -> [Id]

-- | Arguments (types may be less general than in the corresponding
--   signature)
fdefArgs :: FDef -> [IdType]

-- | Condition under which the definition applies
fdefGuard :: FDef -> Expression

-- | Body
fdefBody :: FDef -> Expression

-- | Constraint set: contains a list of definitions and a list of
--   constraints
type ConstraintSet = ([FDef], [FDef])

-- | Abstract store: maps names to their constraints
type AbstractStore = Map Id ConstraintSet

-- | Union of abstract stores (values at the same key are concatenated)
asUnion :: AbstractStore -> AbstractStore -> AbstractStore

-- | Procedure signature
data PSig
PSig :: Id -> [Id] -> [IdTypeWhere] -> [IdTypeWhere] -> [Contract] -> PSig

-- | Procedure name
psigName :: PSig -> Id

-- | Type variables
psigTypeVars :: PSig -> [Id]

-- | In-parameters
psigArgs :: PSig -> [IdTypeWhere]

-- | Out-parameters
psigRets :: PSig -> [IdTypeWhere]

-- | Contracts
psigContracts :: PSig -> [Contract]

-- | All parameters of a procedure signature
psigParams :: PSig -> [IdTypeWhere]

-- | Types of in-parameters of a procedure signature
psigArgTypes :: PSig -> [Type]

-- | Types of out-parameters of a procedure signature
psigRetTypes :: PSig -> [Type]

-- | Modifies clauses of a procedure signature
psigModifies :: PSig -> [Id]

-- | Preconditions of a procedure signature
psigRequires :: PSig -> [SpecClause]

-- | Postconditions of a procedure signature
psigEnsures :: PSig -> [SpecClause]

-- | Procedure signature as a map type
psigType :: PSig -> Type

-- | Procedure definition; a single procedure might have multiple
--   definitions (one per body)
data PDef
PDef :: [Id] -> [Id] -> Bool -> BasicBody -> AbstractStore -> SourcePos -> PDef

-- | In-parameter names (in the same order as <a>psigArgs</a> in the
--   corresponding signature)
pdefIns :: PDef -> [Id]

-- | Out-parameter names (in the same order as <a>psigRets</a> in the
--   corresponding signature)
pdefOuts :: PDef -> [Id]

-- | Are any parameter names in this definition different for the procedure
--   signature? (used for optimizing parameter renaming, True is a safe
--   default)
pdefParamsRenamed :: PDef -> Bool

-- | Body
pdefBody :: PDef -> BasicBody

-- | Constraints on local names
pdefConstraints :: PDef -> AbstractStore

-- | Location of the (first line of the) procedure definition in the source
pdefPos :: PDef -> SourcePos

-- | All local names of a procedure definition
pdefLocals :: PDef -> [Id]
num :: Integer -> Pos BareExpression
eneg :: Pos BareExpression -> Pos BareExpression
enot :: Pos BareExpression -> Pos BareExpression
(|+|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|-|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|*|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|/|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|%|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|=|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|!=|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|<|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|<=|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|>|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|>=|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|&|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|||) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|=>|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
(|<=>|) :: Pos BareExpression -> Pos BareExpression -> Pos BareExpression
conjunction :: [Pos BareExpression] -> Pos BareExpression
assume :: Pos BareExpression -> Pos BareStatement

-- | <a>interval</a> <tt>(lo, hi)</tt> : Interval from <tt>lo</tt> to
--   <tt>hi</tt>
interval :: Enum t => (t, t) -> [t]

-- | Extract the element out of a <a>Right</a> and throw an error if its
--   argument is <a>Left</a>
fromRight :: Either a b -> b

-- | <a>deleteAll</a> <tt>keys m</tt> : map <tt>m</tt> with <tt>keys</tt>
--   removed from its domain
deleteAll :: Ord k => [k] -> Map k a -> Map k a

-- | <a>restrictDomain</a> <tt>keys m</tt> : map <tt>m</tt> restricted on
--   the set of keys <tt>keys</tt>
restrictDomain :: Ord k => Set k -> Map k a -> Map k a

-- | <a>removeDomain</a> <tt>keys m</tt> : map <tt>m</tt> with the set of
--   keys <tt>keys</tt> removed from its domain
removeDomain :: Ord k => Set k -> Map k a -> Map k a
mapItwType :: (Type -> Type) -> IdTypeWhere -> IdTypeWhere

-- | Monadic version of <a>any</a> (executes boolean-valued computation for
--   all arguments in a list until the first True is found)
anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Execute a computation with state of type <tt>t</tt> inside a
--   computation with state of type <tt>s</tt>
changeState :: Monad m => (s -> t) -> (t -> s -> s) -> StateT t m a -> StateT s m a

-- | <a>withLocalState</a> <tt>localState e</tt> : Execute <tt>e</tt> in
--   current state modified by <tt>localState</tt>, and then restore
--   current state
withLocalState :: Monad m => (s -> t) -> StateT t m a -> StateT s m a
internalError :: [Char] -> t
instance Eq PSig
instance Eq FSig


-- | Pretty printer for Boogie 2
module Language.Boogie.PrettyPrinter

-- | Pretty-printed program
programDoc :: Program -> Doc

-- | Render document with tabs instead of spaces
renderWithTabs :: Doc -> String

-- | Pretty-printed type
typeDoc :: Type -> Doc

-- | Pretty-printed expression
exprDoc :: Expression -> Doc

-- | Pretty-printed statement
statementDoc :: Statement -> Doc

-- | Pretty-printed top-level declaration
declDoc :: Decl -> Doc

-- | <a>fdefDoc</a> <tt>isDef fdef</tt> : <tt>fdef</tt> pretty-printed as
--   definition if <tt>isDef</tt> and as constraint otherwise
fdefDoc :: Bool -> FDef -> Doc

-- | Pretty-printed constraint set
constraintSetDoc :: ConstraintSet -> Doc

-- | Pretty-printed abstract store
abstractStoreDoc :: AbstractStore -> Doc

-- | New line
newline :: Doc

-- | Separate by new lines
vsep :: [Doc] -> Doc

-- | Separate by commas
commaSep :: [Doc] -> Doc

-- | Enclose in &lt; &gt;
angles :: Doc -> Doc

-- | Enclose in spaces
spaces :: Doc -> Doc

-- | Conditionally produce a doc
option :: Bool -> Doc -> Doc

-- | Convert a <a>Just</a> value to doc
optionMaybe :: Maybe t -> (t -> Doc) -> Doc

-- | Pretty-printed unary operator
unOpDoc :: UnOp -> Doc

-- | Pretty-printed binary operator
binOpDoc :: BinOp -> Doc

-- | Pretty-printed function or procedure signature
sigDoc :: [Type] -> [Type] -> Doc
nestDef :: Doc -> Doc
instance Eq Doc
instance Show BareDecl
instance Show BareStatement
instance Show BareExpression
instance Show Type
instance Show Program


-- | Type checker for Boogie 2
module Language.Boogie.TypeChecker

-- | Check program and return type errors if present, and the global typing
--   context otherwise
typeCheckProgram :: Program -> Either [TypeError] Context

-- | <a>exprType</a> <tt>c expr</tt> : Type of <tt>expr</tt> in context
--   <tt>c</tt>; fails if expr contains type errors.
exprType :: Context -> Expression -> Type

-- | <a>resolve</a> <tt>c t</tt> : type <tt>t</tt> with all type synonyms
--   resolved according to binding in <tt>c</tt>
resolve :: Context -> Type -> Type

-- | Type error with a source position and a pretty-printed message
data TypeError
TypeError :: SourcePos -> Doc -> TypeError

-- | Pretty-printed list of type errors
typeErrorsDoc :: [TypeError] -> Doc

-- | Typing context
data Context
Context :: Map Id Int -> Map Id ([Id], Type) -> Map Id Type -> Map Id Type -> Map Id FSig -> Map Id PSig -> [Id] -> Map Id Type -> Map Id Type -> [Id] -> [Id] -> [Id] -> Bool -> Bool -> SourcePos -> Integer -> Context

-- | type constructor arity
ctxTypeConstructors :: Context -> Map Id Int

-- | type synonym values
ctxTypeSynonyms :: Context -> Map Id ([Id], Type)

-- | global variable types (type synonyms resolved)
ctxGlobals :: Context -> Map Id Type

-- | constant types (type synonyms resolved)
ctxConstants :: Context -> Map Id Type

-- | function signatures (type synonyms resolved)
ctxFunctions :: Context -> Map Id FSig

-- | procedure signatures (type synonyms resolved) Local:
ctxProcedures :: Context -> Map Id PSig

-- | free type variables
ctxTypeVars :: Context -> [Id]

-- | input parameter types
ctxIns :: Context -> Map Id Type

-- | local variable types
ctxLocals :: Context -> Map Id Type

-- | variables in the modifies clause of the enclosing procedure
ctxModifies :: Context -> [Id]

-- | all labels of the enclosing procedure body
ctxLabels :: Context -> [Id]

-- | labels of all enclosing statements
ctxEncLabels :: Context -> [Id]

-- | is the context two-state? (procedure body or postcondition)
ctxTwoState :: Context -> Bool

-- | is context inside a loop body?
ctxInLoop :: Context -> Bool

-- | position in the source code Persistent context (not specific to any
--   node, never gets restored):
ctxPos :: Context -> SourcePos

-- | number of fresh type variables already generated
ctxFreshTVCount :: Context -> Integer

-- | Empty context
emptyContext :: Context

-- | Type constructors and synonyms
typeNames :: Context -> [Id]

-- | Global variables and constants
globalScope :: Context -> Map Id Type

-- | Input parameters and local variables
localScope :: Context -> Map Id Type

-- | All variables that can be assigned to (local variables and global
--   variables)
mutableVars :: Context -> Map Id Type

-- | All variables that can have where clauses (everything except
--   constants)
allVars :: Context -> Map Id Type

-- | All variables and constants (local-scope preferred)
allNames :: Context -> Map Id Type

-- | Names of functions and procedures
funProcNames :: Context -> [Id]

-- | Function signature by name
funSig :: Id -> Context -> FSig

-- | Procedure signature by name
procSig :: Id -> Context -> PSig
setLocals :: Map Id Type -> Context -> Context

-- | <a>enterFunction</a> <tt>sig formals actuals mRetType c</tt> : Local
--   context of function <tt>sig</tt> with formal arguments
--   <tt>formals</tt> and actual arguments <tt>actuals</tt> in a context
--   where the return type is exprected to be <tt>mRetType</tt> (if known)
enterFunction :: FSig -> [Id] -> [Expression] -> Context -> Context

-- | <a>enterProcedure</a> <tt>sig def actuals lhss c</tt> : Local context
--   of procedure <tt>sig</tt> with definition <tt>def</tt> and actual
--   arguments <tt>actuals</tt> in a call with left-hand sides
--   <tt>lhss</tt>
enterProcedure :: PSig -> PDef -> [Expression] -> [Expression] -> Context -> Context

-- | Local context of a quantified expression
enterQuantified :: [Id] -> [IdType] -> Context -> Context
instance ErrorList TypeError


-- | Parsec-based parser for Boogie 2
module Language.Boogie.Parser

-- | Program parser
program :: Parser Program

-- | Type parser
type_ :: Parser Type

-- | Expression parser
expression :: Parser Expression

-- | Statement parser
statement :: Parser Statement

-- | Top-level declaration parser
decl :: Parser Decl


-- | Various normal forms of Boolean expressions
module Language.Boogie.NormalForm

-- | Negation normal form of a Boolean expression: no negation above
--   boolean connectives, quantifiers or relational operators; no boolean
--   connectives except <tt>&amp;&amp;</tt> and <tt>||</tt>
negationNF :: Expression -> Expression

-- | Prenex normal form of a Boolean expression: all quantifiers are pushed
--   to the outside and any two quantifiers of the same kind in a row are
--   glued together. Requires expression to be in the negation normal form.
prenexNF :: Expression -> Expression

-- | Negation and prenex normal form of a Boolean expression
normalize :: Expression -> Expression


-- | Generic heap with reference counting. This module provides relatively
--   low-level interface to the heap data structure, while keeping its
--   internal representation hidden and consistent.
module Language.Boogie.Heap

-- | Reference (index in the heap)
type Ref = Int

-- | Pretty-printed reference
refDoc :: Ref -> Doc

-- | Heap
data Heap a

-- | Empty heap
emptyHeap :: Heap a

-- | <a>at</a> <tt>h r</tt>: value of <tt>r</tt> in heap <tt>h</tt>
at :: Show a => Heap a -> Ref -> a

-- | <a>alloc</a> <tt>v h</tt> : choose a free reference in heap <tt>h</tt>
--   and store value <tt>v</tt> in there; return the reference and the
--   updated heap
alloc :: a -> Heap a -> (Ref, Heap a)

-- | Does the heap have any garbage?
hasGarbage :: Heap a -> Bool

-- | Collect some garbage reference in the heap and return that reference
--   and the new heap; the heap must have garbage
dealloc :: Heap a -> (Ref, Heap a)

-- | <a>update</a> <tt>r v h</tt> : set the value at reference <tt>r</tt>
--   to <tt>v</tt> in <tt>h</tt>; <tt>r</tt> must be present in <tt>h</tt>
update :: Ref -> a -> Heap a -> Heap a

-- | <a>incRefCount</a> <tt>r h</tt> : increase reference count of
--   <tt>r</tt> in <tt>h</tt>; <tt>r</tt> must be present in <tt>h</tt>
incRefCount :: Ref -> Heap a -> Heap a

-- | <a>decRefCount</a> <tt>r h</tt> : decrease reference count of
--   <tt>r</tt> in <tt>h</tt>; <tt>r</tt> must be present in <tt>h</tt>
decRefCount :: Ref -> Heap a -> Heap a

-- | Pretty-printed heap
heapDoc :: Show a => Heap a -> Doc
instance Show a => Show (Heap a)
instance Eq a => Eq (Heap a)


-- | Execution state for the interpreter
module Language.Boogie.Environment

-- | Representation of a map value
data MapRepr

-- | Map that comes directly from a non-deterministic choice, possibly with
--   some key-value pairs defined
Source :: (Map [Value] Value) -> MapRepr

-- | Map that is derived from another map by redefining values at some keys
Derived :: Ref -> (Map [Value] Value) -> MapRepr

-- | Representation of an empty map
emptyMap :: MapRepr

-- | Key-value pairs stored explicitly in a map representation
stored :: MapRepr -> Map [Value] Value

-- | Run-time value
data Value

-- | Integer value
IntValue :: Integer -> Value

-- | Boolean value
BoolValue :: Bool -> Value

-- | Value of a user-defined type
CustomValue :: Id -> Int -> Value

-- | Value of a map type: consists of an optional reference to the base map
--   (if derived from base by updating) and key-value pairs that override
--   base
MapValue :: MapRepr -> Value

-- | Reference to a map stored in the heap
Reference :: Ref -> Value

-- | <a>valueFromInteger</a> <tt>t n</tt>: value of type <tt>t</tt> with an
--   integer code <tt>n</tt>
valueFromInteger :: Type -> Integer -> Value
vnot :: Value -> Value
unValueBool :: Value -> Bool
unValueMap :: Value -> MapRepr

-- | Source reference and key-value pairs of a reference in a heap
flattenMap :: Heap Value -> Ref -> (Ref, Map [Value] Value)

-- | First component of <a>flattenMap</a>
mapSource :: Heap Value -> Ref -> Ref

-- | Second component of <a>flattenMap</a>
mapValues :: Heap Value -> Ref -> Map [Value] Value

-- | Dummy user-defined type used to differentiate map values
refIdTypeName :: [Char]

-- | Dummy user-defined type used to mark entities whose definitions are
--   currently being evaluated
ucTypeName :: [Char]

-- | <a>deepDeref</a> <tt>h v</tt>: Completely dereference value <tt>v</tt>
--   given heap <tt>h</tt> (so that no references are left in <tt>v</tt>)
deepDeref :: Heap Value -> Value -> Value

-- | <a>objectEq</a> <tt>h v1 v2</tt>: is <tt>v1</tt> equal to <tt>v2</tt>
--   in the Boogie semantics? Nothing if cannot be determined.
objectEq :: Heap Value -> Value -> Value -> Maybe Bool
mustAgree :: Ord k => Heap Value -> Map k Value -> Map k Value -> Bool
mustDisagree :: Ord k => Heap Value -> Map k Value -> Map k Value -> Bool

-- | Pretty-printed value
valueDoc :: Value -> Doc

-- | Store: stores variable values at runtime
type Store = Map Id Value

-- | A store with no variables
emptyStore :: Store

-- | <a>functionConst</a> <tt>name</tt> : name of a map constant that
--   corresponds function <tt>name</tt> (must be distinct from all global
--   names)
functionConst :: [Char] -> [Char]

-- | <a>userStore</a> <tt>heap store</tt> : <tt>store</tt> with all
--   reference values completely dereferenced given <tt>heap</tt>, and all
--   auxiliary values removed
userStore :: Heap Value -> Store -> Store

-- | Pretty-printed store
storeDoc :: Store -> Doc

-- | Memory: stores concrete values associated with names and references
data Memory

-- | Lens that selects a store from memory
type StoreLens = SimpleLens Memory Store
memLocals :: Lens Memory Memory Store Store
memGlobals :: Lens Memory Memory Store Store
memOld :: Lens Memory Memory Store Store
memConstants :: Lens Memory Memory Store Store
memHeap :: Lens Memory Memory (Heap Value) (Heap Value)

-- | Empty memory
emptyMemory :: Memory

-- | Visible values of all identifiers in a memory (locals shadow globals)
visibleVariables :: Memory -> Store

-- | <a>memoryDoc</a> <tt>debug mem</tt> : either user or debug
--   representation of <tt>mem</tt>, depending on <tt>debug</tt>
memoryDoc :: Bool -> Memory -> Doc

-- | Abstract memory: stores constraints associated with names and
--   references
data AbstractMemory
amLocals :: Lens AbstractMemory AbstractMemory AbstractStore AbstractStore
amGlobals :: Lens AbstractMemory AbstractMemory AbstractStore AbstractStore
amHeap :: Lens AbstractMemory AbstractMemory (Map Ref ConstraintSet) (Map Ref ConstraintSet)

-- | Execution state
data Environment m
envMemory :: Lens (Environment m_a1rtn) (Environment m_a1rtn) Memory Memory
envProcedures :: Lens (Environment m_a1rtn) (Environment m_a1rtn) (Map Id [PDef]) (Map Id [PDef])
envConstraints :: Lens (Environment m_a1rtn) (Environment m_a1rtn) AbstractMemory AbstractMemory
envTypeContext :: Lens (Environment m_a1rtn) (Environment m_a1rtn) Context Context
envGenerator :: Lens (Environment m_a1rtn) (Environment m_a1rum) (Generator m_a1rtn) (Generator m_a1rum)
envCustomCount :: Lens (Environment m_a1rtn) (Environment m_a1rtn) (Map Id Int) (Map Id Int)
envQBound :: Lens (Environment m_a1rtn) (Environment m_a1rtn) (Maybe Integer) (Maybe Integer)
envInOld :: Lens (Environment m_a1rtn) (Environment m_a1rtn) Bool Bool

-- | <a>initEnv</a> <tt>tc gen</tt>: Initial environment in a type context
--   <tt>tc</tt> with a value generator <tt>gen</tt>
initEnv :: Context -> Generator m -> Maybe Integer -> Environment m
lookupProcedure :: Id -> Environment m -> [PDef]
lookupNameConstraints :: Id -> Environment m -> ConstraintSet
lookupMapConstraints :: Ref -> Environment m -> ConstraintSet
lookupCustomCount :: Id -> Environment m -> Int
addProcedureImpl :: Id -> PDef -> Environment m -> Environment m
addGlobalDefinition :: Id -> FDef -> Environment m -> Environment m
addMapDefinition :: Ref -> FDef -> Environment m -> Environment m
addMapConstraint :: Ref -> FDef -> Environment m -> Environment m
setCustomCount :: Id -> Int -> Environment m -> Environment m
withHeap :: (Heap Value -> (t, Heap Value)) -> Environment m -> (t, Environment m)
instance Show Memory
instance Eq Value
instance Ord Value
instance Eq MapRepr
instance Ord MapRepr
instance Eq Memory
instance Show Value


-- | Basic block transformation for imperative Boogie code
module Language.Boogie.BasicBlocks

-- | Transform procedure body into a sequence of basic blocks. A basic
--   block starts with a label and contains no jump, if or while
--   statements, except for the last statement, which can be a goto or
--   return.
toBasicBlocks :: Block -> [BasicBlock]

-- | Label of the first block in a procedure
startLabel :: [Char]


-- | Interpreter for Boogie 2
module Language.Boogie.Interpreter

-- | <a>executeProgramDet</a> <tt>p tc entryPoint</tt> : Execute program
--   <tt>p</tt> <i>deterministically</i> in type context <tt>tc</tt>
--   starting from procedure <tt>entryPoint</tt> and return a single
--   outcome. Whenever a value is unspecified, a default value of the
--   required type is used.
executeProgramDet :: Program -> Context -> Maybe Integer -> Id -> TestCase

-- | <a>executeProgram</a> <tt>p tc entryPoint</tt> : Execute program
--   <tt>p</tt> <i>non-deterministically</i> in type context <tt>tc</tt>
--   starting from procedure <tt>entryPoint</tt> and return an infinite
--   list of possible outcomes (each either runtime failure or the final
--   variable store). Whenever a value is unspecified, all values of the
--   required type are tried exhaustively.
executeProgram :: Program -> Context -> Generator Stream -> Maybe Integer -> Id -> [TestCase]

-- | <a>executeProgramGeneric</a> <tt>p tc generator qbound entryPoint</tt>
--   : Execute program <tt>p</tt> in type context <tt>tc</tt> with input
--   generator <tt>generator</tt>, starting from procedure
--   <tt>entryPoint</tt>, and return the outcome(s) embedded into the
--   generator's monad.
executeProgramGeneric :: (Monad m, Functor m) => Program -> Context -> Generator m -> Maybe Integer -> Id -> m (TestCase)
data FailureSource

-- | Violation of user-defined specification
SpecViolation :: SpecClause -> FailureSource

-- | Division by zero
DivisionByZero :: FailureSource

-- | Language construct is not yet supported (should disappear in later
--   versions)
UnsupportedConstruct :: String -> FailureSource

-- | Quantification over an infinite set
InfiniteDomain :: Id -> Interval -> FailureSource

-- | Equality of two maps cannot be determined
MapEquality :: Value -> Value -> FailureSource

-- | Must be cought inside the interpreter and never reach the user
InternalException :: InternalCode -> FailureSource

-- | Information about a procedure or function call
data StackFrame
StackFrame :: SourcePos -> Id -> StackFrame

-- | Source code position of the call
callPos :: StackFrame -> SourcePos

-- | Name of procedure or function
callName :: StackFrame -> Id
type StackTrace = [StackFrame]

-- | Failures that occur during execution
data RuntimeFailure
RuntimeFailure :: FailureSource -> SourcePos -> Memory -> StackTrace -> RuntimeFailure

-- | Source of the failure
rtfSource :: RuntimeFailure -> FailureSource

-- | Location where the failure occurred
rtfPos :: RuntimeFailure -> SourcePos

-- | Memory state at the time of failure
rtfMemory :: RuntimeFailure -> Memory

-- | Stack trace from the program entry point to the procedure where the
--   failure occurred
rtfTrace :: RuntimeFailure -> StackTrace

-- | Pretty-printed run-time failure
runtimeFailureDoc :: Bool -> RuntimeFailure -> Doc

-- | Kinds of run-time failures
data FailureKind

-- | Error state reached (assertion violation)
Error :: FailureKind

-- | Unreachable state reached (assumption violation)
Unreachable :: FailureKind

-- | The state is OK in Boogie semantics, but the execution cannot continue
--   due to the limitations of the interpreter
Nonexecutable :: FailureKind

-- | Kind of a run-time failure
failureKind :: RuntimeFailure -> FailureKind

-- | Description of an execution
data TestCase
TestCase :: PSig -> Memory -> Maybe RuntimeFailure -> TestCase

-- | Root procedure (entry point) of the execution
tcProcedure :: TestCase -> PSig

-- | Final memory state (at the exit from the root procedure)
tcMemory :: TestCase -> Memory

-- | Failure the execution eded with, or Nothing if the execution ended in
--   a valid state
tcFailure :: TestCase -> Maybe RuntimeFailure

-- | <a>isPass</a> <tt>tc</tt>: Does <tt>tc</tt> end in a valid state?
isPass :: TestCase -> Bool

-- | <a>isInvalid</a> <tt>tc</tt>: Does <tt>tc</tt> and in an unreachable
--   state?
isInvalid :: TestCase -> Bool

-- | <a>isNonexecutable</a> <tt>tc</tt>: Does <tt>tc</tt> end in a
--   non-executable state?
isNonexecutable :: TestCase -> Bool

-- | <a>isFail</a> <tt>tc</tt>: Does <tt>tc</tt> end in an error state?
isFail :: TestCase -> Bool

-- | <a>testCaseSummary</a> <tt>debug tc</tt> : Summary of <tt>tc</tt>'s
--   inputs and outcome, displayed in user or debug format depending on
--   <tt>debug</tt>
testCaseSummary :: Bool -> TestCase -> Doc

-- | <a>finalStateDoc</a> <tt>debug tc</tt> : outputs of <tt>tc</tt>,
--   displayed in user or debug format depending on <tt>debug</tt>
finalStateDoc :: Bool -> TestCase -> Doc

-- | Test session summary
data Summary
Summary :: Int -> Int -> Int -> Int -> [TestCase] -> Summary

-- | Number of passing test cases
sPassCount :: Summary -> Int

-- | Number of failing test cases
sFailCount :: Summary -> Int

-- | Number of invalid test cases
sInvalidCount :: Summary -> Int

-- | Number of nonexecutable test cases
sNonExecutableCount :: Summary -> Int

-- | Unique failing test cases
sUniqueFailures :: Summary -> [TestCase]

-- | Summary of a set of test cases
testSessionSummary :: [TestCase] -> Summary

-- | Pretty-printed test session summary
summaryDoc :: Summary -> Doc

-- | Evaluate an expression; can have a side-effect of initializing
--   variables that were not previously defined
eval :: (Monad m, Functor m) => Expression -> Execution m Value

-- | Execute a basic statement (no jump, if or while statements allowed)
exec :: (Monad m, Functor m) => Statement -> Execution m ()

-- | <a>execProcedure</a> <tt>sig def args lhss</tt> : Execute definition
--   <tt>def</tt> of procedure <tt>sig</tt> with actual arguments
--   <tt>args</tt> and call left-hand sides <tt>lhss</tt>
execProcedure :: (Monad m, Functor m) => PSig -> PDef -> [Expression] -> [Expression] -> Execution m [Value]

-- | Collect procedure implementations, and constant<i>function</i>global
--   variable constraints
preprocess :: (Monad m, Functor m) => Program -> SafeExecution m ()
instance Eq StackFrame
instance Eq FailureKind
instance Eq InternalCode
instance Eq FailureSource
instance Show Summary
instance Eq RuntimeFailure
instance Show RuntimeFailure
instance Error RuntimeFailure
instance (Error e, Monad m) => Finalizer (ErrorT e m)
instance Monad m => Finalizer (StateT s m)
