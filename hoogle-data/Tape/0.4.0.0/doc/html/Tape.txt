-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bidirectionally infinite streams, akin to the tape of a Turing machine.
--   
@package Tape
@version 0.4.0.0


-- | This module implements two-way infinite streams with a focused
--   element, akin to a Turing machine's tape. This structure is also known
--   by the name of a list zipper (although in this case it's a list zipper
--   with the additional criterion that the list is infinite in both
--   directions).
module Data.Stream.Tape

-- | A <tt>Tape</tt> is like a Turing-machine tape: infinite in both
--   directions, with a focus in the middle.
data Tape a
Tape :: Stream a -> a -> Stream a -> Tape a

-- | the side of the <tt>Tape</tt> left of <tt>focus</tt>
viewL :: Tape a -> Stream a

-- | the focused element
focus :: Tape a -> a

-- | the side of the <tt>Tape</tt> right of <tt>focus</tt>
viewR :: Tape a -> Stream a

-- | Produce a <tt>Tape</tt> from a seed value, ala unfoldr for lists, or
--   unfold for <tt>Stream</tt>s.
unfold :: (c -> (a, c)) -> (c -> a) -> (c -> (a, c)) -> c -> Tape a

-- | Produce a <tt>Tape</tt> consisting of the infinite iteration of two
--   functions to a starting focus value, ala iterate for lists or
--   <tt>Stream</tt>s.
iterate :: (a -> a) -> (a -> a) -> a -> Tape a

-- | Given an enumerable type, produce the <tt>Tape</tt> where the left
--   side is the sequence of predecessors, and the right side is the
--   sequence of successors.
enumerate :: Enum a => a -> Tape a

-- | Tapes form a comonad, where extract gives the focus element and
--   duplicate gives a <i>diagonalized</i> <tt>Tape (Tape a)</tt> such that
--   <tt>extract . extract . moveL . duplicate == extract . moveL</tt> and
--   likewise for <tt>moveR</tt>.

-- | Applying one tape to another moves them together. This is like the
--   <tt>Applicative</tt> instances for <tt>ZipList</tt> and
--   <tt>Stream</tt>.

-- | A tape is <tt>Applicative</tt>, where the <tt>&lt;*&gt;</tt> is
--   equivalent to its <tt>ComonadApply</tt> instance (required by law),
--   and a pure value is the tape consisting of copies of that value in
--   both directions.

-- | Tapes are <tt>Distributive</tt> because we can replicate their
--   structure on the outside of a functor by sending movement commands
--   through the functor via <tt>fmap moveL</tt> and <tt>fmap moveR</tt>,
--   and using <tt>fmap focus</tt> to remove the extra structure inside the
--   functor. As stated in the Distributive documentation, this can only
--   work if all Tapes have the same cardinality of holes, and if there is
--   no extra information to propagate from outside the functor -- hence,
--   an <tt>Indexed</tt> tape can't be made into a <tt>Distributive</tt>,
--   as there's no way to extract the index from the functor.

-- | The functions <tt>moveR</tt> and <tt>moveL</tt> move the focus on the
--   tape right and left, respectively.
moveL :: Tape a -> Tape a

-- | The functions <tt>moveR</tt> and <tt>moveL</tt> move the focus on the
--   tape right and left, respectively.
moveR :: Tape a -> Tape a

-- | Gives a <tt>Tape</tt> containing infinite copies of the given element.
tapeOf :: a -> Tape a
instance Functor Tape
instance Distributive Tape
instance Applicative Tape
instance ComonadApply Tape
instance Comonad Tape
