-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Represent hierachichal structures, called objects in JSON. (deprecated)
--   
--   These objects show up in different places, eg JSON, Yaml. By providing
--   a representation in a separate repository, other libraries can share a
--   single representation of these structures.
@package data-object
@version 0.3.1.9


-- | The core of this package is the <a>Object</a> data type, which is used
--   for handling scalars, sequences and mappings in a nested manner. This
--   is the same structure used in JSON or Yaml data.
--   
--   The <a>Object</a> data type is polymorphic in its keys and values.
--   Submodules within this package provide more concrete datatypes, such
--   as a <a>String</a> <a>Object</a> and a specialized scalar type.
--   
--   Besides the <a>Object</a> data type, there are utility functions and
--   type classes for converting objects around. Care has been taken to
--   avoid any overloaded instances for these type classes.
module Data.Object

-- | Can represent nested values as scalars, sequences and mappings. A
--   sequence is synonymous with a list, while a mapping is synonymous with
--   a list of pairs.
--   
--   Note that instances of standard library type classes for this data
--   type leave the key untouched while altering the value. For example,
--   the <a>Functor</a> instance defines <a>fmap</a> to be synonymous with
--   <a>mapValues</a>.
data Object key val
Mapping :: [(key, Object key val)] -> Object key val
Sequence :: [Object key val] -> Object key val
Scalar :: val -> Object key val
type StringObject = Object String String

-- | <a>Object</a>s with keys and values of strict <a>Text</a>.
type TextObject = Object Text Text
data Scalar
Numeric :: Rational -> Scalar
Text :: Text -> Scalar
Binary :: ByteString -> Scalar
Bool :: Bool -> Scalar
Timestamp :: UTCTime -> Scalar
Null :: Scalar
type ScalarObject = Object String Scalar

-- | Apply some conversion to the keys of an <a>Object</a>, leaving the
--   values unchanged.
mapKeys :: (keyIn -> keyOut) -> Object keyIn val -> Object keyOut val

-- | Apply some conversion to the values of an <a>Object</a>, leaving the
--   keys unchanged. This is equivalent to <a>fmap</a>.
mapValues :: (valIn -> valOut) -> Object key valIn -> Object key valOut

-- | Apply a conversion to both the keys and values of an <a>Object</a>.
mapKeysValues :: (keyIn -> keyOut) -> (valIn -> valOut) -> Object keyIn valIn -> Object keyOut valOut

-- | Apply an <a>Applicative</a> conversion to both the keys and values of
--   an <a>Object</a>.
mapKeysValuesA :: Applicative f => (keyIn -> f keyOut) -> (valIn -> f valOut) -> Object keyIn valIn -> f (Object keyOut valOut)

-- | The same as <a>mapKeysValuesA</a>, but using a <a>Monad</a> since some
--   people are more comfortable with <a>Monad</a>s and not all
--   <a>Monad</a>s are <a>Applicative</a>.
mapKeysValuesM :: Monad m => (keyIn -> m keyOut) -> (valIn -> m valOut) -> Object keyIn valIn -> m (Object keyOut valOut)

-- | An error value returned when an unexpected node is encountered, eg you
--   were expecting a <a>Scalar</a> and found a <a>Mapping</a>.
data ObjectExtractError
ExpectedScalar :: ObjectExtractError
ExpectedSequence :: ObjectExtractError
ExpectedMapping :: ObjectExtractError
MissingKey :: String -> ObjectExtractError

-- | Extract a scalar from the input, failing if the input is a sequence or
--   mapping.
fromScalar :: Failure ObjectExtractError m => Object k v -> m v

-- | Extract a sequence from the input, failing if the input is a scalar or
--   mapping.
fromSequence :: Failure ObjectExtractError m => Object k v -> m [Object k v]

-- | Extract a mapping from the input, failing if the input is a scalar or
--   sequence.
fromMapping :: Failure ObjectExtractError m => Object k v -> m [(k, Object k v)]
lookupObject :: (Show k, Eq k, Failure ObjectExtractError m) => k -> [(k, Object k v)] -> m (Object k v)
lookupScalar :: (Show k, Eq k, Failure ObjectExtractError m) => k -> [(k, Object k v)] -> m v
lookupSequence :: (Show k, Eq k, Failure ObjectExtractError m) => k -> [(k, Object k v)] -> m [Object k v]
lookupMapping :: (Show k, Eq k, Failure ObjectExtractError m) => k -> [(k, Object k v)] -> m [(k, Object k v)]
instance Typeable2 Object
instance Typeable ObjectExtractError
instance (Show key, Show val) => Show (Object key val)
instance (Eq key, Eq val) => Eq (Object key val)
instance (Data key, Data val) => Data (Object key val)
instance Show ObjectExtractError
instance Exception ObjectExtractError
instance Applicative (Object key)
instance Monad (Object key)
instance Traversable (Object key)
instance Foldable (Object key)
instance Functor (Object key)
