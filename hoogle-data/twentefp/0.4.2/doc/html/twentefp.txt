-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lab Assignments Environment at Univeriteit Twente
--   
--   Lab Assignments Environment at Univeriteit Twente
@package twentefp
@version 0.4.2


-- | Open a new window and display the given picture. Should only be called
--   once during the execution of a program!
module FPPrac.Graphics

-- | Open a new window and display the given picture. Should only be called
--   once during the execution of a program!
--   
--   Use the following commands once the window is open:
--   
--   <ul>
--   <li>Close Window - esc-key.</li>
--   <li>Move Viewport - left-click drag, arrow keys.</li>
--   <li>Rotate Viewport - right-click drag, control-left-click drag, or
--   home/end-keys.</li>
--   <li>Zoom Viewport - mouse wheel, or page up/down-keys.</li>
--   </ul>
graphicsout :: Picture -> IO ()


-- | The event mode lets you manage your own input. Pressing ESC will still
--   closes the window, but you don't get automatic pan and zoom controls
--   like with <a>graphicsout</a>. Should only be called once during the
--   execution of a program!
module FPPrac.Events

-- | Possible filetypes
data FileType

-- | Text file
TXTFile :: String -> FileType

-- | Bitmap file
BMPFile :: Picture -> FileType

-- | Possible input events
data Input

-- | No input
--   
--   Generated every refresh of the eventhandler
NoInput :: Input

-- | Keyboard key x is pressed down; ' ' for space, \t for tab, \n for
--   enter
KeyIn :: Char -> Input

-- | Left mouse button is pressed at location (x,y)
MouseDown :: (Float, Float) -> Input

-- | Left mouse button is released at location (x,y)
MouseUp :: (Float, Float) -> Input

-- | Mouse pointer is moved to location (x,y)
MouseMotion :: (Float, Float) -> Input

-- | Mouse is double-clicked at location (x,y)
MouseDoubleClick :: (Float, Float) -> Input

-- | Prompt (windowname,textbox content)
--   
--   Content returned from textbox in promptwindow with <tt>windowname</tt>
Prompt :: PromptInfo -> Input

-- | Panel buttonId [(controlId, value)]
--   
--   Event indicating that in the panel, the button with buttonId is
--   pressed and that at the time the controls had the given value
--   
--   Note: the list is ordered by controlId
--   
--   <ul>
--   <li>For checkboxes a value "Y" indicates that they are checked and a
--   value of "N" indicates they are unchecked</li>
--   <li>Buttons have no controlstate</li>
--   </ul>
Panel :: Int -> [(Int, String)] -> Input

-- | File name content
--   
--   The found file with given name, and found content
File :: FilePath -> FileType -> Input

-- | Indicates if saving of file at filepath succeeded
Save :: FilePath -> Bool -> Input

-- | Response to GetTime
--   
--   The time from midnight, 0 &lt;= t &lt; 86401s (because of
--   leap-seconds) It has a precision of 10^-12 s. Leap second is only
--   added if day has leap seconds
Time :: Float -> Input

-- | Invalid / Unknown input
Invalid :: Input
data Output

-- | Command to change the drawing mode
--   
--   Pictures returned from the eventhandler will normally be drawn on the
--   screen and in a buffer, so that the window can be quickly redrawn.
--   
--   A DrawOnBuffer command can change this default behavior, If the
--   parameter is False, pictures are only drawn on the screen. If the
--   parameter is True, drawing will be down on both the buffer and the
--   screen. This can be useful in response to MouseMotion Events.
--   
--   Example of rubber banding in line drawing program:
--   
--   <pre>
--   handler (p1:ps) (MouseDown p2)
--     = (p1:ps, [DrawOnBuffer False, DrawPicture (Color black $ Line [p1,p2])])
--   handler (p1:ps) (MouseMotion p2)
--     = (p1:ps, [DrawOnBuffer False, DrawPicture (Color black $ Line [p1,p2])])
--   handler (p1:ps) (MouseUp p2)
--     = (p2:p1:ps, [DrawOnBuffer True, DrawPicture (Color black $ Line [p1,p2])])
--   </pre>
DrawOnBuffer :: Bool -> Output

-- | Draw the picture
DrawPicture :: Picture -> Output

-- | GraphPrompt (windowName,info)
--   
--   Create a graphical prompt window which asks the user to enter a string
--   in a textbox. The user can be informed about valid entries through the
--   <tt>info</tt> field.
--   
--   Note: the entered string is recorded as the following input event:
--   'Prompt (windowName,enteredText)'
GraphPrompt :: PromptInfo -> Output

-- | Command to create a panel with the given panel content, must be
--   actived with the <a>PanelUpdate</a> command
PanelCreate :: PanelContent -> Output

-- | PanelUpdate visible [(identifier, value)]
--   
--   Command to change visibility and the content of a panel.
--   
--   Note: not all controls need to be listed, the order can be arbitrary
--   
--   <ul>
--   <li>For checkboxes, a value "Y" checks them, a value "N" unchecks
--   them</li>
--   <li>Buttons can not be altered</li>
--   </ul>
PanelUpdate :: Bool -> [(Int, String)] -> Output

-- | Clear the screen and buffer
ScreenClear :: Output

-- | ReadFile fileName default
--   
--   Read the file of the given filetype at the filename, if it fails The
--   default content is returned
--   
--   Note: the read file command generates following input event: 'File
--   fileName content'
ReadFile :: FilePath -> FileType -> Output

-- | SaveFile fileName content
--   
--   Save the file of the given filetype at the filename location
--   
--   Note: the save file command generates following input event: Save
--   fileName success (True/False)
SaveFile :: FilePath -> FileType -> Output

-- | Request the current time of day in seconds
--   
--   Note: the gettime command generates the following input event: 'Time
--   timeOfDay'
GetTime :: Output
data PanelItemType
CheckButton :: PanelItemType
Button :: PanelItemType
type PromptInfo = (String, String)

-- | (Title, width, height, menuItems, commandItems)
--   
--   Note: - panels are drawn in the center of the screen
--   
--   <ul>
--   <li>menu items are currently not supported</li>
--   </ul>
type PanelContent = (String, Float, Float, [(String, [(String, Int)])], [PanelItem])

-- | (Id, Title, Type, x-coord, y-coord, width, height)
type PanelItem = (Int, String, PanelItemType, Float, Float, Float, Float)

-- | The event mode lets you manage your own input. Pressing ESC will still
--   abort the program, but you don't get automatic pan and zoom controls
--   like with graphicsout. Should only be called once during the execution
--   of a program!
installEventHandler :: String -> (userState -> Input -> (userState, [Output])) -> userState -> Picture -> Int -> IO ()
instance Eq FileType
instance Show FileType
instance Eq Input
instance Show Input
instance Eq Output
instance Show Output
instance Eq GUIMode
instance Show GUIMode


-- | The <a>Prelude</a> defines the <a>Number</a> type (which is like
--   Amanda's <tt>num</tt> type), and hides the intricacies of Haskell's
--   Type Classes from new users when dealing with number. Also defines
--   corresponding <tt>Prelude</tt> functions that use this new
--   <a>Number</a> type.
module FPPrac.Prelude

-- | Combined integral and floating number type
data Number
ord :: Char -> Number
chr :: Number -> Char

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as a
--   <a>Number</a>.
length :: [a] -> Number

-- | List index (subscript) operator, starting from 0.
(!!) :: [a] -> Number -> a

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element.
--   
--   Fails when <tt>n</tt> is not an integral number
replicate :: Number -> a -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   Fails when <tt>n</tt> is not an integral number
take :: Number -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   Fails when <tt>n</tt> is not an integral number
drop :: Number -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   
--   Fails when <tt>n</tt> is not an integral number
splitAt :: Number -> [a] -> ([a], [a])

module FPPrac
