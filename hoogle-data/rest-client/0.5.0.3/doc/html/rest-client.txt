-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility library for use in generated API client libraries.
--   
@package rest-client
@version 0.5.0.3

module Rest.Client.Base
data ApiInfo
ApiInfo :: Manager -> String -> Int -> [(String, String)] -> ApiInfo
manager :: ApiInfo -> Manager
apiHost :: ApiInfo -> String
apiPort :: ApiInfo -> Int
headers :: ApiInfo -> [(String, String)]
data ApiState
ApiState :: CookieJar -> ApiState
cookies :: ApiState -> CookieJar
newtype ApiT m a
ApiT :: StateT ApiState (ReaderT ApiInfo (ResourceT m)) a -> ApiT m a
unApiT :: ApiT m a -> StateT ApiState (ReaderT ApiInfo (ResourceT m)) a
type Api = ApiT IO
class (MonadResource m, MonadBaseControl IO m, Monad m, Functor m, MonadBase IO m) => ApiStateC m
getApiState :: ApiStateC m => m ApiState
putApiState :: ApiStateC m => ApiState -> m ()
askApiInfo :: ApiStateC m => m ApiInfo
runT :: (MonadBaseControl IO m, Monad m) => ApiInfo -> ApiState -> ApiT m a -> ResourceT m a
run :: String -> ApiT IO a -> IO a
runWithPort :: String -> Int -> ApiT IO a -> IO a
data ApiResponse e a
ApiResponse :: Int -> ByteString -> (Int, Int) -> [(CI ByteString, ByteString)] -> Either (Reason e) a -> ApiResponse e a
statusCode :: ApiResponse e a -> Int
statusMessage :: ApiResponse e a -> ByteString
httpVersion :: ApiResponse e a -> (Int, Int)
responseHeaders :: ApiResponse e a -> [(CI ByteString, ByteString)]
responseBody :: ApiResponse e a -> Either (Reason e) a
responseToMaybe :: ApiResponse e a -> Maybe a
instance Functor m => Functor (ApiT m)
instance (Monad m, Functor m) => Applicative (ApiT m)
instance Monad m => Monad (ApiT m)
instance MonadIO m => MonadIO (ApiT m)
instance (Show e, Show a) => Show (ApiResponse e a)
instance ApiStateC m => ApiStateC (StateT s m)
instance ApiStateC m => ApiStateC (ReaderT r m)
instance ApiStateC m => ApiStateC (ListT m)
instance (Monoid w, ApiStateC m) => ApiStateC (WriterT w m)
instance (Monoid w, ApiStateC m) => ApiStateC (RWST r w s m)
instance (Error e, ApiStateC m) => ApiStateC (ErrorT e m)
instance ApiStateC m => ApiStateC (ExceptT e m)
instance (MonadIO m, MonadThrow m, MonadBase IO m, Functor m, Applicative m) => MonadResource (ApiT m)
instance MonadCatch m => MonadCatch (ApiT m)
instance MonadThrow m => MonadThrow (ApiT m)
instance MonadBaseControl v m => MonadBaseControl v (ApiT m)
instance MonadTransControl ApiT
instance MonadBase b m => MonadBase b (ApiT m)
instance MonadTrans ApiT
instance (MonadBaseControl IO m, Monad m, Functor m, MonadBase IO m, MonadIO m, MonadThrow m) => ApiStateC (ApiT m)

module Rest.Client.Internal

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A lazy <a>ByteString</a> contains 8-bit bytes, or by using the
--   operations from <a>Data.ByteString.Lazy.Char8</a> it can be
--   interpreted as containing 8-bit characters.
data ByteString :: *

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | URI encode a <a>String</a>, unicode aware.
encode :: String -> String
class ShowUrl a
showUrl :: ShowUrl a => a -> String

-- | HTTP Header names
hAccept :: HeaderName

-- | HTTP Header names
hContentType :: HeaderName
data ApiRequest
ApiRequest :: String -> String -> [(String, String)] -> RequestHeaders -> ByteString -> ApiRequest
method :: ApiRequest -> String
uri :: ApiRequest -> String
params :: ApiRequest -> [(String, String)]
requestHeaders :: ApiRequest -> RequestHeaders
requestBody :: ApiRequest -> ByteString
doRequest :: ApiStateC m => (ByteString -> Reason e) -> (ByteString -> a) -> ApiRequest -> m (ApiResponse e a)
parseResult :: (ByteString -> Reason e) -> (ByteString -> a) -> Response ByteString -> ApiResponse e a
fromJSON :: FromJSON a => ByteString -> a
toJSON :: ToJSON a => a -> ByteString
fromXML :: XmlStringToType a => ByteString -> a
toXML :: XmlStringToType a => a -> ByteString
makeReq :: String -> String -> [[String]] -> [(String, String)] -> RequestHeaders -> ByteString -> ApiRequest
doReq :: (ApiStateC m, MonadIO m) => ApiRequest -> m (Response ByteString)
instance [overlap ok] XmlPickler a => XmlStringToType a
instance [overlap ok] XmlStringToType String
