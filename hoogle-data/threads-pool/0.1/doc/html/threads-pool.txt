-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library to operate with pool of haskell's IO threads
--   
--   This library allows you to create a pool of worker threads, give them
--   tasks using a queue and receive results. Or not receive, if you wan't
--   to. Tasks are monadic computations in any monad which belong to
--   special <a>Task</a> typeclass (it basically means that one can run
--   that computation in IO monad, using some argument).
@package threads-pool
@version 0.1

module Control.Concurrent.Pool

-- | Any monadic computation that can be turned to IO
class (Monad m, MonadIO m) => Task m a r
runTask :: Task m a r => m r -> a -> IO r

-- | This stores all pool-related states
data Task m a r => Pool m a r

-- | Create new threads pool
newPool :: Task m a r => Int -> Bool -> m (Pool m a r)

-- | Create new threads pool in IO monad
newPoolIO :: Task m a r => Int -> Bool -> IO (Pool m a r)

-- | Check if pool is waiting for new tasks
isPoolWaiting :: Task m a r => Pool m a r -> IO Bool

-- | Put the new task into queue
queue :: Task m a r => Pool m a r -> m r -> a -> m Integer

-- | Tell to the pool that there will no new tasks
noMoreTasks :: Task m a r => Pool m a r -> m ()

-- | Tell to the pool that there will no new tasks, in IO monad
noMoreTasksIO :: Task m a r => Pool m a r -> IO ()

-- | Read next result from the pool. This makes sense only if for pool
--   which returns results.
readResult :: Task m a r => Pool m a r -> m (Integer, r)

-- | Read all results from pool and run given computation with each.
--   Probably you will run this in the separate thread (using forkIO). This
--   makes sense only if for pool which returns results.
resultsReader :: Task m a r => Pool m a r -> (Integer -> r -> IO b) -> IO ()

-- | Wait until all tasks will end
waitFor :: Task m a r => Pool m a r -> m ()

-- | Wait until all tasks will end, in IO monad
waitForIO :: Task m a r => Pool m a r -> IO ()
waitForTasks :: Task m a r => Pool m a r -> [Integer] -> m ()

-- | Terminate all threads in the pool
terminatePool :: Task m a r => Pool m a r -> m ()

-- | Terminate all threads in the pool, in IO monad
terminatePoolIO :: Task m a r => Pool m a r -> IO ()
instance Task (StateT a IO) a r
instance Task (ReaderT a IO) a r
instance Task IO () r
