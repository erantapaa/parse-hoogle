-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | IP Routing Table
--   
@package iproute
@version 1.4.0


-- | IP routing table is a tree of <tt>IPRange</tt> to search one of them
--   on the longest match base. It is a kind of TRIE with one way branching
--   removed. Both IPv4 and IPv6 are supported.
--   
--   For more information, see:
--   <a>http://www.mew.org/~kazu/proj/iproute/</a>
module Data.IP.RouteTable

-- | A class to contain IPv4 and IPv6.
class Addr a => Routable a
intToTBit :: Routable a => Int -> a
isZero :: Routable a => a -> a -> Bool

-- | The Tree structure for IP routing table based on TRIE with one way
--   branching removed. This is an abstract data type, so you cannot touch
--   its inside. Please use <a>insert</a> or <a>lookup</a>, instead.
data IPRTable k a

-- | The <a>empty</a> function returns an empty IP routing table.
--   
--   <pre>
--   &gt;&gt;&gt; (empty :: IPRTable IPv4 ()) == fromList []
--   True
--   </pre>
empty :: Routable k => IPRTable k a

-- | The <a>insert</a> function inserts a value with a key of
--   <a>AddrRange</a> to <a>IPRTable</a> and returns a new <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (insert ("127.0.0.1" :: AddrRange IPv4) () empty) == fromList [("127.0.0.1",())]
--   True
--   </pre>
insert :: Routable k => AddrRange k -> a -> IPRTable k a -> IPRTable k a

-- | The <a>delete</a> function deletes a value by a key of
--   <a>AddrRange</a> from <a>IPRTable</a> and returns a new
--   <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; delete "127.0.0.1" (insert "127.0.0.1" () empty) == (empty :: IPRTable IPv4 ())
--   True
--   </pre>
delete :: Routable k => AddrRange k -> IPRTable k a -> IPRTable k a

-- | The <a>lookup</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If a routing information in <a>IPRTable</a> matches
--   the key, its value is returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 v4
--   
--   &gt;&gt;&gt; lookup "127.0.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.3.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.4.0.0" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.4.0.1" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.5.16.0" rt
--   Just 133.5.16.0/24
--   
--   &gt;&gt;&gt; lookup "133.5.16.1" rt
--   Just 133.5.16.0/24
--   </pre>
lookup :: Routable k => AddrRange k -> IPRTable k a -> Maybe a

-- | The <a>findMatch</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If the key matches routing informations in
--   <a>IPRTable</a>, they are returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 $ repeat ()
--   
--   &gt;&gt;&gt; findMatch "133.4.0.0/15" rt :: [(AddrRange IPv4,())]
--   [(133.4.0.0/16,()),(133.5.0.0/16,()),(133.5.16.0/24,()),(133.5.23.0/24,())]
--   </pre>
findMatch :: MonadPlus m => Routable k => AddrRange k -> IPRTable k a -> m (AddrRange k, a)

-- | The <a>fromList</a> function creates a new IP routing table from a
--   list of a pair of <tt>IPrange</tt> and value.
fromList :: Routable k => [(AddrRange k, a)] -> IPRTable k a

-- | The <a>toList</a> function creates a list of a pair of
--   <a>AddrRange</a> and value from an IP routing table.
toList :: Routable k => IPRTable k a -> [(AddrRange k, a)]


-- | Data structures to express IPv4, IPv6 and IP range.
module Data.IP

-- | A unified IP data for <a>IPv4</a> and <a>IPv6</a>. To create this, use
--   the data constructors. Or use <a>read</a> <tt>"192.0.2.1"</tt> ::
--   <a>IP</a>, for example. Also, <tt>"192.0.2.1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1" :: IP) == IPv4 (read "192.0.2.1" :: IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01" :: IP) == IPv6 (read "2001:db8:00:00:00:00:00:01" :: IPv6)
--   True
--   </pre>
data IP
IPv4 :: IPv4 -> IP
ipv4 :: IP -> IPv4
IPv6 :: IPv6 -> IP
ipv6 :: IP -> IPv6

-- | The abstract data type to express an IPv4 address. To create this, use
--   <a>toIPv4</a>. Or use <a>read</a> <tt>"192.0.2.1"</tt> :: <a>IPv4</a>,
--   for example. Also, <tt>"192.0.2.1"</tt> can be used as literal with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1" :: IPv4
--   192.0.2.1
--   </pre>
data IPv4

-- | The <a>toIPv4</a> function takes a list of <a>Int</a> and returns
--   <a>IPv4</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv4 [192,0,2,1]
--   192.0.2.1
--   </pre>
toIPv4 :: [Int] -> IPv4

-- | The <a>fromIPv4</a> function converts <a>IPv4</a> to a list of
--   <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv4 (toIPv4 [192,0,2,1])
--   [192,0,2,1]
--   </pre>
fromIPv4 :: IPv4 -> [Int]

-- | The <a>fromHostAddress</a> function converts <a>HostAddress</a> to
--   <a>IPv4</a>.
fromHostAddress :: HostAddress -> IPv4

-- | The <a>toHostAddress</a> function converts <a>IPv4</a> to
--   <a>HostAddress</a>.
toHostAddress :: IPv4 -> HostAddress

-- | The abstract data type to express an IPv6 address. To create this, use
--   <a>toIPv6</a>. Or use <a>read</a> <tt>"2001:DB8::1"</tt> ::
--   <a>IPv6</a>, for example. Also, <tt>"2001:DB8::1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01" :: IPv6
--   2001:db8::1
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00::101" :: IPv6
--   2001:db8:11e:c00::101
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00:aa:bb:192.0.2.1" :: IPv6
--   2001:db8:11e:c00:aa:bb:c000:201
--   
--   &gt;&gt;&gt; read "2001:db8::192.0.2.1" :: IPv6
--   2001:db8::c000:201
--   
--   &gt;&gt;&gt; read "0::ffff:192.0.2.1" :: IPv6
--   ::ffff:192.0.2.1
--   
--   &gt;&gt;&gt; read "0::0:c000:201" :: IPv6
--   ::192.0.2.1
--   
--   &gt;&gt;&gt; read "::0.0.0.1" :: IPv6
--   ::1
--   </pre>
data IPv6

-- | The <a>toIPv6</a> function takes a list of <a>Int</a> and returns
--   <a>IPv6</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv6 [0x2001,0xDB8,0,0,0,0,0,1]
--   2001:db8::1
--   </pre>
toIPv6 :: [Int] -> IPv6

-- | The <a>toIPv6b</a> function takes a list of <a>Int</a> where each
--   member repserents a single byte and returns <a>IPv6</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv6b [0x20,0x01,0xD,0xB8,0,0,0,0,0,0,0,0,0,0,0,1]
--   2001:db8::1
--   </pre>
toIPv6b :: [Int] -> IPv6

-- | The <a>toIPv6</a> function converts <a>IPv6</a> to a list of
--   <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv6 (toIPv6 [0x2001,0xDB8,0,0,0,0,0,1])
--   [8193,3512,0,0,0,0,0,1]
--   </pre>
fromIPv6 :: IPv6 -> [Int]

-- | The <a>fromIPv6b</a> function converts <a>IPv6</a> to a list of
--   <a>Int</a> where each member represents a single byte.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv6b (toIPv6b [0x20,0x01,0xD,0xB8,0,0,0,0,0,0,0,0,0,0,0,1])
--   [32,1,13,184,0,0,0,0,0,0,0,0,0,0,0,1]
--   </pre>
fromIPv6b :: IPv6 -> [Int]

-- | The <a>fromHostAddress6</a> function converts <a>HostAddress6</a> to
--   <a>IPv6</a>.
fromHostAddress6 :: HostAddress6 -> IPv6

-- | The <a>toHostAddress6</a> function converts <a>IPv6</a> to
--   <a>HostAddress6</a>.
toHostAddress6 :: IPv6 -> HostAddress6

-- | A unified data for <a>AddrRange</a> <a>IPv4</a> and <a>AddrRange</a>
--   <a>IPv6</a>. To create this, use <a>read</a> <tt>"192.0.2.0/24"</tt>
--   :: <a>IPRange</a>. Also, <tt>"192.0.2.0/24"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1/24" :: IPRange) == IPv4Range (read "192.0.2.0/24" :: AddrRange IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01/48" :: IPRange) == IPv6Range (read "2001:db8:00:00:00:00:00:01/48" :: AddrRange IPv6)
--   True
--   </pre>
data IPRange
IPv4Range :: AddrRange IPv4 -> IPRange
ipv4range :: IPRange -> AddrRange IPv4
IPv6Range :: AddrRange IPv6 -> IPRange
ipv6range :: IPRange -> AddrRange IPv6

-- | The Addr range consists of an address, a contiguous mask, and mask
--   length. The contiguous mask and the mask length are essentially same
--   information but contained for pre calculation.
--   
--   To create this, use <tt>makeAddrRange</tt> or <a>read</a>
--   <tt>"192.0.2.0/24"</tt> :: <a>AddrRange</a> <a>IPv4</a>. Also,
--   <tt>"192.0.2.0/24"</tt> can be used as literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1/24" :: AddrRange IPv4
--   192.0.2.0/24
--   
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01/48" :: AddrRange IPv6
--   2001:db8::/48
--   </pre>
data AddrRange a

-- | <pre>
--   &gt;&gt;&gt; toIPv4 [127,0,2,1] `masked` intToMask 7
--   126.0.0.0
--   </pre>
class Eq a => Addr a
masked :: Addr a => a -> a -> a
intToMask :: Addr a => Int -> a

-- | The <a>makeAddrRange</a> functions takes an <a>Addr</a> address and a
--   mask length. It creates a bit mask from the mask length and masks the
--   <a>Addr</a> address, then returns <a>AddrRange</a> made of them.
--   
--   <pre>
--   &gt;&gt;&gt; makeAddrRange (toIPv4 [127,0,2,1]) 8
--   127.0.0.0/8
--   
--   &gt;&gt;&gt; makeAddrRange (toIPv6 [0x2001,0xDB8,0,0,0,0,0,1]) 8
--   2000::/8
--   </pre>
makeAddrRange :: Addr a => a -> Int -> AddrRange a

-- | The &gt;:&gt; operator takes two <a>AddrRange</a>. It returns
--   <a>True</a> if the first <a>AddrRange</a> contains the second
--   <a>AddrRange</a>. Otherwise, it returns <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; makeAddrRange ("127.0.2.1" :: IPv4) 8 &gt;:&gt; makeAddrRange "127.0.2.1" 24
--   True
--   
--   &gt;&gt;&gt; makeAddrRange ("127.0.2.1" :: IPv4) 24 &gt;:&gt; makeAddrRange "127.0.2.1" 8
--   False
--   
--   &gt;&gt;&gt; makeAddrRange ("2001:DB8::1" :: IPv6) 16 &gt;:&gt; makeAddrRange "2001:DB8::1" 32
--   True
--   
--   &gt;&gt;&gt; makeAddrRange ("2001:DB8::1" :: IPv6) 32 &gt;:&gt; makeAddrRange "2001:DB8::1" 16
--   False
--   </pre>
(>:>) :: Addr a => AddrRange a -> AddrRange a -> Bool

-- | The <tt>toMatchedTo</tt> function take an <a>Addr</a> address and an
--   <a>AddrRange</a>, and returns <a>True</a> if the range contains the
--   address.
--   
--   <pre>
--   &gt;&gt;&gt; ("127.0.2.0" :: IPv4) `isMatchedTo` makeAddrRange "127.0.2.1" 24
--   True
--   
--   &gt;&gt;&gt; ("127.0.2.0" :: IPv4) `isMatchedTo` makeAddrRange "127.0.2.1" 32
--   False
--   
--   &gt;&gt;&gt; ("2001:DB8::1" :: IPv6) `isMatchedTo` makeAddrRange "2001:DB8::1" 32
--   True
--   
--   &gt;&gt;&gt; ("2001:DB8::" :: IPv6) `isMatchedTo` makeAddrRange "2001:DB8::1" 128
--   False
--   </pre>
isMatchedTo :: Addr a => a -> AddrRange a -> Bool

-- | The <tt>unmakeAddrRange</tt> functions take a <a>AddrRange</a> and
--   returns the network address and a mask length.
--   
--   <pre>
--   &gt;&gt;&gt; addrRangePair ("127.0.0.0/8" :: AddrRange IPv4)
--   (127.0.0.0,8)
--   
--   &gt;&gt;&gt; addrRangePair ("2000::/8" :: AddrRange IPv6)
--   (2000::,8)
--   </pre>
addrRangePair :: Addr a => AddrRange a -> (a, Int)

-- | Convert IPv4 range to IPV4-embedded-in-IPV6 range
ipv4RangeToIPv6 :: AddrRange IPv4 -> AddrRange IPv6

-- | Convert IPv4 address to IPv4-embedded-in-IPv6
ipv4ToIPv6 :: IPv4 -> IPv6
