-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax Macros in the form of an EDSL
--   
--   Library of first-class Syntax Macros
@package SyntaxMacros
@version 1.0.3

module Language.Grammars.SyntaxMacros.Scanner
scanHandle :: ScanOpts -> FilePath -> Handle -> IO [Token]
scanFile :: ScanOpts -> FilePath -> IO [Token]
scan :: ScanOpts -> Pos -> String -> [Token]
getRational :: String -> (String, Maybe String, Maybe (Maybe String, String))
getBaseNumber :: Integer -> [Char] -> Integer
type Token = GenToken String EnumValToken String
data EnumValToken
TkVarid :: EnumValToken
TkConid :: EnumValToken
TkOp :: EnumValToken
TkConOp :: EnumValToken
TkQVarid :: EnumValToken
TkQConid :: EnumValToken
TkQOp :: EnumValToken
TkQConOp :: EnumValToken
TkString :: EnumValToken
TkChar :: EnumValToken
TkInteger8 :: EnumValToken
TkInteger10 :: EnumValToken
TkInteger16 :: EnumValToken
TkFraction :: EnumValToken
TkTextnm :: EnumValToken
TkTextln :: EnumValToken
TkError :: EnumValToken
reserved :: String -> Pos -> Token
valueToken :: EnumValToken -> String -> Pos -> Token
errToken :: String -> Pos -> Token
tokTpIsInt :: EnumValToken -> Bool
tokTpIsId :: EnumValToken -> Bool
tokTpQual :: EnumValToken -> EnumValToken
pKeyPos :: IsParser p Token => String -> p Pos
pSpecPos :: IsParser p Token => Char -> p Pos
pKey :: IsParser p Token => String -> p String
pSpec :: IsParser p Token => Char -> p String
pStringPos, pConsymPos, pVarsymPos, pIntegerPos, pTextlnPos, pTextnmPos, pConidPos, pVaridPos, pFractionPos, pInteger16Pos, pInteger10Pos, pInteger8Pos, pCharPos :: IsParser p Token => p (String, Pos)
pString, pConsym, pVarsym, pInteger, pTextln, pTextnm, pConid, pVarid, pFraction, pInteger16, pInteger10, pInteger8, pChar :: IsParser p Token => p String
pComma, pCCurly, pOCurly, pCBrack, pOBrack, pCParen, pOParen, pSemi :: IsParser p Token => p String
pCommaPos, pCCurlyPos, pOCurlyPos, pCBrackPos, pOBrackPos, pCParenPos, pOParenPos, pSemiPos :: IsParser p Token => p Pos
pCommas :: IsParser p Token => p a -> p [a]
pSemics :: IsParser p Token => p a -> p [a]
pParens :: IsParser p Token => p a -> p a
pBracks :: IsParser p Token => p a -> p a
pCurly :: IsParser p Token => p a -> p a
pParens_pCommas :: IsParser p Token => p a -> p [a]
pBracks_pCommas :: IsParser p Token => p a -> p [a]
pCurly_pSemics :: IsParser p Token => p a -> p [a]
data ScanOpts
ScanOpts :: !Set String -> !Set String -> !Set String -> !Set Char -> !Set Char -> !Set String -> !Bool -> ![String] -> !String -> !String -> !String -> !Bool -> ![(String, String)] -> !Bool -> ScanOpts
scoKeywordsTxt :: ScanOpts -> !Set String
scoCommandsTxt :: ScanOpts -> !Set String
scoKeywordsOps :: ScanOpts -> !Set String
scoSpecChars :: ScanOpts -> !Set Char
scoOpChars :: ScanOpts -> !Set Char
scoSpecPairs :: ScanOpts -> !Set String
scoDollarIdent :: ScanOpts -> !Bool
scoOffsideTrigs :: ScanOpts -> ![String]
scoOffsideModule :: ScanOpts -> !String
scoOffsideOpen :: ScanOpts -> !String
scoOffsideClose :: ScanOpts -> !String
scoLitmode :: ScanOpts -> !Bool
scoVerbOpenClose :: ScanOpts -> ![(String, String)]
scoAllowQualified :: ScanOpts -> !Bool
defaultScanOpts :: ScanOpts
isNoPos :: Pos -> Bool
posIs1stColumn :: Pos -> Bool
data InFilePos
InFilePos :: Int -> Int -> InFilePos
infpLine :: InFilePos -> Int
infpColumn :: InFilePos -> Int
infpStart :: InFilePos
infpNone :: InFilePos
infpAdvCol :: Int -> InFilePos -> InFilePos
infpAdvLine :: Int -> InFilePos -> InFilePos
infpAdv1Line :: InFilePos -> InFilePos
infpAdvStr :: String -> InFilePos -> InFilePos
genTokVal :: GenToken v t v -> v
genTokTp :: GenToken k t v -> Maybe t
genTokMap :: (a -> b) -> GenToken a t a -> GenToken b t b
isLF :: Char -> Bool
isStr :: Char -> Bool
isStrQuote :: Char -> Bool
isWhite :: Char -> Bool
isBlack :: Char -> Bool
isVarStart :: Char -> Bool
isVarRest :: Char -> Bool

module Language.Grammars.Grammar
data TL
data FL a
data NF
data Grammar a
Grammar :: (Ref a env) -> (FinalEnv (Productions NF) env) -> Grammar a
newtype Productions l a env
PS :: [Prod l a env] -> Productions l a env
unPS :: Productions l a env -> [Prod l a env]
data Prod l a env
Star :: Prod l (a -> b) env -> Prod l a env -> Prod l b env
FlipStar :: Prod NF a env -> Prod NF (a -> b) env -> Prod NF b env
Sym :: Symbol a t env -> Prod l a env
Pure :: a -> Prod l a env
Fix :: Productions (FL a) a env -> Prod TL a env
Var :: Prod (FL a) a env
type GramEnv = Env (Productions NF)
type PreGramEnv = Env (Productions TL)
newtype PreProductions l env a
PP :: [Prod l a env] -> PreProductions l env a
unPP :: PreProductions l env a -> [Prod l a env]
type Line = Int
type Column = Int
type Filename = String
data Pos
Pos :: !Line -> !Column -> Pos
PosFile :: !Line -> !Column -> Filename -> Pos
data DTerm a
DTerm :: Pos -> a -> DTerm a
pos :: DTerm a -> Pos
value :: DTerm a -> a
data TTerm
data TNonT
data TAttT
data Symbol a t env
Term :: String -> Symbol (DTerm String) TTerm env
Nont :: Ref a env -> Symbol a TNonT env
TermInt :: Symbol (DTerm Int) TAttT env
TermChar :: Symbol (DTerm Char) TAttT env
TermVarid :: Symbol (DTerm String) TAttT env
TermConid :: Symbol (DTerm String) TAttT env
TermOp :: Symbol (DTerm String) TAttT env
getRefNT :: Symbol a TNonT env -> Ref a env
pairEq :: Maybe (Equal a b) -> Maybe (Equal (a, t) (b, t))
matchSym :: Symbol a t1 env -> Symbol b t2 env -> Maybe (Equal (a, t1) (b, t2))
int :: Symbol (DTerm Int) TAttT env
char :: Symbol (DTerm Char) TAttT env
var :: Symbol (DTerm String) TAttT env
con :: Symbol (DTerm String) TAttT env
op :: Symbol (DTerm String) TAttT env
sym :: Symbol a t env -> PreProductions l env a
nt :: Symbol a TNonT env -> PreProductions l env a
ntPrd :: Symbol a TNonT env -> PreProductions l env a
tr :: String -> PreProductions l env (DTerm String)
prod :: PreProductions l env a -> Productions l a env
varPrd :: PreProductions (FL a) env a
fixPrd :: PreProductions (FL a) env a -> PreProductions TL env a
pSome :: PreProductions (FL [a]) env a -> PreProductions TL env [a]
pMany :: PreProductions (FL [a]) env a -> PreProductions TL env [a]
opt :: PreProductions l env a -> a -> PreProductions l env a
pMaybe :: (b, a -> b) -> PreProductions TL env a -> PreProductions TL env b
pFoldr :: (a -> b -> b, b) -> PreProductions (FL b) env a -> PreProductions TL env b

-- | The <a>Ii</a> is to be pronounced as <tt>stop</tt>
data Ii
Ii :: Ii

-- | The function <a>iI</a> is to be pronounced as <tt>start</tt>
iI :: Idiomatic l env (a -> a) g => g
class Idiomatic l env f g | g -> f l env
idiomatic :: Idiomatic l env f g => PreProductions l env f -> g
newtype LSPair nt a t env
LSPair :: (Symbol a t env) -> LSPair nt a t env
symLSPair :: LSPair nt a t env -> (Symbol a t env)
labelLSPair :: LSPair nt a t env -> nt
(^=) :: nt -> Symbol a t env -> LSPair nt a t env
class LabelSymbol t v v' | t v -> v'
(<=>) :: LabelSymbol t v v' => label -> Symbol v t env -> PreProductions l env (LVPair label v')
instance Show Pos
instance LabelSymbol TTerm v v
instance LabelSymbol TNonT v v
instance LabelSymbol TAttT v (Record HNil -> v)
instance Idiomatic l env f g => Idiomatic l env f (String -> g)
instance Idiomatic l env f g => Idiomatic l env ((a -> b) -> f) ((a -> b) -> g)
instance Idiomatic l env f g => Idiomatic l env ((Record HNil -> a) -> f) (Symbol a TAttT env -> g)
instance Idiomatic l env f g => Idiomatic l env (a -> f) (Symbol a TNonT env -> g)
instance Idiomatic l env f g => Idiomatic l env (a -> f) (PreProductions l env a -> g)
instance Idiomatic l env x (Ii -> PreProductions l env x)
instance Alternative (PreProductions l env)
instance Applicative (PreProductions l env)
instance Functor (PreProductions l env)

module Language.Grammars.SyntaxMacros.UUParsing
type Parser a = P (Str Char String LineCol) a
pInt :: Parser Int
pChr :: Parser Char
pVar :: Parser String
pCon :: Parser String
pIdChar :: Parser Char
pOp :: Parser String
pTerm :: String -> Parser String
spaces :: Parser String
lc2Pos :: LineCol -> Pos
newtype Const f a s
C :: f a -> Const f a s
unC :: Const f a s -> f a

-- | The function <a>compile</a> generates a parser out of a closed grammar
compile :: Grammar a -> Parser a
mapEnv :: (forall a. f a s -> g a s) -> Env f s env -> Env g s env
data ParseResult a
Ok :: a -> ParseResult a
Rep :: a -> [Error LineCol] -> ParseResult a

-- | The function <a>parse</a> runs the parser for an input.
parse :: Parser a -> String -> ParseResult a
instance Show a => Show (ParseResult a)

module Language.Grammars.SyntaxMacros.UULib
toPos :: Pos -> Pos
toDTerm :: (a -> b) -> (a, Pos) -> DTerm b
pChr :: Parser Token (DTerm Char)
pInt :: Parser Token (DTerm Int)
pCon :: Parser Token (DTerm String)
pVar :: Parser Token (DTerm String)
pOp :: Parser Token (DTerm String)
pTerm :: IsParser p Token => String -> p (DTerm String)
newtype Const f a s
C :: f a -> Const f a s
unC :: Const f a s -> f a
compile :: Grammar a -> Parser Token a
mapEnv :: (forall a. f a s -> g a s) -> Env f s env -> Env g s env
type ParseMsg = Message Token (Maybe Token)
data ParseResult a
Ok :: a -> ParseResult a
Rep :: a -> [ParseMsg] -> ParseResult a
parse :: Parser Token a -> [Token] -> ParseResult a
rparse :: Parser Token a -> [Token] -> (a, [ParseMsg])
instance Show a => Show (ParseResult a)

module Language.Grammars.SyntaxMacros
type GramTrafo = Trafo Unit (Productions NF)
type PreGramTrafo = Trafo Unit (Productions TL)
type ExtGram env start nts = PreGramTrafo env () (Export start nts env)
type SyntaxMacro env start nts start' nts' = PreGramTrafo env (Export start nts env) (Export start' nts' env)
data Export start nts env
Export :: (Symbol start TNonT env) -> (nts env) -> Export start nts env
addNT :: PreGramTrafo env (PreProductions TL env a) (Symbol a TNonT env)
addProds :: PreGramTrafo env (Symbol a TNonT env, PreProductions TL env a) ()
closeGram :: (forall env. ExtGram env a nts) -> Grammar a
extendGram :: (NTRecord (nts env), NTRecord (nts' env)) => ExtGram env start nts -> SyntaxMacro env start nts start' nts' -> ExtGram env start' nts'
(+>>) :: (NTRecord (nts env), NTRecord (nts' env)) => ExtGram env start nts -> SyntaxMacro env start nts start' nts' -> ExtGram env start' nts'
exportNTs :: NTRecord (nts env) => PreGramTrafo env (Export start nts env) (Export start nts env)
data NTCons nt v l env
NTCons :: (LSPair nt v TNonT env) -> (l env) -> NTCons nt v l env
data NTNil env
NTNil :: NTNil env
class NTRecord r
class Fail err
data Duplicated nt
class NotDuplicated nt r
ntNil :: NTNil env
(^|) :: NTRecord (NTCons nt a l env) => LSPair nt a TNonT env -> l env -> NTCons nt a l env
class GetNT nt r v | nt r -> v
getNT :: GetNT nt r v => nt -> r -> v
data NotFound nt
getStart :: Export start nts env -> (Symbol start TNonT env)
exportList :: Symbol start TNonT env -> (NTNil env -> nts env) -> Export start nts env
export :: (NTRecord (l env), NotDuplicated nt (l env)) => nt -> Symbol a TNonT env -> l env -> NTCons nt a l env
extendExport :: Export start t env -> (t env -> nts env) -> Export start nts env
instance [overlap ok] GetNT nt (nts env) r => GetNT nt (Export start nts env) r
instance [overlap ok] GetNT nt1 (l env) r => GetNT nt1 (NTCons nt2 v l env) r
instance [overlap ok] GetNT nt (NTCons nt v l env) (Symbol v TNonT env)
instance [overlap ok] Fail (NotFound nt) => GetNT nt (NTNil env) r
instance [overlap ok] NotDuplicated nt1 (l env) => NotDuplicated nt1 (NTCons nt2 v l env)
instance [overlap ok] Fail (Duplicated nt) => NotDuplicated nt (NTCons nt v l env)
instance [overlap ok] NotDuplicated nt (NTNil env)
instance [overlap ok] (NTRecord (l env), NotDuplicated nt (l env)) => NTRecord (NTCons nt v l env)
instance [overlap ok] NTRecord (NTNil env)
