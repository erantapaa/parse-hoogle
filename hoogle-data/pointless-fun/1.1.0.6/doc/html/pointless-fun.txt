-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some common point-free combinators.
--   
@package pointless-fun
@version 1.1.0.6


-- | Pointless fun :)
module Data.Function.Pointless

-- | Lift a function for multicomposition. This is like the <tt>::</tt> of
--   a type signature.
($::) :: (a -> b) -> ((a -> b) -> (c -> d)) -> (c -> d)

-- | Multicompose a function on the appropriate argument. This is like the
--   <tt>-&gt;</tt> arrows in a type signature.
(~>) :: (a -> b) -> (c -> d) -> ((b -> c) -> (a -> d))

-- | Multicompose a function on the appropriate argument, calling the left
--   function eagerly. That is, the resulting function will be strict in
--   <tt>a</tt> if the left argument is strict in <tt>a</tt> (assuming the
--   final function of the multicomposition, the one applied to the return
--   value, is also strict).
(!~>) :: (a -> b) -> (c -> d) -> ((b -> c) -> (a -> d))

-- | Binary composition: pass two args to the right argument before
--   composing.
--   
--   <pre>
--   (f .: g) x y = f (g x y)
--   </pre>
--   
--   or,
--   
--   <pre>
--   f .: g = curry (f . uncurry g)
--   </pre>
--   
--   This is the same as the common idiom <tt>(f .) . g</tt> but more
--   easily extended to multiple uses, due to the fixity declaration.
(.:) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)

-- | Secondary composition: compose the right argument on the second arg of
--   the left argument.
--   
--   <pre>
--   (f .^ g) x y = f x (g y)
--   </pre>
(.^) :: (a -> c -> d) -> (b -> c) -> (a -> b -> d)

-- | Function composition which calls the right-hand function eagerly;
--   i.e., making the left-hand function strict in its first argument.
--   
--   <pre>
--   (f .! g) x = f $! g x
--   </pre>
--   
--   This defines the composition for the sub-category of strict Haskell
--   functions. If the <a>Functor</a> class were parameterized by the
--   domain and codomain categories (e.g., a regular <tt>Functor f</tt>
--   would be <tt>CFunctor (-&gt;) (-&gt;) f</tt> instead) then this would
--   allow us to define functors <tt>CFunctor (-&gt;) (!-&gt;) f</tt> where
--   <tt>fmap f . fmap g = fmap (f .! g)</tt>.
(.!) :: (b -> c) -> (a -> b) -> a -> c
