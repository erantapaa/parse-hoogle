-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some utilities every serious chatty-based application may need.
--   
@package chatty-utils
@version 0.7.3.2

module Data.Chatty.ListBuilder
class Monad l => ListBuilder l i | l -> i
li :: ListBuilder l i => i -> l ()
buildList :: ListBuilder l i => l () -> [i]
newtype StrictBuilderT i m a
StrictBuilder :: ([i] -> m (a, [i])) -> StrictBuilderT i m a
runStrictBuilderT :: StrictBuilderT i m a -> [i] -> m (a, [i])
type StrictBuilder i = StrictBuilderT i Identity
strictBuild :: StrictBuilderT i Identity () -> [i]
newtype LazyBuilderT i m a
LazyBuilder :: (([i] -> [i]) -> m (a, [i] -> [i])) -> LazyBuilderT i m a
runLazyBuilderT :: LazyBuilderT i m a -> ([i] -> [i]) -> m (a, [i] -> [i])
type LazyBuilder i = LazyBuilderT i Identity
lazyBuild :: LazyBuilderT i Identity () -> [i]
lis :: ListBuilder l i => [i] -> l ()
lit :: ListBuilder l (a, b) => a -> b -> l ()
(>-<) :: ListBuilder l (a, b) => a -> b -> l ()
instance [safe] ListBuilder (LazyBuilder i) i
instance [safe] MonadTrans (LazyBuilderT i)
instance [safe] Monad m => Monad (LazyBuilderT i m)
instance [safe] (Functor m, Monad m) => Applicative (LazyBuilderT i m)
instance [safe] Functor m => Functor (LazyBuilderT i m)
instance [safe] ListBuilder (StrictBuilder i) i
instance [safe] MonadTrans (StrictBuilderT i)
instance [safe] Monad m => Monad (StrictBuilderT i m)
instance [safe] (Functor m, Monad m) => Applicative (StrictBuilderT i m)
instance [safe] Functor m => Functor (StrictBuilderT i m)

module Data.Chatty.Hetero

-- | The Cons type for a heterogenous list
data Cons a b
(:-:) :: a -> b -> Cons a b

-- | The empty list
data Nil
Nil :: Nil

-- | Typeclass for appending one heterogenous list to another one
class Append a b ab | a b -> ab
tappend :: Append a b ab => a -> b -> ab

-- | Typeclass for wrapping a heterogenous list into a Maybe on demand
class IntoMaybe a ar | a -> ar
tjust :: IntoMaybe a ar => a -> ar
tnothing :: IntoMaybe a ar => a -> ar

-- | Typeclass for everything that may be converted to a tuple
class Tuplify l t | l -> t
tuplify :: Tuplify l t => l -> t
data Titled a
Titled :: String -> a -> Titled a
instance [safe] Tuplify a ar => Tuplify (Titled a) ar
instance [safe] Tuplify a ar => Tuplify (Maybe a) (Maybe ar)
instance [safe] Tuplify a ar => Tuplify [a] [ar]
instance [safe] Tuplify Char Char
instance [safe] Tuplify Int Int
instance [safe] (Tuplify a ar, Tuplify b br, Tuplify c cr, Tuplify d dr, Tuplify e er, Tuplify f fr) => Tuplify (Cons a (Cons b (Cons c (Cons d (Cons e (Cons f Nil)))))) (ar, br, cr, dr, er, fr)
instance [safe] (Tuplify a ar, Tuplify b br, Tuplify c cr, Tuplify d dr, Tuplify e er) => Tuplify (Cons a (Cons b (Cons c (Cons d (Cons e Nil))))) (ar, br, cr, dr, er)
instance [safe] (Tuplify a ar, Tuplify b br, Tuplify c cr, Tuplify d dr) => Tuplify (Cons a (Cons b (Cons c (Cons d Nil)))) (ar, br, cr, dr)
instance [safe] (Tuplify a ar, Tuplify b br, Tuplify c cr) => Tuplify (Cons a (Cons b (Cons c Nil))) (ar, br, cr)
instance [safe] (Tuplify a ar, Tuplify b br) => Tuplify (Cons a (Cons b Nil)) (ar, br)
instance [safe] Tuplify a ar => Tuplify (Cons a Nil) ar
instance [safe] Tuplify Nil ()
instance [safe] IntoMaybe (Cons a as) (Cons (Maybe (Cons a as)) Nil)
instance [safe] IntoMaybe Nil Nil
instance [safe] Append b c bc => Append (Cons a b) c (Cons a bc)
instance [safe] Append Nil b b


-- | Provides a monad for error handling. Okay, I confess it's equal to
--   ErrorT...
module Data.Chatty.Fail

-- | The error handling monad.
newtype FailT e m a
Fail :: m (Either e a) -> FailT e m a
runFailT :: FailT e m a -> m (Either e a)
type Fail e = FailT e Identity
instance [safe] Monad m => MonadError e (FailT e m)
instance [safe] MonadTrans (FailT e)
instance [safe] Monad m => Monad (FailT e m)
instance [safe] Monad m => Applicative (FailT e m)
instance [safe] Monad m => Functor (FailT e m)


-- | Provides a typeclass for everything that may carry a void value
module Data.Chatty.None

-- | Typeclass for everything that may carry a void value
class None n
none :: None n => n

-- | Wrap the void into a monad.
noneM :: (Monad m, None n) => m n

-- | Join a maybe into the underlying type. <a>Nothing</a> becomes
--   <a>none</a>.
joinMaybe :: None n => Maybe n -> n

-- | Wrap the value into a maybe. <a>none</a> becomes <a>Nothing</a>.
expandMaybe :: (Eq n, None n) => n -> Maybe n

-- | Clean the maybe by pulling wrapped <a>none</a>s to the outside (as a
--   <a>Nothing</a>).
cleanMaybe :: (Eq n, None n) => Maybe n -> Maybe n

-- | Eliminate all void elements from the list.
reduce :: (Eq n, None n) => [n] -> [n]

-- | Eliminate all <a>Nothing</a>s from the list and unjust all remaining
--   values.
reduceMaybe :: [Maybe a] -> [a]
instance [safe] None Bool
instance [safe] None Integer
instance [safe] None Int
instance [safe] Monad m => None (a -> m a)
instance [safe] None (a -> a)
instance [safe] None Text
instance [safe] None ()
instance [safe] None (Maybe a)
instance [safe] None [a]


-- | Provides a ternary search trie
module Data.Chatty.TST

-- | A ternary search trie
data TST a
EmptyTST :: TST a
TST :: Char -> (Maybe a) -> (TST a) -> (TST a) -> (TST a) -> TST a

-- | Insert something into the TST
tstInsert :: String -> a -> TST a -> TST a

-- | Lookup some string in the TST
tstLookup :: String -> TST a -> Maybe a

-- | Check if the TST contains the given key
tstContains :: String -> TST a -> Bool

-- | Traverse TST
tstTraverse :: TST a -> [(String, a)]
instance [safe] None (TST a)


-- | Provides a typeclass for all binary search trees and an unbalanced
--   implementation
module Data.Chatty.BST

-- | Only instances of Indexable may be saved in a BST
class Ord o => Indexable i o v | i -> o, i -> v
indexOf :: Indexable i o v => i -> o
valueOf :: Indexable i o v => i -> v

-- | Typeclass for all BSTs that store the given Indexable
class Indexable i o v => AnyBST t i o v
anyBstInsert :: AnyBST t i o v => i -> t i -> t i
anyBstRemove :: AnyBST t i o v => o -> t i -> t i
anyBstMax :: AnyBST t i o v => t i -> Maybe i
anyBstMin :: AnyBST t i o v => t i -> Maybe i
anyBstLookup :: AnyBST t i o v => o -> t i -> Maybe v
anyBstEmpty :: AnyBST t i o v => t i
anyBstHead :: AnyBST t i o v => t i -> Maybe i
anyBstInorder :: AnyBST t i o v => t i -> [i]

-- | An unbalanced binary search tree
data BST a
EmptyBST :: BST a
BST :: a -> !(BST a) -> !(BST a) -> BST a

-- | Insert into the BST
bstInsert :: Indexable i o v => i -> BST i -> BST i

-- | Remove from the BST
bstRemove :: Indexable i o v => o -> BST i -> BST i

-- | Get the greatest element
bstMax :: BST i -> Maybe i

-- | Get the least element
bstMin :: BST i -> Maybe i

-- | Lookup a given key
bstLookup :: Indexable i o v => o -> BST i -> Maybe v

-- | Lookup if a given key is contained
bstContains :: Indexable i o v => o -> BST i -> Bool

-- | Return the tree's root
bstHead :: Indexable i o v => BST i -> Maybe i

-- | Traverse the tree in order
bstInorder :: Indexable i o v => BST i -> [i]
instance [safe] None (BST a)
instance [safe] Indexable i o v => AnyBST BST i o v
instance [safe] Ord o => Indexable (o, a, b, c, d, e) o (a, b, c, d, e)
instance [safe] Ord o => Indexable (o, a, b, c, d) o (a, b, c, d)
instance [safe] Ord o => Indexable (o, a, b, c) o (a, b, c)
instance [safe] Ord o => Indexable (o, a, b) o (a, b)
instance [safe] Ord o => Indexable (o, a) o a
instance [safe] Indexable Int Int Int


-- | Provides an unbalanced BST with a focus on the root.
module Data.Chatty.Focus

-- | An unbalanced BST with a focus on the root.
data Focus a

-- | Rotate the tree such that the given element becomes the root node.
focusSelect :: Indexable a o v => o -> Focus a -> Maybe (Focus a)
instance [safe] Indexable i o v => AnyBST Focus i o v
instance [safe] None (Focus a)


-- | Provides a counter monad.
module Data.Chatty.Counter

-- | A counter monad.
newtype CounterT m a
Counter :: (Int -> m (a, Int)) -> CounterT m a
runCounterT :: CounterT m a -> Int -> m (a, Int)

-- | Typeclass for all counter monads.
class Monad m => ChCounter m
countOn :: ChCounter m => m Int

-- | Run the given function inside a counter
withCounter :: (Monad m, Functor m) => CounterT m a -> m a
instance [safe] Monad m => ChCounter (CounterT m)
instance [safe] MonadTrans CounterT
instance [safe] Monad m => Monad (CounterT m)
instance [safe] (Functor m, Monad m) => Applicative (CounterT m)
instance [safe] Functor m => Functor (CounterT m)


-- | Provides an AVL tree.
module Data.Chatty.AVL

-- | Get the greatest element.
avlMax :: AVL i -> Maybe i

-- | Get the least element.
avlMin :: AVL i -> Maybe i

-- | Lookup a given key.
avlLookup :: Indexable i o v => o -> AVL i -> Maybe v

-- | Get the height of the tree.
avlHeight :: AVL i -> Int

-- | Get the size of the tree.
avlSize :: AVL i -> Int

-- | Insert into the tree.
avlInsert :: Indexable i o v => i -> AVL i -> AVL i

-- | Remove from the tree.
avlRemove :: Indexable i o v => o -> AVL i -> AVL i

-- | An AVL tree.
data AVL a
EmptyAVL :: AVL a
AVL :: a -> Int -> Int -> !(AVL a) -> !(AVL a) -> AVL a

-- | Get the root of the tree.
avlRoot :: AVL i -> i

-- | Traverse the tree, order (head, left, right)
avlPreorder :: AVL i -> [i]

-- | Traverse the tree, order (left, right, head)
avlPostorder :: AVL i -> [i]

-- | Traverse the tree, order (left, head, right)
avlInorder :: AVL i -> [i]
instance [safe] Functor AVL
instance [safe] None (AVL a)
instance [safe] Indexable i o v => AnyBST AVL i o v


-- | Provides a general graph.
module Data.Chatty.Graph

-- | Phantom type for a node ID
newtype NodeId
NodeId :: Int -> NodeId

-- | A general graph
data Graph a b c
Graph :: AVL (Node a) -> [Edge b c] -> NodeId -> Graph a b c
nodes :: Graph a b c -> AVL (Node a)
edges :: Graph a b c -> [Edge b c]
nextId :: Graph a b c -> NodeId

-- | A node for the graph
data Node a
Node :: Bool -> a -> NodeId -> Node a
nodeMarked :: Node a -> Bool
nodeContent :: Node a -> a
nodeId :: Node a -> NodeId

-- | An edge for the graph
data Edge b c
Edge :: NodeId -> NodeId -> Int -> b -> c -> Edge b c
fromNode :: Edge b c -> NodeId
toNode :: Edge b c -> NodeId
weight :: Edge b c -> Int
label :: Edge b c -> b
content :: Edge b c -> c

-- | Increment a NodeId
incId :: NodeId -> NodeId

-- | An empty graph
emptyGraph :: Graph a b c

-- | Add a node to the graph
addNode :: a -> Graph a b c -> Graph a b c

-- | Add a node to the graph and also return its ID
addNode' :: a -> Graph a b c -> (NodeId, Graph a b c)

-- | Add a bunch of nodes
addNodes :: [a] -> Graph a b c -> Graph a b c

-- | Add a bunch of nodes and also return their IDs
addNodes' :: [a] -> Graph a b c -> ([NodeId], Graph a b c)

-- | Return all nodes
allNodes :: Graph a b c -> [Node a]

-- | Return the node in the AVL tree's root
rootNode :: Graph a b c -> NodeId

-- | Add a unidirectional edge to the graph (provide both nodes, a weight
--   and a label)
addEdge :: NodeId -> NodeId -> Int -> b -> c -> Graph a b c -> Graph a b c

-- | Add a unidirectional edge to the graph (provide the <a>Edge</a>)
addEdge' :: Edge b c -> Graph a b c -> Graph a b c

-- | Add a bidirectional edge to the graph (provide both nodes, a weight
--   and a label)
addMutualEdge :: NodeId -> NodeId -> Int -> b -> c -> Graph a b c -> Graph a b c

-- | Add a bunch of edges unidirectionally (provide both nodes, a weight
--   and a label)
addEdges :: [(NodeId, NodeId, Int, b, c)] -> Graph a b c -> Graph a b c

-- | Add a bunch of edges unidirectionally (provide the <a>Edge</a>s)
addEdges' :: [Edge b c] -> Graph a b c -> Graph a b c

-- | Add a bunch of edges bidirectionally (provide both nodes, a weight and
--   a label)
addMutualEdges :: [(NodeId, NodeId, Int, b, c)] -> Graph a b c -> Graph a b c

-- | Get the node's content from its ID
getNode :: NodeId -> Graph a b c -> a

-- | Get the <a>Node</a> object from its ID
getNode' :: NodeId -> Graph a b c -> Node a

-- | Set the node's content by its ID
setNode :: NodeId -> a -> Graph a b c -> Graph a b c

-- | Mark a node by its ID
markNode :: NodeId -> Graph a b c -> Graph a b c

-- | Follow an edge by its source node and label
followEdge :: Eq b => NodeId -> b -> Graph a b c -> Maybe NodeId

-- | Query an edge's content
queryEdge :: Eq b => NodeId -> b -> Graph a b c -> Maybe c

-- | List all edges from the given node
listEdges :: NodeId -> Graph a b c -> [(b, c, NodeId)]
instance [safe] Eq NodeId
instance [safe] Show NodeId
instance [safe] Ord NodeId
instance [safe] None (Graph a b c)
instance [safe] Show b => Show (Edge b c)
instance [safe] Show a => Show (Node a)
instance [safe] Indexable (Node a) NodeId (Node a)


-- | Provides a variable-storing monad and functions for access
module Data.Chatty.Atoms

-- | Phantom type for atom IDs
data Atom a
Atom :: Int -> Atom a
FunAtom :: Int -> (Atom b) -> (b -> a) -> (b -> a -> b) -> Atom a
FunAtom2 :: Int -> (Atom b) -> (Atom c) -> ((b, c) -> a) -> ((b, c) -> a -> (b, c)) -> Atom a
newtype Container
Container :: () -> Container

-- | The storage monad
newtype AtomStoreT m a
AtomStore :: (AVL (Int, Container) -> m (a, AVL (Int, Container))) -> AtomStoreT m a
runAtomStoreT :: AtomStoreT m a -> AVL (Int, Container) -> m (a, AVL (Int, Container))

-- | Typeclass for all atom-storing monads.
class ChCounter m => ChAtoms m where newAtom = liftM Atom countOn funAtom b r p = do { i <- countOn; return $ FunAtom i b r p } funAtom2 b c r p = do { i <- countOn; return $ FunAtom2 i b c r p } cloneAtom a = do { b <- newAtom; v <- getAtom a; putAtom b v; return b }
newAtom :: ChAtoms m => m (Atom v)
funAtom :: ChAtoms m => Atom b -> (b -> a) -> (b -> a -> b) -> m (Atom a)
funAtom2 :: ChAtoms m => Atom b -> Atom c -> ((b, c) -> a) -> ((b, c) -> a -> (b, c)) -> m (Atom a)
putAtom :: ChAtoms m => Atom v -> v -> m ()
getAtom :: ChAtoms m => Atom v -> m v
dispAtom :: ChAtoms m => Atom v -> m ()
cloneAtom :: ChAtoms m => Atom v -> m (Atom v)

-- | Run a pure function on atoms.
mapAtom :: ChAtoms m => (a -> a) -> Atom a -> m ()

-- | Arrow type operating on atoms. Works by cloning the educt, then
--   overwriting the clone. You shouldn't use this inside long-term
--   environments, as massive usage blows up the memory.
newtype Redundant m a b
Redundant :: (Atom a -> m (Atom b)) -> Redundant m a b
runRedundant :: Redundant m a b -> Atom a -> m (Atom b)
instance ChAtoms m => Arrow (Redundant m)
instance ChAtoms m => Category (Redundant m)
instance ChCounter m => ChAtoms (AtomStoreT m)
instance ChCounter m => ChCounter (AtomStoreT m)
instance MonadIO m => MonadIO (AtomStoreT m)
instance MonadTrans AtomStoreT
instance Monad m => Monad (AtomStoreT m)
instance (Functor m, Monad m) => Applicative (AtomStoreT m)
instance Functor m => Functor (AtomStoreT m)
instance Ord (Atom a)
instance Eq (Atom a)
