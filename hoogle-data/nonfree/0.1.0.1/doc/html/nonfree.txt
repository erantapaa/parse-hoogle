-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Free structures sans laws
--   
@package nonfree
@version 0.1.0.1


-- | A free "monoid sans laws" type (i.e., a "free pointed magma") with an
--   illegal <a>Monoid</a> instance, intended for debugging.
--   
--   An example use: We can see that the <a>Foldable</a> instance for
--   Data.Map in <tt>containers-0.5.0.0</tt> generates a lot of
--   <a>mempty</a>s (one per leaf):
--   
--   <pre>
--   &gt; <a>foldMap</a> <a>N</a> (M.fromList [(x,x) | x &lt;- [1..5]])
--   (((ε ◇ N 1) ◇ ε) ◇ N 2) ◇ ((((ε ◇ N 3) ◇ ε) ◇ N 4) ◇ ((ε ◇ N 5) ◇ ε))
--   </pre>
--   
--   After a discussion with the maintainer, this is improved in
--   <tt>containers-0.5.5.1</tt>:
--   
--   <pre>
--   &gt; <a>foldMap</a> <a>N</a> (M.fromList [(x,x) | x &lt;- [1..5]])
--   (N 1 ◇ (N 2 ◇ N 3)) ◇ (N 4 ◇ N 5)
--   </pre>
--   
--   But now we can see a discrepancy between the <a>Foldable</a> and
--   <a>Traversable</a> instances:
--   
--   <pre>
--   &gt; <a>foldMapDefault</a> <a>N</a> (M.fromList [(x,x) | x &lt;- [1..5]])
--   (((N 1 ◇ N 2) ◇ N 3) ◇ N 4) ◇ N 5
--   </pre>
--   
--   This is because an expression like <tt>f <a>&lt;$&gt;</a> x
--   <a>&lt;*&gt;</a> y <a>&lt;*&gt;</a> z</tt> generates a left-biased
--   tree -- <tt>(x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> -- whereas
--   the <a>Foldable</a> instance makes a right-biased tree -- <tt>x
--   <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z)</tt>.
--   
--   Due to the monoid laws, these sorts of issues are typically invisible
--   unless you look for them. But they can make a performance difference.
module Data.Monoid.Nonfree

-- | Nonfree nonmonoid.
data N a
N :: a -> N a
NEmpty :: N a
NAppend :: (N a) -> (N a) -> N a

-- | A synonym for <a>mappend</a> (<a>&lt;&gt;</a>).
(◇) :: Monoid m => m -> m -> m

-- | A synonym for <a>mempty</a>.
ε :: Monoid m => m

-- | A version of <a>toList</a> that extracts the full monoid append tree
--   rather than flattening it to a list.
toN :: Foldable t => t a -> N a

-- | Given a monoid append tree and a <a>Traversable</a> structure with
--   exactly the same shape, put values from the former into the latter.
--   This will fail with an error if the structure isn't identical.
fromN :: Traversable t => N b -> t a -> t b
instance Applicative (FromN e)
instance Functor (FromN e)
instance Show a => Show (N a)
instance Foldable N
instance Functor N
instance Traversable N
instance Monoid (N a)
