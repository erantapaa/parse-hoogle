-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An experimental alternative hierarchy of numeric type classes
--   
@package numeric-prelude
@version 0.4.2


-- | <ul>
--   <li>** Seems to be a candidate for Algebra directory.
--   Algebra.PermutationGroup ?</li>
--   </ul>
module MathObj.Permutation

-- | There are quite a few way we could represent elements of permutation
--   groups: the images in a row, a list of the cycles, et.c. All of these
--   differ highly in how complex various operations end up being.
class C p
domain :: (C p, Ix i) => p i -> (i, i)
apply :: (C p, Ix i) => p i -> i -> i
inverse :: (C p, Ix i) => p i -> p i


-- | An alternative type class for Ord which allows an ordering for
--   dictionaries like <a>Data.Map</a> and <a>Data.Set</a> independently
--   from the ordering with respect to a magnitude.
module Algebra.Indexable

-- | Definition of an alternative ordering of objects independent from a
--   notion of magnitude. For an application see
--   <a>MathObj.PartialFraction</a>.
class Eq a => C a
compare :: C a => a -> a -> Ordering

-- | If the type has already an <a>Ord</a> instance it is certainly the
--   most easiest to define <a>compare</a> to be equal to <tt>Ord</tt>'s
--   <a>compare</a>.
ordCompare :: Ord a => a -> a -> Ordering

-- | Lift <a>compare</a> implementation from a wrapped object.
liftCompare :: C b => (a -> b) -> a -> a -> Ordering

-- | Wrap an indexable object such that it can be used in <a>Data.Map</a>
--   and <a>Data.Set</a>.
data ToOrd a
toOrd :: a -> ToOrd a
fromOrd :: ToOrd a -> a
instance Eq a => Eq (ToOrd a)
instance Show a => Show (ToOrd a)
instance C a => Ord (ToOrd a)
instance C Integer
instance C a => C [a]
instance (C a, C b) => C (a, b)


-- | We already have the dynamically checked physical units provided by
--   <a>Number.Physical</a> and the statically checked ones of the
--   <tt>dimensional</tt> package of Buckwalter, which require
--   multi-parameter type classes with functional dependencies.
--   
--   Here we provide a poor man's approach: The units are presented by type
--   terms. There is no canonical form and thus the type checker can not
--   automatically check for equal units. However, if two unit terms
--   represent the same unit, then you can tell the type checker to rewrite
--   one into the other.
--   
--   You can add more dimensions by introducing more types of class
--   <a>C</a>.
--   
--   This approach is not entirely safe because you can write your own
--   flawed rewrite rules. It is however more safe than with no units at
--   all.
module Algebra.DimensionTerm
class Show a => C a
noValue :: C a => a
data Scalar
Scalar :: Scalar
data Mul a b
Mul :: Mul a b
data Recip a
Recip :: Recip a
type Sqr a = Mul a a
appPrec :: Int
scalar :: Scalar
mul :: (C a, C b) => a -> b -> Mul a b
recip :: C a => a -> Recip a
(%*%) :: (C a, C b) => a -> b -> Mul a b
(%/%) :: (C a, C b) => a -> b -> Mul a (Recip b)
applyLeftMul :: (C u0, C u1, C v) => (u0 -> u1) -> Mul u0 v -> Mul u1 v
applyRightMul :: (C u0, C u1, C v) => (u0 -> u1) -> Mul v u0 -> Mul v u1
applyRecip :: (C u0, C u1) => (u0 -> u1) -> Recip u0 -> Recip u1
commute :: (C u0, C u1) => Mul u0 u1 -> Mul u1 u0
associateLeft :: (C u0, C u1, C u2) => Mul u0 (Mul u1 u2) -> Mul (Mul u0 u1) u2
associateRight :: (C u0, C u1, C u2) => Mul (Mul u0 u1) u2 -> Mul u0 (Mul u1 u2)
recipMul :: (C u0, C u1) => Recip (Mul u0 u1) -> Mul (Recip u0) (Recip u1)
mulRecip :: (C u0, C u1) => Mul (Recip u0) (Recip u1) -> Recip (Mul u0 u1)
identityLeft :: C u => Mul Scalar u -> u
identityRight :: C u => Mul u Scalar -> u
cancelLeft :: C u => Mul (Recip u) u -> Scalar
cancelRight :: C u => Mul u (Recip u) -> Scalar
invertRecip :: C u => Recip (Recip u) -> u
doubleRecip :: C u => u -> Recip (Recip u)
recipScalar :: Recip Scalar -> Scalar

-- | This class allows defining instances that are exclusively for
--   <a>Scalar</a> dimension. You won't want to define instances by
--   yourself.
class C dim => IsScalar dim
toScalar :: IsScalar dim => dim -> Scalar
fromScalar :: IsScalar dim => Scalar -> dim
data Length
Length :: Length
data Time
Time :: Time
data Mass
Mass :: Mass
data Charge
Charge :: Charge
data Angle
Angle :: Angle
data Temperature
Temperature :: Temperature
data Information
Information :: Information
length :: Length
time :: Time
mass :: Mass
charge :: Charge
angle :: Angle
temperature :: Temperature
information :: Information
type Frequency = Recip Time
frequency :: Frequency
data Voltage
Voltage :: Voltage
type VoltageAnalytical = Mul (Mul (Sqr Length) Mass) (Recip (Mul (Sqr Time) Charge))
voltage :: Voltage
unpackVoltage :: Voltage -> VoltageAnalytical
packVoltage :: VoltageAnalytical -> Voltage
instance C Voltage
instance Show Voltage
instance C Information
instance C Temperature
instance C Angle
instance C Charge
instance C Mass
instance C Time
instance C Length
instance Show Information
instance Show Temperature
instance Show Angle
instance Show Charge
instance Show Mass
instance Show Time
instance Show Length
instance IsScalar Scalar
instance C a => C (Recip a)
instance (C a, C b) => C (Mul a b)
instance C Scalar
instance Show a => Show (Recip a)
instance (Show a, Show b) => Show (Mul a b)
instance Show Scalar

module NumericPrelude.Elementwise

-- | A reader monad for the special purpose of defining instances of
--   certain operations on tuples and records. It does not add any new
--   functionality to the common Reader monad, but it restricts the
--   functions to the required ones and exports them from one module. That
--   is you do not have to import both Control.Monad.Trans.Reader and
--   Control.Applicative. The type also tells the user, for what the Reader
--   monad is used. We can more easily replace or extend the implementation
--   when needed.
newtype T v a
Cons :: (v -> a) -> T v a
run :: T v a -> v -> a
with :: a -> T v a
element :: (v -> a) -> T v a
run2 :: T (x, y) a -> x -> y -> a
run3 :: T (x, y, z) a -> x -> y -> z -> a
run4 :: T (x, y, z, w) a -> x -> y -> z -> w -> a
run5 :: T (x, y, z, u, w) a -> x -> y -> z -> u -> w -> a
instance Applicative (T v)
instance Functor (T v)


-- | Define common properties that can be used e.g. for automated tests.
--   Cf. to <a>Test.QuickCheck.Utils</a>.
module Algebra.Laws
commutative :: Eq a => (b -> b -> a) -> b -> b -> Bool
associative :: Eq a => (a -> a -> a) -> a -> a -> a -> Bool
leftIdentity :: Eq a => (b -> a -> a) -> b -> a -> Bool
rightIdentity :: Eq a => (a -> b -> a) -> b -> a -> Bool
identity :: Eq a => (a -> a -> a) -> a -> a -> Bool
leftZero :: Eq a => (a -> a -> a) -> a -> a -> Bool
rightZero :: Eq a => (a -> a -> a) -> a -> a -> Bool
zero :: Eq a => (a -> a -> a) -> a -> a -> Bool
leftInverse :: Eq a => (b -> b -> a) -> (b -> b) -> a -> b -> Bool
rightInverse :: Eq a => (b -> b -> a) -> (b -> b) -> a -> b -> Bool
inverse :: Eq a => (b -> b -> a) -> (b -> b) -> a -> b -> Bool
leftDistributive :: Eq a => (a -> b -> a) -> (a -> a -> a) -> b -> a -> a -> Bool
rightDistributive :: Eq a => (b -> a -> a) -> (a -> a -> a) -> b -> a -> a -> Bool
homomorphism :: Eq a => (b -> a) -> (b -> b -> b) -> (a -> a -> a) -> b -> b -> Bool
rightCascade :: Eq a => (b -> b -> b) -> (a -> b -> a) -> a -> b -> b -> Bool
leftCascade :: Eq a => (b -> b -> b) -> (b -> a -> a) -> a -> b -> b -> Bool


-- | The only point of this module is to reexport items that we want from
--   the standard Prelude.
module NumericPrelude.Base

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

-- | Strict (call-by-value) application, defined in terms of <a>seq</a>.
($!) :: (a -> b) -> a -> b

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
data Bool :: *
False :: Bool
True :: Bool

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
data Either a b :: * -> * -> *
Left :: a -> Either a b
Right :: b -> Either a b

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Minimal complete definition: <a>&gt;&gt;=</a> and <a>return</a>.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <pre>
--   return a &gt;&gt;= k  ==  k a
--   m &gt;&gt;= return  ==  m
--   m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  ==  (m &gt;&gt;= k) &gt;&gt;= h
--   </pre>
--   
--   Instances of both <a>Monad</a> and <a>Functor</a> should additionally
--   satisfy the law:
--   
--   <pre>
--   fmap f xs  ==  xs &gt;&gt;= return . f
--   </pre>
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Monad (m :: * -> *)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Parsing of <a>String</a>s, producing values.
--   
--   Minimal complete definition: <a>readsPrec</a> (or, for GHC only,
--   <a>readPrec</a>)
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Conversion of values to readable <a>String</a>s.
--   
--   Minimal complete definition: <a>showsPrec</a> or <a>show</a>.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
all :: (a -> Bool) -> [a] -> Bool

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
and :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
any :: (a -> Bool) -> [a] -> Bool

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | Concatenate a list of lists.
concat :: [[a]] -> [a]

-- | Map a function over a list and concatenate the results.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | Constant function.
const :: a -> b -> a

-- | <a>curry</a> converts an uncurried function to a curried function.
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
elem :: Eq a => a -> [a] -> Bool

-- | <a>error</a> stops execution and displays an error message.
error :: [Char] -> a

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
flip :: (a -> b -> c) -> b -> a -> c

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
foldl :: (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldl1 :: (a -> a -> a) -> [a] -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldr1 :: (a -> a -> a) -> [a] -> a

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Identity function.
id :: a -> a

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
length :: [a] -> Int

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
lines :: String -> [String]

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <tt><a>mapM</a> f</tt> is equivalent to <tt><a>sequence</a> .
--   <a>map</a> f</tt>.
mapM :: Monad m => (a -> m b) -> [a] -> m [b]

-- | <tt><a>mapM_</a> f</tt> is equivalent to <tt><a>sequence_</a> .
--   <a>map</a> f</tt>.
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
maximum :: Ord a => [a] -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
maybe :: b -> (a -> b) -> Maybe a -> b

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
minimum :: Ord a => [a] -> a

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
or :: [Bool] -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process.
read :: Read a => String -> a

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | Evaluates its first argument to head normal form, and then returns its
--   second argument as the result.
seq :: a -> b -> b

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | Evaluate each action in the sequence from left to right, and ignore
--   the results.
sequence_ :: Monad m => [m a] -> m ()

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>uncurry</a> converts a curried function to a function on pairs.
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: a

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [String] -> String

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <a>fail</a> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   If one input list is short, excess elements of the longer list are
--   discarded.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
catch :: IO a -> (IOError -> IO a) -> IO a

-- | The same as <a>if'</a>, but the name is chosen such that it can be
--   used for GHC-7.0's rebindable if-then-else syntax.
ifThenElse :: Bool -> a -> a -> a


module MathObj.Permutation.Table
type T i = Array i i
fromFunction :: Ix i => (i, i) -> (i -> i) -> T i
toFunction :: Ix i => T i -> (i -> i)
fromPermutation :: (Ix i, C p) => p i -> T i
fromCycles :: Ix i => (i, i) -> [[i]] -> T i
identity :: Ix i => (i, i) -> T i
cycle :: Ix i => [i] -> T i -> T i
inverse :: Ix i => T i -> T i
compose :: Ix i => T i -> T i -> T i

-- | Extremely naïve algorithm to generate a list of all elements in a
--   group. Should be replaced by a Schreier-Sims system if this code is
--   ever used for anything bigger than .. say .. groups of order 512 or
--   so.
choose :: Set a -> Maybe (a, Set a)
closure :: Ix i => [T i] -> [T i]
closureSlow :: Ix i => [T i] -> [T i]

module Algebra.Additive

-- | Additive a encapsulates the notion of a commutative group, specified
--   by the following laws:
--   
--   <pre>
--          a + b === b + a
--    (a + b) + c === a + (b + c)
--       zero + a === a
--   a + negate a === 0
--   </pre>
--   
--   Typical examples include integers, dollars, and vectors.
--   
--   Minimal definition: <a>+</a>, <a>zero</a>, and (<a>negate</a> or
--   '(-)')
class C a where negate a = zero - a a - b = a + negate b
zero :: C a => a
(+, -) :: C a => a -> a -> a
negate :: C a => a -> a

-- | <a>subtract</a> is <tt>(-)</tt> with swapped operand order. This is
--   the operand order which will be needed in most cases of partial
--   application.
subtract :: C a => a -> a -> a

-- | Sum up all elements of a list. An empty list yields zero.
--   
--   This function is inappropriate for number types like Peano. Maybe we
--   should make <a>sum</a> a method of Additive. This would also make
--   <tt>lengthLeft</tt> and <tt>lengthRight</tt> superfluous.
sum :: C a => [a] -> a

-- | Sum up all elements of a non-empty list. This avoids including a zero
--   which is useful for types where no universal zero is available.
sum1 :: C a => [a] -> a

-- | Sum the operands in an order, such that the dependencies are
--   minimized. Does this have a measurably effect on speed?
--   
--   Requires associativity.
sumNestedAssociative :: C a => [a] -> a
sumNestedCommutative :: C a => [a] -> a

-- | Instead of baking the add operation into the element function, we
--   could use higher rank types and pass a generic <tt>uncurry (+)</tt> to
--   the run function. We do not do so in order to stay Haskell 98 at least
--   for parts of NumericPrelude.
elementAdd :: C x => (v -> x) -> T (v, v) x
elementSub :: C x => (v -> x) -> T (v, v) x
elementNeg :: C x => (v -> x) -> T v x

-- | <pre>
--   addPair :: (Additive.C a, Additive.C b) =&gt; (a,b) -&gt; (a,b) -&gt; (a,b)
--   addPair = Elem.run2 $ Elem.with (,) &lt;*&gt;.+  fst &lt;*&gt;.+  snd
--   </pre>
(<*>.+) :: C x => T (v, v) (x -> a) -> (v -> x) -> T (v, v) a
(<*>.-) :: C x => T (v, v) (x -> a) -> (v -> x) -> T (v, v) a
(<*>.-$) :: C x => T v (x -> a) -> (v -> x) -> T v a
propAssociative :: (Eq a, C a) => a -> a -> a -> Bool
propCommutative :: (Eq a, C a) => a -> a -> Bool
propIdentity :: (Eq a, C a) => a -> Bool
propInverse :: (Eq a, C a) => a -> Bool
instance RealFloat a => C (Complex a)
instance Integral a => C (Ratio a)
instance C v => C (b -> v)
instance C v => C [v]
instance (C v0, C v1, C v2) => C (v0, v1, v2)
instance (C v0, C v1) => C (v0, v1)
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Double
instance C Float
instance C Integer

module Algebra.ZeroTestable

-- | Maybe the naming should be according to Algebra.Unit: Algebra.Zero as
--   module name, and <tt>query</tt> as method name.
class C a
isZero :: C a => a -> Bool

-- | Checks if a number is the zero element. This test is not possible for
--   all <a>C</a> types, since e.g. a function type does not belong to Eq.
--   isZero is possible for some types where (==zero) fails because there
--   is no unique zero. Examples are vector (the length of the zero vector
--   is unknown), physical values (the unit of a zero quantity is unknown),
--   residue class (the modulus is unknown).
defltIsZero :: (Eq a, C a) => a -> Bool
instance C v => C [v]
instance (C v0, C v1, C v2) => C (v0, v1, v2)
instance (C v0, C v1) => C (v0, v1)
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Double
instance C Float
instance C Integer

module Algebra.Ring

-- | Ring encapsulates the mathematical structure of a (not necessarily
--   commutative) ring, with the laws
--   
--   <pre>
--   a * (b * c) === (a * b) * c
--       one * a === a
--       a * one === a
--   a * (b + c) === a * b + a * c
--   </pre>
--   
--   Typical examples include integers, polynomials, matrices, and
--   quaternions.
--   
--   Minimal definition: <a>*</a>, (<a>one</a> or <a>fromInteger</a>)
class C a => C a where fromInteger n = if n < 0 then powerAssociative (+) zero (negate one) (negate n) else powerAssociative (+) zero one n a ^ n = if n >= zero then powerAssociative (*) one a n else error "(^): Illegal negative exponent" one = fromInteger 1
(*) :: C a => a -> a -> a
one :: C a => a
fromInteger :: C a => Integer -> a
(^) :: C a => a -> Integer -> a
sqr :: C a => a -> a
product :: C a => [a] -> a
product1 :: C a => [a] -> a
scalarProduct :: C a => [a] -> [a] -> a
propAssociative :: (Eq a, C a) => a -> a -> a -> Bool
propLeftDistributive :: (Eq a, C a) => a -> a -> a -> Bool
propRightDistributive :: (Eq a, C a) => a -> a -> a -> Bool
propLeftIdentity :: (Eq a, C a) => a -> Bool
propRightIdentity :: (Eq a, C a) => a -> Bool
propPowerCascade :: (Eq a, C a) => a -> Integer -> Integer -> Property
propPowerProduct :: (Eq a, C a) => a -> Integer -> Integer -> Property
propPowerDistributive :: (Eq a, C a) => Integer -> a -> a -> Property

-- | Commutativity need not be satisfied by all instances of <a>C</a>.
propCommutative :: (Eq a, C a) => a -> a -> Bool
instance RealFloat a => C (Complex a)
instance Integral a => C (Ratio a)
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Double
instance C Float
instance C Integer

module Algebra.Differential

-- | <a>differentiate</a> is a general differentation operation It must
--   fulfill the Leibnitz condition
--   
--   <pre>
--   differentiate (x * y) == differentiate x * y + x * differentiate y
--   </pre>
--   
--   Unfortunately, this scheme cannot be easily extended to more than two
--   variables, e.g. <a>MathObj.PowerSeries2</a>.
class C a => C a
differentiate :: C a => a -> a

module Algebra.IntegralDomain

-- | <tt>IntegralDomain</tt> corresponds to a commutative ring, where <tt>a
--   <a>mod</a> b</tt> picks a canonical element of the equivalence class
--   of <tt>a</tt> in the ideal generated by <tt>b</tt>. <a>div</a> and
--   <a>mod</a> satisfy the laws
--   
--   <pre>
--                           a * b === b * a
--   (a `div` b) * b + (a `mod` b) === a
--                 (a+k*b) `mod` b === a `mod` b
--                       0 `mod` b === 0
--   </pre>
--   
--   Typical examples of <tt>IntegralDomain</tt> include integers and
--   polynomials over a field. Note that for a field, there is a canonical
--   instance defined by the above rules; e.g.,
--   
--   <pre>
--   instance IntegralDomain.C Rational where
--       divMod a b =
--          if isZero b
--            then (undefined,a)
--            else (a\/b,0)
--   </pre>
--   
--   It shall be noted, that <a>div</a>, <a>mod</a>, <a>divMod</a> have a
--   parameter order which is unfortunate for partial application. But it
--   is adapted to mathematical conventions, where the operators are used
--   in infix notation.
--   
--   Minimal definition: <a>divMod</a> or (<a>div</a> and <a>mod</a>)
class C a => C a where div a b = fst (divMod a b) mod a b = snd (divMod a b) divMod a b = (div a b, mod a b)
div, mod :: C a => a -> a -> a
divMod :: C a => a -> a -> (a, a)

-- | Allows division by zero. If the divisor is zero, then the dividend is
--   returned as remainder.
divModZero :: (C a, C a) => a -> a -> (a, a)
divides :: (C a, C a) => a -> a -> Bool
sameResidueClass :: (C a, C a) => a -> a -> a -> Bool

-- | Returns the result of the division, if divisible. Otherwise undefined.
divChecked :: (C a, C a) => a -> a -> a

-- | Returns the result of the division, if divisible. Otherwise undefined.

-- | <i>Deprecated: use divChecked instead</i>
safeDiv :: (C a, C a) => a -> a -> a
even :: (C a, C a) => a -> Bool
odd :: (C a, C a) => a -> Bool

-- | <tt>divUp n m</tt> is similar to <tt>div</tt> but it rounds up the
--   quotient, such that <tt>divUp n m * m = roundUp n m</tt>.
divUp :: C a => a -> a -> a

-- | <tt>roundDown n m</tt> rounds <tt>n</tt> down to the next multiple of
--   <tt>m</tt>. That is, <tt>roundDown n m</tt> is the greatest multiple
--   of <tt>m</tt> that is at most <tt>n</tt>. The parameter order is
--   consistent with <tt>div</tt> and friends, but maybe not useful for
--   partial application.
roundDown :: C a => a -> a -> a

-- | <tt>roundUp n m</tt> rounds <tt>n</tt> up to the next multiple of
--   <tt>m</tt>. That is, <tt>roundUp n m</tt> is the greatest multiple of
--   <tt>m</tt> that is at most <tt>n</tt>.
roundUp :: C a => a -> a -> a

-- | <tt>decomposeVarPositional [b0,b1,b2,...] x</tt> decomposes <tt>x</tt>
--   into a positional representation with mixed bases <tt>x0 + b0*(x1 +
--   b1*(x2 + b2*x3))</tt> E.g. <tt>decomposeVarPositional (repeat 10) 123
--   == [3,2,1]</tt>
decomposeVarPositional :: (C a, C a) => [a] -> a -> [a]
decomposeVarPositionalInf :: C a => [a] -> a -> [a]
propInverse :: (Eq a, C a, C a) => a -> a -> Property
propMultipleDiv :: (Eq a, C a, C a) => a -> a -> Property
propMultipleMod :: (Eq a, C a, C a) => a -> a -> Property
propProjectAddition :: (Eq a, C a, C a) => a -> a -> a -> Property
propProjectMultiplication :: (Eq a, C a, C a) => a -> a -> a -> Property
propUniqueRepresentative :: (Eq a, C a, C a) => a -> a -> a -> Property
propZeroRepresentative :: (Eq a, C a, C a) => a -> Property
propSameResidueClass :: (Eq a, C a, C a) => a -> a -> a -> Property
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Integer


-- | Will be used in order to generate type classes for generic algebras.
--   An algebra is a vector space that also is a monoid. Should we use the
--   Monoid class from base library despite its unfortunate method name
--   <tt>mappend</tt>?
module Algebra.Monoid

-- | We expect a monoid to adher to associativity and the identity behaving
--   decently. Nothing more, really.
class C a where cumulate = foldr (<*>) idt
idt :: C a => a
(<*>) :: C a => a -> a -> a
cumulate :: C a => [a] -> a
instance C a => C (Sum a)
instance C a => C (Product a)
instance C (Last a)
instance C (First a)
instance C (Endo a)
instance C a => C (Dual a)
instance C Any
instance C All


-- | A type class for non-negative numbers. Prominent instances are
--   <a>T</a> and <a>T</a> numbers. This class cannot do any checks, but it
--   let you show to the user what arguments your function expects. Thus
--   you must define class instances with care. In fact many standard
--   functions (<a>take</a>, '(!!)', ...) should have this type class
--   constraint.
module Algebra.NonNegative

-- | Instances of this class must ensure non-negative values. We cannot
--   enforce this by types, but the type class constraint
--   <tt>NonNegative.C</tt> avoids accidental usage of types which allow
--   for negative numbers.
--   
--   The Monoid superclass contributes a zero and an addition.
class (Ord a, C a) => C a
split :: C a => a -> a -> (a, (Bool, a))

-- | Default implementation for wrapped types of <a>Ord</a> and <a>Num</a>
--   class.
splitDefault :: (Ord b, C b) => (a -> b) -> (b -> a) -> a -> a -> (a, (Bool, a))

-- | <pre>
--   x -| y == max 0 (x-y)
--   </pre>
--   
--   The default implementation is not efficient, because it compares the
--   values and then subtracts, again, if safe. <tt>max 0 (x-y)</tt> is
--   more elegant and efficient but not possible in the general case, since
--   <tt>x-y</tt> may already yield a negative number.
(-|) :: C a => a -> a -> a
zero :: C a => a
add :: C a => a -> a -> a
sum :: C a => [a] -> a

module Algebra.Units

-- | This class lets us deal with the units in a ring. <a>isUnit</a> tells
--   whether an element is a unit. The other operations let us canonically
--   write an element as a unit times another element. Two elements a, b of
--   a ring R are _associates_ if a=b*u for a unit u. For an element a, we
--   want to write it as a=b*u where b is an associate of a. The map
--   (a-&gt;b) is called <a>StandardAssociate</a> by Gap, "unitCanonical"
--   by Axiom, and "canAssoc" by DoCon. The map (a-&gt;u) is called
--   "canInv" by DoCon and "unitNormal(x).unit" by Axiom.
--   
--   The laws are
--   
--   <pre>
--    stdAssociate x * stdUnit x === x
--      stdUnit x * stdUnitInv x === 1
--   isUnit u ==&gt; stdAssociate x === stdAssociate (x*u)
--   </pre>
--   
--   Currently some algorithms assume
--   
--   <pre>
--   stdAssociate(x*y) === stdAssociate x * stdAssociate y
--   </pre>
--   
--   Minimal definition: <a>isUnit</a> and (<a>stdUnit</a> or
--   <a>stdUnitInv</a>) and optionally <a>stdAssociate</a>
class C a => C a where stdAssociate x = x * stdUnitInv x stdUnit x = div one (stdUnitInv x) stdUnitInv x = div one (stdUnit x)
isUnit :: C a => a -> Bool
stdAssociate, stdUnitInv, stdUnit :: C a => a -> a
intQuery :: (Integral a, C a) => a -> Bool
intAssociate :: (Integral a, C a, C a) => a -> a
intStandard :: (Integral a, C a, C a) => a -> a
intStandardInverse :: (Integral a, C a, C a) => a -> a
propComposition :: (Eq a, C a) => a -> Bool
propInverseUnit :: (Eq a, C a) => a -> Bool
propUniqueAssociate :: (Eq a, C a) => a -> a -> Property

-- | Currently some algorithms assume this property.
propAssociateProduct :: (Eq a, C a) => a -> a -> Bool
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Integer
instance C Int

module Algebra.PrincipalIdealDomain

-- | A principal ideal domain is a ring in which every ideal (the set of
--   multiples of some generating set of elements) is principal: That is,
--   every element can be written as the multiple of some generating
--   element. <tt>gcd a b</tt> gives a generator for the ideal generated by
--   <tt>a</tt> and <tt>b</tt>. The algorithm above works whenever <tt>mod
--   x y</tt> is smaller (in a suitable sense) than both <tt>x</tt> and
--   <tt>y</tt>; otherwise the algorithm may run forever.
--   
--   Laws:
--   
--   <pre>
--   divides x (lcm x y)
--   x `gcd` (y `gcd` z) == (x `gcd` y) `gcd` z
--   gcd x y * z == gcd (x*z) (y*z)
--   gcd x y * lcm x y == x * y
--   </pre>
--   
--   (etc: canonical)
--   
--   Minimal definition: * nothing, if the standard Euclidean algorithm
--   work * if <a>extendedGCD</a> is implemented customly, <a>gcd</a> and
--   <a>lcm</a> make use of it
class (C a, C a) => C a where extendedGCD = extendedEuclid divMod gcd x y = fst $ extendedGCD x y lcm x y = if isZero x then x else divChecked x (gcd x y) * y
extendedGCD :: C a => a -> a -> (a, (a, a))
gcd :: C a => a -> a -> a
lcm :: C a => a -> a -> a
coprime :: C a => a -> a -> Bool
euclid :: (C a, C a) => (a -> a -> a) -> a -> a -> a
extendedEuclid :: (C a, C a) => (a -> a -> (a, a)) -> a -> a -> (a, (a, a))

-- | Compute the greatest common divisor for multiple numbers by repeated
--   application of the two-operand-gcd.
extendedGCDMulti :: C a => [a] -> (a, [a])

-- | A variant with small coefficients.
--   
--   <tt>Just (a,b) = diophantine z x y</tt> means <tt>a*x+b*y = z</tt>. It
--   is required that <tt>gcd(y,z) <a>divides</a> x</tt>.
diophantine :: C a => a -> a -> a -> Maybe (a, a)

-- | Like <a>diophantine</a>, but <tt>a</tt> is minimal with respect to the
--   measure function of the Euclidean algorithm.
diophantineMin :: C a => a -> a -> a -> Maybe (a, a)
diophantineMulti :: C a => a -> [a] -> Maybe [a]

-- | Not efficient enough, because GCD/LCM is computed twice.
chineseRemainder :: C a => (a, a) -> (a, a) -> Maybe (a, a)

-- | For <tt>Just (b,n) = chineseRemainder [(a0,m0), (a1,m1), ...,
--   (an,mn)]</tt> and all <tt>x</tt> with <tt>x = b mod n</tt> the
--   congruences <tt>x=a0 mod m0, x=a1 mod m1, ..., x=an mod mn</tt> are
--   fulfilled.
chineseRemainderMulti :: C a => [(a, a)] -> Maybe (a, a)
propMaximalDivisor :: C a => a -> a -> a -> Property
propGCDDiophantine :: (Eq a, C a) => a -> a -> Bool
propExtendedGCDMulti :: (Eq a, C a) => [a] -> Bool
propDiophantine :: (Eq a, C a) => a -> a -> a -> a -> Bool
propDiophantineMin :: (Eq a, C a) => a -> a -> a -> a -> Bool
propDiophantineMulti :: (Eq a, C a) => [(a, a)] -> Bool
propDiophantineMultiMin :: (Eq a, C a) => [(a, a)] -> Bool
propChineseRemainder :: (Eq a, C a) => a -> a -> [a] -> Property
propDivisibleGCD :: C a => a -> a -> Bool
propDivisibleLCM :: C a => a -> a -> Bool
propGCDIdentity :: (Eq a, C a) => a -> Bool
propGCDCommutative :: (Eq a, C a) => a -> a -> Bool
propGCDAssociative :: (Eq a, C a) => a -> a -> a -> Bool
propGCDHomogeneous :: (Eq a, C a) => a -> a -> a -> Bool
propGCD_LCM :: (Eq a, C a) => a -> a -> Bool
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Integer

module MathObj.Monoid

-- | It is only a monoid for non-negative numbers.
--   
--   <pre>
--   idt &lt;*&gt; GCD (-2) = GCD 2
--   </pre>
--   
--   Thus, use this Monoid only for non-negative numbers!
newtype GCD a
GCD :: a -> GCD a
runGCD :: GCD a -> a
newtype LCM a
LCM :: a -> LCM a
runLCM :: LCM a -> a

-- | <tt>Nothing</tt> is the largest element.
newtype Min a
Min :: Maybe a -> Min a
runMin :: Min a -> Maybe a

-- | <tt>Nothing</tt> is the smallest element.
newtype Max a
Max :: Maybe a -> Max a
runMax :: Max a -> Maybe a
instance Show a => Show (GCD a)
instance Eq a => Eq (GCD a)
instance Show a => Show (LCM a)
instance Eq a => Eq (LCM a)
instance Show a => Show (Min a)
instance Eq a => Eq (Min a)
instance Show a => Show (Max a)
instance Eq a => Eq (Max a)
instance Ord a => C (Max a)
instance Ord a => C (Min a)
instance C a => C (LCM a)
instance C a => C (GCD a)

module Algebra.RightModule
class (C a, C b) => C a b
(<*) :: C a b => b -> a -> b


-- | Abstraction of vectors
module Algebra.Vector

-- | A Module over a ring satisfies:
--   
--   <pre>
--   a *&gt; (b + c) === a *&gt; b + a *&gt; c
--   (a * b) *&gt; c === a *&gt; (b *&gt; c)
--   (a + b) *&gt; c === a *&gt; c + b *&gt; c
--   </pre>
class C v
zero :: (C v, C a) => v a
(<+>) :: (C v, C a) => v a -> v a -> v a
(*>) :: (C v, C a) => a -> v a -> v a

-- | We need a Haskell 98 type class which provides equality test for
--   Vector type constructors.
class Eq v
eq :: (Eq v, Eq a) => v a -> v a -> Bool
functorScale :: (Functor v, C a) => a -> v a -> v a

-- | Compute the linear combination of a list of vectors.
linearComb :: (C a, C v) => [a] -> [v a] -> v a
propCascade :: (C v, Eq v, C a, Eq a) => a -> a -> v a -> Bool
propRightDistributive :: (C v, Eq v, C a, Eq a) => a -> v a -> v a -> Bool
propLeftDistributive :: (C v, Eq v, C a, Eq a) => a -> a -> v a -> Bool
instance Eq []
instance C ((->) b)
instance C []


-- | The generic case of a k-algebra generated by a monoid.
module MathObj.Algebra
newtype T a b
Cons :: (Map a b) -> T a b
zipWith :: Ord a => (b -> b -> b) -> (T a b -> T a b -> T a b)
mulMonomial :: (C a, C b) => (a, b) -> (a, b) -> (a, b)
monomial :: a -> b -> (T a b)
instance (Eq a, Eq b) => Eq (T a b)
instance (Show a, Show b) => Show (T a b)
instance (Ord a, C a, C b) => C (T a b)
instance Ord a => C (T a)
instance (Ord a, C b) => C (T a b)
instance Functor (T a)

module Algebra.Absolute

-- | This is the type class of a ring with a notion of an absolute value,
--   satisfying the laws
--   
--   <pre>
--                        a * b === b * a
--   a /= 0  =&gt;  abs (signum a) === 1
--             abs a * signum a === a
--   </pre>
--   
--   Minimal definition: <a>abs</a>, <a>signum</a>.
--   
--   If the type is in the <a>Ord</a> class we expect <a>abs</a> =
--   <a>absOrd</a> and <a>signum</a> = <a>signumOrd</a> and we expect the
--   following laws to hold:
--   
--   <pre>
--      a + (max b c) === max (a+b) (a+c)
--   negate (max b c) === min (negate b) (negate c)
--      a * (max b c) === max (a*b) (a*c) where a &gt;= 0
--           absOrd a === max a (-a)
--   </pre>
--   
--   If the type is <tt>ZeroTestable</tt>, then it should hold
--   
--   <pre>
--   isZero a  ===  signum a == signum (negate a)
--   </pre>
--   
--   We do not require <a>Ord</a> as superclass since we also want to have
--   <a>Number.Complex</a> as instance. We also do not require
--   <tt>ZeroTestable</tt> as superclass, because we like to have
--   expressions of foreign languages to be instances (cf. embedded domain
--   specific language approach, EDSL), as well as function types.
--   
--   <a>abs</a> for complex numbers alone may have an inappropriate type,
--   because it does not reflect that the absolute value is a real number.
--   You might prefer <a>magnitude</a>. This type class is intended for
--   unifying algorithms that work for both real and complex numbers. Note
--   the similarity to <a>Algebra.Units</a>: <a>abs</a> plays the role of
--   <tt>stdAssociate</tt> and <a>signum</a> plays the role of
--   <tt>stdUnit</tt>.
--   
--   Actually, since <a>abs</a> can be defined using <a>max</a> and
--   <a>negate</a> we could relax the superclasses to <tt>Additive</tt> and
--   <a>Ord</a> if his class would only contain <a>signum</a>.
class C a => C a
abs :: C a => a -> a
signum :: C a => a -> a
absOrd :: (C a, Ord a) => a -> a
signumOrd :: (C a, Ord a) => a -> a
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Double
instance C Float
instance C Integer


-- | Ratios of mathematical objects.
module Number.Ratio
data T a
(:%) :: !a -> !a -> T a
numerator :: T a -> !a
denominator :: T a -> !a
(%) :: C a => a -> a -> T a
type Rational = T Integer
fromValue :: C a => a -> T a
recip :: (C a, C a) => T a -> T a
scale :: C a => a -> T a -> T a

-- | similar to <a>splitFraction</a>
split :: C a => T a -> (a, T a)

-- | This is an alternative show method that is more user-friendly but also
--   potentially more ambigious.
showsPrecAuto :: (Eq a, C a, Show a) => Int -> T a -> String -> String

-- | Necessary when mixing NumericPrelude.Numeric Rationals with Prelude98
--   Rationals
toRational98 :: Integral a => T a -> Ratio a
instance Eq a => Eq (T a)
instance Integral a => Fractional (T a)
instance Integral a => Num (T a)
instance (Random a, C a, C a) => Random (T a)
instance (Storable a, C a) => Storable (T a)
instance (Arbitrary a, C a, C a) => Arbitrary (T a)
instance (Show a, C a) => Show (T a)
instance (Read a, C a) => Read (T a)
instance (C a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => Ord (T a)
instance (C a, C a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)

module Algebra.Field

-- | Field again corresponds to a commutative ring. Division is partially
--   defined and satisfies
--   
--   <pre>
--   not (isZero b)  ==&gt;  (a * b) / b === a
--   not (isZero a)  ==&gt;  a * recip a === one
--   </pre>
--   
--   when it is defined. To safely call division, the program must take
--   type-specific action; e.g., the following is appropriate in many
--   cases:
--   
--   <pre>
--   safeRecip :: (Integral a, Eq a, Field.C a) =&gt; a -&gt; Maybe a
--   safeRecip x =
--       let (q,r) = one `divMod` x
--       in  toMaybe (isZero r) q
--   </pre>
--   
--   Typical examples include rationals, the real numbers, and rational
--   functions (ratios of polynomial functions). An instance should be
--   typically declared only if most elements are invertible.
--   
--   Actually, we have also used this type class for non-fields containing
--   lots of units, e.g. residue classes with respect to non-primes and
--   power series. So the restriction <tt>not (isZero a)</tt> must be
--   better <tt>isUnit a</tt>.
--   
--   Minimal definition: <a>recip</a> or (<a>/</a>)
class C a => C a where recip a = one / a a / b = a * recip b fromRational' r = fromInteger (numerator r) / fromInteger (denominator r) a ^- n = if n < zero then recip (a ^ (- n)) else a ^ n
(/) :: C a => a -> a -> a
recip :: C a => a -> a
fromRational' :: C a => Rational -> a
(^-) :: C a => a -> Integer -> a

-- | Needed to work around shortcomings in GHC.
fromRational :: C a => Rational -> a

-- | the restriction on the divisor should be <tt>isUnit a</tt> instead of
--   <tt>not (isZero a)</tt>
propDivision :: (Eq a, C a, C a) => a -> a -> Property
propReciprocal :: (Eq a, C a, C a) => a -> Property
instance RealFloat a => C (Complex a)
instance Integral a => C (Ratio a)
instance C a => C (T a)
instance C Double
instance C Float

module Algebra.ToRational

-- | This class allows lossless conversion from any representation of a
--   rational to the fixed <a>Rational</a> type. "Lossless" means - don't
--   do any rounding. For rounding see <a>Algebra.RealRing</a>. With the
--   instances for <a>Float</a> and <a>Double</a> we acknowledge that these
--   types actually represent rationals rather than (approximated) real
--   numbers. However, this contradicts to the <a>Transcendental</a> class.
--   
--   Laws that must be satisfied by instances:
--   
--   <pre>
--   fromRational' . toRational === id
--   </pre>
class (C a, C a, Ord a) => C a
toRational :: C a => a -> Rational

-- | It should hold
--   
--   <pre>
--   realToField = fromRational' . toRational
--   </pre>
--   
--   but it should be much more efficient for particular pairs of types,
--   such as converting <a>Float</a> to <a>Double</a>. This achieved by
--   optimizer rules.
realToField :: (C a, C b) => a -> b
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Double
instance C Float
instance C Integer


-- | Generally before using <a>quot</a> and <a>rem</a>, think twice. In
--   most cases <a>divMod</a> and friends are the right choice, because
--   they fulfill more of the wanted properties. On some systems
--   <a>quot</a> and <a>rem</a> are more efficient and if you only use
--   positive numbers, you may be happy with them. But we cannot warrant
--   the efficiency advantage.
--   
--   See also: Daan Leijen: Division and Modulus for Computer Scientists
--   <a>http://www.cs.uu.nl/%7Edaan/download/papers/divmodnote-letter.pdf</a>,
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2007-August/030394.html</a>
module Algebra.RealIntegral

-- | Remember that <a>divMod</a> does not specify exactly what <tt>a
--   <a>quot</a> b</tt> should be, mainly because there is no sensible way
--   to define it in general. For an instance of <tt>Algebra.RealIntegral.C
--   a</tt>, it is expected that <tt>a <a>quot</a> b</tt> will round
--   towards 0 and <tt>a <a>div</a> b</tt> will round towards minus
--   infinity.
--   
--   Minimal definition: nothing required
class (C a, C a, Ord a, C a) => C a where quot a b = fst (quotRem a b) rem a b = snd (quotRem a b) quotRem a b = let (d, m) = divMod a b in if (signum d < zero) then (d + one, m - b) else (d, m)
quot, rem :: C a => a -> a -> a
quotRem :: C a => a -> a -> (a, a)
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Integer

module Algebra.ToInteger

-- | The two classes <a>C</a> and <a>C</a> exist to allow convenient
--   conversions, primarily between the built-in types. They should satisfy
--   
--   <pre>
--   fromInteger .  toInteger === id
--    toRational .  toInteger === toRational
--   </pre>
--   
--   Conversions must be lossless, that is, they do not round in any way.
--   For rounding see <a>Algebra.RealRing</a>.
--   
--   I think that the RealIntegral superclass is too restrictive.
--   Non-negative numbers are not a ring, but can be easily converted to
--   Integers.
class (C a, C a) => C a
toInteger :: C a => a -> Integer
fromIntegral :: (C a, C b) => a -> b

-- | A prefix function of '(Algebra.Ring.^)' with a parameter order that
--   fits the needs of partial application and function composition. It has
--   generalised exponent.
--   
--   See: Argument order of <tt>expNat</tt> on
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2006-September/018022.html</a>
ringPower :: (C a, C b) => b -> a -> a

-- | A prefix function of '(Algebra.Field.^-)'. It has a generalised
--   exponent.
fieldPower :: (C a, C b) => b -> a -> a
instance (C a, C a) => C (T a)
instance C Word64
instance C Word32
instance C Word16
instance C Word8
instance C Word
instance C Int64
instance C Int32
instance C Int16
instance C Int8
instance C Int
instance C Integer

module Algebra.Algebraic

-- | Minimal implementation: <a>root</a> or '(^/)'.
class C a => C a where sqrt = root 2 root n x = x ^/ (1 % n) x ^/ y = root (denominator y) (x ^- numerator y)
sqrt :: C a => a -> a
root :: C a => Integer -> a -> a
(^/) :: C a => a -> Rational -> a
genericRoot :: (C a, C b) => b -> a -> a
power :: (C a, C b) => b -> a -> a
propSqrSqrt :: (Eq a, C a) => a -> Bool
propPowerCascade :: (Eq a, C a) => a -> Rational -> Rational -> Bool
propPowerProduct :: (Eq a, C a) => a -> Rational -> Rational -> Bool
propPowerDistributive :: (Eq a, C a) => Rational -> a -> a -> Bool
instance C Double
instance C Float

module Algebra.Transcendental

-- | Transcendental is the type of numbers supporting the elementary
--   transcendental functions. Examples include real numbers, complex
--   numbers, and computable reals represented as a lazy list of rational
--   approximations.
--   
--   Note the default declaration for a superclass. See the comments below,
--   under "Instance declaractions for superclasses".
--   
--   The semantics of these operations are rather ill-defined because of
--   branch cuts, etc.
--   
--   Minimal complete definition: pi, exp, (log or logBase), sin, cos, atan
class C a => C a where x ** y = exp (log x * y) logBase x y = log y / log x log = logBase (exp 1) tan x = sin x / cos x asin x = atan (x / sqrt (1 - x ^ 2)) acos x = pi / 2 - asin x sinh x = (exp x - exp (- x)) / 2 cosh x = (exp x + exp (- x)) / 2 tanh x = sinh x / cosh x asinh x = log (sqrt (x ^ 2 + 1) + x) acosh x = log (sqrt (x ^ 2 - 1) + x) atanh x = (log (1 + x) - log (1 - x)) / 2
pi :: C a => a
exp, log :: C a => a -> a
logBase, ** :: C a => a -> a -> a
sin, tan, cos :: C a => a -> a
asin, atan, acos :: C a => a -> a
sinh, tanh, cosh :: C a => a -> a
asinh, atanh, acosh :: C a => a -> a
(^?) :: C a => a -> a -> a
propExpLog :: (Eq a, C a) => a -> Bool
propLogExp :: (Eq a, C a) => a -> Bool
propExpNeg :: (Eq a, C a) => a -> Bool
propLogRecip :: (Eq a, C a) => a -> Bool
propExpProduct :: (Eq a, C a) => a -> a -> Bool
propExpLogPower :: (Eq a, C a) => a -> a -> Bool
propLogSum :: (Eq a, C a) => a -> a -> Bool
propPowerCascade :: (Eq a, C a) => a -> a -> a -> Bool
propPowerProduct :: (Eq a, C a) => a -> a -> a -> Bool
propPowerDistributive :: (Eq a, C a) => a -> a -> a -> Bool
propTrigonometricPythagoras :: (Eq a, C a) => a -> Bool
propSinPeriod :: (Eq a, C a) => a -> Bool
propCosPeriod :: (Eq a, C a) => a -> Bool
propTanPeriod :: (Eq a, C a) => a -> Bool
propSinAngleSum :: (Eq a, C a) => a -> a -> Bool
propCosAngleSum :: (Eq a, C a) => a -> a -> Bool
propSinDoubleAngle :: (Eq a, C a) => a -> Bool
propCosDoubleAngle :: (Eq a, C a) => a -> Bool
propSinSquare :: (Eq a, C a) => a -> Bool
propCosSquare :: (Eq a, C a) => a -> Bool
instance C Double
instance C Float


-- | Abstraction of modules
module Algebra.Module

-- | A Module over a ring satisfies:
--   
--   <pre>
--   a *&gt; (b + c) === a *&gt; b + a *&gt; c
--   (a * b) *&gt; c === a *&gt; (b *&gt; c)
--   (a + b) *&gt; c === a *&gt; c + b *&gt; c
--   </pre>
class (C a, C v) => C a v
(*>) :: C a v => a -> v -> v
(<*>.*>) :: C a x => T (a, v) (x -> c) -> (v -> x) -> T (a, v) c

-- | Compute the linear combination of a list of vectors.
--   
--   ToDo: Should it use <a>zipWith</a> ?
linearComb :: C a v => [a] -> [v] -> v

-- | This function can be used to define any <a>C</a> as a module over
--   <a>Integer</a>.
--   
--   Better move to <a>Algebra.Additive</a>?
integerMultiply :: (C a, C v) => a -> v -> v
propCascade :: (Eq v, C a v) => v -> a -> a -> Bool
propRightDistributive :: (Eq v, C a v) => a -> v -> v -> Bool
propLeftDistributive :: (Eq v, C a v) => v -> a -> a -> Bool
instance (C a b, RealFloat b) => C a (Complex b)
instance C a v => C a (c -> v)
instance C a v => C a [v]
instance (C a b0, C a b1, C a b2) => C a (b0, b1, b2)
instance (C a b0, C a b1) => C a (b0, b1)
instance C a => C Integer (T a)
instance C a => C (T a) (T a)
instance C Integer Integer
instance C Int Int
instance C Double Double
instance C Float Float

module Algebra.VectorSpace
class (C a, C a b) => C a b
instance (C a b, RealFloat b) => C a (Complex b)
instance C a b => C a (c -> b)
instance C a b => C a [b]
instance (C a b0, C a b1, C a b2) => C a (b0, b1, b2)
instance (C a b0, C a b1) => C a (b0, b1)
instance C a => C (T a) (T a)
instance C Double Double
instance C Float Float

module Algebra.DivisibleSpace

-- | DivisibleSpace is used for free one-dimensional vector spaces. It
--   satisfies
--   
--   <pre>
--   (a &lt;/&gt; b) *&gt; b = a
--   </pre>
--   
--   Examples include dollars and kilometers.
class C a b => C a b
(</>) :: C a b => b -> b -> a


-- | Abstraction of bases of finite dimensional modules
module Algebra.ModuleBasis

-- | It must hold:
--   
--   <pre>
--   Module.linearComb (flatten v `asTypeOf` [a]) (basis a) == v
--   dimension a v == length (flatten v `asTypeOf` [a])
--   </pre>
class C a v => C a v
basis :: C a v => a -> [v]
flatten :: C a v => v -> [a]
dimension :: C a v => a -> v -> Int
propFlatten :: (Eq v, C a v) => a -> v -> Bool
propDimension :: C a v => a -> v -> Bool
instance (C a v0, C a v1, C a v2) => C a (v0, v1, v2)
instance (C a v0, C a v1) => C a (v0, v1)
instance C a => C (T a) (T a)
instance C Integer Integer
instance C Int Int
instance C Double Double
instance C Float Float


-- | Some functions that are counterparts of functions from
--   <a>Data.List</a> using NumericPrelude.Numeric type classes. They are
--   distinct in that they check for valid arguments, e.g. the length
--   argument of <a>take</a> must be at most the length of the input list.
--   However, since many Haskell programs rely on the absence of such
--   checks, we did not make these the default implementations as in
--   <a>NumericPrelude.List.Generic</a>.
module NumericPrelude.List.Checked

-- | Taken number of elements must be at most the length of the list,
--   otherwise the end of the list is undefined.
take :: C n => n -> [a] -> [a]

-- | Dropped number of elements must be at most the length of the list,
--   otherwise the end of the list is undefined.
drop :: C n => n -> [a] -> [a]

-- | Split position must be at most the length of the list, otherwise the
--   end of the first list and the second list are undefined.
splitAt :: C n => n -> [a] -> ([a], [a])

-- | The index must be smaller than the length of the list, otherwise the
--   result is undefined.
(!!) :: C n => [a] -> n -> a

-- | Zip two lists which must be of the same length. This is checked only
--   lazily, that is unequal lengths are detected only if the list is
--   evaluated completely. But it is more strict than <tt>zipWithPad
--   undefined f</tt> since the latter one may succeed on unequal length
--   list if <tt>f</tt> is lazy.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]


-- | Functions that are counterparts of the <tt>generic</tt> functions in
--   <a>Data.List</a> using NumericPrelude.Numeric type classes. For input
--   arguments we use the restrictive <tt>ToInteger</tt> constraint,
--   although in principle <tt>RealRing</tt> would be enough. However we
--   think that <tt>take 0.5 xs</tt> is rather a bug than a feature, thus
--   we forbid fractional types. On the other hand fractional types as
--   result can be quite handy, e.g. in <tt>average xs = sum xs / length
--   xs</tt>.
module NumericPrelude.List.Generic

-- | The index must be smaller than the length of the list, otherwise the
--   result is undefined.
(!!) :: C n => [a] -> n -> a

-- | Left associative length computation that is appropriate for types like
--   <tt>Integer</tt>.
lengthLeft :: C n => [a] -> n

-- | Right associative length computation that is appropriate for types
--   like <tt>Peano</tt> number.
lengthRight :: C n => [a] -> n
replicate :: C n => n -> a -> [a]
take :: C n => n -> [a] -> [a]
drop :: C n => n -> [a] -> [a]
splitAt :: C n => n -> [a] -> ([a], [a])
findIndex :: C n => (a -> Bool) -> [a] -> Maybe n
elemIndex :: (C n, Eq a) => a -> [a] -> Maybe n
findIndices :: C n => (a -> Bool) -> [a] -> [n]
elemIndices :: (C n, Eq a) => a -> [a] -> [n]

module Algebra.RealRing

-- | Minimal complete definition: <a>splitFraction</a> or <a>floor</a>
--   
--   There are probably more laws, but some laws are
--   
--   <pre>
--   splitFraction x === (fromInteger (floor x), fraction x)
--   fromInteger (floor x) + fraction x === x
--   floor x       &lt;= x       x &lt;  floor x + 1
--   ceiling x - 1 &lt;  x       x &lt;= ceiling x
--   0 &lt;= fraction x          fraction x &lt; 1
--   </pre>
--   
--   <pre>
--               - ceiling x === floor (-x)
--                truncate x === signum x * floor (abs x)
--    ceiling (toRational x) === ceiling x :: Integer
--   truncate (toRational x) === truncate x :: Integer
--      floor (toRational x) === floor x :: Integer
--   </pre>
--   
--   The new function <a>fraction</a> doesn't return the integer part of
--   the number. This also removes a type ambiguity if the integer part is
--   not needed.
--   
--   Many people will associate rounding with fractional numbers, and thus
--   they are surprised about the superclass being <tt>Ring</tt> not
--   <tt>Field</tt>. The reason is that all of these methods can be defined
--   exclusively with functions from <tt>Ord</tt> and <tt>Ring</tt>. The
--   implementations of <a>genericFloor</a> and other functions demonstrate
--   that. They implement power-of-two-algorithms like the one for finding
--   the number of digits of an <a>Integer</a> in FixedPoint-fractions
--   module. They are even reasonably efficient.
--   
--   I am still uncertain whether it was a good idea to add instances for
--   <tt>Integer</tt> and friends, since calling <tt>floor</tt> or
--   <tt>fraction</tt> on an integer may well indicate a bug. The rounding
--   functions are just the identity function and <a>fraction</a> is
--   constant zero. However, I decided to associate our class with
--   <tt>Ring</tt> rather than <tt>Field</tt>, after I found myself using
--   repeated subtraction and testing rather than just calling
--   <tt>fraction</tt>, just in order to get the constraint <tt>(Ring a,
--   Ord a)</tt> that was more general than <tt>(RealField a)</tt>.
--   
--   For the results of the rounding functions we have chosen the
--   constraint <tt>Ring</tt> instead of <tt>ToInteger</tt>, since this is
--   more flexible to use, but it still signals to the user that only
--   integral numbers can be returned. This is so, because the plain
--   <tt>Ring</tt> class only provides <tt>zero</tt>, <tt>one</tt> and
--   operations that allow to reach all natural numbers but not more.
--   
--   As an aside, let me note the similarities between <tt>splitFraction
--   x</tt> and <tt>divMod x 1</tt> (if that were defined). In particular,
--   it might make sense to unify the rounding modes somehow.
--   
--   The new methods <a>fraction</a> and <a>splitFraction</a> differ from
--   <a>properFraction</a> semantics. They always round to <a>floor</a>.
--   This means that the fraction is always non-negative and is always
--   smaller than 1. This is more useful in practice and can be generalised
--   to more than real numbers. Since every <a>T</a> denominator type
--   supports <a>divMod</a>, every <a>T</a> can provide <a>fraction</a> and
--   <a>splitFraction</a>, e.g. fractions of polynomials. However the
--   <tt>Ring</tt> constraint for the ''integral'' part of
--   <a>splitFraction</a> is too weak in order to generate polynomials.
--   After all, I am uncertain whether this would be useful or not.
--   
--   Can there be a separate class for <a>fraction</a>,
--   <a>splitFraction</a>, <a>floor</a> and <a>ceiling</a> since they do
--   not need reals and their ordering?
--   
--   We might also add a round method, that rounds 0.5 always up or always
--   down. This is much more efficient in inner loops and is acceptable or
--   even preferable for many applications.
class (C a, Ord a) => C a where splitFraction x = (floor x, fraction x) fraction x = x - fromInteger (floor x) floor x = fromInteger (fst (splitFraction x)) ceiling x = - floor (- x) truncate x = if x >= 0 then floor x else ceiling x round x = let (n, r) = splitFraction x in case compare (2 * r) one of { LT -> n EQ -> if even n then n else n + 1 GT -> n + 1 }
splitFraction :: (C a, C b) => a -> (b, a)
fraction :: C a => a -> a
ceiling, floor :: (C a, C b) => a -> b
truncate :: (C a, C b) => a -> b
round :: (C a, C b) => a -> b

-- | This function rounds to the closest integer. For <tt>fraction x ==
--   0.5</tt> it rounds away from zero. This function is not the result of
--   an ingenious mathematical insight, but is simply a kind of rounding
--   that is the fastest on IEEE floating point architectures.
roundSimple :: (C a, C b) => a -> b
fastSplitFraction :: (RealFrac a, C a, C b) => (a -> Int) -> (Int -> a) -> a -> (b, a)
fixSplitFraction :: (C a, C b, Ord a) => (b, a) -> (b, a)
fixFraction :: (C a, Ord a) => a -> a
splitFractionInt :: (C a, Ord a) => (a -> Int) -> (Int -> a) -> a -> (Int, a)
floorInt :: (C a, Ord a) => (a -> Int) -> (Int -> a) -> a -> Int
ceilingInt :: (C a, Ord a) => (a -> Int) -> (Int -> a) -> a -> Int
roundInt :: (C a, Ord a) => (a -> Int) -> (Int -> a) -> a -> Int
roundSimpleInt :: (C a, C a, Ord a) => (a -> Int) -> (Int -> a) -> a -> Int

-- | TODO: Should be moved to a continued fraction module.
approxRational :: (C a, C a) => a -> a -> Rational
powersOfTwo :: C a => [a]
pairsOfPowersOfTwo :: (C a, C b) => [(a, b)]

-- | The generic rounding functions need a number of operations
--   proportional to the number of binary digits of the integer portion. If
--   operations like multiplication with two and comparison need time
--   proportional to the number of binary digits, then the overall rounding
--   requires quadratic time.
genericFloor :: (Ord a, C a, C b) => a -> b
genericCeiling :: (Ord a, C a, C b) => a -> b
genericTruncate :: (Ord a, C a, C b) => a -> b
genericRound :: (Ord a, C a, C b) => a -> b
genericFraction :: (Ord a, C a) => a -> a
genericSplitFraction :: (Ord a, C a, C b) => a -> (b, a)
genericPosFloor :: (Ord a, C a, C b) => a -> b
genericPosCeiling :: (Ord a, C a, C b) => a -> b
genericHalfPosFloorDigits :: (Ord a, C a, C b) => a -> ((a, b), [Bool])
genericPosRound :: (Ord a, C a, C b) => a -> b
genericPosFraction :: (Ord a, C a) => a -> a
genericPosSplitFraction :: (Ord a, C a, C b) => a -> (b, a)

-- | Needs linear time with respect to the number of digits.
--   
--   This and other functions using OrderDecision like <tt>floor</tt> where
--   argument and result are the same may be moved to a new module.
decisionPosFraction :: (C a, C a) => a -> a
decisionPosFractionSqrTime :: (C a, C a) => a -> a
instance C Double
instance C Float
instance C Integer
instance C Int
instance (C a, C a) => C (T a)

module Algebra.FloatingPoint

-- | Counterpart of <a>RealFloat</a> but with NumericPrelude superclass.
class C a => C a
radix :: C a => a -> Integer
digits :: C a => a -> Int
range :: C a => a -> (Int, Int)
decode :: C a => a -> (Integer, Int)
encode :: C a => Integer -> Int -> a
exponent :: C a => a -> Int
significand :: C a => a -> a
scale :: C a => Int -> a -> a
isNaN :: C a => a -> Bool
isInfinite :: C a => a -> Bool
isDenormalized :: C a => a -> Bool
isNegativeZero :: C a => a -> Bool
isIEEE :: C a => a -> Bool
instance C Double
instance C Float

module Algebra.RealField

-- | This is a convenient class for common types that both form a field and
--   have a notion of ordering by magnitude.
class (C a, C a) => C a
instance (C a, C a) => C (T a)
instance C Double
instance C Float

module Algebra.RealTranscendental

-- | This class collects all functions for _scalar_ floating point numbers.
--   E.g. computing <a>atan2</a> for complex floating numbers makes
--   certainly no sense.
class (C a, C a) => C a where atan2 y x = select 0 [(x > 0, atan (y / x)), (x == 0 && y > 0, pi / 2), (x < 0 && y > 0, pi + atan (y / x)), (x <= 0 && y < 0, - atan2 (- y) x), (y == 0 && x < 0, pi)]
atan2 :: C a => a -> a -> a
instance C Double
instance C Float

module NumericPrelude.Numeric

-- | add and subtract elements
(+, -) :: C a => a -> a -> a

-- | add and subtract elements
(+, -) :: C a => a -> a -> a

-- | inverse with respect to <a>+</a>
negate :: C a => a -> a

-- | zero element of the vector space
zero :: C a => a

-- | <a>subtract</a> is <tt>(-)</tt> with swapped operand order. This is
--   the operand order which will be needed in most cases of partial
--   application.
subtract :: C a => a -> a -> a

-- | Sum up all elements of a list. An empty list yields zero.
--   
--   This function is inappropriate for number types like Peano. Maybe we
--   should make <a>sum</a> a method of Additive. This would also make
--   <tt>lengthLeft</tt> and <tt>lengthRight</tt> superfluous.
sum :: C a => [a] -> a

-- | Sum up all elements of a non-empty list. This avoids including a zero
--   which is useful for types where no universal zero is available.
sum1 :: C a => [a] -> a
isZero :: C a => a -> Bool
(*) :: C a => a -> a -> a
one :: C a => a
fromInteger :: C a => Integer -> a

-- | The exponent has fixed type <a>Integer</a> in order to avoid an
--   arbitrarily limitted range of exponents, but to reduce the need for
--   the compiler to guess the type (default type). In practice the
--   exponent is most oftenly fixed, and is most oftenly <tt>2</tt>. Fixed
--   exponents can be optimized away and thus the expensive computation of
--   <a>Integer</a>s doesn't matter. The previous solution used a <a>C</a>
--   constrained type and the exponent was converted to Integer before
--   computation. So the current solution is not less efficient.
--   
--   A variant of <a>^</a> with more flexibility is provided by
--   <a>ringPower</a>.
(^) :: C a => a -> Integer -> a

-- | A prefix function of '(Algebra.Ring.^)' with a parameter order that
--   fits the needs of partial application and function composition. It has
--   generalised exponent.
--   
--   See: Argument order of <tt>expNat</tt> on
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2006-September/018022.html</a>
ringPower :: (C a, C b) => b -> a -> a
sqr :: C a => a -> a
product :: C a => [a] -> a
product1 :: C a => [a] -> a
div, mod :: C a => a -> a -> a
div, mod :: C a => a -> a -> a
divMod :: C a => a -> a -> (a, a)
divides :: (C a, C a) => a -> a -> Bool
even :: (C a, C a) => a -> Bool
odd :: (C a, C a) => a -> Bool
(/) :: C a => a -> a -> a
recip :: C a => a -> a
fromRational' :: C a => Rational -> a
(^-) :: C a => a -> Integer -> a

-- | A prefix function of '(Algebra.Field.^-)'. It has a generalised
--   exponent.
fieldPower :: (C a, C b) => b -> a -> a

-- | Needed to work around shortcomings in GHC.
fromRational :: C a => Rational -> a
(^/) :: C a => a -> Rational -> a
sqrt :: C a => a -> a
pi :: C a => a
exp, log :: C a => a -> a
exp, log :: C a => a -> a
logBase, ** :: C a => a -> a -> a
logBase, ** :: C a => a -> a -> a
(^?) :: C a => a -> a -> a
sin, tan, cos :: C a => a -> a
sin, tan, cos :: C a => a -> a
sin, tan, cos :: C a => a -> a
asin, atan, acos :: C a => a -> a
asin, atan, acos :: C a => a -> a
asin, atan, acos :: C a => a -> a
sinh, tanh, cosh :: C a => a -> a
sinh, tanh, cosh :: C a => a -> a
sinh, tanh, cosh :: C a => a -> a
asinh, atanh, acosh :: C a => a -> a
asinh, atanh, acosh :: C a => a -> a
asinh, atanh, acosh :: C a => a -> a
abs :: C a => a -> a
signum :: C a => a -> a
quot, rem :: C a => a -> a -> a
quot, rem :: C a => a -> a -> a
quotRem :: C a => a -> a -> (a, a)
splitFraction :: (C a, C b) => a -> (b, a)
fraction :: C a => a -> a
truncate :: (C a, C b) => a -> b
round :: (C a, C b) => a -> b
ceiling, floor :: (C a, C b) => a -> b
ceiling, floor :: (C a, C b) => a -> b

-- | TODO: Should be moved to a continued fraction module.
approxRational :: (C a, C a) => a -> a -> Rational
atan2 :: C a => a -> a -> a

-- | Lossless conversion from any representation of a rational to
--   <a>Rational</a>
toRational :: C a => a -> Rational
toInteger :: C a => a -> Integer
fromIntegral :: (C a, C b) => a -> b
isUnit :: C a => a -> Bool
stdAssociate, stdUnitInv, stdUnit :: C a => a -> a
stdAssociate, stdUnitInv, stdUnit :: C a => a -> a
stdAssociate, stdUnitInv, stdUnit :: C a => a -> a

-- | Compute the greatest common divisor and solve a respective Diophantine
--   equation.
--   
--   <pre>
--   (g,(a,b)) = extendedGCD x y ==&gt;
--        g==a*x+b*y   &amp;&amp;  g == gcd x y
--   </pre>
--   
--   TODO: This method is not appropriate for the PID class, because there
--   are rings like the one of the multivariate polynomials, where for all
--   x and y greatest common divisors of x and y exist, but they cannot be
--   represented as a linear combination of x and y. TODO: The definition
--   of extendedGCD does not return the canonical associate.
extendedGCD :: C a => a -> a -> (a, (a, a))

-- | The Greatest Common Divisor is defined by:
--   
--   <pre>
--   gcd x y == gcd y x
--   divides z x &amp;&amp; divides z y ==&gt; divides z (gcd x y)   (specification)
--   divides (gcd x y) x
--   </pre>
gcd :: C a => a -> a -> a

-- | Least common multiple
lcm :: C a => a -> a -> a
euclid :: (C a, C a) => (a -> a -> a) -> a -> a -> a
extendedEuclid :: (C a, C a) => (a -> a -> (a, a)) -> a -> a -> (a, (a, a))
type Rational = T Integer
(%) :: C a => a -> a -> T a
numerator :: T a -> a
denominator :: T a -> a

-- | Arbitrary-precision integers.
data Integer :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | scale a vector by a scalar
(*>) :: C a v => a -> v -> v

module Algebra.Lattice
class C a
up, dn :: C a => a -> a -> a
max :: C a => a -> a -> a
min :: C a => a -> a -> a
abs :: (C a, C a) => a -> a
propUpCommutative :: (Eq a, C a) => a -> a -> Bool
propDnCommutative :: (Eq a, C a) => a -> a -> Bool
propUpAssociative :: (Eq a, C a) => a -> a -> a -> Bool
propDnAssociative :: (Eq a, C a) => a -> a -> a -> Bool
propUpDnDistributive :: (Eq a, C a) => a -> a -> a -> Bool
propDnUpDistributive :: (Eq a, C a) => a -> a -> a -> Bool
instance (C a, C b) => C (a, b)
instance C Bool
instance (Ord a, C a) => C (T a)
instance C Integer

module NumericPrelude
max :: C a => a -> a -> a
min :: C a => a -> a -> a
abs :: (C a, C a) => a -> a


-- | Abstraction of normed vector spaces
module Algebra.NormedSpace.Euclidean

-- | Helper class for <a>C</a> that does not need an algebraic type
--   <tt>a</tt>.
--   
--   Minimal definition: <a>normSqr</a>
class (C a, C a v) => Sqr a v
normSqr :: Sqr a v => v -> a

-- | Default definition for <a>normSqr</a> that is based on <a>Foldable</a>
--   class.
normSqrFoldable :: (Sqr a v, Foldable f) => f v -> a

-- | Default definition for <a>normSqr</a> that is based on <a>Foldable</a>
--   class and the argument vector has at least one component.
normSqrFoldable1 :: (Sqr a v, Foldable f, Functor f) => f v -> a

-- | A vector space equipped with an Euclidean or a Hilbert norm.
--   
--   Minimal definition: <a>norm</a>
class Sqr a v => C a v
norm :: C a v => v -> a
defltNorm :: (C a, Sqr a v) => v -> a
instance (C a, Sqr a v, RealFloat v) => C a (Complex v)
instance (Sqr a v, RealFloat v) => Sqr a (Complex v)
instance (C a, Sqr a v) => C a [v]
instance Sqr a v => Sqr a [v]
instance (C a, Sqr a v0, Sqr a v1, Sqr a v2) => C a (v0, v1, v2)
instance (Sqr a v0, Sqr a v1, Sqr a v2) => Sqr a (v0, v1, v2)
instance (C a, Sqr a v0, Sqr a v1) => C a (v0, v1)
instance (Sqr a v0, Sqr a v1) => Sqr a (v0, v1)
instance (C a, C a) => Sqr (T a) (T a)
instance C Integer Integer
instance Sqr Integer Integer
instance C Int Int
instance Sqr Int Int
instance C Double Double
instance Sqr Double Double
instance C Float Float
instance Sqr Float Float


-- | Abstraction of normed vector spaces
module Algebra.NormedSpace.Maximum
class (C a, C a v) => C a v
norm :: C a v => v -> a

-- | Default definition for <a>norm</a> that is based on <a>Foldable</a>
--   class.
normFoldable :: (C a v, Foldable f) => f v -> a

-- | Default definition for <a>norm</a> that is based on <a>Foldable</a>
--   class and the argument vector has at least one component.
normFoldable1 :: (C a v, Foldable f, Functor f) => f v -> a
instance (C a v, RealFloat v) => C a (Complex v)
instance (Ord a, C a v) => C a [v]
instance (Ord a, C a v0, C a v1, C a v2) => C a (v0, v1, v2)
instance (Ord a, C a v0, C a v1) => C a (v0, v1)
instance (C a, C a, C a) => C (T a) (T a)
instance C Integer Integer
instance C Int Int
instance C Double Double
instance C Float Float


-- | Abstraction of normed vector spaces
module Algebra.NormedSpace.Sum

-- | The super class is only needed to state the laws <tt> v == zero ==
--   norm v == zero norm (scale x v) == abs x * norm v norm (u+v) &lt;=
--   norm u + norm v </tt>
class (C a, C a v) => C a v
norm :: C a v => v -> a

-- | Default definition for <a>norm</a> that is based on <a>Foldable</a>
--   class.
normFoldable :: (C a v, Foldable f) => f v -> a

-- | Default definition for <a>norm</a> that is based on <a>Foldable</a>
--   class and the argument vector has at least one component.
normFoldable1 :: (C a v, Foldable f, Functor f) => f v -> a
instance (C a v, RealFloat v) => C a (Complex v)
instance (C a, C a v) => C a [v]
instance (C a, C a v0, C a v1, C a v2) => C a (v0, v1, v2)
instance (C a, C a v0, C a v1) => C a (v0, v1)
instance (C a, C a) => C (T a) (T a)
instance C Integer Integer
instance C Int Int
instance C Double Double
instance C Float Float


-- | DiscreteMap was originally intended as a type class that unifies Map
--   and Array. One should be able to simply choose between - Map for
--   sparse arrays - Array for full arrays.
--   
--   However, the Edison package provides the class AssocX which already
--   exists for that purpose.
--   
--   Currently I use this module for some numeric instances of Data.Map.
module MathObj.DiscreteMap

-- | Remove all zero values from the map.
strip :: (Ord i, Eq v, C v) => Map i v -> Map i v
instance (Ord i, Eq a, Eq v, C a v) => C a (Map i v)
instance (Ord i, Eq a, Eq v, C a, Sqr a v) => C a (Map i v)
instance (Ord i, Eq a, Eq v, Sqr a v) => Sqr a (Map i v)
instance (Ord i, Eq a, Eq v, C a v) => C a (Map i v)
instance (Ord i, Eq a, Eq v, C a v) => C a (Map i v)
instance (Ord i, Eq a, Eq v, C a v) => C a (Map i v)
instance Ord i => C (Map i)
instance (Ord i, Eq v, C v) => C (Map i v)


-- | There are several types of numbers where a subset of numbers can be
--   considered as set of scalars.
--   
--   <ul>
--   <li>A '(Complex.T Double)' value can be converted to <a>Double</a> if
--   the imaginary part is zero.</li>
--   <li>A value with physical units can be converted to a scalar if there
--   is no unit.</li>
--   </ul>
--   
--   Of course this can be cascaded, e.g. a complex number with physical
--   units can be converted to a scalar if there is both no imaginary part
--   and no unit.
--   
--   This is somewhat similar to the multi-type classes NormedMax.C and
--   friends.
--   
--   I hesitate to define an instance for lists to avoid the mess known of
--   MatLab. But if you have an application where you think you need this
--   instance definitely I'll think about that, again.
module Algebra.OccasionallyScalar
class C a v
toScalar :: C a v => v -> a
toMaybeScalar :: C a v => v -> Maybe a
fromScalar :: C a v => a -> v
toScalarDefault :: C a v => v -> a
toScalarShow :: (C a v, Show v) => v -> a
instance C Double Double
instance C Float Float


-- | Routines and abstractions for Matrices and basic linear algebra over
--   fields or rings.
--   
--   We stick to simple Int indices. Although advanced indices would be
--   nice e.g. for matrices with sub-matrices, this is not easily
--   implemented since arrays do only support a lower and an upper bound
--   but no additional parameters.
--   
--   ToDo: - Matrix inverse, determinant (see htam:Matrix)
module MathObj.Matrix

-- | A matrix is a twodimensional array, indexed by integers.
data T a
type Dimension = Int
format :: Show a => T a -> String

-- | Transposition of matrices is just transposition in the sense of
--   Data.List.
transpose :: T a -> T a
rows :: T a -> [[a]]
columns :: T a -> [[a]]
index :: T a -> Dimension -> Dimension -> a
fromRows :: Dimension -> Dimension -> [[a]] -> T a
fromColumns :: Dimension -> Dimension -> [[a]] -> T a
fromList :: Dimension -> Dimension -> [a] -> T a
dimension :: T a -> (Dimension, Dimension)
numRows :: T a -> Dimension
numColumns :: T a -> Dimension
zipWith :: (a -> b -> c) -> T a -> T b -> T c
zero :: C a => Dimension -> Dimension -> T a
one :: C a => Dimension -> T a
diagonal :: C a => [a] -> T a
scale :: C a => a -> T a -> T a
random :: (RandomGen g, Random a) => Dimension -> Dimension -> g -> (T a, g)
randomR :: (RandomGen g, Random a) => Dimension -> Dimension -> (a, a) -> g -> (T a, g)
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance Read a => Read (T a)
instance C a b => C a (T b)
instance C T
instance Functor T
instance C a => C (T a)
instance C a => C (T a)
instance Show a => Show (T a)


-- | Implementation of partial fractions. Useful e.g. for fractions of
--   integers and fractions of polynomials.
--   
--   For the considered ring the prime factorization must be unique.
module MathObj.PartialFraction

-- | <tt>Cons z (indexMapFromList [(x0,[y00,y01]), (x1,[y10]),
--   (x2,[y20,y21,y22])])</tt> represents the partial fraction <tt>z +
--   y00<i>x0 + y01</i>x0^2 + y10<i>x1 + y20</i>x2 + y21<i>x2^2 +
--   y22</i>x2^3</tt> The denominators <tt>x0, x1, x2, ...</tt> must be
--   irreducible, but we can't check this in general. It is also not enough
--   to have relatively prime denominators, because when adding two partial
--   fraction representations there might concur denominators that have
--   non-trivial common divisors.
data T a
Cons :: a -> (Map (ToOrd a) [a]) -> T a

-- | Unchecked construction.
fromFractionSum :: C a => a -> [(a, [a])] -> T a
toFractionSum :: C a => T a -> (a, [(a, [a])])
appPrec :: Int
toFraction :: C a => T a -> T a

-- | <a>C</a> is not really necessary here and only due to invokation of
--   <a>toFraction</a>.
toFactoredFraction :: C a => T a -> ([a], a)

-- | <a>C</a> is not really necessary here and only due to invokation of
--   <a>%</a>.
multiToFraction :: C a => a -> [a] -> T a
hornerRev :: C a => a -> [a] -> a

-- | <tt>fromFactoredFraction x y</tt> computes the partial fraction
--   representation of <tt>y % product x</tt>, where the elements of
--   <tt>x</tt> must be irreducible. The function transforms the factors
--   into their standard form with respect to unit factors.
--   
--   There are more direct methods for special cases like polynomials over
--   rational numbers where the denominators are linear factors.
fromFactoredFraction :: (C a, C a) => [a] -> a -> T a
fromFactoredFractionAlt :: (C a, C a) => [a] -> a -> T a

-- | The list of denominators must contain equal elements. Sorry for this
--   hack.
multiFromFraction :: C a => [a] -> a -> (a, [a])
fromValue :: a -> T a

-- | A normalization step which separates the integer part from the leading
--   fraction of each sub-list.
reduceHeads :: C a => T a -> T a

-- | Cf. Number.Positional
carryRipple :: C a => a -> [a] -> (a, [a])

-- | A normalization step which reduces all elements in sub-lists modulo
--   their denominators. Zeros might be the result, that must be remove
--   with <a>removeZeros</a>.
normalizeModulo :: C a => T a -> T a

-- | Remove trailing zeros in sub-lists because if lists are converted to
--   fractions by <a>multiToFraction</a> we must be sure that the
--   denominator of the (cancelled) fraction is indeed the stored power of
--   the irreducible denominator. Otherwise <a>mulFrac</a> leads to wrong
--   results.
removeZeros :: (C a, C a) => T a -> T a
zipWith :: C a => (a -> a -> a) -> ([a] -> [a] -> [a]) -> (T a -> T a -> T a)

-- | Transforms a product of two partial fractions into a sum of two
--   fractions. The denominators must be at least relatively prime. Since
--   <a>T</a> requires irreducible denominators, these are also relatively
--   prime.
--   
--   Example: <tt>mulFrac (1%6) (1%4)</tt> fails because of the common
--   divisor <tt>2</tt>.
mulFrac :: C a => T a -> T a -> (a, a)
mulFrac' :: C a => T a -> T a -> (T a, T a)

-- | Works always but simply puts the product into the last fraction.
mulFracStupid :: C a => T a -> T a -> ((T a, T a), T a)

-- | Also works if the operands share a non-trivial divisor. However the
--   results are quite arbitrary.
mulFracOverlap :: C a => T a -> T a -> ((T a, T a), T a)

-- | Expects an irreducible denominator as associate in standard form.
scaleFrac :: (C a, C a) => T a -> T a -> T a
scaleInt :: (C a, C a) => a -> T a -> T a
mul :: (C a, C a) => T a -> T a -> T a
mulFast :: (C a, C a) => T a -> T a -> T a
indexMapMapWithKey :: (a -> b -> c) -> Map (ToOrd a) b -> Map (ToOrd a) c
indexMapToList :: Map (ToOrd a) b -> [(a, b)]
indexMapFromList :: C a => [(a, b)] -> Map (ToOrd a) b

-- | Apply a function on a specific element if it exists, and another
--   function to the rest of the map.
mapApplySplit :: Ord a => a -> (c -> c -> c) -> (b -> c) -> (Map a b -> Map a c) -> Map a b -> Map a c
instance Eq a => Eq (T a)
instance (C a, C a) => C (T a)
instance (C a, C a, C a) => C (T a)
instance Show a => Show (T a)


-- | Permutation of Integers represented by cycles.
module MathObj.Permutation.CycleList
type Cycle i = [i]
type T i = [Cycle i]
fromFunction :: Ix i => (i, i) -> (i -> i) -> T i
cycleRightAction :: Eq i => i -> Cycle i -> i
cycleLeftAction :: Eq i => Cycle i -> i -> i
cycleAction :: Eq i => [i] -> i -> i
cycleOrbit :: Ord i => Cycle i -> i -> [i]

-- | Right (left?) group action on the Integers. Close to, but not the same
--   as the module action in Algebra.Module.
(*>) :: Eq i => T i -> i -> i
cyclesOrbit :: Ord i => T i -> i -> [i]
orbit :: Ord i => (i -> i) -> i -> [i]

-- | candidates for Utility ?
takeUntilRepetition :: Ord a => [a] -> [a]
takeUntilRepetitionSlow :: Eq a => [a] -> [a]
choose :: Set a -> Maybe a
keepEssentials :: T i -> T i
isEssential :: Cycle i -> Bool
inverse :: T i -> T i


module MathObj.Permutation.CycleList.Check

-- | We shall make a little bit of a hack here, enabling us to use additive
--   or multiplicative syntax for groups as we wish by simply instantiating
--   Num with both operations corresponding to the group operation of the
--   permutation group we're studying
--   
--   There are quite a few way we could represent elements of permutation
--   groups: the images in a row, a list of the cycles, et.c. All of these
--   differ highly in how complex various operations end up being.
newtype Cycle i
Cycle :: [i] -> Cycle i
cycle :: Cycle i -> [i]
data T i
Cons :: (i, i) -> [Cycle i] -> T i
range :: T i -> (i, i)
cycles :: T i -> [Cycle i]

-- | Does not check whether the input values are in range.
fromCycles :: (i, i) -> [[i]] -> T i
toCycles :: T i -> [[i]]
toTable :: Ix i => T i -> T i
fromTable :: Ix i => T i -> T i
errIncompat :: a
liftCmpTable2 :: Ix i => (T i -> T i -> a) -> T i -> T i -> a
liftTable2 :: Ix i => (T i -> T i -> T i) -> T i -> T i -> T i
closure :: Ix i => [T i] -> [T i]

-- | These instances may need more work They involve converting a
--   permutation to a table.
instance Read i => Read (Cycle i)
instance Eq i => Eq (Cycle i)
instance Ix i => C (T i)
instance Ix i => Ord (T i)
instance Ix i => Eq (T i)
instance Show i => Show (T i)
instance Show i => Show (Cycle i)
instance C T


-- | This module implements polynomial functions on plain lists. We use
--   such functions in order to implement methods of other datatypes.
--   
--   The module organization differs from that of <tt>ResidueClass</tt>:
--   Here the <tt>Polynomial</tt> module exports the type that fits to the
--   NumericPrelude type classes, whereas in <tt>ResidueClass</tt> the
--   sub-modules export various flavors of them.
module MathObj.Polynomial.Core

-- | Horner's scheme for evaluating a polynomial in a ring.
horner :: C a => a -> [a] -> a

-- | Horner's scheme for evaluating a polynomial in a module.
hornerCoeffVector :: C a v => a -> [v] -> v
hornerArgVector :: (C a v, C v) => v -> [a] -> v

-- | It's also helpful to put a polynomial in canonical form.
--   <a>normalize</a> strips leading coefficients that are zero.
normalize :: C a => [a] -> [a]

-- | Multiply by the variable, used internally.
shift :: C a => [a] -> [a]
unShift :: [a] -> [a]
equal :: (Eq a, C a) => [a] -> [a] -> Bool
add :: C a => [a] -> [a] -> [a]
sub :: C a => [a] -> [a] -> [a]
negate :: C a => [a] -> [a]
scale :: C a => a -> [a] -> [a]
collinear :: (Eq a, C a) => [a] -> [a] -> Bool
tensorProduct :: C a => [a] -> [a] -> [[a]]
tensorProductAlt :: C a => [a] -> [a] -> [[a]]

-- | <a>mul</a> is fast if the second argument is a short polynomial,
--   <a>**</a> relies on that fact.
mul :: C a => [a] -> [a] -> [a]
mulShear :: C a => [a] -> [a] -> [a]
mulShearTranspose :: C a => [a] -> [a] -> [a]
divMod :: (C a, C a) => [a] -> [a] -> ([a], [a])

-- | The modulus will always have one element less than the divisor. This
--   means that the modulus will be denormalized in some cases, e.g.
--   <tt>mod [2,1,1] [1,1,1] == [1,0]</tt> instead of <tt>[1]</tt>.
divModRev :: (C a, C a) => [a] -> [a] -> ([a], [a])
stdUnit :: (C a, C a) => [a] -> a
progression :: C a => [a]
differentiate :: C a => [a] -> [a]
integrate :: C a => a -> [a] -> [a]

-- | Integrates if it is possible to represent the integrated polynomial in
--   the given ring. Otherwise undefined coefficients occur.
integrateInt :: (C a, C a) => a -> [a] -> [a]
mulLinearFactor :: C a => a -> [a] -> [a]
alternate :: C a => [a] -> [a]

module MathObj.PowerSeries.Core
evaluate :: C a => [a] -> a -> a
evaluateCoeffVector :: C a v => [v] -> a -> v
evaluateArgVector :: (C a v, C v) => [a] -> v -> v
approximate :: C a => [a] -> a -> [a]
approximateCoeffVector :: C a v => [v] -> a -> [v]
approximateArgVector :: (C a v, C v) => [a] -> v -> [v]

-- | For the series of a real function <tt>f</tt> compute the series for
--   <tt>x -&gt; f (-x)</tt>
alternate :: C a => [a] -> [a]

-- | For the series of a real function <tt>f</tt> compute the series for
--   <tt>x -&gt; (f x + f (-x)) / 2</tt>
holes2 :: C a => [a] -> [a]

-- | For the series of a real function <tt>f</tt> compute the real series
--   for <tt>x -&gt; (f (i*x) + f (-i*x)) / 2</tt>
holes2alternate :: C a => [a] -> [a]

-- | For power series of <tt>f x</tt>, compute the power series of
--   <tt>f(x^n)</tt>.
insertHoles :: C a => Int -> [a] -> [a]
add :: C a => [a] -> [a] -> [a]
sub :: C a => [a] -> [a] -> [a]
negate :: C a => [a] -> [a]
scale :: C a => a -> [a] -> [a]
mul :: C a => [a] -> [a] -> [a]
stripLeadZero :: C a => [a] -> [a] -> ([a], [a])
divMod :: (C a, C a) => [a] -> [a] -> ([a], [a])

-- | Divide two series where the absolute term of the divisor is non-zero.
--   That is, power series with leading non-zero terms are the units in the
--   ring of power series.
--   
--   Knuth: Seminumerical algorithms
divide :: C a => [a] -> [a] -> [a]

-- | Divide two series also if the divisor has leading zeros.
divideStripZero :: (C a, C a) => [a] -> [a] -> [a]
progression :: C a => [a]
recipProgression :: C a => [a]
differentiate :: C a => [a] -> [a]
integrate :: C a => a -> [a] -> [a]

-- | We need to compute the square root only of the first term. That is, if
--   the first term is rational, then all terms of the series are rational.
sqrt :: C a => (a -> a) -> [a] -> [a]

-- | Input series must start with a non-zero term, even better with a
--   positive one.
pow :: C a => (a -> a) -> a -> [a] -> [a]

-- | The first term needs a transcendent computation but the others do not.
--   That's why we accept a function which computes the first term.
--   
--   <pre>
--   (exp . x)' =   (exp . x) * x'
--   (sin . x)' =   (cos . x) * x'
--   (cos . x)' = - (sin . x) * x'
--   </pre>
exp :: C a => (a -> a) -> [a] -> [a]
sinCos :: C a => (a -> (a, a)) -> [a] -> ([a], [a])
sinCosScalar :: C a => a -> (a, a)
sin :: C a => (a -> (a, a)) -> [a] -> [a]
cos :: C a => (a -> (a, a)) -> [a] -> [a]
tan :: C a => (a -> (a, a)) -> [a] -> [a]

-- | Input series must start with non-zero term.
log :: C a => (a -> a) -> [a] -> [a]

-- | Computes <tt>(log x)'</tt>, that is <tt>x'/x</tt>
derivedLog :: C a => [a] -> [a]
atan :: C a => (a -> a) -> [a] -> [a]
asin :: C a => (a -> a) -> (a -> a) -> [a] -> [a]
acos :: C a => (a -> a) -> (a -> a) -> [a] -> [a]

-- | Since the inner series must start with a zero, the first term is
--   omitted in y.
compose :: C a => [a] -> [a] -> [a]

-- | Compose two power series where the outer series can be developed for
--   any expansion point. To be more precise: The outer series must be
--   expanded with respect to the leading term of the inner series.
composeTaylor :: C a => (a -> [a]) -> [a] -> [a]

-- | This function returns the series of the inverse function in the form:
--   (point of the expansion, power series).
--   
--   That is, say we have the equation:
--   
--   <pre>
--   y = a + f(x)
--   </pre>
--   
--   where function f is given by a power series with f(0) = 0. We want to
--   solve for x:
--   
--   <pre>
--   x = f^-1(y-a)
--   </pre>
--   
--   If you pass the power series of <tt>a+f(x)</tt> to <a>inv</a>, you get
--   <tt>(a, f^-1)</tt> as answer, where <tt>f^-1</tt> is a power series.
--   
--   The linear term of <tt>f</tt> (the coefficient of <tt>x</tt>) must be
--   non-zero.
--   
--   This needs cubic run-time and thus is exceptionally slow. Computing
--   inverse series for special power series might be faster.
inv :: (Eq a, C a) => [a] -> (a, [a])
invDiff :: C a => [a] -> (a, [a])


-- | Power series, either finite or unbounded. (zipWith does exactly the
--   right thing to make it work almost transparently.)
module MathObj.PowerSeries
newtype T a
Cons :: [a] -> T a
coeffs :: T a -> [a]
fromCoeffs :: [a] -> T a
lift0 :: [a] -> T a
lift1 :: ([a] -> [a]) -> (T a -> T a)
lift2 :: ([a] -> [a] -> [a]) -> (T a -> T a -> T a)
const :: a -> T a
appPrec :: Int
truncate :: Int -> T a -> T a

-- | Evaluate (truncated) power series.
evaluate :: C a => T a -> a -> a

-- | Evaluate (truncated) power series.
evaluateCoeffVector :: C a v => T v -> a -> v
evaluateArgVector :: (C a v, C v) => T a -> v -> v

-- | Evaluate approximations that is evaluate all truncations of the
--   series.
approximate :: C a => T a -> a -> [a]

-- | Evaluate approximations that is evaluate all truncations of the
--   series.
approximateCoeffVector :: C a v => T v -> a -> [v]

-- | Evaluate approximations that is evaluate all truncations of the
--   series.
approximateArgVector :: (C a v, C v) => T a -> v -> [v]

-- | It fulfills <tt> evaluate x . evaluate y == evaluate (compose x y)
--   </tt>
compose :: (C a, C a) => T a -> T a -> T a
instance (Ord a, C a) => Ord (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance (C a, C a) => C (T a)
instance C a => C (T a)
instance (C a, C a b) => C a (T b)
instance C a b => C a (T b)
instance C T
instance C a => C (T a)
instance C a => C (T a)
instance (Eq a, C a) => Eq (T a)
instance Show a => Show (T a)
instance Functor T

module MathObj.PowerSeries2.Core
type T a = [[a]]
lift0fromPowerSeries :: [T a] -> T a
lift1fromPowerSeries :: ([T a] -> [T a]) -> (T a -> T a)
lift2fromPowerSeries :: ([T a] -> [T a] -> [T a]) -> (T a -> T a -> T a)
add :: C a => T a -> T a -> T a
sub :: C a => T a -> T a -> T a
negate :: C a => T a -> T a
scale :: C a => a -> T a -> T a
mul :: C a => T a -> T a -> T a
divide :: C a => T a -> T a -> T a
sqrt :: C a => (a -> a) -> T a -> T a
pow :: C a => (a -> a) -> a -> T a -> T a
swapVariables :: T a -> T a
differentiate0 :: C a => T a -> T a
differentiate1 :: C a => T a -> T a
integrate0 :: C a => [a] -> T a -> T a
integrate1 :: C a => [a] -> T a -> T a

-- | Since the inner series must start with a zero, the first term is
--   omitted in y.
compose :: C a => [a] -> T a -> T a

module MathObj.PowerSeries.Example
recip :: C a => [a]
exp :: C a => [a]
sqrt :: C a => [a]
atan :: C a => [a]
asin :: C a => [a]
log :: C a => [a]
cos :: C a => [a]
sin :: C a => [a]
acos :: C a => [a]
tan :: (C a, C a) => [a]
sinh :: C a => [a]
atanh :: C a => [a]
cosh :: C a => [a]
pow :: C a => a -> [a]
recipExpl :: C a => [a]
expExpl :: C a => [a]
cosExpl :: C a => [a]
sinExpl :: C a => [a]
tanExpl :: (C a, C a) => [a]
tanExplSieve :: (C a, C a) => [a]
logExpl :: C a => [a]
sqrtExpl :: C a => [a]
atanExpl :: C a => [a]
sinhExpl :: C a => [a]
atanhExpl :: C a => [a]
coshExpl :: C a => [a]
powExpl :: C a => a -> [a]

-- | Power series of error function (almost). More precisely <tt> erf = 2 /
--   sqrt pi * integrate (x -&gt; exp (-x^2)) </tt>, with <tt>erf 0 =
--   0</tt>.
erf :: C a => [a]
expODE :: C a => [a]
tanODESieve :: C a => [a]
tanODE :: C a => [a]
cosODE :: C a => [a]
sinODE :: C a => [a]
logODE :: C a => [a]
sqrtODE :: C a => [a]
atanODE :: C a => [a]
asinODE :: C a => [a]
recipCircle :: C a => [a]
acosODE :: C a => [a]
sinhODE :: C a => [a]
atanhODE :: C a => [a]
coshODE :: C a => [a]
powODE :: C a => a -> [a]


-- | Lazy evaluation allows for the solution of differential equations in
--   terms of power series. Whenever you can express the highest derivative
--   of the solution as explicit expression of the lower derivatives where
--   each coefficient of the solution series depends only on lower
--   coefficients, the recursive algorithm will work.
module MathObj.PowerSeries.DifferentialEquation

-- | Example for a linear equation: Setup a differential equation for
--   <tt>y</tt> with
--   
--   <pre>
--   y   t = (exp (-t)) * (sin t)
--   y'  t = -(exp (-t)) * (sin t) + (exp (-t)) * (cos t)
--   y'' t = -2 * (exp (-t)) * (cos t)
--   </pre>
--   
--   Thus the differential equation
--   
--   <pre>
--   y'' = -2 * (y' + y)
--   </pre>
--   
--   holds.
--   
--   The following function generates a power series for <tt>exp (-t) * sin
--   t</tt> by solving the differential equation.
solveDiffEq0 :: C a => [a]
verifyDiffEq0 :: C a => [a]
propDiffEq0 :: Bool

-- | We are not restricted to linear equations! Let the solution be y with
--   y t = (1-t)^-1 y' t = (1-t)^-2 y'' t = 2*(1-t)^-3 then it holds y'' =
--   2 * y' * y
solveDiffEq1 :: (C a, C a) => [a]
verifyDiffEq1 :: (C a, C a) => [a]
propDiffEq1 :: Bool


-- | Two-variate power series.
module MathObj.PowerSeries2

-- | In order to handle both variables equivalently we maintain a list of
--   coefficients for terms of the same total degree. That is
--   
--   <pre>
--   eval [[a], [b,c], [d,e,f]] (x,y) ==
--      a + b*x+c*y + d*x^2+e*x*y+f*y^2
--   </pre>
--   
--   Although the sub-lists are always finite and thus are more like
--   polynomials than power series, division and square root computation
--   are easier to implement for power series.
newtype T a
Cons :: T a -> T a
coeffs :: T a -> T a
isValid :: [[a]] -> Bool
check :: [[a]] -> [[a]]
fromCoeffs :: [[a]] -> T a
fromPowerSeries0 :: C a => T a -> T a
fromPowerSeries1 :: C a => T a -> T a
lift0 :: T a -> T a
lift1 :: (T a -> T a) -> (T a -> T a)
lift2 :: (T a -> T a -> T a) -> (T a -> T a -> T a)
const :: a -> T a
truncate :: Int -> T a -> T a
appPrec :: Int
instance (Ord a, C a) => Ord (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C T
instance C a => C (T a)
instance C a => C (T a)
instance (Eq a, C a) => Eq (T a)
instance Show a => Show (T a)
instance Functor T


-- | This module computes power series for representing some means as
--   generalized $f$-means.
module MathObj.PowerSeries.Mean
diffComp :: C a => [a] -> [a] -> [a]
logarithmic :: C a => [a]
elemSym3_2 :: C a => [a]
quadratic :: (C a, Eq a) => [a]
quadraticMVF :: C a => [a]
quadraticDiff :: (C a, Eq a) => [a]
quadratic2 :: (C a, Eq a) => T a
quadraticDiff2 :: (C a, Eq a) => T a
harmonicMVF :: C a => [a]
harmonic2 :: (C a, Eq a) => T a
harmonicDiff2 :: (C a, Eq a) => T a
arithmeticMVF :: C a => [a]
arithmetic2 :: (C a, Eq a) => T a
arithmeticDiff2 :: (C a, Eq a) => T a
geometricMVF :: C a => [a]
geometric2 :: (C a, Eq a) => T a
geometricDiff2 :: (C a, Eq a) => T a
meanValueDiff2 :: (C a, Eq a) => T a -> [a] -> T a


-- | Fixed point numbers. They are implemented as ratios with fixed
--   denominator. Many routines fail for some arguments. When they work,
--   they can be useful for obtaining approximations of some constants. We
--   have not paid attention to rounding errors and thus some of the
--   trailing digits may be wrong.
module Number.FixedPoint
fromFloat :: C a => Integer -> a -> Integer

-- | denominator conversion
fromFixedPoint :: Integer -> Integer -> Integer -> Integer

-- | very efficient because it can make use of the decimal output of
--   <a>show</a>
showPositionalDec :: Integer -> Integer -> String
showPositionalHex :: Integer -> Integer -> String
showPositionalBin :: Integer -> Integer -> String
showPositionalBasis :: Integer -> Integer -> Integer -> String
liftShowPosToInt :: (Integer -> String) -> (Integer -> String)
toPositional :: Integer -> Integer -> Integer -> (Integer, [Integer])
add :: Integer -> Integer -> Integer -> Integer
sub :: Integer -> Integer -> Integer -> Integer
mul :: Integer -> Integer -> Integer -> Integer
divide :: Integer -> Integer -> Integer -> Integer
recip :: Integer -> Integer -> Integer
magnitudes :: [Integer]
sqrt :: Integer -> Integer -> Integer
root :: Integer -> Integer -> Integer -> Integer
evalPowerSeries :: [Rational] -> Integer -> Integer -> Integer
cos :: Integer -> Integer -> Integer
tan :: Integer -> Integer -> Integer
sin :: Integer -> Integer -> Integer
arctanSmall :: Integer -> Integer -> Integer
arctan :: Integer -> Integer -> Integer
piConst :: Integer -> Integer
expSmall :: Integer -> Integer -> Integer
eConst :: Integer -> Integer
recipEConst :: Integer -> Integer
exp :: Integer -> Integer -> Integer
approxLogBase :: Integer -> Integer -> (Int, Integer)
lnSmall :: Integer -> Integer -> Integer
ln :: Integer -> Integer -> Integer

module Number.ResidueClass
add :: C a => a -> a -> a -> a
sub :: C a => a -> a -> a -> a
neg :: C a => a -> a -> a
mul :: C a => a -> a -> a -> a

-- | The division may be ambiguous. In this case an arbitrary quotient is
--   returned.
--   
--   <pre>
--   0<i>:4 * 2</i>:4 == 0/:4
--   2<i>:4 * 2</i>:4 == 0/:4
--   </pre>
divideMaybe :: C a => a -> a -> a -> Maybe a
divide :: C a => a -> a -> a -> a
recip :: C a => a -> a -> a


-- | This number type is intended for tests of functions over fields, where
--   the field elements need constant space. This way we can provide a
--   Storable instance. For <a>Rational</a> this would not be possible.
--   
--   However, be aware that sums of non-zero elements may yield zero. Thus
--   division is not always safe, where it is for rational numbers.
module Number.GaloisField2p32m5
newtype T
Cons :: Word32 -> T
decons :: T -> Word32
appPrec :: Int
base :: C a => a
lift2 :: (Word64 -> Word64 -> Word64) -> (T -> T -> T)
lift2Integer :: (Int64 -> Int64 -> Int64) -> (T -> T -> T)
instance Eq T
instance C T T
instance C T
instance C T
instance C T
instance Storable T
instance Arbitrary T
instance Show T


-- | Define Transcendental functions on arbitrary fields. These functions
--   are defined for only a few (in most cases only one) arguments, that's
--   why we discourage making these types instances of <a>C</a>. But
--   instances of <a>C</a> can be useful when working with power series. If
--   you intend to work with power series with <a>Rational</a>
--   coefficients, you might consider using <tt>MathObj.PowerSeries.T
--   (Number.PartiallyTranscendental.T Rational)</tt> instead of
--   <tt>MathObj.PowerSeries.T Rational</tt>.
module Number.PartiallyTranscendental
data T a
fromValue :: a -> T a
toValue :: T a -> a
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance Show a => Show (T a)
instance Fractional a => Fractional (T a)
instance Num a => Num (T a)
instance (C a, Eq a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)

module Number.ResidueClass.Check

-- | The best solution seems to let <a>modulus</a> be part of the type.
--   This could happen with a phantom type for modulus and a <tt>run</tt>
--   function like <a>runST</a>. Then operations with non-matching moduli
--   could be detected at compile time and <a>zero</a> and <a>one</a> could
--   be generated with the correct modulus. An alternative trial can be
--   found in module ResidueClassMaybe.
data T a
Cons :: !a -> !a -> T a
modulus :: T a -> !a
representative :: T a -> !a
factorPrec :: Int

-- | <tt>r /: m</tt> is the residue class containing <tt>r</tt> with
--   respect to the modulus <tt>m</tt>
(/:) :: C a => a -> a -> T a

-- | Check if two residue classes share the same modulus
isCompatible :: Eq a => T a -> T a -> Bool
maybeCompatible :: Eq a => T a -> T a -> Maybe a
fromRepresentative :: C a => a -> a -> T a
lift1 :: Eq a => (a -> a -> a) -> T a -> T a
lift2 :: Eq a => (a -> a -> a -> a) -> T a -> T a -> T a
errIncompat :: a
zero :: C a => a -> T a
one :: C a => a -> T a
fromInteger :: C a => a -> Integer -> T a
instance (Eq a, C a) => C (T a)
instance (Eq a, C a) => C (T a)
instance (Eq a, C a) => C (T a)
instance C a => C (T a)
instance Eq a => Eq (T a)
instance (Read a, C a) => Read (T a)
instance Show a => Show (T a)

module Number.ResidueClass.Maybe

-- | Here we try to provide implementations for <a>zero</a> and <a>one</a>
--   by making the modulus optional. We have to provide non-modulus
--   operations for the cases where both operands have Nothing modulus.
--   This is problematic since operations like '(/)' depend essentially on
--   the modulus.
--   
--   A working version with disabled <a>zero</a> and <a>one</a> can be
--   found ResidueClass.
data T a
Cons :: !(Maybe a) -> !a -> T a

-- | the modulus can be Nothing to denote a generic constant like
--   <a>zero</a> and <a>one</a> which could not be bound to a specific
--   modulus so far
modulus :: T a -> !(Maybe a)
representative :: T a -> !a

-- | <tt>r /: m</tt> is the residue class containing <tt>r</tt> with
--   respect to the modulus <tt>m</tt>
(/:) :: C a => a -> a -> T a
matchMaybe :: Maybe a -> Maybe a -> Maybe a
isCompatibleMaybe :: Eq a => Maybe a -> Maybe a -> Bool

-- | Check if two residue classes share the same modulus
isCompatible :: Eq a => T a -> T a -> Bool
lift2 :: Eq a => (a -> a -> a -> a) -> (a -> a -> a) -> (T a -> T a -> T a)
instance Show a => Show (T a)
instance Read a => Read (T a)
instance (Eq a, C a) => C (T a)
instance (Eq a, C a) => C (T a)
instance (Eq a, C a, C a) => Eq (T a)

module Number.ResidueClass.Reader

-- | T is a Reader monad but does not need functional dependencies like
--   that from the Monad Transformer Library.
newtype T a b
Cons :: (a -> b) -> T a b
toFunc :: T a b -> a -> b
concrete :: a -> T a b -> b
fromRepresentative :: C a => a -> T a a
getZero :: C a => T a a
getOne :: C a => T a a
fromInteger :: C a => Integer -> T a a
getAdd :: C a => T a (a -> a -> a)
getSub :: C a => T a (a -> a -> a)
getNeg :: C a => T a (a -> a)
getAdditiveVars :: C a => T a (a, a -> a -> a, a -> a -> a, a -> a)
getMul :: C a => T a (a -> a -> a)
getRingVars :: C a => T a (a, a -> a -> a)
getDivide :: C a => T a (a -> a -> a)
getRecip :: C a => T a (a -> a)
getFieldVars :: C a => T a (a -> a -> a, a -> a)
monadExample :: C a => T a [a]
runExample :: [Integer]
instance Monad (T a)
instance Applicative (T a)
instance Functor (T a)


-- | Abstract Physical Units
module Number.Physical.Unit

-- | A Unit.T is a sparse vector with integer entries Each map n-&gt;m
--   means that the unit of the n-th dimension is given m times.
--   
--   Example: Let the quantity of length (meter, m) be the zeroth dimension
--   and let the quantity of time (second, s) be the first dimension, then
--   the composed unit <tt>m/s^2</tt> corresponds to the Map
--   <tt>[(0,1),(1,-2)]</tt>.
--   
--   In future I want to have more abstraction here, e.g. a type class from
--   the Edison project that abstracts from the underlying implementation.
--   Then one can easily switch between Arrays, Binary trees (like Map) and
--   what know I.
type T i = Map i Int

-- | The neutral Unit.T
scalar :: T i

-- | Test for the neutral Unit.T
isScalar :: T i -> Bool

-- | Convert a List to sparse Map representation Example: [-1,0,-2] -&gt;
--   [(0,-1),(2,-2)]
fromVector :: (Enum i, Ord i) => [Int] -> T i

-- | Convert Map to a List
toVector :: (Enum i, Ord i) => T i -> [Int]
ratScale :: T Int -> T i -> T i
ratScaleMaybe :: T Int -> T i -> Maybe (T i)
ratScaleMaybe2 :: T Int -> T i -> Map i (Maybe Int)


-- | Tools for creating a data base of physical units and for extracting
--   data from it
module Number.Physical.UnitDatabase
type T i a = [UnitSet i a]
data InitUnitSet i a
InitUnitSet :: T i -> Bool -> [InitScale a] -> InitUnitSet i a
initUnit :: InitUnitSet i a -> T i
initIndependent :: InitUnitSet i a -> Bool
initScales :: InitUnitSet i a -> [InitScale a]
data InitScale a
InitScale :: String -> a -> Bool -> Bool -> InitScale a
initSymbol :: InitScale a -> String
initMag :: InitScale a -> a
initIsUnit :: InitScale a -> Bool
initDefault :: InitScale a -> Bool

-- | An entry for a unit and there scalings.
data UnitSet i a
UnitSet :: T i -> Bool -> Int -> Bool -> [Scale a] -> UnitSet i a
unit :: UnitSet i a -> T i
independent :: UnitSet i a -> Bool
defScaleIx :: UnitSet i a -> Int

-- | If True the symbols must be preceded with a <a>/</a>. Though it sounds
--   like an attribute of Scale it must be the same for all scales and we
--   need it to sort positive powered unitsets to the front of the list of
--   unit components.
reciprocal :: UnitSet i a -> Bool
scales :: UnitSet i a -> [Scale a]

-- | A common scaling for a unit.
data Scale a
Scale :: String -> a -> Scale a
symbol :: Scale a -> String
magnitude :: Scale a -> a
extractOne :: [a] -> a
initScale :: String -> a -> Bool -> Bool -> InitScale a
initUnitSet :: T i -> Bool -> [InitScale a] -> InitUnitSet i a
createScale :: InitScale a -> Scale a
createUnitSet :: InitUnitSet i a -> UnitSet i a
showableUnit :: InitUnitSet i a -> Maybe (InitUnitSet i a)

-- | Raise all scales of a unit and the unit itself to the n-th power
powerOfUnitSet :: (Ord i, C a) => Int -> UnitSet i a -> UnitSet i a
powerOfScale :: C a => Int -> Scale a -> Scale a
showExp :: Int -> String

-- | Reorder the unit components in a way that the units with positive
--   exponents lead the list.
positiveToFront :: [UnitSet i a] -> [UnitSet i a]

-- | Decompose a complex unit into common ones
decompose :: (Ord i, C a) => T i -> T i a -> [UnitSet i a]
findIndep :: Eq i => T i -> T i a -> Maybe (UnitSet i a)
findClosest :: (Ord i, C a) => T i -> T i a -> UnitSet i a
evalDist :: (Ord i, C a) => T i -> T i a -> [(UnitSet i a, Int)]
findBestExp :: Ord i => T i -> T i -> (Int, Int)

-- | Find the exponent that lead to minimal distance Since the list is
--   infinite <a>maximum</a> will fail but the sequence is convex and thus
--   we can abort when the distance stop falling
findMinExp :: [(Int, Int)] -> (Int, Int)
distLE :: (Int, Int) -> (Int, Int) -> Bool
distances :: Ord i => T i -> [(Int, T i)] -> [(Int, Int)]
listMultiples :: (T i -> T i) -> Int -> [(Int, T i)]
instance Show a => Show (Scale a)
instance (Show i, Show a) => Show (UnitSet i a)


-- | Special physical units: SI unit system
module Number.SI.Unit
data Dimension
Length :: Dimension
Time :: Dimension
Mass :: Dimension
Charge :: Dimension
Angle :: Dimension
Temperature :: Dimension
Information :: Dimension

-- | Some common quantity classes.
angle :: T Dimension

-- | Some common quantity classes.
dataRate :: T Dimension

-- | Some common quantity classes.
information :: T Dimension

-- | Some common quantity classes.
temperature :: T Dimension

-- | Some common quantity classes.
capacitance :: T Dimension

-- | Some common quantity classes.
resistance :: T Dimension

-- | Some common quantity classes.
voltage :: T Dimension

-- | Some common quantity classes.
current :: T Dimension

-- | Some common quantity classes.
charge :: T Dimension

-- | Some common quantity classes.
power :: T Dimension

-- | Some common quantity classes.
energy :: T Dimension

-- | Some common quantity classes.
pressure :: T Dimension

-- | Some common quantity classes.
force :: T Dimension

-- | Some common quantity classes.
mass :: T Dimension

-- | Some common quantity classes.
acceleration :: T Dimension

-- | Some common quantity classes.
speed :: T Dimension

-- | Some common quantity classes.
frequency :: T Dimension

-- | Some common quantity classes.
time :: T Dimension

-- | Some common quantity classes.
volume :: T Dimension

-- | Some common quantity classes.
area :: T Dimension

-- | Some common quantity classes.
distance :: T Dimension

-- | Some common quantity classes.
length :: T Dimension

-- | Some common quantity classes.
angularSpeed :: T Dimension

-- | Common constants
percent :: C a => a
threeFourth :: C a => a
half :: C a => a
fourth :: C a => a

-- | Conversion factors
secondsPerMinute :: C a => a
bytesize :: C a => a
grad200 :: C a => a
deg180 :: C a => a
k2 :: C a => a

-- | Physical constants
accelerationOfEarthGravity :: C a => a
meterPerParsec :: C a => a
meterPerAstronomicUnit :: C a => a
meterPerYard :: C a => a
meterPerFoot :: C a => a
meterPerInch :: C a => a
secondsPerYear :: C a => a
secondsPerDay :: C a => a
secondsPerHour :: C a => a
radPerDeg :: C a => a
radPerGrad :: C a => a
mach :: C a => a
horsePower :: C a => a
calorien :: C a => a
electronVolt :: C a => a
speedOfLight :: C a => a

-- | Prefixes used for SI units
yocto :: C a => a
yotta :: C a => a
zetta :: C a => a
exa :: C a => a
peta :: C a => a
tera :: C a => a
giga :: C a => a
mega :: C a => a
kilo :: C a => a
hecto :: C a => a
deca :: C a => a
one :: C a => a
deci :: C a => a
centi :: C a => a
milli :: C a => a
micro :: C a => a
nano :: C a => a
pico :: C a => a
femto :: C a => a
atto :: C a => a
zepto :: C a => a

-- | UnitDatabase.T of units and their common scalings
databaseRead :: C a => T Dimension a

-- | UnitDatabase.T of units and their common scalings
databaseShow :: C a => T Dimension a
database :: C a => [InitUnitSet Dimension a]
instance Eq Dimension
instance Ord Dimension
instance Enum Dimension
instance Show Dimension


-- | A wrapper that provides instances of Haskell 98 and NumericPrelude
--   numeric type classes for types that have Haskell 98 instances.
module MathObj.Wrapper.Haskell98

-- | This makes a type usable in the NumericPrelude framework that was
--   initially implemented for Haskell98 typeclasses. E.g. if <tt>a</tt> is
--   in class <a>Num</a>, then <tt>T a</tt> is both in class <a>Num</a> and
--   in <a>C</a>.
--   
--   You can even lift container types. If <tt>Polynomial a</tt> is in
--   <a>Num</a> for all types <tt>a</tt> that are in <a>Num</a>, then <tt>T
--   (Polynomial (MathObj.Wrapper.NumericPrelude.T a))</tt> is in <a>C</a>
--   for all types <tt>a</tt> that are in <a>C</a>.
newtype T a
Cons :: a -> T a
decons :: T a -> a
lift1 :: (a -> b) -> T a -> T b
lift2 :: (a -> b -> c) -> T a -> T b -> T c
unliftF1 :: Functor f => (f (T a) -> f (T b)) -> f a -> f b
unliftF2 :: Functor f => (f (T a) -> f (T b) -> f (T c)) -> f a -> f b -> f c
unimplemented :: String -> a
instance Show a => Show (T a)
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance Ix a => Ix (T a)
instance Bounded a => Bounded (T a)
instance Enum a => Enum (T a)
instance Num a => Num (T a)
instance Integral a => Integral (T a)
instance Fractional a => Fractional (T a)
instance Floating a => Floating (T a)
instance Real a => Real (T a)
instance RealFrac a => RealFrac (T a)
instance RealFloat a => RealFloat (T a)
instance RealFloat a => C (T a)
instance Real a => C (T a)
instance Integral a => C (T a)
instance Integral a => C (T a)
instance RealFloat a => C (T a)
instance RealFrac a => C (T a)
instance RealFrac a => C (T a)
instance Num a => C (T a)
instance (Eq a, Num a) => C (T a)
instance Integral a => C (T a)
instance Integral a => C (T a)
instance Integral a => C (T a)
instance Floating a => C (T a)
instance Floating a => C (T a)
instance Fractional a => C (T a)
instance Num a => C (T a)
instance Num a => C (T a)
instance Functor T


-- | Polynomials and rational functions in a single indeterminate.
--   Polynomials are represented by a list of coefficients. All non-zero
--   coefficients are listed, but there may be extra '0's at the end.
--   
--   Usage: Say you have the ring of <a>Integer</a> numbers and you want to
--   add a transcendental element <tt>x</tt>, that is an element, which
--   does not allow for simplifications. More precisely, for all positive
--   integer exponents <tt>n</tt> the power <tt>x^n</tt> cannot be
--   rewritten as a sum of powers with smaller exponents. The element
--   <tt>x</tt> must be represented by the polynomial <tt>[0,1]</tt>.
--   
--   In principle, you can have more than one transcendental element by
--   using polynomials whose coefficients are polynomials as well. However,
--   most algorithms on multi-variate polynomials prefer a different
--   (sparse) representation, where the ordering of elements is not so
--   fixed.
--   
--   If you want division, you need <a>Number.Ratio</a>s of polynomials
--   with coefficients from a <a>Algebra.Field</a>.
--   
--   You can also compute with an algebraic element, that is an element
--   which satisfies an algebraic equation like <tt>x^3-x-1==0</tt>.
--   Actually, powers of <tt>x</tt> with exponents above <tt>3</tt> can be
--   simplified, since it holds <tt>x^3==x+1</tt>. You can perform these
--   computations with <a>Number.ResidueClass</a> of polynomials, where the
--   divisor is the polynomial equation that determines <tt>x</tt>. If the
--   polynomial is irreducible (in our case <tt>x^3-x-1</tt> cannot be
--   written as a non-trivial product) then the residue classes also allow
--   unrestricted division (except by zero, of course). That is, using
--   residue classes of polynomials you can work with roots of polynomial
--   equations without representing them by radicals (powers with
--   fractional exponents). It is well-known, that roots of polynomials of
--   degree above 4 may not be representable by radicals.
module MathObj.Polynomial
data T a
fromCoeffs :: [a] -> T a
coeffs :: T a -> [a]
degree :: C a => T a -> Maybe Int
showsExpressionPrec :: (Show a, C a, C a) => Int -> String -> T a -> String -> String
const :: a -> T a
evaluate :: C a => T a -> a -> a

-- | Here the coefficients are vectors, for example the coefficients are
--   real and the coefficents are real vectors.
evaluateCoeffVector :: C a v => T v -> a -> v

-- | Here the argument is a vector, for example the coefficients are
--   complex numbers or square matrices and the coefficents are reals.
evaluateArgVector :: (C a v, C v) => T a -> v -> v
collinear :: (Eq a, C a) => T a -> T a -> Bool
integrate :: C a => a -> T a -> T a

-- | <a>compose</a> is the functional composition of polynomials.
--   
--   It fulfills <tt> eval x . eval y == eval (compose x y) </tt>
compose :: C a => T a -> T a -> T a
fromRoots :: C a => [a] -> T a
reverse :: C a => T a -> T a
translate :: C a => a -> T a -> T a
dilate :: C a => a -> T a -> T a
shrink :: C a => a -> T a -> T a
instance Fractional a => Fractional (T a)
instance Num a => Num (T a)
instance (Arbitrary a, C a) => Arbitrary (T a)
instance C a => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance C a => C (T a)
instance (C a, C a b) => C a (T b)
instance C a b => C a (T b)
instance C T
instance C a => C (T a)
instance C a => C (T a)
instance (C a, C a) => C (T a)
instance (Eq a, C a) => Eq (T a)
instance Show a => Show (T a)
instance Functor T


-- | For a multi-set of numbers, we describe a sequence of the sums of
--   powers of the numbers in the set. These can be easily converted to
--   polynomials and back. Thus they provide an easy way for computations
--   on the roots of a polynomial.
module MathObj.PowerSum
newtype T a
Cons :: [a] -> T a
sums :: T a -> [a]
lift0 :: [a] -> T a
lift1 :: ([a] -> [a]) -> (T a -> T a)
lift2 :: ([a] -> [a] -> [a]) -> (T a -> T a -> T a)
const :: C a => a -> T a
fromElemSym :: (Eq a, C a) => [a] -> [a]
divOneFlip :: (Eq a, C a) => [a] -> [a] -> [a]
fromElemSymDenormalized :: (C a, C a) => [a] -> [a]
toElemSym :: (C a, C a) => [a] -> [a]
toElemSymInt :: (C a, C a) => [a] -> [a]
fromPolynomial :: (C a, C a) => T a -> [a]
elemSymFromPolynomial :: C a => T a -> [a]
binomials :: C a => [[a]]
appPrec :: Int
add :: C a => [a] -> [a] -> [a]
mul :: C a => [a] -> [a] -> [a]
pow :: Integer -> [a] -> [a]
root :: C a => Integer -> [a] -> [a]
approxSeries :: C a b => [b] -> [a] -> [b]
propOp :: (Eq a, C a, C a) => ([a] -> [a] -> [a]) -> (a -> a -> a) -> [a] -> [a] -> [Bool]
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a v, C v) => C a (T v)
instance (C a v, C v) => C a (T v)
instance C a => C (T a)
instance C a => C (T a)
instance Show a => Show (T a)

module MathObj.RefinementMask2
data T a
coeffs :: T a -> [a]
fromCoeffs :: [a] -> T a

-- | Determine mask by Gauss elimination.
--   
--   R - alternating binomial coefficients L - differences of translated
--   polynomials in columns
--   
--   p2 = L * R^(-1) * m
--   
--   R * L^(-1) * p2 = m
fromPolynomial :: C a => T a -> T a

-- | If the mask does not sum up to a power of <tt>1/2</tt> then the
--   function returns <a>Nothing</a>.
toPolynomial :: C a => T a -> Maybe (T a)
toPolynomialFast :: C a => T a -> Maybe (T a)
refinePolynomial :: C a => T a -> T a -> T a

-- | Convolve polynomials via refinement mask.
--   
--   (mask x + ux*(-1,1)^degree x) * (mask y + uy*(-1,1)^degree y)
convolvePolynomial :: C a => T a -> T a -> T a
convolveTruncatedPowerPolynomials :: C a => T a -> T a -> T a
instance (Arbitrary a, C a) => Arbitrary (T a)
instance Show a => Show (T a)
instance Functor T


-- | Computations on the set of roots of a polynomial. These are
--   represented as the list of their elementar symmetric terms. The
--   difference between a polynomial and the list of elementar symmetric
--   terms is the reversed order and the alternated signs.
--   
--   Cf. <i>MathObj.PowerSum</i> .
module MathObj.RootSet
newtype T a
Cons :: [a] -> T a
coeffs :: T a -> [a]
lift0 :: [a] -> T a
lift1 :: ([a] -> [a]) -> (T a -> T a)
lift2 :: ([a] -> [a] -> [a]) -> (T a -> T a -> T a)
const :: C a => a -> T a
toPolynomial :: T a -> T a
fromPolynomial :: T a -> T a
toPowerSums :: (C a, C a) => [a] -> [a]
fromPowerSums :: (C a, C a) => [a] -> [a]

-- | cf. <a>mulLinearFactor</a>
addRoot :: C a => a -> [a] -> [a]
fromRoots :: C a => [a] -> [a]
liftPowerSum1Gen :: ([a] -> [a]) -> ([a] -> [a]) -> ([a] -> [a]) -> ([a] -> [a])
liftPowerSum2Gen :: ([a] -> [a]) -> ([a] -> [a]) -> ([a] -> [a] -> [a]) -> ([a] -> [a] -> [a])
liftPowerSum1 :: (C a, C a) => ([a] -> [a]) -> ([a] -> [a])
liftPowerSum2 :: (C a, C a) => ([a] -> [a] -> [a]) -> ([a] -> [a] -> [a])
liftPowerSumInt1 :: (C a, Eq a, C a) => ([a] -> [a]) -> ([a] -> [a])
liftPowerSumInt2 :: (C a, Eq a, C a) => ([a] -> [a] -> [a]) -> ([a] -> [a] -> [a])
appPrec :: Int
add :: (C a, C a) => [a] -> [a] -> [a]
addInt :: (C a, Eq a, C a) => [a] -> [a] -> [a]
mul :: (C a, C a) => [a] -> [a] -> [a]
mulInt :: (C a, Eq a, C a) => [a] -> [a] -> [a]
pow :: (C a, C a) => Integer -> [a] -> [a]
powInt :: (C a, Eq a, C a) => Integer -> [a] -> [a]

-- | Given an approximation of a root, the degree of the polynomial and
--   maximum value of coefficients, find candidates of polynomials that
--   have approximately this root and show the actual value of the
--   polynomial at the given root approximation.
--   
--   This algorithm runs easily into a stack overflow, I do not know why.
--   We may also employ a more sophisticated integer relation algorithm,
--   like PSLQ and friends.
approxPolynomial :: C a => Int -> Integer -> a -> (a, T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance Show a => Show (T a)

module Number.Root

-- | The root degree must be positive. This way we can implement
--   multiplication using only multiplication from type <tt>a</tt>.
data T a
Cons :: Integer -> a -> T a

-- | When you use <tt>fmap</tt> you must assert that <tt>forall n. fmap f
--   (Cons d x) == fmap f (Cons (n*d) (x^n))</tt>
fromNumber :: a -> T a
toNumber :: C a => T a -> a
toRootSet :: C a => T a -> T a
commonDegree :: C a => T a -> T a -> T (a, a)
mul :: C a => T a -> T a -> T a
div :: C a => T a -> T a -> T a
recip :: C a => T a -> T a

-- | exponent must be non-negative
cardinalPower :: C a => Integer -> T a -> T a

-- | exponent can be negative
integerPower :: C a => Integer -> T a -> T a
rationalPower :: C a => Rational -> T a -> T a

-- | exponent must be positive
root :: C a => Integer -> T a -> T a
sqrt :: C a => T a -> T a
instance Show a => Show (T a)
instance (Ord a, C a) => Ord (T a)
instance (Eq a, C a) => Eq (T a)
instance Functor T


-- | Complex numbers.
module Number.Complex

-- | Complex numbers are an algebraic type.
data T a
imaginaryUnit :: C a => T a
fromReal :: C a => a -> T a

-- | Construct a complex number from real and imaginary part.
(+:) :: a -> a -> T a

-- | Construct a complex number with negated imaginary part.
(-:) :: C a => a -> a -> T a

-- | Scale a complex number by a real number.
scale :: C a => a -> T a -> T a

-- | Exponential of a complex number with minimal type class constraints.
exp :: C a => T a -> T a

-- | Turn the point one quarter to the right.
quarterLeft :: C a => T a -> T a

-- | Turn the point one quarter to the right.
quarterRight :: C a => T a -> T a

-- | Form a complex number from polar components of magnitude and phase.
fromPolar :: C a => a -> a -> T a

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: C a => a -> T a

-- | Scale a complex number to magnitude 1.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
signum :: (C a, C a) => T a -> T a
signumNorm :: (C a, C a a, C a) => T a -> T a

-- | The function <a>toPolar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   nonnegative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
toPolar :: (C a, C a) => T a -> (a, a)
magnitude :: C a => T a -> a
magnitudeSqr :: C a => T a -> a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: (C a, C a) => T a -> a

-- | The conjugate of a complex number.
conjugate :: C a => T a -> T a
propPolar :: (C a, C a) => T a -> Bool

-- | We like to build the Complex Algebraic instance on top of the
--   Algebraic instance of the scalar type. This poses no problem to
--   <a>sqrt</a>. However, <a>root</a> requires computing the complex
--   argument which is a transcendent operation. In order to keep the type
--   class dependencies clean for more sophisticated algebraic number
--   types, we introduce a type class which actually performs the radix
--   operation.
class C a => Power a
power :: Power a => Rational -> T a -> T a
defltPow :: (C a, C a) => Rational -> T a -> T a
instance Eq a => Eq (T a)
instance (Floating a, Eq a) => Fractional (T a)
instance (Floating a, Eq a) => Num (T a)
instance (C a, C a, C a, Power a) => C (T a)
instance (C a, C a, Power a) => C (T a)
instance Power Double
instance Power Float
instance C a => C (T a)
instance (Ord a, C a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance C a => C (T a)
instance (Show v, C v, C v, C a v) => C a (T v)
instance (Ord a, C a v) => C a (T v)
instance (C a, Sqr a b) => C a (T b)
instance Sqr a b => Sqr a (T b)
instance (C a, C a v) => C a (T v)
instance C a b => C a (T b)
instance C a b => C a (T b)
instance C T
instance (C a, C a, C a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance Storable a => Storable (T a)
instance Arbitrary a => Arbitrary (T a)
instance Functor T
instance Read a => Read (T a)
instance Show a => Show (T a)


-- | Polynomials with negative and positive exponents.
module MathObj.LaurentPolynomial

-- | Polynomial including negative exponents
data T a
Cons :: Int -> [a] -> T a
expon :: T a -> Int
coeffs :: T a -> [a]
const :: a -> T a
(!) :: C a => T a -> Int -> a
fromCoeffs :: [a] -> T a
fromShiftCoeffs :: Int -> [a] -> T a
fromPolynomial :: T a -> T a
fromPowerSeries :: T a -> T a
bounds :: T a -> (Int, Int)
shift :: Int -> T a -> T a

-- | <i>Deprecated: In order to avoid confusion with Polynomial.translate,
--   use <a>shift</a> instead</i>
translate :: Int -> T a -> T a
appPrec :: Int
add :: C a => T a -> T a -> T a
series :: C a => [T a] -> T a

-- | Add lists of numbers respecting a relative shift between the starts of
--   the lists. The shifts must be non-negative. The list of relative
--   shifts is one element shorter than the list of summands. Infinitely
--   many summands are permitted, provided that runs of zero shifts are all
--   finite.
--   
--   We could add the lists either with <a>foldl</a> or with <a>foldr</a>,
--   <a>foldl</a> would be straightforward, but more time consuming
--   (quadratic time) whereas foldr is not so obvious but needs only linear
--   time.
--   
--   (stars denote the coefficients, frames denote what is contained in the
--   interim results) <a>foldl</a> sums this way:
--   
--   <pre>
--   | | | *******************************
--   | | +--------------------------------
--   | |          ************************
--   | +----------------------------------
--   |                        ************
--   +------------------------------------
--   </pre>
--   
--   I.e. <a>foldl</a> would use much time find the time differences by
--   successive subtraction 1.
--   
--   <a>foldr</a> mixes this way:
--   
--   <pre>
--   +--------------------------------
--   | *******************************
--   |      +-------------------------
--   |      | ************************
--   |      |           +-------------
--   |      |           | ************
--   </pre>
addShiftedMany :: C a => [Int] -> [[a]] -> [a]
addShifted :: C a => Int -> [a] -> [a] -> [a]
negate :: C a => T a -> T a
sub :: C a => T a -> T a -> T a
mul :: C a => T a -> T a -> T a
div :: (C a, C a) => T a -> T a -> T a
divExample :: T Rational

-- | Two polynomials may be stored differently. This function checks
--   whether two values of type <tt>LaurentPolynomial</tt> actually
--   represent the same polynomial.
equivalent :: (Eq a, C a) => T a -> T a -> Bool
identical :: Eq a => T a -> T a -> Bool

-- | Check whether a Laurent polynomial has only the absolute term, that
--   is, it represents the constant polynomial.
isAbsolute :: C a => T a -> Bool

-- | p(z) -&gt; p(-z)
alternate :: C a => T a -> T a

-- | p(z) -&gt; p(1/z)
reverse :: T a -> T a

-- | p(exp(i·x)) -&gt; conjugate(p(exp(i·x)))
--   
--   If you interpret <tt>(p*)</tt> as a linear operator on the space of
--   Laurent polynomials, then <tt>(adjoint p *)</tt> is the adjoint
--   operator.
adjoint :: C a => T (T a) -> T (T a)
instance (Eq a, C a) => Eq (T a)
instance (C a, C a) => C (T a)
instance C a => C (T a)
instance (C a, C a b) => C a (T b)
instance C a b => C a (T b)
instance C T
instance C a => C (T a)
instance Show a => Show (T a)
instance Functor T


-- | Exact Real Arithmetic - Computable reals. Inspired by ''The most
--   unreliable technique for computing pi.'' See also
--   <a>http://www.haskell.org/haskellwiki/Exact_real_arithmetic</a> .
module Number.Positional
type T = (Exponent, Mantissa)
type FixedPoint = (Integer, Mantissa)
type Mantissa = [Digit]
type Digit = Int
type Exponent = Int
type Basis = Int
moveToZero :: Basis -> Digit -> (Digit, Digit)
checkPosDigit :: Basis -> Digit -> Digit
checkDigit :: Basis -> Digit -> Digit

-- | Converts all digits to non-negative digits, that is the usual
--   positional representation. However the conversion will fail when the
--   remaining digits are all zero. (This cannot be improved!)
nonNegative :: Basis -> T -> T

-- | Requires, that no digit is <tt>(basis-1)</tt> or <tt>(1-basis)</tt>.
--   The leading digit might be negative and might be <tt>-basis</tt> or
--   <tt>basis</tt>.
nonNegativeMant :: Basis -> Mantissa -> Mantissa

-- | May prepend a digit.
compress :: Basis -> T -> T

-- | Compress first digit. May prepend a digit.
compressFirst :: Basis -> T -> T

-- | Does not prepend a digit.
compressMant :: Basis -> Mantissa -> Mantissa

-- | Compress second digit. Sometimes this is enough to keep the digits in
--   the admissible range. Does not prepend a digit.
compressSecondMant :: Basis -> Mantissa -> Mantissa
prependDigit :: Basis -> T -> T

-- | Eliminate leading zero digits. This will fail for zero.
trim :: T -> T

-- | Trim until a minimum exponent is reached. Safe for zeros.
trimUntil :: Exponent -> T -> T
trimOnce :: T -> T

-- | Accept a high leading digit for the sake of a reduced exponent. This
--   eliminates one leading digit. Like <a>pumpFirst</a> but with exponent
--   management.
decreaseExp :: Basis -> T -> T

-- | Merge leading and second digit. This is somehow an inverse of
--   <a>compressMant</a>.
pumpFirst :: Basis -> Mantissa -> Mantissa
decreaseExpFP :: Basis -> (Exponent, FixedPoint) -> (Exponent, FixedPoint)
pumpFirstFP :: Basis -> FixedPoint -> FixedPoint

-- | Make sure that a number with absolute value less than 1 has a (small)
--   negative exponent. Also works with zero because it chooses an
--   heuristic exponent for stopping.
negativeExp :: Basis -> T -> T
fromBaseCardinal :: Basis -> Integer -> T
fromBaseInteger :: Basis -> Integer -> T
mantissaToNum :: C a => Basis -> Mantissa -> a
mantissaFromCard :: C a => Basis -> a -> Mantissa
mantissaFromInt :: C a => Basis -> a -> Mantissa
mantissaFromFixedInt :: Basis -> Exponent -> Integer -> Mantissa
fromBaseRational :: Basis -> Rational -> T

-- | Split into integer and fractional part.
toFixedPoint :: Basis -> T -> FixedPoint
fromFixedPoint :: Basis -> FixedPoint -> T
toDouble :: Basis -> T -> Double

-- | cf. <a>floatToDigits</a>
fromDouble :: Basis -> Double -> T

-- | Only return as much digits as are contained in Double. This will
--   speedup further computations.
fromDoubleApprox :: Basis -> Double -> T
fromDoubleRough :: Basis -> Double -> T
mantLengthDouble :: Basis -> Exponent
liftDoubleApprox :: Basis -> (Double -> Double) -> T -> T
liftDoubleRough :: Basis -> (Double -> Double) -> T -> T

-- | Show a number with respect to basis <tt>10^e</tt>.
showDec :: Exponent -> T -> String
showHex :: Exponent -> T -> String
showBin :: Exponent -> T -> String
showBasis :: Basis -> Exponent -> T -> String

-- | Convert from a <tt>b</tt> basis representation to a <tt>b^e</tt>
--   basis.
--   
--   Works well with every exponent.
powerBasis :: Basis -> Exponent -> T -> T

-- | Convert from a <tt>b^e</tt> basis representation to a <tt>b</tt>
--   basis.
--   
--   Works well with every exponent.
rootBasis :: Basis -> Exponent -> T -> T

-- | Convert between arbitrary bases. This conversion is expensive
--   (quadratic time).
fromBasis :: Basis -> Basis -> T -> T
fromBasisMant :: Basis -> Basis -> Mantissa -> Mantissa

-- | The basis must be at least ***. Note: Equality cannot be asserted in
--   finite time on infinite precise numbers. If you want to assert, that a
--   number is below a certain threshold, you should not call this routine
--   directly, because it will fail on equality. Better round the numbers
--   before comparison.
cmp :: Basis -> T -> T -> Ordering
lessApprox :: Basis -> Exponent -> T -> T -> Bool
trunc :: Exponent -> T -> T
equalApprox :: Basis -> Exponent -> T -> T -> Bool

-- | If all values are completely defined, then it holds
--   
--   <pre>
--   if b then x else y == ifLazy b x y
--   </pre>
--   
--   However if <tt>b</tt> is undefined, then it is at least known that the
--   result is between <tt>x</tt> and <tt>y</tt>.
ifLazy :: Basis -> Bool -> T -> T -> T

-- | <pre>
--   mean2 b (x0,x1) (y0,y1)
--   </pre>
--   
--   computes <tt> round ((x0.x1 + y0.y1)/2) </tt>, where <tt>x0.x1</tt>
--   and <tt>y0.y1</tt> are positional rational numbers with respect to
--   basis <tt>b</tt>
mean2 :: Basis -> (Digit, Digit) -> (Digit, Digit) -> Digit
withTwoMantissas :: Mantissa -> Mantissa -> a -> ((Digit, Mantissa) -> (Digit, Mantissa) -> a) -> a
align :: Basis -> Exponent -> T -> T

-- | Get the mantissa in such a form that it fits an expected exponent.
--   
--   <tt>x</tt> and <tt>(e, alignMant b e x)</tt> represent the same
--   number.
alignMant :: Basis -> Exponent -> T -> Mantissa
absolute :: T -> T
absMant :: Mantissa -> Mantissa
fromLaurent :: T Digit -> T
toLaurent :: T -> T Digit
liftLaurent2 :: (T Digit -> T Digit -> T Digit) -> (T -> T -> T)
liftLaurentMany :: ([T Digit] -> T Digit) -> ([T] -> T)

-- | Add two numbers but do not eliminate leading zeros.
add :: Basis -> T -> T -> T
sub :: Basis -> T -> T -> T
neg :: Basis -> T -> T

-- | Add at most <tt>basis</tt> summands. More summands will violate the
--   allowed digit range.
addSome :: Basis -> [T] -> T

-- | Add many numbers efficiently by computing sums of sub lists with only
--   little carry propagation.
addMany :: Basis -> [T] -> T
type Series = [(Exponent, T)]

-- | Add an infinite number of numbers. You must provide a list of estimate
--   of the current remainders. The estimates must be given as exponents of
--   the remainder. If such an exponent is too small, the summation will be
--   aborted. If exponents are too big, computation will become
--   inefficient.
series :: Basis -> Series -> T
seriesPlain :: Basis -> Series -> T

-- | Like <a>splitAt</a>, but it pads with zeros if the list is too short.
--   This way it preserves <tt> length (fst (splitAtPadZero n xs)) == n
--   </tt>
splitAtPadZero :: Int -> Mantissa -> (Mantissa, Mantissa)
splitAtMatchPadZero :: [()] -> Mantissa -> (Mantissa, Mantissa)

-- | help showing series summands
truncSeriesSummands :: Series -> Series
scale :: Basis -> Digit -> T -> T
scaleSimple :: Basis -> T -> T
scaleMant :: Basis -> Digit -> Mantissa -> Mantissa
mulSeries :: Basis -> T -> T -> Series

-- | For obtaining n result digits it is mathematically sufficient to know
--   the first (n+1) digits of the operands. However this implementation
--   needs (n+2) digits, because of calls to <a>compress</a> in both
--   <a>scale</a> and <a>series</a>. We should fix that.
mul :: Basis -> T -> T -> T

-- | Undefined if the divisor is zero - of course. Because it is impossible
--   to assert that a real is zero, the routine will not throw an error in
--   general.
--   
--   ToDo: Rigorously derive the minimal required magnitude of the leading
--   divisor digit.
divide :: Basis -> T -> T -> T
divMant :: Basis -> Mantissa -> Mantissa -> Mantissa
divMantSlow :: Basis -> Mantissa -> Mantissa -> Mantissa
reciprocal :: Basis -> T -> T

-- | Fast division for small integral divisors, which occur for instance in
--   summands of power series.
divIntMant :: Basis -> Digit -> Mantissa -> Mantissa
divIntMantInf :: Basis -> Digit -> Mantissa -> Mantissa
divInt :: Basis -> Digit -> T -> T
sqrt :: Basis -> T -> T
sqrtDriver :: Basis -> (Basis -> FixedPoint -> Mantissa) -> T -> T
sqrtMant :: Basis -> Mantissa -> Mantissa

-- | Square root.
--   
--   We need a leading digit of type Integer, because we have to collect up
--   to 4 digits. This presentation can also be considered as
--   <a>FixedPoint</a>.
--   
--   ToDo: Rigorously derive the minimal required magnitude of the leading
--   digit of the root.
--   
--   Mathematically the <tt>n</tt>th digit of the square root depends
--   roughly only on the first <tt>n</tt> digits of the input. This is
--   because <tt>sqrt (1+eps) <a>equalApprox</a> 1 + eps/2</tt>. However
--   this implementation requires <tt>2*n</tt> input digits for emitting
--   <tt>n</tt> digits. This is due to the repeated use of
--   <a>compressMant</a>. It would suffice to fully compress only every
--   <tt>basis</tt>th iteration (digit) and compress only the second
--   leading digit in each iteration.
--   
--   Can the involved operations be made lazy enough to solve <tt>y =
--   (x+frac)^2</tt> by <tt>frac = (y-x^2-frac^2) / (2*x)</tt> ?
sqrtFP :: Basis -> FixedPoint -> Mantissa
sqrtNewton :: Basis -> T -> T

-- | Newton iteration doubles the number of correct digits in every step.
--   Thus we process the data in chunks of sizes of powers of two. This way
--   we get fastest computation possible with Newton but also more
--   dependencies on input than necessary. The question arises whether this
--   implementation still fits the needs of computational reals. The input
--   is requested as larger and larger chunks, and the input itself might
--   be computed this way, e.g. a repeated square root. Requesting one
--   digit too much, requires the double amount of work for the input
--   computation, which in turn multiplies time consumption by a factor of
--   four, and so on.
--   
--   Optimal fast implementation of one routine does not preserve fast
--   computation of composed computations.
--   
--   The routine assumes, that the integer parts is at least <tt>b^2.</tt>
sqrtFPNewton :: Basis -> FixedPoint -> Mantissa

-- | List.inits is defined by <tt>inits = foldr (x ys -&gt; [] : map (x:)
--   ys) [[]]</tt>
--   
--   This is too strict for our application.
--   
--   <pre>
--   Prelude&gt; List.inits (0:1:2:undefined)
--   [[],[0],[0,1]*** Exception: Prelude.undefined
--   </pre>
--   
--   The following routine is more lazy than <a>inits</a> and even lazier
--   than <a>inits</a> from <tt>utility-ht</tt> package, but it is
--   restricted to infinite lists. This degree of laziness is needed for
--   <tt>sqrtFP</tt>.
--   
--   <pre>
--   Prelude&gt; lazyInits (0:1:2:undefined)
--   [[],[0],[0,1],[0,1,2],[0,1,2,*** Exception: Prelude.undefined
--   </pre>
lazyInits :: [a] -> [[a]]
expSeries :: Basis -> T -> Series

-- | Absolute value of argument should be below 1.
expSmall :: Basis -> T -> T
expSeriesLazy :: Basis -> T -> Series
expSmallLazy :: Basis -> T -> T
exp :: Basis -> T -> T
intPower :: Basis -> Integer -> T -> T -> T -> T
cardPower :: Basis -> Integer -> T -> T -> T

-- | Residue estimates will only hold for exponents with absolute value
--   below one.
--   
--   The computation is based on <a>Int</a>, thus the denominator should
--   not be too big. (Say, at most 1000 for 1000000 digits.)
--   
--   It is not optimal to split the power into pure root and pure power
--   (that means, with integer exponents). The root series can nicely
--   handle all exponents, but for exponents above 1 the series summands
--   rises at the beginning and thus make the residue estimate complicated.
--   For powers with integer exponents the root series turns into the
--   binomial formula, which is just a complicated way to compute a power
--   which can also be determined by simple multiplication.
powerSeries :: Basis -> Rational -> T -> Series
powerSmall :: Basis -> Rational -> T -> T
power :: Basis -> Rational -> T -> T
root :: Basis -> Integer -> T -> T

-- | Absolute value of argument should be below 1.
cosSinhSmall :: Basis -> T -> (T, T)

-- | Absolute value of argument should be below 1.
cosSinSmall :: Basis -> T -> (T, T)

-- | Like <a>cosSinSmall</a> but converges faster. It calls
--   <tt>cosSinSmall</tt> with reduced arguments using the trigonometric
--   identities <tt> cos (4*x) = 8 * cos x ^ 2 * (cos x ^ 2 - 1) + 1 sin
--   (4*x) = 4 * sin x * cos x * (1 - 2 * sin x ^ 2) </tt>
--   
--   Note that the faster convergence is hidden by the overhead.
--   
--   The same could be achieved with a fourth power of a complex number.
cosSinFourth :: Basis -> T -> (T, T)
cosSin :: Basis -> T -> (T, T)
tan :: Basis -> T -> T
cot :: Basis -> T -> T
lnSeries :: Basis -> T -> Series
lnSmall :: Basis -> T -> T

-- | <pre>
--   x' = x - (exp x - y) / exp x
--      = x + (y * exp (-x) - 1)
--   </pre>
--   
--   First, the dependencies on low-significant places are currently much
--   more than mathematically necessary. Check <tt> *Number.Positional&gt;
--   expSmall 1000 (-1,100 : replicate 16 0 ++ [undefined])
--   (0,[1,105,171,-82,76*** Exception: Prelude.undefined </tt> Every
--   multiplication cut off two trailing digits. <tt>
--   *Number.Positional&gt; nest 8 (mul 1000 (-1,repeat 1)) (-1,100 :
--   replicate 16 0 ++ [undefined]) (-9,[101,*** Exception:
--   Prelude.undefined </tt>
--   
--   Possibly the dependencies of expSmall could be resolved by not
--   computing <tt>mul</tt> immediately but computing <tt>mul</tt> series
--   which are merged and subsequently added. But this would lead to an
--   explosion of series.
--   
--   Second, even if the dependencies of all atomic operations are reduced
--   to a minimum, the mathematical dependencies of the whole iteration
--   function are less than the sums of the parts. Lets demonstrate this
--   with the square root iteration. It is <tt> (1.4140 + 2<i>1.4140) </i>
--   2 == 1.414213578500707 (1.4149 + 2<i>1.4149) </i> 2 ==
--   1.4142137288854335 </tt> That is, the digits <tt>213</tt> do not
--   depend mathematically on <tt>x</tt> of <tt>1.414x</tt>, but their
--   computation depends. Maybe there is a glorious trick to reduce the
--   computational dependencies to the mathematical ones.
lnNewton :: Basis -> T -> T
lnNewton' :: Basis -> T -> T
ln :: Basis -> T -> T

-- | This is an inverse of <a>cosSin</a>, also known as <tt>atan2</tt> with
--   flipped arguments. It's very slow because of the computation of sinus
--   and cosinus. However, because it uses the <a>atan2</a> implementation
--   as estimator, the final application of arctan series should converge
--   rapidly.
--   
--   It could be certainly accelerated by not using cosSin and its fiddling
--   with pi. Instead we could analyse quadrants before calling atan2, then
--   calling cosSinSmall immediately.
angle :: Basis -> (T, T) -> T

-- | Arcus tangens of arguments with absolute value less than <tt>1 / sqrt
--   3</tt>.
arctanSeries :: Basis -> T -> Series
arctanSmall :: Basis -> T -> T

-- | Efficient computation of Arcus tangens of an argument of the form
--   <tt>1/n</tt>.
arctanStem :: Basis -> Digit -> T

-- | This implementation gets the first decimal place for free by calling
--   the arcus tangens implementation for <a>Double</a>s.
arctan :: Basis -> T -> T

-- | A classic implementation without ''cheating'' with floating point
--   implementations.
--   
--   For <tt>x &lt; 1 / sqrt 3</tt> (<tt>1 / sqrt 3 == tan (pi/6)</tt>) use
--   <tt>arctan</tt> power series. (<tt>sqrt 3</tt> is approximately
--   <tt>19/11</tt>.)
--   
--   For <tt>x &gt; sqrt 3</tt> use <tt>arctan x = pi/2 - arctan (1/x)</tt>
--   
--   For other <tt>x</tt> use
--   
--   <tt>arctan x = pi/4 - 0.5*arctan ((1-x^2)/2*x)</tt> (which follows
--   from <tt>arctan x + arctan y == arctan ((x+y) / (1-x*y))</tt> which in
--   turn follows from complex multiplication <tt>(1:+x)*(1:+y) ==
--   ((1-x*y):+(x+y))</tt>
--   
--   If <tt>x</tt> is close to <tt>sqrt 3</tt> or <tt>1 / sqrt 3</tt> the
--   computation is quite inefficient.
arctanClassic :: Basis -> T -> T
zero :: T
one :: T
minusOne :: T
eConst :: Basis -> T
recipEConst :: Basis -> T
piConst :: Basis -> T
sliceVertPair :: [a] -> [(a, a)]


-- | Quaternions
module Number.Quaternion

-- | Quaternions could be defined based on Complex numbers. However
--   quaternions are often considered as real part and three imaginary
--   parts.
data T a
fromReal :: C a => a -> T a

-- | Construct a quaternion from real and imaginary part.
(+::) :: a -> (a, a, a) -> T a

-- | Let <tt>c</tt> be a unit quaternion, then it holds <tt>similarity c
--   (0+::x) == toRotationMatrix c * x</tt>
toRotationMatrix :: C a => T a -> Array (Int, Int) a
fromRotationMatrix :: C a => Array (Int, Int) a -> T a

-- | The rotation matrix must be normalized. (I.e. no rotation with
--   scaling) The computed quaternion is not normalized.
fromRotationMatrixDenorm :: C a => Array (Int, Int) a -> T a

-- | Map a quaternion to complex valued 2x2 matrix, such that quaternion
--   addition and multiplication is mapped to matrix addition and
--   multiplication. The determinant of the matrix equals the squared
--   quaternion norm (<a>normSqr</a>). Since complex numbers can be turned
--   into real (orthogonal) matrices, a quaternion could also be converted
--   into a real matrix.
toComplexMatrix :: C a => T a -> Array (Int, Int) (T a)

-- | Revert <a>toComplexMatrix</a>.
fromComplexMatrix :: C a => Array (Int, Int) (T a) -> T a
scalarProduct :: C a => (a, a, a) -> (a, a, a) -> a
crossProduct :: C a => (a, a, a) -> (a, a, a) -> (a, a, a)

-- | The conjugate of a quaternion.
conjugate :: C a => T a -> T a

-- | Scale a quaternion by a real number.
scale :: C a => a -> T a -> T a
norm :: C a => T a -> a

-- | the same as NormedEuc.normSqr but with a simpler type class constraint
normSqr :: C a => T a -> a

-- | scale a quaternion into a unit quaternion
normalize :: C a => T a -> T a

-- | similarity mapping as needed for rotating 3D vectors
--   
--   It holds <tt>similarity (cos(a/2) +:: scaleImag (sin(a/2)) v) (0 +::
--   x) == (0 +:: y)</tt> where <tt>y</tt> results from rotating <tt>x</tt>
--   around the axis <tt>v</tt> by the angle <tt>a</tt>.
similarity :: C a => T a -> T a -> T a

-- | Spherical Linear Interpolation
--   
--   Can be generalized to any transcendent Hilbert space. In fact, we
--   should also include the real part in the interpolation.
slerp :: C a => a -> (a, a, a) -> (a, a, a) -> (a, a, a)
instance Eq a => Eq (T a)
instance C a b => C a (T b)
instance C a b => C a (T b)
instance C T
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance (C a, Sqr a b) => C a (T b)
instance Sqr a b => Sqr a (T b)
instance Read a => Read (T a)
instance Show a => Show (T a)

module Number.ResidueClass.Func

-- | Here a residue class is a representative and the modulus is an
--   argument. You cannot show a value of type <a>T</a>, you can only show
--   it with respect to a concrete modulus. Values cannot be compared,
--   because the comparison result depends on the modulus.
newtype T a
Cons :: (a -> a) -> T a
concrete :: a -> T a -> a
fromRepresentative :: C a => a -> T a
lift0 :: (a -> a) -> T a
lift1 :: (a -> a -> a) -> T a -> T a
lift2 :: (a -> a -> a -> a) -> T a -> T a -> T a
zero :: C a => T a
one :: C a => T a
fromInteger :: C a => Integer -> T a
equal :: Eq a => a -> T a -> T a -> Bool
notImplemented :: String -> a
lift98_1 :: (T a -> T a -> T a) -> T a -> T a
lift98_2 :: (T a -> T a -> T a -> T a) -> T a -> T a -> T a
instance Show (T a)
instance Eq (T a)
instance Integral a => Num (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)


-- | A wrapper that provides instances of Haskell 98 and NumericPrelude
--   numeric type classes for types that have NumericPrelude instances.
module MathObj.Wrapper.NumericPrelude

-- | This makes a type usable with Haskell98 type classes that was
--   initially implemented for NumericPrelude typeclasses. E.g. if
--   <tt>a</tt> is in class <a>C</a>, then <tt>T a</tt> is both in class
--   <a>Num</a> and in <a>C</a>.
--   
--   You can even lift container types. If <tt>Polynomial a</tt> is in
--   <a>C</a> for all types <tt>a</tt> that are in <a>C</a>, then <tt>T
--   (Polynomial (MathObj.Wrapper.Haskell98.T a))</tt> is in <a>Num</a> for
--   all types <tt>a</tt> that are in <a>Num</a>.
newtype T a
Cons :: a -> T a
decons :: T a -> a
lift1 :: (a -> b) -> T a -> T b
lift2 :: (a -> b -> c) -> T a -> T b -> T c
unimplemented :: String -> a
instance Show a => Show (T a)
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance Ix a => Ix (T a)
instance Bounded a => Bounded (T a)
instance Enum a => Enum (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a v => C (T a) (T v)
instance C a v => C (T a) (T v)
instance C a v => C (T a) (T v)
instance Sqr a v => Sqr (T a) (T v)
instance C a v => C (T a) (T v)
instance C a v => C (T a) (T v)
instance C a v => C (T a) (T v)
instance C a v => C (T a) (T v)
instance (C a, C a, C a, C a, Ord a, Show a) => RealFloat (T a)
instance (C a, C a, C a, C a, Ord a, Show a) => RealFrac (T a)
instance (C a, C a, Ord a, Show a) => Real (T a)
instance (C a, C a, Eq a, Show a) => Floating (T a)
instance (C a, C a, Eq a, Show a) => Fractional (T a)
instance (C a, C a, C a, Ord a, Enum a, Show a) => Integral (T a)
instance (C a, C a, Eq a, Show a) => Num (T a)
instance Functor T


-- | See <a>Algebra.DimensionTerm</a>.
module Number.DimensionTerm
newtype T u a
Cons :: a -> T u a
fromNumber :: a -> Scalar a
toNumber :: Scalar a -> a
fromNumberWithDimension :: C u => u -> a -> T u a
toNumberWithDimension :: C u => u -> T u a -> a
(&*&) :: (C u, C v, C a) => T u a -> T v a -> T (Mul u v) a
(&/&) :: (C u, C v, C a) => T u a -> T v a -> T (Mul u (Recip v)) a
mulToScalar :: (C u, C a) => T u a -> T (Recip u) a -> a
divToScalar :: (C u, C a) => T u a -> T u a -> a
cancelToScalar :: C u => T (Mul u (Recip u)) a -> a
recip :: (C u, C a) => T u a -> T (Recip u) a
unrecip :: (C u, C a) => T (Recip u) a -> T u a
sqr :: (C u, C a) => T u a -> T (Sqr u) a
sqrt :: (C u, C a) => T (Sqr u) a -> T u a
abs :: (C u, C a) => T u a -> T u a
absSignum :: (C u, C a) => T u a -> (T u a, a)
scale :: (C u, C a) => a -> T u a -> T u a
(*&) :: (C u, C a) => a -> T u a -> T u a
rewriteDimension :: (C u, C v) => (u -> v) -> T u a -> T v a
type Scalar a = T Scalar a
type Length a = T Length a
type Time a = T Time a
type Mass a = T Mass a
type Charge a = T Charge a
type Angle a = T Angle a
type Temperature a = T Temperature a
type Information a = T Information a
type Frequency a = T Frequency a
type Voltage a = T Voltage a
scalar :: a -> Scalar a
length :: a -> Length a
time :: a -> Time a
mass :: a -> Mass a
charge :: a -> Charge a
frequency :: a -> Frequency a
angle :: a -> Angle a
temperature :: a -> Temperature a
information :: a -> Information a
voltage :: a -> Voltage a
instance Eq a => Eq (T u a)
instance Ord a => Ord (T u a)
instance (C u, Random a) => Random (T u a)
instance (IsScalar u, C a b) => C a (T u b)
instance (IsScalar u, C a) => C (T u a)
instance (IsScalar u, C a) => C (T u a)
instance (C u, C a b) => C a (T u b)
instance (C u, C a) => C (T u a)
instance NFData a => NFData (T u a)
instance (C u, Show a) => Show (T u a)


-- | Special physical units: SI unit system
module Number.DimensionTerm.SI
second :: C a => Time a
minute :: C a => Time a
hour :: C a => Time a
day :: C a => Time a
year :: C a => Time a
hertz :: C a => Frequency a
meter :: C a => Length a
gramm :: C a => Mass a
tonne :: C a => Mass a
coulomb :: C a => Charge a
volt :: C a => Voltage a
kelvin :: C a => Temperature a
bit :: C a => Information a
byte :: C a => Information a
inch :: C a => Length a
foot :: C a => Length a
yard :: C a => Length a
astronomicUnit :: C a => Length a
parsec :: C a => Length a

-- | Prefixes used for SI units
yocto :: C a => a
zepto :: C a => a
atto :: C a => a
femto :: C a => a
pico :: C a => a
nano :: C a => a
micro :: C a => a
milli :: C a => a
centi :: C a => a
deci :: C a => a
one :: C a => a
deca :: C a => a
hecto :: C a => a
kilo :: C a => a
mega :: C a => a
giga :: C a => a
tera :: C a => a
peta :: C a => a
exa :: C a => a
zetta :: C a => a
yotta :: C a => a

module Number.FixedPoint.Check
data T
Cons :: Integer -> Integer -> T
denominator :: T -> Integer
numerator :: T -> Integer
cons :: Integer -> Integer -> T
fromFloat :: C a => Integer -> a -> T
fromInteger' :: Integer -> Integer -> T
fromRational' :: Integer -> Rational -> T
fromFloatBasis :: C a => Integer -> Int -> a -> T
fromIntegerBasis :: Integer -> Int -> Integer -> T
fromRationalBasis :: Integer -> Int -> Rational -> T

-- | denominator conversion
fromFixedPoint :: Integer -> T -> T
lift0 :: Integer -> (Integer -> Integer) -> T
lift1 :: (Integer -> Integer -> Integer) -> (T -> T)
lift2 :: (Integer -> Integer -> Integer -> Integer) -> (T -> T -> T)
commonDenominator :: Integer -> Integer -> a -> a
appPrec :: Int
defltDenominator :: Integer
defltShow :: T -> String
instance Fractional T
instance Num T
instance C T
instance C T
instance Ord T
instance Eq T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T
instance Show T


-- | A type for non-negative numbers. It performs a run-time check at
--   construction time (i.e. at run-time) and is a member of the
--   non-negative number type class <a>C</a>.
module Number.NonNegative
data T a :: * -> *

-- | Convert a number to a non-negative number. If a negative number is
--   given, an error is raised.
fromNumber :: (Ord a, C a) => a -> T a
fromNumberMsg :: (Ord a, C a) => String -> a -> T a

-- | Convert a number to a non-negative number. A negative number will be
--   replaced by zero. Use this function with care since it may hide bugs.
fromNumberClip :: (Ord a, C a) => a -> T a

-- | Wrap a number into a non-negative number without doing checks. This
--   routine exists entirely for efficiency reasons and must be used only
--   in cases where you are absolutely sure, that the input number is
--   non-negative.
fromNumberUnsafe :: a -> T a
toNumber :: T a -> a
type Int = T Int
type Integer = T Integer
type Float = T Float
type Double = T Double
type Ratio a = T (T a)
type Rational = T Rational
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance (Ord a, C a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)


-- | A lazy number type, which is a generalization of lazy Peano numbers.
--   Comparisons can be made lazy and thus computations are possible which
--   are impossible with strict number types, e.g. you can compute <tt>let
--   y = min (1+y) 2 in y</tt>. You can even work with infinite values.
--   However, depending on the granularity, the memory consumption is
--   higher than that for strict number types. This number type is of
--   interest for the merge operation of event lists, which allows for
--   co-recursive merges.
module Number.NonNegativeChunky

-- | A chunky non-negative number is a list of non-negative numbers. It
--   represents the sum of the list elements. It is possible to represent a
--   finite number with infinitely many chunks by using an infinite number
--   of zeros.
--   
--   Note the following problems:
--   
--   Addition is commutative only for finite representations. E.g. <tt>let
--   y = min (1+y) 2 in y</tt> is defined, <tt>let y = min (y+1) 2 in
--   y</tt> is not.
--   
--   The type is equivalent to <a>Chunky</a>.
data T a
fromChunks :: C a => [a] -> T a
toChunks :: C a => T a -> [a]
fromNumber :: C a => a -> T a
toNumber :: C a => T a -> a
fromChunky98 :: (C a, C a) => T a -> T a
toChunky98 :: (C a, C a) => T a -> T a
minMaxDiff :: C a => T a -> T a -> (T a, (Bool, T a))

-- | Remove zero chunks.
normalize :: C a => T a -> T a
isNull :: C a => T a -> Bool
isPositive :: C a => T a -> Bool

-- | divModLazy accesses the divisor in a lazy way. However this is only
--   relevant if the dividend is smaller than the divisor. For large
--   dividends the divisor will be accessed multiple times but since it is
--   already fully evaluated it could also be strict.
divModLazy :: (C a, C a) => T a -> T a -> (T a, T a)

-- | This function has a strict divisor and maintains the chunk structure
--   of the dividend at a smaller scale.
divModStrict :: (C a, C a) => T a -> a -> (T a, a)
instance C a => C (T a)
instance C a => Monoid (T a)
instance (C a, Fractional a) => Fractional (T a)
instance (C a, Num a) => Num (T a)
instance (C a, Arbitrary a) => Arbitrary (T a)
instance Show a => Show (T a)
instance (Ord a, C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance (C a, C a, C a) => C (T a)
instance (C a, C a) => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => C (T a)
instance C a => Ord (T a)
instance C a => Eq (T a)


-- | Lazy Peano numbers represent natural numbers inclusive infinity. Since
--   they are lazily evaluated, they are optimally for use as number type
--   of <a>genericLength</a> et.al.
module Number.Peano
data T
Zero :: T
Succ :: T -> T
infinity :: T
err :: String -> String -> a
add :: T -> T -> T
sub :: T -> T -> T
subNeg :: T -> T -> (Bool, T)
mul :: T -> T -> T
fromPosEnum :: (C a, Enum a) => a -> T
toPosEnum :: (C a, Enum a) => T -> a

-- | If all values are completely defined, then it holds
--   
--   <pre>
--   if b then x else y == ifLazy b x y
--   </pre>
--   
--   However if <tt>b</tt> is undefined, then it is at least known that the
--   result is larger than <tt>min x y</tt>.
ifLazy :: Bool -> T -> T -> T

-- | cf. To how to find the shortest list in a list of lists efficiently,
--   this means, also in the presence of infinite lists.
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2006-October/018753.html</a>
argMinFull :: (T, a) -> (T, a) -> (T, a)

-- | On equality the first operand is returned.
argMin :: (T, a) -> (T, a) -> a
argMinimum :: [(T, a)] -> a
argMaxFull :: (T, a) -> (T, a) -> (T, a)

-- | On equality the first operand is returned.
argMax :: (T, a) -> (T, a) -> a
argMaximum :: [(T, a)] -> a

-- | <tt>x0 &lt;= x1 &amp;&amp; x1 &lt;= x2 ... </tt> for possibly infinite
--   numbers in finite lists.
isAscendingFiniteList :: [T] -> Bool
isAscendingFiniteNumbers :: [T] -> Bool
toListMaybe :: a -> T -> [Maybe a]

-- | In <tt>glue x y == (z,(b,r))</tt> <tt>z</tt> represents <tt>min x
--   y</tt>, <tt>r</tt> represents <tt>max x y - min x y</tt>, and
--   <tt>x&lt;=y == b</tt>.
--   
--   Cf. Numeric.NonNegative.Chunky
glue :: T -> T -> (T, (Bool, T))
isAscending :: [T] -> Bool
data Valuable a
Valuable :: T -> a -> Valuable a
costs :: Valuable a -> T
value :: Valuable a -> a
increaseCosts :: T -> Valuable a -> Valuable a

-- | Compute '(&amp;&amp;)' with minimal costs.
(&&~) :: Valuable Bool -> Valuable Bool -> Valuable Bool
andW :: [Valuable Bool] -> Valuable Bool
leW :: T -> T -> Valuable Bool
isAscendingW :: [T] -> Valuable Bool
notImplemented :: String -> a
instance Show T
instance Read T
instance Eq T
instance Show a => Show (Valuable a)
instance Eq a => Eq (Valuable a)
instance Ord a => Ord (Valuable a)
instance Integral T
instance Real T
instance Num T
instance Bounded T
instance C T
instance C T
instance C T
instance Ix T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T
instance Ord T
instance C T
instance C T
instance Enum T
instance C T
instance C T
instance C T


-- | Interface to <a>Number.Positional</a> which dynamically checks for
--   equal bases.
module Number.Positional.Check

-- | The value <tt>Cons b e m</tt> represents the number <tt>b^e * (m!!0 /
--   1 + m!!1 / b + m!!2 / b^2 + ...)</tt>. The interpretation of exponent
--   is chosen such that <tt>floor (logBase b (Cons b e m)) == e</tt>. That
--   is, it is good for multiplication and logarithms. (Because of the
--   necessity to normalize the multiplication result, the alternative
--   interpretation wouldn't be more complicated.) However for base
--   conversions, roots, conversion to fixed point and working with the
--   fractional part the interpretation <tt>b^e * (m!!0 / b + m!!1 / b^2 +
--   m!!2 / b^3 + ...)</tt> would fit better. The digits in the mantissa
--   range from <tt>1-base</tt> to <tt>base-1</tt>. The representation is
--   not unique and cannot be made unique in finite time. This way we avoid
--   infinite carry ripples.
data T
Cons :: Basis -> Int -> Mantissa -> T
base :: T -> Basis
exponent :: T -> Int
mantissa :: T -> Mantissa

-- | Shift digits towards zero by partial application of carries. E.g. 1.8
--   is converted to 2.(-2) If the digits are in the range <tt>(1-base,
--   base-1)</tt> the resulting digits are in the range
--   <tt>((1-base)<i>2-2, (base-1)</i>2+2)</tt>. The result is still not
--   unique, but may be useful for further processing.
compress :: T -> T

-- | perfect carry resolution, works only on finite numbers
carry :: T -> T
prependDigit :: Digit -> T -> T
lift0 :: (Basis -> T) -> T
lift1 :: (Basis -> T -> T) -> T -> T
lift2 :: (Basis -> T -> T -> T) -> T -> T -> T
commonBasis :: Basis -> Basis -> Basis
fromBaseInteger :: Basis -> Integer -> T
fromBaseRational :: Basis -> Rational -> T
defltBaseRoot :: Basis
defltBaseExp :: Exponent
defltBase :: Basis
defltShow :: T -> String
instance Show T
instance Fractional T
instance Num T
instance Power T
instance C T
instance C T
instance C T
instance C T
instance Ord T
instance Eq T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T
instance C T


-- | Physical expressions track the operations made on physical values so
--   we are able to give detailed information on how to resolve unit
--   violations.
module Number.OccasionallyScalarExpression

-- | A value of type <a>T</a> stores information on how to resolve unit
--   violations. The main application of the module are certainly
--   Number.Physical type instances but in principle it can also be applied
--   to other occasionally scalar types.
data T a v
Cons :: (Term a v) -> v -> T a v
data Term a v
Const :: Term a v
Add :: (T a v) -> (T a v) -> Term a v
Mul :: (T a v) -> (T a v) -> Term a v
Div :: (T a v) -> (T a v) -> Term a v
fromValue :: v -> T a v
makeLine :: Int -> String -> String
showUnitError :: Show v => Bool -> Int -> v -> T a v -> String
lift :: (v -> v) -> (T a v -> T a v)
fromScalar :: (Show v, C a v) => a -> T a v
scalarMap :: (Show v, C a v) => (a -> a) -> (T a v -> T a v)
scalarMap2 :: (Show v, C a v) => (a -> a -> a) -> (T a v -> T a v -> T a v)
instance (C a v, Show v) => C a (T a v)
instance (C a, C v, Show v, C a v) => C (T a v)
instance (C a, C v, Show v, C a v) => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance Ord v => Ord (T a v)
instance Eq v => Eq (T a v)
instance Show v => Show (T a v)


-- | Numeric values combined with abstract Physical Units
module Number.Physical

-- | A Physics.Quantity.Value.T combines a numeric value with a physical
--   unit.
data T i a
Cons :: (T i) -> a -> T i a

-- | Construct a physical value from a numeric value and the full vector
--   representation of a unit.
quantity :: (Ord i, Enum i, C a) => [Int] -> a -> T i a
fromScalarSingle :: a -> T i a

-- | Test for the neutral Unit.T. Also a zero has a unit!
isScalar :: T i a -> Bool

-- | apply a function to the numeric value while preserving the unit
lift :: (a -> b) -> T i a -> T i b
lift2 :: Eq i => String -> (a -> b -> c) -> T i a -> T i b -> T i c
lift2Maybe :: Eq i => (a -> b -> c) -> T i a -> T i b -> Maybe (T i c)
lift2Gen :: Eq i => String -> (a -> b -> c) -> T i a -> T i b -> c
errorUnitMismatch :: String -> a

-- | Add two values if the units match, otherwise return Nothing
addMaybe :: (Eq i, C a) => T i a -> T i a -> Maybe (T i a)

-- | Subtract two values if the units match, otherwise return Nothing
subMaybe :: (Eq i, C a) => T i a -> T i a -> Maybe (T i a)
scale :: (Ord i, C a) => a -> T i a -> T i a
ratPow :: C a => T Int -> T i a -> T i a
ratPowMaybe :: C a => T Int -> T i a -> Maybe (T i a)
fromRatio :: (C b, C a) => T a -> b
instance Monad (T i)
instance Applicative (T a)
instance Functor (T i)
instance C a v => C a (T i v)
instance (Ord i, C a v) => C a (T i v)
instance (Ord i, C a v) => C a (T i v)
instance Ord i => C (T i)
instance (Ord i, C a) => C (T i a)
instance (Ord i, C a) => C (T i a)
instance (Ord i, C a) => C (T i a)
instance (Ord i, C a) => C (T i a)
instance (Ord i, Ord a) => Ord (T i a)
instance (Ord i, C a) => C (T i a)
instance (Ord i, C a) => C (T i a)
instance (Ord i, Enum i, Show a) => Show (T i a)
instance (Eq i, Eq a) => Eq (T i a)
instance C v => C (T a v)


-- | Convert a physical value to a human readable string.
module Number.Physical.Show
mulPrec :: Int

-- | Show the physical quantity in a human readable form with respect to a
--   given unit data base.
showNat :: (Ord i, Show v, C a, Ord a, C a v) => T i a -> T i v -> String

-- | Returns the rescaled value as number and the unit as string. The value
--   can be used re-scale connected values and display them under the label
--   of the unit
showSplit :: (Ord i, Show v, C a, Ord a, C a v) => T i a -> T i v -> (v, String)
showScaled :: (Ord i, Show v, Ord a, C a, C a v) => v -> [UnitSet i a] -> (v, String)

-- | Choose a scale where the number becomes handy and return the scaled
--   number and the corresponding scale.
chooseScale :: (Ord i, Show v, Ord a, C a, C a v) => v -> UnitSet i a -> (v, Scale a)
showUnitPart :: Bool -> Bool -> Scale a -> String
defScale :: UnitSet i v -> Scale v
findCloseScale :: (Ord a, C a) => a -> [Scale a] -> Scale a

-- | unused
totalDefScale :: C a => T i a -> a

-- | unused
getUnit :: C a => String -> T i a -> T i a


-- | Convert a human readable string to a physical value.
module Number.Physical.Read
mulPrec :: Int
readsNat :: (Enum i, Ord i, Read v, C a v) => T i a -> Int -> ReadS (T i v)
readUnitPart :: (Ord i, C a) => Map String (T i a) -> String -> (T i a, String)

-- | This function could also return the value, but a list of pairs
--   (String, Integer) is easier for testing.
parseProduct :: Parser [(String, Integer)]
parseProductTail :: Parser [(String, Integer)]
parsePower :: Parser (String, Integer)
ignoreSpace :: Parser a -> Parser a
createDict :: T i a -> Map String (T i a)


-- | Numerical values equipped with SI units. This is considered as the
--   user front-end.
module Number.SI
newtype T a v
Cons :: (PValue v) -> T a v
type PValue v = T Dimension v
lift :: (PValue v0 -> PValue v1) -> (T a v0 -> T a v1)
lift2 :: (PValue v0 -> PValue v1 -> PValue v2) -> (T a v0 -> T a v1 -> T a v2)
liftGen :: (PValue v -> x) -> (T a v -> x)
lift2Gen :: (PValue v0 -> PValue v1 -> x) -> (T a v0 -> T a v1 -> x)
scale :: C v => v -> T a v -> T a v
fromScalarSingle :: v -> T a v
showNat :: (Show v, C a, Ord a, C a v) => T Dimension a -> T a v -> String
readsNat :: (Read v, C a v) => T Dimension a -> Int -> ReadS (T a v)
quantity :: (C a, C v) => T Dimension -> v -> T a v
hertz :: (C a, C v) => T a v
accelerationOfEarthGravity :: (C a, C v) => T a v
horsePower :: (C a, C v) => T a v
calorien :: (C a, C v) => T a v
electronVolt :: (C a, C v) => T a v
speedOfLight :: (C a, C v) => T a v
mach :: (C a, C v) => T a v
parsec :: (C a, C v) => T a v
astronomicUnit :: (C a, C v) => T a v
yard :: (C a, C v) => T a v
foot :: (C a, C v) => T a v
inch :: (C a, C v) => T a v
baud :: (C a, C v) => T a v
byte :: (C a, C v) => T a v
bit :: (C a, C v) => T a v
farad :: (C a, C v) => T a v
ohm :: (C a, C v) => T a v
volt :: (C a, C v) => T a v
ampere :: (C a, C v) => T a v
coulomb :: (C a, C v) => T a v
kelvin :: (C a, C v) => T a v
watt :: (C a, C v) => T a v
joule :: (C a, C v) => T a v
bar :: (C a, C v) => T a v
pascal :: (C a, C v) => T a v
newton :: (C a, C v) => T a v
tonne :: (C a, C v) => T a v
gramm :: (C a, C v) => T a v
liter :: (C a, C v) => T a v
meter :: (C a, C v) => T a v
year :: (C a, C v) => T a v
day :: (C a, C v) => T a v
hour :: (C a, C v) => T a v
minute :: (C a, C v) => T a v
second :: (C a, C v) => T a v
instance Functor (T a)
instance Fractional v => Fractional (T a v)
instance Num v => Num (T a v)
instance (C a, Ord a, C a v, Show v, C a v) => C a (T a v)
instance C a v => C a (T b v)
instance C a v => C a (T b v)
instance C (T a)
instance C v => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance Ord v => Ord (T a v)
instance C v => C (T a v)
instance C v => C (T a v)
instance (Read v, Ord a, C a, C a v) => Read (T a v)
instance (Show v, Ord a, C a, C a v) => Show (T a v)
instance Eq v => Eq (T a v)
instance C v => C (T a v)
