-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Parser Generator for Haskell
--   
--   The Parser Generator for Haskell <a>http://tanakh.github.com/Peggy</a>
@package peggy
@version 0.3.2

module Text.Peggy.Syntax
type Syntax = [Definition]
data Definition
Definition :: Identifier -> TermType -> Expr -> Definition
data Expr
Terminals :: Bool -> Bool -> String -> Expr
TerminalSet :: [CharRange] -> Expr
TerminalCmp :: [CharRange] -> Expr
TerminalAny :: Expr
NonTerminal :: Identifier -> Expr
Primitive :: Identifier -> Expr
Empty :: Expr
Named :: Identifier -> Expr -> Expr
Sequence :: [Expr] -> Expr
Choice :: [Expr] -> Expr
Many :: Expr -> Expr
Some :: Expr -> Expr
Optional :: Expr -> Expr
And :: Expr -> Expr
Not :: Expr -> Expr
SepBy :: Expr -> Expr -> Expr
SepBy1 :: Expr -> Expr -> Expr
Token :: Expr -> Expr
Semantic :: Expr -> CodeFragment -> Expr
data CharRange
CharRange :: Char -> Char -> CharRange
CharOne :: Char -> CharRange
type CodeFragment = [CodePart]
data CodePart
Snippet :: String -> CodePart
Argument :: Int -> CodePart
AntiArgument :: Int -> CodePart
ArgPos :: CodePart
ArgSpan :: CodePart
type Identifier = String
type TermType = String
instance Typeable CharRange
instance Typeable CodePart
instance Typeable Expr
instance Typeable Definition
instance Show CharRange
instance Eq CharRange
instance Data CharRange
instance Show CodePart
instance Eq CodePart
instance Data CodePart
instance Show Expr
instance Eq Expr
instance Data Expr
instance Show Definition
instance Eq Definition
instance Data Definition

module Text.Peggy.Normalize
normalize :: Syntax -> Syntax
shouldBind :: Expr -> Bool

module Text.Peggy.LeftRec
removeLeftRecursion :: Syntax -> Syntax

module Text.Peggy.SrcLoc
data SrcLoc
LocPos :: !SrcPos -> SrcLoc
LocSpan :: !SrcPos -> !SrcPos -> SrcLoc
data SrcPos
SrcPos :: !FilePath -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> SrcPos
locFile :: SrcPos -> !FilePath
locAbs :: SrcPos -> {-# UNPACK #-} !Int
locLine :: SrcPos -> {-# UNPACK #-} !Int
locCol :: SrcPos -> {-# UNPACK #-} !Int
advance :: SrcPos -> Char -> SrcPos
instance Typeable SrcPos
instance Typeable SrcLoc
instance Show SrcPos
instance Eq SrcPos
instance Ord SrcPos
instance Data SrcPos
instance Show SrcLoc
instance Eq SrcLoc
instance Ord SrcLoc
instance Data SrcLoc


-- | The monadic parser type and combinators to construct packrat parsers
--   for code generator.
module Text.Peggy.Prim

-- | Parsing function
parse :: MemoTable tbl => (forall s. Parser tbl str s a) -> SrcPos -> str -> Either ParseError a

-- | Parsing function with only input name
parseString :: MemoTable tbl => (forall s. Parser tbl str s a) -> String -> str -> Either ParseError a

-- | Parse from file
parseFile :: MemoTable tbl => (forall s. Parser tbl String s a) -> FilePath -> IO (Either ParseError a)
newtype Parser tbl str s a
Parser :: (tbl s -> SrcPos -> Char -> str -> ST s (Result str a)) -> Parser tbl str s a
unParser :: Parser tbl str s a -> tbl s -> SrcPos -> Char -> str -> ST s (Result str a)
data Result str a
Parsed :: SrcPos -> Char -> str -> a -> Result str a
Failed :: ParseError -> Result str a
data ParseError
ParseError :: SrcLoc -> String -> ParseError
class MemoTable tbl
newTable :: MemoTable tbl => ST s (tbl s)
memo :: (tbl s -> HashTable s Int (Result str a)) -> Parser tbl str s a -> Parser tbl str s a
getPos :: Parser tbl str s SrcPos
setPos :: SrcPos -> Parser tbl str s ()
anyChar :: ListLike str Char => Parser tbl str s Char
satisfy :: ListLike str Char => (Char -> Bool) -> Parser tbl str s Char
char :: ListLike str Char => Char -> Parser tbl str s Char
string :: ListLike str Char => String -> Parser tbl str s String
expect :: ListLike str Char => Parser tbl str s a -> Parser tbl str s ()
unexpect :: ListLike str Char => Parser tbl str s a -> Parser tbl str s ()
space :: ListLike str Char => Parser tbl str s ()
defaultDelimiter :: ListLike str Char => Parser tbl str s ()
token :: ListLike str Char => Parser tbl str s () -> Parser tbl str s () -> Parser tbl str s a -> Parser tbl str s a
instance Show ParseError
instance Alternative (Parser tbl str s)
instance MonadError ParseError (Parser tbl str s)
instance Applicative (Parser tbl str s)
instance Functor (Parser tbl str s)
instance Monad (Parser tbl str s)
instance Error ParseError

module Text.Peggy.CodeGen.TH
genDecs :: Syntax -> Q [Dec]
genQQ :: Syntax -> (String, String) -> Q [Dec]

module Text.Peggy.Parser
syntax :: ListLike str_34 Char => Parser (MemoTable_0 str_34) str_34 s_35 Syntax
instance MemoTable (MemoTable_0 str_4)


-- | The quasi-quoters of peggy syntax.
module Text.Peggy.Quote

-- | quasi-quoter for peggy syntax When it is used at top-level of source
--   code, definitions of parsers are generated.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell, QuasiQuotes, FlexibleContexts #-}
--   import Text.Peggy
--   
--   [peggy|
--   foo :: [Int]
--     = num*
--   num ::: Int
--     = [0-9]+ { read $1 }
--   |]
--   
--   main :: IO ()
--   main = print . parseString foo "&lt;stdin&gt;" =&lt;&lt; getContents
--   </pre>
--   
--   When it is used as expression, the result value is <a>Syntax</a>.
--   
--   <pre>
--   main = print [peggy|
--   num :: Int
--     = [0-9]+ { read $1 }
--   |]
--   </pre>
--   
--   The result is:
--   
--   <pre>
--   $ runhaskell Test.hs
--   [Definition "num" "Int\n  " (Choice [Semantic (Sequence [Some (TerminalSet [CharRange '0' '9'])]) [Snippet "read ",Argument 1,Snippet " "]])]
--   </pre>
peggy :: QuasiQuoter

-- | Parse peggy syntax from File Parse a peggy syntax file and return a
--   <a>Syntax</a> as a result value.
--   
--   <pre>
--   $ cat test.peggy
--   num :: Int
--     = [0-9]+ { return $1 }
--   </pre>
--   
--   <pre>
--   main = print $(peggyFile "test.peggy")
--   </pre>
--   
--   The result is:
--   
--   <pre>
--   [Definition "num" "Int\n  " (Choice [Semantic (Sequence [Some (TerminalSet [CharRange '0' '9'])]) [Snippet "read ",Argument 1,Snippet " "]])]
--   </pre>
peggyFile :: FilePath -> Q Exp

-- | Generates parsers and quasi-quoters. First argument is a list of names
--   of quasi-quoter you want to define. For example:
--   
--   <pre>
--   genParser [("fooqq", "foo")] [peggy|
--   foo :: [Int]
--     = num*
--   num ::: Int
--     = [0-9]+ { read $1 }
--   |]
--   </pre>
--   
--   this code defines parsers named <tt>foo</tt>, <tt>num</tt> and
--   quasi-quoter named <tt>fooqq</tt>.
--   
--   It can use it as follow:
--   
--   <pre>
--   main :: IO ()
--   main = print [fooqq| 1 2 3 4 5 |]
--   </pre>
genParser :: [(String, String)] -> Syntax -> Q [Dec]

module Text.Peggy
