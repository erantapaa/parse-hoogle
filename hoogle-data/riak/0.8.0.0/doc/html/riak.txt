-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell client for the Riak decentralized data store
--   
@package riak
@version 0.8.0.0


-- | Useful functions.
module Network.Riak.Functions
strict :: ByteString -> ByteString
lazy :: ByteString -> ByteString
mapEither :: (a -> c) -> (b -> d) -> Either a b -> Either c d


-- | Support for REST-safe name handling.
--   
--   Riak's protocol buffer (PBC) API will accept unescaped bucket, link,
--   and key names. Its REST API does not unescape names, so it is possible
--   to use the PBC API to construct names that cannot be accessed via the
--   REST API (e.g. containing an embedded slash or other URL-unsafe
--   octet).
module Network.Riak.Escape

-- | The class of string-like types that can be URL-escaped and unescaped.
class Escape e
escape :: Escape e => e -> ByteString
unescape' :: Escape e => ByteString -> Either String e

-- | URL-unescape a string that is presumed to be properly escaped. If the
--   string is invalid, an error will be thrown that cannot be caught from
--   pure code.
unescape :: Escape e => ByteString -> e
instance Escape [Char]
instance Escape Text
instance Escape Text
instance Escape ByteString
instance Escape ByteString


-- | Smart constructors for Riak types. These functions correctly
--   URL-escape bucket, key, and link names. You should thus use them in
--   preference to the raw data constructors.
module Network.Riak.Request
data PingRequest :: *

-- | Create a ping request.
ping :: PingRequest
data GetClientIDRequest :: *

-- | Create a client-ID request.
getClientID :: GetClientIDRequest
data GetServerInfoRequest :: *

-- | Create a server-info request.
getServerInfo :: GetServerInfoRequest
data GetRequest :: *

-- | Create a get request. The bucket and key names are URL-escaped.
get :: Bucket -> Key -> R -> GetRequest

-- | Create a secondary index request. Bucket, key and index names and
--   values are URL-escaped.
getByIndex :: Bucket -> IndexQuery -> IndexRequest
data IndexRequest :: *
data PutRequest :: *

-- | Create a put request. The bucket and key names are URL-escaped. Any
--   <tt>Link</tt> values inside the <a>Content</a> are assumed to have
--   been constructed with the <a>link</a> function, and hence <i>not</i>
--   escaped.
put :: Bucket -> Key -> Maybe VClock -> Content -> W -> DW -> Bool -> PutRequest
data DeleteRequest :: *

-- | Create a delete request. The bucket and key names are URL-escaped.
delete :: Bucket -> Key -> RW -> DeleteRequest
data Link :: *

-- | Create a link. The bucket and key names are URL-escaped.
link :: Bucket -> Key -> Tag -> Link
data ListBucketsRequest :: *

-- | Create a list-buckets request.
listBuckets :: ListBucketsRequest
data ListKeysRequest :: *

-- | Create a list-keys request. The bucket name is URL-escaped.
listKeys :: Bucket -> ListKeysRequest
data GetBucketRequest :: *

-- | Create a get-bucket request. The bucket name is URL-escaped.
getBucket :: Bucket -> GetBucketRequest
data SetBucketRequest :: *

-- | Create a set-bucket request. The bucket name is URL-escaped.
setBucket :: Bucket -> BucketProps -> SetBucketRequest
data MapReduceRequest :: *

-- | Create a map-reduce request.
mapReduce :: Job -> MapReduceRequest


-- | Smart deconstructors for Riak types. These functions correctly
--   URL-unescape bucket, key, and link names. You should thus use them in
--   preference to direct pattern matching against raw data constructors.
module Network.Riak.Response
getClientID :: GetClientIDResponse -> ClientID

-- | Construct a get response. Bucket and key names in links are
--   URL-unescaped.
get :: Maybe GetResponse -> Maybe (Seq Content, VClock)

-- | Construct a put response. Bucket and key names in links are
--   URL-unescaped.
put :: PutResponse -> (Seq Content, VClock)

-- | Construct a list-buckets response. Bucket names are unescaped.
listBuckets :: ListBucketsResponse -> Seq Bucket
getBucket :: GetBucketResponse -> BucketProps

-- | URL-unescape the names of keys and buckets in the links of a
--   <a>Content</a> value.
unescapeLinks :: Content -> Content


-- | Low-level content and link types and functions.
module Network.Riak.Content
data Content :: *
Content :: SrictNotUnpackedByteString -> SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Seq Link) -> SrictNotUnpacked(Maybe Word32) -> SrictNotUnpacked(Maybe Word32) -> SrictNotUnpacked(Seq Pair) -> SrictNotUnpacked(Seq Pair) -> SrictNotUnpacked(Maybe Bool) -> Content
value :: Content -> SrictNotUnpackedByteString
content_type :: Content -> SrictNotUnpacked(Maybe ByteString)
charset :: Content -> SrictNotUnpacked(Maybe ByteString)
content_encoding :: Content -> SrictNotUnpacked(Maybe ByteString)
vtag :: Content -> SrictNotUnpacked(Maybe ByteString)
links :: Content -> SrictNotUnpacked(Seq Link)
last_mod :: Content -> SrictNotUnpacked(Maybe Word32)
last_mod_usecs :: Content -> SrictNotUnpacked(Maybe Word32)
usermeta :: Content -> SrictNotUnpacked(Seq Pair)
indexes :: Content -> SrictNotUnpacked(Seq Pair)
deleted :: Content -> SrictNotUnpacked(Maybe Bool)
data Link :: *
Link :: SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Maybe ByteString) -> SrictNotUnpacked(Maybe ByteString) -> Link
bucket :: Link -> SrictNotUnpacked(Maybe ByteString)
key :: Link -> SrictNotUnpacked(Maybe ByteString)
tag :: Link -> SrictNotUnpacked(Maybe ByteString)

-- | An empty piece of content.
empty :: Content

-- | Content encoded as <tt>application/octet-stream</tt>.
binary :: ByteString -> Content

-- | Content encoded as <tt>application/json</tt>.
json :: ToJSON a => a -> Content

-- | Create a link.
link :: Bucket -> Key -> Tag -> Link


-- | Support for debug logging. The code in this package only works if the
--   package was built with the <tt>-fdebug</tt> flag. Otherwise, they are
--   all no-ops.
module Network.Riak.Debug

-- | The current debugging level. This is established once by reading the
--   <tt>RIAK_DEBUG</tt> environment variable.
level :: Int

-- | Print a debug message, if debugging is enabled.
debug :: String -> String -> IO ()

-- | Print a debug message, and information about some values. If the debug
--   level is greater than 1, print the values themselves.
debugValues :: Show a => String -> String -> [a] -> IO ()

-- | Set the <a>Handle</a> to log to (<a>stderr</a> is the default).
setHandle :: Handle -> IO ()

-- | Show a <a>Tagged</a> value. Show the entire value if the debug level
--   is above 1, just the tag otherwise.
showM :: (Show a, Tagged a) => a -> String


-- | Low-level network connection management.
module Network.Riak.Connection

-- | Connect to a server.
connect :: Client -> IO Connection

-- | Disconnect from a server.
disconnect :: Connection -> IO ()

-- | Default client configuration. Talks to localhost, port 8087, with a
--   randomly chosen client ID.
defaultClient :: Client

-- | Generate a random client ID.
makeClientID :: IO ClientID

-- | Send a request to the server, and receive its response.
exchange :: Exchange req resp => Connection -> req -> IO resp

-- | Send a request to the server, and receive its response (which may be
--   empty).
exchangeMaybe :: Exchange req resp => Connection -> req -> IO (Maybe resp)

-- | Send a request to the server, and receive its response, but do not
--   decode it.
exchange_ :: Request req => Connection -> req -> IO ()

-- | Send a series of requests to the server, back to back, and receive a
--   response for each request sent. The sending and receiving will be
--   overlapped if possible, to improve concurrency and reduce latency.
pipeline :: Exchange req resp => Connection -> [req] -> IO [resp]

-- | Send a series of requests to the server, back to back, and receive a
--   response for each request sent (the responses may be empty). The
--   sending and receiving will be overlapped if possible, to improve
--   concurrency and reduce latency.
pipelineMaybe :: Exchange req resp => Connection -> [req] -> IO [Maybe resp]

-- | Send a series of requests to the server, back to back, and receive
--   (but do not decode) a response for each request sent. The sending and
--   receiving will be overlapped if possible, to improve concurrency and
--   reduce latency.
pipeline_ :: Request req => Connection -> [req] -> IO ()


-- | Basic types.
module Network.Riak.Types

-- | A client identifier. This is used by the Riak cluster when logging
--   vector clock changes, and should be unique for each client.
type ClientID = ByteString
data Client
Client :: HostName -> ServiceName -> ClientID -> Client

-- | Name of the server to connect to.
host :: Client -> HostName

-- | Port number to connect to (default is 8087).
port :: Client -> ServiceName

-- | Client identifier.
clientID :: Client -> ClientID

-- | A connection to a Riak server.
data Connection

-- | The main Riak exception type.
data RiakException

-- | A Bucket is a container and keyspace for data stored in Riak, with a
--   set of common properties for its contents (the number of replicas, for
--   instance).
type Bucket = ByteString

-- | Keys are unique object identifiers in Riak and are scoped within
--   buckets.
type Key = ByteString

-- | An application-specific identifier for a link. See
--   <a>http://wiki.basho.com/Links.html</a> for details.
type Tag = ByteString

-- | A wrapper that keeps Riak vector clocks opaque.
newtype VClock
VClock :: ByteString -> VClock

-- | Unwrap the <a>ByteString</a>. (This is really only useful for printing
--   the raw vclock string.)
fromVClock :: VClock -> ByteString

-- | A specification of a MapReduce job.
--   <a>http://wiki.basho.com/MapReduce.html</a>.
data Job
JSON :: ByteString -> Job
Erlang :: ByteString -> Job

-- | A read/write quorum. The quantity of replicas that must respond to a
--   read or write request before it is considered successful. This is
--   defined as a bucket property or as one of the relevant parameters to a
--   single request (<a>R</a>,<a>W</a>,<a>DW</a>,<a>RW</a>).
data Quorum

-- | Use the default quorum settings for the bucket.
Default :: Quorum

-- | Success after one server has responded.
One :: Quorum

-- | Success after a quorum of servers has responded.
Quorum :: Quorum

-- | Success after all servers have responded.
All :: Quorum

-- | Read/write quorum. How many replicas need to collaborate when deleting
--   a value.
type RW = Quorum

-- | Read quorum. How many replicas need to agree when retrieving a value.
type R = Quorum

-- | Write quorum. How many replicas to write to before returning a
--   successful response.
type W = Quorum

-- | Durable write quorum. How many replicas to commit to durable storage
--   before returning a successful response.
type DW = Quorum

-- | A message representing a request from client to server.
class (Tagged msg, ReflectDescriptor msg, Show msg, Wire msg) => Request msg

-- | A message representing a response from server to client.
class (Tagged msg, ReflectDescriptor msg, Show msg, Wire msg) => Response msg
class (Request req, Response resp) => Exchange req resp | req -> resp, resp -> req

-- | An identifier for an inbound or outbound message.
data MessageTag
ErrorResponse :: MessageTag
PingRequest :: MessageTag
PingResponse :: MessageTag
GetClientIDRequest :: MessageTag
GetClientIDResponse :: MessageTag
SetClientIDRequest :: MessageTag
SetClientIDResponse :: MessageTag
GetServerInfoRequest :: MessageTag
GetServerInfoResponse :: MessageTag
GetRequest :: MessageTag
GetResponse :: MessageTag
PutRequest :: MessageTag
PutResponse :: MessageTag
DeleteRequest :: MessageTag
DeleteResponse :: MessageTag
ListBucketsRequest :: MessageTag
ListBucketsResponse :: MessageTag
ListKeysRequest :: MessageTag
ListKeysResponse :: MessageTag
GetBucketRequest :: MessageTag
GetBucketResponse :: MessageTag
SetBucketRequest :: MessageTag
SetBucketResponse :: MessageTag
MapReduceRequest :: MessageTag
MapReduceResponse :: MessageTag
IndexRequest :: MessageTag
IndexResponse :: MessageTag

-- | Messages are tagged.
class Tagged msg
messageTag :: Tagged msg => msg -> MessageTag
data IndexValue
IndexInt :: !Index -> !Int -> IndexValue
IndexBin :: !Index -> !ByteString -> IndexValue

-- | Index query. Can be exact or range, int or bin. Index name should not
--   contain the "_bin" or "_int" part, since it's determined from data
--   constructor.
data IndexQuery
IndexQueryExactInt :: !Index -> !Int -> IndexQuery
IndexQueryExactBin :: !Index -> !ByteString -> IndexQuery
IndexQueryRangeInt :: !Index -> !Int -> !Int -> IndexQuery
IndexQueryRangeBin :: !Index -> !ByteString -> !ByteString -> IndexQuery


-- | Storage and retrieval of data with automatic conflict resolution.
module Network.Riak.Resolvable

-- | A type that can automatically resolve a vector clock conflict between
--   two or more versions of a value.
--   
--   Instances must be symmetric in their behaviour, such that the
--   following law is obeyed:
--   
--   <pre>
--   resolve a b == resolve b a
--   </pre>
--   
--   Otherwise, there are no restrictions on the behaviour of
--   <a>resolve</a>. The result may be <tt>a</tt>, <tt>b</tt>, a value
--   derived from <tt>a</tt> and <tt>b</tt>, or something else.
--   
--   If several conflicting siblings are found, <a>resolve</a> will be
--   applied over all of them using a fold, to yield a single "winner".
class Show a => Resolvable a
resolve :: Resolvable a => a -> a -> a

-- | A newtype wrapper that uses the <a>mappend</a> method of a type's
--   <a>Monoid</a> instance to perform vector clock conflict resolution.
newtype ResolvableMonoid a
RM :: a -> ResolvableMonoid a
unRM :: ResolvableMonoid a -> a

-- | Automated conflict resolution failed.
data ResolutionFailure

-- | Too many attempts were made to resolve a conflict, with each attempt
--   resulting in another conflict.
--   
--   The number of retries that the library will attempt is high (64). This
--   makes it extremely unlikely that this exception will be thrown during
--   normal application operation. Instead, this exception is most likely
--   to be thrown as a result of a bug in your application code, for
--   example if your <a>resolve</a> function is misbehaving.
RetriesExceeded :: ResolutionFailure


-- | This module allows storage and retrieval of data using the
--   <a>IsContent</a> typeclass. This provides access to more of Riak's
--   storage features than JSON, e.g. links.
--   
--   The functions in this module do not perform any conflict resolution.
module Network.Riak.Value
class IsContent c
parseContent :: IsContent c => Content -> Parser c
toContent :: IsContent c => c -> Content
fromContent :: IsContent c => Content -> Maybe c

-- | Retrieve a value. This may return multiple conflicting siblings.
--   Choosing among them is your responsibility.
get :: IsContent c => Connection -> Bucket -> Key -> R -> IO (Maybe ([c], VClock))
getMany :: IsContent c => Connection -> Bucket -> [Key] -> R -> IO [Maybe ([c], VClock)]

-- | Retrieve list of keys matching some index query.
getByIndex :: Connection -> Bucket -> IndexQuery -> IO [Key]

-- | Add indexes to a content value for a further put request.
addIndexes :: [IndexValue] -> Content -> Content

-- | Store a single value. This may return multiple conflicting siblings.
--   Choosing among them, and storing a new value, is your responsibility.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored.
put :: IsContent c => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO ([c], VClock)

-- | Store an indexed value.
putIndexed :: IsContent c => Connection -> Bucket -> Key -> [IndexValue] -> Maybe VClock -> c -> W -> DW -> IO ([c], VClock)

-- | Store a single value, without the possibility of conflict resolution.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored, and you will not be notified.
put_ :: IsContent c => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO ()

-- | Store many values. This may return multiple conflicting siblings for
--   each value stored. Choosing among them, and storing a new value in
--   each case, is your responsibility.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored.
putMany :: IsContent c => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO [([c], VClock)]

-- | Store many values, without the possibility of conflict resolution.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored, and you will not be notified.
putMany_ :: IsContent c => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO ()
instance IsContent a => IsContent (ResolvableMonoid a)
instance IsContent Value
instance IsContent ()
instance IsContent Content


-- | This module allows storage and retrieval of data encoded using the
--   <a>IsContent</a> typeclass. This provides access to more of Riak's
--   storage features than JSON, e.g. links.
--   
--   Functions automatically resolve conflicts using <a>Resolvable</a>
--   instances. For instance, if a <a>get</a> returns three siblings, a
--   winner will be chosen using <a>resolve</a>. If a <a>put</a> results in
--   a conflict, a winner will be chosen using <a>resolve</a>, and the
--   winner will be <a>put</a>; this will be repeated until either no
--   conflict occurs or the process has been repeated too many times.
module Network.Riak.Value.Resolvable
class IsContent c
parseContent :: IsContent c => Content -> Parser c
toContent :: IsContent c => c -> Content

-- | A type that can automatically resolve a vector clock conflict between
--   two or more versions of a value.
--   
--   Instances must be symmetric in their behaviour, such that the
--   following law is obeyed:
--   
--   <pre>
--   resolve a b == resolve b a
--   </pre>
--   
--   Otherwise, there are no restrictions on the behaviour of
--   <a>resolve</a>. The result may be <tt>a</tt>, <tt>b</tt>, a value
--   derived from <tt>a</tt> and <tt>b</tt>, or something else.
--   
--   If several conflicting siblings are found, <a>resolve</a> will be
--   applied over all of them using a fold, to yield a single "winner".
class Show a => Resolvable a
resolve :: Resolvable a => a -> a -> a

-- | Automated conflict resolution failed.
data ResolutionFailure

-- | Too many attempts were made to resolve a conflict, with each attempt
--   resulting in another conflict.
--   
--   The number of retries that the library will attempt is high (64). This
--   makes it extremely unlikely that this exception will be thrown during
--   normal application operation. Instead, this exception is most likely
--   to be thrown as a result of a bug in your application code, for
--   example if your <a>resolve</a> function is misbehaving.
RetriesExceeded :: ResolutionFailure

-- | Retrieve a single value. If conflicting values are returned, the
--   <a>Resolvable</a> is used to choose a winner.
get :: (Resolvable a, IsContent a) => Connection -> Bucket -> Key -> R -> IO (Maybe (a, VClock))

-- | Retrieve multiple values. If conflicting values are returned for a
--   key, the <a>Resolvable</a> is used to choose a winner.
getMany :: (Resolvable a, IsContent a) => Connection -> Bucket -> [Key] -> R -> IO [Maybe (a, VClock)]

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>,
--   along with the auxiliary value returned by the modification function.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify :: (Resolvable a, IsContent a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO (a, b)) -> IO (a, b)

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify_ :: (Resolvable a, IsContent a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO a) -> IO a

-- | Store a single value, automatically resolving any vector clock
--   conflicts that arise. A single invocation of this function may involve
--   several roundtrips to the server to resolve conflicts.
--   
--   If a conflict arises, a winner will be chosen using <a>resolve</a>,
--   and the winner will be stored; this will be repeated until no conflict
--   occurs or a (fairly large) number of retries has been attempted
--   without success.
--   
--   If this function gives up due to apparently being stuck in a conflict
--   resolution loop, it will throw a <a>ResolutionFailure</a> exception.
put :: (Resolvable a, IsContent a) => Connection -> Bucket -> Key -> Maybe VClock -> a -> W -> DW -> IO (a, VClock)

-- | Store a single value, automatically resolving any vector clock
--   conflicts that arise. A single invocation of this function may involve
--   several roundtrips to the server to resolve conflicts.
--   
--   If a conflict arises, a winner will be chosen using <a>resolve</a>,
--   and the winner will be stored; this will be repeated until no conflict
--   occurs or a (fairly large) number of retries has been attempted
--   without success.
--   
--   If this function gives up due to apparently being stuck in a conflict
--   resolution loop, it will throw a <a>ResolutionFailure</a> exception.
put_ :: (Resolvable a, IsContent a) => Connection -> Bucket -> Key -> Maybe VClock -> a -> W -> DW -> IO ()

-- | Store multiple values, resolving any vector clock conflicts that
--   arise. A single invocation of this function may involve several
--   roundtrips to the server to resolve conflicts.
--   
--   If any conflicts arise, a winner will be chosen in each case using
--   <a>resolve</a>, and the winners will be stored; this will be repeated
--   until either no conflicts occur or a (fairly large) number of retries
--   has been attempted without success.
--   
--   For each original value to be stored, the final value that was stored
--   at the end of any conflict resolution is returned.
--   
--   If this function gives up due to apparently being stuck in a loop, it
--   will throw a <a>ResolutionFailure</a> exception.
putMany :: (Resolvable a, IsContent a) => Connection -> Bucket -> [(Key, Maybe VClock, a)] -> W -> DW -> IO [(a, VClock)]

-- | Store multiple values, resolving any vector clock conflicts that
--   arise. A single invocation of this function may involve several
--   roundtrips to the server to resolve conflicts.
--   
--   If any conflicts arise, a winner will be chosen in each case using
--   <a>resolve</a>, and the winners will be stored; this will be repeated
--   until either no conflicts occur or a (fairly large) number of retries
--   has been attempted without success.
--   
--   If this function gives up due to apparently being stuck in a loop, it
--   will throw a <a>ResolutionFailure</a> exception.
putMany_ :: (Resolvable a, IsContent a) => Connection -> Bucket -> [(Key, Maybe VClock, a)] -> W -> DW -> IO ()


-- | This module allows storage and retrieval of JSON-encoded data.
--   
--   The functions in this module do not perform any conflict resolution.
module Network.Riak.JSON
data JSON a

-- | Wrap up a value so that it will be encoded and decoded as JSON when
--   converted to/from <tt>Content</tt>.
json :: (FromJSON a, ToJSON a) => a -> JSON a

-- | Unwrap a <a>JSON</a>-wrapped value.
plain :: JSON a -> a

-- | Retrieve a value. This may return multiple conflicting siblings.
--   Choosing among them is your responsibility.
get :: (FromJSON c, ToJSON c) => Connection -> Bucket -> Key -> R -> IO (Maybe ([c], VClock))
getMany :: (FromJSON c, ToJSON c) => Connection -> Bucket -> [Key] -> R -> IO [Maybe ([c], VClock)]

-- | Store a single value. This may return multiple conflicting siblings.
--   Choosing among them, and storing a new value, is your responsibility.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored.
put :: (FromJSON c, ToJSON c) => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO ([c], VClock)

-- | Store a single value indexed.
putIndexed :: (FromJSON c, ToJSON c) => Connection -> Bucket -> Key -> [IndexValue] -> Maybe VClock -> c -> W -> DW -> IO ([c], VClock)

-- | Store a single value, without the possibility of conflict resolution.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored, and you will not be notified.
put_ :: (FromJSON c, ToJSON c) => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO ()

-- | Store many values. This may return multiple conflicting siblings for
--   each value stored. Choosing among them, and storing a new value in
--   each case, is your responsibility.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored.
putMany :: (FromJSON c, ToJSON c) => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO [([c], VClock)]

-- | Store many values, without the possibility of conflict resolution.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored, and you will not be notified.
putMany_ :: (FromJSON c, ToJSON c) => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO ()
instance Typeable JSON
instance Eq a => Eq (JSON a)
instance Ord a => Ord (JSON a)
instance Show a => Show (JSON a)
instance Read a => Read (JSON a)
instance Bounded a => Bounded (JSON a)
instance Monoid a => Monoid (JSON a)
instance (FromJSON a, ToJSON a) => IsContent (JSON a)
instance Functor JSON


-- | This module allows storage and retrieval of JSON-encoded data.
--   
--   Functions automatically resolve conflicts using <a>Resolvable</a>
--   instances. For instance, if a <a>get</a> returns three siblings, a
--   winner will be chosen using <a>resolve</a>. If a <a>put</a> results in
--   a conflict, a winner will be chosen using <a>resolve</a>, and the
--   winner will be <a>put</a>; this will be repeated until either no
--   conflict occurs or the process has been repeated too many times.
module Network.Riak.JSON.Resolvable

-- | A type that can automatically resolve a vector clock conflict between
--   two or more versions of a value.
--   
--   Instances must be symmetric in their behaviour, such that the
--   following law is obeyed:
--   
--   <pre>
--   resolve a b == resolve b a
--   </pre>
--   
--   Otherwise, there are no restrictions on the behaviour of
--   <a>resolve</a>. The result may be <tt>a</tt>, <tt>b</tt>, a value
--   derived from <tt>a</tt> and <tt>b</tt>, or something else.
--   
--   If several conflicting siblings are found, <a>resolve</a> will be
--   applied over all of them using a fold, to yield a single "winner".
class Show a => Resolvable a
resolve :: Resolvable a => a -> a -> a

-- | Automated conflict resolution failed.
data ResolutionFailure

-- | Too many attempts were made to resolve a conflict, with each attempt
--   resulting in another conflict.
--   
--   The number of retries that the library will attempt is high (64). This
--   makes it extremely unlikely that this exception will be thrown during
--   normal application operation. Instead, this exception is most likely
--   to be thrown as a result of a bug in your application code, for
--   example if your <a>resolve</a> function is misbehaving.
RetriesExceeded :: ResolutionFailure

-- | Retrieve a single value. If conflicting values are returned,
--   <a>resolve</a> is used to choose a winner.
get :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> R -> IO (Maybe (c, VClock))

-- | Retrieve multiple values. If conflicting values are returned for a
--   key, <a>resolve</a> is used to choose a winner.
getMany :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> [Key] -> R -> IO [Maybe (c, VClock)]

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>,
--   along with the auxiliary value returned by the modification function.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify :: (FromJSON a, ToJSON a, Resolvable a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO (a, b)) -> IO (a, b)

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify_ :: (FromJSON a, ToJSON a, Resolvable a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO a) -> IO a

-- | Store a single value, automatically resolving any vector clock
--   conflicts that arise. A single invocation of this function may involve
--   several roundtrips to the server to resolve conflicts.
--   
--   If a conflict arises, a winner will be chosen using <a>resolve</a>,
--   and the winner will be stored; this will be repeated until no conflict
--   occurs or a (fairly large) number of retries has been attempted
--   without success.
--   
--   If this function gives up due to apparently being stuck in a conflict
--   resolution loop, it will throw a <a>ResolutionFailure</a> exception.
put :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO (c, VClock)

-- | Store a single value indexed.
putIndexed :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> [IndexValue] -> Maybe VClock -> c -> W -> DW -> IO (c, VClock)

-- | Store a single value, automatically resolving any vector clock
--   conflicts that arise. A single invocation of this function may involve
--   several roundtrips to the server to resolve conflicts.
--   
--   If a conflict arises, a winner will be chosen using <a>resolve</a>,
--   and the winner will be stored; this will be repeated until no conflict
--   occurs or a (fairly large) number of retries has been attempted
--   without success.
--   
--   If this function gives up due to apparently being stuck in a conflict
--   resolution loop, it will throw a <a>ResolutionFailure</a> exception.
put_ :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO ()

-- | Store multiple values, resolving any vector clock conflicts that
--   arise. A single invocation of this function may involve several
--   roundtrips to the server to resolve conflicts.
--   
--   If any conflicts arise, a winner will be chosen in each case using
--   <a>resolve</a>, and the winners will be stored; this will be repeated
--   until either no conflicts occur or a (fairly large) number of retries
--   has been attempted without success.
--   
--   For each original value to be stored, the final value that was stored
--   at the end of any conflict resolution is returned.
--   
--   If this function gives up due to apparently being stuck in a loop, it
--   will throw a <a>ResolutionFailure</a> exception.
putMany :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO [(c, VClock)]

-- | Store multiple values, resolving any vector clock conflicts that
--   arise. A single invocation of this function may involve several
--   roundtrips to the server to resolve conflicts.
--   
--   If any conflicts arise, a winner will be chosen in each case using
--   <a>resolve</a>, and the winners will be stored; this will be repeated
--   until either no conflicts occur or a (fairly large) number of retries
--   has been attempted without success.
--   
--   If this function gives up due to apparently being stuck in a loop, it
--   will throw a <a>ResolutionFailure</a> exception.
putMany_ :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO ()


-- | Basic support for the Riak decentralized data store.
--   
--   When storing and retrieving data, the functions in this module do not
--   perform any encoding or decoding of data, nor do they resolve
--   conflicts.
module Network.Riak.Basic

-- | A client identifier. This is used by the Riak cluster when logging
--   vector clock changes, and should be unique for each client.
type ClientID = ByteString
data Client
Client :: HostName -> ServiceName -> ClientID -> Client

-- | Name of the server to connect to.
host :: Client -> HostName

-- | Port number to connect to (default is 8087).
port :: Client -> ServiceName

-- | Client identifier.
clientID :: Client -> ClientID

-- | Default client configuration. Talks to localhost, port 8087, with a
--   randomly chosen client ID.
defaultClient :: Client

-- | A connection to a Riak server.
data Connection
Connection :: Socket -> Client -> IORef ByteString -> Connection
connSock :: Connection -> Socket

-- | The configuration we connected with.
connClient :: Connection -> Client

-- | Received data that has not yet been consumed.
connBuffer :: Connection -> IORef ByteString

-- | Connect to a server.
connect :: Client -> IO Connection

-- | Disconnect from a server.
disconnect :: Connection -> IO ()

-- | Check to see if the connection to the server is alive.
ping :: Connection -> IO ()

-- | Find out from the server what client ID this connection is using.
getClientID :: Connection -> IO ClientID

-- | Tell the server our client ID.
setClientID :: Connection -> ClientID -> IO ()

-- | Retrieve information about the server.
getServerInfo :: Connection -> IO ServerInfo

-- | A read/write quorum. The quantity of replicas that must respond to a
--   read or write request before it is considered successful. This is
--   defined as a bucket property or as one of the relevant parameters to a
--   single request (<a>R</a>,<a>W</a>,<a>DW</a>,<a>RW</a>).
data Quorum

-- | Use the default quorum settings for the bucket.
Default :: Quorum

-- | Success after one server has responded.
One :: Quorum

-- | Success after a quorum of servers has responded.
Quorum :: Quorum

-- | Success after all servers have responded.
All :: Quorum

-- | Retrieve a value. This may return multiple conflicting siblings.
--   Choosing among them is your responsibility.
get :: Connection -> Bucket -> Key -> R -> IO (Maybe (Seq Content, VClock))

-- | Store a single value. This may return multiple conflicting siblings.
--   Choosing among them, and storing a new value, is your responsibility.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored.
put :: Connection -> Bucket -> Key -> Maybe VClock -> Content -> W -> DW -> IO (Seq Content, VClock)

-- | Store a single value, without the possibility of conflict resolution.
--   
--   You should <i>only</i> supply <a>Nothing</a> as a <a>VClock</a> if you
--   are sure that the given bucket+key combination does not already exist.
--   If you omit a <a>VClock</a> but the bucket+key <i>does</i> exist, your
--   value will not be stored, and you will not be notified.
put_ :: Connection -> Bucket -> Key -> Maybe VClock -> Content -> W -> DW -> IO ()

-- | Delete a value.
delete :: Connection -> Bucket -> Key -> RW -> IO ()
listBuckets :: Connection -> IO (Seq Bucket)
foldKeys :: Connection -> Bucket -> (a -> Key -> IO a) -> a -> IO a

-- | Retrieve the properties of a bucket.
getBucket :: Connection -> Bucket -> IO BucketProps

-- | Store new properties for a bucket.
setBucket :: Connection -> Bucket -> BucketProps -> IO ()

-- | Run a <a>MapReduce</a> job. Its result is consumed via a strict left
--   fold.
mapReduce :: Connection -> Job -> (a -> MapReduce -> a) -> a -> IO a


-- | A client for the Riak decentralized data store.
--   
--   The functions in this module use JSON as the storage representation,
--   and automatically perform conflict resolution during storage and
--   retrieval.
--   
--   This library is organized to allow a tradeoff between power and ease
--   of use. If you would like a different degree of automation with
--   storage and conflict resolution, you may want to use one of the
--   following modules (ranked from easiest to most tricky to use):
--   
--   <ul>
--   <li><i>Network.Riak.JSON.Resolvable</i> JSON for storage, automatic
--   conflict resolution. (This module actually re-exports its
--   definitions.) This is the easiest module to work with.</li>
--   <li><i>Network.Riak.JSON</i> JSON for storage, manual conflict
--   resolution.</li>
--   <li><i>Network.Riak.Value.Resolvable</i> More complex (but still
--   automatic) storage, automatic conflict resolution.</li>
--   <li><i>Network.Riak.Value</i> More complex (but still automatic)
--   storage, manual conflict resolution.</li>
--   <li><i>Network.Riak.Basic</i> manual storage, manual conflict
--   resolution. This is the most demanding module to work with, as you
--   must encode and decode data yourself, and handle all conflict
--   resolution yourself.</li>
--   </ul>
--   
--   A short getting started guide is available at
--   <a>http://docs.basho.com/riak/latest/dev/taste-of-riak/haskell/</a>
module Network.Riak

-- | A client identifier. This is used by the Riak cluster when logging
--   vector clock changes, and should be unique for each client.
type ClientID = ByteString
data Client
Client :: HostName -> ServiceName -> ClientID -> Client

-- | Name of the server to connect to.
host :: Client -> HostName

-- | Port number to connect to (default is 8087).
port :: Client -> ServiceName

-- | Client identifier.
clientID :: Client -> ClientID

-- | Default client configuration. Talks to localhost, port 8087, with a
--   randomly chosen client ID.
defaultClient :: Client

-- | Find out from the server what client ID this connection is using.
getClientID :: Connection -> IO ClientID

-- | A connection to a Riak server.
data Connection
Connection :: Socket -> Client -> IORef ByteString -> Connection
connSock :: Connection -> Socket

-- | The configuration we connected with.
connClient :: Connection -> Client

-- | Received data that has not yet been consumed.
connBuffer :: Connection -> IORef ByteString

-- | Connect to a server.
connect :: Client -> IO Connection

-- | Disconnect from a server.
disconnect :: Connection -> IO ()

-- | Check to see if the connection to the server is alive.
ping :: Connection -> IO ()

-- | Retrieve information about the server.
getServerInfo :: Connection -> IO ServerInfo

-- | A read/write quorum. The quantity of replicas that must respond to a
--   read or write request before it is considered successful. This is
--   defined as a bucket property or as one of the relevant parameters to a
--   single request (<a>R</a>,<a>W</a>,<a>DW</a>,<a>RW</a>).
data Quorum

-- | Use the default quorum settings for the bucket.
Default :: Quorum

-- | Success after one server has responded.
One :: Quorum

-- | Success after a quorum of servers has responded.
Quorum :: Quorum

-- | Success after all servers have responded.
All :: Quorum

-- | A type that can automatically resolve a vector clock conflict between
--   two or more versions of a value.
--   
--   Instances must be symmetric in their behaviour, such that the
--   following law is obeyed:
--   
--   <pre>
--   resolve a b == resolve b a
--   </pre>
--   
--   Otherwise, there are no restrictions on the behaviour of
--   <a>resolve</a>. The result may be <tt>a</tt>, <tt>b</tt>, a value
--   derived from <tt>a</tt> and <tt>b</tt>, or something else.
--   
--   If several conflicting siblings are found, <a>resolve</a> will be
--   applied over all of them using a fold, to yield a single "winner".
class Show a => Resolvable a
resolve :: Resolvable a => a -> a -> a

-- | Retrieve a single value. If conflicting values are returned,
--   <a>resolve</a> is used to choose a winner.
get :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> R -> IO (Maybe (c, VClock))

-- | Retrieve multiple values. If conflicting values are returned for a
--   key, <a>resolve</a> is used to choose a winner.
getMany :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> [Key] -> R -> IO [Maybe (c, VClock)]

-- | Retrieve list of keys matching some index query.
getByIndex :: Connection -> Bucket -> IndexQuery -> IO [Key]

-- | Add indexes to a content value for a further put request.
addIndexes :: [IndexValue] -> Content -> Content

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>,
--   along with the auxiliary value returned by the modification function.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify :: (FromJSON a, ToJSON a, Resolvable a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO (a, b)) -> IO (a, b)

-- | Modify a single value. The value, if any, is retrieved using
--   <a>get</a>; conflict resolution is performed if necessary. The
--   modification function is called on the resulting value, and its result
--   is stored using <a>put</a>, which may again perform conflict
--   resolution.
--   
--   The result of this function is whatever was returned by <a>put</a>.
--   
--   If the <a>put</a> phase of this function gives up due to apparently
--   being stuck in a conflict resolution loop, it will throw a
--   <a>ResolutionFailure</a> exception.
modify_ :: (FromJSON a, ToJSON a, Resolvable a) => Connection -> Bucket -> Key -> R -> W -> DW -> (Maybe a -> IO a) -> IO a

-- | Delete a value.
delete :: Connection -> Bucket -> Key -> RW -> IO ()

-- | Store a single value, automatically resolving any vector clock
--   conflicts that arise. A single invocation of this function may involve
--   several roundtrips to the server to resolve conflicts.
--   
--   If a conflict arises, a winner will be chosen using <a>resolve</a>,
--   and the winner will be stored; this will be repeated until no conflict
--   occurs or a (fairly large) number of retries has been attempted
--   without success.
--   
--   If this function gives up due to apparently being stuck in a conflict
--   resolution loop, it will throw a <a>ResolutionFailure</a> exception.
put :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> Maybe VClock -> c -> W -> DW -> IO (c, VClock)

-- | Store a single value indexed.
putIndexed :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> Key -> [IndexValue] -> Maybe VClock -> c -> W -> DW -> IO (c, VClock)

-- | Store multiple values, resolving any vector clock conflicts that
--   arise. A single invocation of this function may involve several
--   roundtrips to the server to resolve conflicts.
--   
--   If any conflicts arise, a winner will be chosen in each case using
--   <a>resolve</a>, and the winners will be stored; this will be repeated
--   until either no conflicts occur or a (fairly large) number of retries
--   has been attempted without success.
--   
--   For each original value to be stored, the final value that was stored
--   at the end of any conflict resolution is returned.
--   
--   If this function gives up due to apparently being stuck in a loop, it
--   will throw a <a>ResolutionFailure</a> exception.
putMany :: (FromJSON c, ToJSON c, Resolvable c) => Connection -> Bucket -> [(Key, Maybe VClock, c)] -> W -> DW -> IO [(c, VClock)]
listBuckets :: Connection -> IO (Seq Bucket)
foldKeys :: Connection -> Bucket -> (a -> Key -> IO a) -> a -> IO a

-- | Retrieve the properties of a bucket.
getBucket :: Connection -> Bucket -> IO BucketProps

-- | Store new properties for a bucket.
setBucket :: Connection -> Bucket -> BucketProps -> IO ()

-- | Run a <a>MapReduce</a> job. Its result is consumed via a strict left
--   fold.
mapReduce :: Connection -> Job -> (a -> MapReduce -> a) -> a -> IO a

-- | Index query. Can be exact or range, int or bin. Index name should not
--   contain the "_bin" or "_int" part, since it's determined from data
--   constructor.
data IndexQuery
IndexQueryExactInt :: !Index -> !Int -> IndexQuery
IndexQueryExactBin :: !Index -> !ByteString -> IndexQuery
IndexQueryRangeInt :: !Index -> !Int -> !Int -> IndexQuery
IndexQueryRangeBin :: !Index -> !ByteString -> !ByteString -> IndexQuery
data IndexValue
IndexInt :: !Index -> !Int -> IndexValue
IndexBin :: !Index -> !ByteString -> IndexValue


-- | A high-performance striped pooling abstraction for managing
--   connections to a Riak cluster. This is a thin wrapper around
--   <a>Pool</a>.
module Network.Riak.Connection.Pool

-- | A pool of connections to a Riak server.
--   
--   This pool is "striped", i.e. it consists of several sub-pools that are
--   managed independently.
--   
--   The total number of connections that can possibly be open at once is
--   <a>maxConnections</a> * <a>numStripes</a>.
data Pool

-- | Client specification. The client ID is ignored, and always regenerated
--   automatically for each new connection.
client :: Pool -> Client

-- | Create a new connection pool.
create :: Client -> Int -> NominalDiffTime -> Int -> IO Pool

-- | Amount of time for which an unused connection is kept open. The
--   smallest acceptable value is 0.5 seconds.
--   
--   The elapsed time before closing may be a little longer than requested,
--   as the reaper thread wakes at 1-second intervals.
idleTime :: Pool -> NominalDiffTime

-- | Maximum number of connections to keep open per stripe. The smallest
--   acceptable value is 1.
--   
--   Requests for connections will block if this limit is reached on a
--   single stripe, even if other stripes have idle connections available.
maxConnections :: Pool -> Int

-- | Stripe count. The number of distinct sub-pools to maintain. The
--   smallest acceptable value is 1.
numStripes :: Pool -> Int

-- | Temporarily take a connection from a <a>Pool</a>, perform an action
--   with it, and return it to the pool afterwards.
--   
--   <ul>
--   <li>If the pool has a connection available, it is used
--   immediately.</li>
--   <li>Otherwise, if the maximum number of connections has not been
--   reached, a new connection is created and used.</li>
--   <li>If the maximum number of connections has been reached, this
--   function blocks until a connection becomes available, then that
--   connection is used.</li>
--   </ul>
--   
--   If the action throws an exception of any type, the <a>Connection</a>
--   is destroyed, and not returned to the pool.
--   
--   It probably goes without saying that you should never call
--   <a>disconnect</a> on a connection, as doing so will cause a subsequent
--   user (who expects the connection to be valid) to throw an exception.
withConnection :: Pool -> (Connection -> IO a) -> IO a

-- | Temporarily take a connection from a <a>Pool</a>, perform an action
--   with it, and return it to the pool afterwards. This is a
--   generalization of <a>withConnection</a>, which remains specialized to
--   prevent breaking source compatibility with existing code.
--   
--   <ul>
--   <li>If the pool has a connection available, it is used
--   immediately.</li>
--   <li>Otherwise, if the maximum number of connections has not been
--   reached, a new connection is created and used.</li>
--   <li>If the maximum number of connections has been reached, this
--   function blocks until a connection becomes available, then that
--   connection is used.</li>
--   </ul>
--   
--   If the action throws an exception of any type, the <a>Connection</a>
--   is destroyed, and not returned to the pool.
--   
--   It probably goes without saying that you should never call
--   <a>disconnect</a> on a connection, as doing so will cause a subsequent
--   user (who expects the connection to be valid) to throw an exception.
withConnectionM :: MonadBaseControl IO m => Pool -> (Connection -> m a) -> m a
instance Typeable Pool
instance Eq Pool
instance Show Pool
