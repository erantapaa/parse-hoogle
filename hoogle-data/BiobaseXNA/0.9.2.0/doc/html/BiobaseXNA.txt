-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient RNA/DNA representations
--   
@package BiobaseXNA
@version 0.9.2.0


-- | A special class of bounds for RNA/pair encodings that are used to
--   index into tables. We typically encode more in the alphabets than we
--   want to use to index, so in order to keep things simple, we have
--   specialized bounds.
module Biobase.Primary.Bounds


-- | A newtype with an attached phenotype which allows us to encode
--   nucleotides and amino acids. Actual seqence-specific functions can be
--   founds in the appropriate modules <tt>AA</tt> and <tt>Nuc</tt>.
module Biobase.Primary.Letter

-- | A <a>Letter</a> together with its phantom type <tt>t</tt> encodes
--   bio-sequences.
newtype Letter t
Letter :: Int -> Letter t
getLetter :: Letter t -> Int
type Primary t = Vector (Letter t)

-- | Conversion from a large number of sequence-like inputs to primary
--   sequences.
class MkPrimary n t
primary :: MkPrimary n t => n -> Primary t
instance IndexStream (Letter l)
instance IndexStream z => IndexStream (z :. Letter l)
instance Index (Letter l)
instance Hashable (Letter t)
instance Vector Vector (Letter a0)
instance MVector MVector (Letter a0)
instance Unbox (Letter a0)
instance Eq (Letter t)
instance Ord (Letter t)
instance Generic (Letter t)
instance Ix (Letter t)
instance Datatype D1Letter
instance Constructor C1_0Letter
instance Selector S1_0_0Letter
instance (Unbox (Letter t), IsString [Letter t]) => IsString (Vector (Letter t))
instance MkPrimary (Vector Char) t => MkPrimary ByteString t
instance MkPrimary (Vector Char) t => MkPrimary ByteString t
instance MkPrimary (Vector Char) t => MkPrimary Text t
instance MkPrimary (Vector Char) t => MkPrimary Text t
instance MkPrimary (Vector Char) t => MkPrimary String t
instance NFData (Letter t)
instance ToJSON (Letter t)
instance FromJSON (Letter t)
instance Serialize (Letter t)
instance Binary (Letter t)


-- | A <a>Letter</a> with unknown annotation. We sometimes want to encode
--   that we are dealing with <tt>Letter</tt>s in an alphabet, but we do
--   not want to commit to a certain alphabet (just yet).
--   
--   This module allows us to make explicit that we do not know the
--   specific alphabet type yet.
module Biobase.Primary.Unknown

-- | <tt>Unknown</tt> phantom type.
data Unknown

-- | Creating an unknown letter.
unk :: Int -> Letter Unknown
instance MkPrimary (Vector Int) Unknown
instance Enum (Letter Unknown)
instance Read (Letter Unknown)
instance Show (Letter Unknown)

module Biobase.Primary.Nuc.RNA

-- | RNA nucleotides.
data RNA
acgu :: [Letter RNA]
charRNA :: Char -> Letter RNA
rnaChar :: Letter RNA -> Char
rnaSeq :: MkPrimary n RNA => n -> Primary RNA
instance IsString [Letter RNA]
instance MkPrimary (Vector Char) RNA
instance Read (Letter RNA)
instance Show (Letter RNA)
instance Enum (Letter RNA)
instance Bounded (Letter RNA)

module Biobase.Primary.Nuc.DNA

-- | DNA nucleotides.
data DNA
acgt :: [Letter DNA]
charDNA :: Char -> Letter DNA
dnaChar :: Letter DNA -> Char
dnaSeq :: MkPrimary n DNA => n -> Primary DNA
instance IsString [Letter DNA]
instance MkPrimary (Vector Char) DNA
instance Bounded (Letter DNA)
instance Read (Letter DNA)
instance Show (Letter DNA)
instance Enum (Letter DNA)

module Biobase.Primary.Nuc.XNA

-- | Combine both, RNA and DNA.
data XNA
charXNA :: Char -> Letter XNA
xnaChar :: Letter XNA -> Char
xnaSeq :: MkPrimary n XNA => n -> Primary XNA
instance IsString [Letter XNA]
instance MkPrimary (Vector Char) XNA
instance Read (Letter XNA)
instance Show (Letter XNA)
instance Enum (Letter XNA)
instance Bounded (Letter XNA)


-- | Convert between different nucleotide representations
module Biobase.Primary.Nuc.Conversion

-- | Transform RNA to DNA. That means change <tt>U</tt> to <tt>T</tt> and
--   keep the other characters as is.
rnaTdna :: Letter RNA -> Letter DNA

-- | Transform DNA to RNA. That means change <tt>T</tt> to <tt>U</tt> and
--   keep the other characters as is.
dnaTrna :: Letter DNA -> Letter RNA

-- | Generalize an RNA character to a XNA character.
rnaGxna :: Letter RNA -> Letter XNA

-- | Generalize a DNA character to a XNA character.
dnaGxna :: Letter DNA -> Letter XNA

-- | Specialize XNA to RNA, <tt>T</tt> becomes <tt>N</tt>.
xnaSrna :: Letter XNA -> Letter RNA

-- | Specialize XNA to DNA, <tt>U</tt> becomes <tt>N</tt>.
xnaSdna :: Letter XNA -> Letter DNA

-- | Produce the complement of a RNA or DNA sequence. Does intentionally
--   not work for XNA sequences as it is not possible to uniquely translate
--   <tt>A</tt> into either <tt>U</tt> or <tt>T</tt>.
class Complement s t
complement :: Complement s t => s -> t

-- | To <a>transcribe</a> a DNA sequence into RNA we reverse the complement
--   of the sequence.
transcribe :: Primary DNA -> Primary RNA
instance [overlap ok] (Complement s t, Functor f) => Complement (f s) (f t)
instance [overlap ok] (Complement s t, Unbox s, Unbox t) => Complement (Vector s) (Vector t)
instance [overlap ok] Complement (Letter RNA) (Letter DNA)
instance [overlap ok] Complement (Letter DNA) (Letter RNA)
instance [overlap ok] Complement (Letter DNA) (Letter DNA)
instance [overlap ok] Complement (Letter RNA) (Letter RNA)


-- | The primary structure: interface to efficient encoding of RNA and DNA
--   sequences. The design aims toward the <tt>vector</tt> library and
--   repa. In particular, everything is strict; if you want to stream full
--   genomes, use <tt>text</tt> or lazy <tt>bytestring</tt>s instead and
--   cast to Biobase.Primary definitions only at the last moment.
--   
--   Degenerate encoding can be found in the <tt>IUPAC</tt> module.
--   
--   TODO enable OverloadedLists
module Biobase.Primary.Nuc


-- | Encoding of Watson-Crick and Wobble Pairs in the Vienna RNA package
--   style.
module Biobase.Secondary.Vienna

-- | Use machine Ints internally
newtype ViennaPair
ViennaPair :: Int -> ViennaPair
unViennaPair :: ViennaPair -> Int
class MkViennaPair a
mkViennaPair :: MkViennaPair a => a -> ViennaPair
fromViennaPair :: MkViennaPair a => ViennaPair -> a
isViennaPair :: Letter RNA -> Letter RNA -> Bool
viennaPairTable :: Unboxed ((Z :. Letter RNA) :. Letter RNA) ViennaPair

-- | reverse a vienna pair
revPair :: ViennaPair -> ViennaPair
cguaP :: [ViennaPair]
cgnsP :: [ViennaPair]
pairToString :: [(ViennaPair, [Char])]
instance Vector Vector ViennaPair
instance MVector MVector ViennaPair
instance Unbox ViennaPair
instance Eq ViennaPair
instance Ord ViennaPair
instance Generic ViennaPair
instance Ix ViennaPair
instance Datatype D1ViennaPair
instance Constructor C1_0ViennaPair
instance Selector S1_0_0ViennaPair
instance Read ViennaPair
instance Show ViennaPair
instance Bounded ViennaPair
instance Enum ViennaPair
instance MkViennaPair (Letter RNA, Letter RNA)
instance IndexStream ViennaPair
instance IndexStream z => IndexStream (z :. ViennaPair)
instance Index ViennaPair
instance ToJSON ViennaPair
instance FromJSON ViennaPair
instance Serialize ViennaPair
instance Binary ViennaPair


-- | Degenerate base symbol representation. We use the same conventions as
--   in which ignores <tt>U</tt>racil, except if it stands alone for
--   <tt>Char</tt> and <tt>XNA</tt> targets. If the <a>Degenerate</a>
--   target is <tt>RNA</tt>, then we create <tt>U</tt>s instead of
--   <tt>T</tt>s.
--   
--   TODO Shall we handle <a>Complement</a> for degenerates?
module Biobase.Primary.IUPAC

-- | Allow the full, including degenerates, alphabet.
data DEG
charDEG :: Char -> Letter DEG
degChar :: Letter DEG -> Char
degSeq :: MkPrimary n DEG => n -> Primary DEG
class Degenerate x
fromDegenerate :: Degenerate x => Char -> [x]
toDegenerate :: Degenerate x => [x] -> Maybe Char

-- | list of characters, using the XNA alphabet, but degenerate chars
--   assume DNA characters.
iupacXDNAchars :: [(Char, String)]

-- | Raw iupac data, embedded into the library.
iupacNucleotides :: ByteString
instance Degenerate (Letter XNA)
instance Degenerate (Letter DNA)
instance Degenerate (Letter RNA)
instance Degenerate Char
instance IsString [Letter DEG]
instance MkPrimary (Vector Char) DEG
instance Show (Letter DEG)
instance Enum (Letter DEG)
instance Bounded (Letter DEG)


-- | Fast hash functions for <a>Primary</a> sequences. This function maps
--   primary sequences to a continuous set of Ints <tt>[0 ..]</tt> where
--   the maximum is dependent on the input length. This allows us to map
--   short sequences into contiguous memory locations. Useful for, say,
--   energy lookup tables.
module Biobase.Primary.Hashed

-- | The hash of a primary sequence.
newtype HashedPrimary t
HashedPrimary :: Int -> HashedPrimary t
unHashedPrimary :: HashedPrimary t -> Int

-- | Given a piece of primary sequence information, reduce it to an index.
--   The empty input produces an index of 0.
mkHashedPrimary :: (Unbox (Letter t), Bounded (Letter t), Enum (Letter t)) => Primary t -> HashedPrimary t

-- | Turn a hash back into a sequence. Will fail if the resulting sequence
--   has more than 100 elements.
hash2primary :: (Unbox (Letter t), Bounded (Letter t), Enum (Letter t)) => HashedPrimary t -> Primary t
instance Vector Vector (HashedPrimary a0)
instance MVector MVector (HashedPrimary a0)
instance Unbox (HashedPrimary a0)
instance Eq (HashedPrimary t)
instance Ord (HashedPrimary t)
instance Ix (HashedPrimary t)
instance Read (HashedPrimary t)
instance Show (HashedPrimary t)
instance Enum (HashedPrimary t)
instance Bounded (HashedPrimary t)


-- | This module has the translation tables for the genetic code. We do
--   have a symbol <a>Undef</a> for undefined amino acids (say because of
--   <tt>N</tt>s in the nucleotide code).
module Biobase.Primary.AA

-- | Amino acid phantom type.
data AA
aa :: Int -> Letter AA
aaRange :: [Letter AA]

-- | Translate <a>Char</a> amino acid representation into efficient
--   <a>AA</a> newtype.
charAA :: Char -> Letter AA

-- | <a>Char</a> representation of an <a>AA</a>.
aaChar :: Letter AA -> Char
charBaa :: Bimap Char (Letter AA)
instance MkPrimary (Vector Char) AA
instance Enum (Letter AA)
instance Read (Letter AA)
instance Show (Letter AA)


-- | This module provides functionality for translation between nucleotides
--   and amino acids.
--   
--   NOTE <a>aaDNAseq</a> is lossy. Might be a good idea to consider
--   something more involved?
--   
--   TODO we need different functions, depending on if we have a part of a
--   genome in <tt>DNA</tt> form, or some messenger <tt>RNA</tt>. It'll
--   probably also be useful to return <tt>Either</tt>, with <tt>Left</tt>
--   indicating error like partially translated sequence due to
--   intermediate stop codons, or so.
--   
--   TODO <a>dnaAAseq</a> and <a>aaDNAseq</a> can be nicely optimized using
--   <tt>flatten</tt> and friends.
module Biobase.Primary.Trans

-- | Using the codon table, create an amino acid sequence from a
--   <tt>DNA</tt> sequence (encoded as 'Primary DNA'). Suffixed
--   <tt>seq</tt> as we deal with sequences, not letters.
dnaAAseq :: Primary DNA -> Primary AA

-- | Transform an amino acid sequence back into DNA.
--   
--   WARNING: This is lossy!
aaDNAseq :: Primary AA -> Primary DNA

-- | Lossy backtransformation.
aaDNAmap :: Map (Letter AA) (Primary DNA)
dnaAAmap :: Map (Primary DNA) (Letter AA)
codonTable :: Map String Char

-- | Raw codon table
codonListEmbedded :: ByteString


-- | TODO make sequence types <tt>stringable</tt>?
module Biobase.Primary


-- | Secondary structure: define basepairs as Int-tuples, the three edges,
--   a nucleotide can use for pairing and the cis/trans isomerism. Both
--   edges and cis/trans come with a tag for "unknown".
--   
--   TODO set ext-annotations to be (isomerism,edge,edge) and have a
--   asString instance to read "cWW" "tSH" and other notation.
module Biobase.Secondary.Basepair

-- | Each nucleotide in a pair may be paired using one of three edges:
--   watson-crick, sugar, or hoogsteen.
newtype Edge
Edge :: Int -> Edge
unEdge :: Edge -> Int

-- | Human-readable Show instance.

-- | Human-readable Read instance.

-- | Nucleotides in a pairing may be in the cis(==?) or trans(==?) state.
newtype CTisomerism
CT :: Int -> CTisomerism
unCT :: CTisomerism -> Int

-- | Human-readable Show instance.

-- | Human-readable Read instance.

-- | A basepair is simply a pair of Ints which are 0-indexing a sequence.
type PairIdx = (Int, Int)

-- | A pair as a tuple containing <tt>Nuc</tt>s.
type Pair = (Letter RNA, Letter RNA)

-- | Annotation for a basepair.
type ExtPairAnnotation = (CTisomerism, Edge, Edge)

-- | An extended basepair is a basepair, annotated with edge and
--   CTisomerism.
type ExtPairIdx = (PairIdx, ExtPairAnnotation)

-- | An extended basepair, with nucleotides an annotation.
type ExtPair = (Pair, ExtPairAnnotation)

-- | Selection of nucleotides and/or type classes independent of which type
--   we are looking at.
class BaseSelect a b | a -> b
baseL :: BaseSelect a b => a -> b
baseR :: BaseSelect a b => a -> b
baseP :: BaseSelect a b => a -> (b, b)
baseT :: BaseSelect a b => a -> ExtPairAnnotation
updL :: BaseSelect a b => b -> a -> a
updR :: BaseSelect a b => b -> a -> a
updP :: BaseSelect a b => (b, b) -> a -> a
updT :: BaseSelect a b => ExtPairAnnotation -> a -> a

-- | extended pairtype annotation given

-- | simple cis/wc-wc basepairs
instance BaseSelect (a, a) a
instance BaseSelect ((a, a), ExtPairAnnotation) a
instance Vector Vector CTisomerism
instance MVector MVector CTisomerism
instance Unbox CTisomerism
instance Eq CTisomerism
instance Ord CTisomerism
instance Ix CTisomerism
instance Generic CTisomerism
instance Datatype D1CTisomerism
instance Constructor C1_0CTisomerism
instance Selector S1_0_0CTisomerism
instance Enum CTisomerism
instance Bounded CTisomerism
instance Read CTisomerism
instance Show CTisomerism
instance ToJSON CTisomerism
instance FromJSON CTisomerism
instance Serialize CTisomerism
instance Binary CTisomerism
instance Vector Vector Edge
instance MVector MVector Edge
instance Unbox Edge
instance Eq Edge
instance Ord Edge
instance Ix Edge
instance Generic Edge
instance Datatype D1Edge
instance Constructor C1_0Edge
instance Selector S1_0_0Edge
instance Enum Edge
instance Bounded Edge
instance Read Edge
instance Show Edge
instance ToJSON Edge
instance FromJSON Edge
instance Serialize Edge
instance Binary Edge


-- | Types for RNA secondary structure. Types vary from the simplest array
--   (D1Secondary) to rather complex ones.
module Biobase.Secondary.Diagrams

-- | RNA secondary structure with 1-diagrams. Each nucleotide is paired
--   with at most one other nucleotide. A nucleotide with index <tt>k</tt>
--   in <tt>[0..len-1]</tt> is paired if <tt>unD1S VU.! k &gt;=0 0</tt>
--   Unpaired status is <tt>-1</tt>.
newtype D1Secondary
D1S :: Vector Int -> D1Secondary
unD1S :: D1Secondary -> Vector Int
newtype D2Secondary
D2S :: Vector ((Int, Edge, CTisomerism), (Int, Edge, CTisomerism)) -> D2Secondary
unD2S :: D2Secondary -> Vector ((Int, Edge, CTisomerism), (Int, Edge, CTisomerism))

-- | Conversion to and from 1-diagrams.
class MkD1Secondary a
mkD1S :: MkD1Secondary a => a -> D1Secondary
fromD1S :: MkD1Secondary a => D1Secondary -> a

-- | Conversion to and from 2-diagrams.
class MkD2Secondary a
mkD2S :: MkD2Secondary a => a -> D2Secondary
fromD2S :: MkD2Secondary a => D2Secondary -> a

-- | A secondary-structure tree. Has no notion of pseudoknots.
data SSTree idx a
SSTree :: idx -> a -> [SSTree idx a] -> SSTree idx a
SSExtern :: Int -> a -> [SSTree idx a] -> SSTree idx a

-- | Create a tree from (pseudoknot-free [not checked]) 1-diagrams.
d1sTree :: D1Secondary -> SSTree PairIdx ()

-- | Create a tree from (pseudoknot-free [not checked]) 2-diagrams.
d2sTree :: D2Secondary -> SSTree ExtPairIdx ()
d2Compare :: (Ord t3, Ord t2) => ((t2, t3), t) -> ((t2, t3), t1) -> Ordering
d2Grouping :: (Ord a1, Ord a) => ((a, a1), t) -> ((a, a1), t1) -> Bool

-- | Conversion between D1S and D2S is lossy in D2S -&gt; D1S

-- | (Length,List of Pairs)

-- | Conversion between D1S and D2S is lossy in D2S -&gt; D1S
--   
--   TODO <a>fromD2S</a> makes me wanna rewrite everything...

-- | A second primitive generator, requiring dictionary and String. This
--   one generates pairs that are then used by the above instance. The dict
--   is a list of possible brackets: ["()"] being the minimal set.

-- | Generate Secondary given that we have an unboxed vector of characters

-- | A "fast" instance for getting the pair list of vienna-structures.

-- | Completely canonical structure.
--   
--   TODO Check size of hairpins and interior loops?
isCanonicalStructure :: String -> Bool

-- | Is constraint type structure, i.e. there can also be symbols present
--   that denote up- or downstream pairing.
isConstraintStructure :: String -> Bool

-- | Take a structural string and split it into its constituents.
--   
--   If we decide to <i>NOT</i> depend on <tt>lens</tt> explicitly, another
--   way to write this is:
--   
--   <pre>
--   structures :: forall p f . (Profunctor p, Functor f) =&gt; p [String] (f [String]) -&gt; p String (f String)
--   structures = dimap (splitOn "&amp;") (fmap (concat . intersperse "&amp;"))
--   </pre>
structures :: Iso' String [String]

-- | A <tt>fold</tt> structure is a single structure
foldStructure :: Prism' String String

-- | A <tt>cofold</tt> structure has exactly two structures split by
--   <tt>&amp;</tt> (which the prism removes).
cofoldStructure :: Prism' String (String, String)

-- | Secondary structure parser which allows pseudoknots, if they use
--   different kinds of brackets.
unsafeDotBracket2pairlist :: [String] -> String -> [(Int, Int)]

-- | Secondary structure parser with a notion of errors. We either return a
--   <tt>Right</tt> structure, including flags, or a <tt>Left</tt> error.
dotBracket2pairlist :: [String] -> String -> Either String ([(Int, Int)])

-- | Calculates the distance between two vienna strings.
viennaStringDistance :: Bool -> Bool -> String -> String -> (String, Int)
instance Read D1Secondary
instance Show D1Secondary
instance Eq D1Secondary
instance Generic D1Secondary
instance Read D2Secondary
instance Show D2Secondary
instance Eq D2Secondary
instance Generic D2Secondary
instance (Read idx, Read a) => Read (SSTree idx a)
instance (Show idx, Show a) => Show (SSTree idx a)
instance (Eq idx, Eq a) => Eq (SSTree idx a)
instance Generic (SSTree idx a)
instance Datatype D1D1Secondary
instance Constructor C1_0D1Secondary
instance Selector S1_0_0D1Secondary
instance Datatype D1D2Secondary
instance Constructor C1_0D2Secondary
instance Selector S1_0_0D2Secondary
instance Datatype D1SSTree
instance Constructor C1_0SSTree
instance Constructor C1_1SSTree
instance MkD1Secondary (Vector Char)
instance MkD1Secondary String
instance MkD1Secondary ([String], Vector Char)
instance MkD1Secondary ([String], String)
instance MkD2Secondary (Int, [ExtPairIdx])
instance MkD2Secondary D1Secondary
instance MkD1Secondary (Int, [PairIdx])
instance MkD1Secondary D2Secondary
instance ToJSON D2Secondary
instance FromJSON D2Secondary
instance Serialize D2Secondary
instance Binary D2Secondary
instance ToJSON D1Secondary
instance FromJSON D1Secondary
instance Serialize D1Secondary
instance Binary D1Secondary


-- | Simple oldstyle RNAfold constraints. A constraint yields a bonus or
--   malus to energy.
module Biobase.Secondary.Constraint

-- | We can create a constraint from different sources.
class MkConstraint a
mkConstraint :: MkConstraint a => a -> Constraint

-- | A constraint is nothing more than a vector of constraint characters
--   together with a possible pairing for each character.
newtype Constraint
Constraint :: Vector (Char, Int) -> Constraint
unConstraint :: Constraint -> Vector (Char, Int)
bonusCC :: Vector Char
nobonusCC :: Vector Char

-- | Given a <a>Constraint</a>, create an NxN matrix with bonus energies.
--   These energies can be included in all pair-creating functions and will
--   disallow or strongly favor certain pairings, while others will receive
--   neither bonus nor malus.
--   
--   In case, a pair (i,j) is annotated as both, bonus- and
--   malus-receiving, it will be set to receive a malus. This can happen,
--   if something like "&lt;" would give a bonus, but "x" gives a malus
--   (and other cases).
--   
--   TODO and again, we should parametrize over <a>Energy</a>,
--   <a>Score</a>, etc (that is, Prim a)
bonusTable :: Double -> Double -> Constraint -> Unboxed ((Z :. Int) :. Int) Double
instance Show Constraint
instance Read Constraint
instance Eq Constraint
instance MkConstraint (Vector Char)
instance MkConstraint String


-- | A secondary structure, with sequence, Vienna compatible canonical
--   secondary structure, extended structure, and additional information.
--   
--   This is the structure that will be returned by prediction algorithms
--   in the future.
--   
--   TODO we will need ex- and import functions to a number of standard
--   formats. There is an open feature request to export to something that
--   resembles FASTA with additional information.
module Biobase.Secondary.Structure

-- | A sequence, complete with secondary structure. While this structure is
--   rather RNA-centric, there is nothing that prohibits us from using this
--   for DNA.
--   
--   TODO Generics, Cereal, Binary, Aeson instances
data SecondaryStructure
SS :: !Text -> !D1Secondary -> !D2Secondary -> Maybe () -> Map Text Text -> SecondaryStructure

-- | sequence; we use <a>Text</a> whenever possible
_ssSeq :: SecondaryStructure -> !Text

-- | canonical Vienna secondary structure
_ssVienna :: SecondaryStructure -> !D1Secondary

-- | extended secondary structure
_ssExt :: SecondaryStructure -> !D2Secondary

-- | TODO will be the energy, measured or predicted
_ssViennaE :: SecondaryStructure -> Maybe ()

-- | any auxiliary info in key/value format
_ssAux :: SecondaryStructure -> Map Text Text
instance Eq SecondaryStructure
instance Show SecondaryStructure
instance Read SecondaryStructure


-- | Provides detailed information on isostericity of RNA basepairs. All
--   data is extracted from csv files which were created from supplemental
--   files in:
--   
--   <pre>
--   Frequency and isostericity of RNA base pairs
--   Jesse Stombaugh, Craig L. Zirbel, Eric Westhof, and Neocles B. Leontis
--   Nucl. Acids Res. (2009)
--   doi:10.1093<i>nar</i>gkp011
--   </pre>
module Biobase.Secondary.Isostericity

-- | Methods to determine the isostericity classes for a given basepair
--   type, or alternatively which basepair types are in a certain
--   isostericity class.
--   
--   TODO This requires a major cleanup: right now we are handling
--   <a>String</a>s as class descriptors, but we should really be
--   newtype-wrapping or create enum data constructors.
class IsostericityLookup a
getClasses :: IsostericityLookup a => a -> [String]
inClass :: IsostericityLookup a => String -> [a]

-- | For extended basepairs, we take the default mapping and go from there.
--   
--   TODO inClass missing

-- | Normal basepairs are assumed to have cWW basepairing.
--   
--   TODO inClass missing

-- | The default isostericity mapping.
defaultIsostericityMap :: Map ExtPair [String]

-- | Mapping of (pair,pairtype) to isostericity class.
mkIsostericityMap :: [[[String]]] -> Map ExtPair [String]

-- | Process CSV list-of-lists to get the isostericity data.
mkIsostericityList :: [[[String]]] -> [(ExtPair, [String])]

-- | Simple parsing of raw CSV data.
parsedCSV :: [[[[Char]]]]

-- | Raw CSV data, embedded into the library.
detailedCSV :: ByteString
instance IsostericityLookup Pair
instance IsostericityLookup ExtPair


-- | Methods to transform a secondary structure containing pseudoknots into
--   a structure which is pseudoknot-free.
--   
--   TODO Until a better name is found, this module is home to functions
--   for "de-pseudoknotting" structures.
--   
--   TODO Check if there are corner-cases remaining when considering
--   2-diagrams.
module Biobase.Secondary.Pseudoknots

-- | Try to removed pseudoknots from the "pairlist". This works by counting
--   for each pair, how many pairs are incompatible with it. Then those
--   with most incompatibilities are successively removed. This function
--   might well remove more than necessary!
class RemovePseudoKnots a
removeByCounting :: RemovePseudoKnots a => a -> a

-- | Remove pseudoknotted pairs from RNA secondary structures.

-- | Remove pseudoknotted pairs from extended RNA secondary structures.
instance RemovePseudoKnots [ExtPairIdx]
instance RemovePseudoKnots (Vector ExtPairIdx)
instance RemovePseudoKnots [PairIdx]
instance RemovePseudoKnots (Vector PairIdx)

module Biobase.Secondary
