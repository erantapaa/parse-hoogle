-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Primitive heterogenous read-only set
--   
@package hset
@version 1.0.1

module Data.HSet.TypeLevel
data Nat
Z :: Nat
S :: Nat -> Nat

-- | Calculates to 'True if first type argument contained in second list
--   element

-- | Calculates to Nat kinded type describing the index of first argument
--   in second argument

module Data.HSet.Labeled
newtype Labeled (label :: k) (typ :: *)
Labeled :: typ -> Labeled
unLabeled :: Labeled -> typ
mkLabel :: proxy label -> e -> Labeled label e
instance Typeable Labeled
instance Show typ => Show (Labeled label typ)
instance Eq typ => Eq (Labeled label typ)
instance Ord typ => Ord (Labeled label typ)

module Data.HSet

-- | Heterogeneous set (list) of elements with unique types. Useful with
--   MonadReader.
--   
--   <pre>
--   &gt;&gt;&gt; let x = HSCons (10 :: Int) $ HSCons (20 :: Double) HSNil
--   
--   &gt;&gt;&gt; x
--   HSCons (10) (HSCons (20.0) (HSNil))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hget x :: Int
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hget x :: Double
--   20.0
--   </pre>
--   
--   Note that <a>hget</a> takes specific element from list of uniquely
--   typed elements depending on what type is required to be returned.
data HSet (elems :: [*])
HSNil :: HSet []
HSCons :: !elem -> !(HSet elems) -> HSet (elem : elems)

-- | Typeclass for sets and elements.
class i ~ (Index e els) => HGet els e i
hget :: HGet els e i => HSet els -> e

-- | Enables deriving of the fact that <tt>e</tt> is contained within
--   <tt>els</tt> and it's safe to say that <a>hget</a> can be performed on
--   this particular pair.
type HGetable els e = HGet els e (Index e els)
hask :: (MonadReader (HSet els) m, HGetable els e) => m e

-- | <pre>
--   &gt;&gt;&gt; let y = HSCons (Labeled 10 :: Labeled "x" Int) $ HSCons (Labeled 20 :: Labeled "y" Int) HSNil
--   
--   &gt;&gt;&gt; y
--   HSCons (Labeled {unLabeled = 10}) (HSCons (Labeled {unLabeled = 20}) (HSNil))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hgetLabeled (Proxy :: Proxy "x") y :: Int
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hgetLabeled (Proxy :: Proxy "y") y :: Int
--   20
--   </pre>
hgetLabeled :: HGetable els (Labeled label e) => proxy label -> HSet els -> e
haskLabeled :: (HGetable els (Labeled label e), MonadReader (HSet els) m, Applicative m) => proxy label -> m e
instance Typeable HSet
instance (i ~ Index e els, 'S i ~ Index e (e1 : els), HGet els e i) => HGet (e1 : els) e ('S i)
instance HGet (e : els) e 'Z
instance (Ord e, Ord (HSet els)) => Ord (HSet (e : els))
instance Ord (HSet '[])
instance (Eq e, Eq (HSet els)) => Eq (HSet (e : els))
instance Eq (HSet '[])
instance (Show e, Show (HSet els)) => Show (HSet (e : els))
instance Show (HSet '[])
