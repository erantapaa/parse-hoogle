-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tournament related algorithms
--   
--   Tournament is a pure library which generates and updates competition
--   based structures that represent basic FFA or Duel tournaments.
@package Tournament
@version 0.0.1


-- | Tournament construction and maintenance including competition based
--   structures and helpers.
--   
--   This library is intended to be imported qualified as it exports
--   functions that clash with Prelude.
--   
--   <pre>
--   import Game.Tournament as T
--   </pre>
--   
--   The Tournament structure contain a Map of <a>GameId</a> -&gt;
--   <a>Game</a> for its internal representation and the <a>GameId</a> keys
--   are the location in the Tournament.
--   
--   Duel tournaments are based on the theory from
--   <a>http://clux.org/entries/view/2407</a>. By using the seeding
--   definitions listed there, there is almost only one way to generate a
--   tournament, and the ambivalence appears only in Double elimination.
--   
--   We have additionally chosen that brackets should converge by having
--   the losers bracket move upwards. This is not necessary, but improves
--   the visual layout when presented in a standard way.
--   
--   FFA tournaments use a collection of sensible assumptions on how to
--   optimally split n people into s groups while minimizing the sum of
--   seeds difference between groups for fairness. At the end of each
--   round, groups are recalculated from the scores of the winners, and new
--   groups are created for the next round.
module Game.Tournament

-- | Power of a tournament. It's defined as 2^num_players rounded up to
--   nearest power of 2. type Power = Int
--   
--   Computes both the upper and lower player seeds for a duel elimiation
--   match. The first argument is the power of the tournament:
--   
--   p :: 2^num_players rounding up to nearest power of 2
--   
--   The second parameter is the game number i (in round one).
--   
--   The pair (p,i) must obey
--   
--   <pre>
--   p &gt; 0 &amp;&amp; 0 &lt; i &lt;= 2^(p-1).
--   </pre>
seeds :: Int -> Int -> (Int, Int)

-- | Check if the 3 criteria for perfect seeding holds for the current
--   power and seed pair arguments. This can be used to make a measure of
--   how good the seeding was in retrospect
duelExpected :: Integral a => a -> (a, a) -> Bool

-- | Splits a numer of players into groups of as close to equal seeding sum
--   as possible. When groupsize is even and s | n, the seed sum is
--   constant. Fixes the number of groups as ceil $ n / s, but will reduce
--   s when all groups not full.
groups :: Int -> Int -> [[Int]]

-- | Round robin schedules a list of n players and returns a list of rounds
--   (where a round is a list of pairs). Uses
--   http:<i></i>en.wikipedia.org<i>wiki</i>Round-robin_tournament#Scheduling_algorithm
robin :: Integral a => a -> [[(a, a)]]

-- | The location of a game is written as to simulate the classical
--   shorthand WBR2, but includes additionally the game number for complete
--   positional uniqueness.
--   
--   A <a>Single</a> elimination final will have the unique identifier
--   
--   <pre>
--   let wbf = GameId WB p 1
--   </pre>
--   
--   where 'p == count t WB'.
data GameId
GameId :: Bracket -> Int -> Int -> GameId
bracket :: GameId -> Bracket
round :: GameId -> Int
game :: GameId -> Int

-- | Duel Tournament option.
--   
--   <a>Single</a> elimation is a standard power of 2 tournament tree,
--   wheras <a>Double</a> elimination grants each loser a second chance in
--   the lower bracket.
data Elimination
Single :: Elimination
Double :: Elimination

-- | The bracket location of a game.
--   
--   For <a>Duel</a> <a>Single</a> or <a>FFA</a>, most matches exist in the
--   winners bracket (<a>WB</a>) , with the exception of the bronze final
--   and possible crossover matches.
--   
--   <a>Duel</a> <a>Double</a> or <a>FFA</a> with crossovers will have
--   extra matches in the loser bracket (<a>LB</a>).
data Bracket
WB :: Bracket
LB :: Bracket
data Rules
FFA :: GroupSize -> Advancers -> Rules
Duel :: Elimination -> Rules

-- | Results in descending order of placement.
--   
--   Only constructed by <a>score</a> once the last game was played.
type Results = [Result]
results :: Tournament -> Maybe Results

-- | Record of each player's accomplishments in the current tournament.
data Result

-- | Player associated with the record.
player :: Result -> Int

-- | Placement of the player associated with this record.
placement :: Result -> Int

-- | Number of games the player associated with this record won.
wins :: Result -> Int

-- | Sum of scores for the games the associated player played.
total :: Result -> Int
type Size = Int
data Tournament
type Score = Int
type GroupSize = Int
type Advancers = Int

-- | Create match shells for an FFA elimination tournament. Result comes
--   pre-filled in with either top advancers or advancers
--   <tt>intersect</tt> seedList. This means what the player numbers
--   represent is only fixed per round. TODO: Either String Tournament as
--   return for intelligent error handling
tournament :: Rules -> Size -> Tournament

-- | Score a match in a tournament and propagate winners/losers. If match
--   is not <a>scorable</a>, the Tournament will pass through unchanged.
--   
--   For a Duel tournament, winners (and losers if Double) are propagated
--   immediately, wheras FFA tournaments calculate winners at the end of
--   the round (when all games played).
--   
--   There is no limitation on re-scoring old games, so care must be taken
--   to not update too far back ones and leaving the tournament in an
--   inconsistent state. When scoring games more than one round behind the
--   corresponding active round, the locations to which these propagate
--   must be updated manually.
--   
--   To prevent yourself from never scoring older matches, only score games
--   for which <a>safeScorable</a> returns True. Though this has not been
--   implemented yet.
--   
--   <pre>
--   gid = (GameId WB 2 1)
--   tUpdated = if safeScorable gid then score gid [1,0] t else t
--   </pre>
--   
--   TODO: strictify this function TODO: better to do a scoreSafe? <i></i>
--   call this scoreUnsafe
score :: GameId -> [Score] -> Tournament -> Tournament

-- | Count the number of rounds in a given bracket in a Tournament. TODO:
--   rename to length once it has been less awkwardly moved into an
--   internal part
count :: Tournament -> Bracket -> Int

-- | Check if a GameId exists and is ready to be scored through
--   <a>score</a>.
scorable :: GameId -> Tournament -> Bool

-- | Get the list of all GameIds in a Tournament. This list is also ordered
--   by GameId's Ord, and in fact, if the corresponding games were scored
--   in this order, the tournament would finish, and scorable would only
--   return False for a few special walkover games. TODO: if introducing
--   crossovers, this would not be true for LB crossovers =&gt; need to
--   place them in WB in an 'interim round'
keys :: Tournament -> [GameId]
testcase :: IO ()
instance Show Elimination
instance Eq Elimination
instance Ord Elimination
instance Show Bracket
instance Eq Bracket
instance Ord Bracket
instance Show GameId
instance Eq GameId
instance Ord GameId
instance Show Game
instance Eq Game
instance Show Result
