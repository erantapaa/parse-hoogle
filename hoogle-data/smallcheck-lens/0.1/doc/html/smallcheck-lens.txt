-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SmallCheck lens laws
--   
--   <tt><a>smallcheck</a></tt> properties ported from
--   <tt><a>lens-properties</a></tt> and <tt><a>tasty</a></tt> test trees
--   to validate <tt>Lens</tt>es, <tt>Setter</tt>s, <tt>Traversal</tt>s,
--   <tt>Iso</tt>s and <tt>Prism</tt>s.
--   
--   Most likely, you will only need the <a>Test.Tasty.SmallCheck.Lens</a>
--   module, which includes test trees ready to be run.
--   
--   Check the <a>tests</a> in this package for examples.
@package smallcheck-lens
@version 0.1

module Test.SmallCheck.Lens.Traversal
traversePure :: (Monad m, Show s, Applicative f, Eq (f s)) => LensLike' f s a -> Series m s -> Property m
traversePureMaybe :: (Monad m, Show s, Eq s) => LensLike' Maybe s a -> Series m s -> Property m
traverseCompose :: (Monad m, Show s, Show a, Show (f a), Show (g a), Applicative f, Applicative g, Eq (g (f s)), Serial Identity a) => Traversal' s a -> Series m s -> Series m (a -> f a) -> Series m (a -> g a) -> Property m

module Test.SmallCheck.Lens.Setter
setterId :: (Eq s, Monad m, Show s) => ASetter' s a -> Series m s -> Property m
setterSetSet :: (Monad m, Eq s, Show s, Show a) => ASetter' s a -> Series m s -> Series m a -> Series m a -> Property m
setterComposition :: (Monad m, Eq s, Show s, Show a, Serial Identity a) => ASetter' s a -> Series m s -> Series m (a -> a) -> Series m (a -> a) -> Property m

module Test.Tasty.SmallCheck.Lens.Setter

-- | A <a>Setter</a> is only legal if the following laws hold:
--   
--   <ol>
--   <li><pre>set l y (set l x a) ≡ set l y a</pre></li>
--   <li><pre>over l id ≡ id</pre></li>
--   <li><pre>over l f . over l g ≡ over l (f . g)</pre></li>
--   </ol>
testSetter :: (Eq s, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => ASetter' s a -> TestTree

module Test.Tasty.SmallCheck.Lens.Traversal

-- | A <a>Traversal'</a> is only legal if it is a valid <a>Setter'</a> (see
--   <a>testSetter</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>t pure ≡ pure</pre></li>
--   <li><pre>fmap (t f) . t g ≡ getCompose . t (Compose . fmap f .
--   g)</pre></li>
--   </ol>
testTraversal :: (Eq s, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Traversal' s a -> TestTree

module Test.SmallCheck.Lens.Prism
prismYin :: (Monad m, Eq s, Show s, Eq a, Show a) => Prism' s a -> Series m a -> Property m
prismYang :: (Monad m, Eq s, Show s, Eq a, Show a) => Prism' s a -> Series m s -> Property m

module Test.Tasty.SmallCheck.Lens.Prism

-- | A <a>Prism'</a> is only legal if it is a valid <a>Traversal'</a> (see
--   <a>testTraversal</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>preview l (review l b) ≡ Just b"</pre></li>
--   <li><pre>maybe s (review l) (preview l s) ≡ s</pre></li>
--   </ol>
testPrism :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Prism' s a -> TestTree

module Test.SmallCheck.Lens.Lens
lensSetView :: (Monad m, Eq s, Show s) => Lens' s a -> Series m s -> Property m
lensViewSet :: (Monad m, Eq s, Eq a, Show s, Show a) => Lens' s a -> Series m s -> Series m a -> Property m

module Test.Tasty.SmallCheck.Lens.Lens

-- | A <a>Lens'</a> is only legal if it is a valid <a>Traversal'</a> (see
--   <a>testTraversal</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>view l (set l b a) ≡ b</pre></li>
--   <li><pre>set l (view l a) a ≡ a</pre></li>
--   <li><pre>set l c (set l b a) ≡ set l c a</pre></li>
--   </ol>
testLens :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Lens' s a -> TestTree

module Test.SmallCheck.Lens.Iso
isoHither :: (Eq s, Show s, Eq a, Show a, Serial m a) => AnIso' s a -> Series m s -> Property m
isoYon :: (Eq s, Show s, Eq a, Show a, Serial m a) => AnIso' s a -> Series m a -> Property m

module Test.Tasty.SmallCheck.Lens.Iso

-- | An <a>Iso'</a> is only legal if the following laws hold:
--   
--   <ol>
--   <li><pre>s ^. l . from l ≡ s</pre></li>
--   <li><pre>s ^. from l . l ≡ s</pre></li>
--   </ol>
--   
--   An <a>Iso'</a> is also a valid <a>Lens'</a> in both normal and reverse
--   form. Check <a>testLens</a>.
testIso :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s, Serial Identity s, CoSerial IO s) => Iso' s a -> TestTree


-- | Preassembled tasty test trees using <a>Serial</a> instances and
--   one-to-one zipping of elements in <a>Series</a> (see <a>zipLogic</a>)
--   when <a>Serial</a> functions are needed.
--   
--   If you need more exhaustive testing coverage or if you experience
--   combinatorial explosion you can either override the default
--   <a>Serial</a> instances with custom ones or you can create your own
--   tasty test trees using the functions at <a>Test.SmallCheck.Lens</a>.
module Test.Tasty.SmallCheck.Lens

-- | An <a>Iso'</a> is only legal if the following laws hold:
--   
--   <ol>
--   <li><pre>s ^. l . from l ≡ s</pre></li>
--   <li><pre>s ^. from l . l ≡ s</pre></li>
--   </ol>
--   
--   An <a>Iso'</a> is also a valid <a>Lens'</a> in both normal and reverse
--   form. Check <a>testLens</a>.
testIso :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s, Serial Identity s, CoSerial IO s) => Iso' s a -> TestTree

-- | A <a>Lens'</a> is only legal if it is a valid <a>Traversal'</a> (see
--   <a>testTraversal</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>view l (set l b a) ≡ b</pre></li>
--   <li><pre>set l (view l a) a ≡ a</pre></li>
--   <li><pre>set l c (set l b a) ≡ set l c a</pre></li>
--   </ol>
testLens :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Lens' s a -> TestTree

-- | A <a>Prism'</a> is only legal if it is a valid <a>Traversal'</a> (see
--   <a>testTraversal</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>preview l (review l b) ≡ Just b"</pre></li>
--   <li><pre>maybe s (review l) (preview l s) ≡ s</pre></li>
--   </ol>
testPrism :: (Eq s, Eq a, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Prism' s a -> TestTree

-- | A <a>Setter</a> is only legal if the following laws hold:
--   
--   <ol>
--   <li><pre>set l y (set l x a) ≡ set l y a</pre></li>
--   <li><pre>over l id ≡ id</pre></li>
--   <li><pre>over l f . over l g ≡ over l (f . g)</pre></li>
--   </ol>
testSetter :: (Eq s, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => ASetter' s a -> TestTree

-- | A <a>Traversal'</a> is only legal if it is a valid <a>Setter'</a> (see
--   <a>testSetter</a>), and if the following laws hold:
--   
--   <ol>
--   <li><pre>t pure ≡ pure</pre></li>
--   <li><pre>fmap (t f) . t g ≡ getCompose . t (Compose . fmap f .
--   g)</pre></li>
--   </ol>
testTraversal :: (Eq s, Show s, Show a, Serial IO a, Serial Identity a, CoSerial IO a, Serial IO s) => Traversal' s a -> TestTree


-- | <a>Property</a> creators for every individual <i>Lens law</i> using
--   explicit <a>Series</a>.
--   
--   Use this module when you need different <a>Series</a> to the ones
--   implicitly in <a>Test.Tasty.SmallCheck.Lens</a> or when you don't want
--   to use <tt>tasty</tt> as the test runner.
module Test.SmallCheck.Lens
setterId :: (Eq s, Monad m, Show s) => ASetter' s a -> Series m s -> Property m
setterSetSet :: (Monad m, Eq s, Show s, Show a) => ASetter' s a -> Series m s -> Series m a -> Series m a -> Property m
setterComposition :: (Monad m, Eq s, Show s, Show a, Serial Identity a) => ASetter' s a -> Series m s -> Series m (a -> a) -> Series m (a -> a) -> Property m
traversePure :: (Monad m, Show s, Applicative f, Eq (f s)) => LensLike' f s a -> Series m s -> Property m
traversePureMaybe :: (Monad m, Show s, Eq s) => LensLike' Maybe s a -> Series m s -> Property m
traverseCompose :: (Monad m, Show s, Show a, Show (f a), Show (g a), Applicative f, Applicative g, Eq (g (f s)), Serial Identity a) => Traversal' s a -> Series m s -> Series m (a -> f a) -> Series m (a -> g a) -> Property m
lensSetView :: (Monad m, Eq s, Show s) => Lens' s a -> Series m s -> Property m
lensViewSet :: (Monad m, Eq s, Eq a, Show s, Show a) => Lens' s a -> Series m s -> Series m a -> Property m
prismYin :: (Monad m, Eq s, Show s, Eq a, Show a) => Prism' s a -> Series m a -> Property m
prismYang :: (Monad m, Eq s, Show s, Eq a, Show a) => Prism' s a -> Series m s -> Property m
isoHither :: (Eq s, Show s, Eq a, Show a, Serial m a) => AnIso' s a -> Series m s -> Property m
isoYon :: (Eq s, Show s, Eq a, Show a, Serial m a) => AnIso' s a -> Series m a -> Property m
