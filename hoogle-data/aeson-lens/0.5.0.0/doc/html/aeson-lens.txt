-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens of Aeson
--   
--   Lens of Aeson
@package aeson-lens
@version 0.5.0.0

module Data.Aeson.Lens

-- | Lens of Array
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "{\"foo\": {\"baz\": 3.14}, \"bar\": [123, false, null]}") :: Maybe Value
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . nth 1 :: Maybe Bool
--   Just False
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . nth 1 :: Maybe String
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . nth 3 :: Maybe Value
--   Nothing
--   
--   &gt;&gt;&gt; v ^. nth 0 :: Maybe Value
--   Nothing
--   
--   &gt;&gt;&gt; let x = Nothing &amp; nth 0 .~ Just 1
--   
--   &gt;&gt;&gt; L.unpack $ encode x
--   "[1]"
--   
--   &gt;&gt;&gt; let y = x &amp; nth 1 .~ Just "hoge"
--   
--   &gt;&gt;&gt; L.unpack $ encode y
--   "[1,\"hoge\"]"
--   
--   &gt;&gt;&gt; let z = y &amp; nth 0 .~ Just False
--   
--   &gt;&gt;&gt; L.unpack $ encode z
--   "[false,\"hoge\"]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "[]") :: Maybe Value
--   
--   &gt;&gt;&gt; v &amp; nth 0 .~ Just "hello"
--   Just (Array (fromList [String "hello"]))
--   
--   &gt;&gt;&gt; v &amp; nth 1 .~ Just "hello"
--   Just (Array (fromList [Null,String "hello"]))
--   </pre>
nth :: (FromJSON v, ToJSON v) => Int -> IndexedLens' ValueIx (Maybe Value) (Maybe v)
nth' :: (FromJSON u, ToJSON v) => Int -> IndexedLens ValueIx (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)

-- | Lens of Object
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "{\"foo\": {\"baz\": 3.14}, \"bar\": [123, false, null]}") :: Maybe Value
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "baz") :: Maybe Double
--   Just 3.14
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "baz") :: Maybe Object
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "hoge") :: Maybe Value
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "hoge") :: Maybe Value
--   Nothing
--   
--   &gt;&gt;&gt; let w = Nothing &amp; key (T.pack "a") .~ Just 2.23
--   
--   &gt;&gt;&gt; L.unpack $ encode w
--   "{\"a\":2.23}"
--   
--   &gt;&gt;&gt; let x = w &amp; key (T.pack "b") . key (T.pack "c") .~ Just True
--   
--   &gt;&gt;&gt; L.unpack $ encode x
--   "{\"b\":{\"c\":true},\"a\":2.23}"
--   </pre>
key :: (FromJSON v, ToJSON v) => Text -> IndexedLens' ValueIx (Maybe Value) (Maybe v)
key' :: (FromJSON u, ToJSON v) => Text -> IndexedLens ValueIx (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)

-- | Lens of Double
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "{\"foo\": {\"baz\": 3.14}, \"bar\": [123, false, null]}") :: Maybe Value
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "baz") . asDouble
--   Just 3.14
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . asDouble
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "hoge") . asDouble
--   Nothing
--   </pre>
asDouble :: Lens' (Maybe Value) (Maybe Double)

-- | Lens of Text
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "{\"foo\": {\"baz\": \"3.14\"}, \"bar\": [123, false, null]}") :: Maybe Value
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "baz") . asText
--   Just "3.14"
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . asText
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "hoge") . asText
--   Nothing
--   </pre>
asText :: Lens' (Maybe Value) (Maybe Text)

-- | Lens of Bool
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "{\"foo\": {\"baz\": false}, \"bar\": [123, false, null]}") :: Maybe Value
--   
--   &gt;&gt;&gt; v ^. key (T.pack "foo") . key (T.pack "baz") . asBool
--   Just False
--   
--   &gt;&gt;&gt; v ^. key (T.pack "bar") . asBool
--   Nothing
--   
--   &gt;&gt;&gt; v ^. key (T.pack "hoge") . asBool
--   Nothing
--   </pre>
asBool :: Lens' (Maybe Value) (Maybe Bool)

-- | Indexed traversal of Array
--   
--   <pre>
--   &gt;&gt;&gt; let v = decode (L.pack "[1, true, null]") :: Maybe Value
--   
--   &gt;&gt;&gt; v &amp; catMaybes . toListOf traverseArray :: [Value]
--   [Number 1,Bool True,Null]
--   
--   &gt;&gt;&gt; let w = decode (L.pack "[{\"name\": \"tanakh\", \"age\": 29}, {\"name\": \"nushio\", \"age\": 28}]") :: Maybe Value
--   
--   &gt;&gt;&gt; w &amp; catMaybes . toListOf (traverseArray . key (T.pack "name")) :: [T.Text]
--   ["tanakh","nushio"]
--   </pre>
traverseArray :: (FromJSON v, ToJSON v) => IndexedTraversal' Int (Maybe Value) (Maybe v)

-- | Type-changing indexed traversal of an Array
traverseArray' :: (FromJSON u, ToJSON v) => IndexedTraversal Int (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)

-- | Indexed traversal of Object
--   
--   <pre>
--   &gt;&gt;&gt; let w = decode (L.pack "[{\"name\": \"tanakh\", \"age\": 29}, {\"name\": \"nushio\", \"age\": 28}]") :: Maybe Value
--   
--   &gt;&gt;&gt; w &amp; catMaybes . toListOf (traverseArray . traverseObject) :: [Value]
--   [String "tanakh",Number 29,String "nushio",Number 28]
--   </pre>
traverseObject :: (FromJSON v, ToJSON v) => IndexedTraversal' Text (Maybe Value) (Maybe v)

-- | Type-changing indexed traversal of Object
traverseObject' :: (FromJSON u, ToJSON v) => IndexedTraversal Text (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)
data ValueIx
ArrIx :: Int -> ValueIx
ObjIx :: Text -> ValueIx

-- | Lens of Value
valueAt :: (FromJSON u, ToJSON v) => ValueIx -> IndexedLens ValueIx (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)
