-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A reflective JSON serializer/parser.
--   
--   See included README for some examples. This package uses the Scrap
--   Your Boilerplate With Class approach to generics to implement a
--   reflective JSON serializer and deserializer. Nested record types are
--   automatically converted to corresponding JSON objects and vice versa.
--   In both cases, various aspects of serializing and deserializing can be
--   customized by implementing instances of type classes. Note that only
--   Haskell 98 types can be serialized and deserialized, and that the use
--   of strict constructors will lead to runtime errors with the current
--   implemetation. Apart from the reflective stuff, the package also
--   provides a straightforward Haskell representation of JSON data,
--   together with a unicode-safe parser and a suitable implementation of
--   <a>show</a>. The code hasn't yet been tested for performance; it might
--   be quite slow.
@package RJson
@version 0.3.7

module Text.RJson
class TranslateField a
translateField :: TranslateField a => a -> String -> String
data TranslateFieldD a

-- | New instances can be added to this class to customize certain aspects
--   of the way in which Haskell types are serialized to JSON.
class TranslateField a => ToJson a
toJson :: ToJson a => a -> JsonData
exclude :: ToJson a => a -> String -> Bool
arrayPrepend :: ToJson a => a -> [JsonData]
arrayAppend :: ToJson a => a -> [JsonData]
objectExtras :: ToJson a => a -> [(String, JsonData)]
data ToJsonD a

-- | This function is used as the the implementation of <a>toJson</a> for
--   the generic instance declaration. It's useful to be able to use the
--   same implentation for other instance declarations which override the
--   default implementations of other methods of the ToJson class.
genericToJson :: (Data ToJsonD a, ToJson a, TranslateField a) => a -> JsonData

-- | This function can be used as an implementation of <a>toJson</a> for
--   simple enums. It converts an enum value to a string determined by the
--   name of the constructor, after being fed through the (String -&gt;
--   String) function given as the first argument.
enumToJson :: (Data ToJsonD a, ToJson a, TranslateField a) => (String -> String) -> a -> JsonData

-- | A Haskell representation of a JSON data structure.
data JsonData
JDString :: String -> JsonData
JDNumber :: Double -> JsonData
JDArray :: [JsonData] -> JsonData
JDBool :: Bool -> JsonData
JDNull :: JsonData
JDObject :: (Map String JsonData) -> JsonData
class TranslateField a => FromJson a
fromJson :: FromJson a => a -> JsonData -> Either String a
objectDefaults :: FromJson a => a -> Map String JsonData
data FromJsonD a

-- | Converts a String (interpreted as a true unicode String) to an
--   instance of JsonData.
parseJsonString :: String -> Either String JsonData

-- | Converts a ByteString to an instance of JsonData (unicode encoding is
--   detected automatically).
parseJsonByteString :: ByteString -> Either String JsonData

-- | Converts a JSON String (interpreted as a true unicode string) to a
--   value of the type given by the first (dummy) argument.
fromJsonString :: FromJson a => a -> String -> Either String a

-- | Converts a JSON ByteString (with unicode encoding automatically
--   detected) to a value of the type given by the first (dummy) argument.
fromJsonByteString :: FromJson a => a -> ByteString -> Either String a
genericFromJson :: (Data FromJsonD a, FromJson a, TranslateField a) => a -> JsonData -> Either String a

-- | The counterpart of <a>enumToJson</a>.
enumFromJson :: (Data FromJsonD a, Data TranslateFieldD a) => (String -> String) -> a -> JsonData -> Either String a
stripInitialUnderscores :: [Char] -> [Char]

-- | Converts a value to an ASCII-only JSON String.
toJsonString :: ToJson a => a -> String

-- | Converts the first character of a string to upper case.
firstCharToUpper :: String -> String

-- | Converts the first character of a string to lower case.
firstCharToLower :: String -> String

-- | This type can be used for merging two or more records together into a
--   single JSON object. By default, a structure such as (Union X Y) is
--   serialized as follows. First, X and Y are serialized, and a runtime
--   error is signalled if the result of serialization is not a JSON object
--   in both cases. The key/value pairs of the two JSON objects are then
--   merged to form a single object.
data Union a b
Union :: a -> b -> Union a b

-- | Nested Unions are left-branching by convention (since this is what you
--   get by using the constructor as an infix operator).
type Union3 a b c = Union (Union a b) c
type Union4 a b c d = Union (Union3 a b c) d
type Union5 a b c d e = Union (Union4 a b c d) e
type Union6 a b c d e f = Union (Union5 a b c d e) f
type Union7 a b c d e f g = Union (Union6 a b c d e f) g
type Union8 a b c d e f g h = Union (Union7 a b c d e f g) h
type Union9 a b c d e f g h i = Union (Union8 a b c d e f g h) i
type Union10 a b c d e f g h i j = Union (Union9 a b c d e f g h i) j
cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
instance [overlap ok] (Data FromJsonD t, TranslateField t) => FromJson t
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b, FromJson c, Typeable c, TranslateField c, FromJson d, Typeable d, TranslateField d, FromJson e, Typeable e, TranslateField e, FromJson f, Typeable f, TranslateField f, FromJson g, Typeable g, TranslateField g) => FromJson (a, b, c, d, e, f, g)
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b, FromJson c, Typeable c, TranslateField c, FromJson d, Typeable d, TranslateField d, FromJson e, Typeable e, TranslateField e, FromJson f, Typeable f, TranslateField f) => FromJson (a, b, c, d, e, f)
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b, FromJson c, Typeable c, TranslateField c, FromJson d, Typeable d, TranslateField d, FromJson e, Typeable e, TranslateField e) => FromJson (a, b, c, d, e)
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b, FromJson c, Typeable c, TranslateField c, FromJson d, Typeable d, TranslateField d) => FromJson (a, b, c, d)
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b, FromJson c, Typeable c, TranslateField c) => FromJson (a, b, c)
instance [overlap ok] (FromJson a, Typeable a, TranslateField a, FromJson b, Typeable b, TranslateField b) => FromJson (a, b)
instance [overlap ok] (FromJson a, FromJson b, Typeable a, Typeable b, TranslateField a, TranslateField b) => FromJson (Union a b)
instance [overlap ok] FromJson Bool
instance [overlap ok] (Typeable a, Integral a) => FromJson (Ratio a)
instance [overlap ok] FromJson Double
instance [overlap ok] FromJson Integer
instance [overlap ok] FromJson Int
instance [overlap ok] (FromJson a, TranslateField a, Typeable a) => FromJson [a]
instance [overlap ok] (FromJson a, TranslateField a, Typeable a) => FromJson (Maybe a)
instance [overlap ok] FromJson Char
instance [overlap ok] FromJson t => Sat (FromJsonD t)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b, ToJson c, Typeable c, ToJson d, Typeable d, ToJson e, Typeable e, ToJson f, Typeable f, ToJson g, Typeable g) => ToJson (a, b, c, d, e, f, g)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b, ToJson c, Typeable c, ToJson d, Typeable d, ToJson e, Typeable e, ToJson f, Typeable f) => ToJson (a, b, c, d, e, f)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b, ToJson c, Typeable c, ToJson d, Typeable d, ToJson e, Typeable e) => ToJson (a, b, c, d, e)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b, ToJson c, Typeable c, ToJson d, Typeable d) => ToJson (a, b, c, d)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b, ToJson c, Typeable c) => ToJson (a, b, c)
instance [overlap ok] (ToJson a, Typeable a, ToJson b, Typeable b) => ToJson (a, b)
instance [overlap ok] (Data ToJsonD t, TranslateField t) => ToJson t
instance [overlap ok] (ToJson a, ToJson b, TranslateField a, TranslateField b, Typeable a, Typeable b, Typeable2 Union) => ToJson (Union a b)
instance [overlap ok] (Data ctx a[a27X], Data ctx b[a27Y], Sat (ctx (Union a[a27X] b[a27Y]))) => Data ctx (Union a[a27X] b[a27Y])
instance [overlap ok] Typeable2 Union
instance [overlap ok] (Show a, Show b) => Show (Union a b)
instance [overlap ok] (ToJson a, TranslateField a, Typeable a, Typeable i, Ix i) => ToJson (Array i a)
instance [overlap ok] (ToJson a, TranslateField a, Typeable a) => ToJson [a]
instance [overlap ok] (ToJson a, TranslateField a, Data TranslateFieldD (Map String a)) => ToJson (Map String a)
instance [overlap ok] (Typeable a, ToJson a) => ToJson (Maybe a)
instance [overlap ok] ToJson Char
instance [overlap ok] (Integral a, TranslateField a, Typeable a) => ToJson (Ratio a)
instance [overlap ok] ToJson Double
instance [overlap ok] ToJson Integer
instance [overlap ok] ToJson Int
instance [overlap ok] ToJson Bool
instance [overlap ok] ToJson t => Sat (ToJsonD t)
instance [overlap ok] Typeable a => TranslateField a
instance [overlap ok] TranslateField t => Sat (TranslateFieldD t)
instance [overlap ok] Show JsonData
