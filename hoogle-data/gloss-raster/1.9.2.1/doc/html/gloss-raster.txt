-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parallel rendering of raster images.
--   
@package gloss-raster
@version 1.9.2.1


-- | Rendering of Repa arrays as raster images.
--   
--   Gloss programs should be compiled with <tt>-threaded</tt>, otherwise
--   the GHC runtime will limit the frame-rate to around 20Hz.
--   
--   The performance of programs using this interface is sensitive to how
--   much boxing and unboxing the GHC simplifier manages to eliminate. For
--   the best result add INLINE pragmas to all of your numeric functions
--   and use the following compile options.
--   
--   <pre>
--   -threaded -Odph -fno-liberate-case -funfolding-use-threshold1000 -funfolding-keeness-factor1000 -fllvm -optlo-O3
--   </pre>
--   
--   See the examples the <tt>raster</tt> directory of the
--   <tt>gloss-examples</tt> package for more details.
module Graphics.Gloss.Raster.Array

-- | Construct a color from red, green, blue components.
--   
--   Each component is clamped to the range [0..1]
rgb :: Float -> Float -> Float -> Color

-- | Construct a color from red, green, blue components.
--   
--   Each component is clamped to the range [0..255]
rgbI :: Int -> Int -> Int -> Color

-- | Construct a color from red, green, blue components.
rgb8w :: Word8 -> Word8 -> Word8 -> Color

-- | Like <a>rgb</a>, but take pre-clamped components for speed.
--   
--   If you're building a new color for every pixel then use this version,
--   however if your components are out of range then the picture you get
--   will be implementation dependent.
rgb' :: Float -> Float -> Float -> Color

-- | Like <a>rgbI</a>, but take pre-clamped components for speed.
--   
--   If you're building a new color for every pixel then use this version,
--   however if your components are out of range then the picture you get
--   will be implementation dependent.
rgbI' :: Int -> Int -> Int -> Color

-- | Describes how Gloss should display its output.
data Display :: *

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen with a drawing area of the given size.
FullScreen :: (Int, Int) -> Display

-- | Animate a bitmap generated from a Repa array.
animateArray :: Display -> (Int, Int) -> (Float -> Array D DIM2 Color) -> IO ()

-- | Play with a bitmap generated from a Repa array.
playArray :: Display -> (Int, Int) -> Int -> world -> (world -> Array D DIM2 Color) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()

-- | Animate a bitmap generated from a Repa array, via the IO monad.
animateArrayIO :: Display -> (Int, Int) -> (Float -> IO (Array D DIM2 Color)) -> IO ()

-- | Play with a bitmap generated from a Repa array, via the IO monad.
playArrayIO :: Display -> (Int, Int) -> Int -> world -> (world -> IO (Array D DIM2 Color)) -> (Event -> world -> IO world) -> (Float -> world -> IO world) -> IO ()


-- | Rendering of continuous 2D functions as raster fields.
--   
--   Gloss programs should be compiled with <tt>-threaded</tt>, otherwise
--   the GHC runtime will limit the frame-rate to around 20Hz.
--   
--   The performance of programs using this interface is sensitive to how
--   much boxing and unboxing the GHC simplifier manages to eliminate. For
--   the best result add INLINE pragmas to all of your numeric functions
--   and use the following compile options.
--   
--   <pre>
--   -threaded -Odph -fno-liberate-case -funfolding-use-threshold1000 -funfolding-keeness-factor1000 -fllvm -optlo-O3
--   </pre>
--   
--   See the examples the <tt>raster</tt> directory of the
--   <tt>gloss-examples</tt> package for more details.
module Graphics.Gloss.Raster.Field

-- | Construct a color from red, green, blue components.
--   
--   Each component is clamped to the range [0..1]
rgb :: Float -> Float -> Float -> Color

-- | Construct a color from red, green, blue components.
--   
--   Each component is clamped to the range [0..255]
rgbI :: Int -> Int -> Int -> Color

-- | Construct a color from red, green, blue components.
rgb8w :: Word8 -> Word8 -> Word8 -> Color

-- | Like <a>rgb</a>, but take pre-clamped components for speed.
--   
--   If you're building a new color for every pixel then use this version,
--   however if your components are out of range then the picture you get
--   will be implementation dependent.
rgb' :: Float -> Float -> Float -> Color

-- | Like <a>rgbI</a>, but take pre-clamped components for speed.
--   
--   If you're building a new color for every pixel then use this version,
--   however if your components are out of range then the picture you get
--   will be implementation dependent.
rgbI' :: Int -> Int -> Int -> Color

-- | Describes how Gloss should display its output.
data Display :: *

-- | Display in a window with the given name, size and position.
InWindow :: String -> (Int, Int) -> (Int, Int) -> Display

-- | Display full screen with a drawing area of the given size.
FullScreen :: (Int, Int) -> Display

-- | A point on the x-y plane.
type Point = (Float, Float)

-- | Animate a continuous 2D function.
animateField :: Display -> (Int, Int) -> (Float -> Point -> Color) -> IO ()

-- | Play a game with a continous 2D function.
playField :: Display -> (Int, Int) -> Int -> world -> (world -> Point -> Color) -> (Event -> world -> world) -> (Float -> world -> world) -> IO ()
makePicture :: Int -> Int -> Int -> Int -> (Point -> Color) -> Picture
makeFrame :: Int -> Int -> (Point -> Color) -> Array (I D) DIM2 (Word8, Word8, Word8)
