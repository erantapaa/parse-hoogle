-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Cloud Haskell Application Platform
--   
--   Modelled after Erlang OTP's gen_server, this framework provides
--   similar facilities for Cloud Haskell, grouping essential practices for
--   client/server development into a set of modules and standards designed
--   to help you build concurrent, distributed applications with relative
--   ease.
@package distributed-process-client-server
@version 0.1.2


-- | Unsafe variant of the <i>Managed Process Client API</i>. This module
--   implements the client portion of a Managed Process using the unsafe
--   variants of cloud haskell's messaging primitives. It relies on the
--   -extras implementation of <tt>UnsafePrimitives</tt>, which forces
--   evaluation for types that provide an <tt>NFData</tt> instance. Direct
--   use of the underlying unsafe primitives (from the distributed-process
--   library) without <tt>NFData</tt> instances is unsupported.
--   
--   IMPORTANT NOTE: As per the platform documentation, it is not possible
--   to <i>guarantee</i> that an <tt>NFData</tt> instance will force
--   evaluation in the same way that a <tt>Binary</tt> instance would (when
--   encoding to a byte string). Please read the unsafe primitives
--   documentation carefully and make sure you know what you're doing. You
--   have been warned.
--   
--   See <a>Control.Distributed.Process.Extras</a>. See
--   <a>Control.Distributed.Process.Extras.UnsafePrimitives</a>. See
--   <a>Control.Distributed.Process.UnsafePrimitives</a>.
module Control.Distributed.Process.ManagedProcess.UnsafeClient

-- | Send a control message over a <a>ControlPort</a>. This version of
--   <tt>shutdown</tt> uses <i>unsafe primitives</i>.
sendControlMessage :: Serializable m => ControlPort m -> m -> Process ()

-- | Send a signal instructing the process to terminate. This version of
--   <tt>shutdown</tt> uses <i>unsafe primitives</i>.
shutdown :: ProcessId -> Process ()

-- | Make a synchronous call - uses <i>unsafe primitives</i>.
call :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process b

-- | Safe version of <a>call</a> that returns information about the error
--   if the operation fails - uses <i>unsafe primitives</i>.
safeCall :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process (Either ExitReason b)

-- | Version of <a>safeCall</a> that returns <a>Nothing</a> if the
--   operation fails. Uses <i>unsafe primitives</i>.
tryCall :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process (Maybe b)

-- | Make a synchronous call, but timeout and return <tt>Nothing</tt> if a
--   reply is not received within the specified time interval - uses
--   <i>unsafe primitives</i>.
callTimeout :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> TimeInterval -> Process (Maybe b)
flushPendingCalls :: NFSerializable b => TimeInterval -> (b -> Process b) -> Process (Maybe b)

-- | Invokes <a>call</a> <i>out of band</i>, and returns an "async handle."
--   Uses <i>unsafe primitives</i>.
callAsync :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process (Async b)

-- | Sends a <i>cast</i> message to the server identified by
--   <tt>server</tt> - uses <i>unsafe primitives</i>.
cast :: (Addressable a, NFSerializable m) => a -> m -> Process ()

-- | Sends a <i>channel</i> message to the server and returns a
--   <tt>ReceivePort</tt> - uses <i>unsafe primitives</i>.
callChan :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process (ReceivePort b)
syncCallChan :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process b
syncSafeCallChan :: (Addressable s, NFSerializable a, NFSerializable b) => s -> a -> Process (Either ExitReason b)

module Control.Distributed.Process.ManagedProcess.Server.Priority
prioritiseCall :: (Serializable a, Serializable b) => (s -> a -> Priority b) -> DispatchPriority s
prioritiseCall_ :: (Serializable a, Serializable b) => (a -> Priority b) -> DispatchPriority s
prioritiseCast :: Serializable a => (s -> a -> Priority ()) -> DispatchPriority s
prioritiseCast_ :: Serializable a => (a -> Priority ()) -> DispatchPriority s
prioritiseInfo :: Serializable a => (s -> a -> Priority ()) -> DispatchPriority s
prioritiseInfo_ :: Serializable a => (a -> Priority ()) -> DispatchPriority s
setPriority :: Int -> Priority m


-- | The Server Portion of the <i>Managed Process</i> API.
module Control.Distributed.Process.ManagedProcess.Server

-- | Creates a <a>Condition</a> from a function that takes a process state
--   <tt>a</tt> and an input message <tt>b</tt> and returns a <a>Bool</a>
--   indicating whether the associated handler should run.
condition :: (Serializable a, Serializable b) => (a -> b -> Bool) -> Condition a b

-- | Create a <a>Condition</a> from a function that takes a process state
--   <tt>a</tt> and returns a <a>Bool</a> indicating whether the associated
--   handler should run.
state :: Serializable m => (s -> Bool) -> Condition s m

-- | Creates a <a>Condition</a> from a function that takes an input message
--   <tt>m</tt> and returns a <a>Bool</a> indicating whether the associated
--   handler should run.
input :: Serializable m => (m -> Bool) -> Condition s m

-- | Instructs the process to send a reply and continue running.
reply :: Serializable r => r -> s -> Process (ProcessReply r s)

-- | Instructs the process to send a reply <i>and</i> evaluate the
--   <a>ProcessAction</a>.
replyWith :: Serializable r => r -> ProcessAction s -> Process (ProcessReply r s)

-- | Instructs the process to skip sending a reply <i>and</i> evaluate a
--   <a>ProcessAction</a>
noReply :: Serializable r => ProcessAction s -> Process (ProcessReply r s)

-- | Instructs the process to continue running and receiving messages.
continue :: s -> Process (ProcessAction s)

-- | Instructs the process loop to wait for incoming messages until
--   <a>Delay</a> is exceeded. If no messages are handled during this
--   period, the <i>timeout</i> handler will be called. Note that this
--   alters the process timeout permanently such that the given
--   <tt>Delay</tt> will remain in use until changed.
timeoutAfter :: Delay -> s -> Process (ProcessAction s)

-- | Instructs the process to <i>hibernate</i> for the given
--   <a>TimeInterval</a>. Note that no messages will be removed from the
--   mailbox until after hibernation has ceased. This is equivalent to
--   calling <tt>threadDelay</tt>.
hibernate :: TimeInterval -> s -> Process (ProcessAction s)

-- | Instructs the process to terminate, giving the supplied reason. If a
--   valid <a>shutdownHandler</a> is installed, it will be called with the
--   <a>ExitReason</a> returned from this call, along with the process
--   state.
stop :: ExitReason -> Process (ProcessAction s)

-- | As <a>stop</a>, but provides an updated state for the shutdown
--   handler.
stopWith :: s -> ExitReason -> Process (ProcessAction s)

-- | Sends a reply explicitly to a caller.
--   
--   <pre>
--   replyTo = sendTo
--   </pre>
replyTo :: Serializable m => CallRef m -> m -> Process ()

-- | Sends a reply to a <a>SendPort</a> (for use in <a>handleRpcChan</a> et
--   al).
--   
--   <pre>
--   replyChan = sendChan
--   </pre>
replyChan :: Serializable m => SendPort m -> m -> Process ()

-- | Continue without giving a reply to the caller - equivalent to
--   <a>continue</a>, but usable in a callback passed to the
--   <a>handleCall</a> family of functions.
noReply_ :: Serializable r => s -> Process (ProcessReply r s)

-- | Halt process execution during a call handler, without paying any
--   attention to the expected return type.
haltNoReply_ :: Serializable r => ExitReason -> Process (ProcessReply r s)

-- | Version of <a>continue</a> that can be used in handlers that ignore
--   process state.
continue_ :: s -> Process (ProcessAction s)

-- | Version of <a>timeoutAfter</a> that can be used in handlers that
--   ignore process state.
--   
--   <pre>
--   action (\(TimeoutPlease duration) -&gt; timeoutAfter_ duration)
--   </pre>
timeoutAfter_ :: Delay -> (s -> Process (ProcessAction s))

-- | Version of <a>hibernate</a> that can be used in handlers that ignore
--   process state.
--   
--   <pre>
--   action (\(HibernatePlease delay) -&gt; hibernate_ delay)
--   </pre>
hibernate_ :: TimeInterval -> (s -> Process (ProcessAction s))

-- | Version of <a>stop</a> that can be used in handlers that ignore
--   process state.
--   
--   <pre>
--   action (\ClientError -&gt; stop_ ExitNormal)
--   </pre>
stop_ :: ExitReason -> (s -> Process (ProcessAction s))

-- | Constructs a <tt>call</tt> handler from a function in the
--   <a>Process</a> monad. &gt; handleCall = handleCallIf (const True)
handleCall :: (Serializable a, Serializable b) => (s -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Constructs a <tt>call</tt> handler from an ordinary function in the
--   <a>Process</a> monad. Given a function <tt>f :: (s -&gt; a -&gt;
--   Process (ProcessReply b s))</tt>, the expression <tt>handleCall f</tt>
--   will yield a <a>Dispatcher</a> for inclusion in a <tt>Behaviour</tt>
--   specification for the <i>GenProcess</i>. Messages are only dispatched
--   to the handler if the supplied condition evaluates to <tt>True</tt>.
handleCallIf :: (Serializable a, Serializable b) => Condition s a -> (s -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | As <a>handleCall</a> but passes the <a>CallRef</a> to the handler
--   function. This can be useful if you wish to <i>reply later</i> to the
--   caller by, e.g., spawning a process to do some work and have it
--   <tt>replyTo caller response</tt> out of band. In this case the
--   callback can pass the <a>CallRef</a> to the worker (or stash it away
--   itself) and return <a>noReply</a>.
handleCallFrom :: (Serializable a, Serializable b) => (s -> CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | As <a>handleCallFrom</a> but only runs the handler if the supplied
--   <a>Condition</a> evaluates to <tt>True</tt>.
handleCallFromIf :: (Serializable a, Serializable b) => Condition s a -> (s -> CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Creates a handler for a <i>typed channel</i> RPC style interaction.
--   The handler takes a <tt>SendPort b</tt> to reply to, the initial input
--   and evaluates to a <a>ProcessAction</a>. It is the handler code's
--   responsibility to send the reply to the <tt>SendPort</tt>.
handleRpcChan :: (Serializable a, Serializable b) => (s -> SendPort b -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | As <a>handleRpcChan</a>, but only evaluates the handler if the
--   supplied condition is met.
handleRpcChanIf :: (Serializable a, Serializable b) => Condition s a -> (s -> SendPort b -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Constructs a <tt>cast</tt> handler from an ordinary function in the
--   <a>Process</a> monad. &gt; handleCast = handleCastIf (const True)
handleCast :: Serializable a => (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Constructs a <tt>cast</tt> handler from an ordinary function in the
--   <a>Process</a> monad. Given a function <tt>f :: (s -&gt; a -&gt;
--   Process (ProcessAction s))</tt>, the expression <tt>handleCall f</tt>
--   will yield a <a>Dispatcher</a> for inclusion in a <tt>Behaviour</tt>
--   specification for the <i>GenProcess</i>.
handleCastIf :: Serializable a => Condition s a -> (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Creates a generic input handler (i.e., for received messages that are
--   <i>not</i> sent using the <tt>cast</tt> or <tt>call</tt> APIs) from an
--   ordinary function in the <a>Process</a> monad.
handleInfo :: Serializable a => (s -> a -> Process (ProcessAction s)) -> DeferredDispatcher s

-- | Handle completely <i>raw</i> input messages.
handleRaw :: (s -> Message -> Process (ProcessAction s)) -> DeferredDispatcher s

-- | Constructs a handler for both <i>call</i> and <i>cast</i> messages.
--   <tt>handleDispatch = handleDispatchIf (const True)</tt>
handleDispatch :: Serializable a => (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Constructs a handler for both <i>call</i> and <i>cast</i> messages.
--   Messages are only dispatched to the handler if the supplied condition
--   evaluates to <tt>True</tt>. Handlers defined in this way have no
--   access to the call context (if one exists) and cannot therefore reply
--   to calls.
handleDispatchIf :: Serializable a => Condition s a -> (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Creates an <i>exit handler</i> scoped to the execution of any and all
--   the registered call, cast and info handlers for the process.
handleExit :: Serializable a => (s -> ProcessId -> a -> Process (ProcessAction s)) -> ExitSignalDispatcher s
handleExitIf :: Serializable a => (s -> a -> Bool) -> (s -> ProcessId -> a -> Process (ProcessAction s)) -> ExitSignalDispatcher s

-- | Constructs an <i>action</i> handler. Like <a>handleDispatch</a> this
--   can handle both <tt>cast</tt> and <tt>call</tt> messages, but you
--   won't know which you're dealing with. This can be useful where certain
--   inputs require a definite action, such as stopping the server, without
--   concern for the state (e.g., when stopping we need only decide to
--   stop, as the terminate handler can deal with state cleanup etc). For
--   example:
--   
--   <pre>
--   action (MyCriticalSignal -&gt; stop_ ExitNormal)
--   </pre>
action :: Serializable a => (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Constructs a <tt>call</tt> handler from a function in the
--   <a>Process</a> monad. The handler expression returns the reply, and
--   the action will be set to <a>continue</a>.
--   
--   <pre>
--   handleCall_ = handleCallIf_ $ input (const True)
--   </pre>
handleCall_ :: (Serializable a, Serializable b) => (a -> Process b) -> Dispatcher s

-- | Constructs a <tt>call</tt> handler from an ordinary function in the
--   <a>Process</a> monad. This variant ignores the state argument present
--   in <a>handleCall</a> and <a>handleCallIf</a> and is therefore useful
--   in a stateless server. Messges are only dispatched to the handler if
--   the supplied condition evaluates to <tt>True</tt>
--   
--   See <a>handleCall</a>
handleCallIf_ :: (Serializable a, Serializable b) => Condition s a -> (a -> Process b) -> Dispatcher s

-- | A variant of <a>handleCallFrom_</a> that ignores the state argument.
handleCallFrom_ :: (Serializable a, Serializable b) => (CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | A variant of <a>handleCallFromIf</a> that ignores the state argument.
handleCallFromIf_ :: (Serializable a, Serializable b) => (Condition s a) -> (CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | A variant of <a>handleRpcChan</a> that ignores the state argument.
handleRpcChan_ :: (Serializable a, Serializable b) => (SendPort b -> a -> Process (ProcessAction ())) -> Dispatcher ()

-- | A variant of <a>handleRpcChanIf</a> that ignores the state argument.
handleRpcChanIf_ :: (Serializable a, Serializable b) => Condition () a -> (SendPort b -> a -> Process (ProcessAction ())) -> Dispatcher ()

-- | Version of <a>handleCast</a> that ignores the server state.
handleCast_ :: Serializable a => (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Version of <a>handleCastIf</a> that ignores the server state.
handleCastIf_ :: Serializable a => Condition s a -> (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Constructs a <i>control channel</i> handler from a function in the
--   <a>Process</a> monad. The handler expression returns no reply, and the
--   <i>control message</i> is treated in the same fashion as a
--   <tt>cast</tt>.
--   
--   <pre>
--   handleControlChan = handleControlChanIf $ input (const True)
--   </pre>
handleControlChan :: Serializable a => ControlChannel a -> (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Version of <a>handleControlChan</a> that ignores the server state.
handleControlChan_ :: Serializable a => ControlChannel a -> (a -> (s -> Process (ProcessAction s))) -> Dispatcher s


-- | A <i>safe</i> variant of the Server Portion of the <i>Managed
--   Process</i> API. Most of these operations have the same names as
--   similar operations in the impure <tt>Server</tt> module (re-exported
--   by the primary API in <tt>ManagedProcess</tt>). To remove the
--   ambiguity, some combination of either qualification and/or the
--   <tt>hiding</tt> clause will be required.
--   
--   <ul>
--   <li><i>Restricted Server Callbacks</i></li>
--   </ul>
--   
--   The idea behind this module is to provide <i>safe</i> callbacks, i.e.,
--   server code that is free from side effects. This safety is enforced by
--   the type system via the <tt>RestrictedProcess</tt> monad. A StateT
--   interface is provided for code running in the
--   <tt>RestrictedProcess</tt> monad, so that server side state can be
--   managed safely without resorting to IO (or code running in the
--   <tt>Process</tt> monad).
module Control.Distributed.Process.ManagedProcess.Server.Restricted

-- | Restricted (i.e., pure, free from side effects) execution environment
--   for call<i>cast</i>info handlers to execute in.
data RestrictedProcess s a

-- | The result of a <tt>call</tt> handler's execution.
data Result a

-- | reply with the given term
Reply :: a -> Result a

-- | reply with the given term and enter timeout
Timeout :: Delay -> a -> Result a

-- | reply with the given term and hibernate
Hibernate :: TimeInterval -> a -> Result a

-- | stop the process with the given reason
Stop :: ExitReason -> Result a

-- | The result of a safe <a>cast</a> handler's execution.
data RestrictedAction

-- | continue executing
RestrictedContinue :: RestrictedAction

-- | timeout if no messages are received
RestrictedTimeout :: Delay -> RestrictedAction

-- | hibernate (i.e., sleep)
RestrictedHibernate :: TimeInterval -> RestrictedAction

-- | stop/terminate the server process
RestrictedStop :: ExitReason -> RestrictedAction

-- | A version of
--   "Control.Distributed.Process.ManagedProcess.Server.handleCall" that
--   takes a handler which executes in <a>RestrictedProcess</a>.
handleCall :: (Serializable a, Serializable b) => (a -> RestrictedProcess s (Result b)) -> Dispatcher s

-- | A version of
--   "Control.Distributed.Process.ManagedProcess.Server.handleCallIf" that
--   takes a handler which executes in <a>RestrictedProcess</a>.
handleCallIf :: (Serializable a, Serializable b) => (Condition s a) -> (a -> RestrictedProcess s (Result b)) -> Dispatcher s

-- | A version of
--   "Control.Distributed.Process.ManagedProcess.Server.handleCast" that
--   takes a handler which executes in <a>RestrictedProcess</a>.
handleCast :: Serializable a => (a -> RestrictedProcess s RestrictedAction) -> Dispatcher s

-- | A version of
--   "Control.Distributed.Process.ManagedProcess.Server.handleCastIf" that
--   takes a handler which executes in <a>RestrictedProcess</a>.
handleCastIf :: Serializable a => Condition s a -> (a -> RestrictedProcess s RestrictedAction) -> Dispatcher s

-- | A version of
--   "Control.Distributed.Process.ManagedProcess.Server.handleInfo" that
--   takes a handler which executes in <a>RestrictedProcess</a>.
handleInfo :: Serializable a => (a -> RestrictedProcess s RestrictedAction) -> DeferredDispatcher s
handleExit :: Serializable a => (a -> RestrictedProcess s RestrictedAction) -> ExitSignalDispatcher s
handleTimeout :: (Delay -> RestrictedProcess s RestrictedAction) -> TimeoutHandler s

-- | Put a new process state state
putState :: s -> RestrictedProcess s ()

-- | Get the current process state
getState :: RestrictedProcess s s

-- | Apply the given expression to the current process state
modifyState :: (s -> s) -> RestrictedProcess s ()

-- | Instructs the process to send a reply and continue running.
reply :: Serializable r => r -> RestrictedProcess s (Result r)

-- | Continue without giving a reply to the caller - equivalent to
--   <a>continue</a>, but usable in a callback passed to the
--   <a>handleCall</a> family of functions.
noReply :: Serializable r => Result r -> RestrictedProcess s (Result r)

-- | Halt process execution during a call handler, without paying any
--   attention to the expected return type.
haltNoReply :: Serializable r => ExitReason -> RestrictedProcess s (Result r)

-- | Instructs the process to continue running and receiving messages.
continue :: RestrictedProcess s RestrictedAction

-- | Instructs the process loop to wait for incoming messages until
--   <a>Delay</a> is exceeded. If no messages are handled during this
--   period, the <i>timeout</i> handler will be called. Note that this
--   alters the process timeout permanently such that the given
--   <tt>Delay</tt> will remain in use until changed.
timeoutAfter :: Delay -> RestrictedProcess s RestrictedAction

-- | Instructs the process to <i>hibernate</i> for the given
--   <a>TimeInterval</a>. Note that no messages will be removed from the
--   mailbox until after hibernation has ceased. This is equivalent to
--   evaluating <tt>liftIO . threadDelay</tt>.
hibernate :: TimeInterval -> RestrictedProcess s RestrictedAction

-- | Instructs the process to terminate, giving the supplied reason. If a
--   valid <a>shutdownHandler</a> is installed, it will be called with the
--   <a>ExitReason</a> returned from this call, along with the process
--   state.
stop :: ExitReason -> RestrictedProcess s RestrictedAction

-- | Log a trace message using the underlying Process's <tt>say</tt>
say :: String -> RestrictedProcess s ()
instance Typeable RestrictedProcess
instance Typeable Result
instance Functor (RestrictedProcess s)
instance Monad (RestrictedProcess s)
instance MonadState s (RestrictedProcess s)
instance MonadIO (RestrictedProcess s)
instance Applicative (RestrictedProcess s)


-- | The Client Portion of the <i>Managed Process</i> API.
module Control.Distributed.Process.ManagedProcess.Client

-- | Send a control message over a <a>ControlPort</a>.
sendControlMessage :: Serializable m => ControlPort m -> m -> Process ()

-- | Send a signal instructing the process to terminate. The <i>receive
--   loop</i> which manages the process mailbox will prioritise
--   <tt>Shutdown</tt> signals higher than any other incoming messages, but
--   the server might be busy (i.e., still in the process of excuting a
--   handler) at the time of sending however, so the caller should not make
--   any assumptions about the timeliness with which the shutdown signal
--   will be handled. If responsiveness is important, a better approach
--   might be to send an <i>exit signal</i> with <a>Shutdown</a> as the
--   reason. An exit signal will interrupt any operation currently underway
--   and force the running process to clean up and terminate.
shutdown :: ProcessId -> Process ()

-- | Make a synchronous call - will block until a reply is received. The
--   calling process will exit with <a>ExitReason</a> if the calls fails.
call :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process b

-- | Safe version of <a>call</a> that returns information about the error
--   if the operation fails. If an error occurs then the explanation will
--   be will be stashed away as <tt>(ExitOther String)</tt>.
safeCall :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process (Either ExitReason b)

-- | Version of <a>safeCall</a> that returns <a>Nothing</a> if the
--   operation fails. If you need information about *why* a call has failed
--   then you should use <a>safeCall</a> or combine <tt>catchExit</tt> and
--   <tt>call</tt> instead.
tryCall :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process (Maybe b)

-- | Make a synchronous call, but timeout and return <tt>Nothing</tt> if a
--   reply is not received within the specified time interval.
--   
--   If the result of the call is a failure (or the call was cancelled)
--   then the calling process will exit, with the <a>ExitReason</a> given
--   as the reason. If the call times out however, the semantics on the
--   server side are undefined, i.e., the server may or may not
--   successfully process the request and may (or may not) send a response
--   at a later time. From the callers perspective, this is somewhat
--   troublesome, since the call result cannot be decoded directly. In this
--   case, the <a>flushPendingCalls</a> API <i>may</i> be used to attempt
--   to receive the message later on, however this makes <i>no attempt
--   whatsoever</i> to guarantee <i>which</i> call response will in fact be
--   returned to the caller. In those semantics are unsuited to your
--   application, you might choose to <tt>exit</tt> or <tt>die</tt> in case
--   of a timeout, or alternatively, use the <a>callAsync</a> API and
--   associated <tt>waitTimeout</tt> function (in the <i>Async API</i>),
--   which takes a re-usable handle on which to wait (with timeouts)
--   multiple times.
callTimeout :: (Addressable s, Serializable a, Serializable b) => s -> a -> TimeInterval -> Process (Maybe b)
flushPendingCalls :: Serializable b => TimeInterval -> (b -> Process b) -> Process (Maybe b)

-- | Invokes <a>call</a> <i>out of band</i>, and returns an <i>async
--   handle</i>.
callAsync :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process (Async b)

-- | Sends a <i>cast</i> message to the server identified by
--   <tt>server</tt>. The server will not send a response. Like Cloud
--   Haskell's <a>send</a> primitive, cast is fully asynchronous and
--   <i>never fails</i> - therefore <a>cast</a>ing to a non-existent (e.g.,
--   dead) server process will not generate an error.
cast :: (Addressable a, Serializable m) => a -> m -> Process ()

-- | Sends a <i>channel</i> message to the server and returns a
--   <tt>ReceivePort</tt> on which the reponse can be delivered, if the
--   server so chooses (i.e., the might ignore the request or crash).
callChan :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process (ReceivePort b)

-- | A synchronous version of <a>callChan</a>.
syncCallChan :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process b

-- | A safe version of <a>syncCallChan</a>, which returns <tt>Left
--   ExitReason</tt> if the call fails.
syncSafeCallChan :: (Addressable s, Serializable a, Serializable b) => s -> a -> Process (Either ExitReason b)


-- | This module provides a high(er) level API for building complex
--   <tt>Process</tt> implementations by abstracting out the management of
--   the process' mailbox, reply/response handling, timeouts, process
--   hiberation, error handling and shutdown/stop procedures. It is
--   modelled along similar lines to OTP's gen_server API -
--   <a>http://www.erlang.org/doc/man/gen_server.html</a>.
--   
--   In particular, a <i>managed process</i> will interoperate cleanly with
--   the supervisor API in distributed-process-supervision.
--   
--   <ul>
--   <li><i>API Overview</i></li>
--   </ul>
--   
--   Once started, a <i>managed process</i> will consume messages from its
--   mailbox and pass them on to user defined <i>handlers</i> based on the
--   types received (mapped to those accepted by the handlers) and
--   optionally by also evaluating user supplied predicates to determine
--   which handler(s) should run. Each handler returns a
--   <a>ProcessAction</a> which specifies how we should proceed. If none of
--   the handlers is able to process a message (because their types are
--   incompatible), then the <a>unhandledMessagePolicy</a> will be applied.
--   
--   The <a>ProcessAction</a> type defines the ways in which our process
--   can respond to its inputs, whether by continuing to read incoming
--   messages, setting an optional timeout, sleeping for a while or
--   stopping. The optional timeout behaves a little differently to the
--   other process actions. If no messages are received within the
--   specified time span, a user defined <a>timeoutHandler</a> will be
--   called in order to determine the next action.
--   
--   The <a>ProcessDefinition</a> type also defines a
--   <tt>shutdownHandler</tt>, which is called whenever the process exits,
--   whether because a callback has returned <a>stop</a> as the next
--   action, or as the result of unhandled exit signal or similar
--   asynchronous exceptions thrown in (or to) the process itself.
--   
--   The other handlers are split into two groups: <i>apiHandlers</i> and
--   <i>infoHandlers</i>. The former contains handlers for the <a>cast</a>
--   and <a>call</a> protocols, whilst the latter contains handlers that
--   deal with input messages which are not sent via these API calls (i.e.,
--   messages sent using bare <a>send</a> or signals put into the process
--   mailbox by the node controller, such as
--   <a>ProcessMonitorNotification</a> and the like).
--   
--   <ul>
--   <li><i>The Cast/Call Protocol</i></li>
--   </ul>
--   
--   Deliberate interactions with a <i>managed process</i> usually fall
--   into one of two categories. A <a>cast</a> interaction involves a
--   client sending a message asynchronously and the server handling this
--   input. No reply is sent to the client. On the other hand, a
--   <a>call</a> is a <i>remote procedure call</i>, where the client sends
--   a message and waits for a reply from the server.
--   
--   All expressions given to <tt>apiHandlers</tt> have to conform to the
--   <i>cast|call</i> protocol. The protocol (messaging) implementation is
--   hidden from the user; API functions for creating user defined
--   <tt>apiHandlers</tt> are given instead, which take expressions (i.e.,
--   a function or lambda expression) and create the appropriate
--   <tt>Dispatcher</tt> for handling the cast (or call).
--   
--   These cast<i>call protocols are for dealing with </i>expected/ inputs.
--   They will usually form the explicit public API for the process, and be
--   exposed by providing module level functions that defer to the
--   cast/call API, giving the author an opportunity to enforce the correct
--   types. For example:
--   
--   <pre>
--   {- Ask the server to add two numbers -}
--   add :: ProcessId -&gt; Double -&gt; Double -&gt; Double
--   add pid x y = call pid (Add x y)
--   </pre>
--   
--   Note here that the return type from the call is <i>inferred</i> and
--   will not be enforced by the type system. If the server sent a
--   different type back in the reply, then the caller might be blocked
--   indefinitely! In fact, the result of mis-matching the expected return
--   type (in the client facing API) with the actual type returned by the
--   server is more severe in practise. The underlying types that implement
--   the <i>call</i> protocol carry information about the expected return
--   type. If there is a mismatch between the input and output types that
--   the client API uses and those which the server declares it can handle,
--   then the message will be considered unroutable - no handler will be
--   executed against it and the unhandled message policy will be applied.
--   You should, therefore, take great care to align these types since the
--   default unhandled message policy is to terminate the server! That
--   might seem pretty extreme, but you can alter the unhandled message
--   policy and/or use the various overloaded versions of the call API in
--   order to detect errors on the server such as this.
--   
--   The cost of potential type mismatches between the client and server is
--   the main disadvantage of this looser coupling between them. This
--   mechanism does however, allow servers to handle a variety of messages
--   without specifying the entire protocol to be supported in excruciating
--   detail.
--   
--   <ul>
--   <li><i>Handling Unexpected/Info Messages</i></li>
--   </ul>
--   
--   An explicit protocol for communicating with the process can be
--   configured using <a>cast</a> and <a>call</a>, but it is not possible
--   to prevent other kinds of messages from being sent to the process
--   mailbox. When any message arrives for which there are no handlers able
--   to process its content, the <a>UnhandledMessagePolicy</a> will be
--   applied. Sometimes it is desireable to process incoming messages which
--   aren't part of the protocol, rather than let the policy deal with
--   them. This is particularly true when incoming messages are important
--   to the process, but their point of origin is outside the author's
--   control. Handling <i>signals</i> such as
--   <a>ProcessMonitorNotification</a> is a typical example of this:
--   
--   <pre>
--   handleInfo_ (\(ProcessMonitorNotification _ _ r) -&gt; say $ show r &gt;&gt; continue_)
--   </pre>
--   
--   <ul>
--   <li><i>Handling Process State</i></li>
--   </ul>
--   
--   The <a>ProcessDefinition</a> is parameterised by the type of state it
--   maintains. A process that has no state will have the type
--   <tt>ProcessDefinition ()</tt> and can be bootstrapped by evaluating
--   <a>statelessProcess</a>.
--   
--   All call/cast handlers come in two flavours, those which take the
--   process state as an input and those which do not. Handlers that ignore
--   the process state have to return a function that takes the state and
--   returns the required action. Versions of the various action generating
--   functions ending in an underscore are provided to simplify this:
--   
--   <pre>
--   statelessProcess {
--       apiHandlers = [
--         handleCall_   (\(n :: Int) -&gt; return (n * 2))
--       , handleCastIf_ (\(c :: String, _ :: Delay) -&gt; c == "timeout")
--                       (\("timeout", (d :: Delay)) -&gt; timeoutAfter_ d)
--       ]
--     , timeoutHandler = \_ _ -&gt; stop $ ExitOther "timeout"
--   }
--   </pre>
--   
--   <ul>
--   <li><i>Avoiding Side Effects</i></li>
--   </ul>
--   
--   If you wish to only write side-effect free code in your server
--   definition, then there is an explicit API for doing so. Instead of
--   using the handlers definition functions in this module, import the
--   <i>pure</i> server module instead, which provides a StateT based monad
--   for building referentially transparent callbacks.
--   
--   See
--   <a>Control.Distributed.Process.ManagedProcess.Server.Restricted</a>
--   for details and API documentation.
--   
--   <ul>
--   <li><i>Handling Errors</i></li>
--   </ul>
--   
--   Error handling appears in several contexts and process definitions can
--   hook into these with relative ease. Only process failures as a result
--   of asynchronous exceptions are supported by the API, which provides
--   several scopes for error handling.
--   
--   Catching exceptions inside handler functions is no different to
--   ordinary exception handling in monadic code.
--   
--   <pre>
--   handleCall (\x y -&gt;
--                catch (hereBeDragons x y)
--                      (\(e :: SmaugTheTerribleException) -&gt;
--                           return (Left (show e))))
--   </pre>
--   
--   The caveats mentioned in <a>Control.Distributed.Process.Extras</a>
--   about exit signal handling obviously apply here as well.
--   
--   <ul>
--   <li><i>Structured Exit Handling</i></li>
--   </ul>
--   
--   Because <a>Control.Distributed.Process.ProcessExitException</a> is a
--   ubiquitous signalling mechanism in Cloud Haskell, it is treated unlike
--   other asynchronous exceptions. The <a>ProcessDefinition</a>
--   <a>exitHandlers</a> field accepts a list of handlers that, for a
--   specific exit reason, can decide how the process should respond. If
--   none of these handlers matches the type of <tt>reason</tt> then the
--   process will exit with <tt>DiedException why</tt>. In addition, a
--   private <i>exit handler</i> is installed for exit signals where
--   <tt>reason :: ExitReason</tt>, which is a form of <i>exit signal</i>
--   used explicitly by the supervision APIs. This behaviour, which cannot
--   be overriden, is to gracefully shut down the process, calling the
--   <tt>shutdownHandler</tt> as usual, before stopping with
--   <tt>reason</tt> given as the final outcome.
--   
--   <i>Example: handling custom data is <tt>ProcessExitException</tt></i>
--   
--   <pre>
--   handleExit  (\state from (sigExit :: SomeExitData) -&gt; continue s)
--   </pre>
--   
--   Under some circumstances, handling exit signals is perfectly
--   legitimate. Handling of <i>other</i> forms of asynchronous exception
--   (e.g., exceptions not generated by an <i>exit</i> signal) is not
--   supported by this API. Cloud Haskell's primitives for exception
--   handling <i>will</i> work normally in managed process callbacks
--   however.
--   
--   If any asynchronous exception goes unhandled, the process will
--   immediately exit without running the <tt>shutdownHandler</tt>. It is
--   very important to note that in Cloud Haskell, link failures generate
--   asynchronous exceptions in the target and these will NOT be caught by
--   the API and will therefore cause the process to exit <i>without
--   running the termination handler</i> callback. If your termination
--   handler is set up to do important work (such as resource cleanup) then
--   you should avoid linking you process and use monitors instead.
--   
--   <ul>
--   <li><i>Prioritised Mailboxes</i></li>
--   </ul>
--   
--   Many processes need to prioritise certain classes of message over
--   others, so two subsets of the API are given to supporting those cases.
--   
--   A <tt>PrioritisedProcessDefintion</tt> combines the usual
--   <tt>ProcessDefintion</tt> - containing the cast/call API, error,
--   termination and info handlers - with a list of <a>Priority</a>
--   entries, which are used at runtime to prioritise the server's inputs.
--   Note that it is only messages which are prioritised; The server's
--   various handlers are still evaluated in insertion order.
--   
--   Prioritisation does not guarantee that a prioritised message/type will
--   be processed before other traffic - indeed doing so in a
--   multi-threaded runtime would be very hard - but in the absence of
--   races between multiple processes, if two messages are both present in
--   the process' own mailbox, they will be applied to the
--   ProcessDefinition's handler's in priority order. This is achieved by
--   draining the real mailbox into a priority queue and processing each
--   message in turn.
--   
--   A prioritised process must be configured with a <a>Priority</a> list
--   to be of any use. Creating a prioritised process without any
--   priorities would be a big waste of computational resources, and it is
--   worth thinking carefully about whether or not prioritisation is truly
--   necessary in your design before choosing to use it.
--   
--   Using a prioritised process is as simple as calling <a>pserve</a>
--   instead of <a>serve</a>, and passing an initialised
--   <a>PrioritisedProcessDefinition</a>.
--   
--   <ul>
--   <li><i>Control Channels</i></li>
--   </ul>
--   
--   For advanced users and those requiring very low latency, a prioritised
--   process definition might not be suitable, since it performs
--   considerable work <i>behind the scenes</i>. There are also designs
--   that need to segregate a process' <i>control plane</i> from other
--   kinds of traffic it is expected to receive. For such use cases, a
--   <i>control channel</i> may prove a better choice, since typed channels
--   are already prioritised during the mailbox scans that the base
--   <tt>receiveWait</tt> and <tt>receiveTimeout</tt> primitives from
--   distribute-process provides.
--   
--   In order to utilise a <i>control channel</i> in a server, it must be
--   passed to the corresponding <a>handleControlChan</a> function (or its
--   stateless variant). The control channel is created by evaluating
--   <a>newControlChan</a>, in the same way that we create regular typed
--   channels.
--   
--   In order for clients to communicate with a server via its control
--   channel however, they must pass a handle to a <a>ControlPort</a>,
--   which can be obtained by evaluating <a>channelControlPort</a> on the
--   <a>ControlChannel</a>. A <a>ControlPort</a> is <tt>Serializable</tt>,
--   so they can alternatively be sent to other processes.
--   
--   <i>Control channel</i> traffic will only be prioritised over other
--   traffic if the handlers using it are present before others (e.g.,
--   <tt>handleInfo, handleCast</tt>, etc) in the process definition. It is
--   not possible to combine prioritised processes with <i>control
--   channels</i>. Attempting to do so will satisfy the compiler, but crash
--   with a runtime error once you attempt to evaluate the prioritised
--   server loop (i.e., <a>pserve</a>).
--   
--   Since the primary purpose of control channels is to simplify and
--   optimise client-server communication over a single channel, this
--   module provides an alternate server loop in the form of
--   <a>chanServe</a>. Instead of passing an initialised
--   <a>ProcessDefinition</a>, this API takes an expression from a
--   <a>ControlChannel</a> to <a>ProcessDefinition</a>, operating in the
--   <a>Process</a> monad. Providing the opaque reference in this fashion
--   is useful, since the type of messages the control channel carries will
--   not correlate directly to the inter-process traffic we use internally.
--   
--   Although control channels are intended for use as a single control
--   plane (via <a>chanServe</a>), it <i>is</i> possible to use them as a
--   more strictly typed communications backbone, since they do enforce
--   absolute type safety in client code, being bound to a particular type
--   on creation. For rpc (i.e., <a>call</a>) interaction however, it is
--   not possible to have the server reply to a control channel, since
--   they're a <i>one way pipe</i>. It is possible to alleviate this
--   situation by passing a request type than contains a typed channel
--   bound to the expected reply type, enabling client and server to match
--   on both the input and output types as specifically as possible. Note
--   that this still does not guarantee an agreement on types between all
--   parties at runtime however.
--   
--   An example of how to do this follows:
--   
--   <pre>
--   data Request = Request String (SendPort String)
--     deriving (Typeable, Generic)
--   instance Binary Request where
--   
--   -- note that our initial caller needs an mvar to obtain the control port...
--   echoServer :: MVar (ControlPort Request) -&gt; Process ()
--   echoServer mv = do
--     cc &lt;- newControlChan :: Process (ControlChannel Request)
--     liftIO $ putMVar mv $ channelControlPort cc
--     let s = statelessProcess {
--         apiHandlers = [
--              handleControlChan_ cc (\(Request m sp) -&gt; sendChan sp m &gt;&gt; continue_)
--            ]
--       }
--     serve () (statelessInit Infinity) s
--   
--   echoClient :: String -&gt; ControlPort Request -&gt; Process String
--   echoClient str cp = do
--     (sp, rp) &lt;- newChan
--     sendControlMessage cp $ Request str sp
--     receiveChan rp
--   </pre>
--   
--   <ul>
--   <li><i>Performance Considerations</i></li>
--   </ul>
--   
--   The various server loops are fairly optimised, but there <i>is</i> a
--   definite cost associated with scanning the mailbox to match on
--   protocol messages, plus additional costs in space and time due to
--   mapping over all available <i>info handlers</i> for non-protocol
--   (i.e., neither <i>call</i> nor <i>cast</i>) messages. These are
--   exacerbated significantly when using prioritisation, whilst using a
--   single control channel is very fast and carries little overhead.
--   
--   From the client perspective, it's important to remember that the
--   <i>call</i> protocol will wait for a reply in most cases, triggering a
--   full O(n) scan of the caller's mailbox. If the mailbox is extremely
--   full and calls are regularly made, this may have a significant impact
--   on the caller. The <tt>callChan</tt> family of client API functions
--   can alleviate this, by using (and matching on) a private typed channel
--   instead, but the server must be written to accomodate this. Similar
--   gains can be had using a <i>control channel</i> and providing a typed
--   reply channel in the request data, however the <a>call</a> mechanism
--   does not support this notion, so not only are we unable to use the
--   various <i>reply</i> functions, client code should also consider
--   monitoring the server's pid and handling server failures whilst
--   waiting on
module Control.Distributed.Process.ManagedProcess

-- | Return type for and <a>InitHandler</a> expression.
data InitResult s
InitOk :: s -> Delay -> InitResult s
InitStop :: String -> InitResult s
InitIgnore :: InitResult s

-- | An expression used to initialise a process with its state.
type InitHandler a s = a -> Process (InitResult s)

-- | Starts the <i>message handling loop</i> for a managed process
--   configured with the supplied process definition, after calling the
--   init handler with its initial arguments. Note that this function does
--   not return until the server exits.
serve :: a -> InitHandler a s -> ProcessDefinition s -> Process ()

-- | Starts the <i>message handling loop</i> for a prioritised managed
--   process, configured with the supplied process definition, after
--   calling the init handler with its initial arguments. Note that this
--   function does not return until the server exits.
pserve :: a -> InitHandler a s -> PrioritisedProcessDefinition s -> Process ()

-- | Starts the <i>message handling loop</i> for a managed process,
--   configured with a typed <i>control channel</i>. The caller supplied
--   expression is evaluated with an opaque reference to the channel, which
--   must be passed when calling <tt>handleControlChan</tt>. The meaning
--   and behaviour of the init handler and initial arguments are the same
--   as those given to <a>serve</a>. Note that this function does not
--   return until the server exits.
chanServe :: Serializable b => a -> InitHandler a s -> (ControlChannel b -> Process (ProcessDefinition s)) -> Process ()

-- | Wraps any <i>process loop</i> and ensures that it adheres to the
--   managed process start/stop semantics, i.e., evaluating the
--   <tt>InitHandler</tt> with an initial state and delay will either
--   <tt>die</tt> due to <tt>InitStop</tt>, exit silently (due to
--   <tt>InitIgnore</tt>) or evaluate the process' <tt>loop</tt>. The
--   supplied <tt>loop</tt> must evaluate to <tt>ExitNormal</tt>, otherwise
--   the calling processing will <tt>die</tt> with whatever
--   <tt>ExitReason</tt> is given.
runProcess :: (s -> Delay -> Process ExitReason) -> a -> InitHandler a s -> Process ()

-- | Turns a standard <a>ProcessDefinition</a> into a
--   <a>PrioritisedProcessDefinition</a>, by virtue of the supplied list of
--   <a>DispatchPriority</a> expressions.
prioritised :: ProcessDefinition s -> [DispatchPriority s] -> PrioritisedProcessDefinition s

-- | Stores the functions that determine runtime behaviour in response to
--   incoming messages and a policy for responding to unhandled messages.
data ProcessDefinition s
ProcessDefinition :: [Dispatcher s] -> [DeferredDispatcher s] -> [ExitSignalDispatcher s] -> TimeoutHandler s -> ShutdownHandler s -> UnhandledMessagePolicy -> ProcessDefinition s

-- | functions that handle call/cast messages
apiHandlers :: ProcessDefinition s -> [Dispatcher s]

-- | functions that handle non call/cast messages
infoHandlers :: ProcessDefinition s -> [DeferredDispatcher s]

-- | functions that handle exit signals
exitHandlers :: ProcessDefinition s -> [ExitSignalDispatcher s]

-- | a function that handles timeouts
timeoutHandler :: ProcessDefinition s -> TimeoutHandler s

-- | a function that is run just before the process exits
shutdownHandler :: ProcessDefinition s -> ShutdownHandler s

-- | how to deal with unhandled messages
unhandledMessagePolicy :: ProcessDefinition s -> UnhandledMessagePolicy

-- | A <tt>ProcessDefinition</tt> decorated with <tt>DispatchPriority</tt>
--   for certain input domains.
data PrioritisedProcessDefinition s
PrioritisedProcessDefinition :: ProcessDefinition s -> [DispatchPriority s] -> RecvTimeoutPolicy -> PrioritisedProcessDefinition s
processDef :: PrioritisedProcessDefinition s -> ProcessDefinition s
priorities :: PrioritisedProcessDefinition s -> [DispatchPriority s]
recvTimeout :: PrioritisedProcessDefinition s -> RecvTimeoutPolicy

-- | For a <a>PrioritisedProcessDefinition</a>, this policy determines for
--   how long the <i>receive loop</i> should continue draining the process'
--   mailbox before processing its received mail (in priority order).
--   
--   If a prioritised <i>managed process</i> is receiving a lot of messages
--   (into its <i>real</i> mailbox), the server might never get around to
--   actually processing its inputs. This (mandatory) policy provides a
--   guarantee that eventually (i.e., after a specified number of received
--   messages or time interval), the server will stop removing messages
--   from its mailbox and process those it has already received.
data RecvTimeoutPolicy
RecvCounter :: Int -> RecvTimeoutPolicy
RecvTimer :: TimeInterval -> RecvTimeoutPolicy
newtype Priority a
Priority :: Int -> Priority a
getPrio :: Priority a -> Int
data DispatchPriority s

-- | Provides dispatch from cast and call messages to a typed handler.
data Dispatcher s

-- | Provides dispatch for any input, returns <a>Nothing</a> for unhandled
--   messages.
data DeferredDispatcher s

-- | An expression used to handle process termination.
type ShutdownHandler s = s -> ExitReason -> Process ()

-- | An expression used to handle process timeouts.
type TimeoutHandler s = s -> Delay -> Process (ProcessAction s)

-- | The action taken by a process after a handler has run and its updated
--   state. See <tt>continue</tt> <tt>timeoutAfter</tt> <tt>hibernate</tt>
--   <tt>stop</tt> <tt>stopWith</tt>
data ProcessAction s

-- | continue with (possibly new) state
ProcessContinue :: s -> ProcessAction s

-- | timeout if no messages are received
ProcessTimeout :: Delay -> s -> ProcessAction s

-- | hibernate for <i>delay</i>
ProcessHibernate :: TimeInterval -> s -> ProcessAction s

-- | stop the process, giving <tt>ExitReason</tt>
ProcessStop :: ExitReason -> ProcessAction s

-- | stop the process with <tt>ExitReason</tt>, with updated state
ProcessStopping :: s -> ExitReason -> ProcessAction s

-- | Returned from handlers for the synchronous <a>call</a> protocol,
--   encapsulates the reply data <i>and</i> the action to take after
--   sending the reply. A handler can return <tt>NoReply</tt> if they wish
--   to ignore the call.
data ProcessReply r s

-- | Wraps a predicate that is used to determine whether or not a handler
--   is valid based on some combination of the current process state, the
--   type and/or value of the input message or both.
data Condition s m

-- | An expression used to handle a <i>call</i> message.
type CallHandler s a b = s -> a -> Process (ProcessReply b s)

-- | An expression used to handle a <i>cast</i> message.
type CastHandler s a = s -> a -> Process (ProcessAction s)

-- | Policy for handling unexpected messages, i.e., messages which are not
--   sent using the <a>call</a> or <tt>cast</tt> APIs, and which are not
--   handled by any of the <tt>handleInfo</tt> handlers.
data UnhandledMessagePolicy

-- | stop immediately, giving <tt>ExitOther <a>UnhandledInput</a></tt> as
--   the reason
Terminate :: UnhandledMessagePolicy

-- | forward the message to the given recipient
DeadLetter :: ProcessId -> UnhandledMessagePolicy

-- | log messages, then behave identically to <tt>Drop</tt>
Log :: UnhandledMessagePolicy

-- | dequeue and then drop/ignore the message
Drop :: UnhandledMessagePolicy
data CallRef a

-- | Provides a means for servers to listen on a separate, typed
--   <i>control</i> channel, thereby segregating the channel from their
--   regular (and potentially busy) mailbox.
data ControlChannel m

-- | The writable end of a <a>ControlChannel</a>.
data ControlPort m

-- | A default <a>ProcessDefinition</a>, with no api, info or exit handler.
--   The default <a>timeoutHandler</a> simply continues, the
--   <a>shutdownHandler</a> is a no-op and the
--   <a>unhandledMessagePolicy</a> is <tt>Terminate</tt>.
defaultProcess :: ProcessDefinition s

-- | Creates a default <a>PrioritisedProcessDefinition</a> from a list of
--   <a>DispatchPriority</a>. See <a>defaultProcess</a> for the underlying
--   definition.
defaultProcessWithPriorities :: [DispatchPriority s] -> PrioritisedProcessDefinition s

-- | A basic, stateless <a>ProcessDefinition</a>. See <a>defaultProcess</a>
--   for the default field values.
statelessProcess :: ProcessDefinition ()

-- | A default, state <i>unaware</i> <a>InitHandler</a> that can be used
--   with <a>statelessProcess</a>. This simply returns <tt>InitOk</tt> with
--   the empty state (i.e., unit) and the given <a>Delay</a>.
statelessInit :: Delay -> InitHandler () ()

-- | Constructs a <tt>call</tt> handler from a function in the
--   <a>Process</a> monad. &gt; handleCall = handleCallIf (const True)
handleCall :: (Serializable a, Serializable b) => (s -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Constructs a <tt>call</tt> handler from an ordinary function in the
--   <a>Process</a> monad. Given a function <tt>f :: (s -&gt; a -&gt;
--   Process (ProcessReply b s))</tt>, the expression <tt>handleCall f</tt>
--   will yield a <a>Dispatcher</a> for inclusion in a <tt>Behaviour</tt>
--   specification for the <i>GenProcess</i>. Messages are only dispatched
--   to the handler if the supplied condition evaluates to <tt>True</tt>.
handleCallIf :: (Serializable a, Serializable b) => Condition s a -> (s -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | As <a>handleCall</a> but passes the <a>CallRef</a> to the handler
--   function. This can be useful if you wish to <i>reply later</i> to the
--   caller by, e.g., spawning a process to do some work and have it
--   <tt>replyTo caller response</tt> out of band. In this case the
--   callback can pass the <a>CallRef</a> to the worker (or stash it away
--   itself) and return <a>noReply</a>.
handleCallFrom :: (Serializable a, Serializable b) => (s -> CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | As <a>handleCallFrom</a> but only runs the handler if the supplied
--   <a>Condition</a> evaluates to <tt>True</tt>.
handleCallFromIf :: (Serializable a, Serializable b) => Condition s a -> (s -> CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Constructs a <tt>cast</tt> handler from an ordinary function in the
--   <a>Process</a> monad. &gt; handleCast = handleCastIf (const True)
handleCast :: Serializable a => (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Constructs a <tt>cast</tt> handler from an ordinary function in the
--   <a>Process</a> monad. Given a function <tt>f :: (s -&gt; a -&gt;
--   Process (ProcessAction s))</tt>, the expression <tt>handleCall f</tt>
--   will yield a <a>Dispatcher</a> for inclusion in a <tt>Behaviour</tt>
--   specification for the <i>GenProcess</i>.
handleCastIf :: Serializable a => Condition s a -> (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Creates a generic input handler (i.e., for received messages that are
--   <i>not</i> sent using the <tt>cast</tt> or <tt>call</tt> APIs) from an
--   ordinary function in the <a>Process</a> monad.
handleInfo :: Serializable a => (s -> a -> Process (ProcessAction s)) -> DeferredDispatcher s

-- | Handle completely <i>raw</i> input messages.
handleRaw :: (s -> Message -> Process (ProcessAction s)) -> DeferredDispatcher s

-- | Creates a handler for a <i>typed channel</i> RPC style interaction.
--   The handler takes a <tt>SendPort b</tt> to reply to, the initial input
--   and evaluates to a <a>ProcessAction</a>. It is the handler code's
--   responsibility to send the reply to the <tt>SendPort</tt>.
handleRpcChan :: (Serializable a, Serializable b) => (s -> SendPort b -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | As <a>handleRpcChan</a>, but only evaluates the handler if the
--   supplied condition is met.
handleRpcChanIf :: (Serializable a, Serializable b) => Condition s a -> (s -> SendPort b -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Constructs an <i>action</i> handler. Like <a>handleDispatch</a> this
--   can handle both <tt>cast</tt> and <tt>call</tt> messages, but you
--   won't know which you're dealing with. This can be useful where certain
--   inputs require a definite action, such as stopping the server, without
--   concern for the state (e.g., when stopping we need only decide to
--   stop, as the terminate handler can deal with state cleanup etc). For
--   example:
--   
--   <pre>
--   action (MyCriticalSignal -&gt; stop_ ExitNormal)
--   </pre>
action :: Serializable a => (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Constructs a handler for both <i>call</i> and <i>cast</i> messages.
--   <tt>handleDispatch = handleDispatchIf (const True)</tt>
handleDispatch :: Serializable a => (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Creates an <i>exit handler</i> scoped to the execution of any and all
--   the registered call, cast and info handlers for the process.
handleExit :: Serializable a => (s -> ProcessId -> a -> Process (ProcessAction s)) -> ExitSignalDispatcher s

-- | Constructs a <tt>call</tt> handler from a function in the
--   <a>Process</a> monad. The handler expression returns the reply, and
--   the action will be set to <a>continue</a>.
--   
--   <pre>
--   handleCall_ = handleCallIf_ $ input (const True)
--   </pre>
handleCall_ :: (Serializable a, Serializable b) => (a -> Process b) -> Dispatcher s

-- | A variant of <a>handleCallFrom_</a> that ignores the state argument.
handleCallFrom_ :: (Serializable a, Serializable b) => (CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Constructs a <tt>call</tt> handler from an ordinary function in the
--   <a>Process</a> monad. This variant ignores the state argument present
--   in <a>handleCall</a> and <a>handleCallIf</a> and is therefore useful
--   in a stateless server. Messges are only dispatched to the handler if
--   the supplied condition evaluates to <tt>True</tt>
--   
--   See <a>handleCall</a>
handleCallIf_ :: (Serializable a, Serializable b) => Condition s a -> (a -> Process b) -> Dispatcher s

-- | A variant of <a>handleCallFromIf</a> that ignores the state argument.
handleCallFromIf_ :: (Serializable a, Serializable b) => (Condition s a) -> (CallRef b -> a -> Process (ProcessReply b s)) -> Dispatcher s

-- | Version of <a>handleCast</a> that ignores the server state.
handleCast_ :: Serializable a => (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Version of <a>handleCastIf</a> that ignores the server state.
handleCastIf_ :: Serializable a => Condition s a -> (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | A variant of <a>handleRpcChan</a> that ignores the state argument.
handleRpcChan_ :: (Serializable a, Serializable b) => (SendPort b -> a -> Process (ProcessAction ())) -> Dispatcher ()

-- | A variant of <a>handleRpcChanIf</a> that ignores the state argument.
handleRpcChanIf_ :: (Serializable a, Serializable b) => Condition () a -> (SendPort b -> a -> Process (ProcessAction ())) -> Dispatcher ()

-- | Creates a new <a>ControlChannel</a>.
newControlChan :: Serializable m => Process (ControlChannel m)

-- | Obtain an opaque expression for communicating with a
--   <a>ControlChannel</a>.
channelControlPort :: Serializable m => ControlChannel m -> ControlPort m

-- | Constructs a <i>control channel</i> handler from a function in the
--   <a>Process</a> monad. The handler expression returns no reply, and the
--   <i>control message</i> is treated in the same fashion as a
--   <tt>cast</tt>.
--   
--   <pre>
--   handleControlChan = handleControlChanIf $ input (const True)
--   </pre>
handleControlChan :: Serializable a => ControlChannel a -> (s -> a -> Process (ProcessAction s)) -> Dispatcher s

-- | Version of <a>handleControlChan</a> that ignores the server state.
handleControlChan_ :: Serializable a => ControlChannel a -> (a -> (s -> Process (ProcessAction s))) -> Dispatcher s

-- | Creates a <a>Condition</a> from a function that takes a process state
--   <tt>a</tt> and an input message <tt>b</tt> and returns a <a>Bool</a>
--   indicating whether the associated handler should run.
condition :: (Serializable a, Serializable b) => (a -> b -> Bool) -> Condition a b

-- | Create a <a>Condition</a> from a function that takes a process state
--   <tt>a</tt> and returns a <a>Bool</a> indicating whether the associated
--   handler should run.
state :: Serializable m => (s -> Bool) -> Condition s m

-- | Creates a <a>Condition</a> from a function that takes an input message
--   <tt>m</tt> and returns a <a>Bool</a> indicating whether the associated
--   handler should run.
input :: Serializable m => (m -> Bool) -> Condition s m

-- | Instructs the process to send a reply and continue running.
reply :: Serializable r => r -> s -> Process (ProcessReply r s)

-- | Instructs the process to send a reply <i>and</i> evaluate the
--   <a>ProcessAction</a>.
replyWith :: Serializable r => r -> ProcessAction s -> Process (ProcessReply r s)

-- | Instructs the process to skip sending a reply <i>and</i> evaluate a
--   <a>ProcessAction</a>
noReply :: Serializable r => ProcessAction s -> Process (ProcessReply r s)

-- | Continue without giving a reply to the caller - equivalent to
--   <a>continue</a>, but usable in a callback passed to the
--   <a>handleCall</a> family of functions.
noReply_ :: Serializable r => s -> Process (ProcessReply r s)

-- | Halt process execution during a call handler, without paying any
--   attention to the expected return type.
haltNoReply_ :: Serializable r => ExitReason -> Process (ProcessReply r s)

-- | Instructs the process to continue running and receiving messages.
continue :: s -> Process (ProcessAction s)

-- | Version of <a>continue</a> that can be used in handlers that ignore
--   process state.
continue_ :: s -> Process (ProcessAction s)

-- | Instructs the process loop to wait for incoming messages until
--   <a>Delay</a> is exceeded. If no messages are handled during this
--   period, the <i>timeout</i> handler will be called. Note that this
--   alters the process timeout permanently such that the given
--   <tt>Delay</tt> will remain in use until changed.
timeoutAfter :: Delay -> s -> Process (ProcessAction s)

-- | Version of <a>timeoutAfter</a> that can be used in handlers that
--   ignore process state.
--   
--   <pre>
--   action (\(TimeoutPlease duration) -&gt; timeoutAfter_ duration)
--   </pre>
timeoutAfter_ :: Delay -> (s -> Process (ProcessAction s))

-- | Instructs the process to <i>hibernate</i> for the given
--   <a>TimeInterval</a>. Note that no messages will be removed from the
--   mailbox until after hibernation has ceased. This is equivalent to
--   calling <tt>threadDelay</tt>.
hibernate :: TimeInterval -> s -> Process (ProcessAction s)

-- | Version of <a>hibernate</a> that can be used in handlers that ignore
--   process state.
--   
--   <pre>
--   action (\(HibernatePlease delay) -&gt; hibernate_ delay)
--   </pre>
hibernate_ :: TimeInterval -> (s -> Process (ProcessAction s))

-- | Instructs the process to terminate, giving the supplied reason. If a
--   valid <a>shutdownHandler</a> is installed, it will be called with the
--   <a>ExitReason</a> returned from this call, along with the process
--   state.
stop :: ExitReason -> Process (ProcessAction s)

-- | As <a>stop</a>, but provides an updated state for the shutdown
--   handler.
stopWith :: s -> ExitReason -> Process (ProcessAction s)

-- | Version of <a>stop</a> that can be used in handlers that ignore
--   process state.
--   
--   <pre>
--   action (\ClientError -&gt; stop_ ExitNormal)
--   </pre>
stop_ :: ExitReason -> (s -> Process (ProcessAction s))

-- | Sends a reply explicitly to a caller.
--   
--   <pre>
--   replyTo = sendTo
--   </pre>
replyTo :: Serializable m => CallRef m -> m -> Process ()

-- | Sends a reply to a <a>SendPort</a> (for use in <a>handleRpcChan</a> et
--   al).
--   
--   <pre>
--   replyChan = sendChan
--   </pre>
replyChan :: Serializable m => SendPort m -> m -> Process ()
