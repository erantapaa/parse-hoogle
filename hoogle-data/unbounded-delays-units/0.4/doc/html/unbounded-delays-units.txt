-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Thread delays and timeouts using proper time units
--   
@package unbounded-delays-units
@version 0.4


-- | Higher level interface to <a>unbounded-delays</a> lib, allowing you to
--   specify the time delays in whatever unit you prefer, us, ms, seconds,
--   minutes, hours. See <a>this blog post for further information</a> All
--   contributions are welcomed!
module Control.Concurrent.Units

-- | Like <tt>Control.Concurrent.<a>threadDelay</a></tt>, but with a delay
--   specified as a proper time unit.
--   
--   For example:
--   
--   <pre>
--   threadDelay (5 %% Second |+| 40 %% milli Second)
--   </pre>
--   
--   or
--   
--   <pre>
--   threadDelay (5.040 %% Second)
--   </pre>
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   earlier than specified.
threadDelay :: Time -> IO ()

-- | Like <tt>System.Timeout.<a>timeout</a></tt>, but with a delay
--   specified as a proper time unit.
--   
--   For example:
--   
--   <pre>
--   timeout (4.5 %% Hour) (reallyLongIOAction)
--   </pre>
--   
--   Wrap an <a>IO</a> computation to time out and return <a>Nothing</a> in
--   case no result is available within <tt>n</tt> seconds. In case a
--   result is available before the timeout expires, <a>Just</a> <tt>a</tt>
--   is returned. A negative timeout interval means "wait indefinitely".
--   
--   The design of this combinator was guided by the objective that
--   <tt>timeout n f</tt> should behave exactly the same as <tt>f</tt> as
--   long as <tt>f</tt> doesn't time out. This means that <tt>f</tt> has
--   the same <tt>myThreadId</tt> it would have without the timeout
--   wrapper. Any exceptions <tt>f</tt> might throw cancel the timeout and
--   propagate further up. It also possible for <tt>f</tt> to receive
--   exceptions thrown to it by another thread.
--   
--   A tricky implementation detail is the question of how to abort an
--   <a>IO</a> computation. This combinator relies on asynchronous
--   exceptions internally. The technique works very well for computations
--   executing inside of the Haskell runtime system, but it doesn't work at
--   all for non-Haskell code. Foreign function calls, for example, cannot
--   be timed out with this combinator simply because an arbitrary C
--   function cannot receive asynchronous exceptions. When <tt>timeout</tt>
--   is used to wrap an FFI call that blocks, no timeout event can be
--   delivered until the FFI call returns, which pretty much negates the
--   purpose of the combinator. In practice, however, this limitation is
--   less severe than it may sound. Standard I/O functions like
--   <a>hGetBuf</a>, <a>hPutBuf</a>, Network.Socket.accept, or
--   <a>hWaitForInput</a> appear to be blocking, but they really don't
--   because the runtime system uses scheduling mechanisms like
--   <tt>select(2)</tt> to perform asynchronous I/O, so it is possible to
--   interrupt standard socket I/O or file I/O using this combinator.
timeout :: Time -> IO a -> IO (Maybe a)
data Second :: *
milli :: unit -> (:@) Milli unit
micro :: unit -> (:@) Micro unit
data Minute :: *
Minute :: Minute
data Hour :: *
Hour :: Hour
data Day :: *
Day :: Day
