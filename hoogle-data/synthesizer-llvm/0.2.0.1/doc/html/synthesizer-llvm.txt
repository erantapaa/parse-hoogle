-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient signal processing using runtime compilation
--   
--   Efficient signal processing using runtime compilation and vector
--   instructions. It uses LLVM library, thus it is not bound to a specific
--   CPU. If you compile with Cabal flag <tt>buildExamples</tt> you get the
--   executable <tt>synthi-llvm-server</tt>, that is a realtime software
--   synthesizer that receives MIDI events via ALSA and in response plays
--   some tones via ALSA.
@package synthesizer-llvm
@version 0.2.0.1

module Synthesizer.LLVM.Parameter

-- | This data type is for parameters of parameterized signal generators
--   and causal processes. It is better than using plain functions of type
--   <tt>p -&gt; a</tt> since it allows for numeric instances and we can
--   make explicit, whether a parameter is constant.
--   
--   We recommend to use parameters for atomic types. Although a parameter
--   of type <tt>T p (a,b)</tt> is possible, it means that the whole
--   parameter is variable if only one of the pair elements is variable.
--   This way you may miss optimizations.
data T p a
Constant :: a -> T p a
Variable :: (p -> a) -> T p a
get :: T p a -> (p -> a)

-- | The call <tt>value param v</tt> requires that <tt>v</tt> represents
--   the same value as <tt>valueTupleOf (get param p)</tt> for some
--   <tt>p</tt>. However <tt>v</tt> might be the result of a load operation
--   and <tt>param</tt> might be a constant. In this case it is more
--   efficient to use <tt>valueTupleOf (get param undefined)</tt> since the
--   constant is translated to an LLVM constant that allows for certain
--   optimizations.
--   
--   This is the main function for taking advantage of a constant parameter
--   in low-level implementations. For simplicity we do not omit constant
--   parameters in the parameter struct since this would mean to construct
--   types at runtime and might become ugly. Instead we just check using
--   <a>value</a> at the according places in LLVM code whether a parameter
--   is constant and ignore the parameter from the struct in this case. In
--   many cases there will be no speed benefit because the parameter will
--   be loaded to a register anyway. It can only lead to speed-up if
--   subsequent optimizations can precompute constant expressions. Another
--   example is <tt>drop</tt> where a loop with constant loop count can be
--   generated. For small loop counts and simple loop bodies the loop might
--   get unrolled.
value :: (MakeValueTuple tuple value) => T p tuple -> value -> value
instance (Fractional a) => Fractional (T p a)
instance (Num a) => Num (T p a)
instance (Show a) => Show (T p a)
instance (Eq a) => Eq (T p a)
instance (C a) => C (T p a)
instance (C a) => C (T p a)
instance (C a) => C (T p a)
instance (C a) => C (T p a)
instance (C a) => C (T p a)
instance Monad (T p)
instance Applicative (T p)
instance Functor (T p)
instance Arrow T
instance Category T


-- | Re-export functions from <a>Sound.Frame.Stereo</a> and add (orphan)
--   instances for various LLVM type classes. If you want to use the Stereo
--   datatype with synthesizer-llvm we recommend to import this module
--   instead of <a>Sound.Frame.Stereo</a> or
--   <a>Sound.Frame.NumericPrelude.Stereo</a>.
module Synthesizer.LLVM.Frame.Stereo
data T a :: * -> *
cons :: a -> a -> T a
left :: T a -> a
right :: T a -> a

-- | Run a causal process independently on each stereo channel.
arrowFromMono :: (Arrow arrow) => arrow a b -> arrow (T a) (T b)
arrowFromMonoControlled :: (Arrow arrow) => arrow (c, a) b -> arrow (c, T a) (T b)
arrowFromChannels :: (Arrow arrow) => arrow a b -> arrow a b -> arrow (T a) (T b)
interleave :: (T a, T b) -> T (a, b)
instance (Memory l s, IsSized s ss) => Memory (T l) (Struct (s, (s, ())))
instance (Access n a v) => Access n (T a) (T v)
instance (ShuffleMatch n v) => ShuffleMatch n (T v)
instance (Phi a) => Phi (T a)
instance (IsTuple a) => IsTuple (T a)
instance (MakeValueTuple h l) => MakeValueTuple (T h) (T l)
instance (CmpRet a b) => CmpRet (T a) (T b)
instance (Select a) => Select (T a)
instance (Undefined a) => Undefined (T a)
instance (ValueTuple a) => ValueTuple (T a)
instance (Zero a) => Zero (T a)

module Synthesizer.LLVM.Simple.Value
newtype T a
Cons :: (forall r. TValue r a) -> T a
decons :: T a -> forall r. TValue r a
twoPi :: (C a, IsConst a, IsFloating a) => T a
lift1 :: (forall r. Value a -> CodeGenFunction r (Value b)) -> T a -> T b
lift2 :: (forall r. Value a -> Value b -> CodeGenFunction r (Value c)) -> T a -> T b -> T c
constantValue :: Value a -> T a
constant :: (IsConst a) => a -> T a
binop :: (forall r. Value a -> Value b -> TValue r c) -> T a -> T b -> T c
class Flatten value register | value -> register
flatten :: (Flatten value register) => value -> CodeGenFunction r register
unfold :: (Flatten value register) => register -> value
flattenTraversable :: (Flatten value register, Traversable f) => f value -> CodeGenFunction r (f register)
unfoldFunctor :: (Flatten value register, Functor f) => f register -> f value
instance Flatten () ()
instance (IsConst a) => Flatten (T a) (Value a)
instance (C v, Flatten v r) => Flatten (T v) r
instance (Flatten v r) => Flatten (T v) (T r)
instance (Flatten ah al, Flatten bh bl, Flatten ch cl) => Flatten (ah, bh, ch) (al, bl, cl)
instance (Flatten ah al, Flatten bh bl) => Flatten (ah, bh) (al, bl)
instance (C a, IsConst a, IsFloating a) => C (T a)
instance (C a, IsConst a, IsFloating a) => C (T a)
instance (C a, IsConst a, IsFloating a) => C (T a)
instance (C a, IsArithmetic a, IsConst a) => Enum (T a)
instance (C a, IsArithmetic a, IsConst a, IsPrimitive a, IsPowerOf2 n) => C (T a) (T (Vector n a))
instance (C a, IsArithmetic a, IsConst a) => C (T a) (T a)
instance (C a, IsArithmetic a, IsConst a) => C (T a)
instance (IsArithmetic a, IsConst a) => C (T a)

module Synthesizer.LLVM.Parameterized.Value
newtype T p a
Cons :: (forall r. p -> TValue r a) -> T p a
decons :: T p a -> forall r. p -> TValue r a
twoPi :: (C a, IsConst a, IsFloating a) => T p a
lift0 :: T a -> T p a
lift1 :: (T a -> T b) -> (T p a -> T p b)
lift2 :: (T a -> T b -> T c) -> (T p a -> T p b -> T p c)
constantValue :: Value a -> T p a
constant :: (IsConst a) => a -> T p a
choose :: (IsConst a) => (p -> a) -> T p a
instance (C a, IsConst a, IsFloating a) => C (T p a)
instance (C a, IsConst a, IsFloating a) => C (T p a)
instance (C a, IsConst a, IsFloating a) => C (T p a)
instance (C a, IsArithmetic a, IsConst a) => Enum (T p a)
instance (C a, IsArithmetic a, IsConst a) => C (T p a)
instance (C a, IsArithmetic a, IsConst a) => C (T p a)

module Synthesizer.LLVM.Sample

-- | Copy mono signal to both stereo channels.
stereoFromMono :: Value a -> CodeGenFunction r (T (Value a))
mixMonoFromStereo :: (IsArithmetic a) => T (Value a) -> CodeGenFunction r (Value a)
zipStereo :: Value a -> Value a -> CodeGenFunction r (T (Value a))
stereoFromVector :: (IsPrimitive a) => Value (Vector D2 a) -> CodeGenFunction r (T (Value a))
vectorFromStereo :: (IsPrimitive a) => T (Value a) -> CodeGenFunction r (Value (Vector D2 a))
quadroFromVector :: (IsPrimitive a) => Value (Vector D4 a) -> CodeGenFunction r (T (T (Value a)))
vectorFromQuadro :: (IsPrimitive a) => T (T (Value a)) -> CodeGenFunction r (Value (Vector D4 a))
mixMono :: (IsArithmetic a) => Value a -> Value a -> CodeGenFunction r (Value a)
mixStereo :: (IsArithmetic a) => T (Value a) -> T (Value a) -> CodeGenFunction r (T (Value a))
class Additive a
zero :: (Additive a) => a
add :: (Additive a) => a -> a -> CodeGenFunction r a

-- | This may mean more shuffling and is not necessarily better than
--   mixStereo.
mixStereoV :: (IsArithmetic a, IsPrimitive a) => T (Value a) -> T (Value a) -> CodeGenFunction r (T (Value a))
mixVector :: (Arithmetic a, IsPowerOf2 n) => Value (Vector n a) -> CodeGenFunction r (Value a)
mixVectorToStereo :: (Arithmetic a, IsPowerOf2 n) => Value (Vector n a) -> CodeGenFunction r (T (Value a))

-- | Mix components with even index to the left channel and components with
--   odd index to the right channel.
mixInterleavedVectorToStereo :: (Arithmetic a, IsPowerOf2 n) => Value (Vector n a) -> CodeGenFunction r (T (Value a))
amplifyMono :: (IsArithmetic a) => Value a -> Value a -> CodeGenFunction r (Value a)
amplifyStereo :: (IsArithmetic a) => Value a -> T (Value a) -> CodeGenFunction r (T (Value a))
subsampleVector :: (Access n a v) => v -> CodeGenFunction r a
instance (Additive a) => Additive (T a)
instance (IsArithmetic a) => Additive (Value a)

module Synthesizer.LLVM.Wave
saw :: (C a, IsConst a, Replicate a v, IsArithmetic v) => Value v -> CodeGenFunction r (Value v)
square :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> CodeGenFunction r (Value v)
triangle :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> CodeGenFunction r (Value v)
approxSine2 :: (C a, IsConst a, Replicate a v, Real v) => Value v -> CodeGenFunction r (Value v)
approxSine3 :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> CodeGenFunction r (Value v)
approxSine4 :: (C a, IsConst a, Replicate a v, Real v) => Value v -> CodeGenFunction r (Value v)

-- | For the distortion factor <tt>recip pi</tt> you get the closest
--   approximation to an undistorted cosine or sine. We have chosen this
--   scaling in order to stay with field operations.
rationalApproxSine1 :: (C a, IsConst a, Replicate a v, Real v, IsFloating v) => Value v -> Value v -> CodeGenFunction r (Value v)
rationalApproxCosine1 :: (C a, IsConst a, Replicate a v, Real v, IsFloating v) => Value v -> Value v -> CodeGenFunction r (Value v)
trapezoidSkew :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> Value v -> CodeGenFunction r (Value v)
sine :: (C a, IsFloating a, IsConst a) => Value a -> CodeGenFunction r (Value a)

-- | This can be used for preprocessing the phase in order to generate
--   locally faster oscillating waves. For example
--   
--   <pre>
--   triangle &lt;=&lt; replicate (valueOf 2.5)
--   </pre>
--   
--   shrinks a triangle wave such that 2.5 periods fit into one.
replicate :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> Value v -> CodeGenFunction r (Value v)

-- | Preprocess the phase such that the first half of a wave is expanded to
--   one period and shifted by 90 degree. E.g.
--   
--   <pre>
--   sine &lt;=&lt; halfEnvelope
--   </pre>
--   
--   generates a sequence of sine bows that starts and ends with the
--   maximum. Such a signal can be used to envelope an oscillation
--   generated using <a>replicate</a>.
halfEnvelope :: (C a, IsConst a, Replicate a v, Fraction v, Real v) => Value v -> CodeGenFunction r (Value v)
partial :: (IsPrimitive i, IsPrimitive a, IsInteger i, IsFloating a, Replicate a v, Fraction v) => (Value v -> CodeGenFunction r (Value v)) -> Value i -> (Value v -> CodeGenFunction r (Value v))

module Synthesizer.LLVM.Parameterized.Signal
data T p a
Cons :: (forall r c. (Phi c) => nextParamValue -> state -> T r c (a, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> (p -> IO (ioContext, (nextParamTuple, startParamTuple))) -> (ioContext -> IO ()) -> T p a
simple :: (Storable startParamTuple, Storable nextParamTuple, MakeValueTuple startParamTuple startParamValue, MakeValueTuple nextParamTuple nextParamValue, Memory startParamValue startParamPacked, Memory nextParamValue nextParamPacked, IsSized startParamPacked startParamSize, IsSized nextParamPacked nextParamSize, Memory state packed, IsSized packed size) => (forall r c. (Phi c) => nextParamValue -> state -> T r c (al, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> T p nextParamTuple -> T p startParamTuple -> T p al
map :: (Storable ph, MakeValueTuple ph pl, Memory pl pp, IsSized pp ps) => (forall r. pl -> a -> CodeGenFunction r b) -> T p ph -> T p a -> T p b
mapSimple :: (forall r. a -> CodeGenFunction r b) -> T p a -> T p b
iterate :: (Storable ph, MakeValueTuple ph pl, Memory pl pp, IsSized pp ps, Storable a, MakeValueTuple a al, Memory al packed, IsSized packed s) => (forall r. pl -> al -> CodeGenFunction r al) -> T p ph -> T p a -> T p al
($#) :: (T p a -> b) -> (a -> b)
mapAccum :: (Storable pnh, MakeValueTuple pnh pnl, Memory pnl pnp, IsSized pnp pns, Storable psh, MakeValueTuple psh psl, Memory psl psp, IsSized psp pss, Memory s struct, IsSized struct sa) => (forall r. pnl -> a -> s -> CodeGenFunction r (b, s)) -> (forall r. psl -> CodeGenFunction r s) -> T p pnh -> T p psh -> T p a -> T p b
zipWith :: (Storable ph, MakeValueTuple ph pl, Memory pl pp, IsSized pp ps) => (forall r. pl -> a -> b -> CodeGenFunction r c) -> T p ph -> T p a -> T p b -> T p c
zipWithSimple :: (forall r. a -> b -> CodeGenFunction r c) -> T p a -> T p b -> T p c
zip :: T p a -> T p b -> T p (a, b)

-- | <tt>tail empty</tt> generates the empty signal.
tail :: T p a -> T p a
drop :: T p Int -> T p a -> T p a

-- | Appending many signals is inefficient, since in cascadingly appended
--   signals the parts are counted in an unary way. Concatenating
--   infinitely many signals is impossible. If you want to concatenate a
--   lot of signals, please render them to lazy storable vectors first.
append :: (Phi a) => T p a -> T p a -> T p a

-- | Stretch signal in time by a certain factor.
--   
--   This can be used for doing expensive computations of filter parameters
--   at a lower rate. Alternatively, we could provide an adaptive
--   <tt>map</tt> that recomputes output values only if the input value
--   changes, or if the input value differs from the last processed one by
--   a certain amount.
interpolateConstant :: (Memory a struct, IsSized struct size, C b, IsFloating b, CmpRet b Bool, Storable b, MakeValueTuple b (Value b), IsConst b, IsFirstClass b, IsSized b sb) => T p b -> T p a -> T p a
mix :: (IsArithmetic a) => T p (Value a) -> T p (Value a) -> T p (Value a)
mixStereo :: (IsArithmetic a) => T p (T (Value a)) -> T p (T (Value a)) -> T p (T (Value a))
envelope :: (IsArithmetic a) => T p (Value a) -> T p (Value a) -> T p (Value a)
envelopeStereo :: (IsArithmetic a) => T p (Value a) -> T p (T (Value a)) -> T p (T (Value a))
amplify :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p (Value a) -> T p (Value a)
amplifyStereo :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p (T (Value a)) -> T p (T (Value a))
constant :: (Storable a, MakeValueTuple a al, Memory al packed, IsSized packed s) => T p a -> T p al
exponentialCore :: (Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p a -> T p (Value a)
exponential2 :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p a -> T p (Value a)
exponentialBoundedCore :: (Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, Real a, IsConst a) => T p a -> T p a -> T p a -> T p (Value a)

-- | Exponential curve that remains at the bound value if it would fall
--   below otherwise. This way you can avoid extremal values, e.g.
--   denormalized ones. The initial value and the bound value must be
--   positive.
exponentialBounded2 :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, Real a, IsConst a) => T p a -> T p a -> T p a -> T p (Value a)
osciCore :: (Storable t, MakeValueTuple t (Value t), IsFirstClass t, IsSized t size, Fraction t, IsConst t) => T p t -> T p t -> T p (Value t)
osci :: (Storable t, MakeValueTuple t (Value t), Storable c, MakeValueTuple c cl, IsFirstClass t, IsSized t size, Memory cl cp, IsSized cp cs, Fraction t, IsConst t) => (forall r. cl -> Value t -> CodeGenFunction r y) -> T p c -> T p t -> T p t -> T p y
osciSimple :: (Storable t, MakeValueTuple t (Value t), IsFirstClass t, IsSized t size, Fraction t, IsConst t) => (forall r. Value t -> CodeGenFunction r y) -> T p t -> T p t -> T p y
osciSaw :: (C a0, IsConst a0, Replicate a0 a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size, Fraction a, IsPrimitive a, IsConst a) => T p a -> T p a -> T p (Value a)
rampCore :: (Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p a -> T p (Value a)
parabolaCore :: (Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p a -> T p a -> T p (Value a)
rampSlope :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeInInf :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeOutInf :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
rampInf :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeIn :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeOut :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeInMap :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
parabolaFadeOutMap :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)
ramp :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => T p a -> T p (Value a)

-- | <pre>
--   noise seed rate
--   </pre>
--   
--   The <tt>rate</tt> parameter is for adjusting the amplitude such that
--   it is uniform across different sample rates and after frequency
--   filters. The <tt>rate</tt> is the ratio of the current sample rate to
--   the default sample rate, where the variance of the samples would be
--   one. If you want that at sample rate 22050 the variance is 1, then in
--   order to get a consistent volume at sample rate 44100 you have to set
--   <tt>rate = 2</tt>.
--   
--   I use the variance as quantity and not the amplitude, because the
--   amplitude makes only sense for uniformly distributed samples. However,
--   frequency filters transform the probabilistic density of the samples
--   towards the normal distribution according to the central limit
--   theorem.
noise :: (C a, IsFloating a, IsConst a, NumberOfElements D1 a, IsSized a ps, MakeValueTuple a (Value a), Storable a) => T p Word32 -> T p a -> T p (Value a)
noiseCoreAlt :: T p Word32 -> T p (Value Word32)
noiseCore :: T p Word32 -> T p (Value Word32)
fromStorableVector :: (Storable a, MakeValueTuple a value, Memory value struct) => T p (Vector a) -> T p value
fromStorableVectorLazy :: (Storable a, MakeValueTuple a value, Memory value struct) => T p (Vector a) -> T p value
piecewiseConstant :: (Storable a, MakeValueTuple a value, Memory value struct, IsSized struct size) => T p (T Int a) -> T p value
asTypeOfEventListElement :: Ptr a -> T p (T Int a) -> Ptr a

-- | Turns a lazy chunky size into a signal generator with unit element
--   type. The signal length is the only information that the generator
--   provides. Using <a>zipWith</a> you can use this signal as a lazy
--   <a>take</a>.
lazySize :: T p LazySize -> T p ()
derefFillPtr :: Importer (Ptr param -> Word32 -> Ptr a -> IO Word32)
run :: (Storable a, MakeValueTuple a value, Memory value struct) => T p value -> IO (Int -> p -> Vector a)

-- | This is not really a function, see <a>renderChunky</a>.
render :: (Storable a, MakeValueTuple a value, Memory value struct) => T p value -> Int -> p -> Vector a
derefChunkPtr :: Importer (Ptr nextParamStruct -> Ptr stateStruct -> Word32 -> Ptr struct -> IO Word32)
compileChunky :: (Memory value struct, Memory state stateStruct, IsSized stateStruct stateSize, Memory startParamValue startParamStruct, Memory nextParamValue nextParamStruct, IsSized startParamStruct startParamSize, IsSized nextParamStruct nextParamSize) => (forall r. nextParamValue -> state -> T r (Value Bool, state) (value, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> IO (FunPtr (Ptr startParamStruct -> IO (Ptr stateStruct)), FunPtr (Ptr stateStruct -> IO ()), FunPtr (Ptr nextParamStruct -> Ptr stateStruct -> Word32 -> Ptr struct -> IO Word32))

-- | Renders a signal generator to a chunky storable vector with given
--   pattern. If the pattern is shorter than the generated signal this
--   means that the signal is shortened.
runChunkyPattern :: (Storable a, MakeValueTuple a value, Memory value struct) => T p value -> IO (LazySize -> p -> Vector a)
runChunky :: (Storable a, MakeValueTuple a value, Memory value struct) => T p value -> IO (ChunkSize -> p -> Vector a)

-- | This looks like a function, but it is not a function since it depends
--   on LLVM being initialized with LLVM.initializeNativeTarget before. It
--   is also problematic since you cannot control when and how often the
--   underlying LLVM code is compiled. The compilation cannot be observed,
--   thus it is referential transparent. But this influences performance
--   considerably and I assume that you use this package exclusively for
--   performance reasons.
renderChunky :: (Storable a, MakeValueTuple a value, Memory value struct) => ChunkSize -> T p value -> p -> Vector a


-- | Signal generators that generate the signal in chunks that can be
--   processed natively by the processor. Some of the functions for plain
--   signals can be re-used without modification. E.g. rendering a signal
--   and reading from and to signals work because the vector type as
--   element type warrents correct alignment. We can convert between atomic
--   and chunked signals.
--   
--   The article
--   <a>http://perilsofparallel.blogspot.com/2008/09/larrabee-vs-nvidia-mimd-vs-simd.html</a>
--   explains the difference between Vector and SIMD computing. According
--   to that the SSE extensions in Intel processors must be called Vector
--   computing. But since we use the term Vector already in the
--   mathematical sense, I like to use the term <a>packed</a> that is used
--   in Intel mnemonics like mulps.
module Synthesizer.LLVM.Parameterized.SignalPacked

-- | Convert a signal of scalar values into one using processor vectors. If
--   the signal length is not divisible by the chunk size, then the last
--   chunk is dropped.
packRotate :: (Access n a v) => T p a -> T p v
packIndex :: (Access n a v) => T p a -> T p v
pack :: (Access n a v) => T p a -> T p v

-- | Like <a>pack</a> but duplicates the code for creating elements. That
--   is, for vectors of size n, the code of the input signal will be
--   emitted n times. This is efficient only for simple input generators.
packSmall :: (Access n a v, Zero v) => T p a -> T p v
unpackRotate :: (Access n a v, Memory v vp, IsSized vp vs) => T p v -> T p a
unpackIndex :: (Access n a v, Memory v vp, IsSized vp vs) => T p v -> T p a
unpack :: (Access n a v, Memory v vp, IsSized vp vs) => T p v -> T p a
withSize :: (n -> T p (Value (Vector n a))) -> T p (Value (Vector n a))
constant :: (Storable a, MakeValueTuple a (Value a), IsConst a, IsPrimitive a, IsPowerOf2 n, IsSized (Vector n a) s) => T p a -> T p (Value (Vector n a))
exponential2 :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsSized (Vector n a) vs, IsPrimitive a, IsArithmetic a, IsConst a, IsPowerOf2 n) => T p a -> T p a -> T p (Value (Vector n a))
exponentialBounded2 :: (C a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a s, IsSized (Vector n a) vs, IsPrimitive a, Real a, IsConst a, IsPowerOf2 n) => T p a -> T p a -> T p a -> T p (Value (Vector n a))
osciCore :: (Storable t, MakeValueTuple t (Value t), IsFirstClass t, IsSized t size, IsSized (Vector n t) vsize, Real t, IsFloating t, C t, IsConst t, IsPowerOf2 n) => T p t -> T p t -> T p (Value (Vector n t))
osci :: (Storable t, MakeValueTuple t (Value t), Storable c, MakeValueTuple c cl, IsFirstClass t, IsSized t size, IsSized (Vector n t) vsize, Memory cl cp, IsSized cp cs, Real t, IsFloating t, C t, IsConst t, IsPowerOf2 n) => (forall r. cl -> Value (Vector n t) -> CodeGenFunction r y) -> T p c -> T p t -> T p t -> T p y
osciSimple :: (Storable t, MakeValueTuple t (Value t), IsFirstClass t, IsSized t size, IsSized (Vector n t) vsize, Real t, IsFloating t, C t, IsConst t, IsPowerOf2 n) => (forall r. Value (Vector n t) -> CodeGenFunction r y) -> T p t -> T p t -> T p y
rampSlope :: (C a, Storable a, MakeValueTuple a (Value a), IsPrimitive a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsSized (Vector n a) s) => T p a -> T p (Value (Vector n a))
parabolaFadeInInf :: (C a, Storable a, MakeValueTuple a (Value a), IsPrimitive a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsSized (Vector n a) s) => T p a -> T p (Value (Vector n a))
parabolaFadeOutInf :: (C a, Storable a, MakeValueTuple a (Value a), IsPrimitive a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsSized (Vector n a) s) => T p a -> T p (Value (Vector n a))
rampInf :: (C a, Storable a, MakeValueTuple a (Value a), IsPrimitive a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsSized (Vector n a) s) => T p a -> T p (Value (Vector n a))

-- | For the mysterious rate parameter see <a>noise</a>.
noise :: (C a, IsFloating a, IsConst a, IsPrimitive a, IsPowerOf2 n, IsSized (Vector n Word32) s, IsSized a as, Mul n as vas, Pos vas, MakeValueTuple a (Value a), Storable a) => T p Word32 -> T p a -> T p (Value (Vector n a))
noiseCoreAlt :: (IsPowerOf2 n, IsSized (Vector n Word32) s) => T p Word32 -> T p (Value (Vector n Word32))
noiseCore :: (IsPowerOf2 n, IsSized (Vector n Word32) s) => T p Word32 -> T p (Value (Vector n Word32))


-- | Functions on lazy storable vectors that are implemented using LLVM.
module Synthesizer.LLVM.Storable.Signal

-- | This function needs only constant time in contrast to
--   <tt>Synthesizer.LLVM.Parameterized.SignalPacked.unpack</tt>.
--   
--   We cannot provide a <tt>pack</tt> function since the array size may
--   not line up. It would also need copying since the source data may not
--   be aligned properly.
unpackStrict :: (Storable a, IsPrimitive a, IsPowerOf2 n) => Vector (Vector n a) -> Vector a
unpack :: (Storable a, IsPrimitive a, IsPowerOf2 n) => Vector (Vector n a) -> Vector a

-- | This is similar to <a>unpackStrict</a> but performs rearrangement of
--   data. This is for instance necessary for stereo signals where the data
--   layout of packed and unpacked data is different, thus simple casting
--   of the data is not possible.
makeUnpackGenericStrict :: (Access n va vv, Storable a, MakeValueTuple a va, Memory va as, IsSized as asize, Storable v, MakeValueTuple v vv, Memory vv vs, IsSized vs vsize) => IO (Vector v -> Vector a)
makeUnpackGeneric :: (Access n va vv, Storable a, MakeValueTuple a va, Memory va as, IsSized as asize, Storable v, MakeValueTuple v vv, Memory vv vs, IsSized vs vsize) => IO (Vector v -> Vector a)
makeReversePackedStrict :: (Storable v, Access n va vv, MakeValueTuple v vv, Memory vv vs, IsSized vs vsize) => IO (Vector v -> Vector v)
makeReversePacked :: (Storable v, Access n va vv, MakeValueTuple v vv, Memory vv vs, IsSized vs vsize) => IO (Vector v -> Vector v)

-- | Append two signals where the second signal gets the last value of the
--   first signal as parameter. If the first signal is empty then there is
--   no parameter for the second signal and thus we simply return an empty
--   signal in that case.
continue :: (Storable a) => Vector a -> (a -> Vector a) -> Vector a
continuePacked :: (IsPowerOf2 n, Storable a, IsPrimitive a) => Vector (Vector n a) -> (a -> Vector (Vector n a)) -> Vector (Vector n a)

-- | Use this like
--   
--   <pre>
--   do unpackGeneric &lt;- makeUnpackGenericStrict
--      return (continuePackedGeneric unpackGeneric x y)
--   </pre>
continuePackedGeneric :: (Storable v, Storable a) => (Vector v -> Vector a) -> Vector v -> (a -> Vector v) -> Vector v
makeMixer :: (Storable a, Additive value, MakeValueTuple a value, Memory value struct) => value -> IO (Word32 -> Ptr a -> Ptr a -> IO ())
makeArranger :: (Storable a, Additive value, MakeValueTuple a value, Memory value struct) => IO (ChunkSize -> T Int (Vector a) -> Vector a)

-- | This is unsafe since it relies on the prior initialization of the LLVM
--   JIT. Better use <a>makeArranger</a>.
arrange :: (Storable a, Additive value, MakeValueTuple a value, Memory value struct) => ChunkSize -> T Int (Vector a) -> Vector a

module Synthesizer.LLVM.CausalParameterized.Process
data T p a b
Cons :: (forall r c. (Phi c) => nextParamValue -> a -> state -> T r c (b, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> (p -> IO (ioContext, (nextParamTuple, startParamTuple))) -> (ioContext -> IO ()) -> T p a b
simple :: (Storable startParamTuple, Storable nextParamTuple, MakeValueTuple startParamTuple startParamValue, MakeValueTuple nextParamTuple nextParamValue, Memory startParamValue startParamPacked, Memory nextParamValue nextParamPacked, IsSized startParamPacked startParamSize, IsSized nextParamPacked nextParamSize, Memory state packed, IsSized packed size) => (forall r c. (Phi c) => nextParamValue -> a -> state -> T r c (b, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> T p nextParamTuple -> T p startParamTuple -> T p a b
mapAccum :: (Storable pnh, MakeValueTuple pnh pnl, Memory pnl pnp, IsSized pnp pns, Storable psh, MakeValueTuple psh psl, Memory psl psp, IsSized psp pss, Memory s struct, IsSized struct sa) => (forall r. pnl -> a -> s -> CodeGenFunction r (b, s)) -> (forall r. psl -> CodeGenFunction r s) -> T p pnh -> T p psh -> T p a b
map :: (Storable ph, MakeValueTuple ph pl, Memory pl pp, IsSized pp ps) => (forall r. pl -> a -> CodeGenFunction r b) -> T p ph -> T p a b
mapSimple :: (forall r. a -> CodeGenFunction r b) -> T p a b
apply :: T p a b -> T p a -> T p b
compose :: T p a b -> T p b c -> T p a c
first :: T p b c -> T p (b, d) (c, d)
feedFst :: T p a -> T p b (a, b)
feedSnd :: T p a -> T p b (b, a)
take :: T p Int -> T p a a

-- | The first output value is the start value. Thus <a>integrate</a>
--   delays by one sample compared with <a>integrate0</a>.
integrate :: (Storable a, IsArithmetic a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p (Value a) (Value a)
($<) :: T p (a, b) c -> T p a -> T p b c
applyFst :: T p (a, b) c -> T p a -> T p b c
($>) :: T p (a, b) c -> T p b -> T p a c
applySnd :: T p (a, b) c -> T p b -> T p a c
($*) :: T p a b -> T p a -> T p b

-- | provide constant input in a comfortable way
($*#) :: (Storable ah, MakeValueTuple ah a, Memory a am, IsSized am as) => T p a b -> ah -> T p b
($<#) :: (Storable ah, MakeValueTuple ah a, Memory a am, IsSized am as) => T p (a, b) c -> ah -> T p b c
($>#) :: (Storable bh, MakeValueTuple bh b, Memory b bm, IsSized bm bs) => T p (a, b) c -> bh -> T p a c
mapAccumSimple :: (Memory s struct, IsSized struct sa) => (forall r. a -> s -> CodeGenFunction r (b, s)) -> (forall r. CodeGenFunction r s) -> T p a b

-- | Not quite the loop of ArrowLoop because we need a delay of one time
--   step and thus an initialization value.
--   
--   For a real ArrowLoop.loop, that is a zero-delay loop, we would
--   formally need a MonadFix instance of CodeGenFunction. But this will
--   not become reality, since LLVM is not able to re-order code in a way
--   that allows to access a result before creating the input.
loop :: (Storable ch, MakeValueTuple ch c, Memory c cp, IsSized cp cs) => T p ch -> T p (a, c) (b, c) -> T p a b
replicateControlled :: Int -> T p (c, x) x -> T p (c, x) x
feedbackControlled :: (Storable ch, MakeValueTuple ch c, Memory c cp, IsSized cp cs) => T p ch -> T p ((ctrl, a), c) b -> T p (ctrl, b) c -> T p (ctrl, a) b
fromModifier :: (Flatten ah al, Flatten bh bl, Flatten ch cl, Flatten sh sl, Memory sl sp, IsSized sp ss) => Simple sh ch ah bh -> T p (cl, al) bl

-- | Run a causal process independently on each stereo channel.
stereoFromMono :: T p a b -> T p (T a) (T b)
stereoFromMonoControlled :: T p (c, a) b -> T p (c, T a) (T b)
stereoFromChannels :: T p a b -> T p a b -> T p (T a) (T b)
stereoFromVector :: (IsPrimitive a, IsPrimitive b) => T p (Value (Vector D2 a)) (Value (Vector D2 b)) -> T p (T (Value a)) (T (Value b))
vectorize :: (Access n a va, Access n b vb) => T p a b -> T p va vb
vectorizeSize :: (Access n a va, Access n b vb) => n -> T p a b -> T p va vb

-- | Given a vector process, replace the i-th output by output that is
--   generated by a scalar process from the i-th input.
replaceChannel :: (Access n a va, Access n b vb) => Int -> T p a b -> T p va vb -> T p va vb
zipWithSimple :: (forall r. a -> b -> CodeGenFunction r c) -> T p (a, b) c
mix :: (IsArithmetic a) => T p (Value a, Value a) (Value a)
mixStereo :: (IsArithmetic a) => T p (T (Value a), T (Value a)) (T (Value a))
raise :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsSized a size) => T p a -> T p (Value a) (Value a)
envelope :: (IsArithmetic a) => T p (Value a, Value a) (Value a)
envelopeStereo :: (IsArithmetic a) => T p (Value a, T (Value a)) (T (Value a))
amplify :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p (Value a) (Value a)
amplifyStereo :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p (T (Value a)) (T (Value a))
mapLinear :: (IsArithmetic a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p a -> T p (Value a) (Value a)
mapExponential :: (C a, IsFloating a, IsConst a, Storable a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size) => T p a -> T p a -> T p (Value a) (Value a)

-- | <tt>quantizeLift k f</tt> applies the process <tt>f</tt> to every
--   <tt>k</tt>th sample and repeats the result <tt>k</tt> times.
--   
--   Like <tt>SigP.interpolateConstant</tt> this function can be used for
--   computation of filter parameters at a lower rate. This can be useful,
--   if you have a frequency control signal at sample rate that shall be
--   used both for an oscillator and a frequency filter.
quantizeLift :: (Memory b struct, IsSized struct size, C c, IsFloating c, CmpRet c Bool, Storable c, MakeValueTuple c (Value c), IsConst c, IsFirstClass c, IsSized c sc) => T p c -> T p a b -> T p a b

-- | Compute the phases from phase distortions and frequencies.
--   
--   It's like integrate but with wrap-around performed by
--   <tt>fraction</tt>. For FM synthesis we need also negative phase
--   distortions, thus we use <a>addToPhase</a> which supports that.
osciCore :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, C t) => T p (Value t, Value t) (Value t)
osciSimple :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, C t) => (forall r. Value t -> CodeGenFunction r y) -> T p (Value t, Value t) y
shapeModOsci :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, C t) => (forall r. c -> Value t -> CodeGenFunction r y) -> T p (c, (Value t, Value t)) y

-- | Delay time must be non-negative.
--   
--   The initial value is needed in order to determine the ring buffer
--   element type.
delay :: (Storable a, MakeValueTuple a al, Memory al ap, IsSized ap as) => T p a -> T p Int -> T p al al
ptrAsTypeOf :: Ptr a -> a -> Ptr a

-- | Delay by one sample. For very small delay times (say up to 8) it may
--   be more efficient to apply <a>delay1</a> several times or to use a
--   pipeline, e.g. <tt>pipeline (id :: T (Vector D4 Float) (Vector D4
--   Float))</tt> delays by 4 samples in an efficient way. In principle it
--   would be also possible to use <tt>unpack (delay1 (const $ toVector
--   (0,0,0,0)))</tt> but <tt>unpack</tt> causes an additional delay. Thus
--   <tt>unpack (id :: T (Vector D4 Float) (Vector D4 Float))</tt> may do,
--   what you want.
delay1 :: (Storable a, MakeValueTuple a al, Memory al ap, IsSized ap as) => T p a -> T p al al

-- | Delay time must be greater than zero!
comb :: (C a, Storable a, IsArithmetic a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a as) => T p a -> T p Int -> T p (Value a) (Value a)
combStereo :: (C a, Storable a, IsArithmetic a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a as) => T p a -> T p Int -> T p (T (Value a)) (T (Value a))
reverb :: (C a, Random a, Storable a, IsArithmetic a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a as, RandomGen g) => g -> Int -> (a, a) -> (Int, Int) -> T p (Value a) (Value a)

-- | This allows to compute a chain of equal processes efficiently, if all
--   of these processes can be bundled in one vectorial process.
--   Applications are an allpass cascade or an FM operator cascade.
--   
--   The function expects that the vectorial input process works like
--   parallel scalar processes. The different pipeline stages may be
--   controlled by different parameters, but the structure of all pipeline
--   stages must be equal. Our function feeds the input of the pipelined
--   process to the zeroth element of the Vector. The result of processing
--   the i-th element (the i-th channel, so to speak) is fed to the
--   (i+1)-th element. The (n-1)-th element of the vectorial process is
--   emitted as output of pipelined process.
--   
--   The pipeline necessarily introduces a delay of (n-1) values. For
--   simplification we extend this to n values delay. If you need to
--   combine the resulting signal from the pipeline with another signal in
--   a <tt>zip</tt>-like way, you may delay that signal with <tt>pipeline
--   id</tt>. The first input values in later stages of the pipeline are
--   initialized with zero. If this is not appropriate for your
--   application, then we may add a more sensible initialization.
pipeline :: (Access n a v, Zero v, Memory v vp, IsSized vp s) => T p v v -> T p a a
linearInterpolation :: (C a, IsArithmetic a, IsConst a) => Value a -> (Value a, Value a) -> CodeGenFunction r (Value a)

-- | <pre>
--   frequencyModulationLinear signal
--   </pre>
--   
--   is a causal process mapping from a shrinking factor to the modulated
--   input <tt>signal</tt>. Similar to <a>interpolateConstant</a> but the
--   factor is reciprocal and controllable and we use linear interpolation.
--   The shrinking factor must be non-negative.
frequencyModulationLinear :: (C a, IsFloating a, CmpRet a Bool, Storable a, MakeValueTuple a (Value a), IsConst a, IsFirstClass a, IsSized a sa) => T p (Value a) -> T p (Value a) (Value a)

-- | <tt>trigger fill signal</tt> send <tt>signal</tt> to the output and
--   restart it whenever the Boolean process input is <a>True</a>. Before
--   the first occurrence of <a>True</a> and between instances of the
--   signal the output is filled with the <tt>fill</tt> value.
--   
--   Attention: This function will crash if the input generator uses
--   fromStorableVectorLazy, piecewiseConstant or lazySize, since these
--   functions contain mutable references and in-place updates, and thus
--   they cannot read lazy Haskell data multiple times.
trigger :: (Storable a, MakeValueTuple a al, Select al, Memory al as, IsSized as asize) => T p a -> T p al -> T p (Value Bool) al

-- | On each restart the parameters of type <tt>b</tt> are passed to the
--   signal.
--   
--   triggerParam :: (MakeValueTuple a al, MakeValueTuple b bl) =&gt;
--   Param.T p a -&gt; (Param.T p b -&gt; Sig.T p a) -&gt; T p (Value Bool,
--   bl) al triggerParam fill sig =
derefFillPtr :: Importer (Ptr param -> Word32 -> Ptr a -> Ptr b -> IO Word32)
runStorable :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T p valueA valueB -> IO (p -> Vector a -> Vector b)
applyStorable :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T p valueA valueB -> p -> Vector a -> Vector b
derefChunkPtr :: Importer (Ptr nextParamStruct -> Ptr stateStruct -> Word32 -> Ptr structA -> Ptr structB -> IO Word32)
compileChunky :: (Memory valueA structA, Memory valueB structB, Memory state stateStruct, IsSized stateStruct stateSize, Memory startParamValue startParamStruct, Memory nextParamValue nextParamStruct, IsSized startParamStruct startParamSize, IsSized nextParamStruct nextParamSize) => (forall r. nextParamValue -> valueA -> state -> T r (Value Bool, (Value (Ptr structB), state)) (valueB, state)) -> (forall r. startParamValue -> CodeGenFunction r state) -> IO (FunPtr (Ptr startParamStruct -> IO (Ptr stateStruct)), FunPtr (Ptr stateStruct -> IO ()), FunPtr (Ptr nextParamStruct -> Ptr stateStruct -> Word32 -> Ptr structA -> Ptr structB -> IO Word32))
runStorableChunky :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T p valueA valueB -> IO (p -> Vector a -> Vector b)

-- | This function should be used instead of
--   <tt>StorableVector.Lazy.Pattern.splitAt</tt> and subsequent
--   <tt>append</tt>, because it does not have the risk of a memory leak.
runStorableChunkyCont :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T p valueA valueB -> IO ((Vector a -> Vector b) -> p -> Vector a -> Vector b)
applyStorableChunky :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T p valueA valueB -> p -> Vector a -> Vector b

module Synthesizer.LLVM.CausalParameterized.ProcessPacked

-- | Run a scalar process on packed data. If the signal length is not
--   divisible by the chunk size, then the last chunk is dropped.
pack :: (Access n a va, Access n b vb) => T p a b -> T p va vb

-- | Like <a>pack</a> but duplicates the code for the scalar process. That
--   is, for vectors of size n, the code for the scalar causal process will
--   be written n times. This is efficient only for simple input processes.
packSmall :: (Access n a va, Access n b vb) => T p a b -> T p va vb

-- | Run a packed process on scalar data. If the signal length is not
--   divisible by the chunk size, then the last chunk is dropped. In order
--   to stay causal, we have to delay the output by <tt>n</tt> samples.
unpack :: (Access n a va, Access n b vb, Zero va, Undefined b, Memory va vap, IsSized vap vas, Memory vb vbp, IsSized vbp vbs) => T p va vb -> T p a b
raise :: (Storable a, IsArithmetic a, IsPrimitive a, IsConst a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size, IsPowerOf2 n, Mul n size ps, Pos ps) => T p a -> T p (Value (Vector n a)) (Value (Vector n a))
amplify :: (Storable a, IsArithmetic a, IsPrimitive a, IsConst a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size, IsPowerOf2 n, Mul n size ps, Pos ps) => T p a -> T p (Value (Vector n a)) (Value (Vector n a))
amplifyStereo :: (Storable a, IsArithmetic a, IsPrimitive a, IsConst a, MakeValueTuple a (Value a), IsFirstClass a, IsSized a size, IsPowerOf2 n, Mul n size ps, Pos ps) => T p a -> T p (T (Value (Vector n a))) (T (Value (Vector n a)))
osciCore :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, Real t, IsPrimitive t, IsPowerOf2 n, C t) => T p (Value (Vector n t), Value (Vector n t)) (Value (Vector n t))
osciSimple :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, Real t, IsPrimitive t, IsPowerOf2 n, C t) => (forall r. Value (Vector n t) -> CodeGenFunction r y) -> T p (Value (Vector n t), Value (Vector n t)) y
shapeModOsci :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t, Real t, IsPrimitive t, IsPowerOf2 n, C t) => (forall r. c -> Value (Vector n t) -> CodeGenFunction r y) -> T p (c, (Value (Vector n t), Value (Vector n t))) y

module Synthesizer.LLVM.Filter.FirstOrder
data Result a :: * -> *
Result :: !a -> !a -> Result a
highpass_ :: Result a -> !a
lowpass_ :: Result a -> !a
data Parameter a :: * -> *
parameter :: (C a, IsConst a, IsFloating a) => Value a -> CodeGenFunction r (Parameter (Value a))
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v) => T p (Parameter (Value a), Value v) (Result (Value v))
lowpassCausalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a) => T p (Parameter (Value a), Value v) (Value v)
highpassCausalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a) => T p (Parameter (Value a), Value v) (Value v)
causalPackedP :: (C a, IsArithmetic a, IsPrimitive a, IsFirstClass a, IsConst a, IsSized a as, IsPowerOf2 n) => T p (Parameter (Value a), Value (Vector n a)) (Result (Value (Vector n a)))
lowpassCausalPackedP :: (C a, IsFirstClass a, IsConst a, IsSized a as, IsPowerOf2 n, IsArithmetic a, IsPrimitive a) => T p (Parameter (Value a), Value (Vector n a)) (Value (Vector n a))
highpassCausalPackedP :: (C a, IsFirstClass a, IsConst a, IsSized a as, IsPowerOf2 n, IsArithmetic a, IsPrimitive a) => T p (Parameter (Value a), Value (Vector n a)) (Value (Vector n a))
causalRecursivePackedP :: (C a, IsFirstClass a, IsConst a, IsSized a as, IsPowerOf2 n, IsArithmetic a, IsPrimitive a) => T p (Parameter (Value a), Value (Vector n a)) (Value (Vector n a))
instance (MakeValueTuple ah al) => MakeValueTuple (Parameter ah) (Parameter al)
instance (IsTuple a) => IsTuple (Parameter a)
instance (ValueTuple a) => ValueTuple (Parameter a)
instance (Flatten ah al) => Flatten (Parameter ah) (Parameter al)
instance (Memory a s, IsSized s ss) => Memory (Parameter a) s
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)

module Synthesizer.LLVM.Filter.Allpass
data Parameter a :: * -> *
parameter :: (C a, IsConst a, IsFloating a) => Value a -> Value a -> CodeGenFunction r (Parameter (Value a))
data CascadeParameter n a
flangerParameter :: (C a, IsConst a, IsFloating a, Nat n) => n -> Value a -> CodeGenFunction r (CascadeParameter n (Value a))
flangerParameterPlain :: (C a, Nat n) => n -> a -> CascadeParameter n a
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a) => T p (Parameter (Value a), Value v) (Value v)
cascadeP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a, Nat n) => T p (CascadeParameter n (Value a), Value v) (Value v)
phaserP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsFloating a, IsArithmetic v, Nat n) => T p (CascadeParameter n (Value a), Value v) (Value v)

-- | Fast implementation of <a>cascadeP</a> using vector instructions.
--   However, we are currently limited to powers of two, primitive element
--   types and we get a delay by the number of pipeline stages.
cascadePipelineP :: (C a, IsFirstClass a, IsSized a as, Mul n as vas, Pos vas, IsPowerOf2 n, IsArithmetic a, IsPrimitive a, IsConst a) => T p (CascadeParameter n (Value a), Value a) (Value a)
phaserPipelineP :: (C a, IsFirstClass a, IsSized a as, IsSized (Vector n a) vas, Mul n as vas, IsPowerOf2 n, IsFloating a, IsPrimitive a, IsConst a) => T p (CascadeParameter n (Value a), Value a) (Value a)
causalPackedP :: (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsPrimitive a, IsSized a as) => T p (Parameter (Value a), Value (Vector n a)) (Value (Vector n a))
cascadePackedP :: (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 m, IsPrimitive a, IsSized a as, Nat n) => T p (CascadeParameter n (Value a), Value (Vector m a)) (Value (Vector m a))
phaserPackedP :: (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 m, IsPrimitive a, IsSized a as, Nat n) => T p (CascadeParameter n (Value a), Value (Vector m a)) (Value (Vector m a))
instance (Phi a) => Phi (CascadeParameter n a)
instance (Undefined a) => Undefined (CascadeParameter n a)
instance (Zero a) => Zero (CascadeParameter n a)
instance (Storable a) => Storable (CascadeParameter n a)
instance Functor (CascadeParameter n)
instance Applicative (CascadeParameter n)
instance Foldable (CascadeParameter n)
instance Traversable (CascadeParameter n)
instance (Access m a v) => Access m (CascadeParameter n a) (CascadeParameter n v)
instance (ShuffleMatch m v) => ShuffleMatch m (CascadeParameter n v)
instance (Flatten ah al) => Flatten (CascadeParameter n ah) (CascadeParameter n al)
instance (MakeValueTuple ah al) => MakeValueTuple (CascadeParameter n ah) (CascadeParameter n al)
instance (IsTuple a) => IsTuple (CascadeParameter n a)
instance (ValueTuple a) => ValueTuple (CascadeParameter n a)
instance (Memory a s, IsSized s ss) => Memory (CascadeParameter n a) s
instance (Access n a v) => Access n (Parameter a) (Parameter v)
instance (ShuffleMatch n v) => ShuffleMatch n (Parameter v)
instance (Flatten ah al) => Flatten (Parameter ah) (Parameter al)
instance (MakeValueTuple ah al) => MakeValueTuple (Parameter ah) (Parameter al)
instance (IsTuple a) => IsTuple (Parameter a)
instance (ValueTuple a) => ValueTuple (Parameter a)
instance (Memory a s, IsSized s ss) => Memory (Parameter a) s
instance (Zero a) => Zero (Parameter a)
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)

module Synthesizer.LLVM.Filter.SecondOrder

-- | Parameters for a general recursive filter of 2nd order.
data Parameter a :: * -> *
bandpassParameter :: (C a, IsFloating a, IsConst a) => Value a -> Value a -> CodeGenFunction r (Parameter (Value a))
type ParameterStruct a = Struct (a, (a, (a, (a, (a, ())))))
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a) => T p (Parameter (Value a), Value v) (Value v)
causalPackedP :: (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsPrimitive a, IsSized a as, Mul n as vas, Pos vas) => T p (Parameter (Value a), Value (Vector n a)) (Value (Vector n a))
instance (Flatten ah al) => Flatten (State ah) (State al)
instance (Memory a s, IsSized s ss) => Memory (State a) (Struct (s, (s, (s, (s, (s, ()))))))
instance (Undefined a) => Undefined (State a)
instance (Phi a) => Phi (State a)
instance (Flatten ah al) => Flatten (Parameter ah) (Parameter al)
instance (Memory a s, IsSized s ss) => Memory (Parameter a) (Struct (s, (s, (s, (s, (s, ()))))))
instance (MakeValueTuple h l) => MakeValueTuple (Parameter h) (Parameter l)
instance (IsTuple a) => IsTuple (Parameter a)
instance (ValueTuple a) => ValueTuple (Parameter a)
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)

module Synthesizer.LLVM.Filter.SecondOrderCascade
type Parameter n a = Array n (ParameterStruct a)
newtype ParameterValue n a
ParameterValue :: Value (Parameter n a) -> ParameterValue n a
parameterValue :: ParameterValue n a -> Value (Parameter n a)
withSize :: (n -> T p (ParameterValue n a, x) y) -> T p (ParameterValue n a, x) y
fixSize :: n -> T p (ParameterValue n a, x) y -> T p (ParameterValue n a, x) y
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize) => T p (ParameterValue n a, Value v) (Value v)
causalPackedP :: (C a, IsPrimitive a, IsSized a as, IsConst a, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize, IsPowerOf2 d, Mul d as vas, Pos vas) => T p (ParameterValue n a, Value (Vector d a)) (Value (Vector d a))
getStageParameterMalloc :: (IsFirstClass a, Nat n, IsSized a sa, Mul n UnknownSize s, Pos s) => ParameterValue n a -> Word32 -> CodeGenFunction r (Parameter (Value a))
getStageParameterAlloca :: (IsFirstClass a, Nat n, IsSized a sa, Mul n UnknownSize s, Pos s) => ParameterValue n a -> Word32 -> CodeGenFunction r (Parameter (Value a))
getStageParameter :: (IsFirstClass a, Nat n, IsSized a sa, Mul n UnknownSize s, Pos s) => ParameterValue n a -> Word32 -> CodeGenFunction r (Parameter (Value a))
instance (Nat n, IsSized a s) => Memory (ParameterValue n a) (Parameter n a)
instance (Nat n, IsSized a s) => Zero (ParameterValue n a)
instance (Nat n, IsSized a s) => Undefined (ParameterValue n a)
instance (Nat n, IsSized a s) => Phi (ParameterValue n a)

module Synthesizer.LLVM.Filter.Butterworth
parameter :: (C a, IsConst a, IsFloating a, IsSized a as, Nat n, Mul n as sineSize, Pos sineSize, IsSized (Parameter n a) paramSize) => n -> Passband -> Value a -> Value a -> CodeGenFunction r (ParameterValue n a)
data ParameterValue n a
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize) => T p (ParameterValue n a, Value v) (Value v)
causalPackedP :: (C a, IsPrimitive a, IsSized a as, IsConst a, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize, IsPowerOf2 d, Mul d as vas, Pos vas) => T p (ParameterValue n a, Value (Vector d a)) (Value (Vector d a))
fixSize :: n -> T p (ParameterValue n a, x) y -> T p (ParameterValue n a, x) y

module Synthesizer.LLVM.Filter.Chebyshev
parameterA :: (C a, IsConst a, IsFloating a, IsSized a as, Pos n, Mul n as sineSize, Pos sineSize, IsSized (Parameter n a) paramSize, Mul n UnknownSize paramSize, Pos paramSize) => n -> Passband -> Value a -> Value a -> CodeGenFunction r (ParameterValue n a)

-- | <tt>n</tt> must be at least one in order to allow amplification by the
--   first partial filter.
parameterB :: (C a, IsConst a, IsFloating a, IsSized a as, Pos n, Mul n as sineSize, Pos sineSize, IsSized (Parameter n a) paramSize, Mul n UnknownSize paramSize, Pos paramSize) => n -> Passband -> Value a -> Value a -> CodeGenFunction r (ParameterValue n a)
data ParameterValue n a
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize) => T p (ParameterValue n a, Value v) (Value v)
causalPackedP :: (C a, IsPrimitive a, IsSized a as, IsConst a, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize, IsPowerOf2 d, Mul d as vas, Pos vas) => T p (ParameterValue n a, Value (Vector d a)) (Value (Vector d a))
fixSize :: n -> T p (ParameterValue n a, x) y -> T p (ParameterValue n a, x) y

module Synthesizer.LLVM.Filter.SecondOrderPacked

-- | Layout:
--   
--   <pre>
--   c0 [c1 d1 c2 d2]
--   </pre>
data Parameter a
bandpassParameter :: (C a, IsFloating a, IsConst a, IsPrimitive a) => Value a -> Value a -> CodeGenFunction r (Parameter a)
type State = Vector D4
causalP :: (C a, Arithmetic a, IsSized (State a) as) => T p (Parameter a, Value a) (Value a)
instance (IsPrimitive l, IsFirstClass l, IsSized l s, Add s s s2, Add s2 s s3, Add s3 s s4, Pos s4) => Memory (Parameter l) (Struct (l, (Vector D4 l, ())))
instance (IsFirstClass a, IsPrimitive a) => Undefined (Parameter a)
instance (IsFirstClass a, IsPrimitive a) => Phi (Parameter a)

module Synthesizer.LLVM.Filter.Moog
data Parameter n a
parameter :: (C a, IsConst a, IsFloating a, Nat n) => n -> Value a -> Value a -> CodeGenFunction r (Parameter n (Value a))
causalP :: (C (T a) (T v), C a v, Storable v, MakeValueTuple v (Value v), MakeValueTuple a (Value a), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, Nat n) => T p (Parameter n (Value a), Value v) (Value v)
instance Functor (Parameter n)
instance Applicative (Parameter n)
instance Foldable (Parameter n)
instance Traversable (Parameter n)
instance (Access m a v, Nat n) => Access m (Parameter n a) (Parameter n v)
instance (ShuffleMatch m v, Nat n) => ShuffleMatch m (Parameter n v)
instance (Flatten ah al, Nat n) => Flatten (Parameter n ah) (Parameter n al)
instance (Memory a s, IsSized s ss, Nat n) => Memory (Parameter n a) (Struct (s, (s, ())))
instance (Zero a, Nat n) => Zero (Parameter n a)
instance (Undefined a, Nat n) => Undefined (Parameter n a)
instance (Phi a, Nat n) => Phi (Parameter n a)

module Synthesizer.LLVM.Filter.Universal
data Result a :: * -> *
Result :: !a -> !a -> !a -> !a -> Result a
highpass :: Result a -> !a
bandpass :: Result a -> !a
lowpass :: Result a -> !a
bandlimit :: Result a -> !a
data Parameter a :: * -> *
parameter :: (C a, IsConst a, IsFloating a) => Value a -> Value a -> CodeGenFunction r (Parameter (Value a))
causalP :: (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic a) => T p (Parameter (Value a), Value v) (Result (Value v))
instance (Access d a v) => Access d (Result a) (Result v)
instance (ShuffleMatch d v) => ShuffleMatch d (Result v)
instance (Undefined a) => Undefined (Result a)
instance (Phi a) => Phi (Result a)
instance (Access d a v) => Access d (Parameter a) (Parameter v)
instance (ShuffleMatch d v) => ShuffleMatch d (Parameter v)
instance (Flatten ah al) => Flatten (Parameter ah) (Parameter al)
instance (MakeValueTuple ah al) => MakeValueTuple (Parameter ah) (Parameter al)
instance (IsTuple a) => IsTuple (Parameter a)
instance (ValueTuple a) => ValueTuple (Parameter a)
instance (Flatten ah al) => Flatten (Result ah) (Result al)
instance (MakeValueTuple ah al) => MakeValueTuple (Result ah) (Result al)
instance (IsTuple a) => IsTuple (Result a)
instance (ValueTuple a) => ValueTuple (Result a)
instance (Memory a s, IsSized s ss) => Memory (Parameter a) (Struct (s, (s, (s, (s, (s, (s, ())))))))
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)


-- | Exponential curve with controllable delay.
module Synthesizer.LLVM.Generator.Exponential2
data Parameter a
parameter :: (C a, IsConst a, IsFloating a) => Value a -> CodeGenFunction r (Parameter (Value a))
parameterPlain :: (C a) => a -> Parameter a
causalP :: (IsFirstClass a, IsSized a size, IsArithmetic a, IsConst a, Storable a, MakeValueTuple a (Value a)) => T p a -> T p (Parameter (Value a)) (Value a)
data ParameterPacked a
parameterPacked :: (C a, IsConst a, IsFloating a, IsPrimitive a, IsPowerOf2 n) => Value a -> CodeGenFunction r (ParameterPacked (Value (Vector n a)))
parameterPackedPlain :: (C a, IsPowerOf2 n) => a -> ParameterPacked (Vector n a)
causalPackedP :: (IsFirstClass a, IsSized a size, IsArithmetic a, IsConst a, Storable a, MakeValueTuple a (Value a), IsPrimitive a, IsPowerOf2 n, Mul n size pss, Pos pss) => T p a -> T p (ParameterPacked (Value (Vector n a))) (Value (Vector n a))
instance (Access m a v) => Access m (ParameterPacked a) (ParameterPacked v)
instance (ShuffleMatch m v) => ShuffleMatch m (ParameterPacked v)
instance (Flatten ah al) => Flatten (ParameterPacked ah) (ParameterPacked al)
instance (MakeValueTuple ah al) => MakeValueTuple (ParameterPacked ah) (ParameterPacked al)
instance (IsTuple a) => IsTuple (ParameterPacked a)
instance (ValueTuple a) => ValueTuple (ParameterPacked a)
instance (Memory l s, IsSized s ss) => Memory (ParameterPacked l) (Struct (s, (s, ())))
instance (Zero a) => Zero (ParameterPacked a)
instance (Undefined a) => Undefined (ParameterPacked a)
instance (Phi a) => Phi (ParameterPacked a)
instance Traversable ParameterPacked
instance Foldable ParameterPacked
instance Applicative ParameterPacked
instance Functor ParameterPacked
instance (Access n a v) => Access n (Parameter a) (Parameter v)
instance (ShuffleMatch n v) => ShuffleMatch n (Parameter v)
instance (Flatten ah al) => Flatten (Parameter ah) (Parameter al)
instance (MakeValueTuple ah al) => MakeValueTuple (Parameter ah) (Parameter al)
instance (IsTuple a) => IsTuple (Parameter a)
instance (ValueTuple a) => ValueTuple (Parameter a)
instance (Memory a s, IsSized s ss) => Memory (Parameter a) s
instance (Zero a) => Zero (Parameter a)
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)
instance Traversable Parameter
instance Foldable Parameter
instance Applicative Parameter
instance Functor Parameter


-- | This is like <a>Synthesizer.LLVM.CausalParameterized.Controlled</a>
--   but for vectorised signals.
module Synthesizer.LLVM.CausalParameterized.ControlledPacked

-- | A filter parameter type uniquely selects a filter function. However it
--   does not uniquely determine the input and output type, since the same
--   filter can run on mono and stereo signals.
class C parameter a b | parameter a -> b, parameter b -> a
process :: (C parameter a b) => T p (parameter, a) b
processCtrlRate :: (C parameter av bv, Access n a av, Access n b bv, Memory parameter struct, IsSized struct ss, C r, IsFloating r, Storable r, IsConst r, MakeValueTuple r (Value r), CmpRet r Bool, IsSized r rs) => T p r -> (T p r -> T p parameter) -> T p av bv
instance (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 d, IsPrimitive a, IsSized a as) => C (Parameter (Value a)) (Value (Vector d a)) (Result (Value (Vector d a)))
instance (C a a, IsFirstClass a, IsArithmetic a, IsConst a, MakeValueTuple a (Value a), Storable a, IsPowerOf2 d, IsPrimitive a, IsSized a as, Nat n) => C (Parameter n (Value a)) (Value (Vector d a)) (Value (Vector d a))
instance (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 d, IsPrimitive a, IsSized a as, Nat n) => C (CascadeParameter n (Value a)) (Value (Vector d a)) (Value (Vector d a))
instance (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsPrimitive a, IsSized a as) => C (Parameter (Value a)) (Value (Vector n a)) (Value (Vector n a))
instance (C a, IsPrimitive a, IsSized a as, IsConst a, IsArithmetic a, Nat n, Mul n UnknownSize paramSize, Pos paramSize, IsPowerOf2 d, Mul d as vas, Pos vas) => C (ParameterValue n a) (Value (Vector d a)) (Value (Vector d a))
instance (C a, IsFirstClass a, IsArithmetic a, IsConst a, IsPowerOf2 n, IsPrimitive a, IsSized a as, Mul n as vas, Pos vas) => C (Parameter (Value a)) (Value (Vector n a)) (Value (Vector n a))
instance (C a, IsArithmetic a, IsPrimitive a, IsFirstClass a, IsConst a, IsSized a as, IsPowerOf2 n) => C (Parameter (Value a)) (Value (Vector n a)) (Result (Value (Vector n a)))

module Synthesizer.LLVM.Server.Common
channel :: Channel
sampleRate :: (Num a) => a
latency :: Int
chunkSize :: ChunkSize
lazySize :: LazySize
periodTime :: (C t) => t
type Real = Float
($/) :: (Functor f) => f (a -> b) -> a -> f b
play :: (C t, C y, SampleFmt y) => t -> t -> T y -> IO ()
playAndRecord :: (C t, C y, SampleFmt y, C y) => FilePath -> t -> t -> T y -> IO ()
piecewiseConstant :: (Storable a, MakeValueTuple a al, Memory al am, IsSized am as) => T p (T a) -> T p al
transposeModulation :: (Functor stream) => Real -> stream (BendModulation Real) -> stream (BendModulation Real)
amplitudeFromVelocity :: Real -> Real
makeNote :: NoteEv -> Word8 -> T


-- | Convert MIDI events of a MIDI controller to a control signal.
module Synthesizer.LLVM.ALSA.MIDI
frequencyFromBendModulation :: (C a, IsConst a, C y, C y, IsConst y, IsSized y size, Storable y, MakeValueTuple y (Value y), Fraction y, Replicate a y) => T p y -> T p (BendModulation (Value y)) (Value y)
frequencyFromBendModulationPacked :: (C a, IsConst a, IsFloating a, Storable a, MakeValueTuple a (Value a), IsSized a size, Real a, Replicate a (Vector n a), IsPowerOf2 n, Mul n size vsize, Pos vsize) => T p a -> T p (BendModulation (Value a)) (Value (Vector n a))
type Instrument y yv = Instrument y (T yv)
type Bank y yv = Bank y (T yv)
sequenceCore :: (Storable yv, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> Channel -> Program -> Modulator Note (T yv) -> Filter (T yv)
sequence :: (Storable yv, C y, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> Channel -> Instrument y yv -> Filter (T yv)
sequenceModulated :: (Transform ctrl, NormalForm ctrl, Storable yv, C y, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> ctrl -> Channel -> (ctrl -> Instrument y yv) -> Filter (T yv)
sequenceMultiModulated :: (Storable yv, C y, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> Channel -> instrument -> Modulator (instrument, Note) (Instrument y yv, Note) -> Filter (T yv)
sequenceMultiProgram :: (Storable yv, C y, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> Channel -> Program -> [Instrument y yv] -> Filter (T yv)
sequenceModulatedMultiProgram :: (Transform ctrl, NormalForm ctrl, Storable yv, C y, Additive value, MakeValueTuple yv value, Memory value struct) => ChunkSize -> ctrl -> Channel -> Program -> [ctrl -> Instrument y yv] -> Filter (T yv)
applyModulation :: (Transform signal, NormalForm signal) => signal -> Modulator (signal -> instr, note) (instr, note)
data BendModulation a :: * -> *
BendModulation :: a -> a -> BendModulation a

module Synthesizer.LLVM.Server.Packed.Instrument
type Vector = Vector VectorSize Real
type VectorSize = D4
vectorSize :: Int
vectorChunkSize :: ChunkSize
vectorRate :: (Fractional a) => a
frequencyFromBendModulation :: T p Real -> T p (T (BendModulation Real), Real) -> T p (Value Vector)
stereoFrequenciesFromDetuneBendModulation :: T p Real -> T p (T Real, T (BendModulation Real), Real) -> T p (T (Value Vector))
pingReleaseEnvelope :: IO (Real -> Real -> Real -> LazyTime -> T Vector)
pingRelease :: IO (Real -> Real -> Instrument Real Vector)
pingStereoRelease :: IO (Real -> Real -> Instrument Real (T Vector))
pingStereoReleaseFM :: IO (Real -> Real -> T Real -> T Real -> Real -> Real -> T (BendModulation Real) -> Instrument Real (T Vector))

-- | Square like wave constructed as difference of two phase shifted
--   sawtooth like oscillations.
squareStereoReleaseFM :: IO (Real -> Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
bellStereoFM :: IO (Real -> Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
bellNoiseStereoFM :: IO (Real -> Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
tine :: IO (Real -> Real -> Instrument Real Vector)
tineStereo :: IO (Real -> Real -> Instrument Real (T Vector))
softStringReleaseEnvelope :: IO (Real -> Real -> LazyTime -> T Vector)
softString :: IO (Instrument Real (T Vector))
softStringFM :: IO (T (BendModulation Real) -> Instrument Real (T Vector))
tineStereoFM :: IO (Real -> Real -> T (BendModulation Real) -> Instrument Real (T Vector))
tineControlledFnProc :: T p (T Real) -> T p (T Real) -> T p Real -> T p (T (Value Vector)) (T (Value Vector))
tineControlledProc :: T p (T Real) -> T p (T Real) -> T p Real -> T p (T (Value Vector)) (T (Value Vector))
tineControlledFM :: IO (Real -> Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
fenderProc :: T p (T Real) -> T p (T Real) -> T p (T Real) -> T p Real -> T p (T (Value Vector)) (T (Value Vector))
fenderFM :: IO (Real -> Real -> T Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
tineModulatorBankFM :: IO (Real -> Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
tineBankFM :: IO (Real -> Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))

-- | FM synthesis where the modulator is a resonantly filtered sawtooth.
--   This way we get a sinus-like modulator where the sine frequency (that
--   is, something like the modulation index) can be controlled
--   continously.
resonantFMSynthProc :: T p (T Real) -> T p (T Real) -> T p (T Real) -> T p Real -> T p (T (Value Vector)) (T (Value Vector))
resonantFMSynth :: IO (Real -> Real -> T Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
piecewiseConstantVector :: T p (T Real) -> T p (Value Vector)
softStringDetuneFM :: IO (Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
cosineStringStereoFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
arcSineStringStereoFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
arcTriangleStringStereoFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
arcSquareStringStereoFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
arcSawStringStereoFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
softStringShapeFM :: IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
arcStringStereoFM :: (forall r. Value Vector -> CodeGenFunction r (Value Vector)) -> IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
softStringShapeCore :: (forall r. Value Vector -> Value Vector -> CodeGenFunction r (Value Vector)) -> IO (Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
fmStringStereoFM :: IO (Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
wind :: IO (Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
fadeProcess :: (Num b, IsConst b, IsArithmetic v, Replicate b v) => T p a (Value v) -> T p a (Value v) -> T p (Value v, a) (Value v)
windPhaser :: IO (Real -> T Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
filterSawStereoFM :: IO (Real -> Real -> T Real -> Real -> Real -> T (BendModulation Real) -> Instrument Real (T Vector))

-- | The ADSR curve is composed from three parts: Attack, Decay(+Sustain),
--   Release. Attack starts when the key is pressed and lasts attackTime
--   seconds where it reaches height attackPeak*amplitudeOfVelocity. It
--   should be attackPeak&gt;1 because in the following phase we want to
--   approach 1 from above. Say the curve would approach the limit value L
--   if it would continue after the end of the attack phase, the slope is
--   determined by the halfLife with respect to this upper bound. That is,
--   attackHalfLife is the time in seconds where the attack curve reaches
--   or would reach L/2. After Attack the Decay part starts at the same
--   level and decays to amplitudeOfVelocity. The slope is again a
--   halfLife, that is, decayHalfLife is the time where the curve drops
--   from attackPeak*amplitudeOfVelocity to
--   (attackPeak+1)/2*amplitudeOfVelocity. This phase lasts as long as the
--   key is pressed. If the key is released the curve decays with half life
--   releaseHalfLife.
adsr :: IO (Real -> Real -> Real -> Real -> Real -> Real -> LazyTime -> T Vector)
brass :: IO (Real -> Real -> Real -> Real -> Real -> Real -> T Real -> T Real -> T (BendModulation Real) -> Instrument Real (T Vector))
data SamplePositions
SamplePositions :: Int -> Int -> Int -> Int -> SamplePositions
sampleStart :: SamplePositions -> Int
sampleLength :: SamplePositions -> Int
sampleLoopStart :: SamplePositions -> Int
sampleLoopLength :: SamplePositions -> Int
data SampledSound
SampledSound :: T Real -> SamplePositions -> Real -> SampledSound
sampleData :: SampledSound -> T Real
samplePositions :: SampledSound -> SamplePositions
samplePeriod :: SampledSound -> Real
sampledSound :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundLeaky :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
type SampleInfo = (FilePath, [SamplePositions], Real)
makeSampledSounds :: SampleInfo -> IO [T (BendModulation Real) -> Instrument Real (T Vector)]
tomatensalatPositions :: [SamplePositions]
tomatensalat :: SampleInfo
halPositions :: [SamplePositions]
hal :: SampleInfo
graphentheoriePositions :: [SamplePositions]
graphentheorie :: SampleInfo

module Synthesizer.LLVM.Server.Packed.Test

-- | try to reproduce a space leak
sequencePlain :: IO ()
sequenceLLVM :: IO ()
sequencePitchBendCycle :: IO ()
sequencePitchBendSimple :: IO ()
sequencePitchBend :: IO ()
sequenceModulated :: IO ()
sequenceModulatedLong :: IO ()
sequenceModulatedLongFM :: IO ()
sequenceModulatedRepeat :: IO ()
sequencePress :: IO ()
sampledSoundTest0 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundTest1 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundTest2 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundTest3SpaceLeak :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundTest4NoSpaceLeak :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundTest5LargeSpaceLeak :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundSmallSpaceLeak4 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundSmallSpaceLeak4a :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundNoSmallSpaceLeak3 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
amplifySVL :: Vector Vector -> Vector Vector
sampledSoundNoSmallSpaceLeak2 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundSmallSpaceLeak1 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sampledSoundSmallSpaceLeak0 :: IO (SampledSound -> T (BendModulation Real) -> Instrument Real (T Vector))
sequenceSample :: IO ()
sequenceSample1 :: IO ()
sequenceSample2 :: IO ()
sequenceSample3 :: IO ()
sequenceSample4 :: IO ()
sequenceFM1 :: IO ()
adsr :: IO ()

module Synthesizer.LLVM.Server.Packed.Run
withMIDIEventsMono :: (Double -> Double -> T Real -> IO b) -> (T StrictTime [T] -> T Vector) -> IO b
withMIDIEventsStereo :: (Double -> Double -> T (T Real) -> IO b) -> (T StrictTime [T] -> T (T Vector)) -> IO b
stair :: Real -> Real
frequencyModulation :: IO ()
keyboard :: IO ()
keyboardStereo :: IO ()
keyboardFM :: IO ()
keyboardFMMulti :: IO ()
controllerDetune :: Controller
controllerTimbre0 :: Controller
controllerTimbre1 :: Controller
controllerFilterCutoff :: Controller
controllerFilterResonance :: Controller
controllerGlobal :: Controller
controllerVolume :: Controller
controllerAttack :: Controller
controllerFMDepth2 :: Controller
controllerFMDepth3 :: Controller
controllerFMDepth4 :: Controller
controllerFMPartial1 :: Controller
controllerFMPartial2 :: Controller
controllerFMPartial3 :: Controller
controllerFMPartial4 :: Controller
controllerFMDepth1 :: Controller
keyboardDetuneFMCore :: IO (Channel -> Program -> Filter (T (T Vector)))
keyboardDetuneFM :: IO ()
keyboardFilter :: IO ()

module Synthesizer.LLVM.Server.Scalar.Instrument
pingSig :: T (Real, Real) (Value Real)
ping :: IO (Real -> Real -> T Real)
pingDur :: IO (Instrument Real Real)
pingDurTake :: IO (Instrument Real Real)
dummy :: Instrument Real Real
pingReleaseEnvelope :: IO (Real -> Real -> Real -> LazyTime -> T Real)
pingRelease :: IO (Real -> Real -> Instrument Real Real)
pingStereoRelease :: IO (Real -> Real -> Instrument Real (T Real))
tine :: IO (Real -> Real -> Instrument Real Real)
tineStereo :: IO (Real -> Real -> Instrument Real (T Real))
softStringReleaseEnvelope :: IO (Real -> LazyTime -> T Real)
softString :: IO (Instrument Real (T Real))

module Synthesizer.LLVM.Server.Scalar.Run
withMIDIEvents :: (Double -> Double -> a -> IO b) -> (T StrictTime [T] -> a) -> IO b
pitchBend :: IO ()
frequencyModulation :: IO ()
keyboard :: IO ()
keyboardStereo :: IO ()
keyboardMulti :: IO ()
keyboardStereoMulti :: IO ()

module Synthesizer.LLVM.Server.Scalar.Test
pitchBend0 :: IO ()
pitchBend1 :: IO ()
pitchBend2 :: IO ()
sequencePress :: IO ()

module Synthesizer.LLVM.Simple.Signal
data T a
Cons :: (forall r c. (Phi c) => ioContext -> state -> T r c (a, state)) -> (forall r. ioContext -> CodeGenFunction r state) -> (IO ioContext) -> (ioContext -> IO ()) -> T a
simple :: (Memory state packed, IsSized packed size) => (forall r c. state -> T r c (a, state)) -> (forall r. CodeGenFunction r state) -> T a
map :: (forall r. a -> CodeGenFunction r b) -> T a -> T b
mapAccum :: (Memory s struct, IsSized struct sa) => (forall r. a -> s -> CodeGenFunction r (b, s)) -> (forall r. CodeGenFunction r s) -> T a -> T b
zipWith :: (forall r. a -> b -> CodeGenFunction r c) -> T a -> T b -> T c
zip :: T a -> T b -> T (a, b)

-- | Stretch signal in time by a certain factor.
interpolateConstant :: (Memory a struct, IsSized struct size, C b, IsFloating b, CmpRet b Bool, IsConst b, IsFirstClass b, IsSized b sb) => b -> T a -> T a
mix :: (IsArithmetic a) => T (Value a) -> T (Value a) -> T (Value a)
mixStereo :: (IsArithmetic a) => T (T (Value a)) -> T (T (Value a)) -> T (T (Value a))
envelope :: (IsArithmetic a) => T (Value a) -> T (Value a) -> T (Value a)
envelopeStereo :: (IsArithmetic a) => T (Value a) -> T (T (Value a)) -> T (T (Value a))
amplify :: (IsArithmetic a, IsConst a) => a -> T (Value a) -> T (Value a)
amplifyStereo :: (IsArithmetic a, IsConst a) => a -> T (T (Value a)) -> T (T (Value a))
iterate :: (IsFirstClass a, IsSized a s, IsConst a) => (forall r. Value a -> CodeGenFunction r (Value a)) -> Value a -> T (Value a)
exponential2 :: (C a, IsFirstClass a, IsSized a s, IsArithmetic a, IsConst a) => a -> a -> T (Value a)
osciPlain :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t) => (forall r. Value t -> CodeGenFunction r y) -> Value t -> Value t -> T y
osci :: (IsFirstClass t, IsSized t size, Fraction t, IsConst t) => (forall r. Value t -> CodeGenFunction r y) -> t -> t -> T y
osciSaw :: (C a0, IsConst a0, Replicate a0 a, IsFirstClass a, IsSized a size, Fraction a, IsConst a) => a -> a -> T (Value a)
fromStorableVector :: (Storable a, MakeValueTuple a value, Memory value struct) => Vector a -> T value
fromStorableVectorLazy :: (Storable a, MakeValueTuple a value, Memory value struct) => Vector a -> T value
render :: (Storable a, MakeValueTuple a value, Memory value struct) => Int -> T value -> Vector a
derefChunkPtr :: Importer (Ptr stateStruct -> Word32 -> Ptr struct -> IO Word32)
compileChunky :: (Memory value struct, Memory state stateStruct, IsSized stateStruct stateSize) => (forall r. state -> T r (Value Bool, state) (value, state)) -> (forall r. CodeGenFunction r state) -> IO (FunPtr (IO (Ptr stateStruct)), FunPtr (Ptr stateStruct -> IO ()), FunPtr (Ptr stateStruct -> Word32 -> Ptr struct -> IO Word32))
runChunky :: (Storable a, MakeValueTuple a value, Memory value struct) => ChunkSize -> T value -> IO (Vector a)
renderChunky :: (Storable a, MakeValueTuple a value, Memory value struct) => ChunkSize -> T value -> Vector a

module Synthesizer.LLVM.Simple.Vanilla
iterateVal :: (IsFirstClass a, IsSized a size) => (T a -> T a) -> T a -> T (T a)
iterate :: (Flatten a reg, Memory reg packed, IsSized packed size) => (a -> a) -> (a -> T a)
map :: (a -> b) -> T a -> T b
osciReg :: (C (T t), IsFirstClass t, IsSized t size, Fraction t, IsConst t, IsFirstClass y) => T (T t) (T y) -> Value t -> Value t -> T (Value y)
osciVal :: (C (T t), IsFirstClass t, IsSized t size, Fraction t, IsConst t) => T (T t) y -> T t -> T t -> T y
incPhaseVal :: (Fraction a, IsArithmetic a) => T a -> T a -> T a
osci :: (C t, Flatten t reg, Memory reg struct, IsSized struct size, Fraction t, IsConst t) => T t y -> T t -> t -> T y

module Synthesizer.LLVM.Causal.Process
data T a b
Cons :: (forall r c. (Phi c) => ioContext -> a -> state -> T r c (b, state)) -> (forall r. ioContext -> CodeGenFunction r state) -> (IO ioContext) -> (ioContext -> IO ()) -> T a b
simple :: (Memory state packed, IsSized packed size) => (forall r c. (Phi c) => a -> state -> T r c (b, state)) -> (forall r. CodeGenFunction r state) -> T a b
toSignal :: T () a -> T a
fromSignal :: T a -> T () a
map :: (forall r. a -> CodeGenFunction r b) -> T a b
mapAccum :: (Memory state packed, IsSized packed size) => (forall r. a -> state -> CodeGenFunction r (b, state)) -> (forall r. CodeGenFunction r state) -> T a b
apply :: T a b -> T a -> T b
feedFst :: T a -> T b (a, b)
feedSnd :: T a -> T b (b, a)
applyFst :: T (a, b) c -> T a -> T b c
applySnd :: T (a, b) c -> T b -> T a c
compose :: T a b -> T b c -> T a c
first :: T b c -> T (b, d) (c, d)
mix :: (IsArithmetic a) => T (Value a, Value a) (Value a)
mixStereo :: (IsArithmetic a) => T (T (Value a), T (Value a)) (T (Value a))
envelope :: (IsArithmetic a) => T (Value a, Value a) (Value a)
envelopeStereo :: (IsArithmetic a) => T (Value a, T (Value a)) (T (Value a))
amplify :: (IsArithmetic a, IsConst a) => a -> T (Value a) (Value a)
amplifyStereo :: (IsArithmetic a, IsConst a) => a -> T (T (Value a)) (T (Value a))
applyStorable :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T valueA valueB -> Vector a -> Vector b
derefStartPtr :: Importer (IO (Ptr stateStruct))
derefStopPtr :: Importer (Ptr stateStruct -> IO ())
derefChunkPtr :: Importer (Ptr stateStruct -> Word32 -> Ptr aStruct -> Ptr bStruct -> IO Word32)
compileChunky :: (Memory aValue aStruct, Memory bValue bStruct, Memory state stateStruct, IsSized stateStruct stateSize) => (forall r. aValue -> state -> T r (Value Bool, (Value (Ptr bStruct), state)) (bValue, state)) -> (forall r. CodeGenFunction r state) -> IO (FunPtr (IO (Ptr stateStruct)), FunPtr (Ptr stateStruct -> IO ()), FunPtr (Ptr stateStruct -> Word32 -> Ptr aStruct -> Ptr bStruct -> IO Word32))

-- | This function will not work as expected, since feeding a lazy storable
--   vector to the causal process means that createIOContext creates a
--   StablePtr to an IORef refering to a chunk list. The IORef will be
--   created once for all uses of the generated function of type
--   <tt>(SVL.Vector a -&gt; SVL.Vector b)</tt>. This means that the
--   pointer into the chunks list will conflict. An alternative would be to
--   create the StablePtr in a foreign function that calls back to Haskell.
--   But this way is disallowed for foreign finalizers.
runStorableChunky :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T valueA valueB -> IO (Vector a -> Vector b)
applyStorableChunky :: (Storable a, MakeValueTuple a valueA, Memory valueA structA, Storable b, MakeValueTuple b valueB, Memory valueB structB) => T valueA valueB -> Vector a -> Vector b
instance Arrow T
instance Category T

module Synthesizer.LLVM.Filter.ComplexFirstOrderPacked
data Parameter a
parameter :: (C a, IsPrimitive a, IsConst a, IsFloating a) => Value a -> Value a -> CodeGenFunction r (Parameter a)
causal :: (IsConst a, Arithmetic a, IsSized (Vector D4 a) as) => T (Parameter a, T (Value a)) (T (Value a))
causalP :: (IsConst a, Arithmetic a, IsSized (Vector D4 a) as) => T p (Parameter a, T (Value a)) (T (Value a))
instance (IsPrimitive l, IsSized l s, Add s s s2, Add s2 s s3, Add s3 s s4, Pos s4) => Memory (Parameter l) (Struct (Vector D4 l, (Vector D4 l, ())))
instance (IsPrimitive a) => Undefined (Parameter a)
instance (IsPrimitive a) => Phi (Parameter a)

module Synthesizer.LLVM.Filter.ComplexFirstOrder
data Parameter a
parameter :: (C a, IsConst a, IsFloating a) => Value a -> Value a -> CodeGenFunction r (Parameter (Value a))
causal :: (IsFirstClass a, IsSized a sa, IsConst a, IsFloating a) => T (Parameter (Value a), T (Value a)) (T (Value a))
causalP :: (IsFirstClass a, IsSized a sa, IsConst a, IsFloating a) => T p (Parameter (Value a), T (Value a)) (T (Value a))
instance (Memory l s, IsSized s ss) => Memory (Parameter l) (Struct (s, (s, (s, ()))))
instance (Undefined a) => Undefined (Parameter a)
instance (Phi a) => Phi (Parameter a)


-- | This module provides a type class that automatically selects a filter
--   for a given parameter type. We choose the dependency this way because
--   there may be different ways to specify the filter parameters but there
--   is only one implementation of the filter itself.
module Synthesizer.LLVM.CausalParameterized.Controlled

-- | A filter parameter type uniquely selects a filter function. However it
--   does not uniquely determine the input and output type, since the same
--   filter can run on mono and stereo signals.
class C parameter a b | parameter a -> b, parameter b -> a
process :: (C parameter a b) => T p (parameter, a) b
processCtrlRate :: (C parameter a b, Memory parameter struct, IsSized struct ss, C r, IsFloating r, Storable r, IsConst r, MakeValueTuple r (Value r), CmpRet r Bool, IsSized r rs) => T p r -> (T p r -> T p parameter) -> T p a b
instance (IsConst a, Arithmetic a, IsSized (Vector D4 a) as) => C (Parameter a) (T (Value a)) (T (Value a))
instance (IsFirstClass a, IsSized a sa, IsConst a, IsFloating a) => C (Parameter (Value a)) (T (Value a)) (T (Value a))
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v) => C (Parameter (Value a)) (Value v) (Result (Value v))
instance (C a v, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v, MakeValueTuple a (Value a), MakeValueTuple v (Value v), Storable v, Nat n) => C (Parameter n (Value a)) (Value v) (Value v)
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v, Nat n) => C (CascadeParameter n (Value a)) (Value v) (Value v)
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v) => C (Parameter (Value a)) (Value v) (Value v)
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v, Nat n, Mul n UnknownSize paramSize, Pos paramSize) => C (ParameterValue n a) (Value v) (Value v)
instance (C a, IsConst a, Arithmetic a, IsSized (Vector D4 a) as) => C (Parameter a) (Value a) (Value a)
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v) => C (Parameter (Value a)) (Value v) (Value v)
instance (C a, C (T a) (T v), IsFirstClass a, IsSized a as, IsConst a, IsArithmetic a, IsFirstClass v, IsSized v vs, IsConst v, IsArithmetic v) => C (Parameter (Value a)) (Value v) (Result (Value v))
