-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Series Expressionss API
--   
--   Series expression API for writing programs subjected to the Data Flow
--   Fusion performed by the repa-plugin.
@package repa-series
@version 1.0.0.1

module Data.Array.Repa.Series.Ref

-- | Mutable references.
data Ref a
Ref :: !(IOVector a) -> Ref a

-- | Create a new unboxed reference.
new :: Unbox a => a -> IO (Ref a)

-- | Read from an unboxed reference.
read :: Unbox a => Ref a -> IO a

-- | Write to an unboxed reference.
write :: Unbox a => Ref a -> a -> IO ()

module Data.Array.Repa.Series.Vector

-- | Abstract mutable vector type that supports random access indexing.
--   
--   Use <a>fromUnboxed</a> and <a>toUnboxed</a> to convert to and from
--   regular immutable unboxed vectors.
data Vector a

-- | Take the length of a vector.
length :: Vector a -> Int#

-- | Create a new vector of the given length.
new :: Unbox a => Int# -> IO (Vector a)

-- | Read a value from a vector.
read :: Unbox a => Vector a -> Int# -> IO a

-- | Write a value into a vector.
write :: Unbox a => Vector a -> Int# -> a -> IO ()

-- | Take the first n elements of a vector
take :: Unbox a => Int# -> Vector a -> IO (Vector a)

-- | O(1). Convert from an Unboxed vector.
fromUnboxed :: Unbox a => Vector a -> IO (Vector a)

-- | O(1). Convert to an Unboxed vector.
toUnboxed :: Unbox a => Vector a -> IO (Vector a)
instance (Unbox a, Show a) => Show (Vector a)

module Data.Array.Repa.Series.Series

-- | A <a>Series</a> is an abstract source of element data and is consumed
--   by series processes. The elements of a series must be consumed
--   sequentially, so they don't support random access indexing.
--   
--   The rate parameter <tt>k</tt> represents the abstract length of the
--   series.
data Series k a
Series :: Int# -> !(Vector a) -> Series k a
seriesLength :: Series k a -> Int#
seriesVector :: Series k a -> !(Vector a)

-- | Index into a series.
index :: Unbox a => Series k a -> Int# -> a

-- | Take the length of a series.
length :: Series k a -> Int#

-- | Convert a series to a vector, discarding the rate information.
toVector :: Unbox a => Series k a -> Vector a

-- | Evaluate a series expression, feeding it an unboxed vector.
--   
--   The rate variable <tt>k</tt> represents the length of the series.
runSeries :: Unbox a => Vector a -> (forall k. Series k a -> b) -> b

-- | Evaluate a series expression, feeding it two unboxed vectors of the
--   same length.
runSeries2 :: (Unbox a, Unbox b) => Vector a -> Vector b -> (forall k. Series k a -> Series k b -> c) -> Maybe c

-- | Three!
runSeries3 :: (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> (forall k. Series k a -> Series k b -> Series k c -> d) -> Maybe d

-- | Four!
runSeries4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> (forall k. Series k a -> Series k b -> Series k c -> Series k d -> e) -> Maybe e

module Data.Array.Repa.Series.Sel

-- | Selectors.
data Sel1 k1 k2
Sel1 :: Int# -> !(Vector Bool) -> Sel1 k1 k2
sel1Length :: Sel1 k1 k2 -> Int#
sel1Flags :: Sel1 k1 k2 -> !(Vector Bool)

-- | Create a new selector from a series of flags.
mkSel1 :: Series k1 Bool -> (forall k2. Sel1 k1 k2 -> a) -> a


-- | Fallback implementations of Series operators.
--   
--   Code using these series operators is typically fused and vectorised by
--   the Repa plugin. If this transformation is successful then the
--   resulting GHC Core program will use primitives from the
--   <tt>Data.Array.Repa.Series.Prim</tt> module instead. If the fusion
--   process is not successful then the implementations in this module will
--   be used directly.
module Data.Array.Repa.Series.Fallback

-- | Apply a function to all elements of a series.
map :: (Unbox a, Unbox b) => (a -> b) -> Series k a -> Series k b

-- | Like <a>zipWith</a>, but for equal-length series
map2 :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Series k a -> Series k b -> Series k c

-- | Combine all elements of a series with an associative operator.
fold :: Unbox b => (a -> b -> a) -> a -> Series k b -> a

-- | Combine all elements of a series with an associative operator. The
--   worker function is given the current index into the series.
foldIndex :: Unbox b => (Int# -> a -> b -> a) -> a -> Series k b -> a

-- | Pack elements of a series using a selector.
pack :: Unbox a => Sel1 k1 k2 -> Series k1 a -> Series k2 a


-- | The <tt>repa-plugin</tt> rewrites client code to use these primitives.
--   
--   The plugin will use whatever names are in scope, so if you want to
--   debug your code you can import a different implementation of these
--   primitives into the module to be vectorized.
module Data.Array.Repa.Series.Prim

-- | Primitives needed by the repa-plugin.
data Primitives
Primitives :: (forall k a. Series k a) -> (forall a. Vector a) -> (forall a. Ref a) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> World -> (# World, Ref Int #)) -> (Ref Int -> World -> (# World, Int# #)) -> (Ref Int -> Int# -> World -> World) -> ((# Int#, Int# #) -> World -> (# World, Ref (Int, Int) #)) -> (Ref (Int, Int) -> World -> (# World, (# Int#, Int# #) #)) -> (Ref (Int, Int) -> (# Int#, Int# #) -> World -> World) -> (Int# -> World -> (# World, Vector Int #)) -> (Vector Int -> Int# -> World -> (# World, Int# #)) -> (Vector Int -> Int# -> Int# -> World -> World) -> (Int# -> Vector Int -> World -> (# World, Vector Int #)) -> (forall k a. Series k a -> Int#) -> (Int# -> (Int# -> World -> World) -> World -> World) -> (Ref Int -> Bool -> (Int# -> World -> World) -> World -> World) -> (forall k. Series k Int -> Int# -> World -> (# World, Int# #)) -> (forall k. Series k (Int, Int) -> Int# -> World -> (# World, (# Int#, Int# #) #)) -> Primitives
prim_Series :: Primitives -> forall k a. Series k a
prim_Vector :: Primitives -> forall a. Vector a
prim_Ref :: Primitives -> forall a. Ref a
prim_addInt :: Primitives -> Int# -> Int# -> Int#
prim_subInt :: Primitives -> Int# -> Int# -> Int#
prim_mulInt :: Primitives -> Int# -> Int# -> Int#
prim_divInt :: Primitives -> Int# -> Int# -> Int#
prim_modInt :: Primitives -> Int# -> Int# -> Int#
prim_remInt :: Primitives -> Int# -> Int# -> Int#
prim_eqInt :: Primitives -> Int# -> Int# -> Bool
prim_neqInt :: Primitives -> Int# -> Int# -> Bool
prim_gtInt :: Primitives -> Int# -> Int# -> Bool
prim_geInt :: Primitives -> Int# -> Int# -> Bool
prim_ltInt :: Primitives -> Int# -> Int# -> Bool
prim_leInt :: Primitives -> Int# -> Int# -> Bool
prim_newRefInt :: Primitives -> Int# -> World -> (# World, Ref Int #)
prim_readRefInt :: Primitives -> Ref Int -> World -> (# World, Int# #)
prim_writeRefInt :: Primitives -> Ref Int -> Int# -> World -> World
prim_newRefInt_T2 :: Primitives -> (# Int#, Int# #) -> World -> (# World, Ref (Int, Int) #)
prim_readRefInt_T2 :: Primitives -> Ref (Int, Int) -> World -> (# World, (# Int#, Int# #) #)
prim_writeRefInt_T2 :: Primitives -> Ref (Int, Int) -> (# Int#, Int# #) -> World -> World
prim_newVectorInt :: Primitives -> Int# -> World -> (# World, Vector Int #)
prim_readVectorInt :: Primitives -> Vector Int -> Int# -> World -> (# World, Int# #)
prim_writeVectorInt :: Primitives -> Vector Int -> Int# -> Int# -> World -> World
prim_sliceVectorInt :: Primitives -> Int# -> Vector Int -> World -> (# World, Vector Int #)
prim_rateOfSeries :: Primitives -> forall k a. Series k a -> Int#
prim_loop :: Primitives -> Int# -> (Int# -> World -> World) -> World -> World
prim_guard :: Primitives -> Ref Int -> Bool -> (Int# -> World -> World) -> World -> World
prim_nextInt :: Primitives -> forall k. Series k Int -> Int# -> World -> (# World, Int# #)
prim_nextInt_T2 :: Primitives -> forall k. Series k (Int, Int) -> Int# -> World -> (# World, (# Int#, Int# #) #)

-- | Table of primitives used by the repa-plugin.
primitives :: Primitives

module Data.Array.Repa.Series

-- | A <a>Series</a> is an abstract source of element data and is consumed
--   by series processes. The elements of a series must be consumed
--   sequentially, so they don't support random access indexing.
--   
--   The rate parameter <tt>k</tt> represents the abstract length of the
--   series.
data Series k a
Series :: Int# -> !(Vector a) -> Series k a
seriesLength :: Series k a -> Int#
seriesVector :: Series k a -> !(Vector a)

-- | Abstract mutable vector type that supports random access indexing.
--   
--   Use <a>fromUnboxed</a> and <a>toUnboxed</a> to convert to and from
--   regular immutable unboxed vectors.
data Vector a

-- | O(1). Convert from an Unboxed vector.
fromUnboxed :: Unbox a => Vector a -> IO (Vector a)

-- | O(1). Convert to an Unboxed vector.
toUnboxed :: Unbox a => Vector a -> IO (Vector a)

-- | Evaluate a series expression, feeding it an unboxed vector.
--   
--   The rate variable <tt>k</tt> represents the length of the series.
runSeries :: Unbox a => Vector a -> (forall k. Series k a -> b) -> b

-- | Evaluate a series expression, feeding it two unboxed vectors of the
--   same length.
runSeries2 :: (Unbox a, Unbox b) => Vector a -> Vector b -> (forall k. Series k a -> Series k b -> c) -> Maybe c

-- | Three!
runSeries3 :: (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> (forall k. Series k a -> Series k b -> Series k c -> d) -> Maybe d

-- | Four!
runSeries4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> (forall k. Series k a -> Series k b -> Series k c -> Series k d -> e) -> Maybe e

-- | Selectors.
data Sel1 k1 k2
Sel1 :: Int# -> !(Vector Bool) -> Sel1 k1 k2
sel1Length :: Sel1 k1 k2 -> Int#
sel1Flags :: Sel1 k1 k2 -> !(Vector Bool)

-- | Create a new selector from a series of flags.
mkSel1 :: Series k1 Bool -> (forall k2. Sel1 k1 k2 -> a) -> a

-- | Apply a function to all elements of a series.
map :: (Unbox a, Unbox b) => (a -> b) -> Series k a -> Series k b

-- | Like <a>zipWith</a>, but for equal-length series
map2 :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Series k a -> Series k b -> Series k c

-- | Combine all elements of a series with an associative operator.
fold :: Unbox b => (a -> b -> a) -> a -> Series k b -> a

-- | Combine all elements of a series with an associative operator. The
--   worker function is given the current index into the series.
foldIndex :: Unbox b => (Int# -> a -> b -> a) -> a -> Series k b -> a

-- | Pack elements of a series using a selector.
pack :: Unbox a => Sel1 k1 k2 -> Series k1 a -> Series k2 a

-- | Primitives needed by the repa-plugin.
data Primitives
Primitives :: (forall k a. Series k a) -> (forall a. Vector a) -> (forall a. Ref a) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Int#) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> Int# -> Bool) -> (Int# -> World -> (# World, Ref Int #)) -> (Ref Int -> World -> (# World, Int# #)) -> (Ref Int -> Int# -> World -> World) -> ((# Int#, Int# #) -> World -> (# World, Ref (Int, Int) #)) -> (Ref (Int, Int) -> World -> (# World, (# Int#, Int# #) #)) -> (Ref (Int, Int) -> (# Int#, Int# #) -> World -> World) -> (Int# -> World -> (# World, Vector Int #)) -> (Vector Int -> Int# -> World -> (# World, Int# #)) -> (Vector Int -> Int# -> Int# -> World -> World) -> (Int# -> Vector Int -> World -> (# World, Vector Int #)) -> (forall k a. Series k a -> Int#) -> (Int# -> (Int# -> World -> World) -> World -> World) -> (Ref Int -> Bool -> (Int# -> World -> World) -> World -> World) -> (forall k. Series k Int -> Int# -> World -> (# World, Int# #)) -> (forall k. Series k (Int, Int) -> Int# -> World -> (# World, (# Int#, Int# #) #)) -> Primitives
prim_Series :: Primitives -> forall k a. Series k a
prim_Vector :: Primitives -> forall a. Vector a
prim_Ref :: Primitives -> forall a. Ref a
prim_addInt :: Primitives -> Int# -> Int# -> Int#
prim_subInt :: Primitives -> Int# -> Int# -> Int#
prim_mulInt :: Primitives -> Int# -> Int# -> Int#
prim_divInt :: Primitives -> Int# -> Int# -> Int#
prim_modInt :: Primitives -> Int# -> Int# -> Int#
prim_remInt :: Primitives -> Int# -> Int# -> Int#
prim_eqInt :: Primitives -> Int# -> Int# -> Bool
prim_neqInt :: Primitives -> Int# -> Int# -> Bool
prim_gtInt :: Primitives -> Int# -> Int# -> Bool
prim_geInt :: Primitives -> Int# -> Int# -> Bool
prim_ltInt :: Primitives -> Int# -> Int# -> Bool
prim_leInt :: Primitives -> Int# -> Int# -> Bool
prim_newRefInt :: Primitives -> Int# -> World -> (# World, Ref Int #)
prim_readRefInt :: Primitives -> Ref Int -> World -> (# World, Int# #)
prim_writeRefInt :: Primitives -> Ref Int -> Int# -> World -> World
prim_newRefInt_T2 :: Primitives -> (# Int#, Int# #) -> World -> (# World, Ref (Int, Int) #)
prim_readRefInt_T2 :: Primitives -> Ref (Int, Int) -> World -> (# World, (# Int#, Int# #) #)
prim_writeRefInt_T2 :: Primitives -> Ref (Int, Int) -> (# Int#, Int# #) -> World -> World
prim_newVectorInt :: Primitives -> Int# -> World -> (# World, Vector Int #)
prim_readVectorInt :: Primitives -> Vector Int -> Int# -> World -> (# World, Int# #)
prim_writeVectorInt :: Primitives -> Vector Int -> Int# -> Int# -> World -> World
prim_sliceVectorInt :: Primitives -> Int# -> Vector Int -> World -> (# World, Vector Int #)
prim_rateOfSeries :: Primitives -> forall k a. Series k a -> Int#
prim_loop :: Primitives -> Int# -> (Int# -> World -> World) -> World -> World
prim_guard :: Primitives -> Ref Int -> Bool -> (Int# -> World -> World) -> World -> World
prim_nextInt :: Primitives -> forall k. Series k Int -> Int# -> World -> (# World, Int# #)
prim_nextInt_T2 :: Primitives -> forall k. Series k (Int, Int) -> Int# -> World -> (# World, (# Int#, Int# #) #)

-- | Table of primitives used by the repa-plugin.
primitives :: Primitives
