-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A low-level HTTP library
--   
--   A low-level HTTP library that can be used to build more sophisticated
--   applications on top of it.
--   
--   The design goals are:
--   
--   <ul>
--   <li><i>secure</i> To mitigate denial-of-service attacks, everything is
--   bounded.</li>
--   <li><i>efficient</i> Message bodies are read in chunks, so that they
--   can be processed in constant space.</li>
--   <li><i>universal</i> No framework for streaming <tt>IO</tt> is used.
--   This allows you to build on top of it, using the libraries that fit
--   your purpose.</li>
--   </ul>
@package http-kit
@version 0.5.1

module Network.HTTP.Toolkit.Error
data ToolkitError

-- | The input ended unpexpectedly while reading a message.
UnexpectedEndOfInput :: ToolkitError

-- | The request-line of the message is malformed.
InvalidRequestLine :: ByteString -> ToolkitError

-- | The status-line of the message is malformed.
InvalidStatusLine :: ByteString -> ToolkitError

-- | A header field is malformed.
InvalidHeader :: ToolkitError

-- | The start-line of the message and all header fields together exceed
--   the specified size <a>Limit</a>.
HeaderTooLarge :: ToolkitError

-- | The size of a body chunk exceeds <a>maxChunkSize</a>.
ChunkTooLarge :: ToolkitError

-- | A body chunk is malformed.
InvalidChunk :: ToolkitError
catchOnly :: (Eq e, Exception e) => IO a -> e -> IO a -> IO a
instance Typeable ToolkitError
instance Eq ToolkitError
instance Show ToolkitError
instance Exception ToolkitError

module Network.HTTP.Toolkit.InputStream

-- | An abstraction for input streams that allows to read and unread input.
data InputStream
InputStream :: IO ByteString -> (ByteString -> IO ()) -> InputStream
_read :: InputStream -> IO ByteString
_unread :: InputStream -> ByteString -> IO ()

-- | Create an <a>InputStream</a> from provided <tt>IO</tt> action.
makeInputStream :: IO ByteString -> IO InputStream

-- | Create an <a>InputStream</a> from provided <a>Handle</a>.
inputStreamFromHandle :: Handle -> IO InputStream

-- | Read some input.
readInput :: InputStream -> IO ByteString

-- | Push back some input. The pushed back input will be returned by a
--   later call to <a>readInput</a>.
unreadInput :: InputStream -> ByteString -> IO ()

-- | Read at least the specified number of bytes from the input stream.
readAtLeast :: InputStream -> Int -> IO ByteString


-- | <i>Deprecated: use <a>Network.HTTP.Toolkit.InputStream</a> instead
--   </i>
module Network.HTTP.Toolkit.Connection
type Connection = InputStream

-- | An abstraction for input streams that allows to read and unread input.
data InputStream
InputStream :: IO ByteString -> (ByteString -> IO ()) -> InputStream
_read :: InputStream -> IO ByteString
_unread :: InputStream -> ByteString -> IO ()
makeConnection :: IO ByteString -> IO Connection
connectionFromHandle :: Handle -> IO Connection
connectionRead :: Connection -> IO ByteString
connectionUnread :: Connection -> ByteString -> IO ()
connectionReadAtLeast :: Connection -> Int -> IO ByteString

module Network.HTTP.Toolkit.Header

-- | Message header size limit in bytes.
type Limit = Int

-- | Read start-line and message headers from provided <a>InputStream</a>
--   (see <a>RFC 2616, Section 4.1</a>).
--   
--   Throws:
--   
--   <ul>
--   <li><a>HeaderTooLarge</a> if start-line and headers together exceed
--   the specified size <a>Limit</a></li>
--   <li><a>InvalidHeader</a> if start-line is missing or a header is
--   malformed</li>
--   </ul>
readMessageHeader :: Limit -> InputStream -> IO (ByteString, [Header])

-- | The default message header size limit of 65536 bytes (64 KB).
defaultHeaderSizeLimit :: Limit

-- | Parse header fields according to <a>RFC 2616, Section 4.2</a>.
parseHeaderFields :: [ByteString] -> Maybe [Header]

-- | Send given start-line and message headers.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendHeader :: (ByteString -> IO ()) -> ByteString -> [Header] -> IO ()
readHeaderLines :: Limit -> InputStream -> IO [ByteString]
combineHeaderLines :: [ByteString] -> [ByteString]

module Network.HTTP.Toolkit.Body

-- | A reader for HTTP bodies. It returns chunks of the body as long as
--   there is more data to consume. When the body has been fully consumed,
--   it returns <a>empty</a>.
type BodyReader = IO ByteString
data BodyType

-- | The message has no body.
None :: BodyType

-- | The message has a body. <i>Chunked transfer coding</i> is used to
--   determine the message length (see <a>RFC 2616, Section 3.6.1</a>).
Chunked :: BodyType

-- | The message has a body with a specified length.
Length :: Int -> BodyType

-- | The message has a body. The body length is determined by the server
--   closing the connection. This is only a valid approach for response
--   bodies. It can not be used for request bodies.
Unlimited :: BodyType

-- | Determine the message <a>BodyType</a> from a given list of message
--   headers (as of <a>RFC 2616, Section 4.4</a>).
--   
--   This is only a partial breakdown. Additional rules apply for request
--   and response bodies respectively (see <a>determineRequestBodyType</a>
--   and <a>determineResponseBodyType</a>).
bodyTypeFromHeaders :: [Header] -> Maybe BodyType

-- | Create a <a>BodyReader</a> from provided <a>InputStream</a> and
--   specified <a>BodyType</a>.
--   
--   The first argument is passed to <a>makeChunkedReader</a>.
makeBodyReader :: Bool -> BodyType -> InputStream -> IO BodyReader

-- | Strictly consume all input from provided <a>BodyReader</a>.
consumeBody :: BodyReader -> IO ByteString

-- | Read input from provided <a>BodyReader</a> and wirte it to provided
--   sink until all input has been consumed.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendBody :: (ByteString -> IO ()) -> BodyReader -> IO ()

-- | Create a <a>BodyReader</a> from provided <a>ByteString</a>.
fromByteString :: ByteString -> IO BodyReader

-- | The maximum size of a chunk in bytes when chunked transfer coding is
--   used. The value depends on the <a>bitSize</a> of <a>Int</a>:
--   
--   <ul>
--   <li><tt>2^28</tt> on 32-bit systems</li>
--   <li><tt>2^60</tt> on 64-bit systems</li>
--   </ul>
maxChunkSize :: Int

-- | Create a reader for bodies with chunked transfer coding.
--   
--   If the first argument is <a>True</a> the body is returned raw,
--   including chunk sizes, chunk extensions and trailer.
--   
--   If the first argument is <a>False</a> only the decoded body is
--   returned, chunk extensions and trailer are striped.
--   
--   The reader throws:
--   
--   <ul>
--   <li><a>InvalidChunk</a> if the body is malformed.</li>
--   <li><a>ChunkTooLarge</a> if the size of a chunk exceeds
--   <a>maxChunkSize</a>.</li>
--   </ul>
makeChunkedReader :: Bool -> InputStream -> IO BodyReader

-- | Read size of next body chunk for when chunked transfer coding is used.
--   
--   Throws:
--   
--   <ul>
--   <li><a>ChunkTooLarge</a> if chunk size exceeds
--   <a>maxChunkSize</a>.</li>
--   </ul>
readChunkSize :: InputStream -> IO (Int, ByteString)

-- | Create a reader for bodies with a specified length.
makeLengthReader :: Int -> InputStream -> IO BodyReader

-- | Create a reader for when the body length is determined by the server
--   closing the connection.
makeUnlimitedReader :: InputStream -> IO BodyReader
instance Eq BodyType
instance Show BodyType

module Network.HTTP.Toolkit.Request
type RequestPath = ByteString
data Request a
Request :: Method -> RequestPath -> [Header] -> a -> Request a
requestMethod :: Request a -> Method
requestPath :: Request a -> RequestPath
requestHeaders :: Request a -> [Header]
requestBody :: Request a -> a

-- | Same as <a>readRequestWithLimit</a> with a <a>Limit</a> of
--   <a>defaultHeaderSizeLimit</a>.
readRequest :: Bool -> InputStream -> IO (Request BodyReader)

-- | Read request from provided <a>InputStream</a>.
--   
--   The second argument is passed to <a>makeChunkedReader</a>.
--   
--   Throws:
--   
--   <ul>
--   <li><a>InvalidRequestLine</a> if request-line is malformed.</li>
--   <li><a>HeaderTooLarge</a> if request-line and headers together exceed
--   the specified size <a>Limit</a></li>
--   <li><a>InvalidHeader</a> if request-line is missing or a header is
--   malformed</li>
--   </ul>
readRequestWithLimit :: Limit -> Bool -> InputStream -> IO (Request BodyReader)

-- | Parse request-line (see <a>RFC 2616, Section 5.1</a>).
parseRequestLine :: ByteString -> Maybe (Method, RequestPath)

-- | Send an HTTP request.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendRequest :: (ByteString -> IO ()) -> Request BodyReader -> IO ()

-- | Format request-line.
formatRequestLine :: Method -> RequestPath -> ByteString

-- | Determine the message <a>BodyType</a> from a given list of message
--   headers (as of <a>RFC 2616, Section 4.4</a>).
determineRequestBodyType :: [Header] -> BodyType
instance Eq a => Eq (Request a)
instance Show a => Show (Request a)
instance Functor Request
instance Foldable Request
instance Traversable Request

module Network.HTTP.Toolkit.Response
data Response a
Response :: Status -> [Header] -> a -> Response a
responseStatus :: Response a -> Status
responseHeaders :: Response a -> [Header]
responseBody :: Response a -> a

-- | Same as <a>readResponseWithLimit</a> with a <a>Limit</a> of
--   <a>defaultHeaderSizeLimit</a>.
readResponse :: Bool -> Method -> InputStream -> IO (Response BodyReader)

-- | Read response from provided <a>InputStream</a>.
--   
--   The second argument is passed to <a>makeChunkedReader</a>.
--   
--   The corresponding request <a>Method</a> has to be specified so that
--   the body length can be determined (see <a>RFC 2616, Section 4.4</a>).
--   
--   Throws:
--   
--   <ul>
--   <li><a>InvalidStatusLine</a> if status-line is malformed.</li>
--   <li><a>HeaderTooLarge</a> if status-line and headers together exceed
--   the specified size <a>Limit</a></li>
--   <li><a>InvalidHeader</a> if status-line is missing or a header is
--   malformed</li>
--   </ul>
readResponseWithLimit :: Limit -> Bool -> Method -> InputStream -> IO (Response BodyReader)

-- | Parse status-line (see <a>RFC 2616, Section 6.1</a>).
parseStatusLine :: ByteString -> Maybe Status

-- | Send a simple HTTP response. The provided <a>ByteString</a> is used as
--   the message body. A suitable <tt>Content-Length</tt> header is added
--   to the specified list of headers.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
simpleResponse :: (ByteString -> IO ()) -> Status -> [Header] -> ByteString -> IO ()

-- | Send an HTTP response.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendResponse :: (ByteString -> IO ()) -> (Response BodyReader) -> IO ()

-- | Format status-line.
formatStatusLine :: Status -> ByteString

-- | Determine the message <a>BodyType</a> from a given <a>Method</a>,
--   <a>Status</a>, and list of message headers (as of <a>RFC 2616, Section
--   4.4</a>).
determineResponseBodyType :: Method -> Status -> [Header] -> BodyType
instance Eq a => Eq (Response a)
instance Show a => Show (Response a)
instance Functor Response
instance Foldable Response
instance Traversable Response

module Network.HTTP.Toolkit
data ToolkitError

-- | The input ended unpexpectedly while reading a message.
UnexpectedEndOfInput :: ToolkitError

-- | The request-line of the message is malformed.
InvalidRequestLine :: ByteString -> ToolkitError

-- | The status-line of the message is malformed.
InvalidStatusLine :: ByteString -> ToolkitError

-- | A header field is malformed.
InvalidHeader :: ToolkitError

-- | The start-line of the message and all header fields together exceed
--   the specified size <a>Limit</a>.
HeaderTooLarge :: ToolkitError

-- | The size of a body chunk exceeds <a>maxChunkSize</a>.
ChunkTooLarge :: ToolkitError

-- | A body chunk is malformed.
InvalidChunk :: ToolkitError

-- | An abstraction for input streams that allows to read and unread input.
data InputStream

-- | Create an <a>InputStream</a> from provided <tt>IO</tt> action.
makeInputStream :: IO ByteString -> IO InputStream

-- | Create an <a>InputStream</a> from provided <a>Handle</a>.
inputStreamFromHandle :: Handle -> IO InputStream
type RequestPath = ByteString
data Request a
Request :: Method -> RequestPath -> [Header] -> a -> Request a
requestMethod :: Request a -> Method
requestPath :: Request a -> RequestPath
requestHeaders :: Request a -> [Header]
requestBody :: Request a -> a

-- | Read request from provided <a>InputStream</a>.
--   
--   The second argument is passed to <a>makeChunkedReader</a>.
--   
--   Throws:
--   
--   <ul>
--   <li><a>InvalidRequestLine</a> if request-line is malformed.</li>
--   <li><a>HeaderTooLarge</a> if request-line and headers together exceed
--   the specified size <a>Limit</a></li>
--   <li><a>InvalidHeader</a> if request-line is missing or a header is
--   malformed</li>
--   </ul>
readRequestWithLimit :: Limit -> Bool -> InputStream -> IO (Request BodyReader)

-- | Same as <a>readRequestWithLimit</a> with a <a>Limit</a> of
--   <a>defaultHeaderSizeLimit</a>.
readRequest :: Bool -> InputStream -> IO (Request BodyReader)

-- | Send an HTTP request.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendRequest :: (ByteString -> IO ()) -> Request BodyReader -> IO ()
data Response a
Response :: Status -> [Header] -> a -> Response a
responseStatus :: Response a -> Status
responseHeaders :: Response a -> [Header]
responseBody :: Response a -> a

-- | Read response from provided <a>InputStream</a>.
--   
--   The second argument is passed to <a>makeChunkedReader</a>.
--   
--   The corresponding request <a>Method</a> has to be specified so that
--   the body length can be determined (see <a>RFC 2616, Section 4.4</a>).
--   
--   Throws:
--   
--   <ul>
--   <li><a>InvalidStatusLine</a> if status-line is malformed.</li>
--   <li><a>HeaderTooLarge</a> if status-line and headers together exceed
--   the specified size <a>Limit</a></li>
--   <li><a>InvalidHeader</a> if status-line is missing or a header is
--   malformed</li>
--   </ul>
readResponseWithLimit :: Limit -> Bool -> Method -> InputStream -> IO (Response BodyReader)

-- | Same as <a>readResponseWithLimit</a> with a <a>Limit</a> of
--   <a>defaultHeaderSizeLimit</a>.
readResponse :: Bool -> Method -> InputStream -> IO (Response BodyReader)

-- | Send an HTTP response.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendResponse :: (ByteString -> IO ()) -> (Response BodyReader) -> IO ()

-- | Send a simple HTTP response. The provided <a>ByteString</a> is used as
--   the message body. A suitable <tt>Content-Length</tt> header is added
--   to the specified list of headers.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
simpleResponse :: (ByteString -> IO ()) -> Status -> [Header] -> ByteString -> IO ()

-- | A reader for HTTP bodies. It returns chunks of the body as long as
--   there is more data to consume. When the body has been fully consumed,
--   it returns <a>empty</a>.
type BodyReader = IO ByteString

-- | Read input from provided <a>BodyReader</a> and wirte it to provided
--   sink until all input has been consumed.
--   
--   <i>Note:</i> The first argument to this function is used to send the
--   data. For space efficiency it may be called multiple times.
sendBody :: (ByteString -> IO ()) -> BodyReader -> IO ()

-- | Strictly consume all input from provided <a>BodyReader</a>.
consumeBody :: BodyReader -> IO ByteString
type Connection = InputStream
makeConnection :: IO ByteString -> IO Connection
connectionFromHandle :: Handle -> IO Connection
