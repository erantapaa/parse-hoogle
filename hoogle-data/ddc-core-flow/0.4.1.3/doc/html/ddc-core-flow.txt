-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler data flow compiler.
--   
--   Disciple Core Flow is a Domain Specific Language (DSL) for writing
--   first order data flow programs. This package provides the language
--   definition as a fragment of Disciple Core. It also provides an
--   implementation of the lowering transform which converts data flow
--   programs into imperative nested loop code. The <tt>repa-plugin</tt>
--   package provides a GHC plugin that transforms GHC core programs gained
--   from vanilla Haskell sources. Use this package if you just want to
--   write and run real programs. Alternatively, Disciple Core Flow
--   programs can be transformed directly via the <tt>ddc</tt> or
--   <tt>ddci-core</tt> command line interfaces, but DDC itself doesn't
--   provide full compilation to machine code. Use GHC and the
--   <tt>repa-plugin</tt> for that.
@package ddc-core-flow
@version 0.4.1.3

module DDC.Core.Flow.Prim

-- | Names of things used in Disciple Core Flow.
data Name

-- | User defined variables.
NameVar :: String -> Name

-- | A name generated by modifying some other name `name$mod`
NameVarMod :: Name -> String -> Name

-- | A user defined constructor.
NameCon :: String -> Name

-- | Fragment specific kind constructors.
NameKiConFlow :: KiConFlow -> Name

-- | Fragment specific type constructors.
NameTyConFlow :: TyConFlow -> Name

-- | Fragment specific data constructors.
NameDaConFlow :: DaConFlow -> Name

-- | Concrete series operators.
NameOpConcrete :: OpConcrete -> Name

-- | Control operators.
NameOpControl :: OpControl -> Name

-- | Series operators.
NameOpSeries :: OpSeries -> Name

-- | Store operators.
NameOpStore :: OpStore -> Name

-- | Vector operators.
NameOpVector :: OpVector -> Name

-- | A primitive type constructor.
NamePrimTyCon :: PrimTyCon -> Name

-- | Primitive arithmetic, logic, comparison and bit-wise operators.
NamePrimArith :: PrimArith -> Name

-- | Primitive casting between numeric types.
NamePrimCast :: PrimCast -> Name

-- | Primitive vector operators.
NamePrimVec :: PrimVec -> Name

-- | A boolean literal.
NameLitBool :: Bool -> Name

-- | A natural literal.
NameLitNat :: Integer -> Name

-- | An integer literal.
NameLitInt :: Integer -> Name

-- | A word literal, with the given number of bits precision.
NameLitWord :: Integer -> Int -> Name

-- | A float literal, with the given number of bits precision.
NameLitFloat :: Rational -> Int -> Name

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name

-- | Fragment specific kind constructors.
data KiConFlow
KiConFlowRate :: KiConFlow

-- | Read a kind constructor name.
readKiConFlow :: String -> Maybe KiConFlow

-- | Fragment specific type constructors.
data TyConFlow

-- | <tt>TupleN#</tt> constructor. Tuples.
TyConFlowTuple :: Int -> TyConFlow

-- | <tt>Vector#</tt> constructor. Vectors.
TyConFlowVector :: TyConFlow

-- | <tt>Series#</tt> constructor. Series types.
TyConFlowSeries :: TyConFlow

-- | <tt>Segd#</tt> constructor. Segment Descriptors.
TyConFlowSegd :: TyConFlow

-- | <tt>SelN#</tt> constructor. Selectors.
TyConFlowSel :: Int -> TyConFlow

-- | <tt>Ref#</tt> constructor. References.
TyConFlowRef :: TyConFlow

-- | <tt>World#</tt> constructor. State token used when converting to GHC
--   core.
TyConFlowWorld :: TyConFlow

-- | <tt>RateNat#</tt> constructor. Naturals witnessing a type-level Rate.
TyConFlowRateNat :: TyConFlow

-- | <tt>DownN#</tt> constructor. Rate decimation.
TyConFlowDown :: Int -> TyConFlow

-- | <tt>TailN#</tt> constructor. Rate tail after decimation.
TyConFlowTail :: Int -> TyConFlow

-- | <tt>Process</tt> constructor.
TyConFlowProcess :: TyConFlow

-- | Read a type constructor name.
readTyConFlow :: String -> Maybe TyConFlow

-- | Yield the kind of a primitive type constructor.
kindTyConFlow :: TyConFlow -> Kind Name

-- | Primitive data constructors.
data DaConFlow

-- | <tt>TN</tt> data constructor.
DaConFlowTuple :: Int -> DaConFlow

-- | Read a data constructor name.
readDaConFlow :: String -> Maybe DaConFlow

-- | Yield the type of a data constructor.
typeDaConFlow :: DaConFlow -> Type Name

-- | Series related operators. These operators work on series after the
--   code has been fused. They do not appear in the source program.
data OpConcrete

-- | Project out a component of a tuple, given the tuple arity and index of
--   the desired component.
OpConcreteProj :: Int -> Int -> OpConcrete

-- | Take the rate of a series.
OpConcreteRateOfSeries :: OpConcrete

-- | Take the underlying <tt>Nat</tt> of a <tt>RateNat</tt>.
OpConcreteNatOfRateNat :: OpConcrete

-- | Take some elements from a series.
OpConcreteNext :: Int -> OpConcrete

-- | Decimate the rate of a series.
OpConcreteDown :: Int -> OpConcrete

-- | Take the tail rate of a decimated series.
OpConcreteTail :: Int -> OpConcrete

-- | Read a series operator name.
readOpConcrete :: String -> Maybe OpConcrete

-- | Yield the type of a series operator.
typeOpConcrete :: OpConcrete -> Type Name

-- | Fusable Flow operators that work on Series.
data OpSeries

-- | Replicate a single element into a series.
OpSeriesRep :: OpSeries

-- | Segmented replicate.
OpSeriesReps :: OpSeries

-- | Segmented indices
OpSeriesIndices :: OpSeries

-- | Fill an existing vector from a series.
OpSeriesFill :: OpSeries

-- | Gather (read) elements from a vector.
OpSeriesGather :: OpSeries

-- | Scatter (write) elements into a vector.
OpSeriesScatter :: OpSeries

-- | Make a selector.
OpSeriesMkSel :: Int -> OpSeries

-- | Make a segment descriptor.
OpSeriesMkSegd :: OpSeries

-- | Apply a worker to corresponding elements of some series.
OpSeriesMap :: Int -> OpSeries

-- | Pack a series according to a flags vector.
OpSeriesPack :: OpSeries

-- | Reduce a series with an associative operator, updating an existing
--   accumulator.
OpSeriesReduce :: OpSeries

-- | Segmented fold.
OpSeriesFolds :: OpSeries

-- | Convert vector(s) into series, all with same length with runtime
--   check.
OpSeriesRunProcess :: Int -> OpSeries

-- | Join two series processes.
OpSeriesJoin :: OpSeries

-- | Read a data flow operator name.
readOpSeries :: String -> Maybe OpSeries

-- | Yield the type of a data flow operator, or <a>error</a> if there isn't
--   one.
typeOpSeries :: OpSeries -> Type Name

-- | Control operators.
data OpControl
OpControlLoop :: OpControl
OpControlLoopN :: OpControl
OpControlGuard :: OpControl
OpControlSegment :: OpControl
OpControlSplit :: Int -> OpControl

-- | Read a control operator name.
readOpControl :: String -> Maybe OpControl

-- | Yield the type of a control operator.
typeOpControl :: OpControl -> Type Name

-- | Store operators.
data OpStore

-- | Allocate a new reference.
OpStoreNew :: OpStore

-- | Read from a reference.
OpStoreRead :: OpStore

-- | Write to a reference.
OpStoreWrite :: OpStore

-- | Allocate a new vector (taking a <tt>Nat</tt> for the length)
OpStoreNewVector :: OpStore

-- | Allocate a new vector (taking a <tt>Rate</tt> for the length)
OpStoreNewVectorR :: OpStore

-- | Allocate a new vector (taking a <tt>RateNat</tt> for the length)
OpStoreNewVectorN :: OpStore

-- | Read a packed Vec of values from a Vector buffer.
OpStoreReadVector :: Int -> OpStore

-- | Write a packed Vec of values to a Vector buffer.
OpStoreWriteVector :: Int -> OpStore

-- | Window a target vector to the tail of some rate.
OpStoreTailVector :: Int -> OpStore

-- | Truncate a vector to a smaller length.
OpStoreTruncVector :: OpStore

-- | Read a store operator name.
readOpStore :: String -> Maybe OpStore

-- | Yield the type of a store operator.
typeOpStore :: OpStore -> Type Name

-- | Fusable flow operators that work on Vectors.
data OpVector

-- | Apply worker function to <tt>n</tt> vectors zipped.
OpVectorMap :: Int -> OpVector

-- | Filter a vector according to a predicate.
OpVectorFilter :: OpVector

-- | Associative fold.
OpVectorReduce :: OpVector

-- | Create a new vector from an index function.
OpVectorGenerate :: OpVector

-- | Get a vector's length.
OpVectorLength :: OpVector

-- | Read a data flow operator name.
readOpVector :: String -> Maybe OpVector

-- | Yield the type of a data flow operator, or <a>error</a> if there isn't
--   one.
typeOpVector :: OpVector -> Type Name

-- | Primitive type constructors.
data PrimTyCon :: *

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Yield the kind of a type constructor.
kindPrimTyCon :: PrimTyCon -> Kind Name

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith :: *

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Take the type of a primitive arithmetic operator.
typePrimArith :: PrimArith -> Type Name

-- | Primitive vector operators.
data PrimVec :: *

-- | Negate elements of a vector.
PrimVecNeg :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Add elements of a vector.
PrimVecAdd :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Subtract elements of a vector.
PrimVecSub :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Multiply elements of a vector.
PrimVecMul :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Divide elements of a vector.
PrimVecDiv :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Replicate a scalar into a vector.
PrimVecRep :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Pack multiple scalars into a vector
PrimVecPack :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Extract a single element from a vector.
PrimVecProj :: Int -> Int -> PrimVec
primVecMulti :: PrimVec -> Int
primVecIndex :: PrimVec -> Int

-- | Read multiple elements from memory.
PrimVecGather :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Write multiple elements to memory.
PrimVecScatter :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Take the type of a primitive vector operator.
typePrimVec :: PrimVec -> Type Name

-- | Yield the multiplicity of a vector operator.
multiOfPrimVec :: PrimVec -> Maybe Int

-- | Yield the <tt>PrimVector</tt> that corresponds to a <a>PrimArith</a>
--   of the given multiplicity, if any.
liftPrimArithToVec :: Int -> PrimArith -> Maybe PrimVec

-- | Yield the <a>PrimArith</a> that corresponds to a <tt>PrimVector</tt>,
--   if any.
lowerPrimVecToArith :: PrimVec -> Maybe PrimArith

-- | Primitive cast between two types.
--   
--   The exact set of available casts is determined by the target platform.
--   For example, you can only promote a <tt>Nat#</tt> to a
--   <tt>Word32#</tt> on a 32-bit system. On a 64-bit system the
--   <tt>Nat#</tt> type is 64-bits wide, so casting it to a
--   <tt>Word32#</tt> would be a truncation.
data PrimCast :: *

-- | Convert a value to a new representation with the same precision.
PrimCastConvert :: PrimCast

-- | Promote a value to one of similar or larger width, without loss of
--   precision.
PrimCastPromote :: PrimCast

-- | Truncate a value to a new width, possibly losing precision.
PrimCastTruncate :: PrimCast

-- | Take the type of a primitive cast.
typePrimCast :: PrimCast -> Type Name
instance Pretty Name
instance NFData Name

module DDC.Core.Flow.Transform.Rates.Fail

-- | Why can't rates be inferred?
data Fail

-- | Function is not in a-normal form
FailNotANormalForm :: Fail

-- | Bindings must be unique
FailNamesNotUnique :: Fail

-- | Bindings must be named
FailNoDeBruijnAllowed :: Fail

-- | Function contains letrec
FailRecursiveBindings :: Fail

-- | Function contains letregion
FailLetRegionNotHandled :: Fail

-- | The constraint would require a buffer. User must expicitly buffer.
FailConstraintFilteredLessFiltered :: Name -> Name -> Fail

-- | The constraint would require a buffer. User must expicitly buffer.
FailConstraintFilteredNotUnique :: Name -> Name -> Fail
type LogFailures a = Writer [Fail] a
warn :: Fail -> LogFailures ()
run :: LogFailures a -> (a, [Fail])
instance Show Fail
instance Eq Fail
instance Pretty Fail

module DDC.Core.Flow.Context
data Context

-- | A top-level context associated with a rate that is a parameter of the
--   process. This context isn't created by the process itself.
ContextRate :: Type Name -> Context
contextRate :: Context -> Type Name

-- | A nested context created by a mkSel1# function.
ContextSelect :: Type Name -> Type Name -> Bound Name -> Bind Name -> Context
contextOuterRate :: Context -> Type Name
contextInnerRate :: Context -> Type Name
contextFlags :: Context -> Bound Name
contextSelector :: Context -> Bind Name

-- | A nested context created by a mkSegd# function.
ContextSegment :: Type Name -> Type Name -> Bound Name -> Bind Name -> Context
contextOuterRate :: Context -> Type Name
contextInnerRate :: Context -> Type Name
contextLens :: Context -> Bound Name
contextSegd :: Context -> Bind Name
instance Show Context
instance Eq Context


-- | Short-hands for constructing compound expressions.
module DDC.Core.Flow.Compounds
kRate :: Type Name

-- | Check if some type is a fully applied type of a RateNat
isRateNatType :: Type Name -> Bool

-- | Check if some type is a fully applied type of a Series.
isSeriesType :: Type Name -> Bool

-- | Check is some type is a fully applied type of a Ref.
isRefType :: Type Name -> Bool

-- | Check is some type is a fully applied type of a Vector.
isVectorType :: Type Name -> Bool
tTuple1 :: Type Name -> Type Name
tTuple2 :: Type Name -> Type Name -> Type Name
tTupleN :: [Type Name] -> Type Name
tVector :: Type Name -> Type Name
tSeries :: Type Name -> Type Name -> Type Name
tSegd :: Type Name -> Type Name -> Type Name
tSel1 :: Type Name -> Type Name -> Type Name
tSel2 :: Type Name -> Type Name -> Type Name -> Type Name
tRef :: Type Name -> Type Name
tWorld :: Type Name
tRateNat :: Type Name -> Type Name
tDown :: Int -> Type Name -> Type Name
tTail :: Int -> Type Name -> Type Name
tProcess :: Type Name

-- | Primitive `Void#` type.
tVoid :: Type Name

-- | Primitive `Bool#` type.
tBool :: Type Name

-- | Primitive Nat# type.
tNat :: Type Name

-- | Primitive `Int#` type.
tInt :: Type Name

-- | Primitive `WordN#` type of the given width.
tWord :: Int -> Type Name

-- | Primitive `FloatN#` type of the given width.
tFloat :: Int -> Type Name

-- | Primitive <tt>VecN# a</tt>.
tVec :: Int -> Type Name -> Type Name

-- | A literal <tt>Bool#</tt>
xBool :: Bool -> Exp a Name

-- | A literal <tt>Bool#</tt> data constructor.
dcBool :: Bool -> DaCon Name

-- | A literal <tt>Nat#</tt>
xNat :: Integer -> Exp a Name

-- | A Literal <tt>Nat#</tt> data constructor.
dcNat :: Integer -> DaCon Name

-- | Data constructor for <tt>Tuple1#</tt>
dcTuple1 :: DaCon Name

-- | Construct a <tt>Tuple2#</tt>
xTuple2 :: Type Name -> Type Name -> Exp a Name -> Exp a Name -> Exp a Name

-- | Data constructor for <tt>Tuple2#</tt>
dcTuple2 :: DaCon Name

-- | Data constructor for n-tuples
dcTupleN :: Int -> DaCon Name
xvRep :: Int -> Type Name -> Exp () Name -> Exp () Name
xvProj :: Int -> Int -> Type Name -> Exp () Name -> Exp () Name
xvGather :: Int -> Type Name -> Exp () Name -> Exp () Name -> Exp () Name
xvScatter :: Int -> Type Name -> Exp () Name -> Exp () Name -> Exp () Name -> Exp () Name
xProj :: [Type Name] -> Int -> Exp () Name -> Exp () Name
xRateOfSeries :: TypeF -> TypeF -> ExpF -> ExpF
xNatOfRateNat :: TypeF -> ExpF -> ExpF
xNext :: TypeF -> TypeF -> ExpF -> ExpF -> ExpF
xNextC :: Int -> TypeF -> TypeF -> ExpF -> ExpF -> ExpF
xDown :: Int -> TypeF -> TypeF -> ExpF -> ExpF -> ExpF
xTail :: Int -> TypeF -> TypeF -> ExpF -> ExpF -> ExpF
xLoopN :: TypeF -> ExpF -> ExpF -> ExpF
xGuard :: ExpF -> ExpF -> ExpF -> ExpF
xSegment :: ExpF -> ExpF -> ExpF -> ExpF
xSplit :: Int -> TypeF -> ExpF -> ExpF -> ExpF -> ExpF
xNew :: Type Name -> Exp () Name -> Exp () Name
xRead :: Type Name -> Exp () Name -> Exp () Name
xWrite :: Type Name -> Exp () Name -> Exp () Name -> Exp () Name
xNewVector :: Type Name -> Exp () Name -> Exp () Name
xNewVectorR :: Type Name -> Type Name -> Exp () Name
xNewVectorN :: Type Name -> Type Name -> Exp () Name -> Exp () Name
xReadVector :: Type Name -> Exp () Name -> Exp () Name -> Exp () Name
xReadVectorC :: Int -> Type Name -> Exp () Name -> Exp () Name -> Exp () Name
xWriteVector :: Type Name -> Exp () Name -> Exp () Name -> Exp () Name -> Exp () Name
xWriteVectorC :: Int -> Type Name -> Exp () Name -> Exp () Name -> Exp () Name -> Exp () Name
xTailVector :: Int -> Type Name -> Type Name -> Exp () Name -> Exp () Name -> Exp () Name
xTruncVector :: Type Name -> Exp () Name -> Exp () Name -> Exp () Name

module DDC.Core.Flow.Env

-- | Data type definitions
--   
--   <pre>
--   Type                         Constructors
--   ----                ------------------------------
--   Bool#               True# False#
--   Nat#                0# 1# 2# ...
--   Int#                ... -2i# -1i# 0i# 1i# 2i# ...
--   Tag#                (none, convert from Nat#)
--   Word{8,16,32,64}#   42w8# 123w64# ...
--   Float{32,64}#       (none, convert from Int#)
--   
--   Tuple{2-32}         (T{2-32})
--   Vector              (none, abstract)
--   Series              (none, abstract)
--   </pre>
primDataDefs :: DataDefs Name

-- | Sort environment containing sorts of primitive kinds.
primSortEnv :: Env Name

-- | Kind environment containing kinds of primitive data types.
primKindEnv :: Env Name

-- | Type environment containing types of primitive operators.
primTypeEnv :: Env Name


-- | Language profile for Disciple Core Flow.
module DDC.Core.Flow.Profile

-- | Language profile for Disciple Core Flow.
profile :: Profile Name

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]

-- | Create a new type variable name that is not in the given environment.
freshT :: Env Name -> Bind Name -> State Int Name

-- | Create a new value variable name that is not in the given environment.
freshX :: Env Name -> Bind Name -> State Int Name


-- | Definition for the thread transform.
module DDC.Core.Flow.Transform.Thread

-- | Thread config defines what state token to use, and what functions need
--   to have it threaded though them.
threadConfig :: Config () Name

-- | Wrap the result type of a stateful computation with the state type.
wrapResultType :: Type Name -> Type Name

-- | Wrap the result of a stateful computation with the state token.
wrapResultExp :: Exp (AnTEC () Name) Name -> Exp (AnTEC () Name) Name -> Exp () Name

-- | Make a pattern to unwrap the result of a stateful computation.
unwrapResult :: Name -> Maybe (Bind Name -> [Bind Name] -> Pat Name)

-- | Get the new type for a stateful primop. The new types have a World#
--   token threaded though them, which make them suitable for applying the
--   Thread transform when converting a Core Flow program to a language
--   that needs such state threading (like GHC Core).
threadType :: Name -> Type Name -> Maybe (Type Name)

module DDC.Core.Flow.Exp
type KindEnvF = Env Name
type TypeEnvF = Env Name
type TypeF = Type Name
type ModuleF = Module () Name
type ExpF = Exp () Name
type CastF = Cast () Name
type LetsF = Lets () Name
type AltF = Alt () Name
type PatF = Pat Name
type WitnessF = Witness () Name
type BoundF = Bound Name
type BindF = Bind Name

module DDC.Core.Flow.Transform.Rates.Constraints

-- | Constraint information An equal can have multiple - eg map3 Filtered
--   only has its source input
data Constraint
ConEqual :: [Name] -> Constraint
ConFiltered :: Name -> Constraint
type ConstraintMap = Map Name Constraint
type EquivClass = [Set Name]

-- | Get canonical name for given equivalence class Return original if
--   there is none (for example, a filter with no maps applied would have
--   none since equiv classes are only built from maps)
canonName :: EquivClass -> Name -> Name

-- | Check constraints for a single function body's bindings. The bindings
--   must be in a-normal form.
checkBindConstraints :: [(Name, ExpF)] -> LogFailures (ConstraintMap, EquivClass)
getMaxSize :: ConstraintMap -> EquivClass -> [Name] -> Name -> Name
instance Eq Constraint
instance Show Constraint

module DDC.Core.Flow.Transform.Rates.Graph
type Graph = Map Name [Edge]

-- | Graph for function Each node is a binding, edges are dependencies, and
--   the bool is whether the node's output can be fused or contracted. For
--   example, filter and map dependencies can be contracted, but a fold
--   cannot as it must consume the entire stream before producing output.
type Edge = (Name, Bool)
graphOfBinds :: [(Name, ExpF)] -> [Name] -> Graph

-- | Find topological ordering of DAG Does not check for cycles - really
--   must be a DAG!
graphTopoOrder :: Graph -> [Name]
mergeWeights :: Graph -> Map Name Int -> Graph
traversal :: Graph -> (Edge -> Name -> Int) -> Map Name Int
invertMap :: (Ord k, Ord v) => Map k v -> Map v [k]
mlookup :: Ord k => String -> Map k v -> k -> v

module DDC.Core.Flow.Transform.Rates.SeriesOfVector
seriesOfVectorModule :: ModuleF -> (ModuleF, [(Name, Fail)])

-- | Takes a single function body. Function body must be in a-normal form.
seriesOfVectorFunction :: ExpF -> (ExpF, [Fail])
instance Eq Loop
instance Show Loop

module DDC.Core.Flow.Transform.Concretize

-- | Rewrite operators that use type level rates to ones that use value
--   level ones.
concretizeModule :: Module () Name -> Module () Name


-- | A <a>Procedure</a> is an abstract imperative loop nest. The loops are
--   represented as a separated loop anatomy, to make it easy to
--   incrementally build them from a data flow graph expressed as a
--   <tt>Process</tt>.
module DDC.Core.Flow.Procedure

-- | An imperative procedure made up of some loops.
data Procedure
Procedure :: Name -> [BindF] -> [BindF] -> Nest -> Procedure
procedureName :: Procedure -> Name
procedureParamTypes :: Procedure -> [BindF]
procedureParamValues :: Procedure -> [BindF]
procedureNest :: Procedure -> Nest

-- | A loop nest.
data Nest
NestEmpty :: Nest
NestList :: [Nest] -> Nest
nestList :: Nest -> [Nest]
NestLoop :: Type Name -> [StmtStart] -> [StmtBody] -> Nest -> [StmtEnd] -> Exp () Name -> Nest
nestRate :: Nest -> Type Name
nestStart :: Nest -> [StmtStart]
nestBody :: Nest -> [StmtBody]
nestInner :: Nest -> Nest
nestEnd :: Nest -> [StmtEnd]
nestResult :: Nest -> Exp () Name
NestGuard :: Type Name -> Type Name -> Bound Name -> [StmtBody] -> Nest -> Nest
nestOuterRate :: Nest -> Type Name
nestInnerRate :: Nest -> Type Name
nestFlags :: Nest -> Bound Name
nestBody :: Nest -> [StmtBody]
nestInner :: Nest -> Nest
NestSegment :: Type Name -> Type Name -> Bound Name -> [StmtBody] -> Nest -> Nest
nestOuterRate :: Nest -> Type Name
nestInnerRate :: Nest -> Type Name
nestLength :: Nest -> Bound Name
nestBody :: Nest -> [StmtBody]
nestInner :: Nest -> Nest
data Context

-- | A top-level context associated with a rate that is a parameter of the
--   process. This context isn't created by the process itself.
ContextRate :: Type Name -> Context
contextRate :: Context -> Type Name

-- | A nested context created by a mkSel1# function.
ContextSelect :: Type Name -> Type Name -> Bound Name -> Bind Name -> Context
contextOuterRate :: Context -> Type Name
contextInnerRate :: Context -> Type Name
contextFlags :: Context -> Bound Name
contextSelector :: Context -> Bind Name

-- | A nested context created by a mkSegd# function.
ContextSegment :: Type Name -> Type Name -> Bound Name -> Bind Name -> Context
contextOuterRate :: Context -> Type Name
contextInnerRate :: Context -> Type Name
contextLens :: Context -> Bound Name
contextSegd :: Context -> Bind Name

-- | Statements that can appear at the start of a loop. These initialise
--   accumulators.
data StmtStart

-- | Evaluate a pure expression
StartStmt :: Bind Name -> Exp () Name -> StmtStart
startResultBind :: StmtStart -> Bind Name
startExpression :: StmtStart -> Exp () Name

-- | Allocate a new vector.
StartVecNew :: Name -> Type Name -> Type Name -> StmtStart
startVecNewName :: StmtStart -> Name
startVecNewElemType :: StmtStart -> Type Name
startVecNewRate :: StmtStart -> Type Name

-- | Inititlise a new accumulator.
StartAcc :: Name -> Type Name -> Exp () Name -> StmtStart
startAccName :: StmtStart -> Name
startAccType :: StmtStart -> Type Name
startAccExp :: StmtStart -> Exp () Name

-- | Statements that appear in the body of a loop.
data StmtBody

-- | Evaluate a pure expression.
BodyStmt :: Bind Name -> Exp () Name -> StmtBody

-- | Bind for the result
bodyResultBind :: StmtBody -> Bind Name

-- | Expression to evaluate
bodyExpression :: StmtBody -> Exp () Name

-- | Write to a vector.
BodyVecWrite :: Name -> Type Name -> Exp () Name -> Exp () Name -> StmtBody

-- | Name of the vector.
bodyVecName :: StmtBody -> Name

-- | Type of the element.
bodyVecWriteElemType :: StmtBody -> Type Name

-- | Expression for the index to write to.
bodyVecWriteIx :: StmtBody -> Exp () Name

-- | Expression for the value to write.
bodyVecWriteVal :: StmtBody -> Exp () Name

-- | Read from an accumulator.
BodyAccRead :: Name -> Type Name -> Bind Name -> StmtBody

-- | Name of the accumulator.
--   
--   Name of the accumulator.
bodyAccName :: StmtBody -> Name

-- | Type of the accumulator.
--   
--   Type of the accumulator.
bodyAccType :: StmtBody -> Type Name

-- | Binder for the read value.
bodyAccNameBind :: StmtBody -> Bind Name

-- | Body of an accumulation operation. Writes to the accumulator.
BodyAccWrite :: Name -> Type Name -> Exp () Name -> StmtBody

-- | Name of the accumulator.
--   
--   Name of the accumulator.
bodyAccName :: StmtBody -> Name

-- | Type of the accumulator.
--   
--   Type of the accumulator.
bodyAccType :: StmtBody -> Type Name

-- | Expression to update the accumulator.
bodyAccExp :: StmtBody -> Exp () Name

-- | Statements that appear after a loop to cleanup.
data StmtEnd

-- | Generic ending statements.
EndStmt :: Bind Name -> Exp () Name -> StmtEnd
endBind :: StmtEnd -> Bind Name
endExp :: StmtEnd -> Exp () Name

-- | Read the result of an accumulator.
EndAcc :: Name -> Type Name -> Name -> StmtEnd
endName :: StmtEnd -> Name
endType :: StmtEnd -> Type Name
endAccName :: StmtEnd -> Name

-- | Destructively truncate a vector to its final size.
EndVecTrunc :: Name -> Type Name -> Type Name -> StmtEnd
endVecName :: StmtEnd -> Name
endVecType :: StmtEnd -> Type Name
endVecRate :: StmtEnd -> Type Name
instance Show StmtStart
instance Show StmtBody
instance Show StmtEnd
instance Show Nest
instance Monoid Nest

module DDC.Core.Flow.Transform.Extract

-- | Extract a core module from some stream procedures. This produces
--   vanilla core code again.
extractModule :: ModuleF -> [Procedure] -> ModuleF

-- | Extract code for a whole procedure.
extractProcedure :: Procedure -> (Bind Name, ExpF)

module DDC.Core.Flow.Transform.Melt

-- | Contains binders of variables that have been melted.
data Info
Info :: (Set Name) -> Info

-- | Melt compound data structures in a module.
meltModule :: Module () Name -> (Module () Name, Info)
instance Melt (Alt () Name)
instance Melt (Lets () Name)
instance Melt (Exp () Name)
instance Monoid Info

module DDC.Core.Flow.Process.Operator

-- | An abstract series operator.
--   
--   Each of the constructors holds all the information we need to produce
--   code for that operator.
data Operator

-- | Connect a series from one place to another. These don't come from the
--   source program, but are useful for during code generation.
OpId :: BindF -> TypeF -> BoundF -> TypeF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opElemType :: Operator -> TypeF

-- | Flat replicate.
OpRep :: BindF -> TypeF -> TypeF -> ExpF -> Operator
opResultSeries :: Operator -> BindF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF
opInputExp :: Operator -> ExpF

-- | Segmented replicate.
OpReps :: BindF -> TypeF -> TypeF -> TypeF -> BoundF -> BoundF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF
opSegdBound :: Operator -> BoundF
opInputSeries :: Operator -> BoundF

-- | Segmented indices.
OpIndices :: BindF -> TypeF -> TypeF -> BoundF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opOutputRate :: Operator -> TypeF
opSegdBound :: Operator -> BoundF

-- | Fill a vector with elements from a series.
OpFill :: BindF -> BoundF -> TypeF -> BoundF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opTargetVector :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opElemType :: Operator -> TypeF

-- | Gather elements from a vector into a series.
OpGather :: BindF -> BoundF -> BoundF -> TypeF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opSourceVector :: Operator -> BoundF
opSourceIndices :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Scatter elements from a series into a vector.
OpScatter :: BindF -> BoundF -> BoundF -> BoundF -> TypeF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opTargetVector :: Operator -> BoundF
opSourceIndices :: Operator -> BoundF
opSourceElems :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Apply a function to corresponding elements in several input series of
--   the same rate, producing a new series. This subsumes the regular
--   <a>map</a> operator as well as <a>zipWith</a> like operators where the
--   input lengths are identical.
OpMap :: Int -> BindF -> TypeF -> [BoundF] -> [BindF] -> ExpF -> Operator
opArity :: Operator -> Int
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeriess :: Operator -> [BoundF]
opWorkerParams :: Operator -> [BindF]
opWorkerBody :: Operator -> ExpF

-- | Pack a series according to a selector.
OpPack :: BindF -> TypeF -> BoundF -> TypeF -> TypeF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Reduce the elements of a series into a reference.
OpReduce :: BindF -> BoundF -> TypeF -> BoundF -> ExpF -> BindF -> BindF -> ExpF -> Operator
opResultBind :: Operator -> BindF
opTargetRef :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opZero :: Operator -> ExpF
opWorkerParamAcc :: Operator -> BindF
opWorkerParamElem :: Operator -> BindF
opWorkerBody :: Operator -> ExpF
instance Show Operator

module DDC.Core.Flow.Process.Process

-- | A process is a graph of series operators that read from some parameter
--   series and write to some accumulators.
data Process
Process :: Name -> [BindF] -> [BindF] -> [Context] -> [Operator] -> Process

-- | Name of whole process. This is taken from the function name in the
--   original source code.
processName :: Process -> Name

-- | Type parameters to process. These are the type parameters of the
--   original function.
processParamTypes :: Process -> [BindF]

-- | Value parameters to process. These are the value parameters of the
--   original function.
processParamValues :: Process -> [BindF]

-- | Flow contexts in this process. This contains a ContextRate entry for
--   all the Rate variables in the parameters, along with an entry for all
--   the nested contexts introduced by the process itself.
processContexts :: Process -> [Context]

-- | Flow operators in this process.
processOperators :: Process -> [Operator]

-- | Take the functional type of a process.
typeOfProcess :: Process -> TypeF

module DDC.Core.Flow.Process

-- | A process is a graph of series operators that read from some parameter
--   series and write to some accumulators.
data Process
Process :: Name -> [BindF] -> [BindF] -> [Context] -> [Operator] -> Process

-- | Name of whole process. This is taken from the function name in the
--   original source code.
processName :: Process -> Name

-- | Type parameters to process. These are the type parameters of the
--   original function.
processParamTypes :: Process -> [BindF]

-- | Value parameters to process. These are the value parameters of the
--   original function.
processParamValues :: Process -> [BindF]

-- | Flow contexts in this process. This contains a ContextRate entry for
--   all the Rate variables in the parameters, along with an entry for all
--   the nested contexts introduced by the process itself.
processContexts :: Process -> [Context]

-- | Flow operators in this process.
processOperators :: Process -> [Operator]

-- | Take the functional type of a process.
typeOfProcess :: Process -> TypeF

-- | An abstract series operator.
--   
--   Each of the constructors holds all the information we need to produce
--   code for that operator.
data Operator

-- | Connect a series from one place to another. These don't come from the
--   source program, but are useful for during code generation.
OpId :: BindF -> TypeF -> BoundF -> TypeF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opElemType :: Operator -> TypeF

-- | Flat replicate.
OpRep :: BindF -> TypeF -> TypeF -> ExpF -> Operator
opResultSeries :: Operator -> BindF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF
opInputExp :: Operator -> ExpF

-- | Segmented replicate.
OpReps :: BindF -> TypeF -> TypeF -> TypeF -> BoundF -> BoundF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF
opSegdBound :: Operator -> BoundF
opInputSeries :: Operator -> BoundF

-- | Segmented indices.
OpIndices :: BindF -> TypeF -> TypeF -> BoundF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opOutputRate :: Operator -> TypeF
opSegdBound :: Operator -> BoundF

-- | Fill a vector with elements from a series.
OpFill :: BindF -> BoundF -> TypeF -> BoundF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opTargetVector :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opElemType :: Operator -> TypeF

-- | Gather elements from a vector into a series.
OpGather :: BindF -> BoundF -> BoundF -> TypeF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opSourceVector :: Operator -> BoundF
opSourceIndices :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Scatter elements from a series into a vector.
OpScatter :: BindF -> BoundF -> BoundF -> BoundF -> TypeF -> TypeF -> Operator
opResultBind :: Operator -> BindF
opTargetVector :: Operator -> BoundF
opSourceIndices :: Operator -> BoundF
opSourceElems :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Apply a function to corresponding elements in several input series of
--   the same rate, producing a new series. This subsumes the regular
--   <a>map</a> operator as well as <a>zipWith</a> like operators where the
--   input lengths are identical.
OpMap :: Int -> BindF -> TypeF -> [BoundF] -> [BindF] -> ExpF -> Operator
opArity :: Operator -> Int
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeriess :: Operator -> [BoundF]
opWorkerParams :: Operator -> [BindF]
opWorkerBody :: Operator -> ExpF

-- | Pack a series according to a selector.
OpPack :: BindF -> TypeF -> BoundF -> TypeF -> TypeF -> Operator
opResultSeries :: Operator -> BindF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opOutputRate :: Operator -> TypeF
opElemType :: Operator -> TypeF

-- | Reduce the elements of a series into a reference.
OpReduce :: BindF -> BoundF -> TypeF -> BoundF -> ExpF -> BindF -> BindF -> ExpF -> Operator
opResultBind :: Operator -> BindF
opTargetRef :: Operator -> BoundF
opInputRate :: Operator -> TypeF
opInputSeries :: Operator -> BoundF
opZero :: Operator -> ExpF
opWorkerParamAcc :: Operator -> BindF
opWorkerParamElem :: Operator -> BindF
opWorkerBody :: Operator -> ExpF

module DDC.Core.Flow.Transform.Schedule

-- | Schedule a process into a procedure, producing scalar code.
scheduleScalar :: Process -> Either Error Procedure

-- | Schedule a process kernel into a procedure.
--   
--   A process kernel is a process with the following restricitions: 1) All
--   input series have the same rate. 2) A kernel accumulates data into
--   sinks, rather than allocating new values. 3) A kernel can be scheduled
--   into a single loop.
scheduleKernel :: Lifting -> Process -> Either Error Procedure

-- | Reason a process kernel could not be scheduled into a procedure.
data Error

-- | Process has no rate parameters.
ErrorNoRateParameters :: Error

-- | Process has no series parameters, but there needs to be at least one.
ErrorNoSeriesParameters :: Error

-- | Process has series of different rates, but all series must have the
--   same rate.
ErrorMultipleRates :: Error

-- | Primary rate variable of the process does not match the rate of the
--   paramter series.
ErrorPrimaryRateMismatch :: Error

-- | Cannot lift expression to vector operators.
ErrorCannotLiftExp :: (Exp () Name) -> Error

-- | Cannot lift type to vector type.
ErrorCannotLiftType :: (Type Name) -> Error

-- | Current scheduler does not support this operator.
ErrorUnsupported :: Operator -> Error

-- | Cannot slurp process description from one of the top-level
--   declarations.
ErrorSlurpError :: Error -> Error

-- | Lifting config controls how many elements should be processed per loop
--   iteration.
data Lifting
Lifting :: Int -> Lifting
liftingFactor :: Lifting -> Int

module DDC.Core.Flow.Transform.Slurp

-- | Slurp stream processes from the top level of a module.
slurpProcesses :: Module () Name -> Either Error [Process]

-- | Slurp a stream operator from a let-binding binding. We use this when
--   recovering operators from the source program.
slurpOperator :: Bind Name -> Exp () Name -> Maybe Operator

-- | Check if some binding is a series operator.
isSeriesOperator :: Exp () Name -> Bool

-- | Check if some binding is a vector operator.
isVectorOperator :: Exp () Name -> Bool

module DDC.Core.Flow.Lower

-- | Configuration for the lower transform.
data Config
Config :: Method -> Config
configMethod :: Config -> Method

-- | Config for producing code with just scalar operations.
defaultConfigScalar :: Config

-- | Config for producing code with vector operations, where the loops just
--   handle a size of data which is an even multiple of the vector width.
defaultConfigKernel :: Config

-- | Config for producing code with vector operations, where the loops
--   handle arbitrary data sizes, of any number of elements.
defaultConfigVector :: Config

-- | What lowering method to use.
data Method

-- | Produce sequential scalar code with nested loops.
MethodScalar :: Method

-- | Produce vector kernel code that only processes an even multiple of the
--   vector width.
MethodKernel :: Lifting -> Method
methodLifting :: Method -> Lifting

-- | Try to produce sequential vector code, falling back to scalar code if
--   this is not possible.
MethodVector :: Lifting -> Method
methodLifting :: Method -> Lifting

-- | Lifting config controls how many elements should be processed per loop
--   iteration.
data Lifting
Lifting :: Int -> Lifting
liftingFactor :: Lifting -> Int

-- | Take a module that contains only well formed series processes defined
--   at top-level, and lower them all into procedures.
lowerModule :: Config -> ModuleF -> Either Error ModuleF
instance Eq Method
instance Show Method
instance Eq Config
instance Show Config


-- | Disciple Core Flow is a Domain Specific Language (DSL) for writing
--   first order data flow programs.
module DDC.Core.Flow

-- | Language profile for Disciple Core Flow.
profile :: Profile Name

-- | Lifting config controls how many elements should be processed per loop
--   iteration.
data Lifting
Lifting :: Int -> Lifting
liftingFactor :: Lifting -> Int

-- | Configuration for the lower transform.
data Config
Config :: Method -> Config
configMethod :: Config -> Method

-- | Config for producing code with vector operations, where the loops
--   handle arbitrary data sizes, of any number of elements.
defaultConfigVector :: Config

-- | Config for producing code with vector operations, where the loops just
--   handle a size of data which is an even multiple of the vector width.
defaultConfigKernel :: Config

-- | Config for producing code with just scalar operations.
defaultConfigScalar :: Config

-- | What lowering method to use.
data Method

-- | Produce sequential scalar code with nested loops.
MethodScalar :: Method

-- | Produce vector kernel code that only processes an even multiple of the
--   vector width.
MethodKernel :: Lifting -> Method
methodLifting :: Method -> Lifting

-- | Try to produce sequential vector code, falling back to scalar code if
--   this is not possible.
MethodVector :: Lifting -> Method
methodLifting :: Method -> Lifting

-- | Take a module that contains only well formed series processes defined
--   at top-level, and lower them all into procedures.
lowerModule :: Config -> ModuleF -> Either Error ModuleF

-- | Names of things used in Disciple Core Flow.
data Name

-- | User defined variables.
NameVar :: String -> Name

-- | A name generated by modifying some other name `name$mod`
NameVarMod :: Name -> String -> Name

-- | A user defined constructor.
NameCon :: String -> Name

-- | Fragment specific kind constructors.
NameKiConFlow :: KiConFlow -> Name

-- | Fragment specific type constructors.
NameTyConFlow :: TyConFlow -> Name

-- | Fragment specific data constructors.
NameDaConFlow :: DaConFlow -> Name

-- | Concrete series operators.
NameOpConcrete :: OpConcrete -> Name

-- | Control operators.
NameOpControl :: OpControl -> Name

-- | Series operators.
NameOpSeries :: OpSeries -> Name

-- | Store operators.
NameOpStore :: OpStore -> Name

-- | Vector operators.
NameOpVector :: OpVector -> Name

-- | A primitive type constructor.
NamePrimTyCon :: PrimTyCon -> Name

-- | Primitive arithmetic, logic, comparison and bit-wise operators.
NamePrimArith :: PrimArith -> Name

-- | Primitive casting between numeric types.
NamePrimCast :: PrimCast -> Name

-- | Primitive vector operators.
NamePrimVec :: PrimVec -> Name

-- | A boolean literal.
NameLitBool :: Bool -> Name

-- | A natural literal.
NameLitNat :: Integer -> Name

-- | An integer literal.
NameLitInt :: Integer -> Name

-- | A word literal, with the given number of bits precision.
NameLitWord :: Integer -> Int -> Name

-- | A float literal, with the given number of bits precision.
NameLitFloat :: Rational -> Int -> Name

-- | Fragment specific kind constructors.
data KiConFlow
KiConFlowRate :: KiConFlow

-- | Fragment specific type constructors.
data TyConFlow

-- | <tt>TupleN#</tt> constructor. Tuples.
TyConFlowTuple :: Int -> TyConFlow

-- | <tt>Vector#</tt> constructor. Vectors.
TyConFlowVector :: TyConFlow

-- | <tt>Series#</tt> constructor. Series types.
TyConFlowSeries :: TyConFlow

-- | <tt>Segd#</tt> constructor. Segment Descriptors.
TyConFlowSegd :: TyConFlow

-- | <tt>SelN#</tt> constructor. Selectors.
TyConFlowSel :: Int -> TyConFlow

-- | <tt>Ref#</tt> constructor. References.
TyConFlowRef :: TyConFlow

-- | <tt>World#</tt> constructor. State token used when converting to GHC
--   core.
TyConFlowWorld :: TyConFlow

-- | <tt>RateNat#</tt> constructor. Naturals witnessing a type-level Rate.
TyConFlowRateNat :: TyConFlow

-- | <tt>DownN#</tt> constructor. Rate decimation.
TyConFlowDown :: Int -> TyConFlow

-- | <tt>TailN#</tt> constructor. Rate tail after decimation.
TyConFlowTail :: Int -> TyConFlow

-- | <tt>Process</tt> constructor.
TyConFlowProcess :: TyConFlow

-- | Primitive data constructors.
data DaConFlow

-- | <tt>TN</tt> data constructor.
DaConFlowTuple :: Int -> DaConFlow

-- | Control operators.
data OpControl
OpControlLoop :: OpControl
OpControlLoopN :: OpControl
OpControlGuard :: OpControl
OpControlSegment :: OpControl
OpControlSplit :: Int -> OpControl

-- | Fusable Flow operators that work on Series.
data OpSeries

-- | Replicate a single element into a series.
OpSeriesRep :: OpSeries

-- | Segmented replicate.
OpSeriesReps :: OpSeries

-- | Segmented indices
OpSeriesIndices :: OpSeries

-- | Fill an existing vector from a series.
OpSeriesFill :: OpSeries

-- | Gather (read) elements from a vector.
OpSeriesGather :: OpSeries

-- | Scatter (write) elements into a vector.
OpSeriesScatter :: OpSeries

-- | Make a selector.
OpSeriesMkSel :: Int -> OpSeries

-- | Make a segment descriptor.
OpSeriesMkSegd :: OpSeries

-- | Apply a worker to corresponding elements of some series.
OpSeriesMap :: Int -> OpSeries

-- | Pack a series according to a flags vector.
OpSeriesPack :: OpSeries

-- | Reduce a series with an associative operator, updating an existing
--   accumulator.
OpSeriesReduce :: OpSeries

-- | Segmented fold.
OpSeriesFolds :: OpSeries

-- | Convert vector(s) into series, all with same length with runtime
--   check.
OpSeriesRunProcess :: Int -> OpSeries

-- | Join two series processes.
OpSeriesJoin :: OpSeries

-- | Store operators.
data OpStore

-- | Allocate a new reference.
OpStoreNew :: OpStore

-- | Read from a reference.
OpStoreRead :: OpStore

-- | Write to a reference.
OpStoreWrite :: OpStore

-- | Allocate a new vector (taking a <tt>Nat</tt> for the length)
OpStoreNewVector :: OpStore

-- | Allocate a new vector (taking a <tt>Rate</tt> for the length)
OpStoreNewVectorR :: OpStore

-- | Allocate a new vector (taking a <tt>RateNat</tt> for the length)
OpStoreNewVectorN :: OpStore

-- | Read a packed Vec of values from a Vector buffer.
OpStoreReadVector :: Int -> OpStore

-- | Write a packed Vec of values to a Vector buffer.
OpStoreWriteVector :: Int -> OpStore

-- | Window a target vector to the tail of some rate.
OpStoreTailVector :: Int -> OpStore

-- | Truncate a vector to a smaller length.
OpStoreTruncVector :: OpStore

-- | Fusable flow operators that work on Vectors.
data OpVector

-- | Apply worker function to <tt>n</tt> vectors zipped.
OpVectorMap :: Int -> OpVector

-- | Filter a vector according to a predicate.
OpVectorFilter :: OpVector

-- | Associative fold.
OpVectorReduce :: OpVector

-- | Create a new vector from an index function.
OpVectorGenerate :: OpVector

-- | Get a vector's length.
OpVectorLength :: OpVector

-- | Primitive type constructors.
data PrimTyCon :: *

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith :: *

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Primitive vector operators.
data PrimVec :: *

-- | Negate elements of a vector.
PrimVecNeg :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Add elements of a vector.
PrimVecAdd :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Subtract elements of a vector.
PrimVecSub :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Multiply elements of a vector.
PrimVecMul :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Divide elements of a vector.
PrimVecDiv :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Replicate a scalar into a vector.
PrimVecRep :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Pack multiple scalars into a vector
PrimVecPack :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Extract a single element from a vector.
PrimVecProj :: Int -> Int -> PrimVec
primVecMulti :: PrimVec -> Int
primVecIndex :: PrimVec -> Int

-- | Read multiple elements from memory.
PrimVecGather :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Write multiple elements to memory.
PrimVecScatter :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Primitive cast between two types.
--   
--   The exact set of available casts is determined by the target platform.
--   For example, you can only promote a <tt>Nat#</tt> to a
--   <tt>Word32#</tt> on a 32-bit system. On a 64-bit system the
--   <tt>Nat#</tt> type is 64-bits wide, so casting it to a
--   <tt>Word32#</tt> would be a truncation.
data PrimCast :: *

-- | Convert a value to a new representation with the same precision.
PrimCastConvert :: PrimCast

-- | Promote a value to one of similar or larger width, without loss of
--   precision.
PrimCastPromote :: PrimCast

-- | Truncate a value to a new width, possibly losing precision.
PrimCastTruncate :: PrimCast

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]


-- | Convert a loop expressed with the loopn combinators into a tail
--   recursive loop with accumulators.
--   
--   ASUMPTIONS:
--   
--   <ul>
--   <li>No nested loops. We could support these, but we don't yet.</li>
--   <li>Outer control flow is only defined via the loopn combinators.</li>
--   <li>References don't escape, so they're not stored in data structures
--   or captured in closures.</li>
--   <li>No aliasing of references, so updating ref with a particular name
--   does not affect any other ref.</li>
--   <li>Refs holding loop counters for loopn are not written to by any
--   other statements.</li>
--   </ul>
--   
--   The above assumptions are true for code generated with the lowering
--   transform, but won't be true for general code, and we don't check for
--   violiations of these assumptions.
module DDC.Core.Flow.Transform.Wind

-- | Current information for a reference.
data RefInfo
RefInfo :: Name -> Type Name -> Name -> Int -> RefInfo
refInfoName :: RefInfo -> Name
refInfoType :: RefInfo -> Type Name
refInfoCurrent :: RefInfo -> Name
refInfoVersionNumber :: RefInfo -> Int

-- | Apply the wind transform to a single module.
windModule :: Module () Name -> Module () Name
instance Show Context
