-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Decision Tree Classifiers for hInduce
--   
--   A very simple decision tree construction algorithm; an implementation
--   of <tt>hinduce-classifier</tt>'s <tt>Classifier</tt> class.
@package hinduce-classifier-decisiontree
@version 0.0.0.1


-- | Decision tree learning, used in statistics, data mining and machine
--   learning, uses a decision tree as a predictive model which maps
--   observations about an item to conclusions about the item's target
--   value. In these tree structures, leaves represent class labels and
--   branches represent conjunctions of features that lead to those class
--   labels.
--   
--   In data mining, a decision tree describes data but not decisions;
--   rather the resulting classification tree can be an input for decision
--   making.
--   
--   (<a>https://en.wikipedia.org/wiki/Decision_tree_learning</a>, Dec 6
--   2011)
module Data.HInduce.Classifier.DecisionTree

-- | A decision tree data structure that allows arbitrary numbers of
--   children. It has been proven that a binary tree is equally expressive,
--   but considering that decision trees are a 'white box' model, we do not
--   want to limit ourselves to the binary case because other numbers of
--   children may make more sense to humans.
--   
--   Converting between binary and arbitrary-child trees is feasible
--   though, but probably not very interesting.
data DTree decider branch label
Node :: decider -> [(branch, DTree decider branch label)] -> DTree decider branch label
dDecider :: DTree decider branch label -> decider
dChildren :: DTree decider branch label -> [(branch, DTree decider branch label)]
Leaf :: label -> DTree decider branch label
dLabel :: DTree decider branch label -> label

-- | An algebra on decision trees
data DTreeAlgebra decider branch label a
DTreeAlgebra :: (label -> a) -> (decider -> [(branch, a)] -> a) -> DTreeAlgebra decider branch label a
fleaf :: DTreeAlgebra decider branch label a -> label -> a
fnode :: DTreeAlgebra decider branch label a -> decider -> [(branch, a)] -> a
buildDTree :: (Ord label, Ord branch, Decider decider attr branch) => DeciderGenerator attr decider -> (x -> attr) -> (x -> label) -> [x] -> DTree decider branch label

-- | fold on a DTree
foldD :: DTreeAlgebra dec branch label a -> DTree dec branch label -> a

-- | Render a decision tree to Graphviz Dot format.
toDot :: (Show decider, Show branch, Show label) => DTree decider branch label -> String

-- | <tt>decide</tt> defines the type and semantics of a split. For
--   example, the split "attr &lt;= 20" is created by <tt>DecideOrd
--   20</tt>.
--   
--   For every possible value of type <tt>branch</tt>, an actual tree
--   branch may be created. Allowing many distinct values in
--   <tt>branch</tt> is a bad idea. Too many of these may have little
--   predictive value and exhaust the training database more quickly.
--   
--   <tt>decider</tt>: The representation of the decider <tt>attr</tt>: The
--   data it needs <tt>branch</tt>: The key of that leads to a branch
class Decider decider attr branch | decider -> attr branch
decide :: Decider decider attr branch => decider -> attr -> branch

-- | Decide with Ord
data Ord t => DecideOrd t
DecideOrd :: t -> DecideOrd t

-- | Decide with set ([]) membership, requiring Eq
data Eq t => DecideSet t
DecideSet :: [t] -> DecideSet t

-- | <tt>AutoDecide</tt> is used to generate possible splits based on
--   actual attributes, in a straightforward fashion. Think of AutoDecide
--   as a default implementation for <tt>Decider</tt> generation.
class AutoDecide attr decider | attr -> decider
autoDeciders :: AutoDecide attr decider => [attr] -> [decider]

-- | Decider generator implementation for any ordered data; considers all
--   sensible <tt>(&lt;= pivot)</tt>s.
genOrds :: Ord attr => [attr] -> [DecideOrd attr]

-- | Decider generator for any ordered data; considers all possible
--   <tt>(&lt;= pivot)</tt>s.
genOrdsAvg :: Ord attr => (attr -> attr -> attr) -> [attr] -> [DecideOrd attr]
genPair :: DeciderGenerator attra decidera -> DeciderGenerator attrb deciderb -> DeciderGenerator (attra, attrb) (Either decidera deciderb)
genMany :: DeciderGenerator attr decider -> DeciderGenerator [attr] (Ixd decider)

-- | <tt>avgF a b = (a+b) / 2</tt>, to be used with genOrdsAvg
avgF :: Fractional a => a -> a -> a

-- | <tt>avgI a b = (a+b) <a>div</a> 2</tt>, to be used with genOrdsAvg
avgI :: Integral a => a -> a -> a
instance (Ord t, Show t) => Show (DecideOrd t)
instance (Ord t, Read t) => Read (DecideOrd t)
instance (Eq t, Show t) => Show (DecideSet t)
instance (Eq t, Read t) => Read (DecideSet t)
instance Show decider => Show (Ixd decider)
instance Read decider => Read (Ixd decider)
instance (Show decider, Show branch, Show label) => Show (DTree decider branch label)
instance (Eq decider, Eq branch, Eq label) => Eq (DTree decider branch label)
instance (Show decider, Show branch, Show label) => Convertible (DTree decider branch label) DisplayLatex
instance (Show decider, Show branch, Show label) => Convertible (DTree decider branch label) DisplayText
instance (Decider decider attr branch, Eq branch) => Classifier (DTree decider branch label) attr label
instance (AutoDecide a xa, AutoDecide b xb) => AutoDecide (a, b) (Either xa xb)
instance AutoDecide [Char] (DecideSet [Char])
instance AutoDecide Char (DecideSet Char)
instance Integral a => AutoDecide (Ratio a) (DecideOrd (Ratio a))
instance AutoDecide Integer (DecideOrd Integer)
instance AutoDecide Int (DecideOrd Int)
instance AutoDecide Float (DecideOrd Float)
instance AutoDecide Double (DecideOrd Double)
instance (Decider deca attra branch, Decider decb attrb branch) => Decider (Either deca decb) (attra, attrb) branch
instance Decider decider attr branch => Decider (Ixd decider) [attr] branch
instance Eq attr => Decider (DecideSet attr) attr Bool
instance Ord attr => Decider (DecideOrd attr) attr Bool
