-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalized booleans and numbers
--   
@package Boolean
@version 0.2.3


-- | Some classes for generalized boolean operations.
--   
--   In this design, for if-then-else, equality and inequality tests, the
--   boolean type depends on the value type.
--   
--   I also tried using a unary type constructor class. The class doesn't
--   work for regular booleans, so generality is lost. Also, we'd probably
--   have to wire class constraints in like: <tt>(==*) :: Eq a =&gt; f Bool
--   -&gt; f a -&gt; f a -&gt; f a</tt>, which disallows situations needing
--   additional constraints, e.g., Show.
--   
--   Starting with 0.1.0, this package uses type families. Up to version
--   0.0.2, it used MPTCs with functional dependencies. My thanks to Andy
--   Gill for suggesting &amp; helping with the change.
module Data.Boolean

-- | Generalized boolean class
class Boolean b
true, false :: Boolean b => b
notB :: Boolean b => b -> b
(&&*, ||*) :: Boolean b => b -> b -> b

-- | <a>BooleanOf</a> computed the boolean analog of a specific type.

-- | Types with conditionals
class Boolean (BooleanOf a) => IfB a
ifB :: (IfB a, bool ~ BooleanOf a) => bool -> a -> a -> a

-- | Expression-lifted conditional with condition last
boolean :: (IfB a, bool ~ BooleanOf a) => a -> a -> bool -> a

-- | Point-wise conditional
cond :: (Applicative f, IfB a, bool ~ BooleanOf a) => f bool -> f a -> f a -> f a

-- | Generalized cropping, filling in <a>mempty</a> where the test yields
--   false.
crop :: (Applicative f, Monoid (f a), IfB a, bool ~ BooleanOf a) => f bool -> f a -> f a

-- | Types with equality. Minimum definition: '(==*)'.
class Boolean (BooleanOf a) => EqB a where u /=* v = notB (u ==* v)
(==*, /=*) :: (EqB a, bool ~ BooleanOf a) => a -> a -> bool

-- | Types with inequality. Minimum definition: '(&lt;*)'.
class Boolean (BooleanOf a) => OrdB a where u >* v = v <* u u >=* v = notB (u <* v) u <=* v = v >=* u
(<*, >=*, >*, <=*) :: (OrdB a, bool ~ BooleanOf a) => a -> a -> bool

-- | Variant of <a>min</a> using <a>ifB</a> and '(&lt;=*)'
minB :: (IfB a, OrdB a) => a -> a -> a

-- | Variant of <a>max</a> using <a>ifB</a> and '(&gt;=*)'
maxB :: (IfB a, OrdB a) => a -> a -> a

-- | Variant of <a>min</a> and <a>max</a> using <a>ifB</a> and '(&lt;=*)'
sort2B :: (IfB a, OrdB a) => (a, a) -> (a, a)

-- | A generalized replacement for guards and chained ifs.
guardedB :: (IfB b, bool ~ BooleanOf b) => bool -> [(bool, b)] -> b -> b

-- | A generalized version of a case like control structure.
caseB :: (IfB b, bool ~ BooleanOf b) => a -> [(a -> bool, b)] -> b -> b
instance OrdB a => OrdB (z -> a)
instance EqB a => EqB (z -> a)
instance IfB a => IfB (z -> a)
instance Boolean bool => Boolean (z -> bool)
instance (bool ~ BooleanOf p, bool ~ BooleanOf q, bool ~ BooleanOf r, bool ~ BooleanOf s, IfB p, IfB q, IfB r, IfB s) => IfB (p, q, r, s)
instance (bool ~ BooleanOf p, bool ~ BooleanOf q, bool ~ BooleanOf r, IfB p, IfB q, IfB r) => IfB (p, q, r)
instance (bool ~ BooleanOf p, bool ~ BooleanOf q, IfB p, IfB q) => IfB (p, q)
instance (Boolean (BooleanOf a), BooleanOf a ~ Bool) => IfB [a]
instance OrdB Char
instance EqB Char
instance IfB Char
instance OrdB Bool
instance EqB Bool
instance IfB Bool
instance OrdB Double
instance EqB Double
instance IfB Double
instance OrdB Float
instance EqB Float
instance IfB Float
instance OrdB Integer
instance EqB Integer
instance IfB Integer
instance OrdB Int
instance EqB Int
instance IfB Int
instance Boolean Bool


-- | Author : Alex Horsman (aninhumer) Maintainer : conal@conal.net
--   Stability : experimental
--   
--   Definitions of Prelude function names in terms of their corresponding
--   Data.Boolean generalised implementation. This can then be used as part
--   of a partial or complete Prelude replacement.
--   
--   Also exports ifThenElse for use with RebindableSyntax.
module Data.Boolean.Overload
(&&) :: Boolean a => a -> a -> a
(||) :: Boolean a => a -> a -> a
not :: Boolean a => a -> a
ifThenElse :: IfB a => BooleanOf a -> a -> a -> a
(==) :: EqB a => a -> a -> BooleanOf a
(/=) :: EqB a => a -> a -> BooleanOf a
(<) :: OrdB a => a -> a -> BooleanOf a
(>) :: OrdB a => a -> a -> BooleanOf a
(<=) :: OrdB a => a -> a -> BooleanOf a
(>=) :: OrdB a => a -> a -> BooleanOf a
min :: (IfB a, OrdB a) => a -> a -> a
max :: (IfB a, OrdB a) => a -> a -> a


-- | A generalized version of the class hirarchy for numbers. All functions
--   that would break a potential deep embedding are removed or generalized
--   to support deep embeddings.
--   
--   The class hierarchy for numeric types keeps as close as possible to
--   the <tt>Prelude</tt> hierarchy. A great part of the default
--   implementation and comments are copied and adopted from
--   <tt>Prelude</tt>.
module Data.Boolean.Numbers

-- | An extension of <a>Num</a> that supplies the integer type of a given
--   number type and a way to create that number from the integer.
class Num a => NumB a where type family IntegerOf a
fromIntegerB :: NumB a => IntegerOf a -> a

-- | A deep embedded version of <a>Integral</a>. Integral numbers,
--   supporting integer division.
--   
--   Minimal complete definition is either <a>quotRem</a> and <a>divMod</a>
--   or the other four functions. Besides that <a>toIntegerB</a> always has
--   to be implemented.
class (NumB a, OrdB a) => IntegralB a where quot = fst .: quotRem rem = snd .: quotRem div = fst .: divMod mod = snd .: divMod quotRem = quot ## rem divMod = div ## mod
quot :: IntegralB a => a -> a -> a
rem :: IntegralB a => a -> a -> a
div :: IntegralB a => a -> a -> a
mod :: IntegralB a => a -> a -> a
quotRem :: IntegralB a => a -> a -> (a, a)
divMod :: IntegralB a => a -> a -> (a, a)
toIntegerB :: IntegralB a => a -> IntegerOf a

-- | Deep embedded version of <a>RealFloat</a>. Extracting components of
--   fractions.
--   
--   Minimal complete definition: <a>properFraction</a>, <a>round</a>,
--   <a>floor</a> and <a>ceiling</a>.
class (NumB a, OrdB a, Fractional a) => RealFracB a where truncate = fst . properFraction
properFraction :: (RealFracB a, IntegerOf a ~ IntegerOf b, IntegralB b) => a -> (b, a)
truncate :: (RealFracB a, IntegerOf a ~ IntegerOf b, IntegralB b) => a -> b
round :: (RealFracB a, IntegerOf a ~ IntegerOf b, IntegralB b) => a -> b
ceiling :: (RealFracB a, IntegerOf a ~ IntegerOf b, IntegralB b) => a -> b
floor :: (RealFracB a, IntegerOf a ~ IntegerOf b, IntegralB b) => a -> b

-- | Deep embedded version of <a>RealFloat</a>. Efficient,
--   machine-independent access to the components of a floating-point
--   number.
--   
--   A complete definition has to define all functions.
class (Boolean (BooleanOf a), RealFracB a, Floating a) => RealFloatB a
isNaN :: RealFloatB a => a -> BooleanOf a
isInfinite :: RealFloatB a => a -> BooleanOf a
isNegativeZero :: RealFloatB a => a -> BooleanOf a
isIEEE :: RealFloatB a => a -> BooleanOf a
atan2 :: RealFloatB a => a -> a -> a

-- | Variant of <a>even</a> for generalized booleans.
evenB :: (IfB a, EqB a, IntegralB a) => a -> BooleanOf a

-- | Variant of <a>odd</a> for generalized booleans.
oddB :: (IfB a, EqB a, IntegralB a) => a -> BooleanOf a

-- | Variant of <a>fromIntegral</a> for generalized booleans.
fromIntegralB :: (IntegerOf a ~ IntegerOf b, IntegralB a, NumB b) => a -> b
instance RealFloatB Double
instance RealFracB Double
instance RealFloatB Float
instance RealFracB Float
instance IntegralB Integer
instance IntegralB Int
instance NumB Double
instance NumB Float
instance NumB Integer
instance NumB Int
