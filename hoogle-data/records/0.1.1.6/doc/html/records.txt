-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A flexible record system
--   
--   This package provides a flexible record system which has some novel
--   features:
--   
--   <ul>
--   <li>Using record type families, the type system can be used to
--   describe relationships between field types.</li>
--   <li>Record scheme induction permits the implementation of polymorphic
--   record combinators that work on whole records instead of only a fixed
--   set of fields.</li>
--   <li>Subkind polymorphism for sorts makes it possible to impose varying
--   restrictions on the structure of field types.</li>
--   </ul>
--   
--   For detailed information, please refer to the paper <i>Generic Record
--   Combinators with Static Type Checking</i>.
@package records
@version 0.1.1.6


-- | Record core support.
module Data.Record

-- | The empty record scheme.
data X style

-- | The empty record.
X :: X style

-- | Non-empty record schemes.
data (:&) rec field style

-- | Non-empty records.
(:&) :: !rec style -> !field style -> :& rec field style

-- | The type of record fields.
data (:::) name sort style

-- | Constructs a record field from a name and a value.
(:=) :: !name -> App style sort -> ::: name sort style

-- | The class of name types. For each field name <tt><i>N</i></tt>, there
--   should be a declaration of the following form:
--   
--   <pre>
--   data <i>N</i> = <i>N</i> deriving (Show)
--   </pre>
--   
--   That way, the name can be represented in types by the type constructor
--   <tt><i>N</i></tt>, and in expressions and patterns by the data
--   constructor <tt><i>N</i></tt>. Furthermore, the following instance
--   declaration should be added:
--   
--   <pre>
--   instance Name <i>N</i> where
--   Â 
--       name = <i>N</i>
--   </pre>
--   
--   Such instance declarations allow record combinators to construct
--   value-level representations of names from type-level representations.
class Name name
name :: Name name => name

-- | An instance <tt>Record <i>k</i> <i>r</i></tt> exists if and only if
--   <tt><i>r</i></tt> is a record scheme whose sorts are of the subkind
--   represented by <tt><i>k</i></tt>.
class Kind kind => Record kind rec
fold :: Record kind rec => thing X -> (forall rec name. (Record kind rec, Name name) => All kind (Expander thing rec name)) -> thing rec

-- | Transformations from the definition of a record combinator for some
--   record scheme into its definition for an expanded record scheme.
newtype Expander thing rec name sort
Expander :: (thing rec -> thing (rec :& (name ::: sort))) -> Expander thing rec name sort

-- | An instance <tt>Convertible <i>r</i> <i>r'</i></tt> exists if and only
--   if <tt><i>r</i></tt> and <tt><i>r'</i></tt> are record schemes, and
--   records of a type <tt><i>r</i> <i>s</i></tt> can be converted into
--   records of the type <tt><i>r'</i> <i>s</i></tt>.
class Convertible rec rec'
convert :: Convertible rec rec' => rec style -> rec' style

-- | An instance <tt>Separation <i>r</i> <i>r'</i> <i>n</i> <i>s</i></tt>
--   exists if and only if the following conditions are met:
--   
--   <ul>
--   <li><tt><i>r</i></tt> is a record scheme that contains the name
--   <tt><i>n</i></tt>.</li>
--   <li>The last name-sort pair with the name <tt><i>n</i></tt> contains
--   the sort <tt><i>s</i></tt>.</li>
--   <li>Removing that name-sort pair from <tt><i>r</i></tt> yields
--   <tt><i>r'</i></tt>.</li>
--   </ul>
class Name sepName => Separation rec remain sepName sepSort | rec sepName -> remain sepSort
separate :: Separation rec remain sepName sepSort => rec style -> (remain style, (sepName ::: sepSort) style)
instance [overlap ok] Show (X style)
instance [overlap ok] ((remain :& (name ::: sort)) ~ extRemain, Separation rec remain sepName sepSort) => Separation (rec :& (name ::: sort)) extRemain sepName sepSort
instance [overlap ok] (sort ~ sepSort, Name name) => Separation (rec :& (name ::: sort)) rec name sepSort
instance [overlap ok] (Separation rec remain name' sort', Convertible remain rec') => Convertible rec (rec' :& (name' ::: sort'))
instance [overlap ok] Convertible rec X
instance [overlap ok] (Record kind rec, Name name, Inhabitant kind sort) => Record kind (rec :& (name ::: sort))
instance [overlap ok] Kind kind => Record kind X
instance [overlap ok] (Show name, Show (App style sort)) => Show ((:::) name sort style)
instance [overlap ok] (Show (rec style), Show name, Show (App style sort)) => Show ((:&) rec (name ::: sort) style)


-- | Record combinators built on top of the record core that
--   <a>Data.Record</a> provides.
module Data.Record.Combinators

-- | Fixes the style of a record. When a record is constructed using
--   <tt>X</tt>, <tt>(:&amp;)</tt>, and <tt>(:=)</tt>, the style of this
--   record is not fixed. For example, the most general type of the record
--   
--   <pre>
--   X :&amp; Surname := "Jeltsch" :&amp; Age := 33 :&amp; Room := "HG/2.39"
--   </pre>
--   
--   is
--   
--   <pre>
--   (<a>App</a> style sortSurname ~ String, Num (<a>App</a> style sortAge), <a>App</a> style sortRoom ~ String) =&gt;
--   (X :&amp; Surname ::: sortSurname :&amp; Age ::: sortAge :&amp; Room ::: sortRoom) style
--   </pre>
--   
--   We can fix the style of that record using the expression
--   
--   <pre>
--   X :&amp; Surname := "Jeltsch" :&amp; Age := 33 :&amp; Room := "HG/2.39" `withStyle` <a>Id</a> <a>KindStar</a>
--   </pre>
--   
--   which has the most general type
--   
--   <pre>
--   (Num age) =&gt;
--   (X :&amp; Surname ::: String :&amp; Age ::: age :&amp; Room ::: String) (<a>Id</a> <a>KindStar</a>)
--   </pre>
--   
--   The <tt>withStyle</tt> combinator is similar to <a>asTypeOf</a>.
withStyle :: Record (Domain style) rec => rec style -> style -> rec style

-- | Looks up the value of a record field.
(!!!) :: Separation rec remain sepName sepSort => rec style -> sepName -> App style sepSort

-- | Removes a record field.
(\\\) :: Separation rec remain sepName sepSort => rec style -> sepName -> remain style

-- | Catenation of two record schemes.

-- | Catenation of two records.
cat :: (TypeFun style, Record (Domain style) rec1, Record (Domain style) rec2) => rec1 style -> rec2 style -> Cat rec1 rec2 style

-- | Generates a record whose fields all contain the same value. In
--   contrast to the <a>repeat</a> function from the Prelude, this function
--   generates a finite data structure. Thereby, the size of the generated
--   record is determined by its type. <tt>repeat</tt> is almost a proper
--   implementation of <a>pure</a> from the <a>Applicative</a> class.
repeat :: (TypeFun style, Record (Domain style) rec) => Universal style -> rec style

-- | Merges a record of functions and a record of arguments by applying the
--   functions to the corresponding arguments. The
--   <tt>(&lt;&lt;*&gt;&gt;)</tt> function is almost a proper
--   implementation of <tt>(&lt;*&gt;)</tt> from the <a>Applicative</a>
--   class.
(<<*>>) :: (TypeFun style, TypeFun style', (Domain style) ~ (Domain style'), Record (Domain (style :-> style')) rec) => rec (style :-> style') -> rec style -> rec style'

-- | Transforms a record by applying a function to all its field values.
map :: (TypeFun style, TypeFun style', (Domain style) ~ (Domain style'), Record (Domain (style :-> style')) rec) => Universal (style :-> style') -> rec style -> rec style'

-- | Merges two records by applying a function to each pair of
--   corresponding field values.
zipWith :: (TypeFun style1, TypeFun style2, TypeFun style', (Domain style1) ~ (Domain style2), (Domain style2) ~ (Domain style'), Record (Domain (style1 :-> (style2 :-> style'))) rec) => Universal (style1 :-> (style2 :-> style')) -> rec style1 -> rec style2 -> rec style'

-- | Modifies a record by changing some of its field values. The first
--   argument of <tt>modify</tt> is called the modification record, and the
--   second argument is called the data record. The result is formed by
--   applying each field value of the modification record to the
--   corresponding field value of the data record and replacing the latter
--   by the result of the application. Data record fields that have no
--   corresponding field in the modification record are left unchanged.
modify :: (TypeFun style, Record (Domain style) rec, Record (Domain style) modRec, Convertible rec modRec) => modRec (style :-> style) -> rec style -> rec style

-- | Overwrites the values of multiple record fields. The first argument is
--   the source record, and the second argument lists the names of the
--   fields to be modified together with their new values.
(///) :: (TypeFun style, Record (Domain style) rec, Record (Domain style) replRec, Convertible rec replRec) => rec style -> replRec style -> rec style

-- | Converts a record whose style is a constant function into the list of
--   its field values.
toList :: (Kind kind, Record kind rec) => rec (Const kind val) -> [val]
