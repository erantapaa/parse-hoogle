-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell URI parsing as ByteStrings
--   
@package uri-bytestring
@version 0.1.6


-- | URI.ByteString aims to be an RFC3986 compliant URI parser that uses
--   efficient ByteStrings for parsing and representing the data. This
--   module provides a URI datatype as well as a parser and serializer.
--   
--   Note that this library is an early release and may have issues. It is
--   currently being used in production and no issues have been
--   encountered, however. Please report any issues encountered to the
--   issue tracker.
--   
--   This module also provides analogs to Lens over the various types in
--   this library. These are written in a generic way to avoid a dependency
--   on any particular lens library. You should be able to use these with a
--   number of packages including lens and lens-family-core.
module URI.ByteString

-- | Required first component to referring to a specification for the
--   remainder of the URI's components, e.g. "http" or "https"
newtype Scheme
Scheme :: ByteString -> Scheme
schemeBS :: Scheme -> ByteString
newtype Host
Host :: ByteString -> Host
hostBS :: Host -> ByteString

-- | While some libraries have chosen to limit this to a Word16, the spec
--   only specifies that the string be comprised of digits.
newtype Port
Port :: Int -> Port
portNumber :: Port -> Int
data Authority
Authority :: Maybe UserInfo -> Host -> Maybe Port -> Authority
authorityUserInfo :: Authority -> Maybe UserInfo
authorityHost :: Authority -> Host
authorityPort :: Authority -> Maybe Port
data UserInfo
UserInfo :: ByteString -> ByteString -> UserInfo
uiUsername :: UserInfo -> ByteString
uiPassword :: UserInfo -> ByteString
newtype Query
Query :: [(ByteString, ByteString)] -> Query
queryPairs :: Query -> [(ByteString, ByteString)]
data URI
URI :: Scheme -> Maybe Authority -> ByteString -> Query -> Maybe ByteString -> URI
uriScheme :: URI -> Scheme
uriAuthority :: URI -> Maybe Authority
uriPath :: URI -> ByteString
uriQuery :: URI -> Query

-- | URI fragment. Does not include the #
uriFragment :: URI -> Maybe ByteString
data RelativeRef
RelativeRef :: Maybe Authority -> ByteString -> Query -> Maybe ByteString -> RelativeRef
rrAuthority :: RelativeRef -> Maybe Authority
rrPath :: RelativeRef -> ByteString
rrQuery :: RelativeRef -> Query

-- | URI fragment. Does not include the #
rrFragment :: RelativeRef -> Maybe ByteString

-- | URI Parser Types
data SchemaError

-- | Scheme must start with an alphabet character
NonAlphaLeading :: SchemaError

-- | Subsequent characters in the schema were invalid
InvalidChars :: SchemaError

-- | Schemas must be followed by a colon
MissingColon :: SchemaError
data URIParseError
MalformedScheme :: SchemaError -> URIParseError
MalformedUserInfo :: URIParseError
MalformedQuery :: URIParseError
MalformedFragment :: URIParseError
MalformedHost :: URIParseError
MalformedPort :: URIParseError
MalformedPath :: URIParseError

-- | Catchall for unpredictable errors
OtherError :: String -> URIParseError

-- | Options for the parser. You will probably want to use either
--   "strictURIParserOptions" or "laxURIParserOptions"
data URIParserOptions
URIParserOptions :: (Word8 -> Bool) -> URIParserOptions
upoValidQueryChar :: URIParserOptions -> Word8 -> Bool

-- | Strict URI Parser config. Follows RFC3986 as-specified. Use this if
--   you can be certain that your URIs are properly encoded or if you want
--   parsing to fail if they deviate from the spec at all.
strictURIParserOptions :: URIParserOptions

-- | Lax URI Parser config. Use this if you you want to handle common
--   deviations from the spec gracefully.
--   
--   <ul>
--   <li>Allows non-encoded [ and ] in query string</li>
--   </ul>
laxURIParserOptions :: URIParserOptions

-- | Parse a strict ByteString into a URI or an error.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; parseURI strictURIParserOptions "http://www.example.org/foo?bar=baz#quux"
--   Right (URI {uriScheme = Scheme {schemeBS = "http"}, uriAuthority = Just (Authority {authorityUserInfo = Nothing, authorityHost = Host {hostBS = "www.example.org"}, authorityPort = Nothing}), uriPath = "/foo", uriQuery = Query {queryPairs = [("bar","baz")]}, uriFragment = Just "quux"})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseURI strictURIParserOptions "$$$$://badurl.example.org"
--   Left (MalformedScheme NonAlphaLeading)
--   </pre>
--   
--   There are some urls that you'll encounter which defy the spec, such as
--   those with square brackets in the query string. If you must be able to
--   parse those, you can use "laxURIParserOptions" or specify your own
--   
--   <pre>
--   &gt;&gt;&gt; parseURI strictURIParserOptions "http://www.example.org/foo?bar[]=baz"
--   Left MalformedQuery
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseURI laxURIParserOptions "http://www.example.org/foo?bar[]=baz"
--   Right (URI {uriScheme = Scheme {schemeBS = "http"}, uriAuthority = Just (Authority {authorityUserInfo = Nothing, authorityHost = Host {hostBS = "www.example.org"}, authorityPort = Nothing}), uriPath = "/foo", uriQuery = Query {queryPairs = [("bar[]","baz")]}, uriFragment = Nothing})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let myLaxOptions = URIParserOptions { upoValidQueryChar = liftA2 (||) (upoValidQueryChar strictURIParserOptions) (inClass "[]")}
--   
--   &gt;&gt;&gt; parseURI myLaxOptions "http://www.example.org/foo?bar[]=baz"
--   Right (URI {uriScheme = Scheme {schemeBS = "http"}, uriAuthority = Just (Authority {authorityUserInfo = Nothing, authorityHost = Host {hostBS = "www.example.org"}, authorityPort = Nothing}), uriPath = "/foo", uriQuery = Query {queryPairs = [("bar[]","baz")]}, uriFragment = Nothing})
--   </pre>
parseURI :: URIParserOptions -> ByteString -> Either URIParseError URI

-- | Like <a>parseURI</a>, but do not parse scheme.
parseRelativeRef :: URIParserOptions -> ByteString -> Either URIParseError RelativeRef

-- | URI Serializer
--   
--   Serialize a URI into a strict ByteString Example:
--   
--   <pre>
--   &gt;&gt;&gt; BB.toLazyByteString $ serializeURI $ URI {uriScheme = Scheme {schemeBS = "http"}, uriAuthority = Just (Authority {authorityUserInfo = Nothing, authorityHost = Host {hostBS = "www.example.org"}, authorityPort = Nothing}), uriPath = "/foo", uriQuery = Query {queryPairs = [("bar","baz")]}, uriFragment = Just "quux"}
--   "http://www.example.org/foo?bar=baz#quux"
--   </pre>
serializeURI :: URI -> Builder

-- | Like <a>serializeURI</a>, but do not render scheme.
serializeRelativeRef :: RelativeRef -> Builder

-- | <pre>
--   schemeBSL :: Lens' <a>Scheme</a> <a>ByteString</a>
--   </pre>
schemeBSL :: Functor f => (ByteString -> f ByteString) -> Scheme -> f Scheme

-- | <pre>
--   hostBSL :: Lens' <a>Host</a> <a>ByteString</a>
--   </pre>
hostBSL :: Functor f => (ByteString -> f ByteString) -> Host -> f Host

-- | <pre>
--   portNumberL :: Lens' <a>Port</a> <a>Int</a>
--   </pre>
portNumberL :: Functor f => (Int -> f Int) -> Port -> f Port

-- | <pre>
--   authorityUserInfoL :: Lens' <a>Authority</a> (<a>Maybe</a> <a>UserInfo</a>)
--   </pre>
authorityUserInfoL :: Functor f => (Maybe UserInfo -> f (Maybe UserInfo)) -> Authority -> f Authority

-- | <pre>
--   authorityHostL :: Lens' <a>Authority</a> <a>Host</a>
--   </pre>
authorityHostL :: Functor f => (Host -> f Host) -> Authority -> f Authority

-- | <pre>
--   authorityPortL :: Lens' <a>Authority</a> (<a>Maybe</a> <a>Port</a>)
--   </pre>
authorityPortL :: Functor f => (Maybe Port -> f (Maybe Port)) -> Authority -> f Authority

-- | <pre>
--   uiUsernameL :: Lens' <a>UserInfo</a> <a>ByteString</a>
--   </pre>
uiUsernameL :: Functor f => (ByteString -> f ByteString) -> UserInfo -> f UserInfo

-- | <pre>
--   uiPasswordL :: Lens' <a>UserInfo</a> <a>ByteString</a>
--   </pre>
uiPasswordL :: Functor f => (ByteString -> f ByteString) -> UserInfo -> f UserInfo

-- | <pre>
--   queryPairsL :: Lens' <a>Query</a> [(<a>ByteString</a>, <a>ByteString</a>)]
--   </pre>
queryPairsL :: Functor f => ([(ByteString, ByteString)] -> f [(ByteString, ByteString)]) -> Query -> f Query

-- | <pre>
--   uriSchemeL :: Lens' <a>URI</a> <a>Scheme</a>
--   </pre>
uriSchemeL :: Functor f => (Scheme -> f Scheme) -> URI -> f URI

-- | <pre>
--   uriAuthorityL :: Lens' <a>URI</a> (<a>Maybe</a> <a>Authority</a>)
--   </pre>
uriAuthorityL :: Functor f => (Maybe Authority -> f (Maybe Authority)) -> URI -> f URI

-- | <pre>
--   uriPathL :: Lens' <a>URI</a> <a>ByteString</a>
--   </pre>
uriPathL :: Functor f => (ByteString -> f ByteString) -> URI -> f URI

-- | <pre>
--   uriQueryL :: Lens' <a>URI</a> <a>Query</a>
--   </pre>
uriQueryL :: Functor f => (Query -> f Query) -> URI -> f URI

-- | <pre>
--   uriFragmentL :: Lens' <a>URI</a> (<a>Maybe</a> <a>ByteString</a>)
--   </pre>
uriFragmentL :: Functor f => (Maybe ByteString -> f (Maybe ByteString)) -> URI -> f URI

-- | <pre>
--   rrAuthorityL :: Lens' <a>RelativeRef</a> (<a>Maybe</a> <a>Authority</a>)
--   </pre>
rrAuthorityL :: Functor f => (Maybe Authority -> f (Maybe Authority)) -> RelativeRef -> f RelativeRef

-- | <pre>
--   rrPathL :: Lens' <a>RelativeRef</a> <a>ByteString</a>
--   </pre>
rrPathL :: Functor f => (ByteString -> f ByteString) -> RelativeRef -> f RelativeRef

-- | <pre>
--   rrQueryL :: Lens' <a>RelativeRef</a> <a>Query</a>
--   </pre>
rrQueryL :: Functor f => (Query -> f Query) -> RelativeRef -> f RelativeRef

-- | <pre>
--   rrFragmentL :: Lens' <a>RelativeRef</a> (<a>Maybe</a> <a>ByteString</a>)
--   </pre>
rrFragmentL :: Functor f => (Maybe ByteString -> f (Maybe ByteString)) -> RelativeRef -> f RelativeRef

-- | <pre>
--   upoValidQueryCharL :: Lens' URIParserOptions (Word8 -&gt; Bool)
--   </pre>
upoValidQueryCharL :: Functor f => ((Word8 -> Bool) -> f (Word8 -> Bool)) -> URIParserOptions -> f URIParserOptions
