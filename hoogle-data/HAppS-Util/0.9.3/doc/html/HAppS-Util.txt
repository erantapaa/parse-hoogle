-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Web framework
--   
--   Web framework
@package HAppS-Util
@version 0.9.3

module HAppS.Util.TH
instanceD' :: CxtQ -> TypeQ -> Q [Dec] -> DecQ
isSigD :: Dec -> Bool

module HAppS.Util.EventHandler

module HAppS.Util.Concurrent
fork_ :: IO a -> IO ()

-- | Fork a new thread.
fork :: IO a -> IO ThreadId

-- | Register an action to be run when ghci is restarted.
registerResetAction :: IO () -> IO ()

-- | Reset state
reset :: IO ()

-- | Sleep N seconds
sleep :: Int -> IO ()


-- | Timeout implementation for performing operations in the IO monad with
--   a timeout added. Both using Maybe and exceptions to handle timeouts
--   are supported.
--   
--   Timeouts can be implemented in GHC with either a global handler or a
--   per-timeout thread which sleeps until the timeout. The latter is used
--   in this module. Blocking on foreign calls can cause problems as GHC
--   has no way of interrupting such threads. The module provides a
--   slightly slower alternative implementation which returns even if the
--   computation has blocked on a foreign call. This should not be an issue
--   unless -threaded is used.
--   
--   The timeouts are currently limited to a maximum of about 2000 seconds.
--   This is a feature of threadDelay, but supporting longer timeouts is
--   certainly possible if that is desirable.
--   
--   For nested timeouts there are different ways to implement them: a)
--   attach an id to the exception so that the catch knows wether it may
--   catch this timout exception. I've choosen this because overhead is
--   only passing and incrementing an integer value. A integer wrap araound
--   is possible but too unlikely to happen to make me worry about it b)
--   start a new workiing and killing thread so that if the original thread
--   was run within withTimeOut itself it catches the exception and not an
--   inner timout. (this is done in withSafeTimeOut, for another reason
--   though) c) keep throwing exceptions until the the withTimeOut function
--   kills the killing thread. But consider sequence (forever (timeOut
--   threadDelay 10sec) ) In this case the exception will be called and the
--   next timOut may be entered before the second Exception has been thrown
--   
--   All exceptions but the internal TimeOutExceptionI are rethrown in the
--   calling thread
module HAppS.Util.TimeOut
withTimeOut :: Int -> IO a -> IO a

-- | This is the normal timeout handler. It throws a TimeOutException
--   exception, if the timeout occurs.
withTimeOutMaybe :: Int -> IO a -> IO (Maybe a)
withSafeTimeOut :: Int -> IO a -> IO a

-- | Like timeOut, but additionally it works even if the computation is
--   blocking async exceptions (explicitely or by a blocking FFI call).
--   This consumes more resources than timeOut, but is still quite fast.
--   
--   Like withTimeOutMaybe, but handles the operation blocking exceptions
--   like withSafeTimeOut does.
withSafeTimeOutMaybe :: Int -> IO a -> IO (Maybe a)
data TimeOutException
TimeOutException :: TimeOutException

-- | Constant representing one second.
second :: Int
instance [overlap ok] Typeable TimeOutException
instance [overlap ok] Typeable TimeOutExceptionI
instance [overlap ok] Show TimeOutException
instance [overlap ok] Exception TimeOutException
instance [overlap ok] Exception TimeOutExceptionI
instance [overlap ok] Show TimeOutExceptionI


-- | Various helper routines.
module HAppS.Util.Common
type Seconds = Int
type EpochSeconds = Int64
epochSeconds :: CalendarTime -> EpochSeconds
eSecsToCalTime :: EpochSeconds -> IO CalendarTime
epochPico :: CalendarTime -> Integer

-- | Put a line into a handle followed by <a>rn</a> and echo to stdout
hPutLine :: Handle -> String -> IO ()

-- | Get a line from the handle and echo to stdout
hGetLn :: Handle -> IO String
ltrim :: String -> String
rtrim :: String -> String
trim :: String -> String
unBracket :: String -> String
splitList :: Eq a => a -> [a] -> [[a]]
splitListBy :: (a -> Bool) -> [a] -> [[a]]

-- | Split is like break, but the matching element is dropped.
split :: (a -> Bool) -> [a] -> ([a], [a])

-- | Read file with a default value if the file does not exist.
mbReadFile :: a -> (String -> a) -> FilePath -> IO a
mapFst :: (a -> b) -> [(a, x)] -> [(b, x)]
mapSnd :: (a -> b) -> [(x, a)] -> [(x, b)]
revmap :: a -> [a -> b] -> [b]
comp :: Ord t => (a -> t) -> a -> a -> Ordering

-- | Run an external command. Upon failure print status to stderr.
runCommand :: String -> [String] -> IO ()

-- | Unsafe tracing, outputs the message and the value to stderr.
debug :: Show a => String -> a -> a

-- | Unsafe tracing messages inside a monad.
debugM :: Monad m => String -> m ()

-- | Read in any monad.
readM :: (Monad m, Read t) => String -> m t

-- | Convert Maybe into an another monad.
maybeM :: Monad m => Maybe a -> m a
notMb :: a -> Maybe a -> Maybe a


-- | Compatiblity for ByteStrings
module HAppS.Util.ByteStringCompat
breakChar :: Char -> ByteString -> (ByteString, ByteString)

-- | <a>breakCharEnd</a> behaves like breakChar, but from the end of the
--   ByteString.
--   
--   <pre>
--   breakCharEnd ('b') (pack "aabbcc") == ("aab","cc")
--   </pre>
--   
--   and the following are equivalent:
--   
--   <pre>
--   breakCharEnd 'c' "abcdef"
--   let (x,y) = break (=='c') (reverse "abcdef")
--   in (reverse (drop 1 y), reverse x)
--   </pre>
breakCharEnd :: Char -> ByteString -> (ByteString, ByteString)
dropSpace :: ByteString -> ByteString
dropSpaceEnd :: ByteString -> ByteString

-- | Chunk a lazy bytestring into reasonable chunks - is id from outside.
--   This is useful to make bytestring chunks reasonable sized for e.g.
--   compression.
rechunkLazy :: ByteString -> ByteString

module HAppS.Crypto.MD5

-- | Will read the lazy ByteString and return the md5 digest. Some
--   application might want to wrap this function for type safty.
md5 :: ByteString -> ByteString
md5InitialContext :: MD5Context
md5Update :: MD5Context -> ByteString -> MD5Context
md5Finalize :: MD5Context -> ByteString
data MD5Context
md5File :: String -> IO ()
stringMD5 :: ByteString -> [Char]
applyMD5Rounds :: MD5Partial -> ByteString -> MD5Partial
test :: IO ()

module HAppS.Crypto.SHA1
sha1 :: String -> String
sha1Raw :: String -> String
sha1_size :: Integral a => a -> String -> String

module HAppS.Util.Daemonize

module HAppS.Crypto.DES
des_enc :: Message -> Key -> Enc
des_dec :: Message -> Key -> Enc
instance [overlap ok] Eq Zord64
instance [overlap ok] Ord Zord64
instance [overlap ok] Bounded Zord64
instance [overlap ok] Bits [Bool]
instance [overlap ok] Num [Bool]
instance [overlap ok] Enum Zord64
instance [overlap ok] Real Zord64
instance [overlap ok] Integral Zord64
instance [overlap ok] Bits Zord64
instance [overlap ok] Num Zord64
instance [overlap ok] Read Zord64
instance [overlap ok] Show Zord64

module HAppS.Crypto.W64

module HAppS.Crypto.Base64
encode :: String -> String
decode :: String -> String

-- | Cut up a string into 72 char lines, each line terminated by CRLF.
chop72 :: String -> String

module HAppS.Crypto.HMAC
hmacSHA1 :: String -> String -> String
