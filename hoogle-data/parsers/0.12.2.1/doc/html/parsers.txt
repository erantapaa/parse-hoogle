-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing combinators
--   
@package parsers
@version 0.12.2.1


-- | Highlighting isn't strictly a parsing concern, but it makes more sense
--   to annotate a parser with highlighting information than to require
--   someone to completely reimplement all of the combinators to add this
--   functionality later when they need it.
module Text.Parser.Token.Highlight

-- | Tags used by the <a>TokenParsing</a> <a>highlight</a> combinator.
data Highlight
EscapeCode :: Highlight
Number :: Highlight
Comment :: Highlight
CharLiteral :: Highlight
StringLiteral :: Highlight
Constant :: Highlight
Statement :: Highlight
Special :: Highlight
Symbol :: Highlight
Identifier :: Highlight
ReservedIdentifier :: Highlight
Operator :: Highlight
ReservedOperator :: Highlight
Constructor :: Highlight
ReservedConstructor :: Highlight
ConstructorOperator :: Highlight
ReservedConstructorOperator :: Highlight
BadInput :: Highlight
Unbound :: Highlight
Layout :: Highlight
MatchedSymbols :: Highlight
LiterateComment :: Highlight
LiterateSyntax :: Highlight
instance Eq Highlight
instance Ord Highlight
instance Show Highlight
instance Read Highlight
instance Enum Highlight
instance Bounded Highlight


-- | This module implements permutation parsers. The algorithm is described
--   in:
--   
--   <i>Parsing Permutation Phrases,</i> by Arthur Baars, Andres Loh and
--   Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
module Text.Parser.Permutation

-- | The type <tt>Permutation m a</tt> denotes a permutation parser that,
--   when converted by the <a>permute</a> function, parses using the base
--   parsing monad <tt>m</tt> and returns a value of type <tt>a</tt> on
--   success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>permute</a>.
data Permutation m a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",some (char 'a'))
--                          &lt;||&gt; char 'b'
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: Alternative m => Permutation m a -> m a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: Functor m => Permutation m (a -> b) -> m a -> Permutation m b

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: Functor m => (a -> b) -> m a -> Permutation m b

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: Functor m => Permutation m (a -> b) -> (a, m a) -> Permutation m b

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: Functor m => (a -> b) -> (a, m a) -> Permutation m b
instance Functor m => Functor (Branch m)
instance Functor m => Functor (Permutation m)


-- | Alternative parser combinators
module Text.Parser.Combinators

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: Alternative m => [m a] -> m a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative m => a -> m a -> m a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | <tt>skipOptional p</tt> tries to apply parser <tt>p</tt>. It will
--   parse <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>. (Plays the role
--   of parsec's optional, which conflicts with Applicative's optional)
skipOptional :: Alternative m => m a -> m ()

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: Applicative m => m bra -> m ket -> m a -> m a

-- | One or more.
some :: Alternative f => forall a. f a -> f [a]

-- | Zero or more.
many :: Alternative f => forall a. f a -> f [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, seperated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Applicative m => Int -> m a -> m [a]

-- | <tt>chainl p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: Alternative m => m a -> m (a -> a -> a) -> a -> m a

-- | <tt>chainr p op x</tt> parser <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: Alternative m => m a -> m (a -> a -> a) -> a -> m a

-- | <tt>chainl1 p op x</tt> parser <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. . This parser can
--   for example be used to eliminate left recursion which typically occurs
--   in expression grammars.
--   
--   <pre>
--   expr   = term   `chainl1` addop
--   term   = factor `chainl1` mulop
--   factor = parens expr &lt;|&gt; integer
--   
--   mulop  = (*) &lt;$ symbol "*"
--        &lt;|&gt; div &lt;$ symbol "/"
--   
--   addop  = (+) &lt;$ symbol "+"
--        &lt;|&gt; (-) &lt;$ symbol "-"
--   </pre>
chainl1 :: Alternative m => m a -> m (a -> a -> a) -> m a

-- | <tt>chainr1 p op x</tt> parser <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: Alternative m => m a -> m (a -> a -> a) -> m a

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: Alternative m => m a -> m end -> m [a]

-- | Additional functionality needed to describe parsers independent of
--   input type.
class Alternative m => Parsing m where skipMany p = () <$ many p skipSome p = p *> skipMany p unexpected = lift . unexpected eof = lift eof
try :: Parsing m => m a -> m a
(<?>) :: Parsing m => m a -> String -> m a
skipMany :: Parsing m => m a -> m ()
skipSome :: Parsing m => m a -> m ()
unexpected :: Parsing m => String -> m a
eof :: Parsing m => m ()
notFollowedBy :: (Parsing m, Show a) => m a -> m ()
instance Parsing ReadP
instance Chunk t => Parsing (Parser t)
instance (Stream s m t, Show t) => Parsing (ParsecT s u m)
instance (Parsing m, Monad m) => Parsing (IdentityT m)
instance (Parsing m, MonadPlus m, Monoid w) => Parsing (RWST r w s m)
instance (Parsing m, MonadPlus m, Monoid w) => Parsing (RWST r w s m)
instance (Parsing m, MonadPlus m, Monoid w) => Parsing (WriterT w m)
instance (Parsing m, MonadPlus m, Monoid w) => Parsing (WriterT w m)
instance (Parsing m, MonadPlus m) => Parsing (ReaderT e m)
instance (Parsing m, MonadPlus m) => Parsing (StateT s m)
instance (Parsing m, MonadPlus m) => Parsing (StateT s m)


-- | Parsers that can <a>lookAhead</a>.
module Text.Parser.LookAhead

-- | Additional functionality needed to describe parsers independent of
--   input type.
class Parsing m => LookAheadParsing m
lookAhead :: LookAheadParsing m => m a -> m a
instance LookAheadParsing ReadP
instance (Stream s m t, Show t) => LookAheadParsing (ParsecT s u m)
instance (LookAheadParsing m, Monad m) => LookAheadParsing (IdentityT m)
instance (LookAheadParsing m, MonadPlus m, Monoid w) => LookAheadParsing (RWST r w s m)
instance (LookAheadParsing m, MonadPlus m, Monoid w) => LookAheadParsing (RWST r w s m)
instance (LookAheadParsing m, MonadPlus m, Monoid w) => LookAheadParsing (WriterT w m)
instance (LookAheadParsing m, MonadPlus m, Monoid w) => LookAheadParsing (WriterT w m)
instance (LookAheadParsing m, MonadPlus m) => LookAheadParsing (ReaderT e m)
instance (LookAheadParsing m, MonadPlus m) => LookAheadParsing (StateT s m)
instance (LookAheadParsing m, MonadPlus m) => LookAheadParsing (StateT s m)


-- | A helper module to parse "expressions". Builds a parser given a table
--   of operators and associativities.
module Text.Parser.Expression

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc

-- | This data type specifies operators that work on values of type
--   <tt>a</tt>. An operator is either binary infix or unary prefix or
--   postfix. A binary operator has also an associated associativity.
data Operator m a
Infix :: (m (a -> a -> a)) -> Assoc -> Operator m a
Prefix :: (m (a -> a)) -> Operator m a
Postfix :: (m (a -> a)) -> Operator m a

-- | An <tt>OperatorTable m a</tt> is a list of <tt>Operator m a</tt>
--   lists. The list is ordered in descending precedence. All operators in
--   one list have the same precedence (but may have a different
--   associativity).
type OperatorTable m a = [[Operator m a]]

-- | <tt>buildExpressionParser table term</tt> builds an expression parser
--   for terms <tt>term</tt> with operators from <tt>table</tt>, taking the
--   associativity and precedence specified in <tt>table</tt> into account.
--   Prefix and postfix operators of the same precedence can only occur
--   once (i.e. <tt>--2</tt> is not allowed if <tt>-</tt> is prefix
--   negate). Prefix and postfix operators of the same precedence associate
--   to the left (i.e. if <tt>++</tt> is postfix increment, than
--   <tt>-2++</tt> equals <tt>-1</tt>, not <tt>-3</tt>).
--   
--   The <tt>buildExpressionParser</tt> takes care of all the complexity
--   involved in building expression parser. Here is an example of an
--   expression parser that handles prefix signs, postfix increment and
--   basic arithmetic.
--   
--   <pre>
--   expr    = buildExpressionParser table term
--           &lt;?&gt; "expression"
--   
--   term    =  parens expr
--           &lt;|&gt; natural
--           &lt;?&gt; "simple expression"
--   
--   table   = [ [prefix "-" negate, prefix "+" id ]
--             , [postfix "++" (+1)]
--             , [binary "*" (*) AssocLeft, binary "/" (div) AssocLeft ]
--             , [binary "+" (+) AssocLeft, binary "-" (-)   AssocLeft ]
--             ]
--   
--   binary  name fun assoc = Infix (fun &lt;* reservedOp name) assoc
--   prefix  name fun       = Prefix (fun &lt;* reservedOp name)
--   postfix name fun       = Postfix (fun &lt;* reservedOp name)
--   </pre>
buildExpressionParser :: (Parsing m, Applicative m) => OperatorTable m a -> m a -> m a
instance Typeable Assoc
instance Eq Assoc
instance Ord Assoc
instance Show Assoc
instance Read Assoc
instance Ix Assoc
instance Enum Assoc
instance Bounded Assoc
instance Data Assoc


-- | Parsers for character streams
module Text.Parser.Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: CharParsing m => [Char] -> m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: CharParsing m => [Char] -> m Char

-- | <tt>oneOfSet cs</tt> succeeds if the current character is in the
--   supplied set of characters <tt>cs</tt>. Returns the parsed character.
--   See also <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOfSet :: CharParsing m => CharSet -> m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOfSet :: CharParsing m => CharSet -> m Char

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: CharParsing m => m ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: CharParsing m => m Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: CharParsing m => m Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: CharParsing m => m Char

-- | Parses an upper case letter. Returns the parsed character.
upper :: CharParsing m => m Char

-- | Parses a lower case character. Returns the parsed character.
lower :: CharParsing m => m Char

-- | Parses a letter or digit. Returns the parsed character.
alphaNum :: CharParsing m => m Char

-- | Parses a letter (an upper case or lower case character). Returns the
--   parsed character.
letter :: CharParsing m => m Char

-- | Parses a digit. Returns the parsed character.
digit :: CharParsing m => m Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: CharParsing m => m Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: CharParsing m => m Char
satisfyRange :: CharParsing m => Char -> Char -> m Char

-- | Additional functionality needed to parse character streams.
class Parsing m => CharParsing m where satisfy = lift . satisfy char c = satisfy (c ==) <?> show [c] notChar c = satisfy (c /=) anyChar = satisfy (const True) string s = s <$ try (traverse_ char s) <?> show s text t = t <$ string (unpack t)
satisfy :: CharParsing m => (Char -> Bool) -> m Char
char :: CharParsing m => Char -> m Char
notChar :: CharParsing m => Char -> m Char
anyChar :: CharParsing m => m Char
string :: CharParsing m => String -> m String
text :: CharParsing m => Text -> m Text
instance CharParsing ReadP
instance Chunk t => CharParsing (Parser t)
instance Stream s m Char => CharParsing (ParsecT s u m)
instance (CharParsing m, MonadPlus m) => CharParsing (IdentityT m)
instance (CharParsing m, MonadPlus m, Monoid w) => CharParsing (RWST r w s m)
instance (CharParsing m, MonadPlus m, Monoid w) => CharParsing (RWST r w s m)
instance (CharParsing m, MonadPlus m, Monoid w) => CharParsing (WriterT w m)
instance (CharParsing m, MonadPlus m, Monoid w) => CharParsing (WriterT w m)
instance (CharParsing m, MonadPlus m) => CharParsing (ReaderT e m)
instance (CharParsing m, MonadPlus m) => CharParsing (StateT s m)
instance (CharParsing m, MonadPlus m) => CharParsing (StateT s m)


-- | Parsers that comprehend whitespace and identifier styles
--   
--   <pre>
--   idStyle    = haskellIdents { styleReserved = ... }
--   identifier = ident idStyle
--   reserved   = reserve idStyle
--   </pre>
module Text.Parser.Token

-- | Skip zero or more bytes worth of white space. More complex parsers are
--   free to consider comments as white space.
whiteSpace :: TokenParsing m => m ()

-- | This token parser parses a single literal character. Returns the
--   literal character value. This parsers deals correctly with escape
--   sequences. The literal character is parsed according to the grammar
--   rules defined in the Haskell report (which matches most programming
--   languages quite closely).
charLiteral :: TokenParsing m => m Char

-- | This token parser parses a literal string. Returns the literal string
--   value. This parsers deals correctly with escape sequences and gaps.
--   The literal string is parsed according to the grammar rules defined in
--   the Haskell report (which matches most programming languages quite
--   closely).
stringLiteral :: (TokenParsing m, IsString s) => m s

-- | This token parser behaves as <a>stringLiteral</a>, but for
--   single-quoted strings.
stringLiteral' :: (TokenParsing m, IsString s) => m s

-- | This token parser parses a natural number (a positive whole number).
--   Returns the value of the number. The number can be specified in
--   <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
natural :: TokenParsing m => m Integer

-- | This token parser parses an integer (a whole number). This parser is
--   like <a>natural</a> except that it can be prefixed with sign (i.e. '-'
--   or '+'). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
integer :: TokenParsing m => m Integer

-- | This token parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
double :: TokenParsing m => m Double

-- | This token parser parses either <a>natural</a> or a <tt>float</tt>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
naturalOrDouble :: TokenParsing m => m (Either Integer Double)

-- | This token parser is like <a>naturalOrDouble</a>, but handles leading
--   <tt>-</tt> or <tt>+</tt>.
integerOrDouble :: TokenParsing m => m (Either Integer Double)

-- | This token parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
scientific :: TokenParsing m => m Scientific

-- | This token parser parses either <a>natural</a> or a <a>scientific</a>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
naturalOrScientific :: TokenParsing m => m (Either Integer Scientific)

-- | This token parser is like <a>naturalOrScientific</a>, but handles
--   leading <tt>-</tt> or <tt>+</tt>.
integerOrScientific :: TokenParsing m => m (Either Integer Scientific)

-- | Token parser <tt>symbol s</tt> parses <a>string</a> <tt>s</tt> and
--   skips trailing white space.
symbol :: TokenParsing m => String -> m String

-- | Token parser <tt>textSymbol t</tt> parses <a>text</a> <tt>s</tt> and
--   skips trailing white space.
textSymbol :: TokenParsing m => Text -> m Text

-- | Token parser <tt>symbolic s</tt> parses <a>char</a> <tt>s</tt> and
--   skips trailing white space.
symbolic :: TokenParsing m => Char -> m Char

-- | Token parser <tt>parens p</tt> parses <tt>p</tt> enclosed in
--   parenthesis, returning the value of <tt>p</tt>.
parens :: TokenParsing m => m a -> m a

-- | Token parser <tt>braces p</tt> parses <tt>p</tt> enclosed in braces
--   ('{' and '}'), returning the value of <tt>p</tt>.
braces :: TokenParsing m => m a -> m a

-- | Token parser <tt>angles p</tt> parses <tt>p</tt> enclosed in angle
--   brackets ('&lt;' and '&gt;'), returning the value of <tt>p</tt>.
angles :: TokenParsing m => m a -> m a

-- | Token parser <tt>brackets p</tt> parses <tt>p</tt> enclosed in
--   brackets ('[' and ']'), returning the value of <tt>p</tt>.
brackets :: TokenParsing m => m a -> m a

-- | Token parser <tt>comma</tt> parses the character ',' and skips any
--   trailing white space. Returns the string ",".
comma :: TokenParsing m => m Char

-- | Token parser <tt>colon</tt> parses the character ':' and skips any
--   trailing white space. Returns the string ":".
colon :: TokenParsing m => m Char

-- | Token parser <tt>dot</tt> parses the character '.' and skips any
--   trailing white space. Returns the string ".".
dot :: TokenParsing m => m Char

-- | Token parser <tt>semiSep p</tt> parses <i>zero</i> or more occurrences
--   of <tt>p</tt> separated by <a>semi</a>. Returns a list of values
--   returned by <tt>p</tt>.
semiSep :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>semiSep1 p</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt> separated by <a>semi</a>. Returns a list of values
--   returned by <tt>p</tt>.
semiSep1 :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>commaSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>commaSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep1 :: TokenParsing m => m a -> m [a]

-- | Additional functionality that is needed to tokenize input while
--   ignoring whitespace.
class CharParsing m => TokenParsing m where someSpace = skipSome (satisfy isSpace) nesting = id semi = token (satisfy (';' ==) <?> ";") highlight _ a = a token p = p <* (someSpace <|> pure ())
someSpace :: TokenParsing m => m ()
nesting :: TokenParsing m => m a -> m a
semi :: TokenParsing m => m Char
highlight :: TokenParsing m => Highlight -> m a -> m a
token :: TokenParsing m => m a -> m a

-- | This is a parser transformer you can use to disable the automatic
--   trailing space consumption of a Token parser.
newtype Unspaced m a
Unspaced :: m a -> Unspaced m a
runUnspaced :: Unspaced m a -> m a

-- | This is a parser transformer you can use to disable the automatic
--   trailing newline (but not whitespace-in-general) consumption of a
--   Token parser.
newtype Unlined m a
Unlined :: m a -> Unlined m a
runUnlined :: Unlined m a -> m a

-- | This is a parser transformer you can use to disable syntax
--   highlighting over a range of text you are parsing.
newtype Unhighlighted m a
Unhighlighted :: m a -> Unhighlighted m a
runUnhighlighted :: Unhighlighted m a -> m a

-- | Parses a positive whole number in the decimal system. Returns the
--   value of the number.
--   
--   This parser does NOT swallow trailing whitespace
decimal :: TokenParsing m => m Integer

-- | Parses a positive whole number in the hexadecimal system. The number
--   should be prefixed with "x" or "X". Returns the value of the number.
--   
--   This parser does NOT swallow trailing whitespace
hexadecimal :: TokenParsing m => m Integer

-- | Parses a positive whole number in the octal system. The number should
--   be prefixed with "o" or "O". Returns the value of the number.
--   
--   This parser does NOT swallow trailing whitespace
octal :: TokenParsing m => m Integer

-- | This parser parses a character literal without the surrounding
--   quotation marks.
--   
--   This parser does NOT swallow trailing whitespace
characterChar :: TokenParsing m => m Char

-- | This parser parses an integer (a whole number). This parser is like
--   <a>natural</a> except that it can be prefixed with sign (i.e. '-' or
--   '+'). Returns the value of the number. The number can be specified in
--   <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
--   
--   This parser does NOT swallow trailing whitespace.
--   
--   Also, unlike the <a>integer</a> parser, this parser does not admit
--   spaces between the sign and the number.
integer' :: TokenParsing m => m Integer

-- | Used to describe an input style for constructors, values, operators,
--   etc.
data IdentifierStyle m
IdentifierStyle :: String -> m Char -> m Char -> HashSet String -> Highlight -> Highlight -> IdentifierStyle m
_styleName :: IdentifierStyle m -> String
_styleStart :: IdentifierStyle m -> m Char
_styleLetter :: IdentifierStyle m -> m Char
_styleReserved :: IdentifierStyle m -> HashSet String
_styleHighlight :: IdentifierStyle m -> Highlight
_styleReservedHighlight :: IdentifierStyle m -> Highlight

-- | Lift an identifier style into a monad transformer
--   
--   Using <tt>over</tt> from the <tt>lens</tt> package:
--   
--   <pre>
--   <a>liftIdentifierStyle</a> = over <a>styleChars</a> <a>lift</a>
--   </pre>
liftIdentifierStyle :: (MonadTrans t, Monad m) => IdentifierStyle m -> IdentifierStyle (t m)

-- | Parse a non-reserved identifier or symbol
ident :: (TokenParsing m, Monad m, IsString s) => IdentifierStyle m -> m s

-- | parse a reserved operator or identifier using a given style
reserve :: (TokenParsing m, Monad m) => IdentifierStyle m -> String -> m ()

-- | parse a reserved operator or identifier using a given style given
--   <a>Text</a>.
reserveText :: (TokenParsing m, Monad m) => IdentifierStyle m -> Text -> m ()

-- | This lens can be used to update the name for this style of identifier.
--   
--   <pre>
--   <a>styleName</a> :: Lens' (<a>IdentifierStyle</a> m) <a>String</a>
--   </pre>
styleName :: Functor f => (String -> f String) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This lens can be used to update the action used to recognize the first
--   letter in an identifier.
--   
--   <pre>
--   <a>styleStart</a> :: Lens' (<a>IdentifierStyle</a> m) (m <a>Char</a>)
--   </pre>
styleStart :: Functor f => (m Char -> f (m Char)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This lens can be used to update the action used to recognize
--   subsequent letters in an identifier.
--   
--   <pre>
--   <a>styleLetter</a> :: Lens' (<a>IdentifierStyle</a> m) (m <a>Char</a>)
--   </pre>
styleLetter :: Functor f => (m Char -> f (m Char)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a traversal of both actions in contained in an
--   <a>IdentifierStyle</a>.
--   
--   <pre>
--   <a>styleChars</a> :: Traversal (<a>IdentifierStyle</a> m) (<a>IdentifierStyle</a> n) (m <a>Char</a>) (n <a>Char</a>)
--   </pre>
styleChars :: Applicative f => (m Char -> f (n Char)) -> IdentifierStyle m -> f (IdentifierStyle n)

-- | This is a lens that can be used to modify the reserved identifier set.
--   
--   <pre>
--   <a>styleReserved</a> :: Lens' (<a>IdentifierStyle</a> m) (<a>HashSet</a> <a>String</a>)
--   </pre>
styleReserved :: Functor f => (HashSet String -> f (HashSet String)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a lens that can be used to modify the highlight used for this
--   identifier set.
--   
--   <pre>
--   <a>styleHighlight</a> :: Lens' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleHighlight :: Functor f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a lens that can be used to modify the highlight used for
--   reserved identifiers in this identifier set.
--   
--   <pre>
--   <a>styleReservedHighlight</a> :: Lens' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleReservedHighlight :: Functor f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a traversal that can be used to modify the highlights used for
--   both non-reserved and reserved identifiers in this identifier set.
--   
--   <pre>
--   <a>styleHighlights</a> :: Traversal' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleHighlights :: Applicative f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)
instance Functor m => Functor (Unhighlighted m)
instance Applicative m => Applicative (Unhighlighted m)
instance Alternative m => Alternative (Unhighlighted m)
instance Monad m => Monad (Unhighlighted m)
instance MonadPlus m => MonadPlus (Unhighlighted m)
instance CharParsing m => CharParsing (Unhighlighted m)
instance Functor m => Functor (Unspaced m)
instance Applicative m => Applicative (Unspaced m)
instance Alternative m => Alternative (Unspaced m)
instance Monad m => Monad (Unspaced m)
instance MonadPlus m => MonadPlus (Unspaced m)
instance CharParsing m => CharParsing (Unspaced m)
instance Functor m => Functor (Unlined m)
instance Applicative m => Applicative (Unlined m)
instance Alternative m => Alternative (Unlined m)
instance Monad m => Monad (Unlined m)
instance MonadPlus m => MonadPlus (Unlined m)
instance CharParsing m => CharParsing (Unlined m)
instance TokenParsing ReadP
instance Chunk t => TokenParsing (Parser t)
instance Stream s m Char => TokenParsing (ParsecT s u m)
instance TokenParsing m => TokenParsing (Unlined m)
instance MonadTrans Unlined
instance Parsing m => Parsing (Unlined m)
instance TokenParsing m => TokenParsing (Unspaced m)
instance MonadTrans Unspaced
instance Parsing m => Parsing (Unspaced m)
instance TokenParsing m => TokenParsing (Unhighlighted m)
instance MonadTrans Unhighlighted
instance Parsing m => Parsing (Unhighlighted m)
instance (TokenParsing m, MonadPlus m) => TokenParsing (IdentityT m)
instance (TokenParsing m, MonadPlus m, Monoid w) => TokenParsing (RWST r w s m)
instance (TokenParsing m, MonadPlus m, Monoid w) => TokenParsing (RWST r w s m)
instance (TokenParsing m, MonadPlus m, Monoid w) => TokenParsing (WriterT w m)
instance (TokenParsing m, MonadPlus m, Monoid w) => TokenParsing (WriterT w m)
instance (TokenParsing m, MonadPlus m) => TokenParsing (ReaderT e m)
instance (TokenParsing m, MonadPlus m) => TokenParsing (StateT s m)
instance (TokenParsing m, MonadPlus m) => TokenParsing (StateT s m)


-- | A toolbox for specifying comment and identifier styles
--   
--   This must be imported directly as it is not re-exported elsewhere
module Text.Parser.Token.Style

-- | How to deal with comments.
data CommentStyle
CommentStyle :: String -> String -> String -> Bool -> CommentStyle

-- | String that starts a multiline comment
_commentStart :: CommentStyle -> String

-- | String that ends a multiline comment
_commentEnd :: CommentStyle -> String

-- | String that starts a single line comment
_commentLine :: CommentStyle -> String

-- | Can we nest multiline comments?
_commentNesting :: CommentStyle -> Bool

-- | This is a lens that can edit the string that starts a multiline
--   comment.
--   
--   <pre>
--   <a>commentStart</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentStart :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit the string that ends a multiline comment.
--   
--   <pre>
--   <a>commentEnd</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentEnd :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit the string that starts a single line
--   comment.
--   
--   <pre>
--   <a>commentLine</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentLine :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit whether we can nest multiline comments.
--   
--   <pre>
--   <a>commentNesting</a> :: Lens' <a>CommentStyle</a> <a>Bool</a>
--   </pre>
commentNesting :: Functor f => (Bool -> f Bool) -> CommentStyle -> f CommentStyle

-- | No comments at all
emptyCommentStyle :: CommentStyle

-- | Use java-style comments
javaCommentStyle :: CommentStyle

-- | Use scala-style comments
scalaCommentStyle :: CommentStyle

-- | Use haskell-style comments
haskellCommentStyle :: CommentStyle

-- | Use this to easily build the definition of whiteSpace for your
--   MonadParser given a comment style and an underlying someWhiteSpace
--   parser
buildSomeSpaceParser :: CharParsing m => m () -> CommentStyle -> m ()

-- | A simple identifier style based on haskell with no reserve words
emptyIdents :: TokenParsing m => IdentifierStyle m

-- | A simple identifier style based on haskell with the reserved words
--   from Haskell 98 and some common extensions.
haskellIdents :: TokenParsing m => IdentifierStyle m

-- | A simple identifier style based on haskell with only the reserved
--   words from Haskell 98.
haskell98Idents :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with no reserved operators
emptyOps :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with the operators from
--   Haskell 98.
haskellOps :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with the operators from
--   Haskell 98.
haskell98Ops :: TokenParsing m => IdentifierStyle m
instance Typeable CommentStyle
instance Eq CommentStyle
instance Ord CommentStyle
instance Show CommentStyle
instance Read CommentStyle
instance Data CommentStyle
