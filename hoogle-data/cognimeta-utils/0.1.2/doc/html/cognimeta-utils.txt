-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for Cognimeta products (such as perdure). API may change often.
--   
--   These utilities are used by Perdure and other internal Cognimeta
--   products.
--   
--   Please do not rely on these APIs. If parts of this are of interest to
--   you please contact 'ppremont@cognimeta.com' and we will consider
--   creating a cleaner separate package.
@package cognimeta-utils
@version 0.1.2

module Cgm.TH.Label
label :: Name -> ExpQ

module Cgm.Data.Structured.Derive
deriveStructured :: Name -> Q [Dec]

module Cgm.Data.NEList
data NEList a
neSingleton :: a -> NEList a
neCons :: a -> NEList a -> NEList a
onNEList :: (a -> Maybe (NEList a) -> z) -> NEList a -> z
neAppend :: NEList a -> NEList a -> NEList a
instance Show a => Show (NEList a)

module Cgm.Data.Monoid
(◊) :: Monoid a => a -> a -> a
ø :: Monoid m => m
inter :: Monoid m => m -> m -> m -> m
foldInter :: (Monoid m, Foldable l) => m -> l m -> m

module Cgm.Data.Typeable

module Cgm.Data.Functor
mapf :: Functor f => f a -> (a -> b) -> f b
(<$$>) :: Functor f => f a -> (a -> b) -> f b

module Cgm.Data.Empty
onØ :: Ø -> a
data Ø

module Cgm.Control.Profile
putCpuTime :: String -> IO a -> IO a
cpuTimeNF :: NFData a => a -> IO (a, Float)
cpuTime :: IO a -> IO (a, Float)

module Cgm.Control.Monad.State

-- | runStateT and runState do not have the usual types: for now we do not
--   make it too easy to discard the precious <a>Nothing</a>
newtype StateT s m a
StateT :: (s -> m (a, Maybe s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, Maybe s)
type State s = StateT s Identity
mState :: (s -> (a, Maybe s)) -> State s a
runState :: State s a -> s -> (a, Maybe s)
focus :: Monad m => Lens t s -> StateT s m a -> StateT t m a

-- | functions st and ts should form a bijection since a StateT t with no
--   changes will become a StateT s with no changes, no matter what st and
--   ts are
viewState :: Monad m => (s -> t, t -> s) -> StateT t m a -> StateT s m a
partialState :: Monad m => m a -> (s -> Maybe t, t -> s) -> StateT t m a -> StateT s m a
partialStateE :: Monad m => m a -> (s -> Maybe t, t -> s) -> StateT t m b -> StateT s m (Either a b)
eitherState :: Monad m => StateT s m a -> StateT t m a -> StateT (Either s t) m a
maybeState :: Monad m => m a -> StateT s m a -> StateT (Maybe s) m a
toStandardState :: Monad m => StateT s m a -> StateT s m a
mapStateT :: (m (a, Maybe s) -> n (b, Maybe s)) -> StateT s m a -> StateT s n b
pairStateT :: Functor m => StateT s (StateT t m) a -> StateT (s, t) m a
instance Monad m => MonadState s (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadTrans (StateT s)
instance Monad m => Monad (StateT s m)
instance (Functor m, Monad m) => Applicative (StateT s m)
instance Functor m => Functor (StateT s m)

module Cgm.Data.Bool
bool :: z -> z -> Bool -> z

module Cgm.Control.Concurrent.NotificationCount
type NotificationCount = MVar (Word64, [IO ()])
withNotificationCount :: (NotificationCount -> IO a) -> IO () -> IO a
notifying :: NotificationCount -> (IO () -> IO a) -> IO a

module Cgm.Control.Concurrent.MVar
stateModifyMVar :: MVar a -> State a b -> IO b
stateTModifyMVar :: MVar a -> StateT a IO b -> IO b
withNewMVar :: (MVar t -> IO z) -> StateT t IO z

module Cgm.Control.Concurrent.Await
type Async a s = (a -> IO ()) -> IO s
await0 :: (IO () -> IO a) -> IO a
await1 :: Async a () -> IO a
mapAsync :: (a -> IO b) -> Async a () -> Async b ()

module Cgm.Control.Combinators
fk :: (x -> y -> b) -> (a -> x) -> (a -> y) -> a -> b
dot2 :: (a' -> b' -> c) -> (a -> a') -> (b -> b') -> a -> b -> c
dot2i :: (a' -> a' -> b) -> (a -> a') -> a -> a -> b
dup :: (a -> a -> b) -> a -> b
(./) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.//) :: (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
(.///) :: (b -> c) -> (a1 -> a2 -> a3 -> a4 -> b) -> a1 -> a2 -> a3 -> a4 -> c
(.////) :: (b -> c) -> (a1 -> a2 -> a3 -> a4 -> a5 -> b) -> a1 -> a2 -> a3 -> a4 -> a5 -> c
type Id a = a -> a
todo :: a

module Cgm.Control.Concurrent.TThread
run2 :: Task2 c a b -> Task2 c b a -> IO c
runWithDeamon :: (String, IO c) -> (String, IO ()) -> IO c
instance Typeable Abort
instance Typeable UnexpectedTaskException
instance Typeable ConcurrentExceptions
instance Typeable PeerTaskException
instance Show Abort
instance Show UnexpectedTaskException
instance Show ConcurrentExceptions
instance Show PeerTaskException
instance Exception PeerTaskException
instance Exception ConcurrentExceptions
instance Exception UnexpectedTaskException
instance Exception Abort

module Cgm.Control.InFunctor
class Category f => Function f
apply :: Function f => f a b -> a -> b
($*) :: Function f => f a b -> a -> b
class Function f => Increasing f
data Increasing' a b
type (:>>=) a b = Increasing' a b
uncheckedIncreasing :: (a -> b) -> Increasing' a b
class Increasing f => StrictlyIncreasing f
data StrictlyIncreasing' a b
type (:>>) a b = StrictlyIncreasing' a b
uncheckedStrictlyIncreasing :: (a -> b) -> StrictlyIncreasing' a b
class Function f => InjectionA f
unapply :: InjectionA f => f a b -> b -> Maybe a
data InjectionA' a b
uncheckedInjectionA :: (a -> b) -> (b -> Maybe a) -> InjectionA' a b
injectionA' :: InjectionA f => f a b -> InjectionA' a b
class InjectionA f => Injection f
retract :: Injection f => f a b -> b -> a
data Injection' a b
uncheckedInjection :: (a -> b) -> (b -> a) -> Injection' a b
injection' :: Injection f => f a b -> Injection' a b
pairInjection :: (Injection f1, Injection f2) => f1 a1 b1 -> f2 a2 b2 -> Injection' (a1, a2) (b1, b2)
class InjectionA f => InjectionM f
data InjectionM' a b
uncheckedInjectionM :: (a -> b) -> (b -> Maybe a) -> InjectionM' a b
injectionM' :: InjectionM f => f a b -> InjectionM' a b
class (Injection f, InjectionM f) => Bijection f
data Bijection' a b
uncheckedBijection :: (a -> b) -> (b -> a) -> Bijection' a b
pairBijection :: (Bijection f1, Bijection f2) => f1 a1 b1 -> f2 a2 b2 -> Bijection' (a1, a2) (b1, b2)
inv :: Bijection f => f a b -> Bijection' b a
liftAB :: (Bijection g, Applicative f) => g a b -> Bijection' (f a) (f b)
class InjectionACofunctor f
iacomap :: (InjectionACofunctor f, InjectionA g) => f b -> g a b -> f a
class InjectionCofunctor f
icomap :: (InjectionCofunctor f, Injection g) => f b -> g a b -> f a
class InjectionMCofunctor f
imcomap :: (InjectionMCofunctor f, InjectionM g) => f b -> g a b -> f a
class ExpFunctor f
bmap :: (ExpFunctor f, Bijection g) => g a b -> f a -> f b
class IncreasingFunctor f
incmap :: (IncreasingFunctor f, Increasing g) => g a b -> f a -> f b
class StrictlyIncreasingFunctor f
sincmap :: (StrictlyIncreasingFunctor f, StrictlyIncreasing g) => g a b -> f a -> f b
class Cofunctor f
(>$<) :: Cofunctor f => f b -> (a -> b) -> f a
functorCofunctorComap :: (Functor f, Cofunctor c) => (Compose f c) b -> (a -> b) -> (Compose f c) a
class Comonoidal f
munit :: Comonoidal f => f ()
mpair :: Comonoidal f => f a -> f b -> f (a, b)
functorIacomap :: (Functor f, InjectionA g) => f b -> g a b -> f a
cofunctorIacomap :: (Cofunctor f, InjectionA g) => f b -> g a b -> f a
newtype RevFun b a
RevFun :: (a -> b) -> RevFun b a
getRevFun :: RevFun b a -> a -> b
type (:<-) = RevFun
wrapU :: (Bijection og, Function i1g) => og o o' -> i1g i1 i1' -> (i1' -> o') -> i1 -> o
wrapB :: (Bijection og, Function i1g, Function i2g) => og o o' -> i1g i1 i1' -> i2g i2 i2' -> (i1' -> i2' -> o') -> i1 -> i2 -> o
liftItI :: Injection f => f a b -> (b -> b) -> a -> a
liftIItK :: Function f => f a a' -> (a' -> a' -> b) -> a -> a -> b
liftIItI :: Injection f => f a2 a' -> (a' -> a' -> a') -> a2 -> a2 -> a2
liftIKtI :: Injection f => f a1 a' -> (a' -> a -> a') -> a1 -> a -> a1
liftIItII :: Injection f => f a2 a' -> (a' -> a' -> (a', a')) -> a2 -> a2 -> (a2, a2)
instance Category InjectionM'
instance Function InjectionM'
instance InjectionA InjectionM'
instance Category Bijection'
instance Function Bijection'
instance InjectionA Bijection'
instance Injection Bijection'
instance Monoid b => Monoid (RevFun b a)
instance (Applicative a, Comonoidal c) => Comonoidal (Compose a c)
instance Monoid m => Comonoidal (Constant m)
instance Monoid m => Comonoidal (RevFun m)
instance (Functor f, Cofunctor c) => Cofunctor (Compose f c)
instance Cofunctor (Constant a)
instance Cofunctor (RevFun b)
instance (Applicative a, InjectionACofunctor c) => InjectionACofunctor (Compose a c)
instance Bijection Bijection'
instance InjectionM Bijection'
instance InjectionM InjectionM'
instance Injection Injection'
instance InjectionA Injection'
instance Function Injection'
instance Category Injection'
instance InjectionA InjectionA'
instance Function InjectionA'
instance Category InjectionA'
instance StrictlyIncreasing StrictlyIncreasing'
instance Increasing StrictlyIncreasing'
instance Function StrictlyIncreasing'
instance Category StrictlyIncreasing'
instance Increasing Increasing'
instance Function Increasing'
instance Category Increasing'
instance Function (->)

module Cgm.Data.Either
type (:|) a b = Either a b
isRight :: Either a b -> Bool
mkRight :: a :>> Either b a
mkLeft :: a :>> Either a b
boolEither :: a -> b -> Bool -> Either a b
fromRight :: Either a b -> b
throwErrorT :: (Show e, MonadIO m) => ErrorT e m a -> m a
mapError :: Monad m => (e -> e') -> ErrorT e m a -> ErrorT e' m a

module Cgm.Data.SortedPair
data SortedPair a
onSortedPair :: (a -> a -> z) -> SortedPair a -> z
sortedPair :: Ord a => a -> a -> SortedPair a
unsafeSortedPair :: a -> a -> SortedPair a
instance Show a => Show (SortedPair a)
instance StrictlyIncreasingFunctor SortedPair

module Cgm.Data.Structured
class Structured a where type family Structure a
structure :: Structured a => a -> Structure a
fromStructure :: Structured a => Structure a -> a
struct :: Structured a => Bijection' a (Structure a)
wrap :: Structured a => Structure a -> a
unwrap :: Structured a => a -> Structure a
in1 :: (Structured a, Structured b) => (Structure a -> Structure b) -> a -> b
in2 :: (Structured a, Structured b, Structured c) => (Structure a -> Structure b -> Structure c) -> a -> b -> c
structureMap :: (InjectionACofunctor p, Structured a) => p (Structure a) -> p a
deriveStructured :: Name -> Q [Dec]
instance Structured (RevFun b0 a0)
instance Structured (Compose f0 g0 a0)
instance Structured (Kleisli m0 a0 b0)
instance Structured Ordering
instance Structured Bool
instance Structured (Maybe a0)
instance Structured [a0]
instance Structured (a0, b0, c0, d0, e0, f0)
instance Structured (a0, b0, c0, d0, e0)
instance Structured (a0, b0, c0, d0)
instance Structured (a0, b0, c0)

module Cgm.Data.Functor.Sum
newtype Sum a b e
Sum :: Either (a e) (b e) -> Sum a b e
getSum :: Sum a b e -> Either (a e) (b e)
instance Structured (Sum a0 b0 e0)

module Cgm.Data.Tagged
tag :: b -> Tagged * s b
at :: Tagged * s b -> b
type At a = forall z. Tagged a z -> z
type Tagged2 a b z = Tagged a (Tagged b z)
tag2 :: a -> Tagged * s (Tagged * s1 a)
at2 :: Tagged * s1 (Tagged * s c) -> c
type At2 a b = forall z. Tagged2 a b z -> z
type Tagged3 a b c z = Tagged a (Tagged2 b c z)
tag3 :: a -> Tagged * s (Tagged * s1 (Tagged * s2 a))
at3 :: Tagged * s2 (Tagged * s1 (Tagged * s c)) -> c
type At3 a b c = forall z. Tagged3 a b c z -> z
type Tagged4 a b c d z = Tagged a (Tagged3 b c d z)
tag4 :: a -> Tagged * s (Tagged * s1 (Tagged * s2 (Tagged * s3 a)))
at4 :: Tagged * s3 (Tagged * s2 (Tagged * s1 (Tagged * s c))) -> c
type At4 a b c d = forall z. Tagged4 a b c d z -> z
flipTags :: Tagged2 a b z -> Tagged2 b a z
rot3Tags :: Tagged3 b c a z -> Tagged3 a b c z
rot3Tags2 :: Tagged3 c a b z -> Tagged3 a b c z
rot4Tags :: Tagged4 b c d a z -> Tagged4 a b c d z
rot4Tags2 :: Tagged4 c d a b z -> Tagged4 a b c d z
rot4Tags3 :: Tagged4 d a b c z -> Tagged4 a b c d z
dupTag :: Tagged2 a a z -> Tagged a z
dup2Tags :: Tagged4 a b a b z -> Tagged2 a b z
pushTagIn :: Functor f => Tagged a (f b) -> f (Tagged a b)
constAt :: Tagged b a -> b -> a

module Cgm.Prelude
counting :: (Num a, Enum a) => a -> [a]

module Cgm.Data.Nat.Base
data D0
d0 :: D0
class Nat n
onNat :: Nat n => (n ~ D0 => c) -> (forall n'. (Succ n' ~ n, Nat n') => Tagged n' c) -> Tagged n c
data Succ n
intOfNat :: Nat a => Tagged a Int
addZ :: Nat b => (((D0 :+: b) ~ b, (b :+: D0) ~ b) => c) -> Tagged b c
addS :: (Nat a, Nat b) => ((Succ a :+: b) ~ Succ (a :+: b) => z) -> Tagged2 a b z
addSC :: (Nat a, Nat b) => (((Succ a :+: b) ~ Succ (a :+: b), Nat (a :+: b)) => z) -> Tagged2 a b z
addC :: (Nat a, Nat b) => (Nat (a :+: b) => z) -> Tagged2 a b z
addComm :: (Nat a, Nat b) => ((a :+: b) ~ (b :+: a) => z) -> Tagged2 a b z
subZ :: Nat b => ((b :-: D0) ~ b => z) -> Tagged b z
subS :: (Nat a, Nat b, Nat (a :-: b)) => ((Succ a :-: b) ~ Succ (a :-: b) => z) -> Tagged2 a b z
subI :: Nat b => ((b :-: b) ~ D0 => z) -> Tagged b z
addSub :: (Nat a, Nat b, Nat c, Nat (b :-: c)) => ((((a :+: b) :-: c) ~ (a :+: (b :-: c)), Nat (a :+: (b :-: c))) => z) -> Tagged3 a b c z
geTrans :: (Nat a, Nat b, Nat c, Nat (a :-: b), Nat (b :-: c)) => (Nat (a :-: c) => z) -> Tagged3 a b c z
instance Typeable D0
instance Typeable1 Succ
instance Nat n => Nat (Succ n)
instance Nat D0

module Cgm.Data.Nat.Constants
type D1 = Succ D0
type D2 = Succ D1
type D3 = Succ D2
type D4 = Succ D3
type D5 = Succ D4
type D6 = Succ D5
type D7 = Succ D6
type D8 = Succ D7
type D9 = Succ D8
type D10 = Succ D9
type D11 = Succ D10
type D12 = Succ D11
type D13 = Succ D12
type D14 = Succ D13
type D15 = Succ D14
type D16 = Succ D15
type D17 = Succ D16
type D18 = Succ D17
type D19 = Succ D18
type D20 = Succ D19
type D21 = Succ D20
type D22 = Succ D21
type D23 = Succ D22
type D24 = Succ D23
type D25 = Succ D24
type D26 = Succ D25
type D27 = Succ D26
type D28 = Succ D27
type D29 = Succ D28
type D30 = Succ D29
type D31 = Succ D30
type D32 = Succ D31
type D33 = Succ D32
type D34 = Succ D33
type D35 = Succ D34
type D36 = Succ D35
type D37 = Succ D36
type D38 = Succ D37
type D39 = Succ D38
type D40 = Succ D39
type D41 = Succ D40
type D42 = Succ D41
type D43 = Succ D42
type D44 = Succ D43
type D45 = Succ D44
type D46 = Succ D45
type D47 = Succ D46
type D48 = Succ D47
type D49 = Succ D48
type D50 = Succ D49
type D51 = Succ D50
type D52 = Succ D51
type D53 = Succ D52
type D54 = Succ D53
type D55 = Succ D54
type D56 = Succ D55
type D57 = Succ D56
type D58 = Succ D57
type D59 = Succ D58
type D60 = Succ D59
type D61 = Succ D60
type D62 = Succ D61
type D63 = Succ D62
type D64 = Succ D63
type D65 = Succ D64


module Cgm.Data.Nat


module Cgm.Data.List
testList :: b -> (a -> [a] -> b) -> [a] -> b
class List a where type family Listed a :: *
onList :: List a => b -> (Listed a -> a -> b) -> a -> b
consList :: List a => Listed a -> a -> a
emptyList :: List a => a
listHead :: List a => a -> Maybe (Listed a)
addListContext :: (List a, List c, Listed a ~ Listed c) => a -> [(c, Listed a, a)]
foldWithContext :: (List a, List c, Listed a ~ Listed c) => (c -> Listed a -> a -> b -> b) -> b -> a -> b
prependReverse :: List a => a -> a -> a
listFoldMap :: (List a, Monoid m) => (Listed a -> m) -> a -> m
class Sizable a
countDown :: Sizable a => Int -> a -> Maybe Int
listStructure :: List a => Bijection' a (Maybe (Listed a, a))
maybeMaximumBy :: Foldable l a => (a -> a -> Ordering) -> l -> Maybe a
maxBy :: (a -> a -> Ordering) -> a -> a -> a
unfoldlE :: (b -> Either c (b, a)) -> b -> (c, [a])
unfoldrE :: (b -> Either c (a, b)) -> b -> ([a], c)
instance List [a]


module Cgm.Data.Maybe
ifJust :: Bool -> a -> Maybe a
justIf :: a -> Bool -> Maybe a
predJust :: (a -> Bool) -> a -> Maybe a
firstJust :: Maybe a -> Maybe a -> Maybe a
maybeToEither :: b -> Maybe a -> Either b a

module Cgm.Data.Super
class Super a b
super :: Super a b => InjectionM' a b
up :: Super a b => a -> b
superSInc :: Super a b => a :>> b
narrowIntegral :: (Integral a, Integral b, Bounded b) => a -> Maybe b
instance Super Word8 Integer
instance Super Word Word64
instance Super Word32 Word
instance Super Word16 Word
instance Super Word8 Word
instance Super Word32 Word64
instance Super Word16 Word32
instance Super Word16 Word64
instance Super Word8 Word16
instance Super Word8 Word32
instance Super Word8 Word64

module Cgm.Data.WordN
data RWord w n
toRWord :: WordN w => w -> RWord w (WordNBits w)
fromRWord :: RWord w n -> w
rWord :: WordN w => Bijection' w (RWord w (WordNBits w))
class (Bits w, Integral w, Nat (WordNBits w)) => WordN w where type family WordNBits w :: *
wordNBits :: WordN w => w -> Int
boolAsWord :: Bijection' Bool (RWord Word8 D1)
class (WordN w, Nat n, Nat (WordNBits w :-: n)) => RWordC w n
type RWord8 = RWord Word8
type RWord16 = RWord Word16
type RWord32 = RWord Word32
type RWord64 = RWord Word64
rChangeWord :: (RWordC w n, RWordC w' n) => Bijection' (RWord w n) (RWord w' n)
rChangeWord' :: (RWordC w n, WordN w', Nat (WordNBits w' :-: WordNBits w)) => Bijection' (RWord w n) (RWord w' n)
rAdd :: Num w => RWord w n -> RWord w n -> RWord w (Succ n)
rWordJoin :: (Nat n, Nat m, Bits w) => RWord w n -> RWord w m -> Tagged n (RWord w (m :+: n))
rWordSplit :: (RWordC w (n :+: m), RWordC w n, RWordC w m) => RWord w (n :+: m) -> Tagged m (RWord w m, RWord w n)
rWordBool :: RWordC w D1 => RWord w D1 -> Bool
instance Typeable2 RWord
instance (Arbitrary w, RWordC w n) => Arbitrary (RWord w n)
instance RWordC w n => Num (RWord w n)
instance (Show w, RWordC w n) => Show (RWord w n)
instance RWordC w n => Eq (RWord w n)
instance RWordC w n => WordN (RWord w n)
instance RWordC w n => Integral (RWord w n)
instance RWordC w n => Real (RWord w n)
instance RWordC w n => Enum (RWord w n)
instance RWordC w n => Ord (RWord w n)
instance RWordC w n => Bits (RWord w n)
instance RWordC w n => Bounded (RWord w n)
instance (RWordC w n, RWordC w' n) => Super (RWord w n) w'
instance (WordN w, Nat n, Nat (WordNBits w :-: n)) => RWordC w n
instance WordN Word64
instance WordN Word32
instance WordN Word16
instance WordN Word8

module Cgm.Data.Word
class WordConv a
wordConv :: WordConv a => Bijection' Word a
onWordConv :: (WordConv Word32 => z) -> (WordConv Word64 => z) -> z
onWordConvB :: (Bijection' Word Word32 -> z) -> (Bijection' Word Word64 -> z) -> z
wordBits :: Integral a => a

-- | 0 &lt;= n &lt; wordBits
partialShiftL :: Word -> Word -> Word

-- | 0 &lt;= n &lt; wordBits
partialShiftRL :: Word -> Word -> Word
uShiftL :: Word -> Word -> Word
uShiftRL :: Word -> Word -> Word
unI# :: Int -> Int#
unW# :: Word -> Word#
class Signed u s | u -> s, s -> u
signed :: Signed u s => Bijection' u s
unsigned :: Signed u s => Bijection' s u
class WordConv1 a
wordConv1 :: (WordConv1 a, WordConv c) => Bijection' (a Word) (a c)
splitWord64LE :: Bijection' Word64 (Word32, Word32)
instance Signed Word Int
instance Signed Word64 Int64
instance Signed Word32 Int32
instance Signed Word16 Int16
instance Signed Word8 Int8
instance WordConv Word32

module Cgm.Data.LongWord
data Word128
word128BE :: Word64 -> Word64 -> Word128
instance Structured Word128
instance Eq Word128
instance Ord Word128
instance Show Word128

module Cgm.Data.Len
data Len u n
showLen :: (Show n, LgMultiple u Bool) => Len u n -> String
bitLen :: Integral a => Len Bool a
word8 :: Integral a => Len Word8 a
word16 :: Integral a => Len Word16 a
word32 :: Integral a => Len Word32 a
word64 :: Integral a => Len Word64 a
word :: Integral a => Len Word a
class LgMultiple a b
lgMul :: LgMultiple a b => LgMul a b
unsafeLen :: n -> Len u n
getLen :: Len u n -> n
wordLenB :: WordConv a => Bijection' (Len Word b) (Len a b)
bitSizeLen :: (Bits a, Integral b) => Tagged a (Len Bool b)
refineLen :: (Bits n, LgMultiple u v) => Len u n -> Len v n
coarsenLen :: (Bits n, Num n, LgMultiple v u) => Len u n -> Len v n
coarseRem :: (Bits n, Num n, LgMultiple v u) => Len u n -> (Len v n, Len u n)
ceilDivPower2 :: (Num a, Bits a) => Int -> a -> a
roundUpPower2 :: (Num a, Bits a) => Int -> a -> a
instance Structured (Len u0 n0)
instance Typeable2 Len
instance Ord n => Ord (Len u n)
instance Enum n => Enum (Len u n)
instance Real n => Real (Len u n)
instance Integral n => Integral (Len u n)
instance Num n => Num (Len u n)
instance Eq n => Eq (Len u n)
instance Bounded n => Bounded (Len u n)
instance Functor (Len u)
instance Super a b => Super (Len u a) (Len u b)
instance Category LgMul
instance LgMultiple Word64 Word
instance LgMultiple Word Word32
instance LgMultiple Word Word16
instance LgMultiple Word Word8
instance LgMultiple Word Bool
instance LgMultiple Word64 Word16
instance LgMultiple Word64 Word8
instance LgMultiple Word32 Word8
instance LgMultiple Word64 Bool
instance LgMultiple Word32 Bool
instance LgMultiple Word16 Bool
instance LgMultiple Word64 Word64
instance LgMultiple Word32 Word32
instance LgMultiple Word16 Word16
instance LgMultiple Word8 Word8
instance LgMultiple Bool Bool
instance LgMultiple Word64 Word32
instance LgMultiple Word32 Word16
instance LgMultiple Word16 Word8
instance LgMultiple Word8 Bool
instance Show n => Show (Len u n)

module Cgm.System.Mem.Alloc
mallocArrayLen :: (Storable a, Integral b) => Len a b -> IO (Ptr a)
copyArrayLen :: (Storable a, Integral b) => Ptr a -> Ptr a -> Len a b -> IO ()
advancePtrLen :: (Storable a, Integral b) => Ptr a -> Len a b -> Ptr a
minusPtrLen :: LgMultiple a Word8 => Ptr a -> Ptr a -> Len a Int
pokeLenOff :: (Show a, Storable a, Integral b) => Ptr a -> Len a b -> a -> IO ()
peekLenOff :: (Storable a, Integral b) => Ptr a -> Len a b -> IO a
hPutBufLen :: (Storable a, Integral b) => Handle -> Ptr a -> Len a b -> IO ()
hGetBufLen :: (Storable a, Integral b) => Handle -> Ptr a -> Len a b -> IO (Len a b)

module Cgm.Data.Array
type ArrayIx a = Len (ArrayElem a) Word
class Array a where type family ArrayElem a :: *
arrayLen :: Array a => a -> ArrayIx a
class Array a => ImmArray a
indexArray :: ImmArray a => a -> ArrayIx a -> ArrayElem a
class Array a => STArray a where type family ArrayState a :: *

-- | STArrays that are instantiable in GCed memory
class STArray a => STMkArray a
mkArray :: STMkArray a => ArrayIx a -> ArrayST a a

-- | STArrays that can be mutated using zero based indexing
class STArray a => STZArray a
readArray :: STZArray a => a -> ArrayIx a -> ArrayST a (ArrayElem a)
writeArray :: STZArray a => a -> ArrayIx a -> ArrayElem a -> ArrayST a ()
class Array a => PinnedArray a
withArrayPtr :: PinnedArray a => (Ptr (ArrayElem a) -> ArrayIx a -> IO b) -> a -> IO b
class Allocation f
newWord8Array :: Allocation f => Len Word8 Word -> ST s (STPrimArray s f Word8)
onAllocation :: Allocation f => (f ~ Free => z) -> (f ~ Pinned => z) -> Tagged f z
newAlignedPinnedWord8Array :: Len Word8 Word -> Len Word8 Word -> ST s (STPrimArray s f Word8)
withArrayByteString :: (PinnedArray a, ArrayElem a ~ Word8) => (ByteString -> IO b) -> a -> IO b
arrayFromByteString :: Allocation f => ByteString -> PrimArray f Word8
unsafeWithCastArrayByteString :: (PinnedArray a, Prim (ArrayElem a)) => (ByteString -> IO b) -> a -> IO b
data Free
data Pinned
primArrayMatchAllocation :: (Allocation f, Allocation f', Prim w) => ArrayRange (PrimArray f w) -> ArrayRange (PrimArray f' w)

-- | f is either Free or Pinned
data PrimArray f w
runSTPrimArray :: (forall s. ST s (STPrimArray s f w)) -> PrimArray f w

-- | Safe as long as the input array is not written to after this call. Use
--   the safe runSTPrimArray when possible.
unsafeFreezeSTPrimArray :: STPrimArray s f w -> ST s (PrimArray f w)

-- | f is either Free or Pinned
data STPrimArray s f w
data ArrayRange a
ArrayRange :: a -> (ArrayIx a) -> (ArrayIx a) -> ArrayRange a
fullArrayRange :: Array a => a -> ArrayRange a
skipArrayRange :: Array a => ArrayIx a -> ArrayRange a -> ArrayRange a
headArrayRange :: Array a => ArrayIx a -> ArrayRange a -> ArrayRange a
wordConvArrayRange :: WordConv c => Bijection' (ArrayRange (PrimArray f Word)) (ArrayRange (PrimArray f c))
unsafePrimArrayCast :: PrimArray f w -> PrimArray f w'
unsafeSTPrimArrayCast :: STPrimArray s f w -> STPrimArray s f w'
mapMArray :: STZArray a => (ArrayElem a -> ArrayST a (ArrayElem a)) -> a -> ArrayST a ()

-- | The number of elements copied is the minimum of the number of elements
--   in the source and the number of elements in the destination
mapMArrayCopy :: (STZArray a, STZArray b, ArrayState a ~ ArrayState b) => (ArrayElem a -> ArrayST a (ArrayElem b)) -> a -> b -> ArrayST a ()

-- | The number of elements copied is the minimum of the number of elements
--   in the source and the number of elements in the destination
mapMArrayCopyImm :: (ImmArray a, STZArray b) => (ArrayElem a -> ArrayST b (ArrayElem b)) -> a -> b -> ArrayST b ()
mapImmArray :: (Allocation f', Prim b, ImmArray r) => (ArrayElem r -> b) -> r -> PrimArray f' b
mkArrayWith :: (Allocation f, Prim a) => Len a Word -> (Len a Word -> a) -> PrimArray f a
ioToST :: IO a -> ST RealWorld a
primSizeOf :: Prim w => w -> Int

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
newtype ST s a :: * -> * -> *
ST :: STRep s a -> ST s a
instance WordConv1 (STPrimArray s f)
instance WordConv1 (PrimArray f)
instance (Prim (ArrayElem a), PinnedArray a) => PinnedArray (ArrayRange a)
instance STZArray a => STZArray (ArrayRange a)
instance STArray a => STArray (ArrayRange a)
instance ImmArray a => ImmArray (ArrayRange a)
instance Array a => Array (ArrayRange a)
instance (ImmArray a, Show (ArrayElem a)) => Show (ArrayRange a)
instance (ImmArray a, Eq (ArrayElem a), Prim (ArrayElem a)) => Eq (ArrayRange a)
instance Prim w => PinnedArray (PrimArray Pinned w)
instance Prim w => ImmArray (PrimArray f w)
instance Prim w => Array (PrimArray f w)
instance (Prim w, Show w) => Show (PrimArray f w)
instance (Prim w, Eq w) => Eq (PrimArray f w)
instance Prim w => PinnedArray (STPrimArray s Pinned w)
instance Prim w => STZArray (STPrimArray s f w)
instance (Allocation f, Prim w) => STMkArray (STPrimArray s f w)
instance Prim w => STArray (STPrimArray s f w)
instance Prim w => Array (STPrimArray s f w)
instance Eq (STPrimArray s f w)
instance Allocation Pinned
instance Allocation Free

module Cgm.Data.Multiset
class Multiset a
emptySet :: Multiset a => a e
insert :: (Multiset a, Ord e) => e -> a e -> a e
delete :: (Multiset a, Ord e) => e -> a e -> Maybe (a e)
instance Multiset []

module Cgm.Data.MapMultiset
data MapMultiset a
instance Typeable1 MapMultiset
instance Ord a => Monoid (MapMultiset a)
instance Multiset MapMultiset

module Cgm.System.Endian
class (Prim w, Bits w, Num w) => Endian w
untypedSwapBytes :: Endian w => w -> w
swapHalves :: Bits w => w -> w
ixBytes :: Endian w => w -> [Word8]
littleEndianIxBytes :: Prim w => Tagged w [Word8]
bigEndianIxBytes :: Prim w => Tagged w [Word8]

-- | Undefined when the platform is neither big nor little endian.
platformEndianness :: Endian w => Tagged w Endianness
platformWordEndianness :: Endianness
data ByteSwapped w
swapBytes :: Endian w => w -> ByteSwapped w
unswapBytes :: Endian w => ByteSwapped w -> w
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness
reverseEndianness :: Endianness -> Endianness
instance Structured Endianness
instance Eq Endianness
instance Show Endianness
instance Prim w => Prim (ByteSwapped w)
instance Show w => Show (ByteSwapped w)
instance Endian Word
instance Endian Word64
instance Endian Word32
instance Endian Word16
instance Endian Word8
