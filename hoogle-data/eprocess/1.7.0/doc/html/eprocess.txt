-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | *Very* basic Erlang-like process support for Haskell
--   
--   This library provides a *very* basic support for processes with
--   message queues. It was built using channels, threads and MVars. Since
--   version 1.1.0 you can also kill a running process.
@package eprocess
@version 1.7.0


-- | This module provides a *very* basic support for processes with message
--   queues. It was built using channels and MVars.
module Control.Concurrent.Process

-- | The <i>ReceiverT</i> generic type.
--   
--   <ul>
--   <li><i><tt>r</tt></i> the type of things the process will receive</li>
--   <li><i><tt>m</tt></i> the monad in which it will run</li>
--   <li><i><tt>a</tt></i> the classic monad parameter</li>
--   </ul>
data ReceiverT r m a

-- | A Process handle. It's returned on process creation and should be used
--   | afterwards to send messages to it
data Handle r

-- | <i>Process</i> are receivers that run in the IO Monad
type Process r = ReceiverT r IO

-- | <i>makeProcess</i> builds a process from a code that generates an IO
--   action. Usage: <tt> process &lt;- makeProcess evalFunction receiver
--   </tt>
makeProcess :: (m t -> IO s) -> ReceiverT r m t -> Process r s

-- | <i>runHere</i> executes process code in the current environment.
--   Usage: <tt> result &lt;- runHere process </tt>
runHere :: MonadIO m => Process r t -> m t

-- | <i>spawn</i> starts a process and returns its handle. Usage: <tt>
--   handle &lt;- spawn process </tt>
spawn :: MonadIO m => Process r k -> m (Handle r)

-- | <i>kill</i> lets you *brutally* terminate a running process. Usage:
--   <tt> kill processHandle </tt>
kill :: MonadIO m => Handle a -> m ()

-- | <i>self</i> returns the handle of the current process. Usage: <tt>
--   handle &lt;- self </tt>
self :: Monad m => ReceiverT r m (Handle r)

-- | <i>sendTo</i> lets you send a message to a running process. Usage:
--   <tt> sendTo processHandle message </tt>
sendTo :: MonadIO m => Handle a -> a -> m ()

-- | <i>recv</i> lets you receive a message in a running process (it's a
--   blocking receive). Usage: <tt> message &lt;- recv </tt>
recv :: MonadIO m => ReceiverT r m r

-- | Just like <i>recv</i> but with a timeout parameter. Usage: <tt>
--   maybeMessage &lt;- recv </tt>
recvIn :: MonadIO m => Int -> ReceiverT r m (Maybe r)

-- | <i>sendRecv</i> is just a syntactic sugar for: <tt> sendTo h a
--   &gt;&gt; recv </tt>
sendRecv :: MonadIO m => Handle a -> a -> ReceiverT r m r
instance Monad m => Monad (ReceiverT r m)
instance MonadIO m => MonadIO (ReceiverT r m)
instance MonadTrans (ReceiverT r)
instance MonadCatch m => MonadCatch (ReceiverT r m)
instance MonadThrow m => MonadThrow (ReceiverT r m)
instance MonadMask m => MonadMask (ReceiverT r m)
instance MonadError e m => MonadError e (ReceiverT r m)
instance (Monoid w, MonadWriter w m) => MonadWriter w (ReceiverT w m)
instance MonadReader r m => MonadReader r (ReceiverT r m)
instance MonadState s m => MonadState s (ReceiverT r m)
