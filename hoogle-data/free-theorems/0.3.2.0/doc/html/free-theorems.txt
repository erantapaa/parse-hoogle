-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic generation of free theorems.
--   
--   The free-theorems library allows to automatically generate free
--   theorems from Haskell type expressions. It supports nearly all Haskell
--   98 types except of type constructor classes, and in addition it can
--   also handle higher-rank functions. Free theorems are generated for
--   three different sublanguages of Haskell, a basic one corresponding to
--   the polymorphic lambda-calculus of Girard-Reynolds, an extension of
--   that allowing for recursion and errors, and finally a sublanguage
--   additionally allowing seq. In the last two sublanguages, also
--   inequational free theorems may be derived in addition to classical
--   equational results.
@package free-theorems
@version 0.3.2.0


-- | Provides functions to generate new variable names of different kinds.
module Language.Haskell.FreeTheorems.NameStores

-- | An infinite list of names for type variables.
typeNameStore :: [String]

-- | An infinite list of names for relation variables.
relationNameStore :: [String]

-- | An infinite list of names for type expressions.
typeExpressionNameStore :: [String]

-- | An infinite list of names for function variables.
functionNameStore1 :: [String]

-- | Another infinite list of names for function variables.
functionNameStore2 :: [String]

-- | An infinite list of names for term variables.
variableNameStore :: [String]


-- | Declares the basic syntax of a Haskell98 subset enriched with
--   higher-ranked functions. Additionally, it defines small convenience
--   functions.
module Language.Haskell.FreeTheorems.BasicSyntax

-- | A Haskell declaration which corresponds to a <tt>type</tt>,
--   <tt>data</tt>, <tt>newtype</tt>, <tt>class</tt> or type signature
--   declaration.
--   
--   In type expressions, type variables must not be applied to type
--   expressions. Thus, for example, the functions of the <tt>Monad</tt>
--   class are not expressible. However, in extension to Haskell98,
--   higher-rank types can be expressed.
--   
--   This data type does not reflect all information of a declaration. Only
--   the aspects needed by the FreeTheorems library are covered.
data Declaration

-- | A <tt>type</tt> declaration.
TypeDecl :: TypeDeclaration -> Declaration

-- | A <tt>data</tt> declaration.
DataDecl :: DataDeclaration -> Declaration

-- | A <tt>newtype</tt> declaration.
NewtypeDecl :: NewtypeDeclaration -> Declaration

-- | A <tt>class</tt> declaration.
ClassDecl :: ClassDeclaration -> Declaration

-- | A type signature.
TypeSig :: Signature -> Declaration

-- | Gets the name of the item declared by a declaration. This is the type
--   constructor for <tt>data</tt>, <tt>newtype</tt> and <tt>type</tt>
--   declarations, the name of a class for a <tt>class</tt> declaration or
--   the name of a type signature.
getDeclarationName :: Declaration -> Identifier

-- | Gets the arity of a type constructor or <tt>Nothing</tt> if this is
--   not a <tt>data</tt>, <tt>newtype</tt> or <tt>type</tt> declaration.
getDeclarationArity :: Declaration -> Maybe Int

-- | A <tt>type</tt> declaration for a type synonym.
data TypeDeclaration
Type :: Identifier -> [TypeVariable] -> TypeExpression -> TypeDeclaration

-- | The type constructor name.
typeName :: TypeDeclaration -> Identifier

-- | The type variables on the left-hand side.
typeVars :: TypeDeclaration -> [TypeVariable]

-- | The type expression on the right-hand side.
typeRhs :: TypeDeclaration -> TypeExpression

-- | A <tt>data</tt> declaration for an algebraic data type.
--   
--   Note that the context and the deriving parts of a <tt>data</tt>
--   declaration are ignored.
data DataDeclaration
Data :: Identifier -> [TypeVariable] -> [DataConstructorDeclaration] -> DataDeclaration

-- | The name of the type constructor.
dataName :: DataDeclaration -> Identifier

-- | The type variables on the left-hand side.
dataVars :: DataDeclaration -> [TypeVariable]

-- | The declarations of the data constructors on the right-hand side.
dataCons :: DataDeclaration -> [DataConstructorDeclaration]

-- | A <tt>newtype</tt> declaration for a type renaming.
--   
--   Note that the context and the deriving parts of a <tt>newtype</tt>
--   declaration are ignored.
data NewtypeDeclaration
Newtype :: Identifier -> [TypeVariable] -> Identifier -> TypeExpression -> NewtypeDeclaration

-- | The name of the type constructor.
newtypeName :: NewtypeDeclaration -> Identifier

-- | The type variables of the left-hand side.
newtypeVars :: NewtypeDeclaration -> [TypeVariable]

-- | The name of the data constructor on the right-hand side.
newtypeCon :: NewtypeDeclaration -> Identifier

-- | The type expression on the right-hand side.
newtypeRhs :: NewtypeDeclaration -> TypeExpression

-- | A <tt>class</tt> declaration for a type class.
--   
--   Note that, except of type signatures of class methods, all other
--   declarations inside the class are ignored.
data ClassDeclaration
Class :: [TypeClass] -> Identifier -> TypeVariable -> [Signature] -> ClassDeclaration

-- | The superclasses of this class.
superClasses :: ClassDeclaration -> [TypeClass]

-- | The name of this type class.
className :: ClassDeclaration -> Identifier

-- | The type variable constrained by this type class.
classVar :: ClassDeclaration -> TypeVariable

-- | The type signatures of the class methods.
classFuns :: ClassDeclaration -> [Signature]

-- | A type signature.
data Signature
Signature :: Identifier -> TypeExpression -> Signature

-- | The name of the signature, i.e. the name of a variable or function.
signatureName :: Signature -> Identifier

-- | The type expression of the type signature.
signatureType :: Signature -> TypeExpression

-- | An identifier. This data type tags every <tt>String</tt> occurring in
--   a declaration or a type expression.
newtype Identifier
Ident :: String -> Identifier
unpackIdent :: Identifier -> String

-- | A data constructor declaration.
data DataConstructorDeclaration
DataCon :: Identifier -> [BangTypeExpression] -> DataConstructorDeclaration

-- | The name of the data constructor.
dataConName :: DataConstructorDeclaration -> Identifier

-- | The type arguments of the data constructor.
dataConTypes :: DataConstructorDeclaration -> [BangTypeExpression]

-- | Indicates whether in an algebraic data type declaration a strictness
--   annotation is used.
data BangTypeExpression

-- | A type expression with a strictness flag "<tt>!</tt>".
Banged :: TypeExpression -> BangTypeExpression
withoutBang :: BangTypeExpression -> TypeExpression

-- | A type expression without a strictness flag.
Unbanged :: TypeExpression -> BangTypeExpression
withoutBang :: BangTypeExpression -> TypeExpression

-- | A Haskell type expression. This data type supports also higher-rank
--   functions. Unlike in Haskell98, a type variable must not be applied to
--   type expressions.
data TypeExpression

-- | A type variable.
TypeVar :: TypeVariable -> TypeExpression

-- | A type constructor. This covers algebraic data types, type synonyms,
--   and type renamings as well as predefined standard data types like
--   lists and tuples.
TypeCon :: TypeConstructor -> [TypeExpression] -> TypeExpression

-- | The function type constructor <tt>-&gt;</tt>.
TypeFun :: TypeExpression -> TypeExpression -> TypeExpression

-- | The function type constructor <tt>-&gt;^o</tt> for the
--   non-bottom-reflecting logical relation for functions in the
--   languagesubset with seq for equational theorems.
TypeFunLab :: TypeExpression -> TypeExpression -> TypeExpression

-- | The type abstraction constructor <tt>forall</tt>.
TypeAbs :: TypeVariable -> [TypeClass] -> TypeExpression -> TypeExpression

-- | The type abstraction constructor <tt>forall^o</tt>, allowing
--   non-bottom-reflecting logical relations for types the type variable is
--   instantiated with in the calculus with seq.
TypeAbsLab :: TypeVariable -> [TypeClass] -> TypeExpression -> TypeExpression

-- | A variable representing a fixed type expression.
TypeExp :: FixedTypeExpression -> TypeExpression

-- | The data type for type constructors.
data TypeConstructor

-- | The unit type constructor <tt>()</tt>.
ConUnit :: TypeConstructor

-- | The list type constructor <tt>[]</tt>.
ConList :: TypeConstructor

-- | The tuple type constructors with given arity.
ConTuple :: Int -> TypeConstructor

-- | The Haskell type <tt>Int</tt>.
ConInt :: TypeConstructor

-- | The Haskell type <tt>Integer</tt>.
ConInteger :: TypeConstructor

-- | The Haskell type <tt>Float</tt>.
ConFloat :: TypeConstructor

-- | The Haskell type <tt>Double</tt>.
ConDouble :: TypeConstructor

-- | The Haskell type <tt>Char</tt>.
ConChar :: TypeConstructor

-- | Any other type constructor with a given name.
Con :: Identifier -> TypeConstructor

-- | Identifies a Haskell type class.
newtype TypeClass
TC :: Identifier -> TypeClass

-- | Identifies a Haskell type variable
newtype TypeVariable
TV :: Identifier -> TypeVariable

-- | Represents an abbreviation for some fixed type expression. It does not
--   occur in Haskell98 source code, but it can occur in generated
--   theorems.
newtype FixedTypeExpression
TF :: Identifier -> FixedTypeExpression
instance Typeable Identifier
instance Typeable TypeConstructor
instance Typeable TypeClass
instance Typeable TypeVariable
instance Typeable FixedTypeExpression
instance Typeable TypeExpression
instance Typeable BangTypeExpression
instance Typeable DataConstructorDeclaration
instance Typeable DataDeclaration
instance Typeable Signature
instance Typeable ClassDeclaration
instance Typeable NewtypeDeclaration
instance Typeable TypeDeclaration
instance Typeable Declaration
instance Eq Identifier
instance Ord Identifier
instance Data Identifier
instance Eq TypeConstructor
instance Data TypeConstructor
instance Eq TypeClass
instance Data TypeClass
instance Eq TypeVariable
instance Ord TypeVariable
instance Data TypeVariable
instance Eq FixedTypeExpression
instance Data FixedTypeExpression
instance Eq TypeExpression
instance Data TypeExpression
instance Eq BangTypeExpression
instance Data BangTypeExpression
instance Eq DataConstructorDeclaration
instance Data DataConstructorDeclaration
instance Eq DataDeclaration
instance Data DataDeclaration
instance Eq Signature
instance Data Signature
instance Eq ClassDeclaration
instance Data ClassDeclaration
instance Eq NewtypeDeclaration
instance Data NewtypeDeclaration
instance Eq TypeDeclaration
instance Data TypeDeclaration
instance Eq Declaration
instance Data Declaration


-- | Declares data types which describe valid declarations and valid type
--   signatures. A declaration or type signature is valid when all checks
--   (see <a>Language.Haskell.FreeTheorems.Frontend</a>) were passed
--   successfully.
module Language.Haskell.FreeTheorems.ValidSyntax

-- | Marks a valid declaration.
data ValidDeclaration
ValidDeclaration :: Declaration -> Bool -> ValidDeclaration

-- | Returns the declaration structure hidden in a valid declaration.
rawDeclaration :: ValidDeclaration -> Declaration

-- | Indicates whether the declarations declares or depends on an algebraic
--   data type with strictness flag.
isStrictDeclaration :: ValidDeclaration -> Bool

-- | Marks a valid type signature.
newtype ValidSignature
ValidSignature :: Signature -> ValidSignature

-- | Returns the signature structure hidden in a valid type signature.
rawSignature :: ValidSignature -> Signature

-- | Extracts all type signatures from a list of declarations.
filterSignatures :: [ValidDeclaration] -> [ValidSignature]


-- | Data structures to describe theorems generated from types.
module Language.Haskell.FreeTheorems.Theorems

-- | A theorem which is generated from a type signature.
type Theorem = Formula

-- | Logical formula constituting automatically generated theorems.
data Formula

-- | Quantifies a relation variable and two type expressions.
ForallRelations :: RelationVariable -> (TypeExpression, TypeExpression) -> [Restriction] -> Formula -> Formula

-- | Quantifies a function variable and two type expressions.
ForallFunctions :: (Either TermVariable TermVariable) -> (TypeExpression, TypeExpression) -> [Restriction] -> Formula -> Formula

-- | Quantifies two term variables taken from a relation.
ForallPairs :: (TermVariable, TermVariable) -> Relation -> Formula -> Formula

-- | Quantifies a term variable of a certain type.
ForallVariables :: TermVariable -> TypeExpression -> Formula -> Formula

-- | Two formulas are equivalent.
Equivalence :: Formula -> Formula -> Formula

-- | The first formula implies the second formula.
Implication :: Formula -> Formula -> Formula

-- | The first formula and the second formula.
Conjunction :: Formula -> Formula -> Formula

-- | A basic formula.
Predicate :: Predicate -> Formula

-- | Restrictions on functions and relations.
data Restriction
Strict :: Restriction
Continuous :: Restriction
Total :: Restriction
BottomReflecting :: Restriction
LeftClosed :: Restriction
RespectsClasses :: [TypeClass] -> Restriction

-- | Predicates occurring in formulas.
data Predicate

-- | The pair of two terms is contained in a relation.
IsMember :: Term -> Term -> Relation -> Predicate

-- | Two terms are equal.
IsEqual :: Term -> Term -> Predicate

-- | The first term is less defined than the second one, based on the
--   semantical approximation order.
IsLessEq :: Term -> Term -> Predicate

-- | The term is not equal to <tt>_|_</tt>.
IsNotBot :: Term -> Predicate

-- | Constant True Predicate
IsTrue :: Predicate

-- | Terms consisting of variables, applications and instantiations.
data Term

-- | A term variable.
TermVar :: TermVariable -> Term

-- | Instantiation of a term.
TermIns :: Term -> TypeExpression -> Term

-- | Application of a term to a term.
TermApp :: Term -> Term -> Term

-- | Composition of function terms
TermComp :: [Term] -> Term

-- | Variables occurring in terms.
newtype TermVariable
TVar :: String -> TermVariable

-- | Relations are the foundations of free theorems.
data Relation

-- | A relation variable.
RelVar :: RelationInfo -> RelationVariable -> Relation

-- | A function variable. It might be either a function to be applied on
--   the left side (in equational and inequational cases) or on the right
--   side (in inequational cases only). In inequational cases, the term is
--   additionally composed with the semantic approximation partial order.
FunVar :: RelationInfo -> (Either Term Term) -> Relation

-- | A basic relation corresponding to a nullary type constructor.
--   Depending on the theorem type, this can be either an equivalence
--   relation or the semantic approximation partial order.
RelBasic :: RelationInfo -> Relation

-- | A lifted relation for any nonnullary type constructor. The semantics
--   of lifted relations is differs with the language subset: In
--   inequational subsets lifted relations explicitly require
--   left-closedness by composition with the semantic approximation partial
--   order. In equational subsets with fix or seq, this relation requires
--   strictness explicitly by relating the undefined value with itself.
RelLift :: RelationInfo -> TypeConstructor -> [Relation] -> Relation

-- | A relation corresponding to a function type constructor. The semantics
--   of this relation differs with the language subset: In the equational
--   subset with seq, this relation is explicitly requiring
--   bottom-reflectiveness of its members. In the inequational subset with
--   seq, this relation is explicitly requiring totality of its members.
RelFun :: RelationInfo -> Relation -> Relation -> Relation

-- | A relation corresponding to a function type constructor. The semantics
--   of this relation differs with the language subset: Apart from the
--   equational subset with seq, it is equal to RelFun. In the equational
--   subset with Seq, this relation is _not_ explicitly requiring
--   bottom-reflectiveness of its members.
RelFunLab :: RelationInfo -> Relation -> Relation -> Relation

-- | A relation corresponding to a type abstraction.
RelAbs :: RelationInfo -> RelationVariable -> (TypeExpression, TypeExpression) -> [Restriction] -> Relation -> Relation

-- | A quantified function.
FunAbs :: RelationInfo -> (Either TermVariable TermVariable) -> (TypeExpression, TypeExpression) -> [Restriction] -> Relation -> Relation

-- | Extracts the relation information from a relation.
relationInfo :: Relation -> RelationInfo

-- | The relation information stored with every relation.
data RelationInfo
RelationInfo :: LanguageSubset -> TypeExpression -> TypeExpression -> RelationInfo

-- | The language subset in which a relation was generated.
relationLanguageSubset :: RelationInfo -> LanguageSubset

-- | The type of the first components of pairs contained in a relation.
relationLeftType :: RelationInfo -> TypeExpression

-- | The type of the second components of pairs contained in a relation.
relationRightType :: RelationInfo -> TypeExpression

-- | A relation variable.
newtype RelationVariable
RVar :: String -> RelationVariable

-- | Describes unfolded lift relations.
data UnfoldedLift
UnfoldedLift :: Relation -> [UnfoldedDataCon] -> UnfoldedLift

-- | A relational descriptions of a data constructor.
data UnfoldedDataCon
BotPair :: UnfoldedDataCon
ConPair :: DataConstructor -> UnfoldedDataCon
ConMore :: DataConstructor -> [TermVariable] -> [TermVariable] -> Formula -> UnfoldedDataCon

-- | Data constructors.
data DataConstructor

-- | The nullary data constructor <tt>[]</tt>.
DConEmptyList :: DataConstructor

-- | The binary data constructor <tt>:</tt>.
DConConsList :: DataConstructor

-- | The n-ary tuple data constructor.
DConTuple :: Int -> DataConstructor

-- | Any other data constructor.
DCon :: String -> DataConstructor

-- | A relational description of a class declaration.
data UnfoldedClass
UnfoldedClass :: [TypeClass] -> TypeClass -> (Either RelationVariable TermVariable) -> [Formula] -> UnfoldedClass
instance Typeable Restriction
instance Typeable TermVariable
instance Typeable Term
instance Typeable RelationInfo
instance Typeable RelationVariable
instance Typeable Relation
instance Typeable Predicate
instance Typeable Formula
instance Typeable DataConstructor
instance Typeable UnfoldedDataCon
instance Typeable UnfoldedLift
instance Typeable UnfoldedClass
instance Data Restriction
instance Eq Restriction
instance Data TermVariable
instance Eq TermVariable
instance Data Term
instance Eq Term
instance Data RelationInfo
instance Eq RelationInfo
instance Data RelationVariable
instance Eq RelationVariable
instance Data Relation
instance Eq Relation
instance Data Predicate
instance Data Formula
instance Data DataConstructor
instance Data UnfoldedDataCon
instance Data UnfoldedLift
instance Data UnfoldedClass


-- | Declars data types describing the abstract syntax of a subset of
--   Haskell in the FreeTheorems library. Only declarations and type
--   expressions are covered by these data types.
--   
--   Note that the data types of this module do not reflect Haskell98. This
--   is because they are able to express higher-rank functions which are
--   not part of Haskell98. Also, in type expressions, a type variable must
--   not be applied to any type expression. Thus, for example, the type
--   <tt>m a</tt>, as occuring in the functions of the <tt>Monad</tt> type
--   class, is not expressable. The reason for this restriction is that the
--   FreeTheorems library cannot handle such types.
module Language.Haskell.FreeTheorems.Syntax

-- | A Haskell declaration which corresponds to a <tt>type</tt>,
--   <tt>data</tt>, <tt>newtype</tt>, <tt>class</tt> or type signature
--   declaration.
--   
--   In type expressions, type variables must not be applied to type
--   expressions. Thus, for example, the functions of the <tt>Monad</tt>
--   class are not expressible. However, in extension to Haskell98,
--   higher-rank types can be expressed.
--   
--   This data type does not reflect all information of a declaration. Only
--   the aspects needed by the FreeTheorems library are covered.
data Declaration

-- | A <tt>type</tt> declaration.
TypeDecl :: TypeDeclaration -> Declaration

-- | A <tt>data</tt> declaration.
DataDecl :: DataDeclaration -> Declaration

-- | A <tt>newtype</tt> declaration.
NewtypeDecl :: NewtypeDeclaration -> Declaration

-- | A <tt>class</tt> declaration.
ClassDecl :: ClassDeclaration -> Declaration

-- | A type signature.
TypeSig :: Signature -> Declaration

-- | Gets the name of the item declared by a declaration. This is the type
--   constructor for <tt>data</tt>, <tt>newtype</tt> and <tt>type</tt>
--   declarations, the name of a class for a <tt>class</tt> declaration or
--   the name of a type signature.
getDeclarationName :: Declaration -> Identifier

-- | Gets the arity of a type constructor or <tt>Nothing</tt> if this is
--   not a <tt>data</tt>, <tt>newtype</tt> or <tt>type</tt> declaration.
getDeclarationArity :: Declaration -> Maybe Int

-- | A <tt>data</tt> declaration for an algebraic data type.
--   
--   Note that the context and the deriving parts of a <tt>data</tt>
--   declaration are ignored.
data DataDeclaration
Data :: Identifier -> [TypeVariable] -> [DataConstructorDeclaration] -> DataDeclaration

-- | The name of the type constructor.
dataName :: DataDeclaration -> Identifier

-- | The type variables on the left-hand side.
dataVars :: DataDeclaration -> [TypeVariable]

-- | The declarations of the data constructors on the right-hand side.
dataCons :: DataDeclaration -> [DataConstructorDeclaration]

-- | A <tt>newtype</tt> declaration for a type renaming.
--   
--   Note that the context and the deriving parts of a <tt>newtype</tt>
--   declaration are ignored.
data NewtypeDeclaration
Newtype :: Identifier -> [TypeVariable] -> Identifier -> TypeExpression -> NewtypeDeclaration

-- | The name of the type constructor.
newtypeName :: NewtypeDeclaration -> Identifier

-- | The type variables of the left-hand side.
newtypeVars :: NewtypeDeclaration -> [TypeVariable]

-- | The name of the data constructor on the right-hand side.
newtypeCon :: NewtypeDeclaration -> Identifier

-- | The type expression on the right-hand side.
newtypeRhs :: NewtypeDeclaration -> TypeExpression

-- | A <tt>type</tt> declaration for a type synonym.
data TypeDeclaration
Type :: Identifier -> [TypeVariable] -> TypeExpression -> TypeDeclaration

-- | The type constructor name.
typeName :: TypeDeclaration -> Identifier

-- | The type variables on the left-hand side.
typeVars :: TypeDeclaration -> [TypeVariable]

-- | The type expression on the right-hand side.
typeRhs :: TypeDeclaration -> TypeExpression

-- | A <tt>class</tt> declaration for a type class.
--   
--   Note that, except of type signatures of class methods, all other
--   declarations inside the class are ignored.
data ClassDeclaration
Class :: [TypeClass] -> Identifier -> TypeVariable -> [Signature] -> ClassDeclaration

-- | The superclasses of this class.
superClasses :: ClassDeclaration -> [TypeClass]

-- | The name of this type class.
className :: ClassDeclaration -> Identifier

-- | The type variable constrained by this type class.
classVar :: ClassDeclaration -> TypeVariable

-- | The type signatures of the class methods.
classFuns :: ClassDeclaration -> [Signature]

-- | A type signature.
data Signature
Signature :: Identifier -> TypeExpression -> Signature

-- | The name of the signature, i.e. the name of a variable or function.
signatureName :: Signature -> Identifier

-- | The type expression of the type signature.
signatureType :: Signature -> TypeExpression

-- | A data constructor declaration.
data DataConstructorDeclaration
DataCon :: Identifier -> [BangTypeExpression] -> DataConstructorDeclaration

-- | The name of the data constructor.
dataConName :: DataConstructorDeclaration -> Identifier

-- | The type arguments of the data constructor.
dataConTypes :: DataConstructorDeclaration -> [BangTypeExpression]

-- | Indicates whether in an algebraic data type declaration a strictness
--   annotation is used.
data BangTypeExpression

-- | A type expression with a strictness flag "<tt>!</tt>".
Banged :: TypeExpression -> BangTypeExpression
withoutBang :: BangTypeExpression -> TypeExpression

-- | A type expression without a strictness flag.
Unbanged :: TypeExpression -> BangTypeExpression
withoutBang :: BangTypeExpression -> TypeExpression

-- | A Haskell type expression. This data type supports also higher-rank
--   functions. Unlike in Haskell98, a type variable must not be applied to
--   type expressions.
data TypeExpression

-- | A type variable.
TypeVar :: TypeVariable -> TypeExpression

-- | A type constructor. This covers algebraic data types, type synonyms,
--   and type renamings as well as predefined standard data types like
--   lists and tuples.
TypeCon :: TypeConstructor -> [TypeExpression] -> TypeExpression

-- | The function type constructor <tt>-&gt;</tt>.
TypeFun :: TypeExpression -> TypeExpression -> TypeExpression

-- | The function type constructor <tt>-&gt;^o</tt> for the
--   non-bottom-reflecting logical relation for functions in the
--   languagesubset with seq for equational theorems.
TypeFunLab :: TypeExpression -> TypeExpression -> TypeExpression

-- | The type abstraction constructor <tt>forall</tt>.
TypeAbs :: TypeVariable -> [TypeClass] -> TypeExpression -> TypeExpression

-- | The type abstraction constructor <tt>forall^o</tt>, allowing
--   non-bottom-reflecting logical relations for types the type variable is
--   instantiated with in the calculus with seq.
TypeAbsLab :: TypeVariable -> [TypeClass] -> TypeExpression -> TypeExpression

-- | A variable representing a fixed type expression.
TypeExp :: FixedTypeExpression -> TypeExpression

-- | The data type for type constructors.
data TypeConstructor

-- | The unit type constructor <tt>()</tt>.
ConUnit :: TypeConstructor

-- | The list type constructor <tt>[]</tt>.
ConList :: TypeConstructor

-- | The tuple type constructors with given arity.
ConTuple :: Int -> TypeConstructor

-- | The Haskell type <tt>Int</tt>.
ConInt :: TypeConstructor

-- | The Haskell type <tt>Integer</tt>.
ConInteger :: TypeConstructor

-- | The Haskell type <tt>Float</tt>.
ConFloat :: TypeConstructor

-- | The Haskell type <tt>Double</tt>.
ConDouble :: TypeConstructor

-- | The Haskell type <tt>Char</tt>.
ConChar :: TypeConstructor

-- | Any other type constructor with a given name.
Con :: Identifier -> TypeConstructor

-- | Identifies a Haskell type class.
newtype TypeClass
TC :: Identifier -> TypeClass

-- | Identifies a Haskell type variable
newtype TypeVariable
TV :: Identifier -> TypeVariable

-- | Represents an abbreviation for some fixed type expression. It does not
--   occur in Haskell98 source code, but it can occur in generated
--   theorems.
newtype FixedTypeExpression
TF :: Identifier -> FixedTypeExpression

-- | An identifier. This data type tags every <tt>String</tt> occurring in
--   a declaration or a type expression.
newtype Identifier
Ident :: String -> Identifier
unpackIdent :: Identifier -> String


-- | Defines a function to parse a string into a list of declarations. This
--   module is based on the 'haskell-src' package most probably included
--   with every Haskell compiler.
module Language.Haskell.FreeTheorems.Parser.Haskell98

-- | Parses a string to a list of declarations. The string should contain a
--   Haskell module.
--   
--   This function is based on the Haskell98 parser of the 'haskell-src'
--   package, i.e. the module 'Language.Haskell.Parser'. That parser
--   supports only Haskell98 and a few extensions. Especially, it does not
--   support explicit quantification of type variables and thus no
--   higher-rank functions.
--   
--   The declarations returned by <a>parse</a> include only <tt>type</tt>,
--   <tt>data</tt>, <tt>newtype</tt>, <tt>class</tt> and type signature
--   declarations. All other declarations and syntactical elements in the
--   input are ignored.
--   
--   Furthermore, the following restrictions apply:
--   
--   <ul>
--   <li>Multi-parameter type classes are not allowed and therefore
--   ignored. When declaring a type class, the argument to the type class
--   name must be a single type variable.</li>
--   <li>A type variable must not be applied to any type. That means, for
--   example, that the type <tt>m a</tt> is not accepted.</li>
--   <li>Contexts and <tt>deriving</tt> parts in <tt>data</tt> and
--   <tt>newtype</tt> declarations are ignored.</li>
--   <li>The module names are ignored. If any identifier was given
--   qualified, the module part of a qualified name is ignored.</li>
--   <li>Special Haskell constructors (unit, list function) are not allowed
--   as identifiers.</li>
--   </ul>
--   
--   If a parser error occurs, as suitable error message is returned in the
--   second component of the returned tuple and the first component will be
--   the empty list. However, if parsing was successful, but the parsed
--   structures could not be completely transformed into
--   <tt>Declaration</tt>s, suitable transformation error messages are
--   returned in the second component while the first components contains
--   all declarations which could be transformed successfully.
parse :: String -> Parsed [Declaration]

module Language.Haskell.FreeTheorems.Parser.Hsx

-- | Parses a string to a list of declarations. The string should contain a
--   Haskell module.
--   
--   This function is based on the extended Haskell parser of the
--   'haskell-src-exts' package.
--   
--   The declarations returned by <a>parse</a> include only <tt>type</tt>,
--   <tt>data</tt>, <tt>newtype</tt>, <tt>class</tt> and type signature
--   declarations. All other declarations and syntactical elements in the
--   input are ignored.
--   
--   Furthermore, the following restrictions apply:
--   
--   <ul>
--   <li>Multi-parameter type classes are not allowed and therefore
--   ignored. When declaring a type class, the argument to the type class
--   name must be a single type variable.</li>
--   <li>Only type variables can be constrained by type classes. That
--   means, for example, the type <tt>Eq [a] =&gt; [a]</tt> is not
--   accepted.</li>
--   <li>A type variable must not be applied to any type. That means, for
--   example, that the type <tt>m a</tt> is not accepted.</li>
--   <li>Contexts and <tt>deriving</tt> parts in <tt>data</tt> and
--   <tt>newtype</tt> declarations are ignored.</li>
--   <li>The module names are ignored. If any identifier was given
--   qualified, the module part of a qualified name is ignored.</li>
--   <li>Special Haskell constructors (unit, list function) are not allowed
--   as identifiers.</li>
--   <li>Further extensions over Haskell98 allowed by the underlying parser
--   are also forbidden, namely generalised algebraic data types and
--   unboxed tuples.</li>
--   </ul>
--   
--   If a parser error occurs, as suitable error message is returned in the
--   second component of the returned tuple and the first component will be
--   the empty list. However, if parsing was successful, but the parsed
--   structures could not be completely transformed into
--   <tt>Declaration</tt>s, suitable transformation error messages are
--   returned in the second component while the first components contains
--   all declarations which could be transformed successfully.
parse :: String -> Parsed [Declaration]


-- | Data structures and functions to automatically generate free theorems.
--   
--   This library is based on the following papers:
--   
--   <ul>
--   <li><i>Theorems For Free!</i>, Philip Wadler, in Functional
--   Programming Languages and Computer Architecture Proceedings, 1989.
--   <a>http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps</a></li>
--   <li><i>The Impact of seq on Free Theorems-Based Program
--   Transformations</i>, Patricia Johann and Janis Voigtl√§nder, Fundamenta
--   Informaticae, 2006.
--   <a>http://www.orchid.inf.tu-dresden.de/~voigt/seqFinal.pdf</a></li>
--   </ul>
--   
--   The intended usage of this library is as follows.
--   
--   <ol>
--   <li>Parse a list of declarations using one of two parsers
--   (<a>parse</a> or <a>parse</a>) or any other suitable parser. Use
--   <a>check</a> to obtain a list of valid declarations.</li>
--   <li>Optional: Parse more declarations and validate them against the
--   previously loaded list of valid declarations with
--   <a>checkAgainst</a>.</li>
--   <li>Extract all valid signatures from a list of valid declarations by
--   <a>filterSignatures</a>.</li>
--   <li>Interpret a signature (<a>interpret</a>), transform it to a
--   theorem (<a>asTheorem</a>) and pretty-print it
--   (<a>prettyTheorem</a>).</li>
--   <li>Optional: Specialise relation variables to functions
--   (<a>relationVariables</a> and <a>specialise</a>).</li>
--   <li>Optional: Extract lifted relations to show their definition
--   (<a>unfoldLifts</a>) and pretty-print them
--   (<a>prettyUnfoldedLift</a>).</li>
--   <li>Optional: Extract class constraints to show their definition
--   (<a>unfoldClasses</a>) and pretty-print them
--   (<a>prettyUnfoldedClass</a>).</li>
--   <li>Optional: Further simplify the Formulas (<a>simplify</a>) or
--   UnfoldedLift (<a>simplifyUnfoldedLift</a>) by syntactic
--   transformations.</li>
--   </ol>
module Language.Haskell.FreeTheorems

-- | Marks a valid declaration.
data ValidDeclaration

-- | Marks a valid type signature.
data ValidSignature

-- | Returns the declaration structure hidden in a valid declaration.
rawDeclaration :: ValidDeclaration -> Declaration

-- | Returns the signature structure hidden in a valid type signature.
rawSignature :: ValidSignature -> Signature

-- | Extracts all type signatures from a list of declarations.
filterSignatures :: [ValidDeclaration] -> [ValidSignature]

-- | A wrapper type for <tt>Writer</tt> which stores pretty-printable
--   documents along with parsed values. This type is provided as standard
--   return type for parsers.
type Parsed a = Writer [Doc] a

-- | A wrapper type for a <tt>Writer</tt> which stores pretty-printable
--   documents along with checked values.
type Checked a = Writer [Doc] a

-- | A wrapper function for <tt>runWriter</tt>.
runChecks :: Checked a -> (a, [Doc])

-- | Checks a list of declarations. It returns a list of all declarations
--   which are valid and an error message for all those declarations which
--   are not valid.
check :: [Declaration] -> Checked [ValidDeclaration]

-- | Checks a list of declarations against a given list of valid
--   declarations. It returns a list of all declarations from the second
--   argument which are valid. Moreover, the result contains an error
--   message for all those declarations which are not valid.
--   
--   The declarations given in the second argument may be based on those of
--   the first argument. For example, if the first argument contains a
--   valid declaration of a type "Foo" and if the second argument contains
--   the following declaration
--   
--   <pre>
--   type Bar = Foo
--   </pre>
--   
--   then also the declaration of "Bar" is valid.
checkAgainst :: [ValidDeclaration] -> [Declaration] -> Checked [ValidDeclaration]

-- | Descriptions of the Haskell language subsets for which free theorems
--   can be generated.
data LanguageSubset

-- | This subset describes only terms in which no undefinedness may. This
--   excludes terms defined using general recursion or selective strictness
--   (as offered by <tt>seq</tt>).
BasicSubset :: LanguageSubset

-- | This subset describes terms in which undefined values may occur such
--   as introduced by a fixpoint combinator or possibly failing pattern
--   matches (if not all cases are covered). This excludes any term based
--   on <tt>seq</tt>.
SubsetWithFix :: TheoremType -> LanguageSubset

-- | Additionally to the fix subset, this subset allows terms to be defined
--   using <tt>seq</tt>.
SubsetWithSeq :: TheoremType -> LanguageSubset

-- | The result type for generating free theorems.
data TheoremType

-- | An equational free theorem should be generated.
EquationalTheorem :: TheoremType

-- | Two inequational free theorems should be generated.
InequationalTheorem :: TheoremType

-- | A structure describing the intermediate result of interpreting a type
--   expression as a relation.
data Intermediate

-- | Interprets a valid signature as a relation. This is the key point for
--   generating free theorems.
interpret :: [ValidDeclaration] -> LanguageSubset -> ValidSignature -> Maybe Intermediate

-- | Unfolds an intermediate structure to a theorem.
asTheorem :: Intermediate -> Theorem

-- | Unfolds an intermediate structure to a theorem with _all_
--   restrictions.
asCompleteTheorem :: Intermediate -> Theorem

-- | Creates a list of all bound relation variables in an intermediate
--   structure, which can be specialised to a function.
relationVariables :: Intermediate -> [RelationVariable]

-- | Specialises a relation variable to a function variable in an
--   intermediate structure.
specialise :: Intermediate -> RelationVariable -> Intermediate

-- | Specialises a relation variable to an inverse function variable. This
--   function does not modify intermediate structures in subsets with
--   equational theorems.
specialiseInverse :: Intermediate -> RelationVariable -> Intermediate

-- | Extracts all lift relations and returns their definition.
unfoldLifts :: [ValidDeclaration] -> Intermediate -> [UnfoldedLift]

-- | Extracts all class constraints and returns their definition.
unfoldClasses :: [ValidDeclaration] -> Intermediate -> [UnfoldedClass]
simplify :: Formula -> Formula
simplifyUnfoldedLift :: UnfoldedLift -> UnfoldedLift

-- | Possible options for pretty-printing theorems.
data PrettyTheoremOption

-- | Omits all instantiations of types. This option makes theorems usually
--   better readable.
OmitTypeInstantiations :: PrettyTheoremOption

-- | Omit mentioning language subsets explicitly for certain relations.
OmitLanguageSubsets :: PrettyTheoremOption

-- | Pretty-prints a declaration.
prettyDeclaration :: Declaration -> Doc

-- | Pretty-prints a type signature.
prettySignature :: Signature -> Doc

-- | Pretty-prints a theorem.
prettyTheorem :: [PrettyTheoremOption] -> Theorem -> Doc

-- | Pretty-prints a relation variable.
prettyRelationVariable :: RelationVariable -> Doc

-- | Pretty-prints an unfolded lift relation.
prettyUnfoldedLift :: [PrettyTheoremOption] -> UnfoldedLift -> Doc

-- | Pretty-prints an unfolded type class.
prettyUnfoldedClass :: [PrettyTheoremOption] -> UnfoldedClass -> Doc
