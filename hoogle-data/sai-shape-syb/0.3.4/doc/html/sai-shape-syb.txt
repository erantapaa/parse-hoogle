-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Obtain homogeneous values from arbitrary values, transforming or culling data
--   
--   This package provides SYB shape support: generic mapping to
--   homogeneous types, and related features. Complements existing Uniplate
--   and TH shape libraries.
--   
--   Given a value of arbitrary complexity (mutually recursive
--   heterogeneous constructor application), you can obtain a
--   structure-preserving representation (homomorphism) as a homogeneous
--   type <tt><a>Homo</a> <a>a</a></tt>, parameterised by any choice type
--   <tt><a>a</a></tt>.
--   
--   See the project <a>homepage</a> for more information.
@package sai-shape-syb
@version 0.3.4


-- | This package provides SYB shape support: generic mapping to
--   homogeneous types, and related features. Complements existing Uniplate
--   and TH shape libraries. See <a>http://www.fremissant.net/shape-syb</a>
--   for more information.
--   
--   The present module provides the main types and functions.
module SAI.Data.Generics.Shape.SYB
type Homo r = Rose r
type Hetero = Homo Dynamic
type Bi r = Homo (Dynamic, r)
type Shape = Homo ()
type HomoM r = Homo (Maybe r)
type BiM r = Bi (Maybe r)

-- | From <a>Data.Tree</a> we have, essentially
--   
--   <pre>
--   data <a>Tree</a> r = <a>Node</a> r [<a>Tree</a> r]
--   </pre>
type Rose = Tree

-- | Map an arbitrary data constructor application expression to a
--   homogeneous representation preserving structure. This is a one-way
--   trip; what value information is preserved depends on the mapping
--   function you provide. Use <a>ghomDyn</a> or <a>ghomBi</a> if you need
--   to be able to recover the original, heterogeneous data.
ghom :: Data d => GenericQ r -> d -> Homo r

-- | Like <a>ghom</a>, but use a custom combining function, instead of the
--   default <tt>(\r _-&gt;r)</tt>.
ghomK :: Data d => (r -> r -> r) -> GenericQ r -> d -> Homo r

-- | Like <a>ghom</a>, but also filter branches using a generic predicate,
--   retaining the stop nodes. The <tt><a>GenericQ</a> r</tt> argument can
--   be specialised for the stop node type(s), for instance to summarise
--   stop branches. (See <a>ghomE</a> for more flexibility.)
ghomP :: Data d => GenericQ Bool -> GenericQ r -> d -> Homo r

-- | Like <a>ghom</a>, but also filter branches using a generic predicate,
--   retaining the stop nodes and summarising their branches in
--   <a>Right</a> values; default values are placed in the non-stop,
--   <a>Left</a> nodes. You can fmap your own function <tt>(s -&gt; r)</tt>
--   to the result, then collapse from <tt><a>Either</a> r r</tt> to
--   <tt>r</tt> in the obvious way. (The function <a>ghomP</a> is probably
--   sufficient in most cases.)
ghomE :: Data d => GenericQ Bool -> GenericQ r -> GenericQ s -> d -> Homo (Either r s)

-- | Uses <a>Data.Dynamic</a> to support mutiple types homogeneously.
--   Unlike <a>ghom</a>, this is invertible (<a>unGhomDyn</a>).
ghomDyn :: Data d => d -> Hetero

-- | <pre>
--   <a>ghomBi</a> f x = <a>zipRose</a> (<a>ghomDyn</a> x) (<a>ghom</a> f x)
--   </pre>
--   
--   Unlike <a>ghom</a>, you can recover the original, polytypic term
--   (<a>unGhomBi</a>).
ghomBi :: Data d => GenericQ r -> d -> Bi r
unGhomDyn :: Typeable a => Hetero -> a
unGhomBi :: Typeable a => Bi r -> a

-- | Drops the <a>Dynamic</a> component.
biToHomo :: Bi r -> Homo r

-- | Drops the homogeneous component (type <tt>r</tt>).
biToHetero :: Bi r -> Hetero
heteroToBi :: (Data d, Typeable d, Typeable r) => r -> (d -> r) -> Hetero -> Bi r

-- | Conversion from <a>Homo</a> to <a>HomoM</a> by wrapping values in
--   <a>Just</a>.
liftHomoM :: Homo r -> HomoM r

-- | Analogous to <a>liftHomoM</a>.
liftBiM :: Bi r -> BiM r

-- | Sometimes it makes sense to replace the <a>Nothing</a> nodes with a
--   default value in type <tt>r</tt>.
--   
--   The best default value will often be some function of the filtered,
--   <a>Just</a> items.
--   
--   <pre>
--   <a>unliftHomoM</a> = <a>fmap</a> . <a>flip</a> <a>maybe</a> <a>id</a>
--   </pre>
--   
--   Lineal ordering is preserved among <a>Just</a> nodes.
unliftHomoM :: r -> HomoM r -> Homo r

-- | Analogous to <a>unliftHomoM</a>.
unliftBiM :: r -> BiM r -> Bi r

-- | Sets up a <tt><a>BiM</a> r</tt> using a default <a>GenericQ</a> which
--   assigns all values to <a>Nothing</a>.
--   
--   Use an expression type signature at the call site, to constrain the
--   type <tt>r</tt> (the usual trick)
--   
--   <pre>
--   ( gempty x :: BiM ( Int , Data.IntMap Text , [Float] ) )
--   </pre>
--   
--   so your choice type <tt>r</tt> is a triple, but the <tt><a>BiM</a>
--   r</tt> value returned contains <a>Nothing</a> at every node. This
--   prepares it for refinement and accumulation.
gempty :: (Typeable r, Data d) => d -> BiM r

-- | Given a monomorphic function you provide, returning r, automatically
--   makes a <tt><a>GenericQ</a> r</tt> from this. It then maps the generic
--   query over the source polytypic tree, the latter being recovered from
--   the <a>Dynamic</a> component of the <a>BiM</a>.
--   
--   The target is updated with write-once semantics enforced; that is to
--   say, <a>grefine</a> will throw an exception if it finds a <a>Just</a>
--   already present at any place in the result tree that it would update.
--   
--   XXX <i>Still only calls error, when should throw an exception.</i>
grefine :: (Typeable r, Data d, Typeable d) => (d -> Maybe r) -> BiM r -> BiM r

-- | Like <a>grefine</a>, but rather than throw exception, it takes a
--   combining function argument to cope with that situation.
gaccum :: (Typeable r, Data d, Typeable d) => (r -> r -> r) -> (d -> Maybe r) -> BiM r -> BiM r

-- | Trivial homomorphism that discards all value information.
shapeOf :: Data d => d -> Shape

-- | Stop traversal on <a>String</a>s.
shapeOf_ :: Data d => d -> Shape

-- | Generic number of nodes in a polytypic term.
sizeOf :: Data d => d -> Int

-- | Compare two general polytypic values for shape equality.
symmorphic :: (Data d1, Data d2) => d1 -> d2 -> Bool

-- | Operator synonymous with <a>symmorphic</a>.
(~~) :: (Data d1, Data d2) => d1 -> d2 -> Bool

-- | Weight of a node is defined as the number of descendants, plus 1.
weightedShapeOf :: Data d => d -> Homo Int

-- | Stop traversal on <a>String</a>s, using the length of the string as
--   the weight for the node rooting the <a>String</a>.
--   
--   <i>XXX Using 2*length + 1 would be more consistent?</i>
weightedShapeOf_ :: Data d => d -> Homo Int
weightedRose :: Rose r -> Rose (r, Int)

-- | Produce a zipped rose tree, where the second component at a node is
--   the number of non-<a>Nothing</a> (<i>i.e.</i> <a>Just</a>)
--   descendants, plus one for itself if it is <a>Just</a>.
weightedRoseJust :: Rose (Maybe r) -> Rose (Maybe r, Int)

-- | Number of nodes in a rose tree.
sizeOfRose :: Rose a -> Int

-- | Combine two rose trees with identical shape, by tupling their values.
zipRose :: Rose r -> Rose s -> Rose (r, s)

-- | Inverse of zipRose (up to currying).
unzipRose :: Rose (r, s) -> (Rose r, Rose s)

-- | Zip two <a>Bi</a>s. It is the caller's responsibility to assure that
--   the <a>Dynamic</a> component is the same in both arguments (in
--   addition to assuring that the shapes are compatible).
zipBi :: Bi r -> Bi s -> Bi (r, s)
unzipBi :: Bi (r, s) -> (Bi r, Bi s)
zip :: (Applicative f, Functor f) => (f a, f b) -> f (a, b)
unzip :: Functor f => f (a, b) -> (f a, f b)
showHomo :: Show r => Rose r -> String
showHomoWhen :: Show r => (r -> Bool) -> Rose r -> String
showHomoM :: Show r => Rose (Maybe r) -> String

-- | One-line, parentheses language representation of the shape of a
--   <tt><a>Homo</a> r</tt>.
showAsParens :: Homo r -> String

-- | One-line, parentheses language representation of the shape of a
--   <a>Homo</a> <a>Bool</a>, enriched by symbols for <a>True</a>
--   (<tt>*</tt>) and <a>False</a> (<tt>.</tt>).
--   
--   (While parentheses around the leaves can in principle be omitted, the
--   loss in readability is not compensated by the shortening.)
showAsParensBool :: Homo Bool -> String

-- | One-line, parentheses language representation of the shape of a
--   <tt><a>Homo</a> r</tt>, and nodes adorned with <tt><a>show</a> r</tt>.
showAsParensEnriched :: Show r => Homo r -> String

-- | One-line, parentheses language representation of the shape of a
--   <tt><a>Homo</a> r</tt>, and nodes adorned with <tt><a>show</a> r</tt>
--   when the predicate holds (and with a dot otherwise).
showAsParensEnrichedWhen :: Show r => (r -> Bool) -> Homo r -> String

-- | One-line, parentheses language representation of the shape of a
--   <tt><a>HomoM</a> r</tt>, with <a>Just</a> nodes designated by
--   <tt><a>show</a> r</tt> (and <a>Nothing</a> nodes by a dot).
showAsParensEnrichedM :: Show r => HomoM r -> String
showDyn :: Dynamic -> String
showHetero :: Hetero -> String
showBi :: Show r => Bi r -> String

-- | Multi-way trees, also known as <i>rose trees</i>.
data Tree a :: * -> *
Node :: a -> Forest a -> Tree a
type Forest a = [Tree a]


-- | This package provides SYB shape support: generic mapping to
--   homogeneous types, and related features. Complements existing Uniplate
--   and TH shape libraries. See <a>http://www.fremissant.net/shape-syb</a>
--   for more information.
--   
--   The present module provides limited support for structure-changing
--   transformations, some generic, others on the homogeneous types.
module SAI.Data.Generics.Shape.SYB.Filter

-- | Tolerate lifted nodes in the result, in exchange for better structure
--   preservation.
--   
--   Lineal ordering is preserved among <a>Just</a> nodes.
--   
--   In the end, this is probably the most useful (unless one that takes a
--   generic predicate, and acts on original types obtained via
--   fromDyn[amic]...).
filterHomoM :: (r -> Bool) -> Homo r -> HomoM r

-- | As per <a>filterHomoM</a>, but we string along the <a>Dynamic</a>
--   component.
filterBiM :: (r -> Bool) -> Bi r -> BiM r

-- | Tolerate lifted nodes in the result, in exchange for better structure
--   preservation.
--   
--   Lineal ordering is preserved among <a>Just</a> nodes.
filterHomoMM :: HomoM r -> HomoM r

-- | As per <a>filterHomoMM</a>, but we string along the <a>Dynamic</a>
--   component.
filterBiMM :: BiM r -> BiM r
filterHomo :: (r -> Bool) -> Homo r -> Homo r
filterHetero :: Typeable r => (r -> Bool) -> Hetero -> Hetero
filterBi :: (r -> Bool) -> Bi r -> Bi r

-- | <a>filterHomoM_</a> acts on a lifted type to avoid needing to specify
--   any default values; however, the root node cannot be eliminated by
--   this algorithm, so in case the root is a <a>Nothing</a>, we need to
--   return its child branches as a forest.
filterHomoM_ :: HomoM r -> [Homo r]

-- | <a>filterHomoM_</a> plus a root default value in the homogeneous type;
--   this allows us to always return a single rooted tree in type
--   <tt><a>Homo</a> r</tt>. Compare to <a>filterHomoM_</a> which, lacking
--   such a root default, is obliged to return <tt>[<a>Homo</a> r]</tt>.
filterHomoM_' :: r -> HomoM r -> Homo r

-- | Takes a generic query (create this with <a>mkQP</a>), and a value, and
--   produce the forest of trees of <a>Just</a> nodes. (Refer to
--   <a>filterHomoM_</a> for more details.)
gfilter :: Data d => (forall d. (Data d, Typeable d) => d -> Maybe r) -> d -> [Homo r]

-- | Analogous to <a>gfilter</a>, but takes a default value in <tt>r</tt>
--   and returns a single tree (instead of a forest). Uses
--   <a>filterHomoM_'</a>.
gfilter_ :: Data d => r -> (forall d. (Data d, Typeable d) => d -> Maybe r) -> d -> Homo r

-- | Would like to be able to call this automatically from gfilter, but I
--   think the user code must call it, and pass the result to gfilter...
mkQP :: (Typeable a, Typeable b) => (r -> Bool) -> (b -> Maybe r) -> a -> Maybe r


-- | This package provides SYB shape support: generic mapping to
--   homogeneous types, and related features. Complements existing Uniplate
--   and TH shape libraries. See <a>http://www.fremissant.net/shape-syb</a>
--   for more information.
--   
--   The present module provides support for staged GHC AST types. Once you
--   have a <tt><a>Homo</a> r</tt>, <a>Hetero</a>, or <tt><a>Bi</a> r</tt>,
--   the rest of the API in <a>Shape.SYB</a> and <a>Shape.SYB.Filter</a> is
--   applicable.
--   
--   Please refer to <a>Shape.SYB</a> for descriptions of these functions.
--   Here, in addition to the extra <a>Stage</a> argument, most of the
--   <tt>ghom</tt> combinator functions also take an extra argument of type
--   <tt>r</tt>, the default value to use wherever staging holes are
--   encountered.
module SAI.Data.Generics.Shape.SYB.GHC
ghom_Staged :: Data d => Stage -> r -> GenericQ r -> d -> Homo r
ghomK_Staged :: Data d => Stage -> r -> (r -> r -> r) -> GenericQ r -> d -> Homo r
ghomP_Staged :: Data d => Stage -> r -> GenericQ Bool -> GenericQ r -> d -> Homo r
ghomE_Staged :: Data d => Stage -> r -> GenericQ Bool -> GenericQ r -> GenericQ s -> d -> Homo (Either r s)

-- | Uses <a>Data.Dynamic</a> to support mutiple types homogeneously.
ghomDyn_Staged :: Data d => Stage -> d -> Hetero

-- | <pre>
--   <a>ghomBi_Staged</a> s f x = <a>zipRose</a> (<a>ghomDyn_Staged</a> s x) (<a>ghom_Staged</a> s f x)
--   </pre>
ghomBi_Staged :: Data d => Stage -> r -> GenericQ r -> d -> Bi r
shapeOf_Staged :: Data d => Stage -> d -> Shape

-- | Treat <a>String</a> and <a>FastString</a> as atomic values.
shapeOf_Staged_ :: Data d => Stage -> d -> Shape
sizeOf_Staged :: Data d => Stage -> d -> Int

-- | Compare two GHC ASTs for shape equality.
symmorphic_Staged :: (Data d1, Data d2) => Stage -> d1 -> d2 -> Bool
weightedShapeOf_Staged :: Data d => Stage -> d -> Homo Int

-- | Treat <a>String</a> and <a>FastString</a> as atomic values.
weightedShapeOf_Staged_ :: Data d => Stage -> d -> Homo Int
instance Typeable GHC_AST_HOLE


-- | This package provides SYB shape support: generic mapping to
--   homogeneous types, and related features. Complements existing Uniplate
--   and TH shape libraries. See <a>http://www.fremissant.net/shape-syb</a>
--   for more information.
--   
--   The present module simply re-exports all relevant modules.
module SAI.Data.Generics.Shape
