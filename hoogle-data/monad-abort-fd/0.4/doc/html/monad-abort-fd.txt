-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A better error monad transformer
--   
--   This package provides automated lifting of operations via functional
--   dependencies for the <tt>transformers-abort</tt> package.
@package monad-abort-fd
@version 0.4

module Control.Monad.Abort.Class
class Monad μ => MonadAbort e μ | μ -> e
abort :: MonadAbort e μ => e -> μ α
class MonadAbort e μ => MonadRecover e μ | μ -> e
recover :: MonadRecover e μ => μ α -> (e -> μ α) -> μ α
onError :: MonadRecover e μ => μ α -> (e -> μ β) -> μ α
onError_ :: MonadRecover e μ => μ α -> μ β -> μ α
ignore :: MonadRecover e μ => μ α -> μ ()
instance (MonadRecover e μ, Monoid w) => MonadRecover e (RWST r w s μ)
instance (MonadAbort e μ, Monoid w) => MonadAbort e (RWST r w s μ)
instance (MonadRecover e μ, Monoid w) => MonadRecover e (RWST r w s μ)
instance (MonadAbort e μ, Monoid w) => MonadAbort e (RWST r w s μ)
instance (MonadRecover e μ, Monoid w) => MonadRecover e (WriterT w μ)
instance (MonadAbort e μ, Monoid w) => MonadAbort e (WriterT w μ)
instance (MonadRecover e μ, Monoid w) => MonadRecover e (WriterT w μ)
instance (MonadAbort e μ, Monoid w) => MonadAbort e (WriterT w μ)
instance MonadRecover e μ => MonadRecover e (StateT s μ)
instance MonadAbort e μ => MonadAbort e (StateT s μ)
instance MonadRecover e μ => MonadRecover e (StateT s μ)
instance MonadAbort e μ => MonadAbort e (StateT s μ)
instance MonadRecover e μ => MonadRecover e (ReaderT r μ)
instance MonadAbort e μ => MonadAbort e (ReaderT r μ)
instance MonadRecover e μ => MonadRecover e (ListT μ)
instance MonadAbort e μ => MonadAbort e (ListT μ)
instance MonadRecover e μ => MonadRecover e (MaybeT μ)
instance MonadAbort e μ => MonadAbort e (MaybeT μ)
instance MonadAbort e μ => MonadAbort e (ContT r μ)
instance MonadRecover e μ => MonadRecover e (IdentityT μ)
instance MonadAbort e μ => MonadAbort e (IdentityT μ)
instance MonadRWS r w s μ => MonadRWS r w s (AbortT e μ)
instance MonadWriter w μ => MonadWriter w (AbortT e μ)
instance MonadState s μ => MonadState s (AbortT e μ)
instance MonadReader r μ => MonadReader r (AbortT e μ)
instance MonadCont μ => MonadCont (AbortT e μ)
instance Monad μ => MonadError e (AbortT e μ)
instance MonadRecover SomeException IO
instance MonadAbort SomeException IO
instance Monad μ => MonadRecover e (AbortT e μ)
instance Monad μ => MonadAbort e (AbortT e μ)

module Control.Monad.Exception
exception :: Exception e => e -> α
evaluate :: MonadBase IO μ => α -> μ α
throw :: (MonadAbort SomeException μ, Exception e) => e -> μ α
throwIO :: (MonadBase IO μ, Exception e) => e -> μ α
catch :: (MonadRecover SomeException μ, Exception e) => μ α -> (e -> μ α) -> μ α
catchJust :: (MonadRecover SomeException μ, Exception e) => (e -> Maybe β) -> μ α -> (β -> μ α) -> μ α
handle :: (MonadRecover SomeException μ, Exception e) => (e -> μ α) -> μ α -> μ α
handleJust :: (MonadRecover SomeException μ, Exception e) => (e -> Maybe β) -> (β -> μ α) -> μ α -> μ α
data Handler μ α
Handler :: (e -> μ α) -> Handler μ α
catches :: MonadRecover SomeException μ => μ α -> [Handler μ α] -> μ α
try :: (MonadRecover SomeException μ, Exception e) => μ α -> μ (Either e α)
tryJust :: (MonadRecover SomeException μ, Exception e) => (e -> Maybe β) -> μ α -> μ (Either β α)
onException :: (MonadRecover SomeException μ, Exception e) => μ α -> (e -> μ β) -> μ α
onExceptions :: MonadRecover SomeException μ => μ α -> [Handler μ β] -> μ α
class (Applicative μ, Monad μ) => MonadFinally μ
finally' :: MonadFinally μ => μ α -> (Maybe α -> μ β) -> μ (α, β)
finally :: MonadFinally μ => μ α -> μ β -> μ α
onEscape :: MonadFinally μ => μ α -> μ β -> μ α
tryAll :: MonadFinally μ => [μ α] -> μ ()
class (Applicative μ, Monad μ, Ord m, Bounded m, Default m) => MonadMask m μ | μ -> m
getMaskingState :: MonadMask m μ => μ m
setMaskingState :: MonadMask m μ => m -> μ α -> μ α
mask :: MonadMask m μ => ((forall η β. MonadMask m η => η β -> η β) -> μ α) -> μ α
mask_ :: MonadMask m μ => μ α -> μ α
uninterruptibleMask :: MonadMask MaskingState μ => ((forall η β. MonadMask MaskingState η => η β -> η β) -> μ α) -> μ α
uninterruptibleMask_ :: MonadMask MaskingState μ => μ α -> μ α
bracket :: (MonadFinally μ, MonadMask m μ) => μ α -> (α -> μ β) -> (α -> μ γ) -> μ γ
bracket_ :: (MonadFinally μ, MonadMask m μ) => μ α -> μ β -> μ γ -> μ γ
bracketOnEscape :: (MonadFinally μ, MonadMask m μ) => μ α -> (α -> μ β) -> (α -> μ γ) -> μ γ
bracketOnError :: (MonadRecover e μ, MonadMask m μ) => μ α -> (α -> μ β) -> (α -> μ γ) -> μ γ
instance Bounded MaskingState
instance Enum MaskingState
instance Ord MaskingState
instance (MonadMask m μ, Monoid w) => MonadMask m (RWST r w s μ)
instance (MonadMask m μ, Monoid w) => MonadMask m (RWST r w s μ)
instance (MonadMask m μ, Monoid w) => MonadMask m (WriterT w μ)
instance (MonadMask m μ, Monoid w) => MonadMask m (WriterT w μ)
instance MonadMask m μ => MonadMask m (StateT s μ)
instance MonadMask m μ => MonadMask m (StateT s μ)
instance MonadMask m μ => MonadMask m (ReaderT r μ)
instance (MonadMask m μ, Error e) => MonadMask m (ErrorT e μ)
instance MonadMask m μ => MonadMask m (FinishT β μ)
instance MonadMask m μ => MonadMask m (AbortT e μ)
instance MonadMask m μ => MonadMask m (ListT μ)
instance MonadMask m μ => MonadMask m (MaybeT μ)
instance MonadMask MaskingState IO
instance MonadMask () Identity
instance Default MaskingState
instance (MonadFinally μ, Monoid w) => MonadFinally (RWST r w s μ)
instance (MonadFinally μ, Monoid w) => MonadFinally (RWST r w s μ)
instance (MonadFinally μ, Monoid w) => MonadFinally (WriterT w μ)
instance (MonadFinally μ, Monoid w) => MonadFinally (WriterT w μ)
instance MonadFinally μ => MonadFinally (StateT s μ)
instance MonadFinally μ => MonadFinally (StateT s μ)
instance MonadFinally μ => MonadFinally (ReaderT r μ)
instance (MonadFinally μ, Error e) => MonadFinally (ErrorT e μ)
instance MonadFinally μ => MonadFinally (FinishT β μ)
instance MonadFinally μ => MonadFinally (AbortT e μ)
instance MonadFinally μ => MonadFinally (ListT μ)
instance MonadFinally μ => MonadFinally (MaybeT μ)
instance MonadFinally IO
instance MonadFinally Identity

module Control.Monad.Abort
class Monad μ => MonadAbort e μ | μ -> e
abort :: MonadAbort e μ => e -> μ α
class MonadAbort e μ => MonadRecover e μ | μ -> e
recover :: MonadRecover e μ => μ α -> (e -> μ α) -> μ α
onError :: MonadRecover e μ => μ α -> (e -> μ β) -> μ α
onError_ :: MonadRecover e μ => μ α -> μ β -> μ α
type Abort e α = AbortT e Identity α
runAbort :: Abort e α -> Either e α
newtype AbortT e μ :: (* -> *) α :: * -> (* -> *) -> * -> *
AbortT :: μ (Either e α) -> AbortT e α
runAbortT :: AbortT e α -> μ (Either e α)

module Control.Monad.Finish.Class
class Monad μ => MonadFinish f μ | μ -> f
finish :: MonadFinish f μ => f -> μ α
instance (MonadFinish f μ, Monoid w) => MonadFinish f (RWST r w s μ)
instance (MonadFinish f μ, Monoid w) => MonadFinish f (RWST r w s μ)
instance (MonadFinish f μ, Monoid w) => MonadFinish f (WriterT w μ)
instance (MonadFinish f μ, Monoid w) => MonadFinish f (WriterT w μ)
instance MonadFinish f μ => MonadFinish f (StateT s μ)
instance MonadFinish f μ => MonadFinish f (StateT s μ)
instance MonadFinish f μ => MonadFinish f (ReaderT r μ)
instance MonadFinish f μ => MonadFinish f (ListT μ)
instance MonadFinish f μ => MonadFinish f (AbortT e μ)
instance (MonadFinish f μ, Error e) => MonadFinish f (ErrorT e μ)
instance MonadFinish f μ => MonadFinish f (MaybeT μ)
instance MonadFinish f μ => MonadFinish f (ContT r μ)
instance MonadFinish f μ => MonadFinish f (IdentityT μ)
instance MonadRWS r w s μ => MonadRWS r w s (FinishT f μ)
instance MonadWriter w μ => MonadWriter w (FinishT f μ)
instance MonadState s μ => MonadState s (FinishT f μ)
instance MonadReader r μ => MonadReader r (FinishT f μ)
instance MonadRecover e μ => MonadRecover e (FinishT f μ)
instance MonadAbort e μ => MonadAbort e (FinishT f μ)
instance MonadError e μ => MonadError e (FinishT f μ)
instance MonadCont μ => MonadCont (FinishT f μ)
instance Monad μ => MonadFinish f (FinishT f μ)

module Control.Monad.Finish
class Monad μ => MonadFinish f μ | μ -> f
finish :: MonadFinish f μ => f -> μ α
type Finish f α = FinishT f Identity α
runFinish :: Finish f α -> Either f α
runFinish' :: Finish α α -> α
newtype FinishT f μ :: (* -> *) α :: * -> (* -> *) -> * -> *
FinishT :: μ (Either f α) -> FinishT f α
runFinishT :: FinishT f α -> μ (Either f α)
runFinishT' :: Monad μ => FinishT α μ α -> μ α
