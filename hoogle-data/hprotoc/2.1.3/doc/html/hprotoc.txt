-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse Google Protocol Buffer specifications
--   
@package hprotoc
@version 2.1.3


-- | This <a>Parser</a> module takes a filename and its contents as a
--   bytestring, and uses Lexer.hs to make a stream of tokens that it
--   parses. No IO is performed and the error function is not used. Since
--   the Lexer should also avoid such errors this should be a reliably
--   total function of the input.
--   
--   The internals have been updated to handle Google's protobuf version
--   2.0.3 formats, including EnumValueOptions.
module Text.ProtocolBuffers.ProtoCompile.Parser
parseProto :: String -> ByteString -> Either ParseError FileDescriptorProto
isValidPacked :: Label -> Maybe Type -> Bool


-- | This huge module handles the loading and name resolution. The
--   loadProto command recursively gets all the imported proto files. The
--   makeNameMaps command makes the translator from proto name to Haskell
--   name. Many possible errors in the proto data are caught and reported
--   by these operations.
--   
--   hprotoc will actually resolve more unqualified imported names than
--   Google's protoc which requires more qualified names. I do not have the
--   obsessive nature to fix this.
module Text.ProtocolBuffers.ProtoCompile.Resolve

-- | Given a list of paths to search, loads proto files by looking for them
--   in the file system.
loadProto :: [LocalFP] -> LocalFP -> IO (Env, [FileDescriptorProto])
loadCodeGenRequest :: CodeGeneratorRequest -> LocalFP -> (Env, [FileDescriptorProto])
makeNameMaps :: [MName String] -> [(CanonFP, [MName String])] -> Env -> Either ErrStr NameMap
getTLS :: Env -> (TopLevel, [TopLevel])
getPackageID :: PackageID a -> a

-- | By construction Env is 0 or more Local Entity namespaces followed by 1
--   or more Global TopLevel namespaces (self and imported files). Entities
--   in first Global TopLevel namespace can refer to each other and to
--   Entities in the list of directly imported TopLevel namespaces only.
data Env
Local :: [IName String] -> EMap -> Env -> Env
Global :: TopLevel -> [TopLevel] -> Env

-- | TopLevel corresponds to all items defined in a .proto file. This
--   includes the FileOptions since this will be consulted when generating
--   the Haskell module names, and the imported files are only known
--   through their TopLevel data.
data TopLevel
TopLevel :: FilePath -> PackageID [IName String] -> Either ErrStr FileDescriptorProto -> EMap -> TopLevel
top'Path :: TopLevel -> FilePath
top'Package :: TopLevel -> PackageID [IName String]
top'FDP :: TopLevel -> Either ErrStr FileDescriptorProto
top'mVals :: TopLevel -> EMap
type ReMap = Map (FIName Utf8) ProtoName
data NameMap
NameMap :: (PackageID (FIName Utf8), [MName String], [MName String]) -> ReMap -> NameMap
data PackageID a
PackageID :: a -> PackageID a
_getPackageID :: PackageID a -> a
NoPackageID :: a -> PackageID a
_getNoPackageID :: PackageID a -> a
newtype LocalFP
LocalFP :: FilePath -> LocalFP
unLocalFP :: LocalFP -> FilePath
newtype CanonFP
CanonFP :: FilePath -> CanonFP
unCanonFP :: CanonFP -> FilePath
instance Show a => Show (PackageID a)
instance Read LocalFP
instance Show LocalFP
instance Eq LocalFP
instance Ord LocalFP
instance Read CanonFP
instance Show CanonFP
instance Eq CanonFP
instance Ord CanonFP
instance Show NameMap
instance Show Entity
instance Show E'Entity
instance Show TopLevel
instance Show Env
instance ConsumeUNO DescriptorProto
instance ConsumeUNO FileDescriptorProto
instance ConsumeUNO FieldDescriptorProto
instance ConsumeUNO ServiceDescriptorProto
instance ConsumeUNO MethodDescriptorProto
instance ConsumeUNO EnumValueDescriptorProto
instance ConsumeUNO EnumDescriptorProto
instance Show SEnv
instance Functor PackageID


-- | The <tt>MakeReflections</tt> module takes the
--   <tt>FileDescriptorProto</tt> output from <tt>Resolve</tt> and produces
--   a <a>ProtoInfo</a> from <tt>Reflections</tt>. This also takes a
--   Haskell module prefix and the proto's package namespace as input. The
--   output is suitable for passing to the <tt>Gen</tt> module to produce
--   the files.
--   
--   This acheives several things: It moves the data from a nested tree to
--   flat lists and maps. It moves the group information from the parent
--   Descriptor to the actual Descriptor. It moves the data out of Maybe
--   types. It converts Utf8 to String. Keys known to extend a Descriptor
--   are listed in that Descriptor.
--   
--   In building the reflection info new things are computed. It changes
--   dotted names to ProtoName using the translator from
--   <tt>makeNameMaps</tt>. It parses the default value from the ByteString
--   to a Haskell type. For fields, the value of the tag on the wire is
--   computed and so is its size on the wire.
module Text.ProtocolBuffers.ProtoCompile.MakeReflections
makeProtoInfo :: (Bool, Bool) -> NameMap -> FileDescriptorProto -> ProtoInfo
serializeFDP :: FileDescriptorProto -> ByteString
