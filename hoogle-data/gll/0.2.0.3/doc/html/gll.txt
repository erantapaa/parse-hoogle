-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GLL parser with simple combinator interface
--   
@package gll
@version 0.2.0.3

module GLL.Combinators.MemInterface
data SymbParser b
data IMParser b
class HasAlts a
altsOf :: HasAlts a => a b -> ([] :. IMParser) b
class IsSymbParser a
toSymb :: IsSymbParser a => a b -> SymbParser b
class IsIMParser a
toImp :: IsIMParser a => a b -> IMParser b

-- | The semantic results of a parser, given a string of Tokens
parse :: IsSymbParser s => s a -> [Token] -> IO [a]

-- | Parse a string of characters
parseString :: IsSymbParser s => s a -> String -> IO [a]
char :: Char -> SymbParser Char
token :: Token -> SymbParser Token
data Token
Char :: (Char) -> Token
EOS :: Token
Epsilon :: Token
Int :: (((Maybe Int))) -> Token
Bool :: (((Maybe Bool))) -> Token
String :: (((Maybe String))) -> Token
Token :: (String) -> (((Maybe String))) -> Token
epsilon :: SymbParser ()
satisfy :: a -> IMParser a
many :: SymbParser a -> SymbParser [a]
some :: SymbParser a -> SymbParser [a]
optional :: SymbParser a -> SymbParser (Maybe a)

-- | Use this combinator on all combinators that might have an infinite
--   number of derivations for some input string. A non-terminal has this
--   property if and only if it is left-recursive and would be
--   left-recursive if all the right-hand sides of the productions of the
--   grammar are reversed.
(<::=>) :: HasAlts b => String -> b a -> SymbParser a

-- | Use this combinator on all recursive non-terminals
(<:=>) :: HasAlts b => String -> b a -> SymbParser a
(<$>) :: IsSymbParser s => (a -> b) -> s a -> IMParser b
(<$) :: IsSymbParser s => b -> s a -> IMParser b
(<*>) :: (IsIMParser i, IsSymbParser s) => i (a -> b) -> s a -> IMParser b
(<*) :: (IsIMParser i, IsSymbParser s) => i b -> s a -> IMParser b
(<|>) :: (IsIMParser i, HasAlts b) => i a -> b a -> ([] :. IMParser) a

-- | Composition of unary type constructors
--   
--   There are (at least) two useful <a>Monoid</a> instances, so you'll
--   have to pick one and type-specialize it (filling in all or parts of
--   <tt>g</tt> and/or <tt>f</tt>).
--   
--   <pre>
--   -- standard Monoid instance for Applicative applied to Monoid
--   instance (Applicative (g :. f), Monoid a) =&gt; Monoid ((g :. f) a) where
--     { mempty = pure mempty; mappend = liftA2 mappend }
--   -- Especially handy when g is a Monoid_f.
--   instance Monoid (g (f a)) =&gt; Monoid ((g :. f) a) where
--     { mempty = O mempty; mappend = inO2 mappend }
--   </pre>
--   
--   Corresponding to the first and second definitions above,
--   
--   <pre>
--   instance (Applicative g, Monoid_f f) =&gt; Monoid_f (g :. f) where
--     { mempty_f = O (pure mempty_f); mappend_f = inO2 (liftA2 mappend_f) }
--   instance Monoid_f g =&gt; Monoid_f (g :. f) where
--     { mempty_f = O mempty_f; mappend_f = inO2 mappend_f }
--   </pre>
--   
--   Similarly, there are two useful <a>Functor</a> instances and two
--   useful <a>ContraFunctor</a> instances.
--   
--   <pre>
--   instance (      Functor g,       Functor f) =&gt; Functor (g :. f) where fmap = fmapFF
--   instance (ContraFunctor g, ContraFunctor f) =&gt; Functor (g :. f) where fmap = fmapCC
--   
--   instance (      Functor g, ContraFunctor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapFC
--   instance (ContraFunctor g,       Functor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapCF
--   </pre>
--   
--   However, it's such a bother to define the Functor instances per
--   composition type, I've left the fmapFF case in. If you want the fmapCC
--   one, you're out of luck for now. I'd love to hear a good solution.
--   Maybe someday Haskell will do Prolog-style search for instances,
--   subgoaling the constraints, rather than just matching instance heads.
data (:.) (g :: * -> *) (f :: * -> *) a :: (* -> *) -> (* -> *) -> * -> *
memo :: IsSymbParser s => MemoRef [a] -> s a -> SymbParser a
newMemoTable :: IO (MemoRef a)
type MemoRef a = IORef (MemoTable a)

-- | use <a>::=</a> to enforce using parse context (to handle
--   left-recursion)
type MemoTable a = IntMap (IntMap a)
instance IsSymbParser ([] :. IMParser)
instance IsSymbParser SymbParser
instance IsSymbParser IMParser
instance IsIMParser ([] :. IMParser)
instance IsIMParser SymbParser
instance IsIMParser IMParser
instance HasAlts ([] :. IMParser)
instance HasAlts SymbParser
instance HasAlts IMParser


-- | This model contains unit-tests for <a>MemInterface</a>
--   
--   <h1>Included examples</h1>
--   
--   <ul>
--   <li>Elementary parsers</li>
--   <li>Sequencing</li>
--   <li>Alternatives</li>
--   <li>Simple binding</li>
--   <li>Binding with alternatives</li>
--   <li>Recursion (non-left)</li>
--   <li>Higher-order patterns:<ul><li>Optional</li><li>Kleene-closure /
--   positive closure</li><li>Seperator</li><li>Inline
--   choice</li></ul></li>
--   </ul>
--   
--   <ul>
--   
--   <li>Ambiguities:<ul><li>"aaa"</li><li>longambig</li><li>aho_s</li><li>EEE</li></ul></li>
--   <li>Left recursion</li>
--   <li>Hidden left-recursion</li>
--   </ul>
module GLL.Combinators.Test.MemInterface

-- | Defines and executes some unit-tests
main :: IO ()

module GLL.Combinators.BinInterface
type Parser a = (Visit1, Visit2, Visit3 a)

-- | The semantic results of a parser, given a token string
parse :: Parser a -> [Token] -> [a]

-- | Parse a given string of characters
parseString :: Parser a -> [Char] -> [a]

-- | A parser that recognises a given character
char :: Char -> Parser Char

-- | A parser that recognises a given token
token :: Token -> Parser Token
data Token
Char :: (Char) -> Token
EOS :: Token
Epsilon :: Token
Int :: (((Maybe Int))) -> Token
Bool :: (((Maybe Bool))) -> Token
String :: (((Maybe String))) -> Token
Token :: (String) -> (((Maybe String))) -> Token

-- | A parser that always succeeds (and returns unit)
epsilon :: Parser ()

-- | A parser that always succeeds and returns a given value
satisfy :: Ord a => a -> Parser a

-- | Apply the given parser many times, 0 or more times (Kleene closure)
many :: Ord a => Parser a -> Parser [a]

-- | Apply the given parser some times, 1 or more times (positive closure)
some :: Ord a => Parser a -> Parser [a]

-- | Optionally use the given parser
optional :: Ord a => Parser a -> Parser (Maybe a)

-- | use <a>::=</a> to enforce using parse context (to handle
--   left-recursion)
(<::=>) :: String -> Parser a -> Parser a

-- | useful for non-recursive definitions (only internally)
(<:=>) :: String -> Parser a -> Parser a

-- | Application of a semantic action.
(<$>) :: (Ord b, Ord a) => (a -> b) -> Parser a -> Parser b

-- | Ignore all results and just return the given value
(<$) :: (Ord a, Ord b) => a -> Parser b -> Parser a

-- | Sequence two parsers, the results of the two parsers are tupled.
(<*>) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser (a, b)

-- | Sequencing, ignoring the result to the left
(*>) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser b

-- | Sequencing, ignoring the result to the right
(<*) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser a

-- | A choice between two parsers, results of the two are concatenated
(<|>) :: Ord a => Parser a -> Parser a -> Parser a


-- | This model contains unit-tests for <a>BinInterface</a>
--   
--   <h1>Included examples</h1>
--   
--   <ul>
--   <li>Elementary parsers</li>
--   <li>Sequencing</li>
--   <li>Alternatives</li>
--   <li>Simple binding</li>
--   <li>Binding with alternatives</li>
--   <li>Recursion (non-left)</li>
--   <li>Higher-order patterns:<ul><li>Optional</li><li>Kleene-closure /
--   positive closure</li><li>Seperator</li><li>Inline
--   choice</li></ul></li>
--   </ul>
--   
--   <ul>
--   
--   <li>Ambiguities:<ul><li>"aaa"</li><li>longambig</li><li>aho_s</li><li>EEE</li></ul></li>
--   <li>Left recursion</li>
--   <li>Hidden left-recursion</li>
--   </ul>
module GLL.Combinators.Test.BinInterface

-- | Defines and executes some unit-tests
main :: IO ()


-- | Parser Combinators for GLL parsing inspired by Tom Ridge's P3 OCaml
--   library
module GLL.Combinators.MemBinInterface
type Parser a = (Visit1, Visit2, Visit3 a)

-- | The semantic results of a parser, given a token string
parse :: Parser a -> [Token] -> IO [a]

-- | Parse a given string of characters
parseString :: Parser a -> [Char] -> IO [a]
(<::=>) :: String -> Parser a -> Parser a

-- | useful for non-recursive definitions (only internally)
(<:=>) :: String -> Parser a -> Parser a

-- | Application of a semantic action.
(<$>) :: (Ord b, Ord a) => (a -> b) -> Parser a -> Parser b

-- | Ignore all results and just return the given value
(<$) :: (Ord a, Ord b) => a -> Parser b -> Parser a

-- | Sequence two parsers, the results of the two parsers are tupled.
(<*>) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser (a, b)

-- | Sequencing, ignoring the result to the left
(*>) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser b

-- | Sequencing, ignoring the result to the right
(<*) :: (Ord a, Ord b) => Parser a -> Parser b -> Parser a

-- | A choice between two parsers, results of the two are concatenated
(<|>) :: Ord a => Parser a -> Parser a -> Parser a

-- | A parser that recognises a given character
char :: Char -> Parser Char

-- | A parser that recognises a given token
token :: Token -> Parser Token
data Token
Char :: (Char) -> Token
EOS :: Token
Epsilon :: Token
Int :: (((Maybe Int))) -> Token
Bool :: (((Maybe Bool))) -> Token
String :: (((Maybe String))) -> Token
Token :: (String) -> (((Maybe String))) -> Token

-- | A parser that always succeeds (and returns unit)
epsilon :: Parser ()

-- | A parser that always succeeds and returns a given value
satisfy :: Ord a => a -> Parser a

-- | Optionally use the given parser
optional :: Ord a => Parser a -> Parser (Maybe a)

-- | Apply the given parser many times, 0 or more times (Kleene closure)
many :: Ord a => Parser a -> Parser [a]

-- | Apply the given parser some times, 1 or more times (positive closure)
some :: Ord a => Parser a -> Parser [a]

-- | Use this function on a parser to memoise the semantic phase of the
--   parser It is advised to only use <a>memo</a> on a parser whose symbol
--   occurs many times in a highly ambiguous grammar Every symbol on which
--   <a>memo</a> is used should have its own table.
memo :: MemoRef (Set a) -> Parser a -> Parser a
newMemoTable :: IO (MemoRef a)
type MemoRef a = IORef (MemoTable a)

-- | use <a>::=</a> to enforce using parse context (to handle
--   left-recursion)
type MemoTable a = IntMap (IntMap a)


-- | This model contains unit-tests for <a>MemBinInterface</a>
--   
--   <h1>Included examples</h1>
--   
--   <ul>
--   <li>Elementary parsers</li>
--   <li>Sequencing</li>
--   <li>Alternatives</li>
--   <li>Simple binding</li>
--   <li>Binding with alternatives</li>
--   <li>Recursion (non-left)</li>
--   <li>Higher-order patterns:<ul><li>Optional</li><li>Kleene-closure /
--   positive closure</li><li>Seperator</li><li>Inline
--   choice</li></ul></li>
--   </ul>
--   
--   <ul>
--   
--   <li>Ambiguities:<ul><li>"aaa"</li><li>longambig</li><li>aho_s</li><li>EEE</li></ul></li>
--   <li>Left recursion</li>
--   <li>Hidden left-recursion</li>
--   </ul>
module GLL.Combinators.Test.MemBinInterface

-- | Defines and executes some unit-tests
main :: IO ()

module GLL.Combinators.Interface

-- | A parser expression representing a symbol.
data SymbParser b

-- | A parser expression representing an alternative (right-hand side).
data IMParser b
class HasAlts a
altsOf :: HasAlts a => a b -> ([] :. IMParser) b
class IsSymbParser a
toSymb :: IsSymbParser a => a b -> SymbParser b
class IsIMParser a
toImp :: IsIMParser a => a b -> IMParser b

-- | The semantic results of a parser, given a string of Tokens
parse :: IsSymbParser s => s a -> [Token] -> [a]

-- | Parse a string of characters
parseString :: IsSymbParser s => s a -> String -> [a]
char :: Char -> SymbParser Char
token :: Token -> SymbParser Token
data Token
Char :: (Char) -> Token
EOS :: Token
Epsilon :: Token
Int :: (((Maybe Int))) -> Token
Bool :: (((Maybe Bool))) -> Token
String :: (((Maybe String))) -> Token
Token :: (String) -> (((Maybe String))) -> Token
epsilon :: SymbParser ()
satisfy :: a -> IMParser a
many :: SymbParser a -> SymbParser [a]
some :: SymbParser a -> SymbParser [a]
optional :: SymbParser a -> SymbParser (Maybe a)

-- | Use this combinator on all combinators that might have an infinite
--   number of derivations for some input string. A non-terminal has this
--   property if and only if it is left-recursive and would be
--   left-recursive if all the right-hand sides of the productions of the
--   grammar are reversed.
(<::=>) :: HasAlts b => String -> b a -> SymbParser a

-- | Use this combinator on all recursive non-terminals
(<:=>) :: HasAlts b => String -> b a -> SymbParser a
(<$>) :: IsSymbParser s => (a -> b) -> s a -> IMParser b
(<$) :: IsSymbParser s => b -> s a -> IMParser b
(<*>) :: (IsIMParser i, IsSymbParser s) => i (a -> b) -> s a -> IMParser b
(<*) :: (IsIMParser i, IsSymbParser s) => i b -> s a -> IMParser b
(<|>) :: (IsIMParser i, HasAlts b) => i a -> b a -> ([] :. IMParser) a

-- | Composition of unary type constructors
--   
--   There are (at least) two useful <a>Monoid</a> instances, so you'll
--   have to pick one and type-specialize it (filling in all or parts of
--   <tt>g</tt> and/or <tt>f</tt>).
--   
--   <pre>
--   -- standard Monoid instance for Applicative applied to Monoid
--   instance (Applicative (g :. f), Monoid a) =&gt; Monoid ((g :. f) a) where
--     { mempty = pure mempty; mappend = liftA2 mappend }
--   -- Especially handy when g is a Monoid_f.
--   instance Monoid (g (f a)) =&gt; Monoid ((g :. f) a) where
--     { mempty = O mempty; mappend = inO2 mappend }
--   </pre>
--   
--   Corresponding to the first and second definitions above,
--   
--   <pre>
--   instance (Applicative g, Monoid_f f) =&gt; Monoid_f (g :. f) where
--     { mempty_f = O (pure mempty_f); mappend_f = inO2 (liftA2 mappend_f) }
--   instance Monoid_f g =&gt; Monoid_f (g :. f) where
--     { mempty_f = O mempty_f; mappend_f = inO2 mappend_f }
--   </pre>
--   
--   Similarly, there are two useful <a>Functor</a> instances and two
--   useful <a>ContraFunctor</a> instances.
--   
--   <pre>
--   instance (      Functor g,       Functor f) =&gt; Functor (g :. f) where fmap = fmapFF
--   instance (ContraFunctor g, ContraFunctor f) =&gt; Functor (g :. f) where fmap = fmapCC
--   
--   instance (      Functor g, ContraFunctor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapFC
--   instance (ContraFunctor g,       Functor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapCF
--   </pre>
--   
--   However, it's such a bother to define the Functor instances per
--   composition type, I've left the fmapFF case in. If you want the fmapCC
--   one, you're out of luck for now. I'd love to hear a good solution.
--   Maybe someday Haskell will do Prolog-style search for instances,
--   subgoaling the constraints, rather than just matching instance heads.
data (:.) (g :: * -> *) (f :: * -> *) a :: (* -> *) -> (* -> *) -> * -> *
instance IsSymbParser ([] :. IMParser)
instance IsSymbParser SymbParser
instance IsSymbParser IMParser
instance IsIMParser ([] :. IMParser)
instance IsIMParser SymbParser
instance IsIMParser IMParser
instance HasAlts ([] :. IMParser)
instance HasAlts SymbParser
instance HasAlts IMParser


-- | This model contains unit-tests for <a>Interface</a>
--   
--   <h1>Included examples</h1>
--   
--   <ul>
--   <li>Elementary parsers</li>
--   <li>Sequencing</li>
--   <li>Alternatives</li>
--   <li>Simple binding</li>
--   <li>Binding with alternatives</li>
--   <li>Recursion (non-left)</li>
--   <li>Higher-order patterns:<ul><li>Optional</li><li>Kleene-closure /
--   positive closure</li><li>Seperator</li><li>Inline
--   choice</li></ul></li>
--   </ul>
--   
--   <ul>
--   
--   <li>Ambiguities:<ul><li>"aaa"</li><li>longambig</li><li>aho_s</li><li>EEE</li></ul></li>
--   <li>Left recursion</li>
--   <li>Hidden left-recursion</li>
--   </ul>
module GLL.Combinators.Test.Interface

-- | Defines and executes some unit-tests
main :: IO ()
