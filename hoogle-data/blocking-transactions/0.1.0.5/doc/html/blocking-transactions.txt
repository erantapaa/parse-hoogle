-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Composable, blocking transactions.
--   
--   A variable type (BVar), monad (BTM), and arrow (BTA), which provide
--   fast, atomic, composable, blocking inter-thread communication.
--   Blocking transactions are strictly less expressive than software
--   transactional memory, but may be more efficient under very high
--   contention.
@package blocking-transactions
@version 0.1.0.5


-- | Composable blocking transactions, based on the blog post:
--   <a>http://blog.downstairspeople.org/2010/06/06/composable-blocking-transactions/</a>
module BlockingTransactions.BlockingTransactions

-- | A transactional variable with a blocking implementation.
data BVar a

-- | Construct a new transactional variable.
newBVar :: a -> IO (BVar a)

-- | Observe the contents of a transactional variable.
peekBVar :: BVar a -> IO a

-- | One-off write to a transactional variable.
pokeBVar :: BVar a -> a -> IO ()

-- | Perform a transaction using only a single variable.
modifyBVar :: BVar a -> (a -> (a, b)) -> IO b

-- | Commit a blocking transaction.
runBTM :: (forall e. BTM e (Value e a)) -> IO a

-- | The blocking transaction monad.
data BTM e a

-- | An opaque value. It can be modified and combined with other opaque
--   values, but not observed.
--   
--   The type variable <tt>e</tt> binds the value to the monadic context in
--   which it occurs, (this is identical to the <tt>runST</tt> existential
--   type trick).
data Value e a

-- | Flow control. Skip the critical section if the predicate is false.
when :: Value e Bool -> BTM e (Value e ()) -> BTM e (Value e ())

-- | Flow control. Skip the critical section if the predicate is true.
unless :: Value e Bool -> BTM e (Value e ()) -> BTM e (Value e ())

-- | Read from a variable.
readBVar :: BVar a -> BTM e (Value e a)

-- | Write to a variable.
writeBVar :: BVar a -> Value e a -> BTM e (Value e ())

-- | Electively retry. This will restore all variables to their state
--   before the transaction began, and listen for a change to any variable
--   in the working set before trying the transaction again.
retry :: BTM e (Value e ())
runBTA :: BTA a b -> a -> IO b

-- | The blocking transaction arrow. The semantics are identical to the
--   equivalent operations on the monadic interface.
data BTA a b

-- | As <a>writeBVar</a>.
fetchBVar :: BVar a -> BTA () a

-- | As <a>readBVar</a>.
storeBVar :: BVar a -> BTA a ()

-- | As <a>retry</a>.
retryWhen :: BTA Bool ()
retryUnless :: BTA Bool ()
instance ArrowChoice BTA
instance Arrow BTA
instance Category BTA
instance Applicative (BTA a)
instance Functor (BTA a)
instance Monad (Value e)
instance Monad (BTM e)
instance Applicative (Value e)
instance Applicative (BTM e)
instance Functor (Value e)
instance Functor (BTM e)
instance Ord AnonymousVar
instance Eq AnonymousVar
instance Ord (BVar a)
instance Eq (BVar a)
