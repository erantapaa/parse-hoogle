-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Page-oriented extraction and composition library
--   
--   Provides an interface to the PageIn export format (.dux) from the
--   StreamServe Persuasion(tm) platform, using it both as a data
--   extraction as well as a page layout DSL. (Extremely experimental, no
--   documentations at the moment!)
@package PageIO
@version 0.0.3

module Text.PageIO.LabelMap
newtype LabelMap a
MkLabelMap :: IntMap a -> LabelMap a
labelMap :: LabelMap a -> IntMap a
newtype Label
MkLabel :: Atom -> Label
labelAtom :: Label -> Atom
toLabel :: (ToAtom a) => a -> Label
fromLabel :: (FromAtom a) => Label -> a
fromList :: [(Label, a)] -> LabelMap a
fromListWith :: (a -> a -> a) -> [(Label, a)] -> LabelMap a
toList :: LabelMap a -> [(Label, a)]
keyToLabel :: Key -> Label
mapWithKey :: (Label -> a -> b) -> LabelMap a -> LabelMap b
elems :: LabelMap a -> [a]
union :: LabelMap a -> LabelMap a -> LabelMap a
unionWith :: (a -> a -> a) -> LabelMap a -> LabelMap a -> LabelMap a
unions :: [LabelMap a] -> LabelMap a
unionsWith :: (a -> a -> a) -> [LabelMap a] -> LabelMap a
lookup :: Label -> LabelMap a -> Maybe a
insert :: Label -> a -> LabelMap a -> LabelMap a
insertWith :: (a -> a -> a) -> Label -> a -> LabelMap a -> LabelMap a
member :: Label -> LabelMap a -> Bool
keys :: LabelMap a -> [Label]
filter :: (a -> Bool) -> LabelMap a -> LabelMap a
null :: LabelMap a -> Bool
mapMaybe :: (a -> Maybe b) -> LabelMap a -> LabelMap b
mapMaybeWithKey :: (Label -> a -> Maybe b) -> LabelMap a -> LabelMap b
intersection :: LabelMap a -> LabelMap b -> LabelMap a
instance Eq Label
instance Ord Label
instance (Eq a) => Eq (LabelMap a)
instance (Ord a) => Ord (LabelMap a)
instance Functor LabelMap
instance Monoid (LabelMap a)
instance Show Label
instance (Show a) => Show (LabelMap a)

module Text.PageIO.Types
newtype Page
MkPage :: [Value] -> Page
pageLines :: Page -> [Value]
type Col = Int
type Row = Int
type FractionDigits = Int
data FieldFormat
FGeneral :: FieldFormat
FNumeric :: FractionDigits -> FieldFormat
FDate :: FieldFormat
type Value = ByteString
data Box
MkBox :: !Col -> !Row -> Col -> !Row -> Box
boxLeft :: Box -> !Col
boxTop :: Box -> !Row
boxRight :: Box -> Col
boxBottom :: Box -> !Row
data Sheet
MkSheet :: !Label -> !Box -> !LabelMap Pattern -> !LabelMap Field -> ![Frame] -> ![Label] -> ![Label] -> !Bool -> Sheet
sheetName :: Sheet -> !Label
sheetBox :: Sheet -> !Box
sheetPatterns :: Sheet -> !LabelMap Pattern
sheetFields :: Sheet -> !LabelMap Field
sheetFrames :: Sheet -> ![Frame]
sheetGroupBy :: Sheet -> ![Label]
sheetOrderBy :: Sheet -> ![Label]
sheetUseBlockSortPriority :: Sheet -> !Bool
data Pattern
MkPattern :: !Box -> !Match -> !Bool -> Pattern
patternBox :: Pattern -> !Box
patternMatch :: Pattern -> !Match
patternUseWildcards :: Pattern -> !Bool
data Scope
SPage :: Scope
SDoc :: Scope
data Variable
VPage :: Variable
VSum :: !Scope -> !Label -> Variable
vScope :: Variable -> !Scope
vLabel :: Variable -> !Label
VCount :: !Scope -> !Label -> Variable
vScope :: Variable -> !Scope
vLabel :: Variable -> !Label
VLabel :: !Label -> Variable
vLabel :: Variable -> !Label
VSubStr :: !Label -> !Int -> !Int -> Variable
vLabel :: Variable -> !Label
vDrop :: Variable -> !Int
vTake :: Variable -> !Int
VReplace :: !Label -> ![(Value, Value)] -> Variable
vLabel :: Variable -> !Label
vMatchReplace :: Variable -> ![(Value, Value)]
VLiteral :: !Value -> Variable
vValue :: Variable -> !Value
data Field
MkField :: !Box -> !Maybe Variable -> !Bool -> !FieldFormat -> Field
fieldBox :: Field -> !Box
fieldVariable :: Field -> !Maybe Variable
fieldKeepSpaces :: Field -> !Bool
fieldFormat :: Field -> !FieldFormat
data Frame
MkFrame :: !Box -> !LabelMap Block -> Frame
frameBox :: Frame -> !Box
frameBlocks :: Frame -> !LabelMap Block
data Operator
ONot :: !Operator -> Operator
OContains :: Operator
OEq :: Operator
OEndsWith :: Operator
OStartsWith :: Operator
data Filter
MkFilter :: !Label -> !Operator -> !Match -> Filter
filterField :: Filter -> !Label
filterOperator :: Filter -> !Operator
filterMatch :: Filter -> !Match
data OrderBy a
DAscending :: !a -> OrderBy a
DDescending :: !a -> OrderBy a
data Block
MkBlock :: !Row -> !LabelMap Pattern -> !LabelMap Field -> ![OrderBy Label] -> ![Label] -> ![Filter] -> !Bool -> Block
blockLines :: Block -> !Row
blockPatterns :: Block -> !LabelMap Pattern
blockFields :: Block -> !LabelMap Field
blockOrderBy :: Block -> ![OrderBy Label]
blockGroupBy :: Block -> ![Label]
blockFilterBy :: Block -> ![Filter]
blockUsePriority :: Block -> !Bool
newtype Match
MkMatch :: Value -> Match
matchValue :: Match -> Value
matches :: Value -> Match -> Bool
valToIntVal :: Value -> Value
valToInt :: Value -> Int
matchSubstring :: Value -> Match -> (Maybe Int)
instance Show Match
instance Eq Match
instance Ord Match
instance Show Block
instance Eq Block
instance Ord Block
instance (Show a) => Show (OrderBy a)
instance (Eq a) => Eq (OrderBy a)
instance Show Filter
instance Eq Filter
instance Ord Filter
instance Show Operator
instance Eq Operator
instance Ord Operator
instance Show Frame
instance Eq Frame
instance Ord Frame
instance Show Field
instance Eq Field
instance Ord Field
instance Show Variable
instance Eq Variable
instance Ord Variable
instance Show Scope
instance Eq Scope
instance Ord Scope
instance Show Pattern
instance Eq Pattern
instance Ord Pattern
instance Show Sheet
instance Eq Sheet
instance Ord Sheet
instance Show Box
instance Eq Box
instance Ord Box
instance Show FieldFormat
instance Eq FieldFormat
instance Ord FieldFormat
instance Show Page
instance Eq Page
instance Ord Page
instance Monoid Page
instance (Ord a) => Ord (OrderBy a)
instance Functor OrderBy

module Text.PageIO.Infer
inferSheet :: FilePath -> [Page] -> Sheet
mkField :: String -> Col -> Row -> Col -> Row -> (Label, Field)
namePattern :: Value
datePattern :: Value
data DateMatch
MkDateMatch :: Int -> Bool -> (Int, Int) -> (Int, Int) -> Maybe (Int, Int) -> DateMatch
matchLine :: DateMatch -> Int
matchIsROC :: DateMatch -> Bool
matchYear :: DateMatch -> (Int, Int)
matchMonth :: DateMatch -> (Int, Int)
matchDay :: DateMatch -> Maybe (Int, Int)
inferPageNameField :: Page -> (Label, Field)
tryMatchName :: (Int, Value) -> [(Label, Field)]
inferPageDateFields :: Page -> [(Label, Field)]
tryMatchDate :: (Int, Value) -> [DateMatch]
validateMatch :: MatchText Value -> Maybe DateMatch
dateMatchToFields :: DateMatch -> [(Label, Field)]
instance Show DateMatch
instance Eq DateMatch
instance Ord DateMatch

module Text.PageIO.Extract
type Area = Page
newtype BlockResult
MkBlockResult :: [(Area, LabelMap Bound)] -> BlockResult
blockResults :: BlockResult -> [(Area, LabelMap Bound)]
type Bound = Value
data SheetResult
MkSheetResult :: !LabelMap Bound -> !LabelMap BlockResult -> SheetResult
resultFields :: SheetResult -> !LabelMap Bound
resultBlocks :: SheetResult -> !LabelMap BlockResult
prettyEntry :: (Show a) => (Label, a) -> String
extractPage :: Sheet -> Page -> Maybe SheetResult
crop :: Box -> Page -> Page
checkPattern :: Page -> Pattern -> Bool
extractField :: Page -> Field -> Bound
fieldLen :: Field -> Int
extractBlocks :: LabelMap Block -> Page -> [(Label, BlockResult)]
extractBlock :: Block -> Page -> Maybe BlockResult
pageVal :: Page -> Value
instance Eq SheetResult
instance Ord SheetResult
instance Eq BlockResult
instance Ord BlockResult
instance Monoid BlockResult
instance Show SheetResult
instance Show BlockResult
instance Monoid SheetResult

module Text.PageIO.Transform
data Doc
MkDoc :: !SheetResult -> !ByteString -> Doc
docMeta :: Doc -> !SheetResult
docContent :: Doc -> !ByteString
type ValueMap = LabelMap [Value]
data AppliedVariable
MkAppliedVariable :: !Row -> !Col -> !Value -> AppliedVariable
avRow :: AppliedVariable -> !Row
avCol :: AppliedVariable -> !Col
avValue :: AppliedVariable -> !Value
data Slot
MkSlot :: !Row -> ![Label] -> Slot
slotSize :: Slot -> !Row
slotBlocks :: Slot -> ![Label]
type Ordered a = ([OrderBy (Maybe Value)], a)
data BlockData
MkBlockData :: !Row -> ![Ordered FieldBinding] -> BlockData
dataSize :: BlockData -> !Row
dataAreas :: BlockData -> ![Ordered FieldBinding]
type PageCapacity = [Slot]
type FitAttempt = LabelMap BlockData
type PageBinding = LabelMap [FieldBinding]
type FieldBinding = (Area, LabelMap Bound)
parsePages :: Sheet -> [Page] -> [Doc]
emitDoc :: [(SheetResult, Page)] -> Doc
transformPages :: Sheet -> [Page] -> Sheet -> [Page] -> [Doc]
makeDoc :: Sheet -> [DocBinding] -> Doc
packPages :: [Page] -> ByteString
data DocBinding
MkDocBinding :: !ValueMap -> !SheetResult -> !Page -> !PageBinding -> DocBinding
docValueMap :: DocBinding -> !ValueMap
docResult :: DocBinding -> !SheetResult
docPage :: DocBinding -> !Page
docBinding :: DocBinding -> !PageBinding
bindDoc :: Sheet -> [Page] -> [SheetResult] -> [DocBinding]
doGroupBlockData :: LabelMap [Label] -> LabelMap (LabelMap Field) -> Label -> BlockData -> BlockData
doExpandFields :: LabelMap Field -> Ordered FieldBinding -> Ordered FieldBinding
replaceWith :: Value -> Value -> Value -> Value
doGroupArea :: [Label] -> LabelMap Field -> [Ordered FieldBinding] -> [Ordered FieldBinding]
doGroupRows :: LabelMap Field -> [Ordered FieldBinding] -> Ordered FieldBinding
repeatTails :: [a] -> [[a]]
constToPattern :: Sheet -> Sheet
fillVariables :: Sheet -> [SheetResult] -> [Page] -> [Page]
formatInt :: Int -> Int -> Value
formatFloat :: Int -> Int -> Value
makeValueMap :: SheetResult -> ValueMap
makePage :: Sheet -> PageBinding -> Page -> Page
doGroupBy :: [(Block, LabelMap Bound)] -> [(Block, LabelMap Bound)]
replacePage :: (Page, Box) -> (Block, LabelMap Bound) -> (Page, Box)
replaceArea :: Box -> [Area] -> Page -> Page
clearArea :: Box -> Page -> Page
fillArea :: Row -> Col -> Area -> Page -> Page
fillLine :: Col -> (Value, Value) -> Value
doCapacity :: Sheet -> [PageCapacity] -> SheetResult -> [PageCapacity]
doAttempt :: LabelMap [OrderBy Label] -> FitAttempt -> SheetResult -> FitAttempt
areaRows :: Area -> Row
fillPageVariables :: LabelMap AppliedVariable -> Page -> Page
valueToArea :: Value -> Area
sheetVariableFields :: Sheet -> (LabelMap Field, LabelMap Field)
sheetBlockOrderBys :: Sheet -> LabelMap [OrderBy Label]
sheetBlockGroupBys :: Sheet -> LabelMap [Label]
sheetBlockFields :: Sheet -> LabelMap (LabelMap Field)
gatherForSheetBlock :: (Block -> a) -> Sheet -> LabelMap a
tryFit :: [PageCapacity] -> FitAttempt -> Maybe [PageBinding]
fitOnePage :: [Slot] -> (PageBinding, FitAttempt) -> (PageBinding, FitAttempt)
fitOneSlot :: Slot -> (PageBinding, FitAttempt) -> (PageBinding, FitAttempt)
instance Show DocBinding
instance Eq DocBinding
instance Ord DocBinding
instance Eq BlockData
instance Ord BlockData
instance Show BlockData
instance Eq Slot
instance Ord Slot
instance Show Slot
instance Show AppliedVariable
instance Eq AppliedVariable
instance Ord AppliedVariable
instance Show Doc
instance Eq Doc
instance Ord Doc
instance Monoid BlockData

module Text.PageIO.Parser
liftA4 :: (Applicative f) => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
liftA5 :: (Applicative f) => (a -> b -> c -> d -> e -> result) -> f a -> f b -> f c -> f d -> f e -> f result
(<$$>) :: (Functor f) => f a -> (a -> b) -> f b
readSheet :: FilePath -> IO Sheet
parseFromFile :: Parser a -> String -> IO (Either ParseError a)
parseMaybe :: Parser a -> Parser (Maybe a)
maybeFieldVariable :: Parser (Maybe Variable)
literalVariable :: Parser Variable
functionVariable :: Parser Variable
substrVariable :: Parser Variable
replaceVariable :: Parser Variable
bareLabel :: Parser Label
maybeFieldFormat :: Parser (Maybe FieldFormat)
maybeFilters :: Parser (Maybe [Filter])
parseFilter :: Parser Filter
operator :: Parser Operator
commaSep :: Parser a -> Parser [a]
maybeOrderBys :: Parser (Maybe [OrderBy Label])
maybeBy :: String -> Parser (Maybe [Label])
maybeRule :: Parser (Maybe a) -> Parser (Maybe a)
parseLabel :: Parser Label
r :: Parser a -> Parser a
sheet :: Parser Sheet
sym :: String -> Parser ()
sp :: Parser ()
num :: Parser Int
pattern :: Parser (Label, Pattern)
field :: Parser (Label, Field)
boxNumbers :: Parser Box
frame :: Parser Frame
retLabel :: Label -> a -> Parser (Label, a)
block :: Parser (Label, Block)
literalStr :: Parser Value
matchStr :: Parser Match
mkMatch :: Value -> Match
packLBS :: ByteString -> ByteString
labelStr :: Parser Label
str :: Parser ByteString
quotedValue :: Parser Value
sepEndBy :: (Alternative f) => f a -> f b -> f [a]
sepEndBy1 :: (Alternative f) => f a -> f b -> f [a]
many1 :: (Alternative f) => f a -> f [a]
choice :: (Alternative f) => [f a] -> f a
between :: Parser a -> Parser b -> Parser c -> Parser c
oneOf :: [Char] -> Parser Char
noneOf :: [Char] -> Parser Char

module Text.PageIO.Index
indexDocs :: Sheet -> [Doc] -> IO ()
blockProduct :: [(Area, LabelMap Bound)] -> BlockResult -> [(Area, LabelMap Bound)]
fromYMD :: Int -> Int -> Int -> String

module Text.PageIO.Run
readPages :: FilePath -> IO [Page]
hReadPages :: Handle -> IO [Page]
hReadPagesLazy :: Handle -> IO [Page]
hReadPagesStrict :: Handle -> Int -> IO [Page]
putPage :: Page -> IO ()

module Text.PageIO
