-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Plant growing programming game
--   
--   The players of this game will write code (the „genome“) that describes
--   how plants (the biological type, not the industrial) will grow. The
--   plants will grow simultaneously on the screen (the „garden“), will
--   compete for light and will multiply. The players can not change the
--   code of a growing plant, but they do have the chance to update their
--   code for the next generation -- when a plant drops a seed, it will run
--   the newest code. All in all, the game aims to be slowly paced and
--   relaxing, something to just watch for a while and something that does
--   not need constant attention by the players.
--   
--   This package contains the haskell programs, i.e. the game simulation
--   with the visual display. It can be used to locally test the plants.
@package L-seed
@version 0.2


-- | Helper module providing a monad that collects lines
module Lseed.Geometry.Generator
data GeometryGenerator x a
translated :: Point -> GeometryGenerator x a -> GeometryGenerator x a
rotated :: Double -> GeometryGenerator x a -> GeometryGenerator x a
runGeometryGenerator :: Point -> Double -> GeometryGenerator x () -> [(Line, x)]
addLine :: x -> Line -> GeometryGenerator x ()
instance Monad (GeometryGenerator x)


-- | Data definitions for L-seed
module Lseed.Data

-- | User Tag
type UserTag = String

-- | Light angle
type Angle = Double

-- | A list of plants, together with their position in the garden, in the
--   interval [0,1]
type Garden a = [Planted a]

-- | Named variants of a garden, for more expressive type signatures
type GrowingGarden = Garden GrowthState
type AnnotatedGarden = Garden StipeInfo

-- | A plant with metainformatoin
data Planted a
Planted :: Double -> Integer -> String -> GrammarFile -> Plant a -> Planted a

-- | Position in the garden, interval [0,1]
plantPosition :: Planted a -> Double

-- | Id of the user that owns this plant
plantOwner :: Planted a -> Integer

-- | Name of the owner of the plant
plantOwnerName :: Planted a -> String

-- | Lsystem in use
genome :: Planted a -> GrammarFile

-- | Actual current form of the plant
phenotype :: Planted a -> Plant a

-- | Named variants of a Planted, for more expressive type signatures
type GrowingPlanted = Planted GrowthState
type AnnotatedPlanted = Planted StipeInfo

-- | A plant, which is
data Plant a

-- | a stipe with a length (factor of stipeLength), an angle relative to
--   the parent stipe and a list of plants sprouting at the end
Plant :: a -> Double -> Angle -> UserTag -> [Plant a] -> Plant a
pData :: Plant a -> a
pLength :: Plant a -> Double
pAngle :: Plant a -> Angle
pUserTag :: Plant a -> UserTag
pBranches :: Plant a -> [Plant a]

-- | A straight, untagged plant with length zero and no branches.
data StipeInfo
StipeInfo :: Double -> Double -> Double -> Double -> Angle -> Angle -> Double -> Double -> Double -> GrowthState -> StipeInfo

-- | a bit redundant, but what shells
siLength :: StipeInfo -> Double
siSubLength :: StipeInfo -> Double
siLight :: StipeInfo -> Double
siSubLight :: StipeInfo -> Double
siAngle :: StipeInfo -> Angle
siDirection :: StipeInfo -> Angle

-- | Sideways position, relative to Plant origin
siOffset :: StipeInfo -> Double

-- | Vertical distance from bottom
siHeight :: StipeInfo -> Double

-- | Distance from root
siDistance :: StipeInfo -> Double
siGrowth :: StipeInfo -> GrowthState

-- | A GrowingPlant can be growing in one of these three ways:
data GrowthState
NoGrowth :: GrowthState

-- | value indicates the growth target
EnlargingTo :: Double -> GrowthState

-- | value indicates the current state [0..1]
GrowingSeed :: Double -> GrowthState

-- | Named variants of a Plant, for more expressive type signatures
type GrowingPlant = Plant GrowthState
type AnnotatedPlant = Plant StipeInfo

-- | Representation of what is on screen
data ScreenContent
ScreenContent :: AnnotatedGarden -> Double -> String -> Maybe String -> ScreenContent
scGarden :: ScreenContent -> AnnotatedGarden
scLightAngle :: ScreenContent -> Double
scTime :: ScreenContent -> String
scMessage :: ScreenContent -> Maybe String

-- | Main loop observers
data Observer
Observer :: IO () -> (Integer -> Angle -> GrowingGarden -> IO ()) -> ((ClockTime -> ScreenContent) -> IO ()) -> (GrowingGarden -> IO ()) -> IO () -> Observer

-- | Called once per season, before the main loop starts
obInit :: Observer -> IO ()

-- | Called once per tick, with the current tick number corresponding light
--   angle and the current state of the garden
obState :: Observer -> Integer -> Angle -> GrowingGarden -> IO ()

-- | Also called once per tick, with a function that calculates the
--   information that should be displayed given a point in time
obGrowingState :: Observer -> (ClockTime -> ScreenContent) -> IO ()

-- | Called before the main loop quits, with the last state of the garden
obFinished :: Observer -> GrowingGarden -> IO ()

-- | Called once before program termination
obShutdown :: Observer -> IO ()

-- | Methods to get the initial garden and the updated code when a plant
--   multiplies
data GardenSource
GardenSource :: IO (Garden ()) -> (Planted () -> IO GrammarFile) -> IO (Maybe String) -> GardenSource

-- | Called at the beginning of a season, to aquire the garden
getGarden :: GardenSource -> IO (Garden ())

-- | Given a plant, returns the genome to be used for a seedling.
getUpdatedCode :: GardenSource -> Planted () -> IO GrammarFile

-- | Text to display on the screen
getScreenMessage :: GardenSource -> IO (Maybe String)
constGardenSource :: Garden () -> GardenSource

-- | A complete grammar file
type GrammarFile = [GrammarRule]
type Priority = Int
type Weight = Int
defaultPriority :: Priority
defaultWeight :: Weight

-- | A single Rule. For now, only single branches can be matched, not whole
--   subtree structures
data GrammarRule
GrammarRule :: String -> Priority -> Weight -> Condition -> GrammarAction -> GrammarRule
grName :: GrammarRule -> String
grPriority :: GrammarRule -> Priority
grWeight :: GrammarRule -> Weight
grCondition :: GrammarRule -> Condition
grAction :: GrammarRule -> GrammarAction
data Matchable
MatchLight :: Matchable
MatchSubLight :: Matchable
MatchLength :: Matchable
MatchSubLength :: Matchable
MatchDirection :: Matchable
MatchAngle :: Matchable
MatchDistance :: Matchable
data Cmp
LE :: Cmp
Less :: Cmp
Equals :: Cmp
Greater :: Cmp
GE :: Cmp
data Condition
Always :: Bool -> Condition
And :: Condition -> Condition -> Condition
Or :: Condition -> Condition -> Condition
UserTagIs :: String -> Condition
NumCond :: Matchable -> Cmp -> Double -> Condition
data GrammarAction
SetLength :: (Maybe UserTag) -> LengthDescr -> GrammarAction
AddBranches :: (Maybe UserTag) -> Double -> [(Angle, Double, Maybe UserTag)] -> GrammarAction
Blossom :: (Maybe UserTag) -> GrammarAction
data LengthDescr
Absolute :: Double -> LengthDescr
Additional :: Double -> LengthDescr

-- | in Percent
AdditionalRelative :: Double -> LengthDescr
instance Read LengthDescr
instance Show LengthDescr
instance Read GrammarAction
instance Show GrammarAction
instance Read Condition
instance Show Condition
instance Read Cmp
instance Show Cmp
instance Read Matchable
instance Show Matchable
instance Read GrammarRule
instance Show GrammarRule
instance Show GrowthState
instance Show StipeInfo
instance (Show a) => Show (Plant a)
instance (Show a) => Show (Planted a)
instance Monoid Observer
instance Traversable Planted
instance Foldable Planted
instance Functor Planted
instance Traversable Plant
instance Foldable Plant
instance Functor Plant

module Lseed.Data.Functions

-- | Puts the length of the current segment in the additional information
--   field
plantPieceLengths :: Plant a -> Plant Double
plantWeightedPieceLengths :: Double -> Plant a -> Plant Double
weightedPlantLength :: Plant a -> Double
plantLength :: Plant a -> Double
plantTotalSum :: Plant Double -> Double
subPieceAccumulate :: (Monoid m) => Plant m -> Plant m

-- | Apply a function to each Planted in a Garden
mapGarden :: (Planted a -> Planted b) -> Garden a -> Garden b

-- | Apply a function to each Planted in a Garden, with an extra argument
--   from a list
--   
--   You need to make sure that the list is long enough!
zipWithGarden :: (Planted a -> x -> Planted b) -> Garden a -> [x] -> Garden b

-- | Apply a function to the Plant in a Planted
mapPlanted :: (Plant a -> Plant b) -> Planted a -> Planted b

module Lseed.Grammar.Parse
parseGrammar :: String -> String -> Either ParseError GrammarFile


-- | This module contians the main nobs to control the game play.
--   
--   All length data is relative to the screen width.
module Lseed.Constants
groundLevel :: Double
budSize :: Double
stipeLength :: Double
blossomSize :: Double
stipeWidth :: Double

-- | Light and growths interpolation frequency
ticksPerDay :: Integer

-- | Plant length growth per Day and Light
--   
--   1 means: Can grow one stipeLength during one day, when catching the
--   sunlight with one branch of (projected) length screenwidth
growthPerDayAndLight :: Double

-- | Plants up to this size get an boost in growths
smallPlantBoostSize :: Double

-- | Minimum growths for plants of size less then smallPlantBoostSize
smallPlantBoostLength :: Double

-- | Cost (in light units) per (sum for all branches (length * distance),
--   to limit the growth of the plants
costPerLength :: Double

-- | Cost (in length growths equivalent) per seed to be grown
seedGrowthCost :: Double

-- | Branch translucency. Proportion of light that is let through by a
--   plant
lightFalloff :: Double

-- | Length of one day, in seconds
dayLength :: Double

-- | 
--   
--   Minimum radial angular distance between two branches
minAngle :: Double

module Lseed.Geometry
type Point = (Double, Double)
type Line = (Point, Point)

-- | from http:<i></i>www.pdas.com/lineint.htm
crossPoint :: Line -> Line -> Maybe Point
plantedToLines :: Planted a -> [(Line, a)]
plantToGeometry :: Plant a -> GeometryGenerator a ()

-- | Lines are annotated with its plant, identified by the extra data
gardenToLines :: Garden a -> [(Line, a)]

-- | Add lightning from a given angle
lightenLines :: Double -> [(Line, a)] -> [(Line, a, Double)]
lightPolygons :: Double -> [(Line, a)] -> [(Point, Point, Point, Point, Double)]
allKindsOfStuffWithAngle :: Double -> [(Line, a)] -> ([(Line, a, Double)], [(Point, Point, Point, Point, Double)])

-- | Annotates each piece of the garden with the amount of line it attacts
lightenGarden :: Angle -> Garden a -> Garden (a, Double)

-- | Helper to apply a function that works on lines to a garden
mapLine :: (forall b. [(Line, b)] -> [(Line, b, c)]) -> c -> (c -> c -> c) -> Garden a -> Garden (a, c)

-- | Slightly shifts angles
--   
--   For a Garden, calculates the maximum size to the left, to the right,
--   and maximum height
gardenOffset :: AnnotatedGarden -> (Double, Double, Double)

module Lseed.LSystem
applyLSystem :: (RandomGen g) => g -> GrammarFile -> AnnotatedPlant -> GrowingPlant
conformsTo :: AnnotatedPlant -> Condition -> Bool

-- | Length reductions are silenty turned into no-ops
calcLengthDescr :: LengthDescr -> Double -> Double

module Lseed.StipeInfo
annotateGarden :: Angle -> GrowingGarden -> AnnotatedGarden
annotatePlant :: Plant (GrowthState, Double) -> AnnotatedPlant


-- | This module is mostly a general dump...
module Lseed.Logic
timeSpanFraction :: Double -> ClockTime -> ClockTime -> Double
formatTimeInfo :: Integer -> Double -> String

-- | Given the fraction of the time passed, returnes the angle of the
--   sunlight
lightAngle :: Double -> Angle

-- | Calculates the length to be grown
remainingGrowth :: (a -> GrowthState) -> Planted a -> Double

-- | For a GrowingGarden, calculates the current amount of light and then
--   advance the growth. This ought to be called after applyGenome
growGarden :: (RandomGen g) => Angle -> g -> GrowingGarden -> (Double -> GrowingGarden)

-- | For all Growing plants that are done, find out the next step If new
--   plants are to be created, these are returned via their position, next
--   to their parent plant.
applyGenome :: (RandomGen g) => Angle -> g -> GrowingGarden -> [(GrowingPlanted, [Double])]

-- | Applies an L-System to a Plant, putting the new length in the
--   additional information field
growPlanted :: GrowingPlanted -> Double -> (Double -> GrowingPlanted)

-- | Applies Growth at given fraction, leaving the target length in place
applyGrowth :: Double -> GrowingPlanted -> GrowingPlanted
applyGrowth' :: (Double -> Double -> Double) -> GrowingPlant -> GrowingPlant


-- | This module contains a runner for a an Lseed garden. It can be passed
--   an observer that will receive the results.
module Lseed.Mainloop

-- | Lets a garden grow for the given number of days, while keeping the
--   observer informed about any changes.
lseedMainLoop :: Bool -> Observer -> GardenSource -> Integer -> IO ()
