-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Arrow based stream transducers
--   
@package machinecell
@version 2.0.1


-- | Arrow utilities not related to machinecell library.
module Control.Arrow.Machine.ArrowUtil
ary0 :: (forall p q. (p -> m q) -> a p q) -> m b -> a () b
ary1 :: (forall p q. (p -> m q) -> a p q) -> (a1 -> m b) -> a a1 b
ary2 :: (forall p q. (p -> m q) -> a p q) -> (a1 -> a2 -> m b) -> a (a1, a2) b
ary3 :: (forall p q. (p -> m q) -> a p q) -> (a1 -> a2 -> a3 -> m b) -> a (a1, a2, a3) b
ary4 :: (forall p q. (p -> m q) -> a p q) -> (a1 -> a2 -> a3 -> a4 -> m b) -> a (a1, a2, a3, a4) b
ary5 :: (forall p q. (p -> m q) -> a p q) -> (a1 -> a2 -> a3 -> a4 -> a5 -> m b) -> a (a1, a2, a3, a4, a5) b
kleisli :: Monad m => (a -> m b) -> Kleisli m a b
kleisli0 :: Monad m => m b -> Kleisli m () b
kleisli2 :: Monad m => (a1 -> a2 -> m b) -> Kleisli m (a1, a2) b
kleisli3 :: Monad m => (a1 -> a2 -> a3 -> m b) -> Kleisli m (a1, a2, a3) b
kleisli4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> m b) -> Kleisli m (a1, a2, a3, a4) b
kleisli5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> m b) -> Kleisli m (a1, a2, a3, a4, a5) b
unArrowMonad :: ArrowApply a => (p -> ArrowMonad a q) -> a p q
arrowMonad :: ArrowApply a => a p q -> p -> ArrowMonad a q
reading :: (Monad m, Arrow a) => (forall p q. (p -> m q) -> a p q) -> (b -> ReaderT r m c) -> ReaderArrow r a b c
statefully :: (Monad m, Arrow a) => (forall p q. (p -> m q) -> a p q) -> (b -> StateT s m c) -> StateArrow s a b c
type AS e = (e, ())
toAS :: e -> AS e
fromAS :: AS e -> e

-- | Alternate for <a>elimReader</a> that can be used with both ghc 7.8 and
--   older.
elimR :: ArrowAddReader r a a' => a (AS e) b -> a' (e, AS r) b

module Control.Arrow.Machine.Types

-- | The stream transducer arrow.
--   
--   To construct <a>ProcessA</a> instances, use <a>Plan</a>, <a>arr</a>,
--   functions declared in <a>Utils</a>, or arrow combinations of them.
data ProcessA a b c

-- | Signals that can be absent(<a>NoEvent</a>) or end. For composite
--   structure, <a>collapse</a> can be defined as monoidal sum of all
--   member occasionals.
class Occasional' a
collapse :: Occasional' a => a -> Event ()

-- | Occasional signals with creation methods.
class Occasional' a => Occasional a
noEvent :: Occasional a => a
end :: Occasional a => a
data Event a
condEvent :: Bool -> Event a -> Event a
filterEvent :: (a -> Bool) -> Event a -> Event a

-- | Alias of "arr . fmap"
--   
--   While "ProcessA a (Event b) (Event c)" means a transducer from b to c,
--   function b-&gt;c can be lifted into a transducer by fhis function.
--   
--   But in most cases you needn't call this function in proc-do notations,
--   because <a>arr</a>s are completed automatically while desugaring.
--   
--   For example,
--   
--   <pre>
--   proc x -&gt; returnA -&lt; f &lt;$&gt; x
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   evMap f
--   </pre>
evMap :: Arrow a => (b -> c) -> a (Event b) (Event c)
type PlanT i o m a = FT (PlanF i o) m a
type Plan i o a = forall m. Monad m => PlanT i o m a
await :: Plan i o i
yield :: o -> Plan i o ()
stop :: Plan i o a
catchP :: Monad m => PlanT i o m a -> PlanT i o m a -> PlanT i o m a
stopped :: (ArrowApply a, Occasional c) => ProcessA a b c
muted :: (ArrowApply a, Occasional' b, Occasional c) => ProcessA a b c
constructT :: (Monad m, ArrowApply a) => (forall b. m b -> a () b) -> PlanT i o m r -> ProcessA a (Event i) (Event o)
repeatedlyT :: (Monad m, ArrowApply a) => (forall b. m b -> a () b) -> PlanT i o m r -> ProcessA a (Event i) (Event o)
construct :: ArrowApply a => Plan i o t -> ProcessA a (Event i) (Event o)
repeatedly :: ArrowApply a => Plan i o t -> ProcessA a (Event i) (Event o)

-- | Run a machine.
run :: ArrowApply a => ProcessA a (Event b) (Event c) -> a [b] [c]

-- | Run a machine with results concatenated in terms of a monoid.
runOn :: (ArrowApply a, Monoid r, Foldable f) => (c -> r) -> ProcessA a (Event b) (Event c) -> a (f b) r

-- | Run a machine discarding all results.
run_ :: ArrowApply a => ProcessA a (Event b) (Event c) -> a [b] ()

-- | Represents return values and informations of step executions.
data ExecInfo fa
ExecInfo :: fa -> Bool -> Bool -> ExecInfo fa
yields :: ExecInfo fa -> fa
hasConsumed :: ExecInfo fa -> Bool
hasStopped :: ExecInfo fa -> Bool

-- | Execute until an input consumed and the machine suspended.
stepRun :: ArrowApply a => ProcessA a (Event b) (Event c) -> a b (ExecInfo [c], ProcessA a (Event b) (Event c))

-- | Execute until an output produced.
stepYield :: ArrowApply a => ProcessA a (Event b) (Event c) -> a b (ExecInfo (Maybe c), ProcessA a (Event b) (Event c))
switch :: ArrowApply a => ProcessA a b (c, Event t) -> (t -> ProcessA a b c) -> ProcessA a b c
dSwitch :: ArrowApply a => ProcessA a b (c, Event t) -> (t -> ProcessA a b c) -> ProcessA a b c
rSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, Event (ProcessA a b c)) c
drSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, Event (ProcessA a b c)) c
kSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, c) (Event t) -> (ProcessA a b c -> t -> ProcessA a b c) -> ProcessA a b c
dkSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, c) (Event t) -> (ProcessA a b c -> t -> ProcessA a b c) -> ProcessA a b c
pSwitch :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a (b, col c) (Event mng) -> (col (ProcessA a ext c) -> mng -> ProcessA a b (col c)) -> ProcessA a b (col c)
pSwitchB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a (b, col c) (Event mng) -> (col (ProcessA a b c) -> mng -> ProcessA a b (col c)) -> ProcessA a b (col c)
rpSwitch :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a (b, Event (col (ProcessA a ext c) -> col (ProcessA a ext c))) (col c)
rpSwitchB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a (b, Event (col (ProcessA a b c) -> col (ProcessA a b c))) (col c)
par :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a b (col c)
parB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a b (col c)
fit :: (Arrow a, Arrow a') => (forall p q. a p q -> a' p q) -> ProcessA a b c -> ProcessA a' b c
loop' :: ArrowApply a => d -> ProcessA a (b, d) (c, d) -> ProcessA a b c
fitEx :: (Arrow a, Arrow a') => (forall p q. a (p, b) (q, c) -> a' (p, b') (q, c')) -> ProcessA a b c -> ProcessA a' b' c'

-- | Repeatedly call <tt>p</tt>.
--   
--   How many times <tt>p</tt> is called is indefinite. So <tt>p</tt> must
--   satisfy the equation below;
--   
--   <pre>
--   p &amp;&amp;&amp; p === p &gt;&gt;&gt; (id &amp;&amp;&amp; id)
--   </pre>
unsafeSteady :: ArrowApply a => a b c -> ProcessA a b c

-- | Repeatedly call <tt>p</tt>.
--   
--   How many times <tt>p</tt> is called is indefinite. So <tt>p</tt> must
--   satisfy the equation below;
--   
--   <pre>
--   p &amp;&amp;&amp; (p &gt;&gt;&gt; arr null) === p &amp;&amp;&amp; arr (const True)
--   </pre>
--   
--   where
--   
--   <pre>
--   null = getAll . foldMap (_ -&gt; All False)
--   </pre>
unsafeExhaust :: (ArrowApply a, Foldable f) => a b (f c) -> ProcessA a b (Event c)
instance Eq Phase
instance Show Phase
instance Eq a => Eq (Event a)
instance Show a => Show (Event a)
instance Eq fa => Eq (ExecInfo fa)
instance Show fa => Show (ExecInfo fa)
instance Alternative f => Monoid (ExecInfo (f a))
instance Monoid (Builder a)
instance Monoid r => Monoid (WithEnd r)
instance Functor (PlanF i o)
instance Occasional (Event a)
instance Occasional' (Event a)
instance (Occasional a, Occasional b) => Occasional (a, b)
instance (Occasional' a, Occasional' b) => Occasional' (a, b)
instance Semigroup a => Monoid (Event a)
instance Functor Event
instance (ArrowApply a, ArrowApply a', ArrowAddReader r a a') => ArrowAddReader r (ProcessA a) (ProcessA a')
instance (ArrowApply a, ArrowReader r a) => ArrowReader r (ProcessA a)
instance (ArrowApply a, ArrowLoop a) => ArrowLoop (ProcessA a)
instance ArrowApply a => ArrowChoice (ProcessA a)
instance ArrowApply a => Arrow (ProcessA a)
instance ArrowApply a => Category (ProcessA a)
instance ArrowApply a => Applicative (ProcessA a i)
instance Arrow a => Functor (ProcessA a i)
instance Arrow a => Profunctor (ProcessA a)
instance Monoid Phase

module Control.Arrow.Machine.Misc.Exception
catch :: Monad m => PlanT i o m a -> PlanT i o m a -> PlanT i o m a
handle :: Monad m => PlanT i o m a -> PlanT i o m a -> PlanT i o m a
bracket :: Monad m => PlanT i o m a -> (a -> PlanT i o m b) -> (a -> PlanT i o m c) -> PlanT i o m c
bracket_ :: Monad m => PlanT i o m a -> PlanT i o m b -> PlanT i o m c -> PlanT i o m c
bracketOnError :: Monad m => PlanT i o m a -> (a -> PlanT i o m b) -> (a -> PlanT i o m c) -> PlanT i o m c
finally :: Monad m => PlanT i o m a -> PlanT i o m b -> PlanT i o m a
onException :: Monad m => PlanT i o m a -> PlanT i o m b -> PlanT i o m a

module Control.Arrow.Machine.Utils
hold :: ArrowApply a => b -> ProcessA a (Event b) b
accum :: ArrowApply a => b -> ProcessA a (Event (b -> b)) b
edge :: (ArrowApply a, Eq b) => ProcessA a b (Event b)

-- | <i>Deprecated: Use <a>hold</a> instead</i>
passRecent :: (ArrowApply a, Occasional o) => ProcessA a (AS e) (Event b) -> ProcessA a (e, AS b) o -> ProcessA a (AS e) o

-- | <i>Deprecated: Use <a>hold</a> instead</i>
withRecent :: (ArrowApply a, Occasional o) => ProcessA a (e, AS b) o -> ProcessA a (e, AS (Event b)) o
switch :: ArrowApply a => ProcessA a b (c, Event t) -> (t -> ProcessA a b c) -> ProcessA a b c
dSwitch :: ArrowApply a => ProcessA a b (c, Event t) -> (t -> ProcessA a b c) -> ProcessA a b c
rSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, Event (ProcessA a b c)) c
drSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, Event (ProcessA a b c)) c
kSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, c) (Event t) -> (ProcessA a b c -> t -> ProcessA a b c) -> ProcessA a b c
dkSwitch :: ArrowApply a => ProcessA a b c -> ProcessA a (b, c) (Event t) -> (ProcessA a b c -> t -> ProcessA a b c) -> ProcessA a b c
pSwitch :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a (b, col c) (Event mng) -> (col (ProcessA a ext c) -> mng -> ProcessA a b (col c)) -> ProcessA a b (col c)
pSwitchB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a (b, col c) (Event mng) -> (col (ProcessA a b c) -> mng -> ProcessA a b (col c)) -> ProcessA a b (col c)
rpSwitch :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a (b, Event (col (ProcessA a ext c) -> col (ProcessA a ext c))) (col c)
rpSwitchB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a (b, Event (col (ProcessA a b c) -> col (ProcessA a b c))) (col c)
peekState :: (ArrowApply a, ArrowState s a) => ProcessA a e s
encloseState :: (ArrowApply a, ArrowApply a', ArrowAddState s a a') => ProcessA a b c -> s -> ProcessA a' b c

-- | Make two event streams into one. Actually <a>gather</a> is more
--   general and convenient;
--   
--   <pre>
--   ... &lt;- tee -&lt; (e1, e2)
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   ... &lt;- gather -&lt; [Left &lt;$&gt; e1, Right &lt;$&gt; e2]
--   </pre>
tee :: ArrowApply a => ProcessA a (Event b1, Event b2) (Event (Either b1 b2))

-- | Make multiple event channels into one. If simultaneous events are
--   given, lefter one is emitted earlier.
gather :: (ArrowApply a, Foldable f) => ProcessA a (f (Event b)) (Event b)
sample :: ArrowApply a => ProcessA a (Event b1, Event b2) [b1]

-- | Provides a source event stream. A dummy input event stream is needed.
--   
--   <pre>
--   run af [...]
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   run (source [...] &gt;&gt;&gt; af) (repeat ())
--   </pre>
source :: (ArrowApply a, Foldable f) => f c -> ProcessA a (Event b) (Event c)

-- | Given an array-valued event and emit it's values as inidvidual events.
fork :: (ArrowApply a, Foldable f) => ProcessA a (Event (f b)) (Event b)
filter :: ArrowApply a => a b Bool -> ProcessA a (Event b) (Event b)
echo :: ArrowApply a => ProcessA a (Event b) (Event b)

-- | Executes an action once per an input event is provided.
anytime :: ArrowApply a => a b c -> ProcessA a (Event b) (Event c)
par :: (ArrowApply a, Traversable col) => (forall sf. b -> col sf -> col (ext, sf)) -> col (ProcessA a ext c) -> ProcessA a b (col c)
parB :: (ArrowApply a, Traversable col) => col (ProcessA a b c) -> ProcessA a b (col c)
now :: ArrowApply a => ProcessA a b (Event ())
onEnd :: (ArrowApply a, Occasional' b) => ProcessA a b (Event ())

-- | Observe a previous value of a signal. Tipically used with rec
--   statement.
cycleDelay :: ArrowApply a => ProcessA a b b


module Control.Arrow.Machine

module Control.Arrow.Machine.Misc.Pump
data Duct a
intake :: ArrowApply a => ProcessA a (Event b, Event ()) (Duct b)
outlet :: ArrowApply a => ProcessA a (Duct b, Event ()) (Event b)

module Control.Arrow.Machine.Misc.Discrete
data T a
updates :: T a -> (Event ())
value :: T a -> a
arr :: ArrowApply a => (b -> c) -> ProcessA a (T b) (T c)
arr2 :: ArrowApply a => (b1 -> b2 -> c) -> ProcessA a (T b1, T b2) (T c)
arr3 :: ArrowApply a => (b1 -> b2 -> b3 -> c) -> ProcessA a (T b1, T b2, T b3) (T c)
arr4 :: ArrowApply a => (b1 -> b2 -> b3 -> b4 -> c) -> ProcessA a (T b1, T b2, T b3, T b4) (T c)
arr5 :: ArrowApply a => (b1 -> b2 -> b3 -> b4 -> b5 -> c) -> ProcessA a (T b1, T b2, T b3, T b4, T b5) (T c)
constant :: ArrowApply a => c -> ProcessA a b (T c)
hold :: ArrowApply a => b -> ProcessA a (Event b) (T b)
accum :: ArrowApply a => b -> ProcessA a (Event (b -> b)) (T b)
fromEq :: (ArrowApply a, Eq b) => ProcessA a b (T b)
edge :: ArrowApply a => ProcessA a (T b) (Event b)
asUpdater :: ArrowApply a => a b c -> ProcessA a (T b) (Event c)
data Alg a i o
instance ArrowApply a => Applicative (Alg a i)
instance ArrowApply a => Functor (Alg a i)
