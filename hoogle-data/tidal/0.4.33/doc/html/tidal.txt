-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pattern language for improvised music
--   
@package tidal
@version 0.4.33

module Sound.Tidal.Utils
enumerate :: [a] -> [(Int, a)]
mapFst :: (a -> b) -> (a, c) -> (b, c)
mapFsts :: (a -> b) -> [(a, c)] -> [(b, c)]
mapSnd :: (a -> b) -> (c, a) -> (c, b)
mapSnds :: (a -> b) -> [(c, a)] -> [(c, b)]
wordsBy :: (a -> Bool) -> [a] -> [[a]]
maybeRead :: String -> Maybe Double
fst' :: (t, t1, t2) -> t
snd' :: (t, t1, t2) -> t1
thd' :: (t, t1, t2) -> t2
mapFst' :: (a -> x) -> (a, b, c) -> (x, b, c)
mapSnd' :: (b -> x) -> (a, b, c) -> (a, x, c)
mapThd' :: (c -> x) -> (a, b, c) -> (a, b, x)
mapFsts' :: (a -> x) -> [(a, b, c)] -> [(x, b, c)]
mapSnds' :: (b -> x) -> [(a, b, c)] -> [(a, x, c)]
mapThds' :: (c -> x) -> [(a, b, c)] -> [(a, b, x)]
mapArcs :: (a -> a) -> [(a, a, x)] -> [(a, a, x)]
getEnvDefault :: String -> String -> IO String
mergelists :: [a] -> [a] -> [a]

module Sound.Tidal.Tempo
data Tempo
Tempo :: UTCTime -> Double -> Double -> Tempo
at :: Tempo -> UTCTime
beat :: Tempo -> Double
cps :: Tempo -> Double
type ClientState = [Connection]
getClockIp :: IO String
getServerPort :: IO Int
readTempo :: String -> Tempo
logicalTime :: Tempo -> Double -> Double
tempoMVar :: IO (MVar (Tempo))
beatNow :: Tempo -> IO (Double)
clientApp :: MVar Tempo -> MVar Double -> ClientApp ()
sendCps :: Connection -> MVar Double -> IO ()
connectClient :: Bool -> String -> MVar Tempo -> MVar Double -> IO ()
runClient :: IO ((MVar Tempo, MVar Double))
cpsUtils :: IO ((Double -> IO (), IO (Rational)))
bpsUtils :: IO ((Double -> IO (), IO (Rational)))
cpsSetter :: IO (Double -> IO ())
clocked :: (Tempo -> Int -> IO ()) -> IO ()
clockedTick :: Int -> (Tempo -> Int -> IO ()) -> IO ()
updateTempo :: MVar Tempo -> Maybe Double -> IO ()
addClient :: Connection -> ClientState -> ClientState
removeClient :: Connection -> ClientState -> ClientState
broadcast :: Text -> ClientState -> IO ()
startServer :: IO (ThreadId)
serverApp :: MVar Tempo -> MVar ClientState -> ServerApp
serverLoop :: Connection -> MVar Tempo -> MVar ClientState -> IO ()
instance Show Tempo
instance Eq Connection

module Sound.Tidal.Time

-- | Time is represented by a rational number. Each natural number
--   represents both the start of the next rhythmic cycle, and the end of
--   the previous one. Rational numbers are used so that subdivisions of
--   each cycle can be accurately represented.
type Time = Rational

-- | <tt>(s,e) :: Arc</tt> represents a time interval with a start and end
--   value. <tt> { t : s &lt;= t &amp;&amp; t &lt; e } </tt>
type Arc = (Time, Time)

-- | An Event is a value that occurs during the period given by the first
--   <tt>Arc</tt>. The second one indicates the event's "domain of
--   influence". These will often be the same, but many temporal
--   transformations, such as rotation and scaling time, may result in arcs
--   being split or truncated. In such cases, the first arc is preserved,
--   but the second arc reflects the portion of the event which is
--   relevant.
type Event a = (Arc, Arc, a)

-- | The starting point of the current cycle. A cycle occurs from each
--   natural number to the next, so this is equivalent to <tt>floor</tt>.
sam :: Time -> Time

-- | The end point of the current cycle (and starting point of the next
--   cycle)
nextSam :: Time -> Time

-- | The position of a time value relative to the start of its cycle.
cyclePos :: Time -> Time

-- | <tt>isIn a t</tt> is <tt>True</tt> iff <tt>t</tt> is inside the arc
--   represented by <tt>a</tt>.
isIn :: Arc -> Time -> Bool

-- | Splits the given <tt>Arc</tt> into a list of <tt>Arc</tt>s, at cycle
--   boundaries.
arcCycles :: Arc -> [Arc]

-- | Splits the given <tt>Arc</tt> into a list of <tt>Arc</tt>s, at cycle
--   boundaries, but wrapping the arcs within the same cycle.
arcCycles' :: Arc -> [Arc]

-- | <tt>subArc i j</tt> is the arc that is the intersection of <tt>i</tt>
--   and <tt>j</tt>.
subArc :: Arc -> Arc -> Maybe Arc

-- | Map the given function over both the start and end <tt>Time</tt>
--   values of the given <tt>Arc</tt>.
mapArc :: (Time -> Time) -> Arc -> Arc

-- | Similar to <tt>mapArc</tt> but time is relative to the cycle (i.e. the
--   sam of the start of the arc)
mapCycle :: (Time -> Time) -> Arc -> Arc

-- | Returns the `mirror image' of an <tt>Arc</tt>, used by
--   <tt>Sound.Tidal.Pattern.rev</tt>.
mirrorArc :: Arc -> Arc

-- | The start time of the given <tt>Event</tt>
eventStart :: Event a -> Time

-- | The original onset of the given <tt>Event</tt>
eventOnset :: Event a -> Time

-- | The original offset of the given <tt>Event</tt>
eventOffset :: Event a -> Time

-- | The arc of the given <tt>Event</tt>
eventArc :: Event a -> Arc

-- | The midpoint of an <tt>Arc</tt>
midPoint :: Arc -> Time
hasOnset :: Event a -> Bool
hasOffset :: Event a -> Bool
onsetIn :: Arc -> Event a -> Bool
offsetIn :: Arc -> Event a -> Bool

module Sound.Tidal.Pattern

-- | The pattern datatype, a function from a time <tt>Arc</tt> to
--   <tt>Event</tt> values. For discrete patterns, this returns the events
--   which are active during that time. For continuous patterns, events
--   with values for the midpoint of the given <tt>Arc</tt> is returned.
data Pattern a
Pattern :: (Arc -> [Event a]) -> Pattern a
arc :: Pattern a -> Arc -> [Event a]

-- | <tt>show (p :: Pattern)</tt> returns a text string representing the
--   event values active during the first cycle of the given pattern.
showTime :: (Show a, Integral a) => Ratio a -> String
showArc :: (Show a1, Show a, Integral a1, Integral a) => (Ratio a, Ratio a1) -> [Char]
showEvent :: (Show a2, Show a1, Show a, Integral a1, Integral a) => ((Ratio a, Ratio a1), (Ratio a, Ratio a1), a2) -> [Char]

-- | <tt>pure a</tt> returns a pattern with an event with value <tt>a</tt>,
--   which has a duration of one cycle, and repeats every cycle.

-- | <tt>mempty</tt> is a synonym for <tt>silence</tt>. | <tt>mappend</tt>
--   is a synonym for <tt>overlay</tt>.
unwrap :: Pattern (Pattern a) -> Pattern a

-- | <tt>atom</tt> is a synonym for <tt>pure</tt>.
atom :: a -> Pattern a

-- | <tt>silence</tt> returns a pattern with no events.
silence :: Pattern a

-- | <tt>withQueryArc f p</tt> returns a new <tt>Pattern</tt> with function
--   <tt>f</tt> applied to the <tt>Arc</tt> values passed to the original
--   <tt>Pattern</tt> <tt>p</tt>.
withQueryArc :: (Arc -> Arc) -> Pattern a -> Pattern a

-- | <tt>withQueryTime f p</tt> returns a new <tt>Pattern</tt> with
--   function <tt>f</tt> applied to the both the start and end
--   <tt>Time</tt> of the <tt>Arc</tt> passed to <tt>Pattern</tt>
--   <tt>p</tt>.
withQueryTime :: (Time -> Time) -> Pattern a -> Pattern a

-- | <tt>withResultArc f p</tt> returns a new <tt>Pattern</tt> with
--   function <tt>f</tt> applied to the <tt>Arc</tt> values in the events
--   returned from the original <tt>Pattern</tt> <tt>p</tt>.
withResultArc :: (Arc -> Arc) -> Pattern a -> Pattern a

-- | <tt>withResultTime f p</tt> returns a new <tt>Pattern</tt> with
--   function <tt>f</tt> applied to the both the start and end
--   <tt>Time</tt> of the <tt>Arc</tt> values in the events returned from
--   the original <tt>Pattern</tt> <tt>p</tt>.
withResultTime :: (Time -> Time) -> Pattern a -> Pattern a

-- | <tt>overlay</tt> combines two <tt>Pattern</tt>s into a new pattern, so
--   that their events are combined over time.
overlay :: Pattern a -> Pattern a -> Pattern a
(>+<) :: Pattern a -> Pattern a -> Pattern a

-- | <tt>stack</tt> combines a list of <tt>Pattern</tt>s into a new
--   pattern, so that their events are combined over time.
stack :: [Pattern a] -> Pattern a

-- | <tt>append</tt> combines two patterns <tt>Pattern</tt>s into a new
--   pattern, so that the events of the second pattern are appended to
--   those of the first pattern, within a single cycle
append :: Pattern a -> Pattern a -> Pattern a

-- | <tt>append'</tt> does the same as <tt>append</tt>, but over two
--   cycles, so that the cycles alternate between the two patterns.
append' :: Pattern a -> Pattern a -> Pattern a

-- | <tt>cat</tt> returns a new pattern which interlaces the cycles of the
--   given patterns, within a single cycle. It's the equivalent of
--   <tt>append</tt>, but with a list of patterns.
cat :: [Pattern a] -> Pattern a
splitAtSam :: Pattern a -> Pattern a

-- | <tt>slowcat</tt> does the same as <tt>cat</tt>, but maintaining the
--   duration of the original patterns. It is the equivalent of
--   <tt>append'</tt>, but with a list of patterns.
slowcat :: [Pattern a] -> Pattern a

-- | <tt>listToPat</tt> turns the given list of values to a Pattern, which
--   cycles through the list.
listToPat :: [a] -> Pattern a

-- | <tt>maybeListToPat</tt> is similar to <tt>listToPat</tt>, but allows
--   values to be optional using the <tt>Maybe</tt> type, so that
--   <tt>Nothing</tt> results in gaps in the pattern.
maybeListToPat :: [Maybe a] -> Pattern a

-- | <tt>run</tt> <tt>n</tt> returns a pattern representing a cycle of
--   numbers from <tt>0</tt> to <tt>n-1</tt>.
run :: (Num a, Enum a) => a -> Pattern a
scan :: (Num a, Enum a) => a -> Pattern a

-- | <tt>density</tt> returns the given pattern with density increased by
--   the given <tt>Time</tt> factor. Therefore <tt>density 2 p</tt> will
--   return a pattern that is twice as fast, and <tt>density (1%3) p</tt>
--   will return one three times as slow.
density :: Time -> Pattern a -> Pattern a

-- | <tt>densityGap</tt> is similar to <tt>density</tt> but maintains its
--   cyclic alignment. For example, <tt>densityGap 2 p</tt> would squash
--   the events in pattern <tt>p</tt> into the first half of each cycle
--   (and the second halves would be empty).
densityGap :: Time -> Pattern a -> Pattern a

-- | <tt>slow</tt> does the opposite of <tt>density</tt>, i.e. <tt>slow 2
--   p</tt> will return a pattern that is half the speed.
slow :: Time -> Pattern a -> Pattern a

-- | The <tt>&lt;~</tt> operator shifts (or rotates) a pattern to the left
--   (or counter-clockwise) by the given <tt>Time</tt> value. For example
--   <tt>(1%16) &lt;~ p</tt> will return a pattern with all the events
--   moved one 16th of a cycle to the left.
(<~) :: Time -> Pattern a -> Pattern a

-- | The <tt>~&gt;</tt> operator does the same as <tt>~&gt;</tt> but shifts
--   events to the right (or clockwise) rather than to the left.
(~>) :: Time -> Pattern a -> Pattern a
brak :: Pattern a -> Pattern a
iter :: Int -> Pattern a -> Pattern a

-- | <tt>rev p</tt> returns <tt>p</tt> with the event positions in each
--   cycle reversed (or mirrored).
rev :: Pattern a -> Pattern a

-- | <tt>palindrome p</tt> applies <tt>rev</tt> to <tt>p</tt> every other
--   cycle, so that the pattern alternates between forwards and backwards.
palindrome :: Pattern a -> Pattern a

-- | <tt>when test f p</tt> applies the function <tt>f</tt> to <tt>p</tt>,
--   but in a way which only affects cycles where the <tt>test</tt>
--   function applied to the cycle number returns <tt>True</tt>.
when :: (Int -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
whenT :: (Time -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
playWhen :: (Time -> Bool) -> Pattern a -> Pattern a
playFor :: Time -> Time -> Pattern a -> Pattern a
seqP :: [(Time, Time, Pattern a)] -> Pattern a

-- | <tt>every n f p</tt> applies the function <tt>f</tt> to <tt>p</tt>,
--   but only affects every <tt>n</tt> cycles.
every :: Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a

-- | <tt>foldEvery ns f p</tt> applies the function <tt>f</tt> to
--   <tt>p</tt>, and is applied for each cycle in <tt>ns</tt>.
foldEvery :: [Int] -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a

-- | <tt>sig f</tt> takes a function from time to values, and turns it into
--   a <tt>Pattern</tt>.
sig :: (Time -> a) -> Pattern a

-- | <tt>sinewave</tt> returns a <tt>Pattern</tt> of continuous
--   <tt>Double</tt> values following a sinewave with frequency of one
--   cycle, and amplitude from -1 to 1.
sinewave :: Pattern Double

-- | <tt>sine</tt> is a synonym for @sinewave.
sine :: Pattern Double

-- | <tt>sinerat</tt> is equivalent to <tt>sinewave</tt> for
--   <tt>Rational</tt> values, suitable for use as <tt>Time</tt> offsets.
sinerat :: Pattern Rational
ratsine :: Pattern Rational

-- | <tt>sinewave1</tt> is equivalent to <tt>sinewave</tt>, but with
--   amplitude from 0 to 1.
sinewave1 :: Pattern Double

-- | <tt>sine1</tt> is a synonym for <tt>sinewave1</tt>.
sine1 :: Pattern Double

-- | <tt>sinerat1</tt> is equivalent to <tt>sinerat</tt>, but with
--   amplitude from 0 to 1.
sinerat1 :: Pattern Rational

-- | <tt>sineAmp1 d</tt> returns <tt>sinewave1</tt> with its amplitude
--   offset by <tt>d</tt>.
sineAmp1 :: Double -> Pattern Double

-- | <tt>sawwave</tt> is the equivalent of <tt>sinewave</tt> for sawtooth
--   waves.
sawwave :: Pattern Double

-- | <tt>saw</tt> is a synonym for <tt>sawwave</tt>.
saw :: Pattern Double

-- | <tt>sawrat</tt> is the same as <tt>sawwave</tt> but returns
--   <tt>Rational</tt> values suitable for use as <tt>Time</tt> offsets.
sawrat :: Pattern Rational
sawwave1 :: Pattern Double
saw1 :: Pattern Double
sawrat1 :: Pattern Rational

-- | <tt>triwave</tt> is the equivalent of <tt>sinewave</tt> for triangular
--   waves.
triwave :: Pattern Double

-- | <tt>tri</tt> is a synonym for <tt>triwave</tt>.
tri :: Pattern Double

-- | <tt>trirat</tt> is the same as <tt>triwave</tt> but returns
--   <tt>Rational</tt> values suitable for use as <tt>Time</tt> offsets.
trirat :: Pattern Rational
triwave1 :: Pattern Double
tri1 :: Pattern Double
trirat1 :: Pattern Rational
squarewave1 :: Pattern Double
square1 :: Pattern Double
squarewave :: Pattern Double
square :: Pattern Double

-- | <tt>envL</tt> is a <tt>Pattern</tt> of continuous <tt>Double</tt>
--   values, representing a linear interpolation between 0 and 1 during the
--   first cycle, then staying constant at 1 for all following cycles.
--   Possibly only useful if you're using something like the retrig
--   function defined in tidal.el.
envL :: Pattern Double
fadeOut :: Time -> Pattern a -> Pattern a
fadeIn :: Time -> Pattern a -> Pattern a
spread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
slowspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
spread' :: (a -> Pattern b -> Pattern c) -> Pattern a -> Pattern b -> Pattern c
filterValues :: (a -> Bool) -> Pattern a -> Pattern a
filterOnsets :: Pattern a -> Pattern a
filterStartInRange :: Pattern a -> Pattern a
filterOnsetsInRange :: Pattern a -> Pattern a
seqToRelOnsets :: Arc -> Pattern a -> [(Double, a)]
segment :: Pattern a -> Pattern [a]
segment' :: [Event a] -> [Event a]
split :: Time -> [Event a] -> [Event a]
points :: [Event a] -> [Time]
groupByTime :: [Event a] -> [Event [a]]
ifp :: (Int -> Bool) -> (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
rand :: Pattern Double
irand :: Double -> Pattern Int
degradeBy :: Double -> Pattern a -> Pattern a
unDegradeBy :: Double -> Pattern a -> Pattern a
sometimesBy :: Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
sometimes :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
often :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
rarely :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
almostNever :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
almostAlways :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
degrade :: Pattern a -> Pattern a

-- | <tt>wedge t p p'</tt> combines patterns <tt>p</tt> and <tt>p'</tt> by
--   squashing the <tt>p</tt> into the portion of each cycle given by
--   <tt>t</tt>, and <tt>p'</tt> into the remainer of each cycle.
wedge :: Time -> Pattern a -> Pattern a -> Pattern a
whenmod :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
superimpose :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a

-- | <tt>splitQueries p</tt> wraps <tt>p</tt> to ensure that it does not
--   get queries that span arcs. For example `arc p (0.5, 1.5)` would be
--   turned into two queries, `(0.5,1)` and `(1,1.5)`, and the results
--   combined. Being able to assume queries don't span cycles often makes
--   transformations easier to specify.
splitQueries :: Pattern a -> Pattern a
trunc :: Time -> Pattern a -> Pattern a
zoom :: Arc -> Pattern a -> Pattern a
compress :: Arc -> Pattern a -> Pattern a
sliceArc :: Arc -> Pattern a -> Pattern a
within :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
revArc :: Arc -> Pattern a -> Pattern a
e :: Int -> Int -> Pattern a -> Pattern a
e' :: Int -> Int -> Pattern a -> Pattern a
index :: Real b => b -> Pattern b -> Pattern c -> Pattern c

-- | <tt>prr rot (blen, vlen) beatPattern valuePattern</tt>: pattern
--   rotate/replace.
prrw :: (a -> b -> c) -> Int -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c

-- | <tt>prr rot (blen, vlen) beatPattern valuePattern</tt>: pattern
--   rotate/replace.
prr :: Int -> (Time, Time) -> Pattern a -> Pattern a -> Pattern a

-- | <tt>preplace (blen, plen) beats values</tt> combines the timing of
--   <tt>beats</tt> with the values of <tt>values</tt>. Other ways of
--   saying this are: * sequential convolution * <tt>values</tt> quantized
--   to <tt>beats</tt>.
--   
--   Examples: <tt> d1 $ sound $ preplace (1,1) "x [~ x] x x" "bd sn" d1 $
--   sound $ preplace (1,1) "x(3,8)" "bd sn" d1 $ sound $ "x(3,8)" <a>~</a>
--   "bd sn" d1 $ sound "[jvbass jvbass:5]*3" |+| (shape $ "1 1 1 1 1"
--   <a>~</a> "0.2 0.9") </tt>
--   
--   It is assumed the pattern fits into a single cycle. This works well
--   with pattern literals, but not always with patterns defined elsewhere.
--   In those cases use <tt>prr</tt> and provide desired pattern lengths: @
--   let p = slow 2 $ "x x x"
--   
--   d1 $ sound $ prr 0 (2,1) p "bd sn" @
preplace :: (Time, Time) -> Pattern a -> Pattern a -> Pattern a
prep :: (Time, Time) -> Pattern a -> Pattern a -> Pattern a
preplace1 :: Pattern a -> Pattern a -> Pattern a
preplaceWith :: (a -> b -> c) -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c
prw :: (a -> b -> c) -> (Time, Time) -> Pattern a -> Pattern b -> Pattern c
preplaceWith1 :: (a -> b -> c) -> Pattern a -> Pattern b -> Pattern c
prw1 :: (a -> b -> c) -> Pattern a -> Pattern b -> Pattern c
(<~>) :: Pattern a -> Pattern a -> Pattern a

-- | <tt>protate len rot p</tt> rotates pattern <tt>p</tt> by <tt>rot</tt>
--   beats to the left. <tt>len</tt>: length of the pattern, in cycles.
--   Example: <tt>d1 $ every 4 (protate 2 (-1)) $ slow 2 $ sound "bd hh hh
--   hh"</tt>
protate :: Time -> Int -> Pattern a -> Pattern a
prot :: Time -> Int -> Pattern a -> Pattern a
prot1 :: Int -> Pattern a -> Pattern a

-- | The <tt>&lt;&lt;~</tt> operator rotates a unit pattern to the left,
--   similar to <tt>&lt;~</tt>, but by events rather than linear time. The
--   timing of the pattern remains constant:
--   
--   <pre>
--   d1 $ (1 &lt;&lt;~) $ sound "bd ~ sn hh"
--   -- will become
--   d1 $ sound "sn ~ hh bd"
--   </pre>
(<<~) :: Int -> Pattern a -> Pattern a
(~>>) :: Int -> Pattern a -> Pattern a

-- | <tt>pequal cycles p1 p2</tt>: quickly test if <tt>p1</tt> and
--   <tt>p2</tt> are the same.
pequal :: Ord a => Time -> Pattern a -> Pattern a -> Bool
instance Monad Pattern
instance Monoid (Pattern a)
instance Applicative Pattern
instance Functor Pattern
instance Show a => Show (Pattern a)

module Sound.Tidal.Parse
class Parseable a
p :: Parseable a => String -> Pattern a
type ColourD = Colour Double
lexer :: GenTokenParser String u Identity
braces :: ParsecT String u Identity a -> ParsecT String u Identity a
brackets :: ParsecT String u Identity a -> ParsecT String u Identity a
parens :: ParsecT String u Identity a -> ParsecT String u Identity a
angles :: ParsecT String u Identity a -> ParsecT String u Identity a
symbol :: String -> ParsecT String u Identity String
natural :: ParsecT String u Identity Integer
integer :: ParsecT String u Identity Integer
float :: ParsecT String u Identity Double
naturalOrFloat :: ParsecT String u Identity (Either Integer Double)
data Sign
Positive :: Sign
Negative :: Sign
applySign :: Num a => Sign -> a -> a
sign :: Parser Sign
intOrFloat :: Parser (Either Integer Double)
r :: Parseable a => String -> Pattern a -> IO (Pattern a)
parseRhythm :: Parser (Pattern a) -> String -> (Pattern a)
pSequenceN :: Parser (Pattern a) -> GenParser Char () (Int, Pattern a)
pSequence :: Parser (Pattern a) -> GenParser Char () (Pattern a)
pSingle :: Parser (Pattern a) -> Parser (Pattern a)
pPart :: Parser (Pattern a) -> Parser ([Pattern a])
pPolyIn :: Parser (Pattern a) -> Parser (Pattern a)
pPolyOut :: Parser (Pattern a) -> Parser (Pattern a)
pString :: Parser (String)
pVocable :: Parser (Pattern String)
pDouble :: Parser (Pattern Double)
pBool :: Parser (Pattern Bool)
pInt :: Parser (Pattern Int)
pColour :: Parser (Pattern ColourD)
pMult :: Pattern a -> Parser (Pattern a)
pRand :: Pattern a -> Parser (Pattern a)
pE :: Pattern a -> Parser (Pattern a)
pReplicate :: Pattern a -> Parser ([Pattern a])
pRatio :: Parser (Rational)
pRational :: Parser (Pattern Rational)
pDensity :: Parser (Rational)
instance [incoherent] Parseable a => IsString (Pattern a)
instance [incoherent] Parseable ColourD
instance [incoherent] Parseable Rational
instance [incoherent] Parseable Int
instance [incoherent] Parseable Bool
instance [incoherent] Parseable String
instance [incoherent] Parseable Double

module Sound.Tidal.Stream
data Param
S :: String -> Maybe String -> Param
name :: Param -> String
sDefault :: Param -> Maybe String
F :: String -> Maybe Double -> Param
name :: Param -> String
fDefault :: Param -> Maybe Double
I :: String -> Maybe Int -> Param
name :: Param -> String
iDefault :: Param -> Maybe Int
data TimeStamp
BundleStamp :: TimeStamp
MessageStamp :: TimeStamp
NoStamp :: TimeStamp
data OscShape
OscShape :: String -> [Param] -> Bool -> TimeStamp -> Double -> Bool -> [Datum] -> OscShape
path :: OscShape -> String
params :: OscShape -> [Param]
cpsStamp :: OscShape -> Bool
timestamp :: OscShape -> TimeStamp
latency :: OscShape -> Double
namedParams :: OscShape -> Bool
preamble :: OscShape -> [Datum]
type OscMap = Map Param (Maybe Datum)
type OscPattern = Pattern OscMap
ticksPerCycle :: Num a => a
defaultDatum :: Param -> Maybe Datum
hasDefault :: Param -> Bool
defaulted :: OscShape -> [Param]
defaultMap :: OscShape -> OscMap
required :: OscShape -> [Param]
hasRequired :: OscShape -> OscMap -> Bool
isSubset :: Eq a => [a] -> [a] -> Bool
toMessage :: UDP -> OscShape -> Tempo -> Int -> (Double, OscMap) -> Maybe (IO ())
doAt :: RealFrac s => s -> IO () -> IO ()
applyShape' :: OscShape -> OscMap -> Maybe OscMap
start :: String -> Int -> OscShape -> IO (MVar (OscPattern))
stream :: String -> Int -> OscShape -> IO (OscPattern -> IO ())
streamcallback :: (OscPattern -> IO ()) -> String -> Int -> OscShape -> IO (OscPattern -> IO ())
onTick :: UDP -> OscShape -> MVar (OscPattern) -> Tempo -> Int -> IO ()
make :: (a -> Datum) -> OscShape -> String -> Pattern a -> OscPattern
nudge :: Pattern Double -> OscPattern
makeS :: OscShape -> String -> Pattern String -> OscPattern
makeF :: OscShape -> String -> Pattern Double -> OscPattern
makeI :: OscShape -> String -> Pattern Int -> OscPattern
param :: OscShape -> String -> Param
merge :: OscPattern -> OscPattern -> OscPattern
(|+|) :: OscPattern -> OscPattern -> OscPattern
instance Eq TimeStamp
instance Show Param
instance Ord Param
instance Eq Param

module Sound.Tidal.SuperCollider
supercollider :: String -> [Param] -> Double -> OscShape
scStream :: String -> [Param] -> Double -> IO (OscPattern -> IO (), OscShape)

module Sound.Tidal.Dirt
dirt :: OscShape
kriole :: OscShape
dirtstart :: t -> IO (MVar OscPattern)
dirtStream :: IO (OscPattern -> IO ())
dirtstream :: t -> IO (OscPattern -> IO ())
kstream :: t -> IO (OscPattern -> IO ())
doubledirt :: IO (OscPattern -> IO ())
dirtToColour :: OscPattern -> Pattern ColourD
showToColour :: Show a => a -> ColourD
datumToColour :: Datum -> ColourD
stringToColour :: String -> ColourD
sound :: Pattern String -> OscPattern
offset :: Pattern Double -> OscPattern
begin :: Pattern Double -> OscPattern
end :: Pattern Double -> OscPattern
speed :: Pattern Double -> OscPattern
pan :: Pattern Double -> OscPattern
velocity :: Pattern Double -> OscPattern
vowel :: Pattern String -> OscPattern
cutoff :: Pattern Double -> OscPattern
resonance :: Pattern Double -> OscPattern
accelerate :: Pattern Double -> OscPattern
shape :: Pattern Double -> OscPattern
gain :: Pattern Double -> OscPattern
delay :: Pattern Double -> OscPattern
delaytime :: Pattern Double -> OscPattern
delayfeedback :: Pattern Double -> OscPattern
crush :: Pattern Double -> OscPattern
coarse :: Pattern Int -> OscPattern
hcutoff :: Pattern Double -> OscPattern
hresonance :: Pattern Double -> OscPattern
bandf :: Pattern Double -> OscPattern
bandq :: Pattern Double -> OscPattern
unit :: Pattern String -> OscPattern
loop :: Pattern Int -> OscPattern
cut :: Pattern Int -> OscPattern
ksymbol :: Pattern Double -> OscPattern
kpitch :: Pattern Double -> OscPattern
pick :: String -> Int -> String
striate :: Int -> OscPattern -> OscPattern
striate' :: Int -> Double -> OscPattern -> OscPattern
striateO :: OscPattern -> Int -> Double -> OscPattern
striateL :: Int -> Int -> OscPattern -> OscPattern
striateL' :: Integral a => Int -> Double -> a -> OscPattern -> OscPattern
metronome :: Pattern OscMap

module Sound.Tidal.Strategies
stutter :: Integral a1 => a1 -> Time -> Pattern a -> Pattern a
echo :: Time -> Pattern a -> Pattern a
triple :: Time -> Pattern a -> Pattern a
quad :: Time -> Pattern a -> Pattern a
double :: Time -> Pattern a -> Pattern a
jux :: (OscPattern -> Pattern OscMap) -> OscPattern -> Pattern OscMap
juxcut :: (OscPattern -> Pattern OscMap) -> OscPattern -> Pattern OscMap
jux4 :: (OscPattern -> Pattern OscMap) -> OscPattern -> Pattern OscMap
juxBy :: Double -> (OscPattern -> Pattern OscMap) -> OscPattern -> Pattern OscMap
smash :: Int -> [Time] -> OscPattern -> Pattern OscMap
smash' :: Int -> [Time] -> OscPattern -> Pattern OscMap
samples :: Applicative f => f String -> f Int -> f String
spreadf :: t -> t1 -> [t2 -> Pattern b] -> t2 -> Pattern b
spin :: Int -> OscPattern -> OscPattern
sawwave4 :: Pattern Double
sinewave4 :: Pattern Double
rand4 :: Pattern Double
stackwith :: Pattern OscMap -> [OscPattern] -> Pattern OscMap
inside :: Time -> (Pattern a1 -> Pattern a) -> Pattern a1 -> Pattern a
stut :: Integer -> Double -> Rational -> OscPattern -> OscPattern
scale :: (Functor f, Num b) => b -> b -> f b -> f b
chop :: Int -> OscPattern -> OscPattern
gap :: Int -> OscPattern -> OscPattern
chopArc :: Arc -> Int -> [Arc]
en :: [(Int, Int)] -> Pattern String -> Pattern String
weave :: Rational -> OscPattern -> [OscPattern] -> OscPattern
weave' :: Rational -> OscPattern -> [OscPattern -> OscPattern] -> OscPattern
interlace :: OscPattern -> OscPattern -> OscPattern

module Sound.Tidal.Context
