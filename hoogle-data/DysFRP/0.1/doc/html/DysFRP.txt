-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | dysFunctional Reactive Programming
--   
--   Simple imperative implementation of FRP.
@package DysFRP
@version 0.1

module Control.DysFRP.Internal

-- | Discrete events.
data Event a

-- | Continuous time functions.
data Behavior a

-- | Time functions with an additional time parameter, corresponding to a
--   starting point.
type BehaviorGen a = Behavior (Behavior a)

-- | Gets the current value of the <a>Behavior</a>.
runBehavior :: Behavior b -> IO b

-- | Creates a new <a>Event</a>. Calling the returned action fires the
--   event.
mkE :: IO (a -> IO (), Event a)
liftBG :: Behavior a -> BehaviorGen a
bindBG :: (Behavior a -> BehaviorGen b) -> BehaviorGen a -> BehaviorGen b

-- | A behavior which gives the current time.
utcTimeB :: Behavior UTCTime

-- | A <a>BehaviorGen</a> which gives the time from the starting point, in
--   seconds.
elapsedTimeB :: BehaviorGen NominalDiffTime

-- | A <a>BehaviorGen</a> which gives the time from the starting point, in
--   seconds.
elapsedTimeNumB :: Fractional a => BehaviorGen a

-- | A <a>BehaviorGen</a> which mirrors the given <a>Behavior</a> from the
--   starting point, and switches to the new behaviors (parametrized by the
--   last value before the switch) given by the <a>Event</a>.
dswitchB :: Behavior a -> Event (a -> Behavior a) -> BehaviorGen a

-- | A specialization of <a>dswitchB</a>.
switchB :: Behavior a -> Event (Behavior a) -> BehaviorGen a

-- | A constant <a>Behavior</a>.
constB :: a -> Behavior a
stepB :: a -> Event a -> BehaviorGen a
accumB :: a -> Event (a -> a) -> BehaviorGen a
ifB :: Behavior Bool -> Behavior a -> Behavior a -> Behavior a
genIntegralB :: (Num t, Num a, Num b) => ((t, a) -> (t, a) -> b -> b) -> Event x -> Behavior t -> b -> Behavior a -> BehaviorGen b
trapIntegralB :: (Eq a, Fractional a) => Event x -> Behavior a -> a -> Behavior a -> BehaviorGen a
nullE :: Event a
appendE :: Event a -> Event a -> Event a
concatE :: [Event a] -> Event a
snapshotE :: Behavior a -> Event b -> Event a
snapshotWithE :: (b -> a -> c) -> Behavior a -> Event b -> Event c
filterE :: (a -> Bool) -> Event a -> Event a
whenE :: Behavior Bool -> Event a -> Event a
filterWhenE :: Behavior (a -> Bool) -> Event a -> Event a
whenCondE :: Behavior a -> (a -> Bool) -> Event b -> Event a
constE :: a -> Event b -> Event a
feedbackB :: a -> Behavior a -> BehaviorGen a
genToE :: (a -> BehaviorGen b) -> Event a -> Event (Behavior b)
joinE :: Event (Event a) -> Behavior (Event a)
condChangeE :: Eq a => (a -> a -> Bool) -> a -> Behavior a -> Event b -> Behavior (Event a)
changeE :: Eq a => a -> Behavior a -> Event b -> Behavior (Event a)
data Handler a
mkH :: k -> (a -> ReactM ()) -> IO (Handler a)
mksH :: (a -> ReactM ()) -> IO (Handler a)
contramapH :: (a -> ReactM b) -> Handler b -> Handler a
mkBG :: ReactM (ReactM a) -> BehaviorGen a
addHandler :: Event a -> Handler a -> IO ()
runHandler :: Handler a -> IO (Maybe (a -> ReactM ()))
ioMapE :: (a -> IO b) -> Event a -> Event b
reactMapE :: (a -> ReactM b) -> Event a -> Event b
alterE :: (Handler a -> Handler b) -> Event b -> Event a
data ReactM a
newReactRef :: a -> ReactM (ReactRef a)
readReactRef :: ReactRef a -> ReactM a
writeReactRef :: ReactRef a -> a -> ReactM ()
updateReactRef :: ReactRef a -> ReactM a -> ReactM ()
instance Functor ReactM
instance Monad ReactM
instance MonadIO ReactM
instance MonadFix ReactM
instance Applicative ReactM
instance Floating a => Floating (Behavior a)
instance Fractional a => Fractional (Behavior a)
instance Num a => Num (Behavior a)
instance Monoid a => Monoid (Behavior a)
instance Monoid (Event a)
instance MonadFix Behavior
instance Monad Behavior
instance Applicative Behavior
instance Functor Behavior
instance Functor Event
instance Contravariant Handler

module Control.DysFRP

-- | Discrete events.
data Event a

-- | Continuous time functions.
data Behavior a

-- | Time functions with an additional time parameter, corresponding to a
--   starting point.
type BehaviorGen a = Behavior (Behavior a)

-- | Gets the current value of the <a>Behavior</a>.
runBehavior :: Behavior b -> IO b

-- | Creates a new <a>Event</a>. Calling the returned action fires the
--   event.
mkE :: IO (a -> IO (), Event a)
liftBG :: Behavior a -> BehaviorGen a
bindBG :: (Behavior a -> BehaviorGen b) -> BehaviorGen a -> BehaviorGen b

-- | A behavior which gives the current time.
utcTimeB :: Behavior UTCTime

-- | A <a>BehaviorGen</a> which gives the time from the starting point, in
--   seconds.
elapsedTimeB :: BehaviorGen NominalDiffTime

-- | A <a>BehaviorGen</a> which gives the time from the starting point, in
--   seconds.
elapsedTimeNumB :: Fractional a => BehaviorGen a

-- | A <a>BehaviorGen</a> which mirrors the given <a>Behavior</a> from the
--   starting point, and switches to the new behaviors (parametrized by the
--   last value before the switch) given by the <a>Event</a>.
dswitchB :: Behavior a -> Event (a -> Behavior a) -> BehaviorGen a

-- | A specialization of <a>dswitchB</a>.
switchB :: Behavior a -> Event (Behavior a) -> BehaviorGen a

-- | A constant <a>Behavior</a>.
constB :: a -> Behavior a
stepB :: a -> Event a -> BehaviorGen a
accumB :: a -> Event (a -> a) -> BehaviorGen a
ifB :: Behavior Bool -> Behavior a -> Behavior a -> Behavior a
genIntegralB :: (Num t, Num a, Num b) => ((t, a) -> (t, a) -> b -> b) -> Event x -> Behavior t -> b -> Behavior a -> BehaviorGen b
trapIntegralB :: (Eq a, Fractional a) => Event x -> Behavior a -> a -> Behavior a -> BehaviorGen a
nullE :: Event a
appendE :: Event a -> Event a -> Event a
concatE :: [Event a] -> Event a
snapshotE :: Behavior a -> Event b -> Event a
snapshotWithE :: (b -> a -> c) -> Behavior a -> Event b -> Event c
filterE :: (a -> Bool) -> Event a -> Event a
whenE :: Behavior Bool -> Event a -> Event a
filterWhenE :: Behavior (a -> Bool) -> Event a -> Event a
whenCondE :: Behavior a -> (a -> Bool) -> Event b -> Event a
constE :: a -> Event b -> Event a
feedbackB :: a -> Behavior a -> BehaviorGen a
genToE :: (a -> BehaviorGen b) -> Event a -> Event (Behavior b)
joinE :: Event (Event a) -> Behavior (Event a)
condChangeE :: Eq a => (a -> a -> Bool) -> a -> Behavior a -> Event b -> Behavior (Event a)
changeE :: Eq a => a -> Behavior a -> Event b -> Behavior (Event a)
