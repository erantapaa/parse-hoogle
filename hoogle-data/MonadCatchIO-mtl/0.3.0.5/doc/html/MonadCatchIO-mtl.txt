-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad-transformer version of the Control.Exception module
--   
--   Provides a monad-transformer version of the
--   <tt>Control.Exception.catch</tt> function. For this, it defines the
--   <tt>MonadCatchIO</tt> class, a subset of <tt>MonadIO</tt>. It defines
--   proper instances for most monad transformers in the <a>mtl</a>
--   library.
@package MonadCatchIO-mtl
@version 0.3.0.5

module Control.Monad.CatchIO
class MonadIO m => MonadCatchIO m
catch :: (MonadCatchIO m, Exception e) => m a -> (e -> m a) -> m a
block :: MonadCatchIO m => m a -> m a
unblock :: MonadCatchIO m => m a -> m a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Generalized version of <a>throwIO</a>
throw :: (MonadIO m, Exception e) => e -> m a

-- | Generalized version of <a>try</a>
try :: (MonadCatchIO m, Exception e) => m a -> m (Either e a)

-- | Generalized version of <a>tryJust</a>
tryJust :: (MonadCatchIO m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Generalized version of <a>onException</a>
onException :: MonadCatchIO m => m a -> m b -> m a

-- | Generalized version of <a>bracket</a>
bracket :: MonadCatchIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: MonadCatchIO m => m a -> m b -> m c -> m c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: MonadCatchIO m => m a -> m b -> m a

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: MonadCatchIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalized version of <a>Handler</a>
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Generalized version of <a>catches</a>
catches :: MonadCatchIO m => m a -> [Handler m a] -> m a
instance (Monoid w, MonadCatchIO m) => MonadCatchIO (RWST r w s m)
instance (Monoid w, MonadCatchIO m) => MonadCatchIO (WriterT w m)
instance (MonadCatchIO m, Error e) => MonadCatchIO (ErrorT e m)
instance MonadCatchIO m => MonadCatchIO (StateT s m)
instance MonadCatchIO m => MonadCatchIO (ReaderT r m)
instance MonadCatchIO IO
