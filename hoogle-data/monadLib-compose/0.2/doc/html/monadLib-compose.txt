-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Arrow-like monad composition for monadLib.
--   
--   Arrow-like monad composition for monadLib.
@package monadLib-compose
@version 0.2


-- | This module provides Arrow-like monad composition for monadLib. To be
--   more precise, it is <a>Category-like</a>, i.e. the parallels are to
--   <tt>Control.Category.Category</tt>.
--   
--   <tt>Control.Category.Category</tt> generalises <a>.</a> and <a>id</a>
--   to arrows and categories. One such arrow is <tt>Kleisli</tt>, which
--   represents functions returning monadic values. Incidentally, that's
--   equivalent to <a>ReaderT</a>! So it turns out that it is possible to
--   generalise <a>.</a> and <a>id</a> to <a>ReaderT</a> (<a>id</a> is just
--   <a>ask</a>), as well as to many monad transformer stacks that embed a
--   <a>ReaderT</a> inside.
--   
--   The motivation to create this module was a nagging feeling when
--   reading the documentation for <tt>hxt</tt> and <tt>HaXml</tt>:
--   composing filters is very nice, but the abundance of constant arrows,
--   and the lack of access to the very extensive set of monad combinators,
--   leads to duplicated effort and unwieldy code (in my humble opinion). I
--   think it is possible to gain similar functionality with a stack of
--   monad transformers including <a>ReaderT</a>, and <a>ComposeM</a>,
--   presented here.
module MonadLib.Compose

-- | Alias for <a>ask</a>. Compare with <tt>Control.Category.id</tt>.
mid :: ReaderM m s => m s

-- | Composable monads. Compare with <tt>Control.Category.Category</tt>.
--   Note that there are two different monad types involved in each
--   instance.
class (Monad m, Monad n) => ComposeM m n s t | m -> s, n -> t, n s -> m
mcompose :: ComposeM m n s t => m a -> n s -> n a
mapply :: ComposeM m n s t => m a -> s -> n a

-- | Compose two monadic values from right to left. Compare with
--   <tt>Control.Category.&lt;&lt;&lt;</tt>. <tt>f &lt;&lt;&lt; g</tt> is
--   equivalent to <tt>mcompose f g</tt>.
(<<<) :: ComposeM m n s t => m a -> n s -> n a

-- | Compose two monadic values from left to right. Compare with
--   <tt>Control.Category.&gt;&gt;&gt;</tt>. <tt>g &gt;&gt;&gt; f</tt> is
--   equivalent to <tt>mcompose f g</tt>.
(>>>) :: ComposeM m n s t => n s -> m a -> n a
derive_mcompose :: ComposeM m n s t => Iso m o -> Iso n p -> o a -> p s -> p a
derive_mapply :: ComposeM m n s t => Iso m o -> Iso n p -> o a -> s -> p a
instance ComposeM m n s t => ComposeM (ChoiceT m) (ChoiceT n) s t
instance ComposeM m n s t => ComposeM (StateT i m) (StateT i n) s t
instance ComposeM m n s t => ComposeM (ExceptionT e m) (ExceptionT e n) s t
instance (ComposeM m n s t, Monoid w) => ComposeM (WriterT w m) (WriterT w n) s t
instance ComposeM m n s t => ComposeM (IdT m) (IdT n) s t
instance ComposeM (Reader s) (Reader t) s t
instance Monad m => ComposeM (ReaderT s m) (ReaderT t m) s t
instance ComposeM ((->) s) ((->) t) s t
