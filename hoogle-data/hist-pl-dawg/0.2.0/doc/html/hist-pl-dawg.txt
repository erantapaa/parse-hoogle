-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A generic, DAWG-based dictionary
--   
--   A generic dictionary implementation based on directed acyclic word
--   graphs.
@package hist-pl-dawg
@version 0.2.0


-- | A <a>DAWG</a>-based dictionary with additional information assigned to
--   lexical entries and word forms.
module NLP.HistPL.DAWG

-- | A rule for translating a form into another form.
data Rule
Rule :: !Int -> !Text -> Rule

-- | Number of characters to cut from the end of the form.
cut :: Rule -> !Int

-- | A suffix to paste.
suffix :: Rule -> !Text

-- | Apply the rule.
apply :: Rule -> Text -> Text

-- | Determine a rule which translates between two strings.
between :: Text -> Text -> Rule

-- | A dictionary entry consists of a <a>Key</a> and a <a>Val</a>ue.
data Lex i a b
Lex :: Key i -> Val a Text b -> Lex i a b

-- | Entry key.
lexKey :: Lex i a b -> Key i

-- | Entry value.
lexVal :: Lex i a b -> Val a Text b

-- | A key of a dictionary entry.
data Key i
Key :: Text -> i -> Key i

-- | A path of the entry, i.e. DAWG key.
path :: Key i -> Text

-- | Unique identifier among entries with the same <a>path</a>.
uid :: Key i -> i

-- | A value of the entry.
data Val a w b
Val :: a -> Map w b -> Val a w b

-- | Additional information assigned to the entry.
info :: Val a w b -> a

-- | A map of forms with additional info of type <tt>b</tt> assigned.
--   Invariant: in case of a reverse dictionary (from word forms to base
--   forms) this map should contain exactly one element (a base form and a
--   corresonding information).
forms :: Val a w b -> Map w b

-- | A set of dictionary entries.
type LexSet i a b = Map (Key i) (Val a Text b)

-- | Make lexical set from a list of entries.
mkLexSet :: Ord i => [Lex i a b] -> LexSet i a b

-- | List lexical entries.
unLexSet :: LexSet i a b -> [Lex i a b]

-- | Actual values stored in automaton states contain all entry information
--   but <a>path</a>.
type Node i a b = Map i (Val a Rule b)

-- | Decode dictionary value given <a>path</a>.
decode :: Ord i => Text -> Node i a b -> LexSet i a b

-- | A dictionary parametrized over ID <tt>i</tt>, with info <tt>a</tt> for
--   every (key, i) pair and info <tt>b</tt> for every (key, i, apply rule
--   key) triple.
type DAWG i a b = DAWG Char Weight (Node i a b)

-- | A <a>DAWG</a> initialization structure (a dynamic DAWG).
type DAWG'Init i a b = DAWG Char (Node i a b)

-- | Empty DAWG.
empty :: Ord b => DAWG a b

-- | Insert a (key, ID, entry info, form, entry/form info) into a
--   <a>DAWG'Init</a> structure.
insert :: (Ord i, Ord a, Ord b) => (Text, i, a, Text, b) -> DAWG'Init i a b -> DAWG'Init i a b

-- | Construct immutable version of the automaton.
freeze :: DAWG a b -> DAWG a () b

-- | Lookup the key in the dictionary.
lookup :: Ord i => Text -> DAWG i a b -> LexSet i a b

-- | Return the sub-dictionary containing all keys beginning with a prefix.
submap :: Ord i => Text -> DAWG i a b -> DAWG i a b

-- | Weight of a node corresponds to the number of final states reachable
--   from the node. Weight of an edge is a sum of weights of preceding
--   nodes outgoing from the same parent node.
type Weight = Int

-- | Compute node weights and store corresponding values in transition
--   labels. Be aware, that the entire DAWG will be weighted, even when
--   (because of the use of the <a>submap</a> function) only a part of the
--   DAWG is currently selected.
weigh :: DAWG a b c -> DAWG a Weight c

-- | A number of distinct (key, value) pairs in the weighted DAWG.
size :: DAWG a Weight c -> Int

-- | Position in a set of all dictionary entries with respect to the
--   lexicographic order.
index :: Text -> DAWG i a b -> Maybe Int

-- | Find dictionary entry given its index with respect to the
--   lexicographic order.
byIndex :: Int -> DAWG i a b -> Maybe Text

-- | Make dictionary from a list of (key, ID, entry info, form, entry/form
--   info) tuples.
fromList :: (Ord i, Ord a, Ord b) => [(Text, i, a, Text, b)] -> DAWG i a b

-- | Transform dictionary back into the list of (key, ID, key/ID info,
--   elem, key/ID/elem info) tuples.
toList :: (Ord i, Ord a, Ord b) => DAWG i a b -> [(Text, i, a, Text, b)]

-- | List dictionary lexical entries.
entries :: Ord i => DAWG i a b -> [Lex i a b]

-- | Reverse the dictionary.
revDAWG :: (Ord i, Ord a, Ord b) => DAWG i a b -> DAWG i a b
instance Show Rule
instance Eq Rule
instance Ord Rule
instance Show i => Show (Key i)
instance Eq i => Eq (Key i)
instance Ord i => Ord (Key i)
instance (Show a, Show w, Show b) => Show (Val a w b)
instance (Eq a, Eq w, Eq b) => Eq (Val a w b)
instance (Ord a, Ord w, Ord b) => Ord (Val a w b)
instance (Show i, Show a, Show b) => Show (Lex i a b)
instance (Eq i, Eq a, Eq b) => Eq (Lex i a b)
instance (Ord i, Ord a, Ord b) => Ord (Lex i a b)
instance (Ord w, Binary a, Binary w, Binary b) => Binary (Val a w b)
instance Binary Rule
