-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Ferry Core Components
--   
--   The Ferry 2.0 Core This package contains the core components of the
--   Ferry compiler [1]. It lacks a parser for the ferry language and the
--   normalisation ferry front, and the conversion of ferry front language
--   to the ferry core language.
--   
--   It exposes the compiler parts that transform (un)typed ferry core into
--   table algebra [2]. When provided an untyped ferrycore AST this ast
--   must have the shape of a normalised ferry program. When a typed ast is
--   used as input it is required to be typed correctly as well. The ferry
--   compiler uses this package providing it untyped ferrycore. DSH [3]
--   uses this package providing a typed AST.
--   
--   <ol>
--   
--   <li><a>http://www-db.informatik.uni-tuebingen.de/research/ferry</a></li>
--   
--   <li><a>http://dbworld.informatik.uni-tuebingen.de/projects/pathfinder/wiki/Logical_Algebra</a></li>
--   
--   <li><a>http://www-db.informatik.uni-tuebingen.de/files/publications/ferryhaskell.pdf</a></li>
--   </ol>
@package FerryCore
@version 0.4.6.4


-- | Everything related to typed core
module Database.Ferry.SyntaxTyped
type Ident = String

-- | Identifiers are represented as strings
type Identifier = String

-- | Constant values
data Const
CInt :: Integer -> Const
CFloat :: Double -> Const
CBool :: Bool -> Const
CString :: String -> Const
CUnit :: Const
data Op
Op :: String -> Op
data CoreExpr
BinOp :: (Qual FType) -> Op -> CoreExpr -> CoreExpr -> CoreExpr
Constant :: (Qual FType) -> Const -> CoreExpr
Var :: (Qual FType) -> String -> CoreExpr
App :: (Qual FType) -> CoreExpr -> Param -> CoreExpr
Let :: (Qual FType) -> String -> CoreExpr -> CoreExpr -> CoreExpr
Rec :: (Qual FType) -> [RecElem] -> CoreExpr
Cons :: (Qual FType) -> CoreExpr -> CoreExpr -> CoreExpr
Nil :: (Qual FType) -> CoreExpr
Elem :: (Qual FType) -> CoreExpr -> String -> CoreExpr
Table :: (Qual FType) -> String -> [Column] -> [Key] -> CoreExpr
If :: (Qual FType) -> CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr
data RecElem
RecElem :: (Qual FType) -> String -> CoreExpr -> RecElem
data Param
ParExpr :: (Qual FType) -> CoreExpr -> Param
ParAbstr :: (Qual FType) -> [String] -> CoreExpr -> Param
data Column
Column :: String -> FType -> Column
data Key
Key :: [String] -> Key
int :: FType
float :: FType
string :: FType
bool :: FType
list :: FType -> FType
var :: Ident -> FType
rec :: [(RLabel, FType)] -> FType
fn :: FType -> FType -> FType
genT :: Int -> FType
(.->) :: FType -> FType -> FType

-- | A type scheme represents a quantified type
data TyScheme
Forall :: TyGens -> RecGens -> Qual FType -> TyScheme

-- | A qualified type is a type with some predicates ([predicates] :=&gt;
--   type)
data Qual t
(:=>) :: [Pred] -> t -> Qual t

-- | Predicates relating to records
data Pred

-- | name <a>IsIn</a> t -&gt; t is a record (or type variable) that
--   contains at least a field name
IsIn :: String -> FType -> Pred

-- | Similaar to IsIn but now with a type for the name
Has :: FType -> RLabel -> FType -> Pred

-- | Type language
data FType
FGen :: Int -> FType
FUnit :: FType
FInt :: FType
FFloat :: FType
FString :: FType
FBool :: FType
FList :: FType -> FType
FVar :: Ident -> FType
FRec :: [(RLabel, FType)] -> FType
FFn :: FType -> FType -> FType
FTF :: FTFn -> FType -> FType

-- | Language for record labels
data RLabel
RLabel :: String -> RLabel
RGen :: Int -> RLabel
RVar :: String -> RLabel

-- | Type functions
data FTFn
Tr :: FTFn
Tr' :: FTFn

-- | Everything that contains a type.
class HasType a
typeOf :: HasType a => a -> Qual FType

-- | Class for transforming values into either an error or a string
--   representing a dot file.
class Dotify a
dot :: Dotify a => a -> Either FerryError String


-- | Everything related to untyped core
module Database.Ferry.Syntax

-- | An identifier is represented by a string
type Ident = String

-- | Identifiers are represented as strings
type Identifier = String

-- | Constant values
data Const
CInt :: Integer -> Const
CFloat :: Double -> Const
CBool :: Bool -> Const
CString :: String -> Const
CUnit :: Const

-- | Type class for extracting all variables that occur in a value of type
--   a
class VarContainer a
vars :: VarContainer a => a -> [Identifier]

-- | Operator constructor
data Op
Op :: String -> Op

-- | Datatype for building untyped core ASTs
data CoreExpr
BinOp :: Op -> CoreExpr -> CoreExpr -> CoreExpr
Constant :: Const -> CoreExpr
Var :: String -> CoreExpr
App :: CoreExpr -> Param -> CoreExpr
Let :: String -> CoreExpr -> CoreExpr -> CoreExpr
Rec :: [RecElem] -> CoreExpr
Cons :: CoreExpr -> CoreExpr -> CoreExpr
Nil :: CoreExpr
Elem :: CoreExpr -> String -> CoreExpr
Table :: String -> [Column] -> [Key] -> CoreExpr
If :: CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr

-- | Record elements
data RecElem
RecElem :: String -> CoreExpr -> RecElem

-- | Function arguments In future, that is when defunctionalisation is
--   implemented function arguments should just be expressions.
data Param
ParExpr :: CoreExpr -> Param
ParAbstr :: [String] -> CoreExpr -> Param

-- | Database table column
data Column
Column :: String -> Type -> Column

-- | Database table key
data Key
Key :: [String] -> Key

-- | Database column type
data Type
TInt :: Type
TFloat :: Type
TString :: Type
TBool :: Type
TUnit :: Type

-- | Class for transforming values into either an error or a string
--   representing a dot file.
class Dotify a
dot :: Dotify a => a -> Either FerryError String

-- | Class for pretty printing a value of a.
class Pretty a
pretty :: Pretty a => a -> Int -> String

-- | Shorthand for pretty without the identation argument
prettyPrint :: Pretty a => a -> String

-- | A newline followed by indenting n positions
newLine :: Int -> String

-- | maps its first argument over the third, then intersperses the result
--   with the second argument, and finally concatenates everything.
mapIntersperseConcat :: (a -> [b]) -> [b] -> [a] -> [b]

-- | Pretty print the values xs then intersperse with a comma and transform
--   it into one string
intersperseComma :: Pretty a => [a] -> Int -> String


-- | The compiler interface
module Database.Ferry.Compiler
xmlPhase :: (Qual FType, AlgPlan AlgRes) -> PhaseResult String
boxingPhase :: CoreExpr -> PhaseResult CoreExpr
rewritePhase :: CoreExpr -> PhaseResult CoreExpr
algebraPhase :: CoreExpr -> PhaseResult (Qual FType, AlgPlan AlgRes)
typeInferPhase :: CoreExpr -> PhaseResult CoreExpr

-- | The FerryError datatype represents errors that occur during
--   compilation
data FerryError
NoSuchFile :: String -> FerryError
ParserError :: ParseError -> FerryError
UnificationError :: FType -> FType -> FerryError
UnificationRecError :: [(RLabel, FType)] -> [(RLabel, FType)] -> FerryError
ClassAlreadyDefinedError :: String -> FerryError
SuperClassNotDefined :: String -> [String] -> FerryError
ClassNotDefined :: String -> FerryError
RecordDuplicateFields :: (Maybe String) -> [(RLabel, FType)] -> FerryError
NotARecordType :: FType -> FerryError
RecordWithoutI :: FType -> String -> FerryError
UnificationOfRecordFieldsFailed :: RLabel -> RLabel -> FerryError
UnificationFail :: RLabel -> RLabel -> FerryError
ProcessComplete :: FerryError

-- | Print an error message
handleError :: FerryError -> IO ()
typedCoreToAlgebra :: CoreExpr -> String

-- | The config datatype is used to store program flags given by the user
--   The compiler can be put in a <a>Mode</a> that determines what sort of
--   result the compilation process will result in. The <a>Input</a>
--   element is set to specify whether a file should be compiled or input
--   from the stdin The debug component is set to switch on debugging mode,
--   debugging mode results in log information on the stdin and possibly
--   extra compiler artifacts.
data Config
Config :: Mode -> Maybe String -> Maybe String -> Input -> [Artefact] -> Bool -> Config
mode :: Config -> Mode
logFile :: Config -> Maybe String
output :: Config -> Maybe String
input :: Config -> Input
artefact :: Config -> [Artefact]
debug :: Config -> Bool

-- | The modes that are supported by the compiler. run ferryc -h to see a
--   list of all options
data Mode
Read :: Mode

-- | Parse mode will stop the compiler after the parsing phase
Parse :: Mode
Normalise :: Mode
Transform :: Mode
TypeInfer :: Mode
OpRewrite :: Mode
Boxing :: Mode
Algebra :: Mode
AlgebraXML :: Mode
data Artefact

-- | Echo mode prints the given input to the console
Echo :: Artefact

-- | Pretty mode parses the given input and pretty prints the result
PrettyAST :: Artefact
PrettyNormalAST :: Artefact
PrettyCore :: Artefact
DotAST :: Artefact
DotCore :: Artefact
DotType :: Artefact
DotRewrite :: Artefact
DotBox :: Artefact
DotAlg :: Artefact
XML :: Artefact
Type :: Artefact
allArtefacts :: [Artefact]

-- | The input mode determines whether the source program is given through
--   a file or via stdin
data Input

-- | File mode, the program is read from a file
File :: String -> Input

-- | Argument mode, the program is given as input directly
Arg :: Input

-- | The default configuration for the compiler
defaultConfig :: Config

-- | The results of artefact generation are all collected in a reader monad
--   The final result is written to disk or screen when compilation has
--   succeeded
type ArtefactResult = Reader Config String

-- | Result of a compilation phase. The error monad is used in case
--   something went wrong during compilation The first writer monad is used
--   for logging purposes. The second writer monad is used to store the
--   artefacts generated by the compiler And the reader monad stores the
--   compiler configuration
type PhaseResult r = ErrorT FerryError (WriterT Log (WriterT [File] (Reader Config))) r

-- | Name of an artefact file
type FileName = String

-- | Artefact file, the first element represents the output file, in case
--   of nothing output is given on stdout. The second component is the file
--   content.
type File = (Maybe FileName, String)

-- | Compilationstep datatype. A compilation step is a record containg a
--   description (stageName field), the internal mode name (stageMode
--   field), the actual stage computation (stageStep field) that transforms
--   element of type a into a PhaseResult of type b and stage artefact
--   generators, a list of function generating artefacts (stageArtefacts
--   field).
data CompilationStep a b
CompilationStep :: Name -> Mode -> (a -> PhaseResult b) -> [(Artefact, String, b -> ArtefactResult)] -> CompilationStep a b
stageName :: CompilationStep a b -> Name
stageMode :: CompilationStep a b -> Mode
stageStep :: CompilationStep a b -> a -> PhaseResult b
stageArtefacts :: CompilationStep a b -> [(Artefact, String, b -> ArtefactResult)]

-- | Type synonym for a stage name type
type Name = String

-- | Every stage has a stage number
type Stage = Int

-- | The compilation log is just a string
type Log = [String]

-- | Lift the result of generating an artefact into the overall phase
--   result type
artefactToPhaseResult :: ArtefactResult -> PhaseResult String

-- | Get the compiler configuration
getConfig :: PhaseResult Config

-- | Get the current log from a phaseresult
getLog :: Config -> PhaseResult r -> Log

-- | Get the artefacts from the phaseresult
getFiles :: Config -> PhaseResult r -> [File]

-- | Execute a phaseresult under a given configuration,, resulting in
--   triple of: 1.) An error or the result 2.) The compilation log 3.) The
--   generated artefacts
runPhase :: Config -> PhaseResult r -> (Either FerryError r, Log, [File])

-- | Throw an error
newError :: FerryError -> PhaseResult r

-- | Final log message when end of compilation is reached
endProcess :: PhaseResult b

-- | Seperator line for logging
line :: String

-- | Log the message t
logMsg :: MonadWriter [t] m => t -> m ()

-- | Add the given file with contents to the phaseresult.
addFile :: Maybe FileName -> String -> PhaseResult ()

-- | The compiler pipeline. The given Core AST is transformed dependent on
--   the configuration of the Phaseresult monad.
backEndPipeline :: CoreExpr -> PhaseResult ()

-- | The compiler pipeline. Some tools might already provide a typed AST,
--   is the same as the normal backEndPipeline without type inferencing.
backEndPipeline' :: CoreExpr -> PhaseResult ()

-- | Apply a compilation step to an expression of type a. The result of
--   type b is returned in a phaseresult monad
executeStep :: CompilationStep a b -> a -> PhaseResult b
