-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Profunctor extras
--   
--   This package provides a number of utilities and constructions that
--   arise when working with profunctors that require minor extensions to
--   Haskell 98.
@package profunctor-extras
@version 3.3.3.1


module Data.Profunctor.Trace

-- | Coend of <a>Profunctor</a> from <tt>Hask -&gt; Hask</tt>.
data Trace f
Trace :: f a a -> Trace f


module Data.Profunctor.Collage

-- | The cograph of a <a>Profunctor</a>.
data Collage k b a
L :: (b -> b') -> Collage k (L b) (L b')
R :: (a -> a') -> Collage k (R a) (R a')
C :: k b a -> Collage k (L b) (R a)
instance Profunctor k => Ob (Collage k) (R a)
instance Profunctor k => Ob (Collage k) (L a)
instance Profunctor k => Semigroupoid (Collage k)


module Data.Profunctor.Rep

-- | A <a>Profunctor</a> <tt>p</tt> is <a>Representable</a> if there exists
--   a <a>Functor</a> <tt>f</tt> such that <tt>p d c</tt> is isomorphic to
--   <tt>d -&gt; f c</tt>.
class (Functor (Rep p), Profunctor p) => Representable p where type family Rep p :: * -> *
tabulate :: Representable p => (d -> Rep p c) -> p d c
rep :: Representable p => p d c -> d -> Rep p c

-- | <a>tabulate</a> and <a>rep</a> form two halves of an isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>tabulated</a> :: <a>Representable</a> p =&gt; <tt>Iso'</tt> (d -&gt; <a>Rep</a> p c) (p d c)
--   </pre>
tabulated :: (Profunctor r, Functor f, Representable p, Representable q) => r (p d c) (f (q d' c')) -> r (d -> Rep p c) (f (d' -> Rep q c'))

-- | A <a>Profunctor</a> <tt>p</tt> is <a>Corepresentable</a> if there
--   exists a <a>Functor</a> <tt>f</tt> such that <tt>p d c</tt> is
--   isomorphic to <tt>f d -&gt; c</tt>.
class (Functor (Corep p), Profunctor p) => Corepresentable p where type family Corep p :: * -> *
cotabulate :: Corepresentable p => (Corep p d -> c) -> p d c
corep :: Corepresentable p => p d c -> Corep p d -> c

-- | <a>cotabulate</a> and <a>corep</a> form two halves of an isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>tabulated</a> :: <a>Corep</a> f p =&gt; <tt>Iso'</tt> (f d -&gt; c) (p d c)
--   </pre>
cotabulated :: (Profunctor r, Functor h, Corepresentable p, Corepresentable q) => r (p d c) (h (q d' c')) -> r (Corep p d -> c) (h (Corep q d' -> c'))
instance Functor f => Corepresentable (DownStar f)
instance Corepresentable (Tagged *)
instance Functor w => Corepresentable (Cokleisli w)
instance Corepresentable (->)
instance Functor f => Representable (UpStar f)
instance (Monad m, Functor m) => Representable (Kleisli m)
instance Representable (->)


module Data.Profunctor.Composition

-- | <tt><a>Procompose</a> p q</tt> is the <a>Profunctor</a> composition of
--   the <a>Profunctor</a>s <tt>p</tt> and <tt>q</tt>.
--   
--   For a good explanation of <a>Profunctor</a> composition in Haskell see
--   Dan Piponi's article:
--   
--   <a>http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html</a>
data Procompose p q d c
Procompose :: p d a -> q a c -> Procompose p q d c
procomposed :: Category p => Procompose p p a b -> p a b

-- | <tt>(-&gt;)</tt> functions as a lax identity for <a>Profunctor</a>
--   composition.
--   
--   This provides an <tt>Iso</tt> for the <tt>lens</tt> package that
--   witnesses the isomorphism between <tt><a>Procompose</a> (-&gt;) q d
--   c</tt> and <tt>q d c</tt>, which is the left identity law.
--   
--   <pre>
--   <a>idl</a> :: <a>Profunctor</a> q =&gt; Iso' (<a>Procompose</a> (-&gt;) q d c) (q d c)
--   </pre>
idl :: (Profunctor p, Profunctor q, Functor f) => p (q d c) (f (r d' c')) -> p (Procompose (->) q d c) (f (Procompose (->) r d' c'))

-- | <tt>(-&gt;)</tt> functions as a lax identity for <a>Profunctor</a>
--   composition.
--   
--   This provides an <tt>Iso</tt> for the <tt>lens</tt> package that
--   witnesses the isomorphism between <tt><a>Procompose</a> q (-&gt;) d
--   c</tt> and <tt>q d c</tt>, which is the right identity law.
--   
--   <pre>
--   <a>idr</a> :: <a>Profunctor</a> q =&gt; Iso' (<a>Procompose</a> q (-&gt;) d c) (q d c)
--   </pre>
idr :: (Profunctor p, Profunctor q, Functor f) => p (q d c) (f (r d' c')) -> p (Procompose q (->) d c) (f (Procompose r (->) d' c'))

-- | <a>Profunctor</a> composition generalizes <a>Functor</a> composition
--   in two ways.
--   
--   This is the first, which shows that <tt>exists b. (a -&gt; f b, b
--   -&gt; g c)</tt> is isomorphic to <tt>a -&gt; f (g c)</tt>.
--   
--   <pre>
--   <a>upstars</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>UpStar</a> f) (<a>UpStar</a> g) d c) (<a>UpStar</a> (<a>Compose</a> f g) d c)
--   </pre>
upstars :: (Profunctor p, Functor f, Functor h) => p (UpStar (Compose f g) d c) (h (UpStar (Compose f' g') d' c')) -> p (Procompose (UpStar f) (UpStar g) d c) (h (Procompose (UpStar f') (UpStar g') d' c'))

-- | This is a variant on <a>upstars</a> that uses <a>Kleisli</a> instead
--   of <a>UpStar</a>.
--   
--   <pre>
--   <a>kleislis</a> :: <a>Monad</a> f =&gt; Iso' (<a>Procompose</a> (<a>Kleisli</a> f) (<a>Kleisli</a> g) d c) (<a>Kleisli</a> (<a>Compose</a> f g) d c)
--   </pre>
kleislis :: (Profunctor p, Monad f, Functor h) => p (Kleisli (Compose f g) d c) (h (Kleisli (Compose f' g') d' c')) -> p (Procompose (Kleisli f) (Kleisli g) d c) (h (Procompose (Kleisli f') (Kleisli g') d' c'))

-- | <a>Profunctor</a> composition generalizes <a>Functor</a> composition
--   in two ways.
--   
--   This is the second, which shows that <tt>exists b. (f a -&gt; b, g b
--   -&gt; c)</tt> is isomorphic to <tt>g (f a) -&gt; c</tt>.
--   
--   <pre>
--   <a>downstars</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>DownStar</a> f) (<a>DownStar</a> g) d c) (<a>DownStar</a> (<a>Compose</a> g f) d c)
--   </pre>
downstars :: (Profunctor p, Functor g, Functor h) => p (DownStar (Compose g f) d c) (h (DownStar (Compose g' f') d' c')) -> p (Procompose (DownStar f) (DownStar g) d c) (h (Procompose (DownStar f') (DownStar g') d' c'))

-- | This is a variant on <a>downstars</a> that uses <a>Cokleisli</a>
--   instead of <a>DownStar</a>.
--   
--   <pre>
--   <a>cokleislis</a> :: <a>Functor</a> f =&gt; Iso' (<a>Procompose</a> (<a>Cokleisli</a> f) (<a>Cokleisli</a> g) d c) (<a>Cokleisli</a> (<a>Compose</a> g f) d c)
--   </pre>
cokleislis :: (Profunctor p, Functor g, Functor h) => p (Cokleisli (Compose g f) d c) (h (Cokleisli (Compose g' f') d' c')) -> p (Procompose (Cokleisli f) (Cokleisli g) d c) (h (Procompose (Cokleisli f') (Cokleisli g') d' c'))
instance (Choice p, Choice q) => Choice (Procompose p q)
instance (Strong p, Strong q) => Strong (Procompose p q)
instance (Corepresentable p, Corepresentable q) => Corepresentable (Procompose p q)
instance (Representable p, Representable q) => Representable (Procompose p q)
instance Profunctor q => Functor (Procompose p q a)
instance (Profunctor p, Profunctor q) => Profunctor (Procompose p q)


module Data.Profunctor.Rift

-- | This represents the right Kan lift of a <a>Profunctor</a> <tt>q</tt>
--   along a <a>Profunctor</a> <tt>p</tt> in a limited version of the
--   2-category of Profunctors where the only object is the category Hask,
--   1-morphisms are profunctors composed and compose with Profunctor
--   composition, and 2-morphisms are just natural transformations.
newtype Rift p q a b
Rift :: (forall x. p x a -> q x b) -> Rift p q a b
runRift :: Rift p q a b -> forall x. p x a -> q x b

-- | The 2-morphism that defines a right Kan lift.
--   
--   Note: When <tt>f</tt> is left adjoint to <tt><a>Rift</a> f
--   (-&gt;)</tt> then <a>decomposeRift</a> is the <tt>counit</tt> of the
--   adjunction.
decomposeRift :: Procompose q (Rift q p) a b -> p a b
precomposeRift :: Profunctor q => Procompose (Rift p (->)) q a b -> Rift p q a b
instance p ~ q => Category (Rift p q)
instance Profunctor q => Functor (Rift p q a)
instance (Profunctor p, Profunctor q) => Profunctor (Rift p q)
