-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell high-level wrapper for OpenCL
--   
--   Haskell FFI binding to OpenCL library. It includes high-level wrappers
--   to help development. Based on the OpenCLRaw package.
--   
--   Most of the functions can throw a <a>CLError</a> exception. Using the
--   module <a>Control.Exception</a> helps to work with this package's
--   exceptions.
@package OpenCL
@version 1.0.3.2

module Control.Parallel.OpenCL.Program
type CLProgram = Ptr ()

-- | <ul>
--   <li><a>CL_BUILD_NONE</a>. The build status returned if no build has
--   been performed on the specified program object for device.</li>
--   <li><a>CL_BUILD_ERROR</a>. The build status returned if the last call
--   to <tt>clBuildProgram</tt> on the specified program object for device
--   generated an error.</li>
--   <li><a>CL_BUILD_SUCCESS</a>. The build status retrned if the last call
--   to <tt>clBuildProgram</tt> on the specified program object for device
--   was successful.</li>
--   <li><a>CL_BUILD_IN_PROGRESS</a>. The build status returned if the last
--   call to <tt>clBuildProgram</tt> on the specified program object for
--   device has not finished.</li>
--   </ul>
data CLBuildStatus
CL_BUILD_NONE :: CLBuildStatus
CL_BUILD_ERROR :: CLBuildStatus
CL_BUILD_SUCCESS :: CLBuildStatus
CL_BUILD_IN_PROGRESS :: CLBuildStatus
type CLKernel = Ptr ()

-- | Creates a program object for a context, and loads the source code
--   specified by the text strings in the strings array into the program
--   object. The devices associated with the program object are the devices
--   associated with context.
--   
--   OpenCL allows applications to create a program object using the
--   program source or binary and build appropriate program executables.
--   This allows applications to determine whether they want to use the
--   pre-built offline binary or load and compile the program source and
--   use the executable compiled/linked online as the program executable.
--   This can be very useful as it allows applications to load and build
--   program executables online on its first instance for appropriate
--   OpenCL devices in the system. These executables can now be queried and
--   cached by the application. Future instances of the application
--   launching will no longer need to compile and build the program
--   executables. The cached executables can be read and loaded by the
--   application, which can help significantly reduce the application
--   initialization time.
--   
--   An OpenCL program consists of a set of kernels that are identified as
--   functions declared with the __kernel qualifier in the program source.
--   OpenCL programs may also contain auxiliary functions and constant data
--   that can be used by __kernel functions. The program executable can be
--   generated online or offline by the OpenCL compiler for the appropriate
--   target device(s).
--   
--   <a>clCreateProgramWithSource</a> returns a valid non-zero program
--   object if the program object is created successfully. Otherwise, it
--   throws one of the following <a>CLError</a> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateProgramWithSource :: CLContext -> String -> IO CLProgram

-- | Creates a program object for a context, and loads specified binary
--   data into the program object.
--   
--   The program binaries specified by binaries contain the bits that
--   describe the program executable that will be run on the device(s)
--   associated with context. The program binary can consist of either or
--   both of device-specific executable(s), and/or implementation-specific
--   intermediate representation (IR) which will be converted to the
--   device-specific executable.
--   
--   OpenCL allows applications to create a program object using the
--   program source or binary and build appropriate program executables.
--   This allows applications to determine whether they want to use the
--   pre-built offline binary or load and compile the program source and
--   use the executable compiled/linked online as the program executable.
--   This can be very useful as it allows applications to load and build
--   program executables online on its first instance for appropriate
--   OpenCL devices in the system. These executables can now be queried and
--   cached by the application. Future instances of the application
--   launching will no longer need to compile and build the program
--   executables. The cached executables can be read and loaded by the
--   application, which can help significantly reduce the application
--   initialization time.
--   
--   Returns a valid non-zero program object and a list of <a>CLError</a>
--   values whether the program binary for each device specified in
--   device_list was loaded successfully or not. It is list of the same
--   length the list of devices with <tt>CL_SUCCESS</tt> if binary was
--   successfully loaded for device specified by same position; otherwise
--   returns <tt>CL_INVALID_VALUE</tt> if length of binary is zero or
--   <tt>CL_INVALID_BINARY</tt> if program binary is not a valid binary for
--   the specified device.
--   
--   The function can throw on of the following <a>CLError</a> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the device list is empty; or if
--   lengths or binaries are empty.</li>
--   <li><tt>CL_INVALID_DEVICE</tt> if OpenCL devices listed in the device
--   list are not in the list of devices associated with context.</li>
--   <li><tt>CL_INVALID_BINARY</tt> if an invalid program binary was
--   encountered for any device.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateProgramWithBinary :: CLContext -> [CLDeviceID] -> [[Word8]] -> IO (CLProgram, [CLError])

-- | Increments the program reference count. <a>clRetainProgram</a> returns
--   <a>True</a> if the function is executed successfully. It returns
--   <a>False</a> if program is not a valid program object.
clRetainProgram :: CLProgram -> IO Bool

-- | Decrements the program reference count. The program object is deleted
--   after all kernel objects associated with program have been deleted and
--   the program reference count becomes zero. <tt>clReleseProgram</tt>
--   returns <a>True</a> if the function is executed successfully. It
--   returns <a>False</a> if program is not a valid program object.
clReleaseProgram :: CLProgram -> IO Bool

-- | Allows the implementation to release the resources allocated by the
--   OpenCL compiler. This is a hint from the application and does not
--   guarantee that the compiler will not be used in the future or that the
--   compiler will actually be unloaded by the implementation. Calls to
--   <a>clBuildProgram</a> after <a>clUnloadCompiler</a> will reload the
--   compiler, if necessary, to build the appropriate program executable.
clUnloadCompiler :: IO ()

-- | Builds (compiles and links) a program executable from the program
--   source or binary. OpenCL allows program executables to be built using
--   the source or the binary. The build options are categorized as
--   pre-processor options, options for math intrinsics, options that
--   control optimization and miscellaneous options. This specification
--   defines a standard set of options that must be supported by an OpenCL
--   compiler when building program executables online or offline. These
--   may be extended by a set of vendor- or platform-specific options.
--   
--   <ul>
--   <li>Preprocessor Options</li>
--   </ul>
--   
--   These options control the OpenCL preprocessor which is run on each
--   program source before actual compilation. -D options are processed in
--   the order they are given in the options argument to clBuildProgram.
--   
--   <ul>
--   <li><i>-D name</i> Predefine name as a macro, with definition 1.</li>
--   <li><i>-D name=definition</i> The contents of definition are tokenized
--   and processed as if they appeared during translation phase three in a
--   `#define' directive. In particular, the definition will be truncated
--   by embedded newline characters.</li>
--   <li><i>-I dir</i> Add the directory dir to the list of directories to
--   be searched for header files.</li>
--   </ul>
--   
--   <ul>
--   <li>Math Intrinsics Options</li>
--   </ul>
--   
--   These options control compiler behavior regarding floating-point
--   arithmetic. These options trade off between speed and correctness.
--   
--   <ul>
--   <li><i>-cl-single-precision-constant</i> Treat double precision
--   floating-point constant as single precision constant.</li>
--   <li><i>-cl-denorms-are-zero</i> This option controls how single
--   precision and double precision denormalized numbers are handled. If
--   specified as a build option, the single precision denormalized numbers
--   may be flushed to zero and if the optional extension for double
--   precision is supported, double precision denormalized numbers may also
--   be flushed to zero. This is intended to be a performance hint and the
--   OpenCL compiler can choose not to flush denorms to zero if the device
--   supports single precision (or double precision) denormalized
--   numbers.</li>
--   </ul>
--   
--   This option is ignored for single precision numbers if the device does
--   not support single precision denormalized numbers i.e.
--   <tt>CL_FP_DENORM</tt> bit is not set in
--   <tt>clGetDeviceSingleFPConfig</tt>.
--   
--   This option is ignored for double precision numbers if the device does
--   not support double precision or if it does support double precison but
--   <tt>CL_FP_DENORM</tt> bit is not set in
--   <tt>clGetDeviceDoubleFPConfig</tt>.
--   
--   This flag only applies for scalar and vector single precision
--   floating-point variables and computations on these floating-point
--   variables inside a program. It does not apply to reading from or
--   writing to image objects.
--   
--   <ul>
--   <li>Optimization Options</li>
--   </ul>
--   
--   These options control various sorts of optimizations. Turning on
--   optimization flags makes the compiler attempt to improve the
--   performance and/or code size at the expense of compilation time and
--   possibly the ability to debug the program.
--   
--   <ul>
--   <li><i>-cl-opt-disable</i> This option disables all optimizations. The
--   default is optimizations are enabled.</li>
--   <li><i>-cl-strict-aliasing</i> This option allows the compiler to
--   assume the strictest aliasing rules.</li>
--   </ul>
--   
--   The following options control compiler behavior regarding
--   floating-point arithmetic. These options trade off between performance
--   and correctness and must be specifically enabled. These options are
--   not turned on by default since it can result in incorrect output for
--   programs which depend on an exact implementation of IEEE 754
--   rules/specifications for math functions.
--   
--   <ul>
--   <li><i>-cl-mad-enable</i> Allow a * b + c to be replaced by a mad. The
--   mad computes a * b + c with reduced accuracy. For example, some OpenCL
--   devices implement mad as truncate the result of a * b before adding it
--   to c.</li>
--   <li><i>-cl-no-signed-zeros</i> Allow optimizations for floating-point
--   arithmetic that ignore the signedness of zero. IEEE 754 arithmetic
--   specifies the behavior of distinct +0.0 and -0.0 values, which then
--   prohibits simplification of expressions such as x+0.0 or 0.0*x (even
--   with -clfinite-math only). This option implies that the sign of a zero
--   result isn't significant.</li>
--   <li><i>-cl-unsafe-math-optimizations</i> Allow optimizations for
--   floating-point arithmetic that (a) assume that arguments and results
--   are valid, (b) may violate IEEE 754 standard and (c) may violate the
--   OpenCL numerical compliance requirements as defined in section 7.4 for
--   single-precision floating-point, section 9.3.9 for double-precision
--   floating-point, and edge case behavior in section 7.5. This option
--   includes the -cl-no-signed-zeros and -cl-mad-enable options.</li>
--   <li><i>-cl-finite-math-only</i> Allow optimizations for floating-point
--   arithmetic that assume that arguments and results are not NaNs or ±∞.
--   This option may violate the OpenCL numerical compliance requirements
--   defined in in section 7.4 for single-precision floating-point, section
--   9.3.9 for double-precision floating-point, and edge case behavior in
--   section 7.5.</li>
--   <li><i>-cl-fast-relaxed-math</i> Sets the optimization options
--   -cl-finite-math-only and -cl-unsafe-math-optimizations. This allows
--   optimizations for floating-point arithmetic that may violate the IEEE
--   754 standard and the OpenCL numerical compliance requirements defined
--   in the specification in section 7.4 for single-precision
--   floating-point, section 9.3.9 for double-precision floating-point, and
--   edge case behavior in section 7.5. This option causes the preprocessor
--   macro __FAST_RELAXED_MATH__ to be defined in the OpenCL program.</li>
--   </ul>
--   
--   <ul>
--   <li>Options to Request or Suppress Warnings</li>
--   </ul>
--   
--   Warnings are diagnostic messages that report constructions which are
--   not inherently erroneous but which are risky or suggest there may have
--   been an error. The following languageindependent options do not enable
--   specific warnings but control the kinds of diagnostics produced by the
--   OpenCL compiler.
--   
--   <ul>
--   <li><i>-w</i> Inhibit all warning messages.</li>
--   <li><i>-Werror</i> Make all warnings into errors.</li>
--   </ul>
--   
--   clBuildProgram can throw the following <a>CLError</a> exceptions when
--   fails:
--   
--   <ul>
--   <li><tt>CL_INVALID_PROGRAM</tt> if program is not a valid program
--   object.</li>
--   <li><tt>CL_INVALID_DEVICE</tt> if OpenCL devices listed in device_list
--   are not in the list of devices associated with program.</li>
--   <li><tt>CL_INVALID_BINARY</tt> if program is created with
--   <tt>clCreateWithProgramWithBinary</tt> and devices listed in
--   device_list do not have a valid program binary loaded.</li>
--   <li><tt>CL_INVALID_BUILD_OPTIONS</tt> if the build options specified
--   by options are invalid.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if the build of a program executable
--   for any of the devices listed in device_list by a previous call to
--   <a>clBuildProgram</a> for program has not completed.</li>
--   <li><tt>CL_COMPILER_NOT_AVAILABLE</tt> if program is created with
--   <a>clCreateProgramWithSource</a> and a compiler is not available i.e.
--   <tt>clGetDeviceCompilerAvailable</tt> is set to <a>False</a>.</li>
--   <li><tt>CL_BUILD_PROGRAM_FAILURE</tt> if there is a failure to build
--   the program executable. This error will be returned if
--   <a>clBuildProgram</a> does not return until the build has
--   completed.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if there are kernel objects attached
--   to program.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clBuildProgram :: CLProgram -> [CLDeviceID] -> String -> IO ()

-- | Return the program reference count. The reference count returned
--   should be considered immediately stale. It is unsuitable for general
--   use in applications. This feature is provided for identifying memory
--   leaks.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_REFERENCE_COUNT</a>.
clGetProgramReferenceCount :: CLProgram -> IO CLuint

-- | Return the context specified when the program object is created.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_CONTEXT</a>.
clGetProgramContext :: CLProgram -> IO CLContext

-- | Return the number of devices associated with program.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_NUM_DEVICES</a>.
clGetProgramNumDevices :: CLProgram -> IO CLuint

-- | Return the list of devices associated with the program object. This
--   can be the devices associated with context on which the program object
--   has been created or can be a subset of devices that are specified when
--   a progam object is created using <a>clCreateProgramWithBinary</a>.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_DEVICES</a>.
clGetProgramDevices :: CLProgram -> IO [CLDeviceID]

-- | Return the program source code specified by
--   <a>clCreateProgramWithSource</a>. The source string returned is a
--   concatenation of all source strings specified to
--   <a>clCreateProgramWithSource</a> with a null terminator. The
--   concatenation strips any nulls in the original source strings. The
--   actual number of characters that represents the program source code
--   including the null terminator is returned in param_value_size_ret.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_SOURCE</a>.
clGetProgramSource :: CLProgram -> IO String

-- | Returns an array that contains the size in bytes of the program binary
--   for each device associated with program. The size of the array is the
--   number of devices associated with program. If a binary is not
--   available for a device(s), a size of zero is returned.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_BINARY_SIZES</a>.
clGetProgramBinarySizes :: CLProgram -> IO [CSize]

-- | Return the program binaries for all devices associated with program.
--   For each device in program, the binary returned can be the binary
--   specified for the device when program is created with
--   <a>clCreateProgramWithBinary</a> or it can be the executable binary
--   generated by <a>clBuildProgram</a>. If program is created with
--   <a>clCreateProgramWithSource</a>, the binary returned is the binary
--   generated by <a>clBuildProgram</a>. The bits returned can be an
--   implementation-specific intermediate representation (a.k.a. IR) or
--   device specific executable bits or both. The decision on which
--   information is returned in the binary is up to the OpenCL
--   implementation.
--   
--   To find out which device the program binary in the array refers to,
--   use the <a>clGetProgramDevices</a> query to get the list of devices.
--   There is a one-to-one correspondence between the array of data
--   returned by <a>clGetProgramBinaries</a> and array of devices returned
--   by <a>clGetProgramDevices</a>.
--   
--   This function execute OpenCL clGetProgramInfo with
--   <a>CL_PROGRAM_BINARIES</a>.
clGetProgramBinaries :: CLProgram -> IO [[Word8]]

-- | Returns the build status of program for a specific device as given by
--   device.
--   
--   This function execute OpenCL clGetProgramBuildInfo with
--   <a>CL_PROGRAM_BUILD_STATUS</a>.
clGetProgramBuildStatus :: CLProgram -> CLDeviceID -> IO CLBuildStatus

-- | Return the build options specified by the options argument in
--   clBuildProgram for device. If build status of program for device is
--   <a>CL_BUILD_NONE</a>, an empty string is returned.
--   
--   This function execute OpenCL clGetProgramBuildInfo with
--   <a>CL_PROGRAM_BUILD_OPTIONS</a>.
clGetProgramBuildOptions :: CLProgram -> CLDeviceID -> IO String

-- | Return the build log when <a>clBuildProgram</a> was called for device.
--   If build status of program for device is <a>CL_BUILD_NONE</a>, an
--   empty string is returned.
--   
--   This function execute OpenCL clGetProgramBuildInfo with
--   <a>CL_PROGRAM_BUILD_LOG</a>.
clGetProgramBuildLog :: CLProgram -> CLDeviceID -> IO String

-- | Creates a kernal object. A kernel is a function declared in a program.
--   A kernel is identified by the __kernel qualifier applied to any
--   function in a program. A kernel object encapsulates the specific
--   __kernel function declared in a program and the argument values to be
--   used when executing this __kernel function.
--   
--   <a>clCreateKernel</a> returns a valid non-zero kernel object if the
--   kernel object is created successfully. Otherwise, it throws one of the
--   following <a>CLError</a> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_PROGRAM</tt> if program is not a valid program
--   object.</li>
--   <li><tt>CL_INVALID_PROGRAM_EXECUTABLE</tt> if there is no successfully
--   built executable for program.</li>
--   <li><tt>CL_INVALID_KERNEL_NAME</tt> if kernel_name is not found in
--   program.</li>
--   <li><tt>CL_INVALID_KERNEL_DEFINITION</tt> if the function definition
--   for __kernel function given by kernel_name such as the number of
--   arguments, the argument types are not the same for all devices for
--   which the program executable has been built.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateKernel :: CLProgram -> String -> IO CLKernel

-- | Creates kernel objects for all kernel functions in a program object.
--   Kernel objects are not created for any __kernel functions in program
--   that do not have the same function definition across all devices for
--   which a program executable has been successfully built.
--   
--   Kernel objects can only be created once you have a program object with
--   a valid program source or binary loaded into the program object and
--   the program executable has been successfully built for one or more
--   devices associated with program. No changes to the program executable
--   are allowed while there are kernel objects associated with a program
--   object. This means that calls to <a>clBuildProgram</a> return
--   <tt>CL_INVALID_OPERATION</tt> if there are kernel objects attached to
--   a program object. The OpenCL context associated with program will be
--   the context associated with kernel. The list of devices associated
--   with program are the devices associated with kernel. Devices
--   associated with a program object for which a valid program executable
--   has been built can be used to execute kernels declared in the program
--   object.
--   
--   <a>clCreateKernelsInProgram</a> will return the kernel objects if the
--   kernel objects were successfully allocated, throws
--   <tt>CL_INVALID_PROGRAM</tt> if program is not a valid program object,
--   throws <tt>CL_INVALID_PROGRAM_EXECUTABLE</tt> if there is no
--   successfully built executable for any device in program and throws
--   <tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.
clCreateKernelsInProgram :: CLProgram -> IO [CLKernel]

-- | Increments the program program reference count. <a>clRetainKernel</a>
--   returns <a>True</a> if the function is executed successfully.
--   <a>clCreateKernel</a> or <a>clCreateKernelsInProgram</a> do an
--   implicit retain.
clRetainKernel :: CLKernel -> IO Bool

-- | Decrements the kernel reference count. The kernel object is deleted
--   once the number of instances that are retained to kernel become zero
--   and the kernel object is no longer needed by any enqueued commands
--   that use kernel. <a>clReleaseKernel</a> returns <a>True</a> if the
--   function is executed successfully.
clReleaseKernel :: CLKernel -> IO Bool

-- | Used to set the argument value for a specific argument of a kernel.
--   
--   A kernel object does not update the reference count for objects such
--   as memory, sampler objects specified as argument values by
--   <a>clSetKernelArg</a>, Users may not rely on a kernel object to retain
--   objects specified as argument values to the kernel.
--   
--   Implementations shall not allow <a>CLKernel</a> objects to hold
--   reference counts to <a>CLKernel</a> arguments, because no mechanism is
--   provided for the user to tell the kernel to release that ownership
--   right. If the kernel holds ownership rights on kernel args, that would
--   make it impossible for the user to tell with certainty when he may
--   safely release user allocated resources associated with OpenCL objects
--   such as the CLMem backing store used with
--   <tt>CL_MEM_USE_HOST_PTR</tt>.
--   
--   <a>clSetKernelArg</a> throws one of the following <a>CLError</a>
--   exceptions when fails:
--   
--   <ul>
--   <li><tt>CL_INVALID_KERNEL</tt> if kernel is not a valid kernel
--   object.</li>
--   <li><tt>CL_INVALID_ARG_INDEX</tt> if arg_index is not a valid argument
--   index.</li>
--   <li><tt>CL_INVALID_ARG_VALUE</tt> if arg_value specified is NULL for
--   an argument that is not declared with the __local qualifier or
--   vice-versa.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> for an argument declared to be a
--   memory object when the specified arg_value is not a valid memory
--   object.</li>
--   <li><tt>CL_INVALID_SAMPLER</tt> for an argument declared to be of type
--   sampler_t when the specified arg_value is not a valid sampler
--   object.</li>
--   <li><tt>CL_INVALID_ARG_SIZE</tt> if arg_size does not match the size
--   of the data type for an argument that is not a memory object or if the
--   argument is a memory object and arg_size != sizeof(cl_mem) or if
--   arg_size is zero and the argument is declared with the __local
--   qualifier or if the argument is a sampler and arg_size !=
--   sizeof(cl_sampler).</li>
--   </ul>
clSetKernelArg :: Integral a => CLKernel -> CLuint -> a -> Ptr b -> IO ()

-- | Wrap function of <a>clSetKernelArg</a> with Storable data.
clSetKernelArgSto :: Storable a => CLKernel -> CLuint -> a -> IO ()

-- | Return the kernel function name.
--   
--   This function execute OpenCL clGetKernelInfo with
--   <a>CL_KERNEL_FUNCTION_NAME</a>.
clGetKernelFunctionName :: CLKernel -> IO String

-- | Return the number of arguments to kernel.
--   
--   This function execute OpenCL clGetKernelInfo with
--   <a>CL_KERNEL_NUM_ARGS</a>.
clGetKernelNumArgs :: CLKernel -> IO CLuint

-- | Return the kernel reference count. The reference count returned should
--   be considered immediately stale. It is unsuitable for general use in
--   applications. This feature is provided for identifying memory leaks.
--   
--   This function execute OpenCL clGetKernelInfo with
--   <a>CL_KERNEL_REFERENCE_COUNT</a>.
clGetKernelReferenceCount :: CLKernel -> IO CLuint

-- | Return the context associated with kernel.
--   
--   This function execute OpenCL clGetKernelInfo with
--   <a>CL_KERNEL_CONTEXT</a>.
clGetKernelContext :: CLKernel -> IO CLContext

-- | Return the program object associated with kernel.
--   
--   This function execute OpenCL clGetKernelInfo with
--   <a>CL_KERNEL_PROGRAM</a>.
clGetKernelProgram :: CLKernel -> IO CLProgram

-- | This provides a mechanism for the application to query the work-group
--   size that can be used to execute a kernel on a specific device given
--   by device. The OpenCL implementation uses the resource requirements of
--   the kernel (register usage etc.) to determine what this work-group
--   size should be.
--   
--   This function execute OpenCL clGetKernelWorkGroupInfo with
--   <a>CL_KERNEL_WORK_GROUP_SIZE</a>.
clGetKernelWorkGroupSize :: CLKernel -> CLDeviceID -> IO CSize

-- | Returns the work-group size specified by the
--   __attribute__((reqd_work_gr oup_size(X, Y, Z))) qualifier. See
--   Function Qualifiers. If the work-group size is not specified using the
--   above attribute qualifier (0, 0, 0) is returned.
--   
--   This function execute OpenCL clGetKernelWorkGroupInfo with
--   <a>CL_KERNEL_COMPILE_WORK_GROUP_SIZE</a>.
clGetKernelCompileWorkGroupSize :: CLKernel -> CLDeviceID -> IO [CSize]

-- | Returns the amount of local memory in bytes being used by a kernel.
--   This includes local memory that may be needed by an implementation to
--   execute the kernel, variables declared inside the kernel with the
--   __local address qualifier and local memory to be allocated for
--   arguments to the kernel declared as pointers with the __local address
--   qualifier and whose size is specified with <a>clSetKernelArg</a>.
--   
--   If the local memory size, for any pointer argument to the kernel
--   declared with the __local address qualifier, is not specified, its
--   size is assumed to be 0.
--   
--   This function execute OpenCL clGetKernelWorkGroupInfo with
--   <a>CL_KERNEL_LOCAL_MEM_SIZE</a>.
clGetKernelLocalMemSize :: CLKernel -> CLDeviceID -> IO CLulong
instance Enum CLKernelGroupInfo
instance Enum CLKernelInfo
instance Enum CLProgramBuildInfo
instance Enum CLProgramInfo

module Control.Parallel.OpenCL.Event
type CLEvent = Ptr ()

-- | Command associated with an event.
data CLCommandType
CL_COMMAND_NDRANGE_KERNEL :: CLCommandType
CL_COMMAND_TASK :: CLCommandType
CL_COMMAND_NATIVE_KERNEL :: CLCommandType
CL_COMMAND_READ_BUFFER :: CLCommandType
CL_COMMAND_WRITE_BUFFER :: CLCommandType
CL_COMMAND_COPY_BUFFER :: CLCommandType
CL_COMMAND_READ_IMAGE :: CLCommandType
CL_COMMAND_WRITE_IMAGE :: CLCommandType
CL_COMMAND_COPY_IMAGE :: CLCommandType
CL_COMMAND_COPY_BUFFER_TO_IMAGE :: CLCommandType
CL_COMMAND_COPY_IMAGE_TO_BUFFER :: CLCommandType
CL_COMMAND_MAP_BUFFER :: CLCommandType
CL_COMMAND_MAP_IMAGE :: CLCommandType
CL_COMMAND_UNMAP_MEM_OBJECT :: CLCommandType
CL_COMMAND_MARKER :: CLCommandType
CL_COMMAND_ACQUIRE_GL_OBJECTS :: CLCommandType
CL_COMMAND_RELEASE_GL_OBJECTS :: CLCommandType

-- | Specifies the profiling data.
--   
--   <ul>
--   <li><a>CL_PROFILING_COMMAND_QUEUED</a>, A 64-bit value that describes
--   the current device time counter in nanoseconds when the command
--   identified by event is enqueued in a command-queue by the host.</li>
--   <li><a>CL_PROFILING_COMMAND_SUBMIT</a>, A 64-bit value that describes
--   the current device time counter in nanoseconds when the command
--   identified by event that has been enqueued is submitted by the host to
--   the device associated with the commandqueue.</li>
--   <li><a>CL_PROFILING_COMMAND_START</a>, A 64-bit value that describes
--   the current device time counter in nanoseconds when the command
--   identified by event starts execution on the device.</li>
--   <li><a>CL_PROFILING_COMMAND_END</a>, A 64-bit value that describes the
--   current device time counter in nanoseconds when the command identified
--   by event has finished execution on the device.</li>
--   </ul>
data CLProfilingInfo
CL_PROFILING_COMMAND_QUEUED :: CLProfilingInfo
CL_PROFILING_COMMAND_SUBMIT :: CLProfilingInfo
CL_PROFILING_COMMAND_START :: CLProfilingInfo
CL_PROFILING_COMMAND_END :: CLProfilingInfo

-- | <ul>
--   <li><a>CL_QUEUED</a>, command has been enqueued in the
--   command-queue.</li>
--   <li><a>CL_SUBMITTED</a>, enqueued command has been submitted by the
--   host to the device associated with the command-queue.</li>
--   <li><a>CL_RUNNING</a>, device is currently executing this
--   command.</li>
--   <li><a>CL_COMPLETE</a>, the command has completed.</li>
--   <li><a>CL_EXEC_ERROR</a>, command was abnormally terminated.</li>
--   </ul>
data CLCommandExecutionStatus
CL_QUEUED :: CLCommandExecutionStatus
CL_SUBMITTED :: CLCommandExecutionStatus
CL_RUNNING :: CLCommandExecutionStatus
CL_COMPLETE :: CLCommandExecutionStatus
CL_EXEC_ERROR :: CLCommandExecutionStatus

-- | Waits on the host thread for commands identified by event objects in
--   event_list to complete. A command is considered complete if its
--   execution status is <a>CL_COMPLETE</a> or a negative value. Returns
--   <a>True</a> if the function was executed successfully. It returns
--   <a>False</a> if the list of events is empty, or if events specified in
--   event_list do not belong to the same context, or if event objects
--   specified in event_list are not valid event objects.
clWaitForEvents :: [CLEvent] -> IO Bool

-- | Increments the event reference count. The OpenCL commands that return
--   an event perform an implicit retain. Returns <a>True</a> if the
--   function is executed successfully. It returns <a>False</a> if event is
--   not a valid event object.
clRetainEvent :: CLEvent -> IO Bool

-- | Decrements the event reference count. Decrements the event reference
--   count. The event object is deleted once the reference count becomes
--   zero, the specific command identified by this event has completed (or
--   terminated) and there are no commands in the command-queues of a
--   context that require a wait for this event to complete. Returns
--   <a>True</a> if the function is executed successfully. It returns
--   <a>False</a> if event is not a valid event object.
clReleaseEvent :: CLEvent -> IO Bool

-- | Return the command-queue associated with event.
--   
--   This function execute OpenCL clGetEventInfo with
--   <a>CL_EVENT_COMMAND_QUEUE</a>.
clGetEventCommandQueue :: CLEvent -> IO CLCommandQueue

-- | Return the command associated with event.
--   
--   This function execute OpenCL clGetEventInfo with
--   <a>CL_EVENT_COMMAND_TYPE</a>.
clGetEventCommandType :: CLEvent -> IO CLCommandType

-- | Return the event reference count. The reference count returned should
--   be considered immediately stale. It is unsuitable for general use in
--   applications. This feature is provided for identifying memory leaks.
--   
--   This function execute OpenCL clGetEventInfo with
--   <a>CL_EVENT_REFERENCE_COUNT</a>.
clGetEventReferenceCount :: CLEvent -> IO CLint

-- | Return the execution status of the command identified by event.
--   
--   This function execute OpenCL clGetEventInfo with
--   <a>CL_EVENT_COMMAND_EXECUTION_STATUS</a>.
clGetEventCommandExecutionStatus :: CLEvent -> IO CLCommandExecutionStatus

-- | Returns profiling information for the command associated with event if
--   profiling is enabled. The unsigned 64-bit values returned can be used
--   to measure the time in nano-seconds consumed by OpenCL commands.
--   
--   OpenCL devices are required to correctly track time across changes in
--   device frequency and power states. The
--   <tt>CL_DEVICE_PROFILING_TIMER_RESOLUTION</tt> specifies the resolution
--   of the timer i.e. the number of nanoseconds elapsed before the timer
--   is incremented.
--   
--   Event objects can be used to capture profiling information that
--   measure execution time of a command. Profiling of OpenCL commands can
--   be enabled either by using a command-queue created with
--   <tt>CL_QUEUE_PROFILING_ENABLE</tt> flag set in properties argument to
--   clCreateCommandQueue or by setting the
--   <tt>CL_QUEUE_PROFILING_ENABLE</tt> flag in properties argument to
--   <tt>clSetCommandQueueProperty</tt>.
--   
--   <a>clGetEventProfilingInfo</a> returns the valueif the function is
--   executed successfully and the profiling information has been recorded,
--   and returns <a>Nothing</a> if the <tt>CL_QUEUE_PROFILING_ENABLE</tt>
--   flag is not set for the command-queue and if the profiling information
--   is currently not available (because the command identified by event
--   has not completed), or if event is a not a valid event object.
clGetEventProfilingInfo :: CLEvent -> CLProfilingInfo -> IO CLulong
instance Enum CLEventInfo

module Control.Parallel.OpenCL.Memory
type CLMem = Ptr ()
type CLSampler = Ptr ()

-- | <ul>
--   <li><a>CL_MEM_READ_WRITE</a>, This flag specifies that the memory
--   object will be read and written by a kernel. This is the default.</li>
--   <li><a>CL_MEM_WRITE_ONLY</a>, This flags specifies that the memory
--   object will be written but not read by a kernel. Reading from a buffer
--   or image object created with <tt>CLMEM_WRITE_ONLY</tt> inside a kernel
--   is undefined.</li>
--   <li><a>CL_MEM_READ_ONLY</a>, This flag specifies that the memory
--   object is a read-only memory object when used inside a kernel. Writing
--   to a buffer or image object created with <tt>CLMEM_READ_ONLY</tt>
--   inside a kernel is undefined.</li>
--   <li><a>CL_MEM_USE_HOST_PTR</a>, This flag is valid only if host_ptr is
--   not NULL. If specified, it indicates that the application wants the
--   OpenCL implementation to use memory referenced by host_ptr as the
--   storage bits for the memory object. OpenCL implementations are allowed
--   to cache the buffer contents pointed to by host_ptr in device memory.
--   This cached copy can be used when kernels are executed on a device.
--   The result of OpenCL commands that operate on multiple buffer objects
--   created with the same host_ptr or overlapping host regions is
--   considered to be undefined.</li>
--   <li><a>CL_MEM_ALLOC_HOST_PTR</a>, This flag specifies that the
--   application wants the OpenCL implementation to allocate memory from
--   host accessible memory. <a>CL_MEM_ALLOC_HOST_PTR</a> and
--   <a>CL_MEM_USE_HOST_PTR</a> are mutually exclusive.</li>
--   <li><a>CL_MEM_COPY_HOST_PTR</a>, This flag is valid only if host_ptr
--   is not NULL. If specified, it indicates that the application wants the
--   OpenCL implementation to allocate memory for the memory object and
--   copy the data from memory referenced by host_ptr.
--   <a>CL_MEM_COPY_HOST_PTR</a> and <a>CL_MEM_USE_HOST_PTR</a> are
--   mutually exclusive. <a>CL_MEM_COPY_HOST_PTR</a> can be used with
--   <a>CL_MEM_ALLOC_HOST_PTR</a> to initialize the contents of the cl_mem
--   object allocated using host-accessible (e.g. PCIe) memory.</li>
--   </ul>
data CLMemFlag
CL_MEM_READ_WRITE :: CLMemFlag
CL_MEM_WRITE_ONLY :: CLMemFlag
CL_MEM_READ_ONLY :: CLMemFlag
CL_MEM_USE_HOST_PTR :: CLMemFlag
CL_MEM_ALLOC_HOST_PTR :: CLMemFlag
CL_MEM_COPY_HOST_PTR :: CLMemFlag

-- | <ul>
--   <li><a>CL_MEM_OBJECT_BUFFER</a> if memobj is created with
--   <tt>clCreateBuffer</tt>.</li>
--   <li><a>CL_MEM_OBJECT_IMAGE2D</a> if memobj is created with
--   <tt>clCreateImage2D</tt></li>
--   <li><a>CL_MEM_OBJECT_IMAGE3D</a> if memobj is created with
--   <tt>clCreateImage3D</tt>.</li>
--   </ul>
data CLMemObjectType
CL_MEM_OBJECT_BUFFER :: CLMemObjectType
CL_MEM_OBJECT_IMAGE2D :: CLMemObjectType
CL_MEM_OBJECT_IMAGE3D :: CLMemObjectType
data CLAddressingMode
CL_ADDRESS_REPEAT :: CLAddressingMode
CL_ADDRESS_CLAMP_TO_EDGE :: CLAddressingMode
CL_ADDRESS_CLAMP :: CLAddressingMode
CL_ADDRESS_NONE :: CLAddressingMode
data CLFilterMode
CL_FILTER_NEAREST :: CLFilterMode
CL_FILTER_LINEAR :: CLFilterMode
data CLImageFormat
CLImageFormat :: !CLChannelOrder -> !CLChannelType -> CLImageFormat
image_channel_order :: CLImageFormat -> !CLChannelOrder
image_channel_data_type :: CLImageFormat -> !CLChannelType

-- | Specifies the number of channels and the channel layout i.e. the
--   memory layout in which channels are stored in the image. Valid values
--   are described in the table below.
--   
--   <ul>
--   <li><a>CL_R</a>, <a>CL_A</a>.</li>
--   <li><a>CL_INTENSITY</a>, This format can only be used if channel data
--   type = <a>CL_UNORM_INT8</a>, <a>CL_UNORM_INT16</a>,
--   <a>CL_SNORM_INT8</a>, <a>CL_SNORM_INT16</a>, <a>CL_HALF_FLOAT</a>, or
--   <a>CL_FLOAT</a>.</li>
--   <li><a>CL_LUMINANCE</a>, This format can only be used if channel data
--   type = <a>CL_UNORM_INT8</a>, <a>CL_UNORM_INT16</a>,
--   <a>CL_SNORM_INT8</a>, <a>CL_SNORM_INT16</a>, <a>CL_HALF_FLOAT</a>, or
--   <a>CL_FLOAT</a>.</li>
--   <li><a>CL_RG</a>, <a>CL_RA</a>.</li>
--   <li><a>CL_RGB</a>, This format can only be used if channel data type =
--   <a>CL_UNORM_SHORT_565</a>, <a>CL_UNORM_SHORT_555</a> or
--   <tt>CL_UNORM_INT101010</tt>.</li>
--   <li><a>CL_RGBA</a>.</li>
--   <li><a>CL_ARGB</a>, <a>CL_BGRA</a>. This format can only be used if
--   channel data type = <a>CL_UNORM_INT8</a>, <a>CL_SNORM_INT8</a>,
--   <a>CL_SIGNED_INT8</a> or <a>CL_UNSIGNED_INT8</a>.</li>
--   </ul>
data CLChannelOrder
CL_R :: CLChannelOrder
CL_A :: CLChannelOrder
CL_INTENSITY :: CLChannelOrder
CL_LUMINANCE :: CLChannelOrder
CL_RG :: CLChannelOrder
CL_RA :: CLChannelOrder
CL_RGB :: CLChannelOrder
CL_RGBA :: CLChannelOrder
CL_ARGB :: CLChannelOrder
CL_BGRA :: CLChannelOrder

-- | Describes the size of the channel data type. The number of bits per
--   element determined by the image_channel_data_type and
--   image_channel_order must be a power of two. The list of supported
--   values is described in the table below.
--   
--   <ul>
--   <li><a>CL_SNORM_INT8</a>, Each channel component is a normalized
--   signed 8-bit integer value.</li>
--   <li><a>CL_SNORM_INT16</a>, Each channel component is a normalized
--   signed 16-bit integer value.</li>
--   <li><a>CL_UNORM_INT8</a>, Each channel component is a normalized
--   unsigned 8-bit integer value.</li>
--   <li><a>CL_UNORM_INT16</a>, Each channel component is a normalized
--   unsigned 16-bit integer value.</li>
--   <li><a>CL_UNORM_SHORT_565</a>, Represents a normalized 5-6-5 3-channel
--   RGB image. The channel order must be <a>CL_RGB</a>.</li>
--   <li><a>CL_UNORM_SHORT_555</a>, Represents a normalized x-5-5-5
--   4-channel xRGB image. The channel order must be <a>CL_RGB</a>.</li>
--   <li><a>CL_UNORM_INT_101010</a>, Represents a normalized x-10-10-10
--   4-channel xRGB image. The channel order must be <a>CL_RGB</a>.</li>
--   <li><a>CL_SIGNED_INT8</a>, Each channel component is an unnormalized
--   signed 8-bit integer value.</li>
--   <li><a>CL_SIGNED_INT16</a>, Each channel component is an unnormalized
--   signed 16-bit integer value.</li>
--   <li><a>CL_SIGNED_INT32</a>, Each channel component is an unnormalized
--   signed 32-bit integer value.</li>
--   <li><a>CL_UNSIGNED_INT8</a>, Each channel component is an unnormalized
--   unsigned 8-bit integer value.</li>
--   <li><a>CL_UNSIGNED_INT16</a>, Each channel component is an
--   unnormalized unsigned 16-bit integer value.</li>
--   <li><a>CL_UNSIGNED_INT32</a>, Each channel component is an
--   unnormalized unsigned 32-bit integer value.</li>
--   <li><a>CL_HALF_FLOAT</a>, Each channel component is a 16-bit
--   half-float value.</li>
--   <li><a>CL_FLOAT</a>, Each channel component is a single precision
--   floating-point value.</li>
--   </ul>
data CLChannelType
CL_SNORM_INT8 :: CLChannelType
CL_SNORM_INT16 :: CLChannelType
CL_UNORM_INT8 :: CLChannelType
CL_UNORM_INT16 :: CLChannelType
CL_UNORM_SHORT_565 :: CLChannelType
CL_UNORM_SHORT_555 :: CLChannelType
CL_UNORM_INT_101010 :: CLChannelType
CL_SIGNED_INT8 :: CLChannelType
CL_SIGNED_INT16 :: CLChannelType
CL_SIGNED_INT32 :: CLChannelType
CL_UNSIGNED_INT8 :: CLChannelType
CL_UNSIGNED_INT16 :: CLChannelType
CL_UNSIGNED_INT32 :: CLChannelType
CL_HALF_FLOAT :: CLChannelType
CL_FLOAT :: CLChannelType

-- | Creates a buffer object. Returns a valid non-zero buffer object if the
--   buffer object is created successfully. Otherwise, it throws the
--   <tt>CLError</tt>:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if values specified in flags are not
--   valid.</li>
--   <li><tt>CL_INVALID_BUFFER_SIZE</tt> if size is 0 or is greater than
--   <tt>clDeviceMaxMemAllocSize</tt> value for all devices in
--   context.</li>
--   <li><tt>CL_INVALID_HOST_PTR</tt> if host_ptr is NULL and
--   <a>CL_MEM_USE_HOST_PTR</a> or <a>CL_MEM_COPY_HOST_PTR</a> are set in
--   flags or if host_ptr is not NULL but <a>CL_MEM_COPY_HOST_PTR</a> or
--   <a>CL_MEM_USE_HOST_PTR</a> are not set in flags.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for buffer object.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateBuffer :: Integral a => CLContext -> [CLMemFlag] -> (a, Ptr ()) -> IO CLMem

-- | Increments the memory object reference count. returns <a>True</a> if
--   the function is executed successfully. After the memobj reference
--   count becomes zero and commands queued for execution on a
--   command-queue(s) that use memobj have finished, the memory object is
--   deleted. It returns <a>False</a> if memobj is not a valid memory
--   object.
clRetainMemObject :: CLMem -> IO Bool

-- | Decrements the memory object reference count. After the memobj
--   reference count becomes zero and commands queued for execution on a
--   command-queue(s) that use memobj have finished, the memory object is
--   deleted. Returns <a>True</a> if the function is executed successfully.
--   It returns <a>False</a> if memobj is not a valid memory object.
clReleaseMemObject :: CLMem -> IO Bool

-- | Returns the mem object type.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_TYPE</a>.
clGetMemType :: CLMem -> IO CLMemObjectType

-- | Return the flags argument value specified when memobj was created.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_FLAGS</a>.
clGetMemFlags :: CLMem -> IO [CLMemFlag]

-- | Return actual size of memobj in bytes.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_SIZE</a>.
clGetMemSize :: CLMem -> IO CSize

-- | Return the host_ptr argument value specified when memobj is created.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_HOST_PTR</a>.
clGetMemHostPtr :: CLMem -> IO (Ptr ())

-- | Map count. The map count returned should be considered immediately
--   stale. It is unsuitable for general use in applications. This feature
--   is provided for debugging.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_MAP_COUNT</a>.
clGetMemMapCount :: CLMem -> IO CLuint

-- | Return memobj reference count. The reference count returned should be
--   considered immediately stale. It is unsuitable for general use in
--   applications. This feature is provided for identifying memory leaks.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_REFERENCE_COUNT</a>.
clGetMemReferenceCount :: CLMem -> IO CLuint

-- | Return context specified when memory object is created.
--   
--   This function execute OpenCL clGetMemObjectInfo with
--   <a>CL_MEM_CONTEXT</a>.
clGetMemContext :: CLMem -> IO CLContext

-- | Creates an OpenCL buffer object from an OpenGL buffer object. Returns
--   a valid non-zero OpenCL buffer object if the buffer object is created
--   successfully. Otherwise it throws the <tt>CLError</tt>: *
--   <tt>CL_INVALID_CONTEXT</tt> if context is not a valid context or was
--   not created from a GL context.
--   
--   <ul>
--   <li><tt>CL_INVALID_VALUE</tt> if values specified in flags are not
--   valid.</li>
--   <li><tt>CL_INVALID_GL_OBJECT</tt> if bufobj is not a GL buffer object
--   or is a GL buffer object but does not have an existing data
--   store.</li>
--   <li><tt>CL_OUT_OF_RESOURCES</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the device.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateFromGLBuffer :: Integral a => CLContext -> [CLMemFlag] -> a -> IO CLMem

-- | Creates a 2D image object.
--   
--   <a>clCreateImage2D</a> returns a valid non-zero image object created
--   if the image object is created successfully. Otherwise, it throws one
--   of the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if values specified in flags are not
--   valid.</li>
--   <li><tt>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</tt> if values specified in
--   image_format are not valid.</li>
--   <li><tt>CL_INVALID_IMAGE_SIZE</tt> if image_width or image_height are
--   0 or if they exceed values specified in
--   <tt>CL_DEVICE_IMAGE2D_MAX_WIDTH</tt> or
--   <tt>CL_DEVICE_IMAGE2D_MAX_HEIGHT</tt> respectively for all devices in
--   context or if values specified by image_row_pitch do not follow rules
--   described in the argument description above.</li>
--   <li><tt>CL_INVALID_HOST_PTR</tt> if host_ptr is <a>nullPtr</a> and
--   <a>CL_MEM_USE_HOST_PTR</a> or <a>CL_MEM_COPY_HOST_PTR</a> are set in
--   flags or if host_ptr is not <a>nullPtr</a> but
--   <a>CL_MEM_COPY_HOST_PTR</a> or <a>CL_MEM_USE_HOST_PTR</a> are not set
--   in flags.</li>
--   <li><tt>CL_IMAGE_FORMAT_NOT_SUPPORTED</tt> if the image_format is not
--   supported.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for image object.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if there are no devices in context
--   that support images (i.e. <tt>CL_DEVICE_IMAGE_SUPPORT</tt> (specified
--   in the table of OpenCL Device Queries for <tt>clGetDeviceInfo</tt>) is
--   <a>False</a>).</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateImage2D :: Integral a => CLContext -> [CLMemFlag] -> CLImageFormat -> a -> a -> a -> Ptr () -> IO CLMem

-- | Creates a 3D image object.
--   
--   <a>clCreateImage3D</a> returns a valid non-zero image object created
--   if the image object is created successfully. Otherwise, it throws one
--   of the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if values specified in flags are not
--   valid.</li>
--   <li><tt>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</tt> if values specified in
--   image_format are not valid.</li>
--   <li><tt>CL_INVALID_IMAGE_SIZE</tt> if image_width, image_height are 0
--   or if image_depth less than or equal to 1 or if they exceed values
--   specified in <tt>CL_DEVICE_IMAGE3D_MAX_WIDTH</tt>,
--   CL_DEVICE_IMAGE3D_MAX_HEIGHT' or <tt>CL_DEVICE_IMAGE3D_MAX_DEPTH</tt>
--   respectively for all devices in context or if values specified by
--   image_row_pitch and image_slice_pitch do not follow rules described in
--   the argument description above.</li>
--   <li><tt>CL_INVALID_HOST_PTR</tt> if host_ptr is <a>nullPtr</a> and
--   <a>CL_MEM_USE_HOST_PTR</a> or <a>CL_MEM_COPY_HOST_PTR</a> are set in
--   flags or if host_ptr is not <a>nullPtr</a> but
--   <a>CL_MEM_COPY_HOST_PTR</a> or <a>CL_MEM_USE_HOST_PTR</a> are not set
--   in flags.</li>
--   <li><tt>CL_IMAGE_FORMAT_NOT_SUPPORTED</tt> if the image_format is not
--   supported.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for image object.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if there are no devices in context
--   that support images (i.e. <tt>CL_DEVICE_IMAGE_SUPPORT</tt> (specified
--   in the table of OpenCL Device Queries for clGetDeviceInfo) is
--   <a>False</a>).</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateImage3D :: Integral a => CLContext -> [CLMemFlag] -> CLImageFormat -> a -> a -> a -> a -> a -> Ptr () -> IO CLMem

-- | Creates a 2D OpenCL image object from an existing OpenGL texture.
--   
--   <a>clCreateFromGLTexture2D</a> returns a non-zero image object if the
--   image object is created successfully. Otherwise, it throws one of the
--   following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid context or
--   was not created from a GL context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if values specified in flags are not
--   valid or if value specified in texture_target is not one of the values
--   specified in the description of texture_target.</li>
--   <li><tt>CL_INVALID_MIPLEVEL</tt> if miplevel is less than the value of
--   levelbase (for OpenGL implementations) or zero (for OpenGL ES
--   implementations); or greater than the value of q (for both OpenGL and
--   OpenGL ES). levelbase and q are defined for the texture in section
--   3.8.10 (Texture Completeness) of the OpenGL 2.1 specification and
--   section 3.7.10 of the OpenGL ES 2.0 specification.</li>
--   <li><tt>CL_INVALID_MIPLEVEL</tt> if miplevel is greater than zero and
--   the OpenGL implementation does not support creating from non-zero
--   mipmap levels.</li>
--   <li><tt>CL_INVALID_GL_OBJECT</tt> if texture is not a GL texture
--   object whose type matches texture_target, if the specified miplevel of
--   texture is not defined, or if the width or height of the specified
--   miplevel is zero.</li>
--   <li><tt>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</tt> if the OpenGL texture
--   internal format does not map to a supported OpenCL image format.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateFromGLTexture2D :: (Integral a, Integral b, Integral c) => CLContext -> [CLMemFlag] -> a -> b -> c -> IO CLMem

-- | Get the list of image formats supported by an OpenCL implementation.
--   <a>clGetSupportedImageFormats</a> can be used to get the list of image
--   formats supported by an OpenCL implementation when the following
--   information about an image memory object is specified:
--   
--   <ul>
--   <li>Context * Image type - 2D or 3D image * Image object allocation
--   information</li>
--   </ul>
--   
--   Throws <tt>CL_INVALID_CONTEXT</tt> if context is not a valid context,
--   throws <tt>CL_INVALID_VALUE</tt> if flags or image_type are not valid.
clGetSupportedImageFormats :: CLContext -> [CLMemFlag] -> CLMemObjectType -> IO [CLImageFormat]

-- | Return image format descriptor specified when image is created with
--   clCreateImage2D or clCreateImage3D.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_FORMAT</a>.
clGetImageFormat :: CLMem -> IO CLImageFormat

-- | Return size of each element of the image memory object given by image.
--   An element is made up of n channels. The value of n is given in
--   <a>CLImageFormat</a> descriptor.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_ELEMENT_SIZE</a>.
clGetImageElementSize :: CLMem -> IO CSize

-- | Return size in bytes of a row of elements of the image object given by
--   image.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_ROW_PITCH</a>.
clGetImageRowPitch :: CLMem -> IO CSize

-- | Return size in bytes of a 2D slice for the 3D image object given by
--   image. For a 2D image object this value will be 0.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_SLICE_PITCH</a>.
clGetImageSlicePitch :: CLMem -> IO CSize

-- | Return width of image in pixels.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_WIDTH</a>.
clGetImageWidth :: CLMem -> IO CSize

-- | Return height of image in pixels.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_HEIGHT</a>.
clGetImageHeight :: CLMem -> IO CSize

-- | Return depth of the image in pixels. For a 2D image, depth equals 0.
--   
--   This function execute OpenCL clGetImageInfo with
--   <a>CL_IMAGE_DEPTH</a>.
clGetImageDepth :: CLMem -> IO CSize

-- | Creates a sampler object. A sampler object describes how to sample an
--   image when the image is read in the kernel. The built-in functions to
--   read from an image in a kernel take a sampler as an argument. The
--   sampler arguments to the image read function can be sampler objects
--   created using OpenCL functions and passed as argument values to the
--   kernel or can be samplers declared inside a kernel. In this section we
--   discuss how sampler objects are created using OpenCL functions.
--   
--   Returns a valid non-zero sampler object if the sampler object is
--   created successfully. Otherwise, it throws one of the following
--   <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context is not a valid
--   context.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if addressing_mode, filter_mode, or
--   normalized_coords or a combination of these argument values are not
--   valid.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if images are not supported by any
--   device associated with context (i.e. <tt>CL_DEVICE_IMAGE_SUPPORT</tt>
--   specified in the table of OpenCL Device Queries for clGetDeviceInfo is
--   <a>False</a>).</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clCreateSampler :: CLContext -> Bool -> CLAddressingMode -> CLFilterMode -> IO CLSampler

-- | Increments the sampler reference count. <a>clCreateSampler</a> does an
--   implicit retain. Returns <a>True</a> if the function is executed
--   successfully. It returns <a>False</a> if sampler is not a valid
--   sampler object.
clRetainSampler :: CLSampler -> IO Bool

-- | Decrements the sampler reference count. The sampler object is deleted
--   after the reference count becomes zero and commands queued for
--   execution on a command-queue(s) that use sampler have finished.
--   <a>clReleaseSampler</a> returns <a>True</a> if the function is
--   executed successfully. It returns <a>False</a> if sampler is not a
--   valid sampler object.
clReleaseSampler :: CLSampler -> IO Bool

-- | Return the sampler reference count. The reference count returned
--   should be considered immediately stale. It is unsuitable for general
--   use in applications. This feature is provided for identifying memory
--   leaks.
--   
--   This function execute OpenCL clGetSamplerInfo with
--   <a>CL_SAMPLER_REFERENCE_COUNT</a>.
clGetSamplerReferenceCount :: CLSampler -> IO CLuint

-- | Return the context specified when the sampler is created.
--   
--   This function execute OpenCL clGetSamplerInfo with
--   <a>CL_SAMPLER_CONTEXT</a>.
clGetSamplerContext :: CLSampler -> IO CLContext

-- | Return the value specified by addressing_mode argument to
--   clCreateSampler.
--   
--   This function execute OpenCL clGetSamplerInfo with
--   <a>CL_SAMPLER_ADDRESSING_MODE</a>.
clGetSamplerAddressingMode :: CLSampler -> IO CLAddressingMode

-- | Return the value specified by filter_mode argument to clCreateSampler.
--   
--   This function execute OpenCL clGetSamplerInfo with
--   <a>CL_SAMPLER_FILTER_MODE</a>.
clGetSamplerFilterMode :: CLSampler -> IO CLFilterMode

-- | Return the value specified by normalized_coords argument to
--   clCreateSampler.
--   
--   This function execute OpenCL clGetSamplerInfo with
--   <a>CL_SAMPLER_NORMALIZED_COORDS</a>.
clGetSamplerNormalizedCoords :: CLSampler -> IO Bool
instance Show CLChannelOrder
instance Show CLChannelType
instance Show CLImageFormat
instance Enum CLSamplerInfo
instance Enum CLMemInfo
instance Enum CLImageInfo
instance Storable CLImageFormat
instance Enum CLChannelType
instance Enum CLChannelOrder

module Control.Parallel.OpenCL.CommandQueue
type CLCommandQueue = Ptr ()

-- | <ul>
--   <li><a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a>, Determines whether
--   the commands queued in the command-queue are executed in-order or
--   out-of-order. If set, the commands in the command-queue are executed
--   out-of-order. Otherwise, commands are executed in-order.</li>
--   <li><a>CL_QUEUE_PROFILING_ENABLE</a>, Enable or disable profiling of
--   commands in the command-queue. If set, the profiling of commands is
--   enabled. Otherwise profiling of commands is disabled. See
--   <tt>clGetEventProfilingInfo</tt> for more information.</li>
--   </ul>
data CLCommandQueueProperty
CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE :: CLCommandQueueProperty
CL_QUEUE_PROFILING_ENABLE :: CLCommandQueueProperty
data CLMapFlag
CL_MAP_READ :: CLMapFlag
CL_MAP_WRITE :: CLMapFlag

-- | Create a command-queue on a specific device.
--   
--   The OpenCL functions that are submitted to a command-queue are
--   enqueued in the order the calls are made but can be configured to
--   execute in-order or out-of-order. The properties argument in
--   clCreateCommandQueue can be used to specify the execution order.
--   
--   If the <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> property of a
--   command-queue is not set, the commands enqueued to a command-queue
--   execute in order. For example, if an application calls
--   <a>clEnqueueNDRangeKernel</a> to execute kernel A followed by a
--   <a>clEnqueueNDRangeKernel</a> to execute kernel B, the application can
--   assume that kernel A finishes first and then kernel B is executed. If
--   the memory objects output by kernel A are inputs to kernel B then
--   kernel B will see the correct data in memory objects produced by
--   execution of kernel A. If the
--   <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> property of a
--   commandqueue is set, then there is no guarantee that kernel A will
--   finish before kernel B starts execution.
--   
--   Applications can configure the commands enqueued to a command-queue to
--   execute out-of-order by setting the
--   <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> property of the
--   command-queue. This can be specified when the command-queue is created
--   or can be changed dynamically using <a>clCreateCommandQueue</a>. In
--   out-of-order execution mode there is no guarantee that the enqueued
--   commands will finish execution in the order they were queued. As there
--   is no guarantee that kernels will be executed in order, i.e. based on
--   when the <a>clEnqueueNDRangeKernel</a> calls are made within a
--   command-queue, it is therefore possible that an earlier
--   <a>clEnqueueNDRangeKernel</a> call to execute kernel A identified by
--   event A may execute and/or finish later than a
--   <a>clEnqueueNDRangeKernel</a> call to execute kernel B which was
--   called by the application at a later point in time. To guarantee a
--   specific order of execution of kernels, a wait on a particular event
--   (in this case event A) can be used. The wait for event A can be
--   specified in the event_wait_list argument to
--   <a>clEnqueueNDRangeKernel</a> for kernel B.
--   
--   In addition, a wait for events or a barrier command can be enqueued to
--   the command-queue. The wait for events command ensures that previously
--   enqueued commands identified by the list of events to wait for have
--   finished before the next batch of commands is executed. The barrier
--   command ensures that all previously enqueued commands in a
--   command-queue have finished execution before the next batch of
--   commands is executed.
--   
--   Similarly, commands to read, write, copy or map memory objects that
--   are enqueued after <a>clEnqueueNDRangeKernel</a>, <a>clEnqueueTask</a>
--   or <a>clEnqueueNativeKernel</a> commands are not guaranteed to wait
--   for kernels scheduled for execution to have completed (if the
--   <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> property is set). To
--   ensure correct ordering of commands, the event object returned by
--   <a>clEnqueueNDRangeKernel</a>, <a>clEnqueueTask</a> or
--   <a>clEnqueueNativeKernel</a> can be used to enqueue a wait for event
--   or a barrier command can be enqueued that must complete before reads
--   or writes to the memory object(s) occur.
clCreateCommandQueue :: CLContext -> CLDeviceID -> [CLCommandQueueProperty] -> IO CLCommandQueue

-- | Increments the command_queue reference count.
--   <a>clCreateCommandQueue</a> performs an implicit retain. This is very
--   helpful for 3rd party libraries, which typically get a command-queue
--   passed to them by the application. However, it is possible that the
--   application may delete the command-queue without informing the
--   library. Allowing functions to attach to (i.e. retain) and release a
--   command-queue solves the problem of a command-queue being used by a
--   library no longer being valid. Returns <a>True</a> if the function is
--   executed successfully. It returns <a>False</a> if command_queue is not
--   a valid command-queue.
clRetainCommandQueue :: CLCommandQueue -> IO Bool

-- | Decrements the command_queue reference count. After the command_queue
--   reference count becomes zero and all commands queued to command_queue
--   have finished (e.g., kernel executions, memory object updates, etc.),
--   the command-queue is deleted. Returns <a>True</a> if the function is
--   executed successfully. It returns <a>False</a> if command_queue is not
--   a valid command-queue.
clReleaseCommandQueue :: CLCommandQueue -> IO Bool

-- | Return the context specified when the command-queue is created.
--   
--   This function execute OpenCL clGetCommandQueueInfo with
--   <a>CL_QUEUE_CONTEXT</a>.
clGetCommandQueueContext :: CLCommandQueue -> IO CLContext

-- | Return the device specified when the command-queue is created.
--   
--   This function execute OpenCL clGetCommandQueueInfo with
--   <a>CL_QUEUE_DEVICE</a>.
clGetCommandQueueDevice :: CLCommandQueue -> IO CLDeviceID

-- | Return the command-queue reference count. The reference count returned
--   should be considered immediately stale. It is unsuitable for general
--   use in applications. This feature is provided for identifying memory
--   leaks.
--   
--   This function execute OpenCL clGetCommandQueueInfo with
--   <a>CL_QUEUE_REFERENCE_COUNT</a>.
clGetCommandQueueReferenceCount :: CLCommandQueue -> IO CLuint

-- | Return the currently specified properties for the command-queue. These
--   properties are specified by the properties argument in
--   <a>clCreateCommandQueue</a> , and can be changed by
--   <a>clSetCommandQueueProperty</a>.
--   
--   This function execute OpenCL clGetCommandQueueInfo with
--   <a>CL_QUEUE_PROPERTIES</a>.
clGetCommandQueueProperties :: CLCommandQueue -> IO [CLCommandQueueProperty]

-- | Enable or disable the properties of a command-queue. Returns the
--   command-queue properties before they were changed by
--   <a>clSetCommandQueueProperty</a>. As specified for
--   <a>clCreateCommandQueue</a>, the
--   <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> command-queue property
--   determines whether the commands in a command-queue are executed
--   in-order or out-of-order. Changing this command-queue property will
--   cause the OpenCL implementation to block until all previously queued
--   commands in command_queue have completed. This can be an expensive
--   operation and therefore changes to the
--   <a>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</a> property should be only
--   done when absolutely necessary.
--   
--   It is possible that a device(s) becomes unavailable after a context
--   and command-queues that use this device(s) have been created and
--   commands have been queued to command-queues. In this case the behavior
--   of OpenCL API calls that use this context (and command-queues) are
--   considered to be implementation-defined. The user callback function,
--   if specified when the context is created, can be used to record
--   appropriate information when the device becomes unavailable.
clSetCommandQueueProperty :: CLCommandQueue -> [CLCommandQueueProperty] -> Bool -> IO [CLCommandQueueProperty]

-- | Enqueue commands to read from a buffer object to host memory. Calling
--   clEnqueueReadBuffer to read a region of the buffer object with the ptr
--   argument value set to host_ptr + offset, where host_ptr is a pointer
--   to the memory region specified when the buffer object being read is
--   created with <tt>CL_MEM_USE_HOST_PTR</tt>, must meet the following
--   requirements in order to avoid undefined behavior:
--   
--   <ul>
--   <li>All commands that use this buffer object have finished execution
--   before the read command begins execution</li>
--   <li>The buffer object is not mapped</li>
--   <li>The buffer object is not used by any command-queue until the read
--   command has finished execution Errors</li>
--   </ul>
--   
--   <a>clEnqueueReadBuffer</a> returns the event if the function is
--   executed successfully. It can throw the following <tt>CLError</tt>
--   exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and buffer are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if buffer is not a valid buffer
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the region being read specified by
--   (offset, cb) is out of bounds or if ptr is a NULL value.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event_wait_list is NULL and
--   num_events_in_wait_list greater than 0, or event_wait_list is not NULL
--   and num_events_in_wait_list is 0, or if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with buffer.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueReadBuffer :: Integral a => CLCommandQueue -> CLMem -> Bool -> a -> a -> Ptr () -> [CLEvent] -> IO CLEvent

-- | Enqueue commands to write to a buffer object from host memory.Calling
--   clEnqueueWriteBuffer to update the latest bits in a region of the
--   buffer object with the ptr argument value set to host_ptr + offset,
--   where host_ptr is a pointer to the memory region specified when the
--   buffer object being written is created with
--   <tt>CL_MEM_USE_HOST_PTR</tt>, must meet the following requirements in
--   order to avoid undefined behavior:
--   
--   <ul>
--   <li>The host memory region given by (host_ptr + offset, cb) contains
--   the latest bits when the enqueued write command begins execution.</li>
--   <li>The buffer object is not mapped.</li>
--   <li>The buffer object is not used by any command-queue until the write
--   command has finished execution.</li>
--   </ul>
--   
--   <a>clEnqueueWriteBuffer</a> returns the Event if the function is
--   executed successfully. It can throw the following <tt>CLError</tt>
--   exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and buffer are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if buffer is not a valid buffer
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the region being written specified by
--   (offset, cb) is out of bounds or if ptr is a NULL value.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event_wait_list is NULL and
--   num_events_in_wait_list greater than 0, or event_wait_list is not NULL
--   and num_events_in_wait_list is 0, or if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with buffer.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueWriteBuffer :: Integral a => CLCommandQueue -> CLMem -> Bool -> a -> a -> Ptr () -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to read from a 2D or 3D image object to host
--   memory.
--   
--   Returns an event object that identifies this particular read command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete.
--   
--   Notes
--   
--   If blocking is <a>True</a> i.e. the read command is blocking,
--   <a>clEnqueueReadImage</a> does not return until the buffer data has
--   been read and copied into memory pointed to by ptr.
--   
--   If blocking_read is <a>False</a> i.e. map operation is non-blocking,
--   <a>clEnqueueReadImage</a> queues a non-blocking read command and
--   returns. The contents of the buffer that ptr points to cannot be used
--   until the read command has completed. The event argument returns an
--   event object which can be used to query the execution status of the
--   read command. When the read command has completed, the contents of the
--   buffer that ptr points to can be used by the application.
--   
--   Calling <a>clEnqueueReadImage</a> to read a region of the image object
--   with the ptr argument value set to host_ptr + (origin.z * image slice
--   pitch + origin.y * image row pitch + origin.x * bytes per pixel),
--   where host_ptr is a pointer to the memory region specified when the
--   image object being read is created with <tt>CL_MEM_USE_HOST_PTR</tt>,
--   must meet the following requirements in order to avoid undefined
--   behavior:
--   
--   <ul>
--   <li>All commands that use this image object have finished execution
--   before the read command begins execution.</li>
--   <li>The row_pitch and slice_pitch argument values in
--   clEnqueueReadImage must be set to the image row pitch and slice
--   pitch.</li>
--   <li>The image object is not mapped.</li>
--   <li>The image object is not used by any command-queue until the read
--   command has finished execution.</li>
--   </ul>
--   
--   <a>clEnqueueReadImage</a> returns the <a>CLEvent</a> if the function
--   is executed successfully. It can throw the following <tt>CLError</tt>
--   exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and image are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if image is not a valid image
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the region being read specified by
--   origin and region is out of bounds or if ptr is a nullPtr value.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if image is a 2D image object and z is
--   not equal to 0 or depth is not equal to 1 or slice_pitch is not equal
--   to 0.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with image.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueReadImage :: Integral a => CLCommandQueue -> CLMem -> Bool -> (a, a, a) -> (a, a, a) -> a -> a -> Ptr () -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to write from a 2D or 3D image object to host
--   memory.
--   
--   Returns an event object that identifies this particular write command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete.
--   
--   Notes
--   
--   If blocking_write is <a>True</a> the OpenCL implementation copies the
--   data referred to by ptr and enqueues the write command in the
--   command-queue. The memory pointed to by ptr can be reused by the
--   application after the <a>clEnqueueWriteImage</a> call returns.
--   
--   If blocking_write is <a>False</a> the OpenCL implementation will use
--   ptr to perform a nonblocking write. As the write is non-blocking the
--   implementation can return immediately. The memory pointed to by ptr
--   cannot be reused by the application after the call returns. The event
--   argument returns an event object which can be used to query the
--   execution status of the write command. When the write command has
--   completed, the memory pointed to by ptr can then be reused by the
--   application.
--   
--   Calling <a>clEnqueueWriteImage</a> to update the latest bits in a
--   region of the image object with the ptr argument value set to host_ptr
--   + (origin.z * image slice pitch + origin.y * image row pitch +
--   origin.x * bytes per pixel), where host_ptr is a pointer to the memory
--   region specified when the image object being written is created with
--   <tt>CL_MEM_USE_HOST_PTR</tt>, must meet the following requirements in
--   order to avoid undefined behavior:
--   
--   <ul>
--   <li>The host memory region being written contains the latest bits when
--   the enqueued write command begins execution.</li>
--   <li>The input_row_pitch and input_slice_pitch argument values in
--   clEnqueueWriteImage must be set to the image row pitch and slice
--   pitch.</li>
--   <li>The image object is not mapped.</li>
--   <li>The image object is not used by any command-queue until the write
--   command has finished execution.</li>
--   </ul>
--   
--   <a>clEnqueueWriteImage</a> returns the <a>CLEvent</a> if the function
--   is executed successfully. It can throw the following <tt>CLError</tt>
--   exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and image are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if image is not a valid image
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the region being write or written
--   specified by origin and region is out of bounds or if ptr is a NULL
--   value.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if image is a 2D image object and z is
--   not equal to 0 or depth is not equal to 1 or slice_pitch is not equal
--   to 0.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with image.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueWriteImage :: Integral a => CLCommandQueue -> CLMem -> Bool -> (a, a, a) -> (a, a, a) -> a -> a -> Ptr () -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to copy image objects.
--   
--   Notes
--   
--   It is currently a requirement that the src_image and dst_image image
--   memory objects for <a>clEnqueueCopyImage</a> must have the exact same
--   image format (i.e. the <tt>CLImageFormat</tt> descriptor specified
--   when src_image and dst_image are created must match).
--   
--   src_image and dst_image can be 2D or 3D image objects allowing us to
--   perform the following actions:
--   
--   <ul>
--   <li>Copy a 2D image object to a 2D image object.</li>
--   <li>Copy a 2D image object to a 2D slice of a 3D image object.</li>
--   <li>Copy a 2D slice of a 3D image object to a 2D image object.</li>
--   <li>Copy a 3D image object to a 3D image object.</li>
--   </ul>
--   
--   <a>clEnqueueCopyImage</a> returns the <a>CLEvent</a> if the function
--   is executed successfully. It can throw the following <tt>CLError</tt>
--   exceptions:
--   
--   <ul>
--   <li>'CL_INVALID_COMMAND_QUEUE if command_queue is not a valid
--   command-queue.</li>
--   <li>'CL_INVALID_CONTEXT if the context associated with command_queue,
--   src_image and dst_image are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li>'CL_INVALID_MEM_OBJECT if src_image and dst_image are not valid
--   image objects.</li>
--   <li>'CL_IMAGE_FORMAT_MISMATCH if src_image and dst_image do not use
--   the same image format.</li>
--   <li>'CL_INVALID_VALUE if the 2D or 3D rectangular region specified by
--   src_origin and src_origin + region refers to a region outside
--   src_image, or if the 2D or 3D rectangular region specified by
--   dst_origin and dst_origin + region refers to a region outside
--   dst_image.</li>
--   <li>'CL_INVALID_VALUE if src_image is a 2D image object and
--   src_origin.z is not equal to 0 or region.depth is not equal to 1.</li>
--   <li>'CL_INVALID_VALUE if dst_image is a 2D image object and
--   dst_origen.z is not equal to 0 or region.depth is not equal to 1.</li>
--   <li>'CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list
--   are not valid events.</li>
--   <li>'CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to
--   allocate memory for data store associated with src_image or
--   dst_image.</li>
--   <li>'CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources
--   required by the OpenCL implementation on the host.</li>
--   <li>'CL_MEM_COPY_OVERLAP if src_image and dst_image are the same image
--   object and the source and destination regions overlap.</li>
--   </ul>
clEnqueueCopyImage :: Integral a => CLCommandQueue -> CLMem -> CLMem -> (a, a, a) -> (a, a, a) -> (a, a, a) -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to copy an image object to a buffer object.
--   
--   Returns an event object that identifies this particular copy command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete. <a>clEnqueueBarrier</a> can be used
--   instead.
--   
--   <a>clEnqueueCopyImageToBuffer</a> returns the <a>CLEvent</a> if the
--   function is executed successfully. It can throw the following
--   <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li>CL_INVALID_COMMAND_QUEUE if command_queue is not a valid
--   command-queue.</li>
--   <li>CL_INVALID_CONTEXT if the context associated with command_queue,
--   src_image and dst_buffer are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li>CL_INVALID_MEM_OBJECT if src_image is not a valid image object and
--   dst_buffer is not a valid buffer object.</li>
--   <li>CL_INVALID_VALUE if the 2D or 3D rectangular region specified by
--   src_origin and src_origin + region refers to a region outside
--   src_image, or if the region specified by dst_offset and dst_offset +
--   dst_cb refers to a region outside dst_buffer.</li>
--   <li>CL_INVALID_VALUE if src_image is a 2D image object and
--   src_origin.z is not equal to 0 or region.depth is not equal to 1.</li>
--   <li>CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list are
--   not valid events.</li>
--   <li>CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate
--   memory for data store associated with src_image or dst_buffer.</li>
--   <li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources
--   required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueCopyImageToBuffer :: Integral a => CLCommandQueue -> CLMem -> CLMem -> (a, a, a) -> (a, a, a) -> a -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to copy a buffer object to an image object.
--   
--   The size in bytes of the region to be copied from src_buffer referred
--   to as src_cb is computed as width * height * depth * bytes/image
--   element if dst_image is a 3D image object and is computed as width *
--   height * bytes/image element if dst_image is a 2D image object.
--   
--   Returns an event object that identifies this particular copy command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete. <a>clEnqueueBarrier</a> can be used
--   instead.
--   
--   <a>clEnqueueCopyBufferToImage</a> returns the <a>CLEvent</a> if the
--   function is executed successfully. It can throw the following
--   <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue, src_buffer and dst_image are not the same or if the
--   context associated with command_queue and events in event_wait_list
--   are not the same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if src_buffer is not a valid buffer
--   object and dst_image is not a valid image object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if the 2D or 3D rectangular region
--   specified by dst_origin and dst_origin + region refers to a region
--   outside dst_origin, or if the region specified by src_offset and
--   src_offset + src_cb refers to a region outside src_buffer.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if dst_image is a 2D image object and
--   dst_origin.z is not equal to 0 or region.depth is not equal to 1.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with src_buffer or
--   dst_image.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueCopyBufferToImage :: Integral a => CLCommandQueue -> CLMem -> CLMem -> a -> (a, a, a) -> (a, a, a) -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to map a region of the buffer object given by
--   buffer into the host address space and returns a pointer to this
--   mapped region.
--   
--   If blocking_map is <a>True</a>, <a>clEnqueueMapBuffer</a> does not
--   return until the specified region in buffer can be mapped.
--   
--   If blocking_map is <a>False</a> i.e. map operation is non-blocking,
--   the pointer to the mapped region returned by <a>clEnqueueMapBuffer</a>
--   cannot be used until the map command has completed. The event argument
--   returns an event object which can be used to query the execution
--   status of the map command. When the map command is completed, the
--   application can access the contents of the mapped region using the
--   pointer returned by <a>clEnqueueMapBuffer</a>.
--   
--   Returns an event object that identifies this particular copy command
--   and can be used toquery or queue a wait for this particular command to
--   complete. event can be NULL in which case it will not be possible for
--   the application to query the status of this command or queue a wait
--   for this command to complete.
--   
--   The contents of the regions of a memory object mapped for writing
--   (i.e. <a>CL_MAP_WRITE</a> is set in map_flags argument to
--   <a>clEnqueueMapBuffer</a> or <a>clEnqueueMapImage</a>) are considered
--   to be undefined until this region is unmapped. Reads and writes by a
--   kernel executing on a device to a memory region(s) mapped for writing
--   are undefined.
--   
--   Multiple command-queues can map a region or overlapping regions of a
--   memory object for reading (i.e. map_flags = <a>CL_MAP_READ</a>). The
--   contents of the regions of a memory object mapped for reading can also
--   be read by kernels executing on a device(s). The behavior of writes by
--   a kernel executing on a device to a mapped region of a memory object
--   is undefined. Mapping (and unmapping) overlapped regions of a buffer
--   or image memory object for writing is undefined.
--   
--   The behavior of OpenCL function calls that enqueue commands that write
--   or copy to regions of a memory object that are mapped is undefined.
--   
--   <a>clEnqueueMapBuffer</a> will return a pointer to the mapped region
--   if the function is executed successfully. A nullPtr pointer is
--   returned otherwise with one of the following exception:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue, src_image and dst_buffer are not the same or if the
--   context associated with command_queue and events in event_wait_list
--   are not the same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if buffer is not a valid buffer
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if region being mapped given by (offset,
--   cb) is out of bounds or if values specified in map_flags are not
--   valid</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MAP_FAILURE</tt> if there is a failure to map the requested
--   region into the host address space. This error cannot occur for buffer
--   objects created with <tt>CL_MEM_USE_HOST_PTR</tt> or
--   <tt>CL_MEM_ALLOC_HOST_PTR</tt>.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with buffer.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
--   
--   The pointer returned maps a region starting at offset and is atleast
--   cb bytes in size. The result of a memory access outside this region is
--   undefined.
clEnqueueMapBuffer :: Integral a => CLCommandQueue -> CLMem -> Bool -> [CLMapFlag] -> a -> a -> [CLEvent] -> IO (CLEvent, Ptr ())

-- | Enqueues a command to map a region of an image object into the host
--   address space and returns a pointer to this mapped region.
--   
--   If blocking_map is <a>False</a> i.e. map operation is non-blocking,
--   the pointer to the mapped region returned by <a>clEnqueueMapImage</a>
--   cannot be used until the map command has completed. The event argument
--   returns an event object which can be used to query the execution
--   status of the map command. When the map command is completed, the
--   application can access the contents of the mapped region using the
--   pointer returned by <a>clEnqueueMapImage</a>.
--   
--   Returns an event object that identifies this particular copy command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete.
--   
--   If the buffer or image object is created with
--   <tt>CL_MEM_USE_HOST_PTR</tt> set in mem_flags, the following will be
--   true:
--   
--   <ul>
--   <li>The host_ptr specified in <tt>clCreateBuffer</tt>,
--   <tt>clCreateImage2D</tt>, or <tt>clCreateImage3D</tt> is guaranteed to
--   contain the latest bits in the region being mapped when the
--   <a>clEnqueueMapBuffer</a> or <a>clEnqueueMapImage</a> command has
--   completed.</li>
--   <li>The pointer value returned by <a>clEnqueueMapBuffer</a> or
--   <a>clEnqueueMapImage</a> will be derived from the host_ptr specified
--   when the buffer or image object is created.</li>
--   </ul>
--   
--   The contents of the regions of a memory object mapped for writing
--   (i.e. <a>CL_MAP_WRITE</a> is set in map_flags argument to
--   <a>clEnqueueMapBuffer</a> or <a>clEnqueueMapImage</a>) are considered
--   to be undefined until this region is unmapped. Reads and writes by a
--   kernel executing on a device to a memory region(s) mapped for writing
--   are undefined.
--   
--   Multiple command-queues can map a region or overlapping regions of a
--   memory object for reading (i.e. map_flags = <a>CL_MAP_READ</a>). The
--   contents of the regions of a memory object mapped for reading can also
--   be read by kernels executing on a device(s). The behavior of writes by
--   a kernel executing on a device to a mapped region of a memory object
--   is undefined. Mapping (and unmapping) overlapped regions of a buffer
--   or image memory object for writing is undefined.
--   
--   The behavior of OpenCL function calls that enqueue commands that write
--   or copy to regions of a memory object that are mapped is undefined.
--   
--   <a>clEnqueueMapImage</a> will return a pointer to the mapped region if
--   the function is executed successfully also the scan-line (row) pitch
--   in bytes for the mapped region and the size in bytes of each 2D slice
--   for the mapped region. For a 2D image, zero is returned as slice
--   pitch. A nullPtr pointer is returned otherwise with one of the
--   following exception:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and image are not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if image is not a valid image
--   object.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if region being mapped given by (origin,
--   origin+region) is out of bounds or if values specified in map_flags
--   are not valid.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if image is a 2D image object and z is
--   not equal to 0 or depth is not equal to 1.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_MAP_FAILURE</tt> if there is a failure to map the requested
--   region into the host address space. This error cannot occur for image
--   objects created with <tt>CL_MEM_USE_HOST_PTR</tt> or
--   <tt>CL_MEM_ALLOC_HOST_PTR</tt>.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with image.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
--   
--   The pointer returned maps a 2D or 3D region starting at origin and is
--   atleast (image_row_pitch * y + x) pixels in size for a 2D image, and
--   is atleast (image_slice_pitch * z] + image_row_pitch * y + x) pixels
--   in size for a 3D image. The result of a memory access outside this
--   region is undefined.
clEnqueueMapImage :: Integral a => CLCommandQueue -> CLMem -> Bool -> [CLMapFlag] -> (a, a, a) -> (a, a, a) -> [CLEvent] -> IO (CLEvent, (Ptr (), CSize, CSize))

-- | Enqueues a command to unmap a previously mapped region of a memory
--   object.
--   
--   Returns an event object that identifies this particular copy command
--   and can be used to query or queue a wait for this particular command
--   to complete. event can be NULL in which case it will not be possible
--   for the application to query the status of this command or queue a
--   wait for this command to complete. <a>clEnqueueBarrier</a> can be used
--   instead.
--   
--   Reads or writes from the host using the pointer returned by
--   <a>clEnqueueMapBuffer</a> or <a>clEnqueueMapImage</a> are considered
--   to be complete.
--   
--   <a>clEnqueueMapBuffer</a> and <a>clEnqueueMapImage</a> increments the
--   mapped count of the memory object. The initial mapped count value of a
--   memory object is zero. Multiple calls to <a>clEnqueueMapBuffer</a> or
--   <a>clEnqueueMapImage</a> on the same memory object will increment this
--   mapped count by appropriate number of calls.
--   <a>clEnqueueUnmapMemObject</a> decrements the mapped count of the
--   memory object.
--   
--   <a>clEnqueueMapBuffer</a> and <a>clEnqueueMapImage</a> act as
--   synchronization points for a region of the memory object being mapped.
--   
--   <a>clEnqueueUnmapMemObject</a> returns the <a>CLEvent</a> if the
--   function is executed successfully. It can throw the following
--   <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li>CL_INVALID_COMMAND_QUEUE if command_queue is not a valid
--   command-queue.</li>
--   <li>CL_INVALID_MEM_OBJECT if memobj is not a valid memory object.</li>
--   <li>CL_INVALID_VALUE if mapped_ptr is not a valid pointer returned by
--   <a>clEnqueueMapBuffer</a> or <a>clEnqueueMapImage</a> for memobj.</li>
--   <li>CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list are
--   not valid events.</li>
--   <li>CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources
--   required by the OpenCL implementation on the host.</li>
--   <li>CL_INVALID_CONTEXT if the context associated with command_queue
--   and memobj are not the same or if the context associated with
--   command_queue and events in event_wait_list are not the same.</li>
--   </ul>
clEnqueueUnmapMemObject :: CLCommandQueue -> CLMem -> Ptr () -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to execute a kernel on a device. Each work-item is
--   uniquely identified by a global identifier. The global ID, which can
--   be read inside the kernel, is computed using the value given by
--   global_work_size and global_work_offset. In OpenCL 1.0, the starting
--   global ID is always (0, 0, ... 0). In addition, a work-item is also
--   identified within a work-group by a unique local ID. The local ID,
--   which can also be read by the kernel, is computed using the value
--   given by local_work_size. The starting local ID is always (0, 0, ...
--   0).
--   
--   Returns the event if the kernel execution was successfully queued. It
--   can throw the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_PROGRAM_EXECUTABLE</tt> if there is no successfully
--   built program executable available for device associated with
--   command_queue.</li>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_KERNEL</tt> if kernel is not a valid kernel
--   object.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context associated with
--   command_queue and kernel is not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_KERNEL_ARGS</tt> if the kernel argument values have
--   not been specified.</li>
--   <li><tt>CL_INVALID_WORK_DIMENSION</tt> if work_dim is not a valid
--   value (i.e. a value between 1 and 3).</li>
--   <li><tt>CL_INVALID_WORK_GROUP_SIZE</tt> if local_work_size is
--   specified and number of work-items specified by global_work_size is
--   not evenly divisable by size of work-group given by local_work_size or
--   does not match the work-group size specified for kernel using the
--   __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program
--   source.</li>
--   <li><tt>CL_INVALID_WORK_GROUP_SIZE</tt> if local_work_size is
--   specified and the total number of work-items in the work-group
--   computed as local_work_size[0] *... local_work_size[work_dim - 1] is
--   greater than the value specified by
--   <tt>CL_DEVICE_MAX_WORK_GROUP_SIZE</tt> in the table of OpenCL Device
--   Queries for clGetDeviceInfo.</li>
--   <li><tt>CL_INVALID_WORK_GROUP_SIZE</tt> if local_work_size is NULL and
--   the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier is used
--   to declare the work-group size for kernel in the program source.</li>
--   <li><tt>CL_INVALID_WORK_ITEM_SIZE</tt> if the number of work-items
--   specified in any of local_work_size[0], ... local_work_size[work_dim -
--   1] is greater than the corresponding values specified by
--   <tt>CL_DEVICE_MAX_WORK_ITEM_SIZES</tt>[0], ....
--   <tt>CL_DEVICE_MAX_WORK_ITEM_SIZES</tt>[work_dim - 1].</li>
--   <li><tt>CL_OUT_OF_RESOURCES</tt> if there is a failure to queue the
--   execution instance of kernel on the command-queue because of
--   insufficient resources needed to execute the kernel. For example, the
--   explicitly specified local_work_size causes a failure to execute the
--   kernel because of insufficient resources such as registers or local
--   memory. Another example would be the number of read-only image args
--   used in kernel exceed the <tt>CL_DEVICE_MAX_READ_IMAGE_ARGS</tt> value
--   for device or the number of write-only image args used in kernel
--   exceed the <tt>CL_DEVICE_MAX_WRITE_IMAGE_ARGS</tt> value for device or
--   the number of samplers used in kernel exceed
--   <tt>CL_DEVICE_MAX_SAMPLERS</tt> for device.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with image or buffer objects
--   specified as arguments to kernel.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueNDRangeKernel :: Integral a => CLCommandQueue -> CLKernel -> [a] -> [a] -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to execute a kernel on a device. The kernel is
--   executed using a single work-item.
--   
--   <a>clEnqueueTask</a> is equivalent to calling
--   <a>clEnqueueNDRangeKernel</a> with work_dim = 1, global_work_offset =
--   [], global_work_size[0] set to 1, and local_work_size[0] set to 1.
--   
--   Returns the evens if the kernel execution was successfully queued. It
--   can throw the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_PROGRAM_EXECUTABLE</tt> if there is no successfully
--   built program executable available for device associated with
--   command_queue.</li>
--   <li>'CL_INVALID_COMMAND_QUEUE if' command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_KERNEL</tt> if kernel is not a valid kernel
--   object.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context associated with
--   command_queue and kernel is not the same or if the context associated
--   with command_queue and events in event_wait_list are not the
--   same.</li>
--   <li><tt>CL_INVALID_KERNEL_ARGS</tt> if the kernel argument values have
--   not been specified.</li>
--   <li><tt>CL_INVALID_WORK_GROUP_SIZE</tt> if a work-group size is
--   specified for kernel using the __attribute__((reqd_work_group_size(X,
--   Y, Z))) qualifier in program source and is not (1, 1, 1).</li>
--   <li><tt>CL_OUT_OF_RESOURCES</tt> if there is a failure to queue the
--   execution instance of kernel on the command-queue because of
--   insufficient resources needed to execute the kernel.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with image or buffer objects
--   specified as arguments to kernel.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueTask :: CLCommandQueue -> CLKernel -> [CLEvent] -> IO CLEvent

-- | Enqueues a command to execute a native C/C++ function not compiled
--   using the OpenCL compiler. A native user function can only be executed
--   on a command-queue created on a device that has
--   <tt>CL_EXEC_NATIVE_KERNEL</tt> capability set in
--   <tt>clGetDeviceExecutionCapabilities</tt>.
--   
--   The data pointed to by args and cb_args bytes in size will be copied
--   and a pointer to this copied region will be passed to user_func. The
--   copy needs to be done because the memory objects (<a>CLMem</a> values)
--   that args may contain need to be modified and replaced by appropriate
--   pointers to global memory. When <a>clEnqueueNativeKernel</a> returns,
--   the memory region pointed to by args can be reused by the application.
--   
--   Returns the evens if the kernel execution was successfully queued. It
--   can throw the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if context associated with
--   command_queue and events in event-wait_list are not the same.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if args is a NULL value and cb_args is
--   greater than 0, or if args is a NULL value and num_mem_objects is
--   greater than 0.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if args is not NULL and cb_args is
--   0.</li>
--   <li><tt>CL_INVALID_OPERATION</tt> if device cannot execute the native
--   kernel.</li>
--   <li><tt>CL_INVALID_MEM_OBJECT</tt> if one or more memory objects
--   specified in mem_list are not valid or are not buffer objects.</li>
--   <li><tt>CL_OUT_OF_RESOURCES</tt> if there is a failure to queue the
--   execution instance of kernel on the command-queue because of
--   insufficient resources needed to execute the kernel.</li>
--   <li><tt>CL_MEM_OBJECT_ALLOCATION_FAILURE</tt> if there is a failure to
--   allocate memory for data store associated with buffer objects
--   specified as arguments to kernel.</li>
--   <li><tt>CL_INVALID_EVENT_WAIT_LIST</tt> if event objects in
--   event_wait_list are not valid events.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueNativeKernel :: CLCommandQueue -> (Ptr () -> IO ()) -> Ptr () -> CSize -> [CLMem] -> [Ptr ()] -> [CLEvent] -> IO CLEvent

-- | Enqueues a marker command to command_queue. The marker command returns
--   an event which can be used to queue a wait on this marker event i.e.
--   wait for all commands queued before the marker command to complete.
--   Returns the event if the function is successfully executed. It throw
--   the <tt>CLError</tt> exception <tt>CL_INVALID_COMMAND_QUEUE</tt> if
--   command_queue is not a valid command-queue and throw
--   <tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.
clEnqueueMarker :: CLCommandQueue -> IO CLEvent

-- | Enqueues a wait for a specific event or a list of events to complete
--   before any future commands queued in the command-queue are executed.
--   The context associated with events in event_list and command_queue
--   must be the same.
--   
--   It can throw the following <tt>CLError</tt> exceptions:
--   
--   <ul>
--   <li><tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue.</li>
--   <li><tt>CL_INVALID_CONTEXT</tt> if the context associated with
--   command_queue and events in event_list are not the same.</li>
--   <li><tt>CL_INVALID_VALUE</tt> if num_events is zero.</li>
--   <li><tt>CL_INVALID_EVENT</tt> if event objects specified in event_list
--   are not valid events.</li>
--   <li><tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a failure to allocate
--   resources required by the OpenCL implementation on the host.</li>
--   </ul>
clEnqueueWaitForEvents :: CLCommandQueue -> [CLEvent] -> IO ()

-- | <a>clEnqueueBarrier</a> is a synchronization point that ensures that
--   all queued commands in command_queue have finished execution before
--   the next batch of commands can begin execution. It throws
--   <tt>CL_INVALID_COMMAND_QUEUE</tt> if command_queue is not a valid
--   command-queue and throws <tt>CL_OUT_OF_HOST_MEMORY</tt> if there is a
--   failure to allocate resources required by the OpenCL implementation on
--   the host.
clEnqueueBarrier :: CLCommandQueue -> IO ()

-- | Issues all previously queued OpenCL commands in a command-queue to the
--   device associated with the command-queue. <a>clFlush</a> only
--   guarantees that all queued commands to command_queue get issued to the
--   appropriate device. There is no guarantee that they will be complete
--   after <a>clFlush</a> returns.
--   
--   <a>clFlush</a> returns <a>True</a> if the function call was executed
--   successfully. It returns <a>False</a> if command_queue is not a valid
--   command-queue or if there is a failure to allocate resources required
--   by the OpenCL implementation on the host.
--   
--   Any blocking commands queued in a command-queue such as
--   <a>clEnqueueReadImage</a> or <a>clEnqueueReadBuffer</a> with
--   blocking_read set to <a>True</a>, <a>clEnqueueWriteImage</a> or
--   <a>clEnqueueWriteBuffer</a> with blocking_write set to <a>True</a>,
--   <a>clEnqueueMapImage</a> or <a>clEnqueueMapBuffer</a> with
--   blocking_map set to <a>True</a> or <tt>clWaitForEvents</tt> perform an
--   implicit flush of the command-queue.
--   
--   To use event objects that refer to commands enqueued in a
--   command-queue as event objects to wait on by commands enqueued in a
--   different command-queue, the application must call a <a>clFlush</a> or
--   any blocking commands that perform an implicit flush of the
--   command-queue where the commands that refer to these event objects are
--   enqueued.
clFlush :: CLCommandQueue -> IO Bool

-- | Blocks until all previously queued OpenCL commands in a command-queue
--   are issued to the associated device and have completed.
--   <a>clFinish</a> does not return until all queued commands in
--   command_queue have been processed and completed. <a>clFinish</a> is
--   also a synchronization point.
--   
--   <a>clFinish</a> returns <a>True</a> if the function call was executed
--   successfully. It returns <a>False</a> if command_queue is not a valid
--   command-queue or if there is a failure to allocate resources required
--   by the OpenCL implementation on the host.
clFinish :: CLCommandQueue -> IO Bool
instance Enum CLCommandQueueInfo

module Control.Parallel.OpenCL.Context
type CLContext = Ptr ()

-- | Specifies a context property name and its corresponding value.
data CLContextProperty

-- | Specifies the platform to use.
CL_CONTEXT_PLATFORM :: CLPlatformID -> CLContextProperty

-- | Specifies the CGL share group to use.
CL_CGL_SHAREGROUP_KHR :: (Ptr ()) -> CLContextProperty
CL_GL_CONTEXT_KHR :: (Ptr ()) -> CLContextProperty
CL_EGL_DISPLAY_KHR :: (Ptr ()) -> CLContextProperty
CL_GLX_DISPLAY_KHR :: (Ptr ()) -> CLContextProperty
CL_WGL_HDC_KHR :: (Ptr ()) -> CLContextProperty

-- | Creates an OpenCL context. An OpenCL context is created with one or
--   more devices. Contexts are used by the OpenCL runtime for managing
--   objects such as command-queues, memory, program and kernel objects and
--   for executing kernels on one or more devices specified in the context.
clCreateContext :: [CLContextProperty] -> [CLDeviceID] -> (String -> IO ()) -> IO CLContext

-- | Create an OpenCL context from a device type that identifies the
--   specific device(s) to use.
clCreateContextFromType :: [CLContextProperty] -> [CLDeviceType] -> (String -> IO ()) -> IO CLContext

-- | Increment the context reference count. <a>clCreateContext</a> and
--   <a>clCreateContextFromType</a> perform an implicit retain. This is
--   very helpful for 3rd party libraries, which typically get a context
--   passed to them by the application. However, it is possible that the
--   application may delete the context without informing the library.
--   Allowing functions to attach to (i.e. retain) and release a context
--   solves the problem of a context being used by a library no longer
--   being valid. Returns <a>True</a> if the function is executed
--   successfully, or <a>False</a> if context is not a valid OpenCL
--   context.
clRetainContext :: CLContext -> IO Bool

-- | Decrement the context reference count. After the context reference
--   count becomes zero and all the objects attached to context (such as
--   memory objects, command-queues) are released, the context is deleted.
--   Returns <a>True</a> if the function is executed successfully, or
--   <a>False</a> if context is not a valid OpenCL context.
clReleaseContext :: CLContext -> IO Bool

-- | Return the context reference count. The reference count returned
--   should be considered immediately stale. It is unsuitable for general
--   use in applications. This feature is provided for identifying memory
--   leaks.
--   
--   This function execute OpenCL clGetContextInfo with
--   <a>CL_CONTEXT_REFERENCE_COUNT</a>.
clGetContextReferenceCount :: CLContext -> IO CLuint

-- | Return the list of devices in context.
--   
--   This function execute OpenCL clGetContextInfo with
--   <a>CL_CONTEXT_DEVICES</a>.
clGetContextDevices :: CLContext -> IO [CLDeviceID]
clGetContextProperties :: CLContext -> IO [CLContextProperty]
instance Show CLContextProperty
instance Enum CLContextInfo
instance Enum CLContextProperties

module Control.Parallel.OpenCL.Query

-- | <ul>
--   <li><a>CL_PLATFORM_PROFILE</a>, OpenCL profile string. Returns the
--   profile name supported by the implementation. The profile name
--   returned can be one of the following strings:</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>FULL_PROFILE</tt></i> If the implementation supports the
--   OpenCL specification (functionality defined as part of the core
--   specification and does not require any extensions to be
--   supported).</li>
--   <li><i><tt>EMBEDDED_PROFILE</tt></i> If the implementation supports
--   the OpenCL embedded profile. The embedded profile is defined to be a
--   subset for each version of OpenCL.</li>
--   </ul>
--   
--   <ul>
--   <li><a>CL_PLATFORM_VERSION</a>, OpenCL version string. Returns the
--   OpenCL version supported by the implementation. This version string
--   has the following format: <i>OpenCL major_version.minor_version
--   platform-specific information</i> The
--   <i>major_version.minor_version</i> value returned will be 1.0.</li>
--   <li><a>CL_PLATFORM_NAME</a>, Platform name string.</li>
--   <li><a>CL_PLATFORM_VENDOR</a>, Platform vendor string.</li>
--   <li><a>CL_PLATFORM_EXTENSIONS</a>, Returns a space-separated list of
--   extension names (the extension names themselves do not contain any
--   spaces) supported by the platform. Extensions defined here must be
--   supported by all devices associated with this platform.</li>
--   </ul>
data CLPlatformInfo
CL_PLATFORM_PROFILE :: CLPlatformInfo
CL_PLATFORM_VERSION :: CLPlatformInfo
CL_PLATFORM_NAME :: CLPlatformInfo
CL_PLATFORM_VENDOR :: CLPlatformInfo
CL_PLATFORM_EXTENSIONS :: CLPlatformInfo
type CLPlatformID = Ptr ()
type CLDeviceID = Ptr ()

-- | <ul>
--   <li><a>CL_DEVICE_TYPE_CPU</a>, An OpenCL device that is the host
--   processor. The host processor runs the OpenCL implementations and is a
--   single or multi-core CPU.</li>
--   <li><a>CL_DEVICE_TYPE_GPU</a>, An OpenCL device that is a GPU. By this
--   we mean that the device can also be used to accelerate a 3D API such
--   as OpenGL or DirectX.</li>
--   <li><a>CL_DEVICE_TYPE_ACCELERATOR</a>, Dedicated OpenCL accelerators
--   (for example the IBM CELL Blade). These devices communicate with the
--   host processor using a peripheral interconnect such as PCIe.</li>
--   <li><a>CL_DEVICE_TYPE_DEFAULT</a>, The default OpenCL device in the
--   system.</li>
--   <li><a>CL_DEVICE_TYPE_ALL</a>, All OpenCL devices available in the
--   system.</li>
--   </ul>
data CLDeviceType
CL_DEVICE_TYPE_CPU :: CLDeviceType
CL_DEVICE_TYPE_GPU :: CLDeviceType
CL_DEVICE_TYPE_ACCELERATOR :: CLDeviceType
CL_DEVICE_TYPE_DEFAULT :: CLDeviceType
CL_DEVICE_TYPE_ALL :: CLDeviceType

-- | <ul>
--   <li><a>CL_FP_DENORM</a>, denorms are supported.</li>
--   <li><a>CL_FP_INF_NAN</a>, INF and NaNs are supported.</li>
--   <li><a>CL_FP_ROUND_TO_NEAREST</a>, round to nearest even rounding mode
--   supported.</li>
--   <li><a>CL_FP_ROUND_TO_ZERO</a>, round to zero rounding mode
--   supported.</li>
--   <li><a>CL_FP_ROUND_TO_INF</a>, round to +ve and -ve infinity rounding
--   modes supported.</li>
--   <li><a>CL_FP_FMA</a>, IEEE754-2008 fused multiply-add is
--   supported.</li>
--   </ul>
data CLDeviceFPConfig
CL_FP_DENORM :: CLDeviceFPConfig
CL_FP_INF_NAN :: CLDeviceFPConfig
CL_FP_ROUND_TO_NEAREST :: CLDeviceFPConfig
CL_FP_ROUND_TO_ZERO :: CLDeviceFPConfig
CL_FP_ROUND_TO_INF :: CLDeviceFPConfig
CL_FP_FMA :: CLDeviceFPConfig

-- | <ul>
--   <li><a>CL_EXEC_KERNEL</a>, The OpenCL device can execute OpenCL
--   kernels.</li>
--   <li><a>CL_EXEC_NATIVE_KERNEL</a>, The OpenCL device can execute native
--   kernels.</li>
--   </ul>
data CLDeviceExecCapability
CL_EXEC_KERNEL :: CLDeviceExecCapability
CL_EXEC_NATIVE_KERNEL :: CLDeviceExecCapability
data CLDeviceLocalMemType
CL_LOCAL :: CLDeviceLocalMemType
CL_GLOBAL :: CLDeviceLocalMemType
data CLDeviceMemCacheType
CL_NONE :: CLDeviceMemCacheType
CL_READ_ONLY_CACHE :: CLDeviceMemCacheType
CL_READ_WRITE_CACHE :: CLDeviceMemCacheType

-- | Obtain the list of platforms available. Returns the list if the
--   function is executed successfully. Otherwise it returns the empty
--   list.
clGetPlatformIDs :: IO [CLPlatformID]

-- | Get specific information about the OpenCL platform. It returns Nothing
--   if platform is not a valid platform.
clGetPlatformInfo :: CLPlatformID -> CLPlatformInfo -> IO String

-- | Obtain the list of devices available on a platform. Returns the list
--   if the function is executed successfully. Otherwise it returns the
--   empty list if platform is not a valid platform or no OpenCL devices
--   that matched device_type were found.
clGetDeviceIDs :: CLPlatformID -> CLDeviceType -> IO [CLDeviceID]

-- | Describes the execution capabilities of the device. This is a list
--   that describes one or more of the <a>CLDeviceExecCapability</a>
--   values. The mandated minimum capability is <a>CL_EXEC_KERNEL</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_EXECUTION_CAPABILITIES</a>.
clGetDeviceExecutionCapabilities :: CLDeviceID -> IO [CLDeviceExecCapability]

-- | The default compute device address space size specified as an unsigned
--   integer value in bits. Currently supported values are 32 or 64 bits.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_ADDRESS_BITS</a>.
clGetDeviceAddressBits :: CLDeviceID -> IO CLuint

-- | Is <a>True</a> if the device is available and <a>False</a> if the
--   device is not available.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_AVAILABLE</a>.
clGetDeviceAvailable :: CLDeviceID -> IO Bool

-- | Is <a>False</a> if the implementation does not have a compiler
--   available to compile the program source. Is <a>True</a> if the
--   compiler is available. This can be <a>False</a> for the embededed
--   platform profile only.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_COMPILER_AVAILABLE</a>.
clGetDeviceCompilerAvailable :: CLDeviceID -> IO Bool

-- | Is <a>True</a> if the OpenCL device is a little endian device and
--   <a>False</a> otherwise.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_ENDIAN_LITTLE</a>.
clGetDeviceEndianLittle :: CLDeviceID -> IO Bool

-- | Is <a>True</a> if the device implements error correction for the
--   memories, caches, registers etc. in the device. Is <a>False</a> if the
--   device does not implement error correction. This can be a requirement
--   for certain clients of OpenCL.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_ERROR_CORRECTION_SUPPORT</a>.
clGetDeviceErrorCorrectionSupport :: CLDeviceID -> IO Bool

-- | Returns a space separated list of extension names (the extension names
--   themselves do not contain any spaces). The list of extension names
--   returned currently can include one or more of the following approved
--   extension names:
--   
--   <ul>
--   <li>cl_khr_fp64</li>
--   <li>cl_khr_select_fprounding_mode</li>
--   <li>cl_khr_global_int32_base_atomics</li>
--   <li>cl_khr_global_int32_extended_atomics</li>
--   <li>cl_khr_local_int32_base_atomics</li>
--   <li>cl_khr_local_int32_extended_atomics</li>
--   <li>cl_khr_int64_base_atomics</li>
--   <li>cl_khr_int64_extended_atomics</li>
--   <li>cl_khr_3d_image_writes</li>
--   <li>cl_khr_byte_addressable_store</li>
--   <li>cl_khr_fp16</li>
--   </ul>
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_EXTENSIONS</a>.
clGetDeviceExtensions :: CLDeviceID -> IO String

-- | Size of global memory cache in bytes.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_GLOBAL_MEM_CACHE_SIZE</a>.
clGetDeviceGlobalMemCacheSize :: CLDeviceID -> IO CLulong

-- | Size of global memory cache line in bytes.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE</a>.
clGetDeviceGlobalMemCachelineSize :: CLDeviceID -> IO CLuint

-- | Size of global device memory in bytes.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_GLOBAL_MEM_SIZE</a>.
clGetDeviceGlobalMemSize :: CLDeviceID -> IO CLulong

-- | Is <a>True</a> if images are supported by the OpenCL device and
--   <a>False</a> otherwise.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE_SUPPORT</a>.
clGetDeviceImageSupport :: CLDeviceID -> IO Bool

-- | Max height of 2D image in pixels. The minimum value is 8192 if
--   <a>clGetDeviceImageSupport</a> is <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE2D_MAX_HEIGHT</a>.
clGetDeviceImage2DMaxHeight :: CLDeviceID -> IO CSize

-- | Max width of 2D image in pixels. The minimum value is 8192 if
--   <a>clGetDeviceImageSupport</a> is <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE2D_MAX_WIDTH</a>.
clGetDeviceImage2DMaxWidth :: CLDeviceID -> IO CSize

-- | Max depth of 3D image in pixels. The minimum value is 2048 if
--   <a>clGetDeviceImageSupport</a> is <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE3D_MAX_DEPTH</a>.
clGetDeviceImage3DMaxDepth :: CLDeviceID -> IO CSize

-- | Max height of 3D image in pixels. The minimum value is 2048 if
--   <a>clGetDeviceImageSupport</a> is <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE3D_MAX_HEIGHT</a>.
clGetDeviceImage3DMaxHeight :: CLDeviceID -> IO CSize

-- | Max width of 3D image in pixels. The minimum value is 2048 if
--   <a>clGetDeviceImageSupport</a> is <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_IMAGE3D_MAX_WIDTH</a>.
clGetDeviceImage3DMaxWidth :: CLDeviceID -> IO CSize

-- | Size of local memory arena in bytes. The minimum value is 16 KB.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_LOCAL_MEM_SIZE</a>.
clGetDeviceLocalMemSize :: CLDeviceID -> IO CLulong

-- | Maximum configured clock frequency of the device in MHz.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_CLOCK_FREQUENCY</a>.
clGetDeviceMaxClockFrequency :: CLDeviceID -> IO CLuint

-- | The number of parallel compute cores on the OpenCL device. The minimum
--   value is 1.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_COMPUTE_UNITS</a>.
clGetDeviceMaxComputeUnits :: CLDeviceID -> IO CLuint

-- | Max number of arguments declared with the __constant qualifier in a
--   kernel. The minimum value is 8.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_CONSTANT_ARGS</a>.
clGetDeviceMaxConstantArgs :: CLDeviceID -> IO CLuint

-- | Max size in bytes of a constant buffer allocation. The minimum value
--   is 64 KB.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE</a>.
clGetDeviceMaxConstantBufferSize :: CLDeviceID -> IO CLulong

-- | Max size of memory object allocation in bytes. The minimum value is
--   max (1/4th of <a>clGetDeviceGlobalMemSize</a>, 128*1024*1024)
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_MEM_ALLOC_SIZE</a>.
clGetDeviceMaxMemAllocSize :: CLDeviceID -> IO CLulong

-- | Max size in bytes of the arguments that can be passed to a kernel. The
--   minimum value is 256.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_PARAMETER_SIZE</a>.
clGetDeviceMaxParameterSize :: CLDeviceID -> IO CSize

-- | Max number of simultaneous image objects that can be read by a kernel.
--   The minimum value is 128 if <a>clGetDeviceImageSupport</a> is
--   <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_READ_IMAGE_ARGS</a>.
clGetDeviceMaxReadImageArgs :: CLDeviceID -> IO CLuint

-- | Maximum number of samplers that can be used in a kernel. The minimum
--   value is 16 if <a>clGetDeviceImageSupport</a> is <a>True</a>. (Also
--   see sampler type.)
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_SAMPLERS</a>.
clGetDeviceMaxSamplers :: CLDeviceID -> IO CLuint

-- | Maximum number of work-items in a work-group executing a kernel using
--   the data parallel execution model. (Refer to
--   <tt>clEnqueueNDRangeKernel</tt>). The minimum value is 1.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_WORK_GROUP_SIZE</a>.
clGetDeviceMaxWorkGroupSize :: CLDeviceID -> IO CSize

-- | Maximum dimensions that specify the global and local work-item IDs
--   used by the data parallel execution model. (Refer to
--   <tt>clEnqueueNDRangeKernel</tt>). The minimum value is 3.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS</a>.
clGetDeviceMaxWorkItemDimensions :: CLDeviceID -> IO CLuint

-- | Maximum number of work-items that can be specified in each dimension
--   of the work-group to <tt>clEnqueueNDRangeKernel</tt>. Returns n
--   entries, where n is the value returned by the query for
--   clDeviceMaxWorkItemDimensions. The minimum value is (1, 1, 1).
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_WORK_ITEM_SIZES</a>.
clGetDeviceMaxWorkItemSizes :: CLDeviceID -> IO [CSize]

-- | Max number of simultaneous image objects that can be written to by a
--   kernel. The minimum value is 8 if <a>clGetDeviceImageSupport</a> is
--   <a>True</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MAX_WRITE_IMAGE_ARGS</a>.
clGetDeviceMaxWriteImageArgs :: CLDeviceID -> IO CLuint

-- | Describes the alignment in bits of the base address of any allocated
--   memory object.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MEM_BASE_ADDR_ALIGN</a>.
clGetDeviceMemBaseAddrAlign :: CLDeviceID -> IO CLuint

-- | The smallest alignment in bytes which can be used for any data type.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE</a>.
clGetDeviceMinDataTypeAlignSize :: CLDeviceID -> IO CLuint

-- | Device name string.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_NAME</a>.
clGetDeviceName :: CLDeviceID -> IO String

-- | The platform associated with this device.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PLATFORM</a>.
clGetDevicePlatform :: CLDeviceID -> IO CLPlatformID

-- | Preferred native vector width size for built-in char types that can be
--   put into vectors. The vector width is defined as the number of scalar
--   elements that can be stored in the vector.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR</a>.
clGetDevicePreferredVectorWidthChar :: CLDeviceID -> IO CLuint

-- | Preferred native vector width size for built-in short types that can
--   be put into vectors. The vector width is defined as the number of
--   scalar elements that can be stored in the vector.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT</a>.
clGetDevicePreferredVectorWidthShort :: CLDeviceID -> IO CLuint

-- | Preferred native vector width size for built-in int types that can be
--   put into vectors. The vector width is defined as the number of scalar
--   elements that can be stored in the vector.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT</a>.
clGetDevicePreferredVectorWidthInt :: CLDeviceID -> IO CLuint

-- | Preferred native vector width size for built-in long types that can be
--   put into vectors. The vector width is defined as the number of scalar
--   elements that can be stored in the vector.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG</a>.
clGetDevicePreferredVectorWidthLong :: CLDeviceID -> IO CLuint

-- | Preferred native vector width size for built-in float types that can
--   be put into vectors. The vector width is defined as the number of
--   scalar elements that can be stored in the vector.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT</a>.
clGetDevicePreferredVectorWidthFloat :: CLDeviceID -> IO CLuint

-- | Preferred native vector width size for built-in double types that can
--   be put into vectors. The vector width is defined as the number of
--   scalar elements that can be stored in the vector. | If the cl_khr_fp64
--   extension is not supported,
--   <a>clGetDevicePreferredVectorWidthDouble</a> must return 0.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE</a>.
clGetDevicePreferredVectorWidthDouble :: CLDeviceID -> IO CLuint

-- | OpenCL profile string. Returns the profile name supported by the
--   device (see note). The profile name returned can be one of the
--   following strings:
--   
--   <ul>
--   <li>FULL_PROFILE - if the device supports the OpenCL specification
--   (functionality defined as part of the core specification and does not
--   require any extensions to be supported).</li>
--   <li>EMBEDDED_PROFILE - if the device supports the OpenCL embedded
--   profile.</li>
--   </ul>
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PROFILE</a>.
clGetDeviceProfile :: CLDeviceID -> IO String

-- | Describes the resolution of device timer. This is measured in
--   nanoseconds.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_PROFILING_TIMER_RESOLUTION</a>.
clGetDeviceProfilingTimerResolution :: CLDeviceID -> IO CSize

-- | Vendor name string.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_VENDOR</a>.
clGetDeviceVendor :: CLDeviceID -> IO String

-- | A unique device vendor identifier. An example of a unique device
--   identifier could be the PCIe ID.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_VENDOR_ID</a>.
clGetDeviceVendorID :: CLDeviceID -> IO CLuint

-- | OpenCL version string. Returns the OpenCL version supported by the
--   device. This version string has the following format: <i>OpenCL
--   major_version.minor_version vendor-specific information</i> The
--   major_version.minor_version value returned will be 1.0.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_VERSION</a>.
clGetDeviceVersion :: CLDeviceID -> IO String

-- | OpenCL software driver version string in the form
--   major_number.minor_number.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DRIVER_VERSION</a>.
clGetDeviceDriverVersion :: CLDeviceID -> IO String

-- | Describes single precision floating-point capability of the device.
--   This is a bit-field that describes one or more of the
--   <a>CLDeviceFPConfig</a> values. The mandated minimum floating-point
--   capability is <a>CL_FP_ROUND_TO_NEAREST</a> | <a>CL_FP_INF_NAN</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_SINGLE_FP_CONFIG</a>.
clGetDeviceSingleFPConfig :: CLDeviceID -> IO [CLDeviceFPConfig]

-- | Describes the OPTIONAL double precision floating-point capability of
--   the OpenCL device. This is a bit-field that describes one or more of
--   the <a>CLDeviceFPConfig</a> values. The mandated minimum double
--   precision floating-point capability is <a>CL_FP_FMA</a> |
--   <a>CL_FP_ROUND_TO_NEAREST</a> | <a>CL_FP_ROUND_TO_ZERO</a> |
--   <a>CL_FP_ROUND_TO_INF</a> | <a>CL_FP_INF_NAN</a> |
--   <a>CL_FP_DENORM</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_DOUBLE_FP_CONFIG</a>.
clGetDeviceDoubleFPConfig :: CLDeviceID -> IO [CLDeviceFPConfig]

-- | Describes the OPTIONAL half precision floating-point capability of the
--   OpenCL device. This is a bit-field that describes one or more of the
--   <a>CLDeviceFPConfig</a> values. The required minimum half precision
--   floating-point capability as implemented by this extension is
--   <a>CL_FP_ROUND_TO_ZERO</a> | <a>CL_FP_ROUND_TO_INF</a> |
--   <a>CL_FP_INF_NAN</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_HALF_FP_CONFIG</a>.
clGetDeviceHalfFPConfig :: CLDeviceID -> IO [CLDeviceFPConfig]

-- | Type of local memory supported. This can be set to <a>CL_LOCAL</a>
--   implying dedicated local memory storage such as SRAM, or
--   <a>CL_GLOBAL</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_LOCAL_MEM_TYPE</a>.
clGetDeviceLocalMemType :: CLDeviceID -> IO CLDeviceLocalMemType

-- | Type of global memory cache supported. Valid values are:
--   <a>CL_NONE</a>, <a>CL_READ_ONLY_CACHE</a>, and
--   <a>CL_READ_WRITE_CACHE</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_GLOBAL_MEM_CACHE_TYPE</a>.
clGetDeviceGlobalMemCacheType :: CLDeviceID -> IO CLDeviceMemCacheType

-- | Describes the command-queue properties supported by the device. This
--   is a list that describes one or more of the CLCommandQueueProperty
--   values. These properties are described in the table for
--   <tt>clCreateCommandQueue</tt>. The mandated minimum capability is
--   <tt>CL_QUEUE_PROFILING_ENABLE</tt>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_QUEUE_PROPERTIES</a>.
clGetDeviceQueueProperties :: CLDeviceID -> IO [CLCommandQueueProperty]

-- | The OpenCL device type. Currently supported values are one of or a
--   combination of: <a>CL_DEVICE_TYPE_CPU</a>, <a>CL_DEVICE_TYPE_GPU</a>,
--   <a>CL_DEVICE_TYPE_ACCELERATOR</a>, or <a>CL_DEVICE_TYPE_DEFAULT</a>.
--   
--   This function execute OpenCL clGetDeviceInfo with
--   <a>CL_DEVICE_TYPE</a>.
clGetDeviceType :: CLDeviceID -> IO [CLDeviceType]
instance Enum CLDeviceInfo

module Control.Parallel.OpenCL

-- | <ul>
--   <li><a>CL_BUILD_PROGRAM_FAILURE</a>, Returned if there is a failure to
--   build the program executable.</li>
--   <li><a>CL_COMPILER_NOT_AVAILABLE</a>, Returned if the parameter
--   program is created with <tt>clCreateProgramWithSource</tt> and a
--   compiler is not available. For example
--   <tt>clDeviceCompilerAvalaible</tt> is set to <a>False</a>.</li>
--   <li><a>CL_DEVICE_NOT_AVAILABLE</a>, Returned if the specified device
--   is not currently available.</li>
--   <li><a>CL_DEVICE_NOT_FOUND</a>, Returned if no OpenCL devices that
--   match the specified devices were found.</li>
--   <li><tt>CL_PLATFORM_NOT_FOUND_khr</tt>, Returned when no .icd
--   (platform drivers) can be properly loaded.</li>
--   <li><a>CL_IMAGE_FORMAT_MISMATCH</a>, Returned if the specified source
--   and destination images are not valid image objects.</li>
--   <li><a>CL_IMAGE_FORMAT_NOT_SUPPORTED</a>, Returned if the specified
--   image format is not supported.</li>
--   <li><a>CL_INVALID_ARG_INDEX</a>, Returned if an invalid argument index
--   is specified.</li>
--   <li><a>CL_INVALID_ARG_SIZE</a>, Returned if argument size specified
--   (arg_size) does not match the size of the data type for an argument
--   that is not a memory object, or if the argument is a memory object and
--   arg_size != sizeof(cl_mem) or if arg_size is zero and the argument is
--   declared with the __local qualifier or if the argument is a sampler
--   and arg_size != sizeof(cl_sampler).</li>
--   <li><a>CL_INVALID_ARG_VALUE</a>, Returned if the argument value
--   specified is NULL for an argument that is not declared with the
--   __local qualifier or vice-versa.</li>
--   <li><a>CL_INVALID_BINARY</a>, Returned if the program binary is not a
--   valid binary for the specified device.</li>
--   <li><a>CL_INVALID_BUFFER_SIZE</a>, Returned if the value of the
--   parameter size is 0 or is greater than
--   <tt>clDeviceMaxMemAllocSize</tt> for all devices specified in the
--   parameter context.</li>
--   <li><a>CL_INVALID_BUILD_OPTIONS</a>, Returned if the specified build
--   options are invalid.</li>
--   <li><a>CL_INVALID_COMMAND_QUEUE</a>, Returned if the specified
--   command-queue is not a valid command-queue.</li>
--   <li><a>CL_INVALID_CONTEXT</a>, Returned if the specified context is
--   not a valid OpenCL context, or the context associated with certain
--   parameters are not the same.</li>
--   <li><a>CL_INVALID_DEVICE</a>, Returned if the device or devices
--   specified are not valid.</li>
--   <li><a>CL_INVALID_DEVICE_TYPE</a>, Returned if device type specified
--   is not valid.</li>
--   <li><a>CL_INVALID_EVENT</a>, Returned if the event objects specified
--   are not valid.</li>
--   <li><a>CL_INVALID_EVENT_WAIT_LIST</a>, Returned if event_wait_list is
--   NULL and num_events_in_wait_list &gt; 0, or event_wait_list_list is
--   not NULL and num_events_in_wait_list is 0, or specified event objects
--   are not valid events.</li>
--   <li><a>CL_INVALID_GL_OBJECT</a>, Returned if obj is not a vaild GL
--   object or is a GL object but does not have an existing data
--   store.</li>
--   <li><a>CL_INVALID_GLOBAL_OFFSET</a>, Returned if global_work_offset is
--   not NULL.</li>
--   <li><a>CL_INVALID_HOST_PTR</a>, Returned if host_ptr is NULL and
--   <a>CL_MEM_USE_HOST_PTR</a> or <a>CL_MEM_COPY_HOST_PTR</a> are set in
--   flags or if host_ptr is not NULL but <a>CL_MEM_COPY_HOST_PTR</a> or
--   <a>CL_MEM_USE_HOST_PTR</a> are not set in flags.</li>
--   <li><a>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</a>, Returned if the image
--   format specified is not valid or is NULL or does not map to a
--   supported OpenCL image format.</li>
--   <li><a>CL_INVALID_IMAGE_SIZE</a>, Returned if the specified image
--   width or height are invalid or if the image row pitch and image slice
--   pitch do not follow the rules.</li>
--   <li><a>CL_INVALID_KERNEL_NAME</a>, Returned if the specified kernel
--   name is not found in program.</li>
--   <li><a>CL_INVALID_KERNEL</a>, Returned if the specified kernel is not
--   a valid kernel object.</li>
--   <li><a>CL_INVALID_KERNEL_ARGS</a>, Returned if the kernel argument
--   values have not been specified.</li>
--   <li><a>CL_INVALID_KERNEL_DEFINITION</a>, Returned if the function
--   definition for __kernel function given by kernel_name such as the
--   number of arguments, the argument types are not the same for all
--   devices for which the program executable has been built.</li>
--   <li><a>CL_INVALID_MEM_OBJECT</a>, Returned if a parameter is not a
--   valid memory, image, or buffer object.</li>
--   <li><a>CL_INVALID_OPERATION</a>, Returned if there are no devices in
--   context that support images. Returned if the build of a program
--   executable for any of the devices specified by a previous call to
--   <tt>clBuildProgram</tt> for program has not completed, or if there are
--   kernel objects attached to program. Returned by
--   <tt>clEnqueueNativeKernel</tt> if the specified device cannot execute
--   the native kernel.</li>
--   <li><a>CL_INVALID_PLATFORM</a>, Returned if the specified platform is
--   not a valid platform, or no platform could be selected, or if platform
--   value specified in properties is not a valid platform.</li>
--   <li><a>CL_INVALID_PROGRAM</a>, Returned if the specified program is
--   not a valid program object.</li>
--   <li><a>CL_INVALID_PROGRAM_EXECUTABLE</a>, Returned if there is no
--   successfully built executable for program, or if there is no device in
--   program. Returned if there is no successfully built program executable
--   available for device associated with command_queue.</li>
--   <li><a>CL_INVALID_QUEUE_PROPERTIES</a>, Returned if specified
--   properties are valid but are not supported by the device.</li>
--   <li><a>CL_INVALID_SAMPLER</a>, Returned if the specified sampler is
--   not a valid sampler object, or for an argument declared to be of type
--   sampler_t when the specified arg_value is not a valid sampler
--   object.</li>
--   <li><a>CL_INVALID_VALUE</a>, Returned if a parameter is not an
--   expected value.</li>
--   <li><a>CL_INVALID_WORK_DIMENSION</a>, Returned if work_dim is not a
--   valid value.</li>
--   <li><a>CL_INVALID_WORK_GROUP_SIZE</a>, Returned if local_work_size is
--   specified and number of workitems specified by global_work_size is not
--   evenly divisible by size of work-group given by local_work_size or
--   does not match the work-group size specified for kernel using the
--   __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program
--   source.</li>
--   <li><a>CL_INVALID_WORK_ITEM_SIZE</a>, Returned if the number of
--   work-items specified in any of local_work_size... [0]...
--   local_work_size[work_dim - 1] is greater than the corresponding values
--   specified by <tt>clDeviceMaxWorkItemSizes</tt>.</li>
--   <li><a>CL_MAP_FAILURE</a>, Returned by if there is a failure to map
--   the requested region into the host address space. This error cannot
--   occur for buffer objects created with <tt>CLMEM_USE_HOST_PTR</tt> or
--   <tt>CLMEM_ALLOC_HOST_PTR</tt>.</li>
--   <li><a>CL_MEM_OBJECT_ALLOCATION_FAILURE</a>, Returned if there is a
--   failure to allocate memory for data store associated with image or
--   buffer objects specified as arguments to kernel.</li>
--   <li><a>CL_MEM_COPY_OVERLAP</a>, Returned if the source and destination
--   images are the same image (or the source and destination buffers are
--   the same buffer), and the source and destination regions overlap.</li>
--   <li><a>CL_OUT_OF_HOST_MEMORY</a>, Returned in the event of a failure
--   to allocate resources required by the OpenCL implementation on the
--   host.</li>
--   <li><a>CL_OUT_OF_RESOURCES</a>, Returned in the event of a failure to
--   queue the execution instance of kernel on the command-queue because of
--   insufficient resources needed to execute the kernel.</li>
--   <li><a>CL_PROFILING_INFO_NOT_AVAILABLE</a>, Returned if the
--   <a>CL_QUEUE_PROFILING_ENABLE</a> flag is not set for the command-queue
--   and the profiling information is currently not available (because the
--   command identified by event has not completed).</li>
--   <li><a>CL_SUCCESS</a>, Indicates that the function executed
--   successfully.</li>
--   </ul>
data CLError
CL_PLATFORM_NOT_FOUND_KHR :: CLError
CL_BUILD_PROGRAM_FAILURE :: CLError
CL_COMPILER_NOT_AVAILABLE :: CLError
CL_DEVICE_NOT_AVAILABLE :: CLError
CL_DEVICE_NOT_FOUND :: CLError
CL_IMAGE_FORMAT_MISMATCH :: CLError
CL_IMAGE_FORMAT_NOT_SUPPORTED :: CLError
CL_INVALID_ARG_INDEX :: CLError
CL_INVALID_ARG_SIZE :: CLError
CL_INVALID_ARG_VALUE :: CLError
CL_INVALID_BINARY :: CLError
CL_INVALID_BUFFER_SIZE :: CLError
CL_INVALID_BUILD_OPTIONS :: CLError
CL_INVALID_COMMAND_QUEUE :: CLError
CL_INVALID_CONTEXT :: CLError
CL_INVALID_DEVICE :: CLError
CL_INVALID_DEVICE_TYPE :: CLError
CL_INVALID_EVENT :: CLError
CL_INVALID_EVENT_WAIT_LIST :: CLError
CL_INVALID_GL_OBJECT :: CLError
CL_INVALID_GLOBAL_OFFSET :: CLError
CL_INVALID_HOST_PTR :: CLError
CL_INVALID_IMAGE_FORMAT_DESCRIPTOR :: CLError
CL_INVALID_IMAGE_SIZE :: CLError
CL_INVALID_KERNEL_NAME :: CLError
CL_INVALID_KERNEL :: CLError
CL_INVALID_KERNEL_ARGS :: CLError
CL_INVALID_KERNEL_DEFINITION :: CLError
CL_INVALID_MEM_OBJECT :: CLError
CL_INVALID_OPERATION :: CLError
CL_INVALID_PLATFORM :: CLError
CL_INVALID_PROGRAM :: CLError
CL_INVALID_PROGRAM_EXECUTABLE :: CLError
CL_INVALID_QUEUE_PROPERTIES :: CLError
CL_INVALID_SAMPLER :: CLError
CL_INVALID_VALUE :: CLError
CL_INVALID_WORK_DIMENSION :: CLError
CL_INVALID_WORK_GROUP_SIZE :: CLError
CL_INVALID_WORK_ITEM_SIZE :: CLError
CL_MAP_FAILURE :: CLError
CL_MEM_OBJECT_ALLOCATION_FAILURE :: CLError
CL_MEM_COPY_OVERLAP :: CLError
CL_OUT_OF_HOST_MEMORY :: CLError
CL_OUT_OF_RESOURCES :: CLError
CL_PROFILING_INFO_NOT_AVAILABLE :: CLError
CL_SUCCESS :: CLError
type CLint = CInt
type CLuint = CUInt
type CLulong = CULLong
