-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Conduit interface for cryptographic operations (from crypto-api).
--   
@package crypto-conduit
@version 0.5.5


-- | This module contains wrappers for cryptographic functions using the
--   <tt>conduit</tt> package. Currently there is support for hashes, HMACs
--   and many modes of block ciphers (but not everything
--   <tt>crypto-api</tt> supports has a counterpart here). All functions on
--   this package work in constant memory.
module Crypto.Conduit

-- | A <a>Sink</a> that hashes a stream of <a>ByteString</a><tt>s</tt> and
--   creates a digest <tt>d</tt>.
sinkHash :: (Monad m, Hash ctx d) => Consumer ByteString m d

-- | Hashes the whole contents of the given file in constant memory. This
--   function is just a convenient wrapper around <a>sinkHash</a> defined
--   as:
--   
--   <pre>
--   hashFile fp = <a>liftIO</a> $ <a>runResourceT</a> (<a>sourceFile</a> fp <a>$$</a> <a>sinkHash</a>)
--   </pre>
hashFile :: (MonadIO m, Hash ctx d) => FilePath -> m d

-- | A <a>Sink</a> that computes the HMAC of a stream of
--   <a>ByteString</a><tt>s</tt> and creates a digest <tt>d</tt>.
sinkHmac :: (Monad m, Hash ctx d) => MacKey ctx d -> Consumer ByteString m d

-- | A <a>Conduit</a> that encrypts a stream of <a>ByteString</a><tt>s</tt>
--   using ECB mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise. (Note that ECB has many
--   undesirable cryptographic properties, please avoid it if you don't
--   know what you're doing.)
conduitEncryptEcb :: (Monad m, BlockCipher k) => k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that decrypts a stream of <a>ByteString</a><tt>s</tt>
--   using ECB mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitDecryptEcb :: (Monad m, BlockCipher k) => k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that encrypts a stream of <a>ByteString</a><tt>s</tt>
--   using CBC mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitEncryptCbc :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that decrypts a stream of <a>ByteString</a><tt>s</tt>
--   using CBC mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitDecryptCbc :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that encrypts a stream of <a>ByteString</a><tt>s</tt>
--   using CFB mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitEncryptCfb :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that decrypts a stream of <a>ByteString</a><tt>s</tt>
--   using CFB mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitDecryptCfb :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that encrypts a stream of <a>ByteString</a><tt>s</tt>
--   using OFB mode. Expects the input length to be a multiple of the block
--   size of the cipher and fails otherwise.
conduitEncryptOfb :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | Synonym for <a>conduitEncryptOfb</a>, since for OFB mode both
--   encryption and decryption are the same.
conduitDecryptOfb :: (Monad m, BlockCipher k) => k -> IV k -> Conduit ByteString m ByteString

-- | A <a>Conduit</a> that encrypts a stream of <a>ByteString</a><tt>s</tt>
--   using CTR mode. The input may have any length, even non-multiples of
--   the block size.
conduitEncryptCtr :: (Monad m, BlockCipher k) => k -> IV k -> (IV k -> IV k) -> Conduit ByteString m ByteString

-- | Synonym for <a>conduitEncryptCtr</a>, since for CTR mode both
--   encryption and decryption are the same.
conduitDecryptCtr :: (Monad m, BlockCipher k) => k -> IV k -> (IV k -> IV k) -> Conduit ByteString m ByteString

-- | An infinite stream of bytes generated by a block cipher on CTR mode.
sourceCtr :: (Monad m, BlockCipher k) => k -> IV k -> Producer m ByteString

-- | A <a>Sink</a> that computes the CBC-MAC of a stream of
--   <a>ByteString</a><tt>s</tt> and creates a digest (already encoded in a
--   <a>ByteString</a>, since we're using a block cipher). Expects the
--   input length to be a multiple of the block size of the cipher and
--   fails otherwise. (Note that CBC-MAC is not secure for variable-length
--   messages.)
sinkCbcMac :: (Monad m, BlockCipher k) => k -> Consumer ByteString m ByteString

-- | A <a>Conduit</a> that takes arbitrary <a>ByteString</a><tt>s</tt> and
--   outputs <a>Block</a><tt>s</tt>. Each <a>Full</a> block will have a
--   length that is multiple of the given block size (either exactly the
--   block size or a multiple of at least 1x the block size, depending on
--   the <a>BlockMode</a>). All <a>Block</a><tt>s</tt> beside the last one
--   will be <a>Full</a>. The last block will always be <a>LastOne</a> with
--   less bytes than the block size, possibly zero.
blocked :: Monad m => BlockMode -> ByteLength -> Conduit ByteString m Block

-- | How <a>Block</a>s should be returned, either with strictly the block
--   size or with a multiple of at least 1x the block size.
data BlockMode
StrictBlockSize :: BlockMode
AnyMultiple :: BlockMode

-- | A block returned by <a>blocked</a>.
data Block
Full :: ByteString -> Block
LastOne :: ByteString -> Block
instance Eq BlockMode
instance Ord BlockMode
instance Show BlockMode
instance Enum BlockMode
instance Eq Block
instance Ord Block
instance Show Block
