-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Conversions between algebraic classes and F-algebras.
--   
@package algebraic-classes
@version 0.5.2


module Data.Algebra.Internal

-- | The signature datatype for the class <tt>c</tt>.
class Traversable f => AlgebraSignature f where type family Class f :: * -> Constraint
evaluate :: (AlgebraSignature f, Class f b) => f b -> b
class Algebra f a
algebra :: (Algebra f a, AlgebraSignature f) => f a -> a

-- | If you just want to applicatively lift existing instances, you can use
--   this default implementation of <a>algebra</a>.
algebraA :: (Applicative g, Class f b, AlgebraSignature f) => f (g b) -> g b
instance (Monoid m, Class f b) => Algebra f (Const m b)
instance (Class f b) => Algebra f (STM b)
instance (Class f b) => Algebra f (Either a b)
instance (Class f b) => Algebra f (Maybe b)
instance (Class f b) => Algebra f (IO b)
instance (Class f b) => Algebra f (a -> b)
instance (Class f m, Class f n) => Algebra f (m, n)
instance Algebra f ()


module Data.Algebra.TH

-- | Derive an instance for an algebraic class. For example:
--   
--   <pre>
--   deriveInstance [t| (Num m, Num n) =&gt; Num (m, n) |]
--   </pre>
--   
--   To be able to derive an instance for <tt>a</tt> of class <tt>c</tt>,
--   we need an instance of <tt><a>Algebra</a> f a</tt>, where <tt>f</tt>
--   is the signature of <tt>c</tt>.
--   
--   <a>deriveInstance</a> will generate a signature for the class if there
--   is no signature in scope.
deriveInstance :: Q Type -> Q [Dec]

-- | Derive an instance for an algebraic class with a given partial
--   implementation. For example:
--   
--   <pre>
--   deriveInstanceWith [t| Num n =&gt; Num (Integer -&gt; n) |] 
--     [d|
--       fromInteger x y = fromInteger (x + y)
--     |]
--   </pre>
deriveInstanceWith :: Q Type -> Q [Dec] -> Q [Dec]

-- | Derive an instance for an algebraic class with a given partial
--   implementation, but don't generate the signature. This is for when you
--   want to derive several instances of the same class, but can't splice
--   the results directly. In that case <a>deriveSignature</a> can't detect
--   it has already generated the signature earlier.
deriveInstanceWith_skipSignature :: Q Type -> Q [Dec] -> Q [Dec]

-- | Derive a signature for an algebraic class. For example:
--   
--   <pre>
--   deriveSignature ''Monoid
--   </pre>
--   
--   The above would generate the following:
--   
--   <pre>
--   data MonoidSignature a = Op_mempty | Op_mappend a a | Op_mconcat [a]
--     deriving (Functor, Foldable, Traversable, Eq, Ord)
--   
--   type instance Signature Monoid = MonoidSignature
--   
--   instance AlgebraSignature MonoidSignature where
--     type Class MonoidSignature = Monoid
--     evaluate Op_mempty = mempty
--     evaluate (Op_mappend a b) = mappend a b
--     evaluate (Op_mconcat ms) = mconcat ms  
--   
--   instance Show a =&gt; Show (MonoidSignature a) where
--     showsPrec d Op_mempty          = showParen (d &gt; 10) $ showString "mempty"
--     showsPrec d (Op_mappend a1 a2) = showParen (d &gt; 10) $ showString "mappend" . showChar ' ' . showsPrec 11 a1 . showChar ' ' . showsPrec 11 a2
--     showsPrec d (Op_mconcat a1)    = showParen (d &gt; 10) $ showString "mconcat" . showChar ' ' . showsPrec 11 a1
--   </pre>
--   
--   <a>deriveSignature</a> creates the signature data type and an instance
--   for it of the <a>AlgebraSignature</a> class.
--   <tt>DeriveTraversable</tt> is used the generate the <a>Traversable</a>
--   instance of the signature.
--   
--   This will do nothing if there is already a signature for the class in
--   scope.
deriveSignature :: Name -> Q [Dec]
data SignatureTH
SignatureTH :: Name -> Name -> [OperationTH] -> SignatureTH
signatureName :: SignatureTH -> Name
typeVarName :: SignatureTH -> Name
operations :: SignatureTH -> [OperationTH]
data OperationTH
OperationTH :: Name -> Name -> Int -> Con -> Fixity -> OperationTH
functionName :: OperationTH -> Name
operationName :: OperationTH -> Name
arity :: OperationTH -> Int
constructor :: OperationTH -> Con
fixity :: OperationTH -> Fixity
getSignatureInfo :: Name -> Q SignatureTH
buildSignatureDataType :: SignatureTH -> [Dec]
signatureInstances :: Name -> SignatureTH -> [Dec]


module Data.Algebra

-- | Derive an instance for an algebraic class. For example:
--   
--   <pre>
--   deriveInstance [t| (Num m, Num n) =&gt; Num (m, n) |]
--   </pre>
--   
--   To be able to derive an instance for <tt>a</tt> of class <tt>c</tt>,
--   we need an instance of <tt><a>Algebra</a> f a</tt>, where <tt>f</tt>
--   is the signature of <tt>c</tt>.
--   
--   <a>deriveInstance</a> will generate a signature for the class if there
--   is no signature in scope.
deriveInstance :: Q Type -> Q [Dec]

-- | Derive an instance for an algebraic class with a given partial
--   implementation. For example:
--   
--   <pre>
--   deriveInstanceWith [t| Num n =&gt; Num (Integer -&gt; n) |] 
--     [d|
--       fromInteger x y = fromInteger (x + y)
--     |]
--   </pre>
deriveInstanceWith :: Q Type -> Q [Dec] -> Q [Dec]
class Algebra f a
algebra :: (Algebra f a, AlgebraSignature f) => f a -> a

-- | If you just want to applicatively lift existing instances, you can use
--   this default implementation of <a>algebra</a>.
algebraA :: (Applicative g, Class f b, AlgebraSignature f) => f (g b) -> g b

-- | The signature datatype for the class <tt>c</tt>.
class Traversable f => AlgebraSignature f where type family Class f :: * -> Constraint
evaluate :: (AlgebraSignature f, Class f b) => f b -> b
