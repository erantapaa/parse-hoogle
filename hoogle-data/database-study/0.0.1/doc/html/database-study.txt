-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Demonstrate how a database can be implemented the functional way
--   
--   This package consists of some toy modules that translate the
--   well-known company database example. We show how to implement various
--   queries and database updates in a way that is both simple and clean.
--   It is recommended to download the package with <tt>cabal fetch</tt>,
--   extract it in a local directory and run <tt>make ghci</tt>.
--   Additionally open a text editor and follow the examples in the
--   <tt>Example</tt> directory. The first queries in the modules
--   <a>Example.RelationalAlgebra</a> and <a>Example.QueryMonad</a> are the
--   same but in different styles.
@package database-study
@version 0.0.1

module Query
showTable :: Show a => [a] -> IO ()
cross :: [a] -> [b] -> [(a, b)]
join :: Eq f => (a -> f) -> (b -> f) -> [a] -> [b] -> [(a, b)]
average :: Fractional a => [a] -> a
averageInt :: Integral a => [a] -> a
groupBy :: Ord key => (a -> key) -> [a] -> [(key, [a])]

module Company
newtype DeptNo
DeptNo :: Int -> DeptNo
data Dept
Dept :: DeptNo -> String -> String -> Dept
deptnoDept :: Dept -> DeptNo
dname :: Dept -> String
loc :: Dept -> String
dept :: [Dept]
data Job
Clerk :: Job
Salesman :: Job
Manager :: Job
Analyst :: Job
President :: Job
newtype EmpNo
EmpNo :: Int -> EmpNo
data Emp
Emp :: EmpNo -> String -> Job -> Maybe EmpNo -> Int -> DeptNo -> Emp
empno :: Emp -> EmpNo
ename :: Emp -> String
job :: Emp -> Job
mgr :: Emp -> Maybe EmpNo
sal :: Emp -> Int
deptnoEmp :: Emp -> DeptNo
emp :: [Emp]
class DeptNoField r
deptno :: DeptNoField r => r -> DeptNo
instance Eq Emp
instance Ord Emp
instance Show Emp
instance Eq EmpNo
instance Ord EmpNo
instance Show EmpNo
instance Eq Job
instance Ord Job
instance Enum Job
instance Show Job
instance Bounded Job
instance Eq Dept
instance Ord Dept
instance Show Dept
instance Eq DeptNo
instance Ord DeptNo
instance Show DeptNo
instance DeptNoField Emp
instance DeptNoField Dept


-- | some queries implemented using operations from relational algebra
module Example.RelationalAlgebra

-- | all employees
employees :: [Emp]

-- | all clerks
clerks :: [Emp]

-- | all clerks with salary at least 1000
richClerks :: [Emp]

-- | all employees in research department
researchers :: [Emp]
researchers0 :: [Emp]
hierarchy :: Forest Emp
hierarchyFast :: Forest Emp

-- | A recursive query: Compute the total salary for each manager and the
--   total set of employees he conducts.
teamSalaries :: [(String, Int)]


-- | some queries implemented using the list monad
--   
--   A special Table type instead of plain lists could provide an efficient
--   implementation.
module Example.QueryMonad

-- | all employees
employees :: [Emp]

-- | all clerks
clerks :: [Emp]

-- | all clerks with salary at least 1000
richClerks :: [Emp]

-- | all employees in research department
researchers :: [Emp]
researchers0 :: [Emp]

-- | names of all employees and their managers if the employee has a
--   manager so far
managers :: [(String, String)]

-- | names of all employees and their managers; if the employee has no
--   manager, return an empty string
managers0 :: [(String, String)]

-- | names of managers that have at least one employee
realManagers :: [String]

-- | managers that have at least one employee
realManagersFull :: [Emp]

-- | managers that have at least one employee, sorted by their names.
realManagersSortedFull :: [Emp]

-- | maximum salary amongst all employees
maximumSalary :: Int

-- | employee with maximum salary without a back-join
richestEmployee :: Emp

-- | employees grouped by their managers implemented with a sub-query
teams :: [(String, [String])]

-- | employees grouped by their managers implemented with a GROUP BY
teams0 :: [(String, [String])]

-- | average salary in each department
averageSalariesInDepartments :: [(String, Int)]

-- | manager with most employees
managerOfLargestTeam :: (String, Int)

-- | A recursive query: Compute the total salary for each manager and the
--   total set of employees he conducts.
teamSalaries0 :: [(String, Int)]
teamSalaries :: [(String, Int)]

module Table
create :: a -> IO (IORef a)
from :: IORef a -> IO a
insert :: IORef [a] -> a -> IO ()
delete :: IORef [a] -> (a -> Bool) -> IO ()
update :: IORef [a] -> (a -> a) -> IO ()
updateWhere :: IORef [a] -> (a -> a) -> (a -> Bool) -> IO ()


-- | demonstrate mutable tables
module Example.UpdateMonad
main :: IO ()
