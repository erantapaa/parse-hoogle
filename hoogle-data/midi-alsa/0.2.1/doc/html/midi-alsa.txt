-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convert between datatypes of the midi and the alsa packages
--   
--   MIDI is the Musical Instrument Digital Interface, ALSA is the Advanced
--   Linux Sound Architecture. This package provides accessors to data
--   structures of the ALSA sequencer interface via the more specific types
--   from the <tt>midi</tt> package. The package also contains a orphan
--   instances for the <tt>alsa-seq:Event</tt> type of the
--   <tt>midi:Message.Class.Check</tt> and
--   <tt>midi:Message.Class.Query</tt> classes.
@package midi-alsa
@version 0.2.1

module Sound.MIDI.ALSA
toChannel :: Channel -> Channel
fromChannel :: Channel -> Channel
toPitch :: Pitch -> Pitch
fromPitch :: Pitch -> Pitch
toVelocity :: Velocity -> Velocity
fromVelocity :: Velocity -> Velocity

-- | Return a <tt>NoteOff</tt> if input is a <tt>NoteOn</tt> with velocity
--   zero. This is a trick of the MIDI standard in order to allow
--   compression of a series of note events. After normalization you can
--   safely match on <tt>NoteOn</tt> and <tt>NoteOff</tt>.
normalizeNote :: (NoteEv, Velocity) -> (NoteEv, Velocity)
normalNoteFromEvent :: NoteEv -> Note -> (NoteEv, Velocity)

-- | Controllers from <tt>0x78</tt> to <tt>0x7F</tt> are special, you must
--   assert that the controller number is in the range <tt>0</tt> to
--   <tt>0x77</tt>.
toController :: Parameter -> Controller
fromController :: Controller -> Parameter
toProgram :: Value -> Program
fromProgram :: Program -> Value
noteEvent :: Channel -> Pitch -> Velocity -> Velocity -> Int -> Note
controllerEvent :: Channel -> Controller -> Int -> Ctrl
programChangeEvent :: Channel -> Program -> Ctrl
modeEvent :: Channel -> T -> Ctrl
noteChannel :: T Note Channel
notePitch :: T Note Pitch

-- | This may not yield what you expect. See <a>normalizeNote</a>.
noteVelocity :: T Note Velocity
ctrlChannel :: T Ctrl Channel

-- | This is undefined, if the controller is no regular controller but a
--   channel mode message. Better use <a>ctrlControllerMode</a>.
ctrlController :: T Ctrl Controller
data ControllerMode
Controller :: Controller -> Int -> ControllerMode
Mode :: T -> ControllerMode
ctrlControllerMode :: T Ctrl ControllerMode
ctrlValue :: T Ctrl Int
ctrlProgram :: T Ctrl Program
instance Show ControllerMode
instance Eq ControllerMode

module Sound.MIDI.ALSA.Check

-- | All methods have default implementations that return <a>Nothing</a>.
--   This helps implementing event data types that support only a subset of
--   types of events.
--   
--   Maybe a better approach is to provide type classes for every type of
--   event and make <a>C</a> a subclass of all of them.
class C event
note :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)
program :: C event => Channel -> event -> Maybe Program
anyController :: C event => Channel -> event -> Maybe (Controller, Int)
pitchBend :: C event => Channel -> event -> Maybe Int
channelPressure :: C event => Channel -> event -> Maybe Int
mode :: C event => Channel -> event -> Maybe T

-- | Warning: This returns note events as they are, that is, a <tt>NoteOff
--   p 64</tt> might be encoded as such or as <tt>NoteOn p 0</tt> depending
--   on the content of <tt>event</tt>. For normalized results you may use
--   <a>noteExplicitOff</a>.
note :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)
program :: C event => Channel -> event -> Maybe Program
anyController :: C event => Channel -> event -> Maybe (Controller, Int)
controller :: C event => Channel -> Controller -> event -> Maybe Int
mode :: C event => Channel -> event -> Maybe T
pitchBend :: C event => Channel -> event -> Maybe Int
channelPressure :: C event => Channel -> event -> Maybe Int
instance C Data
instance C T

module Sound.MIDI.ALSA.Query

-- | All methods have default implementations that return <a>Nothing</a>.
--   This helps implementing event data types that support only a subset of
--   types of events.
--   
--   Maybe a better approach is to provide type classes for every type of
--   event and make <a>C</a> a subclass of all of them.
class C event
note :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))
program :: C event => event -> Maybe (Channel, Program)
anyController :: C event => event -> Maybe (Channel, (Controller, Int))
pitchBend :: C event => event -> Maybe (Channel, Int)
channelPressure :: C event => event -> Maybe (Channel, Int)
mode :: C event => event -> Maybe (Channel, T)

-- | Warning: This returns note events as they are, that is, a <tt>NoteOff
--   p 64</tt> might be encoded as such or as <tt>NoteOn p 0</tt> depending
--   on the content of <tt>event</tt>. For normalized results you may use
--   <a>noteExplicitOff</a>.
note :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))
program :: C event => event -> Maybe (Channel, Program)
anyController :: C event => event -> Maybe (Channel, (Controller, Int))
mode :: C event => event -> Maybe (Channel, T)
pitchBend :: C event => event -> Maybe (Channel, Int)
channelPressure :: C event => event -> Maybe (Channel, Int)
instance C Data
instance C T

module Sound.MIDI.ALSA.Construct
class C event
note :: C event => Channel -> (Velocity, Pitch, Bool) -> event
program :: C event => Channel -> Program -> event
anyController :: C event => Channel -> (Controller, Int) -> event
pitchBend :: C event => Channel -> Int -> event
channelPressure :: C event => Channel -> Int -> event
mode :: C event => Channel -> T -> event

-- | Warning: This constructs a note events as is, that is, a <tt>NoteOff p
--   64</tt> is encoded as such and will not be converted to <tt>NoteOn p
--   0</tt>. If you want such a conversion, you may use
--   <a>noteImplicitOff</a>.
note :: C event => Channel -> (Velocity, Pitch, Bool) -> event

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => Channel -> (Velocity, Pitch, Bool) -> event

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => Channel -> (Velocity, Pitch, Bool) -> event
program :: C event => Channel -> Program -> event
anyController :: C event => Channel -> (Controller, Int) -> event
mode :: C event => Channel -> T -> event
pitchBend :: C event => Channel -> Int -> event
channelPressure :: C event => Channel -> Int -> event
instance C Data
instance C T
