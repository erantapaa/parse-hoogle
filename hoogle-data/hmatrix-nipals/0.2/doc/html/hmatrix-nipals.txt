-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | NIPALS method for Principal Components Analysis on large data-sets.
--   
--   NIPALS -- Nonlinear Iterative Partial Least Squares
--   <a>http://en.wikipedia.org/wiki/NIPALS</a>, is a method for
--   iteratively finding the left singular vectors of a large matrix. In
--   other words it discovers the largest principal component
--   <a>http://en.wikipedia.org/wiki/Principal_component</a> of a set of
--   mean-centred samples, along with the score (the magnitude of the
--   principal component) for each sample, and the residual of each sample
--   that is orthogonal to the principal component. By repeating the
--   procedure on the residuals, the second principal component is found,
--   and so on.
--   
--   The advantage of NIPALS over more traditional methods, like SVD, is
--   that it is memory efficient, and can complete early if only a small
--   number of principal components are needed. It is also simple to
--   implement correctly. Additionally, because it doesn't pre-condition
--   the sample matrix in any way, it can be implemented with only two
--   sequential passes per iteration through the sample data, which is much
--   more efficient than random accesses if the data-set is too large to
--   fit in memory.
--   
--   NIPALS is not generally recommended because sample matrices where the
--   largest eigenvalues are close in magnitude will cause NIPALS to
--   converge very slowly. For sparse matrices, use Lanczos methods
--   <a>http://en.wikipedia.org/wiki/Lanczos_algorithm</a>, and for dense
--   matrices, random-projection methods
--   <a>http://amath.colorado.edu/faculty/martinss/Pubs/2009_HMT_random_review.pdf</a>
--   can be used. However, these methods are harder to implement in a
--   single pass. If you know of a good, single-pass, and memory-efficient
--   implementation of either of these methods, please contact the author.
@package hmatrix-nipals
@version 0.2


-- | Nonlinear Iterative Partial Least Squares
module Numeric.LinearAlgebra.NIPALS

-- | Calculate the first principal component of a set of samples.
--   
--   Each row in the matrix is one sample. Note that this is transposed
--   compared to the implementation of principal components using
--   <a>svd</a> or <a>leftSV</a>
--   
--   Example:
--   
--   <pre>
--   let (pc,scores,residuals) = firstPC $ fromRows samples
--   </pre>
--   
--   This is calculated by providing a default estimate of the scores to
--   <a>firstPCFromScores</a>
firstPC :: Matrix Double -> (Vector Double, Vector Double, Matrix Double)

-- | Calculate the first principal component of a set of samples given a
--   starting estimate of the scores.
--   
--   Each row in the matrix is one sample. Note that this is transposed
--   compared to the implementation of principal components using
--   <a>svd</a> or <a>leftSV</a>
--   
--   The second argument is a starting guess for the score vector. If this
--   is close to the actual score vector, then this will cause the algorthm
--   to converge much faster.
--   
--   Example:
--   
--   <pre>
--   let (pc,scores,residuals) = firstPCFromScores (fromRows samples) scoresGuess
--   </pre>
firstPCFromScores :: Matrix Double -> Vector Double -> (Vector Double, Vector Double, Matrix Double)

-- | Calculate the first principal component -- calculating the samples
--   fresh on every pass.
--   
--   This function calculates the exact same results as
--   <a>firstPCFromScores</a> (minus the residual), but instead of an input
--   <a>Matrix</a>, it takes a monad action that yields the list of
--   samples, and it guarantees that the list returned by the action will
--   be consumed in a single pass. However the action may be demanded many
--   times.
--   
--   The residual can't be calculated lazily, like it is in
--   <a>firstPCFromScores</a>, because the samples would need to be
--   demanded. Instead, to calculate the residual use <a>residual</a>.
--   
--   There is no corresponding <tt>firstPCM</tt> that guesses the initial
--   score vector for you because if you need to use this function instead
--   of <a>firstPC</a>, then you really should come up with a reasonable
--   starting point or it will take forever.
firstPCFromScoresM :: Monad m => m [Vector Double] -> Vector Double -> m (Vector Double, Vector Double)

-- | Calculate the residuals of a series of samples given a component and
--   score vector.
--   
--   <pre>
--   (p,t) &lt;- firstPCFromScoresM samplesM (randomVector 0 Gaussian numSamples)
--   samples &lt;- samplesM
--   let r = residual samples p t
--   </pre>
residual :: [Vector Double] -> Vector Double -> Vector Double -> [Vector Double]
