-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common not-so-common functions for lists
--   
@package list-extras
@version 0.4.1.4


-- | This module provides variants of the <a>maximum</a> and <a>minimum</a>
--   functions which return the elements for which some function is
--   maximized or minimized.
module Data.List.Extras.Argmax

-- | Apply a list function safely, i.e. when the list is non-empty. All
--   other functions will throw errors on empty lists, so use this to make
--   your own safe variations.
catchNull :: ([a] -> b) -> ([a] -> Maybe b)

-- | Return an element of the list which maximizes the function according
--   to a user-defined ordering.
argmaxBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> a

-- | Return all elements of the list which maximize the function according
--   to a user-defined ordering.
argmaxesBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> [a]

-- | Return an element of the list which maximizes the function according
--   to a user-defined ordering, and return the value of the function at
--   that element as well.
argmaxWithMaxBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> (a, b)

-- | Return all elements of the list which maximize the function according
--   to a user-defined ordering, and return the value of the function at
--   those elements as well.
argmaxesWithMaxBy :: (b -> b -> Ordering) -> (a -> b) -> [a] -> ([a], b)

-- | Return an element of the list which maximizes the function.
argmax :: Ord b => (a -> b) -> [a] -> a

-- | Return all elements of the list which maximize the function.
argmaxes :: Ord b => (a -> b) -> [a] -> [a]

-- | Return an element of the list which maximizes the function, and return
--   the value of the function at that element as well.
argmaxWithMax :: Ord b => (a -> b) -> [a] -> (a, b)

-- | Return all elements of the list which maximize the function, and
--   return the value of the function at those elements as well.
argmaxesWithMax :: Ord b => (a -> b) -> [a] -> ([a], b)

-- | Return an element of the list which minimizes the function.
argmin :: Ord b => (a -> b) -> [a] -> a

-- | Return all elements of the list which minimize the function.
argmins :: Ord b => (a -> b) -> [a] -> [a]

-- | Return an element of the list which minimizes the function, and return
--   the value of the function at that element as well.
argminWithMin :: Ord b => (a -> b) -> [a] -> (a, b)

-- | Return all elements of the list which minimize the function, and
--   return the value of the function at those elements as well.
argminsWithMin :: Ord b => (a -> b) -> [a] -> ([a], b)


-- | This module provides safe zipping functions which will fail (return
--   <a>Nothing</a>) on uneven length lists.
module Data.List.Extras.Pair

-- | A generic version of <a>pair</a>. The first argument is a tuple
--   homomorphism (i.e. a function for how to combine values from the two
--   lists), the second two arguments form a list homomorphism (i.e. so you
--   can <a>foldr</a> the <tt>[c]</tt> list directly without actually
--   constructing it).
--   
--   In order to evaluate to WHNF <a>pairWithBy</a> is strict in both list
--   arguments, as it must be, to determine that the lists are of the same
--   length. This means it can survive one infinite list (yielding
--   <a>Nothing</a>) but that it can't survive two. The implementation is
--   very efficient and uses a tight tail-recursive loop, however with
--   extremely long lists it will be churning through heap and that
--   tightness can make it hard to interrupt (lists of 1 million elements
--   return in 1~2 seconds, but lists of 10 million can lock your system
--   up).
pairWithBy :: (a -> b -> c) -> (c -> d -> d) -> d -> [a] -> [b] -> Maybe d

-- | A safe version of <a>zipWith</a>.
pairWith :: (a -> b -> c) -> [a] -> [b] -> Maybe [c]

-- | A safe version of <a>zip</a> that uses a user-defined list
--   homomorphism.
pairBy :: ((a, b) -> d -> d) -> d -> [a] -> [b] -> Maybe d

-- | A safe version of <a>zip</a>.
pair :: [a] -> [b] -> Maybe [(a, b)]

-- | A bijection from a list of functions and a list of arguments to a list
--   of results of applying the functions bijectively.
biject :: [a -> b] -> [a] -> Maybe [b]

-- | A version of <a>biject</a> that applies functions strictly. N.B. the
--   list is still lazily evaluated, this just makes the functions strict
--   in their argument.
biject' :: [a -> b] -> [a] -> Maybe [b]

-- | An unsafe variant of <a>pairWithBy</a> to fill out the interface.
zipWithBy :: (a -> b -> c) -> (c -> d -> d) -> d -> [a] -> [b] -> d

-- | A version of <a>zip</a> that uses a user-defined list homomorphism.
zipBy :: ((a, b) -> d -> d) -> d -> [a] -> [b] -> d


-- | This module provides least-strict functions for getting a list's
--   length and doing natural things with it.
--   
--   The regular version of <tt>length</tt> will traverse the entire spine
--   of the list in order to return an answer. For comparing the length
--   against some bound, that is by far too strict. Being too strict can
--   cause a space leak by expanding a lazy list before necessary (or more
--   than is ever necessary). And it can lead to unnecessarily
--   non-terminating programs when trying to determine if an infinite list
--   is longer or shorter than some finite bound.
--   
--   A nicer version of <tt>length</tt> would return some lazy
--   approximation of an answer which retains the proper semantics. An
--   option for doing this is to return Peano integers which can be
--   decremented as much as necessary and no further (i.e. at most one more
--   than the bound). Of course, Peano integers are woefully inefficient.
--   This module provides functions with the same lazy effect but does so
--   efficiently instead.
--   
--   As of version 0.3.0 the GHC rules to automatically rewrite certain
--   calls to <a>length</a> into our least-strict versions have been
--   <i>removed</i> for more consistent and predictable semantics. All
--   clients should explicitly call these least-strict functions if they
--   want the least-strict behavior.
module Data.List.Extras.LazyLength

-- | A variant of <a>length</a> which is least-strict for comparing against
--   a boundary length.
--   
--   <tt>lengthBound</tt> is polymorphic in the return of the helper
--   function so we can use <a>compare</a> as well as <a>&gt;</a>,
--   <a>&gt;=</a>, <a>==</a>, <a>/=</a>, <a>&lt;=</a>, <a>&lt;</a>. If you
--   want to use any other functions, know that we only preserve the
--   ordering of the list's length vs the boundary length and so the
--   function should not rely on the true values of either of the numbers
--   being compared.
lengthBound :: Int -> (Int -> Int -> a) -> [b] -> a

-- | A variant of <a>length</a> which is least-strict for comparing the
--   lengths of two lists. This is as strict as the length of the shorter
--   list (which allows comparing an infinite list against a finite list).
--   
--   If you're going to immediately follow this with a <a>zip</a> function
--   then see <a>Data.List.Extras.Pair</a> instead.
lengthCompare :: [a] -> [b] -> Ordering


-- | This module provides a single header for all
--   <tt>Data.List.Extras.*</tt> modules and provides a small number of
--   other utility functions.
module Data.List.Extras

-- | Pattern matching for lists, as a first-class function. (Could also be
--   considered as a non-recursive <a>foldr</a>.) If the list argument is
--   <tt>[]</tt> then the default argument is returned; otherwise the
--   function is called with the head and tail of the list.
list :: (a -> [a] -> b) -> b -> [a] -> b


-- | This module provides the <a>Prelude</a> but removing all the list
--   functions. This is helpful for modules that overload those function
--   names to work for other types. Note that on GHC 7.6 and above
--   <tt>catch</tt> is no longer exported from the Prelude, and also not
--   re-exported from here; whereas, on earlier versions of GHC (and
--   non-GHC compilers) we still re-export it.
--   
--   Be sure to disable the implicit importing of the prelude when you
--   import this one (by passing <tt>-fno-implicit-prelude</tt> for GHC, or
--   by explicitly importing the prelude with an empty import list for most
--   implementations).
module Prelude.Listless

-- | Strict (call-by-value) application, defined in terms of <a>seq</a>.
($!) :: (a -> b) -> a -> b

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
data Bool :: *
False :: Bool
True :: Bool

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
data Either a b :: * -> * -> *
Left :: a -> Either a b
Right :: b -> Either a b

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   Minimal complete definition: <a>pi</a>, <a>exp</a>, <a>log</a>,
--   <a>sin</a>, <a>cos</a>, <a>sinh</a>, <a>cosh</a>, <a>asin</a>,
--   <a>acos</a>, <a>atan</a>, <a>asinh</a>, <a>acosh</a> and <a>atanh</a>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
sqrt :: Floating a => a -> a
log :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
tan :: Floating a => a -> a
cos :: Floating a => a -> a
asin :: Floating a => a -> a
atan :: Floating a => a -> a
acos :: Floating a => a -> a
sinh :: Floating a => a -> a
tanh :: Floating a => a -> a
cosh :: Floating a => a -> a
asinh :: Floating a => a -> a
atanh :: Floating a => a -> a
acosh :: Floating a => a -> a

-- | Fractional numbers, supporting real division.
--   
--   Minimal complete definition: <a>fromRational</a> and (<a>recip</a> or
--   <tt>(<a>/</a>)</tt>)
class Num a => Fractional a
(/) :: Fractional a => a -> a -> a
recip :: Fractional a => a -> a
fromRational :: Fractional a => Rational -> a

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Arbitrary-precision integers.
data Integer :: *

-- | Integral numbers, supporting integer division.
--   
--   Minimal complete definition: <a>quotRem</a> and <a>toInteger</a>
class (Real a, Enum a) => Integral a
quot :: Integral a => a -> a -> a
rem :: Integral a => a -> a -> a
div :: Integral a => a -> a -> a
mod :: Integral a => a -> a -> a
quotRem :: Integral a => a -> a -> (a, a)
divMod :: Integral a => a -> a -> (a, a)
toInteger :: Integral a => a -> Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Minimal complete definition: <a>&gt;&gt;=</a> and <a>return</a>.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <pre>
--   return a &gt;&gt;= k  ==  k a
--   m &gt;&gt;= return  ==  m
--   m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  ==  (m &gt;&gt;= k) &gt;&gt;= h
--   </pre>
--   
--   Instances of both <a>Monad</a> and <a>Functor</a> should additionally
--   satisfy the law:
--   
--   <pre>
--   fmap f xs  ==  xs &gt;&gt;= return . f
--   </pre>
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Monad (m :: * -> *)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a

-- | Basic numeric class.
--   
--   Minimal complete definition: all except <a>negate</a> or <tt>(-)</tt>
class Num a
(+) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
negate :: Num a => a -> a
abs :: Num a => a -> a
signum :: Num a => a -> a
fromInteger :: Num a => Integer -> a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | Parsing of <a>String</a>s, producing values.
--   
--   Minimal complete definition: <a>readsPrec</a> (or, for GHC only,
--   <a>readPrec</a>)
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]
class (Num a, Ord a) => Real a
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
--   
--   Minimal complete definition: all except <a>exponent</a>,
--   <a>significand</a>, <a>scaleFloat</a> and <a>atan2</a>
class (RealFrac a, Floating a) => RealFloat a
floatRadix :: RealFloat a => a -> Integer
floatDigits :: RealFloat a => a -> Int
floatRange :: RealFloat a => a -> (Int, Int)
decodeFloat :: RealFloat a => a -> (Integer, Int)
encodeFloat :: RealFloat a => Integer -> Int -> a
exponent :: RealFloat a => a -> Int
significand :: RealFloat a => a -> a
scaleFloat :: RealFloat a => Int -> a -> a
isNaN :: RealFloat a => a -> Bool
isInfinite :: RealFloat a => a -> Bool
isDenormalized :: RealFloat a => a -> Bool
isNegativeZero :: RealFloat a => a -> Bool
isIEEE :: RealFloat a => a -> Bool
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
--   
--   Minimal complete definition: <a>properFraction</a>
class (Real a, Fractional a) => RealFrac a
properFraction :: (RealFrac a, Integral b) => a -> (b, a)
truncate :: (RealFrac a, Integral b) => a -> b
round :: (RealFrac a, Integral b) => a -> b
ceiling :: (RealFrac a, Integral b) => a -> b
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Minimal complete definition: <a>showsPrec</a> or <a>show</a>.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Constant function.
const :: a -> b -> a

-- | <a>curry</a> converts an uncurried function to a curried function.
curry :: ((a, b) -> c) -> a -> b -> c

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <a>error</a> stops execution and displays an error message.
error :: [Char] -> a
even :: Integral a => a -> Bool

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
flip :: (a -> b -> c) -> b -> a -> c

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Identity function.
id :: a -> a

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Boolean "not"
not :: Bool -> Bool
odd :: Integral a => a -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process.
read :: Read a => String -> a

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Evaluates its first argument to head normal form, and then returns its
--   second argument as the result.
seq :: a -> b -> b

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>uncurry</a> converts a curried function to a function on pairs.
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <a>fail</a> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
