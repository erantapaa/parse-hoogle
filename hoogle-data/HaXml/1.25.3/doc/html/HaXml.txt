-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for manipulating XML documents
--   
--   Haskell utilities for parsing, filtering, transforming and generating
--   XML documents.
@package HaXml
@version 1.25.3


-- | This is another hand-written lexer, this time for the Xtract
--   command-language. The entry point is lexXtract. You don't normally
--   need to use this module directly - the lexer is called automatically
--   by the parser. (We only expose this interface for debugging purposes.)
--   
--   The Xtract command language is very like the XPath specification.
module Text.XML.HaXml.Xtract.Lex

-- | First argument is a transformer for pattern strings, e.g. map toLower,
--   but only applying to parts of the pattern not in quotation marks.
--   (Needed to canonicalise HTML where tags are case-insensitive, but
--   attribute values are case sensitive.)
lexXtract :: (String -> String) -> String -> [Token]
data Posn
Pn :: Int -> Posn
data TokenT
Symbol :: String -> TokenT
TokString :: String -> TokenT
TokNum :: Integer -> TokenT
type Token = Either String (Posn, TokenT)
instance Eq Posn
instance Eq TokenT
instance Show TokenT
instance Show Posn


-- | Define a position datatype for giving locations in error messages.
module Text.XML.HaXml.Posn

-- | Source positions contain a filename, line, column, and an inclusion
--   point, which is itself another source position, recursively.
data Posn

-- | <tt>posInNewCxt name pos</tt> creates a new source position from an
--   old one. It is used when opening a new file (e.g. a DTD inclusion), to
--   denote the start of the file <tt>name</tt>, but retain the stacked
--   information that it was included from the old <tt>pos</tt>.
posInNewCxt :: String -> Maybe Posn -> Posn

-- | Dummy value for generated data, where a true source position does not
--   exist.
noPos :: Posn

-- | Just used to strictify the internal values of a position, to avoid
--   space leaks.
forcep :: Posn -> Int

-- | Add n character positions to the given position.
addcol :: Int -> Posn -> Posn

-- | Add a newline or tab to the given position.
newline :: Posn -> Posn

-- | Add a newline or tab to the given position.
tab :: Posn -> Posn

-- | Add the given whitespace char to the given position. Precondition:
--   <tt>white c | isSpace c = True</tt>
white :: Char -> Posn -> Posn
posnFilename :: Posn -> FilePath
posnLine :: Posn -> Int
posnColumn :: Posn -> Int
instance Eq Posn
instance Show Posn


-- | You don't normally need to use this Lex module directly - it is called
--   automatically by the parser. (This interface is only exposed for
--   debugging purposes.)
--   
--   This is a hand-written lexer for tokenising the text of an XML
--   document so that it is ready for parsing. It attaches position
--   information in (line,column) format to every token. The main entry
--   point is <a>xmlLex</a>. A secondary entry point, <a>xmlReLex</a>, is
--   provided for when the parser needs to stuff a string back onto the
--   front of the text and re-tokenise it (typically when expanding
--   macros).
--   
--   As one would expect, the lexer is essentially a small finite state
--   machine.
module Text.XML.HaXml.Lex

-- | The first argument to <a>xmlLex</a> is the filename (used for source
--   positions, especially in error messages), and the second is the string
--   content of the XML file.
xmlLex :: String -> String -> [Token]

-- | <a>xmlReLex</a> is used when the parser expands a macro (PE
--   reference). The expansion of the macro must be re-lexed as if for the
--   first time.
xmlReLex :: Posn -> String -> [Token]

-- | <a>reLexEntityValue</a> is used solely within parsing an entityvalue.
--   Normally, a PERef is logically separated from its surroundings by
--   whitespace. But in an entityvalue, a PERef can be juxtaposed to an
--   identifier, so the expansion forms a new identifier. Thus the need to
--   rescan the whole text for possible PERefs.
reLexEntityValue :: (String -> Maybe String) -> Posn -> String -> [Token]

-- | All tokens are paired up with a source position. Lexical errors are
--   passed back as a special <tt>TokenT</tt> value.
type Token = (Posn, TokenT)

-- | The basic token type.
data TokenT

-- | &lt;!--
TokCommentOpen :: TokenT

-- | <ul>
--   <li>-&gt;</li>
--   </ul>
TokCommentClose :: TokenT

-- | &lt;?
TokPIOpen :: TokenT

-- | ?&gt;
TokPIClose :: TokenT

-- | &lt;![
TokSectionOpen :: TokenT

-- | ]]&gt;
TokSectionClose :: TokenT

-- | CDATA INCLUDE IGNORE etc
TokSection :: Section -> TokenT

-- | &lt;!
TokSpecialOpen :: TokenT

-- | DOCTYPE ELEMENT ATTLIST etc
TokSpecial :: Special -> TokenT

-- | &lt;/
TokEndOpen :: TokenT

-- | /&gt;
TokEndClose :: TokenT

-- | &lt;
TokAnyOpen :: TokenT

-- | <pre>
--   </pre>
TokAnyClose :: TokenT

-- | [
TokSqOpen :: TokenT

-- | ]
TokSqClose :: TokenT

-- | =
TokEqual :: TokenT

-- | ?
TokQuery :: TokenT

-- | *
TokStar :: TokenT

-- | +
TokPlus :: TokenT

-- | &amp;
TokAmp :: TokenT

-- | ;
TokSemi :: TokenT

-- | #
TokHash :: TokenT

-- | (
TokBraOpen :: TokenT

-- | )
TokBraClose :: TokenT

-- | |
TokPipe :: TokenT

-- | %
TokPercent :: TokenT

-- | ,
TokComma :: TokenT

-- | '' or ""
TokQuote :: TokenT

-- | begins with letter, no spaces
TokName :: String -> TokenT

-- | any character data
TokFreeText :: String -> TokenT

-- | fake token
TokNull :: TokenT

-- | lexical error
TokError :: String -> TokenT
data Special
DOCTYPEx :: Special
ELEMENTx :: Special
ATTLISTx :: Special
ENTITYx :: Special
NOTATIONx :: Special
data Section
CDATAx :: Section
INCLUDEx :: Section
IGNOREx :: Section
instance Eq Where
instance Eq Special
instance Show Special
instance Eq Section
instance Show Section
instance Eq TokenT
instance Show TokenT


-- | Defines an internal representation of Haskell data/newtype definitions
--   that correspond to the XML DTD types, and provides pretty-printers to
--   convert these types into the <a>Doc</a> type of
--   <a>Text.PrettyPrint.HughesPJ</a>.
module Text.XML.HaXml.DtdToHaskell.TypeDef
data TypeDef

-- | Bool for main/aux.
DataDef :: Bool -> Name -> AttrFields -> Constructors -> TypeDef
EnumDef :: Name -> [Name] -> TypeDef
type Constructors = [(Name, [StructType])]
type AttrFields = [(Name, StructType)]
data StructType
Maybe :: StructType -> StructType

-- | String holds default value.
Defaultable :: StructType -> String -> StructType
List :: StructType -> StructType

-- | Non-empty lists.
List1 :: StructType -> StructType
Tuple :: [StructType] -> StructType
OneOf :: [StructType] -> StructType

-- | XML's contentspec allows ANY
Any :: StructType

-- | mixed (#PCDATA | ... )*
StringMixed :: StructType

-- | string only (#PCDATA)
String :: StructType
Defined :: Name -> StructType
ppTypeDef :: TypeDef -> Doc

-- | Pretty print Haskell name.
ppHName :: Name -> Doc

-- | Pretty print XML name.
ppXName :: Name -> Doc

-- | Pretty print Haskell attributes name.
ppAName :: Name -> Doc

-- | Need to keep both the XML and Haskell versions of a name.
data Name
Name :: String -> String -> Name

-- | original XML name
xName :: Name -> String

-- | mangled Haskell name
hName :: Name -> String

-- | Make a type name valid in both XML and Haskell.
name :: String -> Name

-- | Append an underscore to the Haskell version of the name.
name_ :: String -> Name

-- | Prefix an attribute enumeration type name with its containing element
--   name.
name_a :: String -> String -> Name

-- | Prefix an attribute enumeration constructor with its element-tag name,
--   and its enumeration type name.
name_ac :: String -> String -> String -> Name

-- | Prefix a field name with its enclosing element name.
name_f :: String -> String -> Name

-- | Convert an XML name to a Haskell conid.
mangle :: String -> String

-- | Convert an XML name to a Haskell varid.
manglef :: String -> String
instance Eq Name
instance Eq StructType
instance Eq TypeDef
instance Show StructType

module Text.XML.HaXml.DtdToHaskell.Instance

-- | Convert typedef to appropriate instance declaration, either
--   <tt>XmlContent</tt>, <tt>XmlAttributes</tt>, or <tt>XmlAttrType</tt>.
mkInstance :: TypeDef -> Doc


-- | This module defines an internal (generic) representation for XML
--   documents including their DTDs.
--   
--   History: The original module was derived by hand from the XML
--   specification, following the grammar precisely. Then we simplified the
--   types, removing layers of indirection and redundancy, and generally
--   making things easier to work with. Then we allowed PEReferences to be
--   ubiquitous, by removing them from the types and resolving all PE
--   references at parse-time. Finally, we added a per-document symbol
--   table for GEReferences, and a whitespace-significance flag for
--   plaintext.
module Text.XML.HaXml.Types
type SymTab a = [(String, a)]
emptyST :: SymTab a
addST :: String -> a -> SymTab a -> SymTab a
lookupST :: String -> SymTab a -> Maybe a

-- | The symbol table stored in a document holds all its general entity
--   reference definitions.
data Document i
Document :: Prolog -> (SymTab EntityDef) -> (Element i) -> [Misc] -> Document i
data Element i
Elem :: QName -> [Attribute] -> [Content i] -> Element i
data ElemTag
ElemTag :: QName -> [Attribute] -> ElemTag
data Content i
CElem :: (Element i) -> i -> Content i

-- | bool is whether whitespace is significant
CString :: Bool -> CharData -> i -> Content i
CRef :: Reference -> i -> Content i
CMisc :: Misc -> i -> Content i
type Attribute = (QName, AttValue)
data AttValue
AttValue :: [Either String Reference] -> AttValue
info :: Content t -> t
data Prolog
Prolog :: (Maybe XMLDecl) -> [Misc] -> (Maybe DocTypeDecl) -> [Misc] -> Prolog
data XMLDecl
XMLDecl :: VersionInfo -> (Maybe EncodingDecl) -> (Maybe SDDecl) -> XMLDecl
data Misc
Comment :: Comment -> Misc
PI :: ProcessingInstruction -> Misc
type ProcessingInstruction = (PITarget, String)
type SDDecl = Bool
type VersionInfo = String
type Comment = String
type PITarget = String
data DocTypeDecl
DTD :: QName -> (Maybe ExternalID) -> [MarkupDecl] -> DocTypeDecl
data MarkupDecl
Element :: ElementDecl -> MarkupDecl
AttList :: AttListDecl -> MarkupDecl
Entity :: EntityDecl -> MarkupDecl
Notation :: NotationDecl -> MarkupDecl
MarkupMisc :: Misc -> MarkupDecl
data ExtSubset
ExtSubset :: (Maybe TextDecl) -> [ExtSubsetDecl] -> ExtSubset
data ExtSubsetDecl
ExtMarkupDecl :: MarkupDecl -> ExtSubsetDecl
ExtConditionalSect :: ConditionalSect -> ExtSubsetDecl
data ElementDecl
ElementDecl :: QName -> ContentSpec -> ElementDecl
data ContentSpec
EMPTY :: ContentSpec
ANY :: ContentSpec
Mixed :: Mixed -> ContentSpec
ContentSpec :: CP -> ContentSpec
data CP
TagName :: QName -> Modifier -> CP
Choice :: [CP] -> Modifier -> CP
Seq :: [CP] -> Modifier -> CP
data Modifier

-- | Just One
None :: Modifier

-- | Zero Or One
Query :: Modifier

-- | Zero Or More
Star :: Modifier

-- | One Or More
Plus :: Modifier
data Mixed
PCDATA :: Mixed
PCDATAplus :: [QName] -> Mixed
data AttListDecl
AttListDecl :: QName -> [AttDef] -> AttListDecl
data AttDef
AttDef :: QName -> AttType -> DefaultDecl -> AttDef
data AttType
StringType :: AttType
TokenizedType :: TokenizedType -> AttType
EnumeratedType :: EnumeratedType -> AttType
data TokenizedType
ID :: TokenizedType
IDREF :: TokenizedType
IDREFS :: TokenizedType
ENTITY :: TokenizedType
ENTITIES :: TokenizedType
NMTOKEN :: TokenizedType
NMTOKENS :: TokenizedType
data EnumeratedType
NotationType :: NotationType -> EnumeratedType
Enumeration :: Enumeration -> EnumeratedType
type NotationType = [Name]
type Enumeration = [NmToken]
data DefaultDecl
REQUIRED :: DefaultDecl
IMPLIED :: DefaultDecl
DefaultTo :: AttValue -> (Maybe FIXED) -> DefaultDecl
data FIXED
FIXED :: FIXED
data ConditionalSect
IncludeSect :: IncludeSect -> ConditionalSect
IgnoreSect :: IgnoreSect -> ConditionalSect
type IncludeSect = [ExtSubsetDecl]
type IgnoreSect = [IgnoreSectContents]
data Ignore
Ignore :: Ignore
data IgnoreSectContents
IgnoreSectContents :: Ignore -> [(IgnoreSectContents, Ignore)] -> IgnoreSectContents
data Reference
RefEntity :: EntityRef -> Reference
RefChar :: CharRef -> Reference
type EntityRef = Name
type CharRef = Int
type PEReference = Name
data EntityDecl
EntityGEDecl :: GEDecl -> EntityDecl
EntityPEDecl :: PEDecl -> EntityDecl
data GEDecl
GEDecl :: Name -> EntityDef -> GEDecl
data PEDecl
PEDecl :: Name -> PEDef -> PEDecl
data EntityDef
DefEntityValue :: EntityValue -> EntityDef
DefExternalID :: ExternalID -> (Maybe NDataDecl) -> EntityDef
data PEDef
PEDefEntityValue :: EntityValue -> PEDef
PEDefExternalID :: ExternalID -> PEDef
data ExternalID
SYSTEM :: SystemLiteral -> ExternalID
PUBLIC :: PubidLiteral -> SystemLiteral -> ExternalID
newtype NDataDecl
NDATA :: Name -> NDataDecl
data TextDecl
TextDecl :: (Maybe VersionInfo) -> EncodingDecl -> TextDecl
data ExtParsedEnt i
ExtParsedEnt :: (Maybe TextDecl) -> (Content i) -> ExtParsedEnt i
data ExtPE
ExtPE :: (Maybe TextDecl) -> [ExtSubsetDecl] -> ExtPE
data NotationDecl
NOTATION :: Name -> (Either ExternalID PublicID) -> NotationDecl
newtype PublicID
PUBLICID :: PubidLiteral -> PublicID
newtype EncodingDecl
EncodingDecl :: String -> EncodingDecl
data EntityValue
EntityValue :: [EV] -> EntityValue
data EV
EVString :: String -> EV
EVRef :: Reference -> EV
newtype PubidLiteral
PubidLiteral :: String -> PubidLiteral
newtype SystemLiteral
SystemLiteral :: String -> SystemLiteral

-- | A QName is a (possibly) qualified name, in the sense of XML
--   namespaces.
data QName
N :: Name -> QName
QN :: Namespace -> Name -> QName

-- | Namespaces are not defined in the XML spec itself, but at
--   http:/<i>www.w3.org</i>TR/xml-names
data Namespace
Namespace :: String -> String -> Namespace
nsPrefix :: Namespace -> String
nsURI :: Namespace -> String
type Name = String
type Names = [Name]
type NmToken = String
type NmTokens = [NmToken]
type CharData = String
type CDSect = CharData
instance Eq Misc
instance Show Misc
instance Eq Modifier
instance Show Modifier
instance Eq TokenizedType
instance Show TokenizedType
instance Eq FIXED
instance Show FIXED
instance Eq Ignore
instance Show Ignore
instance Eq IgnoreSectContents
instance Show IgnoreSectContents
instance Eq EncodingDecl
instance Show EncodingDecl
instance Eq TextDecl
instance Show TextDecl
instance Eq XMLDecl
instance Show XMLDecl
instance Show Namespace
instance Eq QName
instance Show QName
instance Eq Mixed
instance Show Mixed
instance Eq CP
instance Show CP
instance Eq ContentSpec
instance Show ContentSpec
instance Eq ElementDecl
instance Show ElementDecl
instance Eq NDataDecl
instance Show NDataDecl
instance Eq Reference
instance Show Reference
instance Eq EnumeratedType
instance Show EnumeratedType
instance Eq AttType
instance Show AttType
instance Eq AttValue
instance Eq DefaultDecl
instance Show DefaultDecl
instance Eq AttDef
instance Show AttDef
instance Eq AttListDecl
instance Show AttListDecl
instance Eq EV
instance Show EV
instance Eq EntityValue
instance Show EntityValue
instance Eq PubidLiteral
instance Show PubidLiteral
instance Eq PublicID
instance Show PublicID
instance Eq SystemLiteral
instance Show SystemLiteral
instance Eq ExternalID
instance Show ExternalID
instance Eq NotationDecl
instance Show NotationDecl
instance Eq PEDef
instance Show PEDef
instance Eq PEDecl
instance Show PEDecl
instance Eq EntityDef
instance Show EntityDef
instance Eq GEDecl
instance Show GEDecl
instance Eq EntityDecl
instance Show EntityDecl
instance Eq MarkupDecl
instance Show MarkupDecl
instance Eq ExtSubsetDecl
instance Show ExtSubsetDecl
instance Eq ConditionalSect
instance Show ConditionalSect
instance Eq ExtPE
instance Show ExtPE
instance Eq ExtSubset
instance Show ExtSubset
instance Eq DocTypeDecl
instance Show DocTypeDecl
instance Eq Prolog
instance Show Prolog
instance Show i => Show (Content i)
instance Eq (Element i)
instance Show i => Show (Element i)
instance Eq (ExtParsedEnt i)
instance Show i => Show (ExtParsedEnt i)
instance Eq (Document i)
instance Show i => Show (Document i)
instance Eq ElemTag
instance Show AttValue
instance Ord QName
instance Eq Namespace
instance Functor Content
instance Functor Element
instance Functor Document
instance Eq (Content i)

module Text.XML.HaXml.Escape
xmlEscape :: XmlEscaper -> Element i -> Element i
xmlUnEscape :: XmlEscaper -> Element i -> Element i
xmlEscapeContent :: XmlEscaper -> [Content i] -> [Content i]
xmlUnEscapeContent :: XmlEscaper -> [Content i] -> [Content i]
data XmlEscaper
stdXmlEscaper :: XmlEscaper
mkXmlEscaper :: [(Char, String)] -> (Char -> Bool) -> XmlEscaper

module Text.XML.HaXml.Namespaces

-- | The null Namespace (no prefix, no URI).
nullNamespace :: Namespace

-- | Every Name can be split into a Namespace and local Name. The Namespace
--   might of course be missing.
expandedName :: QName -> (Maybe Namespace, String)

-- | Return the (possibly absent) Namespace component of a Name.
namespaceName :: QName -> Maybe Namespace

-- | Return the local component of a Name, without its Namespace.
localName :: QName -> String

-- | Return the printable string for a Name, i.e. attaching a prefix for
--   its namespace (if it has one).
printableName :: QName -> String

-- | <a>qualify</a> splits a Name of the form "pr:nm" into the prefix "pr"
--   and local name "nm", and looks up the prefix in the given environment
--   to determine its Namespace. There may also be a default namespace (the
--   first argument) for unqualified names. In the absence of a default
--   Namespace, a Name that does not have a prefix remains unqualified. A
--   prefix that is not known in the environment becomes a fresh namespace
--   with null URI. A Name that is already qualified is passed unchanged,
--   unless its URI was null, in which case we check afresh for that prefix
--   in the environment.
qualify :: Maybe Namespace -> Map String Namespace -> QName -> QName

-- | <a>deQualify</a> has the same signature as <a>qualify</a>, but ignores
--   the arguments for default namespace and environment, and simply
--   removes any pre-existing qualification.
deQualify :: Maybe Namespace -> Map String Namespace -> QName -> QName

-- | <a>qualifyExceptLocal</a> converts names to qualified names, except
--   where an existing qualification matches the default namespace, in
--   which case the qualification is removed. (This is useful when
--   translating QNames to Haskell, because Haskell qualified names cannot
--   use the current module name.)
qualifyExceptLocal :: Maybe Namespace -> Map String Namespace -> QName -> QName

-- | The initial Namespace environment. It always has bindings for the
--   prefixes <tt>xml</tt> and <tt>xmlns</tt>.
initNamespaceEnv :: Map String Namespace

-- | Add a fresh Namespace into the Namespace environment. It is not
--   permitted to rebind the prefixes <tt>xml</tt> or <tt>xmlns</tt>, but
--   that is not checked here.
augmentNamespaceEnv :: Namespace -> Map String Namespace -> Map String Namespace

-- | resolveAllNames in a document, causes every name to be properly
--   qualified with its namespace. There is a default namespace for any
--   name that was originally unqualified. This is likely only useful when
--   dealing with parsed document, less useful when generating a document
--   from scratch.
resolveAllNames :: (Maybe Namespace -> Map String Namespace -> QName -> QName) -> Document i -> Document i


-- | This module defines the notion of filters and filter combinators for
--   processing XML documents.
--   
--   These XML transformation combinators are described in the paper
--   ``Haskell and XML: Generic Combinators or Type-Based Translation?''
--   Malcolm Wallace and Colin Runciman, Proceedings ICFP'99.
module Text.XML.HaXml.Combinators

-- | All document transformations are <i>content filters</i>. A filter
--   takes a single XML <a>Content</a> value and returns a sequence of
--   <a>Content</a> values, possibly empty.
type CFilter i = Content i -> [Content i]
keep :: a -> [a]
none :: a -> [b]

-- | Throw away current node, keep just the (unprocessed) children.
children :: CFilter i

-- | Process children using specified filters.
childrenBy :: CFilter i -> CFilter i

-- | Select the <tt>n</tt>'th positional result of a filter.
position :: Int -> CFilter i -> CFilter i
elm :: CFilter i
txt :: CFilter i
tag :: String -> CFilter i
attr :: String -> CFilter i
attrval :: Attribute -> CFilter i
tagWith :: (String -> Bool) -> CFilter i

-- | For a mandatory attribute field, <tt>find key cont</tt> looks up the
--   value of the attribute name <tt>key</tt>, and applies the continuation
--   <tt>cont</tt> to the value.
find :: String -> (String -> CFilter i) -> CFilter i

-- | When an attribute field may be absent, use <tt>iffind key yes no</tt>
--   to lookup its value. If the attribute is absent, it acts as the
--   <tt>no</tt> filter, otherwise it applies the <tt>yes</tt> filter.
iffind :: String -> (String -> CFilter i) -> CFilter i -> CFilter i

-- | <tt>ifTxt yes no</tt> processes any textual content with the
--   <tt>yes</tt> filter, but otherwise is the same as the <tt>no</tt>
--   filter.
ifTxt :: (String -> CFilter i) -> CFilter i -> CFilter i

-- | Sequential (<i>Irish</i>,<i>backwards</i>) composition
o :: CFilter i -> CFilter i -> CFilter i

-- | Binary parallel composition. Each filter uses a copy of the input,
--   rather than one filter using the result of the other. (Has a more
--   general type than just CFilter.)
union :: (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | Glue a list of filters together. (A list version of union; also has a
--   more general type than just CFilter.)
cat :: [a -> [b]] -> (a -> [b])

-- | A special form of filter composition where the second filter works
--   over the same data as the first, but also uses the first's result.
andThen :: (a -> c) -> (c -> a -> b) -> (a -> b)

-- | Directional choice: in <tt>f |&gt;| g</tt> give g-productions only if
--   no f-productions
(|>|) :: (a -> [b]) -> (a -> [b]) -> (a -> [b])

-- | Pruning: in <tt>f <a>with</a> g</tt>, keep only those f-productions
--   which have at least one g-production
with :: CFilter i -> CFilter i -> CFilter i

-- | Pruning: in <tt>f <a>without</a> g</tt>, keep only those f-productions
--   which have no g-productions
without :: CFilter i -> CFilter i -> CFilter i

-- | Pronounced <i>slash</i>, <tt>f /&gt; g</tt> means g inside f
(/>) :: CFilter i -> CFilter i -> CFilter i

-- | Pronounced <i>outside</i>, <tt>f &lt;/ g</tt> means f containing g
(</) :: CFilter i -> CFilter i -> CFilter i

-- | Join an element-matching filter with a text-only filter
et :: (String -> CFilter i) -> CFilter i -> CFilter i

-- | Express a list of filters like an XPath query, e.g. <tt>path
--   [children, tag "name1", attr "attr1", children, tag "name2"]</tt> is
--   like the XPath query <tt>/name1[@attr1]/name2</tt>.
path :: [CFilter i] -> CFilter i
deep :: CFilter i -> CFilter i
deepest :: CFilter i -> CFilter i
multi :: CFilter i -> CFilter i

-- | Interior editing: <tt>f <a>when</a> g</tt> applies <tt>f</tt> only
--   when the predicate <tt>g</tt> succeeds, otherwise the content is
--   unchanged.
when :: CFilter i -> CFilter i -> CFilter i

-- | Interior editing: <tt>g <a>guards</a> f</tt> applies <tt>f</tt> only
--   when the predicate <tt>g</tt> succeeds, otherwise the content is
--   discarded.
guards :: CFilter i -> CFilter i -> CFilter i

-- | Process CHildren In Place. The filter is applied to any children of an
--   element content, and the element rebuilt around the results.
chip :: CFilter i -> CFilter i

-- | Process an element In Place. The filter is applied to the element
--   itself, and then the original element rebuilt around the results.
inplace :: CFilter i -> CFilter i

-- | Recursively process an element in place. That is, the filter is
--   applied to the element itself, then recursively to the results of the
--   filter, all the way to the bottom, then the original element rebuilt
--   around the final results.
recursivelyInPlace :: CFilter i -> CFilter i

-- | Recursive application of filters: a fold-like operator. Defined as
--   <tt>f <a>o</a> chip (foldXml f)</tt>.
foldXml :: CFilter i -> CFilter i

-- | Build an element with the given tag name - its content is the results
--   of the given list of filters.
mkElem :: String -> [CFilter i] -> CFilter i

-- | Build an element with the given name, attributes, and content.
mkElemAttr :: String -> [(String, CFilter i)] -> [CFilter i] -> CFilter i

-- | Build some textual content.
literal :: String -> CFilter i

-- | Build some CDATA content.
cdata :: String -> CFilter i

-- | Rename an element tag (leaving attributes in place).
replaceTag :: String -> CFilter i

-- | Replace the attributes of an element (leaving tag the same).
replaceAttrs :: [(String, String)] -> CFilter i

-- | Add the desired attribute name and value to the topmost element,
--   without changing the element in any other way.
addAttribute :: String -> String -> CFilter a

-- | Conjoin the two branches of a conditional.
data ThenElse a
(:>) :: a -> a -> ThenElse a

-- | Select between the two branches of a joined conditional.
(?>) :: (a -> [b]) -> ThenElse (a -> [b]) -> (a -> [b])

-- | A LabelFilter is like a CFilter except that it pairs up a polymorphic
--   value (label) with each of its results.
type LabelFilter i a = Content i -> [(a, Content i)]

-- | Compose a label-processing filter with a label-generating filter.
oo :: (a -> CFilter i) -> LabelFilter i a -> CFilter i

-- | Combine labels. Think of this as a pair-wise zip on labels. e.g.
--   <tt>(numbered <a>x</a> tagged)</tt>
x :: (CFilter i -> LabelFilter i a) -> (CFilter i -> LabelFilter i b) -> (CFilter i -> LabelFilter i (a, b))

-- | Number the results from 1 upwards.
numbered :: CFilter i -> LabelFilter i Int

-- | In <tt>interspersed a f b</tt>, label each result of <tt>f</tt> with
--   the string <tt>a</tt>, except for the last one which is labelled with
--   the string <tt>b</tt>.
interspersed :: String -> CFilter i -> String -> LabelFilter i String

-- | Label each element in the result with its tag name. Non-element
--   results get an empty string label.
tagged :: CFilter i -> LabelFilter i String

-- | Label each element in the result with the value of the named
--   attribute. Elements without the attribute, and non-element results,
--   get an empty string label.
attributed :: String -> CFilter i -> LabelFilter i String

-- | Label each textual part of the result with its text. Element results
--   get an empty string label.
textlabelled :: CFilter i -> LabelFilter i (Maybe String)

-- | Label each content with some information extracted from itself.
extracted :: (Content i -> a) -> CFilter i -> LabelFilter i a


-- | A non-validating XML parser. For the input grammar, see
--   <a>http://www.w3.org/TR/REC-xml</a>.
module Text.XML.HaXml.Parse

-- | To parse a whole document, <tt>xmlParse file content</tt> takes a
--   filename (for generating error reports) and the string content of that
--   file. A parse error causes program failure, with message to stderr.
xmlParse :: String -> String -> Document Posn

-- | To parse a whole document, <tt>xmlParse' file content</tt> takes a
--   filename (for generating error reports) and the string content of that
--   file. Any parse error message is passed back to the caller through the
--   <tt>Either</tt> type.
xmlParse' :: String -> String -> Either String (Document Posn)

-- | To parse just a DTD, <tt>dtdParse file content</tt> takes a filename
--   (for generating error reports) and the string content of that file. If
--   no DTD was found, you get <tt>Nothing</tt> rather than an error.
--   However, if a DTD is found but contains errors, the program crashes.
dtdParse :: String -> String -> Maybe DocTypeDecl

-- | To parse just a DTD, <tt>dtdParse' file content</tt> takes a filename
--   (for generating error reports) and the string content of that file. If
--   no DTD was found, you get <tt>Right Nothing</tt>. If a DTD was found
--   but contains errors, you get a <tt>Left message</tt>.
dtdParse' :: String -> String -> Either String (Maybe DocTypeDecl)

-- | To parse a partial document, e.g. from an XML-based stream protocol,
--   where you may later want to get more document elements from the same
--   stream. Arguments are: a parser for the item you want, and the
--   already-lexed input to parse from. Returns the item you wanted (or an
--   error message), plus the remainder of the input.
xmlParseWith :: XParser a -> [(Posn, TokenT)] -> (Either String a, [(Posn, TokenT)])

-- | Return an entire XML document including prolog and trailing junk.
document :: XParser (Document Posn)

-- | Return a complete element including all its inner content.
element :: XParser (Element Posn)

-- | Return a content particle, e.g. text, element, reference, etc
content :: XParser (Content Posn)

-- | Return an XML comment.
comment :: XParser Comment
cdsect :: XParser CDSect

-- | Return parsed freetext (i.e. until the next markup)
chardata :: XParser CharData

-- | Return either a general entity reference, or a character reference.
reference :: XParser Reference

-- | Return a DOCTYPE decl, indicating a DTD.
doctypedecl :: XParser DocTypeDecl

-- | Parse a processing instruction.
processinginstruction :: XParser ProcessingInstruction

-- | Parse only the parts between angle brackets in an element tag.
elemtag :: XParser ElemTag

-- | Return a qualified name (although the namespace qualification is not
--   processed here; this is merely to get the correct type).
qname :: XParser QName

-- | Return just a name, e.g. element name, attribute name.
name :: XParser Name

-- | Return the next token from the input only if it matches the given
--   token.
tok :: TokenT -> XParser TokenT

-- | For use with stream parsers - returns the complete opening element
--   tag.
elemOpenTag :: XParser ElemTag

-- | For use with stream parsers - accepts a closing tag, provided it
--   matches the given element name.
elemCloseTag :: QName -> XParser ()

-- | Some empty symbol tables for GE and PE references.
emptySTs :: SymTabs

-- | XParser is just a specialisation of the PolyState parser.
type XParser a = Parser SymTabs (Posn, TokenT) a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c


-- | This is a pretty-printer for turning the internal representation of
--   generic structured XML documents into the Doc type (which can later be
--   rendered using Text.PrettyPrint.HughesPJ.render). Essentially there is
--   one pp function for each type in Text.Xml.HaXml.Types, so you can
--   pretty-print as much or as little of the document as you wish.
module Text.XML.HaXml.Pretty
document :: Document i -> Doc
content :: Content i -> Doc
element :: Element i -> Doc
doctypedecl :: DocTypeDecl -> Doc
prolog :: Prolog -> Doc
cp :: CP -> Doc


-- | These are just some common abbreviations for generating HTML content
--   within the XML transformation framework defined by
--   <a>Text.Xml.HaXml.Combinators</a>.
module Text.XML.HaXml.Html.Generate
html :: [CFilter i] -> CFilter i
hhead :: [CFilter i] -> CFilter i
htitle :: [CFilter i] -> CFilter i
hbody :: [CFilter i] -> CFilter i
h1 :: [CFilter i] -> CFilter i
h2 :: [CFilter i] -> CFilter i
h3 :: [CFilter i] -> CFilter i
h4 :: [CFilter i] -> CFilter i
hpara :: [CFilter i] -> CFilter i
hdiv :: [CFilter i] -> CFilter i
hspan :: [CFilter i] -> CFilter i
margin :: [CFilter i] -> CFilter i
anchor :: [(String, CFilter i)] -> [CFilter i] -> CFilter i
makehref :: CFilter i -> [CFilter i] -> CFilter i
anchorname :: CFilter i -> [CFilter i] -> CFilter i
hpre :: [CFilter i] -> CFilter i
hcentre :: [CFilter i] -> CFilter i
hem :: [CFilter i] -> CFilter i
htt :: [CFilter i] -> CFilter i
hbold :: [CFilter i] -> CFilter i
parens :: CFilter i -> CFilter i
bullet :: [CFilter i] -> CFilter i
htable :: [CFilter i] -> CFilter i
hrow :: [CFilter i] -> CFilter i
hcol :: [CFilter i] -> CFilter i
hbr :: CFilter i
hhr :: CFilter i
showattr :: String -> CFilter i
(!) :: String -> CFilter i
(?) :: String -> CFilter i
htmlprint :: [Content i] -> Doc


-- | This is a parser for HTML documents. Unlike for XML documents, it must
--   include a certain amount of error-correction to account for HTML
--   features like self-terminating tags, unterminated tags, and incorrect
--   nesting. The input is tokenised by the XML lexer (a separate lexer is
--   not required for HTML).
module Text.XML.HaXml.Html.Parse

-- | The first argument is the name of the file, the second is the string
--   contents of the file. The result is the generic representation of an
--   XML document. Any errors cause program failure with message to stderr.
htmlParse :: String -> String -> Document Posn

-- | The first argument is the name of the file, the second is the string
--   contents of the file. The result is the generic representation of an
--   XML document. Any parsing errors are returned in the <tt>Either</tt>
--   type.
htmlParse' :: String -> String -> Either String (Document Posn)

module Text.XML.HaXml.Wrappers

-- | This useful auxiliary checks the commandline arguments for two
--   filenames, the input and output file respectively. If either is
--   missing, it is replaced by <a>-</a>, which can be interpreted by the
--   caller as stdin and/or stdout.
fix2Args :: IO (String, String)

-- | The wrapper <tt>processXmlWith</tt> returns an IO () computation that
--   collects the filenames (or stdin/stdout) to use when reading/writing
--   XML documents. Its CFilter argument is applied to transform the XML
--   document from the input and write it to the output. No DTD is attached
--   to the output.
--   
--   If the input filename ends with .html or .htm, it is parsed using the
--   error-correcting HTML parser rather than the strict XML parser.
processXmlWith :: CFilter Posn -> IO ()

-- | The wrapper <tt>onContent</tt> simply applies a given content filter
--   to a document. Ambiguous or empty results raise an error exception.
onContent :: CFilter i -> Document i -> Document i


-- | The preferred method for rendering a <a>Document</a> or single
--   <a>Content</a> is by using the pretty printing facility defined in
--   <a>Pretty</a>. Pretty-printing does not work well for cases, however,
--   where the formatting in the XML document is significant. Examples of
--   this case are XHTML's <tt>&lt;pre&gt;</tt> tag, Docbook's
--   <tt>&lt;literallayout&gt;</tt> tag, and many more.
--   
--   Theoretically, the document author could avoid this problem by
--   wrapping the contents of these tags in a &lt;![CDATA[...]]&gt;
--   section, but often this is not practical, for instance when the
--   literal-layout section contains other elements. Finally, program
--   writers could manually format these elements by transforming them into
--   a <tt>literal</tt> string in their <tt>CFliter</tt>, etc., but this is
--   annoying to do and prone to omissions and formatting errors.
--   
--   As an alternative, this module provides the function <a>verbatim</a>,
--   which will format XML <a>Content</a> as a <a>String</a> while
--   retaining the formatting of the input document unchanged.
--   
--   <i>Known problems</i>:
--   
--   <ul>
--   <li>HaXml's parser eats line feeds between two
--   tags.<ul><li><a>Attribute</a>s should be formatted by making them an
--   instance of <a>Verbatim</a> as well, but since an <a>Attribute</a> is
--   just a tuple, not a full data type, the helper function
--   <a>verbAttr</a> must be used instead.</li><li><a>CMisc</a> is not yet
--   supported.</li><li><a>Element</a>s, which contain no content, are
--   formatted as <tt>&lt;element-name/&gt;</tt>, even if they were not
--   defined as being of type <tt>EMPTY</tt>. In XML this perfectly
--   alright, but in SGML it is not. Those, who wish to use <a>verbatim</a>
--   to format parts of say an HTML page will have to (a) replace
--   problematic elements by <tt>literal</tt>s <i>before</i> running
--   <a>verbatim</a> or (b) use a second search-and-replace stage to fix
--   this.</li></ul></li>
--   </ul>
module Text.XML.HaXml.Verbatim
qname :: QName -> String

-- | This class promises that the function <a>verbatim</a> knows how to
--   format this data type into a string without changing the formatting.
class Verbatim a
verbatim :: Verbatim a => a -> String

-- | This is a helper function is required because Haskell does not allow
--   to make an ordinary tuple (like <a>Attribute</a>) an instance of a
--   class. The resulting output will preface the actual attribute with a
--   single blank so that lists of <a>Attribute</a>s can be handled
--   implicitly by the definition for lists of <a>Verbatim</a> data types.
verbAttr :: Attribute -> String
instance Verbatim AttValue
instance Verbatim Reference
instance Verbatim (Element i)
instance Verbatim (Content i)
instance (Verbatim a, Verbatim b) => Verbatim (Either a b)
instance Verbatim Char
instance Verbatim a => Verbatim [a]


-- | This is a fast non-pretty-printer for turning the internal
--   representation of generic structured XML documents into Lazy
--   ByteStrings. Like in Text.Xml.HaXml.Pretty, there is one pp function
--   for each type in Text.Xml.HaXml.Types, so you can pretty-print as much
--   or as little of the document as you wish.
module Text.XML.HaXml.ByteStringPP
document :: Document i -> ByteString
content :: Content i -> ByteString
element :: Element i -> ByteString
doctypedecl :: DocTypeDecl -> ByteString
prolog :: Prolog -> ByteString
cp :: CP -> ByteString


-- | This module performs the translation of a parsed XML DTD into the
--   internal representation of corresponding Haskell data/newtypes.
--   
--   Note that dtdToTypeDef is partial - it will crash if you resolve
--   qualified names (namespaces) to URIs beforehand. It will only work on
--   the original literal name forms "prefix:name".
module Text.XML.HaXml.DtdToHaskell.Convert
dtd2TypeDef :: [MarkupDecl] -> [TypeDef]


-- | This is a parser for HTML documents. Unlike for XML documents, it must
--   include a certain amount of error-correction to account for HTML
--   features like self-terminating tags, unterminated tags, and incorrect
--   nesting. The input is tokenised by the XML lexer (a separate lexer is
--   not required for HTML).
module Text.XML.HaXml.Html.ParseLazy

-- | The first argument is the name of the file, the second is the string
--   contents of the file. The result is the generic representation of an
--   XML document. Any errors cause program failure with message to stderr.
htmlParse :: String -> String -> Document Posn


-- | This is a separate pretty-printer for HTML documents, recognising some
--   of the differences between HTML and true XML.
module Text.XML.HaXml.Html.Pretty
document :: Document i -> Doc
element :: Element i -> Doc
attribute :: Attribute -> Doc
content :: Content i -> Doc


-- | A non-validating XML parser. For the input grammar, see
--   <a>http://www.w3.org/TR/REC-xml</a>.
module Text.XML.HaXml.ParseLazy

-- | To parse a whole document, <tt>xmlParse file content</tt> takes a
--   filename (for generating error reports) and the string content of that
--   file. A parse error causes program failure, with message to stderr.
xmlParse :: String -> String -> Document Posn

-- | To parse just a DTD, <tt>dtdParse file content</tt> takes a filename
--   (for generating error reports) and the string content of that file. If
--   no DTD was found, you get <tt>Nothing</tt> rather than an error.
--   However, if a DTD is found but contains errors, the program crashes.
dtdParse :: String -> String -> Maybe DocTypeDecl

-- | To parse a partial document, e.g. from an XML-based stream protocol,
--   where you may later want to get more document elements from the same
--   stream. Arguments are: a parser for the item you want, and the
--   already-lexed input to parse from. Returns the item you wanted (or an
--   error message), plus the remainder of the input.
xmlParseWith :: XParser a -> [(Posn, TokenT)] -> (Either String a, [(Posn, TokenT)])

-- | Return an entire XML document including prolog and trailing junk.
document :: XParser (Document Posn)

-- | Return a complete element including all its inner content.
element :: XParser (Element Posn)

-- | Return a content particle, e.g. text, element, reference, etc
content :: XParser (Content Posn)

-- | Return an XML comment.
comment :: XParser Comment

-- | Return parsed freetext (i.e. until the next markup)
chardata :: XParser CharData

-- | Return either a general entity reference, or a character reference.
reference :: XParser Reference

-- | Return a DOCTYPE decl, indicating a DTD.
doctypedecl :: XParser DocTypeDecl

-- | Parse a processing instruction.
processinginstruction :: XParser ProcessingInstruction

-- | Parse only the parts between angle brackets in an element tag.
elemtag :: XParser ElemTag

-- | Return a qualified name (although the namespace qualification is not
--   processed here; this is merely to get the correct type).
qname :: XParser QName

-- | Return just a name, e.g. element name, attribute name.
name :: XParser Name

-- | Return the next token from the input only if it matches the given
--   token.
tok :: TokenT -> XParser TokenT

-- | For use with stream parsers - returns the complete opening element
--   tag.
elemOpenTag :: XParser ElemTag

-- | For use with stream parsers - accepts a closing tag, provided it
--   matches the given element name.
elemCloseTag :: QName -> XParser ()

-- | Some empty symbol tables for GE and PE references.
emptySTs :: SymTabs

-- | XParser is just a specialisation of the PolyStateLazy parser.
type XParser a = Parser SymTabs (Posn, TokenT) a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c


-- | A streaming XML parser, using a method known as SAX. SAX isn't really
--   a standard, but an implementation, so it's just an "SAX-like" parser.
--   This module allows you parse an XML document without having to
--   evaluate it as a whole. This is needed for protocols like jabber,
--   which use xml streams for communication.
module Text.XML.HaXml.SAX
data SaxElement

-- | A doctype declaration occured(&lt;!DOCTYPE&gt;)
SaxDocTypeDecl :: DocTypeDecl -> SaxElement

-- | A processing instruction occured (&lt;??&gt;)
SaxProcessingInstruction :: ProcessingInstruction -> SaxElement

-- | A comment occured (&lt;!-- --&gt;)
SaxComment :: String -> SaxElement

-- | An element was opened (&lt;&gt;)
SaxElementOpen :: Name -> [Attribute] -> SaxElement

-- | An element was closed (&lt;/&gt;)
SaxElementClose :: Name -> SaxElement

-- | An element without content occured (&lt;/&gt;)
SaxElementTag :: Name -> [Attribute] -> SaxElement

-- | Some string data occured
SaxCharData :: CharData -> SaxElement

-- | A reference occured
SaxReference :: Reference -> SaxElement

-- | <tt>saxParse file content</tt> takes a filename and the string content
--   of that file and generates a stream of <tt>SaxElement</tt>s. If an
--   error occurs, the parsing stops and a string is returned using the
--   <tt>Maybe</tt> type.
saxParse :: String -> String -> ([SaxElement], Maybe String)

module Text.XML.HaXml.Schema.XSDTypeModel
data Schema
Schema :: QForm -> QForm -> Maybe Final -> Maybe Block -> Maybe TargetNamespace -> Maybe String -> [Namespace] -> [SchemaItem] -> Schema
schema_elementFormDefault :: Schema -> QForm
schema_attributeFormDefault :: Schema -> QForm
schema_finalDefault :: Schema -> Maybe Final
schema_blockDefault :: Schema -> Maybe Block
schema_targetNamespace :: Schema -> Maybe TargetNamespace
schema_version :: Schema -> Maybe String
schema_namespaces :: Schema -> [Namespace]
schema_items :: Schema -> [SchemaItem]
data SchemaItem
Include :: SchemaLocation -> Annotation -> SchemaItem
Import :: URI -> SchemaLocation -> Annotation -> SchemaItem
Redefine :: SchemaLocation -> [SchemaItem] -> SchemaItem
Annotation :: Annotation -> SchemaItem
Simple :: SimpleType -> SchemaItem
Complex :: ComplexType -> SchemaItem
SchemaElement :: ElementDecl -> SchemaItem
SchemaAttribute :: AttributeDecl -> SchemaItem
AttributeGroup :: AttrGroup -> SchemaItem
SchemaGroup :: Group -> SchemaItem
data SimpleType
Primitive :: PrimitiveType -> SimpleType
simple_primitive :: SimpleType -> PrimitiveType
Restricted :: Annotation -> Maybe Name -> Maybe Final -> Restriction -> SimpleType
simple_annotation :: SimpleType -> Annotation
simple_name :: SimpleType -> Maybe Name
simple_final :: SimpleType -> Maybe Final
simple_restriction :: SimpleType -> Restriction
ListOf :: Annotation -> Maybe Name -> Maybe Final -> Either SimpleType QName -> SimpleType
simple_annotation :: SimpleType -> Annotation
simple_name :: SimpleType -> Maybe Name
simple_final :: SimpleType -> Maybe Final
simple_type :: SimpleType -> Either SimpleType QName
UnionOf :: Annotation -> Maybe Name -> Maybe Final -> [SimpleType] -> [QName] -> SimpleType
simple_annotation :: SimpleType -> Annotation
simple_name :: SimpleType -> Maybe Name
simple_final :: SimpleType -> Maybe Final
simple_union :: SimpleType -> [SimpleType]
simple_members :: SimpleType -> [QName]
data Restriction
RestrictSim1 :: Annotation -> Maybe QName -> Restriction1 -> Restriction
restrict_annotation :: Restriction -> Annotation
restrict_base :: Restriction -> Maybe QName
restrict_r1 :: Restriction -> Restriction1
RestrictType :: Annotation -> Maybe QName -> Maybe SimpleType -> [Facet] -> Restriction
restrict_annotation :: Restriction -> Annotation
restrict_base :: Restriction -> Maybe QName
restrict_type :: Restriction -> Maybe SimpleType
restrict_facets :: Restriction -> [Facet]
data Facet
Facet :: FacetType -> Annotation -> String -> Bool -> Facet
facet_facetType :: Facet -> FacetType
facet_annotation :: Facet -> Annotation
facet_facetValue :: Facet -> String
facet_fixed :: Facet -> Bool
data FacetType
OrderedBoundsMinIncl :: FacetType
OrderedBoundsMinExcl :: FacetType
OrderedBoundsMaxIncl :: FacetType
OrderedBoundsMaxExcl :: FacetType
OrderedNumericTotalDigits :: FacetType
OrderedNumericFractionDigits :: FacetType
UnorderedPattern :: FacetType
UnorderedEnumeration :: FacetType
UnorderedWhitespace :: FacetType
UnorderedLength :: FacetType
UnorderedMaxLength :: FacetType
UnorderedMinLength :: FacetType
data ComplexType
ComplexType :: Annotation -> Maybe Name -> Bool -> Maybe Final -> Maybe Block -> Bool -> ComplexItem -> ComplexType
complex_annotation :: ComplexType -> Annotation
complex_name :: ComplexType -> Maybe Name
complex_abstract :: ComplexType -> Bool
complex_final :: ComplexType -> Maybe Final
complex_block :: ComplexType -> Maybe Block
complex_mixed :: ComplexType -> Bool
complex_content :: ComplexType -> ComplexItem
data ComplexItem
SimpleContent :: Annotation -> (Either Restriction1 Extension) -> ComplexItem
ci_annotation :: ComplexItem -> Annotation
ci_stuff :: ComplexItem -> (Either Restriction1 Extension)
ComplexContent :: Annotation -> Bool -> (Either Restriction1 Extension) -> ComplexItem
ci_annotation :: ComplexItem -> Annotation
ci_mixed :: ComplexItem -> Bool
ci_stuff :: ComplexItem -> (Either Restriction1 Extension)
ThisType :: ParticleAttrs -> ComplexItem
ci_thistype :: ComplexItem -> ParticleAttrs
data Restriction1
Restriction1 :: Particle -> Restriction1
data Extension
Extension :: Annotation -> QName -> ParticleAttrs -> Extension
extension_annotation :: Extension -> Annotation
extension_base :: Extension -> QName
extension_newstuff :: Extension -> ParticleAttrs
type Particle = Maybe (Either ChoiceOrSeq Group)
data ParticleAttrs
PA :: Particle -> [Either AttributeDecl AttrGroup] -> (Maybe AnyAttr) -> ParticleAttrs
data Group
Group :: Annotation -> Either Name QName -> Occurs -> Maybe ChoiceOrSeq -> Group
group_annotation :: Group -> Annotation
group_nameOrRef :: Group -> Either Name QName
group_occurs :: Group -> Occurs
group_stuff :: Group -> Maybe ChoiceOrSeq
data ChoiceOrSeq
All :: Annotation -> [ElementDecl] -> ChoiceOrSeq
Choice :: Annotation -> Occurs -> [ElementEtc] -> ChoiceOrSeq
Sequence :: Annotation -> Occurs -> [ElementEtc] -> ChoiceOrSeq
data ElementEtc
HasElement :: ElementDecl -> ElementEtc
HasGroup :: Group -> ElementEtc
HasCS :: ChoiceOrSeq -> ElementEtc
HasAny :: Any -> ElementEtc
data Any
Any :: Annotation -> URI -> ProcessContents -> Occurs -> Any
any_annotation :: Any -> Annotation
any_namespace :: Any -> URI
any_processContents :: Any -> ProcessContents
any_occurs :: Any -> Occurs
data AnyAttr
AnyAttr :: Annotation -> URI -> ProcessContents -> AnyAttr
anyattr_annotation :: AnyAttr -> Annotation
anyattr_namespace :: AnyAttr -> URI
anyattr_processContents :: AnyAttr -> ProcessContents
data AttrGroup
AttrGroup :: Annotation -> Either Name QName -> [Either AttributeDecl AttrGroup] -> AttrGroup
attrgroup_annotation :: AttrGroup -> Annotation
attrgroup_nameOrRef :: AttrGroup -> Either Name QName
attrgroup_stuff :: AttrGroup -> [Either AttributeDecl AttrGroup]
data ElementDecl
ElementDecl :: Annotation -> Either NameAndType QName -> Occurs -> Nillable -> Maybe QName -> Bool -> Maybe Final -> Maybe Block -> QForm -> Maybe (Either SimpleType ComplexType) -> [UniqueKeyOrKeyRef] -> ElementDecl
elem_annotation :: ElementDecl -> Annotation
elem_nameOrRef :: ElementDecl -> Either NameAndType QName
elem_occurs :: ElementDecl -> Occurs
elem_nillable :: ElementDecl -> Nillable
elem_substGroup :: ElementDecl -> Maybe QName
elem_abstract :: ElementDecl -> Bool
elem_final :: ElementDecl -> Maybe Final
elem_block :: ElementDecl -> Maybe Block
elem_form :: ElementDecl -> QForm
elem_content :: ElementDecl -> Maybe (Either SimpleType ComplexType)
elem_stuff :: ElementDecl -> [UniqueKeyOrKeyRef]
data NameAndType
NT :: Name -> Maybe QName -> NameAndType
theName :: NameAndType -> Name
theType :: NameAndType -> Maybe QName
data AttributeDecl
AttributeDecl :: Annotation -> Either NameAndType QName -> Use -> Maybe (Either DefaultValue FixedValue) -> QForm -> Maybe SimpleType -> AttributeDecl
attr_annotation :: AttributeDecl -> Annotation
attr_nameOrRef :: AttributeDecl -> Either NameAndType QName
attr_use :: AttributeDecl -> Use
attr_defFixed :: AttributeDecl -> Maybe (Either DefaultValue FixedValue)
attr_form :: AttributeDecl -> QForm
attr_simpleType :: AttributeDecl -> Maybe SimpleType
data UniqueKeyOrKeyRef
U :: Unique -> UniqueKeyOrKeyRef
K :: Key -> UniqueKeyOrKeyRef
KR :: KeyRef -> UniqueKeyOrKeyRef
data Unique
Unique :: Annotation -> Name -> Selector -> [Field] -> Unique
unique_annotation :: Unique -> Annotation
unique_name :: Unique -> Name
unique_selector :: Unique -> Selector
unique_fields :: Unique -> [Field]
data Key
Key :: Annotation -> Name -> Selector -> [Field] -> Key
key_annotation :: Key -> Annotation
key_name :: Key -> Name
key_selector :: Key -> Selector
key_fields :: Key -> [Field]
data KeyRef
KeyRef :: Annotation -> Name -> QName -> Selector -> [Field] -> KeyRef
keyref_annotation :: KeyRef -> Annotation
keyref_name :: KeyRef -> Name
keyref_refer :: KeyRef -> QName
keyref_selector :: KeyRef -> Selector
keyref_fields :: KeyRef -> [Field]
data Selector
Selector :: Annotation -> String -> Selector
selector_annotation :: Selector -> Annotation
selector_xpath :: Selector -> String
data Field
Field :: Annotation -> String -> Field
field_annotation :: Field -> Annotation
field_xpath :: Field -> String
data Occurs
Occurs :: (Maybe Int) -> (Maybe Int) -> Occurs
data Use
Required :: Use
Optional :: Use
Prohibited :: Use
data PrimitiveType
String :: PrimitiveType
Boolean :: PrimitiveType
Decimal :: PrimitiveType
Float :: PrimitiveType
Double :: PrimitiveType
Duration :: PrimitiveType
DateTime :: PrimitiveType
Time :: PrimitiveType
Date :: PrimitiveType
GYearMonth :: PrimitiveType
GYear :: PrimitiveType
GMonthDay :: PrimitiveType
GDay :: PrimitiveType
GMonth :: PrimitiveType
Base64Binary :: PrimitiveType
HexBinary :: PrimitiveType
AnyURI :: PrimitiveType
QName :: PrimitiveType
Notation :: PrimitiveType
data MyRestriction
Range :: Occurs -> MyRestriction
Pattern :: Regexp -> MyRestriction
Enumeration :: [String] -> MyRestriction
type Mixed = Bool
type Nillable = Bool
type Fixed = Bool
data Annotation
Documentation :: String -> Annotation
AppInfo :: String -> Annotation
NoAnnotation :: String -> Annotation
data QForm
Qualified :: QForm
Unqualified :: QForm
type TargetNamespace = URI
data Final
NoExtension :: Final
NoRestriction :: Final
AllFinal :: Final
type Block = Final
data ProcessContents
Skip :: ProcessContents
Lax :: ProcessContents
Strict :: ProcessContents
type SchemaLocation = String
type DefaultValue = String
type FixedValue = String
type Regexp = String
type URI = String
type TypeName = String
instance Eq FacetType
instance Show FacetType
instance Eq NameAndType
instance Show NameAndType
instance Eq Occurs
instance Show Occurs
instance Eq Use
instance Show Use
instance Eq PrimitiveType
instance Show PrimitiveType
instance Eq Annotation
instance Show Annotation
instance Eq Field
instance Show Field
instance Eq Selector
instance Show Selector
instance Eq KeyRef
instance Show KeyRef
instance Eq Key
instance Show Key
instance Eq Unique
instance Show Unique
instance Eq UniqueKeyOrKeyRef
instance Show UniqueKeyOrKeyRef
instance Eq Facet
instance Show Facet
instance Eq QForm
instance Show QForm
instance Eq Final
instance Show Final
instance Eq ProcessContents
instance Show ProcessContents
instance Eq MyRestriction
instance Show MyRestriction
instance Eq AnyAttr
instance Show AnyAttr
instance Eq Any
instance Show Any
instance Eq ElementEtc
instance Show ElementEtc
instance Eq ElementDecl
instance Show ElementDecl
instance Eq ComplexType
instance Show ComplexType
instance Eq ComplexItem
instance Show ComplexItem
instance Eq ParticleAttrs
instance Show ParticleAttrs
instance Eq AttributeDecl
instance Show AttributeDecl
instance Eq SimpleType
instance Show SimpleType
instance Eq Restriction
instance Show Restriction
instance Eq Restriction1
instance Show Restriction1
instance Eq ChoiceOrSeq
instance Show ChoiceOrSeq
instance Eq Group
instance Show Group
instance Eq AttrGroup
instance Show AttrGroup
instance Eq Extension
instance Show Extension
instance Eq SchemaItem
instance Show SchemaItem
instance Eq Schema
instance Show Schema
instance Monoid Schema
instance Monoid Annotation


-- | A type model for Haskell datatypes that bears a reasonable
--   correspondence to the XSD type model.
module Text.XML.HaXml.Schema.NameConversion

-- | An XName just holds the original XSD qualified name. It does not
--   ensure that the string conforms to any rules of the various Haskell
--   namespaces. Use a NameConverter to define how you would like names to
--   be mangled.
newtype XName
XName :: QName -> XName

-- | An HName is a resolved version of an XName. It should conform to the
--   various namespace rules, and may already include a module qualifier if
--   appropriate.
newtype HName
HName :: String -> HName

-- | A NameConverter is a collection of functions that convert an XName
--   into an HName, for various Haskell namespaces. You can define your own
--   arbitrary resolver, but should ensure that you abide by the Haskell
--   rules for conid, varid, etc.
data NameConverter
NameConverter :: (XName -> HName) -> (XName -> HName) -> (XName -> HName) -> (XName -> HName) -> (XName -> HName) -> (XName -> HName) -> (XName -> XName -> HName) -> NameConverter
modid :: NameConverter -> XName -> HName
conid :: NameConverter -> XName -> HName
varid :: NameConverter -> XName -> HName
unqconid :: NameConverter -> XName -> HName
unqvarid :: NameConverter -> XName -> HName

-- | for forward type decls
fwdconid :: NameConverter -> XName -> HName
fieldid :: NameConverter -> XName -> XName -> HName

-- | A simple default set of rules for resolving XNames into HNames.
simpleNameConverter :: NameConverter

-- | Character escapes to create a valid Haskell identifier.
escape :: Char -> Char

-- | Ensure that a string does not match a Haskell keyword.
avoidKeywords :: String -> String

-- | A specialised module-name converter for FpML module names with
--   multiple dashes, including version numbers, e.g.
--   fpml-dividend-swaps-4-7.xsd becomes FpML.V47.Swaps.Dividend but
--   fpml-posttrade-execution-4-7.xsd becomes FpML.V47.PostTrade.Execution
fpml :: String -> String

-- | Chop a list into segments, at separators identified by the predicate.
--   The separator items are discarded.
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Remove any prefix directory names, and given suffix extension.
basename :: String -> String -> String
fpmlNameConverter :: NameConverter
instance Eq XName
instance Show XName
instance Show HName

module Text.XML.HaXml.Schema.PrimitiveTypes

-- | Ultimately, an XML parser will find some plain text as the content of
--   a simpleType, which will need to be parsed. We use a TextParser,
--   because values of simpleTypes can also be given elsewhere, e.g. as
--   attribute values in an XSD definition, e.g. to restrict the
--   permissible values of the simpleType. Such restrictions are therefore
--   implemented as layered parsers.
class SimpleType a
acceptingParser :: SimpleType a => TextParser a
simpleTypeText :: SimpleType a => a -> String
newtype XsdString
XsdString :: String -> XsdString
type Boolean = Bool
data Base64Binary
Base64Binary :: String -> Base64Binary
data HexBinary
HexBinary :: String -> HexBinary

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *
data Decimal
Decimal :: Double -> Decimal

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
data AnyURI
AnyURI :: String -> AnyURI

-- | A QName is a (possibly) qualified name, in the sense of XML
--   namespaces.
data QName
N :: Name -> QName
QN :: Namespace -> Name -> QName
data NOTATION
NOTATION :: String -> NOTATION
data Duration
Duration :: Bool -> Int -> Int -> Int -> Int -> Int -> Float -> Duration
data DateTime
DateTime :: String -> DateTime
data Time
Time :: String -> Time
data Date
Date :: String -> Date
data GYearMonth
GYearMonth :: String -> GYearMonth
data GYear
GYear :: String -> GYear
data GMonthDay
GMonthDay :: String -> GMonthDay
data GDay
GDay :: String -> GDay
data GMonth
GMonth :: String -> GMonth
newtype NormalizedString
Normalized :: String -> NormalizedString
newtype Token
Token :: String -> Token
newtype Language
Language :: String -> Language
newtype Name
Name :: String -> Name
newtype NCName
NCName :: String -> NCName
newtype ID
ID :: String -> ID
newtype IDREF
IDREF :: String -> IDREF
newtype IDREFS
IDREFS :: String -> IDREFS
newtype ENTITY
ENTITY :: String -> ENTITY
newtype ENTITIES
ENTITIES :: String -> ENTITIES
newtype NMTOKEN
NMTOKEN :: String -> NMTOKEN
newtype NMTOKENS
NMTOKENS :: String -> NMTOKENS

-- | Arbitrary-precision integers.
data Integer :: *
newtype NonPositiveInteger
NonPos :: Integer -> NonPositiveInteger
newtype NegativeInteger
Negative :: Integer -> NegativeInteger
newtype Long
Long :: Int64 -> Long

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *
newtype Short
Short :: Int16 -> Short
newtype Byte
Byte :: Int8 -> Byte
newtype NonNegativeInteger
NonNeg :: Integer -> NonNegativeInteger
newtype UnsignedLong
ULong :: Word64 -> UnsignedLong
newtype UnsignedInt
UInt :: Word32 -> UnsignedInt
newtype UnsignedShort
UShort :: Word16 -> UnsignedShort
newtype UnsignedByte
UByte :: Word8 -> UnsignedByte
newtype PositiveInteger
Positive :: Integer -> PositiveInteger
instance Eq XsdString
instance Show XsdString
instance Eq Base64Binary
instance Show Base64Binary
instance Eq HexBinary
instance Show HexBinary
instance Eq AnyURI
instance Show AnyURI
instance Eq NOTATION
instance Show NOTATION
instance Eq Decimal
instance Show Decimal
instance Eq Duration
instance Show Duration
instance Eq DateTime
instance Show DateTime
instance Eq Time
instance Show Time
instance Eq Date
instance Show Date
instance Eq GYearMonth
instance Show GYearMonth
instance Eq GYear
instance Show GYear
instance Eq GMonthDay
instance Show GMonthDay
instance Eq GDay
instance Show GDay
instance Eq GMonth
instance Show GMonth
instance Eq NormalizedString
instance Show NormalizedString
instance Eq Token
instance Show Token
instance Eq Language
instance Show Language
instance Eq Name
instance Show Name
instance Eq NCName
instance Show NCName
instance Eq ID
instance Show ID
instance Eq IDREF
instance Show IDREF
instance Eq IDREFS
instance Show IDREFS
instance Eq ENTITY
instance Show ENTITY
instance Eq ENTITIES
instance Show ENTITIES
instance Eq NMTOKEN
instance Show NMTOKEN
instance Eq NMTOKENS
instance Show NMTOKENS
instance Eq NonPositiveInteger
instance Show NonPositiveInteger
instance Eq NegativeInteger
instance Show NegativeInteger
instance Eq Long
instance Show Long
instance Eq Short
instance Show Short
instance Eq Byte
instance Show Byte
instance Eq NonNegativeInteger
instance Show NonNegativeInteger
instance Eq UnsignedLong
instance Show UnsignedLong
instance Eq UnsignedInt
instance Show UnsignedInt
instance Eq UnsignedShort
instance Show UnsignedShort
instance Eq UnsignedByte
instance Show UnsignedByte
instance Eq PositiveInteger
instance Show PositiveInteger
instance SimpleType PositiveInteger
instance SimpleType UnsignedByte
instance SimpleType UnsignedShort
instance SimpleType UnsignedInt
instance SimpleType UnsignedLong
instance SimpleType NonNegativeInteger
instance SimpleType Byte
instance SimpleType Short
instance SimpleType Int
instance SimpleType Long
instance SimpleType NegativeInteger
instance SimpleType NonPositiveInteger
instance SimpleType Integer
instance SimpleType NMTOKENS
instance SimpleType NMTOKEN
instance SimpleType ENTITIES
instance SimpleType ENTITY
instance SimpleType IDREFS
instance SimpleType IDREF
instance SimpleType ID
instance SimpleType NCName
instance SimpleType Name
instance SimpleType Language
instance SimpleType Token
instance SimpleType NormalizedString
instance SimpleType GMonth
instance SimpleType GDay
instance SimpleType GMonthDay
instance SimpleType GYear
instance SimpleType GYearMonth
instance SimpleType Date
instance SimpleType Time
instance SimpleType DateTime
instance SimpleType Duration
instance SimpleType Double
instance SimpleType Float
instance SimpleType Decimal
instance SimpleType NOTATION
instance SimpleType AnyURI
instance SimpleType HexBinary
instance SimpleType Base64Binary
instance SimpleType XsdString
instance SimpleType Bool

module Text.XML.HaXml.TypeMapping

-- | <tt>HTypeable</tt> promises that we can create an explicit
--   representation of of the type of any value.
class HTypeable a
toHType :: HTypeable a => a -> HType

-- | A concrete representation of any Haskell type.
data HType
Maybe :: HType -> HType
List :: HType -> HType
Tuple :: [HType] -> HType

-- | separate Haskell name and XML name
Prim :: String -> String -> HType
String :: HType

-- | A user-defined type has a name, a sequence of type variables, and a
--   set of constructors. (The variables might already be instantiated to
--   actual types.)
Defined :: String -> [HType] -> [Constr] -> HType

-- | A concrete representation of any user-defined Haskell constructor. The
--   constructor has a name, and a sequence of component types. The first
--   sequence of types represents the minimum set of free type variables
--   occurring in the (second) list of real component types. If there are
--   fieldnames, they are contained in the final list, and correspond
--   one-to-one with the component types.
data Constr
Constr :: String -> [HType] -> [HType] -> Constr
showHType :: HType -> ShowS

-- | Project the n'th constructor from an HType and convert it to a string
--   suitable for an XML tagname.
showConstr :: Int -> HType -> String

-- | <a>toDTD</a> converts a concrete representation of the Haskell type of
--   a value (obtained by the method <a>toHType</a>) into a real
--   DocTypeDecl. It ensures that PERefs are defined before they are used,
--   and that no element or attribute-list is declared more than once.
toDTD :: HType -> DocTypeDecl
instance Eq Constr
instance Show Constr
instance Show HType
instance HTypeable a => HTypeable [a]
instance (HTypeable a, HTypeable b) => HTypeable (Either a b)
instance HTypeable a => HTypeable (Maybe a)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o) => HTypeable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n) => HTypeable (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m) => HTypeable (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l) => HTypeable (a, b, c, d, e, f, g, h, i, j, k, l)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k) => HTypeable (a, b, c, d, e, f, g, h, i, j, k)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j) => HTypeable (a, b, c, d, e, f, g, h, i, j)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i) => HTypeable (a, b, c, d, e, f, g, h, i)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h) => HTypeable (a, b, c, d, e, f, g, h)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g) => HTypeable (a, b, c, d, e, f, g)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f) => HTypeable (a, b, c, d, e, f)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e) => HTypeable (a, b, c, d, e)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d) => HTypeable (a, b, c, d)
instance (HTypeable a, HTypeable b, HTypeable c) => HTypeable (a, b, c)
instance (HTypeable a, HTypeable b) => HTypeable (a, b)
instance HTypeable ()
instance HTypeable Char
instance HTypeable Double
instance HTypeable Float
instance HTypeable Integer
instance HTypeable Int
instance HTypeable Bool
instance Eq HType


-- | The class <a>XmlContent</a> is a kind of replacement for Read and
--   Show: it provides conversions between a generic XML tree
--   representation and your own more specialised typeful Haskell data
--   trees.
--   
--   If you are starting with a set of Haskell datatypes, use DrIFT to
--   derive instances of this class for you:
--   http://repetae.net/john/computer/haskell/DrIFT If you are starting
--   with an XML DTD, use HaXml's tool DtdToHaskell to generate both the
--   Haskell types and the corresponding instances.
--   
--   This unified class interface replaces two previous (somewhat similar)
--   classes: Haskell2Xml and Xml2Haskell. There was no real reason to have
--   separate classes depending on how you originally defined your
--   datatypes. However, some instances for basic types like lists will
--   depend on which direction you are using. See Text.XML.HaXml.XmlContent
--   and Text.XML.HaXml.XmlContent.Haskell.
module Text.XML.HaXml.XmlContent.Parser

-- | The symbol table stored in a document holds all its general entity
--   reference definitions.
data Document i
Document :: Prolog -> (SymTab EntityDef) -> (Element i) -> [Misc] -> Document i
data Element i
Elem :: QName -> [Attribute] -> [Content i] -> Element i
data ElemTag
ElemTag :: QName -> [Attribute] -> ElemTag
data Content i
CElem :: (Element i) -> i -> Content i

-- | bool is whether whitespace is significant
CString :: Bool -> CharData -> i -> Content i
CRef :: Reference -> i -> Content i
CMisc :: Misc -> i -> Content i
type Attribute = (QName, AttValue)
data AttValue
AttValue :: [Either String Reference] -> AttValue
data Prolog
Prolog :: (Maybe XMLDecl) -> [Misc] -> (Maybe DocTypeDecl) -> [Misc] -> Prolog
data Reference
RefEntity :: EntityRef -> Reference
RefChar :: CharRef -> Reference

-- | The <tt>XmlContent</tt> class promises that an XML Content element can
--   be converted to and from a Haskell value.
class HTypeable a => XmlContent a where xToChar = error "HaXml.XmlContent.xToChar used in error" xFromChar = error "HaXml.XmlContent.xFromChar used in error"
parseContents :: XmlContent a => XMLParser a
toContents :: XmlContent a => a -> [Content ()]
xToChar :: XmlContent a => a -> Char
xFromChar :: XmlContent a => Char -> a

-- | The <tt>XmlAttributes</tt> class promises that a list of XML tag
--   attributes can be converted to and from a Haskell value.
class XmlAttributes a
fromAttrs :: XmlAttributes a => [Attribute] -> a
toAttrs :: XmlAttributes a => a -> [Attribute]

-- | The <tt>XmlAttrType</tt> class promises that an attribute taking an
--   XML enumerated type can be converted to and from a Haskell value.
class XmlAttrType a
fromAttrToTyp :: XmlAttrType a => String -> Attribute -> Maybe a
toAttrFrTyp :: XmlAttrType a => String -> a -> Maybe Attribute

-- | We need a parsing monad for reading generic XML Content into specific
--   datatypes. This is a specialisation of the Text.ParserCombinators.Poly
--   ones, where the input token type is fixed as XML Content.
type XMLParser a = Parser (Content Posn) a

-- | The most primitive combinator for XMLParser - get one content item.
content :: String -> XMLParser (Content Posn)

-- | A specialisation of <tt>posnElementWith (==)</tt>.
posnElement :: [String] -> XMLParser (Posn, Element Posn)

-- | Get the next content element, checking that it has one of the required
--   tags. (Skips over comments and whitespace, rejects text and refs.)
element :: [String] -> XMLParser (Element Posn)

-- | Run an XMLParser on the contents of the given element (i.e. not on the
--   current monadic content sequence), checking that the contents are
--   exhausted, before returning the calculated value within the current
--   parser context.
interior :: Element Posn -> XMLParser a -> XMLParser a

-- | A combination of element + interior.
inElement :: String -> XMLParser a -> XMLParser a

-- | <a>text</a> is a counterpart to <a>element</a>, parsing text content
--   if it exists. Adjacent text and references are coalesced.
text :: XMLParser String

-- | Do some parsing of the attributes of the given element
attributes :: XmlAttributes a => Element Posn -> XMLParser a

-- | Get the next content element, checking that it has one of the required
--   tags, using the given matching function. (Skips over comments and
--   whitespace, rejects text and refs. Also returns position of element.)
posnElementWith :: (String -> String -> Bool) -> [String] -> XMLParser (Posn, Element Posn)

-- | Like element, only permits a more flexible match against the tagname.
elementWith :: (String -> String -> Bool) -> [String] -> XMLParser (Element Posn)

-- | A combination of elementWith + interior.
inElementWith :: (String -> String -> Bool) -> String -> XMLParser a -> XMLParser a

-- | 'choice f p' means if parseContents succeeds, apply f to the result,
--   otherwise use the continuation parser.
choice :: XmlContent a => (a -> b) -> XMLParser b -> XMLParser b

-- | not sure this is needed now. 'definite p' previously ensured that an
--   element was definitely present. Now I think the monad might take care
--   of that for us.
definite :: XmlContent a => XMLParser a -> String -> String -> XMLParser a

-- | Generate an element with no attributes, named for its HType.
mkElem :: XmlContent a => a -> [Content ()] -> Content ()

-- | Generate an element with no attributes, named directly.
mkElemC :: String -> [Content ()] -> Content ()

-- | Generate a single attribute.
mkAttr :: String -> String -> Attribute

-- | Turn a simple string into XML text.
toText :: String -> [Content ()]

-- | Turn a string into an XML CDATA section. (i.e. special characters like
--   <tt>&amp;</tt> are preserved without interpretation.)
toCData :: String -> [Content ()]
maybeToAttr :: (String -> a -> Maybe Attribute) -> String -> Maybe a -> Maybe Attribute
defaultToAttr :: (String -> a -> Maybe Attribute) -> String -> Defaultable a -> Maybe Attribute
definiteA :: (String -> Attribute -> Maybe a) -> String -> String -> [Attribute] -> a
defaultA :: (String -> Attribute -> Maybe a) -> a -> String -> [Attribute] -> Defaultable a
possibleA :: (String -> Attribute -> Maybe a) -> String -> [Attribute] -> Maybe a
fromAttrToStr :: String -> Attribute -> Maybe String
toAttrFrStr :: String -> String -> Maybe Attribute

-- | If an attribute is defaultable, then it either takes the default value
--   (which is omitted from the output), or a non-default value (which
--   obviously must be printed).
data Defaultable a
Default :: a -> Defaultable a
NonDefault :: a -> Defaultable a
str2attr :: String -> AttValue
attr2str :: AttValue -> String

-- | Read a single attribute called "value".
attval :: Read a => Element i -> a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
catMaybes :: [Maybe a] -> [a]

-- | The List1 type represents lists with at least one element. It is
--   required for DTD content models that use + as a modifier.
data List1 a
NonEmpty :: [a] -> List1 a

-- | A type corresponding to XML's ANY contentspec. It is either a list of
--   unconverted xml <a>Content</a> or some <a>XmlContent</a>-able value.
--   
--   Parsing functions (e.g. <a>parseContents</a>) will always produce
--   <a>UnConverted</a>. Note: The Show instance for <a>UnConverted</a>
--   uses <a>verbatim</a>.
data ANYContent
ANYContent :: a -> ANYContent
UnConverted :: [Content Posn] -> ANYContent
instance Eq a => Eq (Defaultable a)
instance Show a => Show (Defaultable a)
instance Eq a => Eq (List1 a)
instance Show a => Show (List1 a)
instance XmlContent ANYContent
instance HTypeable ANYContent
instance XmlContent a => XmlContent (List1 a)
instance HTypeable a => HTypeable (List1 a)
instance Eq ANYContent
instance Show ANYContent
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o) => XmlContent (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n) => XmlContent (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m) => XmlContent (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l) => XmlContent (a, b, c, d, e, f, g, h, i, j, k, l)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k) => XmlContent (a, b, c, d, e, f, g, h, i, j, k)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j) => XmlContent (a, b, c, d, e, f, g, h, i, j)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i) => XmlContent (a, b, c, d, e, f, g, h, i)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h) => XmlContent (a, b, c, d, e, f, g, h)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g) => XmlContent (a, b, c, d, e, f, g)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f) => XmlContent (a, b, c, d, e, f)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e) => XmlContent (a, b, c, d, e)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d) => XmlContent (a, b, c, d)
instance (XmlContent a, XmlContent b, XmlContent c) => XmlContent (a, b, c)
instance (XmlContent a, XmlContent b) => XmlContent (a, b)


-- | The class <a>XmlContent</a> is a kind of replacement for Read and
--   Show: it provides conversions between a generic XML tree
--   representation and your own more specialised typeful Haskell data
--   trees.
--   
--   If you are starting with an XML DTD, use HaXml's tool DtdToHaskell to
--   generate both the Haskell types and the corresponding instances.
--   
--   If you are starting with a set of Haskell datatypes, use DrIFT to
--   derive instances of this class for you:
--   http://repetae.net/john/computer/haskell/DrIFT and _do_not_ use the
--   current module, but rather Text.XML.HaXml.XmlContent.Haskell, for the
--   correct matching instances for standard Haskell datatypes.
module Text.XML.HaXml.XmlContent

-- | Convert a fully-typed XML document to a string (with or without DTD).
toXml :: XmlContent a => Bool -> a -> Document ()

-- | Read a Haskell value from an XML document, ignoring the DTD and using
--   the Haskell result type to determine how to parse it.
fromXml :: XmlContent a => Document Posn -> Either String a

-- | Read a fully-typed XML document from a string.
readXml :: XmlContent a => String -> Either String a

-- | Convert a fully-typed XML document to a string (without DTD).
showXml :: XmlContent a => Bool -> a -> String

-- | Convert a fully-typed XML document to a ByteString (without DTD).
fpsShowXml :: XmlContent a => Bool -> a -> ByteString

-- | Read an XML document from a file and convert it to a fully-typed
--   Haskell value.
fReadXml :: XmlContent a => FilePath -> IO a

-- | Write a fully-typed Haskell value to the given file as an XML
--   document.
fWriteXml :: XmlContent a => FilePath -> a -> IO ()

-- | Write any Haskell value to the given file as an XML document, using
--   the FastPackedString interface (output will not be prettified).
fpsWriteXml :: XmlContent a => FilePath -> a -> IO ()

-- | Read a fully-typed XML document from a file handle.
hGetXml :: XmlContent a => Handle -> IO a

-- | Write a fully-typed XML document to a file handle.
hPutXml :: XmlContent a => Handle -> Bool -> a -> IO ()

-- | Write a fully-typed XML document to a file handle, using the
--   FastPackedString interface (output will not be prettified).
fpsHPutXml :: XmlContent a => Handle -> Bool -> a -> IO ()
instance XmlContent a => XmlContent (Maybe a)
instance XmlContent a => XmlContent [a]
instance XmlContent Char


-- | Validate a document against a dtd.
module Text.XML.HaXml.Validate

-- | <a>validate</a> takes a DTD and a tagged element, and returns a list
--   of errors in the document with respect to its DTD.
--   
--   If you have several documents to validate against a single DTD, then
--   you will gain efficiency by freezing-in the DTD through partial
--   application, e.g. <tt>checkMyDTD = validate myDTD</tt>.
validate :: DocTypeDecl -> Element i -> [String]

-- | <a>partialValidate</a> is like validate, except that it does not check
--   that the element type matches that of the DTD's root element.
partialValidate :: DocTypeDecl -> Element i -> [String]

module Text.XML.HaXml.OneOfN

-- | Somewhat of a nonsense - a choice of a single item. But sometimes it
--   occurs in auto-generated code.
data OneOf1 a
OneOf1 :: a -> OneOf1 a
foldOneOf1 :: (a -> z) -> OneOf1 a -> z

-- | Equivalent to the Either type, but using the regular naming scheme of
--   this module.
data OneOf2 a b
OneOf2 :: a -> OneOf2 a b
TwoOf2 :: b -> OneOf2 a b
foldOneOf2 :: (a -> z) -> (b -> z) -> OneOf2 a b -> z
data OneOf3 a b c
OneOf3 :: a -> OneOf3 a b c
TwoOf3 :: b -> OneOf3 a b c
ThreeOf3 :: c -> OneOf3 a b c
foldOneOf3 :: (a -> z) -> (b -> z) -> (c -> z) -> OneOf3 a b c -> z
data OneOf4 a b c d
OneOf4 :: a -> OneOf4 a b c d
TwoOf4 :: b -> OneOf4 a b c d
ThreeOf4 :: c -> OneOf4 a b c d
FourOf4 :: d -> OneOf4 a b c d
foldOneOf4 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> OneOf4 a b c d -> z
data OneOf5 a b c d e
OneOf5 :: a -> OneOf5 a b c d e
TwoOf5 :: b -> OneOf5 a b c d e
ThreeOf5 :: c -> OneOf5 a b c d e
FourOf5 :: d -> OneOf5 a b c d e
FiveOf5 :: e -> OneOf5 a b c d e
foldOneOf5 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> OneOf5 a b c d e -> z
data OneOf6 a b c d e f
OneOf6 :: a -> OneOf6 a b c d e f
TwoOf6 :: b -> OneOf6 a b c d e f
ThreeOf6 :: c -> OneOf6 a b c d e f
FourOf6 :: d -> OneOf6 a b c d e f
FiveOf6 :: e -> OneOf6 a b c d e f
SixOf6 :: f -> OneOf6 a b c d e f
foldOneOf6 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> OneOf6 a b c d e f -> z
data OneOf7 a b c d e f g
OneOf7 :: a -> OneOf7 a b c d e f g
TwoOf7 :: b -> OneOf7 a b c d e f g
ThreeOf7 :: c -> OneOf7 a b c d e f g
FourOf7 :: d -> OneOf7 a b c d e f g
FiveOf7 :: e -> OneOf7 a b c d e f g
SixOf7 :: f -> OneOf7 a b c d e f g
SevenOf7 :: g -> OneOf7 a b c d e f g
foldOneOf7 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> OneOf7 a b c d e f g -> z
data OneOf8 a b c d e f g h
OneOf8 :: a -> OneOf8 a b c d e f g h
TwoOf8 :: b -> OneOf8 a b c d e f g h
ThreeOf8 :: c -> OneOf8 a b c d e f g h
FourOf8 :: d -> OneOf8 a b c d e f g h
FiveOf8 :: e -> OneOf8 a b c d e f g h
SixOf8 :: f -> OneOf8 a b c d e f g h
SevenOf8 :: g -> OneOf8 a b c d e f g h
EightOf8 :: h -> OneOf8 a b c d e f g h
foldOneOf8 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> OneOf8 a b c d e f g h -> z
data OneOf9 a b c d e f g h i
OneOf9 :: a -> OneOf9 a b c d e f g h i
TwoOf9 :: b -> OneOf9 a b c d e f g h i
ThreeOf9 :: c -> OneOf9 a b c d e f g h i
FourOf9 :: d -> OneOf9 a b c d e f g h i
FiveOf9 :: e -> OneOf9 a b c d e f g h i
SixOf9 :: f -> OneOf9 a b c d e f g h i
SevenOf9 :: g -> OneOf9 a b c d e f g h i
EightOf9 :: h -> OneOf9 a b c d e f g h i
NineOf9 :: i -> OneOf9 a b c d e f g h i
foldOneOf9 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> OneOf9 a b c d e f g h i -> z
data OneOf10 a b c d e f g h i j
OneOf10 :: a -> OneOf10 a b c d e f g h i j
TwoOf10 :: b -> OneOf10 a b c d e f g h i j
ThreeOf10 :: c -> OneOf10 a b c d e f g h i j
FourOf10 :: d -> OneOf10 a b c d e f g h i j
FiveOf10 :: e -> OneOf10 a b c d e f g h i j
SixOf10 :: f -> OneOf10 a b c d e f g h i j
SevenOf10 :: g -> OneOf10 a b c d e f g h i j
EightOf10 :: h -> OneOf10 a b c d e f g h i j
NineOf10 :: i -> OneOf10 a b c d e f g h i j
TenOf10 :: j -> OneOf10 a b c d e f g h i j
foldOneOf10 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> OneOf10 a b c d e f g h i j -> z
data OneOf11 a b c d e f g h i j k
OneOf11 :: a -> OneOf11 a b c d e f g h i j k
TwoOf11 :: b -> OneOf11 a b c d e f g h i j k
ThreeOf11 :: c -> OneOf11 a b c d e f g h i j k
FourOf11 :: d -> OneOf11 a b c d e f g h i j k
FiveOf11 :: e -> OneOf11 a b c d e f g h i j k
SixOf11 :: f -> OneOf11 a b c d e f g h i j k
SevenOf11 :: g -> OneOf11 a b c d e f g h i j k
EightOf11 :: h -> OneOf11 a b c d e f g h i j k
NineOf11 :: i -> OneOf11 a b c d e f g h i j k
TenOf11 :: j -> OneOf11 a b c d e f g h i j k
ElevenOf11 :: k -> OneOf11 a b c d e f g h i j k
foldOneOf11 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> OneOf11 a b c d e f g h i j k -> z
data OneOf12 a b c d e f g h i j k l
OneOf12 :: a -> OneOf12 a b c d e f g h i j k l
TwoOf12 :: b -> OneOf12 a b c d e f g h i j k l
ThreeOf12 :: c -> OneOf12 a b c d e f g h i j k l
FourOf12 :: d -> OneOf12 a b c d e f g h i j k l
FiveOf12 :: e -> OneOf12 a b c d e f g h i j k l
SixOf12 :: f -> OneOf12 a b c d e f g h i j k l
SevenOf12 :: g -> OneOf12 a b c d e f g h i j k l
EightOf12 :: h -> OneOf12 a b c d e f g h i j k l
NineOf12 :: i -> OneOf12 a b c d e f g h i j k l
TenOf12 :: j -> OneOf12 a b c d e f g h i j k l
ElevenOf12 :: k -> OneOf12 a b c d e f g h i j k l
TwelveOf12 :: l -> OneOf12 a b c d e f g h i j k l
foldOneOf12 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> OneOf12 a b c d e f g h i j k l -> z
data OneOf13 a b c d e f g h i j k l m
OneOf13 :: a -> OneOf13 a b c d e f g h i j k l m
TwoOf13 :: b -> OneOf13 a b c d e f g h i j k l m
ThreeOf13 :: c -> OneOf13 a b c d e f g h i j k l m
FourOf13 :: d -> OneOf13 a b c d e f g h i j k l m
FiveOf13 :: e -> OneOf13 a b c d e f g h i j k l m
SixOf13 :: f -> OneOf13 a b c d e f g h i j k l m
SevenOf13 :: g -> OneOf13 a b c d e f g h i j k l m
EightOf13 :: h -> OneOf13 a b c d e f g h i j k l m
NineOf13 :: i -> OneOf13 a b c d e f g h i j k l m
TenOf13 :: j -> OneOf13 a b c d e f g h i j k l m
ElevenOf13 :: k -> OneOf13 a b c d e f g h i j k l m
TwelveOf13 :: l -> OneOf13 a b c d e f g h i j k l m
ThirteenOf13 :: m -> OneOf13 a b c d e f g h i j k l m
foldOneOf13 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> OneOf13 a b c d e f g h i j k l m -> z
data OneOf14 a b c d e f g h i j k l m n
OneOf14 :: a -> OneOf14 a b c d e f g h i j k l m n
TwoOf14 :: b -> OneOf14 a b c d e f g h i j k l m n
ThreeOf14 :: c -> OneOf14 a b c d e f g h i j k l m n
FourOf14 :: d -> OneOf14 a b c d e f g h i j k l m n
FiveOf14 :: e -> OneOf14 a b c d e f g h i j k l m n
SixOf14 :: f -> OneOf14 a b c d e f g h i j k l m n
SevenOf14 :: g -> OneOf14 a b c d e f g h i j k l m n
EightOf14 :: h -> OneOf14 a b c d e f g h i j k l m n
NineOf14 :: i -> OneOf14 a b c d e f g h i j k l m n
TenOf14 :: j -> OneOf14 a b c d e f g h i j k l m n
ElevenOf14 :: k -> OneOf14 a b c d e f g h i j k l m n
TwelveOf14 :: l -> OneOf14 a b c d e f g h i j k l m n
ThirteenOf14 :: m -> OneOf14 a b c d e f g h i j k l m n
FourteenOf14 :: n -> OneOf14 a b c d e f g h i j k l m n
foldOneOf14 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> OneOf14 a b c d e f g h i j k l m n -> z
data OneOf15 a b c d e f g h i j k l m n o
OneOf15 :: a -> OneOf15 a b c d e f g h i j k l m n o
TwoOf15 :: b -> OneOf15 a b c d e f g h i j k l m n o
ThreeOf15 :: c -> OneOf15 a b c d e f g h i j k l m n o
FourOf15 :: d -> OneOf15 a b c d e f g h i j k l m n o
FiveOf15 :: e -> OneOf15 a b c d e f g h i j k l m n o
SixOf15 :: f -> OneOf15 a b c d e f g h i j k l m n o
SevenOf15 :: g -> OneOf15 a b c d e f g h i j k l m n o
EightOf15 :: h -> OneOf15 a b c d e f g h i j k l m n o
NineOf15 :: i -> OneOf15 a b c d e f g h i j k l m n o
TenOf15 :: j -> OneOf15 a b c d e f g h i j k l m n o
ElevenOf15 :: k -> OneOf15 a b c d e f g h i j k l m n o
TwelveOf15 :: l -> OneOf15 a b c d e f g h i j k l m n o
ThirteenOf15 :: m -> OneOf15 a b c d e f g h i j k l m n o
FourteenOf15 :: n -> OneOf15 a b c d e f g h i j k l m n o
FifteenOf15 :: o -> OneOf15 a b c d e f g h i j k l m n o
foldOneOf15 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> OneOf15 a b c d e f g h i j k l m n o -> z
data OneOf16 a b c d e f g h i j k l m n o p
OneOf16 :: a -> OneOf16 a b c d e f g h i j k l m n o p
TwoOf16 :: b -> OneOf16 a b c d e f g h i j k l m n o p
ThreeOf16 :: c -> OneOf16 a b c d e f g h i j k l m n o p
FourOf16 :: d -> OneOf16 a b c d e f g h i j k l m n o p
FiveOf16 :: e -> OneOf16 a b c d e f g h i j k l m n o p
SixOf16 :: f -> OneOf16 a b c d e f g h i j k l m n o p
SevenOf16 :: g -> OneOf16 a b c d e f g h i j k l m n o p
EightOf16 :: h -> OneOf16 a b c d e f g h i j k l m n o p
NineOf16 :: i -> OneOf16 a b c d e f g h i j k l m n o p
TenOf16 :: j -> OneOf16 a b c d e f g h i j k l m n o p
ElevenOf16 :: k -> OneOf16 a b c d e f g h i j k l m n o p
TwelveOf16 :: l -> OneOf16 a b c d e f g h i j k l m n o p
ThirteenOf16 :: m -> OneOf16 a b c d e f g h i j k l m n o p
FourteenOf16 :: n -> OneOf16 a b c d e f g h i j k l m n o p
FifteenOf16 :: o -> OneOf16 a b c d e f g h i j k l m n o p
SixteenOf16 :: p -> OneOf16 a b c d e f g h i j k l m n o p
foldOneOf16 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> (p -> z) -> OneOf16 a b c d e f g h i j k l m n o p -> z
data OneOf17 a b c d e f g h i j k l m n o p q
OneOf17 :: a -> OneOf17 a b c d e f g h i j k l m n o p q
TwoOf17 :: b -> OneOf17 a b c d e f g h i j k l m n o p q
ThreeOf17 :: c -> OneOf17 a b c d e f g h i j k l m n o p q
FourOf17 :: d -> OneOf17 a b c d e f g h i j k l m n o p q
FiveOf17 :: e -> OneOf17 a b c d e f g h i j k l m n o p q
SixOf17 :: f -> OneOf17 a b c d e f g h i j k l m n o p q
SevenOf17 :: g -> OneOf17 a b c d e f g h i j k l m n o p q
EightOf17 :: h -> OneOf17 a b c d e f g h i j k l m n o p q
NineOf17 :: i -> OneOf17 a b c d e f g h i j k l m n o p q
TenOf17 :: j -> OneOf17 a b c d e f g h i j k l m n o p q
ElevenOf17 :: k -> OneOf17 a b c d e f g h i j k l m n o p q
TwelveOf17 :: l -> OneOf17 a b c d e f g h i j k l m n o p q
ThirteenOf17 :: m -> OneOf17 a b c d e f g h i j k l m n o p q
FourteenOf17 :: n -> OneOf17 a b c d e f g h i j k l m n o p q
FifteenOf17 :: o -> OneOf17 a b c d e f g h i j k l m n o p q
SixteenOf17 :: p -> OneOf17 a b c d e f g h i j k l m n o p q
SeventeenOf17 :: q -> OneOf17 a b c d e f g h i j k l m n o p q
foldOneOf17 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> (p -> z) -> (q -> z) -> OneOf17 a b c d e f g h i j k l m n o p q -> z
data OneOf18 a b c d e f g h i j k l m n o p q r
OneOf18 :: a -> OneOf18 a b c d e f g h i j k l m n o p q r
TwoOf18 :: b -> OneOf18 a b c d e f g h i j k l m n o p q r
ThreeOf18 :: c -> OneOf18 a b c d e f g h i j k l m n o p q r
FourOf18 :: d -> OneOf18 a b c d e f g h i j k l m n o p q r
FiveOf18 :: e -> OneOf18 a b c d e f g h i j k l m n o p q r
SixOf18 :: f -> OneOf18 a b c d e f g h i j k l m n o p q r
SevenOf18 :: g -> OneOf18 a b c d e f g h i j k l m n o p q r
EightOf18 :: h -> OneOf18 a b c d e f g h i j k l m n o p q r
NineOf18 :: i -> OneOf18 a b c d e f g h i j k l m n o p q r
TenOf18 :: j -> OneOf18 a b c d e f g h i j k l m n o p q r
ElevenOf18 :: k -> OneOf18 a b c d e f g h i j k l m n o p q r
TwelveOf18 :: l -> OneOf18 a b c d e f g h i j k l m n o p q r
ThirteenOf18 :: m -> OneOf18 a b c d e f g h i j k l m n o p q r
FourteenOf18 :: n -> OneOf18 a b c d e f g h i j k l m n o p q r
FifteenOf18 :: o -> OneOf18 a b c d e f g h i j k l m n o p q r
SixteenOf18 :: p -> OneOf18 a b c d e f g h i j k l m n o p q r
SeventeenOf18 :: q -> OneOf18 a b c d e f g h i j k l m n o p q r
EighteenOf18 :: r -> OneOf18 a b c d e f g h i j k l m n o p q r
foldOneOf18 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> (p -> z) -> (q -> z) -> (r -> z) -> OneOf18 a b c d e f g h i j k l m n o p q r -> z
data OneOf19 a b c d e f g h i j k l m n o p q r s
OneOf19 :: a -> OneOf19 a b c d e f g h i j k l m n o p q r s
TwoOf19 :: b -> OneOf19 a b c d e f g h i j k l m n o p q r s
ThreeOf19 :: c -> OneOf19 a b c d e f g h i j k l m n o p q r s
FourOf19 :: d -> OneOf19 a b c d e f g h i j k l m n o p q r s
FiveOf19 :: e -> OneOf19 a b c d e f g h i j k l m n o p q r s
SixOf19 :: f -> OneOf19 a b c d e f g h i j k l m n o p q r s
SevenOf19 :: g -> OneOf19 a b c d e f g h i j k l m n o p q r s
EightOf19 :: h -> OneOf19 a b c d e f g h i j k l m n o p q r s
NineOf19 :: i -> OneOf19 a b c d e f g h i j k l m n o p q r s
TenOf19 :: j -> OneOf19 a b c d e f g h i j k l m n o p q r s
ElevenOf19 :: k -> OneOf19 a b c d e f g h i j k l m n o p q r s
TwelveOf19 :: l -> OneOf19 a b c d e f g h i j k l m n o p q r s
ThirteenOf19 :: m -> OneOf19 a b c d e f g h i j k l m n o p q r s
FourteenOf19 :: n -> OneOf19 a b c d e f g h i j k l m n o p q r s
FifteenOf19 :: o -> OneOf19 a b c d e f g h i j k l m n o p q r s
SixteenOf19 :: p -> OneOf19 a b c d e f g h i j k l m n o p q r s
SeventeenOf19 :: q -> OneOf19 a b c d e f g h i j k l m n o p q r s
EighteenOf19 :: r -> OneOf19 a b c d e f g h i j k l m n o p q r s
NineteenOf19 :: s -> OneOf19 a b c d e f g h i j k l m n o p q r s
foldOneOf19 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> (p -> z) -> (q -> z) -> (r -> z) -> (s -> z) -> OneOf19 a b c d e f g h i j k l m n o p q r s -> z
data OneOf20 a b c d e f g h i j k l m n o p q r s t
OneOf20 :: a -> OneOf20 a b c d e f g h i j k l m n o p q r s t
TwoOf20 :: b -> OneOf20 a b c d e f g h i j k l m n o p q r s t
ThreeOf20 :: c -> OneOf20 a b c d e f g h i j k l m n o p q r s t
FourOf20 :: d -> OneOf20 a b c d e f g h i j k l m n o p q r s t
FiveOf20 :: e -> OneOf20 a b c d e f g h i j k l m n o p q r s t
SixOf20 :: f -> OneOf20 a b c d e f g h i j k l m n o p q r s t
SevenOf20 :: g -> OneOf20 a b c d e f g h i j k l m n o p q r s t
EightOf20 :: h -> OneOf20 a b c d e f g h i j k l m n o p q r s t
NineOf20 :: i -> OneOf20 a b c d e f g h i j k l m n o p q r s t
TenOf20 :: j -> OneOf20 a b c d e f g h i j k l m n o p q r s t
ElevenOf20 :: k -> OneOf20 a b c d e f g h i j k l m n o p q r s t
TwelveOf20 :: l -> OneOf20 a b c d e f g h i j k l m n o p q r s t
ThirteenOf20 :: m -> OneOf20 a b c d e f g h i j k l m n o p q r s t
FourteenOf20 :: n -> OneOf20 a b c d e f g h i j k l m n o p q r s t
FifteenOf20 :: o -> OneOf20 a b c d e f g h i j k l m n o p q r s t
SixteenOf20 :: p -> OneOf20 a b c d e f g h i j k l m n o p q r s t
SeventeenOf20 :: q -> OneOf20 a b c d e f g h i j k l m n o p q r s t
EighteenOf20 :: r -> OneOf20 a b c d e f g h i j k l m n o p q r s t
NineteenOf20 :: s -> OneOf20 a b c d e f g h i j k l m n o p q r s t
TwentyOf20 :: t -> OneOf20 a b c d e f g h i j k l m n o p q r s t
foldOneOf20 :: (a -> z) -> (b -> z) -> (c -> z) -> (d -> z) -> (e -> z) -> (f -> z) -> (g -> z) -> (h -> z) -> (i -> z) -> (j -> z) -> (k -> z) -> (l -> z) -> (m -> z) -> (n -> z) -> (o -> z) -> (p -> z) -> (q -> z) -> (r -> z) -> (s -> z) -> (t -> z) -> OneOf20 a b c d e f g h i j k l m n o p q r s t -> z
instance Eq a => Eq (OneOf1 a)
instance Show a => Show (OneOf1 a)
instance (Eq a, Eq b) => Eq (OneOf2 a b)
instance (Show a, Show b) => Show (OneOf2 a b)
instance (Eq a, Eq b, Eq c) => Eq (OneOf3 a b c)
instance (Show a, Show b, Show c) => Show (OneOf3 a b c)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (OneOf4 a b c d)
instance (Show a, Show b, Show c, Show d) => Show (OneOf4 a b c d)
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (OneOf5 a b c d e)
instance (Show a, Show b, Show c, Show d, Show e) => Show (OneOf5 a b c d e)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (OneOf6 a b c d e f)
instance (Show a, Show b, Show c, Show d, Show e, Show f) => Show (OneOf6 a b c d e f)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (OneOf7 a b c d e f g)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g) => Show (OneOf7 a b c d e f g)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq (OneOf8 a b c d e f g h)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h) => Show (OneOf8 a b c d e f g h)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) => Eq (OneOf9 a b c d e f g h i)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i) => Show (OneOf9 a b c d e f g h i)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j) => Eq (OneOf10 a b c d e f g h i j)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j) => Show (OneOf10 a b c d e f g h i j)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k) => Eq (OneOf11 a b c d e f g h i j k)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k) => Show (OneOf11 a b c d e f g h i j k)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l) => Eq (OneOf12 a b c d e f g h i j k l)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l) => Show (OneOf12 a b c d e f g h i j k l)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m) => Eq (OneOf13 a b c d e f g h i j k l m)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m) => Show (OneOf13 a b c d e f g h i j k l m)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n) => Eq (OneOf14 a b c d e f g h i j k l m n)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n) => Show (OneOf14 a b c d e f g h i j k l m n)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) => Eq (OneOf15 a b c d e f g h i j k l m n o)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) => Show (OneOf15 a b c d e f g h i j k l m n o)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p) => Eq (OneOf16 a b c d e f g h i j k l m n o p)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p) => Show (OneOf16 a b c d e f g h i j k l m n o p)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p, Eq q) => Eq (OneOf17 a b c d e f g h i j k l m n o p q)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p, Show q) => Show (OneOf17 a b c d e f g h i j k l m n o p q)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p, Eq q, Eq r) => Eq (OneOf18 a b c d e f g h i j k l m n o p q r)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p, Show q, Show r) => Show (OneOf18 a b c d e f g h i j k l m n o p q r)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p, Eq q, Eq r, Eq s) => Eq (OneOf19 a b c d e f g h i j k l m n o p q r s)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p, Show q, Show r, Show s) => Show (OneOf19 a b c d e f g h i j k l m n o p q r s)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p, Eq q, Eq r, Eq s, Eq t) => Eq (OneOf20 a b c d e f g h i j k l m n o p q r s t)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p, Show q, Show r, Show s, Show t) => Show (OneOf20 a b c d e f g h i j k l m n o p q r s t)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o, XmlContent p, XmlContent q, XmlContent r, XmlContent s, XmlContent t) => XmlContent (OneOf20 a b c d e f g h i j k l m n o p q r s t)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o, HTypeable p, HTypeable q, HTypeable r, HTypeable s, HTypeable t) => HTypeable (OneOf20 a b c d e f g h i j k l m n o p q r s t)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o, XmlContent p, XmlContent q, XmlContent r, XmlContent s) => XmlContent (OneOf19 a b c d e f g h i j k l m n o p q r s)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o, HTypeable p, HTypeable q, HTypeable r, HTypeable s) => HTypeable (OneOf19 a b c d e f g h i j k l m n o p q r s)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o, XmlContent p, XmlContent q, XmlContent r) => XmlContent (OneOf18 a b c d e f g h i j k l m n o p q r)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o, HTypeable p, HTypeable q, HTypeable r) => HTypeable (OneOf18 a b c d e f g h i j k l m n o p q r)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o, XmlContent p, XmlContent q) => XmlContent (OneOf17 a b c d e f g h i j k l m n o p q)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o, HTypeable p, HTypeable q) => HTypeable (OneOf17 a b c d e f g h i j k l m n o p q)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o, XmlContent p) => XmlContent (OneOf16 a b c d e f g h i j k l m n o p)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o, HTypeable p) => HTypeable (OneOf16 a b c d e f g h i j k l m n o p)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n, XmlContent o) => XmlContent (OneOf15 a b c d e f g h i j k l m n o)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n, HTypeable o) => HTypeable (OneOf15 a b c d e f g h i j k l m n o)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m, XmlContent n) => XmlContent (OneOf14 a b c d e f g h i j k l m n)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m, HTypeable n) => HTypeable (OneOf14 a b c d e f g h i j k l m n)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l, XmlContent m) => XmlContent (OneOf13 a b c d e f g h i j k l m)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l, HTypeable m) => HTypeable (OneOf13 a b c d e f g h i j k l m)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k, XmlContent l) => XmlContent (OneOf12 a b c d e f g h i j k l)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k, HTypeable l) => HTypeable (OneOf12 a b c d e f g h i j k l)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j, XmlContent k) => XmlContent (OneOf11 a b c d e f g h i j k)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j, HTypeable k) => HTypeable (OneOf11 a b c d e f g h i j k)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i, XmlContent j) => XmlContent (OneOf10 a b c d e f g h i j)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i, HTypeable j) => HTypeable (OneOf10 a b c d e f g h i j)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h, XmlContent i) => XmlContent (OneOf9 a b c d e f g h i)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h, HTypeable i) => HTypeable (OneOf9 a b c d e f g h i)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g, XmlContent h) => XmlContent (OneOf8 a b c d e f g h)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g, HTypeable h) => HTypeable (OneOf8 a b c d e f g h)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f, XmlContent g) => XmlContent (OneOf7 a b c d e f g)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f, HTypeable g) => HTypeable (OneOf7 a b c d e f g)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e, XmlContent f) => XmlContent (OneOf6 a b c d e f)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e, HTypeable f) => HTypeable (OneOf6 a b c d e f)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d, XmlContent e) => XmlContent (OneOf5 a b c d e)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d, HTypeable e) => HTypeable (OneOf5 a b c d e)
instance (XmlContent a, XmlContent b, XmlContent c, XmlContent d) => XmlContent (OneOf4 a b c d)
instance (HTypeable a, HTypeable b, HTypeable c, HTypeable d) => HTypeable (OneOf4 a b c d)
instance (XmlContent a, XmlContent b, XmlContent c) => XmlContent (OneOf3 a b c)
instance (HTypeable a, HTypeable b, HTypeable c) => HTypeable (OneOf3 a b c)
instance (XmlContent a, XmlContent b) => XmlContent (OneOf2 a b)
instance (HTypeable a, HTypeable b) => HTypeable (OneOf2 a b)
instance XmlContent a => XmlContent (OneOf1 a)
instance HTypeable a => HTypeable (OneOf1 a)

module Text.XML.HaXml.Schema.Parse

-- | Lift boolean <a>or</a> over predicates.
(|||) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)

-- | Qualify an ordinary name with the XSD namespace.
xsd :: Name -> QName

-- | Predicate for comparing against an XSD-qualified name. (Also accepts
--   unqualified names, but this is probably a bit too lax. Doing it right
--   would require checking to see whether the current schema module's
--   default namespace is XSD or not.)
xsdTag :: String -> Content Posn -> Bool

-- | We need a Parser monad for reading from a sequence of generic XML
--   Contents into specific datatypes that model the structure of XSD
--   descriptions. This is a specialisation of the polyparse combinators,
--   fixing the input token type.
type XsdParser a = Parser (Content Posn) a

-- | Get the next content element, checking that it matches some criterion
--   given by the predicate. (Skips over comments and whitespace, rejects
--   text and refs. Also returns position of element.) The list of strings
--   argument is for error reporting - it usually represents a list of
--   expected tags.
posnElementWith :: (Content Posn -> Bool) -> [String] -> XsdParser (Posn, Element Posn)

-- | Get the next content element, checking that it has the required tag
--   belonging to the XSD namespace.
xsdElement :: Name -> XsdParser (Element Posn)

-- | Get the next content element, whatever it is.
anyElement :: XsdParser (Element Posn)

-- | Grab and parse any and all children of the next element.
allChildren :: XsdParser a -> XsdParser a

-- | Run an XsdParser on the child contents of the given element (i.e. not
--   in the current monadic content sequence), filtering the children
--   before parsing, and checking that the contents are exhausted, before
--   returning the calculated value within the current parser context.
interiorWith :: (Content Posn -> Bool) -> XsdParser a -> Element Posn -> XsdParser a

-- | Check for the presence (and value) of an attribute in the given
--   element. Absence results in failure.
attribute :: QName -> TextParser a -> Element Posn -> XsdParser a

-- | Grab any attributes that declare a locally-used prefix for a specific
--   namespace.
namespaceAttrs :: Element Posn -> XsdParser [Namespace]

-- | Predicate for whether an attribute belongs to a given namespace.
matchNamespace :: String -> Attribute -> Bool

-- | Tidy up the parsing context.
tidy :: t -> Result x a -> Result t a

-- | Given a URI for a targetNamespace, and a list of Namespaces, tell me
--   the prefix corresponding to the targetNamespace.
targetPrefix :: Maybe TargetNamespace -> [Namespace] -> Maybe String

-- | An auxiliary you might expect to find in Data.List
lookupBy :: (a -> Bool) -> [a] -> Maybe a

-- | Turn a qualified attribute value (two strings) into a qualified name
--   (QName), but excluding the case where the namespace prefix corresponds
--   to the targetNamespace of the current schema document.
qual :: Maybe TargetNamespace -> [Namespace] -> String -> String -> QName

-- | Parse a Schema declaration
schema :: Parser (Content Posn) Schema

-- | Parse a (possibly missing) <a>xsd:annotation</a> element.
annotation :: XsdParser Annotation

-- | Parse a definitely-occurring <a>xsd:annotation</a> element.
definiteAnnotation :: XsdParser Annotation

-- | Parse a FormDefault attribute.
qform :: TextParser QForm

-- | Parse a Final or Block attribute.
final :: TextParser Final
block :: TextParser Block

-- | Parse a schema item (just under the toplevel <a>xsd:schema</a>)
schemaItem :: (String -> String -> QName) -> XsdParser SchemaItem

-- | Parse an <a>xsd:include</a>.
include :: XsdParser SchemaItem

-- | Parse an <a>xsd:import</a>.
import_ :: XsdParser SchemaItem

-- | Parse a <a>xsd:redefine</a>.
redefine :: (String -> String -> QName) -> XsdParser SchemaItem

-- | Parse a <a>xsd:simpleType</a> decl.
simpleType :: (String -> String -> QName) -> XsdParser SimpleType
aFacet :: XsdParser Facet
facet :: String -> FacetType -> XsdParser Facet

-- | Parse a <a>xsd:complexType</a> decl.
complexType :: (String -> String -> QName) -> XsdParser ComplexType

-- | Parse the alternative contents of a <a>xsd:complexType</a> decl.
complexItem :: (String -> String -> QName) -> XsdParser ComplexItem

-- | Parse a particle decl.
particle :: (String -> String -> QName) -> XsdParser Particle

-- | Parse a particle decl with optional attributes.
particleAttrs :: (String -> String -> QName) -> XsdParser ParticleAttrs

-- | Parse an <a>xsd:all</a>, <a>xsd:choice</a>, or <a>xsd:sequence</a>
--   decl.
choiceOrSeq :: (String -> String -> QName) -> XsdParser ChoiceOrSeq

-- | Parse a <a>xsd:group</a> decl.
group_ :: (String -> String -> QName) -> XsdParser Group

-- | Parse an <a>xsd:element</a>, <a>xsd:group</a>, <a>xsd:all</a>,
--   <a>xsd:choice</a>, <a>xsd:sequence</a> or <a>xsd:any</a>.
elementEtc :: (String -> String -> QName) -> XsdParser ElementEtc

-- | Parse an <a>xsd:any</a>.
any_ :: XsdParser Any

-- | Parse an <a>xsd:anyAttribute</a>.
anyAttr :: XsdParser AnyAttr

-- | Parse an <a>xsd:attributegroup</a>.
attributeGroup :: (String -> String -> QName) -> XsdParser AttrGroup

-- | Parse an <a>xsd:element</a> decl.
elementDecl :: (String -> String -> QName) -> XsdParser ElementDecl

-- | Parse name and type attributes.
nameAndType :: (String -> String -> QName) -> Element Posn -> XsdParser NameAndType

-- | Parse an <a>xsd:attribute</a> decl.
attributeDecl :: (String -> String -> QName) -> XsdParser AttributeDecl

-- | Parse an occurrence range from attributes of given element.
occurs :: Element Posn -> XsdParser Occurs

-- | Parse a <a>xsd:unique</a>, <a>xsd:key</a>, or <a>xsd:keyref</a>.
uniqueKeyOrKeyRef :: (String -> String -> QName) -> XsdParser UniqueKeyOrKeyRef

-- | Parse a <a>xsd:unique</a>.
unique :: XsdParser Unique

-- | Parse a <a>xsd:key</a>.
key :: XsdParser Key

-- | Parse a <a>xsd:keyref</a>.
keyRef :: (String -> String -> QName) -> XsdParser KeyRef

-- | Parse a <a>xsd:selector</a>.
selector :: XsdParser Selector

-- | Parse a <a>xsd:field</a>.
field_ :: XsdParser Field

-- | Text parser for a URI (very simple, non-validating, probably
--   incorrect).
uri :: TextParser String

-- | Text parser for an arbitrary string consisting of possibly multiple
--   tokens.
string :: TextParser String
space :: TextParser String

-- | Parse a textual boolean, i.e. "true", "false", "0", or "1"
bool :: TextParser Bool

-- | Parse a "use" attribute value, i.e. "required", "optional", or
--   "prohibited"
use :: TextParser Use

-- | Parse a "processContents" attribute, i.e. "skip", "lax", or "strict".
processContents :: TextParser ProcessContents

-- | Parse an attribute value that should be a QName.
qname :: (String -> String -> QName) -> TextParser QName

-- | Parse an attribute value that should be a simple Name.
name :: TextParser Name


-- | A type model for Haskell datatypes that bears a reasonable
--   correspondence to the XSD type model.
module Text.XML.HaXml.Schema.HaskellTypeModel

-- | Comments can be attached to most things, but not all of them will
--   exist.
type Comment = Maybe String

-- | The whole Haskell module.
data Module
Module :: XName -> Maybe XName -> [Decl] -> [Decl] -> [Decl] -> Module
module_name :: Module -> XName
module_xsd_ns :: Module -> Maybe XName
module_re_exports :: Module -> [Decl]
module_import_only :: Module -> [Decl]
module_decls :: Module -> [Decl]

-- | There are essentially simple types, and complex types, each of which
--   can be either restricted or extended. There are four kinds of complex
--   type: choices, sequences, named groups, or a simple element with
--   content.
data Decl
NamedSimpleType :: XName -> XName -> Comment -> Decl
RestrictSimpleType :: XName -> XName -> [Restrict] -> Comment -> Decl
ExtendSimpleType :: XName -> XName -> [Attribute] -> Comment -> Decl
UnionSimpleTypes :: XName -> [XName] -> Comment -> Decl
EnumSimpleType :: XName -> [(XName, Comment)] -> Comment -> Decl
ElementsAttrs :: XName -> [Element] -> [Attribute] -> Comment -> Decl
ElementsAttrsAbstract :: XName -> [(XName, Maybe XName)] -> Comment -> Decl
ElementOfType :: Element -> Decl
ElementAbstractOfType :: XName -> XName -> [(XName, Maybe XName)] -> Comment -> Decl
Choice :: XName -> [Element] -> Comment -> Decl
Group :: XName -> [Element] -> Comment -> Decl
RestrictComplexType :: XName -> XName -> Comment -> Decl
ExtendComplexType :: XName -> XName -> [Element] -> [Attribute] -> [Element] -> [Attribute] -> (Maybe XName) -> Bool -> [XName] -> Comment -> Decl
ExtendComplexTypeAbstract :: XName -> XName -> [(XName, Maybe XName)] -> (Maybe XName) -> [XName] -> Comment -> Decl
XSDInclude :: XName -> Comment -> Decl
XSDImport :: XName -> (Maybe XName) -> Comment -> Decl
XSDComment :: Comment -> Decl
data Element
Element :: XName -> XName -> Modifier -> Bool -> [Decl] -> Maybe [XName] -> Comment -> Element
elem_name :: Element -> XName
elem_type :: Element -> XName
elem_modifier :: Element -> Modifier
elem_byRef :: Element -> Bool
elem_locals :: Element -> [Decl]
elem_substs :: Element -> Maybe [XName]
elem_comment :: Element -> Comment
OneOf :: [[Element]] -> Modifier -> Comment -> Element
elem_oneOf :: Element -> [[Element]]
elem_modifier :: Element -> Modifier
elem_comment :: Element -> Comment
AnyElem :: Modifier -> Comment -> Element
elem_modifier :: Element -> Modifier
elem_comment :: Element -> Comment
Text :: Element
data Attribute
Attribute :: XName -> XName -> Bool -> Comment -> Attribute
attr_name :: Attribute -> XName
attr_type :: Attribute -> XName
attr_required :: Attribute -> Bool
attr_comment :: Attribute -> Comment
data Modifier
Single :: Modifier
Optional :: Modifier
Range :: Occurs -> Modifier

-- | Restrictions on simpleType
data Restrict
RangeR :: Occurs -> Comment -> Restrict
Pattern :: String -> Comment -> Restrict
Enumeration :: [(String, Comment)] -> Restrict
StrLength :: Occurs -> Comment -> Restrict

-- | A helper for building the formal Module structure.
mkModule :: String -> Schema -> [Decl] -> Module
instance Eq Attribute
instance Show Attribute
instance Eq Modifier
instance Show Modifier
instance Eq Restrict
instance Show Restrict
instance Eq Decl
instance Show Decl
instance Eq Element
instance Show Element


-- | Pretty-print the internal Haskell model of XSD datatypes to a real
--   Haskell module containing type declarations, and instances for parsing
--   (and printing - though not yet implemented) values of those datatypes
--   from(/to) XML.
module Text.XML.HaXml.Schema.PrettyHaskell

-- | Generate aligned haddock-style documentation. (but without escapes in
--   comment text yet)
ppComment :: CommentPosition -> Comment -> Doc

-- | Convert a whole document from HaskellTypeModel to Haskell source text.
ppModule :: NameConverter -> Module -> Doc

-- | Convert a single Haskell Decl into Haskell source text.
ppHighLevelDecl :: NameConverter -> Decl -> Doc

-- | Convert multiple HaskellTypeModel Decls to Haskell source text.
ppHighLevelDecls :: NameConverter -> [Decl] -> Doc

-- | Vertically pretty-print a list of things, with open and close
--   brackets, and separators.
ppvList :: String -> String -> String -> (a -> Doc) -> [a] -> Doc


-- | Pretty-print the internal Haskell model of XSD datatypes to a Haskell
--   hs-boot module containing only stub type declarations. This approach
--   is intended to work around issues of mutually recursive datatype
--   definitions.
module Text.XML.HaXml.Schema.PrettyHsBoot

-- | Generate aligned haddock-style documentation. (but without escapes in
--   comment text yet)
ppComment :: CommentPosition -> Comment -> Doc

-- | Convert a whole document from HaskellTypeModel to Haskell source text.
ppModule :: NameConverter -> Module -> Doc

-- | Convert a single Haskell Decl into Haskell source text.
ppHighLevelDecl :: NameConverter -> Decl -> Doc

-- | Convert multiple HaskellTypeModel Decls to Haskell source text.
ppHighLevelDecls :: NameConverter -> [Decl] -> Doc

-- | Vertically pretty-print a list of things, with open and close
--   brackets, and separators.
ppvList :: String -> String -> String -> (a -> Doc) -> [a] -> Doc

module Text.XML.HaXml.Schema.Environment
data Environment
Environment :: Map QName (Either SimpleType ComplexType) -> Map QName (Either SimpleType ComplexType) -> Map QName ElementDecl -> Map QName AttributeDecl -> Map QName Group -> Map QName AttrGroup -> Map String String -> Map QName [(QName, FilePath)] -> Map QName [(QName, FilePath)] -> Map QName FilePath -> Environment

-- | type definitions in scope
env_type :: Environment -> Map QName (Either SimpleType ComplexType)

-- | all type definitions, regardless of scope
env_allTypes :: Environment -> Map QName (Either SimpleType ComplexType)
env_element :: Environment -> Map QName ElementDecl
env_attribute :: Environment -> Map QName AttributeDecl
env_group :: Environment -> Map QName Group
env_attrgroup :: Environment -> Map QName AttrGroup
env_namespace :: Environment -> Map String String

-- | supertype -&gt; subtypes
env_extendty :: Environment -> Map QName [(QName, FilePath)]

-- | substitution groups
env_substGrp :: Environment -> Map QName [(QName, FilePath)]

-- | where type is defined
env_typeloc :: Environment -> Map QName FilePath

-- | An empty environment of XSD type mappings.
emptyEnv :: Environment

-- | Combine two environments (e.g. read from different interface files)
combineEnv :: Environment -> Environment -> Environment

-- | Build an environment of XSD type mappings from a schema module.
mkEnvironment :: FilePath -> Schema -> Environment -> Environment

-- | Find all direct module dependencies.
gatherImports :: Schema -> [(FilePath, Maybe String)]

module Text.XML.HaXml.Schema.TypeConversion

-- | Transform a Schema by lifting all locally-defined anonymous types to
--   the top-level, naming them, and planting a referend at their original
--   location.
typeLift :: Schema -> Schema

-- | Given an environment of schema type mappings, and a schema module,
--   create a bunch of Decls that describe the types in a more
--   Haskell-friendly way.
convert :: Environment -> Schema -> [Decl]
comment :: Annotation -> Comment
xname :: String -> XName
checkXName :: Schema -> QName -> XName
nameOfSimple :: SimpleType -> XName
mkRestrict :: Restriction -> [Restrict]
singleton :: a -> [a]

-- | Consolidate a Facet occurrence into a single Occurs value.
consolidate :: Occurs -> (FacetType, Annotation, String) -> Occurs

-- | Find the supertype (if it exists) of a given type name.
supertypeOf :: Environment -> QName -> Maybe QName

-- | Keep applying the function to transform the value, until it yields
--   Nothing. Returns the sequence of transformed values.
repeatedly :: (a -> Maybe a) -> a -> [a]

module Text.XML.HaXml.ShowXmlLazy

-- | Convert a fully-typed XML document to a string (without DTD).
showXmlLazy :: XmlContent a => Bool -> a -> String


-- | <ul>
--   <li>Only a small module containing some helper functions to extract
--   xml content</li>
--   <li>I would have added this to Types but I've put it into an
--   additional module</li>
--   <li>to avoid circular references (Verbatim <a>-</a> Types)</li>
--   </ul>
module Text.XML.HaXml.Util

-- | Get the main element of the document so that you can apply CFilters
--   directly. <tt>i</tt> is typically (posInNewCxt "filename" Nothing)
docContent :: i -> Document i -> Content i

-- | If you know that your CFilter returns a tag, you can use this function
--   to get the tagged Element.
contentElem :: Content i -> Element i
attrs :: Element i -> [Attribute]
tagTextContent :: Content i -> [Char]


-- | The class <a>XmlContent</a> is a kind of replacement for Read and
--   Show: it provides conversions between a generic XML tree
--   representation and your own more specialised typeful Haskell data
--   trees.
--   
--   If you are starting with a set of Haskell datatypes, use DrIFT to
--   derive instances of this class for you:
--   http://repetae.net/john/computer/haskell/DrIFT and use the current
--   module for instances of the standard Haskell datatypes list, Maybe,
--   and so on.
--   
--   If you are starting with an XML DTD, use HaXml's tool DtdToHaskell to
--   generate both the Haskell types and the corresponding instances, but
--   _do_not_ use the current module for instances: use
--   Text.XML.HaXml.XmlContent instead.
module Text.XML.HaXml.XmlContent.Haskell

-- | Convert a fully-typed XML document to a string (with or without DTD).
toXml :: XmlContent a => Bool -> a -> Document ()

-- | Read a Haskell value from an XML document, ignoring the DTD and using
--   the Haskell result type to determine how to parse it.
fromXml :: XmlContent a => Document Posn -> Either String a

-- | Read a fully-typed XML document from a string.
readXml :: XmlContent a => String -> Either String a

-- | Convert a fully-typed XML document to a string (without DTD).
showXml :: XmlContent a => Bool -> a -> String

-- | Convert a fully-typed XML document to a ByteString (without DTD).
fpsShowXml :: XmlContent a => Bool -> a -> ByteString

-- | Read an XML document from a file and convert it to a fully-typed
--   Haskell value.
fReadXml :: XmlContent a => FilePath -> IO a

-- | Write a fully-typed Haskell value to the given file as an XML
--   document.
fWriteXml :: XmlContent a => FilePath -> a -> IO ()

-- | Write any Haskell value to the given file as an XML document, using
--   the FastPackedString interface (output will not be prettified).
fpsWriteXml :: XmlContent a => FilePath -> a -> IO ()

-- | Read a fully-typed XML document from a file handle.
hGetXml :: XmlContent a => Handle -> IO a

-- | Write a fully-typed XML document to a file handle.
hPutXml :: XmlContent a => Handle -> Bool -> a -> IO ()

-- | Write a fully-typed XML document to a file handle, using the
--   FastPackedString interface (output will not be prettified).
fpsHPutXml :: XmlContent a => Handle -> Bool -> a -> IO ()
instance (XmlContent a, XmlContent b) => XmlContent (Either a b)
instance XmlContent a => XmlContent (Maybe a)
instance XmlContent ()
instance XmlContent a => XmlContent [a]
instance XmlContent Char
instance XmlContent Double
instance XmlContent Float
instance XmlContent Integer
instance XmlContent Int
instance XmlContent Bool


-- | This is a new set of XML combinators for Xtract, not standard, but
--   based on the standard set in <a>Text.Xml.Haxml.Combinators</a>. The
--   main difference is that the Content Filter type becomes a Double
--   Filter. A Double Filter always takes the whole document as an extra
--   argument, so you can start to traverse it again from the root, when at
--   any inner location within the document tree.
--   
--   The new combinator definitions are derived from the old ones. The same
--   names have the equivalent meaning - use module qualification on
--   imports to distinguish between CFilter and DFilter variations.
module Text.XML.HaXml.Xtract.Combinators

-- | double content filter - takes document root + local subtree.
type DFilter i = Content i -> Content i -> [Content i]

-- | lift an ordinary content filter to a double filter.
local :: CFilter i -> DFilter i

-- | lift an ordinary content filter to a double filter.
global :: CFilter i -> DFilter i

-- | drop a double filter to an ordinary content filter. (permitting
--   interior access to document root)
dfilter :: DFilter i -> CFilter i

-- | drop a double filter to an ordinary content filter. (Where interior
--   access to the document root is not needed, the retaining pointer to
--   the outer element can be pruned away. <a>cfilter</a> is more
--   space-efficient than <a>dfilter</a> in this situation.)
cfilter :: DFilter i -> CFilter i

-- | lift a CFilter combinator to a DFilter combinator
liftLocal :: (CFilter i -> CFilter i) -> (DFilter i -> DFilter i)

-- | lift a CFilter combinator to a DFilter combinator
liftGlobal :: (CFilter i -> CFilter i) -> (DFilter i -> DFilter i)

-- | lifted composition over double filters.
o :: DFilter i -> DFilter i -> DFilter i

-- | lifted choice.
(|>|) :: (a -> b -> [c]) -> (a -> b -> [c]) -> (a -> b -> [c])

-- | lifted union.
union :: (a -> b -> [c]) -> (a -> b -> [c]) -> (a -> b -> [c])

-- | lifted predicates.
with :: DFilter i -> DFilter i -> DFilter i

-- | lifted predicates.
without :: DFilter i -> DFilter i -> DFilter i

-- | lifted unit and zero.
keep :: DFilter i

-- | lifted unit and zero.
none :: DFilter i
children :: DFilter i
txt :: DFilter i
elm :: DFilter i
applypred :: CFilter i -> DFilter i -> CFilter i
iffind :: String -> (String -> DFilter i) -> DFilter i -> DFilter i
ifTxt :: (String -> DFilter i) -> DFilter i -> DFilter i
cat :: [a -> b -> [c]] -> (a -> b -> [c])
(/>) :: DFilter i -> DFilter i -> DFilter i
(</) :: DFilter i -> DFilter i -> DFilter i
deep :: DFilter i -> DFilter i
multi :: DFilter i -> DFilter i
deepest :: DFilter i -> DFilter i


-- | A parser for the Xtract command-language. (The string input is
--   tokenised internally by the lexer <a>lexXtract</a>.) See
--   <a>http://www.haskell.org/HaXml/Xtract.html</a> for the grammar that
--   is accepted.
module Text.XML.HaXml.Xtract.Parse

-- | The cool thing is that the Xtract command parser directly builds a
--   higher-order <a>DFilter</a> (see
--   <a>Text.XML.HaXml.Xtract.Combinators</a>) which can be applied to an
--   XML document without further ado. (<tt>parseXtract</tt> halts the
--   program if a parse error is found.)
parseXtract :: [Token] -> DFilter i

-- | To convert an Xtract query into an ordinary HaXml combinator
--   expression. First arg is a tag-transformation function (e.g. map
--   toLower) applied
xtract :: (String -> String) -> String -> CFilter i

module Text.XML.HaXml.Schema.Schema

-- | A SchemaType promises to interconvert between a generic XML content
--   tree and a Haskell value, according to the rules of XSD.
class SchemaType a
parseSchemaType :: SchemaType a => String -> XMLParser a
schemaTypeToXML :: SchemaType a => String -> a -> [Content ()]

-- | Ultimately, an XML parser will find some plain text as the content of
--   a simpleType, which will need to be parsed. We use a TextParser,
--   because values of simpleTypes can also be given elsewhere, e.g. as
--   attribute values in an XSD definition, e.g. to restrict the
--   permissible values of the simpleType. Such restrictions are therefore
--   implemented as layered parsers.
class SimpleType a
acceptingParser :: SimpleType a => TextParser a
simpleTypeText :: SimpleType a => a -> String

-- | A type t can extend another type s by the addition of extra elements
--   and/or attributes. s is therefore the supertype of t.
class Extension t s
supertype :: Extension t s => t -> s

-- | A type t can restrict another type s, that is, t admits fewer values
--   than s, but all the values t does admit also belong to the type s.
class Restricts t s | t -> s
restricts :: Restricts t s => t -> s

-- | A trick to enable forward-declaration of a type that will be defined
--   properly in another module, higher in the dependency graph.
--   <tt>fd</tt> is a dummy type e.g. the empty <tt>data FwdA</tt>, where
--   <tt>a</tt> is the proper <tt>data A</tt>, not yet available.
class FwdDecl fd a | fd -> a

-- | Generated parsers will use <a>getAttribute</a> as a convenient wrapper
--   to lift a SchemaAttribute parser into an XMLParser.
getAttribute :: (SimpleType a, Show a) => String -> Element Posn -> Posn -> XMLParser a

-- | Between is a list parser that tries to ensure that any range
--   specification (min and max elements) is obeyed when parsing.
between :: PolyParse p => Occurs -> p a -> p [a]
data Occurs
Occurs :: (Maybe Int) -> (Maybe Int) -> Occurs

-- | Given a TextParser for a SimpleType, make it into an XMLParser, i.e.
--   consuming textual XML content as input rather than a String.
parseSimpleType :: SimpleType t => XMLParser t

-- | Parse the textual part of mixed content
parseText :: XMLParser String

-- | The <a>xsd:any</a> type. Parsing will always produce an
--   <a>UnconvertedANY</a>.
data AnyElement
ANYSchemaType :: a -> AnyElement
UnconvertedANY :: (Content Posn) -> AnyElement
parseAnyElement :: XMLParser AnyElement
data Content i
CElem :: (Element i) -> i -> Content i

-- | bool is whether whitespace is significant
CString :: Bool -> CharData -> i -> Content i
CRef :: Reference -> i -> Content i
CMisc :: Misc -> i -> Content i

-- | We need a parsing monad for reading generic XML Content into specific
--   datatypes. This is a specialisation of the Text.ParserCombinators.Poly
--   ones, where the input token type is fixed as XML Content.
type XMLParser a = Parser (Content Posn) a

-- | A specialisation of <tt>posnElementWith (==)</tt>.
posnElement :: [String] -> XMLParser (Posn, Element Posn)

-- | Get the next content element, checking that it has one of the required
--   tags, using the given matching function. (Skips over comments and
--   whitespace, rejects text and refs. Also returns position of element.)
posnElementWith :: (String -> String -> Bool) -> [String] -> XMLParser (Posn, Element Posn)

-- | Get the next content element, checking that it has one of the required
--   tags. (Skips over comments and whitespace, rejects text and refs.)
element :: [String] -> XMLParser (Element Posn)

-- | Run an XMLParser on the contents of the given element (i.e. not on the
--   current monadic content sequence), checking that the contents are
--   exhausted, before returning the calculated value within the current
--   parser context.
interior :: Element Posn -> XMLParser a -> XMLParser a

-- | <a>text</a> is a counterpart to <a>element</a>, parsing text content
--   if it exists. Adjacent text and references are coalesced.
text :: XMLParser String
toXMLElement :: String -> [[Attribute]] -> [[Content ()]] -> [Content ()]
toXMLText :: String -> [Content ()]
toXMLAnyElement :: AnyElement -> [Content ()]
toXMLAttribute :: SimpleType a => String -> a -> [Attribute]

-- | For a ComplexType that is an extension of a SimpleType, it is
--   necessary to convert the value to XML first, then add in the extra
--   attributes that constitute the extension.
addXMLAttributes :: [[Attribute]] -> [Content ()] -> [Content ()]
instance SchemaType PositiveInteger
instance SchemaType UnsignedByte
instance SchemaType UnsignedShort
instance SchemaType UnsignedInt
instance SchemaType UnsignedLong
instance SchemaType NonNegativeInteger
instance SchemaType Byte
instance SchemaType Short
instance SchemaType Int
instance SchemaType Long
instance SchemaType NegativeInteger
instance SchemaType NonPositiveInteger
instance SchemaType Integer
instance SchemaType NMTOKENS
instance SchemaType NMTOKEN
instance SchemaType ENTITIES
instance SchemaType ENTITY
instance SchemaType IDREFS
instance SchemaType IDREF
instance SchemaType ID
instance SchemaType NCName
instance SchemaType Name
instance SchemaType Language
instance SchemaType Token
instance SchemaType NormalizedString
instance SchemaType GMonth
instance SchemaType GDay
instance SchemaType GMonthDay
instance SchemaType GYear
instance SchemaType GYearMonth
instance SchemaType Date
instance SchemaType Time
instance SchemaType DateTime
instance SchemaType Duration
instance SchemaType NOTATION
instance SchemaType AnyURI
instance SchemaType Double
instance SchemaType Decimal
instance SchemaType Float
instance SchemaType HexBinary
instance SchemaType Base64Binary
instance SchemaType Boolean
instance SchemaType XsdString
instance SchemaType AnyElement
instance Eq AnyElement
instance Show AnyElement


-- | This is just a convenient way of bunching the XML combinators together
--   with some other things you are likely to want at the same time.
module Text.XML.HaXml

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | The version of the library.
version :: String
