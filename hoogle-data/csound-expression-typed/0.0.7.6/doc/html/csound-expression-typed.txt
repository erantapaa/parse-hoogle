-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | typed core for the library csound-expression
--   
@package csound-expression-typed
@version 0.0.7.6

module Csound.Typed.Types.Prim

-- | Signals
data Sig
Sig :: (GE E) -> Sig
PrimSig :: Double -> Sig
unSig :: Sig -> GE E

-- | Constant numbers
data D
D :: (GE E) -> D
PrimD :: Double -> D
unD :: D -> GE E

-- | Tables (or arrays)
data Tab
Tab :: (GE E) -> Tab
TabPre :: PreTab -> Tab
unTab :: Tab -> GE E

-- | Strings
newtype Str
Str :: GE E -> Str
unStr :: Str -> GE E

-- | Spectrum. It's <tt>fsig</tt> in the Csound.
newtype Spec
Spec :: GE E -> Spec
unSpec :: Spec -> GE E

-- | Another type for spectrum. It's <tt>wsig</tt> in the Csound.
newtype Wspec
Wspec :: GE E -> Wspec
unWspec :: Wspec -> GE E

-- | A signal of booleans.
data BoolSig
BoolSig :: (GE E) -> BoolSig
PrimBoolSig :: Bool -> BoolSig
unBoolSig :: BoolSig -> GE E

-- | A constant boolean value.
data BoolD
BoolD :: (GE E) -> BoolD
PrimBoolD :: Bool -> BoolD
unBoolD :: BoolD -> GE E

-- | Csound's empty tuple.
newtype Unit
Unit :: GE () -> Unit
unUnit :: Unit -> GE ()

-- | Constructs Csound's empty tuple.
unit :: Unit

-- | Contains all Csound values.
class Val a where fromE = fromGE . return
fromGE :: Val a => GE E -> a
toGE :: Val a => a -> GE E
fromE :: Val a => E -> a
hideGE :: Val a => GE a -> a
class (IsPrim a, RealFrac (PrimOf a), Val a) => SigOrD a
preTab :: TabSize -> Int -> TabArgs -> Tab
data TabSize
SizePlain :: Int -> TabSize
SizeDegree :: Bool -> Int -> TabSize
hasGuardPoint :: TabSize -> Bool
sizeDegree :: TabSize -> Int
data TabArgs
ArgsPlain :: [Double] -> TabArgs
ArgsRelative :: [Double] -> TabArgs
ArgsGen16 :: [Double] -> TabArgs
FileAccess :: String -> [Double] -> TabArgs
updateTabSize :: (TabSize -> TabSize) -> Tab -> Tab
fromPreTab :: PreTab -> GE Gen
getPreTabUnsafe :: String -> Tab -> PreTab

-- | Skips normalization (sets table size to negative value)
skipNorm :: Tab -> Tab

-- | Force normalization (sets table size to positive value). Might be
--   useful to restore normalization for table <a>doubles</a>.
forceNorm :: Tab -> Tab

-- | nsamp â€” Returns the number of samples loaded into a stored function
--   table number.
--   
--   <pre>
--   nsamp(x) (init-rate args only)
--   </pre>
--   
--   csound doc: <a>http://www.csounds.com/manual/html/nsamp.html</a>
nsamp :: Tab -> D

-- | Returns a length of the table.
ftlen :: Tab -> D

-- | Returns the number of channels for a table that stores wav files
ftchnls :: Tab -> D

-- | Returns the sample rate for a table that stores wav files
ftsr :: Tab -> D

-- | Returns the base frequency for a table that stores wav files
ftcps :: Tab -> D

-- | Constructs a number.
double :: Double -> D

-- | Constructs an integer.
int :: Int -> D

-- | Constructs a string.
text :: String -> Str

-- | Querries a total duration of the note. It's equivallent to Csound's
--   <tt>p3</tt> field.
idur :: D
getSampleRate :: D
getControlRate :: D
getBlockSize :: D
getZeroDbfs :: D

-- | Sets a rate of the signal to audio rate.
ar :: Sig -> Sig

-- | Sets a rate of the signal to control rate.
kr :: Sig -> Sig

-- | Converts a signal to the number (initial value of the signal).
ir :: Sig -> D

-- | Makes a constant signal from the number.
sig :: D -> Sig
on0 :: Val a => E -> a
on1 :: (Val a, Val b) => (E -> E) -> (a -> b)
on2 :: (Val a, Val b, Val c) => (E -> E -> E) -> (a -> b -> c)
on3 :: (Val a, Val b, Val c, Val d) => (E -> E -> E -> E) -> (a -> b -> c -> d)
quot' :: SigOrD a => a -> a -> a
rem' :: SigOrD a => a -> a -> a
div' :: SigOrD a => a -> a -> a
mod' :: SigOrD a => a -> a -> a
ceil' :: SigOrD a => a -> a
floor' :: SigOrD a => a -> a
round' :: SigOrD a => a -> a
int' :: SigOrD a => a -> a
frac' :: SigOrD a => a -> a

-- | Invokes the given procedure if the boolean signal is true.
when1 :: BoolSig -> SE () -> SE ()

-- | The chain of <tt>when1</tt>s. Tests all the conditions in sequence if
--   everything is false it invokes the procedure given in the second
--   argument.
whens :: [(BoolSig, SE ())] -> SE () -> SE ()
untilDo :: BoolSig -> SE () -> SE ()
whileDo :: BoolSig -> SE () -> SE ()

-- | Creates a constant boolean signal.
boolSig :: BoolD -> BoolSig
instance OrdB D
instance OrdB Sig
instance EqB D
instance EqB Sig
instance IfB Spec
instance IfB Str
instance IfB Tab
instance IfB D
instance IfB Sig
instance Boolean BoolD
instance Boolean BoolSig
instance IsPrim BoolD
instance IsPrim BoolSig
instance IsPrim D
instance IsPrim Sig
instance Floating D
instance Floating Sig
instance Fractional D
instance Fractional Sig
instance Num D
instance Num Sig
instance Monoid D
instance Monoid Sig
instance Default Spec
instance Default Str
instance Default Tab
instance Default D
instance Default Sig
instance SigOrD D
instance SigOrD Sig
instance Val BoolD
instance Val BoolSig
instance Val Tab
instance Val Wspec
instance Val Spec
instance Val Str
instance Val D
instance Val Sig
instance Default TabSize
instance Default Unit
instance Monoid Unit

module Csound.Typed.Types.Tuple

-- | A tuple of Csound values.
class Tuple a
tupleMethods :: Tuple a => TupleMethods a
data TupleMethods a

-- | Defines instance of type class <a>Tuple</a> for a new type in terms of
--   an already defined one.
makeTupleMethods :: Tuple a => (a -> b) -> (b -> a) -> TupleMethods b
fromTuple :: Tuple a => a -> GE [E]
toTuple :: Tuple a => GE [E] -> a
tupleArity :: Tuple a => a -> Int
tupleRates :: Tuple a => a -> [Rate]
defTuple :: Tuple a => a
type Sig2 = (Sig, Sig)
type Sig3 = (Sig, Sig, Sig)
type Sig4 = (Sig, Sig, Sig, Sig)
type Sig5 = (Sig, Sig, Sig, Sig, Sig)
type Sig6 = (Sig, Sig, Sig, Sig, Sig, Sig)
type Sig8 = (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig)

-- | The tuples of signals.
class (Tuple a, Num a) => Sigs a
outArity :: Tuple a => SE a -> Int
multiOuts :: Tuple a => E -> a
ar1 :: Sig -> Sig
ar2 :: (Sig, Sig) -> (Sig, Sig)
ar4 :: (Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig)
ar6 :: (Sig, Sig, Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig, Sig, Sig)
ar8 :: (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig) -> (Sig, Sig, Sig, Sig, Sig, Sig, Sig, Sig)
class Tuple a => Arg a
arg :: Arg a => Int -> a
toNote :: Arg a => a -> GE [E]
argArity :: Arg a => a -> Int
toArg :: Arg a => a

-- | <tt>ifB</tt> for tuples of csound values.
ifTuple :: Tuple a => BoolSig -> a -> a -> a

-- | <tt>guardedB</tt> for tuples of csound values.
guardedTuple :: Tuple b => [(BoolSig, b)] -> b -> b

-- | <tt>caseB</tt> for tuples of csound values.
caseTuple :: Tuple b => a -> [(a -> BoolSig, b)] -> b -> b

-- | <tt>ifB</tt> for constants.
ifArg :: (Arg a, Tuple a) => BoolD -> a -> a -> a

-- | <tt>guardedB</tt> for constants.
guardedArg :: (Tuple b, Arg b) => [(BoolD, b)] -> b -> b

-- | <tt>caseB</tt> for constants.
caseArg :: (Tuple b, Arg b) => a -> [(a -> BoolD, b)] -> b -> b
pureTuple :: Tuple a => GE (MultiOut [E]) -> a
dirtyTuple :: Tuple a => GE (MultiOut [E]) -> SE a
instance Num (Sig8, Sig8, Sig8, Sig8)
instance Num (Sig8, Sig8)
instance Num Sig8
instance Num Sig6
instance Num Sig4
instance Num Sig3
instance Num Sig2
instance IfB BoolArg
instance IfB BoolTuple
instance (Arg a, Arg b, Arg c, Arg d, Arg e, Arg f, Arg h, Arg g) => Arg (a, b, c, d, e, f, h, g)
instance (Arg a, Arg b, Arg c, Arg d, Arg e, Arg f, Arg h) => Arg (a, b, c, d, e, f, h)
instance (Arg a, Arg b, Arg c, Arg d, Arg e, Arg f) => Arg (a, b, c, d, e, f)
instance (Arg a, Arg b, Arg c, Arg d, Arg e) => Arg (a, b, c, d, e)
instance (Arg a, Arg b, Arg c, Arg d) => Arg (a, b, c, d)
instance (Arg a, Arg b, Arg c) => Arg (a, b, c)
instance (Arg a, Arg b) => Arg (a, b)
instance Arg Tab
instance Arg Str
instance Arg D
instance Arg Unit
instance Sigs (Sig8, Sig8, Sig8, Sig8)
instance Sigs (Sig8, Sig8)
instance Sigs Sig8
instance Sigs Sig6
instance Sigs Sig4
instance Sigs Sig2
instance Sigs Sig
instance (Tuple a, Tuple b, Tuple c, Tuple d, Tuple e, Tuple f, Tuple g, Tuple h) => Tuple (a, b, c, d, e, f, g, h)
instance (Tuple a, Tuple b, Tuple c, Tuple d, Tuple e, Tuple f, Tuple g) => Tuple (a, b, c, d, e, f, g)
instance (Tuple a, Tuple b, Tuple c, Tuple d, Tuple e, Tuple f) => Tuple (a, b, c, d, e, f)
instance (Tuple a, Tuple b, Tuple c, Tuple d, Tuple e) => Tuple (a, b, c, d, e)
instance (Tuple a, Tuple b, Tuple c, Tuple d) => Tuple (a, b, c, d)
instance (Tuple a, Tuple b, Tuple c) => Tuple (a, b, c)
instance (Tuple a, Tuple b) => Tuple (a, b)
instance Tuple Spec
instance Tuple Str
instance Tuple Tab
instance Tuple D
instance Tuple Sig
instance Tuple Unit

module Csound.Typed.Types.Lift
data GE a

-- | The inner representation of csound expressions.
type E = Fix RatedExp
class PureSingle a
pureSingle :: PureSingle a => ([E] -> E) -> a
class DirtySingle a
dirtySingle :: DirtySingle a => ([E] -> Dep E) -> a
class Procedure a
procedure :: Procedure a => ([E] -> Dep ()) -> a
class PureMulti a
data Pm
fromPm :: Tuple a => Pm -> a
pureMulti :: PureMulti a => ([E] -> MultiOut [E]) -> a
class DirtyMulti a
data Dm
fromDm :: Tuple a => Dm -> SE a
dirtyMulti :: DirtyMulti a => ([E] -> MultiOut (Dep [E])) -> a
instance DirtyMulti b => DirtyMulti (Msg -> b)
instance DirtyMulti b => DirtyMulti ([D] -> b)
instance DirtyMulti b => DirtyMulti ([Sig] -> b)
instance DirtyMulti b => DirtyMulti (Wspec -> b)
instance DirtyMulti b => DirtyMulti (Spec -> b)
instance DirtyMulti b => DirtyMulti (Tab -> b)
instance DirtyMulti b => DirtyMulti (Str -> b)
instance DirtyMulti b => DirtyMulti (D -> b)
instance DirtyMulti b => DirtyMulti (Sig -> b)
instance DirtyMulti b => DirtyMulti (GE [E] -> b)
instance DirtyMulti b => DirtyMulti (GE E -> b)
instance DirtyMulti Dm
instance PureMulti b => PureMulti (Msg -> b)
instance PureMulti b => PureMulti ([D] -> b)
instance PureMulti b => PureMulti ([Sig] -> b)
instance PureMulti b => PureMulti (Wspec -> b)
instance PureMulti b => PureMulti (Spec -> b)
instance PureMulti b => PureMulti (Tab -> b)
instance PureMulti b => PureMulti (Str -> b)
instance PureMulti b => PureMulti (D -> b)
instance PureMulti b => PureMulti (Sig -> b)
instance PureMulti b => PureMulti (GE [E] -> b)
instance PureMulti b => PureMulti (GE E -> b)
instance PureMulti Pm
instance Procedure b => Procedure (Msg -> b)
instance Procedure b => Procedure ([D] -> b)
instance Procedure b => Procedure ([Sig] -> b)
instance Procedure b => Procedure (Wspec -> b)
instance Procedure b => Procedure (Spec -> b)
instance Procedure b => Procedure (Tab -> b)
instance Procedure b => Procedure (Str -> b)
instance Procedure b => Procedure (D -> b)
instance Procedure b => Procedure (Sig -> b)
instance Procedure b => Procedure (GE [E] -> b)
instance Procedure b => Procedure (GE E -> b)
instance Procedure (SE ())
instance DirtySingle b => DirtySingle (Msg -> b)
instance DirtySingle b => DirtySingle ([D] -> b)
instance DirtySingle b => DirtySingle ([Sig] -> b)
instance DirtySingle b => DirtySingle (Wspec -> b)
instance DirtySingle b => DirtySingle (Spec -> b)
instance DirtySingle b => DirtySingle (Tab -> b)
instance DirtySingle b => DirtySingle (Str -> b)
instance DirtySingle b => DirtySingle (D -> b)
instance DirtySingle b => DirtySingle (Sig -> b)
instance DirtySingle (SE Wspec)
instance DirtySingle (SE Spec)
instance DirtySingle (SE Tab)
instance DirtySingle (SE Str)
instance DirtySingle (SE D)
instance DirtySingle (SE Sig)
instance DirtySingle b => DirtySingle (GE [E] -> b)
instance DirtySingle b => DirtySingle (GE E -> b)
instance DirtySingle (SE (GE E))
instance PureSingle b => PureSingle (Msg -> b)
instance PureSingle b => PureSingle ([D] -> b)
instance PureSingle b => PureSingle ([Sig] -> b)
instance PureSingle b => PureSingle (Wspec -> b)
instance PureSingle b => PureSingle (Spec -> b)
instance PureSingle b => PureSingle (Tab -> b)
instance PureSingle b => PureSingle (Str -> b)
instance PureSingle b => PureSingle (D -> b)
instance PureSingle b => PureSingle (Sig -> b)
instance PureSingle Wspec
instance PureSingle Spec
instance PureSingle Tab
instance PureSingle Str
instance PureSingle D
instance PureSingle Sig
instance PureSingle b => PureSingle (GE [E] -> b)
instance PureSingle b => PureSingle (GE E -> b)
instance PureSingle (GE E)

module Csound.Typed.Types.Evt

-- | A stream of events. We can convert a stream of events to the procedure
--   with the function <tt>runEvt</tt>. It waits for events and invokes the
--   given procedure when the event happens.
data Evt a
Evt :: (Bam a -> SE ()) -> Evt a
runEvt :: Evt a -> Bam a -> SE ()

-- | A procedure. Something that takes a value and suddenly bams with it.
type Bam a = a -> SE ()

-- | Executes actions synchronized with global tempo (in Hz).
--   
--   <pre>
--   runEvtSync tempoCps evt proc
--   </pre>
sync :: (Default a, Tuple a) => D -> Evt a -> Evt a

-- | Converts booleans to events.
boolToEvt :: BoolSig -> Evt Unit

-- | Converts an event to boolean signal. It forgets everything about the
--   event values. Signal equals to one when an event happens and zero
--   otherwise.
evtToBool :: Evt a -> SE BoolSig

-- | Triggers an event when signal equals to 1.
sigToEvt :: Sig -> Evt Unit

-- | Converts events to signals.
stepper :: Tuple a => a -> Evt a -> SE a

-- | Filters events with predicate.
filterE :: (a -> BoolD) -> Evt a -> Evt a

-- | Filters events with effectful predicate.
filterSE :: (a -> SE BoolD) -> Evt a -> Evt a

-- | Accumulator for events with side effects.
accumSE :: Tuple s => s -> (a -> s -> SE (b, s)) -> Evt a -> Evt b

-- | Accumulator for events.
accumE :: Tuple s => s -> (a -> s -> (b, s)) -> Evt a -> Evt b

-- | Accumulator with filtering. It can skip the events from the event
--   stream. If the third element of the triple equals to 1 then we should
--   include the event in the resulting stream. If the element equals to 0
--   we skip the event.
filterAccumE :: Tuple s => s -> (a -> s -> (BoolD, b, s)) -> Evt a -> Evt b

-- | Accumulator for events with side effects and filtering. Event triggers
--   only if the first element in the tripplet is true.
filterAccumSE :: Tuple s => s -> (a -> s -> SE (BoolD, b, s)) -> Evt a -> Evt b

-- | A snapshot of the signal. It converts a type of the signal to the type
--   of the value in the given moment. Instances:
--   
--   <pre>
--   type instance Snap D   = D
--   type instance Snap Str = Str
--   type instance Snap Tab = Tab
--   
--   type instance Snap Sig = D
--   
--   type instance Snap (a, b) = (Snap a, Snap b)
--   type instance Snap (a, b, c) = (Snap a, Snap b, Snap c)
--   type instance Snap (a, b, c, d) = (Snap a, Snap b, Snap c, Snap d)
--   type instance Snap (a, b, c, d, e) = (Snap a, Snap b, Snap c, Snap d, Snap e)
--   type instance Snap (a, b, c, d, e, f) = (Snap a, Snap b, Snap c, Snap d, Snap e, Snap f)
--   </pre>

-- | Get values of some signal at the given events.
snapshot :: (Tuple a, Tuple (Snap a)) => (Snap a -> b -> c) -> a -> Evt b -> Evt c

-- | Constructs an event stream that contains values from the given signal.
--   Events happens only when the signal changes.
snaps :: Sig -> Evt D
readSnap :: (Tuple (Snap a), Tuple a) => a -> Snap a
instance Monoid (Evt a)
instance Functor Evt

module Csound.Typed.Types

-- | Appends initialisation arguments. It's up to user to supply arguments
--   with the right types. For example:
--   
--   <pre>
--   oscil 0.5 440 sinWave `withInits` (0.5 :: D)
--   </pre>
withInits :: (Tuple a, Tuple b) => a -> b -> a

-- | A special case of <tt>withInits</tt>. Here all inits are numbers.
withDs :: Tuple a => a -> [D] -> a

-- | A special case of <tt>withInits</tt>. Here all inits are signals.
withSigs :: Tuple a => a -> [Sig] -> a

-- | A special case of <tt>withInits</tt>. Here all inits are arrays.
withTabs :: Tuple a => a -> [Tab] -> a

-- | Appends an init value which is a number.
withD :: Tuple a => a -> D -> a

-- | Appends an init value which is a signal.
withSig :: Tuple a => a -> Sig -> a

-- | Appends an init value which is a table.
withTab :: Tuple a => a -> Tab -> a

-- | Applies a seed to the random value. It's equivalent to the
--   <tt>withD</tt> but it has a special meaning of canceling the side
--   effect. When random opcode is provided with seed value it's no longer
--   contains a side effect so we don't need to restrict it.
withSeed :: SE Sig -> D -> Sig
getNextGlobalGenId :: SE Int

module Csound.Typed.Control

-- | The Csound's <tt>IO</tt>-monad. All values that produce side effects
--   are wrapped in the <tt>SE</tt>-monad.
newtype SE a
SE :: Dep a -> SE a
unSE :: SE a -> Dep a
data LocalHistory :: *
LocalHistory :: E -> Int -> Int -> LocalHistory
expDependency :: LocalHistory -> E
newLineNum :: LocalHistory -> Int
newLocalVarId :: LocalHistory -> Int
runSE :: SE a -> GE a
execSE :: SE () -> GE InstrBody
evalSE :: SE a -> GE a
execGEinSE :: SE (GE a) -> SE a
hideGEinDep :: GE (Dep a) -> Dep a
fromDep :: Dep a -> SE (GE a)
fromDep_ :: Dep () -> SE ()
geToSe :: GE a -> SE a
newLocalVar :: Rate -> GE E -> SE Var
newLocalVars :: [Rate] -> GE [E] -> SE [Var]
newGlobalVars :: [Rate] -> GE [E] -> SE [Var]

-- | It describes a reference to mutable values.
newtype SERef a
SERef :: [Var] -> SERef a
writeSERef :: Tuple a => SERef a -> a -> SE ()
readSERef :: Tuple a => SERef a -> SE a

-- | Allocates a new local (it is visible within the instrument) mutable
--   value and initializes it with value. A reference can contain a tuple
--   of variables.
newSERef :: Tuple a => a -> SE (SERef a)

-- | Adds the given signal to the value that is contained in the reference.
mixSERef :: (Num a, Tuple a) => SERef a -> a -> SE ()

-- | Modifies the SERef value with given function.
modifySERef :: Tuple a => SERef a -> (a -> a) -> SE ()

-- | An alias for the function <tt>newSERef</tt>. It returns not the
--   reference to mutable value but a pair of reader and writer functions.
sensorsSE :: Tuple a => a -> SE (SE a, a -> SE ())

-- | Allocates a new global mutable value and initializes it with value. A
--   reference can contain a tuple of variables.
newGlobalSERef :: Tuple a => a -> SE (SERef a)

-- | An alias for the function <tt>newSERef</tt>. It returns not the
--   reference to mutable value but a pair of reader and writer functions.
globalSensorsSE :: Tuple a => a -> SE (SE a, a -> SE ())
instr0 :: Tuple a => SE a -> SE a
getIns :: Sigs a => SE a

-- | Sets the global duration of the file or output signal to the given
--   value. It should be used only once! The proper place is in the
--   top-most expression before sending to <tt>dac</tt> or
--   <tt>writeWav</tt>.
setDur :: Sigs a => D -> a -> a

-- | Gets new id.
freshId :: SE D

-- | Special type that represents a scores of sound signals. If an
--   instrument is triggered with the scores the result is wrapped in the
--   value of this type.
data Mix a

-- | Plays a bunch of notes with the given instrument.
--   
--   <pre>
--   res = sco instrument scores 
--   </pre>
sco :: (Arg a, Sigs b) => (a -> SE b) -> Sco a -> Sco (Mix b)

-- | Applies an effect to the sound. Effect is applied to the sound on the
--   give track.
--   
--   <pre>
--   res = eff effect sco 
--   </pre>
--   
--   <ul>
--   <li><tt>effect</tt> - a function that takes a tuple of signals and
--   produces a tuple of signals.</li>
--   <li><tt>sco</tt> - something that is constructed with <a>sco</a> or
--   <a>eff</a>.</li>
--   </ul>
--   
--   With the function <a>eff</a> you can apply a reverb or adjust the
--   level of the signal. It functions like a mixing board but unlike
--   mixing board it produces the value that you can arrange with functions
--   from your favorite Score-generation library. You can delay it or mix
--   with some other track and apply some another effect on top of it!
eff :: (Sigs a, Sigs b) => (a -> SE b) -> Sco (Mix a) -> Sco (Mix b)

-- | Renders a scores to the sound signals. we can use it inside the other
--   instruments.
mix :: Sigs a => Sco (Mix a) -> a

-- | Imitates a closure for a bunch of notes to be played within another
--   instrument.
mixBy :: (Arg a, Sigs b) => (a -> Sco (Mix b)) -> (a -> b)

-- | Invokes a procedure for the given bunch of events.
sco_ :: Arg a => (a -> SE ()) -> Sco a -> Sco (Mix Unit)

-- | Converts a bunch of procedures scheduled with scores to a single
--   procedure.
mix_ :: Sco (Mix Unit) -> SE ()

-- | Imitates a closure for a bunch of procedures to be played within
--   another instrument.
mixBy_ :: Arg a => (a -> Sco (Mix Unit)) -> (a -> SE ())
type Sco a = Track D a
type CsdEventList a = Track D a

-- | The Csound note. It's a triple of
--   
--   <pre>
--   (startTime, duration, parameters)
--   </pre>
type CsdEvent = (Double, Double, Note)
data Msg
type Channel = Int

-- | Triggers a midi-instrument (aka Csound's massign) for all channels.
--   It's useful to test a single instrument.
midi :: (Num a, Sigs a) => (Msg -> SE a) -> SE a

-- | Triggers a midi-instrument (aka Csound's massign) on the specified
--   channel.
midin :: (Num a, Sigs a) => Channel -> (Msg -> SE a) -> SE a

-- | Triggers a midi-instrument (aka Csound's pgmassign) on the specified
--   programm bank.
pgmidi :: (Num a, Sigs a) => Maybe Int -> Channel -> (Msg -> SE a) -> SE a

-- | Triggers a midi-procedure (aka Csound's massign) for all channels.
midi_ :: (Msg -> SE ()) -> SE ()

-- | Triggers a midi-procedure (aka Csound's pgmassign) on the given
--   channel.
midin_ :: Channel -> (Msg -> SE ()) -> SE ()

-- | Triggers a midi-procedure (aka Csound's pgmassign) on the given
--   programm bank.
pgmidi_ :: Maybe Int -> Channel -> (Msg -> SE ()) -> SE ()
initMidiCtrl :: D -> D -> D -> SE ()
data OscRef

-- | The hostname of the computer. An empty string is for local machine.
type OscHost = String

-- | Port to listen OSC-messages.
type OscPort = Int

-- | Path-like string ("<i>foo</i>bar/baz")
type OscAddress = String

-- | The string specifies the type of expected arguments. The string can
--   contain the characters "bcdfilmst" which stand for Boolean, character,
--   double, float, 32-bit integer, 64-bit integer, MIDI, string and
--   timestamp.
type OscType = String

-- | Initializes host client. The process starts to run in the background.
initOsc :: OscPort -> SE OscRef

-- | Listens for the OSC-messages. The first argument is OSC-reference. We
--   can create it with the function <tt>oscInit</tt>. The next two
--   arguments are strings. The former specifies the path-like address to
--   listen the messages. It can be:
--   
--   <pre>
--   /foo/bar/baz
--   </pre>
--   
--   The latter specifies the type of expected arguments. The string can
--   contain the characters "bcdfilmst" which stand for Boolean, character,
--   double, float, 32-bit integer, 64-bit integer, MIDI, string and
--   timestamp.
--   
--   The result is an event of messages. We can run a callback on it with
--   standard function <tt>runEvt</tt>:
--   
--   <pre>
--   runEvt :: Evt a -&gt; (a -&gt; SE ()) -&gt; SE ()
--   </pre>
listenOsc :: Tuple a => OscRef -> OscAddress -> OscType -> Evt a

-- | Sends OSC-messages. It takes in a name of the host computer (empty
--   string is alocal machine), port on which the target machine is
--   listening, OSC-addres and type. The last argument produces the values
--   for OSC-messages.
sendOsc :: Tuple a => OscHost -> OscPort -> OscAddress -> OscType -> Evt a -> SE ()

-- | Reads a value of type double.
chnGetD :: Str -> SE D

-- | Reads an audio signal.
chnGetSig :: Str -> SE Sig

-- | Reads a control signal. The control signals are updated at the lower
--   rate.
chnGetCtrl :: Str -> SE Sig

-- | Reads a string.
chnGetStr :: Str -> SE Str

-- | Writes a value of type double.
chnSetD :: D -> Str -> SE ()

-- | Writes an audio signal.
chnSetSig :: Sig -> Str -> SE ()

-- | Writes a control signal. The control signals are updated at the lower
--   rate.
chnSetCtrl :: Sig -> Str -> SE ()

-- | Writes a string.
chnSetStr :: Str -> Str -> SE ()

-- | The sf2 sound font preset. It is defined with file name, bank and
--   program integers.
data Sf
Sf :: String -> Int -> Int -> Sf
sfName :: Sf -> String
sfBank :: Sf -> Int
sfProg :: Sf -> Int
SfId :: (GE E) -> Sf
unSf :: Sf -> GE E
sched :: (Arg a, Sigs b) => (a -> SE b) -> Evt (Sco a) -> b

-- | Triggers a procedure on the event stream.
sched_ :: Arg a => (a -> SE ()) -> Evt (Sco a) -> SE ()

-- | A closure to trigger an instrument inside the body of another
--   instrument.
schedBy :: (Arg a, Sigs b, Arg c) => (a -> SE b) -> (c -> Evt (Sco a)) -> (c -> b)

-- | An instrument is triggered with event stream and delay time is set to
--   zero (event fires immediately) and duration is set to inifinite time.
--   The note is held while the instrument is producing something. If the
--   instrument is silent for some seconds (specified in the first
--   argument) then it's turned off.
schedHarp :: (Arg a, Sigs b) => D -> (a -> SE b) -> Evt [a] -> b

-- | A closure to trigger an instrument inside the body of another
--   instrument.
schedHarpBy :: (Arg a, Sigs b, Arg c) => D -> (a -> SE b) -> (c -> Evt [a]) -> (c -> b)

-- | Retriggers an instrument every time an event happens. The note is held
--   until the next event happens.
retrigs :: (Arg a, Sigs b) => (a -> SE b) -> Evt [a] -> b
evtLoop :: (Num a, Tuple a, Sigs a) => Maybe (Evt Unit) -> [SE a] -> [Evt Unit] -> a
evtLoopOnce :: (Num a, Tuple a, Sigs a) => Maybe (Evt Unit) -> [SE a] -> [Evt Unit] -> a

-- | A sawtooth.
saw :: Sig -> Sig

-- | Integrated sawtooth: 4 * x * (1 - x).
isaw :: Sig -> Sig

-- | Pulse (not normalized).
pulse :: Sig -> Sig

-- | A triangle wave.
tri :: Sig -> Sig

-- | A square wave.
sqr :: Sig -> Sig

-- | A band-limited oscillator with user defined waveform (it's stored in
--   the table).
blosc :: Tab -> Sig -> Sig

module Csound.Typed.Render
renderOut :: Sigs a => SE a -> IO String
renderOutBy :: Sigs a => Options -> SE a -> IO String
renderEff :: (Sigs a, Sigs b) => (a -> SE b) -> IO String
renderEffBy :: (Sigs a, Sigs b) => Options -> (a -> SE b) -> IO String
renderOut_ :: SE () -> IO String
renderOutBy_ :: Options -> SE () -> IO String

-- | Csound options. The default values are
--   
--   <pre>
--   flags      = def     -- the only flag set by default is "no-displays" 
--                        -- to supress the display of the tables
--   sampleRate = 44100
--   blockSize  = 64
--   gain       = 0.5
--   tabFi      = fineFi 13 [(idLins, 11), (idExps, 11), (idConsts, 9), (idSplines, 11), (idStartEnds, 12)] }
--   </pre>
data Options
Options :: Flags -> Maybe Int -> Maybe Int -> Maybe Double -> Maybe TabFi -> Options

-- | Csound command line flags
csdFlags :: Options -> Flags

-- | The sample rate
csdSampleRate :: Options -> Maybe Int

-- | The number of audio samples in one control step
csdBlockSize :: Options -> Maybe Int

-- | A gain of the final output
csdGain :: Options -> Maybe Double

-- | Default fidelity of the arrays
csdTabFi :: Options -> Maybe TabFi
defGain :: Options -> Double
defSampleRate :: Options -> Int
defBlockSize :: Options -> Int
defTabFi :: Options -> TabFi

-- | Table size fidelity (how many points in the table by default).
data TabFi
TabFi :: Int -> IntMap Int -> TabFi
tabFiBase :: TabFi -> Int
tabFiGens :: TabFi -> IntMap Int

-- | Sets different table size for different GEN-routines.
--   
--   <pre>
--   fineFi n ps 
--   </pre>
--   
--   where
--   
--   <ul>
--   <li><tt>n</tt> is the default value for table size (size is a
--   <tt>n</tt> power of 2) for all gen routines that are not listed in the
--   next argument <tt>ps</tt>.</li>
--   <li><tt>ps</tt> is a list of pairs <tt>(genRoutineId,
--   tableSizeDegreeOf2)</tt> that sets the given table size for a given
--   GEN-routine.</li>
--   </ul>
--   
--   with this function we can set lower table sizes for tables that are
--   usually used in the envelopes.
fineFi :: Int -> [(Int, Int)] -> TabFi

-- | Sets the same table size for all tables.
--   
--   <pre>
--   coarseFi n
--   </pre>
--   
--   where <tt>n</tt> is a degree of 2. For example, <tt>n = 10</tt> sets
--   size to 1024 points for all tables by default.
coarseFi :: Int -> TabFi
idWavs :: Int
idMp3s :: Int
idDoubles :: Int
idSines :: Int
idSines3 :: Int
idSines2 :: Int
idPartials :: Int
idSines4 :: Int
idBuzzes :: Int
idConsts :: Int
idLins :: Int
idCubes :: Int
idExps :: Int
idSplines :: Int
idStartEnds :: Int
idPolys :: Int
idChebs1 :: Int
idChebs2 :: Int
idBessels :: Int
idWins :: Int

module Csound.Typed.Gui
data Panel
Single :: Win -> Bool -> Panel
singleContent :: Panel -> Win
singleIsKeybdSensitive :: Panel -> Bool
Tabs :: String -> Maybe Rect -> [Win] -> Bool -> Panel
tabsTitle :: Panel -> String
tabsRect :: Panel -> Maybe Rect
tabsContent :: Panel -> [Win]
tabsIsKeybdSensitive :: Panel -> Bool
data Win
Win :: String -> Maybe Rect -> Gui -> Win
winTitle :: Win -> String
winRect :: Win -> Maybe Rect
winGui :: Win -> Gui
data GuiNode
GuiNode :: Gui -> GuiHandle -> GuiNode
guiNodeElem :: GuiNode -> Gui
guiNodeHandle :: GuiNode -> GuiHandle
newtype GuiHandle
GuiHandle :: Int -> GuiHandle
unGuiHandle :: GuiHandle -> Int

-- | A visual representation of the GUI-element.
newtype Gui
Gui :: LowGui -> Gui
unGui :: Gui -> LowGui
data Elem
GuiVar :: GuiHandle -> Elem
Count :: ValDiap -> ValStep -> (Maybe ValStep) -> Elem
Joy :: ValSpan -> ValSpan -> Elem
Knob :: ValSpan -> Elem
Roller :: ValSpan -> ValStep -> Elem
Slider :: ValSpan -> Elem
Text :: ValDiap -> ValStep -> Elem
Box :: String -> Elem
ButBank :: Int -> Int -> Elem
Button :: InstrId -> Elem
Toggle :: Elem
Value :: Elem
Vkeybd :: Elem
data InitMe
InitMe :: Var -> Double -> InitMe
initHandle :: InitMe -> Var
initValue :: InitMe -> Double
restoreTree :: GuiMap -> Gui -> Gui
guiMap :: [GuiNode] -> GuiMap
mapGuiOnPanel :: (Gui -> Gui) -> Panel -> Panel
fromElem :: ElemOuts -> [InitMe] -> Elem -> Gui
fromGuiHandle :: GuiHandle -> Gui
panelIsKeybdSensitive :: Panel -> Bool
defText :: String -> Gui
guiStmt :: Monad m => [Panel] -> DepT m ()

-- | Horizontal groupping of the elements. All elements are placed in the
--   stright horizontal line and aligned by Y-coordinate and height.
hor :: [Gui] -> Gui

-- | Vertical groupping of the elements. All elements are placed in the
--   stright vertical line and aligned by X-coordinate and width.
ver :: [Gui] -> Gui

-- | An empty space.
space :: Gui

-- | Scales an element within the group. It depends on the type of the
--   alignment (horizontal or vertical) which side of the bounding box is
--   scaled. If it's a horizontal group then the width is scaled and height
--   is scaled otherwise.
--   
--   Every element in the group has a scaling factor. By default it equals
--   to one. During rendering all scaling factors are summed and divided on
--   the sum of all factors. So that factors become weights or proportions.
--   This process is called normalization. Scaling one element affects not
--   only this element but all other elements in the group!
--   
--   An example:
--   
--   One element is twice as large as the other two:
--   
--   <pre>
--   hor [a, b, sca 2 c]
--   </pre>
--   
--   Why is it so? Let's look at the hidden scaling factors:
--   
--   <pre>
--   hor [sca 1 a, sca 1 b, sca 2 c]
--   </pre>
--   
--   During rendering we scale all the scaling fators so that total sum
--   equals to one:
--   
--   <pre>
--   hor [sca 0.25 a, sca 0.25 b, sca 0.5 c]
--   </pre>
sca :: Double -> Gui -> Gui

-- | Weighted horizontal grouping. It takes a list of scaling factors and
--   elements.
horSca :: [(Double, Gui)] -> Gui

-- | Weighted vertical grouping. It takes a list of scaling factors and
--   elements.
verSca :: [(Double, Gui)] -> Gui

-- | Sets the padding of the element. How much empty space to reserve
--   outside the element.
padding :: Int -> Gui -> Gui

-- | Sets the margin of the element. How much empty space to reserve
--   between the elements within the group. It affects only compound
--   elements.
margin :: Int -> Gui -> Gui

-- | Sets the properties for a GUI element.
props :: [Prop] -> Gui -> Gui

-- | Sets the properties for a GUI element on all levels.
forceProps :: [Prop] -> Gui -> Gui

-- | Properties of the widgets.
data Prop
SetLabel :: String -> Prop
SetMaterial :: Material -> Prop
SetBoxType :: BoxType -> Prop
SetColor1 :: Color -> Prop
SetColor2 :: Color -> Prop
SetTextColor :: Color -> Prop
SetFontSize :: Int -> Prop
SetFontType :: FontType -> Prop
SetEmphasis :: Emphasis -> Prop
SetSliderType :: SliderType -> Prop
SetTextType :: TextType -> Prop
SetButtonType :: ButtonType -> Prop
SetOrient :: Orient -> Prop
SetKnobType :: KnobType -> Prop
SetLabelType :: LabelType -> Prop
data BorderType
NoBorder :: BorderType
DownBoxBorder :: BorderType
UpBoxBorder :: BorderType
EngravedBorder :: BorderType
EmbossedBorder :: BorderType
BlackLine :: BorderType
ThinDown :: BorderType
ThinUp :: BorderType

-- | The Csound colours.
type Color = Colour Double

-- | A rectangle.
data Rect
Rect :: Int -> Int -> Int -> Int -> Rect
px :: Rect -> Int
py :: Rect -> Int
width :: Rect -> Int
height :: Rect -> Int
data FontType
Helvetica :: FontType
Courier :: FontType
Times :: FontType
Symbol :: FontType
Screen :: FontType
Dingbats :: FontType
data Emphasis
NoEmphasis :: Emphasis
Italic :: Emphasis
Bold :: Emphasis
BoldItalic :: Emphasis

-- | The type of the material of the element. It affects sliders and
--   buttons.
data Material
NoPlastic :: Material
Plastic :: Material

-- | The orientation of the widget (slider, roller). This property is never
--   needs to be set in practice. If this property is not set then default
--   orientation is calculated from the bounding box of the widget. If the
--   width is greater than the height then we need to use a horizontal
--   widget otherwise it should be a vertical one.
data Orient
Hor :: Orient
Ver :: Orient

-- | Some values are not implemented on the Csound level.
data LabelType
NormalLabel :: LabelType
NoLabel :: LabelType
SymbolLabel :: LabelType
ShadowLabel :: LabelType
EngravedLabel :: LabelType
EmbossedLabel :: LabelType
setBorder :: BorderType -> Gui -> Gui
setLabel :: String -> Gui -> Gui
setMaterial :: Material -> Gui -> Gui
setLabelType :: LabelType -> Gui -> Gui
setColor1 :: Color -> Gui -> Gui
setColor2 :: Color -> Gui -> Gui
setColors :: Color -> Color -> Gui -> Gui
setTextColor :: Color -> Gui -> Gui
setFontSize :: Int -> Gui -> Gui
setFontType :: FontType -> Gui -> Gui
setEmphasis :: Emphasis -> Gui -> Gui
setOrient :: Orient -> Gui -> Gui

-- | The diapason of the continuous value.
data ValDiap
ValDiap :: Double -> Double -> ValDiap
valDiapMin :: ValDiap -> Double
valDiapMax :: ValDiap -> Double
type ValStep = Double
data ValScaleType
Linear :: ValScaleType
Exponential :: ValScaleType

-- | A value span is a diapason of the value and a type of the scale (can
--   be linear or exponential).
data ValSpan
ValSpan :: ValDiap -> ValScaleType -> ValSpan
valSpanDiap :: ValSpan -> ValDiap
valSpanScale :: ValSpan -> ValScaleType

-- | Makes a linear <tt>ValSpan</tt> with specified boundaries.
--   
--   <pre>
--   linSpan minVal maxVal
--   </pre>
linSpan :: Double -> Double -> ValSpan

-- | Makes an exponential <tt>ValSpan</tt> with specified boundaries.
--   
--   <pre>
--   expSpan minVal maxVal
--   </pre>
expSpan :: Double -> Double -> ValSpan

-- | Unit span. A special case:
--   
--   <pre>
--   uspan = linSpan 0 1
--   </pre>
uspan :: ValSpan

-- | Bipolar unit span. A special case:
--   
--   <pre>
--   uspan = linSpan (-1) 1
--   </pre>
bspan :: ValSpan

-- | An exponential unit span. A special case:
--   
--   <pre>
--   uspan = expSpan 0 1
--   </pre>
uspanExp :: ValSpan
data KnobType
ThreeD :: (Maybe Int) -> KnobType
Pie :: KnobType
Clock :: KnobType
Flat :: KnobType
setKnobType :: KnobType -> Gui -> Gui
data SliderType
Fill :: SliderType
Engraved :: SliderType
Nice :: SliderType
setSliderType :: SliderType -> Gui -> Gui
data TextType
NormalText :: TextType
NoDrag :: TextType
NoEdit :: TextType
setTextType :: TextType -> Gui -> Gui

-- | The type of the box. Some values are not implemented on the Csound
--   level.
data BoxType
FlatBox :: BoxType
UpBox :: BoxType
DownBox :: BoxType
ThinUpBox :: BoxType
ThinDownBox :: BoxType
EngravedBox :: BoxType
EmbossedBox :: BoxType
BorderBox :: BoxType
ShadowBox :: BoxType
Roundedbox :: BoxType
RoundedShadowBox :: BoxType
RoundedFlatBox :: BoxType
RoundedUpBox :: BoxType
RoundedDownBox :: BoxType
DiamondUpBox :: BoxType
DiamondDownBox :: BoxType
OvalBox :: BoxType
OvalShadowBox :: BoxType
OvalFlatBox :: BoxType
setBoxType :: BoxType -> Gui -> Gui

-- | The type of the button. It affects toggle buttons and button banks.
--   
--   In Csound buttons and toggle buttons are constructed with the same
--   function (but with different button types). But in this library they
--   are contructed by different functions (<tt>button</tt> and
--   <tt>toggle</tt>). Normal button is a plain old button, but other
--   values specify toggle buttons. So this property doesn't affect the
--   buttons (since they could be only normal buttons).
data ButtonType
NormalButton :: ButtonType
LightButton :: ButtonType
CheckButton :: ButtonType
RoundButton :: ButtonType
setButtonType :: ButtonType -> Gui -> Gui

-- | Renders the GUI elements on the window. Rectangle is calculated
--   automatically (window doesn't listens for keyboard events).
panel :: Gui -> SE ()

-- | Renders the GUI elements on the window. Rectangle is calculated
--   automatically (window listens for keyboard events).
keyPanel :: Gui -> SE ()

-- | Renders the GUI elements with tabs. Rectangles are calculated
--   automatically.
tabs :: [(String, Gui)] -> SE ()

-- | Renders the GUI elements with tabs. Rectangles are calculated
--   automatically.
keyTabs :: [(String, Gui)] -> SE ()

-- | Renders a list of panels.
panels :: [Gui] -> SE ()

-- | Renders a list of panels. Panels are sensitive to keyboard events.
keyPanels :: [Gui] -> SE ()

-- | Renders the GUI elements on the window. We can specify the window
--   title and rectangle of the window.
panelBy :: String -> Maybe Rect -> Gui -> SE ()

-- | Renders the GUI elements on the window. We can specify the window
--   title and rectangle of the window. Panesls are sensitive to keyboard
--   events.
keyPanelBy :: String -> Maybe Rect -> Gui -> SE ()

-- | Renders the GUI elements with tabs. We can specify the window title
--   and rectangles for all tabs and for the main window.
tabsBy :: String -> Maybe Rect -> [(String, Maybe Rect, Gui)] -> SE ()

-- | Renders the GUI elements with tabs. We can specify the window title
--   and rectangles for all tabs and for the main window. Tabs are
--   sensitive to keyboard events.
keyTabsBy :: String -> Maybe Rect -> [(String, Maybe Rect, Gui)] -> SE ()

-- | Widgets that produce something has inputs.
type Input a = a

-- | Widgets that consume something has outputs.
type Output a = a -> SE ()

-- | Widgets that just do something inside them or have an inner state.
type Inner = SE ()

-- | A value for widgets that produce nothing.
noInput :: Input ()

-- | A value for widgets that consume nothing.
noOutput :: Output ()

-- | A value for stateless widgets.
noInner :: Inner

-- | A widget consists of visible element (Gui), value consumer (Output)
--   and producer (Input) and an inner state (Inner).
type Widget a b = SE (Gui, Output a, Input b, Inner)

-- | A widget constructor.
widget :: SE (Gui, Output a, Input b, Inner) -> Widget a b

-- | A producer of the values.
type Source a = SE (Gui, Input a)

-- | A producer constructor.
source :: SE (Gui, Input a) -> Source a

-- | A consumer of the values.
type Sink a = SE (Gui, Output a)

-- | A consumer constructor.
sink :: SE (Gui, Output a) -> Sink a

-- | A static element. We can only look at it.
type Display = SE Gui

-- | A display constructor.
display :: SE Gui -> Display
type SinkSource a = SE (Gui, Output a, Input a)
sinkSource :: SE (Gui, Output a, Input a) -> SinkSource a
sourceSlice :: SinkSource a -> Source a
sinkSlice :: SinkSource a -> Sink a

-- | A handy function for transforming the value of producers.
mapSource :: (a -> b) -> Source a -> Source b

-- | A handy function for transforming the GUIs of producers.
mapGuiSource :: (Gui -> Gui) -> Source a -> Source a

-- | Horizontal grouping of widgets that can produce monoidal values.
mhor :: Monoid a => [Source a] -> Source a

-- | Vertical grouping of widgets that can produce monoidal values.
mver :: Monoid a => [Source a] -> Source a

-- | Scaling of widgets that can produce values.
msca :: Double -> Source a -> Source a

-- | Allows the user to increase/decrease a value with mouse clicks on a
--   corresponding arrow button. Output is an event stream that contains
--   values when counter changes.
--   
--   <pre>
--   count diapason fineValStep maybeCoarseValStep initValue 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLcount.html</a>
count :: ValDiap -> ValStep -> Maybe ValStep -> Double -> Source (Evt D)

-- | A variance on the function <a>count</a>, but it produces a signal of
--   piecewise constant function.
countSig :: ValDiap -> ValStep -> Maybe ValStep -> Double -> Source Sig

-- | It is a squared area that allows the user to modify two output values
--   at the same time. It acts like a joystick.
--   
--   <pre>
--   joy valueSpanX valueSpanY (initX, initY) 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLjoy.html</a>
joy :: ValSpan -> ValSpan -> (Double, Double) -> Source (Sig, Sig)

-- | A FLTK widget opcode that creates a knob.
--   
--   <pre>
--   knob valueSpan initValue
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLknob.html</a>
knob :: String -> ValSpan -> Double -> Source Sig

-- | FLroller is a sort of knob, but put transversally.
--   
--   <pre>
--   roller valueSpan step initVal
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLroller.html</a>
roller :: String -> ValSpan -> ValStep -> Double -> Source Sig

-- | FLslider puts a slider into the corresponding container.
--   
--   <pre>
--   slider valueSpan initVal 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLslider.html</a>
slider :: String -> ValSpan -> Double -> Source Sig

-- | Constructs a list of linear unit sliders (ranges in [0, 1]). It takes
--   a list of init values.
sliderBank :: String -> [Double] -> Source [Sig]

-- | numeric (originally FLtext in the Csound) allows the user to modify a
--   parameter value by directly typing it into a text field.
--   
--   <pre>
--   numeric diapason step initValue 
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLtext.html</a>
numeric :: String -> ValDiap -> ValStep -> Double -> Source Sig

-- | A slider that serves as indicator. It consumes values instead of
--   producing.
--   
--   <pre>
--   meter valueSpan initValue
--   </pre>
meter :: String -> ValSpan -> Double -> Sink Sig

-- | A FLTK widget that displays text inside of a box. If the text is
--   longer than 255 characters the text is split on several parts (Csound
--   limitations).
--   
--   <pre>
--   box text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbox.html</a>
box :: String -> Display

-- | A FLTK widget opcode that creates a button.
--   
--   <pre>
--   button text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutton.html</a>
button :: String -> Source (Evt Unit)

-- | A FLTK widget opcode that creates a bank of buttons. Result is (x, y)
--   coordinate of the triggered button.
--   
--   <pre>
--   butBank xNumOfButtons yNumOfButtons
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutBank.html</a>
butBank :: String -> Int -> Int -> (Int, Int) -> Source (Evt (D, D))

-- | A variance on the function <a>butBank</a>, but it produces a signal of
--   piecewise constant function. Result is (x, y) coordinate of the
--   triggered button.
butBankSig :: String -> Int -> Int -> (Int, Int) -> Source (Sig, Sig)

-- | A FLTK widget opcode that creates a bank of buttons.
--   
--   <pre>
--   butBank xNumOfButtons yNumOfButtons
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutBank.html</a>
butBank1 :: String -> Int -> Int -> (Int, Int) -> Source (Evt D)
butBankSig1 :: String -> Int -> Int -> (Int, Int) -> Source Sig

-- | A FLTK widget opcode that creates a toggle button.
--   
--   <pre>
--   button text
--   </pre>
--   
--   doc: <a>http://www.csounds.com/manual/html/FLbutton.html</a>
toggle :: String -> Bool -> Source (Evt D)

-- | A variance on the function <a>toggle</a>, but it produces a signal of
--   piecewise constant function.
toggleSig :: String -> Bool -> Source Sig

-- | FLtext that is sink shows current the value of a valuator in a text
--   field.
setNumeric :: String -> ValDiap -> ValStep -> Double -> Sink Sig
setToggle :: String -> Bool -> SinkSource (Evt D)
setToggleSig :: String -> Bool -> SinkSource Sig
setKnob :: String -> ValSpan -> Double -> SinkSource Sig
setSlider :: String -> ValSpan -> Double -> SinkSource Sig

-- | Appends a title to a group of widgets.
setTitle :: String -> Gui -> SE Gui

-- | Keyboard events.
data KeyEvt
Press :: Key -> KeyEvt
Release :: Key -> KeyEvt

-- | Keys.
data Key
CharKey :: Char -> Key
F1 :: Key
F2 :: Key
F3 :: Key
F4 :: Key
F5 :: Key
F6 :: Key
F7 :: Key
F8 :: Key
F9 :: Key
F10 :: Key
F11 :: Key
F12 :: Key
Scroll :: Key
CapsLook :: Key
LeftShift :: Key
RightShift :: Key
LeftCtrl :: Key
RightCtrl :: Key
Enter :: Key
LeftAlt :: Key
RightAlt :: Key
LeftWinKey :: Key
RightWinKey :: Key
Backspace :: Key
ArrowUp :: Key
ArrowLeft :: Key
ArrowRight :: Key
ArrowDown :: Key
Insert :: Key
Home :: Key
PgUp :: Key
Delete :: Key
End :: Key
PgDown :: Key
NumLock :: Key
NumDiv :: Key
NumMul :: Key
NumSub :: Key
NumHome :: Key
NumArrowUp :: Key
NumPgUp :: Key
NumArrowLeft :: Key
NumSpace :: Key
NumArrowRight :: Key
NumEnd :: Key
NumArrowDown :: Key
NumPgDown :: Key
NumIns :: Key
NumDel :: Key
NumEnter :: Key
NumPlus :: Key
Num7 :: Key
Num8 :: Key
Num9 :: Key
Num4 :: Key
Num5 :: Key
Num6 :: Key
Num1 :: Key
Num2 :: Key
Num3 :: Key
Num0 :: Key
NumDot :: Key

-- | The stream of keyboard press/release events.
keyIn :: KeyEvt -> Evt Unit

module Csound.Typed
infiniteDur :: Num a => a
