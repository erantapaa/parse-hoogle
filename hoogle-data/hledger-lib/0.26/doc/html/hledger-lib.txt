-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core data types, parsers and utilities for the hledger accounting tool.
--   
@package hledger-lib
@version 0.26


-- | Debugging helpers
module Hledger.Utils.Debug

-- | Trace (print on stdout at runtime) a showable value. (for easily
--   tracing in the middle of a complex expression)
strace :: Show a => a -> a

-- | Labelled trace - like strace, with a label prepended.
ltrace :: Show a => String -> a -> a

-- | Monadic trace - like strace, but works as a standalone line in a
--   monad.
mtrace :: (Monad m, Show a) => a -> m a

-- | Custom trace - like strace, with a custom show function.
traceWith :: (a -> String) -> a -> a

-- | Parsec trace - show the current parsec position and next input, and
--   the provided label if it's non-null.
ptrace :: Stream [Char] m t => String -> ParsecT [Char] st m ()

-- | Global debug level, which controls the verbosity of debug output on
--   the console. The default is 0 meaning no debug output. The
--   <tt>--debug</tt> command line flag sets it to 1, or <tt>--debug=N</tt>
--   sets it to a higher value (note: not <tt>--debug N</tt> for some
--   reason). This uses unsafePerformIO and can be accessed from anywhere
--   and before normal command-line processing. After command-line
--   processing, it is also available as the <tt>debug_</tt> field of
--   <a>CliOpts</a>. {--} {--}
debugLevel :: Int

-- | Convenience aliases for tracePrettyAt. Pretty-print a message and the
--   showable value to the console, then return it.
dbg :: Show a => String -> a -> a

-- | Pretty-print a message and the showable value to the console when the
--   debug level is &gt;= 1, then return it. Uses unsafePerformIO.
dbg1 :: Show a => String -> a -> a
dbg2 :: Show a => String -> a -> a
dbg3 :: Show a => String -> a -> a
dbg4 :: Show a => String -> a -> a
dbg5 :: Show a => String -> a -> a
dbg6 :: Show a => String -> a -> a
dbg7 :: Show a => String -> a -> a
dbg8 :: Show a => String -> a -> a
dbg9 :: Show a => String -> a -> a

-- | Convenience aliases for tracePrettyAtIO. Like dbg, but convenient to
--   insert in an IO monad.
dbgIO :: Show a => String -> a -> IO ()
dbg1IO :: Show a => String -> a -> IO ()
dbg2IO :: Show a => String -> a -> IO ()
dbg3IO :: Show a => String -> a -> IO ()
dbg4IO :: Show a => String -> a -> IO ()
dbg5IO :: Show a => String -> a -> IO ()
dbg6IO :: Show a => String -> a -> IO ()
dbg7IO :: Show a => String -> a -> IO ()
dbg8IO :: Show a => String -> a -> IO ()
dbg9IO :: Show a => String -> a -> IO ()

-- | Pretty-print a message and a showable value to the console if the
--   debug level is at or above the specified level. dbtAt 0 always prints.
--   Otherwise, uses unsafePerformIO.
tracePrettyAt :: Show a => Int -> String -> a -> a
tracePrettyAtIO :: Show a => Int -> String -> a -> IO ()

-- | print this string to the console before evaluating the expression, if
--   the global debug level is non-zero. Uses unsafePerformIO.
dbgtrace :: String -> a -> a

-- | Print a showable value to the console, with a message, if the debug
--   level is at or above the specified level (uses unsafePerformIO).
--   Values are displayed with show, all on one line, which is hard to
--   read.
dbgshow :: Show a => Int -> String -> a -> a

-- | Print a showable value to the console, with a message, if the debug
--   level is at or above the specified level (uses unsafePerformIO).
--   Values are displayed with ppShow, each field/constructor on its own
--   line.
dbgppshow :: Show a => Int -> String -> a -> a

-- | Like dbg, then exit the program. Uses unsafePerformIO.
dbgExit :: Show a => String -> a -> a

-- | Print a message and parsec debug info (parse position and next input)
--   to the console when the debug level is at or above this level. Uses
--   unsafePerformIO. pdbgAt :: GenParser m =&gt; Float -&gt; String -&gt;
--   m ()
pdbg :: Stream [Char] m t => Int -> String -> ParsecT [Char] st m ()

-- | Convert a generic value into a pretty <a>String</a>, if possible.
ppShow :: Show a => a -> String


-- | UTF-8 aware string IO functions that will work across multiple
--   platforms and GHC versions. Includes code from Text.Pandoc.UTF8 ((C)
--   2010 John MacFarlane).
--   
--   Example usage:
--   
--   import Prelude hiding
--   (readFile,writeFile,appendFile,getContents,putStr,putStrLn) import
--   UTF8IOCompat
--   (readFile,writeFile,appendFile,getContents,putStr,putStrLn) import
--   UTF8IOCompat
--   (SystemString,fromSystemString,toSystemString,error',userError')
--   
--   2013<i>4</i>10 update: we now trust that current GHC versions &amp;
--   platforms do the right thing, so this file is a no-op and on its way
--   to being removed. Not carefully tested.
module Hledger.Utils.UTF8IOCompat

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | A string received from or being passed to the operating system, such
--   as a file path, command-line argument, or environment variable name or
--   value. With GHC versions before 7.2 on some platforms (posix) these
--   are typically encoded. When converting, we assume the encoding is
--   UTF-8 (cf
--   <a>http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html#UTF8</a>).
type SystemString = String

-- | Convert a system string to an ordinary string, decoding from UTF-8 if
--   it appears to be UTF8-encoded and GHC version is less than 7.2.
fromSystemString :: SystemString -> String

-- | Convert a unicode string to a system string, encoding with UTF-8 if we
--   are on a posix platform with GHC &lt; 7.2.
toSystemString :: String -> SystemString

-- | A SystemString-aware version of error.
error' :: String -> a

-- | A SystemString-aware version of userError.
userError' :: String -> IOError


-- | Easy regular expression helpers, currently based on regex-tdfa. These
--   should:
--   
--   <ul>
--   <li>be cross-platform, not requiring C libraries</li>
--   <li>support unicode</li>
--   <li>support extended regular expressions</li>
--   <li>support replacement, with backreferences etc.</li>
--   <li>support splitting</li>
--   <li>have mnemonic names</li>
--   <li>have simple monomorphic types</li>
--   <li>work with strings</li>
--   </ul>
--   
--   Current limitations:
--   
--   <ul>
--   <li>(?i) and similar are not supported</li>
--   </ul>
module Hledger.Utils.Regex

-- | Regular expression. Extended regular expression-ish syntax ? But does
--   not support eg (?i) syntax.
type Regexp = String

-- | A replacement pattern. May include numeric backreferences (N).
type Replacement = String
regexMatches :: Regexp -> String -> Bool
regexMatchesCI :: Regexp -> String -> Bool

-- | Replace all occurrences of the regexp with the replacement pattern.
--   The replacement pattern supports numeric backreferences (N) but no
--   other RE syntax.
regexReplace :: Regexp -> Replacement -> String -> String
regexReplaceCI :: Regexp -> Replacement -> String -> String

-- | Replace all occurrences of the regexp, transforming each match with
--   the given function.
regexReplaceBy :: Regexp -> (String -> String) -> String -> String
regexReplaceByCI :: Regexp -> (String -> String) -> String -> String


-- | Most data types are defined here to avoid import cycles. Here is an
--   overview of the hledger data model:
--   
--   <pre>
--   Journal                  -- a journal is read from one or more data files. It contains..
--    [Transaction]           -- journal transactions (aka entries), which have date, cleared status, code, description and..
--     [Posting]              -- multiple account postings, which have account name and amount
--    [HistoricalPrice]       -- historical commodity prices
--   
--   Ledger                   -- a ledger is derived from a journal, by applying a filter specification and doing some further processing. It contains..
--    Journal                 -- a filtered copy of the original journal, containing only the transactions and postings we are interested in
--    [Account]               -- all accounts, in tree order beginning with a "root" account", with their balances and sub/parent accounts
--   </pre>
--   
--   For more detailed documentation on each type, see the corresponding
--   modules.
module Hledger.Data.Types
type SmartDate = (String, String, String)
data WhichDate
PrimaryDate :: WhichDate
SecondaryDate :: WhichDate
data DateSpan
DateSpan :: (Maybe Day) -> (Maybe Day) -> DateSpan
data Interval
NoInterval :: Interval
Days :: Int -> Interval
Weeks :: Int -> Interval
Months :: Int -> Interval
Quarters :: Int -> Interval
Years :: Int -> Interval
DayOfMonth :: Int -> Interval
DayOfWeek :: Int -> Interval
type AccountName = String
data AccountAlias
BasicAlias :: AccountName -> AccountName -> AccountAlias
RegexAlias :: Regexp -> Replacement -> AccountAlias
data Side
L :: Side
R :: Side
type Commodity = String

-- | The basic numeric type used in amounts. Different implementations can
--   be selected via cabal flag for testing and benchmarking purposes.
numberRepresentation :: String
type Quantity = Decimal

-- | An amount's price (none, per unit, or total) in another commodity.
--   Note the price should be a positive number, although this is not
--   enforced.
data Price
NoPrice :: Price
UnitPrice :: Amount -> Price
TotalPrice :: Amount -> Price

-- | Display style for an amount.
data AmountStyle
AmountStyle :: Side -> Bool -> Int -> Maybe Char -> Maybe DigitGroupStyle -> AmountStyle

-- | does the symbol appear on the left or the right ?
ascommodityside :: AmountStyle -> Side

-- | space between symbol and quantity ?
ascommodityspaced :: AmountStyle -> Bool

-- | number of digits displayed after the decimal point
asprecision :: AmountStyle -> Int

-- | character used as decimal point: period or comma. Nothing means
--   "unspecified, use default"
asdecimalpoint :: AmountStyle -> Maybe Char

-- | style for displaying digit groups, if any
asdigitgroups :: AmountStyle -> Maybe DigitGroupStyle

-- | A style for displaying digit groups in the integer part of a floating
--   point number. It consists of the character used to separate groups
--   (comma or period, whichever is not used as decimal point), and the
--   size of each group, starting with the one nearest the decimal point.
--   The last group size is assumed to repeat. Eg, comma between thousands
--   is DigitGroups ',' [3].
data DigitGroupStyle
DigitGroups :: Char -> [Int] -> DigitGroupStyle
data Amount
Amount :: Commodity -> Quantity -> Price -> AmountStyle -> Amount
acommodity :: Amount -> Commodity
aquantity :: Amount -> Quantity

-- | the (fixed) price for this amount, if any
aprice :: Amount -> Price
astyle :: Amount -> AmountStyle
newtype MixedAmount
Mixed :: [Amount] -> MixedAmount
data PostingType
RegularPosting :: PostingType
VirtualPosting :: PostingType
BalancedVirtualPosting :: PostingType
type Tag = (String, String)
data ClearedStatus
Uncleared :: ClearedStatus
Pending :: ClearedStatus
Cleared :: ClearedStatus
data Posting
Posting :: Maybe Day -> Maybe Day -> ClearedStatus -> AccountName -> MixedAmount -> String -> PostingType -> [Tag] -> Maybe MixedAmount -> Maybe Transaction -> Posting

-- | this posting's date, if different from the transaction's
pdate :: Posting -> Maybe Day

-- | this posting's secondary date, if different from the transaction's
pdate2 :: Posting -> Maybe Day
pstatus :: Posting -> ClearedStatus
paccount :: Posting -> AccountName
pamount :: Posting -> MixedAmount

-- | this posting's comment lines, as a single non-indented multi-line
--   string
pcomment :: Posting -> String
ptype :: Posting -> PostingType

-- | tag names and values, extracted from the comment
ptags :: Posting -> [Tag]

-- | optional: the expected balance in the account after this posting
pbalanceassertion :: Posting -> Maybe MixedAmount

-- | this posting's parent transaction (co-recursive types). Tying this
--   knot gets tedious, Maybe makes it easier/optional.
ptransaction :: Posting -> Maybe Transaction
data Transaction
Transaction :: SourcePos -> Day -> Maybe Day -> ClearedStatus -> String -> String -> String -> [Tag] -> [Posting] -> String -> Transaction
tsourcepos :: Transaction -> SourcePos
tdate :: Transaction -> Day
tdate2 :: Transaction -> Maybe Day
tstatus :: Transaction -> ClearedStatus
tcode :: Transaction -> String
tdescription :: Transaction -> String

-- | this transaction's comment lines, as a single non-indented multi-line
--   string
tcomment :: Transaction -> String

-- | tag names and values, extracted from the comment
ttags :: Transaction -> [Tag]

-- | this transaction's postings
tpostings :: Transaction -> [Posting]

-- | any comment lines immediately preceding this transaction
tpreceding_comment_lines :: Transaction -> String
data ModifierTransaction
ModifierTransaction :: String -> [Posting] -> ModifierTransaction
mtvalueexpr :: ModifierTransaction -> String
mtpostings :: ModifierTransaction -> [Posting]
data PeriodicTransaction
PeriodicTransaction :: String -> [Posting] -> PeriodicTransaction
ptperiodicexpr :: PeriodicTransaction -> String
ptpostings :: PeriodicTransaction -> [Posting]
data TimeLogCode
SetBalance :: TimeLogCode
SetRequiredHours :: TimeLogCode
In :: TimeLogCode
Out :: TimeLogCode
FinalOut :: TimeLogCode
data TimeLogEntry
TimeLogEntry :: SourcePos -> TimeLogCode -> LocalTime -> String -> String -> TimeLogEntry
tlsourcepos :: TimeLogEntry -> SourcePos
tlcode :: TimeLogEntry -> TimeLogCode
tldatetime :: TimeLogEntry -> LocalTime
tlaccount :: TimeLogEntry -> String
tldescription :: TimeLogEntry -> String
data HistoricalPrice
HistoricalPrice :: Day -> Commodity -> Amount -> HistoricalPrice
hdate :: HistoricalPrice -> Day
hcommodity :: HistoricalPrice -> Commodity
hamount :: HistoricalPrice -> Amount
type Year = Integer

-- | A journal "context" is some data which can change in the course of
--   parsing a journal. An example is the default year, which changes when
--   a Y directive is encountered. At the end of parsing, the final context
--   is saved for later use by eg the add command.
data JournalContext
Ctx :: !(Maybe Year) -> !(Maybe (Commodity, AmountStyle)) -> ![AccountName] -> ![AccountAlias] -> JournalContext

-- | the default year most recently specified with Y
ctxYear :: JournalContext -> !(Maybe Year)

-- | the default commodity and amount style most recently specified with D
ctxDefaultCommodityAndStyle :: JournalContext -> !(Maybe (Commodity, AmountStyle))

-- | the current stack of parent accounts/account name components specified
--   with "account" directive(s). Concatenated, these are the account
--   prefix prepended to parsed account names.
ctxAccount :: JournalContext -> ![AccountName]

-- | the current list of account name aliases in effect
ctxAliases :: JournalContext -> ![AccountAlias]
data Journal
Journal :: [ModifierTransaction] -> [PeriodicTransaction] -> [Transaction] -> [TimeLogEntry] -> [HistoricalPrice] -> String -> JournalContext -> [(FilePath, String)] -> ClockTime -> Map Commodity AmountStyle -> Journal
jmodifiertxns :: Journal -> [ModifierTransaction]
jperiodictxns :: Journal -> [PeriodicTransaction]
jtxns :: Journal -> [Transaction]
open_timelog_entries :: Journal -> [TimeLogEntry]
historical_prices :: Journal -> [HistoricalPrice]

-- | any trailing comments from the journal file
final_comment_lines :: Journal -> String

-- | the context (parse state) at the end of parsing
jContext :: Journal -> JournalContext

-- | the file path and raw text of the main and any included journal files.
--   The main file is first followed by any included files in the order
--   encountered.
files :: Journal -> [(FilePath, String)]

-- | when this journal was last read from its file(s)
filereadtime :: Journal -> ClockTime

-- | how to display amounts in each commodity
jcommoditystyles :: Journal -> Map Commodity AmountStyle

-- | A JournalUpdate is some transformation of a Journal. It can do I/O or
--   raise an error.
type JournalUpdate = ExceptT String IO (Journal -> Journal)

-- | The id of a data format understood by hledger, eg <tt>journal</tt> or
--   <tt>csv</tt>.
type StorageFormat = String

-- | A hledger journal reader is a triple of format name, format-detecting
--   predicate, and a parser to Journal.
data Reader
Reader :: StorageFormat -> (FilePath -> String -> Bool) -> (Maybe FilePath -> Bool -> FilePath -> String -> ExceptT String IO Journal) -> Reader
rFormat :: Reader -> StorageFormat
rDetector :: Reader -> FilePath -> String -> Bool
rParser :: Reader -> Maybe FilePath -> Bool -> FilePath -> String -> ExceptT String IO Journal
data HledgerFormatField
AccountField :: HledgerFormatField
DefaultDateField :: HledgerFormatField
DescriptionField :: HledgerFormatField
TotalField :: HledgerFormatField
DepthSpacerField :: HledgerFormatField
FieldNo :: Int -> HledgerFormatField
data OutputFormat
FormatLiteral :: String -> OutputFormat
FormatField :: Bool -> (Maybe Int) -> (Maybe Int) -> HledgerFormatField -> OutputFormat

-- | An account, with name, balances and links to parent/subaccounts which
--   let you walk up or down the account tree.
data Account
Account :: AccountName -> MixedAmount -> [Account] -> Int -> MixedAmount -> Maybe Account -> Bool -> Account

-- | this account's full name
aname :: Account -> AccountName

-- | this account's balance, excluding subaccounts
aebalance :: Account -> MixedAmount

-- | sub-accounts
asubs :: Account -> [Account]

-- | number of postings to this account derived from the above:
anumpostings :: Account -> Int

-- | this account's balance, including subaccounts
aibalance :: Account -> MixedAmount

-- | parent account
aparent :: Account -> Maybe Account

-- | used in the accounts report to label elidable parents
aboring :: Account -> Bool

-- | A Ledger has the journal it derives from, and the accounts derived
--   from that. Accounts are accessible both list-wise and tree-wise, since
--   each one knows its parent and subs; the first account is the root of
--   the tree and always exists.
data Ledger
Ledger :: Journal -> [Account] -> Ledger
ljournal :: Ledger -> Journal
laccounts :: Ledger -> [Account]
instance Typeable DateSpan
instance Typeable Interval
instance Typeable AccountAlias
instance Typeable Side
instance Typeable DigitGroupStyle
instance Typeable AmountStyle
instance Typeable Amount
instance Typeable Price
instance Typeable MixedAmount
instance Typeable PostingType
instance Typeable ClearedStatus
instance Typeable Transaction
instance Typeable Posting
instance Typeable ModifierTransaction
instance Typeable PeriodicTransaction
instance Typeable TimeLogCode
instance Typeable TimeLogEntry
instance Typeable HistoricalPrice
instance Typeable JournalContext
instance Typeable Journal
instance Typeable ClockTime
instance Data ClockTime
instance Data (DecimalRaw Integer)
instance Eq WhichDate
instance Show WhichDate
instance Eq DateSpan
instance Ord DateSpan
instance Data DateSpan
instance Eq Interval
instance Show Interval
instance Ord Interval
instance Data Interval
instance Eq AccountAlias
instance Read AccountAlias
instance Show AccountAlias
instance Ord AccountAlias
instance Data AccountAlias
instance Eq Side
instance Show Side
instance Read Side
instance Ord Side
instance Data Side
instance Eq DigitGroupStyle
instance Ord DigitGroupStyle
instance Read DigitGroupStyle
instance Show DigitGroupStyle
instance Data DigitGroupStyle
instance Eq AmountStyle
instance Ord AmountStyle
instance Read AmountStyle
instance Show AmountStyle
instance Data AmountStyle
instance Eq Amount
instance Ord Amount
instance Data Amount
instance Eq Price
instance Ord Price
instance Data Price
instance Eq MixedAmount
instance Ord MixedAmount
instance Data MixedAmount
instance Eq PostingType
instance Show PostingType
instance Data PostingType
instance Eq ClearedStatus
instance Ord ClearedStatus
instance Data ClearedStatus
instance Eq Transaction
instance Data Transaction
instance Data Posting
instance Eq ModifierTransaction
instance Data ModifierTransaction
instance Eq PeriodicTransaction
instance Data PeriodicTransaction
instance Eq TimeLogCode
instance Ord TimeLogCode
instance Data TimeLogCode
instance Eq TimeLogEntry
instance Ord TimeLogEntry
instance Data TimeLogEntry
instance Eq HistoricalPrice
instance Data HistoricalPrice
instance Read JournalContext
instance Show JournalContext
instance Eq JournalContext
instance Data JournalContext
instance Eq Journal
instance Data Journal
instance Show HledgerFormatField
instance Eq HledgerFormatField
instance Show OutputFormat
instance Eq OutputFormat
instance Show Reader
instance Eq Posting
instance Show ClearedStatus
instance ToMarkup Quantity

module Hledger.Data.OutputFormat
parseStringFormat :: String -> Either String [OutputFormat]
formatsp :: Stream [Char] m Char => ParsecT [Char] st m [OutputFormat]
formatValue :: Bool -> Maybe Int -> Maybe Int -> String -> String
data OutputFormat
FormatLiteral :: String -> OutputFormat
FormatField :: Bool -> (Maybe Int) -> (Maybe Int) -> HledgerFormatField -> OutputFormat
data HledgerFormatField
AccountField :: HledgerFormatField
DefaultDateField :: HledgerFormatField
DescriptionField :: HledgerFormatField
TotalField :: HledgerFormatField
DepthSpacerField :: HledgerFormatField
FieldNo :: Int -> HledgerFormatField
tests :: Test


-- | Standard imports and utilities which are useful everywhere, or needed
--   low in the module hierarchy. This is the bottom of hledger's module
--   graph.
module Hledger.Utils
lowercase :: String -> String
uppercase :: String -> String

-- | Remove leading and trailing whitespace.
strip :: String -> String

-- | Remove leading whitespace.
lstrip :: String -> String

-- | Remove trailing whitespace.
rstrip :: String -> String

-- | Remove trailing newlines/carriage returns.
chomp :: String -> String
stripbrackets :: String -> String
elideLeft :: Int -> String -> String
elideRight :: Int -> String -> String
underline :: String -> String

-- | Wrap a string in double quotes, and -prefix any embedded single
--   quotes, if it contains whitespace and is not already single- or
--   double-quoted.
quoteIfSpaced :: String -> String

-- | Double-quote this string if it contains whitespace, single quotes or
--   double-quotes, escaping the quotes as needed.
quoteIfNeeded :: String -> String

-- | Single-quote this string if it contains whitespace or double-quotes.
--   No good for strings containing single quotes.
singleQuoteIfNeeded :: String -> String
quotechars :: [Char]
whitespacechars :: [Char]
escapeDoubleQuotes :: String -> String
escapeSingleQuotes :: String -> String
escapeQuotes :: String -> String

-- | Quote-aware version of words - don't split on spaces which are inside
--   quotes. NB correctly handles "a'b" but not "''a''". Can raise an error
--   if parsing fails.
words' :: String -> [String]

-- | Quote-aware version of unwords - single-quote strings which contain
--   whitespace
unwords' :: [String] -> String

-- | Strip one matching pair of single or double quotes on the ends of a
--   string.
stripquotes :: String -> String
isSingleQuoted :: [Char] -> Bool
isDoubleQuoted :: [Char] -> Bool
unbracket :: String -> String

-- | Join multi-line strings as side-by-side rectangular strings of the
--   same height, top-padded.
concatTopPadded :: [String] -> String

-- | Join multi-line strings as side-by-side rectangular strings of the
--   same height, bottom-padded.
concatBottomPadded :: [String] -> String

-- | Compose strings vertically and right-aligned.
vConcatRightAligned :: [String] -> String

-- | Convert a multi-line string to a rectangular string top-padded to the
--   specified height.
padtop :: Int -> String -> String

-- | Convert a multi-line string to a rectangular string bottom-padded to
--   the specified height.
padbottom :: Int -> String -> String

-- | Convert a multi-line string to a rectangular string left-padded to the
--   specified width.
padleft :: Int -> String -> String

-- | Convert a multi-line string to a rectangular string right-padded to
--   the specified width.
padright :: Int -> String -> String

-- | Clip a multi-line string to the specified width and height from the
--   top left.
cliptopleft :: Int -> Int -> String -> String

-- | Clip and pad a multi-line string to fill the specified width and
--   height.
fitto :: Int -> Int -> String -> String
first3 :: (t, t1, t2) -> t
second3 :: (t, t1, t2) -> t1
third3 :: (t, t1, t2) -> t2
first4 :: (t, t1, t2, t3) -> t
second4 :: (t, t1, t2, t3) -> t1
third4 :: (t, t1, t2, t3) -> t2
fourth4 :: (t, t1, t2, t3) -> t3
first5 :: (t, t1, t2, t3, t4) -> t
second5 :: (t, t1, t2, t3, t4) -> t1
third5 :: (t, t1, t2, t3, t4) -> t2
fourth5 :: (t, t1, t2, t3, t4) -> t3
fifth5 :: (t, t1, t2, t3, t4) -> t4
difforzero :: (Num a, Ord a) => a -> a -> a
splitAtElement :: Eq a => a -> [a] -> [[a]]
root :: Tree a -> a
subs :: Tree a -> Forest a
branches :: Tree a -> Forest a

-- | List just the leaf nodes of a tree
leaves :: Tree a -> [a]

-- | get the sub-tree rooted at the first (left-most, depth-first)
--   occurrence of the specified node value
subtreeat :: Eq a => a -> Tree a -> Maybe (Tree a)

-- | get the sub-tree for the specified node value in the first tree in
--   forest in which it occurs.
subtreeinforest :: Eq a => a -> [Tree a] -> Maybe (Tree a)

-- | remove all nodes past a certain depth
treeprune :: Int -> Tree a -> Tree a

-- | apply f to all tree nodes
treemap :: (a -> b) -> Tree a -> Tree b

-- | remove all subtrees whose nodes do not fulfill predicate
treefilter :: (a -> Bool) -> Tree a -> Tree a

-- | is predicate true in any node of tree ?
treeany :: (a -> Bool) -> Tree a -> Bool

-- | show a compact ascii representation of a tree
showtree :: Show a => Tree a -> String

-- | show a compact ascii representation of a forest
showforest :: Show a => Forest a -> String

-- | An efficient-to-build tree suggested by Cale Gibbard, probably better
--   than accountNameTreeFrom.
newtype FastTree a
T :: (Map a (FastTree a)) -> FastTree a
emptyTree :: FastTree a
mergeTrees :: Ord a => FastTree a -> FastTree a -> FastTree a
treeFromPath :: [a] -> FastTree a
treeFromPaths :: Ord a => [[a]] -> FastTree a

-- | Backtracking choice, use this when alternatives share a prefix.
--   Consumes no input if all choices fail.
choice' :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
parsewith :: Parsec [Char] () a -> String -> Either ParseError a
parseWithCtx :: Stream s m t => u -> ParsecT s u m a -> s -> m (Either ParseError a)
fromparse :: Either ParseError a -> a
parseerror :: ParseError -> a
showParseError :: ParseError -> String
showDateParseError :: ParseError -> String
nonspace :: Stream [Char] m Char => ParsecT [Char] st m Char
spacenonewline :: Stream [Char] m Char => ParsecT [Char] st m Char
restofline :: Stream [Char] m Char => ParsecT [Char] st m String
eolof :: Stream [Char] m Char => ParsecT [Char] st m ()
getCurrentLocalTime :: IO LocalTime

-- | Get a Test's label, or the empty string.
testName :: Test -> String

-- | Flatten a Test containing TestLists into a list of single tests.
flattenTests :: Test -> [Test]

-- | Filter TestLists in a Test, recursively, preserving the structure.
filterTests :: (Test -> Bool) -> Test -> Test

-- | Simple way to assert something is some expected value, with no label.
is :: (Eq a, Show a) => a -> a -> Assertion

-- | Assert a parse result is successful, printing the parse error on
--   failure.
assertParse :: (Either ParseError a) -> Assertion

-- | Assert a parse result is successful, printing the parse error on
--   failure.
assertParseFailure :: (Either ParseError a) -> Assertion

-- | Assert a parse result is some expected value, printing the parse error
--   on failure.
assertParseEqual :: (Show a, Eq a) => (Either ParseError a) -> a -> Assertion
printParseError :: Show a => a -> IO ()
isLeft :: Either a b -> Bool
isRight :: Either a b -> Bool

-- | Apply a function the specified number of times. Possibly uses O(n)
--   stack ?
applyN :: Int -> (a -> a) -> a -> a

-- | Convert a possibly relative, possibly tilde-containing file path to an
--   absolute one, given the current directory. ~username is not supported.
--   Leave "-" unchanged.
expandPath :: MonadIO m => FilePath -> FilePath -> m FilePath
firstJust :: Eq a => [Maybe a] -> Maybe a

-- | Read a file in universal newline mode, handling whatever newline
--   convention it may contain.
readFile' :: FilePath -> IO String

-- | A string received from or being passed to the operating system, such
--   as a file path, command-line argument, or environment variable name or
--   value. With GHC versions before 7.2 on some platforms (posix) these
--   are typically encoded. When converting, we assume the encoding is
--   UTF-8 (cf
--   <a>http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html#UTF8</a>).
type SystemString = String

-- | Convert a system string to an ordinary string, decoding from UTF-8 if
--   it appears to be UTF8-encoded and GHC version is less than 7.2.
fromSystemString :: SystemString -> String

-- | Convert a unicode string to a system string, encoding with UTF-8 if we
--   are on a posix platform with GHC &lt; 7.2.
toSystemString :: String -> SystemString

-- | A SystemString-aware version of error.
error' :: String -> a

-- | A SystemString-aware version of userError.
userError' :: String -> IOError
instance Show a => Show (FastTree a)
instance Eq a => Eq (FastTree a)
instance Ord a => Ord (FastTree a)


-- | <a>AccountName</a>s are strings like <tt>assets:cash:petty</tt>, with
--   multiple components separated by <tt>:</tt>. From a set of these we
--   derive the account hierarchy.
module Hledger.Data.AccountName
acctsepchar :: Char
accountNameComponents :: AccountName -> [String]
accountNameFromComponents :: [String] -> AccountName
accountLeafName :: AccountName -> String
accountNameLevel :: AccountName -> Int
accountNameDrop :: Int -> AccountName -> AccountName

-- | <ul>
--   <li><i>"a:b:c","d:e"</i> -&gt; ["a","a:b","a:b:c","d","d:e"]</li>
--   </ul>
expandAccountNames :: [AccountName] -> [AccountName]

-- | "a:b:c" -&gt; ["a","a:b","a:b:c"]
expandAccountName :: AccountName -> [AccountName]

-- | <ul>
--   <li><i>"a:b:c","d:e"</i> -&gt; ["a","d"]</li>
--   </ul>
topAccountNames :: [AccountName] -> [AccountName]
parentAccountName :: AccountName -> AccountName
parentAccountNames :: AccountName -> [AccountName]

-- | Is the first account a parent or other ancestor of (and not the same
--   as) the second ?
isAccountNamePrefixOf :: AccountName -> AccountName -> Bool
isSubAccountNameOf :: AccountName -> AccountName -> Bool

-- | From a list of account names, select those which are direct
--   subaccounts of the given account name.
subAccountNamesFrom :: [AccountName] -> AccountName -> [AccountName]

-- | Convert a list of account names to a tree.
accountNameTreeFrom :: [AccountName] -> Tree AccountName
nullaccountnametree :: Tree [Char]

-- | Elide an account name to fit in the specified width. From the ledger
--   2.6 news:
--   
--   <pre>
--   What Ledger now does is that if an account name is too long, it will
--   start abbreviating the first parts of the account name down to two
--   letters in length.  If this results in a string that is still too
--   long, the front will be elided -- not the end.  For example:
--   
--     Expenses:Cash           ; OK, not too long
--     Ex:Wednesday:Cash       ; <a>Expenses</a> was abbreviated to fit
--     Ex:We:Afternoon:Cash    ; <a>Expenses</a> and <a>Wednesday</a> abbreviated
--     ; Expenses:Wednesday:Afternoon:Lunch:Snack:Candy:Chocolate:Cash
--     ..:Af:Lu:Sn:Ca:Ch:Cash  ; Abbreviated and elided!
--   </pre>
elideAccountName :: Int -> AccountName -> AccountName

-- | Keep only the first n components of an account name, where n is a
--   positive integer. If n is 0, returns the empty string.
clipAccountName :: Int -> AccountName -> AccountName

-- | Keep only the first n components of an account name, where n is a
--   positive integer. If n is 0, returns "...".
clipOrEllipsifyAccountName :: Int -> AccountName -> AccountName

-- | Convert an account name to a regular expression matching it and its
--   subaccounts.
accountNameToAccountRegex :: String -> String

-- | Convert an account name to a regular expression matching it but not
--   its subaccounts.
accountNameToAccountOnlyRegex :: String -> String

-- | Convert an exact account-matching regular expression to a plain
--   account name.
accountRegexToAccountName :: String -> String

-- | Does this string look like an exact account-matching regular
--   expression ?
isAccountRegex :: String -> Bool
tests_Hledger_Data_AccountName :: Test


-- | A <a>Commodity</a> is a symbol representing a currency or some other
--   kind of thing we are tracking, and some display preferences that tell
--   how to display <a>Amount</a>s of the commodity - is the symbol on the
--   left or right, are thousands separated by comma, significant decimal
--   places and so on.
module Hledger.Data.Commodity
nonsimplecommoditychars :: String
quoteCommoditySymbolIfNeeded :: [Char] -> [Char]
commodity :: [Char]
commoditysymbols :: [([Char], [Char])]

-- | Look up one of the sample commodities' symbol by name.
comm :: String -> Commodity

-- | Find the conversion rate between two commodities. Currently returns 1.
conversionRate :: Commodity -> Commodity -> Double
tests_Hledger_Data_Commodity :: Test


-- | A simple <a>Amount</a> is some quantity of money, shares, or anything
--   else. It has a (possibly null) <a>Commodity</a> and a numeric
--   quantity:
--   
--   <pre>
--   $1
--   £-50
--   EUR 3.44
--   GOOG 500
--   1.5h
--   90 apples
--   0
--   </pre>
--   
--   It may also have an assigned <a>Price</a>, representing this amount's
--   per-unit or total cost in a different commodity. If present, this is
--   rendered like so:
--   
--   <pre>
--   EUR 2 @ $1.50  (unit price)
--   EUR 2 @@ $3   (total price)
--   </pre>
--   
--   A <a>MixedAmount</a> is zero or more simple amounts, so can represent
--   multiple commodities; this is the type most often used:
--   
--   <pre>
--   0
--   $50 + EUR 3
--   16h + $13.55 + AAPL 500 + 6 oranges
--   </pre>
--   
--   When a mixed amount has been "normalised", it has no more than one
--   amount in each commodity and no zero amounts; or it has just a single
--   zero amount and no others.
--   
--   Limited arithmetic with simple and mixed amounts is supported, best
--   used with similar amounts since it mostly ignores assigned prices and
--   commodity exchange rates.
module Hledger.Data.Amount

-- | The empty simple amount.
amount :: Amount

-- | The empty simple amount.
nullamt :: Amount

-- | A temporary value for parsed transactions which had no amount
--   specified.
missingamt :: Amount
num :: Quantity -> Amount
usd :: DecimalRaw Integer -> Amount
eur :: DecimalRaw Integer -> Amount
gbp :: DecimalRaw Integer -> Amount
hrs :: Quantity -> Amount
at :: Amount -> Amount -> Amount
(@@) :: Amount -> Amount -> Amount

-- | Convert an amount to the specified commodity, ignoring and discarding
--   any assigned prices and assuming an exchange rate of 1.
amountWithCommodity :: Commodity -> Amount -> Amount

-- | Convert an amount to the commodity of its assigned price, if any.
--   Notes:
--   
--   <ul>
--   <li>price amounts must be MixedAmounts with exactly one component
--   Amount (or there will be a runtime error) XXX</li>
--   <li>price amounts should be positive, though this is not currently
--   enforced</li>
--   </ul>
costOfAmount :: Amount -> Amount

-- | Divide an amount's quantity by a constant.
divideAmount :: Amount -> Quantity -> Amount
amountstyle :: AmountStyle

-- | Get the string representation of an amount, based on its commodity's
--   display settings. String representations equivalent to zero are
--   converted to just "0". The special "missing" amount is displayed as
--   the empty string.
showAmount :: Amount -> String

-- | Like showAmount, but show a zero amount's commodity if it has one.
showAmountWithZeroCommodity :: Amount -> String

-- | Get a string representation of an amount for debugging, appropriate to
--   the current debug level. 9 shows maximum detail.
showAmountDebug :: Amount -> String

-- | Get the string representation of an amount, without any @ price.
showAmountWithoutPrice :: Amount -> String

-- | For rendering: a special precision value which means show all
--   available digits.
maxprecision :: Int

-- | For rendering: a special precision value which forces display of a
--   decimal point.
maxprecisionwithpoint :: Int

-- | Set an amount's display precision.
setAmountPrecision :: Int -> Amount -> Amount

-- | Set an amount's display precision, flipped.
withPrecision :: Amount -> Int -> Amount

-- | Canonicalise an amount's display style using the provided commodity
--   style map.
canonicaliseAmount :: Map Commodity AmountStyle -> Amount -> Amount

-- | The empty mixed amount.
nullmixedamt :: MixedAmount

-- | A temporary value for parsed transactions which had no amount
--   specified.
missingmixedamt :: MixedAmount

-- | Convert amounts in various commodities into a normalised MixedAmount.
mixed :: [Amount] -> MixedAmount

-- | Sum same-commodity amounts. If there were different prices, set the
--   price to a special marker indicating "various". Only used as a
--   rendering helper. sumSimilarAmountsNotingPriceDifference :: [Amount]
--   -&gt; Amount sumSimilarAmountsNotingPriceDifference [] = nullamt
--   sumSimilarAmountsNotingPriceDifference as = undefined
--   
--   Get a mixed amount's component amounts.
amounts :: MixedAmount -> [Amount]

-- | Filter a mixed amount's component amounts by a predicate.
filterMixedAmount :: (Amount -> Bool) -> MixedAmount -> MixedAmount

-- | Return an unnormalised MixedAmount containing exactly one Amount with
--   the specified commodity and the quantity of that commodity found in
--   the original. NB if Amount's quantity is zero it will be discarded
--   next time the MixedAmount gets normalised.
filterMixedAmountByCommodity :: Commodity -> MixedAmount -> MixedAmount

-- | Like normaliseMixedAmount, but combine each commodity's amounts into
--   just one by throwing away all prices except the first. This is only
--   used as a rendering helper, and could show a misleading price.
normaliseMixedAmountSquashPricesForDisplay :: MixedAmount -> MixedAmount

-- | Simplify a mixed amount's component amounts:
--   
--   <ul>
--   <li>amounts in the same commodity are combined unless they have
--   different prices or total prices</li>
--   <li>multiple zero amounts are replaced by just one. If they had the
--   same commodity, it is preserved.</li>
--   <li>an empty amount list is replaced with a single commodityless
--   zero</li>
--   <li>the special "missing" mixed amount remains unchanged</li>
--   </ul>
normaliseMixedAmount :: MixedAmount -> MixedAmount

-- | Convert a mixed amount's component amounts to the commodity of their
--   assigned price, if any.
costOfMixedAmount :: MixedAmount -> MixedAmount

-- | Divide a mixed amount's quantities by a constant.
divideMixedAmount :: MixedAmount -> Quantity -> MixedAmount

-- | Calculate the average of some mixed amounts.
averageMixedAmounts :: [MixedAmount] -> MixedAmount

-- | Is this mixed amount negative, if it can be normalised to a single
--   commodity ?
isNegativeMixedAmount :: MixedAmount -> Maybe Bool

-- | Does this mixed amount appear to be zero when displayed with its given
--   precision ?
isZeroMixedAmount :: MixedAmount -> Bool

-- | Is this mixed amount "really" zero ? See isReallyZeroAmount.
isReallyZeroMixedAmount :: MixedAmount -> Bool

-- | Is this mixed amount "really" zero, after converting to cost
--   commodities where possible ?
isReallyZeroMixedAmountCost :: MixedAmount -> Bool

-- | Get the string representation of a mixed amount, after normalising it
--   to one amount per commodity. Assumes amounts have no or similar
--   prices, otherwise this can show misleading prices.
showMixedAmount :: MixedAmount -> String

-- | Get an unambiguous string representation of a mixed amount for
--   debugging.
showMixedAmountDebug :: MixedAmount -> String

-- | Get the string representation of a mixed amount, but without any @
--   prices.
showMixedAmountWithoutPrice :: MixedAmount -> String

-- | Get the one-line string representation of a mixed amount, but without
--   any @ prices.
showMixedAmountOneLineWithoutPrice :: MixedAmount -> String

-- | Like showMixedAmount, but zero amounts are shown with their commodity
--   if they have one.
showMixedAmountWithZeroCommodity :: MixedAmount -> String

-- | Get the string representation of a mixed amount, showing each of its
--   component amounts with the specified precision, ignoring their
--   commoditys' display precision settings.
showMixedAmountWithPrecision :: Int -> MixedAmount -> String

-- | Set the display precision in the amount's commodities.
setMixedAmountPrecision :: Int -> MixedAmount -> MixedAmount

-- | Canonicalise a mixed amount's display styles using the provided
--   commodity style map.
canonicaliseMixedAmount :: Map Commodity AmountStyle -> MixedAmount -> MixedAmount

-- | Compact labelled trace of a mixed amount, for debugging.
ltraceamount :: String -> MixedAmount -> MixedAmount
tests_Hledger_Data_Amount :: Test
instance Show HistoricalPrice
instance Num MixedAmount
instance Show MixedAmount
instance Num Amount
instance Show Amount


-- | Date parsing and utilities for hledger.
--   
--   For date and time values, we use the standard Day and UTCTime types.
--   
--   A <a>SmartDate</a> is a date which may be partially-specified or
--   relative. Eg 2008/12/31, but also 2008/12, 12/31, tomorrow, last week,
--   next year. We represent these as a triple of strings like
--   ("2008","12",""), ("","","tomorrow"), ("","last","week").
--   
--   A <a>DateSpan</a> is the span of time between two specific calendar
--   dates, or an open-ended span where one or both dates are unspecified.
--   (A date span with both ends unspecified matches all dates.)
--   
--   An <a>Interval</a> is ledger's "reporting interval" - weekly, monthly,
--   quarterly, etc.
module Hledger.Data.Dates

-- | Get the current local date.
getCurrentDay :: IO Day

-- | Get the current local month number.
getCurrentMonth :: IO Int

-- | Get the current local year.
getCurrentYear :: IO Integer
nulldate :: Day

-- | Does the span include the given date ?
spanContainsDate :: DateSpan -> Day -> Bool

-- | Parse a couple of date string formats to a time type.
parsedateM :: String -> Maybe Day

-- | Parse a date string to a time type, or raise an error.
parsedate :: String -> Day
showDate :: Day -> String

-- | Render a datespan as a display string, abbreviating into a compact
--   form if possible.
showDateSpan :: DateSpan -> String
elapsedSeconds :: Fractional a => UTCTime -> UTCTime -> a
prevday :: Day -> Day

-- | Parse a period expression to an Interval and overall DateSpan using
--   the provided reference date, or return a parse error.
parsePeriodExpr :: Day -> String -> Either ParseError (Interval, DateSpan)
nulldatespan :: DateSpan
tests_Hledger_Data_Dates :: Test
failIfInvalidYear :: Monad m => String -> m ()
failIfInvalidMonth :: Monad m => String -> m ()
failIfInvalidDay :: Monad m => String -> m ()
datesepchar :: Stream [Char] m Char => ParsecT [Char] st m Char
datesepchars :: [Char]
spanStart :: DateSpan -> Maybe Day
spanEnd :: DateSpan -> Maybe Day

-- | Get overall span enclosing multiple sequentially ordered spans.
spansSpan :: [DateSpan] -> DateSpan

-- | Calculate the intersection of two datespans.
spanIntersect :: DateSpan -> DateSpan -> DateSpan

-- | Calculate the intersection of a number of datespans.
spansIntersect :: [DateSpan] -> DateSpan

-- | Fill any unspecified dates in the first span with the dates from the
--   second one. Sort of a one-way spanIntersect.
spanDefaultsFrom :: DateSpan -> DateSpan -> DateSpan

-- | Calculate the union of two datespans.
spanUnion :: DateSpan -> DateSpan -> DateSpan

-- | Calculate the union of a number of datespans.
spansUnion :: [DateSpan] -> DateSpan

-- | Parse a date in any of the formats allowed in ledger's period
--   expressions, and maybe some others:
--   
--   <pre>
--   2004
--   2004/10
--   2004/10/1
--   10/1
--   21
--   october, oct
--   yesterday, today, tomorrow
--   this/next/last week/day/month/quarter/year
--   </pre>
--   
--   Returns a SmartDate, to be converted to a full date later (see
--   fixSmartDate). Assumes any text in the parse stream has been
--   lowercased.
smartdate :: Stream [Char] m Char => ParsecT [Char] st m SmartDate

-- | Split a DateSpan into one or more consecutive whole spans of the
--   specified length which enclose it. If no interval is specified, the
--   original span is returned.
splitSpan :: Interval -> DateSpan -> [DateSpan]

-- | Convert a SmartDate to an absolute date using the provided reference
--   date.
fixSmartDate :: Day -> SmartDate -> Day

-- | Convert a smart date string to an explicit yyyy/mm/dd string using the
--   provided reference date, or raise an error.
fixSmartDateStr :: Day -> String -> String

-- | A safe version of fixSmartDateStr.
fixSmartDateStrEither :: Day -> String -> Either ParseError String
fixSmartDateStrEither' :: Day -> String -> Either ParseError Day

-- | Count the days in a DateSpan, or if it is open-ended return Nothing.
daysInSpan :: DateSpan -> Maybe Integer
maybePeriod :: Day -> String -> Maybe (Interval, DateSpan)

-- | Make a datespan from two valid date strings parseable by parsedate (or
--   raise an error). Eg: mkdatespan "2011<i>1</i>1" "2011<i>12</i>31".
mkdatespan :: String -> String -> DateSpan
instance Show DateSpan


-- | A <a>Posting</a> represents a change (by some <a>MixedAmount</a>) of
--   the balance in some <a>Account</a>. Each <a>Transaction</a> contains
--   two or more postings which should add up to 0. Postings reference
--   their parent transaction, so we can look up the date or description
--   there.
module Hledger.Data.Posting
nullposting :: Posting
posting :: Posting
post :: AccountName -> Amount -> Posting

-- | Get a posting's cleared status: cleared or pending if those are
--   explicitly set, otherwise the cleared status of its parent
--   transaction, or uncleared if there is no parent transaction. (Note
--   Uncleared's ambiguity, it can mean "uncleared" or "don't know".
postingStatus :: Posting -> ClearedStatus
isReal :: Posting -> Bool
isVirtual :: Posting -> Bool
isBalancedVirtual :: Posting -> Bool
isEmptyPosting :: Posting -> Bool
hasAmount :: Posting -> Bool

-- | Tags for this posting including any inherited from its parent
--   transaction.
postingAllTags :: Posting -> [Tag]

-- | Tags for this transaction including any from its postings.
transactionAllTags :: Transaction -> [Tag]
relatedPostings :: Posting -> [Posting]

-- | Get a posting's (primary) date - it's own primary date if specified,
--   otherwise the parent transaction's primary date, or the null date if
--   there is no parent transaction.
postingDate :: Posting -> Day

-- | Get a posting's secondary (secondary) date, which is the first of:
--   posting's secondary date, transaction's secondary date, posting's
--   primary date, transaction's primary date, or the null date if there is
--   no parent transaction.
postingDate2 :: Posting -> Day

-- | Does this posting fall within the given date span ?
isPostingInDateSpan :: DateSpan -> Posting -> Bool
isPostingInDateSpan' :: WhichDate -> DateSpan -> Posting -> Bool

-- | Get the minimal date span which contains all the postings, or the null
--   date span if there are none.
postingsDateSpan :: [Posting] -> DateSpan
postingsDateSpan' :: WhichDate -> [Posting] -> DateSpan
accountNamesFromPostings :: [Posting] -> [AccountName]
accountNamePostingType :: AccountName -> PostingType
accountNameWithoutPostingType :: AccountName -> AccountName
accountNameWithPostingType :: PostingType -> AccountName -> AccountName

-- | Prefix one account name to another, preserving posting type indicators
--   like concatAccountNames.
joinAccountNames :: AccountName -> AccountName -> AccountName

-- | Join account names into one. If any of them has () or [] posting type
--   indicators, these (the first type encountered) will also be applied to
--   the resulting account name.
concatAccountNames :: [AccountName] -> AccountName

-- | Rewrite an account name using all matching aliases from the given
--   list, in sequence. Each alias sees the result of applying the previous
--   aliases.
accountNameApplyAliases :: [AccountAlias] -> AccountName -> AccountName
sumPostings :: [Posting] -> MixedAmount
showPosting :: Posting -> String
showComment :: String -> String
tests_Hledger_Data_Posting :: Test
instance Show Posting


-- | An <a>Account</a> has a name, a list of subaccounts, an optional
--   parent account, and subaccounting-excluding and -including balances.
module Hledger.Data.Account
nullacct :: Account

-- | Derive 1. an account tree and 2. their balances from a list of
--   postings. (ledger's core feature). The accounts are returned in a
--   list, but retain their tree structure; the first one is the root of
--   the tree.
accountsFromPostings :: [Posting] -> [Account]

-- | Convert an AccountName tree to an Account tree
nameTreeToAccount :: AccountName -> FastTree AccountName -> Account

-- | Tie the knot so all subaccounts' parents are set correctly.
tieAccountParents :: Account -> Account

-- | Get this account's parent accounts, from the nearest up to the root.
parentAccounts :: Account -> [Account]

-- | List the accounts at each level of the account tree.
accountsLevels :: Account -> [[Account]]

-- | Map a (non-tree-structure-modifying) function over this and sub
--   accounts.
mapAccounts :: (Account -> Account) -> Account -> Account

-- | Is the predicate true on any of this account or its subaccounts ?
anyAccounts :: (Account -> Bool) -> Account -> Bool

-- | Add subaccount-inclusive balances to an account tree.
sumAccounts :: Account -> Account

-- | Remove all subaccounts below a certain depth.
clipAccounts :: Int -> Account -> Account

-- | Remove subaccounts below the specified depth, aggregating their
--   balance at the depth limit (accounts at the depth limit will have any
--   sub-balances merged into their exclusive balance).
clipAccountsAndAggregate :: Int -> [Account] -> [Account]

-- | Remove all leaf accounts and subtrees matching a predicate.
pruneAccounts :: (Account -> Bool) -> Account -> Maybe Account

-- | Flatten an account tree into a list, which is sometimes convenient.
--   Note since accounts link to their parents/subs, the account tree
--   remains intact and can still be used. It's a tree/list!
flattenAccounts :: Account -> [Account]

-- | Filter an account tree (to a list).
filterAccounts :: (Account -> Bool) -> Account -> [Account]

-- | Search an account list by name.
lookupAccount :: AccountName -> [Account] -> Maybe Account
printAccounts :: Account -> IO ()
showAccounts :: Account -> String
showAccountsBoringFlag :: Account -> String
showAccountDebug :: PrintfType t => Account -> t
tests_Hledger_Data_Account :: Test
instance Eq Account
instance Show Account


-- | hledger's cmdargs modes parse command-line arguments to an
--   intermediate format, RawOpts (an association list), rather than a
--   fixed ADT like CliOpts. This allows the modes and flags to be reused
--   more easily by hledger commands/scripts in this and other packages.
module Hledger.Data.RawOptions

-- | The result of running cmdargs: an association list of option names to
--   string values.
type RawOpts = [(String, String)]
setopt :: String -> String -> RawOpts -> RawOpts
setboolopt :: String -> RawOpts -> RawOpts

-- | Is the named option present ?
inRawOpts :: String -> RawOpts -> Bool
boolopt :: String -> RawOpts -> Bool
stringopt :: String -> RawOpts -> String
maybestringopt :: String -> RawOpts -> Maybe String
listofstringopt :: String -> RawOpts -> [String]
intopt :: String -> RawOpts -> Int
maybeintopt :: String -> RawOpts -> Maybe Int

-- | Raise an error, showing the specified message plus a hint about
--   --help.
optserror :: String -> a


-- | A <a>Transaction</a> represents a movement of some commodity(ies)
--   between two or more accounts. It consists of multiple account
--   <a>Posting</a>s which balance to zero, a date, and optional extras
--   like description, cleared status, and tags.
module Hledger.Data.Transaction
nullsourcepos :: SourcePos
nulltransaction :: Transaction

-- | Ensure a transaction's postings refer back to it, so that eg
--   relatedPostings works right.
txnTieKnot :: Transaction -> Transaction

-- | Show an account name, clipped to the given width if any, and
--   appropriately bracketed/parenthesised for the given posting type.
showAccountName :: Maybe Int -> PostingType -> AccountName -> String
hasRealPostings :: Transaction -> Bool
realPostings :: Transaction -> [Posting]
virtualPostings :: Transaction -> [Posting]
balancedVirtualPostings :: Transaction -> [Posting]
transactionsPostings :: [Transaction] -> [Posting]

-- | Is this transaction balanced ? A balanced transaction's real
--   (non-virtual) postings sum to 0, and any balanced virtual postings
--   also sum to 0.
isTransactionBalanced :: Maybe (Map Commodity AmountStyle) -> Transaction -> Bool
transactionDate2 :: Transaction -> Day

-- | Get the sums of a transaction's real, virtual, and balanced virtual
--   postings.
transactionPostingBalances :: Transaction -> (MixedAmount, MixedAmount, MixedAmount)

-- | Ensure this transaction is balanced, possibly inferring a missing
--   amount or conversion price(s), or return an error message. Balancing
--   is affected by commodity display precisions, so those can (optionally)
--   be provided.
balanceTransaction :: Maybe (Map Commodity AmountStyle) -> Transaction -> Either String Transaction

-- | Show a journal transaction, formatted for the print command. ledger
--   2.x's standard format looks like this:
--   
--   <pre>
--   yyyy<i>mm</i>dd[ *][ CODE] description.........          [  ; comment...............]
--       account name 1.....................  ...$amount1[  ; comment...............]
--       account name 2.....................  ..$-amount1[  ; comment...............]
--   
--   pcodewidth    = no limit -- 10          -- mimicking ledger layout.
--   pdescwidth    = no limit -- 20          -- I don't remember what these mean,
--   pacctwidth    = 35 minimum, no maximum  -- they were important at the time.
--   pamtwidth     = 11
--   pcommentwidth = no limit -- 22
--   </pre>
showTransaction :: Transaction -> String
showTransactionUnelided :: Transaction -> String
tests_Hledger_Data_Transaction :: Test
instance Show PeriodicTransaction
instance Show ModifierTransaction
instance Show Transaction


-- | A <a>TimeLogEntry</a> is a clock-in, clock-out, or other directive in
--   a timelog file (see timeclock.el or the command-line version). These
--   can be converted to <tt>Transactions</tt> and queried like a ledger.
module Hledger.Data.TimeLog

-- | Convert time log entries to journal transactions. When there is no
--   clockout, add one with the provided current time. Sessions crossing
--   midnight are split into days to give accurate per-day totals.
timeLogEntriesToTransactions :: LocalTime -> [TimeLogEntry] -> [Transaction]

-- | Convert a timelog clockin and clockout entry to an equivalent journal
--   transaction, representing the time expenditure. Note this entry is not
--   balanced, since we omit the "assets:time" transaction for simpler
--   output.
entryFromTimeLogInOut :: TimeLogEntry -> TimeLogEntry -> Transaction
tests_Hledger_Data_TimeLog :: Test
instance Read TimeLogCode
instance Show TimeLogCode
instance Show TimeLogEntry


-- | A general query system for matching things (accounts, postings,
--   transactions..) by various criteria, and a parser for query
--   expressions.
module Hledger.Query

-- | A query is a composition of search criteria, which can be used to
--   match postings, transactions, accounts and more.
data Query

-- | always match
Any :: Query

-- | never match
None :: Query

-- | negate this match
Not :: Query -> Query

-- | match if any of these match
Or :: [Query] -> Query

-- | match if all of these match
And :: [Query] -> Query

-- | match if code matches this regexp
Code :: Regexp -> Query

-- | match if description matches this regexp
Desc :: Regexp -> Query

-- | match postings whose account matches this regexp
Acct :: Regexp -> Query

-- | match if primary date in this date span
Date :: DateSpan -> Query

-- | match if secondary date in this date span
Date2 :: DateSpan -> Query

-- | match txns/postings with this cleared status (Status Uncleared matches
--   all states except cleared)
Status :: ClearedStatus -> Query

-- | match if "realness" (involves a real non-virtual account ?) has this
--   value
Real :: Bool -> Query

-- | match if the amount's numeric quantity is less than<i>greater
--   than</i>equal to/unsignedly equal to some value
Amt :: OrdPlus -> Quantity -> Query

-- | match if the entire commodity symbol is matched by this regexp
Sym :: Regexp -> Query

-- | if true, show zero-amount postings/accounts which are usually not
--   shown more of a query option than a query criteria ?
Empty :: Bool -> Query

-- | match if account depth is less than or equal to this value
Depth :: Int -> Query

-- | match if a tag's name, and optionally its value, is matched by these
--   respective regexps matching the regexp if provided, exists
Tag :: Regexp -> (Maybe Regexp) -> Query

-- | A query option changes a query's/report's behaviour and output in some
--   way.
data QueryOpt

-- | show an account register focussed on this account
QueryOptInAcctOnly :: AccountName -> QueryOpt

-- | as above but include sub-accounts in the account register |
--   QueryOptCostBasis -- ^ show amounts converted to cost where possible |
--   QueryOptDate2 -- ^ show secondary dates instead of primary dates
QueryOptInAcct :: AccountName -> QueryOpt

-- | Convert a query expression containing zero or more space-separated
--   terms to a query and zero or more query options. A query term is
--   either:
--   
--   <ol>
--   <li>a search pattern, which matches on one or more fields,
--   eg:acct:REGEXP - match the account name with a regular expression
--   desc:REGEXP - match the transaction description date:PERIODEXP - match
--   the date with a period expressionThe prefix indicates the field to
--   match, or if there is no prefix account name is assumed.</li>
--   <li>a query option, which modifies the reporting behaviour in some
--   way. There is currently one of these, which may appear only
--   once:inacct:FULLACCTNAME</li>
--   </ol>
--   
--   The usual shell quoting rules are assumed. When a pattern contains
--   whitespace, it (or the whole term including prefix) should be enclosed
--   in single or double quotes.
--   
--   Period expressions may contain relative dates, so a reference date is
--   required to fully parse these.
--   
--   Multiple terms are combined as follows: 1. multiple account patterns
--   are OR'd together 2. multiple description patterns are OR'd together
--   3. then all terms are AND'd together
parseQuery :: Day -> String -> (Query, [QueryOpt])
simplifyQuery :: Query -> Query

-- | Remove query terms (or whole sub-expressions) not matching the given
--   predicate from this query. XXX Semantics not yet clear.
filterQuery :: (Query -> Bool) -> Query -> Query

-- | Does this query match everything ?
queryIsNull :: Query -> Bool
queryIsAcct :: Query -> Bool
queryIsDepth :: Query -> Bool
queryIsDate :: Query -> Bool
queryIsDate2 :: Query -> Bool
queryIsDateOrDate2 :: Query -> Bool

-- | Does this query specify a start date and nothing else (that would
--   filter postings prior to the date) ? When the flag is true, look for a
--   starting secondary date instead.
queryIsStartDateOnly :: Bool -> Query -> Bool
queryIsSym :: Query -> Bool

-- | What start date (or secondary date) does this query specify, if any ?
--   For OR expressions, use the earliest of the dates. NOT is ignored.
queryStartDate :: Bool -> Query -> Maybe Day

-- | What end date (or secondary date) does this query specify, if any ?
--   For OR expressions, use the latest of the dates. NOT is ignored.
queryEndDate :: Bool -> Query -> Maybe Day

-- | What date span (or secondary date span) does this query specify ? For
--   OR expressions, use the widest possible span. NOT is ignored.
queryDateSpan :: Bool -> Query -> DateSpan

-- | What date span (or secondary date span) does this query specify ? For
--   OR expressions, use the widest possible span. NOT is ignored.
queryDateSpan' :: Query -> DateSpan

-- | The depth limit this query specifies, or a large number if none.
queryDepth :: Query -> Int

-- | The account we are currently focussed on, if any, and whether
--   subaccounts are included. Just looks at the first query option.
inAccount :: [QueryOpt] -> Maybe (AccountName, Bool)

-- | A query for the account(s) we are currently focussed on, if any. Just
--   looks at the first query option.
inAccountQuery :: [QueryOpt] -> Maybe Query

-- | Does the match expression match this transaction ?
matchesTransaction :: Query -> Transaction -> Bool

-- | Does the match expression match this posting ?
matchesPosting :: Query -> Posting -> Bool

-- | Does the match expression match this account ? A matching in: clause
--   is also considered a match.
matchesAccount :: Query -> AccountName -> Bool
matchesMixedAmount :: Query -> MixedAmount -> Bool

-- | Does the match expression match this (simple) amount ?
matchesAmount :: Query -> Amount -> Bool

-- | Quote-and-prefix-aware version of words - don't split on spaces which
--   are inside quotes, including quotes which may have one of the
--   specified prefixes in front, and maybe an additional not: prefix in
--   front of that.
words'' :: [String] -> String -> [String]
tests_Hledger_Query :: Test
instance Typeable QueryOpt
instance Typeable OrdPlus
instance Typeable Query
instance Show QueryOpt
instance Eq QueryOpt
instance Data QueryOpt
instance Show OrdPlus
instance Eq OrdPlus
instance Data OrdPlus
instance Eq Query
instance Data Query
instance Show Query


-- | A <a>Journal</a> is a set of transactions, plus optional related data.
--   This is hledger's primary data object. It is usually parsed from a
--   journal file or other data format (see <a>Hledger.Read</a>).
module Hledger.Data.Journal
addHistoricalPrice :: HistoricalPrice -> Journal -> Journal
addModifierTransaction :: ModifierTransaction -> Journal -> Journal
addPeriodicTransaction :: PeriodicTransaction -> Journal -> Journal
addTimeLogEntry :: TimeLogEntry -> Journal -> Journal
addTransaction :: Transaction -> Journal -> Journal

-- | Apply additional account aliases (eg from the command-line) to all
--   postings in a journal.
journalApplyAliases :: [AccountAlias] -> Journal -> Journal

-- | Fill in any missing amounts and check that all journal transactions
--   balance, or return an error message. This is done after parsing all
--   amounts and working out the canonical commodities, since balancing
--   depends on display precision. Reports only the first error
--   encountered.
journalBalanceTransactions :: Journal -> Either String Journal

-- | Convert all the journal's posting amounts (not price amounts) to their
--   canonical display settings. Ie, all amounts in a given commodity will
--   use (a) the display settings of the first, and (b) the greatest
--   precision, of the posting amounts in that commodity.
journalCanonicaliseAmounts :: Journal -> Journal

-- | Convert all this journal's amounts to cost by applying their prices,
--   if any.
journalConvertAmountsToCost :: Journal -> Journal

-- | Do post-parse processing on a journal to make it ready for use: check
--   all transactions balance, canonicalise amount formats, close any open
--   timelog entries, maybe check balance assertions and so on.
journalFinalise :: ClockTime -> LocalTime -> FilePath -> String -> JournalContext -> Bool -> Journal -> Either String Journal

-- | Keep only transactions matching the query expression.
filterJournalTransactions :: Query -> Journal -> Journal

-- | Keep only postings matching the query expression. This can leave
--   unbalanced transactions.
filterJournalPostings :: Query -> Journal -> Journal

-- | Within each posting's amount, keep only the parts matching the query.
--   This can leave unbalanced transactions.
filterJournalAmounts :: Query -> Journal -> Journal

-- | Filter out all parts of this transaction's amounts which do not match
--   the query. This can leave the transaction unbalanced.
filterTransactionAmounts :: Query -> Transaction -> Transaction

-- | Filter out all parts of this posting's amount which do not match the
--   query.
filterPostingAmount :: Query -> Posting -> Posting

-- | Unique account names in this journal, including parent accounts
--   containing no postings.
journalAccountNames :: Journal -> [AccountName]

-- | Unique account names posted to in this journal.
journalAccountNamesUsed :: Journal -> [AccountName]

-- | Get all this journal's component amounts, roughly in the order parsed.
journalAmounts :: Journal -> [Amount]

-- | The fully specified date span enclosing the dates (primary or
--   secondary) of all this journal's transactions and postings, or
--   DateSpan Nothing Nothing if there are none.
journalDateSpan :: Bool -> Journal -> DateSpan

-- | Unique transaction descriptions used in this journal.
journalDescriptions :: Journal -> [String]
journalFilePath :: Journal -> FilePath
journalFilePaths :: Journal -> [FilePath]

-- | All postings from this journal's transactions, in order.
journalPostings :: Journal -> [Posting]

-- | A query for Asset, Liability &amp; Equity accounts in this journal. Cf
--   <a>http://en.wikipedia.org/wiki/Chart_of_accounts#Balance_Sheet_Accounts</a>.
journalBalanceSheetAccountQuery :: Journal -> Query

-- | A query for Profit &amp; Loss accounts in this journal. Cf
--   <a>http://en.wikipedia.org/wiki/Chart_of_accounts#Profit_.26_Loss_accounts</a>.
journalProfitAndLossAccountQuery :: Journal -> Query

-- | A query for Income (Revenue) accounts in this journal. This is
--   currently hard-coded to the case-insensitive regex
--   <tt>^(income|revenue)s?(:|$)</tt>.
journalIncomeAccountQuery :: Journal -> Query

-- | A query for Expense accounts in this journal. This is currently
--   hard-coded to the case-insensitive regex <tt>^expenses?(:|$)</tt>.
journalExpenseAccountQuery :: Journal -> Query

-- | A query for Asset accounts in this journal. This is currently
--   hard-coded to the case-insensitive regex <tt>^assets?(:|$)</tt>.
journalAssetAccountQuery :: Journal -> Query

-- | A query for Liability accounts in this journal. This is currently
--   hard-coded to the case-insensitive regex
--   <tt>^(debts?|liabilit(y|ies))(:|$)</tt>.
journalLiabilityAccountQuery :: Journal -> Query

-- | A query for Equity accounts in this journal. This is currently
--   hard-coded to the case-insensitive regex <tt>^equity(:|$)</tt>.
journalEquityAccountQuery :: Journal -> Query

-- | A query for Cash (-equivalent) accounts in this journal (ie, accounts
--   which appear on the cashflow statement.) This is currently hard-coded
--   to be all the Asset accounts except for those containing the
--   case-insensitive regex <tt>(receivable|A/R)</tt>.
journalCashAccountQuery :: Journal -> Query

-- | Given a list of amounts in parse order, build a map from commodities
--   to canonical display styles for amounts in that commodity.
canonicalStyles :: [Amount] -> Map Commodity AmountStyle

-- | Check if a set of hledger account/description filter patterns matches
--   the given account name or entry description. Patterns are
--   case-insensitive regular expressions. Prefixed with not:, they become
--   anti-patterns.
matchpats :: [String] -> String -> Bool
nullctx :: JournalContext
nulljournal :: Journal
samplejournal :: Journal
tests_Hledger_Data_Journal :: Test
instance Show Journal


-- | A <a>Ledger</a> is derived from a <a>Journal</a> by applying a filter
--   specification to select <a>Transaction</a>s and <a>Posting</a>s of
--   interest. It contains the filtered journal and knows the resulting
--   chart of accounts, account balances, and postings in each account.
module Hledger.Data.Ledger
nullledger :: Ledger

-- | Filter a journal's transactions with the given query, then derive a
--   ledger containing the chart of accounts and balances. If the query
--   includes a depth limit, that will affect the this ledger's journal but
--   not the ledger's account tree.
ledgerFromJournal :: Query -> Journal -> Ledger

-- | List a ledger's account names.
ledgerAccountNames :: Ledger -> [AccountName]

-- | Get the named account from a ledger.
ledgerAccount :: Ledger -> AccountName -> Maybe Account

-- | Get this ledger's root account, which is a dummy "root" account above
--   all others. This should always be first in the account list, if
--   somehow not this returns a null account.
ledgerRootAccount :: Ledger -> Account

-- | List a ledger's top-level accounts (the ones below the root), in tree
--   order.
ledgerTopAccounts :: Ledger -> [Account]

-- | List a ledger's bottom-level (subaccount-less) accounts, in tree
--   order.
ledgerLeafAccounts :: Ledger -> [Account]

-- | Accounts in ledger whose name matches the pattern, in tree order.
ledgerAccountsMatching :: [String] -> Ledger -> [Account]

-- | List a ledger's postings, in the order parsed.
ledgerPostings :: Ledger -> [Posting]

-- | The (fully specified) date span containing all the ledger's (filtered)
--   transactions, or DateSpan Nothing Nothing if there are none.
ledgerDateSpan :: Ledger -> DateSpan

-- | All commodities used in this ledger.
ledgerCommodities :: Ledger -> [Commodity]
tests_ledgerFromJournal :: [Test]
tests_Hledger_Data_Ledger :: Test
instance Show Ledger


-- | The Hledger.Data library allows parsing and querying of C++
--   ledger-style journal files. It generally provides a compatible subset
--   of C++ ledger's functionality. This package re-exports all the
--   Hledger.Data.* modules (except UTF8, which requires an explicit
--   import.)
module Hledger.Data
tests_Hledger_Data :: Test


-- | A reader for hledger's journal file format
--   (<a>http://hledger.org/MANUAL.html#the-journal-file</a>). hledger's
--   journal format is a compatible subset of c++ ledger's
--   (<a>http://ledger-cli.org/3.0/doc/ledger3.html#Journal-Format</a>), so
--   this reader should handle many ledger files as well. Example:
--   
--   <pre>
--   2012/3/24 gift
--       expenses:gifts  $10
--       assets:cash
--   </pre>
module Hledger.Read.JournalReader
reader :: Reader

-- | Given a JournalUpdate-generating parsec parser, file path and data
--   string, parse and post-process a Journal so that it's ready to use, or
--   give an error.
parseJournalWith :: (ParsecT [Char] JournalContext (ExceptT String IO) (JournalUpdate, JournalContext)) -> Bool -> FilePath -> String -> ExceptT String IO Journal
getParentAccount :: Stream [Char] m Char => ParsecT [Char] JournalContext m String

-- | Top-level journal parser. Returns a single composite, I/O performing,
--   error-raising <a>JournalUpdate</a> (and final <a>JournalContext</a>)
--   which can be applied to an empty journal to get the final result.
journal :: ParsecT [Char] JournalContext (ExceptT String IO) (JournalUpdate, JournalContext)
directive :: ParsecT [Char] JournalContext (ExceptT String IO) JournalUpdate
defaultyeardirective :: ParsecT [Char] JournalContext (ExceptT String IO) JournalUpdate
historicalpricedirective :: ParsecT [Char] JournalContext (ExceptT String IO) HistoricalPrice

-- | Parse a date and time in YYYY<i>MM</i>DD HH:MM[:SS][+-ZZZZ] format.
--   Hyphen (-) and period (.) are also allowed as date separators. The
--   year may be omitted if a default year has been set. Seconds are
--   optional. The timezone is optional and ignored (the time is always
--   interpreted as a local time). Leading zeroes may be omitted (except in
--   a timezone).
datetimep :: Stream [Char] m Char => ParsecT [Char] JournalContext m LocalTime
codep :: Stream [Char] m Char => ParsecT [Char] JournalContext m String

-- | Parse an account name. Account names start with a non-space, may have
--   single spaces inside them, and are terminated by two or more spaces
--   (or end of input). Also they have one or more components of at least
--   one character, separated by the account separator char. (This parser
--   will also consume one following space, if present.)
accountnamep :: Stream [Char] m Char => ParsecT [Char] st m AccountName

-- | Parse an account name, then apply any parent account prefix and/or
--   account aliases currently in effect.
modifiedaccountname :: Stream [Char] m Char => ParsecT [Char] JournalContext m AccountName
postingp :: Stream [Char] m Char => ParsecT [Char] JournalContext m Posting

-- | Parse a single-commodity amount, with optional symbol on the left or
--   right, optional unit or total price, and optional (ignored)
--   ledger-style balance assertion or fixed lot price declaration.
amountp :: Stream [Char] m t => ParsecT [Char] JournalContext m Amount

-- | Parse an amount from a string, or get an error.
amountp' :: String -> Amount

-- | Parse a mixed amount from a string, or get an error.
mamountp' :: String -> MixedAmount

-- | Parse a string representation of a number for its value and display
--   attributes.
--   
--   Some international number formats are accepted, eg either period or
--   comma may be used for the decimal point, and the other of these may be
--   used for separating digit groups in the integer part. See
--   <a>http://en.wikipedia.org/wiki/Decimal_separator</a> for more
--   examples.
--   
--   This returns: the parsed numeric value, the precision (number of
--   digits seen following the decimal point), the decimal point character
--   used if any, and the digit group style if any.
numberp :: Stream [Char] m t => ParsecT [Char] JournalContext m (Quantity, Int, Maybe Char, Maybe DigitGroupStyle)
statusp :: Stream [Char] m Char => ParsecT [Char] JournalContext m ClearedStatus
emptyorcommentlinep :: Stream [Char] m Char => ParsecT [Char] JournalContext m ()
followingcommentp :: Stream [Char] m Char => ParsecT [Char] JournalContext m String
accountaliasp :: Stream [Char] m Char => ParsecT [Char] st m AccountAlias
tests_Hledger_Read_JournalReader :: Test


-- | A reader for the timelog file format generated by timeclock.el
--   (<a>http://www.emacswiki.org/emacs/TimeClock</a>). Example:
--   
--   <pre>
--   i 2007/03/10 12:26:00 hledger
--   o 2007/03/10 17:26:02
--   </pre>
--   
--   From timeclock.el 2.6:
--   
--   <pre>
--   A timelog contains data in the form of a single entry per line.
--   Each entry has the form:
--   
--     CODE YYYY<i>MM</i>DD HH:MM:SS [COMMENT]
--   
--   CODE is one of: b, h, i, o or O.  COMMENT is optional when the code is
--   i, o or O.  The meanings of the codes are:
--   
--     b  Set the current time balance, or "time debt".  Useful when
--        archiving old log data, when a debt must be carried forward.
--        The COMMENT here is the number of seconds of debt.
--   
--     h  Set the required working time for the given day.  This must
--        be the first entry for that day.  The COMMENT in this case is
--        the number of hours in this workday.  Floating point amounts
--        are allowed.
--   
--     i  Clock in.  The COMMENT in this case should be the name of the
--        project worked on.
--   
--     o  Clock out.  COMMENT is unnecessary, but can be used to provide
--        a description of how the period went, for example.
--   
--     O  Final clock out.  Whatever project was being worked on, it is
--        now finished.  Useful for creating summary reports.
--   </pre>
module Hledger.Read.TimelogReader
reader :: Reader
tests_Hledger_Read_TimelogReader :: Test


-- | A reader for CSV data, using an extra rules file to help interpret the
--   data.
module Hledger.Read.CsvReader
reader :: Reader
type CsvRecord = [String]
rulesFileFor :: FilePath -> FilePath
parseRulesFile :: FilePath -> ExceptT String IO CsvRules
transactionFromCsvRecord :: SourcePos -> CsvRules -> CsvRecord -> Transaction
tests_Hledger_Read_CsvReader :: Test
instance Show CsvRules
instance Eq CsvRules


-- | This is the entry point to hledger's reading system, which can read
--   Journals from various data formats. Use this module if you want to
--   parse journal data or read journal files. Generally it should not be
--   necessary to import modules below this one.
module Hledger.Read

-- | All the data formats we can read. formats = map rFormat readers
--   
--   Get the default journal file path specified by the environment. Like
--   ledger, we look first for the LEDGER_FILE environment variable, and if
--   that does not exist, for the legacy LEDGER environment variable. If
--   neither is set, or the value is blank, return the hard-coded default,
--   which is <tt>.hledger.journal</tt> in the users's home directory (or
--   in the current directory, if we cannot determine a home directory).
defaultJournalPath :: IO String

-- | Read the default journal file specified by the environment, or raise
--   an error.
defaultJournal :: IO Journal

-- | Read a journal from this string, trying whatever readers seem
--   appropriate:
--   
--   <ul>
--   <li>if a format is specified, try that reader only</li>
--   <li>or if one or more readers recognises the file path and data, try
--   those</li>
--   <li>otherwise, try them all.</li>
--   </ul>
--   
--   A CSV conversion rules file may also be specified for use by the CSV
--   reader. Also there is a flag specifying whether to check or ignore
--   balance assertions in the journal.
readJournal :: Maybe StorageFormat -> Maybe FilePath -> Bool -> Maybe FilePath -> String -> IO (Either String Journal)

-- | Read a journal from the given string, trying all known formats, or
--   simply throw an error.
readJournal' :: String -> IO Journal

-- | Read a Journal from this file (or stdin if the filename is -) or give
--   an error message, using the specified data format or trying all known
--   formats. A CSV conversion rules file may be specified for better
--   conversion of that format. Also there is a flag specifying whether to
--   check or ignore balance assertions in the journal.
readJournalFile :: Maybe StorageFormat -> Maybe FilePath -> Bool -> FilePath -> IO (Either String Journal)
readJournalFiles :: Maybe StorageFormat -> Maybe FilePath -> Bool -> [FilePath] -> IO (Either String Journal)

-- | If the specified journal file does not exist, give a helpful error and
--   quit.
requireJournalFileExists :: FilePath -> IO ()

-- | Ensure there is a journal file at the given path, creating an empty
--   one if needed.
ensureJournalFileExists :: FilePath -> IO ()
postingp :: Stream [Char] m Char => ParsecT [Char] JournalContext m Posting

-- | Parse an account name. Account names start with a non-space, may have
--   single spaces inside them, and are terminated by two or more spaces
--   (or end of input). Also they have one or more components of at least
--   one character, separated by the account separator char. (This parser
--   will also consume one following space, if present.)
accountnamep :: Stream [Char] m Char => ParsecT [Char] st m AccountName

-- | Parse a single-commodity amount, with optional symbol on the left or
--   right, optional unit or total price, and optional (ignored)
--   ledger-style balance assertion or fixed lot price declaration.
amountp :: Stream [Char] m t => ParsecT [Char] JournalContext m Amount

-- | Parse an amount from a string, or get an error.
amountp' :: String -> Amount

-- | Parse a mixed amount from a string, or get an error.
mamountp' :: String -> MixedAmount

-- | Parse a string representation of a number for its value and display
--   attributes.
--   
--   Some international number formats are accepted, eg either period or
--   comma may be used for the decimal point, and the other of these may be
--   used for separating digit groups in the integer part. See
--   <a>http://en.wikipedia.org/wiki/Decimal_separator</a> for more
--   examples.
--   
--   This returns: the parsed numeric value, the precision (number of
--   digits seen following the decimal point), the decimal point character
--   used if any, and the digit group style if any.
numberp :: Stream [Char] m t => ParsecT [Char] JournalContext m (Quantity, Int, Maybe Char, Maybe DigitGroupStyle)
codep :: Stream [Char] m Char => ParsecT [Char] JournalContext m String
accountaliasp :: Stream [Char] m Char => ParsecT [Char] st m AccountAlias
samplejournal :: IO Journal
tests_Hledger_Read :: Test


-- | Options common to most hledger reports.
module Hledger.Reports.ReportOptions

-- | Standard options for customising report filtering and output,
--   corresponding to hledger's command-line options and query language
--   arguments. Used in hledger-lib and above.
data ReportOpts
ReportOpts :: Maybe Day -> Maybe Day -> Maybe (Interval, DateSpan) -> Bool -> Bool -> Bool -> Bool -> Maybe Int -> Maybe DisplayExp -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe FormatStr -> String -> Bool -> Bool -> BalanceType -> AccountListMode -> Int -> Bool -> Bool -> ReportOpts
begin_ :: ReportOpts -> Maybe Day
end_ :: ReportOpts -> Maybe Day
period_ :: ReportOpts -> Maybe (Interval, DateSpan)
cleared_ :: ReportOpts -> Bool
pending_ :: ReportOpts -> Bool
uncleared_ :: ReportOpts -> Bool
cost_ :: ReportOpts -> Bool
depth_ :: ReportOpts -> Maybe Int
display_ :: ReportOpts -> Maybe DisplayExp
date2_ :: ReportOpts -> Bool
empty_ :: ReportOpts -> Bool
no_elide_ :: ReportOpts -> Bool
real_ :: ReportOpts -> Bool
daily_ :: ReportOpts -> Bool
weekly_ :: ReportOpts -> Bool
monthly_ :: ReportOpts -> Bool
quarterly_ :: ReportOpts -> Bool
yearly_ :: ReportOpts -> Bool
format_ :: ReportOpts -> Maybe FormatStr
query_ :: ReportOpts -> String
average_ :: ReportOpts -> Bool
related_ :: ReportOpts -> Bool
balancetype_ :: ReportOpts -> BalanceType
accountlistmode_ :: ReportOpts -> AccountListMode
drop_ :: ReportOpts -> Int
row_total_ :: ReportOpts -> Bool
no_total_ :: ReportOpts -> Bool

-- | Which balance is being shown in a multi-column balance report.
data BalanceType

-- | The change of balance in each period.
PeriodBalance :: BalanceType

-- | The accumulated balance at each period's end, starting from zero at
--   the report start date.
CumulativeBalance :: BalanceType

-- | The historical balance at each period's end, starting from the account
--   balances at the report start date.
HistoricalBalance :: BalanceType

-- | Should accounts be displayed: in the command's default style,
--   hierarchically, or as a flat list ?
data AccountListMode
ALDefault :: AccountListMode
ALTree :: AccountListMode
ALFlat :: AccountListMode
type FormatStr = String
defreportopts :: ReportOpts
rawOptsToReportOpts :: RawOpts -> IO ReportOpts
flat_ :: ReportOpts -> Bool

-- | Legacy-compatible convenience aliases for accountlistmode_.
tree_ :: ReportOpts -> Bool

-- | Figure out the date span we should report on, based on any
--   begin<i>end</i>period options provided. A period option will cause
--   begin and end options to be ignored.
dateSpanFromOpts :: Day -> ReportOpts -> DateSpan

-- | Figure out the reporting interval, if any, specified by the options.
--   --period overrides --daily overrides --weekly overrides --monthly etc.
intervalFromOpts :: ReportOpts -> Interval

-- | Get a maybe boolean representing the last cleared/uncleared option if
--   any.
clearedValueFromOpts :: ReportOpts -> Maybe ClearedStatus

-- | Report which date we will report on based on --date2.
whichDateFromOpts :: ReportOpts -> WhichDate

-- | Convert this journal's postings' amounts to the cost basis amounts if
--   specified by options.
journalSelectingAmountFromOpts :: ReportOpts -> Journal -> Journal

-- | Convert report options and arguments to a query.
queryFromOpts :: Day -> ReportOpts -> Query

-- | Convert report options to a query, ignoring any non-flag command line
--   arguments.
queryFromOptsOnly :: Day -> ReportOpts -> Query

-- | Convert report options and arguments to query options.
queryOptsFromOpts :: Day -> ReportOpts -> [QueryOpt]

-- | Select the Transaction date accessor based on --date2.
transactionDateFn :: ReportOpts -> (Transaction -> Day)

-- | Select the Posting date accessor based on --date2.
postingDateFn :: ReportOpts -> (Posting -> Day)
tests_Hledger_Reports_ReportOptions :: Test
instance Typeable BalanceType
instance Typeable AccountListMode
instance Typeable ReportOpts
instance Eq BalanceType
instance Show BalanceType
instance Data BalanceType
instance Eq AccountListMode
instance Show AccountListMode
instance Data AccountListMode
instance Show ReportOpts
instance Data ReportOpts
instance Default ReportOpts
instance Default AccountListMode
instance Default BalanceType


-- | Journal entries report, used by the print command.
module Hledger.Reports.EntriesReport

-- | A journal entries report is a list of whole transactions as originally
--   entered in the journal (mostly). This is used by eg hledger's print
--   command and hledger-web's journal entries view.
type EntriesReport = [EntriesReportItem]
type EntriesReportItem = Transaction

-- | Select transactions for an entries report.
entriesReport :: ReportOpts -> Query -> Journal -> EntriesReport
tests_Hledger_Reports_EntriesReport :: Test


-- | Postings report, used by the register command.
module Hledger.Reports.PostingsReport

-- | A postings report is a list of postings with a running total, a label
--   for the total field, and a little extra transaction info to help with
--   rendering. This is used eg for the register command.
type PostingsReport = (String, [PostingsReportItem])
type PostingsReportItem = (Maybe Day, Maybe Day, Maybe String, Posting, MixedAmount)

-- | Select postings from the journal and add running balance and other
--   information to make a postings report. Used by eg hledger's register
--   command.
postingsReport :: ReportOpts -> Query -> Journal -> PostingsReport

-- | Generate one postings report line item, containing the posting, the
--   current running balance, and optionally the posting date and/or the
--   transaction description.
mkpostingsReportItem :: Bool -> Bool -> WhichDate -> Maybe Day -> Posting -> MixedAmount -> PostingsReportItem
tests_Hledger_Reports_PostingsReport :: Test


-- | Here are several variants of a transactions report. Transactions
--   reports are like a postings report, but more transaction-oriented, and
--   (in the account-centric variant) relative to a some base account. They
--   are used by hledger-web.
module Hledger.Reports.TransactionsReports

-- | A transactions report includes a list of transactions
--   (posting-filtered and unfiltered variants), a running balance, and
--   some other information helpful for rendering a register view (a flag
--   indicating multiple other accounts and a display string describing
--   them) with or without a notion of current account(s). Two kinds of
--   report use this data structure, see journalTransactionsReport and
--   accountTransactionsReport below for detais.
type TransactionsReport = (String, [TransactionsReportItem])
type TransactionsReportItem = (Transaction, Transaction, Bool, String, MixedAmount, MixedAmount)
triOrigTransaction :: (t, t1, t2, t3, t4, t5) -> t
triDate :: (t, Transaction, t1, t2, t3, t4) -> Day
triAmount :: (t, t1, t2, t3, t4, t5) -> t4
triBalance :: (t, t1, t2, t3, t4, t5) -> t5
triCommodityAmount :: Commodity -> (t, t1, t2, t3, MixedAmount, t4) -> MixedAmount
triCommodityBalance :: Commodity -> (t, t1, t2, t3, t4, MixedAmount) -> MixedAmount

-- | Select transactions from the whole journal. This is similar to a
--   "postingsReport" except with transaction-based report items which are
--   ordered most recent first. XXX Or an EntriesReport - use that instead
--   ? This is used by hledger-web's journal view.
journalTransactionsReport :: ReportOpts -> Journal -> Query -> TransactionsReport
accountTransactionsReport :: ReportOpts -> Journal -> Query -> Query -> AccountTransactionsReport

-- | Split a transactions report whose items may involve several
--   commodities, into one or more single-commodity transactions reports.
transactionsReportByCommodity :: TransactionsReport -> [(Commodity, TransactionsReport)]


-- | Balance report, used by the balance command.
module Hledger.Reports.BalanceReport

-- | A simple single-column balance report. It has:
--   
--   <ol>
--   <li>a list of rows, each containing a renderable account name and a
--   corresponding amount</li>
--   <li>the final total of the amounts</li>
--   </ol>
type BalanceReport = ([BalanceReportItem], MixedAmount)
type BalanceReportItem = (RenderableAccountName, MixedAmount)

-- | A renderable account name includes some additional hints for rendering
--   accounts in a balance report. It has:
--   
--   <ul>
--   <li>The full account name</li>
--   <li>The ledger-style short elided account name (the leaf name,
--   prefixed by any boring parents immediately above)</li>
--   <li>The number of indentation steps to use when rendering a
--   ledger-style account tree (normally the 0-based depth of this account
--   excluding boring parents, or 0 with --flat).</li>
--   </ul>
type RenderableAccountName = (AccountName, AccountName, Int)

-- | Enabling this makes balance --flat --empty also show parent accounts
--   without postings, in addition to those with postings and a zero
--   balance. Disabling it shows only the latter. No longer supported, but
--   leave this here for a bit. flatShowsPostinglessAccounts = True
--   
--   Generate a simple balance report, containing the matched accounts and
--   their balances (change of balance) during the specified period. This
--   is like periodBalanceReport with a single column (but more mature, eg
--   this can do hierarchical display).
balanceReport :: ReportOpts -> Query -> Journal -> BalanceReport

-- | When true (the default), this makes balance --flat reports and their
--   implementation clearer. Single/multi-col balance reports currently
--   aren't all correct if this is false.
flatShowsExclusiveBalance :: Bool
tests_Hledger_Reports_BalanceReport :: Test


-- | Multi-column balance reports, used by the balance command.
module Hledger.Reports.MultiBalanceReports

-- | A multi balance report is a balance report with one or more columns.
--   It has:
--   
--   <ol>
--   <li>a list of each column's date span</li>
--   <li>a list of rows, each containing a renderable account name and the
--   amounts to show in each column</li>
--   <li>a list of each column's final total</li>
--   </ol>
--   
--   The meaning of the amounts depends on the type of multi balance
--   report, of which there are three: periodic, cumulative and historical
--   (see <a>BalanceType</a> and <a>Hledger.Cli.Balance</a>).
newtype MultiBalanceReport
MultiBalanceReport :: ([DateSpan], [MultiBalanceReportRow], MultiBalanceTotalsRow) -> MultiBalanceReport

-- | A row in a multi balance report has
--   
--   <ul>
--   <li>An account name, with rendering hints</li>
--   <li>A list of amounts to be shown in each of the report's
--   columns.</li>
--   <li>The total of the row amounts.</li>
--   <li>The average of the row amounts.</li>
--   </ul>
type MultiBalanceReportRow = (RenderableAccountName, [MixedAmount], MixedAmount, MixedAmount)

-- | Generate a multicolumn balance report for the matched accounts,
--   showing the change of balance, accumulated balance, or historical
--   balance in each of the specified periods.
multiBalanceReport :: ReportOpts -> Query -> Journal -> MultiBalanceReport
instance Show MultiBalanceReport


-- | Account balance history report.
module Hledger.Reports.BalanceHistoryReport

-- | Get the historical running inclusive balance of a particular account,
--   from earliest to latest posting date.
accountBalanceHistory :: ReportOpts -> Journal -> Account -> [(Day, MixedAmount)]


-- | Generate several common kinds of report from a journal, as "*Report" -
--   simple intermediate data structures intended to be easily rendered as
--   text, html, json, csv etc. by hledger commands, hamlet templates,
--   javascript, or whatever.
module Hledger.Reports
tests_Hledger_Reports :: Test

module Hledger
tests_Hledger :: Test
