-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | RNA secondary structure prediction
--   
--   RNAfold v2 using the ADPfusion library. The RNAfold algorithm is used
--   to determine how fast we can be compared to a highly optimized C
--   program.
--   
--   If possible, build using the GHC llvm backend, and GHC-7.2.2.
--   GHC-7.4.x produces very bad code on my system, please benchmark using
--   7.2.2.
--   
--   NOTE I'd like to rename this package to RNAfold, like the C
--   implementation. Do not install <a>globally</a>, especially if you
--   normally use RNAfold from the ViennaRNA package, for obvious reasons.
--   
--   NOTE I am reluctant to call this v2 for now.
@package RNAFold
@version 1.99.1.3


-- | A library of helpers for ADPfusion algorithms.
module BioInf.RNAfold.Library
base' :: Primary -> DIM2 -> (Scalar Nuc)

-- | Nucleotide, second one to the right. The assertion allows a size of
--   one or two to capture special cases of looking outside of the bounds
--   (used by <tt>justStemF</tt> in RNAfold).
baseLr' :: Primary -> DIM2 -> (Scalar (Nuc :!: Nuc))
baselR' :: Primary -> DIM2 -> (Scalar (Nuc :!: Nuc))
region' :: Vector Nuc -> DIM2 -> (Scalar (Vector Nuc))

-- | A <a>Primary</a> together with the lowest included nucleotide and the
--   highest included nucleotide.
primary' :: Primary -> DIM2 -> (Scalar ((Primary :!: Int) :!: Int))

-- | A <a>Primary</a> together with the lowest included nucleotide and the
--   highest included nucleotide.
primaryPR' :: Primary -> DIM2 -> (Scalar ((Primary :!: Int) :!: Int))

-- | A <a>Primary</a> together with the lowest included nucleotide and the
--   highest included nucleotide.
primaryPL' :: Primary -> DIM2 -> (Scalar ((Primary :!: Int) :!: Int))

-- | Vector of nucleotides peeking one nucleotide to the left.
regionpl' :: Vector Nuc -> DIM2 -> (Scalar (Vector Nuc))

-- | Vector of nucleotides peeaking one nucleotide to the right.
regionpr' :: Vector Nuc -> DIM2 -> (Scalar (Vector Nuc))

-- | Tests if (i,j) is a valid base pair.
basepairing' :: (Num a, Ord a, MkViennaPair (t, t), PrimArrayOps arr (:. Z a) t) => arr (:. Z a) t -> :. (:. Z a) a -> Bool
stackpairing' :: (Enum a, Num a, Ord a, MkViennaPair (t, t), PrimArrayOps arr (:. Z a) t) => arr (:. Z a) t -> a -> :. (:. Z a) a -> Bool
constrained :: (t1 -> t) -> t1 -> t
reglen' :: Primary -> DIM2 -> Scalar Int
reglenpl' :: Primary -> DIM2 -> Scalar (Nuc, Nuc, Int)
reglenpr' :: Primary -> DIM2 -> Scalar (Int, Nuc, Nuc)

-- | True, if the subword at ij is empty.
empty :: DIM2 -> Scalar Bool


-- | A set of energy functions that are modelled after the ViennaRNA
--   package, Version 2 (with d=2).
--   
--   As part of the design, we could have (i) either continued giving many
--   parameters or (ii) have fewer parameters that require input of the
--   (Primary,Index,Index) type. Since the compilation speed of the
--   grammars using these functions depends on the number of arguments (in
--   case (i) compilation takes minutes!), this approach has benefits for
--   testing the fusion library.
--   
--   This means compilation is a lot faster, but runtime is not
--   <tt>2.8x</tt> slower but <tt>3.5x</tt> slower.
module BioInf.RNAfold.Energy

-- | Hairpin structures. Hairpins with less than 3 unpaired nucleotides are
--   forbidden.
--   
--   NOTE <tt>(xs,i,j)</tt> is indeed *only* the unpaired stretch. Hence,
--   the length is <tt>j-i+1</tt>, as given.
--   
--   TODO Activate tabulated hairpin structures.
hairpinF :: Vienna2004 -> (Nuc :!: Nuc) -> ((Primary :!: Int) :!: Int) -> (Nuc :!: Nuc) -> Int

-- | Tiny loops are small interior loops. This includes canonical stacks
--   without any unpaired nucleotides, and small, tabulated interior loops.
tinyloopF :: Vienna2004 -> ((Primary :!: Int) :!: Int) -> Int -> ((Primary :!: Int) :!: Int) -> Int

-- | A left bulge <tt>(....[[...]])</tt> which four unpaired nucleotides in
--   the bulge. the left bulge <tt>ls</tt> will be given six nucleotides
--   (note, <tt>ls</tt> is the complete input, use <tt>li</tt> and
--   <tt>lj</tt> as the first and last included nucleotide index), the two
--   outer ones being for the outer and inner loop. On the right, we have
--   <tt>rp</tt> and <tt>r</tt> which are nucleotides. <tt>ls!(Z:.li)</tt>
--   and <tt>r</tt> form the outer Vienna pair. <tt>rp</tt> and
--   <tt>ls!(Z:.lj)</tt> form the inner pair.
bulgeLF :: Vienna2004 -> ((Primary :!: Int) :!: Int) -> Int -> (Nuc :!: Nuc) -> Int

-- | A right bulge <tt>([[...]]....)</tt>. See <a>bulgeLF</a> for how this
--   works.
bulgeRF :: Vienna2004 -> (Nuc :!: Nuc) -> Int -> ((Primary :!: Int) :!: Int) -> Int

-- | An interior loop with <tt>N</tt> unpaired nucleotides to the left and
--   <tt>1</tt> unpaired nucleotide to the right. The regions <tt>ls</tt>
--   and <tt>rs</tt> each have 2 nucleotides more than are unpaired. These
--   first and last nucleotides form the last paired or first pairs in the
--   stacks around the loop.
iloopN1F :: Vienna2004 -> ((Primary :!: Int) :!: Int) -> Int -> ((Primary :!: Int) :!: Int) -> Int

-- | 1xN interior loops.
iloop1NF :: Vienna2004 -> ((Primary :!: Int) :!: Int) -> Int -> ((Primary :!: Int) :!: Int) -> Int
iloopIF :: Vienna2004 -> ((Primary :!: Int) :!: Int) -> Int -> ((Primary :!: Int) :!: Int) -> Int
iloopOF :: Vienna2004 -> (Nuc :!: Nuc) -> Int -> (Nuc :!: Nuc) -> Int
multiIF :: Vienna2004 -> Int -> Int -> Int
multiOF :: Vienna2004 -> (Nuc :!: Nuc) -> Int -> (Nuc :!: Nuc) -> Int
regionStemF :: Vienna2004 -> Nuc -> Int -> Int
justStemF :: Vienna2004 -> (Nuc :!: Nuc) -> Int -> (Nuc :!: Nuc) -> Int
bsF :: Int -> Int -> Int
rSF :: Nuc -> Int -> Int
bcF :: Int -> Int -> Int
ssF :: Int -> Int
cmF :: Int -> Int -> Int
nilF :: Bool -> Int
iD :: a -> a
h :: Monad m => Stream m Int -> m Int
terminalAU :: Num a => a -> ViennaPair -> a


-- | RNAfold combinators, extracted for quickcheck
module BioInf.RNAfold.Combinators

-- | The structure on the right is a subword with size 2-30, however we
--   inspect the stack an reduce the maximal size.
(~~#) :: (Monad m1, Monad m, Num head1, Num head, Ord head1, Ord head) => xs -> ys -> Box ((:. (:. (:. t head) head) head, t1, t2) -> m (:. (:. (:. (:. t head) head) head) head, t1, t2)) ((:. (:. (:. (:. t3 head1) head1) head1) head1, t4, t5) -> m1 (Step (:. (:. (:. (:. t3 head1) head1) head1) head1, t4, t5) (:. (:. (:. (:. t3 head1) head1) head1) head1, t4, t5))) xs ys

-- | The structure on the left is a subword with size 2-28. The maximal
--   size could be 30 but since the two combinators are linked, 29,30 would
--   fail anyways.
(#~~) :: (Monad m1, Monad m, Num head, Num head1, Ord head) => xs -> ys -> Box ((:. (:. tail head1) head2, t, t1) -> m (:. (:. (:. tail head1) head1) head2, t, t1)) ((:. (:. (:. tail1 head) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head) head) head, t2, t3) (:. (:. (:. tail1 head) head) head, t2, t3))) xs ys

module BioInf.RNAfold
testRNAfold :: String -> (Int, [String])
testInput :: [Char]
test :: (Int, [String])
rnafold :: Vienna2004 -> Primary -> ST s (Arr0 DIM2 Int, Arr0 DIM2 Int, Arr0 DIM2 Int, Arr0 DIM2 Int)
(*~+) :: (Monad m1, Monad m, Num head, Num head1, Ord head) => xs -> ys -> Box ((:. (:. tail head1) head2, t, t1) -> m (:. (:. (:. tail head1) head1) head2, t, t1)) ((:. (:. (:. tail1 head) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head) head) head, t2, t3) (:. (:. (:. tail1 head) head) head, t2, t3))) xs ys
(+~*) :: (Monad m1, Monad m, Num head, Num head1, Ord head, Ord head1) => xs -> ys -> Box ((:. (:. tail head1) head1, t, t1) -> m (:. (:. (:. tail head1) head1) head1, t, t1)) ((:. (:. (:. tail1 head2) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head2) head) head, t2, t3) (:. (:. (:. tail1 head2) head) head, t2, t3))) xs ys
(&~+) :: (Monad m1, Monad m, Num head, Num head1, Ord head) => xs -> ys -> Box ((:. (:. tail head1) head2, t, t1) -> m (:. (:. (:. tail head1) head1) head2, t, t1)) ((:. (:. (:. tail1 head) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head) head) head, t2, t3) (:. (:. (:. tail1 head) head) head, t2, t3))) xs ys
(+~&) :: (Monad m1, Monad m, Num head, Num head1, Ord head, Ord head1) => xs -> ys -> Box ((:. (:. tail head1) head1, t, t1) -> m (:. (:. (:. tail head1) head1) head1, t, t1)) ((:. (:. (:. tail1 head2) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head2) head) head, t2, t3) (:. (:. (:. tail1 head2) head) head, t2, t3))) xs ys
(---~+) :: (Monad m1, Monad m, Num head, Num head1, Ord head) => xs -> ys -> Box ((:. (:. tail head1) head2, t, t1) -> m (:. (:. (:. tail head1) head1) head2, t, t1)) ((:. (:. (:. tail1 head) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head) head) head, t2, t3) (:. (:. (:. tail1 head) head) head, t2, t3))) xs ys
(+~@) :: (Monad m1, Monad m, Num head, Num head1, Ord head, Ord head1) => xs -> ys -> Box ((:. (:. tail head1) head1, t, t1) -> m (:. (:. (:. tail head1) head1) head1, t, t1)) ((:. (:. (:. tail1 head2) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head2) head) head, t2, t3) (:. (:. (:. tail1 head2) head) head, t2, t3))) xs ys
(+~---) :: (Monad m1, Monad m, Num head, Num head1, Ord head, Ord head1) => xs -> ys -> Box ((:. (:. tail head1) head1, t, t1) -> m (:. (:. (:. tail head1) head1) head1, t, t1)) ((:. (:. (:. tail1 head2) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head2) head) head, t2, t3) (:. (:. (:. tail1 head2) head) head, t2, t3))) xs ys
(@~+) :: (Monad m1, Monad m, Num head, Num head1, Ord head) => xs -> ys -> Box ((:. (:. tail head1) head2, t, t1) -> m (:. (:. (:. tail head1) head1) head2, t, t1)) ((:. (:. (:. tail1 head) head) head, t2, t3) -> m1 (Step (:. (:. (:. tail1 head) head) head, t2, t3) (:. (:. (:. tail1 head) head) head, t2, t3))) xs ys
btRNAfold :: Vienna2004 -> Primary -> (Arr0 DIM2 Int, Arr0 DIM2 Int, Arr0 DIM2 Int, Arr0 DIM2 Int) -> [String]
adjustStream :: Int -> (DIM2 -> Stream (ST s) Int) -> DIM2 -> Stream (ST s) Int
adjustStreamBT :: Int -> (DIM2 -> Stream elm) -> DIM2 -> Stream elm
(.!.) :: (Monad m, Num head, Num head1, Ord head, Ord head1) => (:. (:. Z head1) head -> Stream m a) -> (Stream m a -> t, head) -> :. (:. Z head1) head -> t
with :: (Monad m, Num a) => (t -> m a) -> (t -> Bool) -> t -> m a
withBT :: Monad m => (t -> m [a]) -> (t -> Bool) -> t -> m [a]
fillTables :: PrimMonad m => MArr0 (PrimState m) DIM2 Int -> (DIM2 -> m Int) -> MArr0 (PrimState m) DIM2 Int -> (DIM2 -> m Int) -> MArr0 (PrimState m) DIM2 Int -> (DIM2 -> m Int) -> MArr0 (PrimState m) DIM2 Int -> (DIM2 -> m Int) -> m ()
