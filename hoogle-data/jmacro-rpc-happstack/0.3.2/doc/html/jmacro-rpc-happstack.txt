-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Happstack backend for jmacro-rpc
--   
@package jmacro-rpc-happstack
@version 0.3.2


-- | Happstack backend for JMacro-RPC.
--   
--   Example usage:
--   
--   <pre>
--   module Main where
--   import Network.JMacroRPC.Happstack
--   import Happstack.Server
--   import Language.Javascript.JMacro
--   import Control.Concurrent
--   import Network.JMacroRPC.Base
--   import Text.XHtml hiding(dir)
--   import Control.Monad.Trans(lift)
--   
--   jsScript f = script (primHtml f) ! [thetype "text/javascript"]
--   jsScript' = jsScript . show . renderJs
--   
--   testPage :: IO (ServerPartT IO Response)
--   testPage = mkConversationPageNoCulling pageFun (newMVar (1::Int)) jRpcs
--       where pageFun js = return $ toResponse $
--                          (header &lt;&lt; [script ! [src "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"] &lt;&lt; noHtml]) +++
--                          jsScript' js +++
--                          jsScript' ([jmacro|$(\
--                                        {
--                                              var b = $("&lt;button&gt;click me!&lt;/button&gt;");
--                                              $("body").append(b);
--                                              b.click(\ {
--                                                  var c = getCounter();
--                                                  alert ("counter is: " + c);
--                                              });
--                                        });
--                                     |]);
--             jRpcs = [getCounterRPC]
--             getCounterRPC =
--                 toJsonConvRPC "getCounter" $ \s -&gt; (lift $ retRight =&lt;&lt; modifyMVar s (\i -&gt; return (i+1,i)) :: ServerPartT IO (Either String Int))
--   
--   retRight :: a -&gt; IO (Either String a)
--   retRight = return . Right
--   
--   main = simpleHTTP nullConf =&lt;&lt; testPage
--   </pre>
--   
--   Every invocation of this page (including from the same browser) will
--   have a distinct, stateful, counter, stored server-side.
module Network.JMacroRPC.Happstack
serveRpcs :: (MonadIO m, Functor m, Monad m) => (Int -> (ServerPartT m) s) -> [JsonRPC (ServerPartT m) s] -> ServerPartT m Response
serveSimpleRpcs :: (MonadIO m, Functor m, Monad m) => [JsonRPC (ServerPartT m) ()] -> ServerPartT m Response

-- | This general handler allows explicit culling of conversation state.
mkConversationPage :: (Monad m, Functor m, MonadIO m, MonadPlus m) => IO timestamp -> (IntMap (timestamp, s) -> IO (IntMap (timestamp, s))) -> (JStat -> ServerPartT m Response) -> IO s -> [JsonRPC (ServerPartT m) s] -> IO (ServerPartT m Response)

-- | This simple handler allows conversation state to grow without bounds.
mkConversationPageNoCulling :: (Monad m, Functor m, MonadIO m, MonadPlus m) => (JStat -> ServerPartT m Response) -> IO s -> [JsonRPC (ServerPartT m) s] -> IO (ServerPartT m Response)

-- | Render a Panel as a <tt>ServerPartT m Response</tt>.
panelToPage :: (Monad m, Functor m, MonadIO m, MonadPlus m) => Maybe String -> String -> Panel (ServerPartT m) -> ServerPartT m Response
instance (ToJSON b, Monad m, Functor m) => ToJsonRPC (ServerPartT m (Either String b)) (ServerPartT m)
