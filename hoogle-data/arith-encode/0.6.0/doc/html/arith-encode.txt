-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A practical arithmetic encoding (aka Godel numbering) library.
--   
@package arith-encode
@version 0.6.0


-- | Definition of <a>Encoding</a>, and a set of fundamental
--   <a>Encoding</a>s and constructions.
--   
--   This module contains the basic definitions for <a>Encoding</a>s. It
--   defines the <a>Encoding</a> type, the functions for creating an
--   <a>Encoding</a>, and a set of stock constructions.
--   
--   The <a>Encoding</a> type is encapsulated; the functions
--   <a>mkEncoding</a> (and the variants thereof) are used to synthetically
--   construct an encoding from the fundamental operations.
--   
--   The <a>IllegalArgument</a> exception datatype, as well as the
--   fundamental operations are also defined here.
--   
--   In addition to this, a set of basic definitions and constructions are
--   provided. These definitions should be suitable for defining
--   <a>Encoding</a>s for most algebraic datatypes without having to
--   manually write encode/decode implementations.
module Data.ArithEncode.Basic

-- | Type for an encoding. The structure of this type is deliberately
--   hidden from users. Use the <a>mkEncoding</a> functions to construct
--   <a>Encoding</a>s, and the seven functions to use them.
data Encoding ty

-- | Create an encoding from all the necessary components.
mkEncoding :: (ty -> Integer) -> (Integer -> ty) -> Maybe Integer -> (ty -> Bool) -> Encoding ty

-- | Create an infinite-sized encoding. This variant does not need a size.
mkInfEncoding :: (ty -> Integer) -> (Integer -> ty) -> (ty -> Bool) -> Encoding ty

-- | An exception to be thrown if an illegal argument is given to
--   <a>encode</a>, <a>decode</a>.
data IllegalArgument
IllegalArgument :: !String -> IllegalArgument

-- | Encode a <tt>ty</tt> as a positive <a>Integer</a> (ie. a natural
--   number).
--   
--   If the given <tt>ty</tt> is not in the domain of the <a>Encoding</a>
--   (meaning, <a>inDomain</a> returns <a>False</a>), the underlying
--   implementation <i>may</i> throw <a>IllegalArgument</a>. However, this
--   is not <i>strictly</i> required; therefore, do not rely on
--   <a>IllegalArgument</a> being thrown.
encode :: Encoding ty -> ty -> Integer

-- | Decode a <tt>ty</tt> from a positive <a>Integer</a> (ie. a natural
--   number).
--   
--   If the given <a>Integer</a> is out of bounds (ie. it is bigger than
--   <a>size</a>), the underlying implementation <i>may</i> throw
--   <a>IllegalArgument</a>. However, this not <i>strictly</i> required;
--   therefore, do not rely on <a>IllegalArgument</a> being thrown.
decode :: Encoding ty -> Integer -> ty

-- | Get the size of an <a>Encoding</a>, or <a>Nothing</a> if it is
--   infinite.
size :: Encoding ty -> Maybe Integer

-- | Indicate whether or not a value is in the domain of the encoding.
inDomain :: Encoding ty -> ty -> Bool

-- | The identity encoding. Maps every positive <a>Integer</a> to itself.
--   
--   Note: only positive integers are in the domain of this encoding. For
--   all an encoding whose domain is all integers, use <a>integral</a>.
identity :: Encoding Integer

-- | A singleton encoding. Maps a singular value to 0.
singleton :: Eq ty => ty -> Encoding ty

-- | An encoding of <i>all</i> integers.
--   
--   Note: this is <i>not</i> an identity mapping.
integral :: Integral n => Encoding n

-- | Build an encoding from a finite range of <a>Integral</a>s.
--   
--   Both the upper and lower bounds are inclusive. This allows an
--   <a>Encoding</a> to be created for bounded integer datatypes, such as
--   <tt>Int8</tt>.
interval :: Integral n => n -> n -> Encoding n

-- | Build an encoding from a list of items with a <a>Hashable</a>
--   instance.
fromHashableList :: (Hashable ty, Ord ty) => [ty] -> Encoding ty

-- | Build an encoding from a list of items with an <a>Ord</a> instance.
fromOrdList :: Ord ty => [ty] -> Encoding ty

-- | Wrap an encoding using a pair of functions. These functions must also
--   define an isomorphism.
wrap :: (a -> Maybe b) -> (b -> Maybe a) -> Encoding b -> Encoding a

-- | Generate an encoding for <tt>Maybe ty</tt> from an inner encoding for
--   <tt>ty</tt>.
optional :: Encoding ty -> Encoding (Maybe ty)

-- | The dual of <tt>optional</tt>. This construction assumes that
--   <tt>Nothing</tt> maps to <tt>0</tt>, and removes it from the input
--   domain.
--   
--   Using this construction on encodings for <tt>Maybe ty</tt> which are
--   not produced by <tt>optional</tt> may have unexpected results.
mandatory :: Encoding (Maybe ty) -> Encoding ty

-- | Removes the mapping to <tt>0</tt> (ie. the first mapping). This has
--   the same effect as <tt>exclude [x]</tt>, where <tt>x</tt> is the value
--   that maps to <tt>0</tt>. It is also similar to <tt>mandatory</tt>,
--   except that it does not change the base type.
nonzero :: Encoding ty -> Encoding ty

-- | Removes the mapping to the items in the list. The resulting
--   <tt>encode</tt>, <tt>decode</tt>, and <tt>highestIndex</tt> are
--   O(<tt>length excludes</tt>), so this should only be used with a very
--   short excludes list.
exclude :: [ty] -> Encoding ty -> Encoding ty

-- | Combine two encodings into a single encoding that returns an
--   <tt>Either</tt> of the two types.
either :: Encoding ty1 -> Encoding ty2 -> Encoding (Either ty1 ty2)

-- | Combine a set of encodings with the result type into a single encoding
--   which represents the disjoint union of the components.
union :: [Encoding ty] -> Encoding ty

-- | Take encodings for two datatypes A and B, and build an encoding for a
--   pair (A, B).
pair :: Encoding ty1 -> Encoding ty2 -> Encoding (ty1, ty2)

-- | Construct an encoding for a 3-tuple from the encodings for the three
--   components. This is actually just a wrapper around <tt>pair</tt>.
triple :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding (ty1, ty2, ty3)

-- | Construct an encoding for a 4-tuple from the encodings for the four
--   components. This is actually just a wrapper around <tt>pair</tt>.
quad :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding (ty1, ty2, ty3, ty4)

-- | Construct an encoding for a 5-tuple from the encodings for the five
--   components. This is actually just a wrapper around <tt>pair</tt>.
quint :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding (ty1, ty2, ty3, ty4, ty5)

-- | Construct an encoding for a 6-tuple from the encodings for the six
--   components. This is actually just a wrapper around <tt>pair</tt>.
sextet :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding ty6 -> Encoding (ty1, ty2, ty3, ty4, ty5, ty6)

-- | Construct an encoding for a 7-tuple from the encodings for the seven
--   components. This is actually just a wrapper around <tt>pair</tt>.
septet :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding ty6 -> Encoding ty7 -> Encoding (ty1, ty2, ty3, ty4, ty5, ty6, ty7)

-- | Construct an encoding for an 8-tuple from the encodings for the eight
--   components. This is actually just a wrapper around <tt>pair</tt>.
octet :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding ty6 -> Encoding ty7 -> Encoding ty8 -> Encoding (ty1, ty2, ty3, ty4, ty5, ty6, ty7, ty8)

-- | Construct an encoding for a 9-tuple from the encodings for the nine
--   components. This is actually just a wrapper around <tt>pair</tt>.
nonet :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding ty6 -> Encoding ty7 -> Encoding ty8 -> Encoding ty9 -> Encoding (ty1, ty2, ty3, ty4, ty5, ty6, ty7, ty8, ty9)

-- | Construct an encoding for a 10-tuple from the encodings for the ten
--   components. This is actually just a wrapper around <tt>pair</tt>.
dectet :: Encoding ty1 -> Encoding ty2 -> Encoding ty3 -> Encoding ty4 -> Encoding ty5 -> Encoding ty6 -> Encoding ty7 -> Encoding ty8 -> Encoding ty9 -> Encoding ty10 -> Encoding (ty1, ty2, ty3, ty4, ty5, ty6, ty7, ty8, ty9, ty10)

-- | Take an <tt>Encoding</tt> for elements and a length and produce an
--   <tt>Encoding</tt> for lists of exactly that length.
--   
--   This differs from <a>boundedSeq</a> in that the resulting list is
--   <i>exactly</i> the given length, as opposed to upper-bounded by it.
power :: Integer -> Encoding ty -> Encoding [ty]

-- | Build an encoding for <i>finite</i> sets of values of a given datatype
--   from an encoding for that datatype.
--   
--   Note: this encoding and its variants can produce very large numbers
--   for a very small set.
set :: Ord ty => Encoding ty -> Encoding (Set ty)

-- | Build an encoding for <i>finite</i> sets of values of a given datatype
--   from an encoding for that datatype. Similar to <tt>set</tt>, but uses
--   <tt>HashSet</tt> instead
hashSet :: (Hashable ty, Ord ty) => Encoding ty -> Encoding (HashSet ty)

-- | Construct an encoding for <i>finite</i> sequences of a type from an
--   encoding for values of that type.
--   
--   Note: This encoding can produce very large numbers for short
--   sequences.
seq :: Encoding ty -> Encoding [ty]

-- | Construct an encoding for sequences whose length is bounded by a given
--   value from an encoding for elements of the sequence.
boundedSeq :: Integer -> Encoding ty -> Encoding [ty]

-- | Take a function which takes a self-reference and produces a recursive
--   encoding, and produce the fixed-point encoding.
recursive :: (Encoding ty -> Encoding ty) -> Encoding ty

-- | A recursive construction for two mutually-recursive constructions.
recursive2 :: ((Encoding ty1, Encoding ty2) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2) -> Encoding ty2) -> (Encoding ty1, Encoding ty2)

-- | A recursive construction for three mutually-recursive constructions.
recursive3 :: ((Encoding ty1, Encoding ty2, Encoding ty3) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3) -> Encoding ty3) -> (Encoding ty1, Encoding ty2, Encoding ty3)

-- | A recursive construction for four mutually-recursive constructions.
recursive4 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4) -> Encoding ty4) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4)

-- | A recursive construction for five mutually-recursive constructions.
recursive5 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5) -> Encoding ty5) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5)

-- | A recursive construction for six mutually-recursive constructions.
recursive6 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty5) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6) -> Encoding ty6) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6)

-- | A recursive construction for seven mutually-recursive constructions.
recursive7 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty5) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty6) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7) -> Encoding ty7) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7)

-- | A recursive construction for eight mutually-recursive constructions.
recursive8 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty5) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty6) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty7) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8) -> Encoding ty8) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8)

-- | A recursive construction for nine mutually-recursive constructions.
recursive9 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty5) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty6) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty7) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty8) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9) -> Encoding ty9) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9)

-- | A recursive construction for ten mutually-recursive constructions.
recursive10 :: ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty1) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty2) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty3) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty4) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty5) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty6) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty7) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty8) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty9) -> ((Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10) -> Encoding ty10) -> (Encoding ty1, Encoding ty2, Encoding ty3, Encoding ty4, Encoding ty5, Encoding ty6, Encoding ty7, Encoding ty8, Encoding ty9, Encoding ty10)
instance Typeable IllegalArgument
instance (Show key, Show val) => Show (BinTree key val)
instance Exception IllegalArgument
instance Show IllegalArgument


-- | Derived encodings for standard datatypes.
--   
--   This module contains a number of useful constructions which can be
--   defined using the constructions from <a>Basic</a>.
module Data.ArithEncode.Util

-- | An encoding that produces <tt>()</tt>.
unit :: Encoding ()

-- | An empty encoding, which contains no mappings.
void :: Encoding b

-- | Build an encoding that produces non-empty sequences from an encoding
--   for the elements of the sequence.
nonEmptySeq :: Encoding ty -> Encoding [ty]

-- | Build an encoding for lists of <tt>Maybe</tt>s, where the last element
--   of the list is always guaranteed not to be <tt>Nothing</tt>. This is
--   useful for building function encodings.
nonEmptyOptionSeq :: Encoding ty -> Encoding [Maybe ty]

-- | Build an encoding that produces non-empty sets from an encoding for
--   the elements of the set.
nonEmptySet :: Ord ty => Encoding ty -> Encoding (Set ty)

-- | Build an encoding that produces non-empty hash sets from an encoding
--   for the elements of the set.
nonEmptyHashSet :: (Hashable ty, Ord ty) => Encoding ty -> Encoding (HashSet ty)

-- | Build an encoding that produces a (finite partial) function from one
--   type to another. This function is represented using a <tt>Map</tt>.
function :: Ord keyty => Encoding keyty -> Encoding valty -> Encoding (Map keyty valty)

-- | Build an encoding that produces a (finite partial) function from one
--   type to another. This function is represented using a
--   <tt>HashMap</tt>.
functionHashable :: (Ord keyty, Hashable keyty) => Encoding keyty -> Encoding valty -> Encoding (HashMap keyty valty)

-- | Build an encoding that produces relations between two types. These
--   relations are represented as <tt>Map</tt>s from the first type to
--   <tt>Set</tt>s of the second.
relation :: (Ord keyty, Ord valty) => Encoding keyty -> Encoding valty -> Encoding (Map keyty (Set valty))

-- | Build an encoding that produces relations between two types. These
--   relations are represented as <tt>HashMap</tt>s from the first type to
--   <tt>HashSet</tt>s of the second.
relationHashable :: (Hashable keyty, Ord keyty, Hashable valty, Ord valty) => Encoding keyty -> Encoding valty -> Encoding (HashMap keyty (HashSet valty))

-- | Build an encoding that produces trees from an encoding for the node
--   labels.
tree :: Encoding ty -> Encoding (Tree ty)


-- | ArithEncode is a library that provides tools for defining arithmetic
--   encodings for arbitrary datatypes. The library is designed so that
--   multiple encoding schemes can be defined for a given datatype, and a
--   given encoding need not encode all possible instances of the datatype.
--   
--   An <a>Encoding</a> is an object which is passed as the first argument
--   to seven different functions. The primary function of an
--   <a>Encoding</a> is manifest in the <a>encode</a> and <a>decode</a>
--   functions, which define an isomorphism between the datatype and the
--   natural numbers (or a bounded set thereof), represented using
--   <tt>Integer</tt>s. The <a>encode</a> and <a>decode</a> functions have
--   the following properties:
--   
--   <ul>
--   <li><tt>decode enc (encode enc v) == v</tt> for all values <tt>v</tt>
--   in the domain</li>
--   <li><tt>encode enc v == encode enc w</tt> only if <tt>w == v</tt></li>
--   <li><tt>decode enc n == decode enc m</tt> only if <tt>n == m</tt></li>
--   </ul>
--   
--   The <a>inDomain</a> function indicates whether or not a given value is
--   in the domain of the encoding. Passing a value <tt>v</tt> where
--   <tt>inDomain enc v == False</tt> into any other function <i>may</i>
--   result in an <tt>IllegalArgument</tt> exception. (For performance
--   reasons, encodings are not <i>strictly</i> required to throw
--   <tt>IllegalArgument</tt>, but the result should not be considered
--   valid if they do not throw the exception).
--   
--   This library provides a large collection of combinators for
--   constructing more complex <a>Encoding</a>s out of simpler ones. The
--   provided combinators should be appropriate for constructing
--   <a>Encoding</a>s for most datatypes.
--   
--   As an example, the following definition creates an <a>Encoding</a> for
--   the <tt>Tree Integer</tt> type:
--   
--   <pre>
--   tree :: Encoding (Tree Integer)
--   tree =
--     let
--       ...
--       nodeEncoding nodeenc =
--         wrap unmakeNode makeNode (pair interval (seq nodeenc))
--     in
--       recursive nodeEncoding
--   </pre>
--   
--   In this example, the <tt>makeNode</tt> and <tt>unmakeNode</tt>
--   functios are simply "glue"; their definitions are
--   
--   <pre>
--   makeNode (label, children) =
--     Node { rootLabel = label, subForest = children }
--   
--   unmakeNode Node { rootLabel = label, subForest = children } =
--     Just (label, children)
--   </pre>
--   
--   The resulting <a>Encoding</a> maps any <tt>Tree Integer</tt> to a
--   unique <tt>Integer</tt> value.
--   
--   <a>Encoding</a>s have a number of practical uses. First, all
--   <a>Encoding</a>s in this library satisfy a <i>completeness</i>
--   property, which guarantees that they map each value to a finite
--   natural number (or in the case of constructions on <a>Encoding</a>s,
--   they preserve completeness). Hence, they can be used as an enumeration
--   procedure for their underlying datatype.
--   
--   Second, as <a>Encoding</a>s define an isomorphism to the natural
--   numbers, they provide an efficient binary encode/decode procedure in
--   theory. In practice, the techniques used to guarantee the completeness
--   property may result in long encodings of some types (particularly
--   sequences). Also, knowledge of the distribution of the domain is
--   necessary in order to achieve the most succinct possible encoding.
module Data.ArithEncode
