-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Encode/Decode values to/from CBOR
--   
--   Provides a simple type to represent CBOR values as well as instances
--   of the Get and Put classes from the binary package to encode/decode
--   those values to/from ByteStrings. <i>N.B.</i> Alpha, interface subject
--   to change!
@package CBOR
@version 0.1.0.1


-- | Provides functions to serialize CBOR encoded values to/from
--   ByteStrings.
--   
--   Warning, this package is very alpha quality right now. I've attempted
--   to implement a useful subset of the CBOR standard, but the interface
--   is still being refined and subject to change. Do not use this for
--   anything important!
module Data.CBOR

-- | Data type for CBOR values
data CBOR
CBOR_UInt :: Integer -> CBOR
CBOR_SInt :: Integer -> CBOR
CBOR_BS :: ByteString -> CBOR

-- | TextString. This SHOULD be a UTF8 string if the spec is being
--   followed.
CBOR_TS :: ByteString -> CBOR
CBOR_Array :: [CBOR] -> CBOR
CBOR_Map :: [(CBOR, CBOR)] -> CBOR
CBOR_Tag :: Integer -> CBOR -> CBOR

-- | N.B. Currently stored as an opaque value because I can't be bothered
--   to implement my own half width float type.
CBOR_HalfFloat :: HalfFloat -> CBOR
CBOR_Float :: Float -> CBOR
CBOR_Double :: Double -> CBOR
CBOR_NULL :: CBOR

-- | Undefined as per the CBOR specification, a value of this type will
--   usually represent a serializatoin error.
CBOR_Undefined :: CBOR

-- | Reserved, you probably shouldn't see any of these.
CBOR_Reserved :: Int -> CBOR

-- | Unassigned
CBOR_Unassigned :: Int -> CBOR
CBOR_True :: CBOR
CBOR_False :: CBOR
CBOR_Byte :: Word8 -> CBOR

-- | Stop marker for indefinite encoding scheme
CBOR_Stop :: CBOR
newtype HalfFloat

-- | Opaque value, actual implementation TODO
HF :: Word16 -> HalfFloat
instance Eq HalfFloat
instance Ord HalfFloat
instance Show CBOR
instance Eq CBOR
instance Show HalfFloat

module Data.Binary.CBOR

-- | Reads CBOR encoded data
--   
--   <pre>
--   &gt;&gt;&gt; let x = LBS.pack [26,111,122,133,144]
--   
--   &gt;&gt;&gt; runGet getCBOR x
--   CBOR_UInt 1870300560
--   </pre>
getCBOR :: Get CBOR

-- | Writes CBOR encoded data
--   
--   <pre>
--   &gt;&gt;&gt; let x = CBOR_Array [CBOR_UInt 42, CBOR_Float 3.14]
--   
--   &gt;&gt;&gt; LBS.unpack $ runPut (putCBOR x)
--   [130,24,42,250,64,72,245,195]
--   </pre>
putCBOR :: CBOR -> Put
