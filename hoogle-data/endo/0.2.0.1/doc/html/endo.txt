-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Endomorphism utilities.
--   
@package endo
@version 0.2.0.1


-- | Generic folding for various endomorphism representations.
module Data.Monoid.Endo.Fold

-- | Fold all variously represented endomorphisms in to one endomorphism.
--   
--   Order in which endomorphisms are folded is preserved:
--   
--   <pre>
--   &gt;&gt;&gt; foldEndo (Endo (1:)) [(2:), (3:)] `appEndo` []
--   [1,2,3]
--   </pre>
--   
--   For numbers it would look like:
--   
--   <pre>
--   &gt;&gt;&gt; foldEndo (Endo (+1)) [(+2), (*3)] `appEndo` 1
--   6
--   </pre>
--   
--   Above can be seen as:
--   
--   <pre>
--   &gt;&gt;&gt; (+1) . (+2) . (*3) $ 1
--   6
--   </pre>
foldEndo :: FoldEndoArgs args => args

-- | Same as <a>foldEndo</a>, but folds endomorphisms in reverse order.
--   
--   Following are the same examples as for <a>foldEndo</a> function.
--   Please, note the differences in results.
--   
--   Order in which endomorphisms are folded is reversed:
--   
--   <pre>
--   &gt;&gt;&gt; dualFoldEndo (Endo (1:)) [(2:), (3:)] `appEndo` []
--   [2,3,1]
--   </pre>
--   
--   For numbers it would look like:
--   
--   <pre>
--   &gt;&gt;&gt; dualFoldEndo (Endo (+1)) [(+2), (*3)] `appEndo` 1
--   12
--   </pre>
--   
--   Above can be seen as:
--   
--   <pre>
--   &gt;&gt;&gt; (*3) . (+2) . (+1) $ 1
--   12
--   </pre>
dualFoldEndo :: FoldEndoArgs args => args

-- | Class of arguments for <a>foldEndo</a> and its dual
--   <a>dualFoldEndo</a> functions.
--   
--   Note that results are instances of this (<a>FoldEndoArgs</a>) class
--   and endomorphism representations are instances of <a>AnEndo</a> type
--   class.
class FoldEndoArgs a where type family ResultOperatesOn a type family Result a
foldEndoArgs :: FoldEndoArgs a => Endo (ResultOperatesOn a) -> a
dualFoldEndoArgs :: FoldEndoArgs a => Dual (Endo (ResultOperatesOn a)) -> a

-- | Class that represents various endomorphism representation. In other
--   words anything that encodes <tt>a -&gt; a</tt> can be instance of this
--   class.
--   
--   Here are some important instances with not so obvious definitions.
--   
--   <pre>
--   instance <a>AnEndo</a> (<a>Proxy</a> a) where
--       type <a>EndoOperatesOn</a> (<a>Proxy</a> a) = a
--   
--       <a>anEndo</a>    _ = <a>mempty</a> -- = Endo <a>id</a>
--       <a>aDualEndo</a> _ = <a>mempty</a>
--   </pre>
--   
--   It got quite common to use <a>Proxy</a> data type as an explicit way
--   to pass types around. Above instance allows you to restrict type of
--   result of endomorphism folding, to some extent.
--   
--   <pre>
--   instance <a>AnEndo</a> a =&gt; <a>AnEndo</a> (Maybe a) where
--       type <a>EndoOperatesOn</a> (Maybe a) = <a>EndoOperatesOn</a> a
--   
--       <a>anEndo</a> Nothing  = <a>mempty</a> -- = Endo <a>id</a>
--       <a>anEndo</a> (Just e) = <a>anEndo</a> e
--   
--       -- Definition of <a>aDualEndo</a> is analogous.
--   </pre>
--   
--   Instance for <tt>Maybe</tt> lets us conditionally inject endomorphism
--   in to a folding chain.
class AnEndo a where type family EndoOperatesOn a anEndo = getDual . aDualEndo aDualEndo = Dual . anEndo
anEndo :: AnEndo a => a -> Endo (EndoOperatesOn a)
aDualEndo :: AnEndo a => a -> Dual (Endo (EndoOperatesOn a))

-- | Wrapper for <a>Foldable</a> instances.
--   
--   This allows using <a>foldEndo</a> and <a>dualFoldEndo</a> for any
--   <a>Foldable</a> instance without the need for
--   <tt>OverlappingInstances</tt> language extension.
newtype WrappedFoldable f a
WrapFoldable :: f a -> WrappedFoldable f a
getFoldable :: WrappedFoldable f a -> f a

-- | Variant of function <tt>(<a>$</a>) :: (a -&gt; b) -&gt; a -&gt;
--   b</tt>, from <a>Data.Function</a> module, but with fixity as
--   <tt>(<a>&amp;</a>) :: a -&gt; (a -&gt; b) -&gt; b</tt> function from
--   <a>Data.Function</a> module (available in base since version 4.8.0.0).
(&$) :: (a -> b) -> a -> b

-- | Variant of function <tt>(<a>&lt;$&gt;</a>) :: <a>Functor</a> f =&gt;
--   (a -&gt; b) -&gt; a -&gt; b</tt> from <a>Data.Functor</a> module, but
--   with fixity as <a>&amp;$</a> function.
(<&$>) :: Functor f => (a -> b) -> f a -> f b

-- | Use <a>Endo</a> (possibly result of <a>foldEndo</a>) and use it to
--   create value of different type.
--   
--   Examples:
--   
--   <pre>
--   <a>embedEndoWith</a> <a>tell</a>
--       :: (Monad m, <a>AnEndo</a> e, w ~ <a>EndoOperatesOn</a> e)
--       =&gt; e
--       -&gt; <a>WriterT</a> (<a>Endo</a> w) m ()
--   
--   <a>embedEndoWith</a> <a>modify</a>
--       :: (Monad m, <a>AnEndo</a> e, s ~ <a>EndoOperatesOn</a> e)
--       =&gt; e
--       -&gt; <a>StateT</a> s m ()
--   </pre>
--   
--   See also <a>embedDualEndoWith</a>.
embedEndoWith :: (AnEndo e, EndoOperatesOn e ~ a) => (Endo a -> b) -> e -> b

-- | Dual to <a>embedEndoWith</a>, which uses <a>aDualEndo</a> instead of
--   <a>anEndo</a>.
embedDualEndoWith :: (AnEndo e, EndoOperatesOn e ~ a) => (Dual (Endo a) -> b) -> e -> b
instance Typeable WrappedFoldable
instance Generic (WrappedFoldable f a)
instance Read (f a) => Read (WrappedFoldable f a)
instance Show (f a) => Show (WrappedFoldable f a)
instance (Data (f a), Typeable f, Typeable a) => Data (WrappedFoldable f a)
instance Datatype D1WrappedFoldable
instance Constructor C1_0WrappedFoldable
instance Selector S1_0_0WrappedFoldable
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, AnEndo a6, AnEndo a7, AnEndo a8, AnEndo a9, AnEndo a10, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5, EndoOperatesOn a1 ~ EndoOperatesOn a6, EndoOperatesOn a1 ~ EndoOperatesOn a7, EndoOperatesOn a1 ~ EndoOperatesOn a8, EndoOperatesOn a1 ~ EndoOperatesOn a9, EndoOperatesOn a1 ~ EndoOperatesOn a10) => AnEndo (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, AnEndo a6, AnEndo a7, AnEndo a8, AnEndo a9, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5, EndoOperatesOn a1 ~ EndoOperatesOn a6, EndoOperatesOn a1 ~ EndoOperatesOn a7, EndoOperatesOn a1 ~ EndoOperatesOn a8, EndoOperatesOn a1 ~ EndoOperatesOn a9) => AnEndo (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, AnEndo a6, AnEndo a7, AnEndo a8, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5, EndoOperatesOn a1 ~ EndoOperatesOn a6, EndoOperatesOn a1 ~ EndoOperatesOn a7, EndoOperatesOn a1 ~ EndoOperatesOn a8) => AnEndo (a1, a2, a3, a4, a5, a6, a7, a8)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, AnEndo a6, AnEndo a7, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5, EndoOperatesOn a1 ~ EndoOperatesOn a6, EndoOperatesOn a1 ~ EndoOperatesOn a7) => AnEndo (a1, a2, a3, a4, a5, a6, a7)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, AnEndo a6, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5, EndoOperatesOn a1 ~ EndoOperatesOn a6) => AnEndo (a1, a2, a3, a4, a5, a6)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, AnEndo a5, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4, EndoOperatesOn a1 ~ EndoOperatesOn a5) => AnEndo (a1, a2, a3, a4, a5)
instance (AnEndo a1, AnEndo a2, AnEndo a3, AnEndo a4, EndoOperatesOn a1 ~ EndoOperatesOn a2, EndoOperatesOn a1 ~ EndoOperatesOn a3, EndoOperatesOn a1 ~ EndoOperatesOn a4) => AnEndo (a1, a2, a3, a4)
instance (AnEndo a, AnEndo b, AnEndo c, EndoOperatesOn a ~ EndoOperatesOn b, EndoOperatesOn a ~ EndoOperatesOn c) => AnEndo (a, b, c)
instance (AnEndo a, AnEndo b, EndoOperatesOn a ~ EndoOperatesOn b) => AnEndo (a, b)
instance (Foldable f, AnEndo a) => AnEndo (Reverse f a)
instance AnEndo a => AnEndo [a]
instance (Foldable f, AnEndo a) => AnEndo (WrappedFoldable f a)
instance AnEndo (Proxy a)
instance AnEndo a => AnEndo (Maybe a)
instance AnEndo (a -> a)
instance AnEndo (Endo a)
instance (Applicative f, FoldEndoArgs r, Monoid w) => FoldEndoArgs (WriterT w f r)
instance (Applicative f, FoldEndoArgs r, Monoid w) => FoldEndoArgs (WriterT w f r)
instance (Monad m, FoldEndoArgs r) => FoldEndoArgs (StateT s m r)
instance (Monad m, FoldEndoArgs r) => FoldEndoArgs (StateT s m r)
instance (Monad m, Functor m, Monoid w, FoldEndoArgs r) => FoldEndoArgs (RWST r' w s m r)
instance (Monad m, Functor m, Monoid w, FoldEndoArgs r) => FoldEndoArgs (RWST r' w s m r)
instance (Applicative f, FoldEndoArgs r) => FoldEndoArgs (ReaderT r' f r)
instance (Monad m, Functor m, FoldEndoArgs r) => FoldEndoArgs (MaybeT m r)
instance (Applicative f, FoldEndoArgs r) => FoldEndoArgs (ListT f r)
instance (Applicative f, FoldEndoArgs r) => FoldEndoArgs (IdentityT f r)
instance (Applicative f, Applicative g, FoldEndoArgs r) => FoldEndoArgs (Product f g r)
instance (Applicative f, Applicative g, FoldEndoArgs r) => FoldEndoArgs (Compose f g r)
instance FoldEndoArgs r => FoldEndoArgs (Maybe r)
instance FoldEndoArgs r => FoldEndoArgs (IO r)
instance FoldEndoArgs r => FoldEndoArgs (Identity r)
instance FoldEndoArgs r => FoldEndoArgs (Either e r)
instance (Monoid c, FoldEndoArgs r) => FoldEndoArgs (Const c r)
instance FoldEndoArgs (Endo a)
instance (AnEndo a, FoldEndoArgs r, EndoOperatesOn a ~ ResultOperatesOn r) => FoldEndoArgs (a -> r)


-- | Utilities for <a>Endo</a> data type from <a>Data.Monoid</a> module.
module Data.Monoid.Endo

-- | Type synonym for endomorphsm; it can be used to simplify type
--   signatures.
type E a = a -> a

-- | The monoid of endomorphisms under composition.
newtype Endo a :: * -> *
Endo :: (a -> a) -> Endo a
appEndo :: Endo a -> a -> a

-- | Flipped version of <a>appEndo</a>.
runEndo :: a -> Endo a -> a

-- | Transform function wrapped in <a>Endo</a>.
mapEndo :: (E a -> E b) -> Endo a -> Endo b

-- | Variation of <a>mapEndo</a> for functions with arity two.
mapEndo2 :: (E a -> E b -> E c) -> Endo a -> Endo b -> Endo c

-- | Apply <a>fmap</a> to function wrapped in <a>Endo</a>. It's a short
--   hand for <tt><a>mapEndo</a> <a>fmap</a></tt>.
liftEndo :: Functor f => Endo a -> Endo (f a)

-- | Lens for <a>Endo</a>. In terms of <i>lens</i> package it would have
--   type:
--   
--   <pre>
--   <a>endo</a> :: Lens (<a>Endo</a> a) (<a>Endo</a> b) (<a>E</a> a) (<a>E</a> b)
--   </pre>
--   
--   For details see <a>lens package</a>.
endo :: Functor f => (E a -> f (E b)) -> Endo a -> f (Endo b)
