-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Third party extensions for xmonad
--   
--   This is a modified version of xmonad-contrib used by Bluetile.
@package xmonad-contrib-bluetilebranch
@version 0.9.1.4


-- | Internal utility functions for storing Strings with the root window.
--   
--   Used for global state like IORefs with string keys, but more latency,
--   persistent between xmonad restarts.
module XMonad.Util.StringProp
type StringProp = String

-- | Get the name of a string property and returns it as a <a>Maybe</a>.
getStringProp :: (MonadIO m) => Display -> StringProp -> m (Maybe [Char])

-- | Set the value of a string property.
setStringProp :: (MonadIO m) => Display -> StringProp -> [Char] -> m ()

-- | Given a property name, returns its contents as a list. It uses the
--   empty list as default value.
getStringListProp :: (MonadIO m) => Display -> StringProp -> m [String]

-- | Given a property name and a list, sets the value of this property with
--   the list given as argument.
setStringListProp :: (MonadIO m) => Display -> StringProp -> [String] -> m ()


-- | Implements a <tt>--replace</tt> behavior outside of core.
module XMonad.Util.Replace

-- | <tt>replace</tt> must be run before xmonad starts to signals to
--   compliant window managers that they must exit and let xmonad take
--   over.
replace :: IO ()


-- | Customized key bindings.
--   
--   (See also <a>XMonad.Util.EZConfig</a> in xmonad-contrib.)
module XMonad.Util.CustomKeys

-- | Customize <tt>XMonad.Config.defaultConfig</tt> -- delete needless
--   shortcuts and insert those you will use.
customKeys :: (XConfig Layout -> [(KeyMask, KeySym)]) -> (XConfig Layout -> [((KeyMask, KeySym), X ())]) -> XConfig Layout -> Map (KeyMask, KeySym) (X ())

-- | General variant of <a>customKeys</a>: customize key bindings of
--   third-party configuration.
customKeysFrom :: XConfig l -> (XConfig Layout -> [(KeyMask, KeySym)]) -> (XConfig Layout -> [((KeyMask, KeySym), X ())]) -> XConfig Layout -> Map (KeyMask, KeySym) (X ())


-- | A layout similar to tall but with three columns. With 2560x1600 pixels
--   this layout can be used for a huge main window and up to six
--   reasonable sized slave windows.
module XMonad.Layout.ThreeColumns

-- | Arguments are nmaster, delta, fraction
data ThreeCol a
ThreeColMid :: !Int -> !Rational -> !Rational -> ThreeCol a
threeColNMaster :: ThreeCol a -> !Int
threeColDelta :: ThreeCol a -> !Rational
threeColFrac :: ThreeCol a -> !Rational
ThreeCol :: !Int -> !Rational -> !Rational -> ThreeCol a
threeColNMaster :: ThreeCol a -> !Int
threeColDelta :: ThreeCol a -> !Rational
threeColFrac :: ThreeCol a -> !Rational
instance Show (ThreeCol a)
instance Read (ThreeCol a)
instance LayoutClass ThreeCol a


-- | A stacking layout, like dishes but with the ability to resize master
--   pane. Mostly useful on small screens.
module XMonad.Layout.StackTile
data StackTile a
StackTile :: !Int -> !Rational -> !Rational -> StackTile a
instance Show (StackTile a)
instance Read (StackTile a)
instance LayoutClass StackTile a


-- | A spiral tiling layout.
module XMonad.Layout.Spiral

-- | A spiral layout. The parameter controls the size ratio between
--   successive windows in the spiral. Sensible values range from 0 up to
--   the aspect ratio of your monitor (often 4/3).
--   
--   By default, the spiral is counterclockwise, starting to the east. See
--   also <a>spiralWithDir</a>.
spiral :: Rational -> SpiralWithDir a

-- | Create a spiral layout, specifying the starting cardinal direction,
--   the spiral direction (clockwise or counterclockwise), and the size
--   ratio.
spiralWithDir :: Direction -> Rotation -> Rational -> SpiralWithDir a
data Rotation
CW :: Rotation
CCW :: Rotation
data Direction
East :: Direction
South :: Direction
West :: Direction
North :: Direction
instance Read (SpiralWithDir a)
instance Show (SpiralWithDir a)
instance Eq Direction
instance Enum Direction
instance Read Direction
instance Show Direction
instance Read Rotation
instance Show Rotation
instance LayoutClass SpiralWithDir a


-- | A very simple layout. The simplest, afaik.
module XMonad.Layout.Simplest
data Simplest a
Simplest :: Simplest a
instance Show (Simplest a)
instance Read (Simplest a)
instance LayoutClass Simplest a


-- | This is a completely pointless layout which acts like Microsoft's Flip
--   3D
module XMonad.Layout.Roledex
data Roledex a
Roledex :: Roledex a
instance Show (Roledex a)
instance Read (Roledex a)
instance LayoutClass Roledex Window


-- | More useful tiled layout that allows you to change a width/height of
--   window.
module XMonad.Layout.ResizableTile
data ResizableTall a
ResizableTall :: Int -> Rational -> Rational -> [Rational] -> ResizableTall a

-- | number of master windows
_nmaster :: ResizableTall a -> Int

-- | change when resizing by <a>Shrink</a>, <a>Expand</a>,
--   <a>MirrorShrink</a>, <a>MirrorExpand</a>
_delta :: ResizableTall a -> Rational

-- | width of master
_frac :: ResizableTall a -> Rational

-- | fraction to multiply the window height that would be given when
--   divided equally.
--   
--   slave windows are assigned their modified heights in order, from top
--   to bottom
--   
--   unspecified values are replaced by 1
_slaves :: ResizableTall a -> [Rational]
data MirrorResize
MirrorShrink :: MirrorResize
MirrorExpand :: MirrorResize
instance Typeable MirrorResize
instance Show (ResizableTall a)
instance Read (ResizableTall a)
instance LayoutClass ResizableTall a
instance Message MirrorResize


-- | Provides layout named OneBig. It places one (master) window at top
--   left corner of screen, and other (slave) windows at top
module XMonad.Layout.OneBig

-- | Data type for layout
data OneBig a
OneBig :: Float -> Float -> OneBig a
instance Read (OneBig a)
instance Show (OneBig a)
instance LayoutClass OneBig a


-- | Dynamically apply and unapply transformers to your window layout. This
--   can be used to rotate your window layout by 90 degrees, or to make the
--   currently focused window occupy the whole screen ("zoom in") then undo
--   the transformation ("zoom out").
module XMonad.Layout.MultiToggle

-- | A class to identify custom transformers (and look up transforming
--   functions by type).
class (Eq t, Typeable t) => Transformer t a | t -> a
transform :: (Transformer t a, LayoutClass l a) => t -> l a -> (forall l'. (LayoutClass l' a) => l' a -> (l' a -> l a) -> b) -> b

-- | Toggle the specified layout transformer.
data Toggle a
Toggle :: t -> Toggle a

-- | Prepend an element to a heterogeneous list. Used to build transformer
--   tables for <a>mkToggle</a>.
(??) :: (HList b w) => a -> b -> HCons a b

-- | Marks the end of a transformer list.
data EOT
EOT :: EOT

-- | Construct a singleton transformer table.
single :: a -> HCons a EOT

-- | Construct a <tt>MultiToggle</tt> layout from a transformer table and a
--   base layout.
mkToggle :: (LayoutClass l a) => ts -> l a -> MultiToggle ts l a

-- | Construct a <tt>MultiToggle</tt> layout from a single transformer and
--   a base layout.
mkToggle1 :: (LayoutClass l a) => t -> l a -> MultiToggle (HCons t EOT) l a
instance Typeable1 Toggle
instance (Read a, Read b) => Read (HCons a b)
instance (Show a, Show b) => Show (HCons a b)
instance Read EOT
instance Show EOT
instance (Read ts, Read (l a)) => Read (MultiToggleS ts l a)
instance (Show ts, Show (l a)) => Show (MultiToggleS ts l a)
instance (Typeable a, Show ts, HList ts a, LayoutClass l a) => LayoutClass (MultiToggle ts l) a
instance (Transformer a w, HList b w) => HList (HCons a b) w
instance HList EOT w
instance (Show ts, Show (l a), LayoutClass l a) => Show (MultiToggle ts l a)
instance (LayoutClass l a, Read (l a), HList ts a, Read ts) => Read (MultiToggle ts l a)
instance (Typeable a) => Message (Toggle a)


-- | This layout tiles windows in a growing number of columns. The number
--   of windows in each column can be controlled by messages.
module XMonad.Layout.MultiColumns

-- | Layout constructor.
multiCol :: [Int] -> Int -> Rational -> Rational -> MultiCol a
instance Show (MultiCol a)
instance Read (MultiCol a)
instance Eq (MultiCol a)
instance LayoutClass MultiCol a


-- | A layout which gives each window a specified amount of screen space
--   relative to the others. Compared to the <tt>Mosaic</tt> layout, this
--   one divides the space in a more balanced way.
module XMonad.Layout.MosaicAlt
data MosaicAlt a
MosaicAlt :: Params -> MosaicAlt a
shrinkWindowAlt :: Window -> HandleWindowAlt
expandWindowAlt :: Window -> HandleWindowAlt
tallWindowAlt :: Window -> HandleWindowAlt
wideWindowAlt :: Window -> HandleWindowAlt
resetAlt :: HandleWindowAlt
instance Typeable HandleWindowAlt
instance Show (MosaicAlt a)
instance Read (MosaicAlt a)
instance Show Param
instance Read Param
instance Eq HandleWindowAlt
instance LayoutClass MosaicAlt Window
instance Message HandleWindowAlt


-- | Based on MosaicAlt, but aspect ratio messages always change the aspect
--   ratios, and rearranging the window stack changes the window sizes.
module XMonad.Layout.Mosaic
data Aspect
Taller :: Aspect
Wider :: Aspect
Reset :: Aspect
SlopeMod :: ([Rational] -> [Rational]) -> Aspect

-- | The relative magnitudes (the sign is ignored) of the rational numbers
--   in the second argument determine the relative areas that the windows
--   receive. The first number represents the size of the master window,
--   the second is for the next window in the stack, and so on.
--   
--   The list is extended with <tt>++ repeat 1</tt>, so <tt>mosaic 1.5
--   []</tt> is like a resizable grid.
--   
--   The first parameter is the multiplicative factor to use when
--   responding to the <a>Expand</a> message.
mosaic :: Rational -> [Rational] -> Mosaic a

-- | These sample functions are meant to be applied to the list of window
--   sizes through the <a>SlopeMod</a> message.
changeMaster :: (Rational -> Rational) -> X ()

-- | Apply a function to the Rational that represents the currently focused
--   window.
--   
--   <a>Expand</a> and <a>Shrink</a> messages are responded to with
--   <tt>changeFocused (*delta)</tt> or <tt>changeFocused (delta/)</tt>
--   where <tt>delta</tt> is the first argument to <a>mosaic</a>.
--   
--   This is exported because other functions (ex. <tt>const 1</tt>,
--   <tt>(+1)</tt>) may be useful to apply to the current area.
changeFocused :: (Rational -> Rational) -> X ()
instance Typeable Aspect
instance Read (Mosaic a)
instance Show (Mosaic a)
instance Monoid (Tree a)
instance Functor Tree
instance Foldable Tree
instance LayoutClass Mosaic a
instance Message Aspect


-- | A layout combinator that sends a specified number of windows to one
--   rectangle and the rest to another.
module XMonad.Layout.LayoutBuilder

-- | Use the specified layout in the described area for N windows and send
--   the rest of the windows to the next layout in the chain. It is
--   possible to supply an alternative area that will then be used instead,
--   if there are no windows to send to the next layout.
layoutN :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a, LayoutClass l3 a) => Int -> SubBox -> Maybe SubBox -> l1 a -> LayoutN l2 l3 a -> LayoutN l1 (LayoutN l2 l3) a

-- | As layoutN, but the number of windows is given relative to the total
--   number of windows remaining to be handled. The first argument is how
--   much to change the ratio when using IncLayoutN, and the second is the
--   initial ratio.
layoutR :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a, LayoutClass l3 a) => Rational -> Rational -> SubBox -> Maybe SubBox -> l1 a -> LayoutN l2 l3 a -> LayoutN l1 (LayoutN l2 l3) a

-- | Use the specified layout in the described area for all remaining
--   windows.
layoutAll :: (Read a, Eq a, LayoutClass l1 a) => SubBox -> l1 a -> LayoutN l1 Full a

-- | Change the number of windows handled by the focused layout.
data IncLayoutN
IncLayoutN :: Int -> IncLayoutN

-- | The absolute or relative measures used to describe the area a layout
--   should be placed in. For negative absolute values the total remaining
--   space will be added. For sizes, the remaining space will also be added
--   for zeroes. Relative values are applied on the remaining space after
--   the top-left corner of the box have been removed.
data SubMeasure
Abs :: Int -> SubMeasure
Rel :: Rational -> SubMeasure

-- | A box to place a layout in. The stored values are xpos, ypos, width
--   and height.
data SubBox
SubBox :: SubMeasure -> SubMeasure -> SubMeasure -> SubMeasure -> SubBox

-- | Create a box with only absolute measurements. If the values are
--   negative, the total remaining space will be added. For sizes it will
--   also be added for zeroes.
absBox :: Int -> Int -> Int -> Int -> SubBox

-- | Create a box with only relative measurements.
relBox :: Rational -> Rational -> Rational -> Rational -> SubBox
instance Typeable IncLayoutN
instance Show SubBox
instance Read SubBox
instance Show SubMeasure
instance Read SubMeasure
instance (Show a, Show (l1 a), Show (l2 a)) => Show (LayoutN l1 l2 a)
instance (Read a, Read (l1 a), Read (l2 a)) => Read (LayoutN l1 l2 a)
instance (LayoutClass l1 a, LayoutClass l2 a, Read a, Show a, Eq a, Typeable a) => LayoutClass (LayoutN l1 l2) a
instance Message IncLayoutN


-- | A not so simple layout that attempts to put all windows in a square
--   grid while obeying their size hints.
module XMonad.Layout.HintedGrid

-- | Automatic mirroring of hinted layouts doesn't work very well, so this
--   <a>Grid</a> comes with built-in mirroring. <tt>Grid False</tt> is the
--   normal layout, <tt>Grid True</tt> is the mirrored variant (rotated by
--   90 degrees).
data Grid a
Grid :: Bool -> Grid a
GridRatio :: Double -> Bool -> Grid a

-- | The internal function for computing the grid layout.
arrange :: Double -> Bool -> Rectangle -> [Window] -> X [(Window, Rectangle)]
defaultRatio :: Double
instance Read (Grid a)
instance Show (Grid a)
instance LayoutClass Grid Window


-- | Two layouts: one is a variant of the Grid layout that allows the
--   desired aspect ratio of windows to be specified. The other is like
--   Tall but places a grid with fixed number of rows and columns in the
--   master area and uses an aspect-ratio-specified layout for the slaves.
module XMonad.Layout.GridVariants

-- | The geometry change message understood by the master grid
data ChangeMasterGeom

-- | Change the number of master rows
IncMasterRows :: !Int -> ChangeMasterGeom

-- | Change the number of master columns
IncMasterCols :: !Int -> ChangeMasterGeom

-- | Grid layout. The parameter is the desired x:y aspect ratio of windows
data Grid a
Grid :: !Rational -> Grid a

-- | TallGrid layout. Parameters are
--   
--   <ul>
--   <li>number of master rows - number of master columns - portion of
--   screen used for master grid - x:y aspect ratio of slave windows -
--   increment for resize messages</li>
--   </ul>
--   
--   This exists mostly because it was introduced in an earlier version.
--   It's a fairly thin wrapper around <a>SplitGrid L</a>.
data TallGrid a
TallGrid :: !Int -> !Int -> !Rational -> !Rational -> !Rational -> TallGrid a

-- | SplitGrid layout. Parameters are
--   
--   <ul>
--   <li>side where the master is - number of master rows - number of
--   master columns - portion of screen used for master grid - x:y aspect
--   ratio of slave windows - increment for resize messages</li>
--   </ul>
data SplitGrid a
SplitGrid :: Orientation -> !Int -> !Int -> !Rational -> !Rational -> !Rational -> SplitGrid a

-- | Type to specify the side of the screen that holds the master area of a
--   SplitGrid.
data Orientation
T :: Orientation
B :: Orientation
L :: Orientation
R :: Orientation
instance Typeable ChangeMasterGeom
instance Read (TallGrid a)
instance Show (TallGrid a)
instance Eq Orientation
instance Read Orientation
instance Show Orientation
instance Read (SplitGrid a)
instance Show (SplitGrid a)
instance Read (Grid a)
instance Show (Grid a)
instance LayoutClass TallGrid a
instance Message ChangeMasterGeom
instance LayoutClass SplitGrid a
instance LayoutClass Grid a


-- | A simple layout that attempts to put all windows in a square grid.
module XMonad.Layout.Grid
data Grid a
Grid :: Grid a
GridRatio :: Double -> Grid a
arrange :: Double -> Rectangle -> [a] -> [(a, Rectangle)]
defaultRatio :: Double
instance Read (Grid a)
instance Show (Grid a)
instance LayoutClass Grid a


-- | A layout much like Tall, but using a multiple of a window's minimum
--   resize amount instead of a percentage of screen to decide where to
--   split. This is useful when you usually leave a text editor or terminal
--   in the master pane and like it to be 80 columns wide.
module XMonad.Layout.FixedColumn

-- | A tiling mode based on preserving a nice fixed width window. Supports
--   <a>Shrink</a>, <a>Expand</a> and <a>IncMasterN</a>.
data FixedColumn a
FixedColumn :: !Int -> !Int -> !Int -> !Int -> FixedColumn a
instance Read (FixedColumn a)
instance Show (FixedColumn a)
instance LayoutClass FixedColumn Window


-- | Dishes is a layout that stacks extra windows underneath the master
--   windows.
module XMonad.Layout.Dishes
data Dishes a
Dishes :: Int -> Rational -> Dishes a
instance Show (Dishes a)
instance Read (Dishes a)
instance LayoutClass Dishes a


-- | A data type to store the layout state
module XMonad.Util.Invisible
newtype Invisible m a
I :: (m a) -> Invisible m a
whenIJust :: (Monad m) => Invisible Maybe a -> (a -> m ()) -> m ()
fromIMaybe :: a -> Invisible Maybe a -> a
instance (Monad m) => Monad (Invisible m)
instance (Functor m) => Functor (Invisible m)
instance (Monad m) => Show (Invisible m a)
instance (Functor m, Monad m) => Read (Invisible m a)


-- | A Cross Layout with the main window in the center.
module XMonad.Layout.Cross

-- | A simple Cross Layout. It places the focused window in the center. The
--   proportion of the screen used by the main window is 4/5.
simpleCross :: Cross a

-- | The Cross Layout draws the focused window in the center of the screen
--   and part of the other windows on the sides. The <a>Shrink</a> and
--   <a>Expand</a> messages increment the size of the main window.
--   
--   The focus keybindings change the center window, while other windows
--   cycle through the side positions. With the Cross layout only four
--   windows are shown around the focused window, two ups and two downs, no
--   matter how many are in the current stack. I.e. focus down cycles the
--   window below focused into the center; focus up cycles the window
--   above.
data Cross a
Cross :: !Rational -> !Rational -> Cross a

-- | Proportion of screen occupied by the main window.
crossProp :: Cross a -> !Rational

-- | Percent of main window to increment by when resizing.
crossInc :: Cross a -> !Rational
instance Show (Cross a)
instance Read (Cross a)
instance LayoutClass Cross a


-- | Provides Column layout that places all windows in one column. Windows
--   heights are calculated from equation: H1<i>H2 = H2</i>H3 = ... = q,
--   where q is given. With Shrink/Expand messages you can change the q
--   value.
module XMonad.Layout.Column
data Column a
Column :: Float -> Column a
instance Read (Column a)
instance Show (Column a)
instance LayoutClass Column a


-- | Circle is an elliptical, overlapping layout, by Peter De Wachter
module XMonad.Layout.Circle
data Circle a
Circle :: Circle a
instance Read (Circle a)
instance Show (Circle a)
instance LayoutClass Circle Window


-- | A ManageHook matching on XProperties.
module XMonad.Hooks.XPropManage
xPropManageHook :: [XPropMatch] -> ManageHook
type XPropMatch = ([(Atom, [String] -> Bool)], Window -> X (WindowSet -> WindowSet))
pmX :: (Window -> X ()) -> Window -> X (WindowSet -> WindowSet)
pmP :: (WindowSet -> WindowSet) -> Window -> X (WindowSet -> WindowSet)


-- | A module for setting up timers
module XMonad.Util.Timer

-- | Start a timer, which will send a ClientMessageEvent after some time
--   (in seconds).
startTimer :: Rational -> X TimerId

-- | Given a <a>TimerId</a> and an <a>Event</a>, run an action when the
--   <a>Event</a> has been sent by the timer specified by the
--   <a>TimerId</a>
handleTimer :: TimerId -> Event -> X (Maybe a) -> X (Maybe a)
type TimerId = Int


-- | Provides a simple interface for running a ~/.xmonad/hooks script with
--   the name of a hook.
module XMonad.Hooks.Script

-- | Execute a named script hook
execScriptHook :: (MonadIO m) => String -> m ()


-- | Configure where new windows should be added and which window should be
--   focused.
module XMonad.Hooks.InsertPosition

-- | insertPosition. A manage hook for placing new windows. XMonad's
--   default is the same as using: <tt>insertPosition Above Newer</tt>.
insertPosition :: Position -> Focus -> ManageHook
data Focus
Newer :: Focus
Older :: Focus
data Position
Master :: Position
End :: Position
Above :: Position
Below :: Position


-- | Makes XMonad set the _NET_WM_WINDOW_OPACITY atom for inactive windows,
--   which causes those windows to become slightly translucent if something
--   like xcompmgr is running
module XMonad.Hooks.FadeInactive

-- | sets the opacity of a window
setOpacity :: Window -> Rational -> X ()

-- | returns True if the window doesn't have the focus.
isUnfocused :: Query Bool

-- | makes a window completely opaque
fadeIn :: Window -> X ()

-- | fades a window out by setting the opacity
fadeOut :: Rational -> Window -> X ()

-- | Fades a window by the specified amount if it satisfies the first
--   query, otherwise makes it opaque.
fadeIf :: Query Bool -> Rational -> Query Rational

-- | sets the opacity of inactive windows to the specified amount
fadeInactiveLogHook :: Rational -> X ()

-- | fades out every window by the amount returned by the query.
fadeOutLogHook :: Query Rational -> X ()


-- | EDSL for specifying window properties; various utilities related to
--   window properties.
module XMonad.Util.WindowProperties

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Does given window have this property?
hasProperty :: Property -> Window -> X Bool

-- | Does the focused window have this property?
focusedHasProperty :: Property -> X Bool

-- | Find all existing windows with specified property
allWithProperty :: Property -> X [Window]

-- | Convert property to <a>Query</a> <a>Bool</a> (see
--   <a>XMonad.ManageHook</a>)
propertyToQuery :: Property -> Query Bool

-- | Get a window property from atom
getProp32 :: Atom -> Window -> X (Maybe [CLong])

-- | Get a window property from string
getProp32s :: String -> Window -> X (Maybe [CLong])
instance Read Property
instance Show Property


-- | Sets the WM name to a given string, so that it could be detected using
--   _NET_SUPPORTING_WM_CHECK protocol.
--   
--   May be useful for making Java GUI programs work, just set WM name to
--   <a>LG3D</a> and use Java 1.6u1 (1.6.0_01-ea-b03 works for me) or
--   later.
--   
--   To your <tt>~/.xmonad/xmonad.hs</tt> file, add the following line:
--   
--   <pre>
--   import XMonad.Hooks.SetWMName
--   </pre>
--   
--   Then edit your <tt>startupHook</tt>:
--   
--   <pre>
--   startupHook = setWMName "LG3D"
--   </pre>
--   
--   For details on the problems with running Java GUI programs in
--   non-reparenting WMs, see
--   <a>http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6429775</a> and
--   related bugs.
--   
--   Setting WM name to <a>compiz</a> does not solve the problem, because
--   of yet another bug in AWT code (related to insets). For LG3D insets
--   are explicitly set to 0, while for other WMs the insets are "guessed"
--   and the algorithm fails miserably by guessing absolutely bogus values.
--   
--   For detailed instructions on editing your hooks, see
--   <a>XMonad.Doc.Extending#4</a>.
module XMonad.Hooks.SetWMName

-- | sets WM name
setWMName :: String -> X ()


-- | A layout that splits the screen horizontally and shows two windows.
--   The left window is always the master window, and the right is either
--   the currently focused window or the second window in layout order.
module XMonad.Layout.TwoPane
data TwoPane a
TwoPane :: Rational -> Rational -> TwoPane a
instance Show (TwoPane a)
instance Read (TwoPane a)
instance LayoutClass TwoPane a


-- | Divide a single screen into multiple screens.
module XMonad.Layout.LayoutScreens

-- | Modify all screens.
layoutScreens :: (LayoutClass l Int) => Int -> l Int -> X ()

-- | Modify current screen.
layoutSplitScreen :: (LayoutClass l Int) => Int -> l Int -> X ()
fixedLayout :: [Rectangle] -> FixedLayout a
instance Read (FixedLayout a)
instance Show (FixedLayout a)
instance LayoutClass FixedLayout a


-- | A gapless tiled layout that attempts to obey window size hints, rather
--   than simply ignoring them.
module XMonad.Layout.HintedTile
data HintedTile a
HintedTile :: !Int -> !Rational -> !Rational -> !Alignment -> !Orientation -> HintedTile a

-- | number of windows in the master pane
nmaster :: HintedTile a -> !Int

-- | how much to change when resizing
delta :: HintedTile a -> !Rational

-- | ratio between master/nonmaster panes
frac :: HintedTile a -> !Rational

-- | Where to place windows that are smaller than their preordained
--   rectangles.
alignment :: HintedTile a -> !Alignment

-- | Tall or Wide (mirrored) layout?
orientation :: HintedTile a -> !Orientation
data Orientation

-- | Lay out windows similarly to Mirror tiled.
Wide :: Orientation

-- | Lay out windows similarly to tiled.
Tall :: Orientation
data Alignment
TopLeft :: Alignment
Center :: Alignment
BottomRight :: Alignment
instance Show Alignment
instance Read Alignment
instance Eq Alignment
instance Ord Alignment
instance Show Orientation
instance Read Orientation
instance Eq Orientation
instance Ord Orientation
instance Show (HintedTile a)
instance Read (HintedTile a)
instance LayoutClass HintedTile Window


-- | A module to toggle between two layouts.
module XMonad.Layout.ToggleLayouts
toggleLayouts :: (LayoutClass lt a, LayoutClass lf a) => lt a -> lf a -> ToggleLayouts lt lf a
data ToggleLayout
ToggleLayout :: ToggleLayout
Toggle :: String -> ToggleLayout
instance Typeable ToggleLayout
instance Read ToggleLayout
instance Show ToggleLayout
instance (Read (lt a), Read (lf a)) => Read (ToggleLayouts lt lf a)
instance (Show (lt a), Show (lf a)) => Show (ToggleLayouts lt lf a)
instance (LayoutClass lt a, LayoutClass lf a) => LayoutClass (ToggleLayouts lt lf) a
instance Message ToggleLayout


-- | A layout that splits the screen into a square area and the rest of the
--   screen. This is probably only ever useful in combination with
--   <a>XMonad.Layout.Combo</a>. It sticks one window in a square region,
--   and makes the rest of the windows live with what's left (in a
--   full-screen sense).
module XMonad.Layout.Square
data Square a
Square :: Square a
instance Read (Square a)
instance Show (Square a)
instance LayoutClass Square a


-- | A module for setting the default mouse cursor.
--   
--   Some ideas shamelessly stolen from Nils Schweinsberg; thanks!
module XMonad.Util.Cursor

-- | Set the default (root) cursor
setDefaultCursor :: Glyph -> X ()


-- | This module fixes some of the keybindings for the francophone among
--   you who use an AZERTY keyboard layout. Config stolen from TeXitoi's
--   config on the wiki.
module XMonad.Config.Azerty
azertyConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))
azertyKeys :: XConfig t -> Map (KeyMask, KeySym) (X ())


-- | LayoutClass that puts non-focused windows in ribbons at the top and
--   bottom of the screen.
module XMonad.Layout.Accordion
data Accordion a
Accordion :: Accordion a
instance Read (Accordion a)
instance Show (Accordion a)
instance LayoutClass Accordion Window


-- | A module for writing easy layout modifiers, which do not define a
--   layout in and of themselves, but modify the behavior of or add new
--   functionality to other layouts. If you ever find yourself writing a
--   layout which takes another layout as a parameter, chances are you
--   should be writing a LayoutModifier instead!
--   
--   In case it is not clear, this module is not intended to help you
--   configure xmonad, it is to help you write other extension modules. So
--   get hacking!
module XMonad.Layout.LayoutModifier
class (Show (m a), Read (m a)) => LayoutModifier m a
modifyLayout :: (LayoutModifier m a, LayoutClass l a) => m a -> Workspace WorkspaceId (l a) a -> Rectangle -> X ([(a, Rectangle)], Maybe (l a))
handleMess :: (LayoutModifier m a) => m a -> SomeMessage -> X (Maybe (m a))
handleMessOrMaybeModifyIt :: (LayoutModifier m a) => m a -> SomeMessage -> X (Maybe (Either (m a) SomeMessage))
pureMess :: (LayoutModifier m a) => m a -> SomeMessage -> Maybe (m a)
redoLayout :: (LayoutModifier m a) => m a -> Rectangle -> Maybe (Stack a) -> [(a, Rectangle)] -> X ([(a, Rectangle)], Maybe (m a))
pureModifier :: (LayoutModifier m a) => m a -> Rectangle -> Maybe (Stack a) -> [(a, Rectangle)] -> ([(a, Rectangle)], Maybe (m a))
hook :: (LayoutModifier m a) => m a -> X ()
unhook :: (LayoutModifier m a) => m a -> X ()
modifierDescription :: (LayoutModifier m a) => m a -> String
modifyDescription :: (LayoutModifier m a, LayoutClass l a) => m a -> l a -> String

-- | A <a>ModifiedLayout</a> is simply a container for a layout modifier
--   combined with an underlying layout. It is, of course, itself a layout
--   (i.e. an instance of <a>LayoutClass</a>).
data ModifiedLayout m l a
ModifiedLayout :: (m a) -> (l a) -> ModifiedLayout m l a
instance (Read (m a), Read (l a)) => Read (ModifiedLayout m l a)
instance (Show (m a), Show (l a)) => Show (ModifiedLayout m l a)
instance (LayoutModifier m a, LayoutClass l a) => LayoutClass (ModifiedLayout m l) a


-- | Screenshot : <a>http://caladan.rave.org/magnifier.png</a>
--   
--   This is a layout modifier that will make a layout increase the size of
--   the window that has focus.
module XMonad.Layout.Magnifier

-- | Increase the size of the window that has focus
magnifier :: l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus, unless if it is the
--   master window.
magnifier' :: l a -> ModifiedLayout Magnifier l a

-- | Magnifier that defaults to Off
magnifierOff :: l a -> ModifiedLayout Magnifier l a

-- | Change the size of the window that has focus by a custom zoom
magnifiercz :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus by a custom zoom,
--   unless if it is the master window.
magnifiercz' :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | A magnifier that greatly magnifies just the vertical direction
maximizeVertical :: l a -> ModifiedLayout Magnifier l a
data MagnifyMsg
MagnifyMore :: MagnifyMsg
MagnifyLess :: MagnifyMsg
ToggleOn :: MagnifyMsg
ToggleOff :: MagnifyMsg
Toggle :: MagnifyMsg
instance Typeable MagnifyMsg
instance Read MagnifyMaster
instance Show MagnifyMaster
instance Read Toggle
instance Show Toggle
instance Read (Magnifier a)
instance Show (Magnifier a)
instance LayoutModifier Magnifier Window
instance Message MagnifyMsg


-- | Make a given layout display without borders. This is useful for
--   full-screen or tabbed layouts, where you don't really want to waste a
--   couple of pixels of real estate just to inform yourself that the
--   visible window has focus.
module XMonad.Layout.NoBorders

-- | Removes all window borders from the specified layout.
noBorders :: (LayoutClass l Window) => l Window -> ModifiedLayout WithBorder l Window

-- | Removes the borders from a window under one of the following
--   conditions:
--   
--   <ul>
--   <li>There is only one screen and only one window. In this case it's
--   obvious that it has the focus, so no border is needed.</li>
--   <li>A floating window covers the entire screen (e.g. mplayer).</li>
--   </ul>
smartBorders :: (LayoutClass l a) => l a -> ModifiedLayout SmartBorder l a

-- | Forces a layout to use the specified border width. <a>noBorders</a> is
--   equivalent to <tt><a>withBorder</a> 0</tt>.
withBorder :: (LayoutClass l a) => Dimension -> l a -> ModifiedLayout WithBorder l a

-- | Apply a datatype that has a SetsAmbiguous instance to provide a list
--   of windows that should not have borders.
--   
--   This gives flexibility over when borders should be drawn, in
--   particular with xinerama setups: <a>Ambiguity</a> has a number of
--   useful <a>SetsAmbiguous</a> instances
lessBorders :: (SetsAmbiguous p, Read p, Show p, LayoutClass l a) => p -> l a -> ModifiedLayout (ConfigurableBorder p) l a

-- | SetsAmbiguous allows custom actions to generate lists of windows that
--   should not have borders drawn through <a>ConfigurableBorder</a>
--   
--   To add your own (though perhaps those options would better belong as
--   an aditional constructor to <a>Ambiguity</a>), you can add the
--   function as such:
--   
--   <pre>
--   data MyAmbiguity = MyAmbiguity deriving (Read, Show)
--   </pre>
--   
--   <pre>
--   instance SetsAmbiguous MyAmbiguity where
--    hiddens _ wset mst wrs = otherHiddens Screen \\ otherHiddens OnlyFloat
--       where otherHiddens p = hiddens p wset mst wrs
--   </pre>
--   
--   The above example is redundant, because you can have the same result
--   with:
--   
--   <pre>
--   layoutHook = lessBorders (Combine Difference Screen OnlyFloat) (Tall 1 0.5 0.03 ||| ... )
--   </pre>
--   
--   To get the same result as smartBorders:
--   
--   <pre>
--   layoutHook = lessBorders (Combine Never) (Tall 1 0.5 0.03 ||| ...)
--   </pre>
--   
--   This indirect method is required to keep the Read and Show for
--   ConfigurableBorder so that xmonad can serialize state.
class SetsAmbiguous p
hiddens :: (SetsAmbiguous p) => p -> WindowSet -> Maybe (Stack Window) -> [(Window, Rectangle)] -> [Window]

-- | In order of increasing ambiguity (less borders more frequently), where
--   subsequent constructors add additional cases where borders are not
--   drawn than their predecessors. These behaviors make most sense with
--   with multiple screens: for single screens, Never or
--   <a>smartBorders</a> makes more sense.
data Ambiguity

-- | This constructor is used to combine the borderless windows provided by
--   the SetsAmbiguous instances from two other <a>Ambiguity</a> data
--   types.
Combine :: With -> Ambiguity -> Ambiguity -> Ambiguity

-- | Only remove borders on floating windows that cover the whole screen
OnlyFloat :: Ambiguity

-- | Never remove borders when ambiguous: this is the same as smartBorders
Never :: Ambiguity

-- | Focus in an empty screens does not count as ambiguous.
EmptyScreen :: Ambiguity

-- | No borders on full when all other screens have borders.
OtherIndicated :: Ambiguity

-- | Borders are never drawn on singleton screens. With this one you really
--   need another way such as a statusbar to detect focus.
Screen :: Ambiguity

-- | Used to indicate to the <a>SetsAmbiguous</a> instance for
--   <a>Ambiguity</a> how two lists should be combined.
data With

-- | Combine with Data.List.union
Union :: With

-- | Combine with Data.List.\
Difference :: With

-- | Combine with Data.List.intersect
Intersection :: With
instance Read With
instance Show With
instance Read Ambiguity
instance Show Ambiguity
instance (Read p, Read w) => Read (ConfigurableBorder p w)
instance (Show p, Show w) => Show (ConfigurableBorder p w)
instance (Read a) => Read (WithBorder a)
instance (Show a) => Show (WithBorder a)
instance SetsAmbiguous Ambiguity
instance (Read p, Show p, SetsAmbiguous p) => LayoutModifier (ConfigurableBorder p) Window
instance LayoutModifier WithBorder Window


-- | BoringWindows is an extension to allow windows to be marked boring
module XMonad.Layout.BoringWindows
boringWindows :: (LayoutClass l a, Eq a) => l a -> ModifiedLayout BoringWindows l a

-- | Mark windows that are not given rectangles as boring
boringAuto :: (LayoutClass l a, Eq a) => l a -> ModifiedLayout BoringWindows l a
markBoring :: X ()
clearBoring :: X ()
focusUp :: X ()
focusDown :: X ()
focusMaster :: X ()

-- | UpdateBoring is sent before attempting to view another boring window,
--   so that layouts have a chance to mark boring windows.
data UpdateBoring
UpdateBoring :: UpdateBoring
data BoringMessage
Replace :: String -> [Window] -> BoringMessage
Merge :: String -> [Window] -> BoringMessage
data BoringWindows a
instance Typeable1 BoringWindows
instance Typeable UpdateBoring
instance Typeable BoringMessage
instance (Show a) => Show (BoringWindows a)
instance (Read a) => Read (BoringWindows a)
instance Read BoringMessage
instance Show BoringMessage
instance LayoutModifier BoringWindows Window
instance Message UpdateBoring
instance Message BoringMessage


-- | A helper module to visualize the process of dragging a window by
--   making it follow the mouse cursor. See
--   <a>XMonad.Layout.WindowSwitcherDecoration</a> for a module that makes
--   use of this.
module XMonad.Layout.DraggingVisualizer
draggingVisualizer :: (LayoutClass l Window) => l Window -> ModifiedLayout DraggingVisualizer l Window
data DraggingVisualizerMsg
DraggingWindow :: Window -> Rectangle -> DraggingVisualizerMsg
DraggingStopped :: DraggingVisualizerMsg
instance Typeable DraggingVisualizerMsg
instance Eq DraggingVisualizerMsg
instance Read (DraggingVisualizer a)
instance Show (DraggingVisualizer a)
instance LayoutModifier DraggingVisualizer Window
instance Message DraggingVisualizerMsg


-- | A module for assigning a name to a given layout.
module XMonad.Layout.Named

-- | Rename a layout.
named :: String -> l a -> ModifiedLayout Named l a

-- | Remove the first word of the name.
nameTail :: l a -> ModifiedLayout NameTail l a
instance Read (NameTail a)
instance Show (NameTail a)
instance Read (Named a)
instance Show (Named a)
instance LayoutModifier NameTail a
instance LayoutModifier Named a


-- | Provides layout modifier AutoMaster. It separates screen in two parts
--   - master and slave. Size of slave area automatically changes depending
--   on number of slave windows.
module XMonad.Layout.AutoMaster

-- | User interface function
autoMaster :: (LayoutClass l a) => Int -> Float -> l a -> ModifiedLayout AutoMaster l a
instance Read (AutoMaster a)
instance Show (AutoMaster a)
instance LayoutModifier AutoMaster Window


-- | Two layout modifiers. centerMaster places master window at center, on
--   top of all other windows, which are managed by base layout.
--   topRightMaster is similar, but places master window in top right
--   corner instead of center.
module XMonad.Layout.CenteredMaster

-- | Modifier that puts master window in center, other windows in
--   background are managed by given layout
centerMaster :: (LayoutClass l a) => l a -> ModifiedLayout CenteredMaster l a

-- | Modifier that puts master window in top right corner, other windows in
--   background are managed by given layout
topRightMaster :: (LayoutClass l a) => l a -> ModifiedLayout TopRightMaster l a
instance Read (TopRightMaster a)
instance Show (TopRightMaster a)
instance Read (CenteredMaster a)
instance Show (CenteredMaster a)
instance LayoutModifier TopRightMaster Window
instance LayoutModifier CenteredMaster Window


-- | Reflect a layout horizontally or vertically.
module XMonad.Layout.Reflect

-- | Apply a horizontal reflection (left &lt;--&gt; right) to a layout.
reflectHoriz :: l a -> ModifiedLayout Reflect l a

-- | Apply a vertical reflection (top &lt;--&gt; bottom) to a layout.
reflectVert :: l a -> ModifiedLayout Reflect l a
data REFLECTX
REFLECTX :: REFLECTX
data REFLECTY
REFLECTY :: REFLECTY
data Reflect a
instance Typeable REFLECTY
instance Typeable REFLECTX
instance Read REFLECTY
instance Show REFLECTY
instance Eq REFLECTY
instance Read REFLECTX
instance Show REFLECTX
instance Eq REFLECTX
instance Show (Reflect a)
instance Read (Reflect a)
instance Read ReflectDir
instance Show ReflectDir
instance Transformer REFLECTY Window
instance Transformer REFLECTX Window
instance LayoutModifier Reflect a


-- | A layout modifier that puts some windows in a <a>drawer</a> which
--   retracts and expands depending on whether any window in it has focus.
--   
--   Useful for music players, tool palettes, etc.
module XMonad.Layout.Drawer

-- | Construct a drawer with a simple layout of the windows inside
simpleDrawer :: Rational -> Rational -> Property -> Drawer Tall a

-- | Construct a drawer with an arbitrary layout for windows inside
drawer :: Rational -> Rational -> Property -> (l a) -> Drawer l a
onLeft :: Drawer l a -> l' a -> ModifiedLayout (Drawer l) l' a
onTop :: Drawer l a -> l' a -> Mirror (ModifiedLayout (Drawer l) (Mirror l')) a
onRight :: Drawer l a -> l' a -> Reflected (ModifiedLayout (Drawer l) (Reflected l')) a
onBottom :: Drawer l a -> l' a -> Reflected (Mirror (ModifiedLayout (Drawer l) (Mirror (Reflected l')))) a
instance (Read (l a)) => Read (Drawer l a)
instance (Show (l a)) => Show (Drawer l a)
instance (LayoutClass l Window, Read (l Window)) => LayoutModifier (Drawer l) Window


-- | Layout modfier suitable for workspace with multi-windowed instant
--   messenger (like Psi or Tkabber).
module XMonad.Layout.IM

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | This is for compatibility with old configs only and will be removed in
--   future versions!
data IM a
IM :: Rational -> Property -> IM a

-- | Modifier which converts given layout to IM-layout (with dedicated
--   space for roster and original layout for chat windows)
withIM :: (LayoutClass l a) => Rational -> Property -> l a -> ModifiedLayout AddRoster l a

-- | IM layout modifier applied to the Grid layout
gridIM :: Rational -> Property -> ModifiedLayout AddRoster Grid a
instance Read (IM a)
instance Show (IM a)
instance Read (AddRoster a)
instance Show (AddRoster a)
instance LayoutClass IM Window
instance LayoutModifier AddRoster Window


-- | A layout modifier that limits the number of windows that can be shown.
--   See <a>XMonad.Layout.Minimize</a> for manually setting hidden windows.
module XMonad.Layout.LimitWindows

-- | Only display the first <tt>n</tt> windows.
limitWindows :: Int -> l a -> ModifiedLayout LimitWindows l a

-- | Only display <tt>n</tt> windows around the focused window. This makes
--   sense with layouts that arrange windows linearily, like
--   <tt>XMonad.Layout.Layout.Accordion</tt>.
limitSlice :: Int -> l a -> ModifiedLayout LimitWindows l a

-- | Only display the first <tt>m</tt> windows and <tt>r</tt> others. The
--   <tt>IncMasterN</tt> message will change <tt>m</tt>, as well as passing
--   it onto the underlying layout.
limitSelect :: Int -> Int -> l a -> ModifiedLayout Selection l a
increaseLimit :: X ()
decreaseLimit :: X ()
setLimit :: Int -> X ()
instance Typeable LimitChange
instance Read (Selection a)
instance Show (Selection a)
instance Eq (Selection a)
instance Read SliceStyle
instance Show SliceStyle
instance Read (LimitWindows a)
instance Show (LimitWindows a)
instance LayoutModifier Selection a
instance LayoutModifier LimitWindows a
instance Message LimitChange


-- | Layout modfier that adds a master window to another layout.
module XMonad.Layout.Master

-- | Modifier which converts given layout to a mastered one
mastered :: (LayoutClass l a) => Rational -> Rational -> l a -> ModifiedLayout AddMaster l a
instance Show (AddMaster a)
instance Read (AddMaster a)
instance LayoutModifier AddMaster Window


-- | Provides message "escaping" and filtering facilities which help
--   control complex nested layouts.
module XMonad.Layout.MessageControl

-- | the Ignore layout modifier. Prevents its inner layout from receiving
--   messages of a certain type.
data Ignore m l w

-- | Applies the Ignore layout modifier to a layout, blocking all messages
--   of the same type as the one passed as its first argument.
ignore :: (Message m, LayoutClass l w) => m -> l w -> (Ignore m l w)

-- | the UnEscape layout modifier. Listens to <a>EscapedMessage</a>s and
--   sends their nested message to the inner layout.
data UnEscape w

-- | Applies the UnEscape layout modifier to a layout.
unEscape :: (LayoutClass l w) => l w -> ModifiedLayout UnEscape l w

-- | Data type for an escaped message. Send with <a>escape</a>.
newtype EscapedMessage
Escape :: SomeMessage -> EscapedMessage

-- | Creates an <a>EscapedMessage</a>.
escape :: (Message m) => m -> EscapedMessage
instance Typeable EscapedMessage
instance Show (UnEscape w)
instance Read (UnEscape w)
instance (Show (l w)) => Show (Ignore m l w)
instance (Read (l w)) => Read (Ignore m l w)
instance Message EscapedMessage
instance LayoutModifier UnEscape a
instance (Message m, LayoutClass l w) => LayoutClass (Ignore m l) w


-- | Some convenient common instances of the <a>Transformer</a> class, for
--   use with <a>XMonad.Layout.MultiToggle</a>.
module XMonad.Layout.MultiToggle.Instances
data StdTransformers

-- | switch to Full layout
FULL :: StdTransformers

-- | switch to Full with no borders
NBFULL :: StdTransformers

-- | Mirror the current layout.
MIRROR :: StdTransformers

-- | Remove borders.
NOBORDERS :: StdTransformers

-- | Apply smart borders.
SMARTBORDERS :: StdTransformers
instance Typeable StdTransformers
instance Read StdTransformers
instance Show StdTransformers
instance Eq StdTransformers
instance Transformer StdTransformers Window


-- | Configure layouts on a per-workspace basis: use layouts and apply
--   layout modifiers selectively, depending on the workspace.
module XMonad.Layout.PerWorkspace

-- | Structure for representing a workspace-specific layout along with a
--   layout for all other workspaces. We store the tags of workspaces to be
--   matched, and the two layouts. We save the layout choice in the Bool,
--   to be used to implement description.
data PerWorkspace l1 l2 a

-- | Specify one layout to use on a particular workspace, and another to
--   use on all others. The second layout can be another call to
--   <a>onWorkspace</a>, and so on.
onWorkspace :: (LayoutClass l1 a, LayoutClass l2 a) => WorkspaceId -> (l1 a) -> (l2 a) -> PerWorkspace l1 l2 a

-- | Specify one layout to use on a particular set of workspaces, and
--   another to use on all other workspaces.
onWorkspaces :: (LayoutClass l1 a, LayoutClass l2 a) => [WorkspaceId] -> (l1 a) -> (l2 a) -> PerWorkspace l1 l2 a

-- | Specify a layout modifier to apply to a particular workspace; layouts
--   on all other workspaces will remain unmodified.
modWorkspace :: (LayoutClass l a) => WorkspaceId -> (l a -> ModifiedLayout lm l a) -> l a -> PerWorkspace (ModifiedLayout lm l) l a

-- | Specify a layout modifier to apply to a particular set of workspaces;
--   layouts on all other workspaces will remain unmodified.
modWorkspaces :: (LayoutClass l a) => [WorkspaceId] -> (l a -> ModifiedLayout lm l a) -> l a -> PerWorkspace (ModifiedLayout lm l) l a
instance (Read (l1 a), Read (l2 a)) => Read (PerWorkspace l1 l2 a)
instance (Show (l1 a), Show (l2 a)) => Show (PerWorkspace l1 l2 a)
instance (LayoutClass l1 a, LayoutClass l2 a, Show a) => LayoutClass (PerWorkspace l1 l2) a


-- | Add a configurable amount of space around windows.
module XMonad.Layout.Spacing

-- | Surround all windows by a certain number of pixels of blank space.
spacing :: Int -> l a -> ModifiedLayout Spacing l a
instance Show (Spacing a)
instance Read (Spacing a)
instance LayoutModifier Spacing a


-- | Makes it possible to minimize windows, temporarily removing them from
--   the layout until they are restored.
module XMonad.Layout.Minimize
minimize :: (LayoutClass l Window) => l Window -> ModifiedLayout Minimize l Window
data MinimizeMsg
MinimizeWin :: Window -> MinimizeMsg
RestoreMinimizedWin :: Window -> MinimizeMsg
RestoreNextMinimizedWin :: MinimizeMsg
instance Typeable MinimizeMsg
instance Eq MinimizeMsg
instance Read (Minimize a)
instance Show (Minimize a)
instance LayoutModifier Minimize Window
instance Message MinimizeMsg


-- | Lets you restore minimized windows (see <a>XMonad.Layout.Minimize</a>)
--   by selecting them on a taskbar (listens for _NET_ACTIVE_WINDOW and
--   WM_CHANGE_STATE).
module XMonad.Hooks.RestoreMinimized
data RestoreMinimized
RestoreMinimized :: RestoreMinimized
restoreMinimizedEventHook :: Event -> X All
instance Show RestoreMinimized
instance Read RestoreMinimized


-- | Temporarily yanks the focused window out of the layout to mostly fill
--   the screen.
module XMonad.Layout.Maximize
maximize :: (LayoutClass l Window) => l Window -> ModifiedLayout Maximize l Window
maximizeRestore :: Window -> MaximizeRestore
instance Typeable MaximizeRestore
instance Eq MaximizeRestore
instance Read (Maximize a)
instance Show (Maximize a)
instance LayoutModifier Maximize Window
instance Message MaximizeRestore


-- | Warp the pointer to a given window or screen.
module XMonad.Actions.Warp

-- | Move the mouse cursor to a corner of the focused window. Useful for
--   uncluttering things.
--   
--   Internally, this uses numerical parameters. We parametrize on the
--   <a>Corner</a> type so the user need not see the violence inherent in
--   the system.
--   
--   <a>warpToScreen</a> and <a>warpToWindow</a> can be used in a variety
--   of ways. Suppose you wanted to emulate Ratpoison's 'banish' command,
--   which moves the mouse pointer to a corner? warpToWindow can do that!
banish :: Corner -> X ()

-- | Same as <a>banish</a> but moves the mouse to the corner of the
--   currently focused screen
banishScreen :: Corner -> X ()
data Corner
UpperLeft :: Corner
UpperRight :: Corner
LowerLeft :: Corner
LowerRight :: Corner

-- | Warp the pointer to the given position (top left = (0,0), bottom right
--   = (1,1)) on the given screen.
warpToScreen :: ScreenId -> Rational -> Rational -> X ()

-- | Warp the pointer to a given position relative to the currently focused
--   window. Top left = (0,0), bottom right = (1,1).
warpToWindow :: Rational -> Rational -> X ()


-- | Causes the pointer to follow whichever window focus changes to.
--   Compliments the idea of switching focus as the mouse crosses window
--   boundaries to keep the mouse near the currently focused window
module XMonad.Actions.UpdatePointer

-- | Update the pointer's location to the currently focused window or empty
--   screen unless it's already there, or unless the user was changing
--   focus with the mouse
updatePointer :: PointerPosition -> X ()
data PointerPosition
Nearest :: PointerPosition
Relative :: Rational -> Rational -> PointerPosition
TowardsCentre :: Rational -> Rational -> PointerPosition
instance Read PointerPosition
instance Show PointerPosition


-- | Automagically put the focused window in the master area.
module XMonad.Layout.MagicFocus

-- | Create a new layout which automagically puts the focused window in the
--   master area.
magicFocus :: l a -> ModifiedLayout MagicFocus l a

-- | An eventHook that overrides the normal focusFollowsMouse. When the
--   mouse it moved to another window, that window is replaced as the
--   master, and the mouse is warped to inside the new master.
--   
--   It prevents infinite loops when focusFollowsMouse is true (the
--   default), and MagicFocus is in use when changing focus with the mouse.
--   
--   This eventHook does nothing when there are floating windows on the
--   current workspace.
promoteWarp :: Event -> X All

-- | promoteWarp' allows you to specify an arbitrary PointerPosition to
--   apply when the mouse enters another window.
promoteWarp' :: PointerPosition -> Event -> X All

-- | Another event hook to override the focusFollowsMouse and make the
--   pointer only follow if a given condition is satisfied. This could be
--   used to disable focusFollowsMouse only for given workspaces or
--   layouts. Beware that your focusFollowsMouse setting is ignored if you
--   use this event hook.
followOnlyIf :: X Bool -> Event -> X All

-- | Disables focusFollow on the given workspaces:
disableFollowOnWS :: [WorkspaceId] -> X Bool
instance Show (MagicFocus a)
instance Read (MagicFocus a)
instance LayoutModifier MagicFocus Window


-- | Updates the focus on mouse move in unfocused windows.
module XMonad.Actions.UpdateFocus

-- | Changes the focus if the mouse is moved within an unfocused window.
focusOnMouseMove :: Event -> X All

-- | Adjusts the event mask to pick up pointer movements.
adjustEventInput :: X ()


-- | A module that allows the user to create a sub-mapping of key bindings.
module XMonad.Actions.Submap

-- | Given a <tt>Data.Map.Map</tt> from key bindings to X () actions,
--   return an action which waits for a user keypress and executes the
--   corresponding action, or does nothing if the key is not found in the
--   map.
submap :: Map (KeyMask, KeySym) (X ()) -> X ()

-- | Like <a>submap</a>, but executes a default action if the key did not
--   match.
submapDefault :: X () -> Map (KeyMask, KeySym) (X ()) -> X ()


-- | A wrapper for keybinding configuration that can list the available
--   keybindings.
module XMonad.Util.NamedActions

-- | <a>sendMessage</a> but add a description that is <tt>show
--   message</tt>. Note that not all messages have show instances.
sendMessage' :: (Message a, Show a) => a -> NamedAction

-- | <a>spawn</a> but the description is the string passed
spawn' :: String -> NamedAction

-- | <a>submap</a>, but propagate the descriptions of the actions. Does
--   this belong in <a>XMonad.Actions.Submap</a>?
submapName :: (HasName a) => [((KeyMask, KeySym), a)] -> NamedAction

-- | Merge the supplied keys with <a>defaultKeysDescr</a>, also adding a
--   keybinding to run an action for showing the keybindings.
addDescrKeys :: (HasName b1, HasName b) => ((KeyMask, KeySym), [((KeyMask, KeySym), NamedAction)] -> b) -> (XConfig Layout -> [((KeyMask, KeySym), b1)]) -> XConfig l -> XConfig l

-- | An action to send to <a>addDescrKeys</a> for showing the keybindings.
--   See also <a>showKm</a> and <a>showKmSimple</a>
xMessage :: [((KeyMask, KeySym), NamedAction)] -> NamedAction
showKmSimple :: [((KeyMask, KeySym), NamedAction)] -> [[Char]]
showKm :: [((KeyMask, KeySym), NamedAction)] -> [String]

-- | These are just the <tt>NamedAction</tt> constructor but with a more
--   specialized type, so that you don't have to supply any annotations,
--   for ex coercing spawn to <tt>X ()</tt> from the more general
--   <tt>MonadIO m =&gt; m ()</tt>
noName :: X () -> NamedAction
oneName :: (X (), String) -> NamedAction
addName :: String -> X () -> NamedAction

-- | For a prettier presentation: keymask, keysym of 0 are reserved for
--   this purpose: they do not happen, afaik, and keysymToString 0 would
--   raise an error otherwise
separator :: ((KeyMask, KeySym), NamedAction)
subtitle :: String -> ((KeyMask, KeySym), NamedAction)

-- | Combine keymap lists with actions that may or may not have names
(^++^) :: (HasName b, HasName b1) => [(d, b)] -> [(d, b1)] -> [(d, NamedAction)]

-- | An existential wrapper so that different types can be combined in
--   lists, and maps
data NamedAction
NamedAction :: a -> NamedAction
class HasName a

-- | A version of the default keys from
--   <tt>XMonad.Config.defaultConfig</tt>, but with <a>NamedAction</a>
--   instead of <tt>X ()</tt>
defaultKeysDescr :: XConfig Layout -> [((KeyMask, KeySym), NamedAction)]
instance Show IncMasterN
instance Show Resize
instance HasName NamedAction
instance HasName (NamedAction, String)
instance HasName (X (), [String])
instance HasName (X (), String)
instance HasName [Char]
instance HasName (IO ())
instance HasName (X ())


-- | Useful helper functions for amending the defaultConfig, and for
--   parsing keybindings specified in a special (emacs-like) format.
--   
--   (See also <a>XMonad.Util.CustomKeys</a> in xmonad-contrib.)
module XMonad.Util.EZConfig

-- | Add or override keybindings from the existing set. Example use:
--   
--   <pre>
--   main = xmonad $ defaultConfig { terminal = "urxvt" }
--                   `additionalKeys`
--                   [ ((mod1Mask, xK_m        ), spawn "echo 'Hi, mom!' | dzen2 -p 4")
--                   , ((mod1Mask, xK_BackSpace), withFocused hide) -- N.B. this is an absurd thing to do
--                   ]
--   </pre>
--   
--   This overrides the previous definition of mod-m.
--   
--   Note that, unlike in xmonad 0.4 and previous, you can't use modMask to
--   refer to the modMask you configured earlier. You must specify mod1Mask
--   (or whichever), or add your own <tt>myModMask = mod1Mask</tt> line.
additionalKeys :: XConfig a -> [((ButtonMask, KeySym), X ())] -> XConfig a

-- | Like <a>additionalKeys</a>, except using short <tt>String</tt> key
--   descriptors like <tt>"M-m"</tt> instead of <tt>(modMask, xK_m)</tt>,
--   as described in the documentation for <a>mkKeymap</a>. For example:
--   
--   <pre>
--   main = xmonad $ defaultConfig { terminal = "urxvt" }
--                   `additionalKeysP`
--                   [ ("M-m", spawn "echo 'Hi, mom!' | dzen2 -p 4")
--                   , ("M-&lt;Backspace&gt;", withFocused hide) -- N.B. this is an absurd thing to do
--                   ]
--   </pre>
additionalKeysP :: XConfig l -> [(String, X ())] -> XConfig l

-- | Remove standard keybindings you're not using. Example use:
--   
--   <pre>
--   main = xmonad $ defaultConfig { terminal = "urxvt" }
--                   `removeKeys` [(mod1Mask .|. shiftMask, n) | n &lt;- [xK_1 .. xK_9]]
--   </pre>
removeKeys :: XConfig a -> [(ButtonMask, KeySym)] -> XConfig a

-- | Like <a>removeKeys</a>, except using short <tt>String</tt> key
--   descriptors like <tt>"M-m"</tt> instead of <tt>(modMask, xK_m)</tt>,
--   as described in the documentation for <a>mkKeymap</a>. For example:
--   
--   <pre>
--   main = xmonad $ defaultConfig { terminal = "urxvt" }
--                   `removeKeysP` ["M-S-" ++ [n] | n &lt;- ['1'..'9']]
--   </pre>
removeKeysP :: XConfig l -> [String] -> XConfig l

-- | Like <a>additionalKeys</a>, but for mouse bindings.
additionalMouseBindings :: XConfig a -> [((ButtonMask, Button), Window -> X ())] -> XConfig a

-- | Like <a>removeKeys</a>, but for mouse bindings.
removeMouseBindings :: XConfig a -> [(ButtonMask, Button)] -> XConfig a

-- | Given a config (used to determine the proper modifier key to use) and
--   a list of <tt>(String, X ())</tt> pairs, create a key map by parsing
--   the key sequence descriptions contained in the Strings. The key
--   sequence descriptions are "emacs-style": <tt>M-</tt>, <tt>C-</tt>,
--   <tt>S-</tt>, and <tt>M#-</tt> denote mod, control, shift, and
--   mod1-mod5 (where <tt>#</tt> is replaced by the appropriate number)
--   respectively. Note that if you want to make a keybinding using 'alt'
--   even though you use a different key (like the 'windows' key) for
--   'mod', you can use something like <tt>"M1-x"</tt> for alt+x (check the
--   output of <tt>xmodmap</tt> to see which mod key 'alt' is bound to).
--   Some special keys can also be specified by enclosing their name in
--   angle brackets.
--   
--   For example, <tt>"M-C-x"</tt> denotes mod+ctrl+x;
--   <tt>"S-&lt;Escape&gt;"</tt> denotes shift-escape;
--   <tt>"M1-C-&lt;Delete&gt;"</tt> denotes alt+ctrl+delete (assuming alt
--   is bound to mod1, which is common).
--   
--   Sequences of keys can also be specified by separating the key
--   descriptions with spaces. For example, <tt>"M-x y &lt;Down&gt;"</tt>
--   denotes the sequence of keys mod+x, y, down. Submaps (see
--   <a>XMonad.Actions.Submap</a>) will be automatically generated to
--   correctly handle these cases.
--   
--   So, for example, a complete key map might be specified as
--   
--   <pre>
--   keys = \c -&gt; mkKeymap c $
--       [ ("M-S-&lt;Return&gt;", spawn $ terminal c)
--       , ("M-x w", spawn "xmessage 'woohoo!'")  -- type mod+x then w to pop up 'woohoo!'
--       , ("M-x y", spawn "xmessage 'yay!'")     -- type mod+x then y to pop up 'yay!'
--       , ("M-S-c", kill)
--       ]
--   </pre>
--   
--   Alternatively, you can use <a>additionalKeysP</a> to automatically
--   create a keymap and add it to your config.
--   
--   Here is a complete list of supported special keys. Note that a few
--   keys, such as the arrow keys, have synonyms. If there are other
--   special keys you would like to see supported, feel free to submit a
--   patch, or ask on the xmonad mailing list; adding special keys is quite
--   simple.
--   
--   <pre>
--   &lt;Backspace&gt;
--   &lt;Tab&gt;
--   &lt;Return&gt;
--   &lt;Pause&gt;
--   &lt;Scroll_lock&gt;
--   &lt;Sys_Req&gt;
--   &lt;Print&gt;
--   &lt;Escape&gt;, &lt;Esc&gt;
--   &lt;Delete&gt;
--   &lt;Home&gt;
--   &lt;Left&gt;, &lt;L&gt;
--   &lt;Up&gt;, &lt;U&gt;
--   &lt;Right&gt;, &lt;R&gt;
--   &lt;Down&gt;, &lt;D&gt;
--   &lt;Page_Up&gt;
--   &lt;Page_Down&gt;
--   &lt;End&gt;
--   &lt;Insert&gt;
--   &lt;Break&gt;
--   &lt;Space&gt;
--   &lt;F1&gt;-&lt;F24&gt;
--   &lt;KP_Space&gt;
--   &lt;KP_Tab&gt;
--   &lt;KP_Enter&gt;
--   &lt;KP_F1&gt;
--   &lt;KP_F2&gt;
--   &lt;KP_F3&gt;
--   &lt;KP_F4&gt;
--   &lt;KP_Home&gt;
--   &lt;KP_Left&gt;
--   &lt;KP_Up&gt;
--   &lt;KP_Right&gt;
--   &lt;KP_Down&gt;
--   &lt;KP_Prior&gt;
--   &lt;KP_Page_Up&gt;
--   &lt;KP_Next&gt;
--   &lt;KP_Page_Down&gt;
--   &lt;KP_End&gt;
--   &lt;KP_Begin&gt;
--   &lt;KP_Insert&gt;
--   &lt;KP_Delete&gt;
--   &lt;KP_Equal&gt;
--   &lt;KP_Multiply&gt;
--   &lt;KP_Add&gt;
--   &lt;KP_Separator&gt;
--   &lt;KP_Subtract&gt;
--   &lt;KP_Decimal&gt;
--   &lt;KP_Divide&gt;
--   &lt;KP_0&gt;-&lt;KP_9&gt;
--   </pre>
--   
--   Long list of multimedia keys. Please note that not all keys may be
--   present in your particular setup although most likely they will do.
--   
--   <pre>
--   &lt;XF86ModeLock&gt;
--   &lt;XF86MonBrightnessUp&gt;
--   &lt;XF86MonBrightnessDown&gt;
--   &lt;XF86KbdLightOnOff&gt;
--   &lt;XF86KbdBrightnessUp&gt;
--   &lt;XF86KbdBrightnessDown&gt;
--   &lt;XF86Standby&gt;
--   &lt;XF86AudioLowerVolume&gt;
--   &lt;XF86AudioMute&gt;
--   &lt;XF86AudioRaiseVolume&gt;
--   &lt;XF86AudioPlay&gt;
--   &lt;XF86AudioStop&gt;
--   &lt;XF86AudioPrev&gt;
--   &lt;XF86AudioNext&gt;
--   &lt;XF86HomePage&gt;
--   &lt;XF86Mail&gt;
--   &lt;XF86Start&gt;
--   &lt;XF86Search&gt;
--   &lt;XF86AudioRecord&gt;
--   &lt;XF86Calculator&gt;
--   &lt;XF86Memo&gt;
--   &lt;XF86ToDoList&gt;
--   &lt;XF86Calendar&gt;
--   &lt;XF86PowerDown&gt;
--   &lt;XF86ContrastAdjust&gt;
--   &lt;XF86RockerUp&gt;
--   &lt;XF86RockerDown&gt;
--   &lt;XF86RockerEnter&gt;
--   &lt;XF86Back&gt;
--   &lt;XF86Forward&gt;
--   &lt;XF86Stop&gt;
--   &lt;XF86Refresh&gt;
--   &lt;XF86PowerOff&gt;
--   &lt;XF86WakeUp&gt;
--   &lt;XF86Eject&gt;
--   &lt;XF86ScreenSaver&gt;
--   &lt;XF86WWW&gt;
--   &lt;XF86Sleep&gt;
--   &lt;XF86Favorites&gt;
--   &lt;XF86AudioPause&gt;
--   &lt;XF86AudioMedia&gt;
--   &lt;XF86MyComputer&gt;
--   &lt;XF86VendorHome&gt;
--   &lt;XF86LightBulb&gt;
--   &lt;XF86Shop&gt;
--   &lt;XF86History&gt;
--   &lt;XF86OpenURL&gt;
--   &lt;XF86AddFavorite&gt;
--   &lt;XF86HotLinks&gt;
--   &lt;XF86BrightnessAdjust&gt;
--   &lt;XF86Finance&gt;
--   &lt;XF86Community&gt;
--   &lt;XF86AudioRewind&gt;
--   &lt;XF86XF86BackForward&gt;
--   &lt;XF86Launch0&gt;-&lt;XF86Launch9&gt;, &lt;XF86LaunchA&gt;-&lt;XF86LaunchF&gt;
--   &lt;XF86ApplicationLeft&gt;
--   &lt;XF86ApplicationRight&gt;
--   &lt;XF86Book&gt;
--   &lt;XF86CD&gt;
--   &lt;XF86Calculater&gt;
--   &lt;XF86Clear&gt;
--   &lt;XF86Close&gt;
--   &lt;XF86Copy&gt;
--   &lt;XF86Cut&gt;
--   &lt;XF86Display&gt;
--   &lt;XF86DOS&gt;
--   &lt;XF86Documents&gt;
--   &lt;XF86Excel&gt;
--   &lt;XF86Explorer&gt;
--   &lt;XF86Game&gt;
--   &lt;XF86Go&gt;
--   &lt;XF86iTouch&gt;
--   &lt;XF86LogOff&gt;
--   &lt;XF86Market&gt;
--   &lt;XF86Meeting&gt;
--   &lt;XF86MenuKB&gt;
--   &lt;XF86MenuPB&gt;
--   &lt;XF86MySites&gt;
--   &lt;XF86New&gt;
--   &lt;XF86News&gt;
--   &lt;XF86OfficeHome&gt;
--   &lt;XF86Open&gt;
--   &lt;XF86Option&gt;
--   &lt;XF86Paste&gt;
--   &lt;XF86Phone&gt;
--   &lt;XF86Q&gt;
--   &lt;XF86Reply&gt;
--   &lt;XF86Reload&gt;
--   &lt;XF86RotateWindows&gt;
--   &lt;XF86RotationPB&gt;
--   &lt;XF86RotationKB&gt;
--   &lt;XF86Save&gt;
--   &lt;XF86ScrollUp&gt;
--   &lt;XF86ScrollDown&gt;
--   &lt;XF86ScrollClick&gt;
--   &lt;XF86Send&gt;
--   &lt;XF86Spell&gt;
--   &lt;XF86SplitScreen&gt;
--   &lt;XF86Support&gt;
--   &lt;XF86TaskPane&gt;
--   &lt;XF86Terminal&gt;
--   &lt;XF86Tools&gt;
--   &lt;XF86Travel&gt;
--   &lt;XF86UserPB&gt;
--   &lt;XF86User1KB&gt;
--   &lt;XF86User2KB&gt;
--   &lt;XF86Video&gt;
--   &lt;XF86WheelButton&gt;
--   &lt;XF86Word&gt;
--   &lt;XF86Xfer&gt;
--   &lt;XF86ZoomIn&gt;
--   &lt;XF86ZoomOut&gt;
--   &lt;XF86Away&gt;
--   &lt;XF86Messenger&gt;
--   &lt;XF86WebCam&gt;
--   &lt;XF86MailForward&gt;
--   &lt;XF86Pictures&gt;
--   &lt;XF86Music&gt;
--   &lt;XF86_Switch_VT_1&gt;-&lt;XF86_Switch_VT_12&gt;
--   &lt;XF86_Ungrab&gt;
--   &lt;XF86_ClearGrab&gt;
--   &lt;XF86_Next_VMode&gt;
--   &lt;XF86_Prev_VMode&gt;
--   </pre>
mkKeymap :: XConfig l -> [(String, X ())] -> Map (KeyMask, KeySym) (X ())

-- | Given a configuration record and a list of (key sequence description,
--   action) pairs, check the key sequence descriptions for validity, and
--   warn the user (via a popup xmessage window) of any unparseable or
--   duplicate key sequences. This function is appropriate for adding to
--   your <tt>startupHook</tt>, and you are highly encouraged to do so;
--   otherwise, duplicate or unparseable keybindings will be silently
--   ignored.
--   
--   For example, you might do something like this:
--   
--   <pre>
--   main = xmonad $ myConfig
--   
--   myKeymap = [("S-M-c", kill), ...]
--   myConfig = defaultConfig {
--       ...
--       keys = \c -&gt; mkKeymap c myKeymap
--       startupHook = return () &gt;&gt; checkKeymap myConfig myKeymap
--       ...
--   }
--   </pre>
--   
--   NOTE: the <tt>return ()</tt> in the example above is very important!
--   Otherwise, you might run into problems with infinite mutual recursion:
--   the definition of myConfig depends on the definition of startupHook,
--   which depends on the definition of myConfig, ... and so on. Actually,
--   it's likely that the above example in particular would be OK without
--   the <tt>return ()</tt>, but making <tt>myKeymap</tt> take
--   <tt>myConfig</tt> as a parameter would definitely lead to problems.
--   Believe me. It, uh, happened to my friend. In... a dream. Yeah. In any
--   event, the <tt>return () &gt;&gt;</tt> introduces enough laziness to
--   break the deadlock.
checkKeymap :: XConfig l -> [(String, a)] -> X ()
mkNamedKeymap :: XConfig l -> [(String, NamedAction)] -> [((KeyMask, KeySym), NamedAction)]

-- | Parse an unmodified basic key, like <tt>"x"</tt>,
--   <tt>"<a>F1</a>"</tt>, etc.
parseKey :: ReadP KeySym


-- | This module provides helper functions to be used in
--   <tt>manageHook</tt>. Here's how you might use this:
--   
--   <pre>
--   import XMonad.Hooks.ManageHelpers
--   main =
--       xmonad defaultConfig{
--           ...
--           manageHook = composeOne [
--               isKDETrayWindow -?&gt; doIgnore,
--               transience,
--               isFullscreen -?&gt; doFullFloat,
--               resource =? "stalonetray" -?&gt; doIgnore
--           ],
--           ...
--       }
--   </pre>
module XMonad.Hooks.ManageHelpers

-- | Denotes a side of a screen. <tt>S</tt> stands for South, <tt>NE</tt>
--   for Northeast etc. <tt>C</tt> stands for Center.
data Side
SC :: Side
NC :: Side
CE :: Side
CW :: Side
SE :: Side
SW :: Side
NE :: Side
NW :: Side
C :: Side

-- | An alternative <a>ManageHook</a> composer. Unlike <a>composeAll</a> it
--   stops as soon as a candidate returns a <a>Just</a> value, effectively
--   running only the first match (whereas <a>composeAll</a> continues and
--   executes all matching rules).
composeOne :: [MaybeManageHook] -> ManageHook

-- | A helper operator for use in <a>composeOne</a>. It takes a condition
--   and an action; if the condition fails, it returns <a>Nothing</a> from
--   the <a>Query</a> so <a>composeOne</a> will go on and try the next
--   rule.
(-?>) :: Query Bool -> ManageHook -> MaybeManageHook

-- | q /=? x. if the result of q equals x, return False
(/=?) :: (Eq a) => Query a -> a -> Query Bool

-- | q &lt;==? x. if the result of q equals x, return True grouped with q
(<==?) :: (Eq a) => Query a -> a -> Query (Match a)

-- | q &lt;/=? x. if the result of q notequals x, return True grouped with
--   q
(</=?) :: (Eq a) => Query a -> a -> Query (Match a)

-- | A helper operator for use in <a>composeAll</a>. It takes a condition
--   and a function taking a grouped datum to action. If <tt>p</tt> is
--   true, it executes the resulting action.
(-->>) :: Query (Match a) -> (a -> ManageHook) -> ManageHook

-- | A helper operator for use in <a>composeOne</a>. It takes a condition
--   and a function taking a groupdatum to action. If <tt>p</tt> is true,
--   it executes the resulting action. If it fails, it returns
--   <a>Nothing</a> from the <a>Query</a> so <a>composeOne</a> will go on
--   and try the next rule.
(-?>>) :: Query (Match a) -> (a -> ManageHook) -> MaybeManageHook

-- | Return the current workspace
currentWs :: Query WorkspaceId

-- | Helper to check if a window property contains certain value.
isInProperty :: String -> String -> Query Bool

-- | A predicate to check whether a window is a KDE system tray icon.
isKDETrayWindow :: Query Bool

-- | A predicate to check whether a window wants to fill the whole screen.
--   See also <a>doFullFloat</a>.
isFullscreen :: Query Bool

-- | A predicate to check whether a window is a dialog.
isDialog :: Query Bool
pid :: Query (Maybe ProcessID)

-- | A predicate to check whether a window is Transient. It holds the
--   result which might be the window it is transient to or it might be
--   <a>Nothing</a>.
transientTo :: Query (Maybe Window)

-- | converts <a>MaybeManageHook</a>s to <a>ManageHook</a>s
maybeToDefinite :: MaybeManageHook -> ManageHook

-- | A ManageHook that may or may not have been executed; the outcome is
--   embedded in the Maybe
type MaybeManageHook = Query (Maybe (Endo WindowSet))

-- | A convenience <a>MaybeManageHook</a> that will check to see if a
--   window is transient, and then move it to its parent.
transience :: MaybeManageHook

-- | <a>transience</a> set to a <a>ManageHook</a>
transience' :: ManageHook

-- | Floats the new window in the given rectangle.
doRectFloat :: RationalRect -> ManageHook

-- | Floats the window and makes it use the whole screen. Equivalent to
--   <tt><a>doRectFloat</a> $ <a>RationalRect</a> 0 0 1 1</tt>.
doFullFloat :: ManageHook

-- | Floats a new window with its original size, but centered.
doCenterFloat :: ManageHook

-- | Floats a new window with its original size on the specified side of a
--   screen
doSideFloat :: Side -> ManageHook

-- | Floats a new window with its original size, and its top left corner at
--   a specific point on the screen (both coordinates should be in the
--   range 0 to 1).
doFloatAt :: Rational -> Rational -> ManageHook

-- | Floats a new window using a rectangle computed as a function of the
--   rectangle that it would have used by default.
doFloatDep :: (RationalRect -> RationalRect) -> ManageHook

-- | Hides window and ignores it.
doHideIgnore :: ManageHook
instance Read Side
instance Show Side
instance Eq Side


-- | Layout modfier for displaying some window (monitor) above other
--   windows
module XMonad.Layout.Monitor
data Monitor a
Monitor :: Property -> Rectangle -> Bool -> String -> Bool -> Rational -> Monitor a

-- | property which uniquely identifies monitor window
prop :: Monitor a -> Property

-- | specifies where to put monitor
rect :: Monitor a -> Rectangle

-- | is it visible by default?
visible :: Monitor a -> Bool

-- | name of monitor (useful when we have many of them)
name :: Monitor a -> String

-- | is it shown on all layouts?
persistent :: Monitor a -> Bool

-- | opacity level
opacity :: Monitor a -> Rational

-- | Template for <a>Monitor</a> record. At least <a>prop</a> and
--   <a>rect</a> should be redefined. Default settings: <a>visible</a> is
--   <a>True</a>, <a>persistent</a> is <a>False</a>.
monitor :: Monitor a

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Messages without names affect all monitors. Messages with names affect
--   only monitors whose names match.
data MonitorMessage
ToggleMonitor :: MonitorMessage
ShowMonitor :: MonitorMessage
HideMonitor :: MonitorMessage
ToggleMonitorNamed :: String -> MonitorMessage
ShowMonitorNamed :: String -> MonitorMessage
HideMonitorNamed :: String -> MonitorMessage

-- | Hides window and ignores it.
doHideIgnore :: ManageHook

-- | ManageHook which demanages monitor window and applies opacity
--   settings.
manageMonitor :: Monitor a -> ManageHook
instance Typeable MonitorMessage
instance Read MonitorMessage
instance Show MonitorMessage
instance Eq MonitorMessage
instance Read (Monitor a)
instance Show (Monitor a)
instance LayoutModifier Monitor Window
instance Message MonitorMessage


-- | Provides functions for performing a given action on all windows of the
--   current workspace.
module XMonad.Actions.WithAll

-- | Un-float all floating windows on the current workspace.
sinkAll :: X ()

-- | Execute an <a>X</a> action for each window on the current workspace.
withAll :: (Window -> X ()) -> X ()

-- | Apply a function to all windows on the current workspace.
withAll' :: (Window -> WindowSet -> WindowSet) -> X ()

-- | Kill all the windows on the current workspace.
killAll :: X ()


-- | Provides a simple binding that pushes all floating windows on the
--   current workspace back into tiling. Note that the functionality of
--   this module has been folded into the more general
--   <a>XMonad.Actions.WithAll</a>; this module simply re-exports the
--   <a>sinkAll</a> function for backwards compatibility.
module XMonad.Actions.SinkAll

-- | Un-float all floating windows on the current workspace.
sinkAll :: X ()


-- | An action to start terminals with a random background color
module XMonad.Actions.RandomBackground

-- | <tt>randomBg'</tt> produces a random hex number in the form
--   <tt>'#xxyyzz'</tt>
randomBg' :: (MonadIO m) => RandomColor -> m String

-- | <tt>randomBg</tt> starts a terminal with the background color taken
--   from <a>randomBg'</a>
--   
--   This depends on the your <a>terminal</a> configuration field accepting
--   an argument like <tt>-bg '#ff0023'</tt>
randomBg :: RandomColor -> X ()

-- | RandomColor fixes constraints when generating random colors. All
--   parameters should be in the range 0 -- 0xff
data RandomColor

-- | specify the minimum and maximum lowest values for each color channel.
RGB :: Int -> Int -> RandomColor

-- | specify the saturation and value, leaving the hue random.
HSV :: Double -> Double -> RandomColor


-- | Alternate promote function for xmonad.
--   
--   Moves the focused window to the master pane. All other windows retain
--   their order. If focus is in the master, swap it with the next window
--   in the stack. Focus stays in the master.
module XMonad.Actions.Promote

-- | Move the focused window to the master pane. All other windows retain
--   their order. If focus is in the master, swap it with the next windo in
--   the stack. Focus stays in the master.
promote :: X ()


-- | This modules provides several commands to run an external process. It
--   is composed of functions formerly defined in <a>XMonad.Util.Dmenu</a>
--   (by Spencer Janssen), <a>XMonad.Util.Dzen</a> (by glasser@mit.edu) and
--   XMonad.Util.RunInXTerm (by Andrea Rossato).
module XMonad.Util.Run

-- | Returns the output.
runProcessWithInput :: (MonadIO m) => FilePath -> [String] -> String -> m String

-- | Wait is in s (microseconds)
runProcessWithInputAndWait :: (MonadIO m) => FilePath -> [String] -> String -> Int -> m ()

-- | <a>safeSpawn</a> bypasses <a>XMonad.Core</a>'s <a>spawn</a> command,
--   because spawn passes strings to /bin/sh to be interpreted as shell
--   commands. This is often what one wants, but in many cases the passed
--   string will contain shell metacharacters which one does not want
--   interpreted as such (URLs particularly often have shell metacharacters
--   like '&amp;' in them). In this case, it is more useful to specify a
--   file or program to be run and a string to give it as an argument so as
--   to bypass the shell and be certain the program will receive the string
--   as you typed it. unsafeSpawn is internally an alias for XMonad's
--   <a>spawn</a>, to remind one that use of it can be, well, unsafe.
--   Examples:
--   
--   <pre>
--   , ((modm, xK_Print), unsafeSpawn "import -window root $HOME/xwd-$(date +%s)$$.png")
--   , ((modm, xK_d    ), safeSpawn "firefox" "")
--   </pre>
--   
--   Note that the unsafeSpawn example must be unsafe and not safe because
--   it makes use of shell interpretation by relying on <tt>$HOME</tt> and
--   interpolation, whereas the safeSpawn example can be safe because
--   Firefox doesn't need any arguments if it is just being started.
safeSpawn :: (MonadIO m) => FilePath -> [String] -> m ()

-- | Like <a>safeSpawn</a>, but only takes a program (and no arguments for
--   it). eg.
--   
--   <pre>
--   safeSpawnProg "firefox"
--   </pre>
safeSpawnProg :: (MonadIO m) => FilePath -> m ()
unsafeSpawn :: (MonadIO m) => String -> m ()

-- | Open a terminal emulator. The terminal emulator is specified in
--   <tt>defaultConfig</tt> as xterm by default. It is then asked to pass
--   the shell a command with certain options. This is unsafe in the sense
--   of <a>unsafeSpawn</a>
runInTerm :: String -> String -> X ()

-- | Run a given program in the preferred terminal emulator; see
--   <a>runInTerm</a>. This makes use of <a>safeSpawn</a>.
safeRunInTerm :: String -> String -> X ()

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
seconds :: Rational -> Int

-- | Launch an external application through the system shell and return a
--   <tt>Handle</tt> to its standard input.
spawnPipe :: (MonadIO m) => String -> m Handle

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()


-- | A module for accessing and manipulating X Window's mouse selection
--   (the buffer used in copy and pasting). <a>getSelection</a> is an
--   adaptation of Hxsel.hs and Hxput.hs from the XMonad-utils, available:
--   
--   <pre>
--   $ darcs get &lt;http://gorgias.mine.nu/repos/xmonad-utils&gt;
--   </pre>
module XMonad.Util.XSelection

-- | Returns a String corresponding to the current mouse selection in X; if
--   there is none, an empty string is returned. Note that this is really
--   only reliable for ASCII text and currently escapes or otherwise
--   mangles more complex UTF-8 characters.
getSelection :: (MonadIO m) => m String
promptSelection :: String -> X ()

-- | A wrapper around <a>getSelection</a>. Makes it convenient to run a
--   program with the current selection as an argument. This is convenient
--   for handling URLs, in particular. For example, in your Config.hs you
--   could bind a key to <tt>promptSelection "firefox"</tt>; this would
--   allow you to highlight a URL string and then immediately open it up in
--   Firefox.
--   
--   <a>promptSelection</a> passes strings through the system shell,
--   /bin/sh; if you do not wish your selected text to be interpreted or
--   mangled by the shell, use <a>safePromptSelection</a>.
--   safePromptSelection will bypass the shell using <a>safeSpawn</a> from
--   <a>XMonad.Util.Run</a>; see its documentation for more details on the
--   advantages and disadvantages of using safeSpawn.
safePromptSelection :: String -> X ()
transformPromptSelection :: (String -> String) -> String -> X ()

-- | A wrapper around <a>promptSelection</a> and its safe variant. They
--   take two parameters, the first is a function that transforms strings,
--   and the second is the application to run. The transformer essentially
--   transforms the selection in X. One example is to wrap code, such as a
--   command line action copied out of the browser to be run as
--   <tt><a>sudo</a> ++ cmd</tt> or <tt><a>su - -c "</a>++ cmd
--   ++<a>"</a></tt>.
transformSafePromptSelection :: (String -> String) -> String -> X ()


-- | A module for sending key presses to windows. This modules provides
--   generalized and specialized functions for this task.
module XMonad.Util.Paste

-- | Paste the current X mouse selection. Note that this uses
--   <a>getSelection</a> from <a>XMonad.Util.XSelection</a> and so is heir
--   to its flaws.
pasteSelection :: X ()

-- | Send a string to the window which is currently focused. This function
--   correctly handles capitalization.
pasteString :: String -> X ()

-- | Send a character to the current window. This is more low-level.
--   Remember that you must handle the case of capitalization
--   appropriately. That is, from the window's perspective:
--   
--   <pre>
--   pasteChar mod2Mask 'F' ~&gt; "f"
--   </pre>
--   
--   You would want to do something like:
--   
--   <pre>
--   pasteChar shiftMask 'F'
--   </pre>
--   
--   Note that this function makes use of <a>stringToKeysym</a>, and so
--   will probably have trouble with any <a>Char</a> outside ASCII.
pasteChar :: KeyMask -> Char -> X ()
sendKey :: KeyMask -> KeySym -> X ()

-- | The primitive. Allows you to send any combination of <a>KeyMask</a>
--   and <a>KeySym</a> to any <a>Window</a> you specify.
sendKeyWindow :: KeyMask -> KeySym -> Window -> X ()

-- | A null <a>KeyMask</a>. Used when you don't want a character or string
--   shifted, control'd, or what.
--   
--   TODO: This really should be a function in the X11 binding. When
--   noModMask shows up there, remove.
noModMask :: KeyMask


-- | An example external contrib module for XMonad. Provides a simple
--   binding to dzen2 to print the date as a popup menu.
module XMonad.Actions.SimpleDate
date :: X ()


-- | Handy wrapper for dzen. Requires dzen &gt;= 0.2.4.
module XMonad.Util.Dzen

-- | <tt>dzenConfig config s</tt> will display the string <tt>s</tt>
--   according to the configuration <tt>config</tt>. For example, to
--   display the string <tt>"foobar"</tt> with all the default settings,
--   you can simply call
--   
--   <pre>
--   dzenConfig return "foobar"
--   </pre>
--   
--   Or, to set a longer timeout, you could use
--   
--   <pre>
--   dzenConfig (timeout 10) "foobar"
--   </pre>
--   
--   You can combine configurations with the (&gt;=&gt;) operator. To
--   display <tt>"foobar"</tt> for 10 seconds on the first screen, you
--   could use
--   
--   <pre>
--   dzenConfig (timeout 10 &gt;=&gt; xScreen 0) "foobar"
--   </pre>
--   
--   As a final example, you could adapt the above to display
--   <tt>"foobar"</tt> for 10 seconds on the current screen with
--   
--   <pre>
--   dzenConfig (timeout 10 &gt;=&gt; onCurr xScreen) "foobar"
--   </pre>
dzenConfig :: DzenConfig -> String -> X ()

-- | Set the timeout, in seconds. This defaults to 3 seconds if not
--   specified.
timeout :: Rational -> DzenConfig

-- | Specify the font. Check out xfontsel to get the format of the String
--   right; if your dzen supports xft, then you can supply that here, too.
font :: String -> DzenConfig

-- | Start dzen2 on a particular screen. Only works with versions of dzen
--   that support the <a>-xs</a> argument.
xScreen :: ScreenId -> DzenConfig

-- | <tt>vCenter height sc</tt> sets the configuration to have the dzen bar
--   appear on screen <tt>sc</tt> with height <tt>height</tt>, vertically
--   centered with respect to the actual size of that screen.
vCenter :: Int -> ScreenId -> DzenConfig

-- | <tt>hCenter width sc</tt> sets the configuration to have the dzen bar
--   appear on screen <tt>sc</tt> with width <tt>width</tt>, horizontally
--   centered with respect to the actual size of that screen.
hCenter :: Int -> ScreenId -> DzenConfig

-- | <tt>center width height sc</tt> sets the configuration to have the
--   dzen bar appear on screen <tt>sc</tt> with width <tt>width</tt> and
--   height <tt>height</tt>, centered both horizontally and vertically with
--   respect to the actual size of that screen.
center :: Int -> Int -> ScreenId -> DzenConfig

-- | Take a screen-specific configuration and supply it with the screen ID
--   of the currently focused screen, according to xmonad. For example,
--   show a 100-pixel wide bar centered within the current screen, you
--   could use
--   
--   <pre>
--   dzenConfig (onCurr (hCenter 100)) "foobar"
--   </pre>
--   
--   Of course, you can still combine these with (&gt;=&gt;); for example,
--   to center the string <tt>"foobar"</tt> both horizontally and
--   vertically in a 100x14 box using the lovely Terminus font, you could
--   use
--   
--   <pre>
--   terminus = "-*-terminus-*-*-*-*-12-*-*-*-*-*-*-*"
--   dzenConfig (onCurr (center 100 14) &gt;=&gt; font terminus) "foobar"
--   </pre>
onCurr :: (ScreenId -> DzenConfig) -> DzenConfig

-- | Put the top of the dzen bar at a particular pixel.
x :: Int -> DzenConfig

-- | Put the left of the dzen bar at a particular pixel.
y :: Int -> DzenConfig

-- | Add raw command-line arguments to the configuration. These will be
--   passed on verbatim to dzen2. The default includes no arguments.
addArgs :: [String] -> DzenConfig

-- | <tt>dzen str timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> microseconds. Example usage:
--   
--   <pre>
--   dzen "Hi, mom!" (5 `seconds`)
--   </pre>
dzen :: String -> Int -> X ()

-- | <tt>dzenScreen sc str timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> microseconds, and on screen <tt>sc</tt>. Requires
--   dzen to be compiled with Xinerama support.
dzenScreen :: ScreenId -> String -> Int -> X ()

-- | <tt>dzen str args timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> seconds, passing <tt>args</tt> to dzen. Example
--   usage:
--   
--   <pre>
--   dzenWithArgs "Hi, dons!" ["-ta", "r"] (5 `seconds`)
--   </pre>
dzenWithArgs :: String -> [String] -> Int -> X ()

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
seconds :: Rational -> Int

-- | dzen wants exactly one newline at the end of its input, so this can be
--   used for your own invocations of dzen. However, all functions in this
--   module will call this for you.
chomp :: String -> String

-- | Left-to-right Kleisli composition of monads.
(>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c


-- | This module has functions to navigate through workspaces in a
--   bidimensional manner. It allows the organization of workspaces in
--   lines, and provides functions to move and shift windows in all four
--   directions (left, up, right and down) possible in a surface.
--   
--   This functionality was inspired by GNOME (finite) and KDE (infinite)
--   keybindings for workspace navigation, and by
--   <a>XMonad.Actions.CycleWS</a> for the idea of applying this approach
--   to XMonad.
module XMonad.Actions.Plane

-- | Direction to go in the plane.
data Direction
ToLeft :: Direction
ToUp :: Direction
ToRight :: Direction
ToDown :: Direction

-- | Defines the behaviour when you're trying to move out of the limits.
data Limits

-- | Ignore the function call, and keep in the same workspace.
Finite :: Limits

-- | Get on the other side, like in the Snake game.
Circular :: Limits

-- | The plan comes as a row, so it goes to the next or prev if the
--   workspaces were numbered.
Linear :: Limits

-- | The number of lines in which the workspaces will be arranged. It's
--   possible to use a number of lines that is not a divisor of the number
--   of workspaces, but the results are better when using a divisor. If
--   it's not a divisor, the last line will have the remaining workspaces.
data Lines

-- | Use <tt>gconftool-2</tt> to find out the number of lines.
GConf :: Lines

-- | Specify the number of lines explicitly.
Lines :: Int -> Lines

-- | This is the way most people would like to use this module. It attaches
--   the <a>KeyMask</a> passed as a parameter with <a>xK_Left</a>,
--   <a>xK_Up</a>, <a>xK_Right</a> and <a>xK_Down</a>, associating it with
--   <a>planeMove</a> to the corresponding <a>Direction</a>. It also
--   associates these bindings with <a>shiftMask</a> to <a>planeShift</a>.
planeKeys :: KeyMask -> Lines -> Limits -> Map (KeyMask, KeySym) (X ())

-- | Shift a window to the next workspace in <a>Direction</a>. Note that
--   this will also move to the next workspace. It's a good idea to use the
--   same <a>Lines</a> and <a>Limits</a> for all the bindings.
planeShift :: Lines -> Limits -> Direction -> X ()

-- | Move to the next workspace in <a>Direction</a>.
planeMove :: Lines -> Limits -> Direction -> X ()
instance Eq Limits
instance Enum Direction


-- | Manipulate screens ordered by physical location instead of ID
module XMonad.Actions.PhysicalScreens

-- | The type of the index of a screen by location
newtype PhysicalScreen
P :: Int -> PhysicalScreen

-- | Translate a physical screen index to a <a>ScreenId</a>
getScreen :: PhysicalScreen -> X (Maybe ScreenId)

-- | Switch to a given physical screen
viewScreen :: PhysicalScreen -> X ()

-- | Send the active window to a given physical screen
sendToScreen :: PhysicalScreen -> X ()

-- | Apply operation on a WindowSet with the WorkspaceId of the next screen
--   in the physical order as parameter.
onNextNeighbour :: (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | Apply operation on a WindowSet with the WorkspaceId of the previous
--   screen in the physical order as parameter.
onPrevNeighbour :: (WorkspaceId -> WindowSet -> WindowSet) -> X ()
instance Eq PhysicalScreen
instance Ord PhysicalScreen
instance Show PhysicalScreen
instance Read PhysicalScreen
instance Enum PhysicalScreen
instance Num PhysicalScreen
instance Integral PhysicalScreen
instance Real PhysicalScreen


-- | Define key-bindings on per-workspace basis.
module XMonad.Actions.PerWorkspaceKeys

-- | Uses supplied function to decide which action to run depending on
--   current workspace name.
chooseAction :: (String -> X ()) -> X ()

-- | If current workspace is listed, run appropriate action (only the first
--   match counts!) If it isn't listed, then run default action (marked
--   with empty string, ""), or do nothing if default isn't supplied.
bindOn :: [(String, X ())] -> X ()


-- | Control workspaces on different screens (in xinerama mode).
module XMonad.Actions.OnScreen

-- | Run any function that modifies the stack on a given screen. This
--   function will also need to know which Screen to focus after the
--   function has been run.
onScreen :: (WindowSet -> WindowSet) -> Focus -> ScreenId -> WindowSet -> WindowSet

-- | A variation of <tt>onScreen</tt> which will take any <tt>X ()</tt>
--   function and run it on the given screen. Warning: This function will
--   change focus even if the function it's supposed to run doesn't
--   succeed.
onScreen' :: X () -> Focus -> ScreenId -> X ()

-- | Focus data definitions
data Focus

-- | always focus the new screen
FocusNew :: Focus

-- | always keep the focus on the current screen
FocusCurrent :: Focus

-- | always focus tag i on the new stack
FocusTag :: WorkspaceId -> Focus

-- | focus tag i only if workspace with tag i is visible on the old stack
FocusTagVisible :: WorkspaceId -> Focus

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible use <tt>view</tt> to switch focus to the workspace <tt>i</tt>.
viewOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible use <tt>greedyView</tt> to switch the current workspace with
--   workspace <tt>i</tt>.
greedyViewOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible do nothing.
onlyOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | <tt>toggleOrView</tt> as in <a>XMonad.Actions.CycleWS</a> for
--   <tt>onScreen</tt> with view
toggleOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | <tt>toggleOrView</tt> from <a>XMonad.Actions.CycleWS</a> for
--   <tt>onScreen</tt> with greedyView
toggleGreedyOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet


-- | This module provides helper functions for dealing with window borders.
module XMonad.Actions.NoBorders

-- | Toggle the border of the currently focused window. To use it, add a
--   keybinding like so:
--   
--   <pre>
--   , ((modm,  xK_g ),   withFocused toggleBorder)
--   </pre>
toggleBorder :: Window -> X ()


-- | Alternative to <tt>XMonad.Operations.sendMessage</tt> that provides
--   knowledge of whether the message was handled, and utility functions
--   based on this facility.
module XMonad.Actions.MessageFeedback

-- | Behaves like <tt>XMonad.Operations.sendMessage</tt>, but returns True
--   of the message was handled by the layout, False otherwise.
send :: (Message a) => a -> X Bool

-- | Sends the first message, and if it was not handled, sends the second.
--   Returns True if either message was handled, False otherwise.
tryMessage :: (Message a, Message b) => a -> b -> X Bool
tryMessage_ :: (Message a, Message b) => a -> b -> X ()

-- | Tries sending every message of the list in order until one of them is
--   handled. Returns True if one of the messages was handled, False
--   otherwise.
tryInOrder :: [SomeMessage] -> X Bool
tryInOrder_ :: [SomeMessage] -> X ()

-- | Convenience shorthand for <a>SomeMessage</a>.
sm :: (Message a) => a -> SomeMessage
sendSM :: SomeMessage -> X Bool
sendSM_ :: SomeMessage -> X ()


-- | This module allows you to associate the X titles of windows with them.
module XMonad.Util.NamedWindows
data NamedWindow
getName :: Window -> X NamedWindow
withNamedWindow :: (NamedWindow -> X ()) -> X ()
unName :: NamedWindow -> Window
instance Show NamedWindow
instance Ord NamedWindow
instance Eq NamedWindow


-- | A module for abstracting a font facility over Core fonts and Xft
module XMonad.Util.Font
data XMonadFont
Core :: FontStruct -> XMonadFont
Utf8 :: FontSet -> XMonadFont
Xft :: XftFont -> XMonadFont

-- | When initXMF gets a font name that starts with 'xft:' it switches to
--   the Xft backend Example: 'xft: Sans-10'
initXMF :: String -> X XMonadFont
releaseXMF :: XMonadFont -> X ()

-- | Given a fontname returns the font structure. If the font name is not
--   valid the default font will be loaded and returned.
initCoreFont :: String -> X FontStruct
releaseCoreFont :: FontStruct -> X ()
initUtf8Font :: String -> X FontSet
releaseUtf8Font :: FontSet -> X ()

-- | String position
data Align
AlignCenter :: Align
AlignRight :: Align
AlignLeft :: Align
AlignRightOffset :: Int -> Align

-- | Return the string x and y <a>Position</a> in a <a>Rectangle</a>, given
--   a <a>FontStruct</a> and the <a>Align</a>ment
stringPosition :: (Functor m, MonadIO m) => Display -> XMonadFont -> Rectangle -> Align -> String -> m (Position, Position)
textWidthXMF :: (MonadIO m) => Display -> XMonadFont -> String -> m Int
textExtentsXMF :: (MonadIO m) => XMonadFont -> String -> m (Int32, Int32)
printStringXMF :: (Functor m, MonadIO m) => Display -> Drawable -> XMonadFont -> GC -> String -> String -> Position -> Position -> String -> m ()

-- | Get the Pixel value for a named color: if an invalid name is given the
--   black pixel will be returned.
stringToPixel :: (Functor m, MonadIO m) => Display -> String -> m Pixel
decodeInput :: String -> String
encodeOutput :: String -> String
instance Show Align
instance Read Align


-- | A module for painting on the screen
module XMonad.Util.XUtils

-- | Compute the weighted average the colors of two given Pixel values.
averagePixels :: Pixel -> Pixel -> Double -> X Pixel

-- | Create a simple window given a rectangle. If Nothing is given only the
--   exposureMask will be set, otherwise the Just value. Use
--   <a>showWindow</a> to map and hideWindow to unmap.
createNewWindow :: Rectangle -> Maybe EventMask -> String -> Bool -> X Window

-- | Map a window
showWindow :: Window -> X ()

-- | the list version
showWindows :: [Window] -> X ()

-- | unmap a window
hideWindow :: Window -> X ()

-- | the list version
hideWindows :: [Window] -> X ()

-- | destroy a window
deleteWindow :: Window -> X ()

-- | the list version
deleteWindows :: [Window] -> X ()

-- | Fill a window with a rectangle and a border
paintWindow :: Window -> Dimension -> Dimension -> Dimension -> String -> String -> X ()

-- | Fill a window with a rectangle and a border, and write | a number of
--   strings to given positions
paintAndWrite :: Window -> XMonadFont -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> [Align] -> [String] -> X ()

-- | Get the Pixel value for a named color: if an invalid name is given the
--   black pixel will be returned.
stringToPixel :: (Functor m, MonadIO m) => Display -> String -> m Pixel

-- | Short-hand for <a>fromIntegral</a>
fi :: (Integral a, Num b) => a -> b


-- | This is a pure layout modifier that will let you move and resize
--   windows with the keyboard in any layout.
module XMonad.Layout.WindowArranger

-- | A layout modifier to float the windows in a workspace
windowArrange :: l a -> ModifiedLayout WindowArranger l a

-- | A layout modifier to float all the windows in a workspace
windowArrangeAll :: l a -> ModifiedLayout WindowArranger l a
data WindowArrangerMsg
DeArrange :: WindowArrangerMsg
Arrange :: WindowArrangerMsg
IncreaseLeft :: Int -> WindowArrangerMsg
IncreaseRight :: Int -> WindowArrangerMsg
IncreaseUp :: Int -> WindowArrangerMsg
IncreaseDown :: Int -> WindowArrangerMsg
DecreaseLeft :: Int -> WindowArrangerMsg
DecreaseRight :: Int -> WindowArrangerMsg
DecreaseUp :: Int -> WindowArrangerMsg
DecreaseDown :: Int -> WindowArrangerMsg
MoveLeft :: Int -> WindowArrangerMsg
MoveRight :: Int -> WindowArrangerMsg
MoveUp :: Int -> WindowArrangerMsg
MoveDown :: Int -> WindowArrangerMsg
SetGeometry :: Rectangle -> WindowArrangerMsg
data WindowArranger a

-- | Given a function to be applied to each member of ta list, and a
--   function to check a condition by processing this transformed member
--   with something, you get the first member that satisfy the condition,
--   or an empty list.
memberFromList :: (b -> c) -> (c -> a -> Bool) -> a -> [b] -> [b]

-- | Given a function to be applied to each member of a list, and a
--   function to check a condition by processing this transformed member
--   with the members of a list, you get the list of members that satisfy
--   the condition.
listFromList :: (b -> c) -> (c -> [a] -> Bool) -> [a] -> [b] -> [b]

-- | Get the list of elements to be deleted and the list of elements to be
--   added to the first list in order to get the second list.
diff :: (Eq a) => ([a], [a]) -> ([a], [a])
instance Typeable WindowArrangerMsg
instance (Read a) => Read (WindowArranger a)
instance (Show a) => Show (WindowArranger a)
instance (Read a) => Read (ArrangedWindow a)
instance (Show a) => Show (ArrangedWindow a)
instance (Show a, Read a, Eq a) => LayoutModifier WindowArranger a
instance Message WindowArrangerMsg


-- | A layout in the spirit of <a>XMonad.Layout.ResizableTile</a>, but with
--   the option to use the mouse to adjust the layout.
module XMonad.Layout.MouseResizableTile
mouseResizableTile :: MouseResizableTile a
mouseResizableTileMirrored :: MouseResizableTile a
data MRTMessage
ShrinkSlave :: MRTMessage
ExpandSlave :: MRTMessage
instance Typeable MRTMessage
instance Show (MouseResizableTile a)
instance Read (MouseResizableTile a)
instance Show DraggerInfo
instance Read DraggerInfo
instance LayoutClass MouseResizableTile Window
instance Message MRTMessage


-- | Useful in a dual-head setup: Looks at the requested geometry of new
--   windows and moves them to the workspace of the non-focused screen if
--   necessary.
module XMonad.Hooks.WorkspaceByPos
workspaceByPos :: ManageHook


-- | Layouts that splits the screen either horizontally or vertically and
--   shows two windows. The first window is always the master window, and
--   the other is either the currently focused window or the second window
--   in layout order.
module XMonad.Layout.DragPane
dragPane :: DragType -> Double -> Double -> DragPane a
data DragPane a
data DragType
Horizontal :: DragType
Vertical :: DragType
instance Typeable SetFrac
instance Show SetFrac
instance Read SetFrac
instance Eq SetFrac
instance Show DragType
instance Read DragType
instance Show (DragPane a)
instance Read (DragPane a)
instance Message SetFrac
instance LayoutClass DragPane a


-- | A basic floating layout like SimpleFloat but without the decoration.
module XMonad.Layout.SimplestFloat

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
simplestFloat :: (Eq a) => (ModifiedLayout WindowArranger SimplestFloat) a
data SimplestFloat a
instance Show (SimplestFloat a)
instance Read (SimplestFloat a)
instance LayoutClass SimplestFloat Window


-- | This is a layout modifier that will show the workspace name
module XMonad.Layout.ShowWName

-- | A layout modifier to show the workspace name when switching
showWName :: l a -> ModifiedLayout ShowWName l a

-- | A layout modifier to show the workspace name when switching. It is
--   possible to provide a custom configuration.
showWName' :: SWNConfig -> l a -> ModifiedLayout ShowWName l a
defaultSWNConfig :: SWNConfig
data SWNConfig
SWNC :: String -> String -> String -> Rational -> SWNConfig

-- | Font name
swn_font :: SWNConfig -> String

-- | Background color
swn_bgcolor :: SWNConfig -> String

-- | String color
swn_color :: SWNConfig -> String

-- | Time in seconds of the name visibility
swn_fade :: SWNConfig -> Rational
instance Read SWNConfig
instance Show SWNConfig
instance Read (ShowWName a)
instance Show (ShowWName a)
instance LayoutModifier ShowWName a


-- | Focus the nth window of the current workspace.
module XMonad.Actions.FocusNth

-- | Give focus to the nth window of the current workspace.
focusNth :: Int -> X ()
focusNth' :: Int -> Stack a -> Stack a


-- | Like <a>XMonad.Actions.Plane</a> for an arbitrary number of
--   dimensions.
module XMonad.Actions.WorkspaceCursors
focusDepth :: Cursors t -> Int

-- | makeCursors requires a nonempty string, and each sublist must be
--   nonempty
makeCursors :: [[String]] -> Cursors String

-- | List of elements of a structure.
toList :: (Foldable t) => t a -> [a]

-- | The state is stored in the <a>WorkspaceCursors</a> layout modifier.
--   Put this as your outermost modifier, unless you want different cursors
--   at different times (using <a>XMonad.Layout.MultiToggle</a>)
workspaceCursors :: Cursors String -> l a -> ModifiedLayout WorkspaceCursors l a
data WorkspaceCursors a
getFocus :: Cursors b -> b

-- | <tt>modifyLayer</tt> is used to change the focus at a given depth
modifyLayer :: (Stack (Cursors String) -> Stack (Cursors String)) -> Int -> X ()

-- | example usages are <a>shiftLayer</a> and <a>shiftModifyLayer</a>
modifyLayer' :: (Stack (Cursors String) -> X (Stack (Cursors String))) -> Int -> X ()

-- | <tt>shiftModifyLayer</tt> is the same as <a>modifyLayer</a>, but also
--   shifts the currently focused window to the new workspace
shiftModifyLayer :: (Stack (Cursors String) -> Stack (Cursors WorkspaceId)) -> Int -> X ()

-- | <tt>shiftLayer</tt> is the same as <a>shiftModifyLayer</a>, but the
--   focus remains on the current workspace.
shiftLayer :: (Stack (Cursors String) -> Stack (Cursors WorkspaceId)) -> Int -> X ()
focusNth' :: Int -> Stack a -> Stack a

-- | non-wrapping version of <a>focusUp'</a>
noWrapUp :: Stack t -> Stack t

-- | non-wrapping version of <a>focusDown'</a>
noWrapDown :: Stack t -> Stack t
instance Typeable ChangeCursors
instance Typeable1 WorkspaceCursors
instance Typeable1 Cursors
instance Read (WorkspaceCursors a)
instance Show (WorkspaceCursors a)
instance (Eq a) => Eq (Cursors a)
instance (Show a) => Show (Cursors a)
instance (Read a) => Read (Cursors a)
instance LayoutModifier WorkspaceCursors a
instance Message ChangeCursors
instance Functor Cursors
instance Foldable Cursors


-- | Move and resize floating windows.
module XMonad.Actions.FloatKeys

-- | <tt>keysMoveWindow (dx, dy)</tt> moves the window by <tt>dx</tt>
--   pixels to the right and <tt>dy</tt> pixels down.
keysMoveWindow :: D -> Window -> X ()

-- | <tt>keysMoveWindowTo (x, y) (gx, gy)</tt> moves the window relative
--   point <tt>(gx, gy)</tt> to the point <tt>(x,y)</tt>, where
--   <tt>(gx,gy)</tt> gives a position relative to the window border, i.e.
--   <tt>gx = 0</tt> is the left border, <tt>gx = 1</tt> is the right
--   border, <tt>gy = 0</tt> is the top border, and <tt>gy = 1</tt> the
--   bottom border.
--   
--   For example, on a 1024x768 screen:
--   
--   <pre>
--   keysMoveWindowTo (512,384) (1%2, 1%2) -- center the window on screen
--   keysMoveWindowTo (1024,0) (1, 0)      -- put window in the top right corner
--   </pre>
keysMoveWindowTo :: P -> G -> Window -> X ()

-- | <tt>keysResizeWindow (dx, dy) (gx, gy)</tt> changes the width by
--   <tt>dx</tt> and the height by <tt>dy</tt>, leaving the window-relative
--   point <tt>(gx, gy)</tt> fixed.
--   
--   For example:
--   
--   <pre>
--   keysResizeWindow (10, 0) (0, 0)      -- make the window 10 pixels larger to the right
--   keysResizeWindow (10, 0) (0, 1%2)    -- does the same, unless sizeHints are applied
--   keysResizeWindow (10, 10) (1%2, 1%2) -- add 5 pixels on each side
--   keysResizeWindow (-10, -10) (0, 1)   -- shrink the window in direction of the bottom-left corner
--   </pre>
keysResizeWindow :: D -> G -> Window -> X ()

-- | <tt>keysAbsResizeWindow (dx, dy) (ax, ay)</tt> changes the width by
--   <tt>dx</tt> and the height by <tt>dy</tt>, leaving the screen absolute
--   point <tt>(ax, ay)</tt> fixed.
--   
--   For example:
--   
--   <pre>
--   keysAbsResizeWindow (10, 10) (0, 0)   -- enlarge the window; if it is not in the top-left corner it will also be moved down and to the right.
--   </pre>
keysAbsResizeWindow :: D -> D -> Window -> X ()


-- | Automatic placement of floating windows.
module XMonad.Hooks.Place

-- | Repositions the focused window according to a placement policy. Works
--   for both "real" floating windows and windows in a
--   <a>WindowArranger</a>-based layout.
placeFocused :: Placement -> X ()

-- | Hook to automatically place windows when they are created.
placeHook :: Placement -> ManageHook

-- | The type of placement policies
data Placement

-- | Try to place windows with as little overlap as possible
smart :: (Rational, Rational) -> Placement
simpleSmart :: Placement

-- | Place windows at a fixed position
fixed :: (Rational, Rational) -> Placement

-- | Place windows under the mouse
underMouse :: (Rational, Rational) -> Placement

-- | Apply the given placement policy, constraining the placed windows
--   inside the screen boundaries.
inBounds :: Placement -> Placement

-- | Same as <a>inBounds</a>, but allows specifying gaps along the screen's
--   edges
withGaps :: (Dimension, Dimension, Dimension, Dimension) -> Placement -> Placement

-- | Compute the new position of a window according to a placement policy.
purePlaceWindow :: Placement -> Rectangle -> [Rectangle] -> (Position, Position) -> Rectangle -> Rectangle
instance (Show a) => Show (SmartRectangle a)
instance (Eq a) => Eq (SmartRectangle a)
instance Show Placement
instance Read Placement
instance Eq Placement


-- | Resize floating windows from any corner.
module XMonad.Actions.FlexibleResize

-- | Resize a floating window from whichever corner the mouse is closest
--   to.
mouseResizeWindow :: Window -> X ()

-- | Resize a floating window from whichever corner or edge the mouse is
--   closest to.
mouseResizeEdgeWindow :: Rational -> Window -> X ()


-- | Move and resize floating windows without warping the mouse.
module XMonad.Actions.FlexibleManipulate

-- | Manipulate the window based on discrete pick regions; the window is
--   divided into regions by thirds along each axis.
--   
--   Scale/reposition the window by factors obtained from the mouse
--   position by linear interpolation. Dragging precisely on a corner
--   resizes that corner; dragging precisely in the middle moves the window
--   without resizing; anything else is an interpolation between the two.
--   
--   Only resize the window, based on the window quadrant the mouse is in.
--   
--   Only reposition the window.
--   
--   Given an interpolation function, implement an appropriate window
--   manipulation action.
mouseWindow :: (Double -> Double) -> Window -> X ()
discrete :: Double -> Double
linear :: Double -> Double
resize :: Double -> Double
position :: Double -> Double
instance Fractional Pnt
instance Num Pnt


-- | Find an empty workspace.
module XMonad.Actions.FindEmptyWorkspace

-- | Find and view an empty workspace. Do nothing if all workspaces are in
--   use.
viewEmptyWorkspace :: X ()

-- | Tag current window to an empty workspace and view it. Do nothing if
--   all workspaces are in use.
tagToEmptyWorkspace :: X ()


-- | Module for storing custom mutable state in xmonad.
module XMonad.Util.ExtensibleState

-- | Add a value to the extensible state field. A previously stored value
--   with the same type will be overwritten. (More precisely: A value whose
--   string representation of its type is equal to the new one's)
put :: (ExtensionClass a) => a -> X ()

-- | Apply a function to a stored value of the matching type or the initial
--   value if there is none.
modify :: (ExtensionClass a) => (a -> a) -> X ()

-- | Remove the value from the extensible state field that has the same
--   type as the supplied argument
remove :: (ExtensionClass a) => a -> X ()

-- | Try to retrieve a value of the requested type, return an initial value
--   if there is no such value.
get :: (ExtensionClass a) => X a
gets :: (ExtensionClass a) => (a -> b) -> X b


-- | UrgencyHook lets you configure an action to occur when a window
--   demands your attention. (In traditional WMs, this takes the form of
--   "flashing" on your "taskbar." Blech.)
module XMonad.Hooks.UrgencyHook

-- | This is the method to enable an urgency hook. It uses the default
--   <a>urgencyConfig</a> to control behavior. To change this, use
--   <a>withUrgencyHookC</a> instead.
withUrgencyHook :: (LayoutClass l Window, UrgencyHook h) => h -> XConfig l -> XConfig l

-- | This lets you modify the defaults set in <a>urgencyConfig</a>. An
--   example:
--   
--   <pre>
--   withUrgencyHookC dzenUrgencyHook { ... } urgencyConfig { suppressWhen = Focused }
--   </pre>
--   
--   (Don't type the <tt>...</tt>, you dolt.) See <a>UrgencyConfig</a> for
--   details on configuration.
withUrgencyHookC :: (LayoutClass l Window, UrgencyHook h) => h -> UrgencyConfig -> XConfig l -> XConfig l

-- | Global configuration, applied to all types of <a>UrgencyHook</a>. See
--   <a>urgencyConfig</a> for the defaults.
data UrgencyConfig
UrgencyConfig :: SuppressWhen -> RemindWhen -> UrgencyConfig

-- | when to trigger the urgency hook
suppressWhen :: UrgencyConfig -> SuppressWhen

-- | when to re-trigger the urgency hook
remindWhen :: UrgencyConfig -> RemindWhen

-- | The default <a>UrgencyConfig</a>. suppressWhen = Visible, remindWhen =
--   Dont. Use a variation of this in your config just as you use a
--   variation of defaultConfig for your xmonad definition.
urgencyConfig :: UrgencyConfig

-- | A set of choices as to <i>when</i> you should (or rather, shouldn't)
--   be notified of an urgent window. The default is <a>Visible</a>. Prefix
--   each of the following with "don't bug me when":
data SuppressWhen

-- | the window is currently visible
Visible :: SuppressWhen

-- | the window is on the currently focused physical screen
OnScreen :: SuppressWhen

-- | the window is currently focused
Focused :: SuppressWhen

-- | ... aww, heck, go ahead and bug me, just in case.
Never :: SuppressWhen

-- | A set of choices as to when you want to be re-notified of an urgent
--   window. Perhaps you focused on something and you miss the dzen popup
--   bar. Or you're AFK. Or you feel the need to be more distracted. I
--   don't care.
--   
--   The interval arguments are in seconds. See the <a>minutes</a> helper.
data RemindWhen

-- | triggering once is enough
Dont :: RemindWhen

-- | repeat <a>arg1</a> times every <a>arg2</a> seconds
Repeatedly :: Int -> Interval -> RemindWhen

-- | repeat every <a>arg1</a> until the urgency hint is cleared
Every :: Interval -> RemindWhen

-- | Focuses the most recently urgent window. Good for what ails ya -- I
--   mean, your keybindings. Example keybinding:
--   
--   <pre>
--   , ((modm              , xK_BackSpace), focusUrgent)
--   </pre>
focusUrgent :: X ()

-- | Just makes the urgents go away. Example keybinding:
--   
--   <pre>
--   , ((modm .|. shiftMask, xK_BackSpace), clearUrgents)
--   </pre>
clearUrgents :: X ()

-- | Flashes when a window requests your attention and you can't see it.
--   Defaults to a duration of five seconds, and no extra args to dzen. See
--   <a>DzenUrgencyHook</a>.
dzenUrgencyHook :: DzenUrgencyHook

-- | Your set of options for configuring a dzenUrgencyHook.
data DzenUrgencyHook
DzenUrgencyHook :: Int -> [String] -> DzenUrgencyHook

-- | number of microseconds to display the dzen (hence, you'll probably
--   want to use <a>seconds</a>)
duration :: DzenUrgencyHook -> Int

-- | list of extra args (as <a>String</a>s) to pass to dzen
args :: DzenUrgencyHook -> [String]
data NoUrgencyHook
NoUrgencyHook :: NoUrgencyHook

-- | A hook which will automatically send you to anything which sets the
--   urgent flag (as opposed to printing some sort of message. You would
--   use this as usual, eg.
--   
--   <pre>
--   withUrgencyHook FocusHook $ myconfig { ...
--   </pre>
data FocusHook
FocusHook :: FocusHook

-- | A prettified way of multiplying by 60. Use like: <tt>(5
--   <a>minutes</a>)</tt>.
minutes :: Rational -> Rational

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
seconds :: Rational -> Int

-- | X action that returns a list of currently urgent windows. You might
--   use it, or <a>withUrgents</a>, in your custom logHook, to display the
--   workspaces that contain urgent windows.
readUrgents :: X [Window]

-- | An HOF version of <a>readUrgents</a>, for those who prefer that sort
--   of thing.
withUrgents :: ([Window] -> X a) -> X a

-- | For debugging purposes, really.
data StdoutUrgencyHook
StdoutUrgencyHook :: StdoutUrgencyHook

-- | Spawn a commandline thing, appending the window id to the prefix
--   string you provide. (Make sure to add a space if you need it.) Do your
--   crazy xcompmgr thing.
newtype SpawnUrgencyHook
SpawnUrgencyHook :: String -> SpawnUrgencyHook

-- | The class definition, and some pre-defined instances.
class (Read h, Show h) => UrgencyHook h
urgencyHook :: (UrgencyHook h) => h -> Window -> X ()
instance Typeable Reminder
instance Typeable Urgents
instance Read StdoutUrgencyHook
instance Show StdoutUrgencyHook
instance Read SpawnUrgencyHook
instance Show SpawnUrgencyHook
instance Read FocusHook
instance Show FocusHook
instance Read DzenUrgencyHook
instance Show DzenUrgencyHook
instance Read NoUrgencyHook
instance Show NoUrgencyHook
instance (Read h) => Read (WithUrgencyHook h)
instance (Show h) => Show (WithUrgencyHook h)
instance Show Reminder
instance Read Reminder
instance Eq Reminder
instance Read RemindWhen
instance Show RemindWhen
instance Read SuppressWhen
instance Show SuppressWhen
instance Read UrgencyConfig
instance Show UrgencyConfig
instance Read Urgents
instance Show Urgents
instance UrgencyHook StdoutUrgencyHook
instance UrgencyHook SpawnUrgencyHook
instance UrgencyHook FocusHook
instance UrgencyHook DzenUrgencyHook
instance UrgencyHook NoUrgencyHook
instance ExtensionClass [Reminder]
instance ExtensionClass Urgents


-- | A layout modifier and a class for easily creating decorated layouts.
module XMonad.Layout.Decoration

-- | A layout modifier that, with a <a>Shrinker</a>, a <a>Theme</a>, a
--   <a>DecorationStyle</a>, and a layout, will decorate this layout
--   according to the decoration style provided.
--   
--   For some usage examples see <a>XMonad.Layout.DecorationMadness</a>.
decoration :: (DecorationStyle ds a, Shrinker s) => s -> Theme -> ds a -> l a -> ModifiedLayout (Decoration ds s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> Theme

-- | Color of the active window
activeColor :: Theme -> String

-- | Color of the inactive window
inactiveColor :: Theme -> String

-- | Color of the urgent window
urgentColor :: Theme -> String

-- | Color of the border of the active window
activeBorderColor :: Theme -> String

-- | Color of the border of the inactive window
inactiveBorderColor :: Theme -> String

-- | Color of the border of the urgent window
urgentBorderColor :: Theme -> String

-- | Color of the text of the active window
activeTextColor :: Theme -> String

-- | Color of the text of the inactive window
inactiveTextColor :: Theme -> String

-- | Color of the text of the urgent window
urgentTextColor :: Theme -> String

-- | Font name
fontName :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
decoWidth :: Theme -> Dimension

-- | Height of the decorations
decoHeight :: Theme -> Dimension

-- | Extra text to appear in a window's title bar
windowTitleAddons :: Theme -> [(String, Align)]

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme

-- | The <a>Decoration</a> <a>LayoutModifier</a>. This data type is an
--   instance of the <a>LayoutModifier</a> class. This data type will be
--   passed, together with a layout, to the <a>ModifiedLayout</a> type
--   constructor to modify the layout by adding decorations according to a
--   <a>DecorationStyle</a>.
data Decoration ds s a

-- | A <a>Decoration</a> layout modifier will handle <a>SetTheme</a>, a
--   message to dynamically change the decoration <a>Theme</a>.
data DecorationMsg
SetTheme :: Theme -> DecorationMsg

-- | The <a>DecorationStyle</a> class, defines methods used in the
--   implementation of the <a>Decoration</a> <a>LayoutModifier</a>
--   instance. A type instance of this class is passed to the
--   <a>Decoration</a> type in order to decorate a layout, by using these
--   methods.
class (Read (ds a), Show (ds a), Eq a) => DecorationStyle ds a
describeDeco :: (DecorationStyle ds a) => ds a -> String
shrink :: (DecorationStyle ds a) => ds a -> Rectangle -> Rectangle -> Rectangle
decorationEventHook :: (DecorationStyle ds a) => ds a -> DecorationState -> Event -> X ()
decorationCatchClicksHook :: (DecorationStyle ds a) => ds a -> Window -> Int -> Int -> X Bool
decorationWhileDraggingHook :: (DecorationStyle ds a) => ds a -> CInt -> CInt -> (Window, Rectangle) -> Position -> Position -> X ()
decorationAfterDraggingHook :: (DecorationStyle ds a) => ds a -> (Window, Rectangle) -> Window -> X ()
pureDecoration :: (DecorationStyle ds a) => ds a -> Dimension -> Dimension -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> Maybe Rectangle
decorate :: (DecorationStyle ds a) => ds a -> Dimension -> Dimension -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> X (Maybe Rectangle)

-- | The default <a>DecorationStyle</a>, with just the default methods'
--   implementations.
data DefaultDecoration a
DefaultDecoration :: DefaultDecoration a
class (Read s, Show s) => Shrinker s
shrinkIt :: (Shrinker s) => s -> String -> [String]
data DefaultShrinker
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
shrinkWhile :: (String -> [String]) -> (String -> X Bool) -> String -> X String

-- | True if the window is in the <tt>Stack</tt>. The <a>Window</a> comes
--   second to facilitate list processing, even though <tt>w `isInStack`
--   s</tt> won't work...;)
isInStack :: (Eq a) => Stack a -> a -> Bool

-- | Given a <a>Rectangle</a> and a list of <a>Rectangle</a>s is True if
--   the <a>Rectangle</a> is not completely contained by any
--   <a>Rectangle</a> of the list.
isVisible :: Rectangle -> [Rectangle] -> Bool

-- | The contrary of <a>isVisible</a>.
isInvisible :: Rectangle -> [Rectangle] -> Bool

-- | True is the first <a>Rectangle</a> is totally within the second
--   <a>Rectangle</a>.
isWithin :: Rectangle -> Rectangle -> Bool

-- | Short-hand for <a>fromIntegral</a>
fi :: (Integral a, Num b) => a -> b
findWindowByDecoration :: Window -> DecorationState -> Maybe (OrigWin, (Window, Maybe Rectangle))
instance Typeable DecorationMsg
instance Read (DefaultDecoration a)
instance Show (DefaultDecoration a)
instance (Show s, Show (ds a)) => Show (Decoration ds s a)
instance (Read s, Read (ds a)) => Read (Decoration ds s a)
instance Show Theme
instance Read Theme
instance Shrinker DefaultShrinker
instance Read DefaultShrinker
instance Show DefaultShrinker
instance Read CustomShrink
instance Show CustomShrink
instance (DecorationStyle ds Window, Shrinker s) => LayoutModifier (Decoration ds s) Window
instance (Eq a) => DecorationStyle DefaultDecoration a
instance Message DecorationMsg


-- | A layout modifier to resize windows with the mouse by grabbing the
--   window's lower right corner.
--   
--   This module must be used together with
--   <a>XMonad.Layout.WindowArranger</a>.
module XMonad.Actions.MouseResize
mouseResize :: l a -> ModifiedLayout MouseResize l a
data MouseResize a
MR :: [((a, Rectangle), Maybe a)] -> MouseResize a
instance LayoutModifier MouseResize Window
instance Read (MouseResize a)
instance Show (MouseResize a)


-- | A tabbed layout for the Xmonad Window Manager
module XMonad.Layout.Tabbed

-- | A tabbed layout with the default xmonad Theme.
--   
--   This is a minimal working configuration:
--   
--   <pre>
--   import XMonad
--   import XMonad.Layout.Tabbed
--   main = xmonad defaultConfig { layoutHook = simpleTabbed }
--   </pre>
simpleTabbed :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbed :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to any layout.
addTabs :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a
simpleTabbedAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window
tabbedAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A bottom-tabbed layout with the default xmonad Theme.
simpleTabbedBottom :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs at the bottom and the possibility to set
--   a custom shrinker and theme.
tabbedBottom :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to the bottom of any layout.
addTabsBottom :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A bottom-tabbed layout with the default xmonad Theme.
simpleTabbedBottomAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window
tabbedBottomAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsBottomAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> Theme

-- | Color of the active window
activeColor :: Theme -> String

-- | Color of the inactive window
inactiveColor :: Theme -> String

-- | Color of the urgent window
urgentColor :: Theme -> String

-- | Color of the border of the active window
activeBorderColor :: Theme -> String

-- | Color of the border of the inactive window
inactiveBorderColor :: Theme -> String

-- | Color of the border of the urgent window
urgentBorderColor :: Theme -> String

-- | Color of the text of the active window
activeTextColor :: Theme -> String

-- | Color of the text of the inactive window
inactiveTextColor :: Theme -> String

-- | Color of the text of the urgent window
urgentTextColor :: Theme -> String

-- | Font name
fontName :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
decoWidth :: Theme -> Dimension

-- | Height of the decorations
decoHeight :: Theme -> Dimension

-- | Extra text to appear in a window's title bar
windowTitleAddons :: Theme -> [(String, Align)]

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme
data TabbedDecoration a
Tabbed :: TabbarLocation -> TabbarShown -> TabbedDecoration a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: (Shrinker s) => s -> String -> [String]
instance Read (TabbedDecoration a)
instance Show (TabbedDecoration a)
instance Read TabbarShown
instance Show TabbarShown
instance Eq TabbarShown
instance Read TabbarLocation
instance Show TabbarLocation
instance (Eq a) => DecorationStyle TabbedDecoration a


-- | A (hopefully) growing collection of themes for decorated layouts.
module XMonad.Util.Themes
listOfThemes :: [ThemeInfo]
ppThemeInfo :: ThemeInfo -> String

-- | The default xmonad theme, by David Roundy.
xmonadTheme :: ThemeInfo

-- | Small decorations with a Ion3 remembrance, by Andrea Rossato.
smallClean :: ThemeInfo

-- | Ffrom Robert Manea's prompt theme.
robertTheme :: ThemeInfo

-- | deifl's Theme, by deifl.
deiflTheme :: ThemeInfo

-- | oxymor00n's theme, by Tom Rauchenwald.
oxymor00nTheme :: ThemeInfo

-- | Don's prefered colors - from DynamicLog...;)
donaldTheme :: ThemeInfo
wfarrTheme :: ThemeInfo

-- | Forest colours, by Kathryn Andersen
kavonForestTheme :: ThemeInfo

-- | Lake (blue/green) colours, by Kathryn Andersen
kavonLakeTheme :: ThemeInfo

-- | Peacock colours, by Kathryn Andersen
kavonPeacockTheme :: ThemeInfo

-- | Violet-Green colours, by Kathryn Andersen
kavonVioGreenTheme :: ThemeInfo

-- | Blue colours, by Kathryn Andersen
kavonBluesTheme :: ThemeInfo

-- | Autumn colours, by Kathryn Andersen
kavonAutumnTheme :: ThemeInfo

-- | Fire colours, by Kathryn Andersen
kavonFireTheme :: ThemeInfo

-- | Christmas colours, by Kathryn Andersen
kavonChristmasTheme :: ThemeInfo
data ThemeInfo
TI :: String -> String -> String -> Theme -> ThemeInfo
themeName :: ThemeInfo -> String
themeAuthor :: ThemeInfo -> String
themeDescription :: ThemeInfo -> String
theme :: ThemeInfo -> Theme


-- | This layout modifier will allow to resize windows by dragging their
--   borders with the mouse. However, it only works in layouts or modified
--   layouts that react to the <a>SetGeometry</a> message.
--   <a>XMonad.Layout.WindowArranger</a> can be used to create such a
--   setup, but it is probably must useful in a floating layout such as
--   <a>XMonad.Layout.PositionStoreFloat</a> with which it has been mainly
--   tested. See the documentation of PositionStoreFloat for a typical
--   usage example.
module XMonad.Layout.BorderResize
borderResize :: l a -> ModifiedLayout BorderResize l a
data BorderResize a
BR :: (Map Window RectWithBorders) -> BorderResize a
instance Show (BorderResize a)
instance Read (BorderResize a)
instance Show BorderInfo
instance Read BorderInfo
instance Show BorderType
instance Read BorderType
instance Eq BorderType
instance LayoutModifier BorderResize Window


-- | A layout modifier for decorating windows in a dwm like style.
module XMonad.Layout.DwmStyle

-- | Add simple old dwm-style decorations to windows of a layout.
dwmStyle :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration DwmStyle s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> Theme

-- | Color of the active window
activeColor :: Theme -> String

-- | Color of the inactive window
inactiveColor :: Theme -> String

-- | Color of the urgent window
urgentColor :: Theme -> String

-- | Color of the border of the active window
activeBorderColor :: Theme -> String

-- | Color of the border of the inactive window
inactiveBorderColor :: Theme -> String

-- | Color of the border of the urgent window
urgentBorderColor :: Theme -> String

-- | Color of the text of the active window
activeTextColor :: Theme -> String

-- | Color of the text of the inactive window
inactiveTextColor :: Theme -> String

-- | Color of the text of the urgent window
urgentTextColor :: Theme -> String

-- | Font name
fontName :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
decoWidth :: Theme -> Dimension

-- | Height of the decorations
decoHeight :: Theme -> Dimension

-- | Extra text to appear in a window's title bar
windowTitleAddons :: Theme -> [(String, Align)]

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme
data DwmStyle a
Dwm :: DwmStyle a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: (Shrinker s) => s -> String -> [String]
instance Show (DwmStyle a)
instance Read (DwmStyle a)
instance (Eq a) => DecorationStyle DwmStyle a


-- | A layout modifier for adding simple decorations to the windows of a
--   given layout. The decorations are in the form of ion-like tabs for
--   window titles.
module XMonad.Layout.SimpleDecoration

-- | Add simple decorations to windows of a layout.
simpleDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration SimpleDecoration s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> Theme

-- | Color of the active window
activeColor :: Theme -> String

-- | Color of the inactive window
inactiveColor :: Theme -> String

-- | Color of the urgent window
urgentColor :: Theme -> String

-- | Color of the border of the active window
activeBorderColor :: Theme -> String

-- | Color of the border of the inactive window
inactiveBorderColor :: Theme -> String

-- | Color of the border of the urgent window
urgentBorderColor :: Theme -> String

-- | Color of the text of the active window
activeTextColor :: Theme -> String

-- | Color of the text of the inactive window
inactiveTextColor :: Theme -> String

-- | Color of the text of the urgent window
urgentTextColor :: Theme -> String

-- | Font name
fontName :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
decoWidth :: Theme -> Dimension

-- | Height of the decorations
decoHeight :: Theme -> Dimension

-- | Extra text to appear in a window's title bar
windowTitleAddons :: Theme -> [(String, Align)]

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme
data SimpleDecoration a
Simple :: Bool -> SimpleDecoration a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: (Shrinker s) => s -> String -> [String]
instance Show (SimpleDecoration a)
instance Read (SimpleDecoration a)
instance (Eq a) => DecorationStyle SimpleDecoration a


-- | A basic floating layout.
module XMonad.Layout.SimpleFloat

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
--   
--   This version is decorated with the <a>SimpleDecoration</a> style.
simpleFloat :: (Eq a) => ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>simpleFloat</a>, but with the possibility of setting a
--   custom shrinker and a custom theme.
simpleFloat' :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a
data SimpleDecoration a
Simple :: Bool -> SimpleDecoration a
data SimpleFloat a
SF :: Dimension -> SimpleFloat a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: (Shrinker s) => s -> String -> [String]
instance Show (SimpleFloat a)
instance Read (SimpleFloat a)
instance LayoutClass SimpleFloat Window


-- | Most basic version of decoration for windows without any additional
--   modifications. In contrast to <a>XMonad.Layout.SimpleDecoration</a>
--   this will result in title bars that span the entire window instead of
--   being only the length of the window title.
module XMonad.Layout.NoFrillsDecoration

-- | Add very simple decorations to windows of a layout.
noFrillsDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration NoFrillsDecoration s) l a
instance Show (NoFrillsDecoration a)
instance Read (NoFrillsDecoration a)
instance (Eq a) => DecorationStyle NoFrillsDecoration a


-- | A layout transformer to have a layout respect a given screen geometry.
--   Mostly used with <a>Decoration</a> (the Horizontal and the Vertical
--   version will react to SetTheme and change their dimension accordingly.
module XMonad.Layout.ResizeScreen
resizeHorizontal :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeVertical :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeHorizontalRight :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeVerticalBottom :: Int -> l a -> ModifiedLayout ResizeScreen l a
withNewRectangle :: Rectangle -> l a -> ModifiedLayout ResizeScreen l a
data ResizeScreen a
ResizeScreen :: ResizeMode -> Int -> ResizeScreen a
WithNewScreen :: Rectangle -> ResizeScreen a
instance Read ResizeMode
instance Show ResizeMode
instance Read (ResizeScreen a)
instance Show (ResizeScreen a)
instance LayoutModifier ResizeScreen a


-- | Ensures that the windows of the current workspace are always in front
--   of windows that are located on other visible screens. This becomes
--   important if you use decoration and drag windows from one screen to
--   another. Using this module, the dragged window will always be in front
--   of other windows.
module XMonad.Hooks.CurrentWorkspaceOnTop
currentWorkspaceOnTop :: X ()
instance Typeable CWOTState
instance ExtensionClass CWOTState


-- | A module for spawning a command once, and only once. Useful to start
--   status bars and make session settings inside startupHook.
module XMonad.Util.SpawnOnce

-- | The first time <a>spawnOnce</a> is executed on a particular command,
--   that command is executed. Subsequent invocations for a command do
--   nothing.
spawnOnce :: String -> X ()
instance Typeable SpawnOnce
instance Read SpawnOnce
instance Show SpawnOnce
instance ExtensionClass SpawnOnce


-- | One-shot and permanent ManageHooks that can be updated at runtime.
module XMonad.Hooks.DynamicHooks

-- | Master <a>ManageHook</a> that must be in your <tt>xmonad.hs</tt>
--   <a>ManageHook</a>.
dynamicMasterHook :: ManageHook

-- | Appends the given <a>ManageHook</a> to the permanent dynamic
--   <a>ManageHook</a>.
addDynamicHook :: ManageHook -> X ()

-- | Modifies the permanent <a>ManageHook</a> with an arbitrary function.
updateDynamicHook :: (ManageHook -> ManageHook) -> X ()

-- | Creates a one-shot <a>ManageHook</a>. Note that you have to specify
--   the two parts of the <a>ManageHook</a> separately. Where you would
--   usually write:
--   
--   <pre>
--   className =? "example" --&gt; doFloat
--   </pre>
--   
--   you must call <a>oneShotHook</a> as
--   
--   <pre>
--   oneShotHook dynHooksRef (className =? "example) doFloat
--   </pre>
oneShotHook :: Query Bool -> ManageHook -> X ()
instance Typeable DynamicHooks
instance ExtensionClass DynamicHooks


-- | Hook and keybindings for automatically sending the next spawned
--   window(s) to the floating layer.
module XMonad.Hooks.FloatNext

-- | This <a>ManageHook</a> will selectively float windows as set by
--   <a>floatNext</a> and <a>floatAllNew</a>.
floatNextHook :: ManageHook

-- | <tt>floatNext True</tt> arranges for the next spawned window to be
--   sent to the floating layer, <tt>floatNext False</tt> cancels it.
floatNext :: Bool -> X ()
toggleFloatNext :: X ()

-- | <tt>floatAllNew True</tt> arranges for new windows to be sent to the
--   floating layer, <tt>floatAllNew False</tt> cancels it
floatAllNew :: Bool -> X ()
toggleFloatAllNew :: X ()

-- | Whether the next window will be set floating
willFloatNext :: X Bool

-- | Whether new windows will be set floating
willFloatAllNew :: X Bool
willFloatNextPP :: (String -> String) -> X (Maybe String)
willFloatAllNewPP :: (String -> String) -> X (Maybe String)
runLogHook :: X ()
instance Typeable FloatMode
instance ExtensionClass FloatMode


-- | A utility module to store information about position and size of a
--   window. See <a>XMonad.Layout.PositionStoreFloat</a> for a layout that
--   makes use of this.
module XMonad.Util.PositionStore
getPosStore :: X (PositionStore)
modifyPosStore :: (PositionStore -> PositionStore) -> X ()
posStoreInsert :: PositionStore -> Window -> Rectangle -> Rectangle -> PositionStore
posStoreMove :: PositionStore -> Window -> Position -> Position -> Rectangle -> Rectangle -> PositionStore
posStoreQuery :: PositionStore -> Window -> Rectangle -> Maybe Rectangle
posStoreRemove :: PositionStore -> Window -> PositionStore
instance Typeable PosStoreRectangle
instance Typeable PositionStore
instance Read PosStoreRectangle
instance Show PosStoreRectangle
instance Read PositionStore
instance Show PositionStore
instance ExtensionClass PositionStore


-- | A floating layout which has been designed with a dual-head setup in
--   mind. It makes use of <a>XMonad.Util.PositionStore</a> as well as
--   <a>XMonad.Hooks.PositionStoreHooks</a> . Since there is currently no
--   way to move or resize windows with the keyboard alone in this layout,
--   it is adviced to use it in combination with a decoration such as
--   <a>XMonad.Layout.NoFrillsDecoration</a> (to move windows) and the
--   layout modifier <a>XMonad.Layout.BorderResize</a> (to resize windows).
module XMonad.Layout.PositionStoreFloat
positionStoreFloat :: PositionStoreFloat a
instance (Show a) => Show (PositionStoreFloat a)
instance (Read a) => Read (PositionStoreFloat a)
instance LayoutClass PositionStoreFloat Window


-- | This module contains two hooks for the PositionStore (see
--   <a>XMonad.Util.PositionStore</a>) - a ManageHook and an EventHook.
--   
--   The ManageHook can be used to fill the PositionStore with position and
--   size information about new windows. The advantage of using this hook
--   is, that the information is recorded independent of the currently
--   active layout. So the floating shape of the window can later be
--   restored even if it was opened in a tiled layout initially.
--   
--   For windows, that do not request a particular position, a random
--   position will be assigned. This prevents windows from piling up
--   exactly on top of each other.
--   
--   The EventHook makes sure that windows are deleted from the
--   PositionStore when they are closed.
module XMonad.Hooks.PositionStoreHooks
positionStoreManageHook :: ManageHook
positionStoreEventHook :: Event -> X All


-- | Run <tt>X ()</tt> actions by touching the edge of your screen with
--   your mouse.
module XMonad.Hooks.ScreenCorners
data ScreenCorner
SCUpperLeft :: ScreenCorner
SCUpperRight :: ScreenCorner
SCLowerLeft :: ScreenCorner
SCLowerRight :: ScreenCorner

-- | Add one single <tt>X ()</tt> action to a screen corner
addScreenCorner :: ScreenCorner -> X () -> X ()

-- | Add a list of <tt>(ScreenCorner, X ())</tt> tuples
addScreenCorners :: [(ScreenCorner, X ())] -> X ()

-- | Handle screen corner events
screenCornerEventHook :: Event -> X All
instance Typeable ScreenCornerState
instance Eq ScreenCorner
instance Ord ScreenCorner
instance Show ScreenCorner
instance ExtensionClass ScreenCornerState


-- | Dwm-like swap function for xmonad.
--   
--   Swaps focused window with the master window. If focus is in the
--   master, swap it with the next window in the stack. Focus stays in the
--   master.
module XMonad.Actions.DwmPromote

-- | Swap the focused window with the master window. If focus is in the
--   master, swap it with the next window in the stack. Focus stays in the
--   master.
dwmpromote :: X ()


-- | This module provides a method to cease management of a window without
--   unmapping it. This is especially useful for applications like kicker
--   and gnome-panel. See also <a>XMonad.Hooks.ManageDocks</a> for more a
--   more automated solution.
--   
--   To make a panel display correctly with xmonad:
--   
--   <ul>
--   <li>Determine the pixel size of the panel, add that value to
--   <tt>XMonad.Core.XConfig.defaultGaps</tt></li>
--   <li>Launch the panel</li>
--   <li>Give the panel window focus, then press <tt>mod-d</tt> (or
--   whatever key you have bound <a>demanage</a> to)</li>
--   <li>Convince the panel to move/resize to the correct location.
--   Changing the panel's position setting several times seems to
--   work.</li>
--   </ul>
module XMonad.Actions.DeManage

-- | Stop managing the currently focused window.
demanage :: Window -> X ()


module XMonad.Util.WorkspaceCompare
type WorkspaceCompare = WorkspaceId -> WorkspaceId -> Ordering
type WorkspaceSort = [WindowSpace] -> [WindowSpace]

-- | Lookup the index of a workspace id in the user's config, return
--   Nothing if that workspace does not exist in the config.
getWsIndex :: X (WorkspaceId -> Maybe Int)

-- | A comparison function for WorkspaceId, based on the index of the tags
--   in the user's config.
getWsCompare :: X WorkspaceCompare

-- | A simple comparison function that orders workspaces lexicographically
--   by tag.
getWsCompareByTag :: X WorkspaceCompare

-- | A comparison function like <a>getXineramaWsCompare</a>, but uses
--   physical locations for screens.
getXineramaPhysicalWsCompare :: X WorkspaceCompare

-- | A comparison function for Xinerama based on visibility, workspace and
--   screen id. It produces the same ordering as
--   <tt>XMonad.Hooks.DynamicLog.pprWindowSetXinerama</tt>.
getXineramaWsCompare :: X WorkspaceCompare

-- | Create a workspace sorting function from a workspace comparison
--   function.
mkWsSort :: X WorkspaceCompare -> X WorkspaceSort

-- | Sort several workspaces according to their tags' indices in the user's
--   config.
getSortByIndex :: X WorkspaceSort

-- | Sort workspaces lexicographically by tag.
getSortByTag :: X WorkspaceSort

-- | Like <a>getSortByXineramaRule</a>, but uses physical locations for
--   screens.
getSortByXineramaPhysicalRule :: X WorkspaceSort

-- | Sort serveral workspaces for xinerama displays, in the same order
--   produced by <tt>XMonad.Hooks.DynamicLog.pprWindowSetXinerama</tt>:
--   first visible workspaces, sorted by screen, then hidden workspaces,
--   sorted by tag.
getSortByXineramaRule :: X WorkspaceSort


-- | Makes xmonad use the EWMH hints to tell panel applications about its
--   workspaces and the windows therein. It also allows the user to
--   interact with xmonad by clicking on panels and window lists.
module XMonad.Hooks.EwmhDesktops

-- | Add EWMH functionality to the given config. See above for an example.
ewmh :: XConfig a -> XConfig a

-- | Initializes EwmhDesktops and advertises EWMH support to the X server
ewmhDesktopsStartup :: X ()

-- | Notifies pagers and window lists, such as those in the gnome-panel of
--   the current state of workspaces and windows.
ewmhDesktopsLogHook :: X ()

-- | Generalized version of ewmhDesktopsLogHook that allows an arbitrary
--   user-specified function to transform the workspace list (post-sorting)
ewmhDesktopsLogHookCustom :: ([WindowSpace] -> [WindowSpace]) -> X ()

-- | Intercepts messages from pagers and similar applications and reacts on
--   them. Currently supports:
--   
--   <ul>
--   <li>_NET_CURRENT_DESKTOP (switching desktops)</li>
--   <li>_NET_WM_DESKTOP (move windows to other desktops)</li>
--   <li>_NET_ACTIVE_WINDOW (activate another window, changing workspace if
--   needed)</li>
--   </ul>
ewmhDesktopsEventHook :: Event -> X All

-- | An event hook to handle applications that wish to fullscreen using the
--   _NET_WM_STATE protocol. This includes users of the
--   gtk_window_fullscreen() function, such as Totem, Evince and
--   OpenOffice.org.
fullscreenEventHook :: Event -> X All


-- | Miscellaneous commonly used types.
module XMonad.Util.Types

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
instance Typeable Direction2D
instance Typeable Direction1D
instance Eq Direction2D
instance Read Direction2D
instance Show Direction2D
instance Ord Direction2D
instance Enum Direction2D
instance Bounded Direction2D
instance Eq Direction1D
instance Read Direction1D
instance Show Direction1D


-- | A module for writing graphical prompts for XMonad
module XMonad.Prompt

-- | Creates a prompt given:
--   
--   <ul>
--   <li>a prompt type, instance of the <a>XPrompt</a> class.</li>
--   <li>a prompt configuration (<a>defaultXPConfig</a> can be used as a
--   starting point)</li>
--   <li>a completion function (<a>mkComplFunFromList</a> can be used to
--   create a completions function given a list of possible
--   completions)</li>
--   <li>an action to be run: the action must take a string and return
--   <a>X</a> ()</li>
--   </ul>
mkXPrompt :: (XPrompt p) => p -> XPConfig -> ComplFunction -> (String -> X ()) -> X ()

-- | Same as <a>mkXPrompt</a>, except that the action function can have
--   type <tt>String -&gt; X a</tt>, for any <tt>a</tt>, and the final
--   action returned by <a>mkXPromptWithReturn</a> will have type <tt>X
--   (Maybe a)</tt>. <tt>Nothing</tt> is yielded if the user cancels the
--   prompt (by e.g. hitting Esc or Ctrl-G). For an example of use, see the
--   <tt>XMonad.Prompt.Input</tt> module.
mkXPromptWithReturn :: (XPrompt p) => p -> XPConfig -> ComplFunction -> (String -> X a) -> X (Maybe a)
amberXPConfig :: XPConfig
defaultXPConfig :: XPConfig
greenXPConfig :: XPConfig
data XPType
XPT :: p -> XPType
data XPPosition
Top :: XPPosition
Bottom :: XPPosition
data XPConfig
XPC :: String -> String -> String -> String -> String -> String -> !Dimension -> XPPosition -> !Dimension -> !Int -> ([String] -> [String]) -> Map (KeyMask, KeySym) (XP ()) -> KeySym -> String -> Maybe Int -> Bool -> (String -> String -> Bool) -> XPConfig

-- | Font
font :: XPConfig -> String

-- | Background color
bgColor :: XPConfig -> String

-- | Font color
fgColor :: XPConfig -> String

-- | Font color of a highlighted completion entry
fgHLight :: XPConfig -> String

-- | Background color of a highlighted completion entry
bgHLight :: XPConfig -> String

-- | Border color
borderColor :: XPConfig -> String

-- | Border width
promptBorderWidth :: XPConfig -> !Dimension

-- | Position: <a>Top</a> or <a>Bottom</a>
position :: XPConfig -> XPPosition

-- | Window height
height :: XPConfig -> !Dimension

-- | The number of history entries to be saved
historySize :: XPConfig -> !Int

-- | a filter to determine which history entries to remember
historyFilter :: XPConfig -> [String] -> [String]

-- | Mapping from key combinations to actions
promptKeymap :: XPConfig -> Map (KeyMask, KeySym) (XP ())

-- | Key that should trigger completion
completionKey :: XPConfig -> KeySym

-- | The text by default in the prompt line
defaultText :: XPConfig -> String

-- | Just x: if only one completion remains, auto-select it,
autoComplete :: XPConfig -> Maybe Int

-- | Only show list of completions when Tab was pressed and delay by x
--   microseconds
showCompletionOnTab :: XPConfig -> Bool

-- | Given the typed string and a possible completion, is the completion
--   valid?
searchPredicate :: XPConfig -> String -> String -> Bool

-- | The class prompt types must be an instance of. In order to create a
--   prompt you need to create a data type, without parameters, and make it
--   an instance of this class, by implementing a simple method,
--   <a>showXPrompt</a>, which will be used to print the string to be
--   displayed in the command line window.
--   
--   This is an example of a XPrompt instance definition:
--   
--   <pre>
--   instance XPrompt Shell where
--        showXPrompt Shell = "Run: "
--   </pre>
class XPrompt t
showXPrompt :: (XPrompt t) => t -> String
nextCompletion :: (XPrompt t) => t -> String -> [String] -> String
commandToComplete :: (XPrompt t) => t -> String -> String
completionToCommand :: (XPrompt t) => t -> String -> String
type XP = StateT XPState IO
defaultXPKeymap :: Map (KeyMask, KeySym) (XP ())

-- | Quit.
quit :: XP ()

-- | Kill the portion of the command before the cursor
killBefore :: XP ()

-- | Kill the portion of the command including and after the cursor
killAfter :: XP ()

-- | Put the cursor at the start of line
startOfLine :: XP ()

-- | Put the cursor at the end of line
endOfLine :: XP ()

-- | Insert the current X selection string at the cursor position.
pasteString :: XP ()

-- | move the cursor one position
moveCursor :: Direction1D -> XP ()

-- | Sets the input string to the given value.
setInput :: String -> XP ()

-- | Returns the current input string. Intented for use in custom keymaps
--   where the <a>get</a> or similar can't be used to retrieve it.
getInput :: XP String

-- | move the cursor one word
moveWord :: Direction1D -> XP ()

-- | Kill the next/previous word
killWord :: Direction1D -> XP ()

-- | Remove a character at the cursor position
deleteString :: Direction1D -> XP ()
moveHistory :: (Stack String -> Stack String) -> XP ()
setSuccess :: Bool -> XP ()
setDone :: Bool -> XP ()

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D
type ComplFunction = String -> IO [String]

-- | Creates a window with the attribute override_redirect set to True.
--   Windows Managers should not touch this kind of windows.
mkUnmanagedWindow :: Display -> Screen -> Window -> Position -> Position -> Dimension -> Dimension -> IO Window

-- | Fills a <a>Drawable</a> with a rectangle and a border
fillDrawable :: Display -> Drawable -> GC -> Pixel -> Pixel -> Dimension -> Dimension -> Dimension -> IO ()

-- | This function takes a list of possible completions and returns a
--   completions function to be used with <a>mkXPrompt</a>
mkComplFunFromList :: [String] -> String -> IO [String]

-- | This function takes a list of possible completions and returns a
--   completions function to be used with <a>mkXPrompt</a>. If the string
--   is null it will return all completions.
mkComplFunFromList' :: [String] -> String -> IO [String]

-- | Given the prompt type, the command line and the completion list,
--   return the next completion in the list for the last word of the
--   command line. This is the default <a>nextCompletion</a>
--   implementation.
getNextOfLastWord :: (XPrompt t) => t -> String -> [String] -> String

-- | An alternative <a>nextCompletion</a> implementation: given a command
--   and a completion list, get the next completion in the list matching
--   the whole command line.
getNextCompletion :: String -> [String] -> String

-- | Gets the last word of a string or the whole string if formed by only
--   one word
getLastWord :: String -> String

-- | Skips the last word of the string, if the string is composed by more
--   then one word. Otherwise returns the string.
skipLastWord :: String -> String

-- | Given a maximum length, splits a list into sublists
splitInSubListsAt :: Int -> [a] -> [[a]]
breakAtSpace :: String -> (String, String)

-- | Sort a list and remove duplicates. Like <a>deleteAllDuplicates</a>,
--   but trades off laziness and stability for efficiency.
uniqSort :: (Ord a) => [a] -> [a]
decodeInput :: String -> String
encodeOutput :: String -> String

-- | <a>historyCompletion</a> provides a canned completion function much
--   like <tt>getShellCompl</tt>; you pass it to mkXPrompt, and it will
--   make completions work from the query history stored in
--   ~/.xmonad/history.
historyCompletion :: ComplFunction

-- | Like <a>historyCompletion</a> but only uses history data from Prompts
--   whose name satisfies the given predicate.
historyCompletionP :: (String -> Bool) -> ComplFunction
deleteAllDuplicates :: [String] -> [String]

-- | Functions to be used with the <a>historyFilter</a> setting.
--   <a>deleteAllDuplicates</a> will remove all duplicate entries.
--   <a>deleteConsecutive</a> will only remove duplicate elements
--   immediately next to each other.
deleteConsecutive :: [String] -> [String]
data HistoryMatches

-- | Initializes a new HistoryMatches structure to be passed to
--   historyUpMatching
initMatches :: (Functor m, MonadIO m) => m HistoryMatches
historyUpMatching :: HistoryMatches -> XP ()

-- | Retrieve the next history element that starts with the current input.
--   Pass it the result of initMatches when creating the prompt. Example:
--   
--   <pre>
--   ..
--   ((modMask,xK_p), shellPrompt . myPrompt =&lt;&lt; initMatches)
--   ..
--   myPrompt ref = defaultPrompt
--     { promptKeymap = M.union [((0,xK_Up), historyUpMatching ref)
--                              ,((0,xK_Down), historyDownMatching ref)]
--                              (promptKeymap defaultPrompt)
--     , .. }
--   </pre>
historyDownMatching :: HistoryMatches -> XP ()
instance Show XPPosition
instance Read XPPosition
instance XPrompt XPType
instance Show XPType


-- | A workspace prompt for XMonad
module XMonad.Prompt.Workspace
workspacePrompt :: XPConfig -> (String -> X ()) -> X ()
instance XPrompt Wor


-- | Provides bindings to add and delete workspaces.
module XMonad.Actions.DynamicWorkspaces

-- | Add a new workspace with the given name, or do nothing if a workspace
--   with the given name already exists; then switch to the newly created
--   workspace.
addWorkspace :: String -> X ()

-- | Prompt for the name of a new workspace, add it if it does not already
--   exist, and switch to it.
addWorkspacePrompt :: XPConfig -> X ()

-- | Remove the current workspace.
removeWorkspace :: X ()

-- | Remove the current workspace if it contains no windows.
removeEmptyWorkspace :: X ()

-- | Remove the current workspace after an operation if it is empty and
--   hidden. Can be used to remove a workspace if it is empty when leaving
--   it. The operation may only change workspace once, otherwise the
--   workspace will not be removed.
removeEmptyWorkspaceAfter :: X () -> X ()

-- | Like <a>removeEmptyWorkspaceAfter</a> but use a list of sticky
--   workspaces, whose entries will never be removed.
removeEmptyWorkspaceAfterExcept :: [String] -> X () -> X ()

-- | Add a new hidden workspace with the given name, or do nothing if a
--   workspace with the given name already exists.
addHiddenWorkspace :: String -> X ()
withWorkspace :: XPConfig -> (String -> X ()) -> X ()
selectWorkspace :: XPConfig -> X ()
renameWorkspace :: XPConfig -> X ()
toNthWorkspace :: (String -> X ()) -> Int -> X ()
withNthWorkspace :: (String -> WindowSet -> WindowSet) -> Int -> X ()
instance XPrompt Wor


-- | Named scratchpads that support several arbitrary applications at the
--   same time.
module XMonad.Util.NamedScratchpad

-- | Single named scratchpad configuration
data NamedScratchpad
NS :: String -> String -> Query Bool -> ManageHook -> NamedScratchpad

-- | Scratchpad name
name :: NamedScratchpad -> String

-- | Command used to run application
cmd :: NamedScratchpad -> String

-- | Query to find already running application
query :: NamedScratchpad -> Query Bool

-- | Manage hook called for application window, use it to define the
--   placement. See <tt>nonFloating</tt>, <tt>defaultFloating</tt> and
--   <tt>customFloating</tt>
hook :: NamedScratchpad -> ManageHook

-- | Manage hook that makes the window non-floating
nonFloating :: ManageHook

-- | Manage hook that makes the window floating with the default placement
defaultFloating :: ManageHook

-- | Manage hook that makes the window floating with custom placement
customFloating :: RationalRect -> ManageHook

-- | Named scratchpads configuration
type NamedScratchpads = [NamedScratchpad]

-- | Action to pop up specified named scratchpad
namedScratchpadAction :: NamedScratchpads -> String -> X ()

-- | Manage hook to use with named scratchpads
namedScratchpadManageHook :: NamedScratchpads -> ManageHook

-- | Transforms a workspace list containing the NSP workspace into one that
--   doesn't contain it. Intended for use with logHooks.
namedScratchpadFilterOutWorkspace :: [WindowSpace] -> [WindowSpace]


-- | Very handy hotkey-launched floating terminal window.
module XMonad.Util.Scratchpad

-- | Action to pop up the terminal, for the user to bind to a custom key.
scratchpadSpawnAction :: XConfig l -> X ()

-- | Action to pop up the terminal, with a directly specified terminal.
scratchpadSpawnActionTerminal :: String -> X ()

-- | Action to pop up any program with the user specifying how to set its
--   resource to "scratchpad". For example, with gnome-terminal:
--   
--   <pre>
--   scratchpadSpawnActionCustom "gnome-terminal --disable-factory --name scratchpad"
--   </pre>
scratchpadSpawnActionCustom :: String -> X ()

-- | The ManageHook, with the default rectangle: Half the screen wide, a
--   quarter of the screen tall, centered.
scratchpadManageHookDefault :: ManageHook

-- | The ManageHook, with a user-specified StackSet.RationalRect, e.g., for
--   a terminal 4/10 of the screen width from the left, half the screen
--   height from the top, and 6/10 of the screen width by 3/10 the screen
--   height, use:
--   
--   <pre>
--   scratchpadManageHook (W.RationalRect 0.4 0.5 0.6 0.3)
--   </pre>
scratchpadManageHook :: RationalRect -> ManageHook

-- | Transforms a workspace list containing the SP workspace into one that
--   doesn't contain it. Intended for use with logHooks.
scratchpadFilterOutWorkspace :: [WindowSpace] -> [WindowSpace]


-- | Dynamically manage "workspace groups", sets of workspaces being used
--   together for some common task or purpose, to allow switching between
--   workspace groups in a single action. Note that this only makes sense
--   for multi-head setups.
module XMonad.Actions.DynamicWorkspaceGroups
type WSGroupId = String

-- | Add a new workspace group with the given name.
addWSGroup :: WSGroupId -> [WorkspaceId] -> X ()

-- | Give a name to the current workspace group.
addCurrentWSGroup :: WSGroupId -> X ()

-- | Delete the named workspace group from the list of workspace groups.
--   Note that this has no effect on the workspaces involved; it simply
--   forgets the given name.
forgetWSGroup :: WSGroupId -> X ()

-- | View the workspace group with the given name.
viewWSGroup :: WSGroupId -> X ()

-- | Prompt for a workspace group to view.
promptWSGroupView :: XPConfig -> String -> X ()

-- | Prompt for a name for the current workspace group.
promptWSGroupAdd :: XPConfig -> String -> X ()

-- | Prompt for a workspace group to forget.
promptWSGroupForget :: XPConfig -> String -> X ()
instance Typeable WSGroupStorage
instance Read WSGroupStorage
instance Show WSGroupStorage
instance XPrompt WSGPrompt
instance ExtensionClass WSGroupStorage


-- | A shell prompt for XMonad
module XMonad.Prompt.Shell
data Shell
Shell :: Shell
shellPrompt :: XPConfig -> X ()
getCommands :: IO [String]

-- | Ask the shell what browser the user likes. If the user hasn't defined
--   any $BROWSER, defaults to returning "firefox", since that seems to be
--   the most common X web browser. Note that if you don't specify a GUI
--   browser but a textual one, that'll be a problem as <a>getBrowser</a>
--   will be called by functions expecting to be able to just execute the
--   string or pass it to a shell; so in that case, define $BROWSER as
--   something like "xterm -e elinks" or as the name of a shell script
--   doing much the same thing.
getBrowser :: IO String

-- | Like <a>getBrowser</a>, but should be of a text editor. This gets the
--   $EDITOR variable, defaulting to "emacs".
getEditor :: IO String
getShellCompl :: [String] -> String -> IO [String]
split :: (Eq a) => a -> [a] -> [[a]]
prompt :: FilePath -> XPConfig -> X ()
safePrompt :: FilePath -> XPConfig -> X ()
instance XPrompt Shell


module XMonad.Actions.Search

-- | Given a browser, a search engine's transformation function, and a
--   search term, perform the requested search in the browser.
search :: Browser -> Site -> Query -> X ()
data SearchEngine
SearchEngine :: Name -> Site -> SearchEngine

-- | Given a base URL, create the <a>SearchEngine</a> that escapes the
--   query and appends it to the base. You can easily define a new engine
--   locally using exported functions without needing to modify
--   <a>XMonad.Actions.Search</a>:
--   
--   <pre>
--   myNewEngine = searchEngine "site" "http://site.com/search="
--   </pre>
--   
--   The important thing is that the site has a interface which accepts the
--   escaped query string as part of the URL. Alas, the exact URL to feed
--   searchEngine varies from site to site, often considerably, so there's
--   no general way to cover this.
--   
--   Generally, examining the resultant URL of a search will allow you to
--   reverse-engineer it if you can't find the necessary URL already
--   described in other projects such as Surfraw.
searchEngine :: Name -> String -> SearchEngine

-- | If your search engine is more complex than this (you may want to
--   identify the kind of input and make the search URL dependent on the
--   input or put the query inside of a URL instead of in the end) you can
--   use the alternative <a>searchEngineF</a> function.
--   
--   <pre>
--   searchFunc :: String -&gt; String
--   searchFunc s | s `isPrefixOf` "wiki:"   = "http://en.wikipedia.org/wiki/" ++ (escape $ tail $ snd $ break (==':') s)
--                | s `isPrefixOf` "http://" = s
--                | otherwise               = (use google) s
--   myNewEngine = searchEngineF "mymulti" searchFunc
--   </pre>
--   
--   <tt>searchFunc</tt> here searches for a word in wikipedia if it has a
--   prefix of "wiki:" (you can use the <a>escape</a> function to escape
--   any forbidden characters), opens an address directly if it starts with
--   "http://" and otherwise uses the provided google search engine. You
--   can use other engines inside of your own through the <a>use</a>
--   function as shown above to make complex searches.
--   
--   The user input will be automatically escaped in search engines created
--   with <a>searchEngine</a>, <a>searchEngineF</a>, however, completely
--   depends on the transformation function passed to it.
searchEngineF :: Name -> Site -> SearchEngine

-- | Like <a>search</a>, but in this case, the string is not specified but
--   grabbed from the user's response to a prompt. Example:
--   
--   <pre>
--   , ((modm, xK_g), promptSearch greenXPConfig google)
--   </pre>
--   
--   This specializes <a>promptSearchBrowser</a> by supplying the browser
--   argument as supplied by <a>getBrowser</a> from
--   <a>XMonad.Prompt.Shell</a>.
promptSearch :: XPConfig -> SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the output from a Prompt; it
--   grabs the Prompt's result, passes it to a given searchEngine and opens
--   it in a given browser.
promptSearchBrowser :: XPConfig -> Browser -> SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the X selection; it grabs the
--   selection, passes it to a given searchEngine and opens it in the
--   default browser . Example:
--   
--   <pre>
--   , ((modm .|. shiftMask, xK_g), selectSearch google)
--   </pre>
--   
--   This specializes <a>selectSearchBrowser</a> by supplying the browser
--   argument as supplied by <a>getBrowser</a> from
--   <a>XMonad.Prompt.Shell</a>.
selectSearch :: SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the X selection; it grabs the
--   selection, passes it to a given searchEngine and opens it in a given
--   browser.
selectSearchBrowser :: Browser -> SearchEngine -> X ()

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: (Eq a) => [a] -> [a] -> Bool

-- | Escape the search string so search engines understand it. Note that
--   everything is escaped; we could be smarter and use
--   <tt>isAllowedInURI</tt> but then that'd be hard enough to
--   copy-and-paste we'd need to depend on <tt>network</tt>.
escape :: String -> String

-- | Given an already defined search engine, extracts its transformation
--   function, making it easy to create compound search engines. For an
--   instance you can use <tt>use google</tt> to get a function which makes
--   the same transformation as the google search engine would.
use :: SearchEngine -> Site

-- | This function wraps up a search engine and creates a new one, which
--   works like the argument, but goes directly to a URL if one is given
--   rather than searching.
--   
--   <pre>
--   myIntelligentGoogleEngine = intelligent google
--   </pre>
--   
--   Now if you search for http://xmonad.org it will directly open in your
--   browser
intelligent :: SearchEngine -> SearchEngine

-- | Connects a few search engines into one. If the search engines' names
--   are "s1", "s2" and "s3", then the resulting engine will use s1 if the
--   query is <tt>s1:word</tt>, s2 if you type <tt>s2:word</tt> and s3 in
--   all other cases.
--   
--   Example:
--   
--   <pre>
--   multiEngine = intelligent (wikipedia !&gt; mathworld !&gt; (prefixAware google))
--   </pre>
--   
--   Now if you type "wiki:Haskell" it will search for "Haskell" in
--   Wikipedia, "mathworld:integral" will search mathworld, and everything
--   else will fall back to google. The use of intelligent will make sure
--   that URLs are opened directly.
(!>) :: SearchEngine -> SearchEngine -> SearchEngine

-- | Makes a search engine prefix-aware. Especially useful together with
--   <a>!&gt;</a>. It will automatically remove the prefix from a query so
--   that you don't end up searching for google:xmonad if google is your
--   fallback engine and you explicitly add the prefix.
prefixAware :: SearchEngine -> SearchEngine

-- | Changes search engine's name
namedEngine :: Name -> SearchEngine -> SearchEngine
amazon :: SearchEngine
alpha :: SearchEngine
codesearch :: SearchEngine
deb :: SearchEngine
debbts :: SearchEngine
debpts :: SearchEngine
dictionary :: SearchEngine
google :: SearchEngine
hackage :: SearchEngine
hoogle :: SearchEngine
images :: SearchEngine
imdb :: SearchEngine
isohunt :: SearchEngine
lucky :: SearchEngine
maps :: SearchEngine
mathworld :: SearchEngine
openstreetmap :: SearchEngine
scholar :: SearchEngine
thesaurus :: SearchEngine
wayback :: SearchEngine
wikipedia :: SearchEngine
wiktionary :: SearchEngine
youtube :: SearchEngine
multi :: SearchEngine
instance XPrompt Search


-- | Provides a way to modify a window spawned by a command(e.g shift it to
--   the workspace it was launched on) by using the _NET_WM_PID property
--   that most windows set on creation. Hence this module won't work on
--   applications that don't set this property.
module XMonad.Actions.SpawnOn
data Spawner

-- | Provides a manage hook to react on process spawned with
--   <a>spawnOn</a>, <a>spawnHere</a> etc.
manageSpawn :: ManageHook

-- | Replacement for <a>spawn</a> which launches application on current
--   workspace.
spawnHere :: String -> X ()

-- | Replacement for <a>spawn</a> which launches application on given
--   workspace.
spawnOn :: WorkspaceId -> String -> X ()

-- | Spawn an application and apply the manage hook when it opens.
spawnAndDo :: ManageHook -> String -> X ()

-- | Replacement for Shell prompt (<a>XMonad.Prompt.Shell</a>) which
--   launches application on current workspace.
shellPromptHere :: XPConfig -> X ()

-- | Replacement for Shell prompt (<a>XMonad.Prompt.Shell</a>) which
--   launches application on given workspace.
shellPromptOn :: WorkspaceId -> XPConfig -> X ()
instance Typeable Spawner
instance ExtensionClass Spawner


-- | Functions for tagging windows and selecting them by tags.
module XMonad.Actions.TagWindows

-- | add a tag to the existing ones
addTag :: String -> Window -> X ()

-- | remove a tag from a window, if it exists
delTag :: String -> Window -> X ()

-- | remove all tags
unTag :: Window -> X ()

-- | set multiple tags for a window at once (overriding any previous tags)
setTags :: [String] -> Window -> X ()

-- | read all tags of a window reads from the "_XMONAD_TAGS" window
--   property
getTags :: Window -> X [String]

-- | check a window for the given tag
hasTag :: String -> Window -> X Bool
withTaggedP :: String -> (Window -> WindowSet -> WindowSet) -> X ()

-- | apply a pure function to windows with a tag
withTaggedGlobalP :: String -> (Window -> WindowSet -> WindowSet) -> X ()
withFocusedP :: (Window -> WindowSet -> WindowSet) -> X ()
withTagged :: String -> (Window -> X ()) -> X ()
withTaggedGlobal :: String -> (Window -> X ()) -> X ()
focusUpTagged :: String -> X ()
focusUpTaggedGlobal :: String -> X ()

-- | Move the focus in a group of windows, which share the same given tag.
--   The Global variants move through all workspaces, whereas the other
--   ones operate only on the current workspace
focusDownTagged :: String -> X ()
focusDownTaggedGlobal :: String -> X ()
shiftHere :: (Ord a, Eq s, Eq i) => a -> StackSet i l a s sd -> StackSet i l a s sd
shiftToScreen :: (Ord a, Eq s, Eq i) => s -> a -> StackSet i l a s sd -> StackSet i l a s sd
tagPrompt :: XPConfig -> (String -> X ()) -> X ()
tagDelPrompt :: XPConfig -> X ()
instance XPrompt TagPrompt


-- | A ssh prompt for XMonad
module XMonad.Prompt.Ssh
sshPrompt :: XPConfig -> X ()
instance XPrompt Ssh


-- | A prompt for changing the theme of the current workspace
module XMonad.Prompt.Theme
themePrompt :: XPConfig -> X ()
instance XPrompt ThemePrompt


-- | A layout modifier to add a bar of tabs to your layouts.
module XMonad.Layout.TabBarDecoration

-- | Add, on the top of the screen, a simple bar of tabs to a given |
--   layout, with the default theme and the default shrinker.
simpleTabBar :: (Eq a) => l a -> ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen l) a

-- | Same of <a>simpleTabBar</a>, but with the possibility of setting a
--   custom shrinker, a custom theme and the position: <a>Top</a> or
--   <a>Bottom</a>.
tabBar :: (Eq a, Shrinker s) => s -> Theme -> XPPosition -> l a -> ModifiedLayout (Decoration TabBarDecoration s) l a

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme
shrinkText :: DefaultShrinker
data TabBarDecoration a
TabBar :: XPPosition -> TabBarDecoration a
data XPPosition
Top :: XPPosition
Bottom :: XPPosition
instance Read (TabBarDecoration a)
instance Show (TabBarDecoration a)
instance (Eq a) => DecorationStyle TabBarDecoration a


-- | A collection of decorated layouts: some of them may be nice, some
--   usable, others just funny.
module XMonad.Layout.DecorationMadness

-- | A <a>Circle</a> layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDefault.png</a>
circleSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) Circle Window

-- | Similar to <a>circleSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDefault :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) Circle Window

-- | A <a>Circle</a> layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDefaultResizable.png</a>
circleSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Circle)) Window

-- | Similar to <a>circleSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
circleDefaultResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Circle)) Window

-- | A <a>Circle</a> layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDeco.png</a>
circleSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) Circle Window

-- | A <a>Circle</a> layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDecoResizable.png</a>
circleSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Circle)) Window

-- | Similar to <tt>circleSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDeco :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) Circle Window

-- | Similar to <a>circleSimpleDecoResizable</a> but with the possibility
--   of setting a custom shrinker and a custom theme.
circleDecoResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Circle)) Window

-- | A <a>Circle</a> layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDwmStyle.png</a>
circleSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) Circle Window

-- | Similar to <a>circleSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDwmStyle :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) Circle Window

-- | A <a>Circle</a> layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleTabbed.png</a>
circleSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen Circle) Window

-- | Similar to <a>circleSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleTabbed :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen Circle) Window

-- | An <a>Accordion</a> layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDefault.png</a>
accordionSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) Accordion Window

-- | Similar to <a>accordionSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDefault :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
accordionSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | Similar to <a>accordionSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
accordionDefaultResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | An <a>Accordion</a> layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDeco.png</a>
accordionSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
accordionSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | Similar to <tt>accordionSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDeco :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) Accordion Window

-- | Similar to <a>accordionSimpleDecoResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
accordionDecoResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | An <a>Accordion</a> layout with the xmonad DwmStyle decoration,
--   default theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDwmStyle.png</a>
accordionSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) Accordion Window

-- | Similar to <a>accordionSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDwmStyle :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleTabbed.png</a>
accordionSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen Accordion) Window

-- | Similar to <a>accordionSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionTabbed :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen Accordion) Window

-- | A <a>Tall</a> layout with the xmonad default decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDefault.png</a>
tallSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) Tall Window

-- | Similar to <a>tallSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDefault :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) Tall Window

-- | A <a>Tall</a> layout with the xmonad default decoration, default theme
--   and default shrinker, but with the possibility of moving windows with
--   the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDefaultResizable.png</a>
tallSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | Similar to <a>tallSimpleDefaultResizable</a> but with the possibility
--   of setting a custom shrinker and a custom theme.
tallDefaultResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | A <a>Tall</a> layout with the xmonad simple decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDeco.png</a>
tallSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) Tall Window

-- | Similar to <tt>tallSimpleDece</tt> but with the possibility of setting
--   a custom shrinker and a custom theme.
tallDeco :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) Tall Window

-- | A <a>Tall</a> layout with the xmonad simple decoration, default theme
--   and default shrinker, but with the possibility of moving windows with
--   the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDecoResizable.png</a>
tallSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | Similar to <a>tallSimpleDecoResizable</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDecoResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | A <a>Tall</a> layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDwmStyle.png</a>
tallSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) Tall Window

-- | Similar to <a>tallSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDwmStyle :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) Tall Window

-- | A <a>Tall</a> layout with the xmonad tabbed decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleTabbed.png</a>
tallSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen Tall) Window

-- | Similar to <a>tallSimpleTabbed</a> but with the possibility of setting
--   a custom shrinker and a custom theme.
tallTabbed :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen Tall) Window

-- | A 'Mirror Tall' layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDefault.png</a>
mirrorTallSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (Mirror Tall) Window

-- | Similar to <a>mirrorTallSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDefault :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDefaultResizable.png</a>
mirrorTallSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | Similar to <a>mirrorTallSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
mirrorTallDefaultResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | A 'Mirror Tall' layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDeco.png</a>
mirrorTallSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (Mirror Tall) Window

-- | Similar to <tt>mirrorTallSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDeco :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDecoResizable.png</a>
mirrorTallSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | Similar to <a>mirrorTallSimpleDecoResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
mirrorTallDecoResizable :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | A 'Mirror Tall' layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDwmStyle.png</a>
mirrorTallSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) (Mirror Tall) Window

-- | Similar to <a>mirrorTallSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDwmStyle :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleTabbed.png</a>
mirrorTallSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen (Mirror Tall)) Window

-- | Similar to <a>mirrorTallSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallTabbed :: (Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen (Mirror Tall)) Window

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleSimple.png</a>
floatSimpleSimple :: (Show a, Eq a) => ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a
floatSimple :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <a>DefaultDecoration</a> style.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleDefault.png</a>
floatSimpleDefault :: (Show a, Eq a) => ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleDefault</a>, but with the possibility of setting
--   a custom shrinker and a custom theme.
floatDefault :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <a>DwmStyle</a>. Note that this is
--   a keyboard only floating layout.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleDwmStyle.png</a>
floatSimpleDwmStyle :: (Show a, Eq a) => ModifiedLayout (Decoration DwmStyle DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleDwmStyle</a>, but with the possibility of
--   setting a custom shrinker and a custom theme.
floatDwmStyle :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <tt>TabbedDecoration</tt> style. |
--   Mouse dragging is somehow weird.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleTabbed.png</a>
floatSimpleTabbed :: (Show a, Eq a) => ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleTabbed</a>, but with the possibility of setting
--   a custom shrinker and a custom theme.
floatTabbed :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | The default xmonad <a>Theme</a>.
defaultTheme :: Theme
shrinkText :: DefaultShrinker


-- | A directory prompt for XMonad
module XMonad.Prompt.Directory
directoryPrompt :: XPConfig -> String -> (String -> X ()) -> X ()
instance XPrompt Dir


-- | WorkspaceDir is an extension to set the current directory in a
--   workspace.
--   
--   Actually, it sets the current directory in a layout, since there's no
--   way I know of to attach a behavior to a workspace. This means that any
--   terminals (or other programs) pulled up in that workspace (with that
--   layout) will execute in that working directory. Sort of handy, I
--   think.
--   
--   Note this extension requires the <tt>directory</tt> package to be
--   installed.
module XMonad.Layout.WorkspaceDir
workspaceDir :: (LayoutClass l a) => String -> l a -> ModifiedLayout WorkspaceDir l a
changeDir :: XPConfig -> X ()
instance Typeable Chdir
instance Read (WorkspaceDir a)
instance Show (WorkspaceDir a)
instance LayoutModifier WorkspaceDir Window
instance Message Chdir


-- | A prompt for appending a single line of text to a file. Useful for
--   keeping a file of notes, things to remember for later, and so on---
--   using a keybinding, you can write things down just about as quickly as
--   you think of them, so it doesn't have to interrupt whatever else
--   you're doing.
--   
--   Who knows, it might be useful for other purposes as well!
module XMonad.Prompt.AppendFile

-- | Given an XPrompt configuration and a file path, prompt the user for a
--   line of text, and append it to the given file.
appendFilePrompt :: XPConfig -> FilePath -> X ()
instance XPrompt AppendFile


-- | A module for launch applicationes that receive parameters in the
--   command line. The launcher call a prompt to get the parameters.
module XMonad.Prompt.AppLauncher

-- | Get the user's response to a prompt an launch an application using the
--   input as command parameters of the application.
launchApp :: XPConfig -> Application -> X ()
instance XPrompt AppPrompt


-- | A directory file executables prompt for XMonad. This might be useful
--   if you don't want to have scripts in your PATH environment variable
--   (same executable names, different behavior) - otherwise you might want
--   to use <a>XMonad.Prompt.Shell</a> instead - but you want to have easy
--   access to these executables through the xmonad's prompt.
module XMonad.Prompt.DirExec

-- | Function <a>dirExecPrompt</a> starts the prompt with list of all
--   executable files in directory specified by <a>FilePath</a>. The name
--   of the prompt is taken from the last element of the path. If you
--   specify root directory - <tt>/</tt> - as the path, name <tt>Root:</tt>
--   will be used as the name of the prompt instead. The <a>XPConfig</a>
--   parameter can be used to customize visuals of the prompt. The runner
--   parameter specifies the function used to run the program - see usage
--   for more information
dirExecPrompt :: XPConfig -> (String -> X ()) -> FilePath -> X ()

-- | Function <a>dirExecPromptNamed</a> does the same as
--   <a>dirExecPrompt</a> except the name of the prompt is specified by
--   <a>String</a> parameter.
dirExecPromptNamed :: XPConfig -> (String -> X ()) -> FilePath -> String -> X ()
instance XPrompt DirExec


-- | A generic framework for prompting the user for input and passing it
--   along to some other action.
module XMonad.Prompt.Input

-- | Given a prompt configuration and some prompt text, create an X action
--   which pops up a prompt waiting for user input, and returns whatever
--   they type. Note that the type of the action is <tt>X (Maybe
--   String)</tt>, which reflects the fact that the user might cancel the
--   prompt (resulting in <tt>Nothing</tt>), or enter an input string
--   <tt>s</tt> (resulting in <tt>Just s</tt>).
inputPrompt :: XPConfig -> String -> X (Maybe String)

-- | The same as <a>inputPrompt</a>, but with a completion function. The
--   type <tt>ComplFunction</tt> is <tt>String -&gt; IO [String]</tt>, as
--   defined in <a>XMonad.Prompt</a>. The <a>mkComplFunFromList</a> utility
--   function, also defined in <a>XMonad.Prompt</a>, is useful for creating
--   such a function from a known list of possibilities.
inputPromptWithCompl :: XPConfig -> String -> ComplFunction -> X (Maybe String)

-- | A combinator for hooking up an input prompt action to a function which
--   can take the result of the input prompt and produce another action. If
--   the user cancels the input prompt, the second function will not be
--   run.
--   
--   The astute student of types will note that this is actually a very
--   general combinator and has nothing in particular to do with input
--   prompts. If you find a more general use for it and want to move it to
--   a different module, be my guest.
(?+) :: (Monad m) => m (Maybe a) -> (a -> m ()) -> m ()
instance XPrompt InputPrompt


-- | A prompt for sending quick, one-line emails, via the standard GNU
--   'mail' utility (which must be in your $PATH). This module is intended
--   mostly as an example of using <a>XMonad.Prompt.Input</a> to build an
--   action requiring user input.
module XMonad.Prompt.Email

-- | Prompt the user for a recipient, subject, and body, and send an email
--   via the GNU 'mail' utility. The second argument is a list of addresses
--   for autocompletion.
emailPrompt :: XPConfig -> [String] -> X ()


-- | A manual page prompt for XMonad window manager.
--   
--   TODO
--   
--   <ul>
--   <li>narrow completions by section number, if the one is specified
--   (like <tt>/etc/bash_completion</tt> does)</li>
--   </ul>
module XMonad.Prompt.Man

-- | Query for manual page to be displayed.
manPrompt :: XPConfig -> X ()

-- | Run a command using shell and return its output.
--   
--   XXX Merge into <tt>XMonad.Util.Run</tt>?
--   
--   (Ask "gurus" whether <tt>evaluate (length ...)</tt> approach is
--   better/more idiomatic.)
getCommandOutput :: String -> IO String
instance XPrompt Man


-- | This module provides tools to automatically manage <tt>dock</tt> type
--   programs, such as gnome-panel, kicker, dzen, and xmobar.
module XMonad.Hooks.ManageDocks

-- | Detects if the given window is of type DOCK and if so, reveals it, but
--   does not manage it. If the window has the STRUT property set, adjust
--   the gap accordingly.
manageDocks :: ManageHook

-- | Checks if a window is a DOCK or DESKTOP window
checkDock :: Query Bool
data AvoidStruts a

-- | Adjust layout automagically: don't cover up any docks, status bars,
--   etc.
avoidStruts :: (LayoutClass l a) => l a -> ModifiedLayout AvoidStruts l a

-- | Adjust layout automagically: don't cover up docks, status bars, etc.
--   on the indicated sides of the screen. Valid sides are U (top), D
--   (bottom), R (right), or L (left).
avoidStrutsOn :: (LayoutClass l a) => [Direction2D] -> l a -> ModifiedLayout AvoidStruts l a

-- | Message type which can be sent to an <a>AvoidStruts</a> layout
--   modifier to alter its behavior.
data ToggleStruts
ToggleStruts :: ToggleStruts
ToggleStrut :: Direction2D -> ToggleStruts

-- | SetStruts is a message constructor used to set or unset specific
--   struts, regardless of whether or not the struts were originally set.
--   Here are some example bindings:
--   
--   Show all gaps:
--   
--   <pre>
--   ,((modm .|. shiftMask  ,xK_b),sendMessage $ SetStruts [minBound .. maxBound] [])
--   </pre>
--   
--   Hide all gaps:
--   
--   <pre>
--   ,((modm .|. controlMask,xK_b),sendMessage $ SetStruts [] [minBound .. maxBound])
--   </pre>
--   
--   Show only upper and left gaps:
--   
--   <pre>
--   ,((modm .|. controlMask .|. shiftMask,xK_b),sendMessage $ SetStruts [U,L] [minBound .. maxBound])
--   </pre>
--   
--   Hide the bottom keeping whatever the other values were:
--   
--   <pre>
--   ,((modm .|. controlMask .|. shiftMask,xK_g),sendMessage $ SetStruts [] [D])
--   </pre>
data SetStruts
SetStruts :: [Direction2D] -> [Direction2D] -> SetStruts
addedStruts :: SetStruts -> [Direction2D]

-- | These are removed from the currently set struts before
--   <a>addedStruts</a> are added.
removedStruts :: SetStruts -> [Direction2D]

-- | Goes through the list of windows and find the gap so that all STRUT
--   settings are satisfied.
calcGap :: Set Direction2D -> X (Rectangle -> Rectangle)
instance Typeable SetStruts
instance Typeable ToggleStruts
instance Read SetStruts
instance Show SetStruts
instance Read ToggleStruts
instance Show ToggleStruts
instance Read (AvoidStruts a)
instance Show (AvoidStruts a)
instance LayoutModifier AvoidStruts a
instance Message SetStruts
instance Message ToggleStruts


-- | Move and resize floating windows using other windows and the edge of
--   the screen as guidelines.
module XMonad.Actions.FloatSnap

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | Move a window in the specified direction until it snaps against
--   another window or the edge of the screen.
snapMove :: Direction2D -> Maybe Int -> Window -> X ()

-- | Grow the specified edge of a window until it snaps against another
--   window or the edge of the screen.
snapGrow :: Direction2D -> Maybe Int -> Window -> X ()

-- | Shrink the specified edge of a window until it snaps against another
--   window or the edge of the screen.
snapShrink :: Direction2D -> Maybe Int -> Window -> X ()

-- | Move a window by both axises in any direction to snap against the
--   closest part of other windows or the edge of the screen.
snapMagicMove :: Maybe Int -> Maybe Int -> Window -> X ()

-- | Resize the window by each edge independently to snap against the
--   closest part of other windows or the edge of the screen.
snapMagicResize :: [Direction2D] -> Maybe Int -> Maybe Int -> Window -> X ()

-- | Resize the window by each edge independently to snap against the
--   closest part of other windows or the edge of the screen. Use the
--   location of the mouse over the window to decide which edges to snap.
--   In corners, the two adjoining edges will be snapped, along the middle
--   of an edge only that edge will be snapped. In the center of the window
--   all edges will snap. Intended to be used together with
--   <a>XMonad.Actions.FlexibleResize</a> or
--   <a>XMonad.Actions.FlexibleManipulate</a>.
snapMagicMouseResize :: Rational -> Maybe Int -> Maybe Int -> Window -> X ()


-- | xmonad calls the logHook with every internal state update, which is
--   useful for (among other things) outputting status information to an
--   external status bar program such as xmobar or dzen. DynamicLog
--   provides several drop-in logHooks for this purpose, as well as
--   flexible tools for specifying your own formatting.
module XMonad.Hooks.DynamicLog

-- | Run xmonad with a dzen status bar set to some nice defaults.
--   
--   <pre>
--   main = xmonad =&lt;&lt; dzen myConfig
--   
--   myConfig = defaultConfig { ... }
--   </pre>
--   
--   The intent is that the above config file should provide a nice status
--   bar with minimal effort.
--   
--   If you wish to customize the status bar format at all, you'll have to
--   use the <a>statusBar</a> function instead.
--   
--   The binding uses the XMonad.Hooks.ManageDocks module to automatically
--   handle screen placement for dzen, and enables 'mod-b' for toggling the
--   menu bar.
dzen :: (LayoutClass l Window) => XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | Run xmonad with a xmobar status bar set to some nice defaults.
--   
--   <pre>
--   main = xmonad =&lt;&lt; xmobar myConfig
--   
--   myConfig = defaultConfig { ... }
--   </pre>
--   
--   This works pretty much the same as <a>dzen</a> function above.
xmobar :: (LayoutClass l Window) => XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | Modifies the given base configuration to launch the given status bar,
--   send status information to that bar, and allocate space on the screen
--   edges for the bar.
statusBar :: (LayoutClass l Window) => String -> PP -> (XConfig Layout -> (KeyMask, KeySym)) -> XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | An example log hook, which prints status information to stdout in the
--   default format:
--   
--   <pre>
--   1 2 [3] 4 7 : full : title
--   </pre>
--   
--   That is, the currently populated workspaces, the current workspace
--   layout, and the title of the focused window.
--   
--   To customize the output format, see <a>dynamicLogWithPP</a>.
dynamicLog :: X ()

-- | Workspace logger with a format designed for Xinerama:
--   
--   <pre>
--   [1 9 3] 2 7
--   </pre>
--   
--   where 1, 9, and 3 are the workspaces on screens 1, 2 and 3,
--   respectively, and 2 and 7 are non-visible, non-empty workspaces.
--   
--   Unfortunately, at the present time, the current layout and window
--   title are not shown, and there is no way to incorporate the xinerama
--   workspace format shown above with <a>dynamicLogWithPP</a>. Hopefully
--   this will change soon.
dynamicLogXinerama :: X ()

-- | Write a string to the property _XMONAD_LOG on the root window. This
--   property is of type UTF8_STRING. The string must have been processed
--   by encodeString (dynamicLogString does this).
xmonadPropLog :: String -> X ()

-- | Format the current status using the supplied pretty-printing format,
--   and write it to stdout.
dynamicLogWithPP :: PP -> X ()

-- | The same as <a>dynamicLogWithPP</a>, except it simply returns the
--   status as a formatted string without actually printing it to stdout,
--   to allow for further processing, or use in some application other than
--   a status bar.
dynamicLogString :: PP -> X String

-- | The <a>PP</a> type allows the user to customize the formatting of
--   status information.
data PP
PP :: (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> String -> String -> (String -> String) -> (String -> String) -> ([String] -> [String]) -> X ([WindowSpace] -> [WindowSpace]) -> [X (Maybe String)] -> (String -> IO ()) -> PP

-- | how to print the tag of the currently focused workspace
ppCurrent :: PP -> WorkspaceId -> String

-- | how to print tags of visible but not focused workspaces (xinerama
--   only)
ppVisible :: PP -> WorkspaceId -> String

-- | how to print tags of hidden workspaces which contain windows
ppHidden :: PP -> WorkspaceId -> String

-- | how to print tags of empty hidden workspaces
ppHiddenNoWindows :: PP -> WorkspaceId -> String

-- | format to be applied to tags of urgent workspaces.
ppUrgent :: PP -> WorkspaceId -> String

-- | separator to use between different log sections (window name, layout,
--   workspaces)
ppSep :: PP -> String

-- | separator to use between workspace tags
ppWsSep :: PP -> String

-- | window title format
ppTitle :: PP -> String -> String

-- | layout name format
ppLayout :: PP -> String -> String

-- | how to order the different log sections. By default, this function
--   receives a list with three formatted strings, representing the
--   workspaces, the layout, and the current window title, respectively. If
--   you have specified any extra loggers in <a>ppExtras</a>, their output
--   will also be appended to the list. To get them in the reverse order,
--   you can just use <tt>ppOrder = reverse</tt>. If you don't want to
--   display the current layout, you could use something like <tt>ppOrder =
--   \(ws:_:t:_) -&gt; [ws,t]</tt>, and so on.
ppOrder :: PP -> [String] -> [String]

-- | how to sort the workspaces. See <a>XMonad.Util.WorkspaceCompare</a>
--   for some useful sorts.
ppSort :: PP -> X ([WindowSpace] -> [WindowSpace])

-- | loggers for generating extra information such as time and date, system
--   load, battery status, and so on. See <a>XMonad.Util.Loggers</a> for
--   examples, or create your own!
ppExtras :: PP -> [X (Maybe String)]

-- | applied to the entire formatted string in order to output it. Can be
--   used to specify an alternative output method (e.g. write to a pipe
--   instead of stdout), and/or to perform some last-minute formatting.
ppOutput :: PP -> String -> IO ()

-- | The default pretty printing options, as seen in <a>dynamicLog</a>.
defaultPP :: PP

-- | Settings to emulate dwm's statusbar, dzen only.
dzenPP :: PP

-- | Some nice xmobar defaults.
xmobarPP :: PP

-- | The options that sjanssen likes to use with xmobar, as an example.
--   Note the use of <a>xmobarColor</a> and the record update on
--   <a>defaultPP</a>.
sjanssenPP :: PP

-- | The options that byorgey likes to use with dzen, as another example.
byorgeyPP :: PP

-- | Wrap a string in delimiters, unless it is empty.
wrap :: String -> String -> String -> String

-- | Pad a string with a leading and trailing space.
pad :: String -> String

-- | Trim leading and trailing whitespace from a string.
trim :: String -> String

-- | Limit a string to a certain length, adding <a>...</a> if truncated.
shorten :: Int -> String -> String

-- | Use xmobar escape codes to output a string with given foreground and
--   background colors.
xmobarColor :: String -> String -> String -> String

-- | Strip xmobar markup.
xmobarStrip :: String -> String

-- | Use dzen escape codes to output a string with given foreground and
--   background colors.
dzenColor :: String -> String -> String -> String

-- | Escape any dzen metacharacters.
dzenEscape :: String -> String

-- | Strip dzen formatting or commands.
dzenStrip :: String -> String

-- | Format the workspace information, given a workspace sorting function,
--   a list of urgent windows, a pretty-printer format, and the current
--   WindowSet.
pprWindowSet :: WorkspaceSort -> [Window] -> PP -> WindowSet -> String
pprWindowSetXinerama :: WindowSet -> String


-- | Turns your workspaces into a more topic oriented system.
module XMonad.Actions.TopicSpace

-- | <a>Topic</a> is just an alias for <a>WorkspaceId</a>
type Topic = WorkspaceId

-- | <a>Dir</a> is just an alias for <a>FilePath</a> but should points to a
--   directory.
type Dir = FilePath

-- | Here is the topic space configuration area.
data TopicConfig
TopicConfig :: Map Topic Dir -> Map Topic (X ()) -> (Topic -> X ()) -> Topic -> Int -> TopicConfig

-- | This mapping associate a directory to each topic.
topicDirs :: TopicConfig -> Map Topic Dir

-- | This mapping associate an action to trigger when switching to a given
--   topic which workspace is empty.
topicActions :: TopicConfig -> Map Topic (X ())

-- | This is the default topic action.
defaultTopicAction :: TopicConfig -> Topic -> X ()

-- | This is the default topic.
defaultTopic :: TopicConfig -> Topic

-- | This setups the maximum depth of topic history, usually 10 is a good
--   default since we can bind all of them using numeric keypad.
maxTopicHistory :: TopicConfig -> Int
defaultTopicConfig :: TopicConfig

-- | Returns the list of last focused workspaces the empty list otherwise.
getLastFocusedTopics :: X [String]

-- | Given a <a>TopicConfig</a>, the last focused topic, and a predicate
--   that will select topics that one want to keep, this function will set
--   the property of last focused topics.
setLastFocusedTopic :: TopicConfig -> Topic -> (Topic -> Bool) -> X ()

-- | This function is a variant of <a>pprWindowSet</a> which takes a topic
--   configuration and a pretty-printing record <a>PP</a>. It will show the
--   list of topics sorted historically and highlighting topics with urgent
--   windows.
pprWindowSet :: TopicConfig -> PP -> X String

-- | Given a prompt configuration and a topic configuration, triggers the
--   action associated with the topic given in prompt.
topicActionWithPrompt :: XPConfig -> TopicConfig -> X ()

-- | Given a configuration and a topic, triggers the action associated with
--   the given topic.
topicAction :: TopicConfig -> Topic -> X ()

-- | Trigger the action associated with the current topic.
currentTopicAction :: TopicConfig -> X ()

-- | Switch to the given topic.
switchTopic :: TopicConfig -> Topic -> X ()

-- | Switch to the Nth last focused topic or failback to the
--   <a>defaultTopic</a>.
switchNthLastFocused :: TopicConfig -> Int -> X ()

-- | Shift the focused window to the Nth last focused topic, or fallback to
--   doing nothing.
shiftNthLastFocused :: Int -> X ()

-- | Returns the directory associated with current topic returns the empty
--   string otherwise.
currentTopicDir :: TopicConfig -> X String

-- | Check the given topic configuration for duplicates topics or undefined
--   topics.
checkTopicConfig :: [Topic] -> TopicConfig -> IO ()

-- | An alias for <tt>flip replicateM_</tt>
(>*>) :: (Monad m) => m a -> Int -> m ()
instance Typeable PrevTopics
instance Read PrevTopics
instance Show PrevTopics
instance ExtensionClass PrevTopics


-- | Utility functions for simulating independent sets of workspaces on
--   each screen (like dwm's workspace model), using internal tags to
--   distinguish workspaces associated with each screen.
module XMonad.Layout.IndependentScreens
type VirtualWorkspace = WorkspaceId
type PhysicalWorkspace = WorkspaceId
workspaces' :: XConfig l -> [VirtualWorkspace]
withScreens :: ScreenId -> [VirtualWorkspace] -> [PhysicalWorkspace]
onCurrentScreen :: (VirtualWorkspace -> WindowSet -> a) -> (PhysicalWorkspace -> WindowSet -> a)

-- | This turns a naive pretty-printer into one that is aware of the
--   independent screens. That is, you can write your pretty printer to
--   behave the way you want on virtual workspaces; this function will
--   convert that pretty-printer into one that first filters out physical
--   workspaces on other screens, then converts all the physical workspaces
--   on this screen to their virtual names.
--   
--   For example, if you have handles <tt>hLeft</tt> and <tt>hRight</tt>
--   for bars on the left and right screens, respectively, and <tt>pp</tt>
--   is a pretty-printer function that takes a handle, you could write
--   
--   <pre>
--   logHook = let log screen handle = dynamicLogWithPP . marshallPP screen . pp $ handle
--             in log 0 hLeft &gt;&gt; log 1 hRight
--   </pre>
marshallPP :: ScreenId -> PP -> PP

-- | In case you don't know statically how many screens there will be, you
--   can call this in main before starting xmonad. For example, part of my
--   config reads
--   
--   <pre>
--   main = do
--     nScreens &lt;- countScreens
--     xmonad $ defaultConfig {
--       ...
--       workspaces = withScreens nScreens (workspaces defaultConfig),
--       ...
--       }
--   </pre>
countScreens :: (MonadIO m, Integral i) => m i
marshall :: ScreenId -> VirtualWorkspace -> PhysicalWorkspace
unmarshall :: PhysicalWorkspace -> (ScreenId, VirtualWorkspace)
unmarshallS :: PhysicalWorkspace -> ScreenId
unmarshallW :: PhysicalWorkspace -> VirtualWorkspace

-- | Convert the tag of the <a>WindowSpace</a> from a
--   <a>VirtualWorkspace</a> to a <a>PhysicalWorkspace</a>.
marshallWindowSpace :: ScreenId -> WindowSpace -> WindowSpace

-- | Convert the tag of the <a>WindowSpace</a> from a
--   <a>PhysicalWorkspace</a> to a <a>VirtualWorkspace</a>.
unmarshallWindowSpace :: WindowSpace -> WindowSpace


-- | A collection of simple logger functions and formatting utilities which
--   can be used in the <a>ppExtras</a> field of a pretty-printing status
--   logger format. See <a>XMonad.Hooks.DynamicLog</a> for more
--   information.
module XMonad.Util.Loggers

-- | <a>Logger</a> is just a convenient synonym for <tt>X (Maybe
--   String)</tt>.
type Logger = X (Maybe String)

-- | Get the current volume with <tt>aumix</tt>.
--   <a>http://jpj.net/~trevor/aumix.html</a>
aumixVolume :: Logger

-- | Get the battery status (percent charge and charging/discharging
--   status). This is an ugly hack and may not work for some people. At
--   some point it would be nice to make this more general/have fewer
--   dependencies (assumes <tt>/usr/bin/acpi</tt> and <tt>sed</tt> are
--   installed.)
battery :: Logger

-- | Get the current date and time, and format them via the given format
--   string. The format used is the same as that used by the C library
--   function strftime; for example, <tt>date "%a %b %d"</tt> might display
--   something like <tt>Tue Feb 19</tt>. For more information see something
--   like
--   <a>http://www.cplusplus.com/reference/clibrary/ctime/strftime.html</a>.
date :: String -> Logger

-- | Get the load average. This assumes that you have a utility called
--   <tt>/usr/bin/uptime</tt> and that you have <tt>sed</tt> installed;
--   these are fairly common on GNU/Linux systems but it would be nice to
--   make this more general.
loadAvg :: Logger

-- | Get a count of new mails in a maildir.
maildirNew :: FilePath -> Logger

-- | Get a count of unread mails in a maildir. For maildir format details,
--   to write loggers for other classes of mail, see
--   <a>http://cr.yp.to/proto/maildir.html</a> and <a>logFileCount</a>.
maildirUnread :: FilePath -> Logger

-- | Create a <a>Logger</a> from an arbitrary shell command.
logCmd :: String -> Logger

-- | Get a count of filtered files in a directory. See <a>maildirUnread</a>
--   and <a>maildirNew</a> source for usage examples.
logFileCount :: FilePath -> (String -> Bool) -> Logger

-- | Get the name of the current workspace.
logCurrent :: Logger

-- | Get the name of the current layout.
logLayout :: Logger

-- | Get the title (name) of the focused window.
logTitle :: Logger

-- | Use a string formatting function to edit a <a>Logger</a> string. For
--   example, to create a tag function to prefix or label loggers, as in
--   'tag: output', use:
--   
--   <pre>
--   tagL l = onLogger $ wrap (l ++ ": ") ""
--   
--      tagL "bat" battery
--      tagL "load" loadAvg
--   </pre>
--   
--   If you already have a (String -&gt; String) function you want to apply
--   to a logger:
--   
--   <pre>
--   revL = onLogger trim
--   </pre>
--   
--   See formatting utility source code for more <a>onLogger</a> usage
--   examples.
onLogger :: (String -> String) -> Logger -> Logger

-- | Wrap a logger's output in delimiters, unless it is <tt>X
--   (Nothing)</tt> or <tt>X (Just "")</tt>. Some examples:
--   
--   <pre>
--   wrapL " | " " | " (date "%a %d %b") -- ' | Tue 19 Feb | '
--   
--   wrapL "bat: " "" battery            -- ' bat: battery_logger_output'
--   </pre>
wrapL :: String -> String -> Logger -> Logger

-- | Make a logger's output constant width by padding with the given
--   string, <i>even if the logger is</i> <tt>X (Nothing)</tt> <i>or</i>
--   <tt>X (Just "")</tt>. Useful to reduce visual noise as a title logger
--   shrinks and grows, to use a fixed width for a logger that sometimes
--   becomes Nothing, or even to create fancy spacers or character based
--   art effects.
--   
--   It fills missing logger output with a repeated character like ".", ":"
--   or pattern, like " -.-". The cycling padding string is reversed on the
--   left of the logger output. This is mainly useful with AlignCenter.
fixedWidthL :: Align -> String -> Int -> Logger -> Logger

-- | Create a "spacer" logger, e.g. <tt>logSp 3 -- loggerizes ' '</tt>. For
--   more complex "spacers", use <a>fixedWidthL</a> with <tt>return
--   Nothing</tt>.
logSp :: Int -> Logger

-- | Pad a logger's output with a leading and trailing space, unless it is
--   <tt>X (Nothing)</tt> or <tt>X (Just "")</tt>.
padL :: Logger -> Logger

-- | Limit a logger's length, adding "..." if truncated.
shortenL :: Int -> Logger -> Logger

-- | Color a logger's output with dzen foreground and background colors.
--   
--   <pre>
--   dzenColorL "green" "#2A4C3F" battery
--   </pre>
dzenColorL :: String -> String -> Logger -> Logger

-- | Color a logger's output with xmobar foreground and background colors.
--   
--   <pre>
--   xmobarColorL "#6A5ACD" "gray6" loadAverage
--   </pre>
xmobarColorL :: String -> String -> Logger -> Logger

-- | An infix synonym for <a>fmap</a>.
(<$>) :: (Functor f) => (a -> b) -> f a -> f b


-- | This module provides a config suitable for use with a desktop
--   environment such as KDE or GNOME.
module XMonad.Config.Desktop
desktopConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
desktopLayoutModifiers :: (LayoutClass l a) => l a -> ModifiedLayout AvoidStruts l a


-- | This module provides a config suitable for use with the GNOME desktop
--   environment.
module XMonad.Config.Gnome
gnomeConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))

-- | Launch the <a>Run Application</a> dialog. gnome-panel must be running
--   for this to work.
gnomeRun :: X ()

-- | Register xmonad with gnome. 'dbus-send' must be in the $PATH with
--   which xmonad is started.
--   
--   This action reduces a delay on startup only only if you have
--   configured gnome-session&gt;=2.26: to start xmonad with a command as
--   such:
--   
--   <pre>
--   gconftool-2 -s /desktop/gnome/session/required_components/windowmanager xmonad --type string
--   </pre>
gnomeRegister :: (MonadIO m) => m ()


-- | This module provides a config suitable for use with the KDE desktop
--   environment.
module XMonad.Config.Kde
kdeConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
kde4Config :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))


-- | This module provides a config suitable for use with the Xfce desktop
--   environment.
module XMonad.Config.Xfce
xfceConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))


-- | Support for simple mouse gestures.
module XMonad.Actions.MouseGestures

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | <tt><a>mouseGestureH</a> moveHook endHook</tt> is a mouse button event
--   handler. It collects mouse movements, calling <tt>moveHook</tt> for
--   each update; when the button is released, it calls <tt>endHook</tt>.
mouseGestureH :: (Direction2D -> X ()) -> X () -> X ()

-- | A utility function on top of <a>mouseGestureH</a>. It uses a
--   <a>Map</a> to look up the mouse gesture, then executes the
--   corresponding action (if any).
mouseGesture :: Map [Direction2D] (Window -> X ()) -> Window -> X ()

-- | A callback generator for <a>mouseGestureH</a>. <a>mkCollect</a>
--   returns two callback functions for passing to <a>mouseGestureH</a>.
--   The move hook will collect mouse movements (and return the current
--   gesture as a list); the end hook will return a list of the completed
--   gesture, which you can access with <a>&gt;&gt;=</a>.
mkCollect :: (MonadIO m, MonadIO m') => m (Direction2D -> m' [Direction2D], m' [Direction2D])


-- | License : BSD3-style (see LICENSE) Stability : unstable Portability :
--   unportable
--   
--   This is a rewrite of <a>XMonad.Layout.WindowNavigation</a>.
--   WindowNavigation lets you assign keys to move up/down/left/right,
--   based on actual cartesian window coordinates, rather than just going
--   j/k on the stack.
--   
--   This module is experimental. You'll have better luck with the
--   original.
--   
--   This module differs from the other in a few ways:
--   
--   <ol>
--   <li>You can go up/down/left/right across multiple screens.</li>
--   <li>It doesn't provide little border colors for your neighboring
--   windows.</li>
--   <li>It doesn't provide the 'Move' action, which seems to be related to
--   the XMonad.Layout.Combo extension.</li>
--   <li>It tries to be slightly smarter about tracking your current
--   position.</li>
--   <li>Configuration is different.</li>
--   </ol>
module XMonad.Actions.WindowNavigation
withWindowNavigation :: (KeySym, KeySym, KeySym, KeySym) -> XConfig l -> IO (XConfig l)
withWindowNavigationKeys :: [((KeyMask, KeySym), WNAction)] -> XConfig l -> IO (XConfig l)
data WNAction
WNGo :: Direction2D -> WNAction
WNSwap :: Direction2D -> WNAction
go :: IORef WNState -> Direction2D -> X ()
swap :: IORef WNState -> Direction2D -> X ()

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D


-- | WindowNavigation is an extension to allow easy navigation of a
--   workspace.
module XMonad.Layout.WindowNavigation
windowNavigation :: (LayoutClass l a) => l a -> ModifiedLayout WindowNavigation l a
configurableNavigation :: (LayoutClass l a) => WNConfig -> l a -> ModifiedLayout WindowNavigation l a
data Navigate
Go :: Direction2D -> Navigate
Swap :: Direction2D -> Navigate
Move :: Direction2D -> Navigate

-- | Apply action with destination window
Apply :: (Window -> X ()) -> Direction2D -> Navigate

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
data MoveWindowToWindow a
MoveWindowToWindow :: a -> a -> MoveWindowToWindow a
navigateColor :: String -> WNConfig
navigateBrightness :: Double -> WNConfig
noNavigateBorders :: WNConfig
defaultWNConfig :: WNConfig
instance Typeable Navigate
instance Typeable1 MoveWindowToWindow
instance Read (WindowNavigation a)
instance Show (WindowNavigation a)
instance Show WNConfig
instance Read WNConfig
instance (Read a) => Read (MoveWindowToWindow a)
instance (Show a) => Show (MoveWindowToWindow a)
instance LayoutModifier WindowNavigation Window
instance Message Navigate
instance (Typeable a) => Message (MoveWindowToWindow a)


-- | A layout that combines multiple layouts.
module XMonad.Layout.Combo
combineTwo :: (Read a, Eq a, LayoutClass super (), LayoutClass l1 a, LayoutClass l2 a) => super () -> l1 a -> l2 a -> CombineTwo (super ()) l1 l2 a
data CombineTwo l l1 l2 a
instance (Read l, Read a, Read (l1 a), Read (l2 a)) => Read (CombineTwo l l1 l2 a)
instance (Show l, Show a, Show (l1 a), Show (l2 a)) => Show (CombineTwo l l1 l2 a)
instance (LayoutClass l (), LayoutClass l1 a, LayoutClass l2 a, Read a, Show a, Eq a, Typeable a) => LayoutClass (CombineTwo (l ()) l1 l2) a


-- | A layout that combines multiple layouts and allows to specify where to
--   put new windows.
module XMonad.Layout.ComboP
combineTwoP :: (LayoutClass super (), LayoutClass l1 Window, LayoutClass l2 Window) => super () -> l1 Window -> l2 Window -> Property -> CombineTwoP (super ()) l1 l2 Window
data CombineTwoP l l1 l2 a
data SwapWindow

-- | Swap window between panes
SwapWindow :: SwapWindow

-- | Swap window between panes in the N-th nested ComboP. <tt>SwapWindowN
--   0</tt> equals to SwapWindow
SwapWindowN :: Int -> SwapWindow

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property
instance Typeable SwapWindow
instance (Read l, Read a, Read (l1 a), Read (l2 a)) => Read (CombineTwoP l l1 l2 a)
instance (Show l, Show a, Show (l1 a), Show (l2 a)) => Show (CombineTwoP l l1 l2 a)
instance Read SwapWindow
instance Show SwapWindow
instance (LayoutClass l (), LayoutClass l1 Window, LayoutClass l2 Window) => LayoutClass (CombineTwoP (l ()) l1 l2) Window
instance Message SwapWindow


-- | Create manually-sized gaps along edges of the screen which will not be
--   used for tiling, along with support for toggling gaps on and off.
--   
--   Note that <a>XMonad.Hooks.ManageDocks</a> is the preferred solution
--   for leaving space for your dock-type applications (status bars,
--   toolbars, docks, etc.), since it automatically sets up appropriate
--   gaps, allows them to be toggled, etc. However, this module may still
--   be useful in some situations where the automated approach of
--   ManageDocks does not work; for example, to work with a dock-type
--   application that does not properly set the STRUTS property, or to
--   leave part of the screen blank which is truncated by a projector, and
--   so on.
module XMonad.Layout.Gaps

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | A manual gap configuration. Each side of the screen on which a gap is
--   enabled is paired with a size in pixels.
type GapSpec = [(Direction2D, Int)]

-- | Add togglable manual gaps to a layout.
gaps :: GapSpec -> l a -> ModifiedLayout Gaps l a

-- | Messages which can be sent to a gap modifier.
data GapMessage

-- | Toggle all gaps.
ToggleGaps :: GapMessage

-- | Toggle a single gap.
ToggleGap :: !Direction2D -> GapMessage

-- | Increase a gap by a certain number of pixels.
IncGap :: !Int -> !Direction2D -> GapMessage

-- | Decrease a gap.
DecGap :: !Int -> !Direction2D -> GapMessage
instance Typeable GapMessage
instance Show (Gaps a)
instance Read (Gaps a)
instance LayoutModifier Gaps a
instance Message GapMessage


-- | Make layouts respect size hints.
module XMonad.Layout.LayoutHints
layoutHints :: (LayoutClass l a) => l a -> ModifiedLayout LayoutHints l a

-- | <tt>layoutHintsWithPlacement (rx, ry) layout</tt> will adapt the sizes
--   of a layout's windows according to their size hints, and position them
--   inside their originally assigned area according to the <tt>rx</tt> and
--   <tt>ry</tt> parameters. (0, 0) places the window at the top left, (1,
--   0) at the top right, (0.5, 0.5) at the center, etc.
layoutHintsWithPlacement :: (LayoutClass l a) => (Double, Double) -> l a -> ModifiedLayout LayoutHints l a

-- | <tt>layoutHintsToCenter layout</tt> applies hints, sliding the window
--   to the center of the screen and expanding its neighbors to fill the
--   gaps. Windows are never expanded in a way that increases overlap.
--   
--   <tt>layoutHintsToCenter</tt> only makes one pass at resizing the
--   neighbors of hinted windows, so with some layouts (ex. the arrangement
--   with two <tt>Mirror</tt> <tt>Tall</tt> stacked vertically),
--   <tt>layoutHintsToCenter</tt> may leave some gaps. Simple layouts like
--   <tt>Tall</tt> are unaffected.
layoutHintsToCenter :: (LayoutClass l a) => l a -> ModifiedLayout LayoutHintsToCenter l a
data LayoutHints a
instance Read (LayoutHintsToCenter a)
instance Show (LayoutHintsToCenter a)
instance Read (LayoutHints a)
instance Show (LayoutHints a)
instance LayoutModifier LayoutHintsToCenter Window
instance LayoutModifier LayoutHints Window


-- | A layout combinator that allows layouts to be nested.
module XMonad.Layout.SubLayouts

-- | The main layout modifier arguments:
--   
--   <pre>
--   subLayout advanceInnerLayouts innerLayout outerLayout
--   </pre>
--   
--   <ul>
--   <li><i><tt>advanceInnerLayouts</tt></i> When a new group at index
--   <tt>n</tt> in the outer layout is created (even with one element), the
--   <tt>innerLayout</tt> is used as the layout within that group after
--   being advanced with <tt>advanceInnerLayouts !! n</tt>
--   <a>NextLayout</a> messages. If there is no corresponding element in
--   the <tt>advanceInnerLayouts</tt> list, then <tt>innerLayout</tt> is
--   not given any <a>NextLayout</a> messages.</li>
--   <li><i><tt>innerLayout</tt></i> The single layout given to be run as a
--   sublayout.</li>
--   <li><i><tt>outerLayout</tt></i> The layout that determines the
--   rectangles given to each group.</li>
--   </ul>
--   
--   Ex. The second group is <a>Tall</a>, the third is <tt>Circle</tt>, all
--   others are tabbed with:
--   
--   <pre>
--   myLayout = addTabs shrinkText defaultTheme
--            $ subLayout [0,1,2] (Simplest ||| Tall 1 0.2 0.5 ||| Circle)
--            $ Tall 1 0.2 0.5 ||| Full
--   </pre>
subLayout :: [Int] -> subl a -> l a -> ModifiedLayout (Sublayout subl) l a

-- | <tt>subTabbed</tt> is a use of <a>subLayout</a> with <a>addTabs</a> to
--   show decorations.
subTabbed :: (Eq a, LayoutModifier (Sublayout Simplest) a, LayoutClass l a) => l a -> ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) (ModifiedLayout (Sublayout Simplest) l) a

-- | <tt>pullGroup</tt>, <tt>pushGroup</tt> allow you to merge windows or
--   groups inheriting the position of the current window (pull) or the
--   other window (push).
--   
--   <tt>pushWindow</tt> and <tt>pullWindow</tt> move individual windows
--   between groups. They are less effective at preserving window
--   positions.
pushGroup :: Direction2D -> Navigate
pullGroup :: Direction2D -> Navigate
pushWindow :: Direction2D -> Navigate
pullWindow :: Direction2D -> Navigate

-- | Apply a function on the stack belonging to the currently focused
--   group. It works for rearranging windows and for changing focus.
onGroup :: (Stack Window -> Stack Window) -> X ()

-- | Send a message to the currently focused sublayout.
toSubl :: (Message a) => a -> X ()

-- | merge the window that would be focused by the function when applied to
--   the W.Stack of all windows, with the current group removed. The given
--   window should be focused by a sublayout. Example usage:
--   <tt>withFocused (sendMessage . mergeDir W.focusDown')</tt>
mergeDir :: (Stack Window -> Stack Window) -> Window -> GroupMsg Window

-- | GroupMsg take window parameters to determine which group the action
--   should be applied to
data GroupMsg a

-- | free the focused window from its tab stack
UnMerge :: a -> GroupMsg a

-- | separate the focused group into singleton groups
UnMergeAll :: a -> GroupMsg a

-- | merge the first group into the second group
Merge :: a -> a -> GroupMsg a

-- | make one large group, keeping the parameter focused
MergeAll :: a -> GroupMsg a

-- | used to the window named in the first argument to the second
--   argument's group, this may be replaced by a combination of
--   <a>UnMerge</a> and <a>Merge</a>
Migrate :: a -> a -> GroupMsg a
WithGroup :: (Stack a -> X (Stack a)) -> a -> GroupMsg a

-- | the sublayout with the given window will get the message
SubMessage :: SomeMessage -> a -> GroupMsg a
data Broadcast

-- | send a message to all sublayouts
Broadcast :: SomeMessage -> Broadcast

-- | <tt>defaultSublMap</tt> is an attempt to create a set of keybindings
--   like the defaults ones but to be used as a <tt>submap</tt> for sending
--   messages to the sublayout.
defaultSublMap :: XConfig l -> Map (KeyMask, KeySym) (X ())
instance Typeable Broadcast
instance Typeable1 GroupMsg
instance (Read a, Read (l a)) => Read (Sublayout l a)
instance (Show a, Show (l a)) => Show (Sublayout l a)
instance (Read (l Window), Show (l Window), LayoutClass l Window) => LayoutModifier (Sublayout l) Window
instance (Typeable a) => Message (GroupMsg a)
instance Message Broadcast


-- | Provides bindings to cycle forward or backward through the list of
--   workspaces, to move windows between workspaces, and to cycle between
--   screens. More general combinators provide ways to cycle through
--   workspaces in various orders, to only cycle through some subset of
--   workspaces, and to cycle by more than one workspace at a time.
--   
--   Note that this module now subsumes the functionality of the former
--   <tt>XMonad.Actions.RotView</tt>. Former users of <tt>rotView</tt> can
--   simply replace <tt>rotView True</tt> with <tt>moveTo Next
--   NonEmptyWS</tt>, and so on.
--   
--   If you want to exactly replicate the action of <tt>rotView</tt>
--   (cycling through workspace in order lexicographically by tag, instead
--   of in the order specified in the config), it can be implemented as:
--   
--   <pre>
--   rotView b  = do t &lt;- findWorkspace getSortByTag (bToDir b) NonEmptyWS 1
--                   windows . greedyView $ t
--     where bToDir True  = Next
--           bToDir False = Prev
--   </pre>
module XMonad.Actions.CycleWS

-- | Switch to the next workspace.
nextWS :: X ()

-- | Switch to the previous workspace.
prevWS :: X ()

-- | Move the focused window to the next workspace.
shiftToNext :: X ()

-- | Move the focused window to the previous workspace.
shiftToPrev :: X ()

-- | Toggle to the workspace displayed previously.
toggleWS :: X ()

-- | <a>greedyView</a> a workspace, or if already there, view the
--   previously displayed workspace ala weechat. Change <tt>greedyView</tt>
--   to <tt>toggleOrView</tt> in your workspace bindings as in the
--   <a>view</a> faq at
--   <a>http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions</a>.
--   For more flexibility see <a>toggleOrDoSkip</a>.
toggleOrView :: WorkspaceId -> X ()

-- | View next screen
nextScreen :: X ()

-- | View prev screen
prevScreen :: X ()

-- | Move focused window to workspace on next screen
shiftNextScreen :: X ()

-- | Move focused window to workspace on prev screen
shiftPrevScreen :: X ()

-- | Swap current screen with next screen
swapNextScreen :: X ()

-- | Swap current screen with previous screen
swapPrevScreen :: X ()

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D

-- | What type of workspaces should be included in the cycle?
data WSType

-- | cycle through empty workspaces
EmptyWS :: WSType

-- | cycle through non-empty workspaces
NonEmptyWS :: WSType

-- | cycle through non-visible workspaces
HiddenWS :: WSType

-- | cycle through non-empty non-visible workspaces
HiddenNonEmptyWS :: WSType

-- | cycle through all workspaces
AnyWS :: WSType

-- | cycle through workspaces in the same group, the group name is all
--   characters up to the first separator character or the end of the tag
WSTagGroup :: Char -> WSType

-- | cycle through workspaces satisfying an arbitrary predicate
WSIs :: (X (WindowSpace -> Bool)) -> WSType

-- | Move the currently focused window to the next workspace in the given
--   direction that satisfies the given condition.
shiftTo :: Direction1D -> WSType -> X ()

-- | View the next workspace in the given direction that satisfies the
--   given condition.
moveTo :: Direction1D -> WSType -> X ()

-- | Using the given sort, find the next workspace in the given direction
--   of the given type, and perform the given action on it.
doTo :: Direction1D -> WSType -> X WorkspaceSort -> (WorkspaceId -> X ()) -> X ()

-- | Given a function <tt>s</tt> to sort workspaces, a direction
--   <tt>dir</tt>, a predicate <tt>p</tt> on workspaces, and an integer
--   <tt>n</tt>, find the tag of the workspace which is <tt>n</tt> away
--   from the current workspace in direction <tt>dir</tt> (wrapping around
--   if necessary), among those workspaces, sorted by <tt>s</tt>, which
--   satisfy <tt>p</tt>.
--   
--   For some useful workspace sorting functions, see
--   <a>XMonad.Util.WorkspaceCompare</a>.
--   
--   For ideas of what to do with a workspace tag once obtained, note that
--   <a>moveTo</a> and <a>shiftTo</a> are implemented by applying
--   <tt>(&gt;&gt;= (windows . greedyView))</tt> and <tt>(&gt;&gt;=
--   (windows . shift))</tt>, respectively, to the output of
--   <a>findWorkspace</a>.
findWorkspace :: X WorkspaceSort -> Direction1D -> WSType -> Int -> X WorkspaceId

-- | Allows ignoring listed workspace tags (such as scratchpad's "NSP")
--   while finding the previously displayed workspace, or choice of
--   different actions, like view, shift, etc. For example:
--   
--   <pre>
--   import qualified XMonad.StackSet as W
--   import XMonad.Actions.CycleWS
--   
--   -- toggleOrView for people who prefer view to greedyView
--   toggleOrView' = toggleOrDoSkip [] W.view
--   
--   -- toggleOrView ignoring scratchpad and named scratchpad workspace
--   toggleOrViewNoSP = toggleOrDoSkip ["NSP"] W.greedyView
--   </pre>
toggleOrDoSkip :: [WorkspaceId] -> (WorkspaceId -> WindowSet -> WindowSet) -> WorkspaceId -> X ()

-- | List difference (<tt>\\</tt>) for workspaces and tags. Removes
--   workspaces matching listed tags from the given workspace list.
skipTags :: (Eq i) => [Workspace i l a] -> [i] -> [Workspace i l a]


-- | Remember a dynamically updateable ordering on workspaces, together
--   with tools for using this ordering with <a>XMonad.Actions.CycleWS</a>
--   and <a>XMonad.Hooks.DynamicLog</a>.
module XMonad.Actions.DynamicWorkspaceOrder

-- | A comparison function which orders workspaces according to the stored
--   dynamic ordering.
getWsCompareByOrder :: X WorkspaceCompare

-- | Sort workspaces according to the stored dynamic ordering.
getSortByOrder :: X WorkspaceSort

-- | Swap the current workspace with another workspace in the stored
--   dynamic order.
swapWith :: Direction1D -> WSType -> X ()

-- | View the next workspace of the given type in the given direction,
--   where "next" is determined using the dynamic workspace order.
moveTo :: Direction1D -> WSType -> X ()

-- | Same as <a>moveTo</a>, but using <tt>greedyView</tt> instead of
--   <tt>view</tt>.
moveToGreedy :: Direction1D -> WSType -> X ()

-- | Shift the currently focused window to the next workspace of the given
--   type in the given direction, using the dynamic workspace order.
shiftTo :: Direction1D -> WSType -> X ()
instance Typeable WSOrderStorage
instance Read WSOrderStorage
instance Show WSOrderStorage
instance ExtensionClass WSOrderStorage


-- | Lets you swap workspace tags, so you can keep related ones next to
--   each other, without having to move individual windows.
module XMonad.Actions.SwapWorkspaces

-- | Swaps the currently focused workspace with the given workspace tag,
--   via <tt>swapWorkspaces</tt>.
swapWithCurrent :: (Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Say <tt>swapTo Next</tt> or <tt>swapTo Prev</tt> to move your current
--   workspace. This is an <tt>X ()</tt> so can be hooked up to your
--   keybindings directly.
swapTo :: Direction1D -> X ()

-- | Takes two workspace tags and an existing XMonad.StackSet and returns a
--   new one with the two corresponding workspaces' tags swapped.
swapWorkspaces :: (Eq i) => i -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D


-- | Provides bindings to rename workspaces, show these names in DynamicLog
--   and swap workspaces along with their names. These names survive
--   restart. Together with <a>XMonad.Layout.WorkspaceDir</a> this provides
--   for a fully dynamic topic space workflow.
module XMonad.Actions.WorkspaceNames

-- | Prompt for a new name for the current workspace and set it.
renameWorkspace :: XPConfig -> X ()

-- | Modify <a>XMonad.Hooks.DynamicLog</a>'s pretty-printing format to show
--   workspace names as well.
workspaceNamesPP :: PP -> X PP

-- | Returns a function that maps workspace tag <tt>"t"</tt> to
--   <tt>"t:name"</tt> for workspaces with a name, and to <tt>"t"</tt>
--   otherwise.
getWorkspaceNames :: X (WorkspaceId -> String)

-- | Sets the name of a workspace. Empty string makes the workspace unnamed
--   again.
setWorkspaceName :: WorkspaceId -> String -> X ()

-- | Sets the name of the current workspace. See <a>setWorkspaceName</a>.
setCurrentWorkspaceName :: String -> X ()

-- | See <tt>XMonad.Actions.SwapWorkspaces.swapTo</tt>. This is the same
--   with names.
swapTo :: Direction1D -> X ()

-- | Swap with the previous or next workspace of the given type.
swapTo' :: Direction1D -> WSType -> X ()

-- | See <tt>XMonad.Actions.SwapWorkspaces.swapWithCurrent</tt>. This is
--   almost the same with names.
swapWithCurrent :: WorkspaceId -> X ()
instance Typeable WorkspaceNames
instance Read WorkspaceNames
instance Show WorkspaceNames
instance XPrompt Wor
instance ExtensionClass WorkspaceNames


-- | Rotate all windows except the master window and keep the focus in
--   place.
module XMonad.Actions.RotSlaves

-- | The actual rotation, as a pure function on the window stack.
rotSlaves' :: ([a] -> [a]) -> Stack a -> Stack a
rotSlavesUp :: X ()

-- | Rotate the windows in the current stack, excluding the first one
--   (master).
rotSlavesDown :: X ()

-- | The actual rotation, as a pure function on the window stack.
rotAll' :: ([a] -> [a]) -> Stack a -> Stack a
rotAllUp :: X ()

-- | Rotate all the windows in the current stack.
rotAllDown :: X ()


-- | Provides bindings to cycle windows up or down on the current workspace
--   stack while maintaining focus in place.
--   
--   Bindings are available to:
--   
--   <ul>
--   <li>Cycle nearby or nth windows into the focused frame</li>
--   <li>Cycle a window halfway around the stack</li>
--   <li>Cycle windows through the focused position.</li>
--   <li>Cycle unfocused windows.</li>
--   </ul>
--   
--   These bindings are especially useful with layouts that hide some of
--   the windows in the stack, such as Full, <a>XMonad.Layout.TwoPane</a>
--   or when using <a>XMonad.Layout.LimitWindows</a> to only show three or
--   four panes. See also <a>XMonad.Actions.RotSlaves</a> for related
--   actions.
module XMonad.Actions.CycleWindows
cycleRecentWindows :: [KeySym] -> KeySym -> KeySym -> X ()

-- | Cycle through a <i>finite</i> list of window stacks with repeated
--   presses of a key while a modifier key is held down. For best results
--   use the same mod key + key combination as the one used to invoke the
--   "bring from below" action. You could use cycleStacks' with a different
--   stack permutations function to, for example, cycle from one below to
--   one above to two below, etc. instead of in order. You are responsible
--   for having it generate a finite list, though, or xmonad may hang
--   seeking its length.
cycleStacks' :: (Stack Window -> [Stack Window]) -> [KeySym] -> KeySym -> KeySym -> X ()

-- | The opposite rotation on a Stack.
rotOpposite' :: Stack a -> Stack a
rotOpposite :: X ()

-- | The focused rotation on a stack.
rotFocused' :: ([a] -> [a]) -> Stack a -> Stack a

-- | Rotate windows through the focused frame, excluding the "next" window.
--   With, e.g. TwoPane, this allows cycling windows through either the
--   master or slave pane, without changing the other frame. When the
--   master is focused, the window below is skipped, when a non-master
--   window is focused, the master is skipped.
rotFocusedUp :: X ()
rotFocusedDown :: X ()

-- | Given a stack element and a stack, shift or insert the element
--   (window) at the currently focused position.
shiftToFocus' :: (Eq a, Show a, Read a) => a -> Stack a -> Stack a

-- | The unfocused rotation on a stack.
rotUnfocused' :: ([a] -> [a]) -> Stack a -> Stack a
rotUnfocusedUp :: X ()
rotUnfocusedDown :: X ()
rotUp :: [a] -> [a]
rotDown :: [a] -> [a]


-- | Provides bindings to cycle through most recently used workspaces with
--   repeated presses of a single key (as long as modifier key is held
--   down). This is similar to how many window managers handle window
--   switching.
module XMonad.Actions.CycleRecentWS

-- | Cycle through most recent workspaces with repeated presses of a key,
--   while a modifier key is held down. The recency of workspaces previewed
--   while browsing to the target workspace is not affected. That way a
--   stack of most recently used workspaces is maintained, similarly to how
--   many window managers handle window switching. For best effects use the
--   same modkey+key combination as the one used to invoke this action.
cycleRecentWS :: [KeySym] -> KeySym -> KeySym -> X ()

-- | Cycle through a finite list of WindowSets with repeated presses of a
--   key, while a modifier key is held down. For best effects use the same
--   modkey+key combination as the one used to invoke this action.
cycleWindowSets :: (WindowSet -> [WindowSet]) -> [KeySym] -> KeySym -> KeySym -> X ()


-- | Defines a few convenient operations for raising (traveling to) windows
--   based on XMonad's Query monad, such as <a>runOrRaise</a>. runOrRaise
--   will run a shell command unless it can find a specified window; you
--   would use this to automatically travel to your Firefox or Emacs
--   session, or start a new one (for example), instead of trying to
--   remember where you left it or whether you still have one running.
module XMonad.Actions.WindowGo

-- | See <a>raiseMaybe</a>. If the Window can't be found, quietly give up
--   and do nothing.
raise :: Query Bool -> X ()

-- | See <a>raise</a> and <a>raiseNextMaybe</a>. Version that allows
--   cycling through matches.
raiseNext :: Query Bool -> X ()

-- | <tt>action</tt> is an executable to be run via <a>safeSpawnProg</a>
--   (of <a>XMonad.Util.Run</a>) if the Window cannot be found. Presumably
--   this executable is the same one that you were looking for.
runOrRaise :: String -> Query Bool -> X ()

-- | See <a>runOrRaise</a> and <a>raiseNextMaybe</a>. Version that allows
--   cycling through matches.
runOrRaiseNext :: String -> Query Bool -> X ()

-- | <a>raiseMaybe</a> queries all Windows based on a boolean provided by
--   the user. Currently, there are 3 such useful booleans defined in
--   <a>XMonad.ManageHook</a>: <a>title</a>, <a>resource</a>,
--   <a>className</a>. Each one tests based pretty much as you would think.
--   ManageHook also defines several operators, the most useful of which is
--   (=?). So a useful test might be finding a <tt>Window</tt> whose class
--   is Firefox. Firefox 3 declares the class "Firefox", so you'd want to
--   pass in a boolean like <tt>(className =? "Firefox")</tt>.
--   
--   If the boolean returns <tt>True</tt> on one or more windows, then
--   XMonad will quickly make visible the first result. If no
--   <tt>Window</tt> meets the criteria, then the first argument comes into
--   play.
--   
--   The first argument is an arbitrary IO function which will be executed
--   if the tests fail. This is what enables <a>runOrRaise</a> to use
--   <a>raiseMaybe</a>: it simply runs the desired program if it isn't
--   found. But you don't have to do that. Maybe you want to do nothing if
--   the search fails (the definition of <a>raise</a>), or maybe you want
--   to write to a log file, or call some prompt function, or something
--   crazy like that. This hook gives you that flexibility. You can do some
--   cute things with this hook. Suppose you want to do the same thing for
--   Mutt which you just did for Firefox - but Mutt runs inside a terminal
--   window? No problem: you search for a terminal window calling itself
--   "mutt", and if there isn't you run a terminal with a command to run
--   Mutt! Here's an example (borrowing <tt>runInTerm</tt> from
--   <a>XMonad.Utils.Run</a>):
--   
--   <pre>
--   , ((modm, xK_m), raiseMaybe (runInTerm "-title mutt" "mutt") (title =? "mutt"))
--   </pre>
raiseMaybe :: X () -> Query Bool -> X ()

-- | See <a>raiseMaybe</a>. <a>raiseNextMaybe</a> is an alternative version
--   that allows cycling through the matching windows. If the focused
--   window matches the query the next matching window is raised. If no
--   matches are found the function f is executed.
raiseNextMaybe :: X () -> Query Bool -> X ()
raiseBrowser :: X ()

-- | <a>raiseBrowser</a> and <a>raiseEditor</a> grab $BROWSER and $EDITOR
--   respectively and they either take you to the specified program's
--   window, or they try to run it. This is most useful if your variables
--   are simple and look like "firefox" or "emacs".
raiseEditor :: X ()

-- | If a window matching the second arugment is found, the window is
--   focused and the third argument is called; otherwise, the first
--   argument is called.
runOrRaiseAndDo :: String -> Query Bool -> (Window -> X ()) -> X ()

-- | If the window is found the window is focused and set to master
--   otherwise, action is run.
--   
--   <pre>
--   runOrRaiseMaster "firefox" (className =? "Firefox"))
--   </pre>
runOrRaiseMaster :: String -> Query Bool -> X ()

-- | If the window is found the window is focused and the third argument is
--   called otherwise, the first argument is called See <a>raiseMaster</a>
--   for an example.
raiseAndDo :: X () -> Query Bool -> (Window -> X ()) -> X ()

-- | if the window is found the window is focused and set to master
--   otherwise, the first argument is called.
--   
--   <pre>
--   raiseMaster (runInTerm "-title ghci"  "zsh -c 'ghci'") (title =? "ghci") 
--   </pre>
raiseMaster :: X () -> Query Bool -> X ()

-- | If windows that satisfy the query exist, apply the supplied function
--   to them, otherwise run the action given as second parameter.
ifWindows :: Query Bool -> ([Window] -> X ()) -> X () -> X ()

-- | The same as ifWindows, but applies a ManageHook to the first match
--   instead and discards the other matches
ifWindow :: Query Bool -> ManageHook -> X () -> X ()

-- | A manage hook that raises the window.
raiseHook :: ManageHook


-- | A prompt for XMonad which will run a program, open a file, or raise an
--   already running program, depending on context.
module XMonad.Prompt.RunOrRaise
runOrRaisePrompt :: XPConfig -> X ()
instance XPrompt RunOrRaisePrompt


-- | Provides bindings to duplicate a window on multiple workspaces,
--   providing dwm-like tagging functionality.
module XMonad.Actions.CopyWindow

-- | Copy the focused window to a workspace.
copy :: (Eq s, Eq i, Eq a) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Copy the focused window to all workspaces.
copyToAll :: (Eq s, Eq i, Eq a) => StackSet i l a s sd -> StackSet i l a s sd

-- | Copy an arbitrary window to a workspace.
copyWindow :: (Eq a, Eq i, Eq s) => a -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | runOrCopy will run the provided shell command unless it can find a
--   specified window in which case it will copy the window to the current
--   workspace. Similar to (i.e., stolen from)
--   <a>XMonad.Actions.WindowGo</a>.
runOrCopy :: String -> Query Bool -> X ()

-- | Kill all other copies of focused window (if they're present). 'All
--   other' means here 'copies which are not on the current workspace'.
killAllOtherCopies :: X ()

-- | Remove the focused window from this workspace. If it's present in no
--   other workspace, then kill it instead. If we do kill it, we'll get a
--   delete notify back from X.
--   
--   There are two ways to delete a window. Either just kill it, or if it
--   supports the delete protocol, send a delete event (e.g. firefox).
kill1 :: X ()

-- | A list of hidden workspaces containing a copy of the focused window.
wsContainingCopies :: X [WorkspaceId]

module XMonad.Config.Sjanssen
sjanssenConfig :: XConfig (ModifiedLayout AvoidStruts (ModifiedLayout SmartBorder (Choose (Choose HintedTile (Choose HintedTile Full)) (ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest))))


-- | Lets you constrain the aspect ratio of a floating window (by, say,
--   holding shift while you resize).
--   
--   Useful for making a nice circular XClock window.
module XMonad.Actions.ConstrainedResize

-- | Resize (floating) window with optional aspect ratio constraints.
mouseResizeWindow :: Window -> Bool -> X ()


-- | A convenient binding to dmenu.
--   
--   Requires the process-1.0 package
module XMonad.Util.Dmenu

-- | Run dmenu to select an option from a list.
dmenu :: [String] -> X String

-- | Starts dmenu on the current screen. Requires this patch to dmenu:
--   <a>http://www.jcreigh.com/dmenu/dmenu-3.2-xinerama.patch</a>
dmenuXinerama :: [String] -> X String

-- | Run dmenu to select an entry from a map based on the key.
dmenuMap :: Map String a -> X (Maybe a)

-- | like <a>dmenu</a> but also takes the command to run.
menu :: String -> [String] -> X String

-- | Like <a>menu</a> but also takes a list of command line arguments.
menuArgs :: String -> [String] -> [String] -> X String

-- | Like <a>dmenuMap</a> but also takes the command to run.
menuMap :: String -> Map String a -> X (Maybe a)

-- | Like <a>menuMap</a> but also takes a list of command line arguments.
menuMapArgs :: String -> [String] -> Map String a -> X (Maybe a)


-- | dmenu operations to bring windows to you, and bring you to windows.
--   That is to say, it pops up a dmenu with window names, in case you
--   forgot where you left your XChat.
module XMonad.Actions.WindowBringer

-- | Pops open a dmenu with window titles. Choose one, and you will be
--   taken to the corresponding workspace.
gotoMenu :: X ()
gotoMenu' :: String -> X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   dragged, kicking and screaming, into your current workspace.
bringMenu :: X ()

-- | A map from window names to Windows.
windowMap :: X (Map String Window)

-- | Brings the specified window into the current workspace.
bringWindow :: Window -> WindowSet -> WindowSet


-- | GridSelect displays items(e.g. the opened windows) in a 2D grid and
--   lets the user select from it with the cursor/hjkl keys or the mouse.
module XMonad.Actions.GridSelect
data GSConfig a
GSConfig :: Integer -> Integer -> Integer -> (a -> Bool -> X (String, String)) -> String -> NavigateMap -> Double -> Double -> GSConfig a
gs_cellheight :: GSConfig a -> Integer
gs_cellwidth :: GSConfig a -> Integer
gs_cellpadding :: GSConfig a -> Integer
gs_colorizer :: GSConfig a -> a -> Bool -> X (String, String)
gs_font :: GSConfig a -> String
gs_navigate :: GSConfig a -> NavigateMap
gs_originFractX :: GSConfig a -> Double
gs_originFractY :: GSConfig a -> Double

-- | A basic configuration for <a>gridselect</a>, with the colorizer chosen
--   based on the type.
--   
--   If you want to replace the <a>gs_colorizer</a> field, use
--   <a>buildDefaultGSConfig</a> instead, to avoid ambiguous type
--   variables.
defaultGSConfig :: (HasColorizer a) => GSConfig a
type NavigateMap = Map (KeyMask, KeySym) (TwoDPosition -> TwoDPosition)
type TwoDPosition = (Integer, Integer)

-- | Builds a default gs config from a colorizer function.
buildDefaultGSConfig :: (a -> Bool -> X (String, String)) -> GSConfig a

-- | Brings up a 2D grid of elements in the center of the screen, and one
--   can select an element with cursors keys. The selected element is
--   returned.
gridselect :: GSConfig a -> [(String, a)] -> X (Maybe a)

-- | Like <tt>gridSelect</tt> but with the current windows and their titles
--   as elements
gridselectWindow :: GSConfig Window -> X (Maybe Window)

-- | Brings up a 2D grid of windows in the center of the screen, and one
--   can select a window with cursors keys. The selected window is then
--   passed to a callback function.
withSelectedWindow :: (Window -> X ()) -> GSConfig Window -> X ()

-- | Brings selected window to the current workspace.
bringSelected :: GSConfig Window -> X ()

-- | Switches to selected window's workspace and focuses that window.
goToSelected :: GSConfig Window -> X ()

-- | Select a workspace and view it using the given function (normally
--   <a>view</a> or <a>greedyView</a>)
--   
--   Another option is to shift the current window to the selected
--   workspace:
--   
--   <pre>
--   gridselectWorkspace (\ws -&gt; W.greedyView ws . W.shift ws)
--   </pre>
gridselectWorkspace :: GSConfig WorkspaceId -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | Select an application to spawn from a given list
spawnSelected :: GSConfig String -> [String] -> X ()

-- | Select an action and run it in the X monad
runSelectedAction :: GSConfig (X ()) -> [(String, X ())] -> X ()

-- | That is <a>fromClassName</a> if you are selecting a <a>Window</a>, or
--   <a>defaultColorizer</a> if you are selecting a <a>String</a>. The
--   catch-all instance <tt>HasColorizer a</tt> uses the
--   <a>focusedBorderColor</a> and <a>normalBorderColor</a> colors.
class HasColorizer a
defaultColorizer :: (HasColorizer a) => a -> Bool -> X (String, String)

-- | Colorize a window depending on it's className.
fromClassName :: Window -> Bool -> X (String, String)

-- | Default colorizer for Strings
stringColorizer :: String -> Bool -> X (String, String)

-- | A colorizer that picks a color inside a range, and depending on the
--   window's class.
colorRangeFromClassName :: (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> Window -> Bool -> X (String, String)
instance [overlap ok] Monad (TwoD a)
instance [overlap ok] Functor (TwoD a)
instance [overlap ok] MonadState (TwoDState a) (TwoD a)
instance [overlap ok] Applicative (TwoD a)
instance [overlap ok] HasColorizer a
instance [overlap ok] HasColorizer String
instance [overlap ok] HasColorizer Window


-- | Uses <a>XMonad.Actions.GridSelect</a> to display a number of actions
--   related to window management in the center of the focused window.
--   Actions include: Closing, maximizing, minimizing and shifting the
--   window to another workspace.
--   
--   Note: For maximizing and minimizing to actually work, you will need to
--   integrate <a>XMonad.Layout.Maximize</a> and
--   <a>XMonad.Layout.Minimize</a> into your setup. See the documentation
--   of those modules for more information.
module XMonad.Actions.WindowMenu
windowMenu :: X ()


-- | Various stuff that can be added to the decoration. Most of it is
--   intended to be used by other modules. See
--   <a>XMonad.Layout.ButtonDecoration</a> for a module that makes use of
--   this.
module XMonad.Layout.DecorationAddons

-- | A function intended to be plugged into the
--   <a>decorationCatchClicksHook</a> of a decoration. It will intercept
--   clicks on the buttons of the decoration and invoke the associated
--   action. To actually see the buttons, you will need to use a theme that
--   includes them. See <a>defaultThemeWithButtons</a> below.
titleBarButtonHandler :: Window -> Int -> Int -> X Bool

-- | Intended to be used together with <a>titleBarButtonHandler</a>. See
--   above.
defaultThemeWithButtons :: Theme

-- | A function intended to be plugged into the
--   <a>decorationAfterDraggingHook</a> of a decoration. It will check if
--   the window has been dragged onto another screen and shift it there.
--   The PositionStore is also updated accordingly, as this is designed to
--   be used together with <a>XMonad.Layout.PositionStoreFloat</a>.
handleScreenCrossing :: Window -> Window -> X Bool


-- | A decoration that includes small buttons on both ends which invoke
--   various actions when clicked on: Show a window menu (see
--   <a>XMonad.Actions.WindowMenu</a>), minimize, maximize or close the
--   window.
--   
--   Note: For maximizing and minimizing to actually work, you will need to
--   integrate <a>XMonad.Layout.Maximize</a> and
--   <a>XMonad.Layout.Minimize</a> into your setup. See the documentation
--   of those modules for more information.
module XMonad.Layout.ButtonDecoration
buttonDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration ButtonDecoration s) l a
instance Show (ButtonDecoration a)
instance Read (ButtonDecoration a)
instance (Eq a) => DecorationStyle ButtonDecoration a


-- | A decoration that allows to switch the position of windows by dragging
--   them onto each other.
module XMonad.Layout.WindowSwitcherDecoration
windowSwitcherDecoration :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration WindowSwitcherDecoration s) l a
windowSwitcherDecorationWithButtons :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration WindowSwitcherDecoration s) l a
instance Show (WindowSwitcherDecoration a)
instance Read (WindowSwitcherDecoration a)
instance (Eq a) => DecorationStyle WindowSwitcherDecoration a


-- | xprompt operations to bring windows to you, and bring you to windows.
module XMonad.Prompt.Window
windowPromptGoto :: XPConfig -> X ()
windowPromptBring :: XPConfig -> X ()
windowPromptBringCopy :: XPConfig -> X ()
instance XPrompt WindowPrompt


-- | Allows you to run internal xmonad commands (X () actions) using a
--   dmenu menu in addition to key bindings. Requires dmenu and the Dmenu
--   XMonad.Actions module.
module XMonad.Actions.Commands

-- | Create a <tt>Data.Map.Map</tt> from <tt>String</tt>s to xmonad actions
--   from a list of pairs.
commandMap :: [(String, X ())] -> Map String (X ())

-- | Given a list of command/action pairs, prompt the user to choose a
--   command and return the corresponding action.
runCommand :: [(String, X ())] -> X ()

-- | Given the name of a command from <a>defaultCommands</a>, return the
--   corresponding action (or the null action if the command is not found).
runCommand' :: String -> X ()

-- | Generate a list of commands to switch to/send windows to workspaces.
workspaceCommands :: X [(String, X ())]

-- | Generate a list of commands dealing with multiple screens.
screenCommands :: [(String, X ())]

-- | A nice pre-defined list of commands.
defaultCommands :: X [(String, X ())]


-- | This is an <tt>EventHook</tt> that will receive commands from an
--   external client.
--   
--   This is the example of a client:
--   
--   <pre>
--   import Graphics.X11.Xlib
--   import Graphics.X11.Xlib.Extras
--   import System.Environment
--   import Data.Char
--   
--   usage :: String -&gt; String
--   usage n = "Usage: " ++ n ++ " command number\nSend a command number to a running instance of XMonad"
--   
--   main :: IO ()
--   main = do
--     args &lt;- getArgs
--     pn &lt;- getProgName
--     let com = case args of
--                 [] -&gt; error $ usage pn
--                 w -&gt; (w !! 0)
--     sendCommand com
--   
--   sendCommand :: String -&gt; IO ()
--   sendCommand s = do
--     d   &lt;- openDisplay ""
--     rw  &lt;- rootWindow d $ defaultScreen d
--     a &lt;- internAtom d "XMONAD_COMMAND" False
--     allocaXEvent $ \e -&gt; do
--                     setEventType e clientMessage
--                     setClientMessageEvent e rw a 32 (fromIntegral (read s)) currentTime
--                     sendEvent d rw False structureNotifyMask e
--                     sync d False
--   </pre>
--   
--   compile with: <tt>ghc --make sendCommand.hs</tt>
--   
--   run with
--   
--   <pre>
--   sendCommand command number
--   </pre>
--   
--   For instance:
--   
--   <pre>
--   sendCommand 0
--   </pre>
--   
--   will ask to xmonad to print the list of command numbers in stderr (so
--   you can read it in <tt>~/.xsession-errors</tt>).
module XMonad.Hooks.ServerMode
data ServerMode
ServerMode :: ServerMode

-- | Executes a command of the list when receiving its index via a special
--   ClientMessageEvent (indexing starts at 1)
serverModeEventHook :: Event -> X All

-- | serverModeEventHook' additionally takes an action to generate the list
--   of commands.
serverModeEventHook' :: X [(String, X ())] -> Event -> X All
instance Show ServerMode
instance Read ServerMode


-- | A prompt for running XMonad commands
module XMonad.Prompt.XMonad
xmonadPrompt :: XPConfig -> X ()

-- | An xmonad prompt with a custom command list
xmonadPromptC :: [(String, X ())] -> XPConfig -> X ()
instance XPrompt XMonad


-- | The <a>XMonad.Layout.LayoutCombinators</a> module provides combinators
--   for easily combining multiple layouts into one composite layout, as
--   well as a way to jump directly to any particular layout (say, with a
--   keybinding) without having to cycle through other layouts to get to
--   it.
module XMonad.Layout.LayoutCombinators
(*||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(**||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(****||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***||**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(****||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***||****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*||****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(**||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*||**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(**//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(****//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***//**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(****//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(***//****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*//****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(**//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*//**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
(*|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(**|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(***|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(****|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(***|**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(****|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(***|****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(*|****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(**|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(*|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(*|**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
(*/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(**/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(***/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(****/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(***/**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(****/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(***/****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(*/****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(**/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(*/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
(*/**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a

-- | A reimplementation of the combinator of the same name from the xmonad
--   core, providing layout choice, and the ability to support
--   <a>JumpToLayout</a> messages.
(|||) :: (LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> NewSelect l1 l2 a
data JumpToLayout

-- | A message to jump to a particular layout , specified by its
--   description string..
JumpToLayout :: String -> JumpToLayout
NextLayoutNoWrap :: JumpToLayout
Wrap :: JumpToLayout
instance Typeable JumpToLayout
instance Read JumpToLayout
instance Show JumpToLayout
instance (Read (l1 a), Read (l2 a)) => Read (NewSelect l1 l2 a)
instance (Show (l1 a), Show (l2 a)) => Show (NewSelect l1 l2 a)
instance (LayoutClass l1 a, LayoutClass l2 a) => LayoutClass (NewSelect l1 l2) a
instance Message JumpToLayout


-- | This module allows to cycle through the given subset of layouts.
module XMonad.Actions.CycleSelectedLayouts

-- | If the current layout is in the list, cycle to the next layout.
--   Otherwise, apply the first layout from list.
cycleThroughLayouts :: [String] -> X ()


-- | This module specifies my xmonad defaults.
module XMonad.Config.Arossato
arossatoConfig :: (MonadIO m) => m (XConfig (ModifiedLayout AvoidStruts (NewSelect (ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat))) (NewSelect (ModifiedLayout WithBorder (ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest)) (ModifiedLayout WindowArranger (NewSelect (ModifiedLayout Magnifier Tall) (NewSelect (ModifiedLayout WithBorder Full) (NewSelect (Mirror Tall) Accordion))))))))


-- | A layout-selection prompt for XMonad
module XMonad.Prompt.Layout
layoutPrompt :: XPConfig -> X ()
instance XPrompt Wor


module XMonad.Config.Droundy
config :: XConfig (ModifiedLayout ShowWName (ModifiedLayout WorkspaceDir (ModifiedLayout BoringWindows (ModifiedLayout SmartBorder (ModifiedLayout WindowNavigation (ModifiedLayout Magnifier (ToggleLayouts Full (ModifiedLayout AvoidStruts (NewSelect (ModifiedLayout Named (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)) (NewSelect (ModifiedLayout Named (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)))) (NewSelect (ModifiedLayout Named (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest))))) (ModifiedLayout Named (CombineTwo (DragPane ()) (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)))))))))))))))
mytab :: ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest Window
instance Shrinker CustomShrink


-- | This is a list of selected commands that can be made available using
--   <a>XMonad.Hooks.ServerMode</a> to allow external programs to control
--   the window manager. Bluetile
--   (<a>http://projects.haskell.org/bluetile/</a>) uses this to enable its
--   dock application to do things like changing workspaces and layouts.
module XMonad.Actions.BluetileCommands
bluetileCommands :: X [(String, X ())]


-- | This is the default configuration of Bluetile
--   (<a>http://projects.haskell.org/bluetile/</a>). If you are migrating
--   from Bluetile to xmonad or want to create a similar setup, then this
--   will give you pretty much the same thing, except for Bluetile's helper
--   applications such as the dock.
module XMonad.Config.Bluetile
bluetileConfig :: XConfig (ModifiedLayout AvoidStruts (ModifiedLayout Minimize (ModifiedLayout BoringWindows (NewSelect (ModifiedLayout Named (ModifiedLayout (Decoration ButtonDecoration DefaultShrinker) (ModifiedLayout Maximize (ModifiedLayout BorderResize PositionStoreFloat)))) (NewSelect (ModifiedLayout Named (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize MouseResizableTile)))) (NewSelect (ModifiedLayout Named (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize MouseResizableTile)))) (ModifiedLayout Named (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize (ModifiedLayout SmartBorder Full)))))))))))


-- | This module gives a brief overview of the xmonad internals. It is
--   intended for advanced users who are curious about the xmonad source
--   code and want an brief overview. This document may also be helpful for
--   the beginner/intermediate Haskell programmer who is motivated to write
--   an xmonad extension as a way to deepen her understanding of this
--   powerful functional language; however, there is not space here to go
--   into much detail. For a more comprehensive document covering some of
--   the same material in more depth, see the guided tour of the xmonad
--   source on the xmonad wiki:
--   <a>http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source</a>.
--   
--   If you write an extension module and think it may be useful for
--   others, consider releasing it. Coding guidelines and licensing
--   policies are covered at the end of this document, and must be followed
--   if you want your code to be included in the official repositories. For
--   a basic tutorial on the nuts and bolts of developing a new extension
--   for xmonad, see the tutorial on the wiki:
--   <a>http://haskell.org/haskellwiki/Xmonad/xmonad_development_tutorial</a>.
module XMonad.Doc.Developing


-- | This module documents the xmonad-contrib library and how to use it to
--   extend the capabilities of xmonad.
--   
--   Reading this document should not require a deep knowledge of Haskell;
--   the examples are intended to be useful and understandable for those
--   users who do not know Haskell and don't want to have to learn it just
--   to configure xmonad. You should be able to get by just fine by
--   ignoring anything you don't understand and using the provided examples
--   as templates. However, relevant Haskell features are discussed when
--   appropriate, so this document will hopefully be useful for more
--   advanced Haskell users as well.
--   
--   Those wishing to be totally hardcore and develop their own xmonad
--   extensions (it's easier than it sounds, we promise!) should read the
--   documentation in <a>XMonad.Doc.Developing</a>.
--   
--   More configuration examples may be found on the Haskell wiki:
--   
--   <a>http://haskell.org/haskellwiki/Xmonad/Config_archive</a>
module XMonad.Doc.Extending


-- | This is a brief tutorial that will teach you how to create a basic
--   xmonad configuration.
--   
--   For more detailed instructions on extending xmonad with the
--   xmonad-contrib library, see <a>XMonad.Doc.Extending</a>.
module XMonad.Doc.Configuring


-- | This is the main documentation module for the xmonad-contrib library.
--   It provides a brief overview of xmonad and a link to documentation for
--   configuring and extending xmonad.
--   
--   A link to documentation describing xmonad internals is also provided.
--   This module is mainly intended for those wanting to contribute code,
--   or for those who are curious to know what's going on behind the
--   scenes.
module XMonad.Doc
