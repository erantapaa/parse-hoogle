-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Grammatical Framework
--   
@package gf
@version 3.7


-- | Pretty printing with class
module GF.Text.Pretty
class Pretty a where ppList = fsep . map pp
pp :: Pretty a => a -> Doc
ppList :: Pretty a => [a] -> Doc
render :: Pretty a => a -> String
renderStyle :: Pretty a => Style -> a -> String
($$) :: (Pretty a1, Pretty a) => a -> a1 -> Doc
($+$) :: (Pretty a1, Pretty a) => a -> a1 -> Doc
(<+>) :: (Pretty a1, Pretty a) => a -> a1 -> Doc
(<>) :: (Pretty a1, Pretty a) => a -> a1 -> Doc
braces :: Pretty a => a -> Doc
brackets :: Pretty a => a -> Doc
cat :: Pretty a => [a] -> Doc
doubleQuotes :: Pretty a => a -> Doc
fcat :: Pretty a => [a] -> Doc
fsep :: Pretty a => [a] -> Doc
hang :: (Pretty a1, Pretty a) => a -> Int -> a1 -> Doc
hcat :: Pretty a => [a] -> Doc
hsep :: Pretty a => [a] -> Doc
nest :: Pretty a => Int -> a -> Doc
parens :: Pretty a => a -> Doc
punctuate :: (Pretty a1, Pretty a) => a -> [a1] -> [Doc]
quotes :: Pretty a => a -> Doc
sep :: Pretty a => [a] -> Doc
vcat :: Pretty a => [a] -> Doc
instance Pretty a => Pretty [a]
instance Pretty Char
instance Pretty Double
instance Pretty Float
instance Pretty Integer
instance Pretty Int
instance Pretty Doc


-- | Auxiliary types and functions for use with grammars translated to
--   Haskell with <tt>gf -output-format=haskell -haskell=concrete</tt>
module PGF.Haskell

-- | For enumerating parameter values used in tables
class EnumAll a
enumAll :: EnumAll a => [a]

-- | Tables
table :: (EnumAll k, Ord k) => [a] -> k -> a

-- | Token sequences, output form linearization functions
type Str = [Tok]

-- | Tokens
data Tok
TK :: String -> Tok
TP :: [([Prefix], Str)] -> Str -> Tok
BIND :: Tok
SOFT_BIND :: Tok
SOFT_SPACE :: Tok
CAPIT :: Tok
ALL_CAPIT :: Tok
type Prefix = String

-- | Render a token sequence as a <a>String</a>
fromStr :: Str -> String

-- | Overloaded function to project the <tt>s</tt> field from any record
--   type
class Has_s r a | r -> a
proj_s :: Has_s r a => r -> a

-- | Haskell representation of the GF record type <tt>{s:t}</tt>
data R_s t
R_s :: t -> R_s t

-- | Coerce from any record type <tt>{...,s:t,...}</tt> field to the
--   supertype <tt>{s:t}</tt>
to_R_s :: Has_s r t => r -> R_s t

-- | Concatenation with variants
(+++) :: Applicative f => f [a] -> f [a] -> f [a]

-- | Selection from tables with variants
(!) :: Monad m => (t -> m (m a)) -> t -> m a
(!$) :: (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
(!*) :: (Applicative m, Monad m) => m (a1 -> m a) -> m a1 -> m a
instance Eq Tok
instance Ord Tok
instance Show Tok
instance Eq t => Eq (R_s t)
instance Ord t => Ord (R_s t)
instance Show t => Show (R_s t)
instance Has_s (R_s t) t
instance EnumAll t => EnumAll (R_s t)

module PGF.Lexing

-- | Text lexing with standard word capitalization of the first word of
--   every sentence
lexText :: String -> [String]

-- | Text lexing with custom treatment of the first word of every sentence.
lexText' :: (String -> String) -> String -> [String]
unlexText :: [String] -> String

-- | Bind tokens separated by Prelude.BIND, i.e. &amp;+
bindTok :: [String] -> [String]

-- | Haskell lexer, usable for much code
lexCode :: String -> [String]
unlexCode :: [String] -> String

-- | LaTeX lexer in the math mode: should not be separated from the next
--   word
lexLatexCode :: String -> [String]

-- | LaTeX style lexer, with "math" environment using Code between $...$
lexMixed :: String -> [String]
unlexMixed :: [String] -> String

-- | Capitalize first letter
capitInit :: [Char] -> [Char]

-- | Uncapitalize first letter
uncapitInit :: [Char] -> [Char]

-- | Unquote each string wrapped in double quotes
unquote :: [[Char]] -> [[Char]]
isPunct :: Char -> Bool
isMajorPunct :: Char -> Bool
isMinorPunct :: Char -> Bool
isParen :: Char -> Bool
isClosing :: Char -> Bool


-- | Basic utilities
module PGF.Utilities

-- | Like <a>nub</a>, but O(n log n) instead of O(n^2), since it uses a set
--   to lookup previous things. The result list is stable (the elements are
--   returned in the order they occur), and lazy. Requires that the list
--   elements can be compared by Ord. Code ruthlessly taken from
--   <a>http://hpaste.org/54411</a>
nub' :: Ord a => [a] -> [a]

-- | Replace all occurences of an element by another element.
replace :: Eq a => a -> a -> [a] -> [a]


-- | This module is an Application Programming Interface to load and
--   interpret grammars compiled in Portable Grammar Format (PGF). The PGF
--   format is produced as a final output from the GF compiler. The API is
--   meant to be used for embedding GF grammars in Haskell programs
module PGF

-- | An abstract data type representing multilingual grammar in Portable
--   Grammar Format.
data PGF

-- | Reads file in Portable Grammar Format and produces <a>PGF</a>
--   structure. The file is usually produced with:
--   
--   <pre>
--   $ gf -make &lt;grammar file name&gt;
--   </pre>
readPGF :: FilePath -> IO PGF

-- | An abstract data type that represents identifiers for functions and
--   categories in PGF.
data CId

-- | Creates a new identifier from <a>String</a>
mkCId :: String -> CId
wildCId :: CId

-- | Renders the identifier as <a>String</a>
showCId :: CId -> String

-- | Reads an identifier from <a>String</a>. The function returns
--   <a>Nothing</a> if the string is not valid identifier.
readCId :: String -> Maybe CId
ppCId :: CId -> Doc
pIdent :: ReadP String

-- | Creates an identifier from a UTF-8-encoded <tt>ByteString</tt>
utf8CId :: ByteString -> CId

-- | This is just a <a>CId</a> with the language name. A language name is
--   the identifier that you write in the top concrete or abstract module
--   in GF after the concrete/abstract keyword. Example:
--   
--   <pre>
--   abstract Lang = ...
--   concrete LangEng of Lang = ...
--   </pre>
type Language = CId
showLanguage :: Language -> String
readLanguage :: String -> Maybe Language

-- | List of all languages available in the given grammar.
languages :: PGF -> [Language]

-- | The abstract language name is the name of the top-level abstract
--   module
abstractName :: PGF -> Language

-- | Gets the RFC 4646 language tag of the language which the given
--   concrete syntax implements, if this is listed in the source grammar.
--   Example language tags include <tt>"en"</tt> for English, and
--   <tt>"en-UK"</tt> for British English.
languageCode :: PGF -> Language -> Maybe String

-- | To read a type from a <a>String</a>, use <a>readType</a>.
data Type

-- | <a>Hypo</a> represents a hypothesis in a type i.e. in the type A -&gt;
--   B, A is the hypothesis
type Hypo = (BindType, CId, Type)

-- | renders type as <a>String</a>. The list of identifiers is the list of
--   all free variables in the expression in order reverse to the order of
--   binding.
showType :: [CId] -> Type -> String

-- | Reads a <a>Type</a> from a <a>String</a>.
readType :: String -> Maybe Type

-- | creates a type from list of hypothesises, category and list of
--   arguments for the category. The operation <tt>mkType [h_1,...,h_n] C
--   [e_1,...,e_m]</tt> will create <tt>h_1 -&gt; ... -&gt; h_n -&gt; C e_1
--   ... e_m</tt>
mkType :: [Hypo] -> CId -> [Expr] -> Type

-- | creates hypothesis for non-dependent type i.e. A
mkHypo :: Type -> Hypo

-- | creates hypothesis for dependent type i.e. (x : A)
mkDepHypo :: CId -> Type -> Hypo

-- | creates hypothesis for dependent type with implicit argument i.e. ({x}
--   : A)
mkImplHypo :: CId -> Type -> Hypo
unType :: Type -> ([Hypo], CId, [Expr])

-- | List of all categories defined in the given grammar. The categories
--   are defined in the abstract syntax with the 'cat' keyword.
categories :: PGF -> [CId]
categoryContext :: PGF -> CId -> Maybe [Hypo]

-- | The start category is defined in the grammar with the 'startcat' flag.
--   This is usually the sentence category but it is not necessary. Despite
--   that there is a start category defined you can parse with any
--   category. The start category definition is just for convenience.
startCat :: PGF -> Type

-- | List of all functions defined in the abstract syntax
functions :: PGF -> [CId]

-- | List of all functions defined for a given category
functionsByCat :: PGF -> CId -> [CId]

-- | The type of a given function
functionType :: PGF -> CId -> Maybe Type

-- | List of functions that lack linearizations in the given language.
missingLins :: PGF -> Language -> [CId]

-- | Tree is the abstract syntax representation of a given sentence in some
--   concrete syntax. Technically <a>Tree</a> is a type synonym of
--   <a>Expr</a>.
type Tree = Expr

-- | An expression in the abstract syntax of the grammar. It could be both
--   parameter of a dependent type or an abstract syntax tree for for some
--   sentence.
data Expr

-- | renders expression as <a>String</a>. The list of identifiers is the
--   list of all free variables in the expression in order reverse to the
--   order of binding.
showExpr :: [CId] -> Expr -> String

-- | parses <a>String</a> as an expression
readExpr :: String -> Maybe Expr
mkAbs :: BindType -> CId -> Expr -> Expr
unAbs :: Expr -> Maybe (BindType, CId, Expr)

-- | Constructs an expression by applying a function to a list of
--   expressions
mkApp :: CId -> [Expr] -> Expr

-- | Decomposes an expression into application of function
unApp :: Expr -> Maybe (CId, [Expr])

-- | Constructs an expression from string literal
mkStr :: String -> Expr

-- | Decomposes an expression into string literal
unStr :: Expr -> Maybe String

-- | Constructs an expression from integer literal
mkInt :: Int -> Expr

-- | Decomposes an expression into integer literal
unInt :: Expr -> Maybe Int

-- | Constructs an expression from real number literal
mkDouble :: Double -> Expr

-- | Decomposes an expression into real number literal
unDouble :: Expr -> Maybe Double

-- | Constructs an expression which is meta variable
mkMeta :: Int -> Expr

-- | Checks whether an expression is a meta variable
unMeta :: Expr -> Maybe Int
pExpr :: ReadP Expr

-- | Linearizes given expression as string in the language
linearize :: PGF -> Language -> Tree -> String

-- | Linearizes given expression as string in all languages available in
--   the grammar.
linearizeAllLang :: PGF -> Tree -> [(Language, String)]

-- | The same as <a>linearizeAllLang</a> but does not return the language.
linearizeAll :: PGF -> Tree -> [String]

-- | Linearizes given expression as a bracketed string in the language
bracketedLinearize :: PGF -> Language -> Tree -> [BracketedString]

-- | Creates a table from feature name to linearization. The outher list
--   encodes the variations
tabularLinearizes :: PGF -> Language -> Expr -> [[(String, String)]]
groupResults :: [[(Language, String)]] -> [(Language, [String])]

-- | Show the printname of function or category
showPrintName :: PGF -> Language -> CId -> String

-- | BracketedString represents a sentence that is linearized as usual but
--   we also want to retain the ''brackets'' that mark the beginning and
--   the end of each constituent.
data BracketedString

-- | this is the leaf i.e. a single token
Leaf :: Token -> BracketedString

-- | this is a bracket. The <a>CId</a> is the category of the phrase. The
--   <a>FId</a> is an unique identifier for every phrase in the sentence.
--   For context-free grammars i.e. without discontinuous constituents this
--   identifier is also unique for every bracket. When there are
--   discontinuous phrases then the identifiers are unique for every phrase
--   but not for every bracket since the bracket represents a constituent.
--   The different constituents could still be distinguished by using the
--   constituent index i.e. <a>LIndex</a>. If the grammar is reduplicating
--   then the constituent indices will be the same for all brackets that
--   represents the same constituent.
Bracket :: CId -> {-# UNPACK #-} !FId -> {-# UNPACK #-} !LIndex -> CId -> [Expr] -> [BracketedString] -> BracketedString
type FId = Int
type LIndex = Int
type Token = String

-- | Renders the bracketed string as string where the brackets are shown as
--   <tt>(S ...)</tt> where <tt>S</tt> is the category.
showBracketedString :: BracketedString -> String
flattenBracketedString :: BracketedString -> [String]

-- | Tries to parse the given string in the specified language and to
--   produce abstract syntax expression.
parse :: PGF -> Language -> Type -> String -> [Tree]

-- | Tries to parse the given string with all available languages. The
--   returned list contains pairs of language and list of abstract syntax
--   expressions (this is a list, since grammars can be ambiguous). Only
--   those languages for which at least one parsing is possible are listed.
parseAllLang :: PGF -> Type -> String -> [(Language, [Tree])]

-- | The same as <a>parseAllLang</a> but does not return the language.
parseAll :: PGF -> Type -> String -> [[Tree]]

-- | The same as <a>parse</a> but returns more detailed information
parse_ :: PGF -> Language -> Type -> Maybe Int -> String -> (ParseOutput, BracketedString)

-- | This is an experimental function. Use it on your own risk
parseWithRecovery :: PGF -> Language -> Type -> [Type] -> Maybe Int -> String -> (ParseOutput, BracketedString)

-- | Converts an expression to normal form
compute :: PGF -> Expr -> Expr
paraphrase :: PGF -> Expr -> [Expr]

-- | Check whether a given type is consistent with the abstract syntax of
--   the grammar.
checkType :: PGF -> Type -> Either TcError Type

-- | Checks an expression against a specified type.
checkExpr :: PGF -> Expr -> Type -> Either TcError Expr

-- | Tries to infer the type of a given expression. Note that even if the
--   expression is type correct it is not always possible to infer its type
--   in the GF type system. In this case the function returns the
--   <a>CannotInferType</a> error.
inferExpr :: PGF -> Expr -> Either TcError (Expr, Type)

-- | If an error occurs in the typechecking phase the type checker returns
--   not a plain text error message but a <a>TcError</a> structure which
--   describes the error.
data TcError

-- | Unknown category name was found.
UnknownCat :: CId -> TcError

-- | Unknown function name was found.
UnknownFun :: CId -> TcError

-- | A category was applied to wrong number of arguments. The first integer
--   is the number of expected arguments and the second the number of given
--   arguments. The <tt>[CId]</tt> argument is the list of free variables
--   in the type. It should be used for the <a>showType</a> function.
WrongCatArgs :: [CId] -> Type -> CId -> Int -> Int -> TcError

-- | The expression is not of the expected type. The first type is the
--   expected type, while the second is the inferred. The <tt>[CId]</tt>
--   argument is the list of free variables in both the expression and the
--   type. It should be used for the <a>showType</a> and <a>showExpr</a>
--   functions.
TypeMismatch :: [CId] -> Expr -> Type -> Type -> TcError

-- | Something that is not of function type was applied to an argument.
NotFunType :: [CId] -> Expr -> Type -> TcError

-- | It is not possible to infer the type of an expression.
CannotInferType :: [CId] -> Expr -> TcError

-- | Some metavariables have to be instantiated in order to complete the
--   typechecking.
UnresolvedMetaVars :: [CId] -> Expr -> [MetaId] -> TcError

-- | Implicit argument was passed where the type doesn't allow it
UnexpectedImplArg :: [CId] -> Expr -> TcError

-- | There is a goal that cannot be solved
UnsolvableGoal :: [CId] -> MetaId -> Type -> TcError

-- | Renders the type checking error to a document. See <a>PrettyPrint</a>.
ppTcError :: TcError -> Doc

-- | An abstract data type whose values represent the current state in an
--   incremental parser.
data ParseState

-- | Creates an initial parsing state for a given language and startup
--   category.
initState :: PGF -> Language -> Type -> ParseState

-- | From the current state and the next token <a>nextState</a> computes a
--   new state, where the token is consumed and the current position is
--   shifted by one. If the new token cannot be accepted then an error
--   state is returned.
nextState :: ParseState -> ParseInput -> Either ErrorState ParseState

-- | If the next token is not known but only its prefix (possible empty
--   prefix) then the <a>getCompletions</a> function can be used to
--   calculate the possible next words and the consequent states. This is
--   used for word completions in the GF interpreter.
getCompletions :: ParseState -> String -> Map Token ParseState
recoveryStates :: [Type] -> ErrorState -> (ParseState, Map Token ParseState)

-- | The input to the parser is a pair of predicates. The first one
--   <a>piToken</a> selects a token from a list of suggestions from the
--   grammar, actually appears at the current position in the input string.
--   The second one <a>piLiteral</a> recognizes whether a literal with
--   forest id <a>FId</a> could be matched at the current position.
data ParseInput
ParseInput :: (forall a. Map Token a -> Maybe a) -> (FId -> Maybe (CId, Tree, [Token])) -> ParseInput
piToken :: ParseInput -> forall a. Map Token a -> Maybe a
piLiteral :: ParseInput -> FId -> Maybe (CId, Tree, [Token])

-- | This function constructs the simplest possible parser input. It checks
--   the tokens for exact matching and recognizes only <tt>String</tt>,
--   <tt>Int</tt> and <tt>Float</tt> literals. The <tt>Int</tt> and
--   <tt>Float</tt> literals match only if the token passed is some number.
--   The <tt>String</tt> literal always match but the length of the literal
--   could be only one token.
simpleParseInput :: Token -> ParseInput
mkParseInput :: PGF -> Language -> (forall a. b -> Map Token a -> Maybe a) -> [(CId, b -> Maybe (Tree, [Token]))] -> (b -> ParseInput)

-- | This data type encodes the different outcomes which you could get from
--   the parser.
data ParseOutput

-- | The integer is the position in number of tokens where the parser
--   failed.
ParseFailed :: Int -> ParseOutput

-- | The parsing was successful but none of the trees is type correct. The
--   forest id (<a>FId</a>) points to the bracketed string from the parser
--   where the type checking failed. More than one error is returned if
--   there are many analizes for some phrase but they all are not type
--   correct.
TypeError :: [(FId, TcError)] -> ParseOutput

-- | If the parsing and the type checking are successful we get a list of
--   abstract syntax trees. The list should be non-empty.
ParseOk :: [Tree] -> ParseOutput

-- | The sentence is not complete. Only partial output is produced
ParseIncomplete :: ParseOutput

-- | This function extracts the list of all completed parse trees that
--   spans the whole input consumed so far. The trees are also limited by
--   the category specified, which is usually the same as the startup
--   category.
getParseOutput :: ParseState -> Type -> Maybe Int -> (ParseOutput, BracketedString)

-- | Return the Continuation of a Parsestate with exportable types Used by
--   PGFService
getContinuationInfo :: ParseState -> Map [Token] [(FunId, CId, String)]

-- | Generates an exhaustive possibly infinite list of abstract syntax
--   expressions.
generateAll :: PGF -> Type -> [Expr]

-- | A variant of <a>generateAll</a> which also takes as argument the upper
--   limit of the depth of the generated expression.
generateAllDepth :: PGF -> Type -> Maybe Int -> [Expr]

-- | Generates a list of abstract syntax expressions in a way similar to
--   <a>generateAll</a> but instead of generating all instances of a given
--   type, this function uses a template.
generateFrom :: PGF -> Expr -> [Expr]

-- | A variant of <a>generateFrom</a> which also takes as argument the
--   upper limit of the depth of the generated subexpressions.
generateFromDepth :: PGF -> Expr -> Maybe Int -> [Expr]

-- | Generates an infinite list of random abstract syntax expressions. This
--   is usefull for tree bank generation which after that can be used for
--   grammar testing.
generateRandom :: RandomGen g => g -> PGF -> Type -> [Expr]

-- | A variant of <a>generateRandom</a> which also takes as argument the
--   upper limit of the depth of the generated expression.
generateRandomDepth :: RandomGen g => g -> PGF -> Type -> Maybe Int -> [Expr]

-- | Random generation based on template
generateRandomFrom :: RandomGen g => g -> PGF -> Expr -> [Expr]

-- | Random generation based on template with a limitation in the depth.
generateRandomFromDepth :: RandomGen g => g -> PGF -> Expr -> Maybe Int -> [Expr]
type Lemma = CId
type Analysis = String
data Morpho
lookupMorpho :: Morpho -> String -> [(Lemma, Analysis)]
buildMorpho :: PGF -> Language -> Morpho
fullFormLexicon :: Morpho -> [(String, [(Lemma, Analysis)])]
morphoMissing :: Morpho -> [String] -> [String]
morphoKnown :: Morpho -> [String] -> [String]
isInMorpho :: Morpho -> String -> Bool

-- | Renders abstract syntax tree in Graphviz format
graphvizAbstractTree :: PGF -> (Bool, Bool) -> Tree -> String
graphvizParseTree :: PGF -> Language -> GraphvizOptions -> Tree -> String
graphvizDependencyTree :: String -> Bool -> Maybe Labels -> Maybe String -> PGF -> CId -> Tree -> String
graphvizBracketedString :: GraphvizOptions -> [BracketedString] -> String
graphvizAlignment :: PGF -> [Language] -> Expr -> String
gizaAlignment :: PGF -> (Language, Language) -> Expr -> (String, String, String)
data GraphvizOptions
GraphvizOptions :: Bool -> Bool -> Bool -> String -> String -> String -> String -> String -> String -> GraphvizOptions
noLeaves :: GraphvizOptions -> Bool
noFun :: GraphvizOptions -> Bool
noCat :: GraphvizOptions -> Bool
nodeFont :: GraphvizOptions -> String
leafFont :: GraphvizOptions -> String
nodeColor :: GraphvizOptions -> String
leafColor :: GraphvizOptions -> String
nodeEdgeStyle :: GraphvizOptions -> String
leafEdgeStyle :: GraphvizOptions -> String
graphvizDefaults :: GraphvizOptions
getDepLabels :: [String] -> Labels

-- | An abstract data structure which represents the probabilities for the
--   different functions in a grammar.
data Probabilities

-- | Builds probability tables. The second argument is a map which contains
--   the know probabilities. If some function is not in the map then it
--   gets assigned some probability based on the even distribution of the
--   unallocated probability mass for the result category.
mkProbabilities :: PGF -> Map CId Double -> Probabilities

-- | Returns the default even distibution.
defaultProbabilities :: PGF -> Probabilities

-- | Renders the probability structure as string
showProbabilities :: Probabilities -> String

-- | Reads the probabilities from a file. This should be a text file where
--   on every line there is a function name followed by a real number. The
--   number represents the probability mass allocated for that function.
--   The function name and the probability should be separated by a
--   whitespace.
readProbabilitiesFromFile :: FilePath -> PGF -> IO Probabilities

-- | compute the probability of a given tree
probTree :: PGF -> Expr -> Double
setProbabilities :: Probabilities -> PGF -> PGF

-- | rank from highest to lowest probability
rankTreesByProbs :: PGF -> [Expr] -> [(Expr, Double)]
browse :: PGF -> CId -> Maybe (String, [CId], [CId])

-- | A type for plain applicative trees
data ATree t
Other :: t -> ATree t
App :: CId -> [ATree t] -> ATree t

-- | A type for tries of plain applicative trees
data Trie
Oth :: Tree -> Trie
Ap :: CId -> [[Trie]] -> Trie

-- | Convert a <a>Tree</a> to an <a>ATree</a>
toATree :: Tree -> ATree Tree

-- | Combine a list of trees into a trie
toTrie :: [ATree Tree] -> [[Trie]]
instance Show t => Show (ATree t)
instance Show Trie

module GF.Support
class HasSourcePath a
sourcePath :: HasSourcePath a => a -> FilePath
data Location
NoLoc :: Location
Local :: Int -> Int -> Location
External :: FilePath -> Location -> Location

-- | Attaching location information
data L a
L :: Location -> a -> L a
unLoc :: L a -> a
noLoc :: a -> L a
ppLocation :: FilePath -> Location -> Doc
ppL :: (Pretty a2, Pretty a1) => L a2 -> a1 -> Doc
data Options
data Flags
Flags :: Mode -> Phase -> Verbosity -> Bool -> [OutputFormat] -> Maybe SISRFormat -> Set HaskellOption -> Set String -> Set Ident -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Recomp -> Maybe FilePath -> Bool -> Maybe String -> [String] -> Maybe String -> Bool -> Set Optimization -> Bool -> Bool -> Set CFGTransform -> [FilePath] -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> [Warning] -> [Dump] -> Bool -> Maybe Double -> Bool -> Bool -> Maybe (Maybe Int) -> Flags
optMode :: Flags -> Mode
optStopAfterPhase :: Flags -> Phase
optVerbosity :: Flags -> Verbosity
optShowCPUTime :: Flags -> Bool
optOutputFormats :: Flags -> [OutputFormat]
optSISR :: Flags -> Maybe SISRFormat
optHaskellOptions :: Flags -> Set HaskellOption
optLexicalCats :: Flags -> Set String
optLiteralCats :: Flags -> Set Ident
optGFODir :: Flags -> Maybe FilePath
optOutputDir :: Flags -> Maybe FilePath
optGFLibPath :: Flags -> Maybe FilePath
optDocumentRoot :: Flags -> Maybe FilePath
optRecomp :: Flags -> Recomp
optProbsFile :: Flags -> Maybe FilePath
optRetainResource :: Flags -> Bool
optName :: Flags -> Maybe String
optPreprocessors :: Flags -> [String]
optEncoding :: Flags -> Maybe String
optPMCFG :: Flags -> Bool
optOptimizations :: Flags -> Set Optimization
optOptimizePGF :: Flags -> Bool
optSplitPGF :: Flags -> Bool
optCFGTransforms :: Flags -> Set CFGTransform
optLibraryPath :: Flags -> [FilePath]
optStartCat :: Flags -> Maybe String
optSpeechLanguage :: Flags -> Maybe String
optLexer :: Flags -> Maybe String
optUnlexer :: Flags -> Maybe String
optWarnings :: Flags -> [Warning]
optDump :: Flags -> [Dump]
optTagsOnly :: Flags -> Bool
optHeuristicFactor :: Flags -> Maybe Double
optCaseSensitive :: Flags -> Bool
optPlusAsBind :: Flags -> Bool
optJobs :: Flags -> Maybe (Maybe Int)
data Mode
ModeVersion :: Mode
ModeHelp :: Mode
ModeInteractive :: Mode
ModeRun :: Mode
ModeCompiler :: Mode
ModeServer :: Int -> Mode
data Phase
Preproc :: Phase
Convert :: Phase
Compile :: Phase
Link :: Phase
data Verbosity
Quiet :: Verbosity
Normal :: Verbosity
Verbose :: Verbosity
Debug :: Verbosity
data OutputFormat
FmtPGFPretty :: OutputFormat
FmtJavaScript :: OutputFormat
FmtPython :: OutputFormat
FmtHaskell :: OutputFormat
FmtProlog :: OutputFormat
FmtLambdaProlog :: OutputFormat
FmtByteCode :: OutputFormat
FmtBNF :: OutputFormat
FmtEBNF :: OutputFormat
FmtRegular :: OutputFormat
FmtNoLR :: OutputFormat
FmtSRGS_XML :: OutputFormat
FmtSRGS_XML_NonRec :: OutputFormat
FmtSRGS_ABNF :: OutputFormat
FmtSRGS_ABNF_NonRec :: OutputFormat
FmtJSGF :: OutputFormat
FmtGSL :: OutputFormat
FmtVoiceXML :: OutputFormat
FmtSLF :: OutputFormat
FmtRegExp :: OutputFormat
FmtFA :: OutputFormat
data SISRFormat

-- | SISR Working draft 1 April 2003
--   <a>http://www.w3.org/TR/2003/WD-semantic-interpretation-20030401/</a>
SISR_WD20030401 :: SISRFormat
SISR_1_0 :: SISRFormat
data Optimization
OptStem :: Optimization
OptCSE :: Optimization
OptExpand :: Optimization
OptParametrize :: Optimization
data CFGTransform
CFGNoLR :: CFGTransform
CFGRegular :: CFGTransform
CFGTopDownFilter :: CFGTransform
CFGBottomUpFilter :: CFGTransform
CFGStartCatOnly :: CFGTransform
CFGMergeIdentical :: CFGTransform
CFGRemoveCycles :: CFGTransform
data HaskellOption
HaskellNoPrefix :: HaskellOption
HaskellGADT :: HaskellOption
HaskellLexical :: HaskellOption
HaskellConcrete :: HaskellOption
HaskellVariants :: HaskellOption
newtype Dump
Dump :: Pass -> Dump
data Pass
Source :: Pass
Rebuild :: Pass
Extend :: Pass
Rename :: Pass
TypeCheck :: Pass
Refresh :: Pass
Optimize :: Pass
Canon :: Pass
data Recomp
AlwaysRecomp :: Recomp
RecompIfNewer :: Recomp
NeverRecomp :: Recomp
outputFormatsExpl :: [((String, OutputFormat), String)]
parseOptions :: ErrorMonad err => [String] -> err (Options, [FilePath])
parseModuleOptions :: ErrorMonad err => [String] -> err Options
fixRelativeLibPaths :: FilePath -> FilePath -> Options -> Options

-- | Pretty-print the options that are preserved in .gfo files.
optionsGFO :: Options -> [(String, Literal)]

-- | Pretty-print the options that are preserved in .pgf files.
optionsPGF :: Options -> [(String, Literal)]
addOptions :: Options -> Options -> Options
concatOptions :: [Options] -> Options
noOptions :: Options
modifyFlags :: (Flags -> Flags) -> Options
helpMessage :: String
flag :: (Flags -> a) -> Options -> a
cfgTransform :: Options -> CFGTransform -> Bool
haskellOption :: Options -> HaskellOption -> Bool
readOutputFormat :: Monad m => String -> m OutputFormat
isLexicalCat :: Options -> String -> Bool
isLiteralCat :: Options -> Ident -> Bool

-- | This is for bacward compatibility. Since GHC 6.12 we started using the
--   native Unicode support in GHC but it uses different names for the code
--   pages.
renameEncoding :: String -> String
getEncoding :: Options -> String
defaultEncoding :: [Char]
setOptimization :: Optimization -> Bool -> Options
setCFGTransform :: CFGTransform -> Bool -> Options
verbAtLeast :: Options -> Verbosity -> Bool
dump :: Options -> Dump -> Bool

-- | Like <a>Maybe</a> type with error msgs
data Err a
Ok :: a -> Err a
Bad :: String -> Err a

-- | Analogue of <a>maybe</a>
err :: (String -> b) -> (a -> b) -> Err a -> b

-- | Add msg s to <a>Maybe</a> failures
maybeErr :: ErrorMonad m => String -> Maybe a -> m a
testErr :: ErrorMonad m => Bool -> String -> m ()

-- | Analogue of <tt>fromMaybe</tt>
fromErr :: a -> Err a -> a
errIn :: ErrorMonad m => String -> m a -> m a
lookupErr :: (ErrorMonad m, Eq a, Show a) => a -> [(a, b)] -> m b
class (Functor m, Monad m) => ErrorMonad m where handle_ a b = a `handle` (\ _ -> b)
raise :: ErrorMonad m => String -> m a
handle :: ErrorMonad m => m a -> (String -> m a) -> m a
handle_ :: ErrorMonad m => m a -> m a -> m a
checks :: ErrorMonad m => [m a] -> m a
doUntil :: ErrorMonad m => (a -> Bool) -> [m a] -> m a
liftErr :: ErrorMonad m => Err a -> m a
checkUnique :: (Show a, Eq a) => [a] -> [String]
unifyMaybeBy :: (Eq b, Monad m) => (a -> b) -> Maybe a -> Maybe a -> m (Maybe a)

-- | this is what happens when matching two values in the same module
unifyMaybe :: (Eq a, Monad m) => Maybe a -> Maybe a -> m (Maybe a)
mapPairListM :: Monad m => ((a, b) -> m c) -> [(a, b)] -> m [(a, c)]
mapPairsM :: Monad m => (b -> m c) -> [(a, b)] -> m [(a, c)]
pairM :: Monad m => (b -> m c) -> (b, b) -> m (c, c)
type BinTree a b = Map a b
emptyBinTree :: BinTree a b
isInBinTree :: Ord a => a -> BinTree a b -> Bool
lookupTree :: (ErrorMonad m, Ord a) => (a -> String) -> a -> BinTree a b -> m b
lookupTreeManyAll :: Ord a => (a -> String) -> [BinTree a b] -> a -> [b]
updateTree :: Ord a => (a, b) -> BinTree a b -> BinTree a b
buildTree :: Ord a => [(a, b)] -> BinTree a b
filterBinTree :: Ord a => (a -> b -> Bool) -> BinTree a b -> BinTree a b
mapTree :: ((a, b) -> c) -> BinTree a b -> BinTree a c
tree2list :: BinTree a b -> [(a, b)]
indent :: Int -> String -> String
(+++) :: String -> String -> String
(++-) :: String -> String -> String
(++++) :: String -> String -> String
(+++++) :: String -> String -> String
prUpper :: String -> String
prReplicate :: Int -> String -> String
prTList :: String -> [String] -> String
prQuotedString :: String -> String
prParenth :: String -> String
prCurly :: String -> String
prBracket :: String -> String
prArgList :: [String] -> String
prSemicList :: [String] -> String
prCurlyList :: [String] -> String
restoreEscapes :: String -> String
numberedParagraphs :: [[String]] -> [String]
prConjList :: String -> [String] -> String
prIfEmpty :: String -> String -> String -> String -> String

-- | Thomas Hallgren's wrap lines
wrapLines :: Int -> String -> String

-- | Topological sorting with test of cyclicity
topoTest :: Ord a => [(a, [a])] -> Either [a] [[a]]

-- | Topological sorting with test of cyclicity, new version /TH 2012-06-26
topoTest2 :: Ord a => [(a, [a])] -> Either [[a]] [[a]]
ifNull :: b -> ([a] -> b) -> [a] -> b

-- | <a>combinations</a> is the same as <a>sequence</a>!!! peb 30/5-04
combinations :: [[a]] -> [[a]]

-- | <pre>
--   return ()
--   </pre>
done :: Monad m => m ()
readIntArg :: String -> Int

-- | Fix point iterator (for computing e.g. transitive closures or
--   reachability)
iterFix :: Eq a => ([a] -> [a]) -> [a] -> [a]

-- | chop into separator-separated parts
chunks :: Eq a => a -> [a] -> [[a]]
putIfVerb :: Output m => Options -> String -> m ()
type FileName = String
type InitPath = String
type FullPath = String
gfLibraryPath :: [Char]
gfGrammarPathVar :: [Char]
getLibraryDirectory :: MonadIO io => Options -> io FilePath
getGrammarPath :: MonadIO io => FilePath -> io [FilePath]

-- | extends the search path with the <a>gfLibraryPath</a> and
--   <a>gfGrammarPathVar</a> environment variables. Returns only existing
--   paths.
extendPathEnv :: MonadIO io => Options -> io [FilePath]
getSubdirs :: FilePath -> IO [FilePath]
justModuleName :: FilePath -> String
isGF :: FilePath -> Bool
isGFO :: FilePath -> Bool
gfFile :: FilePath -> FilePath
gfoFile :: FilePath -> FilePath
gf2gfo :: Options -> FilePath -> FilePath
gf2gfo' :: Maybe FilePath -> FilePath -> FilePath
splitInModuleSearchPath :: String -> [FilePath]

-- | Was: <tt>newtype IOE a = IOE { appIOE :: IO (Err a) }</tt>
type IOE a = IO a

-- | Catch exceptions caused by calls to <a>raise</a> or <a>fail</a> in the
--   <a>IO</a> monad. To catch all <a>IO</a> exceptions, use <a>try</a>
--   instead.
tryIOE :: IOE a -> IO (Err a)

-- | Make raise and handle mimic behaviour of the old IOE monad

-- | Print the error message and return a default value if the IO operation
--   <a>fail</a>s
useIOE :: a -> IOE a -> IO a
maybeIO :: (MonadIO f, Functor f) => IO a -> f (Maybe a)
die :: String -> IO a
class Monad m => Output m
ePutStr, putStrLnE, putStrE, ePutStrLn :: Output m => String -> m ()
putPointE :: (Output m, MonadIO m) => Verbosity -> Options -> String -> m b -> m b

-- | Because GHC adds the confusing text "user error" for failures caused
--   by calls to <a>fail</a>.
ioErrorText :: IOError -> String
timeIt :: MonadIO m => m t -> m (Integer, t)
writeUTF8File :: FilePath -> String -> IO ()
readBinaryFile :: FilePath -> IO String
writeBinaryFile :: FilePath -> String -> IO ()

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a
liftErr :: ErrorMonad m => Err a -> m a
catch :: IO a -> (IOError -> IO a) -> IO a
try :: IO a -> IO (Either IOError a)

-- | Set the console encoding (for Windows, has no effect on Unix-like
--   systems)
setConsoleEncoding :: IO ()
changeConsoleEncoding :: String -> IO ()
data TermColors
TermColors :: String -> String -> String -> TermColors
redFg :: TermColors -> String
blueFg :: TermColors -> String
restore :: TermColors -> String
getTermColors :: MonadIO m => m TermColors

-- | The <tt>Binary</tt> class provides <a>put</a> and <a>get</a>, methods
--   to encode and decode a Haskell value to a lazy ByteString. It mirrors
--   the Read and Show classes for textual representation of Haskell types,
--   and is suitable for serialising Haskell values to disk, over the
--   network.
--   
--   For parsing and generating simple external binary formats (e.g. C
--   structures), Binary may be used, but in general is not suitable for
--   complex protocols. Instead use the Put and Get primitives directly.
--   
--   Instances of Binary should satisfy the following property:
--   
--   <pre>
--   decode . encode == id
--   </pre>
--   
--   That is, the <a>get</a> and <a>put</a> methods should be the inverse
--   of each other. A range of instances are provided for basic Haskell
--   types.
class Binary t

-- | Encode a value using binary serialisation to a lazy ByteString.
encode :: Binary a => a -> ByteString

-- | Decode a value from a lazy ByteString, reconstructing the original
--   structure.
decode :: Binary a => ByteString -> a

-- | Lazily serialise a value to a file
--   
--   This is just a convenience function, it's defined simply as:
--   
--   <pre>
--   encodeFile f = B.writeFile f . encode
--   </pre>
--   
--   So for example if you wanted to compress as well, you could use:
--   
--   <pre>
--   B.writeFile f . compress . encode
--   </pre>
encodeFile :: Binary a => FilePath -> a -> IO ()

-- | Lazily reconstruct a value previously written to a file.
--   
--   This is just a convenience function, it's defined simply as:
--   
--   <pre>
--   decodeFile f = return . decode =&lt;&lt; B.readFile f
--   </pre>
--   
--   So for example if you wanted to decompress as well, you could use:
--   
--   <pre>
--   return . decode . decompress =&lt;&lt; B.readFile f
--   </pre>
decodeFile :: Binary a => FilePath -> IO a


-- | GF, the Grammatical Framework, as a library
module GF

-- | Run the GF main program, taking arguments from the command line. (It
--   calls <a>setConsoleEncoding</a> and <a>getOptions</a>, then
--   <a>mainOpts</a>.) Run <tt>gf --help</tt> for usage info.
main :: IO ()

-- | Get and parse GF command line arguments. Fix relative paths. Calls
--   <a>getArgs</a> and <a>parseOptions</a>.
getOptions :: IO (Options, [FilePath])

-- | Run the GF main program with the given options and files. Depending on
--   the options it invokes <a>mainGFC</a>, <a>mainGFI</a>,
--   <a>mainRunGFI</a>, <a>mainServerGFI</a>, or it just prints
--   version/usage info.
mainOpts :: Options -> [FilePath] -> IO ()

-- | Run the interactive GF Shell
mainGFI :: Options -> [FilePath] -> IO ()

-- | Run the GF Shell in quiet mode (<tt>gf -run</tt>).
mainRunGFI :: Options -> [FilePath] -> IO ()

-- | Run the GF Server (<tt>gf -server</tt>). The <a>Int</a> argument is
--   the port number for the HTTP service.
mainServerGFI :: Options -> Int -> [FilePath] -> IO Server

-- | Compile the given GF grammar files. The result is a number of
--   <tt>.gfo</tt> files and, depending on the options, a <tt>.pgf</tt>
--   file. (<tt>gf -batch</tt>, <tt>gf -make</tt>)
mainGFC :: Options -> [FilePath] -> IO ()

-- | Create a <tt>.pgf</tt> file (and possibly files in other formats, if
--   specified in the <a>Options</a>) from the output of
--   <a>parallelBatchCompile</a>. If a <tt>.pgf</tt> file by the same name
--   already exists and it is newer than the source grammar files (as
--   indicated by the <tt>UTCTime</tt> argument), it is not recreated.
--   Calls <a>writePGF</a> and <a>writeOutputs</a>.
linkGrammars :: Options -> (UTCTime, [(ModuleName, Grammar)]) -> IO ()

-- | Write the result of compiling a grammar (e.g. with
--   <tt>compileToPGF</tt> or <a>link</a>) to a <tt>.pgf</tt> file. A split
--   PGF file is output if the <tt>-split-pgf</tt> option is used.
writePGF :: Options -> PGF -> IOE ()

-- | Export the PGF to the <a>OutputFormat</a>s specified in the
--   <a>Options</a>. Calls <a>exportPGF</a>.
writeOutputs :: Options -> PGF -> IOE ()

-- | Compiles a number of source files and builds a <a>PGF</a> structure
--   for them. This is a composition of <a>link</a> and
--   <a>batchCompile</a>.
compileToPGF :: Options -> [FilePath] -> IOE PGF

-- | Link a grammar into a <a>PGF</a> that can be used to <a>linearize</a>
--   and <a>parse</a> with the <a>PGF</a> run-time system.
link :: Options -> (ModuleName, Grammar) -> IOE PGF

-- | Compile the given grammar files and everything they depend on.
--   Compiled modules are stored in <tt>.gfo</tt> files (unless the
--   <tt>-tags</tt> option is used, in which case tags files are produced
--   instead). Existing <tt>.gfo</tt> files are reused if they are
--   up-to-date (unless the option <tt>-src</tt> aka <tt>-force-recomp</tt>
--   is used).
batchCompile :: Options -> [FilePath] -> IOE (UTCTime, (ModuleName, Grammar))

-- | Returns the name of the abstract syntax corresponding to the named
--   concrete syntax
srcAbsName :: Grammar -> ModuleName -> ModuleName

-- | Compile the given grammar files and everything they depend on, like
--   <tt>batchCompile</tt>. This function compiles modules in parallel. It
--   keeps modules compiled in <i>present</i> and <i>alltenses</i> mode
--   apart, storing the <tt>.gfo</tt> files in separate subdirectories to
--   avoid creating the broken PGF files that can result from mixing
--   different modes in the same concrete syntax.
--   
--   The first argument is supposed to be the number of jobs to run in
--   parallel, but this has not been implemented yet. Instead you have to
--   use the GHC run-time flag <tt>+RTS -N -RTS</tt> to enable parallelism.
parallelBatchCompile :: (Output m, ErrorMonad m, MonadIO m) => t -> Options -> [FilePath] -> m (UTCTime, [(ModuleName, Grammar)])

-- | Export a PGF to the given <a>OutputFormat</a>. For many output
--   formats, additional <a>Options</a> can be used to control the output.
exportPGF :: Options -> OutputFormat -> PGF -> [(FilePath, String)]
type OneOutput = (Maybe FullPath, CompiledModule)
type CompiledModule = Module

-- | Compile a given source file (or just load a .gfo file), given a
--   <a>Grammar</a> containing everything it depends on. Calls
--   <a>reuseGFO</a> or <a>useTheSource</a>.
compileOne :: (Output m, ErrorMonad m, MonadIO m) => Options -> Grammar -> FullPath -> m OneOutput

-- | Read a compiled GF module. Also undo common subexp optimization, to
--   enable normal computations.
reuseGFO :: (Output m, ErrorMonad m, MonadIO m) => Options -> Grammar -> FullPath -> m OneOutput

-- | Compile GF module from source. It both returns the result and stores
--   it in a <tt>.gfo</tt> file (or a tags file, if running with the
--   <tt>-tags</tt> option)
useTheSource :: (Output m, ErrorMonad m, MonadIO m) => Options -> Grammar -> FullPath -> m OneOutput

-- | Read a source file and parse it (after applying preprocessors
--   specified in the options)
getSourceModule :: (Output m, ErrorMonad m, MonadIO m) => Options -> FilePath -> m (ModuleName, ModuleInfo)
getCFRules :: Options -> FilePath -> IOE [CFRule]
getEBNFRules :: Options -> FilePath -> IOE [ERule]

-- | A grammar is a self-contained collection of grammar modules
data Grammar

-- | Module names
data ModuleName

-- | Modules
type Module = (ModuleName, ModuleInfo)
data ModuleInfo
ModInfo :: ModuleType -> ModuleStatus -> Options -> [(ModuleName, MInclude)] -> Maybe (ModuleName, MInclude, [(ModuleName, ModuleName)]) -> [OpenSpec] -> [ModuleName] -> FilePath -> Maybe (Array SeqId Sequence) -> Map Ident Info -> ModuleInfo
mtype :: ModuleInfo -> ModuleType
mstatus :: ModuleInfo -> ModuleStatus
mflags :: ModuleInfo -> Options
mextend :: ModuleInfo -> [(ModuleName, MInclude)]
mwith :: ModuleInfo -> Maybe (ModuleName, MInclude, [(ModuleName, ModuleName)])
mopens :: ModuleInfo -> [OpenSpec]
mexdeps :: ModuleInfo -> [ModuleName]
msrc :: ModuleInfo -> FilePath
mseqs :: ModuleInfo -> Maybe (Array SeqId Sequence)
jments :: ModuleInfo -> Map Ident Info
type SourceGrammar = Grammar
type SourceModInfo = ModuleInfo
type SourceModule = Module

-- | encoding the type of the module
data ModuleType
MTAbstract :: ModuleType
MTResource :: ModuleType
MTConcrete :: ModuleName -> ModuleType
MTInterface :: ModuleType
MTInstance :: (ModuleName, MInclude) -> ModuleType
emptyGrammar :: Grammar
mGrammar :: [Module] -> Grammar
modules :: Grammar -> [Module]
prependModule :: Grammar -> Module -> Grammar
moduleMap :: Grammar -> Map ModuleName ModuleInfo
data MInclude
MIAll :: MInclude
MIOnly :: [Ident] -> MInclude
MIExcept :: [Ident] -> MInclude
data OpenSpec
OSimple :: ModuleName -> OpenSpec
OQualif :: ModuleName -> ModuleName -> OpenSpec
extends :: ModuleInfo -> [ModuleName]
isInherited :: MInclude -> Ident -> Bool
inheritAll :: ModuleName -> (ModuleName, MInclude)
openedModule :: OpenSpec -> ModuleName

-- | all dependencies
allDepsModule :: Grammar -> ModuleInfo -> [OpenSpec]

-- | select just those modules that a given one depends on, including
--   itself
partOfGrammar :: Grammar -> Module -> Grammar

-- | initial dependency list
depPathModule :: ModuleInfo -> [OpenSpec]

-- | all modules that a module extends, directly or indirectly, with
--   restricts
allExtends :: Grammar -> ModuleName -> [Module]

-- | the same as <a>allExtends</a> plus that an instance extends its
--   interface
allExtendsPlus :: Grammar -> ModuleName -> [ModuleName]
lookupModule :: ErrorMonad m => Grammar -> ModuleName -> m ModuleInfo
isModAbs :: ModuleInfo -> Bool
isModRes :: ModuleInfo -> Bool
isModCnc :: ModuleInfo -> Bool
sameMType :: ModuleType -> ModuleType -> Bool

-- | don't generate code for interfaces and for incomplete modules
isCompilableModule :: ModuleInfo -> Bool

-- | interface and "incomplete M" are not complete
isCompleteModule :: ModuleInfo -> Bool

-- | all abstract modules sorted from least to most dependent
allAbstracts :: Grammar -> [ModuleName]

-- | the last abstract in dependency order (head of list)
greatestAbstract :: Grammar -> Maybe ModuleName

-- | all resource modules
allResources :: Grammar -> [ModuleName]

-- | the greatest resource in dependency order
greatestResource :: Grammar -> Maybe ModuleName

-- | all concretes for a given abstract
allConcretes :: Grammar -> ModuleName -> [ModuleName]

-- | all concrete modules for any abstract
allConcreteModules :: Grammar -> [ModuleName]

-- | we store the module type with the identifier
abstractOfConcrete :: ErrorMonad m => Grammar -> ModuleName -> m ModuleName
data ModuleStatus
MSComplete :: ModuleStatus
MSIncomplete :: ModuleStatus

-- | the constructors are judgements in
--   
--   <ul>
--   <li>abstract syntax (<i>ABS</i>)</li>
--   <li>resource (<i>RES</i>)</li>
--   <li>concrete syntax (<i>CNC</i>)</li>
--   </ul>
--   
--   and indirection to module (<i>INDIR</i>)
data Info

-- | (<i>ABS</i>) context of a category
AbsCat :: (Maybe (L Context)) -> Info

-- | (<i>ABS</i>) type, arrity and definition of a function
AbsFun :: (Maybe (L Type)) -> (Maybe Int) -> (Maybe [L Equation]) -> (Maybe Bool) -> Info

-- | (<i>RES</i>) the second parameter is list of all possible values
ResParam :: (Maybe (L [Param])) -> (Maybe [Term]) -> Info

-- | (<i>RES</i>) to mark parameter constructors for lookup
ResValue :: (L Type) -> Info

-- | (<i>RES</i>)
ResOper :: (Maybe (L Type)) -> (Maybe (L Term)) -> Info

-- | (<i>RES</i>) idents: modules inherited
ResOverload :: [ModuleName] -> [(L Type, L Term)] -> Info

-- | (<i>CNC</i>) lindef ini'zed,
CncCat :: (Maybe (L Type)) -> (Maybe (L Term)) -> (Maybe (L Term)) -> (Maybe (L Term)) -> (Maybe PMCFG) -> Info

-- | (<i>CNC</i>) type info added at <tt>TC</tt>
CncFun :: (Maybe (Ident, Context, Type)) -> (Maybe (L Term)) -> (Maybe (L Term)) -> (Maybe PMCFG) -> Info

-- | (<i>INDIR</i>) the <a>Bool</a> says if canonical
AnyInd :: Bool -> ModuleName -> Info
data Term

-- | variable
Vr :: Ident -> Term

-- | constant
Cn :: Ident -> Term

-- | constructor
Con :: Ident -> Term

-- | basic type
Sort :: Ident -> Term

-- | integer literal
EInt :: Int -> Term

-- | floating point literal
EFloat :: Double -> Term

-- | string literal or token: <tt>"foo"</tt>
K :: String -> Term

-- | the empty string <tt>[]</tt>
Empty :: Term

-- | application: <tt>f a</tt>
App :: Term -> Term -> Term

-- | abstraction: <tt>x -&gt; b</tt>
Abs :: BindType -> Ident -> Term -> Term

-- | metavariable: <tt>?i</tt> (only parsable: ? = ?0)
Meta :: {-# UNPACK #-} !MetaId -> Term

-- | placeholder for implicit argument <tt>{t}</tt>
ImplArg :: Term -> Term

-- | function type: <tt>(x : A) -&gt; B</tt>, <tt>A -&gt; B</tt>, <tt>({x}
--   : A) -&gt; B</tt>
Prod :: BindType -> Ident -> Term -> Term -> Term

-- | type-annotated term
--   
--   <i>below this, the constructors are only for concrete syntax</i>
Typed :: Term -> Term -> Term

-- | example-based term: @in M.C "foo"
Example :: Term -> String -> Term

-- | record type: <tt>{ p : A ; ...}</tt>
RecType :: [Labelling] -> Term

-- | record: <tt>{ p = a ; ...}</tt>
R :: [Assign] -> Term

-- | projection: <tt>r.p</tt>
P :: Term -> Label -> Term

-- | extension: <tt>R ** {x : A}</tt> (both types and terms)
ExtR :: Term -> Term -> Term

-- | table type: <tt>P =&gt; A</tt>
Table :: Term -> Term -> Term

-- | table: <tt>table {p =&gt; c ; ...}</tt>
T :: TInfo -> [Case] -> Term

-- | table given as course of values: <tt>table T [c1 ; ... ; cn]</tt>
V :: Type -> [Term] -> Term

-- | selection: <tt>t ! p</tt>
S :: Term -> Term -> Term

-- | local definition: <tt>let {t : T = a} in b</tt>
Let :: LocalDef -> Term -> Term

-- | qualified constant from a package
Q :: QIdent -> Term

-- | qualified constructor from a package
QC :: QIdent -> Term

-- | concatenation: <tt>s ++ t</tt>
C :: Term -> Term -> Term

-- | agglutination: <tt>s + t</tt>
Glue :: Term -> Term -> Term

-- | pattern (in macro definition): # p
EPatt :: Patt -> Term

-- | pattern type: pattern T
EPattType :: Term -> Term

-- | boxed linearization type of Ident
ELincat :: Ident -> Term -> Term

-- | boxed linearization of type Ident
ELin :: Ident -> Term -> Term

-- | ad hoc overloading generated in Rename
AdHocOverload :: [Term] -> Term

-- | alternatives in free variation: <tt>variants { s ; ... }</tt>
FV :: [Term] -> Term

-- | alternatives by prefix: <tt>pre {t ; s/c ; ...}</tt>
Alts :: Term -> [(Term, Term)] -> Term

-- | conditioning prefix strings: <tt>strs {s ; ...}</tt>
Strs :: [Term] -> Term

-- | error values returned by Predef.error
Error :: String -> Term
type Type = Term
type Cat = QIdent
type Fun = QIdent
type QIdent = (ModuleName, Ident)
data BindType
Explicit :: BindType
Implicit :: BindType

-- | Patterns
data Patt

-- | constructor pattern: <tt>C p1 ... pn</tt> <tt>C</tt>
PC :: Ident -> [Patt] -> Patt

-- | package constructor pattern: <tt>P.C p1 ... pn</tt> <tt>P.C</tt>
PP :: QIdent -> [Patt] -> Patt

-- | variable pattern: <tt>x</tt>
PV :: Ident -> Patt

-- | wild card pattern: <tt>_</tt>
PW :: Patt

-- | record pattern: <tt>{r = p ; ...}</tt> -- only concrete
PR :: [(Label, Patt)] -> Patt

-- | string literal pattern: <tt>"foo"</tt> -- only abstract
PString :: String -> Patt

-- | integer literal pattern: <tt>12</tt> -- only abstract
PInt :: Int -> Patt

-- | float literal pattern: <tt>1.2</tt> -- only abstract
PFloat :: Double -> Patt

-- | type-annotated pattern
PT :: Type -> Patt -> Patt

-- | as-pattern: x@p
PAs :: Ident -> Patt -> Patt

-- | placeholder for pattern for implicit argument <tt>{p}</tt>
PImplArg :: Patt -> Patt

-- | inaccessible pattern
PTilde :: Term -> Patt

-- | negated pattern: -p
PNeg :: Patt -> Patt

-- | disjunctive pattern: p1 | p2
PAlt :: Patt -> Patt -> Patt

-- | sequence of token parts: p + q
PSeq :: Patt -> Patt -> Patt

-- | sequence of token parts: p + q
PMSeq :: MPatt -> MPatt -> Patt

-- | repetition of token part: p*
PRep :: Patt -> Patt

-- | string of length one: ?
PChar :: Patt

-- | character list: ["aeiou"]
PChars :: [Char] -> Patt
PMacro :: Ident -> Patt
PM :: QIdent -> Patt

-- | to guide computation and type checking of tables
data TInfo

-- | received from parser; can be anything
TRaw :: TInfo

-- | type annontated, but can be anything
TTyped :: Type -> TInfo

-- | expanded
TComp :: Type -> TInfo

-- | just one wild card pattern, no need to expand
TWild :: Type -> TInfo

-- | record label
data Label
LIdent :: RawIdent -> Label
LVar :: Int -> Label
type MetaId = Int
type Hypo = (BindType, Ident, Term)
type Context = [Hypo]
type Equation = ([Patt], Term)
type Labelling = (Label, Type)
type Assign = (Label, (Maybe Type, Term))
type Case = (Patt, Term)
type LocalDef = (Ident, (Maybe Type, Term))
type Param = (Ident, Context)
type Altern = (Term, [(Term, Term)])
type Substitution = [(Ident, Term)]
varLabel :: Int -> Label
tupleLabel :: Int -> Label
linLabel :: Int -> Label
theLinLabel :: Label
ident2label :: Ident -> Label
label2ident :: Label -> Ident
data Location
NoLoc :: Location
Local :: Int -> Int -> Location
External :: FilePath -> Location -> Location

-- | Attaching location information
data L a
L :: Location -> a -> L a
unLoc :: L a -> a
noLoc :: a -> L a
ppLocation :: FilePath -> Location -> Doc
ppL :: (Pretty a2, Pretty a1) => L a2 -> a1 -> Doc
data PMCFG
PMCFG :: [Production] -> (Array FunId (UArray LIndex SeqId)) -> PMCFG
data Production
Production :: {-# UNPACK #-} !FId -> {-# UNPACK #-} !FunId -> [[FId]] -> Production
type FId = Int
type FunId = Int
type SeqId = Int
type LIndex = Int
type Sequence = Array DotPos Symbol
typeForm :: Type -> (Context, Cat, [Term])
typeFormCnc :: Type -> (Context, Type)
valCat :: Type -> Cat
valType :: Type -> Type
valTypeCnc :: Type -> Type
typeSkeleton :: Type -> ([(Int, Cat)], Cat)
catSkeleton :: Type -> ([Cat], Cat)
funsToAndFrom :: Type -> (Cat, [(Cat, [Int])])
isRecursiveType :: Type -> Bool
isHigherOrderType :: Type -> Bool
contextOfType :: Monad m => Type -> m Context
termForm :: Monad m => Term -> m ([(BindType, Ident)], Term, [Term])
termFormCnc :: Term -> ([(BindType, Ident)], Term)
appForm :: Term -> (Term, [Term])
mkProdSimple :: Context -> Term -> Term
mkProd :: Context -> Term -> [Term] -> Term
mkTerm :: ([(BindType, Ident)], Term, [Term]) -> Term
mkApp :: Term -> [Term] -> Term
mkAbs :: [(BindType, Ident)] -> Term -> Term
appCons :: Ident -> [Term] -> Term
mkLet :: [LocalDef] -> Term -> Term
mkLetUntyped :: Context -> Term -> Term
isVariable :: Term -> Bool
uType :: Type
assign :: Label -> Term -> Assign
assignT :: Label -> Type -> Term -> Assign
unzipR :: [Assign] -> ([Label], [Term])
mkAssign :: [(Label, Term)] -> [Assign]
projectRec :: Label -> [Assign] -> Term
zipAssign :: [Label] -> [Term] -> [Assign]
mapAssignM :: Monad m => (Term -> m c) -> [Assign] -> m [(Label, (Maybe c, c))]
mkRecordN :: Int -> (Int -> Label) -> [Term] -> Term
mkRecord :: (Int -> Label) -> [Term] -> Term
mkRecTypeN :: Int -> (Int -> Label) -> [Type] -> Type
mkRecType :: (Int -> Label) -> [Type] -> Type
record2subst :: Term -> Err Substitution
typeType :: Type
typeStrs :: Type
typeTok :: Type
typeStr :: Type
typePType :: Type
typeString :: Type
typeInt :: Type
typeFloat :: Type
typeInts :: Int -> Type
typePBool :: Type
typeError :: Type
isTypeInts :: Type -> Maybe Int
isPredefConstant :: Term -> Bool
checkPredefError :: Monad m => Term -> m Term
cnPredef :: Ident -> Term
mkSelects :: Term -> [Term] -> Term
mkTable :: [Term] -> Term -> Term
mkCTable :: [(BindType, Ident)] -> Term -> Term
mkHypo :: Term -> Hypo
eqStrIdent :: Ident -> Ident -> Bool
tuple2record :: [Term] -> [Assign]
tuple2recordType :: [Term] -> [Labelling]
tuple2recordPatt :: [Patt] -> [(Label, Patt)]
mkCases :: Ident -> Term -> Term
mkWildCases :: Term -> Term
mkFunType :: [Type] -> Type -> Type
plusRecType :: ErrorMonad m => Term -> Term -> m Term
plusRecord :: ErrorMonad m => Term -> Term -> m Term

-- | default linearization type
defLinType :: Type

-- | refreshing variables
mkFreshVar :: [Ident] -> Ident

-- | trying to preserve a given symbol
mkFreshVarX :: [Ident] -> Ident -> Ident
maxVarIndex :: [Ident] -> Int
mkFreshVars :: Int -> [Ident] -> [Ident]

-- | quick hack for refining with var in editor
freshAsTerm :: String -> Term

-- | create a terminal for concrete syntax
string2term :: String -> Term
int2term :: Int -> Term
float2term :: Double -> Term

-- | create a terminal from identifier
ident2terminal :: Ident -> Term
symbolOfIdent :: Ident -> String
symid :: Ident -> String
justIdentOf :: Term -> Maybe Ident
linTypeStr :: Type
linAsStr :: String -> Term
term2patt :: Term -> Err Patt
patt2term :: Patt -> Term

-- | to define compositional term functions
composSafeOp :: (Term -> Term) -> Term -> Term

-- | to define compositional term functions
composOp :: Monad m => (Term -> m Term) -> Term -> m Term
composSafePattOp :: (Patt -> Patt) -> Patt -> Patt
composPattOp :: Monad m => (Patt -> m Patt) -> Patt -> m Patt
collectOp :: Monoid m => (Term -> m) -> Term -> m
mconcatMap :: Monoid c => (a -> c) -> [a] -> c
collectPattOp :: (Patt -> [a]) -> Patt -> [a]
redirectTerm :: ModuleName -> Term -> Term

-- | to gather ultimate cases in a table; preserves pattern list
allCaseValues :: Term -> [([Patt], Term)]

-- | to get a string from a term that represents a sequence of terminals
strsFromTerm :: Term -> Err [Str]

-- | to print an Str-denoting term as a string; if the term is of wrong
--   type, the error msg
stringFromTerm :: Term -> String
getTableType :: TInfo -> Err Type
changeTableType :: Monad m => (Type -> m Type) -> TInfo -> m TInfo

-- | to find the word items in a term
wordsInTerm :: Term -> [String]
noExist :: Term
defaultLinType :: Type
sortRec :: [(Label, a)] -> [(Label, a)]

-- | dependency check, detecting circularities and returning topo-sorted
--   list
allDependencies :: (ModuleName -> Bool) -> BinTree Ident Info -> [(Ident, [Ident])]
topoSortJments :: ErrorMonad m => SourceModule -> m [(Ident, Info)]
topoSortJments2 :: ErrorMonad m => SourceModule -> m [[(Ident, Info)]]
data TermPrintQual
Unqualified :: TermPrintQual
Qualified :: TermPrintQual
Internal :: TermPrintQual
ppModule :: TermPrintQual -> SourceModule -> Doc
ppJudgement :: Pretty a1 => TermPrintQual -> (a1, Info) -> Doc
ppParams :: Pretty a => TermPrintQual -> [(a, [(t, Ident, Term)])] -> Doc
ppTerm :: (Ord a, Num a) => TermPrintQual -> a -> Term -> Doc
ppPatt :: (Ord a, Num a) => TermPrintQual -> a -> Patt -> Doc
ppValue :: TermPrintQual -> Int -> Val -> Doc
ppConstrs :: Constraints -> [Doc]
ppQIdent :: TermPrintQual -> QIdent -> Doc
ppMeta :: MetaId -> Doc
getAbs :: Term -> ([(BindType, Ident)], Term)

-- | Module names
newtype ModuleName
MN :: Ident -> ModuleName
moduleNameS :: String -> ModuleName

-- | the constructors labelled <i>INTERNAL</i> are internal representation
--   never returned by the parser
data Ident

-- | This function should be used with care, since the returned ByteString
--   is UTF-8-encoded.
ident2utf8 :: Ident -> ByteString
showIdent :: Ident -> String
prefixIdent :: String -> Ident -> Ident
identS :: String -> Ident
identC :: RawIdent -> Ident
identW :: Ident
identV :: RawIdent -> Int -> Ident
identA :: RawIdent -> Int -> Ident
identAV :: RawIdent -> Int -> Int -> Ident

-- | to mark argument variables
argIdent :: Int -> Ident -> Int -> Ident
isArgIdent :: Ident -> Bool
getArgIndex :: Ident -> Maybe Int

-- | used in lin defaults
varStr :: Ident

-- | refreshing variables
varX :: Int -> Ident
isWildIdent :: Ident -> Bool
varIndex :: Ident -> Int

-- | Identifiers are stored as UTF-8-encoded bytestrings. (It is also
--   possible to use regular Haskell <a>String</a>s, with somewhat reduced
--   performance and increased memory use.)
data RawIdent
rawIdentS :: String -> RawIdent
rawIdentC :: ByteString -> RawIdent
ident2raw :: Ident -> RawIdent
prefixRawIdent :: RawIdent -> RawIdent -> RawIdent
isPrefixOf :: RawIdent -> RawIdent -> Bool
showRawIdent :: RawIdent -> String
data VersionTagged a
Tagged :: a -> VersionTagged a
unV :: VersionTagged a -> a
WrongVersion :: VersionTagged a

-- | Read just the module header, the returned <a>Module</a> will have an
--   empty body
decodeModuleHeader :: MonadIO io => FilePath -> io (VersionTagged Module)
decodeModule :: MonadIO io => FilePath -> io SourceModule
encodeModule :: MonadIO io => FilePath -> SourceModule -> io ()
