-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Toolsuite for automated design of business processes.
--   
--   You can define your business processes by means of rules, written in
--   Relation Algebra.
@package ampersand
@version 3.0.2

module DatabaseDesign.Ampersand
data A_Context
data P_Context
PCtx :: String -> [Origin] -> Maybe Lang -> Maybe PandocFormat -> [String] -> [P_Pattern] -> [P_Process] -> [(P_Rule TermPrim)] -> [P_Declaration] -> [ConceptDef] -> [P_IdentDef] -> [P_ViewDef] -> [P_Gen] -> [P_Interface] -> [PPurpose] -> [P_Population] -> [P_ObjectDef] -> [P_ObjectDef] -> [Meta] -> P_Context

-- | The name of this context
ctx_nm :: P_Context -> String

-- | The origin of the context. A context can be a merge of a file
--   including other files c.q. a list of Origin.
ctx_pos :: P_Context -> [Origin]

-- | The default language specified by this context, if specified at all.
ctx_lang :: P_Context -> Maybe Lang

-- | The default markup format for free text in this context
ctx_markup :: P_Context -> Maybe PandocFormat

-- | Names of patterns/processes to be printed in the functional
--   specification. (For partial documents.)
ctx_thms :: P_Context -> [String]

-- | The patterns defined in this context
ctx_pats :: P_Context -> [P_Pattern]

-- | The processes as defined by the parser
ctx_PPrcs :: P_Context -> [P_Process]

-- | All user defined rules in this context, but outside patterns and
--   outside processes
ctx_rs :: P_Context -> [(P_Rule TermPrim)]

-- | The relations defined in this context, outside the scope of patterns
ctx_ds :: P_Context -> [P_Declaration]

-- | The concept definitions defined in this context, outside the scope of
--   patterns
ctx_cs :: P_Context -> [ConceptDef]

-- | The identity definitions defined in this context, outside the scope of
--   patterns
ctx_ks :: P_Context -> [P_IdentDef]

-- | The view definitions defined in this context, outside the scope of
--   patterns
ctx_vs :: P_Context -> [P_ViewDef]

-- | The gen definitions defined in this context, outside the scope of
--   patterns
ctx_gs :: P_Context -> [P_Gen]

-- | The interfaces defined in this context, outside the scope of patterns
ctx_ifcs :: P_Context -> [P_Interface]

-- | The purposes defined in this context, outside the scope of patterns
ctx_ps :: P_Context -> [PPurpose]

-- | The populations defined in this context
ctx_pops :: P_Context -> [P_Population]

-- | user defined sqlplugs, taken from the Ampersand script
ctx_sql :: P_Context -> [P_ObjectDef]

-- | user defined phpplugs, taken from the Ampersand script
ctx_php :: P_Context -> [P_ObjectDef]

-- | generic meta information (name/value pairs) that can be used for
--   experimenting without having to modify the adl syntax
ctx_metas :: P_Context -> [Meta]
data P_Population
P_RelPopu :: String -> Origin -> Pairs -> P_Population
p_rnme :: P_Population -> String
p_orig :: P_Population -> Origin
p_popps :: P_Population -> Pairs
P_TRelPop :: String -> P_Sign -> Origin -> Pairs -> P_Population
p_rnme :: P_Population -> String
p_type :: P_Population -> P_Sign
p_orig :: P_Population -> Origin
p_popps :: P_Population -> Pairs
P_CptPopu :: String -> Origin -> [String] -> P_Population
p_cnme :: P_Population -> String
p_orig :: P_Population -> Origin
p_popas :: P_Population -> [String]
data PairView a
PairView :: [PairViewSegment a] -> PairView a
ppv_segs :: PairView a -> [PairViewSegment a]
data PairViewSegment a
PairViewText :: String -> PairViewSegment a
PairViewExp :: SrcOrTgt -> a -> PairViewSegment a
data SrcOrTgt
Src :: SrcOrTgt
Tgt :: SrcOrTgt
data P_Rule a
P_Ru :: String -> (Term a) -> Origin -> [PMeaning] -> [PMessage] -> Maybe (PairView (Term a)) -> P_Rule a

-- | Name of this rule
rr_nm :: P_Rule a -> String

-- | The rule expression
rr_exp :: P_Rule a -> (Term a)

-- | Position in the Ampersand file
rr_fps :: P_Rule a -> Origin

-- | User-specified meanings, possibly more than one, for multiple
--   languages.
rr_mean :: P_Rule a -> [PMeaning]

-- | User-specified violation messages, possibly more than one, for
--   multiple languages.
rr_msg :: P_Rule a -> [PMessage]

-- | Custom presentation for violations, currently only in a single
--   language
rr_viol :: P_Rule a -> Maybe (PairView (Term a))
data Term a
Prim :: a -> Term a

-- | equivalence =
Pequ :: Origin -> (Term a) -> (Term a) -> Term a

-- | implication |-
Pimp :: Origin -> (Term a) -> (Term a) -> Term a

-- | intersection /
PIsc :: Origin -> (Term a) -> (Term a) -> Term a

-- | union /
PUni :: Origin -> (Term a) -> (Term a) -> Term a

-- | difference -
PDif :: Origin -> (Term a) -> (Term a) -> Term a

-- | left residual /
PLrs :: Origin -> (Term a) -> (Term a) -> Term a

-- | right residual
PRrs :: Origin -> (Term a) -> (Term a) -> Term a

-- | diamond <a></a>
PDia :: Origin -> (Term a) -> (Term a) -> Term a

-- | composition ;
PCps :: Origin -> (Term a) -> (Term a) -> Term a

-- | relative addition !
PRad :: Origin -> (Term a) -> (Term a) -> Term a

-- | cartesian product *
PPrd :: Origin -> (Term a) -> (Term a) -> Term a

-- | Rfx.Trn closure * (Kleene star)
PKl0 :: Origin -> (Term a) -> Term a

-- | Transitive closure + (Kleene plus)
PKl1 :: Origin -> (Term a) -> Term a

-- | conversion (flip, wok) ~
PFlp :: Origin -> (Term a) -> Term a

-- | Complement
PCpl :: Origin -> (Term a) -> Term a

-- | bracketed expression ( ... )
PBrk :: Origin -> (Term a) -> Term a
data TermPrim

-- | identity element without a type At parse time, there may be zero or
--   one element in the list of concepts. Reason: when making eqClasses,
--   the least element of that class is used as a witness of that class to
--   know whether an eqClass represents a concept, we only look at its
--   witness By making Pid the first in the data decleration, it becomes
--   the least element for <a>deriving Ord</a>.
PI :: Origin -> TermPrim

-- | identity element restricted to a type
Pid :: Origin -> P_Concept -> TermPrim

-- | an atom, possibly with a type
Patm :: Origin -> String -> (Maybe P_Concept) -> TermPrim

-- | the complete relation, of which the type is yet to be derived by the
--   type checker.
PVee :: Origin -> TermPrim

-- | the complete relation, restricted to a type. At parse time, there may
--   be zero, one or two elements in the list of concepts.
Pfull :: Origin -> P_Concept -> P_Concept -> TermPrim

-- | we expect expressions in flip-normal form
Prel :: Origin -> String -> TermPrim

-- | type cast expression
PTrel :: Origin -> String -> P_Sign -> TermPrim
data P_Sign
P_Sign :: P_Concept -> P_Concept -> P_Sign
pSrc :: P_Sign -> P_Concept
pTgt :: P_Sign -> P_Concept
data P_Concept

-- | The name of this Concept
PCpt :: String -> P_Concept
p_cptnm :: P_Concept -> String
P_Singleton :: P_Concept
data P_Declaration
P_Sgn :: String -> P_Sign -> Props -> String -> String -> String -> [PMeaning] -> Pairs -> Origin -> Bool -> P_Declaration

-- | the name of the declaration
dec_nm :: P_Declaration -> String

-- | the type. Parser must guarantee it is not empty.
dec_sign :: P_Declaration -> P_Sign

-- | the user defined multiplicity properties (Uni, Tot, Sur, Inj) and
--   algebraic properties (Sym, Asy, Trn, Rfx)
dec_prps :: P_Declaration -> Props

-- | three strings, which form the pragma. E.g. if pragma consists of the
--   three strings: <a>Person </a>, <a> is married to person </a>, and <a>
--   in Vegas.</a>
dec_prL :: P_Declaration -> String

-- | then a tuple (<a>Peter</a>,<a>Jane</a>) in the list of links means
--   that Person Peter is married to person Jane in Vegas.
dec_prM :: P_Declaration -> String
dec_prR :: P_Declaration -> String

-- | the optional meaning of a declaration, possibly more than one for
--   different languages.
dec_Mean :: P_Declaration -> [PMeaning]

-- | the list of tuples, of which the relation consists.
dec_popu :: P_Declaration -> Pairs

-- | the position in the Ampersand source file where this declaration is
--   declared. Not all decalartions come from the ampersand souce file.
dec_fpos :: P_Declaration -> Origin

-- | if true, this relation may not be stored in or retrieved from the
--   standard database (it should be gotten from a Plug of some sort
--   instead)
dec_plug :: P_Declaration -> Bool
data P_Pattern
P_Pat :: String -> Origin -> Origin -> [(P_Rule TermPrim)] -> [P_Gen] -> [P_Declaration] -> [RoleRule] -> [P_RoleRelation] -> [ConceptDef] -> [P_IdentDef] -> [P_ViewDef] -> [PPurpose] -> [P_Population] -> P_Pattern

-- | Name of this pattern
pt_nm :: P_Pattern -> String

-- | the starting position in the file in which this pattern was declared.
pt_pos :: P_Pattern -> Origin

-- | the end position in the file in which this pattern was declared.
pt_end :: P_Pattern -> Origin

-- | The user defined rules in this pattern
pt_rls :: P_Pattern -> [(P_Rule TermPrim)]

-- | The generalizations defined in this pattern
pt_gns :: P_Pattern -> [P_Gen]

-- | The relations that are declared in this pattern
pt_dcs :: P_Pattern -> [P_Declaration]

-- | The assignment of roles to rules.
pt_rus :: P_Pattern -> [RoleRule]

-- | The assignment of roles to Relations.
pt_res :: P_Pattern -> [P_RoleRelation]

-- | The concept definitions defined in this pattern
pt_cds :: P_Pattern -> [ConceptDef]

-- | The identity definitions defined in this pattern
pt_ids :: P_Pattern -> [P_IdentDef]

-- | The view definitions defined in this pattern
pt_vds :: P_Pattern -> [P_ViewDef]

-- | The purposes of elements defined in this pattern
pt_xps :: P_Pattern -> [PPurpose]

-- | The populations that are local to this pattern
pt_pop :: P_Pattern -> [P_Population]
data P_Gen
P_Cy :: P_Concept -> [P_Concept] -> Origin -> P_Gen

-- | specific concept
--   
--   Left hand side concept expression
gen_spc :: P_Gen -> P_Concept

-- | Right hand side concept expression
gen_rhs :: P_Gen -> [P_Concept]

-- | the position of the GEN-rule
--   
--   Position in the Ampersand file
gen_fp :: P_Gen -> Origin
PGen :: P_Concept -> P_Concept -> Origin -> P_Gen

-- | specific concept
--   
--   Left hand side concept expression
gen_spc :: P_Gen -> P_Concept

-- | generic concept
gen_gen :: P_Gen -> P_Concept

-- | the position of the GEN-rule
--   
--   Position in the Ampersand file
gen_fp :: P_Gen -> Origin
data P_Markup
P_Markup :: Maybe Lang -> Maybe PandocFormat -> String -> P_Markup
mLang :: P_Markup -> Maybe Lang
mFormat :: P_Markup -> Maybe PandocFormat
mString :: P_Markup -> String
data PRef2Obj
PRef2ConceptDef :: String -> PRef2Obj
PRef2Declaration :: TermPrim -> PRef2Obj
PRef2Rule :: String -> PRef2Obj
PRef2IdentityDef :: String -> PRef2Obj
PRef2ViewDef :: String -> PRef2Obj
PRef2Pattern :: String -> PRef2Obj
PRef2Process :: String -> PRef2Obj
PRef2Interface :: String -> PRef2Obj
PRef2Context :: String -> PRef2Obj
PRef2Fspc :: String -> PRef2Obj
data PPurpose
PRef2 :: Origin -> PRef2Obj -> P_Markup -> [String] -> PPurpose
pexPos :: PPurpose -> Origin
pexObj :: PPurpose -> PRef2Obj
pexMarkup :: PPurpose -> P_Markup
pexRefIDs :: PPurpose -> [String]
newtype PMeaning
PMeaning :: P_Markup -> PMeaning
data Meta
Meta :: Origin -> MetaObj -> String -> String -> Meta
mtPos :: Meta -> Origin
mtObj :: Meta -> MetaObj
mtName :: Meta -> String
mtVal :: Meta -> String
data MetaObj
ContextMeta :: MetaObj
data A_Concept

-- | PlainConcept nm represents the set of instances cs by name nm.
PlainConcept :: String -> A_Concept
cptnm :: A_Concept -> String

-- | The universal Singleton: <tt>I</tt>[<tt>Anything</tt>] =
--   <tt>V</tt>['Anything'*'Anything']
ONE :: A_Concept

-- | data structure A_Gen contains the CLASSIFY statements from an
--   Ampersand script CLASSIFY Employee ISA Person translates to Isa (C
--   <a>Person</a>) (C <a>Employee</a>) CLASSIFY Workingstudent IS
--   Employee/Student translates to IsE orig (C <a>Workingstudent</a>) [C
--   <a>Employee</a>,C <a>Student</a>]
data A_Gen
Isa :: A_Concept -> A_Concept -> A_Gen

-- | specific concept
--   
--   specific concept
genspc :: A_Gen -> A_Concept

-- | generic concept
gengen :: A_Gen -> A_Concept
IsE :: A_Concept -> [A_Concept] -> A_Gen

-- | specific concept
--   
--   specific concept
genspc :: A_Gen -> A_Concept

-- | concepts of which the conjunction is equivalent to the specific
--   concept
genrhs :: A_Gen -> [A_Concept]
data Sign
Sign :: A_Concept -> A_Concept -> Sign
data ConceptDef
Cd :: Origin -> String -> Bool -> String -> String -> String -> String -> ConceptDef

-- | The position of this definition in the text of the Ampersand source
--   (filename, line number and column number).
cdpos :: ConceptDef -> Origin

-- | The name of the concept for which this is the definition. If there is
--   no such concept, the conceptdefinition is ignored.
cdcpt :: ConceptDef -> String

-- | Whether the user specifically told Ampersand not to store this concept
--   in the database
cdplug :: ConceptDef -> Bool

-- | The textual definition of this concept.
cddef :: ConceptDef -> String

-- | The (SQL) type of this concept.
cdtyp :: ConceptDef -> String

-- | A label meant to identify the source of the definition. (useful as
--   LaTeX' symbolic reference)
cdref :: ConceptDef -> String

-- | The name of the pattern or context in which this concept definition
--   was made
cdfrom :: ConceptDef -> String
class ConceptStructure a where relsUsedIn a = [d | d@(Sgn {}) <- relsMentionedIn a] ++ [Isn c | c <- concs a] relsMentionedIn = nub . map prim2rel . primsMentionedIn primsMentionedIn = nub . concatMap primitives . expressionsIn mp1Exprs = filter isMp1 . primsMentionedIn mp1Pops struc = [PCptPopu {popcpt = cpt (head cl), popas = map atm cl} | cl <- eqCl cpt (mp1Exprs struc)] where cpt (EMp1 _ c) = c cpt _ = fatal 31 "cpt error" atm (EMp1 a _) = a atm _ = fatal 31 "atm error"
concs :: ConceptStructure a => a -> [A_Concept]
relsUsedIn :: ConceptStructure a => a -> [Declaration]
relsMentionedIn :: ConceptStructure a => a -> [Declaration]
primsMentionedIn :: ConceptStructure a => a -> [Expression]
expressionsIn :: ConceptStructure a => a -> [Expression]
mp1Exprs :: ConceptStructure a => a -> [Expression]
mp1Pops :: ConceptStructure a => a -> [Population]
data Activity
Act :: Rule -> [Declaration] -> [Declaration] -> [Quad] -> [ECArule] -> [Purpose] -> Activity
actRule :: Activity -> Rule
actTrig :: Activity -> [Declaration]
actAffect :: Activity -> [Declaration]
actQuads :: Activity -> [Quad]
actEcas :: Activity -> [ECArule]
actPurp :: Activity -> [Purpose]
data AMeaning
AMeaning :: [A_Markup] -> AMeaning
ameaMrk :: AMeaning -> [A_Markup]
data Quad
Quad :: Declaration -> Clauses -> Quad
qDcl :: Quad -> Declaration
qClauses :: Quad -> Clauses
data RuleClause
RC :: Int -> String -> Expression -> [DnfClause] -> RuleClause
rc_int :: RuleClause -> Int
rc_rulename :: RuleClause -> String
rc_conjunct :: RuleClause -> Expression
rc_dnfClauses :: RuleClause -> [DnfClause]

-- | A list of ECA rules, which is used for automated functionality.
data Fswitchboard
Fswtch :: [Event] -> [Event] -> [(Rule, Expression)] -> [ECArule] -> Fswitchboard
fsbEvIn :: Fswitchboard -> [Event]
fsbEvOut :: Fswitchboard -> [Event]
fsbConjs :: Fswitchboard -> [(Rule, Expression)]
fsbECAs :: Fswitchboard -> [ECArule]
data ECArule
ECA :: Event -> Declaration -> PAclause -> Int -> ECArule
ecaTriggr :: ECArule -> Event
ecaDelta :: ECArule -> Declaration
ecaAction :: ECArule -> PAclause
ecaNum :: ECArule -> Int
data Event
On :: InsDel -> Declaration -> Event
eSrt :: Event -> InsDel
eDcl :: Event -> Declaration
data InsDel
Ins :: InsDel
Del :: InsDel
data Pattern
A_Pat :: String -> Origin -> Origin -> [Rule] -> [A_Gen] -> [Declaration] -> [Population] -> [(String, Rule)] -> [(String, Declaration)] -> [IdentityDef] -> [ViewDef] -> [Purpose] -> Pattern

-- | Name of this pattern
ptnm :: Pattern -> String

-- | the position in the file in which this pattern was declared.
ptpos :: Pattern -> Origin

-- | the end position in the file, elements with a position between pos and
--   end are elements of this pattern.
ptend :: Pattern -> Origin

-- | The user defined rules in this pattern
ptrls :: Pattern -> [Rule]

-- | The generalizations defined in this pattern
ptgns :: Pattern -> [A_Gen]

-- | The relations that are declared in this pattern
ptdcs :: Pattern -> [Declaration]

-- | The user defined populations in this pattern
ptups :: Pattern -> [Population]

-- | The assignment of roles to rules.
ptrruls :: Pattern -> [(String, Rule)]

-- | The assignment of roles to Relations.
ptrrels :: Pattern -> [(String, Declaration)]

-- | The identity definitions defined in this pattern
ptids :: Pattern -> [IdentityDef]

-- | The view definitions defined in this pattern
ptvds :: Pattern -> [ViewDef]

-- | The purposes of elements defined in this pattern
ptxps :: Pattern -> [Purpose]
data Declaration
Sgn :: String -> Sign -> [Prop] -> Maybe [Prop] -> String -> String -> String -> AMeaning -> Origin -> Bool -> Bool -> String -> Bool -> Declaration

-- | the name of the declaration
decnm :: Declaration -> String

-- | the source and target concepts of the declaration multiplicities
--   returns decprps_calc, when it has been calculated. So if you only need
--   the user defined properties do not use multiplicities but decprps
decsgn :: Declaration -> Sign

-- | the user defined multiplicity properties (Uni, Tot, Sur, Inj) and
--   algebraic properties (Sym, Asy, Trn, Rfx)
decprps :: Declaration -> [Prop]

-- | the calculated and user defined multiplicity properties (Uni, Tot,
--   Sur, Inj) and algebraic properties (Sym, Asy, Trn, Rfx, Irf). Note
--   that calculated properties are made by adl2fspec, so in the
--   A-structure decprps and decprps_calc yield exactly the same answer.
decprps_calc :: Declaration -> Maybe [Prop]

-- | three strings, which form the pragma. E.g. if pragma consists of the
--   three strings: <a>Person </a>, <a> is married to person </a>, and <a>
--   in Vegas.</a>
decprL :: Declaration -> String

-- | then a tuple (<a>Peter</a>,<a>Jane</a>) in the list of links means
--   that Person Peter is married to person Jane in Vegas.
decprM :: Declaration -> String
decprR :: Declaration -> String

-- | the meaning of a declaration, for each language supported by
--   Ampersand.
decMean :: Declaration -> AMeaning

-- | the position in the Ampersand source file where this declaration is
--   declared. Not all decalartions come from the ampersand souce file.
decfpos :: Declaration -> Origin

-- | if true, this is a signal relation; otherwise it is an ordinary
--   relation.
deciss :: Declaration -> Bool

-- | if true, this relation is declared by an author in the Ampersand
--   script; otherwise it was generated by Ampersand.
decusr :: Declaration -> Bool

-- | the pattern where this declaration has been declared.
decpat :: Declaration -> String

-- | if true, this relation may not be stored in or retrieved from the
--   standard database (it should be gotten from a Plug of some sort
--   instead)
decplug :: Declaration -> Bool
Isn :: A_Concept -> Declaration

-- | The type
detyp :: Declaration -> A_Concept
Vs :: Sign -> Declaration

-- | the source and target concepts of the declaration multiplicities
--   returns decprps_calc, when it has been calculated. So if you only need
--   the user defined properties do not use multiplicities but decprps
decsgn :: Declaration -> Sign
data IdentityDef
Id :: Origin -> String -> A_Concept -> [IdentitySegment] -> IdentityDef

-- | position of this definition in the text of the Ampersand source file
--   (filename, line number and column number).
idPos :: IdentityDef -> Origin

-- | the name (or label) of this Identity. The label has no meaning in the
--   Compliant Service Layer, but is used in the generated user interface.
--   It is not an empty string.
idLbl :: IdentityDef -> String

-- | this expression describes the instances of this object, related to
--   their context
idCpt :: IdentityDef -> A_Concept

-- | the constituent attributes (i.e. name/expression pairs) of this
--   identity.
identityAts :: IdentityDef -> [IdentitySegment]
data ViewDef
Vd :: Origin -> String -> A_Concept -> [ViewSegment] -> ViewDef

-- | position of this definition in the text of the Ampersand source file
--   (filename, line number and column number).
vdpos :: ViewDef -> Origin

-- | the name (or label) of this View. The label has no meaning in the
--   Compliant Service Layer, but is used in the generated user interface.
--   It is not an empty string.
vdlbl :: ViewDef -> String

-- | this expression describes the instances of this object, related to
--   their context
vdcpt :: ViewDef -> A_Concept

-- | the constituent attributes (i.e. name/expression pairs) of this view.
vdats :: ViewDef -> [ViewSegment]
data IdentitySegment
IdentityExp :: ObjectDef -> IdentitySegment
data ViewSegment
ViewExp :: ObjectDef -> ViewSegment
ViewText :: String -> ViewSegment
ViewHtml :: String -> ViewSegment
data Expression

-- | equivalence =
EEqu :: (Expression, Expression) -> Expression

-- | implication |-
EImp :: (Expression, Expression) -> Expression

-- | intersection /\
EIsc :: (Expression, Expression) -> Expression

-- | union /
EUni :: (Expression, Expression) -> Expression

-- | difference -
EDif :: (Expression, Expression) -> Expression

-- | left residual /
ELrs :: (Expression, Expression) -> Expression

-- | right residual \
ERrs :: (Expression, Expression) -> Expression

-- | diamond <a></a>
EDia :: (Expression, Expression) -> Expression

-- | composition ;
ECps :: (Expression, Expression) -> Expression

-- | relative addition !
ERad :: (Expression, Expression) -> Expression

-- | cartesian product *
EPrd :: (Expression, Expression) -> Expression

-- | Rfx.Trn closure * (Kleene star)
EKl0 :: Expression -> Expression

-- | Transitive closure + (Kleene plus)
EKl1 :: Expression -> Expression

-- | conversion (flip, wok) ~
EFlp :: Expression -> Expression

-- | Complement
ECpl :: Expression -> Expression

-- | bracketed expression ( ... )
EBrk :: Expression -> Expression

-- | simple declaration
EDcD :: Declaration -> Expression

-- | Identity relation
EDcI :: A_Concept -> Expression

-- | Epsilon relation (introduced by the system to ensure we compare
--   concepts by equality only.
EEps :: A_Concept -> Sign -> Expression

-- | Cartesian product relation
EDcV :: Sign -> Expression

-- | constant (string between single quotes)
EMp1 :: String -> A_Concept -> Expression
data Population
PRelPopu :: Declaration -> Pairs -> Population
popdcl :: Population -> Declaration
popps :: Population -> Pairs
PCptPopu :: A_Concept -> [String] -> Population
popcpt :: Population -> A_Concept
popas :: Population -> [String]
data Fspc
Fspc :: String -> [Origin] -> [String] -> [Pattern] -> [Process] -> [Rule] -> [Declaration] -> [A_Concept] -> [ConceptDef] -> [A_Gen] -> Lang -> [FProcess] -> [PlugInfo] -> [PlugInfo] -> [Interface] -> [Interface] -> Fswitchboard -> [Activity] -> [(String, Declaration)] -> [(String, Rule)] -> [String] -> [Rule] -> [Rule] -> [Rule] -> [Rule] -> [Declaration] -> [Declaration] -> [Declaration] -> [A_Concept] -> [[A_Concept]] -> [IdentityDef] -> [ViewDef] -> [A_Gen] -> [RuleClause] -> [Quad] -> [ECArule] -> [(A_Concept, A_Concept)] -> [Pattern] -> [ConceptDef] -> [Purpose] -> [Meta] -> [Population] -> [(Rule, [Paire])] -> Fspc

-- | The name of the specification, taken from the Ampersand script
fsName :: Fspc -> String

-- | The origin of the Fspc. An Fspc can be a merge of a file including
--   other files c.q. a list of Origin.
fspos :: Fspc -> [Origin]

-- | The names of patterns/processes to be printed in the functional
--   specification. (for making partial documentation)
themes :: Fspc -> [String]
pattsInScope :: Fspc -> [Pattern]
procsInScope :: Fspc -> [Process]
rulesInScope :: Fspc -> [Rule]
declsInScope :: Fspc -> [Declaration]
concsInScope :: Fspc -> [A_Concept]
cDefsInScope :: Fspc -> [ConceptDef]
gensInScope :: Fspc -> [A_Gen]

-- | The default language for this specification (always specified, so no
--   Maybe here!).
fsLang :: Fspc -> Lang

-- | All processes defined in the Ampersand script
vprocesses :: Fspc -> [FProcess]

-- | All plugs defined in the Ampersand script
vplugInfos :: Fspc -> [PlugInfo]

-- | All plugs (defined and derived)
plugInfos :: Fspc -> [PlugInfo]

-- | All interfaces defined in the Ampersand script
interfaceS :: Fspc -> [Interface]

-- | All interfaces derived from the basic ontology (the Lonneker
--   interface)
interfaceG :: Fspc -> [Interface]

-- | The code to be executed to maintain the truth of invariants
fSwitchboard :: Fspc -> Fswitchboard

-- | generated: One Activity for every ObjectDef in interfaceG and
--   interfaceS
fActivities :: Fspc -> [Activity]

-- | the relation saying which roles may change the population of which
--   relation.
fRoleRels :: Fspc -> [(String, Declaration)]

-- | the relation saying which roles may change the population of which
--   relation.
fRoleRuls :: Fspc -> [(String, Rule)]

-- | All roles mentioned in this context.
fRoles :: Fspc -> [String]

-- | All user defined rules that apply in the entire Fspc
vrules :: Fspc -> [Rule]

-- | All rules that are generated: multiplicity rules and identity rules
grules :: Fspc -> [Rule]

-- | All invariant rules
invars :: Fspc -> [Rule]

-- | All rules, both generated (from multiplicity and keys) as well as user
--   defined ones.
allRules :: Fspc -> [Rule]

-- | All relations that are used in the fSpec
allUsedDecls :: Fspc -> [Declaration]

-- | All relations that are declared in the fSpec
allDecls :: Fspc -> [Declaration]

-- | All user defined and generated relations plus all defined and computed
--   totals. The generated relations are all generalizations and one
--   declaration for each signal.
vrels :: Fspc -> [Declaration]

-- | All concepts in the fSpec
allConcepts :: Fspc -> [A_Concept]

-- | All concepts, grouped by their classifications
kernels :: Fspc -> [[A_Concept]]

-- | All keys that apply in the entire Fspc
vIndices :: Fspc -> [IdentityDef]

-- | All views that apply in the entire Fspc
vviews :: Fspc -> [ViewDef]

-- | All gens that apply in the entire Fspc
vgens :: Fspc -> [A_Gen]

-- | All conjuncts generated (by ADL2Fspec)
vconjs :: Fspc -> [RuleClause]

-- | All quads generated (by ADL2Fspec)
vquads :: Fspc -> [Quad]

-- | All ECA rules generated (by ADL2Fspec)
vEcas :: Fspc -> [ECArule]

-- | generated: The data structure containing the generalization structure
--   of concepts
fsisa :: Fspc -> [(A_Concept, A_Concept)]

-- | All patterns taken from the Ampersand script
vpatterns :: Fspc -> [Pattern]

-- | All concept definitions defined throughout a context, including those
--   inside patterns and processes
conceptDefs :: Fspc -> [ConceptDef]

-- | All purposes that have been declared at the top level of the current
--   specification, but not in the processes, patterns and interfaces.
fSexpls :: Fspc -> [Purpose]

-- | All meta relations from the entire context
metas :: Fspc -> [Meta]
initialPops :: Fspc -> [Population]
allViolations :: Fspc -> [(Rule, [Paire])]
concDefs :: Fspc -> A_Concept -> [ConceptDef]
data PlugSQL

-- | stores a related collection of relations: a kernel of concepts and
--   attribute relations of this kernel i.e. a list of SqlField given some
--   A -&gt; [target r | r::A*B,isUni r,isTot r, isInj r] ++ [target r |
--   r::A*B,isUni r, not(isTot r), not(isSur r)] kernel = A closure of
--   concepts A,B for which there exists a r::A-&gt;B[INJ] (r=fldexpr of
--   kernel field holding instances of B, in practice r is I or a
--   makeRelation(flipped declaration)) attribute relations = All concepts
--   B, A in kernel for which there exists a r::A*B[UNI] and r not TOT and
--   SUR (r=fldexpr of attMor field, in practice r is a
--   makeRelation(declaration))
TblSQL :: String -> [SqlField] -> [(A_Concept, SqlField)] -> [(Expression, SqlField, SqlField)] -> PlugSQL
sqlname :: PlugSQL -> String

-- | the first field is the concept table of the most general concept (e.g.
--   Person) then follow concept tables of specializations. Together with
--   the first field this is called the <a>kernel</a> the remaining fields
--   represent attributes.
fields :: PlugSQL -> [SqlField]

-- | lookup table that links all kernel concepts to fields in the plug
--   cLkpTbl is een lijst concepten die in deze plug opgeslagen zitten, en
--   hoe je ze eruit kunt halen
cLkpTbl :: PlugSQL -> [(A_Concept, SqlField)]

-- | lookup table that links concepts to column names in the plug
--   (kernel+attRels) mLkpTbl is een lijst met relaties die in deze plug
--   opgeslagen zitten, en hoe je ze eruit kunt halen
mLkpTbl :: PlugSQL -> [(Expression, SqlField, SqlField)]

-- | stores one relation r in two ordered columns i.e. a tuple of SqlField
--   -&gt; (source r,target r) with (fldexpr=I/r;r~, fldexpr=r) (note: if r
--   TOT then (I/r;r~ = I). Thus, the concept (source r) is stored in this
--   plug too) with tblcontents = [[Just x,Just y] |(x,y)&lt;-contents r].
--   Typical for BinSQL is that it has exactly two columns that are not
--   unique and may not contain NULL values
BinSQL :: String -> (SqlField, SqlField) -> [(A_Concept, SqlField)] -> Expression -> PlugSQL
sqlname :: PlugSQL -> String
columns :: PlugSQL -> (SqlField, SqlField)

-- | lookup table that links all kernel concepts to fields in the plug
--   cLkpTbl is een lijst concepten die in deze plug opgeslagen zitten, en
--   hoe je ze eruit kunt halen
cLkpTbl :: PlugSQL -> [(A_Concept, SqlField)]
mLkp :: PlugSQL -> Expression

-- | stores one concept c in one column i.e. a SqlField -&gt; c with
--   tblcontents = [[Just x] |(x,_)&lt;-contents c]. Typical for ScalarSQL
--   is that it has exactly one column that is unique and may not contain
--   NULL values i.e. fldexpr=I[c]
ScalarSQL :: String -> SqlField -> A_Concept -> PlugSQL
sqlname :: PlugSQL -> String
sqlColumn :: PlugSQL -> SqlField
cLkp :: PlugSQL -> A_Concept
data SqlField
Fld :: String -> Expression -> SqlType -> SqlFieldUsage -> Bool -> Bool -> SqlField
fldname :: SqlField -> String

-- | De target van de expressie geeft de waarden weer in de
--   SQL-tabel-kolom.
fldexpr :: SqlField -> Expression
fldtype :: SqlField -> SqlType
flduse :: SqlField -> SqlFieldUsage

-- | True if there can be empty field-values (intended for data dictionary
--   of DB-implementation)
fldnull :: SqlField -> Bool

-- | True if all field-values are unique? (intended for data dictionary of
--   DB-implementation)
flduniq :: SqlField -> Bool
data SqlType
SQLChar :: Int -> SqlType
SQLBlob :: SqlType
SQLPass :: SqlType
SQLSingle :: SqlType
SQLDouble :: SqlType
SQLText :: SqlType
SQLuInt :: Int -> SqlType
SQLsInt :: Int -> SqlType
SQLId :: SqlType
SQLVarchar :: Int -> SqlType
SQLBool :: SqlType
data PlugInfo
InternalPlug :: PlugSQL -> PlugInfo
ExternalPlug :: ObjectDef -> PlugInfo
data PAclause
CHC :: [PAclause] -> [(Expression, [Rule])] -> PAclause
paCls :: PAclause -> [PAclause]
paMotiv :: PAclause -> [(Expression, [Rule])]
GCH :: [(InsDel, Expression, PAclause)] -> [(Expression, [Rule])] -> PAclause
paGCls :: PAclause -> [(InsDel, Expression, PAclause)]
paMotiv :: PAclause -> [(Expression, [Rule])]
ALL :: [PAclause] -> [(Expression, [Rule])] -> PAclause
paCls :: PAclause -> [PAclause]
paMotiv :: PAclause -> [(Expression, [Rule])]
Do :: InsDel -> Declaration -> Expression -> [(Expression, [Rule])] -> PAclause
paSrt :: PAclause -> InsDel
paTo :: PAclause -> Declaration
paDelta :: PAclause -> Expression
paMotiv :: PAclause -> [(Expression, [Rule])]
New :: A_Concept -> (String -> PAclause) -> [(Expression, [Rule])] -> PAclause
paCpt :: PAclause -> A_Concept
paCl :: PAclause -> String -> PAclause
paMotiv :: PAclause -> [(Expression, [Rule])]
Rmv :: A_Concept -> (String -> PAclause) -> [(Expression, [Rule])] -> PAclause
paCpt :: PAclause -> A_Concept
paCl :: PAclause -> String -> PAclause
paMotiv :: PAclause -> [(Expression, [Rule])]
Nop :: [(Expression, [Rule])] -> PAclause
paMotiv :: PAclause -> [(Expression, [Rule])]
Blk :: [(Expression, [Rule])] -> PAclause
paMotiv :: PAclause -> [(Expression, [Rule])]
Let :: PAclause -> (PAclause -> PAclause) -> [(Expression, [Rule])] -> PAclause
paExpr :: PAclause -> PAclause
paBody :: PAclause -> PAclause -> PAclause
paMotiv :: PAclause -> [(Expression, [Rule])]
Ref :: String -> PAclause
paVar :: PAclause -> String
data Rule
Ru :: String -> Expression -> Origin -> AMeaning -> [A_Markup] -> Maybe (PairView Expression) -> Sign -> Maybe (Prop, Declaration) -> String -> RuleOrigin -> Bool -> Declaration -> Rule

-- | Name of this rule
rrnm :: Rule -> String

-- | The rule expression
rrexp :: Rule -> Expression

-- | Position in the Ampersand file
rrfps :: Rule -> Origin

-- | Ampersand generated meaning (for all known languages)
rrmean :: Rule -> AMeaning

-- | User-specified violation messages, possibly more than one, for
--   multiple languages.
rrmsg :: Rule -> [A_Markup]

-- | Custom presentation for violations, currently only in a single
--   language
rrviol :: Rule -> Maybe (PairView Expression)

-- | Allocated type
rrtyp :: Rule -> Sign

-- | The property, if this rule originates from a property on a Declaration
rrdcl :: Rule -> Maybe (Prop, Declaration)

-- | Name of pattern in which it was defined.
r_env :: Rule -> String

-- | Where does this rule come from?
r_usr :: Rule -> RuleOrigin

-- | True if this is a signal; False if it is an invariant
isSignal :: Rule -> Bool

-- | the signal relation
srrel :: Rule -> Declaration
data Process
Proc :: String -> Origin -> Origin -> [Rule] -> [A_Gen] -> [Declaration] -> [Population] -> [(String, Rule)] -> [(String, Declaration)] -> [IdentityDef] -> [ViewDef] -> [Purpose] -> Process
prcNm :: Process -> String
prcPos :: Process -> Origin

-- | the end position in the file, elements with a position between pos and
--   end are elements of this process.
prcEnd :: Process -> Origin
prcRules :: Process -> [Rule]
prcGens :: Process -> [A_Gen]
prcDcls :: Process -> [Declaration]

-- | The user defined populations in this process
prcUps :: Process -> [Population]

-- | The assignment of roles to rules.
prcRRuls :: Process -> [(String, Rule)]

-- | The assignment of roles to Relations.
prcRRels :: Process -> [(String, Declaration)]

-- | The identity definitions defined in this process
prcIds :: Process -> [IdentityDef]

-- | The view definitions defined in this process
prcVds :: Process -> [ViewDef]

-- | The motivations of elements defined in this process
prcXps :: Process -> [Purpose]
data FProcess
FProc :: Process -> [Activity] -> FProcess
fpProc :: FProcess -> Process
fpActivities :: FProcess -> [Activity]
data Prop

-- | univalent
Uni :: Prop

-- | injective
Inj :: Prop

-- | surjective
Sur :: Prop

-- | total
Tot :: Prop

-- | symmetric
Sym :: Prop

-- | antisymmetric
Asy :: Prop

-- | transitive
Trn :: Prop

-- | reflexive
Rfx :: Prop

-- | irreflexive
Irf :: Prop
data RuleOrigin
UserDefined :: RuleOrigin
Multiplicity :: RuleOrigin
Identity :: RuleOrigin
data Lang
Dutch :: Lang
English :: Lang
data SqlFieldUsage
TableKey :: Bool -> A_Concept -> SqlFieldUsage
ForeignKey :: A_Concept -> SqlFieldUsage
PlainAttr :: SqlFieldUsage
data DnfClause
Dnf :: [Expression] -> [Expression] -> DnfClause
data Clauses
Clauses :: [RuleClause] -> Rule -> Clauses
cl_conjNF :: Clauses -> [RuleClause]
cl_rule :: Clauses -> Rule

-- | This data constructor is able to hold all kind of information that is
--   useful to express what the user would like Ampersand to do.
data Options
Options :: Bool -> String -> String -> Bool -> Bool -> Bool -> Bool -> Bool -> String -> Bool -> String -> Bool -> String -> Maybe Int -> Maybe String -> Maybe FilePath -> FilePath -> FileFormat -> DocTheme -> Bool -> Bool -> Bool -> FspecFormat -> Bool -> Bool -> Bool -> Bool -> String -> String -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe Lang -> String -> FilePath -> String -> FilePath -> String -> FilePath -> LocalTime -> Bool -> Bool -> Bool -> String -> String -> String -> String -> ParserVersion -> Options
showVersion :: Options -> Bool
preVersion :: Options -> String
postVersion :: Options -> String
showHelp :: Options -> Bool
verboseP :: Options -> Bool
development :: Options -> Bool
validateSQL :: Options -> Bool
genPrototype :: Options -> Bool
dirPrototype :: Options -> String
allInterfaces :: Options -> Bool
dbName :: Options -> String
genAtlas :: Options -> Bool
namespace :: Options -> String
autoRefresh :: Options -> Maybe Int
testRule :: Options -> Maybe String
customCssFile :: Options -> Maybe FilePath
importfile :: Options -> FilePath
fileformat :: Options -> FileFormat
theme :: Options -> DocTheme
genXML :: Options -> Bool
genFspec :: Options -> Bool
diag :: Options -> Bool
fspecFormat :: Options -> FspecFormat
genGraphics :: Options -> Bool
genEcaDoc :: Options -> Bool
proofs :: Options -> Bool
haskell :: Options -> Bool
dirOutput :: Options -> String
outputfile :: Options -> String
crowfoot :: Options -> Bool
blackWhite :: Options -> Bool
doubleEdges :: Options -> Bool
showPredExpr :: Options -> Bool
noDiagnosis :: Options -> Bool
diagnosisOnly :: Options -> Bool
genLegalRefs :: Options -> Bool
genUML :: Options -> Bool
genFPAExcel :: Options -> Bool
genStaticFiles :: Options -> Bool
genBericht :: Options -> Bool
genMeat :: Options -> Bool
language :: Options -> Maybe Lang
dirExec :: Options -> String
ampersandDataDir :: Options -> FilePath
progrName :: Options -> String
fileName :: Options -> FilePath
baseName :: Options -> String
logName :: Options -> FilePath
genTime :: Options -> LocalTime
export2adl :: Options -> Bool
test :: Options -> Bool
includeRap :: Options -> Bool
pangoFont :: Options -> String
sqlHost :: Options -> String
sqlLogin :: Options -> String
sqlPwd :: Options -> String
parserVersion :: Options -> ParserVersion
data DocTheme
DefaultTheme :: DocTheme
ProofTheme :: DocTheme
StudentTheme :: DocTheme
StudentDesignerTheme :: DocTheme
DesignerTheme :: DocTheme
data Picture
Pict :: PictureReq -> String -> DotGraph String -> GraphvizCommand -> String -> Picture

-- | the type of the picture
pType :: Picture -> PictureReq

-- | a scale factor, intended to pass on to LaTeX, because Pandoc seems to
--   have a problem with scaling.
scale :: Picture -> String

-- | the string representing the .dot
dotSource :: Picture -> DotGraph String

-- | the name of the program to use (<a>dot</a> or <a>neato</a> or
--   <a>fdp</a> or <a>Sfdp</a>)
dotProgName :: Picture -> GraphvizCommand

-- | a human readable name of this picture
caption :: Picture -> String
writePicture :: Options -> Picture -> IO ()
data PictureReq
PTClassDiagram :: PictureReq
PTRelsUsedInPat :: Pattern -> PictureReq
PTDeclaredInPat :: Pattern -> PictureReq
PTProcess :: FProcess -> PictureReq
PTConcept :: A_Concept -> PictureReq
PTSwitchBoard :: Activity -> PictureReq
PTFinterface :: Activity -> PictureReq
PTIsaInPattern :: Pattern -> PictureReq
PTSingleRule :: Rule -> PictureReq
PTLogicalDM :: PictureReq
PTTechnicalDM :: PictureReq
makePicture :: Options -> Fspc -> PictureReq -> Picture
data FilePos
FilePos :: (String, Pos, String) -> FilePos
data Origin
OriginUnknown :: Origin
Origin :: String -> Origin
FileLoc :: FilePos -> Origin
DBLoc :: String -> Origin
data Pos
Pos :: !Line -> !Column -> Pos
data FPA
FPA :: FPtype -> FPcompl -> FPA
fpType :: FPA -> FPtype
complexity :: FPA -> FPcompl
data FPcompl
Eenvoudig :: FPcompl
Gemiddeld :: FPcompl
Moeilijk :: FPcompl
mkPair :: String -> String -> Paire
class Association rel where source x = source (sign x) target x = target (sign x) isEndo s = source s == target s
source, target :: Association rel => rel -> A_Concept
sign :: Association rel => rel -> Sign
isEndo :: Association rel => rel -> Bool
flp :: Flippable a => a -> a
class Collection a
eleM :: (Collection a, Eq b) => b -> a b -> Bool
uni, isc :: (Collection a, Eq b) => a b -> a b -> a b
(>-) :: (Collection a, Eq b) => a b -> a b -> a b
empty :: (Collection a, Eq b) => a b
elems :: (Collection a, Eq b) => a b -> [b]
class Identified a
name :: Identified a => a -> String
class ProcessStructure a where workFromProcessRules gens' udp x = [(r, viol) | r <- processRules x, viol <- ruleviolations gens' udp r]
processes :: ProcessStructure a => a -> [Process]
roles :: ProcessStructure a => a -> [String]
interfaces :: ProcessStructure a => a -> [Interface]
objDefs :: ProcessStructure a => a -> [ObjectDef]
processRules :: ProcessStructure a => a -> [Rule]
maintains :: ProcessStructure a => a -> [(String, Rule)]
mayEdit :: ProcessStructure a => a -> [(String, Declaration)]
workFromProcessRules :: ProcessStructure a => [A_Gen] -> [Population] -> a -> [(Rule, Paire)]
data ObjectDef
Obj :: String -> Origin -> Expression -> Maybe SubInterface -> [[String]] -> ObjectDef

-- | view name of the object definition. The label has no meaning in the
--   Compliant Service Layer, but is used in the generated user interface
--   if it is not an empty string.
objnm :: ObjectDef -> String

-- | position of this definition in the text of the Ampersand source file
--   (filename, line number and column number)
objpos :: ObjectDef -> Origin

-- | this expression describes the instances of this object, related to
--   their context.
objctx :: ObjectDef -> Expression

-- | the attributes, which are object definitions themselves.
objmsub :: ObjectDef -> Maybe SubInterface

-- | directives that specify the interface.
objstrs :: ObjectDef -> [[String]]
class Association r => Relational r where isFunction r = null ([Uni, Tot] >- multiplicities r) isTot r = Tot `elem` multiplicities r isUni r = Uni `elem` multiplicities r isSur r = Sur `elem` multiplicities r isInj r = Inj `elem` multiplicities r isRfx r = Rfx `elem` multiplicities r isIrf r = Irf `elem` multiplicities r isTrn r = Trn `elem` multiplicities r isSym r = Sym `elem` multiplicities r isAsy r = Asy `elem` multiplicities r
multiplicities :: Relational r => r -> [Prop]
isProp :: Relational r => r -> Bool
isImin :: Relational r => r -> Bool
isTrue :: Relational r => r -> Bool
isFalse :: Relational r => r -> Bool
isFunction :: Relational r => r -> Bool
isTot :: Relational r => r -> Bool
isUni :: Relational r => r -> Bool
isSur :: Relational r => r -> Bool
isInj :: Relational r => r -> Bool
isRfx :: Relational r => r -> Bool
isIrf :: Relational r => r -> Bool
isTrn :: Relational r => r -> Bool
isSym :: Relational r => r -> Bool
isAsy :: Relational r => r -> Bool
isIdent :: Relational r => r -> Bool
isEpsilon :: Relational r => r -> Bool
data Interface
Ifc :: [Expression] -> [[String]] -> [String] -> ObjectDef -> Origin -> String -> Interface
ifcParams :: Interface -> [Expression]
ifcArgs :: Interface -> [[String]]
ifcRoles :: Interface -> [String]
ifcObj :: Interface -> ObjectDef
ifcPos :: Interface -> Origin
ifcPrp :: Interface -> String
data SubInterface
Box :: A_Concept -> [ObjectDef] -> SubInterface
InterfaceRef :: String -> SubInterface
class Object a
concept :: Object a => a -> A_Concept
attributes :: Object a => a -> [ObjectDef]
contextOf :: Object a => a -> Expression
class (Identified p, Eq p, Show p) => Plugable p
makePlug :: Plugable p => PlugInfo -> p
class Identified a => Motivated a where purposeOf fSpec l x = case expls of { [] -> Nothing ps -> Just ps } where expls = [e | e <- explanations fSpec, explForObj x (explObj e), markupMatchesLang (explMarkup e)] markupMatchesLang m = amLang m == l purposesDefinedIn fSpec l x = [e | e <- explanations fSpec, amLang (explMarkup e) == l, explForObj x (explObj e)]
purposeOf :: Motivated a => Fspc -> Lang -> a -> Maybe [Purpose]
explForObj :: Motivated a => a -> ExplObj -> Bool
explanations :: Motivated a => a -> [Purpose]
purposesDefinedIn :: Motivated a => Fspc -> Lang -> a -> [Purpose]
class Traced a where filenm x = case origin x of { FileLoc (FilePos (nm, _, _)) -> nm _ -> "" } linenr x = case origin x of { FileLoc (FilePos (_, Pos l _, _)) -> l _ -> 0 } colnr x = case origin x of { FileLoc (FilePos (_, Pos _ c, _)) -> c _ -> 0 }
origin :: Traced a => a -> Origin
filenm :: Traced a => a -> String
linenr :: Traced a => a -> Int
colnr :: Traced a => a -> Int
class Language a where invariants x = [r | r <- udefrules x, not (isSignal r)] ++ multrules x ++ identityRules x multrules x = [rulefromProp p d | d <- relsDefdIn x, p <- multiplicities d] identityRules x = concatMap rulesFromIdentity (identities x)
objectdef :: Language a => a -> ObjectDef
relsDefdIn :: Language a => a -> [Declaration]
udefrules :: Language a => a -> [Rule]
invariants :: Language a => a -> [Rule]
multrules :: Language a => a -> [Rule]
identityRules :: Language a => a -> [Rule]
identities :: Language a => a -> [IdentityDef]
viewDefs :: Language a => a -> [ViewDef]
gens :: Language a => a -> [A_Gen]
patterns :: Language a => a -> [Pattern]
class FPAble a where fPoints x = fPoints' (fpa x) showFPA l x = showLang l (fpa x)
fpa :: FPAble a => a -> FPA
fPoints :: FPAble a => a -> Int
showFPA :: FPAble a => Lang -> a -> String
class ShowHS a
showHS :: ShowHS a => Options -> String -> a -> String
class ShowHSName a
showHSName :: ShowHSName a => a -> String
haskellIdentifier :: String -> String

-- | Is comparable to.
(<==>) :: Poset a => a -> a -> Bool
meet :: Sortable a => a -> a -> a
join :: Sortable a => a -> a -> a
sortWith :: (Show b, Poset b) => (b -> [[b]], [b]) -> (a -> b) -> [a] -> [a]

-- | This function returns the atoms of a concept (like fullContents does
--   for relation-like things.)
atomsOf :: [A_Gen] -> [Population] -> A_Concept -> [String]

-- | this function takes all generalisation relations from the context and
--   a concept and delivers a list of all concepts that are more specific
--   than the given concept. If there are no cycles in the generalization
--   graph, cpt cannot be an element of smallerConcepts gens cpt.
smallerConcepts :: [A_Gen] -> A_Concept -> [A_Concept]

-- | this function takes all generalisation relations from the context and
--   a concept and delivers a list of all concepts that are more generic
--   than the given concept.
largerConcepts :: [A_Gen] -> A_Concept -> [A_Concept]

-- | this function returns the most generic concepts in the class of a
--   given concept
rootConcepts :: [A_Gen] -> [A_Concept] -> [A_Concept]
conjNF :: Expression -> Expression
disjNF :: Expression -> Expression
simplify :: Expression -> Expression
cfProof :: (Expression -> String) -> Expression -> Proof Expression
dfProof :: (Expression -> String) -> Expression -> Proof Expression
nfProof :: (Expression -> String) -> Expression -> Proof Expression
normPA :: PAclause -> PAclause

-- | This returns all column<i>table pairs that serve as a concept table
--   for cpt. When adding</i>removing atoms, all of these columns need to
--   be updated
lookupCpt :: Fspc -> A_Concept -> [(PlugSQL, SqlField)]
showPrf :: (expr -> String) -> Proof expr -> [String]
notCpl :: Expression -> Expression
isCpl :: Expression -> Bool
isPos :: Expression -> Bool
isNeg :: Expression -> Bool
foldrMapExpression :: (r -> a -> a) -> (Declaration -> r) -> a -> Expression -> a
(.==.) :: Expression -> Expression -> Expression
(.|-.) :: Expression -> Expression -> Expression
(./\.) :: Expression -> Expression -> Expression
(.\/.) :: Expression -> Expression -> Expression
(.-.) :: Expression -> Expression -> Expression
(./.) :: Expression -> Expression -> Expression
(.\.) :: Expression -> Expression -> Expression
(.<>.) :: Expression -> Expression -> Expression
(.:.) :: Expression -> Expression -> Expression
(.!.) :: Expression -> Expression -> Expression
(.*.) :: Expression -> Expression -> Expression

-- | The rule of De Morgan requires care with respect to the complement.
--   The following function provides a function to manipulate with De
--   Morgan correctly.
deMorganERad :: Expression -> Expression
deMorganECps :: Expression -> Expression
deMorganEUni :: Expression -> Expression
deMorganEIsc :: Expression -> Expression
exprUni2list :: Expression -> [Expression]
exprIsc2list :: Expression -> [Expression]
exprCps2list :: Expression -> [Expression]
exprRad2list :: Expression -> [Expression]
exprPrd2list :: Expression -> [Expression]
plugFields :: PlugSQL -> [SqlField]
tblcontents :: [A_Gen] -> [Population] -> PlugSQL -> [TblRecord]
plugpath :: PlugSQL -> SqlField -> SqlField -> Maybe Expression
fldauto :: SqlField -> Bool
requires :: PlugSQL -> (SqlField, SqlField) -> Bool
requiredFields :: PlugSQL -> SqlField -> [SqlField]
isPlugIndex :: PlugSQL -> SqlField -> Bool

-- | Parse isolated ADL1 expression strings
parseADL1pExpr :: String -> String -> Either String (Term TermPrim)
data CtxError

-- | create an Fspec, based on the user defined flags.
createFspec :: Options -> IO (Guarded Fspc)
getGeneralizations :: Fspc -> A_Concept -> [A_Concept]
getSpecializations :: Fspc -> A_Concept -> [A_Concept]
data Guarded a
Errors :: [CtxError] -> Guarded a
Checked :: a -> Guarded a
pCtx2aCtx :: P_Context -> Guarded A_Context
makeFspec :: Options -> A_Context -> Fspc
generateAmpersandOutput :: Options -> Fspc -> IO ()
class ShowADL a
showADL :: ShowADL a => a -> String
showSQL :: SqlType -> String
showSign :: Association a => a -> String
getOptions :: IO Options
verboseLn :: Options -> String -> IO ()
verbose :: Options -> String -> IO ()
data FileFormat
Adl1Format :: FileFormat
Adl1PopFormat :: FileFormat
helpNVersionTexts :: String -> Options -> [String]

-- | eqCl is a very useful function for gathering things that are equal wrt
--   some criterion f. For instance, if you want to have persons with the
--   same name: 'eqCl name persons' produces a list,in which each element
--   is a list of persons with the same name.
eqCl :: Eq b => (a -> b) -> [a] -> [[a]]
showErr :: CtxError -> String

-- | Converts the first character of a string to lowercase, with the
--   exception that there is a second character, which is uppercase. uncap
--   <a>AbcDe</a> == <a>abcDe</a> uncap <a>ABcDE</a> == <a>ABcDE</a>
unCap :: String -> String

-- | Converts the first character of a string to uppercase
upCap :: String -> String

-- | escape anything except regular characters and digits to _<a>code</a>
--   e.g. escapeNonAlphaNum <a>a_</a> = <a>a_95_233</a>
escapeNonAlphaNum :: String -> String

-- | a function to create error message in a structured way, containing the
--   version of Ampersand. It throws an error, showing a (module)name and a
--   number. This makes debugging pretty easy.
fatalMsg :: String -> Int -> String -> a

-- | String, containing the Ampersand version, including the build
--   timestamp.
ampersandVersionStr :: String

-- | String, containing the Ampersand version
ampersandVersionWithoutBuildTimeStr :: String
putStr :: String -> IO ()
hGetContents :: Handle -> IO String
hPutStr :: Handle -> String -> IO ()
hPutStrLn :: Handle -> String -> IO ()
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
data A_Markup
A_Markup :: Lang -> PandocFormat -> [Block] -> A_Markup
amLang :: A_Markup -> Lang
amFormat :: A_Markup -> PandocFormat
amPandoc :: A_Markup -> [Block]

-- | write [Block] as String in a certain format using defaultWriterOptions
blocks2String :: PandocFormat -> Bool -> [Block] -> String
aMarkup2String :: A_Markup -> String
data PandocFormat
HTML :: PandocFormat
ReST :: PandocFormat
LaTeX :: PandocFormat
Markdown :: PandocFormat
class Meaning a where meaning2Blocks l a = case meaning l a of { Nothing -> [] Just m -> amPandoc m }
meaning :: Meaning a => Lang -> a -> Maybe A_Markup
meaning2Blocks :: Meaning a => Lang -> a -> [Block]
rulefromProp :: Prop -> Declaration -> Rule
fullContents :: [A_Gen] -> [Population] -> Expression -> Pairs
type Paire = (String, String)
srcPaire :: Paire -> String
trgPaire :: Paire -> String

-- | Explanation is the intended constructor. It explains the purpose of
--   the object it references. The enrichment process of the parser must
--   map the names (from PPurpose) to the actual objects
data Purpose
Expl :: Origin -> ExplObj -> A_Markup -> Bool -> [String] -> Purpose

-- | The position in the Ampersand script of this purpose definition
explPos :: Purpose -> Origin

-- | The object that is explained.
explObj :: Purpose -> ExplObj

-- | This field contains the text of the explanation including language and
--   markup info.
explMarkup :: Purpose -> A_Markup

-- | Is this purpose defined in the script?
explUserdefd :: Purpose -> Bool

-- | The references of the explaination
explRefIds :: Purpose -> [String]
data ExplObj
ExplConceptDef :: ConceptDef -> ExplObj
ExplDeclaration :: Declaration -> ExplObj
ExplRule :: String -> ExplObj
ExplIdentityDef :: String -> ExplObj
ExplViewDef :: String -> ExplObj
ExplPattern :: String -> ExplObj
ExplProcess :: String -> ExplObj
ExplInterface :: String -> ExplObj
ExplContext :: String -> ExplObj
