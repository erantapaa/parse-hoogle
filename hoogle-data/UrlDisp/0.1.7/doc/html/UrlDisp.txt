-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Url dispatcher. Helps to retain friendly URLs in web applications.
--   
--   The aim of urldisp is to provide a simple, declarative and expressive
--   URL routing in web applications.
@package UrlDisp
@version 0.1.7


-- | URL dispatching (routing) library, based on Sterling Clover's HVAC.
module Network.UrlDisp
data UrlDisp m a
data UrlS

-- | A null CGI action, used to begin a string of path combinators
h :: MonadCGI m => m ()

-- | Combinator that filters on and consumes the next element of the url
--   path. <tt> h |/ "dir" |/ "subdir" </tt> will match "/dir/subdir".
--   Consumtion of the path element backtracks on failure.
(|/) :: (MonadState UrlS m, Alternative m) => m a -> String -> m ()

-- | Combinator that filters on the request method. <tt> h |// "GET" </tt>
--   will match requests made using get.
(|//) :: (MonadCGI m, Alternative m) => m a -> String -> m ()

-- | Combinator that filters on any parameter (via put or get). <tt> h |?
--   ("cmd","foo") </tt> will match on ?cmd=foo
(|?) :: (MonadCGI m, Alternative m) => m a -> (String, String) -> m ()

-- | Combinator that matches and consumes the next element of the path if
--   path element can be successfully read as the proper type and passed to
--   the following lambda expression. <tt> h |\ \x -&gt; output (x +
--   (1.5::Float)) </tt> will match on "/12" and output "13.5". Consumption
--   of the path element backtracks on failure.
(|\) :: (Read x, MonadState UrlS m, Alternative m) => m a -> (x -> m b) -> m b

-- | Combinator that consumes the next element of the path and passes it as
--   an unparsed string into the following lambda expression. <tt> h |\\ \x
--   -&gt; output (x++"99") </tt> will match on "/12" and output "1299"
--   Consumtion of the path element backtracks on failure.
(|\\) :: (MonadState UrlS m, Alternative m) => m a -> (String -> m b) -> m b

-- | Combinator that only matches if the remaining path is empty.
(|.) :: (MonadState UrlS m, Alternative m) => m a -> m b -> m b

-- | Filters on and consumes the next element of the url path. <tt> path
--   "str" </tt> will match requests whose next path element is "str"
--   Consumption of the path element backtracks on failure.
path :: (MonadState UrlS m, Alternative m) => String -> m ()

-- | Filters on the request method. <tt> meth "GET" </tt> will match
--   requests made using get.
meth :: (MonadCGI m, Alternative m) => String -> m ()

-- | Filters on any parameter (via put or get). <tt> param ("cmd", "foo")
--   </tt> will match on ?cmd=foo
param :: (MonadCGI m, Alternative m) => (String, String) -> m ()

-- | Combinator that consumes the next element of the path and passes it as
--   an unparsed string into the following lambda expression. <tt> h
--   <a>takePath</a> \x -&gt; output (x++"99") </tt> will match on "/12"
--   and output "1299" Consumption of the path element backtracks on
--   failure.
takePath :: (MonadState UrlS m, Alternative m) => m String

-- | Matches and consumes the next element of the path if that element can
--   be successfully read as the proper type. The parsed element is
--   returned.
readPath :: (Read a, MonadState UrlS m, Alternative m) => m a

-- | Only matches if the remaining path is empty.
endPath :: (MonadState UrlS m, Alternative m) => m ()

-- | Given path and a sequence of actions chained using combinators defined
--   in controller API, run them in the CGI monad.
runUrlDisp :: MonadCGI m => String -> UrlDisp m a -> m (Maybe a)

-- | The same as runUrlDisp, but yields CGIResult. If URL dispatching
--   failed, then a 404 not found error is returned.
evalUrlDisp :: (MonadCGI m, MonadIO m) => UrlDisp m CGIResult -> m CGIResult
