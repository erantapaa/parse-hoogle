-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for manipulating Curry programs
--   
--   This package serves as a foundation for Curry compilers. it defines
--   the intermediate formats FlatCurry and ExtendedFlat. Additionally, it
--   provides functionality for the smooth integration of compiler
--   frontends and backends.
@package curry-base
@version 0.2.7

module Curry.Files.Filenames
lcurryExt :: String
icurryExt :: String
oExt :: String
curryExt :: String
moduleExts :: [String]
objectExts :: [String]
sourceExts :: [String]
interfName :: FilePath -> FilePath
flatName :: FilePath -> FilePath
extFlatName :: FilePath -> FilePath
flatIntName :: FilePath -> FilePath
xmlName :: FilePath -> FilePath
acyName :: FilePath -> FilePath
uacyName :: FilePath -> FilePath
sourceRepName :: FilePath -> FilePath
objectName :: Bool -> FilePath -> FilePath

module Curry.Base.Position
newtype SrcRef
SrcRef :: [Int] -> SrcRef
noRef :: SrcRef
incSrcRef :: SrcRef -> Int -> SrcRef
data Position
Position :: FilePath -> Int -> Int -> SrcRef -> Position
file :: Position -> FilePath
line :: Position -> Int
column :: Position -> Int
astRef :: Position -> SrcRef
AST :: SrcRef -> Position
astRef :: Position -> SrcRef
NoPos :: Position
incPosition :: Position -> Int -> Position
tabWidth :: Int
first :: FilePath -> Position
incr :: Position -> Int -> Position
next :: Position -> Position
tab :: Position -> Position
nl :: Position -> Position
showLine :: Position -> String
class SrcRefOf a
srcRefsOf :: (SrcRefOf a) => a -> [SrcRef]
srcRefOf :: (SrcRefOf a) => a -> SrcRef
instance Typeable Position
instance Typeable SrcRef
instance Eq Position
instance Ord Position
instance Data Position
instance Data SrcRef
instance SrcRefOf Position
instance Show Position
instance Read Position
instance Ord SrcRef
instance Eq SrcRef
instance Read SrcRef
instance Show SrcRef

module Curry.Base.Ident
data Ident
Ident :: Position -> String -> Int -> Ident
positionOfIdent :: Ident -> Position
name :: Ident -> String
uniqueId :: Ident -> Int
showIdent :: Ident -> String
data QualIdent
QualIdent :: Maybe ModuleIdent -> Ident -> QualIdent
qualidMod :: QualIdent -> Maybe ModuleIdent
qualidId :: QualIdent -> Ident
data ModuleIdent
ModuleIdent :: Position -> [String] -> ModuleIdent
positionOfModuleIdent :: ModuleIdent -> Position
moduleQualifiers :: ModuleIdent -> [String]
class SrcRefOf a
srcRefsOf :: (SrcRefOf a) => a -> [SrcRef]
srcRefOf :: (SrcRefOf a) => a -> SrcRef
mkIdent :: String -> Ident
qualName :: QualIdent -> String
renameIdent :: Ident -> Int -> Ident
unRenameIdent :: Ident -> Ident
mkMIdent :: [String] -> ModuleIdent
moduleName :: ModuleIdent -> String
isInfixOp :: Ident -> Bool
isQInfixOp :: QualIdent -> Bool
qualify :: Ident -> QualIdent
qualifyWith :: ModuleIdent -> Ident -> QualIdent
qualQualify :: ModuleIdent -> QualIdent -> QualIdent
isQualified :: QualIdent -> Bool
unqualify :: QualIdent -> Ident
qualUnqualify :: ModuleIdent -> QualIdent -> QualIdent
localIdent :: ModuleIdent -> QualIdent -> Maybe Ident
emptyMIdent :: ModuleIdent
mainMIdent :: ModuleIdent
preludeMIdent :: ModuleIdent
anonId :: Ident
unitId :: Ident
boolId :: Ident
charId :: Ident
intId :: Ident
floatId :: Ident
listId :: Ident
ioId :: Ident
successId :: Ident
trueId :: Ident
falseId :: Ident
nilId :: Ident
consId :: Ident
mainId :: Ident
tupleId :: Int -> Ident
isTupleId :: Ident -> Bool
tupleArity :: Ident -> Int
minusId :: Ident
fminusId :: Ident
updIdentName :: (String -> String) -> Ident -> Ident
qUnitId :: QualIdent
qBoolId :: QualIdent
qCharId :: QualIdent
qIntId :: QualIdent
qFloatId :: QualIdent
qListId :: QualIdent
qIOId :: QualIdent
qSuccessId :: QualIdent
qTrueId :: QualIdent
qFalseId :: QualIdent
qNilId :: QualIdent
qConsId :: QualIdent
qTupleId :: Int -> QualIdent
isQTupleId :: QualIdent -> Bool
qTupleArity :: QualIdent -> Int
fpSelectorId :: Int -> Ident
isFpSelectorId :: Ident -> Bool
isQualFpSelectorId :: QualIdent -> Bool
recSelectorId :: QualIdent -> Ident -> Ident
qualRecSelectorId :: ModuleIdent -> QualIdent -> Ident -> QualIdent
recUpdateId :: QualIdent -> Ident -> Ident
qualRecUpdateId :: ModuleIdent -> QualIdent -> Ident -> QualIdent
recordExtId :: Ident -> Ident
labelExtId :: Ident -> Ident
isRecordExtId :: Ident -> Bool
isLabelExtId :: Ident -> Bool
fromRecordExtId :: Ident -> Ident
fromLabelExtId :: Ident -> Ident
renameLabel :: Ident -> Ident
recordExt :: String
labelExt :: String
mkLabelIdent :: String -> Ident
addPositionIdent :: Position -> Ident -> Ident
addPositionModuleIdent :: Position -> ModuleIdent -> ModuleIdent
addRef :: SrcRef -> QualIdent -> QualIdent
addRefId :: SrcRef -> Ident -> Ident
positionOfQualIdent :: QualIdent -> Position
updQualIdent :: (ModuleIdent -> ModuleIdent) -> (Ident -> Ident) -> QualIdent -> QualIdent
instance Typeable ModuleIdent
instance Typeable QualIdent
instance Typeable Ident
instance Read ModuleIdent
instance Data ModuleIdent
instance Eq QualIdent
instance Ord QualIdent
instance Read QualIdent
instance Data QualIdent
instance Read Ident
instance Data Ident
instance SrcRefOf QualIdent
instance SrcRefOf Ident
instance Show ModuleIdent
instance Ord ModuleIdent
instance Eq ModuleIdent
instance Show QualIdent
instance Show Ident
instance Ord Ident
instance Eq Ident

module Curry.Files.PathUtils

-- | Get the base name, without an extension or path.
--   
--   <tt> takeBaseName "file/test.txt" == "test" takeBaseName "dave.ext" ==
--   "dave" takeBaseName "" == "" takeBaseName "test" == "test"
--   takeBaseName (addTrailingPathSeparator x) == "" takeBaseName
--   "file/file.tar.gz" == "file.tar" </tt>
takeBaseName :: FilePath -> String

-- | Remove last extension, and the "." preceding it.
--   
--   <tt> dropExtension x == fst (splitExtension x) </tt>
dropExtension :: FilePath -> FilePath

-- | Get the extension of a file, returns <tt>""</tt> for no extension,
--   <tt>.ext</tt> otherwise.
--   
--   <tt> takeExtension x == snd (splitExtension x) Valid x =&gt;
--   takeExtension (addExtension x "ext") == ".ext" Valid x =&gt;
--   takeExtension (replaceExtension x "ext") == ".ext" </tt>
takeExtension :: FilePath -> String
lookupModule :: [FilePath] -> [FilePath] -> ModuleIdent -> IO (Maybe FilePath)
lookupFile :: [FilePath] -> [String] -> String -> IO (Maybe FilePath)
lookupInterface :: [FilePath] -> ModuleIdent -> IO (Maybe FilePath)
getCurryPath :: [FilePath] -> FilePath -> IO (Maybe FilePath)
writeModule :: Bool -> FilePath -> String -> IO ()
readModule :: FilePath -> IO String
doesModuleExist :: FilePath -> IO Bool
maybeReadModule :: FilePath -> IO (Maybe String)
getModuleModTime :: FilePath -> IO ClockTime

module Curry.FlatCurry.Type
data Prog
Prog :: String -> [String] -> [TypeDecl] -> [FuncDecl] -> [OpDecl] -> Prog
type QName = (String, String)
data Visibility
Public :: Visibility
Private :: Visibility
type TVarIndex = Int
data TypeDecl
Type :: QName -> Visibility -> [TVarIndex] -> [ConsDecl] -> TypeDecl
TypeSyn :: QName -> Visibility -> [TVarIndex] -> TypeExpr -> TypeDecl
data ConsDecl
Cons :: QName -> Int -> Visibility -> [TypeExpr] -> ConsDecl
data TypeExpr
TVar :: TVarIndex -> TypeExpr
FuncType :: TypeExpr -> TypeExpr -> TypeExpr
TCons :: QName -> [TypeExpr] -> TypeExpr
data OpDecl
Op :: QName -> Fixity -> Int -> OpDecl
data Fixity
InfixOp :: Fixity
InfixlOp :: Fixity
InfixrOp :: Fixity
type VarIndex = Int
data FuncDecl
Func :: QName -> Int -> Visibility -> TypeExpr -> Rule -> FuncDecl
data Rule
Rule :: [VarIndex] -> Expr -> Rule
External :: String -> Rule
data CaseType
Rigid :: CaseType
Flex :: CaseType
data CombType
FuncCall :: CombType
ConsCall :: CombType
FuncPartCall :: Int -> CombType
ConsPartCall :: Int -> CombType
data Expr
Var :: VarIndex -> Expr
Lit :: Literal -> Expr
Comb :: CombType -> QName -> [Expr] -> Expr
Free :: [VarIndex] -> Expr -> Expr
Let :: [(VarIndex, Expr)] -> Expr -> Expr
Or :: Expr -> Expr -> Expr
Case :: CaseType -> Expr -> [BranchExpr] -> Expr
data BranchExpr
Branch :: Pattern -> Expr -> BranchExpr
data Pattern
Pattern :: QName -> [VarIndex] -> Pattern
LPattern :: Literal -> Pattern
data Literal
Intc :: Integer -> Literal
Floatc :: Double -> Literal
Charc :: Char -> Literal
readFlatCurry :: FilePath -> IO (Maybe Prog)
readFlatInterface :: String -> IO (Maybe Prog)
readFlat :: FilePath -> IO (Maybe Prog)
writeFlatCurry :: Bool -> String -> Prog -> IO ()
instance Read Literal
instance Show Literal
instance Eq Literal
instance Read Pattern
instance Show Pattern
instance Eq Pattern
instance Read BranchExpr
instance Show BranchExpr
instance Eq BranchExpr
instance Read Expr
instance Show Expr
instance Eq Expr
instance Read CombType
instance Show CombType
instance Eq CombType
instance Read CaseType
instance Show CaseType
instance Eq CaseType
instance Read Rule
instance Show Rule
instance Eq Rule
instance Read FuncDecl
instance Show FuncDecl
instance Eq FuncDecl
instance Read Fixity
instance Show Fixity
instance Eq Fixity
instance Read OpDecl
instance Show OpDecl
instance Eq OpDecl
instance Read TypeExpr
instance Show TypeExpr
instance Eq TypeExpr
instance Read ConsDecl
instance Show ConsDecl
instance Eq ConsDecl
instance Read TypeDecl
instance Show TypeDecl
instance Eq TypeDecl
instance Read Visibility
instance Show Visibility
instance Eq Visibility
instance Read Prog
instance Show Prog
instance Eq Prog

module Curry.FlatCurry.Goodies
failed :: a
type Update a b = (b -> b) -> a -> a
trProg :: (String -> [String] -> [TypeDecl] -> [FuncDecl] -> [OpDecl] -> a) -> Prog -> a
progName :: Prog -> String
progImports :: Prog -> [String]
progTypes :: Prog -> [TypeDecl]
progFuncs :: Prog -> [FuncDecl]
progOps :: Prog -> [OpDecl]
updProg :: (String -> String) -> ([String] -> [String]) -> ([TypeDecl] -> [TypeDecl]) -> ([FuncDecl] -> [FuncDecl]) -> ([OpDecl] -> [OpDecl]) -> Prog -> Prog
updProgName :: Update Prog String
updProgImports :: Update Prog [String]
updProgTypes :: Update Prog [TypeDecl]
updProgFuncs :: Update Prog [FuncDecl]
updProgOps :: Update Prog [OpDecl]
allVarsInProg :: Prog -> [VarIndex]
updProgExps :: Update Prog Expr
rnmAllVarsInProg :: Update Prog VarIndex
updQNamesInProg :: Update Prog QName
rnmProg :: String -> Prog -> Prog
trType :: (QName -> Visibility -> [TVarIndex] -> [ConsDecl] -> a) -> (QName -> Visibility -> [TVarIndex] -> TypeExpr -> a) -> TypeDecl -> a
typeName :: TypeDecl -> QName
typeVisibility :: TypeDecl -> Visibility
typeParams :: TypeDecl -> [TVarIndex]
typeConsDecls :: TypeDecl -> [ConsDecl]
typeSyn :: TypeDecl -> TypeExpr
isTypeSyn :: TypeDecl -> Bool
isDataTypeDecl :: TypeDecl -> Bool
isExternalType :: TypeDecl -> Bool
updType :: (QName -> QName) -> (Visibility -> Visibility) -> ([TVarIndex] -> [TVarIndex]) -> ([ConsDecl] -> [ConsDecl]) -> (TypeExpr -> TypeExpr) -> TypeDecl -> TypeDecl
updTypeName :: Update TypeDecl QName
updTypeVisibility :: Update TypeDecl Visibility
updTypeParams :: Update TypeDecl [TVarIndex]
updTypeConsDecls :: Update TypeDecl [ConsDecl]
updTypeSynonym :: Update TypeDecl TypeExpr
updQNamesInType :: Update TypeDecl QName
trCons :: (QName -> Int -> Visibility -> [TypeExpr] -> a) -> ConsDecl -> a
consName :: ConsDecl -> QName
consArity :: ConsDecl -> Int
consVisibility :: ConsDecl -> Visibility
consArgs :: ConsDecl -> [TypeExpr]
updCons :: (QName -> QName) -> (Int -> Int) -> (Visibility -> Visibility) -> ([TypeExpr] -> [TypeExpr]) -> ConsDecl -> ConsDecl
updConsName :: Update ConsDecl QName
updConsArity :: Update ConsDecl Int
updConsVisibility :: Update ConsDecl Visibility
updConsArgs :: Update ConsDecl [TypeExpr]
updQNamesInConsDecl :: Update ConsDecl QName
tVarIndex :: TypeExpr -> TVarIndex
domain :: TypeExpr -> TypeExpr
range :: TypeExpr -> TypeExpr
tConsName :: TypeExpr -> QName
tConsArgs :: TypeExpr -> [TypeExpr]
trTypeExpr :: (TVarIndex -> a) -> (QName -> [a] -> a) -> (a -> a -> a) -> TypeExpr -> a
isTVar :: TypeExpr -> Bool
isTCons :: TypeExpr -> Bool
isFuncType :: TypeExpr -> Bool
updTVars :: (TVarIndex -> TypeExpr) -> TypeExpr -> TypeExpr
updTCons :: (QName -> [TypeExpr] -> TypeExpr) -> TypeExpr -> TypeExpr
updFuncTypes :: (TypeExpr -> TypeExpr -> TypeExpr) -> TypeExpr -> TypeExpr
argTypes :: TypeExpr -> [TypeExpr]
resultType :: TypeExpr -> TypeExpr
allVarsInTypeExpr :: TypeExpr -> [TVarIndex]
rnmAllVarsInTypeExpr :: (TVarIndex -> TVarIndex) -> TypeExpr -> TypeExpr
updQNamesInTypeExpr :: (QName -> QName) -> TypeExpr -> TypeExpr
trOp :: (QName -> Fixity -> Int -> a) -> OpDecl -> a
opName :: OpDecl -> QName
opFixity :: OpDecl -> Fixity
opPrecedence :: OpDecl -> Int
updOp :: (QName -> QName) -> (Fixity -> Fixity) -> (Int -> Int) -> OpDecl -> OpDecl
updOpName :: Update OpDecl QName
updOpFixity :: Update OpDecl Fixity
updOpPrecedence :: Update OpDecl Int
trFunc :: (QName -> Int -> Visibility -> TypeExpr -> Rule -> a) -> FuncDecl -> a
funcName :: FuncDecl -> QName
funcArity :: FuncDecl -> Int
funcVisibility :: FuncDecl -> Visibility
funcType :: FuncDecl -> TypeExpr
funcRule :: FuncDecl -> Rule
updFunc :: (QName -> QName) -> (Int -> Int) -> (Visibility -> Visibility) -> (TypeExpr -> TypeExpr) -> (Rule -> Rule) -> FuncDecl -> FuncDecl
updFuncName :: Update FuncDecl QName
updFuncArity :: Update FuncDecl Int
updFuncVisibility :: Update FuncDecl Visibility
updFuncType :: Update FuncDecl TypeExpr
updFuncRule :: Update FuncDecl Rule
isExternal :: FuncDecl -> Bool
allVarsInFunc :: FuncDecl -> [VarIndex]
funcArgs :: FuncDecl -> [VarIndex]
funcBody :: FuncDecl -> Expr
funcRHS :: FuncDecl -> [Expr]
rnmAllVarsInFunc :: Update FuncDecl VarIndex
updQNamesInFunc :: Update FuncDecl QName
updFuncArgs :: Update FuncDecl [VarIndex]
updFuncBody :: Update FuncDecl Expr
trRule :: ([VarIndex] -> Expr -> a) -> (String -> a) -> Rule -> a
ruleArgs :: Rule -> [VarIndex]
ruleBody :: Rule -> Expr
ruleExtDecl :: Rule -> String
isRuleExternal :: Rule -> Bool
updRule :: ([VarIndex] -> [VarIndex]) -> (Expr -> Expr) -> (String -> String) -> Rule -> Rule
updRuleArgs :: Update Rule [VarIndex]
updRuleBody :: Update Rule Expr
updRuleExtDecl :: Update Rule String
allVarsInRule :: Rule -> [VarIndex]
rnmAllVarsInRule :: Update Rule VarIndex
updQNamesInRule :: Update Rule QName
trCombType :: a -> (Int -> a) -> a -> (Int -> a) -> CombType -> a
isCombTypeFuncCall :: CombType -> Bool
isCombTypeFuncPartCall :: CombType -> Bool
isCombTypeConsCall :: CombType -> Bool
isCombTypeConsPartCall :: CombType -> Bool
missingArgs :: CombType -> Int
varNr :: Expr -> VarIndex
literal :: Expr -> Literal
combType :: Expr -> CombType
combName :: Expr -> QName
combArgs :: Expr -> [Expr]
missingCombArgs :: Expr -> Int
letBinds :: Expr -> [(VarIndex, Expr)]
letBody :: Expr -> Expr
freeVars :: Expr -> [VarIndex]
freeExpr :: Expr -> Expr
orExps :: Expr -> [Expr]
caseType :: Expr -> CaseType
caseExpr :: Expr -> Expr
caseBranches :: Expr -> [BranchExpr]
isVar :: Expr -> Bool
isLit :: Expr -> Bool
isComb :: Expr -> Bool
isLet :: Expr -> Bool
isFree :: Expr -> Bool
isOr :: Expr -> Bool
isCase :: Expr -> Bool
trExpr :: (VarIndex -> a) -> (Literal -> a) -> (CombType -> QName -> [a] -> a) -> ([(VarIndex, a)] -> a -> a) -> ([VarIndex] -> a -> a) -> (a -> a -> a) -> (CaseType -> a -> [b] -> a) -> (Pattern -> a -> b) -> Expr -> a
updVars :: (VarIndex -> Expr) -> Expr -> Expr
updLiterals :: (Literal -> Expr) -> Expr -> Expr
updCombs :: (CombType -> QName -> [Expr] -> Expr) -> Expr -> Expr
updLets :: ([(VarIndex, Expr)] -> Expr -> Expr) -> Expr -> Expr
updFrees :: ([VarIndex] -> Expr -> Expr) -> Expr -> Expr
updOrs :: (Expr -> Expr -> Expr) -> Expr -> Expr
updCases :: (CaseType -> Expr -> [BranchExpr] -> Expr) -> Expr -> Expr
updBranches :: (Pattern -> Expr -> BranchExpr) -> Expr -> Expr
isFuncCall :: Expr -> Bool
isFuncPartCall :: Expr -> Bool
isConsCall :: Expr -> Bool
isConsPartCall :: Expr -> Bool
isGround :: Expr -> Bool
allVars :: Expr -> [VarIndex]
rnmAllVars :: Update Expr VarIndex
updQNames :: Update Expr QName
trBranch :: (Pattern -> Expr -> a) -> BranchExpr -> a
branchPattern :: BranchExpr -> Pattern
branchExpr :: BranchExpr -> Expr
updBranch :: (Pattern -> Pattern) -> (Expr -> Expr) -> BranchExpr -> BranchExpr
updBranchPattern :: Update BranchExpr Pattern
updBranchExpr :: Update BranchExpr Expr
trPattern :: (QName -> [VarIndex] -> a) -> (Literal -> a) -> Pattern -> a
patCons :: Pattern -> QName
patArgs :: Pattern -> [VarIndex]
patLiteral :: Pattern -> Literal
isConsPattern :: Pattern -> Bool
updPattern :: (QName -> QName) -> ([VarIndex] -> [VarIndex]) -> (Literal -> Literal) -> Pattern -> Pattern
updPatCons :: (QName -> QName) -> Pattern -> Pattern
updPatArgs :: ([VarIndex] -> [VarIndex]) -> Pattern -> Pattern
updPatLiteral :: (Literal -> Literal) -> Pattern -> Pattern
patExpr :: Pattern -> Expr

module Curry.FlatCurry.Tools
progName :: Prog -> String
progImports :: Prog -> [String]
progTypes :: Prog -> [TypeDecl]
progFuncs :: Prog -> [FuncDecl]
progOps :: Prog -> [OpDecl]
updProg :: (String -> String) -> ([String] -> [String]) -> ([TypeDecl] -> [TypeDecl]) -> ([FuncDecl] -> [FuncDecl]) -> ([OpDecl] -> [OpDecl]) -> Prog -> Prog
updProgName :: (String -> String) -> Prog -> Prog
updProgImports :: ([String] -> [String]) -> Prog -> Prog
updProgTypes :: ([TypeDecl] -> [TypeDecl]) -> Prog -> Prog
updProgFuncs :: ([FuncDecl] -> [FuncDecl]) -> Prog -> Prog
updProgOps :: ([OpDecl] -> [OpDecl]) -> Prog -> Prog
updProgExps :: (Expr -> Expr) -> Prog -> Prog
rnmAllVarsProg :: (Int -> Int) -> Prog -> Prog
allVarsProg :: Prog -> [Int]
updQNamesProg :: (QName -> QName) -> Prog -> Prog
rnmProg :: String -> Prog -> Prog
updQNamesType :: (QName -> QName) -> TypeDecl -> TypeDecl
allConstructors :: TypeDecl -> [ConsDecl]
consQName :: ConsDecl -> QName
consArity :: ConsDecl -> Int
isTypeSyn :: TypeDecl -> Bool
isDataTypeDecl :: TypeDecl -> Bool
isPublicType :: TypeDecl -> Bool
isPublicCons :: ConsDecl -> Bool
typeQName :: TypeDecl -> QName
isExternalType :: TypeDecl -> Bool
funcName :: FuncDecl -> QName
funcArity :: FuncDecl -> Int
funcVisibility :: FuncDecl -> Visibility
funcType :: FuncDecl -> TypeExpr
funcRule :: FuncDecl -> Rule
updFunc :: (QName -> QName) -> (Int -> Int) -> (Visibility -> Visibility) -> (TypeExpr -> TypeExpr) -> (Rule -> Rule) -> FuncDecl -> FuncDecl
updFuncName :: (QName -> QName) -> FuncDecl -> FuncDecl
updFuncArity :: (Int -> Int) -> FuncDecl -> FuncDecl
updFuncVisibility :: (Visibility -> Visibility) -> FuncDecl -> FuncDecl
updFuncType :: (TypeExpr -> TypeExpr) -> FuncDecl -> FuncDecl
updFuncRule :: (Rule -> Rule) -> FuncDecl -> FuncDecl
funcArgs :: FuncDecl -> Maybe [Int]
funcBody :: FuncDecl -> Maybe Expr
funcRHS :: FuncDecl -> Maybe [Expr]
isExternal :: FuncDecl -> Bool
isCombFunc :: FuncDecl -> Expr -> Bool
updFuncArgs :: ([Int] -> [Int]) -> FuncDecl -> FuncDecl
updFuncBody :: (Expr -> Expr) -> FuncDecl -> FuncDecl
incVarsFunc :: Int -> FuncDecl -> FuncDecl
rnmAllVarsFunc :: (Int -> Int) -> FuncDecl -> FuncDecl
allVarsFunc :: FuncDecl -> [Int]
updQNamesFunc :: (QName -> QName) -> FuncDecl -> FuncDecl
isRuleExternal :: Rule -> Bool
ruleArgs :: Rule -> Maybe [Int]
ruleBody :: Rule -> Maybe Expr
updRule :: ([VarIndex] -> [VarIndex]) -> (Expr -> Expr) -> (String -> String) -> Rule -> Rule
updRuleArgs :: ([Int] -> [Int]) -> Rule -> Rule
updRuleBody :: (Expr -> Expr) -> Rule -> Rule
rnmAllVarsRule :: (Int -> Int) -> Rule -> Rule
allVarsRule :: Rule -> [Int]
updQNamesRule :: (QName -> QName) -> Rule -> Rule
isTypeVar :: TypeExpr -> Bool
isFuncType :: TypeExpr -> Bool
isTypeCons :: TypeExpr -> Bool
typeConsName :: TypeExpr -> Maybe QName
argTypes :: TypeExpr -> [TypeExpr]
resultType :: TypeExpr -> TypeExpr
isIOType :: TypeExpr -> Bool
typeArity :: TypeExpr -> Int
allTVars :: TypeExpr -> [TVarIndex]
rnmAllVarsTypeExpr :: (Int -> Int) -> TypeExpr -> TypeExpr
allTypeCons :: TypeExpr -> [QName]
isVar :: Expr -> Bool
varNr :: Expr -> Int
isLit :: Expr -> Bool
isComb :: Expr -> Bool
isFree :: Expr -> Bool
isOr :: Expr -> Bool
isCase :: Expr -> Bool
isLet :: Expr -> Bool
isGround :: Expr -> Bool
literal :: Expr -> Maybe Literal
combType :: Expr -> Maybe CombType
exprFromFreeDecl :: Expr -> Expr
orExps :: Expr -> [Expr]
isFuncCall :: Expr -> Bool
isPartCall :: Expr -> Bool
isConsCall :: Expr -> Bool
combFunc :: Expr -> Maybe QName
combCons :: Expr -> Maybe QName
combArgs :: Expr -> Maybe [Expr]
missingFuncArgs :: Expr -> Maybe Int
hasName :: QName -> Expr -> Bool
caseBranches :: Expr -> [BranchExpr]
rnmAllVars :: (Int -> Int) -> Expr -> Expr
allVars :: Expr -> [Int]
mapVar :: (Expr -> Expr) -> Expr -> Expr
mapLit :: (Expr -> Expr) -> Expr -> Expr
mapComb :: (Expr -> Expr) -> Expr -> Expr
mapFree :: (Expr -> Expr) -> Expr -> Expr
mapOr :: (Expr -> Expr) -> Expr -> Expr
mapCase :: (Expr -> Expr) -> Expr -> Expr
mapLet :: (Expr -> Expr) -> Expr -> Expr
isCombFuncCall :: CombType -> Bool
isCombPartCall :: CombType -> Bool
isCombConsCall :: CombType -> Bool
missingArgs :: CombType -> Int
branchPattern :: BranchExpr -> Pattern
branchExpr :: BranchExpr -> Expr
isConsPattern :: Pattern -> Bool
updBranch :: (Pattern -> Pattern) -> (Expr -> Expr) -> BranchExpr -> BranchExpr
updBranchPattern :: (Pattern -> Pattern) -> BranchExpr -> BranchExpr
updBranchExpr :: (Expr -> Expr) -> BranchExpr -> BranchExpr
patCons :: Pattern -> Maybe QName
patArgs :: Pattern -> Maybe [Int]
patLiteral :: Pattern -> Maybe Literal
patExpr :: Pattern -> Expr
rnmAllVarsBranch :: (Int -> Int) -> BranchExpr -> BranchExpr
allVarsBranch :: BranchExpr -> [Int]
rnmAllVarsPat :: (Int -> Int) -> Pattern -> Pattern
allVarsPat :: Pattern -> [Int]
opName :: OpDecl -> QName

module Curry.AbstractCurry
data CurryProg
CurryProg :: String -> [String] -> [CTypeDecl] -> [CFuncDecl] -> [COpDecl] -> CurryProg
type QName = (String, String)
type CLabel = String
data CVisibility
Public :: CVisibility
Private :: CVisibility
type CTVarIName = (Int, String)
data CTypeDecl
CType :: QName -> CVisibility -> [CTVarIName] -> [CConsDecl] -> CTypeDecl
CTypeSyn :: QName -> CVisibility -> [CTVarIName] -> CTypeExpr -> CTypeDecl
data CConsDecl
CCons :: QName -> Int -> CVisibility -> [CTypeExpr] -> CConsDecl
data CTypeExpr
CTVar :: CTVarIName -> CTypeExpr
CFuncType :: CTypeExpr -> CTypeExpr -> CTypeExpr
CTCons :: QName -> [CTypeExpr] -> CTypeExpr
CRecordType :: [CField CTypeExpr] -> (Maybe CTVarIName) -> CTypeExpr
data COpDecl
COp :: QName -> CFixity -> Int -> COpDecl
data CFixity
CInfixOp :: CFixity
CInfixlOp :: CFixity
CInfixrOp :: CFixity
type CVarIName = (Int, String)
data CFuncDecl
CFunc :: QName -> Int -> CVisibility -> CTypeExpr -> CRules -> CFuncDecl
data CRules
CRules :: CEvalAnnot -> [CRule] -> CRules
CExternal :: String -> CRules
data CEvalAnnot
CFlex :: CEvalAnnot
CRigid :: CEvalAnnot
CChoice :: CEvalAnnot
data CRule
CRule :: [CPattern] -> [(CExpr, CExpr)] -> [CLocalDecl] -> CRule
data CLocalDecl
CLocalFunc :: CFuncDecl -> CLocalDecl
CLocalPat :: CPattern -> CExpr -> [CLocalDecl] -> CLocalDecl
CLocalVar :: CVarIName -> CLocalDecl
data CExpr
CVar :: CVarIName -> CExpr
CLit :: CLiteral -> CExpr
CSymbol :: QName -> CExpr
CApply :: CExpr -> CExpr -> CExpr
CLambda :: [CPattern] -> CExpr -> CExpr
CLetDecl :: [CLocalDecl] -> CExpr -> CExpr
CDoExpr :: [CStatement] -> CExpr
CListComp :: CExpr -> [CStatement] -> CExpr
CCase :: CExpr -> [CBranchExpr] -> CExpr
CRecConstr :: [CField CExpr] -> CExpr
CRecSelect :: CExpr -> CLabel -> CExpr
CRecUpdate :: [CField CExpr] -> CExpr -> CExpr
data CStatement
CSExpr :: CExpr -> CStatement
CSPat :: CPattern -> CExpr -> CStatement
CSLet :: [CLocalDecl] -> CStatement
data CPattern
CPVar :: CVarIName -> CPattern
CPLit :: CLiteral -> CPattern
CPComb :: QName -> [CPattern] -> CPattern
CPAs :: CVarIName -> CPattern -> CPattern
CPFuncComb :: QName -> [CPattern] -> CPattern
CPLazy :: CPattern -> CPattern
CPRecord :: [CField CPattern] -> (Maybe CPattern) -> CPattern
data CBranchExpr
CBranch :: CPattern -> CExpr -> CBranchExpr
data CLiteral
CIntc :: Integer -> CLiteral
CFloatc :: Double -> CLiteral
CCharc :: Char -> CLiteral
type CField a = (CLabel, a)
readCurry :: String -> IO CurryProg
writeCurry :: Bool -> String -> CurryProg -> IO ()
instance Read CLiteral
instance Show CLiteral
instance Eq CLiteral
instance Read CBranchExpr
instance Show CBranchExpr
instance Read CPattern
instance Show CPattern
instance Read CStatement
instance Show CStatement
instance Read CExpr
instance Show CExpr
instance Read CLocalDecl
instance Show CLocalDecl
instance Read CRule
instance Show CRule
instance Read CEvalAnnot
instance Show CEvalAnnot
instance Eq CEvalAnnot
instance Read CRules
instance Show CRules
instance Read CFuncDecl
instance Show CFuncDecl
instance Read CFixity
instance Show CFixity
instance Eq CFixity
instance Read COpDecl
instance Show COpDecl
instance Read CTypeExpr
instance Show CTypeExpr
instance Read CConsDecl
instance Show CConsDecl
instance Read CTypeDecl
instance Show CTypeDecl
instance Read CVisibility
instance Show CVisibility
instance Eq CVisibility
instance Read CurryProg
instance Show CurryProg

module Curry.Base.MessageMonad
type MsgMonadT m = ErrorT WarnMsg (WriterT [WarnMsg] m)
type MsgMonad = MsgMonadT Identity
type MsgMonadIO = MsgMonadT IO
data WarnMsg
WarnMsg :: Maybe Position -> String -> WarnMsg
warnPos :: WarnMsg -> Maybe Position
warnTxt :: WarnMsg -> String
ok :: MsgMonad a -> a
failWith :: (MonadError a m, Error a) => String -> m a1
failWithAt :: (MonadError WarnMsg m) => Position -> String -> m a
warnMessage :: (MonadWriter [WarnMsg] m) => String -> m ()
warnMessageAt :: (MonadWriter [WarnMsg] m) => Position -> String -> m ()
runMsg :: MsgMonad a -> (Either WarnMsg a, [WarnMsg])
runMsgIO :: MsgMonad a -> (a -> IO (MsgMonad b)) -> IO (MsgMonad b)
dropIO :: MsgMonad a -> MsgMonadIO a
instance Show WarnMsg
instance Error WarnMsg

module Curry.ExtendedFlat.Type
data SrcRef
data Prog
Prog :: String -> [String] -> [TypeDecl] -> [FuncDecl] -> [OpDecl] -> Prog
data QName
QName :: Maybe SrcRef -> Maybe TypeExpr -> String -> String -> QName
srcRef :: QName -> Maybe SrcRef
typeofQName :: QName -> Maybe TypeExpr
modName :: QName -> String
localName :: QName -> String
qnOf :: QName -> (String, String)
mkQName :: (String, String) -> QName
data Visibility
Public :: Visibility
Private :: Visibility
type TVarIndex = Int
data TypeDecl
Type :: QName -> Visibility -> [TVarIndex] -> [ConsDecl] -> TypeDecl
TypeSyn :: QName -> Visibility -> [TVarIndex] -> TypeExpr -> TypeDecl
data ConsDecl
Cons :: QName -> Int -> Visibility -> [TypeExpr] -> ConsDecl
data TypeExpr
TVar :: !TVarIndex -> TypeExpr
FuncType :: TypeExpr -> TypeExpr -> TypeExpr
TCons :: QName -> [TypeExpr] -> TypeExpr
data OpDecl
Op :: QName -> Fixity -> Integer -> OpDecl
data Fixity
InfixOp :: Fixity
InfixlOp :: Fixity
InfixrOp :: Fixity
data VarIndex
VarIndex :: Maybe TypeExpr -> Int -> VarIndex
typeofVar :: VarIndex -> Maybe TypeExpr
idxOf :: VarIndex -> Int
mkIdx :: Int -> VarIndex
incVarIndex :: VarIndex -> Int -> VarIndex
data FuncDecl
Func :: QName -> Int -> Visibility -> TypeExpr -> Rule -> FuncDecl
data Rule
Rule :: [VarIndex] -> Expr -> Rule
External :: String -> Rule
data CaseType
Rigid :: CaseType
Flex :: CaseType
data CombType
FuncCall :: CombType
ConsCall :: CombType
FuncPartCall :: Int -> CombType
ConsPartCall :: Int -> CombType
data Expr
Var :: VarIndex -> Expr
Lit :: Literal -> Expr
Comb :: CombType -> QName -> [Expr] -> Expr
Free :: [VarIndex] -> Expr -> Expr
Let :: [(VarIndex, Expr)] -> Expr -> Expr
Or :: Expr -> Expr -> Expr
Case :: SrcRef -> CaseType -> Expr -> [BranchExpr] -> Expr
data BranchExpr
Branch :: Pattern -> Expr -> BranchExpr
data Pattern
Pattern :: QName -> [VarIndex] -> Pattern
LPattern :: Literal -> Pattern
data Literal
Intc :: SrcRef -> Integer -> Literal
Floatc :: SrcRef -> Double -> Literal
Charc :: SrcRef -> Char -> Literal
readFlatCurry :: FilePath -> IO (Maybe Prog)
readFlatInterface :: String -> IO (Maybe Prog)
readFlat :: FilePath -> IO (Maybe Prog)
writeFlatCurry :: Bool -> String -> Prog -> IO ()
writeExtendedFlat :: Bool -> String -> Prog -> IO ()
gshowsPrec :: (Data a) => Bool -> Bool -> a -> ShowS
instance Typeable Literal
instance Typeable Pattern
instance Typeable BranchExpr
instance Typeable Expr
instance Typeable CombType
instance Typeable CaseType
instance Typeable Rule
instance Typeable FuncDecl
instance Typeable Fixity
instance Typeable OpDecl
instance Typeable TypeExpr
instance Typeable ConsDecl
instance Typeable TypeDecl
instance Typeable Visibility
instance Typeable VarIndex
instance Typeable QName
instance Typeable Prog
instance Read Literal
instance Show Literal
instance Eq Literal
instance Data Literal
instance Read Pattern
instance Show Pattern
instance Eq Pattern
instance Data Pattern
instance Read BranchExpr
instance Show BranchExpr
instance Eq BranchExpr
instance Data BranchExpr
instance Read Expr
instance Show Expr
instance Eq Expr
instance Data Expr
instance Read CombType
instance Show CombType
instance Eq CombType
instance Data CombType
instance Read CaseType
instance Show CaseType
instance Eq CaseType
instance Data CaseType
instance Read Rule
instance Show Rule
instance Eq Rule
instance Data Rule
instance Read FuncDecl
instance Show FuncDecl
instance Eq FuncDecl
instance Data FuncDecl
instance Read Fixity
instance Show Fixity
instance Eq Fixity
instance Data Fixity
instance Read OpDecl
instance Show OpDecl
instance Eq OpDecl
instance Data OpDecl
instance Read TypeExpr
instance Show TypeExpr
instance Eq TypeExpr
instance Data TypeExpr
instance Read ConsDecl
instance Show ConsDecl
instance Eq ConsDecl
instance Data ConsDecl
instance Read TypeDecl
instance Show TypeDecl
instance Eq TypeDecl
instance Data TypeDecl
instance Read Visibility
instance Show Visibility
instance Eq Visibility
instance Data Visibility
instance Data VarIndex
instance Data QName
instance Read Prog
instance Show Prog
instance Eq Prog
instance Data Prog
instance Num VarIndex
instance Ord VarIndex
instance Eq VarIndex
instance Show VarIndex
instance Read VarIndex
instance Ord QName
instance Eq QName
instance Show QName
instance Read QName

module Curry.ExtendedFlat.Goodies
failed :: a
type Update a b = (b -> b) -> a -> a
trProg :: (String -> [String] -> [TypeDecl] -> [FuncDecl] -> [OpDecl] -> a) -> Prog -> a
progName :: Prog -> String
progImports :: Prog -> [String]
progTypes :: Prog -> [TypeDecl]
progFuncs :: Prog -> [FuncDecl]
progOps :: Prog -> [OpDecl]
updProg :: (String -> String) -> ([String] -> [String]) -> ([TypeDecl] -> [TypeDecl]) -> ([FuncDecl] -> [FuncDecl]) -> ([OpDecl] -> [OpDecl]) -> Prog -> Prog
updProgName :: Update Prog String
updProgImports :: Update Prog [String]
updProgTypes :: Update Prog [TypeDecl]
updProgFuncs :: Update Prog [FuncDecl]
updProgOps :: Update Prog [OpDecl]
allVarsInProg :: Prog -> [VarIndex]
updProgExps :: Update Prog Expr
rnmAllVarsInProg :: Update Prog VarIndex
updQNamesInProg :: Update Prog QName
rnmProg :: String -> Prog -> Prog
trType :: (QName -> Visibility -> [TVarIndex] -> [ConsDecl] -> a) -> (QName -> Visibility -> [TVarIndex] -> TypeExpr -> a) -> TypeDecl -> a
typeName :: TypeDecl -> QName
typeVisibility :: TypeDecl -> Visibility
typeParams :: TypeDecl -> [TVarIndex]
typeConsDecls :: TypeDecl -> [ConsDecl]
typeSyn :: TypeDecl -> TypeExpr
isTypeSyn :: TypeDecl -> Bool
isDataTypeDecl :: TypeDecl -> Bool
isExternalType :: TypeDecl -> Bool
updType :: (QName -> QName) -> (Visibility -> Visibility) -> ([TVarIndex] -> [TVarIndex]) -> ([ConsDecl] -> [ConsDecl]) -> (TypeExpr -> TypeExpr) -> TypeDecl -> TypeDecl
updTypeName :: Update TypeDecl QName
updTypeVisibility :: Update TypeDecl Visibility
updTypeParams :: Update TypeDecl [TVarIndex]
updTypeConsDecls :: Update TypeDecl [ConsDecl]
updTypeSynonym :: Update TypeDecl TypeExpr
updQNamesInType :: Update TypeDecl QName
trCons :: (QName -> Int -> Visibility -> [TypeExpr] -> a) -> ConsDecl -> a
consName :: ConsDecl -> QName
consArity :: ConsDecl -> Int
consVisibility :: ConsDecl -> Visibility
consArgs :: ConsDecl -> [TypeExpr]
updCons :: (QName -> QName) -> (Int -> Int) -> (Visibility -> Visibility) -> ([TypeExpr] -> [TypeExpr]) -> ConsDecl -> ConsDecl
updConsName :: Update ConsDecl QName
updConsArity :: Update ConsDecl Int
updConsVisibility :: Update ConsDecl Visibility
updConsArgs :: Update ConsDecl [TypeExpr]
updQNamesInConsDecl :: Update ConsDecl QName
tVarIndex :: TypeExpr -> TVarIndex
domain :: TypeExpr -> TypeExpr
range :: TypeExpr -> TypeExpr
tConsName :: TypeExpr -> QName
tConsArgs :: TypeExpr -> [TypeExpr]
trTypeExpr :: (TVarIndex -> a) -> (QName -> [a] -> a) -> (a -> a -> a) -> TypeExpr -> a
isTVar :: TypeExpr -> Bool
isTCons :: TypeExpr -> Bool
isFuncType :: TypeExpr -> Bool
updTVars :: (TVarIndex -> TypeExpr) -> TypeExpr -> TypeExpr
updTCons :: (QName -> [TypeExpr] -> TypeExpr) -> TypeExpr -> TypeExpr
updFuncTypes :: (TypeExpr -> TypeExpr -> TypeExpr) -> TypeExpr -> TypeExpr
argTypes :: TypeExpr -> [TypeExpr]
resultType :: TypeExpr -> TypeExpr
allVarsInTypeExpr :: TypeExpr -> [TVarIndex]
rnmAllVarsInTypeExpr :: (TVarIndex -> TVarIndex) -> TypeExpr -> TypeExpr
updQNamesInTypeExpr :: (QName -> QName) -> TypeExpr -> TypeExpr
trOp :: (QName -> Fixity -> Integer -> a) -> OpDecl -> a
opName :: OpDecl -> QName
opFixity :: OpDecl -> Fixity
opPrecedence :: OpDecl -> Integer
updOp :: (QName -> QName) -> (Fixity -> Fixity) -> (Integer -> Integer) -> OpDecl -> OpDecl
updOpName :: Update OpDecl QName
updOpFixity :: Update OpDecl Fixity
updOpPrecedence :: Update OpDecl Integer
trFunc :: (QName -> Int -> Visibility -> TypeExpr -> Rule -> a) -> FuncDecl -> a
funcName :: FuncDecl -> QName
funcArity :: FuncDecl -> Int
funcVisibility :: FuncDecl -> Visibility
funcType :: FuncDecl -> TypeExpr
funcRule :: FuncDecl -> Rule
updFunc :: (QName -> QName) -> (Int -> Int) -> (Visibility -> Visibility) -> (TypeExpr -> TypeExpr) -> (Rule -> Rule) -> FuncDecl -> FuncDecl
updFuncName :: Update FuncDecl QName
updFuncArity :: Update FuncDecl Int
updFuncVisibility :: Update FuncDecl Visibility
updFuncType :: Update FuncDecl TypeExpr
updFuncRule :: Update FuncDecl Rule
isExternal :: FuncDecl -> Bool
allVarsInFunc :: FuncDecl -> [VarIndex]
funcArgs :: FuncDecl -> [VarIndex]
funcBody :: FuncDecl -> Expr
funcRHS :: FuncDecl -> [Expr]
rnmAllVarsInFunc :: Update FuncDecl VarIndex
updQNamesInFunc :: Update FuncDecl QName
updFuncArgs :: Update FuncDecl [VarIndex]
updFuncBody :: Update FuncDecl Expr
trRule :: ([VarIndex] -> Expr -> a) -> (String -> a) -> Rule -> a
ruleArgs :: Rule -> [VarIndex]
ruleBody :: Rule -> Expr
ruleExtDecl :: Rule -> String
isRuleExternal :: Rule -> Bool
updRule :: ([VarIndex] -> [VarIndex]) -> (Expr -> Expr) -> (String -> String) -> Rule -> Rule
updRuleArgs :: Update Rule [VarIndex]
updRuleBody :: Update Rule Expr
updRuleExtDecl :: Update Rule String
allVarsInRule :: Rule -> [VarIndex]
rnmAllVarsInRule :: Update Rule VarIndex
updQNamesInRule :: Update Rule QName
trCombType :: a -> (Int -> a) -> a -> (Int -> a) -> CombType -> a
isCombTypeFuncCall :: CombType -> Bool
isCombTypeFuncPartCall :: CombType -> Bool
isCombTypeConsCall :: CombType -> Bool
isCombTypeConsPartCall :: CombType -> Bool
missingArgs :: CombType -> Int
varNr :: Expr -> VarIndex
literal :: Expr -> Literal
combType :: Expr -> CombType
combName :: Expr -> QName
combArgs :: Expr -> [Expr]
missingCombArgs :: Expr -> Int
letBinds :: Expr -> [(VarIndex, Expr)]
letBody :: Expr -> Expr
freeVars :: Expr -> [VarIndex]
freeExpr :: Expr -> Expr
orExps :: Expr -> [Expr]
caseType :: Expr -> CaseType
caseExpr :: Expr -> Expr
caseBranches :: Expr -> [BranchExpr]
isVar :: Expr -> Bool
isLit :: Expr -> Bool
isComb :: Expr -> Bool
isLet :: Expr -> Bool
isFree :: Expr -> Bool
isOr :: Expr -> Bool
isCase :: Expr -> Bool
trExpr :: (VarIndex -> a) -> (Literal -> a) -> (CombType -> QName -> [a] -> a) -> ([(VarIndex, a)] -> a -> a) -> ([VarIndex] -> a -> a) -> (a -> a -> a) -> (SrcRef -> CaseType -> a -> [b] -> a) -> (Pattern -> a -> b) -> Expr -> a
updVars :: (VarIndex -> Expr) -> Expr -> Expr
updLiterals :: (Literal -> Expr) -> Expr -> Expr
updCombs :: (CombType -> QName -> [Expr] -> Expr) -> Expr -> Expr
updLets :: ([(VarIndex, Expr)] -> Expr -> Expr) -> Expr -> Expr
updFrees :: ([VarIndex] -> Expr -> Expr) -> Expr -> Expr
updOrs :: (Expr -> Expr -> Expr) -> Expr -> Expr
updCases :: (SrcRef -> CaseType -> Expr -> [BranchExpr] -> Expr) -> Expr -> Expr
updBranches :: (Pattern -> Expr -> BranchExpr) -> Expr -> Expr
isFuncCall :: Expr -> Bool
isFuncPartCall :: Expr -> Bool
isConsCall :: Expr -> Bool
isConsPartCall :: Expr -> Bool
isGround :: Expr -> Bool
allVars :: Expr -> [VarIndex]
rnmAllVars :: Update Expr VarIndex
updQNames :: Update Expr QName
trBranch :: (Pattern -> Expr -> a) -> BranchExpr -> a
branchPattern :: BranchExpr -> Pattern
branchExpr :: BranchExpr -> Expr
updBranch :: (Pattern -> Pattern) -> (Expr -> Expr) -> BranchExpr -> BranchExpr
updBranchPattern :: Update BranchExpr Pattern
updBranchExpr :: Update BranchExpr Expr
trPattern :: (QName -> [VarIndex] -> a) -> (Literal -> a) -> Pattern -> a
patCons :: Pattern -> QName
patArgs :: Pattern -> [VarIndex]
patLiteral :: Pattern -> Literal
isConsPattern :: Pattern -> Bool
updPattern :: (QName -> QName) -> ([VarIndex] -> [VarIndex]) -> (Literal -> Literal) -> Pattern -> Pattern
updPatCons :: (QName -> QName) -> Pattern -> Pattern
updPatArgs :: ([VarIndex] -> [VarIndex]) -> Pattern -> Pattern
updPatLiteral :: (Literal -> Literal) -> Pattern -> Pattern
patExpr :: Pattern -> Expr
typeofExpr :: Expr -> Maybe TypeExpr
typeofLiteral :: Literal -> TypeExpr
fvs :: Expr -> [VarIndex]
whnf :: Expr -> Bool

module Curry.ExtendedFlat.TypeInference

-- | Displays a TypeExpr as a string
dispType :: TypeExpr -> String

-- | For every identifier that occurs in the right hand side of a
--   declaration, the polymorphic type variables in its type label are
--   replaced by concrete types.
adjustTypeInfo :: Prog -> Prog

-- | All identifiers that do not have type annotations are labelled with
--   new type variables
labelVarsWithTypes :: Prog -> Prog

-- | Type variables that occur in the type annotations of QNames are
--   replaced by newly introduced type variables, so that further
--   unification steps will not interfere with parametric polymorphism
uniqueTypeIndices :: Prog -> Prog

-- | Specialises all type variables (part of adjustTypeInfo)
genEquations :: Prog -> Prog

-- | Type variables that occur in the right hand side of a declaration but
--   not in its type signature are replaced by the unit type (). This
--   function requires that proper type information has been made available
--   by function <tt>adjustTypeInfo</tt>
elimFreeTypes :: Prog -> Prog

module Curry.ExtendedFlat.MonadicGoodies
type UpdateM m a b = (b -> m b) -> a -> m a
postOrderM :: (Monad m) => UpdateM m Expr Expr
updFuncExpsM :: (Monad m) => UpdateM m FuncDecl Expr
updProgFuncsM :: (Monad m) => UpdateM m Prog FuncDecl
updFuncLetsM :: (Monad m) => ([(VarIndex, Expr)] -> Expr -> m Expr) -> FuncDecl -> m FuncDecl

module Curry.ExtendedFlat.LiftLetrec
liftLetrecProg :: Prog -> Prog

module Curry.ExtendedFlat.UnMutual
unMutualProg :: Prog -> Prog
