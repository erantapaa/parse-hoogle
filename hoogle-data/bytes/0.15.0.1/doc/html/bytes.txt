-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sharing code for serialization between binary and cereal
--   
@package bytes
@version 0.15.0.1


-- | When one wants to think of an <a>Int</a> as a dumb bitstring,
--   converting it to a <a>Word</a> avoids pesky complications with respect
--   to sign extension.
module Data.Bytes.Signed
unsigned :: (Integral i, Num (Unsigned i)) => i -> Unsigned i
signed :: (Integral i, Num (Signed i)) => i -> Signed i


-- | This module provides a <a>VarInt</a> wrapper with a <tt>Serial</tt>
--   instance that generates base-128 variable-width ints. Values are
--   encoded 7 bits at a time, with the most significant being a
--   continuation bit. Thus, the numbers from 0 to 127 require only a
--   single byte to encode, those from 128 to 16383 require two bytes, etc.
--   
--   This format is taken from Google's <i>Protocol Buffers</i>, which
--   provides a bit more verbiage on the encoding:
--   <a>https://developers.google.com/protocol-buffers/docs/encoding#varints</a>.
module Data.Bytes.VarInt
newtype VarInt n
VarInt :: n -> VarInt n
unVarInt :: VarInt n -> n
instance Eq n => Eq (VarInt n)
instance Ord n => Ord (VarInt n)
instance Show n => Show (VarInt n)
instance Enum n => Enum (VarInt n)
instance Num n => Num (VarInt n)
instance Integral n => Integral (VarInt n)
instance Bounded n => Bounded (VarInt n)
instance Real n => Real (VarInt n)
instance Bits n => Bits (VarInt n)


-- | This module generalizes the <tt>binary</tt> <a>PutM</a> and
--   <tt>cereal</tt> <a>PutM</a> monads in an ad hoc fashion to permit code
--   to be written that is compatible across them.
--   
--   Moreover, this class permits code to be written to be portable over
--   various monad transformers applied to these as base monads.
module Data.Bytes.Put
class (Applicative m, Monad m) => MonadPut m where putWord8 = lift . putWord8 putByteString = lift . putByteString putLazyByteString = lift . putLazyByteString flush = lift flush putWord16le = lift . putWord16le putWord16be = lift . putWord16be putWord16host = lift . putWord16host putWord32le = lift . putWord32le putWord32be = lift . putWord32be putWord32host = lift . putWord32host putWord64le = lift . putWord64le putWord64be = lift . putWord64be putWord64host = lift . putWord64host putWordhost = lift . putWordhost
putWord8 :: MonadPut m => Word8 -> m ()
putByteString :: MonadPut m => ByteString -> m ()
putLazyByteString :: MonadPut m => ByteString -> m ()
flush :: MonadPut m => m ()
putWord16le :: MonadPut m => Word16 -> m ()
putWord16be :: MonadPut m => Word16 -> m ()
putWord16host :: MonadPut m => Word16 -> m ()
putWord32le :: MonadPut m => Word32 -> m ()
putWord32be :: MonadPut m => Word32 -> m ()
putWord32host :: MonadPut m => Word32 -> m ()
putWord64le :: MonadPut m => Word64 -> m ()
putWord64be :: MonadPut m => Word64 -> m ()
putWord64host :: MonadPut m => Word64 -> m ()
putWordhost :: MonadPut m => Word -> m ()

-- | Put a value into a lazy <a>ByteString</a> using <a>runPut</a>.
runPutL :: Put -> ByteString

-- | Put a value into a strict <a>ByteString</a> using <a>runPut</a>.
runPutS :: Put -> ByteString
instance MonadPut m => MonadPut (ExceptT e m)
instance (MonadPut m, Monoid w) => MonadPut (RWST r w s m)
instance (MonadPut m, Monoid w) => MonadPut (RWST r w s m)
instance (MonadPut m, Monoid w) => MonadPut (WriterT w m)
instance (MonadPut m, Monoid w) => MonadPut (WriterT w m)
instance MonadPut m => MonadPut (ReaderT e m)
instance MonadPut m => MonadPut (StateT s m)
instance MonadPut m => MonadPut (StateT s m)
instance MonadPut PutM
instance MonadPut PutM


-- | This module generalizes the <tt>binary</tt> <a>Get</a> and
--   <tt>cereal</tt> <a>Get</a> monads in an ad hoc fashion to permit code
--   to be written that is compatible across them.
--   
--   Moreover, this class permits code to be written to be portable over
--   various monad transformers applied to these as base monads.
module Data.Bytes.Get
class (Integral (Remaining m), Monad m, Applicative m) => MonadGet m where type family Remaining m :: * type family Bytes m :: * skip = lift . skip ensure = lift . ensure getBytes = lift . getBytes remaining = lift remaining isEmpty = lift isEmpty getWord8 = lift getWord8 getByteString = lift . getByteString getLazyByteString = lift . getLazyByteString getWord16be = lift getWord16be getWord16le = lift getWord16le getWord16host = lift getWord16host getWord32be = lift getWord32be getWord32le = lift getWord32le getWord32host = lift getWord32host getWord64be = lift getWord64be getWord64le = lift getWord64le getWord64host = lift getWord64host getWordhost = lift getWordhost
skip :: MonadGet m => Int -> m ()
ensure :: MonadGet m => Int -> m ByteString
lookAhead :: MonadGet m => m a -> m a
lookAheadM :: MonadGet m => m (Maybe a) -> m (Maybe a)
lookAheadE :: MonadGet m => m (Either a b) -> m (Either a b)
getBytes :: MonadGet m => Int -> m ByteString
remaining :: MonadGet m => m (Remaining m)
isEmpty :: MonadGet m => m Bool
getWord8 :: MonadGet m => m Word8
getByteString :: MonadGet m => Int -> m ByteString
getLazyByteString :: MonadGet m => Int64 -> m ByteString
getWord16be :: MonadGet m => m Word16
getWord16le :: MonadGet m => m Word16
getWord16host :: MonadGet m => m Word16
getWord32be :: MonadGet m => m Word32
getWord32le :: MonadGet m => m Word32
getWord32host :: MonadGet m => m Word32
getWord64be :: MonadGet m => m Word64
getWord64le :: MonadGet m => m Word64
getWord64host :: MonadGet m => m Word64
getWordhost :: MonadGet m => m Word

-- | Get something from a lazy <a>ByteString</a> using <a>runGet</a>.
runGetL :: Get a -> ByteString -> a

-- | Get something from a strict <a>ByteString</a> using <a>runGet</a>.
runGetS :: Get a -> ByteString -> Either String a
instance MonadGet m => MonadGet (ExceptT e m)
instance (MonadGet m, Monoid w) => MonadGet (RWST r w s m)
instance (MonadGet m, Monoid w) => MonadGet (RWST r w s m)
instance (MonadGet m, Monoid w) => MonadGet (WriterT w m)
instance (MonadGet m, Monoid w) => MonadGet (WriterT w m)
instance MonadGet m => MonadGet (ReaderT e m)
instance MonadGet m => MonadGet (StateT s m)
instance MonadGet m => MonadGet (StateT s m)
instance MonadGet Get
instance MonadGet Get


-- | This module contains two main classes, each providing methods to
--   serialize and deserialize types. <a>Serial</a> is the primary class,
--   to be used for the canonical way to serialize a specific type.
--   <a>SerialEndian</a> is used to provide endian-specific methods for
--   serializing a type.
module Data.Bytes.Serial

-- | Methods to serialize and deserialize type <tt>a</tt> to a binary
--   representation
--   
--   Instances provided here for fixed-with Integers and Words are big
--   endian. Instances for strict and lazy bytestrings store also the
--   length of bytestring big endian. Instances for Word and Int are host
--   endian as they are machine-specific types.
class Serial a where serialize = gserialize . from deserialize = liftM to gdeserialize
serialize :: (Serial a, MonadPut m) => a -> m ()
deserialize :: (Serial a, MonadGet m) => m a

-- | Methods to serialize and deserialize type <tt>a</tt> to a big and
--   little endian binary representations. Methods suffixed with "host" are
--   automatically defined to use equal the methods corresponding to the
--   current machine's native endianness, but they can be overridden.
class SerialEndian a where serializeBE = gserializeBE . from deserializeBE = liftM to gdeserializeBE serializeLE = gserializeLE . from deserializeLE = liftM to gdeserializeLE serializeHost = serializeLE deserializeHost = deserializeLE
serializeBE :: (SerialEndian a, MonadPut m) => a -> m ()
deserializeBE :: (SerialEndian a, MonadGet m) => m a
serializeLE :: (SerialEndian a, MonadPut m) => a -> m ()
deserializeLE :: (SerialEndian a, MonadGet m) => m a
serializeHost :: (SerialEndian a, MonadPut m) => a -> m ()
deserializeHost :: (SerialEndian a, MonadGet m) => m a
class Serial1 f where serializeWith f = gserializeWith f . from1 deserializeWith f = liftM to1 (gdeserializeWith f)
serializeWith :: (Serial1 f, MonadPut m) => (a -> m ()) -> f a -> m ()
deserializeWith :: (Serial1 f, MonadGet m) => m a -> m (f a)
serialize1 :: (MonadPut m, Serial1 f, Serial a) => f a -> m ()
deserialize1 :: (MonadGet m, Serial1 f, Serial a) => m (f a)
class Serial2 f
serializeWith2 :: (Serial2 f, MonadPut m) => (a -> m ()) -> (b -> m ()) -> f a b -> m ()
deserializeWith2 :: (Serial2 f, MonadGet m) => m a -> m b -> m (f a b)
serialize2 :: (MonadPut m, Serial2 f, Serial a, Serial b) => f a b -> m ()
deserialize2 :: (MonadGet m, Serial2 f, Serial a, Serial b) => m (f a b)

-- | serialize any <a>Storable</a> in a host-specific format.
store :: (MonadPut m, Storable a) => a -> m ()

-- | deserialize any <a>Storable</a> in a host-specific format.
restore :: (MonadGet m, Storable a) => m a

-- | Used internally to provide generic serialization
class GSerial f
gserialize :: (GSerial f, MonadPut m) => f a -> m ()
gdeserialize :: (GSerial f, MonadGet m) => m (f a)

-- | Used internally to provide generic big-endian serialization
class GSerialEndian f where gserializeBE = gserialize gdeserializeBE = gdeserialize gserializeLE = gserialize gdeserializeLE = gdeserialize
gserializeBE :: (GSerialEndian f, MonadPut m) => f a -> m ()
gdeserializeBE :: (GSerialEndian f, MonadGet m) => m (f a)
gserializeLE :: (GSerialEndian f, MonadPut m) => f a -> m ()
gdeserializeLE :: (GSerialEndian f, MonadGet m) => m (f a)

-- | Used internally to provide generic serialization
class GSerial1 f
gserializeWith :: (GSerial1 f, MonadPut m) => (a -> m ()) -> f a -> m ()
gdeserializeWith :: (GSerial1 f, MonadGet m) => m a -> m (f a)
instance (Serial a, Serial b, Serial c) => Serial2 ((,,,,) a b c)
instance (Serial a, Serial b) => Serial2 ((,,,) a b)
instance Serial a => Serial2 ((,,) a)
instance Serial2 (,)
instance Serial2 Either
instance Serial a => GSerial1 (K1 i a)
instance GSerial1 f => GSerial1 (M1 i c f)
instance (Serial1 f, GSerial1 g) => GSerial1 (f :.: g)
instance (GSerial1 f, GSerial1 g) => GSerial1 (f :+: g)
instance (GSerial1 f, GSerial1 g) => GSerial1 (f :*: g)
instance GSerial1 V1
instance GSerial1 U1
instance Serial1 f => GSerial1 (Rec1 f)
instance GSerial1 Par1
instance (Ord k, Serial k) => Serial1 (Map k)
instance Serial1 IntMap
instance Serial1 Seq
instance (Serial a, Serial b, Serial c, Serial d) => Serial1 ((,,,,) a b c d)
instance (Serial a, Serial b, Serial c) => Serial1 ((,,,) a b c)
instance (Serial a, Serial b) => Serial1 ((,,) a b)
instance Serial a => Serial1 ((,) a)
instance Serial a => Serial1 (Either a)
instance Serial1 Maybe
instance Serial1 []
instance SerialEndian a => GSerialEndian (K1 i a)
instance Serial a => GSerial (K1 i a)
instance GSerial f => GSerial (M1 i c f)
instance (GSerial f, GSerial g) => GSerial (f :+: g)
instance (GSerial f, GSerial g) => GSerial (f :*: g)
instance GSerial V1
instance GSerial U1
instance Serial a => Serial (Last a)
instance Serial a => Serial (First a)
instance Serial a => Serial (Product a)
instance Serial a => Serial (Sum a)
instance Serial Any
instance Serial All
instance Serial a => Serial (Dual a)
instance Serial (f a) => Serial (Reverse f a)
instance (Serial (f a), Serial (g a)) => Serial (Product f g a)
instance Serial a => Serial (Constant a b)
instance Serial a => Serial (Identity a)
instance Serial a => Serial (ZipList a)
instance Serial Version
instance Serial a => Serial (Down a)
instance Serial Ordering
instance Serial ZonedTime
instance Serial LocalTime
instance Serial TimeOfDay
instance Serial TimeZone
instance Serial UniversalTime
instance (Serial a, Integral a) => Serial (Ratio a)
instance Serial AbsoluteTime
instance Serial UTCTime
instance Serial Day
instance Serial NominalDiffTime
instance Serial DiffTime
instance HasResolution a => Serial (Fixed a)
instance Serial Integer
instance (Bits n, Integral n, Bits (Unsigned n), Integral (Unsigned n)) => Serial (VarInt n)
instance (Serial k, Serial v, Ord k) => Serial (Map k v)
instance Serial v => Serial (IntMap v)
instance (Serial a, Ord a) => Serial (Set a)
instance Serial a => Serial (Seq a)
instance Serial IntSet
instance Serial Void
instance Serial Int8
instance Serial Int16
instance Serial Int32
instance Serial Int64
instance Serial Int
instance Serial Word8
instance Serial Word16
instance Serial Word32
instance Serial Word64
instance Serial Word
instance Serial Char
instance Serial Float
instance Serial Double
instance Serial Bool
instance (Serial a, Serial b, Serial c, Serial d, Serial e) => Serial (a, b, c, d, e)
instance (Serial a, Serial b, Serial c, Serial d) => Serial (a, b, c, d)
instance (Serial a, Serial b, Serial c) => Serial (a, b, c)
instance (Serial a, Serial b) => Serial (a, b)
instance (Serial a, Serial b) => Serial (Either a b)
instance Serial a => Serial (Maybe a)
instance Serial a => Serial [a]
instance Serial ()
instance Serial Text
instance Serial Text
instance Serial ByteString
instance Serial ByteString
instance SerialEndian Int16
instance SerialEndian Int32
instance SerialEndian Int64
instance SerialEndian Word16
instance SerialEndian Word32
instance SerialEndian Word64
instance SerialEndian Char
instance SerialEndian Float
instance SerialEndian Double
