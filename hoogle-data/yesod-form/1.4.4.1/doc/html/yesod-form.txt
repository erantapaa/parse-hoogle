-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Form handling support for Yesod Web Framework
--   
--   API docs and the README are available at
--   <a>http://www.stackage.org/package/yesod-form</a>
@package yesod-form
@version 1.4.4.1

module Yesod.Form.Types

-- | The encoding type required by a form. The <tt>ToHtml</tt> instance
--   produces values that can be inserted directly into HTML.
data Enctype
UrlEncoded :: Enctype
Multipart :: Enctype

-- | A form can produce three different results: there was no data
--   available, the data was invalid, or there was a successful parse.
--   
--   The <a>Applicative</a> instance will concatenate the failure messages
--   in two <a>FormResult</a>s.
data FormResult a
FormMissing :: FormResult a
FormFailure :: [Text] -> FormResult a
FormSuccess :: a -> FormResult a
data FormMessage
MsgInvalidInteger :: Text -> FormMessage
MsgInvalidNumber :: Text -> FormMessage
MsgInvalidEntry :: Text -> FormMessage
MsgInvalidUrl :: Text -> FormMessage
MsgInvalidEmail :: Text -> FormMessage
MsgInvalidTimeFormat :: FormMessage
MsgInvalidHour :: Text -> FormMessage
MsgInvalidMinute :: Text -> FormMessage
MsgInvalidSecond :: Text -> FormMessage
MsgInvalidDay :: FormMessage
MsgCsrfWarning :: FormMessage
MsgValueRequired :: FormMessage
MsgInputNotFound :: Text -> FormMessage
MsgSelectNone :: FormMessage
MsgInvalidBool :: Text -> FormMessage
MsgBoolYes :: FormMessage
MsgBoolNo :: FormMessage
MsgDelete :: FormMessage
type Env = Map Text [Text]
type FileEnv = Map Text [FileInfo]
data Ints
IntCons :: Int -> Ints -> Ints
IntSingle :: Int -> Ints
type MForm m a = RWST (Maybe (Env, FileEnv), HandlerSite m, [Lang]) Enctype Ints m a
newtype AForm m a
AForm :: ((HandlerSite m, [Text]) -> Maybe (Env, FileEnv) -> Ints -> m (FormResult a, [FieldView (HandlerSite m)] -> [FieldView (HandlerSite m)], Ints, Enctype)) -> AForm m a
unAForm :: AForm m a -> (HandlerSite m, [Text]) -> Maybe (Env, FileEnv) -> Ints -> m (FormResult a, [FieldView (HandlerSite m)] -> [FieldView (HandlerSite m)], Ints, Enctype)
data Field m a
Field :: ([Text] -> [FileInfo] -> m (Either (SomeMessage (HandlerSite m)) (Maybe a))) -> FieldViewFunc m a -> Enctype -> Field m a
fieldParse :: Field m a -> [Text] -> [FileInfo] -> m (Either (SomeMessage (HandlerSite m)) (Maybe a))
fieldView :: Field m a -> FieldViewFunc m a
fieldEnctype :: Field m a -> Enctype
data FieldSettings master
FieldSettings :: SomeMessage master -> Maybe (SomeMessage master) -> Maybe Text -> Maybe Text -> [(Text, Text)] -> FieldSettings master
fsLabel :: FieldSettings master -> SomeMessage master
fsTooltip :: FieldSettings master -> Maybe (SomeMessage master)
fsId :: FieldSettings master -> Maybe Text
fsName :: FieldSettings master -> Maybe Text
fsAttrs :: FieldSettings master -> [(Text, Text)]
data FieldView site
FieldView :: Markup -> Maybe Markup -> Text -> WidgetT site IO () -> Maybe Markup -> Bool -> FieldView site
fvLabel :: FieldView site -> Markup
fvTooltip :: FieldView site -> Maybe Markup
fvId :: FieldView site -> Text
fvInput :: FieldView site -> WidgetT site IO ()
fvErrors :: FieldView site -> Maybe Markup
fvRequired :: FieldView site -> Bool
type FieldViewFunc m a = Text -> Text -> [(Text, Text)] -> Either Text a -> Bool -> WidgetT (HandlerSite m) IO ()
instance Show a => Show (FormResult a)
instance Eq Enctype
instance Enum Enctype
instance Bounded Enctype
instance Show FormMessage
instance Eq FormMessage
instance Read FormMessage
instance IsString (FieldSettings a)
instance MonadTrans AForm
instance (Monad m, Semigroup a) => Semigroup (AForm m a)
instance (Monad m, Monoid a) => Monoid (AForm m a)
instance Monad m => Applicative (AForm m)
instance Monad m => Functor (AForm m)
instance Show Ints
instance Semigroup Enctype
instance Monoid Enctype
instance ToMarkup Enctype
instance Semigroup m => Semigroup (FormResult m)
instance Monoid m => Monoid (FormResult m)
instance Applicative FormResult
instance Functor FormResult

module Yesod.Form.Functions

-- | Get a unique identifier.
newFormIdent :: Monad m => MForm m Text
askParams :: Monad m => MForm m (Maybe Env)
askFiles :: Monad m => MForm m (Maybe FileEnv)
formToAForm :: (HandlerSite m ~ site, Monad m) => MForm m (FormResult a, [FieldView site]) -> AForm m a
aFormToForm :: (Monad m, HandlerSite m ~ site) => AForm m a -> MForm m (FormResult a, [FieldView site] -> [FieldView site])

-- | Converts a form field into monadic form. This field requires a value
--   and will return <a>FormFailure</a> if left empty.
mreq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> MForm m (FormResult a, FieldView site)

-- | Converts a form field into monadic form. This field is optional, i.e.
--   if filled in, it returns 'Just a', if left empty, it returns
--   <a>Nothing</a>. Arguments are the same as for <a>mreq</a> (apart from
--   type of default value).
mopt :: (site ~ HandlerSite m, MonadHandler m) => Field m a -> FieldSettings site -> Maybe (Maybe a) -> MForm m (FormResult (Maybe a), FieldView site)

-- | Applicative equivalent of <a>mreq</a>.
areq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> AForm m a

-- | Applicative equivalent of <a>mopt</a>.
aopt :: MonadHandler m => Field m a -> FieldSettings (HandlerSite m) -> Maybe (Maybe a) -> AForm m (Maybe a)

-- | This function is used to both initially render a form and to later
--   extract results from it. Note that, due to CSRF protection and a few
--   other issues, forms submitted via GET and POST are slightly different.
--   As such, be sure to call the relevant function based on how the form
--   will be submitted, <i>not</i> the current request method.
--   
--   For example, a common case is displaying a form on a GET request and
--   having the form submit to a POST page. In such a case, both the GET
--   and POST handlers should use <a>runFormPost</a>.
runFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadResource m, MonadHandler m) => (Markup -> MForm m (FormResult a, xml)) -> m ((FormResult a, xml), Enctype)
runFormPostNoToken :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)
runFormGet :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)

-- | Similar to <a>runFormPost</a>, except it always ignores the currently
--   available environment. This is necessary in cases like a wizard UI,
--   where a single page will both receive and incoming form and produce a
--   new, blank form. For general usage, you can stick with
--   <tt>runFormPost</tt>.
generateFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m) => (Markup -> MForm m (FormResult a, xml)) -> m (xml, Enctype)

-- | Since 1.3.11
generateFormGet' :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m) => (Markup -> MForm m (FormResult a, xml)) -> m (xml, Enctype)

-- | <i>Deprecated: Will require RenderMessage in next version of Yesod</i>
generateFormGet :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)

-- | Creates a hidden field on the form that identifies it. This
--   identification is then used to distinguish between <i>missing</i> and
--   <i>wrong</i> form data when a single handler contains more than one
--   form.
--   
--   For instance, if you have the following code on your handler:
--   
--   <pre>
--   ((fooRes, fooWidget), fooEnctype) &lt;- runFormPost fooForm
--   ((barRes, barWidget), barEnctype) &lt;- runFormPost barForm
--   </pre>
--   
--   Then replace it with
--   
--   <pre>
--   ((fooRes, fooWidget), fooEnctype) &lt;- runFormPost $ identifyForm "foo" fooForm
--   ((barRes, barWidget), barEnctype) &lt;- runFormPost $ identifyForm "bar" barForm
--   </pre>
--   
--   Note that it's your responsibility to ensure that the identification
--   strings are unique (using the same one twice on a single handler will
--   not generate any errors). This allows you to create a variable number
--   of forms and still have them work even if their number or order change
--   between the HTML generation and the form submission.
identifyForm :: Monad m => Text -> (Markup -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ())) -> (Markup -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ()))
type FormRender m a = AForm m a -> Markup -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ())

-- | Render a form into a series of tr tags. Note that, in order to allow
--   you to add extra rows to the table, this function does <i>not</i> wrap
--   up the resulting HTML in a table tag; you must do that yourself.
renderTable :: Monad m => FormRender m a

-- | render a field inside a div
renderDivs :: Monad m => FormRender m a

-- | render a field inside a div, not displaying any label
renderDivsNoLabels :: Monad m => FormRender m a

-- | Deprecated synonym for <a>renderBootstrap2</a>.

-- | <i>Deprecated: Please use the Yesod.Form.Bootstrap3 module.</i>
renderBootstrap :: Monad m => FormRender m a

-- | Render a form using Bootstrap v2-friendly shamlet syntax. If you're
--   using Bootstrap v3, then you should use the functions from module
--   <a>Yesod.Form.Bootstrap3</a>.
--   
--   Sample Hamlet:
--   
--   <pre>
--   &lt;form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}&gt;
--     &lt;fieldset&gt;
--       &lt;legend&gt;_{MsgLegend}
--       $case result
--         $of FormFailure reasons
--           $forall reason &lt;- reasons
--             &lt;div .alert .alert-error&gt;#{reason}
--         $of _
--       ^{formWidget}
--       &lt;div .form-actions&gt;
--         &lt;input .btn .primary type=submit value=_{MsgSubmit}&gt;
--   </pre>
--   
--   Since 1.3.14
renderBootstrap2 :: Monad m => FormRender m a
check :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> Either msg a) -> Field m a -> Field m a

-- | Return the given error message if the predicate is false.
checkBool :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> Bool) -> msg -> Field m a -> Field m a
checkM :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> m (Either msg a)) -> Field m a -> Field m a

-- | Same as <a>checkM</a>, but modifies the datatype.
--   
--   In order to make this work, you must provide a function to convert
--   back from the new datatype to the old one (the second argument to this
--   function).
--   
--   Since 1.1.2
checkMMap :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> m (Either msg b)) -> (b -> a) -> Field m a -> Field m b

-- | Allows you to overwrite the error message on parse error.
customErrorMessage :: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a

-- | Generate a <a>FieldSettings</a> from the given label.
fieldSettingsLabel :: RenderMessage site msg => msg -> FieldSettings site

-- | A helper function for creating custom fields.
--   
--   This is intended to help with the common case where a single input
--   value is required, such as when parsing a text field.
--   
--   Since 1.1
parseHelper :: (Monad m, RenderMessage site FormMessage) => (Text -> Either FormMessage a) -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))

-- | A generalized version of <a>parseHelper</a>, allowing any type for the
--   message indicating a bad parse.
--   
--   Since 1.3.6
parseHelperGen :: (Monad m, RenderMessage site msg) => (Text -> Either msg a) -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))

-- | Since a <a>Field</a> cannot be a <a>Functor</a>, it is not obvious how
--   to "reuse" a Field on a <tt>newtype</tt> or otherwise equivalent type.
--   This function allows you to convert a <tt>Field m a</tt> to a
--   <tt>Field m b</tt> assuming you provide a bidireccional convertion
--   among the two, through the first two functions.
--   
--   A simple example:
--   
--   <pre>
--   import Data.Monoid
--   sumField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) =&gt; Field m (Sum Int)
--   sumField = convertField Sum getSum intField
--   </pre>
--   
--   Another example, not using a newtype, but instead creating a Lazy Text
--   field:
--   
--   <pre>
--   import qualified Data.Text.Lazy as TL
--   TextField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) =&gt; Field m TL.Text
--   lazyTextField = convertField TL.fromStrict TL.toStrict textField
--   </pre>
--   
--   Since 1.3.16
convertField :: Functor m => (a -> b) -> (b -> a) -> Field m a -> Field m b


-- | Provides for getting input from either GET or POST params without
--   generating HTML forms. For more information, see:
--   <a>http://www.yesodweb.com/book/forms#forms_kinds_of_forms</a>.
module Yesod.Form.Input

-- | Type for a form which parses a value of type <tt>a</tt> with the base
--   monad <tt>m</tt> (usually your <tt>Handler</tt>). Can can compose this
--   using its <tt>Applicative</tt> instance.
newtype FormInput m a
FormInput :: (HandlerSite m -> [Text] -> Env -> FileEnv -> m (Either DText a)) -> FormInput m a
unFormInput :: FormInput m a -> HandlerSite m -> [Text] -> Env -> FileEnv -> m (Either DText a)

-- | Run a <tt>FormInput</tt> on the GET parameters (i.e., query string).
--   If parsing fails, calls <a>invalidArgs</a>.
runInputGet :: MonadHandler m => FormInput m a -> m a

-- | Run a <tt>FormInput</tt> on the GET parameters (i.e., query string).
--   Does <i>not</i> throw exceptions on failure.
--   
--   Since 1.4.1
runInputGetResult :: MonadHandler m => FormInput m a -> m (FormResult a)

-- | Run a <tt>FormInput</tt> on the POST parameters (i.e., request body).
--   If parsing fails, calls <a>invalidArgs</a>.
runInputPost :: MonadHandler m => FormInput m a -> m a

-- | Run a <tt>FormInput</tt> on the POST parameters (i.e., request body).
--   Does <i>not</i> throw exceptions on failure.
runInputPostResult :: MonadHandler m => FormInput m a -> m (FormResult a)

-- | Promote a <tt>Field</tt> into a <tt>FormInput</tt>, requiring that the
--   value be present and valid.
ireq :: (Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m a -> Text -> FormInput m a

-- | Promote a <tt>Field</tt> into a <tt>FormInput</tt>, with its presence
--   being optional. If the value is present but does not parse correctly,
--   the form will still fail.
iopt :: Monad m => Field m a -> Text -> FormInput m (Maybe a)
instance Monad m => Applicative (FormInput m)
instance Monad m => Functor (FormInput m)


-- | Helper functions for creating forms when using <a>Bootstrap 3</a>.
module Yesod.Form.Bootstrap3

-- | Render the given form using Bootstrap v3 conventions.
--   
--   Since: yesod-form 1.3.8
renderBootstrap3 :: Monad m => BootstrapFormLayout -> FormRender m a

-- | The layout used for the bootstrap form.
--   
--   Since: yesod-form 1.3.8
data BootstrapFormLayout

-- | A form with labels and inputs listed vertically. See
--   <a>http://getbootstrap.com/css/#forms-example</a>
BootstrapBasicForm :: BootstrapFormLayout

-- | A form whose <tt>&lt;inputs&gt;</tt> are laid out horizontally
--   (displayed as <tt>inline-block</tt>). For this layout,
--   <tt>&lt;label&gt;</tt>s are still added to the HTML, but are hidden
--   from display. When using this layout, you must add the
--   <tt>form-inline</tt> class to your form tag. See
--   <a>http://getbootstrap.com/css/#forms-inline</a>
BootstrapInlineForm :: BootstrapFormLayout

-- | A form laid out using the Bootstrap grid, with labels in the left
--   column and inputs on the right. When using this layout, you must add
--   the <tt>form-horizontal</tt> class to your form tag. Bootstrap
--   requires additional markup for the submit button for horizontal forms;
--   you can use <a>bootstrapSubmit</a> in your form or write the markup
--   manually. See <a>http://getbootstrap.com/css/#forms-horizontal</a>
BootstrapHorizontalForm :: !BootstrapGridOptions -> !BootstrapGridOptions -> !BootstrapGridOptions -> !BootstrapGridOptions -> BootstrapFormLayout

-- | The left <a>offset</a> of the <tt>&lt;label&gt;</tt>.
bflLabelOffset :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The number of grid columns the <tt>&lt;label&gt;</tt> should use.
bflLabelSize :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The left <a>offset</a> of the <tt>&lt;input&gt;</tt> from its
--   <tt>&lt;label&gt;</tt>.
bflInputOffset :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The number of grid columns the <tt>&lt;input&gt;</tt> should use.
bflInputSize :: BootstrapFormLayout -> !BootstrapGridOptions

-- | How many bootstrap grid columns should be taken (see
--   <a>BootstrapFormLayout</a>).
--   
--   Since: yesod-form 1.3.8
data BootstrapGridOptions
ColXs :: !Int -> BootstrapGridOptions
ColSm :: !Int -> BootstrapGridOptions
ColMd :: !Int -> BootstrapGridOptions
ColLg :: !Int -> BootstrapGridOptions

-- | Create a new <a>FieldSettings</a> with the <tt>form-control</tt> class
--   that is required by Bootstrap v3.
--   
--   Since: yesod-form 1.3.8
bfs :: RenderMessage site msg => msg -> FieldSettings site

-- | Add a placeholder attribute to a field. If you need i18n for the
--   placeholder, currently you'll need to do a hack and use
--   <a>getMessageRender</a> manually.
--   
--   Since: yesod-form 1.3.8
withPlaceholder :: Text -> FieldSettings site -> FieldSettings site

-- | Add an autofocus attribute to a field.
--   
--   Since: yesod-form 1.3.8
withAutofocus :: FieldSettings site -> FieldSettings site

-- | Add the <tt>input-lg</tt> CSS class to a field.
--   
--   Since: yesod-form 1.3.8
withLargeInput :: FieldSettings site -> FieldSettings site

-- | Add the <tt>input-sm</tt> CSS class to a field.
--   
--   Since: yesod-form 1.3.8
withSmallInput :: FieldSettings site -> FieldSettings site

-- | A Bootstrap v3 submit button disguised as a field for convenience. For
--   example, if your form currently is:
--   
--   <pre>
--   Person &lt;$&gt; areq textField "Name"    Nothing
--          &lt;*&gt; areq textField "Surname" Nothing
--   </pre>
--   
--   Then just change it to:
--   
--   <pre>
--   Person &lt;$&gt; areq textField "Name"    Nothing
--          &lt;*&gt; areq textField "Surname" Nothing
--          &lt;*  bootstrapSubmit ("Register" :: BootstrapSubmit Text)
--   </pre>
--   
--   (Note that <tt>&lt;*</tt> is not a typo.)
--   
--   Alternatively, you may also just create the submit button manually as
--   well in order to have more control over its layout.
--   
--   Since: yesod-form 1.3.8
bootstrapSubmit :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => BootstrapSubmit msg -> AForm m ()

-- | Same as <a>bootstrapSubmit</a> but for monadic forms. This isn't as
--   useful since you're not going to use <a>renderBootstrap3</a> anyway.
--   
--   Since: yesod-form 1.3.8
mbootstrapSubmit :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => BootstrapSubmit msg -> MForm m (FormResult (), FieldView site)

-- | How the <a>bootstrapSubmit</a> button should be rendered.
--   
--   Since: yesod-form 1.3.8
data BootstrapSubmit msg
BootstrapSubmit :: msg -> Text -> [(Text, Text)] -> BootstrapSubmit msg

-- | The text of the submit button.
bsValue :: BootstrapSubmit msg -> msg

-- | Classes added to the <tt>&lt;button&gt;</tt>.
bsClasses :: BootstrapSubmit msg -> Text

-- | Attributes added to the <tt>&lt;button&gt;</tt>.
bsAttrs :: BootstrapSubmit msg -> [(Text, Text)]
instance Eq BootstrapGridOptions
instance Ord BootstrapGridOptions
instance Show BootstrapGridOptions
instance Show BootstrapFormLayout
instance Show msg => Show (BootstrapSubmit msg)
instance IsString msg => IsString (BootstrapSubmit msg)

module Yesod.Form.I18n.English
englishFormMessage :: FormMessage -> Text


-- | Field functions allow you to easily create and validate forms, cleanly
--   handling the uncertainty of parsing user input.
--   
--   When possible, the field functions use a specific input type (e.g.
--   "number"), allowing supporting browsers to validate the input before
--   form submission. Browsers can also improve usability with this
--   information; for example, mobile browsers might present a specialized
--   keyboard for an input of type "email" or "number".
--   
--   See the Yesod book <a>chapter on forms</a> for a broader overview of
--   forms in Yesod.
module Yesod.Form.Fields
data FormMessage
MsgInvalidInteger :: Text -> FormMessage
MsgInvalidNumber :: Text -> FormMessage
MsgInvalidEntry :: Text -> FormMessage
MsgInvalidUrl :: Text -> FormMessage
MsgInvalidEmail :: Text -> FormMessage
MsgInvalidTimeFormat :: FormMessage
MsgInvalidHour :: Text -> FormMessage
MsgInvalidMinute :: Text -> FormMessage
MsgInvalidSecond :: Text -> FormMessage
MsgInvalidDay :: FormMessage
MsgCsrfWarning :: FormMessage
MsgValueRequired :: FormMessage
MsgInputNotFound :: Text -> FormMessage
MsgSelectNone :: FormMessage
MsgInvalidBool :: Text -> FormMessage
MsgBoolYes :: FormMessage
MsgBoolNo :: FormMessage
MsgDelete :: FormMessage
defaultFormMessage :: FormMessage -> Text

-- | Creates a input with <tt>type="text"</tt>.
textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="password"</tt>.
passwordField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose returned value is
--   wrapped in a <a>Textarea</a>; see <a>Textarea</a> for details.
textareaField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Textarea

-- | Creates an input with <tt>type="hidden"</tt>; you can use this to
--   store information in a form that users shouldn't see (for example,
--   Yesod stores CSRF tokens in a hidden field).
hiddenField :: (Monad m, PathPiece p, RenderMessage (HandlerSite m) FormMessage) => Field m p

-- | Creates a input with <tt>type="number"</tt> and <tt>step=1</tt>.
intField :: (Monad m, Integral i, RenderMessage (HandlerSite m) FormMessage) => Field m i

-- | Creates an input with <tt>type="date"</tt>, validating the input using
--   the <a>parseDate</a> function.
--   
--   Add the <tt>time</tt> package and import the <a>Data.Time.Calendar</a>
--   module to use this function.
dayField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Day

-- | An alias for <a>timeFieldTypeText</a>.

-- | <i>Deprecated: <a>timeField</a> currently defaults to an input of
--   type="text". In the next major release, it will default to
--   type="time". To opt in to the new functionality, use
--   <a>timeFieldTypeTime</a>. To keep the existing behavior, use
--   <a>timeFieldTypeText</a>. See
--   'https://github.com/yesodweb/yesod/pull/874' for details.</i>
timeField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="time"</tt>. <a>Browsers not supporting
--   this type</a> will fallback to a text field, and Yesod will parse the
--   time as described in <a>timeFieldTypeText</a>.
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeTime :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="text"</tt>, parsing the time from an
--   [H]H:MM[:SS] format, with an optional AM or PM (if not given, AM is
--   assumed for compatibility with the 24 hour clock system).
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeText :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose input is sanitized to
--   prevent XSS attacks and is validated for having balanced tags.
htmlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Html

-- | Creates an input with <tt>type="email"</tt>. Yesod will validate the
--   email's correctness according to RFC5322 and canonicalize it by
--   removing comments and whitespace (see <a>Text.Email.Validate</a>).
emailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="email"</tt> with the <a>multiple</a>
--   attribute; browsers might implement this as taking a comma separated
--   list of emails. Each email address is validated as described in
--   <a>emailField</a>.
--   
--   Since 1.3.7
multiEmailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m [Text]

-- | Creates an input with <tt>type="search"</tt>. For <a>browsers without
--   autofocus support</a>, a JS fallback is used if <tt>AutoFocus</tt> is
--   true.
searchField :: Monad m => RenderMessage (HandlerSite m) FormMessage => AutoFocus -> Field m Text
type AutoFocus = Bool

-- | Creates an input with <tt>type="url"</tt>, validating the URL
--   according to RFC3986.
urlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates a input with <tt>type="number"</tt> and <tt>step=any</tt>.
doubleField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Double

-- | Parses a <a>Day</a> from a <a>String</a>.
parseDate :: String -> Either FormMessage Day
parseTime :: Text -> Either FormMessage TimeOfDay

-- | A newtype wrapper around a <a>Text</a> whose <a>ToMarkup</a> instance
--   converts newlines to HTML <tt>&lt;br&gt;</tt> tags.
--   
--   (When text is entered into a <tt>&lt;textarea&gt;</tt>, newline
--   characters are used to separate lines. If this text is then placed
--   verbatim into HTML, the lines won't be separated, thus the need for
--   replacing with <tt>&lt;br&gt;</tt> tags). If you don't need this
--   functionality, simply use <a>unTextarea</a> to access the raw text.
newtype Textarea
Textarea :: Text -> Textarea
unTextarea :: Textarea -> Text

-- | Creates a group of radio buttons to answer the question given in the
--   message. Radio buttons are used to allow differentiating between an
--   empty response (<tt>Nothing</tt>) and a no response (<tt>Just
--   False</tt>). Consider using the simpler <a>checkBoxField</a> if you
--   don't need to make this distinction.
--   
--   If this field is optional, the first radio button is labeled
--   "&lt;None&gt;", the second "Yes" and the third "No".
--   
--   If this field is required, the first radio button is labeled "Yes" and
--   the second "No".
--   
--   (Exact label titles will depend on localization).
boolField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool

-- | Creates an input with <tt>type="checkbox"</tt>. While the default
--   <tt><a>boolField</a></tt> implements a radio button so you can
--   differentiate between an empty response (<tt>Nothing</tt>) and a no
--   response (<tt>Just False</tt>), this simpler checkbox field returns an
--   empty response as <tt>Just False</tt>.
--   
--   Note that this makes the field always optional.
checkBoxField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool

-- | Creates an input with <tt>type="file"</tt>.
fileField :: (Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m FileInfo
fileAFormReq :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage) => FieldSettings (HandlerSite m) -> AForm m FileInfo
fileAFormOpt :: MonadHandler m => RenderMessage (HandlerSite m) FormMessage => FieldSettings (HandlerSite m) -> AForm m (Maybe FileInfo)

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectField $ optionsPairs [(MsgValue1, "value1"),(MsgValue2, "value2")]) "Which value?" Nothing
--   </pre>
selectField :: (Eq a, RenderMessage site FormMessage) => HandlerT site IO (OptionList a) -> Field (HandlerT site IO) a

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectFieldList [("Value 1" :: Text, "value1"),("Value 2", "value2")]) "Which value?" Nothing
--   </pre>
selectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerT site IO) a

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioField :: (Eq a, RenderMessage site FormMessage) => HandlerT site IO (OptionList a) -> Field (HandlerT site IO) a

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerT site IO) a

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesField :: (Eq a, RenderMessage site FormMessage) => HandlerT site IO (OptionList a) -> Field (HandlerT site IO) [a]

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerT site IO) [a]

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectField :: (Eq a, RenderMessage site FormMessage) => HandlerT site IO (OptionList a) -> Field (HandlerT site IO) [a]

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerT site IO) [a]
data Option a
Option :: Text -> a -> Text -> Option a

-- | The user-facing label.
optionDisplay :: Option a -> Text

-- | The Haskell value being selected.
optionInternalValue :: Option a -> a

-- | The representation of this value stored in the form.
optionExternalValue :: Option a -> Text

-- | A structure holding a list of options. Typically you can use a
--   convenience function like <a>mkOptionList</a> or <a>optionsPairs</a>
--   instead of creating this directly.
data OptionList a
OptionList :: [Option a] -> (Text -> Maybe a) -> OptionList a
olOptions :: OptionList a -> [Option a]

-- | A function mapping from the form's value (<a>optionExternalValue</a>)
--   to the selected Haskell value (<a>optionInternalValue</a>).
olReadExternal :: OptionList a -> Text -> Maybe a

-- | Creates an <a>OptionList</a>, using a <tt>Map</tt> to implement the
--   <a>olReadExternal</a> function.
mkOptionList :: [Option a] -> OptionList a

-- | Selects a list of <a>Entity</a>s with the given <a>Filter</a> and
--   <a>SelectOpt</a>s. The <tt>(a -&gt; msg)</tt> function is then used to
--   derive the display value for an <a>OptionList</a>. Example usage:
--   
--   <pre>
--   Country
--      name Text
--      deriving Eq -- Must derive Eq
--   </pre>
--   
--   <pre>
--   data CountryForm = CountryForm
--     { country :: Entity Country
--     }
--   
--   countryNameForm :: AForm Handler CountryForm
--   countryNameForm = CountryForm
--           &lt;$&gt; areq (selectField countries) "Which country do you live in?" Nothing
--           where
--             countries = optionsPersist [] [Asc CountryName] countryName
--   </pre>
optionsPersist :: (YesodPersist site, PersistEntity a, PersistQuery (PersistEntityBackend a), PathPiece (Key a), RenderMessage site msg, YesodPersistBackend site ~ PersistEntityBackend a) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerT site IO (OptionList (Entity a))

-- | An alternative to <a>optionsPersist</a> which returns just the
--   <a>Key</a> instead of the entire <a>Entity</a>.
--   
--   Since 1.3.2
optionsPersistKey :: (YesodPersist site, PersistEntity a, PersistQuery (PersistEntityBackend a), PathPiece (Key a), RenderMessage site msg, YesodPersistBackend site ~ PersistEntityBackend a) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerT site IO (OptionList (Key a))

-- | Creates an <a>OptionList</a> from a list of (display-value, internal
--   value) pairs.
optionsPairs :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => [(msg, a)] -> m (OptionList a)

-- | Creates an <a>OptionList</a> from an <a>Enum</a>, using its
--   <a>Show</a> instance for the user-facing value.
optionsEnum :: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
instance Show Textarea
instance Read Textarea
instance Eq Textarea
instance PersistField Textarea
instance Ord Textarea
instance ToJSON Textarea
instance FromJSON Textarea
instance ToMarkup Textarea
instance PersistFieldSql Textarea

module Yesod.Form.MassInput
inputList :: (m ~ HandlerT site IO, xml ~ WidgetT site IO (), RenderMessage site FormMessage) => Html -> ([[FieldView site]] -> xml) -> (Maybe a -> AForm (HandlerT site IO) a) -> (Maybe [a] -> AForm (HandlerT site IO) [a])
massDivs :: [[FieldView site]] -> WidgetT site IO ()
massTable :: [[FieldView site]] -> WidgetT site IO ()

module Yesod.Form.I18n.Portuguese
portugueseFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Swedish
swedishFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.German
germanFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.French
frenchFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Norwegian
norwegianBokmålFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Japanese
japaneseFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Czech
czechFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Russian
russianFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Dutch
dutchFormMessage :: FormMessage -> Text


-- | Parse forms (and query strings).
module Yesod.Form


-- | Some fields spiced up with jQuery UI.
module Yesod.Form.Jquery
class YesodJquery a where urlJqueryJs _ = Right "//ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js" urlJqueryUiJs _ = Right "//ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js" urlJqueryUiCss _ = Right $ googleHostedJqueryUiCss "cupertino" urlJqueryUiDateTimePicker _ = Right "http://github.com/gregwebs/jquery.ui.datetimepicker/raw/master/jquery.ui.datetimepicker.js"
urlJqueryJs :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiJs :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiCss :: YesodJquery a => a -> Either (Route a) Text
urlJqueryUiDateTimePicker :: YesodJquery a => a -> Either (Route a) Text
jqueryDayField :: (RenderMessage site FormMessage, YesodJquery site) => JqueryDaySettings -> Field (HandlerT site IO) Day

-- | Use jQuery's datepicker as the underlying implementation.
--   
--   Since 1.4.3
jqueryDatePickerDayField :: (RenderMessage site FormMessage, YesodJquery site) => JqueryDaySettings -> Field (HandlerT site IO) Day
jqueryAutocompleteField :: (RenderMessage site FormMessage, YesodJquery site) => Route site -> Field (HandlerT site IO) Text
jqueryAutocompleteField' :: (RenderMessage site FormMessage, YesodJquery site) => Int -> Route site -> Field (HandlerT site IO) Text

-- | Gets the Google hosted jQuery UI 1.8 CSS file with the given theme.
googleHostedJqueryUiCss :: Text -> Text
data JqueryDaySettings
JqueryDaySettings :: Bool -> Bool -> String -> Either Int (Int, Int) -> JqueryDaySettings
jdsChangeMonth :: JqueryDaySettings -> Bool
jdsChangeYear :: JqueryDaySettings -> Bool
jdsYearRange :: JqueryDaySettings -> String
jdsNumberOfMonths :: JqueryDaySettings -> Either Int (Int, Int)
class Default a
def :: Default a => a
instance Default JqueryDaySettings


-- | Provide the user with a rich text editor.
module Yesod.Form.Nic
class Yesod a => YesodNic a where urlNicEdit _ = Right "http://js.nicedit.com/nicEdit-latest.js"
urlNicEdit :: YesodNic a => a -> Either (Route a) Text
nicHtmlField :: YesodNic site => Field (HandlerT site IO) Html
