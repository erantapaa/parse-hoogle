-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Explicitly typed, checked exceptions with stack traces
--   
@package control-monad-exception
@version 0.11.2


-- | Defines the <tt>Throws</tt> binary relationship between types.
module Control.Monad.Exception.Throws

-- | <tt>Throws</tt> is a type level binary relationship used to model a
--   list of exceptions.
--   
--   There is only one case in which the user must add further instances to
--   <tt>Throws</tt>. If your sets of exceptions are hierarchical then you
--   need to teach <a>Throws</a> about the hierarchy.
--   
--   <ul>
--   <li><i><i>Subtyping</i></i> As there is no way to automatically infer
--   the subcases of an exception, they have to be encoded manually
--   mirroring the hierarchy defined in the defined <a>Exception</a>
--   instances. For example, the following instance encodes that
--   <tt>MyFileNotFoundException</tt> is a subexception of
--   <tt>MyIOException</tt> :</li>
--   </ul>
--   
--   <pre>
--   instance Throws MyFileNotFoundException (Caught MyIOException l)
--   </pre>
--   
--   <a>Throws</a> is not a transitive relation and every ancestor relation
--   must be explicitly encoded.
--   
--   <pre>
--                                                            --   TopException
--                                                            --         |
--   instance Throws MidException   (Caught TopException l)   --         |
--                                                            --   MidException
--   instance Throws ChildException (Caught MidException l)   --         |
--   instance Throws ChildException (Caught TopException l)   --         |
--                                                            --  ChildException
--   </pre>
--   
--   Note that <a>SomeException</a> is automatically an ancestor of every
--   other exception type.
class Exception e => Throws e l

-- | A type level witness of a exception handler.
data Caught e l

-- | <tt>CheckedException</tt> adds a phantom type parameter <tt>l</tt> to
--   <tt>SomeException</tt>
newtype CheckedException l
CheckedException :: SomeException -> CheckedException l
checkedException :: CheckedException l -> SomeException
instance [overlap ok] Typeable CheckedException
instance [overlap ok] Show (CheckedException l)
instance [overlap ok] Throws SomeException (Caught SomeException l)
instance [overlap ok] Exception e => Throws e (Caught SomeException l)
instance [overlap ok] Exception e => Throws e (Caught e l)
instance [overlap ok] Throws e l => Throws e (Caught e' l)


-- | Defines the (not so useful anymore) <a>MonadCatch</a> type class.
module Control.Monad.Exception.Catch
class (Monad m, Monad m') => MonadCatch e m m' | e m -> m', e m' -> m where catchWithSrcLoc m h = catch m (h [])
catch :: MonadCatch e m m' => m a -> (e -> m' a) -> m' a
catchWithSrcLoc :: MonadCatch e m m' => m a -> ([String] -> e -> m' a) -> m' a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException
instance [overlap ok] Exception e => MonadCatch e IO IO

module Control.Monad.Exception.Base
type CallTrace = [String]

-- | A Monad Transformer for explicitly typed checked exceptions.
newtype EMT l m a
EMT :: m (Either (CallTrace, CheckedException l) a) -> EMT l m a
unEMT :: EMT l m a -> m (Either (CallTrace, CheckedException l) a)

-- | Run a computation explicitly handling exceptions
tryEMT :: Monad m => EMT AnyException m a -> m (Either SomeException a)
tryEMTWithLoc :: Monad m => EMT AnyException m a -> m (Either (CallTrace, SomeException) a)
runEMTGen :: Monad m => EMT l m a -> m a
data AnyException
data NoExceptions
data ParanoidMode

-- | Run a safe computation
runEMT :: Monad m => EMT NoExceptions m a -> m a

-- | Run a safe computation checking even unchecked
--   (<a>UncaughtException</a>) exceptions
runEMTParanoid :: Monad m => EMT ParanoidMode m a -> m a

-- | The throw primitive
throw :: (Exception e, Throws e l, Monad m) => e -> EMT l m a

-- | Rethrow an exception keeping the call trace
rethrow :: (Throws e l, Monad m) => CallTrace -> e -> EMT l m a
showExceptionWithTrace :: Exception e => [String] -> e -> String

-- | UncaughtException models unchecked exceptions
--   
--   In order to declare an unchecked exception <tt>E</tt>, all that is
--   needed is to make <tt>e</tt> an instance of <a>UncaughtException</a>
--   
--   <pre>
--   instance UncaughtException E
--   </pre>
--   
--   Note that declaring an exception E as unchecked does not automatically
--   turn its children unchecked too. This is a shortcoming of the current
--   encoding.
class Exception e => UncaughtException e

-- | A monad of explicitly typed, checked exceptions
type EM l = EMT l Identity

-- | Run a computation explicitly handling exceptions
tryEM :: EM AnyException a -> Either SomeException a
tryEMWithLoc :: EM AnyException a -> Either (CallTrace, SomeException) a

-- | Run a safe computation
runEM :: EM NoExceptions a -> a

-- | Run a computation checking even unchecked
--   (<tt>UncaughtExceptions</tt>) exceptions
runEMParanoid :: EM ParanoidMode a -> a

-- | <tt>FailException</tt> is thrown by Monad <a>fail</a>
data FailException
FailException :: String -> FailException

-- | <tt>MonadZeroException</tt> is thrown by MonadPlus <a>mzero</a>
data MonadZeroException
MonadZeroException :: MonadZeroException

-- | This function may be used as a value for <a>mplus</a> in
--   <a>MonadPlus</a>
mplusDefault :: Monad m => EMT l m a -> EMT l m a -> EMT l m a
mapLeft :: (a -> b) -> Either a r -> Either b r
instance [overlap ok] Typeable FailException
instance [overlap ok] Typeable MonadZeroException
instance [overlap ok] Show FailException
instance [overlap ok] Show MonadZeroException
instance [overlap ok] MonadIO m => MonadIO (EMT l m)
instance [overlap ok] Exception MonadZeroException
instance [overlap ok] Exception FailException
instance [overlap ok] Throws MonadZeroException l => Alternative (EM l)
instance [overlap ok] Throws MonadZeroException l => MonadPlus (EM l)
instance [overlap ok] UncaughtException SomeException
instance [overlap ok] UncaughtException e => Throws e NoExceptions
instance [overlap ok] MonadFix m => MonadFix (EMT l m)
instance [overlap ok] Monad m => MonadLoc (EMT l m)
instance [overlap ok] MonadTransControl (EMT l)
instance [overlap ok] MonadBaseControl b m => MonadBaseControl b (EMT l m)
instance [overlap ok] MonadBase b m => MonadBase b (EMT l m)
instance [overlap ok] MonadTrans (EMT l)
instance [overlap ok] (Exception e, Throws e l, Monad m) => Failure e (EMT l m)
instance [overlap ok] Monad m => Applicative (EMT l m)
instance [overlap ok] Monad m => Monad (EMT l m)
instance [overlap ok] Monad m => Functor (EMT l m)
instance [overlap ok] Exception e => Throws e AnyException


-- | A monad transformer for explicitly typed checked exceptions with
--   support for asynchronous exception handling. Explicit exceptions are
--   supported by the ideas described in:
--   
--   <ul>
--   <li>Jose Iborra, "Explicitly Typed Exceptions for Haskell", PADL'10,
--   January 2010,
--   <a>http://dl.dropbox.com/s/lgm12trtl0swtra/PADL10.pdf?dl=1</a></li>
--   </ul>
--   
--   The exceptions thrown by a computation are inferred by the typechecker
--   and appear in the type signature of the computation as <a>Throws</a>
--   constraints.
--   
--   Support for asynchronous exceptions is provided by the monad-control
--   package.
--   
--   <i>Example</i>
--   
--   <pre>
--   data DivideByZero = DivideByZero deriving (Show, Typeable)
--   data SumOverflow  = SumOverflow  deriving (Show, Typeable)
--   </pre>
--   
--   <pre>
--   instance Exception DivideByZero
--   instance Exception SumOverflow
--   </pre>
--   
--   <pre>
--   data Expr = Add Expr Expr | Div Expr Expr | Val Double
--   </pre>
--   
--   <pre>
--   eval (Val x)     = return x
--   eval (Add a1 a2) = do
--      v1 &lt;- eval a1
--      v2 &lt;- eval a2
--      let sum = v1 + v2
--      if sum &lt; v1 || sum &lt; v2 then throw SumOverflow else return sum
--   eval (Div a1 a2) = do
--      v1 &lt;- eval a1
--      v2 &lt;- eval a2
--      if v2 == 0 then throw DivideByZero else return (v1 / v2)
--   </pre>
--   
--   GHCi infers the following types
--   
--   <pre>
--   eval                                             :: (Throws DivideByZero l, Throws SumOverflow l) =&gt; Expr -&gt; EM l Double
--   eval `catch` \ (e::DivideByZero) -&gt; return (-1)  :: Throws SumOverflow l =&gt; Expr -&gt; EM l Double
--   runEM(eval `catch` \ (e::SomeException) -&gt; return (-1))
--                                                    :: Expr -&gt; Double
--   </pre>
module Control.Monad.Exception.IO

-- | A monad of explicitly typed, checked exceptions
type EM l = EMT l Identity

-- | Run a computation explicitly handling exceptions
tryEM :: EM AnyException a -> Either SomeException a
tryEMWithLoc :: EM AnyException a -> Either (CallTrace, SomeException) a

-- | Run a safe computation
runEM :: EM NoExceptions a -> a

-- | Run a computation checking even unchecked
--   (<tt>UncaughtExceptions</tt>) exceptions
runEMParanoid :: EM ParanoidMode a -> a

-- | A Monad Transformer for explicitly typed checked exceptions.
newtype EMT l m a
EMT :: m (Either (CallTrace, CheckedException l) a) -> EMT l m a
unEMT :: EMT l m a -> m (Either (CallTrace, CheckedException l) a)
type CallTrace = [String]

-- | Run a computation explicitly handling exceptions
tryEMT :: Monad m => EMT AnyException m a -> m (Either SomeException a)
tryEMTWithLoc :: Monad m => EMT AnyException m a -> m (Either (CallTrace, SomeException) a)

-- | Run a safe computation
runEMT :: Monad m => EMT NoExceptions m a -> m a

-- | Run a safe computation checking even unchecked
--   (<a>UncaughtException</a>) exceptions
runEMTParanoid :: Monad m => EMT ParanoidMode m a -> m a
data AnyException

-- | UncaughtException models unchecked exceptions
--   
--   In order to declare an unchecked exception <tt>E</tt>, all that is
--   needed is to make <tt>e</tt> an instance of <a>UncaughtException</a>
--   
--   <pre>
--   instance UncaughtException E
--   </pre>
--   
--   Note that declaring an exception E as unchecked does not automatically
--   turn its children unchecked too. This is a shortcoming of the current
--   encoding.
class Exception e => UncaughtException e

-- | <tt>Throws</tt> is a type level binary relationship used to model a
--   list of exceptions.
--   
--   There is only one case in which the user must add further instances to
--   <tt>Throws</tt>. If your sets of exceptions are hierarchical then you
--   need to teach <a>Throws</a> about the hierarchy.
--   
--   <ul>
--   <li><i><i>Subtyping</i></i> As there is no way to automatically infer
--   the subcases of an exception, they have to be encoded manually
--   mirroring the hierarchy defined in the defined <a>Exception</a>
--   instances. For example, the following instance encodes that
--   <tt>MyFileNotFoundException</tt> is a subexception of
--   <tt>MyIOException</tt> :</li>
--   </ul>
--   
--   <pre>
--   instance Throws MyFileNotFoundException (Caught MyIOException l)
--   </pre>
--   
--   <a>Throws</a> is not a transitive relation and every ancestor relation
--   must be explicitly encoded.
--   
--   <pre>
--                                                            --   TopException
--                                                            --         |
--   instance Throws MidException   (Caught TopException l)   --         |
--                                                            --   MidException
--   instance Throws ChildException (Caught MidException l)   --         |
--   instance Throws ChildException (Caught TopException l)   --         |
--                                                            --  ChildException
--   </pre>
--   
--   Note that <a>SomeException</a> is automatically an ancestor of every
--   other exception type.
class Exception e => Throws e l

-- | A type level witness of a exception handler.
data Caught e l

-- | The throw primitive
throw :: (Exception e, Throws e l, Monad m) => e -> EMT l m a

-- | Rethrow an exception keeping the call trace
rethrow :: (Throws e l, Monad m) => CallTrace -> e -> EMT l m a

-- | The catch primitive
catch :: (Exception e, MonadBaseControl IO m) => EMT (Caught e l) m a -> (e -> EMT l m a) -> EMT l m a

-- | Catch and exception and observe the stack trace. If on top of the IO
--   monad, this will also capture asynchronous exceptions
catchWithSrcLoc :: (Exception e, MonadBaseControl IO m) => EMT (Caught e l) m a -> (CallTrace -> e -> EMT l m a) -> EMT l m a

-- | Sequence two computations discarding the result of the second one. If
--   the first computation rises an exception, the second computation is
--   run and then the exception is rethrown.
finally :: MonadBaseControl IO m => EMT l m a -> EMT l m b -> EMT l m a

-- | Like finally, but performs the second computation only when the first
--   one rises an exception
onException :: MonadBaseControl IO m => EMT l m a -> EMT l m b -> EMT l m a
bracket :: MonadBaseControl IO m => EMT l m a -> (a -> EMT l m b) -> (a -> EMT l m c) -> EMT l m c

-- | Capture an exception e, wrap it, and rethrow. Keeps the original
--   monadic call trace.
wrapException :: (Exception e, Throws e' l, MonadBaseControl IO m) => (e -> e') -> EMT (Caught e l) m a -> EMT l m a
showExceptionWithTrace :: Exception e => [String] -> e -> String

-- | <tt>FailException</tt> is thrown by Monad <a>fail</a>
data FailException
FailException :: String -> FailException

-- | <tt>MonadZeroException</tt> is thrown by MonadPlus <a>mzero</a>
data MonadZeroException
MonadZeroException :: MonadZeroException

-- | This function may be used as a value for <a>mplus</a> in
--   <a>MonadPlus</a>
mplusDefault :: Monad m => EMT l m a -> EMT l m a -> EMT l m a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
class Monad f => Failure e (f :: * -> *)
failure :: Failure e f => e -> f v
instance [overlap ok] (Exception e, MonadBaseControl IO m) => MonadCatch e (EMT (Caught e l) m) (EMT l m)


-- | A Monad Transformer for explicitly typed checked exceptions, described
--   in detail by:
--   
--   <ul>
--   <li>Jose Iborra, "Explicitly Typed Exceptions for Haskell", PADL'10,
--   January 2010,
--   <a>http://dl.dropbox.com/s/lgm12trtl0swtra/PADL10.pdf?dl=1</a></li>
--   </ul>
--   
--   The exceptions thrown by a computation are inferred by the typechecker
--   and appear in the type signature of the computation as <a>Throws</a>
--   constraints.
--   
--   Exceptions are defined using the extensible exceptions framework of
--   Marlow (documented in <a>Control.Exception</a>):
--   
--   <ul>
--   <li><i>An Extensible Dynamically-Typed Hierarchy of Exceptions</i>, by
--   Simon Marlow, in <i>Haskell '06</i>.</li>
--   </ul>
--   
--   <i>Example</i>
--   
--   <pre>
--   data DivideByZero = DivideByZero deriving (Show, Typeable)
--   data SumOverflow  = SumOverflow  deriving (Show, Typeable)
--   </pre>
--   
--   <pre>
--   instance Exception DivideByZero
--   instance Exception SumOverflow
--   </pre>
--   
--   <pre>
--   data Expr = Add Expr Expr | Div Expr Expr | Val Double
--   </pre>
--   
--   <pre>
--   eval (Val x)     = return x
--   eval (Add a1 a2) = do
--      v1 &lt;- eval a1
--      v2 &lt;- eval a2
--      let sum = v1 + v2
--      if sum &lt; v1 || sum &lt; v2 then throw SumOverflow else return sum
--   eval (Div a1 a2) = do
--      v1 &lt;- eval a1
--      v2 &lt;- eval a2
--      if v2 == 0 then throw DivideByZero else return (v1 / v2)
--   </pre>
--   
--   GHCi infers the following types
--   
--   <pre>
--   eval                                             :: (Throws DivideByZero l, Throws SumOverflow l) =&gt; Expr -&gt; EM l Double
--   eval `catch` \ (e::DivideByZero) -&gt; return (-1)  :: Throws SumOverflow l =&gt; Expr -&gt; EM l Double
--   runEM(eval `catch` \ (e::SomeException) -&gt; return (-1))
--                                                    :: Expr -&gt; Double
--   </pre>
module Control.Monad.Exception.Pure

-- | A monad of explicitly typed, checked exceptions
type EM l = EMT l Identity

-- | Run a computation explicitly handling exceptions
tryEM :: EM AnyException a -> Either SomeException a
tryEMWithLoc :: EM AnyException a -> Either (CallTrace, SomeException) a

-- | Run a safe computation
runEM :: EM NoExceptions a -> a

-- | Run a computation checking even unchecked
--   (<tt>UncaughtExceptions</tt>) exceptions
runEMParanoid :: EM ParanoidMode a -> a

-- | A Monad Transformer for explicitly typed checked exceptions.
newtype EMT l m a
EMT :: m (Either (CallTrace, CheckedException l) a) -> EMT l m a
unEMT :: EMT l m a -> m (Either (CallTrace, CheckedException l) a)
type CallTrace = [String]

-- | Run a computation explicitly handling exceptions
tryEMT :: Monad m => EMT AnyException m a -> m (Either SomeException a)
tryEMTWithLoc :: Monad m => EMT AnyException m a -> m (Either (CallTrace, SomeException) a)

-- | Run a safe computation
runEMT :: Monad m => EMT NoExceptions m a -> m a

-- | Run a safe computation checking even unchecked
--   (<a>UncaughtException</a>) exceptions
runEMTParanoid :: Monad m => EMT ParanoidMode m a -> m a
data AnyException

-- | UncaughtException models unchecked exceptions
--   
--   In order to declare an unchecked exception <tt>E</tt>, all that is
--   needed is to make <tt>e</tt> an instance of <a>UncaughtException</a>
--   
--   <pre>
--   instance UncaughtException E
--   </pre>
--   
--   Note that declaring an exception E as unchecked does not automatically
--   turn its children unchecked too. This is a shortcoming of the current
--   encoding.
class Exception e => UncaughtException e

-- | <tt>Throws</tt> is a type level binary relationship used to model a
--   list of exceptions.
--   
--   There is only one case in which the user must add further instances to
--   <tt>Throws</tt>. If your sets of exceptions are hierarchical then you
--   need to teach <a>Throws</a> about the hierarchy.
--   
--   <ul>
--   <li><i><i>Subtyping</i></i> As there is no way to automatically infer
--   the subcases of an exception, they have to be encoded manually
--   mirroring the hierarchy defined in the defined <a>Exception</a>
--   instances. For example, the following instance encodes that
--   <tt>MyFileNotFoundException</tt> is a subexception of
--   <tt>MyIOException</tt> :</li>
--   </ul>
--   
--   <pre>
--   instance Throws MyFileNotFoundException (Caught MyIOException l)
--   </pre>
--   
--   <a>Throws</a> is not a transitive relation and every ancestor relation
--   must be explicitly encoded.
--   
--   <pre>
--                                                            --   TopException
--                                                            --         |
--   instance Throws MidException   (Caught TopException l)   --         |
--                                                            --   MidException
--   instance Throws ChildException (Caught MidException l)   --         |
--   instance Throws ChildException (Caught TopException l)   --         |
--                                                            --  ChildException
--   </pre>
--   
--   Note that <a>SomeException</a> is automatically an ancestor of every
--   other exception type.
class Exception e => Throws e l

-- | A type level witness of a exception handler.
data Caught e l

-- | The throw primitive
throw :: (Exception e, Throws e l, Monad m) => e -> EMT l m a

-- | Rethrow an exception keeping the call trace
rethrow :: (Throws e l, Monad m) => CallTrace -> e -> EMT l m a

-- | The catch primitive
catch :: (Exception e, Monad m) => EMT (Caught e l) m a -> (e -> EMT l m a) -> EMT l m a

-- | Catch and exception and observe the stack trace. If on top of the IO
--   monad, this will also capture asynchronous exceptions
catchWithSrcLoc :: (Exception e, Monad m) => EMT (Caught e l) m a -> (CallTrace -> e -> EMT l m a) -> EMT l m a

-- | Sequence two computations discarding the result of the second one. If
--   the first computation rises an exception, the second computation is
--   run and then the exception is rethrown.
finally :: Monad m => EMT l m a -> EMT l m b -> EMT l m a

-- | Like finally, but performs the second computation only when the first
--   one rises an exception TODO asynchronous exceptions! This needs to be
--   moved to Monad
onException :: Monad m => EMT l m a -> EMT l m b -> EMT l m a
bracket :: Monad m => EMT l m a -> (a -> EMT l m b) -> (a -> EMT l m c) -> EMT l m c

-- | Capture an exception e, wrap it, and rethrow. Keeps the original
--   monadic call trace.
wrapException :: (Exception e, Throws e' l, Monad m) => (e -> e') -> EMT (Caught e l) m a -> EMT l m a
showExceptionWithTrace :: Exception e => [String] -> e -> String

-- | <tt>FailException</tt> is thrown by Monad <a>fail</a>
data FailException
FailException :: String -> FailException

-- | <tt>MonadZeroException</tt> is thrown by MonadPlus <a>mzero</a>
data MonadZeroException
MonadZeroException :: MonadZeroException

-- | This function may be used as a value for <a>mplus</a> in
--   <a>MonadPlus</a>
mplusDefault :: Monad m => EMT l m a -> EMT l m a -> EMT l m a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable * e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException
type Typeable1 (a :: * -> *) = Typeable (* -> *) a
class Monad f => Failure e (f :: * -> *)
failure :: Failure e f => e -> f v
instance [overlap ok] (Exception e, Monad m) => MonadCatch e (EMT (Caught e l) m) (EMT l m)


-- | A Monad Transformer for explicitly typed checked exceptions, described
--   in detail by:
--   
--   <ul>
--   <li>Jose Iborra, "Explicitly Typed Exceptions for Haskell", PADL'10,
--   January 2010,
--   <a>http://dl.dropbox.com/s/lgm12trtl0swtra/PADL10.pdf?dl=1</a></li>
--   </ul>
--   
--   <a>Control.Monad.Exception.Pure</a> provides the classic, Either based
--   monad, whereas <a>Control.Monad.Exception.IO</a> provides a more
--   advanced IO based monad with the ability to handle asynchronous
--   exceptions as well.
module Control.Monad.Exception
