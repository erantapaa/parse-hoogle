-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict variants of the types provided in base.
--   
--   It is common knowledge that lazy datastructures can lead to
--   space-leaks. This problem is particularly prominent, when using lazy
--   datastructures to store the state of a long-running application in
--   memory. The easiest solution to this problem is to use fully strict
--   types to store such state values. By "fully strict types" we mean
--   types for whose values it holds that, if they are in weak-head normal
--   form, then they are also in normal form. Intuitively, this means that
--   values of fully strict types cannot contain unevaluated thunks.
--   
--   To define a fully strict datatype, one typically uses the following
--   recipe.
--   
--   <ol>
--   <li>Make all fields of every constructor strict; i.e., add a bang to
--   all fields.</li>
--   <li>Use only strict types for the fields of the constructors.</li>
--   </ol>
--   
--   The second requirement is problematic as it rules out the use of the
--   standard Haskell <a>Maybe</a>, <a>Either</a>, and pair types. This
--   library solves this problem by providing strict variants of these
--   types and their corresponding standard support functions and
--   type-class instances.
--   
--   Note that this library does currently not provide fully strict lists.
--   They can be added if they are really required. However, in many cases
--   one probably wants to use unboxed or strict boxed vectors from the
--   <a>vector</a> library
--   (<a>http://hackage.haskell.org/package/vector</a>) instead of strict
--   lists. Moreover, instead of <tt>String</tt>s one probably wants to use
--   strict <tt>Text</tt> values from the <tt>text</tt> library
--   (<a>http://hackage.haskell.org/package/text</a>).
--   
--   This library comes with batteries included; i.e., missing instances
--   for type-classes from the <tt>deepseq</tt>, <tt>binary</tt>,
--   <tt>aeson</tt>, <tt>QuickCheck</tt>, and <tt>lens</tt> packages are
--   included. Of particluar interest is the <tt>Strict</tt> type-class
--   provided by the lens library
--   (<a>http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Iso.html#t:Strict</a>).
--   It is used in the following example to simplify the modification of
--   strict fields.
--   
--   <pre>
--   (-# LANGUAGE TemplateHaskell #-)   -- replace with curly braces,
--   (-# LANGUAGE OverloadedStrings #-) -- the Haddock prologues are a P.I.T.A!
--   
--   import           Control.Lens ( (.=), Strict(strict), from, Iso', makeLenses)
--   import           Control.Monad.State.Strict (State)
--   import qualified Data.Map                   as M
--   import qualified Data.Maybe.Strict          as S
--   import qualified Data.Text                  as T
--   
--   -- | An example of a state record as it could be used in a (very minimal)
--   -- role-playing game.
--   data GameState = GameState
--       ( _gsCooldown :: !(S.Maybe Int)
--       , _gsHealth   :: !Int
--       )  -- replace with curly braces, *grmbl*
--   
--   makeLenses ''GameState
--   
--   -- The isomorphism, which converts a strict field to its lazy variant
--   lazy :: Strict lazy strict =&gt; Iso' strict lazy
--   lazy = from strict
--   
--   type Game = State GameState
--   
--   cast :: T.Text -&gt; Game ()
--   cast spell =
--       gsCooldown.lazy .= M.lookup spell spellDuration
--       -- ... implement remainder of spell-casting ...
--     where
--       spellDuration = M.fromList [("fireball", 5)]
--   </pre>
--   
--   See
--   <a>http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html</a>
--   for a gentle introduction to lenses and state manipulation.
--   
--   Note that this package uses the types provided by the <a>strict</a>
--   package (<a>http://hackage.haskell.org/package/strict</a>), but
--   organizes them a bit differently. More precisely, the
--   <tt>strict-base-types</tt> package
--   
--   <ul>
--   <li>only provides the fully strict variants of types from
--   <a>base</a>,</li>
--   <li>is in-sync with the current base library (base-4.6),</li>
--   <li>provides the missing instances for (future) Haskell platform
--   packages, and</li>
--   <li>conforms to the standard policy that strictness variants of an
--   existing datatype are identified by suffixing 'Strict' or 'Lazy' in
--   the module hierarchy.</li>
--   </ul>
@package strict-base-types
@version 0.2


-- | The strict variant of the standard Haskell <a>Either</a> type and the
--   corresponding variants of the functions from <a>Data.Either</a>.
--   
--   Note that the strict <a>Either</a> type is not an applicative functor,
--   and therefore also no monad. The reasons are the same as the ones for
--   the strict <tt>Maybe</tt> type, which are explained in
--   <a>Data.Maybe.Strict</a>.
module Data.Either.Strict

-- | The strict choice type.
data Either a b :: * -> * -> *
Left :: !a -> Either a b
Right :: !b -> Either a b

-- | Yields <a>True</a> iff the argument is of the form <tt>Right _</tt>.
isRight :: Either a b -> Bool

-- | Yields <a>True</a> iff the argument is of the form <tt>Left _</tt>.
isLeft :: Either a b -> Bool

-- | Case analysis: if the value is <tt><a>Left</a> a</tt>, apply the first
--   function to <tt>a</tt>; if it is <tt><a>Right</a> b</tt>, apply the
--   second function to <tt>b</tt>.
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Analogous to <a>lefts</a> in <a>Data.Either</a>.
lefts :: [Either a b] -> [a]

-- | Analogous to <a>rights</a> in <a>Data.Either</a>.
rights :: [Either a b] -> [b]

-- | Analogous to <a>partitionEithers</a> in <a>Data.Either</a>.
partitionEithers :: [Either a b] -> ([a], [b])

-- | Analogous to <a>_Left</a> in <a>Control.Lens.Prism</a>.
_Left :: Prism (Either a c) (Either b c) a b

-- | Analogous to <a>_Right</a> in <a>Control.Lens.Prism</a>.
_Right :: Prism (Either c a) (Either c b) a b
instance Generic (Either a b)
instance Typeable2 Either
instance (Data a, Data b) => Data (Either a b)
instance Datatype D1Either
instance Constructor C1_0Either
instance Constructor C1_1Either
instance Swapped Either
instance Strict (Either a b) (Either a b)
instance Bitraversable Either
instance Bifoldable Either
instance Bifunctor Either
instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)
instance (FromJSON a, FromJSON b) => FromJSON (Either a b)
instance (ToJSON a, ToJSON b) => ToJSON (Either a b)
instance (Binary a, Binary b) => Binary (Either a b)
instance (NFData a, NFData b) => NFData (Either a b)
instance Traversable (Either e)
instance Foldable (Either e)


-- | The strict variant of the standard Haskell <a>Maybe</a> type and the
--   corresponding variants of the functions from <a>Data.Maybe</a>.
--   
--   Note that in contrast to the standard lazy <a>Maybe</a> type, the
--   strict <a>Maybe</a> type is not an applicative functor, and therefore
--   also not a monad. The problem is the <i>homomorphism</i> law, which
--   states that
--   
--   <pre>
--   <tt>pure</tt> f <tt>&lt;*&gt;</tt> <tt>pure</tt> x = <tt>pure</tt> (f x)  -- must hold for all f
--   </pre>
--   
--   This law does not hold for the expected applicative functor instance
--   of <a>Maybe</a>, as this instance does not satisfy <tt>pure f
--   &lt;*&gt; pure _|_ = pure (f _|_)</tt> for <tt>f = const</tt>.
module Data.Maybe.Strict

-- | The type of strict optional values.
data Maybe a :: * -> *
Nothing :: Maybe a
Just :: !a -> Maybe a

-- | Given a default value, a function and a <a>Maybe</a> value, yields the
--   default value if the <a>Maybe</a> value is <a>Nothing</a> and applies
--   the function to the value stored in the <a>Just</a> otherwise.
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Yields <a>True</a> iff the argument is of the form <tt>Just _</tt>.
isJust :: Maybe a -> Bool

-- | Yields <a>True</a> iff the argument is <a>Nothing</a>.
isNothing :: Maybe a -> Bool

-- | Extracts the element out of a <a>Just</a> and throws an error if the
--   argument is <a>Nothing</a>.
fromJust :: Maybe a -> a

-- | Given a default value and a <a>Maybe</a>, yield the default value if
--   the <a>Maybe</a> argument is <a>Nothing</a> and extract the value out
--   of the <a>Just</a> otherwise.
fromMaybe :: a -> Maybe a -> a

-- | Analogous to <a>listToMaybe</a> in <a>Data.Maybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Analogous to <a>maybeToList</a> in <a>Data.Maybe</a>.
maybeToList :: Maybe a -> [a]

-- | Analogous to <a>catMaybes</a> in <a>Data.Maybe</a>.
catMaybes :: [Maybe a] -> [a]

-- | Analogous to <a>mapMaybe</a> in <a>Data.Maybe</a>.
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | Analogous to <a>_Just</a> in <a>Control.Lens.Prism</a>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | Analogous to <a>_Nothing</a> in <a>Control.Lens.Prism</a>
_Nothing :: Prism' (Maybe a) ()
instance Generic (Maybe a)
instance Typeable1 Maybe
instance Data a => Data (Maybe a)
instance Datatype D1Maybe
instance Constructor C1_0Maybe
instance Constructor C1_1Maybe
instance Strict (Maybe a) (Maybe a)
instance Arbitrary a => Arbitrary (Maybe a)
instance FromJSON a => FromJSON (Maybe a)
instance ToJSON a => ToJSON (Maybe a)
instance Binary a => Binary (Maybe a)
instance NFData a => NFData (Maybe a)
instance Monoid a => Monoid (Maybe a)


-- | The strict variant of the standard Haskell pairs and the corresponding
--   variants of the functions from <a>Data.Tuple</a>.
module Data.Tuple.Strict

-- | The type of strict pairs.
data Pair a b :: * -> * -> *
(:!:) :: !a -> !b -> Pair a b

-- | Extract the first component of a strict pair.
fst :: Pair a b -> a

-- | Extract the second component of a strict pair.
snd :: Pair a b -> b

-- | Curry a function on strict pairs.
curry :: (Pair a b -> c) -> a -> b -> c

-- | Convert a curried function to a function on strict pairs.
uncurry :: (a -> b -> c) -> Pair a b -> c

-- | Analagous to <a>swap</a> from <a>Data.Tuple</a>
swap :: Pair a b -> Pair b a

-- | Zip for strict pairs (defined with zipWith).
zip :: [a] -> [b] -> [Pair a b]

-- | Unzip for stict pairs into a (lazy) pair of lists.
unzip :: [Pair a b] -> ([a], [b])
instance Generic (Pair a b)
instance Typeable2 Pair
instance (Data a, Data b) => Data (Pair a b)
instance Datatype D1Pair
instance Constructor C1_0Pair
instance (Applicative f, a ~ a', b ~ b') => Each f (Pair a a') (Pair b b') a b
instance Swapped Pair
instance Field2 (Pair a b) (Pair a b') b b'
instance Field1 (Pair a b) (Pair a' b) a a'
instance Strict (a, b) (Pair a b)
instance Bitraversable Pair
instance Bifoldable Pair
instance Bifunctor Pair
instance (Arbitrary a, Arbitrary b) => Arbitrary (Pair a b)
instance (FromJSON a, FromJSON b) => FromJSON (Pair a b)
instance (ToJSON a, ToJSON b) => ToJSON (Pair a b)
instance (Binary a, Binary b) => Binary (Pair a b)
instance (NFData a, NFData b) => NFData (Pair a b)
instance (Monoid a, Monoid b) => Monoid (Pair a b)
