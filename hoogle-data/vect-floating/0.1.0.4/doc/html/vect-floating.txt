-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A low-dimensional linear algebra library, operating on the Floating typeclass
--   
@package vect-floating
@version 0.1.0.4

module Data.Vect.Floating.Base
class AbelianGroup g
(&+) :: AbelianGroup g => g -> g -> g
(&-) :: AbelianGroup g => g -> g -> g
neg :: AbelianGroup g => g -> g
zero :: AbelianGroup g => g
vecSum :: AbelianGroup g => [g] -> g
class MultSemiGroup r
(.*.) :: MultSemiGroup r => r -> r -> r
one :: MultSemiGroup r => r
class (AbelianGroup r, MultSemiGroup r) => Ring r
semigroupProduct :: MultSemiGroup r => [r] -> r
class LeftModule r m where (*.) = lmul
lmul :: LeftModule r m => r -> m -> m
(*.) :: LeftModule r m => r -> m -> m
class RightModule m r | m -> r, r -> m where (.*) = rmul
rmul :: RightModule m r => m -> r -> m
(.*) :: RightModule m r => m -> r -> m
class AbelianGroup (v a) => Vector a v where (*&) s v = scalarMul s v (&*) v s = scalarMul s v
mapVec :: Vector a v => (a -> a) -> v a -> v a
scalarMul :: Vector a v => a -> v a -> v a
(*&) :: Vector a v => a -> v a -> v a
(&*) :: Vector a v => v a -> a -> v a
class Floating a => DotProd a v where len = norm lensqr = normsqr normsqr v = (v &. v) norm = sqrt . lensqr dotprod = (&.)
(&.) :: DotProd a v => v a -> v a -> a
norm :: DotProd a v => v a -> a
normsqr :: DotProd a v => v a -> a
len :: DotProd a v => v a -> a
lensqr :: DotProd a v => v a -> a
dotprod :: DotProd a v => v a -> v a -> a

-- | Cross product
class CrossProd v where (&^) = crossprod
crossprod :: CrossProd v => v -> v -> v
(&^) :: CrossProd v => v -> v -> v
normalize :: (Vector a v, DotProd a v) => v a -> v a
distance :: (Vector a v, DotProd a v) => v a -> v a -> a

-- | the angle between two vectors
angle :: (Vector a v, DotProd a v) => v a -> v a -> a

-- | the angle between two unit vectors
angle' :: (Vector a v, UnitVector a v u, DotProd a v) => u a -> u a -> a
class (Vector a v, DotProd a v) => UnitVector a v u | u -> v, v -> u where fromNormalRadius t n = t *& fromNormal n
mkNormal :: UnitVector a v u => v a -> u a
toNormalUnsafe :: UnitVector a v u => v a -> u a
fromNormal :: UnitVector a v u => u a -> v a
fromNormalRadius :: UnitVector a v u => a -> u a -> v a

-- | Pointwise multiplication
class Pointwise v where (&!) = pointwise
pointwise :: Pointwise v => v -> v -> v
(&!) :: Pointwise v => v -> v -> v

-- | conversion between vectors (and matrices) of different dimensions
class Extend a u v
extendZero :: Extend a u v => u a -> v a
extendWith :: Extend a u v => a -> u a -> v a
trim :: Extend a u v => v a -> u a
class HasCoordinates v x | v -> x
_1 :: HasCoordinates v x => v -> x
_2 :: HasCoordinates v x => v -> x
_3 :: HasCoordinates v x => v -> x
_4 :: HasCoordinates v x => v -> x
class Dimension a
dim :: Dimension a => a -> Int
class Matrix m
transpose :: Matrix m => m -> m
inverse :: Matrix m => m -> m
idmtx :: Matrix m => m

-- | Outer product (could be unified with Diagonal?)
class Tensor t v | t -> v
outer :: Tensor t v => v -> v -> t

-- | makes a diagonal matrix from a vector
class Diagonal s t | t -> s
diag :: Diagonal s t => s -> t
class Determinant a m
det :: Determinant a m => m -> a
class Matrix (m a) => Orthogonal a m o | m -> o, o -> m
fromOrtho :: Orthogonal a m o => o a -> m a
toOrthoUnsafe :: Orthogonal a m o => m a -> o a

-- | "Projective" matrices have the following form: the top left corner is
--   an any matrix, the bottom right corner is 1, and the top-right column
--   is zero. These describe the affine orthogonal transformation of the
--   space one dimension less.
class (Vector a v, Orthogonal a n o, Diagonal (v a) (n a)) => Projective a v n o m p | m -> p, p -> m, p -> o, o -> p, p -> n, n -> p, p -> v, v -> p, n -> o, n -> v, v -> n
fromProjective :: Projective a v n o m p => p a -> m a
toProjectiveUnsafe :: Projective a v n o m p => m a -> p a
orthogonal :: Projective a v n o m p => o a -> p a
linear :: Projective a v n o m p => n a -> p a
translation :: Projective a v n o m p => v a -> p a
scaling :: Projective a v n o m p => v a -> p a
class (AbelianGroup m, Matrix m) => MatrixNorms a m where matrixDistance m n = frobeniusNorm (n &- m) operatorNorm = error "operatorNorm: not implemented yet"
frobeniusNorm :: MatrixNorms a m => m -> a
matrixDistance :: MatrixNorms a m => m -> m -> a
operatorNorm :: MatrixNorms a m => m -> a
data Vec2 a
Vec2 :: !a -> !a -> Vec2 a
data Vec3 a
Vec3 :: !a -> !a -> !a -> Vec3 a
data Vec4 a
Vec4 :: !a -> !a -> !a -> !a -> Vec4 a

-- | The components are <i>row</i> vectors
data Mat2 a
Mat2 :: !(Vec2 a) -> !(Vec2 a) -> Mat2 a
data Mat3 a
Mat3 :: !(Vec3 a) -> !(Vec3 a) -> !(Vec3 a) -> Mat3 a
data Mat4 a
Mat4 :: !(Vec4 a) -> !(Vec4 a) -> !(Vec4 a) -> !(Vec4 a) -> Mat4 a

-- | Orthogonal matrices.
--   
--   Note: the <a>Random</a> instances generates orthogonal matrices with
--   determinant 1 (that is, orientation-preserving orthogonal
--   transformations)!
data Ortho2 a
data Ortho3 a
data Ortho4 a

-- | The assumption when dealing with these is always that they are of unit
--   length. Also, interpolation works differently.
data Normal2 a
data Normal3 a
data Normal4 a

-- | Projective matrices, encoding affine transformations in dimension one
--   less.
data Proj3 a
data Proj4 a
mkVec2 :: (a, a) -> Vec2 a
mkVec3 :: (a, a, a) -> Vec3 a
mkVec4 :: (a, a, a, a) -> Vec4 a
project :: (Vector a v, DotProd a v) => v a -> v a -> v a

-- | Projects the first vector down to the hyperplane orthogonal to the
--   second (unit) vector
project' :: (Vector a v, UnitVector a v u, DotProd a v) => v a -> u a -> v a

-- | Direction (second argument) is assumed to be a <i>unit</i> vector!
projectUnsafe :: (Vector a v, DotProd a v) => v a -> v a -> v a

-- | Since unit vectors are not a group, we need a separate function.
flipNormal :: UnitVector a v n => n a -> n a

-- | Householder matrix, see
--   <a>http://en.wikipedia.org/wiki/Householder_transformation</a>. In
--   plain words, it is the reflection to the hyperplane orthogonal to the
--   input vector.
householder :: (Vector a v, UnitVector a v u, Matrix (m a), Vector a m, Tensor (m a) (v a)) => u a -> m a
householderOrtho :: (Vector a v, UnitVector a v u, Matrix (m a), Vector a m, Tensor (m a) (v a), Orthogonal a m o) => u a -> o a
instance Typeable Vec2
instance Typeable Vec3
instance Typeable Vec4
instance Typeable Normal2
instance Typeable Normal3
instance Typeable Normal4
instance Floating a => DotProd a Normal4
instance Floating a => DotProd a Normal3
instance Floating a => DotProd a Normal2
instance Read a => Read (Vec2 a)
instance Show a => Show (Vec2 a)
instance Read a => Read (Vec3 a)
instance Show a => Show (Vec3 a)
instance Read a => Read (Vec4 a)
instance Show a => Show (Vec4 a)
instance Read a => Read (Mat2 a)
instance Show a => Show (Mat2 a)
instance Read a => Read (Mat3 a)
instance Show a => Show (Mat3 a)
instance Read a => Read (Mat4 a)
instance Show a => Show (Mat4 a)
instance Read a => Read (Normal2 a)
instance Show a => Show (Normal2 a)
instance (Floating a, Storable a) => Storable (Normal2 a)
instance Floating a => Dimension (Normal2 a)
instance Read a => Read (Normal3 a)
instance Show a => Show (Normal3 a)
instance (Floating a, Storable a) => Storable (Normal3 a)
instance Floating a => Dimension (Normal3 a)
instance Read a => Read (Normal4 a)
instance Show a => Show (Normal4 a)
instance (Floating a, Storable a) => Storable (Normal4 a)
instance Floating a => Dimension (Normal4 a)
instance Read a => Read (Ortho2 a)
instance Show a => Show (Ortho2 a)
instance (Floating a, Storable a) => Storable (Ortho2 a)
instance Floating a => MultSemiGroup (Ortho2 a)
instance Floating a => Determinant a (Ortho2 a)
instance Floating a => Dimension (Ortho2 a)
instance Read a => Read (Ortho3 a)
instance Show a => Show (Ortho3 a)
instance (Floating a, Storable a) => Storable (Ortho3 a)
instance Floating a => MultSemiGroup (Ortho3 a)
instance Floating a => Determinant a (Ortho3 a)
instance Floating a => Dimension (Ortho3 a)
instance Read a => Read (Ortho4 a)
instance Show a => Show (Ortho4 a)
instance (Floating a, Storable a) => Storable (Ortho4 a)
instance Floating a => MultSemiGroup (Ortho4 a)
instance Floating a => Determinant a (Ortho4 a)
instance Floating a => Dimension (Ortho4 a)
instance Read a => Read (Proj3 a)
instance Show a => Show (Proj3 a)
instance (Floating a, Storable a) => Storable (Proj3 a)
instance Floating a => MultSemiGroup (Proj3 a)
instance Read a => Read (Proj4 a)
instance Show a => Show (Proj4 a)
instance (Floating a, Storable a) => Storable (Proj4 a)
instance Floating a => MultSemiGroup (Proj4 a)
instance Floating a => Extend a Mat3 Mat4
instance Floating a => Extend a Mat2 Mat4
instance Floating a => Extend a Mat2 Mat3
instance Floating a => Extend a Vec3 Vec4
instance Floating a => Extend a Vec2 Vec4
instance Floating a => Extend a Vec2 Vec3
instance Floating a => Pointwise (Mat4 a)
instance Floating a => MatrixNorms a (Mat4 a)
instance Floating a => Dimension (Mat4 a)
instance (Floating a, Random a) => Random (Mat4 a)
instance (Floating a, Storable a) => Storable (Mat4 a)
instance Floating a => Determinant a (Mat4 a)
instance Floating a => Tensor (Mat4 a) (Vec4 a)
instance Floating a => Diagonal (Vec4 a) (Mat4 a)
instance Floating a => RightModule (Vec4 a) (Mat4 a)
instance Floating a => LeftModule (Mat4 a) (Vec4 a)
instance Floating a => Ring (Mat4 a)
instance Floating a => MultSemiGroup (Mat4 a)
instance Floating a => Vector a Mat4
instance Floating a => AbelianGroup (Mat4 a)
instance Floating a => Matrix (Mat4 a)
instance Floating a => HasCoordinates (Mat4 a) (Vec4 a)
instance Floating a => Dimension (Vec4 a)
instance (Floating a, Storable a) => Storable (Vec4 a)
instance (Floating a, Random a) => Random (Vec4 a)
instance Num a => Pointwise (Vec4 a)
instance Floating a => DotProd a Vec4
instance Floating a => Vector a Vec4
instance Floating a => AbelianGroup (Vec4 a)
instance Floating a => HasCoordinates (Vec4 a) a
instance Floating a => Pointwise (Mat3 a)
instance Floating a => MatrixNorms a (Mat3 a)
instance Floating a => Dimension (Mat3 a)
instance (Floating a, Random a) => Random (Mat3 a)
instance (Floating a, Storable a) => Storable (Mat3 a)
instance Floating a => Determinant a (Mat3 a)
instance Floating a => Tensor (Mat3 a) (Vec3 a)
instance Floating a => Diagonal (Vec3 a) (Mat3 a)
instance Floating a => RightModule (Vec3 a) (Mat3 a)
instance Floating a => LeftModule (Mat3 a) (Vec3 a)
instance Floating a => Ring (Mat3 a)
instance Floating a => MultSemiGroup (Mat3 a)
instance Floating a => Vector a Mat3
instance Floating a => AbelianGroup (Mat3 a)
instance Floating a => Matrix (Mat3 a)
instance Floating a => HasCoordinates (Mat3 a) (Vec3 a)
instance Floating a => Dimension (Vec3 a)
instance (Floating a, Storable a) => Storable (Vec3 a)
instance Floating a => Determinant a (Vec3 a, Vec3 a, Vec3 a)
instance Floating a => CrossProd (Vec3 a)
instance (Floating a, Random a) => Random (Vec3 a)
instance Num a => Pointwise (Vec3 a)
instance Floating a => DotProd a Vec3
instance Floating a => Vector a Vec3
instance Floating a => AbelianGroup (Vec3 a)
instance Floating a => HasCoordinates (Vec3 a) a
instance Floating a => Pointwise (Mat2 a)
instance Floating a => MatrixNorms a (Mat2 a)
instance Floating a => Dimension (Mat2 a)
instance (Floating a, Random a) => Random (Mat2 a)
instance (Floating a, Storable a) => Storable (Mat2 a)
instance Floating a => Determinant a (Mat2 a)
instance Floating a => Tensor (Mat2 a) (Vec2 a)
instance Floating a => Diagonal (Vec2 a) (Mat2 a)
instance Floating a => RightModule (Vec2 a) (Mat2 a)
instance Floating a => LeftModule (Mat2 a) (Vec2 a)
instance Floating a => Ring (Mat2 a)
instance Floating a => MultSemiGroup (Mat2 a)
instance Floating a => Vector a Mat2
instance Floating a => AbelianGroup (Mat2 a)
instance Floating a => Matrix (Mat2 a)
instance Floating a => HasCoordinates (Mat2 a) (Vec2 a)
instance Floating a => Dimension (Vec2 a)
instance (Floating a, Storable a) => Storable (Vec2 a)
instance (Floating a, Random a) => Random (Vec2 a)
instance Floating a => Determinant a (Vec2 a, Vec2 a)
instance Floating a => Pointwise (Vec2 a)
instance Floating a => DotProd a Vec2
instance Floating a => Vector a Vec2
instance Floating a => AbelianGroup (Vec2 a)
instance Floating a => HasCoordinates (Vec2 a) a
instance Floating a => Matrix (Proj4 a)
instance Floating a => Matrix (Proj3 a)
instance Floating a => Projective a Vec3 Mat3 Ortho3 Mat4 Proj4
instance Floating a => Projective a Vec2 Mat2 Ortho2 Mat3 Proj3
instance (Floating a, Ord a, Random a) => Random (Ortho4 a)
instance (Floating a, Ord a, Random a) => Random (Ortho3 a)
instance (Floating a, Ord a, Random a) => Random (Ortho2 a)
instance Floating a => Matrix (Ortho4 a)
instance Floating a => Matrix (Ortho3 a)
instance Floating a => Matrix (Ortho2 a)
instance Floating a => Orthogonal a Mat4 Ortho4
instance Floating a => Orthogonal a Mat3 Ortho3
instance Floating a => Orthogonal a Mat2 Ortho2
instance Floating a => CrossProd (Normal3 a)
instance (Floating a, Random a, Ord a) => Random (Normal4 a)
instance (Floating a, Random a, Ord a) => Random (Normal3 a)
instance (Floating a, Random a, Ord a) => Random (Normal2 a)
instance Floating a => UnitVector a Vec4 Normal4
instance Floating a => UnitVector a Vec3 Normal3
instance Floating a => UnitVector a Vec2 Normal2


-- | Interpolation of vectors. Note: we interpolate unit vectors
--   differently from ordinary vectors.
module Data.Vect.Floating.Interpolate
class Interpolate a v
interpolate :: Interpolate a v => a -> v -> v -> v

-- | Spherical linear interpolation. See
--   <a>http://en.wikipedia.org/wiki/Slerp</a>
slerp :: UnitVector a v u => a -> u a -> u a -> u a
instance Floating a => Interpolate a (Normal4 a)
instance Floating a => Interpolate a (Normal3 a)
instance Floating a => Interpolate a (Normal2 a)
instance Floating a => Interpolate a (Vec4 a)
instance Floating a => Interpolate a (Vec3 a)
instance Floating a => Interpolate a (Vec2 a)
instance Num a => Interpolate a a

module Data.Vect.Floating.Util.Dim2

-- | Example: <tt>structVec2 [1,2,3,4] = [ Vec2 1 2 , Vec2 3 4 ]</tt>.
structVec2 :: [a] -> [Vec2 a]

-- | The opposite of "structVec2".
destructVec2 :: [Vec2 a] -> [a]
det2 :: Floating a => Vec2 a -> Vec2 a -> a
vec2X :: Num a => Vec2 a
vec2Y :: Num a => Vec2 a
translate2X :: Num a => a -> Vec2 a -> Vec2 a
translate2Y :: Num a => a -> Vec2 a -> Vec2 a

-- | unit vector with given angle relative to the positive X axis (in the
--   positive direction, that is, CCW). A more precise name would be
--   <tt>cosSin</tt>, but that sounds bad :)
sinCos :: Floating a => a -> Vec2 a
sinCos' :: Floating a => a -> Normal2 a
sinCosRadius :: Floating a => a -> a -> Vec2 a

-- | The angle relative to the positive X axis
angle2 :: RealFloat a => Vec2 a -> a
angle2' :: RealFloat a => Normal2 a -> a

-- | Rotation matrix by a given angle (in radians), counterclockwise.
rotMatrix2 :: Floating a => a -> Mat2 a
rotMatrixOrtho2 :: Floating a => a -> Ortho2 a
rotate2 :: Floating a => a -> Vec2 a -> Vec2 a

-- | Rotates counterclockwise by 90 degrees.
rotateCCW :: Floating a => Vec2 a -> Vec2 a

-- | Rotates clockwise by 90 degrees.
rotateCW :: Floating a => Vec2 a -> Vec2 a

module Data.Vect.Floating.Util.Dim3

-- | Example: <tt>structVec3 [1,2,3,4,5,6] = [ Vec3 1 2 3 , Vec3 4 5
--   6]</tt>.
structVec3 :: [a] -> [Vec3 a]

-- | The opposite of "structVec3".
destructVec3 :: [Vec3 a] -> [a]
det3 :: Floating a => Vec3 a -> Vec3 a -> Vec3 a -> a
translate3X :: Num a => a -> Vec3 a -> Vec3 a
translate3Y :: Num a => a -> Vec3 a -> Vec3 a
translate3Z :: Num a => a -> Vec3 a -> Vec3 a
vec3X :: Num a => Vec3 a
vec3Y :: Num a => Vec3 a
vec3Z :: Num a => Vec3 a
rotMatrixZ :: Floating a => a -> Mat3 a
rotMatrixY :: Floating a => a -> Mat3 a
rotMatrixX :: Floating a => a -> Mat3 a
rotate3' :: Floating a => a -> Normal3 a -> Vec3 a -> Vec3 a
rotate3 :: Floating a => a -> Vec3 a -> Vec3 a -> Vec3 a

-- | Rotation around an arbitrary 3D vector. The resulting 3x3 matrix is
--   intended for multiplication on the <i>right</i>.
rotMatrix3 :: Floating a => Vec3 a -> a -> Mat3 a
rotMatrixOrtho3 :: Floating a => Vec3 a -> a -> Ortho3 a

-- | Rotation around an arbitrary 3D <i>unit</i> vector. The resulting 3x3
--   matrix is intended for multiplication on the <i>right</i>.
rotMatrix3' :: Floating a => Normal3 a -> a -> Mat3 a
rotMatrixOrtho3' :: Floating a => Normal3 a -> a -> Ortho3 a

-- | Reflects a vector to an axis: that is, the result of <tt>reflect n
--   v</tt> is 2&lt;n,v&gt;n - v
reflect :: Floating a => Normal3 a -> Vec3 a -> Vec3 a
reflect' :: Floating a => Normal3 a -> Normal3 a -> Normal3 a
refract :: (Floating a, Ord a) => a -> Normal3 a -> Vec3 a -> Vec3 a

-- | Refraction. First parameter (<tt>eta</tt>) is the relative refraction
--   index
--   
--   <pre>
--          refl_inside
--   eta = --------------
--          refl_outside
--   </pre>
--   
--   where "inside" is the direction of the second argument (to vector
--   normal to plane which models the boundary between the two materials).
--   That is, total internal reflection can occur when <tt>eta&gt;1</tt>.
--   
--   The convention is that the origin is the point of intersection of the
--   ray and the surface, and all the vectors "point away" from here
--   (unlike, say, GLSL's <tt>refract</tt>, where the incident vector
--   "points towards" the material)
refract' :: (Floating a, Ord a) => a -> Normal3 a -> Normal3 a -> Normal3 a

-- | When total internal reflection would occur, we return <a>Nothing</a>.
refractOnly' :: (Floating a, Ord a) => a -> Normal3 a -> Normal3 a -> Maybe (Normal3 a)


-- | Classic 4x4 projective matrices, encoding the affine transformations
--   of R^3. Our convention is that they are intended for multiplication on
--   the <i>right</i>, that is, they are of the form
--   
--   <pre>
--       _____
--   [  |     |  0  ]
--   [  | 3x3 |  0  ]
--   [  |_____|  0  ]
--   [  p  q  r  1  ]
--   </pre>
--   
--   Please note that by default, OpenGL stores the matrices (in memory) by
--   columns, while we store them by rows; but OpenGL also use the opposite
--   convention (so the OpenGL projective matrices are intended for
--   multiplication on the <i>left</i>). So in effect, they are the same
--   when stored in the memory, say with <tt>poke :: Ptr Mat4 -&gt; Mat4
--   -&gt; IO ()</tt>.
--   
--   Warning: The naming conventions will probably change in the future.
module Data.Vect.Floating.Util.Projective
rotMatrixProj4' :: (Floating a, Projective a Vec3 Mat3 Ortho3 b Proj4) => a -> Normal3 a -> Proj4 a
rotMatrixProj4 :: Floating a => a -> Vec3 a -> Proj4 a

-- | synonym for "rotateAfterProj4"
rotateProj4 :: Floating a => a -> Normal3 a -> Proj4 a -> Proj4 a

-- | Synonym for <tt>m -&gt; m .*. rotMatrixProj4 angle axis</tt>.
rotateAfterProj4 :: Floating a => a -> Normal3 a -> Proj4 a -> Proj4 a

-- | Synonym for <tt>m -&gt; rotMatrixProj4 angle axis .*. m</tt>.
rotateBeforeProj4 :: Floating a => a -> Normal3 a -> Proj4 a -> Proj4 a
scalingUniformProj4 :: Floating a => a -> Proj4 a

-- | Equivalent to <tt>m -&gt; scaling v .*. m</tt>.
scaleBeforeProj4 :: Floating a => Vec3 a -> Proj4 a -> Proj4 a

-- | Equivalent to <tt>m -&gt; m .*. scaling v</tt>.
scaleAfterProj4 :: Floating a => Vec3 a -> Proj4 a -> Proj4 a

-- | Synonym for "translateAfter4"
translate4 :: Floating a => Vec3 a -> Proj4 a -> Proj4 a

-- | Equivalent to <tt>m -&gt; m .*. translation v</tt>.
translateAfter4 :: Floating a => Vec3 a -> Proj4 a -> Proj4 a

-- | Equivalent to <tt>m -&gt; translation v .*. m</tt>.
translateBefore4 :: (Floating a, Extend a Mat3 Mat4, RightModule (Vec3 a) (Mat3 a)) => Vec3 a -> Proj4 a -> Proj4 a


-- | Gram-Schmidt orthogonalization. This module is not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Floating.GramSchmidt

-- | produces orthogonal/orthonormal vectors from a set of vectors
class GramSchmidt a
gramSchmidt :: GramSchmidt a => a -> a
gramSchmidtNormalize :: GramSchmidt a => a -> a
instance Floating a => GramSchmidt (Normal4 a, Normal4 a, Normal4 a, Normal4 a)
instance Floating a => GramSchmidt (Vec4 a, Vec4 a, Vec4 a, Vec4 a)
instance Floating a => GramSchmidt (Normal4 a, Normal4 a, Normal4 a)
instance Floating a => GramSchmidt (Normal3 a, Normal3 a, Normal3 a)
instance Floating a => GramSchmidt (Vec4 a, Vec4 a, Vec4 a)
instance Floating a => GramSchmidt (Vec3 a, Vec3 a, Vec3 a)
instance Floating a => GramSchmidt (Normal4 a, Normal4 a)
instance Floating a => GramSchmidt (Normal3 a, Normal3 a)
instance Floating a => GramSchmidt (Normal2 a, Normal2 a)
instance Floating a => GramSchmidt (Vec4 a, Vec4 a)
instance Floating a => GramSchmidt (Vec3 a, Vec3 a)
instance Floating a => GramSchmidt (Vec2 a, Vec2 a)


-- | Rotation around an arbitrary plane in four dimensions, and other
--   miscellanea. Not very useful for most people, and not re-exported by
--   <a>Data.Vect</a>.
module Data.Vect.Floating.Util.Dim4
structVec4 :: [a] -> [Vec4 a]
destructVec4 :: [Vec4 a] -> [a]
translate4X :: Num a => a -> Vec4 a -> Vec4 a
translate4Y :: Num a => a -> Vec4 a -> Vec4 a
translate4Z :: Num a => a -> Vec4 a -> Vec4 a
translate4W :: Num a => a -> Vec4 a -> Vec4 a
vec4X :: Num a => Vec4 a
vec4Y :: Num a => Vec4 a
vec4Z :: Num a => Vec4 a
vec4W :: Num a => Vec4 a

-- | If <tt>(x,y,u,v)</tt> is an orthonormal system, then (written in
--   pseudo-code) <tt>biVector4 (x,y) = plusMinus (reverse $ biVector4
--   (u,v))</tt>. This is a helper function for the 4 dimensional rotation
--   code. If <tt>(x,y,z,p,q,r) = biVector4 a b</tt>, then the
--   corresponding antisymmetric tensor is
--   
--   <pre>
--   [  0  r  q  p ]
--   [ -r  0  z -y ]
--   [ -q -z  0  x ]
--   [ -p  y -x  0 ]
--   </pre>
biVector4 :: Num a => Vec4 a -> Vec4 a -> (a, a, a, a, a, a)

-- | the corresponding antisymmetric tensor
biVector4AsTensor :: Num a => Vec4 a -> Vec4 a -> Mat4 a

-- | We assume that the axes are normalized and <i>orthogonal</i> to each
--   other!
rotate4' :: Floating a => a -> (Normal4 a, Normal4 a) -> Vec4 a -> Vec4 a

-- | We assume only that the axes are independent vectors.
rotate4 :: Floating a => a -> (Vec4 a, Vec4 a) -> Vec4 a -> Vec4 a

-- | Rotation matrix around a plane specified by two normalized and
--   <i>orthogonal</i> vectors. Intended for multiplication on the
--   <i>right</i>!
rotMatrix4' :: Floating a => a -> (Normal4 a, Normal4 a) -> Mat4 a

-- | We assume only that the axes are independent vectors.
rotMatrix4 :: Floating a => a -> (Vec4 a, Vec4 a) -> Mat4 a


-- | The unit sphere in the space of quaternions has the group structure
--   SU(2) coming from the quaternion multiplication, which is the double
--   cover of the group SO(3) of rotations in R^3. Thus, unit quaternions
--   can be used to encode rotations in 3D, which is a more compact
--   encoding (4 floats) than a 3x3 matrix; however, there are <i>two</i>
--   quaternions corresponding to each rotation.
--   
--   See <a>http://en.wikipedia.org/wiki/Quaternion</a> and
--   <a>http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a>
--   for more information.
module Data.Vect.Floating.Util.Quaternion

-- | The type for quaternions.
newtype Quaternion a
Q :: (Vec4 a) -> Quaternion a

-- | The type for unit quaternions.
newtype UnitQuaternion a
U :: (Vec4 a) -> UnitQuaternion a

-- | An abbreviated type synonym for quaternions
type Q = Quaternion

-- | An abbreviated type synonym for unit quaternions
type U = UnitQuaternion
unitQ :: Num a => Q a
zeroQ :: Num a => Q a
multQ :: Num a => Q a -> Q a -> Q a
negQ :: Floating a => Q a -> Q a
normalizeQ :: Floating a => Q a -> Q a

-- | The inverse quaternion
invQ :: Floating a => Q a -> Q a
fromQ :: Q a -> Vec4 a
toQ :: Vec4 a -> Q a
unitU :: Num a => U a
multU :: Num a => U a -> U a -> U a

-- | The opposite quaternion (which encodes the same rotation)
negU :: Floating a => U a -> U a

-- | This is no-op, up to numerical imprecision. However, if you multiply
--   together a large number of unit quaternions, it may be a good idea to
--   normalize the end result.
normalizeU :: Floating a => U a -> U a

-- | The inverse of a unit quaternion
invU :: Num a => U a -> U a
fromU :: Num a => U a -> Vec4 a
fromU' :: Floating a => U a -> Normal4 a
mkU :: Floating a => Vec4 a -> U a
toU :: Floating a => Normal4 a -> U a
unsafeToU :: Num a => Vec4 a -> U a

-- | The <i>left</i> action of unit quaternions on 3D vectors. That is,
--   
--   <pre>
--   actU q1 $ actU q2 v  ==  actU (q1 `multU` q2) v 
--   </pre>
actU :: Num a => U a -> Vec3 a -> Vec3 a
actU' :: Floating a => U a -> Normal3 a -> Normal3 a

-- | The quaternion to encode rotation around an axis. Please note that
--   quaternions act on the <i>left</i>, that is
--   
--   <pre>
--   rotU axis1 angl1 *. rotU axis2 angl2 *. v  ==  (rotU axis1 angl1 .*. rotU axis2 angl2) *. v 
--   </pre>
rotU :: Floating a => Vec3 a -> a -> U a
rotU' :: Floating a => Normal3 a -> a -> U a

-- | Interpolation of unit quaternions. Note that when applied to
--   rotations, this may be not what you want, since it is possible that
--   the shortest path in the space of unit quaternions is not the shortest
--   path in the space of rotations; see <a>slerpU</a>!
longSlerpU :: Floating a => a -> U a -> U a -> U a

-- | This is shortest path interpolation in the space of rotations; however
--   this is achieved by possibly flipping the first endpoint in the space
--   of quaternions. Thus <tt>slerpU 0.001 q1 q2</tt> may be very far from
--   <tt>q1</tt> (and very close to <tt>negU q1</tt>) in the space of
--   quaternions (but they are very close in the space of rotations).
slerpU :: (Floating a, Ord a) => a -> U a -> U a -> U a

-- | Makes a rotation matrix (to be multiplied with on the <i>right</i>)
--   out of a unit quaternion:
--   
--   <pre>
--   v .* rightOrthoU (rotU axis angl)  ==  v .* rotMatrix3 axis angl
--   </pre>
--   
--   Please note that while these matrices act on the <i>right</i>,
--   quaternions act on the <i>left</i>; thus
--   
--   <pre>
--   rightOrthoU q1 .*. rightOrthoU q2  ==  rightOrthoU (q2 .*. q1)
--   </pre>
rightOrthoU :: Floating a => U a -> Ortho3 a

-- | Makes a rotation matrix (to be multiplied with on the <i>left</i>) out
--   of a unit quaternion.
--   
--   <pre>
--   leftOrthoU (rotU axis angl) *. v  ==  v .* rotMatrix3 axis angl
--   </pre>
leftOrthoU :: Floating a => U a -> Ortho3 a
instance Typeable Quaternion
instance Typeable UnitQuaternion
instance Floating a => DotProd a UnitQuaternion
instance Floating a => DotProd a Quaternion
instance Floating a => Vector a Quaternion
instance Read a => Read (Quaternion a)
instance Show a => Show (Quaternion a)
instance (Floating a, Storable a) => Storable (Quaternion a)
instance Floating a => AbelianGroup (Quaternion a)
instance (Floating a, Random a) => Random (Quaternion a)
instance Floating a => Interpolate a (Quaternion a)
instance Read a => Read (UnitQuaternion a)
instance Show a => Show (UnitQuaternion a)
instance (Floating a, Storable a) => Storable (UnitQuaternion a)
instance (Floating a, Ord a, Random a) => Random (UnitQuaternion a)
instance Num a => LeftModule (UnitQuaternion a) (Vec3 a)
instance Floating a => MultSemiGroup (UnitQuaternion a)
instance Num a => MultSemiGroup (Quaternion a)
instance Floating a => UnitVector a Quaternion UnitQuaternion

module Data.Vect.Floating
