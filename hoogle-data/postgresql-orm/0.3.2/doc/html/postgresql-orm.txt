-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.
--   
@package postgresql-orm
@version 0.3.2

module Database.PostgreSQL.ORM.Validations
newtype ValidationError
ValidationError :: HashMap Text [Text] -> ValidationError
validationErrors :: ValidationError -> HashMap Text [Text]
type ValidationFunc a = a -> ValidationError
validate :: (a -> Bool) -> Text -> Text -> ValidationFunc a
validateNotEmpty :: (a -> Text) -> Text -> Text -> ValidationFunc a
instance Typeable ValidationError
instance Show ValidationError
instance FromJSON ValidationError
instance ToJSON ValidationError
instance Monoid ValidationError
instance Exception ValidationError


-- | This module deals with escaping and sanitizing SQL templates.
module Database.PostgreSQL.Escape

-- | Take a SQL template containing '?' characters and a list of paremeters
--   whose length must match the number of '?' characters, and format the
--   result as an escaped <a>ByteString</a> that can be used as a query.
--   
--   Like <a>formatQuery</a>, this function is naive about the placement of
--   '?' characters and will expand all of them, even ones within quotes.
--   To avoid this, you must use <a>quoteIdent</a> on identifiers
--   containing question marks.
--   
--   Also like <a>formatQuery</a>, '?' characters touching other '?'
--   characters or quoted strings may do the wrong thing, and end up
--   doubling a quote, so avoid substrings such as <tt>"??"</tt> or
--   <tt>"?<tt>string</tt>"</tt>, as these could get expanded to, e.g.,
--   <tt>"'param''string'"</tt>, which is a single string containing an
--   apostrophe, when you probably wanted two strings.
fmtSql :: ToRow p => Query -> p -> Query

-- | Quote an identifier such as a table or column name using double-quote
--   characters. Note this has nothing to do with quoting <i>values</i>,
--   which must be quoted using single quotes. (Anyway, all values should
--   be quoted by <a>query</a> or <a>fmtSql</a>.) This function uses a
--   unicode escape sequence to escape '?' characters, which would
--   otherwise be expanded by <a>query</a>, <a>formatQuery</a>, or
--   <a>fmtSql</a>.
--   
--   <pre>
--   &gt;&gt;&gt; S8.putStrLn $ quoteIdent "hello \"world\"!"
--   "hello ""world""!"
--   
--   &gt;&gt;&gt; S8.putStrLn $ quoteIdent "hello \"world\"?"
--    U&amp;"hello ""world""\003f"
--   </pre>
--   
--   Note that this quoting function is correct only if
--   <tt>client_encoding</tt> is <tt>SQL_ASCII</tt>, <tt>client_coding</tt>
--   is <tt>UTF8</tt>, or the identifier contains no multi-byte characters.
--   For other coding schemes, this function may erroneously duplicate
--   bytes that look like quote characters but are actually part of a
--   multi-byte character code. In such cases, maliciously crafted
--   identifiers will, even after quoting, allow injection of arbitrary SQL
--   commands to the server.
--   
--   The upshot is that it is unwise to use this function on identifiers
--   provided by untrustworthy sources. Note this is true anyway,
--   regardless of <tt>client_encoding</tt> setting, because certain
--   "system column" names (e.g., <tt>oid</tt>, <tt>tableoid</tt>,
--   <tt>xmin</tt>, <tt>cmin</tt>, <tt>xmax</tt>, <tt>cmax</tt>,
--   <tt>ctid</tt>) are likely to produce unexpected results even when
--   properly quoted.
--   
--   See <tt>Id</tt> for a convenient way to include quoted identifiers in
--   parameter lists.
quoteIdent :: ByteString -> ByteString

-- | A builder version of <a>fmtSql</a>, possibly useful if you are about
--   to concatenate various individually formatted query fragments and want
--   to save the work of concatenating each individually.
buildSql :: ToRow p => Query -> p -> Builder

-- | A lower-level function used by <a>buildSql</a> and <a>fmtSql</a>. You
--   probably don't need to call it directly.
buildSqlFromActions :: Query -> [Action] -> Builder
buildAction :: Action -> Builder
buildLiteral :: ByteString -> Builder
buildByteA :: ByteString -> Builder

-- | Build a quoted identifier. Generally you will want to use
--   <a>quoteIdent</a>, and for repeated use it will be faster to use
--   <tt><a>fromByteString</a> . <a>quoteIdent</a></tt>, but this internal
--   function is exposed in case it is useful.
buildIdent :: ByteString -> Builder


-- | Functions to help with building database migrations.
--   
--   Most users will want to create a database migration using
--   <tt>defaultMain</tt> as follows,
--   
--   <pre>
--   import Database.PostgreSQL.Migrations
--   
--   main = defaultMain up down
--   
--   up = migrate $ do
--         create_table "posts"
--           [ column "title" "VARCHAR(255) NOT NULL"
--           , column "author_id" "integer references authors(id)"]
--   
--   down = migrate $ drop_table "posts"
--   </pre>
module Database.PostgreSQL.Migrations
defaultMain :: (Connection -> IO ()) -> (Connection -> IO ()) -> IO ()

-- | Creates a PostgreSQL <a>Connection</a> using the <i>DATABASE_URL</i>
--   environment variable, if it exists. If it does, it should match the
--   format:
--   
--   <pre>
--   postgresql://[[USERNAME@PASSWORD]HOSTNAME[:PORT]]/[DBNAME]
--   </pre>
--   
--   If it is not present, the environment variables <i>PG_DBNAME</i>
--   <i>PG_HOST</i> etc, are used.
connectEnv :: IO Connection

-- | Runs the SQL file at the given path, relative to the current working
--   directory.
runSqlFile :: FilePath -> Migration ()
type Migration = ReaderT Connection IO
migrate :: Migration a -> Connection -> IO ()

-- | Returns a column defition by quoting the given name
column :: ByteString -> ByteString -> ByteString

-- | Creates a table. See <a>column</a> for constructing the column list.
create_table :: ByteString -> [ByteString] -> Migration Int64

-- | Adds a column to the given table. For example,
--   
--   <pre>
--   add_column "posts" "title" "VARCHAR(255)"
--   </pre>
--   
--   adds a varchar column called "title" to the table "posts".
add_column :: ByteString -> ByteString -> ByteString -> Migration Int64

-- | Creates an index for efficient lookup.
create_index :: ByteString -> ByteString -> [ByteString] -> Migration Int64

-- | Creates a unique index for efficient lookup.
create_unique_index :: ByteString -> ByteString -> [ByteString] -> Migration Int64

-- | Drops a table
drop_table :: ByteString -> Migration Int64

-- | Drops a column from the given table. For example,
--   
--   <pre>
--   drop_column "posts" "title"
--   </pre>
--   
--   drops the column "title" from the "posts" table.
drop_column :: ByteString -> ByteString -> Migration Int64

-- | Drops an index.
drop_index :: ByteString -> Migration Int64

-- | Renames a column in the given table. For example,
--   
--   <pre>
--   rename_column "posts" "title" "name"
--   </pre>
--   
--   renames the column "title" in the "posts" table to "name".
rename_column :: ByteString -> ByteString -> ByteString -> Migration Int64

-- | Alters a column in the given table. For example,
--   
--   <pre>
--   change_column "posts" "title" "DROP DEFAULT"
--   </pre>
--   
--   drops the default constraint for the "title" column in the "posts"
--   table.
change_column :: ByteString -> ByteString -> ByteString -> Migration Int64

-- | Returns a <a>Query</a> that creates a table, for example:
--   
--   <pre>
--   create_table "posts"
--     [ column "title" "VARCHAR(255) NOT NULL"
--     , column "body"  "text"]
--   </pre>
create_table_stmt :: ByteString -> [ByteString] -> Query

-- | Returns a <a>Query</a> that adds a column to the given table. For
--   example,
--   
--   <pre>
--   add_column "posts" "title" "VARCHAR(255)"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   ALTER TABLE "posts" add "title" VARCHAR(255);
--   </pre>
add_column_stmt :: ByteString -> ByteString -> ByteString -> Query

-- | Returns a <a>Query</a> that creates an index for the given columns on
--   the given table. For example,
--   
--   <pre>
--   create_index_stmt "post_owner_index" "posts" "owner"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   CREATE INDEX "post_owner_index" ON "posts" ("owner")
--   </pre>
create_index_stmt :: Bool -> ByteString -> ByteString -> [ByteString] -> Query

-- | Returns a <a>Query</a> that drops a table
drop_table_stmt :: ByteString -> Query

-- | Returns a <a>Query</a> that drops a column from the given table. For
--   example,
--   
--   <pre>
--   drop_column "posts" "title"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   ALTER TABLE "posts" add "title";
--   </pre>
drop_column_stmt :: ByteString -> ByteString -> Query

-- | Returns a <a>Query</a> that drops an index.
--   
--   <pre>
--   drop_index_stmt "post_owner_index"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   DROP INDEX "post_owner_index"
--   </pre>
drop_index_stmt :: ByteString -> Query

-- | Returns a <a>Query</a> that renames a column in the given table. For
--   example,
--   
--   <pre>
--   rename_column "posts" "title" "name"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   ALTER TABLE "posts" RENAME "title" TO "name";
--   </pre>
rename_column_stmt :: ByteString -> ByteString -> ByteString -> Query

-- | Returns a <a>Query</a> that alters a column in the given table. For
--   example,
--   
--   <pre>
--   change_column "posts" "title" "DROP DEFAULT"
--   </pre>
--   
--   Returns the query
--   
--   <pre>
--   ALTER TABLE "posts" ALTER "title" DROP DEFAULT;
--   </pre>
change_column_stmt :: ByteString -> ByteString -> ByteString -> Query


-- | Functions for creating and running database migrations. You should
--   probably be using the <tt>pg_migrate</tt> executable to run
--   migrations, however these functions are exposed for developers that
--   want to integrate migrations more tightly into their applications or
--   utilities.
module Database.PostgreSQL.Migrate

-- | Initializes the database by creating a "schema-migrations" table. This
--   table must exist before running any migrations.
initializeDb :: IO ()

-- | Runs all new migrations in a given directory and dumps the resulting
--   schema to a file "schema.sql" in the migrations directory.
--   
--   Determining which migrations to run is done by querying the database
--   for the largest version in the <i>schema_migrations</i> table, and
--   choosing all migrations in the given directory with higher versions.
runMigrationsForDir :: Handle -> FilePath -> IO ExitCode
runRollbackForDir :: FilePath -> IO ExitCode

-- | Dumps the database schema to the given file handle.
--   
--   This is a wrapper around the utility <i>pg_dump</i> that comes with
--   postgresql. Therefore, <i>pg_dump</i> must be installed on the system.
dumpDb :: Handle -> IO ExitCode
newMigration :: FilePath -> FilePath -> IO ()

-- | The default relative path containing migrations:
--   <tt>"db/migrations"</tt>
defaultMigrationsDir :: FilePath
data MigrationDetails
MigrationDetails :: FilePath -> String -> String -> MigrationDetails
migrationPath :: MigrationDetails -> FilePath
migrationVersion :: MigrationDetails -> String
migrationName :: MigrationDetails -> String
instance Show MigrationDetails


-- | Utility function for describing a table in the database.
module Database.PostgreSQL.Describe
data ColumnInfo
ColumnInfo :: !Int16 -> ByteString -> !TypeInfo -> !Bool -> !Bool -> !Bool -> !(Maybe ByteString) -> ColumnInfo

-- | Internal column number used by PostgreSQL. Generally these will be
--   consecutive starting from 1, but this may not be the case if you have
--   altered a table to delete columns.
colNum :: ColumnInfo -> !Int16

-- | Name of the column
colName :: ColumnInfo -> ByteString

-- | Type of the column
colType :: ColumnInfo -> !TypeInfo

-- | If <a>True</a>, the database cannot contain null. (This constraint
--   should always be accurate.)
colNotNull :: ColumnInfo -> !Bool

-- | <a>True</a> if this column (and only this column) constitutes the
--   primary key of the table. Always <a>False</a> if the primary key
--   comprises multiple columns (even if this is one of those columns).
colPrimary :: ColumnInfo -> !Bool

-- | <a>True</a> if there is a uniqueness constraint on this column. Not
--   <a>True</a> if this column is part of a uniqueness constraint
--   involving multiple columns. (Such multi-column uniqueness constraints
--   are not reported by this interface.)
colUnique :: ColumnInfo -> !Bool

-- | If this there is a foreign key constraint on this column (and the
--   constraint does not span multiple columns), report the table
--   referenced by this column.
colReferences :: ColumnInfo -> !(Maybe ByteString)

-- | Returns a list of <a>ColumnInfo</a> structures for a particular table.
--   Not all information about a table is returned. In particular,
--   constraints that span columns are ignored.
describeTable :: Connection -> ByteString -> IO [ColumnInfo]
instance Show ColumnInfo


-- | Functions for initializing self-contained local postgreSQL database
--   clusters (useful in development more than production).
module Database.PostgreSQL.Devel

-- | Create a directory for a local database cluster entirely
--   self-contained within one directory. This is accomplished by creating
--   a new PostgreSQL database cluster in the directory and setting the
--   following configuration options in <tt>postgresql.conf</tt>:
--   
--   <ul>
--   <li><tt>listen_address</tt> is set to empty (i.e., <tt>''</tt>), so
--   that no TCP socket is bound, avoiding conflicts with any other running
--   instaces of PostgreSQL.</li>
--   <li><tt>logging_collector</tt> is set to <tt>yes</tt>, so that all
--   message logs are kept in the <tt>pg_log</tt> subdirectory of the
--   directory you specified.</li>
--   </ul>
--   
--   Note this function does <i>not</i> start a postgres server after
--   creating the directory. You will seperately need to start the server
--   using <a>startLocalDB</a> or <a>initLocalDB</a>. (And note that
--   <a>initLocalDB</a> already calls <tt>createLocalDB</tt> if the
--   directory does not exist or is empty. Hence the primary use of this
--   function is if you want to call <a>configLocalDB</a> between
--   <a>createLocalDB</a> and <a>startLocalDB</a>.)
createLocalDB :: FilePath -> IO ()

-- | Set configuration parameters on a database by editing the
--   <tt>postgresql.conf</tt> file. Takes the database directory and a list
--   of <tt>(</tt><i>parameter</i><tt>,</tt> <i>full-line</i><tt>)</tt>
--   pairs. For example, when creating a throw-away database cluster you
--   later intend to discard, you might say:
--   
--   <pre>
--   configLocalDB dbpath [("fsync", "fsync = off")]
--   </pre>
--   
--   Note that the second element of each pair is the complete
--   configuration line. It is not correct to say:
--   
--   <pre>
--   configLocalDB dbpath [("fsync", "off")]   -- INCORRECT
--   </pre>
configLocalDB :: FilePath -> [(String, String)] -> IO ()

-- | Start a local database if the server is not already running.
--   Otherwise, does nothing, but returns a <a>ConnectInfo</a> in either
--   case. The database server will continue running after the current
--   process exits (but see <a>stopLocalDB</a>).
startLocalDB :: FilePath -> IO ConnectInfo

-- | A combination of <a>createLocalDB</a> and <a>startLocalDB</a>.
--   
--   The parameter is a PostgreSQL data directory. If the directory is
--   empty or does not exist, this function creates a new database cluster
--   (via <a>createLocalDB</a>). Then, if a database server is not already
--   running for the directory, starts a server. No matter what, returns a
--   <a>ConnectInfo</a> that will connect to the server running on this
--   local database.
--   
--   Note that if <tt>initLocalDB</tt> starts a postgres server, the server
--   process will continue running after the process that called
--   <tt>initLocalDB</tt> exits. This is normally fine. Since multiple
--   client processes may access the same PostgreSQL database, it makes
--   sense for the first client to start the database and no one to stop
--   it. See <a>stopLocalDB</a> if you wish to stop the server process
--   (which you should always do before deleting a test cluster). See also
--   <a>withTempDB</a> to create a temporary cluster for the purposes of
--   running a test suite.
initLocalDB :: FilePath -> IO ConnectInfo

-- | Stop the server for a local database cluster entirely self-contained
--   within one directory. You must call this before deleting the
--   directory, or else stray postgres processes will linger forever. If
--   the argument is the empty string, looks for the database directory in
--   the <tt>PGDATA</tt> environment variable.
stopLocalDB :: FilePath -> IO ()

-- | Set environment variables to make a local database cluster the
--   default. Also returns shell commands you can eval or cut-and-paste
--   into your shell to make <tt>pg_ctl</tt> and <tt>psql</tt> access a
--   local database cluster.
setLocalDB :: FilePath -> IO String

-- | Run a function with a completely fresh database cluster that gets
--   deleted on return. Since the entire database is blown away when the
--   function returns, <tt>withTempDB</tt> is obviously only useful for
--   test suites.
withTempDB :: (ConnectInfo -> IO a) -> IO a

-- | Reset a connection to its default state before re-cycling it for
--   another thread or request.
resetConnection :: Connection -> IO ()

module Data.RequireSelector

-- | The point of this class is to ensure that you are using data types
--   defined with record selectors (i.e., <tt>data Foo = Foo { unFoo :: Int
--   }</tt> as opposed to <tt>data Foo = Foo Int</tt>).
--   
--   Unfortunately, <a>GHC.Generics</a> makes the <a>NoSelector</a> type a
--   member of the <a>Selector</a> class. Hence, if you want to ensure a
--   type <tt>a</tt> is <i>not</i> <a>NoSelector</a>, use the context
--   <tt>(RequireSelector a) =&gt;</tt>.
--   
--   If you see a compilation error involving <tt>RequireSelector</tt> or
--   <tt>IntentionallyCauseError</tt>, it means you failed to define one of
--   your datatypes using record selector syntax.
class RequireSelector a
instance RequireSelector a
instance IntentionallyCauseError NoSelector => RequireSelector NoSelector


-- | The main database ORM interface. This module contains functionality
--   for moving a Haskell data structure in and out of a database table.
--   
--   The most important feature is the <a>Model</a> class, which encodes a
--   typed database interface (i.e., the ORM layer). This class has a
--   default implementation for types that are members of the
--   <a>Generic</a> class (using GHC's <tt>DeriveGeneric</tt> extension),
--   provided the following conditions hold:
--   
--   <ol>
--   <li>The data type must have a single constructor that is defined using
--   record selector syntax.</li>
--   <li>The very first field of the data type must be a <a>DBKey</a> to
--   represent the primary key. Other orders will cause a compilation
--   error.</li>
--   <li>Every field of the data structure must be an instance of
--   <a>FromField</a> and <a>ToField</a>.</li>
--   </ol>
--   
--   If these three conditions hold and your database naming scheme follows
--   the conventions of <a>defaultModelInfo</a>--namely that the table name
--   is the same as the type name with the first character downcased, and
--   the field names are the same as the column names--then it is
--   reasonable to have a completely empty (default) instance declaration:
--   
--   <pre>
--   data MyType = MyType { myKey :: !DBKey
--                        , myName :: !S.ByteString
--                        , myCamelCase :: !Int
--                        , ...
--                        } deriving (Show, Generic)
--   instance Model MyType
--   </pre>
--   
--   The default <a>modelInfo</a> method is called <a>defaultModelInfo</a>.
--   You may wish to use almost all of the defaults, but tweak a few
--   things. This is easily accomplished by overriding a few fields of the
--   default structure. For example, suppose your database columns use
--   exactly the same name as your Haskell field names, but the name of
--   your database table is not the same as the name of the Haskell data
--   type. You can override the database table name (field
--   <a>modelTable</a>) as follows:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = defaultModelInfo { modelTable = "my_type" }
--   </pre>
--   
--   Finally, if you dislike the conventions followed by
--   <a>defaultModelInfo</a>, you can simply implement an alternate
--   pattern. An example of this is <a>underscoreModelInfo</a>, which
--   strips a prefix off every field name and converts everything from
--   camel-case to underscore notation:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = underscoreModelInfo "my"
--   </pre>
--   
--   The above code will associate <tt>MyType</tt> with a database table
--   <tt>my_type</tt> having column names <tt>key</tt>, <tt>name</tt>,
--   <tt>camel_case</tt>, etc.
--   
--   You can implement other patterns like <a>underscoreModelInfo</a> by
--   calling <a>defaultModelInfo</a> and modifying the results.
--   Alternatively, you can directly call the lower-level functions from
--   which <a>defaultModelInfo</a> is built (<a>defaultModelTable</a>,
--   <a>defaultModelColumns</a>, <a>defaultModelGetPrimaryKey</a>).
module Database.PostgreSQL.ORM.Model

-- | The class of data types that represent a database table. This class
--   conveys information necessary to move a Haskell data structure in and
--   out of a database table. The most important field is <a>modelInfo</a>,
--   which describes the database table and column names. <a>modelInfo</a>
--   has a reasonable default implementation for types that are members of
--   the <a>Generic</a> class (using GHC's <tt>DeriveGeneric</tt>
--   extension), provided the following conditions hold:
--   
--   <ol>
--   <li>The data type must have a single constructor that is defined using
--   record selector syntax.</li>
--   <li>The very first field of the data type must be a <a>DBKey</a> to
--   represent the primary key. Other orders will cause a compilation
--   error.</li>
--   <li>Every field of the data structure must be an instance of
--   <a>FromField</a> and <a>ToField</a>.</li>
--   </ol>
--   
--   If these three conditions hold and your database naming scheme follows
--   the conventions of <a>defaultModelInfo</a>--namely that the table name
--   is the same as the type name with the first character downcased, and
--   the field names are the same as the column names--then it is
--   reasonable to have a completely empty (default) instance declaration:
--   
--   <pre>
--   data MyType = MyType { myKey :: !DBKey
--                        , myName :: !S.ByteString
--                        , myCamelCase :: !Int
--                        , ...
--                        } deriving (Show, Generic)
--   instance Model MyType
--   </pre>
--   
--   The default <a>modelInfo</a> method is called <a>defaultModelInfo</a>.
--   You may wish to use almost all of the defaults, but tweak a few
--   things. This is easily accomplished by overriding a few fields of the
--   default structure. For example, suppose your database columns use
--   exactly the same name as your Haskell field names, but the name of
--   your database table is not the same as the name of the Haskell data
--   type. You can override the database table name (field
--   <a>modelTable</a>) as follows:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = defaultModelInfo { modelTable = "my_type" }
--   </pre>
--   
--   Finally, if you dislike the conventions followed by
--   <a>defaultModelInfo</a>, you can simply implement an alternate
--   pattern. An example of this is <a>underscoreModelInfo</a>, which
--   strips a prefix off every field name and converts everything from
--   camel-case to underscore notation:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = underscoreModelInfo "my"
--   </pre>
--   
--   The above code will associate <tt>MyType</tt> with a database table
--   <tt>my_type</tt> having column names <tt>key</tt>, <tt>name</tt>,
--   <tt>camel_case</tt>, etc.
--   
--   You can implement other patterns like <a>underscoreModelInfo</a> by
--   calling <a>defaultModelInfo</a> and modifying the results.
--   Alternatively, you can directly call the lower-level functions from
--   which <a>defaultModelInfo</a> is built (<a>defaultModelTable</a>,
--   <a>defaultModelColumns</a>, <a>defaultModelGetPrimaryKey</a>).
class Model a where modelInfo = defaultModelInfo modelIdentifiers = defaultModelIdentifiers modelInfo modelRead = defaultFromRow modelWrite = defaultModelWrite modelQueries = defaultModelQueries modelIdentifiers modelCreateInfo = emptyModelCreateInfo modelValid = const mempty
modelInfo :: Model a => ModelInfo a
modelIdentifiers :: Model a => ModelIdentifiers a
modelRead :: Model a => RowParser a
modelWrite :: Model a => a -> [Action]
modelQueries :: Model a => ModelQueries a
modelCreateInfo :: Model a => ModelCreateInfo a
modelValid :: Model a => a -> ValidationError

-- | A <tt>ModelInfo T</tt> contains the information necessary for mapping
--   <tt>T</tt> to a database table. Each <tt><a>Model</a></tt> type has a
--   single <tt>ModelInfo</tt> associated with it, accessible through the
--   <a>modelInfo</a> method of the <a>Model</a> class. Note the table and
--   column names must all be unquoted in this data structure, as they will
--   later be quoted using <a>quoteIdent</a> by the <a>modelIdentifiers</a>
--   method.
data ModelInfo a
ModelInfo :: !ByteString -> ![ByteString] -> !Int -> !(a -> DBKey) -> ModelInfo a

-- | The name of the database table corresponding to this model. The
--   default <a>modelInfo</a> instance uses <a>defaultModelTable</a>, which
--   is the name of your data type with the first letter downcased.
modelTable :: ModelInfo a -> !ByteString

-- | The names of the database columns corresponding to fields of this
--   model. The column names should appear in the order in which the fields
--   are defined in the Haskell data type <tt>a</tt> (which should also be
--   the order in which <a>modelRead</a> parses them to an <tt>a</tt> and
--   <a>modelWrite</a> marshalls them).
--   
--   Note that all queries generated by the library specify explicit column
--   names. Hence the order of columns does not need to match their order
--   in the database table. They should instead match the order of fields
--   in the Haskell data structure.
--   
--   The default, given by <a>defaultModelColumns</a>, is to use the
--   Haskell field names for <tt>a</tt>. This default will fail to compile
--   if <tt>a</tt> is not defined using record syntax.
modelColumns :: ModelInfo a -> ![ByteString]

-- | The 0-based index of the primary key column in <a>modelColumns</a>.
--   This should be 0 when your data structure's first field is its
--   <a>DBKey</a> (highly recommended, and required by
--   <a>defaultModelGetPrimaryKey</a>). If you customize this field, you
--   must also customize <a>modelGetPrimaryKey</a>--no check is made that
--   the two are consistent.
modelPrimaryColumn :: ModelInfo a -> !Int

-- | Return the primary key of a particular model instance. If you
--   customize this field, you must also customize
--   <a>modelPrimaryColumn</a>--no check is made that the two are
--   consistent.
modelGetPrimaryKey :: ModelInfo a -> !(a -> DBKey)

-- | SQL table and column identifiers that should be copied verbatim into
--   queries. For normal models, these will simply be quoted versions of
--   the fields in the corresponding <a>ModelInfo</a>. However, for special
--   cases, the fields of this structure can contain unquoted SQL including
--   <tt>JOIN</tt> keywords. In the case of joins, different elements of
--   <a>modelQColumns</a> may be qualified by different table names.
--   
--   Note that <a>modelQColumns</a> and <a>modelQPrimaryColumn</a> both
--   contain table-qualified names (e.g., <tt>"\"my_type\".\"key\""</tt>),
--   while <a>modelQWriteColumns</a> contains only the quoted column names.
data ModelIdentifiers a
ModelIdentifiers :: !ByteString -> ![ByteString] -> ByteString -> [ByteString] -> !(Maybe ByteString) -> !(Maybe ByteString) -> ModelIdentifiers a

-- | Literal SQL for the name of the table.
modelQTable :: ModelIdentifiers a -> !ByteString

-- | Literal SQL for each, table-qualified column.
modelQColumns :: ModelIdentifiers a -> ![ByteString]

-- | Literal SQL for the model's table-qualified primary key column.
modelQPrimaryColumn :: ModelIdentifiers a -> ByteString

-- | Literal SQL for all the columns except the primary key. These are the
--   columns that should be included in an <tt>INSERT</tt> or
--   <tt>UPDATE</tt>. Note that unlike the other fields, these column names
--   should <i>not</i> be table-qualified.
modelQWriteColumns :: ModelIdentifiers a -> [ByteString]

-- | When all columns in <a>modelQColumns</a> are qualified by the same
--   table name, this field contains <a>Just</a> the table name. For the
--   <a>:.</a> type (in which different columns have different table
--   qualifications), this field is <a>Nothing</a>.
--   
--   For normal models, this field will be identical to <a>modelQTable</a>.
--   However, for <a>As</a> models, <a>modelQTable</a> will contain
--   unquoted SQL such as <tt>"\"MyType\" AS \"my_alias\""</tt>, in which
--   case <tt>modelQualifier</tt> will contain <tt><a>Just</a>
--   "\"my_alias\""</tt>.
modelQualifier :: ModelIdentifiers a -> !(Maybe ByteString)

-- | The original, unquoted name of the table representing the model in the
--   database. Ordinarily, this should be the same as <a>modelTable</a> in
--   <a>ModelInfo</a>, but in the case of <a>As</a> aliases, the
--   <a>modelTable</a> is an alias, and <a>modelOrigTable</a> is the
--   original table. <a>Nothing</a> for joins.
modelOrigTable :: ModelIdentifiers a -> !(Maybe ByteString)

-- | Standard CRUD (create/read/update/delete) queries on a model.
data ModelQueries a
ModelQueries :: !Query -> !Query -> !Query -> !Query -> ModelQueries a

-- | A query template for looking up a model by its primary key. Expects a
--   single query parameter, namely the <a>DBKey</a> or <a>DBRef</a> being
--   looked up.
modelLookupQuery :: ModelQueries a -> !Query

-- | A query template for updating an existing <a>Model</a> in the
--   database. Expects as query parameters a value for every column of the
--   model <i>except</i> the primary key, followed by the primary key. (The
--   primary key is not written to the database, just used to select the
--   row to change.)
modelUpdateQuery :: ModelQueries a -> !Query

-- | A query template for inserting a new <a>Model</a> in the database. The
--   query parameters are values for all columns <i>except</i> the primary
--   key. The query returns the full row as stored in the database
--   (including the values of fields, such as the primary key, that have
--   been chosen by the database server).
modelInsertQuery :: ModelQueries a -> !Query

-- | A query template for deleting a <a>Model</a> from the database. Should
--   have a single query parameter, namely the <a>DBKey</a> of the row to
--   delete.
modelDeleteQuery :: ModelQueries a -> !Query

-- | An alternate <a>Model</a> pattern in which Haskell type and field
--   names are converted from camel-case to underscore notation. The first
--   argument is a prefix to be removed from field names (since Haskell
--   requires field names to be unique across data types, while SQL allows
--   the same column names to be used in different tables).
--   
--   For example:
--   
--   <pre>
--   data Bar = Bar {
--       barId :: !DBKey
--     , barNameOfBar :: !String
--     , barParent :: !(Maybe (DBRef Bar))
--     } deriving (Show, Generic)
--   
--   instance Model Bar where modelInfo = underscoreModelInfo "bar"
--   </pre>
--   
--   would associate type <tt>Bar</tt> with a database table called
--   <tt>bar</tt> with fields <tt>id</tt>, <tt>name_of_bar</tt>, and
--   <tt>parent</tt>.
underscoreModelInfo :: (Generic a, GToRow (Rep a), GFromRow (Rep a), GPrimaryKey0 (Rep a), GColumns (Rep a), GDatatypeName (Rep a)) => ByteString -> ModelInfo a

-- | A type large enough to hold database primary keys. Do not use this
--   type directly in your data structures. Use <a>DBKey</a> to hold a
--   <a>Model</a>'s primary key and <a>DBRef</a> to reference the primary
--   key of another model.
type DBKeyType = Int64

-- | The type of the Haskell data structure field containing a model's
--   primary key.
--   
--   Every <a>Model</a> must have exactly one <tt>DBKey</tt>, and the
--   <tt>DBKey</tt> must be the <a>Model</a>'s very first field in the
--   Haskel data type definition. (The ordering is enforced by
--   <a>defaultModelGetPrimaryKey</a>, which, through use of the
--   <tt>DeriveGeneric</tt> extension, fails to compile when the first
--   field is not a <tt>DBKey</tt>.)
--   
--   Each <a>Model</a> stored in the database should have a unique non-null
--   primary key. However, the key is determined at the time the
--   <a>Model</a> is inserted into the database. While you are constructing
--   a new <a>Model</a> to insert, you will not have its key. Hence, you
--   should use the value <tt>NullKey</tt> to let the database chose the
--   key.
--   
--   If you wish to store a <a>Model</a>'s primary key as a reference in
--   another <a>Model</a>, do not copy the <a>DBKey</a> structure. Use
--   <a>mkDBRef</a> to convert the <a>Model</a>'s primary key to a foreign
--   key reference.
data DBKey
DBKey :: !DBKeyType -> DBKey
NullKey :: DBKey

-- | Returns <a>True</a> when a <a>DBKey</a> is <a>NullKey</a>.
isNullKey :: DBKey -> Bool

-- | A <tt>DBRef T</tt> represents a many-to-one relationship between
--   tables. For example, if type <tt>A</tt> contains a <tt>DBRef B</tt>,
--   then each <tt>B</tt> is associated with many <tt>A</tt>'s. By
--   contrast, a <tt><a>DBRefUnique</a></tt> represents a one-to-one
--   relationship.
--   
--   <tt>DBRef</tt> is a type alias of kind <tt>* -&gt; *</tt>. The type
--   <tt>DBRef T</tt> references an instance of type <tt>T</tt> by the
--   primary key of its database row. The type argument <tt>T</tt> should
--   be an instance of <a>Model</a>.
type DBRef = GDBRef NormalRef

-- | A <tt>DBRefUnique T</tt> represents a one-to-one relationship between
--   types. For example, if type <tt>A</tt> contains a <tt>DBRefUnique
--   B</tt>, then each <tt>A</tt> is associated with one (or at most one)
--   <tt>B</tt>, and each <tt>B</tt> has one (or at most one) <tt>A</tt>
--   associated with it.
--   
--   By contrast, a <tt><a>DBRef</a></tt> represents a many-to-one
--   relationship.
type DBRefUnique = GDBRef UniqueRef

-- | Many operations can take either a <a>DBRef</a> or a <a>DBRefUnique</a>
--   (both of which consist internally of a <a>DBKeyType</a>). Hence, these
--   two types are just type aliases to a generalized reference type
--   <tt>GDBRef</tt>, where <tt>GDBRef</tt>'s first type argument,
--   <tt>reftype</tt>, is a phantom type denoting the flavor of reference
--   (<a>NormalRef</a> or <a>UniqueRef</a>).
newtype GDBRef reftype table
DBRef :: DBKeyType -> GDBRef reftype table

-- | Create a reference to the primary key of a <a>Model</a>, suitable for
--   storing in a <a>DBRef</a> or <a>DBRefUnique</a> field of a different
--   <a>Model</a>.
mkDBRef :: Model a => a -> GDBRef rt a

-- | Dump an entire model. Useful for development and debugging only, as
--   every row will be read into memory before the function returns.
--   
--   Note that unlike the other primary model operations, it is OK to call
--   <a>findAll</a> even on degenerate models such as <a>As</a> and
--   <a>:.</a>.
findAll :: Model r => Connection -> IO [r]

-- | Follow a <a>DBRef</a> or <a>DBRefUnique</a> and fetch the target row
--   from the database into a <a>Model</a> type <tt>r</tt>.
findRow :: Model r => Connection -> GDBRef rt r -> IO (Maybe r)

-- | Like <a>trySave</a> but instead of returning an <a>Either</a>, throws
--   a <a>ValidationError</a> if the <a>Model</a> is invalid.
save :: Model r => Connection -> r -> IO r

-- | <a>save</a> but returning '()' instead of the saved model.
save_ :: Model r => Connection -> r -> IO ()

-- | Write a <a>Model</a> to the database. If the primary key is
--   <a>NullKey</a>, the item is written with an <tt>INSERT</tt> query,
--   read back from the database, and returned with its primary key filled
--   in. If the primary key is not <a>NullKey</a>, then the <a>Model</a> is
--   written with an <tt>UPDATE</tt> query and returned as-is.
--   
--   If the <a>Model</a> is invalid (i.e. the return value of
--   <a>modelValid</a> is non-empty), a list of <tt>InvalidError</tt> is
--   returned instead.
trySave :: Model r => Connection -> r -> IO (Either ValidationError r)

-- | Remove the row corresponding to a particular data structure from the
--   database. This function only looks at the primary key in the data
--   structure. It is an error to call this function if the primary key is
--   not set.
destroy :: Model a => Connection -> a -> IO ()

-- | Remove a row from the database without fetching it first.
destroyByRef :: Model a => Connection -> GDBRef rt a -> IO ()

-- | Lookup the <a>modelTable</a> of a <a>Model</a> (<tt>modelName _ =
--   <a>modelTable</a> (<a>modelInfo</a> :: <a>ModelInfo</a> a)</tt>).
modelName :: Model a => a -> ByteString

-- | Lookup the primary key of a <a>Model</a>.
primaryKey :: Model a => a -> DBKey

-- | Generate a SQL <tt>SELECT</tt> statement with no <tt>WHERE</tt>
--   predicate. For example, <a>defaultModelLookupQuery</a> consists of
--   <tt>modelSelectFragment</tt> followed by "<tt>WHERE</tt>
--   <i>primary-key</i> = ?".
modelSelectFragment :: ModelIdentifiers a -> ByteString

-- | A newtype wrapper in the <a>FromRow</a> class, permitting every model
--   to be used as the result of a database query.
newtype LookupRow a
LookupRow :: a -> LookupRow a
lookupRow :: LookupRow a -> a

-- | A newtype wrapper in the <a>ToRow</a> class, which marshalls every
--   field except the primary key, followed by the primary key. For use
--   with <a>modelUpdateQuery</a>.
newtype UpdateRow a
UpdateRow :: a -> UpdateRow a

-- | A newtype wrapper in the <a>ToRow</a> class, which marshalls every
--   field except the primary key. For use with <a>modelInsertQuery</a>.
newtype InsertRow a
InsertRow :: a -> InsertRow a

-- | The newtype <tt>As</tt> can be wrapped around an existing type to give
--   it a table name alias in a query. This is necessary when a model is
--   being joined with itself, to distinguish the two joined instances of
--   the same table.
--   
--   For example:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data X = X instance <a>RowAlias</a> X where rowAliasName = const "x"
--   
--   ... r &lt;- <tt>dbSelect</tt> c $ addWhere_ "bar.bar_key =
--   x.bar_parent" modelDBSelect :: IO [Bar :. As X Bar] @
newtype As alias row
As :: row -> As alias row
unAs :: As alias row -> row

-- | <tt>fromAs</tt> extracts the <tt>row</tt> from an <tt><a>As</a> alias
--   row</tt>, but constrains the type of <tt>alias</tt> to be the same as
--   its first argument (which is non-strict). This can save you from
--   explicitly specifying types. For example:
--   
--   <pre>
--   data X = X deriving (Generic)
--   instance RowAlias X where rowAliasName = const "x"
--   
--   ...
--     r &lt;- map (\(b1 :. b2) -&gt; (b1, fromAs X b2)) &lt;$&gt;
--         dbSelect c $ addWhere \"bar.bar_key = x.bar_parent\" modelDBSelect
--   </pre>
fromAs :: alias -> As alias row -> row

-- | A type-restricted wrapper around the <a>As</a> constructor, under the
--   same rationale as <a>fromAs</a>. Not strict in its first argument.
toAs :: alias -> row -> As alias row

-- | The class of types that can be used as tags in as <a>As</a> alias.
--   Such types should be unit types--in other words, have exactly one
--   constructor where the constructor is nullary (take no arguments). The
--   reason for this class is that the <a>Model</a> instance for <a>As</a>
--   requires a way to extract the name of the row alias without having a
--   concrete instance of the type. This is provided by the
--   <a>rowAliasName</a> method (which must be non-strict).
class RowAlias a where rowAliasName _ = fromString $ caseFold $ gUnitTypeName . from $ a where caseFold (h : t) = toLower h : t caseFold [] = [] a = undefined :: a
rowAliasName :: RowAlias a => g a row -> ByteString

-- | The default definition of <a>modelInfo</a>. See the documentation at
--   <a>Model</a> for more information. Sets <a>modelTable</a> to the name
--   of the type with the first character converted to lower-case. Sets
--   <a>modelColumns</a> to the names of the Haskell field selectors. Sets
--   <a>modelPrimaryColumn</a> to <tt>0</tt> and extracts the first field
--   of the structure for <a>modelGetPrimaryKey</a>. Will fail to compile
--   unless the data structure is defined with record syntax and that its
--   first field is of type <a>DBKey</a>.
--   
--   Note that defaults for the individual fields are available in separate
--   functions (e.g., <a>defaultModelTable</a>) with fewer class
--   requirements in the context, in case you want to make piecemeal use of
--   defaults. The default for <a>modelPrimaryColumn</a> is 0. If you
--   overwrite that, you will need to overwrite <a>modelGetPrimaryKey</a>
--   as well (and likely vice versa).
defaultModelInfo :: (Generic a, GDatatypeName (Rep a), GColumns (Rep a), GPrimaryKey0 (Rep a)) => ModelInfo a

-- | The default name of the database table corresponding to a Haskell
--   type. The default is the same as the type name with the first letter
--   converted to lower-case. (The rationale is that Haskell requires types
--   to start with a capital letter, but all-lower-case table names are
--   easier to use in queries because PostgreSQL generally does not require
--   them to be quoted.)
defaultModelTable :: (Generic a, GDatatypeName (Rep a)) => a -> ByteString

-- | Returns the Haskell field names in a data structure.
defaultModelColumns :: (Generic a, GColumns (Rep a)) => a -> [ByteString]

-- | Extract the primary key of type <a>DBKey</a> from a model when the
--   <a>DBKey</a> is the first element of the data structure. Fails to
--   compile if the first field is not of type <a>DBKey</a>.
defaultModelGetPrimaryKey :: (Generic a, GPrimaryKey0 (Rep a)) => a -> DBKey

-- | The default simply quotes the <a>modelInfo</a> and <a>modelColumns</a>
--   fields of <a>ModelInfo</a> using <a>quoteIdent</a>.
defaultModelIdentifiers :: ModelInfo a -> ModelIdentifiers a

-- | Returns a series of <a>Action</a>s serializing each field of a data
--   structure (in the order of the Haskell datatype definition),
--   <i>except</i> the primary key, since the primary key should never be
--   written to a database. Every field must be an instance of
--   <a>ToField</a>.
defaultModelWrite :: (Model a, Generic a, GToRow (Rep a)) => a -> [Action]

-- | The default value of <a>modelQueries</a>.
defaultModelQueries :: ModelIdentifiers a -> ModelQueries a

-- | Default SQL lookup query for a model.
defaultModelLookupQuery :: ModelIdentifiers a -> Query

-- | Default SQL update query for a model.
defaultModelUpdateQuery :: ModelIdentifiers a -> Query

-- | Default SQL insert query for a model.
defaultModelInsertQuery :: ModelIdentifiers a -> Query

-- | Default SQL delete query for a model.
defaultModelDeleteQuery :: ModelIdentifiers a -> Query

-- | Quote an identifier such as a table or column name using double-quote
--   characters. Note this has nothing to do with quoting <i>values</i>,
--   which must be quoted using single quotes. (Anyway, all values should
--   be quoted by <a>query</a> or <a>fmtSql</a>.) This function uses a
--   unicode escape sequence to escape '?' characters, which would
--   otherwise be expanded by <a>query</a>, <a>formatQuery</a>, or
--   <a>fmtSql</a>.
--   
--   <pre>
--   &gt;&gt;&gt; S8.putStrLn $ quoteIdent "hello \"world\"!"
--   "hello ""world""!"
--   
--   &gt;&gt;&gt; S8.putStrLn $ quoteIdent "hello \"world\"?"
--    U&amp;"hello ""world""\003f"
--   </pre>
--   
--   Note that this quoting function is correct only if
--   <tt>client_encoding</tt> is <tt>SQL_ASCII</tt>, <tt>client_coding</tt>
--   is <tt>UTF8</tt>, or the identifier contains no multi-byte characters.
--   For other coding schemes, this function may erroneously duplicate
--   bytes that look like quote characters but are actually part of a
--   multi-byte character code. In such cases, maliciously crafted
--   identifiers will, even after quoting, allow injection of arbitrary SQL
--   commands to the server.
--   
--   The upshot is that it is unwise to use this function on identifiers
--   provided by untrustworthy sources. Note this is true anyway,
--   regardless of <tt>client_encoding</tt> setting, because certain
--   "system column" names (e.g., <tt>oid</tt>, <tt>tableoid</tt>,
--   <tt>xmin</tt>, <tt>cmin</tt>, <tt>xmax</tt>, <tt>cmax</tt>,
--   <tt>ctid</tt>) are likely to produce unexpected results even when
--   properly quoted.
--   
--   See <tt>Id</tt> for a convenient way to include quoted identifiers in
--   parameter lists.
quoteIdent :: ByteString -> ByteString

-- | Phantom type for instantiating <a>GDBRef</a> that represents a
--   one-to-many relationship between tables.
data NormalRef
NormalRef :: NormalRef

-- | Phantom type for instantiating <a>GDBRef</a> that represents a
--   one-to-one relationship between tables.
data UniqueRef
UniqueRef :: UniqueRef

-- | Extra information for <a>Database.PostgreSQL.ORM.CreateTable</a>. You
--   probably don't need to use this.
data ModelCreateInfo a
ModelCreateInfo :: ![(ByteString, ByteString)] -> !ByteString -> ModelCreateInfo a

-- | A list of (column-name, type) pairs for which you want to override the
--   default.
modelCreateColumnTypeExceptions :: ModelCreateInfo a -> ![(ByteString, ByteString)]

-- | Extra constraints to stick at the end of the <tt>CREATE TABLE</tt>
--   statement.
modelCreateExtraConstraints :: ModelCreateInfo a -> !ByteString

-- | A <a>ModelCreateInfo</a> that doesn't imply any extra constraints or
--   exceptions.
emptyModelCreateInfo :: ModelCreateInfo a

-- | This function provides a <a>fromRow</a> function for <a>Generic</a>
--   types, suitable as a default of the <a>FromRow</a> class. This module
--   uses it as the default implementation of <a>modelRead</a>.
defaultFromRow :: (Generic a, GFromRow (Rep a)) => RowParser a

-- | This function provides a <a>toRow</a> function for <a>Generic</a>
--   types that marshalls each field of the data type in the order in which
--   it appears in the type definition. This function is <i>not</i> a
--   suitable implementation of <a>modelWrite</a> (since it marshals the
--   primary key, which is not supposed to be written). However, it is
--   required internally by <a>defaultModelWrite</a>, and exposed in the
--   unlikely event it is of use to alternate generic <a>modelWrite</a>
--   functions. You probably don't want to call this function.
defaultToRow :: (Generic a, GToRow (Rep a)) => a -> [Action]

-- | Print to stdout the query statement.
printq :: Query -> IO ()

-- | This class extracts the first field in a data structure when the field
--   is of type <a>DBKey</a>. If you get a compilation error because of
--   this class, then move the <a>DBKey</a> first in your data structure.
class GPrimaryKey0 f

-- | This class extracts the field names of a Haskell data structure. Only
--   defined for types with a single constructor that uses record syntax.
class GColumns f

-- | This class returns the name of a datatype.
class GDatatypeName f
class GFromRow f
class GToRow f
instance Typeable DBKey
instance Typeable GDBRef
instance Typeable NormalRef
instance Typeable UniqueRef
instance Data DBKey
instance Generic DBKey
instance Eq (GDBRef reftype table)
instance (Data reftype, Data table) => Data (GDBRef reftype table)
instance Num (GDBRef reftype table)
instance Integral (GDBRef reftype table)
instance Real (GDBRef reftype table)
instance Ord (GDBRef reftype table)
instance Enum (GDBRef reftype table)
instance Bounded (GDBRef reftype table)
instance Generic (GDBRef reftype table)
instance Show NormalRef
instance Data NormalRef
instance Show UniqueRef
instance Data UniqueRef
instance Show (ModelIdentifiers a)
instance Show (ModelQueries a)
instance Show (ModelCreateInfo a)
instance Show a => Show (LookupRow a)
instance Show a => Show (InsertRow a)
instance Show a => Show (UpdateRow a)
instance Datatype D1DBKey
instance Constructor C1_0DBKey
instance Constructor C1_1DBKey
instance Datatype D1GDBRef
instance Constructor C1_0GDBRef
instance Model a => ToRow (UpdateRow a)
instance Model a => ToRow (InsertRow a)
instance Model a => FromRow (LookupRow a)
instance (Model a, RowAlias as) => Model (As as a)
instance (RowAlias alias, Show row) => Show (As alias row)
instance (Datatype c, GUnitType f) => GUnitType (D1 c f)
instance GUnitType V1
instance GUnitType (C1 c U1)
instance (Model a, Model b) => Model (a :. b)
instance FromField AnyField
instance Model a => Model (Maybe a)
instance (FromField a, FromField b, FromField c, FromField d, FromField e) => Model (a, b, c, d, e)
instance (FromField a, FromField b, FromField c, FromField d) => Model (a, b, c, d)
instance (FromField a, FromField b, FromField c) => Model (a, b, c)
instance (FromField a, FromField b) => Model (a, b)
instance FromField t => Model [t]
instance FromField t => Model (Only t)
instance GToRow f => GToRow (M1 i c f)
instance (GToRow a, GToRow b) => GToRow (a :*: b)
instance ToField c => GToRow (K1 i c)
instance GToRow U1
instance GFromRow f => GFromRow (M1 i c f)
instance (GFromRow a, GFromRow b) => GFromRow (a :*: b)
instance FromField c => GFromRow (K1 i c)
instance GFromRow U1
instance GPrimaryKey0 f => GPrimaryKey0 (D1 c f)
instance GPrimaryKey0 f => GPrimaryKey0 (C1 c f)
instance GPrimaryKey0 a => GPrimaryKey0 (a :*: b)
instance RequireSelector c => GPrimaryKey0 (S1 c (K1 i DBKey))
instance GColumns f => GColumns (M1 D c f)
instance GColumns f => GColumns (M1 C c f)
instance (GColumns a, GColumns b) => GColumns (a :*: b)
instance (Selector c, RequireSelector c) => GColumns (M1 S c f)
instance GColumns U1
instance Datatype c => GDatatypeName (D1 c f)
instance Show (ModelInfo a)
instance ToField (GDBRef rt t)
instance FromField (GDBRef rt t)
instance Model t => Read (GDBRef rt t)
instance Model t => Show (GDBRef rt t)
instance FromJSON (GDBRef t a)
instance ToJSON (GDBRef t a)
instance ToField DBKey
instance FromField DBKey
instance Show DBKey
instance Ord DBKey
instance Eq DBKey
instance FromJSON DBKey
instance ToJSON DBKey

module Database.PostgreSQL.ORM.DBSelect

-- | A deconstructed SQL select statement that allows easier manipulation
--   of individual terms. Several functions are provided to combine the
--   <a>selFields</a>, <a>selFrom</a>, and <a>selWhere</a> clauses of
--   muliple <tt>DBSelect</tt> structures. Other clauses may be discarded
--   when combining queries with join operations. Hence it is advisable to
--   set the other clauses at the end (or, if you set these fields, to
--   collapse your <a>DBSelect</a> structure into a subquery using
--   <a>dbProject'</a>).
data DBSelect a
DBSelect :: !Query -> !Query -> Query -> !FromClause -> !Query -> !Query -> !Query -> !Query -> !Query -> !Query -> !Query -> DBSelect a
selWith :: DBSelect a -> !Query

-- | By default <tt>"SELECT"</tt>, but might usefully be set to something
--   else such as <tt>"SELECT DISTINCT"</tt> in some situations.
selSelectKeyword :: DBSelect a -> !Query
selFields :: DBSelect a -> Query
selFrom :: DBSelect a -> !FromClause

-- | Empty by default, but set to <tt>"WHERE"</tt> if any <tt>WHERE</tt>
--   clauses are added to the <a>selWhere</a> field.
selWhereKeyword :: DBSelect a -> !Query
selWhere :: DBSelect a -> !Query
selGroupBy :: DBSelect a -> !Query
selHaving :: DBSelect a -> !Query
selOrderBy :: DBSelect a -> !Query
selLimit :: DBSelect a -> !Query
selOffset :: DBSelect a -> !Query

-- | As it's name would suggest, a <tt>FromClause</tt> is the part of a
--   query between the <tt>FROM</tt> keyword and the <tt>WHERE</tt>
--   keyword. It can consist of simple table names, <tt>JOIN</tt>
--   operations, and parenthesized subqueries.
--   
--   From clauses are represented in a more structured way than the other
--   fields so as to allow the possibility of collapsing join relations.
--   For instance, given a <tt><a>DBSelect</a> (A :. B)</tt> and a
--   <tt><a>DBSelect</a> (B :. C)</tt>, it is desirable to be able to
--   generate a <tt><a>DBSelect</a> (A :. B :. C)</tt> in which each pair
--   of terms involving <tt>B</tt> in the three-way relation is constrained
--   according to the original two queries. This functionality is provided
--   by <a>dbNest</a> and <a>dbChain</a>, but it requires the ability to
--   locate and replace the instance of type <tt>B</tt> in one
--   <a>DBSelect</a> with the <tt>FromClause</tt> of the other
--   <a>DBSelect</a>.
--   
--   The <a>fcCanonical</a> field is a canonical name of each type, which
--   by convention is the quoted and fully-qualified table name. Comparing
--   <a>fcCanonical</a> is somewhat of a hack, and happens entirely at
--   runtime. It would be nicer to do this at compile time, but doing so
--   would require language extensions such as <tt>GADTs</tt> of
--   <tt>FunctionalDependencies</tt>.
data FromClause
FromModel :: !Query -> !ByteString -> FromClause

-- | Verbatim SQL for a table, table <tt>AS</tt> alias, or parenthesized
--   subquery.
fcVerbatim :: FromClause -> !Query

-- | Canonical name of the table or join relation represented by this term.
--   For <tt>JOIN</tt> terms, this is always the <tt>CROSS JOIN</tt> of the
--   canonical names of <a>fcLeft</a> and <a>fcRight</a>. This means one
--   can locate a join given only it's type (e.g., the canonical name for
--   <tt>A :. B</tt> is always <tt>"a CROSS JOIN b"</tt>), but it does mean
--   you have to be careful not accidentally to merge two different joins
--   on the same types. For this reason it may be safest always to have
--   type <tt>b</tt> be a single table in <a>dbNest</a> and <a>dbChain</a>.
fcCanonical :: FromClause -> !ByteString
FromJoin :: !FromClause -> !Query -> !FromClause -> !Query -> !ByteString -> FromClause
fcLeft :: FromClause -> !FromClause

-- | Usually <tt>"JOIN"</tt>
fcJoinOp :: FromClause -> !Query
fcRight :: FromClause -> !FromClause

-- | <tt>ON</tt> or <tt>USING</tt> clause (or empty)
fcOnClause :: FromClause -> !Query

-- | Canonical name of the table or join relation represented by this term.
--   For <tt>JOIN</tt> terms, this is always the <tt>CROSS JOIN</tt> of the
--   canonical names of <a>fcLeft</a> and <a>fcRight</a>. This means one
--   can locate a join given only it's type (e.g., the canonical name for
--   <tt>A :. B</tt> is always <tt>"a CROSS JOIN b"</tt>), but it does mean
--   you have to be careful not accidentally to merge two different joins
--   on the same types. For this reason it may be safest always to have
--   type <tt>b</tt> be a single table in <a>dbNest</a> and <a>dbChain</a>.
fcCanonical :: FromClause -> !ByteString

-- | Run a <a>DBSelect</a> query on parameters. The number of <tt>'?'</tt>
--   characters embedeed in various fields of the <a>DBSelect</a> must
--   exactly match the number of fields in parameter type <tt>p</tt>. Note
--   the order of arguments is such that the <a>DBSelect</a> can be
--   pre-rendered and the parameters supplied later. Hence, you should use
--   this version when the <a>DBSelect</a> is static. For dynamically
--   modified <a>DBSelect</a> structures, you may prefer <a>dbSelect</a>.
dbSelectParams :: (Model a, ToRow p) => DBSelect a -> Connection -> p -> IO [a]

-- | Run a <a>DBSelect</a> query and return the resulting models.
dbSelect :: Model a => Connection -> DBSelect a -> IO [a]

-- | Datatype that represents a connected cursor
data Cursor a
Cursor :: !Connection -> !Query -> !Query -> IORef [a] -> Cursor a
curConn :: Cursor a -> !Connection
curName :: Cursor a -> !Query
curChunkSize :: Cursor a -> !Query
curCache :: Cursor a -> IORef [a]

-- | Create a <a>Cursor</a> for the given <a>DBSelect</a>
curSelect :: Model a => Connection -> DBSelect a -> IO (Cursor a)

-- | Fetch the next <a>Model</a> for the underlying <a>Cursor</a>. If the
--   cache has prefetched values, dbNext will return the head of the cache
--   without querying the database. Otherwise, it will prefetch the next
--   256 values, return the first, and store the rest in the cache.
curNext :: Model a => Cursor a -> IO (Maybe a)

-- | Streams results of a <a>DBSelect</a> and consumes them using a
--   left-fold. Uses default settings for <a>Cursor</a> (batch size is 256
--   rows).
dbFold :: Model model => Connection -> (b -> model -> b) -> b -> DBSelect model -> IO b

-- | Streams results of a <a>DBSelect</a> and consumes them using a monadic
--   left-fold. Uses default settings for <a>Cursor</a> (batch size is 256
--   rows).
dbFoldM :: (MonadIO m, Model model) => Connection -> (b -> model -> m b) -> b -> DBSelect model -> m b

-- | Streams results of a <a>DBSelect</a> and consumes them using a monadic
--   left-fold. Uses default settings for <a>Cursor</a> (batch size is 256
--   rows).
dbFoldM_ :: (MonadIO m, Model model) => Connection -> (model -> m ()) -> DBSelect model -> m ()

-- | Group the returned tuples by unique a's. Expects the query to return
--   a's in sequence -- all rows with the same value for a must be grouped
--   together, for example, by sorting the result on a's primary key
--   column.
dbCollect :: (Model a, Model b) => Connection -> DBSelect (a :. b) -> IO [(a, [b])]

-- | Turn a <a>DBSelect</a> into a <a>Query</a> suitable for the
--   <a>query</a> or <a>query_</a> functions.
renderDBSelect :: DBSelect a -> Query

-- | Create a <a>Builder</a> for a rendered version of a <a>DBSelect</a>.
--   This can save one string copy if you want to embed one query inside
--   another as a subquery, as done by <a>dbProject'</a>, and thus need to
--   parenthesize it. However, the function is probably not a useful for
--   end users.
buildDBSelect :: DBSelect a -> Builder

-- | A <a>DBSelect</a> structure with keyword <tt>"SELECT"</tt> and
--   everything else empty.
emptyDBSelect :: DBSelect a

-- | A <a>DBSelect</a> for one or more comma-separated expressions, rather
--   than for a table. For example, to issue the query <tt>"SELECT
--   lastval()"</tt>:
--   
--   <pre>
--   lastval :: DBSelect (Only DBKeyType)
--   lastval = expressionDBSelect "lastval ()"
--   
--     ...
--     [just_inserted_id] &lt;- dbSelect conn lastval
--   </pre>
--   
--   On the other hand, for such a simple expression, you might as well
--   call <a>query_</a> directly.
expressionDBSelect :: Model r => Query -> DBSelect r

-- | A <a>DBSelect</a> that returns all rows of a model.
modelDBSelect :: Model a => DBSelect a

-- | Create a join of the <a>selFields</a>, <a>selFrom</a>, and
--   <a>selWhere</a> clauses of two <a>DBSelect</a> queries. Other fields
--   are simply taken from the second <a>DBSelect</a>, meaning fields such
--   as <a>selWith</a>, <a>selGroupBy</a>, and <a>selOrderBy</a> in the in
--   the first <a>DBSelect</a> are entirely ignored.
dbJoin :: (Model a, Model b) => DBSelect a -> Query -> DBSelect b -> Query -> DBSelect (a :. b)

-- | A version of <a>dbJoin</a> that uses <a>modelDBSelect</a> for the
--   joined tables.
dbJoinModels :: (Model a, Model b) => Query -> Query -> DBSelect (a :. b)

-- | Restrict the fields returned by a DBSelect to be those of a single
--   <a>Model</a> <tt>a</tt>. It only makes sense to do this if <tt>a</tt>
--   is part of <tt>something_containing_a</tt>, but no static check is
--   performed that this is the case. If you <tt>dbProject</tt> a type that
--   doesn't make sense, you will get a runtime error from a failed
--   database query.
dbProject :: Model a => DBSelect something_containing_a -> DBSelect a

-- | Like <a>dbProject</a>, but renders the entire input <a>DBSelect</a> as
--   a subquery. Hence, you can no longer mention fields of models other
--   than <tt>a</tt> that might be involved in joins. The two advantages of
--   this approach are 1) that you can once again join to tables that were
--   part of the original query without worrying about row aliases, and 2)
--   that all terms of the <a>DBSelect</a> will be faithrully rendered into
--   the subquery (whereas otherwise they could get dropped by join
--   operations). Generally you will still want to use <a>dbProject</a>,
--   but <tt>dbProject'</tt> is available when needed.
dbProject' :: Model a => DBSelect something_containing_a -> DBSelect a

-- | Nest two type-compatible <tt>JOIN</tt> queries. As with <a>dbJoin</a>,
--   fields of the first <tt>JOIN</tt> (the <tt><a>DBSelect</a> (a :.
--   b)</tt>) other than <a>selFields</a>, <a>selFrom</a>, and
--   <a>selWhere</a> are entirely ignored.
dbNest :: (Model a, Model b) => DBSelect (a :. b) -> DBSelect (b :. c) -> DBSelect (a :. (b :. c))

-- | Like <a>dbNest</a>, but projects away the middle type <tt>b</tt>.
dbChain :: (Model a, Model b, Model c) => DBSelect (a :. b) -> DBSelect (b :. c) -> DBSelect (a :. c)

-- | Add a where clause verbatim to a <a>DBSelect</a>. The clause must
--   <i>not</i> contain the <tt>WHERE</tt> keyword (which is added
--   automatically by <tt>addWhere_</tt> if needed). If the
--   <tt>DBSelect</tt> has existing <tt>WHERE</tt> clauses, the new clause
--   is appended with <tt>AND</tt>. If the query contains any <tt>'?'</tt>
--   characters, they will be rendered into the query and matching
--   parameters will later have to be filled in via a call to
--   <a>dbSelectParams</a>.
addWhere_ :: Query -> DBSelect a -> DBSelect a

-- | Add a where clause, and pre-render parameters directly into the
--   clause. The argument <tt>p</tt> must have exactly as many fields as
--   there are <tt>'?'</tt> characters in the <a>Query</a>. Example:
--   
--   <pre>
--   bars &lt;- dbSelect c $ addWhere "bar_id = ?" (Only target_id) $
--                        (modelDBSelect :: DBSelect Bar)
--   </pre>
addWhere :: ToRow p => Query -> p -> DBSelect a -> DBSelect a

-- | Set the <tt>ORDER BY</tt> clause of a <a>DBSelect</a>. Example:
--   
--   <pre>
--   dbSelect c $ setOrderBy "\"employeeName\" DESC NULLS FIRST" $
--                  modelDBSelect
--   </pre>
setOrderBy :: Query -> DBSelect a -> DBSelect a

-- | Set the <tt>LIMIT</tt> clause of a <a>DBSelect</a>.
setLimit :: Int -> DBSelect a -> DBSelect a

-- | Set the <tt>OFFSET</tt> clause of a <a>DBSelect</a>.
setOffset :: Int -> DBSelect a -> DBSelect a

-- | Add one or more comma-separated expressions to <a>selFields</a> that
--   produce column values without any corresponding relation in the
--   <tt>FROM</tt> clause. Type <tt>r</tt> is the type into which the
--   expression is to be parsed. Generally this will be an instance of
--   <a>FromRow</a> that is a degenerate model (e.g., <a>Only</a>, or a
--   tuple).
--   
--   For example, to rank results by the field <tt>value</tt> and compute
--   the fraction of overall value they contribute:
--   
--   <pre>
--   r &lt;- dbSelect c $ addExpression
--          "rank() OVER (ORDER BY value), value::float4/SUM(value) OVER ()"
--          modelDBSelect
--            :: IO [Bar :. (Int, Double)]
--   </pre>
addExpression :: Model r => Query -> DBSelect a -> DBSelect (a :. r)
instance Show FromClause
instance Generic (DBSelect a)
instance Datatype D1DBSelect
instance Constructor C1_0DBSelect
instance Selector S1_0_0DBSelect
instance Selector S1_0_1DBSelect
instance Selector S1_0_2DBSelect
instance Selector S1_0_3DBSelect
instance Selector S1_0_4DBSelect
instance Selector S1_0_5DBSelect
instance Selector S1_0_6DBSelect
instance Selector S1_0_7DBSelect
instance Selector S1_0_8DBSelect
instance Selector S1_0_9DBSelect
instance Selector S1_0_10DBSelect
instance GDBS f => GDBS (M1 i c f)
instance (GDBS a, GDBS b) => GDBS (a :*: b)
instance GDBS (K1 i FromClause)
instance GDBS (K1 i Query)
instance Show (DBSelect a)

module Database.PostgreSQL.ORM.SqlType

-- | The class of Haskell types that can be converted to and from a
--   particular SQL type. For most instances, you only need to define
--   <a>sqlBaseType</a>.
class (ToField a, FromField a) => SqlType a where sqlType _ = (sqlBaseType (undefined :: a)) <> " NOT NULL"
sqlBaseType :: SqlType a => a -> ByteString
sqlType :: SqlType a => a -> ByteString

-- | Retreive the <a>Oid</a> corresponding to a type. You can subsequently
--   use the <a>Oid</a> to call <tt>getTypeInfo</tt> for more information
--   on the type.
getTypeOid :: Connection -> ByteString -> IO Oid
instance Model a => SqlType (DBRefUnique a)
instance Model a => SqlType (DBRef a)
instance (Typeable a, SqlType a) => SqlType (Vector a)
instance SqlType a => SqlType (Maybe a)
instance SqlType DBKey
instance SqlType (Binary ByteString)
instance SqlType (Binary ByteString)
instance SqlType String
instance SqlType LocalTimestamp
instance SqlType UTCTimestamp
instance SqlType ZonedTimestamp
instance SqlType Date
instance SqlType Day
instance SqlType UTCTime
instance SqlType TimeOfDay
instance SqlType ZonedTime
instance SqlType LocalTime
instance SqlType Oid
instance SqlType Text
instance SqlType Text
instance SqlType ByteString
instance SqlType ByteString
instance SqlType Int64
instance SqlType Int32
instance SqlType Int16
instance SqlType Float
instance SqlType Double
instance SqlType Bool
instance FromField ExtractTypeOid


-- | Functions to extract a field of a particular type from a
--   <a>Generic</a> data structure, when the data structure contains
--   exactly one field of the given type. Only works for types with exactly
--   one constructor (not variant types).
--   
--   An example of usage:
--   
--   <pre>
--   data MyType = MyType { myString :: String             -- position 0
--                        , myInt :: Int                   -- position 1
--                        , myBool :: Bool                 -- position 2
--                        , myMaybeChar :: Maybe Char      -- position 3
--                        , myMaybeString :: Maybe String  -- position 4
--                        } deriving (Show, Generic)
--   
--   myType :: MyType
--   myType = MyType "my type" 21 True Nothing (Just "maybe string")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getFieldVal ExtractId myType :: String
--   "my type"
--   
--   &gt;&gt;&gt; getFieldVal ExtractId myType :: Int
--   21
--   
--   &gt;&gt;&gt; getFieldVal ExtractMaybe myType :: Maybe Char
--   Nothing
--   
--   &gt;&gt;&gt; getFieldVal ExtractMaybe myType :: Maybe Int
--   Just 21
--   
--   &gt;&gt;&gt; getFieldVal ExtractMaybe myType :: Maybe String  -- ambiguous
--   &lt;interactive&gt;:5:1: Couldn't match type `THasMany' with `THasOne'
--   
--   &gt;&gt;&gt; getFieldPos' ExtractId (undefined :: MyType) (undefined :: Bool)
--   2
--   
--   &gt;&gt;&gt; getFieldPos' ExtractMaybe (undefined :: MyType) (undefined :: Maybe Bool)
--   2
--   
--   &gt;&gt;&gt; getFieldPos' ExtractMaybe myType ()  -- No field has type ()
--   &lt;interactive&gt;:8:1: Couldn't match type `THasNone' with `THasOne'
--   </pre>
module Data.GetField
class (Generic a, GGetField f (Rep a) r THasOne) => GetField f a r
getFieldVal :: GetField f a r => f r -> a -> r
getFieldPos :: GetField f a r => f r -> a -> Int

-- | An extractor that matches an exact field type.
data ExtractId r
ExtractId :: ExtractId r

-- | An extractor that matches either type <tt>r</tt> or type <tt>Maybe
--   r</tt>, and, in the former case, wraps <tt>Just</tt> around the value
--   so as always to return type <tt>Maybe r</tt>.
data ExtractMaybe r
ExtractMaybe :: ExtractMaybe r

-- | A variant of <a>getFieldPos</a> in which the type of the field is
--   supplied as a non-strict argument. This may be easier than typecasting
--   the extractor argument. For example, to extract the <a>Int</a> from a
--   structure with a single <a>Int</a> field:
--   
--   <pre>
--   getFieldPos' <a>ExtractId</a> myStruct (<a>undefined</a> :: <a>Int</a>)
--   </pre>
getFieldPos' :: (Generic a, GGetField f (Rep a) r THasOne) => (f ()) -> a -> r -> Int

-- | Exactly one matching field has been found.
newtype THasOne a
THasOne :: a -> THasOne a
fromTHasOne :: THasOne a -> a

-- | Zero matching fields have been found.
data THasNone a
THasNone :: THasNone a

-- | More than one matching field has been found.
newtype THasMany a
THasMany :: [a] -> THasMany a
fromTHasMany :: THasMany a -> [a]

-- | Class of types used as tag arguments to <a>gGetFieldVal</a> and
--   <a>gGetFieldPos</a>. <tt>f</tt> should be a new unit type of kind
--   <tt>* -&gt; *</tt>, used to designate the type of extraction you want.
--   Then instances should be defined to transform each type <tt>a</tt> you
--   want to extract to some type <tt>r</tt>, with <tt>g</tt> set to
--   <a>THasOne</a>.
--   
--   For example, <a>ExtractMaybe</a> is a type to convert types <tt>a</tt>
--   and <tt>Maybe a</tt> both to type <tt>Maybe a</tt> (i.e., type
--   argument <tt>r</tt> is <tt>Maybe a</tt>).
--   
--   <pre>
--   data ExtractMaybe a = ExtractMaybe
--   instance Extractor ExtractMaybe a (Maybe a) THasOne where
--     extract _ = THasOne . Just
--   instance Extractor ExtractMaybe (Maybe a) (Maybe a) THasOne where
--     extract _ = THasOne
--   </pre>
--   
--   Note that there is already a default general instance returning
--   <a>THasNone</a>. Hence, you do not need to define one. Otherwise, you
--   would have to define an overlapping instance such as:
--   
--   <pre>
--   instance Extractor ExtractMaybe a b THasZero where  -- Incorrect
--     extract _ = THasNone
--   </pre>
--   
--   (Except the above wouldn't quite work anyway given the rules for
--   overlapping instances.) So just assume that any instance you don't
--   explicitly define for your <a>Extractor</a> will automatically fall
--   back to <a>THasNone</a>.
class Extractor f a r g | f a r -> g where extractCount fr a = gCount (extract fr a)
extract :: Extractor f a r g => f r -> a -> g r
extractCount :: Extractor f a r g => f r -> a -> (Int, [Int])

-- | Generlized extraction of a field from a <a>Generic</a> data structure.
--   Argument <tt>rep</tt> should generally be the type <tt><a>Rep</a>
--   t</tt> for some data type <tt>t</tt> whose fields you want to extract.
--   <tt>r</tt> is the result type you want back from the extraction.
--   <tt>f</tt> should be defined such that there is an instance of
--   <tt><a>Extractor</a> f a r THasOne</tt> for each type <tt>a</tt> you
--   want to convert to <tt>r</tt> and extract.
class GGetField f rep r g | f rep r -> g
gGetFieldVal :: GGetField f rep r g => f r -> rep p -> g r
gGetFieldPos :: GGetField f rep r g => f r -> rep p -> (Int, [Int])
instance [overlap ok] [safe] Show a => Show (THasOne a)
instance [overlap ok] [safe] Show (THasNone a)
instance [overlap ok] [safe] Show a => Show (THasMany a)
instance [overlap ok] [safe] Show (ExtractId r)
instance [overlap ok] [safe] Extractor ExtractMaybe (Maybe a) (Maybe a) THasOne
instance [overlap ok] [safe] Extractor ExtractMaybe a (Maybe a) THasOne
instance [overlap ok] [safe] Extractor ExtractId a a THasOne
instance [overlap ok] [safe] (Generic a, GGetField f (Rep a) r THasOne) => GetField f a r
instance [overlap ok] [safe] GGetField f a r g => GGetField f (M1 i c a) r g
instance [overlap ok] [safe] (GGetField f a1 r g1, GGetField f a2 r g2, GCombine g1 g2 g) => GGetField f (a1 :*: a2) r g
instance [overlap ok] [safe] Extractor f c r g => GGetField f (K1 i c) r g
instance [overlap ok] [safe] TypeGCast THasNone g => Extractor f a r g
instance [overlap ok] [safe] GCount THasNone
instance [overlap ok] [safe] GCount THasMany
instance [overlap ok] [safe] GCount THasOne
instance [overlap ok] [safe] GCombine THasMany THasOne THasMany
instance [overlap ok] [safe] GCombine THasOne THasMany THasMany
instance [overlap ok] [safe] GCombine THasMany THasNone THasMany
instance [overlap ok] [safe] GCombine THasNone THasMany THasMany
instance [overlap ok] [safe] GCombine THasMany THasMany THasMany
instance [overlap ok] [safe] GCombine THasOne THasOne THasMany
instance [overlap ok] [safe] GCombine THasNone THasNone THasNone
instance [overlap ok] [safe] GCombine THasNone THasOne THasOne
instance [overlap ok] [safe] GCombine THasOne THasNone THasOne
instance [overlap ok] [safe] TypeGCast f f

module Database.PostgreSQL.ORM.Association

-- | A data structure representing a relationship between a model
--   <tt>a</tt> and a model <tt>b</tt>. At a high level, an <tt>Association
--   a b</tt> tells you how to find rows of type <tt>b</tt> given rows of
--   type <tt>a</tt>. More concretely, this boils down to being able to
--   make two types of query.
--   
--   <ul>
--   <li>You want to look up a bunch of <tt>(a <a>:.</a> b)</tt>s,
--   filtering using predicates on both <tt>a</tt> and <tt>b</tt> (e.g.,
--   get a list of recent posts and their authors). For this purpose, you
--   can use <a>assocSelect</a>, which allows you to <a>addWhere</a>
--   predicates mentioning columns in both <tt>a</tt> and <tt>b</tt>.</li>
--   <li>You already have an instance of type <tt>a</tt>, and want to find
--   all the <tt>b</tt>s associated with it. For that you use either
--   <a>assocWhere</a> or <a>findAssoc</a> (which internally access fields
--   <a>assocSelectOnlyB</a>, <a>assocWhereQuery</a>, and
--   <a>assocWhereParam</a>). This type of query is strictly less general
--   than the first one, but can be formulated in a more efficient way by
--   extracting values directly from a concrete instance of <tt>a</tt>
--   without needing to touch table <tt>a</tt> in the database.</li>
--   </ul>
--   
--   Note that an <tt>Association</tt> is asymmetric. It tells you how to
--   get <tt>b</tt>s from <tt>a</tt>s, but not vice versa. In practice,
--   there will almost always be an association in the other direction,
--   too. Functions such as <a>dbrefAssocs</a> and <a>jtAssocs</a>
--   therefore create an <tt>Association</tt> and its inverse
--   simultaneously, returning them as a pair.
data Association a b
Association :: !(DBSelect (a :. b)) -> !(DBSelect b) -> !Query -> !(a -> [Action]) -> Association a b

-- | General select returning all instances of <tt>a</tt> and <tt>b</tt>
--   that match according to the association.
assocSelect :: Association a b -> !(DBSelect (a :. b))

-- | The right-hand side of the <a>assocSelect</a> query. This query makes
--   no mention of type <tt>a</tt> (but can be combined with the next two
--   fields to form an optimized query). You probably never want to use
--   this directly, and should instead use either <a>findAssoc</a> or
--   <a>assocWhere</a>. Also note this is not useful for selecting all the
--   <tt>b</tt>s in the relation; for that you should use
--   <a>assocProject</a>.
assocSelectOnlyB :: Association a b -> !(DBSelect b)

-- | A <tt>WHERE</tt> clause to find all the <tt>b</tt>s associated with a
--   particular <tt>a</tt>. This can often be done more efficiently than
--   through <a>assocSelect</a>. The clause contains <tt>'?'</tt>
--   characters which should be filled in by <a>assocWhereParam</a>.
assocWhereQuery :: Association a b -> !Query

-- | The query parameters for the query returned by <a>assocWhereQuery</a>.
assocWhereParam :: Association a b -> !(a -> [Action])

-- | A projection of <a>assocSelect</a>, extracting only the fields of
--   model <tt>b</tt>. Note that this query touches table <tt>a</tt> even
--   if it does not return results from <tt>a</tt>. Hence, you can use
--   <a>addWhere</a> to add predicates on both <tt>a</tt> and <tt>b</tt>.
--   (Note the contrast to <a>assocSelectOnlyB</a>, which does not touch
--   table <tt>a</tt> at all, and hence in the case of an <tt>INNER
--   JOIN</tt> might return rows of <tt>b</tt> that should not be part of
--   the association. <a>assocSelectOnlyB</a> is intended for use only in
--   conjunction with <a>assocWhereQuery</a>.)
assocProject :: Model b => Association a b -> DBSelect b

-- | Returns a <a>DBSelect</a> for all <tt>b</tt>s associated with a
--   particular <tt>a</tt>.
assocWhere :: Model b => Association a b -> a -> DBSelect b

-- | Follow an association to return all of the <tt>b</tt>s associated with
--   a particular <tt>a</tt>. The behavior is similar to:
--   
--   <pre>
--   findAssoc' ab c a = dbSelect c $ assocWhere ab a
--   </pre>
--   
--   But if the first argument is a static association, this function may
--   be marginally faster because it pre-renders most of the query.
findAssoc :: Model b => Association a b -> Connection -> a -> IO [b]

-- | A common type of association is when one model contains a <a>DBRef</a>
--   or <a>DBRefUnique</a> pointing to another model. In this case, the
--   model containing the <a>DBRef</a> is known as the <i>child</i>, and
--   the referenced model is known as the <i>parent</i>.
--   
--   Two pieces of information are required to describe a parent-child
--   relationship: First, the field selector that extracts the Haskell
--   <a>DBRef</a> from the haskell type <tt>child</tt>, and second the name
--   of the database column that stores this <a>DBRef</a> field.
--   
--   For example, consider the following:
--   
--   <pre>
--   data Author = Author {
--       authorId :: DBKey
--     } deriving (Show, Generic)
--   instance Model Author
--   
--   data Post = Post {
--       postId :: DBKey
--     , postAuthorId :: DBRef Author
--     } deriving (Show, Generic)
--   instance Model Post
--   
--   post_author_refinfo :: DBRefInfo Post Author
--   post_author_refinfo = DBRefInfo {
--       dbrefSelector = postAuthorId
--     , dbrefQColumn = "\"post\".\"postAuthorId\""
--     }
--   </pre>
--   
--   Note that the parent-child relationship described by a
--   <tt>GDBRefInfo</tt> is asymmetric, but bidirectional. When a
--   <tt><a>DBRefInfo</a> child parent</tt> exists, the schema should
--   generally <i>not</i> permit the existence of a valid
--   <tt><a>DBRefInfo</a> parent child</tt> structure. However, the
--   <a>dbrefAssocs</a> function generates <a>Association</a>s in both
--   directions from a single <a>DBRefInfo</a>.
--   
--   Constructing such parent-child <a>Association</a>s requires knowing
--   how to extract primary keys from the <tt>parent</tt> type as well as
--   the name of the column storing primary keys in <tt>parent</tt>.
--   Fortunately, this information is already available from the
--   <a>Model</a> class, and thus does not need to be in the
--   <tt>GDBRefInfo</tt>. (Most functions on <tt>GDBRefInfo</tt>s require
--   <tt>parent</tt> and <tt>child</tt> to be instances of <a>Model</a>.)
--   
--   When your <a>Model</a>s are instances of <tt>Generic</tt> (which will
--   usually be the case), a <a>DBRefInfo</a> structure can be computed
--   automatically by <a>defaultDBRefInfo</a>. This is the recommended way
--   to produce a <tt>GDBRefInfo</tt>. (Alternatively, see <a>has</a> and
--   <a>belongsTo</a> to make use of an entirely implicit
--   <tt>DBRefInfo</tt>.)
data GDBRefInfo reftype child parent
DBRefInfo :: !(child -> GDBRef reftype parent) -> !ByteString -> GDBRefInfo reftype child parent

-- | Field selector returning a reference.
dbrefSelector :: GDBRefInfo reftype child parent -> !(child -> GDBRef reftype parent)

-- | Literal SQL for the database column storing the reference. This should
--   be double-quoted and table-qualified, in case the column name is a
--   reserved keyword, contains capital letters, or conflicts with the name
--   of a column in the joined table. An example would be:
--   
--   <pre>
--   dbrefQColumn = "\"table_name\".\"column_name\""
--   </pre>
dbrefQColumn :: GDBRefInfo reftype child parent -> !ByteString

-- | <tt>DBRefInfo</tt> is a type alias for the common case that the
--   reference in a <a>GDBRefInfo</a> is a <a>DBRef</a> (as opposed to a
--   <a>DBRefUnique</a>). The functions in this library do not care what
--   type of reference is used. The type is generalized to
--   <a>GDBRefInfo</a> just to make it easier to assign a selector to
--   <a>dbrefSelector</a> when the selector returns a <a>DBRefUnique</a>.
--   Note, however, that <a>defaultDBRefInfo</a> returns a <a>DBRefInfo</a>
--   regardless of the flavor of reference actually encountered.
type DBRefInfo = GDBRefInfo NormalRef

-- | Creates a <a>DBRefInfo</a> from a model <tt>child</tt> that references
--   <tt>parent</tt>. For this to work, the <tt>child</tt> type must be an
--   instance of <tt>Generic</tt> and must contain exactly one field of the
--   any of the following types:
--   
--   <ol>
--   <li><tt><a>GDBRef</a> rt parent</tt>, which matches both
--   <tt><a>DBRef</a> parent</tt> and <tt><a>DBRefUnique</a>
--   parent</tt>.</li>
--   <li><tt>Maybe (<a>GDBRef</a> rt parent)</tt>, for cases where the
--   reference might be <tt>NULL</tt>. Note, however, that an exception
--   will be thrown if you call <a>findAssoc</a> on a child whose reference
--   is <a>Nothing</a>.</li>
--   </ol>
--   
--   A special case arises when a Model contains a <a>DBRef</a> to itself.
--   If you just wish to find parents and children given an existing
--   structure (i.e., <a>findAssoc</a>), it is okay to declare an
--   <tt><a>Association</a> MyType MyType</tt>. However, in this case
--   attempts to use <a>assocSelect</a> will then fail. To work around this
--   problem, the parent must use a row alias.
--   
--   Note that currently <i>aliasing the child will not work</i>, since the
--   <a>As</a> data structure will not contain a <a>DBRef</a> field, only
--   the contents of the <a>As</a> data structure. An example of doing this
--   correctly (using <a>has</a> and <a>belongsTo</a>, both of which wrap
--   <tt>defaultDBRefInfo</tt>):
--   
--   <pre>
--   data Bar = Bar {
--       barId :: !DBKey
--     , barName :: !String
--     , barParent :: !(Maybe (DBRef Bar))
--     } deriving (Show, Generic)
--   instance Model Bar where modelInfo = underscoreModelInfo "bar"
--   
--   data ParentBar = ParentBar
--   instance RowAlias ParentBar where rowAliasName _ = "parent_bar"
--   
--   toParent :: Association Bar (As ParentBar Bar)
--   toParent = belongsTo
--   
--   toChild :: Association (As ParentBar Bar) Bar
--   toChild = has
--   </pre>
defaultDBRefInfo :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => DBRefInfo child parent

-- | Generate both the child-parent and parent-child <a>Association</a>s
--   implied by a <a>GDBRefInfo</a>.
dbrefAssocs :: (Model child, Model parent) => GDBRefInfo rt child parent -> (Association child parent, Association parent child)

-- | Short for
--   
--   <pre>
--   snd $ dbrefAssocs defaultDBRefInfo
--   </pre>
--   
--   Note the inverse <a>Association</a> is given by <a>belongsTo</a>. For
--   example, given the <tt>Author</tt> and <tt>Post</tt> models described
--   in the documentation for <a>GDBRefInfo</a>, in which each
--   <tt>Post</tt> references an <tt>Author</tt>, you might say:
--   
--   <pre>
--   author_post :: Association Author Post
--   author_post = has
--   
--   post_author :: Association Post Author
--   post_author = belongsTo
--   </pre>
has :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => Association parent child

-- | The inverse of <a>has</a>. Short for
--   
--   <pre>
--   fst $ dbrefAssocs defaultDBRefInfo
--   </pre>
--   
--   See an example at <a>has</a>.
belongsTo :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => Association child parent

-- | A data structure representing a dedicated join table in the database.
--   A join table differs from a model in that rows do not have primary
--   keys. Hence, model operations do not apply. Nonetheless a join table
--   conveys information about a relationship between models.
--   
--   Note that all names in a <tt>JoinTable</tt> should be unquoted.
data JoinTable a b
JoinTable :: !ByteString -> !ByteString -> !ByteString -> JoinTable a b

-- | Name of the join table in the database. (Not quoted.)
jtTable :: JoinTable a b -> !ByteString

-- | Name of the column in table <a>jtTable</a> that contains a
--   <a>DBRef</a> to model <tt>a</tt>. (Not quoted or table-qualified.)
jtColumnA :: JoinTable a b -> !ByteString

-- | Like <a>jtColumnA</a> for model <tt>b</tt>.
jtColumnB :: JoinTable a b -> !ByteString

-- | The default join table has the following fields:
--   
--   <ul>
--   <li><tt>jtName</tt> is the name of the two models (in alphabetical
--   order), separated by an <tt>'_'</tt> character.</li>
--   <li><a>jtColumnA</a> is the name of model <tt>a</tt>, an <tt>'_'</tt>
--   character, and the name of the primary key column in table
--   <tt>a</tt>.</li>
--   <li><a>jtColumnB</a> is the name of model <tt>b</tt>, an <tt>'_'</tt>
--   character, and the name of the primary key column in table
--   <tt>b</tt>.</li>
--   </ul>
--   
--   Note that <a>defaultJoinTable</a> cannot create a default join table
--   for joining a model to itself, as following these rules the two
--   columns would have the same name. If you wish to join a table to
--   itself, you have two options: First, you can define the join table and
--   assign the column names manually. This will permit you to call
--   <a>findAssoc</a>, but you still will not be able to use
--   <a>assocSelect</a> for more complex queries, since SQL does not permit
--   joins between two tables with the same name. The second option is to
--   give one of the sides of the join table a row alias with <a>As</a>.
--   For example:
--   
--   <pre>
--   data ParentBar = ParentBar
--   instance RowAlias ParentBar where rowAliasName _ = "parent_bar"
--   
--   selfJoinTable :: JoinTable Bar (As ParentBar Bar)
--   selfJoinTable = defaultJoinTable
--   
--   selfJoin :: Association Bar (As ParentBar Bar)
--   otherSelfJoin :: Association (As ParentBar Bar) Bar
--   (selfJoin, otherSelfJoin) = jtAssocs selfJoinTable
--   </pre>
defaultJoinTable :: (Model a, Model b) => JoinTable a b

-- | Generate the two associations implied by a <a>JoinTable</a>.
jtAssocs :: (Model a, Model b) => JoinTable a b -> (Association a b, Association b a)

-- | Generate a one-way association based on the default join table naming
--   scheme described at <a>defaultJoinTable</a>. Defined as:
--   
--   <pre>
--   joinTable = jtAssoc defaultJoinTable
--   </pre>
--   
--   For example:
--   
--   <pre>
--   aToB :: Association A B
--   aToB = joinTable
--   
--   bToA :: Association B A
--   bToA = joinTable
--   </pre>
joinTable :: (Model a, Model b) => Association a b

-- | Add an association between two models to a join table. Returns
--   <a>True</a> if the association was not already there.
jtAdd :: (Model a, Model b) => JoinTable a b -> Connection -> a -> b -> IO Bool

-- | Remove an association from a join table. Returns <a>True</a> if the
--   association was previously there.
jtRemove :: (Model a, Model b) => JoinTable a b -> Connection -> a -> b -> IO Bool

-- | Remove an assocation from a join table when you don't have the target
--   instances of the two models handy, but do have references.
jtRemoveByRef :: (Model a, Model b) => JoinTable a b -> Connection -> GDBRef rt a -> GDBRef rt b -> IO Bool

-- | A SQL statement suitable for adding a pair to a join table. Note that
--   the statement takes two parameters (i.e., contains two <tt>'?'</tt>
--   characters) corresponding to the primary keys of the two models being
--   associated. These parameters can be supplied by <a>jtParam</a>.
jtAddStatement :: JoinTable a b -> Query

-- | A SQL statement for removing a pair from a join table. Like
--   <a>jtAddStatement</a>, the query is parameterized by two primary keys.
jtRemoveStatement :: JoinTable a b -> Query

-- | Generate parameters for <a>jtAddStatement</a> and
--   <a>jtRemoveStatement</a>. The returned list is suitable for use as a
--   <a>ToRow</a> instance. For example:
--   
--   <pre>
--   execute conn (jtAddStatement my_join_table) (jtParam a b)
--   </pre>
jtParam :: (Model a, Model b) => JoinTable a b -> a -> b -> [Action]

-- | Flip a join table. This doesn't change the name of the table (since
--   the same join table is used in both directions, and the default join
--   table name glues together the two model names in alphabetical order
--   anyway).
jtFlip :: JoinTable a b -> JoinTable b a

-- | Generate a one-way association from a <a>JoinTable</a>. Use
--   <a>jtAssocs</a> instead.
jtAssoc :: (Model a, Model b) => JoinTable a b -> Association a b

-- | Combine two associations into one.
nestAssoc :: (Model a, Model b) => Association a b -> Association b c -> Association a (b :. c)

-- | Combine two associations into one, and project away the middle type.
--   (The middle type can still be mentioned in <tt>WHERE</tt> clauses.)
--   
--   An example:
--   
--   <pre>
--   data Author = Author {
--       authorId :: DBKey
--     } deriving (Show, Generic)
--   instance Model Author where modelInfo = underscoreModelInfo "author"
--   
--   data Post = Post {
--       postId :: DBKey
--     , postAuthorId :: DBRef Author
--     } deriving (Show, Generic)
--   instance Model Post where modelInfo = underscoreModelInfo "post"
--   
--   data Comment = Comment {
--       commentId :: DBKey
--     , commentPostId :: DBRef Post
--     } deriving (Show, Generic)
--   instance Model Comment where modelInfo = underscoreModelInfo "comment"
--   
--   author_posts :: Association Author Post
--   post_author :: Association Post Author
--   (post_author, author_posts) = dbrefAssocs defaultDBRefInfo
--   
--   -- Could equally well use dbrefAssocs as above
--   post_comments :: Association Post Comment
--   post_comments = has
--   
--   comment_post :: Association Comment Post
--   comment_post = belongsTo
--   
--   comment_author :: Association Comment Author
--   comment_author = chainAssoc comment_post post_author
--   
--   author_comments :: Association Author Comment
--   author_comments =  chainAssoc author_posts post_comments
--   </pre>
chainAssoc :: (Model a, Model b, Model c) => Association a b -> Association b c -> Association a c
instance Show (ExtractRef a)
instance Show (JoinTable a b)
instance Extractor ExtractRef (Maybe (GDBRef rt a)) (DBRef (As alias a)) THasOne
instance Extractor ExtractRef (Maybe (GDBRef rt a)) (DBRef a) THasOne
instance Extractor ExtractRef (GDBRef rt a) (DBRef (As alias a)) THasOne
instance Extractor ExtractRef (GDBRef rt a) (DBRef a) THasOne
instance Show (GDBRefInfo rt c p)
instance Show (Association a b)

module Database.PostgreSQL.ORM

-- | The class of data types that represent a database table. This class
--   conveys information necessary to move a Haskell data structure in and
--   out of a database table. The most important field is <a>modelInfo</a>,
--   which describes the database table and column names. <a>modelInfo</a>
--   has a reasonable default implementation for types that are members of
--   the <a>Generic</a> class (using GHC's <tt>DeriveGeneric</tt>
--   extension), provided the following conditions hold:
--   
--   <ol>
--   <li>The data type must have a single constructor that is defined using
--   record selector syntax.</li>
--   <li>The very first field of the data type must be a <a>DBKey</a> to
--   represent the primary key. Other orders will cause a compilation
--   error.</li>
--   <li>Every field of the data structure must be an instance of
--   <a>FromField</a> and <a>ToField</a>.</li>
--   </ol>
--   
--   If these three conditions hold and your database naming scheme follows
--   the conventions of <a>defaultModelInfo</a>--namely that the table name
--   is the same as the type name with the first character downcased, and
--   the field names are the same as the column names--then it is
--   reasonable to have a completely empty (default) instance declaration:
--   
--   <pre>
--   data MyType = MyType { myKey :: !DBKey
--                        , myName :: !S.ByteString
--                        , myCamelCase :: !Int
--                        , ...
--                        } deriving (Show, Generic)
--   instance Model MyType
--   </pre>
--   
--   The default <a>modelInfo</a> method is called <a>defaultModelInfo</a>.
--   You may wish to use almost all of the defaults, but tweak a few
--   things. This is easily accomplished by overriding a few fields of the
--   default structure. For example, suppose your database columns use
--   exactly the same name as your Haskell field names, but the name of
--   your database table is not the same as the name of the Haskell data
--   type. You can override the database table name (field
--   <a>modelTable</a>) as follows:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = defaultModelInfo { modelTable = "my_type" }
--   </pre>
--   
--   Finally, if you dislike the conventions followed by
--   <a>defaultModelInfo</a>, you can simply implement an alternate
--   pattern. An example of this is <a>underscoreModelInfo</a>, which
--   strips a prefix off every field name and converts everything from
--   camel-case to underscore notation:
--   
--   <pre>
--   instance Model MyType where
--       modelInfo = underscoreModelInfo "my"
--   </pre>
--   
--   The above code will associate <tt>MyType</tt> with a database table
--   <tt>my_type</tt> having column names <tt>key</tt>, <tt>name</tt>,
--   <tt>camel_case</tt>, etc.
--   
--   You can implement other patterns like <a>underscoreModelInfo</a> by
--   calling <a>defaultModelInfo</a> and modifying the results.
--   Alternatively, you can directly call the lower-level functions from
--   which <a>defaultModelInfo</a> is built (<a>defaultModelTable</a>,
--   <a>defaultModelColumns</a>, <a>defaultModelGetPrimaryKey</a>).
class Model a where modelInfo = defaultModelInfo modelIdentifiers = defaultModelIdentifiers modelInfo modelRead = defaultFromRow modelWrite = defaultModelWrite modelQueries = defaultModelQueries modelIdentifiers modelCreateInfo = emptyModelCreateInfo modelValid = const mempty
modelInfo :: Model a => ModelInfo a
modelValid :: Model a => a -> ValidationError

-- | A <tt>ModelInfo T</tt> contains the information necessary for mapping
--   <tt>T</tt> to a database table. Each <tt><a>Model</a></tt> type has a
--   single <tt>ModelInfo</tt> associated with it, accessible through the
--   <a>modelInfo</a> method of the <a>Model</a> class. Note the table and
--   column names must all be unquoted in this data structure, as they will
--   later be quoted using <a>quoteIdent</a> by the <a>modelIdentifiers</a>
--   method.
data ModelInfo a
ModelInfo :: !ByteString -> ![ByteString] -> !Int -> !(a -> DBKey) -> ModelInfo a

-- | The name of the database table corresponding to this model. The
--   default <a>modelInfo</a> instance uses <a>defaultModelTable</a>, which
--   is the name of your data type with the first letter downcased.
modelTable :: ModelInfo a -> !ByteString

-- | The names of the database columns corresponding to fields of this
--   model. The column names should appear in the order in which the fields
--   are defined in the Haskell data type <tt>a</tt> (which should also be
--   the order in which <a>modelRead</a> parses them to an <tt>a</tt> and
--   <a>modelWrite</a> marshalls them).
--   
--   Note that all queries generated by the library specify explicit column
--   names. Hence the order of columns does not need to match their order
--   in the database table. They should instead match the order of fields
--   in the Haskell data structure.
--   
--   The default, given by <a>defaultModelColumns</a>, is to use the
--   Haskell field names for <tt>a</tt>. This default will fail to compile
--   if <tt>a</tt> is not defined using record syntax.
modelColumns :: ModelInfo a -> ![ByteString]

-- | The 0-based index of the primary key column in <a>modelColumns</a>.
--   This should be 0 when your data structure's first field is its
--   <a>DBKey</a> (highly recommended, and required by
--   <a>defaultModelGetPrimaryKey</a>). If you customize this field, you
--   must also customize <a>modelGetPrimaryKey</a>--no check is made that
--   the two are consistent.
modelPrimaryColumn :: ModelInfo a -> !Int

-- | Return the primary key of a particular model instance. If you
--   customize this field, you must also customize
--   <a>modelPrimaryColumn</a>--no check is made that the two are
--   consistent.
modelGetPrimaryKey :: ModelInfo a -> !(a -> DBKey)

-- | The default definition of <a>modelInfo</a>. See the documentation at
--   <a>Model</a> for more information. Sets <a>modelTable</a> to the name
--   of the type with the first character converted to lower-case. Sets
--   <a>modelColumns</a> to the names of the Haskell field selectors. Sets
--   <a>modelPrimaryColumn</a> to <tt>0</tt> and extracts the first field
--   of the structure for <a>modelGetPrimaryKey</a>. Will fail to compile
--   unless the data structure is defined with record syntax and that its
--   first field is of type <a>DBKey</a>.
--   
--   Note that defaults for the individual fields are available in separate
--   functions (e.g., <a>defaultModelTable</a>) with fewer class
--   requirements in the context, in case you want to make piecemeal use of
--   defaults. The default for <a>modelPrimaryColumn</a> is 0. If you
--   overwrite that, you will need to overwrite <a>modelGetPrimaryKey</a>
--   as well (and likely vice versa).
defaultModelInfo :: (Generic a, GDatatypeName (Rep a), GColumns (Rep a), GPrimaryKey0 (Rep a)) => ModelInfo a

-- | An alternate <a>Model</a> pattern in which Haskell type and field
--   names are converted from camel-case to underscore notation. The first
--   argument is a prefix to be removed from field names (since Haskell
--   requires field names to be unique across data types, while SQL allows
--   the same column names to be used in different tables).
--   
--   For example:
--   
--   <pre>
--   data Bar = Bar {
--       barId :: !DBKey
--     , barNameOfBar :: !String
--     , barParent :: !(Maybe (DBRef Bar))
--     } deriving (Show, Generic)
--   
--   instance Model Bar where modelInfo = underscoreModelInfo "bar"
--   </pre>
--   
--   would associate type <tt>Bar</tt> with a database table called
--   <tt>bar</tt> with fields <tt>id</tt>, <tt>name_of_bar</tt>, and
--   <tt>parent</tt>.
underscoreModelInfo :: (Generic a, GToRow (Rep a), GFromRow (Rep a), GPrimaryKey0 (Rep a), GColumns (Rep a), GDatatypeName (Rep a)) => ByteString -> ModelInfo a

-- | The type of the Haskell data structure field containing a model's
--   primary key.
--   
--   Every <a>Model</a> must have exactly one <tt>DBKey</tt>, and the
--   <tt>DBKey</tt> must be the <a>Model</a>'s very first field in the
--   Haskel data type definition. (The ordering is enforced by
--   <a>defaultModelGetPrimaryKey</a>, which, through use of the
--   <tt>DeriveGeneric</tt> extension, fails to compile when the first
--   field is not a <tt>DBKey</tt>.)
--   
--   Each <a>Model</a> stored in the database should have a unique non-null
--   primary key. However, the key is determined at the time the
--   <a>Model</a> is inserted into the database. While you are constructing
--   a new <a>Model</a> to insert, you will not have its key. Hence, you
--   should use the value <tt>NullKey</tt> to let the database chose the
--   key.
--   
--   If you wish to store a <a>Model</a>'s primary key as a reference in
--   another <a>Model</a>, do not copy the <a>DBKey</a> structure. Use
--   <a>mkDBRef</a> to convert the <a>Model</a>'s primary key to a foreign
--   key reference.
data DBKey
DBKey :: !DBKeyType -> DBKey
NullKey :: DBKey

-- | A <tt>DBRef T</tt> represents a many-to-one relationship between
--   tables. For example, if type <tt>A</tt> contains a <tt>DBRef B</tt>,
--   then each <tt>B</tt> is associated with many <tt>A</tt>'s. By
--   contrast, a <tt><a>DBRefUnique</a></tt> represents a one-to-one
--   relationship.
--   
--   <tt>DBRef</tt> is a type alias of kind <tt>* -&gt; *</tt>. The type
--   <tt>DBRef T</tt> references an instance of type <tt>T</tt> by the
--   primary key of its database row. The type argument <tt>T</tt> should
--   be an instance of <a>Model</a>.
type DBRef = GDBRef NormalRef

-- | A <tt>DBRefUnique T</tt> represents a one-to-one relationship between
--   types. For example, if type <tt>A</tt> contains a <tt>DBRefUnique
--   B</tt>, then each <tt>A</tt> is associated with one (or at most one)
--   <tt>B</tt>, and each <tt>B</tt> has one (or at most one) <tt>A</tt>
--   associated with it.
--   
--   By contrast, a <tt><a>DBRef</a></tt> represents a many-to-one
--   relationship.
type DBRefUnique = GDBRef UniqueRef

-- | Create a reference to the primary key of a <a>Model</a>, suitable for
--   storing in a <a>DBRef</a> or <a>DBRefUnique</a> field of a different
--   <a>Model</a>.
mkDBRef :: Model a => a -> GDBRef rt a

-- | Lookup the primary key of a <a>Model</a>.
primaryKey :: Model a => a -> DBKey

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data (:.) h t :: * -> * -> *

-- | The newtype <tt>As</tt> can be wrapped around an existing type to give
--   it a table name alias in a query. This is necessary when a model is
--   being joined with itself, to distinguish the two joined instances of
--   the same table.
--   
--   For example:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data X = X instance <a>RowAlias</a> X where rowAliasName = const "x"
--   
--   ... r &lt;- <tt>dbSelect</tt> c $ addWhere_ "bar.bar_key =
--   x.bar_parent" modelDBSelect :: IO [Bar :. As X Bar] @
newtype As alias row
As :: row -> As alias row
unAs :: As alias row -> row

-- | The class of types that can be used as tags in as <a>As</a> alias.
--   Such types should be unit types--in other words, have exactly one
--   constructor where the constructor is nullary (take no arguments). The
--   reason for this class is that the <a>Model</a> instance for <a>As</a>
--   requires a way to extract the name of the row alias without having a
--   concrete instance of the type. This is provided by the
--   <a>rowAliasName</a> method (which must be non-strict).
class RowAlias a where rowAliasName _ = fromString $ caseFold $ gUnitTypeName . from $ a where caseFold (h : t) = toLower h : t caseFold [] = [] a = undefined :: a
rowAliasName :: RowAlias a => g a row -> ByteString

-- | <tt>fromAs</tt> extracts the <tt>row</tt> from an <tt><a>As</a> alias
--   row</tt>, but constrains the type of <tt>alias</tt> to be the same as
--   its first argument (which is non-strict). This can save you from
--   explicitly specifying types. For example:
--   
--   <pre>
--   data X = X deriving (Generic)
--   instance RowAlias X where rowAliasName = const "x"
--   
--   ...
--     r &lt;- map (\(b1 :. b2) -&gt; (b1, fromAs X b2)) &lt;$&gt;
--         dbSelect c $ addWhere \"bar.bar_key = x.bar_parent\" modelDBSelect
--   </pre>
fromAs :: alias -> As alias row -> row

-- | Follow a <a>DBRef</a> or <a>DBRefUnique</a> and fetch the target row
--   from the database into a <a>Model</a> type <tt>r</tt>.
findRow :: Model r => Connection -> GDBRef rt r -> IO (Maybe r)

-- | Dump an entire model. Useful for development and debugging only, as
--   every row will be read into memory before the function returns.
--   
--   Note that unlike the other primary model operations, it is OK to call
--   <a>findAll</a> even on degenerate models such as <a>As</a> and
--   <a>:.</a>.
findAll :: Model r => Connection -> IO [r]

-- | Like <a>trySave</a> but instead of returning an <a>Either</a>, throws
--   a <a>ValidationError</a> if the <a>Model</a> is invalid.
save :: Model r => Connection -> r -> IO r

-- | Write a <a>Model</a> to the database. If the primary key is
--   <a>NullKey</a>, the item is written with an <tt>INSERT</tt> query,
--   read back from the database, and returned with its primary key filled
--   in. If the primary key is not <a>NullKey</a>, then the <a>Model</a> is
--   written with an <tt>UPDATE</tt> query and returned as-is.
--   
--   If the <a>Model</a> is invalid (i.e. the return value of
--   <a>modelValid</a> is non-empty), a list of <tt>InvalidError</tt> is
--   returned instead.
trySave :: Model r => Connection -> r -> IO (Either ValidationError r)

-- | Remove the row corresponding to a particular data structure from the
--   database. This function only looks at the primary key in the data
--   structure. It is an error to call this function if the primary key is
--   not set.
destroy :: Model a => Connection -> a -> IO ()

-- | Remove a row from the database without fetching it first.
destroyByRef :: Model a => Connection -> GDBRef rt a -> IO ()

-- | A deconstructed SQL select statement that allows easier manipulation
--   of individual terms. Several functions are provided to combine the
--   <a>selFields</a>, <a>selFrom</a>, and <a>selWhere</a> clauses of
--   muliple <tt>DBSelect</tt> structures. Other clauses may be discarded
--   when combining queries with join operations. Hence it is advisable to
--   set the other clauses at the end (or, if you set these fields, to
--   collapse your <a>DBSelect</a> structure into a subquery using
--   <a>dbProject'</a>).
data DBSelect a
DBSelect :: !Query -> !Query -> Query -> !FromClause -> !Query -> !Query -> !Query -> !Query -> !Query -> !Query -> !Query -> DBSelect a
selWith :: DBSelect a -> !Query

-- | By default <tt>"SELECT"</tt>, but might usefully be set to something
--   else such as <tt>"SELECT DISTINCT"</tt> in some situations.
selSelectKeyword :: DBSelect a -> !Query
selFields :: DBSelect a -> Query
selFrom :: DBSelect a -> !FromClause

-- | Empty by default, but set to <tt>"WHERE"</tt> if any <tt>WHERE</tt>
--   clauses are added to the <a>selWhere</a> field.
selWhereKeyword :: DBSelect a -> !Query
selWhere :: DBSelect a -> !Query
selGroupBy :: DBSelect a -> !Query
selHaving :: DBSelect a -> !Query
selOrderBy :: DBSelect a -> !Query
selLimit :: DBSelect a -> !Query
selOffset :: DBSelect a -> !Query

-- | A <a>DBSelect</a> that returns all rows of a model.
modelDBSelect :: Model a => DBSelect a

-- | Run a <a>DBSelect</a> query on parameters. The number of <tt>'?'</tt>
--   characters embedeed in various fields of the <a>DBSelect</a> must
--   exactly match the number of fields in parameter type <tt>p</tt>. Note
--   the order of arguments is such that the <a>DBSelect</a> can be
--   pre-rendered and the parameters supplied later. Hence, you should use
--   this version when the <a>DBSelect</a> is static. For dynamically
--   modified <a>DBSelect</a> structures, you may prefer <a>dbSelect</a>.
dbSelectParams :: (Model a, ToRow p) => DBSelect a -> Connection -> p -> IO [a]

-- | Run a <a>DBSelect</a> query and return the resulting models.
dbSelect :: Model a => Connection -> DBSelect a -> IO [a]

-- | Add a where clause verbatim to a <a>DBSelect</a>. The clause must
--   <i>not</i> contain the <tt>WHERE</tt> keyword (which is added
--   automatically by <tt>addWhere_</tt> if needed). If the
--   <tt>DBSelect</tt> has existing <tt>WHERE</tt> clauses, the new clause
--   is appended with <tt>AND</tt>. If the query contains any <tt>'?'</tt>
--   characters, they will be rendered into the query and matching
--   parameters will later have to be filled in via a call to
--   <a>dbSelectParams</a>.
addWhere_ :: Query -> DBSelect a -> DBSelect a

-- | Add a where clause, and pre-render parameters directly into the
--   clause. The argument <tt>p</tt> must have exactly as many fields as
--   there are <tt>'?'</tt> characters in the <a>Query</a>. Example:
--   
--   <pre>
--   bars &lt;- dbSelect c $ addWhere "bar_id = ?" (Only target_id) $
--                        (modelDBSelect :: DBSelect Bar)
--   </pre>
addWhere :: ToRow p => Query -> p -> DBSelect a -> DBSelect a

-- | Set the <tt>ORDER BY</tt> clause of a <a>DBSelect</a>. Example:
--   
--   <pre>
--   dbSelect c $ setOrderBy "\"employeeName\" DESC NULLS FIRST" $
--                  modelDBSelect
--   </pre>
setOrderBy :: Query -> DBSelect a -> DBSelect a

-- | Set the <tt>LIMIT</tt> clause of a <a>DBSelect</a>.
setLimit :: Int -> DBSelect a -> DBSelect a

-- | Set the <tt>OFFSET</tt> clause of a <a>DBSelect</a>.
setOffset :: Int -> DBSelect a -> DBSelect a

-- | A data structure representing a relationship between a model
--   <tt>a</tt> and a model <tt>b</tt>. At a high level, an <tt>Association
--   a b</tt> tells you how to find rows of type <tt>b</tt> given rows of
--   type <tt>a</tt>. More concretely, this boils down to being able to
--   make two types of query.
--   
--   <ul>
--   <li>You want to look up a bunch of <tt>(a <a>:.</a> b)</tt>s,
--   filtering using predicates on both <tt>a</tt> and <tt>b</tt> (e.g.,
--   get a list of recent posts and their authors). For this purpose, you
--   can use <a>assocSelect</a>, which allows you to <a>addWhere</a>
--   predicates mentioning columns in both <tt>a</tt> and <tt>b</tt>.</li>
--   <li>You already have an instance of type <tt>a</tt>, and want to find
--   all the <tt>b</tt>s associated with it. For that you use either
--   <a>assocWhere</a> or <a>findAssoc</a> (which internally access fields
--   <a>assocSelectOnlyB</a>, <a>assocWhereQuery</a>, and
--   <a>assocWhereParam</a>). This type of query is strictly less general
--   than the first one, but can be formulated in a more efficient way by
--   extracting values directly from a concrete instance of <tt>a</tt>
--   without needing to touch table <tt>a</tt> in the database.</li>
--   </ul>
--   
--   Note that an <tt>Association</tt> is asymmetric. It tells you how to
--   get <tt>b</tt>s from <tt>a</tt>s, but not vice versa. In practice,
--   there will almost always be an association in the other direction,
--   too. Functions such as <a>dbrefAssocs</a> and <a>jtAssocs</a>
--   therefore create an <tt>Association</tt> and its inverse
--   simultaneously, returning them as a pair.
data Association a b

-- | General select returning all instances of <tt>a</tt> and <tt>b</tt>
--   that match according to the association.
assocSelect :: Association a b -> (DBSelect (a :. b))

-- | A projection of <a>assocSelect</a>, extracting only the fields of
--   model <tt>b</tt>. Note that this query touches table <tt>a</tt> even
--   if it does not return results from <tt>a</tt>. Hence, you can use
--   <a>addWhere</a> to add predicates on both <tt>a</tt> and <tt>b</tt>.
--   (Note the contrast to <a>assocSelectOnlyB</a>, which does not touch
--   table <tt>a</tt> at all, and hence in the case of an <tt>INNER
--   JOIN</tt> might return rows of <tt>b</tt> that should not be part of
--   the association. <a>assocSelectOnlyB</a> is intended for use only in
--   conjunction with <a>assocWhereQuery</a>.)
assocProject :: Model b => Association a b -> DBSelect b

-- | Returns a <a>DBSelect</a> for all <tt>b</tt>s associated with a
--   particular <tt>a</tt>.
assocWhere :: Model b => Association a b -> a -> DBSelect b

-- | Follow an association to return all of the <tt>b</tt>s associated with
--   a particular <tt>a</tt>. The behavior is similar to:
--   
--   <pre>
--   findAssoc' ab c a = dbSelect c $ assocWhere ab a
--   </pre>
--   
--   But if the first argument is a static association, this function may
--   be marginally faster because it pre-renders most of the query.
findAssoc :: Model b => Association a b -> Connection -> a -> IO [b]

-- | A common type of association is when one model contains a <a>DBRef</a>
--   or <a>DBRefUnique</a> pointing to another model. In this case, the
--   model containing the <a>DBRef</a> is known as the <i>child</i>, and
--   the referenced model is known as the <i>parent</i>.
--   
--   Two pieces of information are required to describe a parent-child
--   relationship: First, the field selector that extracts the Haskell
--   <a>DBRef</a> from the haskell type <tt>child</tt>, and second the name
--   of the database column that stores this <a>DBRef</a> field.
--   
--   For example, consider the following:
--   
--   <pre>
--   data Author = Author {
--       authorId :: DBKey
--     } deriving (Show, Generic)
--   instance Model Author
--   
--   data Post = Post {
--       postId :: DBKey
--     , postAuthorId :: DBRef Author
--     } deriving (Show, Generic)
--   instance Model Post
--   
--   post_author_refinfo :: DBRefInfo Post Author
--   post_author_refinfo = DBRefInfo {
--       dbrefSelector = postAuthorId
--     , dbrefQColumn = "\"post\".\"postAuthorId\""
--     }
--   </pre>
--   
--   Note that the parent-child relationship described by a
--   <tt>GDBRefInfo</tt> is asymmetric, but bidirectional. When a
--   <tt><a>DBRefInfo</a> child parent</tt> exists, the schema should
--   generally <i>not</i> permit the existence of a valid
--   <tt><a>DBRefInfo</a> parent child</tt> structure. However, the
--   <a>dbrefAssocs</a> function generates <a>Association</a>s in both
--   directions from a single <a>DBRefInfo</a>.
--   
--   Constructing such parent-child <a>Association</a>s requires knowing
--   how to extract primary keys from the <tt>parent</tt> type as well as
--   the name of the column storing primary keys in <tt>parent</tt>.
--   Fortunately, this information is already available from the
--   <a>Model</a> class, and thus does not need to be in the
--   <tt>GDBRefInfo</tt>. (Most functions on <tt>GDBRefInfo</tt>s require
--   <tt>parent</tt> and <tt>child</tt> to be instances of <a>Model</a>.)
--   
--   When your <a>Model</a>s are instances of <tt>Generic</tt> (which will
--   usually be the case), a <a>DBRefInfo</a> structure can be computed
--   automatically by <a>defaultDBRefInfo</a>. This is the recommended way
--   to produce a <tt>GDBRefInfo</tt>. (Alternatively, see <a>has</a> and
--   <a>belongsTo</a> to make use of an entirely implicit
--   <tt>DBRefInfo</tt>.)
data GDBRefInfo reftype child parent
DBRefInfo :: !(child -> GDBRef reftype parent) -> !ByteString -> GDBRefInfo reftype child parent

-- | Field selector returning a reference.
dbrefSelector :: GDBRefInfo reftype child parent -> !(child -> GDBRef reftype parent)

-- | Literal SQL for the database column storing the reference. This should
--   be double-quoted and table-qualified, in case the column name is a
--   reserved keyword, contains capital letters, or conflicts with the name
--   of a column in the joined table. An example would be:
--   
--   <pre>
--   dbrefQColumn = "\"table_name\".\"column_name\""
--   </pre>
dbrefQColumn :: GDBRefInfo reftype child parent -> !ByteString

-- | <tt>DBRefInfo</tt> is a type alias for the common case that the
--   reference in a <a>GDBRefInfo</a> is a <a>DBRef</a> (as opposed to a
--   <a>DBRefUnique</a>). The functions in this library do not care what
--   type of reference is used. The type is generalized to
--   <a>GDBRefInfo</a> just to make it easier to assign a selector to
--   <a>dbrefSelector</a> when the selector returns a <a>DBRefUnique</a>.
--   Note, however, that <a>defaultDBRefInfo</a> returns a <a>DBRefInfo</a>
--   regardless of the flavor of reference actually encountered.
type DBRefInfo = GDBRefInfo NormalRef

-- | Creates a <a>DBRefInfo</a> from a model <tt>child</tt> that references
--   <tt>parent</tt>. For this to work, the <tt>child</tt> type must be an
--   instance of <tt>Generic</tt> and must contain exactly one field of the
--   any of the following types:
--   
--   <ol>
--   <li><tt><a>GDBRef</a> rt parent</tt>, which matches both
--   <tt><a>DBRef</a> parent</tt> and <tt><a>DBRefUnique</a>
--   parent</tt>.</li>
--   <li><tt>Maybe (<a>GDBRef</a> rt parent)</tt>, for cases where the
--   reference might be <tt>NULL</tt>. Note, however, that an exception
--   will be thrown if you call <a>findAssoc</a> on a child whose reference
--   is <a>Nothing</a>.</li>
--   </ol>
--   
--   A special case arises when a Model contains a <a>DBRef</a> to itself.
--   If you just wish to find parents and children given an existing
--   structure (i.e., <a>findAssoc</a>), it is okay to declare an
--   <tt><a>Association</a> MyType MyType</tt>. However, in this case
--   attempts to use <a>assocSelect</a> will then fail. To work around this
--   problem, the parent must use a row alias.
--   
--   Note that currently <i>aliasing the child will not work</i>, since the
--   <a>As</a> data structure will not contain a <a>DBRef</a> field, only
--   the contents of the <a>As</a> data structure. An example of doing this
--   correctly (using <a>has</a> and <a>belongsTo</a>, both of which wrap
--   <tt>defaultDBRefInfo</tt>):
--   
--   <pre>
--   data Bar = Bar {
--       barId :: !DBKey
--     , barName :: !String
--     , barParent :: !(Maybe (DBRef Bar))
--     } deriving (Show, Generic)
--   instance Model Bar where modelInfo = underscoreModelInfo "bar"
--   
--   data ParentBar = ParentBar
--   instance RowAlias ParentBar where rowAliasName _ = "parent_bar"
--   
--   toParent :: Association Bar (As ParentBar Bar)
--   toParent = belongsTo
--   
--   toChild :: Association (As ParentBar Bar) Bar
--   toChild = has
--   </pre>
defaultDBRefInfo :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => DBRefInfo child parent

-- | Generate both the child-parent and parent-child <a>Association</a>s
--   implied by a <a>GDBRefInfo</a>.
dbrefAssocs :: (Model child, Model parent) => GDBRefInfo rt child parent -> (Association child parent, Association parent child)

-- | Short for
--   
--   <pre>
--   snd $ dbrefAssocs defaultDBRefInfo
--   </pre>
--   
--   Note the inverse <a>Association</a> is given by <a>belongsTo</a>. For
--   example, given the <tt>Author</tt> and <tt>Post</tt> models described
--   in the documentation for <a>GDBRefInfo</a>, in which each
--   <tt>Post</tt> references an <tt>Author</tt>, you might say:
--   
--   <pre>
--   author_post :: Association Author Post
--   author_post = has
--   
--   post_author :: Association Post Author
--   post_author = belongsTo
--   </pre>
has :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => Association parent child

-- | The inverse of <a>has</a>. Short for
--   
--   <pre>
--   fst $ dbrefAssocs defaultDBRefInfo
--   </pre>
--   
--   See an example at <a>has</a>.
belongsTo :: (Model child, Model parent, GetField ExtractRef child (DBRef parent)) => Association child parent

-- | A data structure representing a dedicated join table in the database.
--   A join table differs from a model in that rows do not have primary
--   keys. Hence, model operations do not apply. Nonetheless a join table
--   conveys information about a relationship between models.
--   
--   Note that all names in a <tt>JoinTable</tt> should be unquoted.
data JoinTable a b
JoinTable :: !ByteString -> !ByteString -> !ByteString -> JoinTable a b

-- | Name of the join table in the database. (Not quoted.)
jtTable :: JoinTable a b -> !ByteString

-- | Name of the column in table <a>jtTable</a> that contains a
--   <a>DBRef</a> to model <tt>a</tt>. (Not quoted or table-qualified.)
jtColumnA :: JoinTable a b -> !ByteString

-- | Like <a>jtColumnA</a> for model <tt>b</tt>.
jtColumnB :: JoinTable a b -> !ByteString

-- | The default join table has the following fields:
--   
--   <ul>
--   <li><tt>jtName</tt> is the name of the two models (in alphabetical
--   order), separated by an <tt>'_'</tt> character.</li>
--   <li><a>jtColumnA</a> is the name of model <tt>a</tt>, an <tt>'_'</tt>
--   character, and the name of the primary key column in table
--   <tt>a</tt>.</li>
--   <li><a>jtColumnB</a> is the name of model <tt>b</tt>, an <tt>'_'</tt>
--   character, and the name of the primary key column in table
--   <tt>b</tt>.</li>
--   </ul>
--   
--   Note that <a>defaultJoinTable</a> cannot create a default join table
--   for joining a model to itself, as following these rules the two
--   columns would have the same name. If you wish to join a table to
--   itself, you have two options: First, you can define the join table and
--   assign the column names manually. This will permit you to call
--   <a>findAssoc</a>, but you still will not be able to use
--   <a>assocSelect</a> for more complex queries, since SQL does not permit
--   joins between two tables with the same name. The second option is to
--   give one of the sides of the join table a row alias with <a>As</a>.
--   For example:
--   
--   <pre>
--   data ParentBar = ParentBar
--   instance RowAlias ParentBar where rowAliasName _ = "parent_bar"
--   
--   selfJoinTable :: JoinTable Bar (As ParentBar Bar)
--   selfJoinTable = defaultJoinTable
--   
--   selfJoin :: Association Bar (As ParentBar Bar)
--   otherSelfJoin :: Association (As ParentBar Bar) Bar
--   (selfJoin, otherSelfJoin) = jtAssocs selfJoinTable
--   </pre>
defaultJoinTable :: (Model a, Model b) => JoinTable a b

-- | Generate the two associations implied by a <a>JoinTable</a>.
jtAssocs :: (Model a, Model b) => JoinTable a b -> (Association a b, Association b a)

-- | Add an association between two models to a join table. Returns
--   <a>True</a> if the association was not already there.
jtAdd :: (Model a, Model b) => JoinTable a b -> Connection -> a -> b -> IO Bool

-- | Remove an association from a join table. Returns <a>True</a> if the
--   association was previously there.
jtRemove :: (Model a, Model b) => JoinTable a b -> Connection -> a -> b -> IO Bool

-- | Remove an assocation from a join table when you don't have the target
--   instances of the two models handy, but do have references.
jtRemoveByRef :: (Model a, Model b) => JoinTable a b -> Connection -> GDBRef rt a -> GDBRef rt b -> IO Bool

-- | Combine two associations into one.
nestAssoc :: (Model a, Model b) => Association a b -> Association b c -> Association a (b :. c)

-- | Combine two associations into one, and project away the middle type.
--   (The middle type can still be mentioned in <tt>WHERE</tt> clauses.)
--   
--   An example:
--   
--   <pre>
--   data Author = Author {
--       authorId :: DBKey
--     } deriving (Show, Generic)
--   instance Model Author where modelInfo = underscoreModelInfo "author"
--   
--   data Post = Post {
--       postId :: DBKey
--     , postAuthorId :: DBRef Author
--     } deriving (Show, Generic)
--   instance Model Post where modelInfo = underscoreModelInfo "post"
--   
--   data Comment = Comment {
--       commentId :: DBKey
--     , commentPostId :: DBRef Post
--     } deriving (Show, Generic)
--   instance Model Comment where modelInfo = underscoreModelInfo "comment"
--   
--   author_posts :: Association Author Post
--   post_author :: Association Post Author
--   (post_author, author_posts) = dbrefAssocs defaultDBRefInfo
--   
--   -- Could equally well use dbrefAssocs as above
--   post_comments :: Association Post Comment
--   post_comments = has
--   
--   comment_post :: Association Comment Post
--   comment_post = belongsTo
--   
--   comment_author :: Association Comment Author
--   comment_author = chainAssoc comment_post post_author
--   
--   author_comments :: Association Author Comment
--   author_comments =  chainAssoc author_posts post_comments
--   </pre>
chainAssoc :: (Model a, Model b, Model c) => Association a b -> Association b c -> Association a c
newtype ValidationError
ValidationError :: HashMap Text [Text] -> ValidationError
validationErrors :: ValidationError -> HashMap Text [Text]
validate :: (a -> Bool) -> Text -> Text -> ValidationFunc a
validateNotEmpty :: (a -> Text) -> Text -> Text -> ValidationFunc a


-- | Functions for creating a table from a model. These are mostly useful
--   in development, for very rigid applications, or to compare what would
--   be created against what is actually in the database. In practice,
--   production settings should create and update tables using migrations.
--   
--   Note that often it is more interesting to see what would be created
--   than to create an actual table. For that reason, functions creating
--   the statements are exposed.
module Database.PostgreSQL.ORM.CreateTable

-- | Statement for creating the table corresponding to a model. Not strict
--   in its argument.
modelCreateStatement :: (Model a, Generic a, GDefTypes (Rep a)) => a -> Query

-- | Create a the database table for a model.
modelCreate :: (Model a, Generic a, GDefTypes (Rep a)) => Connection -> a -> IO Int64

-- | This is a helper class used to extract the row types. You don't need
--   to use this class. If you are creating custom types, just declare an
--   instance of <a>SqlType</a>.
class GDefTypes f
gDefTypes :: GDefTypes f => f p -> [ByteString]

-- | Create the database table corresponding to a <a>JoinTable</a>.
jtCreateStatement :: (Model a, Model b) => JoinTable a b -> Query

-- | Create a join table in the database.
jtCreate :: (Model a, Model b) => Connection -> JoinTable a b -> IO Int64
instance GDefTypes f => GDefTypes (M1 i c f)
instance (GDefTypes a, GDefTypes b) => GDefTypes (a :*: b)
instance SqlType c => GDefTypes (K1 i c)
