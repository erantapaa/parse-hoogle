-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Commonly used conduit functions, for both chunked and unchunked data
--   
@package conduit-combinators
@version 1.0.1


-- | These are stream fusion versions of some of the functions in
--   <a>Data.Conduit.Combinators</a>. Many functions don't have stream
--   versions here because instead they have <tt>RULES</tt> which inline a
--   definition that fuses.
module Data.Conduit.Combinators.Stream
yieldManyS :: (Monad m, MonoFoldable mono) => mono -> StreamProducer m (Element mono)
repeatMS :: Monad m => m a -> StreamProducer m a
repeatWhileMS :: Monad m => m a -> (a -> Bool) -> StreamProducer m a
sourceHandleS :: (MonadIO m, IOData a) => Handle -> StreamProducer m a
foldl1S :: Monad m => (a -> a -> a) -> StreamConsumer a m (Maybe a)
allS :: Monad m => (a -> Bool) -> StreamConsumer a m Bool
anyS :: Monad m => (a -> Bool) -> StreamConsumer a m Bool
sinkLazyS :: (Monad m, LazySequence lazy strict) => StreamConsumer strict m lazy
sinkVectorS :: (MonadBase base m, Vector v a, PrimMonad base) => StreamConsumer a m (v a)
sinkVectorNS :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> StreamConsumer a m (v a)
sinkLazyBuilderS :: (Monad m, Monoid builder, ToBuilder a builder, Builder builder lazy) => StreamConsumer a m lazy
lastS :: Monad m => StreamConsumer a m (Maybe a)
lastES :: (Monad m, IsSequence seq) => StreamConsumer seq m (Maybe (Element seq))
findS :: Monad m => (a -> Bool) -> StreamConsumer a m (Maybe a)
concatMapS :: (Monad m, MonoFoldable mono) => (a -> mono) -> StreamConduit a m (Element mono)
concatMapMS :: (Monad m, MonoFoldable mono) => (a -> m mono) -> StreamConduit a m (Element mono)
concatS :: (Monad m, MonoFoldable mono) => StreamConduit mono m (Element mono)
scanlS :: Monad m => (a -> b -> a) -> a -> StreamConduit b m a
scanlMS :: Monad m => (a -> b -> m a) -> a -> StreamConduit b m a
mapAccumWhileS :: Monad m => (a -> s -> Either s (s, b)) -> s -> StreamConduitM a b m s
mapAccumWhileMS :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> StreamConduitM a b m s
intersperseS :: Monad m => a -> StreamConduit a m a
slidingWindowS :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> StreamConduit a m seq
filterMS :: Monad m => (a -> m Bool) -> StreamConduit a m a
splitOnUnboundedES :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> StreamConduit seq m seq

-- | Streaming versions of
--   <tt>Data.Conduit.Combinators.Internal.initReplicate</tt>
initReplicateS :: Monad m => m seed -> (seed -> m a) -> Int -> StreamProducer m a

-- | Streaming versions of
--   <tt>Data.Conduit.Combinators.Internal.initRepeat</tt>
initRepeatS :: Monad m => m seed -> (seed -> m a) -> StreamProducer m a


-- | Internal helper functions, usually used for rewrite rules.
module Data.Conduit.Combinators.Internal

-- | Acquire the seed value and perform the given action with it n times,
--   yielding each result.
--   
--   Subject to fusion
--   
--   Since 0.2.1
initReplicate :: Monad m => m seed -> (seed -> m a) -> Int -> Producer m a

-- | Optimized version of initReplicate for the special case of connecting
--   with a <tt>Sink</tt>.
--   
--   Since 0.2.1
initReplicateConnect :: Monad m => m seed -> (seed -> m a) -> Int -> Sink a m b -> m b

-- | Acquire the seed value and perform the given action with it forever,
--   yielding each result.
--   
--   Subject to fusion
--   
--   Since 0.2.1
initRepeat :: Monad m => m seed -> (seed -> m a) -> Producer m a

-- | Optimized version of initRepeat for the special case of connecting
--   with a <tt>Sink</tt>.
--   
--   Since 0.2.1
initRepeatConnect :: Monad m => m seed -> (seed -> m a) -> Sink a m b -> m b


-- | This module is meant as a replacement for Data.Conduit.List. That
--   module follows a naming scheme which was originally inspired by its
--   enumerator roots. This module is meant to introduce a naming scheme
--   which encourages conduit best practices.
--   
--   There are two versions of functions in this module. Those with a
--   trailing E work in the individual elements of a chunk of data, e.g.,
--   the bytes of a ByteString, the Chars of a Text, or the Ints of a
--   Vector Int. Those without a trailing E work on unchunked streams.
--   
--   FIXME: discuss overall naming, usage of mono-traversable, etc
--   
--   Mention take (Conduit) vs drop (Consumer)
module Data.Conduit.Combinators

-- | Yield each of the values contained by the given <tt>MonoFoldable</tt>.
--   
--   This will work on many data structures, including lists,
--   <tt>ByteString</tt>s, and <tt>Vector</tt>s.
--   
--   Subject to fusion
--   
--   Since 1.0.0
yieldMany :: (Monad m, MonoFoldable mono) => mono -> Producer m (Element mono)

-- | Generate a producer from a seed value.
--   
--   Subject to fusion
--   
--   Since 1.0.0
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> Producer m a

-- | Enumerate from a value to a final value, inclusive, via <a>succ</a>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
--   
--   Subject to fusion
--   
--   Since 1.0.0
enumFromTo :: (Monad m, Enum a, Ord a) => a -> a -> Producer m a

-- | Produces an infinite stream of repeated applications of f to x.
--   
--   Subject to fusion
--   
--   Since 1.0.0
iterate :: Monad m => (a -> a) -> a -> Producer m a

-- | Produce an infinite stream consisting entirely of the given value.
--   
--   Subject to fusion
--   
--   Since 1.0.0
repeat :: Monad m => a -> Producer m a

-- | Produce a finite stream consisting of n copies of the given value.
--   
--   Subject to fusion
--   
--   Since 1.0.0
replicate :: Monad m => Int -> a -> Producer m a

-- | Generate a producer by yielding each of the strict chunks in a
--   <tt>LazySequence</tt>.
--   
--   For more information, see <a>toChunks</a>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceLazy :: (Monad m, LazySequence lazy strict) => lazy -> Producer m strict

-- | Repeatedly run the given action and yield all values it produces.
--   
--   Subject to fusion
--   
--   Since 1.0.0
repeatM :: Monad m => m a -> Producer m a

-- | Repeatedly run the given action and yield all values it produces,
--   until the provided predicate returns <tt>False</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
repeatWhileM :: Monad m => m a -> (a -> Bool) -> Producer m a

-- | Perform the given action n times, yielding each result.
--   
--   Subject to fusion
--   
--   Since 1.0.0
replicateM :: Monad m => Int -> m a -> Producer m a

-- | Read all data from the given file.
--   
--   This function automatically opens and closes the file handle, and
--   ensures exception safety via <tt>MonadResource</tt>. It works for all
--   instances of <tt>IOData</tt>, including <tt>ByteString</tt> and
--   <tt>Text</tt>.
--   
--   Since 1.0.0
sourceFile :: (MonadResource m, IOData a) => FilePath -> Producer m a

-- | Read all data from the given <tt>Handle</tt>.
--   
--   Does not close the <tt>Handle</tt> at any point.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceHandle :: (MonadIO m, IOData a) => Handle -> Producer m a

-- | Open a <tt>Handle</tt> using the given function and stream data from
--   it.
--   
--   Automatically closes the file at completion.
--   
--   Since 1.0.0
sourceIOHandle :: (MonadResource m, IOData a) => IO Handle -> Producer m a

-- | <tt>sourceHandle</tt> applied to <tt>stdin</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
stdin :: (MonadIO m, IOData a) => Producer m a

-- | Create an infinite stream of random values, seeding from the system
--   random number.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceRandom :: (Variate a, MonadIO m) => Producer m a

-- | Create a stream of random values of length n, seeding from the system
--   random number.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceRandomN :: (Variate a, MonadIO m) => Int -> Producer m a

-- | Create an infinite stream of random values, using the given random
--   number generator.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceRandomGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Producer m a

-- | Create a stream of random values of length n, seeding from the system
--   random number.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sourceRandomNGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Int -> Producer m a

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
--   
--   Since 1.0.0
sourceDirectory :: MonadResource m => FilePath -> Producer m FilePath

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
--   
--   Since 1.0.0
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> Producer m FilePath

-- | Ignore a certain number of values in the stream.
--   
--   Since 1.0.0
drop :: Monad m => Int -> Consumer a m ()

-- | Drop a certain number of elements from a chunked stream.
--   
--   Since 1.0.0
dropE :: (Monad m, IsSequence seq) => Index seq -> Consumer seq m ()

-- | Drop all values which match the given predicate.
--   
--   Since 1.0.0
dropWhile :: Monad m => (a -> Bool) -> Consumer a m ()

-- | Drop all elements in the chunked stream which match the given
--   predicate.
--   
--   Since 1.0.0
dropWhileE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Consumer seq m ()

-- | Monoidally combine all values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
fold :: (Monad m, Monoid a) => Consumer a m a

-- | Monoidally combine all elements in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldE :: (Monad m, MonoFoldable mono, Monoid (Element mono)) => Consumer mono m (Element mono)

-- | A strict left fold.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldl :: Monad m => (a -> b -> a) -> a -> Consumer b m a

-- | A strict left fold with no starting value. Returns <a>Nothing</a> when
--   the stream is empty.
--   
--   Subject to fusion
foldl1 :: Monad m => (a -> a -> a) -> Consumer a m (Maybe a)

-- | A strict left fold on a chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldlE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> a) -> a -> Consumer mono m a

-- | Apply the provided mapping function and monoidal combine all values.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldMap :: (Monad m, Monoid b) => (a -> b) -> Consumer a m b

-- | Apply the provided mapping function and monoidal combine all elements
--   of the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldMapE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Consumer mono m w

-- | Check that all values in the stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Subject to fusion
--   
--   Since 1.0.0
all :: Monad m => (a -> Bool) -> Consumer a m Bool

-- | Check that all elements in the chunked stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Subject to fusion
--   
--   Since 1.0.0
allE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m Bool

-- | Check that at least one value in the stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Subject to fusion
--   
--   Since 1.0.0
any :: Monad m => (a -> Bool) -> Consumer a m Bool

-- | Check that at least one element in the chunked stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Subject to fusion
--   
--   Since 1.0.0
anyE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m Bool

-- | Are all values in the stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Subject to fusion
--   
--   Since 1.0.0
and :: Monad m => Consumer Bool m Bool

-- | Are all elements in the chunked stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Subject to fusion
--   
--   Since 1.0.0
andE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Consumer mono m Bool

-- | Are any values in the stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Subject to fusion
--   
--   Since 1.0.0
or :: Monad m => Consumer Bool m Bool

-- | Are any elements in the chunked stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Subject to fusion
--   
--   Since 1.0.0
orE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Consumer mono m Bool

-- | Are any values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
--   
--   Since 1.0.0
elem :: (Monad m, Eq a) => a -> Consumer a m Bool

-- | Are any elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
--   
--   Since 1.0.0
elemE :: (Monad m, EqSequence seq) => Element seq -> Consumer seq m Bool

-- | Are no values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
--   
--   Since 1.0.0
notElem :: (Monad m, Eq a) => a -> Consumer a m Bool

-- | Are no elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
--   
--   Since 1.0.0
notElemE :: (Monad m, EqSequence seq) => Element seq -> Consumer seq m Bool

-- | Consume all incoming strict chunks into a lazy sequence. Note that the
--   entirety of the sequence will be resident at memory.
--   
--   This can be used to consume a stream of strict ByteStrings into a lazy
--   ByteString, for example.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkLazy :: (Monad m, LazySequence lazy strict) => Consumer strict m lazy

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkList :: Monad m => Consumer a m [a]

-- | Sink incoming values into a vector, growing the vector as necessary to
--   fit more elements.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkVector :: (MonadBase base m, Vector v a, PrimMonad base) => Consumer a m (v a)

-- | Sink incoming values into a vector, up until size <tt>maxSize</tt>.
--   Subsequent values will be left in the stream. If there are less than
--   <tt>maxSize</tt> values present, returns a <tt>Vector</tt> of smaller
--   size.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkVectorN :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> Consumer a m (v a)

-- | Convert incoming values to a builder and fold together all builder
--   values.
--   
--   Defined as: <tt>foldMap toBuilder</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkBuilder :: (Monad m, Monoid builder, ToBuilder a builder) => Consumer a m builder

-- | Same as <tt>sinkBuilder</tt>, but afterwards convert the builder to
--   its lazy representation.
--   
--   Alternatively, this could be considered an alternative to
--   <tt>sinkLazy</tt>, with the following differences:
--   
--   <ul>
--   <li>This function will allow multiple input types, not just the strict
--   version of the lazy structure.</li>
--   <li>Some buffer copying may occur in this version.</li>
--   </ul>
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkLazyBuilder :: (Monad m, Monoid builder, ToBuilder a builder, Builder builder lazy) => Consumer a m lazy

-- | Consume and discard all remaining values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkNull :: Monad m => Consumer a m ()

-- | Same as <tt>await</tt>, but discards any leading <a>onull</a> values.
--   
--   Since 1.0.0
awaitNonNull :: (Monad m, MonoFoldable a) => Consumer a m (Maybe (NonNull a))

-- | Get the next element in the chunked stream.
--   
--   Since 1.0.0
headE :: (Monad m, IsSequence seq) => Consumer seq m (Maybe (Element seq))

-- | View the next value in the stream without consuming it.
--   
--   Since 1.0.0
peek :: Monad m => Consumer a m (Maybe a)

-- | View the next element in the chunked stream without consuming it.
--   
--   Since 1.0.0
peekE :: (Monad m, MonoFoldable mono) => Consumer mono m (Maybe (Element mono))

-- | Retrieve the last value in the stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
last :: Monad m => Consumer a m (Maybe a)

-- | Retrieve the last element in the chunked stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
lastE :: (Monad m, IsSequence seq) => Consumer seq m (Maybe (Element seq))

-- | Count how many values are in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
length :: (Monad m, Num len) => Consumer a m len

-- | Count how many elements are in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
lengthE :: (Monad m, Num len, MonoFoldable mono) => Consumer mono m len

-- | Count how many values in the stream pass the given predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
lengthIf :: (Monad m, Num len) => (a -> Bool) -> Consumer a m len

-- | Count how many elements in the chunked stream pass the given
--   predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
lengthIfE :: (Monad m, Num len, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m len

-- | Get the largest value in the stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
maximum :: (Monad m, Ord a) => Consumer a m (Maybe a)

-- | Get the largest element in the chunked stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
maximumE :: (Monad m, OrdSequence seq) => Consumer seq m (Maybe (Element seq))

-- | Get the smallest value in the stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
minimum :: (Monad m, Ord a) => Consumer a m (Maybe a)

-- | Get the smallest element in the chunked stream, if present.
--   
--   Subject to fusion
--   
--   Since 1.0.0
minimumE :: (Monad m, OrdSequence seq) => Consumer seq m (Maybe (Element seq))

-- | True if there are no values in the stream.
--   
--   This function does not modify the stream.
--   
--   Since 1.0.0
null :: Monad m => Consumer a m Bool

-- | True if there are no elements in the chunked stream.
--   
--   This function may remove empty leading chunks from the stream, but
--   otherwise will not modify it.
--   
--   Since 1.0.0
nullE :: (Monad m, MonoFoldable mono) => Consumer mono m Bool

-- | Get the sum of all values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sum :: (Monad m, Num a) => Consumer a m a

-- | Get the sum of all elements in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sumE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Consumer mono m (Element mono)

-- | Get the product of all values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
product :: (Monad m, Num a) => Consumer a m a

-- | Get the product of all elements in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
productE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Consumer mono m (Element mono)

-- | Find the first matching value.
--   
--   Subject to fusion
--   
--   Since 1.0.0
find :: Monad m => (a -> Bool) -> Consumer a m (Maybe a)

-- | Apply the action to all values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
mapM_ :: Monad m => (a -> m ()) -> Consumer a m ()

-- | Apply the action to all elements in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
mapM_E :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> Consumer mono m ()

-- | A monadic strict left fold.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldM :: Monad m => (a -> b -> m a) -> a -> Consumer b m a

-- | A monadic strict left fold on a chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldME :: (Monad m, MonoFoldable mono) => (a -> Element mono -> m a) -> a -> Consumer mono m a

-- | Apply the provided monadic mapping function and monoidal combine all
--   values.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldMapM :: (Monad m, Monoid w) => (a -> m w) -> Consumer a m w

-- | Apply the provided monadic mapping function and monoidal combine all
--   elements in the chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
foldMapME :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> m w) -> Consumer mono m w

-- | Write all data to the given file.
--   
--   This function automatically opens and closes the file handle, and
--   ensures exception safety via <tt>MonadResource</tt>. It works for all
--   instances of <tt>IOData</tt>, including <tt>ByteString</tt> and
--   <tt>Text</tt>.
--   
--   Since 1.0.0
sinkFile :: (MonadResource m, IOData a) => FilePath -> Consumer a m ()

-- | Write all data to the given <tt>Handle</tt>.
--   
--   Does not close the <tt>Handle</tt> at any point.
--   
--   Subject to fusion
--   
--   Since 1.0.0
sinkHandle :: (MonadIO m, IOData a) => Handle -> Consumer a m ()

-- | Open a <tt>Handle</tt> using the given function and stream data to it.
--   
--   Automatically closes the file at completion.
--   
--   Since 1.0.0
sinkIOHandle :: (MonadResource m, IOData a) => IO Handle -> Consumer a m ()

-- | Print all incoming values to stdout.
--   
--   Subject to fusion
--   
--   Since 1.0.0
print :: (Show a, MonadIO m) => Consumer a m ()

-- | <tt>sinkHandle</tt> applied to <tt>stdout</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
stdout :: (MonadIO m, IOData a) => Consumer a m ()

-- | <tt>sinkHandle</tt> applied to <tt>stderr</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
stderr :: (MonadIO m, IOData a) => Consumer a m ()

-- | Apply a transformation to all values in a stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
map :: Monad m => (a -> b) -> Conduit a m b

-- | Apply a transformation to all elements in a chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
mapE :: (Monad m, Functor f) => (a -> b) -> Conduit (f a) m (f b)

-- | Apply a monomorphic transformation to all elements in a chunked
--   stream.
--   
--   Unlike <tt>mapE</tt>, this will work on types like <tt>ByteString</tt>
--   and <tt>Text</tt> which are <tt>MonoFunctor</tt> but not
--   <tt>Functor</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
omapE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> Conduit mono m mono

-- | Apply the function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concatMap :: (Monad m, MonoFoldable mono) => (a -> mono) -> Conduit a m (Element mono)

-- | Apply the function to each element in the chunked stream, resulting in
--   a foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concatMapE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Conduit mono m w

-- | Stream up to n number of values downstream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <a>takeExactly</a>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
take :: Monad m => Int -> Conduit a m a

-- | Stream up to n number of elements downstream in a chunked stream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <a>takeExactlyE</a>.
--   
--   Since 1.0.0
takeE :: (Monad m, IsSequence seq) => Index seq -> Conduit seq m seq

-- | Stream all values downstream that match the given predicate.
--   
--   Same caveats regarding downstream termination apply as with
--   <a>take</a>.
--   
--   Since 1.0.0
takeWhile :: Monad m => (a -> Bool) -> Conduit a m a

-- | Stream all elements downstream that match the given predicate in a
--   chunked stream.
--   
--   Same caveats regarding downstream termination apply as with
--   <a>takeE</a>.
--   
--   Since 1.0.0
takeWhileE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Conduit seq m seq

-- | Consume precisely the given number of values and feed them downstream.
--   
--   This function is in contrast to <a>take</a>, which will only consume
--   up to the given number of values, and will terminate early if
--   downstream terminates early. This function will discard any additional
--   values in the stream if they are unconsumed.
--   
--   Note that this function takes a downstream <tt>ConduitM</tt> as a
--   parameter, as opposed to working with normal fusion. For more
--   information, see
--   <a>http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit</a>,
--   the section titled "pipes and conduit: isolate".
--   
--   Since 1.0.0
takeExactly :: Monad m => Int -> ConduitM a b m r -> ConduitM a b m r

-- | Same as <a>takeExactly</a>, but for chunked streams.
--   
--   Since 1.0.0
takeExactlyE :: (Monad m, IsSequence a) => Index a -> ConduitM a b m r -> ConduitM a b m r

-- | Flatten out a stream by yielding the values contained in an incoming
--   <tt>MonoFoldable</tt> as individually yielded values.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concat :: (Monad m, MonoFoldable mono) => Conduit mono m (Element mono)

-- | Keep only values in the stream passing a given predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
filter :: Monad m => (a -> Bool) -> Conduit a m a

-- | Keep only elements in the chunked stream passing a given predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
filterE :: (IsSequence seq, Monad m) => (Element seq -> Bool) -> Conduit seq m seq

-- | Map values as long as the result is <tt>Just</tt>.
--   
--   Since 1.0.0
mapWhile :: Monad m => (a -> Maybe b) -> Conduit a m b

-- | Break up a stream of values into vectors of size n. The final vector
--   may be smaller than n if the total number of values is not a strict
--   multiple of n. No empty vectors will be yielded.
--   
--   Since 1.0.0
conduitVector :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> Conduit a m (v a)

-- | Analog of <a>scanl</a> for lists.
--   
--   Subject to fusion
--   
--   Since 1.0.6
scanl :: Monad m => (a -> b -> a) -> a -> Conduit b m a

-- | <a>mapWhile</a> with a break condition dependent on an accumulator.
--   Equivalently, <a>mapAccum</a> as long as the result is <tt>Right</tt>.
--   Instead of producing a leftover, the breaking input determines the
--   resulting accumulator via <tt>Left</tt>.
--   
--   Subject to fusion
mapAccumWhile :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitM a b m s

-- | <a>concatMap</a> with an accumulator.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concatMapAccum :: Monad m => (a -> accum -> (accum, [b])) -> accum -> Conduit a m b

-- | Insert the given value between each two values in the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
intersperse :: Monad m => a -> Conduit a m a

-- | Sliding window of values 1,2,3,4,5 with window size 2 gives
--   [1,2],[2,3],[3,4],[4,5]
--   
--   Best used with structures that support O(1) snoc.
--   
--   Subject to fusion
--   
--   Since 1.0.0
slidingWindow :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> Conduit a m seq

-- | Apply base64-encoding to the stream.
--   
--   Since 1.0.0
encodeBase64 :: Monad m => Conduit ByteString m ByteString

-- | Apply base64-decoding to the stream. Will stop decoding on the first
--   invalid chunk.
--   
--   Since 1.0.0
decodeBase64 :: Monad m => Conduit ByteString m ByteString

-- | Apply URL-encoding to the stream.
--   
--   Since 1.0.0
encodeBase64URL :: Monad m => Conduit ByteString m ByteString

-- | Apply lenient base64URL-decoding to the stream. Will stop decoding on
--   the first invalid chunk.
--   
--   Since 1.0.0
decodeBase64URL :: Monad m => Conduit ByteString m ByteString

-- | Apply base16-encoding to the stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
encodeBase16 :: Monad m => Conduit ByteString m ByteString

-- | Apply base16-decoding to the stream. Will stop decoding on the first
--   invalid chunk.
--   
--   Since 1.0.0
decodeBase16 :: Monad m => Conduit ByteString m ByteString

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <a>mapM_</a>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
mapM :: Monad m => (a -> m b) -> Conduit a m b

-- | Apply a monadic transformation to all elements in a chunked stream.
--   
--   Subject to fusion
--   
--   Since 1.0.0
mapME :: (Monad m, Traversable f) => (a -> m b) -> Conduit (f a) m (f b)

-- | Apply a monadic monomorphic transformation to all elements in a
--   chunked stream.
--   
--   Unlike <tt>mapME</tt>, this will work on types like
--   <tt>ByteString</tt> and <tt>Text</tt> which are <tt>MonoFunctor</tt>
--   but not <tt>Functor</tt>.
--   
--   Subject to fusion
--   
--   Since 1.0.0
omapME :: (Monad m, MonoTraversable mono) => (Element mono -> m (Element mono)) -> Conduit mono m mono

-- | Apply the monadic function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMapM, mapMaybeM, and mapFoldableM.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concatMapM :: (Monad m, MonoFoldable mono) => (a -> m mono) -> Conduit a m (Element mono)

-- | Keep only values in the stream passing a given monadic predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
filterM :: Monad m => (a -> m Bool) -> Conduit a m a

-- | Keep only elements in the chunked stream passing a given monadic
--   predicate.
--   
--   Subject to fusion
--   
--   Since 1.0.0
filterME :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> Conduit seq m seq

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
--   
--   Subject to fusion
--   
--   Since 1.0.0
iterM :: Monad m => (a -> m ()) -> Conduit a m a

-- | Analog of <a>scanl</a> for lists, monadic.
--   
--   Subject to fusion
--   
--   Since 1.0.6
scanlM :: Monad m => (a -> b -> m a) -> a -> Conduit b m a

-- | Monadic <a>mapAccumWhile</a>.
--   
--   Subject to fusion
mapAccumWhileM :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> ConduitM a b m s

-- | <a>concatMapM</a> with an accumulator.
--   
--   Subject to fusion
--   
--   Since 1.0.0
concatMapAccumM :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> Conduit a m b

-- | Encode a stream of text as UTF8.
--   
--   Subject to fusion
--   
--   Since 1.0.0
encodeUtf8 :: (Monad m, Utf8 text binary) => Conduit text m binary

-- | Decode a stream of binary data as UTF8.
--   
--   Since 1.0.0
decodeUtf8 :: MonadThrow m => Conduit ByteString m Text

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes
--   with the Unicode replacement character.
--   
--   Since 1.0.0
decodeUtf8Lenient :: MonadThrow m => Conduit ByteString m Text

-- | Stream in the entirety of a single line.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the line
--   regardless of the behavior of the inner Conduit.
--   
--   Since 1.0.0
line :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitM seq o m r -> ConduitM seq o m r

-- | Same as <a>line</a>, but operates on ASCII/binary data.
--   
--   Since 1.0.0
lineAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitM seq o m r -> ConduitM seq o m r

-- | Insert a newline character after each incoming chunk of data.
--   
--   Subject to fusion
--   
--   Since 1.0.0
unlines :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq

-- | Same as <a>unlines</a>, but operates on ASCII/binary data.
--   
--   Subject to fusion
--   
--   Since 1.0.0
unlinesAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq

-- | Stream in the chunked input until an element matches a predicate.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the
--   prefix regardless of the behavior of the inner Conduit.
takeExactlyUntilE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitM seq o m r -> ConduitM seq o m r

-- | Convert a stream of arbitrarily-chunked textual data into a stream of
--   data where each chunk represents a single line. Note that, if you have
--   unknown or untrusted input, this function is <i>unsafe</i>, since it
--   would allow an attacker to form lines of massive length and exhaust
--   memory.
--   
--   Subject to fusion
--   
--   Since 1.0.0
linesUnbounded :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq

-- | Same as <a>linesUnbounded</a>, but for ASCII/binary data.
--   
--   Subject to fusion
--   
--   Since 1.0.0
linesUnboundedAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq

-- | Split a stream of arbitrarily-chunked data, based on a predicate on
--   elements. Elements that satisfy the predicate will cause chunks to be
--   split, and aren't included in these output chunks. Note that, if you
--   have unknown or untrusted input, this function is <i>unsafe</i>, since
--   it would allow an attacker to form chunks of massive length and
--   exhaust memory.
splitOnUnboundedE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Conduit seq m seq

-- | Generally speaking, yielding values from inside a Conduit requires
--   some allocation for constructors. This can introduce an overhead,
--   similar to the overhead needed to represent a list of values instead
--   of a vector. This overhead is even more severe when talking about
--   unboxed values.
--   
--   This combinator allows you to overcome this overhead, and efficiently
--   fill up vectors. It takes two parameters. The first is the size of
--   each mutable vector to be allocated. The second is a function. The
--   function takes an argument which will yield the next value into a
--   mutable vector.
--   
--   Under the surface, this function uses a number of tricks to get high
--   performance. For more information on both usage and implementation,
--   please see:
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/vectorbuilder</a>
--   
--   Since 1.0.0
vectorBuilder :: (PrimMonad base, MonadBase base m, Vector v e, MonadBase base n) => Int -> ((e -> n ()) -> Sink i m r) -> ConduitM i (v e) m r

-- | Consume a source in a way piecewise defined by a controlling stream.
--   The latter will be evaluated until it terminates.
--   
--   <pre>
--   &gt;&gt;&gt; let f a s = liftM (:s) $ mapC (*a) =$ CL.take a
--   
--   &gt;&gt;&gt; reverse $ runIdentity $ yieldMany [0..3] $$ mapAccumS f [] (yieldMany [1..])
--   [[],[1],[4,6],[12,15,18]] :: [[Int]]
--   </pre>
mapAccumS :: Monad m => (a -> s -> Sink b m s) -> s -> Source m b -> Sink a m s

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
--   
--   Since 1.0.0
peekForever :: Monad m => ConduitM i o m () -> ConduitM i o m ()


-- | Your intended one-stop-shop for conduit functionality. This re-exports
--   functions from many commonly used modules. When there is a conflict
--   with standard functions, functions in this module are disambiguated by
--   adding a trailing C (or for chunked functions, replacing a trailing E
--   with CE). This means that the Conduit module can be imported
--   unqualified without causing naming conflicts.
--   
--   For more information on the naming scheme and intended usages of the
--   combinators, please see the <a>Data.Conduit.Combinators</a>
--   documentation.
module Conduit

-- | Yield each of the values contained by the given <tt>MonoFoldable</tt>.
--   
--   This will work on many data structures, including lists,
--   <tt>ByteString</tt>s, and <tt>Vector</tt>s.
--   
--   Since 1.0.0
yieldMany :: (Monad m, MonoFoldable mono) => mono -> Producer m (Element mono)

-- | Generate a producer from a seed value.
--   
--   Since 1.0.0
unfoldC :: Monad m => (b -> Maybe (a, b)) -> b -> Producer m a

-- | Enumerate from a value to a final value, inclusive, via <tt>succ</tt>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
--   
--   Since 1.0.0
enumFromToC :: (Monad m, Enum a, Ord a) => a -> a -> Producer m a

-- | Produces an infinite stream of repeated applications of f to x.
--   
--   Since 1.0.0
iterateC :: Monad m => (a -> a) -> a -> Producer m a

-- | Produce an infinite stream consisting entirely of the given value.
--   
--   Since 1.0.0
repeatC :: Monad m => a -> Producer m a

-- | Produce a finite stream consisting of n copies of the given value.
--   
--   Since 1.0.0
replicateC :: Monad m => Int -> a -> Producer m a

-- | Generate a producer by yielding each of the strict chunks in a
--   <tt>LazySequence</tt>.
--   
--   For more information, see <a>toChunks</a>.
--   
--   Since 1.0.0
sourceLazy :: (Monad m, LazySequence lazy strict) => lazy -> Producer m strict

-- | Repeatedly run the given action and yield all values it produces.
--   
--   Since 1.0.0
repeatMC :: Monad m => m a -> Producer m a

-- | Repeatedly run the given action and yield all values it produces,
--   until the provided predicate returns <tt>False</tt>.
--   
--   Since 1.0.0
repeatWhileMC :: Monad m => m a -> (a -> Bool) -> Producer m a

-- | Perform the given action n times, yielding each result.
--   
--   Since 1.0.0
replicateMC :: Monad m => Int -> m a -> Producer m a

-- | Read all data from the given file.
--   
--   This function automatically opens and closes the file handle, and
--   ensures exception safety via <tt>MonadResource. It works for all
--   instances of </tt>IOData<tt>, including </tt>ByteString<tt> and
--   </tt>Text@.
--   
--   Since 1.0.0
sourceFile :: (MonadResource m, IOData a) => FilePath -> Producer m a

-- | Read all data from the given <tt>Handle</tt>.
--   
--   Does not close the <tt>Handle</tt> at any point.
--   
--   Since 1.0.0
sourceHandle :: (MonadIO m, IOData a) => Handle -> Producer m a

-- | Open a <tt>Handle</tt> using the given function and stream data from
--   it.
--   
--   Automatically closes the file at completion.
--   
--   Since 1.0.0
sourceIOHandle :: (MonadResource m, IOData a) => IO Handle -> Producer m a

-- | <tt>sourceHandle</tt> applied to <tt>stdin</tt>.
--   
--   Since 1.0.0
stdinC :: (MonadIO m, IOData a) => Producer m a

-- | Create an infinite stream of random values, seeding from the system
--   random number.
--   
--   Since 1.0.0
sourceRandom :: (Variate a, MonadIO m) => Producer m a

-- | Create a stream of random values of length n, seeding from the system
--   random number.
--   
--   Since 1.0.0
sourceRandomN :: (Variate a, MonadIO m) => Int -> Producer m a

-- | Create an infinite stream of random values, using the given random
--   number generator.
--   
--   Since 1.0.0
sourceRandomGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Producer m a

-- | Create a stream of random values of length n, seeding from the system
--   random number.
--   
--   Since 1.0.0
sourceRandomNGen :: (Variate a, MonadBase base m, PrimMonad base) => Gen (PrimState base) -> Int -> Producer m a

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
--   
--   Since 1.0.0
sourceDirectory :: MonadResource m => FilePath -> Producer m FilePath

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
--   
--   Since 1.0.0
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> Producer m FilePath

-- | Ignore a certain number of values in the stream.
--   
--   Since 1.0.0
dropC :: Monad m => Int -> Consumer a m ()

-- | Drop a certain number of elements from a chunked stream.
--   
--   Since 1.0.0
dropCE :: (Monad m, IsSequence seq) => Index seq -> Consumer seq m ()

-- | Drop all values which match the given predicate.
--   
--   Since 1.0.0
dropWhileC :: Monad m => (a -> Bool) -> Consumer a m ()

-- | Drop all elements in the chunked stream which match the given
--   predicate.
--   
--   Since 1.0.0
dropWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Consumer seq m ()

-- | Monoidally combine all values in the stream.
--   
--   Since 1.0.0
foldC :: (Monad m, Monoid a) => Consumer a m a

-- | Monoidally combine all elements in the chunked stream.
--   
--   Since 1.0.0
foldCE :: (Monad m, MonoFoldable mono, Monoid (Element mono)) => Consumer mono m (Element mono)

-- | A strict left fold.
--   
--   Since 1.0.0
foldlC :: Monad m => (a -> b -> a) -> a -> Consumer b m a

-- | A strict left fold on a chunked stream.
--   
--   Since 1.0.0
foldlCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> a) -> a -> Consumer mono m a

-- | Apply the provided mapping function and monoidal combine all values.
--   
--   Since 1.0.0
foldMapC :: (Monad m, Monoid b) => (a -> b) -> Consumer a m b

-- | Apply the provided mapping function and monoidal combine all elements
--   of the chunked stream.
--   
--   Since 1.0.0
foldMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Consumer mono m w

-- | Check that all values in the stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Since 1.0.0
allC :: Monad m => (a -> Bool) -> Consumer a m Bool

-- | Check that all elements in the chunked stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Since 1.0.0
allCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m Bool

-- | Check that at least one value in the stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Since 1.0.0
anyC :: Monad m => (a -> Bool) -> Consumer a m Bool

-- | Check that at least one element in the chunked stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Since 1.0.0
anyCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m Bool

-- | Are all values in the stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Since 1.0.0
andC :: Monad m => Consumer Bool m Bool

-- | Are all elements in the chunked stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Since 1.0.0
andCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Consumer mono m Bool

-- | Are any values in the stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Since 1.0.0
orC :: Monad m => Consumer Bool m Bool

-- | Are any elements in the chunked stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Since 1.0.0
orCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => Consumer mono m Bool

-- | Are any values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Since 1.0.0
elemC :: (Monad m, Eq a) => a -> Consumer a m Bool

-- | Are any elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Since 1.0.0
elemCE :: (Monad m, EqSequence seq) => Element seq -> Consumer seq m Bool

-- | Are no values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Since 1.0.0
notElemC :: (Monad m, Eq a) => a -> Consumer a m Bool

-- | Are no elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Since 1.0.0
notElemCE :: (Monad m, EqSequence seq) => Element seq -> Consumer seq m Bool

-- | Consume all incoming strict chunks into a lazy sequence. Note that the
--   entirety of the sequence will be resident at memory.
--   
--   This can be used to consume a stream of strict ByteStrings into a lazy
--   ByteString, for example.
--   
--   Since 1.0.0
sinkLazy :: (Monad m, LazySequence lazy strict) => Consumer strict m lazy

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory.
--   
--   Since 1.0.0
sinkList :: Monad m => Consumer a m [a]

-- | Sink incoming values into a vector, growing the vector as necessary to
--   fit more elements.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Since 1.0.0
sinkVector :: (MonadBase base m, Vector v a, PrimMonad base) => Consumer a m (v a)

-- | Sink incoming values into a vector, up until size <tt>maxSize</tt>.
--   Subsequent values will be left in the stream. If there are less than
--   <tt>maxSize</tt> values present, returns a <tt>Vector</tt> of smaller
--   size.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Since 1.0.0
sinkVectorN :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> Consumer a m (v a)

-- | Convert incoming values to a builder and fold together all builder
--   values.
--   
--   Defined as: <tt>foldMap toBuilder</tt>.
--   
--   Since 1.0.0
sinkBuilder :: (Monad m, Monoid builder, ToBuilder a builder) => Consumer a m builder

-- | Same as <tt>sinkBuilder</tt>, but afterwards convert the builder to
--   its lazy representation.
--   
--   Alternatively, this could be considered an alternative to
--   <tt>sinkLazy</tt>, with the following differences:
--   
--   <ul>
--   <li>This function will allow multiple input types, not just the strict
--   version of the lazy structure.</li>
--   <li>Some buffer copying may occur in this version.</li>
--   </ul>
--   
--   Since 1.0.0
sinkLazyBuilder :: (Monad m, Monoid builder, ToBuilder a builder, Builder builder lazy) => Consumer a m lazy

-- | Consume and discard all remaining values in the stream.
--   
--   Since 1.0.0
sinkNull :: Monad m => Consumer a m ()

-- | Same as <tt>await</tt>, but discards any leading <a>onull</a> values.
--   
--   Since 1.0.0
awaitNonNull :: (Monad m, MonoFoldable a) => Consumer a m (Maybe (NonNull a))

-- | Get the next element in the chunked stream.
--   
--   Since 1.0.0
headCE :: (Monad m, IsSequence seq) => Consumer seq m (Maybe (Element seq))

-- | View the next value in the stream without consuming it.
--   
--   Since 1.0.0
peekC :: Monad m => Consumer a m (Maybe a)

-- | View the next element in the chunked stream without consuming it.
--   
--   Since 1.0.0
peekCE :: (Monad m, MonoFoldable mono) => Consumer mono m (Maybe (Element mono))

-- | Retrieve the last value in the stream, if present.
--   
--   Since 1.0.0
lastC :: Monad m => Consumer a m (Maybe a)

-- | Retrieve the last element in the chunked stream, if present.
--   
--   Since 1.0.0
lastCE :: (Monad m, IsSequence seq) => Consumer seq m (Maybe (Element seq))

-- | Count how many values are in the stream.
--   
--   Since 1.0.0
lengthC :: (Monad m, Num len) => Consumer a m len

-- | Count how many elements are in the chunked stream.
--   
--   Since 1.0.0
lengthCE :: (Monad m, Num len, MonoFoldable mono) => Consumer mono m len

-- | Count how many values in the stream pass the given predicate.
--   
--   Since 1.0.0
lengthIfC :: (Monad m, Num len) => (a -> Bool) -> Consumer a m len

-- | Count how many elements in the chunked stream pass the given
--   predicate.
--   
--   Since 1.0.0
lengthIfCE :: (Monad m, Num len, MonoFoldable mono) => (Element mono -> Bool) -> Consumer mono m len

-- | Get the largest value in the stream, if present.
--   
--   Since 1.0.0
maximumC :: (Monad m, Ord a) => Consumer a m (Maybe a)

-- | Get the largest element in the chunked stream, if present.
--   
--   Since 1.0.0
maximumCE :: (Monad m, OrdSequence seq) => Consumer seq m (Maybe (Element seq))

-- | Get the smallest value in the stream, if present.
--   
--   Since 1.0.0
minimumC :: (Monad m, Ord a) => Consumer a m (Maybe a)

-- | Get the smallest element in the chunked stream, if present.
--   
--   Since 1.0.0
minimumCE :: (Monad m, OrdSequence seq) => Consumer seq m (Maybe (Element seq))

-- | True if there are no values in the stream.
--   
--   This function does not modify the stream.
--   
--   Since 1.0.0
nullC :: Monad m => Consumer a m Bool

-- | True if there are no elements in the chunked stream.
--   
--   This function may remove empty leading chunks from the stream, but
--   otherwise will not modify it.
--   
--   Since 1.0.0
nullCE :: (Monad m, MonoFoldable mono) => Consumer mono m Bool

-- | Get the sum of all values in the stream.
--   
--   Since 1.0.0
sumC :: (Monad m, Num a) => Consumer a m a

-- | Get the sum of all elements in the chunked stream.
--   
--   Since 1.0.0
sumCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Consumer mono m (Element mono)

-- | Get the product of all values in the stream.
--   
--   Since 1.0.0
productC :: (Monad m, Num a) => Consumer a m a

-- | Get the product of all elements in the chunked stream.
--   
--   Since 1.0.0
productCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => Consumer mono m (Element mono)

-- | Find the first matching value.
--   
--   Since 1.0.0
findC :: Monad m => (a -> Bool) -> Consumer a m (Maybe a)

-- | Apply the action to all values in the stream.
--   
--   Since 1.0.0
mapM_C :: Monad m => (a -> m ()) -> Consumer a m ()

-- | Apply the action to all elements in the chunked stream.
--   
--   Since 1.0.0
mapM_CE :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> Consumer mono m ()

-- | A monadic strict left fold.
--   
--   Since 1.0.0
foldMC :: Monad m => (a -> b -> m a) -> a -> Consumer b m a

-- | A monadic strict left fold on a chunked stream.
--   
--   Since 1.0.0
foldMCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> m a) -> a -> Consumer mono m a

-- | Apply the provided monadic mapping function and monoidal combine all
--   values.
--   
--   Since 1.0.0
foldMapMC :: (Monad m, Monoid w) => (a -> m w) -> Consumer a m w

-- | Apply the provided monadic mapping function and monoidal combine all
--   elements in the chunked stream.
--   
--   Since 1.0.0
foldMapMCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> m w) -> Consumer mono m w

-- | Write all data to the given file.
--   
--   This function automatically opens and closes the file handle, and
--   ensures exception safety via <tt>MonadResource. It works for all
--   instances of </tt>IOData<tt>, including </tt>ByteString<tt> and
--   </tt>Text@.
--   
--   Since 1.0.0
sinkFile :: (MonadResource m, IOData a) => FilePath -> Consumer a m ()

-- | Write all data to the given <tt>Handle</tt>.
--   
--   Does not close the <tt>Handle</tt> at any point.
--   
--   Since 1.0.0
sinkHandle :: (MonadIO m, IOData a) => Handle -> Consumer a m ()

-- | Open a <tt>Handle</tt> using the given function and stream data to it.
--   
--   Automatically closes the file at completion.
--   
--   Since 1.0.0
sinkIOHandle :: (MonadResource m, IOData a) => IO Handle -> Consumer a m ()

-- | Print all incoming values to stdout.
--   
--   Since 1.0.0
printC :: (Show a, MonadIO m) => Consumer a m ()

-- | <tt>sinkHandle</tt> applied to <tt>stdout</tt>.
--   
--   Since 1.0.0
stdoutC :: (MonadIO m, IOData a) => Consumer a m ()

-- | <tt>sinkHandle</tt> applied to <tt>stderr</tt>.
--   
--   Since 1.0.0
stderrC :: (MonadIO m, IOData a) => Consumer a m ()

-- | Apply a transformation to all values in a stream.
--   
--   Since 1.0.0
mapC :: Monad m => (a -> b) -> Conduit a m b

-- | Apply a transformation to all elements in a chunked stream.
--   
--   Since 1.0.0
mapCE :: (Monad m, Functor f) => (a -> b) -> Conduit (f a) m (f b)

-- | Apply a monomorphic transformation to all elements in a chunked
--   stream.
--   
--   Unlike <tt>mapE</tt>, this will work on types like <tt>ByteString</tt>
--   and <tt>Text</tt> which are <tt>MonoFunctor</tt> but not
--   <tt>Functor</tt>.
--   
--   Since 1.0.0
omapCE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> Conduit mono m mono

-- | Apply the function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Since 1.0.0
concatMapC :: (Monad m, MonoFoldable mono) => (a -> mono) -> Conduit a m (Element mono)

-- | Apply the function to each element in the chunked stream, resulting in
--   a foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Since 1.0.0
concatMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> Conduit mono m w

-- | Stream up to n number of values downstream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <tt>takeExactly</tt>.
--   
--   Since 1.0.0
takeC :: Monad m => Int -> Conduit a m a

-- | Stream up to n number of elements downstream in a chunked stream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <tt>takeExactlyE</tt>.
--   
--   Since 1.0.0
takeCE :: (Monad m, IsSequence seq) => Index seq -> Conduit seq m seq

-- | Stream all values downstream that match the given predicate.
--   
--   Same caveats regarding downstream termination apply as with
--   <tt>take</tt>.
--   
--   Since 1.0.0
takeWhileC :: Monad m => (a -> Bool) -> Conduit a m a

-- | Stream all elements downstream that match the given predicate in a
--   chunked stream.
--   
--   Same caveats regarding downstream termination apply as with
--   <tt>takeE</tt>.
--   
--   Since 1.0.0
takeWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> Conduit seq m seq

-- | Consume precisely the given number of values and feed them downstream.
--   
--   This function is in contrast to <tt>take</tt>, which will only consume
--   up to the given number of values, and will terminate early if
--   downstream terminates early. This function will discard any additional
--   values in the stream if they are unconsumed.
--   
--   Note that this function takes a downstream <tt>ConduitM</tt> as a
--   parameter, as opposed to working with normal fusion. For more
--   information, see
--   <a>http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit</a>,
--   the section titled "pipes and conduit: isolate".
--   
--   Since 1.0.0
takeExactlyC :: Monad m => Int -> ConduitM a b m r -> ConduitM a b m r

-- | Same as <tt>takeExactly</tt>, but for chunked streams.
--   
--   Since 1.0.0
takeExactlyCE :: (Monad m, IsSequence a) => Index a -> ConduitM a b m r -> ConduitM a b m r

-- | Flatten out a stream by yielding the values contained in an incoming
--   <tt>MonoFoldable</tt> as individually yielded values.
--   
--   Since 1.0.0
concatC :: (Monad m, MonoFoldable mono) => Conduit mono m (Element mono)

-- | Keep only values in the stream passing a given predicate.
--   
--   Since 1.0.0
filterC :: Monad m => (a -> Bool) -> Conduit a m a

-- | Keep only elements in the chunked stream passing a given predicate.
--   
--   Since 1.0.0
filterCE :: (IsSequence seq, Monad m) => (Element seq -> Bool) -> Conduit seq m seq

-- | Map values as long as the result is <tt>Just</tt>.
--   
--   Since 1.0.0
mapWhileC :: Monad m => (a -> Maybe b) -> Conduit a m b

-- | Break up a stream of values into vectors of size n. The final vector
--   may be smaller than n if the total number of values is not a strict
--   multiple of n. No empty vectors will be yielded.
--   
--   Since 1.0.0
conduitVector :: (MonadBase base m, Vector v a, PrimMonad base) => Int -> Conduit a m (v a)

-- | Analog of <a>scanl</a> for lists.
--   
--   Since 1.0.6
scanlC :: Monad m => (a -> b -> a) -> a -> Conduit b m a

-- | <a>mapWhileC</a> with a break condition dependent on an accumulator.
--   Equivalently, <a>mapAccum</a> as long as the result is <tt>Right</tt>.
--   Instead of producing a leftover, the breaking input determines the
--   resulting accumulator via <tt>Left</tt>.
mapAccumWhileC :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitM a b m s

-- | <tt>concatMap</tt> with an accumulator.
--   
--   Since 1.0.0
concatMapAccumC :: Monad m => (a -> accum -> (accum, [b])) -> accum -> Conduit a m b

-- | Insert the given value between each two values in the stream.
--   
--   Since 1.0.0
intersperseC :: Monad m => a -> Conduit a m a

-- | Sliding window of values 1,2,3,4,5 with window size 2 gives
--   [1,2],[2,3],[3,4],[4,5]
--   
--   Best used with structures that support O(1) snoc.
--   
--   Since 1.0.0
slidingWindowC :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> Conduit a m seq

-- | Apply base64-encoding to the stream.
--   
--   Since 1.0.0
encodeBase64C :: Monad m => Conduit ByteString m ByteString

-- | Apply base64-decoding to the stream. Will stop decoding on the first
--   invalid chunk.
--   
--   Since 1.0.0
decodeBase64C :: Monad m => Conduit ByteString m ByteString

-- | Apply URL-encoding to the stream.
--   
--   Since 1.0.0
encodeBase64URLC :: Monad m => Conduit ByteString m ByteString

-- | Apply lenient base64URL-decoding to the stream. Will stop decoding on
--   the first invalid chunk.
--   
--   Since 1.0.0
decodeBase64URLC :: Monad m => Conduit ByteString m ByteString

-- | Apply base16-encoding to the stream.
--   
--   Since 1.0.0
encodeBase16C :: Monad m => Conduit ByteString m ByteString

-- | Apply base16-decoding to the stream. Will stop decoding on the first
--   invalid chunk.
--   
--   Since 1.0.0
decodeBase16C :: Monad m => Conduit ByteString m ByteString

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <tt>mapM_</tt>.
--   
--   Since 1.0.0
mapMC :: Monad m => (a -> m b) -> Conduit a m b

-- | Apply a monadic transformation to all elements in a chunked stream.
--   
--   Since 1.0.0
mapMCE :: (Monad m, Traversable f) => (a -> m b) -> Conduit (f a) m (f b)

-- | Apply a monadic monomorphic transformation to all elements in a
--   chunked stream.
--   
--   Unlike <tt>mapME</tt>, this will work on types like
--   <tt>ByteString</tt> and <tt>Text</tt> which are <tt>MonoFunctor</tt>
--   but not <tt>Functor</tt>.
--   
--   Since 1.0.0
omapMCE :: (Monad m, MonoTraversable mono) => (Element mono -> m (Element mono)) -> Conduit mono m mono

-- | Apply the monadic function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMapM, mapMaybeM, and mapFoldableM.
--   
--   Since 1.0.0
concatMapMC :: (Monad m, MonoFoldable mono) => (a -> m mono) -> Conduit a m (Element mono)

-- | Keep only values in the stream passing a given monadic predicate.
--   
--   Since 1.0.0
filterMC :: Monad m => (a -> m Bool) -> Conduit a m a

-- | Keep only elements in the chunked stream passing a given monadic
--   predicate.
--   
--   Since 1.0.0
filterMCE :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> Conduit seq m seq

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
--   
--   Since 1.0.0
iterMC :: Monad m => (a -> m ()) -> Conduit a m a

-- | Analog of <a>scanl</a> for lists, monadic.
--   
--   Since 1.0.6
scanlMC :: Monad m => (a -> b -> m a) -> a -> Conduit b m a

-- | Monadic <a>mapAccumWhileC</a>.
mapAccumWhileMC :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> ConduitM a b m s

-- | <tt>concatMapM</tt> with an accumulator.
--   
--   Since 1.0.0
concatMapAccumMC :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> Conduit a m b

-- | Encode a stream of text as UTF8.
--   
--   Since 1.0.0
encodeUtf8C :: (Monad m, Utf8 text binary) => Conduit text m binary

-- | Decode a stream of binary data as UTF8.
--   
--   Since 1.0.0
decodeUtf8C :: MonadThrow m => Conduit ByteString m Text

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes
--   with the Unicode replacement character.
--   
--   Since 1.0.0
decodeUtf8LenientC :: MonadThrow m => Conduit ByteString m Text

-- | Stream in the entirety of a single line.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the line
--   regardless of the behavior of the inner Conduit.
--   
--   Since 1.0.0
lineC :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitM seq o m r -> ConduitM seq o m r

-- | Same as <tt>line</tt>, but operates on ASCII/binary data.
--   
--   Since 1.0.0
lineAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitM seq o m r -> ConduitM seq o m r

-- | Insert a newline character after each incoming chunk of data.
--   
--   Since 1.0.0
unlinesC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq

-- | Same as <tt>unlines</tt>, but operates on ASCII/binary data.
--   
--   Since 1.0.0
unlinesAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq

-- | Convert a stream of arbitrarily-chunked textual data into a stream of
--   data where each chunk represents a single line. Note that, if you have
--   unknown<i>untrusted input, this function is </i>unsafe/, since it
--   would allow an attacker to form lines of massive length and exhaust
--   memory.
--   
--   Since 1.0.0
linesUnboundedC :: (Monad m, IsSequence seq, Element seq ~ Char) => Conduit seq m seq

-- | Same as <tt>linesUnbounded</tt>, but for ASCII/binary data.
--   
--   Since 1.0.0
linesUnboundedAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => Conduit seq m seq

-- | Generally speaking, yielding values from inside a Conduit requires
--   some allocation for constructors. This can introduce an overhead,
--   similar to the overhead needed to represent a list of values instead
--   of a vector. This overhead is even more severe when talking about
--   unboxed values.
--   
--   This combinator allows you to overcome this overhead, and efficiently
--   fill up vectors. It takes two parameters. The first is the size of
--   each mutable vector to be allocated. The second is a function. The
--   function takes an argument which will yield the next value into a
--   mutable vector.
--   
--   Under the surface, this function uses a number of tricks to get high
--   performance. For more information on both usage and implementation,
--   please see:
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/vectorbuilder</a>
--   
--   Since 1.0.0
vectorBuilderC :: (PrimMonad base, MonadBase base m, Vector v e, MonadBase base n) => Int -> ((e -> n ()) -> Sink i m r) -> ConduitM i (v e) m r

-- | Consume a source in a way piecewise defined by a controlling stream.
--   The latter will be evaluated until it terminates.
--   
--   <pre>
--   &gt;&gt;&gt; let f a s = liftM (:s) $ mapC (*a) =$ CL.take a
--   
--   &gt;&gt;&gt; reverse $ runIdentity $ yieldMany [0..3] $$ mapAccumS f [] (yieldMany [1..])
--   [[],[1],[4,6],[12,15,18]] :: [[Int]]
--   </pre>
mapAccumS :: Monad m => (a -> s -> Sink b m s) -> s -> Source m b -> Sink a m s

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
--   
--   Since 1.0.0
peekForever :: Monad m => ConduitM i o m () -> ConduitM i o m ()

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)
liftIO :: MonadIO m => IO a -> m a

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: (* -> *) -> * -> *)
lift :: (MonadTrans t, Monad m) => m a -> t m a
class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase (b :: * -> *) (m :: * -> *) | m -> b
liftBase :: MonadBase b m => b  -> m 

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: * -> *)
throwM :: (MonadThrow m, Exception e) => e -> m a
class MonadBase b m => MonadBaseControl (b :: * -> *) (m :: * -> *) | m -> b

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack included a <tt>ResourceT</tt> can be an
--   instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a
--   <tt>MonadBaseControl IO m</tt> monad, which allows control operations
--   to be lifted. A <tt>MonadResource</tt> does not have this requirement.
--   This means that transformers such as <tt>ContT</tt> can be an instance
--   of <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will
--   need to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class (MonadThrow m, MonadIO m, Applicative m, MonadBase IO m) => MonadResource (m :: * -> *)

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <tt>runResourceT</tt>). Actions may be registered via
--   <tt>register</tt>, or resources may be allocated atomically via
--   <tt>allocate</tt>. <tt>allocate</tt> corresponds closely to
--   <tt>bracket</tt>.
--   
--   Releasing may be performed before exit via the <tt>release</tt>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Since 0.3.0
data ResourceT (m :: * -> *) a :: (* -> *) -> * -> *

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to
--   <a>resourceForkIO</a>. If multiple threads are sharing the same
--   collection of resources, only the last call to <tt>runResourceT</tt>
--   will deallocate the resources.
--   
--   Since 0.3.0
runResourceT :: MonadBaseControl IO m => ResourceT m a -> m a
withAcquire :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a :: * -> *
Identity :: a -> Identity a
runIdentity :: Identity a -> a
