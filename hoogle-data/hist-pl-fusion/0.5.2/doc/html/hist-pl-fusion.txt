-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Merging historical dictionary with PoliMorf
--   
--   The library provides functions for merging historical dictionary with
--   PoliMorf morphological dictionary.
@package hist-pl-fusion
@version 0.5.2

module NLP.HistPL.Fusion

-- | A unique identifier among entries with the same <tt>keyForm</tt>.
type UID = Int

-- | Part of speech.
type POS = Text

-- | Word form.
type Word = Text

-- | Base form.
type Base = Text

-- | Is the word form a base form?
type IsBase = Bool

-- | Dictionary keys represent base forms and rules transform base forms to
--   their corresponding word forms. Info <tt>a</tt> is assigned to every
--   lexeme and info <tt>b</tt> to every word form.
type BaseDAWG i a b = DAWG i a b

-- | Dictionary keys represent word forms and rules transform word forms to
--   their corresponding base forms. Info <tt>a</tt> is assigned to every
--   lexeme and info <tt>b</tt> to every word form.
type FormDAWG i a b = DAWG i a b

-- | Bilateral dictionary.
data Bila i a b
Bila :: BaseDAWG i a b -> FormDAWG i a b -> Bila i a b
baseDAWG :: Bila i a b -> BaseDAWG i a b
formDAWG :: Bila i a b -> FormDAWG i a b

-- | Make bilateral dictionary from a list of (base form, ID, additional
--   lexeme info, word form, additional word form info) tuples.
mkBila :: (Ord i, Ord a, Ord b) => [(Base, i, a, Word, b)] -> Bila i a b

-- | Identify entries which contain given word form.
withForm :: Ord i => Bila i a b -> Word -> LexSet i a b

-- | PoliMorf dictionary in a bilateral form.
type Poli = Bila POS () ()

-- | PoliMorf dictionary entry.
type PLex = Lex POS () ()

-- | Set of PoliMorf dictionary entries.
type PLexSet = LexSet POS () ()

-- | Make bilateral dictionary from PoliMorf.
mkPoli :: [Entry] -> Poli

-- | A function which determines entries from a bilateral dictionary
--   corresponing to a given historical lexeme.
type Corresp = Poli -> LexEntry -> PLexSet

-- | Build <a>Corresp</a> function form individual components.
buildCorresp :: Core -> Filter -> Choice -> Corresp

-- | We provide three component types, <a>Core</a>, <a>Filter</a> and
--   <a>Choice</a>, which can be combined together using the
--   <a>buildCorresp</a> function to construct a <a>Corresp</a> function.
--   The first one, <a>Core</a>, is used to identify a list of potential
--   sets of lexemes. It is natural to define the core function in such a
--   way because the task of determining corresponding lexemes can be
--   usually divided into a set of smaller tasks of the same purpose. For
--   example, we may want to identify <a>LexSet</a>s corresponding to
--   individual word forms of the historical lexeme.
type Core = Poli -> LexEntry -> [PLexSet]

-- | Function which can be used to filter out lexemes which do not satisfy
--   a particular predicate. For example, we may want to filter out lexemes
--   with incompatible POS value.
type Filter = LexEntry -> PLex -> Bool

-- | The final choice of lexemes. Many different strategies can be used
--   here sum of the sets, intersection, or voting.
type Choice = [PLexSet] -> PLexSet

-- | Identify <a>LexSet</a>s corresponding to individual word forms of the
--   historical lexeme using the <a>withForm</a> function.
byForms :: Core

-- | Filter out lexemes with POS value incompatible with the set of POS
--   values assigned to the historical lexeme.
posFilter :: Filter

-- | Sum of sets of lexemes.
sumChoice :: Choice
instance (Show i, Show a, Show b) => Show (Bila i a b)
instance (Eq i, Eq a, Eq b) => Eq (Bila i a b)
instance (Ord i, Ord a, Ord b) => Ord (Bila i a b)
