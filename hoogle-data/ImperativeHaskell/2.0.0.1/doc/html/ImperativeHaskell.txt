-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for writing Imperative style haskell.
--   
--   A monad that uses GADTs and continuations to replicate what it is like
--   to program in an imperative language like C, Java or Go with
--   <a>return</a>, <a>for</a>, <a>break</a>, <a>continue</a>, and mutable
--   references.
--   
--   In Version 2:
--   
--   <ul>
--   <li>Single return function: <tt>return'</tt></li>
--   <li>A Go language style <tt>defer'</tt> primitive.</li>
--   <li>Proper compiler errors when <tt>break'</tt> and <tt>continue'</tt>
--   are used incorrectly</li>
--   <li><i>Note</i>: Version 2 has a very different internal structure
--   from version 1, and thus there will likely be type signature
--   conflicts.</li>
--   </ul>
--   
--   For more information see:
--   
--   <ul>
--   <li>Examples on github
--   <a>http://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs</a></li>
--   <li>The relevant blog post
--   <a>http://kormacode.blogspot.com/2011/11/c-style-haskell_10.html</a></li>
--   </ul>
@package ImperativeHaskell
@version 2.0.0.1


-- | A module which defines the monad for ImperativeHaskell, and some
--   control operator to interact with <a>MIO</a>
module Control.Monad.Imperative.Internals

-- | <tt><a>modifyOp</a></tt> makes a modification assignment operator out
--   of a binary haskell function. The suggested use is to replicate
--   functionality of assignments like <tt>-=</tt> or <tt>%=</tt> from C
--   style languages.
modifyOp :: (HasValue r (V TyVar r) i, HasValue r (V k r) i) => (a -> b -> a) -> V TyVar r a -> V k r b -> MIO i r ()

-- | <tt><a>if'</a>(check) act</tt> only performs <tt>act</tt> if
--   <tt>check</tt> evaluates to true it is specifically a value in its
--   argument.
if' :: (HasValue r (V b r) i, HasValue r valt i) => V b r Bool -> valt () -> MIO i r ()

-- | <tt><a>for'</a>(init, check, incr)</tt> acts like its imperative
--   <tt>for</tt> counterpart
for' :: (CState i, HasValue r (V b r) i, HasValue r valt TyInLoop) => (MIO i r irr1, V b r Bool, MIO i r irr2) -> valt () -> MIO i r ()

-- | <tt><a>while'</a>(check)</tt> acts like its imperative <tt>while</tt>
--   counterpart.
while' :: (HasValue r (V b r) i, HasValue r (V b r) TyInLoop, HasValue r valt TyInLoop, CState i) => V b r Bool -> valt () -> MIO i r ()

-- | <tt><a>break'</a></tt> exists the current loop.
break' :: MIO TyInLoop r ()

-- | <a>continue'</a> continues the current loop, passing over any control
--   flow that is defined.
continue' :: MIO TyInLoop r ()

-- | <a>defer'</a> executes the given action (or value) before the function
--   returns.
defer' :: HasValue r valt TyInFunc => valt a -> MIO i r ()

-- | <tt><a>function</a> foo</tt> takes an ImperativeMonad action and
--   removes it from it's specific function context, specifically making it
--   applicable in the body of other functions.
function :: MIO TyInFunc a a -> MIO i b a

-- | <a>new</a> constructs a new reference to the specified pure value
new :: HasValue r (V TyVar r) i => a -> MIO i r (V TyVar r a)

-- | <a>auto</a> should just be used where the type can be automatically
--   infered and we don't need an initial value Use caution, as it is
--   simply an alternate name for <a>undefined</a>
auto :: a

-- | <tt><a>runImperative</a></tt> takes an MIO action as returned by a
--   function, and lifts it into IO.
runImperative :: MIO TyInFunc a a -> IO a

-- | <tt><a>io</a> action</tt> takes a haskell <a>IO</a> <tt>action</tt>
--   and makes it useable from within the MIO monad.
io :: IO a -> MIO i r a
data V b r a
Lit :: a -> V TyVal r a
C :: MIO i r (V b r a) -> V (TyComp i b) r a
data MIO i r a
data TyInLoop
data TyInFunc
data TyVar
data TyVal
data TyComp i v

-- | <tt>variable <a>=:</a> value</tt> executes <tt>value</tt> and writes
--   it to the location pointed to by <tt>variable</tt>
(=:) :: (HasValue r valt i, HasValue r (V TyVar r) i) => V TyVar r a -> valt a -> MIO i r ()

-- | <tt>(<a>&amp;</a>)a</tt> gets a reference/pointer to the variable
--   specified
(&) :: V TyVar r a -> V TyVar s a

-- | Although the functional dependency <tt>b -&gt; i</tt> is declared, it
--   does not do anything useful.
class HasValue r b i | b -> r i
val :: HasValue r b i => b a -> MIO i r a
class CState i
return' :: (CState i, HasValue r (V a r) i) => V a r r -> MIO i r (RetTy i r)
instance Monad (MIO i r)
instance MonadCont (MIO i r)
instance MonadIO (MIO i r)
instance IsString s => IsString (V TyVal r s)
instance Num a => Num (V TyVal r a)
instance Show a => Show (V TyVal r a)
instance Eq a => Eq (V TyVal r a)
instance CState TyInLoop
instance CState TyInFunc
instance HasValue r IO i
instance HasValue r (MIO i r) i
instance HasValue r (V b r) a => HasValue r (V (TyComp a b) r) a
instance HasValue r (V TyVal r) i
instance HasValue r (V TyVar r) i


-- | Some predefined operators for the imperative monad.
module Control.Monad.Imperative.Operators
(+=:, -=:, *=:) :: (HasValue r (V k r) i, Num b) => V TyVar r b -> V k r b -> MIO i r ()
(%=:) :: (HasValue r (V k r) i, Integral b) => V TyVar r b -> V k r b -> MIO i r ()
(<., <=., >=., >.) :: (Ord c, HasValue r (V b1 r) i, HasValue r (V b2 r) i) => V b1 r c -> V b2 r c -> V (TyComp i TyVal) r Bool
(==.) :: (Eq c, HasValue r (V b1 r) i, HasValue r (V b2 r) i) => V b1 r c -> V b2 r c -> V (TyComp i TyVal) r Bool
(+., *., -.) :: (Num c, HasValue r (V b1 r) i, HasValue r (V b2 r) i) => V b1 r c -> V b2 r c -> V (TyComp i TyVal) r c
(%.) :: (Integral c, HasValue r (V b1 r) i, HasValue r (V b2 r) i) => V b1 r c -> V b2 r c -> V (TyComp i TyVal) r c
(/.) :: (HasValue r (V b1 r) i, HasValue r (V b2 r) i, Fractional c) => V b1 r c -> V b2 r c -> V (TyComp i TyVal) r c
(&&., ||.) :: (HasValue r (V b1 r) i, HasValue r (V b2 r) i) => V b1 r Bool -> V b2 r Bool -> V (TyComp i TyVal) r Bool
(~.) :: HasValue r (V b r) i => V b r Bool -> V (TyComp i TyVal) r Bool

-- | <tt><a>liftOp2</a> f</tt> turns a pure function into one which gets
--   executes its arguments and returns their value as a function. It is
--   defined using <tt>liftOp</tt>.
liftOp2 :: (HasValue r (V b1 r) i, HasValue r (V b2 r) i) => (a -> b -> c) -> V b1 r a -> V b2 r b -> V (TyComp i TyVal) r c


-- | A module which defines a function <a>liftOp</a> which coverts pure
--   functions into reference taking functions.
module Control.Monad.Imperative.FunctionFactory
liftOp :: Name -> Q Exp


-- | A front end for the ImperativeMonad
module Control.Monad.Imperative
