-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Offline Music Manipulation And Generation EDSL
--   
--   HOMMAGE is the successor of the Haskell Sound Lib.
--   <a>http://substitut-fuer-feinmotorik.net/projects/haskellommage/introduction</a>
@package hommage
@version 0.0.5


-- | This module contains a datatype <a>Field</a> and sone type classes. It
--   is used to construct record-like datatypes.
module Sound.Hommage.Parameter

-- | A <tt> Field record field </tt> is an interface to access a type <tt>
--   field </tt> which is part of a type <tt> record </tt>. A <a>Field</a>
--   is used to access and modify subtypes ("datafields") of a record-like
--   datastructure. In this module, a right-associative pair structure is
--   taken as record-type with "datafields" in the fst parts of the pairs.
data Field c a
Field :: (c -> a) -> ((a -> a) -> c -> c) -> Field c a
getField :: Field c a -> c -> a
setField :: Field c a -> (a -> a) -> c -> c
(<>) :: Field a b -> Field c a -> Field c b
fstField :: Field (a, b) a
sndField :: Field (a, b) b
data UpdateField c
(:=) :: Field c a -> a -> UpdateField c
(:$) :: Field c a -> (a -> a) -> UpdateField c
If :: (CheckField c) -> [UpdateField c] -> [UpdateField c] -> UpdateField c
data CheckField c
(:?) :: Field c a -> (a -> Bool) -> CheckField c
And :: [CheckField c] -> CheckField c
Or :: [CheckField c] -> CheckField c
updateField :: UpdateField c -> c -> c
checkField :: CheckField c -> c -> Bool
applyField :: [UpdateField c] -> c -> c
withField :: [UpdateField a] -> (a -> b) -> a -> b
data Group c a
Group :: (c -> Maybe a) -> (a -> c) -> Group c a
isGroup :: Group c a -> c -> Maybe a
mkGroup :: Group c a -> a -> c
leftGroup :: Group (Either a b) a
rightGroup :: Group (Either a b) b
(><) :: Group a b -> Group c a -> Group c b
data LM a b m
(:>>) :: m a -> b m -> LM a b m

-- | The correct type is: <tt> data NilM (m :: * -&gt; *) = NilM </tt> .
--   (But Haddock rejects this definition. GHC will need it) data NilM m =
--   NilM
data NilM m :: (* -> *)
NilM :: NilM
class PushFields m
pushFields :: (PushFields m) => m (Field c) -> m (Field (x, c))
class ToFields a r
toFields :: (ToFields a r) => a -> r (Field a)
class PushGroups m
pushGroups :: (PushGroups m) => m (Group c) -> m (Group (Either x c))
class ToGroups a r
toGroups :: (ToGroups a r) => a -> r (Group a)
instance (ToGroups b b', PushGroups b') => ToGroups (Either a b) (LM a b')
instance ToGroups () NilM
instance (PushGroups b) => PushGroups (LM a b)
instance PushGroups NilM
instance (PushFields b', ToFields b b') => ToFields (a, b) (LM a b')
instance ToFields () NilM
instance (PushFields b) => PushFields (LM a b)
instance PushFields NilM

module Sound.Hommage.Filter
lowpass :: [Double] -> [Double] -> [Double]
highpass :: [Double] -> [Double] -> [Double]
bandpass :: [Double] -> [Double] -> [Double] -> [Double]
stretchpass :: FilterSpec -> [Double] -> [Double]
morphpass :: FilterSpec -> FilterSpec -> [Double] -> [Double]

-- | Filtering starts at coeff nr 0 and value 0.0 (constant coeff is always
--   zero). The elements in FilterSpec define the next value and how many
--   coeffs it takes to reach this value.
type FilterSpec = [(Int, Double)]

-- | 0..1: lower, 1..: higher
shiftFilterSpec :: Double -> FilterSpec -> FilterSpec

-- | Converting a FilterSpec to a list of 512 Doubles
filterSpecToList :: FilterSpec -> [Double]

-- | Converting and interpolating a sequence of FilterSpecs to a list of
--   lists. The first elemet of the tuple, an Int, describes how many lists
--   it takes to reach the given FilterSpec.
filterSpecsToLists :: [(Int, FilterSpec)] -> [[Double]]
interpolFilterLists :: [Double] -> [Double] -> Double -> [Double]

-- | for filter coefficient number: (0.0 .. 1.0) -&gt; (1.0 .. 512.0)
ffreq :: Double -> Double

-- | floor of <a>ffreq</a>
ffreqi :: Double -> Int

-- | the resulting list is 1 / 512 as long as the input list. 512 elements
--   are read and their average is the next output value.
average512 :: [Double] -> [Double]
lowpassFS :: Double -> Double -> FilterSpec
highpassFS :: Double -> Double -> FilterSpec

-- | range, curve, cutoff
bandpassFS :: Double -> Double -> Double -> FilterSpec
lowp0FS :: Double -> FilterSpec
lowp1FS :: Double -> FilterSpec
bandp0FS :: Double -> FilterSpec
bandp1FS :: Double -> FilterSpec
highp0FS :: Double -> FilterSpec
highp1FS :: Double -> FilterSpec


-- | This module contains some functions and datatypes for envelopes. An
--   envelope in generall is a kind of controll signal that modulates (for
--   example) the volume of a sound in a non-periodic way (getting loud at
--   the beginning and fading out at the end...). It is also used to
--   controll the duration of a sound, since (here) envelopes always
--   produce finite signals.
module Sound.Hommage.Envelope
type Env = Int -> [Double]
runEnv :: [(Env, EnvLength)] -> Env
(<?>) :: (IsEnv a) => a -> EnvLength -> (Env, EnvLength)
class IsEnv a
toEnv :: (IsEnv a) => a -> Env

-- | Takes an absolute total length and a list of EnvLengths. Each
--   <a>EnvLength</a> is mapped to its length with respect to the total
--   length and a resuming length that is the result of <tt> total length -
--   (all fixed lengths + all relative lengths) </tt>. This resuming
--   lengths is distributed to the flexible lengths.
calculateEnvLengths :: Int -> [EnvLength] -> [Int]

-- | <a>EnvLength</a> represents the length of a segment of an Envelope.
data EnvLength

-- | A fixed length.
Abs :: Int -> EnvLength

-- | A fixed length that is not subtracted from the total time.
Abs_ :: Int -> EnvLength

-- | A flexible length. Resuming length is distributed to all flexible
--   lengths proportionally to its value.
Flex :: Double -> EnvLength

-- | A length relative to the total length.
Rel :: (Ratio Int) -> EnvLength

-- | A relative length that is not subtracted from the total time.
Rel_ :: (Ratio Int) -> EnvLength

-- | The four components of <a>ADSR</a> are:
--   
--   <ul>
--   <li>Attack (time to reach value 1.0, starting from 0.0)</li>
--   <li>Decay (time to reach sustain level)</li>
--   <li>Sustain (level to hold until note is released, should be a value
--   between 0.0 and 1.0)</li>
--   <li>Release (time to reach value 0.0 after note is released)</li>
--   </ul>
--   
--   time is measured in sample points, 44100 is one second.
type ADSR = (Int, Int, Double, Int)

-- | A linear or a cosinus-like shape
data EnvShape
Linear :: EnvShape
CosLike :: EnvShape
data EnvMode

-- | Sustain value is kept until duration is over, Release part is
--   appended.
HoldS :: EnvMode

-- | Envelope has given duration by fitting only duration of constant
--   Sustain level.
FitS :: EnvMode

-- | Attack, Decay and Released are together stretched to given duration.
FitADR :: EnvMode

-- | Playing an ADSR
playADSR :: EnvMode -> EnvShape -> ADSR -> Int -> [Double]
data Interpolate
Interpolate :: EnvShape -> (Double, Double) -> Interpolate
data Constant
Constant :: Double -> Constant

-- | produces a line with given length that starts with fst value and ends
--   with snd value
interpolate :: (Fractional a) => (a, a) -> Int -> [a]

-- | produces a curve with given length that starts with fst value and ends
--   with snd value. this curve has the shape of a half cosinus curve
--   (values for 0 to PI).
interpolate_cos :: (Floating a) => (a, a) -> Int -> [a]
instance Eq EnvMode
instance Read EnvMode
instance Show EnvMode
instance Eq EnvShape
instance Read EnvShape
instance Show EnvShape
instance IsEnv Constant
instance IsEnv Interpolate
instance IsEnv Env

module Sound.Hommage.WavFile
writeDataFile :: (Storable a) => FilePath -> [a] -> IO ()
readDataFile :: (Storable a) => FilePath -> IO [a]
openDataFile :: (Storable a) => FilePath -> [a]
writeWavFile :: FilePath -> Either [Int16] [(Int16, Int16)] -> IO ()
writeWavFileMono :: FilePath -> [Int16] -> IO ()
writeWavFileStereo :: FilePath -> [(Int16, Int16)] -> IO ()
readWavFile :: FilePath -> IO (Either [Int16] [(Int16, Int16)])
openWavFile :: FilePath -> Either [Int16] [(Int16, Int16)]
writeWavFiles :: FilePath -> String -> [Either [Int16] [(Int16, Int16)]] -> IO ()
wavInt16ToDouble :: Int16 -> Double
wavDoubleToInt16 :: Double -> Int16
readArrayFromFile :: (Storable a) => HeaderSize -> FilePath -> IO (StorableArray Int a, Int)
writeArrayToFileWithHeader :: (MArray StorableArray a IO, Storable a) => HeaderFun -> FilePath -> StorableArray Int a -> IO ()
writeArrayToFile :: (MArray StorableArray a IO, Storable a) => FilePath -> StorableArray Int a -> IO ()
openSingleInputFile :: (Storable a) => Int -> HeaderSize -> FilePath -> IO (IO (), IO (Maybe a), Int)
openSingleOutputFile :: (Storable a) => Int -> FilePath -> IO (IO (), a -> IO ())
openSingleInputWavFile :: Int -> FilePath -> IO (IO (), Either (IO (Maybe Int16)) (IO (Maybe (Int16, Int16))), Int)
openSingleOutputWavFileMono :: Int -> FilePath -> IO (IO (), Int16 -> IO ())
openSingleOutputWavFileStereo :: Int -> FilePath -> IO (IO (), (Int16, Int16) -> IO ())
openInputFile :: (Storable a) => HeaderSize -> FilePath -> Int -> IO (IO (), StorableArray Int a -> Int -> IO Int, Int)
openOutputFile :: (Storable a) => FilePath -> IO (IO (), StorableArray Int a -> Int -> IO ())
openOutputFileWithHeader :: (Storable a) => HeaderFun -> FilePath -> IO (IO (), StorableArray Int a -> Int -> IO ())
openInputWavFile :: FilePath -> IO (IO (), StorableArray Int Int16 -> Int -> IO (), Int, Bool)
openOutputWavFileMono :: FilePath -> IO (IO (), StorableArray Int Int16 -> Int -> IO ())
openOutputWavFileStereo :: FilePath -> IO (IO (), StorableArray Int Int16 -> Int -> IO ())

-- | The first Action is applied after opening the file. Then the data
--   bytes are written. The second Action is then called with the number of
--   bytes of the data. It must close the handle.
type HeaderFun = (Handle -> IO (), Handle -> Int -> IO ())
type HeaderSize = Int
noHeader :: HeaderFun

-- | The first Action writes the Header of the wav-file. Then the wav-data
--   is written. The second action moves the Handle to the positions where
--   the lenght of the wav-file are encoded (in the header) and writes the
--   right number, which is unknown before all data is written. Afterwards
--   it closes the file.
wavHeaderFunMono :: HeaderFun
wavHeaderFunStereo :: HeaderFun
wavHeaderSize :: HeaderSize
initWriteWavHeaderMono :: Handle -> IO ()
initWriteWavHeaderStereo :: Handle -> IO ()
initReadWavHeader :: Handle -> IO (Maybe (Bool, Int, Int, Int))
closeWriteWavHeader :: Handle -> Int -> IO ()
encode :: Int -> String
decode :: String -> Int
encodeWavLengt :: Int -> (String, String)
initWavHeaderMono :: [Char]
initWavHeaderStereo :: [Char]
sizeOfArrayElements :: (Storable a) => StorableArray Int a -> Int
inferSizeOfArrayElements :: (Storable a) => (StorableArray Int a -> IO Int) -> StorableArray Int a -> Int
inferSizeOfArrayElements' :: (Storable a) => (StorableArray Int a -> Int -> IO ()) -> StorableArray Int a -> Int

module Sound.Hommage.Midi
data MidiFile

-- | Some parallel (synchronous) MidiTracks.
MidiSync :: Ticks -> [MidiTrack] -> MidiFile

-- | A single MidiTrack. (Seems not to work yet)
MidiSingle :: Ticks -> MidiTrack -> MidiFile

-- | Some asynchronous MidiTracks. (Seems not to work yet)
MidiAsync :: Ticks -> [MidiTrack] -> MidiFile

-- | Writes a <a>MidiFile</a> to a File.
writeMidiFile :: FilePath -> MidiFile -> IO ()

-- | Ticks per Quarter. For some unknown reasons it does not work with any
--   value. 96 seems to be ok.
type Ticks = Int
data MidiNote

-- | A note with pitch and volume
MidiNote :: Chan -> MidiValue -> MidiValue -> MidiNote

-- | Controllernumber and value
MidiCtrl :: Chan -> MidiValue -> MidiValue -> MidiNote

-- | A Midi-Channel (0-15)
type Chan = Word8

-- | A Midi-Value (0-127)
type MidiValue = Word8

-- | A kind of extended MidiTrack type, that allows delta-times without
--   events (will be summed up by converting to <a>MidiTrack</a>).
type MidiMusic = [(Delta, Maybe MidiEvent)]

-- | Creates a note or controller event with given length (relative to
--   <a>Ticks</a>). The length means the delta-time between note-on and
--   note-off resp. the time after the controller event.
noteMidiMusic :: Int -> MidiNote -> MidiMusic

-- | A pause with given length.
restMidiMusic :: Int -> MidiMusic

-- | Sequencial composition of <a>MidiMusic</a>.
appendMidiMusic :: MidiMusic -> MidiMusic -> MidiMusic

-- | Parallel composition of <a>MidiMusic</a>.
mergeMidiMusic :: MidiMusic -> MidiMusic -> MidiMusic

-- | Converts a <a>MidiMusic</a> to a <a>MidiTrack</a>.
runMidiMusic :: MidiMusic -> MidiTrack

-- | A sequence of MidiEvents with a delta-time which means the number of
--   ticks before the event happens (relative to the last event).
type MidiTrack = [(Delta, MidiEvent)]
type Delta = Int
data MidiEvent
MidiNoteOff :: !Chan -> !MidiValue -> !MidiValue -> MidiEvent
MidiNoteOn :: !Chan -> !MidiValue -> !MidiValue -> MidiEvent
MidiKeyAfter :: !Chan -> !MidiValue -> !MidiValue -> MidiEvent
MidiControl :: !Chan -> !MidiValue -> !MidiValue -> MidiEvent
MidiEndOfTrack :: MidiEvent
encodeMidiFile :: MidiFile -> [Word8]
midiHeaderSync :: [Word8]
midiHeaderSingle :: [Word8]
midiHeaderAsync :: [Word8]
encodeMidiTrack :: MidiTrack -> [Word8]
encodeDelta :: Int -> [Word8]
encodeMidiDeltaEvent :: (Delta, MidiEvent) -> [Word8]
encodeEvent :: MidiEvent -> [Word8]
lastByte :: Int -> Word8
nextByte :: Int -> Int
toBytes :: Int -> Int -> [Word8]

module Sound.Hommage.Notation

-- | The duration (of a note, e. g).
type Dur = Ratio Int

-- | Calculates the absolute duration by dividing the numerator with the
--   denominator. Because of rounding error this makes only sense if the
--   result is a relative big number.
absDur :: Dur -> Int
class IsDur d
durFrom :: (IsDur d) => d -> Dur
durUpdate :: (IsDur d) => (Dur -> Dur) -> d -> d
newtype (IsDur d) => WithDur d a
WithDur :: (d -> a) -> WithDur d a
unWithDur :: WithDur d a -> d -> a

-- | A <a>Notation</a> is a constant, tree-like structure that represents a
--   musical notation. It has a type parameter for flexible usage reasons.
data Notation a

-- | A note with given duration and a value of type <tt>a</tt>.
Note :: Dur -> a -> Notation a

-- | A rest with given duration.
Rest :: Dur -> Notation a

-- | Sequential composition of two notations.
(:+:) :: Notation a -> Notation a -> Notation a

-- | Parallel composition of two notations.
(:=:) :: Notation a -> Notation a -> Notation a

-- | Stretches the duration of the sub-music by given factor.
Stretch :: Dur -> (Notation a) -> Notation a

-- | A <a>Notation</a> can be interpreted if the contained type is an
--   instance of class <a>Musical</a>.
runNotation :: (Musical m) => Notation m -> m
runNotationWith :: (Musical m) => (a -> m) -> Notation a -> m

-- | A type/structure that can be stretched.
class Stretchable a
stretch :: (Stretchable a) => Dur -> a -> a

-- | Types/structures that can be composed in two ways, parallel and
--   sequent.
class Arrangeable a
parallel :: (Arrangeable a) => a -> a -> a
sequent :: (Arrangeable a) => a -> a -> a

-- | Instances of class <a>Musical</a> must be <a>Stretchable</a>,
--   <a>Arrangeable</a> and they must implement the method <a>rest</a>.
class (Stretchable a, Arrangeable a) => Musical a
rest :: (Musical a) => a
rest0 :: (Musical a) => a
(-=-) :: (Arrangeable a) => a -> a -> a
(->-) :: (Arrangeable a) => a -> a -> a

-- | A sequence of sounds
line :: (Musical a) => [a] -> a

-- | A sequence of sounds that will be stretched to length=1
line' :: (Musical a) => [a] -> a
chord :: (Musical a) => [a] -> a

-- | Composes the notations sequentially and stretches them proportionally.
proportional :: (Musical a) => (Int, Int) -> a -> a -> a

-- | A convenient function to write a set of midi notations to a
--   synchronous MIDI-file. NOTE: For unknown reasons not any Ticks value
--   seemes to work. This function uses 96 Ticks per quarter.
writeMidiSyncNotation :: FilePath -> [Notation MidiNote] -> IO ()

-- | A <tt> Notation MidiNote </tt> can be interpreted using
--   <a>runNotationWith</a> and <a>midi</a>.
midi :: (IsDur d) => MidiNote -> WithDur d MidiMusic
midi' :: (IsDur d) => WithDur d MidiNote -> WithDur d MidiMusic
midiSyncFile :: Ticks -> [WithDur Dur MidiMusic] -> MidiFile

-- | Creates a note with length 1. Is a synonym for <tt>Note (1%1)</tt>
note :: a -> Notation a

-- | <a>Notation</a> is instance of the class Functor.
mapNotation :: (a -> b) -> Notation a -> Notation b

-- | <a>Notation</a> is instance of the class Monad. Joining will replace
--   every (outer) Note by its contained (inner) Notation. The inner
--   Notation will be stretched by the duration of the (outer) Note.
joinNotation :: Notation (Notation a) -> Notation a

-- | Replaces any Note that contains Nothing by a rest (with same
--   duration).
unmaybeNotation :: Notation (Maybe a) -> Notation a

-- | Calculates the (relative) duration of a <a>Notation</a> (Must be
--   finite!).
durationNotation :: Notation a -> Ratio Int

-- | Calculates the offset for each note.
positionNotation :: Notation a -> Notation (Dur, a)

-- | Reverses a <a>Notation</a> (Must be finite!).
reverseNotation :: Notation a -> Notation a

-- | Takes the beginning of <a>Notation</a>, result has the given duration
--   if possible or is shorter otherwise. Notes that overlap with the end
--   of duration are not taken but replaced by the (fitted) rests.
takeNotation :: Ratio Int -> Notation a -> Notation a

-- | Drops the beginning of <a>Notation</a>. Notes that would be split are
--   replaced by fitted rests.
dropNotation :: Ratio Int -> Notation a -> Notation a

-- | Replaces notes where the predicate fails with rests. filterNotation ::
--   (a -&gt; Bool) -&gt; Notation a -&gt; Notation a
filterNotation :: (Musical (m a), Monad m) => (a -> Bool) -> m a -> m a
filterNotation' :: (Musical (m a), Musical (m b), Monad m) => (a -> Maybe b) -> m a -> m b

-- | A parallel composition of a sequence of values and a Notation Each
--   value of the sequence has the same given duration. Every Note is
--   updated by a function that gets the actual value of the sequence.
--   NOTE: This function is not tested yet!
sequenceNotation :: (a -> b -> c) -> Dur -> [a] -> Notation b -> Notation c
instance (IsDur d) => Musical (WithDur d MidiMusic)
instance Arrangeable MidiMusic
instance Monad Notation
instance Musical (Notation a)
instance Arrangeable (Notation a)
instance Stretchable (Notation a)
instance Functor Notation
instance IsDur Dur
instance (Musical a) => Musical (s -> a)
instance (Arrangeable a) => Arrangeable (s -> a)
instance (Stretchable a) => Stretchable (s -> a)
instance (IsDur d, Arrangeable a) => Arrangeable (WithDur d a)
instance (IsDur d) => Stretchable (WithDur d a)

module Sound.Hommage.Misc
for :: (Monad m) => a -> (a -> Bool) -> (a -> a) -> (a -> m b) -> m ()
for' :: (Monad m) => a -> (a -> Bool) -> (a -> a) -> b -> (a -> b -> m b) -> m b

-- | a pseudo-strict <a>map</a> version. does not touch the elements but
--   reconstructs the whole list structure before the function is applied
--   to the value
map_ :: (a -> b) -> [a] -> [b]

-- | a pseudo-strict <a>foldr</a> version. does not touch the elements but
--   reconstructs the whole list structure before the function is applied
--   to the values.
foldr_ :: (a -> b -> b) -> b -> [a] -> b

-- | Similar to <a>zipWith</a>, but the result has the length of the longer
--   input list.
merge :: (a -> a -> a) -> [a] -> [a] -> [a]
mergeSet :: ([a] -> b) -> [[a]] -> [b]
uneitherlist :: [Either a b] -> ([a], [b])
walk :: ([a] -> [b]) -> [a] -> ([a], [b])
appendmaps :: [[a] -> [b]] -> [a] -> [b]
appendmaps' :: [[a] -> [b]] -> [a] -> [[b]]
qsort :: (a -> a -> Bool) -> [a] -> [a]
qsortM :: (Monad m) => (a -> a -> m Bool) -> [a] -> m [a]
head_opt :: a -> [a] -> a

-- | the given function must create a filepath using the Int-argument. The
--   filepath must be different for different arguments. <a>newFilePath</a>
--   works like G dels mu-operator and terminates only if the filepath does
--   not exist.
newFilePath :: (Int -> FilePath) -> IO FilePath
inList :: IO (Maybe a -> IO (Maybe b)) -> [a] -> [b]
inList' :: IO (a -> IO b) -> [a] -> [b]
inList'' :: IO (a -> IO (Maybe b)) -> [a] -> [b]
toList :: IO (IO a) -> [a]
toList' :: IO (IO (Maybe a)) -> [a]
inListE :: IO (Either (Maybe a -> IO (Maybe b)) (Maybe a -> IO (Maybe c))) -> [a] -> Either [b] [c]
inListE' :: IO (Either (a -> IO b) (a -> IO c)) -> [a] -> Either [b] [c]
inListE'' :: IO (Either (a -> IO (Maybe b)) (a -> IO (Maybe c))) -> [a] -> Either [b] [c]
toListE :: IO (Either (IO a) (IO b)) -> Either [a] [b]
toListE' :: IO (Either (IO (Maybe a)) (IO (Maybe b))) -> Either [a] [b]


-- | This module imports the C-functions for a Fast Fourier Transform and
--   encapsulates them in list-mapping functions. (At first it was a DFT
--   algoritm which I changed, but I didn'd change all the names of the
--   functions, so it is called dft...) The functionality of this module is
--   used for filtering audio data, i. e. for building audio filters.
module Sound.Hommage.DFTFilter

-- | (Fast) Fourier Transformation.
dftanalyse :: [Double] -> [(Complex Double)]

-- | Inverse (Fast) Fourier Transformation
dftsynthese :: [Complex Double] -> [Double]

-- | (Fast) Fourier Transformation and Inverse with an additional argument
--   with sublists of factors to weight the coefficients. See
--   <a>mkCoeffMap</a> for a decription of that argument.
dftfilter :: [Double] -> [Double] -> [Double]

-- | (Fast) Fourier Transformation and Inverse with a buffer-mapping action
--   for filtering.
dftfilterBy :: IO (CoeffMap ()) -> [Double] -> [Double]

-- | (Fast) Fourier Transformation and Inverse with a buffer-mapping action
--   for filtering.
dftfilterBy' :: s -> IO (s -> CoeffMap s) -> [Double] -> [Double]

-- | Represents a frequency spectrum. Range is from 0 to 1023 (N=1024).
--   Index 0 is constant value, index 1 is Nyquest frequency (real part of
--   the N/2 frequency). Index 2 and 3 are the complex value for the
--   basefrequency, index 4 and 5 are the complex value for the double
--   basefrequency, 6 and 7 for 3 * basefrequency and so on:
--   
--   <pre>
--   arr [0] = real part of zero frequency (imaginary part is allways 0)
--   arr [1] = real part of Nyquest frequency (N/2) (imaginary part is allways 0)
--   arr [2] = real part of base frequency
--   arr [3] = imag part of base frequency
--   arr [4] = real part of base frequency * 2
--   arr [5] = imag part of base frequency * 2
--   arr [6] = real part of base frequency * 3
--   arr [7] = imag part of base frequency * 3
--   ...
--   arr [N-4] = real part of base frequency * (N/2 - 2)
--   arr [N-3] = imag part of base frequency * (N/2 - 2)
--   arr [N-2] = real part of base frequency * (N/2 - 1)
--   arr [N-1] = imag part of base frequency * (N/2 - 1)
--   </pre>
--   
--   Pseudocode:
--   
--   <pre>
--   c (0)   = (arr [0] :+ 0)
--   c (512) = (arr [1] :+ 0)
--   </pre>
--   
--   and for all i=[1..511]:
--   
--   <pre>
--   c (i) = (arr [i*2] :+ arr [i*2+1])
--   </pre>
type CoeffArr = StorableArray Int Double

-- | Reads a Complex value of a CoeffArr (with Nyquest as imaginary part of
--   coeff 0).
readCoeffArr :: CoeffArr -> Int -> IO (Complex Double)

-- | Writes a Complex value of a CoeffArr (with Nyquest as imaginary part
--   of coeff 0).
writeCoeffArr :: CoeffArr -> Int -> Complex Double -> IO ()
storeCoeff :: IOArray Int (Complex Double) -> CoeffArr -> IO ()
unstoreCoeff :: CoeffArr -> IOArray Int (Complex Double) -> IO ()

-- | An action that maps the fourier coefficients from the first array to
--   the second. Modifying the data while mapping means filtering. See
--   <a>CoeffArr</a> for a description of the arrays.
type CoeffMap a = CoeffArr -> CoeffArr -> IO a

-- | Constructs a Coeffmap. The sublists contain the 512 real values with
--   which the basefrequency and the 511 complex fourier coefficients are
--   multiplied (the Nyquist frequency will be zero). The first value is
--   the factor for the constant coefficient, the second for the base
--   frequency, the next one for the double base freq and so on. If the
--   sublists have more than 512 elements, these elements are thrown away.
--   If it is shorter, the array will be filled up with zeros.
mkCoeffMap :: [Double] -> IO (CoeffMap ())

-- | <a>coeffmap</a> takes an Array with 512 values and uses them for a
--   weigted map of the fourier coefficients. The Nyquist frequency is
--   muliplied with 0.0.
coeffmap :: StorableArray Int Double -> CoeffMap ()

-- | Constructs an action that maps wave-data to coefficient-data. Has a
--   delay of 512, i. e. the first 512 elements are zero and the result has
--   (these) 512 elemets more than the input.
mkAnalyse :: IO (Maybe Double -> IO (Maybe (Complex Double)))

-- | Constructs an action that maps coefficient-data to wave-data. Has a
--   delay of 512, i. e. the first 512 elements are zero and the result has
--   (these) 512 elemets more than the input.
mkSynthese :: IO (Maybe (Complex Double) -> IO (Maybe Double))

-- | Constructs an action that maps wave-data to wave-data via a Fast
--   Foutrier Transform and inverse, filtered by the given <a>CoeffMap</a>.
--   Has a delay of 1024.
mkFilterBuffered :: IO (CoeffMap ()) -> IO (Maybe Double -> IO (Maybe Double))

-- | Maps an array with 1024 real values to its frequency spectrum with 512
--   complex values. The spectrum is stored in the second array with 1024
--   Doubles which are the real and imaginary parts of the complex values.
--   See <a>CoeffArr</a> for a detailed frequency spectrum desription.
analyseDFT :: StorableArray Int Double -> StorableArray Int Double -> IO ()

-- | Maps a frequency spectrum to its signal value. Both arrays have a
--   length of 1024; the first one contains the 512 complex values of the
--   spectrum. The real signal value will be stored in the second array.
--   See <a>CoeffArr</a> for a detailed frequency spectrum desription.
syntheseDFT :: StorableArray Int Double -> StorableArray Int Double -> IO ()

-- | Fades a signal which is stored in an array of length 1024 in and out.
--   The signal is multiplied with a cosinus curve with range 0..pi.
kurveDFT :: StorableArray Int Double -> IO ()


-- | Dieses Module stellt Datentypen und Funktionen zum Umgang mit Mono-
--   und Stereodaten zur Verf gung. Speziell im Falle des  ffnens einer
--   WAV-Datei ist erst zur Laufzeit bekannt, ob es sich um eine Mono- oder
--   Stereodatei handelt, hier wird der Typ <a>Signal</a> ben tigt.
module Sound.Hommage.Signal

-- | A mono value.
type Mono = Double

-- | A stereo value with left and right part. It is an instance of class
--   Num and Fractional.
data Stereo
(:><:) :: !Double -> !Double -> Stereo

-- | Access to the left part of a <a>Stereo</a> value.
leftStereo :: Stereo -> Mono

-- | Access to the right part of a <a>Stereo</a> value.
rightStereo :: Stereo -> Mono

-- | Converts a Stereo value to a Mono value (Double)
stereoToMono :: Stereo -> Mono

-- | Converts a Mono value (Double) to a Stereo value
monoToStereo :: Mono -> Stereo

-- | The range of the Double value must be between -1 and 1. If it is below
--   0 the left channel is turned down, if it is greater than 0 the right
--   channel is turned down. NOTE: This function should be replaced by a
--   better one.
balance :: Double -> Stereo -> Stereo

-- | A Signal is either a list of <a>Mono</a> values or a list of
--   <a>Stereo</a> values.
data Signal
Mono :: [Mono] -> Signal
Stereo :: [Stereo] -> Signal

-- | Reads a <a>Signal</a> from a WAV-File.
readWavSignal :: FilePath -> IO Signal

-- | Opens a <a>Signal</a> from a WAV-File.
openWavSignal :: FilePath -> Signal

-- | Writes a list of mono values to a WAV-File.
writeWavMono :: FilePath -> [Mono] -> IO ()

-- | Writes a list of stereo values to a WAV-File.
writeWavStereo :: FilePath -> [Stereo] -> IO ()

-- | Writes a <a>Signal</a> to a WAV-File.
writeWavSignal :: FilePath -> Signal -> IO ()
writeTracks :: FilePath -> [Signal] -> IO ()

-- | Transfroms a signal to a list of mono values.
signalToMono :: Signal -> [Mono]

-- | Transfroms a signal to a list of stereo values.
signalToStereo :: Signal -> [Stereo]
eitherSignal :: ([Mono] -> a) -> ([Stereo] -> a) -> Signal -> a

-- | Applies the function to the input signal. If it is a stereo signal,
--   the function is applied to both channels seperately.
liftSignal :: ([Mono] -> [Mono]) -> Signal -> Signal

-- | The sum of two signals
mergeSignal :: Signal -> Signal -> Signal

-- | The sum of a set of signals. If all signals are mono, the result will
--   be mono. Otherwise it will be stereo.
mergeSignals :: [Signal] -> Signal

-- | Multiplies two signals.
multSignal :: Signal -> Signal -> Signal

-- | The Double value is added to the input signal (offset). The resulting
--   signal will be infinie in any case.
infiniteSignal :: Double -> Signal -> Signal
instance Eq Stereo
instance Show Stereo
instance Fractional Stereo
instance Num Stereo

module Sound.Hommage.Sample
data Sample a
arraySample :: Sample a -> (IOArray Int a)
sizeSample :: Sample a -> Int
newSample :: Int -> a -> IO (Sample a)
newSampleFromList :: [a] -> IO (Sample a)
openWavSample :: FilePath -> IO (Either (Sample Mono) (Sample Stereo))
saveWavSampleMono :: FilePath -> Sample Double -> IO ()
saveWavSampleStereo :: FilePath -> Sample Stereo -> IO ()

-- | Open a Wav-File, but play it with variable (positive) speed/
--   frequency.
pitchWavSignal :: FilePath -> [Double] -> Signal

-- | Open a Wav-File, but play it with variable (positive and/or negative)
--   speed/ frequency. Backward playing is possible.
scratchWavSignal :: FilePath -> [Double] -> Signal

-- | Creates a finite list with the content of the Sample.
playSample :: Sample a -> [a]

-- | Creates a list with the content of the Sample, but played with
--   variable speed/frequency.
pitchSample :: (Fractional a) => Sample a -> [Double] -> [a]

-- | Creates a list with the content of the Sample, but played with
--   variable speed/frequency, backward playing possible.
scratchSample :: (Fractional a) => Sample a -> [Double] -> [a]

-- | Creates a list with the content of <a>Coeffs</a> (a representation of
--   the fourier coefficients of a <a>Sample</a>).
playCoeffs :: Coeffs -> [Complex Double]
mapSample :: (a -> b) -> Sample a -> IO (Sample b)
foldlSample :: Sample a -> (b -> a -> b) -> b -> IO b
updateSample :: Sample a -> (a -> a) -> IO ()
normaliseSample :: (Ord a, Fractional a) => Sample a -> IO ()
fadeinoutSample :: (Fractional a) => (Int, Int) -> Sample a -> IO ()
stretchSample :: (Fractional a) => Int -> Sample a -> IO (Sample a)
data Coeffs
arrayCoeffs :: Coeffs -> IOArray Int CoeffArr
sizeCoeffs :: Coeffs -> Int
wavesizeCoeffs :: Coeffs -> Int
syntheseSample :: Coeffs -> IO (Sample Mono)
analyseSample :: Sample Mono -> IO Coeffs
filterCoeffs :: IO (CoeffMap ()) -> Coeffs -> IO Coeffs
mkPlayCoeffs :: Coeffs -> IO (IO (Maybe (Complex Double)))

-- | usage: <tt> readCoeffs obj nrOfCoeffarr nrOfCoefficient </tt>
readCoeffs :: Coeffs -> Int -> Int -> IO (Complex Double)
writeCoeffs :: Coeffs -> Int -> Int -> (Complex Double) -> IO ()
mkTriggerSample :: Sample a -> a -> IO (Bool -> IO a)
mkPlaySample :: Sample a -> IO (IO (Maybe a))
mkScratchSample :: (Fractional a) => Sample a -> IO (Double -> IO a)
mkPitchSample :: (Fractional a) => Sample a -> IO (Double -> IO (Maybe a))
interpolArray :: (Fractional a, MArray array a IO) => array Int a -> Int -> Double -> IO a
mkLoopArray :: (Fractional a, MArray arr a IO) => arr Int a -> Int -> IO (Double -> IO a)
mkPlayArray :: (Fractional a, MArray arr a IO) => arr Int a -> Int -> IO (Double -> IO (Maybe a))

module Sound.Hommage.Seq
runNumNotation :: (IsDur d, Num a) => Notation (WithDur d [a]) -> d -> [a]
bpmToDur :: Double -> Dur

-- | A <a>Seq</a> represents a temporal sequence of "Moments". Each moment
--   can contain some events of type <tt>a</tt>.
newtype Seq a
SEQ :: [[a]] -> Seq a
unSeq :: Seq a -> [[a]]

-- | Creates a <a>Seq</a> with the length that the Reader reads. (The
--   length will be in any case at least 1).
noteSeq :: (IsDur d) => a -> WithDur d (Seq a)
noteSeq' :: (IsDur d) => WithDur d a -> WithDur d (Seq a)
mixdownNumSeq :: (Num a) => Seq [a] -> [a]
applySeq :: (s -> s) -> Seq (s -> a) -> s -> (Seq a)
applySeqE :: (s -> s) -> Seq (Either (s -> a) (s -> s)) -> s -> Seq a
filterSeq :: (a -> Maybe b) -> Seq a -> Seq b
instance (IsDur d) => Musical (WithDur d (Seq a))
instance Arrangeable (Seq a)

module Sound.Hommage.Osc

-- | Play given sound with variable speed resp. frequency. (General
--   definition: Usually a frequency of 1.0 means a period of 1024 values).
--   Use scratchSample or scratchSampleSignal for backward playing.
osc :: [Double] -> [Double] -> [Double]

-- | A sinus wave generator with a period of 1024/N for frequency N
sinus :: [Double] -> [Double]

-- | A cosinus wave generator
cosinus :: [Double] -> [Double]

-- | A rectangle wave generator
rect :: [Double] -> [Double]

-- | A sawtooth wave generator
saw :: [Double] -> [Double]

-- | A triangle wave generator
tri :: [Double] -> [Double]
randomList :: (Random a) => (a, a) -> [a]

-- | Current output value is repeatet until the first list argument value
--   switches from zero or below to a non-zero positive value, the actual
--   value of the second list argument is then taken for output.
sampleAndHold :: (Ord a, Num a) => b -> [a] -> [b] -> [b]

-- | Maps the values to the average of the last N values (including the
--   actual)
average :: (Fractional a) => Int -> [a] -> [a]

-- | If predicate holds for N elements, list is cut.
terminateAt :: Int -> (a -> Bool) -> [a] -> [a]
follow :: Double -> [Double] -> [Double] -> [Double]

-- | <pre>
--   compress p x = x / (abs p + abs x)
--   </pre>
compress :: Double -> Double -> Double

-- | Transforms a notevalue into a frequency. A Notevalue of 0.0 means a
--   frequency of 1.0.
noteToFrequency :: Double -> Double -> Double

-- | Adjusts the frequency. If given oscillator has period X for frequency
--   of 1.0 and you want it to produce a wave with Y Hz at frequency of
--   1.0, use <tt> map (adjustFrequency X Y) </tt> to adjust the input of
--   the oscillator.
adjustFrequency :: Double -> Double -> Double -> Double

-- | Splits a wave into parts. they are split when a value equal or less
--   than zero is followed by a value greater than zero.
splitWaves :: [Double] -> [[Double]]

-- | Create a wave with the beginning of w1, the ending of w2 and the
--   length of the longer one of them.
crossfade :: [Double] -> [Double] -> [Double]

module Sound.Hommage.Play
newtype Play a
PLAY :: (Duration -> Environment -> a) -> Play a
unPlay :: Play a -> Duration -> Environment -> a
getDur :: Play Dur
resetDur :: Play a -> Play a
randomPlay :: (Random a) => (a, a) -> Play a
mix :: [Play Signal] -> Play Signal
mix' :: (Num a) => [Play [a]] -> Play [a]
notationMono :: Notation (Play Signal) -> Play [Mono]
notationStereo :: Notation (Play Signal) -> Play [Stereo]
notation :: (Mixable a) => Notation (Play a) -> Play a
class Mixable a
mixdown :: (Mixable a) => Seq a -> a
data Song a
SONG :: (Duration -> Environment -> (a, Environment)) -> Song a
unSong :: Song a -> Duration -> Environment -> (a, Environment)
runSong :: Double -> Song (Play a) -> a
newtype Track a
TRACK :: (Environment -> a) -> Track a
unTrack :: Track a -> Environment -> a
playTrack :: Track a -> Play a
track :: (Trackable a) => Play a -> Song (Track a)
class (Typeable a) => Trackable a
toNext :: (Trackable a) => a -> a
newtype Environment
Environment :: (Int, [(Int, [Dynamic])]) -> Environment
emptyEnvironment :: Environment
nextEnvironment :: Environment -> Environment
insertEnvironment :: [Dynamic] -> Environment -> (Environment -> Dynamic, Environment)
lookupEnvironment :: Int -> Environment -> Dynamic
data Duration
DURATION :: Dur -> Dur -> Duration
relativeDuration :: Duration -> Dur
absoluteDuration :: Duration -> Dur
resetDuration :: Duration -> Duration
initDuration :: Dur -> Duration
instance Functor Track
instance Monad Song
instance Functor Song
instance (Num a) => Mixable [a]
instance Stretchable (Play a)
instance Functor Play
instance Monad Play
instance IsDur Duration
instance Typeable Stereo
instance (Typeable a) => Trackable [a]
instance Trackable Signal
instance Typeable Signal


-- | This module implements the Fast Fourier Transformation purely in
--   Haskell.
module Sound.Hommage.FFT

-- | FFT transformation. Input is grouped into overlapping parts of 2^(N+2)
--   reals and mapped to sublists with 2^(N+1) complex numbers.
fft :: Int -> [Double] -> [[Complex Double]]

-- | Inverse FFT transformation. Complex input is grouped into parts with
--   length 2^(N+1) and mapped to sublists with 2^(N+2) reals, which are
--   overlapped and mixed.
fft' :: Int -> [Complex Double] -> [Double]

-- | FFT transformation with overlapping and windowing. Argument function
--   maps the coefficients. Windowsize: 2^(N+2), i. e. 2^(N+1) coefficients
fftt :: Int -> ([[Complex Double]] -> [Complex Double]) -> [Double] -> [Double]

-- | FFT transformation for complex input (segments of length 2^n). No
--   overlapping or windowing.
fftc :: Int -> [Complex Double] -> [[Complex Double]]

-- | Inverse FFT transformation for complex input (segments of length 2^n).
--   No overlapping or windowing.
fftc' :: Int -> [Complex Double] -> [[Complex Double]]
ffttv :: Int -> [Double] -> [Double] -> [Double]

-- | FFT for complex input with overlapping. Segment-size: 2^(n+1)
fftco :: Int -> [Complex Double] -> [[Complex Double]]
fftco' :: Int -> [Complex Double] -> [Complex Double]

-- | A self-inverse transformation similar to FFT but with a simple
--   butterfly operation that uses always W=1. Modifying the data between
--   application and inverse is similar to filtering but the result will be
--   built up from rectangle waves instead of sinus waves.
rect_transform :: (Floating a) => Int -> [a] -> [[a]]
rect_filter :: (Floating a) => Int -> ([[a]] -> [[a]]) -> [a] -> [a]
rect_filter' :: (Floating a) => Int -> [[a]] -> [a] -> [a]

-- | The complex value <a>i</a> = <tt>(0 :+ 1)</tt>
i :: Complex Double

-- | The n-th root of 1
w :: Int -> Complex Double

-- | the 2n-th root with exponents 0, 1, .. n. False=inverse (exponents are
--   negated)
ws :: Bool -> Int -> [Complex Double]
map2 :: (a -> a -> b) -> [a] -> [b]
zip2 :: [a] -> [a] -> [a]

-- | returns [] if argument has zero or one element.
appendpair :: ([a], [a]) -> [a]

-- | list is grouped into sublists with length N (must be power of 2) and
--   bitwise reverse order
reorder :: Int -> [[a]] -> [[a]]
reorder_init' :: [a] -> [[a]]
butterfly :: Complex Double -> Complex Double -> Complex Double -> (Complex Double, Complex Double)
butterfly' :: Complex Double -> Complex Double -> Complex Double -> (Complex Double, Complex Double)
fft_level :: [Complex Double] -> [[Complex Double]] -> [[Complex Double]]
fft_merge :: [Complex Double] -> [Complex Double] -> [Complex Double] -> ([Complex Double], [Complex Double])
fft_level' :: [Complex Double] -> [[Complex Double]] -> [[Complex Double]]
fft_merge' :: [Complex Double] -> [Complex Double] -> [Complex Double] -> ([Complex Double], [Complex Double])

-- | Creates a fade with length N
overlap_curve :: Int -> [Double]

-- | Overlaps a sequence of parts of length N (overlaps by N/2).
mix_overlap :: Int -> [[Double]] -> [Double]

module Sound.Hommage.Sound
(==>) :: (Sound a, Effect b) => a -> b -> Play Signal
(.=>) :: (Effect a, Effect b) => a -> b -> Play (Signal -> Signal)

-- | Minimal complete definition: <a>play</a>.
class Sound a
play :: (Sound a) => a -> Play Signal
playMono :: (Sound a) => a -> Play [Mono]
playStereo :: (Sound a) => a -> Play [Stereo]
class Effect a
effect :: (Effect a) => a -> Play (Signal -> Signal)
effectMono :: (Effect a) => a -> Play ([Mono] -> [Mono])
effectStereo :: (Effect a) => a -> Play ([Stereo] -> [Stereo])
(<+>) :: (Sound a, Sound b) => a -> b -> Play Signal
(<*>) :: (Sound a, Sound b) => a -> b -> Play Signal
data WaveForm
Sinus :: WaveForm
Cosinus :: WaveForm
Rect :: WaveForm
Saw :: WaveForm
Tri :: WaveForm
playWaveForm :: WaveForm -> [Double] -> [Double]
data Oscillator
Oscillator :: WaveForm -> Double -> Oscillator

-- | Turns pitch to frequency.
data ToFreq
ToFreq :: Double -> ToFreq
data ToFreqDyn a
ToFreqDyn :: a -> ToFreqDyn a
data Noise
Noise :: Noise
newtype PlayWav
PlayWav :: FilePath -> PlayWav
data OscWav
OscWav :: FilePath -> Double -> OscWav
data PitchWav
PitchWav :: FilePath -> PitchWav
data ScratchWav
ScratchWav :: FilePath -> ScratchWav
data Filter a
Filter :: a -> Filter a
data FilterFFT a
FilterFFT :: Int -> a -> FilterFFT a

-- | Width and cutoff.
data Lowpass width cutoff
Lowpass :: width -> cutoff -> Lowpass width cutoff

-- | Width and cutoff.
data Highpass width cutoff
Highpass :: width -> cutoff -> Highpass width cutoff
data Bandpass width slope cutoff
Bandpass :: width -> slope -> cutoff -> Bandpass width slope cutoff
data Morphfilter cutoff
Morphfilter :: FilterSpec -> FilterSpec -> cutoff -> Morphfilter cutoff
data Stretchfilter cutoff
Stretchfilter :: FilterSpec -> cutoff -> Stretchfilter cutoff
data Envelope
Envelope :: EnvMode -> EnvShape -> ADSR -> Envelope
data Amplifier volume
Amplifier :: volume -> Amplifier volume
data AddTo summand
AddTo :: summand -> AddTo summand

-- | The result will be infinite, with given offset.
data Infinite
Infinite :: Double -> Infinite
data Delay

-- | Absolute Delay
AbsDelay :: Int -> Delay

-- | Relative Delay with respect to the current duration
RelDelay :: Dur -> Delay
data ToMono
ToMono :: ToMono
data Average
Average :: Int -> Average
data SampleAndHold trigger
SampleAndHold :: trigger -> SampleAndHold trigger
data Compressor a
Compressor :: a -> Compressor a
data Follow a
Follow :: Double -> a -> Follow a
data Panorama balance
Panorama :: balance -> Panorama balance
instance Eq WaveForm
instance Read WaveForm
instance Show WaveForm
instance Eq Envelope
instance Read Envelope
instance Show Envelope
instance (Sound a) => Effect (Panorama a)
instance (Sound a) => Effect (Follow a)
instance (Sound a) => Sound (Stretchfilter a)
instance (Sound a) => Sound (Morphfilter a)
instance (Sound a) => Effect (Compressor a)
instance (Sound a) => Effect (SampleAndHold a)
instance (Sound a, Sound b, Sound c) => Sound (Bandpass a b c)
instance Effect Average
instance Effect ToMono
instance Effect Delay
instance Effect ScratchWav
instance Effect PitchWav
instance Effect OscWav
instance Effect Oscillator
instance Effect WaveForm
instance (Sound a) => Effect (ToFreqDyn a)
instance Effect ToFreq
instance Sound Noise
instance Effect Infinite
instance (Sound a) => Effect (AddTo a)
instance Sound [(Env, EnvLength)]
instance Sound Envelope
instance (Sound a) => Effect (Amplifier a)
instance (Sound a, Sound b) => Sound (Highpass a b)
instance (Sound a, Sound b) => Sound (Lowpass a b)
instance (Sound a) => Effect (FilterFFT a)
instance (Sound a) => Effect (Filter a)
instance Sound PlayWav
instance Effect ([Stereo] -> [Stereo])
instance Effect ([Mono] -> [Mono])
instance Effect (Signal -> Signal)
instance Effect (Play (Signal -> Signal))
instance (Sound a) => Effect (Play [Stereo] -> a)
instance (Sound a) => Effect (Play [Mono] -> a)
instance (Sound a) => Effect (Play Signal -> a)
instance Sound Interpolate
instance Sound (Track [Stereo])
instance Sound (Track [Mono])
instance Sound (Track Signal)
instance Sound Stereo
instance Sound Mono
instance Sound [Stereo]
instance Sound [Mono]
instance Sound Signal
instance Sound (Play [Stereo])
instance Sound (Play [Mono])
instance Sound (Play Signal)
instance Sound ()

module Sound.Hommage.Rand
newtype R a
R :: (StdGen -> a) -> R a
unR :: R a -> StdGen -> a
mkR :: (StdGen -> (a, StdGen)) -> R a
runR :: Int -> R a -> a
rif :: Double -> (a, a) -> R a
rselect :: [a] -> R a
data RM a
ror :: [RM a] -> RM a
rnote :: a -> RM a
runRM :: RM a -> R (Notation a)
rplay :: (Sound a) => a -> RM (Play Signal)
instance Musical (RM a)
instance Arrangeable (RM a)
instance Stretchable (RM a)
instance Monad RM
instance Functor RM
instance Applicative R
instance Functor R
instance Monad R

module Sound.Hommage.Tools

-- | Usage: <tt> testSound mb_wavplayer outputfileprefix stereo? bpm sound
--   </tt>
--   
--   Example: <tt> testSound (Just "c:/Programme/coolpro/coolpro.exe")
--   "out_" True 110.0 $ Interpolate Linear (0,1) </tt>
testSound :: (Sound a) => (Maybe String) -> String -> Bool -> Double -> a -> IO ()
testSong :: (Sound a) => (Maybe String) -> String -> Bool -> Double -> Song a -> IO ()
stepSequencer :: (Eq c) => [(c, a)] -> Dur -> [c] -> Notation a
rhythmize :: Dur -> [Int] -> [Maybe a] -> Notation a
pitchlist :: (Num a, Ord a) => Bool -> a -> [a]


-- | HOMMAGE - Haskell Offline Music Manipulation And Generation EDSL
--   
--   Daniel van den Eijkel <a>mailto:dvde@gmx.net</a>
module Sound.Hommage
