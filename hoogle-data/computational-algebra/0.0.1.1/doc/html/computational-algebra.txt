-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Well-kinded computational algebra library, currently supporting Groebner basis.
--   
--   Dependently-typed computational algebra libray for Groebner basis.
@package computational-algebra
@version 0.0.1.1

module Algebra.Ring.Noetherian
class (Commutative r, Ring r) => NoetherianRing r
data Ideal r
Ideal :: (Vector r n) -> Ideal r
addToIdeal :: r -> Ideal r -> Ideal r
toIdeal :: NoetherianRing r => [r] -> Ideal r
appendIdeal :: Ideal r -> Ideal r -> Ideal r
generators :: Ideal r -> [r]
filterIdeal :: NoetherianRing r => (r -> Bool) -> Ideal r -> Ideal r
mapIdeal :: (r -> r') -> Ideal r -> Ideal r'
principalIdeal :: r -> Ideal r
instance Show r => Show (Ideal r)
instance Ord r => Ord (Ideal r)
instance Eq r => Eq (Ideal r)
instance Integral n => Multiplicative (Ratio n)
instance Integral n => Abelian (Ratio n)
instance Integral n => Additive (Ratio n)
instance Integral n => Semiring (Ratio n)
instance Integral n => RightModule Integer (Ratio n)
instance Integral n => LeftModule Integer (Ratio n)
instance Integral n => Group (Ratio n)
instance Integral n => Unital (Ratio n)
instance Integral n => RightModule Natural (Ratio n)
instance Integral n => LeftModule Natural (Ratio n)
instance Integral n => Monoidal (Ratio n)
instance Integral n => Rig (Ratio n)
instance Integral n => Ring (Ratio n)
instance Integral n => Commutative (Ratio n)
instance Division (Ratio Integer)
instance Integral n => NoetherianRing (Ratio n)
instance (Commutative (Complex r), Ring (Complex r)) => NoetherianRing (Complex r)
instance NoetherianRing Integer
instance NoetherianRing Int

module Algebra.Ring.Polynomial
type Polynomial r = OrderedPolynomial r Grevlex

-- | N-ary Monomial. IntMap contains degrees for each x_i.
type Monomial (n :: Nat) = Vector Int n

-- | Monomial order (of degree n). This should satisfy following laws: (1)
--   Totality: forall a, b (a &lt; b || a == b || b &lt; a) (2) Additivity:
--   a <a>b ==</a> a + c &lt;= b + c (3) Non-negative: forall a, 0 &lt;= a
type MonomialOrder n = Monomial n -> Monomial n -> Ordering
class Order a

-- | Lexicographical order. This *is* a monomial order.
lex :: MonomialOrder n

-- | Reversed lexicographical order. This is *not* a monomial order.
revlex :: Monomial n -> Monomial n -> Ordering

-- | Convert ordering into graded one.
graded :: (Monomial n -> Monomial n -> Ordering) -> (Monomial n -> Monomial n -> Ordering)

-- | Graded lexicographical order. This *is* a monomial order.
grlex :: MonomialOrder n

-- | Graded reversed lexicographical order. This *is* a monomial order.
grevlex :: MonomialOrder n
transformMonomial :: (IsOrder o, IsPolynomial k n, IsPolynomial k m) => (Monomial n -> Monomial m) -> OrderedPolynomial k o n -> OrderedPolynomial k o m

-- | Type-level constraint to check whether it forms polynomial ring or
--   not.
type IsPolynomial r n = (NoetherianRing r, Sing n, Eq r)

-- | coefficient for a degree.
coeff :: (IsOrder order, IsPolynomial r n) => Monomial n -> OrderedPolynomial r order n -> r
lcmMonomial :: Monomial n -> Monomial n -> Monomial n
sPolynomial :: (IsPolynomial k n, Field k, IsOrder order) => OrderedPolynomial k order n -> OrderedPolynomial k order n -> OrderedPolynomial k order n
polynomial :: (Sing n, Eq r, NoetherianRing r, IsOrder order) => Map (OrderedMonomial order n) r -> OrderedPolynomial r order n
castMonomial :: (IsOrder o, IsOrder o', Sing m, n :<= m) => OrderedMonomial o n -> OrderedMonomial o' m
castPolynomial :: (IsPolynomial r n, IsPolynomial r m, Sing m, IsOrder o, IsOrder o', n :<= m) => OrderedPolynomial r o n -> OrderedPolynomial r o' m
toPolynomial :: (IsOrder order, IsPolynomial r n) => (r, Monomial n) -> OrderedPolynomial r order n
changeOrder :: (Eq (Monomial n), IsOrder o, IsOrder o', Sing n) => o' -> OrderedPolynomial k o n -> OrderedPolynomial k o' n
scastMonomial :: n :<= m => SNat m -> OrderedMonomial o n -> OrderedMonomial o m
scastPolynomial :: (IsOrder o, IsOrder o', IsPolynomial r n, IsPolynomial r m, n :<= m, Sing m) => SNat m -> OrderedPolynomial r o n -> OrderedPolynomial r o' m

-- | n-ary polynomial ring over some noetherian ring R.
data OrderedPolynomial r order n
showPolynomialWithVars :: (Eq a, Show a, Sing n, NoetherianRing a, IsOrder ordering) => [(Int, String)] -> OrderedPolynomial a ordering n -> String
normalize :: (Eq r, IsOrder order, IsPolynomial r n) => OrderedPolynomial r order n -> OrderedPolynomial r order n
injectCoeff :: IsPolynomial r n => r -> OrderedPolynomial r order n
varX :: (NoetherianRing r, Sing n, One :<= n) => OrderedPolynomial r order n
var :: (NoetherianRing r, Sing m, S n :<= m) => SNat (S n) -> OrderedPolynomial r order m
getTerms :: OrderedPolynomial k order n -> [(k, Monomial n)]
shiftR :: (Field r, IsPolynomial r n, IsPolynomial r (k :+: n), IsOrder ord) => SNat k -> OrderedPolynomial r ord n -> OrderedPolynomial r ord (k :+: n)
divs :: Monomial n -> Monomial n -> Bool
tryDiv :: Field r => (r, Monomial n) -> (r, Monomial n) -> (r, Monomial n)

-- | convert NAry list into Monomial.
fromList :: SNat n -> [Int] -> Monomial n
leadingTerm :: (IsOrder order, IsPolynomial r n) => OrderedPolynomial r order n -> (r, Monomial n)
leadingMonomial :: (IsOrder order, IsPolynomial r n) => OrderedPolynomial r order n -> Monomial n
leadingCoeff :: (IsOrder order, IsPolynomial r n) => OrderedPolynomial r order n -> r
genVars :: (IsPolynomial k (S n), IsOrder o) => SNat (S n) -> [OrderedPolynomial k o (S n)]
sDegree :: OrderedPolynomial k ord n -> SNat n

-- | A wrapper for monomials with a certain (monomial) order.
newtype OrderedMonomial (ordering :: *) n
OrderedMonomial :: Monomial n -> OrderedMonomial n
getMonomial :: OrderedMonomial n -> Monomial n
data Grevlex
Grevlex :: Grevlex
data Revlex
Revlex :: Revlex
data Lex
Lex :: Lex
data Grlex
Grlex :: Grlex

-- | Class to lookup ordering from its (type-level) name.
class IsOrder (ordering :: *)

-- | Class for Monomial orders.
class IsOrder name => IsMonomialOrder name
instance Eq (Monomial n) => Eq (OrderedMonomial ordering n)
instance Show Grevlex
instance Eq Grevlex
instance Ord Grevlex
instance Show Lex
instance Eq Lex
instance Ord Lex
instance Show Grlex
instance Eq Grlex
instance Ord Grlex
instance Show Revlex
instance Eq Revlex
instance Ord Revlex
instance (IsMonomialOrder order, IsPolynomial r n, Num r) => Num (OrderedPolynomial r order n)
instance (Eq r, IsPolynomial r n, IsOrder order, Show r) => Show (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Abelian (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Commutative (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Semiring (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Multiplicative (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Unital (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => RightModule Natural (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => LeftModule Natural (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Monoidal (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Additive (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => RightModule Integer (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => LeftModule Integer (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Group (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Rig (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => Ring (OrderedPolynomial r order n)
instance (IsOrder order, IsPolynomial r n) => NoetherianRing (OrderedPolynomial r order n)
instance (Eq r, IsOrder order, IsPolynomial r n) => Eq (OrderedPolynomial r order n)
instance Wrapped (Map (OrderedMonomial order n) r) (Map (OrderedMonomial order' m) q) (OrderedPolynomial r order n) (OrderedPolynomial q order' m)
instance Eq (Monomial n) => Ord (Monomial n)
instance (Eq (Monomial n), IsOrder name) => Ord (OrderedMonomial name n)
instance IsMonomialOrder Lex
instance IsMonomialOrder Grevlex
instance IsMonomialOrder Grlex
instance IsOrder Grlex
instance IsOrder Lex
instance IsOrder Revlex
instance IsOrder Grevlex
instance Wrapped (Monomial n) (Monomial m) (OrderedMonomial o n) (OrderedMonomial o' m)

module Algebra.Algorithms.Groebner
divModPolynomial :: (IsMonomialOrder order, IsPolynomial r n, Field r) => OrderedPolynomial r order n -> [OrderedPolynomial r order n] -> ([(OrderedPolynomial r order n, OrderedPolynomial r order n)], OrderedPolynomial r order n)
modPolynomial :: (IsPolynomial r n, Field r, IsMonomialOrder order) => OrderedPolynomial r order n -> [OrderedPolynomial r order n] -> OrderedPolynomial r order n
divPolynomial :: (IsPolynomial r n, Field r, IsMonomialOrder order) => OrderedPolynomial r order n -> [OrderedPolynomial r order n] -> [(OrderedPolynomial r order n, OrderedPolynomial r order n)]
simpleBuchberger :: (Field k, IsPolynomial k n, IsMonomialOrder order) => Ideal (OrderedPolynomial k order n) -> [OrderedPolynomial k order n]
minimizeGroebnerBasis :: (Field k, IsPolynomial k n, IsMonomialOrder order) => [OrderedPolynomial k order n] -> [OrderedPolynomial k order n]
reduceMinimalGroebnerBasis :: (Field k, IsPolynomial k n, IsMonomialOrder order) => [OrderedPolynomial k order n] -> [OrderedPolynomial k order n]
calcGroebnerBasisWith :: (Field k, IsPolynomial k n, IsMonomialOrder order, IsMonomialOrder order') => order -> Ideal (OrderedPolynomial k order' n) -> [OrderedPolynomial k order n]
calcGroebnerBasis :: (Field k, IsPolynomial k n, IsMonomialOrder order) => Ideal (OrderedPolynomial k order n) -> [OrderedPolynomial k order n]
isIdealMember :: (IsPolynomial k n, Field k, IsMonomialOrder o) => OrderedPolynomial k o n -> Ideal (OrderedPolynomial k o n) -> Bool
groebnerTest :: (IsPolynomial k n, Field k, IsMonomialOrder order) => OrderedPolynomial k order n -> [OrderedPolynomial k order n] -> Bool
thEliminationIdeal :: (IsMonomialOrder ord, Field k, IsPolynomial k m, IsPolynomial k (n :+: m)) => SNat n -> Ideal (OrderedPolynomial k ord (n :+: m)) -> Ideal (OrderedPolynomial k Lex m)

-- | An intersection ideal of given ideals.
intersection :: (IsMonomialOrder ord, Field r, IsPolynomial r k, IsPolynomial r n, IsPolynomial r (k :+: n)) => Vector (Ideal (OrderedPolynomial r ord n)) k -> Ideal (OrderedPolynomial r Lex n)

-- | Ideal quotient by a principal ideals.
quotByPrincipalIdeal :: (Field k, IsPolynomial k n, IsMonomialOrder ord) => Ideal (OrderedPolynomial k ord n) -> OrderedPolynomial k ord n -> Ideal (OrderedPolynomial k Lex n)
quotIdeal :: (IsPolynomial k n, Field k, IsMonomialOrder ord) => Ideal (OrderedPolynomial k ord n) -> Ideal (OrderedPolynomial k ord n) -> Ideal (OrderedPolynomial k Lex n)

-- | Saturation by a principal ideal.
saturationByPrincipalIdeal :: (Field k, IsPolynomial k n, IsMonomialOrder ord) => Ideal (OrderedPolynomial k ord n) -> OrderedPolynomial k ord n -> Ideal (OrderedPolynomial k Lex n)
saturationIdeal :: (IsPolynomial k n, Field k, IsMonomialOrder ord) => Ideal (OrderedPolynomial k ord n) -> Ideal (OrderedPolynomial k ord n) -> Ideal (OrderedPolynomial k Lex n)

module Algebra.Ring.Polynomial.Monomorphic
data Variable
Variable :: Char -> Maybe Int -> Variable
varName :: Variable -> Char
varIndex :: Variable -> Maybe Int
type Polyn = [(Rational, [(Variable, Integer)])]
buildVarsList :: Polyn -> [Variable]
encodeMonomList :: [Variable] -> [(Variable, Integer)] -> [Int]
encodeMonomial :: [Variable] -> [(Variable, Integer)] -> Monomorphic (Vector Int)
encodePolynomial :: Polyn -> Monomorphic (Polynomial Rational)
toPolynomialSetting :: Polyn -> PolynomialSetting
data PolynomialSetting
PolySetting :: Monomorphic SNat -> Polyn -> PolynomialSetting
dimension :: PolynomialSetting -> Monomorphic SNat
polyn :: PolynomialSetting -> Polyn
uniformlyPromote :: IsMonomialOrder ord => [Polyn] -> Monomorphic (Ideal :.: OrderedPolynomial Rational ord)
promoteList :: IsMonomialOrder ord => [Polyn] -> Monomorphic ([] :.: OrderedPolynomial Rational ord)
renameVars :: [Variable] -> Polyn -> Polyn
showPolyn :: Polyn -> String
instance Eq Variable
instance Ord Variable
instance Show PolynomialSetting
instance IsMonomialOrder ord => Monomorphicable Nat ((:.:) * Nat Ideal (OrderedPolynomial Rational ord))
instance IsMonomialOrder ord => Monomorphicable Nat (OrderedPolynomial Rational ord)
instance Show Variable

module Algebra.Algorithms.Groebner.Monomorphic
calcGroebnerBasis :: [Polyn] -> [Polyn]
isIdealMember :: Polyn -> [Polyn] -> Bool

module Algebra.Ring.Polynomial.Parser
variable :: Parser Variable
variableWithPower :: Parser (Variable, Integer)
index :: Parser Int
monomial :: Parser [(Variable, Integer)]
term :: Parser (Rational, [(Variable, Integer)])
signed' :: Num t => ParsecT String () Identity (t, t1) -> ParsecT String () Identity (t, t1)
symbol :: Char -> Parser Char
lexeme :: Parser a -> Parser a
polyOp :: Parser (Polyn -> Polyn -> Polyn)
expression :: Parser [(Rational, [(Variable, Integer)])]
coefficient :: Parser Rational
number :: Parser Rational
parseInt :: Parser Integer
signed :: Num b => Parser b -> Parser b
parseDouble :: Parser Double
parsePolyn :: String -> Either ParseError Polyn
