-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler C code generator.
--   
--   Disciplined Disciple Compiler C code generator.
@package ddc-core-salt
@version 0.4.1.3

module DDC.Core.Salt.Platform

-- | Enough information about the platform to generate code for it. We need
--   to know the pointer size and alignment constraints so that we can lay
--   out heap objects.
data Platform
Platform :: Integer -> Integer -> Integer -> Integer -> Integer -> Platform

-- | Width of an address in bytes.
platformAddrBytes :: Platform -> Integer

-- | Width of a constructor tag in bytes.
platformTagBytes :: Platform -> Integer

-- | Width of a Nat in bytes (used for object sizes like size_t).
platformNatBytes :: Platform -> Integer

-- | Align functions on this boundary in bytes.
platformAlignBytes :: Platform -> Integer

-- | Minimum size of a heap object in bytes.
platformObjBytes :: Platform -> Integer

-- | 32-bit platform specification.
--   
--   Heap objects are aligned to 64-bit so that double-precision floats in
--   the object payloads maintain their alignments.
platform32 :: Platform

-- | 64-bit platform specification.
platform64 :: Platform
instance Show Platform
instance Pretty Platform

module DDC.Core.Lite.Compounds

-- | Unboxed `Bool#` type constructor.
tBoolU :: Type Name

-- | Application of the Bool type constructor.
tBool :: Region Name -> Type Name

-- | The Nat# type constructor.
tNatU :: Type Name

-- | Application of the Nat type constructor.
tNat :: Region Name -> Type Name

-- | A Literal Nat# data constructor.
dcNatU :: Integer -> DaCon Name

-- | A literal Nat#
xNatU :: a -> Integer -> Exp a Name

-- | Unboxed `Int#` type constructor.
tIntU :: Type Name

-- | Application of the Int type constructor.
tInt :: Region Name -> Type Name

-- | Unboxed `WordN#` type constructor of the given width.
tWordU :: Int -> Type Name

-- | Application of the Pair type constructor.
tPair :: Region Name -> Type Name -> Type Name -> Type Name

-- | Application of the List type constructor.
tList :: Region Name -> Type Name -> Type Name

module DDC.Core.Lite.Env

-- | Data type definitions
--   
--   <pre>
--   Type                         Constructors
--   ----                ------------------------------
--   Bool#               True# False#
--   Nat#                0# 1# 2# ...
--   Int#                ... -2i# -1i# 0i# 1i# 2i# ...
--   Tag#                (none, convert from Nat#)
--   Word{8,16,32,64}#   42w8# 123w64# ...
--   Float{32,64}#       (none, convert from Int#)
--   
--   Unit                ()
--   Bool                B#
--   Nat                 N#
--   Int                 I#
--   Pair                Pr
--   List                Nil  Cons
--   </pre>
primDataDefs :: DataDefs Name

-- | Kind environment containing kinds of primitive data types.
primKindEnv :: Env Name

-- | Type environment containing types of primitive operators.
primTypeEnv :: Env Name

-- | Check if a type represents a boxed data type, where type variables are
--   treated as boxed.
isBoxedType :: Type Name -> Bool


-- | Names used in the Disciple Core Salt language profile.
module DDC.Core.Salt.Name

-- | Names of things used in Disciple Core Salt.
data Name

-- | A type or value variable.
NameVar :: String -> Name

-- | Constructor names.
NameCon :: String -> Name

-- | The abstract heap object type constructor.
NameObjTyCon :: Name

-- | A primitive type constructor.
NamePrimTyCon :: PrimTyCon -> Name

-- | A primitive operator.
NamePrimOp :: PrimOp -> Name

-- | The void literal.
NameLitVoid :: Name

-- | A boolean literal.
NameLitBool :: Bool -> Name

-- | A natural number literal.
NameLitNat :: Integer -> Name

-- | An integer number literal.
NameLitInt :: Integer -> Name

-- | A constructor tag literal.
NameLitTag :: Integer -> Name

-- | A <tt>WordN#</tt> literal, of the given width.
NameLitWord :: Integer -> Int -> Name

-- | Primitive type constructors.
data PrimTyCon

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Read a primitive type constructor.
--   
--   Words are limited to 8, 16, 32, or 64 bits.
--   
--   Floats are limited to 32 or 64 bits.
readPrimTyCon :: String -> Maybe PrimTyCon

-- | Integral constructors are the ones that we can reasonably convert from
--   integers of the same size.
--   
--   These are <tt>Bool</tt> <tt>Int</tt> and <tt>Tag#</tt>.
primTyConIsIntegral :: PrimTyCon -> Bool

-- | Floating point constructors.
--   
--   These are <tt>FloatN</tt>.
primTyConIsFloating :: PrimTyCon -> Bool

-- | Unsigned integral constructors.
--   
--   These are <tt>Bool</tt> <tt>Nat</tt> <tt>WordN</tt> <tt>Tag</tt>.
primTyConIsUnsigned :: PrimTyCon -> Bool

-- | Signed integral constructors.
--   
--   This is just <tt>Int</tt>.
primTyConIsSigned :: PrimTyCon -> Bool

-- | Get the representation width of a primitive type constructor, in bits.
--   This is how much space it takes up in an object payload.
--   
--   Bools are representable with a single bit, but we unpack them into a
--   whole word.
--   
--   The constructors <tt>Void</tt> and <tt>VecN#</tt> and <tt>String</tt>
--   have no width.
primTyConWidth :: Platform -> PrimTyCon -> Maybe Integer

-- | Primitive operators implemented directly by the machine or runtime
--   system.
data PrimOp

-- | Arithmetic, logic, comparison and bit-wise operators.
PrimArith :: PrimArith -> PrimOp

-- | Casting between numeric types.
PrimCast :: PrimCast -> PrimOp

-- | Raw store access.
PrimStore :: PrimStore -> PrimOp

-- | Special function calling conventions.
PrimCall :: PrimCall -> PrimOp

-- | Non-functional control flow.
PrimControl :: PrimControl -> PrimOp

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Read a primitive operator.
readPrimArith :: String -> Maybe PrimArith

-- | Primitive ways of invoking a function, where control flow returns back
--   to the caller.
data PrimCall

-- | Tailcall a function
PrimCallTail :: Int -> PrimCall
readPrimCall :: String -> Maybe PrimCall

-- | Primitive cast between two types.
--   
--   The exact set of available casts is determined by the target platform.
--   For example, you can only promote a <tt>Nat#</tt> to a
--   <tt>Word32#</tt> on a 32-bit system. On a 64-bit system the
--   <tt>Nat#</tt> type is 64-bits wide, so casting it to a
--   <tt>Word32#</tt> would be a truncation.
data PrimCast

-- | Convert a value to a new representation with the same precision.
PrimCastConvert :: PrimCast

-- | Promote a value to one of similar or larger width, without loss of
--   precision.
PrimCastPromote :: PrimCast

-- | Truncate a value to a new width, possibly losing precision.
PrimCastTruncate :: PrimCast
readPrimCast :: String -> Maybe PrimCast

-- | Check for a valid promotion primop.
primCastPromoteIsValid :: Platform -> PrimTyCon -> PrimTyCon -> Bool

-- | Check for valid truncation primop.
primCastTruncateIsValid :: Platform -> PrimTyCon -> PrimTyCon -> Bool

-- | Primitive non-returning control flow.
data PrimControl

-- | Ungraceful failure -- just abort the program. This is called on
--   internal errors in the runtime system. There is no further debugging
--   info provided, so you'll need to look at the stack trace to debug it.
PrimControlFail :: PrimControl

-- | Return from the enclosing function with the given value.
PrimControlReturn :: PrimControl
readPrimControl :: String -> Maybe PrimControl

-- | Raw access to the store.
data PrimStore

-- | Number of bytes needed to store a value of a primitive type.
PrimStoreSize :: PrimStore

-- | Log2 of number of bytes need to store a value of a primitive type.
PrimStoreSize2 :: PrimStore

-- | Create a heap of the given size. This must be called before
--   <tt>alloc#</tt> below, and has global side effect. Calling it twice in
--   the same program is undefined.
PrimStoreCreate :: PrimStore

-- | Check whether there are at least this many bytes still available on
--   the heap.
PrimStoreCheck :: PrimStore

-- | Force a garbage collection to recover at least this many bytes.
PrimStoreRecover :: PrimStore

-- | Allocate some space on the heap. There must be enough space available,
--   else undefined.
PrimStoreAlloc :: PrimStore

-- | Read a value from the store at the given address and offset.
PrimStoreRead :: PrimStore

-- | Write a value to the store at the given address and offset.
PrimStoreWrite :: PrimStore

-- | Add an offset in bytes to an address.
PrimStorePlusAddr :: PrimStore

-- | Subtract an offset in bytes from an address.
PrimStoreMinusAddr :: PrimStore

-- | Read a value from a pointer plus the given offset.
PrimStorePeek :: PrimStore

-- | Write a value to a pointer plus the given offset.
PrimStorePoke :: PrimStore

-- | Add an offset in bytes to a pointer.
PrimStorePlusPtr :: PrimStore

-- | Subtract an offset in bytes from a pointer.
PrimStoreMinusPtr :: PrimStore

-- | Convert an raw address to a pointer.
PrimStoreMakePtr :: PrimStore

-- | Convert a pointer to a raw address.
PrimStoreTakePtr :: PrimStore

-- | Cast between pointer types.
PrimStoreCastPtr :: PrimStore
readPrimStore :: String -> Maybe PrimStore

-- | Primitive vector operators.
data PrimVec

-- | Negate elements of a vector.
PrimVecNeg :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Add elements of a vector.
PrimVecAdd :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Subtract elements of a vector.
PrimVecSub :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Multiply elements of a vector.
PrimVecMul :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Divide elements of a vector.
PrimVecDiv :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Replicate a scalar into a vector.
PrimVecRep :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Pack multiple scalars into a vector
PrimVecPack :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Extract a single element from a vector.
PrimVecProj :: Int -> Int -> PrimVec
primVecMulti :: PrimVec -> Int
primVecIndex :: PrimVec -> Int

-- | Read multiple elements from memory.
PrimVecGather :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Write multiple elements to memory.
PrimVecScatter :: Int -> PrimVec
primVecMulti :: PrimVec -> Int

-- | Read a primitive vector operator.
readPrimVec :: String -> Maybe PrimVec

-- | Yield the multiplicity of a vector operator.
multiOfPrimVec :: PrimVec -> Maybe Int

-- | Yield the <tt>PrimVector</tt> that corresponds to a <a>PrimArith</a>
--   of the given multiplicity, if any.
liftPrimArithToVec :: Int -> PrimArith -> Maybe PrimVec

-- | Yield the <a>PrimArith</a> that corresponds to a <tt>PrimVector</tt>,
--   if any.
lowerPrimVecToArith :: PrimVec -> Maybe PrimArith

-- | Read a signed integer.
readLitInteger :: String -> Maybe Integer

-- | Read an integer with an explicit format specifier like
--   <tt>1234i#</tt>.
readLitPrimNat :: String -> Maybe Integer

-- | Read an integer literal with an explicit format specifier like
--   <tt>1234i#</tt>.
readLitPrimInt :: String -> Maybe Integer

-- | Read a word with an explicit format speficier.
readLitPrimWordOfBits :: String -> Maybe (Integer, Int)

-- | Read a float literal with an explicit format specifier like
--   <tt>123.00f32#</tt>.
readLitPrimFloatOfBits :: String -> Maybe (Double, Int)

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name
instance Typeable Name
instance Eq PrimOp
instance Ord PrimOp
instance Show PrimOp
instance Eq Name
instance Ord Name
instance Show Name
instance Pretty PrimOp
instance NFData PrimOp
instance Pretty Name
instance NFData Name


-- | Layout of algebraic data.
module DDC.Core.Lite.Layout

-- | Enumerates the heap object formats that can be used to store algebraic
--   data.
--   
--   The layout of these is defined in the <tt>ObjectNN.dce</tt> file of
--   the runtime system, where <tt>NN</tt> is the word size of the machine.
data HeapObject
HeapObjectBoxed :: HeapObject
HeapObjectMixed :: HeapObject
HeapObjectRaw :: HeapObject
HeapObjectRawSmall :: HeapObject

-- | Decide which heap object to use to represent a data constructor.
heapObjectOfDataCtor :: Platform -> DataCtor Name -> Maybe HeapObject

-- | Get the size of the payload for this data constructor. The payload
--   holds all the fields, but does not include header information such as
--   the constructor tag.
--   
--   This doesn't add any padding for misaligned fields.
payloadSizeOfDataCtor :: Platform -> DataCtor Name -> Maybe Integer

-- | Given a constructor definition, get the offset of each field in the
--   payload of a heap object.
--   
--   We don't know the absolute offset from the beginning of the heap
--   object, because the size of the header is only known by the runtime
--   system.
--   
--   This doesn't add any padding for misaligned fields.
fieldOffsetsOfDataCtor :: Platform -> DataCtor Name -> Maybe [Integer]
instance Eq HeapObject
instance Show HeapObject

module DDC.Core.Salt.Compounds
tVoid :: Type Name
tBool :: Type Name
xBool :: a -> Bool -> Exp a Name
tNat :: Type Name
xNat :: a -> Integer -> Exp a Name
tInt :: Type Name
xInt :: a -> Integer -> Exp a Name
tWord :: Int -> Type Name
xWord :: a -> Integer -> Int -> Exp a Name
tTag :: Type Name
xTag :: a -> Integer -> Exp a Name
tObj :: Type Name
tAddr :: Type Name
tPtr :: Region Name -> Type Name -> Type Name
takeTPtr :: Type Name -> Maybe (Region Name, Type Name)
tString :: Type Name


-- | Types of Disciple Core Salt primops.
module DDC.Core.Salt.Env

-- | Data type definitions for:
--   
--   <pre>
--   Type                        Constructors
--   ----                --------------------------
--   Bool#               True# False#
--   Nat#                0# 1# 2# ...
--   Int#                ... -2i# -1i# 0i# 1i# 2i# ...
--   Tag#                (none, convert from Nat#)
--   Word{8,16,32,64}#   42w8# 123w64# ...
--   Float{32,64}#       (none, convert from Int#)
--   </pre>
primDataDefs :: DataDefs Name

-- | Kind environment containing kinds of primitive data types.
primKindEnv :: Env Name

-- | Type environment containing types of primitive operators.
primTypeEnv :: Env Name

-- | Take the type of a primitive operator.
typeOfPrimArith :: PrimArith -> Type Name

-- | Take the type of a primitive cast.
typeOfPrimCast :: PrimCast -> Type Name

-- | Take the type of a primitive call operator.
typeOfPrimCall :: PrimCall -> Type Name
typeOfPrimControl :: PrimControl -> Type Name

-- | Take the type of a primitive projection.
typeOfPrimStore :: PrimStore -> Type Name

-- | Check if a type is an unboxed data type.
typeIsUnboxed :: Type Name -> Bool


-- | Language profile for Disciple Core Salt.
module DDC.Core.Salt.Profile

-- | Language profile for Disciple Core Salt.
profile :: Profile Name

-- | Lex a string to tokens, using primitive names.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]


-- | Bindings to functions exported by the runtime system, and wrappers for
--   related primops.
module DDC.Core.Salt.Runtime

-- | Runtime system configuration
data Config
Config :: Integer -> Config

-- | Used a fixed-size heap of this many bytes.
configHeapSize :: Config -> Integer

-- | Kind signatures for runtime types that we use when converting to Salt.
runtimeImportKinds :: Map Name (ImportSource Name)

-- | Type signatures for runtime funtions that we use when converting to
--   Salt.
runtimeImportTypes :: Map Name (ImportSource Name)

-- | The top-level region. This region lives for the whole program, and is
--   used to store objects whose types don't have region annotations (like
--   function closures and Unit values).
rTop :: Type Name

-- | Get the constructor tag of an object.
xGetTag :: a -> Type Name -> Exp a Name -> Exp a Name

-- | Allocate a Boxed object.
xAllocBoxed :: a -> Type Name -> Integer -> Exp a Name -> Exp a Name

-- | Get a field of a Boxed object.
xGetFieldOfBoxed :: a -> Type Name -> Type Name -> Exp a Name -> Integer -> Exp a Name

-- | Set a field in a Boxed Object.
xSetFieldOfBoxed :: a -> Type Name -> Type Name -> Exp a Name -> Integer -> Exp a Name -> Exp a Name

-- | Allocate a RawSmall object.
xAllocRawSmall :: a -> Type Name -> Integer -> Exp a Name -> Exp a Name

-- | Get the payload of a RawSmall object.
xPayloadOfRawSmall :: a -> Type Name -> Exp a Name -> Exp a Name

-- | Create the heap.
xCreate :: a -> Integer -> Exp a Name

-- | Read a value from an address plus offset.
xRead :: a -> Type Name -> Exp a Name -> Integer -> Exp a Name

-- | Write a value to an address plus offset.
xWrite :: a -> Type Name -> Exp a Name -> Integer -> Exp a Name -> Exp a Name

-- | Peek a value from a buffer pointer plus offset
xPeekBuffer :: a -> Type Name -> Type Name -> Exp a Name -> Integer -> Exp a Name

-- | Poke a value from a buffer pointer plus offset
xPokeBuffer :: a -> Type Name -> Type Name -> Exp a Name -> Integer -> Exp a Name -> Exp a Name

-- | Fail with an internal error.
xFail :: a -> Type Name -> Exp a Name

-- | Return a value. like (return] x)
xReturn :: a -> Type Name -> Exp a Name -> Exp a Name


-- | Convert the Disciple Core Salt into to real C code.
--   
--   The input module needs to be: well typed, fully named with no deBruijn
--   indices, have all functions defined at top-level, a-normalised, have a
--   control-transfer primop at the end of every function body (these are
--   added by DDC.Core.Salt.Convert.Transfer)
module DDC.Core.Salt.Convert

-- | Convert a Disciple Core Salt module to C-source text.
seaOfSaltModule :: Show a => Bool -> Platform -> Module a Name -> Either (Error a) Doc

-- | If this it the Main module, then insert a main function for the posix
--   entry point that initialises the runtime system and calls the real
--   main function.
--   
--   Returns Nothing if this is the Main module, but there is no main
--   function.
initRuntime :: Config -> Module a Name -> Maybe (Module a Name)

-- | Convert the Salt name of a supercombinator to a name we can use when
--   defining the C function.
seaNameOfSuper :: Maybe (ImportSource Name) -> Maybe (ExportSource Name) -> Name -> Maybe Doc

-- | Convert the Salt name of a local variable to a name we can use in the
--   body of a C function.
seaNameOfLocal :: Name -> Maybe Doc

-- | Rewrite a name to make it safe to export as an external C symbol.
--   
--   Names containing unfriendly characters like <tt>&amp;</tt> are
--   prefixed with <tt>_sym_</tt> and the <tt>&amp;</tt> is replaced by
--   <tt>ZAn</tt>. Literal <tt>Z</tt>s such a name are doubled to
--   <tt>ZZ</tt>.
sanitizeName :: String -> String

-- | Things that can go wrong when converting a Disciple Core Salt module
--   to C source text.
data Error a

-- | Variable is not in scope.
ErrorUndefined :: Bound Name -> Error a
errorVar :: Error a -> Bound Name

-- | Binder has BNone form, binds no variable.
ErrorBindNone :: Error a

-- | Invalid import.
ErrorImportInvalid :: Name -> Error a
errorImportName :: Error a -> Name

-- | A local variable has an invalid type.
ErrorTypeInvalid :: Type Name -> Error a
errorType :: Error a -> Type Name

-- | Modules must contain a top-level letrec.
ErrorNoTopLevelLetrec :: Module a Name -> Error a
errorModule :: Error a -> Module a Name

-- | An invalid function definition.
ErrorFunctionInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid function parameter.
ErrorParameterInvalid :: Bind Name -> Error a
errorBind :: Error a -> Bind Name

-- | An invalid function body.
ErrorBodyInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | A function body that does not explicitly pass control.
ErrorBodyMustPassControl :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid statement.
ErrorStmtInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid alternative.
ErrorAltInvalid :: Alt a Name -> Error a
errorAlt :: Error a -> Alt a Name

-- | An invalid RValue.
ErrorRValueInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid function argument.
ErrorArgInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid primitive call
ErrorPrimCallInvalid :: PrimOp -> [Exp a Name] -> Error a
errorPrimOp :: Error a -> PrimOp
errorArgs :: Error a -> [Exp a Name]

module DDC.Core.Salt.Transfer

-- | Add control transfer primops to function bodies. For example:
--   
--   <pre>
--         fun [x : Int32#] : Int32#
--            = case ... of
--                    ...      -&gt; add# [Int32] ...
--                    ...      -&gt; fun x
--   
--   =&gt; fun [x : Int32#] : Int32#
--            = case ... of
--                    ...      -&gt; return# [Int32#] (add# [Int32] ...)
--                    ...      -&gt; tailcall1# [Int32#] [Int32#] fun x
--   </pre>
--   
--   The control primops return tell us how to transfer control after we've
--   finished with the current function.
transferModule :: Module (AnTEC a Name) Name -> Either (Error (AnTEC a Name)) (Module (AnTEC a Name) Name)


-- | Disciple Core Lite.
--   
--   This is a desugared version of Disciple Core that has all the
--   polymorphism of System-F2 along with algebraic data types. It does not
--   yet support user-defined data types, but has Units, Ints, Pairs and
--   Lists baked in.
--   
--   Lite exposes arithmetic primops like <tt>add</tt>, but no store or
--   control primops. Code written in Lite cannot corrupt the heap,
--   assuming the implementation of the Salt primitives it uses (and
--   compiler) is correct.
module DDC.Core.Lite

-- | Profile for Disciple Core Lite.
profile :: Profile Name

-- | Convert a Disciple Core Lite module to Disciple Core Salt.
--   
--   Case expressions on algebraic data values are converted into ones that
--   just check the tag, while data constructors are unfolded into explicit
--   allocation and field initialization primops.
--   
--   The input module needs to be: well typed, fully named with no deBruijn
--   indices, have all functions defined at top-level, have type
--   annotations on every bound variable and constructor, be a-normalised.
--   If not then <a>Error</a>.
--   
--   The output code contains: debruijn indices. These then need to be
--   eliminated before it will pass the Salt fragment checks.
saltOfLiteModule :: Show a => Platform -> Config -> DataDefs Name -> KindEnv Name -> TypeEnv Name -> Module (AnTEC a Name) Name -> Either (Error a) (Module a Name)

-- | Things that can go wrong during the conversion.
data Error a

-- | The <tt>Main</tt> module has no <tt>main</tt> function.
ErrorMainHasNoMain :: Error a

-- | Found unexpected AST node, like <a>LWithRegion</a>.
ErrorMalformed :: String -> Error a

-- | The program is definately not well typed.
ErrorMistyped :: (Exp (AnTEC a Name) Name) -> Error a

-- | The program wasn't in a-normal form.
ErrorNotNormalized :: String -> Error a

-- | The program has bottom (missing) type annotations.
ErrorBotAnnot :: Error a

-- | Found an unexpected type sum.
ErrorUnexpectedSum :: Error a

-- | An invalid name used in a binding position
ErrorInvalidBinder :: Name -> Error a

-- | An invalid name used in a bound position
ErrorInvalidBound :: (Bound Name) -> Error a

-- | An invalid name used for the constructor of an alternative.
ErrorInvalidAlt :: Error a

-- | Names of things used in Disciple Core Lite.
data Name

-- | User defined variables.
NameVar :: String -> Name

-- | A user defined constructor.
NameCon :: String -> Name

-- | Baked in effect type constructors.
NameEffectTyCon :: EffectTyCon -> Name

-- | Baked in data type constructors.
NameDataTyCon :: DataTyCon -> Name

-- | A primitive data constructor.
NamePrimDaCon :: PrimDaCon -> Name

-- | A primitive type constructor.
NamePrimTyCon :: PrimTyCon -> Name

-- | Primitive arithmetic, logic, comparison and bit-wise operators.
NamePrimArith :: PrimArith -> Name

-- | Primitive casting between numeric types.
NamePrimCast :: PrimCast -> Name

-- | An unboxed boolean literal
NameLitBool :: Bool -> Name

-- | An unboxed natural literal.
NameLitNat :: Integer -> Name

-- | An unboxed integer literal.
NameLitInt :: Integer -> Name

-- | An unboxed word literal
NameLitWord :: Integer -> Int -> Name

-- | Baked-in data type constructors.
data DataTyCon

-- | <tt>Unit</tt> type constructor.
DataTyConUnit :: DataTyCon

-- | <tt>Bool</tt> type constructor.
DataTyConBool :: DataTyCon

-- | <tt>Nat</tt> type constructor.
DataTyConNat :: DataTyCon

-- | <tt>Int</tt> type constructor.
DataTyConInt :: DataTyCon

-- | <tt>Pair</tt> type constructor.
DataTyConPair :: DataTyCon

-- | <tt>List</tt> type constructor.
DataTyConList :: DataTyCon

-- | Primitive type constructors.
data PrimTyCon

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Baked-in data constructors.
data PrimDaCon

-- | Unit data constructor <tt>()</tt>.
PrimDaConUnit :: PrimDaCon

-- | <tt>B#</tt> data constructor.
PrimDaConBoolU :: PrimDaCon

-- | <tt>N#</tt> data constructor.
PrimDaConNatU :: PrimDaCon

-- | <tt>I#</tt> data constructor.
PrimDaConIntU :: PrimDaCon

-- | <tt>Pr</tt> data construct (pairs).
PrimDaConPr :: PrimDaCon

-- | <tt>Nil</tt> data constructor (lists).
PrimDaConNil :: PrimDaCon

-- | <tt>Cons</tt> data constructor (lists).
PrimDaConCons :: PrimDaCon

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Primitive cast between two types.
--   
--   The exact set of available casts is determined by the target platform.
--   For example, you can only promote a <tt>Nat#</tt> to a
--   <tt>Word32#</tt> on a 32-bit system. On a 64-bit system the
--   <tt>Nat#</tt> type is 64-bits wide, so casting it to a
--   <tt>Word32#</tt> would be a truncation.
data PrimCast

-- | Convert a value to a new representation with the same precision.
PrimCastConvert :: PrimCast

-- | Promote a value to one of similar or larger width, without loss of
--   precision.
PrimCastPromote :: PrimCast

-- | Truncate a value to a new width, possibly losing precision.
PrimCastTruncate :: PrimCast

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]


-- | Disciple Core Salt.
--   
--   This is what happens to <tt>C</tt> when you leave it out in the sun
--   for too long.
--   
--   Salt is a fragment of System-F2 that contains just those features that
--   can be easily mapped onto C or LLVM code. It has functions, case
--   expressions and primops, but no partial application, data types, or
--   nested functions. All operations on algebraic data need to have been
--   expanded to primitive store operations.
--   
--   Salt exposes raw store and control primops, so its possible for
--   functions written directly in Salt to corrupt the heap (if they are
--   wrong).
module DDC.Core.Salt

-- | Language profile for Disciple Core Salt.
profile :: Profile Name

-- | Convert a Disciple Core Salt module to C-source text.
seaOfSaltModule :: Show a => Bool -> Platform -> Module a Name -> Either (Error a) Doc

-- | Things that can go wrong when converting a Disciple Core Salt module
--   to C source text.
data Error a

-- | Variable is not in scope.
ErrorUndefined :: Bound Name -> Error a
errorVar :: Error a -> Bound Name

-- | Binder has BNone form, binds no variable.
ErrorBindNone :: Error a

-- | Invalid import.
ErrorImportInvalid :: Name -> Error a
errorImportName :: Error a -> Name

-- | A local variable has an invalid type.
ErrorTypeInvalid :: Type Name -> Error a
errorType :: Error a -> Type Name

-- | Modules must contain a top-level letrec.
ErrorNoTopLevelLetrec :: Module a Name -> Error a
errorModule :: Error a -> Module a Name

-- | An invalid function definition.
ErrorFunctionInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid function parameter.
ErrorParameterInvalid :: Bind Name -> Error a
errorBind :: Error a -> Bind Name

-- | An invalid function body.
ErrorBodyInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | A function body that does not explicitly pass control.
ErrorBodyMustPassControl :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid statement.
ErrorStmtInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid alternative.
ErrorAltInvalid :: Alt a Name -> Error a
errorAlt :: Error a -> Alt a Name

-- | An invalid RValue.
ErrorRValueInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid function argument.
ErrorArgInvalid :: Exp a Name -> Error a
errorExp :: Error a -> Exp a Name

-- | An invalid primitive call
ErrorPrimCallInvalid :: PrimOp -> [Exp a Name] -> Error a
errorPrimOp :: Error a -> PrimOp
errorArgs :: Error a -> [Exp a Name]

-- | Names of things used in Disciple Core Salt.
data Name

-- | A type or value variable.
NameVar :: String -> Name

-- | Constructor names.
NameCon :: String -> Name

-- | The abstract heap object type constructor.
NameObjTyCon :: Name

-- | A primitive type constructor.
NamePrimTyCon :: PrimTyCon -> Name

-- | A primitive operator.
NamePrimOp :: PrimOp -> Name

-- | The void literal.
NameLitVoid :: Name

-- | A boolean literal.
NameLitBool :: Bool -> Name

-- | A natural number literal.
NameLitNat :: Integer -> Name

-- | An integer number literal.
NameLitInt :: Integer -> Name

-- | A constructor tag literal.
NameLitTag :: Integer -> Name

-- | A <tt>WordN#</tt> literal, of the given width.
NameLitWord :: Integer -> Int -> Name

-- | Primitive type constructors.
data PrimTyCon

-- | <tt>Void#</tt> the Void type has no values.
PrimTyConVoid :: PrimTyCon

-- | <tt>Bool#</tt> unboxed booleans.
PrimTyConBool :: PrimTyCon

-- | <tt>Nat#</tt> natural numbers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
PrimTyConNat :: PrimTyCon

-- | <tt>Int#</tt> signed integers. Enough precision to count every object
--   in the heap, but NOT enough precision to count every byte of memory.
--   If N is the total number of objects that can exist in the heap, then
--   the range of <tt>Int#</tt> is at least (-N .. +N) inclusive.
PrimTyConInt :: PrimTyCon

-- | <tt>WordN#</tt> machine words of the given width.
PrimTyConWord :: Int -> PrimTyCon

-- | <tt>FloatN#</tt> floating point numbers of the given width.
PrimTyConFloat :: Int -> PrimTyCon

-- | <tt>VecN#</tt> a packed vector of N values. This is intended to have
--   kind (Data -&gt; Data), so we use concrete vector types like
--   <tt>Vec4</tt>.
PrimTyConVec :: Int -> PrimTyCon

-- | <tt>Addr#</tt> a relative or absolute machine address. Enough
--   precision to count every byte of memory. Unlike pointers below, an
--   absolute <tt>Addr#</tt> need not refer to memory owned by the current
--   process.
PrimTyConAddr :: PrimTyCon

-- | <tt>Ptr#</tt> should point to a well-formed object owned by the
--   current process.
PrimTyConPtr :: PrimTyCon

-- | <tt>Tag#</tt> data constructor tags. Enough precision to count every
--   possible alternative of an enumerated type.
PrimTyConTag :: PrimTyCon

-- | <tt>String#</tt> of UTF8 characters.
--   
--   These are primitive until we can define our own unboxed types.
PrimTyConString :: PrimTyCon

-- | Primitive operators implemented directly by the machine or runtime
--   system.
data PrimOp

-- | Arithmetic, logic, comparison and bit-wise operators.
PrimArith :: PrimArith -> PrimOp

-- | Casting between numeric types.
PrimCast :: PrimCast -> PrimOp

-- | Raw store access.
PrimStore :: PrimStore -> PrimOp

-- | Special function calling conventions.
PrimCall :: PrimCall -> PrimOp

-- | Non-functional control flow.
PrimControl :: PrimControl -> PrimOp

-- | Primitive cast between two types.
--   
--   The exact set of available casts is determined by the target platform.
--   For example, you can only promote a <tt>Nat#</tt> to a
--   <tt>Word32#</tt> on a 32-bit system. On a 64-bit system the
--   <tt>Nat#</tt> type is 64-bits wide, so casting it to a
--   <tt>Word32#</tt> would be a truncation.
data PrimCast

-- | Convert a value to a new representation with the same precision.
PrimCastConvert :: PrimCast

-- | Promote a value to one of similar or larger width, without loss of
--   precision.
PrimCastPromote :: PrimCast

-- | Truncate a value to a new width, possibly losing precision.
PrimCastTruncate :: PrimCast

-- | Check for a valid promotion primop.
primCastPromoteIsValid :: Platform -> PrimTyCon -> PrimTyCon -> Bool

-- | Check for valid truncation primop.
primCastTruncateIsValid :: Platform -> PrimTyCon -> PrimTyCon -> Bool

-- | Primitive ways of invoking a function, where control flow returns back
--   to the caller.
data PrimCall

-- | Tailcall a function
PrimCallTail :: Int -> PrimCall

-- | Primitive non-returning control flow.
data PrimControl

-- | Ungraceful failure -- just abort the program. This is called on
--   internal errors in the runtime system. There is no further debugging
--   info provided, so you'll need to look at the stack trace to debug it.
PrimControlFail :: PrimControl

-- | Return from the enclosing function with the given value.
PrimControlReturn :: PrimControl

-- | Raw access to the store.
data PrimStore

-- | Number of bytes needed to store a value of a primitive type.
PrimStoreSize :: PrimStore

-- | Log2 of number of bytes need to store a value of a primitive type.
PrimStoreSize2 :: PrimStore

-- | Create a heap of the given size. This must be called before
--   <tt>alloc#</tt> below, and has global side effect. Calling it twice in
--   the same program is undefined.
PrimStoreCreate :: PrimStore

-- | Check whether there are at least this many bytes still available on
--   the heap.
PrimStoreCheck :: PrimStore

-- | Force a garbage collection to recover at least this many bytes.
PrimStoreRecover :: PrimStore

-- | Allocate some space on the heap. There must be enough space available,
--   else undefined.
PrimStoreAlloc :: PrimStore

-- | Read a value from the store at the given address and offset.
PrimStoreRead :: PrimStore

-- | Write a value to the store at the given address and offset.
PrimStoreWrite :: PrimStore

-- | Add an offset in bytes to an address.
PrimStorePlusAddr :: PrimStore

-- | Subtract an offset in bytes from an address.
PrimStoreMinusAddr :: PrimStore

-- | Read a value from a pointer plus the given offset.
PrimStorePeek :: PrimStore

-- | Write a value to a pointer plus the given offset.
PrimStorePoke :: PrimStore

-- | Add an offset in bytes to a pointer.
PrimStorePlusPtr :: PrimStore

-- | Subtract an offset in bytes from a pointer.
PrimStoreMinusPtr :: PrimStore

-- | Convert an raw address to a pointer.
PrimStoreMakePtr :: PrimStore

-- | Convert a pointer to a raw address.
PrimStoreTakePtr :: PrimStore

-- | Cast between pointer types.
PrimStoreCastPtr :: PrimStore

-- | Primitive arithmetic, logic, and comparison opretors. We expect the
--   backend/machine to be able to implement these directly.
--   
--   For the Shift Right operator, the type that it is used at determines
--   whether it is an arithmetic (with sign-extension) or logical (no
--   sign-extension) shift.
data PrimArith

-- | Negation
PrimArithNeg :: PrimArith

-- | Addition
PrimArithAdd :: PrimArith

-- | Subtraction
PrimArithSub :: PrimArith

-- | Multiplication
PrimArithMul :: PrimArith

-- | Division
PrimArithDiv :: PrimArith

-- | Modulus
PrimArithMod :: PrimArith

-- | Remainder
PrimArithRem :: PrimArith

-- | Equality
PrimArithEq :: PrimArith

-- | Negated Equality
PrimArithNeq :: PrimArith

-- | Greater Than
PrimArithGt :: PrimArith

-- | Greater Than or Equal
PrimArithGe :: PrimArith

-- | Less Than
PrimArithLt :: PrimArith

-- | Less Than or Equal
PrimArithLe :: PrimArith

-- | Boolean And
PrimArithAnd :: PrimArith

-- | Boolean Or
PrimArithOr :: PrimArith

-- | Shift Left
PrimArithShl :: PrimArith

-- | Shift Right
PrimArithShr :: PrimArith

-- | Bit-wise And
PrimArithBAnd :: PrimArith

-- | Bit-wise Or
PrimArithBOr :: PrimArith

-- | Bit-wise eXclusive Or
PrimArithBXOr :: PrimArith

-- | Read the name of a variable, constructor or literal.
readName :: String -> Maybe Name

-- | Lex a string to tokens, using primitive names.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]
