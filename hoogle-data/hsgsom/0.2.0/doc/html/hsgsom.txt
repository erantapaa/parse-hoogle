-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the GSOM clustering algorithm.
--   
--   The growing self organising map (GSOM) algorithm is a clustering
--   algorithm working on a set of n-dimensional numeric input vectors.
--   It's output is a network of nodes laid out in two dimensions where
--   each node has a weight vector associated with it. This weight vector
--   has the same dimension as the input vectors and is meant to be
--   intepreted as a cluster center, i.e. it represents those input vectors
--   whose distance to the node's weight vector is minimal when compared to
--   the distance to the other nodes weight vectors. See
--   <a>http://en.wikipedia.org/wiki/GSOM</a> for an explanation of the
--   algorithm. The algorithm was introduced in: Alahakoon, D., Halgamuge,
--   S. K. and Sirinivasan, B. (2000) Dynamic Self Organizing Maps With
--   Controlled Growth for Knowledge Discovery, IEEE Transactions on Neural
--   Networks, Special Issue on Knowledge Discovery and Data Mining, 11, pp
--   601-614.
@package hsgsom
@version 0.2.0


-- | The GSOM algorithm works on numerical input vectors. These input
--   vectors are internally represented as lists of <tt><a>Double</a></tt>s
--   and this module contains the functions working on these.
module Data.Datamining.Clustering.Gsom.Input

-- | The bounds of a list of inputs. Having the tuple <tt>(a,b)</tt> at
--   index <tt>i</tt> in <tt>bounds</tt> means that the value at index
--   <tt>i</tt> of each of the input vectors from the inputs which where
--   used to calculate <tt>bounds</tt> is from the intervall
--   <tt>[a,b]</tt>.
type Bounds = [(Double, Double)]

-- | Input vectors are represented as lists of Doubles.
type Input = [Double]
type Inputs = [Input]

-- | Calculates the bounds of the input vector components.
bounds :: Inputs -> Bounds

-- | Calculating the dimension of a given set of inputs just means finding
--   the length of the longest input vector.
dimension :: Inputs -> Int

-- | Normalizes input vectors. <tt><a>normalize</a> inputs</tt> takes the
--   given list of input vectors <tt>inputs</tt> and returns a list of
--   input vectors where each component is in <tt>[0,1]</tt>. If you want
--   to unnormalize the input vectors use <tt><a>bounds</a></tt> and
--   <tt><a>unnormalize</a></tt>.
normalize :: Bounds -> Inputs -> Inputs

-- | Unnormalizes the given input vectors <tt>inputs</tt> assuming that
--   it's bounds previously where <tt>bounds</tt>.
unnormalize :: Bounds -> Inputs -> Inputs

-- | <tt><a>distance</a> i1 i2</tt> calculates the euclidean distance
--   between <tt>i1</tt> and <tt>i2</tt>. If <tt>i1</tt> and <tt>i2</tt>
--   have different lengths, excess values are ignored.
distance :: Input -> Input -> Double
(*.) :: Input -> Double -> Input

-- | Multiplication of an input vector with a scalar.
(.*) :: Double -> Input -> Input

-- | Subtraction and addition of vectors between each other.
(<+>) :: Input -> Input -> Input
(<->) :: Input -> Input -> Input


-- | The network created by the GSOM algorithm is layed out in two
--   dimensions. Thus one needs to assign two dimensional coordinates to
--   the nodes of the network and for a clustering to the clusters.
--   
--   The types defining these coordinates and the functions to handle them
--   belong into this module.
module Data.Datamining.Clustering.Gsom.Coordinates
type Coordinates = (Int, Int)
type Direction = Int
type Directions = [Int]

-- | The list of supported directions. Since we are only dealing with
--   hexagonal lattices, there are only six possible directions.
directions :: Directions

-- | <tt><a>neighbour</a> location direction</tt> calculates the
--   coordinates of the neighbour of node with location <tt>location</tt>
--   in direction <tt>direction</tt>.
neighbour :: Coordinates -> Direction -> Coordinates

-- | <tt><a>neighbourCoordinates</a> point</tt> calculates the list of
--   coordinates which are directly adjacent to <tt>point</tt>.
neighbourCoordinates :: Coordinates -> [Coordinates]


-- | The network of nodes which is build by GSOM consists if nodes of type
--   <tt><a>Node</a></tt> and this module contains the definition if this
--   type along with most of the functions altering or working on them.
module Data.Datamining.Clustering.Gsom.Node

-- | A node's neighbours are stored in fields of type <tt>Neighbours</tt>.
type Neighbours = [TVar Node]

-- | The type of neighbourhoods. Wherever a neighbourhood of a node is
--   neede, this type should be used. A <tt>Neighbourhood</tt> consits of a
--   list of pairs of nodes and their discrete grid distance from the
--   source of the neighbourhood. The source node is the only one with
--   distance <tt>0</tt> while immediate neighbours get distance one and so
--   on.
type Neighbourhood = [(Int, Node)]

-- | The type of nodes of a gsom.
data Node

-- | They're either Leafs, signalling neighbours of boundary nodes
Leaf :: Node

-- | or they are actual nodes with a few associated values and a list of
--   neighbouring nodes.
Node :: Coordinates -> TVar Double -> TVar Input -> Neighbours -> Node

-- | Used to uniquely identify nodes. This is also the actual location of
--   the node if the lattice it belongs to is beeing laid out in the two
--   dimensional plane and it is used to store the node in the map
--   comprising the lattice.
location :: Node -> Coordinates

-- | The quantization error the node has accumulated so far.
quantizationError :: Node -> TVar Double

-- | The node's weight vector. This is the center of the voronoi cell the
--   node represents.
weights :: Node -> TVar Input

-- | The node's neighbours.
neighbours :: Node -> Neighbours
type Nodes = [Node]
isLeaf :: Node -> Bool

-- | <tt><a>isLeaf</a> node</tt> returns <tt><a>True</a></tt> if the given
--   node is a <tt><a>Leaf</a></tt> and <tt><a>False</a></tt> otherwise.
isNode :: Node -> Bool

-- | <tt><a>isNode</a> node</tt> returns <tt><a>False</a></tt> if the given
--   node is a <tt><a>Leaf</a></tt> and <tt><a>True</a></tt> otherwise.
--   
--   Calculates the neighbourhood of the given size of the given node. A
--   neighbourhood size of <tt>0</tt> means that only the given node will
--   be an element of the returned set while a size of one will return the
--   given node and it's immediate neighbours and so on. It's not very
--   efficient so you shouldn't try big neihbourhood sizes. The returned
--   neighbourhood always includes <tt>node</tt>.
neighbourhood :: Node -> Int -> STM Neighbourhood

-- | When a new node is spawned we need to calculate it's new weight
--   vector. If the new node is spawned from parent p in direction d and p
--   has a neighbour n in the direction d' opposite to d then the new
--   weight vector nw is calculated according to the formula:
--   
--   <ul>
--   <li><tt>nw = 2 * (<a>weights</a> p) - (<a>weights</a> n)</tt>.</li>
--   </ul>
--   
--   In all other cases there exists exactly one neighbour of the new node.
--   Let this neighbour be called n and let d' be the direction in which we
--   have to go to reach this neighbour from the new node. Let s then be
--   the child of the new node's parent p in direction d'. The new weights
--   are then calculated according to the formula:
--   
--   <ul>
--   <li><tt>nw = p + n - s</tt>.</li>
--   </ul>
newWeight :: Node -> Int -> STM ()

-- | <tt><a>node</a> id weights neighbours</tt> creates a node with the
--   specified parameters and initial quantization error of <tt>0</tt>.
node :: Coordinates -> Input -> Neighbours -> STM Node

-- | <tt><a>propagate</a> node</tt> propagates the accumulated error of the
--   given <tt>node</tt> to it's neighbours.
propagate :: Node -> Nodes -> STM ()
putNode :: Node -> IO [String]
boundaryNode :: Node -> STM Bool

-- | <tt><a>unwrappedNeighbours</a> node</tt> returns the list of
--   neighbours of the given <tt>node</tt>. Note that neighbours is
--   unwrapped, i.e. the returned list hast type <tt><a>Nodes</a></tt> not
--   <tt>TVar <a>Nodes</a></tt>.
unwrappedNeighbours :: Node -> STM Nodes

-- | <tt><a>update</a> input learning_rate kernel neighbour</tt> updates
--   the weights of the <tt>neighbour</tt> according to the formula:
--   
--   <ul>
--   <li><pre>weight -&gt; weight + learning_rate * (kernel d) (input -
--   weight)</pre></li>
--   </ul>
update :: Input -> Double -> (Int -> Double) -> (Int, Node) -> STM ()

-- | <tt>updateError node input</tt> updates the
--   <tt><a>quantizationError</a></tt> of <tt>node</tt>. The new error is
--   just the old error plus the distance of the <tt>node</tt>'s weight
--   vector from <tt>input</tt>.
updateError :: Node -> Input -> STM ()
instance Eq Node


-- | The type <tt><a>Lattice</a></tt> is the type of the network build by
--   the GSOM algorithm. This type and most of the functions dealing with
--   it are defined in this module.
module Data.Datamining.Clustering.Gsom.Lattice

-- | The lattice type. Since global access to nodes is needed they're
--   stored in a <tt>Data.Map</tt> indexed by their coordinates.
type Lattice = Map Coordinates (TVar Node)

-- | <tt><tt>newNormalized</tt> dimension</tt> creates a new minimal
--   lattice where weights are initialized with all components having the
--   value <tt>0.5</tt> the and with the weight vectors having length
--   <tt>dimension</tt>.
newCentered :: Int -> IO Lattice

-- | <tt><a>newRandom</a> g dimension</tt> creates a new minimal lattice
--   where weights are randomly initialized with values between 0 and 1
--   using the random number generator <tt>g</tt> and with the weight
--   vectors having the specified <tt>dimension</tt>.
newRandom :: RandomGen g => g -> Int -> IO Lattice

-- | <tt><a>bmu</a> input lattice</tt> returns the best matching unit i.e.
--   the node with minimal distance to the given input vector.
bmu :: Input -> Lattice -> STM Node

-- | <tt><a>grow</a> lattice node</tt> will create new neighbours for every
--   Leaf neighbour of the given <tt>node</tt> and add the created nodes to
--   <tt>lattice</tt>. It will return the list of spawned nodes and the new
--   lattice containing every node created in the process of spawning.
grow :: Lattice -> Node -> STM (Lattice, Nodes)

-- | <tt><a>vent</a> lattice node growthThreshold</tt> will check the
--   accumulated error of the <tt>node</tt> against the given
--   <tt>growthThreshold</tt> and will do nothing if the errror value is
--   below the growth threshhold. Otherwise it will either spawn new nodes
--   or it will propagate the accumulated error value to it's neighbours,
--   depending on whether the node is a boundary node or not. If new nodes
--   are spawned they will be added to <tt>lattice</tt> and returned as the
--   second component of the resulting pair.
vent :: Lattice -> Node -> Double -> STM (Lattice, [Node])

-- | Returns the nodes stored in lattice.
nodes :: Lattice -> STM Nodes
putLattice :: Lattice -> IO String
putWeights :: Lattice -> IO String


-- | The GSOM Algorithm can be split up in multiple sequentially executed
--   <tt><a>Phase</a></tt>s. Each of these phases makes a certain number of
--   passes over the inputs. While doing so each <tt><a>phase</a></tt>
--   modifies a given <tt><a>Lattice</a></tt> according to a certain set of
--   specified parameters. This module contains the definition of the
--   <tt><a>Phase</a></tt> type, a few default instances and the functions
--   needed to run a single <tt><a>phase</a></tt> or to <tt><a>run</a></tt>
--   a sequence of <tt><a>Phase</a></tt>s.
module Data.Datamining.Clustering.Gsom.Phase

-- | This datatype encapsulates all the parameters needed to be known to
--   run one phase of the GSOM algorithm.
data Phase
Phase :: Int -> Int -> LearningRate -> Kernel -> Bool -> Double -> Phase

-- | The number of passes which are to be made over the input vectors.
--   Since each step of the phase consumes one input vector, the overall
--   number of steps the phase will have will be:
--   
--   <ul>
--   <li><pre>steps = passes * length inputs</pre></li>
--   </ul>
passes :: Phase -> Int

-- | The initial size of the neighbourhood affected by weight adaption.
--   This will decrease linearly while the phase is executed.
neighbourhoodSize :: Phase -> Int

-- | The function used to calculate the learning rate in each of the
--   phase's steps. During each step <tt>learninRate currentStep
--   maxSteps</tt> is fed the number (starting from zero) of the current
--   step as the first argument and the total number of steps the phase
--   will have as the second argument to calculate the learning rate which
--   will be in effect for this phase.
learningRate :: Phase -> LearningRate

-- | The kernel function. It is used in conjunction with the learning rate
--   to adjust weight adaption. <tt>kernel currentNeighbourhoodsize
--   gridDistance</tt> should take the neighbourhood size which is in
--   effect during the current step and a nodes grid distance from the
--   winning node. The neighbourhood size will be a real number due to the
--   linear decrease.
kernel :: Phase -> Kernel

-- | The <tt>grow</tt> flag determines whether this is a growing phase or
--   not. If this is <tt>False</tt> then no new nodes will be grown.
grow :: Phase -> Bool

-- | The spread factor is used to calculate the growth threshold according
--   to the formula:
--   
--   <ul>
--   <li><pre>GT = - sqrt(<tt>d</tt>)*ln(<a>spreadFactor</a>)</pre></li>
--   </ul>
--   
--   where <tt>d</tt> is the input dimension.
spreadFactor :: Phase -> Double
type Phases = [Phase]

-- | The default first phase is the only growing phase. It makes 5 passes
--   over the input, uses an initial learning rate of 0.1 and a starting
--   neighbourhood size of 3. The <tt><a>spreadFactor</a></tt> is set to
--   0.1.
defaultFirst :: Phase

-- | The default for the second phase is a smoothing phase making 50 passes
--   over the input vectors with a learning rate of 0.05 and an initial
--   neighbourhood size of 2. Since there is no node growth the
--   <tt><a>spreadFactor</a></tt> is ignored and thus set to 0.
defaultSecond :: Phase

-- | The default for the third and last phase is a smoothing phase making
--   50 passes over the input vectors with a learning rate of 0.01 and an
--   initial neighbourhood size of 1. Since there is no node growth the
--   <tt><a>spreadFactor</a></tt> is ignored and thus set to 0.
defaultThird :: Phase

-- | This is the list of the three default phases of the GSOM algorithm.
defaults :: Phases

-- | Calculates the growth threshold as explained in the documentation for
--   <tt><a>Phase</a></tt>.
growthThreshold :: Phase -> Int -> Double

-- | <tt><a>phase</a> parameters inputs</tt> will update the given
--   <tt>lattice</tt> by executing one phase of the GSOM algorithm with the
--   given <tt>inputs</tt> and <tt>parameters</tt>.
phase :: Phase -> Lattice -> Inputs -> IO Lattice

-- | Since a complete run of the GSOM algorithm means running a number of
--   <tt><a>Phases</a></tt> this is usually the main function used. <tt>run
--   phases lattice inputs</tt> runs the GSOM algorithm by running the
--   <tt>phases</tt> in the order specified, each time making passes over
--   <tt>inputs</tt> and using the produced <tt><a>Lattice</a></tt> to as
--   an argument to the next phase. The initial <tt><a>Lattice</a></tt>,
--   <tt>lattice</tt> may be constructed with the <tt><a>newRandom</a></tt>
--   and the <tt><a>newCentered</a></tt> functions.
run :: Phases -> Lattice -> Inputs -> IO Lattice
data Kernel

-- | The bubble kernel is essentially the identity, i.e. it has no effect.
Bubble :: Kernel

-- | Let <tt>s</tt> be the neighbourhood size currently in effect and
--   <tt>d</tt> be the grid-distance of the current node to the winning
--   node then this kernel calculates a factor to control weight adaption
--   with the following formula:
--   
--   <ul>
--   <li><pre>gaussian s d = exp(d^2/(2*s^2))</pre></li>
--   </ul>
Gaussian :: Kernel

-- | Returns the kernel function associated with the given kernel.
kernelFunction :: Kernel -> Double -> Int -> Double
data LearningRate

-- | The linear learning rate reduction function. If you supply it with the
--   initial learning rate <tt>lr</tt> it uses the following formula where
--   <tt>step</tt> is the current step the phase is in and <tt>steps</tt>
--   is the overall number of steps the phase will take:
--   
--   <ul>
--   <li><pre>linear lr step steps = lr * (1-step/steps)</pre></li>
--   </ul>
Linear :: Double -> LearningRate

-- | The inverse time learning rate reduction function. Given an initial
--   learning rate of <tt>lr</tt>, a maximum number of steps of
--   <tt>steps</tt> and the current step number beeing <tt>step</tt>, the
--   formula is:
--   
--   <ul>
--   <li><pre>inverseAge lr step steps = lr * steps / (steps + 100 *
--   step)</pre></li>
--   </ul>
InverseAge :: Double -> LearningRate

-- | Returns the learning rate adaption function associated with the given
--   type of learning rate.
adaption :: LearningRate -> Int -> Int -> Double
instance Read LearningRate
instance Show LearningRate
instance Eq Kernel
instance Enum Kernel
instance Ord Kernel
instance Read Kernel
instance Show Kernel
instance Read Phase
instance Show Phase


-- | This module contains the necessary modifications of some functions to
--   parallelise a phase of the GSOM Algorithm by using multiple threads.
module Data.Datamining.Clustering.Gsom.Parallel

-- | <tt><a>phase</a> n parameters inputs</tt> will update the given
--   <tt>lattice</tt> by executing one phase of the GSOM algorithm with the
--   given <tt>inputs</tt> and <tt>parameters</tt> using <tt>n</tt>
--   threads.
phase :: Int -> Phase -> Lattice -> Inputs -> IO Lattice

-- | Since a complete run of the GSOM algorithm means running a number of
--   <tt><a>Phases</a></tt> this is usually the main function used. <tt>run
--   n phases lattice inputs</tt> runs the GSOM algorithm by running the
--   <tt>phases</tt> in the order specified, each time making passes over
--   <tt>inputs</tt> and using the produced <tt><a>Lattice</a></tt> as an
--   argument to the next phase. The phases are run using <tt>n</tt> worker
--   threads. The initial <tt><a>Lattice</a></tt>, <tt>lattice</tt> may be
--   constructed with the <tt><a>newRandom</a></tt> and the
--   <tt><a>newCentered</a></tt> functions.
run :: Int -> Phases -> Lattice -> Inputs -> IO Lattice


-- | This module should contain everything you need to run the GSOM
--   clustering algorithm. It collects and re-exports all important and
--   needed functions from moduls lower in the hirarchy.
--   
--   Ideally you should never need to look at those modules. If you do need
--   to do this, it is a design failure and I would appreciate it if you
--   would drop me a note.
module Data.Datamining.Clustering.Gsom

-- | Input vectors are represented as lists of Doubles.
type Input = [Double]
type Inputs = [Input]

-- | Calculating the dimension of a given set of inputs just means finding
--   the length of the longest input vector.
dimension :: Inputs -> Int

-- | The bounds of a list of inputs. Having the tuple <tt>(a,b)</tt> at
--   index <tt>i</tt> in <tt>bounds</tt> means that the value at index
--   <tt>i</tt> of each of the input vectors from the inputs which where
--   used to calculate <tt>bounds</tt> is from the intervall
--   <tt>[a,b]</tt>.
type Bounds = [(Double, Double)]

-- | Calculates the bounds of the input vector components.
bounds :: Inputs -> Bounds

-- | Normalizes input vectors. <tt><a>normalize</a> inputs</tt> takes the
--   given list of input vectors <tt>inputs</tt> and returns a list of
--   input vectors where each component is in <tt>[0,1]</tt>. If you want
--   to unnormalize the input vectors use <tt><a>bounds</a></tt> and
--   <tt><a>unnormalize</a></tt>.
normalize :: Bounds -> Inputs -> Inputs

-- | Unnormalizes the given input vectors <tt>inputs</tt> assuming that
--   it's bounds previously where <tt>bounds</tt>.
unnormalize :: Bounds -> Inputs -> Inputs

-- | <tt><a>distance</a> i1 i2</tt> calculates the euclidean distance
--   between <tt>i1</tt> and <tt>i2</tt>. If <tt>i1</tt> and <tt>i2</tt>
--   have different lengths, excess values are ignored.
distance :: Input -> Input -> Double
(*.) :: Input -> Double -> Input

-- | Multiplication of an input vector with a scalar.
(.*) :: Double -> Input -> Input

-- | Subtraction and addition of vectors between each other.
(<+>) :: Input -> Input -> Input
(<->) :: Input -> Input -> Input
type Coordinates = (Int, Int)

-- | The type of nodes of a gsom.
data Node

-- | They're either Leafs, signalling neighbours of boundary nodes
Leaf :: Node

-- | or they are actual nodes with a few associated values and a list of
--   neighbouring nodes.
Node :: Coordinates -> TVar Double -> TVar Input -> Neighbours -> Node

-- | Used to uniquely identify nodes. This is also the actual location of
--   the node if the lattice it belongs to is beeing laid out in the two
--   dimensional plane and it is used to store the node in the map
--   comprising the lattice.
location :: Node -> Coordinates

-- | The quantization error the node has accumulated so far.
quantizationError :: Node -> TVar Double

-- | The node's weight vector. This is the center of the voronoi cell the
--   node represents.
weights :: Node -> TVar Input

-- | The node's neighbours.
neighbours :: Node -> Neighbours
type Nodes = [Node]

-- | A node's neighbours are stored in fields of type <tt>Neighbours</tt>.
type Neighbours = [TVar Node]

-- | The type of neighbourhoods. Wherever a neighbourhood of a node is
--   neede, this type should be used. A <tt>Neighbourhood</tt> consits of a
--   list of pairs of nodes and their discrete grid distance from the
--   source of the neighbourhood. The source node is the only one with
--   distance <tt>0</tt> while immediate neighbours get distance one and so
--   on.
type Neighbourhood = [(Int, Node)]

-- | <tt><a>node</a> id weights neighbours</tt> creates a node with the
--   specified parameters and initial quantization error of <tt>0</tt>.
node :: Coordinates -> Input -> Neighbours -> STM Node

-- | <tt><a>propagate</a> node</tt> propagates the accumulated error of the
--   given <tt>node</tt> to it's neighbours.
propagate :: Node -> Nodes -> STM ()

-- | <tt><a>update</a> input learning_rate kernel neighbour</tt> updates
--   the weights of the <tt>neighbour</tt> according to the formula:
--   
--   <ul>
--   <li><pre>weight -&gt; weight + learning_rate * (kernel d) (input -
--   weight)</pre></li>
--   </ul>
update :: Input -> Double -> (Int -> Double) -> (Int, Node) -> STM ()

-- | <tt>updateError node input</tt> updates the
--   <tt><a>quantizationError</a></tt> of <tt>node</tt>. The new error is
--   just the old error plus the distance of the <tt>node</tt>'s weight
--   vector from <tt>input</tt>.
updateError :: Node -> Input -> STM ()
isLeaf :: Node -> Bool

-- | <tt><a>isLeaf</a> node</tt> returns <tt><a>True</a></tt> if the given
--   node is a <tt><a>Leaf</a></tt> and <tt><a>False</a></tt> otherwise.
isNode :: Node -> Bool

-- | <tt><a>isNode</a> node</tt> returns <tt><a>False</a></tt> if the given
--   node is a <tt><a>Leaf</a></tt> and <tt><a>True</a></tt> otherwise.
--   
--   Calculates the neighbourhood of the given size of the given node. A
--   neighbourhood size of <tt>0</tt> means that only the given node will
--   be an element of the returned set while a size of one will return the
--   given node and it's immediate neighbours and so on. It's not very
--   efficient so you shouldn't try big neihbourhood sizes. The returned
--   neighbourhood always includes <tt>node</tt>.
neighbourhood :: Node -> Int -> STM Neighbourhood

-- | <tt><a>unwrappedNeighbours</a> node</tt> returns the list of
--   neighbours of the given <tt>node</tt>. Note that neighbours is
--   unwrapped, i.e. the returned list hast type <tt><a>Nodes</a></tt> not
--   <tt>TVar <a>Nodes</a></tt>.
unwrappedNeighbours :: Node -> STM Nodes
putNode :: Node -> IO [String]

-- | The lattice type. Since global access to nodes is needed they're
--   stored in a <tt>Data.Map</tt> indexed by their coordinates.
type Lattice = Map Coordinates (TVar Node)

-- | <tt><tt>newNormalized</tt> dimension</tt> creates a new minimal
--   lattice where weights are initialized with all components having the
--   value <tt>0.5</tt> the and with the weight vectors having length
--   <tt>dimension</tt>.
newCentered :: Int -> IO Lattice

-- | <tt><a>newRandom</a> g dimension</tt> creates a new minimal lattice
--   where weights are randomly initialized with values between 0 and 1
--   using the random number generator <tt>g</tt> and with the weight
--   vectors having the specified <tt>dimension</tt>.
newRandom :: RandomGen g => g -> Int -> IO Lattice

-- | <tt><a>bmu</a> input lattice</tt> returns the best matching unit i.e.
--   the node with minimal distance to the given input vector.
bmu :: Input -> Lattice -> STM Node

-- | Returns the nodes stored in lattice.
nodes :: Lattice -> STM Nodes
putLattice :: Lattice -> IO String
putWeights :: Lattice -> IO String

-- | Dumps the given input vectors to a string which can be fed to gnuplot.
--   Just write the string to a file and write <tt>plot "file"</tt> in
--   gnuplot.
dumpInputs :: Inputs -> String

-- | <tt><a>renderScript</a> c path</tt> expects to be given a
--   <a>Clustering</a> <tt>c</tt> having 2 dimensional <a>center</a>s and
--   will call <a>error</a> if that's not the case. On success it will save
--   a python script to <tt>path</tt>.py. If this python script is run it
--   will in turn save a PDF image to <tt>path</tt>.pdf. The image will
--   contain the graph induced by <tt>c</tt> with each node (cluster
--   center) placed positioned according to the <tt>c</tt>'s center (weight
--   vector). The python script will depend on the <tt>networkx</tt> and
--   <tt>mathplotlib</tt> python packages being installed. I know that this
--   is relatively clunky, but since I haven't found a better way of
--   creating an image of a graph with known node positions, this is the
--   way I chose to go.
renderScript :: Clustering -> String -> IO ()

-- | This datatype encapsulates all the parameters needed to be known to
--   run one phase of the GSOM algorithm.
data Phase
Phase :: Int -> Int -> LearningRate -> Kernel -> Bool -> Double -> Phase

-- | The number of passes which are to be made over the input vectors.
--   Since each step of the phase consumes one input vector, the overall
--   number of steps the phase will have will be:
--   
--   <ul>
--   <li><pre>steps = passes * length inputs</pre></li>
--   </ul>
passes :: Phase -> Int

-- | The initial size of the neighbourhood affected by weight adaption.
--   This will decrease linearly while the phase is executed.
neighbourhoodSize :: Phase -> Int

-- | The function used to calculate the learning rate in each of the
--   phase's steps. During each step <tt>learninRate currentStep
--   maxSteps</tt> is fed the number (starting from zero) of the current
--   step as the first argument and the total number of steps the phase
--   will have as the second argument to calculate the learning rate which
--   will be in effect for this phase.
learningRate :: Phase -> LearningRate

-- | The kernel function. It is used in conjunction with the learning rate
--   to adjust weight adaption. <tt>kernel currentNeighbourhoodsize
--   gridDistance</tt> should take the neighbourhood size which is in
--   effect during the current step and a nodes grid distance from the
--   winning node. The neighbourhood size will be a real number due to the
--   linear decrease.
kernel :: Phase -> Kernel

-- | The <tt>grow</tt> flag determines whether this is a growing phase or
--   not. If this is <tt>False</tt> then no new nodes will be grown.
grow :: Phase -> Bool

-- | The spread factor is used to calculate the growth threshold according
--   to the formula:
--   
--   <ul>
--   <li><pre>GT = - sqrt(<tt>d</tt>)*ln(<a>spreadFactor</a>)</pre></li>
--   </ul>
--   
--   where <tt>d</tt> is the input dimension.
spreadFactor :: Phase -> Double
type Phases = [Phase]
data Kernel

-- | The bubble kernel is essentially the identity, i.e. it has no effect.
Bubble :: Kernel

-- | Let <tt>s</tt> be the neighbourhood size currently in effect and
--   <tt>d</tt> be the grid-distance of the current node to the winning
--   node then this kernel calculates a factor to control weight adaption
--   with the following formula:
--   
--   <ul>
--   <li><pre>gaussian s d = exp(d^2/(2*s^2))</pre></li>
--   </ul>
Gaussian :: Kernel
data LearningRate

-- | The linear learning rate reduction function. If you supply it with the
--   initial learning rate <tt>lr</tt> it uses the following formula where
--   <tt>step</tt> is the current step the phase is in and <tt>steps</tt>
--   is the overall number of steps the phase will take:
--   
--   <ul>
--   <li><pre>linear lr step steps = lr * (1-step/steps)</pre></li>
--   </ul>
Linear :: Double -> LearningRate

-- | The inverse time learning rate reduction function. Given an initial
--   learning rate of <tt>lr</tt>, a maximum number of steps of
--   <tt>steps</tt> and the current step number beeing <tt>step</tt>, the
--   formula is:
--   
--   <ul>
--   <li><pre>inverseAge lr step steps = lr * steps / (steps + 100 *
--   step)</pre></li>
--   </ul>
InverseAge :: Double -> LearningRate

-- | The default first phase is the only growing phase. It makes 5 passes
--   over the input, uses an initial learning rate of 0.1 and a starting
--   neighbourhood size of 3. The <tt><a>spreadFactor</a></tt> is set to
--   0.1.
defaultFirst :: Phase

-- | The default for the second phase is a smoothing phase making 50 passes
--   over the input vectors with a learning rate of 0.05 and an initial
--   neighbourhood size of 2. Since there is no node growth the
--   <tt><a>spreadFactor</a></tt> is ignored and thus set to 0.
defaultSecond :: Phase

-- | The default for the third and last phase is a smoothing phase making
--   50 passes over the input vectors with a learning rate of 0.01 and an
--   initial neighbourhood size of 1. Since there is no node growth the
--   <tt><a>spreadFactor</a></tt> is ignored and thus set to 0.
defaultThird :: Phase

-- | This is the list of the three default phases of the GSOM algorithm.
defaults :: Phases

-- | <tt><a>phase</a> parameters inputs</tt> will update the given
--   <tt>lattice</tt> by executing one phase of the GSOM algorithm with the
--   given <tt>inputs</tt> and <tt>parameters</tt>.
phase :: Phase -> Lattice -> Inputs -> IO Lattice

-- | Since a complete run of the GSOM algorithm means running a number of
--   <tt><a>Phases</a></tt> this is usually the main function used. <tt>run
--   phases lattice inputs</tt> runs the GSOM algorithm by running the
--   <tt>phases</tt> in the order specified, each time making passes over
--   <tt>inputs</tt> and using the produced <tt><a>Lattice</a></tt> to as
--   an argument to the next phase. The initial <tt><a>Lattice</a></tt>,
--   <tt>lattice</tt> may be constructed with the <tt><a>newRandom</a></tt>
--   and the <tt><a>newCentered</a></tt> functions.
run :: Phases -> Lattice -> Inputs -> IO Lattice

-- | The clusters generated by GSOM basically consist of three things:
data Cluster
Cluster :: Input -> [Int] -> Coordinates -> Cluster

-- | the vector which best represents all the vectors belonging to this
--   cluster.
center :: Cluster -> Input

-- | The indices of the input vectors belonging to this cluster. That means
--   a cluster is always relative to a set of <tt><a>Inputs</a></tt>
contents :: Cluster -> [Int]

-- | the coordinates of this cluster
coordinates :: Cluster -> Coordinates

-- | The final clustering which is the result of the GSOM algorithm is a
--   <tt><tt>Data.Map</tt></tt> mapping <tt><a>Coordinates</a></tt> to
--   <tt><a>Cluster</a></tt>s.
type Clustering = Map Coordinates Cluster

-- | <tt><a>cluster</a> inputs clustering</tt> clusters the given
--   <tt>inputs</tt> according to the centers of the clusters in
--   <tt>clustering</tt>. That means for each input <tt>i</tt> from
--   <tt>inputs</tt> the index of <tt>i</tt> is added to the contents of
--   the cluster center to which <tt>i</tt> has minimal distance. TODO:
--   Implement tiebreaker.
cluster :: Inputs -> Clustering -> Clustering

-- | Computes a clustering induced by the given lattice.
--   
--   <tt><a>clustering</a> lattice</tt> uses the <tt><a>weights</a></tt> of
--   the <tt><a>nodes</a></tt> stored in <tt>lattice</tt> to generate
--   <a>cluster</a>s and returns the <tt><a>Clustering</a></tt> storing
--   these <a>cluster</a>s. Each non leaf node <tt>n</tt> in
--   <tt>lattice</tt> corresponds to one <a>cluster</a> <tt>c</tt> with
--   <tt>(<a>coordinates</a> c = <a>location</a> n)</tt> and with
--   <tt><a>center</a> c</tt> equal to the weight vector of <tt>n</tt>.
--   Each generated <a>cluster</a>'s <a>contents</a> are empty. Use the
--   <a>cluster</a> function with a set of inputs to obtain a clustering
--   where each <a>Cluster</a>'s <a>contents</a> is a list of the indices
--   of the input points belonging to this <a>cluster</a>.
clustering :: Lattice -> IO Clustering

-- | <tt><a>nearestCluster</a> input clustering</tt> returns the cluster
--   which has the center with the smallest distance to <tt>input</tt>.
nearestCluster :: Input -> Clustering -> Cluster
instance Read Cluster
instance Show Cluster
