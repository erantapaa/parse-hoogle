-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic support for programming with names and binders
--   
--   Specify the binding structure of your data type with an expressive set
--   of type combinators, and Unbound handles the rest! Automatically
--   derives alpha-equivalence, free variable calculation, capture-avoiding
--   substitution, and more. See <a>Unbound.LocallyNameless</a> to get
--   started.
@package unbound
@version 0.4.3.1


-- | A slow, but hopefully correct implementation of permutations.
module Unbound.PermM

-- | A <i>permutation</i> is a bijective function from names to names which
--   is the identity on all but a finite set of names. They form the basis
--   for nominal approaches to binding, but can also be useful in general.
newtype Perm a
Perm :: (Map a a) -> Perm a
permValid :: Ord a => Perm a -> Bool

-- | Create a permutation which swaps two elements.
single :: Ord a => a -> a -> Perm a

-- | Compose two permutations. The right-hand permutation will be applied
--   first.
compose :: Ord a => Perm a -> Perm a -> Perm a

-- | Apply a permutation to an element of the domain.
apply :: Ord a => Perm a -> a -> a

-- | The <i>support</i> of a permutation is the set of elements which are
--   not fixed.
support :: Ord a => Perm a -> [a]

-- | Is this the identity permutation?
isid :: Ord a => Perm a -> Bool

-- | <i>Join</i> two permutations by taking the union of their relation
--   graphs. Fail if they are inconsistent, i.e. map the same element to
--   two different elements.
join :: Ord a => Perm a -> Perm a -> Maybe (Perm a)

-- | The empty (identity) permutation.
empty :: Perm a

-- | Restrict a permutation to a certain domain.
restrict :: Ord a => Perm a -> [a] -> Perm a

-- | <tt>mkPerm l1 l2</tt> creates a permutation that sends <tt>l1</tt> to
--   <tt>l2</tt>. Fail if there is no such permutation, either because the
--   lists have different lengths or because they are inconsistent (which
--   can only happen if <tt>l1</tt> or <tt>l2</tt> have repeated elements).
mkPerm :: Ord a => [a] -> [a] -> Maybe (Perm a)
instance Show a => Show (PartialPerm a)
instance Ord a => Monoid (Perm a)
instance Show a => Show (Perm a)
instance Ord a => Eq (Perm a)


-- | Various utilities for the Unbound library.
module Unbound.Util

-- | Collections are foldable types that support empty, singleton, union,
--   and map operations. The result of a free variable calculation may be
--   any collection. Instances are provided for lists, sets, and multisets.
class Foldable f => Collection f
emptyC :: Collection f => f a
singleton :: Collection f => a -> f a
union :: (Collection f, Ord a) => f a -> f a -> f a
cmap :: (Collection f, Ord a, Ord b) => (a -> b) -> f a -> f b

-- | Combine a list of containers into one.
unions :: (Ord a, Collection f) => [f a] -> f a

-- | Create a collection from a list of elements.
fromList :: (Ord a, Collection f) => [a] -> f a

-- | Remove the <tt>Nothing</tt>s from a collection.
filterC :: (Collection f, Ord a) => f (Maybe a) -> f a

-- | A simple representation of multisets.
newtype Multiset a
Multiset :: (Map a Int) -> Multiset a
disjoint :: Ord a => Set a -> Set a -> Bool
instance Collection Set
instance Collection Multiset
instance Foldable Multiset
instance Collection []


-- | An implementation of names in a locally nameless representation.
module Unbound.LocallyNameless.Name

-- | <a>Name</a>s are things that get bound. This type is intentionally
--   abstract; to create a <a>Name</a> you can use <a>string2Name</a> or
--   <a>integer2Name</a>. The type parameter is a tag, or <i>sort</i>,
--   which tells us what sorts of things this name may stand for. The sort
--   must be a <i>representable</i> type, <i>i.e.</i> an instance of the
--   <a>Rep</a> type class from the <tt>RepLib</tt> generic programming
--   framework.
--   
--   To hide the sort of a name, use <a>AnyName</a>.
data Name a
Nm :: (R a) -> (String, Integer) -> Name a
Bn :: (R a) -> Integer -> Integer -> Name a

-- | A name with a hidden (existentially quantified) sort. To hide the sort
--   of a name, use the <a>AnyName</a> constructor directly; to extract a
--   name with a hidden sort, use <a>toSortedName</a>.
data AnyName
AnyName :: (Name a) -> AnyName

-- | Create a free <a>Name</a> from an <a>Integer</a>.
integer2Name :: Rep a => Integer -> Name a

-- | Create a free <a>Name</a> from a <a>String</a>.
string2Name :: Rep a => String -> Name a

-- | Convenient synonym for <a>string2Name</a>.
s2n :: Rep a => String -> Name a

-- | Create a free <a>Name</a> from a <tt>String</tt> and an
--   <tt>Integer</tt> index.
makeName :: Rep a => String -> Integer -> Name a

-- | Get the integer index of a <a>Name</a>.
name2Integer :: Name a -> Integer

-- | Get the string part of a <a>Name</a>.
name2String :: Name a -> String

-- | Get the integer index of an <a>AnyName</a>.
anyName2Integer :: AnyName -> Integer

-- | Get the string part of an <a>AnyName</a>.
anyName2String :: AnyName -> String

-- | Cast a name with an existentially hidden sort to an explicitly sorted
--   name.
toSortedName :: Rep a => AnyName -> Maybe (Name a)

-- | Change the sort of a name.
translate :: Rep b => Name a -> Name b

-- | Determine the sort of a <a>Name</a>.
getR :: Name a -> R a

-- | Test whether a name is a bound variable (i.e. a reference to some
--   binding site, represented as a de Bruijn index). Normal users of the
--   library should not need this function, as it is impossible to
--   encounter a bound name when using the abstract interface provided by
--   <a>Unbound.LocallyNameless</a>.
isBound :: Name a -> Bool

-- | Test whether a name is a free variable. Normal users of the library
--   should not need this function, as all the names encountered will be
--   free variables when using the abstract interface provided by
--   <a>Unbound.LocallyNameless</a>.
isFree :: Name a -> Bool
rR :: Rep a_a4sI => R (R a_a4sI)
rR1 :: Rep a_a4sI => R1 ctx_a4xN (R a_a4sI)
rName :: Rep a_a4yl => R (Name a_a4yl)
rName1 :: Rep a_a4yl => (ctx_a4G3 (R a_a4yl), ctx_a4G3 (String, Integer)) -> (ctx_a4G3 (R a_a4yl), ctx_a4G3 Integer, ctx_a4G3 Integer) -> R1 ctx_a4G3 (Name a_a4yl)
rAnyName :: R AnyName
rAnyName1 :: R1 ctx_a4Ic AnyName
instance Show (Name a)
instance Ord AnyName
instance Eq AnyName
instance Show AnyName
instance Rep1 ctx0 AnyName
instance Rep AnyName
instance (Rep a0, Sat (ctx0 (R a0)), Sat (ctx0 (String, Integer)), Sat (ctx0 Integer)) => Rep1 ctx0 (Name a0)
instance Rep a0 => Rep (Name a0)
instance Eq (Name a)
instance Ord (Name a)
instance Rep a0 => Rep1 ctx0 (R a0)
instance Rep a0 => Rep (R a0)


-- | The <a>Fresh</a> and <a>LFresh</a> classes, which govern monads with
--   fresh name generation capabilities, and the FreshM(T) and LFreshM(T)
--   monad (transformers) which provide useful default implementations.
module Unbound.LocallyNameless.Fresh

-- | The <tt>Fresh</tt> type class governs monads which can generate new
--   globally unique <a>Name</a>s based on a given <a>Name</a>.
class Monad m => Fresh m
fresh :: Fresh m => Name a -> m (Name a)

-- | A convenient monad which is an instance of <a>Fresh</a>. It keeps
--   track of a global index used for generating fresh names, which is
--   incremented every time <a>fresh</a> is called.
type FreshM = FreshMT Identity

-- | Run a FreshM computation (with the global index starting at zero).
runFreshM :: FreshM a -> a

-- | Run a FreshM computation given a starting index.
contFreshM :: FreshM a -> Integer -> a

-- | The <tt>FreshM</tt> monad transformer. Keeps track of the lowest index
--   still globally unused, and increments the index every time it is asked
--   for a fresh name.
newtype FreshMT m a
FreshMT :: StateT Integer m a -> FreshMT m a
unFreshMT :: FreshMT m a -> StateT Integer m a

-- | Run a <a>FreshMT</a> computation (with the global index starting at
--   zero).
runFreshMT :: Monad m => FreshMT m a -> m a

-- | Run a <a>FreshMT</a> computation given a starting index for fresh name
--   generation.
contFreshMT :: Monad m => FreshMT m a -> Integer -> m a

-- | This is the class of monads that support freshness in an (implicit)
--   local scope. Generated names are fresh for the current local scope,
--   not necessarily globally fresh.
class Monad m => LFresh m
lfresh :: (LFresh m, Rep a) => Name a -> m (Name a)
avoid :: LFresh m => [AnyName] -> m a -> m a
getAvoids :: LFresh m => m (Set AnyName)

-- | A convenient monad which is an instance of <a>LFresh</a>. It keeps
--   track of a set of names to avoid, and when asked for a fresh one will
--   choose the first unused numerical name.
type LFreshM = LFreshMT Identity

-- | Run a LFreshM computation in an empty context.
runLFreshM :: LFreshM a -> a

-- | Run a LFreshM computation given a set of names to avoid.
contLFreshM :: LFreshM a -> Set AnyName -> a

-- | The LFresh monad transformer. Keeps track of a set of names to avoid,
--   and when asked for a fresh one will choose the first numeric prefix of
--   the given name which is currently unused.
newtype LFreshMT m a
LFreshMT :: ReaderT (Set AnyName) m a -> LFreshMT m a
unLFreshMT :: LFreshMT m a -> ReaderT (Set AnyName) m a

-- | Run an <a>LFreshMT</a> computation in an empty context.
runLFreshMT :: LFreshMT m a -> m a

-- | Run an <a>LFreshMT</a> computation given a set of names to avoid.
contLFreshMT :: LFreshMT m a -> Set AnyName -> m a
instance [overlap ok] Functor m => Functor (FreshMT m)
instance [overlap ok] (Monad m, Functor m) => Applicative (FreshMT m)
instance [overlap ok] Monad m => Monad (FreshMT m)
instance [overlap ok] MonadPlus m => MonadPlus (FreshMT m)
instance [overlap ok] MonadIO m => MonadIO (FreshMT m)
instance [overlap ok] MonadFix m => MonadFix (FreshMT m)
instance [overlap ok] Functor m => Functor (LFreshMT m)
instance [overlap ok] Applicative m => Applicative (LFreshMT m)
instance [overlap ok] Monad m => Monad (LFreshMT m)
instance [overlap ok] MonadIO m => MonadIO (LFreshMT m)
instance [overlap ok] MonadPlus m => MonadPlus (LFreshMT m)
instance [overlap ok] MonadFix m => MonadFix (LFreshMT m)
instance [overlap ok] MonadWriter w m => MonadWriter w (LFreshMT m)
instance [overlap ok] MonadReader r m => MonadReader r (LFreshMT m)
instance [overlap ok] MonadState s m => MonadState s (LFreshMT m)
instance [overlap ok] MonadError e m => MonadError e (LFreshMT m)
instance [overlap ok] MonadCont m => MonadCont (LFreshMT m)
instance [overlap ok] MonadTrans LFreshMT
instance [overlap ok] (Monoid w, LFresh m) => LFresh (WriterT w m)
instance [overlap ok] (Monoid w, LFresh m) => LFresh (WriterT w m)
instance [overlap ok] LFresh m => LFresh (StateT s m)
instance [overlap ok] LFresh m => LFresh (StateT s m)
instance [overlap ok] LFresh m => LFresh (ReaderT r m)
instance [overlap ok] LFresh m => LFresh (MaybeT m)
instance [overlap ok] LFresh m => LFresh (ListT m)
instance [overlap ok] LFresh m => LFresh (IdentityT m)
instance [overlap ok] (Error e, LFresh m) => LFresh (ErrorT e m)
instance [overlap ok] LFresh m => LFresh (ContT r m)
instance [overlap ok] Monad m => LFresh (LFreshMT m)
instance [overlap ok] MonadWriter w m => MonadWriter w (FreshMT m)
instance [overlap ok] MonadReader r m => MonadReader r (FreshMT m)
instance [overlap ok] MonadState s m => MonadState s (FreshMT m)
instance [overlap ok] MonadError e m => MonadError e (FreshMT m)
instance [overlap ok] MonadCont m => MonadCont (FreshMT m)
instance [overlap ok] MonadTrans FreshMT
instance [overlap ok] (Monoid w, Fresh m) => Fresh (WriterT w m)
instance [overlap ok] (Monoid w, Fresh m) => Fresh (WriterT w m)
instance [overlap ok] Fresh m => Fresh (StateT s m)
instance [overlap ok] Fresh m => Fresh (StateT s m)
instance [overlap ok] Fresh m => Fresh (ReaderT r m)
instance [overlap ok] Fresh m => Fresh (MaybeT m)
instance [overlap ok] Fresh m => Fresh (ListT m)
instance [overlap ok] Fresh m => Fresh (IdentityT m)
instance [overlap ok] (Error e, Fresh m) => Fresh (ErrorT e m)
instance [overlap ok] Fresh m => Fresh (ContT r m)
instance [overlap ok] Monad m => Fresh (FreshMT m)


-- | Special type combinators for specifying binding structure.
module Unbound.LocallyNameless.Types

-- | The most fundamental combinator for expressing binding structure is
--   <a>Bind</a>. The <i>term type</i> <tt>Bind p t</tt> represents a
--   pattern <tt>p</tt> paired with a term <tt>t</tt>, where names in
--   <tt>p</tt> are bound within <tt>t</tt>.
--   
--   Like <a>Name</a>, <a>Bind</a> is also abstract. You can create
--   bindings using <tt>bind</tt> and take them apart with <tt>unbind</tt>
--   and friends.
data GenBind order card p t
B :: p -> t -> GenBind order card p t
type Bind p t = GenBind StrictOrder StrictCard p t
type SetBind p t = GenBind RelaxedOrder StrictCard p t
type SetPlusBind p t = GenBind RelaxedOrder RelaxedCard p t

-- | <tt>Rebind</tt> allows for <i>nested</i> bindings. If <tt>p1</tt> and
--   <tt>p2</tt> are pattern types, then <tt>Rebind p1 p2</tt> is also a
--   pattern type, similar to the pattern type <tt>(p1,p2)</tt> except that
--   <tt>p1</tt> <i>scopes over</i> <tt>p2</tt>. That is, names within
--   terms embedded in <tt>p2</tt> may refer to binders in <tt>p1</tt>.
data Rebind p1 p2
R :: p1 -> p2 -> Rebind p1 p2

-- | If <tt>p</tt> is a pattern type, then <tt>Rec p</tt> is also a pattern
--   type, which is <i>recursive</i> in the sense that <tt>p</tt> may bind
--   names in terms embedded within itself. Useful for encoding e.g.
--   lectrec and Agda's dot notation.
data Rec p
Rec :: p -> Rec p

-- | <tt>TRec</tt> is a standalone variant of <a>Rec</a>: the only
--   difference is that whereas <tt><a>Rec</a> p</tt> is a pattern type,
--   <tt>TRec p</tt> is a <i>term type</i>. It is isomorphic to
--   <tt><a>Bind</a> (<a>Rec</a> p) ()</tt>.
--   
--   Note that <tt>TRec</tt> corresponds to Pottier's <i>abstraction</i>
--   construct from alpha-Caml. In this context, <tt><a>Embed</a> t</tt>
--   corresponds to alpha-Caml's <tt>inner t</tt>, and <tt><a>Shift</a>
--   (<a>Embed</a> t)</tt> corresponds to alpha-Caml's <tt>outer t</tt>.
newtype TRec p
TRec :: (Bind (Rec p) ()) -> TRec p

-- | <tt>Embed</tt> allows for terms to be <i>embedded</i> within patterns.
--   Such embedded terms do not bind names along with the rest of the
--   pattern. For examples, see the tutorial or examples directories.
--   
--   If <tt>t</tt> is a <i>term type</i>, then <tt>Embed t</tt> is a
--   <i>pattern type</i>.
--   
--   <tt>Embed</tt> is not abstract since it involves no binding, and hence
--   it is safe to manipulate directly. To create and destruct
--   <tt>Embed</tt> terms, you may use the <tt>Embed</tt> constructor
--   directly. (You may also use the functions <tt>embed</tt> and
--   <tt>unembed</tt>, which additionally can construct or destruct any
--   number of enclosing <a>Shift</a>s at the same time.)
newtype Embed t
Embed :: t -> Embed t

-- | Shift the scope of an embedded term one level outwards.
newtype Shift p
Shift :: p -> Shift p
rGenBind :: (Rep order_aa3O, Rep card_aa3P, Rep p_aa3Q, Rep t_aa3R) => R (GenBind order_aa3O card_aa3P p_aa3Q t_aa3R)
rRebind :: (Rep p1_aa3G, Rep p2_aa3H) => R (Rebind p1_aa3G p2_aa3H)
rEmbed :: Rep t_aa3D => R (Embed t_aa3D)
rRec :: Rep p_aa3F => R (Rec p_aa3F)
rShift :: Rep p_aa3C => R (Shift p_aa3C)
instance Binary p => Binary (Embed p)
instance (Binary p1, Binary p2) => Binary (Rebind p1 p2)
instance (Binary p, Binary t) => Binary (GenBind order card p t)
instance Rep a => Binary (Name a)
instance Rep1 ctx0 StrictCard
instance Rep StrictCard
instance Rep1 ctx0 RelaxedCard
instance Rep RelaxedCard
instance Rep1 ctx0 StrictOrder
instance Rep StrictOrder
instance Rep1 ctx0 RelaxedOrder
instance Rep RelaxedOrder
instance (Rep p0, Sat (ctx0 p0)) => Rep1 ctx0 (Shift p0)
instance Rep p0 => Rep (Shift p0)
instance (Rep p0, Sat (ctx0 p0)) => Rep1 ctx0 (Rec p0)
instance Rep p0 => Rep (Rec p0)
instance (Rep p10, Rep p20, Sat (ctx0 p10), Sat (ctx0 p20)) => Rep1 ctx0 (Rebind p10 p20)
instance (Rep p10, Rep p20) => Rep (Rebind p10 p20)
instance (Rep t0, Sat (ctx0 t0)) => Rep1 ctx0 (Embed t0)
instance Rep t0 => Rep (Embed t0)
instance (Rep order0, Rep card0, Rep p0, Rep t0, Sat (ctx0 p0), Sat (ctx0 t0)) => Rep1 ctx0 (GenBind order0 card0 p0 t0)
instance (Rep order0, Rep card0, Rep p0, Rep t0) => Rep (GenBind order0 card0 p0 t0)
instance Eq t => Eq (Embed t)
instance Eq p => Eq (Shift p)
instance Show a => Show (Shift a)
instance Show a => Show (Embed a)
instance Show a => Show (TRec a)
instance Show a => Show (Rec a)
instance (Show a, Show b) => Show (Rebind a b)
instance (Show a, Show b) => Show (GenBind order card a b)


module Unbound.LocallyNameless.Alpha

-- | The <tt>Alpha</tt> type class is for types which may contain names.
--   The <a>Rep1</a> constraint means that we can only make instances of
--   this class for types that have generic representations (which can be
--   automatically derived by RepLib.)
--   
--   Note that the methods of <tt>Alpha</tt> should almost never be called
--   directly. Instead, use other methods provided by this module which are
--   defined in terms of <tt>Alpha</tt> methods.
--   
--   Most of the time, the default definitions of these methods will
--   suffice, so you can make an instance for your data type by simply
--   declaring
--   
--   <pre>
--   instance Alpha MyType
--   </pre>
--   
--   Occasionally, however, it may be useful to override the default
--   implementations of one or more <tt>Alpha</tt> methods for a particular
--   type. For example, consider a type like
--   
--   <pre>
--   data Term = ...
--             | Annotation Stuff Term
--   </pre>
--   
--   where the <tt>Annotation</tt> constructor of <tt>Term</tt> associates
--   some sort of annotation with a term --- say, information obtained from
--   a parser about where in an input file the term came from. This
--   information is needed to produce good error messages, but should not
--   be taken into consideration when, say, comparing two <tt>Term</tt>s
--   for alpha-equivalence. In order to make <tt>aeq</tt> ignore
--   annotations, you can override the implementation of <tt>aeq'</tt> like
--   so:
--   
--   <pre>
--   instance Alpha Term where
--     aeq' c (Annotation _ t1) t2 = aeq' c t1 t2
--     aeq' c t1 (Annotation _ t2) = aeq' c t1 t2
--     aeq' c t1 t2 = aeqR1 rep1 t1 t2
--   </pre>
--   
--   Note how the call to <a>aeqR1</a> handles all the other cases
--   generically.
class (Show a, Rep1 AlphaD a) => Alpha a where swaps' = swapsR1 rep1 fv' = fvR1 rep1 lfreshen' = lfreshenR1 rep1 freshen' = freshenR1 rep1 aeq' = aeqR1 rep1 acompare' = acompareR1 rep1 close = closeR1 rep1 open = openR1 rep1 isPat = isPatR1 rep1 isTerm = isTermR1 rep1 isEmbed _ = False nthpatrec = nthpatR1 rep1 findpatrec = findpatR1 rep1
swaps' :: Alpha a => AlphaCtx -> Perm AnyName -> a -> a
fv' :: (Alpha a, Collection f) => AlphaCtx -> a -> f AnyName
lfreshen' :: (Alpha a, LFresh m) => AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b
freshen' :: (Alpha a, Fresh m) => AlphaCtx -> a -> m (a, Perm AnyName)
aeq' :: Alpha a => AlphaCtx -> a -> a -> Bool
acompare' :: Alpha a => AlphaCtx -> a -> a -> Ordering
close :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
open :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
isPat :: Alpha a => a -> Maybe [AnyName]
isTerm :: Alpha a => a -> Bool
isEmbed :: Alpha a => a -> Bool
nthpatrec :: Alpha a => a -> NthCont
findpatrec :: Alpha a => a -> AnyName -> FindResult

-- | Type class for embedded terms (either <tt>Embed</tt> or
--   <tt>Shift</tt>).
class IsEmbed e where type family Embedded e :: *
embed :: IsEmbed e => Embedded e -> e
unembed :: IsEmbed e => e -> Embedded e

-- | The result of a <a>findpatrec</a> operation.
data FindResult

-- | The (first) index of the name we sought
Index :: Integer -> FindResult

-- | We haven't found the name (yet), but have seen this many others while
--   looking for it
NamesSeen :: Integer -> FindResult

-- | Find the (first) index of the name in the pattern, if it exists.
findpat :: Alpha a => a -> AnyName -> Maybe Integer

-- | The result of an <a>nthpatrec</a> operation.
data NthResult

-- | The name found at the given index.
Found :: AnyName -> NthResult

-- | We haven't yet reached the required index; this is the index into the
--   remainder of the pattern (which decreases as we traverse the pattern).
CurIndex :: Integer -> NthResult

-- | A continuation which takes the remaining index and searches for that
--   location in a pattern, yielding a name or a remaining index if the end
--   of the pattern was reached too soon.
newtype NthCont
NthCont :: (Integer -> NthResult) -> NthCont
runNthCont :: NthCont -> Integer -> NthResult

-- | If we see a name, check whether the index is 0: if it is, we've found
--   the name we're looking for, otherwise continue with a decremented
--   index.
nthName :: AnyName -> NthCont

-- | <tt><a>nthpat</a> b n</tt> looks up up the <tt>n</tt>th name in the
--   pattern <tt>b</tt> (zero-indexed). PRECONDITION: the number of names
--   in the pattern must be at least <tt>n</tt>.
nthpat :: Alpha a => a -> Integer -> AnyName

-- | Many of the operations in the <a>Alpha</a> class take an
--   <a>AlphaCtx</a>: stored information about the iteration as it
--   progresses. This type is abstract, as classes that override these
--   operations should just pass the context on.
data AlphaCtx
AC :: Mode -> Integer -> AlphaCtx
mode :: AlphaCtx -> Mode
level :: AlphaCtx -> Integer
initial :: AlphaCtx
incr :: AlphaCtx -> AlphaCtx
decr :: AlphaCtx -> AlphaCtx
pat :: AlphaCtx -> AlphaCtx
term :: AlphaCtx -> AlphaCtx

-- | A mode is basically a flag that tells us whether we should be looking
--   at the names in the term, or if we are in a pattern and should
--   <i>only</i> be looking at the names in the annotations. The standard
--   mode is to use <a>Term</a>; many functions do this by default.
data Mode
Term :: Mode
Pat :: Mode

-- | Open a term using the given pattern.
openT :: (Alpha p, Alpha t) => p -> t -> t

-- | <tt>openP p1 p2</tt> opens the pattern <tt>p2</tt> using the pattern
--   <tt>p1</tt>.
openP :: (Alpha p1, Alpha p2) => p1 -> p2 -> p2

-- | Close a term using the given pattern.
closeT :: (Alpha p, Alpha t) => p -> t -> t

-- | <tt>closeP p1 p2</tt> closes the pattern <tt>p2</tt> using the pattern
--   <tt>p1</tt>.
closeP :: (Alpha p1, Alpha p2) => p1 -> p2 -> p2

-- | Class constraint hackery to allow us to override the default
--   definitions for certain classes. <a>AlphaD</a> is essentially a
--   reified dictionary for the <a>Alpha</a> class.
data AlphaD a
AlphaD :: (a -> Maybe [AnyName]) -> (a -> Bool) -> (a -> Bool) -> (AlphaCtx -> Perm AnyName -> a -> a) -> (forall f. Collection f => AlphaCtx -> a -> f AnyName) -> (forall m. Fresh m => AlphaCtx -> a -> m (a, Perm AnyName)) -> (forall m b. LFresh m => AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b) -> (AlphaCtx -> a -> a -> Bool) -> (AlphaCtx -> a -> a -> Ordering) -> (forall b. Alpha b => AlphaCtx -> b -> a -> a) -> (forall b. Alpha b => AlphaCtx -> b -> a -> a) -> (a -> AnyName -> FindResult) -> (a -> NthCont) -> AlphaD a
isPatD :: AlphaD a -> a -> Maybe [AnyName]
isTermD :: AlphaD a -> a -> Bool
isEmbedD :: AlphaD a -> a -> Bool
swapsD :: AlphaD a -> AlphaCtx -> Perm AnyName -> a -> a
fvD :: AlphaD a -> forall f. Collection f => AlphaCtx -> a -> f AnyName
freshenD :: AlphaD a -> forall m. Fresh m => AlphaCtx -> a -> m (a, Perm AnyName)
lfreshenD :: AlphaD a -> forall m b. LFresh m => AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b
aeqD :: AlphaD a -> AlphaCtx -> a -> a -> Bool
acompareD :: AlphaD a -> AlphaCtx -> a -> a -> Ordering
closeD :: AlphaD a -> forall b. Alpha b => AlphaCtx -> b -> a -> a
openD :: AlphaD a -> forall b. Alpha b => AlphaCtx -> b -> a -> a
findpatD :: AlphaD a -> a -> AnyName -> FindResult
nthpatD :: AlphaD a -> a -> NthCont
closeR1 :: Alpha b => R1 AlphaD a -> AlphaCtx -> b -> a -> a
openR1 :: Alpha b => R1 AlphaD a -> AlphaCtx -> b -> a -> a
swapsR1 :: R1 AlphaD a -> AlphaCtx -> Perm AnyName -> a -> a
fvR1 :: Collection f => R1 (AlphaD) a -> AlphaCtx -> a -> f AnyName
fv1 :: Collection f => MTup (AlphaD) l -> AlphaCtx -> l -> f AnyName
aeqR1 :: R1 (AlphaD) a -> AlphaCtx -> a -> a -> Bool
aeq1 :: MTup (AlphaD) l -> AlphaCtx -> l -> l -> Bool
freshenR1 :: Fresh m => R1 (AlphaD) a -> AlphaCtx -> a -> m (a, Perm AnyName)
freshenL :: Fresh m => MTup (AlphaD) l -> AlphaCtx -> l -> m (l, Perm AnyName)
lfreshenR1 :: LFresh m => R1 AlphaD a -> AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b
lfreshenL :: LFresh m => MTup (AlphaD) l -> AlphaCtx -> l -> (l -> Perm AnyName -> m b) -> m b
findpatR1 :: R1 AlphaD b -> b -> AnyName -> FindResult
findpatL :: MTup AlphaD l -> l -> AnyName -> FindResult
nthpatR1 :: R1 AlphaD b -> b -> NthCont
nthpatL :: MTup AlphaD l -> l -> NthCont
combine :: Maybe [AnyName] -> Maybe [AnyName] -> Maybe [AnyName]
isPatR1 :: R1 AlphaD b -> b -> Maybe [AnyName]
isTermR1 :: R1 AlphaD b -> b -> Bool
acompareR1 :: R1 AlphaD a -> AlphaCtx -> a -> a -> Ordering
compareTupM :: MTup AlphaD l -> AlphaCtx -> l -> l -> Ordering
instance Eq FindResult
instance Ord FindResult
instance Show FindResult
instance Show Mode
instance Eq Mode
instance Read Mode
instance Rep a => Alpha (R a)
instance (Alpha a, Alpha b, Alpha c, Alpha d, Alpha e) => Alpha (a, b, c, d, e)
instance (Alpha a, Alpha b, Alpha c, Alpha d) => Alpha (a, b, c, d)
instance (Alpha a, Alpha b, Alpha c) => Alpha (a, b, c)
instance (Alpha a, Alpha b) => Alpha (a, b)
instance (Alpha a, Alpha b) => Alpha (Either a b)
instance Alpha a => Alpha (Maybe a)
instance Alpha Char
instance Alpha Double
instance Alpha Integer
instance Alpha Int
instance Alpha a => Alpha [a]
instance Alpha ()
instance Alpha Float
instance Alpha Bool
instance IsEmbed e => IsEmbed (Shift e)
instance Alpha a => Alpha (Shift a)
instance IsEmbed (Embed t)
instance Alpha t => Alpha (Embed t)
instance Alpha p => Alpha (Rec p)
instance (Alpha p, Alpha q) => Alpha (Rebind p q)
instance (Rep order, Rep card, Alpha p, Alpha t) => Alpha (GenBind order card p t)
instance Alpha AnyName
instance Rep a => Alpha (Name a)
instance Alpha a => Sat (AlphaD a)
instance Monoid NthCont
instance Monoid FindResult


-- | The <tt>Subst</tt> type class for generic capture-avoiding
--   substitution.
module Unbound.LocallyNameless.Subst

-- | See <a>isvar</a>.
data SubstName a b
SubstName :: Name a -> SubstName a b

-- | See <a>isCoerceVar</a>
data SubstCoerce a b
SubstCoerce :: Name b -> (b -> Maybe a) -> SubstCoerce a b

-- | The <tt>Subst</tt> class governs capture-avoiding substitution. To
--   derive this class, you only need to indicate where the variables are
--   in the data type, by overriding the method <a>isvar</a>.
class Rep1 (SubstD b) a => Subst b a where isvar _ = Nothing isCoerceVar _ = Nothing subst n u x | isFree n = case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> if m == n then u else x Nothing -> case (isCoerceVar x :: Maybe (SubstCoerce a b)) of { Just (SubstCoerce m f) -> if m == n then maybe x id (f u) else x Nothing -> substR1 rep1 n u x } } subst m _ _ = error $ "Cannot substitute for bound variable " ++ show m substs ss x | all (isFree . fst) ss = case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> case find ((== m) . fst) ss of { Just (_, u) -> u Nothing -> x } Nothing -> case isCoerceVar x :: Maybe (SubstCoerce a b) of { Just (SubstCoerce m f) -> case find ((== m) . fst) ss of { Just (_, u) -> maybe x id (f u) Nothing -> x } Nothing -> substsR1 rep1 ss x } } | otherwise = error $ "Cannot substitute for bound variable in: " ++ show (map fst ss)
isvar :: Subst b a => a -> Maybe (SubstName a b)
isCoerceVar :: Subst b a => a -> Maybe (SubstCoerce a b)
subst :: Subst b a => Name b -> b -> a -> a
substs :: Subst b a => [(Name b, b)] -> a -> a

-- | Reified class dictionary for <a>Subst</a>.
data SubstD b a
SubstD :: (a -> Maybe (SubstName a b)) -> (Name b -> b -> a -> a) -> ([(Name b, b)] -> a -> a) -> SubstD b a
isvarD :: SubstD b a -> a -> Maybe (SubstName a b)
substD :: SubstD b a -> Name b -> b -> a -> a
substsD :: SubstD b a -> [(Name b, b)] -> a -> a
substDefault :: Rep1 (SubstD b) a => Name b -> b -> a -> a
substR1 :: R1 (SubstD b) a -> Name b -> b -> a -> a
substsR1 :: R1 (SubstD b) a -> [(Name b, b)] -> a -> a
instance (Alpha a, Subst c a) => Subst c (Rec a)
instance Subst c a => Subst c (Embed a)
instance (Subst c b, Subst c a, Alpha a, Alpha b) => Subst c (Rebind a b)
instance (Rep order, Rep card, Subst c b, Subst c a, Alpha a, Alpha b) => Subst c (GenBind order card a b)
instance (Subst c a, Subst c b) => Subst c (Either a b)
instance Subst c a => Subst c (Maybe a)
instance Subst c a => Subst c [a]
instance (Subst c a, Subst c b, Subst c d, Subst c e, Subst c f) => Subst c (a, b, d, e, f)
instance (Subst c a, Subst c b, Subst c d, Subst c e) => Subst c (a, b, d, e)
instance (Subst c a, Subst c b, Subst c d) => Subst c (a, b, d)
instance (Subst c a, Subst c b) => Subst c (a, b)
instance Rep a => Subst b (Name a)
instance Rep a => Subst b (R a)
instance Subst b AnyName
instance Subst b Double
instance Subst b Float
instance Subst b Integer
instance Subst b Char
instance Subst b ()
instance Subst b Bool
instance Subst b Int
instance Subst b a => Sat (SubstD b a)


-- | Generic operations defined in terms of the RepLib framework and the
--   <a>Alpha</a> type class.
module Unbound.LocallyNameless.Ops

-- | A smart constructor for binders, also sometimes referred to as
--   "close". Free variables in the term are taken to be references to
--   matching binders in the pattern. (Free variables with no matching
--   binders will remain free.)
bind :: (Alpha p, Alpha t) => p -> t -> Bind p t

-- | A destructor for binders that does <i>not</i> guarantee fresh names
--   for the binders.
unsafeUnbind :: (Alpha a, Alpha b) => GenBind order card a b -> (a, b)
permCloseAny :: Alpha t => [AnyName] -> t -> ([AnyName], t)
strength :: Functor f => (a, f b) -> f (a, b)
permClose :: (Alpha a, Alpha t) => [Name a] -> t -> ([Name a], t)

-- | Bind the pattern in the term "up to permutation" of bound variables.
--   For example, the following 4 terms are <i>all</i> alpha-equivalent:
--   
--   <pre>
--   permbind [a,b] (a,b)
--   permbind [a,b] (b,a)
--   permbind [b,a] (a,b)
--   permbind [b,a] (b,a)
--   </pre>
--   
--   Note that none of these terms is equivalent to a term with a redundant
--   pattern such as
--   
--   <pre>
--   permbind [a,b,c] (a,b)
--   </pre>
--   
--   For binding constructors which <i>do</i> render these equivalent, see
--   <a>setbind</a> and <a>setbindAny</a>.
permbind :: (Alpha p, Alpha t) => p -> t -> SetBind p t

-- | Bind the list of names in the term up to permutation and dropping of
--   unused variables.
--   
--   For example, the following 5 terms are <i>all</i> alpha-equivalent:
--   
--   <pre>
--   setbind [a,b] (a,b)
--   setbind [a,b] (b,a)
--   setbind [b,a] (a,b)
--   setbind [b,a] (b,a)
--   setbind [a,b,c] (a,b)
--   </pre>
--   
--   There is also a variant, <a>setbindAny</a>, which ignores name sorts.
setbind :: (Alpha a, Alpha t) => [Name a] -> t -> SetPlusBind [Name a] t

-- | Bind the list of (any-sorted) names in the term up to permutation and
--   dropping of unused variables. See <a>setbind</a>.
setbindAny :: Alpha t => [AnyName] -> t -> SetPlusBind [AnyName] t

-- | Constructor for rebinding patterns.
rebind :: (Alpha p1, Alpha p2) => p1 -> p2 -> Rebind p1 p2

-- | Destructor for rebinding patterns. It does not need a monadic context
--   for generating fresh names, since <tt>Rebind</tt> can only occur in
--   the pattern of a <a>Bind</a>; hence a previous call to <a>unbind</a>
--   (or something similar) must have already freshened the names at this
--   point.
unrebind :: (Alpha p1, Alpha p2) => Rebind p1 p2 -> (p1, p2)

-- | Constructor for recursive patterns.
rec :: Alpha p => p -> Rec p

-- | Destructor for recursive patterns.
unrec :: Alpha p => Rec p -> p

-- | Constructor for recursive abstractions.
trec :: Alpha p => p -> TRec p

-- | Destructor for recursive abstractions which picks globally fresh names
--   for the binders.
untrec :: (Fresh m, Alpha p) => TRec p -> m p

-- | Destructor for recursive abstractions which picks <i>locally</i> fresh
--   names for binders (see <a>LFresh</a>).
luntrec :: (LFresh m, Alpha p) => TRec p -> m p

-- | Determine the alpha-equivalence of two terms.
aeq :: Alpha t => t -> t -> Bool

-- | Determine (alpha-)equivalence of patterns. Do they bind the same
--   variables in the same patterns and have alpha-equivalent annotations
--   in matching positions?
aeqBinders :: Alpha p => p -> p -> Bool

-- | An alpha-respecting total order on terms involving binders.
acompare :: Alpha t => t -> t -> Ordering

-- | Calculate the free variables (of any sort) contained in a term.
fvAny :: (Alpha t, Collection f) => t -> f AnyName

-- | Calculate the free variables of a particular sort contained in a term.
fv :: (Rep a, Alpha t, Collection f) => t -> f (Name a)

-- | Calculate the variables (of any sort) that occur freely in terms
--   embedded within a pattern (but are not bound by the pattern).
patfvAny :: (Alpha p, Collection f) => p -> f AnyName

-- | Calculate the variables of a particular sort that occur freely in
--   terms embedded within a pattern (but are not bound by the pattern).
patfv :: (Rep a, Alpha p, Collection f) => p -> f (Name a)

-- | Calculate the binding variables (of any sort) in a pattern.
bindersAny :: (Alpha p, Collection f) => p -> f AnyName

-- | Calculate the binding variables (of a particular sort) in a pattern.
binders :: (Rep a, Alpha p, Collection f) => p -> f (Name a)

-- | Apply a permutation to a term.
swaps :: Alpha t => Perm AnyName -> t -> t

-- | Apply a permutation to the binding variables in a pattern. Embedded
--   terms are left alone by the permutation.
swapsBinders :: Alpha p => Perm AnyName -> p -> p

-- | Apply a permutation to the embedded terms in a pattern. Binding names
--   are left alone by the permutation.
swapsEmbeds :: Alpha p => Perm AnyName -> p -> p

-- | "Locally" freshen a pattern, replacing all binding names with new
--   names that are not already "in scope". The second argument is a
--   continuation, which takes the renamed term and a permutation that
--   specifies how the pattern has been renamed. The resulting computation
--   will be run with the in-scope set extended by the names just
--   generated.
lfreshen :: (Alpha p, LFresh m) => p -> (p -> Perm AnyName -> m b) -> m b

-- | Freshen a pattern by replacing all old binding <a>Name</a>s with new
--   fresh <a>Name</a>s, returning a new pattern and a <tt><a>Perm</a>
--   <a>Name</a></tt> specifying how <a>Name</a>s were replaced.
freshen :: (Alpha p, Fresh m) => p -> m (p, Perm AnyName)

-- | Unbind (also known as "open") is the simplest destructor for bindings.
--   It ensures that the names in the binding are globally fresh, using a
--   monad which is an instance of the <a>Fresh</a> type class.
unbind :: (Fresh m, Alpha p, Alpha t) => GenBind order card p t -> m (p, t)

-- | Unbind two terms with the <i>same</i> fresh names, provided the
--   binders have the same binding variables (both number and sort). If the
--   patterns have different binding variables, return <tt>Nothing</tt>.
--   Otherwise, return the renamed patterns and the associated terms.
unbind2 :: (Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> m (Maybe (p1, t1, p2, t2))

-- | Unbind three terms with the same fresh names, provided the binders
--   have the same number of binding variables. See the documentation for
--   <a>unbind2</a> for more details.
unbind3 :: (Fresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> m (Maybe (p1, t1, p2, t2, p3, t3))

-- | <tt>lunbind</tt> opens a binding in an <a>LFresh</a> monad, ensuring
--   that the names chosen for the binders are <i>locally</i> fresh. The
--   components of the binding are passed to a <i>continuation</i>, and the
--   resulting monadic action is run in a context extended to avoid
--   choosing new names which are the same as the ones chosen for this
--   binding.
--   
--   For more information, see the documentation for the <a>LFresh</a> type
--   class.
lunbind :: (LFresh m, Alpha p, Alpha t) => GenBind order card p t -> ((p, t) -> m c) -> m c

-- | Unbind two terms with the same locally fresh names, provided the
--   patterns have the same number of binding variables. See the
--   documentation for <a>unbind2</a> and <a>lunbind</a> for more details.
lunbind2 :: (LFresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> (Maybe (p1, t1, p2, t2) -> m r) -> m r

-- | Unbind three terms with the same locally fresh names, provided the
--   binders have the same number of binding variables. See the
--   documentation for <a>unbind2</a> and <a>lunbind</a> for more details.
lunbind3 :: (LFresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> (Maybe (p1, t1, p2, t2, p3, t3) -> m r) -> m r
unbind2Plus :: (MonadPlus m, Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> m (p1, t1, p2, t2)
unbind3Plus :: (MonadPlus m, Fresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> m (p1, t1, p2, t2, p3, t3)
lunbind2Plus :: (MonadPlus m, LFresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> ((p1, t1, p2, t2) -> m r) -> m r
lunbind3Plus :: (MonadPlus m, LFresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> ((p1, t1, p2, t2, p3, t3) -> m r) -> m r
instance (Alpha p1, Alpha p2, Eq p2) => Eq (Rebind p1 p2)
instance (Alpha a, Alpha b, Read a, Read b) => Read (Bind a b)


-- | A generic implementation of standard functions dealing with names and
--   binding structure (alpha equivalence, free variable calculation,
--   capture-avoiding substitution, name permutation, ...) using a locally
--   nameless representation.
--   
--   Normal users of this library should only need to import this module.
--   In particular, this module is careful to export only an abstract
--   interface with various safety guarantees. Power users who wish to have
--   access to the internals of the library (at the risk of shooting
--   oneself in the foot) can directly import the various implementation
--   modules such as <a>Unbound.LocallyNameless.Name</a> and so on.
--   
--   <i>Ten-second tutorial</i>: use the type combinators <a>Bind</a>,
--   <a>Embed</a>, <a>Rebind</a>, <a>Rec</a>, <a>TRec</a>, and <a>Shift</a>
--   to specify the binding structure of your data types. Then use Template
--   Haskell to derive generic representations for your types:
--   
--   <pre>
--   $(derive [''Your, ''Types, ''Here])
--   </pre>
--   
--   Finally, declare <a>Alpha</a> and <a>Subst</a> instances for your
--   types. Then you can go to town using all the generically-derived
--   operations like <a>aeq</a>, <a>fv</a>, <a>subst</a>, and so on.
--   
--   For more information, see the more in-depth literate Haskell tutorial
--   in the <tt>tutorial</tt> directory (which can be obtained as part of
--   the library source package: <tt>cabal unpack unbound</tt>) and the
--   examples in the <tt>example</tt> directory.
--   
--   See also: Stephanie Weirich, Brent A. Yorgey, and Tim Sheard.
--   <i>Binders Unbound</i>. ICFP'11, September 2011, Tokyo, Japan.
--   <a>http://www.cis.upenn.edu/~byorgey/papers/binders-unbound.pdf</a>.
module Unbound.LocallyNameless

-- | <a>Name</a>s are things that get bound. This type is intentionally
--   abstract; to create a <a>Name</a> you can use <a>string2Name</a> or
--   <a>integer2Name</a>. The type parameter is a tag, or <i>sort</i>,
--   which tells us what sorts of things this name may stand for. The sort
--   must be a <i>representable</i> type, <i>i.e.</i> an instance of the
--   <a>Rep</a> type class from the <tt>RepLib</tt> generic programming
--   framework.
--   
--   To hide the sort of a name, use <a>AnyName</a>.
data Name a

-- | A name with a hidden (existentially quantified) sort. To hide the sort
--   of a name, use the <a>AnyName</a> constructor directly; to extract a
--   name with a hidden sort, use <a>toSortedName</a>.
data AnyName
AnyName :: (Name a) -> AnyName

-- | Create a free <a>Name</a> from an <a>Integer</a>.
integer2Name :: Rep a => Integer -> Name a

-- | Create a free <a>Name</a> from a <a>String</a>.
string2Name :: Rep a => String -> Name a

-- | Convenient synonym for <a>string2Name</a>.
s2n :: Rep a => String -> Name a

-- | Create a free <a>Name</a> from a <tt>String</tt> and an
--   <tt>Integer</tt> index.
makeName :: Rep a => String -> Integer -> Name a

-- | Get the integer index of a <a>Name</a>.
name2Integer :: Name a -> Integer

-- | Get the string part of a <a>Name</a>.
name2String :: Name a -> String

-- | Get the integer index of an <a>AnyName</a>.
anyName2Integer :: AnyName -> Integer

-- | Get the string part of an <a>AnyName</a>.
anyName2String :: AnyName -> String

-- | Change the sort of a name.
translate :: Rep b => Name a -> Name b

-- | Cast a name with an existentially hidden sort to an explicitly sorted
--   name.
toSortedName :: Rep a => AnyName -> Maybe (Name a)
type Bind p t = GenBind StrictOrder StrictCard p t

-- | A smart constructor for binders, also sometimes referred to as
--   "close". Free variables in the term are taken to be references to
--   matching binders in the pattern. (Free variables with no matching
--   binders will remain free.)
bind :: (Alpha p, Alpha t) => p -> t -> Bind p t

-- | Bind the pattern in the term "up to permutation" of bound variables.
--   For example, the following 4 terms are <i>all</i> alpha-equivalent:
--   
--   <pre>
--   permbind [a,b] (a,b)
--   permbind [a,b] (b,a)
--   permbind [b,a] (a,b)
--   permbind [b,a] (b,a)
--   </pre>
--   
--   Note that none of these terms is equivalent to a term with a redundant
--   pattern such as
--   
--   <pre>
--   permbind [a,b,c] (a,b)
--   </pre>
--   
--   For binding constructors which <i>do</i> render these equivalent, see
--   <a>setbind</a> and <a>setbindAny</a>.
permbind :: (Alpha p, Alpha t) => p -> t -> SetBind p t

-- | Bind the list of names in the term up to permutation and dropping of
--   unused variables.
--   
--   For example, the following 5 terms are <i>all</i> alpha-equivalent:
--   
--   <pre>
--   setbind [a,b] (a,b)
--   setbind [a,b] (b,a)
--   setbind [b,a] (a,b)
--   setbind [b,a] (b,a)
--   setbind [a,b,c] (a,b)
--   </pre>
--   
--   There is also a variant, <a>setbindAny</a>, which ignores name sorts.
setbind :: (Alpha a, Alpha t) => [Name a] -> t -> SetPlusBind [Name a] t

-- | Bind the list of (any-sorted) names in the term up to permutation and
--   dropping of unused variables. See <a>setbind</a>.
setbindAny :: Alpha t => [AnyName] -> t -> SetPlusBind [AnyName] t

-- | Unbind (also known as "open") is the simplest destructor for bindings.
--   It ensures that the names in the binding are globally fresh, using a
--   monad which is an instance of the <a>Fresh</a> type class.
unbind :: (Fresh m, Alpha p, Alpha t) => GenBind order card p t -> m (p, t)

-- | <tt>lunbind</tt> opens a binding in an <a>LFresh</a> monad, ensuring
--   that the names chosen for the binders are <i>locally</i> fresh. The
--   components of the binding are passed to a <i>continuation</i>, and the
--   resulting monadic action is run in a context extended to avoid
--   choosing new names which are the same as the ones chosen for this
--   binding.
--   
--   For more information, see the documentation for the <a>LFresh</a> type
--   class.
lunbind :: (LFresh m, Alpha p, Alpha t) => GenBind order card p t -> ((p, t) -> m c) -> m c

-- | Unbind two terms with the <i>same</i> fresh names, provided the
--   binders have the same binding variables (both number and sort). If the
--   patterns have different binding variables, return <tt>Nothing</tt>.
--   Otherwise, return the renamed patterns and the associated terms.
unbind2 :: (Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> m (Maybe (p1, t1, p2, t2))

-- | Unbind three terms with the same fresh names, provided the binders
--   have the same number of binding variables. See the documentation for
--   <a>unbind2</a> for more details.
unbind3 :: (Fresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> m (Maybe (p1, t1, p2, t2, p3, t3))

-- | Unbind two terms with the same locally fresh names, provided the
--   patterns have the same number of binding variables. See the
--   documentation for <a>unbind2</a> and <a>lunbind</a> for more details.
lunbind2 :: (LFresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> (Maybe (p1, t1, p2, t2) -> m r) -> m r

-- | Unbind three terms with the same locally fresh names, provided the
--   binders have the same number of binding variables. See the
--   documentation for <a>unbind2</a> and <a>lunbind</a> for more details.
lunbind3 :: (LFresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> (Maybe (p1, t1, p2, t2, p3, t3) -> m r) -> m r
unbind2Plus :: (MonadPlus m, Fresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> m (p1, t1, p2, t2)
unbind3Plus :: (MonadPlus m, Fresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> m (p1, t1, p2, t2, p3, t3)
lunbind2Plus :: (MonadPlus m, LFresh m, Alpha p1, Alpha p2, Alpha t1, Alpha t2) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> ((p1, t1, p2, t2) -> m r) -> m r
lunbind3Plus :: (MonadPlus m, LFresh m, Alpha p1, Alpha p2, Alpha p3, Alpha t1, Alpha t2, Alpha t3) => GenBind order card p1 t1 -> GenBind order card p2 t2 -> GenBind order card p3 t3 -> ((p1, t1, p2, t2, p3, t3) -> m r) -> m r

-- | <tt>Embed</tt> allows for terms to be <i>embedded</i> within patterns.
--   Such embedded terms do not bind names along with the rest of the
--   pattern. For examples, see the tutorial or examples directories.
--   
--   If <tt>t</tt> is a <i>term type</i>, then <tt>Embed t</tt> is a
--   <i>pattern type</i>.
--   
--   <tt>Embed</tt> is not abstract since it involves no binding, and hence
--   it is safe to manipulate directly. To create and destruct
--   <tt>Embed</tt> terms, you may use the <tt>Embed</tt> constructor
--   directly. (You may also use the functions <tt>embed</tt> and
--   <tt>unembed</tt>, which additionally can construct or destruct any
--   number of enclosing <a>Shift</a>s at the same time.)
newtype Embed t
Embed :: t -> Embed t

-- | Construct an embedded term, which is an instance of <a>Embed</a> with
--   any number of enclosing <a>Shift</a>s. That is, <tt>embed</tt> can
--   have any of the types
--   
--   <ul>
--   <li><pre>t -&gt; Embed t</pre></li>
--   <li><pre>t -&gt; Shift (Embed t)</pre></li>
--   <li><pre>t -&gt; Shift (Shift (Embed t))</pre></li>
--   </ul>
--   
--   and so on.
embed :: IsEmbed e => Embedded e -> e

-- | Destruct an embedded term. <tt>unembed</tt> can have any of the types
--   
--   <ul>
--   <li><pre>Embed t -&gt; t</pre></li>
--   <li><pre>Shift (Embed t) -&gt; t</pre></li>
--   </ul>
--   
--   and so on.
unembed :: IsEmbed e => e -> Embedded e

-- | <tt>Rebind</tt> allows for <i>nested</i> bindings. If <tt>p1</tt> and
--   <tt>p2</tt> are pattern types, then <tt>Rebind p1 p2</tt> is also a
--   pattern type, similar to the pattern type <tt>(p1,p2)</tt> except that
--   <tt>p1</tt> <i>scopes over</i> <tt>p2</tt>. That is, names within
--   terms embedded in <tt>p2</tt> may refer to binders in <tt>p1</tt>.
data Rebind p1 p2

-- | Constructor for rebinding patterns.
rebind :: (Alpha p1, Alpha p2) => p1 -> p2 -> Rebind p1 p2

-- | Destructor for rebinding patterns. It does not need a monadic context
--   for generating fresh names, since <tt>Rebind</tt> can only occur in
--   the pattern of a <a>Bind</a>; hence a previous call to <a>unbind</a>
--   (or something similar) must have already freshened the names at this
--   point.
unrebind :: (Alpha p1, Alpha p2) => Rebind p1 p2 -> (p1, p2)

-- | If <tt>p</tt> is a pattern type, then <tt>Rec p</tt> is also a pattern
--   type, which is <i>recursive</i> in the sense that <tt>p</tt> may bind
--   names in terms embedded within itself. Useful for encoding e.g.
--   lectrec and Agda's dot notation.
data Rec p

-- | Constructor for recursive patterns.
rec :: Alpha p => p -> Rec p

-- | Destructor for recursive patterns.
unrec :: Alpha p => Rec p -> p

-- | <tt>TRec</tt> is a standalone variant of <a>Rec</a>: the only
--   difference is that whereas <tt><a>Rec</a> p</tt> is a pattern type,
--   <tt>TRec p</tt> is a <i>term type</i>. It is isomorphic to
--   <tt><a>Bind</a> (<a>Rec</a> p) ()</tt>.
--   
--   Note that <tt>TRec</tt> corresponds to Pottier's <i>abstraction</i>
--   construct from alpha-Caml. In this context, <tt><a>Embed</a> t</tt>
--   corresponds to alpha-Caml's <tt>inner t</tt>, and <tt><a>Shift</a>
--   (<a>Embed</a> t)</tt> corresponds to alpha-Caml's <tt>outer t</tt>.
data TRec p

-- | Constructor for recursive abstractions.
trec :: Alpha p => p -> TRec p

-- | Destructor for recursive abstractions which picks globally fresh names
--   for the binders.
untrec :: (Fresh m, Alpha p) => TRec p -> m p

-- | Destructor for recursive abstractions which picks <i>locally</i> fresh
--   names for binders (see <a>LFresh</a>).
luntrec :: (LFresh m, Alpha p) => TRec p -> m p

-- | Shift the scope of an embedded term one level outwards.
newtype Shift p
Shift :: p -> Shift p

-- | Determine the alpha-equivalence of two terms.
aeq :: Alpha t => t -> t -> Bool

-- | Determine (alpha-)equivalence of patterns. Do they bind the same
--   variables in the same patterns and have alpha-equivalent annotations
--   in matching positions?
aeqBinders :: Alpha p => p -> p -> Bool

-- | An alpha-respecting total order on terms involving binders.
acompare :: Alpha t => t -> t -> Ordering

-- | Calculate the free variables of a particular sort contained in a term.
fv :: (Rep a, Alpha t, Collection f) => t -> f (Name a)

-- | Calculate the free variables (of any sort) contained in a term.
fvAny :: (Alpha t, Collection f) => t -> f AnyName

-- | Calculate the variables of a particular sort that occur freely in
--   terms embedded within a pattern (but are not bound by the pattern).
patfv :: (Rep a, Alpha p, Collection f) => p -> f (Name a)

-- | Calculate the variables (of any sort) that occur freely in terms
--   embedded within a pattern (but are not bound by the pattern).
patfvAny :: (Alpha p, Collection f) => p -> f AnyName

-- | Calculate the binding variables (of a particular sort) in a pattern.
binders :: (Rep a, Alpha p, Collection f) => p -> f (Name a)

-- | Calculate the binding variables (of any sort) in a pattern.
bindersAny :: (Alpha p, Collection f) => p -> f AnyName

-- | Collections are foldable types that support empty, singleton, union,
--   and map operations. The result of a free variable calculation may be
--   any collection. Instances are provided for lists, sets, and multisets.
class Foldable f => Collection f
emptyC :: Collection f => f a
singleton :: Collection f => a -> f a
union :: (Collection f, Ord a) => f a -> f a -> f a
cmap :: (Collection f, Ord a, Ord b) => (a -> b) -> f a -> f b

-- | A simple representation of multisets.
newtype Multiset a
Multiset :: (Map a Int) -> Multiset a

-- | The <tt>Subst</tt> class governs capture-avoiding substitution. To
--   derive this class, you only need to indicate where the variables are
--   in the data type, by overriding the method <a>isvar</a>.
class Rep1 (SubstD b) a => Subst b a where isvar _ = Nothing isCoerceVar _ = Nothing subst n u x | isFree n = case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> if m == n then u else x Nothing -> case (isCoerceVar x :: Maybe (SubstCoerce a b)) of { Just (SubstCoerce m f) -> if m == n then maybe x id (f u) else x Nothing -> substR1 rep1 n u x } } subst m _ _ = error $ "Cannot substitute for bound variable " ++ show m substs ss x | all (isFree . fst) ss = case (isvar x :: Maybe (SubstName a b)) of { Just (SubstName m) -> case find ((== m) . fst) ss of { Just (_, u) -> u Nothing -> x } Nothing -> case isCoerceVar x :: Maybe (SubstCoerce a b) of { Just (SubstCoerce m f) -> case find ((== m) . fst) ss of { Just (_, u) -> maybe x id (f u) Nothing -> x } Nothing -> substsR1 rep1 ss x } } | otherwise = error $ "Cannot substitute for bound variable in: " ++ show (map fst ss)
isvar :: Subst b a => a -> Maybe (SubstName a b)
isCoerceVar :: Subst b a => a -> Maybe (SubstCoerce a b)
subst :: Subst b a => Name b -> b -> a -> a
substs :: Subst b a => [(Name b, b)] -> a -> a

-- | See <a>isvar</a>.
data SubstName a b
SubstName :: Name a -> SubstName a b

-- | A <i>permutation</i> is a bijective function from names to names which
--   is the identity on all but a finite set of names. They form the basis
--   for nominal approaches to binding, but can also be useful in general.
data Perm a

-- | Create a permutation which swaps two elements.
single :: Ord a => a -> a -> Perm a

-- | Compose two permutations. The right-hand permutation will be applied
--   first.
compose :: Ord a => Perm a -> Perm a -> Perm a

-- | Apply a permutation to an element of the domain.
apply :: Ord a => Perm a -> a -> a

-- | The <i>support</i> of a permutation is the set of elements which are
--   not fixed.
support :: Ord a => Perm a -> [a]

-- | Is this the identity permutation?
isid :: Ord a => Perm a -> Bool

-- | <i>Join</i> two permutations by taking the union of their relation
--   graphs. Fail if they are inconsistent, i.e. map the same element to
--   two different elements.
join :: Ord a => Perm a -> Perm a -> Maybe (Perm a)

-- | The empty (identity) permutation.
empty :: Perm a

-- | Restrict a permutation to a certain domain.
restrict :: Ord a => Perm a -> [a] -> Perm a

-- | <tt>mkPerm l1 l2</tt> creates a permutation that sends <tt>l1</tt> to
--   <tt>l2</tt>. Fail if there is no such permutation, either because the
--   lists have different lengths or because they are inconsistent (which
--   can only happen if <tt>l1</tt> or <tt>l2</tt> have repeated elements).
mkPerm :: Ord a => [a] -> [a] -> Maybe (Perm a)

-- | Apply a permutation to a term.
swaps :: Alpha t => Perm AnyName -> t -> t

-- | Apply a permutation to the embedded terms in a pattern. Binding names
--   are left alone by the permutation.
swapsEmbeds :: Alpha p => Perm AnyName -> p -> p

-- | Apply a permutation to the binding variables in a pattern. Embedded
--   terms are left alone by the permutation.
swapsBinders :: Alpha p => Perm AnyName -> p -> p

-- | Freshen a pattern by replacing all old binding <a>Name</a>s with new
--   fresh <a>Name</a>s, returning a new pattern and a <tt><a>Perm</a>
--   <a>Name</a></tt> specifying how <a>Name</a>s were replaced.
freshen :: (Alpha p, Fresh m) => p -> m (p, Perm AnyName)

-- | The <tt>Fresh</tt> type class governs monads which can generate new
--   globally unique <a>Name</a>s based on a given <a>Name</a>.
class Monad m => Fresh m
fresh :: Fresh m => Name a -> m (Name a)

-- | A convenient monad which is an instance of <a>Fresh</a>. It keeps
--   track of a global index used for generating fresh names, which is
--   incremented every time <a>fresh</a> is called.
type FreshM = FreshMT Identity

-- | Run a FreshM computation (with the global index starting at zero).
runFreshM :: FreshM a -> a

-- | The <tt>FreshM</tt> monad transformer. Keeps track of the lowest index
--   still globally unused, and increments the index every time it is asked
--   for a fresh name.
data FreshMT m a

-- | Run a <a>FreshMT</a> computation (with the global index starting at
--   zero).
runFreshMT :: Monad m => FreshMT m a -> m a

-- | "Locally" freshen a pattern, replacing all binding names with new
--   names that are not already "in scope". The second argument is a
--   continuation, which takes the renamed term and a permutation that
--   specifies how the pattern has been renamed. The resulting computation
--   will be run with the in-scope set extended by the names just
--   generated.
lfreshen :: (Alpha p, LFresh m) => p -> (p -> Perm AnyName -> m b) -> m b

-- | This is the class of monads that support freshness in an (implicit)
--   local scope. Generated names are fresh for the current local scope,
--   not necessarily globally fresh.
class Monad m => LFresh m
lfresh :: (LFresh m, Rep a) => Name a -> m (Name a)
avoid :: LFresh m => [AnyName] -> m a -> m a
getAvoids :: LFresh m => m (Set AnyName)

-- | A convenient monad which is an instance of <a>LFresh</a>. It keeps
--   track of a set of names to avoid, and when asked for a fresh one will
--   choose the first unused numerical name.
type LFreshM = LFreshMT Identity

-- | Run a LFreshM computation in an empty context.
runLFreshM :: LFreshM a -> a

-- | The LFresh monad transformer. Keeps track of a set of names to avoid,
--   and when asked for a fresh one will choose the first numeric prefix of
--   the given name which is currently unused.
data LFreshMT m a

-- | Run an <a>LFreshMT</a> computation in an empty context.
runLFreshMT :: LFreshMT m a -> m a

-- | The <tt>Alpha</tt> type class is for types which may contain names.
--   The <a>Rep1</a> constraint means that we can only make instances of
--   this class for types that have generic representations (which can be
--   automatically derived by RepLib.)
--   
--   Note that the methods of <tt>Alpha</tt> should almost never be called
--   directly. Instead, use other methods provided by this module which are
--   defined in terms of <tt>Alpha</tt> methods.
--   
--   Most of the time, the default definitions of these methods will
--   suffice, so you can make an instance for your data type by simply
--   declaring
--   
--   <pre>
--   instance Alpha MyType
--   </pre>
--   
--   Occasionally, however, it may be useful to override the default
--   implementations of one or more <tt>Alpha</tt> methods for a particular
--   type. For example, consider a type like
--   
--   <pre>
--   data Term = ...
--             | Annotation Stuff Term
--   </pre>
--   
--   where the <tt>Annotation</tt> constructor of <tt>Term</tt> associates
--   some sort of annotation with a term --- say, information obtained from
--   a parser about where in an input file the term came from. This
--   information is needed to produce good error messages, but should not
--   be taken into consideration when, say, comparing two <tt>Term</tt>s
--   for alpha-equivalence. In order to make <tt>aeq</tt> ignore
--   annotations, you can override the implementation of <tt>aeq'</tt> like
--   so:
--   
--   <pre>
--   instance Alpha Term where
--     aeq' c (Annotation _ t1) t2 = aeq' c t1 t2
--     aeq' c t1 (Annotation _ t2) = aeq' c t1 t2
--     aeq' c t1 t2 = aeqR1 rep1 t1 t2
--   </pre>
--   
--   Note how the call to <a>aeqR1</a> handles all the other cases
--   generically.
class (Show a, Rep1 AlphaD a) => Alpha a where swaps' = swapsR1 rep1 fv' = fvR1 rep1 lfreshen' = lfreshenR1 rep1 freshen' = freshenR1 rep1 aeq' = aeqR1 rep1 acompare' = acompareR1 rep1 close = closeR1 rep1 open = openR1 rep1 isPat = isPatR1 rep1 isTerm = isTermR1 rep1 isEmbed _ = False nthpatrec = nthpatR1 rep1 findpatrec = findpatR1 rep1
swaps' :: Alpha a => AlphaCtx -> Perm AnyName -> a -> a
fv' :: (Alpha a, Collection f) => AlphaCtx -> a -> f AnyName
lfreshen' :: (Alpha a, LFresh m) => AlphaCtx -> a -> (a -> Perm AnyName -> m b) -> m b
freshen' :: (Alpha a, Fresh m) => AlphaCtx -> a -> m (a, Perm AnyName)
aeq' :: Alpha a => AlphaCtx -> a -> a -> Bool
acompare' :: Alpha a => AlphaCtx -> a -> a -> Ordering
close :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
open :: (Alpha a, Alpha b) => AlphaCtx -> b -> a -> a
isPat :: Alpha a => a -> Maybe [AnyName]
isTerm :: Alpha a => a -> Bool
isEmbed :: Alpha a => a -> Bool
nthpatrec :: Alpha a => a -> NthCont
findpatrec :: Alpha a => a -> AnyName -> FindResult
rName :: Rep a_a4yl => R (Name a_a4yl)
rGenBind :: (Rep order_aa3O, Rep card_aa3P, Rep p_aa3Q, Rep t_aa3R) => R (GenBind order_aa3O card_aa3P p_aa3Q t_aa3R)
rRebind :: (Rep p1_aa3G, Rep p2_aa3H) => R (Rebind p1_aa3G p2_aa3H)
rEmbed :: Rep t_aa3D => R (Embed t_aa3D)
rRec :: Rep p_aa3F => R (Rec p_aa3F)
rShift :: Rep p_aa3C => R (Shift p_aa3C)
