-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for bidirectional JSON parsing
--   
@package JsonGrammar
@version 1.0.2


-- | JsonGrammar allows you to express a bidirectional mapping between
--   Haskell datatypes and JSON ASTs in one go.
module Language.JsonGrammar

-- | A <tt>Grammar</tt> provides a bidirectional mapping between a Haskell
--   datatype and its JSON encoding. Its first type argument specifies its
--   context: either it's defining properties (context <a>Obj</a>), array
--   elements (context <a>Arr</a>) or values (context <a>Val</a>).
data Grammar (c :: Context) t1 t2

-- | The context of a grammar. Most combinators ask for a grammar in a
--   specific context as input, and produce a grammar in another context.
data Context

-- | Value context
Val :: Context

-- | Object context, for defining object members
Obj :: Context

-- | Array context, for defining array elements
Arr :: Context
data (:-) h t :: * -> * -> *
(:-) :: h -> t -> (:-) h t

-- | Creates a pure grammar that doesn't specify any JSON format but just
--   operates on the Haskell level. Pure grammars can be used in any
--   context.
pure :: (t1 -> Parser t2) -> (t2 -> Maybe t1) -> Grammar c t1 t2

-- | Try to apply a grammar as many times as possible. The argument
--   grammar's output is fed to itself as input until doing so again would
--   fail. This allows you to express repetitive constructions such as
--   array elements. <a>many</a> can be used in any context.
many :: Grammar c t t -> Grammar c t t

-- | Expect or produce a literal JSON <a>Value</a>. You can only use this
--   constructor in the value context <a>Val</a>.
literal :: Value -> Grammar Val (Value :- t) t

-- | Label a value grammar with a name. This doesn't affect the JSON
--   conversion itself, but it generates an interface definition when
--   converting to TypeScript <tt>interfaces</tt>.
label :: Text -> Grammar Val t1 t2 -> Grammar Val t1 t2

-- | Expect or produce a JSON object whose properties match the specified
--   <a>Obj</a> grammar. You can create <a>Obj</a> grammars using
--   <a>property</a>. Alternatively, if you want to match an empty object,
--   use <tt>object <a>id</a></tt>.
object :: Grammar Obj t1 t2 -> Grammar Val (Value :- t1) t2

-- | Expect or produce an object property with the specified name, and a
--   value that can be parsed/produced by the specified grammar. This
--   function creates a grammar in the <a>Obj</a> context. You can combine
--   multiple <tt>property</tt> grammars using the <a>.</a> operator from
--   <a>Category</a>.
--   
--   Use <tt>&lt;&gt;</tt> to denote choice. For example, if you are
--   creating an object with a property called <tt>"type"</tt>, whose value
--   determines what other properties your object has, you can write it
--   like this:
--   
--   <pre>
--   grammar = object (propertiesA &lt;&gt; propertiesB)
--     where
--       propertiesA = property "type" "A" . fromPrism constructorA . prop "foo"
--       propertiesB = property "type" "B" . fromPrism constructorB . prop "bar" . prop "baz"
--   </pre>
property :: Text -> Grammar Val (Value :- t1) t2 -> Grammar Obj t1 t2

-- | Expect or produce a JSON array value whose contents match the
--   specified <a>Arr</a> grammar. You can create <a>Arr</a> grammars using
--   <a>element</a>. Alternatively, if you want to match an empty array,
--   use <tt>array <a>id</a></tt>.
array :: Grammar Arr t1 t2 -> Grammar Val (Value :- t1) t2

-- | Expect or produce a JSON array element whose value matches the
--   specified <a>Val</a> grammar.
element :: Grammar Val (Value :- t1) t2 -> Grammar Arr t1 t2

-- | Mark a grammar to be of a specific TypeScript type. This doesn't
--   affect the JSON conversion, but when generating TypeScript
--   <tt>interfaces</tt> a coercion causes the interface generator to stop
--   looking at the underlying grammar and just use the specified
--   TypeScript <a>Type</a> as inferred type instead.
--   
--   This is useful if you write a grammar that, for example, wraps a
--   primitive type like string (in which case you would specify
--   <tt><a>Predefined</a> <a>StringType</a></tt> as type). Another use is
--   when you find the generated interface can't be described by a
--   <a>Grammar</a>, for example because it uses a generic type parameter.
coerce :: Type -> Grammar Val t1 t2 -> Grammar Val t1 t2

-- | Create a <a>pure</a> grammar from a <a>StackPrism</a>.
fromPrism :: StackPrism a b -> Grammar c a b

-- | Create a <a>pure</a> grammar that expects or produces a specific
--   Haskell value.
defaultValue :: Eq a => a -> Grammar c t (a :- t)

-- | A <a>pure</a> grammar that expects or produces the empty list
--   <tt>[]</tt>.
nil :: Grammar c t ([a] :- t)

-- | A <a>pure</a> grammar that expects or produces a cons <tt>:</tt>.
cons :: Grammar c (a :- ([a] :- t)) ([a] :- t)

-- | A <a>pure</a> grammar that wraps or unwraps a tuple.
tup2 :: Grammar c (a :- (b :- t)) ((a, b) :- t)

-- | A type class for types that can be converted from and to JSON using a
--   <a>Grammar</a>. The grammar is expected to be in the value context
--   <a>Val</a> and consumes (or produces) a JSON <a>Value</a>.
class Json a
grammar :: Json a => Grammar Val (Value :- t) (a :- t)

-- | Expect or produce an array <a>element</a> whose value grammar is
--   specified by <a>grammar</a>.
el :: Json a => Grammar Arr t (a :- t)

-- | Expect or produce an object <a>property</a> whose value grammar is
--   specified by <a>grammar</a>.
prop :: Json a => Text -> Grammar Obj t (a :- t)

-- | Parse a JSON value according to the specified grammar.
parse :: Grammar Val (a :- ()) (b :- ()) -> a -> Parser b

-- | Serialize a Haskell value to a JSON value according to the specified
--   grammar.
serialize :: Grammar Val (a :- ()) (b :- ()) -> b -> Maybe a

-- | Generate a list of TypeScript interface declarations from the
--   specified grammars.
interfaces :: [SomeGrammar Val] -> [DeclarationElement]

-- | Wrap a <tt>Grammar</tt>, discarding the input/output type arguments.
data SomeGrammar c
SomeGrammar :: Grammar c t1 t2 -> SomeGrammar c
