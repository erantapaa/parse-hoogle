-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)
--   
--   A package to support reading and writing ipe7 files. It has support
--   for converting from and to several geometry types like Points,
--   (Poly)Lines, Polygons etc.
@package hipe
@version 0.2.0.0

module Data.Geometry.Ipe.InternalTypes

-- | A complete ipe file
data IpeFile a
IpeFile :: Maybe IpePreamble -> [IpeStyle] -> [IpePage a] -> IpeFile a
preamble :: IpeFile a -> Maybe IpePreamble
styles :: IpeFile a -> [IpeStyle]
ipePages :: IpeFile a -> [IpePage a]

-- | the maybe string is the styles name
data IpeStyle
IpeStyle :: (Maybe String) -> [XmlTree] -> IpeStyle

-- | The maybe string is the encoding
data IpePreamble
IpePreamble :: (Maybe String) -> XmlTree -> IpePreamble
type IpeBitmap = XmlTree

-- | Represents the <a>page</a> tag
data IpePage a
IpePage :: [LayerDefinition] -> [ViewDefinition] -> [IpeObject a] -> IpePage a
type LayerDefinition = String

-- | The definition of a view make active layer into an index ?
data ViewDefinition
ViewDefinition :: [String] -> String -> ViewDefinition
layerNames :: ViewDefinition -> [String]
activeLayer :: ViewDefinition -> String

-- | An ipe-object. The main `<tt>thing'</tt> that defines the drawings
data IpeObject a
Path :: [Operation a] -> AMap -> IpeObject a
Group :: [IpeObject a] -> AMap -> IpeObject a
IpeText :: String -> AMap -> IpeObject a
Use :: (Point2' a) -> AMap -> IpeObject a

-- | Attribute Map
type AMap = Map String String

-- | type that represents a path in ipe.
data Operation a
MoveTo :: (Point2' a) -> Operation a
LineTo :: (Point2' a) -> Operation a
CurveTo :: (Point2' a) -> (Point2' a) -> (Point2' a) -> Operation a
QCurveTo :: (Point2' a) -> (Point2' a) -> Operation a
Ellipse :: (Matrix3 a) -> Operation a
ArcTo :: (Matrix3 a) -> (Point2' a) -> Operation a
Spline :: [Point2' a] -> Operation a
ClosedSpline :: [Point2' a] -> Operation a
ClosePath :: Operation a

-- | Stuff with attributes
class HasAttributes c where getAttr s o = lookup s . attrs $ o setAttr k v = updateWith (insert k v) setAttrs ats = updateWith (insertAll ats) where insertAll :: [(String, String)] -> AMap -> AMap insertAll ats m = foldr (uncurry insert) m ats hasAttrWithValue at val o = Just val == getAttr at o hasAttr s = isJust . getAttr s extractAttr s = updateWith (delete s)
attrs :: HasAttributes c => c -> AMap
updateWith :: HasAttributes c => (AMap -> AMap) -> c -> c
getAttr :: HasAttributes c => String -> c -> Maybe String
setAttr :: HasAttributes c => String -> String -> c -> c
setAttrs :: HasAttributes c => [(String, String)] -> c -> c
hasAttrWithValue :: HasAttributes c => String -> String -> c -> Bool
hasAttr :: HasAttributes c => String -> c -> Bool
extractAttr :: HasAttributes c => String -> c -> c
instance Eq IpeStyle
instance Show IpeStyle
instance Eq IpePreamble
instance Show IpePreamble
instance Eq ViewDefinition
instance Show ViewDefinition
instance Eq a => Eq (Operation a)
instance Show a => Show (Operation a)
instance Eq a => Eq (IpeObject a)
instance Show a => Show (IpeObject a)
instance Eq a => Eq (IpePage a)
instance Show a => Show (IpePage a)
instance Eq a => Eq (IpeFile a)
instance Show a => Show (IpeFile a)
instance HasAttributes (IpeObject a)
instance IsPoint2Functor Operation
instance IsPoint2Functor IpeObject

module Data.Geometry.Ipe.IpeGeometryTypes

-- | An ipe point.
data IpePoint' a
IpePoint :: (Point2' a) -> AMap -> IpePoint' a

-- | create a default ipe point from a given point
fromPoint :: Point2' a -> IpePoint' a

-- | A polyline
data IpePolyline' a
IpePolyline :: [LineSegment2' a] -> AMap -> IpePolyline' a
toPolyLine :: IpePolyline' a -> Polyline2' a
fromPolyline :: Polyline2' a -> IpePolyline' a

-- | Polygons
data IpeSimplePolygon' a
IpeSimplePolygon :: [Point2' a] -> AMap -> IpeSimplePolygon' a
data IpeMultiPolygon' a
IpeMultiPolygon :: [SimplePolygon' a] -> AMap -> IpeMultiPolygon' a
instance Eq a => Eq (IpePoint' a)
instance Ord a => Ord (IpePoint' a)
instance Read a => Read (IpePoint' a)
instance Show a => Show (IpePoint' a)
instance Show a => Show (IpePolyline' a)
instance Eq a => Eq (IpePolyline' a)
instance Show a => Show (IpeSimplePolygon' a)
instance Eq a => Eq (IpeSimplePolygon' a)
instance Show a => Show (IpeMultiPolygon' a)
instance Eq a => Eq (IpeMultiPolygon' a)
instance IsPolygon IpeMultiPolygon'
instance HasAttributes (IpeMultiPolygon' a)
instance HasPoints IpeMultiPolygon'
instance IsPoint2Functor IpeMultiPolygon'
instance IsPolygon IpeSimplePolygon'
instance HasAttributes (IpeSimplePolygon' a)
instance HasPoints IpeSimplePolygon'
instance IsPoint2Functor IpeSimplePolygon'
instance HasAttributes (IpePolyline' a)
instance HasPoints IpePolyline'
instance IsPoint2Functor IpePolyline'
instance HasAttributes (IpePoint' a)
instance HasPoints IpePoint'
instance IsPoint2Functor IpePoint'

module Data.Geometry.Ipe.IGC

-- | an ipe geometry collection
data IGC a
IGC :: String -> [IpePoint' a] -> [IpePolyline' a] -> [IpeSimplePolygon' a] -> [IpeMultiPolygon' a] -> IGC a
name :: IGC a -> String
points :: IGC a -> [IpePoint' a]
polyLines :: IGC a -> [IpePolyline' a]
simplePolygons :: IGC a -> [IpeSimplePolygon' a]
multiPolygons :: IGC a -> [IpeMultiPolygon' a]

-- | Stuff that we can store in a IpGeometryCollection
class IsIpeGeometry g where g <| c = insert g c insertAll gs col = foldr insert col gs
insert :: IsIpeGeometry g => g a -> IGC a -> IGC a
(<|) :: IsIpeGeometry g => g a -> IGC a -> IGC a
insertAll :: IsIpeGeometry g => [g a] -> IGC a -> IGC a
empty :: IGC a
singleton :: IsIpeGeometry g => g a -> IGC a
fromList :: IsIpeGeometry g => [g a] -> IGC a
mergeAll :: [IGC a] -> IGC a
updateAll :: (forall t. HasAttributes t => t -> t) -> IGC a -> IGC a
instance Show a => Show (IGC a)
instance Eq a => Eq (IGC a)
instance IsIpeGeometry IpeMultiPolygon'
instance IsIpeGeometry IpeSimplePolygon'
instance IsIpeGeometry IpePolyline'
instance IsIpeGeometry IpePoint'
instance Monoid (IGC a)

module Data.Geometry.Ipe.ReadIpeGeometry

-- | Typeclass expressing which ipetypes we can convert into a IGC
--   
--   minimal implementation: toIGC
class IsConvertableToIGC t where type family PM t listToIGC = foldr (mappend . toIGC) empty perEntry = map (\ e -> (e, toIGC e))
toIGC :: IsConvertableToIGC t => t -> IGC (PM t)
listToIGC :: IsConvertableToIGC t => [t] -> IGC (PM t)
perEntry :: IsConvertableToIGC t => [t] -> [(t, IGC (PM t))]
instance Eq GeometryType
instance Show GeometryType
instance IsConvertableToIGC (IpeObject a)
instance IsConvertableToIGC (IpePage a)
instance IsConvertableToIGC (IpeFile a)

module Data.Geometry.Ipe.WriteIpeGeometry
class IsConvertableToIpeObject g where type family PM g toIpeObjects = mapMaybe toIpeObject
toIpeObject :: IsConvertableToIpeObject g => g -> Maybe (IpeObject (PM g))
toIpeObjects :: IsConvertableToIpeObject g => [g] -> [IpeObject (PM g)]
toIpeObjects' :: IGC a -> [IpeObject a]
instance IsConvertableToIpeObject (IGC a)
instance IsConvertableToIpeObject (IpeMultiPolygon' a)
instance IsConvertableToIpeObject (IpeSimplePolygon' a)
instance IsConvertableToIpeObject (IpePolyline' a)
instance IsConvertableToIpeObject (IpePoint' a)

module Data.Geometry.Ipe.Pickle

-- | Represent stuff that can be used as a coordinate in ipe. (similar to
--   show/read)
class (Fractional a, Ord a) => Coordinate a where fromSeq x Nothing = fromInteger x fromSeq x (Just y) = let x' = fromInteger x y' = fromInteger y asDecimal = head . dropWhile (>= 1) . iterate (* 0.1) in signum x' * (abs x' + asDecimal y')
toIpeOut :: Coordinate a => a -> String
fromSeq :: Coordinate a => Integer -> Maybe Integer -> a

-- | Load an ipe drawing from a file
loadFile :: Coordinate a => FilePath -> IO (IpeFile a)

-- | Store an ipe drawing in a file
storeFile :: Coordinate a => IpeFile a -> FilePath -> IO ()
loadFileA :: Coordinate a => Kleisli IO FilePath (IpeFile a)
storeFileA :: Coordinate a => FilePath -> Kleisli IO (IpeFile a) ()
unpickle :: PU a -> FilePath -> IO [a]
xpLoadSettings :: [SysConfig]
xpStoreSettings :: [SysConfig]
instance IsIpeWriteable Operation
instance IsIpeWriteable Point2'
instance IsIpeWriteable Matrix3
instance XmlPickler ViewDefinition
instance Coordinate a => XmlPickler (IpeFile a)
instance Coordinate a => XmlPickler (IpePage a)
instance Coordinate a => XmlPickler (IpeObject a)
instance Coordinate (Ratio Integer)
instance Coordinate Double

module Data.Geometry.Ipe.IpeTypes

-- | Representing ipe drawings
data IpeDrawing a
IpeDrawing :: [Page a] -> IpeDrawing a
pages :: IpeDrawing a -> [Page a]
data Page a
Page :: [Layer a] -> [ViewDefinition] -> Page a
layers :: Page a -> [Layer a]
views :: Page a -> [ViewDefinition]
data Layer a
Layer :: LayerDefinition -> IGC a -> Layer a
layerDef :: Layer a -> LayerDefinition
layerContent :: Layer a -> IGC a

-- | A new blank ipe drawing
emptyDrawing :: IpeDrawing a

-- | A new empty page
emptyPage :: Page a
emptyLayer :: Layer a

-- | Getting the content of pages/layers etc
class HasContent t where type family PM t
content :: HasContent t => t -> IGC (PM t)

-- | Merges the two drawings. i.e. page by page we merge the pages in the
--   sense that objects on layers with the same names are *BOTH* included
extend :: IpeDrawing a -> IpeDrawing a -> IpeDrawing a

-- | Working with views
view :: [LayerDefinition] -> ViewDefinition
runOnFile :: Arrow arr => arr (IpeDrawing a) (IpeDrawing b) -> arr (IpeFile a) (IpeFile b)

-- | Manipulating Ipe documents
runOnPath :: Coordinate a => Kleisli IO (IpeDrawing a) (IpeDrawing b) -> Kleisli IO FilePath (IpeFile b)

-- | Querying a drawing for layers<i>views</i>pages etc
findLayer :: Int -> LayerDefinition -> IpeDrawing a -> Maybe (Layer a)
findLayer' :: LayerDefinition -> Page a -> Maybe (Layer a)

-- | A complete ipe file
data IpeFile a
type LayerDefinition = String

-- | The definition of a view make active layer into an index ?
data ViewDefinition
ViewDefinition :: [String] -> String -> ViewDefinition
layerNames :: ViewDefinition -> [String]
activeLayer :: ViewDefinition -> String

-- | Attribute Map
type AMap = Map String String

-- | Stuff with attributes
class HasAttributes c where getAttr s o = lookup s . attrs $ o setAttr k v = updateWith (insert k v) setAttrs ats = updateWith (insertAll ats) where insertAll :: [(String, String)] -> AMap -> AMap insertAll ats m = foldr (uncurry insert) m ats hasAttrWithValue at val o = Just val == getAttr at o hasAttr s = isJust . getAttr s extractAttr s = updateWith (delete s)
attrs :: HasAttributes c => c -> AMap
updateWith :: HasAttributes c => (AMap -> AMap) -> c -> c
getAttr :: HasAttributes c => String -> c -> Maybe String
setAttr :: HasAttributes c => String -> String -> c -> c
setAttrs :: HasAttributes c => [(String, String)] -> c -> c
hasAttrWithValue :: HasAttributes c => String -> String -> c -> Bool
hasAttr :: HasAttributes c => String -> c -> Bool
extractAttr :: HasAttributes c => String -> c -> c
instance Show a => Show (Layer a)
instance Eq a => Eq (Layer a)
instance Show a => Show (Page a)
instance Eq a => Eq (Page a)
instance Show a => Show (IpeDrawing a)
instance Eq a => Eq (IpeDrawing a)
instance HasContent (Layer a)
instance HasContent (Page a)
instance HasContent (IpeDrawing a)
instance Monoid (Layer a)
instance Monoid (Page a)
instance Monoid (IpeDrawing a)

module Data.Geometry.Ipe.Ipe
