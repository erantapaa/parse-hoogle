-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | haskell supercollider data
--   
@package hsc3-data
@version 0.15

module Sound.SC3.Data.Trace

-- | Traces are sequences <tt>Ord t =&gt; [(t,a)]</tt> where t is
--   ascending.
--   
--   Ordinarily t is a time-point, and traces are temporal.
--   
--   However <i>t</i> may be, for instance, distance traversed so that line
--   segments (sequences of cartesian points) can be transformed into
--   Traces by associating each point with the distance along the line.
--   
--   If there is an interpolation function (linear or otherwise) for the
--   type <i>a</i> we can lookup a value for any index <i>t</i> in the
--   window of the trace.
--   
--   Traces can be both more accurate and more compact than sampled data
--   streams.
--   
--   Break-point envelopes are Traces where <i>a</i> is a scalar
--   <tt>(interpolation-type,value)</tt>.
--   
--   Traces are <i>normal</i> if t0 is &gt;= 0 and tn is &lt;= 1.
--   
--   Traces are <i>strictly normal</i> if t0 == 0 and tn == 1.
type Trace t a = [(t, a)]

-- | Start time of trace, or zero for null trace.
trace_start_time :: Num t => Trace t a -> t

-- | End time of trace, or zero for null trace.
trace_end_time :: Num t => Trace t a -> t

-- | A trace window is a pait (t0,t1) indicating the begin and end time
--   points.
type Window t = (t, t)

-- | Start and end times of trace, or (0,0) for null trace.
trace_window :: Num t => Trace t a -> Window t

-- | Interpolation function type.
type Lerp_F t a b = t -> a -> a -> b

-- | Synonym for real valued time point.
type Time = R

-- | Load real valued trace stored as a sound file.
--   
--   The temporal data is in the first channel, subsequent channels are
--   associated data points. If set <i>nc</i> is set it requires the file
--   have precisely the indicated number of _data_ channels, ie. <i>nc</i>
--   does not include the _temporal_ channel.
trace_load_sf :: Maybe Int -> FilePath -> IO (Trace Time [R])

-- | Variant for loading two-channel trace file.
trace_load_sf2 :: FilePath -> IO (Trace Time (R, R))

-- | Variant for set of traces given by <a>glob</a> pattern'.
trace_load_sf_dir :: Maybe Int -> String -> IO [Trace Time [R]]
trace_load_sf2_dir :: String -> IO [Trace Time (R, R)]

-- | Map over trace times.
trace_map_t :: (t -> t') -> Trace t a -> Trace t' a

-- | Map over trace values.
trace_map :: (a -> b) -> Trace t a -> Trace t b

-- | Trace nodes that bracket time <i>t</i>, and trace starting from left
--   neighbour.
--   
--   <pre>
--   map (trace_locate (zip [0..9] ['a'..])) [-1,3.5,10]
--   </pre>
trace_locate :: (Ord t, Fractional t) => Trace t a -> t -> Either String (((t, a), (t, a)), Trace t a)

-- | <a>fst</a> of <a>trace_locate</a>
--   
--   <pre>
--   trace_neighbours (zip [0..9] ['a'..]) 3.5 == Just ((3.0,'d'),(4.0,'e'))
--   </pre>
trace_neighbours :: (Ord t, Fractional t) => Trace t a -> t -> Maybe ((t, a), (t, a))

-- | <a>fromJust</a> of <a>trace_neighbours</a>.
trace_neighbours_err :: (Fractional t, Ord t) => Trace t a -> t -> ((t, a), (t, a))

-- | Interpolate between to trace points using given interpolation
--   function.
trace_lerp :: Fractional t => Lerp_F t a b -> t -> (t, a) -> (t, a) -> (t, b)

-- | Linear interpolating lookup, ie. <a>trace_lerp</a> of
--   <a>trace_neighbours</a>.
--   
--   <pre>
--   t &lt;- trace_load_sf2_dir "/home/rohan/sw/hsc3-data/help/au/*.txy.au"
--   map (\z -&gt; trace_lookup lerpn2 z 0.5) t
--   </pre>
trace_lookup :: (Ord t, Fractional t) => Lerp_F t a b -> Trace t a -> t -> Maybe (t, b)

-- | <a>trace_lookup</a> with default value.
trace_lookup_def :: (Ord t, Fractional t) => b -> Lerp_F t a b -> Trace t a -> t -> (t, b)

-- | <a>fromJust</a> of <a>trace_lookup</a>.
trace_lookup_err :: (Ord t, Fractional t) => Lerp_F t a b -> Trace t a -> t -> (t, b)
trace_lookup_seq_asc :: (Ord t, Fractional t) => Lerp_F t a b -> Trace t a -> [t] -> Trace t b

-- | Normalise so that <a>trace_window</a> is (0,1).
--   
--   <pre>
--   let r = [(0,'a'),(0.2,'b'),(1,'c')]
--   in trace_normalise_t [(0,'a'),(1,'b'),(5,'c')] == r
--   </pre>
trace_normalise_t :: Fractional t => Trace t a -> Trace t a

-- | Transform trace to an <i>n</i>-point linear form (time-points are
--   equi-distant) over indicated <a>Window</a> (which must be ascending,
--   ie <i>t0</i> &lt; <i>t1</i>).
trace_linearise :: (Ord t, Fractional t) => Int -> Lerp_F t a b -> Trace t a -> Window t -> Trace t b

-- | Variant where the range is derived implicity from input trace
--   (<a>trace_window</a>).
--   
--   <pre>
--   t &lt;- trace_load_sf2_dir "/home/rohan/sw/hsc3-data/help/au/*.txy.au"
--   plotCoord (map (trace_linearise_w 1024 lerpn . trace_map fst) t)
--   plotCoord (map (trace_map fst) t)
--   trace2_plot_tbl t
--   </pre>
trace_linearise_w :: (Ord t, Fractional t) => Int -> Lerp_F t a b -> Trace t a -> Trace t b

-- | Values only of <a>trace_linearise_w</a>.
--   
--   <pre>
--   plotTable (map (trace_table 1024 lerpn . trace_map fst) t)
--   </pre>
trace_table :: (Ord t, Fractional t) => Int -> Lerp_F t a b -> Trace t a -> [b]

-- | Variant of <tt>trace_linearize</tt> assuming <i>t</i> is normalised.
--   
--   <pre>
--   trace_rescale lerpd [(0,[1]),(2,[2])] 3 == [(0,[1]),(0.5,[1.25]),(1,[1.5])]
--   </pre>
trace_rescale :: (Eq t, Ord t, Fractional t) => Lerp_F t a b -> Trace t a -> Int -> Trace t b

-- | Interpolate maintaining temporal shape, divide each step in half.
--   
--   <pre>
--   let r = [(0,[0]),(0.5,[0.5]),(1,[1]),(2.5,[2.5]),(4,[4])]
--   in trace_expand lerpd [(0,[0]),(1,[1]),(4,[4])] == r
--   </pre>
--   
--   <pre>
--   trace2_plot_3d (map (trace_expand lerpn2) t)
--   </pre>
trace_expand :: Fractional t => Lerp_F t a a -> Trace t a -> Trace t a

-- | Recursive expansion
--   
--   <pre>
--   length (trace_expand_n lerpd [(0,[0]),(1,[1]),(4,[4])] 3) == 17
--   </pre>
trace_expand_n :: (Fractional t, Integral n) => Lerp_F t a a -> Trace t a -> n -> Trace t a

-- | Linear interpolation.
--   
--   <pre>
--   zipWith (lerpn 0.25) [4,5] [6,9] == [4.5,6.0]
--   </pre>
lerpn :: Num a => a -> a -> a -> a

-- | Variant at uniform 2-tuple.
--   
--   <pre>
--   lerpn2 0.25 (4,5) (6,9) == (4.5,6.0)
--   </pre>
lerpn2 :: Num n => n -> (n, n) -> (n, n) -> (n, n)

-- | Pointwise linear interpolation at lists.
--   
--   <pre>
--   lerp_pw lerpn 0.25 [4,5] [6,9] == [4.5,6]
--   </pre>
lerp_pw :: Lerp_F t a b -> t -> [a] -> [a] -> [b]

-- | <a>lerp_pw</a> of <a>lerpn</a>.
--   
--   <pre>
--   lerpd 0.25 [4,5] [6,9] == [4.5,6]
--   </pre>
lerpd :: Num c => c -> [c] -> [c] -> [c]

-- | Transform <a>Ls</a> to <a>Trace</a>, <i>t</i> is distance along line.
ls_with_distance :: (Eq t, Floating t) => Ls t -> Trace t (Pt t)

-- | Generic iota function (name courtesy scheme language) with explicit
--   increment. The last value is the given end-point regardless of
--   accumulated errors.
--   
--   <pre>
--   iota' 0 1 0.25 5 == [0,0.25,0.5,0.75,1]
--   </pre>
iota' :: (Eq n, Num n, Eq m, Num m) => n -> n -> n -> m -> [n]

-- | Fractional iota function with implicit increment.
--   
--   <pre>
--   iota 0 1 5 == [0,0.25,0.5,0.75,1]
--   </pre>
iota :: (Integral m, Eq n, Fractional n) => n -> n -> m -> [n]

-- | Alternate elements of two lists.
--   
--   <pre>
--   interleave2 ("one","two") == "otnweo"
--   interleave2 ("long","short") == "lsohnogrt"
--   </pre>
interleave2 :: ([t], [t]) -> [t]

-- | Inverse of <a>interleave2</a>.
--   
--   <pre>
--   interleave2 ("abcd","ABCD") == "aAbBcCdD"
--   deinterleave2 "aAbBcCdD" == ("abcd","ABCD")
--   </pre>
deinterleave2 :: [a] -> ([a], [a])

-- | Three-dimensional plot of two-dimensional traces (<i>time</i> on
--   <tt>x</tt> axis), ie. <a>plotPath</a>.
trace2_plot_3d :: [Trace R (R, R)] -> IO ()

-- | Two-dimensional plot of two-dimensional traces (<i>time</i> not
--   drawn), ie. <a>plotCoord</a>.
trace2_plot_2d :: [Trace R (R, R)] -> IO ()
trace2_plot_tbl :: [Trace R (R, R)] -> IO ()


-- | Load linearised path data from SVG files.
module Sound.SC3.Data.SVG

-- | Make <a>QName</a> with <tt>svg</tt> <a>qURI</a>.
svg_name :: String -> QName
pathFromString' :: String -> Either String [PathCommand]
parse_path :: String -> [PathCommand]
svg_read_path_d :: String -> [[PathCommand]]
subpaths_to_ls :: (Double, Double) -> [PathCommand] -> [Ls Double]
svg_load_ls :: (Double, Double) -> FilePath -> IO [Ls Double]
plot_ls :: PNum t => [Ls t] -> IO ()


-- | <a>http://sprott.physics.wisc.edu/sa.htm</a>
module Sound.SC3.Data.Math.Sprott_1993a

-- | Table 2-1. ASCII character set and associated coefficient values
--   (p.28)
sprott_tbl_2_1 :: [(Char, Int, Double)]

-- | Lookup coeffient at <a>sprott_tbl_2_1</a>.
--   
--   <pre>
--   sprott_coef 'M' == Just 0
--   </pre>
sprott_coef :: Char -> Maybe Double

-- | <a>fromJust</a> of <a>sprott_coef</a>.
sprott_coef_err :: Char -> Double

-- | Pair each elements with the element <i>n</i> places further along.
--   
--   <pre>
--   with_delayed 3 [1..9] == [(1,4),(2,5),(3,6),(4,7),(5,8),(6,9)]
--   </pre>
with_delayed :: Int -> [t] -> [(t, t)]

-- | General one-dimensional quadratic iterated map (Equation 2A, p.25)
quadratic_1 :: Num a => a -> a -> a -> a -> a

-- | List (<i>l</i>) variant of <a>quadratic_1</a>.
quadratic_1l :: Num a => [a] -> a -> a

-- | General one-dimensional quintic iterated map (Equation 2E, p.41)
quintic_1 :: Num a => a -> a -> a -> a -> a -> a -> a -> a

-- | List (<i>l</i>) variant of <a>quintic_1</a>.
quintic_1l :: Num a => [a] -> a -> a

-- | Generalised one-dimensional iterated map.
general_1l :: Num a => [a] -> Maybe (a -> a)

-- | General two-dimensional iterated quadratic map (Equation 3B, p.53)
quadratic_2 :: Num t => t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> (t, t) -> (t, t)

-- | List (<i>l</i>) variant of <a>quadratic_2</a>.
quadratic_2l :: Num t => [t] -> (t, t) -> (t, t)

-- | General two-dimensional iterated cubic map (Equation 3F, p.80)
cubic_2 :: Num t => t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> (t, t) -> (t, t)

-- | List (<i>l</i>) variant of <a>cubic_2</a>.
cubic_2l :: Num t => [t] -> (t, t) -> (t, t)

-- | Generalised two-dimensional iterated map.
general_2l :: Num t => [t] -> Maybe ((t, t) -> (t, t))

-- | General three-dimensional iterated quadratic map (Equation 4A, p.147)
quadratic_3 :: Num t => t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> (t, t, t) -> (t, t, t)

-- | List (<i>l</i>) variant of <a>quadratic_3</a>.
quadratic_3l :: Num t => [t] -> (t, t, t) -> (t, t, t)

-- | Generalised three-dimensional iterated map.
general_3l :: Num t => [t] -> Maybe ((t, t, t) -> (t, t, t))

-- | Projection onto sphere (Equation 3G, p.107)
sphere_proj :: (Floating t, Ord t) => [(t, t)] -> [(t, t)]

-- | Plot one-dimensional code, <i>m</i> is delay, <i>n</i> is iteration
--   degree, <i>i</i> is initial value.
plot_code_1 :: Int -> Int -> Double -> (Code, Annotation) -> IO ()

-- | Plot two-dimensional code, <i>n</i> is iteration degree, <i>i</i> is
--   initial value.
plot_code_2 :: Bool -> Int -> (Double, Double) -> (Code, Annotation) -> IO ()

-- | Plot three-dimensional code, <i>n</i> is iteration degree, <i>i</i> is
--   initial value.
plot_code_3 :: Int -> (Double, Double, Double) -> (Code, Annotation) -> IO ()

-- | A code is a string. The set of book codes are at:
--   <a>http://sprott.physics.wisc.edu/fractals/bookdisk/BOOKFIGS.DIC</a>
--   and there is a further set of codes at:
--   <a>http://sprott.physics.wisc.edu/fractals/bookdisk/SELECTED.DIC</a>
type Code = String
type Annotation = String

-- | One-dimensional codes.
--   
--   <pre>
--   plot_code_1 5 12500 0.1 (codes_1 !! 7)
--   </pre>
codes_1 :: [(Code, Annotation)]

-- | Two-dimensional codes.
--   
--   <pre>
--   plot_code_2 False 25000 (0.1,0) (codes_2 !! 25)
--   </pre>
codes_2 :: [(Code, Annotation)]

-- | Three-dimensional codes.
--   
--   <pre>
--   plot_code_3 15000 (0.1,0,0) (codes_3 !! 1)
--   </pre>
codes_3 :: [(Code, Annotation)]

-- | Sprott p.9 (Equation 1C)
--   
--   <pre>
--   plot_p2_pt [with_delayed 1 (take 5000 (iterate (logistic 4) 0.05))]
--   </pre>
logistic :: Num a => a -> a -> a

-- | Figure 3-1. The Hénon map (p.52)
--   
--   <pre>
--   plot_p2_pt [take 5000 (iterate (henon (-1.4) 0.3) (0.1,0))]
--   </pre>
henon :: Num t => t -> t -> (t, t) -> (t, t)


-- | Perceptual loudness functions.
module Sound.SC3.Data.Math.Loudness

-- | A-weighting curve multiplier function, ie. for linear magnitude --
--   value. See <a>http://en.wikipedia.org/wiki/A-weighting</a>
--   
--   <pre>
--   import Sound.SC3.Plot
--   </pre>
--   
--   <pre>
--   let {f w = map w [20::Double,50 .. 20000]
--       ;r = [a_weighting_R,b_weighting_R,c_weighting_R,d_weighting_R]}
--   in plotTable (map f r)
--   </pre>
--   
--   <pre>
--   let {f w = zip (map log [1..]) (map w [25,50 .. 20000])
--       ;r = [a_weighting_R,b_weighting_R,c_weighting_R,d_weighting_R]}
--   in plot_p2_ln (map f r)
--   </pre>
a_weighting_R :: Floating a => a -> a

-- | A-weighting curve Db offset (additive) function, ie. for un-weighted
--   Db readings.
--   
--   <pre>
--   plotTable1 (map a_weighting [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map a_weighting [25,50 .. 20000])]
--   </pre>
a_weighting :: Floating a => a -> a

-- | B-weighting curve multiplier function, ie. for linear magnitude value.
--   See <a>http://en.wikipedia.org/wiki/A-weighting</a>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable1 (map b_weighting_R [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map b_weighting_R [25,50 .. 20000])]
--   </pre>
b_weighting_R :: Floating a => a -> a

-- | B-weighting curve Db offset (additive) function, ie. for un-weighted
--   Db readings.
--   
--   <pre>
--   plotTable1 (map b_weighting [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map b_weighting [25,50 .. 20000])]
--   </pre>
b_weighting :: Floating a => a -> a

-- | C-weighting curve multiplier function, ie. for linear magnitude value.
--   See <a>http://en.wikipedia.org/wiki/A-weighting</a>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable1 (map c_weighting_R [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map c_weighting_R [25,50 .. 20000])]
--   </pre>
c_weighting_R :: Floating a => a -> a

-- | C-weighting curve Db offset (additive) function, ie. for un-weighted
--   Db readings.
--   
--   <pre>
--   plotTable1 (map c_weighting [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map c_weighting [25,50 .. 20000])]
--   </pre>
c_weighting :: Floating a => a -> a

-- | <i>h</i> function for D weighting.
d_h_function :: Fractional a => a -> a

-- | D-weighting curve multiplier function, ie. for linear magnitude value.
--   See <a>http://en.wikipedia.org/wiki/A-weighting</a>
--   
--   <pre>
--   import Sound.SC3.Plot
--   plotTable1 (map d_weighting_R [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map d_weighting_R [25,50 .. 20000])]
--   </pre>
d_weighting_R :: Floating a => a -> a

-- | D-weighting curve Db offset (additive) function, ie. for un-weighted
--   Db readings.
--   
--   <pre>
--   plotTable1 (map d_weighting [20,50 .. 20000])
--   plot_p2_ln [zip (map log [1..]) (map d_weighting [25,50 .. 20000])]
--   </pre>
d_weighting :: Floating a => a -> a


-- | <a>http://paulbourke.net/</a>
module Sound.SC3.Data.Math.Bourke

-- | 2-element <i>h</i> transform.
h_transform_2 :: Num t => t -> ((t, t) -> (t, t)) -> (t, t) -> (t, t)

-- | 3-element <i>h</i> transform.
h_transform_3 :: Num t => t -> ((t, t, t) -> (t, t, t)) -> (t, t, t) -> (t, t, t)

-- | <a>http://paulbourke.net/fractals/lorenz/</a>
lorenz :: Num t => t -> t -> t -> (t, t, t) -> (t, t, t)

-- | <a>http://paulbourke.net/fractals/lorenz/</a>
--   
--   <pre>
--   import Sound.SC3.Plot 
--   </pre>
--   
--   <pre>
--   let l = iterate (lorenz_h 0.01 10 28 (8/3)) (0.1,0.0,0.0)
--   in plot_p3_ln [take 5000 l]
--   </pre>
--   
--   <pre>
--   let {l = iterate (lorenz_h 0.01 10 28 (8/3)) (0.1,0.0,0.0)
--       ;f (x,_,z) = (x,z)}
--   in plot_p2_ln [take 15000 (map f l)]
--   </pre>
lorenz_h :: Num t => t -> t -> t -> t -> (t, t, t) -> (t, t, t)

-- | <a>http://paulbourke.net/fractals/rossler/</a>
rossler :: Num t => t -> t -> t -> (t, t, t) -> (t, t, t)

-- | <a>http://paulbourke.net/fractals/rossler/</a>
--   
--   <pre>
--   plot_p3_ln [take 5000 (iterate (rossler_h 0.02 0.2 0.2 5.7) (0.1,0,0))]
--   </pre>
rossler_h :: Num t => t -> t -> t -> t -> (t, t, t) -> (t, t, t)

-- | <a>http://paulbourke.net/fractals/peterdejong/</a>
--   
--   <pre>
--   let pdj a b c d =
--     let vw x = plot_p2_pt [take 15000 x]
--     in vw (iterate (peter_de_jong a b c d) (-0.72,-0.64))
--   </pre>
--   
--   <pre>
--   pdj 1.4 (-2.3) 2.4 (-2.1)
--   pdj 2.01 (-2.53) 1.61 (-0.33)
--   pdj (-2.7) (-0.09) (-0.86) (-2.2)
--   pdj (-2.24) 0.43 (-0.65) (-2.43)
--   pdj (-2.0) (-2.0) (-1.2) 2.0
--   </pre>
peter_de_jong :: Floating t => t -> t -> t -> t -> (t, t) -> (t, t)

-- | <a>http://paulbourke.net/fractals/clifford/</a>
--   
--   <pre>
--   let clf a b c d =
--     let vw x = plot_p2_pt [take 12500 x]
--     in vw (iterate (clifford a b c d) (-0.72,-0.64))
--   </pre>
--   
--   <pre>
--   clf (-1.4) (1.6) (1.0) (0.7)
--   clf (1.1) (-1.0) (1.0) (1.5) 
--   clf (1.6) (-0.6) (-1.2) (1.6)
--   clf (1.7) (1.7) (0.6) (1.2)
--   </pre>
clifford :: Floating t => t -> t -> t -> t -> (t, t) -> (t, t)
