-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty printing designed for printing source code.
--   
@package mainland-pretty
@version 0.4.0.0


-- | This module is based on <i>A Prettier Printer</i> by Phil Wadler in
--   <i>The Fun of Programming</i>, Jeremy Gibbons and Oege de Moor (eds)
--   <a>http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf</a>
--   
--   At the time it was originally written I didn't know about Daan
--   Leijen's pretty printing module based on the same paper. I have since
--   incorporated many of his improvements. This module is geared towards
--   pretty printing source code; its main advantages over other libraries
--   are the ability to automatically track the source locations associated
--   with pretty printed values and output appropriate #line pragmas and
--   the use of <a>Text</a> for output.
module Text.PrettyPrint.Mainland

-- | The abstract type of documents.
data Doc

-- | The document <tt><a>text</a> s</tt> consists of the string <tt>s</tt>,
--   which should not contain any newlines. For a string that may include
--   newlines, use <a>string</a>.
text :: String -> Doc

-- | The document <tt>bool b</tt> is equivalent to <tt>text (show b)</tt>.
bool :: Bool -> Doc

-- | The document <tt><a>char</a> c</tt> consists the single character
--   <tt>c</tt>.
char :: Char -> Doc

-- | The document <tt><a>string</a> s</tt> consists of all the characters
--   in <tt>s</tt> but with newlines replaced by <a>line</a>.
string :: String -> Doc

-- | The document <tt>int i</tt> is equivalent to <tt>text (show i)</tt>.
int :: Int -> Doc

-- | The document <tt>integer i</tt> is equivalent to <tt>text (show
--   i)</tt>. <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>float f</tt> is equivalent to <tt>text (show f)</tt>.
float :: Float -> Doc

-- | The document <tt>double d</tt> is equivalent to <tt>text (show
--   d)</tt>.
double :: Double -> Doc

-- | The document <tt>rational r</tt> is equivalent to <tt>text (show
--   r)</tt>.
rational :: Rational -> Doc

-- | The document <tt><a>strictText</a> s</tt> consists of the <a>Text</a>
--   <tt>s</tt>, which should not contain any newlines.
strictText :: Text -> Doc

-- | The document <tt><a>lazyText</a> s</tt> consists of the <a>Text</a>
--   <tt>s</tt>, which should not contain any newlines.
lazyText :: Text -> Doc

-- | The document <tt>star</tt> consists of an asterisk, <tt>"*"</tt>.
star :: Doc

-- | The document <tt>colon</tt> consists of a colon, <tt>":"</tt>.
colon :: Doc

-- | The document <tt>comma</tt> consists of a comma, <tt>","</tt>.
comma :: Doc

-- | The document <tt>dot</tt> consists of a period, <tt>"."</tt>.
dot :: Doc

-- | The document <tt>equals</tt> consists of an equals sign, <tt>"="</tt>.
equals :: Doc

-- | The document <tt>semi</tt> consists of a semicolon, <tt>";"</tt>.
semi :: Doc

-- | The document <tt>space</tt> consists of a space, <tt>" "</tt>.
space :: Doc

-- | The document <tt><a>space</a> n</tt> consists of n spaces.
spaces :: Int -> Doc

-- | The document <tt>backquote</tt> consists of a backquote, <tt>"`"</tt>.
backquote :: Doc

-- | The document <tt>squote</tt> consists of a single quote,
--   <tt>"\'"</tt>.
squote :: Doc

-- | The document <tt>dquote</tt> consists of a double quote,
--   <tt>"\""</tt>.
dquote :: Doc

-- | The document <tt>langle</tt> consists of a less-than sign,
--   <tt>"&lt;"</tt>.
langle :: Doc

-- | The document <tt>rangle</tt> consists of a greater-than sign,
--   <tt>"&gt;"</tt>.
rangle :: Doc

-- | The document <tt>lbrace</tt> consists of a left brace, <tt>"{"</tt>.
lbrace :: Doc

-- | The document <tt>rbrace</tt> consists of a right brace, <tt>"}"</tt>.
rbrace :: Doc

-- | The document <tt>lbracket</tt> consists of a right brace,
--   <tt>"["</tt>.
lbracket :: Doc

-- | The document <tt>rbracket</tt> consists of a right brace,
--   <tt>"]"</tt>.
rbracket :: Doc

-- | The document <tt>lparen</tt> consists of a right brace, <tt>"("</tt>.
lparen :: Doc

-- | The document <tt>rparen</tt> consists of a right brace, <tt>")"</tt>.
rparen :: Doc

-- | The empty document.
empty :: Doc

-- | The document <tt><a>srcloc</a> x</tt> tags the current line with
--   <tt><a>locOf</a> x</tt>. Only shown when running <a>prettyPragma</a>
--   and friends.
srcloc :: Located a => a -> Doc

-- | The document <tt><a>line</a></tt> advances to the next line and
--   indents to the current indentation level. When undone by <a>group</a>,
--   it behaves like <a>space</a>.
line :: Doc

-- | Becomes <a>space</a> if there is room, otherwise <a>line</a>.
--   
--   <pre>
--   pretty 11 $ text "foo" &lt;+/&gt; text "bar" &lt;+/&gt; text "baz" =="foo bar baz"
--   pretty  7 $ text "foo" &lt;+/&gt; text "bar" &lt;+/&gt; text "baz" == "foo bar\nbaz"
--   pretty  6 $ text "foo" &lt;+/&gt; text "bar" &lt;+/&gt; text "baz" == "foo\nbar\nbaz"
--   </pre>
softline :: Doc

-- | Becomes <a>empty</a> if there is room, otherwise <a>line</a>.
softbreak :: Doc

-- | An infix synonym for <a>mappend</a>.
--   
--   <i>Since: 4.5.0.0</i>
(<>) :: Monoid m => m -> m -> m

-- | Provide alternative layouts of the same content. Invariant: both
--   arguments must flatten to the same document.
(<|>) :: Doc -> Doc -> Doc

-- | Concatenates two documents with a <a>space</a> in between, with
--   identity <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Concatenates two documents with a <a>line</a> in between.
(</>) :: Doc -> Doc -> Doc

-- | Concatenates two documents with a <a>softline</a> in between, with
--   identity <a>empty</a>.
(<+/>) :: Doc -> Doc -> Doc

-- | Concatenates two documents with a <a>softbreak</a> in between.
(<//>) :: Doc -> Doc -> Doc

-- | The document <tt><a>group</a> d</tt> will flatten <tt>d</tt> to
--   <i>one</i> line if there is room for it, otherwise the original
--   <tt>d</tt>.
group :: Doc -> Doc

-- | The document <tt><a>enclose</a> l r d</tt> encloses the document
--   <tt>d</tt> between the documents <tt>l</tt> and <tt>r</tt> using
--   <tt>&lt;&gt;</tt>. It obeys the law
--   
--   <pre>
--   <a>enclose</a> l r d = l &lt;&gt; d &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | The document <tt><a>squotes</a> d</tt> encloses the alinged document
--   <tt>d</tt> in '...'.
squotes :: Doc -> Doc

-- | The document <tt><a>dquotes</a> d</tt> encloses the aligned document
--   <tt>d</tt> in "...".
dquotes :: Doc -> Doc

-- | The document <tt><a>angles</a> d</tt> encloses the aligned document
--   <tt>d</tt> in &lt;...&gt;.
angles :: Doc -> Doc

-- | The document <tt><a>backquotes</a> d</tt> encloses the aligned
--   document <tt>d</tt> in `...`.
backquotes :: Doc -> Doc

-- | The document <tt><a>braces</a> d</tt> encloses the aligned document
--   <tt>d</tt> in {...}.
braces :: Doc -> Doc

-- | The document <tt><a>brackets</a> d</tt> encloses the aligned document
--   <tt>d</tt> in [...].
brackets :: Doc -> Doc

-- | The document <tt><a>parens</a> d</tt> encloses the aligned document
--   <tt>d</tt> in (...).
parens :: Doc -> Doc

-- | The document <tt><a>parensIf</a> p d</tt> encloses the document
--   <tt>d</tt> in parenthesis if <tt>p</tt> is <tt>True</tt>, and
--   otherwise yields just <tt>d</tt>.
parensIf :: Bool -> Doc -> Doc

-- | The document <tt><a>folddoc</a> f ds</tt> obeys the laws:
--   
--   <ul>
--   <li><pre><a>folddoc</a> f [] = <a>empty</a></pre></li>
--   <li><pre><a>folddoc</a> f [d1, d2, ..., dnm1, dn] = d1 <tt>f</tt> (d2
--   <tt>f</tt> ... (dnm1 <tt>f</tt> dn))</pre></li>
--   </ul>
folddoc :: (Doc -> Doc -> Doc) -> [Doc] -> Doc

-- | The document <tt><a>spread</a> ds</tt> concatenates the documents
--   <tt>ds</tt> with <a>space</a>.
spread :: [Doc] -> Doc

-- | The document <tt><a>stack</a> ds</tt> concatenates the documents
--   <tt>ds</tt> with <a>line</a>.
stack :: [Doc] -> Doc

-- | The document <tt><a>cat</a> ds</tt> concatenates the documents
--   <tt>ds</tt> with the <a>empty</a> document as long as there is room,
--   and uses <a>line</a> when there isn't.
cat :: [Doc] -> Doc

-- | The document <tt><a>sep</a> ds</tt> concatenates the documents
--   <tt>ds</tt> with the <a>space</a> document as long as there is room,
--   and uses <a>line</a> when there isn't.
sep :: [Doc] -> Doc

-- | The document <tt><a>punctuate</a> p ds</tt> obeys the law:
--   
--   <pre>
--   <a>punctuate</a> p [d1, d2, ..., dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ..., dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt><a>commasep</a> ds</tt> comma-space separates
--   <tt>ds</tt>, aligning the resulting document to the current nesting
--   level.
commasep :: [Doc] -> Doc

-- | The document <tt><a>semisep</a> ds</tt> semicolon-space separates
--   <tt>ds</tt>, aligning the resulting document to the current nesting
--   level.
semisep :: [Doc] -> Doc

-- | The document <tt><a>enclosesep</a> l r p ds</tt> separates <tt>ds</tt>
--   with the punctuation <tt>p</tt> and encloses the result using
--   <tt>l</tt> and <tt>r</tt>. When wrapped, punctuation appears at the
--   end of the line. The enclosed portion of the document is aligned one
--   column to the right of the opening document.
--   
--   <pre>
--   &gt; ws = map text (words "The quick brown fox jumps over the lazy dog")
--   &gt; test = pretty 15 (enclosesep lparen rparen comma ws)
--   </pre>
--   
--   will be layed out as:
--   
--   <pre>
--   (The, quick,
--    brown, fox,
--    jumps, over,
--    the, lazy,
--    dog)
--   </pre>
enclosesep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | The document <tt><a>tuple</a> ds</tt> separates <tt>ds</tt> with
--   commas and encloses them with parentheses.
tuple :: [Doc] -> Doc

-- | The document <tt><a>list</a> ds</tt> separates <tt>ds</tt> with commas
--   and encloses them with brackets.
list :: [Doc] -> Doc

-- | The document <tt><a>align</a> d</tt> renders <tt>d</tt> with a nesting
--   level set to the current column.
align :: Doc -> Doc

-- | The document <tt><a>hang</a> i d</tt> renders <tt>d</tt> with a
--   nesting level set to the current column plus <tt>i</tt>, <i>not
--   including</i> the first line.
hang :: Int -> Doc -> Doc

-- | The document <tt><a>indent</a> i d</tt> renders <tt>d</tt> with a
--   nesting level set to the current column plus <tt>i</tt>,
--   <i>including</i> the first line.
indent :: Int -> Doc -> Doc

-- | The document <tt><a>nest</a> i d</tt> renders the document <tt>d</tt>
--   with the current indentation level increased by <tt>i</tt>.
nest :: Int -> Doc -> Doc

-- | The document <tt><a>column</a> f</tt> is produced by calling
--   <tt>f</tt> with the current column.
column :: (Int -> Doc) -> Doc

-- | The document <tt><a>column</a> f</tt> is produced by calling
--   <tt>f</tt> with the current nesting level.
nesting :: (Int -> Doc) -> Doc

-- | The document <tt><a>width</a> d f</tt> is produced by concatenating
--   <tt>d</tt> with the result of calling <tt>f</tt> with the width of the
--   document <tt>d</tt>.
width :: Doc -> (Int -> Doc) -> Doc

-- | The document <tt><a>fill</a> i d</tt> renders document <tt>x</tt>,
--   appending <tt>space</tt>s until the width is equal to <tt>i</tt>. If
--   the width of <tt>d</tt> is already greater than <tt>i</tt>, nothing is
--   appended.
fill :: Int -> Doc -> Doc

-- | The document <tt><a>fillbreak</a> i d</tt> renders document
--   <tt>d</tt>, appending <tt><a>space</a></tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>d</tt> is already greater than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended.
fillbreak :: Int -> Doc -> Doc

-- | Equivalent of <a>fail</a>, but with a document instead of a string.
faildoc :: Monad m => Doc -> m a

-- | Equivalent of <a>error</a>, but with a document instead of a string.
errordoc :: Doc -> a

-- | A rendered document.
data RDoc

-- | The empty document
REmpty :: RDoc

-- | A single character
RChar :: {-# UNPACK #-} !Char -> RDoc -> RDoc

-- | <a>String</a> with associated length (to avoid recomputation)
RString :: {-# UNPACK #-} !Int -> String -> RDoc -> RDoc

-- | <a>Text</a>
RText :: Text -> RDoc -> RDoc

-- | <a>Text</a>
RLazyText :: Text -> RDoc -> RDoc

-- | Tag output with source location
RPos :: Pos -> RDoc -> RDoc

-- | A newline with the indentation of the subsequent line
RLine :: {-# UNPACK #-} !Int -> RDoc -> RDoc

-- | Render a document given a maximum width.
render :: Int -> Doc -> RDoc

-- | Render a document without indentation on infinitely long lines. Since
--   no 'pretty' printing is involved, this renderer is fast. The resulting
--   output contains fewer characters.
renderCompact :: Doc -> RDoc

-- | Display a rendered document.
displayS :: RDoc -> ShowS

-- | Render and display a document.
prettyS :: Int -> Doc -> ShowS

-- | Render and convert a document to a <a>String</a>.
pretty :: Int -> Doc -> String

-- | Display a rendered document with #line pragmas.
displayPragmaS :: RDoc -> ShowS

-- | Render and display a document with #line pragmas.
prettyPragmaS :: Int -> Doc -> ShowS

-- | Render and convert a document to a <a>String</a> with #line pragmas.
--   
--   <pre>
--   &gt; let loc = Loc (Pos "filename" 3 5 7) (Pos "filename" 5 7 9)
--   &gt; in  putStrLn $ prettyPragma 80 $ srcloc loc &lt;&gt; text "foo" &lt;/&gt; text "bar" &lt;/&gt; text "baz"
--   </pre>
--   
--   will be printed as
--   
--   <pre>
--   foo
--   #line 3 "filename"
--   bar
--   baz
--   </pre>
prettyPragma :: Int -> Doc -> String

-- | Display a rendered document as <a>Text</a>. Uses a builder.
displayLazyText :: RDoc -> Text

-- | Render and display a document as <a>Text</a>. Uses a builder.
prettyLazyText :: Int -> Doc -> Text

-- | Display a rendered document with #line pragmas as <a>Text</a>. Uses a
--   builder.
displayPragmaLazyText :: RDoc -> Text

-- | Render and convert a document to <a>Text</a> with #line pragmas. Uses
--   a builder.
prettyPragmaLazyText :: Int -> Doc -> Text

-- | Render a document with a width of 80 and print it to standard output.
putDoc :: Doc -> IO ()

-- | Render a document with a width of 80 and print it to standard output,
--   followed by a newline.
putDocLn :: Doc -> IO ()

-- | Render a document with a width of 80 and print it to the specified
--   handle.
hPutDoc :: Handle -> Doc -> IO ()

-- | Render a document with a width of 80 and print it to the specified
--   handle, followed by a newline.
hPutDocLn :: Handle -> Doc -> IO ()
class Pretty a where ppr = pprPrec 0 pprPrec _ = ppr pprList xs = list (map ppr xs)
ppr :: Pretty a => a -> Doc
pprPrec :: Pretty a => Int -> a -> Doc
pprList :: Pretty a => [a] -> Doc
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j, Pretty k, Pretty l, Pretty m, Pretty n, Pretty o) => Pretty (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j, Pretty k, Pretty l, Pretty m, Pretty n) => Pretty (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j, Pretty k, Pretty l, Pretty m) => Pretty (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j, Pretty k, Pretty l) => Pretty (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j, Pretty k) => Pretty (a, b, c, d, e, f, g, h, i, j, k)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i, Pretty j) => Pretty (a, b, c, d, e, f, g, h, i, j)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h, Pretty i) => Pretty (a, b, c, d, e, f, g, h, i)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g, Pretty h) => Pretty (a, b, c, d, e, f, g, h)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f, Pretty g) => Pretty (a, b, c, d, e, f, g)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e, Pretty f) => Pretty (a, b, c, d, e, f)
instance (Pretty a, Pretty b, Pretty c, Pretty d, Pretty e) => Pretty (a, b, c, d, e)
instance (Pretty a, Pretty b, Pretty c, Pretty d) => Pretty (a, b, c, d)
instance (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance (Pretty a, Pretty b) => Pretty (a, b)
instance Pretty ()
instance Pretty a => Pretty (Set a)
instance (Pretty k, Pretty v) => Pretty (Map k v)
instance Pretty x => Pretty (L x)
instance Pretty Loc
instance Pretty Pos
instance Pretty Text
instance Pretty Text
instance Pretty Int64
instance Pretty Int32
instance Pretty Int16
instance Pretty Int8
instance Pretty Word64
instance Pretty Word32
instance Pretty Word16
instance Pretty Word8
instance (Integral a, Pretty a) => Pretty (Ratio a)
instance Pretty Double
instance Pretty Float
instance Pretty Integer
instance Pretty Int
instance Pretty Char
instance Pretty Bool
instance Pretty a => Pretty (Maybe a)
instance Pretty a => Pretty [a]
instance IsString Doc
instance Monoid Doc
