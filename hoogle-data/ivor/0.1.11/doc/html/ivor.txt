-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Theorem proving library based on dependent type theory
--   
--   Ivor is a type theory based theorem prover, with a Haskell API,
--   designed for easy extending and embedding of theorem proving
--   technology in Haskell applications. It provides an implementation of
--   the type theory and tactics for building terms, more or less along the
--   lines of systems such as Coq or Agda, and taking much of its
--   inspiration from Conor McBride's presentation of OLEG.
--   
--   The API provides a collection of primitive tactics and combinators for
--   building new tactics. It is therefore possible to build new tactics to
--   suit specific applications. Ivor features a dependent type theory
--   similar to Luo's ECC with definitions (and similar to that implemented
--   in Epigram), with dependent pattern matching, and experimental
--   multi-stage programming support. Optionally, it can be extended with
--   heterogeneous equality, primitive types and operations, new parser
--   rules, user defined tactics and (if you want your proofs to be
--   untrustworthy) a fixpoint combinator.
@package ivor
@version 0.1.11


-- | Exported view of terms and inductive data structures; imported
--   implicitly by <a>Ivor.TT</a>.
module Ivor.ViewTerm
data Name
name :: String -> Name
displayName :: Name -> String

-- | Categories for names; typechecked terms will know what each variable
--   is for.
data NameType
Bound :: NameType
Free :: NameType
DataCon :: NameType
TypeCon :: NameType
ElimOp :: NameType

-- | Use for sending to typechecker.
Unknown :: NameType

-- | Construct a term representing a variable
mkVar :: String -> ViewTerm

-- | Abstract type representing a TT term and its type.
newtype Term
Term :: (Indexed Name, Indexed Name) -> Term
data ViewTerm
Name :: NameType -> Name -> ViewTerm
nametype :: ViewTerm -> NameType
var :: ViewTerm -> Name
App :: ViewTerm -> ViewTerm -> ViewTerm
fun :: ViewTerm -> ViewTerm
arg :: ViewTerm -> ViewTerm
Lambda :: Name -> ViewTerm -> ViewTerm -> ViewTerm
var :: ViewTerm -> Name
vartype :: ViewTerm -> ViewTerm
scope :: ViewTerm -> ViewTerm
Forall :: Name -> ViewTerm -> ViewTerm -> ViewTerm
var :: ViewTerm -> Name
vartype :: ViewTerm -> ViewTerm
scope :: ViewTerm -> ViewTerm
Let :: Name -> ViewTerm -> ViewTerm -> ViewTerm -> ViewTerm
var :: ViewTerm -> Name
vartype :: ViewTerm -> ViewTerm
varval :: ViewTerm -> ViewTerm
scope :: ViewTerm -> ViewTerm
Label :: Name -> [ViewTerm] -> ViewTerm -> ViewTerm
fname :: ViewTerm -> Name
fargs :: ViewTerm -> [ViewTerm]
labeltype :: ViewTerm -> ViewTerm
Call :: Name -> [ViewTerm] -> ViewTerm -> ViewTerm
fname :: ViewTerm -> Name
fargs :: ViewTerm -> [ViewTerm]
callterm :: ViewTerm -> ViewTerm
Return :: ViewTerm -> ViewTerm
returnterm :: ViewTerm -> ViewTerm
Constant :: c -> ViewTerm
Star :: ViewTerm

-- | Staging annotation
Quote :: ViewTerm -> ViewTerm
quotedterm :: ViewTerm -> ViewTerm

-- | Staging annotation
Code :: ViewTerm -> ViewTerm
codetype :: ViewTerm -> ViewTerm

-- | Staging annotation
Eval :: ViewTerm -> ViewTerm
evalterm :: ViewTerm -> ViewTerm

-- | Staging annotation
Escape :: ViewTerm -> ViewTerm
escapedterm :: ViewTerm -> ViewTerm
Placeholder :: ViewTerm

-- | additional annotations
Annotation :: Annot -> ViewTerm -> ViewTerm
annotation :: ViewTerm -> Annot
term :: ViewTerm -> ViewTerm
Metavar :: Name -> ViewTerm
var :: ViewTerm -> Name
data Annot

-- | source file, line number
FileLoc :: FilePath -> Int -> Annot

-- | Make an application of a function to several arguments
apply :: ViewTerm -> [ViewTerm] -> ViewTerm

-- | Get a pattern matchable representation of a term.
view :: Term -> ViewTerm

-- | Get a pattern matchable representation of a term's type.
viewType :: Term -> ViewTerm

-- | Haskell types which can be used as constants
class (Typeable c, Show c, Eq c) => ViewConst c
typeof :: (ViewConst c) => c -> Name

-- | Return whether the name occurs free in the term.
freeIn :: Name -> ViewTerm -> Bool

-- | Return the names occurring free in a term
namesIn :: ViewTerm -> [Name]

-- | Return whether a subterm occurs in a (first order) term.
occursIn :: ViewTerm -> ViewTerm -> Bool

-- | Substitute a name n with a value v in a term f
subst :: Name -> ViewTerm -> ViewTerm -> ViewTerm

-- | Get the function from an application. If no application, returns the
--   entire term.
getApp :: ViewTerm -> ViewTerm

-- | Get the arguments from a function application.
getFnArgs :: ViewTerm -> [ViewTerm]

-- | Transform a term according to a rewrite rule.
transform :: ViewTerm -> ViewTerm -> ViewTerm -> ViewTerm

-- | Get the argument names and types from a function type
getArgTypes :: ViewTerm -> [(Name, ViewTerm)]

-- | Get the return type from a function type
getReturnType :: ViewTerm -> ViewTerm
dbgshow :: Name -> [Char]
data Inductive
Inductive :: Name -> [(Name, ViewTerm)] -> [(Name, ViewTerm)] -> ViewTerm -> [(Name, ViewTerm)] -> Inductive
typecon :: Inductive -> Name
parameters :: Inductive -> [(Name, ViewTerm)]
indices :: Inductive -> [(Name, ViewTerm)]
contype :: Inductive -> ViewTerm
constructors :: Inductive -> [(Name, ViewTerm)]
instance [overlap ok] Show NameType
instance [overlap ok] Enum NameType
instance [overlap ok] Binary Annot
instance [overlap ok] Binary NameType
instance [overlap ok] Binary Name
instance [overlap ok] Show Inductive
instance [overlap ok] Forget Inductive String
instance [overlap ok] Show ViewTerm
instance [overlap ok] Forget ViewTerm Raw
instance [overlap ok] (ViewConst c) => Constant c
instance [overlap ok] Eq ViewTerm
instance [overlap ok] Show Term


-- | Extensible Parsec based parsing library for <a>ViewTerm</a>s.
--   
--   Briefly, the syntax is as follows:
--   
--   <ul>
--   <li><tt>[x:A]y</tt> -- Lambda binding with scope <tt>y</tt>.</li>
--   <li><tt>(x:A) -&gt; B</tt> -- Forall binding with scope <tt>B</tt>
--   (<tt>-&gt;</tt> optional).</li>
--   <li><tt>A -&gt; B</tt> -- Forall binding where name bound is not used
--   in <tt>B</tt>..</li>
--   <li><tt>let x:A=v in y</tt> -- Let binding, <tt>x=v</tt> in scope
--   <tt>y</tt>.</li>
--   <li><tt>f a</tt> -- Function application (left associative, by
--   juxtaposition).</li>
--   <li><tt>[identifier]</tt> -- names are legal Haskell identifiers.</li>
--   <li><tt>*</tt> -- Asterisk is type of types.</li>
--   <li><tt>_</tt> -- Underscore is a placeholder.</li>
--   <li><tt>?identifier</tt> -- metavariable, add a name to be defined
--   later</li>
--   </ul>
--   
--   Lambda/forall bindings of multiple variables are also accepted, in the
--   form <tt>[x,y:A;z:B]</tt>
--   
--   Staging annotations have the following syntax:
--   
--   <ul>
--   <li><tt>{'x}</tt> -- quoted term <tt>x</tt></li>
--   <li><tt>{{A}}</tt> -- code type <tt>A</tt> (if <tt>x:A</tt>,
--   <tt>{'x}:{{A}}</tt></li>
--   <li><tt>!x</tt> -- evaluate a quoted term</li>
--   <li><tt>~x</tt> -- escape a quoted term (i.e. splice into a quoted
--   term)</li>
--   </ul>
--   
--   Extensions for labelled types (see McBride/McKinna "The View From The
--   Left" for details):
--   
--   <ul>
--   <li><tt>&lt;[identifier] args : t&gt;</tt> -- Labelled type.</li>
--   <li><tt>call &lt;label&gt; term</tt> -- Call a computation.</li>
--   <li><tt>return t</tt> -- Return a value from a computation.</li>
--   </ul>
module Ivor.TermParser

-- | Basic parsec combinator for parsing terms.
pTerm :: Maybe (Parser ViewTerm) -> Parser ViewTerm

-- | Parse a term which is not an application; use for parsing lists of
--   terms.
pNoApp :: Maybe (Parser ViewTerm) -> Parser ViewTerm

-- | Basic parsec combinator for parsing inductive data types
pInductive :: Maybe (Parser ViewTerm) -> Parser Inductive

-- | Parse a string into a ViewTerm, without mucking about with parsec or
--   any extra parse rules.
parseTermString :: (Monad m) => String -> m ViewTerm

-- | Parse a string into an Inductive, without mucking about with parsec or
--   any extra parse rules.
parseDataString :: (Monad m) => String -> m Inductive


-- | Public interface for theorem proving gadgets.
module Ivor.TT

-- | Initialise a context, with no data or definitions and an empty proof
--   state.
emptyContext :: Context

-- | Abstract type representing state of the system.
data Context

-- | Quickly convert a <a>ViewTerm</a> into a real <a>Term</a>. This is
--   dangerous; you must know that typechecking will succeed, and the
--   resulting term won't have a valid type, but you will be able to run
--   it. This is useful if you simply want to do a substitution into a
--   <a>ViewTerm</a>.
fastCheck :: Context -> ViewTerm -> Term

-- | Check a term in the context of the given goal
checkCtxt :: (IsTerm a) => Context -> Goal -> a -> TTM Term

-- | Check whether the conversion relation holds between two terms, in the
--   context of the given goal
converts :: (IsTerm a, IsTerm b) => Context -> Goal -> a -> b -> TTM Bool

-- | Create a .hs file containing (unreadable) Haskell code implementing
--   all of the definitions. (TODO: Generate a more readable, usable
--   interface)
compile :: Context -> String -> IO ()
class IsTerm a
check :: (IsTerm a) => Context -> a -> TTM Term
class IsData a
addData :: (IsData a) => Context -> a -> TTM Context
addDataNoElim :: (IsData a) => Context -> a -> TTM Context
data TTError
CantUnify :: ViewTerm -> ViewTerm -> TTError
NotConvertible :: ViewTerm -> ViewTerm -> TTError
Message :: String -> TTError
Unbound :: ViewTerm -> ViewTerm -> ViewTerm -> ViewTerm -> [Name] -> TTError
NoSuchVar :: Name -> TTError
CantInfer :: Name -> ViewTerm -> TTError
ErrContext :: String -> TTError -> TTError
ttfail :: String -> TTM a
getError :: IError -> TTError
type TTM = Either TTError

-- | Add a new definition to the global state.
addDef :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Add a new definition, with its type to the global state. These
--   definitions can be recursive, so use with care.
addTypedDef :: (IsTerm term, IsTerm ty) => Context -> Name -> term -> ty -> TTM Context

-- | Add a new axiom to the global state.
addAxiom :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Declare a name which is to be defined later
declare :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Declare a type constructor which is to be defined later
declareData :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Begin a new proof.
theorem :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Begin a new interactive definition. Actually, just the same as
--   <a>theorem</a> but this version allows you to make recursive calls,
--   which should of course be done with care.
interactive :: (IsTerm a) => Context -> Name -> a -> TTM Context

-- | Add a new primitive type. This should be done in assocation with
--   creating an instance of <a>ViewConst</a> for the type, and creating
--   appropriate primitive functions.
addPrimitive :: Context -> Name -> TTM Context

-- | Add a new binary operator on constants. Warning: The type you give is
--   not checked!
addBinOp :: (ViewConst a, ViewConst b, ViewConst c, IsTerm ty) => Context -> Name -> (a -> b -> c) -> ty -> TTM Context

-- | Add a new binary function on constants. Warning: The type you give is
--   not checked!
addBinFn :: (ViewConst a, ViewConst b, IsTerm ty) => Context -> Name -> (a -> b -> ViewTerm) -> ty -> TTM Context

-- | Add a new primitive function on constants, usually used for converting
--   to some form which can be examined in the type theory itself. Warning:
--   The type you give is not checked!
addPrimFn :: (ViewConst a, IsTerm ty) => Context -> Name -> (a -> ViewTerm) -> ty -> TTM Context

-- | Add a new externally defined function. Warning: The type you give is
--   not checked!
addExternalFn :: (IsTerm ty) => Context -> Name -> Int -> ([ViewTerm] -> Maybe ViewTerm) -> ty -> TTM Context

-- | Add the heterogenous ("John Major") equality rule and its reduction
addEquality :: Context -> Name -> Name -> TTM Context

-- | Forget a definition and all following definitions.
forgetDef :: Context -> Name -> TTM Context

-- | Add the general recursion elimination rule, thus making all further
--   definitions untrustworthy :).
addGenRec :: Context -> Name -> TTM Context

-- | Add implicit binders for names used in a type, but not declared.
--   |Returns the new type and the number of implicit names bound.
addImplicit :: Context -> ViewTerm -> (Int, ViewTerm)
data PClause
PClause :: [ViewTerm] -> [(Name, ViewTerm)] -> ViewTerm -> PClause
arguments :: PClause -> [ViewTerm]
boundnames :: PClause -> [(Name, ViewTerm)]
returnval :: PClause -> ViewTerm
PWithClause :: Bool -> [ViewTerm] -> ViewTerm -> Patterns -> PClause
eqproof :: PClause -> Bool
arguments :: PClause -> [ViewTerm]
scrutinee :: PClause -> ViewTerm
patterns :: PClause -> Patterns
data Patterns
Patterns :: [PClause] -> Patterns
data PattOpt

-- | No need to cover all cases
Partial :: PattOpt

-- | No termination checking
GenRec :: PattOpt

-- | Allow metavariables in the definition, which will become theorems
--   which need to be proved.
Holey :: PattOpt

-- | Add a new definition to the global state. By default, these
--   definitions must cover all cases and be well-founded, but can be
--   optionally partial or general recursive. Returns the new context, and
--   a list of names which need to be defined to complete the definition.
addPatternDef :: (IsTerm ty) => Context -> Name -> ty -> Patterns -> [PattOpt] -> TTM (Context, [(Name, ViewTerm)])
toPattern :: Context -> ViewTerm -> ViewTerm

-- | Return whether we are in the middle of proving something.
proving :: Context -> Bool

-- | Get the number of unsolved goals
numUnsolved :: Context -> Int

-- | Suspend the current proof. Clears the current proof state; use
--   <a>resume</a> to continue the proof.
suspend :: Context -> Context

-- | Resume an unfinished proof, suspending the current one if necessary.
--   Fails if there is no such name. Can also be used to begin a proof of
--   an identifier previously claimed as an axiom. Remember that you will
--   need to <a>attack</a> the goal if you are resuming an axiom.
resume :: Context -> Name -> TTM Context

-- | Save the state (e.g. for Undo)
save :: Context -> Context

-- | Restore a saved state; fails if none have been saved.
restore :: Context -> TTM Context

-- | Clears the saved state (e.g. if undo no longer makes sense, like when
--   a proof has been completed)
clearSaved :: Context -> Context

-- | Get the current proof term, if we are in the middle of a proof.
proofterm :: Context -> TTM Term

-- | Get the goals still to be solved.
getGoals :: Context -> [Goal]

-- | Get the type and context of the given goal, if it exists
getGoal :: Context -> Goal -> TTM ([(Name, Term)], Term)

-- | Create a name unique in the proof state
uniqueName :: Context -> Name -> TTM Name

-- | Return whether all goals have been solved.
allSolved :: Context -> Bool

-- | Lift a finished proof into the context
qed :: Context -> TTM Context

-- | Normalise a term and its type (using old evaluator_
eval :: Context -> Term -> Term

-- | Reduce a term and its type to Weak Head Normal Form
whnf :: Context -> Term -> Term

-- | Reduce a term and its type to Normal Form (using new evaluator)
evalnew :: Context -> Term -> Term

-- | Reduce a term and its type to Normal Form (using new evaluator, not
--   reducing given names)
evalnewWithout :: Context -> Term -> [Name] -> Term

-- | Reduce a term and its type to Normal Form (using new evaluator,
--   reducing given names a maximum number of times)
evalnewLimit :: Context -> Term -> [(Name, Int)] -> Term

-- | Evaluate a term in the context of the given goal
evalCtxt :: (IsTerm a) => Context -> Goal -> a -> TTM Term

-- | Lookup a definition in the context.
getDef :: Context -> Name -> TTM Term

-- | Check whether a name is defined
defined :: Context -> Name -> Bool

-- | Lookup a pattern matching definition in the context. Return the type
--   and the pattern definition.
getPatternDef :: Context -> Name -> TTM (ViewTerm, Patterns)

-- | Get all the names and types in the context
getAllTypes :: Context -> [(Name, Term)]
getAllDefs :: Context -> [(Name, Term)]

-- | Get all the pattern matching definitions in the context. Also returns
--   CAFs (i.e. 0 argument functions)
getAllPatternDefs :: Context -> [(Name, (ViewTerm, Patterns))]

-- | Is the name an auxiliary function of a pattern definition (e.g.
--   generated by a with clause?
isAuxPattern :: Context -> Name -> Bool

-- | Get the names of all of the constructors of an inductive family
getConstructors :: Context -> Name -> TTM [Name]

-- | Return the data type with the given name. Note that this knows nothing
--   about the difference between parameters and indices; that information
--   is discarded after the elimination rule is constructed.
getInductive :: Context -> Name -> TTM Inductive

-- | Get all the inductive type definitions in the context.
getAllInductives :: Context -> [(Name, Inductive)]

-- | Get the type of a definition in the context.
getType :: Context -> Name -> TTM Term

-- | Types of elimination rule
data Rule
Case :: Rule
Elim :: Rule

-- | Get the pattern matching elimination rule for a type
getElimRule :: Context -> Name -> Rule -> TTM Patterns

-- | Find out what type of variable the given name is
nameType :: Context -> Name -> TTM NameType

-- | Get an integer tag for a constructor. Each constructor has a tag
--   unique within the data type, which could be used by a compiler.
getConstructorTag :: Context -> Name -> TTM Int

-- | Get the arity of the given constructor.
getConstructorArity :: Context -> Name -> TTM Int

-- | Freeze a name (i.e., set it so that it does not reduce) Fails if the
--   name does not exist.
freeze :: Context -> Name -> TTM Context

-- | Unfreeze a name (i.e., allow it to reduce). Fails if the name does not
--   exist.
thaw :: Context -> Name -> TTM Context

-- | Abstract type representing goal or subgoal names.
data Goal
goal :: String -> Goal
defaultGoal :: Goal

-- | A tactic is any function which manipulates a term at the given goal
--   binding. Tactics may fail, hence the monad.
type Tactic = Goal -> Context -> TTM Context

-- | Environment and goal type for a given subgoal
data GoalData

-- | Get the premises of the goal
bindings :: GoalData -> [(Name, Term)]

-- | Get the name of the goal
goalName :: GoalData -> Goal

-- | Get the type of the goal
goalType :: GoalData -> Term

-- | Get information about a subgoal.
goalData :: Context -> Bool -> Goal -> TTM GoalData

-- | Get the names and types of all goals
subGoals :: Context -> TTM [(Name, Term)]

-- | Introduce an assumption (i.e. a lambda binding)
intro :: Tactic

-- | Introduce an assumption (i.e. a lambda binding)
introName :: Name -> Tactic

-- | Keep introducing things until there's nothing left to introduce.
intros :: Tactic

-- | Keep introducing things until there's nothing left to introduce, Must
--   introduce at least one thing.
intros1 :: Tactic

-- | As <a>intros</a>, but with names, and stop when we've run out of
--   names. Fails if too many names are given.
introsNames :: [Name] -> Tactic

-- | Add a new top level argument after the arguments its type depends on
--   (changing the type of the theorem). This can be useful if, for
--   example, you find you need an extra premise to prove a goal.
addArg :: (IsTerm a) => Name -> a -> Tactic

-- | Abstract over the given term in the goal.
generalise :: (IsTerm a) => a -> Tactic

-- | Abstract over the given term in the goal, and also all variables
--   appearing in the goal whose types depend on it.
dependentGeneralise :: (IsTerm a) => a -> Tactic

-- | Make a local claim
claim :: (IsTerm a) => Name -> a -> Tactic

-- | Focus on a different hole, i.e. set the default goal.
focus :: Tactic

-- | Rename the outermost binder in the given goal
rename :: Name -> Tactic

-- | Prepare a goal for introduction.
attack :: Tactic

-- | Prepare a goal for introduction.
attackWith :: Name -> Tactic

-- | Finalise a goal's solution.
solve :: Tactic

-- | If the goal has a solution, finalise it, otherwise prepare the goal
--   (with attack). Typically, could be used on the subgoals generated by
--   refinement, where some may have solutions attached already, and others
--   will need to be prepared.
trySolve :: Tactic

-- | Finalise as many solutions of as many goals as possible.
keepSolving :: Tactic

-- | Remove a solution from a goal.
abandon :: Tactic

-- | Hide a premise
hide :: Tactic

-- | Attach a solution to a goal.
fill :: (IsTerm a) => a -> Tactic

-- | Solve a goal by applying a function. If the term given has arguments,
--   attempts to fill in these arguments by unification and solves them
--   (with <a>solve</a>). See <a>refineWith</a> and <a>basicRefine</a> for
--   slight variations.
refine :: (IsTerm a) => a -> Tactic

-- | Solve a goal by applying a function. If the term given has arguments,
--   this will create a subgoal for each. Some arguments may be solved by
--   unification, in which case they will already have a guess attached
--   after refinement, but the guess will not be solved (via <a>solve</a>).
basicRefine :: (IsTerm a) => a -> Tactic

-- | Solve a goal by applying a function with some arguments filled in. See
--   <a>refine</a> for details.
refineWith :: (IsTerm a) => a -> [a] -> Tactic

-- | Find a trivial solution to the goal by searching through the context
--   for a premise which solves it immediately by refinement
trivial :: Tactic

-- | Add an axiom to the global context which would solve the goal, and
--   apply it. FIXME: This tactic doesn't pick up all dependencies on
--   types, but is okay for simply typed axioms, e.g. equations on Nats.
axiomatise :: Name -> [Name] -> Tactic

-- | Apply an eliminator.
by :: (IsTerm a) => a -> Tactic

-- | Apply the appropriate induction rule to the term.
induction :: (IsTerm a) => a -> Tactic

-- | Apply the appropriate case analysis rule to the term. Like
--   <a>induction</a>, but no induction hypotheses generated.
cases :: (IsTerm a) => a -> Tactic

-- | Check that the goal is definitionally equal to the given term, and
--   rewrite the goal accordingly.
equiv :: (IsTerm a) => a -> Tactic

-- | Normalise the goal
compute :: Tactic

-- | Beta reduce in the goal
beta :: Tactic

-- | Beta reduce the goal, unfolding the given function
unfold :: Name -> Tactic

-- | Replace a term in the goal according to an equality premise. Any
--   equality type with three arguments is acceptable (i.e. the type, and
--   the two values), provided there are suitable replacement and symmetry
--   lemmas. Heterogeneous equality as provided by <a>addEquality</a> is
--   acceptable (if you provide the lemmas!).
replace :: (IsTerm a, IsTerm b, IsTerm c, IsTerm d) => a -> b -> c -> d -> Bool -> Tactic

-- | Make a recursive call of a computation. The term must be an allowed
--   recursive call, identified in the context by having a labelled type.
call :: (IsTerm a) => a -> Tactic

-- | Prepare to return a value in a computation
returnComputation :: Tactic

-- | Prepare to return a quoted value
quoteVal :: Tactic

-- | The Identity tactic, does nothing.
idTac :: Tactic

-- | Apply a sequence of tactics to the default goal. Read the type as
--   [<a>Tactic</a>] -&gt; <a>Tactic</a>
tacs :: [Goal -> Context -> TTM Context] -> Goal -> Context -> TTM Context

-- | Sequence two tactics; applies two tactics sequentially to the same
--   goal
(>->) :: Tactic -> Tactic -> Tactic

-- | Apply a tactic, then apply another to each subgoal generated.
(>=>) :: Tactic -> Tactic -> Tactic

-- | Apply a tactic, then apply the next tactic to the next default
--   subgoal.
(>+>) :: Tactic -> Tactic -> Tactic

-- | Tries the left tactic, if that fails try the right one. Shorthand for
--   <a>try</a> x <a>idTac</a> y.
(>|>) :: Tactic -> Tactic -> Tactic

-- | Try a tactic.
try :: Tactic -> Tactic -> Tactic -> Tactic

-- | The Tracing tactic; does nothing, but uses <a>trace</a> to dump the
--   current proof state
traceTac :: Tactic
instance [overlap ok] Show RecAllowed
instance [overlap ok] Eq PattOpt
instance [overlap ok] Show Patterns
instance [overlap ok] Show PClause
instance [overlap ok] Eq Goal
instance [overlap ok] IsData Inductive
instance [overlap ok] IsData String
instance [overlap ok] Error TTError
instance [overlap ok] Show TTError
instance [overlap ok] IsTerm Raw
instance [overlap ok] IsTerm String
instance [overlap ok] IsTerm ViewTerm
instance [overlap ok] IsTerm Term
instance [overlap ok] Show Goal


-- | Some generic tactics for solving goals by applying constructors
module Ivor.Construction

-- | Tries to solve a simple goal automatically by trying each of these in
--   turn: * Looking for an assumption (<a>trivial</a>) * <a>intros</a>
--   everything then solve by <a>auto</a> * Splitting the goal, then
--   solving each subgoal by <a>auto</a> * If the goal is of a type with
--   more than one constructor, try <a>auto</a> on each constructor in
--   turn. FIXME: not that this actually works yet.
auto :: Int -> Tactic

-- | Split a goal into subgoals. Type of goal must be a one constructor
--   family, with constructor <tt>c</tt>, then proceeds by <a>refine</a>
--   <tt>c</tt>.
split :: Tactic

-- | Split a goal into subgoals. Type of goal must be a two constructor
--   family, with constructors <tt>l</tt> and <tt>r</tt>, then proceeds by
--   <a>refine</a> <tt>l</tt>.
left :: Tactic

-- | Split a goal into subgoals. Type of goal must be a two constructor
--   family, with constructors <tt>l</tt> and <tt>r</tt>, then proceeds by
--   <a>refine</a> <tt>r</tt>.
right :: Tactic

-- | Solve the goal by applying a numbered constructor
useCon :: Int -> Int -> Tactic

-- | Solve an existential by providing a witness. More generally; apply the
--   first constructor of the goal's type and provide the witness as its
--   first non-inferrable argument.
exists :: (IsTerm a) => a -> Tactic

-- | Try to solve a goal <tt>A</tt> by evaluating a term of type <tt>Maybe
--   A</tt>. If the answer is <tt>Just a</tt>, fill in the goal with the
--   proof term <tt>a</tt>.
isItJust :: (IsTerm a) => a -> Tactic


-- | Tactics for Heterogeneous Equality (injectivity, disjointness, etc)
module Ivor.Equality


-- | Some basic primitive types. Importing this module adds instances of
--   <a>ViewConst</a> for Int, Float and String (Float is represented by
--   Haskell Double). <a>addPrimitives</a> should be used to add these type
--   constructors to the context.
module Ivor.Primitives

-- | Add primitive types for Int, Float and String, and some primitive
--   operations [add,sub,mult,div][int,float] and concat.
addPrimitives :: Context -> TTM Context

-- | Parse a primitive constant
parsePrimitives :: Parser ViewTerm

-- | Parse a term including primitives
parsePrimTerm :: String -> TTM ViewTerm
instance [overlap ok] ViewConst String
instance [overlap ok] ViewConst Double
instance [overlap ok] ViewConst Int


-- | Plugin loader
module Ivor.Plugin

-- | Load the given plugin file (which should be a full path to a .o or .hs
--   file) and update the Context. If it is a .hs file, it will be compiled
--   if necessary. Plugins must contain the symbol <tt>plugin_context ::
--   Monad m =&gt; Context -&gt; m Context</tt> which updates the context.
--   It may optionally contain symbols <tt>plugin_parser :: Parser
--   ViewTerm</tt> which adds new parsing rules, <tt>plugin_shell ::
--   ShellState -&gt; IO ShellState</tt> which updates the shell
--   <tt>plugin_commands :: IO [(String, String -&gt; COntext -&gt; IO
--   (String, Context))]</tt> which adds new user defined commands (which
--   may need to do some setting up themselves, hence the IO) Returns the
--   new context and the extra parsing rules and commands, if any.
load :: FilePath -> Context -> IO (Context, Maybe (Parser ViewTerm), Maybe (ShellState -> IO ShellState), Maybe (IO [(String, String -> Context -> IO (String, Context))]))


-- | Shell interface to theorem prover
module Ivor.Shell
data ShellState

-- | Run a command shell.
runShell :: String -> ShellState -> IO ShellState

-- | Import a file of shell commands; fails if the module does not exist in
--   the current directory or search path, does nothing if already loaded.
importFile :: FilePath -> ShellState -> IO ShellState

-- | Add a directory to the module search path
addModulePath :: ShellState -> FilePath -> ShellState

-- | Add the standard library path to the module search path
addStdlibPath :: ShellState -> ShellState

-- | Get the install prefix of the library
prefix :: FilePath

-- | Get the system state from a finished shell
getContext :: ShellState -> Context

-- | Create a new shell state.
newShell :: Context -> ShellState

-- | Update the context in a shell
updateShell :: (Context -> TTM Context) -> ShellState -> TTM ShellState

-- | Send a command directly to a shell
sendCommand :: String -> ShellState -> TTM ShellState

-- | Send a command directly to a shell, allowing commands which might do
--   IO actions.
sendCommandIO :: String -> ShellState -> IO ShellState

-- | Add a user defined tactic to the shell.
addTactic :: String -> (String -> Tactic) -> ShellState -> ShellState

-- | Add a user defined command to the shell.
addCommand :: String -> (String -> Context -> IO (String, Context)) -> ShellState -> ShellState

-- | Add another parsing rule for parsing terms.
extendParser :: ShellState -> Parser ViewTerm -> ShellState

-- | Set up the equality type, for use by the <a>replace</a> tactic
configureEq :: String -> String -> String -> ShellState -> ShellState

-- | Parse a term using the shell's current parser extensions
shellParseTerm :: ShellState -> Parser ViewTerm

-- | Get a string representation of the current proof state
showProofState :: ShellState -> String

-- | Get reply from last shell command
response :: ShellState -> String
