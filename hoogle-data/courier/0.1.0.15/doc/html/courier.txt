-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A message-passing library for simplifying network applications
--   
--   Inspired by Erlang's simple message-passing facilities, courier
--   provides roughly similar capabilities. Applications simply create one
--   or more endpoints, bind each to a transport using a given name, then
--   can freely send / receive messages to other endpoints just by
--   referencing the name each endpoint bound to its transport.
--   
--   A primary driver of this package's design is separation of concerns:
--   many algorithms (especially for distributed applications) depend upon
--   a message-passing foundation, but the algorithms are sufficiently
--   complex that the details of how those messages are transmitted among
--   nodes are best hidden away and solved separately from the distributed
--   algorithm itself. With this in mind, this package aims to provide a
--   variety of transports as well as support for common communication
--   idioms (e.g., in order message delivery, selective out of order
--   message delivery, synchronous RPC, etc.).
--   
--   Applications may process messages in the order received at an
--   endpoint, or use selective message reception to process the first
--   message arriving at an endpoint that also matches a provided selection
--   function. Through selective message reception, applications may
--   approximate the style of an Erlang application, and enjoy better
--   composability of message reception with multiple independent dispatch
--   routines or message pumps.
@package courier
@version 0.1.0.15


-- | A <a>Mailbox</a> is a drop-in replacement for <a>TQueue</a> in
--   <a>Control.Concurrent.STM</a>, except that it also supports selective
--   out of order message reception: that is, it allows the caller to
--   dequeue the first message among the messages available in the queue
--   that matches a supplied test function, or block if no such match is
--   possible with the messages currently in the queue.
--   
--   As <a>Mailbox</a> implements the same basic <tt>read <i> write </i>
--   peek</tt> group of functions as a <a>TQueue</a>, it offers a superset
--   of <a>TQueue</a> functionality by extending it with the <tt>find <i>
--   select </i> handle</tt> groups of functions. Thus, applications can
--   safely use <a>Mailbox</a>es in place of <a>TQueue</a>s, but choose
--   when to take the slight extra overhead of <a>Mailbox</a>
--   functionality.
--   
--   Because message selection in worst case requires fully traversing all
--   messages in the queue, application designers are encouraged to
--   understand this aspect when choosing to use <a>Mailbox</a>es in their
--   designs, or when using the additional features of <a>Mailbox</a>es
--   beyond that of <a>TQueue</a>s. Dispatching messages with a
--   <a>Mailbox</a> is analogous to using a <tt>case</tt> expression (O(n))
--   to dispatch messages to a handler function, except that new cases can
--   be added or removed at any time. In essence, one can regard
--   <a>Mailbox</a>es as a useful means of creating an extensible message
--   dispatch function. If, however, if O(1) message dispatching time is
--   necessary or desired, (using hashmaps, for example) then
--   <a>Mailbox</a>es are not the correct choice.
--   
--   Despite this extra cost, <a>Mailbox</a>es offer advantages to
--   designers:
--   
--   <ul>
--   <li>Implementation of Erlang-style message reception: as messages can
--   be received out of order, a mailbox is analogous to a process input
--   queue in Erlang.</li>
--   <li>Better composability: if applications must only dequeue messages
--   in the order in which they are queued (which is sufficient for many
--   applications), then the main message pump requires modification each
--   time a new class of message must be handled. With selective message
--   reception, multiple concurrent message pumps are possible (with a
--   small performance impact), each processing the messages they expect
--   and with no need to be aware of other message pumps performing their
--   own work on the same mailbox.</li>
--   <li>Mixing synchronous and asynchronous programming styles: if
--   restricted to in order message delivery, an application must carefully
--   construct all logic to avoid blocking its central message loop. By
--   supporting out of message delivery and multiple selective recipients,
--   it becomes possible to combine synchronous and asynchronous
--   programming styles using the same <a>Mailbox</a>.</li>
--   </ul>
--   
--   Basic framework for <a>Mailbox</a> brazenly copied from
--   <a>Control.Concurrent.STM.TQueue</a>.
module Control.Concurrent.Mailbox
data Mailbox m

-- | Build and returns a new instance of <a>Mailbox</a>
newMailbox :: STM (Mailbox m)

-- | <tt>IO</tt> version of <a>newMailbox</a>. This is useful for creating
--   top-level <a>Mailbox</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newMailboxIO :: IO (Mailbox m)

-- | Write a value to a <a>Mailbox</a>.
writeMailbox :: Mailbox m -> m -> STM ()

-- | Read the next value from the <a>Mailbox</a>.
readMailbox :: Mailbox m -> STM m

-- | A version of <a>readMailbox</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadMailbox :: Mailbox m -> STM (Maybe m)

-- | Get the next value from the <tt>Mailbox</tt> without removing it,
--   retrying if the channel is empty.
peekMailbox :: Mailbox m -> STM m

-- | A version of <a>peekMailbox</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekMailbox :: Mailbox m -> STM (Maybe m)

-- | Find the next message in the mailbox that matches the supplied test
--   function or block until there is a message that does. When a message
--   matches (e.g., test functions returns <tt>Just v</tt>), return it.
selectMailbox :: Mailbox m -> (m -> Maybe v) -> STM v

-- | A version of <a>selectMailbox</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
trySelectMailbox :: Mailbox m -> (m -> Maybe v) -> STM (Maybe v)

-- | Wait until there is a message in the mailbox matching the supplied
--   test function (using <a>selectMailbox</a>), then when a message is
--   found, handle it in the <a>IO</a> monad with the supplied function.
handleMailbox :: Mailbox m -> (m -> Maybe v) -> (v -> IO r) -> IO r

-- | Find the next value from the <tt>Mailbox</tt> matching <tt>testFn</tt>
--   without removing it, retrying if the channel is empty.
findMailbox :: Mailbox m -> (m -> Maybe v) -> STM v

-- | A version of <a>findMailbox</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryFindMailbox :: Mailbox m -> (m -> Maybe v) -> STM (Maybe v)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetMailbox :: Mailbox m -> m -> STM ()

-- | Returns <a>True</a> if the supplied <a>Mailbox</a> is empty.
isEmptyMailbox :: Mailbox m -> STM Bool
instance Eq (Mailbox m)


-- | A <a>Transport</a> abstracts the details of message delivery, and
--   defines the interfaces that specific <a>Transport</a> implementations
--   should provide in order to deliver messages for <tt>Endpoint</tt>s.
--   
--   The definition of a transport is deliberately low-level in nature.
--   Unless a specific transport describes itself as supporting features
--   like guaranteed delivery, applications should NOT assume that message
--   delivery is reliable.
--   
--   For example, if a sender sends a message to a name that has not yet
--   been bound, then immediately waits on the response for that message,
--   then the application may hang, as the original message may have been
--   dropped.
--   
--   However, many application may find it easier to push features such as
--   reliable message delivery into a custom transport, leaving the
--   application only having to concern itself with the messages being
--   delivered rather than how they arrive.
module Network.Transport

-- | A <a>Mailbox</a> is a place where transports can put messages for
--   <a>Endpoint</a>s to receive. Typically <a>Endpoint</a>s will use the
--   same <a>Mailbox</a> when binding or connecting with a
--   <a>Transport</a>.
--   
--   An address is a logical identifier suitable for establishing a
--   connection to another <tt>Endpoint</tt> over a <a>Transport</a>. It's
--   use (if at all) is specific to the <a>Transport</a> in question.
type Address = String

-- | Bindings are a site for receiving messages on a particular
--   <a>Address</a> through a <a>Transport</a>.
data Binding
Binding :: Name -> IO () -> Binding
bindingName :: Binding -> Name
unbind :: Binding -> IO ()

-- | An <a>Envelope</a> is a container for a <a>Message</a> with the
--   <a>Address</a> of the <tt>Message'</tt>s destination.
data Envelope
Envelope :: Name -> Message -> Envelope
envelopeDestination :: Envelope -> Name
envelopeContents :: Envelope -> Message

-- | Messages are containers for arbitrary data that may be sent to other
--   <a>Endpoint</a>s.
type Message = ByteString

-- | Name for uniquely identifying an <tt>Endpoint</tt>; suitable for
--   identifying the target destination for a <a>Message</a>.
type Name = String

-- | A <a>Resolver</a> translates a name into an <a>Address</a>, if
--   possible. <a>Transport</a>s may find resolvers useful for determing
--   where to reach a specific <tt>Endpoint</tt>, given it''s <a>Name</a>.
data Resolver

-- | Ask the <a>Resolver</a> to find one or more <a>Address</a>es for the
--   provided <a>Name</a>, if any are available from this resolver.
resolve :: Resolver -> Name -> IO (Maybe Address)

-- | A simple <a>Resolver</a> that accepts an association list of
--   <a>Name</a>s to <a>Address</a>es and returns the addresses associated
--   with a given name in the list.
resolverFromList :: [(Name, Address)] -> Resolver

-- | A scheme is an identifier for a discrete type of transport.
type Scheme = String

-- | A <a>Transport</a> defines a specific method for establishing
--   connections between <tt>Endpoint</tt>s.
data Transport
Transport :: String -> (Name -> IO Bool) -> (Mailbox Message -> Name -> IO (Either String Binding)) -> (Name -> Message -> IO ()) -> IO () -> Transport
scheme :: Transport -> String
handles :: Transport -> Name -> IO Bool
bind :: Transport -> Mailbox Message -> Name -> IO (Either String Binding)
sendTo :: Transport -> Name -> Message -> IO ()
shutdown :: Transport -> IO ()
instance Eq Envelope
instance Show Envelope
instance Generic Envelope
instance Datatype D1Envelope
instance Constructor C1_0Envelope
instance Selector S1_0_0Envelope
instance Selector S1_0_1Envelope
instance Serialize Envelope


-- | Memory transports deliver messages to other <a>Endpoint</a>s within
--   the same shared address space, or operating system process.
module Network.Transport.Memory

-- | Create a new memory <a>Transport</a> for use by <a>Endpoint</a>s.
newMemoryTransport :: IO Transport


-- | TCP transports deliver messages to other <a>Endpoint</a>s using
--   TCP/IP.
--   
--   Each TCP transport manages both socket bindings and connections on
--   behalf of <tt>Endpoint</tt>s, dynamically opening / closing new
--   sockets as needed to deliver messages to other <tt>Endpoint</tt>s
--   using TCP transports.
module Network.Transport.TCP

-- | Create a new <a>Transport</a> suitable for sending messages over
--   TCP/IP (IPv4). There can be multiple instances of these
--   <a>Transport</a>s: <a>Endpoint</a> using different instances will
--   still be able to communicate, provided they use correct TCP/IP
--   addresses (or hostnames) for communication.
newTCPTransport :: Resolver -> IO Transport

-- | Create a new <a>Transport</a> suitable for sending messages over
--   TCP/IP (IPv4). There can be multiple instances of these
--   <a>Transport</a>s: <a>Endpoint</a> using different instances will
--   still be able to communicate, provided they use correct TCP/IP
--   addresses (or hostnames) for communication.
newTCPTransport6 :: Resolver -> IO Transport
lookupAddresses :: Family -> SocketType -> Address -> IO [SockAddr]
lookupTCPAddress :: Address -> Family -> IO SockAddr
lookupWildcardTCPAddress :: Address -> Family -> IO SockAddr


-- | UDP transports deliver messages to other <a>Endpoint</a>s using
--   UDP/IP.
--   
--   Each UDP transport manages socket bindings on behalf of
--   <tt>Endpoint</tt>s, dynamically opening / closing new sockets as
--   needed to deliver messages to other <tt>Endpoint</tt>s using UDP
--   transports.
--   
--   There is no reuse of sockets on the sending side, so while messages
--   will be received on a known bound port, the remote sending port will
--   vary arbitrarily.
--   
--   This transport only reads at most 512 bytes from incoming packets:
--   constraining the packet size avoids fragmentation. Applications using
--   this transport should take responsibility for fragmentation,
--   reassembly, retransmission of lost packets, and congestion control.
module Network.Transport.UDP
newUDPTransport :: Resolver -> IO Transport
newUDPTransport6 :: Resolver -> IO Transport
lookupAddresses :: Family -> SocketType -> Address -> IO [SockAddr]
lookupUDPAddress :: Address -> Family -> IO SockAddr
lookupWildcardUDPAddress :: Address -> Family -> IO SockAddr


-- | <a>Endpoint</a>s are a generalized abstraction for communication
--   between parts of a program, whether on the same physical host or
--   distributed over a network. <a>Endpoint</a>s are intended to simplify
--   the development of network-centric applications by providing a small
--   transport-independent message-passing interface, and application
--   writers can independently alter their implementation by enabling their
--   <a>Endpoint</a>s with different <a>Transport</a>s without modifying
--   the logic of their application that sends / receives <a>Message</a>s.
module Network.Endpoints

-- | Endpoints are a locus of communication, used for sending and receive
--   messages.
data Endpoint

-- | Create a new <a>Endpoint</a> using the provided transports.
newEndpoint :: [Transport] -> IO Endpoint

-- | Binding an <a>Endpoint</a> to a <a>Name</a> prepares the
--   <a>Endpoint</a> to receive messages sent to the bound name. Upon
--   success, the result will be <tt>Right ()</tt>, but if failed, <tt>Left
--   text-of-error-message</tt>.
bindEndpoint :: Endpoint -> Name -> IO (Either String ())

-- | Invoke <a>bindEndpoint</a>, but ignore any returned result (success or
--   failure).
bindEndpoint_ :: Endpoint -> Name -> IO ()

-- | Unbind an <a>Endpoint</a> from a <a>Name</a>, after which the
--   <a>Endpoint</a> will eventually not receive messages sent to that
--   <a>Name</a>. Note that there is no guarantee that after
--   <tt>Unbind</tt> succeeds that additional messages to that <a>Name</a>
--   will not be delivered: the only guarantee is that eventually messages
--   will no longer be delivered. Upon success, the result will be
--   <tt>Right ()</tt> but if failed, <tt>Left text-of-error-message</tt>.
unbindEndpoint :: Endpoint -> Name -> IO (Either String ())

-- | Invoke <a>unbindEndpoint</a>, but ignore any returned result (success
--   or failure).
unbindEndpoint_ :: Endpoint -> Name -> IO ()

-- | Send a <a>Message</a> to specific <a>Name</a> via the indicated
--   <a>Endpoint</a>. While a successful response (indicated by returning
--   <tt>Right ()</tt>) indicates that there was no error initiating
--   transport of the message, success does not guarantee that an
--   <a>Endpoint</a> received the message. Failure initiating transport is
--   indicated by returning <tt>Left text-of-error-message</tt>.
sendMessage :: Endpoint -> Name -> Message -> IO (Either String ())

-- | A variant of <a>sendMessage</a> for use when the return value can be
--   ignored.
sendMessage_ :: Endpoint -> Name -> Message -> IO ()

-- | Helper for sending a single <a>Message</a> to several
--   <a>Endpoint</a>s.
broadcastMessage :: Endpoint -> [Name] -> Message -> IO [(Either String ())]

-- | Variant of <a>broadcastMessage</a> that ignores the results of
--   sending.
broadcastMessage_ :: Endpoint -> [Name] -> Message -> IO ()

-- | Receive the next <a>Message</a> sent to the <a>Endpoint</a>, blocking
--   until a message is available.
receiveMessage :: Endpoint -> IO Message

-- | Wait for a message to be received within the timeout, blocking until
--   either a message is available or the timeout has occurred. If a
--   message was available, returns <tt>Just message</tt>, but returns
--   <tt>Nothing</tt> if no message available before the timeout occurred.
receiveMessageTimeout :: Endpoint -> Int -> IO (Maybe Message)

-- | Posts a <a>Message</a> directly to an <a>Endpoint</a>, without use of
--   a transport. This may be useful for applications that prefer to use
--   the <tt>Endpoint'</tt>s <a>Mailbox</a> as a general queue of ordered
--   messages.
postMessage :: Endpoint -> Message -> IO ()

-- | Select the next available message in the <a>Endpoint</a>
--   <a>Mailbox</a> matching the supplied test function, or blocking until
--   one is available. This function differs from <a>receiveMessage</a> in
--   that it supports out of order message reception.
selectMessage :: Endpoint -> (Message -> Maybe v) -> IO v

-- | Wait for a message to be selected within the timeout, blocking until
--   either a message is available or the timeout has occurred. If a
--   message was available, returns <tt>Just message</tt>, but returns
--   <tt>Nothing</tt> if no message available before the timeout occurred.
--   Like <a>selectMessage</a>, this function enables out of order message
--   reception.
selectMessageTimeout :: Endpoint -> Int -> (Message -> Maybe v) -> IO (Maybe v)

-- | Find a <a>Message</a> in the <a>Endpoint</a> <a>Mailbox</a> matching
--   the supplied test function, or block until one is available. Note that
--   any such message is left in the mailbox, and thus repeated calls to
--   this function could find the message if it is not consumed
--   immediately.
detectMessage :: Endpoint -> (Message -> Maybe v) -> IO v

-- | Find a <a>Message</a> in the <a>Endpoint</a> <a>Mailbox</a> matching
--   the supplied test function, or block until either one is available or
--   the timeout expires. Note that any such message is left in the
--   mailbox, and thus repeated calls to this function could find the
--   message if it is not consumed immediately.
detectMessageTimeout :: Endpoint -> Int -> (Message -> Maybe v) -> IO (Maybe v)

-- | Dispatch the next available message in the <a>Endpoint</a>
--   <a>Mailbox</a> matching the supplied test function, or blocking until
--   one is available. Once a matching message is found, handle the message
--   with the supplied handler and return any result obtained. This
--   function differs from <a>receiveMessage</a> in that it supports out of
--   order message reception.
dispatchMessage :: Endpoint -> (Message -> Maybe v) -> (v -> IO r) -> IO r
dispatchMessageTimeout :: Endpoint -> Int -> (Message -> Maybe v) -> (v -> IO r) -> IO (Maybe r)


-- | An implementation of synchronous remote procedure calls (<a>RPC</a>)
--   on top of <a>Endpoint</a>s.
--   
--   Applications exporting services for use by other applications via RPC
--   call <a>handle</a> to start listening for incoming RPC requests for a
--   specific <a>Method</a>. If multiple functions or <a>Method</a>s are
--   exported, then separate calls to <a>handle</a> are necessary, one for
--   each exported <a>Method</a>. Each call to <a>handle</a> produces a
--   <a>HandleSite</a> which may be used to terminate future handling of
--   RPCs for that specific method by calling <a>hangup</a> on the returned
--   <a>HandleSite</a>.
--   
--   Applications wishing to make RPCs to other applications or services do
--   so by first constructing a <a>CallSite</a>, and then <a>call</a>ing
--   specific methods on the target handler through that <a>CallSite</a>.
--   
--   Both single and multiple target RPCs are available, as are variants
--   that either wait indefinitely or at most for a defined timeout.
module Network.RPC
type Method = String

-- | Create a new <a>CallSite</a> using the indicated <a>Endpoint</a> for
--   sending RPCs and using the specified <a>Name</a> for receiving
--   responses.
newCallSite :: Endpoint -> Name -> CallSite

-- | A call site is a location for making RPCs: it includes an endpoint and
--   a name by which recipients can return the call
data CallSite

-- | Call a method with the provided arguments on the recipient with the
--   given name.
--   
--   The caller will wait until a matching response is received.
call :: CallSite -> Name -> Method -> Message -> IO Message

-- | Call a method with the provided arguments on the recipient with the
--   given name. A request will be made through the <tt>CallSite'</tt>s
--   <a>Endpoint</a>, and then the caller will wait until a matching
--   response is received. If a response is received within the provided
--   timeout (measured in microseconds), then return the value wrapped in
--   <a>Just</a>; otherwise, if the timeout expires before the call
--   returns, then return 'Nothing.
callWithTimeout :: CallSite -> Name -> Method -> Int -> Message -> IO (Maybe Message)

-- | Group call or RPC: call a method with the provided arguments on all
--   the recipients with the given names. A request will be made through
--   the <tt>CallSite'</tt>s <a>Endpoint</a>, and then the caller will wait
--   until all matching responses are received.
gcall :: CallSite -> [Name] -> Method -> Message -> IO (Map Name Message)

-- | Group call or RPC but with a timeout: call a method with the provided
--   arguments on all the recipients with the given names. A request will
--   be made through the <tt>CallSite'</tt>s <a>Endpoint</a>, and then the
--   caller will wait until all matching responses are received or the
--   timeout occurs. The returned <a>Map</a> has a key for every
--   <a>Name</a> that was a target of the call, and the value of that key
--   will be <tt>Nothing</tt> if no response was received before the
--   timeout, or <tt>Just value</tt> if a response was received.
gcallWithTimeout :: CallSite -> [Name] -> Method -> Int -> Message -> IO (Map Name (Maybe Message))

-- | Invoke the same method on multiple <a>Name</a>s, and wait indefinitely
--   until the first response from any <a>Name</a>, returning the value and
--   the <a>Name</a> which responded.
anyCall :: CallSite -> [Name] -> Method -> Message -> IO (Message, Name)

-- | A simple function that, given a <a>Method</a>, returns a filter
--   suitable for use with <a>selectMessage</a>. The typical use case will
--   involve partial application: <tt>methodSelector method</tt> passed as
--   an argument to <a>selectMessage</a>.
methodSelector :: Method -> Message -> Maybe (Name, RequestId, Message)

-- | Wait for a single incoming request to invoke the indicated
--   <a>Method</a> on the specified <a>Endpoint</a>. Return both the method
--   arguments and a <a>Reply</a> function useful for sending the reply. A
--   good pattern for using <a>hear</a> will pattern match the result to a
--   tuple of the form <tt>(args,reply)</tt>, then use the args as needed
--   to compute a result, and then finally send the result back to the
--   client by simply passing the result to reply: <tt>reply result</tt>.
--   
--   The invoker of <a>hear</a> must supply the <a>Name</a> they have bound
--   to the <a>Endpoint</a>, as this helps the original requestor of the
--   RPC differentiate responses when the RPC was a group call.
hear :: Endpoint -> Name -> Method -> IO (Message, Reply Message)

-- | Same as <a>hear</a>, except return <a>Nothing</a> if no request
--   received within the specified timeout (measured in microseconds), or
--   return a <a>Just</a> instance containing both the method arguments and
--   a <a>Reply</a> function useful for sending the reply.
hearTimeout :: Endpoint -> Name -> Method -> Int -> IO (Maybe (Message, Reply Message))

-- | A <a>Reply</a> is a one-shot function for sending a response to an
--   incoming request.
type Reply b = b -> IO ()

-- | A <a>HandleSite</a> is a just reference to the actual handler of a
--   specific method. Mostly for invoking <a>hangup</a> on the handler,
--   once it is no longer needed.
data HandleSite

-- | Handle all RPCs to invoke the indicated <a>Method</a> on the specified
--   <a>Endpoint</a>, until <a>hangup</a> is called on the returned
--   <a>HandleSite</a>.
handle :: Endpoint -> Name -> Method -> (Message -> IO Message) -> IO HandleSite

-- | Stop handling incoming RPCs for the indicated <a>HandleSite</a>.
hangup :: HandleSite -> IO ()
data Request
Request :: RequestId -> Name -> Method -> Message -> Request
requestId :: Request -> RequestId
requestCaller :: Request -> Name
requestMethod :: Request -> Method
requestArgs :: Request -> Message
data RequestId

-- | Create a new identifier for <a>Request</a>s
mkRequestId :: IO RequestId
data Response
Response :: RequestId -> Name -> Message -> Response
responseId :: Response -> RequestId
responseFrom :: Response -> Name
responseValue :: Response -> Message
instance Eq RPCMessageType
instance Show RPCMessageType
instance Enum RPCMessageType
instance Generic RPCMessageType
instance Generic RequestId
instance Eq RequestId
instance Show RequestId
instance Eq Request
instance Show Request
instance Eq Response
instance Show Response
instance Datatype D1RPCMessageType
instance Constructor C1_0RPCMessageType
instance Constructor C1_1RPCMessageType
instance Datatype D1RequestId
instance Constructor C1_0RequestId
instance Serialize Response
instance Serialize Request
instance Serialize RequestId
instance Serialize RPCMessageType
