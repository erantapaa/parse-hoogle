-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Spear Parser
--   
--   Parser for the analysis files produced by the Spear frequency partial
--   tracker.
@package hspear
@version 0.14


-- | <i>Spear</i> <tt>PTPF</tt> (par-text-partials-format) files.
module Sound.Analysis.Spear.PTPF

-- | Adjacent duples.
--   
--   <pre>
--   duples [1..6] == [(1,2),(3,4),(5,6)]
--   </pre>
duples :: [t] -> [(t, t)]

-- | Adjacent triples.
--   
--   <pre>
--   triples [1..6] == [(1,2,3),(4,5,6)]
--   </pre>
triples :: [t] -> [(t, t, t)]

-- | Apply <i>f</i> at last element.
--   
--   <pre>
--   at_last negate [1..3] == [1,2,-3]
--   </pre>
at_last :: (a -> a) -> [a] -> [a]

-- | Numerically stable mean
--   
--   <pre>
--   map mean [[1..5],[3,5,7],[7,7],[3,9,10,11,12]] == [3,5,7,9]
--   </pre>
mean :: Floating a => [a] -> a

-- | <a>minimum</a> &amp; <a>maximum</a>.
--   
--   <pre>
--   minmax [0..5] == (0,5)
--   </pre>
minmax :: Ord b => [b] -> (b, b)
type N_Time = Double
type N_Data = Double

-- | Record to hold data for single node of a partial track.
data Node
Node :: Int -> Double -> N_Data -> N_Data -> Node

-- | Partial identifier
n_partial_id :: Node -> Int
n_time :: Node -> Double
n_frequency :: Node -> N_Data
n_amplitude :: Node -> N_Data

-- | Set <a>n_amplitude</a> at <a>Node</a> to <tt>0</tt>.
n_zero_amplitude :: Node -> Node

-- | Set <a>n_partial_id</a> at <a>Node</a>.
n_set_partial_id :: Int -> Node -> Node

-- | Apply transform <i>f</i> at <a>n_time</a>.
n_temporal_f :: (N_Time -> N_Time) -> Node -> Node

-- | A sequence of partial <a>Node</a> data.
data Seq
Seq :: Int -> N_Time -> N_Time -> Int -> [Node] -> Seq

-- | <a>==</a> to <a>n_partial_id</a> at <a>s_data</a>.
s_identifier :: Seq -> Int

-- | <a>minimum</a> <a>n_time</a> at <a>s_data</a>.
s_start_time :: Seq -> N_Time

-- | <a>maximum</a> <a>n_time</a> at <a>s_data</a>.
s_end_time :: Seq -> N_Time

-- | <a>==</a> to <a>length</a> <a>s_data</a>
s_nodes :: Seq -> Int
s_data :: Seq -> [Node]

-- | Apply <i>f</i> at <a>s_data</a> of <a>Seq</a> and re-calculate
--   temporal bounds.
s_map :: (Node -> Node) -> Seq -> Seq
s_summarise :: ([a] -> b) -> (Node -> a) -> Seq -> b

-- | <a>maximum</a> <a>n_amplitude</a> at <a>s_data</a>.
s_max_amplitude :: Seq -> N_Data

-- | <a>minimum</a> <a>n_amplitude</a> at <a>s_data</a>.
s_min_amplitude :: Seq -> N_Data

-- | <a>mean</a> <a>n_amplitude</a> at <a>s_data</a>.
s_mean_amplitude :: Seq -> N_Data

-- | <a>mean</a> <a>n_frequency</a> at <a>s_data</a>.
s_mean_frequency :: Seq -> N_Data

-- | <a>s_end_time</a> <a>-</a> <a>s_start_time</a>.
s_duration :: Seq -> N_Time

-- | Set <a>s_identifier</a> and associated <a>n_partial_id</a>.
s_set_identifier :: Int -> Seq -> Seq

-- | <a>==</a> <a>on</a> <a>s_identifier</a>.
s_eq_identifier :: Seq -> Seq -> Bool

-- | <a>unionBy</a> <a>s_eq_identifier</a>.
s_union :: [Seq] -> [Seq] -> [Seq]

-- | Apply transform <i>f</i> at <a>n_time</a>.
s_temporal_f :: (N_Time -> N_Time) -> Seq -> Seq

-- | A <a>PTPF</a> is a set of <a>Seq</a>.
data PTPF
PTPF :: Int -> [Seq] -> PTPF
p_partials :: PTPF -> Int
p_seq :: PTPF -> [Seq]

-- | <a>minimum</a> <a>s_start_time</a> at <a>p_seq</a>.
p_start_time :: PTPF -> N_Time

-- | <a>maximum</a> <a>s_end_time</a> at <a>p_seq</a>.
p_end_time :: PTPF -> N_Time

-- | <a>sum</a> of <a>s_nodes</a> of <a>p_seq</a>.
p_nodes :: PTPF -> Int

-- | Generate <a>PTPF</a> from set of <a>Seq</a>. Re-assigns partial
--   identifiers.
p_from_seq :: [Seq] -> PTPF
p_temporal_f :: (N_Time -> N_Time) -> PTPF -> PTPF
p_map :: (Seq -> Seq) -> PTPF -> PTPF
p_filter :: (Seq -> Bool) -> PTPF -> PTPF
p_node_map :: (Node -> Node) -> PTPF -> PTPF
type STR = ByteString
str_int :: ByteString -> Int
str_double :: Floating n => ByteString -> n
str_words :: ByteString -> [ByteString]
str_lines :: ByteString -> [ByteString]

-- | Parse <a>Node</a>.
ptpf_node :: Int -> (STR, STR, STR) -> Node

-- | Parse <a>Seq</a> from pair of input lines.
ptpf_seq :: (STR, STR) -> Seq

-- | Parse header section, result is number of partials.
ptpf_header :: [STR] -> Maybe Int

-- | Parse <a>PTPF</a> at <a>STR</a>.
parse_ptpf :: STR -> Either String PTPF

-- | All <a>Node</a>s grouped into sets with equal start times.
ptpf_time_asc :: PTPF -> [(N_Time, [Node])]
instance Eq Node
instance Show Node
instance Eq Seq
instance Show Seq
instance Eq PTPF
instance Show PTPF


-- | Variants for handling <tt>GZIP</tt> compressed data.
module Sound.Analysis.Spear.PTPF.GZ

-- | Variant of <a>parse_ptpf</a> running <a>decompress</a>.
parse_ptpf_gz :: ByteString -> Either String PTPF

-- | Load compressed spear data.
load_ptpf_gz :: FilePath -> IO (Either String PTPF)

-- | Apply <i>f</i> at <a>Right</a>, else <a>id</a>.
at_right :: (a -> b) -> Either t a -> Either t b

-- | Variant of <a>load_ptpf_gz</a> transforming with <a>ptpf_time_asc</a>.
load_ptpf_gz_time_asc :: FilePath -> IO (Either String [(N_Time, [Node])])

module Sound.Analysis.Spear.PTPF.Reduce

-- | True if (n1,n2,n3) can be reduced to (n1,n3).
type N_Reduction_F = (Node, Node, Node) -> Bool
n_reduction :: N_Reduction_F -> [Node] -> [Node]
s_reduction :: N_Reduction_F -> Seq -> Seq
cps_to_fmidi :: Floating a => a -> a
ampDb :: Floating a => a -> a

-- | Frequency (FMIDI) and amplitude (DB) gradient from <i>n1</i> to
--   <i>n2</i>.
n_gradient :: Node -> Node -> (N_Data, N_Data)
s_reduction_gradient :: (N_Data, N_Data) -> Seq -> Seq
p_reduction_gradient :: (N_Data, N_Data) -> PTPF -> PTPF


-- | <a>String</a> variant of parser.
module Sound.Analysis.Spear.PTPF.String

-- | Parse <a>Node</a>.
ptpf_node :: Int -> (String, String, String) -> Node

-- | Parse <a>Seq</a> from pair of input lines.
ptpf_seq :: (String, String) -> Seq

-- | Parse header section, result is number of partials.
ptpf_header :: [String] -> Maybe Int

-- | Parse <a>PTPF</a> at <a>String</a>.
parse_ptpf :: String -> Either String PTPF
