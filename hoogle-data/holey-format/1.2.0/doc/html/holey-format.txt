-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinator-based type-safe formatting (like printf() or FORMAT)
--   
--   Combinator-based type-safe formatting (like printf() or FORMAT),
--   modelled from the HoleyMonoids package.
@package holey-format
@version 1.2.0


-- | Combinator-based type-safe formatting (like printf() or FORMAT) for
--   Text.
--   
--   Example:
--   
--   <pre>
--   formatPerson =
--     print (now "Person's name is " . ident . text . now ", age is " . hex . now "n")
--           "Dave"
--           "Jones"
--           35
--   </pre>
module Text.Format

-- | Continuation based string formatter.
type Format m a b = forall r. ((m -> r) -> a) -> ((m -> r) -> b)

-- | Builder formatting.
type Build a = forall r b. ((Builder -> r) -> b) -> (Builder -> r) -> a -> b

-- | Wrap the result with a function.
type Wrap r m a t = ((m -> a) -> t) -> ((r -> a) -> t)

-- | Append something to the output stream now.
now :: Monoid m => m -> Format m a a

-- | Append something to the output stream, taking the value as an argument
--   to a formatting function later.
later :: Monoid m => (a -> m) -> Format m b (a -> b)

-- | Wrap the whole result in a function.
wrap :: (m -> r) -> Wrap r m a t

-- | Run the formatter.
run :: Monoid f => Format f f a -> a

-- | Identity on later.
ident :: Monoid m => ((m -> r) -> b) -> (m -> r) -> m -> b

-- | Run the formatter and at the end extract a lazy <a>Text</a> from the
--   <a>Builder</a>.
format :: Format Builder Text a -> a

-- | Run the formatter producing a <a>Builder</a>.
builder :: Format Builder Builder a -> a

-- | Run the formatter and print out the text to stdout.
print :: Format Builder (IO ()) a -> a

-- | Run the formatter and put the output onto the given <a>Handle</a>.
hprint :: Handle -> Format Builder (IO ()) a -> a

-- | Include a buildable in the output stream.
build :: Buildable a => Build a

-- | Output a lazy text.
text :: Build Text

-- | Output a strict text.
stext :: Build Text

-- | Output a string.
string :: Build String

-- | Render an integer using hexadecimal notation. (No leading 0x is
--   added.) hex :: Build Integer
hex :: Build Integer

-- | Render a floating point number using scientific/engineering notation
--   (e.g. 2.3e123), with the given number of decimal places.
expt :: Real a => Int -> Build a

-- | Render a floating point number using normal notation, with the given
--   number of decimal places.
fixed :: Real a => Int -> Build a

-- | Render a floating point number, with the given number of digits of
--   precision. Uses decimal notation for values between 0.1 and 9,999,999,
--   and scientific notation otherwise.
prec :: Real a => Int -> Build a

-- | Render a floating point number using the smallest number of digits
--   that correctly represent it.
shortest :: Real a => Build a

-- | Pad the left hand side of a string until it reaches k characters wide,
--   if necessary filling with character c.
left :: Buildable a => Int -> Char -> Build a

-- | Pad the right hand side of a string until it reaches k characters
--   wide, if necessary filling with character c.
right :: Buildable a => Int -> Char -> Build a
data Text :: *

-- | A <tt>Builder</tt> is an efficient way to build lazy <tt>Text</tt>
--   values. There are several functions for constructing builders, but
--   only one to inspect them: to extract any data, you have to turn them
--   into lazy <tt>Text</tt> values using <tt>toLazyText</tt>.
--   
--   Internally, a builder constructs a lazy <tt>Text</tt> by filling
--   arrays piece by piece. As each buffer is filled, it is 'popped' off,
--   to become a new chunk of the resulting lazy <tt>Text</tt>. All this is
--   hidden from the user of the <tt>Builder</tt>.
data Builder :: *

-- | The class of types that can be rendered to a <a>Builder</a>.
class Buildable p
