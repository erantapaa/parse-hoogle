-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible Haskell pretty printer
--   
@package hindent
@version 4.5.4


-- | All types.
module HIndent.Types

-- | A pretty printing monad.
newtype Printer s a
Printer :: StateT (PrintState s) (MaybeT Identity) a -> Printer s a
runPrinter :: Printer s a -> StateT (PrintState s) (MaybeT Identity) a

-- | The state of the pretty printer.
data PrintState s
PrintState :: !Int64 -> !Builder -> !Bool -> !Int64 -> !Int64 -> !s -> ![Extender s] -> !Config -> !Bool -> !Bool -> !ParseMode -> (forall m. MonadState (PrintState s) m => [Comment] -> m [Comment]) -> PrintState s

-- | Current indentation level.
psIndentLevel :: PrintState s -> !Int64

-- | The current output.
psOutput :: PrintState s -> !Builder

-- | Just outputted a newline?
psNewline :: PrintState s -> !Bool

-- | Current column.
psColumn :: PrintState s -> !Int64

-- | Current line number.
psLine :: PrintState s -> !Int64

-- | User state.
psUserState :: PrintState s -> !s

-- | Extenders.
psExtenders :: PrintState s -> ![Extender s]

-- | Config which styles may or may not pay attention to.
psConfig :: PrintState s -> !Config

-- | An end of line comment has just been outputted.
psEolComment :: PrintState s -> !Bool

-- | Whether we're in a case statement, used for Rhs printing.
psInsideCase :: PrintState s -> !Bool

-- | Mode used to parse the original AST.
psParseMode :: PrintState s -> !ParseMode

-- | Preprocessor applied to comments on an AST before printing.
psCommentPreprocessor :: PrintState s -> forall m. MonadState (PrintState s) m => [Comment] -> m [Comment]

-- | A printer extender. Takes as argument the user state that the printer
--   was run with, and the current node to print. Use <tt>prettyNoExt</tt>
--   to fallback to the built-in printer.
data Extender s
Extender :: (a -> Printer s ()) -> Extender s
CatchAll :: (forall a. Typeable a => s -> a -> Maybe (Printer s ())) -> Extender s

-- | A printer style.
data Style
Style :: !Text -> !Text -> !Text -> !s -> ![Extender s] -> !Config -> (forall s' m. MonadState (PrintState s') m => [Comment] -> m [Comment]) -> Style

-- | Name of the style, used in the commandline interface.
styleName :: Style -> !Text

-- | Author of the printer (as opposed to the author of the style).
styleAuthor :: Style -> !Text

-- | Description of the style.
styleDescription :: Style -> !Text

-- | User state, if needed.
styleInitialState :: Style -> !s

-- | Extenders to the printer.
styleExtenders :: Style -> ![Extender s]

-- | Default config to use for this style.
styleDefConfig :: Style -> !Config

-- | Preprocessor to use for comments.
styleCommentPreprocessor :: Style -> forall s' m. MonadState (PrintState s') m => [Comment] -> m [Comment]

-- | Configurations shared among the different styles. Styles may pay
--   attention to or completely disregard this configuration.
data Config
Config :: !Int64 -> !Int64 -> !Bool -> Config

-- | Maximum columns to fit code into ideally.
configMaxColumns :: Config -> !Int64

-- | How many spaces to indent?
configIndentSpaces :: Config -> !Int64

-- | Remove spaces on lines that are otherwise empty?
configClearEmptyLines :: Config -> !Bool

-- | Default style configuration.
defaultConfig :: Config

-- | Information for each node in the AST.
data NodeInfo
NodeInfo :: !SrcSpanInfo -> ![ComInfo] -> NodeInfo

-- | Location info from the parser.
nodeInfoSpan :: NodeInfo -> !SrcSpanInfo

-- | Comments which are attached to this node.
nodeInfoComments :: NodeInfo -> ![ComInfo]

-- | Comment with some more info.
data ComInfo
ComInfo :: !Comment -> !(Maybe ComInfoLocation) -> ComInfo

-- | The normal comment type.
comInfoComment :: ComInfo -> !Comment

-- | Where the comment lies relative to the node.
comInfoLocation :: ComInfo -> !(Maybe ComInfoLocation)

-- | Comment relative locations.
data ComInfoLocation
Before :: ComInfoLocation
After :: ComInfoLocation
instance Typeable ComInfoLocation
instance Typeable ComInfo
instance Typeable NodeInfo
instance Applicative (Printer s)
instance Monad (Printer s)
instance Functor (Printer s)
instance MonadState (PrintState s) (Printer s)
instance MonadPlus (Printer s)
instance Alternative (Printer s)
instance Show ComInfoLocation
instance Data ComInfoLocation
instance Eq ComInfoLocation
instance Show ComInfo
instance Data ComInfo
instance Show NodeInfo
instance Data NodeInfo
instance Default Config
instance Eq (PrintState s)


-- | Fundamental built-in style. Defines no additional extensions or
--   configurations beyond the default printer.
module HIndent.Styles.Fundamental

-- | Empty state.
data State
State :: State

-- | The printer style.
fundamental :: Style


-- | Pretty printing.
module HIndent.Pretty

-- | Pretty printing class.
class (Annotated ast, Typeable ast) => Pretty ast

-- | Pretty print using extenders.
pretty :: (Pretty ast, MonadState (PrintState s) m) => ast NodeInfo -> m ()

-- | Run the basic printer for the given node without calling an extension
--   hook for this node, but do allow extender hooks in child nodes. Also
--   auto-inserts comments.
prettyNoExt :: (Pretty ast, MonadState (PrintState s) m) => ast NodeInfo -> m ()

-- | Get the user state.
getState :: Printer s s

-- | Put the user state.
putState :: s -> Printer s ()

-- | Modify the user state.
modifyState :: (s -> s) -> Printer s ()

-- | Write out a string, updating the current position information.
write :: MonadState (PrintState s) m => Builder -> m ()

-- | Output a newline.
newline :: MonadState (PrintState s) m => m ()

-- | Write a space.
space :: MonadState (PrintState s) m => m ()

-- | Write a comma.
comma :: MonadState (PrintState s) m => m ()

-- | Write an integral.
int :: (Integral n, MonadState (PrintState s) m) => n -> m ()

-- | Write a string.
string :: MonadState (PrintState s) m => String -> m ()

-- | Maybe render a class context.
maybeCtx :: MonadState (PrintState s) m => Maybe (Context NodeInfo) -> m ()

-- | Pretty print a comment.
printComment :: MonadState (PrintState s) m => Maybe SrcSpan -> Comment -> m ()

-- | Print comments of a node.
printComments :: (Pretty ast, MonadState (PrintState s) m) => ComInfoLocation -> ast NodeInfo -> m ()

-- | Set the context to a case context, where RHS is printed with -&gt; .
withCaseContext :: MonadState (PrintState s) m => Bool -> m a -> m a

-- | Get the current RHS separator, either = or -&gt; .
rhsSeparator :: MonadState (PrintState s) m => m ()

-- | Print all the printers separated by sep.
inter :: MonadState (PrintState s) m => m () -> [m ()] -> m ()

-- | Print all the printers separated by spaces.
spaced :: MonadState (PrintState s) m => [m ()] -> m ()

-- | Print all the printers separated by newlines.
lined :: MonadState (PrintState s) m => [m ()] -> m ()

-- | Print all the printers separated newlines and optionally a line
--   prefix.
prefixedLined :: MonadState (PrintState s) m => Text -> [m ()] -> m ()

-- | Print all the printers separated by commas.
commas :: MonadState (PrintState s) m => [m ()] -> m ()

-- | Wrap in parens.
parens :: MonadState (PrintState s) m => m a -> m a

-- | Wrap in brackets.
brackets :: MonadState (PrintState s) m => m a -> m a

-- | Wrap in braces.
braces :: MonadState (PrintState s) m => m a -> m a

-- | Increase indentation level by n spaces for the given printer.
indented :: MonadState (PrintState s) m => Int64 -> m a -> m a

-- | Set the (newline-) indent level to the given column for the given
--   printer.
column :: MonadState (PrintState s) m => Int64 -> m a -> m a

-- | Get the current indent level.
getColumn :: MonadState (PrintState s) m => m Int64

-- | Get the current line number.
getLineNum :: MonadState (PrintState s) m => m Int64

-- | Make the latter's indentation depend upon the end column of the
--   former.
depend :: MonadState (PrintState s) m => m () -> m b -> m b

-- | Make the latter's indentation depend upon the end column of the
--   former.
dependBind :: MonadState (PrintState s) m => m a -> (a -> m b) -> m b

-- | Swing the second printer below and indented with respect to the first.
swing :: MonadState (PrintState s) m => m () -> m b -> m b

-- | Swing the second printer below and indented with respect to the first
--   by the specified amount.
swingBy :: MonadState (PrintState s) m => Int64 -> m () -> m b -> m b

-- | Indent spaces, e.g. 2.
getIndentSpaces :: MonadState (PrintState s) m => m Int64

-- | Column limit, e.g. 80
getColumnLimit :: MonadState (PrintState s) m => m Int64

-- | No binds?
nullBinds :: Binds NodeInfo -> Bool

-- | Play with a printer and then restore the state to what it was before.
sandbox :: MonadState s m => m a -> m (a, s)

-- | Pretty print using HSE's own printer. The <a>Pretty</a> class here is
--   HSE's.
pretty' :: (Pretty ast, Pretty (ast SrcSpanInfo), Functor ast, MonadState (PrintState s) m) => ast NodeInfo -> m ()
instance Pretty ExportSpec
instance Pretty ExportSpecList
instance Pretty WarningText
instance Pretty ImportSpec
instance Pretty ImportSpecList
instance Pretty ModuleName
instance Pretty ImportDecl
instance Pretty ModulePragma
instance Pretty ModuleHead
instance Pretty TyVarBind
instance Pretty QOp
instance Pretty QName
instance Pretty Name
instance Pretty Literal
instance Pretty Kind
instance Pretty FunDep
instance Pretty DataOrNew
instance Pretty IPBind
instance Pretty Bracket
instance Pretty Module
instance Pretty Sign
instance Pretty Overlap
instance Pretty SpecialCon
instance Pretty DeclHead
instance Pretty InstHead
instance Pretty InstRule
instance Pretty Splice
instance Pretty Rhs
instance Pretty QualConDecl
instance Pretty PatField
instance Pretty Match
instance Pretty InstDecl
instance Pretty GuardedRhs
instance Pretty FieldUpdate
instance Pretty FieldDecl
instance Pretty ConDecl
instance Pretty ClassDecl
instance Pretty Binds
instance Pretty BangType
instance Pretty Asst
instance Pretty Alt
instance Pretty Deriving
instance Pretty Decl
instance Pretty QualStmt
instance Pretty Stmt
instance Pretty Exp
instance Pretty Type
instance Pretty Pat
instance Pretty Context

module HIndent.Styles.Gibiansky

-- | Empty state.
data State
State :: Bool -> Bool -> State
gibianskyForceSingleLine :: State -> Bool
gibianskyLetBind :: State -> Bool
userGets :: (State -> a) -> Printer State a
userModify :: (State -> State) -> Printer State ()

-- | The printer style.
gibiansky :: Style
commentContent :: Comment -> String
commentSrcSpan :: Comment -> SrcSpan
commentPreprocessor :: MonadState (PrintState s) m => [Comment] -> m [Comment]

-- | Break a comment string into lines of a maximum character length. Each
--   line starts with a space, mirroring the traditional way of writing
--   comments:
--   
--   <ul>
--   <li>- Hello</li>
--   <li>- Note the space after the <a>-</a></li>
--   </ul>
breakCommentLines :: Int -> String -> [String]
dropTrailingNewlines :: String -> String

-- | Number of spaces to indent by.
indentSpaces :: Integral a => a

-- | Printer to indent one level.
indentOnce :: Printer s ()

-- | How many exports to format in a single line. If an export list has
--   more than this, it will be formatted as multiple lines.
maxSingleLineExports :: Integral a => a
attemptSingleLine :: Printer State a -> Printer State a -> Printer State a
type Extend f = f NodeInfo -> Printer State ()

-- | Format whole modules.
modl :: Extend Module
skipFollowingNewline :: Decl l -> Bool

-- | Format pragmas differently (language pragmas).
pragmas :: Extend ModulePragma

-- | Format patterns.
pat :: Extend Pat

-- | Format import statements.
imp :: Extend ImportDecl

-- | Return the number of columns between the start and end of a printer.
--   Note that if it breaks lines, the line break is not counted; only
--   column is used. So you probably only want to use this for single-line
--   printers.
prettyColLength :: (Integral a, Pretty ast) => ast NodeInfo -> Printer State a

-- | Format contexts with spaces and commas between class constraints.
context :: Extend Context

-- | Format deriving clauses with spaces and commas between class
--   constraints.
derivings :: Extend Deriving

-- | Format function type declarations.
typ :: Extend Type
writeTuple :: Pretty ast => Boxed -> [ast NodeInfo] -> Printer State ()
sameLine :: (Annotated ast, Annotated ast') => ast NodeInfo -> ast' NodeInfo -> Bool
collectTypes :: Type l -> [Type l]
exprs :: Extend Exp
multiIfExpr :: Exp NodeInfo -> Printer State ()
letExpr :: Exp NodeInfo -> Printer State ()
keepingColumn :: Printer State () -> Printer State ()
appExpr :: Exp NodeInfo -> Printer State ()
doExpr :: Exp NodeInfo -> Printer State ()
listExpr :: Exp NodeInfo -> Printer State ()
singleLineList :: Pretty a => [a NodeInfo] -> Printer State ()
multiLineList :: [Exp NodeInfo] -> Printer State ()
dollarExpr :: Exp NodeInfo -> Printer State ()
applicativeExpr :: Exp NodeInfo -> Printer State ()
opExpr :: Exp NodeInfo -> Printer State ()
lambdaExpr :: Exp NodeInfo -> Printer State ()
caseExpr :: Exp NodeInfo -> Printer State ()
lambdaCaseExpr :: Exp NodeInfo -> Printer State ()
ifExpr :: Exp NodeInfo -> Printer State ()
writeCaseAlts :: [Alt NodeInfo] -> Printer State ()
prettyCommentCallbacks :: (Pretty ast, MonadState (PrintState s) m) => ast NodeInfo -> (ComInfoLocation -> m ()) -> m ()
recUpdateExpr :: Foldable f => [f NodeInfo] -> Printer State () -> [(ComInfoLocation -> Printer State ()) -> Printer State ()] -> Printer State ()
commaAfterComment :: ComInfoLocation -> Printer State ()
rhss :: Extend Rhs
lineBreakAfterRhs :: NodeInfo -> Exp NodeInfo -> Bool
guardedRhs :: Extend GuardedRhs
rhsRest :: Pretty ast => ast NodeInfo -> Printer State ()
stmts :: Extend Stmt
decls :: Extend Decl
qualConDecl :: Extend QualConDecl
funBody :: [Pat NodeInfo] -> Rhs NodeInfo -> Maybe (Binds NodeInfo) -> Printer State ()
writeWhereBinds :: Binds NodeInfo -> Printer State ()
onSeparateLines :: (Pretty ast, Annotated ast) => [ast NodeInfo] -> Printer State ()
onSeparateLines' :: Annotated ast => (ast NodeInfo -> Printer State ()) -> [ast NodeInfo] -> Printer State ()
fixSpans :: NodeInfo -> NodeInfo
astStartLine :: Annotated ast => ast NodeInfo -> Int
isDoBlock :: Rhs l -> Bool
condecls :: Extend ConDecl
hasComments :: Foldable ast => ast NodeInfo -> Bool
alt :: Extend Alt
moduleHead :: Extend ModuleHead
exportList :: Extend ExportSpecList
lineDelta :: (Annotated ast1, Annotated ast2) => ast1 NodeInfo -> ast2 NodeInfo -> Int
fieldUpdate :: Extend FieldUpdate


-- | Comment handling.
module HIndent.Comments

-- | Annotate the AST with comments.
annotateComments :: (Data (ast NodeInfo), Traversable ast, Annotated ast) => ast SrcSpanInfo -> [Comment] -> ([ComInfo], ast NodeInfo)

-- | Is the comment after the node?
commentLocated :: ComInfoLocation -> NodeInfo -> Comment -> Bool

-- | For <tt>After</tt>, does the first span end before the second starts?
--   For <tt>Before</tt>, does the first span start after the second ends?
spanTest :: ComInfoLocation -> SrcSpan -> SrcSpan -> Bool


-- | Chris Done's style.
--   
--   Documented here:
--   <a>https://github.com/chrisdone/haskell-style-guide</a>
module HIndent.Styles.ChrisDone

-- | A short function name.
shortName :: Int64

-- | Column limit: 50
smallColumnLimit :: Int64

-- | Empty state.
data State
State :: State

-- | The printer style.
chrisDone :: Style

-- | Pretty print type signatures like
--   
--   foo :: (Show x,Read x) =&gt; (Foo -&gt; Bar) -&gt; Maybe Int -&gt;
--   (Char -&gt; X -&gt; Y) -&gt; IO ()
decl :: Decl NodeInfo -> Printer s ()

-- | I want field updates to be dependent or newline.
fieldupdate :: FieldUpdate NodeInfo -> Printer t ()

-- | Right-hand sides are dependent.
rhs :: Rhs NodeInfo -> Printer t ()

-- | Right-hand sides are dependent.
unguardedrhs :: Rhs NodeInfo -> Printer t ()

-- | Unguarded case alts.
unguardedalt :: Rhs NodeInfo -> Printer t ()

-- | Decide whether to do alts or rhs based on the context.
contextualGuardedRhs :: GuardedRhs NodeInfo -> Printer t ()

-- | I want guarded RHS be dependent or newline.
guardedrhs :: GuardedRhs NodeInfo -> Printer t ()

-- | I want guarded alts be dependent or newline.
guardedalt :: GuardedRhs NodeInfo -> Printer t ()
stmt :: Stmt NodeInfo -> Printer t ()

-- | Expressions
exp :: Exp NodeInfo -> Printer t ()

-- | Sandbox and render the nodes on multiple lines, returning whether each
--   is a single line.
sandboxSingles :: Pretty ast => [ast NodeInfo] -> Printer t (Bool, PrintState t)

-- | Render multi-line nodes.
multi :: Pretty ast => Int64 -> [ast NodeInfo] -> Bool -> Printer t ()

-- | Sandbox and render the node on a single line, return whether it's on a
--   single line and whether it's overflowing.
sandboxNonOverflowing :: Pretty ast => [ast NodeInfo] -> Printer t ((Bool, Bool), PrintState t)

-- | Is the expression "short"? Used for app heads.
isShort :: Pretty ast => ast NodeInfo -> Printer t (Bool, PrintState t)

-- | Is the given expression "small"? I.e. does it fit on one line and
--   under <a>smallColumnLimit</a> columns.
isSmall :: MonadState (PrintState t) m => m a -> m (Bool, PrintState t)

-- | Is the given expression "small"? I.e. does it fit under
--   <a>smallColumnLimit</a> columns.
isSmallFitting :: MonadState (PrintState t) m => m a -> m (Bool, PrintState t)

-- | Is an expression flat?
isFlat :: Exp NodeInfo -> Bool

-- | Does printing the given thing overflow column limit? (e.g. 80)
fitsOnOneLine :: MonadState (PrintState s) m => m a -> m (Bool, PrintState s)

-- | Does printing the given thing overflow column limit? (e.g. 80)
fitsInColumnLimit :: Printer t a -> Printer t (Bool, PrintState t)
infixApp :: Exp NodeInfo -> Exp NodeInfo -> QOp NodeInfo -> Exp NodeInfo -> Maybe Int64 -> Printer s ()

-- | A link in a chain of operator applications.
data OpChainLink l
OpChainExp :: (Exp l) -> OpChainLink l
OpChainLink :: (QOp l) -> OpChainLink l

-- | Flatten a tree of InfixApp expressions into a chain of operator links.
flattenOpChain :: Exp l -> [OpChainLink l]

-- | Make the right hand side dependent if it's flat, otherwise newline it.
dependOrNewline :: Printer t () -> Exp NodeInfo -> (Exp NodeInfo -> Printer t ()) -> Printer t ()
instance Show l => Show (OpChainLink l)


-- | Stub module for Johan Tibell's style.
--   
--   Documented here:
--   <a>https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md</a>
--   
--   Questions:
--   
--   How to indent after a guarded alt/rhs? How to indent let? How to
--   indent large ADT constructors types?
module HIndent.Styles.JohanTibell

-- | A short function name.
shortName :: Int64

-- | Empty state.
data State
State :: State

-- | The printer style.
johanTibell :: Style
stmt :: Stmt NodeInfo -> Printer s ()

-- | Make the right hand side dependent if it fits on one line, otherwise
--   send it to the next line.
dependOrNewline :: Printer t () -> Exp NodeInfo -> (Exp NodeInfo -> Printer t ()) -> Printer t ()

-- | Handle do and case specially and also space out guards more.
rhs :: Rhs NodeInfo -> Printer s ()

-- | Handle do specially.
--   
--   Implement dangling right-hand-sides.
guardedRhs :: GuardedRhs NodeInfo -> Printer s ()

-- | Space out tuples.
--   
--   Expression customizations.
exp :: Exp NodeInfo -> Printer s ()
match :: Match NodeInfo -> Printer s ()

-- | Format contexts with spaces and commas between class constraints.
context :: Context NodeInfo -> Printer s ()
unboxParens :: MonadState (PrintState s) m => m a -> m a
typ :: Type NodeInfo -> Printer s ()

-- | Pretty print type signatures like
--   
--   foo :: (Show x, Read x) =&gt; (Foo -&gt; Bar) -&gt; Maybe Int -&gt;
--   (Char -&gt; X -&gt; Y) -&gt; IO ()
--   
--   Specially format records. Indent where clauses only 2 spaces.
decl :: Decl NodeInfo -> Printer s ()

-- | Use special record display, used by <tt>dataDecl</tt> in a record
--   scenario.
qualConDecl :: QualConDecl NodeInfo -> Printer s ()

-- | Fields are preceded with a space.
conDecl :: ConDecl NodeInfo -> Printer s ()

-- | Record decls are formatted like: Foo { bar :: X }
recDecl :: ConDecl NodeInfo -> Printer s ()
recUpdateExpr :: Printer s () -> [FieldUpdate NodeInfo] -> Printer s ()

-- | Is the decl a record?
isRecord :: QualConDecl t -> Bool

-- | Does printing the given thing overflow column limit? (e.g. 80)
isOverflow :: MonadState (PrintState s) m => m a -> m Bool

-- | Does printing the given thing overflow column limit? (e.g. 80)
fitsOnOneLine :: MonadState (PrintState s) m => m a -> m (Bool, PrintState s)

-- | Is the given expression a single-liner when printed?
isSingleLiner :: MonadState (PrintState s) m => m a -> m Bool

-- | Is the expression "short"? Used for app heads.
isShort :: Pretty ast => ast NodeInfo -> Printer s (Bool)

-- | Is an expression flat?
isFlat :: Exp NodeInfo -> Printer s Bool

-- | rhs on field update on the same line as lhs.
fieldupdate :: FieldUpdate NodeInfo -> Printer s ()
isSmall :: MonadState (PrintState t) m => m a -> m Bool
bindingGroup :: Binds NodeInfo -> Printer s ()


-- | Haskell indenter.
module HIndent

-- | Format the given source.
reformat :: Style -> Maybe [Extension] -> Text -> Either String Builder

-- | Print the module.
prettyPrint :: ParseMode -> Style -> Module SrcSpanInfo -> [Comment] -> Either a Builder

-- | Parse mode, includes all extensions, doesn't assume any fixities.
parseMode :: ParseMode

-- | A printer style.
data Style
Style :: !Text -> !Text -> !Text -> !s -> ![Extender s] -> !Config -> (forall s' m. MonadState (PrintState s') m => [Comment] -> m [Comment]) -> Style

-- | Name of the style, used in the commandline interface.
styleName :: Style -> !Text

-- | Author of the printer (as opposed to the author of the style).
styleAuthor :: Style -> !Text

-- | Description of the style.
styleDescription :: Style -> !Text

-- | User state, if needed.
styleInitialState :: Style -> !s

-- | Extenders to the printer.
styleExtenders :: Style -> ![Extender s]

-- | Default config to use for this style.
styleDefConfig :: Style -> !Config

-- | Preprocessor to use for comments.
styleCommentPreprocessor :: Style -> forall s' m. MonadState (PrintState s') m => [Comment] -> m [Comment]

-- | Styles list, useful for programmatically choosing.
styles :: [Style]

-- | The printer style.
chrisDone :: Style

-- | The printer style.
johanTibell :: Style

-- | The printer style.
fundamental :: Style

-- | The printer style.
gibiansky :: Style

-- | Test with the given style, prints to stdout.
test :: Style -> Text -> IO ()

-- | Test the given file.
testFile :: FilePath -> Style -> IO ()

-- | Test with all styles, prints to stdout.
testAll :: Text -> IO ()

-- | Parse the source and annotate it with comments, yielding the resulting
--   AST.
testAst :: Text -> Either String ([ComInfo], Module NodeInfo)
instance Show CodeBlock
instance Eq CodeBlock
