-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FRP (functional reactive programming) framework
--   
--   FRP (functional reactive programming) framework inspired by RX,
--   reactive-banana and Iteratee
@package reactive-bacon
@version 0.4.1

module Reactive.Bacon.Core
class Observable s where >>=! action f = action >>= \ observable -> (observable ==> f)
(==>) :: Observable s => s a -> (a -> IO ()) -> IO ()
(>>=!) :: Observable s => IO (s a) -> (a -> IO ()) -> IO ()
data EventStream a
EventStream :: (EventSink a -> IO Disposable) -> EventStream a
subscribe :: EventStream a -> (EventSink a -> IO Disposable)
type EventSink a = Event a -> IO (HandleResult)
data Event a
Next :: a -> Event a
End :: Event a
data HandleResult
More :: HandleResult
NoMore :: HandleResult
type Disposable = IO ()
class EventSource s
toEventStream :: EventSource s => s a -> EventStream a
obs :: EventSource s => s a -> EventStream a
neverE :: EventStream a
toObserver :: (a -> IO ()) -> EventSink a
toEventObserver :: (Event a -> IO ()) -> EventSink a

-- | Reactive property. Differences from EventStream: - addListener
--   function must always deliver the latest known value to the new
--   listener
--   
--   So a Property is roughly an EventStream that stores its latest value
--   so that it is always available for new listeners. Doesn't mean it has
--   to be up to date if it has been without listeners for a while.
data Property a
Property :: (PropertySink a -> IO Disposable) -> Property a
addPropertyListener :: Property a -> PropertySink a -> IO Disposable
class PropertySource s
toProperty :: PropertySource s => s a -> Property a
data PropertyEvent a
Initial :: a -> PropertyEvent a
Update :: a -> PropertyEvent a
EndUpdate :: PropertyEvent a
type PropertySink a = PropertyEvent a -> IO HandleResult
instance PropertySource Property
instance Eq a => Eq (Event a)
instance Show a => Show (Event a)
instance Functor Event
instance Observable EventStream
instance EventSource EventStream

module Reactive.Bacon.PushStream
newPushStream :: IO (EventStream a, Event a -> IO ())
newDispatcher :: ((a -> IO ()) -> IO Disposable) -> IO (EventStream a)

-- | Makes an observable with a single connection to the underlying
--   EventSource. Automatically subscribes/unsubscribes from EventSource
--   based on whether there are any EventSinks.
wrap :: EventSource s => s a -> IO (EventStream a)
instance Observable PushCollection
instance EventSource PushCollection
instance Eq (Subscription q)

module Reactive.Bacon.EventStream
mapE :: EventSource s => (a -> b) -> s a -> IO (EventStream b)
voidE :: EventSource s => s a -> IO (EventStream ())
scanE :: EventSource s => (b -> a -> b) -> b -> s a -> IO (EventStream b)
filterE :: EventSource s => (a -> Bool) -> s a -> IO (EventStream a)
skipDuplicatesE :: EventSource s => Eq a => s a -> IO (EventStream a)
stateMachineE :: EventSource s => (st -> a -> (st, b)) -> st -> s a -> IO (EventStream b)
takeWhileE :: EventSource s => (a -> Bool) -> s a -> IO (EventStream a)
takeE :: EventSource s => Num n => Ord n => n -> s a -> IO (EventStream a)
sinkMap :: EventSource s => (EventSink b -> EventSink a) -> s a -> EventStream b
(===>) :: EventSource s => s a -> (Event a -> IO ()) -> IO ()
instance Functor EventStream

module Reactive.Bacon.Property
changesP :: PropertySource s => s a -> IO (EventStream a)
mapP :: PropertySource s => (a -> b) -> s a -> Property b
combineP :: PropertySource s1 => PropertySource s2 => s1 a -> s2 b -> Property (a, b)
combineWithP :: PropertySource s1 => PropertySource s2 => (a -> b -> c) -> s1 a -> s2 b -> Property c

-- | Combines the values from the first source to the current value of the
--   second source
combineWithLatestOfP :: PropertySource s1 => PropertySource s2 => (a -> b -> c) -> s1 a -> s2 b -> Property c
constantP :: a -> Property a
fromEventSource :: EventSource s => s a -> IO (Property a)
fromEventSourceWithStartValue :: EventSource s => Maybe a -> s a -> IO (Property a)
newPushProperty :: IO (Property a, a -> IO ())
instance Observable Property
instance (Show a, Eq a, Num a) => Num (Property a)
instance Eq a => Eq (Property a)
instance Show a => Show (Property a)
instance Applicative Property
instance Functor Property

module Reactive.Bacon.EventStream.Combinators
mergeE :: EventSource s1 => EventSource s2 => s1 a -> s2 a -> IO (EventStream a)
takeUntilE :: EventSource s1 => EventSource s2 => s1 a -> s2 b -> IO (EventStream b)
eitherE :: EventSource s1 => EventSource s2 => s1 a -> s2 b -> IO (EventStream (Either a b))
combineLatestE :: EventSource s1 => EventSource s2 => s1 a -> s2 b -> IO (EventStream (a, b))
instance Eq a => Eq (EventStream a)
instance Show a => Show (EventStream a)

module Reactive.Bacon.EventStream.Monadic
flatMapE :: EventSource s => (a -> IO (EventStream b)) -> s a -> IO (EventStream b)
switchE :: EventSource s => (a -> IO (EventStream b)) -> s a -> IO (EventStream b)

module Reactive.Bacon.EventStream.IO

-- | startProcess is a function whose params are <a>event sink</a> and
--   <a>stop sign</a>
fromStoppableProcess :: ((Event a -> IO ()) -> IO Bool -> IO ()) -> IO (EventStream a, IO ())
fromNonStoppableProcess :: ((Event a -> IO ()) -> IO ()) -> IO (EventStream a)
fromIO :: IO a -> IO (EventStream a)

module Reactive.Bacon.EventStream.Timed
laterE :: TimeDiff -> a -> IO (EventStream a)
periodicallyE :: TimeDiff -> a -> IO (EventStream a, Disposable)
sequentiallyE :: TimeDiff -> [a] -> IO (EventStream a)
timedE :: [(TimeDiff, a)] -> IO (EventStream a, Disposable)
delayE :: EventSource s => TimeDiff -> s a -> IO (EventStream a)
throttleE :: EventSource s => TimeDiff -> s a -> IO (EventStream a)
toMicros :: TimeDiff -> Int

-- | Milliseconds to TimeDiff
milliseconds :: Integral a => a -> TimeDiff

-- | Seconds to TimeDiff
seconds :: Integral a => a -> TimeDiff

module Reactive.Bacon
