-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deprecated: Use 'reducers'
--   
--   Deprecated: Use <a>reducers</a>
@package monoids
@version 0.3.2


-- | More easily understood aliases for <a>mappend</a> and <a>mempty</a>,
--   chosen for symmetry with Data.Monoid.Multiplicative
--   
--   <pre>
--   import Data.Monoid.Additive
--   </pre>
module Data.Monoid.Additive
plus :: Monoid m => m -> m -> m
zero :: Monoid m => m


-- | A <tt>c</tt>-<a>Reducer</a> is a <a>Monoid</a> with a canonical
--   mapping from <tt>c</tt> to the Monoid. This <a>unit</a> acts in many
--   ways like <a>return</a> for a <a>Monad</a> but is limited to a single
--   type.
module Data.Monoid.Reducer

-- | This type may be best read infix. A <tt>c <a>Reducer</a> m</tt> is a
--   <a>Monoid</a> <tt>m</tt> that maps values of type <tt>c</tt> through
--   <tt>unit</tt> to values of type <tt>m</tt>. A
--   <tt>c</tt>-<a>Reducer</a> may also supply operations which tack-on
--   another <tt>c</tt> to an existing <a>Monoid</a> <tt>m</tt> on the left
--   or right. These specialized reductions may be more efficient in some
--   scenarios and are used when appropriate by a <tt>Generator</tt>. The
--   names <a>cons</a> and <a>snoc</a> work by analogy to the synonymous
--   operations in the list monoid.
--   
--   This class deliberately avoids functional-dependencies, so that () can
--   be a <tt>c</tt>-Reducer for all <tt>c</tt>, and so many common
--   reducers can work over multiple types, for instance, First and Last
--   may reduce both <tt>a</tt> and <a>Maybe</a> <tt>a</tt>. Since a
--   <tt>Generator</tt> has a fixed element type, the input to the reducer
--   is generally known and extracting from the monoid usually is
--   sufficient to fix the result type. Combinators are available for most
--   scenarios where this is not the case, and the few remaining cases can
--   be handled by using an explicit type annotation.
--   
--   Minimal definition: <a>unit</a> or <a>snoc</a>
class Monoid m => Reducer c m where unit = snoc mempty snoc m = mappend m . unit cons = mappend . unit
unit :: Reducer c m => c -> m
snoc :: Reducer c m => m -> c -> m
cons :: Reducer c m => c -> m -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> container, after mapping
--   the contents into a suitable form for reduction.
foldMapReduce :: (Foldable f, e Reducer m) => (a -> e) -> f a -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> mapping each element
--   through <a>unit</a>
foldReduce :: (Foldable f, e Reducer m) => f e -> m
pureUnit :: (Applicative f, c Reducer n) => c -> f n
returnUnit :: (Monad m, c Reducer n) => c -> m n
instance Reducer a (Last a)
instance Reducer (Maybe a) (Last a)
instance Reducer a (First a)
instance Reducer (Maybe a) (First a)
instance Num a => Reducer a (Product a)
instance Num a => Reducer a (Sum a)
instance Monoid a => Reducer a (Dual a)
instance Reducer (a -> a) (Endo a)
instance Reducer Bool All
instance Reducer Bool Any
instance Reducer c ()
instance Reducer c [c]
instance (Reducer c m, Reducer c n, Reducer c o, Reducer c p) => Reducer c (m, n, o, p)
instance (Reducer c m, Reducer c n, Reducer c o) => Reducer c (m, n, o)
instance (Reducer c m, Reducer c n) => Reducer c (m, n)


-- | A simple <a>Monoid</a> transformer that takes a <a>Monoid</a> m and
--   produces a new <tt>m</tt>-Reducer named <a>Self</a> <tt>m</tt>
--   
--   This is useful when you have a generator that already contains
--   monoidal values or someone supplies the map to the monoid in the form
--   of a function rather than as a <a>Reducer</a> instance. You can just
--   <tt><a>getSelf</a> . <tt>reduce</tt></tt> or <tt><a>getSelf</a> .
--   <tt>mapReduce</tt> f</tt> in those scenarios. These behaviors are
--   encapsulated into the <tt>fold</tt> and <tt>foldMap</tt> combinators
--   in <a>Data.Monoid.Combinators</a> respectively.
module Data.Monoid.Self
newtype Self m
Self :: m -> Self m
getSelf :: Self m -> m
instance Monoid m => Monoid (Self m)
instance Functor Self
instance Monoid m => Reducer m (Self m)


-- | Utilities for working with Monoids that conflict with names from the
--   <a>Prelude</a>, <a>Data.Foldable</a>, <a>Control.Monad</a> or
--   elsewhere. Intended to be imported qualified.
--   
--   <pre>
--   import Data.Monoid.Combinators as Monoid 
--   </pre>
module Data.Monoid.Combinators

-- | A generalization of <a>repeat</a> to an arbitrary <a>Monoid</a>. May
--   fail to terminate for some values in some monoids.
repeat :: e Reducer m => e -> m

-- | A generalization of <a>replicate</a> to an arbitrary <a>Monoid</a>.
--   Adapted from
--   <a>http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html</a>
replicate :: (Monoid m, Integral n) => m -> n -> m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Monoid</a>. May
--   fail to terminate for some values in some monoids.
cycle :: Monoid m => m -> m

module Data.Monoid.Ord

-- | The <a>Monoid</a> <tt>(<a>max</a>,<a>minBound</a>)</tt>
newtype Max a
Max :: a -> Max a
getMax :: Max a -> a

-- | The <a>Monoid</a> given by <tt>(<a>min</a>,<a>maxBound</a>)</tt>
newtype Min a
Min :: a -> Min a
getMin :: Min a -> a

-- | The <a>Monoid</a> <tt>(<a>max</a>,<a>Nothing</a>)</tt> over
--   <tt><a>Maybe</a> a</tt> where <a>Nothing</a> is the bottom element
newtype MaxPriority a
MaxPriority :: Maybe a -> MaxPriority a
getMaxPriority :: MaxPriority a -> Maybe a
minfinity :: MaxPriority a

-- | The <a>Monoid</a> <tt>(<a>min</a>,<a>Nothing</a>)</tt> over
--   <tt><a>Maybe</a> a</tt> where <a>Nothing</a> is the top element
newtype MinPriority a
MinPriority :: Maybe a -> MinPriority a
getMinPriority :: MinPriority a -> Maybe a
infinity :: MinPriority a
instance Eq a => Eq (Max a)
instance Ord a => Ord (Max a)
instance Show a => Show (Max a)
instance Read a => Read (Max a)
instance Bounded a => Bounded (Max a)
instance Eq a => Eq (Min a)
instance Ord a => Ord (Min a)
instance Show a => Show (Min a)
instance Read a => Read (Min a)
instance Bounded a => Bounded (Min a)
instance Eq a => Eq (MaxPriority a)
instance Ord a => Ord (MaxPriority a)
instance Show a => Show (MaxPriority a)
instance Read a => Read (MaxPriority a)
instance Eq a => Eq (MinPriority a)
instance Show a => Show (MinPriority a)
instance Read a => Read (MinPriority a)
instance Functor MinPriority
instance Ord a => Reducer (Maybe a) (MinPriority a)
instance Ord a => Monoid (MinPriority a)
instance Ord a => Ord (MinPriority a)
instance Functor MaxPriority
instance Ord a => Reducer (Maybe a) (MaxPriority a)
instance Ord a => Monoid (MaxPriority a)
instance Functor Min
instance (Ord a, Bounded a) => Reducer a (Min a)
instance (Ord a, Bounded a) => Monoid (Min a)
instance Functor Max
instance (Ord a, Bounded a) => Reducer a (Max a)
instance (Ord a, Bounded a) => Monoid (Max a)

module Data.Monoid.Union

-- | A Container suitable for the <a>Union</a> <a>Monoid</a>
class HasUnion f
empty :: HasUnion f => f
union :: HasUnion f => f -> f -> f

-- | The <a>Monoid</a> <tt>(<a>union</a>,<a>empty</a>)</tt>
newtype Union f
Union :: f -> Union f
getUnion :: Union f -> f

-- | Polymorphic containers that we can supply an operation to handle
--   unions with
class Functor f => HasUnionWith f
unionWith :: HasUnionWith f => (a -> a -> a) -> f a -> f a -> f a
emptyWith :: HasUnionWith f => f a

-- | The <a>Monoid</a> <tt>('unionWith mappend',<a>empty</a>)</tt> for
--   containers full of monoids.
newtype UnionWith f m
UnionWith :: f m -> UnionWith f m
getUnionWith :: UnionWith f m -> f m
instance Eq f => Eq (Union f)
instance Ord f => Ord (Union f)
instance Show f => Show (Union f)
instance Read f => Read (Union f)
instance Eq (f m) => Eq (UnionWith f m)
instance Ord (f m) => Ord (UnionWith f m)
instance Show (f m) => Show (UnionWith f m)
instance Read (f m) => Read (UnionWith f m)
instance Functor f => Functor (UnionWith f)
instance Monad f => Monad (UnionWith f)
instance (HasUnionWith f, Monoid m) => Reducer (f m) (UnionWith f m)
instance (HasUnionWith f, Monoid m) => Monoid (UnionWith f m)
instance Ord k => HasUnionWith (Map k)
instance HasUnionWith IntMap
instance Functor Union
instance HasUnion f => Reducer f (Union f)
instance HasUnion f => Monoid (Union f)
instance HasUnion IntSet
instance Ord a => HasUnion (Set a)
instance Eq a => HasUnion [a]
instance Ord k => HasUnion (Map k a)
instance HasUnion (IntMap a)


-- | A <a>Generator</a> <tt>c</tt> is a possibly-specialized container,
--   which contains values of type <a>Elem</a> <tt>c</tt>, and which knows
--   how to efficiently apply a <a>Reducer</a> to extract an answer.
--   
--   Since a <a>Generator</a> is not polymorphic in its contents, it is
--   more specialized than <a>Data.Foldable.Foldable</a>, and a
--   <a>Reducer</a> may supply efficient left-to-right and right-to-left
--   reduction strategies that a <a>Generator</a> may avail itself of.
module Data.Generator

-- | minimal definition <a>mapReduce</a> or <a>mapTo</a>
class Generator c where type family Elem c :: * mapReduce f = mapTo f mempty mapTo f m = mappend m . mapReduce f mapFrom f = mappend . mapReduce f
mapReduce :: (Generator c, e Reducer m) => (Elem c -> e) -> c -> m
mapTo :: (Generator c, e Reducer m) => (Elem c -> e) -> m -> c -> m
mapFrom :: (Generator c, e Reducer m) => (Elem c -> e) -> c -> m -> m

-- | a <a>Generator</a> transformer that asks only for the keys of an
--   indexed container
newtype Keys c
Keys :: c -> Keys c
getKeys :: Keys c -> c

-- | a <a>Generator</a> transformer that asks only for the values contained
--   in an indexed container
newtype Values c
Values :: c -> Values c
getValues :: Values c -> c

-- | a <a>Generator</a> transformer that treats <a>Word8</a> as <a>Char</a>
--   This lets you use a <tt>ByteString</tt> as a <a>Char</a> source
--   without going through a <a>Monoid</a> transformer like <tt>UTF8</tt>
newtype Char8 c
Char8 :: c -> Char8 c
getChar8 :: Char8 c -> c

-- | Apply a <a>Reducer</a> directly to the elements of a <a>Generator</a>
reduce :: (Generator c, Elem c Reducer m) => c -> m
mapReduceWith :: (Generator c, e Reducer m) => (m -> n) -> (Elem c -> e) -> c -> n
reduceWith :: (Generator c, Elem c Reducer m) => (m -> n) -> c -> n
instance Generator (Char8 ByteString)
instance Generator (Char8 ByteString)
instance Ix i => Generator (Values (Array i e))
instance Generator (Values (Map k v))
instance Generator (Values (IntMap v))
instance Ix i => Generator (Keys (Array i e))
instance Generator (Keys (Map k v))
instance Generator (Keys (IntMap v))
instance Ix i => Generator (Array i e)
instance Generator (Map k v)
instance Generator (IntMap v)
instance Generator (Set a)
instance Generator IntSet
instance Generator (Seq c)
instance Measured v e => Generator (FingerTree v e)
instance Generator [c]
instance Generator Text
instance Generator ByteString
instance Generator ByteString


-- | When dealing with a <tt>Ring</tt> or other structure, you often need a
--   pair of <a>Monoid</a> instances that are closely related. Making a
--   <tt>newtype</tt> for one is unsatisfying and yields an unnatural
--   programming style.
--   
--   A <a>Multiplicative</a> is a <a>Monoid</a> that is intended for use in
--   a scenario that can be extended to have another <a>Monoid</a> slot in
--   for addition. This enables one to use common notation.
--   
--   Any <a>Multiplicative</a> can be turned into a <a>Monoid</a> using the
--   <a>Log</a> wrapper.
--   
--   Any <a>Monoid</a> can be turned into a <a>Multiplicative</a> using the
--   <a>Exp</a> wrapper.
--   
--   Instances are supplied for common Monads of Monoids, in a fashion
--   which can be extended if the <a>Monad</a> is a <tt>MonadPlus</tt> to
--   yield a <tt>RightSemiNearRing</tt>
--   
--   Instances are also supplied for common Applicatives of Monoids, in a
--   fashion which can be extended if the <a>Applicative</a> is
--   <a>Alternative</a> to yield a <tt>RightSemiNearRing</tt>
module Data.Monoid.Multiplicative
class Multiplicative m
one :: Multiplicative m => m
times :: Multiplicative m => m -> m -> m

-- | Convert a <a>Multiplicative</a> into a <a>Monoid</a>. Mnemonic:
--   <tt>Log a + Log b = Log (a * b)</tt>
data Log m
Log :: m -> Log m
getLog :: Log m -> m

-- | Convert a <a>Monoid</a> into a <a>Multiplicative</a>. Mnemonic:
--   <tt>Exp a * Exp b = Exp (a + b)</tt>
data Exp m
Exp :: m -> Exp m
getExp :: Exp m -> m
instance (Measured v m, Monoid m) => Multiplicative (FingerTree v m)
instance Monoid m => Multiplicative (Seq m)
instance Integral m => Multiplicative (Ratio m)
instance Multiplicative Integer
instance Multiplicative Int
instance Monoid m => Multiplicative (Const m a)
instance Monoid n => Multiplicative (ZipList n)
instance Monoid n => Multiplicative (IO n)
instance Monoid m => Multiplicative (Maybe m)
instance Monoid m => Multiplicative [m]
instance Multiplicative m => Multiplicative (Self m)
instance Monoid m => Multiplicative (Exp m)
instance Multiplicative m => Monoid (Log m)
instance Multiplicative m => Multiplicative (Dual m)


-- | Extends <a>Monoid</a> to support <a>Group</a> operations
module Data.Group

-- | Minimal complete definition: <a>gnegate</a> or <a>minus</a>
class Monoid a => Group a where gnegate = minus zero a minus b = a `plus` gnegate b a gsubtract b = gnegate a `plus` b
gnegate :: Group a => a -> a
minus :: Group a => a -> a -> a
gsubtract :: Group a => a -> a -> a

-- | Minimal definition over or grecip
class Multiplicative g => MultiplicativeGroup g where x under y = grecip x `times` y x over y = x `times` grecip y grecip x = one `over` x
over :: MultiplicativeGroup g => g -> g -> g
under :: MultiplicativeGroup g => g -> g -> g
grecip :: MultiplicativeGroup g => g -> g
instance MultiplicativeGroup a => MultiplicativeGroup (Dual a)
instance MultiplicativeGroup g => MultiplicativeGroup (Self g)
instance Group g => MultiplicativeGroup (Exp g)
instance MultiplicativeGroup g => Group (Log g)
instance Group a => Group (Self a)
instance Group a => Group (Dual a)
instance Fractional a => Group (Product a)
instance Num a => Group (Sum a)


-- | Monoids for working with an <a>Applicative</a> <a>Functor</a>.
module Data.Monoid.Applicative

-- | A <a>Traversal</a> uses an glues together <a>Applicative</a> actions
--   with (*&gt;) in the manner of <tt>traverse_</tt> from
--   <a>Data.Foldable</a>. Any values returned by reduced actions are
--   discarded.
newtype Traversal f
Traversal :: f () -> Traversal f
getTraversal :: Traversal f -> f ()

-- | A <a>Alt</a> turns any <a>Alternative</a> instance into a
--   <a>Monoid</a>. It also provides a <a>Multiplicative</a> instance for
--   an <a>Applicative</a> functor wrapped around a <a>Monoid</a> and
--   asserts that any <a>Alternative</a> applied to a <a>Monoid</a> forms a
--   <tt>RightSemiNearRing</tt> under these operations.
newtype Alt f a
Alt :: f a -> Alt f a
getAlt :: Alt f a -> f a

-- | if <tt>m</tt> is a <tt>Module</tt> over <tt>r</tt> and <tt>f</tt> is a
--   <a>Applicative</a> then <tt>f <a>App</a> m</tt> is a <tt>Module</tt>
--   over <tt>r</tt> as well
newtype App f m
App :: f m -> App f m
getApp :: App f m -> f m

-- | Efficiently avoid needlessly rebinding when using <a>snoc</a> on an
--   action that already returns () A rewrite rule automatically applies
--   this when possible
snocTraversal :: Reducer (f ()) (Traversal f) => Traversal f -> f () -> Traversal f
instance Eq (f a) => Eq (Alt f a)
instance Ord (f a) => Ord (Alt f a)
instance Show (f a) => Show (Alt f a)
instance Read (f a) => Read (Alt f a)
instance Functor f => Functor (Alt f)
instance Applicative f => Applicative (Alt f)
instance Alternative f => Alternative (Alt f)
instance Eq (f m) => Eq (App f m)
instance Ord (f m) => Ord (App f m)
instance Show (f m) => Show (App f m)
instance Read (f m) => Read (App f m)
instance Functor f => Functor (App f)
instance Applicative f => Applicative (App f)
instance Alternative f => Alternative (App f)
instance (Reducer c m, Applicative f) => Reducer c (App f m)
instance (Group m, Applicative f) => Group (App f m)
instance (Monoid m, Applicative f) => Monoid (App f m)
instance Alternative f => Reducer (f a) (Alt f a)
instance (Applicative f, Monoid a) => Multiplicative (Alt f a)
instance Alternative f => Monoid (Alt f a)
instance Applicative f => Reducer (f a) (Traversal f)
instance Applicative f => Monoid (Traversal f)


-- | <a>Monoid</a> instances for working with a <a>Monad</a>
module Data.Monoid.Monad

-- | An <a>Action</a> uses glues together <a>Monad</a> actions with
--   (&gt;&gt;) in the manner of <a>mapM_</a> from <a>Data.Foldable</a>.
--   Any values returned by reduced actions are discarded.
newtype Action m
Action :: m () -> Action m
getAction :: Action m -> m ()

-- | Efficiently avoid needlessly rebinding when using <a>snoc</a> on an
--   action that already returns () A rewrite rule automatically applies
--   this when possible
snocAction :: Reducer (m ()) (Action m) => Action m -> m () -> Action m

-- | A <a>MonadSum</a> turns any <a>MonadPlus</a> instance into a
--   <a>Monoid</a>. It also provides a <a>Multiplicative</a> instance for a
--   <a>Monad</a> wrapped around a <a>Monoid</a> and asserts that any
--   <a>MonadPlus</a> applied to a <a>Monoid</a> forms a
--   <tt>RightSemiNearRing</tt> under these operations.
newtype MonadSum m a
MonadSum :: m a -> MonadSum m a
getMonadSum :: MonadSum m a -> m a

-- | if <tt>m</tt> is a <tt>Module</tt> over <tt>r</tt> and <tt>f</tt> is a
--   <a>Monad</a> then <tt>f <a>Mon</a> m</tt> is a <tt>Module</tt> as well
newtype Mon f m
Mon :: f m -> Mon f m
getMon :: Mon f m -> f m
instance Eq (m a) => Eq (MonadSum m a)
instance Ord (m a) => Ord (MonadSum m a)
instance Show (m a) => Show (MonadSum m a)
instance Read (m a) => Read (MonadSum m a)
instance Monad m => Monad (MonadSum m)
instance MonadPlus m => MonadPlus (MonadSum m)
instance Eq (f m) => Eq (Mon f m)
instance Ord (f m) => Ord (Mon f m)
instance Show (f m) => Show (Mon f m)
instance Read (f m) => Read (Mon f m)
instance Functor f => Functor (Mon f)
instance Monad f => Monad (Mon f)
instance MonadPlus f => MonadPlus (Mon f)
instance (Reducer c m, Monad f) => Reducer c (Mon f m)
instance (Group m, Monad f) => Group (Mon f m)
instance (Monoid m, Monad f) => Monoid (Mon f m)
instance MonadPlus m => Reducer (m a) (MonadSum m a)
instance Monad m => Applicative (MonadSum m)
instance Monad m => Functor (MonadSum m)
instance (Monad m, Monoid a) => Multiplicative (MonadSum m a)
instance MonadPlus m => Monoid (MonadSum m a)
instance Monad m => Reducer (m a) (Action m)
instance Monad m => Monoid (Action m)


-- | Utilities for working with Monoids that conflict with names from the
--   <a>Prelude</a>, <a>Data.Foldable</a>, <a>Control.Monad</a> or
--   elsewhere. Intended to be imported qualified.
--   
--   <pre>
--   import Data.Generator.Combinators as Generator
--   </pre>
module Data.Generator.Combinators

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Action</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a> and <a>Control.Monad</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAction</a>
--   </pre>
mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()

-- | Convenience function as found in <a>Data.Foldable</a> and
--   <a>Control.Monad</a>
--   
--   <pre>
--   <a>flip</a> <a>mapM_</a>
--   </pre>
forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getMonadSum</a>
--   </pre>
msum :: (Generator c, MonadPlus m, m a ~ Elem c) => c -> m a

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Traversal</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduce</a> <a>getTraversal</a>
--   </pre>
traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()

-- | Convenience function as found in <a>Data.Foldable</a>
--   
--   <pre>
--   <a>flip</a> <a>traverse_</a>
--   </pre>
for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAlt</a>
--   </pre>
asum :: (Generator c, Alternative f, f a ~ Elem c) => c -> f a

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAll</a>
--   </pre>
and :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAny</a>
--   </pre>
or :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   any of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAny</a>
--   </pre>
any :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   all of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAll</a>
--   </pre>
all :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the <a>Self</a>
--   monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getSelf</a>
--   </pre>
foldMap :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m

-- | Efficiently <a>reduce</a> a <a>Generator</a> using the <a>Self</a>
--   monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getSelf</a>
--   </pre>
fold :: (Monoid m, Generator c, Elem c ~ m) => c -> m

-- | Convert any <a>Generator</a> to a list of its contents. Specialization
--   of <a>reduce</a>
toList :: Generator c => c -> [Elem c]

-- | Type specialization of <a>foldMap</a> above
concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]

-- | Check to see if <a>any</a> member of the <a>Generator</a> matches the
--   supplied value
elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool

-- | Efficiently <a>mapReduce</a> a subset of the elements in a
--   <a>Generator</a>
filter :: (Generator c, Elem c Reducer m) => (Elem c -> Bool) -> c -> m

-- | Allows idiomatic specialization of filter by proving a function that
--   will be used to transform the output
filterWith :: (Generator c, Elem c Reducer m) => (m -> n) -> (Elem c -> Bool) -> c -> n

-- | A specialization of <a>filter</a> using the <a>First</a>
--   <a>Monoid</a>, analogous to <a>find</a>
--   
--   <pre>
--   <a>filterWith</a> <a>getFirst</a>
--   </pre>
find :: Generator c => (Elem c -> Bool) -> c -> Maybe (Elem c)

-- | Efficiently sum over the members of any <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getSum</a>
--   </pre>
sum :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Efficiently take the product of every member of a <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getProduct</a>
--   </pre>
product :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Check to make sure that the supplied value is not a member of the
--   <a>Generator</a>
notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool


-- | Utilities for working with Groups that conflict with names from the
--   <a>Prelude</a>.
--   
--   Intended to be imported qualified.
--   
--   <pre>
--   import Data.Group.Combinators as Group (replicate)
--   </pre>
module Data.Group.Combinators
replicate :: (Group m, Integral n) => m -> n -> m


-- | Syntactic sugar for working with a <a>Monoid</a> and
--   <a>Multiplicative</a> instances that conflicts with names from the
--   <a>Prelude</a>.
--   
--   <pre>
--   import Prelude hiding ((+),(*),(^))
--   import Data.Monoid.Sugar
--   </pre>
module Data.Monoid.Sugar
(+) :: Monoid m => m -> m -> m
(*) :: Multiplicative r => r -> r -> r
(^) :: (Multiplicative r, Integral b) => r -> b -> r


-- | Syntactic sugar for working with groups that conflicts with names from
--   the <a>Prelude</a>.
--   
--   <pre>
--   import Prelude hiding ((-), (+), (*), (/), (^), (^^), negate, subtract, recip)
--   import Data.Group.Sugar
--   </pre>
module Data.Group.Sugar
(-) :: Group g => g -> g -> g
negate :: Group g => g -> g
subtract :: Group g => g -> g -> g
(/) :: MultiplicativeGroup g => g -> g -> g
(.\.) :: MultiplicativeGroup g => g -> g -> g
(^^) :: MultiplicativeGroup g => g -> Integer -> g
recip :: MultiplicativeGroup g => g -> g
