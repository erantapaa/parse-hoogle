-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Lindenmayer Systems
--   
@package hls
@version 0.15


-- | Standard <a>Turtle</a> graphics.
module LSystem.Turtle

-- | Turtle.
data Turtle
Turtle :: Double -> Double -> Pt Double -> Double -> Double -> Double -> [Turtle] -> Turtle

-- | turning angle
ta :: Turtle -> Double

-- | turning angle increment
tai :: Turtle -> Double

-- | location
loc :: Turtle -> Pt Double

-- | heading
hdg :: Turtle -> Double

-- | line length
ll :: Turtle -> Double

-- | line length scalar
lls :: Turtle -> Double

-- | turtle stack
stk :: Turtle -> [Turtle]

-- | Right turn by <a>ta</a>.
turnRight :: Turtle -> Turtle

-- | Left turn by <a>ta</a>.
turnLeft :: Turtle -> Turtle

-- | <tt>180</tt> degree turn.
turnBack :: Turtle -> Turtle

-- | Increment line length (<a>ll</a>) by multiplying by line length scalar
--   (<a>lls</a>).
incrLine :: Turtle -> Turtle

-- | Decrement line length (<a>ll</a>) by dividing by line length scalar
--   (<a>lls</a>).
decrLine :: Turtle -> Turtle

-- | Move <a>loc</a> of <a>Turtle</a> by <a>ll</a> on current <a>hdg</a>.
forward :: Turtle -> Turtle

-- | Push <a>Turtle</a> onto <a>stk</a>.
push :: Turtle -> Turtle

-- | Fetch <a>Turtle</a> from <a>stk</a>.
pop :: Turtle -> Turtle

-- | Given state processing function <i>f</i>, a <a>Turtle</a> and an
--   initial state, step <a>Turtle</a> and state.
stepTurtle :: (t -> Pt R -> Pt R -> b) -> Turtle -> t -> (Turtle, b)


-- | Lindenmayer system definition, expander and renderer.
module LSystem.LSystem

-- | Element of <a>Axiom</a>.
type Element = Char

-- | An axiom (sequence of <tt>Elements</tt>).
type Axiom = [Element]

-- | A <a>Map</a> from <a>Element</a>s to <a>Axiom</a>s.
type Rules = Map Element Axiom

-- | An <a>LSystem</a> is an <a>Axiom</a> and a set of <a>Rules</a>.
data LSystem
LSystem :: Axiom -> Rules -> LSystem

-- | L-System constructor.
--   
--   <pre>
--   lSystem "F+F+F" [('F',"F-F+F")]
--   </pre>
lSystem :: Axiom -> [(Element, [Element])] -> LSystem

-- | Rule lookup.
getRule :: Rules -> Element -> [Element]

-- | Rule application.
applyRule :: [Element] -> Rules -> [Element]

-- | <i>n</i> iterations of the specified <a>LSystem</a>.
--   
--   <pre>
--   let f p q n = expand (lSystem p q) n
--   f  "A" [('A',"AB"),('B',"A")] 5 == "ABAABABAABAAB"
--   f "0" [('1',"11"),('0',"1[0]0")] 3 == "1111[11[1[0]0]1[0]0]11[1[0]0]1[0]0"
--   f  "A" [('A',"ABA"),('B',"BBB")] 3 == "ABABBBABABBBBBBBBBABABBBABA"
--   f  "F" [('F',"F+F-F-F+F")] 2 == "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
--   f "F+F+F" [('F',"F-F+F")] 1 == "F-F+F+F-F+F+F-F+F"
--   </pre>
expand :: LSystem -> Int -> [Element]

-- | State transformer <a>Turtle</a> commands.
stateT :: Element -> Turtle -> Turtle

-- | Operational <a>Turtle</a> commands.
cmd :: (Turtle -> b -> (Turtle, b)) -> Element -> Turtle -> b -> (Turtle, b)

-- | Fold over an expanded L-system using standard turtle commands.
render :: b -> (b -> Pt R -> Pt R -> b) -> [Element] -> Turtle -> b
instance Eq LSystem
instance Show LSystem


-- | Postscript renderer for <a>LSystem</a>s.
module LSystem.Render.PS

-- | Given initial <a>ta</a>, <a>ls</a> and <a>lls</a> values render
--   <i>i</i> steps of an <a>LSystem</a>.
renderL :: (LSystem, Double, Double) -> Int -> Double -> [Ln R]

-- | Draw output of <a>renderL</a> normalised, scaled to <i>m</i> and
--   translated by <i>o</i>.
draw :: R -> R -> [Ln R] -> Image


-- | Various <a>LSystem</a>s. For <a>l0</a> through <a>lB</a> see
--   <a>http://paulbourke.net/fractals/lsys/</a>. For <a>lC</a> see
--   <a>http://en.wikipedia.org/wiki/Penrose_tiling</a>. For <a>lD</a> see
--   <a>http://hackage.haskell.org/package/nymphaea</a>. For <tt>p0</tt>
--   etc. see <a>http://algorithmicbotany.org/papers/#abop</a>.
module LSystem.Systems
l0 :: LSystem
lB :: LSystem
lA :: LSystem
l9 :: LSystem
l8 :: LSystem
l7 :: LSystem
l6 :: LSystem
l5 :: LSystem
l4 :: LSystem
l3 :: LSystem
l2 :: LSystem
l1 :: LSystem
lC :: LSystem
lD :: LSystem
p00 :: LSystem
p01 :: LSystem
p02 :: LSystem
p03 :: LSystem
p04 :: LSystem
p05 :: LSystem
p00d :: (LSystem, Double, Double)
p01d :: (LSystem, Double, Double)
p02d :: (LSystem, Double, Double)
p03d :: (LSystem, Double, Double)
p04d :: (LSystem, Double, Double)
p05d :: (LSystem, Double, Double)
p00l_a :: [Ln R]
p00l_b :: [Ln R]
p00l_c :: [Ln R]
p00l_d :: [Ln R]
p01l :: [Ln R]
p02l :: [Ln R]
p03l :: [Ln R]
p04l :: [Ln R]
p05l :: [Ln R]
l0d :: (LSystem, Double, Double)
lDd :: (LSystem, Double, Double)
lCd :: (LSystem, Double, Double)
lBd :: (LSystem, Double, Double)
lAd :: (LSystem, Double, Double)
l9d :: (LSystem, Double, Double)
l8d :: (LSystem, Double, Double)
l7d :: (LSystem, Double, Double)
l6d :: (LSystem, Double, Double)
l5d :: (LSystem, Double, Double)
l4d :: (LSystem, Double, Double)
l3d :: (LSystem, Double, Double)
l2d :: (LSystem, Double, Double)
l1d :: (LSystem, Double, Double)
l0l :: [Ln R]
lDl :: [Ln R]
lCl :: [Ln R]
lBl :: [Ln R]
lAl :: [Ln R]
l9l :: [Ln R]
l8l :: [Ln R]
l7l :: [Ln R]
l6l :: [Ln R]
l5l :: [Ln R]
l4l :: [Ln R]
l3l :: [Ln R]
l2l :: [Ln R]
l1l :: [Ln R]
systems_l :: [[Ln R]]
systems_i :: [Image]

-- | Generate postscript file with drawings of <a>l0</a> through <a>lD</a>.
--   
--   <pre>
--   systems_ps "/tmp/hls.ps"
--   System.Process.system "gv /tmp/hls.ps"
--   </pre>
systems_ps :: FilePath -> IO ()
