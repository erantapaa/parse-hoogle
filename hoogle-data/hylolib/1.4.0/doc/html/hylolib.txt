-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tools for hybrid logics related programs
--   
--   Tools for hybrid logics related programs
@package hylolib
@version 1.4.0

module Data.EnumMap
data EnumMap a b
empty :: Enum a => EnumMap a b
insert :: Enum a => a -> b -> EnumMap a b -> EnumMap a b
insertWith :: Enum a => (b -> b -> b) -> a -> b -> EnumMap a b -> EnumMap a b
insertLookupWithKey :: Enum a => (a -> b -> b -> b) -> a -> b -> EnumMap a b -> (Maybe b, EnumMap a b)
delete :: Enum a => a -> EnumMap a b -> EnumMap a b
update :: Enum a => (b -> Maybe b) -> a -> EnumMap a b -> EnumMap a b
lookup :: Enum a => a -> EnumMap a b -> Maybe b
(!) :: Enum a => EnumMap a b -> a -> b
member :: Enum a => a -> EnumMap a b -> Bool
null :: EnumMap a b -> Bool
size :: EnumMap a b -> Int
elems :: EnumMap a b -> [b]
instance Eq b => Eq (EnumMap a b)
instance Ord b => Ord (EnumMap a b)
instance Foldable (EnumMap a)
instance Functor (EnumMap a)
instance Monoid (EnumMap a b)
instance (Typeable a, Typeable b) => Typeable (EnumMap a b)
instance Typeable a => Typeable1 (EnumMap a)
instance Typeable2 EnumMap
instance (Read a, Read b) => Read (EnumMap a b)
instance (Show a, Show b) => Show (EnumMap a b)

module Data.EnumSet
data EnumSet a
empty :: Enum a => EnumSet a
singleton :: Enum a => a -> EnumSet a
insert :: Enum a => a -> EnumSet a -> EnumSet a
delete :: Enum a => a -> EnumSet a -> EnumSet a
intersection :: Enum a => EnumSet a -> EnumSet a -> EnumSet a
union :: Enum a => EnumSet a -> EnumSet a -> EnumSet a
size :: EnumSet a -> Int
null :: EnumSet a -> Bool
toList :: Enum a => EnumSet a -> [a]
instance Eq (EnumSet a)
instance Ord (EnumSet a)
instance Monoid (EnumSet a)
instance Typeable a => Typeable (EnumSet a)
instance Typeable1 EnumSet
instance Read a => Read (EnumSet a)
instance Show a => Show (EnumSet a)

module HyLo.Util
sequenceUntil :: Monad m => (a -> Bool) -> [m a] -> m [a]

module Data.Map.Arbitrary
instance (Arbitrary k, Arbitrary v, Ord k) => Arbitrary (Map k v)

module Data.Set.Arbitrary
instance (Arbitrary a, Ord a) => Arbitrary (Set a)

module HyLo.Test
type ModuleName = String
type TestName = String
type TestCase = TestName -> Align -> IO TestResult
data TestResult
OK :: TestResult
EXHAUSTED :: TestResult
FAILED :: TestResult
type UnitTest = [(TestName, TestCase)]
runTest :: Testable a => a -> TestCase
runTestWith :: Testable a => Config -> a -> TestCase
data Config :: *
Config :: Int -> Int -> (Int -> Int) -> (Int -> [String] -> String) -> Config
configMaxTest :: Config -> Int
configMaxFail :: Config -> Int
configSize :: Config -> Int -> Int
configEvery :: Config -> Int -> [String] -> String
defaultConfig :: Config
testSuite :: [(ModuleName, UnitTest)] -> [IO TestResult]
testModule :: UnitTest -> [IO TestResult]
stopOnError :: ([a] -> [IO TestResult]) -> [a] -> IO [TestResult]
runCompletely :: ([a] -> [IO TestResult]) -> [a] -> IO [TestResult]
instance Eq TestResult
instance Show TestResult
instance Enum TestResult

module HyLo.Signature
data Signature n p r
emptySignature :: Signature n p r
buildSignature :: Set n -> Set p -> Set r -> Signature n p r
addNomToSig :: Ord n => n -> Signature n p r -> Signature n p r
delNomFromSig :: Ord n => n -> Signature n p r -> Signature n p r
addPropToSig :: Ord p => p -> Signature n p r -> Signature n p r
delPropFromSig :: Ord p => p -> Signature n p r -> Signature n p r
addRelToSig :: Ord r => r -> Signature n p r -> Signature n p r
delRelFromSig :: Ord r => r -> Signature n p r -> Signature n p r
isNomInSig :: Ord n => n -> Signature n p r -> Bool
isPropInSig :: Ord p => p -> Signature n p r -> Bool
isRelInSig :: Ord r => r -> Signature n p r -> Bool
merge :: (Ord n, Ord p, Ord r) => Signature n p r -> Signature n p r -> Signature n p r
commonSig :: (Ord n, Ord p, Ord r) => Signature n p r -> Signature n p r -> Signature n p r
relSymbols :: Signature n p r -> Set r
propSymbols :: Signature n p r -> Set p
nomSymbols :: Signature n p r -> Set n
isSubsignatureOf :: (Ord n, Ord p, Ord r) => Signature n p r -> Signature n p r -> Bool
class HasSignature a where type family NomsOf a :: * type family PropsOf a :: * type family RelsOf a :: *
getSignature :: HasSignature a => a -> Signature (NomsOf a) (PropsOf a) (RelsOf a)
unit_tests :: UnitTest
instance (Eq n, Eq p, Eq r) => Eq (Signature n p r)
instance (Ord n, Ord p, Ord r, Read n, Read p, Read r) => Read (Signature n p r)
instance (Show n, Show p, Show r) => Show (Signature n p r)
instance (Arbitrary n, Ord n, Arbitrary p, Ord p, Arbitrary r, Ord r) => Arbitrary (Signature n p r)
instance (Ord n, Ord p, Ord r) => Monoid (Signature n p r)
instance HasSignature (Signature n p r)

module HyLo.Signature.Simple
type SimpleSignature = Signature NomSymbol PropSymbol RelSymbol
newtype PropSymbol
PropSymbol :: Int -> PropSymbol
data NomSymbol
N :: Int -> NomSymbol
X :: Int -> NomSymbol
newtype RelSymbol
RelSymbol :: Int -> RelSymbol
unit_tests :: UnitTest
instance Eq PropSymbol
instance Ord PropSymbol
instance Enum PropSymbol
instance Arbitrary PropSymbol
instance Eq NomSymbol
instance Ord NomSymbol
instance Eq RelSymbol
instance Ord RelSymbol
instance Arbitrary RelSymbol
instance Arbitrary NomSymbol
instance Read RelSymbol
instance Show RelSymbol
instance Read NomSymbol
instance Show NomSymbol
instance Read PropSymbol
instance Show PropSymbol

module HyLo.InputFile.OldLexer
alexScanTokens :: String -> [(Token, FilePos)]
data Token
TokenBegin :: Token
TokenEnd :: Token
TokenTrue :: Token
TokenFalse :: Token
TokenProp :: PropSymbol -> Token
TokenNom :: NomSymbol -> Token
TokenVar :: NomSymbol -> Token
TokenNeg :: Token
TokenAnd :: Token
TokenOr :: Token
TokenAt :: Token
TokenAt2 :: Token
TokenDown :: Token
TokenBox :: RelSymbol -> Token
TokenDia :: RelSymbol -> Token
TokenIBox :: RelSymbol -> Token
TokenIDia :: RelSymbol -> Token
TokenImp :: Token
TokenDimp :: Token
TokenUBox :: Token
TokenUDia :: Token
TokenDBox :: Token
TokenDDia :: Token
TokenOB :: Token
TokenCB :: Token
TokenDot :: Token
TokenSC :: Token
data FilePos
line :: FilePos -> Int
col :: FilePos -> Int
instance Eq AlexPosn
instance Show AlexPosn
instance Eq Token
instance Show Token
instance Read Token
instance Eq FilePos
instance Show FilePos
instance Functor AlexLastAcc

module HyLo.Signature.String
type StringSignature = Signature NomSymbol PropSymbol RelSymbol
newtype PropSymbol
PropSymbol :: String -> PropSymbol
newtype NomSymbol
NomSymbol :: String -> NomSymbol
newtype RelSymbol
RelSymbol :: String -> RelSymbol
instance Eq PropSymbol
instance Ord PropSymbol
instance Show PropSymbol
instance Read PropSymbol
instance Eq NomSymbol
instance Ord NomSymbol
instance Show NomSymbol
instance Read NomSymbol
instance Eq RelSymbol
instance Ord RelSymbol
instance Show RelSymbol
instance Read RelSymbol

module HyLo.InputFile.Lexer
alexScanTokens :: String -> [(Token, FilePos)]
data Token
TokenSignature :: Token
TokenPropositions :: Token
TokenNominals :: Token
TokenRelations :: Token
TokenSubsetOf :: Token
TokenEquals :: Token
TokenInverseOf :: Token
TokenTClosureOf :: Token
TokenTRClosureOf :: Token
TokenReflexive :: Token
TokenTransitive :: Token
TokenSymmetric :: Token
TokenFunctional :: Token
TokenInjective :: Token
TokenUniversal :: Token
TokenDifference :: Token
TokenAutomatic :: Token
TokenProverParameters :: Token
TokenProver :: Token
TokenTheory :: Token
TokenQuery :: Token
TokenValid :: Token
TokenSatisfiable :: Token
TokenRetrieve :: Token
TokenCount :: Token
TokenOC :: Token
TokenCC :: Token
TokenEqual :: Token
TokenInteger :: Int -> Token
TokenVariable :: String -> Token
TokenLabel :: String -> Token
TokenFile :: String -> Token
TokenBegin :: Token
TokenEnd :: Token
TokenTrue :: Token
TokenFalse :: Token
TokenProp :: PropSymbol -> Token
TokenNom :: NomSymbol -> Token
TokenNeg :: Token
TokenAnd :: Token
TokenOr :: Token
TokenDown :: Token
TokenGE :: Token
TokenLE :: Token
TokenG :: Token
TokenL :: Token
TokenE :: Token
TokenNE :: Token
TokenBox :: RelSymbol -> Token
TokenDia :: RelSymbol -> Token
TokenIBox :: RelSymbol -> Token
TokenIDia :: RelSymbol -> Token
TokenImp :: Token
TokenDimp :: Token
TokenUBox :: Token
TokenUDia :: Token
TokenDBox :: Token
TokenDDia :: Token
TokenOB :: Token
TokenCB :: Token
TokenODia :: Token
TokenCDia :: Token
TokenOBox :: Token
TokenCBox :: Token
TokenDot :: Token
TokenSC :: Token
TokenColon :: Token
TokenComma :: Token
data FilePos
line :: FilePos -> Int
col :: FilePos -> Int
instance Eq AlexPosn
instance Show AlexPosn
instance Eq Token
instance Show Token
instance Eq FilePos
instance Show FilePos
instance Functor AlexLastAcc

module HyLo.Formula
data Formula n p r
Top :: Formula n p r
Bot :: Formula n p r
Prop :: p -> Formula n p r
Nom :: n -> Formula n p r
Neg :: (Formula n p r) -> Formula n p r
(:&:) :: (Formula n p r) -> (Formula n p r) -> Formula n p r
(:|:) :: (Formula n p r) -> (Formula n p r) -> Formula n p r
(:-->:) :: (Formula n p r) -> (Formula n p r) -> Formula n p r
(:<-->:) :: (Formula n p r) -> (Formula n p r) -> Formula n p r
Diam :: r -> (Formula n p r) -> Formula n p r
Box :: r -> (Formula n p r) -> Formula n p r
IDiam :: r -> (Formula n p r) -> Formula n p r
IBox :: r -> (Formula n p r) -> Formula n p r
At :: n -> (Formula n p r) -> Formula n p r
A :: (Formula n p r) -> Formula n p r
E :: (Formula n p r) -> Formula n p r
D :: (Formula n p r) -> Formula n p r
B :: (Formula n p r) -> Formula n p r
Down :: n -> (Formula n p r) -> Formula n p r
Count :: CountOp -> (Where r) -> Int -> (Formula n p r) -> Formula n p r
data Where r
Global :: Where r
Local :: r -> Where r
data CountOp
(:>=:) :: CountOp
(:<=:) :: CountOp
(:>:) :: CountOp
(:<:) :: CountOp
(:=:) :: CountOp
(:/=:) :: CountOp
negCount :: CountOp -> CountOp
nnf :: Formula n p r -> Formula n p r
composeFold :: b -> (b -> b -> b) -> (Formula n p r -> b) -> (Formula n p r -> b)
composeFoldM :: Monad m => m b -> (b -> b -> m b) -> (Formula n p r -> m b) -> (Formula n p r -> m b)
composeMap :: (Formula n p r -> Formula n p r) -> (Formula n p r -> Formula n p r) -> (Formula n p r -> Formula n p r)
composeMapM :: (Monad m, Functor m) => (Formula n p r -> m (Formula n p r)) -> (Formula n p r -> m (Formula n p r)) -> (Formula n p r -> m (Formula n p r))
onShape :: (n -> n') -> (p -> p') -> (r -> r') -> (Formula n p r -> Formula n' p' r') -> (Formula n p r -> Formula n' p' r')
mapSig :: (n -> n') -> (p -> p') -> (r -> r') -> Formula n p r -> Formula n' p' r'
freeVars :: Eq n => Formula n p r -> [n]
boundVars :: Eq n => Formula n p r -> [n]
compareWith :: CountOp -> Int -> Int -> Bool
cmpListLen :: CountOp -> [a] -> Int -> Bool
type TestFormula = Formula NomSymbol PropSymbol RelSymbol
metap_read_Formula :: (Show n, Read n, Eq n, Show p, Read p, Eq p, Show r, Read r, Eq r) => Formula n p r -> Bool
unit_tests :: UnitTest
instance Eq r => Eq (Where r)
instance Ord r => Ord (Where r)
instance Eq CountOp
instance Ord CountOp
instance (Eq n, Eq p, Eq r) => Eq (Formula n p r)
instance (Ord n, Ord p, Ord r) => Ord (Formula n p r)
instance (Arbitrary n, Arbitrary p, Arbitrary r) => Arbitrary (Formula n p r)
instance Arbitrary CountOp
instance Arbitrary r => Arbitrary (Where r)
instance (Read n, Read p, Read r) => Read (Formula n p r)
instance (Show n, Show p, Show r) => Show (Formula n p r)
instance (Ord n, Ord p, Ord r) => HasSignature (Formula n p r)
instance Uniplate (Formula n p r)
instance Read CountOp
instance Show CountOp

module HyLo.InputFile.OldParser
parse :: [(Token, FilePos)] -> [Formula NomSymbol PropSymbol RelSymbol]
instance Monad HappyIdentity

module HyLo.Model
data Model w n p r
worlds :: Model w n p r -> Set w
succs :: Model w n p r -> r -> w -> Set w
valP :: Model w n p r -> p -> Set w
valN :: Model w n p r -> n -> w
model :: (RelRepr rs r w, ValRepr ps p w, ValNomRepr ns n w) => Set w -> rs -> ps -> ns -> Signature n p r -> Model w n p r
equiv :: (Eq w, Eq n, Eq p, Eq r) => Model w n p r -> Model w n p r -> Bool
expand :: (Ord n, Ord p, Ord r) => Signature n p r -> Model w n p r -> Model w n p r
setSignature :: (Ord n, Ord p, Ord r) => Signature n p r -> Model w n p r -> Model w n p r
(??) :: Eq n => Model w n p r -> (n, w) -> Model w n p r
removeWorld :: Ord w => w -> Model w n p r -> Model w n p r
removeWorlds :: Ord w => Set w -> Model w n p r -> Model w n p r
countInModel :: (Ord w, Ord n, Ord p, Ord r) => Formula n p r -> Model w n p r -> Int
namesOf :: Eq w => w -> Model w n p r -> [n]
propsOf :: Ord w => w -> Model w n p r -> [p]
class ModelsRel m f n p r | m -> n, m -> p, m -> r, f -> n, f -> p, f -> r
(|=) :: ModelsRel m f n p r => m -> f -> Bool
(|/=) :: ModelsRel m f n p r => m -> f -> Bool
modelFor :: (HasSignature x, Ord (NomsOf x), Ord (RelsOf x), Ord (PropsOf x)) => x -> Gen (Model Int (NomsOf x) (PropsOf x) (RelsOf x))
worldOf :: Model w n p r -> Gen w
iff :: Bool -> Bool -> Bool
unit_tests :: UnitTest
instance (Ord w, Ord n, Ord p, Ord r, Arbitrary w, Arbitrary n, Arbitrary p, Arbitrary r) => Arbitrary (Model w n p r)
instance Ord n => ValNomRepr (Map n w, w) n w
instance Ord n => ValNomRepr (Map n w, n -> w) n w
instance ValNomRepr (n -> w) n w
instance (Ord w, Ord p, Foldable t) => ValRepr (t (p, w)) p w
instance (Ord w, Ord p) => ValRepr (Map p [w]) p w
instance (Ord w, Ord p) => ValRepr (Map p (Set w)) p w
instance Ord w => ValRepr (p -> [w]) p w
instance ValRepr (p -> Set w) p w
instance (Ord r, Ord w) => RelRepr (Set (w, r, w)) r w
instance (Ord r, Ord w) => RelRepr [(w, r, w)] r w
instance (Ord r, Ord w, Foldable t) => RelRepr (Map r (t (w, w))) r w
instance (Ord r, Ord w) => RelRepr (Map r (Map w (Set w))) r w
instance Ord w => RelRepr (r -> w -> [w]) r w
instance RelRepr (r -> w -> Set w) r w
instance (Ord w, Ord n, Ord p, Ord r) => ModelsRel (Model w n p r) (Formula n p r) n p r
instance (Ord w, Ord n, Ord p, Ord r) => ModelsRel (Model w n p r, w) (Formula n p r) n p r
instance (Read w, Read n, Read p, Read r, Ord w, Ord n, Ord p, Ord r) => Read (Model w n p r)
instance (Show w, Show n, Show p, Show r) => Show (Model w n p r)
instance HasSignature (Model w n p r)

module HyLo.Formula.Rewrite
data Rewr prop
Orig :: prop -> Rewr prop
Rewr :: Int -> Rewr prop
pnf :: Eq n => [Formula n p r] -> [Formula n (Rewr p) r]
simplify :: (Ord n, Ord p, Ord r) => Formula n p r -> Formula n p r
unit_tests :: UnitTest
instance Eq prop => Eq (Rewr prop)
instance Ord prop => Ord (Rewr prop)
instance Eq nom => Eq (BndInfo nom)
instance Ord nom => Ord (BndInfo nom)
instance Read nom => Read (BndInfo nom)
instance Show nom => Show (BndInfo nom)
instance Arbitrary prop => Arbitrary (Rewr prop)
instance Read prop => Read (Rewr prop)
instance Show prop => Show (Rewr prop)

module HyLo.InputFile.Parser
parse :: [(Token, FilePos)] -> State ParseState ParseOutput
initParseState :: (Signature n p r, SignatureType)
type ParseState = (StringSignature, SignatureType)
data QueryType
Valid :: QueryType
Satisfiable :: QueryType
Retrieve :: QueryType
Counting :: QueryType
data RelProperty
Reflexive :: RelProperty
Symmetric :: RelProperty
Transitive :: RelProperty
Functional :: RelProperty
Injective :: RelProperty
Universal :: RelProperty
Difference :: RelProperty
InverseOf :: String -> RelProperty
SubsetOf :: [String] -> RelProperty
Equals :: [String] -> RelProperty
TClosureOf :: String -> RelProperty
TRClosureOf :: String -> RelProperty
data ParseOutput
PO :: [RelInfo] -> [ProverInfo] -> [Formula NomSymbol PropSymbol RelSymbol] -> [InferenceTask] -> ParseOutput
relations :: ParseOutput -> [RelInfo]
provers :: ParseOutput -> [ProverInfo]
theory :: ParseOutput -> [Formula NomSymbol PropSymbol RelSymbol]
tasks :: ParseOutput -> [InferenceTask]
type RelInfo = (String, [RelProperty])
type ProverInfo = (String, [(String, String)])
type InferenceTask = (QueryType, Maybe String, [Formula NomSymbol PropSymbol RelSymbol])
instance Eq RelProperty
instance Show RelProperty
instance Ord RelProperty
instance Eq QueryType
instance Show QueryType
instance Show ParseOutput
instance Eq SignatureType

module HyLo.InputFile
type InputFile = [Formula NomSymbol PropSymbol RelSymbol]
parse :: String -> InputFile
myparse :: String -> ParseOutput
write :: (Show n, Show p, Show r) => [Formula n p r] -> String
parseOldFormat :: String -> OldInputFile
type OldInputFile = [Formula NomSymbol PropSymbol RelSymbol]

module HyLo.Model.Herbrand
data HerbrandModel n p r
herbrand :: (Ord n, Ord p, Ord r) => Set (n, n) -> Set (n, p) -> Set (n, r, n) -> HerbrandModel n p r
inducedModel :: (Ord r, Ord n, Ord p) => HerbrandModel n p r -> Model n n p r
expand :: (Ord n, Ord p, Ord r) => Signature n p r -> HerbrandModel n p r -> HerbrandModel n p r
removeWorld :: (Ord n, Ord p, Ord r) => n -> HerbrandModel n p r -> HerbrandModel n p r
unit_tests :: UnitTest
instance Show a => Show (MF a)
instance (Read n, Read p, Read r, Ord n, Ord p, Ord r) => Read (HerbrandModel n p r)
instance (Show n, Show p, Show r) => Show (HerbrandModel n p r)
instance (Arbitrary n, Arbitrary p, Arbitrary r, Ord n, Ord p, Ord r) => Arbitrary (HerbrandModel n p r)
instance (Ord r, Ord n, Ord p) => HasSignature (HerbrandModel n p r)
instance (Ord r, Ord n, Ord p, ModelsRel (Model n n p r) f n p r) => ModelsRel (HerbrandModel n p r) f n p r
instance (Ord r, Ord n, Ord p, ModelsRel (Model n n p r, n) f n p r) => ModelsRel (HerbrandModel n p r, n) f n p r

module HyLo.Model.PrettyPrint
toDot :: (Show w, Show n, Show p, Show r, Ord w) => Model w n p r -> String
toDotStr :: Model NomSymbol NomSymbol PropSymbol RelSymbol -> String
toDotFrame :: (Show w, Show n, Show p, Show r, Ord w) => Model w n p r -> String
