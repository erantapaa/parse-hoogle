-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A regular expression library for W3C XML Schema regular expressions
--   
--   This library supports full W3C XML Schema regular expressions
--   inclusive all Unicode character sets and blocks. The complete grammar
--   can be found under <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>.
--   It is implemented by the technique of derivations of regular
--   expressions. The W3C syntax is extended to support not only union of
--   regular sets, but also intersection, set difference, exor. Matching of
--   subexpressions is also supported. The library can be used for
--   constricting lightweight scanners and tokenizers. It is a standalone
--   library, no external regex libraries are used.
@package regex-xmlschema
@version 0.1.5


-- | Unicode Code Blocks
--   
--   don't edit this module it's generated from
--   'http:\/\/www.unicode.org\/Public\/UNIDATA\/Blocks.txt'
module Text.Regex.XMLSchema.String.Unicode.Blocks
codeBlocks :: [(String, (Char, Char))]


-- | Char sets implemeted as sorted lists of intervalls
module Text.Regex.XMLSchema.String.CharSet
type CharSet = [(Char, Char)]
emptyCS :: CharSet
allCS :: CharSet
singleCS :: Char -> CharSet
stringCS :: String -> CharSet
rangeCS :: Char -> Char -> CharSet
nullCS :: CharSet -> Bool
fullCS :: CharSet -> Bool
unionCS :: CharSet -> CharSet -> CharSet
diffCS :: CharSet -> CharSet -> CharSet
intersectCS :: CharSet -> CharSet -> CharSet
exorCS :: CharSet -> CharSet -> CharSet
compCS :: CharSet -> CharSet
elemCS :: Char -> CharSet -> Bool


-- | Unicode character properties
--   
--   don't edit this module it's generated from
--   'http:\/\/www.unicode.org\/Public\/UNIDATA\/UnicodeData.txt'
module Text.Regex.XMLSchema.String.Unicode.CharProps
isUnicodeC :: CharSet
isUnicodeCc :: CharSet
isUnicodeCf :: CharSet
isUnicodeCo :: CharSet
isUnicodeCs :: CharSet
isUnicodeL :: CharSet
isUnicodeLl :: CharSet
isUnicodeLm :: CharSet
isUnicodeLo :: CharSet
isUnicodeLt :: CharSet
isUnicodeLu :: CharSet
isUnicodeM :: CharSet
isUnicodeMc :: CharSet
isUnicodeMe :: CharSet
isUnicodeMn :: CharSet
isUnicodeN :: CharSet
isUnicodeNd :: CharSet
isUnicodeNl :: CharSet
isUnicodeNo :: CharSet
isUnicodeP :: CharSet
isUnicodePc :: CharSet
isUnicodePd :: CharSet
isUnicodePe :: CharSet
isUnicodePf :: CharSet
isUnicodePi :: CharSet
isUnicodePo :: CharSet
isUnicodePs :: CharSet
isUnicodeS :: CharSet
isUnicodeSc :: CharSet
isUnicodeSk :: CharSet
isUnicodeSm :: CharSet
isUnicodeSo :: CharSet
isUnicodeZ :: CharSet
isUnicodeZl :: CharSet
isUnicodeZp :: CharSet
isUnicodeZs :: CharSet


-- | XML character properties
module Text.Regex.XMLSchema.String.XML.CharProps

-- | checking for valid XML characters
isXmlChar :: CharSet

-- | checking for XML space character: \n, \r, \t and " "
isXmlSpaceChar :: CharSet

-- | checking for XML1.1 space character: additional space 0x85 and 0x2028
--   
--   see also : <a>isXmlSpaceChar</a>
isXml11SpaceChar :: CharSet

-- | checking for XML name character
isXmlNameChar :: CharSet

-- | checking for XML name start character
--   
--   see also : <a>isXmlNameChar</a>
isXmlNameStartChar :: CharSet

-- | checking for XML NCName character: no ":" allowed
--   
--   see also : <a>isXmlNameChar</a>
isXmlNCNameChar :: CharSet

-- | checking for XML NCName start character: no ":" allowed
--   
--   see also : <a>isXmlNameChar</a>, <a>isXmlNCNameChar</a>
isXmlNCNameStartChar :: CharSet

-- | checking for XML public id character
isXmlPubidChar :: CharSet

-- | checking for XML letter
isXmlLetter :: CharSet

-- | checking for XML base charater
isXmlBaseChar :: CharSet

-- | checking for XML ideographic charater
isXmlIdeographicChar :: CharSet

-- | checking for XML combining charater
isXmlCombiningChar :: CharSet

-- | checking for XML digit
isXmlDigit :: CharSet

-- | checking for XML extender
isXmlExtender :: CharSet

-- | checking for XML control or permanently discouraged char
--   
--   see Errata to XML1.0 (http://www.w3.org/XML/xml-V10-2e-errata) No 46
--   
--   Document authors are encouraged to avoid <a>compatibility
--   characters</a>, as defined in section 6.8 of [Unicode] (see also D21
--   in section 3.6 of [Unicode3]). The characters defined in the following
--   ranges are also discouraged. They are either control characters or
--   permanently undefined Unicode characters:
isXmlControlOrPermanentlyUndefined :: CharSet


-- | W3C XML Schema Regular Expression Matcher
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.String.Regex
type Regex = GenRegex String
data GenRegex l

-- | construct the r.e. for the empty set. An (error-) message may be
--   attached
mkZero :: String -> GenRegex l

-- | construct the r.e. for the set containing the empty word
mkUnit :: GenRegex l

-- | construct the r.e. for a set of chars
mkSym :: CharSet -> GenRegex l

-- | construct an r.e. for a single char set
mkSym1 :: Char -> GenRegex l

-- | construct an r.e. for an intervall of chars
mkSymRng :: Char -> Char -> GenRegex l

-- | mkSym generaized for strings
mkWord :: [Char] -> GenRegex l

-- | construct an r.e. for the set of all Unicode chars
mkDot :: GenRegex l

-- | construct r.e. for r*
mkStar :: Eq l => GenRegex l -> GenRegex l

-- | construct an r.e. for the set of all Unicode words
mkAll :: Eq l => GenRegex l

-- | construct the r.e for r1|r2
mkAlt :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | construct the r.e. for r1{|}r2 (r1 orElse r2).
--   
--   This represents the same r.e. as r1|r2, but when collecting the
--   results of subexpressions in (...) and r1 succeeds, the subexpressions
--   of r2 are discarded, so r1 matches are prioritized
--   
--   example
--   
--   <pre>
--   splitSubex "({1}x)|({2}.)"   "x" = ([("1","x"),("2","x")], "")
--   
--   splitSubex "({1}x){|}({2}.)" "x" = ([("1","x")], "")
--   </pre>
mkElse :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct the sequence r.e. r1.r2
mkSeq :: GenRegex l -> GenRegex l -> GenRegex l

-- | mkSeq extened to lists
mkSeqs :: [GenRegex l] -> GenRegex l

-- | Construct repetition r{i,}
mkRep :: Eq l => Int -> GenRegex l -> GenRegex l

-- | Construct range r{i,j}
mkRng :: Int -> Int -> GenRegex l -> GenRegex l

-- | Construct option r?
mkOpt :: GenRegex l -> GenRegex l

-- | Construct difference r.e.: r1 {\} r2
--   
--   example
--   
--   <pre>
--   match "[a-z]+{\\}bush" "obama"     = True
--   match "[a-z]+{\\}bush" "clinton"   = True
--   match "[a-z]+{\\}bush" "bush"      = False     -- not important any more
--   </pre>
mkDiff :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct r.e. for intersection: r1 {&amp;} r2
--   
--   example
--   
--   <pre>
--   match ".*a.*{&amp;}.*b.*" "-a-b-"  = True
--   match ".*a.*{&amp;}.*b.*" "-b-a-"  = True
--   match ".*a.*{&amp;}.*b.*" "-a-a-"  = False
--   match ".*a.*{&amp;}.*b.*" "---b-"  = False
--   </pre>
mkIsect :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct r.e. for exclusive or: r1 {^} r2
--   
--   example
--   
--   <pre>
--   match "[a-c]+{^}[c-d]+" "abc"  = True
--   match "[a-c]+{^}[c-d]+" "acdc" = False
--   match "[a-c]+{^}[c-d]+" "ccc"  = False
--   match "[a-c]+{^}[c-d]+" "cdc"  = True
--   </pre>
mkExor :: Eq l => GenRegex l -> GenRegex l -> GenRegex l
mkInterleave :: GenRegex l -> GenRegex l -> GenRegex l

-- | Construct the Complement of an r.e.: whole set of words - r
mkCompl :: Eq l => GenRegex l -> GenRegex l

-- | Construct a labeled subexpression: ({label}r)
mkBr :: l -> GenRegex l -> GenRegex l
isZero :: GenRegex l -> Bool
errRegex :: GenRegex l -> String
nullable :: GenRegex l -> Bool
nullable' :: GenRegex l -> Nullable l
delta1 :: Eq l => GenRegex l -> Char -> GenRegex l
delta :: Eq l => GenRegex l -> String -> GenRegex l

-- | FIRST for regular expressions
--   
--   this is only an approximation, the real set of char may be smaller,
--   when the expression contains intersection, set difference or exor
--   operators
firstChars :: GenRegex l -> CharSet
matchWithRegex :: Eq l => GenRegex l -> String -> Bool
matchWithRegex' :: Eq l => GenRegex l -> String -> Maybe [(Label l, String)]

-- | This function wraps the whole regex in a subexpression before starting
--   the parse. This is done for getting acces to the whole parsed string.
--   Therfore we need one special label, this label is the Nothing value,
--   all explicit labels are Just labels.
splitWithRegex :: Eq l => GenRegex l -> String -> Maybe ([(Label l, String)], String)

-- | The main scanner function
splitWithRegex' :: Eq l => GenRegex l -> String -> Maybe (GenRegex l, String)
splitWithRegexCS :: Eq l => GenRegex l -> CharSet -> String -> Maybe ([(Label l, String)], String)

-- | speedup version for splitWithRegex'
--   
--   This function checks whether the input starts with a char from FIRST
--   re. If this is not the case, the split fails. The FIRST set can be
--   computed once for a whole tokenizer and reused by every call of split
splitWithRegexCS' :: Eq l => GenRegex l -> CharSet -> String -> Maybe (GenRegex l, String)
instance Eq l => Eq (GenRegex l)
instance Ord l => Ord (GenRegex l)
instance Show l => Show (GenRegex l)


-- | W3C XML Schema Regular Expression Parser
--   
--   This parser supports the full W3C standard, the complete grammar can
--   be found under <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.String.RegexParser

-- | parse a W3C XML Schema regular expression
--   
--   the Syntax of the W3C XML Schema spec is extended by further useful
--   set operations, like intersection, difference, exor. Subexpression
--   match becomes possible with "named" pairs of parentheses. The multi
--   char escape sequence \a represents any Unicode char, The multi char
--   escape sequence \A represents any Unicode word, (\A = \a*). All
--   syntactically wrong inputs are mapped to the Zero expression
--   representing the empty set of words. Zero contains as data field a
--   string for an error message. So error checking after parsing becomes
--   possible by checking against Zero (<a>isZero</a> predicate)
parseRegex :: String -> Regex


-- | Convenient functions for W3C XML Schema Regular Expression Matcher.
--   For internals see <tt>Text.Regex.XMLSchema.String.Regex</tt>
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.String
data GenRegex l
type Regex = GenRegex String

-- | grep like filter for lists of strings
--   
--   The regular expression may be prefixed with the usual context spec "^"
--   for start of string, and <a>\&lt;</a> for start of word. and suffixed
--   with "$" for end of text and <a>\&gt;</a> end of word. Word chars are
--   defined by the multi char escape sequence <a>\w</a>
--   
--   Examples
--   
--   <pre>
--   grep "a"    ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a_", "_a", "a_", "a"]
--   grep "^a"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a_", "a"]
--   grep "a$"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a", "a"]
--   grep "^a$"  ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a"]
--   grep "\\&lt;a" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " ax "]
--   grep "a\\&gt;" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " xa "]
--   </pre>
grep :: String -> [String] -> [String]

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   match "x*" "xxx" = True
--   match "x" "xxx"  = False
--   match "[" "xxx"  = False
--   </pre>
match :: String -> String -> Bool

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   matchSubex "({1}x*)"                 "xxx"      = [("1","xxx")]
--   matchSubex "({1}x*)"                 "y"        = []
--   matchSubex "({w}[0-9]+)x({h}[0-9]+)" "800x600"  = [("w","800"),("h","600")]
--   matchSubex "[" "xxx"                            = []
--   </pre>
matchSubex :: String -> String -> [(String, String)]

-- | convenient function for <a>sedRE</a>
--   
--   examples:
--   
--   <pre>
--   sed (const "b") "a" "xaxax"       = "xbxbx"
--   sed (\ x -&gt; x ++ x) "a" "xax"     = "xaax"
--   sed undefined       "[" "xxx"     = "xxx"
--   </pre>
sed :: (String -> String) -> String -> String -> String

-- | convenient function for <a>splitRE</a>
--   
--   examples:
--   
--   <pre>
--   split "a*b" "abc" = ("ab","c")
--   split "a*"  "bc"  = ("", "bc")
--   split "a+"  "bc"  = ("", "bc")
--   split "["   "abc" = ("", "abc")
--   </pre>
split :: String -> String -> (String, String)

-- | convenient function for <a>splitSubex</a>
--   
--   examples:
--   
--   <pre>
--   splitSubex "({1}a*)b"  "abc" = ([("1","a")],"c")
--   splitSubex "({2}a*)"   "bc"  = ([("2","")], "bc")
--   splitSubex "({1}a|b)+" "abc" = ([("1","a"),("1","b")],"c")        -- subex 1 matches 2 times
--   
--   splitSubex ".*({x}a*)" "aa"  = ([("x",""),("x","a"),("x","aa")],"")
--                                                                     -- nondeterminism: 3 matches for a*
--   
--   splitSubex "({1}do)|({2}[a-z]+)" "do you know"
--                                  = ([("1","do"),("2","do")]," you know")
--                                                                     -- nondeterminism: 2 matches for do
--   
--   splitSubex "({1}do){|}({2}[a-z]+)" "do you know"
--                                  = ([("1","do")]," you know")
--                                                                     -- no nondeterminism with {|}: 1. match for do
--   
--   splitSubex "({1}a+)"   "bcd" = ([], "bcd")                        -- no match
--   splitSubex "["         "abc" = ([], "abc")                        -- syntax error
--   </pre>
splitSubex :: String -> String -> ([(String, String)], String)

-- | split a string into tokens (words) by giving a regular expression
--   which all tokens must match.
--   
--   Convenient function for <a>tokenizeRE</a>
--   
--   This can be used for simple tokenizers. It is recommended to use
--   regular expressions where the empty word does not match. Else there
--   will appear a lot of probably useless empty tokens in the output. All
--   none matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
--   
--   examples:
--   
--   <pre>
--   tokenize "a" "aabba"      = ["a","a","a"]
--   tokenize "a*" "aaaba"     = ["aaa","a"]
--   tokenize "a*" "bbb"       = ["","",""]
--   tokenize "a+" "bbb"       = []
--   
--   tokenize "a*b" ""         = []
--   tokenize "a*b" "abc"      = ["ab"]
--   tokenize "a*b" "abaab ab" = ["ab","aab","ab"]
--   
--   tokenize "[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+" "ab123 456.7abc"
--                             = ["ab","123","456.7","abc"]
--   
--   tokenize "[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+" "cab123 456.7abc"
--                             = ["cab","123","456.7","abc"]
--   
--   tokenize "[^ \t\n\r]*" "abc def\t\n\rxyz"
--                             = ["abc","def","xyz"]
--   
--   tokenize ".*"   "\nabc\n123\n\nxyz\n"
--                             = ["","abc","123","","xyz"]
--   
--   tokenize ".*"             = lines
--   
--   tokenize "[^ \t\n\r]*"    = words
--   </pre>
tokenize :: String -> String -> [String]

-- | convenient function for <a>tokenizeRE'</a>
--   
--   When the regular expression parses as Zero, <tt>[Left input]</tt> is
--   returned, that means no tokens are found
tokenize' :: String -> String -> [Either String String]

-- | convenient function for <a>tokenizeSubexRE</a> a string
--   
--   examples:
--   
--   <pre>
--   tokenizeSubex "({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)"
--                   "cab123 456.7abc"
--                                    = [("name","cab")
--                                      ,("num","123")
--                                      ,("real","456.7")
--                                      ,("name","abc")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                   "12.34"          = [("real","12.34")
--                                      ,("n","12")
--                                      ,("f","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                    "12 34"         = [("real","12"),("n","12")
--                                      ,("real","34"),("n","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))"
--                    "12 34.56"      = [("real","12"),("n","12"),("f","")
--                                      ,("real","34.56"),("n","34"),("f","56")]
--   </pre>
tokenizeSubex :: String -> String -> [(String, String)]

-- | match a string with a regular expression
matchRE :: (Eq l, Show l) => GenRegex l -> String -> Bool

-- | match a string with a regular expression and extract subexpression
--   matches
matchSubexRE :: (Eq l, Show l) => GenRegex l -> String -> [(l, String)]

-- | sed like editing function
--   
--   All matching tokens are edited by the 1. argument, the editing
--   function, all other chars remain as they are
sedRE :: (Eq l, Show l) => (String -> String) -> GenRegex l -> String -> String

-- | split a string by taking the longest prefix matching a regular
--   expression
--   
--   <tt>Nothing</tt> is returned in case there is no matching prefix, else
--   the pair of prefix and rest is returned
splitRE :: (Eq l, Show l) => GenRegex l -> String -> Maybe (String, String)

-- | split a string by removing the longest prefix matching a regular
--   expression and then return the list of subexpressions found in the
--   matching part
--   
--   <tt>Nothing</tt> is returned in case of no matching prefix, else the
--   list of pairs of labels and submatches and the rest is returned
splitSubexRE :: (Eq l, Show l) => GenRegex l -> String -> Maybe ([(l, String)], String)

-- | The function, that does the real work for <a>tokenize</a>
tokenizeRE :: (Eq l, Show l) => GenRegex l -> String -> [String]

-- | split a string into tokens and delimierter by giving a regular
--   expression wich all tokens must match
--   
--   This is a generalisation of the above <a>tokenizeRE</a> functions. The
--   none matching char sequences are marked with <tt>Left</tt>, the
--   matching ones are marked with <tt>Right</tt>
--   
--   If the regular expression contains syntax errors <tt>Nothing</tt> is
--   returned
--   
--   The following Law holds:
--   
--   <pre>
--   concat . map (either id id) . tokenizeRE' re == id
--   </pre>
tokenizeRE' :: (Eq l, Show l) => GenRegex l -> String -> [Either String String]

-- | split a string into tokens (pair of labels and words) by giving a
--   regular expression containing labeled subexpressions.
--   
--   This function should not be called with regular expressions without
--   any labeled subexpressions. This does not make sense, because the
--   result list will always be empty.
--   
--   Result is the list of matching subexpressions This can be used for
--   simple tokenizers. At least one char is consumed by parsing a token.
--   The pairs in the result list contain the matching substrings. All none
--   matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
tokenizeSubexRE :: (Eq l, Show l) => GenRegex l -> String -> [(l, String)]

-- | construct the r.e. for the empty set. An (error-) message may be
--   attached
mkZero :: String -> GenRegex l

-- | construct the r.e. for the set containing the empty word
mkUnit :: GenRegex l

-- | construct an r.e. for a single char set
mkSym1 :: Char -> GenRegex l

-- | construct an r.e. for an intervall of chars
mkSymRng :: Char -> Char -> GenRegex l

-- | mkSym generaized for strings
mkWord :: [Char] -> GenRegex l

-- | construct an r.e. for the set of all Unicode chars
mkDot :: GenRegex l

-- | construct r.e. for r*
mkStar :: Eq l => GenRegex l -> GenRegex l

-- | construct an r.e. for the set of all Unicode words
mkAll :: Eq l => GenRegex l

-- | construct the r.e for r1|r2
mkAlt :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | construct the r.e. for r1{|}r2 (r1 orElse r2).
--   
--   This represents the same r.e. as r1|r2, but when collecting the
--   results of subexpressions in (...) and r1 succeeds, the subexpressions
--   of r2 are discarded, so r1 matches are prioritized
--   
--   example
--   
--   <pre>
--   splitSubex "({1}x)|({2}.)"   "x" = ([("1","x"),("2","x")], "")
--   
--   splitSubex "({1}x){|}({2}.)" "x" = ([("1","x")], "")
--   </pre>
mkElse :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct the sequence r.e. r1.r2
mkSeq :: GenRegex l -> GenRegex l -> GenRegex l

-- | mkSeq extened to lists
mkSeqs :: [GenRegex l] -> GenRegex l

-- | Construct repetition r{i,}
mkRep :: Eq l => Int -> GenRegex l -> GenRegex l

-- | Construct range r{i,j}
mkRng :: Int -> Int -> GenRegex l -> GenRegex l

-- | Construct option r?
mkOpt :: GenRegex l -> GenRegex l

-- | Construct difference r.e.: r1 {\} r2
--   
--   example
--   
--   <pre>
--   match "[a-z]+{\\}bush" "obama"     = True
--   match "[a-z]+{\\}bush" "clinton"   = True
--   match "[a-z]+{\\}bush" "bush"      = False     -- not important any more
--   </pre>
mkDiff :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct r.e. for intersection: r1 {&amp;} r2
--   
--   example
--   
--   <pre>
--   match ".*a.*{&amp;}.*b.*" "-a-b-"  = True
--   match ".*a.*{&amp;}.*b.*" "-b-a-"  = True
--   match ".*a.*{&amp;}.*b.*" "-a-a-"  = False
--   match ".*a.*{&amp;}.*b.*" "---b-"  = False
--   </pre>
mkIsect :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct r.e. for exclusive or: r1 {^} r2
--   
--   example
--   
--   <pre>
--   match "[a-c]+{^}[c-d]+" "abc"  = True
--   match "[a-c]+{^}[c-d]+" "acdc" = False
--   match "[a-c]+{^}[c-d]+" "ccc"  = False
--   match "[a-c]+{^}[c-d]+" "cdc"  = True
--   </pre>
mkExor :: Eq l => GenRegex l -> GenRegex l -> GenRegex l

-- | Construct the Complement of an r.e.: whole set of words - r
mkCompl :: Eq l => GenRegex l -> GenRegex l

-- | Construct a labeled subexpression: ({label}r)
mkBr :: l -> GenRegex l -> GenRegex l
isZero :: GenRegex l -> Bool
errRegex :: GenRegex l -> String

-- | parse a W3C XML Schema regular expression
--   
--   the Syntax of the W3C XML Schema spec is extended by further useful
--   set operations, like intersection, difference, exor. Subexpression
--   match becomes possible with "named" pairs of parentheses. The multi
--   char escape sequence \a represents any Unicode char, The multi char
--   escape sequence \A represents any Unicode word, (\A = \a*). All
--   syntactically wrong inputs are mapped to the Zero expression
--   representing the empty set of words. Zero contains as data field a
--   string for an error message. So error checking after parsing becomes
--   possible by checking against Zero (<a>isZero</a> predicate)
parseRegex :: String -> Regex
