-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A generalization of pattern matching
--   
--   This library provides pattern matching with <i>restricted function
--   patterns</i> (RFPs). An expression is an RFP iff exists an equivalent
--   valid Haskell pattern. For example <tt>("abc" ++ xs)</tt> is an RFP,
--   because <tt>('a' : 'b' : 'c' : xs)</tt> is an equivalent valid Haskell
--   pattern. On the other hand, <tt>(xs ++ "abc")</tt> is not an RFP.
--   Details are discussed in the paper <i>Restricted Function Patterns</i>
--   presented at <i>TFP 2011</i>.
--   
--   <i>Example 1.</i> Here is a function to chop off the prefix
--   <tt>"prefix" of strings</tt>:
--   
--   <pre>
--   unprefix :: String -&gt; String
--   unprefix s = match s $ do
--      with $ \z -&gt;   "prefix" ++ z ~&gt; z
--      with $ \z -&gt;   z             ~&gt; z
--   </pre>
--   
--   <i>Example 2.</i> Let's have a small embedded language:
--   
--   <pre>
--   data Expr = Symbol String | Expr :$ Expr
--       deriving (Eq,Show,Typeable)
--   
--   instance Num Expr where
--       fromInteger n = Symbol $ show n
--       a + b = Symbol "+" :$ a :$ b
--       a * b = Symbol "*" :$ a :$ b
--       ...
--   </pre>
--   
--   In order to allow pattern matching on expressions of type
--   <tt>Expr</tt>, the following <tt>Matchable</tt> instance is needed:
--   
--   <pre>
--   instance Matchable Expr where
--       Symbol s .=. Symbol z   = Just [s :=: z]
--       (e :$ f) .=. (g :$ h)   = Just [e :=: g, f :=: h]
--       _ .=. _                 = Nothing
--   </pre>
--   
--   Now we can pattern match on expressions even if the constructors of
--   the <tt>Expr</tt> type were hidden:
--   
--   <pre>
--   transform :: Expr -&gt; Expr
--   transform e = match e $ do
--       with $ \a -&gt;        0 + a       ~&gt; a
--       with $ \a b c -&gt;    a * (b + c) ~&gt; a * b + a * c
--       with $ \a -&gt;        a           ~&gt; a
--   </pre>
@package funpat
@version 0.1

module Language.FunPat.Match

-- | A data type to be used in <a>Matchable</a> instances.
data Match
(:=:) :: a -> a -> Match

-- | <a>Matchable</a> data types can be used in patterns.
class Typeable a => Matchable a
(.=.) :: Matchable a => a -> a -> Maybe [Match]
makeParam :: Matchable a => Bool -> a
isParam :: Matchable a => a -> Maybe Bool
data Param
Param :: Bool -> Param
fromParam :: Param -> Bool

-- | <tt>Case</tt> instances are allowed to form cases of a pattern match.
--   (Normally, there is no need to implement more instances of this
--   class.)
class Matchable (PatternType t) => Case t where { type family PatternType t; type family ResultType t; type family ParameterType t; }
start :: Case t => PatternType t -> t -> Maybe (ParameterType t)
continue :: (Case t, Typeable p) => PatternType t -> t -> p -> Maybe [p]
matchCase :: Case t => PatternType t -> t -> Maybe (ResultType t)
data SomeCase t
SomeCase :: a -> SomeCase (PatternType a, ResultType a)

-- | Processes one case.
matchSomeCase :: pat -> SomeCase (pat, res) -> Maybe res

-- | Processes multiple cases.
matchCases :: pat -> [SomeCase (pat, res)] -> res
matchHelp :: Typeable p => Match -> p -> Maybe [p]
matchFold :: Typeable p => p -> [Match] -> Maybe [p]
package :: String
unbound :: String
nonlinear :: String
nonparametric :: String
matchError :: String -> a
instance Typeable Param
instance (Typeable p, Matchable p, Case u) => Case (p -> u)
instance (Matchable u, Typeable u) => Case (u, v)
instance Exception Param
instance Show Param


-- | This module provides <a>Matchable</a> instances for built-in Haskell
--   types.
module Language.FunPat.Instances
instance (Matchable a, Matchable b) => Matchable (Either a b)
instance Matchable a => Matchable (Maybe a)
instance Matchable a => Matchable [a]
instance (Matchable a, Matchable b, Matchable c, Matchable d, Matchable e, Matchable f, Matchable g) => Matchable (a, b, c, d, e, f, g)
instance (Matchable a, Matchable b, Matchable c, Matchable d, Matchable e, Matchable f) => Matchable (a, b, c, d, e, f)
instance (Matchable a, Matchable b, Matchable c, Matchable d, Matchable e) => Matchable (a, b, c, d, e)
instance (Matchable a, Matchable b, Matchable c, Matchable d) => Matchable (a, b, c, d)
instance (Matchable a, Matchable b, Matchable c) => Matchable (a, b, c)
instance (Matchable a, Matchable b) => Matchable (a, b)
instance Matchable Double
instance Matchable Ordering
instance Matchable Float
instance Matchable Int
instance Matchable Integer
instance Matchable Char
instance Matchable Bool
instance Matchable ()

module Language.FunPat.Interface

-- | Matches a value with cases.
match :: pat -> State [SomeCase (pat, res)] () -> res

-- | Creates one <i>case</i> of the match.
with :: Case a => a -> State [SomeCase (PatternType a, ResultType a)] ()

-- | Syntactic sugar to compose <tt>(pattern,result)</tt> pairs.
(~>) :: a -> b -> (a, b)

module Language.FunPat
