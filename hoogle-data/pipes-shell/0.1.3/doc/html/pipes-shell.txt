-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Create proper Pipes from System.Process
--   
@package pipes-shell
@version 0.1.3


-- | This module contains a few functions to use unix-y shell commands as
--   <a>Pipe</a>s.
--   
--   The output <tt>ByteString</tt>s from <a>pipeCmdEnv</a> and friends are
--   not line-wise, but chunk-wise. To get proper lines use the
--   pipes-bytestring and the upcoming pipes-text machinery. Note that exit
--   code handling is not yet implemented.
--   
--   All code examples in this module assume following qualified imports:
--   Pipes.Prelude as P, Pipes.ByteString as PBS, Data.ByteString.Char8 as
--   BSC
module Pipes.Shell

-- | This is the workhorse of this package.
--   
--   It provides the direct interface from a shell command string to a
--   proper <a>Pipe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; runShell $ yield (BSC.pack "aaa") &gt;?&gt; pipeCmdEnv Nothing "tr 'a' 'A'" &gt;-&gt; PBS.stdout
--   AAA
--   </pre>
pipeCmdEnv :: MonadSafe m => Maybe [(String, String)] -> String -> Pipe (Maybe ByteString) (Either ByteString ByteString) m ()

-- | Like <a>pipeCmdEnv</a> but doesn't set enviorment varaibles
pipeCmd :: MonadSafe m => String -> Pipe (Maybe ByteString) (Either ByteString ByteString) m ()

-- | Like <a>pipeCmd</a> but ignores stderr
pipeCmd' :: MonadSafe m => String -> Pipe (Maybe ByteString) ByteString m ()

-- | Like <a>pipeCmdEnv</a> but closes the input end immediately.
--   
--   Useful for command line tools like <tt> ls </tt>
producerCmdEnv :: MonadSafe m => Maybe [(String, String)] -> String -> Producer (Either ByteString ByteString) m ()

-- | Like <a>producerCmdEnv</a> but doesn't set enviorment varaibles
producerCmd :: MonadSafe m => String -> Producer (Either ByteString ByteString) m ()

-- | Like <a>producerCmd</a> but ignores stderr
producerCmd' :: MonadSafe m => String -> Producer ByteString m ()

-- | Like <a>pipeCmd</a> but closes the output end immediately.
--   
--   Useful for command line tools like <tt> cat &gt; test.file </tt>
consumerCmdEnv :: MonadSafe m => Maybe [(String, String)] -> String -> Consumer (Maybe ByteString) m ()

-- | Like <a>consumerCmdEnv</a> but doesn't set enviorment varaibles
consumerCmd :: MonadSafe m => String -> Consumer (Maybe ByteString) m ()

-- | An ad-hoc typeclass to get the varadic arguments and DWIM behavoir of
--   <a>cmdEnv</a>
class Cmd cmd where cmd = cmdEnv Nothing
cmdEnv :: Cmd cmd => Maybe [(String, String)] -> String -> cmd
cmd :: (Cmd cmd, Cmd cmd) => String -> cmd

-- | An ad-hoc typeclass to get the varadic arguments and DWIM behavoir of
--   <a>cmd'</a>. This class is seperate from <a>Cmd</a> to make the return
--   types work out.
class Cmd' cmd
cmd' :: Cmd' cmd => String -> cmd

-- | Like <a>&gt;-&gt;</a> but marks the end of the left pipe with
--   <a>markEnd</a>. It's needed because <a>pipeCmdEnv</a> has to know when
--   the upstream <a>Pipe</a> finishes.
--   
--   The basic rule is:
--   
--   <pre>
--   Replace every <a>&gt;-&gt;</a> with <a>&gt;?&gt;</a> when it's in front of
--     <a>pipeCmdEnv</a> or similar.
--   </pre>
(>?>) :: Monad m => Proxy a' a () b m r -> Proxy () (Maybe b) c' c m r -> Proxy a' a c' c m r

-- | Mark the end of a pipe. It wraps all values in a <a>Just</a> and
--   yields *one* <a>Nothing</a> after the upstream pipe finished.
markEnd :: Monad m => Proxy a' a b' b m r -> Proxy a' a b' (Maybe b) m r

-- | Ignore stderr from a <a>pipeCmd</a>
ignoreErr :: Monad m => Pipe (Either ByteString ByteString) ByteString m ()

-- | Ignore stdout from a <a>pipeCmd</a>
ignoreOut :: Monad m => Pipe (Either ByteString ByteString) ByteString m ()

-- | A simple run function for <a>Pipe</a>s that live in <a>SafeT</a>
--   <a>IO</a>
runShell :: Effect (SafeT IO) r -> IO r
instance MonadSafe m => Cmd' (Consumer (Maybe ByteString) m ())
instance MonadSafe m => Cmd' (Producer ByteString m ())
instance MonadSafe m => Cmd' (Pipe (Maybe ByteString) ByteString m ())
instance Cmd' cmd => Cmd' (String -> cmd)
instance MonadSafe m => Cmd (Consumer (Maybe ByteString) m ())
instance MonadSafe m => Cmd (Producer (Either ByteString ByteString) m ())
instance MonadSafe m => Cmd (Pipe (Maybe ByteString) (Either ByteString ByteString) m ())
instance Cmd cmd => Cmd (String -> cmd)
