-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An alternative to lazy I/O that doesn't conflate
execution with evaluation
--   
--   Lazy I/O conflates evaluation with execution; a value obtained from
--   <a>unsafeInterleaveIO</a> can perform side-effects during the
--   evaluation of pure code. Like lazy I/O, a <a>Sink</a> provides a way
--   to obtain the value of the result of an <a>IO</a> action before the
--   action has been executed, but unlike lazy I/O, it does not enable pure
--   code to perform side-effects. Instead, the value is explicitly
--   assigned by a later <a>IO</a> action.
@package sink
@version 0.1.0.1


-- | <a>Sink</a>s are a more flexible alternative to lazy I/O
--   (<a>unsafeInterleaveIO</a>). Lazy I/O conflates evaluation with
--   execution; a value obtained from <a>unsafeInterleaveIO</a> can perform
--   side-effects during the evaluation of pure code. Like lazy I/O, a
--   <a>Sink</a> provides a way to obtain the value of the result of an
--   <a>IO</a> action before the action has been executed, but unlike lazy
--   I/O, it does not enable pure code to perform side-effects. Instead,
--   the value is explicitly assigned by a later <a>IO</a> action; repeated
--   attempts to assign the value of a <a>Sink</a> fail. The catch is that
--   this explicit assignment must occur before the value is forced, so
--   just like with lazy I/O, you can't get away with completely ignoring
--   evaluation order without introducing bugs. However, violating this
--   condition does not violate purity because if the value is forced
--   before it has been assigned, it is .
--   
--   In practice, using <a>Sink</a>s instead of <a>unsafeInterleaveIO</a>
--   requires a bit more <a>IO</a> boilerplate. The main practical
--   difference is that while <a>unsafeInterleaveIO</a> requires you to
--   reason about effects from the point of view of pure code, <a>Sink</a>s
--   require you to reason about evaluation order of pure code from the
--   point of view of <a>IO</a>; the <a>IO</a> portion of your program will
--   have to be aware of what data is necessary to produce *for* your pure
--   code in order to be able to consume the output it expects *from* your
--   pure code.
module Data.Sink

-- | A write-once reference
data Sink a

-- | Create a new <a>Sink</a> and a pure value. If you force the value
--   before writing to the <a>Sink</a>, the value is . If you write to the
--   <a>Sink</a> before forcing the value, the value will be whatever you
--   wrote to the <a>Sink</a>. The <a>String</a> argument is an error
--   message in case you force the value before writing to the <a>Sink</a>.
newSinkMsg :: String -> IO (Sink a, a)

-- | Create a new <a>Sink</a> with a default error message.
newSink :: IO (Sink a, a)

-- | Attempt to assign a value to a <a>Sink</a>. If the <a>Sink</a> was
--   previously unwritten, write the value and return <a>True</a>,
--   otherwise keep the old value and return <a>False</a>. This is an
--   atomic (thread safe) operation.
tryWriteSink :: Sink a -> a -> IO Bool

-- | Attempt to assign a value to a <a>Sink</a>. If the <a>Sink</a> had
--   already been written to, throw a <a>MultipleWrites</a> exception. This
--   is an atomic (thread safe) operation.
writeSink :: Sink a -> a -> IO ()

-- | An exception that is thrown by <a>writeSink</a> if you attempt to
--   write to a <a>Sink</a> more than once.
data MultipleWrites
MultipleWrites :: MultipleWrites
instance Typeable1 Sink
instance Typeable MultipleWrites
instance Eq (Sink a)
instance Show MultipleWrites
instance Exception MultipleWrites
