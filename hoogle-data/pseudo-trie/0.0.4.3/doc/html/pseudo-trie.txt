-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A tagged rose-tree with short circuited unique leaves
--   
@package pseudo-trie
@version 0.0.4.3

module Data.Trie.Pseudo

-- | Non-Empty Rose Tree with explicit emptyness
data PseudoTrie t a
More :: !(t, Maybe a) -> !(NonEmpty (PseudoTrie t a)) -> PseudoTrie t a
Rest :: !(NonEmpty t) -> a -> PseudoTrie t a
Nil :: PseudoTrie t a

-- | Overwriting instance

-- | Depth first
beginsWith :: Eq t => PseudoTrie t a -> t -> Bool

-- | Provides a form of deletion by setting a path to <tt>Nothing</tt>, but
--   doesn't cleanup like <tt>prune</tt>
assign :: Eq t => NonEmpty t -> Maybe a -> PseudoTrie t a -> PseudoTrie t a

-- | Overwrite the LHS point-wise with the RHS's contents
merge :: Eq t => PseudoTrie t a -> PseudoTrie t a -> PseudoTrie t a
add :: Eq t => NonEmpty t -> PseudoTrie t a -> PseudoTrie t a -> PseudoTrie t a
toAssocs :: PseudoTrie t a -> [(NonEmpty t, a)]
fromAssocs :: Eq t => [(NonEmpty t, a)] -> PseudoTrie t a
lookup :: Eq t => NonEmpty t -> PseudoTrie t a -> Maybe a
lookupNearestParent :: Eq t => [t] -> PseudoTrie t a -> Maybe a

-- | Simple test on the heads of two tries
areDisjoint :: Eq t => PseudoTrie t a -> PseudoTrie t a -> Bool

-- | The meet of two <tt>PseudoTrie</tt>s
intersectionWith :: Eq t => (a -> b -> c) -> PseudoTrie t a -> PseudoTrie t b -> PseudoTrie t c

-- | Needless intermediary elements are turned into shortcuts,
--   <tt>Nil</tt>'s in subtrees are also removed.
prune :: PseudoTrie t a -> PseudoTrie t a
instance (Show t, Show a) => Show (PseudoTrie t a)
instance (Eq t, Eq a) => Eq (PseudoTrie t a)
instance Functor (PseudoTrie t)
instance Foldable (PseudoTrie t)
instance Eq t => Monoid (PseudoTrie t a)

module Data.Trie.Rooted
data Rooted t a
Rooted :: (Maybe a) -> [PseudoTrie t a] -> Rooted t a
root :: Rooted t a -> (Maybe a)
children :: Rooted t a -> [PseudoTrie t a]

-- | Intersection instance

-- | Union instance
newtype MergeRooted t a
MergeRooted :: Rooted t a -> MergeRooted t a
unMergeRooted :: MergeRooted t a -> Rooted t a

-- | Strictly constructive form of <tt>Data.Trie.Pseudo.assign</tt>
assign :: Eq t => [t] -> Maybe a -> Rooted t a -> Rooted t a
lookup :: Eq t => [t] -> Rooted t a -> Maybe a
lookupNearestParent :: Eq t => [t] -> Rooted t a -> Maybe a
merge :: Eq t => Rooted t a -> Rooted t a -> Rooted t a

-- | Prepend root with a tag
push :: Rooted t a -> NonEmpty t -> PseudoTrie t a

-- | Disjoint cases just pull children to common root
unionWith :: Eq t => (a -> a -> a) -> Rooted t a -> Rooted t a -> Rooted t a
instance (Show t, Show a) => Show (Rooted t a)
instance (Eq t, Eq a) => Eq (Rooted t a)
instance Functor (Rooted t)
instance Functor (MergeRooted t)
instance Eq t => Monoid (MergeRooted t a)
instance (Eq t, Monoid a) => Monoid (Rooted t a)
instance Eq t => Applicative (Rooted t)
