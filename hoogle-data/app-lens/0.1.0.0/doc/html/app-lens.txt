-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | applicative (functional) bidirectional programming beyond composition chains
--   
@package app-lens
@version 0.1.0.0

module Control.LensFunction.Exception
data SomeLensFunctionException
SomeLensFunctionException :: e -> SomeLensFunctionException
data NoLUBException
NoLUBException :: String -> NoLUBException
data ChangedObservationException
ChangedObservationException :: String -> ChangedObservationException
data ShapeMismatchException
ShapeMismatchException :: String -> ShapeMismatchException
data ConstantUpdateException
ConstantUpdateException :: String -> ConstantUpdateException
instance Typeable SomeLensFunctionException
instance Typeable NoLUBException
instance Typeable ChangedObservationException
instance Typeable ShapeMismatchException
instance Typeable ConstantUpdateException
instance Exception ConstantUpdateException
instance Show ConstantUpdateException
instance Exception ShapeMismatchException
instance Show ShapeMismatchException
instance Exception ChangedObservationException
instance Show ChangedObservationException
instance Exception NoLUBException
instance Show NoLUBException
instance Exception SomeLensFunctionException
instance Show SomeLensFunctionException


-- | This module provides an "applicative" (functional) way of composing
--   lenses through the data type <a>L</a>. For example, this module
--   enables us to define a "lens" version of <a>unlines</a> as follows.
--   
--   <pre>
--   unlinesF :: [L s String] -&gt; L s String
--   unlinesF []     = new ""
--   unlinesF (x:xs) = catLineF x (unlinesF xs)
--     where catLineF = lift2 catLineL
--   
--   catLineL :: Lens' (String, String) String
--   catLineL = ...
--   </pre>
--   
--   To make a lens from such "lens functions", one can use unlifting
--   functions (<a>unlift</a>, <a>unlift2</a>, <a>unliftT</a>) as follows.
--   
--   <pre>
--   unlinesL :: Lens' [String] String
--   unlinesL = unliftT unlinesF
--   </pre>
--   
--   The obtained lens works as expected (here <a>^.</a>, <a>&amp;</a> and
--   <a>.~</a> are taken from <a>Control.Lens</a>).
--   
--   <pre>
--   &gt;&gt;&gt; ["banana", "orange", "apple"] ^. unlinesL
--   "banana\norange\napple\n"
--   
--   &gt;&gt;&gt; ["banana", "orange", "apple"] &amp; unlinesL .~ "Banana\nOrange\nApple\n"
--   ["Banana","Orange","Apple"]
--   </pre>
--   
--   One can understand that <tt>L s a</tt> is an updatable <tt>a</tt>. The
--   type <tt>[L s String] -&gt; L s String</tt> of <tt>unlinesF</tt> tells
--   us that we can update only the list elements. Actually, insertion or
--   deletion of lines to the view will fail, as below.
--   
--   <pre>
--   &gt;&gt;&gt; ["banana", "orange", "apple"] &amp; unlinesL .~ "Banana\nOrange\nApple"
--   *** Exception: ...
--   
--   &gt;&gt;&gt; ["banana", "orange", "apple"] &amp; unlinesL .~ "Banana\nOrange\nApple\n\n"
--   *** Exception: ...
--   </pre>
--   
--   If you want to reflect insertions and deletions, one have to write a
--   function of type <tt>L s [String] -&gt; L s String</tt>, which says
--   that the list structure itself would be updatable. To write a function
--   of this type, <a>liftC</a> and <a>liftC2</a> functions would be
--   sometimes useful.
--   
--   <pre>
--   unlinesF' :: L s [String] -&gt; L s String
--   unlinesF' = liftC (foldWithDefault "" "n") (lift catLineL')
--   
--   catLineL' :: Lens' (Either () (String,String)) String
--   catLineL' = ...
--   
--   foldWithDefault :: a -&gt; (Lens' (Either () (a,b)) b) -&gt; Lens' [a] b
--   foldWithDefault d f = ...
--   </pre>
module Control.LensFunction

-- | An abstract type for "updatable" data. Bidirectional programming
--   through our module is to write manipulation of this datatype.
--   
--   <h4>Categorical Notes</h4>
--   
--   The type constructor <tt>L s</tt> together with <a>lift</a>,
--   <a>unit</a> and <a>pair</a> defines a lax monoidal functor from the
--   category of lenses to that of Haskell functions. The <a>lift</a>
--   function does transfor a lens to a function. The <a>unit</a> and
--   <a>pair</a> functions are the core operations on this lax monoidal
--   functor. Any lifting functions defined in this module can be defined
--   by these three functions.
data L s a

-- | A variant of <a>lens</a>. Sometimes, this function would be easier to
--   use because one can re-use a source information to define a "put".
lens' :: (s -> (v, v -> s)) -> Lens' s v

-- | The unit element in the lifted world.
--   
--   Let <tt>elimUnitL</tt> and <tt>elimUnitR</tt> are lenses defined as
--   follows.
--   
--   <pre>
--   elimUnitL = lens ((x,()) -&gt; x) (_ x -&gt; (x,()))
--   elimUnitR = lens (((),x) -&gt; x) (_ x -&gt; ((),x))
--   </pre>
--   
--   Then, we have the following laws.
--   
--   <pre>
--   lift2 elimUnitL x unit = x
--   </pre>
--   
--   <pre>
--   lift2 elimUnitR unit x = x
--   </pre>
unit :: L s ()

-- | A paring function of <tt>L s a</tt>-typed values. This function can be
--   defined by <tt>lift2</tt> as below.
--   
--   <pre>
--   pair = lift2 (lens id (const id))
--   </pre>
pair :: L s a -> L s b -> L s (a, b)

-- | Similar to <tt>pair</tt>, but this function is for lists. This is a
--   derived function, because this can be defined by using <a>lift</a> and
--   <a>pair</a>.
list :: [L s a] -> L s [a]

-- | A data-type generic version of <a>list</a>. The contraint <tt>Eq (t
--   ())</tt> says that we can check the equivalence of shapes of
--   containers <tt>t</tt>.
sequenceL :: (Eq (t ()), Traversable t) => t (L s a) -> L s (t a)

-- | The nullary version of a lifting function. Since there is no source,
--   every view generated by <a>new</a> is not updatable.
--   
--   The function will throw <a>ConstantUpdateException</a>, if its view is
--   updated.
new :: Eq a => a -> L s a

-- | The lifting function. Note that it forms a functor from the category
--   of lenses to the category of sets and functions.
--   
--   <a>unlift</a> is a left-inverse of this function.
--   
--   <pre>
--   unlift (lift x) = x
--   </pre>
lift :: Lens' a b -> (forall s. L s a -> L s b)

-- | The lifting function for binary lenses. <a>unlift2</a> is a left
--   inverse of this function.
--   
--   <pre>
--   unlift2 (lift2 l) = l
--   </pre>
--   
--   This function can be defined from <a>lift</a> and <a>pair</a> as
--   below.
--   
--   <pre>
--   lift2 l x y = lift l (pair x y)
--   </pre>
--   
--   NB: This is not a right inverse of <a>unlift2</a>.
--   
--   <pre>
--   (\x y -&gt; x) /= lift2 (unlift2 (\x y -&gt; x))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set (unlift (\z -&gt; (\x y -&gt; x) z z)) "A" "B"
--   "B"
--   
--   &gt;&gt;&gt; set (unlift (\z -&gt; lift2 (unlift2 (\x y -&gt; x)) (z,z))) "A" "B"
--   Error: ...
--   </pre>
lift2 :: Lens' (a, b) c -> (L s a -> L s b -> L s c)

-- | A datatype-generic version of <a>lift2</a>
liftT :: (Eq (t ()), Traversable t) => Lens' (t a) b -> (forall s. t (L s a) -> L s b)

-- | Just a composition of <a>lift</a> and <a>lens</a>. Sometimes, this
--   function would be more efficient than the composition due to
--   eliminated conversion from the lens to the internal representation.
--   
--   Since both of the internal and the external representations are
--   functions (= normal forms), we have to pay the conversion cost for
--   each time when the lifted lens function is evaluated, even in the lazy
--   evaluation.
--   
--   We actually has the RULE to make the composition of <a>lift</a> and
--   <a>lens</a> to <a>liftLens</a>. However, the rule may not be fired
--   especially when profiling codes are inserted by GHC.
liftLens :: (a -> b) -> (a -> b -> a) -> (forall s. L s a -> L s b)

-- | Just a composition of <a>lift</a> and <a>lens'</a>. This function has
--   the similar role to <a>liftLens</a>.
liftLens' :: (a -> (b, b -> a)) -> (forall s. L s a -> L s b)

-- | The unlifting function, satisfying <tt>unlift (lift x) = x</tt>.
unlift :: Eq a => (forall s. L s a -> L s b) -> Lens' a b

-- | The unlifting function for binary functions, satisfying <tt>unlift2
--   (lift2 x) = x</tt>.
unlift2 :: (Eq a, Eq b) => (forall s. L s a -> L s b -> L s c) -> Lens' (a, b) c

-- | The unlifting function for functions that manipulate data structures,
--   satisfying <tt>unliftT (liftT x) = x</tt> if <tt>x</tt> keeps the
--   shape. The constraint <tt>Eq (t ())</tt> says that we can compare the
--   shapes of given two containers.
unliftT :: (Eq a, Eq (t ()), Traversable t) => (forall s. t (L s a) -> L s b) -> Lens' (t a) b

-- | An abstract monad used to keep track of observations. By this monad,
--   we can inspect the value of 'L s a'-data.
--   
--   It is worth noting that we cannot change the inspection result to
--   ensure the consistency property (aka PutGet in some context).
data R s a

-- | A primitive used to define <tt>liftO</tt> and <tt>liftO2</tt>. With
--   <a>observe</a>, one can inspect the current value of a lifted '(L s
--   a)'-value as below.
--   
--   <pre>
--   f x :: L s A -&gt; R s (L s B)
--   f x = do viewX &lt;- observe x
--            ... computation depending on <tt>viewX</tt> ...
--   </pre>
--   
--   Once the <a>observe</a> function is used in a lens function, the lens
--   function becomes not able to change change the "observed" value to
--   ensure the correctness.
observe :: Eq w => L s w -> R s w

-- | Lifting of observations. A typical use of this function would be as
--   follows.
--   
--   <pre>
--   f x :: L s Int -&gt; R s (L s B)
--   f x = do b <a>liftO (</a> 0) x 
--            if b then ... else ...           
--   </pre>
liftO :: Eq w => (a -> w) -> L s a -> R s w

-- | Lifting of binary observations
liftO2 :: Eq w => (a -> b -> w) -> L s a -> L s b -> R s w

-- | A monadic version of <a>unlift</a>.
unliftM :: Eq a => (forall s. L s a -> R s (L s b)) -> Lens' a b

-- | A monadic version of <a>unlift2</a>.
unliftM2 :: (Eq a, Eq b) => (forall s. L s a -> L s b -> R s (L s c)) -> Lens' (a, b) c

-- | A monadic version of <a>unliftT</a>.
unliftMT :: (Eq a, Eq (t ()), Traversable t) => (forall s. t (L s a) -> R s (L s b)) -> Lens' (t a) b

-- | A lifting function for lens combinators. One can understand that the
--   universal quantification for the second argument as closedness
--   restriction.
liftC :: Eq a => (Lens' a b -> Lens' c d) -> (forall s. L s a -> L s b) -> (forall s. L s c -> L s d)

-- | Similar to <a>liftC</a>, but this function is for binary lens
--   combinators.
liftC2 :: (Eq a, Eq c) => (Lens' a b -> Lens' c d -> Lens' e f) -> (forall s. L s a -> L s b) -> (forall s. L s c -> L s d) -> (forall s. L s e -> L s f)
