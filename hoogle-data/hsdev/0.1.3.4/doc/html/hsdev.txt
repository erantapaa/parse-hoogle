-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.
--   
--   Haskell development library and tool with support of autocompletion,
--   symbol info, go to declaration, find references, hayoo search etc.
@package hsdev
@version 0.1.3.4

module HsDev.Version
cabalVersion :: ExpQ

module HsDev.Tools.Ghc.Prelude
reduce :: ([a] -> a) -> [a] -> [a]
one :: a -> [a]
trim :: String -> String
rx :: String -> String -> Maybe String
srx :: String -> String -> String -> String


-- | Format module
--   
--   <pre>
--   "My name is $, I am ${age} years old, I am from $" %~ ("Vasya" % ("age" %= 20) % "Moscow")
--   "My name is Vasya, I am 20 years old"
--   </pre>
module Text.Format
class Format a
format :: Format a => a -> String
type FormatArgs = [(Maybe String, String)]
class Hole a
hole :: Hole a => a -> FormatArgs
(%~) :: Hole a => String -> a -> Either String String
(~~) :: Hole a => String -> a -> String
(%) :: (Hole a, Hole b) => a -> b -> FormatArgs
(%=) :: Format a => String -> a -> (String, String)
instance [overlap ok] Hole [(String, String)]
instance [overlap ok] Format a => Hole (String, a)
instance [overlap ok] Format a => Hole a
instance [overlap ok] Hole FormatArgs
instance [overlap ok] Format Integer
instance [overlap ok] Format Int
instance [overlap ok] Format String

module Data.Lisp
data Lisp
Null :: Lisp
Bool :: Bool -> Lisp
Symbol :: String -> Lisp
String :: String -> Lisp
Number :: Scientific -> Lisp
List :: [Lisp] -> Lisp
lisp :: Int -> ReadP Lisp
encodeLisp :: ToJSON a => a -> ByteString
decodeLisp :: FromJSON a => ByteString -> Either String a
instance Eq Lisp
instance FromJSON Lisp
instance ToJSON Lisp
instance Show Lisp
instance Read Lisp

module Data.Help
class Help a
brief :: Help a => a -> String
help :: Help a => a -> [String]
indent :: String -> String
indentHelp :: [String] -> [String]
detailed :: Help a => a -> [String]
indented :: Help a => a -> [String]

module System.Console.Args
data Args
Args :: [String] -> Opts String -> Args
posArgs :: Args -> [String]
namedArgs :: Args -> Opts String
newtype Opts a
Opts :: Map String [a] -> Opts a
getOpts :: Opts a -> Map String [a]
data Arg
Flag :: Arg
Required :: String -> Arg
List :: String -> Arg
data Opt
Opt :: String -> [Char] -> [String] -> Maybe String -> Arg -> Opt
optName :: Opt -> String
optShort :: Opt -> [Char]
optLong :: Opt -> [String]
optDescription :: Opt -> Maybe String
optArg :: Opt -> Arg
withOpts :: (Opts String -> Opts String) -> Args -> Args

-- | Set default values, if option doesn't present
defOpts :: Opts String -> Opts String -> Opts String
defArgs :: Opts String -> Args -> Args
selectOpts :: [Opt] -> Opts a -> Opts a
splitOpts :: [Opt] -> Opts a -> (Opts a, Opts a)
(%--) :: Format a => String -> a -> Opts String
(%-?) :: Format a => String -> Maybe a -> Opts String

-- | Make <a>Opts</a> with flag set
hoist :: String -> Opts a
has :: String -> Opts a -> Bool

-- | Get argument value
arg :: String -> Opts a -> Maybe a

-- | Get numeric value
narg :: (Read a, Num a) => String -> Opts String -> Maybe a

-- | Get integer value
iarg :: String -> Opts String -> Maybe Integer

-- | Get list argument
listArg :: String -> Opts a -> [a]

-- | Is flag set
flagSet :: String -> Opts a -> Bool

-- | Flag option
flag :: String -> Opt

-- | Required option
req :: String -> String -> Opt

-- | List option
list :: String -> String -> Opt

-- | Convert req option to list
manyReq :: Opt -> Opt

-- | Set description
--   
--   <pre>
--   flag "quiet" `desc` "quiet mode"
--   </pre>
desc :: Opt -> String -> Opt

-- | Set aliases
--   
--   <pre>
--   fliag "quiet" `alias` 
--   </pre>
alias :: Opt -> [String] -> Opt

-- | Shortcuts
short :: Opt -> [Char] -> Opt
parse :: [Opt] -> [String] -> Either String Args

-- | Parse with no options declarations
parse_ :: [String] -> Args
tryParse :: [Opt] -> [String] -> Args
toArgs :: Args -> [String]
info :: [Opt] -> String
splitArgs :: String -> [String]
unsplitArgs :: [String] -> String
verify :: [Opt] -> Args -> Either String Args
instance Eq a => Eq (Opts a)
instance Show a => Show (Opts a)
instance Eq Args
instance Show Args
instance Eq Arg
instance Ord Arg
instance Show Arg
instance Eq Opt
instance Show Opt
instance Help [Opt]
instance Help Opt
instance FromJSON a => FromJSON (Opts a)
instance ToJSON a => ToJSON (Opts a)
instance Monoid (Opts a)
instance Traversable Opts
instance Foldable Opts
instance Functor Opts
instance Monoid Args

module System.Console.Cmd
type CmdAction a = ErrorT String Maybe a

-- | Arguments doesn't match command
notMatch :: CmdAction a

-- | Invalid command arguments
failMatch :: String -> CmdAction a

-- | Run cmd
runCmd :: Cmd a -> Args -> CmdAction a

-- | Set default opts
defaultOpts :: Opts String -> Cmd a -> Cmd a

-- | Validate Args in command
validateArgs :: (Args -> CmdAction ()) -> Cmd a -> Cmd a

-- | Alter Args in command
alterArgs :: (Args -> CmdAction Args) -> Cmd a -> Cmd a
data Cmd a
Cmd :: String -> [String] -> [Opt] -> String -> (Args -> CmdAction Args) -> (Args -> CmdAction a) -> Cmd a
cmdName :: Cmd a -> String
cmdArgs :: Cmd a -> [String]
cmdOpts :: Cmd a -> [Opt]
cmdDesc :: Cmd a -> String

-- | Get command arguments from source arguments, by default it cuts
--   command name
cmdGetArgs :: Cmd a -> Args -> CmdAction Args
cmdAction :: Cmd a -> Args -> CmdAction a

-- | Make CmdAction function
cmdAct :: (b -> a) -> b -> CmdAction a

-- | Cut name of command from arguments and checks if it matches
--   
--   <pre>
--   cutName &gt;=&gt; cmdAct act
--   </pre>
cutName :: String -> Args -> CmdAction Args
cmda :: String -> [String] -> [Opt] -> String -> (Args -> CmdAction a) -> Cmd a
cmda_ :: String -> [Opt] -> String -> (Opts String -> CmdAction a) -> Cmd a
cmd :: String -> [String] -> [Opt] -> String -> (Args -> a) -> Cmd a
cmd_ :: String -> [Opt] -> String -> (Opts String -> a) -> Cmd a

-- | Unnamed command
defCmd :: [String] -> [Opt] -> String -> (Args -> a) -> Cmd a
data CmdHelp
HelpUsage :: [String] -> CmdHelp
HelpCommands :: [(String, [String])] -> CmdHelp

-- | Make help command, which will show help on for specified commands
helpCommand :: String -> (Either String CmdHelp -> a) -> [Cmd a] -> Cmd a

-- | Add help command
withHelp :: String -> (Either String CmdHelp -> a) -> [Cmd a] -> [Cmd a]
printWith :: (String -> a) -> (Either String CmdHelp -> a)

-- | Run commands
run :: [Cmd a] -> a -> (String -> a) -> [String] -> a

-- | Run commands with parsed args
runArgs :: [Cmd a] -> a -> (String -> a) -> Args -> a

-- | Run commands with
runOn :: [Cmd a] -> a -> (String -> a) -> (Cmd a -> c -> Args) -> c -> a
instance Eq CmdHelp
instance Ord CmdHelp
instance Read CmdHelp
instance Show CmdHelp
instance Help (Cmd a)
instance Functor Cmd

module Data.Group

-- | Group is monoid with invertibility But for our purposes we prefer two
--   functions: <a>add</a> and <a>sub</a>.
class Eq a => Group a
add :: Group a => a -> a -> a
sub :: Group a => a -> a -> a
zero :: Group a => a

-- | Sums list
groupSum :: Group a => [a] -> a
instance (Ord k, Group a) => Group (Map k a)
instance Ord a => Group (Set a)
instance Eq a => Group [a]

module Data.Async

-- | Event on async value
data Event a
Append :: a -> Event a
Remove :: a -> Event a
Clear :: Event a
Modify :: (a -> a) -> Event a
Action :: (a -> IO a) -> Event a

-- | Event to function
event :: Group a => Event a -> a -> IO a
data Async a
Async :: MVar a -> Chan (Event a) -> Async a
asyncVar :: Async a -> MVar a
asyncEvents :: Async a -> Chan (Event a)
newAsync :: (NFData a, Group a) => IO (Async a)
readAsync :: Async a -> IO a
modifyAsync :: Async a -> Event a -> IO ()

module Control.Concurrent.Util
fork :: (MonadIO m, Functor m) => IO () -> m ()
race :: [IO a] -> IO a
timeout :: Int -> IO a -> IO (Maybe a)
withSync :: a -> ((a -> IO ()) -> IO b) -> IO a
withSync_ :: (IO () -> IO a) -> IO ()

module Control.Concurrent.Task

-- | Task result
data Task a
Task :: MVar (Maybe (SomeException -> IO ())) -> TaskResult a -> Task a
taskStart :: Task a -> MVar (Maybe (SomeException -> IO ()))
taskResult :: Task a -> TaskResult a
data TaskException
TaskCancelled :: TaskException
TaskKilled :: TaskException
data TaskResult a
TaskResult :: IO Bool -> IO (Maybe (Either SomeException a)) -> IO (Either SomeException a) -> (SomeException -> IO ()) -> TaskResult a
taskResultEmpty :: TaskResult a -> IO Bool
taskResultTryRead :: TaskResult a -> IO (Maybe (Either SomeException a))
taskResultTake :: TaskResult a -> IO (Either SomeException a)
taskResultFail :: TaskResult a -> SomeException -> IO ()
taskStarted :: Task a -> IO Bool
taskRunning :: Task a -> IO Bool
taskStopped :: Task a -> IO Bool
taskDone :: Task a -> IO Bool
taskFailed :: Task a -> IO Bool
taskCancelled :: Task a -> IO Bool

-- | Wait until task starts or be cancelled, returns True if started
taskWaitStart :: Task a -> IO Bool

-- | Wait for task
taskWait :: Task a -> IO (Either SomeException a)

-- | Kill task
taskKill :: Task a -> IO ()

-- | Cancel task if it is not started yet
taskCancel :: Task a -> IO Bool

-- | Cancel or kill task, returns whether it was cancelled
taskStop :: Task a -> IO Bool
runTask :: (MonadCatch m, MonadIO m, MonadIO n) => (m () -> n ()) -> m a -> n (Task a)
runTask_ :: (MonadCatch m, MonadIO m, MonadIO n) => (Task a -> m () -> n ()) -> m a -> n (Task a)
runTaskTry :: (MonadCatch m, MonadIO m, MonadIO n) => (Task a -> m () -> n ()) -> m (Either SomeException a) -> n (Task a)
runTaskError :: (Show e, Error e, MonadError e m, MonadCatch m, MonadIO m, MonadIO n) => (Task a -> m () -> n ()) -> m a -> n (Task a)

-- | Run task in separate thread
forkTask :: IO a -> IO (Task a)
tryT :: (Show e, Error e, MonadError e m) => m a -> m (Either SomeException a)
instance Typeable TaskException
instance Eq TaskException
instance Ord TaskException
instance Enum TaskException
instance Bounded TaskException
instance Read TaskException
instance Show TaskException
instance Functor Task
instance Functor TaskResult
instance Exception TaskException

module HsDev.Util

-- | Run action with current directory set
withCurrentDirectory :: FilePath -> IO a -> IO a

-- | Get directory contents safely
directoryContents :: FilePath -> IO [FilePath]

-- | Collect all file names in directory recursively
traverseDirectory :: FilePath -> IO [FilePath]

-- | Search something up
searchPath :: (MonadIO m, MonadPlus m) => FilePath -> (FilePath -> m a) -> m a

-- | Is one path parent of another
isParent :: FilePath -> FilePath -> Bool

-- | Is haskell source?
haskellSource :: FilePath -> Bool

-- | Is cabal file?
cabalFile :: FilePath -> Bool

-- | Add N tabs to line
tab :: Int -> String -> String

-- | Add N tabs to multiline
tabs :: Int -> String -> String

-- | Trim string
trim :: String -> String

-- | Split list
split :: (a -> Bool) -> [a] -> [[a]]

-- | Workaround, sometimes we get HM.lookup "foo" v == Nothing, but lookup
--   "foo" (HM.toList v) == Just smth
(.::) :: FromJSON a => HashMap Text Value -> Text -> Parser a
(.::?) :: FromJSON a => HashMap Text Value -> Text -> Parser (Maybe a)

-- | Union two JSON objects
objectUnion :: Value -> Value -> Value

-- | Lift IO exception to ErrorT
liftException :: MonadCatch m => m a -> ErrorT String m a

-- | Same as <tt>liftException</tt>
liftE :: MonadCatch m => m a -> ErrorT String m a

-- | <tt>liftE</tt> for IO
liftEIO :: (MonadCatch m, MonadIO m) => IO a -> ErrorT String m a

-- | Run actions ignoring errors
tries :: MonadPlus m => [m a] -> m [a]
triesMap :: MonadPlus m => (a -> m b) -> [a] -> m [b]

-- | Lift IO exception to MonadError
liftExceptionM :: (MonadCatch m, Error e, MonadError e m) => m a -> m a

-- | Lift IO exceptions to ErrorT
liftIOErrors :: MonadCatch m => ErrorT String m a -> ErrorT String m a
eitherT :: (Monad m, Error e, MonadError e m) => Either String a -> m a

-- | Throw error as exception
liftThrow :: (Show e, Error e, MonadError e m, MonadCatch m) => m a -> m a
fromUtf8 :: ByteString -> String
toUtf8 :: String -> ByteString

-- | Read file in UTF8
readFileUtf8 :: FilePath -> IO String
writeFileUtf8 :: FilePath -> String -> IO ()
hGetLineBS :: Handle -> IO ByteString
logException :: String -> (String -> IO ()) -> IO () -> IO ()
logIO :: String -> (String -> IO ()) -> IO () -> IO ()
ignoreIO :: IO () -> IO ()
liftTask :: (MonadThrow m, MonadCatch m, MonadIO m) => IO (Task a) -> ErrorT String m a

module Data.Mark

-- | Point at text: line and column
data Point
Point :: Int -> Int -> Point
pointLine :: Point -> Int
pointColumn :: Point -> Int

-- | Distance between points is measured in lines and columns. And it is
--   defined, that distance between point at l:c and point (l + 1):0 is one
--   line no matter c is because we need to go to new line to reach
--   destination point Columns are taken into account only if points are on
--   the same line <tt>pt .-. base</tt> is distance from <tt>base</tt> to
--   <tt>pt</tt> Distance can't be less then zero lines and columns
(.-.) :: Point -> Point -> Point

-- | Opposite to ".-.", <tt>(pt .-. base) .+. base = pt</tt>
(.+.) :: Point -> Point -> Point
type Size = Point

-- | Distance in <tt>n</tt> lines
linesSize :: Int -> Point

-- | Distance in <tt>n</tt> chars within one line
stringSize :: Int -> Point

-- | Region from <a>Point</a> to <a>Point</a>
data Region
Region :: Point -> Point -> Region
regionFrom :: Region -> Point
regionTo :: Region -> Point

-- | <a>Region</a> height in lines. Any <a>Region</a> at least of one line
--   height
regionLines :: Region -> Int

-- | Is <a>Region</a> empty
emptyRegion :: Region -> Bool

-- | n'th line region, starts at the beginning of line and ends on the next
--   line
line :: Int -> Region

-- | Make region
region :: Point -> Point -> Region

-- | Make region from starting point and its size
regionSize :: Point -> Size -> Region

-- | Get contents at specified region
at :: Editable a => Contents a -> Region -> Contents a

-- | Main idea is that there are only two basic actions , that chances
--   regions: inserting and cutting When something is cutted out or
--   inserted in, region positions must be updated All editings can be
--   represented as many cuts and inserts, so we can combine them to get
--   function which maps source regions to regions on updated data Because
--   insert is dual to cut (and therefore composes iso), we can also get
--   function to map regions back Combining this functions while edit, we
--   get function, that maps regions from source data to edited one To get
--   back function, we must also combine opposite actions, or we can
--   represent actions as isomorphisms Same idea goes for modifying
--   contents, represent each action as isomorphism and combine them
--   together
newtype Map
Map :: Iso' Region Region -> Map
mapIso :: Map -> Iso' Region Region

-- | Apply mapping
apply :: Map -> Region -> Region

-- | Back mapping
back :: Map -> Map

-- | Cut region mapping
cut :: Region -> Map

-- | Opposite to "cut"
insert :: Region -> Map

-- | Update second region position as if it was data cutted at first region
cutRegion :: Region -> Region -> Region

-- | Update second region position as if it was data inserted at first
--   region
insertRegion :: Region -> Region -> Region

-- | Contents is list of lines
type Contents a = [a]

-- | Edit data
data Edit a

-- | Map region from source contents to edited
Edit :: (Contents a -> Contents a) -> Map -> Edit a

-- | Edit contents splitted by lines
editCts :: Edit a -> Contents a -> Contents a
editMap :: Edit a -> Map

-- | Edit monad is state on <a>Edit</a>, it also collects region mappings
newtype EditM s a
EditM :: State (Edit s) a -> EditM s a
runEditM :: EditM s a -> State (Edit s) a

-- | Basic edit action in monad It takes region, region edit function and
--   contents updater and passes mapped region to these functions to get
--   new state
editRegion :: Region -> (Region -> Edit a) -> EditM a ()

-- | Get mapped region
mapRegion :: Region -> EditM a Region

-- | Run edit monad
runEdit :: Editable s => EditM s a -> (a, Edit s)

-- | Edit contents
edit :: Editable s => s -> EditM s a -> s

-- | Eval edit
editEval :: Editable s => s -> EditM s a -> (a, s)

-- | Prefix of contents cutted at some point
data Prefix a
Prefix :: [a] -> a -> Prefix a
prefixLines :: Prefix a -> [a]
prefixLine :: Prefix a -> a

-- | Make prefix from full contents
prefix :: Contents a -> Prefix a

-- | Suffix of contents
data Suffix a
Suffix :: a -> [a] -> Suffix a
suffixLine :: Suffix a -> a
suffixLines :: Suffix a -> [a]
suffix :: Contents a -> Suffix a

-- | Concat prefix and suffix. First line of suffix is appended to last
--   line of prefix
concatCts :: Monoid a => Prefix a -> Suffix a -> Contents a

-- | Split contents at point. First argument is function to split one line
--   at position.
splitCts :: Editable a => Point -> Contents a -> (Prefix a, Suffix a)
class Monoid a => Editable a
splitAt :: Editable a => Int -> a -> (a, a)
length :: Editable a => a -> Int
lines :: Editable a => a -> [a]
unlines :: Editable a => [a] -> a

-- | Contents size
measure :: Editable s => Contents s -> Size

-- | Erase data
erase :: Editable s => Region -> EditM s ()

-- | Paste data at position
write :: Editable s => Point -> Contents s -> EditM s ()

-- | Replace data with
replace :: Editable s => Region -> Contents s -> EditM s ()

-- | Replace action
data Replace s
Replace :: Region -> Contents s -> Replace s
replaceRegion :: Replace s -> Region
replaceWith :: Replace s -> Contents s
eraser :: Monoid s => Region -> Replace s
writer :: Editable s => Point -> s -> Replace s
replacer :: Editable s => Region -> s -> Replace s
run :: Editable s => [Replace s] -> EditM s ()
instance Eq Point
instance Ord Point
instance Read Point
instance Show Point
instance Eq Region
instance Ord Region
instance Read Region
instance Show Region
instance Functor (EditM s)
instance Applicative (EditM s)
instance Monad (EditM s)
instance MonadState (Edit s) (EditM s)
instance Eq a => Eq (Prefix a)
instance Ord a => Ord (Prefix a)
instance Read a => Read (Prefix a)
instance Show a => Show (Prefix a)
instance Eq a => Eq (Suffix a)
instance Ord a => Ord (Suffix a)
instance Read a => Read (Suffix a)
instance Show a => Show (Suffix a)
instance Eq s => Eq (Replace s)
instance Read s => Read (Replace s)
instance Show s => Show (Replace s)
instance (Editable s, FromJSON s) => FromJSON (Replace s)
instance (Editable s, ToJSON s) => ToJSON (Replace s)
instance Editable Text
instance Editable String
instance Functor Suffix
instance Functor Prefix
instance Monoid (Edit a)
instance Monoid Map
instance FromJSON Region
instance ToJSON Region
instance Monoid Size
instance FromJSON Point
instance ToJSON Point

module HsDev.Cabal

-- | Cabal or sandbox
data Cabal
Cabal :: Cabal
Sandbox :: FilePath -> Cabal

-- | Get sandbox
sandbox :: Cabal -> Maybe FilePath

-- | Is -package-db file
isPackageDb :: FilePath -> Bool

-- | Find -package-db path for sandbox directory or package-db file itself
findPackageDb :: FilePath -> IO (Maybe FilePath)

-- | Create sandbox by directory or package-db file
locateSandbox :: FilePath -> ErrorT String IO Cabal

-- | Try find sandbox by parent directory
getSandbox :: FilePath -> IO Cabal

-- | Search sandbox
searchSandbox :: FilePath -> IO Cabal

-- | Cabal ghc option
cabalOpt :: Cabal -> [String]
instance Eq Cabal
instance Ord Cabal
instance FromJSON Cabal
instance ToJSON Cabal
instance Show Cabal
instance NFData Cabal

module HsDev.Project

-- | Cabal project
data Project
Project :: String -> FilePath -> FilePath -> Maybe ProjectDescription -> Project
projectName :: Project -> String
projectPath :: Project -> FilePath
projectCabal :: Project -> FilePath
projectDescription :: Project -> Maybe ProjectDescription
data ProjectDescription
ProjectDescription :: Maybe Library -> [Executable] -> [Test] -> ProjectDescription
projectLibrary :: ProjectDescription -> Maybe Library
projectExecutables :: ProjectDescription -> [Executable]
projectTests :: ProjectDescription -> [Test]
class Target a
buildInfo :: Target a => a -> Info

-- | Library in project
data Library
Library :: [[String]] -> Info -> Library
libraryModules :: Library -> [[String]]
libraryBuildInfo :: Library -> Info

-- | Executable
data Executable
Executable :: String -> FilePath -> Info -> Executable
executableName :: Executable -> String
executablePath :: Executable -> FilePath
executableBuildInfo :: Executable -> Info

-- | Test
data Test
Test :: String -> Bool -> Info -> Test
testName :: Test -> String
testEnabled :: Test -> Bool
testBuildInfo :: Test -> Info

-- | Build info
data Info
Info :: [String] -> Maybe Language -> [Extension] -> [FilePath] -> Info
infoDepends :: Info -> [String]
infoLanguage :: Info -> Maybe Language
infoExtensions :: Info -> [Extension]
infoSourceDirs :: Info -> [FilePath]

-- | Read project info from .cabal
readProject :: FilePath -> ErrorT String IO Project

-- | Load project description
loadProject :: Project -> ErrorT String IO Project

-- | Find project sandbox
getProjectSandbox :: Project -> IO Cabal

-- | Make project by .cabal file
project :: FilePath -> Project

-- | Entity with project extensions
data Extensions a
Extensions :: [Extension] -> a -> Extensions a
extensions :: Extensions a -> [Extension]
entity :: Extensions a -> a

-- | Extensions for target
withExtensions :: a -> Info -> Extensions a

-- | Returns build targets infos
infos :: ProjectDescription -> [Info]

-- | Check if source related to target, source must be relative to project
--   directory
inTarget :: FilePath -> Info -> Bool

-- | Get target for source file
fileTarget :: Project -> FilePath -> Maybe Info

-- | Finds source dir file belongs to
findSourceDir :: Project -> FilePath -> Maybe FilePath

-- | Returns source dirs for library, executables and tests
sourceDirs :: ProjectDescription -> [Extensions FilePath]

-- | Extension as flag name
showExtension :: Extension -> String

-- | Convert -Xext to ext
flagExtension :: String -> Maybe String

-- | Convert ext to -Xext
extensionFlag :: String -> String

-- | Extensions as opts to GHC
extensionsOpts :: [Extension] -> [String]
instance Eq Info
instance Read Info
instance Eq Test
instance Read Test
instance Eq Executable
instance Read Executable
instance Eq Library
instance Read Library
instance Eq ProjectDescription
instance Read ProjectDescription
instance Read Project
instance Eq a => Eq (Extensions a)
instance Read a => Read (Extensions a)
instance Show a => Show (Extensions a)
instance Traversable Extensions
instance Foldable Extensions
instance Applicative Extensions
instance Functor Extensions
instance FromJSON Info
instance ToJSON Info
instance Show Info
instance FromJSON Test
instance ToJSON Test
instance Show Test
instance Target Test
instance FromJSON Executable
instance ToJSON Executable
instance Show Executable
instance Target Executable
instance FromJSON Library
instance ToJSON Library
instance Show Library
instance Target Library
instance FromJSON ProjectDescription
instance ToJSON ProjectDescription
instance Show ProjectDescription
instance FromJSON Project
instance ToJSON Project
instance Show Project
instance Ord Project
instance Eq Project
instance NFData Project

module HsDev.Server.Message

-- | Message with id to link request and response
data Message a
Message :: Maybe String -> a -> Message a
messageId :: Message a -> Maybe String
message :: Message a -> a

-- | Get messages by id
messagesById :: Maybe String -> [Message a] -> [a]

-- | Request from client
data Request
Request :: String -> [String] -> Opts String -> Request
requestCommand :: Request -> String
requestArgs :: Request -> [String]
requestOpts :: Request -> Opts String
requestToArgs :: Request -> Args

-- | Add options to request
withOpts :: Request -> [Opts String] -> Request

-- | Remove options from request
withoutOpts :: Request -> [String] -> Request

-- | Notification from server
data Notification
Notification :: Value -> Notification

-- | Result from server
data Result

-- | Result
Result :: Value -> Result

-- | Error
Error :: String -> (Map String Value) -> Result

-- | Part of result list, returns via notification
data ResultPart
ResultPart :: Value -> ResultPart
type Response = Either Notification Result
isNotification :: Response -> Bool
notification :: ToJSON a => a -> Response
result :: ToJSON a => a -> Response
responseError :: String -> [Pair] -> Response
resultPart :: ToJSON a => a -> Notification
groupResponses :: [Response] -> [([Notification], Result)]
responsesById :: Maybe String -> [Message Response] -> [([Notification], Result)]
instance Eq a => Eq (Message a)
instance Ord a => Ord (Message a)
instance Functor Message
instance FromJSON Response
instance ToJSON Response
instance FromJSON ResultPart
instance ToJSON ResultPart
instance FromJSON Result
instance ToJSON Result
instance FromJSON Notification
instance ToJSON Notification
instance FromJSON Request
instance ToJSON Request
instance Traversable Message
instance Foldable Message
instance FromJSON a => FromJSON (Message a)
instance ToJSON a => ToJSON (Message a)

module HsDev.Symbols.Location
data ModulePackage
ModulePackage :: String -> String -> ModulePackage
packageName :: ModulePackage -> String
packageVersion :: ModulePackage -> String

-- | Location of module
data ModuleLocation
FileModule :: FilePath -> Maybe Project -> ModuleLocation
moduleFile :: ModuleLocation -> FilePath
moduleProject :: ModuleLocation -> Maybe Project
CabalModule :: Cabal -> Maybe ModulePackage -> String -> ModuleLocation
moduleCabal :: ModuleLocation -> Cabal
modulePackage :: ModuleLocation -> Maybe ModulePackage
cabalModuleName :: ModuleLocation -> String
ModuleSource :: Maybe String -> ModuleLocation
moduleSourceName :: ModuleLocation -> Maybe String
moduleSource :: ModuleLocation -> Maybe FilePath
moduleProject_ :: ModuleLocation -> Maybe Project
moduleStandalone :: ModuleLocation -> Bool
moduleCabal_ :: ModuleLocation -> Maybe Cabal
moduleCabalPackage :: ModuleLocation -> Maybe ModulePackage
data Position
Position :: Int -> Int -> Position
positionLine :: Position -> Int
positionColumn :: Position -> Int
data Region
Region :: Position -> Position -> Region
regionFrom :: Region -> Position
regionTo :: Region -> Position
region :: Position -> Position -> Region
regionLines :: Region -> Int

-- | Get string at region
regionStr :: Region -> String -> String

-- | Location of symbol
data Location
Location :: ModuleLocation -> Maybe Position -> Location
locationModule :: Location -> ModuleLocation
locationPosition :: Location -> Maybe Position
packageOpt :: Maybe ModulePackage -> [String]

-- | Recalc position to interpret '\t' as one symbol instead of 8
recalcTabs :: String -> Position -> Position
instance Eq ModulePackage
instance Ord ModulePackage
instance Eq ModuleLocation
instance Ord ModuleLocation
instance Eq Position
instance Ord Position
instance Read Position
instance Eq Region
instance Ord Region
instance Read Region
instance Eq Location
instance Ord Location
instance FromJSON Location
instance ToJSON Location
instance Show Location
instance NFData Location
instance FromJSON Region
instance ToJSON Region
instance Show Region
instance NFData Region
instance FromJSON Position
instance ToJSON Position
instance Show Position
instance NFData Position
instance FromJSON ModuleLocation
instance ToJSON ModuleLocation
instance Show ModuleLocation
instance NFData ModuleLocation
instance FromJSON ModulePackage
instance ToJSON ModulePackage
instance Read ModulePackage
instance Show ModulePackage
instance NFData ModulePackage

module HsDev.Display
class Display a
display :: Display a => a -> String
displayType :: Display a => a -> String
instance Display FilePath
instance Display Project
instance Display ModuleLocation
instance Display Cabal

module HsDev.Symbols.Class
class Symbol a
symbolName :: Symbol a => a -> Text
symbolQualifiedName :: Symbol a => a -> Text
symbolDocs :: Symbol a => a -> Maybe Text
symbolLocation :: Symbol a => a -> Location
symbolModuleLocation :: Symbol a => a -> ModuleLocation

module HsDev.Symbols.Documented

-- | Documented symbol
class Symbol a => Documented a where detailed = unlines . defaultDetailed
brief :: Documented a => a -> String
detailed :: Documented a => a -> String

-- | Default detailed docs
defaultDetailed :: Documented a => a -> [String]

module HsDev.Symbols

-- | Module export
data Export
ExportName :: (Maybe Text) -> Text -> Export
ExportModule :: Text -> Export

-- | Get name of export
export :: Export -> Text

-- | Import list
data ImportList
ImportList :: Bool -> [Text] -> ImportList
hidingList :: ImportList -> Bool
importSpec :: ImportList -> [Text]

-- | Check whether name pass import list
passImportList :: ImportList -> Text -> Bool

-- | Module import
data Import
Import :: Text -> Bool -> Maybe Text -> Maybe ImportList -> Maybe Position -> Import
importModuleName :: Import -> Text
importIsQualified :: Import -> Bool
importAs :: Import -> Maybe Text
importList :: Import -> Maybe ImportList
importPosition :: Import -> Maybe Position

-- | Get import module name
importName :: Import -> Text

-- | Simple import
import_ :: Text -> Import
class Symbol a
symbolName :: Symbol a => a -> Text
symbolQualifiedName :: Symbol a => a -> Text
symbolDocs :: Symbol a => a -> Maybe Text
symbolLocation :: Symbol a => a -> Location

-- | Module id
data ModuleId
ModuleId :: Text -> ModuleLocation -> ModuleId
moduleIdName :: ModuleId -> Text
moduleIdLocation :: ModuleId -> ModuleLocation
unnamedModuleId :: ModuleLocation -> ModuleId

-- | Module
data Module
Module :: Text -> Maybe Text -> ModuleLocation -> Maybe [Export] -> [Import] -> [Declaration] -> Module
moduleName :: Module -> Text
moduleDocs :: Module -> Maybe Text
moduleLocation :: Module -> ModuleLocation
moduleExports :: Module -> Maybe [Export]
moduleImports :: Module -> [Import]
moduleDeclarations :: Module -> [Declaration]
sortDeclarations :: [Declaration] -> [Declaration]

-- | Bring locals to top
moduleLocals :: Module -> Module

-- | Set all declaration <a>definedIn</a> to this module
setDefinedIn :: Module -> Module

-- | Drop all declarations, that not defined in this module
dropExternals :: Module -> Module

-- | Clear <a>definedIn</a> information
clearDefinedIn :: Module -> Module

-- | Get declarations with locals
moduleLocalDeclarations :: Module -> [Declaration]

-- | Get list of declarations as ModuleDeclaration
moduleModuleDeclarations :: Module -> [ModuleDeclaration]
moduleId :: Module -> ModuleId
class Locals a
locals :: Locals a => a -> [Declaration]
where_ :: Locals a => a -> [Declaration] -> a

-- | Declaration
data Declaration
Declaration :: Text -> Maybe ModuleId -> Maybe [Import] -> Maybe Text -> Maybe Position -> DeclarationInfo -> Declaration
declarationName :: Declaration -> Text

-- | Where declaration defined, <tt>Nothing</tt> if here
declarationDefined :: Declaration -> Maybe ModuleId

-- | Declaration imported with. <tt>Nothing</tt> if unknown (cabal modules)
--   or here (source file)
declarationImported :: Declaration -> Maybe [Import]
declarationDocs :: Declaration -> Maybe Text
declarationPosition :: Declaration -> Maybe Position
declaration :: Declaration -> DeclarationInfo
decl :: Text -> DeclarationInfo -> Declaration
definedIn :: Declaration -> ModuleId -> Declaration
declarationLocals :: Declaration -> [Declaration]

-- | Get scopes of <tt>Declaration</tt>, where <tt>Nothing</tt> is global
--   scope
scopes :: Declaration -> [Maybe Text]

-- | Common info for type, newtype, data and class
data TypeInfo
TypeInfo :: Maybe Text -> [Text] -> Maybe Text -> TypeInfo
typeInfoContext :: TypeInfo -> Maybe Text
typeInfoArgs :: TypeInfo -> [Text]
typeInfoDefinition :: TypeInfo -> Maybe Text

-- | Declaration info
data DeclarationInfo
Function :: Maybe Text -> [Declaration] -> DeclarationInfo
functionType :: DeclarationInfo -> Maybe Text
localDeclarations :: DeclarationInfo -> [Declaration]
Type :: TypeInfo -> DeclarationInfo
typeInfo :: DeclarationInfo -> TypeInfo
NewType :: TypeInfo -> DeclarationInfo
newTypeInfo :: DeclarationInfo -> TypeInfo
Data :: TypeInfo -> DeclarationInfo
dataInfo :: DeclarationInfo -> TypeInfo
Class :: TypeInfo -> DeclarationInfo
classInfo :: DeclarationInfo -> TypeInfo

-- | Symbol in context of some module
data ModuleDeclaration
ModuleDeclaration :: ModuleId -> Declaration -> ModuleDeclaration
declarationModuleId :: ModuleDeclaration -> ModuleId
moduleDeclaration :: ModuleDeclaration -> Declaration

-- | Symbol exported with
data ExportedDeclaration
ExportedDeclaration :: [ModuleId] -> Declaration -> ExportedDeclaration
exportedBy :: ExportedDeclaration -> [ModuleId]
exportedDeclaration :: ExportedDeclaration -> Declaration

-- | Merge <tt>ModuleDeclaration</tt> into <tt>ExportedDeclaration</tt>
mergeExported :: [ModuleDeclaration] -> [ExportedDeclaration]

-- | Inspection data
data Inspection

-- | No inspection
InspectionNone :: Inspection

-- | Time and flags of inspection
InspectionAt :: POSIXTime -> [String] -> Inspection

-- | Get inspection opts
inspectionOpts :: Inspection -> [String]

-- | Inspected entity
data Inspected i a
Inspected :: Inspection -> i -> Either String a -> Inspected i a
inspection :: Inspected i a -> Inspection
inspectedId :: Inspected i a -> i
inspectionResult :: Inspected i a -> Either String a

-- | Inspected module
type InspectedModule = Inspected ModuleLocation Module
showTypeInfo :: TypeInfo -> String -> String -> String

-- | Get function type of type info
declarationInfo :: DeclarationInfo -> Either (Maybe Text, [Declaration]) TypeInfo

-- | Get type info of declaration
declarationTypeInfo :: DeclarationInfo -> Maybe TypeInfo
declarationTypeCtor :: String -> TypeInfo -> DeclarationInfo
declarationTypeName :: DeclarationInfo -> Maybe String

-- | Returns qualified name of symbol
qualifiedName :: ModuleId -> Declaration -> Text

-- | Imported module can be accessed via qualifier
importQualifier :: Maybe Text -> Import -> Bool

-- | Canonicalize all paths within something
class Canonicalize a
canonicalize :: Canonicalize a => a -> IO a

-- | Find project file is related to
locateProject :: FilePath -> IO (Maybe Project)

-- | Search project up
searchProject :: FilePath -> IO (Maybe Project)

-- | Locate source dir of file
locateSourceDir :: FilePath -> IO (Maybe FilePath)

-- | Get source module root directory, i.e. for "...srcFooBar.hs" with
--   module <a>Bar</a> will return "...src"
sourceModuleRoot :: Text -> FilePath -> FilePath

-- | Get path of imported module &gt;importedModulePath <a>Foo.Bar</a>
--   "...srcFooBar.hs" <a>Quux.Blah</a> = "...srcQuuxBlah.hs"
importedModulePath :: Text -> FilePath -> Text -> FilePath

-- | Add declaration to module
addDeclaration :: Declaration -> Module -> Module

-- | Unalias import name
unalias :: Module -> Text -> [Text]

-- | Module contents
moduleContents :: Module -> [String]
instance Eq Export
instance Ord Export
instance Eq ImportList
instance Ord ImportList
instance Eq Import
instance Ord Import
instance Eq ModuleId
instance Ord ModuleId
instance Eq TypeInfo
instance Ord TypeInfo
instance Read TypeInfo
instance Show TypeInfo
instance Ord DeclarationInfo
instance Eq Declaration
instance Ord Declaration
instance Ord Module
instance Eq ModuleDeclaration
instance Ord ModuleDeclaration
instance Eq ExportedDeclaration
instance Ord ExportedDeclaration
instance Eq Inspection
instance Ord Inspection
instance (Eq i, Eq a) => Eq (Inspected i a)
instance (Ord i, Ord a) => Ord (Inspected i a)
instance FromJSON InspectedModule
instance ToJSON InspectedModule
instance Show InspectedModule
instance (NFData i, NFData a) => NFData (Inspected i a)
instance Traversable (Inspected i)
instance Foldable (Inspected i)
instance Functor (Inspected i)
instance FromJSON Inspection
instance ToJSON Inspection
instance Read POSIXTime
instance Show Inspection
instance NFData Inspection
instance Documented ModuleDeclaration
instance Documented Declaration
instance Documented Module
instance Documented ModuleId
instance Canonicalize ModuleLocation
instance Canonicalize Project
instance Canonicalize Cabal
instance Canonicalize FilePath
instance FromJSON ExportedDeclaration
instance ToJSON ExportedDeclaration
instance Show ExportedDeclaration
instance NFData ExportedDeclaration
instance FromJSON ModuleDeclaration
instance ToJSON ModuleDeclaration
instance Show ModuleDeclaration
instance NFData ModuleDeclaration
instance Locals DeclarationInfo
instance FromJSON DeclarationInfo
instance ToJSON DeclarationInfo
instance Eq DeclarationInfo
instance NFData DeclarationInfo
instance FromJSON TypeInfo
instance ToJSON TypeInfo
instance NFData TypeInfo
instance Locals Declaration
instance FromJSON Declaration
instance ToJSON Declaration
instance Show Declaration
instance NFData Declaration
instance Show Module
instance Eq Module
instance NFData Module
instance FromJSON Module
instance ToJSON Module
instance FromJSON ModuleId
instance ToJSON ModuleId
instance Show ModuleId
instance NFData ModuleId
instance Symbol ModuleDeclaration
instance Symbol Declaration
instance Symbol ModuleId
instance Symbol Module
instance FromJSON Import
instance ToJSON Import
instance Show Import
instance NFData Import
instance FromJSON ImportList
instance ToJSON ImportList
instance Show ImportList
instance NFData ImportList
instance FromJSON Export
instance ToJSON Export
instance Show Export
instance NFData Export

module HsDev.Symbols.Util

-- | Get module project
projectOf :: ModuleId -> Maybe Project

-- | Get module cabal
cabalOf :: ModuleId -> Maybe Cabal

-- | Get module package
packageOf :: ModuleId -> Maybe ModulePackage

-- | Check if module in project
inProject :: Project -> ModuleId -> Bool

-- | Check if module in deps of project target
inDepsOfTarget :: Info -> ModuleId -> Bool

-- | Check if module in deps of source
inDepsOfFile :: Project -> FilePath -> ModuleId -> Bool

-- | Check if module in deps of project
inDepsOfProject :: Project -> ModuleId -> Bool

-- | Check if module in cabal
inCabal :: Cabal -> ModuleId -> Bool

-- | Check if module in package
inPackage :: String -> ModuleId -> Bool
inVersion :: String -> ModuleId -> Bool

-- | Check if module in file
inFile :: FilePath -> ModuleId -> Bool

-- | Check if module in source
inModuleSource :: Maybe String -> ModuleId -> Bool

-- | Check if declaration is in module
inModule :: String -> ModuleId -> Bool

-- | Check if module defined in file
byFile :: ModuleId -> Bool

-- | Check if module got from cabal database
byCabal :: ModuleId -> Bool

-- | Check if module is standalone
standalone :: ModuleId -> Bool

-- | Get list of imports
imports :: Module -> [Import]

-- | Get list of imports, which can be accessed with specified qualifier or
--   unqualified
qualifier :: Module -> Maybe String -> [Import]

-- | Check if module imported via imports specified
imported :: ModuleId -> [Import] -> Bool

-- | Check if module visible from this module within this project
visible :: Project -> ModuleId -> ModuleId -> Bool

-- | Check if module is in scope with qualifier
inScope :: Module -> Maybe String -> ModuleId -> Bool

-- | Select symbols with last package version
newestPackage :: Symbol a => [a] -> [a]

-- | Select module, defined by sources
sourceModule :: Maybe Project -> [Module] -> Maybe Module

-- | Select module, visible in project or cabal
visibleModule :: Cabal -> Maybe Project -> [Module] -> Maybe Module

-- | Select preferred visible module
preferredModule :: Cabal -> Maybe Project -> [ModuleId] -> Maybe ModuleId

-- | Remove duplicate modules, leave only <a>preferredModule</a>
uniqueModules :: Cabal -> Maybe Project -> [ModuleId] -> [ModuleId]

-- | Select value, satisfying to all predicates
allOf :: [a -> Bool] -> a -> Bool

-- | Select value, satisfying one of predicates
anyOf :: [a -> Bool] -> a -> Bool

module HsDev.Database

-- | HsDev database
data Database
Database :: Map ModuleLocation InspectedModule -> Map FilePath Project -> Database
databaseModules :: Database -> Map ModuleLocation InspectedModule
databaseProjects :: Database -> Map FilePath Project

-- | Database intersection, prefers first database data
databaseIntersection :: Database -> Database -> Database

-- | Check if database is empty
nullDatabase :: Database -> Bool

-- | Bring all locals to scope
databaseLocals :: Database -> Database

-- | All modules
allModules :: Database -> [Module]

-- | All declarations
allDeclarations :: Database -> [ModuleDeclaration]

-- | Make database from module
fromModule :: InspectedModule -> Database

-- | Make database from project
fromProject :: Project -> Database

-- | Filter database by predicate
filterDB :: (ModuleId -> Bool) -> (Project -> Bool) -> Database -> Database

-- | Project database
projectDB :: Project -> Database -> Database

-- | Cabal database
cabalDB :: Cabal -> Database -> Database

-- | Standalone database
standaloneDB :: Database -> Database

-- | Select module by predicate
selectModules :: (Module -> Bool) -> Database -> [Module]

-- | Select declaration by predicate
selectDeclarations :: (ModuleDeclaration -> Bool) -> Database -> [ModuleDeclaration]

-- | Lookup module by its location and name
lookupModule :: ModuleLocation -> Database -> Maybe Module

-- | Lookup module by its source file
lookupFile :: FilePath -> Database -> Maybe Module

-- | Refine project
refineProject :: Database -> Project -> Maybe Project

-- | Get inspected module
getInspected :: Database -> Module -> InspectedModule

-- | Append database
append :: Database -> Database -> Database

-- | Remove database
remove :: Database -> Database -> Database

-- | Structured database
data Structured
Structured :: Map Cabal Database -> Map FilePath Database -> Database -> Structured
structuredCabals :: Structured -> Map Cabal Database
structuredProjects :: Structured -> Map FilePath Database
structuredFiles :: Structured -> Database
structured :: [Database] -> [Database] -> Database -> Either String Structured
structurize :: Database -> Structured
merge :: Structured -> Database
instance Eq Database
instance Ord Database
instance Eq Structured
instance Ord Structured
instance FromJSON Structured
instance ToJSON Structured
instance Monoid Structured
instance Group Structured
instance NFData Structured
instance FromJSON Database
instance ToJSON Database
instance Monoid Database
instance Group Database
instance NFData Database

module HsDev.Cache

-- | Escape path
escapePath :: FilePath -> FilePath

-- | Name of cache for cabal
cabalCache :: Cabal -> FilePath

-- | Name of cache for projects
projectCache :: Project -> FilePath

-- | Name of cache for standalone files
standaloneCache :: FilePath

-- | Dump database to file
dump :: FilePath -> Database -> IO ()

-- | Load database from file, strict
load :: FilePath -> IO (Either String Database)

module HsDev.Cache.Structured

-- | Write cache
dump :: FilePath -> Structured -> IO ()

-- | Load all cache
load :: FilePath -> IO (Either String Structured)

-- | Load cabal from cache
loadCabal :: Cabal -> FilePath -> ErrorT String IO Structured

-- | Load project from cache
loadProject :: FilePath -> FilePath -> ErrorT String IO Structured

-- | Load standalone files
loadFiles :: (FilePath -> Bool) -> FilePath -> ErrorT String IO Structured

module HsDev.Database.Async
update :: MonadIO m => Async Database -> m Database -> m ()
clear :: MonadIO m => Async Database -> m Database -> m ()

-- | This function is used to ensure that all previous updates were applied
wait :: MonadIO m => Async Database -> m ()

module HsDev.Symbols.Resolve

-- | Resolve monad uses existing <tt>Database</tt> and
--   <tt>ResolvedTree</tt> as state.
newtype ResolveM a
ResolveM :: ReaderT Database (State ResolvedTree) a -> ResolveM a
runResolveM :: ResolveM a -> ReaderT Database (State ResolvedTree) a

-- | Tree of resolved modules
type ResolvedTree = Map ModuleId ResolvedModule

-- | Module with declarations bringed to scope and with exported
--   declarations
data ResolvedModule
ResolvedModule :: Module -> [Declaration] -> [Declaration] -> ResolvedModule
resolvedModule :: ResolvedModule -> Module
resolvedScope :: ResolvedModule -> [Declaration]
resolvedExports :: ResolvedModule -> [Declaration]

-- | Make <tt>Module</tt> with scope declarations
scopeModule :: ResolvedModule -> Module

-- | Make <tt>Module</tt> with exported only declarations
exportsModule :: ResolvedModule -> Module

-- | Get top-level scope
resolvedTopScope :: ResolvedModule -> [Declaration]

-- | Resolve modules, function is not IO, so all file names must be
--   canonicalized
resolve :: (Traversable t, Foldable t) => Database -> t Module -> t ResolvedModule

-- | Resolve one module
resolveOne :: Database -> Module -> ResolvedModule

-- | Resolve module
resolveModule :: Module -> ResolveM ResolvedModule

-- | Select declarations exported with <tt>Export</tt>
exported :: [Declaration] -> Export -> [Declaration]

-- | Bring declarations into scope
resolveImport :: Module -> Import -> ResolveM [Declaration]

-- | Merge imported declarations
mergeImported :: [Declaration] -> [Declaration]
instance Functor ResolveM
instance Applicative ResolveM
instance Monad ResolveM
instance MonadState ResolvedTree ResolveM
instance MonadReader Database ResolveM

module HsDev.Tools.Base
type Result = Either String String
type ToolM a = ErrorT String IO a

-- | Run command and wait for result
runWait :: FilePath -> [String] -> String -> IO Result

-- | Run command with no input
runWait_ :: FilePath -> [String] -> IO Result

-- | Tool
tool :: FilePath -> [String] -> String -> ToolM String

-- | Tool with no input
tool_ :: FilePath -> [String] -> ToolM String
matchRx :: String -> String -> Maybe (Int -> Maybe String)
splitRx :: String -> String -> [String]
replaceRx :: String -> String -> String -> String
at :: (Int -> Maybe String) -> Int -> String
inspect :: Monad m => ModuleLocation -> ErrorT String m Inspection -> ErrorT String m Module -> ErrorT String m InspectedModule
type ReadM a = StateT String [] a

-- | Parse readable value
readParse :: Read a => ReadM a

-- | Run parser
parseReads :: String -> ReadM a -> [a]

-- | Run parser and select first result
parseRead :: String -> ReadM a -> Maybe a

module HsDev.Commands

-- | Find declaration by name
findDeclaration :: Database -> String -> ErrorT String IO [ModuleDeclaration]

-- | Find module by name
findModule :: Database -> String -> ErrorT String IO [Module]

-- | Find module in file
fileModule :: Database -> FilePath -> ErrorT String IO Module

-- | Lookup visible within project symbol
lookupSymbol :: Database -> Cabal -> FilePath -> String -> ErrorT String IO [ModuleDeclaration]

-- | Whois symbol in scope
whois :: Database -> Cabal -> FilePath -> String -> ErrorT String IO [ModuleDeclaration]

-- | Accessible modules
scopeModules :: Database -> Cabal -> FilePath -> ErrorT String IO [Module]

-- | Symbols in scope
scope :: Database -> Cabal -> FilePath -> Bool -> ErrorT String IO [ModuleDeclaration]

-- | Completions
completions :: Database -> Cabal -> FilePath -> String -> Bool -> ErrorT String IO [ModuleDeclaration]

-- | Module completions
moduleCompletions :: Database -> [Module] -> String -> ErrorT String IO [String]

-- | Check module
checkModule :: (ModuleId -> Bool) -> (ModuleDeclaration -> Bool)

-- | Check declaration
checkDeclaration :: (Declaration -> Bool) -> (ModuleDeclaration -> Bool)

-- | Allow only selected cabal sandbox
restrictCabal :: Cabal -> ModuleId -> Bool

-- | Check whether module is visible from source file
visibleFrom :: Maybe Project -> Module -> ModuleId -> Bool

-- | Split identifier into module name and identifier itself
splitIdentifier :: String -> (Maybe String, String)

-- | Get context file and project
fileCtx :: Database -> FilePath -> ErrorT String IO (FilePath, Module, Maybe Project)

-- | Try get context file
fileCtxMaybe :: Database -> FilePath -> ErrorT String IO (FilePath, Maybe Module, Maybe Project)

module HsDev.Tools.Cabal
data CabalPackage
CabalPackage :: String -> Maybe String -> Maybe Version -> [Version] -> Maybe String -> Maybe License -> CabalPackage
cabalPackageName :: CabalPackage -> String
cabalPackageSynopsis :: CabalPackage -> Maybe String
cabalPackageDefaultVersion :: CabalPackage -> Maybe Version
cabalPackageInstalledVersions :: CabalPackage -> [Version]
cabalPackageHomepage :: CabalPackage -> Maybe String
cabalPackageLicense :: CabalPackage -> Maybe License
cabalList :: [String] -> ToolM [CabalPackage]
instance Eq CabalPackage
instance Read CabalPackage
instance Show CabalPackage
instance FromJSON CabalPackage
instance ToJSON CabalPackage

module HsDev.Tools.HDocs

-- | Get docs for module
hdocs :: ModuleLocation -> [String] -> IO (Map String String)

-- | Get all docs
hdocsCabal :: Cabal -> [String] -> ErrorT String IO (Map String (Map String String))

-- | Set docs for module
setDocs :: Map String String -> Module -> Module

-- | Load docs for module
loadDocs :: [String] -> Module -> IO Module
hdocsProcess :: String -> [String] -> IO (Maybe (Map String String))

module HsDev.Inspect

-- | Analize source contents
analyzeModule :: [String] -> Maybe FilePath -> String -> Either String Module

-- | Extract file docs and set them to module declarations
inspectDocs :: [String] -> Module -> ErrorT String IO Module

-- | Inspect contents
inspectContents :: String -> [String] -> String -> ErrorT String IO InspectedModule
contentsInspection :: String -> [String] -> ErrorT String IO Inspection

-- | Inspect file
inspectFile :: [String] -> FilePath -> ErrorT String IO InspectedModule

-- | File inspection data
fileInspection :: FilePath -> [String] -> ErrorT String IO Inspection

-- | Enumerate project dirs
projectDirs :: Project -> ErrorT String IO [Extensions FilePath]

-- | Enumerate project source files
projectSources :: Project -> ErrorT String IO [Extensions FilePath]

-- | Inspect project
inspectProject :: [String] -> Project -> ErrorT String IO (Project, [InspectedModule])

module HsDev.Scan.Browse

-- | Browse packages
browsePackages :: [String] -> Cabal -> ErrorT String IO [ModulePackage]
listModules :: [String] -> Cabal -> ErrorT String IO [ModuleLocation]
browseModules :: [String] -> Cabal -> [ModuleLocation] -> ErrorT String IO [InspectedModule]

-- | Browse all modules
browse :: [String] -> Cabal -> ErrorT String IO [InspectedModule]

module HsDev.Tools.Hayoo

-- | Hayoo response
data HayooResult
HayooResult :: Int -> Int -> Int -> [HayooSymbol] -> HayooResult
resultMax :: HayooResult -> Int
resultOffset :: HayooResult -> Int
resultCount :: HayooResult -> Int
resultResult :: HayooResult -> [HayooSymbol]

-- | Hayoo symbol
data HayooSymbol
HayooSymbol :: String -> String -> String -> String -> String -> String -> String -> [String] -> Double -> String -> HayooSymbol
resultUri :: HayooSymbol -> String
tag :: HayooSymbol -> String
hayooPackage :: HayooSymbol -> String
hayooName :: HayooSymbol -> String
hayooSource :: HayooSymbol -> String
hayooDescription :: HayooSymbol -> String
hayooSignature :: HayooSymbol -> String
hayooModules :: HayooSymbol -> [String]
hayooScore :: HayooSymbol -> Double
hayooType :: HayooSymbol -> String

-- | <tt>HayooFunction</tt> as <a>Declaration</a>
hayooAsDeclaration :: HayooSymbol -> Maybe ModuleDeclaration

-- | Search hayoo
hayoo :: String -> Maybe Int -> ErrorT String IO HayooResult

-- | Remove tags in description
untagDescription :: String -> String
instance Eq HayooSymbol
instance Ord HayooSymbol
instance Read HayooSymbol
instance Show HayooSymbol
instance Eq HayooResult
instance Ord HayooResult
instance Read HayooResult
instance Show HayooResult
instance FromJSON HayooValue
instance FromJSON HayooSymbol
instance Documented HayooSymbol
instance Symbol HayooSymbol
instance FromJSON HayooResult

module HsDev.Tools.ClearImports

-- | Dump minimal imports
dumpMinimalImports :: [String] -> FilePath -> ErrorT String IO String

-- | Read imports from file
waitImports :: FilePath -> IO [String]

-- | Clean temporary files
cleanTmpImports :: FilePath -> IO ()

-- | Dump and read imports
findMinimalImports :: [String] -> FilePath -> ErrorT String IO [String]

-- | Groups several lines related to one import by indents
groupImports :: [String] -> [[String]]

-- | Split import to import and import-list
splitImport :: [String] -> (String, String)

-- | Returns minimal imports for file specified
clearImports :: [String] -> FilePath -> ErrorT String IO [(String, String)]

module Control.Concurrent.FiniteChan

-- | <a>Chan</a> is stoppable channel unline <a>Chan</a>
data Chan a

-- | Create channel
newChan :: IO (Chan a)

-- | Duplicate channel
dupChan :: Chan a -> IO (Chan a)

-- | Write data to channel
putChan :: Chan a -> a -> IO ()

-- | Get data from channel
getChan :: Chan a -> IO (Maybe a)

-- | Read channel contents
readChan :: Chan a -> IO [a]

-- | Close channel. <a>putChan</a> will still work, but no data will be
--   available on other ending
closeChan :: Chan a -> IO ()

-- | Stop channel and return all data
stopChan :: Chan a -> IO [a]

module Control.Concurrent.Worker
data Worker m
Worker :: Chan (Task (), m ()) -> (forall a. m a -> m a) -> MVar (Task ()) -> IO Bool -> Worker m
workerChan :: Worker m -> Chan (Task (), m ())
workerWrap :: Worker m -> forall a. m a -> m a
workerTask :: Worker m -> MVar (Task ())
workerRestart :: Worker m -> IO Bool
startWorker :: MonadIO m => (m () -> IO ()) -> (m () -> m ()) -> (forall a. m a -> m a) -> IO (Worker m)
sendTask :: (MonadCatch m, MonadIO m) => Worker m -> m a -> IO (Task a)
pushTask :: (MonadCatch m, MonadIO m) => Worker m -> m a -> IO (Task a)
stopWorker :: Worker m -> IO ()

module HsDev.Tools.GhcMod
list :: [String] -> Cabal -> ErrorT String IO [ModuleLocation]
browse :: [String] -> Cabal -> String -> Maybe ModulePackage -> ErrorT String IO InspectedModule
browseInspection :: [String] -> Inspection
langs :: ErrorT String IO [String]
flags :: ErrorT String IO [String]
info :: [String] -> Cabal -> FilePath -> String -> GhcModT IO Declaration
data TypedRegion
TypedRegion :: Region -> String -> String -> TypedRegion
typedRegion :: TypedRegion -> Region
typedExpr :: TypedRegion -> String
typedType :: TypedRegion -> String
typeOf :: [String] -> Cabal -> FilePath -> Int -> Int -> GhcModT IO [TypedRegion]
data OutputMessage
OutputMessage :: Location -> OutputMessageLevel -> String -> OutputMessage
errorLocation :: OutputMessage -> Location
errorLevel :: OutputMessage -> OutputMessageLevel
errorMessage :: OutputMessage -> String
parseOutputMessages :: String -> [OutputMessage]
parseOutputMessage :: String -> Maybe OutputMessage
check :: [String] -> Cabal -> [FilePath] -> Maybe Project -> GhcModT IO [OutputMessage]
lint :: [String] -> FilePath -> GhcModT IO [OutputMessage]
runGhcMod :: (IOish m, MonadCatch m) => Options -> GhcModT m a -> ErrorT String m a
locateGhcModEnv :: FilePath -> IO (Either Project Cabal)
ghcModEnvPath :: FilePath -> Either Project Cabal -> FilePath

-- | Create ghc-mod worker for project or for sandbox
ghcModWorker :: Either Project Cabal -> IO (Worker (GhcModT IO))
type WorkerMap = MVar (Map FilePath (Worker (GhcModT IO)))

-- | Manage many ghc-mod workers for each project/sandbox
ghcModMultiWorker :: IO (Worker (ReaderT WorkerMap IO))
dispatch :: FilePath -> GhcModT IO a -> ReaderT WorkerMap IO (Task a)
waitMultiGhcMod :: Worker (ReaderT WorkerMap IO) -> FilePath -> GhcModT IO a -> ErrorT String IO a

-- | This is basically a newtype wrapper around <a>StateT</a>,
--   <a>ErrorT</a>, <a>JournalT</a> and <a>ReaderT</a> with custom
--   instances for <a>GhcMonad</a> and it's constraints that means you can
--   run (almost) all functions from the GHC API on top of <a>GhcModT</a>
--   transparently.
--   
--   The inner monad <tt>m</tt> should have instances for <a>MonadIO</a>
--   and <a>MonadBaseControl</a> <a>IO</a>, in the common case this is
--   simply <a>IO</a>. Most <tt>mtl</tt> monads already have
--   <a>MonadBaseControl</a> <a>IO</a> instances, see the
--   <tt>monad-control</tt> package.
data GhcModT (m :: * -> *) a :: (* -> *) -> * -> *
instance Eq TypedRegion
instance Ord TypedRegion
instance Read TypedRegion
instance Show TypedRegion
instance Eq OutputMessageLevel
instance Ord OutputMessageLevel
instance Bounded OutputMessageLevel
instance Enum OutputMessageLevel
instance Read OutputMessageLevel
instance Show OutputMessageLevel
instance Eq OutputMessage
instance Show OutputMessage
instance MonadCatch (GhcModT IO)
instance MonadThrow (GhcModT IO)
instance FromJSON OutputMessage
instance ToJSON OutputMessage
instance NFData OutputMessage
instance FromJSON OutputMessageLevel
instance ToJSON OutputMessageLevel
instance NFData OutputMessageLevel
instance FromJSON TypedRegion
instance ToJSON TypedRegion
instance NFData TypedRegion

module HsDev.Scan

-- | Enum cabal modules
enumCabal :: [String] -> Cabal -> ErrorT String IO [ModuleLocation]

-- | Compile flags
type CompileFlag = String

-- | Module with flags ready to scan
type ModuleToScan = (ModuleLocation, [CompileFlag])

-- | Project ready to scan
type ProjectToScan = (Project, [ModuleToScan])

-- | Cabal sandbox to scan
type SandboxToScan = Cabal

-- | Scan info
data ScanContents
ScanContents :: [ModuleToScan] -> [ProjectToScan] -> [SandboxToScan] -> ScanContents
modulesToScan :: ScanContents -> [ModuleToScan]
projectsToScan :: ScanContents -> [ProjectToScan]
sandboxesToScan :: ScanContents -> [SandboxToScan]

-- | Enum project sources
enumProject :: Project -> ErrorT String IO ProjectToScan

-- | Enum directory modules
enumDirectory :: FilePath -> ErrorT String IO ScanContents

-- | Scan project file
scanProjectFile :: [String] -> FilePath -> ErrorT String IO Project

-- | Scan module
scanModule :: [String] -> ModuleLocation -> ErrorT String IO InspectedModule

-- | Scan additional info and modify scanned module. Dones't fail on error,
--   just left module unchanged
scanModify :: ([String] -> Cabal -> Module -> ErrorT String IO Module) -> InspectedModule -> ErrorT String IO InspectedModule

-- | Is inspected module up to date?
upToDate :: [String] -> InspectedModule -> ErrorT String IO Bool

-- | Rescan inspected module
rescanModule :: [String] -> InspectedModule -> ErrorT String IO (Maybe InspectedModule)

-- | Is module new or recently changed
changedModule :: Database -> [String] -> ModuleLocation -> ErrorT String IO Bool

-- | Returns new (to scan) and changed (to rescan) modules
changedModules :: Database -> [String] -> [ModuleToScan] -> ErrorT String IO [ModuleToScan]

module HsDev

module HsDev.Tools.AutoFix
data Correction
Correction :: FilePath -> String -> String -> String -> String -> Replace String -> Correction
correctionFile :: Correction -> FilePath
correctionType :: Correction -> String
description :: Correction -> String
message :: Correction -> String
solution :: Correction -> String
corrector :: Correction -> Replace String
correct :: Correction -> EditM String ()
corrections :: [OutputMessage] -> [Correction]

-- | Apply corrections
autoFix_ :: [Correction] -> EditM String ()

-- | Apply corrections and update rest correction positions
autoFix :: [Correction] -> [Correction] -> EditM String [Correction]
updateRegion :: Correction -> EditM String Correction
type CorrectorMatch = FilePath -> Point -> String -> Maybe Correction
correctors :: [CorrectorMatch]
match :: String -> ((Int -> Maybe String) -> FilePath -> Point -> Correction) -> CorrectorMatch
findCorrector :: FilePath -> Point -> String -> Maybe Correction

-- | Canonicalize all paths within something
class Canonicalize a
canonicalize :: Canonicalize a => a -> IO a
instance Eq Correction
instance Read Correction
instance Show Correction
instance FromJSON Correction
instance ToJSON Correction
instance Canonicalize Correction

module HsDev.Tools.GhcMod.InferType

-- | Is declaration untyped
untyped :: DeclarationInfo -> Bool

-- | Infer type of declaration
inferType :: [String] -> Cabal -> FilePath -> Declaration -> GhcModT IO Declaration

-- | Infer types for module
inferTypes :: [String] -> Cabal -> Module -> GhcModT IO Module

-- | This is basically a newtype wrapper around <a>StateT</a>,
--   <a>ErrorT</a>, <a>JournalT</a> and <a>ReaderT</a> with custom
--   instances for <a>GhcMonad</a> and it's constraints that means you can
--   run (almost) all functions from the GHC API on top of <a>GhcModT</a>
--   transparently.
--   
--   The inner monad <tt>m</tt> should have instances for <a>MonadIO</a>
--   and <a>MonadBaseControl</a> <a>IO</a>, in the common case this is
--   simply <a>IO</a>. Most <tt>mtl</tt> monads already have
--   <a>MonadBaseControl</a> <a>IO</a> instances, see the
--   <tt>monad-control</tt> package.
data GhcModT (m :: * -> *) a :: (* -> *) -> * -> *

-- | Infer type in module
infer :: [String] -> Cabal -> Module -> ErrorT String IO Module

module HsDev.Database.Update
data Status
StatusWorking :: Status
StatusOk :: Status
StatusError :: String -> Status
data Progress
Progress :: Int -> Int -> Progress
progressCurrent :: Progress -> Int
progressTotal :: Progress -> Int
data Task
Task :: String -> Status -> Object -> Maybe Progress -> Maybe Task -> Task
taskName :: Task -> String
taskStatus :: Task -> Status
taskParams :: Task -> Object
taskProgress :: Task -> Maybe Progress
taskChild :: Task -> Maybe Task
isStatus :: Value -> Bool
data Settings
Settings :: Async Database -> ((FilePath -> ErrorT String IO Structured) -> IO (Maybe Database)) -> (Database -> IO ()) -> (Task -> IO ()) -> [String] -> Settings
database :: Settings -> Async Database
databaseCacheReader :: Settings -> (FilePath -> ErrorT String IO Structured) -> IO (Maybe Database)
databaseCacheWriter :: Settings -> Database -> IO ()
onStatus :: Settings -> Task -> IO ()
ghcOptions :: Settings -> [String]
data UpdateDB m a

-- | Run <a>UpdateDB</a> monad
updateDB :: MonadIO m => Settings -> ErrorT String (UpdateDB m) () -> m ()

-- | Post status
postStatus :: (MonadIO m, MonadReader Settings m) => Task -> m ()

-- | Wait DB to complete actions
waiter :: (MonadIO m, MonadReader Settings m) => m () -> m ()

-- | Update task result to database
updater :: (MonadIO m, MonadReader Settings m, MonadWriter [ModuleLocation] m) => m Database -> m ()

-- | Get data from cache without updating DB
loadCache :: (MonadIO m, MonadReader Settings m, MonadWriter [ModuleLocation] m) => (FilePath -> ErrorT String IO Structured) -> m Database

-- | Load data from cache if not loaded yet and wait
getCache :: (MonadIO m, MonadReader Settings m, MonadWriter [ModuleLocation] m) => (FilePath -> ErrorT String IO Structured) -> (Database -> Database) -> m Database

-- | Run one task
runTask :: MonadIO m => String -> [Pair] -> ErrorT String (UpdateDB m) a -> ErrorT String (UpdateDB m) a

-- | Run many tasks with numeration
runTasks :: Monad m => [ErrorT String (UpdateDB m) ()] -> ErrorT String (UpdateDB m) ()

-- | Get database value
readDB :: (MonadIO m, MonadReader Settings m) => m Database

-- | Scan module
scanModule :: (MonadIO m, MonadCatch m) => [String] -> ModuleLocation -> ErrorT String (UpdateDB m) ()

-- | Scan modules
scanModules :: (MonadIO m, MonadCatch m) => [String] -> [ModuleToScan] -> ErrorT String (UpdateDB m) ()

-- | Scan source file
scanFile :: (MonadIO m, MonadCatch m) => [String] -> FilePath -> ErrorT String (UpdateDB m) ()

-- | Scan cabal modules
scanCabal :: (MonadIO m, MonadCatch m) => [String] -> Cabal -> ErrorT String (UpdateDB m) ()

-- | Scan project file
scanProjectFile :: (MonadIO m, MonadCatch m) => [String] -> FilePath -> ErrorT String (UpdateDB m) Project

-- | Scan project
scanProject :: (MonadIO m, MonadCatch m) => [String] -> FilePath -> ErrorT String (UpdateDB m) ()

-- | Scan directory for source files and projects
scanDirectory :: (MonadIO m, MonadCatch m) => [String] -> FilePath -> ErrorT String (UpdateDB m) ()

-- | Generic scan function. Reads cache only if data is not already loaded,
--   removes obsolete modules and rescans changed modules.
scan :: (MonadIO m, MonadCatch m) => (FilePath -> ErrorT String IO Structured) -> (Database -> Database) -> [ModuleToScan] -> [String] -> ([ModuleToScan] -> ErrorT String (UpdateDB m) ()) -> ErrorT String (UpdateDB m) ()

-- | Lift errors
liftErrorT :: MonadIO m => ErrorT String IO a -> ErrorT String m a
instance Applicative m => Applicative (UpdateDB m)
instance Monad m => Monad (UpdateDB m)
instance MonadIO m => MonadIO (UpdateDB m)
instance MonadThrow m => MonadThrow (UpdateDB m)
instance MonadCatch m => MonadCatch (UpdateDB m)
instance Functor m => Functor (UpdateDB m)
instance Monad m => MonadReader Settings (UpdateDB m)
instance Monad m => MonadWriter [ModuleLocation] (UpdateDB m)
instance FromJSON Task
instance ToJSON Task
instance FromJSON Progress
instance ToJSON Progress
instance FromJSON Status
instance ToJSON Status

module HsDev.Tools.Ghc.Worker
ghcWorker :: IO (Worker Ghc)
evaluate :: String -> Ghc String

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
data Ghc a :: * -> *
instance MonadCatch Ghc
instance MonadThrow Ghc

module HsDev.Server.Types
data CommandOptions
CommandOptions :: Async Database -> (Database -> IO ()) -> ((FilePath -> ErrorT String IO Structured) -> IO (Maybe Database)) -> FilePath -> (String -> IO ()) -> (([String] -> IO ()) -> IO ()) -> IO () -> Worker Ghc -> Worker (ReaderT WorkerMap IO) -> (Notification -> IO ()) -> IO () -> IO () -> IO () -> CommandOptions
commandDatabase :: CommandOptions -> Async Database
commandWriteCache :: CommandOptions -> Database -> IO ()
commandReadCache :: CommandOptions -> (FilePath -> ErrorT String IO Structured) -> IO (Maybe Database)
commandRoot :: CommandOptions -> FilePath
commandLog :: CommandOptions -> String -> IO ()
commandListenLog :: CommandOptions -> ([String] -> IO ()) -> IO ()
commandLogWait :: CommandOptions -> IO ()
commandGhc :: CommandOptions -> Worker Ghc
commandGhcMod :: CommandOptions -> Worker (ReaderT WorkerMap IO)
commandNotify :: CommandOptions -> Notification -> IO ()
commandLink :: CommandOptions -> IO ()
commandHold :: CommandOptions -> IO ()
commandExit :: CommandOptions -> IO ()
data CommandError
CommandError :: String -> [Pair] -> CommandError
commandError :: String -> [Pair] -> ErrorT CommandError IO a
type CommandAction = CommandOptions -> IO Result
type CommandM a = ErrorT CommandError IO a
type CommandActionT a = CommandOptions -> CommandM a
data ResultValue
ResultDatabase :: Database -> ResultValue
ResultDeclaration :: Declaration -> ResultValue
ResultModuleDeclaration :: ModuleDeclaration -> ResultValue
ResultModuleId :: ModuleId -> ResultValue
ResultModule :: Module -> ResultValue
ResultInspectedModule :: InspectedModule -> ResultValue
ResultPackage :: ModulePackage -> ResultValue
ResultProject :: Project -> ResultValue
ResultTyped :: TypedRegion -> ResultValue
ResultOutputMessage :: OutputMessage -> ResultValue
ResultList :: [ResultValue] -> ResultValue
ResultMap :: (Map String ResultValue) -> ResultValue
ResultJSON :: Value -> ResultValue
ResultString :: String -> ResultValue
ResultNone :: ResultValue
instance FromJSON ResultValue
instance ToJSON ResultValue
instance Error CommandError

module HsDev.Client.Commands

-- | Client commands
commands :: [Cmd CommandAction]

module Control.Apply.Util
(&) :: a -> (a -> b) -> b
chain :: [a -> a] -> a -> a

-- | Flipped version of <a>chain</a>, which can be used like this:
--   
--   <pre>
--   foo `with` [f, g, h]
--   </pre>
with :: a -> [a -> a] -> a

module HsDev.Server.Commands

-- | Server commands
commands :: [Cmd (IO ())]

-- | Server options
serverOpts :: [Opt]

-- | Server default options
serverDefCfg :: Opts String

-- | Client options
clientOpts :: [Opt]

-- | Client default options
clientDefCfg :: Opts String

-- | Command to send to client
clientCmd :: Cmd CommandAction -> Cmd (IO ())

-- | Send command to server
sendCmd :: String -> Args -> IO ()

-- | Inits log chan and returns functions (print message, wait channel)
initLog :: Opts String -> IO (String -> IO (), ([String] -> IO ()) -> IO (), IO ())

-- | Run server
runServer :: Opts String -> (CommandOptions -> IO ()) -> IO ()

-- | Process request, notifications can be sent during processing
processRequest :: CommandOptions -> (Notification -> IO ()) -> Request -> IO Result

-- | Process client, listen for requests and process them
processClient :: String -> IO ByteString -> (ByteString -> IO ()) -> CommandOptions -> IO ()

-- | Perform action on cache
withCache :: Opts String -> a -> (FilePath -> IO a) -> IO a
writeCache :: Opts String -> (String -> IO ()) -> Database -> IO ()
readCache :: Opts String -> (String -> IO ()) -> (FilePath -> ErrorT String IO Structured) -> IO (Maybe Database)
