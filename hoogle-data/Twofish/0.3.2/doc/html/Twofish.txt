-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the Twofish Symmetric-key cipher.
--   
--   Implements the Twofish symmetric block cipher, designed by: Bruce
--   Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall, and
--   Niels Ferguson.
--   
--   As well, this module includes some generic definitions for ciphers and
--   cipher-block-chaining mode in the Data.Cipher module. In the future,
--   these should probably either be moved to their own package, or all of
--   this should be merged into the Crypto package.
--   
--   Acknowledgments:
--   
--   Dominic Steinitz, Caylee Hogg and Thomas DuBuisson for their work on
--   the Crypto package, upon which this package depends.
--   
--   Stephen Tetley for his advice and code examples provided on the
--   Haskell-Beginners mailing list in response to a question I had, which
--   helped me to create a transformer version of the Cbc monad. (now
--   deprecated in favor of the CBC definitions in crypto-api)
@package Twofish
@version 0.3.2

module Data.Bitlib
pack :: (Integral a, Bits a, Integral b, Bits b) => [a] -> b
packMany :: (Integral a, Bits a, Num b, Integral b, Bits b) => b -> [a] -> [b]
unpack :: (Integral a, Bits a, Num b, Bits b) => a -> [b]
unpackMany :: (Integral a, Bits a, Num b, Bits b) => [a] -> [b]


-- | Implements the Twofish symmetric block cipher, designed by: Bruce
--   Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall, and
--   Niels Ferguson.
--   
--   Implemented from the paper entitled <a>Twofish: A 128-Bit Block
--   Cipher</a>, <a>http://www.counterpane.com/twofish.html</a> with help
--   from the reference C implementation.
--   
--   This module provides two methods for constructiong a Twofish cipher
--   from a 128, 192 or 256 bit key. The mkCipher function allows you to
--   customize the number of rounds, while the mkStdCipher function gives
--   you the standard 16 rounds.
module Codec.Encryption.Twofish

-- | A key is a vector of bytes of a certain size (given in bits). Twofish
--   suppports key sizes of 128, 192, and 256 bits.
class (Bits a, Integral a) => Key a where keyByte w n = let w' = fromIntegral w :: Integer in fromIntegral $ (w' `shiftR` (8 * n)) .&. 255

-- | A keyed Twofish cipher capable of both encryption and decryption.
data TwofishCipher

-- | Constructs a standard Twofish cipher from the given key
mkStdCipher :: Key a => a -> TwofishCipher

-- | Constructs an encryption/decryption cipher from the given key, and a
--   given number of rounds (standard Twofish uses 16 rounds)
mkCipher :: Key a => Int -> a -> TwofishCipher
encrypt :: TwofishCipher -> Word128 -> Word128
decrypt :: TwofishCipher -> Word128 -> Word128
mkS :: Key a => a -> SVector
mkfH :: Key a => a -> HFunc
mkK :: Key a => a -> Int -> HFunc -> KIndexor
mkG :: HFunc -> SVector -> GFunc

-- | This function performs n rounds of the encryption algorithm
encryptRounds :: GFunc -> KIndexor -> Int -> Block -> Block

-- | Generates the <tt>q0</tt> byte vector using the algorithm specified in
--   the Twofish paper. This function isn't used by the cipher; instead the
--   pre-computed array is contained in the code.
q0o :: Word8 -> Word8

-- | Generates the <tt>q1</tt> byte vector using the algorithm specified in
--   the Twofish paper. This function isn't used by the cipher; instead the
--   pre-computed array is contained in the code.
q1o :: Word8 -> Word8
instance BlockCipher TwofishKey
instance Serialize TwofishKey
instance Binary TwofishKey
instance Key Word256
instance Key Word192
instance Key Word128
