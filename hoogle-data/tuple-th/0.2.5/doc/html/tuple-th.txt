-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate (non-recursive) utility functions for tuples of statically known size
--   
@package tuple-th
@version 0.2.5


-- | Note: One-tuples are currently understood as just the original type by
--   Template Haskell (though this could be an undefined case which is not
--   guaranteed to work this way?), so for example, we get
--   
--   <pre>
--   $(<a>catTuples</a> 1 2) = \x (y,z) -&gt; (x,y,z)
--   </pre>
module TupleTH

-- | Type of the generated expression:
--   
--   <pre>
--   (a -&gt; b) -&gt; (a, ..) -&gt; (b, ..)
--   </pre>
mapTuple :: Int -> ExpQ

-- | Takes the mapping as a quoted expression. This can sometimes produce
--   an expression that typechecks when the analogous expression using
--   <a>filterTuple</a> does not, e.g.:
--   
--   <pre>
--   $(mapTuple 2) Just        ((),"foo") -- Type error
--   $(mapTuple' 2 [| Just |]) ((),"foo") -- OK
--   </pre>
mapTuple' :: Int -> ExpQ -> Q Exp

-- | Type of the generated expression:
--   
--   <pre>
--   (a -&gt; Bool) -&gt; (a, ..) -&gt; [a]
--   </pre>
filterTuple :: Int -> ExpQ

-- | Takes the predicate as a quoted expression. See <a>mapTuple'</a> for
--   how this can be useful.
filterTuple' :: Int -> ExpQ -> ExpQ

-- | <tt>reindexTuple n js</tt> =&gt;
--   
--   <pre>
--   \(x_0, ..., x_{n-1}) -&gt; (x_{js !! 0}, x_{js !! 1}, ... x_{last js})
--   </pre>
--   
--   For example,
--   
--   <pre>
--   $(reindexTuple 3 [1,1,0,0]) ('a','b','c') == ('b','b','a','a')
--   </pre>
--   
--   Each element of <tt>js</tt> must be nonnegative and less than
--   <tt>n</tt>.
reindexTuple :: Int -> [Int] -> Q Exp

-- | Like <a>reverse</a>.
reverseTuple :: Int -> Q Exp

-- | <tt>rotateTuple n k</tt> creates a function which rotates an
--   <tt>n</tt>-tuple rightwards by <tt>k</tt> positions (<tt>k</tt> may be
--   negative or greater than <tt>n-1</tt>).
rotateTuple :: Int -> Int -> Q Exp

-- | Generates the function which maps a tuple <tt>(x_1, ..., x_n)</tt> to
--   the tuple of all its subtuples of the form <tt>(x_{i_1}, ...,
--   x_{i_k})</tt>, where <tt>i_1 &lt; i_2 &lt; ... &lt; i_k</tt>.
subtuples :: Int -> Int -> Q Exp

-- | Generates a function which takes a <a>Num</a> <tt>i</tt> and a
--   homogenous tuple of size <tt>n</tt> and deletes the <tt>i</tt>-th
--   (0-based) element of the tuple.
deleteAtTuple :: Int -> Q Exp

-- | <pre>
--   takeTuple n i = \(x_0, ..., x_{n-1}) -&gt; (x_0, ..., x_{i-1})
--   </pre>
takeTuple :: Int -> Int -> Q Exp

-- | <pre>
--   dropTuple n i = \(x_0, ..., x_{n-1}) -&gt; (x_i, ..., x_{n-1})
--   </pre>
dropTuple :: Int -> Int -> Q Exp

-- | <tt>safeDeleteTuple n</tt> generates a function analogous to
--   <a>delete</a> that takes an element and an <tt>n</tt>-tuple and maybe
--   returns an <tt>n-1</tt>-tuple (if and only if the element was found).
safeDeleteTuple :: Int -> Q Exp

-- | Generates a function modifying a single element of a tuple.
updateAtN :: Int -> Int -> Q Exp

-- | Like <a>zip</a>.
--   
--   Type of the generated expression:
--   
--   <pre>
--   (a1, a2, ..) -&gt; (b1, b2, ..) -&gt; ((a1,b1), (a2,b2), ..)
--   </pre>
zipTuple :: Int -> Q Exp

-- | Type of the generated expression:
--   
--   <pre>
--   (a1, ..) -&gt; (b1, ..) -&gt; (a1, .., b1, ..)
--   </pre>
catTuples :: Int -> Int -> Q Exp

-- | <pre>
--   uncatTuple n m = <a>splitTupleAt</a> (n+m) n
--   </pre>
--   
--   <tt>uncatTuple n m</tt> is the inverse function of <tt>uncurry
--   (catTuples n m)</tt>.
uncatTuple :: Int -> Int -> Q Exp

-- | <tt>splitTupleAt n i</tt> =&gt; <tt>\(x_0, ..., x_{n-1}) -&gt; ((x_0,
--   ..., x_{i-1}),(x_i, ..., x_{n-1})</tt>
splitTupleAt :: Int -> Int -> Q Exp

-- | Like <a>zipWith</a>.
--   
--   Type of the generated expression:
--   
--   <pre>
--   (a -&gt; b -&gt; c) -&gt; (a, ..) -&gt; (b, ..) -&gt; (c, ..)
--   </pre>
zipTupleWith :: Int -> ExpQ

-- | Takes the zipping function as a quoted expression. See
--   <a>mapTuple'</a> for how this can be useful.
zipTupleWith' :: Int -> ExpQ -> ExpQ

-- | Type of the generated expression:
--   
--   <pre>
--   [a] -&gt; Maybe (a, ..)
--   </pre>
safeTupleFromList :: Int -> Q Exp

-- | Type of the generated expression:
--   
--   <pre>
--   [a] -&gt; (a, ..)
--   </pre>
--   
--   The generated function is partial.
tupleFromList :: Int -> Q Exp
constTuple :: Int -> Q Exp

-- | <pre>
--   Generate a projection (like 'fst' and 'snd').
--   </pre>
proj :: Int -> Int -> ExpQ

-- | Like <a>proj</a>, but takes the index argument as the first argument
--   at runtime and returns a <tt>Maybe</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t $(proj' 3)
--   $(proj' 3) :: Num a =&gt; (a1, a1, a1) -&gt; a -&gt; Maybe a1
--   </pre>
proj' :: Int -> Q Exp

-- | Like <a>elem</a>.
--   
--   Type of generated expression:
--   
--   <pre>
--   Eq a =&gt; a -&gt; (a, ..) -&gt; Bool
--   </pre>
elemTuple :: Int -> Q Exp
tupleToList :: Int -> Q Exp
sumTuple :: Int -> Q Exp

-- | Generates a function that takes a binary relation and a tuple
--   <tt>xs</tt>, and returns <a>Just</a> the first index <tt>i</tt> such
--   that the relation holds for <tt>x_i</tt>, <tt>x_{i+1}</tt>, or
--   <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t $(findSuccessiveElementsSatisfying 4)
--   $(findSuccessiveElementsSatisfying 4)
--     :: (t -&gt; t -&gt; Bool) -&gt; (t, t, t, t) -&gt; Maybe Int
--   </pre>
findSuccessiveElementsSatisfying :: Int -> Q Exp

-- | Type of the generated expression:
--   
--   <pre>
--   (a -&gt; r -&gt; r) -&gt; r -&gt; (a, ..) -&gt; r
--   </pre>
foldrTuple :: Int -> ExpQ

-- | Takes the folding function (but not the seed element) as a quoted
--   expression. See <a>mapTuple'</a> for how this can be useful.
foldrTuple' :: Int -> ExpQ -> ExpQ

-- | Type of the generated expression:
--   
--   <pre>
--   (a -&gt; a -&gt; a) -&gt; (a, ..) -&gt; a
--   </pre>
foldr1Tuple :: Int -> ExpQ

-- | Takes the folding function as a quoted expression. See
--   <a>mapTuple'</a> for how this can be useful.
foldr1Tuple' :: Int -> ExpQ -> Q Exp

-- | Type of the generated expression:
--   
--   <pre>
--   (r -&gt; a -&gt; r) -&gt; r -&gt; (a, ..) -&gt; r
--   </pre>
foldlTuple :: Int -> ExpQ

-- | Takes the folding function (but not the seed element) as a quoted
--   expression. See <a>mapTuple'</a> for how this can be useful.
foldlTuple' :: Int -> ExpQ -> ExpQ

-- | Type of the generated expression:
--   
--   <pre>
--   (a -&gt; a -&gt; a) -&gt; (a, ..) -&gt; a
--   </pre>
foldl1Tuple :: Int -> ExpQ

-- | Takes the folding function as a quoted expression. See
--   <a>mapTuple'</a> for how this can be useful.
foldl1Tuple' :: Int -> ExpQ -> Q Exp

-- | Like <a>and</a>.
andTuple :: Int -> Q Exp

-- | Like <a>or</a>.
orTuple :: Int -> Q Exp

-- | Like <a>any</a>.
anyTuple :: Int -> Q Exp
anyTuple' :: Int -> Q Exp -> Q Exp

-- | Like <a>all</a>.
allTuple :: Int -> Q Exp
allTuple' :: Int -> Q Exp -> Q Exp

-- | Like <a>sequence</a>.
sequenceTuple :: Int -> Q Exp

-- | Like <tt>sequenceA</tt>.
sequenceATuple :: Int -> Q Exp

-- | Makes a homogenous tuple type of the given size and element type
--   
--   <pre>
--   $(htuple 2) [t| Char |] = (Char,Char)
--   </pre>
htuple :: Int -> TypeQ -> TypeQ
