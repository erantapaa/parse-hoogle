-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Write more understandable Haskell.
--   
@package flow
@version 1.0.1


-- | Flow is a package that provides functions and operators for writing
--   more understandable Haskell. It's an alternative to some common idioms
--   like <tt>($)</tt> for function application and <tt>(.)</tt> for
--   function composition.
--   
--   Flow is designed to be imported unqualified. It does not export
--   anything that conflicts with <a>the base package</a>.
--   
--   <pre>
--   &gt;&gt;&gt; import Flow
--   </pre>
--   
--   For more information about Flow, please visit <a>the official
--   site</a>.
module Flow

-- | <pre>
--   apply x f == f x
--   </pre>
--   
--   <a>Function application</a>. This is like the <a>$</a> operator.
--   
--   <pre>
--   &gt;&gt;&gt; apply False not
--   True
--   </pre>
--   
--   Using this function with many arguments is cumbersome. Use
--   <a>|&gt;</a> or <a>&lt;|</a> instead.
--   
--   <pre>
--   &gt;&gt;&gt; False `apply` not `apply` fromEnum
--   1
--   </pre>
--   
--   This function usually isn't necessary since <tt><a>apply</a> x f</tt>
--   is the same as <tt>f x</tt>. However it can come in handy when working
--   with higher-order functions.
--   
--   <pre>
--   &gt;&gt;&gt; map (apply False) [not, id]
--   [True,False]
--   </pre>
apply :: a -> (a -> b) -> b

-- | <pre>
--   (x |&gt; f) == f x
--   </pre>
--   
--   <pre>
--   (x |&gt; f |&gt; g) == g (f x)
--   </pre>
--   
--   Left-associative <a>apply</a> operator. This is like a flipped version
--   of the <a>$</a> operator. Read it as "apply forward" or "pipe into".
--   
--   <pre>
--   &gt;&gt;&gt; False |&gt; not
--   True
--   </pre>
--   
--   Since this operator has such low precedence, it can be used to remove
--   parentheses from complicated expressions.
--   
--   <pre>
--   &gt;&gt;&gt; False |&gt; not |&gt; fromEnum
--   1
--   </pre>
--   
--   This operator can be used with higher-order functions, but
--   <a>apply</a> might be clearer.
--   
--   <pre>
--   &gt;&gt;&gt; map (False |&gt;) [not, id]
--   [True,False]
--   </pre>
(|>) :: a -> (a -> b) -> b

-- | <pre>
--   (f &lt;| x) == f x
--   </pre>
--   
--   <pre>
--   (g &lt;| f &lt;| x) == g (f x)
--   </pre>
--   
--   Right-associative <a>apply</a> operator. This is like the <a>$</a>
--   operator. Read it as "apply backward" or "pipe from".
--   
--   <pre>
--   &gt;&gt;&gt; not &lt;| False
--   True
--   </pre>
--   
--   This operator can be used to remove parentheses from complicated
--   expressions because of its low precedence.
--   
--   <pre>
--   &gt;&gt;&gt; fromEnum &lt;| not &lt;| False
--   1
--   </pre>
--   
--   With higher-order functions, this operator is a clearer alternative to
--   <tt>flip <a>apply</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map (&lt;| False) [not, id]
--   [True,False]
--   </pre>
(<|) :: (a -> b) -> a -> b

-- | <pre>
--   compose f g x == g (f x)
--   </pre>
--   
--   <a>Function composition</a>. This is like the <a>.</a> operator.
--   
--   <pre>
--   &gt;&gt;&gt; (compose not fromEnum) False
--   1
--   </pre>
--   
--   Composing many functions together quickly becomes unwieldy. Use
--   <a>.&gt;</a> or <a>&lt;.</a> instead.
--   
--   <pre>
--   &gt;&gt;&gt; (not `compose` fromEnum `compose` succ) False
--   2
--   </pre>
compose :: (a -> b) -> (b -> c) -> (a -> c)

-- | <pre>
--   (f .&gt; g) x == g (f x)
--   </pre>
--   
--   <pre>
--   (f .&gt; g .&gt; h) x == h (g (f x))
--   </pre>
--   
--   Left-associative <a>compose</a> operator. This is like a flipped
--   version of the <a>.</a> operator. Read it as "compose forward" or "and
--   then".
--   
--   <pre>
--   &gt;&gt;&gt; (not .&gt; fromEnum) False
--   1
--   </pre>
--   
--   Thanks to its high precedence, composing many functions together is
--   easy.
--   
--   <pre>
--   &gt;&gt;&gt; (not .&gt; fromEnum .&gt; succ) False
--   2
--   </pre>
(.>) :: (a -> b) -> (b -> c) -> (a -> c)

-- | <pre>
--   (g &lt;. f) x == g (f x)
--   </pre>
--   
--   <pre>
--   (h &lt;. g &lt;. f) x == h (g (f x))
--   </pre>
--   
--   Right-associative <a>compose</a> operator. This is like the <a>.</a>
--   operator. Read it as "compose backward" or "but first".
--   
--   <pre>
--   &gt;&gt;&gt; (fromEnum &lt;. not) False
--   1
--   </pre>
--   
--   Composing many functions together is easy thanks to its high
--   precedence.
--   
--   <pre>
--   &gt;&gt;&gt; (succ &lt;. fromEnum &lt;. not) False
--   2
--   </pre>
(<.) :: (b -> c) -> (a -> b) -> (a -> c)

-- | <pre>
--   apply' x f == seq x (f x)
--   </pre>
--   
--   Strict function application. This is like the <a>$!</a> operator.
--   
--   <pre>
--   &gt;&gt;&gt; apply' undefined (const False)
--   *** Exception: Prelude.undefined
--   </pre>
apply' :: a -> (a -> b) -> b

-- | <pre>
--   (x !&gt; f) == seq x (f x)
--   </pre>
--   
--   <pre>
--   (x !&gt; f !&gt; g) == seq x (g (seq x (f x)))
--   </pre>
--   
--   Left-associative <a>apply'</a> operator. This is like a flipped
--   version of the <a>$!</a> operator.
--   
--   <pre>
--   &gt;&gt;&gt; undefined !&gt; const False
--   *** Exception: Prelude.undefined
--   </pre>
(!>) :: a -> (a -> b) -> b

-- | <pre>
--   (f &lt;! x) == seq x (f x)
--   </pre>
--   
--   <pre>
--   (g &lt;! f &lt;! x) == seq x (g (seq x (f x)))
--   </pre>
--   
--   Right-associative <a>apply'</a> operator. This is like the <a>$!</a>
--   operator.
--   
--   <pre>
--   &gt;&gt;&gt; const False &lt;! undefined
--   *** Exception: Prelude.undefined
--   </pre>
(<!) :: (a -> b) -> a -> b
