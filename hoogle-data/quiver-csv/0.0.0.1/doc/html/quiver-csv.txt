-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Quiver combinators for cellular CSV data processing
--   
--   This library provides an efficient pipes-based implementation of a
--   cellular CSV codec designed for fast streaming of data with guaranteed
--   constant memory usage.
@package quiver-csv
@version 0.0.0.1


-- | CSV syntax elements as defined in RFC 4180 and a few miscellaneous
--   Quiver combinators.
module Control.Quiver.CSV.Extras

-- | Codec result type.
type ParseResult e = Maybe (Maybe e)

-- | Codec result value indicating premature termination of the consumer.

-- | Codec result value indicating successful processing of the entire
--   input stream.

-- | Codec result value indicating unsuccessful processing of the input
--   stream.

-- | Codec error type.
data ParseError

-- | Input ends in a partial cell value. For encoder, this means that the
--   last <tt>Cell</tt> of the input stream specifies the <tt>EOP</tt>
--   delimiter instead of <tt>EOR</tt> or <tt>EOT</tt>. For decoder, this
--   means that the last cell of the input stream is missing the closing
--   quote character.
[IncompleteCell] :: ParseError

-- | Input ends in a partial row value. For encoder, this means that the
--   last <tt>Cell</tt> of the input stream specifies the <tt>EOC</tt>
--   delimiter instead of <tt>EOR</tt> or <tt>EOT</tt>. For decoder, this
--   means that the last row of the input stream is missing the line break
--   sequence.
[IncompleteRow] :: ParseError
(>:>) :: b -> P a' a b b' f (ParseResult e) -> P a' a b b' f (ParseResult e)
(*>:>) :: ByteString -> P a' a ByteString b' f (ParseResult e) -> P a' a ByteString b' f (ParseResult e)
deliverError :: e -> P a' a b b' f (ParseResult e)

-- | line byte value

-- | carriage return byte value

-- | quote character byte value

-- | comma character byte value

-- | Identifies special byte values, which should never appear within
--   unquoted CSV fields.
isSpecial :: Word8 -> Bool

-- | The field delimiter string (a quote character.)
fieldDelimiter :: ByteString

-- | The field separator string (a comma character.)
fieldSeparator :: ByteString

-- | The field separator (CR+LF byte sequence.)
recordSeparator :: ByteString

-- | An escaped quote string (double quote character.)
quoteSequence :: ByteString
instance Enum ParseError
instance Show ParseError
instance Ord ParseError
instance Eq ParseError


-- | Streaming CSV file decoder compliant with RFC 4180. All fields are
--   quoted except for short fields consisting entirely of “safe” ASCII
--   characters, i.e., printable 7-bit characters other than quote and
--   comma. The maximum length of an unquoted field is supplied explicitly
--   to the encoder, which allows us to decide whether a given field
--   requires quoting without unbounded lookahead.
module Control.Quiver.CSV.Encoder

-- | <tt>encodeCSV n</tt> is an infinite pipe that converts a stream of
--   cells into a fragmented strict representation of a CSV file,
--   unconditionally quoting any field values with length greater than
--   <tt>n</tt>.
encodeCSV :: Int -> SP (Cell ByteString) ByteString f (ParseResult ParseError)

-- | <tt>encodeLazyCSV n</tt> is an infinite pipe that converts a stream of
--   cells into a fragmented lazy representation of a CSV file,
--   unconditionally quoting any field values with length greater than
--   <tt>n</tt>.
encodeLazyCSV :: Int -> SP (Cell ByteString) ByteString f (ParseResult ParseError)


-- | Streaming CSV file decoder compliant with RFC 4180. It follows the RFC
--   4180 quite strictly, with the following minor extensions:
--   
--   <ul>
--   <li>arbitrary characters, including ASCII control codes and non-ASCII
--   code points are accepted anywhere in the input,</li>
--   <li>CR and LF are accepted as row separators in addition to the
--   standard CR+LF,</li>
--   <li>rows can have varying number of fields,</li>
--   <li>final row is not required to end with CR+LF, and</li>
--   <li>within quoted field, a quote character that is not followed by
--   another quote, comma or line break is accepted literally.</li>
--   </ul>
module Control.Quiver.CSV.Decoder

-- | A Quiver processor that parses a fragmented strict representation of a
--   CSV file into a stream of cells.
decodeCSV :: Functor f => SP ByteString (Cell ByteString) f (ParseResult ParseError)

-- | A Quiver processor that parses a fragmented lazy representation of a
--   CSV file into a stream of cells.
decodeLazyCSV :: Functor f => SP ByteString (Cell ByteString) f (ParseResult ParseError)


-- | Aan efficient Quiver-based implementation of a cellular CSV encoder
--   and decoder, designed for fast streaming of data with guaranteed
--   constant memory usage.
module Control.Quiver.CSV

-- | Codec result type.
type ParseResult e = Maybe (Maybe e)

-- | Codec result value indicating premature termination of the consumer.

-- | Codec result value indicating successful processing of the entire
--   input stream.

-- | Codec result value indicating unsuccessful processing of the input
--   stream.

-- | Codec error type.
data ParseError

-- | Input ends in a partial cell value. For encoder, this means that the
--   last <tt>Cell</tt> of the input stream specifies the <tt>EOP</tt>
--   delimiter instead of <tt>EOR</tt> or <tt>EOT</tt>. For decoder, this
--   means that the last cell of the input stream is missing the closing
--   quote character.
[IncompleteCell] :: ParseError

-- | Input ends in a partial row value. For encoder, this means that the
--   last <tt>Cell</tt> of the input stream specifies the <tt>EOC</tt>
--   delimiter instead of <tt>EOR</tt> or <tt>EOT</tt>. For decoder, this
--   means that the last row of the input stream is missing the line break
--   sequence.
[IncompleteRow] :: ParseError

-- | A Quiver processor that parses a fragmented strict representation of a
--   CSV file into a stream of cells.
decodeCSV :: Functor f => SP ByteString (Cell ByteString) f (ParseResult ParseError)

-- | A Quiver processor that parses a fragmented lazy representation of a
--   CSV file into a stream of cells.
decodeLazyCSV :: Functor f => SP ByteString (Cell ByteString) f (ParseResult ParseError)

-- | <tt>encodeCSV n</tt> is an infinite pipe that converts a stream of
--   cells into a fragmented strict representation of a CSV file,
--   unconditionally quoting any field values with length greater than
--   <tt>n</tt>.
encodeCSV :: Int -> SP (Cell ByteString) ByteString f (ParseResult ParseError)

-- | <tt>encodeLazyCSV n</tt> is an infinite pipe that converts a stream of
--   cells into a fragmented lazy representation of a CSV file,
--   unconditionally quoting any field values with length greater than
--   <tt>n</tt>.
encodeLazyCSV :: Int -> SP (Cell ByteString) ByteString f (ParseResult ParseError)
