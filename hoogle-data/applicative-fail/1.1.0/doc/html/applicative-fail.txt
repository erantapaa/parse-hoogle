-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Applicative functor and monad which collects all your fails
--   
@package applicative-fail
@version 1.1.0

module Control.Applicative.Fail

-- | Applicative functor which collects all the fails instead of immediate
--   returning first fail like <a>Either</a>. It can not be a monad because
--   of differenct logic in Applicative. Applicative instance of Fail
--   continue to fold fails even when 'Fail e Nothing' pattern is met.
--   Monad instance can not behave like that, so <a>Fail</a> have no Monad
--   instance
data Fail e a

-- | (Just a) when checking may proceed in Applicative
Fail :: e -> (Maybe a) -> Fail e a
Success :: a -> Fail e a

-- | Unwraps <a>Fail</a> to tuple of error and value. If pattern is
--   <a>Success</a> then return <a>mempty</a> in error part.
runFail :: Monoid e => Fail e a -> (e, Maybe a)

-- | Unwraps <a>Fail</a> and constrain error container to <a>DList</a> for
--   type inference
runDLFail :: Fail (DList e) a -> ([e], Maybe a)
afail :: Applicative f => e -> Fail (f e) a
awarn :: Applicative f => e -> a -> Fail (f e) a

-- | Return True if pattern does not contain not success value nor fails,
--   i.e. (Fail mempty Nothing)
fNull :: (Eq e, Monoid e) => Fail e a -> Bool

-- | Return fail part if exists
getFail :: Fail e a -> Maybe e

-- | Return success part if exists
getSucc :: Fail e a -> Maybe a

-- | Return <a>Right</a> if there is value (including pattern '(Fail e
--   (Just a))'). If there is no value return <a>Left</a>
failEither :: Fail e a -> Either e a

-- | Join two fails like monad does. This function still match to
--   <a>Applicative</a>
joinFail :: Monoid e => Fail e (Fail e a) -> Fail e a
instance Typeable Fail
instance (Eq e, Eq a) => Eq (Fail e a)
instance (Ord e, Ord a) => Ord (Fail e a)
instance (Show e, Show a) => Show (Fail e a)
instance (Read e, Read a) => Read (Fail e a)
instance Functor (Fail e)
instance Foldable (Fail e)
instance Traversable (Fail e)
instance Generic (Fail e a)
instance Datatype D1Fail
instance Constructor C1_0Fail
instance Constructor C1_1Fail
instance (Monoid e, Monoid a) => Monoid (Fail e a)
instance Monoid e => Applicative (Fail e)
instance Bifunctor Fail

module Control.Monad.Fail
newtype FailT e m a
FailT :: m (Fail e a) -> FailT e m a
runFailT :: FailT e m a -> m (Fail e a)

-- | Unwraps <a>FailT</a> and wraps result into <a>Compose</a> functor.
--   Usable for convenient composition of <a>Fail</a> where <a>FailT</a>
--   works inside.
runFailC :: FailT e m a -> Compose m (Fail e) a
runFailI :: FailT e Identity a -> Fail e a
mapFailTBase :: (forall x. m x -> n x) -> FailT e m a -> FailT e n a

-- | Like <a>first</a> from <a>Bifunctor</a> maps error type
mapFailTFail :: Functor m => (e -> e') -> FailT e m a -> FailT e' m a
mfail :: (Applicative f, Applicative m) => e -> FailT (f e) m a
mwarn :: (Applicative f, Applicative m) => e -> FailT (f e) m ()
instance Typeable FailT
instance Show (m (Fail e a)) => Show (FailT e m a)
instance Ord (m (Fail e a)) => Ord (FailT e m a)
instance Eq (m (Fail e a)) => Eq (FailT e m a)
instance Functor m => Functor (FailT e m)
instance Foldable m => Foldable (FailT e m)
instance Traversable m => Traversable (FailT e m)
instance Generic (FailT e m a)
instance Datatype D1FailT
instance Constructor C1_0FailT
instance Selector S1_0_0FailT
instance (Monad m, Monoid e) => MonadError e (FailT e m)
instance (MonadWriter w m, Monoid e) => MonadWriter w (FailT e m)
instance (MonadState s m, Monoid e) => MonadState s (FailT e m)
instance (MonadReader r m, Monoid e) => MonadReader r (FailT e m)
instance (Monoid e, MonadBase b m) => MonadBase b (FailT e m)
instance MonadTrans (FailT e)
instance (Monoid e, Monad m) => Monad (FailT e m)
instance (Monoid e, Functor m, Monad m) => Applicative (FailT e m)
instance (Applicative m, Monoid a, Monoid e) => Monoid (FailT e m a)
