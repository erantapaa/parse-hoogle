-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe datatype-database mapping library.
--   
@package groundhog
@version 0.7.0.3


-- | This module defines the functions and datatypes used throughout the
--   framework. Most of them are for the internal use
module Database.Groundhog.Core

-- | Only instances of this class can be persisted in a database
class (PurePersistField (AutoKey v), PurePersistField (DefaultKey v)) => PersistEntity v where data family Field v :: ((* -> *) -> *) -> * -> * data family Key v :: * -> * type family AutoKey v type family DefaultKey v type family IsSumType v
entityDef :: (PersistEntity v, DbDescriptor db) => proxy db -> v -> EntityDef
toEntityPersistValues :: (PersistEntity v, PersistBackend m) => v -> m ([PersistValue] -> [PersistValue])
fromEntityPersistValues :: (PersistEntity v, PersistBackend m) => [PersistValue] -> m (v, [PersistValue])
getUniques :: (PersistEntity v, DbDescriptor db) => proxy db -> v -> (Int, [(String, [PersistValue] -> [PersistValue])])
entityFieldChain :: (PersistEntity v, DbDescriptor db) => proxy db -> Field v c a -> FieldChain

-- | A raw value which can be stored in any backend and can be marshalled
--   to and from a <a>PersistField</a>.
data PersistValue
PersistString :: String -> PersistValue
PersistByteString :: ByteString -> PersistValue
PersistInt64 :: Int64 -> PersistValue
PersistDouble :: Double -> PersistValue
PersistBool :: Bool -> PersistValue
PersistDay :: Day -> PersistValue
PersistTimeOfDay :: TimeOfDay -> PersistValue
PersistUTCTime :: UTCTime -> PersistValue
PersistZonedTime :: ZT -> PersistValue
PersistNull :: PersistValue

-- | Creating some datatypes may require calling a function, using a
--   special constructor, or other syntax. The string (which can have
--   placeholders) is included into query without escaping. The recursive
--   constructions are not allowed, i.e., [PersistValue] cannot contain
--   PersistCustom values.
PersistCustom :: Utf8 -> [PersistValue] -> PersistValue

-- | Represents everything which can be put into a database. This data can
--   be stored in multiple columns and tables. To get value of those
--   columns we might need to access another table. That is why the result
--   type is monadic.
class PersistField a
persistName :: PersistField a => a -> String
toPersistValues :: (PersistField a, PersistBackend m) => a -> m ([PersistValue] -> [PersistValue])
fromPersistValues :: (PersistField a, PersistBackend m) => [PersistValue] -> m (a, [PersistValue])
dbType :: (PersistField a, DbDescriptor db) => proxy db -> a -> DbType

-- | Represents all datatypes that map into a single column. Getting value
--   for that column might require monadic actions to access other tables.
class PersistField a => SinglePersistField a
toSinglePersistValue :: (SinglePersistField a, PersistBackend m) => a -> m PersistValue
fromSinglePersistValue :: (SinglePersistField a, PersistBackend m) => PersistValue -> m a

-- | Represents all datatypes that map into several columns. Getting values
--   for those columns is pure.
class PersistField a => PurePersistField a
toPurePersistValues :: (PurePersistField a, DbDescriptor db) => proxy db -> a -> ([PersistValue] -> [PersistValue])
fromPurePersistValues :: (PurePersistField a, DbDescriptor db) => proxy db -> [PersistValue] -> (a, [PersistValue])

-- | Datatypes which can be converted directly to <a>PersistValue</a>. The
--   no-value parameter <tt>DbDescriptor db =&gt; proxy db</tt> allows
--   conversion depend the database details while keeping it pure. A type
--   which has an instance of <a>PrimitivePersistField</a> should be an
--   instance of superclasses <a>SinglePersistField</a> and
--   <a>PurePersistField</a> as well.
class PersistField a => PrimitivePersistField a
toPrimitivePersistValue :: (PrimitivePersistField a, DbDescriptor db) => proxy db -> a -> PersistValue
fromPrimitivePersistValue :: (PrimitivePersistField a, DbDescriptor db) => proxy db -> PersistValue -> a
class PersistField v => Embedded v where data family Selector v :: * -> *
selectorNum :: Embedded v => Selector v a -> Int

-- | Any data that can be fetched from a database
class Projection p a | p -> a where type family ProjectionDb p db :: Constraint type family ProjectionRestriction p r :: Constraint
projectionExprs :: (Projection p a, DbDescriptor db, ProjectionDb p db, ProjectionRestriction p r) => p -> [UntypedExpr db r] -> [UntypedExpr db r]
projectionResult :: (Projection p a, PersistBackend m) => p -> [PersistValue] -> m (a, [PersistValue])
class (Projection p a, ProjectionDb p db, ProjectionRestriction p r) => Projection' p db r a
data RestrictionHolder v (c :: (* -> *) -> *)

-- | A holder for Unique constraints
data Unique (u :: (* -> *) -> *)

-- | It allows to store autogenerated keys of one database in another if
--   they have different datatype.
data KeyForBackend db v
KeyForBackend :: (AutoKeyType db) -> KeyForBackend db v

-- | Key marked with this type can have value for any backend
data BackendSpecific

-- | A phantom datatype to make instance head different <tt>c
--   (ConstructorMarker v)</tt>
data ConstructorMarker v a

-- | A phantom datatype to make instance head different <tt>u (UniqueMarker
--   v)</tt>
data UniqueMarker v a
data HFalse
data HTrue

-- | Avoid orphan instances.
newtype ZT
ZT :: ZonedTime -> ZT

-- | Datatype for incremental building SQL queries
newtype Utf8
Utf8 :: Builder -> Utf8
fromUtf8 :: Utf8 -> ByteString
delim :: Char

-- | Represents condition for a query.
data Cond db r
And :: (Cond db r) -> (Cond db r) -> Cond db r
Or :: (Cond db r) -> (Cond db r) -> Cond db r
Not :: (Cond db r) -> Cond db r
Compare :: ExprRelation -> (UntypedExpr db r) -> (UntypedExpr db r) -> Cond db r
CondRaw :: (QueryRaw db r) -> Cond db r
CondEmpty :: Cond db r
data ExprRelation
Eq :: ExprRelation
Ne :: ExprRelation
Gt :: ExprRelation
Lt :: ExprRelation
Ge :: ExprRelation
Le :: ExprRelation
data Update db r
Update :: f -> (UntypedExpr db r) -> Update db r

-- | Accesses fields of the embedded datatypes. For example, <tt>SomeField
--   ==. ("abc", "def") ||. SomeField ~&gt; Tuple2_0Selector ==. "def"</tt>
(~>) :: (EntityConstr v c, FieldLike f a, DbDescriptor db, Projection' f db (RestrictionHolder v c) a, Embedded a) => f -> Selector a a' -> SubField db v c a'

-- | This subset of Assignable is for plain database fields.
class Assignable f a => FieldLike f a | f -> a
fieldChain :: (FieldLike f a, DbDescriptor db, ProjectionDb f db) => proxy db -> f -> FieldChain

-- | This subset of Projection instances is for things that behave like
--   fields. Namely, they can occur in condition expressions (for example,
--   Field and SubField) and on the left side of update statements. For
--   example "lower(field)" is a valid Projection, but not Field like
--   because it cannot be on the left side. Datatypes that index PostgreSQL
--   arrays "arr[5]" or access composites "(comp).subfield" are valid
--   instances of Assignable.
class Projection f a => Assignable f a | f -> a
newtype SubField db v (c :: (* -> *) -> *) a
SubField :: FieldChain -> SubField db v a

-- | It can be used in expressions like a regular field. For example,
--   <tt>delete (AutoKeyField ==. k)</tt> or <tt>delete (AutoKeyField ==. k
--   ||. SomeField ==. "DUPLICATE")</tt>
data AutoKeyField v (c :: (* -> *) -> *)
AutoKeyField :: AutoKeyField v c

-- | It is used to map field to column names. It can be either a column
--   name for a regular field of non-embedded type or a list of this field
--   and the outer fields in reverse order. Eg, fieldChain $ SomeField
--   ~&gt; Tuple2_0Selector may result in [("val0", DbString), ("some",
--   DbEmbedded False [dbType "", dbType True])].
type FieldChain = ((String, DbType), [(String, EmbeddedDef)])

-- | Types which are never NULL when converted to <a>PersistValue</a>.
--   Consider the type <tt>Maybe (Maybe a)</tt>. Now Nothing is stored as
--   NULL, so we cannot distinguish between Just Nothing and Nothing which
--   is a problem. The purpose of this class is to ban the inner Maybe's.
--   Maybe this class can be removed when support for inner Maybe's
--   appears.
class NeverNull a

-- | Used to uniformly represent fields, constants and more complex things,
--   e.g., arithmetic expressions. A value should be converted to
--   <a>UntypedExpr</a> for usage in expressions
data UntypedExpr db r
ExprRaw :: QueryRaw db r -> UntypedExpr db r
ExprField :: FieldChain -> UntypedExpr db r
ExprPure :: a -> UntypedExpr db r
ExprCond :: Cond db r -> UntypedExpr db r

-- | Expr with phantom type helps to keep type safety in complex
--   expressions
newtype Expr db r a
Expr :: (UntypedExpr db r) -> Expr db r a

-- | Defines sort order of a result-set
data Order db r
Asc :: f -> Order db r
Desc :: f -> Order db r

-- | This class helps to check that limit, offset, or order clauses are
--   added to condition only once.
class HasSelectOptions a db r | a -> db r where type family HasLimit a type family HasOffset a type family HasOrder a type family HasDistinct a
getSelectOptions :: HasSelectOptions a db r => a -> SelectOptions db r (HasLimit a) (HasOffset a) (HasOrder a) (HasDistinct a)
data SelectOptions db r hasLimit hasOffset hasOrder hasDistinct
SelectOptions :: Cond db r -> Maybe Int -> Maybe Int -> [Order db r] -> Bool -> [(String, QueryRaw db r)] -> SelectOptions db r hasLimit hasOffset hasOrder hasDistinct
condOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> Cond db r
limitOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> Maybe Int
offsetOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> Maybe Int

-- | False - no DISTINCT, True - DISTINCT
orderOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> [Order db r]

-- | The name of the option and part of the SQL which will be put later
distinctOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> Bool
dbSpecificOptions :: SelectOptions db r hasLimit hasOffset hasOrder hasDistinct -> [(String, QueryRaw db r)]
limitTo :: (HasSelectOptions a db r, HasLimit a ~ HFalse) => a -> Int -> SelectOptions db r HTrue (HasOffset a) (HasOrder a) (HasDistinct a)
offsetBy :: (HasSelectOptions a db r, HasOffset a ~ HFalse) => a -> Int -> SelectOptions db r (HasLimit a) HTrue (HasOrder a) (HasDistinct a)
orderBy :: (HasSelectOptions a db r, HasOrder a ~ HFalse) => a -> [Order db r] -> SelectOptions db r (HasLimit a) (HasOffset a) HTrue (HasDistinct a)

-- | Select DISTINCT rows. <tt>select $ distinct CondEmpty</tt>
distinct :: (HasSelectOptions a db r, HasDistinct a ~ HFalse) => a -> SelectOptions db r (HasLimit a) (HasOffset a) (HasOrder a) HTrue

-- | A DB data type. Naming attempts to reflect the underlying Haskell
--   datatypes, eg DbString instead of DbVarchar. Different databases may
--   have different representations for these types.
data DbTypePrimitive' str
DbString :: DbTypePrimitive' str
DbInt32 :: DbTypePrimitive' str
DbInt64 :: DbTypePrimitive' str
DbReal :: DbTypePrimitive' str
DbBool :: DbTypePrimitive' str
DbDay :: DbTypePrimitive' str
DbTime :: DbTypePrimitive' str
DbDayTime :: DbTypePrimitive' str
DbDayTimeZoned :: DbTypePrimitive' str

-- | ByteString
DbBlob :: DbTypePrimitive' str
DbOther :: (OtherTypeDef' str) -> DbTypePrimitive' str
type DbTypePrimitive = DbTypePrimitive' String
data DbType

-- | type, nullable, default value, reference
DbTypePrimitive :: DbTypePrimitive -> Bool -> (Maybe String) -> (Maybe ParentTableReference) -> DbType
DbEmbedded :: EmbeddedDef -> (Maybe ParentTableReference) -> DbType

-- | List table name and type of its argument
DbList :: String -> DbType -> DbType

-- | Describes an ADT.
data EntityDef' str dbType
EntityDef :: str -> Maybe str -> [dbType] -> [ConstructorDef' str dbType] -> EntityDef' str dbType

-- | Entity name. <tt>entityName (entityDef v) == persistName v</tt>
entityName :: EntityDef' str dbType -> str

-- | Database schema for the entity table and tables of its constructors
entitySchema :: EntityDef' str dbType -> Maybe str

-- | Named types of the instantiated polymorphic type parameters
typeParams :: EntityDef' str dbType -> [dbType]

-- | List of entity constructors definitions
constructors :: EntityDef' str dbType -> [ConstructorDef' str dbType]
type EntityDef = EntityDef' String DbType

-- | The first argument is a flag which defines if the field names should
--   be concatenated with the outer field name (False) or used as is which
--   provides full control over table column names (True). Value False
--   should be the default value so that a datatype can be embedded without
--   name conflict concern. The second argument list of field names and
--   field types.
data EmbeddedDef' str dbType
EmbeddedDef :: Bool -> [(str, dbType)] -> EmbeddedDef' str dbType
type EmbeddedDef = EmbeddedDef' String DbType

-- | Stores a database type. The list contains two kinds of tokens for the
--   type string. Backend will choose a string representation for
--   DbTypePrimitive's, and the string literals will go to the type as-is.
--   As the final step, these tokens are concatenated. For example,
--   <tt>[Left "varchar(50)"]</tt> will become a string with max length and
--   <tt>[Right DbInt64, Left "[]"]</tt> will become integer[] in
--   PostgreSQL.
newtype OtherTypeDef' str
OtherTypeDef :: ([Either str (DbTypePrimitive' str)]) -> OtherTypeDef' str
type OtherTypeDef = OtherTypeDef' String

-- | Describes an entity constructor
data ConstructorDef' str dbType
ConstructorDef :: str -> Maybe str -> [(str, dbType)] -> [UniqueDef' str (Either (str, dbType) str)] -> ConstructorDef' str dbType

-- | Constructor name
constrName :: ConstructorDef' str dbType -> str

-- | Autokey name if any
constrAutoKeyName :: ConstructorDef' str dbType -> Maybe str

-- | Parameter names with their named type
constrParams :: ConstructorDef' str dbType -> [(str, dbType)]

-- | Uniqueness constraints on the constructor fiels
constrUniques :: ConstructorDef' str dbType -> [UniqueDef' str (Either (str, dbType) str)]
type ConstructorDef = ConstructorDef' String DbType

-- | Phantom constructors are made instances of this class. This class
--   should be used only by Template Haskell codegen
class Constructor c
phantomConstrNum :: Constructor c => c (a :: * -> *) -> Int

-- | This class helps type inference in cases when query does not contain
--   any fields which define the constructor, but the entity has only one.
--   For example, in <tt>select $ AutoKeyField ==. k</tt> the condition
--   would need type annotation with constructor name only if we select a
--   sum type.
class PersistEntity v => EntityConstr v c
entityConstrNum :: EntityConstr v c => proxy v -> c (a :: * -> *) -> Int
class PurePersistField uKey => IsUniqueKey uKey
extractUnique :: (IsUniqueKey uKey, uKey ~ Key v u) => v -> uKey
uniqueNum :: IsUniqueKey uKey => uKey -> Int

-- | Unique name and list of the fields that form a unique combination. The
--   fields are parametrized to reuse this datatype both with field and
--   DbType and with column name
data UniqueDef' str field
UniqueDef :: Maybe str -> UniqueType -> [field] -> UniqueDef' str field
uniqueDefName :: UniqueDef' str field -> Maybe str
uniqueDefType :: UniqueDef' str field -> UniqueType
uniqueDefFields :: UniqueDef' str field -> [field]

-- | Field is either a pair of entity field name and its type or an
--   expression which will be used in query as-is.
type UniqueDef = UniqueDef' String (Either (String, DbType) String)

-- | Defines how to treat the unique set of fields for a datatype
data UniqueType
UniqueConstraint :: UniqueType
UniqueIndex :: UniqueType

-- | is autoincremented
UniquePrimary :: Bool -> UniqueType
data ReferenceActionType
NoAction :: ReferenceActionType
Restrict :: ReferenceActionType
Cascade :: ReferenceActionType
SetNull :: ReferenceActionType
SetDefault :: ReferenceActionType

-- | The reference contains either EntityDef of the parent table and name
--   of the unique constraint. Or for tables not mapped by Groundhog schema
--   name, table name, and list of columns Reference to the autogenerated
--   key of a mapped entity = (Left (entityDef, Nothing), onDelete,
--   onUpdate) Reference to a unique key of a mapped entity = (Left
--   (entityDef, Just uniqueKeyName), onDelete, onUpdate) Reference to a
--   table that is not mapped = (Right ((schema, tableName), columns),
--   onDelete, onUpdate)
type ParentTableReference = (Either (EntityDef, Maybe String) ((Maybe String, String), [String]), Maybe ReferenceActionType, Maybe ReferenceActionType)

-- | Either error messages or migration queries with safety flag and
--   execution order
type SingleMigration = Either [String] [(Bool, Int, String)]

-- | Datatype names and corresponding migrations
type NamedMigrations = Map String SingleMigration
type Migration m = StateT NamedMigrations m ()
class (Monad m, DbDescriptor (PhantomDb m)) => PersistBackend m where type family PhantomDb m
insert :: (PersistBackend m, PersistEntity v) => v -> m (AutoKey v)
insert_ :: (PersistBackend m, PersistEntity v) => v -> m ()
insertBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> v -> m (Either (AutoKey v) (AutoKey v))
insertByAll :: (PersistBackend m, PersistEntity v) => v -> m (Either (AutoKey v) (AutoKey v))
replace :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> v -> m ()
replaceBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> v -> m ()
select :: (PersistBackend m, PersistEntity v, EntityConstr v c, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c)) => opts -> m [v]
selectAll :: (PersistBackend m, PersistEntity v) => m [(AutoKey v, v)]
get :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m (Maybe v)
getBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => Key v (Unique u) -> m (Maybe v)
update :: (PersistBackend m, PersistEntity v, EntityConstr v c) => [Update (PhantomDb m) (RestrictionHolder v c)] -> Cond (PhantomDb m) (RestrictionHolder v c) -> m ()
delete :: (PersistBackend m, PersistEntity v, EntityConstr v c) => Cond (PhantomDb m) (RestrictionHolder v c) -> m ()
deleteBy :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m ()
deleteAll :: (PersistBackend m, PersistEntity v) => v -> m ()
count :: (PersistBackend m, PersistEntity v, EntityConstr v c) => Cond (PhantomDb m) (RestrictionHolder v c) -> m Int
countAll :: (PersistBackend m, PersistEntity v) => v -> m Int
project :: (PersistBackend m, PersistEntity v, EntityConstr v c, Projection' p (PhantomDb m) (RestrictionHolder v c) a, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c)) => p -> opts -> m [a]
migrate :: (PersistBackend m, PersistEntity v) => v -> Migration m
executeRaw :: PersistBackend m => Bool -> String -> [PersistValue] -> m ()
queryRaw :: PersistBackend m => Bool -> String -> [PersistValue] -> (RowPopper m -> m a) -> m a
insertList :: (PersistBackend m, PersistField a) => [a] -> m Int64
getList :: (PersistBackend m, PersistField a) => Int64 -> m [a]
class PrimitivePersistField (AutoKeyType db) => DbDescriptor db where type family AutoKeyType db type family QueryRaw db :: * -> *
backendName :: DbDescriptor db => proxy db -> String
type RowPopper m = m (Maybe [PersistValue])
newtype DbPersist conn m a
DbPersist :: ReaderT conn m a -> DbPersist conn m a
unDbPersist :: DbPersist conn m a -> ReaderT conn m a
runDbPersist :: Monad m => DbPersist conn m a -> conn -> m a

-- | Connection manager provides connection to the passed function handles
--   transations. Manager can be a connection itself, a pool, Snaplet in
--   Snap, foundation datatype in Yesod, etc.
class ConnectionManager cm conn | cm -> conn
withConn :: (ConnectionManager cm conn, MonadBaseControl IO m, MonadIO m) => (conn -> m a) -> cm -> m a
withConnNoTransaction :: (ConnectionManager cm conn, MonadBaseControl IO m, MonadIO m) => (conn -> m a) -> cm -> m a

-- | This connection manager always returns the same connection. This
--   constraint is useful when performing operations which make sense only
--   within one connection, for example, nested savepoints..
class ConnectionManager cm conn => SingleConnectionManager cm conn
class Savepoint conn
withConnSavepoint :: (Savepoint conn, MonadBaseControl IO m, MonadIO m) => String -> m a -> conn -> m a
instance Show ExprRelation
instance Monad m => Monad (DbPersist conn m)
instance MonadIO m => MonadIO (DbPersist conn m)
instance Functor m => Functor (DbPersist conn m)
instance Applicative m => Applicative (DbPersist conn m)
instance MonadTrans (DbPersist conn)
instance Monad m => MonadReader conn (DbPersist conn m)
instance Show UniqueType
instance Eq UniqueType
instance Ord UniqueType
instance (Show str, Show field) => Show (UniqueDef' str field)
instance (Eq str, Eq field) => Eq (UniqueDef' str field)
instance (Show str, Show dbType) => Show (ConstructorDef' str dbType)
instance (Eq str, Eq dbType) => Eq (ConstructorDef' str dbType)
instance (Show str, Show dbType) => Show (EntityDef' str dbType)
instance (Eq str, Eq dbType) => Eq (EntityDef' str dbType)
instance Eq ReferenceActionType
instance Show ReferenceActionType
instance Eq str => Eq (OtherTypeDef' str)
instance Show str => Show (OtherTypeDef' str)
instance Eq str => Eq (DbTypePrimitive' str)
instance Show str => Show (DbTypePrimitive' str)
instance (Eq str, Eq dbType) => Eq (EmbeddedDef' str dbType)
instance (Show str, Show dbType) => Show (EmbeddedDef' str dbType)
instance Eq DbType
instance Show DbType
instance Show ZT
instance Read ZT
instance Eq PersistValue
instance Show PersistValue
instance Read PersistValue
instance Eq (Expr db r a)
instance Show (Expr db r a)
instance Ord ZT
instance Eq ZT
instance Read Utf8
instance Show Utf8
instance Eq Utf8
instance MonadState s m => MonadState s (DbPersist conn m)
instance MonadCont m => MonadCont (DbPersist conn m)
instance MonadError e m => MonadError e (DbPersist conn m)
instance MonadWriter w m => MonadWriter w (DbPersist conn m)
instance MonadLogger m => MonadLogger (DbPersist conn m)
instance MonadBaseControl IO m => MonadBaseControl IO (DbPersist conn m)
instance MonadTransControl (DbPersist conn)
instance MonadBase IO m => MonadBase IO (DbPersist conn m)
instance db' ~ db => HasSelectOptions (SelectOptions db r hasLimit hasOffset hasOrder hasDistinct) db' r
instance db' ~ db => HasSelectOptions (Cond db r) db' r
instance (Projection p a, ProjectionDb p db, ProjectionRestriction p r) => Projection' p db r a


-- | This helper module is intended for use by the backend creators
module Database.Groundhog.Generic

-- | Produce the migrations but not execute them. Fails when an unsafe
--   migration occurs.
createMigration :: Monad m => Migration m -> m NamedMigrations

-- | Execute the migrations with printing to stderr. Fails when an unsafe
--   migration occurs.
executeMigration :: (PersistBackend m, MonadIO m) => NamedMigrations -> m ()

-- | Execute the migrations. Fails when an unsafe migration occurs.
executeMigrationSilent :: (PersistBackend m, MonadIO m) => NamedMigrations -> m ()

-- | Execute migrations. Executes the unsafe migrations without warnings
--   and prints them to stderr
executeMigrationUnsafe :: (PersistBackend m, MonadIO m) => NamedMigrations -> m ()

-- | Creates migrations and executes them with printing to stderr. Fails
--   when an unsafe migration occurs. &gt; runMigration m = createMigration
--   m &gt;&gt;= executeMigration
runMigration :: (PersistBackend m, MonadIO m) => Migration m -> m ()

-- | Creates migrations and silently executes them. Fails when an unsafe
--   migration occurs. &gt; runMigration m = createMigration m &gt;&gt;=
--   executeMigrationSilent
runMigrationSilent :: (PersistBackend m, MonadIO m) => Migration m -> m ()

-- | Creates migrations and executes them with printing to stderr. Executes
--   the unsafe migrations without warnings &gt; runMigrationUnsafe m =
--   createMigration m &gt;&gt;= executeMigrationUnsafe
runMigrationUnsafe :: (PersistBackend m, MonadIO m) => Migration m -> m ()

-- | Returns either a list of errors in migration or a list of queries
getQueries :: Bool -> SingleMigration -> Either [String] [String]

-- | Pretty print the migrations
printMigration :: MonadIO m => NamedMigrations -> m ()

-- | Joins the migrations. The result is either all error messages or all
--   queries
mergeMigrations :: [SingleMigration] -> SingleMigration

-- | This class helps to shorten the type signatures of user monadic code.
class (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadReader cm m, ConnectionManager cm conn) => HasConn m cm conn

-- | It helps to run database operations within an application monad.
runDb :: HasConn m cm conn => DbPersist conn m a -> m a

-- | Runs action within connection. It can handle a simple connection, a
--   pool of them, etc.
runDbConn :: (MonadBaseControl IO m, MonadIO m, ConnectionManager cm conn) => DbPersist conn (NoLoggingT m) a -> cm -> m a

-- | It is similar to <a>runDbConn</a> but runs action without transaction.
--   It can be useful if you use Groundhog within IO monad or in other
--   cases when you cannot put <a>PersistBackend</a> instance into your
--   monad stack.
--   
--   <pre>
--   flip withConn cm $ \conn -&gt; liftIO $ do
--     -- transaction is already opened by withConn at this point
--     someIOAction
--     getValuesFromIO $ \value -&gt; runDbConnNoTransaction (insert_ value) conn
--   </pre>
runDbConnNoTransaction :: (MonadBaseControl IO m, MonadIO m, ConnectionManager cm conn) => DbPersist conn (NoLoggingT m) a -> cm -> m a

-- | It helps to run <a>withConnSavepoint</a> within a monad.
withSavepoint :: (HasConn m cm conn, SingleConnectionManager cm conn, Savepoint conn) => String -> m a -> m a
primToPersistValue :: (PersistBackend m, PrimitivePersistField a) => a -> m ([PersistValue] -> [PersistValue])
primFromPersistValue :: (PersistBackend m, PrimitivePersistField a) => [PersistValue] -> m (a, [PersistValue])
primToPurePersistValues :: (DbDescriptor db, PrimitivePersistField a) => proxy db -> a -> ([PersistValue] -> [PersistValue])
primFromPurePersistValues :: (DbDescriptor db, PrimitivePersistField a) => proxy db -> [PersistValue] -> (a, [PersistValue])
primToSinglePersistValue :: (PersistBackend m, PrimitivePersistField a) => a -> m PersistValue
primFromSinglePersistValue :: (PersistBackend m, PrimitivePersistField a) => PersistValue -> m a
pureToPersistValue :: (PersistBackend m, PurePersistField a) => a -> m ([PersistValue] -> [PersistValue])
pureFromPersistValue :: (PersistBackend m, PurePersistField a) => [PersistValue] -> m (a, [PersistValue])
singleToPersistValue :: (PersistBackend m, SinglePersistField a) => a -> m ([PersistValue] -> [PersistValue])
singleFromPersistValue :: (PersistBackend m, SinglePersistField a) => [PersistValue] -> m (a, [PersistValue])
toSinglePersistValueUnique :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u)), PrimitivePersistField (Key v (Unique u))) => u (UniqueMarker v) -> v -> m PersistValue
fromSinglePersistValueUnique :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u)), PrimitivePersistField (Key v (Unique u))) => u (UniqueMarker v) -> PersistValue -> m v
toPersistValuesUnique :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> v -> m ([PersistValue] -> [PersistValue])
fromPersistValuesUnique :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> [PersistValue] -> m (v, [PersistValue])
toSinglePersistValueAutoKey :: (PersistBackend m, PersistEntity v, PrimitivePersistField (AutoKey v)) => v -> m PersistValue
fromSinglePersistValueAutoKey :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => PersistValue -> m v
failMessage :: PersistField a => a -> [PersistValue] -> String
failMessageNamed :: String -> [PersistValue] -> String
bracket :: MonadBaseControl IO m => m a -> (a -> m b) -> (a -> m c) -> m c
finally :: MonadBaseControl IO m => m a -> m b -> m a
onException :: MonadBaseControl IO m => m a -> m b -> m a
data PSFieldDef str
PSFieldDef :: str -> Maybe str -> Maybe str -> Maybe str -> Maybe [PSFieldDef str] -> Maybe str -> Maybe (Maybe ((Maybe str, str), [str]), Maybe ReferenceActionType, Maybe ReferenceActionType) -> PSFieldDef str
psFieldName :: PSFieldDef str -> str
psDbFieldName :: PSFieldDef str -> Maybe str
psDbTypeName :: PSFieldDef str -> Maybe str
psExprName :: PSFieldDef str -> Maybe str
psEmbeddedDef :: PSFieldDef str -> Maybe [PSFieldDef str]
psDefaultValue :: PSFieldDef str -> Maybe str
psReferenceParent :: PSFieldDef str -> Maybe (Maybe ((Maybe str, str), [str]), Maybe ReferenceActionType, Maybe ReferenceActionType)
applyDbTypeSettings :: PSFieldDef String -> DbType -> DbType
findOne :: (Eq x, Show x) => String -> (a -> x) -> x -> [a] -> a
replaceOne :: (Eq x, Show x) => String -> (a -> x) -> (b -> x) -> (a -> b -> b) -> a -> [b] -> [b]

-- | Returns only old elements, only new elements, and matched pairs (old,
--   new). The new ones exist only in datatype, the old are present only in
--   DB, match is typically by name (the properties of the matched elements
--   may differ).
matchElements :: Show a => (a -> b -> Bool) -> [a] -> [b] -> ([a], [b], [(a, b)])
haveSameElems :: Show a => (a -> b -> Bool) -> [a] -> [b] -> Bool
mapAllRows :: Monad m => ([PersistValue] -> m a) -> RowPopper m -> m [a]
phantomDb :: PersistBackend m => m (proxy (PhantomDb m))
getAutoKeyType :: DbDescriptor db => proxy db -> DbTypePrimitive
getUniqueFields :: UniqueDef' str (Either field str) -> [field]
isSimple :: [ConstructorDef] -> Bool

-- | <i>Deprecated: Use deleteBy instead</i>
deleteByKey :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m ()
instance Eq str => Eq (PSFieldDef str)
instance Show str => Show (PSFieldDef str)
instance (MonadIO m, MonadLogger m, MonadBaseControl IO m, MonadReader cm m, ConnectionManager cm conn) => HasConn m cm conn

module Database.Groundhog.Instances
instance [overlap ok] Show (Key v u) => ToJSON (Key v u)
instance [overlap ok] Read (Key v u) => FromJSON (Key v u)
instance [overlap ok] ToJSON PersistValue
instance [overlap ok] FromJSON PersistValue
instance [overlap ok] Constructor c => EntityConstr' HTrue c
instance [overlap ok] EntityConstr' HFalse c
instance [overlap ok] (PersistEntity v, EntityConstr' (IsSumType v) c) => EntityConstr v c
instance [overlap ok] (PersistEntity v, IsUniqueKey k, k ~ Key v (Unique u)) => FieldLike (u (UniqueMarker v)) k
instance [overlap ok] (EntityConstr v c, PersistField a) => FieldLike (Field v c a) a
instance [overlap ok] (EntityConstr v c, PersistField a) => FieldLike (SubField db v c a) a
instance [overlap ok] (EntityConstr v c, a ~ AutoKey v) => FieldLike (AutoKeyField v c) a
instance [overlap ok] (PersistEntity v, IsUniqueKey k, k ~ Key v (Unique u)) => Assignable (u (UniqueMarker v)) k
instance [overlap ok] (EntityConstr v c, PersistField a) => Assignable (Field v c a) a
instance [overlap ok] (EntityConstr v c, PersistField a) => Assignable (SubField db v c a) a
instance [overlap ok] (EntityConstr v c, a ~ AutoKey v) => Assignable (AutoKeyField v c) a
instance [overlap ok] (Projection a1 a1', Projection a2 a2', Projection a3 a3', Projection a4 a4', Projection a5 a5') => Projection (a1, a2, a3, a4, a5) (a1', a2', a3', a4', a5')
instance [overlap ok] (Projection a1 a1', Projection a2 a2', Projection a3 a3', Projection a4 a4') => Projection (a1, a2, a3, a4) (a1', a2', a3', a4')
instance [overlap ok] (Projection a1 a1', Projection a2 a2', Projection a3 a3') => Projection (a1, a2, a3) (a1', a2', a3')
instance [overlap ok] (Projection a1 a1', Projection a2 a2') => Projection (a1, a2) (a1', a2')
instance [overlap ok] (PersistEntity v, IsUniqueKey k, k ~ Key v (Unique u)) => Projection (u (UniqueMarker v)) k
instance [overlap ok] EntityConstr v c => Projection (c (ConstructorMarker v)) v
instance [overlap ok] (EntityConstr v c, a ~ AutoKey v) => Projection (AutoKeyField v c) a
instance [overlap ok] a ~ Bool => Projection (Cond db r) a
instance [overlap ok] PersistField a => Projection (Expr db r a) a
instance [overlap ok] (EntityConstr v c, PersistField a) => Projection (SubField db v c a) a
instance [overlap ok] (EntityConstr v c, PersistField a) => Projection (Field v c a) a
instance [overlap ok] (DbDescriptor db, PersistEntity v, PersistField v) => PersistField (KeyForBackend db v)
instance [overlap ok] (PersistField a, PersistField b, PersistField c, PersistField d, PersistField e) => PersistField (a, b, c, d, e)
instance [overlap ok] (PersistField a, PersistField b, PersistField c, PersistField d) => PersistField (a, b, c, d)
instance [overlap ok] (PersistField a, PersistField b, PersistField c) => PersistField (a, b, c)
instance [overlap ok] (PersistField a, PersistField b) => PersistField (a, b)
instance [overlap ok] PersistField ()
instance [overlap ok] PersistField a => PersistField [a]
instance [overlap ok] (PersistField a, NeverNull a) => PersistField (Maybe a)
instance [overlap ok] PersistField ZonedTime
instance [overlap ok] PersistField UTCTime
instance [overlap ok] PersistField TimeOfDay
instance [overlap ok] PersistField Day
instance [overlap ok] PersistField Bool
instance [overlap ok] PersistField Double
instance [overlap ok] PersistField Word64
instance [overlap ok] PersistField Word32
instance [overlap ok] PersistField Word16
instance [overlap ok] PersistField Word8
instance [overlap ok] PersistField Int64
instance [overlap ok] PersistField Int32
instance [overlap ok] PersistField Int16
instance [overlap ok] PersistField Int8
instance [overlap ok] PersistField Int
instance [overlap ok] PersistField Text
instance [overlap ok] PersistField String
instance [overlap ok] PersistField ByteString
instance [overlap ok] PersistField ByteString
instance [overlap ok] NeverNull (KeyForBackend db v)
instance [overlap ok] PrimitivePersistField (Key v u) => NeverNull (Key v u)
instance [overlap ok] NeverNull ZonedTime
instance [overlap ok] NeverNull UTCTime
instance [overlap ok] NeverNull TimeOfDay
instance [overlap ok] NeverNull Day
instance [overlap ok] NeverNull Bool
instance [overlap ok] NeverNull Double
instance [overlap ok] NeverNull Word64
instance [overlap ok] NeverNull Word32
instance [overlap ok] NeverNull Word16
instance [overlap ok] NeverNull Word8
instance [overlap ok] NeverNull Int64
instance [overlap ok] NeverNull Int32
instance [overlap ok] NeverNull Int16
instance [overlap ok] NeverNull Int8
instance [overlap ok] NeverNull Int
instance [overlap ok] NeverNull ByteString
instance [overlap ok] NeverNull ByteString
instance [overlap ok] NeverNull Text
instance [overlap ok] NeverNull String
instance [overlap ok] PrimitivePersistField a => SinglePersistField a
instance [overlap ok] PrimitivePersistField a => PurePersistField a
instance [overlap ok] (DbDescriptor db, PersistEntity v, PersistField v) => PrimitivePersistField (KeyForBackend db v)
instance [overlap ok] (PrimitivePersistField a, NeverNull a) => PrimitivePersistField (Maybe a)
instance [overlap ok] PrimitivePersistField ZonedTime
instance [overlap ok] PrimitivePersistField UTCTime
instance [overlap ok] PrimitivePersistField TimeOfDay
instance [overlap ok] PrimitivePersistField Day
instance [overlap ok] PrimitivePersistField Bool
instance [overlap ok] PrimitivePersistField Double
instance [overlap ok] PrimitivePersistField Word64
instance [overlap ok] PrimitivePersistField Word32
instance [overlap ok] PrimitivePersistField Word16
instance [overlap ok] PrimitivePersistField Word8
instance [overlap ok] PrimitivePersistField Int64
instance [overlap ok] PrimitivePersistField Int32
instance [overlap ok] PrimitivePersistField Int16
instance [overlap ok] PrimitivePersistField Int8
instance [overlap ok] PrimitivePersistField Int
instance [overlap ok] PrimitivePersistField ByteString
instance [overlap ok] PrimitivePersistField ByteString
instance [overlap ok] PrimitivePersistField Text
instance [overlap ok] PrimitivePersistField String
instance [overlap ok] (PurePersistField a, PurePersistField b, PurePersistField c, PurePersistField d, PurePersistField e) => PurePersistField (a, b, c, d, e)
instance [overlap ok] (PurePersistField a, PurePersistField b, PurePersistField c, PurePersistField d) => PurePersistField (a, b, c, d)
instance [overlap ok] (PurePersistField a, PurePersistField b, PurePersistField c) => PurePersistField (a, b, c)
instance [overlap ok] (PurePersistField a, PurePersistField b) => PurePersistField (a, b)
instance [overlap ok] PurePersistField ()
instance [overlap ok] (PersistField a', PersistField b', PersistField c', PersistField d', PersistField e') => Embedded (a', b', c', d', e')
instance [overlap ok] (PersistField a', PersistField b', PersistField c', PersistField d') => Embedded (a', b', c', d')
instance [overlap ok] (PersistField a', PersistField b', PersistField c') => Embedded (a', b', c')
instance [overlap ok] (PersistField a', PersistField b') => Embedded (a', b')


-- | This module provides mechanism for flexible and typesafe usage of
--   plain data values and fields. The expressions can used in conditions
--   and right part of Update statement. Example:
--   
--   <pre>
--   StringField ==. "abc" &amp;&amp;. NumberField &gt;. (0 :: Int) ||. MaybeField ==. (Nothing :: Maybe String) ||. MaybeField ==. Just "def"
--   </pre>
--   
--   Note that polymorphic values like numbers or Nothing must have a type
--   annotation. Comparison operators specific for SQL such as IN and LIKE
--   are defined in <a>Database.Groundhog.Generic.Sql.Functions</a>.
module Database.Groundhog.Expression

-- | Instances of this type can be converted to <a>UntypedExpr</a>. It is
--   useful for uniform manipulation over fields, constant values, etc.
class Expression db r a
toExpr :: Expression db r a => a -> UntypedExpr db r
class Unifiable a b

-- | This helper class can make type signatures more concise
class (Expression db r a, PersistField a') => ExpressionOf db r a a' | a -> a'

-- | Update field
(=.) :: (Assignable f a', ProjectionDb f db, ProjectionRestriction f r, Expression db r b, Unifiable f b) => f -> b -> Update db r

-- | Boolean "and" operator.
(&&.) :: Cond db r -> Cond db r -> Cond db r

-- | Boolean "or" operator.
(||.) :: Cond db r -> Cond db r -> Cond db r
(==.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(/=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(<.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(<=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(>.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(>=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r

-- | This function more limited than (==.), but has better type inference.
--   If you want to compare your value to Nothing with <tt>(==.)</tt>
--   operator, you have to write the types explicitly <tt>myExpr ==.
--   (Nothing :: Maybe Int)</tt>. TODO: restrict db r
isFieldNothing :: (Expression db r f, Projection f (Maybe a), PrimitivePersistField (Maybe a), Unifiable f (Maybe a)) => f -> Cond db r

-- | Converts value to <a>Expr</a>. It can help to pass values of different
--   types into functions which expect arguments of the same type, like
--   (+).
liftExpr :: ExpressionOf db r a a' => a -> Expr db r a'

-- | It is kept for compatibility with older Groundhog versions and can be
--   replaced with "liftExpr".

-- | <i>Deprecated: Please use liftExpr instead</i>
toArith :: ExpressionOf db r a a' => a -> Expr db r a'
instance [overlap ok] k ~ Key v u => NormalizeKey HFalse v u k
instance [overlap ok] k ~ v => NormalizeKey HTrue v u k
instance [overlap ok] TypeEq x x HTrue
instance [overlap ok] b ~ HFalse => TypeEq x y b
instance [overlap ok] r ~ (HTrue, a) => NormalizeValue a r
instance [overlap ok] (TypeEq (DefaultKey v) (Key v u) isDef, NormalizeKey isDef v u k, r ~ (Not isDef, k)) => NormalizeValue (Key v u) r
instance [overlap ok] (TypeEq (DefaultKey v) (Key v u) isDef, NormalizeKey isDef v u k, r ~ (Not isDef, Maybe k)) => NormalizeValue (Maybe (Key v u)) r
instance [overlap ok] r ~ (HTrue, t) => Normalize HTrue t r
instance [overlap ok] NormalizeValue t r => Normalize HFalse t r
instance [overlap ok] r ~ (HTrue, Bool) => Normalize HTrue (Cond db r') r
instance [overlap ok] r ~ (HTrue, Bool) => Normalize HFalse (Cond db r') r
instance [overlap ok] r ~ (HFalse, Key v BackendSpecific) => Normalize HTrue (AutoKeyField v c) r
instance [overlap ok] NormalizeValue (Key v BackendSpecific) (isPlain, r) => Normalize HFalse (AutoKeyField v c) (HFalse, r)
instance [overlap ok] r ~ (HFalse, Key v (Unique u)) => Normalize HTrue (u (UniqueMarker v)) r
instance [overlap ok] NormalizeValue (Key v (Unique u)) (isPlain, r) => Normalize HFalse (u (UniqueMarker v)) (HFalse, r)
instance [overlap ok] r ~ (HFalse, a) => Normalize HTrue (Expr db r' a) r
instance [overlap ok] NormalizeValue a (isPlain, r) => Normalize HFalse (Expr db r' a) (HFalse, r)
instance [overlap ok] r ~ (HFalse, a) => Normalize HTrue (SubField db v c a) r
instance [overlap ok] NormalizeValue a (isPlain, r) => Normalize HFalse (SubField db v c a) (HFalse, r)
instance [overlap ok] r ~ (HFalse, a) => Normalize HTrue (Field v c a) r
instance [overlap ok] NormalizeValue a (isPlain, r) => Normalize HFalse (Field v c a) (HFalse, r)
instance [overlap ok] (Normalize bk a (ak, r), Normalize ak b (bk, r)) => Unifiable a b
instance [overlap ok] Unifiable a a
instance [overlap ok] (db' ~ db, r' ~ r) => Expression db' r' (Cond db r)
instance [overlap ok] (PersistEntity v, DbDescriptor db, IsUniqueKey k, k ~ Key v (Unique u), RestrictionHolder v c ~ r') => Expression db r' (u (UniqueMarker v))
instance [overlap ok] (EntityConstr v c, DbDescriptor db, RestrictionHolder v c ~ r') => Expression db r' (AutoKeyField v c)
instance [overlap ok] (EntityConstr v c, DbDescriptor db, PersistField a, db' ~ db, RestrictionHolder v c ~ r') => Expression db' r' (SubField db v c a)
instance [overlap ok] (EntityConstr v c, DbDescriptor db, PersistField a, RestrictionHolder v c ~ r') => Expression db r' (Field v c a)
instance [overlap ok] (PersistField a, db' ~ db, r' ~ r) => Expression db' r' (Expr db r a)
instance [overlap ok] PurePersistField a => Expression db r a
instance [overlap ok] (Expression db r a, Normalize HTrue a (flag, a'), PersistField a') => ExpressionOf db r a a'


-- | This module defines the functions which are used only for backends
--   creation.
module Database.Groundhog.Generic.Sql

-- | Renders conditions for SQL backend. Returns Nothing if the fields
--   don't have any columns.
renderCond :: SqlDb db => RenderConfig -> Cond db r -> Maybe (RenderS db r)
defaultShowPrim :: PersistValue -> String
renderOrders :: SqlDb db => RenderConfig -> [Order db r] -> RenderS db r
renderUpdates :: SqlDb db => RenderConfig -> [Update db r] -> Maybe (RenderS db r)
renderFields :: StringLike s => (s -> s) -> [(String, DbType)] -> s
renderChain :: RenderConfig -> FieldChain -> [Utf8] -> [Utf8]
renderExpr :: SqlDb db => RenderConfig -> UntypedExpr db r -> RenderS db r
renderExprPriority :: SqlDb db => RenderConfig -> Int -> UntypedExpr db r -> RenderS db r
renderExprExtended :: SqlDb db => RenderConfig -> Int -> UntypedExpr db r -> [RenderS db r]
renderPersistValue :: PersistValue -> RenderS db r

-- | Helps creating an expression which depends on render configuration. It
--   can be used in pair with <a>prerenderExpr</a>. <tt> myExpr x =
--   mkExprWithConf $ conf _ -&gt; let x' = prerenderExpr conf x in x' + x'
--   * x'</tt> @
mkExprWithConf :: (SqlDb db, PersistField a) => (RenderConfig -> Int -> Expr db r a) -> Expr db r a

-- | If we reuse complex expression several times, prerendering it saves
--   time. <a>RenderConfig</a> can be obtained with <a>mkExprWithConf</a>
prerenderExpr :: SqlDb db => RenderConfig -> Expr db r a -> Expr db r a
intercalateS :: StringLike s => s -> [s] -> s
commasJoin :: StringLike s => [s] -> s
flatten :: StringLike s => (s -> s) -> (String, DbType) -> ([s] -> [s])
data RenderS db r
RenderS :: Utf8 -> ([PersistValue] -> [PersistValue]) -> RenderS db r
getQuery :: RenderS db r -> Utf8
getValues :: RenderS db r -> [PersistValue] -> [PersistValue]

-- | Datatype for incremental building SQL queries
newtype Utf8
Utf8 :: Builder -> Utf8
newtype RenderConfig
RenderConfig :: (Utf8 -> Utf8) -> RenderConfig
esc :: RenderConfig -> Utf8 -> Utf8
fromUtf8 :: Utf8 -> ByteString
class (Monoid a, IsString a) => StringLike a
fromChar :: StringLike a => Char -> a
fromString :: IsString a => String -> a

-- | An infix synonym for <a>mappend</a>.
--   
--   <i>Since: 4.5.0.0</i>
(<>) :: Monoid m => m -> m -> m
function :: SqlDb db => String -> [UntypedExpr db r] -> Snippet db r
operator :: (SqlDb db, Expression db r a, Expression db r b) => Int -> String -> a -> b -> Snippet db r
parens :: Int -> Int -> RenderS db r -> RenderS db r
mkExpr :: SqlDb db => Snippet db r -> Expr db r a

-- | Escape function, priority of the outer operator. The result is a list
--   for the embedded data which may expand to several RenderS.
newtype Snippet db r
Snippet :: (RenderConfig -> Int -> [RenderS db r]) -> Snippet db r

-- | This class distinguishes databases which support SQL-specific
--   expressions. It contains ad hoc members for features whose syntax
--   differs across the databases.
class (DbDescriptor db, QueryRaw db ~ Snippet db) => SqlDb db
append :: (SqlDb db, ExpressionOf db r a String, ExpressionOf db r b String) => a -> b -> Expr db r String
signum' :: (SqlDb db, ExpressionOf db r x a, Num a) => x -> Expr db r a
quotRem' :: (SqlDb db, ExpressionOf db r x a, ExpressionOf db r y a, Integral a) => x -> y -> (Expr db r a, Expr db r a)
equalsOperator :: SqlDb db => RenderS db r -> RenderS db r -> RenderS db r
notEqualsOperator :: SqlDb db => RenderS db r -> RenderS db r -> RenderS db r

-- | This class distinguishes databases which support trigonometry and
--   other math functions. For example, PostgreSQL has them but Sqlite does
--   not. It contains ad hoc members for features whose syntax differs
--   across the databases.
class SqlDb db => FloatingSqlDb db
log' :: (FloatingSqlDb db, ExpressionOf db r x a, Floating a) => x -> Expr db r a
logBase' :: (FloatingSqlDb db, ExpressionOf db r b a, ExpressionOf db r x a, Floating a) => b -> x -> Expr db r a

-- | Returns escaped table name optionally qualified with schema
tableName :: StringLike s => (s -> s) -> EntityDef -> ConstructorDef -> s

-- | Returns escaped main table name optionally qualified with schema
mainTableName :: StringLike s => (s -> s) -> EntityDef -> s
instance StringLike String
instance StringLike (RenderS db r)
instance IsString (RenderS db r)
instance Monoid (RenderS db r)
instance StringLike Utf8
instance IsString Utf8
instance Monoid Utf8


-- | This helper module is intended for use by the backend creators
module Database.Groundhog.Generic.Migration
data Column
Column :: String -> Bool -> DbTypePrimitive -> Maybe String -> Column
colName :: Column -> String
colNull :: Column -> Bool
colType :: Column -> DbTypePrimitive
colDefault :: Column -> Maybe String
data Reference
Reference :: QualifiedName -> [(String, String)] -> Maybe ReferenceActionType -> Maybe ReferenceActionType -> Reference
referencedTableName :: Reference -> QualifiedName

-- | child column, parent column
referencedColumns :: Reference -> [(String, String)]
referenceOnDelete :: Reference -> Maybe ReferenceActionType
referenceOnUpdate :: Reference -> Maybe ReferenceActionType

-- | Schema-qualified name of a table of another database object
type QualifiedName = (Maybe String, String)
data TableInfo
TableInfo :: [Column] -> [UniqueDefInfo] -> [(Maybe String, Reference)] -> TableInfo
tableColumns :: TableInfo -> [Column]
tableUniques :: TableInfo -> [UniqueDefInfo]

-- | constraint name and reference
tableReferences :: TableInfo -> [(Maybe String, Reference)]

-- | Either column name or expression
type UniqueDefInfo = UniqueDef' String (Either String String)
data AlterColumn
Type :: DbTypePrimitive -> AlterColumn
IsNull :: AlterColumn
NotNull :: AlterColumn
Default :: String -> AlterColumn
NoDefault :: AlterColumn
UpdateValue :: String -> AlterColumn
data AlterTable
AddUnique :: UniqueDefInfo -> AlterTable
DropConstraint :: String -> AlterTable
DropIndex :: String -> AlterTable
AddReference :: Reference -> AlterTable
DropReference :: String -> AlterTable
DropColumn :: String -> AlterTable
AddColumn :: Column -> AlterTable
AlterColumn :: Column -> [AlterColumn] -> AlterTable
data AlterDB
AddTable :: String -> AlterDB

-- | Qualified table name, create statement, structure of table from DB,
--   structure of table from datatype, alters
AlterTable :: QualifiedName -> String -> TableInfo -> TableInfo -> [AlterTable] -> AlterDB

-- | Qualified trigger name, qualified table name
DropTrigger :: QualifiedName -> QualifiedName -> AlterDB

-- | Qualified trigger name, qualified table name, body
AddTriggerOnDelete :: QualifiedName -> QualifiedName -> String -> AlterDB

-- | Qualified trigger name, qualified table name, field name, body
AddTriggerOnUpdate :: QualifiedName -> QualifiedName -> (Maybe String) -> String -> AlterDB

-- | Statement which creates the function
CreateOrReplaceFunction :: String -> AlterDB

-- | Qualified function name
DropFunction :: QualifiedName -> AlterDB

-- | Schema name, if not exists
CreateSchema :: String -> Bool -> AlterDB
data MigrationPack m
MigrationPack :: (DbTypePrimitive -> DbTypePrimitive -> Bool) -> ((Maybe String, Reference) -> (Maybe String, Reference) -> Bool) -> (UniqueDefInfo -> UniqueDefInfo -> Bool) -> (String -> String -> Bool) -> (QualifiedName -> [(String, String)] -> m (Bool, [AlterDB])) -> (QualifiedName -> [(String, String)] -> m [(Bool, [AlterDB])]) -> (MigrationPack m -> EntityDef -> ConstructorDef -> m (Bool, SingleMigration)) -> (String -> String) -> String -> String -> Int -> ([UniqueDefInfo] -> [Reference] -> ([String], [AlterTable])) -> (DbTypePrimitive -> String) -> (Column -> String) -> (AlterDB -> SingleMigration) -> ReferenceActionType -> ReferenceActionType -> MigrationPack m
compareTypes :: MigrationPack m -> DbTypePrimitive -> DbTypePrimitive -> Bool
compareRefs :: MigrationPack m -> (Maybe String, Reference) -> (Maybe String, Reference) -> Bool
compareUniqs :: MigrationPack m -> UniqueDefInfo -> UniqueDefInfo -> Bool
compareDefaults :: MigrationPack m -> String -> String -> Bool
migTriggerOnDelete :: MigrationPack m -> QualifiedName -> [(String, String)] -> m (Bool, [AlterDB])
migTriggerOnUpdate :: MigrationPack m -> QualifiedName -> [(String, String)] -> m [(Bool, [AlterDB])]
migConstr :: MigrationPack m -> MigrationPack m -> EntityDef -> ConstructorDef -> m (Bool, SingleMigration)
escape :: MigrationPack m -> String -> String
autoincrementedKeyTypeName :: MigrationPack m -> String
mainTableId :: MigrationPack m -> String
defaultPriority :: MigrationPack m -> Int

-- | Sql pieces for the create table statement that add constraints and
--   alterations for running after the table is created
addUniquesReferences :: MigrationPack m -> [UniqueDefInfo] -> [Reference] -> ([String], [AlterTable])
showSqlType :: MigrationPack m -> DbTypePrimitive -> String
showColumn :: MigrationPack m -> Column -> String
showAlterDb :: MigrationPack m -> AlterDB -> SingleMigration
defaultReferenceOnDelete :: MigrationPack m -> ReferenceActionType
defaultReferenceOnUpdate :: MigrationPack m -> ReferenceActionType
class (Applicative m, Monad m) => SchemaAnalyzer m
schemaExists :: SchemaAnalyzer m => String -> m Bool
getCurrentSchema :: SchemaAnalyzer m => m (Maybe String)
listTables :: SchemaAnalyzer m => Maybe String -> m [String]
listTableTriggers :: SchemaAnalyzer m => QualifiedName -> m [String]
analyzeTable :: SchemaAnalyzer m => QualifiedName -> m (Maybe TableInfo)
analyzeTrigger :: SchemaAnalyzer m => QualifiedName -> m (Maybe String)
analyzeFunction :: SchemaAnalyzer m => QualifiedName -> m (Maybe (Maybe [DbTypePrimitive], Maybe DbTypePrimitive, String))
getMigrationPack :: SchemaAnalyzer m => m (MigrationPack m)

-- | Create migration for a given entity and all entities it depends on.
--   The stateful Map is used to avoid duplicate migrations when an entity
--   type occurs several times in a datatype
migrateRecursively :: (PersistBackend m, PersistEntity v) => (String -> m SingleMigration) -> (EntityDef -> m SingleMigration) -> (DbType -> m SingleMigration) -> v -> Migration m
migrateSchema :: SchemaAnalyzer m => MigrationPack m -> String -> m SingleMigration
migrateEntity :: (SchemaAnalyzer m, PersistBackend m) => MigrationPack m -> EntityDef -> m SingleMigration
migrateList :: (SchemaAnalyzer m, PersistBackend m) => MigrationPack m -> DbType -> m SingleMigration
getAlters :: MigrationPack m -> TableInfo -> TableInfo -> [AlterTable]
defaultMigConstr :: (SchemaAnalyzer m, PersistBackend m) => MigrationPack m -> EntityDef -> ConstructorDef -> m (Bool, SingleMigration)
showReferenceAction :: ReferenceActionType -> String
readReferenceAction :: String -> Maybe ReferenceActionType
instance Eq Column
instance Show Column
instance Show Reference
instance Show TableInfo
instance Show AlterColumn
instance Show AlterTable
instance Show AlterDB


-- | This module has common SQL functions and operators which are supported
--   in the most SQL databases
module Database.Groundhog.Generic.Sql.Functions
like :: (SqlDb db, ExpressionOf db r a a', IsString a') => a -> String -> Cond db r
notLike :: (SqlDb db, ExpressionOf db r a a', IsString a') => a -> String -> Cond db r
in_ :: (SqlDb db, Expression db r a, Expression db r b, PrimitivePersistField b, Unifiable a b) => a -> [b] -> Cond db r
notIn_ :: (SqlDb db, Expression db r a, Expression db r b, PrimitivePersistField b, Unifiable a b) => a -> [b] -> Cond db r
lower :: (SqlDb db, ExpressionOf db r a a', IsString a') => a -> Expr db r a'
upper :: (SqlDb db, ExpressionOf db r a a', IsString a') => a -> Expr db r a'
case_ :: (SqlDb db, ExpressionOf db r a a', ExpressionOf db r b a') => [(Cond db r, a)] -> b -> Expr db r a'

-- | This class distinguishes databases which support SQL-specific
--   expressions. It contains ad hoc members for features whose syntax
--   differs across the databases.
class (DbDescriptor db, QueryRaw db ~ Snippet db) => SqlDb db
append :: (SqlDb db, ExpressionOf db r a String, ExpressionOf db r b String) => a -> b -> Expr db r String
signum' :: (SqlDb db, ExpressionOf db r x a, Num a) => x -> Expr db r a
quotRem' :: (SqlDb db, ExpressionOf db r x a, ExpressionOf db r y a, Integral a) => x -> y -> (Expr db r a, Expr db r a)
equalsOperator :: SqlDb db => RenderS db r -> RenderS db r -> RenderS db r
notEqualsOperator :: SqlDb db => RenderS db r -> RenderS db r -> RenderS db r
cot :: (FloatingSqlDb db, ExpressionOf db r a a', Floating a') => a -> Expr db r a'

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a
radians :: (FloatingSqlDb db, ExpressionOf db r a a', Floating a') => a -> Expr db r a'
degrees :: (FloatingSqlDb db, ExpressionOf db r a a', Floating a') => a -> Expr db r a'
instance (SqlDb db, PurePersistField a, Integral a) => Integral (Expr db r a)
instance (SqlDb db, PersistField a, Enum a) => Enum (Expr db r a)
instance (SqlDb db, PersistField a, Real a) => Real (Expr db r a)
instance (SqlDb db, PersistField a, Ord a) => Ord (Expr db r a)
instance (FloatingSqlDb db, PersistField a, Floating a) => Floating (Expr db r a)
instance (SqlDb db, PersistField a, Fractional a) => Fractional (Expr db r a)
instance (SqlDb db, PersistField a, Num a) => Num (Expr db r a)


-- | This helper module contains generic versions of PersistBackend
--   functions
module Database.Groundhog.Generic.PersistBackendHelpers
get :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> Key v BackendSpecific -> m (Maybe v)
select :: (SqlDb db, db ~ PhantomDb m, r ~ RestrictionHolder v c, PersistBackend m, PersistEntity v, EntityConstr v c, HasSelectOptions opts db r) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> (opts -> RenderS db r) -> Utf8 -> opts -> m [v]
selectAll :: (PersistBackend m, PersistEntity v) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> m [(AutoKey v, v)]
getBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> Key v (Unique u) -> m (Maybe v)
project :: (SqlDb db, db ~ PhantomDb m, r ~ RestrictionHolder v c, PersistBackend m, PersistEntity v, EntityConstr v c, Projection p a', ProjectionDb p db, ProjectionRestriction p r, HasSelectOptions opts db r) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> (opts -> RenderS db r) -> Utf8 -> p -> opts -> m [a']
count :: (SqlDb db, db ~ PhantomDb m, r ~ RestrictionHolder v c, PersistBackend m, PersistEntity v, EntityConstr v c) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> Cond db r -> m Int
replace :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> (Utf8 -> [PersistValue] -> m ()) -> (Bool -> Utf8 -> ConstructorDef -> [PersistValue] -> RenderS db r) -> Key v BackendSpecific -> v -> m ()
replaceBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => RenderConfig -> (Utf8 -> [PersistValue] -> m ()) -> u (UniqueMarker v) -> v -> m ()
update :: (SqlDb db, db ~ PhantomDb m, r ~ RestrictionHolder v c, PersistBackend m, PersistEntity v, EntityConstr v c) => RenderConfig -> (Utf8 -> [PersistValue] -> m ()) -> [Update db r] -> Cond db r -> m ()
delete :: (SqlDb db, db ~ PhantomDb m, r ~ RestrictionHolder v c, PersistBackend m, PersistEntity v, EntityConstr v c) => RenderConfig -> (Utf8 -> [PersistValue] -> m ()) -> Cond db r -> m ()
deleteBy :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => RenderConfig -> (Utf8 -> [PersistValue] -> m ()) -> Key v BackendSpecific -> m ()
deleteAll :: (PersistBackend m, PersistEntity v) => RenderConfig -> (Utf8 -> [PersistValue] -> m ()) -> v -> m ()
insertByAll :: (PersistBackend m, PersistEntity v) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> Bool -> v -> m (Either (AutoKey v) (AutoKey v))
countAll :: (PersistBackend m, PersistEntity v) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> v -> m Int
insertBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => RenderConfig -> (forall a. Utf8 -> [PersistValue] -> (RowPopper m -> m a) -> m a) -> Bool -> u (UniqueMarker v) -> v -> m (Either (AutoKey v) (AutoKey v))


-- | This module exports the most commonly used functions and datatypes.
--   
--   See <a>http://github.com/lykahb/groundhog/blob/master/examples/</a>.
module Database.Groundhog
class (Monad m, DbDescriptor (PhantomDb m)) => PersistBackend m where type family PhantomDb m
insert :: (PersistBackend m, PersistEntity v) => v -> m (AutoKey v)
insert_ :: (PersistBackend m, PersistEntity v) => v -> m ()
insertBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> v -> m (Either (AutoKey v) (AutoKey v))
insertByAll :: (PersistBackend m, PersistEntity v) => v -> m (Either (AutoKey v) (AutoKey v))
replace :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> v -> m ()
replaceBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => u (UniqueMarker v) -> v -> m ()
select :: (PersistBackend m, PersistEntity v, EntityConstr v c, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c)) => opts -> m [v]
selectAll :: (PersistBackend m, PersistEntity v) => m [(AutoKey v, v)]
get :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m (Maybe v)
getBy :: (PersistBackend m, PersistEntity v, IsUniqueKey (Key v (Unique u))) => Key v (Unique u) -> m (Maybe v)
update :: (PersistBackend m, PersistEntity v, EntityConstr v c) => [Update (PhantomDb m) (RestrictionHolder v c)] -> Cond (PhantomDb m) (RestrictionHolder v c) -> m ()
delete :: (PersistBackend m, PersistEntity v, EntityConstr v c) => Cond (PhantomDb m) (RestrictionHolder v c) -> m ()
deleteBy :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m ()
deleteAll :: (PersistBackend m, PersistEntity v) => v -> m ()
count :: (PersistBackend m, PersistEntity v, EntityConstr v c) => Cond (PhantomDb m) (RestrictionHolder v c) -> m Int
countAll :: (PersistBackend m, PersistEntity v) => v -> m Int
project :: (PersistBackend m, PersistEntity v, EntityConstr v c, Projection' p (PhantomDb m) (RestrictionHolder v c) a, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c)) => p -> opts -> m [a]
migrate :: (PersistBackend m, PersistEntity v) => v -> Migration m
executeRaw :: PersistBackend m => Bool -> String -> [PersistValue] -> m ()
queryRaw :: PersistBackend m => Bool -> String -> [PersistValue] -> (RowPopper m -> m a) -> m a
insertList :: (PersistBackend m, PersistField a) => [a] -> m Int64
getList :: (PersistBackend m, PersistField a) => Int64 -> m [a]
newtype DbPersist conn m a
DbPersist :: ReaderT conn m a -> DbPersist conn m a
unDbPersist :: DbPersist conn m a -> ReaderT conn m a

-- | A holder for Unique constraints
data Unique (u :: (* -> *) -> *)

-- | A phantom datatype to make instance head different <tt>u (UniqueMarker
--   v)</tt>
data UniqueMarker v a

-- | Key marked with this type can have value for any backend
data BackendSpecific

-- | Creates value of unique key using the data extracted from the passed
--   value
extractUnique :: (IsUniqueKey uKey, uKey ~ Key v u) => v -> uKey

-- | Represents condition for a query.
data Cond db r
And :: (Cond db r) -> (Cond db r) -> Cond db r
Or :: (Cond db r) -> (Cond db r) -> Cond db r
Not :: (Cond db r) -> Cond db r
Compare :: ExprRelation -> (UntypedExpr db r) -> (UntypedExpr db r) -> Cond db r
CondRaw :: (QueryRaw db r) -> Cond db r
CondEmpty :: Cond db r

-- | Defines sort order of a result-set
data Order db r
Asc :: f -> Order db r
Desc :: f -> Order db r

-- | It can be used in expressions like a regular field. For example,
--   <tt>delete (AutoKeyField ==. k)</tt> or <tt>delete (AutoKeyField ==. k
--   ||. SomeField ==. "DUPLICATE")</tt>
data AutoKeyField v (c :: (* -> *) -> *)
AutoKeyField :: AutoKeyField v c

-- | Accesses fields of the embedded datatypes. For example, <tt>SomeField
--   ==. ("abc", "def") ||. SomeField ~&gt; Tuple2_0Selector ==. "def"</tt>
(~>) :: (EntityConstr v c, FieldLike f a, DbDescriptor db, Projection' f db (RestrictionHolder v c) a, Embedded a) => f -> Selector a a' -> SubField db v c a'
limitTo :: (HasSelectOptions a db r, HasLimit a ~ HFalse) => a -> Int -> SelectOptions db r HTrue (HasOffset a) (HasOrder a) (HasDistinct a)
offsetBy :: (HasSelectOptions a db r, HasOffset a ~ HFalse) => a -> Int -> SelectOptions db r (HasLimit a) HTrue (HasOrder a) (HasDistinct a)
orderBy :: (HasSelectOptions a db r, HasOrder a ~ HFalse) => a -> [Order db r] -> SelectOptions db r (HasLimit a) (HasOffset a) HTrue (HasDistinct a)

-- | <i>Deprecated: Use deleteBy instead</i>
deleteByKey :: (PersistBackend m, PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m ()

-- | Update field
(=.) :: (Assignable f a', ProjectionDb f db, ProjectionRestriction f r, Expression db r b, Unifiable f b) => f -> b -> Update db r

-- | Boolean "and" operator.
(&&.) :: Cond db r -> Cond db r -> Cond db r

-- | Boolean "or" operator.
(||.) :: Cond db r -> Cond db r -> Cond db r
(==.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(/=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(<.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(<=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(>.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r
(>=.) :: (Expression db r a, Expression db r b, Unifiable a b) => a -> b -> Cond db r

-- | This function more limited than (==.), but has better type inference.
--   If you want to compare your value to Nothing with <tt>(==.)</tt>
--   operator, you have to write the types explicitly <tt>myExpr ==.
--   (Nothing :: Maybe Int)</tt>. TODO: restrict db r
isFieldNothing :: (Expression db r f, Projection f (Maybe a), PrimitivePersistField (Maybe a), Unifiable f (Maybe a)) => f -> Cond db r

-- | Converts value to <a>Expr</a>. It can help to pass values of different
--   types into functions which expect arguments of the same type, like
--   (+).
liftExpr :: ExpressionOf db r a a' => a -> Expr db r a'

-- | It is kept for compatibility with older Groundhog versions and can be
--   replaced with "liftExpr".

-- | <i>Deprecated: Please use liftExpr instead</i>
toArith :: ExpressionOf db r a a' => a -> Expr db r a'

-- | Produce the migrations but not execute them. Fails when an unsafe
--   migration occurs.
createMigration :: Monad m => Migration m -> m NamedMigrations

-- | Execute the migrations with printing to stderr. Fails when an unsafe
--   migration occurs.
executeMigration :: (PersistBackend m, MonadIO m) => NamedMigrations -> m ()

-- | Execute migrations. Executes the unsafe migrations without warnings
--   and prints them to stderr
executeMigrationUnsafe :: (PersistBackend m, MonadIO m) => NamedMigrations -> m ()

-- | Creates migrations and executes them with printing to stderr. Fails
--   when an unsafe migration occurs. &gt; runMigration m = createMigration
--   m &gt;&gt;= executeMigration
runMigration :: (PersistBackend m, MonadIO m) => Migration m -> m ()

-- | Creates migrations and executes them with printing to stderr. Executes
--   the unsafe migrations without warnings &gt; runMigrationUnsafe m =
--   createMigration m &gt;&gt;= executeMigrationUnsafe
runMigrationUnsafe :: (PersistBackend m, MonadIO m) => Migration m -> m ()

-- | Pretty print the migrations
printMigration :: MonadIO m => NamedMigrations -> m ()
