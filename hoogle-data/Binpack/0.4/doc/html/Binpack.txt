-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common bin-packing heuristics.
--   
--   An implementation of the first-fit, modified-first-fit, last-fit,
--   best-fit, sum-of-squares-fit, worst-fit, and almost-last-fit bin
--   packing heuristics. Items can be packed in order of both decreasing
--   and increasing size (and, of course, in unmodified order).
--   
--   The module supports both the standard (textbook) minimization problem
--   (<i>How many bins do I need?</i>) and the more practical fitting
--   problem (<i>I've got n bins; which items can I take?</i>).
--   
--   The API is simple and the module is documented with Haddock (complete
--   with examples). The implementation of the above-mentioned heuristics
--   is complete and partially tested with QuickCheck. However, note that
--   speed has not been a primary concern to date.
--   
--   Patches and feedback are very welcome.
@package Binpack
@version 0.4


-- | This module implements a number of common bin-packing heuristics:
--   <a>FirstFit</a>, <a>LastFit</a>, <a>BestFit</a>, <a>WorstFit</a>, and
--   <a>AlmostWorstFit</a>. In addition, the not-so-common, but
--   analytically superior (in terms of worst-case behavior),
--   <a>ModifiedFirstFit</a> heuristic is also supported. Further, the
--   (slow) <a>SumOfSquaresFit</a> heuristic, which has been considered in
--   the context of online bin-packing (Bender et al., 2008), is also
--   supported.
--   
--   Items can be packed in order of both <a>Decreasing</a> and
--   <a>Increasing</a> size (and, of course, in unmodified order; see
--   <a>AsGiven</a>).
--   
--   The module supports both the standard (textbook) minimization problem
--   (<i>"How many bins do I need to pack all items?"</i>; see
--   <a>minimizeBins</a> and <a>countBins</a>) and the more practical
--   fitting problem (<i>"I've got n bins; which items can I take?"</i>;
--   see <a>binpack</a>).
--   
--   The well-known heuristics are described online in many places and are
--   not further discussed here. For example, see
--   <a>http://www.cs.arizona.edu/icon/oddsends/bpack/bpack.htm</a> for an
--   overview. A description of the <a>ModifiedFirstFit</a> algorithm is
--   harder to come by online, hence a brief description and references are
--   provided below.
--   
--   Note that most published analysis assumes items to be sorted in some
--   specific (mostly <a>Decreasing</a>) order. This module does not
--   enforce such assumptions, rather, any ordering can be combined with
--   any placement heuristic.
--   
--   If unsure what to pick, then try <a>FirstFit</a> <a>Decreasing</a> or
--   <a>BestFit</a> <a>Decreasing</a> as a default. Use <a>WorstFit</a>
--   <a>Decreasing</a> (in combination with <a>binpack</a>) if you want a
--   pre-determined number of bins filled evenly.
--   
--   A short overview of the <a>ModifiedFirstFit</a> heuristic follows.
--   This overview is based on the description given in (Yue and Zhang,
--   1995).
--   
--   Let <tt>lst</tt> denote the list of items to be bin-packed, let
--   <tt>x</tt> denote the size of the smallest element in <tt>lst</tt>,
--   and let <tt>cap</tt> denote the capacity of one bin. <tt>lst</tt> is
--   split into the four sub-lists, <tt>lA</tt>, <tt>lB</tt>, <tt>lC</tt>,
--   <tt>lD</tt>.
--   
--   <ul>
--   <li><i><tt>lA</tt></i> All items strictly larger than
--   <tt>cap/2</tt>.</li>
--   <li><i><tt>lB</tt></i> All items of size at most <tt>cap/2</tt> and
--   strictly larger than <tt>cap/3</tt>.</li>
--   <li><i><tt>lC</tt></i> All items of size at most <tt>cap/3</tt> and
--   strictly larger than <tt>(cap - x)/5</tt>.</li>
--   <li><i><tt>lD</tt></i> The rest, <i>i.e.</i>, all items of size at
--   most <tt>(cap - x)/5</tt>.</li>
--   </ul>
--   
--   Items are placed as follows:
--   
--   <ol>
--   <li>Create a list of <tt>length lA</tt> bins. Place each item in
--   <tt>lA</tt> into its own bin (while maintaining relative item order
--   with respect to <tt>lst</tt>). Note: relevant published analysis
--   assumes that <tt>lst</tt> is sorted in order of <a>decreasing</a>
--   size.</li>
--   <li>Take the list of bins created in Step 1 and reverse it.</li>
--   <li>Sequentially consider each bin <tt>b</tt>. If the two smallest
--   items in <tt>lC</tt> do NOT fit together into <tt>b</tt> of if there a
--   less than two items remaining in <tt>lC</tt>, then pack nothing into
--   <tt>b</tt> and move on to the next bin (if any). If they do fit
--   together, then find the largest item <tt>x1</tt> in <tt>lC</tt> that
--   would fit together with the smallest item in <tt>lC</tt> into
--   <tt>b</tt>. Remove <tt>x1</tt> from <tt>lC</tt>. Then find the largest
--   item <tt>x2</tt>, <tt>x2 \= x1</tt>, in <tt>lC</tt> that will now fit
--   into <tt>b</tt> <i>together</i> with <tt>x1</tt>. Remove <tt>x1</tt>
--   from <tt>lC</tt>. Place both <tt>x1</tt> and <tt>x2</tt> into
--   <tt>b</tt> and move on to the next item.</li>
--   <li>Reverse the list of bins again.</li>
--   <li>Use the <a>FirstFit</a> heuristic to place all remaining items,
--   <i>i.e.</i>, <tt>lB</tt>, <tt>lD</tt>, and any remaining items of
--   <tt>lC</tt>.</li>
--   </ol>
--   
--   References:
--   
--   <ul>
--   <li>D.S. Johnson and M.R. Garey (1985). A 71/60 Theorem for
--   Bin-Packing. <i>Journal of Complexity</i>, 1:65-106.</li>
--   <li>M. Yue and L. Zhang (1995). A Simple Proof of the Inequality
--   MFFD(L) &lt;= 71/60 OPT(L) + 1, L for the MFFD Bin-Packing Algorithm.
--   <i>Acta Mathematicae Applicatae Sinica</i>, 11(3):318-330.</li>
--   <li>M.A. Bender, B. Bradley, G. Jagannathan, and K. Pillaipakkamnatt
--   (2008). Sum-of-Squares Heuristics for Bin Packing and Memory
--   Allocation. <i>ACM Journal of Experimental Algorithmics</i>,
--   12:1-19.</li>
--   </ul>
module Data.BinPack

-- | What placement heuristic should be used?
data PlacementPolicy

-- | Traverse bin list from <a>head</a> to <a>last</a> and place item in
--   the first bin that has sufficient capacity.
FirstFit :: PlacementPolicy

-- | See above.
ModifiedFirstFit :: PlacementPolicy

-- | Traverse bin list from <a>last</a> to <a>head</a> and place item in
--   the first bin that has sufficient capacity.
LastFit :: PlacementPolicy

-- | Place item in the bin with the most capacity.
BestFit :: PlacementPolicy

-- | Place item in the bin with the least (but sufficient) capacity.
WorstFit :: PlacementPolicy

-- | Choose the 2nd to worst-fitting bin.
AlmostWorstFit :: PlacementPolicy

-- | Choose bin such that sum-of-squares heuristic is minimized.
SumOfSquaresFit :: PlacementPolicy

-- | How to pre-process the input.
data OrderPolicy

-- | Don't modify item order.
AsGiven :: OrderPolicy

-- | Sort from largest to smallest.
Decreasing :: OrderPolicy

-- | Sort from smallest to largest.
Increasing :: OrderPolicy

-- | A function that maps an item <tt>b</tt> to its size <tt>a</tt>. The
--   constraint <tt>(<a>Num</a> a, <a>Ord</a> a)</tt> has been omitted from
--   the type, but is required by the exposed functions.
type Measure a b = b -> a

-- | The list of all possible <a>OrderPolicy</a> choices.
allOrders :: [OrderPolicy]

-- | The list of all possible <a>PlacementPolicy</a> choices.
allPlacements :: [PlacementPolicy]

-- | All supported ordering and placment choices.
allHeuristics :: [(PlacementPolicy, OrderPolicy)]

-- | A <a>Bin</a> consists of the remaining capacity together with a list
--   of items already placed.
type Bin a b = (a, [b])

-- | Create an empty bin.
emptyBin :: (Num a, Ord a) => a -> Bin a b

-- | Create multiple empty bins with uniform capacity.
emptyBins :: (Num a, Ord a) => a -> Int -> [Bin a b]

-- | Turn a list of items into a pre-filled bin.
asBin :: (Ord a, Num a) => a -> Measure a b -> [b] -> Bin a b

-- | Try placing an item inside a <a>Bin</a>.
tryAddItem :: (Num a, Ord a) => a -> b -> Bin a b -> Maybe (Bin a b)

-- | Place an item inside a <a>Bin</a>. Fails if there is insufficient
--   capacity.
addItem :: (Num a, Ord a) => a -> b -> Bin a b -> Bin a b

-- | Add a list of items to an existing bin. Fails if there is insufficient
--   capacity.
addItems :: (Ord a, Num a) => Bin a b -> Measure a b -> [b] -> Bin a b

-- | Get the items in a bin.
items :: Bin a b -> [b]

-- | Get the remaining capacity of a bin.
gap :: Bin a b -> a

-- | Bin-packing without a limit on the number of bins (minimization
--   problem). Assumption: The maximum item size is at most the size of one
--   bin (this is not checked).
--   
--   Examples:
--   
--   <ul>
--   <li>Pack the words of the sentence <i>"Bin packing heuristics are a
--   lot of fun!"</i> into bins of size 11, assuming the size of a word is
--   its length. The <a>Increasing</a> ordering yields a sub-optimal result
--   that leaves a lot of empty space in the bins.</li>
--   </ul>
--   
--   <pre>
--   minimizeBins FirstFit Increasing length 11 (words "Bin packing heuristics are a lot of fun!")
--   ~~&gt; [(2,["are","Bin","of","a"]),(4,["fun!","lot"]),(4,["packing"]),(1,["heuristics"])]
--   </pre>
--   
--   <ul>
--   <li>Similarly, for <a>Int</a>. Note that we use <a>id</a> as a
--   <a>Measure</a> of the size of an <a>Int</a>.</li>
--   </ul>
--   
--   <pre>
--   minimizeBins FirstFit Decreasing id 11 [3,7,10,3,1,3,2,4]
--   ~~&gt; [(0,[1,10]),(0,[4,7]),(0,[2,3,3,3])]
--   </pre>
minimizeBins :: (Num a, Ord a) => PlacementPolicy -> OrderPolicy -> Measure a b -> a -> [b] -> [Bin a b]

-- | Wrapper around <a>minimizeBins</a>; useful if only the number of
--   required bins is of interest. See <a>minimizeBins</a> for a
--   description of the arguments.
--   
--   Examples:
--   
--   <ul>
--   <li>How many bins of size 11 characters each do we need to pack the
--   words of the sentence <i>"Bin packing heuristics are a lot of
--   fun!"</i>?</li>
--   </ul>
--   
--   <pre>
--   countBins FirstFit Increasing length 11 (words "Bin packing heuristics are a lot of fun!")
--   ~~&gt; 4
--   </pre>
--   
--   <ul>
--   <li>Similarly, for <a>Int</a>. As before, we use <a>id</a> as a
--   <a>Measure</a> for the size of an <a>Int</a>.</li>
--   </ul>
--   
--   <pre>
--   countBins FirstFit Decreasing id 11 [3,7,10,3,1,3,2,4]
--   ~~&gt; 3
--   </pre>
countBins :: (Num a, Ord a) => PlacementPolicy -> OrderPolicy -> Measure a b -> a -> [b] -> Int

-- | Bin-pack a list of items into a list of (possibly non-uniform) bins.
--   If an item cannot be placed, instead of creating a new bin, this
--   version will return a list of items that could not be packed (if any).
--   
--   Example: We have two empty bins, one of size 10 and one of size 12.
--   Which words can we fit in there?
--   
--   <pre>
--   binpack WorstFit Decreasing length [emptyBin 10, emptyBin 12]  (words "Bin packing heuristics are a lot of fun!")
--   ~~&gt; ([(0,["Bin","packing"]),(0,["of","heuristics"])],["a","lot","are","fun!"])
--   </pre>
--   
--   Both bins were filled completely, and the words <i>"are a lot
--   fun!"</i> coult not be packed.
binpack :: (Num a, Ord a) => PlacementPolicy -> OrderPolicy -> Measure a b -> [Bin a b] -> [b] -> ([Bin a b], [b])
instance Show PlacementPolicy
instance Eq PlacementPolicy
instance Ord PlacementPolicy
