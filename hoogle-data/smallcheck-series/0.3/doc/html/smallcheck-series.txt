-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extra SmallCheck series and utilities
--   
--   Orphan <tt>Serial</tt> instances and utilities to create and
--   manipulate <tt>Series</tt> for common types.
@package smallcheck-series
@version 0.3

module Test.SmallCheck.Series.Utils

-- | <i>One-to-One</i> zipping of 2 <a>MonadLogic</a> instances. You can
--   use for <a>Series</a> like this:
--   
--   <pre>
--   &gt;&gt;&gt; list 2 $ (series :: Series Identity Char) `zipLogic` (series :: Series Identity Int)
--   [('a',0),('b',1),('c',-1)]
--   </pre>
--   
--   Notice the difference with <a>&gt;&lt;</a>:
--   
--   <pre>
--   &gt;&gt;&gt; list 2 $ (series :: Series Identity Char) &gt;&lt; (series :: Series Identity Int)
--   [('a',0),('b',0),('a',1),('c',0),('a',-1),...,('b',-2),('c',-2)]
--   </pre>
zipLogic :: MonadLogic m => m a -> m b -> m (a, b)

-- | <i>One-to-One</i> zipping of 3 <a>MonadLogic</a> instances. You can
--   use for <a>Series</a> like this:
--   
--   <pre>
--   &gt;&gt;&gt; list 2 $ zipLogic3 (series :: Series Identity Char) (series :: Series Identity Int) (series :: Series Identity Text)
--   [('a',0,""),('b',1,"a"),('c',-1,"aa")]
--   </pre>
zipLogic3 :: MonadLogic m => m a -> m b -> m c -> m (a, b, c)


-- | Following the convention from <a>Data.Text.Lazy</a>, this module is
--   intended to be imported <tt>qualified</tt>. For example:
--   
--   <pre>
--   import qualified Test.SmallCheck.Series.Text.Lazy as L.Series
--   </pre>
module Test.SmallCheck.Series.Text.Lazy

-- | A <a>Text</a> <a>Series</a> that grows by replicating the <tt>a</tt>
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateA
--   ["","a","aa","aaa","aaaa"]
--   </pre>
--   
--   Use this when you don't care about the <a>Char</a>s inside
--   <a>Text</a>.
replicateA :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by replicating the <tt>NUL</tt>
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateNull
--   ["","\NUL","\NUL\NUL","\NUL\NUL\NUL","\NUL\NUL\NUL\NUL"]
--   </pre>
replicateNull :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by replicating the given
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 $ replicateChar '☃'
--   ["","\9731","\9731\9731","\9731\9731\9731","\9731\9731\9731\9731"]
--   </pre>
replicateChar :: Char -> Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating the latin
--   alphabet.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumAlphabet
--   ["","a","ab","abc","abcd"]
--   </pre>
enumAlphabet :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating every
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumChars
--   ["","\NUL","\NUL\SOH","\NUL\SOH\STX","\NUL\SOH\STX\ETX"]
--   </pre>
enumChars :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating every
--   <a>Char</a> in the given <a>String</a>. Notice that the <a>String</a>
--   can be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; list 5 $ enumString "xyz"
--   ["","x","xy","xyz"]
--   </pre>
enumString :: String -> Series m Text

-- | A <a>Text</a> <a>Series</a> that grows with English words.
--   
--   This is useful when you want to print <a>Series</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = list 20 jack
--   
--   &gt;&gt;&gt; take 3 s
--   ["","All","All work"]
--   
--   &gt;&gt;&gt; last s
--   "All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy."
--   </pre>
jack :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows with the first character of
--   each <a>Unicode plane</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 3 enumNonBmp
--   ["","\NUL","\NUL\65536","\NUL\65536\131072"]
--   </pre>
--   
--   Notice that this covers the 16 unicode planes.
--   
--   <pre>
--   &gt;&gt;&gt; last (list 16 enumNonBmp) == last (list 17 enumNonBmp)
--   True
--   </pre>
enumNonBmp :: Series m Text


-- | Following the convention from <a>Data.Text</a>, this module is
--   intended to be imported <tt>qualified</tt>. For example:
--   
--   <pre>
--   import qualified Test.SmallCheck.Series.Text as T.Series
--   </pre>
module Test.SmallCheck.Series.Text

-- | A <a>Text</a> <a>Series</a> that grows by replicating the <tt>a</tt>
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateA
--   ["","a","aa","aaa","aaaa"]
--   </pre>
--   
--   Use this when you don't care about the <a>Char</a>s inside
--   <a>Text</a>.
replicateA :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by replicating the <tt>NUL</tt>
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateNull
--   ["","\NUL","\NUL\NUL","\NUL\NUL\NUL","\NUL\NUL\NUL\NUL"]
--   </pre>
replicateNull :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by replicating the given
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 $ replicateChar '☃'
--   ["","\9731","\9731\9731","\9731\9731\9731","\9731\9731\9731\9731"]
--   </pre>
replicateChar :: Char -> Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating the latin
--   alphabet.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumAlphabet
--   ["","a","ab","abc","abcd"]
--   </pre>
enumAlphabet :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating every
--   <a>Char</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumChars
--   ["","\NUL","\NUL\SOH","\NUL\SOH\STX","\NUL\SOH\STX\ETX"]
--   </pre>
enumChars :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows by enumerating every
--   <a>Char</a> in the given <a>String</a>. Notice that the <a>String</a>
--   can be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; list 5 $ enumString "xyz"
--   ["","x","xy","xyz"]
--   </pre>
enumString :: String -> Series m Text

-- | A <a>Text</a> <a>Series</a> that grows with English words.
--   
--   This is useful when you want to print <a>Series</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = list 20 jack
--   
--   &gt;&gt;&gt; take 3 s
--   ["","All","All work"]
--   
--   &gt;&gt;&gt; last s
--   "All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy."
--   </pre>
jack :: Series m Text

-- | A <a>Text</a> <a>Series</a> that grows with the first character of
--   each <a>Unicode plane</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 3 enumNonBmp
--   ["","\NUL","\NUL\65536","\NUL\65536\131072"]
--   </pre>
--   
--   Notice that this covers the 16 unicode planes.
--   
--   <pre>
--   &gt;&gt;&gt; last (list 16 enumNonBmp) == last (list 17 enumNonBmp)
--   True
--   </pre>
enumNonBmp :: Series m Text


-- | Following the convention from <a>Data.ByteString.Lazy</a>, this module
--   is intended to be imported <tt>qualified</tt>. For example:
--   
--   <pre>
--   import qualified Test.SmallCheck.Series.ByteString.Lazy as L.Series
--   </pre>
module Test.SmallCheck.Series.ByteString.Lazy

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the
--   <tt>97</tt> <a>Word8</a>, which encodes the <tt>a</tt> <a>Char</a> in
--   <tt>ASCII</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateA
--   ["","a","aa","aaa","aaaa"]
--   </pre>
--   
--   Use this when you don't care about the <a>Word8</a> inside
--   <a>ByteString</a>.
replicateA :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the
--   <tt>0</tt> <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicate0
--   ["","\NUL","\NUL\NUL","\NUL\NUL\NUL","\NUL\NUL\NUL\NUL"]
--   </pre>
replicate0 :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the given
--   <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 $ replicateW8 64
--   ["","@","@@","@@@","@@@@"]
--   </pre>
replicateW8 :: Word8 -> Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating every
--   <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumW8s
--   ["","\NUL","\NUL\SOH","\NUL\SOH\STX","\NUL\SOH\STX\ETX"]
--   </pre>
enumW8s :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating the
--   <a>Word8</a>s which encode the latin alphabet in <tt>ASCII</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumAlphabet
--   ["","a","ab","abc","abcd"]
--   </pre>
enumAlphabet :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating every
--   <a>Word8</a> in the given list.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 . enumList $ fmap (fromIntegral . ord) "abc"
--   ["","a","ab","abc"]
--   </pre>
enumList :: [Word8] -> Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows with <tt>ASCII</tt> dummy
--   English words encoded in <tt>ASCII</tt>.
--   
--   This is useful when you want to print <a>Series</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = list 20 jack
--   
--   &gt;&gt;&gt; take 3 s
--   ["","All","All work"]
--   
--   &gt;&gt;&gt; last s
--   "All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy."
--   </pre>
jack :: Series m ByteString


-- | Following the convention from <a>Data.ByteString</a>, this module is
--   intended to be imported <tt>qualified</tt>. For example:
--   
--   <pre>
--   import qualified Test.SmallCheck.Series.ByteString as B.Series
--   </pre>
module Test.SmallCheck.Series.ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the
--   <tt>97</tt> <a>Word8</a>, which encodes the <tt>a</tt> <a>Char</a> in
--   <tt>ASCII</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicateA
--   ["","a","aa","aaa","aaaa"]
--   </pre>
--   
--   Use this when you don't care about the <a>Word8</a> inside
--   <a>ByteString</a>.
replicateA :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the
--   <tt>0</tt> <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 replicate0
--   ["","\NUL","\NUL\NUL","\NUL\NUL\NUL","\NUL\NUL\NUL\NUL"]
--   </pre>
replicate0 :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by replicating the given
--   <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 $ replicateW8 64
--   ["","@","@@","@@@","@@@@"]
--   </pre>
replicateW8 :: Word8 -> Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating every
--   <a>Word8</a>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumW8s
--   ["","\NUL","\NUL\SOH","\NUL\SOH\STX","\NUL\SOH\STX\ETX"]
--   </pre>
enumW8s :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating the
--   <a>Word8</a>s which encode the latin alphabet in <tt>ASCII</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; list 4 enumAlphabet
--   ["","a","ab","abc","abcd"]
--   </pre>
enumAlphabet :: Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows by enumerating every
--   <a>Word8</a> in the given list.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char (ord)
--   
--   &gt;&gt;&gt; list 4 . enumList $ fmap (fromIntegral . ord) "abc"
--   ["","a","ab","abc"]
--   </pre>
enumList :: [Word8] -> Series m ByteString

-- | A <a>ByteString</a> <a>Series</a> that grows with <tt>ASCII</tt> dummy
--   English words encoded in <tt>ASCII</tt>.
--   
--   This is useful when you want to print <a>Series</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = list 20 jack
--   
--   &gt;&gt;&gt; take 3 s
--   ["","All","All work"]
--   
--   &gt;&gt;&gt; last s
--   "All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy."
--   </pre>
jack :: Series m ByteString


-- | <a>Serial</a> instances are provided for the following types:
--   
--   <ul>
--   <li><a>ByteString</a></li>
--   <li><a>ByteString</a></li>
--   <li><a>Text</a></li>
--   <li><a>Text</a></li>
--   </ul>
--   
--   By default the most economical but less exhaustive series are
--   provided. You may want to create your own instances for your own tests
--   if this setting doesn't apply for your own tests. Check the utilities
--   in the other modules in this package to create custom <a>Series</a>.
--   
--   Make sure the module where you import these instances is not meant to
--   be imported, otherwise the orphan instances might create issues.
module Test.SmallCheck.Series.Instances
instance Monad m => Serial m ByteString
instance Monad m => Serial m ByteString
instance Monad m => Serial m Text
instance Monad m => Serial m Text
instance (Serial m k, Serial m v) => Serial m (Map k v)
