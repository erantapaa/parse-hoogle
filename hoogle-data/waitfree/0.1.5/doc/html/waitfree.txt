-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A wrapping library for waitfree computation.
--   
--   A combinator library for asynchronous waitfree computation among
--   forkIO threads.
@package waitfree
@version 0.1.5

module Control.Concurrent.Waitfree

-- | <a>ZeroT</a> is a <a>Thread</a>
data ZeroT

-- | 'SucT t' is a <a>Thread</a> if t is a <a>Thread</a>. The name
--   <a>SucT</a> comes from the successor function.
data SucT t

-- | <a>HNil</a> is the empty <a>IOerSequent</a>
data HNil

-- | 'HCons (K t e)' adds a remote computation in front of a
--   <a>IOerSequent</a>
data HCons e l

-- | an abreviation for <a>HCons</a>
type :*: e l = HCons e l

-- | A value of type 'K t a' represents a remote computation returning
--   <tt>a</tt> that is performed by a thread <a>t</a>.
data K t a

-- | <a>single</a> creates a IO hypersequent consisting of a single remote
--   computation.
single :: Thread t => (t -> IO a) -> IO (K t a :*: HNil)

-- | An abstract representation of a thread. Threads are actually
--   implemented using <a>forkIO</a>.
class Thread t
t :: Thread t => t
atid :: Thread t => t -> AbstractThreadId

-- | Each <a>Thread</a> type has <a>AbstractThreadId</a>
type AbstractThreadId = Int

-- | ThreadStatus shows whether a thread is finished or have to try
--   executing another job.
data ThreadStatus
TryAnotherJob :: ThreadStatus
Finished :: ThreadStatus

-- | <a>peek</a> allows to look at the result of a remote computation
peek :: Thread t => (t -> JobStatus a -> IO b) -> K t a -> IO b

-- | <a>comm</a> stands for communication. <a>comm</a> combines two
--   hypersequents with a communicating component from each hypersequent. |
--   'comm hypersequent1 error1 hypersequent2 error2' where <tt>error1</tt>
--   and <tt>error2</tt> specifies what to do in case of read failure.
comm :: (Thread s, Thread t, HAppend l l' l'') => IO (HCons (K t (b, a)) l) -> (t -> b -> IO ThreadStatus) -> IO (HCons (K s (d, c)) l') -> (s -> d -> IO ThreadStatus) -> IO (K t (b, c) :*: (K s (d, a) :*: l''))
follows :: HAppend l l' l'' => IO l -> IO l' -> IO l''

-- | <a>execute</a> executes a <a>IO</a> hypersequent.
execute :: Lconvertible l => IO l -> IO ()
choice :: Thread t => K t a :*: (K t a :*: l) -> IO (K t a :*: l)
cycling :: HLast l last heads => IO l -> IO (HCons last heads)
exchange :: K t a :*: (K s b :*: l) -> IO (K s b :*: (K t a :*: l))

-- | extend a IO hypersequent with another computation
(-*-) :: (Thread t, IOerSequent l, IOerSequent l') => (t -> a -> IO b) -> (l -> IO l') -> HCons (K t a) l -> IO (HCons (K t b) l')
instance (Thread t, Lconvertible l) => Lconvertible (HCons (K t ThreadStatus) l)
instance Lconvertible HNil
instance HLast (HCons lh ll) a heads => HLast (HCons b (HCons lh ll)) a (HCons b heads)
instance HLast (HCons a HNil) a HNil
instance (IOerSequent l, HAppend l l' l'') => HAppend (HCons x l) l' (HCons x l'')
instance IOerSequent l => HAppend HNil l l
instance IOerSequent l => IOerSequent (HCons (K t e) l)
instance IOerSequent HNil
instance Thread t => Thread (SucT t)
instance Thread ZeroT
