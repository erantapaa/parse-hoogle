-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sodium Reactive Programming (FRP) System
--   
--   A general purpose Reactive Programming (FRP) system. This is part of a
--   project to implement reactive libraries with similar interfaces across
--   a range of programming languages at
--   <a>http://reactiveprogramming.org/</a>
--   
--   <ul>
--   <li>Goals include simplicity and completeness.</li>
--   <li>Applicative style: Event implements Functor and Behaviour
--   implements Applicative.</li>
--   <li>Instead of the common approach where inputs are fed into the front
--   of a monolithic 'reactimate', Sodium allows you to push inputs in from
--   scattered places in IO.</li>
--   <li>Integration with IO: Extensible to provide lots of scope for
--   lifting IO into FRP logic.</li>
--   <li>Push-based imperative implementation.</li>
--   </ul>
--   
--   See the <i>examples</i> directory for test cases and examples.
--   
--   Changes:
--   
--   <ul>
--   <li>0.2.0.0 - Fix some value recursion deadlocks and improve
--   docs;</li>
--   <li>0.3.0.0 - Add mergeWith, make cross asynchronous;</li>
--   <li>0.4.0.0 - API revamp to remove an excess type variable.
--   Parallelism stuff to be rethought;</li>
--   <li>0.5.0.0 - Improved tests cases + add Freecell example, API
--   tweaks;</li>
--   <li>0.5.0.1 - Internal improvements;</li>
--   <li>0.5.0.2 - Fix multiple memory leaks;</li>
--   <li>0.6 - Minor API changes, particular with accum;</li>
--   <li>0.6.0.1 - ghc-7.8 compatibility;</li>
--   <li>0.6.0.2 - Fix memory leak - see memory-test-8 &amp;
--   memory-test-8a;</li>
--   <li>0.7.0.0 - Add split primitive.</li>
--   <li>0.8.0.0 - Add executeIO primitive.</li>
--   <li>0.9.0.0 - Rename changes to updates. Rename values to value.</li>
--   <li>0.10.0.0 - Add Monoid instance to Event - thanks Finlay
--   Thompson.</li>
--   <li>0.10.0.1 - Fix finalizer issue that caused breakage in ghc-7.8 -
--   thanks Luite Stegeman.</li>
--   <li>0.10.0.2 - Second attempt.</li>
--   <li>0.11.0.0 - Make <a>merge</a> left-biased, like Reactive
--   Banana.</li>
--   <li>0.11.0.1 - Fix regression when using in ghc-7.8: prevent keepAlive
--   from being GC'd early</li>
--   <li>0.11.0.2 - Thank you Samuel GÃ©lineau. Fix breakage in
--   0.11.0.1.</li>
--   </ul>
@package sodium
@version 0.11.0.3


-- | Generalization of the Sodium API to allow for parallel processing.
module FRP.Sodium.Context
class (Applicative (Reactive r), Monad (Reactive r), MonadFix (Reactive r), Functor (Event r), Applicative (Behavior r)) => Context r where data family Reactive r :: * -> * data family Event r :: * -> * data family Behavior r :: * -> *
sync :: Context r => Reactive r a -> IO a
newEvent :: Context r => Reactive r (Event r a, a -> Reactive r ())
listen :: Context r => Event r a -> (a -> IO ()) -> Reactive r (IO ())
never :: Context r => Event r a
merge :: Context r => Event r a -> Event r a -> Event r a
filterJust :: Context r => Event r (Maybe a) -> Event r a
hold :: Context r => a -> Event r a -> Reactive r (Behavior r a)
updates :: Context r => Behavior r a -> Event r a
value :: Context r => Behavior r a -> Event r a
snapshot :: Context r => (a -> b -> c) -> Event r a -> Behavior r b -> Event r c
switchE :: Context r => Behavior r (Event r a) -> Event r a
switch :: Context r => Behavior r (Behavior r a) -> Reactive r (Behavior r a)
execute :: Context r => Event r (Reactive r a) -> Event r a
sample :: Context r => Behavior r a -> Reactive r a
coalesce :: Context r => (a -> a -> a) -> Event r a -> Event r a
once :: Context r => Event r a -> Event r a
split :: Context r => Event r [a] -> Event r a
class Context r => ContextIO r
executeAsyncIO :: ContextIO r => Event r (IO a) -> Event r a
executeSyncIO :: ContextIO r => Event r (IO a) -> Event r a

-- | A time-varying value, British spelling.
type Behaviour r a = Behavior r a

-- | Create a new <a>Behavior</a> along with an action to push changes into
--   it. American spelling.
newBehavior :: Context r => a -> Reactive r (Behavior r a, a -> Reactive r ())

-- | Create a new <a>Behavior</a> along with an action to push changes into
--   it. British spelling.
newBehaviour :: Context r => a -> Reactive r (Behavior r a, a -> Reactive r ())

-- | Merge two streams of events of the same type, combining simultaneous
--   event occurrences.
--   
--   In the case where multiple event occurrences are simultaneous (i.e.
--   all within the same transaction), they are combined using the same
--   logic as <a>coalesce</a>.
mergeWith :: Context r => (a -> a -> a) -> Event r a -> Event r a -> Event r a

-- | Only keep event occurrences for which the predicate returns true.
filterE :: Context r => (a -> Bool) -> Event r a -> Event r a

-- | Let event occurrences through only when the behavior's value is True.
--   Note that the behavior's value is as it was at the start of the
--   transaction, that is, no state changes from the current transaction
--   are taken into account.
gate :: Context r => Event r a -> Behavior r Bool -> Event r a

-- | Transform an event with a generalized state loop (a mealy machine).
--   The function is passed the input and the old state and returns the new
--   state and output value.
collectE :: Context r => (a -> s -> (b, s)) -> s -> Event r a -> Reactive r (Event r b)

-- | Transform a behavior with a generalized state loop (a mealy machine).
--   The function is passed the input and the old state and returns the new
--   state and output value.
collect :: Context r => (a -> s -> (b, s)) -> s -> Behavior r a -> Reactive r (Behavior r b)

-- | Accumulate state changes given in the input event.
accum :: Context r => a -> Event r (a -> a) -> Reactive r (Behavior r a)
instance Context r => Monoid (Event r a)

module FRP.Sodium.Internal

-- | Variant of <a>listen</a> that allows you to initiate more activity in
--   the current transaction. Useful for implementing new primitives.
listenTrans :: Event a -> (a -> Reactive ()) -> Reactive (IO ())

-- | Queue the specified atomic to run at the end of the priority 2 queue
schedulePrioritized :: Maybe (MVar Node) -> Reactive () -> Reactive ()
scheduleLast :: Reactive () -> Reactive ()
data Listen a
Listen :: (Maybe (MVar Node) -> Bool -> (a -> Reactive ()) -> Reactive (IO ())) -> IORef () -> Listen a
runListen_ :: Listen a -> Maybe (MVar Node) -> Bool -> (a -> Reactive ()) -> Reactive (IO ())
listenerKeepAlive :: Listen a -> IORef ()

-- | Unwrap an event's listener machinery.
getListen :: Event a -> Reactive (Listen a)

-- | Listen for firings of this event. The returned <tt>IO ()</tt> is an IO
--   action that unregisters the listener. This is the observer pattern.
linkedListen :: Event a -> Maybe (MVar Node) -> Bool -> (a -> Reactive ()) -> Reactive (IO ())
data Node

-- | Returns an event, and a push action for pushing a value into the
--   event.
newEventLinked :: Dep -> IO (Event a, a -> Reactive (), MVar Node)

-- | Returns an event, and a push action for pushing a value into the
--   event.
newEvent :: Reactive (Event a, a -> Reactive ())

-- | Returns a <a>Listen</a> for registering listeners, and a push action
--   for pushing a value into the event.
newEventImpl :: IO (Listen a, a -> Reactive (), MVar Node)

-- | Add a finalizer to an event.
finalizeEvent :: Event a -> IO () -> Event a

-- | Add a finalizer to a listener.
finalizeListen :: Listen a -> IO () -> IO (Listen a)
ioReactive :: IO a -> Reactive a
data Unlistener

-- | Cause the things listened to with <a>later</a> to be unlistened when
--   the specified listener is not referenced any more.
addCleanup_Listen :: Unlistener -> Listen a -> Reactive (Listen a)
data Sample a
Sample :: IO a -> Dep -> Maybe (IORef ()) -> Sample a
unSample :: Sample a -> IO a
sDep :: Sample a -> Dep
sampleKeepAlive :: Sample a -> Maybe (IORef ())

-- | Cause the things listened to with <a>later</a> to be unlistened when
--   the specified sample is not referenced any more.
addCleanup_Sample :: Unlistener -> Sample a -> IO (Sample a)

-- | Perform a listen later so we can tolerate lazy loops. Returns an
--   <a>Unlistener</a> that can be attached to an event with
--   <a>addCleanup_Listen</a>.
later :: Reactive (IO ()) -> Reactive Unlistener
dep :: a -> Dep
unsafeNewIORef :: a -> b -> IORef a

-- | Phantom type for use with <a>Context</a> type class.
data Plain

module FRP.Sodium.IO

-- | Execute the specified IO operation asynchronously on a separate
--   thread, and signal the output event in a new transaction upon its
--   completion.
--   
--   Caveat: Where <a>switch</a> or <a>switchE</a> is used, when some
--   reactive logic has been switched away, we rely on garbage collection
--   to actually disconnect this logic from any input it may be listening
--   to. With normal Sodium code, everything is pure, so before garbage
--   collection happens, the worst we will get is some wasted CPU cycles.
--   If you are using 'executeAsyncIO'/'executeSyncIO' inside a
--   <a>switch</a> or <a>switchE</a>, however, it is possible that logic
--   that has been switched away hasn't been garbage collected yet. This
--   logic <i>could</i> still run, and if it has observable effects, you
--   could see it running after it is supposed to have been switched out.
--   One way to avoid this is to pipe the source event for IO out of the
--   switch, run the 'executeAsyncIO'/'executeSyncIO' outside the switch,
--   and pipe its output back into the switch contents.
executeAsyncIO :: Event Plain (IO a) -> Event Plain a

-- | Execute the specified IO operation synchronously and fire the output
--   event in the same transaction.
--   
--   Caveat: See <a>executeAsyncIO</a>.
executeSyncIO :: Event Plain (IO a) -> Event Plain a


-- | Sodium Reactive Programming (FRP) system.
--   
--   See the <i>examples</i> directory for test cases and examples.
--   
--   Some functions are pure, and others need to run under the
--   <a>Reactive</a> monad via <a>sync</a>. An <a>Event</a>
--   <i>(</i><a>Reactive</a> <i>a)</i> can be flattened to an <a>Event</a>
--   <i>a</i> using the <a>execute</a> primitive.
--   
--   In addition to the explicit functions in the language, note that you
--   can use
--   
--   <ul>
--   <li>Functor on <a>Event</a> and <a>Behavior</a></li>
--   <li>Applicative on <tt>behaviour</tt>, e.g. <tt>let bsum = (+)
--   &lt;$&gt; ba &lt;*&gt; bb</tt></li>
--   <li>Applicative <a>pure</a> is used to give a constant
--   <a>Behavior</a>.</li>
--   <li>A Monoid instance on <a>Event</a> where <a>mempty</a> =
--   <a>never</a> and <a>mappend</a> = <a>merge</a></li>
--   <li>Recursive do (using the DoRec language extension) to make state
--   loops with the <tt>rec</tt> keyword.</li>
--   <li>Data.Traversable.<a>sequenceA</a> is useful to convert
--   <i>[Behavior a]</i> into <i>Behavior [a]</i>.</li>
--   </ul>
--   
--   Here's an example of recursive do to write state-keeping loops. Note
--   that all <a>hold</a>s are delayed, so <a>snapshot</a> will capture the
--   <i>old</i> value of the state <i>s</i>.
--   
--   <pre>
--   {-# LANGUAGE DoRec #-}
--   -- | Accumulate state changes given in the input event.
--   accum :: Context r =&gt; a -&gt; Event r (a -&gt; a) -&gt; Reactive r (Behavior r a)
--   accum z efa = do
--       rec
--           s &lt;- hold z $ snapshot ($) efa s
--       return s
--   </pre>
module FRP.Sodium

-- | Phantom type for use with <a>Context</a> type class.
data Plain

-- | A monad for transactional reactive operations. Execute it from
--   <a>IO</a> using <a>sync</a>.
type Reactive = Reactive Plain

-- | Execute the specified <a>Reactive</a> within a new transaction,
--   blocking the caller until all resulting processing is complete and all
--   callbacks have been called. This operation is thread-safe, so it may
--   be called from any thread.
--   
--   State changes to <a>hold</a> values occur after processing of the
--   transaction is complete.
sync :: Reactive a -> IO a

-- | Returns an event, and a push action for pushing a value into the
--   event.
newEvent :: Reactive (Event a, a -> Reactive ())

-- | Create a new <a>Behavior</a> along with an action to push changes into
--   it. American spelling.
newBehavior :: a -> Reactive (Behavior a, a -> Reactive ())

-- | Create a new <a>Behavior</a> along with an action to push changes into
--   it. British spelling.
newBehaviour :: a -> Reactive (Behavior a, a -> Reactive ())

-- | Listen for firings of this event. The returned <tt>IO ()</tt> is an IO
--   action that unregisters the listener. This is the observer pattern.
--   
--   To listen to a <a>Behavior</a> use <tt>listen (value b) handler</tt>
--   or <tt>listen (updates b) handler</tt>
--   
--   NOTE: The callback is called with the transaction held, so you cannot
--   use <a>sync</a> inside a listener. You can delegate to another thread
--   and have that start the new transaction. If you want to do more
--   processing in the same transction, then you can use <a>listenTrans</a>
--   but this is discouraged unless you really need to write a new
--   primitive.
listen :: Event a -> (a -> IO ()) -> Reactive (IO ())

-- | A stream of events. The individual firings of events are called 'event
--   occurrences'.
type Event = Event Plain

-- | A time-varying value, American spelling.
type Behavior = Behavior Plain

-- | A time-varying value, British spelling.
type Behaviour = Behavior Plain

-- | An event that never fires.
never :: Event a

-- | Merge two streams of events of the same type.
--   
--   In the case where two event occurrences are simultaneous (i.e. both
--   within the same transaction), both will be delivered in the same
--   transaction. If the event firings are ordered for some reason, then
--   their ordering is retained. In many common cases the ordering will be
--   undefined.
merge :: Event a -> Event a -> Event a

-- | Unwrap Just values, and discard event occurrences with Nothing values.
filterJust :: Event (Maybe a) -> Event a

-- | Create a behavior with the specified initial value, that gets updated
--   by the values coming through the event. The 'current value' of the
--   behavior is notionally the value as it was 'at the start of the
--   transaction'. That is, state updates caused by event firings get
--   processed at the end of the transaction.
hold :: a -> Event a -> Reactive (Behavior a)

-- | An event that gives the updates for the behavior. If the behavior was
--   created with <a>hold</a>, then <a>updates</a> gives you an event like
--   to the one that was held but with only the last firing in any single
--   transaction included.
updates :: Behavior a -> Event a

-- | An event that is guaranteed to fire once when you listen to it, giving
--   the current value of the behavior, and thereafter behaves like
--   <a>updates</a>, firing for each update to the behavior's value.
value :: Behavior a -> Event a

-- | Sample the behavior at the time of the event firing. Note that the
--   'current value' of the behavior that's sampled is the value as at the
--   start of the transaction before any state changes of the current
--   transaction are applied through <a>hold</a>s.
snapshot :: (a -> b -> c) -> Event a -> Behavior b -> Event c

-- | Unwrap an event inside a behavior to give a time-varying event
--   implementation.
switchE :: Behavior (Event a) -> Event a

-- | Unwrap a behavior inside another behavior to give a time-varying
--   behavior implementation.
switch :: Behavior (Behavior a) -> Reactive (Behavior a)

-- | Execute the specified <a>Reactive</a> action inside an event.
execute :: Event (Reactive a) -> Event a

-- | Obtain the current value of a behavior.
sample :: Behavior a -> Reactive a

-- | If there's more than one firing in a single transaction, combine them
--   into one using the specified combining function.
--   
--   If the event firings are ordered, then the first will appear at the
--   left input of the combining function. In most common cases it's best
--   not to make any assumptions about the ordering, and the combining
--   function would ideally be commutative.
coalesce :: (a -> a -> a) -> Event a -> Event a

-- | Throw away all event occurrences except for the first one.
once :: Event a -> Event a

-- | Take each list item and put it into a new transaction of its own.
--   
--   An example use case of this might be a situation where we are
--   splitting a block of input data into frames. We obviously want each
--   frame to have its own transaction so that state is updated separately
--   each frame.
split :: Event [a] -> Event a

-- | Merge two streams of events of the same type, combining simultaneous
--   event occurrences.
--   
--   In the case where multiple event occurrences are simultaneous (i.e.
--   all within the same transaction), they are combined using the supplied
--   function. The output event is guaranteed not to have more than one
--   event occurrence per transaction.
--   
--   The combine function should be commutative, because simultaneous
--   events should be considered to be order-agnostic.
mergeWith :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Only keep event occurrences for which the predicate is true.
filterE :: (a -> Bool) -> Event a -> Event a

-- | Let event occurrences through only when the behavior's value is True.
--   Note that the behavior's value is as it was at the start of the
--   transaction, that is, no state changes from the current transaction
--   are taken into account.
gate :: Event a -> Behavior Bool -> Event a

-- | Transform an event with a generalized state loop (a mealy machine).
--   The function is passed the input and the old state and returns the new
--   state and output value.
collectE :: (a -> s -> (b, s)) -> s -> Event a -> Reactive (Event b)

-- | Transform a behavior with a generalized state loop (a mealy machine).
--   The function is passed the input and the old state and returns the new
--   state and output value.
collect :: (a -> s -> (b, s)) -> s -> Behavior a -> Reactive (Behavior b)

-- | Accumulate state changes given in the input event.
accum :: a -> Event (a -> a) -> Reactive (Behavior a)

-- | An event that gives the updates for the behavior. If the behavior was
--   created with <a>hold</a>, then <a>changes</a> gives you an event
--   equivalent to the one that was held.

-- | <i>Deprecated: renamed to <a>updates</a></i>
changes :: Behavior a -> Event a

-- | An event that is guaranteed to fire once when you listen to it, giving
--   the current value of the behavior, and thereafter behaves like
--   <a>changes</a>, firing for each update to the behavior's value.

-- | <i>Deprecated: renamed to <a>value</a></i>
values :: Behavior a -> Event a

-- | Sample the behavior at the time of the event firing. Note that the
--   'current value' of the behavior that's sampled is the value as at the
--   start of the transaction before any state changes of the current
--   transaction are applied through <a>hold</a>s.

-- | <i>Deprecated: renamed to <a>snapshot</a></i>
snapshotWith :: (a -> b -> c) -> Event a -> Behavior b -> Event c

-- | Count event occurrences, giving a behavior that starts with 0 before
--   the first occurrence.

-- | <i>Deprecated: removing it in the pursuit of minimalism, replace with:
--   accum 0 (const (1+) <a>$</a> e)</i>
count :: Event a -> Reactive (Behavior Int)
