-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | String class library
--   
@package string-class
@version 0.1.6.4

module Data.String.Class

-- | String super class
class (StringCells s, StringRWIO s) => Stringy s

-- | Minimal complete definition: StringCellChar; StringCellAltChar;
--   toStringCells; fromStringCells; toMainChar; toAltChar; cons; snoc;
--   either all of head, tail, last, and init, or all of uncons and unsnoc;
--   take, take64 or genericTake; drop, drop64, or genericDrop; and length,
--   length64, or genericLength
class (Eq s, Monoid s, IsString s, Typeable s, StringCell (StringCellChar s), StringCell (StringCellAltChar s), ConvGenString s, ConvString s, ConvStrictByteString s, ConvLazyByteString s, ConvText s, ConvLazyText s) => StringCells s where type family StringCellChar s type family StringCellAltChar s unfoldr f b = case f b of { (Just (a, new_b)) -> a `cons` unfoldr f new_b (Nothing) -> empty } altUnfoldr f b = case f b of { (Just (a, new_b)) -> a `altCons` altUnfoldr f new_b (Nothing) -> empty } unfoldrN = const unfoldr altUnfoldrN = const altUnfoldr unfoldrN64 l f z = unfoldrN (fromIntegral l) f z altUnfoldrN64 l f z = altUnfoldrN (fromIntegral l) f z altCons c s = cons (s `untagTypeOf` toMainChar c) s altSnoc s c = snoc s (s `untagTypeOf` toMainChar c) altUncons s = (\ ~(a, s') -> (s `untagTypeOf` toAltChar a, s')) $ uncons s altUnsnoc s = (\ ~(s', a) -> (s', s `untagTypeOf` toAltChar a)) $ unsnoc s append = mappend concat = mconcat empty = mempty null = (== mempty) head = fst . uncons tail = snd . uncons last = snd . unsnoc init = fst . unsnoc altHead s = (s `untagTypeOf`) . toAltChar . head $ s altLast s = (s `untagTypeOf`) . toAltChar . last $ s index s 0 = head s index s n = (flip index $ pred n) . tail $ s index64 s 0 = head s index64 s n = (flip index64 $ pred n) . tail $ s genericIndex s 0 = head s genericIndex s n = (flip genericIndex $ pred n) . tail $ s take n s = take64 (fromIntegral n) s take64 n s = genericTake (fromIntegral n :: Integer) s genericTake n s = take (fromIntegral n) s drop n s = drop64 (fromIntegral n) s drop64 n s = genericDrop (fromIntegral n :: Integer) s genericDrop n s = drop (fromIntegral n) s length = fromIntegral . length64 length64 = (fromIntegral :: Integer -> Int64) . genericLength genericLength = fromIntegral . length uncons s = (head s, tail s) unsnoc s = (init s, last s) cons2 a b s = a `cons` b `cons` s cons3 a b c s = a `cons` b `cons` c `cons` s cons4 a b c d s = a `cons` b `cons` c `cons` d `cons` s uncons2 s = let (a, s') = uncons s (b, s'') = uncons s' in (a, b, s'') uncons3 s = let (a, s') = uncons s (b, s'') = uncons s' (c, s''') = uncons s'' in (a, b, c, s''') uncons4 s = let (a, s') = uncons s (b, s'') = uncons s' (c, s''') = uncons s'' (d, s'''') = uncons s''' in (a, b, c, d, s'''') safeUncons s | null s = Nothing | otherwise = Just $ uncons s safeUnsnoc s | null s = Nothing | otherwise = Just $ unsnoc s safeAltUncons s | null s = Nothing | otherwise = Just $ altUncons s safeAltUnsnoc s | null s = Nothing | otherwise = Just $ altUnsnoc s safeHead s | null s = Nothing | otherwise = Just $ head s safeTail s | null s = Nothing | otherwise = Just $ tail s safeLast s | null s = Nothing | otherwise = Just $ last s safeInit s | null s = Nothing | otherwise = Just $ init s safeAltHead s | null s = Nothing | otherwise = Just $ altHead s safeAltLast s | null s = Nothing | otherwise = Just $ altLast s safeIndex s n | length s <= n = Nothing | otherwise = Just $ s `index` n safeIndex64 s n | length64 s <= n = Nothing | otherwise = Just $ s `index64` n safeGenericIndex s n | genericLength s <= n = Nothing | otherwise = Just $ s `genericIndex` n safeTake n s | n > length s = Nothing | otherwise = Just $ take n s safeTake64 n s | n > length64 s = Nothing | otherwise = Just $ take64 n s safeGenericTake n s | n > genericLength s = Nothing | otherwise = Just $ genericTake n s safeDrop n s | n > length s = Nothing | otherwise = Just $ drop n s safeDrop64 n s | n > length64 s = Nothing | otherwise = Just $ drop64 n s safeGenericDrop n s | n > genericLength s = Nothing | otherwise = Just $ genericDrop n s safeUncons2 s = do { (a, s') <- safeUncons s; (b, s'') <- safeUncons s'; return (a, b, s'') } safeUncons3 s = do { (a, s') <- safeUncons s; (b, s'') <- safeUncons s'; (c, s''') <- safeUncons s''; return (a, b, c, s''') } safeUncons4 s = do { (a, s') <- safeUncons s; (b, s'') <- safeUncons s'; (c, s''') <- safeUncons s''; (d, s'''') <- safeUncons s'''; return (a, b, c, d, s'''') }
toStringCells :: (StringCells s, StringCells s2) => s -> s2
fromStringCells :: (StringCells s, StringCells s2) => s2 -> s
cons :: StringCells s => StringCellChar s -> s -> s
uncons :: StringCells s => s -> (StringCellChar s, s)
snoc :: StringCells s => s -> StringCellChar s -> s
unsnoc :: StringCells s => s -> (s, StringCellChar s)
altCons :: StringCells s => StringCellAltChar s -> s -> s
altUncons :: StringCells s => s -> (StringCellAltChar s, s)
altSnoc :: StringCells s => s -> StringCellAltChar s -> s
altUnsnoc :: StringCells s => s -> (s, StringCellAltChar s)
toMainChar :: (StringCells s, StringCell c) => c -> Tagged s (StringCellChar s)
toAltChar :: (StringCells s, StringCell c) => c -> Tagged s (StringCellAltChar s)
append :: StringCells s => s -> s -> s
concat :: StringCells s => [s] -> s
empty :: StringCells s => s
null :: StringCells s => s -> Bool
head :: StringCells s => s -> StringCellChar s
tail :: StringCells s => s -> s
last :: StringCells s => s -> StringCellChar s
init :: StringCells s => s -> s
altHead :: StringCells s => s -> StringCellAltChar s
altLast :: StringCells s => s -> StringCellAltChar s
unfoldr :: StringCells s => (a -> Maybe (StringCellChar s, a)) -> a -> s
altUnfoldr :: StringCells s => (a -> Maybe (StringCellAltChar s, a)) -> a -> s
unfoldrN :: StringCells s => Int -> (a -> Maybe (StringCellChar s, a)) -> a -> s
altUnfoldrN :: StringCells s => Int -> (a -> Maybe (StringCellAltChar s, a)) -> a -> s
unfoldrN64 :: StringCells s => Int64 -> (a -> Maybe (StringCellChar s, a)) -> a -> s
altUnfoldrN64 :: StringCells s => Int64 -> (a -> Maybe (StringCellAltChar s, a)) -> a -> s
index :: StringCells s => s -> Int -> StringCellChar s
index64 :: StringCells s => s -> Int64 -> StringCellChar s
genericIndex :: (StringCells s, Integral i) => s -> i -> StringCellChar s
take :: StringCells s => Int -> s -> s
take64 :: StringCells s => Int64 -> s -> s
genericTake :: (StringCells s, Integral i) => i -> s -> s
drop :: StringCells s => Int -> s -> s
drop64 :: StringCells s => Int64 -> s -> s
genericDrop :: (StringCells s, Integral i) => i -> s -> s
length :: StringCells s => s -> Int
length64 :: StringCells s => s -> Int64
genericLength :: (StringCells s, Integral i) => s -> i
safeUncons :: StringCells s => s -> Maybe (StringCellChar s, s)
safeUnsnoc :: StringCells s => s -> Maybe (s, StringCellChar s)
safeAltUncons :: StringCells s => s -> Maybe (StringCellAltChar s, s)
safeAltUnsnoc :: StringCells s => s -> Maybe (s, StringCellAltChar s)
safeHead :: StringCells s => s -> Maybe (StringCellChar s)
safeTail :: StringCells s => s -> Maybe s
safeLast :: StringCells s => s -> Maybe (StringCellChar s)
safeInit :: StringCells s => s -> Maybe s
safeAltHead :: StringCells s => s -> Maybe (StringCellAltChar s)
safeAltLast :: StringCells s => s -> Maybe (StringCellAltChar s)
safeIndex :: StringCells s => s -> Int -> Maybe (StringCellChar s)
safeIndex64 :: StringCells s => s -> Int64 -> Maybe (StringCellChar s)
safeGenericIndex :: (StringCells s, Integral i) => s -> i -> Maybe (StringCellChar s)
safeTake :: StringCells s => Int -> s -> Maybe s
safeTake64 :: StringCells s => Int64 -> s -> Maybe s
safeGenericTake :: (StringCells s, Integral i) => i -> s -> Maybe s
safeDrop :: StringCells s => Int -> s -> Maybe s
safeDrop64 :: StringCells s => Int64 -> s -> Maybe s
safeGenericDrop :: (StringCells s, Integral i) => i -> s -> Maybe s
safeUncons2 :: StringCells s => s -> Maybe (StringCellChar s, StringCellChar s, s)
safeUncons3 :: StringCells s => s -> Maybe (StringCellChar s, StringCellChar s, StringCellChar s, s)
safeUncons4 :: StringCells s => s -> Maybe (StringCellChar s, StringCellChar s, StringCellChar s, StringCellChar s, s)
cons2 :: StringCells s => StringCellChar s -> StringCellChar s -> s -> s
cons3 :: StringCells s => StringCellChar s -> StringCellChar s -> StringCellChar s -> s -> s
cons4 :: StringCells s => StringCellChar s -> StringCellChar s -> StringCellChar s -> StringCellChar s -> s -> s
uncons2 :: StringCells s => s -> (StringCellChar s, StringCellChar s, s)
uncons3 :: StringCells s => s -> (StringCellChar s, StringCellChar s, StringCellChar s, s)
uncons4 :: StringCells s => s -> (StringCellChar s, StringCellChar s, StringCellChar s, StringCellChar s, s)
class StringCell c
toChar :: StringCell c => c -> Char
toWord8 :: StringCell c => c -> Word8
toWord16 :: StringCell c => c -> Word16
toWord32 :: StringCell c => c -> Word32
toWord64 :: StringCell c => c -> Word64
fromChar :: StringCell c => Char -> c
fromWord8 :: StringCell c => Word8 -> c
fromWord16 :: StringCell c => Word16 -> c
fromWord32 :: StringCell c => Word32 -> c
fromWord64 :: StringCell c => Word64 -> c

-- | Minimal complete definition: <a>hGetContents</a>, <a>hGetLine</a>,
--   <a>hPutStr</a>, and <a>hPutStrLn</a>
class StringRWIO s where interact f = putStr . f =<< getContents getContents = hGetContents stdin getLine = hGetLine stdin putStr = hPutStr stdout putStrLn = hPutStrLn stdout readFile fn = hGetContents =<< openFile fn ReadMode writeFile fn s = withFile fn WriteMode $ \ hdl -> hPutStr hdl s appendFile fn s = withFile fn AppendMode $ \ hdl -> hPutStr hdl s
hGetContents :: StringRWIO s => Handle -> IO s
hGetLine :: StringRWIO s => Handle -> IO s
hPutStr :: StringRWIO s => Handle -> s -> IO ()
hPutStrLn :: StringRWIO s => Handle -> s -> IO ()
interact :: StringRWIO s => (s -> s) -> IO ()
getContents :: StringRWIO s => IO s
getLine :: StringRWIO s => IO s
putStr :: StringRWIO s => s -> IO ()
putStrLn :: StringRWIO s => s -> IO ()
readFile :: StringRWIO s => FilePath -> IO s
writeFile :: StringRWIO s => FilePath -> s -> IO ()
appendFile :: StringRWIO s => FilePath -> s -> IO ()
class ConvGenString s
toGenString :: ConvGenString s => s -> GenString
fromGenString :: ConvGenString s => GenString -> s
class ConvString s
toString :: ConvString s => s -> String
fromString :: ConvString s => String -> s
class ConvStrictByteString s
toStrictByteString :: ConvStrictByteString s => s -> ByteString
fromStrictByteString :: ConvStrictByteString s => ByteString -> s
class ConvLazyByteString s
toLazyByteString :: ConvLazyByteString s => s -> ByteString
fromLazyByteString :: ConvLazyByteString s => ByteString -> s
class ConvText s
toText :: ConvText s => s -> Text
fromText :: ConvText s => Text -> s

-- | Polymorphic container of a string
--   
--   When operations take place on multiple <a>GenString</a>s, they are
--   first converted to the type <a>GenStringDefault</a>, which are lazy
--   bytestrings, whenever absolutely necessary (which includes testing for
--   equality, appending strings, concatenating lists of strings, empty
--   strings with <a>empty</a>, and unfolding), making them the most
--   efficient type for this polymorphic container.
data GenString
GenString :: s -> GenString
gen_string :: GenString -> s

-- | This type is used by <a>GenString</a> when a concrete string type is
--   needed
type GenStringDefault = ByteString
instance Typeable GenString
instance StringCells GenString
instance Monoid GenString
instance IsString GenString
instance Eq GenString
instance StringRWIO Text
instance StringRWIO Text
instance StringRWIO ByteString
instance StringRWIO ByteString
instance StringRWIO String
instance StringRWIO GenString
instance ConvLazyText Text
instance ConvLazyText Text
instance ConvLazyText ByteString
instance ConvLazyText ByteString
instance ConvLazyText String
instance ConvLazyText GenString
instance ConvText Text
instance ConvText Text
instance ConvText ByteString
instance ConvText ByteString
instance ConvText String
instance ConvText GenString
instance ConvLazyByteString Text
instance ConvLazyByteString Text
instance ConvLazyByteString ByteString
instance ConvLazyByteString ByteString
instance ConvLazyByteString String
instance ConvLazyByteString GenString
instance ConvStrictByteString Text
instance ConvStrictByteString Text
instance ConvStrictByteString ByteString
instance ConvStrictByteString ByteString
instance ConvStrictByteString String
instance ConvStrictByteString GenString
instance ConvString Text
instance ConvString Text
instance ConvString ByteString
instance ConvString ByteString
instance ConvString String
instance ConvString GenString
instance ConvGenString Text
instance ConvGenString Text
instance ConvGenString ByteString
instance ConvGenString ByteString
instance ConvGenString String
instance ConvGenString GenString
instance StringCell Word64
instance StringCell Word32
instance StringCell Word16
instance StringCell Word8
instance StringCell Char
instance StringCells Text
instance StringCells Text
instance StringCells ByteString
instance StringCells ByteString
instance StringCells String
instance (StringCells s, StringRWIO s) => Stringy s
