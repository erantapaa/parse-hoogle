-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Faster Haskell lists using stream fusion
--   
--   This package provides the standard Haskell list library reimplemented
--   to allow stream fusion. This should in general provide faster list
--   operations, and faster code for list-heavy programs. See the paper
--   <i>Stream Fusion: From Lists to Streams to Nothing at All</i>, Coutts,
--   Leshchinskiy and Stewart, 2007. To use, simply import Data.List.Stream
--   in place of Data.List, and hide list functions from the Prelude.
@package stream-fusion
@version 0.1.2.5


-- | Tested with : GHC 6.6
--   
--   Stream fusion for sequences. Described in:
--   
--   <ul>
--   <li><i>Stream Fusion: From Lists to Streams to Nothing at All</i>, by
--   Duncan Coutts, Roman Leshchinskiy and Don Stwwart, ICFP 2007.
--   <a>http://www.cse.unsw.edu.au/~dons/papers/CLS07.html</a></li>
--   <li><i>Rewriting Haskell Strings</i>, by Duncan Coutts, Don Stewart
--   and Roman Leshchinskiy, Practical Aspects of Declarative Languages 8th
--   International Symposium, PADL 2007, 2007.
--   <a>http://www.cse.unsw.edu.au/~dons/papers/CSL06.html</a></li>
--   </ul>
--   
--   See the source for the complete story:
--   
--   <ul>
--   
--   <li><a>http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/Stream.hs</a></li>
--   </ul>
module Data.Stream

-- | A stream.
--   
--   It is important that we never construct a bottom stream, because the
--   fusion rule is not true for bottom streams.
--   
--   <pre>
--   (replicate 1 True) ++ (tail undefined)
--   </pre>
--   
--   The suspicion is that under fusion the append will force the bottom.
data Stream a
Stream :: !(s -> Step a s) -> !s -> Stream a

-- | A stream step.
--   
--   A step either ends a stream, skips a value, or yields a value
data Step a s
Yield :: a -> !s -> Step a s
Skip :: !s -> Step a s
Done :: Step a s

-- | Construct an abstract stream from a list.
stream :: [a] -> Stream a

-- | Flatten a stream back into a list.
unstream :: Stream a -> [a]

-- | Boxes for user's state. This is the gateway for user's types into
--   unlifted stream states. The L is always safe since it's lifted<i>lazy,
--   exposing</i>seqing it does nothing. S is unlifted and so is only
--   suitable for users states that we know we can be strict in. This
--   requires attention and auditing.
data L a
L :: a -> L a
append :: Stream a -> Stream a -> Stream a
append1 :: Stream a -> [a] -> [a]
cons :: a -> Stream a -> Stream a
snoc :: Stream a -> a -> Stream a
head :: Stream a -> a
last :: Stream a -> a
tail :: Stream a -> Stream a
init :: Stream a -> Stream a
null :: Stream a -> Bool
length :: Stream a -> Int
map :: (a -> b) -> Stream a -> Stream b
intersperse :: a -> Stream a -> Stream a
foldl :: (b -> a -> b) -> b -> Stream a -> b
foldl' :: (b -> a -> b) -> b -> Stream a -> b
foldl1 :: (a -> a -> a) -> Stream a -> a
foldl1' :: (a -> a -> a) -> Stream a -> a
foldr :: (a -> b -> b) -> b -> Stream a -> b
foldr1 :: (a -> a -> a) -> Stream a -> a
concat :: Stream [a] -> [a]
concatMap :: (a -> Stream b) -> Stream a -> Stream b
and :: Stream Bool -> Bool
or :: Stream Bool -> Bool
any :: (a -> Bool) -> Stream a -> Bool
all :: (a -> Bool) -> Stream a -> Bool
sum :: Num a => Stream a -> a
product :: Num a => Stream a -> a
maximum :: Ord a => Stream a -> a
minimum :: Ord a => Stream a -> a
strictMaximum :: Ord a => Stream a -> a
strictMinimum :: Ord a => Stream a -> a
scanl :: (b -> a -> b) -> b -> Stream a -> Stream b
scanl1 :: (a -> a -> a) -> Stream a -> Stream a
iterate :: (a -> a) -> a -> Stream a
repeat :: a -> Stream a
replicate :: Int -> a -> Stream a
cycle :: Stream a -> Stream a
unfoldr :: (b -> Maybe (a, b)) -> b -> Stream a
take :: Int -> Stream a -> Stream a
drop :: Int -> Stream a -> Stream a
splitAt :: Int -> Stream a -> ([a], [a])
takeWhile :: (a -> Bool) -> Stream a -> Stream a
dropWhile :: (a -> Bool) -> Stream a -> Stream a
isPrefixOf :: Eq a => Stream a -> Stream a -> Bool
elem :: Eq a => a -> Stream a -> Bool
lookup :: Eq a => a -> Stream (a, b) -> Maybe b
find :: (a -> Bool) -> Stream a -> Maybe a
filter :: (a -> Bool) -> Stream a -> Stream a
index :: Stream a -> Int -> a
findIndex :: (a -> Bool) -> Stream a -> Maybe Int
elemIndex :: Eq a => a -> Stream a -> Maybe Int
elemIndices :: Eq a => a -> Stream a -> Stream Int
findIndices :: (a -> Bool) -> Stream a -> Stream Int
zip :: Stream a -> Stream b -> Stream (a, b)
zip3 :: Stream a -> Stream b -> Stream c -> Stream (a, b, c)
zip4 :: Stream a -> Stream b -> Stream c -> Stream d -> Stream (a, b, c, d)
zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c
zipWith3 :: (a -> b -> c -> d) -> Stream a -> Stream b -> Stream c -> Stream d
zipWith4 :: (a -> b -> c -> d -> e) -> Stream a -> Stream b -> Stream c -> Stream d -> Stream e
unzip :: Stream (a, b) -> ([a], [b])
insertBy :: (a -> a -> Ordering) -> a -> Stream a -> Stream a
maximumBy :: (a -> a -> Ordering) -> Stream a -> a
minimumBy :: (a -> a -> Ordering) -> Stream a -> a
genericLength :: Num i => Stream b -> i
genericTake :: Integral i => i -> Stream a -> Stream a
genericDrop :: Integral i => i -> Stream a -> Stream a
genericIndex :: Integral a => Stream b -> a -> b
genericSplitAt :: Integral i => i -> Stream a -> ([a], [a])
enumFromToInt :: Int -> Int -> Stream Int
enumFromToChar :: Char -> Char -> Stream Char
enumDeltaInteger :: Integer -> Integer -> Stream Integer
foldM :: Monad m => (b -> a -> m b) -> b -> Stream a -> m b
foldM_ :: Monad m => (b -> a -> m b) -> b -> Stream a -> m ()
return :: a -> Stream a
guard :: Bool -> Stream a -> Stream a
bind :: (a -> Bool) -> (a -> Stream b) -> Stream a -> Stream b
mapFilter :: (a -> Bool) -> (a -> b) -> Stream a -> Stream b
declare :: (a -> Stream b) -> a -> Stream b
instance Unlifted (S a)
instance Unlifted (L a)
instance Unlifted (Stream a)
instance (Unlifted a, Unlifted b) => Unlifted (Either a b)
instance Unlifted a => Unlifted (Maybe a)
instance (Unlifted a, Unlifted b) => Unlifted (a :!: b)
instance Unlifted Switch
instance Unlifted None
instance Functor Stream


-- | A reimplementation of the standard Haskell list library to take
--   advantage of stream fusion, and new GHC optimisations. The fusion
--   mechanism is based on stream fusion for sequences. Described in:
--   
--   <ul>
--   <li><i>Stream Fusion: From Lists to Streams to Nothing at All</i>, by
--   Duncan Coutts, Roman Leshchinskiy and Don Stwwart, ICFP 2007.
--   <a>http://www.cse.unsw.edu.au/~dons/papers/CLS07.html</a></li>
--   <li><i>Rewriting Haskell Strings</i>, by Duncan Coutts, Don Stewart
--   and Roman Leshchinskiy, Practical Aspects of Declarative Languages 8th
--   International Symposium, PADL 2007, 2007.
--   <a>http://www.cse.unsw.edu.au/~dons/papers/CSL06.html</a></li>
--   </ul>
--   
--   See the source for the complete story:
--   
--   <ul>
--   
--   <li><a>http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/Stream.hs</a></li>
--   </ul>
--   
--   This library is a drop in replacement for <a>Data.List</a>.
module Data.List.Stream

-- | <i>O(n)</i>, <i>fusion</i>. Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list. The
--   spine of the first list argument must be copied.
(++) :: [a] -> [a] -> [a]

-- | <i>O(1)</i>, <i>fusion</i>. Extract the first element of a list, which
--   must be non-empty.
head :: [a] -> a

-- | <i>O(n)</i>, <i>fusion</i>. Extract the last element of a list, which
--   must be finite and non-empty.
last :: [a] -> a

-- | <i>O(1)</i>, <i>fusion</i>. Extract the elements after the head of a
--   list, which must be non-empty.
tail :: [a] -> [a]

-- | <i>O(n)</i>, <i>fusion</i>. Return all the elements of a list except
--   the last one. The list must be finite and non-empty.
init :: [a] -> [a]

-- | <i>O(1)</i>, <i>fusion</i>. Test whether a list is empty.
null :: [a] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. <a>length</a> returns the length of a
--   finite list as an <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
length :: [a] -> Int

-- | <i>O(n)</i>, <i>fusion</i>. <a>map</a> <tt>f xs</tt> is the list
--   obtained by applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   map f . map g         = map (f . g)
--   map f (repeat x)      = repeat (f x)
--   map f (replicate n x) = replicate n (f x)
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <i>O(n)</i>, <i>fusion</i>. <a>reverse</a> <tt>xs</tt> returns the
--   elements of <tt>xs</tt> in reverse order. <tt>xs</tt> must be finite.
--   Will fuse as a consumer only.
reverse :: [a] -> [a]

-- | <i>O(n)</i>, <i>fusion</i>. The <a>intersperse</a> function takes an
--   element and a list and `intersperses' that element between the
--   elements of the list. For example,
--   
--   <pre>
--   intersperse ',' "abcde" == "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <i>O(n)</i>, <i>fusion</i>. <a>intercalate</a> <tt>xs xss</tt> is
--   equivalent to <tt>(<a>concat</a> (<a>intersperse</a> xs xss))</tt>. It
--   inserts the list <tt>xs</tt> in between the lists in <tt>xss</tt> and
--   concatenates the result.
--   
--   <pre>
--   intercalate = concat . intersperse
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | <i>O(n)</i>, <i>fusion</i>. <a>foldl</a>, applied to a binary
--   operator, a starting value (typically the left-identity of the
--   operator), and a list, reduces the list using the binary operator,
--   from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
foldl :: (a -> b -> a) -> a -> [b] -> a

-- | <i>O(n)</i>, <i>fusion</i>. A strict version of <a>foldl</a>.
foldl' :: (a -> b -> a) -> a -> [b] -> a

-- | <i>O(n)</i>, <i>fusion</i>. <a>foldl1</a> is a variant of <a>foldl</a>
--   that has no starting value argument, and thus must be applied to
--   non-empty lists.
foldl1 :: (a -> a -> a) -> [a] -> a

-- | <i>O(n)</i>, <i>fusion</i>. A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <i>O(n)</i>, <i>fusion</i>. <a>foldr</a>, applied to a binary
--   operator, a starting value (typically the right-identity of the
--   operator), and a list, reduces the list using the binary operator,
--   from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <i>O(n)</i>, <i>fusion</i>. <a>foldr1</a> is a variant of <a>foldr</a>
--   that has no starting value argument, and thus must be applied to
--   non-empty lists.
foldr1 :: (a -> a -> a) -> [a] -> a

-- | <i>O(n)</i>, <i>fusion</i>. Concatenate a list of lists.
concat :: [[a]] -> [a]

-- | <i>O(n)</i>, <i>fusion</i>. Map a function over a list and concatenate
--   the results.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <i>O(n)</i>, <i>fusion</i>. <a>and</a> returns the conjunction of a
--   Boolean list. For the result to be <a>True</a>, the list must be
--   finite; <a>False</a>, however, results from a <a>False</a> value at a
--   finite index of a finite or infinite list.
and :: [Bool] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. <a>or</a> returns the disjunction of a
--   Boolean list. For the result to be <a>False</a>, the list must be
--   finite; <a>True</a>, however, results from a <a>True</a> value at a
--   finite index of a finite or infinite list.
or :: [Bool] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. Applied to a predicate and a list,
--   <a>any</a> determines if any element of the list satisfies the
--   predicate.
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate.
all :: (a -> Bool) -> [a] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. The <a>sum</a> function computes the sum
--   of a finite list of numbers.
sum :: Num a => [a] -> a

-- | <i>O(n)</i>,<i>fusion</i>. The <a>product</a> function computes the
--   product of a finite list of numbers.
product :: Num a => [a] -> a

-- | <i>O(n)</i>,<i>fusion</i>. <a>maximum</a> returns the maximum value
--   from a list, which must be non-empty, finite, and of an ordered type.
--   It is a special case of <a>maximumBy</a>, which allows the programmer
--   to supply their own comparison function.
maximum :: Ord a => [a] -> a

-- | <i>O(n)</i>,<i>fusion</i>. <a>minimum</a> returns the minimum value
--   from a list, which must be non-empty, finite, and of an ordered type.
--   It is a special case of <a>minimumBy</a>, which allows the programmer
--   to supply their own comparison function.
minimum :: Ord a => [a] -> a

-- | <i>O(n)</i>, <i>fusion</i>. <a>scanl</a> is similar to <a>foldl</a>,
--   but returns a list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   last (scanl f z xs) == foldl f z x
--   </pre>
scanl :: (a -> b -> a) -> a -> [b] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. <a>scanl1</a> is a variant of <a>scanl</a>
--   that has no starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Properties:
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | <i>fusion</i>. <a>iterate</a> <tt>f x</tt> returns an infinite list of
--   repeated applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <i>fusion</i>. <a>repeat</a> <tt>x</tt> is an infinite list, with
--   <tt>x</tt> the value of every element.
repeat :: a -> [a]

-- | <i>O(n)</i>, <i>fusion</i>. <a>replicate</a> <tt>n x</tt> is a list of
--   length <tt>n</tt> with <tt>x</tt> the value of every element. It is an
--   instance of the more general <a>genericReplicate</a>, in which
--   <tt>n</tt> may be of any integral type.
replicate :: Int -> a -> [a]

-- | <i>fusion</i>. <a>cycle</a> ties a finite list into a circular one, or
--   equivalently, the infinite repetition of the original list. It is the
--   identity on infinite lists.
cycle :: [a] -> [a]

-- | <i>fusion</i>. The <a>unfoldr</a> function is a `dual' to
--   <a>foldr</a>: while <a>foldr</a> reduces a list to a summary value,
--   <a>unfoldr</a> builds a list from a seed value. The function takes the
--   element and returns <a>Nothing</a> if it is done producing the list or
--   returns <a>Just</a> <tt>(a,b)</tt>, in which case, <tt>a</tt> is a
--   prepended to the list and <tt>b</tt> is used as the next element in a
--   recursive call. For example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--    [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. <a>take</a> <tt>n</tt>, applied to a list
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. <a>drop</a> <tt>n xs</tt> returns the
--   suffix of <tt>xs</tt> after the first <tt>n</tt> elements, or
--   <tt>[]</tt> if <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <i>O(n)</i>,<i>fusion</i>. <a>takeWhile</a>, applied to a predicate
--   <tt>p</tt> and a list <tt>xs</tt>, returns the longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. <a>dropWhile</a> <tt>p xs</tt> returns the
--   suffix remaining after <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   inits "abc" == ["","a","ab","abc"]
--   </pre>
inits :: [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   tails "abc" == ["abc", "bc", "c",""]
--   </pre>
tails :: [a] -> [[a]]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>isPrefixOf</a> function takes two
--   lists and returns <a>True</a> iff the first list is a prefix of the
--   second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. Both lists must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." -&gt; True
--   isInfixOf "Ial" "I really like Haskell." -&gt; False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. <a>elem</a> is the list membership
--   predicate, usually written in infix form, e.g., <tt>x <a>elem</a>
--   xs</tt>.
elem :: Eq a => a -> [a] -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. <a>notElem</a> is the negation of
--   <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool

-- | <i>O(n)</i>,<i>fusion</i>. <a>lookup</a> <tt>key assocs</tt> looks up
--   a key in an association list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <i>O(n)</i>,<i>fusion</i>. The <a>find</a> function takes a predicate
--   and a list and returns the first element in the list matching the
--   predicate, or <a>Nothing</a> if there is no such element.
find :: (a -> Bool) -> [a] -> Maybe a

-- | <i>O(n)</i>,<i>fusion</i>. <a>filter</a>, applied to a predicate and a
--   list, returns the list of those elements that satisfy the predicate;
--   i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   filter p (filter q s) = filter (\x -&gt; q x &amp;&amp; p x) s
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | <i>O(n)</i>,<i>fusion</i>. List index (subscript) operator, starting
--   from 0. It is an instance of the more general <a>genericIndex</a>,
--   which takes an index of any integral type.
(!!) :: [a] -> Int -> a

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   Properties:
--   
--   <pre>
--   elemIndex x xs = listToMaybe [ n | (n,a) &lt;- zip [0..] xs, a == x ]
--   elemIndex x xs = findIndex (x==) xs
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | <i>O(n)</i>,<i>fusion</i>. The <a>elemIndices</a> function extends
--   <a>elemIndex</a>, by returning the indices of all elements equal to
--   the query element, in ascending order.
--   
--   Properties:
--   
--   <pre>
--   length (filter (==a) xs) = length (elemIndices a xs)
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   Properties:
--   
--   <pre>
--   findIndex p xs = listToMaybe [ n | (n,x) &lt;- zip [0..] xs, p x ]
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | <i>O(n)</i>,<i>fusion</i>. The <a>findIndices</a> function extends
--   <a>findIndex</a>, by returning the indices of all elements satisfying
--   the predicate, in ascending order.
--   
--   Properties:
--   
--   <pre>
--   length (filter p xs) = length (findIndices p xs)
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | <i>O(n)</i>,<i>fusion</i>. <a>zip</a> takes two lists and returns a
--   list of corresponding pairs. If one input list is short, excess
--   elements of the longer list are discarded.
--   
--   Properties:
--   
--   <pre>
--   zip a b = zipWith (,) a b
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <i>O(n)</i>,<i>fusion</i>. <a>zip3</a> takes three lists and returns a
--   list of triples, analogous to <a>zip</a>.
--   
--   Properties:
--   
--   <pre>
--   zip3 a b c = zipWith (,,) a b c
--   </pre>
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>zip4</a> function takes four lists
--   and returns a list of quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | <i>O(n)</i>,<i>fusion</i>. <a>zipWith</a> generalises <a>zip</a> by
--   zipping with the function given as the first argument, instead of a
--   tupling function. For example, <tt><a>zipWith</a> (+)</tt> is applied
--   to two lists to produce the list of corresponding sums. Properties:
--   
--   <pre>
--   zipWith (,) = zip
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>zipWith3</a> function takes a
--   function which combines three elements, as well as three lists and
--   returns a list of their point-wise combination, analogous to
--   <a>zipWith</a>.
--   
--   Properties:
--   
--   <pre>
--   zipWith3 (,,) = zip3
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>zipWith4</a> function takes a
--   function which combines four elements, as well as four lists and
--   returns a list of their point-wise combination, analogous to
--   <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <i>O(O)</i>,<i>fusion</i>. <a>lines</a> breaks a string up into a list
--   of strings at newline characters. The resulting strings do not contain
--   newlines.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | <i>O(n)</i>,<i>fusion</i>. <a>unlines</a> is an inverse operation to
--   <a>lines</a>. It joins lines, after appending a terminating newline to
--   each.
--   
--   <pre>
--   unlines xs = concatMap (++"\n")
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means `essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own equality
--   test.
nub :: Eq a => [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   delete 'a' "banana" == "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference ((non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   "dog" `union` "cow" == "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result. It is a
--   special case of <a>intersectBy</a>, which allows the programmer to
--   supply their own equality test.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Properties:
--   
--   <pre>
--   not (null x) ==&gt; (head . sort) x = minimum x
--   not (null x) ==&gt; (last . sort) x = maximum x
--   </pre>
sort :: Ord a => [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>insert</a> function takes an element
--   and a list and inserts the element into the list at the last position
--   where it is still less than or equal to the next element. In
--   particular, if the list is sorted before the call, the result will
--   also be sorted. It is a special case of <a>insertBy</a>, which allows
--   the programmer to supply their own comparison function.
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. The non-overloaded version of
--   <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>maximumBy</a> function takes a
--   comparison function and a list and returns the greatest element of the
--   list by the comparison function. The list must be finite and
--   non-empty.
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | <i>O(n)</i>,<i>fusion</i>. The <a>minimumBy</a> function takes a
--   comparison function and a list and returns the least element of the
--   list by the comparison function. The list must be finite and
--   non-empty.
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: Num i => [b] -> i

-- | <i>O(n)</i>,<i>fusion</i>. The <a>genericTake</a> function is an
--   overloaded version of <a>take</a>, which accepts any <a>Integral</a>
--   value as the number of elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>genericDrop</a> function is an
--   overloaded version of <a>drop</a>, which accepts any <a>Integral</a>
--   value as the number of elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | <i>O(n)</i>,<i>fusion</i>. The <a>genericSplitAt</a> function is an
--   overloaded version of <a>splitAt</a>, which accepts any
--   <a>Integral</a> value as the position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | <i>O(n)</i>,<i>fusion</i>. The <a>genericIndex</a> function is an
--   overloaded version of <a>!!</a>, which accepts any <a>Integral</a>
--   value as the index.
genericIndex :: Integral a => [b] -> a -> b

-- | <i>O(n)</i>,<i>fusion</i>. The <a>genericReplicate</a> function is an
--   overloaded version of <a>replicate</a>, which accepts any
--   <a>Integral</a> value as the number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]
errorEmptyList :: String -> a


-- | The <a>Functor</a>, <a>Monad</a> and <a>MonadPlus</a> classes, with
--   some useful operations on monads.
module Control.Monad.Stream

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Minimal complete definition: <a>&gt;&gt;=</a> and <a>return</a>.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <pre>
--   return a &gt;&gt;= k  ==  k a
--   m &gt;&gt;= return  ==  m
--   m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  ==  (m &gt;&gt;= k) &gt;&gt;= h
--   </pre>
--   
--   Instances of both <a>Monad</a> and <a>Functor</a> should additionally
--   satisfy the law:
--   
--   <pre>
--   fmap f xs  ==  xs &gt;&gt;= return . f
--   </pre>
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Monad (m :: * -> *)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a

-- | Monads that also support choice and failure.
class Monad m => MonadPlus m
mzero :: MonadPlus m => m a
mplus :: MonadPlus m => m a -> m a -> m a

-- | <tt><a>mapM</a> f</tt> is equivalent to <tt><a>sequence</a> .
--   <a>map</a> f</tt>.
mapM :: Monad m => (a -> m b) -> [a] -> m [b]

-- | <tt><a>mapM_</a> f</tt> is equivalent to <tt><a>sequence_</a> .
--   <a>map</a> f</tt>.
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped
forM :: Monad m => [a] -> (a -> m b) -> m [b]

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped
forM_ :: Monad m => [a] -> (a -> m b) -> m ()

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | Evaluate each action in the sequence from left to right, and ignore
--   the results.
sequence_ :: Monad m => [m a] -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)

-- | Right-to-left Kleisli composition of monads. '(&gt;=&gt;)', with the
--   arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: Monad m => m a -> m ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m (m a) -> m a

-- | This generalizes the list-based <a>concat</a> function.
msum :: MonadPlus m => [m a] -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   monads.
zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where '(&gt;&gt;)' and the `folded function' are not commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm ]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Monad m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Monad m => Int -> m a -> m ()

-- | <tt><a>guard</a> b</tt> is <tt><a>return</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>mzero</a> if <tt>b</tt> is <a>False</a>.
guard :: MonadPlus m => Bool -> m ()

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b
instance MonadPlus Maybe
instance MonadPlus []
