-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An Attoparsec compatibility layer for Parsec
--   
--   This package provides an implementation of <a>Data.Attoparsec.Text</a>
--   in terms of Parsec. It can be used to write parsers that can be
--   compiled against both Attoparsec and Parsec.
--   
--   Attoparsec is an awesome and very fast library, but it still has a
--   weak point: It does not generate very useful error messages on parse
--   errors. Compiling an Attoparsec parser against Parsec can be useful
--   for at least two scenarios.
--   
--   <ul>
--   <li>Parsec can be used while developing Attoparsec parsers, so that
--   you get better error messages on failing test cases.</li>
--   <li>You can use Attoparsec for parsing, so that you benefit from it's
--   speed. And on parse errors you can re-parse the input with Parsec, so
--   that you can display a useful error message to the user.</li>
--   </ul>
--   
--   A simple usage example is here:
--   <a>https://github.com/sol/attoparsec-parsec#readme</a>
@package attoparsec-parsec
@version 0.0.2


-- | This module implements <a>Data.Attoparsec.Text</a> in terms of Parsec.
--   It can be used to write parsers that can be compiled against both
--   Attoparsec and Parsec.
--   
--   Differences from <a>Data.Attoparsec.Text</a>:
--   
--   <ul>
--   <li>Incremental input is not supported.</li>
--   <li><a>satisfyWith</a>, <a>skip</a>, <a>scan</a>, and most of the
--   numeric parsers are not yet implemented. Patches are gladly
--   welcome!</li>
--   <li>Parsec parsers (and hence the parsers provided here) do not
--   automatically backtrack on failing alternatives that consumed input.
--   With careful use of <a>try</a> it is possible to write parsers that
--   behave consistent across Attoparsec and Parsec. Read the next section
--   for more on that.</li>
--   </ul>
--   
--   A simple usage example is here:
--   <a>https://github.com/sol/attoparsec-parsec#readme</a>
module Data.Attoparsec.Text.Parsec
type Parser = Parsec Text ()
parseOnly :: Parser a -> Text -> Either String a

-- | Name the parser, in case failure occurs.
--   
--   See Parsec's documentation of <a>&lt;?&gt;</a> for detailed semantics.
(<?>) :: Parser a -> String -> Parser a

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   See Parsec's documentation of <a>try</a> for detailed semantics.
try :: Parser a -> Parser a

-- | Match a specific character.
char :: Char -> Parser Char

-- | Match any character.
anyChar :: Parser Char

-- | Match any character except the given one.
notChar :: Char -> Parser Char

-- | The parser <tt>satisfy p</tt> succeeds for any character for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the character that
--   is actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
satisfy :: (Char -> Bool) -> Parser Char

-- | Parse a single digit, as recognised by <a>isDigit</a>.
digit :: Parser Char

-- | Parse a letter, as recognised by <a>isAlpha</a>.
letter :: Parser Char

-- | Parse a space character, as recognised by <a>isSpace</a>.
space :: Parser Char

-- | Match any character in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal <tt>'-'</tt> to a set, place it at the beginning or
--   end of the string.
inClass :: String -> Char -> Bool

-- | Match any character not in a set.
notInClass :: String -> Char -> Bool

-- | <tt>string s</tt> parses a sequence of characters that identically
--   match <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>).
string :: Text -> Parser Text

-- | Satisfy a literal string, ignoring case.
--   
--   <i>Note</i>: No proper case folding is done, yet. Currently
--   <tt>stringCI s</tt> is just
--   
--   <pre>
--   char (toLower c) &lt;|&gt; char (toUpper c)
--   </pre>
--   
--   for each character of <tt>s</tt>. The implementation from
--   <a>Data.Attoparsec.Text</a> tries to do proper case folding, but is
--   actually buggy (see
--   <a>https://github.com/bos/attoparsec/issues/6</a>). As long as you
--   deal with characters from the ASCII range, both implementations should
--   be fine.
stringCI :: Text -> Parser Text

-- | Skip over white space.
skipSpace :: Parser ()

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Char -> Bool) -> Parser ()

-- | Consume exactly <tt>n</tt> characters of input.
take :: Int -> Parser Text

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Char -> Bool) -> Parser Text

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one
--   character of input: it will fail if the predicate never returns
--   <a>True</a> or if there is no input left.
takeWhile1 :: (Char -> Bool) -> Parser Text

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Char -> Bool) -> Parser Text

-- | Consume all remaining input and return it as a single string.
takeText :: Parser Text

-- | Consume all remaining input and return it as a single string.
takeLazyText :: Parser Text

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
endOfLine :: Parser ()

-- | A predicate that matches either a carriage return <tt>'\r'</tt> or
--   newline <tt>'\n'</tt> character.
isEndOfLine :: Char -> Bool

-- | A predicate that matches either a space <tt>' '</tt> or horizontal tab
--   <tt>'\t'</tt> character.
isHorizontalSpace :: Char -> Bool

-- | Parse and decode an unsigned decimal number.
decimal :: Integral a => Parser a

-- | Match only if all input has been consumed.
endOfInput :: Parser ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Parser Bool
