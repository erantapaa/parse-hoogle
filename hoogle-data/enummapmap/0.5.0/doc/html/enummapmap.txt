-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Map of maps using Enum types as keys
--   
--   This package provides 'maps of maps' using Enum types as keys. The
--   code is based upon Data.IntMap in containers 5.0.
@package enummapmap
@version 0.5.0


-- | Based on <a>Data.IntSet</a>, this module provides multi-dimensional
--   sets of <tt>Enums</tt>. Keys are built using <a>:&amp;</a> and
--   terminated with <a>S</a>. They are stored using <a>Int</a>s so 2 keys
--   that <a>Enum</a> to the same <a>Int</a> value will overwrite each
--   other. The intension is that the <a>Enum</a> types will actually be
--   <tt>newtype <a>Int</a></tt>s.
--   
--   <pre>
--   newtype AppleID = AppleID Int
--   newtype TreeID = TreeID Int
--   type Orchard = EnumMapSet (TreeID :&amp; S AppleID)
--   applePresent = member (TreeID 4 :&amp; K AppleID 32) orchard
--   </pre>
module Data.EnumMapSet
type EnumMapSet k = EnumMapMap k ()

-- | Keys are terminated with the <a>S</a> type.
--   
--   <pre>
--   singleKey :: S Int
--   singleKey = S 5
--   </pre>
newtype S k
S :: k -> S k

-- | Multiple keys are joined by the (<a>:&amp;</a>) constructor.
--   
--   <pre>
--   multiKey :: Int :&amp; Int :&amp; K Int
--   multiKey = 5 :&amp; 6 :&amp; K 5
--   </pre>
data (:&) k t
(:&) :: !k -> !t -> :& k t
null :: IsKey k => EnumMapSet k -> Bool
size :: IsKey k => EnumMapSet k -> Int
member :: (SubKey k1 k2 (), IsKey k1, IsKey k2) => k1 -> EnumMapSet k2 -> Bool

-- | Lookup a subtree in an <a>EnumMapSet</a>.
--   
--   <pre>
--   ems = fromList [1 :&amp; 2 :&amp; K 3, 1 :&amp; 2 :&amp; K 4]
--   lookup (1 :&amp; K 2) ems == fromList [K 3, K 4]
--   lookup (1 :&amp; 2 :&amp; K 3) -- ERROR: Use 'member' to check for a key.
--   </pre>
lookup :: (SubKey k1 k2 (), IsKey k1, IsKey k2) => k1 -> EnumMapSet k2 -> Maybe (Result k1 k2 ())
empty :: IsKey k => EnumMapSet k
singleton :: (IsKey k, SubKey k k (), Result k k () ~ ()) => k -> EnumMapSet k
insert :: (IsKey k, SubKey k k (), Result k k () ~ ()) => k -> EnumMapSet k -> EnumMapSet k
delete :: (SubKey k1 k2 (), IsKey k1, IsKey k2) => k1 -> EnumMapSet k2 -> EnumMapSet k2
union :: IsKey k => EnumMapSet k -> EnumMapSet k -> EnumMapSet k
difference :: IsKey k => EnumMapSet k -> EnumMapSet k -> EnumMapSet k
intersection :: IsKey k => EnumMapSet k -> EnumMapSet k -> EnumMapSet k

-- | <tt><a>map</a> f s</tt> is the set obtained by applying <tt>f</tt> to
--   each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (IsKey k1, IsKey k2, SubKey k2 k2 (), Result k2 k2 () ~ ()) => (k1 -> k2) -> EnumMapSet k1 -> EnumMapSet k2
foldr :: IsKey k => (k -> t -> t) -> t -> EnumMapSet k -> t
all :: IsKey k => (k -> Bool) -> EnumMapSet k -> Bool
toList :: IsKey k => EnumMapSet k -> [k]
fromList :: (IsKey k, SubKey k k (), Result k k () ~ ()) => [k] -> EnumMapSet k
keys :: IsKey k => EnumMapSet k -> [k]
findMin :: IsKey k => EnumMapSet k -> k
minView :: IsKey k => EnumMapSet k -> Maybe (k, EnumMapSet k)
deleteFindMin :: IsKey k => EnumMapSet k -> (k, EnumMapSet k)


-- | Strict <a>EnumMapMap</a>. Based upon <a>Data.IntMap.Strict</a>, this
--   version uses multi dimensional keys and <a>Enum</a> types instead of
--   <a>Int</a>s. Keys are built using the <a>:&amp;</a> operator and
--   terminated with <a>K</a>. They are stored using <a>Int</a>s so 2 keys
--   that <a>Enum</a> to the same <a>Int</a> value will overwrite each
--   other. The intension is that the <a>Enum</a> types will actually be
--   <tt>newtype <a>Int</a></tt>s.
--   
--   <pre>
--   newtype AppleID = AppleID Int
--   newtype TreeID = TreeID Int
--   type Orchard = EnumMapMap (TreeID :&amp; K AppleID) Apple
--   apple = lookup (TreeID 4 :&amp; K AppleID 32) orchard
--   </pre>
--   
--   The <a>K</a> type is different to that used in
--   <a>Data.EnumMapMap.Lazy</a> so only strict operations can be performed
--   on a strict <a>EnumMapMap</a>.
--   
--   The functions are strict on values and keys.
module Data.EnumMapMap.Strict

-- | Multiple keys are joined by the (<a>:&amp;</a>) constructor.
--   
--   <pre>
--   multiKey :: Int :&amp; Int :&amp; K Int
--   multiKey = 5 :&amp; 6 :&amp; K 5
--   </pre>
data (:&) k t
(:&) :: !k -> !t -> :& k t

-- | Keys are terminated with the <a>K</a> type
--   
--   <pre>
--   singleKey :: K Int
--   singleKey = K 5
--   </pre>
newtype K k
K :: k -> K k
class Eq k => IsKey k where data family EnumMapMap k :: * -> * joinKey = removeEmpties . unsafeJoinKey map f = mapWithKey (\ _ -> f) toList = foldrWithKey (\ k x xs -> (k, x) : xs) [] fromList = foldlStrict (\ t (k, x) -> insert k x t) empty elems = foldr (:) [] keys = foldrWithKey (\ k _ ks -> k : ks) [] deleteFindMin = fromMaybe (error "deleteFindMin: empty EnumMapMap has no minimal element") . minViewWithKey unions = foldlStrict union empty unionsWith f = foldlStrict (unionWith f) empty unionWith f = unionWithKey (\ _ -> f) differenceWith f = differenceWithKey (\ _ -> f) intersectionWith f = intersectionWithKey (\ _ -> f)
emptySubTrees :: IsKey k => EnumMapMap k v -> Bool
joinKey :: (IsKey k, IsKey (Plus k k2)) => EnumMapMap k (EnumMapMap k2 v) -> EnumMapMap (Plus k k2) v
unsafeJoinKey :: IsKey k => EnumMapMap k (EnumMapMap k2 v) -> EnumMapMap (Plus k k2) v
empty :: IsKey k => EnumMapMap k v
null :: IsKey k => EnumMapMap k v -> Bool
size :: IsKey k => EnumMapMap k v -> Int
alter :: IsKey k => (Maybe v -> Maybe v) -> k -> EnumMapMap k v -> EnumMapMap k v
map :: IsKey k => (v -> t) -> EnumMapMap k v -> EnumMapMap k t
mapWithKey :: IsKey k => (k -> v -> t) -> EnumMapMap k v -> EnumMapMap k t
foldr :: IsKey k => (v -> t -> t) -> t -> EnumMapMap k v -> t
foldrWithKey :: IsKey k => (k -> v -> t -> t) -> t -> EnumMapMap k v -> t
toList :: (IsKey k, SubKey k k v) => EnumMapMap k v -> [(k, v)]
fromList :: (IsKey k, SubKey k k v, Result k k v ~ v) => [(k, v)] -> EnumMapMap k v
elems :: IsKey k => EnumMapMap k v -> [v]
keys :: IsKey k => EnumMapMap k v -> [k]
keysSet :: (IsKey k, HasSKey k) => EnumMapMap k v -> EnumMapMap (Skey k) ()
fromSet :: (IsKey k, HasSKey k) => (k -> v) -> EnumMapMap (Skey k) () -> EnumMapMap k v
findMin :: IsKey k => EnumMapMap k v -> (k, v)
minViewWithKey :: IsKey k => EnumMapMap k v -> Maybe ((k, v), EnumMapMap k v)
deleteFindMin :: IsKey k => EnumMapMap k v -> ((k, v), EnumMapMap k v)
union :: IsKey k => EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
unions :: IsKey k => [EnumMapMap k v] -> EnumMapMap k v
unionsWith :: IsKey k => (v -> v -> v) -> [EnumMapMap k v] -> EnumMapMap k v
unionWith :: IsKey k => (v -> v -> v) -> EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
unionWithKey :: IsKey k => (k -> v -> v -> v) -> EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
difference :: IsKey k => EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
differenceWith :: IsKey k => (v1 -> v2 -> Maybe v1) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
differenceWithKey :: IsKey k => (k -> v1 -> v2 -> Maybe v1) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
intersection :: IsKey k => EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
intersectionWith :: IsKey k => (v1 -> v2 -> v3) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v3
intersectionWithKey :: IsKey k => (k -> v1 -> v2 -> v3) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v3
class SubKey k1 k2 v where type family Result k1 k2 v :: * insertWith f = insertWithKey (\ _ -> f)
member :: SubKey k1 k2 v => k1 -> EnumMapMap k2 v -> Bool
singleton :: SubKey k1 k2 v => k1 -> Result k1 k2 v -> EnumMapMap k2 v
lookup :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> EnumMapMap k2 v -> Maybe (Result k1 k2 v)
insert :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
insertWith :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => (Result k1 k2 v -> Result k1 k2 v -> Result k1 k2 v) -> k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
insertWithKey :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => (k1 -> Result k1 k2 v -> Result k1 k2 v -> Result k1 k2 v) -> k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
delete :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> EnumMapMap k2 v -> EnumMapMap k2 v

-- | Split after 1 key.
--   
--   <pre>
--   emm :: EnumMapMap (T1 :&amp; T2 :&amp; K T3) v
--   splitKey d1 emm :: EnumMapMap (T1 :&amp; K T2) (EnumMapMap (K T3) v)
--   </pre>
d1 :: Z

-- | Split after 2 keys.
--   
--   <pre>
--   emm :: EnumMapMap (T1 :&amp; T2 :&amp; K T3) v
--   splitKey d1 emm :: EnumMapMap (K T1) (EnumMapMap (T2 :&amp; K T3) v)
--   </pre>
d2 :: N Z
d3 :: N (N Z)
d4 :: N (N (N Z))
d5 :: N (N (N (N Z)))
d6 :: N (N (N (N (N Z))))
d7 :: N (N (N (N (N (N Z)))))
d8 :: N (N (N (N (N (N (N Z))))))
d9 :: N (N (N (N (N (N (N (N Z)))))))
d10 :: N (N (N (N (N (N (N (N (N Z))))))))

-- | The difference between an <a>EnumMapMap</a> and an
--   <tt>EnumMapSet</tt>. If a key is present in the <tt>EnumMapSet</tt> it
--   will not be present in the result.
differenceSet :: (SubKeyS k s, IsKey k, IsKey s) => EnumMapMap k v -> EnumMapMap s () -> EnumMapMap k v

-- | The intersection of an <a>EnumMapMap</a> and an <tt>EnumMapSet</tt>.
--   If a key is present in the EnumMapSet then it will be present in the
--   resulting <a>EnumMapMap</a>. Works with <tt>EnumMapSet</tt>s that are
--   submaps of the <a>EnumMapMap</a>.
intersectSet :: (SubKeyS k s, IsKey k, IsKey s) => EnumMapMap k v -> EnumMapMap s () -> EnumMapMap k v

-- | Convert a key terminated with <tt>S</tt> into one terminated with
--   <tt>K</tt>.
--   
--   <pre>
--   s = 1 :&amp; 2 :&amp; S 3
--   toK s == 1 :&amp; 2 :&amp; K 3
--   </pre>
toK :: HasSKey k => Skey k -> k

-- | Convert a key terminated with <tt>K</tt> into one terminated with
--   <tt>S</tt>.
--   
--   <pre>
--   k = 1 :&amp; 2 :&amp; 'K' 3
--   toS k == 1 :&amp; 2 :&amp; 'S' 3
--   </pre>
toS :: HasSKey k => k -> Skey k

-- | Split a key so that an <a>EnumMapMap</a> becomes an <a>EnumMapMap</a>
--   of <a>EnumMapMap</a>s.
--   
--   <pre>
--   newtype ID = ID Int deriving Enum
--   emm = empty :: EnumMapMap (Int :&amp; K ID) Bool
--   res :: EnumMapMap (K ID) Bool
--   res = lookup (K 5) $ splitKey d1 emm
--   </pre>
--   
--   If the level is too high then the compilation will fail with an error
--   
--   <pre>
--   emm = empty :: EnumMapMap (Int :&amp; Int :&amp; K Int) Bool -- 3 levels
--   res1 = splitKey d4 emm -- ERROR! Instance not found...
--   res2 = splitKey d3 emm -- ERROR! Instance not found...
--   res3 = splitKey d2 emm -- Good
--   </pre>
splitKey :: IsSplit k z => z -> EnumMapMap k v -> EnumMapMap (Head k z) (EnumMapMap (Tail k z) v)
instance Show k => Show (K k)
instance Eq k => Eq (K k)
instance Enum k => SubKeyS (K k) (S k)
instance (Enum k1, k1 ~ k2) => SubKeyS (k1 :& t) (S k2)
instance Enum k => SubKey (K k) (K k) v
instance (Enum k1, k1 ~ k2) => SubKey (K k1) (k2 :& t2) v
instance IsSplit (k :& t) Z
instance HasSKey (K k)
instance (Eq k, Enum k) => Foldable (EnumMapMap (K k))
instance NFData k => NFData (K k)
instance NFData v => NFData (EnumMapMap (K k) v)
instance Show v => Show (EnumMapMap (K k) v)
instance (Enum k, Eq k) => IsKey (K k)


-- | Lazy <a>EnumMapMap</a>. Based upon <a>Data.IntMap.Lazy</a>, this
--   version uses multi dimensional keys and <a>Enum</a> types instead of
--   <a>Int</a>s. Keys are built using the <a>:&amp;</a> operator and
--   terminated with <a>K</a>. They are stored using <a>Int</a>s so 2 keys
--   that <a>Enum</a> to the same <a>Int</a> value will overwrite each
--   other. The intension is that the <a>Enum</a> types will actually be
--   <tt>newtype <a>Int</a></tt>s.
--   
--   <pre>
--   newtype AppleID = AppleID Int
--   newtype TreeID = TreeID Int
--   type Orchard = EnumMapMap (TreeID :&amp; K AppleID) Apple
--   apple = lookup (TreeID 4 :&amp; K AppleID 32) orchard
--   </pre>
--   
--   The <a>K</a> type is different to that used in
--   <a>Data.EnumMapMap.Strict</a> so only lazy operations can be performed
--   on a lazy <a>EnumMapMap</a>.
--   
--   The functions are lazy on values, but strict on keys.
module Data.EnumMapMap.Lazy

-- | Multiple keys are joined by the (<a>:&amp;</a>) constructor.
--   
--   <pre>
--   multiKey :: Int :&amp; Int :&amp; K Int
--   multiKey = 5 :&amp; 6 :&amp; K 5
--   </pre>
data (:&) k t
(:&) :: !k -> !t -> :& k t

-- | Keys are terminated with the <a>K</a> type
--   
--   <pre>
--   singleKey :: K Int
--   singleKey = K 5
--   </pre>
newtype K k
K :: k -> K k
class Eq k => IsKey k where data family EnumMapMap k :: * -> * joinKey = removeEmpties . unsafeJoinKey map f = mapWithKey (\ _ -> f) toList = foldrWithKey (\ k x xs -> (k, x) : xs) [] fromList = foldlStrict (\ t (k, x) -> insert k x t) empty elems = foldr (:) [] keys = foldrWithKey (\ k _ ks -> k : ks) [] deleteFindMin = fromMaybe (error "deleteFindMin: empty EnumMapMap has no minimal element") . minViewWithKey unions = foldlStrict union empty unionsWith f = foldlStrict (unionWith f) empty unionWith f = unionWithKey (\ _ -> f) differenceWith f = differenceWithKey (\ _ -> f) intersectionWith f = intersectionWithKey (\ _ -> f)
emptySubTrees :: IsKey k => EnumMapMap k v -> Bool
joinKey :: (IsKey k, IsKey (Plus k k2)) => EnumMapMap k (EnumMapMap k2 v) -> EnumMapMap (Plus k k2) v
unsafeJoinKey :: IsKey k => EnumMapMap k (EnumMapMap k2 v) -> EnumMapMap (Plus k k2) v
empty :: IsKey k => EnumMapMap k v
null :: IsKey k => EnumMapMap k v -> Bool
size :: IsKey k => EnumMapMap k v -> Int
alter :: IsKey k => (Maybe v -> Maybe v) -> k -> EnumMapMap k v -> EnumMapMap k v
map :: IsKey k => (v -> t) -> EnumMapMap k v -> EnumMapMap k t
mapWithKey :: IsKey k => (k -> v -> t) -> EnumMapMap k v -> EnumMapMap k t
foldr :: IsKey k => (v -> t -> t) -> t -> EnumMapMap k v -> t
foldrWithKey :: IsKey k => (k -> v -> t -> t) -> t -> EnumMapMap k v -> t
toList :: (IsKey k, SubKey k k v) => EnumMapMap k v -> [(k, v)]
fromList :: (IsKey k, SubKey k k v, Result k k v ~ v) => [(k, v)] -> EnumMapMap k v
elems :: IsKey k => EnumMapMap k v -> [v]
keys :: IsKey k => EnumMapMap k v -> [k]
keysSet :: (IsKey k, HasSKey k) => EnumMapMap k v -> EnumMapMap (Skey k) ()
fromSet :: (IsKey k, HasSKey k) => (k -> v) -> EnumMapMap (Skey k) () -> EnumMapMap k v
findMin :: IsKey k => EnumMapMap k v -> (k, v)
minViewWithKey :: IsKey k => EnumMapMap k v -> Maybe ((k, v), EnumMapMap k v)
deleteFindMin :: IsKey k => EnumMapMap k v -> ((k, v), EnumMapMap k v)
union :: IsKey k => EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
unions :: IsKey k => [EnumMapMap k v] -> EnumMapMap k v
unionsWith :: IsKey k => (v -> v -> v) -> [EnumMapMap k v] -> EnumMapMap k v
unionWith :: IsKey k => (v -> v -> v) -> EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
unionWithKey :: IsKey k => (k -> v -> v -> v) -> EnumMapMap k v -> EnumMapMap k v -> EnumMapMap k v
difference :: IsKey k => EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
differenceWith :: IsKey k => (v1 -> v2 -> Maybe v1) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
differenceWithKey :: IsKey k => (k -> v1 -> v2 -> Maybe v1) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
intersection :: IsKey k => EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v1
intersectionWith :: IsKey k => (v1 -> v2 -> v3) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v3
intersectionWithKey :: IsKey k => (k -> v1 -> v2 -> v3) -> EnumMapMap k v1 -> EnumMapMap k v2 -> EnumMapMap k v3
class SubKey k1 k2 v where type family Result k1 k2 v :: * insertWith f = insertWithKey (\ _ -> f)
member :: SubKey k1 k2 v => k1 -> EnumMapMap k2 v -> Bool
singleton :: SubKey k1 k2 v => k1 -> Result k1 k2 v -> EnumMapMap k2 v
lookup :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> EnumMapMap k2 v -> Maybe (Result k1 k2 v)
insert :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
insertWith :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => (Result k1 k2 v -> Result k1 k2 v -> Result k1 k2 v) -> k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
insertWithKey :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => (k1 -> Result k1 k2 v -> Result k1 k2 v -> Result k1 k2 v) -> k1 -> Result k1 k2 v -> EnumMapMap k2 v -> EnumMapMap k2 v
delete :: (SubKey k1 k2 v, IsKey k1, IsKey k2) => k1 -> EnumMapMap k2 v -> EnumMapMap k2 v

-- | Split after 1 key.
--   
--   <pre>
--   emm :: EnumMapMap (T1 :&amp; T2 :&amp; K T3) v
--   splitKey d1 emm :: EnumMapMap (T1 :&amp; K T2) (EnumMapMap (K T3) v)
--   </pre>
d1 :: Z

-- | Split after 2 keys.
--   
--   <pre>
--   emm :: EnumMapMap (T1 :&amp; T2 :&amp; K T3) v
--   splitKey d1 emm :: EnumMapMap (K T1) (EnumMapMap (T2 :&amp; K T3) v)
--   </pre>
d2 :: N Z
d3 :: N (N Z)
d4 :: N (N (N Z))
d5 :: N (N (N (N Z)))
d6 :: N (N (N (N (N Z))))
d7 :: N (N (N (N (N (N Z)))))
d8 :: N (N (N (N (N (N (N Z))))))
d9 :: N (N (N (N (N (N (N (N Z)))))))
d10 :: N (N (N (N (N (N (N (N (N Z))))))))

-- | The difference between an <a>EnumMapMap</a> and an
--   <tt>EnumMapSet</tt>. If a key is present in the <tt>EnumMapSet</tt> it
--   will not be present in the result.
differenceSet :: (SubKeyS k s, IsKey k, IsKey s) => EnumMapMap k v -> EnumMapMap s () -> EnumMapMap k v

-- | The intersection of an <a>EnumMapMap</a> and an <tt>EnumMapSet</tt>.
--   If a key is present in the EnumMapSet then it will be present in the
--   resulting <a>EnumMapMap</a>. Works with <tt>EnumMapSet</tt>s that are
--   submaps of the <a>EnumMapMap</a>.
intersectSet :: (SubKeyS k s, IsKey k, IsKey s) => EnumMapMap k v -> EnumMapMap s () -> EnumMapMap k v

-- | Convert a key terminated with <tt>S</tt> into one terminated with
--   <tt>K</tt>.
--   
--   <pre>
--   s = 1 :&amp; 2 :&amp; S 3
--   toK s == 1 :&amp; 2 :&amp; K 3
--   </pre>
toK :: HasSKey k => Skey k -> k

-- | Convert a key terminated with <tt>K</tt> into one terminated with
--   <tt>S</tt>.
--   
--   <pre>
--   k = 1 :&amp; 2 :&amp; 'K' 3
--   toS k == 1 :&amp; 2 :&amp; 'S' 3
--   </pre>
toS :: HasSKey k => k -> Skey k

-- | Split a key so that an <a>EnumMapMap</a> becomes an <a>EnumMapMap</a>
--   of <a>EnumMapMap</a>s.
--   
--   <pre>
--   newtype ID = ID Int deriving Enum
--   emm = empty :: EnumMapMap (Int :&amp; K ID) Bool
--   res :: EnumMapMap (K ID) Bool
--   res = lookup (K 5) $ splitKey d1 emm
--   </pre>
--   
--   If the level is too high then the compilation will fail with an error
--   
--   <pre>
--   emm = empty :: EnumMapMap (Int :&amp; Int :&amp; K Int) Bool -- 3 levels
--   res1 = splitKey d4 emm -- ERROR! Instance not found...
--   res2 = splitKey d3 emm -- ERROR! Instance not found...
--   res3 = splitKey d2 emm -- Good
--   </pre>
splitKey :: IsSplit k z => z -> EnumMapMap k v -> EnumMapMap (Head k z) (EnumMapMap (Tail k z) v)
instance Show k => Show (K k)
instance Eq k => Eq (K k)
instance Enum k => SubKeyS (K k) (S k)
instance (Enum k1, k1 ~ k2) => SubKeyS (k1 :& t) (S k2)
instance Enum k => SubKey (K k) (K k) v
instance (Enum k1, k1 ~ k2) => SubKey (K k1) (k2 :& t2) v
instance IsSplit (k :& t) Z
instance HasSKey (K k)
instance (Eq k, Enum k) => Foldable (EnumMapMap (K k))
instance NFData k => NFData (K k)
instance NFData v => NFData (EnumMapMap (K k) v)
instance Show v => Show (EnumMapMap (K k) v)
instance (Enum k, Eq k) => IsKey (K k)
