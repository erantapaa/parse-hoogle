-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Something similar to Dijkstra's guarded command language
--   
--   language-gcl provides the abstract syntax and parsers for basic
--   building blocks for programming languages, based on Edsger W.
--   Dijkstra's guarded command language.
@package language-gcl
@version 0.2


-- | A language with guarded commands, heavily based on:
--   
--   <ul>
--   <li>Edsger W. Dijkstra. Guarded commands, nondeterminacy and formal
--   derivation of programs. <i>Commun. ACM 18</i>, 8 (August 1975),
--   453–457. <a>DOI=10.1145/360933.360975</a></li>
--   </ul>
--   
--   With regards to the above source, the following assumptions were made:
--   
--   <ul>
--   <li>Guarded command sets may be empty, and __skip__ and __abort__ are
--   keywords.</li>
--   <li>The __while__ <i>guard</i> __do__ <i>stmts...</i> __od__ notation
--   used on page 457 is allowed and is syntactic sugar for __do__
--   <i>guard</i> __→__<i>stmts...</i> __od__.</li>
--   </ul>
--   
--   Furthermore, the language is extended so that the blocks denoted by
--   __do__ <i>...</i> __od__ may be preceded by zero or more loop
--   invariants (written: __invariant__ <i>guard</i>).
module Language.GuardedCommands

-- | Guarded statements
data GCL stmt guard

-- | Alternative statement. If none of the guards is true, the command
--   diverges; otherwise, an arbitrary guarded list with a true guard is
--   executed.
Alternative :: [GC stmt guard] -> GCL stmt guard

-- | Repetitive statement. If none of the guards is true, the command
--   terminates; otherwise, an arbitrary guarded list with a true guard is
--   executed (the 'iteration'), after which the entire repetitive
--   statement is executed again. Before and after every iteration, all
--   loop invariants must hold.
Repetitive :: [guard] -> [GC stmt guard] -> GCL stmt guard

-- | Some user-defined statement.
Statement :: stmt -> GCL stmt guard

-- | Guarded commands
data GC stmt guard
GC :: guard -> [GCL stmt guard] -> GC stmt guard

-- | Parse a guarded statement, given parsers for user-defined statments
--   and for guards.
pGCL :: TokenParsing m => m stmt -> m guard -> m (GCL stmt guard)

-- | Parse a guarded command set, given parsers for guards and guarded
--   statements.
--   
--   The guarded commands are separated by a 'white vertical bar' (U+2AFE)
--   symbol, a.k.a. 'Dijkstra choice'.
pGuardedCommandSet :: TokenParsing m => m guard -> m (GCL stmt guard) -> m [GC stmt guard]

-- | Parse a guarded command, given parsers for guards and guarded
--   statements.
--   
--   The guard and the guarded list are separated by a 'rightwards arrow'
--   (U+2192) symbol.
pGuardedCommand :: TokenParsing m => m guard -> m (GCL stmt guard) -> m (GC stmt guard)

-- | Parse a guarded list, given a parser for guarded statements.
--   
--   The guarded statements are separated by a semicolon. This function is
--   equal to a type-restricted <a>semiSep1</a>.
pGuardedList :: TokenParsing m => m (GCL stmt guard) -> m [GCL stmt guard]
instance Typeable2 GC
instance Typeable2 GCL
instance (Data stmt, Data guard) => Data (GC stmt guard)
instance (Eq stmt, Eq guard) => Eq (GC stmt guard)
instance Foldable (GC stmt)
instance Functor (GC stmt)
instance (Show stmt, Show guard) => Show (GC stmt guard)
instance Traversable (GC stmt)
instance (Data stmt, Data guard) => Data (GCL stmt guard)
instance (Eq stmt, Eq guard) => Eq (GCL stmt guard)
instance Foldable (GCL stmt)
instance Functor (GCL stmt)
instance (Show stmt, Show guard) => Show (GCL stmt guard)
instance Traversable (GCL stmt)
instance Bifunctor GC
instance Bifunctor GCL
