-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for reading, manipulating, and writing HDR images
--   
--   PFS is a library for manipulating Portable Floating-point Streams, an
--   interchange format for high-dynamic range images. You will need
--   pfstools for this library to work properly. pfstools can be found at
--   http:<i></i>pfstools.sourceforge.net/
@package HDRUtils
@version 1.0.2

module Graphics.Image.PixelMap

-- | type of channels
type Channel = StorableArray (Int, Int) CFloat

-- | A pixel map, stored as separate 2D mutable, C-compatible arrays for
--   each channel in w,h order
data PixelMap
PixelMap :: [(String, String)] -> Map String (StorableArray (Int, Int) CFloat) -> Int -> Int -> ColourSpace -> PixelMap

-- | tags for TIFF files
tags :: PixelMap -> [(String, String)]

-- | the actual pixels. if the image is an CIE one then channels will be
--   "X", "Y", "Z" (and possibly more). If it's RGB, then it's "R" "G" "B"
--   (and possibly more)
pixels :: PixelMap -> Map String (StorableArray (Int, Int) CFloat)

-- | the width of the image
width :: PixelMap -> Int

-- | the height of the image
height :: PixelMap -> Int

-- | the color space of the image (see <a>Data.Colour</a> for more details)
colorspace :: PixelMap -> ColourSpace

-- | Converting to and from this portable PixelMap format
class ImageData a
toPixelMap :: (ImageData a) => a -> PixelMap
fromPixelMap :: (ImageData a) => PixelMap -> a

-- | Colourspace monikers representing different spaces in Data.Colour
data ColourSpace

-- | CIE XYZa format. Don't worry if you don't have an alpha channel, it
--   will be filled in if you don't.
Ciea :: ColourSpace

-- | RGBa with a defined colourspace
Rgba :: (RGBSpace CFloat) -> ColourSpace

-- | SRGBa
Srgba :: ColourSpace

-- | Linear SRGBa colourspace
SrgbaLinear :: ColourSpace

-- | Read an arbitrary pixel
(!!) :: PixelMap -> (Int, Int) -> IO (AlphaColour CFloat)

-- | Read one channel from an arbitrary pixel
(!/) :: PixelMap -> (Int, Int, String) -> IO CFloat

-- | Write one channel of an arbitrary pixel
(!/=) :: (CFloat -> IO ()) -> CFloat -> IO ()

-- | Usage: refChan image (0,0) "R" !/= 1.0
refChan :: PixelMap -> (Int, Int) -> String -> CFloat -> IO ()

-- | Write a colour to an arbitrary pixel
(!=) :: (AlphaColour CFloat -> IO ()) -> AlphaColour CFloat -> IO ()

-- | Usage: refPixel image (0,0) != opaque black
refPixel :: PixelMap -> (Int, Int) -> AlphaColour CFloat -> IO ()

module Graphics.Image.PFS.Internal
data TagIterator
data TagContainer
data Channel
data Array
data ChannelIterator
data Frame
data DOMIO
data FrameFile
data FrameFileIterator
data FILE
type TagIteratorH = Ptr TagIterator
type TagContainerH = Ptr TagContainer
type ChannelH = Ptr Channel
type ArrayH = Ptr Array
type ChannelIteratorH = Ptr ChannelIterator
type FrameH = Ptr Frame
type DOMIOH = Ptr DOMIO
type FrameFileH = Ptr FrameFile
type FrameFileIteratorH = Ptr FrameFileIterator
type FILEH = Ptr FILE
pfs_TagIteratorGetNext :: TagIteratorH -> IO CString
pfs_TagIteratorHasNext :: TagIteratorH -> CInt
pfs_TagContainerGetString :: TagContainerH -> CString -> IO CString
pfs_TagContainerSetString :: TagContainerH -> CString -> CString -> IO ()
pfs_TagContainerRemoveTag :: TagContainerH -> CString -> IO ()
pfs_TagContainerGetIterator :: TagContainerH -> IO TagIteratorH
pfs_Array2DGetCols :: ArrayH -> CInt
pfs_Array2DGetRows :: ArrayH -> CInt
pfs_Array2DGet :: ArrayH -> CInt -> CInt -> CFloat
pfs_Array2DSet :: ArrayH -> CInt -> CInt -> CFloat -> IO CFloat
pfs_Array1DGet :: ArrayH -> CInt -> CFloat
pfs_Array1DSet :: ArrayH -> CInt -> CFloat -> IO CFloat
pfs_ChannelGetWidth :: ChannelH -> CInt
pfs_ChannelGetHeight :: ChannelH -> CInt
pfs_ChannelGetName :: ChannelH -> CString
pfs_ChannelGetTags :: ChannelH -> IO TagContainerH
pfs_ChannelGetRawData :: ChannelH -> IO (Ptr CFloat)
pfs_ChannelIteratorGetNext :: ChannelIteratorH -> IO ChannelH
pfs_ChannelIteratorHasNext :: ChannelIteratorH -> IO CInt
pfs_FrameGetWidth :: FrameH -> CInt
pfs_FrameGetHeight :: FrameH -> CInt
pfs_FrameGetXYZChannels :: FrameH -> Ptr ChannelH -> Ptr ChannelH -> Ptr ChannelH -> IO ()
pfs_FrameCreateXYZChannels :: FrameH -> Ptr ChannelH -> Ptr ChannelH -> Ptr ChannelH -> IO ()
pfs_FrameGetChannel :: FrameH -> CString -> IO ChannelH
pfs_FrameCreateChannel :: FrameH -> CString -> IO ChannelH
pfs_FrameRemoveChannel :: FrameH -> ChannelH -> IO ()
pfs_FrameGetChannelIterator :: FrameH -> IO ChannelIteratorH
pfs_FrameGetTags :: FrameH -> IO TagContainerH
pfs_newDOMIO :: IO DOMIOH
pfs_deleteDOMIO :: DOMIOH -> IO ()
pfs_DOMIOCreateFrame :: DOMIOH -> CInt -> CInt -> IO FrameH
pfs_DOMIOWriteFrame :: DOMIOH -> FrameH -> FILEH -> IO ()
pfs_DOMIOReadFrame :: DOMIOH -> FILEH -> IO FrameH
pfs_DOMIOFreeFrame :: DOMIOH -> FrameH -> IO ()
pfs_newFrameFile :: FILEH -> CString -> IO FrameFileH
pfs_FrameFileGetFileHandle :: FrameFileH -> FILEH
pfsFrameFileGetFileName :: FrameFileH -> CString
pfs_newFrameFileIterator :: Ptr CInt -> Ptr CString -> CString -> CString -> FILEH -> CString -> Ptr () -> IO FrameFileIteratorH
pfs_FrameFileIteratorGetNextFrameFile :: FrameFileIteratorH -> IO FrameFileH
pfs_FrameFileIteratorCloseFrameFile :: FrameFileH -> IO ()
pfs_freeChannelIterator :: ChannelIteratorH -> IO ()
pfs_freeTagIterator :: TagIteratorH -> IO ()
fopen :: CString -> CString -> IO FILEH
fclose :: FILEH -> IO ()
fdopen :: CInt -> CString -> IO FILEH

module Graphics.Image.PFS

-- | Datatype representing a floating point image frame
data FPFrame
FPFrame :: [(String, String)] -> StorableArray (Int, Int) CFloat -> StorableArray (Int, Int) CFloat -> StorableArray (Int, Int) CFloat -> Map String (StorableArray (Int, Int) CFloat) -> Int -> Int -> FPFrame
tags :: FPFrame -> [(String, String)]
channelX :: FPFrame -> StorableArray (Int, Int) CFloat
channelY :: FPFrame -> StorableArray (Int, Int) CFloat
channelZ :: FPFrame -> StorableArray (Int, Int) CFloat
channels :: FPFrame -> Map String (StorableArray (Int, Int) CFloat)
width :: FPFrame -> Int
height :: FPFrame -> Int

-- | Read a frame from a handle
hReadFrame :: Handle -> IO FPFrame
readFrameFromFile :: FilePath -> IO FPFrame

-- | Write a frame to a PFS file
writeFrameToFile :: FilePath -> FPFrame -> IO ()

-- | Write a frame to a Handle
hWriteFrame :: Handle -> FPFrame -> IO ()

-- | get a frame from stdin
getFrame :: IO FPFrame

-- | put a frame to stdout
putFrame :: FPFrame -> IO ()
instance ImageData FPFrame
