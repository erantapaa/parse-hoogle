-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fay Text type represented as JavaScript strings
--   
@package fay-text
@version 0.3.2.2


-- | Module to be shared between server and client.
--   
--   This module must be valid for both GHC and Fay.
--   
--   For GHC this is an alias for Data.Text, for Fay it's an opaque data
--   type represented by JavaScript strings.
module Fay.Text.Type

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>. Subject to
--   fusion. Performs replacement on invalid scalar values.
pack :: String -> Text

-- | <i>O(n)</i> Convert a <a>Text</a> into a <a>String</a>. Subject to
--   fusion.
unpack :: Text -> String

-- | Have this in scope with the OverloadedStrings and BindableSyntax
--   extensions and Fay will replace all string literals with Text.
fromString :: String -> Text


-- | Module to be shared between server and client.
--   
--   This module must be valid for both GHC and Fay.
--   
--   For GHC this is an alias for Data.Text, for Fay it's an opaque data
--   type represented by JavaScript strings.
module Fay.Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>. Subject to
--   fusion. Performs replacement on invalid scalar values.
pack :: String -> Text

-- | <i>O(n)</i> Convert a <a>Text</a> into a <a>String</a>. Subject to
--   fusion.
unpack :: Text -> String

-- | Have this in scope with the OverloadedStrings and BindableSyntax
--   extensions and Fay will replace all string literals with Text.
fromString :: String -> Text

-- | <i>O(1)</i> The empty <a>Text</a>.
empty :: Text

-- | <i>O(m+n)</i> Break a <a>Text</a> into pieces separated by the first
--   <a>Text</a> argument (which cannot be empty), consuming the delimiter.
--   An empty delimiter is invalid, and will cause an error to be raised.
--   
--   Examples:
--   
--   <pre>
--   splitOn "\r\n" "a\r\nb\r\nd\r\ne" == ["a","b","d","e"]
--   splitOn "aaa"  "aaaXaaaXaaaXaaa"  == ["","X","X","X",""]
--   splitOn "x"    "x"                == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate s . splitOn s         == id
--   splitOn (singleton c)             == split (==c)
--   </pre>
--   
--   (Note: the string <tt>s</tt> to split on above cannot be empty.)
--   
--   In (unlikely) bad cases, this function's time complexity degrades
--   towards <i>O(n*m)</i>.
splitOn :: Text -> Text -> [Text]

-- | <i>O(n)</i> Return the prefix of the second string if its suffix
--   matches the entire first string.
--   
--   Examples:
--   
--   <pre>
--   stripSuffix "bar" "foobar" == Just "foo"
--   stripSuffix ""    "baz"    == Just "baz"
--   stripSuffix "foo" "quux"   == Nothing
--   </pre>
--   
--   This is particularly useful with the <tt>ViewPatterns</tt> extension
--   to GHC, as follows:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns #-}
--   import Data.Text as T
--   
--   quuxLength :: Text -&gt; Int
--   quuxLength (stripSuffix "quux" -&gt; Just pre) = T.length pre
--   quuxLength _                                = -1
--   </pre>
stripSuffix :: Text -> Text -> Maybe Text

-- | <i>O(n)</i> Adds a character to the front of a <a>Text</a>. This
--   function is more costly than its <tt>List</tt> counterpart because it
--   requires copying a new array. Subject to fusion. Performs replacement
--   on invalid scalar values.
cons :: Char -> Text -> Text

-- | <i>O(n)</i> Adds a character to the end of a <a>Text</a>. This copies
--   the entire array in the process, unless fused. Subject to fusion.
--   Performs replacement on invalid scalar values.
snoc :: Text -> Char -> Text

-- | <i>O(n)</i> Appends one <a>Text</a> to the other by copying both of
--   them into a new <a>Text</a>. Subject to fusion.
append :: Text -> Text -> Text

-- | <i>O(1)</i> Returns the first character and rest of a <a>Text</a>, or
--   <a>Nothing</a> if empty. Subject to fusion.
uncons :: Text -> Maybe (Char, Text)

-- | <i>O(1)</i> Returns the first character of a <a>Text</a>, which must
--   be non-empty. Subject to fusion.
head :: Text -> Char

-- | <i>O(1)</i> Returns all but the last character of a <a>Text</a>, which
--   must be non-empty. Subject to fusion.
init :: Text -> Text

-- | <i>O(1)</i> Returns the last character of a <a>Text</a>, which must be
--   non-empty. Subject to fusion.
last :: Text -> Char

-- | <i>O(1)</i> Returns all characters after the head of a <a>Text</a>,
--   which must be non-empty. Subject to fusion.
tail :: Text -> Text

-- | <i>O(1)</i> Tests whether a <a>Text</a> is empty or not. Subject to
--   fusion.
null :: Text -> Bool

-- | <i>O(n)</i> Returns the number of characters in a <a>Text</a>. Subject
--   to fusion.
length :: Text -> Int

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>Text</a>, which must be non-empty. Subject to fusion.
maximum :: Text -> Char

-- | <i>O(n)</i> <a>all</a> <tt>p</tt> <tt>t</tt> determines whether all
--   characters in the <a>Text</a> <tt>t</tt> satisify the predicate
--   <tt>p</tt>. Subject to fusion.
all :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> <a>any</a> <tt>p</tt> <tt>t</tt> determines whether any
--   character in the <a>Text</a> <tt>t</tt> satisifes the predicate
--   <tt>p</tt>. Subject to fusion.
any :: (Char -> Bool) -> Text -> Bool

-- | <i>O(n)</i> Map a function over a <a>Text</a> that results in a
--   <a>Text</a>, and concatenate the results.
concatMap :: (Char -> Text) -> Text -> Text

-- | <i>O(n)</i> Concatenate a list of <a>Text</a>s.
concat :: [Text] -> Text

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>Text</a>, which must be non-empty. Subject to fusion.
minimum :: Text -> Char

-- | <i>O(n)</i> Convert a string to lower case, using simple case
--   conversion. Subject to fusion.
--   
--   The result string may be longer than the input string. For instance,
--   "İ" (Latin capital letter I with dot above, U+0130) maps to the
--   sequence "i" (Latin small letter i, U+0069) followed by " ̇"
--   (combining dot above, U+0307).
toLower :: Text -> Text

-- | <i>O(n)</i> Convert a string to upper case, using simple case
--   conversion. Subject to fusion.
--   
--   The result string may be longer than the input string. For instance,
--   the German "ß" (eszett, U+00DF) maps to the two-letter sequence "SS".
toUpper :: Text -> Text

-- | <i>O(n)</i> <a>map</a> <tt>f</tt> <tt>t</tt> is the <a>Text</a>
--   obtained by applying <tt>f</tt> to each element of <tt>t</tt>. Subject
--   to fusion. Performs replacement on invalid scalar values.
map :: (Char -> Char) -> Text -> Text

-- | <i>O(n)</i> The <a>intercalate</a> function takes a <a>Text</a> and a
--   list of <a>Text</a>s and concatenates the list after interspersing the
--   first argument between each element of the list.
intercalate :: Text -> [Text] -> Text

-- | <i>O(n)</i> The <a>intersperse</a> function takes a character and
--   places it between the characters of a <a>Text</a>. Subject to fusion.
--   Performs replacement on invalid scalar values.
intersperse :: Char -> Text -> Text

-- | <i>O(n)</i> Reverse the characters of a string. Subject to fusion.
reverse :: Text -> Text

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two <a>Text</a>s and
--   returns <a>True</a> iff the first is a prefix of the second. Subject
--   to fusion.
isPrefixOf :: Text -> Text -> Bool

-- | <i>O(n)</i> <a>drop</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the suffix of the <a>Text</a> after the first <tt>n</tt> characters,
--   or the empty <a>Text</a> if <tt>n</tt> is greater than the length of
--   the <a>Text</a>. Subject to fusion.
drop :: Int -> Text -> Text

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a <a>Text</a>, returns
--   the prefix of the <a>Text</a> of length <tt>n</tt>, or the <a>Text</a>
--   itself if <tt>n</tt> is greater than the length of the Text. Subject
--   to fusion.
take :: Int -> Text -> Text

-- | <i>O(n)</i> Joins lines, after appending a terminating newline to
--   each.
unlines :: [Text] -> Text

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of <a>Text</a>s at
--   newline <a>Char</a>s. The resulting strings do not contain newlines.
lines :: Text -> [Text]
