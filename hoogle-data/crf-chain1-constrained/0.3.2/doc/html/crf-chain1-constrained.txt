-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | First-order, constrained, linear-chain conditional random fields
--   
@package crf-chain1-constrained
@version 0.3.2

module Data.CRF.Chain1.Constrained.Dataset.Internal

-- | An observation.
newtype Ob
Ob :: Int -> Ob
unOb :: Ob -> Int

-- | A label.
newtype Lb
Lb :: Int -> Lb
unLb :: Lb -> Int

-- | A word represented by a list of its observations and a list of its
--   potential label interpretations.
data X

-- | The word with default set of potential interpretations.
X :: AVec Ob -> X
_unX :: X -> AVec Ob

-- | The word with custom set of potential labels.
R :: AVec Ob -> AVec Lb -> X
_unX :: X -> AVec Ob
_unR :: X -> AVec Lb

-- | X constructor.
mkX :: [Ob] -> [Lb] -> X

-- | List of observations.
unX :: X -> [Ob]

-- | List of potential labels.
unR :: AVec Lb -> X -> [Lb]

-- | Sentence of words.
type Xs = Vector X

-- | Probability distribution over labels. We assume, that when y is a
--   member of chosen labels list it is also a member of the list potential
--   labels for corresponding <a>X</a> word. TODO: Perhaps we should
--   substitute <a>Lb</a>s with label indices corresponding to labels from
--   the vector of potential labels? FIXME: The type definition is
--   incorrect (see <a>fromList</a> definition), it should be something
--   like AVec2.
newtype Y
Y :: AVec (Lb, Double) -> Y
_unY :: Y -> AVec (Lb, Double)

-- | Y constructor.
mkY :: [(Lb, Double)] -> Y

-- | Y deconstructor symetric to mkY.
unY :: Y -> [(Lb, Double)]

-- | Sentence of Y (label choices).
type Ys = Vector Y

-- | Ascending vector of unique interger elements.
data AVec a

-- | Smart AVec constructor which ensures that the underlying vector
--   satisfies the AVec properties.
fromList :: (Ord a, Unbox a) => [a] -> AVec a

-- | Smart AVec constructor which ensures that the underlying vector
--   satisfies the AVec properties.
fromSet :: (Ord a, Unbox a) => Set a -> AVec a
instance (Show a, Unbox a) => Show (AVec a)
instance (Read a, Unbox a) => Read (AVec a)
instance (Eq a, Unbox a) => Eq (AVec a)
instance (Ord a, Unbox a) => Ord (AVec a)
instance (Binary a, Unbox a) => Binary (AVec a)
instance Show X
instance Read X
instance Eq X
instance Ord X
instance Show Y
instance Read Y
instance Eq Y
instance Ord Y
instance Binary Y
instance Binary X
instance Vector Vector Lb
instance MVector MVector Lb
instance Unbox Lb
instance Show Lb
instance Read Lb
instance Eq Lb
instance Ord Lb
instance Binary Lb
instance Num Lb
instance Ix Lb
instance Vector Vector Ob
instance MVector MVector Ob
instance Unbox Ob
instance Show Ob
instance Read Ob
instance Eq Ob
instance Ord Ob
instance Binary Ob

module Data.CRF.Chain1.Constrained.Dataset.External

-- | A Word is represented by a set of observations and a set of potential
--   interpretation labels. When the set of potential labels is empty the
--   word is considered to be unknown and the default potential set is used
--   in its place.
data Word a b
Word :: Set a -> Set b -> Word a b

-- | The set of observations
obs :: Word a b -> Set a

-- | The set of potential interpretations.
lbs :: Word a b -> Set b

-- | The word is considered to be unknown when the set of potential labels
--   is empty.
unknown :: Word a b -> Bool

-- | A sentence of words.
type Sent a b = [Word a b]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Prob a

-- | Construct the probability distribution.
mkProb :: Ord a => [(a, Double)] -> Prob a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels. We assume that every label from the distribution
--   domain is a member of the set of potential labels corresponding to the
--   word. Use the <a>mkWordL</a> smart constructor to build <a>WordL</a>.
data WordL a b

-- | Ensure, that every label from the distribution domain is a member of
--   the set of potential labels corresponding to the word.
mkWordL :: Word a b -> Prob b -> WordL a b

-- | A sentence of labeled words.
type SentL a b = [WordL a b]
instance (Show a, Show b) => Show (Word a b)
instance (Eq a, Eq b) => Eq (Word a b)
instance (Ord a, Ord b) => Ord (Word a b)
instance Show a => Show (Prob a)
instance Eq a => Eq (Prob a)
instance Ord a => Ord (Prob a)

module Data.CRF.Chain1.Constrained.Dataset.Codec

-- | A codec. The first component is used to encode observations of type a,
--   the second one is used to encode labels of type b.
type Codec a b = (AtomCodec a, AtomCodec (Maybe b))

-- | Type synonym for the codec monad. It is important to notice that by a
--   codec we denote here a structure of two <a>AtomCodec</a>s while in the
--   monad-codec package it denotes a monad.
type CodecM a b c = Codec (Codec a b) c

-- | The maximum internal observation included in the codec.
obMax :: Codec a b -> Ob

-- | The maximum internal label included in the codec.
lbMax :: Codec a b -> Lb

-- | Encode the word and update the codec.
encodeWord'Cu :: (Ord a, Ord b) => Word a b -> CodecM a b X

-- | Encode the word and do *not* update the codec.
encodeWord'Cn :: (Ord a, Ord b) => Word a b -> CodecM a b X

-- | Encode the sentence and update the codec.
encodeSent'Cu :: (Ord a, Ord b) => Sent a b -> CodecM a b Xs

-- | Encode the sentence and do *not* update the codec.
encodeSent'Cn :: (Ord a, Ord b) => Sent a b -> CodecM a b Xs

-- | Encode the sentence using the given codec.
encodeSent :: (Ord a, Ord b) => Codec a b -> Sent a b -> Xs

-- | Encode the labeled word and update the codec.
encodeWordL'Cu :: (Ord a, Ord b) => WordL a b -> CodecM a b (X, Y)

-- | Encodec the labeled word and do *not* update the codec.
encodeWordL'Cn :: (Ord a, Ord b) => WordL a b -> CodecM a b (X, Y)

-- | Encode the labeled sentence and update the codec.
encodeSentL'Cu :: (Ord a, Ord b) => SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence and do *not* update the codec. Substitute
--   the default label for any label not present in the codec.
encodeSentL'Cn :: (Ord a, Ord b) => SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence with the given codec. Substitute the
--   default label for any label not present in the codec.
encodeSentL :: (Ord a, Ord b) => Codec a b -> SentL a b -> (Xs, Ys)

-- | Encode labels into an ascending vector of distinct label codes.
encodeLabels :: Ord b => Codec a b -> [b] -> AVec Lb

-- | Decode the label.
decodeLabel :: Ord b => Codec a b -> Lb -> Maybe b

-- | Decode the sequence of labels.
decodeLabels :: Ord b => Codec a b -> [Lb] -> [Maybe b]

-- | Create codec on the basis of the labeled dataset.
mkCodec :: (Ord a, Ord b) => [SentL a b] -> Codec a b

-- | Encode the dataset with the codec.
encodeData :: (Ord a, Ord b) => Codec a b -> [Sent a b] -> [Xs]

-- | Encode the labeled dataset using the codec. Substitute the default
--   label for any label not present in the codec.
encodeDataL :: (Ord a, Ord b) => Codec a b -> [SentL a b] -> [(Xs, Ys)]

-- | Return the label when <a>Just</a> or one of the unknown values when
--   <a>Nothing</a>.
unJust :: Ord b => Codec a b -> Word a b -> Maybe b -> b

-- | Replace <a>Nothing</a> labels with all unknown labels from the set of
--   potential interpretations.
unJusts :: Ord b => Codec a b -> Word a b -> [Maybe b] -> [b]

module Data.CRF.Chain1.Constrained.Feature

-- | A Feature is either an observation feature OFeature o x, which models
--   relation between observation o and label x assigned to the same word,
--   or a transition feature TFeature x y (SFeature x for the first
--   position in the sentence), which models relation between two
--   subsequent labels, x (on i-th position) and y (on (i-1)-th positoin).
data Feature
SFeature :: {-# UNPACK #-} !Lb -> Feature
TFeature :: {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Lb -> Feature
OFeature :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb -> Feature

-- | Is it a <a>SFeature</a>?
isSFeat :: Feature -> Bool

-- | Is it a <a>TFeature</a>?
isTFeat :: Feature -> Bool

-- | Is it an <a>OFeature</a>?
isOFeat :: Feature -> Bool

-- | All features with assigned probabilities in given labeled sentence.
featuresIn :: Xs -> Ys -> [(Feature, LogFloat)]
instance Show Feature
instance Eq Feature
instance Ord Feature
instance Binary Feature


-- | The module provides feature selection functions which extract features
--   present in the dataset, i.e. features which directly occure the
--   dataset.
--   
--   You can mix functions defined here with the selection functions from
--   the <a>Data.CRF.Chain1.Constrained.Feature.Hidden</a> module.
module Data.CRF.Chain1.Constrained.Feature.Present

-- | <a>Feature</a>s of all kinds which occur in the dataset.
presentFeats :: [(Xs, Ys)] -> [Feature]

-- | <a>OFeature</a>s which occur in the dataset.
presentOFeats :: [(Xs, Ys)] -> [Feature]

-- | <a>TFeature</a>s which occur in the dataset.
presentTFeats :: [(a, Ys)] -> [Feature]

-- | <a>SFeature</a>s which occur in the dataset.
presentSFeats :: [(a, Ys)] -> [Feature]


-- | The module provides feature selection functions which extract hidden
--   features, i.e. all features which can be constructed on the basis of
--   observations and potential labels (constraints) corresponding to
--   individual words.
--   
--   You can mix functions defined here with the selection functions from
--   the <a>Data.CRF.Chain1.Constrained.Feature.Present</a> module.
module Data.CRF.Chain1.Constrained.Feature.Hidden

-- | Hidden <a>Feature</a>s of all types which can be constructed on the
--   basis of the dataset. The default set of potential interpretations is
--   used for all unknown words.
hiddenFeats :: AVec Lb -> [(Xs, b)] -> [Feature]

-- | Hidden <a>OFeature</a>s which can be constructed based on the dataset.
--   The default set of potential interpretations is used for all unknown
--   words.
hiddenOFeats :: AVec Lb -> [(Xs, b)] -> [Feature]

-- | Hidden <a>TFeature</a>s which can be constructed based on the dataset.
--   The default set of potential interpretations is used for all unknown
--   words.
hiddenTFeats :: AVec Lb -> [(Xs, b)] -> [Feature]

-- | Hidden <a>SFeature</a>s which can be constructed based on the dataset.
--   The default set of potential interpretations is used for all unknown
--   words.
hiddenSFeats :: AVec Lb -> [(Xs, b)] -> [Feature]


-- | Internal implementation of the CRF model.
module Data.CRF.Chain1.Constrained.Model

-- | A feature index. To every model feature a unique index is assigned. It
--   is equall to -1 if there is no corresponding feature in the model.
newtype FeatIx
FeatIx :: Int -> FeatIx
unFeatIx :: FeatIx -> Int

-- | The model is actually a map from features to their respective
--   potentials, but for the sake of efficiency the internal representation
--   is more complex.
data Model
Model :: Vector Double -> Map Feature FeatIx -> AVec Lb -> Vector FeatIx -> Vector (AVec LbIx) -> Vector (AVec LbIx) -> Vector (AVec LbIx) -> Model

-- | Value (potential) of the model for feature index.
values :: Model -> Vector Double

-- | A map from features to feature indices
ixMap :: Model -> Map Feature FeatIx

-- | A default set of labels. It is used on sentence positions for which no
--   constraints are assigned.
r0 :: Model -> AVec Lb

-- | Singular feature index for the given label. Index is equall to -1 if
--   feature is not present in the model.
sgIxsV :: Model -> Vector FeatIx

-- | Set of labels for the given observation which, together with the
--   observation, constitute an observation feature of the model.
obIxsV :: Model -> Vector (AVec LbIx)

-- | Set of ,,previous'' labels for the value of the ,,current'' label.
--   Both labels constitute a transition feature present in the the model.
prevIxsV :: Model -> Vector (AVec LbIx)

-- | Set of ,,next'' labels for the value of the ,,current'' label. Both
--   labels constitute a transition feature present in the the model.
nextIxsV :: Model -> Vector (AVec LbIx)

-- | Construct the model from the list of features. All parameters will be
--   set to 0. There can be repetitions in the input list. We assume that
--   the set of labels is of the {0, 1, .. <tt>lbMax</tt>} form and,
--   similarly, the set of observations is of the {0, 1, .. <tt>obMax</tt>}
--   form.
mkModel :: Ob -> Lb -> [Feature] -> Model

-- | Model potential defined for the given feature interpreted as a number
--   in logarithmic domain.
valueL :: Model -> FeatIx -> LogFloat

-- | Determine index for the given feature.
featToIx :: Model -> Feature -> Maybe FeatIx

-- | Determine index for the given feature. Throw error when the feature is
--   not a member of the model.
featToJustIx :: Model -> Feature -> FeatIx

-- | Determine index for the given feature and return it as an integer.
--   Throw error when the feature is not a member of the model.
featToJustInt :: Model -> Feature -> Int

-- | Potential value (in log domain) of the singular feature with the given
--   label. The value defaults to 1 (0 in log domain) when the feature is
--   not a member of the model.
sgValue :: Model -> Lb -> LogFloat

-- | List of labels which can be located on the first position of a
--   sentence together with feature indices determined by them.
sgIxs :: Model -> [LbIx]

-- | List of labels which constitute a valid feature in combination with
--   the given observation accompanied by feature indices determined by
--   these labels.
obIxs :: Model -> Ob -> AVec LbIx

-- | List of ,,next'' labels which constitute a valid feature in
--   combination with the ,,current'' label accompanied by feature indices
--   determined by ,,next'' labels.
nextIxs :: Model -> Lb -> AVec LbIx

-- | List of ,,previous'' labels which constitute a valid feature in
--   combination with the ,,current'' label accompanied by feature indices
--   determined by ,,previous'' labels.
prevIxs :: Model -> Lb -> AVec LbIx
instance Binary Model
instance Vector Vector FeatIx
instance MVector MVector FeatIx
instance Unbox FeatIx
instance Show FeatIx
instance Eq FeatIx
instance Ord FeatIx
instance Binary FeatIx

module Data.CRF.Chain1.Constrained.Inference

-- | Find the most probable label sequence (with probabilities of
--   individual lables determined with respect to marginal distributions)
--   satisfying the constraints imposed over label values.
tag :: Model -> Xs -> [Lb]

-- | Get (at most) k best tags for each word and return them in descending
--   order. TODO: Tagging with respect to marginal distributions might not
--   be the best idea. Think of some more elegant method.
tagK :: Int -> Model -> Xs -> [[(Lb, LogFloat)]]

-- | Tag probabilities with respect to marginal distributions.
marginals :: Model -> Xs -> [[(Lb, LogFloat)]]

-- | Compute the accuracy of the model with respect to the labeled dataset.
accuracy :: Model -> [(Xs, Ys)] -> Double

-- | A list of features (represented by feature indices) defined within the
--   context of the sentence accompanied by expected probabilities
--   determined on the basis of the model.
--   
--   One feature can occur multiple times in the output list.
expectedFeaturesIn :: Model -> Xs -> [(FeatIx, LogFloat)]

-- | Normalization factor computed for the <a>Xs</a> sentence using the
--   backward computation.
zx :: Model -> Xs -> LogFloat

-- | Normalization factor computed for the <a>Xs</a> sentence using the
--   forward computation.
zx' :: Model -> Xs -> LogFloat

module Data.CRF.Chain1.Constrained.Train

-- | A conditional random field model with additional codec used for data
--   encoding.
data CRF a b
CRF :: Codec a b -> Model -> CRF a b

-- | The codec is used to transform data into internal representation,
--   where each observation and each label is represented by a unique
--   integer number.
codec :: CRF a b -> Codec a b

-- | The actual model, which is a map from <a>Feature</a>s to potentials.
model :: CRF a b -> Model

-- | Train the CRF using the stochastic gradient descent method.
--   
--   The resulting model will contain features extracted with the user
--   supplied extraction function. You can use the functions provided by
--   the <a>Data.CRF.Chain1.Constrained.Feature.Present</a> and
--   <a>Data.CRF.Chain1.Constrained.Feature.Hidden</a> modules for this
--   purpose.
--   
--   You also have to supply R0 construction method (e.g. <a>oovChosen</a>)
--   which determines the contents of the default set of labels.
train :: (Ord a, Ord b) => SgdArgs -> Bool -> ([SentL a b] -> Set b) -> (AVec Lb -> [(Xs, Ys)] -> [Feature]) -> IO [SentL a b] -> IO [SentL a b] -> IO (CRF a b)

-- | Collect labels assigned to OOV words.
oovChosen :: Ord b => [SentL a b] -> Set b

-- | Collect labels assigned to words in a dataset.
anyChosen :: Ord b => [SentL a b] -> Set b

-- | Collect interpretations (also labels assigned) of words in a dataset.
anyInterps :: Ord b => [SentL a b] -> Set b
instance (Ord a, Ord b, Binary a, Binary b) => Binary (CRF a b)


-- | The module provides first-order, linear-chain conditional random
--   fields (CRFs) with position-wide constraints over label values.
module Data.CRF.Chain1.Constrained

-- | A Word is represented by a set of observations and a set of potential
--   interpretation labels. When the set of potential labels is empty the
--   word is considered to be unknown and the default potential set is used
--   in its place.
data Word a b
Word :: Set a -> Set b -> Word a b

-- | The set of observations
obs :: Word a b -> Set a

-- | The set of potential interpretations.
lbs :: Word a b -> Set b

-- | The word is considered to be unknown when the set of potential labels
--   is empty.
unknown :: Word a b -> Bool

-- | A sentence of words.
type Sent a b = [Word a b]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Prob a

-- | Construct the probability distribution.
mkProb :: Ord a => [(a, Double)] -> Prob a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels. We assume that every label from the distribution
--   domain is a member of the set of potential labels corresponding to the
--   word. Use the <a>mkWordL</a> smart constructor to build <a>WordL</a>.
data WordL a b

-- | Ensure, that every label from the distribution domain is a member of
--   the set of potential labels corresponding to the word.
mkWordL :: Word a b -> Prob b -> WordL a b

-- | A sentence of labeled words.
type SentL a b = [WordL a b]

-- | Determine the most probable label sequence within the context of the
--   given sentence using the model provided by the <a>CRF</a>.
tag :: (Ord a, Ord b) => CRF a b -> Sent a b -> [b]

-- | Determine the most probable label sets of the given size (at maximum)
--   for each position in the input sentence.
tagK :: (Ord a, Ord b) => Int -> CRF a b -> Sent a b -> [[b]]
