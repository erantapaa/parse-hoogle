-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | IntMap and IntSet with Enum keys/elements.
--   
@package enummapset
@version 0.5.2.1


module Data.EnumSet

-- | Wrapper for <a>IntSet</a> with <a>Enum</a> elements.
data EnumSet k

-- | Wrap <a>IntSet</a>.
intSetToEnumSet :: IntSet -> EnumSet k

-- | Unwrap <a>IntSet</a>.
enumSetToIntSet :: EnumSet k -> IntSet
(\\) :: EnumSet k -> EnumSet k -> EnumSet k
null :: EnumSet k -> Bool
size :: EnumSet k -> Int
member :: Enum k => k -> EnumSet k -> Bool
notMember :: Enum k => k -> EnumSet k -> Bool
lookupLT :: Enum k => k -> EnumSet k -> Maybe k
lookupGT :: Enum k => k -> EnumSet k -> Maybe k
lookupLE :: Enum k => k -> EnumSet k -> Maybe k
lookupGE :: Enum k => k -> EnumSet k -> Maybe k
isSubsetOf :: EnumSet k -> EnumSet k -> Bool
isProperSubsetOf :: EnumSet k -> EnumSet k -> Bool
empty :: EnumSet k
singleton :: Enum k => k -> EnumSet k
insert :: Enum k => k -> EnumSet k -> EnumSet k
delete :: Enum k => k -> EnumSet k -> EnumSet k
union :: EnumSet k -> EnumSet k -> EnumSet k
unions :: [EnumSet k] -> EnumSet k
difference :: EnumSet k -> EnumSet k -> EnumSet k
intersection :: EnumSet k -> EnumSet k -> EnumSet k
filter :: Enum k => (k -> Bool) -> EnumSet k -> EnumSet k
partition :: Enum k => (k -> Bool) -> EnumSet k -> (EnumSet k, EnumSet k)
split :: Enum k => k -> EnumSet k -> (EnumSet k, EnumSet k)
splitMember :: Enum k => k -> EnumSet k -> (EnumSet k, Bool, EnumSet k)
map :: Enum k => (k -> k) -> EnumSet k -> EnumSet k
foldr :: Enum k => (k -> b -> b) -> b -> EnumSet k -> b
foldl :: Enum k => (a -> k -> a) -> a -> EnumSet k -> a
foldr' :: Enum k => (k -> b -> b) -> b -> EnumSet k -> b
foldl' :: Enum k => (a -> k -> a) -> a -> EnumSet k -> a
fold :: Enum k => (k -> b -> b) -> b -> EnumSet k -> b
findMin :: Enum k => EnumSet k -> k
findMax :: Enum k => EnumSet k -> k
deleteMin :: EnumSet k -> EnumSet k
deleteMax :: EnumSet k -> EnumSet k
deleteFindMin :: Enum k => EnumSet k -> (k, EnumSet k)
deleteFindMax :: Enum k => EnumSet k -> (k, EnumSet k)
maxView :: Enum k => EnumSet k -> Maybe (k, EnumSet k)
minView :: Enum k => EnumSet k -> Maybe (k, EnumSet k)
elems :: Enum k => EnumSet k -> [k]
toList :: Enum k => EnumSet k -> [k]
fromList :: Enum k => [k] -> EnumSet k
toAscList :: Enum k => EnumSet k -> [k]
toDescList :: Enum k => EnumSet k -> [k]
fromAscList :: Enum k => [k] -> EnumSet k
fromDistinctAscList :: Enum k => [k] -> EnumSet k
instance Typeable EnumSet
instance Eq (EnumSet k)
instance Monoid (EnumSet k)
instance Ord (EnumSet k)
instance NFData (EnumSet k)
instance (Enum k, Read k) => Read (EnumSet k)
instance (Enum k, Show k) => Show (EnumSet k)


module Data.EnumMap.Strict

-- | Wrapper for <a>IntMap</a> with <a>Enum</a> keys.
data EnumMap k a

-- | Wrap <a>IntMap</a>.
intMapToEnumMap :: IntMap a -> EnumMap k a

-- | Unwrap <a>IntMap</a>.
enumMapToIntMap :: EnumMap k a -> IntMap a
(!) :: Enum k => EnumMap k a -> k -> a
(\\) :: EnumMap k a -> EnumMap k b -> EnumMap k a
null :: EnumMap k a -> Bool
size :: EnumMap k a -> Int
member :: Enum k => k -> EnumMap k a -> Bool
notMember :: Enum k => k -> EnumMap k a -> Bool
lookup :: Enum k => k -> EnumMap k a -> Maybe a
findWithDefault :: Enum k => a -> k -> EnumMap k a -> a
lookupLT :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupGT :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupLE :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupGE :: Enum k => k -> EnumMap k a -> Maybe (k, a)
empty :: EnumMap k a
singleton :: Enum k => k -> a -> EnumMap k a
insert :: Enum k => k -> a -> EnumMap k a -> EnumMap k a
insertWith :: Enum k => (a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
insertWithKey :: Enum k => (k -> a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
insertLookupWithKey :: Enum k => (k -> a -> a -> a) -> k -> a -> EnumMap k a -> (Maybe a, EnumMap k a)
delete :: Enum k => k -> EnumMap k a -> EnumMap k a
adjust :: Enum k => (a -> a) -> k -> EnumMap k a -> EnumMap k a
adjustWithKey :: Enum k => (k -> a -> a) -> k -> EnumMap k a -> EnumMap k a
update :: Enum k => (a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
updateWithKey :: Enum k => (k -> a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
updateLookupWithKey :: Enum k => (k -> a -> Maybe a) -> k -> EnumMap k a -> (Maybe a, EnumMap k a)
alter :: Enum k => (Maybe a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
union :: EnumMap k a -> EnumMap k a -> EnumMap k a
unionWith :: (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
unionWithKey :: Enum k => (k -> a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
unions :: [EnumMap k a] -> EnumMap k a
unionsWith :: (a -> a -> a) -> [EnumMap k a] -> EnumMap k a
difference :: EnumMap k a -> EnumMap k b -> EnumMap k a
differenceWith :: (a -> b -> Maybe a) -> EnumMap k a -> EnumMap k b -> EnumMap k a
differenceWithKey :: Enum k => (k -> a -> b -> Maybe a) -> EnumMap k a -> EnumMap k b -> EnumMap k a
intersection :: EnumMap k a -> EnumMap k b -> EnumMap k a
intersectionWith :: (a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
intersectionWithKey :: Enum k => (k -> a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
mergeWithKey :: Enum k => (k -> a -> b -> Maybe c) -> (EnumMap k a -> EnumMap k c) -> (EnumMap k b -> EnumMap k c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
map :: (a -> b) -> EnumMap k a -> EnumMap k b
mapWithKey :: Enum k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
traverseWithKey :: (Applicative t, Enum k) => (k -> a -> t b) -> EnumMap k a -> t (EnumMap k b)
mapAccum :: (a -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapAccumWithKey :: Enum k => (a -> k -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapAccumRWithKey :: Enum k => (a -> k -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapKeys :: Enum k => (k -> k) -> EnumMap k a -> EnumMap k a
mapKeysWith :: Enum k => (a -> a -> a) -> (k -> k) -> EnumMap k a -> EnumMap k a
mapKeysMonotonic :: Enum k => (k -> k) -> EnumMap k a -> EnumMap k a
foldr :: (a -> b -> b) -> b -> EnumMap k a -> b
foldl :: (a -> b -> a) -> a -> EnumMap k b -> a
foldrWithKey :: Enum k => (k -> a -> b -> b) -> b -> EnumMap k a -> b
foldlWithKey :: Enum k => (a -> k -> b -> a) -> a -> EnumMap k b -> a
foldr' :: (a -> b -> b) -> b -> EnumMap k a -> b
foldl' :: (a -> b -> a) -> a -> EnumMap k b -> a
foldrWithKey' :: Enum k => (k -> a -> b -> b) -> b -> EnumMap k a -> b
foldlWithKey' :: Enum k => (a -> k -> b -> a) -> a -> EnumMap k b -> a
elems :: EnumMap k a -> [a]
keys :: Enum k => EnumMap k a -> [k]
assocs :: Enum k => EnumMap k a -> [(k, a)]
keysSet :: Enum k => EnumMap k a -> EnumSet k
fromSet :: Enum k => (k -> a) -> EnumSet k -> EnumMap k a
toList :: Enum k => EnumMap k a -> [(k, a)]
fromList :: Enum k => [(k, a)] -> EnumMap k a
fromListWith :: Enum k => (a -> a -> a) -> [(k, a)] -> EnumMap k a
fromListWithKey :: Enum k => (k -> a -> a -> a) -> [(k, a)] -> EnumMap k a
toAscList :: Enum k => EnumMap k a -> [(k, a)]
toDescList :: Enum k => EnumMap k a -> [(k, a)]
fromAscList :: Enum k => [(k, a)] -> EnumMap k a
fromAscListWith :: Enum k => (a -> a -> a) -> [(k, a)] -> EnumMap k a
fromAscListWithKey :: Enum k => (k -> a -> a -> a) -> [(k, a)] -> EnumMap k a
fromDistinctAscList :: Enum k => [(k, a)] -> EnumMap k a
filter :: (a -> Bool) -> EnumMap k a -> EnumMap k a
filterWithKey :: Enum k => (k -> a -> Bool) -> EnumMap k a -> EnumMap k a
partition :: (a -> Bool) -> EnumMap k a -> (EnumMap k a, EnumMap k a)
partitionWithKey :: Enum k => (k -> a -> Bool) -> EnumMap k a -> (EnumMap k a, EnumMap k a)
mapMaybe :: (a -> Maybe b) -> EnumMap k a -> EnumMap k b
mapMaybeWithKey :: Enum k => (k -> a -> Maybe b) -> EnumMap k a -> EnumMap k b
mapEither :: (a -> Either b c) -> EnumMap k a -> (EnumMap k b, EnumMap k c)
mapEitherWithKey :: Enum k => (k -> a -> Either b c) -> EnumMap k a -> (EnumMap k b, EnumMap k c)
split :: Enum k => k -> EnumMap k a -> (EnumMap k a, EnumMap k a)
splitLookup :: Enum k => k -> EnumMap k a -> (EnumMap k a, Maybe a, EnumMap k a)
isSubmapOf :: Eq a => EnumMap k a -> EnumMap k a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> EnumMap k a -> EnumMap k b -> Bool
isProperSubmapOf :: Eq a => EnumMap k a -> EnumMap k a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> EnumMap k a -> EnumMap k b -> Bool
findMin :: Enum k => EnumMap k a -> (k, a)
findMax :: Enum k => EnumMap k a -> (k, a)
deleteMin :: EnumMap k a -> EnumMap k a
deleteMax :: EnumMap k a -> EnumMap k a
deleteFindMin :: Enum k => EnumMap k a -> ((k, a), EnumMap k a)
deleteFindMax :: Enum k => EnumMap k a -> ((k, a), EnumMap k a)
updateMin :: (a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMax :: (a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMinWithKey :: Enum k => (k -> a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMaxWithKey :: Enum k => (k -> a -> Maybe a) -> EnumMap k a -> EnumMap k a
minView :: EnumMap k a -> Maybe (a, EnumMap k a)
maxView :: EnumMap k a -> Maybe (a, EnumMap k a)
minViewWithKey :: Enum k => EnumMap k a -> Maybe ((k, a), EnumMap k a)
maxViewWithKey :: Enum k => EnumMap k a -> Maybe ((k, a), EnumMap k a)


module Data.EnumMap.Lazy

-- | Wrapper for <a>IntMap</a> with <a>Enum</a> keys.
data EnumMap k a

-- | Wrap <a>IntMap</a>.
intMapToEnumMap :: IntMap a -> EnumMap k a

-- | Unwrap <a>IntMap</a>.
enumMapToIntMap :: EnumMap k a -> IntMap a
(!) :: Enum k => EnumMap k a -> k -> a
(\\) :: EnumMap k a -> EnumMap k b -> EnumMap k a
null :: EnumMap k a -> Bool
size :: EnumMap k a -> Int
member :: Enum k => k -> EnumMap k a -> Bool
notMember :: Enum k => k -> EnumMap k a -> Bool
lookup :: Enum k => k -> EnumMap k a -> Maybe a
findWithDefault :: Enum k => a -> k -> EnumMap k a -> a
lookupLT :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupGT :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupLE :: Enum k => k -> EnumMap k a -> Maybe (k, a)
lookupGE :: Enum k => k -> EnumMap k a -> Maybe (k, a)
empty :: EnumMap k a
singleton :: Enum k => k -> a -> EnumMap k a
insert :: Enum k => k -> a -> EnumMap k a -> EnumMap k a
insertWith :: Enum k => (a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
insertWithKey :: Enum k => (k -> a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
insertLookupWithKey :: Enum k => (k -> a -> a -> a) -> k -> a -> EnumMap k a -> (Maybe a, EnumMap k a)
delete :: Enum k => k -> EnumMap k a -> EnumMap k a
adjust :: Enum k => (a -> a) -> k -> EnumMap k a -> EnumMap k a
adjustWithKey :: Enum k => (k -> a -> a) -> k -> EnumMap k a -> EnumMap k a
update :: Enum k => (a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
updateWithKey :: Enum k => (k -> a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
updateLookupWithKey :: Enum k => (k -> a -> Maybe a) -> k -> EnumMap k a -> (Maybe a, EnumMap k a)
alter :: Enum k => (Maybe a -> Maybe a) -> k -> EnumMap k a -> EnumMap k a
union :: EnumMap k a -> EnumMap k a -> EnumMap k a
unionWith :: (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
unionWithKey :: Enum k => (k -> a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
unions :: [EnumMap k a] -> EnumMap k a
unionsWith :: (a -> a -> a) -> [EnumMap k a] -> EnumMap k a
difference :: EnumMap k a -> EnumMap k b -> EnumMap k a
differenceWith :: (a -> b -> Maybe a) -> EnumMap k a -> EnumMap k b -> EnumMap k a
differenceWithKey :: Enum k => (k -> a -> b -> Maybe a) -> EnumMap k a -> EnumMap k b -> EnumMap k a
intersection :: EnumMap k a -> EnumMap k b -> EnumMap k a
intersectionWith :: (a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
intersectionWithKey :: Enum k => (k -> a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
mergeWithKey :: Enum k => (k -> a -> b -> Maybe c) -> (EnumMap k a -> EnumMap k c) -> (EnumMap k b -> EnumMap k c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
map :: (a -> b) -> EnumMap k a -> EnumMap k b
mapWithKey :: Enum k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
traverseWithKey :: (Applicative t, Enum k) => (k -> a -> t b) -> EnumMap k a -> t (EnumMap k b)
mapAccum :: (a -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapAccumWithKey :: Enum k => (a -> k -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapAccumRWithKey :: Enum k => (a -> k -> b -> (a, c)) -> a -> EnumMap k b -> (a, EnumMap k c)
mapKeys :: Enum k => (k -> k) -> EnumMap k a -> EnumMap k a
mapKeysWith :: Enum k => (a -> a -> a) -> (k -> k) -> EnumMap k a -> EnumMap k a
mapKeysMonotonic :: Enum k => (k -> k) -> EnumMap k a -> EnumMap k a
foldr :: (a -> b -> b) -> b -> EnumMap k a -> b
foldl :: (a -> b -> a) -> a -> EnumMap k b -> a
foldrWithKey :: Enum k => (k -> a -> b -> b) -> b -> EnumMap k a -> b
foldlWithKey :: Enum k => (a -> k -> b -> a) -> a -> EnumMap k b -> a
foldr' :: (a -> b -> b) -> b -> EnumMap k a -> b
foldl' :: (a -> b -> a) -> a -> EnumMap k b -> a
foldrWithKey' :: Enum k => (k -> a -> b -> b) -> b -> EnumMap k a -> b
foldlWithKey' :: Enum k => (a -> k -> b -> a) -> a -> EnumMap k b -> a
elems :: EnumMap k a -> [a]
keys :: Enum k => EnumMap k a -> [k]
assocs :: Enum k => EnumMap k a -> [(k, a)]
keysSet :: Enum k => EnumMap k a -> EnumSet k
fromSet :: Enum k => (k -> a) -> EnumSet k -> EnumMap k a
toList :: Enum k => EnumMap k a -> [(k, a)]
fromList :: Enum k => [(k, a)] -> EnumMap k a
fromListWith :: Enum k => (a -> a -> a) -> [(k, a)] -> EnumMap k a
fromListWithKey :: Enum k => (k -> a -> a -> a) -> [(k, a)] -> EnumMap k a
toAscList :: Enum k => EnumMap k a -> [(k, a)]
toDescList :: Enum k => EnumMap k a -> [(k, a)]
fromAscList :: Enum k => [(k, a)] -> EnumMap k a
fromAscListWith :: Enum k => (a -> a -> a) -> [(k, a)] -> EnumMap k a
fromAscListWithKey :: Enum k => (k -> a -> a -> a) -> [(k, a)] -> EnumMap k a
fromDistinctAscList :: Enum k => [(k, a)] -> EnumMap k a
filter :: (a -> Bool) -> EnumMap k a -> EnumMap k a
filterWithKey :: Enum k => (k -> a -> Bool) -> EnumMap k a -> EnumMap k a
partition :: (a -> Bool) -> EnumMap k a -> (EnumMap k a, EnumMap k a)
partitionWithKey :: Enum k => (k -> a -> Bool) -> EnumMap k a -> (EnumMap k a, EnumMap k a)
mapMaybe :: (a -> Maybe b) -> EnumMap k a -> EnumMap k b
mapMaybeWithKey :: Enum k => (k -> a -> Maybe b) -> EnumMap k a -> EnumMap k b
mapEither :: (a -> Either b c) -> EnumMap k a -> (EnumMap k b, EnumMap k c)
mapEitherWithKey :: Enum k => (k -> a -> Either b c) -> EnumMap k a -> (EnumMap k b, EnumMap k c)
split :: Enum k => k -> EnumMap k a -> (EnumMap k a, EnumMap k a)
splitLookup :: Enum k => k -> EnumMap k a -> (EnumMap k a, Maybe a, EnumMap k a)
isSubmapOf :: Eq a => EnumMap k a -> EnumMap k a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> EnumMap k a -> EnumMap k b -> Bool
isProperSubmapOf :: Eq a => EnumMap k a -> EnumMap k a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> EnumMap k a -> EnumMap k b -> Bool
findMin :: Enum k => EnumMap k a -> (k, a)
findMax :: Enum k => EnumMap k a -> (k, a)
deleteMin :: EnumMap k a -> EnumMap k a
deleteMax :: EnumMap k a -> EnumMap k a
deleteFindMin :: Enum k => EnumMap k a -> ((k, a), EnumMap k a)
deleteFindMax :: Enum k => EnumMap k a -> ((k, a), EnumMap k a)
updateMin :: (a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMax :: (a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMinWithKey :: Enum k => (k -> a -> Maybe a) -> EnumMap k a -> EnumMap k a
updateMaxWithKey :: Enum k => (k -> a -> Maybe a) -> EnumMap k a -> EnumMap k a
minView :: EnumMap k a -> Maybe (a, EnumMap k a)
maxView :: EnumMap k a -> Maybe (a, EnumMap k a)
minViewWithKey :: Enum k => EnumMap k a -> Maybe ((k, a), EnumMap k a)
maxViewWithKey :: Enum k => EnumMap k a -> Maybe ((k, a), EnumMap k a)


module Data.EnumMap
insertWith' :: Enum k => (a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
insertWithKey' :: Enum k => (k -> a -> a -> a) -> k -> a -> EnumMap k a -> EnumMap k a
fold :: (a -> b -> b) -> b -> EnumMap k a -> b
foldWithKey :: Enum k => (k -> a -> b -> b) -> b -> EnumMap k a -> b
