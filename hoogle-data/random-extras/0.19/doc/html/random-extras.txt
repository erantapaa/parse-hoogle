-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Additional functions for random values.
--   
--   Additional functions for random values, based on random-fu. Inspired
--   by random-shuffle.
@package random-extras
@version 0.19


-- | Additional monadic random functions, based on random-fu.
module Data.Random.Extras

-- | Shuffle a list randomly. The method is based on Oleg Kiselyov's
--   <i>perfect shuffle</i>
--   <a>http://okmij.org/ftp/Haskell/perfect-shuffle.txt</a>, but much
--   simpler because it uses existing data structures. The efficiency of
--   both methods should be comparable.
--   
--   <i>Complexity:</i> O(n * log n), where <i>n</i> is the length of the
--   input list.
shuffle :: [a] -> RVar [a]

-- | Shuffle a sequence randomly. This is being used by <a>shuffle</a>, so
--   it logically uses the same method.
--   
--   <i>Complexity:</i> O(n * log n), where <i>n</i> is the length of the
--   input sequence.
shuffleSeq :: Seq a -> RVar [a]

-- | Take a random sample from a list.
--   
--   <i>Complexity:</i> O(n + m * log n), where <i>n</i> is the length of
--   the input list and <i>m</i> is the sample size.
sample :: Int -> [a] -> RVar [a]

-- | Take a random sample from a sequence.
--   
--   <i>Complexity:</i> O(m * log n), where <i>n</i> is the length of the
--   input sequence and <i>m</i> is the sample size.
sampleSeq :: Int -> Seq a -> RVar [a]

-- | Randomly choose and extract an element from a list.
--   
--   <i>Complexity:</i> O(n), where <i>n</i> is the length of the input
--   list.
choiceExtract :: [a] -> Maybe (RVar ([a], a))

-- | Randomly choose and extract an element from a sequence.
--   
--   <i>Complexity:</i> O(log n), where <i>n</i> is the length of the input
--   sequence.
choiceExtractSeq :: Seq a -> Maybe (RVar (Seq a, a))

-- | Select a random element from a list.
--   
--   <i>Partial function:</i> This function is only defined on non-empty
--   lists.
--   
--   <i>Complexity:</i> O(n), where <i>n</i> is the length of the input
--   list.
choice :: [a] -> RVar a

-- | Safely select a random element from a list.
--   
--   <i>Complexity:</i> O(n), where <i>n</i> is the length of the input
--   list.
safeChoice :: [a] -> Maybe (RVar a)

-- | Select a random element from a list, traversing the list only once.
--   
--   <i>Partial function:</i> This function is only defined on non-empty
--   lists with a length below (<a>maxBound</a> + 1 :: Int).
--   
--   <i>Complexity:</i> O(n), where <i>n</i> is the length of the input
--   list.
iterativeChoice :: [a] -> RVar a

-- | Select a random element from a sequence.
--   
--   <i>Partial function:</i> This function is only defined on non-empty
--   sequences.
--   
--   <i>Complexity:</i> O(log n), where <i>n</i> is the length of the input
--   sequence.
choiceSeq :: Seq a -> RVar a

-- | Safely select a random element from a sequence.
--   
--   <i>Complexity:</i> O(log n), where <i>n</i> is the length of the input
--   sequence.
safeChoiceSeq :: Seq a -> Maybe (RVar a)

-- | Select a random element from an array.
--   
--   <i>Complexity:</i> O(1).
choiceArray :: (IArray arr a, Ix i, Distribution Uniform i) => arr i a -> RVar a

-- | A stream of random elements from a list.
--   
--   <i>Partial function:</i> This function is only defined on non-empty
--   lists.
--   
--   <i>Complexity:</i> O(n) base and O(1) per element.
choices :: Int -> [a] -> RVar [a]

-- | Safely get a stream of random elements from a list.
--   
--   <i>Complexity:</i> O(n) base and O(1) per element, where <i>n</i> is
--   the length of the input list.
safeChoices :: Int -> [a] -> Maybe (RVar [a])

-- | A stream of random elements from an array.
--   
--   <i>Complexity:</i> O(1) per element.
choicesArray :: (IArray arr a, Ix i, Distribution Uniform i) => Int -> arr i a -> RVar [a]


-- | Functions for splitting a deck of cards like game players.
--   
--   Decks are represented by <a>Seq</a>s, because these efficiently
--   support the required operations.
--   
--   <ul>
--   <li><i>See:</i> Bayer, Diaconis <i>Trailing the Dovetail Shuffle to
--   its Lair</i>
--   <a>http://projecteuclid.org/euclid.aoap/1177005705</a></li>
--   </ul>
module Data.Random.Dovetail

-- | Split a deck into two <i>roughly equal</i> halves.
splitDeck :: Seq a -> RVar (Seq a, Seq a)

-- | Split a deck into <i>n</i> <i>roughly equal</i> parts.
generalizedSplitDeck :: Int -> Seq a -> RVar [Seq a]

-- | Riffle two halves of a deck into one deck.
riffleDecks :: Seq a -> Seq a -> RVar (Seq a)

-- | Riffle <i>n</i> parts into one deck.
generalizedRiffleDecks :: [Seq a] -> RVar (Seq a)

-- | Perform an inverse riffle, i.e. letting the cards from a deck drop
--   randomly into two heaps.
inverseRiffleDecks :: Seq a -> RVar (Seq a, Seq a)

-- | Perform an inverse riffle, i.e. letting the cards from a deck drop
--   randomly into <i>n</i> heaps.
generalizedInverseRiffleDecks :: Int -> Seq a -> RVar (Seq (Seq a))

-- | Dovetail shuffle a deck, i.e. split the deck with splitDeck and riffle
--   the resulting halves with <a>riffleDecks</a>.
dovetail :: Seq a -> RVar (Seq a)

-- | Dovetail shuffle a deck (generalized), i.e. split the deck into
--   <i>n</i> parts and riffle them back together.
generalizedDovetail :: Int -> Seq a -> RVar (Seq a)

-- | Dovetail shuffle a deck repeatedly for <i>n</i> times.
dovetails :: Int -> Seq a -> RVar (Seq a)

-- | Dovetail shuffle a deck repeatedly for <i>shuffles</i> times, using
--   <i>parts</i> parts.
--   
--   <i>Invocation:</i> <tt>generalizedDovetails shuffles parts deck</tt>
generalizedDovetails :: Int -> Int -> Seq a -> RVar (Seq a)

-- | Perform an inverse dovetail shuffle, i.e. letting the cards from a
--   deck drop randomly into two heaps and then stack these heaps.
inverseDovetail :: Seq a -> RVar (Seq a)

-- | Perform a generalized inverse dovetail shuffle, i.e. letting the cards
--   from a deck drop randomly into <i>n</i> heaps and then stack them back
--   together.
generalizedInverseDovetail :: Int -> Seq a -> RVar (Seq a)

-- | Perform a <i>face up, face down</i> shuffle, which is like a dovetail
--   shuffle where the lower of the two halves is reversed.
faceUpFaceDown :: Seq a -> RVar (Seq a)


-- | An uniform distribution that excludes the first parameter.
module Data.Random.Distribution.Uniform.Exclusive

-- | A class for excluding discrete values. No change for floating point
--   values.
--   
--   <i>Note:</i> <a>Uniform</a> is exclusive on the second argument for
--   floating point values, so <a>Excludable</a> does not need to exclude
--   anything for them.
class Excludable a
smaller :: Excludable a => a -> a
bigger :: Excludable a => a -> a

-- | A uniform distribution that excludes the first parameter , but
--   includes the second.
--   
--   <i>Note:</i> <a>Uniform</a> behaves the opposite way for floating
--   point values.
uniformExclusiveDist :: (Excludable a, Ord a) => a -> a -> Uniform a

-- | A uniformly distributed random value that excludes the first
--   parameter.
uniformExclusive :: (Distribution Uniform a, Excludable a, Ord a) => a -> a -> RVar a
instance HasResolution r => Excludable (Fixed r)
instance Excludable Bool
instance Excludable Double
instance Excludable Float
instance Excludable Integer
instance Excludable Word64
instance Excludable Word32
instance Excludable Word16
instance Excludable Word8
instance Excludable Word
instance Excludable Int64
instance Excludable Int32
instance Excludable Int16
instance Excludable Int8
instance Excludable Int


-- | Functions for shuffling elements according to weights.
--   
--   Definitions:
--   
--   <ul>
--   <li><i>Weight</i> A number above <i>0</i> denoting how likely it is
--   for an element to end up in the first position.</li>
--   <li><i>Probability</i> A weight normalised into the <i>(0,1]</i>
--   range.</li>
--   <li><i>Weighted list</i> A list of pairs <tt>(w, a)</tt>, where
--   <tt>w</tt> is the weight of element <tt>a</tt>. The probability of an
--   element getting into the first position is equal by its weight divided
--   by the sum of all weights, and the probability of getting into a
--   position other than the first is equal to the probability of getting
--   in the first position when all elements in prior positions have been
--   removed from the weighted list.</li>
--   <li><i>CDF Map</i> A map of <i>summed weights</i> to elements. For
--   example, a weighted list <tt>[(0.2, <tt>a</tt>), (0.6, <tt>b</tt>),
--   (0.2, <tt>c</tt>)]</tt> corresponds to a CDF map of <tt>[(0.2,
--   <tt>a</tt>), (0.8, <tt>b</tt>), (1.0, <tt>c</tt>)]</tt> (as a
--   <tt>Map</tt>). The weights are summed from left to right.</li>
--   </ul>
module Data.Random.Shuffle.Weighted

-- | Randomly shuffle a CDF map according to its weights.
weightedShuffleCDF :: (Num w, Ord w, Distribution Uniform w, Excludable w) => Map w a -> RVar [a]

-- | Randomly shuffle a weighted list according to its weights.
weightedShuffle :: (Num w, Ord w, Distribution Uniform w, Excludable w) => [(w, a)] -> RVar [a]

-- | Randomly draw <i>n</i> elements from a CDF map according to its
--   weights.
weightedSampleCDF :: (Num w, Ord w, Distribution Uniform w, Excludable w) => Int -> Map w a -> RVar [a]

-- | Randomly draw <i>n</i> elements from a weighted list according to its
--   weights.
weightedSample :: (Num w, Ord w, Distribution Uniform w, Excludable w) => Int -> [(w, a)] -> RVar [a]

-- | Randomly extract an element from a CDF map according to its weights.
--   The element is removed and the resulting <a>weight gap</a> closed.
weightedChoiceExtractCDF :: (Num w, Ord w, Distribution Uniform w, Excludable w) => Map w a -> RVar (Map w a, a)

-- | Generate a CDF map from a weighted list.
cdfMapFromList :: (Num w, Eq w) => [(w, a)] -> Map w a


-- | Unsafely <a>show</a> a <a>RVar</a> by taking a random sample. Uses
--   <a>unsafePerformIO</a>.
--   
--   Contains an instance of <a>Show</a> for <a>RVar</a>.
module Data.Random.Show.Unsafe
instance Show a => Show (RVar a)
