-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible and Modular Generics for the Masses
--   
--   EMGM is a general-purpose library for datatype-generic programming.
--   
--   The design is based on the idea of modeling algebraic datatypes as
--   sum-of-product structures. Many datatypes can be modeled this way, and
--   because they all share a common structure, we can write generic
--   functions that work on this structure.
--   
--   The primary features of the library are:
--   
--   <ul>
--   <li><i>A foundation for building generic functions.</i> EMGM includes
--   a collection of datatypes (e.g. sum, product, and unit) and type
--   classes (e.g. <tt>Generic</tt> and <tt>Rep</tt>). Everything you need
--   for defining generic functions and supporting datatypes can be found
--   here.</li>
--   <li><i>Many useful generic functions.</i> These provide a wide range
--   of functionality. For example, there is <tt>crush</tt>, a
--   generalization of the foldl/foldr functions, that allows you to
--   flexibly extract the elements of a polymorphic container. Now, you can
--   do many of the operations with your container that were previously
--   only available for lists.</li>
--   <li><i>Support for standard datatypes.</i> EMGM supports standard
--   types: primitives (e.g. <tt>Int</tt> and <tt>Float</tt>),
--   <tt>Bool</tt>, lists, tuples, <tt>Maybe</tt>, etc.</li>
--   </ul>
--   
--   <i>NOTE:</i> As of version 0.4, this library does not have Template
--   Haskell for generating the representation. We are working on another
--   library for a solution to this problem.
@package emgm
@version 0.4


-- | Summary: Types and related functions for the representation used in
--   EMGM.
--   
--   EMGM uses a generic sum-of-products view of datatypes encoded into the
--   <a>Unit</a>, <tt>:+:</tt> (sum), and <tt>:*:</tt> (product). Many
--   Haskell datatypes can be represented in this way. Right-nested sums
--   replace the <tt>|</tt>, and right-nested products replace the
--   arguments to a constructor. Units replace constructors with no
--   arguments.
--   
--   Since constructors encode more than just a list of arguments, this
--   library uses <a>ConDescr</a> to store that information. This includes
--   name, arity, record labels, fixity, and operator precedence.
--   Constructor descriptions are useful for generic operations such as
--   <a>Read</a> and <a>Show</a> and possibly others.
--   
--   Generic functions need to convert values between the Haskell datatype
--   and its structure representation. This is done using the
--   embedding-projection pair, which is simply a pair a functions for
--   translating between two types.
module Generics.EMGM.Representation

-- | Encodes a constructor with no arguments. An analogous standard Haskell
--   type is <tt>()</tt>.
data Unit

-- | The only value of type <tt>Unit</tt> (ignoring <tt>_|_</tt>).
Unit :: Unit

-- | The "sum" encodes 2 constructor alternatives. An analogous standard
--   Haskell type is <tt><a>Either</a> a b</tt>.
data (:+:) a b

-- | Left alternative
L :: a -> :+: a b

-- | Right alternative
R :: b -> :+: a b

-- | The "product" encodes 2 constructor arguments. An analogous standard
--   Haskell type is <tt>(a, b)</tt>.
data (:*:) a b

-- | A pair of arguments
(:*:) :: a -> b -> :*: a b

-- | Contains useful meta-information about the syntax used in a
--   constructor declaration.
--   
--   NOTE: It is important that the <a>ConDescr</a> value accurately
--   describe the syntax in a constructor declaration. An incorrect
--   description may lead to faulty <a>Read</a> or <a>Show</a> operation.
data ConDescr
ConDescr :: String -> Int -> Bool -> Fixity -> ConDescr

-- | Name of the constructor (without parenthesese if infix).
conName :: ConDescr -> String

-- | Number of fields.
conArity :: ConDescr -> Int

-- | Uses labeled fields (a.k.a. record syntax).
conRecord :: ConDescr -> Bool

-- | Fixity, associativity, precedence.
conFixity :: ConDescr -> Fixity

-- | Type of constructor syntax. Used in the generic functions <a>Read</a>
--   and <a>Show</a>.
data ConType

-- | Have not seen the rcon yet
UnknownC :: ConType

-- | Normal prefix-style constructor
NormalC :: ConType

-- | Infix with symbol (no record syntax)
InfixC :: String -> ConType

-- | Record-style (any fixity)
RecordC :: ConType

-- | Encodes the string label for a field in a constructor defined with
--   labeled fields (a.k.a. record syntax).
newtype LblDescr
LblDescr :: String -> LblDescr

-- | The embedding-projection pair contains two functions for converting
--   between the datatype and its representation. An <tt>EP</tt> value
--   preserves an isomorphism (ignoring <tt>_|_</tt>s) between a datatype
--   and its structure representation.
data EP d r
EP :: (d -> r) -> (r -> d) -> EP d r

-- | Embed a <tt>d</tt>atatype into its <tt>r</tt>epresentation.
from :: EP d r -> (d -> r)

-- | Project <tt>d</tt>atatype from its <tt>r</tt>epresentation.
to :: EP d r -> (r -> d)

-- | A constructor's fixity, associativity, and precedence.
data Fixity

-- | Associativity and precedence are the same as function application.
Prefix :: Fixity
Infix :: Associativity -> Prec -> Fixity

-- | A constructor's associativity.
data Associativity

-- | Declared with infixl
LeftAssoc :: Associativity

-- | Declared with infixr
RightAssoc :: Associativity

-- | Declared with infix
NonAssoc :: Associativity
type Prec = Int

-- | Get the precedence of a fixity value.
prec :: Fixity -> Prec
minPrec :: Prec

-- | Maximum precedence: 11
maxPrec :: Prec

-- | Precedence for function application: 10
appPrec :: Prec

-- | Precedence for record construction: 11
recPrec :: Prec
instance Enum Unit
instance Eq Unit
instance Ord Unit
instance Show Unit
instance (Eq a, Eq b) => Eq (a :+: b)
instance (Ord a, Ord b) => Ord (a :+: b)
instance (Read a, Read b) => Read (a :+: b)
instance (Show a, Show b) => Show (a :+: b)
instance (Eq a, Eq b) => Eq (a :*: b)
instance (Ord a, Ord b) => Ord (a :*: b)
instance (Read a, Read b) => Read (a :*: b)
instance (Show a, Show b) => Show (a :*: b)
instance Eq LblDescr
instance Ord LblDescr
instance Read LblDescr
instance Show LblDescr
instance Eq ConType
instance Show ConType
instance Eq Associativity
instance Ord Associativity
instance Read Associativity
instance Show Associativity
instance Eq Fixity
instance Ord Fixity
instance Read Fixity
instance Show Fixity
instance Eq ConDescr
instance Show ConDescr


-- | Summary: Type classes used for generic functions with <i>one</i>
--   generic argument.
--   
--   A <i>generic function</i> is defined as an instance of <a>Generic</a>,
--   <a>Generic2</a>, or <a>Generic3</a>. Each method in the class serves
--   for a case in the datatype representation
--   
--   A <i>representation dispatcher</i> simplifies the use of a generic
--   function. There must be an instance of each of the classes <a>Rep</a>,
--   <a>FRep</a>, <a>FRep2</a>, etc. (that apply) for every datatype.
module Generics.EMGM.Base

-- | This class forms the foundation for defining generic functions with a
--   single generic argument. Each method represents a type case. There are
--   cases for primitive types, structural representation types, and for
--   user-defined datatypes.
--   
--   The included modules using <tt>Generic</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.Collect</a></li>
--   <li><a>Generics.EMGM.Functions.Compare</a></li>
--   <li><a>Generics.EMGM.Functions.Constructor</a></li>
--   <li><a>Generics.EMGM.Functions.Crush</a></li>
--   <li><a>Generics.EMGM.Functions.Enum</a></li>
--   <li><a>Generics.EMGM.Functions.Read</a></li>
--   <li><a>Generics.EMGM.Functions.Show</a></li>
--   </ul>
class Generic g
rint :: Generic g => g Int
rinteger :: Generic g => g Integer
rfloat :: Generic g => g Float
rdouble :: Generic g => g Double
rchar :: Generic g => g Char
runit :: Generic g => g Unit
rsum :: Generic g => g a -> g b -> g (a :+: b)
rprod :: Generic g => g a -> g b -> g (a :*: b)
rcon :: Generic g => ConDescr -> g a -> g a
rlbl :: Generic g => LblDescr -> g a -> g a
rtype :: Generic g => EP b a -> g a -> g b

-- | This class forms the foundation for defining generic functions with
--   two generic arguments. See <a>Generic</a> for details.
--   
--   The included modules using <tt>Generic2</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.Map</a></li>
--   <li><a>Generics.EMGM.Functions.Transpose</a></li>
--   </ul>
class Generic2 g
rint2 :: Generic2 g => g Int Int
rinteger2 :: Generic2 g => g Integer Integer
rfloat2 :: Generic2 g => g Float Float
rdouble2 :: Generic2 g => g Double Double
rchar2 :: Generic2 g => g Char Char
runit2 :: Generic2 g => g Unit Unit
rsum2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1 :+: b1) (a2 :+: b2)
rprod2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1 :*: b1) (a2 :*: b2)
rcon2 :: Generic2 g => ConDescr -> g a1 a2 -> g a1 a2
rlbl2 :: Generic2 g => LblDescr -> g a1 a2 -> g a1 a2
rtype2 :: Generic2 g => EP a2 a1 -> EP b2 b1 -> g a1 b1 -> g a2 b2

-- | This class forms the foundation for defining generic functions with
--   three generic arguments. See <a>Generic</a> for details.
--   
--   The included modules using <tt>Generic3</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.UnzipWith</a></li>
--   <li><a>Generics.EMGM.Functions.ZipWith</a></li>
--   </ul>
class Generic3 g
rint3 :: Generic3 g => g Int Int Int
rinteger3 :: Generic3 g => g Integer Integer Integer
rfloat3 :: Generic3 g => g Float Float Float
rdouble3 :: Generic3 g => g Double Double Double
rchar3 :: Generic3 g => g Char Char Char
runit3 :: Generic3 g => g Unit Unit Unit
rsum3 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (a1 :+: b1) (a2 :+: b2) (a3 :+: b3)
rprod3 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (a1 :*: b1) (a2 :*: b2) (a3 :*: b3)
rcon3 :: Generic3 g => ConDescr -> g a1 a2 a3 -> g a1 a2 a3
rlbl3 :: Generic3 g => LblDescr -> g a1 a2 a3 -> g a1 a2 a3
rtype3 :: Generic3 g => EP a2 a1 -> EP b2 b1 -> EP c2 c1 -> g a1 b1 c1 -> g a2 b2 c2

-- | Representation dispatcher for monomorphic types (kind <tt>*</tt>) used
--   with <a>Generic</a>. Every structure type and supported datatype
--   should have an instance of <a>Rep</a>.
class Rep g a
rep :: Rep g a => g a

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic</a>.
class FRep g f
frep :: FRep g f => g a -> g (f a)

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic2</a>.
class FRep2 g f
frep2 :: FRep2 g f => g a b -> g (f a) (f b)

-- | Representation dispatcher for bifunctor types (kind <tt>* -&gt;
--   *</tt>) used with <a>Generic2</a>.
class BiFRep2 g f
bifrep2 :: BiFRep2 g f => g a1 b1 -> g a2 b2 -> g (f a1 a2) (f b1 b2)

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic3</a>.
class FRep3 g f
frep3 :: FRep3 g f => g a b c -> g (f a) (f b) (f c)
instance [overlap ok] (Generic g, Rep g a, Rep g b) => Rep g (a :*: b)
instance [overlap ok] (Generic g, Rep g a, Rep g b) => Rep g (a :+: b)
instance [overlap ok] Generic g => Rep g Unit
instance [overlap ok] Generic g => Rep g Char
instance [overlap ok] Generic g => Rep g Double
instance [overlap ok] Generic g => Rep g Float
instance [overlap ok] Generic g => Rep g Integer
instance [overlap ok] Generic g => Rep g Int


-- | Summary: Generic function that collects values of a specified type
--   from a generic value.
module Generics.EMGM.Functions.Collect

-- | The type of a generic function that takes a value of one type and
--   returns a collection of values of another type.
--   
--   For datatypes to work with Collect, a special instance must be given.
--   This instance is trivial to write. Given a type <tt>T</tt>, the
--   <a>Rep</a> instance looks like this:
--   
--   <pre>
--   {-# LANGUAGE OverlappingInstances #-}
--   
--   data T = ...
--   
--   instance (Alternative f) =&gt; Rep (Collect f T) T where
--     rep = Collect pure
--   </pre>
--   
--   (Note that overlapping instances are required.) This instance triggers
--   when the result type (the <tt>T</tt> in <tt>Collect f T</tt>) matches
--   the value type (the second <tt>T</tt>) contained within the argument
--   to <a>collect</a>. See the source of this module for more examples.
newtype Collect f b a
Collect :: (a -> f b) -> Collect f b a
selCollect :: Collect f b a -> a -> f b

-- | Collect values of type <tt>b</tt> from some value of type <tt>a</tt>.
--   An <a>empty</a> means no values were collected. If you expected
--   otherwise, be sure that you have an instance such as <tt><a>Rep</a>
--   (<a>Collect</a> B) B</tt> for the type <tt>B</tt> that you are
--   collecting.
--   
--   <tt>collect</tt> works by searching a datatype for values that are the
--   same type as the return type specified. Here are some examples using
--   the same value with different return types:
--   
--   <pre>
--   ghci&gt; let x = [<a>Left</a> 1, <a>Right</a> 'a', <a>Left</a> 2] :: [<a>Either</a> <a>Int</a> <a>Char</a>]
--   ghci&gt; collect x :: [<a>Int</a>]
--   [1,2]
--   ghci&gt; collect x :: [<a>Char</a>]
--   "a"
--   ghci&gt; collect x == x
--   <a>True</a>
--   </pre>
--   
--   Note that the numerical constants have been declared <a>Int</a> using
--   the type annotation. Since these natively have the type <tt><a>Num</a>
--   a =&gt; a</tt>, you may need to give explicit types. By design, there
--   is no connection that can be inferred between the return type and the
--   argument type.
--   
--   <tt>collect</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Collect</a></tt>.
collect :: (Alternative f, Rep (Collect f b) a) => a -> f b
instance [overlap ok] Alternative f => Rep (Collect f Char) Char
instance [overlap ok] Alternative f => Rep (Collect f Double) Double
instance [overlap ok] Alternative f => Rep (Collect f Float) Float
instance [overlap ok] Alternative f => Rep (Collect f Integer) Integer
instance [overlap ok] Alternative f => Rep (Collect f Int) Int
instance [overlap ok] Alternative f => Generic (Collect f b)


-- | Summary: Generic functions for comparing two values in different ways.
--   
--   The fundamental function here is <a>compare</a>, a function that
--   returns the <a>Ordering</a> of two values (less than, equal to, or
--   greater than). It uses the same lexicographical ordering as
--   <tt>deriving Ord</tt> (e.g. left alternative of a sum is less than the
--   right alternative, the first component of a product is compared first
--   while the second is only compared if the first is equal, etc.).
--   
--   All of the remaining functions are simply derived (in the most obvious
--   way) from <a>compare</a>. All of these functions are equivalent to
--   methods in the <a>Eq</a> and <a>Ord</a> type classes. The difference
--   with using this approach vs. <tt>deriving (Eq, Ord)</tt> is that you
--   can write ad-hoc cases for certain datatypes while most of the
--   functionality is handled generically.
module Generics.EMGM.Functions.Compare

-- | The type of a generic function that takes two values of the same type
--   and returns an <a>Ordering</a>.
newtype Compare a
Compare :: (a -> a -> Ordering) -> Compare a
selCompare :: Compare a -> a -> a -> Ordering

-- | Compare two values and return an <a>Ordering</a> (i.e. <tt>LT</tt>,
--   <tt>GT</tt>, or <tt>EQ</tt>). This is implemented exactly as if the
--   datatype was <tt>deriving Ord</tt>.
compare :: Rep Compare a => a -> a -> Ordering

-- | Equal to. Returns <tt>x == y</tt>.
eq :: Rep Compare a => a -> a -> Bool

-- | Not equal to. Returns <tt>x /= y</tt>.
neq :: Rep Compare a => a -> a -> Bool

-- | Less than. Returns <tt>x &lt; y</tt>.
lt :: Rep Compare a => a -> a -> Bool

-- | Less than or equal to. Returns <tt>x &lt;= y</tt>.
lteq :: Rep Compare a => a -> a -> Bool

-- | Greater than. Returns <tt>x &gt; y</tt>.
gt :: Rep Compare a => a -> a -> Bool

-- | Greater than or equal to. Returns <tt>x &gt;= y</tt>.
gteq :: Rep Compare a => a -> a -> Bool

-- | The minimum of two values.
min :: Rep Compare a => a -> a -> a

-- | The maximum of two values.
max :: Rep Compare a => a -> a -> a
instance Generic Compare


-- | Summary: Generic functions that crush a container into an iteration
--   over its elements.
--   
--   Crush is a datatype-generic operation on container types. It is a
--   generalization of folds, but it is not a catamorphism. To understand
--   how crush works, one can think of it as generating a list of all
--   elements and mapping an accumulating function over each one. With this
--   image in mind, it is evident that (unlike a catamorphism) very little
--   information can be determined about the structure of the container.
--   
--   The EMGM implementation of <a>crush</a> can not inherently know the
--   associativity of the binary operator. Consequently, associativity is
--   left as an argument, but there are variants specific to left- and
--   right-associativity for convenience.
--   
--   Many standard Haskell datatypes (e.g. <tt>[]</tt>, <tt>Data.Tree</tt>)
--   are designed such that a constructor with more than one argument (i.e.
--   a product structurally represented by <tt>(:*:)</tt>) has the element
--   on the left and any recursive points towards the right. Due to this,
--   the right-associative functions would typically produce the expected
--   values. See examples in the comments for <a>flattenr</a> and
--   <a>firstr</a>.
module Generics.EMGM.Functions.Crush

-- | The type of a generic function that takes an associativity and two
--   arguments of different types and returns a value of the type of the
--   second.
newtype Crush b a
Crush :: (Assoc -> a -> b -> b) -> Crush b a
selCrush :: Crush b a -> Assoc -> a -> b -> b

-- | Associativity of the binary operator used for <a>crush</a>
data Assoc

-- | Left-associative
AssocLeft :: Assoc

-- | Right-associative
AssocRight :: Assoc

-- | Apply a function (<tt>a -&gt; b -&gt; b</tt>) to each element
--   (<tt>a</tt>) of a container (<tt>f a</tt>) and an accumulator value
--   (<tt>b</tt>) to produce an accumulated result (<tt>b</tt>).
--   
--   This is the most general form in which you must specify the
--   associativity. You may prefer to use <a>crushr</a> or <a>crushl</a>.
crush :: FRep (Crush b) f => Assoc -> (a -> b -> b) -> b -> f a -> b

-- | A left-associative variant of <a>crush</a>.
crushl :: FRep (Crush b) f => (a -> b -> b) -> b -> f a -> b

-- | A right-associative variant of <a>crush</a>.
crushr :: FRep (Crush b) f => (a -> b -> b) -> b -> f a -> b

-- | Flatten the elements of a container into a list.
--   
--   This is the most general form in which you must specify the
--   associativity. You may prefer to use <a>flattenr</a> or
--   <a>flattenl</a>.
flatten :: FRep (Crush [a]) f => Assoc -> f a -> [a]

-- | A left-associative variant of <a>flatten</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>flattenl ls == reverse
--   ls</tt>.
flattenl :: FRep (Crush [a]) f => f a -> [a]

-- | A right-associative variant of <a>flatten</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>flattenr ls == ls</tt>.
flattenr :: FRep (Crush [a]) f => f a -> [a]

-- | Extract the first element of a container. <a>fail</a> if the container
--   is empty.
--   
--   This is the most general form in which you must specify the
--   associativity and the <a>Monad</a> instance. You may prefer to use the
--   more convenient <a>firstr</a> or <a>firstl</a>.
first :: (Monad m, FRep (Crush [a]) f) => Assoc -> f a -> m a

-- | A left-associative <a>Maybe</a> variant of <a>first</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>fromJust (firstl ls) ==
--   last ls</tt>.
firstl :: FRep (Crush [a]) f => f a -> Maybe a

-- | A right-associative <a>Maybe</a> variant of <a>first</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>fromJust (firstr ls) ==
--   head ls</tt>.
firstr :: FRep (Crush [a]) f => f a -> Maybe a

-- | Compute the conjunction of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
and :: FRep (Crush Bool) f => f Bool -> Bool

-- | Compute the disjunction of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
or :: FRep (Crush Bool) f => f Bool -> Bool

-- | Determine if any element in a container satisfies the predicate
--   <tt>p</tt>. This is a generalization of the <tt>Prelude</tt> function
--   of the same name.
any :: FRep (Crush Bool) f => (a -> Bool) -> f a -> Bool

-- | Determine if all elements in a container satisfy the predicate
--   <tt>p</tt>. This is a generalization the <tt>Prelude</tt> function of
--   the same name.
all :: FRep (Crush Bool) f => (a -> Bool) -> f a -> Bool

-- | Compute the sum of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
sum :: (Num a, FRep (Crush a) f) => f a -> a

-- | Compute the product of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
product :: (Num a, FRep (Crush a) f) => f a -> a

-- | Determine the minimum element of a container. If the container is
--   empty, return <a>Nothing</a>. This is a generalization of the
--   <tt>Prelude</tt> function of the same name.
minimum :: (Rep Compare a, FRep (Crush (Maybe a)) f) => f a -> Maybe a

-- | Determine the maximum element of a container. If the container is
--   empty, return <a>Nothing</a>. This is a generalization of the
--   <tt>Prelude</tt> function of the same name.
maximum :: (Rep Compare a, FRep (Crush (Maybe a)) f) => f a -> Maybe a

-- | Determine if an element is a member of a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
elem :: (Rep Compare a, FRep (Crush Bool) f) => a -> f a -> Bool

-- | Determine if an element is not a member of a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
notElem :: (Rep Compare a, FRep (Crush Bool) f) => a -> f a -> Bool
instance Generic (Crush b)


-- | Summary: Generic function that enumerates the values of a datatype.
--   
--   <a>enum</a> generates a list of the values of a datatypes. It will
--   produce all values of all supported datatypes (with only a few
--   exceptions [1]). For datatypes that have an infinite enumeration (e.g.
--   <a>Integer</a> and <tt>[a]</tt>), <a>enum</a> produces an infinite
--   list.
--   
--   A number of the techniques used to write <a>enum</a> came from a talk
--   by Mark Jones at the 2008 Advanced Functional Programming Summer
--   School. The authors gratefully acknowledge his contribution.
--   
--   <ul>
--   <li><i>1</i> The exceptions are <a>Float</a> and <a>Double</a>. These
--   are treated in the same way as their <a>Enum</a> instances are
--   treated. The result looks like this: <tt>[0.0,-1.0,1.0,-2.0,..]</tt>,
--   thus skipping all non-integral values. Note that these may overflow,
--   because they are unbounded.</li>
--   </ul>
module Generics.EMGM.Functions.Enum

-- | The type of a generic function that takes no arguments and returns a
--   list of some type.
newtype Enum a
Enum :: [a] -> Enum a
selEnum :: Enum a -> [a]

-- | Enumerate the values of a datatype. If the number of values is
--   infinite, the result will be an infinite list. The remaining functions
--   are derived from <a>enum</a>.
enum :: Rep Enum a => [a]

-- | Enumerate the first <tt>n</tt> values of a datatype. This is a
--   shortcut for <tt><a>genericTake</a> n (<a>enum</a>)</tt>.
enumN :: (Integral n, Rep Enum a) => n -> [a]

-- | Returns the first element of the enumeration from <a>enum</a>. This is
--   often called the neutral or empty value.
empty :: Rep Enum a => a
instance Generic Enum


-- | Summary: Generic functions that apply a transformation at every
--   location of one type in a value of a possibly different type.
--   
--   The functions <a>everywhere</a> and <a>everywhere'</a> have exactly
--   the same type, but they apply the transformation in different
--   fashions. <a>everywhere</a> uses bottom-up application while
--   <a>everywhere'</a> uses a top-down approach. This may make a
--   difference if you have recursive datatypes or use nested pattern
--   matching in the higher-order function.
--   
--   These functions are very similar to others with the same names in the
--   "Scrap Your Boilerplate" library (<tt>syb</tt> package). The SYB
--   functions use rank-2 types, while the EMGM functions use a single
--   class constraint. Compare the types of the following:
--   
--   <pre>
--   -- SYB
--   everywhere :: (forall a. Data a =&gt; a -&gt; a) -&gt; forall a. Data a =&gt; a -&gt; a
--   </pre>
--   
--   <pre>
--   -- EMGM
--   everywhere :: (Rep (Everywhere a) b) =&gt; (a -&gt; a) -&gt; b -&gt; b
--   </pre>
module Generics.EMGM.Functions.Everywhere

-- | The type of a generic function that takes a function of one type, a
--   value of another type, and returns a value of the value type.
--   
--   For datatypes to work with Everywhere, a special instance must be
--   given. This instance is trivial to write. For a non-recursive type,
--   the instance is the same as described for <a>Everywhere'</a>. For a
--   recursive type <tt>T</tt>, the <a>Rep</a> instance looks like this:
--   
--   <pre>
--   {-# LANGUAGE OverlappingInstances #-}
--   </pre>
--   
--   <pre>
--   data T a = Val a | Rec (T a)
--   </pre>
--   
--   <pre>
--   instance (<a>Rep</a> (Everywhere (T a)) (T a), <a>Rep</a> (Everywhere (T a)) a) =&gt; <a>Rep</a> (Everywhere (T a)) (T a) where
--     <a>rep</a> = Everywhere app
--       where
--         app f x =
--           case x of
--             Val v1 -&gt; f (Val (selEverywhere <a>rep</a> f v1))
--             Rec v1 -&gt; f (Rec (selEverywhere <a>rep</a> f v1))
--   </pre>
--   
--   Note the requirement of overlapping instances.
--   
--   This instance is triggered when the function type (the first <tt>T
--   a</tt> in <tt><a>Rep</a> (Everywhere (T a)) (T a)</tt>) matches some
--   value type (the second <tt>T a</tt>) contained within the argument to
--   <a>everywhere</a>.
newtype Everywhere a b
Everywhere :: ((a -> a) -> b -> b) -> Everywhere a b
selEverywhere :: Everywhere a b -> (a -> a) -> b -> b

-- | Apply a transformation <tt>a -&gt; a</tt> to values of type <tt>a</tt>
--   within the argument of type <tt>b</tt> in a bottom-up manner. Values
--   that do not have type <tt>a</tt> are passed through <a>id</a>.
--   
--   <tt>everywhere</tt> works by searching the datatype <tt>b</tt> for
--   values that are the same type as the function argument type
--   <tt>a</tt>. Here are some examples using the datatype declared in the
--   documentation for <a>Everywhere</a>.
--   
--   <pre>
--   ghci&gt; let f t = case t of { Val i -&gt; Val (i+(1::<a>Int</a>)); other -&gt; other }
--   ghci&gt; everywhere f (Val (1::<a>Int</a>))
--   Val 2
--   ghci&gt; everywhere f (Rec (Rec (Val (1::<a>Int</a>))))
--   Rec (Rec (Val 2))
--   </pre>
--   
--   <pre>
--   ghci&gt; let x = [<a>Left</a> 1, <a>Right</a> 'a', <a>Left</a> 2] :: [<a>Either</a> <a>Int</a> <a>Char</a>]
--   ghci&gt; everywhere (*(3::<a>Int</a>)) x
--   [<a>Left</a> 3,<a>Right</a> 'a',<a>Left</a> 6]
--   ghci&gt; everywhere (\x -&gt; x :: <a>Float</a>) x == x
--   <a>True</a>
--   </pre>
--   
--   Note the type annotations. Since numerical constants have the type
--   <tt><a>Num</a> a =&gt; a</tt>, you may need to give explicit types.
--   Also, the function <tt>\x -&gt; x</tt> has type <tt>a -&gt; a</tt>,
--   but we need to give it some non-polymorphic type here. By design,
--   there is no connection that can be inferred between the value type and
--   the function type.
--   
--   <tt>everywhere</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Everywhere</a></tt>.
everywhere :: Rep (Everywhere a) b => (a -> a) -> b -> b

-- | This type servers the same purpose as <a>Everywhere</a>, except that
--   <a>Rep</a> instances are designed to be top-down instead of bottom-up.
--   That means, given any type <tt>U</tt> (recursive or not), the
--   <a>Rep</a> instance looks like this:
--   
--   <pre>
--   {-# LANGUAGE OverlappingInstances #-}
--   </pre>
--   
--   <pre>
--   data U = ...
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (Everywhere' U) U where
--     <a>rep</a> = Everywhere' ($)
--   </pre>
--   
--   Note the requirement of overlapping instances.
--   
--   This instance is triggered when the function type (the first
--   <tt>U</tt> in <tt><a>Rep</a> (Everywhere U) U</tt>) matches some value
--   type (the second <tt>U</tt>) contained within the argument to
--   <a>everywhere'</a>.
newtype Everywhere' a b
Everywhere' :: ((a -> a) -> b -> b) -> Everywhere' a b
selEverywhere' :: Everywhere' a b -> (a -> a) -> b -> b

-- | Apply a transformation <tt>a -&gt; a</tt> to values of type <tt>a</tt>
--   within the argument of type <tt>b</tt> in a top-down manner. Values
--   that do not have type <tt>a</tt> are passed through <a>id</a>.
--   
--   <tt>everywhere'</tt> is the same as <a>everywhere</a> with the
--   exception of recursive datatypes. For example, compare the example
--   used in the documentation for <a>everywhere</a> with the following.
--   
--   <pre>
--   ghci&gt; let f t = case t of { Val i -&gt; Val (i+(1::<a>Int</a>)); other -&gt; other }
--   ghci&gt; everywhere' f (Val (1::<a>Int</a>))
--   Val 2
--   ghci&gt; everywhere' f (Rec (Rec (Val (1::<a>Int</a>))))
--   Rec (Rec (Val 1))
--   </pre>
--   
--   <tt>everywhere'</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Everywhere'</a></tt>.
everywhere' :: Rep (Everywhere' a) b => (a -> a) -> b -> b
instance [overlap ok] Rep (Everywhere' Char) Char
instance [overlap ok] Rep (Everywhere' Float) Float
instance [overlap ok] Rep (Everywhere' Double) Double
instance [overlap ok] Rep (Everywhere' Integer) Integer
instance [overlap ok] Rep (Everywhere' Int) Int
instance [overlap ok] Generic (Everywhere' a)
instance [overlap ok] Rep (Everywhere Char) Char
instance [overlap ok] Rep (Everywhere Float) Float
instance [overlap ok] Rep (Everywhere Double) Double
instance [overlap ok] Rep (Everywhere Integer) Integer
instance [overlap ok] Rep (Everywhere Int) Int
instance [overlap ok] Generic (Everywhere a)


-- | Summary: Generic functions that translate values of one type into
--   values of another.
--   
--   <a>map</a> is a generic version of the <tt>Prelude</tt> <tt>map</tt>
--   function. It works on all supported container datatypes of kind <tt>*
--   -&gt; *</tt>. The <a>map</a> function is equivalent to <a>fmap</a>
--   after <tt>deriving <a>Functor</a></tt> if that were possible.
--   
--   <a>cast</a> is a generic and configurable function for converting a
--   value of one type into a value of another using instances provided by
--   the programmer.
module Generics.EMGM.Functions.Map

-- | The type of a generic function that takes a value of one type and
--   returns a value of a different type.
newtype Map a b
Map :: (a -> b) -> Map a b
selMap :: Map a b -> a -> b

-- | Apply a function to all elements of a container datatype (kind <tt>*
--   -&gt; *</tt>).
map :: FRep2 Map f => (a -> b) -> f a -> f b

-- | Replace all <tt>a</tt>-values in <tt>f a</tt> with <tt>b</tt>. Defined
--   as: <tt> replace as b = map (const b) as </tt>
replace :: FRep2 Map f => f a -> b -> f b

-- | Given a datatype <tt>F a b</tt>, <tt>bimap f g</tt> applies the
--   function <tt>f :: a -&gt; c</tt> to every <tt>a</tt>-element and the
--   function <tt>g :: b -&gt; d</tt> to every <tt>b</tt>-element. The
--   result is a value with transformed elements: <tt>F c d</tt>.
bimap :: BiFRep2 Map f => (a -> c) -> (b -> d) -> f a b -> f c d

-- | Cast a value of one type into a value of another. This is a
--   configurable function that allows you to define your own type-safe
--   conversions for a variety of types.
--   
--   <tt>cast</tt> works with instances of <tt><a>Rep</a> (<a>Map</a> i)
--   o</tt> in which you choose the input type <tt>i</tt> and the output
--   type <tt>o</tt> and implement the function of type <tt>i -&gt; o</tt>.
--   
--   Here are some examples of instances (and flags you will need or want):
--   
--   <pre>
--   {-# LANGUAGE MultiParamTypeClasses  #-}
--   {-# LANGUAGE FlexibleContexts       #-}
--   {-# LANGUAGE FlexibleInstances      #-}
--   {-# OPTIONS_GHC -fno-warn-orphans   #-}
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Int</a>) <a>Char</a> where
--     <a>rep</a> = <a>Map</a> <tt>chr</tt>
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Float</a>) <a>Double</a> where
--     <a>rep</a> = <a>Map</a> <a>realToFrac</a>
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Integer</a>) <a>Integer</a> where
--     <a>rep</a> = <a>Map</a> (+42)
--   </pre>
--   
--   There are no pre-defined instances, and a call to <tt>cast</tt> will
--   not compile if no instances for the input and output type pair are
--   found, so you must define instances in order to use <tt>cast</tt>.
cast :: Rep (Map a) b => a -> b
instance Generic2 Map


-- | Summary: Functions for extracting meta-information about the
--   representation.
module Generics.EMGM.Functions.Meta

-- | A class to reveal the embedding-projection pair for a given datatype
--   and its isomorphic representation type.
class HasEP a b | a -> b
epOf :: HasEP a b => a -> EP a b

-- | The type of a generic function that takes one value and returns an
--   optional constructor description.
newtype Con a
Con :: (a -> Maybe ConDescr) -> Con a
selConstructor :: Con a -> a -> Maybe ConDescr

-- | Returns a constructor description if the value is not a primitive. The
--   argument is not evaluated and may be <tt>undefined</tt>.
conDescr :: Rep Con a => a -> Maybe ConDescr

-- | The type of a generic function that takes a boolean to limit recursion
--   and a value and returns a list of label descriptions for that
--   constructor.
newtype Lbls a
Lbls :: (Bool -> a -> [LblDescr]) -> Lbls a
selLabels :: Lbls a -> Bool -> a -> [LblDescr]

-- | Returns a list of descriptions for all labels in the head constructor.
--   Does not recurse into the children. The argument is not evaluated and
--   may be <tt>undefined</tt>.
lblDescrs :: Rep Lbls a => a -> [LblDescr]
instance Generic Lbls
instance Generic Con


-- | Summary: Generic functions that parse strings to produce values.
--   
--   The functions in this module involve generically parsing a string and
--   producing a value. They rely on the return type to determine the
--   structure for parsing. Often, this can be determined by the type
--   checker, but you will occasionally need to give an explicit type
--   signature.
--   
--   The underlying parser is designed to be as similar to <tt>deriving
--   Read</tt> (as implemented by GHC) as possible. Refer to documentation
--   in <a>Text.Read</a> for details.
--   
--   Since this library does not have access to the syntax of a
--   <tt>data</tt> declaration, it relies on <a>ConDescr</a> for
--   information. It is important that <a>ConDescr</a> accurately describe,
--   for each constructor, the name, record labels (in same order as
--   declared) if present, and fixity.
--   
--   See also <a>Generics.EMGM.Functions.Show</a>.
module Generics.EMGM.Functions.Read

-- | The type of a generic function that takes a constructor-type argument
--   and returns a parser combinator for some type.
newtype Read a
Read :: (ConType -> ReadPrec a) -> Read a
selRead :: Read a -> ConType -> ReadPrec a

-- | Generate a <a>ReadPrec</a> parser combinator for the datatype
--   <tt>a</tt> that handles operator precedence. This uses the library in
--   <a>Text.ParserCombinators.ReadPrec</a> and should be similar to a
--   derived implementation of <tt>Text.Read.readPrec</tt>.
readPrec :: Rep Read a => ReadPrec a

-- | Generate a <a>ReadP</a> parser combinator for the datatype <tt>a</tt>.
--   This can be used with <tt>Text.ParserCombinators.ReadP</tt>.
readP :: Rep Read a => Int -> ReadP a

-- | Attempt to parse a value from the front of the string using the given
--   precedence. <a>readsPrec</a> returns a list of (parsed value,
--   remaining string) pairs. If parsing fails, <a>readsPrec</a> returns an
--   empty list.
readsPrec :: Rep Read a => Int -> ReadS a

-- | A variant of <a>readsPrec</a> with the minimum precedence (0).
reads :: Rep Read a => ReadS a

-- | A variant of <a>reads</a> that returns <tt>Just value</tt> on a
--   successful parse. Otherwise, <a>read</a> returns <a>Nothing</a>. Note
--   that a successful parse requires the input to be completely consumed.
read :: Rep Read a => String -> Maybe a
instance [overlap ok] (Rep Read a, Rep Read b, Rep Read c, Rep Read d, Rep Read e, Rep Read f, Rep Read h) => Rep Read (a, b, c, d, e, f, h)
instance [overlap ok] (Rep Read a, Rep Read b, Rep Read c, Rep Read d, Rep Read e, Rep Read f) => Rep Read (a, b, c, d, e, f)
instance [overlap ok] (Rep Read a, Rep Read b, Rep Read c, Rep Read d, Rep Read e) => Rep Read (a, b, c, d, e)
instance [overlap ok] (Rep Read a, Rep Read b, Rep Read c, Rep Read d) => Rep Read (a, b, c, d)
instance [overlap ok] (Rep Read a, Rep Read b, Rep Read c) => Rep Read (a, b, c)
instance [overlap ok] (Rep Read a, Rep Read b) => Rep Read (a, b)
instance [overlap ok] Rep Read ()
instance [overlap ok] Rep Read String
instance [overlap ok] Rep Read a => Rep Read [a]
instance [overlap ok] Generic Read


-- | Summary: Generic functions that convert values to readable strings.
--   
--   The functions in this module involve generically producing a string
--   from a value of a supported datatype. The functions <a>showsPrec</a>
--   and <a>show</a> are modeled after those in the class <tt>Show</tt>,
--   and <a>shows</a> after the related function of the same name.
--   
--   The underlying unparser is designed to be as similar to <tt>deriving
--   Show</tt> as possible. Refer to documentation in <a>Text.Show</a> for
--   details.
--   
--   Since this library does not have access to the syntax of a
--   <tt>data</tt> declaration, it relies on <a>ConDescr</a> for
--   information. It is important that <a>ConDescr</a> accurately describe,
--   for each constructor, the name, arity, record labels (in same order as
--   declared) if present, and fixity.
--   
--   See also <a>Generics.EMGM.Functions.Read</a>.
module Generics.EMGM.Functions.Show

-- | The type of a generic function that takes a constructor-type argument,
--   a number (precedence), and a value and returns a <a>ShowS</a>
--   function.
newtype Show a
Show :: (ConType -> Int -> a -> ShowS) -> Show a
selShow :: Show a -> ConType -> Int -> a -> ShowS

-- | Convert a value to a readable string starting with the operator
--   precedence of the enclosing context.
showsPrec :: Rep Show a => Int -> a -> ShowS

-- | A variant of <a>showsPrec</a> with the minimum precedence (0).
shows :: Rep Show a => a -> ShowS

-- | A variant of <a>shows</a> that returns a <a>String</a> instead of
--   <a>ShowS</a>.
show :: Rep Show a => a -> String
instance [overlap ok] (Rep Show a, Rep Show b, Rep Show c, Rep Show d, Rep Show e, Rep Show f, Rep Show h) => Rep Show (a, b, c, d, e, f, h)
instance [overlap ok] (Rep Show a, Rep Show b, Rep Show c, Rep Show d, Rep Show e, Rep Show f) => Rep Show (a, b, c, d, e, f)
instance [overlap ok] (Rep Show a, Rep Show b, Rep Show c, Rep Show d, Rep Show e) => Rep Show (a, b, c, d, e)
instance [overlap ok] (Rep Show a, Rep Show b, Rep Show c, Rep Show d) => Rep Show (a, b, c, d)
instance [overlap ok] (Rep Show a, Rep Show b, Rep Show c) => Rep Show (a, b, c)
instance [overlap ok] (Rep Show a, Rep Show b) => Rep Show (a, b)
instance [overlap ok] Rep Show ()
instance [overlap ok] Rep Show String
instance [overlap ok] Rep Show a => Rep Show [a]
instance [overlap ok] Generic Show


-- | Summary: Generic function that applies a (non-generic) function to
--   every element in a value, splitting the element into two. The result
--   is a pair of structurally equivalent values, one with the elements
--   from the first component of the splitting function and the other with
--   the elements from the second component.
--   
--   <a>UnzipWith</a> can be seen as the dual of <tt>ZipWith</tt>, though
--   it has no direct <tt>Prelude</tt> counterpart. Only <a>unzip</a> has a
--   <tt>Prelude</tt> analog.
--   
--   See also <a>Generics.EMGM.Functions.ZipWith</a>.
module Generics.EMGM.Functions.UnzipWith

-- | The type of a generic function that takes an argument of one type and
--   returns a pair of values with two different types.
newtype UnzipWith m a b c
UnzipWith :: (a -> m (b, c)) -> UnzipWith m a b c
selUnzipWith :: UnzipWith m a b c -> a -> m (b, c)

-- | Splits a container into two structurally equivalent containers by
--   applying a function to every element, which splits it into two
--   corresponding elements. Fails if the spliting function fails
unzipWithM :: (Monad m, FRep3 (UnzipWith m) f) => (a -> m (b, c)) -> f a -> m (f b, f c)

-- | A specialized version of <a>unzipWithM</a> using the identity monad
--   and a splitting function that does not fail.
unzipWith :: FRep3 (UnzipWith Id) f => (a -> (b, c)) -> f a -> (f b, f c)

-- | A specialized version of <a>unzipWith</a> for pairs. Generic version
--   of <tt>Prelude.unzip</tt>.
unzip :: FRep3 (UnzipWith Id) f => f (b, c) -> (f b, f c)
instance Monad Id
instance Monad m => Generic3 (UnzipWith m)


-- | Summary: Generic function that applies a (non-generic) function to
--   every pair of corresponding elements in two structurally equivalent
--   polymorphic values to produce a third (also structurally equivalent)
--   value with the result of each application in every element location.
--   
--   The important concepts for <a>zipWithM</a> are <i>structural
--   equivalence</i> and <i>corresponding elements</i>. For <a>zipWithM</a>
--   to be successful (and not <a>fail</a>), its two container arguments
--   must have exactly the same shape. If the shapes of the arguments
--   differ, then it is unclear what the shape of the result is supposed to
--   be. As a result, <a>zipWithM</a> will <a>fail</a>.
--   
--   Corresponding elements are those elements that are located in the same
--   place in the tree of each argument. If you were to traverse the tree
--   to get to element x in one tree, then its corresponding element y in
--   the other tree should require the exact same path to reach it.
--   
--   See also <a>Generics.EMGM.Functions.UnzipWith</a>.
module Generics.EMGM.Functions.ZipWith

-- | The type of a generic function that takes two arguments of two
--   different types and returns a value of a third type in a Monad.
newtype ZipWith m a b c
ZipWith :: (a -> b -> m c) -> ZipWith m a b c
selZipWith :: ZipWith m a b c -> a -> b -> m c

-- | Combine two structurally equivalent containers into one by applying a
--   function to every corresponding pair of elements. Fails if (1) the
--   binary operator fails or (2) <tt>f a</tt> and <tt>f b</tt> have
--   different shapes.
zipWithM :: (Monad m, FRep3 (ZipWith m) f) => (a -> b -> m c) -> f a -> f b -> m (f c)

-- | A specialized version of <a>zipWithM</a> for the <a>Maybe</a> monad
--   and a binary operator that does not fail. Generic version of
--   <tt>Prelude.zipWith</tt>.
zipWith :: FRep3 (ZipWith Maybe) f => (a -> b -> c) -> f a -> f b -> Maybe (f c)

-- | A specialized version of <a>zipWith</a> for pairs. Generic version of
--   <tt>Prelude.zip</tt>.
zip :: FRep3 (ZipWith Maybe) f => f a -> f b -> Maybe (f (a, b))
instance Monad m => Generic3 (ZipWith m)


-- | Summary: Generic function thats transposes a value <tt>f (g a)</tt> to
--   <tt>g (f a)</tt>.
--   
--   This is an interesting generic function since it uses multiple other
--   generic functions: <a>Crush</a>, <a>Enum</a>, <a>Map</a>, and
--   <a>ZipWith</a>. Notably, <a>Map</a> and <a>ZipWith</a> are required
--   for definining the sum and product cases of the generic function. The
--   others make the generic function easy to use.
--   
--   NOTE: Be aware of the special case for empty values noted in the
--   documentation of <tt>tranpose</tt>.
module Generics.EMGM.Functions.Transpose

-- | The type of a generic function that takes a generic value and
--   non-generic container and returns the container filled with other
--   generic values.
newtype Monad m => Transpose m f c b a
Transpose :: (a -> f c -> m (f b)) -> Transpose m f c b a
selTranspose :: Transpose m f c b a -> a -> f c -> m (f b)

-- | Transposes the structure of nested containers (types <tt>f</tt> and
--   <tt>g</tt>). <a>fail</a> if the outermost container is empty, because
--   there is no generic way to guarantee that both have unit constructors
--   or, if they do, decide which one to choose. See <a>transposeE</a> for
--   an alternative approach.
transpose :: (Monad m, FRep (Crush [g a]) f, FRep2 (Transpose m g a) f) => f (g a) -> m (g (f a))

-- | A convenient version of <a>transpose</a> that returns the <a>empty</a>
--   value on failure.
transposeE :: (Rep Enum (g (f a)), FRep (Crush [g a]) f, FRep2 (Transpose Maybe g a) f) => f (g a) -> g (f a)
instance (Monad m, FRep2 Map f, FRep3 (ZipWith m) f) => Generic2 (Transpose m f c)


-- | Summary: Generic representation and instances for <a>Bool</a>.
module Generics.EMGM.Data.Bool
type BoolS = Unit :+: Unit

-- | Constructor description for <a>False</a>.
conFalse :: ConDescr

-- | Constructor description for <a>True</a>.
conTrue :: ConDescr

-- | Representation of <a>Bool</a> for <a>rep</a>.
repBool :: Generic g => g Bool

-- | Representation of <a>Bool</a> for <a>frep</a>.
frepBool :: Generic g => g Bool

-- | Representation of <a>Bool</a> for <a>frep2</a>.
frep2Bool :: Generic2 g => g Bool Bool

-- | Representation of <a>Bool</a> for <a>frep3</a>.
frep3Bool :: Generic3 g => g Bool Bool Bool

-- | Representation of <a>Bool</a> for <a>bifrep2</a>.
bifrep2Bool :: Generic2 g => g Bool Bool
instance [overlap ok] Rep (Everywhere' Bool) Bool
instance [overlap ok] Rep (Everywhere Bool) Bool
instance [overlap ok] Alternative f => Rep (Collect f Bool) Bool
instance [overlap ok] Generic g => Rep g Bool
instance [overlap ok] HasEP Bool BoolS


-- | Summary: Generic representation and instances for <a>Either</a>.
module Generics.EMGM.Data.Either
type EitherS a b = a :+: b

-- | Constructor description for <a>Left</a>.
conLeft :: ConDescr

-- | Constructor description for <a>Right</a>.
conRight :: ConDescr

-- | Representation of <a>Either</a> for <a>rep</a>.
repEither :: (Generic g, Rep g a, Rep g b) => g (Either a b)

-- | Representation of <a>Either</a> for <a>frep</a>.
frepEither :: Generic g => g a -> g b -> g (Either a b)

-- | Representation of <a>Either</a> for <a>frep2</a>.
frep2Either :: Generic2 g => g a1 a2 -> g b1 b2 -> g (Either a1 b1) (Either a2 b2)

-- | Representation of <a>Either</a> for <a>frep3</a>.
frep3Either :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (Either a1 b1) (Either a2 b2) (Either a3 b3)

-- | Representation of <a>Either</a> for <a>bifrep2</a>.
bifrep2Either :: Generic2 g => g a1 a2 -> g b1 b2 -> g (Either a1 b1) (Either a2 b2)
instance [overlap ok] Rep (Everywhere' (Either a b)) (Either a b)
instance [overlap ok] (Rep (Everywhere (Either a b)) a, Rep (Everywhere (Either a b)) b) => Rep (Everywhere (Either a b)) (Either a b)
instance [overlap ok] Alternative f => Rep (Collect f (Either a b)) (Either a b)
instance [overlap ok] Generic2 g => BiFRep2 g Either
instance [overlap ok] (Generic g, Rep g a, Rep g b) => Rep g (Either a b)
instance [overlap ok] HasEP (Either a b) (EitherS a b)


-- | Summary: Generic representation and instances for lists.
module Generics.EMGM.Data.List
type ListS a = Unit :+: (a :*: [a])

-- | Constructor description for ''nil'': <tt>[]</tt>.
conNil :: ConDescr

-- | Constructor description for ''cons'': <tt>(:)</tt>.
conCons :: ConDescr

-- | Representation of lists for <a>rep</a>.
repList :: (Generic g, Rep g a, Rep g [a]) => g [a]

-- | Representation of lists for <a>frep</a>.
frepList :: Generic g => g a -> g [a]

-- | Representation of lists for <a>frep2</a>.
frep2List :: Generic2 g => g a b -> g [a] [b]

-- | Representation of lists for <a>frep3</a>.
frep3List :: Generic3 g => g a b c -> g [a] [b] [c]

-- | Representation of lists for <a>bifrep2</a>.
bifrep2List :: Generic2 g => g a b -> g [a] [b]
instance [overlap ok] Rep (Everywhere' [a]) [a]
instance [overlap ok] Rep (Everywhere [a]) a => Rep (Everywhere [a]) [a]
instance [overlap ok] Alternative f => Rep (Collect f [a]) [a]
instance [overlap ok] Generic3 g => FRep3 g []
instance [overlap ok] Generic2 g => FRep2 g []
instance [overlap ok] Generic g => FRep g []
instance [overlap ok] (Generic g, Rep g a) => Rep g [a]
instance [overlap ok] HasEP [a] (ListS a)


-- | Summary: Generic representation and instances for <a>Maybe</a>.
module Generics.EMGM.Data.Maybe
type MaybeS a = Unit :+: a

-- | Constructor description for <a>Nothing</a>.
conNothing :: ConDescr

-- | Constructor description for <a>Just</a>.
conJust :: ConDescr

-- | Representation of <a>Maybe</a> for <a>rep</a>.
repMaybe :: (Generic g, Rep g a) => g (Maybe a)

-- | Representation of <a>Maybe</a> for <a>frep</a>.
frepMaybe :: Generic g => g a -> g (Maybe a)

-- | Representation of <a>Maybe</a> for <a>frep2</a>.
frep2Maybe :: Generic2 g => g a b -> g (Maybe a) (Maybe b)

-- | Representation of <a>Maybe</a> for <a>frep3</a>.
frep3Maybe :: Generic3 g => g a b c -> g (Maybe a) (Maybe b) (Maybe c)

-- | Representation of <a>Maybe</a> for <a>bifrep2</a>.
bifrep2Maybe :: Generic2 g => g a b -> g (Maybe a) (Maybe b)
instance [overlap ok] Rep (Everywhere' (Maybe a)) (Maybe a)
instance [overlap ok] Rep (Everywhere (Maybe a)) a => Rep (Everywhere (Maybe a)) (Maybe a)
instance [overlap ok] Alternative f => Rep (Collect f (Maybe a)) (Maybe a)
instance [overlap ok] Generic3 g => FRep3 g Maybe
instance [overlap ok] Generic2 g => FRep2 g Maybe
instance [overlap ok] Generic g => FRep g Maybe
instance [overlap ok] (Generic g, Rep g a) => Rep g (Maybe a)
instance [overlap ok] HasEP (Maybe a) (MaybeS a)


-- | Summary: Generic representation and instances for tuples of arity 0
--   (''unit'') and 2 to 7.
module Generics.EMGM.Data.Tuple
type Tuple0S = Unit

-- | Constructor description for <tt>()</tt>.
conTuple0 :: ConDescr

-- | Representation of <tt>()</tt> for <a>rep</a>.
repTuple0 :: Generic g => g ()

-- | Representation of <tt>()</tt> for <a>frep</a>.
frepTuple0 :: Generic g => g ()

-- | Representation of <tt>()</tt> for <a>frep2</a>.
frep2Tuple0 :: Generic2 g => g () ()

-- | Representation of <tt>()</tt> for <a>frep3</a>.
frep3Tuple0 :: Generic3 g => g () () ()

-- | Representation of <tt>()</tt> for <a>bifrep2</a>.
bifrep2Tuple0 :: Generic2 g => g () ()
type Tuple2S a b = a :*: b

-- | Constructor description for <tt>(,)</tt>.
conTuple2 :: ConDescr

-- | Representation of <tt>(,)</tt> for <a>rep</a>.
repTuple2 :: (Generic g, Rep g a, Rep g b) => g (a, b)

-- | Representation of <tt>(,)</tt> for <a>frep</a>.
frepTuple2 :: Generic g => g a -> g b -> g (a, b)

-- | Representation of <tt>(,)</tt> for <a>frep2</a>.
frep2Tuple2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1, b1) (a2, b2)

-- | Representation of <tt>(,)</tt> for <a>frep3</a>.
frep3Tuple2 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (a1, b1) (a2, b2) (a3, b3)

-- | Representation of <tt>(,)</tt> for <a>bifrep2</a>.
bifrep2Tuple2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1, b1) (a2, b2)
type Tuple3S a b c = a :*: (b :*: c)

-- | Constructor description for <tt>(,,)</tt>.
conTuple3 :: ConDescr

-- | Representation of <tt>(,,)</tt> for <a>rep</a>.
repTuple3 :: (Generic g, Rep g a, Rep g b, Rep g c) => g (a, b, c)

-- | Representation of <tt>(,,)</tt> for <a>frep</a>.
frepTuple3 :: Generic g => g a -> g b -> g c -> g (a, b, c)

-- | Representation of <tt>(,,)</tt> for <a>frep2</a>.
frep2Tuple3 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g (a1, b1, c1) (a2, b2, c2)

-- | Representation of <tt>(,,)</tt> for <a>frep3</a>.
frep3Tuple3 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g c1 c2 c3 -> g (a1, b1, c1) (a2, b2, c2) (a3, b3, c3)

-- | Representation of <tt>(,,)</tt> for <a>bifrep2</a>.
bifrep2Tuple3 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g (a1, b1, c1) (a2, b2, c2)
type Tuple4S a b c d = a :*: (b :*: (c :*: d))

-- | Constructor description for <tt>(,,,)</tt>.
conTuple4 :: ConDescr

-- | Representation of <tt>(,,,)</tt> for <a>rep</a>.
repTuple4 :: (Generic g, Rep g a, Rep g b, Rep g c, Rep g d) => g (a, b, c, d)

-- | Representation of <tt>(,,,)</tt> for <a>frep</a>.
frepTuple4 :: Generic g => g a -> g b -> g c -> g d -> g (a, b, c, d)

-- | Representation of <tt>(,,,)</tt> for <a>frep2</a>.
frep2Tuple4 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g (a1, b1, c1, d1) (a2, b2, c2, d2)

-- | Representation of <tt>(,,,)</tt> for <a>frep3</a>.
frep3Tuple4 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g c1 c2 c3 -> g d1 d2 d3 -> g (a1, b1, c1, d1) (a2, b2, c2, d2) (a3, b3, c3, d3)

-- | Representation of <tt>(,,,)</tt> for <a>bifrep2</a>.
bifrep2Tuple4 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g (a1, b1, c1, d1) (a2, b2, c2, d2)
type Tuple5S a b c d e = a :*: (b :*: (c :*: (d :*: e)))

-- | Constructor description for <tt>(,,,,)</tt>.
conTuple5 :: ConDescr

-- | Representation of <tt>(,,,,)</tt> for <a>rep</a>.
repTuple5 :: (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e) => g (a, b, c, d, e)

-- | Representation of <tt>(,,,,)</tt> for <a>frep</a>.
frepTuple5 :: Generic g => g a -> g b -> g c -> g d -> g e -> g (a, b, c, d, e)

-- | Representation of <tt>(,,,,)</tt> for <a>frep2</a>.
frep2Tuple5 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2)

-- | Representation of <tt>(,,,,)</tt> for <a>frep3</a>.
frep3Tuple5 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g c1 c2 c3 -> g d1 d2 d3 -> g e1 e2 e3 -> g (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2) (a3, b3, c3, d3, e3)

-- | Representation of <tt>(,,,,)</tt> for <tt>bfrep2</tt>.
bifrep2Tuple5 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2)
type Tuple6S a b c d e f = a :*: (b :*: (c :*: (d :*: (e :*: f))))

-- | Constructor description for <tt>(,,,,,)</tt>.
conTuple6 :: ConDescr

-- | Representation of <tt>(,,,,,)</tt> for <a>rep</a>.
repTuple6 :: (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e, Rep g f) => g (a, b, c, d, e, f)

-- | Representation of <tt>(,,,,,)</tt> for <a>frep</a>.
frepTuple6 :: Generic g => g a -> g b -> g c -> g d -> g e -> g f -> g (a, b, c, d, e, f)

-- | Representation of <tt>(,,,,,)</tt> for <a>frep2</a>.
frep2Tuple6 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g f1 f2 -> g (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2)

-- | Representation of <tt>(,,,,,)</tt> for <a>frep3</a>.
frep3Tuple6 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g c1 c2 c3 -> g d1 d2 d3 -> g e1 e2 e3 -> g f1 f2 f3 -> g (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2) (a3, b3, c3, d3, e3, f3)

-- | Representation of <tt>(,,,,,)</tt> for <a>bifrep2</a>.
bifrep2Tuple6 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g f1 f2 -> g (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2)
type Tuple7S a b c d e f h = a :*: (b :*: (c :*: (d :*: (e :*: (f :*: h)))))

-- | Constructor description for <tt>(,,,,,,)</tt>.
conTuple7 :: ConDescr

-- | Representation of <tt>(,,,,,,)</tt> for <a>rep</a>.
repTuple7 :: (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e, Rep g f, Rep g h) => g (a, b, c, d, e, f, h)

-- | Representation of <tt>(,,,,,,)</tt> for <a>frep</a>.
frepTuple7 :: Generic g => g a -> g b -> g c -> g d -> g e -> g f -> g h -> g (a, b, c, d, e, f, h)

-- | Representation of <tt>(,,,,,,)</tt> for <a>frep2</a>.
frep2Tuple7 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g f1 f2 -> g h1 h2 -> g (a1, b1, c1, d1, e1, f1, h1) (a2, b2, c2, d2, e2, f2, h2)

-- | Representation of <tt>(,,,,,,)</tt> for <a>frep3</a>.
frep3Tuple7 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g c1 c2 c3 -> g d1 d2 d3 -> g e1 e2 e3 -> g f1 f2 f3 -> g h1 h2 h3 -> g (a1, b1, c1, d1, e1, f1, h1) (a2, b2, c2, d2, e2, f2, h2) (a3, b3, c3, d3, e3, f3, h3)

-- | Representation of <tt>(,,,,,,)</tt> for <a>bifrep2</a>.
bifrep2Tuple7 :: Generic2 g => g a1 a2 -> g b1 b2 -> g c1 c2 -> g d1 d2 -> g e1 e2 -> g f1 f2 -> g h1 h2 -> g (a1, b1, c1, d1, e1, f1, h1) (a2, b2, c2, d2, e2, f2, h2)
instance [overlap ok] (Rep (Everywhere (a, b, c, d, e, f, h)) a, Rep (Everywhere (a, b, c, d, e, f, h)) b, Rep (Everywhere (a, b, c, d, e, f, h)) c, Rep (Everywhere (a, b, c, d, e, f, h)) d, Rep (Everywhere (a, b, c, d, e, f, h)) e, Rep (Everywhere (a, b, c, d, e, f, h)) f, Rep (Everywhere (a, b, c, d, e, f, h)) h) => Rep (Everywhere (a, b, c, d, e, f, h)) (a, b, c, d, e, f, h)
instance [overlap ok] (Rep (Everywhere (a, b, c, d, e, f)) a, Rep (Everywhere (a, b, c, d, e, f)) b, Rep (Everywhere (a, b, c, d, e, f)) c, Rep (Everywhere (a, b, c, d, e, f)) d, Rep (Everywhere (a, b, c, d, e, f)) e, Rep (Everywhere (a, b, c, d, e, f)) f) => Rep (Everywhere (a, b, c, d, e, f)) (a, b, c, d, e, f)
instance [overlap ok] (Rep (Everywhere (a, b, c, d, e)) a, Rep (Everywhere (a, b, c, d, e)) b, Rep (Everywhere (a, b, c, d, e)) c, Rep (Everywhere (a, b, c, d, e)) d, Rep (Everywhere (a, b, c, d, e)) e) => Rep (Everywhere (a, b, c, d, e)) (a, b, c, d, e)
instance [overlap ok] (Rep (Everywhere (a, b, c, d)) a, Rep (Everywhere (a, b, c, d)) b, Rep (Everywhere (a, b, c, d)) c, Rep (Everywhere (a, b, c, d)) d) => Rep (Everywhere (a, b, c, d)) (a, b, c, d)
instance [overlap ok] (Rep (Everywhere (a, b, c)) a, Rep (Everywhere (a, b, c)) b, Rep (Everywhere (a, b, c)) c) => Rep (Everywhere (a, b, c)) (a, b, c)
instance [overlap ok] (Rep (Everywhere (a, b)) a, Rep (Everywhere (a, b)) b) => Rep (Everywhere (a, b)) (a, b)
instance [overlap ok] Rep (Everywhere ()) ()
instance [overlap ok] Rep (Everywhere' (a, b, c, d, e, f, h)) (a, b, c, d, e, f, h)
instance [overlap ok] Rep (Everywhere' (a, b, c, d, e, f)) (a, b, c, d, e, f)
instance [overlap ok] Rep (Everywhere' (a, b, c, d, e)) (a, b, c, d, e)
instance [overlap ok] Rep (Everywhere' (a, b, c, d)) (a, b, c, d)
instance [overlap ok] Rep (Everywhere' (a, b, c)) (a, b, c)
instance [overlap ok] Rep (Everywhere' (a, b)) (a, b)
instance [overlap ok] Rep (Everywhere' ()) ()
instance [overlap ok] Alternative f => Rep (Collect f (a, b, c, d, e, h, i)) (a, b, c, d, e, h, i)
instance [overlap ok] Alternative f => Rep (Collect f (a, b, c, d, e, h)) (a, b, c, d, e, h)
instance [overlap ok] Alternative f => Rep (Collect f (a, b, c, d, e)) (a, b, c, d, e)
instance [overlap ok] Alternative f => Rep (Collect f (a, b, c, d)) (a, b, c, d)
instance [overlap ok] Alternative f => Rep (Collect f (a, b, c)) (a, b, c)
instance [overlap ok] Alternative f => Rep (Collect f (a, b)) (a, b)
instance [overlap ok] Alternative f => Rep (Collect f ()) ()
instance [overlap ok] Generic2 g => BiFRep2 g (,)
instance [overlap ok] (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e, Rep g f, Rep g h) => Rep g (a, b, c, d, e, f, h)
instance [overlap ok] (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e, Rep g f) => Rep g (a, b, c, d, e, f)
instance [overlap ok] (Generic g, Rep g a, Rep g b, Rep g c, Rep g d, Rep g e) => Rep g (a, b, c, d, e)
instance [overlap ok] (Generic g, Rep g a, Rep g b, Rep g c, Rep g d) => Rep g (a, b, c, d)
instance [overlap ok] (Generic g, Rep g a, Rep g b, Rep g c) => Rep g (a, b, c)
instance [overlap ok] (Generic g, Rep g a, Rep g b) => Rep g (a, b)
instance [overlap ok] Generic g => Rep g ()
instance [overlap ok] HasEP (a, b, c, d, e, f, h) (Tuple7S a b c d e f h)
instance [overlap ok] HasEP (a, b, c, d, e, f) (Tuple6S a b c d e f)
instance [overlap ok] HasEP (a, b, c, d, e) (Tuple5S a b c d e)
instance [overlap ok] HasEP (a, b, c, d) (Tuple4S a b c d)
instance [overlap ok] HasEP (a, b, c) (Tuple3S a b c)
instance [overlap ok] HasEP (a, b) (Tuple2S a b)
instance [overlap ok] HasEP () Tuple0S


-- | Summary: Generic representation and instances for <a>Ratio</a>.
module Generics.EMGM.Data.Ratio
type RatioS a = a :*: a

-- | Constructor description for <a>%</a>.
conRatio :: ConDescr

-- | Representation of <a>Ratio</a> for <a>rep</a>.
repRatio :: (Integral a, Generic g, Rep g a) => g (Ratio a)

-- | Representation of <a>Ratio</a> for <a>frep</a>.
frepRatio :: (Integral a, Generic g) => g a -> g (Ratio a)

-- | Representation of <a>Ratio</a> for <a>frep2</a>.
frep2Ratio :: (Integral a1, Integral a2, Generic2 g) => g a1 a2 -> g (Ratio a1) (Ratio a2)

-- | Representation of <a>Ratio</a> for <a>frep3</a>.
frep3Ratio :: (Integral a1, Integral a2, Integral a3, Generic3 g) => g a1 a2 a3 -> g (Ratio a1) (Ratio a2) (Ratio a3)

-- | Representation of <a>Ratio</a> for <a>bifrep2</a>.
bifrep2Ratio :: (Integral a1, Integral a2, Generic2 g) => g a1 a2 -> g (Ratio a1) (Ratio a2)
instance [overlap ok] Rep (Everywhere' (Ratio a)) (Ratio a)
instance [overlap ok] (Integral a, Rep (Everywhere (Ratio a)) a) => Rep (Everywhere (Ratio a)) (Ratio a)
instance [overlap ok] Alternative f => Rep (Collect f (Ratio a)) (Ratio a)
instance [overlap ok] (Integral a, Generic g, Rep g a) => Rep g (Ratio a)
instance [overlap ok] Integral a => HasEP (Ratio a) (RatioS a)


-- | EMGM is "Extensible and Modular Generics for the Masses," a library
--   for datatype-generic programming in Haskell.
--   
--   This module exports the most commonly used types, classes, and
--   functions. The documentation is organized by topic for convenient
--   access.
module Generics.EMGM

-- | Encodes a constructor with no arguments. An analogous standard Haskell
--   type is <tt>()</tt>.
data Unit

-- | The only value of type <tt>Unit</tt> (ignoring <tt>_|_</tt>).
Unit :: Unit

-- | The "sum" encodes 2 constructor alternatives. An analogous standard
--   Haskell type is <tt><a>Either</a> a b</tt>.
data (:+:) a b

-- | Left alternative
L :: a -> :+: a b

-- | Right alternative
R :: b -> :+: a b

-- | The "product" encodes 2 constructor arguments. An analogous standard
--   Haskell type is <tt>(a, b)</tt>.
data (:*:) a b

-- | A pair of arguments
(:*:) :: a -> b -> :*: a b

-- | The embedding-projection pair contains two functions for converting
--   between the datatype and its representation. An <tt>EP</tt> value
--   preserves an isomorphism (ignoring <tt>_|_</tt>s) between a datatype
--   and its structure representation.
data EP d r
EP :: (d -> r) -> (r -> d) -> EP d r

-- | Embed a <tt>d</tt>atatype into its <tt>r</tt>epresentation.
from :: EP d r -> (d -> r)

-- | Project <tt>d</tt>atatype from its <tt>r</tt>epresentation.
to :: EP d r -> (r -> d)

-- | Contains useful meta-information about the syntax used in a
--   constructor declaration.
--   
--   NOTE: It is important that the <a>ConDescr</a> value accurately
--   describe the syntax in a constructor declaration. An incorrect
--   description may lead to faulty <a>Read</a> or <a>Show</a> operation.
data ConDescr
ConDescr :: String -> Int -> Bool -> Fixity -> ConDescr

-- | Name of the constructor (without parenthesese if infix).
conName :: ConDescr -> String

-- | Number of fields.
conArity :: ConDescr -> Int

-- | Uses labeled fields (a.k.a. record syntax).
conRecord :: ConDescr -> Bool

-- | Fixity, associativity, precedence.
conFixity :: ConDescr -> Fixity

-- | Encodes the string label for a field in a constructor defined with
--   labeled fields (a.k.a. record syntax).
newtype LblDescr
LblDescr :: String -> LblDescr

-- | A constructor's fixity, associativity, and precedence.
data Fixity

-- | Associativity and precedence are the same as function application.
Prefix :: Fixity
Infix :: Associativity -> Prec -> Fixity

-- | A constructor's associativity.
data Associativity

-- | Declared with infixl
LeftAssoc :: Associativity

-- | Declared with infixr
RightAssoc :: Associativity

-- | Declared with infix
NonAssoc :: Associativity
type Prec = Int

-- | Get the precedence of a fixity value.
prec :: Fixity -> Prec

-- | This class forms the foundation for defining generic functions with a
--   single generic argument. Each method represents a type case. There are
--   cases for primitive types, structural representation types, and for
--   user-defined datatypes.
--   
--   The included modules using <tt>Generic</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.Collect</a></li>
--   <li><a>Generics.EMGM.Functions.Compare</a></li>
--   <li><a>Generics.EMGM.Functions.Constructor</a></li>
--   <li><a>Generics.EMGM.Functions.Crush</a></li>
--   <li><a>Generics.EMGM.Functions.Enum</a></li>
--   <li><a>Generics.EMGM.Functions.Read</a></li>
--   <li><a>Generics.EMGM.Functions.Show</a></li>
--   </ul>
class Generic g
rint :: Generic g => g Int
rinteger :: Generic g => g Integer
rfloat :: Generic g => g Float
rdouble :: Generic g => g Double
rchar :: Generic g => g Char
runit :: Generic g => g Unit
rsum :: Generic g => g a -> g b -> g (a :+: b)
rprod :: Generic g => g a -> g b -> g (a :*: b)
rcon :: Generic g => ConDescr -> g a -> g a
rlbl :: Generic g => LblDescr -> g a -> g a
rtype :: Generic g => EP b a -> g a -> g b

-- | This class forms the foundation for defining generic functions with
--   two generic arguments. See <a>Generic</a> for details.
--   
--   The included modules using <tt>Generic2</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.Map</a></li>
--   <li><a>Generics.EMGM.Functions.Transpose</a></li>
--   </ul>
class Generic2 g
rint2 :: Generic2 g => g Int Int
rinteger2 :: Generic2 g => g Integer Integer
rfloat2 :: Generic2 g => g Float Float
rdouble2 :: Generic2 g => g Double Double
rchar2 :: Generic2 g => g Char Char
runit2 :: Generic2 g => g Unit Unit
rsum2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1 :+: b1) (a2 :+: b2)
rprod2 :: Generic2 g => g a1 a2 -> g b1 b2 -> g (a1 :*: b1) (a2 :*: b2)
rcon2 :: Generic2 g => ConDescr -> g a1 a2 -> g a1 a2
rlbl2 :: Generic2 g => LblDescr -> g a1 a2 -> g a1 a2
rtype2 :: Generic2 g => EP a2 a1 -> EP b2 b1 -> g a1 b1 -> g a2 b2

-- | This class forms the foundation for defining generic functions with
--   three generic arguments. See <a>Generic</a> for details.
--   
--   The included modules using <tt>Generic3</tt> are:
--   
--   <ul>
--   <li><a>Generics.EMGM.Functions.UnzipWith</a></li>
--   <li><a>Generics.EMGM.Functions.ZipWith</a></li>
--   </ul>
class Generic3 g
rint3 :: Generic3 g => g Int Int Int
rinteger3 :: Generic3 g => g Integer Integer Integer
rfloat3 :: Generic3 g => g Float Float Float
rdouble3 :: Generic3 g => g Double Double Double
rchar3 :: Generic3 g => g Char Char Char
runit3 :: Generic3 g => g Unit Unit Unit
rsum3 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (a1 :+: b1) (a2 :+: b2) (a3 :+: b3)
rprod3 :: Generic3 g => g a1 a2 a3 -> g b1 b2 b3 -> g (a1 :*: b1) (a2 :*: b2) (a3 :*: b3)
rcon3 :: Generic3 g => ConDescr -> g a1 a2 a3 -> g a1 a2 a3
rlbl3 :: Generic3 g => LblDescr -> g a1 a2 a3 -> g a1 a2 a3
rtype3 :: Generic3 g => EP a2 a1 -> EP b2 b1 -> EP c2 c1 -> g a1 b1 c1 -> g a2 b2 c2

-- | Representation dispatcher for monomorphic types (kind <tt>*</tt>) used
--   with <a>Generic</a>. Every structure type and supported datatype
--   should have an instance of <a>Rep</a>.
class Rep g a
rep :: Rep g a => g a

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic</a>.
class FRep g f
frep :: FRep g f => g a -> g (f a)

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic2</a>.
class FRep2 g f
frep2 :: FRep2 g f => g a b -> g (f a) (f b)

-- | Representation dispatcher for functor types (kind <tt>* -&gt; *</tt>)
--   used with <a>Generic3</a>.
class FRep3 g f
frep3 :: FRep3 g f => g a b c -> g (f a) (f b) (f c)

-- | Representation dispatcher for bifunctor types (kind <tt>* -&gt;
--   *</tt>) used with <a>Generic2</a>.
class BiFRep2 g f
bifrep2 :: BiFRep2 g f => g a1 b1 -> g a2 b2 -> g (f a1 a2) (f b1 b2)

-- | Collect values of type <tt>b</tt> from some value of type <tt>a</tt>.
--   An <a>empty</a> means no values were collected. If you expected
--   otherwise, be sure that you have an instance such as <tt><a>Rep</a>
--   (<a>Collect</a> B) B</tt> for the type <tt>B</tt> that you are
--   collecting.
--   
--   <tt>collect</tt> works by searching a datatype for values that are the
--   same type as the return type specified. Here are some examples using
--   the same value with different return types:
--   
--   <pre>
--   ghci&gt; let x = [<a>Left</a> 1, <a>Right</a> 'a', <a>Left</a> 2] :: [<a>Either</a> <a>Int</a> <a>Char</a>]
--   ghci&gt; collect x :: [<a>Int</a>]
--   [1,2]
--   ghci&gt; collect x :: [<a>Char</a>]
--   "a"
--   ghci&gt; collect x == x
--   <a>True</a>
--   </pre>
--   
--   Note that the numerical constants have been declared <a>Int</a> using
--   the type annotation. Since these natively have the type <tt><a>Num</a>
--   a =&gt; a</tt>, you may need to give explicit types. By design, there
--   is no connection that can be inferred between the return type and the
--   argument type.
--   
--   <tt>collect</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Collect</a></tt>.
collect :: (Alternative f, Rep (Collect f b) a) => a -> f b

-- | Compare two values and return an <a>Ordering</a> (i.e. <tt>LT</tt>,
--   <tt>GT</tt>, or <tt>EQ</tt>). This is implemented exactly as if the
--   datatype was <tt>deriving Ord</tt>.
compare :: Rep Compare a => a -> a -> Ordering

-- | Equal to. Returns <tt>x == y</tt>.
eq :: Rep Compare a => a -> a -> Bool

-- | Not equal to. Returns <tt>x /= y</tt>.
neq :: Rep Compare a => a -> a -> Bool

-- | Less than. Returns <tt>x &lt; y</tt>.
lt :: Rep Compare a => a -> a -> Bool

-- | Less than or equal to. Returns <tt>x &lt;= y</tt>.
lteq :: Rep Compare a => a -> a -> Bool

-- | Greater than. Returns <tt>x &gt; y</tt>.
gt :: Rep Compare a => a -> a -> Bool

-- | Greater than or equal to. Returns <tt>x &gt;= y</tt>.
gteq :: Rep Compare a => a -> a -> Bool

-- | The minimum of two values.
min :: Rep Compare a => a -> a -> a

-- | The maximum of two values.
max :: Rep Compare a => a -> a -> a

-- | Associativity of the binary operator used for <a>crush</a>
data Assoc

-- | Left-associative
AssocLeft :: Assoc

-- | Right-associative
AssocRight :: Assoc

-- | Apply a function (<tt>a -&gt; b -&gt; b</tt>) to each element
--   (<tt>a</tt>) of a container (<tt>f a</tt>) and an accumulator value
--   (<tt>b</tt>) to produce an accumulated result (<tt>b</tt>).
--   
--   This is the most general form in which you must specify the
--   associativity. You may prefer to use <a>crushr</a> or <a>crushl</a>.
crush :: FRep (Crush b) f => Assoc -> (a -> b -> b) -> b -> f a -> b

-- | A left-associative variant of <a>crush</a>.
crushl :: FRep (Crush b) f => (a -> b -> b) -> b -> f a -> b

-- | A right-associative variant of <a>crush</a>.
crushr :: FRep (Crush b) f => (a -> b -> b) -> b -> f a -> b

-- | Flatten the elements of a container into a list.
--   
--   This is the most general form in which you must specify the
--   associativity. You may prefer to use <a>flattenr</a> or
--   <a>flattenl</a>.
flatten :: FRep (Crush [a]) f => Assoc -> f a -> [a]

-- | A left-associative variant of <a>flatten</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>flattenl ls == reverse
--   ls</tt>.
flattenl :: FRep (Crush [a]) f => f a -> [a]

-- | A right-associative variant of <a>flatten</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>flattenr ls == ls</tt>.
flattenr :: FRep (Crush [a]) f => f a -> [a]

-- | Extract the first element of a container. <a>fail</a> if the container
--   is empty.
--   
--   This is the most general form in which you must specify the
--   associativity and the <a>Monad</a> instance. You may prefer to use the
--   more convenient <a>firstr</a> or <a>firstl</a>.
first :: (Monad m, FRep (Crush [a]) f) => Assoc -> f a -> m a

-- | A left-associative <a>Maybe</a> variant of <a>first</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>fromJust (firstl ls) ==
--   last ls</tt>.
firstl :: FRep (Crush [a]) f => f a -> Maybe a

-- | A right-associative <a>Maybe</a> variant of <a>first</a>.
--   
--   Note that, for a list <tt>ls :: [a]</tt>, <tt>fromJust (firstr ls) ==
--   head ls</tt>.
firstr :: FRep (Crush [a]) f => f a -> Maybe a

-- | Compute the conjunction of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
and :: FRep (Crush Bool) f => f Bool -> Bool

-- | Compute the disjunction of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
or :: FRep (Crush Bool) f => f Bool -> Bool

-- | Determine if any element in a container satisfies the predicate
--   <tt>p</tt>. This is a generalization of the <tt>Prelude</tt> function
--   of the same name.
any :: FRep (Crush Bool) f => (a -> Bool) -> f a -> Bool

-- | Determine if all elements in a container satisfy the predicate
--   <tt>p</tt>. This is a generalization the <tt>Prelude</tt> function of
--   the same name.
all :: FRep (Crush Bool) f => (a -> Bool) -> f a -> Bool

-- | Compute the sum of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
sum :: (Num a, FRep (Crush a) f) => f a -> a

-- | Compute the product of all elements in a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
product :: (Num a, FRep (Crush a) f) => f a -> a

-- | Determine the minimum element of a container. If the container is
--   empty, return <a>Nothing</a>. This is a generalization of the
--   <tt>Prelude</tt> function of the same name.
minimum :: (Rep Compare a, FRep (Crush (Maybe a)) f) => f a -> Maybe a

-- | Determine the maximum element of a container. If the container is
--   empty, return <a>Nothing</a>. This is a generalization of the
--   <tt>Prelude</tt> function of the same name.
maximum :: (Rep Compare a, FRep (Crush (Maybe a)) f) => f a -> Maybe a

-- | Determine if an element is a member of a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
elem :: (Rep Compare a, FRep (Crush Bool) f) => a -> f a -> Bool

-- | Determine if an element is not a member of a container. This is a
--   generalization of the <tt>Prelude</tt> function of the same name.
notElem :: (Rep Compare a, FRep (Crush Bool) f) => a -> f a -> Bool

-- | Enumerate the values of a datatype. If the number of values is
--   infinite, the result will be an infinite list. The remaining functions
--   are derived from <a>enum</a>.
enum :: Rep Enum a => [a]

-- | Enumerate the first <tt>n</tt> values of a datatype. This is a
--   shortcut for <tt><a>genericTake</a> n (<a>enum</a>)</tt>.
enumN :: (Integral n, Rep Enum a) => n -> [a]

-- | Returns the first element of the enumeration from <a>enum</a>. This is
--   often called the neutral or empty value.
empty :: Rep Enum a => a

-- | Apply a transformation <tt>a -&gt; a</tt> to values of type <tt>a</tt>
--   within the argument of type <tt>b</tt> in a bottom-up manner. Values
--   that do not have type <tt>a</tt> are passed through <a>id</a>.
--   
--   <tt>everywhere</tt> works by searching the datatype <tt>b</tt> for
--   values that are the same type as the function argument type
--   <tt>a</tt>. Here are some examples using the datatype declared in the
--   documentation for <a>Everywhere</a>.
--   
--   <pre>
--   ghci&gt; let f t = case t of { Val i -&gt; Val (i+(1::<a>Int</a>)); other -&gt; other }
--   ghci&gt; everywhere f (Val (1::<a>Int</a>))
--   Val 2
--   ghci&gt; everywhere f (Rec (Rec (Val (1::<a>Int</a>))))
--   Rec (Rec (Val 2))
--   </pre>
--   
--   <pre>
--   ghci&gt; let x = [<a>Left</a> 1, <a>Right</a> 'a', <a>Left</a> 2] :: [<a>Either</a> <a>Int</a> <a>Char</a>]
--   ghci&gt; everywhere (*(3::<a>Int</a>)) x
--   [<a>Left</a> 3,<a>Right</a> 'a',<a>Left</a> 6]
--   ghci&gt; everywhere (\x -&gt; x :: <a>Float</a>) x == x
--   <a>True</a>
--   </pre>
--   
--   Note the type annotations. Since numerical constants have the type
--   <tt><a>Num</a> a =&gt; a</tt>, you may need to give explicit types.
--   Also, the function <tt>\x -&gt; x</tt> has type <tt>a -&gt; a</tt>,
--   but we need to give it some non-polymorphic type here. By design,
--   there is no connection that can be inferred between the value type and
--   the function type.
--   
--   <tt>everywhere</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Everywhere</a></tt>.
everywhere :: Rep (Everywhere a) b => (a -> a) -> b -> b

-- | Apply a transformation <tt>a -&gt; a</tt> to values of type <tt>a</tt>
--   within the argument of type <tt>b</tt> in a top-down manner. Values
--   that do not have type <tt>a</tt> are passed through <a>id</a>.
--   
--   <tt>everywhere'</tt> is the same as <a>everywhere</a> with the
--   exception of recursive datatypes. For example, compare the example
--   used in the documentation for <a>everywhere</a> with the following.
--   
--   <pre>
--   ghci&gt; let f t = case t of { Val i -&gt; Val (i+(1::<a>Int</a>)); other -&gt; other }
--   ghci&gt; everywhere' f (Val (1::<a>Int</a>))
--   Val 2
--   ghci&gt; everywhere' f (Rec (Rec (Val (1::<a>Int</a>))))
--   Rec (Rec (Val 1))
--   </pre>
--   
--   <tt>everywhere'</tt> only works if there is an instance for the return
--   type as described in the <tt>newtype <a>Everywhere'</a></tt>.
everywhere' :: Rep (Everywhere' a) b => (a -> a) -> b -> b

-- | Apply a function to all elements of a container datatype (kind <tt>*
--   -&gt; *</tt>).
map :: FRep2 Map f => (a -> b) -> f a -> f b

-- | Replace all <tt>a</tt>-values in <tt>f a</tt> with <tt>b</tt>. Defined
--   as: <tt> replace as b = map (const b) as </tt>
replace :: FRep2 Map f => f a -> b -> f b

-- | Given a datatype <tt>F a b</tt>, <tt>bimap f g</tt> applies the
--   function <tt>f :: a -&gt; c</tt> to every <tt>a</tt>-element and the
--   function <tt>g :: b -&gt; d</tt> to every <tt>b</tt>-element. The
--   result is a value with transformed elements: <tt>F c d</tt>.
bimap :: BiFRep2 Map f => (a -> c) -> (b -> d) -> f a b -> f c d

-- | Cast a value of one type into a value of another. This is a
--   configurable function that allows you to define your own type-safe
--   conversions for a variety of types.
--   
--   <tt>cast</tt> works with instances of <tt><a>Rep</a> (<a>Map</a> i)
--   o</tt> in which you choose the input type <tt>i</tt> and the output
--   type <tt>o</tt> and implement the function of type <tt>i -&gt; o</tt>.
--   
--   Here are some examples of instances (and flags you will need or want):
--   
--   <pre>
--   {-# LANGUAGE MultiParamTypeClasses  #-}
--   {-# LANGUAGE FlexibleContexts       #-}
--   {-# LANGUAGE FlexibleInstances      #-}
--   {-# OPTIONS_GHC -fno-warn-orphans   #-}
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Int</a>) <a>Char</a> where
--     <a>rep</a> = <a>Map</a> <tt>chr</tt>
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Float</a>) <a>Double</a> where
--     <a>rep</a> = <a>Map</a> <a>realToFrac</a>
--   </pre>
--   
--   <pre>
--   instance <a>Rep</a> (<a>Map</a> <a>Integer</a>) <a>Integer</a> where
--     <a>rep</a> = <a>Map</a> (+42)
--   </pre>
--   
--   There are no pre-defined instances, and a call to <tt>cast</tt> will
--   not compile if no instances for the input and output type pair are
--   found, so you must define instances in order to use <tt>cast</tt>.
cast :: Rep (Map a) b => a -> b

-- | A class to reveal the embedding-projection pair for a given datatype
--   and its isomorphic representation type.
class HasEP a b | a -> b
epOf :: HasEP a b => a -> EP a b

-- | Returns a constructor description if the value is not a primitive. The
--   argument is not evaluated and may be <tt>undefined</tt>.
conDescr :: Rep Con a => a -> Maybe ConDescr

-- | Returns a list of descriptions for all labels in the head constructor.
--   Does not recurse into the children. The argument is not evaluated and
--   may be <tt>undefined</tt>.
lblDescrs :: Rep Lbls a => a -> [LblDescr]

-- | Generate a <a>ReadPrec</a> parser combinator for the datatype
--   <tt>a</tt> that handles operator precedence. This uses the library in
--   <a>Text.ParserCombinators.ReadPrec</a> and should be similar to a
--   derived implementation of <tt>Text.Read.readPrec</tt>.
readPrec :: Rep Read a => ReadPrec a

-- | Generate a <a>ReadP</a> parser combinator for the datatype <tt>a</tt>.
--   This can be used with <tt>Text.ParserCombinators.ReadP</tt>.
readP :: Rep Read a => Int -> ReadP a

-- | Attempt to parse a value from the front of the string using the given
--   precedence. <a>readsPrec</a> returns a list of (parsed value,
--   remaining string) pairs. If parsing fails, <a>readsPrec</a> returns an
--   empty list.
readsPrec :: Rep Read a => Int -> ReadS a

-- | A variant of <a>readsPrec</a> with the minimum precedence (0).
reads :: Rep Read a => ReadS a

-- | A variant of <a>reads</a> that returns <tt>Just value</tt> on a
--   successful parse. Otherwise, <a>read</a> returns <a>Nothing</a>. Note
--   that a successful parse requires the input to be completely consumed.
read :: Rep Read a => String -> Maybe a

-- | Convert a value to a readable string starting with the operator
--   precedence of the enclosing context.
showsPrec :: Rep Show a => Int -> a -> ShowS

-- | A variant of <a>showsPrec</a> with the minimum precedence (0).
shows :: Rep Show a => a -> ShowS

-- | A variant of <a>shows</a> that returns a <a>String</a> instead of
--   <a>ShowS</a>.
show :: Rep Show a => a -> String

-- | Transposes the structure of nested containers (types <tt>f</tt> and
--   <tt>g</tt>). <a>fail</a> if the outermost container is empty, because
--   there is no generic way to guarantee that both have unit constructors
--   or, if they do, decide which one to choose. See <a>transposeE</a> for
--   an alternative approach.
transpose :: (Monad m, FRep (Crush [g a]) f, FRep2 (Transpose m g a) f) => f (g a) -> m (g (f a))

-- | A convenient version of <a>transpose</a> that returns the <a>empty</a>
--   value on failure.
transposeE :: (Rep Enum (g (f a)), FRep (Crush [g a]) f, FRep2 (Transpose Maybe g a) f) => f (g a) -> g (f a)

-- | Splits a container into two structurally equivalent containers by
--   applying a function to every element, which splits it into two
--   corresponding elements. Fails if the spliting function fails
unzipWithM :: (Monad m, FRep3 (UnzipWith m) f) => (a -> m (b, c)) -> f a -> m (f b, f c)

-- | A specialized version of <a>unzipWithM</a> using the identity monad
--   and a splitting function that does not fail.
unzipWith :: FRep3 (UnzipWith Id) f => (a -> (b, c)) -> f a -> (f b, f c)

-- | A specialized version of <a>unzipWith</a> for pairs. Generic version
--   of <tt>Prelude.unzip</tt>.
unzip :: FRep3 (UnzipWith Id) f => f (b, c) -> (f b, f c)

-- | Combine two structurally equivalent containers into one by applying a
--   function to every corresponding pair of elements. Fails if (1) the
--   binary operator fails or (2) <tt>f a</tt> and <tt>f b</tt> have
--   different shapes.
zipWithM :: (Monad m, FRep3 (ZipWith m) f) => (a -> b -> m c) -> f a -> f b -> m (f c)

-- | A specialized version of <a>zipWithM</a> for the <a>Maybe</a> monad
--   and a binary operator that does not fail. Generic version of
--   <tt>Prelude.zipWith</tt>.
zipWith :: FRep3 (ZipWith Maybe) f => (a -> b -> c) -> f a -> f b -> Maybe (f c)

-- | A specialized version of <a>zipWith</a> for pairs. Generic version of
--   <tt>Prelude.zip</tt>.
zip :: FRep3 (ZipWith Maybe) f => f a -> f b -> Maybe (f (a, b))
