-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stompl Client Library
--   
@package stomp-queue
@version 0.2.2


-- | Exceptions for the Stompl Client. Note that exceptions thrown in
--   internal worker threads (sender and listener) will be forwarded to the
--   connection owner, that is the thread that actually initialised the
--   connection. Since, in some circumstances, several exceptions may be
--   thrown in response to one error event (<i>e.g.</i> the broker sends an
--   error frame and, immediately afterwards, closes the connection), the
--   connection owner should implement a robust exception handling
--   mechanism.
module Network.Mom.Stompl.Client.Exception
data StomplException

-- | Currently not used
SocketException :: String -> StomplException

-- | Thrown when a worker thread terminates unexpectedly; usually, this is
--   a consequence of another error (<i>e.g.</i> the broker closed the
--   socket) and you will probably receive another exception (<i>e.g.</i> a
--   BrokerException)
WorkerException :: String -> StomplException

-- | Thrown when something against the protocol happens, <i>e.g.</i> an
--   unexpected frame is received or a message from a queue that was not
--   subscribed
ProtocolException :: String -> StomplException

-- | Thrown on wrong uses of queues, <i>e.g.</i> use of a queue outside its
--   scope
QueueException :: String -> StomplException

-- | Thrown on transaction errors, <i>e.g.</i> pending acks
TxException :: String -> StomplException

-- | Thrown on connection errors, <i>e.g.</i> connection was closed
ConnectException :: String -> StomplException

-- | Should be thrown by user-defined converters
ConvertException :: String -> StomplException

-- | Thrown when an error frame is received
BrokerException :: String -> StomplException

-- | Thrown by <i>abort</i>
AppException :: String -> StomplException

-- | You hit a bug! This exception is only thrown when something really
--   strange happened
OuchException :: String -> StomplException

-- | Catches any <a>StomplException</a>, including asynchronous exceptions
--   coming from internal threads
try :: IO a -> IO (Either StomplException a)

-- | Throws <a>ConvertException</a> to signal a conversion error.
convertError :: String -> IO a
instance Typeable StomplException
instance Show StomplException
instance Read StomplException
instance Eq StomplException
instance Exception StomplException


-- | The Stomp Protocol specifies message-oriented interoperability.
--   Applications connect to a message broker to send (publish) or receive
--   (subscribe) messages through queues. Interoperating applications do
--   not know the location or internal structure of each other. They only
--   see interfaces, <i>i.e.</i> the messages published and subscribed
--   through the broker.
--   
--   The Stompl Client library implements a Stomp client using abstractions
--   like <a>Connection</a>, <a>Transaction</a> and queues in terms of
--   <a>Reader</a> and <a>Writer</a>.
module Network.Mom.Stompl.Client.Queue

-- | Initialises a connection and executes an <a>IO</a> action. The
--   connection lifetime is the scope of this action. The connection
--   handle, <a>Con</a>, that is passed to the action should not be
--   returned from <a>withConnection</a>. Connections, however, can be
--   shared among threads. In this case, the programmer has to take care
--   not to terminate the action before all other threads working on the
--   connection have finished.
--   
--   Since <a>Connection</a> is a heavy data type, you should try to reduce
--   the number of connections to the same broker within the same process -
--   there is ideally only one connection per broker in one process.
--   
--   Paramter:
--   
--   <ul>
--   <li><a>String</a>: The broker's hostname or IP-address</li>
--   <li><a>Int</a>: The broker's port</li>
--   <li><a>Copt</a>: Control options passed to the connection (including
--   user/password)</li>
--   <li><tt>Header</tt>: List of additional, broker-specific headers</li>
--   <li>(<a>Con</a> -&gt; <a>IO</a> a): The action to execute. The action
--   receives the connection handle and returns a value of type <i>a</i> in
--   the <a>IO</a> monad.</li>
--   </ul>
--   
--   <a>withConnection</a> returns the result of the action passed into it.
--   
--   <a>withConnection</a> will always disconnect from the broker when the
--   action has terminated, even if an exception is raised.
--   
--   Example:
--   
--   <pre>
--   withConnection "localhost" 61613 [] [] $ \c -&gt; do
--   </pre>
--   
--   This would connect to a broker listening to the loopback interface,
--   port number 61613. The action is defined after the <i>hanging do</i>.
--   
--   Internally, connections use concurrent threads; errors are
--   communicated by throwing exceptions to the owner of the connection,
--   where the owner is the thread that created the connection calling
--   <a>withConnection</a>. It is therefore advisable to start different
--   connections in different threads, so that each thread will receive
--   only exceptions related to the connection it has opened.
withConnection :: String -> Int -> [Copt] -> [Header] -> (Con -> IO a) -> IO a

-- | Opaque Connection handle. Only valid within the action passed to
--   <i>withConnection</i>.
data Con

-- | Heart-beat configuration; the first <a>Int</a> of the pair represents
--   the frequency in which the sender wants to send heart-beats; the
--   second represents the highest frequency in which the sender can accept
--   heart-beats. The frequency is expressed as the period in milliseconds
--   between two heart-beats. For details on negotiating heart-beats,
--   please refer to the Stomp specification.
type Heart = (Int, Int)

-- | Options passed to a connection
data Copt

-- | Tells the connection to wait <i>n</i> milliseconds for the
--   <a>Receipt</a> sent with <a>Disconnect</a> at the end of the session.
--   The <i>Stomp</i> protocol advises to request a receipt and to wait for
--   it before actually closing the socket. Many brokers, however, do not
--   implement this feature (or implement it inappropriately, closing the
--   connection immediately after having sent the receipt).
--   <tt>withConnection</tt>, for this reason, ignores the receipt by
--   default and simply closes the socket after having sent the
--   <a>Disconnect</a> frame. If your broker shows a correct behaviour, it
--   is advisable to use this option.
OWaitBroker :: Int -> Copt

-- | Wait <i>n</i> milliseconds after the connection has been closed by the
--   broker to give the library some time to process the error message (if
--   one has been sent).
OWaitError :: Int -> Copt

-- | The maximum size of TCP/IP packets. This option is currently ignored.
--   Instead, <a>Network</a> defines the packet size (currently hard-wired
--   4KB). The maximum message size is 1024 times this value, <i>i.e.</i>
--   4MB.
OMaxRecv :: Int -> Copt

-- | This option defines the client's bid for negotiating heartbeats
--   providing an accepted lower and upper bound expessed as milliseconds
--   between heartbeats. By default, no heart beats are sent or accepted
OHeartBeat :: (Heart) -> Copt

-- | Authentication: user and password
OAuth :: String -> String -> Copt

-- | Identification: specifies the JMS Client ID for persistent connections
OClientId :: String -> Copt

-- | With this option set, "connect" will use a <a>STOMP</a> frame instead
--   of a <a>CONNECT</a> frame
OStomp :: Copt

-- | Connection timeout in milliseconds; if the broker does not respond to
--   a connect request within this time frame, a <a>ConnectException</a> is
--   thrown. If the value is &lt;= 0, the program will wait forever.
OTmo :: Int -> Copt

-- | <a>TLSClientConfig</a> (see <a>TLS</a> for details) for TLS
--   connections. If the option is not given, a plain TCP/IP connection is
--   used.
OTLS :: TLSClientConfig -> Copt

-- | Action to handle Error frames; if the option is not given, an
--   exception is raised on arrival of an error frame. If it is given, one
--   should also pass a value for OWaitError to give the error handler time
--   to execute.
OEH :: EHandler -> Copt

-- | Action executed when an Error Frame is received; the typical use case
--   is logging the text of the Error Frame.
type EHandler = Con -> Frame -> IO ()

-- | A Queue for receiving messages
data Reader a

-- | A Queue for sending messages.
data Writer a

-- | Creates a <a>Reader</a> with the lifetime of the connection
--   <a>Con</a>. Creating a receiving queue involves interaction with the
--   broker; this may result in preempting the calling thread, depending on
--   the options [<a>Qopt</a>].
--   
--   Parameters:
--   
--   <ul>
--   <li>The connection handle <a>Con</a></li>
--   <li>A queue name that should be unique in your application. The queue
--   name is used only for debugging.</li>
--   <li>The Stomp destination, <i>i.e.</i> the name of the queue as it is
--   known to the broker and other applications.</li>
--   <li>A list of options (<a>Qopt</a>).</li>
--   <li>A list of headers (<a>Header</a>), which will be passed to the
--   broker. A header may be, for instance, a selector that restricts the
--   subscription to this queue, such that only messages with certain
--   attributes (<i>i.e.</i> specific headers) are sent to the subscribing
--   client. Selectors are broker-specific and typically expressed in some
--   kind of query language such as SQL or XPath.</li>
--   <li>An in-bound converter.</li>
--   </ul>
--   
--   A usage example to create a <a>Reader</a> with <a>Connection</a>
--   <i>c</i> and the in-bound converter <i>iconv</i> would be:
--   
--   <pre>
--   q &lt;- newReader c "TestQ" "/queue/test" [] [] iconv
--   </pre>
--   
--   A call to <a>newReader</a> may result in preemption when one of the
--   options <a>OWaitReceipt</a> or <a>OWithReceipt</a> are given; an
--   example for such a call with <i>tmo</i> an <a>Int</a> value
--   representing a <i>timeout</i> in microseconds and the result
--   <i>mbQ</i> of type <a>Maybe</a> is:
--   
--   <pre>
--   mbQ &lt;- timeout tmo $ newReader c "TestQ" "/queue/test" [OWaitReceipt] [] oconv
--   case mbQ of
--     Nothing -&gt; -- handle error
--     Just q  -&gt; do -- ...
--   </pre>
--   
--   A newReader stores data in the connection <i>c</i>. If the lifetime of
--   a reader is shorter than that of its connection it should call
--   <a>destroyReader</a> to avoid memory leaks. In such cases, it is
--   usually preferable to use <a>withReader</a>.
newReader :: Con -> String -> String -> [Qopt] -> [Header] -> InBound a -> IO (Reader a)

-- | Removes all references to the reader from the connection.
destroyReader :: Reader a -> IO ()

-- | Creates a <a>Writer</a> with the lifetime of the connection
--   <a>Con</a>. Creating a sending queue does not involve interaction with
--   the broker and will not preempt the calling thread.
--   
--   A sending queue may be created like in the following code fragment,
--   where <i>oconv</i> is an already defined out-bound converter:
--   
--   <pre>
--   q &lt;- newWriter c "TestQ" "/queue/test" [] [] oconv
--   </pre>
--   
--   Currently no references to the writer are stored in the connection. It
--   is advisable, however, to use <a>withWriter</a> instead of
--   <a>newWriter</a> whenever the lifetime of a writer is shorter than
--   that of the connection. In cases where this is not possible, you
--   should use <a>destroyWriter</a> when the writer is not needed anymore.
--   Currently <a>destroyWriter</a> does nothing, but this may change in
--   the future.
newWriter :: Con -> String -> String -> [Qopt] -> [Header] -> OutBound a -> IO (Writer a)

-- | Does nothing, but should be used with <a>newWriter</a>.
destroyWriter :: Writer a -> IO ()

-- | Creates a <a>Reader</a> with limited lifetime. The queue will live
--   only in the scope of the action that is passed as last parameter. The
--   function is useful for readers with a lifetime shorter than that of
--   the connection. When the action terminates, the client unsubscribes
--   from the broker queue - even if an exception is raised.
--   
--   <a>withReader</a> returns the result of the action. Since the lifetime
--   of the queue is limited to the action, it should not be returned. Any
--   operation on a reader created by <a>withReader</a> outside the action
--   will raise <a>QueueException</a>.
--   
--   A usage example is:
--   
--   <pre>
--   x &lt;- withReader c "TestQ" "/queue/test" [] [] iconv $ \q -&gt; do
--   </pre>
withReader :: Con -> String -> String -> [Qopt] -> [Header] -> InBound i -> (Reader i -> IO r) -> IO r

-- | Creates a <a>Writer</a> with limited lifetime. The queue will live
--   only in the scope of the action that is passed as last parameter. The
--   function should be used for writers with a lifetime shorter than that
--   of the connection.
--   
--   <a>withWriter</a> returns the result of the action. Since the lifetime
--   of the queue is limited to the action, it should not be returned. Any
--   operation on a writer created by <a>withWriter</a> outside the action
--   will raise a <a>QueueException</a>.
withWriter :: Con -> String -> String -> [Qopt] -> [Header] -> OutBound o -> (Writer o -> IO r) -> IO r

-- | Creates a pair of (<a>Reader</a> i, <a>Writer</a> o) with limited
--   lifetime. The pair will live only in the scope of the action that is
--   passed as last parameter. The function is useful for readers/writers
--   used in combination, <i>e.g.</i> to emulate a client/server kind of
--   communication.
--   
--   <a>withPair</a> returns the result of the action passed in.
--   
--   The parameters are:
--   
--   <ul>
--   <li>The connection handle <a>Con</a></li>
--   <li>The name of the pair; the reader will be identified by a string
--   with "_r" added to this name, the writer by a string with "_w" added
--   to this name.</li>
--   <li>The description of the <a>Reader</a>, <a>ReaderDesc</a></li>
--   <li>The description of the <a>Writer</a>, <a>WriterDesc</a></li>
--   <li>The application-defined action</li>
--   </ul>
--   
--   The reason for introducing the reader and writer description is to
--   provide error detection at compile time: It is this way much more
--   difficult to accidently confuse the writer's and the reader's
--   parameters (<i>e.g.</i> passing the writer's <a>Qopt</a>s to the
--   reader).
withPair :: Con -> String -> ReaderDesc i -> WriterDesc o -> ((Reader i, Writer o) -> IO r) -> IO r

-- | The <a>Reader</a> parameters of <a>withPair</a>:
--   
--   <ul>
--   <li>The reader's queue name <ul><li>The reader's
--   <a>Qopt</a>s</li><li>The reader's <tt>Header</tt>s</li><li>The
--   reader's (inbound) converter</li></ul></li>
--   </ul>
type ReaderDesc i = (String, [Qopt], [Header], InBound i)

-- | The <a>Writer</a> parameters of <a>withPair</a>
--   
--   <ul>
--   <li>The writer's queue name<ul><li>The writer's
--   <a>Qopt</a>s</li><li>The writer's <tt>Header</tt>s</li><li>The
--   writer's (outbound) converter</li></ul></li>
--   </ul>
type WriterDesc o = (String, [Qopt], [Header], OutBound o)

-- | Options that may be passed to <a>newReader</a> and <a>newWriter</a>
--   and their variants.
data Qopt

-- | A queue created with <a>OWithReceipt</a> will request a receipt on all
--   interactions with the broker. The handling of receipts is usually not
--   visible to applications, but may be made visible in the case of
--   sending messages using <a>writeQWith</a>. <a>writeQWith</a> return the
--   receipt identifier and the application can later invoke
--   <a>waitReceipt</a> to explicitly wait for the broker confirming this
--   receipt.
--   
--   A <a>Reader</a> created with <a>OWithReceipt</a> will issue a request
--   for receipt when subscribing to a Stomp queue.
OWithReceipt :: Qopt

-- | A queue created with <a>OWaitReceipt</a> will wait for the receipt
--   before returning from a call that has issued a request for receipt.
--   This implies that the current thread will yield the processor.
--   <a>writeQ</a> will internally create a request for receipt and wait
--   for the broker to confirm the receipt before returning. Note that, for
--   <a>newReader</a>, there is no difference between <a>OWaitReceipt</a>
--   and <a>OWithReceipt</a>. Either option will cause the thread to
--   preempt until the receipt is confirmed.
--   
--   On writing a message, this is not always the preferred method. You may
--   want to fire and forget - and check for the confirmation of the
--   receipt only later. In this case, you will create the <a>Writer</a>
--   with <a>OWithReceipt</a> only and, later, after having sent a message
--   with <a>writeQWith</a>, wait for the receipt using <a>waitReceipt</a>.
--   Note that <a>OWaitReceipt</a> without <a>OWithReceipt</a> has no
--   meaning with <a>writeQ</a> and <a>writeQWith</a>. If you want to
--   request a receipt with a message and wait for the broker to confirm
--   it, you have to use both options.
--   
--   It is good practice to use <i>timeout</i> with all calls that may wait
--   for receipts, <i>i.e.</i> <a>newReader</a> and <a>withReader</a> with
--   options <a>OWithReceipt</a> or <a>OWaitReceipt</a>, or <a>writeQ</a>
--   and <a>writeQWith</a> with options <a>OWaitReceipt</a>, or
--   <a>ackWith</a> and <a>nackWith</a>.
OWaitReceipt :: Qopt

-- | The option defines the <a>AckMode</a> of the queue, which is relevant
--   for <a>Reader</a> only. <a>AckMode</a> is one of: <a>Auto</a>,
--   <a>Client</a>, <a>ClientIndi</a>.
--   
--   If <a>OMode</a> is not given, <a>Auto</a> is assumed as default.
--   
--   For more details, see <a>AckMode</a>.
OMode :: AckMode -> Qopt

-- | Expression often used by Ren√© Artois. Furthermore, if <a>OMode</a> is
--   either <a>Client</a> or <a>ClientIndi</a>, then this option forces
--   <a>readQ</a> to send an acknowledgement automatically when a message
--   has been read from the queue.
OAck :: Qopt

-- | A queue created with <a>OForceTx</a> will throw <a>QueueException</a>
--   when used outside a <a>Transaction</a>.
OForceTx :: Qopt

-- | Do not automatically add a content-length header
ONoContentLen :: Qopt
data AckMode :: *

-- | A successfully sent message is automatically considered ack'd
Auto :: AckMode

-- | The client is expected to explicitly confirm the receipt of a message
--   by sending an <a>Ack</a> frame; all message older than the ack'd
--   message since the last <a>Ack</a> (or the beginning of the session)
--   are implicitly ack'd as well. This is called <i>cumulative</i> ack.
Client :: AckMode

-- | Non-cumulative ack: The client is expected to explicitly confirm the
--   receipt of a message by sending an <a>Ack</a> frame; only the message
--   with the msg-id in the <a>Ack</a> frame is actually ack'd
ClientIndi :: AckMode

-- | Converters are user-defined actions passed to <a>newReader</a>
--   (<a>InBound</a>) and <a>newWriter</a> (<a>OutBound</a>) that convert a
--   <a>ByteString</a> to a value of type <i>a</i> (<a>InBound</a>) or a
--   value of type <i>a</i> to <a>ByteString</a> (<a>OutBound</a>).
--   Converters are, hence, similar to <i>put</i> and <i>get</i> in the
--   <i>Binary</i> monad.
--   
--   The reason for using explicit, user-defined converters instead of
--   <i>Binary</i> <i>encode</i> and <i>decode</i> is that the conversion
--   with queues may be much more complex, involving reading configurations
--   or other <a>IO</a> actions. Furthermore, we have to distinguish
--   between data types and there binary encoding when sent over the
--   network. This distinction is made by <i>MIME</i> types. Two
--   applications may send the same data type, but one encodes this type as
--   "text/plain", the other as "text/xml". <a>InBound</a> conversions have
--   to consider the <i>MIME</i> type and, hence, need more input
--   parameters than provided by <i>decode</i>. <i>encode</i> and
--   <i>decode</i>, however, can be used internally by user-defined
--   converters.
--   
--   The parameters expected by an <a>InBound</a> converter are:
--   
--   <ul>
--   <li>the <i>MIME</i> type of the content<ul><li>the content
--   size</li><li>the list of <a>Header</a> coming with the
--   message</li><li>the content encoded as
--   <a>ByteString</a>.</li></ul></li>
--   </ul>
--   
--   A simple in-bound converter for plain strings is for instance:
--   
--   <pre>
--   let iconv _ _ _ = return . unpack
--   </pre>
type InBound a = Type -> Int -> [Header] -> ByteString -> IO a

-- | Out-bound converters are much simpler. Since the application developer
--   knows, which encoding to use, the <i>MIME</i> type is not needed. The
--   converter receives only the value of type <i>a</i> and converts it
--   into a <a>ByteString</a>. A simple example to create an out-bound
--   converter for plain strings could be:
--   
--   <pre>
--   let oconv = return . pack
--   </pre>
type OutBound a = a -> IO ByteString

-- | Removes the oldest message from the queue and returns it as
--   <a>Message</a>. The message cannot be read from the queue by another
--   call to <a>readQ</a> within the same connection. Wether other
--   connections will receive the message too depends on the broker and the
--   queue patterns it implements. If the queue is currently empty, the
--   thread will preempt until a message arrives.
--   
--   If the queue was created with <a>OMode</a> other than <a>Auto</a> and
--   with <a>OAck</a>, then an <i>ack</i> will be automatically sent to the
--   broker; if <a>OAck</a> was not set, the message will be registered as
--   pending <i>ack</i>.
--   
--   Note that, when <a>readQ</a> sends an <i>ack</i> internally, it will
--   not request a receipt from the broker. The rationale for this design
--   is simplicity. If the function expected a receipt, it would have to
--   either wait for the receipt or return it. In the first case, it would
--   be difficult for the programmer to distinguish, on a timeout, between
--   <i>no message available</i> and <i>no receipt arrived</i>. In the
--   second case, the receipt would need to be returned. This would
--   unnecessarily blow up the interface. If you need the reliability of
--   receipts, you should create the queue without <a>OAck</a> and use
--   <a>ackWith</a> to acknowledge the message explicitly.
readQ :: Reader a -> IO (Message a)

-- | Adds the value <i>a</i> as message at the end of the queue. The Mime
--   type as well as the headers are added to the message.
--   
--   If the queue was created with the option <a>OWithReceipt</a>,
--   <a>writeQ</a> will request a receipt from the broker. If the queue was
--   additionally created with <a>OWaitReceipt</a>, <a>writeQ</a> will
--   preempt until the receipt is confirmed.
--   
--   The Stomp headers are useful for brokers that provide selectors on
--   <i>subscribe</i>, see <a>newReader</a> for details.
--   
--   A usage example for a <a>Writer</a> <i>q</i> of type <a>String</a> may
--   be (<i>nullType</i> is defined as <i>text</i>/<i>plain</i> in
--   Codec.MIME):
--   
--   <pre>
--   writeQ q nullType [] "hello world!"
--   </pre>
--   
--   For a <a>Writer</a> that was created with <a>OWithReceipt</a> and
--   <a>OWaitReceipt</a>, the function should be called with
--   <i>timeout</i>:
--   
--   <pre>
--   mbR &lt;- timeout tmo $ writeQ q nullType [] "hello world!"
--   case mbR of
--     Nothing -&gt; -- error handling
--     Just r  -&gt; do -- ...
--   </pre>
writeQ :: Writer a -> Type -> [Header] -> a -> IO ()

-- | This is a variant of <a>writeQ</a> that is particularly useful for
--   queues created with <a>OWithReceipt</a>, but without
--   <a>OWaitReceipt</a>. It returns the <a>Receipt</a>, so that it can be
--   waited for later, using <a>waitReceipt</a>.
--   
--   Note that the behaviour of <a>writeQWith</a>, besides of returning the
--   receipt, is the same as <a>writeQ</a>, <i>i.e.</i>, on a queue with
--   <a>OWithReceipt</a> and <a>OWaitReceipt</a> <a>writeQWith</a> will
--   wait for the receipt being confirmed. In this case, the returned
--   receipt is, in fact, of no further use for the application.
--   
--   The function is used like:
--   
--   <pre>
--   r &lt;- writeQWith q nullType [] "hello world!"
--   </pre>
writeQWith :: Writer a -> Type -> [Header] -> a -> IO Receipt

-- | This is a variant of <a>writeQ</a> that overwrites the destination
--   queue defined in the writer queue. It can be used for <i>ad hoc</i>
--   communication and for emulations of client/server-like protocols: the
--   client would pass the name of the queue where it expects the server
--   response in a header; the server would send the reply to the queue
--   indicated in the header using <a>writeAdHoc</a>. The additional
--   <a>String</a> parameter contains the destination.
writeAdHoc :: Writer a -> String -> Type -> [Header] -> a -> IO ()

-- | This is a variant of <a>writeAdHoc</a> that is particularly useful for
--   queues created with <a>OWithReceipt</a>, but without
--   <a>OWaitReceipt</a>. It returns the <a>Receipt</a>, so that it can be
--   waited for later, using <a>waitReceipt</a>. Please refer to
--   <a>writeQWith</a> for more details.
writeAdHocWith :: Writer a -> String -> Type -> [Header] -> a -> IO Receipt

-- | Any content received from a queue is wrapped in a message. It is, in
--   particular, the return value of <i>readQ</i>.
data Message a

-- | Returns the content of the message in the format produced by an
--   in-bound converter
msgContent :: Message a -> a

-- | The encoded content
msgRaw :: Message a -> ByteString

-- | The <i>MIME</i> type of the content
msgType :: Message a -> Type

-- | The length of the encoded content
msgLen :: Message a -> Int

-- | The Stomp headers that came with the message
msgHdrs :: Message a -> [Header]

-- | This is a receipt.
data Rec

-- | A valid receipt
Rec :: Int -> Rec

-- | No receipt was sent with this interaction. Receiving a <a>NoRec</a> is
--   not an error, but the result of an inconsistent - but harmless - use
--   of <i>writeQWith</i> on a queue that does not send receipts. An
--   application should, of course, not try to wait for a <a>NoRec</a>. It
--   will never be confirmed.
NoRec :: Rec

-- | Just a nicer word for <tt>Rec</tt>
type Receipt = Rec

-- | Waits for the <a>Receipt</a> to be confirmed by the broker. Since the
--   thread will preempt, the call should be protected with <i>timeout</i>,
--   <i>e.g.</i>:
--   
--   <pre>
--   mb_ &lt;- timeout tmo $ waitReceipt c r
--   case mb_ of
--    Nothing -&gt; -- error handling
--    Just _  -&gt; do -- ...
--   </pre>
waitReceipt :: Con -> Receipt -> IO ()
data Tx

-- | Starts a transaction and executes the action in the last parameter.
--   After the action has finished, the transaction will be either
--   committed or aborted even if an exception has been raised. Note that,
--   depending on the options, the way a transaction is terminated may
--   vary, refer to <a>Topt</a> for details.
--   
--   Transactions cannot be shared among threads. Transactions are
--   internally protected against access from any thread but the one that
--   has actually started the transaction.
--   
--   It is <i>not</i> advisable to use <a>withTransaction</a> with
--   <i>timeout</i>. It is preferred to use <i>timeout</i> on the the
--   actions executed within this transaction. Whether and how much time
--   the transaction itself shall wait for the completion of on-going
--   interactions with the broker, in particular pending receipts, shall be
--   controlled by the <a>OTimeout</a> option.
--   
--   <a>withTransaction</a> returns the result of the action.
--   
--   The simplest usage example with a <a>Connection</a> <i>c</i> is:
--   
--   <pre>
--   r &lt;- withTransaction c [] $ \_ -&gt; do
--   </pre>
--   
--   If the transaction shall use receipts and, before terminating, wait
--   100<i>ms</i> for all receipts to be confirmed by the broker
--   <a>withTransaction</a> is called like:
--   
--   <pre>
--   eiR &lt;- try $ withTransaction c [OTimeout 100, OWithReceipts] \_ -&gt; do
--   case eiR of
--     Left e  -&gt; -- error handling
--     Right x -&gt; do -- ..
--   </pre>
--   
--   Note that <a>try</a> is used to catch any <a>StomplException</a>.
withTransaction :: Con -> [Topt] -> (Tx -> IO a) -> IO a

-- | Options passed to a transaction.
data Topt

-- | The timeout in milliseconds (not microseconds!) to wait for <i>pending
--   receipts</i>. If receipts are pending, when the transaction is ready
--   to terminate, and no timeout or a timeout <i>&lt;= 0</i> is given, and
--   the option <a>OWithReceipts</a> was passed to
--   <tt>withTransaction</tt>, the transaction will be aborted with
--   <a>TxException</a>; otherwise it will wait until all pending
--   ineractions with the broker have terminated or the timeout has expired
--   - whatever comes first. If the timeout expires first,
--   <a>TxException</a> is raised.
OTimeout :: Int -> Topt

-- | This option has two effects: 1) Internal interactions of the
--   transaction with the broker will request receipts; 2) before ending
--   the transaction, the library will check for receipts that have not yet
--   been confirmed by the broker (including receipts requested by user
--   calls such as <i>writeQ</i> or <i>ackWith</i>).
--   
--   If receipts are pending, when the transaction is ready to terminate
--   and <a>OTimeout</a> with a value <i>&gt; 0</i> is given, the
--   transaction will wait for pending receipts; otherwise the transaction
--   will be aborted with <a>TxException</a>. Note that it usually does not
--   make sense to use this option without <a>OTimeout</a>, since, in all
--   probability, there will be receipts that have not yet been confirmed
--   when the transaction terminates.
OWithReceipts :: Topt

-- | If a message has been received from a queue with <tt>OMode</tt> option
--   other than <a>Auto</a> and this message has not yet been acknowledged
--   when the transaction is ready to terminate, the <i>ack</i> is
--   <i>missing</i>. With this option, the transaction will not commit with
--   missing <i>acks</i>, but abort and raise <a>TxException</a>.
OAbortMissingAcks :: Topt

-- | Aborts the transaction immediately by raising <a>AppException</a>. The
--   string passed in to <a>abort</a> will be added to the exception
--   message.
abort :: String -> IO ()

-- | Acknowledges the arrival of <a>Message</a> to the broker. It is used
--   with a <a>Connection</a> <i>c</i> and a <a>Message</a> <i>x</i> like:
--   
--   <pre>
--   ack c x
--   </pre>
ack :: Con -> Message a -> IO ()

-- | Acknowledges the arrival of <a>Message</a> to the broker, requests a
--   receipt and waits until it is confirmed. Since it preempts the calling
--   thread, it is usually used with <i>timeout</i>, for a
--   <a>Connection</a> <i>c</i>, a <a>Message</a> <i>x</i> and a
--   <i>timeout</i> in microseconds <i>tmo</i> like:
--   
--   <pre>
--   mbR &lt;- timeout tmo $ ackWith c x   
--   case mbR of
--     Nothing -&gt; -- error handling
--     Just _  -&gt; do -- ...
--   </pre>
ackWith :: Con -> Message a -> IO ()

-- | Negatively acknowledges the arrival of <a>Message</a> to the broker.
--   For more details see <a>ack</a>.
nack :: Con -> Message a -> IO ()

-- | Negatively acknowledges the arrival of <a>Message</a> to the broker,
--   requests a receipt and waits until it is confirmed. For more details
--   see <a>ackWith</a>.
nackWith :: Con -> Message a -> IO ()
instance Show Qopt
instance Read Qopt
instance Eq Qopt
instance Eq (Writer a)
instance Eq (Reader a)


-- | The Stomp specification defines only one queuing pattern: <i>publish
--   and subscribe</i>. In some situations, other patterns may be more
--   appropriate such as <i>peer-to-peer</i> or <i>client server</i>.
--   Whereas patterns like peer-to-peer are easy to simulate with the means
--   provided by Stomp, client/server needs some more coordination between
--   the involved parties, the clients and the server.
--   
--   This module provides abstractions that implement a simple
--   client/server protocol on top of Stomp. A server is an application
--   that provides a <i>service</i> to others. The service must be
--   explicitly requested by a client and only the requesting client must
--   see the response produced by the server.
--   
--   The module, basically, provides two data types (<a>ClientA</a> and
--   <a>ServerA</a>) and two functions working on these data types, namely
--   <a>request</a> and <a>reply</a>. With the request function, the client
--   requests a service and waits for a response. With the reply function,
--   a server waits for a request, produces a response and sends it back
--   through a channel indicated by the client.
--   
--   Internally, <a>request</a> and <a>reply</a> use a message header
--   called "<b>client</b>" to agree on the reply queue

-- | <i>Deprecated: use Network.Mom.Stompl.Patterns.Basic instead!</i>
module Network.Mom.Stompl.Client.Patterns

-- | The client data type
data ClientA i o

-- | The function creates a client that lives within its scope.
--   
--   Parameters:
--   
--   <ul>
--   <li><a>Con</a>: Connection to a Stomp broker</li>
--   <li><a>String</a>: Name of the Client, used for debugging.</li>
--   <li><a>ReaderDesc</a> i: Description of a reader queue; this is the
--   queue through which the server will send its response.</li>
--   <li><a>WriterDesc</a> o: Description of a writer queue; this is the
--   queue through which the server is expecting requests.</li>
--   <li><a>ClientA</a> i o -&gt; IO r: An application-defined action whose
--   scope defines the client's lifetime</li>
--   </ul>
withClient :: Con -> String -> ReaderDesc i -> WriterDesc o -> (ClientA i o -> IO r) -> IO r

-- | The client will send the request of type <i>o</i> and wait for the
--   reply until the timeout exprires. The reply is of type <i>i</i> and is
--   returned as <a>Message</a> <i>i</i>. If the timeout expires before the
--   reply has been received, the function returns <a>Nothing</a>.
--   
--   Parameters:
--   
--   <ul>
--   <li><a>ClientA</a> i o: The client; note that i is the type of the
--   reply, o is the type of the request.</li>
--   <li><a>Int</a>: The timeout in microseconds.</li>
--   <li><a>Type</a>: The <i>MIME</i> type of the request.</li>
--   <li>[<a>Header</a>]: List of additional headers to be sent with the
--   request; note that the function, internally, uses a header named
--   "<b>client</b>". This header name, hence, is reserved and must not be
--   used by the application.</li>
--   <li><i>o</i>: The request</li>
--   </ul>
request :: ClientA i o -> Int -> Type -> [Header] -> o -> IO (Maybe (Message i))

-- | This function serves as a "delayed" receiver for the case that the
--   timeout of a request has expired. When using this function, it is
--   assumed that a request has been made, but no response has been
--   received. It can be used in time-critical applications, where the
--   client may use the time between request and reply productively,
--   instead of blocking on the reply queue.
--   
--   Use this function with care! It can be easily abused to break the
--   client/server pattern, when it is called without a request having been
--   made before. If, in this case, <i>timout</i> is <i>-1</i>, the
--   application will block for ever.
--   
--   For parameters, please refer to <a>request</a>.
checkRequest :: ClientA i o -> Int -> IO (Maybe (Message i))

-- | The server data type
data ServerA i o

-- | The function creates a server that lives within its scope.
--   
--   Parameters:
--   
--   <ul>
--   <li><a>Con</a>: Connection to a Stomp broker</li>
--   <li><a>String</a>: Name of the Server, used for debugging.</li>
--   <li><a>ReaderDesc</a> i: Description of a reader queue; this is the
--   queue through which clients are expected to send requests.</li>
--   <li><a>WriterDesc</a> o: Description of a writer queue; this is the
--   queue through which a specific client will expect the reply. Note that
--   the server will overwrite the destination of this queue using
--   <a>writeAdHoc</a>; the destination of this queue, hence, is
--   irrelevant.</li>
--   <li><a>ServerA</a> i o -&gt; IO r: An application-defined action whose
--   scope defines the server's lifetime</li>
--   </ul>
withServer :: Con -> String -> ReaderDesc i -> WriterDesc o -> (ServerA i o -> IO r) -> IO r

-- | Waits for a client request, calls the application-defined transformer
--   to generate a reply and sends this reply through the queue whose name
--   is indicated by the value of the "<b>client</b>" header. The time a
--   server waits for a request may be restricted by the timeout.
--   Typically, you would call reply with timeout set to <i>-1</i> (for
--   <i>wait eternally</i>). There may be situations, however, where it
--   actually makes sense to restrict the waiting time, <i>i.e.</i> to
--   perform some housekeeping in between.
--   
--   Typically, you call reply in a loop like
--   
--   <pre>
--   forever $ reply srv (-1) nullType [] f
--   </pre>
--   
--   where <i>f</i> is a function of type
--   
--   <pre>
--   'Message' i -&gt; 'IO' o.
--   </pre>
--   
--   Parameters:
--   
--   <ul>
--   <li><a>ServerA</a> i o: The server; note that i is the request queue
--   and o the reply queue.</li>
--   <li><a>Int</a>: The timeout in microseconds.</li>
--   <li><a>Type</a>: The <i>MIME</i> type of the reply.</li>
--   <li>[<a>Header</a>]: Additional headers to be sent with the
--   reply.</li>
--   <li><a>Message</a> i -&gt; IO o: Transforms the request into a reply -
--   this defines the service provided by this application.</li>
--   </ul>
reply :: ServerA i o -> Int -> Type -> [Header] -> (Message i -> IO o) -> IO ()
