-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | CAES Language for Synchronous Hardware - Prelude library
--   
--   CλaSH (pronounced ‘clash’) is a functional hardware description
--   language that borrows both its syntax and semantics from the
--   functional programming language Haskell. The merits of using a
--   functional language to describe hardware comes from the fact that
--   combinational circuits can be directly modeled as mathematical
--   functions and that functional languages lend themselves very well at
--   describing and (de-)composing mathematical functions.
--   
--   This package provides:
--   
--   <ul>
--   <li>Prelude library containing datatypes and functions for circuit
--   design</li>
--   </ul>
--   
--   To use the library:
--   
--   <ul>
--   <li>Import <a>CLaSH.Prelude</a></li>
--   <li>Additionally import <a>CLaSH.Prelude.Explicit</a> if you want to
--   design explicitly clocked circuits in a multi-clock setting</li>
--   </ul>
--   
--   A preliminary version of a tutorial can be found in
--   <a>CLaSH.Tutorial</a>, for a general overview of the library you
--   should however check out <a>CLaSH.Prelude</a>. Some circuit examples
--   can be found in <a>CLaSH.Examples</a>.
@package clash-prelude
@version 0.9.1


module CLaSH.Sized.Internal.Index

-- | Arbitrary-bounded unsigned integer represented by
--   <tt>ceil(log_2(n))</tt> bits.
--   
--   Given an upper bound <tt>n</tt>, an <a>Index</a> <tt>n</tt> number has
--   a range of: [0 .. <tt>n</tt>-1]
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Index 8
--   7
--   
--   &gt;&gt;&gt; minBound :: Index 8
--   0
--   
--   &gt;&gt;&gt; 1 + 2 :: Index 8
--   3
--   
--   &gt;&gt;&gt; 2 + 6 :: Index 8
--   *** Exception: 8 is out of bounds: [0..7]
--   
--   &gt;&gt;&gt; 1 - 3 :: Index 8
--   *** Exception: -2 is out of bounds: [0..7]
--   
--   &gt;&gt;&gt; 2 * 3 :: Index 8
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Index 8
--   *** Exception: 8 is out of bounds: [0..7]
--   </pre>
newtype Index (n :: Nat)

-- | The constructor, <a>I</a>, and the field, <a>unsafeToInteger</a>, are
--   not synthesisable.
[I] :: Integer -> Index
[unsafeToInteger] :: Index -> Integer
eq# :: (Index n) -> (Index n) -> Bool
neq# :: (Index n) -> (Index n) -> Bool
lt# :: Index n -> Index n -> Bool
ge# :: Index n -> Index n -> Bool
gt# :: Index n -> Index n -> Bool
le# :: Index n -> Index n -> Bool
enumFrom# :: KnownNat n => Index n -> [Index n]
enumFromThen# :: KnownNat n => Index n -> Index n -> [Index n]
enumFromTo# :: KnownNat n => Index n -> Index n -> [Index n]
enumFromThenTo# :: KnownNat n => Index n -> Index n -> Index n -> [Index n]
maxBound# :: KnownNat n => Index n
(+#) :: KnownNat n => Index n -> Index n -> Index n
(-#) :: KnownNat n => Index n -> Index n -> Index n
(*#) :: KnownNat n => Index n -> Index n -> Index n
fromInteger# :: KnownNat n => Integer -> Index n
quot# :: Index n -> Index n -> Index n
rem# :: Index n -> Index n -> Index n
toInteger# :: Index n -> Integer
instance Eq (Index n)
instance Ord (Index n)
instance KnownNat n => Enum (Index n)
instance KnownNat n => Bounded (Index n)
instance KnownNat n => Num (Index n)
instance KnownNat n => Real (Index n)
instance KnownNat n => Integral (Index n)
instance KnownNat n => Lift (Index n)
instance Show (Index n)
instance KnownNat n => Default (Index n)
instance KnownNat n => Arbitrary (Index n)
instance KnownNat n => CoArbitrary (Index n)


module CLaSH.Promoted.Symbol

-- | Singleton value for a type-level string <tt>s</tt>
data SSymbol (s :: Symbol)
[SSymbol] :: (Proxy s) -> SSymbol

-- | Create a singleton literal for a type-level natural number
ssymbol :: KnownSymbol s => SSymbol s

-- | Reify the type-level <a>Symbol</a> <tt>s</tt> to it's term-level
--   <a>String</a> representation.
ssymbolToString :: SSymbol s -> String
instance [safe] Show (SSymbol s)


module CLaSH.Promoted.Ord

-- | Type-level <a>min</a> function for natural numbers

-- | Type-level <a>max</a> function for natural numbers


module CLaSH.Promoted.Nat

-- | Singleton value for a type-level natural number <tt>n</tt>
--   
--   <ul>
--   <li><a>CLaSH.Promoted.Nat.Literals</a> contains a list of predefined
--   <a>SNat</a> literals</li>
--   <li><a>CLaSH.Promoted.Nat.TH</a> has functions to easily create large
--   ranges of new <a>SNat</a> literals</li>
--   </ul>
data SNat (n :: Nat)
[SNat] :: (Proxy n) -> SNat

-- | Create a singleton literal for a type-level natural number
snat :: KnownNat n => SNat n

-- | Supply a function with a singleton natural <tt>n</tt> according to the
--   context
withSNat :: KnownNat n => (SNat n -> a) -> a

-- | Reify the type-level <a>Nat</a> <tt>n</tt> to it's term-level
--   <a>Integer</a> representation.
snatToInteger :: SNat n -> Integer

-- | Add two singleton natural numbers
addSNat :: KnownNat (a + b) => SNat a -> SNat b -> SNat (a + b)

-- | Subtract two singleton natural numbers
subSNat :: KnownNat (a - b) => SNat a -> SNat b -> SNat (a - b)

-- | Multiply two singleton natural numbers
mulSNat :: KnownNat (a * b) => SNat a -> SNat b -> SNat (a * b)

-- | Power of two singleton natural numbers
powSNat :: KnownNat (a ^ b) => SNat a -> SNat b -> SNat (a ^ b)

-- | Unary representation of a type-level natural
--   
--   <b>NB</b>: Not synthesisable
data UNat :: Nat -> *
[UZero] :: UNat 0
[USucc] :: UNat n -> UNat (n + 1)

-- | Convert a singleton natural number to its unary representation
--   
--   <b>NB</b>: Not synthesisable
toUNat :: SNat n -> UNat n

-- | Add two unary singleton natural numbers
--   
--   <b>NB</b>: Not synthesisable
addUNat :: UNat n -> UNat m -> UNat (n + m)

-- | Multiply two unary singleton natural numbers
--   
--   <b>NB</b>: Not synthesisable
multUNat :: UNat n -> UNat m -> UNat (n * m)

-- | Power of two unary singleton natural numbers
--   
--   <b>NB</b>: Not synthesisable
powUNat :: UNat n -> UNat m -> UNat (n ^ m)
instance Show (SNat n)


module CLaSH.Promoted.Nat.TH

-- | Create an <a>SNat</a> literal
--   
--   <pre>
--   $(decLiteralD 1111)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t d1111
--   d1111 :: SNat 1111
--   </pre>
decLiteralD :: Integer -> Q [Dec]

-- | Create a range of <a>SNat</a> literals
--   
--   <pre>
--   $(decLiteralsD 1200 1202)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t d1200
--   d1200 :: SNat 1200
--   
--   &gt;&gt;&gt; :t d1201
--   d1201 :: SNat 1201
--   
--   &gt;&gt;&gt; :t d1202
--   d1202 :: SNat 1202
--   </pre>
decLiteralsD :: Integer -> Integer -> Q [Dec]


-- | Predefined <tt>SNat</tt> singleton literals in the range [0 .. 1024]
--   
--   Defines:
--   
--   <pre>
--   d0 = snat :: SNat 0
--   d1 = snat :: SNat 1
--   d2 = snat :: SNat 2
--   ...
--   d1024 = snat :: SNat 102
--   </pre>
--   
--   You can generate more <tt>SNat</tt> literals using <a>decLiteralsD</a>
--   from <a>CLaSH.Promoted.Nat.TH</a>
module CLaSH.Promoted.Nat.Literals
d1024 :: SNat 1024
d1023 :: SNat 1023
d1022 :: SNat 1022
d1021 :: SNat 1021
d1020 :: SNat 1020
d1019 :: SNat 1019
d1018 :: SNat 1018
d1017 :: SNat 1017
d1016 :: SNat 1016
d1015 :: SNat 1015
d1014 :: SNat 1014
d1013 :: SNat 1013
d1012 :: SNat 1012
d1011 :: SNat 1011
d1010 :: SNat 1010
d1009 :: SNat 1009
d1008 :: SNat 1008
d1007 :: SNat 1007
d1006 :: SNat 1006
d1005 :: SNat 1005
d1004 :: SNat 1004
d1003 :: SNat 1003
d1002 :: SNat 1002
d1001 :: SNat 1001
d1000 :: SNat 1000
d999 :: SNat 999
d998 :: SNat 998
d997 :: SNat 997
d996 :: SNat 996
d995 :: SNat 995
d994 :: SNat 994
d993 :: SNat 993
d992 :: SNat 992
d991 :: SNat 991
d990 :: SNat 990
d989 :: SNat 989
d988 :: SNat 988
d987 :: SNat 987
d986 :: SNat 986
d985 :: SNat 985
d984 :: SNat 984
d983 :: SNat 983
d982 :: SNat 982
d981 :: SNat 981
d980 :: SNat 980
d979 :: SNat 979
d978 :: SNat 978
d977 :: SNat 977
d976 :: SNat 976
d975 :: SNat 975
d974 :: SNat 974
d973 :: SNat 973
d972 :: SNat 972
d971 :: SNat 971
d970 :: SNat 970
d969 :: SNat 969
d968 :: SNat 968
d967 :: SNat 967
d966 :: SNat 966
d965 :: SNat 965
d964 :: SNat 964
d963 :: SNat 963
d962 :: SNat 962
d961 :: SNat 961
d960 :: SNat 960
d959 :: SNat 959
d958 :: SNat 958
d957 :: SNat 957
d956 :: SNat 956
d955 :: SNat 955
d954 :: SNat 954
d953 :: SNat 953
d952 :: SNat 952
d951 :: SNat 951
d950 :: SNat 950
d949 :: SNat 949
d948 :: SNat 948
d947 :: SNat 947
d946 :: SNat 946
d945 :: SNat 945
d944 :: SNat 944
d943 :: SNat 943
d942 :: SNat 942
d941 :: SNat 941
d940 :: SNat 940
d939 :: SNat 939
d938 :: SNat 938
d937 :: SNat 937
d936 :: SNat 936
d935 :: SNat 935
d934 :: SNat 934
d933 :: SNat 933
d932 :: SNat 932
d931 :: SNat 931
d930 :: SNat 930
d929 :: SNat 929
d928 :: SNat 928
d927 :: SNat 927
d926 :: SNat 926
d925 :: SNat 925
d924 :: SNat 924
d923 :: SNat 923
d922 :: SNat 922
d921 :: SNat 921
d920 :: SNat 920
d919 :: SNat 919
d918 :: SNat 918
d917 :: SNat 917
d916 :: SNat 916
d915 :: SNat 915
d914 :: SNat 914
d913 :: SNat 913
d912 :: SNat 912
d911 :: SNat 911
d910 :: SNat 910
d909 :: SNat 909
d908 :: SNat 908
d907 :: SNat 907
d906 :: SNat 906
d905 :: SNat 905
d904 :: SNat 904
d903 :: SNat 903
d902 :: SNat 902
d901 :: SNat 901
d900 :: SNat 900
d899 :: SNat 899
d898 :: SNat 898
d897 :: SNat 897
d896 :: SNat 896
d895 :: SNat 895
d894 :: SNat 894
d893 :: SNat 893
d892 :: SNat 892
d891 :: SNat 891
d890 :: SNat 890
d889 :: SNat 889
d888 :: SNat 888
d887 :: SNat 887
d886 :: SNat 886
d885 :: SNat 885
d884 :: SNat 884
d883 :: SNat 883
d882 :: SNat 882
d881 :: SNat 881
d880 :: SNat 880
d879 :: SNat 879
d878 :: SNat 878
d877 :: SNat 877
d876 :: SNat 876
d875 :: SNat 875
d874 :: SNat 874
d873 :: SNat 873
d872 :: SNat 872
d871 :: SNat 871
d870 :: SNat 870
d869 :: SNat 869
d868 :: SNat 868
d867 :: SNat 867
d866 :: SNat 866
d865 :: SNat 865
d864 :: SNat 864
d863 :: SNat 863
d862 :: SNat 862
d861 :: SNat 861
d860 :: SNat 860
d859 :: SNat 859
d858 :: SNat 858
d857 :: SNat 857
d856 :: SNat 856
d855 :: SNat 855
d854 :: SNat 854
d853 :: SNat 853
d852 :: SNat 852
d851 :: SNat 851
d850 :: SNat 850
d849 :: SNat 849
d848 :: SNat 848
d847 :: SNat 847
d846 :: SNat 846
d845 :: SNat 845
d844 :: SNat 844
d843 :: SNat 843
d842 :: SNat 842
d841 :: SNat 841
d840 :: SNat 840
d839 :: SNat 839
d838 :: SNat 838
d837 :: SNat 837
d836 :: SNat 836
d835 :: SNat 835
d834 :: SNat 834
d833 :: SNat 833
d832 :: SNat 832
d831 :: SNat 831
d830 :: SNat 830
d829 :: SNat 829
d828 :: SNat 828
d827 :: SNat 827
d826 :: SNat 826
d825 :: SNat 825
d824 :: SNat 824
d823 :: SNat 823
d822 :: SNat 822
d821 :: SNat 821
d820 :: SNat 820
d819 :: SNat 819
d818 :: SNat 818
d817 :: SNat 817
d816 :: SNat 816
d815 :: SNat 815
d814 :: SNat 814
d813 :: SNat 813
d812 :: SNat 812
d811 :: SNat 811
d810 :: SNat 810
d809 :: SNat 809
d808 :: SNat 808
d807 :: SNat 807
d806 :: SNat 806
d805 :: SNat 805
d804 :: SNat 804
d803 :: SNat 803
d802 :: SNat 802
d801 :: SNat 801
d800 :: SNat 800
d799 :: SNat 799
d798 :: SNat 798
d797 :: SNat 797
d796 :: SNat 796
d795 :: SNat 795
d794 :: SNat 794
d793 :: SNat 793
d792 :: SNat 792
d791 :: SNat 791
d790 :: SNat 790
d789 :: SNat 789
d788 :: SNat 788
d787 :: SNat 787
d786 :: SNat 786
d785 :: SNat 785
d784 :: SNat 784
d783 :: SNat 783
d782 :: SNat 782
d781 :: SNat 781
d780 :: SNat 780
d779 :: SNat 779
d778 :: SNat 778
d777 :: SNat 777
d776 :: SNat 776
d775 :: SNat 775
d774 :: SNat 774
d773 :: SNat 773
d772 :: SNat 772
d771 :: SNat 771
d770 :: SNat 770
d769 :: SNat 769
d768 :: SNat 768
d767 :: SNat 767
d766 :: SNat 766
d765 :: SNat 765
d764 :: SNat 764
d763 :: SNat 763
d762 :: SNat 762
d761 :: SNat 761
d760 :: SNat 760
d759 :: SNat 759
d758 :: SNat 758
d757 :: SNat 757
d756 :: SNat 756
d755 :: SNat 755
d754 :: SNat 754
d753 :: SNat 753
d752 :: SNat 752
d751 :: SNat 751
d750 :: SNat 750
d749 :: SNat 749
d748 :: SNat 748
d747 :: SNat 747
d746 :: SNat 746
d745 :: SNat 745
d744 :: SNat 744
d743 :: SNat 743
d742 :: SNat 742
d741 :: SNat 741
d740 :: SNat 740
d739 :: SNat 739
d738 :: SNat 738
d737 :: SNat 737
d736 :: SNat 736
d735 :: SNat 735
d734 :: SNat 734
d733 :: SNat 733
d732 :: SNat 732
d731 :: SNat 731
d730 :: SNat 730
d729 :: SNat 729
d728 :: SNat 728
d727 :: SNat 727
d726 :: SNat 726
d725 :: SNat 725
d724 :: SNat 724
d723 :: SNat 723
d722 :: SNat 722
d721 :: SNat 721
d720 :: SNat 720
d719 :: SNat 719
d718 :: SNat 718
d717 :: SNat 717
d716 :: SNat 716
d715 :: SNat 715
d714 :: SNat 714
d713 :: SNat 713
d712 :: SNat 712
d711 :: SNat 711
d710 :: SNat 710
d709 :: SNat 709
d708 :: SNat 708
d707 :: SNat 707
d706 :: SNat 706
d705 :: SNat 705
d704 :: SNat 704
d703 :: SNat 703
d702 :: SNat 702
d701 :: SNat 701
d700 :: SNat 700
d699 :: SNat 699
d698 :: SNat 698
d697 :: SNat 697
d696 :: SNat 696
d695 :: SNat 695
d694 :: SNat 694
d693 :: SNat 693
d692 :: SNat 692
d691 :: SNat 691
d690 :: SNat 690
d689 :: SNat 689
d688 :: SNat 688
d687 :: SNat 687
d686 :: SNat 686
d685 :: SNat 685
d684 :: SNat 684
d683 :: SNat 683
d682 :: SNat 682
d681 :: SNat 681
d680 :: SNat 680
d679 :: SNat 679
d678 :: SNat 678
d677 :: SNat 677
d676 :: SNat 676
d675 :: SNat 675
d674 :: SNat 674
d673 :: SNat 673
d672 :: SNat 672
d671 :: SNat 671
d670 :: SNat 670
d669 :: SNat 669
d668 :: SNat 668
d667 :: SNat 667
d666 :: SNat 666
d665 :: SNat 665
d664 :: SNat 664
d663 :: SNat 663
d662 :: SNat 662
d661 :: SNat 661
d660 :: SNat 660
d659 :: SNat 659
d658 :: SNat 658
d657 :: SNat 657
d656 :: SNat 656
d655 :: SNat 655
d654 :: SNat 654
d653 :: SNat 653
d652 :: SNat 652
d651 :: SNat 651
d650 :: SNat 650
d649 :: SNat 649
d648 :: SNat 648
d647 :: SNat 647
d646 :: SNat 646
d645 :: SNat 645
d644 :: SNat 644
d643 :: SNat 643
d642 :: SNat 642
d641 :: SNat 641
d640 :: SNat 640
d639 :: SNat 639
d638 :: SNat 638
d637 :: SNat 637
d636 :: SNat 636
d635 :: SNat 635
d634 :: SNat 634
d633 :: SNat 633
d632 :: SNat 632
d631 :: SNat 631
d630 :: SNat 630
d629 :: SNat 629
d628 :: SNat 628
d627 :: SNat 627
d626 :: SNat 626
d625 :: SNat 625
d624 :: SNat 624
d623 :: SNat 623
d622 :: SNat 622
d621 :: SNat 621
d620 :: SNat 620
d619 :: SNat 619
d618 :: SNat 618
d617 :: SNat 617
d616 :: SNat 616
d615 :: SNat 615
d614 :: SNat 614
d613 :: SNat 613
d612 :: SNat 612
d611 :: SNat 611
d610 :: SNat 610
d609 :: SNat 609
d608 :: SNat 608
d607 :: SNat 607
d606 :: SNat 606
d605 :: SNat 605
d604 :: SNat 604
d603 :: SNat 603
d602 :: SNat 602
d601 :: SNat 601
d600 :: SNat 600
d599 :: SNat 599
d598 :: SNat 598
d597 :: SNat 597
d596 :: SNat 596
d595 :: SNat 595
d594 :: SNat 594
d593 :: SNat 593
d592 :: SNat 592
d591 :: SNat 591
d590 :: SNat 590
d589 :: SNat 589
d588 :: SNat 588
d587 :: SNat 587
d586 :: SNat 586
d585 :: SNat 585
d584 :: SNat 584
d583 :: SNat 583
d582 :: SNat 582
d581 :: SNat 581
d580 :: SNat 580
d579 :: SNat 579
d578 :: SNat 578
d577 :: SNat 577
d576 :: SNat 576
d575 :: SNat 575
d574 :: SNat 574
d573 :: SNat 573
d572 :: SNat 572
d571 :: SNat 571
d570 :: SNat 570
d569 :: SNat 569
d568 :: SNat 568
d567 :: SNat 567
d566 :: SNat 566
d565 :: SNat 565
d564 :: SNat 564
d563 :: SNat 563
d562 :: SNat 562
d561 :: SNat 561
d560 :: SNat 560
d559 :: SNat 559
d558 :: SNat 558
d557 :: SNat 557
d556 :: SNat 556
d555 :: SNat 555
d554 :: SNat 554
d553 :: SNat 553
d552 :: SNat 552
d551 :: SNat 551
d550 :: SNat 550
d549 :: SNat 549
d548 :: SNat 548
d547 :: SNat 547
d546 :: SNat 546
d545 :: SNat 545
d544 :: SNat 544
d543 :: SNat 543
d542 :: SNat 542
d541 :: SNat 541
d540 :: SNat 540
d539 :: SNat 539
d538 :: SNat 538
d537 :: SNat 537
d536 :: SNat 536
d535 :: SNat 535
d534 :: SNat 534
d533 :: SNat 533
d532 :: SNat 532
d531 :: SNat 531
d530 :: SNat 530
d529 :: SNat 529
d528 :: SNat 528
d527 :: SNat 527
d526 :: SNat 526
d525 :: SNat 525
d524 :: SNat 524
d523 :: SNat 523
d522 :: SNat 522
d521 :: SNat 521
d520 :: SNat 520
d519 :: SNat 519
d518 :: SNat 518
d517 :: SNat 517
d516 :: SNat 516
d515 :: SNat 515
d514 :: SNat 514
d513 :: SNat 513
d512 :: SNat 512
d511 :: SNat 511
d510 :: SNat 510
d509 :: SNat 509
d508 :: SNat 508
d507 :: SNat 507
d506 :: SNat 506
d505 :: SNat 505
d504 :: SNat 504
d503 :: SNat 503
d502 :: SNat 502
d501 :: SNat 501
d500 :: SNat 500
d499 :: SNat 499
d498 :: SNat 498
d497 :: SNat 497
d496 :: SNat 496
d495 :: SNat 495
d494 :: SNat 494
d493 :: SNat 493
d492 :: SNat 492
d491 :: SNat 491
d490 :: SNat 490
d489 :: SNat 489
d488 :: SNat 488
d487 :: SNat 487
d486 :: SNat 486
d485 :: SNat 485
d484 :: SNat 484
d483 :: SNat 483
d482 :: SNat 482
d481 :: SNat 481
d480 :: SNat 480
d479 :: SNat 479
d478 :: SNat 478
d477 :: SNat 477
d476 :: SNat 476
d475 :: SNat 475
d474 :: SNat 474
d473 :: SNat 473
d472 :: SNat 472
d471 :: SNat 471
d470 :: SNat 470
d469 :: SNat 469
d468 :: SNat 468
d467 :: SNat 467
d466 :: SNat 466
d465 :: SNat 465
d464 :: SNat 464
d463 :: SNat 463
d462 :: SNat 462
d461 :: SNat 461
d460 :: SNat 460
d459 :: SNat 459
d458 :: SNat 458
d457 :: SNat 457
d456 :: SNat 456
d455 :: SNat 455
d454 :: SNat 454
d453 :: SNat 453
d452 :: SNat 452
d451 :: SNat 451
d450 :: SNat 450
d449 :: SNat 449
d448 :: SNat 448
d447 :: SNat 447
d446 :: SNat 446
d445 :: SNat 445
d444 :: SNat 444
d443 :: SNat 443
d442 :: SNat 442
d441 :: SNat 441
d440 :: SNat 440
d439 :: SNat 439
d438 :: SNat 438
d437 :: SNat 437
d436 :: SNat 436
d435 :: SNat 435
d434 :: SNat 434
d433 :: SNat 433
d432 :: SNat 432
d431 :: SNat 431
d430 :: SNat 430
d429 :: SNat 429
d428 :: SNat 428
d427 :: SNat 427
d426 :: SNat 426
d425 :: SNat 425
d424 :: SNat 424
d423 :: SNat 423
d422 :: SNat 422
d421 :: SNat 421
d420 :: SNat 420
d419 :: SNat 419
d418 :: SNat 418
d417 :: SNat 417
d416 :: SNat 416
d415 :: SNat 415
d414 :: SNat 414
d413 :: SNat 413
d412 :: SNat 412
d411 :: SNat 411
d410 :: SNat 410
d409 :: SNat 409
d408 :: SNat 408
d407 :: SNat 407
d406 :: SNat 406
d405 :: SNat 405
d404 :: SNat 404
d403 :: SNat 403
d402 :: SNat 402
d401 :: SNat 401
d400 :: SNat 400
d399 :: SNat 399
d398 :: SNat 398
d397 :: SNat 397
d396 :: SNat 396
d395 :: SNat 395
d394 :: SNat 394
d393 :: SNat 393
d392 :: SNat 392
d391 :: SNat 391
d390 :: SNat 390
d389 :: SNat 389
d388 :: SNat 388
d387 :: SNat 387
d386 :: SNat 386
d385 :: SNat 385
d384 :: SNat 384
d383 :: SNat 383
d382 :: SNat 382
d381 :: SNat 381
d380 :: SNat 380
d379 :: SNat 379
d378 :: SNat 378
d377 :: SNat 377
d376 :: SNat 376
d375 :: SNat 375
d374 :: SNat 374
d373 :: SNat 373
d372 :: SNat 372
d371 :: SNat 371
d370 :: SNat 370
d369 :: SNat 369
d368 :: SNat 368
d367 :: SNat 367
d366 :: SNat 366
d365 :: SNat 365
d364 :: SNat 364
d363 :: SNat 363
d362 :: SNat 362
d361 :: SNat 361
d360 :: SNat 360
d359 :: SNat 359
d358 :: SNat 358
d357 :: SNat 357
d356 :: SNat 356
d355 :: SNat 355
d354 :: SNat 354
d353 :: SNat 353
d352 :: SNat 352
d351 :: SNat 351
d350 :: SNat 350
d349 :: SNat 349
d348 :: SNat 348
d347 :: SNat 347
d346 :: SNat 346
d345 :: SNat 345
d344 :: SNat 344
d343 :: SNat 343
d342 :: SNat 342
d341 :: SNat 341
d340 :: SNat 340
d339 :: SNat 339
d338 :: SNat 338
d337 :: SNat 337
d336 :: SNat 336
d335 :: SNat 335
d334 :: SNat 334
d333 :: SNat 333
d332 :: SNat 332
d331 :: SNat 331
d330 :: SNat 330
d329 :: SNat 329
d328 :: SNat 328
d327 :: SNat 327
d326 :: SNat 326
d325 :: SNat 325
d324 :: SNat 324
d323 :: SNat 323
d322 :: SNat 322
d321 :: SNat 321
d320 :: SNat 320
d319 :: SNat 319
d318 :: SNat 318
d317 :: SNat 317
d316 :: SNat 316
d315 :: SNat 315
d314 :: SNat 314
d313 :: SNat 313
d312 :: SNat 312
d311 :: SNat 311
d310 :: SNat 310
d309 :: SNat 309
d308 :: SNat 308
d307 :: SNat 307
d306 :: SNat 306
d305 :: SNat 305
d304 :: SNat 304
d303 :: SNat 303
d302 :: SNat 302
d301 :: SNat 301
d300 :: SNat 300
d299 :: SNat 299
d298 :: SNat 298
d297 :: SNat 297
d296 :: SNat 296
d295 :: SNat 295
d294 :: SNat 294
d293 :: SNat 293
d292 :: SNat 292
d291 :: SNat 291
d290 :: SNat 290
d289 :: SNat 289
d288 :: SNat 288
d287 :: SNat 287
d286 :: SNat 286
d285 :: SNat 285
d284 :: SNat 284
d283 :: SNat 283
d282 :: SNat 282
d281 :: SNat 281
d280 :: SNat 280
d279 :: SNat 279
d278 :: SNat 278
d277 :: SNat 277
d276 :: SNat 276
d275 :: SNat 275
d274 :: SNat 274
d273 :: SNat 273
d272 :: SNat 272
d271 :: SNat 271
d270 :: SNat 270
d269 :: SNat 269
d268 :: SNat 268
d267 :: SNat 267
d266 :: SNat 266
d265 :: SNat 265
d264 :: SNat 264
d263 :: SNat 263
d262 :: SNat 262
d261 :: SNat 261
d260 :: SNat 260
d259 :: SNat 259
d258 :: SNat 258
d257 :: SNat 257
d256 :: SNat 256
d255 :: SNat 255
d254 :: SNat 254
d253 :: SNat 253
d252 :: SNat 252
d251 :: SNat 251
d250 :: SNat 250
d249 :: SNat 249
d248 :: SNat 248
d247 :: SNat 247
d246 :: SNat 246
d245 :: SNat 245
d244 :: SNat 244
d243 :: SNat 243
d242 :: SNat 242
d241 :: SNat 241
d240 :: SNat 240
d239 :: SNat 239
d238 :: SNat 238
d237 :: SNat 237
d236 :: SNat 236
d235 :: SNat 235
d234 :: SNat 234
d233 :: SNat 233
d232 :: SNat 232
d231 :: SNat 231
d230 :: SNat 230
d229 :: SNat 229
d228 :: SNat 228
d227 :: SNat 227
d226 :: SNat 226
d225 :: SNat 225
d224 :: SNat 224
d223 :: SNat 223
d222 :: SNat 222
d221 :: SNat 221
d220 :: SNat 220
d219 :: SNat 219
d218 :: SNat 218
d217 :: SNat 217
d216 :: SNat 216
d215 :: SNat 215
d214 :: SNat 214
d213 :: SNat 213
d212 :: SNat 212
d211 :: SNat 211
d210 :: SNat 210
d209 :: SNat 209
d208 :: SNat 208
d207 :: SNat 207
d206 :: SNat 206
d205 :: SNat 205
d204 :: SNat 204
d203 :: SNat 203
d202 :: SNat 202
d201 :: SNat 201
d200 :: SNat 200
d199 :: SNat 199
d198 :: SNat 198
d197 :: SNat 197
d196 :: SNat 196
d195 :: SNat 195
d194 :: SNat 194
d193 :: SNat 193
d192 :: SNat 192
d191 :: SNat 191
d190 :: SNat 190
d189 :: SNat 189
d188 :: SNat 188
d187 :: SNat 187
d186 :: SNat 186
d185 :: SNat 185
d184 :: SNat 184
d183 :: SNat 183
d182 :: SNat 182
d181 :: SNat 181
d180 :: SNat 180
d179 :: SNat 179
d178 :: SNat 178
d177 :: SNat 177
d176 :: SNat 176
d175 :: SNat 175
d174 :: SNat 174
d173 :: SNat 173
d172 :: SNat 172
d171 :: SNat 171
d170 :: SNat 170
d169 :: SNat 169
d168 :: SNat 168
d167 :: SNat 167
d166 :: SNat 166
d165 :: SNat 165
d164 :: SNat 164
d163 :: SNat 163
d162 :: SNat 162
d161 :: SNat 161
d160 :: SNat 160
d159 :: SNat 159
d158 :: SNat 158
d157 :: SNat 157
d156 :: SNat 156
d155 :: SNat 155
d154 :: SNat 154
d153 :: SNat 153
d152 :: SNat 152
d151 :: SNat 151
d150 :: SNat 150
d149 :: SNat 149
d148 :: SNat 148
d147 :: SNat 147
d146 :: SNat 146
d145 :: SNat 145
d144 :: SNat 144
d143 :: SNat 143
d142 :: SNat 142
d141 :: SNat 141
d140 :: SNat 140
d139 :: SNat 139
d138 :: SNat 138
d137 :: SNat 137
d136 :: SNat 136
d135 :: SNat 135
d134 :: SNat 134
d133 :: SNat 133
d132 :: SNat 132
d131 :: SNat 131
d130 :: SNat 130
d129 :: SNat 129
d128 :: SNat 128
d127 :: SNat 127
d126 :: SNat 126
d125 :: SNat 125
d124 :: SNat 124
d123 :: SNat 123
d122 :: SNat 122
d121 :: SNat 121
d120 :: SNat 120
d119 :: SNat 119
d118 :: SNat 118
d117 :: SNat 117
d116 :: SNat 116
d115 :: SNat 115
d114 :: SNat 114
d113 :: SNat 113
d112 :: SNat 112
d111 :: SNat 111
d110 :: SNat 110
d109 :: SNat 109
d108 :: SNat 108
d107 :: SNat 107
d106 :: SNat 106
d105 :: SNat 105
d104 :: SNat 104
d103 :: SNat 103
d102 :: SNat 102
d101 :: SNat 101
d100 :: SNat 100
d99 :: SNat 99
d98 :: SNat 98
d97 :: SNat 97
d96 :: SNat 96
d95 :: SNat 95
d94 :: SNat 94
d93 :: SNat 93
d92 :: SNat 92
d91 :: SNat 91
d90 :: SNat 90
d89 :: SNat 89
d88 :: SNat 88
d87 :: SNat 87
d86 :: SNat 86
d85 :: SNat 85
d84 :: SNat 84
d83 :: SNat 83
d82 :: SNat 82
d81 :: SNat 81
d80 :: SNat 80
d79 :: SNat 79
d78 :: SNat 78
d77 :: SNat 77
d76 :: SNat 76
d75 :: SNat 75
d74 :: SNat 74
d73 :: SNat 73
d72 :: SNat 72
d71 :: SNat 71
d70 :: SNat 70
d69 :: SNat 69
d68 :: SNat 68
d67 :: SNat 67
d66 :: SNat 66
d65 :: SNat 65
d64 :: SNat 64
d63 :: SNat 63
d62 :: SNat 62
d61 :: SNat 61
d60 :: SNat 60
d59 :: SNat 59
d58 :: SNat 58
d57 :: SNat 57
d56 :: SNat 56
d55 :: SNat 55
d54 :: SNat 54
d53 :: SNat 53
d52 :: SNat 52
d51 :: SNat 51
d50 :: SNat 50
d49 :: SNat 49
d48 :: SNat 48
d47 :: SNat 47
d46 :: SNat 46
d45 :: SNat 45
d44 :: SNat 44
d43 :: SNat 43
d42 :: SNat 42
d41 :: SNat 41
d40 :: SNat 40
d39 :: SNat 39
d38 :: SNat 38
d37 :: SNat 37
d36 :: SNat 36
d35 :: SNat 35
d34 :: SNat 34
d33 :: SNat 33
d32 :: SNat 32
d31 :: SNat 31
d30 :: SNat 30
d29 :: SNat 29
d28 :: SNat 28
d27 :: SNat 27
d26 :: SNat 26
d25 :: SNat 25
d24 :: SNat 24
d23 :: SNat 23
d22 :: SNat 22
d21 :: SNat 21
d20 :: SNat 20
d19 :: SNat 19
d18 :: SNat 18
d17 :: SNat 17
d16 :: SNat 16
d15 :: SNat 15
d14 :: SNat 14
d13 :: SNat 13
d12 :: SNat 12
d11 :: SNat 11
d10 :: SNat 10
d9 :: SNat 9
d8 :: SNat 8
d7 :: SNat 7
d6 :: SNat 6
d5 :: SNat 5
d4 :: SNat 4
d3 :: SNat 3
d2 :: SNat 2
d1 :: SNat 1
d0 :: SNat 0


module CLaSH.Sized.Index

-- | Arbitrary-bounded unsigned integer represented by
--   <tt>ceil(log_2(n))</tt> bits.
--   
--   Given an upper bound <tt>n</tt>, an <a>Index</a> <tt>n</tt> number has
--   a range of: [0 .. <tt>n</tt>-1]
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Index 8
--   7
--   
--   &gt;&gt;&gt; minBound :: Index 8
--   0
--   
--   &gt;&gt;&gt; 1 + 2 :: Index 8
--   3
--   
--   &gt;&gt;&gt; 2 + 6 :: Index 8
--   *** Exception: 8 is out of bounds: [0..7]
--   
--   &gt;&gt;&gt; 1 - 3 :: Index 8
--   *** Exception: -2 is out of bounds: [0..7]
--   
--   &gt;&gt;&gt; 2 * 3 :: Index 8
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Index 8
--   *** Exception: 8 is out of bounds: [0..7]
--   </pre>
data Index (n :: Nat)


module CLaSH.Class.Resize

-- | Coerce a value to be represented by a different number of bits
class Resize (f :: Nat -> *) where extend = resize
resize :: (Resize f, KnownNat a, KnownNat b) => f a -> f b
extend :: (Resize f, KnownNat a, KnownNat (b + a)) => f a -> f (b + a)
zeroExtend :: (Resize f, KnownNat a, KnownNat b, KnownNat (b + a)) => f a -> f (b + a)
signExtend :: (Resize f, KnownNat a, KnownNat (b + a)) => f a -> f (b + a)
truncateB :: (Resize f, KnownNat a) => f (b + a) -> f a


module CLaSH.Class.Num

-- | Adding, subtracting, and multiplying values of two different
--   (sub-)types.
class ExtendingNum a b where type family AResult a b type family MResult a b
plus :: ExtendingNum a b => a -> b -> AResult a b
minus :: ExtendingNum a b => a -> b -> AResult a b
times :: ExtendingNum a b => a -> b -> MResult a b

-- | Determine how overflow and underflow are handled by the functions in
--   <a>SaturatingNum</a>
data SaturationMode

-- | Wrap around on overflow and underflow
[SatWrap] :: SaturationMode

-- | Become <a>maxBound</a> on overflow, and <a>minBound</a> on underflow
[SatBound] :: SaturationMode

-- | Become <tt>0</tt> on overflow and underflow
[SatZero] :: SaturationMode

-- | Become <a>maxBound</a> on overflow, and (<tt><a>minBound</a> - 1</tt>)
--   on underflow for signed numbers, and <a>minBound</a> for unsigned
--   numbers.
[SatSymmetric] :: SaturationMode

-- | <a>Num</a> operators in which overflow and underflow behaviour can be
--   specified using <a>SaturationMode</a>.
class (Bounded a, Num a) => SaturatingNum a
satPlus :: SaturatingNum a => SaturationMode -> a -> a -> a
satMin :: SaturatingNum a => SaturationMode -> a -> a -> a
satMult :: SaturatingNum a => SaturationMode -> a -> a -> a

-- | Addition that clips to <a>maxBound</a> on overflow, and
--   <a>minBound</a> on underflow
boundedPlus :: SaturatingNum a => a -> a -> a

-- | Subtraction that clips to <a>maxBound</a> on overflow, and
--   <a>minBound</a> on underflow
boundedMin :: SaturatingNum a => a -> a -> a

-- | Multiplication that clips to <a>maxBound</a> on overflow, and
--   <a>minBound</a> on underflow
boundedMult :: SaturatingNum a => a -> a -> a
instance [safe] Eq SaturationMode


module CLaSH.Signal.Internal

-- | A clock with a name (<a>Symbol</a>) and period (<a>Nat</a>)
data Clock
[Clk] :: Symbol -> Nat -> Clock

-- | Singleton value for a type-level <a>Clock</a> with the given
--   <tt>name</tt> and <tt>period</tt>
data SClock (clk :: Clock)
[SClock] :: SSymbol name -> SNat period -> SClock (Clk name period)

-- | A synchronized signal with samples of type <tt>a</tt>, explicitly
--   synchronized to a clock <tt>clk</tt>
--   
--   <b>NB</b>: The constructor, <tt>(<a>:-</a>)</tt>, is <b>not</b>
--   synthesisable.
data Signal' (clk :: Clock) a
[:-] :: a -> Signal' clk a -> Signal' a
register# :: SClock clk -> a -> Signal' clk a -> Signal' clk a
regEn# :: SClock clk -> a -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>mux</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> a
--   </pre>
--   
--   A multiplexer. Given "<tt><a>mux</a> b t f</tt>", output <tt>t</tt>
--   when <tt>b</tt> is <a>True</a>, and <tt>f</tt> when <tt>b</tt> is
--   <a>False</a>.
mux :: Applicative f => f Bool -> f a -> f a -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>signal</b> :: a -&gt; <a>Signal</a> a
--   </pre>
--   
--   Create a constant <a>Signal</a> from a combinational value
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; List.take 5 (sample (signal 4 :: Signal Int))
--   [4,4,4,4,4]
--   </pre>
signal :: Applicative f => a -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&amp;&amp;.)</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&amp;&amp;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.&&.) :: Applicative f => f Bool -> f Bool -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.||.)</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>||</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.||.) :: Applicative f => f Bool -> f Bool -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>not1</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of <a>not</a> that operates on <a>Signal</a>s of
--   <a>Bool</a>
not1 :: Functor f => f Bool -> f Bool

-- | Simulate a (<tt><a>Signal</a> a -&gt; <a>Signal</a> b</tt>) function
--   given a list of samples of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; simulate (register 8) [1, 2, 3]
--   [8,1,2,3...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
simulate :: (Signal' clk1 a -> Signal' clk2 b) -> [a] -> [b]

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>sample</b> :: <a>Signal</a> a -&gt; [a]
--   </pre>
--   
--   Get an infinite list of samples from a <a>Signal</a>
--   
--   The elements in the list correspond to the values of the <a>Signal</a>
--   at consecutive clock cycles
--   
--   <pre>
--   sample s == [s0, s1, s2, s3, ...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
sample :: Foldable f => f a -> [a]

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>sampleN</b> :: Int -&gt; <a>Signal</a> a -&gt; [a]
--   </pre>
--   
--   Get a list of <tt>n</tt> samples from a <a>Signal</a>
--   
--   The elements in the list correspond to the values of the <a>Signal</a>
--   at consecutive clock cycles
--   
--   <pre>
--   sampleN 3 s == [s0, s1, s2]
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
sampleN :: Foldable f => Int -> f a -> [a]

-- | Create a <a>Signal</a> from a list
--   
--   Every element in the list will correspond to a value of the signal for
--   one clock cycle.
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 2 (fromList [1,2,3,4,5])
--   [1,2]
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
fromList :: [a] -> Signal' clk a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>testFor</b> :: <a>Int</a> -&gt; <a>Signal</a> Bool -&gt; <a>Property</a>
--   </pre>
--   
--   <tt>testFor n s</tt> tests the signal <tt>s</tt> for <tt>n</tt>
--   cycles.
testFor :: Foldable f => Int -> f Bool -> Property

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.==.)</b> :: <a>Eq</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>==</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.==.) :: (Eq a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(./=.)</b> :: <a>Eq</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>/=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(./=.) :: (Eq a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>compare</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Ordering</a>
--   </pre>
--   
--   It is a version of <a>compare</a> that returns a <a>Signal</a> of
--   <a>Ordering</a>
compare1 :: (Ord a, Applicative f) => f a -> f a -> f Ordering

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&lt;.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&lt;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.<.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&lt;=.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&lt;=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.<=.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&gt;=.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&gt;=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.>=.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&gt;.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&gt;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.>.) :: (Ord a, Applicative f) => f a -> f a -> f Bool
mapSignal# :: (a -> b) -> Signal' clk a -> Signal' clk b
signal# :: a -> Signal' clk a
appSignal# :: Signal' clk (a -> b) -> Signal' clk a -> Signal' clk b

-- | <b>NB</b>: Not synthesisable
--   
--   <b>NB</b>: In "<tt><a>foldr#</a> f z s</tt>":
--   
--   <ul>
--   <li>The function <tt>f</tt> should be <i>lazy</i> in its second
--   argument.</li>
--   <li>The <tt>z</tt> element will never be used.</li>
--   </ul>
foldr# :: (a -> b -> b) -> b -> Signal' clk a -> b
traverse# :: Applicative f => (a -> f b) -> Signal' clk a -> f (Signal' clk b)

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>fromEnum1</b> :: <a>Enum</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a>
--   </pre>
--   
--   It is a version of <a>fromEnum</a> that returns a CLaSH.Signal.Signal'
--   of <a>Int</a>
fromEnum1 :: (Enum a, Functor f) => f a -> f Int

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>fromEnum1</b> :: <a>Real</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Rational</a>
--   </pre>
--   
--   | It is a version of <a>toRational</a> that returns a <a>Signal</a> of
--   <a>Rational</a>
toRational1 :: (Real a, Functor f) => f a -> f Rational

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>toInteger1</b> :: <a>Integral</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Integer</a>
--   </pre>
--   
--   It is a version of <a>toRational</a> that returns a <a>Signal</a> of
--   <a>Integer</a>
toInteger1 :: (Integral a, Functor f) => f a -> f Integer

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>testBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of <a>testBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument, and a result of <a>Signal</a> of
--   <a>Bool</a>
testBit1 :: (Bits a, Applicative f) => f a -> f Int -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>popCount1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a>
--   </pre>
--   
--   It is a version of <a>popCount</a> that returns a <a>Signal</a> of
--   <a>Int</a>
popCount1 :: (Bits a, Functor f) => f a -> f Int

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shift1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shift</a> that has a <a>Signal</a> of <a>Int</a>
--   as indexing argument
shift1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotate1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotate</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotate1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>setBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>setBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
setBit1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>clearBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>clearBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
clearBit1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shiftL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shiftL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
shiftL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>unsafeShiftL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>unsafeShiftL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
unsafeShiftL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shiftR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shiftR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
shiftR1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>unsafeShiftR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>unsafeShiftR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
unsafeShiftR1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotateL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotateL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotateL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotateR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotateR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotateR1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | <b>WARNING: EXTREMELY EXPERIMENTAL</b>
--   
--   The circuit semantics of this operation are unclear and/or
--   non-existent. There is a good reason there is no <a>Monad</a> instance
--   for <a>Signal'</a>.
--   
--   Is currently treated as <a>id</a> by the CLaSH compiler.
joinSignal# :: Signal' clk (Signal' clk a) -> Signal' clk a
instance Show (SClock clk)
instance Show a => Show (Signal' clk a)
instance Lift a => Lift (Signal' clk a)
instance Default a => Default (Signal' clk a)
instance Functor (Signal' clk)
instance Applicative (Signal' clk)
instance Num a => Num (Signal' clk a)
instance Foldable (Signal' clk)
instance Traversable (Signal' clk)
instance Bounded a => Bounded (Signal' clk a)
instance ExtendingNum a b => ExtendingNum (Signal' clk a) (Signal' clk b)
instance SaturatingNum a => SaturatingNum (Signal' clk a)
instance Eq (Signal' clk a)
instance Ord a => Ord (Signal' clk a)
instance Enum a => Enum (Signal' clk a)
instance (Num a, Ord a) => Real (Signal' clk a)
instance Integral a => Integral (Signal' clk a)
instance Bits a => Bits (Signal' clk a)
instance FiniteBits a => FiniteBits (Signal' clk a)
instance Fractional a => Fractional (Signal' clk a)
instance Arbitrary a => Arbitrary (Signal' clk a)
instance CoArbitrary a => CoArbitrary (Signal' clk a)


module CLaSH.Sized.Internal.BitVector

-- | A vector of bits.
--   
--   <ul>
--   <li>Bit indices are descending</li>
--   <li><a>Num</a> instance performs <i>unsigned</i> arithmetic.</li>
--   </ul>
newtype BitVector (n :: Nat)

-- | The constructor, <a>BV</a>, and the field, <a>unsafeToInteger</a>, are
--   not synthesisable.
[BV] :: Integer -> BitVector
[unsafeToInteger] :: BitVector -> Integer

-- | <a>Bit</a>: a <a>BitVector</a> of length 1
type Bit = BitVector 1
size# :: KnownNat n => BitVector n -> Int
maxIndex# :: KnownNat n => BitVector n -> Int

-- | logic '1'
high :: Bit

-- | logic '0'
low :: Bit

-- | Create a binary literal
--   
--   <pre>
--   &gt;&gt;&gt; $$(bLit "1001") :: BitVector 4
--   1001
--   
--   &gt;&gt;&gt; $$(bLit "1001") :: BitVector 3
--   001
--   </pre>
--   
--   <b>NB</b>: You can also just write:
--   
--   <pre>
--   &gt;&gt;&gt; 0b1001 :: BitVector 4
--   1001
--   </pre>
--   
--   The advantage of <a>bLit</a> is that you can use computations to
--   create the string literal:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; $$(bLit (List.replicate 4 '1')) :: BitVector 4
--   1111
--   </pre>
bLit :: KnownNat n => String -> Q (TExp (BitVector n))

-- | Concatenate two <a>BitVector</a>s
(++#) :: KnownNat m => BitVector n -> BitVector m -> BitVector (n + m)
reduceAnd# :: (KnownNat n) => BitVector n -> BitVector 1
reduceOr# :: BitVector n -> BitVector 1
reduceXor# :: BitVector n -> BitVector 1
index# :: KnownNat n => BitVector n -> Int -> Bit
replaceBit# :: KnownNat n => BitVector n -> Int -> Bit -> BitVector n
setSlice# :: BitVector ((m + 1) + i) -> SNat m -> SNat n -> BitVector ((m + 1) - n) -> BitVector ((m + 1) + i)
slice# :: BitVector ((m + 1) + i) -> SNat m -> SNat n -> BitVector ((m + 1) - n)
split# :: KnownNat n => BitVector (m + n) -> (BitVector m, BitVector n)

-- | MSB
msb# :: KnownNat n => BitVector n -> Bit

-- | LSB
lsb# :: BitVector n -> Bit
eq# :: BitVector n -> BitVector n -> Bool
neq# :: BitVector n -> BitVector n -> Bool
lt# :: BitVector n -> BitVector n -> Bool
ge# :: BitVector n -> BitVector n -> Bool
gt# :: BitVector n -> BitVector n -> Bool
le# :: BitVector n -> BitVector n -> Bool
enumFrom# :: KnownNat n => BitVector n -> [BitVector n]
enumFromThen# :: KnownNat n => BitVector n -> BitVector n -> [BitVector n]
enumFromTo# :: KnownNat n => BitVector n -> BitVector n -> [BitVector n]
enumFromThenTo# :: KnownNat n => BitVector n -> BitVector n -> BitVector n -> [BitVector n]
minBound# :: KnownNat n => BitVector n
maxBound# :: KnownNat n => BitVector n
(+#) :: KnownNat n => BitVector n -> BitVector n -> BitVector n
(-#) :: KnownNat n => BitVector n -> BitVector n -> BitVector n
(*#) :: KnownNat n => BitVector n -> BitVector n -> BitVector n
negate# :: KnownNat n => BitVector n -> BitVector n
fromInteger# :: KnownNat n => Integer -> BitVector n
plus# :: KnownNat (Max m n + 1) => BitVector m -> BitVector n -> BitVector (Max m n + 1)
minus# :: KnownNat (Max m n + 1) => BitVector m -> BitVector n -> BitVector (Max m n + 1)
times# :: KnownNat (m + n) => BitVector m -> BitVector n -> BitVector (m + n)
quot# :: BitVector n -> BitVector n -> BitVector n
rem# :: BitVector n -> BitVector n -> BitVector n
toInteger# :: BitVector n -> Integer
and# :: BitVector n -> BitVector n -> BitVector n
or# :: BitVector n -> BitVector n -> BitVector n
xor# :: BitVector n -> BitVector n -> BitVector n
complement# :: KnownNat n => BitVector n -> BitVector n
shiftL# :: KnownNat n => BitVector n -> Int -> BitVector n
shiftR# :: KnownNat n => BitVector n -> Int -> BitVector n
rotateL# :: KnownNat n => BitVector n -> Int -> BitVector n
rotateR# :: KnownNat n => BitVector n -> Int -> BitVector n
popCount# :: BitVector n -> Int
resize# :: KnownNat m => BitVector n -> BitVector m
instance KnownNat n => Show (BitVector n)
instance Eq (BitVector n)
instance Ord (BitVector n)
instance KnownNat n => Enum (BitVector n)
instance KnownNat n => Bounded (BitVector n)
instance KnownNat n => Num (BitVector n)
instance (KnownNat (Max m n + 1), KnownNat (m + n)) => ExtendingNum (BitVector m) (BitVector n)
instance KnownNat n => Real (BitVector n)
instance KnownNat n => Integral (BitVector n)
instance KnownNat n => Bits (BitVector n)
instance KnownNat n => FiniteBits (BitVector n)
instance KnownNat n => Default (BitVector n)
instance Resize BitVector
instance KnownNat n => Lift (BitVector n)
instance (KnownNat n, KnownNat (n + 1), KnownNat (n + n)) => SaturatingNum (BitVector n)
instance KnownNat n => Arbitrary (BitVector n)
instance KnownNat n => CoArbitrary (BitVector n)
instance KnownNat n => Ixed (BitVector n)


module CLaSH.Sized.BitVector

-- | A vector of bits.
--   
--   <ul>
--   <li>Bit indices are descending</li>
--   <li><a>Num</a> instance performs <i>unsigned</i> arithmetic.</li>
--   </ul>
data BitVector (n :: Nat)

-- | <a>Bit</a>: a <a>BitVector</a> of length 1
type Bit = BitVector 1
size# :: KnownNat n => BitVector n -> Int
maxIndex# :: KnownNat n => BitVector n -> Int

-- | logic '1'
high :: Bit

-- | logic '0'
low :: Bit

-- | Create a binary literal
--   
--   <pre>
--   &gt;&gt;&gt; $$(bLit "1001") :: BitVector 4
--   1001
--   
--   &gt;&gt;&gt; $$(bLit "1001") :: BitVector 3
--   001
--   </pre>
--   
--   <b>NB</b>: You can also just write:
--   
--   <pre>
--   &gt;&gt;&gt; 0b1001 :: BitVector 4
--   1001
--   </pre>
--   
--   The advantage of <a>bLit</a> is that you can use computations to
--   create the string literal:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; $$(bLit (List.replicate 4 '1')) :: BitVector 4
--   1111
--   </pre>
bLit :: KnownNat n => String -> Q (TExp (BitVector n))

-- | Concatenate two <a>BitVector</a>s
(++#) :: KnownNat m => BitVector n -> BitVector m -> BitVector (n + m)


module CLaSH.Class.BitPack

-- | Convert to and from a <a>BitVector</a>
class BitPack a where type family BitSize a :: Nat
pack :: BitPack a => a -> BitVector (BitSize a)
unpack :: BitPack a => BitVector (BitSize a) -> a

-- | Coerce a value from one type to another through its bit
--   representation.
--   
--   <pre>
--   &gt;&gt;&gt; pack (-5 :: Signed 6)
--   11_1011
--   
--   &gt;&gt;&gt; bitCoerce (-5 :: Signed 6) :: Unsigned 6
--   59
--   
--   &gt;&gt;&gt; pack (59 :: Unsigned 6)
--   11_1011
--   </pre>
bitCoerce :: (BitPack a, BitPack b, BitSize a ~ BitSize b) => a -> b
instance BitPack Bool
instance BitPack (BitVector n)
instance (KnownNat (BitSize b), BitPack a, BitPack b) => BitPack (a, b)


module CLaSH.Prelude.BitIndex

-- | Get the bit at the specified bit index.
--   
--   <b>NB:</b> Bit indices are <b>DESCENDING</b>.
--   
--   <pre>
--   &gt;&gt;&gt; pack (7 :: Unsigned 6)
--   00_0111
--   
--   &gt;&gt;&gt; (7 :: Unsigned 6) ! 1
--   1
--   
--   &gt;&gt;&gt; (7 :: Unsigned 6) ! 5
--   0
--   
--   &gt;&gt;&gt; (7 :: Unsigned 6) ! 6
--   *** Exception: (!): 6 is out of range [5..0]
--   </pre>
(!) :: (BitPack a, KnownNat (BitSize a), Enum i) => a -> i -> Bit

-- | Get a slice between bit index <tt>m</tt> and and bit index <tt>n</tt>.
--   
--   <b>NB:</b> Bit indices are <b>DESCENDING</b>.
--   
--   <pre>
--   &gt;&gt;&gt; pack (7 :: Unsigned 6)
--   00_0111
--   
--   &gt;&gt;&gt; slice d4 d2 (7 :: Unsigned 6)
--   001
--   
--   &gt;&gt;&gt; slice d6 d4 (7 :: Unsigned 6)
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘7 + i0’ with ‘6’
--       The type variable ‘i0’ is ambiguous
--       Expected type: (6 + 1) + i0
--         Actual type: BitSize (Unsigned 6)
--       In the expression: slice d6 d4 (7 :: Unsigned 6)
--       In an equation for ‘it’: it = slice d6 d4 (7 :: Unsigned 6)
--   </pre>
slice :: (BitPack a, BitSize a ~ ((m + 1) + i)) => SNat m -> SNat n -> a -> BitVector ((m + 1) - n)

-- | Split a value of a bit size <tt>m + n</tt> into a tuple of values with
--   size <tt>m</tt> and size <tt>n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; pack (7 :: Unsigned 6)
--   00_0111
--   
--   &gt;&gt;&gt; split (7 :: Unsigned 6) :: (BitVector 2, BitVector 4)
--   (00,0111)
--   </pre>
split :: (BitPack a, BitSize a ~ (m + n), KnownNat n) => a -> (BitVector m, BitVector n)

-- | Set the bit at the specified index
--   
--   <b>NB:</b> Bit indices are <b>DESCENDING</b>.
--   
--   <pre>
--   &gt;&gt;&gt; pack (-5 :: Signed 6)
--   11_1011
--   
--   &gt;&gt;&gt; replaceBit 4 0 (-5 :: Signed 6)
--   -21
--   
--   &gt;&gt;&gt; pack (-21 :: Signed 6)
--   10_1011
--   
--   &gt;&gt;&gt; replaceBit 5 0 (-5 :: Signed 6)
--   27
--   
--   &gt;&gt;&gt; pack (27 :: Signed 6)
--   01_1011
--   
--   &gt;&gt;&gt; replaceBit 6 0 (-5 :: Signed 6)
--   *** Exception: replaceBit: 6 is out of range [5..0]
--   </pre>
replaceBit :: (BitPack a, KnownNat (BitSize a), Enum i) => i -> Bit -> a -> a

-- | Set the bits between bit index <tt>m</tt> and bit index <tt>n</tt>.
--   
--   <b>NB:</b> Bit indices are <b>DESCENDING</b>.
--   
--   <pre>
--   &gt;&gt;&gt; pack (-5 :: Signed 6)
--   11_1011
--   
--   &gt;&gt;&gt; setSlice d4 d3 0 (-5 :: Signed 6)
--   -29
--   
--   &gt;&gt;&gt; pack (-29 :: Signed 6)
--   10_0011
--   
--   &gt;&gt;&gt; setSlice d6 d5 0 (-5 :: Signed 6)
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘7 + i0’ with ‘6’
--       The type variable ‘i0’ is ambiguous
--       Expected type: (6 + 1) + i0
--         Actual type: BitSize (Signed 6)
--       In the expression: setSlice d6 d5 0 (- 5 :: Signed 6)
--       In an equation for ‘it’: it = setSlice d6 d5 0 (- 5 :: Signed 6)
--   </pre>
setSlice :: (BitPack a, BitSize a ~ ((m + 1) + i)) => SNat m -> SNat n -> BitVector ((m + 1) - n) -> a -> a

-- | Get the most significant bit.
--   
--   <pre>
--   &gt;&gt;&gt; pack (-4 :: Signed 6)
--   11_1100
--   
--   &gt;&gt;&gt; msb (-4 :: Signed 6)
--   1
--   
--   &gt;&gt;&gt; pack (4 :: Signed 6)
--   00_0100
--   
--   &gt;&gt;&gt; msb (4 :: Signed 6)
--   0
--   </pre>
msb :: (BitPack a, KnownNat (BitSize a)) => a -> Bit

-- | Get the least significant bit.
--   
--   <pre>
--   &gt;&gt;&gt; pack (-9 :: Signed 6)
--   11_0111
--   
--   &gt;&gt;&gt; lsb (-9 :: Signed 6)
--   1
--   
--   &gt;&gt;&gt; pack (-8 :: Signed 6)
--   11_1000
--   
--   &gt;&gt;&gt; lsb (-8 :: Signed 6)
--   0
--   </pre>
lsb :: BitPack a => a -> Bit


module CLaSH.Prelude.BitReduction

-- | Are all bits set to '1'?
--   
--   <pre>
--   &gt;&gt;&gt; pack (-2 :: Signed 6)
--   11_1110
--   
--   &gt;&gt;&gt; reduceAnd (-2 :: Signed 6)
--   0
--   
--   &gt;&gt;&gt; pack (-1 :: Signed 6)
--   11_1111
--   
--   &gt;&gt;&gt; reduceAnd (-1 :: Signed 6)
--   1
--   </pre>
reduceAnd :: (BitPack a, KnownNat (BitSize a)) => a -> Bit

-- | Is there at least one bit set to '1'?
--   
--   <pre>
--   &gt;&gt;&gt; pack (5 :: Signed 6)
--   00_0101
--   
--   &gt;&gt;&gt; reduceOr (5 :: Signed 6)
--   1
--   
--   &gt;&gt;&gt; pack (0 :: Signed 6)
--   00_0000
--   
--   &gt;&gt;&gt; reduceOr (0 :: Signed 6)
--   0
--   </pre>
reduceOr :: BitPack a => a -> Bit

-- | Is the number of bits set to '1' uneven?
--   
--   <pre>
--   &gt;&gt;&gt; pack (5 :: Signed 6)
--   00_0101
--   
--   &gt;&gt;&gt; reduceXor (5 :: Signed 6)
--   0
--   
--   &gt;&gt;&gt; pack (28 :: Signed 6)
--   01_1100
--   
--   &gt;&gt;&gt; reduceXor (28 :: Signed 6)
--   1
--   
--   &gt;&gt;&gt; pack (-5 :: Signed 6)
--   11_1011
--   
--   &gt;&gt;&gt; reduceXor (-5 :: Signed 6)
--   1
--   </pre>
reduceXor :: BitPack a => a -> Bit


module CLaSH.Sized.Vector

-- | Fixed size vectors
--   
--   <ul>
--   <li>Lists with their length encoded in their type</li>
--   <li><a>Vec</a>tor elements have an <b>ASCENDING</b> subscript starting
--   from 0 and ending at <a>maxIndex</a> (== <a>length</a> - 1).</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; 3:&gt;4:&gt;5:&gt;Nil
--   &lt;3,4,5&gt;
--   
--   &gt;&gt;&gt; let x = 3:&gt;4:&gt;5:&gt;Nil
--   
--   &gt;&gt;&gt; :t x
--   x :: Num a =&gt; Vec 3 a
--   </pre>
data Vec :: Nat -> * -> *
[Nil] :: Vec 0 a
[:>] :: a -> Vec n a -> Vec (n + 1) a

-- | Add an element to the tail of a vector.
--   
--   <pre>
--   &gt;&gt;&gt; (3:&gt;4:&gt;5:&gt;Nil) &lt;: 1
--   &lt;3,4,5,1&gt;
--   
--   &gt;&gt;&gt; let x = (3:&gt;4:&gt;5:&gt;Nil) &lt;: 1
--   
--   &gt;&gt;&gt; :t x
--   x :: Num a =&gt; Vec 4 a
--   </pre>
(<:) :: Vec n a -> a -> Vec (n + 1) a

-- | Create a vector of one element
--   
--   <pre>
--   &gt;&gt;&gt; singleton 5
--   &lt;5&gt;
--   </pre>
singleton :: a -> Vec 1 a

-- | Extract the first element of a vector
--   
--   <pre>
--   &gt;&gt;&gt; head (1:&gt;2:&gt;3:&gt;Nil)
--   1
--   
--   &gt;&gt;&gt; head Nil
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘...’ with ‘0’
--       Expected type: Vec ... a
--         Actual type: Vec 0 a
--       In the first argument of ‘head’, namely ‘Nil’
--       In the expression: head Nil
--   </pre>
head :: Vec (n + 1) a -> a

-- | Extract the elements after the head of a vector
--   
--   <pre>
--   &gt;&gt;&gt; tail (1:&gt;2:&gt;3:&gt;Nil)
--   &lt;2,3&gt;
--   
--   &gt;&gt;&gt; tail Nil
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘...’ with ‘0’
--       Expected type: Vec ... a
--         Actual type: Vec 0 a
--       In the first argument of ‘tail’, namely ‘Nil’
--       In the expression: tail Nil
--   </pre>
tail :: Vec (n + 1) a -> Vec n a

-- | Extract the last element of a vector
--   
--   <pre>
--   &gt;&gt;&gt; last (1:&gt;2:&gt;3:&gt;Nil)
--   3
--   
--   &gt;&gt;&gt; last Nil
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘...’ with ‘0’
--       Expected type: Vec ... a
--         Actual type: Vec 0 a
--       In the first argument of ‘last’, namely ‘Nil’
--       In the expression: last Nil
--   </pre>
last :: Vec (n + 1) a -> a

-- | Extract all the elements of a vector except the last element
--   
--   <pre>
--   &gt;&gt;&gt; init (1:&gt;2:&gt;3:&gt;Nil)
--   &lt;1,2&gt;
--   
--   &gt;&gt;&gt; init Nil
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘...’ with ‘0’
--       Expected type: Vec ... a
--         Actual type: Vec 0 a
--       In the first argument of ‘init’, namely ‘Nil’
--       In the expression: init Nil
--   </pre>
init :: Vec (n + 1) a -> Vec n a

-- | <a>take</a> <tt>n</tt>, applied to a vector <tt>xs</tt>, returns the
--   <tt>n</tt>-length prefix of <tt>xs</tt>
--   
--   <pre>
--   &gt;&gt;&gt; take (snat :: SNat 3) (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;1,2,3&gt;
--   
--   &gt;&gt;&gt; take d3               (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;1,2,3&gt;
--   
--   &gt;&gt;&gt; take d0               (1:&gt;2:&gt;Nil)
--   &lt;&gt;
--   
--   &gt;&gt;&gt; take d4               (1:&gt;2:&gt;Nil)
--   
--   &lt;interactive&gt;:...
--       Couldn't match type ‘4 + n0’ with ‘2’
--       The type variable ‘n0’ is ambiguous
--       Expected type: Vec (4 + n0) a
--         Actual type: Vec (1 + 1) a
--       In the second argument of ‘take’, namely ‘(1 :&gt; 2 :&gt; Nil)’
--       In the expression: take d4 (1 :&gt; 2 :&gt; Nil)
--       In an equation for ‘it’: it = take d4 (1 :&gt; 2 :&gt; Nil)
--   </pre>
take :: SNat m -> Vec (m + n) a -> Vec m a

-- | <a>takeI</a> <tt>xs</tt>, returns the prefix of <tt>xs</tt> as
--   demanded by the context
--   
--   <pre>
--   &gt;&gt;&gt; takeI (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) :: Vec 2 Int
--   &lt;1,2&gt;
--   </pre>
takeI :: KnownNat m => Vec (m + n) a -> Vec m a

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements
--   
--   <pre>
--   &gt;&gt;&gt; drop (snat :: SNat 3) (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;4,5&gt;
--   
--   &gt;&gt;&gt; drop d3               (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;4,5&gt;
--   
--   &gt;&gt;&gt; drop d0               (1:&gt;2:&gt;Nil)
--   &lt;1,2&gt;
--   
--   &gt;&gt;&gt; drop d4               (1:&gt;2:&gt;Nil)
--   
--   &lt;interactive&gt;:...
--       Couldn't match expected type ‘2’ with actual type ‘4 + n0’
--       The type variable ‘n0’ is ambiguous
--       In the first argument of ‘print’, namely ‘it’
--       In a stmt of an interactive GHCi command: print it
--   </pre>
drop :: SNat m -> Vec (m + n) a -> Vec n a

-- | <a>dropI</a> <tt>xs</tt>, returns the suffix of <tt>xs</tt> as
--   demanded by the context
--   
--   <pre>
--   &gt;&gt;&gt; dropI (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) :: Vec 2 Int
--   &lt;4,5&gt;
--   </pre>
dropI :: KnownNat m => Vec (m + n) a -> Vec n a

-- | <a>at</a> <tt>n xs</tt> returns <tt>n</tt>'th element of <tt>xs</tt>
--   
--   <b>NB</b>: vector elements have an <b>ASCENDING</b> subscript starting
--   from 0 and ending at <a>maxIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; at (snat :: SNat 1) (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   2
--   
--   &gt;&gt;&gt; at d1               (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   2
--   </pre>
at :: SNat m -> Vec (m + (n + 1)) a -> a

-- | <a>select</a> <tt>f s n xs</tt> selects <tt>n</tt> elements with
--   stepsize <tt>s</tt> and offset <tt>f</tt> from <tt>xs</tt>
--   
--   <pre>
--   &gt;&gt;&gt; select (snat :: SNat 1) (snat :: SNat 2) (snat :: SNat 3) (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;6:&gt;7:&gt;8:&gt;Nil)
--   &lt;2,4,6&gt;
--   
--   &gt;&gt;&gt; select d1 d2 d3 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;6:&gt;7:&gt;8:&gt;Nil)
--   &lt;2,4,6&gt;
--   </pre>
select :: (CmpNat (i + s) (s * n) ~ GT) => SNat f -> SNat s -> SNat n -> Vec (f + i) a -> Vec n a

-- | <a>selectI</a> <tt>f s xs</tt> selects as many elements as demanded by
--   the context with stepsize <tt>s</tt> and offset <tt>f</tt> from
--   <tt>xs</tt>
--   
--   <pre>
--   &gt;&gt;&gt; selectI d1 d2 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;6:&gt;7:&gt;8:&gt;Nil) :: Vec 2 Int
--   &lt;2,4&gt;
--   </pre>
selectI :: (CmpNat (i + s) (s * n) ~ GT, KnownNat n) => SNat f -> SNat s -> Vec (f + i) a -> Vec n a

-- | Append two vectors
--   
--   <pre>
--   &gt;&gt;&gt; (1:&gt;2:&gt;3:&gt;Nil) ++ (7:&gt;8:&gt;Nil)
--   &lt;1,2,3,7,8&gt;
--   </pre>
(++) :: Vec n a -> Vec m a -> Vec (n + m) a

-- | Add an element to the head of a vector, and extract all but the last
--   element.
--   
--   <pre>
--   &gt;&gt;&gt; 1 +&gt;&gt; (3:&gt;4:&gt;5:&gt;Nil)
--   &lt;1,3,4&gt;
--   
--   &gt;&gt;&gt; 1 +&gt;&gt; Nil
--   &lt;&gt;
--   </pre>
(+>>) :: KnownNat n => a -> Vec n a -> Vec n a

-- | Add an element to the tail of a vector, and extract all but the first
--   element.
--   
--   <pre>
--   &gt;&gt;&gt; (3:&gt;4:&gt;5:&gt;Nil) &lt;&lt;+ 1
--   &lt;4,5,1&gt;
--   
--   &gt;&gt;&gt; Nil &lt;&lt;+ 1
--   &lt;&gt;
--   </pre>
(<<+) :: Vec n a -> a -> Vec n a

-- | Concatenate a vector of vectors
--   
--   <pre>
--   &gt;&gt;&gt; concat ((1:&gt;2:&gt;3:&gt;Nil) :&gt; (4:&gt;5:&gt;6:&gt;Nil) :&gt; (7:&gt;8:&gt;9:&gt;Nil) :&gt; (10:&gt;11:&gt;12:&gt;Nil) :&gt; Nil)
--   &lt;1,2,3,4,5,6,7,8,9,10,11,12&gt;
--   </pre>
concat :: Vec n (Vec m a) -> Vec (n * m) a

-- | <a>zip</a> takes two vectors and returns a vector of corresponding
--   pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip (1:&gt;2:&gt;3:&gt;4:&gt;Nil) (4:&gt;3:&gt;2:&gt;1:&gt;Nil)
--   &lt;(1,4),(2,3),(3,2),(4,1)&gt;
--   </pre>
zip :: Vec n a -> Vec n b -> Vec n (a, b)

-- | <a>unzip</a> transforms a vector of pairs into a vector of first
--   components and a vector of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip ((1,4):&gt;(2,3):&gt;(3,2):&gt;(4,1):&gt;Nil)
--   (&lt;1,2,3,4&gt;,&lt;4,3,2,1&gt;)
--   </pre>
unzip :: Vec n (a, b) -> (Vec n a, Vec n b)

-- | <a>zip</a> takes three vectors and returns a vector of corresponding
--   triplets.
--   
--   <pre>
--   &gt;&gt;&gt; zip3 (1:&gt;2:&gt;3:&gt;4:&gt;Nil) (4:&gt;3:&gt;2:&gt;1:&gt;Nil) (5:&gt;6:&gt;7:&gt;8:&gt;Nil)
--   &lt;(1,4,5),(2,3,6),(3,2,7),(4,1,8)&gt;
--   </pre>
zip3 :: Vec n a -> Vec n b -> Vec n c -> Vec n (a, b, c)

-- | <a>unzip3</a> transforms a vector of triplets into a vector of first
--   components, a vector of second components, and a vector of third
--   components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 ((1,4,5):&gt;(2,3,6):&gt;(3,2,7):&gt;(4,1,8):&gt;Nil)
--   (&lt;1,2,3,4&gt;,&lt;4,3,2,1&gt;,&lt;5,6,7,8&gt;)
--   </pre>
unzip3 :: Vec n (a, b, c) -> (Vec n a, Vec n b, Vec n c)

-- | Shift in elements to the head of a vector, bumping out elements at the
--   tail. The result is a tuple containing:
--   
--   <ul>
--   <li>The new vector</li>
--   <li>The shifted out elements</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; shiftInAt0 (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil) ((-1) :&gt; 0 :&gt; Nil)
--   (&lt;-1,0,1,2&gt;,&lt;3,4&gt;)
--   
--   &gt;&gt;&gt; shiftInAt0 (1 :&gt; Nil) ((-1) :&gt; 0 :&gt; Nil)
--   (&lt;-1&gt;,&lt;0,1&gt;)
--   </pre>
shiftInAt0 :: KnownNat n => Vec n a -> Vec m a -> (Vec n a, Vec m a)

-- | Shift in element to the tail of a vector, bumping out elements at the
--   head. The result is a tuple containing:
--   
--   <ul>
--   <li>The new vector</li>
--   <li>The shifted out elements</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; shiftInAtN (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil) (5 :&gt; 6 :&gt; Nil)
--   (&lt;3,4,5,6&gt;,&lt;1,2&gt;)
--   
--   &gt;&gt;&gt; shiftInAtN (1 :&gt; Nil) (2 :&gt; 3 :&gt; Nil)
--   (&lt;3&gt;,&lt;1,2&gt;)
--   </pre>
shiftInAtN :: KnownNat m => Vec n a -> Vec m a -> (Vec n a, Vec m a)

-- | Shift <tt>m</tt> elements out from the head of a vector, filling up
--   the tail with <a>Default</a> values. The result is a tuple containing:
--   
--   <ul>
--   <li>The new vector</li>
--   <li>The shifted out values</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; shiftOutFrom0 d2 ((1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; 5 :&gt; Nil) :: Vec 5 Integer)
--   (&lt;3,4,5,0,0&gt;,&lt;1,2&gt;)
--   </pre>
shiftOutFrom0 :: (Default a, KnownNat m) => SNat m -> Vec (m + n) a -> (Vec (m + n) a, Vec m a)

-- | Shift <tt>m</tt> elements out from the tail of a vector, filling up
--   the head with <a>Default</a> values. The result is a tuple containing:
--   
--   <ul>
--   <li>The new vector</li>
--   <li>The shifted out values</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; shiftOutFromN d2 ((1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; 5 :&gt; Nil) :: Vec 5 Integer)
--   (&lt;0,0,1,2,3&gt;,&lt;4,5&gt;)
--   </pre>
shiftOutFromN :: (Default a, KnownNat (m + n)) => SNat m -> Vec (m + n) a -> (Vec (m + n) a, Vec m a)

-- | Split a vector into two vectors at the given point
--   
--   <pre>
--   &gt;&gt;&gt; splitAt (snat :: SNat 3) (1:&gt;2:&gt;3:&gt;7:&gt;8:&gt;Nil)
--   (&lt;1,2,3&gt;,&lt;7,8&gt;)
--   
--   &gt;&gt;&gt; splitAt d3 (1:&gt;2:&gt;3:&gt;7:&gt;8:&gt;Nil)
--   (&lt;1,2,3&gt;,&lt;7,8&gt;)
--   </pre>
splitAt :: SNat m -> Vec (m + n) a -> (Vec m a, Vec n a)

-- | Split a vector into two vectors where the length of the two is
--   determined by the context
--   
--   <pre>
--   &gt;&gt;&gt; splitAtI (1:&gt;2:&gt;3:&gt;7:&gt;8:&gt;Nil) :: (Vec 2 Int, Vec 3 Int)
--   (&lt;1,2&gt;,&lt;3,7,8&gt;)
--   </pre>
splitAtI :: KnownNat m => Vec (m + n) a -> (Vec m a, Vec n a)

-- | Split a vector of (n * m) elements into a vector of vectors with
--   length m, where m is given
--   
--   <pre>
--   &gt;&gt;&gt; unconcat d4 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;6:&gt;7:&gt;8:&gt;9:&gt;10:&gt;11:&gt;12:&gt;Nil)
--   &lt;&lt;1,2,3,4&gt;,&lt;5,6,7,8&gt;,&lt;9,10,11,12&gt;&gt;
--   </pre>
unconcat :: KnownNat n => SNat m -> Vec (n * m) a -> Vec n (Vec m a)

-- | Split a vector of (n * m) elements into a vector of vectors with
--   length m, where m is determined by the context
--   
--   <pre>
--   &gt;&gt;&gt; unconcatI (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;6:&gt;7:&gt;8:&gt;9:&gt;10:&gt;11:&gt;12:&gt;Nil) :: Vec 2 (Vec 6 Int)
--   &lt;&lt;1,2,3,4,5,6&gt;,&lt;7,8,9,10,11,12&gt;&gt;
--   </pre>
unconcatI :: (KnownNat n, KnownNat m) => Vec (n * m) a -> Vec n (Vec m a)

-- | Merge two vectors, alternating their elements, i.e.,
--   
--   <pre>
--   &gt;&gt;&gt; merge (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil) (5 :&gt; 6 :&gt; 7 :&gt; 8 :&gt; Nil)
--   &lt;1,5,2,6,3,7,4,8&gt;
--   </pre>
merge :: Vec n a -> Vec n a -> Vec (n + n) a

-- | <a>map</a> <tt>f xs</tt> is the vector obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f (x1 :&gt; x2 :&gt;  ... :&gt; xn :&gt; Nil) == (f x1 :&gt; f x2 :&gt; ... :&gt; f xn :&gt; Nil)
--   </pre>
--   
--   and corresponds to the following circuit layout:
--   
map :: (a -> b) -> Vec n a -> Vec n b

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two vectors to
--   produce the vector of corresponding sums.
--   
--   <pre>
--   zipWith f (x1 :&gt; x2 :&gt; ... xn :&gt; Nil) (y1 :&gt; y2 :&gt; ... :&gt; yn :&gt; Nil) == (f x1 y1 :&gt; f x2 y2 :&gt; ... :&gt; f xn yn :&gt; Nil)
--   </pre>
--   
--   <tt>zipWith f xs ys</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB:</b> <a>zipWith</a> is <i>strict</i> in its second argument, and
--   <i>lazy</i> in its third. This matters when <a>zipWith</a> is used in
--   a recursive setting. See <a>lazyV</a> for more information.
zipWith :: (a -> b -> c) -> Vec n a -> Vec n b -> Vec n c

-- | <a>zipWith3</a> generalises <a>zip3</a> by zipping with the function
--   given as the first argument, instead of a tupling function.
--   
--   <pre>
--   zipWith3 f (x1 :&gt; x2 :&gt; ... xn :&gt; Nil) (y1 :&gt; y2 :&gt; ... :&gt; yn :&gt; Nil) (z1 :&gt; z2 :&gt; ... :&gt; zn :&gt; Nil) == (f x1 y1 z1 :&gt; f x2 y2 z2 :&gt; ... :&gt; f xn yn zn :&gt; Nil)
--   </pre>
--   
--   <tt>zipWith3 f xs ys zs</tt> corresponds to the following circuit
--   layout:
--   
--   
--   <b>NB:</b> <a>zipWith3</a> is <i>strict</i> in its second argument,
--   and <i>lazy</i> in its third and fourth. This matters when
--   <a>zipWith3</a> is used in a recursive setting. See <a>lazyV</a> for
--   more information.
zipWith3 :: (a -> b -> c -> d) -> Vec n a -> Vec n b -> Vec n c -> Vec n d

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a vector, reduces
--   the vector using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z (x1 :&gt; ... :&gt; xn1 :&gt; xn :&gt; Nil) == x1 `f` (... (xn1 `f` (xn `f` z))...)
--   foldr r z Nil                             == z
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (/) 1 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   1.875
--   </pre>
--   
--   <tt>foldr f z xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>: <tt>"<a>foldr</a> f z xs"</tt> produces a linear structure,
--   which has a depth, or delay, of O(<tt><a>length</a> xs</tt>). Use
--   <a>fold</a> if your binary operator <tt>f</tt> is associative, as
--   <tt>"<a>fold</a> f xs"</tt> produces a structure with a depth of
--   O(log_2(<tt><a>length</a> xs</tt>)).
foldr :: (a -> b -> b) -> b -> Vec n a -> b

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a vector, reduces
--   the vector using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z (x1 :&gt; x2 :&gt; ... :&gt; xn :&gt; Nil) == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   foldl f z Nil                            == z
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl (/) 1 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   8.333333333333333e-3
--   </pre>
--   
--   <tt>foldl f z xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>: <tt>"<a>foldl</a> f z xs"</tt> produces a linear structure,
--   which has a depth, or delay, of O(<tt><a>length</a> xs</tt>). Use
--   <a>fold</a> if your binary operator <tt>f</tt> is associative, as
--   <tt>"<a>fold</a> f xs"</tt> produces a structure with a depth of
--   O(log_2(<tt><a>length</a> xs</tt>)).
foldl :: (b -> a -> b) -> b -> Vec n a -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty vectors.
--   
--   <pre>
--   foldr1 f (x1 :&gt; ... :&gt; xn2 :&gt; xn1 :&gt; xn :&gt; Nil) == x1 `f` (... (xn2 `f` (xn1 `f` xn))...)
--   foldr1 f (x1 :&gt; Nil)                            == x1
--   foldr1 f Nil                                    == TYPE ERROR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (/) (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; 1 :&gt; Nil)
--   1.875
--   </pre>
--   
--   <tt>foldr1 f xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>: <tt>"<a>foldr1</a> f z xs"</tt> produces a linear
--   structure, which has a depth, or delay, of O(<tt><a>length</a>
--   xs</tt>). Use <a>fold</a> if your binary operator <tt>f</tt> is
--   associative, as <tt>"<a>fold</a> f xs"</tt> produces a structure with
--   a depth of O(log_2(<tt><a>length</a> xs</tt>)).
foldr1 :: (a -> a -> a) -> Vec (n + 1) a -> a

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty vectors.
--   
--   <pre>
--   foldl1 f (x1 :&gt; x2 :&gt; x3 :&gt; ... :&gt; xn :&gt; Nil) == (...((x1 `f` x2) `f` x3) `f`...) `f` xn
--   foldl1 f (x1 :&gt; Nil)                          == x1
--   foldl1 f Nil                                  == TYPE ERROR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (/) (1 :&gt; 5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   8.333333333333333e-3
--   </pre>
--   
--   <tt>foldl1 f xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>: <tt>"<a>foldl1</a> f z xs"</tt> produces a linear
--   structure, which has a depth, or delay, of O(<tt><a>length</a>
--   xs</tt>). Use <a>fold</a> if your binary operator <tt>f</tt> is
--   associative, as <tt>"<a>fold</a> f xs"</tt> produces a structure with
--   a depth of O(log_2(<tt><a>length</a> xs</tt>)).
foldl1 :: (a -> a -> a) -> Vec (n + 1) a -> a

-- | <a>fold</a> is a variant of <a>foldr1</a> and <a>foldl1</a>, but
--   instead of reducing from right to left, or left to right, it reduces a
--   vector using a tree-like structure. The depth, or delay, of the
--   structure produced by "<tt><a>fold</a> f xs</tt>", is hence
--   <tt>O(log_2(<a>length</a> xs))</tt>, and not <tt>O(<a>length</a>
--   xs)</tt>.
--   
--   <b>NB</b>: The binary operator "<tt>f</tt> in <tt><a>fold</a> f
--   xs</tt>" must be associative. <b>NB</b>: Not synthesisable
--   
--   <pre>
--   fold f (x1 :&gt; x2 :&gt; ... :&gt; xn1 :&gt; xn :&gt; Nil) == ((x1 `f` x2) `f` ...) `f` (... `f` (xn1 `f` xn))
--   fold f (x1 :&gt; Nil)                           == x1
--   fold f Nil                                   == TYPE ERROR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold (+) (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; 1 :&gt; Nil)
--   15
--   </pre>
fold :: (a -> a -> a) -> Vec (n + 1) a -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a vector of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z (x1 :&gt; x2 :&gt; ... :&gt; Nil) == z :&gt; (z `f` x1) :&gt; ((z `f` x1) `f` x2) :&gt; ... :&gt; Nil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   &lt;0,5,9,12,14&gt;
--   </pre>
--   
--   <tt>scanl f z xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>:
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
scanl :: (b -> a -> b) -> b -> Vec n a -> Vec (n + 1) b

-- | <a>scanr</a> is similar to <a>foldr</a>, but returns a vector of
--   successive reduced values from the right:
--   
--   <pre>
--   scanr f z (... :&gt; xn1 :&gt; xn :&gt; Nil) == ... :&gt; (xn1 `f` (xn `f` z)) :&gt; (xn `f` z) :&gt; z :&gt; Nil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   &lt;14,9,5,2,0&gt;
--   </pre>
--   
--   <tt>scanr f z xs</tt> corresponds to the following circuit layout:
--   
--   
--   <b>NB</b>:
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs
--   </pre>
scanr :: (a -> b -> b) -> b -> Vec n a -> Vec (n + 1) b

-- | <a>sscanl</a> is a variant of <a>scanl</a> where the first result is
--   dropped:
--   
--   <pre>
--   sscanl f z (x1 :&gt; x2 :&gt; ... :&gt; Nil) == (z `f` x1) :&gt; ((z `f` x1) `f` x2) :&gt; ... :&gt; Nil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sscanl (+) 0 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   &lt;5,9,12,14&gt;
--   </pre>
--   
--   <tt>sscanl f z xs</tt> corresponds to the following circuit layout:
--   
sscanl :: (b -> a -> b) -> b -> Vec n a -> Vec n b

-- | <a>sscanr</a> is a variant of <a>scanr</a> that where the last result
--   is dropped:
--   
--   <pre>
--   sscanr f z (... :&gt; xn1 :&gt; xn :&gt; Nil) == ... :&gt; (xn1 `f` (xn `f` z)) :&gt; (xn `f` z) :&gt; Nil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sscanr (+) 0 (5 :&gt; 4 :&gt; 3 :&gt; 2 :&gt; Nil)
--   &lt;14,9,5,2&gt;
--   </pre>
--   
--   <tt>sscanr f z xs</tt> corresponds to the following circuit layout:
--   
sscanr :: (a -> b -> b) -> b -> Vec n a -> Vec n b

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a vector,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new vector.
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\acc x -&gt; (acc + x,acc + 1)) 0 (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil)
--   (10,&lt;1,2,4,7&gt;)
--   </pre>
--   
--   <tt>mapAccumL f acc xs</tt> corresponds to the following circuit
--   layout:
--   
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> Vec n x -> (acc, Vec n y)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a vector,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new vector.
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\acc x -&gt; (acc + x,acc + 1)) 0 (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; Nil)
--   (10,&lt;10,8,5,1&gt;)
--   </pre>
--   
--   <tt>mapAccumR f acc xs</tt> corresponds to the following circuit
--   layout:
--   
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> Vec n x -> (acc, Vec n y)

-- | A <i>dependently</i> typed fold.
--   
--   <b>NB</b>: Not synthesisable
--   
--   Using lists, we can define <tt>append</tt> (<a>++</a>) using
--   <a>foldr</a>:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Prelude
--   
--   &gt;&gt;&gt; let append xs ys = Prelude.foldr (:) ys xs
--   
--   &gt;&gt;&gt; append [1,2] [3,4]
--   [1,2,3,4]
--   </pre>
--   
--   However, when we try to do the same for <a>Vec</a>:
--   
--   <pre>
--   append' xs ys = <a>foldr</a> (:&gt;) ys xs
--   </pre>
--   
--   We get a type error
--   
--   <pre>
--   &gt;&gt;&gt; let append' xs ys = foldr (:&gt;) ys xs
--   
--   &lt;interactive&gt;:...
--       Occurs check: cannot construct the infinite type: n1 ~ n1 + 1
--       Expected type: a -&gt; Vec n1 a -&gt; Vec n1 a
--         Actual type: a -&gt; Vec n1 a -&gt; Vec (n1 + 1) a
--       Relevant bindings include
--         ys :: Vec n1 a (bound at ...)
--         append' :: Vec n a -&gt; Vec n1 a -&gt; Vec n1 a
--           (bound at ...)
--       In the first argument of ‘foldr’, namely ‘(:&gt;)’
--       In the expression: foldr (:&gt;) ys xs
--   </pre>
--   
--   The reason is that the type of <a>foldr</a> is:
--   
--   <pre>
--   &gt;&gt;&gt; :t foldr
--   foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Vec n a -&gt; b
--   </pre>
--   
--   While the type of (<a>:&gt;</a>) is:
--   
--   <pre>
--   &gt;&gt;&gt; :t (:&gt;)
--   (:&gt;) :: a -&gt; Vec n a -&gt; Vec (n + 1) a
--   </pre>
--   
--   We thus need a <tt>fold</tt> function that can handle the growing
--   vector type: <a>dfold</a>. Compared to <a>foldr</a>, <a>dfold</a>
--   takes an extra parameter, called the <i>motive</i>, that allows the
--   folded function to have an argument and result type that
--   <i>depends</i> on the current index into the vector. Using
--   <a>dfold</a>, we can now correctly define (<a>++</a>):
--   
--   <pre>
--   import Data.Singletons.Prelude
--   import Data.Proxy
--   
--   data Append (m :: Nat) (a :: *) (f :: <a>TyFun</a> Nat *) :: *
--   type instance <a>Apply</a> (Append m a) l = <a>Vec</a> (l + m) a
--   
--   append' xs ys = <a>dfold</a> (Proxy :: Proxy (Append m a)) (const (<a>:&gt;</a>)) ys xs
--   </pre>
--   
--   We now see that <tt>append'</tt> has the appropriate type:
--   
--   <pre>
--   &gt;&gt;&gt; :t append'
--   append' :: Vec k a -&gt; Vec m a -&gt; Vec (k + m) a
--   </pre>
--   
--   And that it works:
--   
--   <pre>
--   &gt;&gt;&gt; append' (1 :&gt; 2 :&gt; Nil) (3 :&gt; 4 :&gt; Nil)
--   &lt;1,2,3,4&gt;
--   </pre>
dfold :: Proxy (p :: TyFun Nat * -> *) -> (forall l. Proxy l -> a -> p $ l -> p $ (l + 1)) -> (p $ 0) -> Vec k a -> p $ k

-- | Specialised version of <a>dfold</a> that builds a triangular
--   computational structure.
--   
--   <b>NB</b>: Not synthesisable
--   
--   Example:
--   
--   <pre>
--   cs a b     = if a &gt; b then (a,b) else (b,a)
--   csRow y xs = let (y',xs') = <a>mapAccumL</a> cs y xs in xs' <a>&lt;:</a> y'
--   csSort     = <a>vfold</a> csRow
--   </pre>
--   
--   Builds a triangular structure of compare and swaps to sort a row.
--   
--   <pre>
--   &gt;&gt;&gt; csSort (7 :&gt; 3 :&gt; 9 :&gt; 1 :&gt; Nil)
--   &lt;1,3,7,9&gt;
--   </pre>
vfold :: (forall l. a -> Vec l b -> Vec (l + 1) b) -> Vec k a -> Vec k b

-- | Vector index (subscript) operator.
--   
--   <b>NB</b>: vector elements have an <b>ASCENDING</b> subscript starting
--   from 0 and ending at <a>maxIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) !! 4
--   5
--   
--   &gt;&gt;&gt; (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) !! maxIndex (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   5
--   
--   &gt;&gt;&gt; (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) !! 1
--   2
--   
--   &gt;&gt;&gt; (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) !! 14
--   *** Exception: CLaSH.Sized.Vector.(!!): index 14 is larger than maximum index 4
--   </pre>
(!!) :: (KnownNat n, Enum i) => Vec n a -> i -> a

-- | Replace an element of a vector at the given index (subscript).
--   
--   <b>NB</b>: vector elements have an <b>ASCENDING</b> subscript starting
--   from 0 and ending at <a>maxIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replace 3 7 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;1,2,3,7,5&gt;
--   
--   &gt;&gt;&gt; replace 0 7 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;7,2,3,4,5&gt;
--   
--   &gt;&gt;&gt; replace 9 7 (1:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil)
--   &lt;1,2,3,4,*** Exception: CLaSH.Sized.Vector.replace: index 9 is larger than maximum index 4
--   </pre>
replace :: (KnownNat n, Enum i) => i -> a -> Vec n a -> Vec n a

-- | Index (subscript) of the last element in a <a>Vec</a>tor
--   
--   <pre>
--   &gt;&gt;&gt; maxIndex (6 :&gt; 7 :&gt; 8 :&gt; Nil)
--   2
--   </pre>
maxIndex :: KnownNat n => Vec n a -> Integer

-- | Length of a <a>Vec</a>tor as an Integer
--   
--   <pre>
--   &gt;&gt;&gt; length (6 :&gt; 7 :&gt; 8 :&gt; Nil)
--   3
--   </pre>
length :: KnownNat n => Vec n a -> Integer

-- | <a>replicate</a> <tt>n a</tt> returns a vector that has <tt>n</tt>
--   copies of <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; replicate (snat :: SNat 3) 6
--   &lt;6,6,6&gt;
--   
--   &gt;&gt;&gt; replicate d3 6
--   &lt;6,6,6&gt;
--   </pre>
replicate :: SNat n -> a -> Vec n a

-- | <a>repeat</a> <tt>a</tt> creates a vector with as many copies of
--   <tt>a</tt> as demanded by the context
--   
--   <pre>
--   &gt;&gt;&gt; repeat 6 :: Vec 5 Int
--   &lt;6,6,6,6,6&gt;
--   </pre>
repeat :: KnownNat n => a -> Vec n a

-- | <a>iterate</a> <tt>n f x</tt> returns a vector starting with
--   <tt>x</tt> followed by <tt>n</tt> repeated applications of <tt>f</tt>
--   to <tt>x</tt>
--   
--   <pre>
--   iterate (snat :: SNat 4) f x == (x :&gt; f x :&gt; f (f x) :&gt; f (f (f x)) :&gt; Nil)
--   iterate d4 f x               == (x :&gt; f x :&gt; f (f x) :&gt; f (f (f x)) :&gt; Nil)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterate d4 (+1) 1
--   &lt;1,2,3,4&gt;
--   </pre>
--   
--   <tt>interate n f z</tt> corresponds to the following circuit layout:
--   
iterate :: SNat n -> (a -> a) -> a -> Vec n a

-- | <a>iterate</a> <tt>f x</tt> returns a vector starting with <tt>x</tt>
--   followed by <tt>n</tt> repeated applications of <tt>f</tt> to
--   <tt>x</tt>, where <tt>n</tt> is determined by the context
--   
--   <pre>
--   iterateI f x :: Vec 3 a == (x :&gt; f x :&gt; f (f x) :&gt; Nil)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateI (+1) 1 :: Vec 3 Int
--   &lt;1,2,3&gt;
--   </pre>
--   
--   <tt>interateI f z</tt> corresponds to the following circuit layout:
--   
iterateI :: KnownNat n => (a -> a) -> a -> Vec n a

-- | <a>generate</a> <tt>n f x</tt> returns a vector with <tt>n</tt>
--   repeated applications of <tt>f</tt> to <tt>x</tt>
--   
--   <pre>
--   generate (snat :: SNat 4) f x == (f x :&gt; f (f x) :&gt; f (f (f x)) :&gt; f (f (f (f x))) :&gt; Nil)
--   generate d4 f x               == (f x :&gt; f (f x) :&gt; f (f (f x)) :&gt; f (f (f (f x))) :&gt; Nil)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate d4 (+1) 1
--   &lt;2,3,4,5&gt;
--   </pre>
--   
--   <tt>generate n f z</tt> corresponds to the following circuit layout:
--   
generate :: SNat n -> (a -> a) -> a -> Vec n a

-- | <a>generate</a> <tt>f x</tt> returns a vector with <tt>n</tt> repeated
--   applications of <tt>f</tt> to <tt>x</tt>, where <tt>n</tt> is
--   determined by the context
--   
--   <pre>
--   generateI f x :: Vec 3 a == (f x :&gt; f (f x) :&gt; f (f (f x)) :&gt; Nil)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateI (+1) 1 :: Vec 3 Int
--   &lt;2,3,4&gt;
--   </pre>
--   
--   <tt>generateI f z</tt> corresponds to the following circuit layout:
--   
generateI :: KnownNat n => (a -> a) -> a -> Vec n a

-- | Returns the elements in a vector in reverse order
--   
--   <pre>
--   &gt;&gt;&gt; reverse (1:&gt;2:&gt;3:&gt;4:&gt;Nil)
--   &lt;4,3,2,1&gt;
--   </pre>
reverse :: Vec n a -> Vec n a

-- | Convert a vector to a list
--   
--   <pre>
--   &gt;&gt;&gt; toList (1:&gt;2:&gt;3:&gt;Nil)
--   [1,2,3]
--   </pre>
--   
--   <b>NB</b>: Not synthesisable
toList :: Vec n a -> [a]

-- | Create a vector literal from a list literal
--   
--   <pre>
--   $(v [1::Signed 8,2,3,4,5]) == (8:&gt;2:&gt;3:&gt;4:&gt;5:&gt;Nil) :: Vec 5 (Signed 8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1 :: Signed 8,2,3,4,5]
--   [1,2,3,4,5]
--   
--   &gt;&gt;&gt; $(v [1::Signed 8,2,3,4,5])
--   &lt;1,2,3,4,5&gt;
--   </pre>
v :: Lift a => [a] -> ExpQ

-- | For when your vector functions are too strict in their arguments
--   
--   For example:
--   
--   <pre>
--   -- Bubble sort for 1 iteration
--   sortV xs = <a>map</a> fst sorted <a>&lt;:</a> (snd (<a>last</a> sorted))
--    where
--      lefts  = <a>head</a> xs :&gt; <a>map</a> snd (<a>init</a> sorted)
--      rights = <a>tail</a> xs
--      sorted = <a>zipWith</a> compareSwapL lefts rights
--   
--   -- Compare and swap
--   compareSwapL a b = if a &lt; b then (a,b)
--                               else (b,a)
--   </pre>
--   
--   Will not terminate because <a>zipWith</a> is too strict in its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; sortV (4 :&gt; 1 :&gt; 2 :&gt; 3 :&gt; Nil)
--   &lt;*** Exception: &lt;&lt;loop&gt;&gt;
--   </pre>
--   
--   In this case, adding <a>lazyV</a> on <a>zipWith</a>s second argument:
--   
--   <pre>
--   sortVL xs = <a>map</a> fst sorted <a>&lt;:</a> (snd (<a>last</a> sorted))
--    where
--      lefts  = <a>head</a> xs :&gt; map snd (<a>init</a> sorted)
--      rights = <a>tail</a> xs
--      sorted = <a>zipWith</a> compareSwapL (<a>lazyV</a> lefts) rights
--   </pre>
--   
--   Results in a successful computation:
--   
--   <pre>
--   &gt;&gt;&gt; sortVL (4 :&gt; 1 :&gt; 2 :&gt; 3 :&gt; Nil)
--   &lt;1,2,3,4&gt;
--   </pre>
--   
--   <b>NB</b>: There is also a solution using <a>flip</a>, but it slightly
--   obfuscates the meaning of the code:
--   
--   <pre>
--   sortV_flip xs = <a>map</a> fst sorted <a>&lt;:</a> (snd (<a>last</a> sorted))
--    where
--      lefts  = <a>head</a> xs :&gt; <a>map</a> snd (<a>init</a> sorted)
--      rights = <a>tail</a> xs
--      sorted = <a>zipWith</a> (<a>flip</a> compareSwapL) rights lefts
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortV_flip (4 :&gt; 1 :&gt; 2 :&gt; 3 :&gt; Nil)
--   &lt;1,2,3,4&gt;
--   </pre>
lazyV :: KnownNat n => Vec n a -> Vec n a

-- | <a>Vec</a>tor as a <a>Proxy</a> for <a>Nat</a>
asNatProxy :: Vec n a -> Proxy n
concatBitVector# :: KnownNat m => Vec n (BitVector m) -> BitVector (n * m)
unconcatBitVector# :: (KnownNat n, KnownNat m) => BitVector (n * m) -> Vec n (BitVector m)
instance Show a => Show (Vec n a)
instance Eq a => Eq (Vec n a)
instance Ord a => Ord (Vec n a)
instance KnownNat n => Applicative (Vec n)
instance Foldable (Vec n)
instance Functor (Vec n)
instance Traversable (Vec n)
instance (Default a, KnownNat n) => Default (Vec n a)
instance (KnownNat n, KnownNat (BitSize a), BitPack a) => BitPack (Vec n a)
instance Lift a => Lift (Vec n a)
instance (KnownNat n, Arbitrary a) => Arbitrary (Vec n a)
instance CoArbitrary a => CoArbitrary (Vec n a)
instance KnownNat n => Ixed (Vec n a)


module CLaSH.Sized.Internal.Signed

-- | Arbitrary-width signed integer represented by <tt>n</tt> bits,
--   including the sign bit.
--   
--   Uses standard 2-complements representation. Meaning that, given
--   <tt>n</tt> bits, a <a>Signed</a> <tt>n</tt> number has a range of:
--   [-(2^(<tt>n</tt>-1)) .. 2^(<tt>n</tt>-1)-1]
--   
--   <b>NB</b>: The <a>Num</a> operators perform <tt>wrap-around</tt> on
--   overflow. If you want saturation on overflow, check out the
--   <a>SaturatingNum</a> class.
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Signed 3
--   3
--   
--   &gt;&gt;&gt; minBound :: Signed 3
--   -4
--   
--   &gt;&gt;&gt; 1 + 2 :: Signed 3
--   3
--   
--   &gt;&gt;&gt; 2 + 3 :: Signed 3
--   -3
--   
--   &gt;&gt;&gt; (-2) + (-3) :: Signed 3
--   3
--   
--   &gt;&gt;&gt; 2 * 3 :: Signed 4
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Signed 4
--   -8
--   
--   &gt;&gt;&gt; (2 :: Signed 3) `times` (4 :: Signed 4) :: Signed 7
--   8
--   
--   &gt;&gt;&gt; (2 :: Signed 3) `plus` (3 :: Signed 3) :: Signed 4
--   5
--   
--   &gt;&gt;&gt; (-2 :: Signed 3) `plus` (-3 :: Signed 3) :: Signed 4
--   -5
--   
--   &gt;&gt;&gt; satPlus SatSymmetric 2 3 :: Signed 3
--   3
--   
--   &gt;&gt;&gt; satPlus SatSymmetric (-2) (-3) :: Signed 3
--   -3
--   </pre>
newtype Signed (n :: Nat)

-- | The constructor, <a>S</a>, and the field, <a>unsafeToInteger</a>, are
--   not synthesisable.
[S] :: Integer -> Signed
[unsafeToInteger] :: Signed -> Integer
size# :: KnownNat n => Signed n -> Int
pack# :: KnownNat n => Signed n -> BitVector n
unpack# :: KnownNat n => BitVector n -> Signed n
eq# :: Signed n -> Signed n -> Bool
neq# :: Signed n -> Signed n -> Bool
lt# :: Signed n -> Signed n -> Bool
ge# :: Signed n -> Signed n -> Bool
gt# :: Signed n -> Signed n -> Bool
le# :: Signed n -> Signed n -> Bool
enumFrom# :: KnownNat n => Signed n -> [Signed n]
enumFromThen# :: KnownNat n => Signed n -> Signed n -> [Signed n]
enumFromTo# :: KnownNat n => Signed n -> Signed n -> [Signed n]
enumFromThenTo# :: KnownNat n => Signed n -> Signed n -> Signed n -> [Signed n]
minBound# :: KnownNat n => Signed n
maxBound# :: KnownNat n => Signed n
(+#) :: KnownNat n => Signed n -> Signed n -> Signed n
(-#) :: KnownNat n => Signed n -> Signed n -> Signed n
(*#) :: KnownNat n => Signed n -> Signed n -> Signed n
negate# :: KnownNat n => Signed n -> Signed n
abs# :: KnownNat n => Signed n -> Signed n
fromInteger# :: KnownNat n => Integer -> Signed (n :: Nat)
plus# :: KnownNat (1 + Max m n) => Signed m -> Signed n -> Signed (1 + Max m n)
minus# :: KnownNat (1 + Max m n) => Signed m -> Signed n -> Signed (1 + Max m n)
times# :: KnownNat (m + n) => Signed m -> Signed n -> Signed (m + n)
quot# :: Signed n -> Signed n -> Signed n
rem# :: Signed n -> Signed n -> Signed n
div# :: KnownNat n => Signed n -> Signed n -> Signed n
mod# :: KnownNat n => Signed n -> Signed n -> Signed n
toInteger# :: Signed n -> Integer
and# :: KnownNat n => Signed n -> Signed n -> Signed n
or# :: KnownNat n => Signed n -> Signed n -> Signed n
xor# :: KnownNat n => Signed n -> Signed n -> Signed n
complement# :: KnownNat n => Signed n -> Signed n
shiftL# :: KnownNat n => Signed n -> Int -> Signed n
shiftR# :: KnownNat n => Signed n -> Int -> Signed n
rotateL# :: KnownNat n => Signed n -> Int -> Signed n
rotateR# :: KnownNat n => Signed n -> Int -> Signed n
popCount# :: KnownNat n => Signed n -> Int
resize# :: (KnownNat n, KnownNat m) => Signed n -> Signed m
truncateB# :: KnownNat m => Signed (n + m) -> Signed m
minBoundSym# :: KnownNat n => Signed n
instance Show (Signed n)
instance KnownNat n => BitPack (Signed n)
instance Eq (Signed n)
instance Ord (Signed n)
instance KnownNat n => Enum (Signed n)
instance KnownNat n => Bounded (Signed n)
instance KnownNat n => Num (Signed n)
instance (KnownNat (1 + Max m n), KnownNat (m + n)) => ExtendingNum (Signed m) (Signed n)
instance KnownNat n => Real (Signed n)
instance KnownNat n => Integral (Signed n)
instance KnownNat n => Bits (Signed n)
instance KnownNat n => FiniteBits (Signed n)
instance Resize Signed
instance KnownNat n => Default (Signed n)
instance KnownNat n => Lift (Signed n)
instance (KnownNat n, KnownNat (1 + n), KnownNat (n + n)) => SaturatingNum (Signed n)
instance KnownNat n => Arbitrary (Signed n)
instance KnownNat n => CoArbitrary (Signed n)
instance KnownNat n => Ixed (Signed n)


module CLaSH.Sized.Signed

-- | Arbitrary-width signed integer represented by <tt>n</tt> bits,
--   including the sign bit.
--   
--   Uses standard 2-complements representation. Meaning that, given
--   <tt>n</tt> bits, a <a>Signed</a> <tt>n</tt> number has a range of:
--   [-(2^(<tt>n</tt>-1)) .. 2^(<tt>n</tt>-1)-1]
--   
--   <b>NB</b>: The <a>Num</a> operators perform <tt>wrap-around</tt> on
--   overflow. If you want saturation on overflow, check out the
--   <a>SaturatingNum</a> class.
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Signed 3
--   3
--   
--   &gt;&gt;&gt; minBound :: Signed 3
--   -4
--   
--   &gt;&gt;&gt; 1 + 2 :: Signed 3
--   3
--   
--   &gt;&gt;&gt; 2 + 3 :: Signed 3
--   -3
--   
--   &gt;&gt;&gt; (-2) + (-3) :: Signed 3
--   3
--   
--   &gt;&gt;&gt; 2 * 3 :: Signed 4
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Signed 4
--   -8
--   
--   &gt;&gt;&gt; (2 :: Signed 3) `times` (4 :: Signed 4) :: Signed 7
--   8
--   
--   &gt;&gt;&gt; (2 :: Signed 3) `plus` (3 :: Signed 3) :: Signed 4
--   5
--   
--   &gt;&gt;&gt; (-2 :: Signed 3) `plus` (-3 :: Signed 3) :: Signed 4
--   -5
--   
--   &gt;&gt;&gt; satPlus SatSymmetric 2 3 :: Signed 3
--   3
--   
--   &gt;&gt;&gt; satPlus SatSymmetric (-2) (-3) :: Signed 3
--   -3
--   </pre>
data Signed (n :: Nat)


module CLaSH.Sized.Internal.Unsigned

-- | Arbitrary-width unsigned integer represented by <tt>n</tt> bits
--   
--   Given <tt>n</tt> bits, an <a>Unsigned</a> <tt>n</tt> number has a
--   range of: [0 .. 2^<tt>n</tt>-1]
--   
--   <b>NB</b>: The <a>Num</a> operators perform <tt>wrap-around</tt> on
--   overflow. If you want saturation on overflow, check out the
--   <a>SaturatingNum</a> class.
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Unsigned 3
--   7
--   
--   &gt;&gt;&gt; minBound :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; 1 + 2 :: Unsigned 3
--   3
--   
--   &gt;&gt;&gt; 2 + 6 :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; 1 - 3 :: Unsigned 3
--   6
--   
--   &gt;&gt;&gt; 2 * 3 :: Unsigned 3
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; (2 :: Unsigned 3) `times` (4 :: Unsigned 3) :: Unsigned 6
--   8
--   
--   &gt;&gt;&gt; (2 :: Unsigned 3) `plus` (6 :: Unsigned 3) :: Unsigned 4
--   8
--   
--   &gt;&gt;&gt; satPlus SatSymmetric 2 6 :: Unsigned 3
--   7
--   
--   &gt;&gt;&gt; satMin SatSymmetric 2 3 :: Unsigned 3
--   0
--   </pre>
newtype Unsigned (n :: Nat)

-- | The constructor, <a>U</a>, and the field, <a>unsafeToInteger</a>, are
--   not synthesisable.
[U] :: Integer -> Unsigned
[unsafeToInteger] :: Unsigned -> Integer
size# :: KnownNat n => Unsigned n -> Int
pack# :: Unsigned n -> BitVector n
unpack# :: BitVector n -> Unsigned n
eq# :: Unsigned n -> Unsigned n -> Bool
neq# :: Unsigned n -> Unsigned n -> Bool
lt# :: Unsigned n -> Unsigned n -> Bool
ge# :: Unsigned n -> Unsigned n -> Bool
gt# :: Unsigned n -> Unsigned n -> Bool
le# :: Unsigned n -> Unsigned n -> Bool
enumFrom# :: KnownNat n => Unsigned n -> [Unsigned n]
enumFromThen# :: KnownNat n => Unsigned n -> Unsigned n -> [Unsigned n]
enumFromTo# :: KnownNat n => Unsigned n -> Unsigned n -> [Unsigned n]
enumFromThenTo# :: KnownNat n => Unsigned n -> Unsigned n -> Unsigned n -> [Unsigned n]
minBound# :: KnownNat n => Unsigned n
maxBound# :: KnownNat n => Unsigned n
(+#) :: KnownNat n => Unsigned n -> Unsigned n -> Unsigned n
(-#) :: KnownNat n => Unsigned n -> Unsigned n -> Unsigned n
(*#) :: KnownNat n => Unsigned n -> Unsigned n -> Unsigned n
negate# :: KnownNat n => Unsigned n -> Unsigned n
fromInteger# :: KnownNat n => Integer -> Unsigned n
plus# :: KnownNat (1 + Max m n) => Unsigned m -> Unsigned n -> Unsigned (1 + Max m n)
minus# :: KnownNat (1 + Max m n) => Unsigned m -> Unsigned n -> Unsigned (1 + Max m n)
times# :: KnownNat (m + n) => Unsigned m -> Unsigned n -> Unsigned (m + n)
quot# :: Unsigned n -> Unsigned n -> Unsigned n
rem# :: Unsigned n -> Unsigned n -> Unsigned n
toInteger# :: Unsigned n -> Integer
and# :: Unsigned n -> Unsigned n -> Unsigned n
or# :: Unsigned n -> Unsigned n -> Unsigned n
xor# :: Unsigned n -> Unsigned n -> Unsigned n
complement# :: KnownNat n => Unsigned n -> Unsigned n
shiftL# :: KnownNat n => Unsigned n -> Int -> Unsigned n
shiftR# :: KnownNat n => Unsigned n -> Int -> Unsigned n
rotateL# :: KnownNat n => Unsigned n -> Int -> Unsigned n
rotateR# :: KnownNat n => Unsigned n -> Int -> Unsigned n
popCount# :: Unsigned n -> Int
resize# :: KnownNat m => Unsigned n -> Unsigned m
instance Show (Unsigned n)
instance BitPack (Unsigned n)
instance Eq (Unsigned n)
instance Ord (Unsigned n)
instance KnownNat n => Enum (Unsigned n)
instance KnownNat n => Bounded (Unsigned n)
instance KnownNat n => Num (Unsigned n)
instance (KnownNat (1 + Max m n), KnownNat (m + n)) => ExtendingNum (Unsigned m) (Unsigned n)
instance KnownNat n => Real (Unsigned n)
instance KnownNat n => Integral (Unsigned n)
instance KnownNat n => Bits (Unsigned n)
instance KnownNat n => FiniteBits (Unsigned n)
instance Resize Unsigned
instance KnownNat n => Default (Unsigned n)
instance KnownNat n => Lift (Unsigned n)
instance (KnownNat n, KnownNat (1 + n), KnownNat (n + n)) => SaturatingNum (Unsigned n)
instance KnownNat n => Arbitrary (Unsigned n)
instance KnownNat n => CoArbitrary (Unsigned n)
instance KnownNat n => Ixed (Unsigned n)


module CLaSH.Sized.Unsigned

-- | Arbitrary-width unsigned integer represented by <tt>n</tt> bits
--   
--   Given <tt>n</tt> bits, an <a>Unsigned</a> <tt>n</tt> number has a
--   range of: [0 .. 2^<tt>n</tt>-1]
--   
--   <b>NB</b>: The <a>Num</a> operators perform <tt>wrap-around</tt> on
--   overflow. If you want saturation on overflow, check out the
--   <a>SaturatingNum</a> class.
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: Unsigned 3
--   7
--   
--   &gt;&gt;&gt; minBound :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; 1 + 2 :: Unsigned 3
--   3
--   
--   &gt;&gt;&gt; 2 + 6 :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; 1 - 3 :: Unsigned 3
--   6
--   
--   &gt;&gt;&gt; 2 * 3 :: Unsigned 3
--   6
--   
--   &gt;&gt;&gt; 2 * 4 :: Unsigned 3
--   0
--   
--   &gt;&gt;&gt; (2 :: Unsigned 3) `times` (4 :: Unsigned 3) :: Unsigned 6
--   8
--   
--   &gt;&gt;&gt; (2 :: Unsigned 3) `plus` (6 :: Unsigned 3) :: Unsigned 4
--   8
--   
--   &gt;&gt;&gt; satPlus SatSymmetric 2 6 :: Unsigned 3
--   7
--   
--   &gt;&gt;&gt; satMin SatSymmetric 2 3 :: Unsigned 3
--   0
--   </pre>
data Unsigned (n :: Nat)


-- | Fixed point numbers
--   
--   <ul>
--   <li>The <a>Num</a> operators for the given types saturate on overflow,
--   and use truncation as the rounding method.</li>
--   <li><a>Fixed</a> has an instance for <a>Fractional</a> meaning you use
--   fractional literals <tt>(3.75 :: <a>SFixed</a> 4 18)</tt>.</li>
--   <li>Both integer literals and fractional literals are clipped to
--   <a>minBound</a> and <a>maxBound</a>.</li>
--   <li>There is no <a>Floating</a> instance for <a>Fixed</a>, but you can
--   use <tt>$$(<a>fLit</a> d)</tt> to create <a>Fixed</a> point literal
--   from <a>Double</a> constant at compile-time.</li>
--   <li>Use <a>Constraint synonyms</a> when writing type signatures for
--   polymorphic functions that use <a>Fixed</a> point numbers.</li>
--   </ul>
--   
--   BEWARE: rounding by truncation introduces a sign bias!
--   
--   <ul>
--   <li>Truncation for positive numbers effectively results in: round
--   towards zero.</li>
--   <li>Truncation for negative numbers effectively results in: round
--   towards -infinity.</li>
--   </ul>
module CLaSH.Sized.Fixed

-- | Signed <a>Fixed</a>-point number, with <tt>int</tt> integer bits
--   (including sign-bit) and <tt>frac</tt> fractional bits.
--   
--   <ul>
--   <li>The range <a>SFixed</a> <tt>int</tt> <tt>frac</tt> numbers is:
--   [-(2^(<tt>int</tt> -1)) .. 2^(<tt>int</tt>-1) - 2^-<tt>frac</tt>
--   ]</li>
--   <li>The resolution of <a>SFixed</a> <tt>int</tt> <tt>frac</tt> numbers
--   is: 2^<tt>frac</tt></li>
--   <li>The <a>Num</a> operators for this type saturate on overflow, and
--   use truncation as the rounding method.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: SFixed 3 4
--   3.9375
--   
--   &gt;&gt;&gt; minBound :: SFixed 3 4
--   -4.0
--   
--   &gt;&gt;&gt; 1 + 2 :: SFixed 3 4
--   3.0
--   
--   &gt;&gt;&gt; 2 + 3 :: SFixed 3 4
--   3.9375
--   
--   &gt;&gt;&gt; (-2) + (-3) :: SFixed 3 4
--   -4.0
--   
--   &gt;&gt;&gt; 1.375 * (-0.8125) :: SFixed 3 4
--   -1.125
--   
--   &gt;&gt;&gt; (1.375 :: SFixed 3 4) `times` (-0.8125 :: SFixed 3 4) :: SFixed 6 8
--   -1.1171875
--   
--   &gt;&gt;&gt; (2 :: SFixed 3 4) `plus` (3 :: SFixed 3 4) :: SFixed 4 4
--   5.0
--   
--   &gt;&gt;&gt; (-2 :: SFixed 3 4) `plus` (-3 :: SFixed 3 4) :: SFixed 4 4
--   -5.0
--   </pre>
type SFixed = Fixed Signed

-- | Treat a <a>Signed</a> integer as a <tt>Signed</tt>
--   <a>Fixed</a>-<tt>point</tt> integer
--   
--   <pre>
--   &gt;&gt;&gt; sf d4 (-22 :: Signed 7)
--   -1.375
--   </pre>
sf :: SNat frac -> Signed (int + frac) -> SFixed int frac

-- | See the underlying representation of a Signed Fixed-point integer
unSF :: SFixed int frac -> Signed (int + frac)

-- | Unsigned <a>Fixed</a>-point number, with <tt>int</tt> integer bits and
--   <tt>frac</tt> fractional bits
--   
--   <ul>
--   <li>The range <a>UFixed</a> <tt>int</tt> <tt>frac</tt> numbers is: [0
--   .. 2^<tt>int</tt> - 2^-<tt>frac</tt> ]</li>
--   <li>The resolution of <a>UFixed</a> <tt>int</tt> <tt>frac</tt> numbers
--   is: 2^<tt>frac</tt></li>
--   <li>The <a>Num</a> operators for this type saturate on overflow, and
--   use truncation as the rounding method.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; maxBound :: UFixed 3 4
--   7.9375
--   
--   &gt;&gt;&gt; minBound :: UFixed 3 4
--   0.0
--   
--   &gt;&gt;&gt; 1 + 2 :: UFixed 3 4
--   3.0
--   
--   &gt;&gt;&gt; 2 + 6 :: UFixed 3 4
--   7.9375
--   
--   &gt;&gt;&gt; 1 - 3 :: UFixed 3 4
--   0.0
--   
--   &gt;&gt;&gt; 1.375 * 0.8125 :: UFixed 3 4
--   1.0625
--   
--   &gt;&gt;&gt; (1.375 :: UFixed 3 4) `times` (0.8125 :: UFixed 3 4) :: UFixed 6 8
--   1.1171875
--   
--   &gt;&gt;&gt; (2 :: UFixed 3 4) `plus` (6 :: UFixed 3 4) :: UFixed 4 4
--   8.0
--   </pre>
--   
--   However, <a>minus</a> does not saturate to <a>minBound</a> on
--   underflow:
--   
--   <pre>
--   &gt;&gt;&gt; (1 :: UFixed 3 4) `minus` (3 :: UFixed 3 4) :: UFixed 4 4
--   14.0
--   </pre>
type UFixed = Fixed Unsigned

-- | Treat an <a>Unsigned</a> integer as a <tt>Unsigned</tt>
--   <a>Fixed</a>-<tt>point</tt> number
--   
--   <pre>
--   &gt;&gt;&gt; uf d4 (92 :: Unsigned 7)
--   5.75
--   </pre>
uf :: SNat frac -> Unsigned (int + frac) -> UFixed int frac

-- | See the underlying representation of an Unsigned Fixed-point integer
unUF :: UFixed int frac -> Unsigned (int + frac)

-- | Fixed point division
--   
--   When used in a polymorphic setting, use the following <a>Constraint
--   synonyms</a> for less verbose type signatures:
--   
--   <ul>
--   <li><tt><a>DivideC</a> rep int1 frac1 int2 frac2</tt> for:
--   <tt><a>Fixed</a> rep int1 frac1 -&gt; <a>Fixed</a> rep int2 frac2
--   -&gt; <a>Fixed</a> rep (int1 + frac2 + 1) (int2 + frac1)</tt></li>
--   <li><tt><a>DivideSC</a> rep int1 frac1 int2 frac2</tt> for:
--   <tt><a>SFixed</a> int1 frac1 -&gt; <a>SFixed</a> int2 frac2 -&gt;
--   <a>SFixed</a> (int1 + frac2 + 1) (int2 + frac1)</tt></li>
--   <li><tt><a>DivideUC</a> rep int1 frac1 int2 frac2</tt> for:
--   <tt><a>UFixed</a> int1 frac1 -&gt; <a>UFixed</a> int2 frac2 -&gt;
--   <a>UFixed</a> (int1 + frac2 + 1) (int2 + frac1)</tt></li>
--   </ul>
divide :: DivideC rep int1 frac1 int2 frac2 => Fixed rep int1 frac1 -> Fixed rep int2 frac2 -> Fixed rep ((int1 + frac2) + 1) (int2 + frac1)

-- | Convert, at compile-time, a <a>Double</a> <i>constant</i> to a
--   <a>Fixed</a>-point <i>literal</i>. The conversion saturates on
--   overflow, and uses truncation as its rounding method.
--   
--   So when you type:
--   
--   <pre>
--   n = $$(<a>fLit</a> pi) :: <a>SFixed</a> 4 4
--   </pre>
--   
--   The compiler sees:
--   
--   <pre>
--   n = <a>Fixed</a> (fromInteger 50) :: <a>SFixed</a> 4 4
--   </pre>
--   
--   Upon evaluation you see that the value is rounded / truncated in
--   accordance to the fixed point representation:
--   
--   <pre>
--   &gt;&gt;&gt; n
--   3.125
--   </pre>
--   
--   Further examples:
--   
--   <pre>
--   &gt;&gt;&gt; sin 0.5 :: Double
--   0.479425538604203
--   
--   &gt;&gt;&gt; $$(fLit (sin 0.5)) :: SFixed 1 8
--   0.4765625
--   
--   &gt;&gt;&gt; atan 0.2 :: Double
--   0.19739555984988078
--   
--   &gt;&gt;&gt; $$(fLit (atan 0.2)) :: SFixed 1 8
--   0.1953125
--   
--   &gt;&gt;&gt; $$(fLit (atan 0.2)) :: SFixed 1 20
--   0.19739532470703125
--   </pre>
fLit :: (size ~ (int + frac), KnownNat frac, Bounded (rep size), Integral (rep size)) => Double -> Q (TExp (Fixed rep int frac))

-- | Convert, at run-time, a <a>Double</a> to a <a>Fixed</a>-point.
--   
--   <b>NB</b>: this functions is <i>not</i> synthesisable
--   
--   <h1>Creating data-files </h1>
--   
--   An example usage of this function is for example to convert a data
--   file containing <a>Double</a>s to a data file with ASCI-encoded binary
--   numbers to be used by a synthesisable function like
--   <a>asyncRomFile</a>. For example, given a file <tt>Data.txt</tt>
--   containing:
--   
--   <pre>
--   1.2 2.0 3.0 4.0
--   -1.0 -2.0 -3.5 -4.0
--   </pre>
--   
--   which we want to put in a ROM, interpreting them as <tt>8.8</tt>
--   signed fixed point numbers. What we do is that we first create a
--   conversion utility, <tt>createRomFile</tt>, which uses <a>fLitR</a>:
--   
--   <tt>createRomFile.hs</tt>:
--   
--   <pre>
--   module Main where
--   
--   import CLaSH.Prelude
--   import System.Environment
--   import qualified Data.List as L
--   
--   createRomFile :: KnownNat n =&gt; (Double -&gt; BitVector n)
--                 -&gt; FilePath -&gt; FilePath -&gt; IO ()
--   createRomFile convert fileR fileW = do
--     f &lt;- readFile fileR
--     let ds :: [Double]
--         ds = L.concat . (L.map . L.map) read . L.map words $ lines f
--         bvs = L.map (filter (/= '_') . show . convert) ds
--     writeFile fileW (unlines bvs)
--   
--   toSFixed8_8 :: Double -&gt; SFixed 8 8
--   toSFixed8_8 = <a>fLitR</a>
--   
--   main :: IO ()
--   main = do
--     [fileR,fileW] &lt;- getArgs
--     createRomFile (<a>pack</a> . toSFixed8_8) fileR fileW
--   </pre>
--   
--   We then compile this to an executable:
--   
--   <pre>
--   $ clash --make createRomFile.hs
--   </pre>
--   
--   We can then use this utility to convert our <tt>Data.txt</tt> file
--   which contains <a>Double</a>s to a <tt>Data.bin</tt> file which will
--   containing the desired ASCI-encoded binary data:
--   
--   <pre>
--   $ ./createRomFile "Data.txt" "Data.bin"
--   </pre>
--   
--   Which results in a <tt>Data.bin</tt> file containing:
--   
--   <pre>
--   0000000100110011
--   0000001000000000
--   0000001100000000
--   0000010000000000
--   1111111100000000
--   1111111000000000
--   1111110010000000
--   1111110000000000
--   </pre>
--   
--   We can then use this <tt>Data.bin</tt> file in for our ROM:
--   
--   <pre>
--   romF :: Unsigned 3 -&gt; Unsigned 3 -&gt; SFixed 8 8
--   romF rowAddr colAddr = <a>unpack</a>
--                        $ <a>asyncRomFile</a> d8 "Data.bin" ((rowAddr * 4) + colAddr)
--   </pre>
--   
--   And see that it works as expected:
--   
--   <pre>
--   <b>&gt;&gt;&gt; romF 1 2</b>
--   -3.5
--   <b>&gt;&gt;&gt; romF 0 0</b>
--   1.19921875
--   </pre>
--   
--   <h2>Using Template Haskell</h2>
--   
--   For those of us who like to live on the edge, another option is to
--   convert our <tt>Data.txt</tt> at compile-time using <a>Template
--   Haskell</a>. For this we first create a module
--   <tt>CreateRomFileTH.hs</tt>:
--   
--   <pre>
--   module CreateRomFileTH (romDataFromFile) where
--   
--   import CLaSH.Prelude
--   import qualified Data.List        as L
--   import Language.Haskell.TH        (ExpQ, litE, stringL)
--   import Language.Haskell.TH.Syntax (qRunIO)
--   
--   createRomFile :: KnownNat n =&gt; (Double -&gt; BitVector n)
--                 -&gt; FilePath -&gt; FilePath -&gt; IO ()
--   createRomFile convert fileR fileW = do
--     f &lt;- readFile fileR
--     let ds :: [Double]
--         ds = L.concat . (L.map . L.map) read . L.map words $ lines f
--         bvs = L.map (filter (/= '_') . show . convert) ds
--     writeFile fileW (unlines bvs)
--   
--   romDataFromFile :: KnownNat n =&gt; (Double -&gt; BitVector n) -&gt; String -&gt; ExpQ
--   romDataFromFile convert fileR = do
--     let fileW = fileR L.++ ".bin"
--     bvF &lt;- qRunIO (createRomFile convert fileR fileW)
--     litE (stringL fileW)
--   </pre>
--   
--   Instead of first converting <tt>Data.txt</tt> to <tt>Data.bin</tt>, we
--   will now use the <tt>romDataFromFile</tt> function to convert
--   <tt>Data.txt</tt> to a new file in the proper format at compile-time
--   of our new <tt>romF'</tt> function:
--   
--   <pre>
--   import CLaSH.Prelude
--   import CreateRomFileTH
--   
--   toSFixed8_8 :: Double -&gt; SFixed 8 8
--   toSFixed8_8 = <a>fLitR</a>
--   
--   romF' :: Unsigned 3 -&gt; Unsigned 3 -&gt; SFixed 8 8
--   romF' rowAddr colAddr = unpack $
--     asyncRomFile d8
--                  $(romDataFromFile (pack . toSFixed8_8) "Data.txt") -- Template Haskell splice
--                  ((rowAddr * 4) + colAddr)
--   </pre>
--   
--   And see that it works just like the <tt>romF</tt> function from
--   earlier:
--   
--   <pre>
--   <b>&gt;&gt;&gt; romF' 1 2</b>
--   -3.5
--   <b>&gt;&gt;&gt; romF' 0 0</b>
--   1.19921875
--   </pre>
fLitR :: (size ~ (int + frac), KnownNat frac, Bounded (rep size), Integral (rep size)) => Double -> Fixed rep int frac

-- | <a>Fixed</a>-point number
--   
--   Where:
--   
--   <ul>
--   <li><tt>rep</tt> is the underlying representation</li>
--   <li><tt>int</tt> is the number of bits used to represent the integer
--   part</li>
--   <li><tt>frac</tt> is the number of bits used to represent the
--   fractional part</li>
--   </ul>
--   
--   The <a>Num</a> operators for this type saturate to <a>maxBound</a> on
--   overflow and <a>minBound</a> on underflow, and use truncation as the
--   rounding method.
newtype Fixed (rep :: Nat -> *) (int :: Nat) (frac :: Nat)
[Fixed] :: rep (int + frac) -> Fixed
[unFixed] :: Fixed -> rep (int + frac)

-- | Saturating resize operation, truncates for rounding
--   
--   <pre>
--   &gt;&gt;&gt; 0.8125 :: SFixed 3 4
--   0.8125
--   
--   &gt;&gt;&gt; resizeF (0.8125 :: SFixed 3 4) :: SFixed 2 3
--   0.75
--   
--   &gt;&gt;&gt; 3.4 :: SFixed 3 4
--   3.375
--   
--   &gt;&gt;&gt; resizeF (3.4 :: SFixed 3 4) :: SFixed 2 3
--   1.875
--   
--   &gt;&gt;&gt; maxBound :: SFixed 2 3
--   1.875
--   </pre>
--   
--   When used in a polymorphic setting, use the following <a>Constraint
--   synonyms</a> for less verbose type signatures:
--   
--   <ul>
--   <li><tt><a>ResizeFC</a> rep int1 frac1 int2 frac2</tt> for:
--   <tt><a>Fixed</a> rep int1 frac1 -&gt; <a>Fixed</a> rep int2
--   frac2</tt></li>
--   <li><tt><a>ResizeSFC</a> int1 frac1 int2 frac2</tt> for:
--   <tt><a>SFixed</a> int1 frac1 -&gt; <a>SFixed</a> int2 frac2</tt></li>
--   <li><tt><a>ResizeUFC</a> rep int1 frac1 int2 frac2</tt> for:
--   <tt><a>UFixed</a> int1 frac1 -&gt; <a>UFixed</a> int2 frac2</tt></li>
--   </ul>
resizeF :: (ResizeFC rep int1 frac1 int2 frac2, Bounded (rep (int2 + frac2))) => Fixed rep int1 frac1 -> Fixed rep int2 frac2

-- | Get the position of the virtual <tt>point</tt> of a
--   <a>Fixed</a>-<tt>point</tt> number
fracShift :: KnownNat frac => Fixed rep int frac -> Int

-- | Constraint for the <a>Num</a> instance of <a>SFixed</a>
type NumSFixedC int frac = (KnownNat frac, KnownNat (frac + frac), KnownNat (int + frac), KnownNat (1 + (int + frac)), KnownNat ((int + frac) + (int + frac)), ((int + int) + (frac + frac)) ~ ((int + frac) + (int + frac)))

-- | Constraint for the <a>ExtendingNum</a> instance of <a>SFixed</a>
type ENumSFixedC int1 frac1 int2 frac2 = (KnownNat frac1, KnownNat frac2, KnownNat (Max frac1 frac2), KnownNat (int1 + frac1), KnownNat (int2 + frac2), KnownNat ((int1 + int2) + (frac1 + frac2)), KnownNat (1 + Max (int1 + frac1) (int2 + frac2)), KnownNat ((1 + Max int1 int2) + Max frac1 frac2), ((int1 + frac1) + (int2 + frac2)) ~ ((int1 + int2) + (frac1 + frac2)))

-- | Constraint for the <a>Fractional</a> instance of <a>SFixed</a>
type FracSFixedC int frac = (NumSFixedC int frac, KnownNat int, KnownNat (((int + frac) + 1) + (int + frac)))

-- | Constraint for the <a>resizeF</a> function, specialized for
--   <a>SFixed</a>
type ResizeSFC int1 frac1 int2 frac2 = (KnownNat frac1, KnownNat frac2, KnownNat (int1 + frac1), KnownNat (int2 + frac2))

-- | Constraint for the <a>divide</a> function, specialized for
--   <a>SFixed</a>
type DivideSC int1 frac1 int2 frac2 = (KnownNat int2, KnownNat frac2, KnownNat (int1 + frac1), KnownNat (int2 + frac2), KnownNat (((int1 + frac2) + 1) + (int2 + frac1)))

-- | Constraint for the <a>Num</a> instance of <a>UFixed</a>
type NumUFixedC int frac = NumSFixedC int frac

-- | Constraint for the <a>ExtendingNum</a> instance of <a>UFixed</a>
type ENumUFixedC int1 frac1 int2 frac2 = ENumSFixedC int1 frac1 int2 frac2

-- | Constraint for the <a>Fractional</a> instance of <a>UFixed</a>
type FracUFixedC int frac = FracSFixedC int frac

-- | Constraint for the <a>resizeF</a> function, specialized for
--   <a>UFixed</a>
type ResizeUFC int1 frac1 int2 frac2 = ResizeSFC int1 frac1 int2 frac2

-- | Constraint for the <a>divide</a> function, specialized for
--   <a>UFixed</a>
type DivideUC int1 frac1 int2 frac2 = DivideSC int1 frac1 int2 frac2

-- | Constraint for the <a>Num</a> instance of <a>Fixed</a>
type NumFixedC rep int frac = (SaturatingNum (rep (int + frac)), ExtendingNum (rep (int + frac)) (rep (int + frac)), ResizeFC rep (int + int) (frac + frac) int frac, MResult (rep (int + frac)) (rep (int + frac)) ~ rep ((int + int) + (frac + frac)))

-- | Constraint for the <a>ExtendingNum</a> instance of <a>Fixed</a>
type ENumFixedC rep int1 frac1 int2 frac2 = (ResizeFC rep int1 frac1 (1 + Max int1 int2) (Max frac1 frac2), ResizeFC rep int2 frac2 (1 + Max int1 int2) (Max frac1 frac2), Bounded (rep ((1 + Max int1 int2) + Max frac1 frac2)), Num (rep ((1 + Max int1 int2) + Max frac1 frac2)), ExtendingNum (rep (int1 + frac1)) (rep (int2 + frac2)), MResult (rep (int1 + frac1)) (rep (int2 + frac2)) ~ rep ((int1 + int2) + (frac1 + frac2)))

-- | Constraint for the <a>Fractional</a> instance of <a>Fixed</a>
type FracFixedC rep int frac = (NumFixedC rep int frac, DivideC rep int frac int frac, Integral (rep (int + frac)))

-- | Constraint for the <a>resizeF</a> function
type ResizeFC rep int1 frac1 int2 frac2 = (Resize rep, Ord (rep (int1 + frac1)), Num (rep (int1 + frac1)), Bits (rep (int1 + frac1)), Bits (rep (int2 + frac2)), KnownNat frac1, KnownNat frac2, KnownNat (int1 + frac1), KnownNat (int2 + frac2))

-- | Constraint for the <a>divide</a> function
type DivideC rep int1 frac1 int2 frac2 = (Resize rep, Integral (rep (((int1 + frac2) + 1) + (int2 + frac1))), Bits (rep (((int1 + frac2) + 1) + (int2 + frac1))), KnownNat int2, KnownNat frac2, KnownNat (int1 + frac1), KnownNat (int2 + frac2), KnownNat (((int1 + frac2) + 1) + (int2 + frac1)))

-- | <a>Fixed</a> as a <a>Proxy</a> for it's representation type
--   <tt>rep</tt>
asRepProxy :: Fixed rep int frac -> Proxy rep

-- | <a>Fixed</a> as a <a>Proxy</a> for the number of integer bits
--   <tt>int</tt>
asIntProxy :: Fixed rep int frac -> Proxy int
instance Eq (rep (int + frac)) => Eq (Fixed rep int frac)
instance Ord (rep (int + frac)) => Ord (Fixed rep int frac)
instance Enum (rep (int + frac)) => Enum (Fixed rep int frac)
instance Bounded (rep (int + frac)) => Bounded (Fixed rep int frac)
instance Default (rep (int + frac)) => Default (Fixed rep int frac)
instance Arbitrary (rep (int + frac)) => Arbitrary (Fixed rep int frac)
instance CoArbitrary (rep (int + frac)) => CoArbitrary (Fixed rep int frac)
instance Bits (rep (int + frac)) => Bits (Fixed rep int frac)
instance (size ~ (int + frac), KnownNat frac, Integral (rep size)) => Show (Fixed rep int frac)
instance ENumFixedC rep int1 frac1 int2 frac2 => ExtendingNum (Fixed rep int1 frac1) (Fixed rep int2 frac2)
instance NumFixedC rep int frac => Num (Fixed rep int frac)
instance BitPack (rep (int + frac)) => BitPack (Fixed rep int frac)
instance (Lift (rep (int + frac)), KnownNat frac, KnownNat int, Typeable rep) => Lift (Fixed rep int frac)
instance NumFixedC rep int frac => SaturatingNum (Fixed rep int frac)
instance FracFixedC rep int frac => Fractional (Fixed rep int frac)


-- | The Product/Signal isomorphism
module CLaSH.Signal.Bundle

-- | Isomorphism between a <a>Signal</a> of a product type (e.g. a tuple)
--   and a product type of <a>Signal'</a>s.
--   
--   Instances of <a>Bundle</a> must satisfy the following laws:
--   
--   <pre>
--   <a>bundle'</a> . <a>unbundle'</a> = <a>id</a>
--   <a>unbundle'</a> . <a>bundle'</a> = <a>id</a>
--   </pre>
--   
--   By default, <a>bundle'</a> and <a>unbundle'</a>, are defined as the
--   identity, that is, writing:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D
--   </pre>
--   
--   is the same as:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D where
--     type <a>Unbundled'</a> clk D = <a>Signal'</a> clk D
--     <a>bundle'</a>   _ s = s
--     <a>unbundle'</a> _ s = s
--   </pre>
class Bundle a where type family Unbundled' (clk :: Clock) a Unbundled' clk a = Signal' clk a bundle' _ s = s unbundle' _ s = s
bundle' :: Bundle a => SClock clk -> Unbundled' clk a -> Signal' clk a
unbundle' :: Bundle a => SClock clk -> Signal' clk a -> Unbundled' clk a
instance Bundle Bool
instance Bundle Integer
instance Bundle Int
instance Bundle Float
instance Bundle Double
instance Bundle ()
instance Bundle (Maybe a)
instance Bundle (Either a b)
instance Bundle (BitVector n)
instance Bundle (Index n)
instance Bundle (Fixed rep int frac)
instance Bundle (Signed n)
instance Bundle (Unsigned n)
instance Bundle (a, b)
instance Bundle (a, b, c)
instance Bundle (a, b, c, d)
instance Bundle (a, b, c, d, e)
instance Bundle (a, b, c, d, e, f)
instance Bundle (a, b, c, d, e, f, g)
instance Bundle (a, b, c, d, e, f, g, h)
instance KnownNat n => Bundle (Vec n a)


module CLaSH.Signal.Explicit

-- | A synchronized signal with samples of type <tt>a</tt>, explicitly
--   synchronized to a clock <tt>clk</tt>
--   
--   <b>NB</b>: The constructor, <tt>(<a>:-</a>)</tt>, is <b>not</b>
--   synthesisable.
data Signal' (clk :: Clock) a

-- | A clock with a name (<a>Symbol</a>) and period (<a>Nat</a>)
data Clock
[Clk] :: Symbol -> Nat -> Clock

-- | Singleton value for a type-level <a>Clock</a> with the given
--   <tt>name</tt> and <tt>period</tt>
data SClock (clk :: Clock)
[SClock] :: SSymbol name -> SNat period -> SClock (Clk name period)

-- | Create a singleton clock
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   </pre>
sclock :: (KnownSymbol name, KnownNat period) => SClock (Clk name period)

-- | Supply a function with a singleton clock <tt>clk</tt> according to the
--   context
withSClock :: (KnownSymbol name, KnownNat period) => (SClock (Clk name period) -> a) -> a

-- | The standard system clock with a period of 1000
type SystemClock = Clk "system" 1000

-- | The singleton clock for <a>SystemClock</a>
systemClock :: SClock SystemClock

-- | Calculate relative periods given a list of frequencies.
--   
--   So for example, you have one part of your design connected to an ADC
--   running at 20 MHz, one part of your design connected to a DAC running
--   at 36 MHz, and the rest of your system is running at 50 MHz. What are
--   the relative (integer) clock periods in CλaSH, such that their ratios
--   correspond to the ratios between the actual clock frequencies.
--   
--   For this we use <a>freqCalc</a>:
--   
--   <pre>
--   &gt;&gt;&gt; freqCalc [20,36,50]
--   [45,25,18]
--   </pre>
--   
--   So that we create the proper clocks:
--   
--   <pre>
--   type ADC20 = <a>Clk</a> "ADC" 45
--   type DAC36 = <a>Clk</a> "DAC" 25
--   type Sys50 = <a>Clk</a> "Sys" 18
--   
--   sys50 :: SClock System50
--   sys50 = <a>sclock</a>
--   
--   adc20 :: SClock ADC20
--   adc20 = <a>sclock</a>
--   
--   dac36 :: SClock DAC36
--   dac36 = <a>sclock</a>
--   </pre>
--   
--   <b>NB</b>: This function is <i>not</i> synthesisable
freqCalc :: [Integer] -> [Integer]

-- | The <a>unsafeSynchronizer</a> function is a primitive that must be
--   used to connect one clock domain to the other, and will be synthesised
--   to a (bundle of) wire(s) in the eventual circuit. This function should
--   only be used as part of a proper synchronisation component, such as
--   the following dual flip-flop synchronizer:
--   
--   <pre>
--   dualFlipFlop :: SClock clkA -&gt; SClock clkB
--                -&gt; Signal' clkA Bit -&gt; Signal' clkB Bit
--   dualFlipFlop clkA clkB = <a>register'</a> clkB low . <a>register'</a> clkB low
--                          . <a>unsafeSynchronizer</a> clkA clkB
--   </pre>
--   
--   The <a>unsafeSynchronizer</a> works in such a way that, given 2
--   clocks:
--   
--   <pre>
--   type Clk7 = <a>Clk</a> "clk7" 7
--   
--   clk7 :: <a>SClock</a> Clk7
--   clk7 = <a>sclock</a>
--   </pre>
--   
--   and
--   
--   <pre>
--   type Clk2 = <a>Clk</a> "clk2" 2
--   
--   clk2 :: <a>SClock</a> Clk2
--   clk2 = <a>sclock</a>
--   </pre>
--   
--   Oversampling followed by compression is the identity function plus 2
--   initial values:
--   
--   <pre>
--   <a>register'</a> clk7 i $
--   <a>unsafeSynchronizer</a> clk2 clk7 $
--   <a>register'</a> clk2 j $
--   <a>unsafeSynchronizer</a> clk7 clk2 $
--   <a>register'</a> clk7 k s
--   
--   ==
--   
--   i :- j :- s
--   </pre>
--   
--   Something we can easily observe:
--   
--   <pre>
--   oversampling = <a>register'</a> clk2 99 . <a>unsafeSynchronizer</a> clk7 clk2
--                . <a>register'</a> clk7 50
--   almostId     = <a>register'</a> clk7 70 . <a>unsafeSynchronizer</a> clk2 clk7
--                . <a>register'</a> clk2 99 . <a>unsafeSynchronizer</a> clk7 clk2
--                . <a>register'</a> clk7 50
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 37 (oversampling (fromList [1..10]))
--   [99,50,1,1,1,2,2,2,2,3,3,3,4,4,4,4,5,5,5,6,6,6,6,7,7,7,8,8,8,8,9,9,9,10,10,10,10]
--   
--   &gt;&gt;&gt; sampleN 12 (almostId (fromList [1..10]))
--   [70,99,1,2,3,4,5,6,7,8,9,10]
--   </pre>
unsafeSynchronizer :: SClock clk1 -> SClock clk2 -> Signal' clk1 a -> Signal' clk2 a

-- | "<tt><a>register'</a> i s</tt>" delays the values in <a>Signal'</a>
--   <tt>s</tt> for one cycle, and sets the value at time 0 to <tt>i</tt>
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 3 (register' clkA 8 (fromList [1,2,3,4]))
--   [8,1,2]
--   </pre>
register' :: SClock clk -> a -> Signal' clk a -> Signal' clk a

-- | Version of <a>register'</a> that only updates its content when its
--   second argument is asserted. So given:
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   oscillate = <a>register'</a> clkA False (<a>not1</a> oscillate)
--   count     = <a>regEn'</a> clkA 0 oscillate (count + 1)
--   </pre>
--   
--   We get:
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 8 oscillate
--   [False,True,False,True,False,True,False,True]
--   
--   &gt;&gt;&gt; sampleN 8 count
--   [0,0,1,1,2,2,3,3]
--   </pre>
regEn' :: SClock clk -> a -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Isomorphism between a <a>Signal</a> of a product type (e.g. a tuple)
--   and a product type of <a>Signal'</a>s.
--   
--   Instances of <a>Bundle</a> must satisfy the following laws:
--   
--   <pre>
--   <a>bundle'</a> . <a>unbundle'</a> = <a>id</a>
--   <a>unbundle'</a> . <a>bundle'</a> = <a>id</a>
--   </pre>
--   
--   By default, <a>bundle'</a> and <a>unbundle'</a>, are defined as the
--   identity, that is, writing:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D
--   </pre>
--   
--   is the same as:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D where
--     type <a>Unbundled'</a> clk D = <a>Signal'</a> clk D
--     <a>bundle'</a>   _ s = s
--     <a>unbundle'</a> _ s = s
--   </pre>
class Bundle a where type family Unbundled' (clk :: Clock) a Unbundled' clk a = Signal' clk a bundle' _ s = s unbundle' _ s = s
bundle' :: Bundle a => SClock clk -> Unbundled' clk a -> Signal' clk a
unbundle' :: Bundle a => SClock clk -> Signal' clk a -> Unbundled' clk a

-- | Simulate a (<tt><a>Unbundled'</a> clk1 a -&gt; <a>Unbundled'</a> clk2
--   b</tt>) function given a list of samples of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB' clkA clkA (unbundle' clkA . register' clkA (8,8) . bundle' clkA) [(1,1), (2,2), (3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
simulateB' :: (Bundle a, Bundle b) => SClock clk1 -> SClock clk2 -> (Unbundled' clk1 a -> Unbundled' clk2 b) -> [a] -> [b]


module CLaSH.Signal

-- | Signal synchronised to the "system" clock, which has a period of 1000.
type Signal a = Signal' SystemClock a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>signal</b> :: a -&gt; <a>Signal</a> a
--   </pre>
--   
--   Create a constant <a>Signal</a> from a combinational value
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; List.take 5 (sample (signal 4 :: Signal Int))
--   [4,4,4,4,4]
--   </pre>
signal :: Applicative f => a -> f a

-- | <a>register</a> <tt>i s</tt> delays the values in <a>Signal</a>
--   <tt>s</tt> for one cycle, and sets the value at time 0 to <tt>i</tt>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 3 (register 8 (fromList [1,2,3,4]))
--   [8,1,2]
--   </pre>
register :: a -> Signal a -> Signal a

-- | Version of <a>register</a> that only updates its content when its
--   second argument is asserted. So given:
--   
--   <pre>
--   oscillate = <a>register</a> False (<a>not1</a> oscillate)
--   count     = <a>regEn</a> 0 oscillate (count + 1)
--   </pre>
--   
--   We get:
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 8 oscillate
--   [False,True,False,True,False,True,False,True]
--   
--   &gt;&gt;&gt; sampleN 8 count
--   [0,0,1,1,2,2,3,3]
--   </pre>
regEn :: a -> Signal Bool -> Signal a -> Signal a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>mux</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> a
--   </pre>
--   
--   A multiplexer. Given "<tt><a>mux</a> b t f</tt>", output <tt>t</tt>
--   when <tt>b</tt> is <a>True</a>, and <tt>f</tt> when <tt>b</tt> is
--   <a>False</a>.
mux :: Applicative f => f Bool -> f a -> f a -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&amp;&amp;.)</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&amp;&amp;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.&&.) :: Applicative f => f Bool -> f Bool -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.||.)</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>||</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.||.) :: Applicative f => f Bool -> f Bool -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>not1</b> :: <a>Signal</a> <a>Bool</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of <a>not</a> that operates on <a>Signal</a>s of
--   <a>Bool</a>
not1 :: Functor f => f Bool -> f Bool

-- | Isomorphism between a <a>Signal</a> of a product type (e.g. a tuple)
--   and a product type of <a>Signal'</a>s.
--   
--   Instances of <a>Bundle</a> must satisfy the following laws:
--   
--   <pre>
--   <a>bundle'</a> . <a>unbundle'</a> = <a>id</a>
--   <a>unbundle'</a> . <a>bundle'</a> = <a>id</a>
--   </pre>
--   
--   By default, <a>bundle'</a> and <a>unbundle'</a>, are defined as the
--   identity, that is, writing:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D
--   </pre>
--   
--   is the same as:
--   
--   <pre>
--   data D = A | B
--   
--   instance <a>Bundle</a> D where
--     type <a>Unbundled'</a> clk D = <a>Signal'</a> clk D
--     <a>bundle'</a>   _ s = s
--     <a>unbundle'</a> _ s = s
--   </pre>
class Bundle a where Unbundled' clk a = Signal' clk a bundle' _ s = s unbundle' _ s = s

-- | Isomorphism between a <a>Signal</a> of a product type (e.g. a tuple)
--   and a product type of <a>Signal</a>s.
type Unbundled a = Unbundled' SystemClock a

-- | Example:
--   
--   <pre>
--   <b>bundle</b> :: (<a>Signal</a> a, <a>Signal</a> b) -&gt; <a>Signal</a> (a,b)
--   </pre>
--   
--   However:
--   
--   <pre>
--   <b>bundle</b> :: <a>Signal</a> <a>Bit</a> -&gt; <a>Signal</a> <a>Bit</a>
--   </pre>
bundle :: Bundle a => Unbundled a -> Signal a

-- | Example:
--   
--   <pre>
--   <b>unbundle</b> :: <a>Signal</a> (a,b) -&gt; (<a>Signal</a> a, <a>Signal</a> b)
--   </pre>
--   
--   However:
--   
--   <pre>
--   <b>unbundle</b> :: <a>Signal</a> <a>Bit</a> -&gt; <a>Signal</a> <a>Bit</a>
--   </pre>
unbundle :: Bundle a => Signal a -> Unbundled a

-- | Simulate a (<tt><a>Signal</a> a -&gt; <a>Signal</a> b</tt>) function
--   given a list of samples of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; simulate (register 8) [1, 2, 3]
--   [8,1,2,3...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
simulate :: (Signal' clk1 a -> Signal' clk2 b) -> [a] -> [b]

-- | Simulate a (<tt><a>Unbundled</a> a -&gt; <a>Unbundled</a> b</tt>)
--   function given a list of samples of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB (unbundle . register (8,8) . bundle) [(1,1), (2,2), (3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
simulateB :: (Bundle a, Bundle b) => (Unbundled a -> Unbundled b) -> [a] -> [b]

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>sample</b> :: <a>Signal</a> a -&gt; [a]
--   </pre>
--   
--   Get an infinite list of samples from a <a>Signal</a>
--   
--   The elements in the list correspond to the values of the <a>Signal</a>
--   at consecutive clock cycles
--   
--   <pre>
--   sample s == [s0, s1, s2, s3, ...
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
sample :: Foldable f => f a -> [a]

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>sampleN</b> :: Int -&gt; <a>Signal</a> a -&gt; [a]
--   </pre>
--   
--   Get a list of <tt>n</tt> samples from a <a>Signal</a>
--   
--   The elements in the list correspond to the values of the <a>Signal</a>
--   at consecutive clock cycles
--   
--   <pre>
--   sampleN 3 s == [s0, s1, s2]
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
sampleN :: Foldable f => Int -> f a -> [a]

-- | Create a <a>Signal</a> from a list
--   
--   Every element in the list will correspond to a value of the signal for
--   one clock cycle.
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 2 (fromList [1,2,3,4,5])
--   [1,2]
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
fromList :: [a] -> Signal' clk a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>testFor</b> :: <a>Int</a> -&gt; <a>Signal</a> Bool -&gt; <a>Property</a>
--   </pre>
--   
--   <tt>testFor n s</tt> tests the signal <tt>s</tt> for <tt>n</tt>
--   cycles.
testFor :: Foldable f => Int -> f Bool -> Property

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.==.)</b> :: <a>Eq</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>==</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.==.) :: (Eq a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(./=.)</b> :: <a>Eq</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>/=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(./=.) :: (Eq a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>compare</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Ordering</a>
--   </pre>
--   
--   It is a version of <a>compare</a> that returns a <a>Signal</a> of
--   <a>Ordering</a>
compare1 :: (Ord a, Applicative f) => f a -> f a -> f Ordering

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&lt;.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&lt;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.<.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&lt;=.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&lt;=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.<=.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&gt;=.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&gt;=</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.>=.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>(.&gt;.)</b> :: <a>Ord</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of (<a>&gt;</a>) that returns a <a>Signal</a> of
--   <a>Bool</a>
(.>.) :: (Ord a, Applicative f) => f a -> f a -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>fromEnum1</b> :: <a>Enum</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a>
--   </pre>
--   
--   It is a version of <a>fromEnum</a> that returns a CLaSH.Signal.Signal'
--   of <a>Int</a>
fromEnum1 :: (Enum a, Functor f) => f a -> f Int

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>fromEnum1</b> :: <a>Real</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Rational</a>
--   </pre>
--   
--   | It is a version of <a>toRational</a> that returns a <a>Signal</a> of
--   <a>Rational</a>
toRational1 :: (Real a, Functor f) => f a -> f Rational

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>toInteger1</b> :: <a>Integral</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Integer</a>
--   </pre>
--   
--   It is a version of <a>toRational</a> that returns a <a>Signal</a> of
--   <a>Integer</a>
toInteger1 :: (Integral a, Functor f) => f a -> f Integer

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>testBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <a>Bool</a>
--   </pre>
--   
--   It is a version of <a>testBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument, and a result of <a>Signal</a> of
--   <a>Bool</a>
testBit1 :: (Bits a, Applicative f) => f a -> f Int -> f Bool

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>popCount1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a>
--   </pre>
--   
--   It is a version of <a>popCount</a> that returns a <a>Signal</a> of
--   <a>Int</a>
popCount1 :: (Bits a, Functor f) => f a -> f Int

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shift1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shift</a> that has a <a>Signal</a> of <a>Int</a>
--   as indexing argument
shift1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotate1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotate</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotate1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>setBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>setBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
setBit1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>clearBit1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>clearBit</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
clearBit1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shiftL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shiftL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
shiftL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>unsafeShiftL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>unsafeShiftL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
unsafeShiftL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>shiftR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>shiftR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
shiftR1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>unsafeShiftR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>unsafeShiftR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
unsafeShiftR1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotateL1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotateL</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotateL1 :: (Bits a, Applicative f) => f a -> f Int -> f a

-- | The above type is a generalisation for:
--   
--   <pre>
--   <b>rotateR1</b> :: <a>Bits</a> a =&gt; <a>Signal</a> a -&gt; <a>Signal</a> <a>Int</a> -&gt; <a>Signal</a> <tt>a</tt>
--   </pre>
--   
--   It is a version of <a>rotateR</a> that has a <a>Signal</a> of
--   <a>Int</a> as indexing argument
rotateR1 :: (Bits a, Applicative f) => f a -> f Int -> f a


module CLaSH.Signal.Delayed

-- | A synchronized signal with samples of type <tt>a</tt>, synchronized to
--   "system" clock (period 1000), that has accumulated <tt>delay</tt>
--   amount of samples delay along its path.
data DSignal (delay :: Nat) a

-- | Delay a <a>DSignal</a> for <tt>d</tt> periods.
--   
--   <pre>
--   delay3 :: <a>DSignal</a> n Int -&gt; <a>DSignal</a> (n + 3) Int
--   delay3 = <a>delay</a> (0 <tt>:&gt;</tt> 0 <tt>:&gt;</tt> 0 <tt>:&gt;</tt> <tt>Nil</tt>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 6 (delay3 (dfromList [1..]))
--   [0,0,0,1,2,3]
--   </pre>
delay :: KnownNat d => Vec d a -> DSignal n a -> DSignal (n + d) a

-- | Delay a <a>DSignal</a> for <tt>m</tt> periods, where <tt>m</tt> is
--   derived from the context.
--   
--   <pre>
--   delay2 :: <a>DSignal</a> n Int -&gt; <a>DSignal</a> (n + 2) Int
--   delay2 = <a>delayI</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 6 (delay2 (dfromList [1..]))
--   [0,0,1,2,3,4]
--   </pre>
delayI :: (Default a, KnownNat d) => DSignal n a -> DSignal (n + d) a

-- | Feed the delayed result of a function back to its input:
--   
--   <pre>
--   mac :: <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int
--   mac x y = <a>feedback</a> (mac' x y)
--     where
--       mac' :: <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int
--            -&gt; (<a>DSignal</a> 0 Int, <a>DSignal</a> 1 Int)
--       mac' a b acc = let acc' = a * b + acc
--                      in  (acc, <a>delay</a> (<a>singleton</a> 0) acc')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 6 (mac (dfromList [1..]) (dfromList [1..]))
--   [0,1,5,14,30,55]
--   </pre>
feedback :: (DSignal n a -> (DSignal n a, DSignal ((n + m) + 1) a)) -> DSignal n a

-- | <a>Signal</a>s are not delayed
--   
--   <pre>
--   sample s == dsample (fromSignal s)
--   </pre>
fromSignal :: Signal a -> DSignal 0 a

-- | Strip a <a>DSignal</a> from its delay information.
toSignal :: DSignal delay a -> Signal a

-- | Create a <a>DSignal</a> from a list
--   
--   Every element in the list will correspond to a value of the signal for
--   one clock cycle.
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 2 (dfromList [1,2,3,4,5])
--   [1,2]
--   </pre>
--   
--   <b>NB</b>: This function is not synthesisable
dfromList :: [a] -> DSignal 0 a

-- | <b>EXPERIMENTAL</b>
--   
--   <b>Unsafely</b> convert a <a>Signal</a> to <i>any</i> <a>DSignal</a>.
--   
--   <b>NB</b>: Should only be used to interface with functions specified
--   in terms of <a>Signal</a>.
unsafeFromSignal :: Signal a -> DSignal n a

-- | <b>EXPERIMENTAL</b>
--   
--   Access a <i>delayed</i> signal in the present.
--   
--   <pre>
--   mac :: <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int -&gt; <a>DSignal</a> 0 Int
--   mac x y = acc'
--     where
--       acc' = (x * y) + <a>antiDelay</a> d1 acc
--       acc  = <a>delay</a> (<a>singleton</a> 0) acc'
--   </pre>
antiDelay :: SNat d -> DSignal (n + d) a -> DSignal n a
instance CoArbitrary a => CoArbitrary (DSignal delay a)
instance Arbitrary a => Arbitrary (DSignal delay a)
instance Traversable (DSignal delay)
instance Foldable (DSignal delay)
instance FiniteBits a => FiniteBits (DSignal delay a)
instance Bits a => Bits (DSignal delay a)
instance Enum a => Enum (DSignal delay a)
instance Ord a => Ord (DSignal delay a)
instance Eq (DSignal delay a)
instance SaturatingNum a => SaturatingNum (DSignal delay a)
instance Integral a => Integral (DSignal delay a)
instance (Num a, Ord a) => Real (DSignal delay a)
instance Fractional a => Fractional (DSignal delay a)
instance Bounded a => Bounded (DSignal delay a)
instance Num a => Num (DSignal delay a)
instance Applicative (DSignal delay)
instance Functor (DSignal delay)
instance Lift a => Lift (DSignal delay a)
instance Default a => Default (DSignal delay a)
instance Show a => Show (DSignal delay a)
instance ExtendingNum a b => ExtendingNum (DSignal n a) (DSignal n b)


-- | Self-synchronising circuits based on data-flow principles.
module CLaSH.Prelude.DataFlow

-- | Dataflow circuit synchronised to the <a>SystemClock</a>.
type DataFlow iEn oEn i o = DataFlow' SystemClock iEn oEn i o

-- | Dataflow circuit with bidirectional synchronisation channels.
--   
--   In the <i>forward</i> direction we assert <i>validity</i> of the data.
--   In the <i>backward</i> direction we assert that the circuit is
--   <i>ready</i> to receive new data. A circuit adhering to the
--   <a>DataFlow</a> type should:
--   
--   <ul>
--   <li>Not consume data when validity is deasserted.</li>
--   <li>Only update its output when readiness is asserted.</li>
--   </ul>
--   
--   The <a>DataFlow'</a> type is defined as:
--   
--   <pre>
--   newtype DataFlow' clk iEn oEn i o
--     = DF
--     { df :: <a>Signal'</a> clk i     -- Incoming data
--          -&gt; <a>Signal'</a> clk iEn   -- Flagged with <i>valid</i> bits <tt>iEn</tt>.
--          -&gt; <a>Signal'</a> clk oEn   -- Incoming back-pressure, <i>ready</i> edge.
--          -&gt; ( <a>Signal'</a> clk o   -- Outgoing data.
--             , <a>Signal'</a> clk oEn -- Flagged with <i>valid</i> bits <tt>oEn</tt>.
--             , <a>Signal'</a> clk iEn -- Outgoing back-pressure, <i>ready</i> edge.
--             )
--     }
--   </pre>
--   
--   where:
--   
--   <ul>
--   <li><tt>clk</tt> is the clock to which the circuit is
--   synchronised.</li>
--   <li><tt>iEn</tt> is the type of the bidirectional incoming
--   synchronisation channel.</li>
--   <li><tt>oEn</tt> is the type of the bidirectional outgoing
--   synchronisation channel.</li>
--   <li><tt>i</tt> is the incoming data type.</li>
--   <li><tt>o</tt> is the outgoing data type.</li>
--   </ul>
--   
--   We define several composition operators for our <a>DataFlow</a>
--   circuits:
--   
--   <ul>
--   <li><a>seqDF</a> sequential composition.</li>
--   <li><a>parDF</a> parallel composition.</li>
--   <li><a>loopDF</a> add a feedback arc.</li>
--   <li><a>lockStep</a> proceed in lock-step.</li>
--   </ul>
--   
--   When you look at the types of the above operators it becomes clear why
--   we parametrise in the types of the synchronisation channels.
data DataFlow' clk iEn oEn i o

-- | Create an ordinary circuit from a <a>DataFlow</a> circuit
df :: DataFlow' clk iEn oEn i o -> Signal' clk i -> Signal' clk iEn -> Signal' clk oEn -> (Signal' clk o, Signal' clk oEn, Signal' clk iEn)

-- | Create a <a>DataFlow</a> circuit from a circuit description with the
--   appropriate type:
--   
--   <pre>
--   <a>Signal'</a> clk i        -- Incoming data.
--   -&gt; <a>Signal'</a> clk Bool  -- Flagged with a single <i>valid</i> bit.
--   -&gt; <a>Signal'</a> clk Bool  -- Incoming back-pressure, <i>ready</i> bit.
--   -&gt; ( <a>Signal'</a> clk o   -- Outgoing data.
--      , <a>Signal'</a> clk oEn -- Flagged with a single <i>valid</i> bit.
--      , <a>Signal'</a> clk iEn -- Outgoing back-pressure, <i>ready</i> bit.
--      )
--   </pre>
--   
--   A circuit adhering to the <a>DataFlow</a> type should:
--   
--   <ul>
--   <li>Not consume data when validity is deasserted.</li>
--   <li>Only update its output when readiness is asserted.</li>
--   </ul>
liftDF :: (Signal' clk i -> Signal' clk Bool -> Signal' clk Bool -> (Signal' clk o, Signal' clk Bool, Signal' clk Bool)) -> DataFlow' clk Bool Bool i o

-- | Create a <a>DataFlow</a> circuit from a Mealy machine description as
--   those of <a>CLaSH.Prelude.Mealy</a>
mealyDF :: (s -> i -> (s, o)) -> s -> DataFlow Bool Bool i o

-- | Create a <a>DataFlow</a> circuit from a Moore machine description as
--   those of <a>CLaSH.Prelude.Moore</a>
mooreDF :: (s -> i -> s) -> (s -> o) -> s -> DataFlow Bool Bool i o

-- | Identity circuit
--   
idDF :: DataFlow' clk en en a a

-- | Sequential composition of two <a>DataFlow</a> circuits.
--   
seqDF :: DataFlow' clk aEn bEn a b -> DataFlow' clk bEn cEn b c -> DataFlow' clk aEn cEn a c

-- | Apply the circuit to the first halve of the communication channels,
--   leave the second halve unchanged.
--   
firstDF :: (KnownSymbol nm, KnownNat rate) => DataFlow' (Clk nm rate) aEn bEn a b -> DataFlow' (Clk nm rate) (aEn, cEn) (bEn, cEn) (a, c) (b, c)

-- | Swap the two communication channels.
--   
swapDF :: DataFlow' (Clk nm rate) (aEn, bEn) (bEn, aEn) (a, b) (b, a)

-- | Apply the circuit to the second halve of the communication channels,
--   leave the first halve unchanged.
--   
secondDF :: (KnownSymbol nm, KnownNat rate) => DataFlow' (Clk nm rate) aEn bEn a b -> DataFlow' (Clk nm rate) (cEn, aEn) (cEn, bEn) (c, a) (c, b)

-- | Compose two <a>DataFlow</a> circuits in parallel.
--   
parDF :: (KnownSymbol nm, KnownNat rate) => DataFlow' (Clk nm rate) aEn bEn a b -> DataFlow' (Clk nm rate) cEn dEn c d -> DataFlow' (Clk nm rate) (aEn, cEn) (bEn, dEn) (a, c) (b, d)

-- | Feed back the second halve of the communication channel.
--   
--   Given:
--   
--   <pre>
--   f `<tt><a>seqDF</a></tt>` (<a>loopDF</a> h) `<tt><a>seqDF</a></tt>` g
--   </pre>
--   
--   The circuits <tt>f</tt>, <tt>h</tt>, and <tt>g</tt>, will operate in
--   <i>lock-step</i>. Which means that there it only progress when all
--   three circuits are producing <i>valid</i> data and all three circuits
--   are <i>ready</i> to receive new data. The <a>loopDF</a> function uses
--   the <a>lockStep</a> and <a>stepLock</a> functions to achieve the
--   <i>lock-step</i> operation.
--   
loopDF :: (KnownSymbol nm, KnownNat rate) => DataFlow' (Clk nm rate) Bool Bool (a, d) (b, d) -> DataFlow' (Clk nm rate) Bool Bool a b

-- | Reduce the synchronisation granularity to a single <a>Bool</a>ean
--   value.
--   
--   Given:
--   
--   <pre>
--   <b>f</b> :: <a>DataFlow</a> Bool Bool a b
--   <b>g</b> :: <a>DataFlow</a> Bool Bool c d
--   <b>h</b> :: <a>DataFlow</a> Bool Bool (b,d) (p,q)
--   </pre>
--   
--   We <i>cannot</i> simply write:
--   
--   <pre>
--   (f `<tt><a>parDF</a></tt>` g) `<tt><a>seqDF</a></tt>` h
--   </pre>
--   
--   because, <tt>f `parDF` g</tt>, has type, <tt><a>DataFlow</a>
--   (Bool,Bool) (Bool,Bool) (a,c) (b,d)</tt>, which does not match the
--   expected synchronisation granularity of <tt>h</tt>. We need a circuit
--   in between that has the type:
--   
--   <pre>
--   <a>DataFlow</a> (Bool,Bool) Bool (b,d) (b,d)
--   </pre>
--   
--   Simply <a>&amp;&amp;</a>-ing the <i>valid</i> signals in the forward
--   direction, and duplicating the <i>ready</i> signal in the backward
--   direction is however not enough. We also need to make sure that
--   <tt>f</tt> does not update its output when <tt>g</tt>'s output is
--   invalid and visa versa, as <tt>h</tt> can only consume its input when
--   both <tt>f</tt> and <tt>g</tt> are producing valid data. <tt>g</tt>'s
--   <i>ready</i> port is hence only asserted when <tt>h</tt> is ready and
--   <tt>f</tt> is producing <i>valid</i> data. And <tt>f</tt>'s ready port
--   is only asserted when <tt>h</tt> is ready and <tt>g</tt> is producing
--   valid data. <tt>f</tt> and <tt>g</tt> will hence be proceeding in
--   <i>lock-step</i>.
--   
--   The <a>lockStep</a> function ensures that all synchronisation signals
--   are properly connected:
--   
--   <pre>
--   (f `<tt><a>parDF</a></tt>` g) `<tt><a>seqDF</a></tt>` <a>lockStep</a> `<tt><a>seqDF</a></tt>` h
--   </pre>
--   
--   
--   Note that <a>lockStep</a> works for arbitrarily nested tuples. That
--   is:
--   
--   <pre>
--   p :: <a>DataFlow</a> Bool Bool ((b,d),d) z
--   
--   q :: <a>DataFlow</a> ((Bool,Bool),Bool) ((Bool,Bool),Bool) ((a,c),c) ((b,d),d)
--   q = f `<tt><a>parDF</a></tt>` g `<tt><a>parDF</a></tt>` g
--   
--   r = q `<tt><a>seqDF</a></tt>` <a>lockStep</a> `<tt><a>seqDF</a></tt>` p
--   </pre>
--   
--   Does the right thing.
lockStep :: (LockStep a b, KnownNat rate, KnownSymbol nm) => DataFlow' (Clk nm rate) a Bool b b

-- | Extend the synchronisation granularity from a single <a>Bool</a>ean
--   value.
--   
--   Given:
--   
--   <pre>
--   <b>f</b> :: <a>DataFlow</a> Bool Bool a b
--   <b>g</b> :: <a>DataFlow</a> Bool Bool c d
--   <b>h</b> :: <a>DataFlow</a> Bool Bool (p,q) (a,c)
--   </pre>
--   
--   We <i>cannot</i> simply write:
--   
--   <pre>
--   h `<tt><a>seqDF</a></tt>` (f `<tt><a>parDF</a></tt>` g)
--   </pre>
--   
--   because, <tt>f `parDF` g</tt>, has type, <tt><a>DataFlow</a>
--   (Bool,Bool) (Bool,Bool) (a,c) (b,d)</tt>, which does not match the
--   expected synchronisation granularity of <tt>h</tt>. We need a circuit
--   in between that has the type:
--   
--   <pre>
--   <a>DataFlow</a> Bool (Bool,Bool) (a,c) (a,c)
--   </pre>
--   
--   Simply <a>&amp;&amp;</a>-ing the <i>ready</i> signals in the backward
--   direction, and duplicating the <i>valid</i> signal in the forward
--   direction is however not enough. We need to make sure that <tt>f</tt>
--   does not consume values when <tt>g</tt> is not <i>ready</i> and visa
--   versa, because <tt>h</tt> cannot update the values of its output tuple
--   independently. <tt>f</tt>'s <i>valid</i> port is hence only asserted
--   when <tt>h</tt> is valid and <tt>g</tt> is ready to receive new
--   values. <tt>g</tt>'s <i>valid</i> port is only asserted when
--   <tt>h</tt> is valid and <tt>f</tt> is ready to receive new values.
--   <tt>f</tt> and <tt>g</tt> will hence be proceeding in
--   <i>lock-step</i>.
--   
--   The <a>stepLock</a> function ensures that all synchronisation signals
--   are properly connected:
--   
--   <pre>
--   h `<tt><a>seqDF</a></tt>` <a>stepLock</a> `<tt><a>seqDF</a></tt>` (f `<tt><a>parDF</a></tt>` g)
--   </pre>
--   
--   
--   Note that <a>stepLock</a> works for arbitrarily nested tuples. That
--   is:
--   
--   <pre>
--   p :: <a>DataFlow</a> Bool Bool z ((a,c),c)
--   
--   q :: <a>DataFlow</a> ((Bool,Bool),Bool) ((Bool,Bool),Bool) ((a,c),c) ((b,d),d)
--   q = f `<tt><a>parDF</a></tt>` g `<tt><a>parDF</a></tt>` g
--   
--   r = p `<tt><a>seqDF</a></tt>` <a>lockStep</a> `<tt><a>seqDF</a></tt>` q
--   </pre>
--   
--   Does the right thing.
stepLock :: (LockStep a b, KnownNat rate, KnownSymbol nm) => DataFlow' (Clk nm rate) Bool a b b
instance [safe] LockStep Bool c
instance [safe] (LockStep a x, LockStep b y) => LockStep (a, b) (x, y)


-- | BlockRAM primitives
--   
--   <h1>Using RAMs </h1>
--   
--   We will show a rather elaborate example on how you can, and why you
--   might want to use <a>blockRam</a>s. We will build a "small"
--   CPU+Memory+Program ROM where we will slowly evolve to using blockRams.
--   Note that the code is <i>not</i> meant as a de-facto standard on how
--   to do CPU design in CλaSH.
--   
--   We start with the definition of the Instructions, Register names and
--   machine codes:
--   
--   <pre>
--   {-# LANGUAGE RecordWildCards #-}
--   module CPU where
--   
--   import CLaSH.Prelude
--   import qualified Data.List as L
--   
--   type InstrAddr = Unsigned 8
--   type MemAddr   = Unsigned 5
--   type Value     = Signed 8
--   
--   data Instruction
--     = Compute Operator Reg Reg Reg
--     | Branch Reg Value
--     | Jump Value
--     | Load MemAddr Reg
--     | Store Reg MemAddr
--     | Nop
--     deriving (Eq,Show)
--   
--   data Reg
--     = Zero
--     | PC
--     | RegA
--     | RegB
--     | RegC
--     | RegD
--     | RegE
--     deriving (Eq,Show,Enum)
--   
--   data Operator = Add | Sub | Incr | Imm | CmpGt
--     deriving (Eq,Show)
--   
--   data MachCode
--     = MachCode
--     { inputX  :: Reg
--     , inputY  :: Reg
--     , result  :: Reg
--     , aluCode :: Operator
--     , ldReg   :: Reg
--     , rdAddr  :: MemAddr
--     , wrAddr  :: MemAddr
--     , wrEn    :: Bool
--     , jmpM    :: Maybe Value
--     }
--   
--   nullCode = MachCode { inputX = Zero, inputY = Zero, result = Zero, aluCode = Imm
--                       , ldReg = Zero, wrAddr = 0, rdAddr = 0, wrEn = False
--                       , jmpM = Nothing
--                       }
--   </pre>
--   
--   Next we define the CPU and its ALU:
--   
--   <pre>
--   cpu :: Vec 7 Value          -- ^ Register bank
--       -&gt; (Value,Instruction)  -- ^ (Memory output, Current instruction)
--       -&gt; ( Vec 7 Value
--          , (MemAddr,MemAddr,Bool,Value,InstrAddr)
--          )
--   cpu regbank (memOut,instr) = (regbank',(rdAddr,wrAddr,wrEn,aluOut,fromIntegral ipntr))
--     where
--       -- Current instruction pointer
--       ipntr = regbank <a>!!</a> PC
--   
--       -- Decoder
--       (MachCode {..}) = case instr of
--         Compute op rx ry res -&gt; nullCode {inputX=rx,inputY=ry,result=res,aluCode=op}
--         Branch cr a          -&gt; nullCode {inputX=cr,jmpM=Just a}
--         Jump a               -&gt; nullCode {aluCode=Incr,jmpM=Just a}
--         Load a r             -&gt; nullCode {ldReg=r,rdAddr=a}
--         Store r a            -&gt; nullCode {inputX=r,wrAddr=a,wrEn=True}
--         Nop                  -&gt; nullCode
--   
--       -- ALU
--       regX   = regbank <a>!!</a> inputX
--       regY   = regbank <a>!!</a> inputY
--       aluOut = alu aluCode regX regY
--   
--       -- next instruction
--       nextPC = case jmpM of
--                  Just a | aluOut /= 0 -&gt; ipntr + a
--                  _                    -&gt; ipntr + 1
--   
--       -- update registers
--       regbank' = <tt>replace</tt> Zero   0
--                $ <tt>replace</tt> PC     nextPC
--                $ <tt>replace</tt> result aluOut
--                $ <tt>replace</tt> ldReg  memOut
--                $ regbank
--   
--   alu Add   x y = x + y
--   alu Sub   x y = x - y
--   alu Incr  x _ = x + 1
--   alu Imm   x _ = x
--   alu CmpGt x y = if x &gt; y then 1 else 0
--   </pre>
--   
--   We initially create a memory out of simple registers:
--   
--   <pre>
--   dataMem :: Signal MemAddr -- ^ Read address
--           -&gt; Signal MemAddr -- ^ Write address
--           -&gt; Signal Bool    -- ^ Write enable
--           -&gt; Signal Value   -- ^ data in
--           -&gt; Signal Value   -- ^ data out
--   dataMem wr rd en din = <a>mealy</a> dataMemT (<a>replicate</a> d32 0) (bundle (wr,rd,en,din))
--     where
--       dataMemT mem (wr,rd,en,din) = (mem',dout)
--         where
--           dout = mem <a>!!</a> rd
--           mem' | en        = <tt>replace</tt> wr din mem
--                | otherwise = mem
--   </pre>
--   
--   And then connect everything:
--   
--   <pre>
--   system :: KnownNat n =&gt; Vec n Instruction -&gt; Signal Value
--   system instrs = memOut
--     where
--       memOut = dataMem wrAddr rdAddr wrEn aluOut
--       (rdAddr,wrAddr,wrEn,aluOut,ipntr) = <a>mealyB</a> cpu (<a>replicate</a> d7 0) (memOut,instr)
--       instr  = <a>asyncRom</a> instrs <a>&lt;$&gt;</a> ipntr
--   </pre>
--   
--   Create a simple program that calculates the GCD of 4 and 6:
--   
--   <pre>
--   -- Compute GCD of 4 and 6
--   prog = -- 0 := 4
--          Compute Incr Zero RegA RegA :&gt;
--          replicate d3 (Compute Incr RegA Zero RegA) ++
--          Store RegA 0 :&gt;
--          -- 1 := 6
--          Compute Incr Zero RegA RegA :&gt;
--          replicate d5 (Compute Incr RegA Zero RegA) ++
--          Store RegA 1 :&gt;
--          -- A := 4
--          Load 0 RegA :&gt;
--          -- B := 6
--          Load 1 RegB :&gt;
--          -- start
--          Compute CmpGt RegA RegB RegC :&gt;
--          Branch RegC 4 :&gt;
--          Compute CmpGt RegB RegA RegC :&gt;
--          Branch RegC 4 :&gt;
--          Jump 5 :&gt;
--          -- (a &gt; b)
--          Compute Sub RegA RegB RegA :&gt;
--          Jump (-6) :&gt;
--          -- (b &gt; a)
--          Compute Sub RegB RegA RegB :&gt;
--          Jump (-8) :&gt;
--          -- end
--          Store RegA 2 :&gt;
--          Load 2 RegC :&gt;
--          Nil
--   </pre>
--   
--   And test our system:
--   
--   <pre>
--   <b>&gt;&gt;&gt; L.take 31 $ sample $ system prog</b>
--   [0,0,0,0,0,4,4,4,4,4,4,4,4,4,6,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2]
--   </pre>
--   
--   to see that our system indeed calculates that the GCD of 6 and 4 is 2.
--   
--   <h3>Improvement 1: using <tt>asyncRam</tt></h3>
--   
--   As you can see, it's fairly straightforward to build a memory using
--   registers and read (<a>!!</a>) and write (<tt>replace</tt>) logic.
--   This might however not result in the most efficient hardware
--   structure, especially when building an ASIC.
--   
--   Instead it is preferable to use the <a>asyncRam</a> function which has
--   the potential to be translated to a more efficient structure:
--   
--   <pre>
--   system2 :: KnownNat n =&gt; Vec n Instruction -&gt; Signal Value
--   system2 instrs = memOut
--     where
--       memOut = <a>asyncRam</a> d32 wrAddr rdAddr wrEn aluOut
--       (rdAddr,wrAddr,wrEn,aluOut,ipntr) = <tt>mealyB</tt> cpu (<a>replicate</a> d7 0) (memOut,instr)
--       instr  = <a>asyncRom</a> instrs <a>&lt;$&gt;</a> ipntr
--   </pre>
--   
--   Again, we can simulate our system and see that it works. This time
--   however, we need to drop the first few output samples, because the
--   initial content of an <a>asyncRam</a> is <a>undefined</a>, and
--   consequently, the first few output samples are also <a>undefined</a>.
--   
--   <pre>
--   <b>&gt;&gt;&gt; L.take 26 $ L.drop 5 $ sample $ system2 prog</b>
--   [4,4,4,4,4,4,4,4,4,6,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2]
--   </pre>
--   
--   <h3>Improvement 2: using <tt>blockRam</tt></h3>
--   
--   Finally we get to using <a>blockRam</a>. On FPGAs, <a>asyncRam</a>
--   will be implemented in terms of LUTs, and therefore take up logic
--   resources. FPGAs also have large(r) memory structures called <i>Block
--   RAMs</i>, which are preferred, especially as the memories we need for
--   our application get bigger. The <a>blockRam</a> function will be
--   translated to such a <i>Block RAM</i>.
--   
--   One important aspect of Block RAMs have a <i>synchronous</i> read
--   port, meaning that, unlike the behaviour of <a>asyncRam</a>, given a
--   read address <tt>r</tt> at time <tt>t</tt>, the value <tt>v</tt> in
--   the RAM at address <tt>r</tt> is only available at time <tt>t+1</tt>.
--   
--   For us that means we need to change the design of our CPU. Right now,
--   upon a load instruction we generate a read address for the memory, and
--   the value at that read address is immediately available to be put in
--   the register bank. Because we will be using a BlockRAM, the value is
--   delayed until the next cycle. We hence need to also delay the register
--   address to which the memory address is loaded:
--   
--   <pre>
--   cpu2 :: (Vec 7 Value,Reg)    -- ^ (Register bank, Load reg addr)
--        -&gt; (Value,Instruction)  -- ^ (Memory output, Current instruction)
--        -&gt; ( (Vec 7 Value,Reg)
--           , (MemAddr,MemAddr,Bool,Value,InstrAddr)
--           )
--   cpu2 (regbank,ldRegD) (memOut,instr) = ((regbank',ldRegD'),(rdAddr,wrAddr,wrEn,aluOut,fromIntegral ipntr))
--     where
--       -- Current instruction pointer
--       ipntr = regbank <a>!!</a> PC
--   
--       -- Decoder
--       (MachCode {..}) = case instr of
--         Compute op rx ry res -&gt; nullCode {inputX=rx,inputY=ry,result=res,aluCode=op}
--         Branch cr a          -&gt; nullCode {inputX=cr,jmpM=Just a}
--         Jump a               -&gt; nullCode {aluCode=Incr,jmpM=Just a}
--         Load a r             -&gt; nullCode {ldReg=r,rdAddr=a}
--         Store r a            -&gt; nullCode {inputX=r,wrAddr=a,wrEn=True}
--         Nop                  -&gt; nullCode
--   
--       -- ALU
--       regX   = regbank <a>!!</a> inputX
--       regY   = regbank <a>!!</a> inputY
--       aluOut = alu aluCode regX regY
--   
--       -- next instruction
--       nextPC = case jmpM of
--                  Just a | aluOut /= 0 -&gt; ipntr + a
--                  _                    -&gt; ipntr + 1
--   
--       -- update registers
--       ldRegD'  = ldReg -- Delay the ldReg by 1 cycle
--       regbank' = <tt>replace</tt> Zero   0
--                $ <tt>replace</tt> PC     nextPC
--                $ <tt>replace</tt> result aluOut
--                $ <tt>replace</tt> ldRegD memOut
--                $ regbank
--   </pre>
--   
--   We can now finally instantiate our system with a <a>blockRam</a>:
--   
--   <pre>
--   system3 :: KnownNat n =&gt; Vec n Instruction -&gt; Signal Value
--   system3 instrs = memOut
--     where
--       memOut = <a>blockRam</a> (replicate d32 0) wrAddr rdAddr wrEn aluOut
--       (rdAddr,wrAddr,wrEn,aluOut,ipntr) = <tt>mealyB</tt> cpu2 ((<a>replicate</a> d7 0),Zero) (memOut,instr)
--       instr  = <a>asyncRom</a> instrs <a>&lt;$&gt;</a> ipntr
--   </pre>
--   
--   We are, however, not done. We will also need to update our program.
--   The reason being that values that we try to load in our registers
--   won't be loaded into the register until the next cycle. This is a
--   problem when the next instruction immediately depended on this memory
--   value. In our case, this was only the case when the loaded the value
--   <tt>6</tt>, which was stored at address <tt>1</tt>, into
--   <tt>RegB</tt>. Our updated program is thus:
--   
--   <pre>
--   prog2 = -- 0 := 4
--          Compute Incr Zero RegA RegA :&gt;
--          replicate d3 (Compute Incr RegA Zero RegA) ++
--          Store RegA 0 :&gt;
--          -- 1 := 6
--          Compute Incr Zero RegA RegA :&gt;
--          replicate d5 (Compute Incr RegA Zero RegA) ++
--          Store RegA 1 :&gt;
--          -- A := 4
--          Load 0 RegA :&gt;
--          -- B := 6
--          Load 1 RegB :&gt;
--          Nop :&gt; -- Extra NOP
--          -- start
--          Compute CmpGt RegA RegB RegC :&gt;
--          Branch RegC 4 :&gt;
--          Compute CmpGt RegB RegA RegC :&gt;
--          Branch RegC 4 :&gt;
--          Jump 5 :&gt;
--          -- (a &gt; b)
--          Compute Sub RegA RegB RegA :&gt;
--          Jump (-6) :&gt;
--          -- (b &gt; a)
--          Compute Sub RegB RegA RegB :&gt;
--          Jump (-8) :&gt;
--          -- end
--          Store RegA 2 :&gt;
--          Load 2 RegC :&gt;
--          Nil
--   </pre>
--   
--   When we simulate our system we see that it works. This time however,
--   we need to drop the first few sample, because the initial output of a
--   <a>blockRam</a> is <a>undefined</a>, and consequently, the first
--   output sample is also <a>undefined</a>.
--   
--   <pre>
--   <b>&gt;&gt;&gt; L.take 32 $ L.tail $ sample $ system3 prog2</b>
--   [4,4,4,4,4,4,4,4,4,6,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2]
--   </pre>
--   
--   This concludes the short introduction to using <a>blockRam</a>.
module CLaSH.Prelude.BlockRam

-- | Create a blockRAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram40 :: <a>Signal</a> (<a>Unsigned</a> 6) -&gt; Signal (<a>Unsigned</a> 6) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; Signal <a>Bit</a>
--   bram40 = <a>blockRam</a> (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam :: (KnownNat n, Enum addr) => Vec n a -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram32 :: <a>Signal</a> (<a>Unsigned</a> 5) -&gt; Signal (<a>Unsigned</a> 5) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; <a>Signal</a> <a>Bit</a>
--   bram32 = <a>blockRamPow2</a> (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram40 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 6) -&gt; <a>Signal'</a> ClkA (<a>Unsigned</a> 6)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; ClkA <a>Signal'</a> <a>Bit</a>
--   bram40 = <a>blockRam'</a> clkA100 (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk addr -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram32 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 5) -&gt; Signal' ClkA (<a>Unsigned</a> 5)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; Signal' ClkA <a>Bit</a>
--   bram32 = <a>blockRamPow2'</a> clkA100 (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk (Unsigned n) -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | blockRAM primitive
blockRam# :: KnownNat n => SClock clk -> Vec n a -> Signal' clk Int -> Signal' clk Int -> Signal' clk Bool -> Signal' clk a -> Signal' clk a


-- | <h1>Initialising a BlockRAM with a data file </h1>
--   
--   BlockRAM primitives that can be initialised with a data file. The BNF
--   grammar for this data file is simple:
--   
--   <pre>
--   FILE = LINE+
--   LINE = BIT+
--   BIT  = '0'
--        | '1'
--   </pre>
--   
--   Consecutive <tt>LINE</tt>s correspond to consecutive memory addresses
--   starting at <tt>0</tt>. For example, a data file <tt>memory.bin</tt>
--   containing the 9-bit unsigned number <tt>7</tt> to <tt>13</tt> looks
--   like:
--   
--   <pre>
--   000000111
--   000001000
--   000001001
--   000001010
--   000001011
--   000001100
--   000001101
--   </pre>
--   
--   We can instantiate a BlockRAM using the content of the above file like
--   so:
--   
--   <pre>
--   topEntity :: Signal (Unsigned 3) -&gt; Signal (Unsigned 9)
--   topEntity rd = <a>unpack</a> <a>&lt;$&gt;</a> <a>blockRamFile</a> d7 "memory.bin" 0 rd (signal False) 0
--   </pre>
--   
--   In the example above, we basically treat the BlockRAM as an
--   synchronous ROM. We can see that it works as expected:
--   
--   <pre>
--   <b>&gt;&gt;&gt; import qualified Data.List as L</b>
--   <b>&gt;&gt;&gt; L.tail $ sampleN 4 $ topEntity (fromList [3..5])</b>
--   [10,11,12]
--   </pre>
--   
--   However, we can also interpret the same data as a tuple of a 6-bit
--   unsigned number, and a 3-bit signed number:
--   
--   <pre>
--   topEntity2 :: Signal (Unsigned 3) -&gt; Signal (Unsigned 6,Signed 3)
--   topEntity2 rd = <a>unpack</a> <a>&lt;$&gt;</a> <a>blockRamFile</a> d7 "memory.bin" 0 rd (signal False) 0
--   </pre>
--   
--   And then we would see:
--   
--   <pre>
--   <b>&gt;&gt;&gt; import qualified Data.List as L</b>
--   <b>&gt;&gt;&gt; L.tail $ sampleN 4 $ topEntity2 (fromList [3..5])</b>
--   [(1,2),(1,3)(1,-4)]
--   </pre>
module CLaSH.Prelude.BlockRam.File

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFile :: (KnownNat m, Enum addr) => SNat n -> FilePath -> Signal addr -> Signal addr -> Signal Bool -> Signal (BitVector m) -> Signal (BitVector m)

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal (BitVector m) -> Signal (BitVector m)

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFile' :: (KnownNat m, Enum addr) => SClock clk -> SNat n -> FilePath -> Signal' clk addr -> Signal' clk addr -> Signal' clk Bool -> Signal' clk (BitVector m) -> Signal' clk (BitVector m)

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFilePow2' :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => SClock clk -> FilePath -> Signal' clk (Unsigned n) -> Signal' clk (Unsigned n) -> Signal' clk Bool -> Signal' clk (BitVector m) -> Signal' clk (BitVector m)

-- | blockRamFile primitive
blockRamFile# :: KnownNat m => SClock clk -> SNat n -> FilePath -> Signal' clk Int -> Signal' clk Int -> Signal' clk Bool -> Signal' clk (BitVector m) -> Signal' clk (BitVector m)

-- | <b>NB:</b> Not synthesisable
initMem :: KnownNat n => FilePath -> [BitVector n]


-- | ROMs
module CLaSH.Prelude.ROM

-- | An asynchronous/combinational ROM with space for <tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRom :: (KnownNat n, Enum addr) => Vec n a -> addr -> a

-- | An asynchronous/combinational ROM with space for 2^<tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRomPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Unsigned n -> a

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom :: (KnownNat n, KnownNat m) => Vec n a -> Signal (Unsigned m) -> Signal a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal a

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2' :: (KnownNat (2 ^ n), KnownNat n) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk a

-- | asyncROM primitive
asyncRom# :: KnownNat n => Vec n a -> Int -> a

-- | ROM primitive
rom# :: KnownNat n => SClock clk -> Vec n a -> Signal' clk Int -> Signal' clk a


-- | <h1>Initialising a ROM with a data file </h1>
--   
--   ROMs initialised with a data file. The BNF grammar for this data file
--   is simple:
--   
--   <pre>
--   FILE = LINE+
--   LINE = BIT+
--   BIT  = '0'
--        | '1'
--   </pre>
--   
--   Consecutive <tt>LINE</tt>s correspond to consecutive memory addresses
--   starting at <tt>0</tt>. For example, a data file <tt>memory.bin</tt>
--   containing the 9-bit unsigned number <tt>7</tt> to <tt>13</tt> looks
--   like:
--   
--   <pre>
--   000000111
--   000001000
--   000001001
--   000001010
--   000001011
--   000001100
--   000001101
--   </pre>
--   
--   We can instantiate a synchronous ROM using the content of the above
--   file like so:
--   
--   <pre>
--   topEntity :: Signal (Unsigned 3) -&gt; Signal (Unsigned 9)
--   topEntity rd = <a>unpack</a> <a>&lt;$&gt;</a> <a>romFile</a> d7 "memory.bin" rd
--   </pre>
--   
--   And see that it works as expected:
--   
--   <pre>
--   <b>&gt;&gt;&gt; import qualified Data.List as L</b>
--   <b>&gt;&gt;&gt; L.tail $ sampleN 4 $ topEntity (fromList [3..5])</b>
--   [10,11,12]
--   </pre>
--   
--   However, we can also interpret the same data as a tuple of a 6-bit
--   unsigned number, and a 3-bit signed number:
--   
--   <pre>
--   topEntity2 :: Signal (Unsigned 3) -&gt; Signal (Unsigned 6,Signed 3)
--   topEntity2 rd = <a>unpack</a> <a>&lt;$&gt;</a> <a>romFile</a> d7 "memory.bin" rd
--   </pre>
--   
--   And then we would see:
--   
--   <pre>
--   <b>&gt;&gt;&gt; import qualified Data.List as L</b>
--   <b>&gt;&gt;&gt; L.tail $ sampleN 4 $ topEntity2 (fromList [3..5])</b>
--   [(1,2),(1,3)(1,-4)]
--   </pre>
module CLaSH.Prelude.ROM.File

-- | An asynchronous/combinational ROM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
asyncRomFile :: (KnownNat m, Enum addr) => SNat n -> FilePath -> addr -> BitVector m

-- | An asynchronous/combinational ROM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
asyncRomFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Unsigned n -> BitVector m

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFile :: (KnownNat m, KnownNat k) => SNat n -> FilePath -> Signal (Unsigned k) -> Signal (BitVector m)

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Signal (Unsigned n) -> Signal (BitVector m)

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFile' :: (KnownNat m, Enum addr) => SClock clk -> SNat n -> FilePath -> Signal' clk addr -> Signal' clk (BitVector m)

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFilePow2' :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => SClock clk -> FilePath -> Signal' clk (Unsigned n) -> Signal' clk (BitVector m)

-- | asyncROMFile primitive
asyncRomFile# :: KnownNat m => SNat n -> FilePath -> Int -> BitVector m

-- | romFile primitive
romFile# :: KnownNat m => SClock clk -> SNat n -> FilePath -> Signal' clk Int -> Signal' clk (BitVector m)


module CLaSH.Prelude.Testbench

-- | Compares the first two <a>Signal</a>s for equality and logs a warning
--   when they are not equal. The second <a>Signal</a> is considered the
--   expected value. This function simply returns the third <a>Signal</a>
--   unaltered as its result. This function is used by
--   <a>outputVerifier</a>.
--   
--   <b>NB</b>: This function is <i>can</i> be used in synthesizable
--   designs.
assert :: (Eq a, Show a) => String -> Signal a -> Signal a -> Signal b -> Signal b

-- | To be used as a one of the functions to create the "magical"
--   <tt>testInput</tt> value, which the CλaSH compilers looks for to
--   create the stimulus generator for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   testInput :: <a>Signal</a> Int
--   testInput = <a>stimuliGenerator</a> $(<a>v</a> [(1::Int),3..21])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 13 testInput
--   [1,3,5,7,9,11,13,15,17,19,21,21,21]
--   </pre>
stimuliGenerator :: KnownNat l => Vec l a -> Signal a

-- | To be used as a functions to generate the "magical"
--   <tt>expectedOutput</tt> function, which the CλaSH compilers looks for
--   to create the signal verifier for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   expectedOutput :: <a>Signal</a> Int -&gt; <a>Signal</a> Bool
--   expectedOutput = <a>outputVerifier</a> $(<a>v</a> ([70,99,2,3,4,5,7,8,9,10]::[Int]))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; sampleN 12 (expectedOutput (fromList ([0..10] List.++ [10,10,10])))
--   [
--   cycle(system1000): 0, outputVerifier
--   expected value: 70, not equal to actual value: 0
--   False,
--   cycle(system1000): 1, outputVerifier
--   expected value: 99, not equal to actual value: 1
--   False,False,False,False,False,
--   cycle(system1000): 6, outputVerifier
--   expected value: 7, not equal to actual value: 6
--   False,
--   cycle(system1000): 7, outputVerifier
--   expected value: 8, not equal to actual value: 7
--   False,
--   cycle(system1000): 8, outputVerifier
--   expected value: 9, not equal to actual value: 8
--   False,
--   cycle(system1000): 9, outputVerifier
--   expected value: 10, not equal to actual value: 9
--   False,True,True]
--   </pre>
outputVerifier :: (KnownNat l, Eq a, Show a) => Vec l a -> Signal a -> Signal Bool

-- | Compares the first two <a>Signal'</a>s for equality and logs a warning
--   when they are not equal. The second <a>Signal'</a> is considered the
--   expected value. This function simply returns the third <a>Signal'</a>
--   unaltered as its result. This function is used by
--   <a>outputVerifier'</a>.
--   
--   <b>NB</b>: This function is <i>can</i> be used in synthesizable
--   designs.
assert' :: (Eq a, Show a) => SClock t -> String -> Signal' t a -> Signal' t a -> Signal' t b -> Signal' t b

-- | To be used as a one of the functions to create the "magical"
--   <tt>testInput</tt> value, which the CλaSH compilers looks for to
--   create the stimulus generator for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   testInput' :: <a>Signal'</a> clkA Int
--   testInput' = <a>stimuliGenerator'</a> clkA $(<a>v</a> [(1::Int),3..21])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 13 testInput'
--   [1,3,5,7,9,11,13,15,17,19,21,21,21]
--   </pre>
stimuliGenerator' :: KnownNat l => SClock clk -> Vec l a -> Signal' clk a

-- | To be used as a functions to generate the "magical"
--   <tt>expectedOutput</tt> function, which the CλaSH compilers looks for
--   to create the signal verifier for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   expectedOutput' :: <a>Signal'</a> ClkA Int -&gt; <a>Signal'</a> ClkA Bool
--   expectedOutput' = <a>outputVerifier'</a> clkA $(<a>v</a> ([70,99,2,3,4,5,7,8,9,10]::[Int]))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; sampleN 12 (expectedOutput' (fromList ([0..10] List.++ [10,10,10])))
--   [
--   cycle(A100): 0, outputVerifier
--   expected value: 70, not equal to actual value: 0
--   False,
--   cycle(A100): 1, outputVerifier
--   expected value: 99, not equal to actual value: 1
--   False,False,False,False,False,
--   cycle(A100): 6, outputVerifier
--   expected value: 7, not equal to actual value: 6
--   False,
--   cycle(A100): 7, outputVerifier
--   expected value: 8, not equal to actual value: 7
--   False,
--   cycle(A100): 8, outputVerifier
--   expected value: 9, not equal to actual value: 8
--   False,
--   cycle(A100): 9, outputVerifier
--   expected value: 10, not equal to actual value: 9
--   False,True,True]
--   </pre>
outputVerifier' :: (KnownNat l, Eq a, Show a) => SClock clk -> Vec l a -> Signal' clk a -> Signal' clk Bool


-- | Whereas the output of a Moore machine depends on the <i>previous
--   state</i>, the outputof a Mealy machine depends on <i>current
--   transition</i>.
--   
--   Mealy machines are strictly more expressive, but may impose stricter
--   timing requirements.
module CLaSH.Prelude.Mealy

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>mealy</a> mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy</a> mac 0 (<a>bundle</a> (a,x))
--       s2 = <a>mealy</a> mac 0 (<a>bundle</a> (b,y))
--   </pre>
mealy :: (s -> i -> (s, o)) -> s -> (Signal i -> Signal o)

-- | A version of <a>mealy</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool, Int) -&gt; (Int, (Int, Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>mealy</a> f 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>mealy</a> f 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mealyB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB</a> f 0 (a,b)
--       (i2,b2) = <a>mealyB</a> f 3 (i1,c)
--   </pre>
mealyB :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Infix version of <a>mealyB</a>
(<^>) :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>mealy'</a> clkA mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; <a>Signal'</a> clkA100 Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (a,x))
--       s2 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (b,y))
--   </pre>
mealy' :: SClock clk -> (s -> i -> (s, o)) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>mealy'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool,Int) -&gt; (Int,(Int,Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (mealy' clk f 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (mealy' clk f 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mealyB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB'</a> clk f 0 (a,b)
--       (i2,b2) = <a>mealyB'</a> clk f 3 (i1,c)
--   </pre>
mealyB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> (s, o)) -> s -> (Unbundled' clk i -> Unbundled' clk o)


-- | Whereas the output of a Mealy machine depends on <i>current
--   transition</i>, the output of a Moore machine depends on the
--   <i>previous state</i>.
--   
--   Moore machines are strictly less expressive, but may impose laxer
--   timing requirements.
module CLaSH.Prelude.Moore

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; Int        -- Updated state
--   mac s (x,y) = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>moore</a> mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore</a> mac id 0 (<a>bundle</a> (a,x))
--       s2 = <a>moore</a> mac id 0 (<a>bundle</a> (b,y))
--   </pre>
moore :: (s -> i -> s) -> (s -> o) -> s -> (Signal i -> Signal o)

-- | A version of <a>moore</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>moore</a> t o 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>moore</a> t o 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mooreB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB</a> t o 0 (a,b)
--       (i2,b2) = <a>mooreB</a> t o 3 (i1,c)
--   </pre>
mooreB :: (Bundle i, Bundle o) => (s -> i -> s) -> (s -> o) -> s -> (Unbundled i -> Unbundled o)

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- Updated state
--   mac s (x,y) = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>moore'</a> clkA mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; <a>Signal'</a> clkA Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (a,x))
--       s2 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (b,y))
--   </pre>
moore' :: SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>moore'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (moore' clk t o 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (moore' clk t o 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mooreB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB'</a> clk t o 0 (a,b)
--       (i2,b2) = <a>mooreB'</a> clk to 3 (i1,c)
--   </pre>
mooreB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Unbundled' clk i -> Unbundled' clk o)


-- | RAM primitives with a combinational read port.
module CLaSH.Prelude.RAM

-- | Create a RAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam :: (KnownNat n, Enum addr) => SNat n -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Create a RAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam' :: (KnownNat n, Enum addr) => SClock wclk -> SClock rclk -> SNat n -> Signal' wclk addr -> Signal' rclk addr -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock wclk -> SClock rclk -> Signal' wclk (Unsigned n) -> Signal' rclk (Unsigned n) -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | RAM primitive
asyncRam# :: SClock wclk -> SClock rclk -> SNat n -> Signal' wclk Int -> Signal' rclk Int -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a


-- | Synchronizer circuits for safe clock domain crossings
module CLaSH.Prelude.Synchronizer

-- | Synchroniser based on two sequentially connected flip-flops.
--   
--   <ul>
--   <li><b>NB</b>: This synchroniser can be used for
--   <b>bit</b>-synchronization.</li>
--   <li><b>NB</b>: Although this synchroniser does reduce metastability,
--   it does not guarantee the proper synchronisation of a whole
--   <b>word</b>. For example, given that the output is sampled twice as
--   fast as the input is running, and we have two samples in the input
--   stream that look like:<pre>[0111,1000]</pre>But the circuit driving
--   the input stream has a longer propagation delay on <b>msb</b> compared
--   to the <b>lsb</b>s. What can happen is an output stream that looks
--   like this:<pre>[0111,0111,0000,1000]</pre>Where the level-change of
--   the <b>msb</b> was not captured, but the level change of the
--   <b>lsb</b>s were.If you want to have <i>safe</i>
--   <b>word</b>-synchronisation use <a>asyncFIFOSynchronizer</a>.</li>
--   </ul>
dualFlipFlopSynchronizer :: SClock clk1 -> SClock clk2 -> a -> Signal' clk1 a -> Signal' clk2 a

-- | Synchroniser implemented as a FIFO around an asynchronous RAM. Based
--   on the design described in <a>CLaSH.Tutorial#multiclock</a>, which is
--   itself based on the design described in
--   <a>http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf</a>.
--   
--   <b>NB</b>: This synchroniser can be used for
--   <b>word</b>-synchronization.
asyncFIFOSynchronizer :: _ => SNat addrSize -> SClock wclk -> SClock rclk -> Signal' wclk a -> Signal' wclk Bool -> Signal' rclk Bool -> (Signal' rclk a, Signal' rclk Bool, Signal' wclk Bool)


-- | <b>This is the <a>Safe</a> API only of
--   <a>CLaSH.Prelude.Explicit</a></b>
--   
--   This module defines the explicitly clocked counterparts of the
--   functions defined in <a>CLaSH.Prelude</a>.
--   
--   This module uses the explicitly clocked <a>Signal'</a> synchronous
--   signals, as opposed to the implicitly clocked <tt>Signal</tt> used in
--   <a>CLaSH.Prelude</a>. Take a look at <a>CLaSH.Signal.Explicit</a> to
--   see how you can make multi-clock designs using explicitly clocked
--   signals.
module CLaSH.Prelude.Explicit.Safe

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>mealy'</a> clkA mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; <a>Signal'</a> clkA100 Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (a,x))
--       s2 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (b,y))
--   </pre>
mealy' :: SClock clk -> (s -> i -> (s, o)) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>mealy'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool,Int) -&gt; (Int,(Int,Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (mealy' clk f 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (mealy' clk f 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mealyB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB'</a> clk f 0 (a,b)
--       (i2,b2) = <a>mealyB'</a> clk f 3 (i1,c)
--   </pre>
mealyB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> (s, o)) -> s -> (Unbundled' clk i -> Unbundled' clk o)

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- Updated state
--   mac s (x,y) = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>moore'</a> clkA mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; <a>Signal'</a> clkA Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (a,x))
--       s2 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (b,y))
--   </pre>
moore' :: SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>moore'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (moore' clk t o 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (moore' clk t o 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mooreB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB'</a> clk t o 0 (a,b)
--       (i2,b2) = <a>mooreB'</a> clk to 3 (i1,c)
--   </pre>
mooreB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Unbundled' clk i -> Unbundled' clk o)

-- | Create a <tt>register</tt> function for product-type like signals
--   (e.g. <tt>(<tt>Signal</tt> a, <tt>Signal</tt> b)</tt>)
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   rP :: (<a>Signal'</a> ClkA Int, <a>Signal'</a> ClkA Int) -&gt; (<a>Signal'</a> ClkA Int, <a>Signal'</a> ClkA Int)
--   rP = <a>registerB'</a> clkA (8,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB' clkA clkA rP [(1,1),(2,2),(3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
registerB' :: Bundle a => SClock clk -> a -> Unbundled' clk a -> Unbundled' clk a

-- | Synchroniser based on two sequentially connected flip-flops.
--   
--   <ul>
--   <li><b>NB</b>: This synchroniser can be used for
--   <b>bit</b>-synchronization.</li>
--   <li><b>NB</b>: Although this synchroniser does reduce metastability,
--   it does not guarantee the proper synchronisation of a whole
--   <b>word</b>. For example, given that the output is sampled twice as
--   fast as the input is running, and we have two samples in the input
--   stream that look like:<pre>[0111,1000]</pre>But the circuit driving
--   the input stream has a longer propagation delay on <b>msb</b> compared
--   to the <b>lsb</b>s. What can happen is an output stream that looks
--   like this:<pre>[0111,0111,0000,1000]</pre>Where the level-change of
--   the <b>msb</b> was not captured, but the level change of the
--   <b>lsb</b>s were.If you want to have <i>safe</i>
--   <b>word</b>-synchronisation use <a>asyncFIFOSynchronizer</a>.</li>
--   </ul>
dualFlipFlopSynchronizer :: SClock clk1 -> SClock clk2 -> a -> Signal' clk1 a -> Signal' clk2 a

-- | Synchroniser implemented as a FIFO around an asynchronous RAM. Based
--   on the design described in <a>CLaSH.Tutorial#multiclock</a>, which is
--   itself based on the design described in
--   <a>http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf</a>.
--   
--   <b>NB</b>: This synchroniser can be used for
--   <b>word</b>-synchronization.
asyncFIFOSynchronizer :: _ => SNat addrSize -> SClock wclk -> SClock rclk -> Signal' wclk a -> Signal' wclk Bool -> Signal' rclk Bool -> (Signal' rclk a, Signal' rclk Bool, Signal' wclk Bool)

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2' :: (KnownNat (2 ^ n), KnownNat n) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk a

-- | Create a RAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam' :: (KnownNat n, Enum addr) => SClock wclk -> SClock rclk -> SNat n -> Signal' wclk addr -> Signal' rclk addr -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock wclk -> SClock rclk -> Signal' wclk (Unsigned n) -> Signal' rclk (Unsigned n) -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram40 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 6) -&gt; <a>Signal'</a> ClkA (<a>Unsigned</a> 6)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; ClkA <a>Signal'</a> <a>Bit</a>
--   bram40 = <a>blockRam'</a> clkA100 (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk addr -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram32 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 5) -&gt; Signal' ClkA (<a>Unsigned</a> 5)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; Signal' ClkA <a>Bit</a>
--   bram32 = <a>blockRamPow2'</a> clkA100 (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk (Unsigned n) -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Give a pulse when the <a>Signal'</a> goes from <a>minBound</a> to
--   <a>maxBound</a>
isRising' :: (Bounded a, Eq a) => SClock clk -> a -> Signal' clk a -> Signal' clk Bool

-- | Give a pulse when the <a>Signal'</a> goes from <a>maxBound</a> to
--   <a>minBound</a>
isFalling' :: (Bounded a, Eq a) => SClock clk -> a -> Signal' clk a -> Signal' clk Bool


-- | This module defines the explicitly clocked counterparts of the
--   functions defined in <a>CLaSH.Prelude</a>.
--   
--   This module uses the explicitly clocked <a>Signal'</a> synchronous
--   signals, as opposed to the implicitly clocked <tt>Signal</tt> used in
--   <a>CLaSH.Prelude</a>. Take a look at <a>CLaSH.Signal.Explicit</a> to
--   see how you can make multi-clock designs using explicitly clocked
--   signals.
module CLaSH.Prelude.Explicit

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>mealy'</a> clkA mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; (<a>Signal'</a> clkA100 Int, <a>Signal'</a> clkA100 Int)
--           -&gt; <a>Signal'</a> clkA100 Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (a,x))
--       s2 = <a>mealy'</a> clkA100 mac 0 (<a>bundle'</a> clkA100 (b,y))
--   </pre>
mealy' :: SClock clk -> (s -> i -> (s, o)) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>mealy'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool,Int) -&gt; (Int,(Int,Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (mealy' clk f 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (mealy' clk f 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mealyB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB'</a> clk f 0 (a,b)
--       (i2,b2) = <a>mealyB'</a> clk f 3 (i1,c)
--   </pre>
mealyB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> (s, o)) -> s -> (Unbundled' clk i -> Unbundled' clk o)

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- Updated state
--   mac s (x,y) = x * y + s
--   
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   topEntity :: <a>Signal'</a> ClkA (Int, Int) -&gt; <a>Signal'</a> ClkA Int
--   topEntity = <a>moore'</a> clkA mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; (<a>Signal'</a> clkA Int, <a>Signal'</a> clkA Int)
--           -&gt; <a>Signal'</a> clkA Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (a,x))
--       s2 = <a>moore'</a> clkA mac id 0 (<a>bundle'</a> clkA (b,y))
--   </pre>
moore' :: SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Signal' clk i -> Signal' clk o)

-- | A version of <a>moore'</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore'</a>, we have to write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle'</a> clk (moore' clk t o 0 (<a>bundle'</a> clk (a,b)))
--       (i2,b2) = <a>unbundle'</a> clk (moore' clk t o 3 (<a>bundle'</a> clk (i1,c)))
--   </pre>
--   
--   Using <a>mooreB'</a> however we can write:
--   
--   <pre>
--   g clk a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB'</a> clk t o 0 (a,b)
--       (i2,b2) = <a>mooreB'</a> clk to 3 (i1,c)
--   </pre>
mooreB' :: (Bundle i, Bundle o) => SClock clk -> (s -> i -> s) -> (s -> o) -> s -> (Unbundled' clk i -> Unbundled' clk o)

-- | Create a <tt>register</tt> function for product-type like signals
--   (e.g. <tt>(<tt>Signal</tt> a, <tt>Signal</tt> b)</tt>)
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   rP :: (<a>Signal'</a> ClkA Int, <a>Signal'</a> ClkA Int) -&gt; (<a>Signal'</a> ClkA Int, <a>Signal'</a> ClkA Int)
--   rP = <a>registerB'</a> clkA (8,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB' clkA clkA rP [(1,1),(2,2),(3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
registerB' :: Bundle a => SClock clk -> a -> Unbundled' clk a -> Unbundled' clk a

-- | Synchroniser based on two sequentially connected flip-flops.
--   
--   <ul>
--   <li><b>NB</b>: This synchroniser can be used for
--   <b>bit</b>-synchronization.</li>
--   <li><b>NB</b>: Although this synchroniser does reduce metastability,
--   it does not guarantee the proper synchronisation of a whole
--   <b>word</b>. For example, given that the output is sampled twice as
--   fast as the input is running, and we have two samples in the input
--   stream that look like:<pre>[0111,1000]</pre>But the circuit driving
--   the input stream has a longer propagation delay on <b>msb</b> compared
--   to the <b>lsb</b>s. What can happen is an output stream that looks
--   like this:<pre>[0111,0111,0000,1000]</pre>Where the level-change of
--   the <b>msb</b> was not captured, but the level change of the
--   <b>lsb</b>s were.If you want to have <i>safe</i>
--   <b>word</b>-synchronisation use <a>asyncFIFOSynchronizer</a>.</li>
--   </ul>
dualFlipFlopSynchronizer :: SClock clk1 -> SClock clk2 -> a -> Signal' clk1 a -> Signal' clk2 a

-- | Synchroniser implemented as a FIFO around an asynchronous RAM. Based
--   on the design described in <a>CLaSH.Tutorial#multiclock</a>, which is
--   itself based on the design described in
--   <a>http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf</a>.
--   
--   <b>NB</b>: This synchroniser can be used for
--   <b>word</b>-synchronization.
asyncFIFOSynchronizer :: _ => SNat addrSize -> SClock wclk -> SClock rclk -> Signal' wclk a -> Signal' wclk Bool -> Signal' rclk Bool -> (Signal' rclk a, Signal' rclk Bool, Signal' wclk Bool)

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2' :: (KnownNat (2 ^ n), KnownNat n) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk a

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFile' :: (KnownNat m, Enum addr) => SClock clk -> SNat n -> FilePath -> Signal' clk addr -> Signal' clk (BitVector m)

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFilePow2' :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => SClock clk -> FilePath -> Signal' clk (Unsigned n) -> Signal' clk (BitVector m)

-- | Create a RAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam' :: (KnownNat n, Enum addr) => SClock wclk -> SClock rclk -> SNat n -> Signal' wclk addr -> Signal' rclk addr -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock wclk -> SClock rclk -> Signal' wclk (Unsigned n) -> Signal' rclk (Unsigned n) -> Signal' wclk Bool -> Signal' wclk a -> Signal' rclk a

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram40 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 6) -&gt; <a>Signal'</a> ClkA (<a>Unsigned</a> 6)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; ClkA <a>Signal'</a> <a>Bit</a>
--   bram40 = <a>blockRam'</a> clkA100 (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam' :: (KnownNat n, Enum addr) => SClock clk -> Vec n a -> Signal' clk addr -> Signal' clk addr -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   type ClkA = Clk "A" 100
--   
--   clkA100 :: SClock ClkA
--   clkA100 = <a>sclock</a>
--   
--   bram32 :: <a>Signal'</a> ClkA (<a>Unsigned</a> 5) -&gt; Signal' ClkA (<a>Unsigned</a> 5)
--          -&gt; <a>Signal'</a> ClkA Bool -&gt; <a>Signal'</a> ClkA <a>Bit</a> -&gt; Signal' ClkA <a>Bit</a>
--   bram32 = <a>blockRamPow2'</a> clkA100 (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2' :: (KnownNat n, KnownNat (2 ^ n)) => SClock clk -> Vec (2 ^ n) a -> Signal' clk (Unsigned n) -> Signal' clk (Unsigned n) -> Signal' clk Bool -> Signal' clk a -> Signal' clk a

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFile' :: (KnownNat m, Enum addr) => SClock clk -> SNat n -> FilePath -> Signal' clk addr -> Signal' clk addr -> Signal' clk Bool -> Signal' clk (BitVector m) -> Signal' clk (BitVector m)

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFilePow2' :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => SClock clk -> FilePath -> Signal' clk (Unsigned n) -> Signal' clk (Unsigned n) -> Signal' clk Bool -> Signal' clk (BitVector m) -> Signal' clk (BitVector m)

-- | Give a window over a <a>Signal'</a>
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   window4 :: <a>Signal'</a> ClkA Int -&gt; <a>Vec</a> 4 (<a>Signal'</a> ClkA Int)
--   window4 = <a>window'</a> clkA
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB' clkA clkA window4 [1::Int,2,3,4,5] :: [Vec 4 Int]
--   [&lt;1,0,0,0&gt;,&lt;2,1,0,0&gt;,&lt;3,2,1,0&gt;,&lt;4,3,2,1&gt;,&lt;5,4,3,2&gt;...
--   </pre>
window' :: (KnownNat n, Default a) => SClock clk -> Signal' clk a -> Vec (n + 1) (Signal' clk a)

-- | Give a delayed window over a <a>Signal'</a>
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   windowD3 :: <a>Signal'</a> ClkA Int -&gt; <a>Vec</a> 3 (<a>Signal'</a> ClkA Int)
--   windowD3 = <a>windowD'</a> clkA
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB' clkA clkA windowD3 [1::Int,2,3,4] :: [Vec 3 Int]
--   [&lt;0,0,0&gt;,&lt;1,0,0&gt;,&lt;2,1,0&gt;,&lt;3,2,1&gt;,&lt;4,3,2&gt;...
--   </pre>
windowD' :: (KnownNat (n + 1), Default a) => SClock clk -> Signal' clk a -> Vec (n + 1) (Signal' clk a)

-- | Give a pulse when the <a>Signal'</a> goes from <a>minBound</a> to
--   <a>maxBound</a>
isRising' :: (Bounded a, Eq a) => SClock clk -> a -> Signal' clk a -> Signal' clk Bool

-- | Give a pulse when the <a>Signal'</a> goes from <a>maxBound</a> to
--   <a>minBound</a>
isFalling' :: (Bounded a, Eq a) => SClock clk -> a -> Signal' clk a -> Signal' clk Bool

-- | Compares the first two <a>Signal'</a>s for equality and logs a warning
--   when they are not equal. The second <a>Signal'</a> is considered the
--   expected value. This function simply returns the third <a>Signal'</a>
--   unaltered as its result. This function is used by
--   <a>outputVerifier'</a>.
--   
--   <b>NB</b>: This function is <i>can</i> be used in synthesizable
--   designs.
assert' :: (Eq a, Show a) => SClock t -> String -> Signal' t a -> Signal' t a -> Signal' t b -> Signal' t b

-- | To be used as a one of the functions to create the "magical"
--   <tt>testInput</tt> value, which the CλaSH compilers looks for to
--   create the stimulus generator for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   testInput' :: <a>Signal'</a> clkA Int
--   testInput' = <a>stimuliGenerator'</a> clkA $(<a>v</a> [(1::Int),3..21])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 13 testInput'
--   [1,3,5,7,9,11,13,15,17,19,21,21,21]
--   </pre>
stimuliGenerator' :: KnownNat l => SClock clk -> Vec l a -> Signal' clk a

-- | To be used as a functions to generate the "magical"
--   <tt>expectedOutput</tt> function, which the CλaSH compilers looks for
--   to create the signal verifier for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   type ClkA = <a>Clk</a> "A" 100
--   
--   clkA :: <a>SClock</a> ClkA
--   clkA = <a>sclock</a>
--   
--   expectedOutput' :: <a>Signal'</a> ClkA Int -&gt; <a>Signal'</a> ClkA Bool
--   expectedOutput' = <a>outputVerifier'</a> clkA $(<a>v</a> ([70,99,2,3,4,5,7,8,9,10]::[Int]))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; sampleN 12 (expectedOutput' (fromList ([0..10] List.++ [10,10,10])))
--   [
--   cycle(A100): 0, outputVerifier
--   expected value: 70, not equal to actual value: 0
--   False,
--   cycle(A100): 1, outputVerifier
--   expected value: 99, not equal to actual value: 1
--   False,False,False,False,False,
--   cycle(A100): 6, outputVerifier
--   expected value: 7, not equal to actual value: 6
--   False,
--   cycle(A100): 7, outputVerifier
--   expected value: 8, not equal to actual value: 7
--   False,
--   cycle(A100): 8, outputVerifier
--   expected value: 9, not equal to actual value: 8
--   False,
--   cycle(A100): 9, outputVerifier
--   expected value: 10, not equal to actual value: 9
--   False,True,True]
--   </pre>
outputVerifier' :: (KnownNat l, Eq a, Show a) => SClock clk -> Vec l a -> Signal' clk a -> Signal' clk Bool


-- | The <a>TopEntity</a> annotations described in this module make it
--   easier to put your design on an FPGA.
--   
--   We can exert some control how the top level function is created by the
--   CλaSH compiler by annotating the <tt>topEntity</tt> function with a
--   <a>TopEntity</a> annotation. You apply these annotations using the
--   <tt>ANN</tt> pragma like so:
--   
--   <pre>
--   {-# ANN topEntity (TopEntity {t_name = ..., ...  }) #-}
--   topEntity x = ...
--   </pre>
--   
--   For example, given the following specification:
--   
--   <pre>
--   topEntity :: Signal Bit -&gt; Signal (BitVector 8)
--   topEntity key1 = leds
--     where
--       key1R = isRising 1 key1
--       leds  = mealy blinkerT (1,False,0) key1R
--   
--   blinkerT (leds,mode,cntr) key1R = ((leds',mode',cntr'),leds)
--     where
--       -- clock frequency = 50e6   (50 MHz)
--       -- led update rate = 333e-3 (every 333ms)
--       cnt_max = 16650000 -- 50e6 * 333e-3
--   
--       cntr' | cntr == cnt_max = 0
--             | otherwise       = cntr + 1
--   
--       mode' | key1R     = not mode
--             | otherwise = mode
--   
--       leds' | cntr == 0 = if mode then complement leds
--                                   else rotateL leds 1
--             | otherwise = leds
--   </pre>
--   
--   The CλaSH compiler will normally generate the following
--   <tt>topEntity.vhdl</tt> file:
--   
--   <pre>
--   -- Automatically generated VHDL
--   library IEEE;
--   use IEEE.STD_LOGIC_1164.ALL;
--   use IEEE.NUMERIC_STD.ALL;
--   use IEEE.MATH_REAL.ALL;
--   use work.all;
--   use work.types.all;
--   
--   entity topEntity is
--     port(input_0         : in std_logic_vector(0 downto 0);
--          -- clock
--          system1000      : in std_logic;
--          -- asynchronous reset: active low
--          system1000_rstn : in std_logic;
--          output_0        : out std_logic_vector(7 downto 0));
--   end;
--   
--   architecture structural of topEntity is
--   begin
--     topEntity_0_inst : entity topEntity_0
--       port map
--         (key1_i1         =&gt; input_0
--         ,system1000      =&gt; system1000
--         ,system1000_rstn =&gt; system1000_rstn
--         ,topLet_o        =&gt; output_0);
--   end;
--   </pre>
--   
--   However, if we add the following <a>TopEntity</a> annotation in the
--   file:
--   
--   <pre>
--   {-# ANN topEntity
--     (<a>defTop</a>
--       { t_name     = "blinker"
--       , t_inputs   = ["KEY1"]
--       , t_outputs  = ["LED"]
--       , t_extraIn  = [ ("CLOCK_50", 1)
--                      , ("KEY0"    , 1)
--                      ]
--       , t_clocks   = [ <a>altpll</a> "altpll50" "CLOCK_50(0)" "not KEY0(0)" ]
--       }) #-}
--   </pre>
--   
--   The CλaSH compiler will generate the following <tt>blinker.vhdl</tt>
--   file instead:
--   
--   <pre>
--   -- Automatically generated VHDL
--   library IEEE;
--   use IEEE.STD_LOGIC_1164.ALL;
--   use IEEE.NUMERIC_STD.ALL;
--   use IEEE.MATH_REAL.ALL;
--   use work.all;
--   use work.types.all;
--   
--   entity blinker is
--     port(KEY1     : in std_logic_vector(0 downto 0);
--          CLOCK_50 : in std_logic_vector(0 downto 0);
--          KEY0     : in std_logic_vector(0 downto 0);
--          LED      : out std_logic_vector(7 downto 0));
--   end;
--   
--   architecture structural of blinker is
--     signal system1000      : std_logic;
--     signal system1000_rstn : std_logic;
--     signal altpll50_locked : std_logic;
--   begin
--     altpll50_inst : entity altpll50
--       port map
--         (inclk0 =&gt; CLOCK_50(0)
--         ,c0     =&gt; system1000
--         ,areset =&gt; not KEY0(0)
--         ,locked =&gt; altpll50_locked);
--   
--     -- reset system1000_rstn is asynchronously asserted, but synchronously de-asserted
--     resetSync_n_0 : block
--       signal n_1 : std_logic;
--       signal n_2 : std_logic;
--     begin
--       process(system1000,altpll50_locked)
--       begin
--         if altpll50_locked = '0' then
--           n_1 &lt;= '0';
--           n_2 &lt;= '0';
--         elsif rising_edge(system1000) then
--           n_1 &lt;= '1';
--           n_2 &lt;= n_1;
--         end if;
--       end process;
--   
--       system1000_rstn &lt;= n_2;
--     end block;
--   
--     topEntity_0_inst : entity topEntity_0
--       port map
--         (key1_i1         =&gt; KEY1
--         ,system1000      =&gt; system1000
--         ,system1000_rstn =&gt; system1000_rstn
--         ,topLet_o        =&gt; LED);
--   end;
--   </pre>
--   
--   Where we now have:
--   
--   <ul>
--   <li>A top-level component that is called <tt>blinker</tt>.</li>
--   <li>Inputs and outputs that have a <i>user</i>-chosen name:
--   <tt>KEY1</tt>, <tt>LED</tt>, etc.</li>
--   <li>An instantiated <a>PLL</a> component providing a stable clock
--   signal from the free-running clock pin <tt>CLOCK_50</tt>.</li>
--   <li>A reset that is <i>asynchronously</i> asserted by the
--   <tt>lock</tt> signal originating from the PLL, meaning that your
--   design is kept in reset until the PLL is providing a stable clock. The
--   reset is additionally <i>synchronously</i> de-asserted to prevent
--   <a>metastability</a> of your design due to unlucky timing of the
--   de-assertion of the reset.</li>
--   </ul>
--   
--   See the documentation of <a>TopEntity</a> for the meaning of all its
--   fields.
module CLaSH.Annotations.TopEntity

-- | TopEntity annotation
data TopEntity
[TopEntity] :: String -> [String] -> [String] -> [(String, Int)] -> [(String, Int)] -> [ClockSource] -> TopEntity

-- | The name the top-level component should have, put in a correspondingly
--   named file.
[t_name] :: TopEntity -> String

-- | List of names that are assigned in-order to the inputs of the
--   component.
[t_inputs] :: TopEntity -> [String]

-- | List of names that are assigned in-order to the outputs of the
--   component.
[t_outputs] :: TopEntity -> [String]

-- | Extra input ports, where every tuple holds the name of the input port
--   and the number of bits are used for that input port.
--   
--   So given a bit-width <tt>n</tt>, the port has type:
--   
--   <ul>
--   <li><b>VHDL</b>: <tt>std_logic_vector (n-1 downto 0)</tt></li>
--   <li><b>Verilog</b>: <tt>[n-1:0]</tt></li>
--   <li><b>SystemVerilog</b>: <tt>logic [n-1:0]</tt></li>
--   </ul>
[t_extraIn] :: TopEntity -> [(String, Int)]

-- | Extra output ports, where every tuple holds the name of the input port
--   and the number of bits are used for that input port.
--   
--   So given a bit-width <tt>n</tt>, the port has type:
--   
--   <ul>
--   <li><b>VHDL</b>: <tt>std_logic_vector (n-1 downto 0)</tt></li>
--   <li><b>Verilog</b>: <tt>[n-1:0]</tt></li>
--   <li><b>SystemVerilog</b>: <tt>logic [n-1:0]</tt></li>
--   </ul>
[t_extraOut] :: TopEntity -> [(String, Int)]

-- | List of clock sources
[t_clocks] :: TopEntity -> [ClockSource]

-- | A clock source
data ClockSource
[ClockSource] :: String -> Maybe (String, String) -> [(String, String)] -> Maybe (String, String) -> String -> Bool -> ClockSource

-- | Component name
[c_name] :: ClockSource -> String

-- | optional: <tt>(Input port, clock pin/expression)</tt>
[c_inp] :: ClockSource -> Maybe (String, String)

-- | List of <tt>(Output port, clock)</tt>
--   
--   The best way to create the <a>String</a> representing the name of the
--   clock is to <a>show</a> the corresponding singleton clock
--   (<a>sclock</a>).
--   
--   So given that you your design is synchronised to the
--   <a>SystemClock</a> and some another clock <tt>ClkA</tt>
--   
--   <pre>
--   type ClkA = 'Clk "clkA" 2000
--   </pre>
--   
--   the best way to connect output clock ports is by doing:
--   
--   <pre>
--   ClockSource { ..
--               , c_outp = [("c0", show (sclock :: SClock SystemClock))
--                          ,("c1", show (sclock :: SClock ClkA))
--                          ]
--               , ..
--               }
--   </pre>
[c_outp] :: ClockSource -> [(String, String)]

-- | optional: <tt>(Reset port, reset pin/expression)</tt>
[c_reset] :: ClockSource -> Maybe (String, String)

-- | Output port name of the clock source component indicating that the
--   clock signal is stable.
[c_lock] :: ClockSource -> String

-- | Indicates whether the components synchronised by the clocks generated
--   by this clock source are pulled out of reset simultaneously.
--   
--   The recommended setting if <a>False</a>.
--   
--   When <a>c_sync</a> is set to <a>False</a>, the compiler generates
--   reset synchronisers which ensure that each component is synchronously
--   pulled out of reset, preventing <a>metastability</a> introduced by
--   unlucky timing of the reset de-assertion.
--   
--   When <a>c_sync</a> is set to <a>True</a> those reset synchronisers are
--   not generated and there is change for reset-induced metastability.
[c_sync] :: ClockSource -> Bool

-- | Default <a>TopEntity</a> which has no clocks, and no specified names
--   for the input and output ports. Also has no clock sources:
--   
--   <pre>
--   &gt;&gt;&gt; defTop
--   TopEntity {t_name = "topentity", t_inputs = [], t_outputs = [], t_extraIn = [], t_extraOut = [], t_clocks = []}
--   </pre>
defTop :: TopEntity

-- | A clock source that corresponds to the Altera/Quartus "ALTPLL"
--   component with default settings to provide a stable
--   <a>systemClock</a>.
--   
--   <pre>
--   &gt;&gt;&gt; altpll "altpll50" "CLOCK(0)" "not KEY(0)"
--   ClockSource {c_name = "altpll50", c_inp = Just ("inclk0","CLOCK(0)"), c_outp = [("c0","system1000")], c_reset = Just ("areset","not KEY(0)"), c_lock = "locked", c_sync = False}
--   </pre>
--   
--   Will generate the following VHDL:
--   
--   <pre>
--   altpll50_inst : entity altpll50
--     port map
--       (inclk0 =&gt; CLOCK_50(0)
--       ,c0     =&gt; system1000
--       ,areset =&gt; not KEY0(0)
--       ,locked =&gt; altpll50_locked);
--   </pre>
--   
--   If you are however generating (System)Verilog you should write:
--   
--   <pre>
--   &gt;&gt;&gt; altpll "altpll50" "CLOCK[0]" "~ KEY[0]"
--   ClockSource {c_name = "altpll50", c_inp = Just ("inclk0","CLOCK[0]"), c_outp = [("c0","system1000")], c_reset = Just ("areset","~ KEY[0]"), c_lock = "locked", c_sync = False}
--   </pre>
--   
--   so that the following (System)Verilog is created:
--   
--   <pre>
--   altpll50 altpll50_inst
--   (.inclk0 (CLOCK_50[0])
--   ,.c0 (system1000)
--   ,.areset (~ KEY0[0])
--   ,.locked (altpll50_locked));
--   </pre>
altpll :: String -> String -> String -> ClockSource

-- | A clock source that corresponds to the Altera "Altera PLL" component
--   with default settings to provide a stable <a>systemClock</a>.
--   
--   <pre>
--   &gt;&gt;&gt; alteraPll "alteraPll50" "CLOCK(0)" "not KEY(0)"
--   ClockSource {c_name = "alteraPll50", c_inp = Just ("refclk","CLOCK(0)"), c_outp = [("outclk_0","system1000")], c_reset = Just ("rst","not KEY(0)"), c_lock = "locked", c_sync = False}
--   </pre>
--   
--   Will generate the following VHDL:
--   
--   <pre>
--   alteraPll50_inst : entity alteraPll
--     port map
--       (refclk   =&gt; CLOCK_50(0)
--       ,outclk_0 =&gt; system1000
--       ,rst      =&gt; not KEY0(0)
--       ,locked   =&gt; alteraPll50_locked);
--   </pre>
--   
--   If you are however generating (System)Verilog you should write:
--   
--   <pre>
--   &gt;&gt;&gt; alteraPll "alteraPll50" "CLOCK[0]" "~ KEY[0]"
--   ClockSource {c_name = "alteraPll50", c_inp = Just ("refclk","CLOCK[0]"), c_outp = [("outclk_0","system1000")], c_reset = Just ("rst","~ KEY[0]"), c_lock = "locked", c_sync = False}
--   </pre>
--   
--   so that the following (System)Verilog is created:
--   
--   <pre>
--   alteraPll50 alteraPll50_inst
--   (.refclk (CLOCK_50[0])
--   ,.outclk_0 (system1000)
--   ,.rst (~ KEY0[0])
--   ,.locked (alteraPll50_locked));
--   </pre>
alteraPll :: String -> String -> String -> ClockSource

-- | A clock source that corresponds to the Xilinx PLL/MMCM component
--   created with the "Clock Wizard", with settings to provide a stable
--   <a>systemClock</a>.
--   
--   <pre>
--   &gt;&gt;&gt; clockWizard "clkwiz50" "CLOCK(0)" "not KEY(0)"
--   ClockSource {c_name = "clkwiz50", c_inp = Just ("CLK_IN1","CLOCK(0)"), c_outp = [("CLK_OUT1","system1000")], c_reset = Just ("RESET","not KEY(0)"), c_lock = "LOCKED", c_sync = False}
--   </pre>
--   
--   Will generate the following VHDL:
--   
--   <pre>
--   clkwiz50_inst : entity clkwiz50
--     port map
--       (CLK_IN1  =&gt; CLOCK_50(0)
--       ,CLK_OUT1 =&gt; system1000
--       ,RESET    =&gt; not KEY0(0)
--       ,LOCKED   =&gt; altpll50_locked);
--   </pre>
--   
--   If you are however generating (System)Verilog you should write:
--   
--   <pre>
--   &gt;&gt;&gt; clockWizard "clkwiz50" "CLOCK[0]" "~ KEY[0]"
--   ClockSource {c_name = "clkwiz50", c_inp = Just ("CLK_IN1","CLOCK[0]"), c_outp = [("CLK_OUT1","system1000")], c_reset = Just ("RESET","~ KEY[0]"), c_lock = "LOCKED", c_sync = False}
--   </pre>
--   
--   so that the following (System)Verilog is created:
--   
--   <pre>
--   clkwiz50 clkwiz50_inst
--   (.CLK_IN1 (CLOCK_50[0])
--   ,.CLK_OUT1 (system1000)
--   ,.RESET (~ KEY0[0])
--   ,.LOCKED (altpll50_locked));
--   </pre>
clockWizard :: String -> String -> String -> ClockSource
instance [safe] Show TopEntity
instance [safe] Data TopEntity
instance [safe] Show ClockSource
instance [safe] Data ClockSource


-- | <b>This is the <a>Safe</a> API only of <a>CLaSH.Prelude</a></b>
--   
--   CλaSH (pronounced ‘clash’) is a functional hardware description
--   language that borrows both its syntax and semantics from the
--   functional programming language Haskell. The merits of using a
--   functional language to describe hardware comes from the fact that
--   combinational circuits can be directly modeled as mathematical
--   functions and that functional languages lend themselves very well at
--   describing and (de-)composing mathematical functions.
--   
--   This package provides:
--   
--   <ul>
--   <li>Prelude library containing datatypes and functions for circuit
--   design</li>
--   </ul>
--   
--   To use the library:
--   
--   <ul>
--   <li>Import <a>CLaSH.Prelude</a></li>
--   <li>Additionally import <a>CLaSH.Prelude.Explicit</a> if you want to
--   design explicitly clocked circuits in a multi-clock setting</li>
--   </ul>
--   
--   For now, <a>CLaSH.Prelude</a> is also the best starting point for
--   exploring the library. A preliminary version of a tutorial can be
--   found in <a>CLaSH.Tutorial</a>. Some circuit examples can be found in
--   <a>CLaSH.Examples</a>.
module CLaSH.Prelude.Safe

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>mealy</a> mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy</a> mac 0 (<a>bundle</a> (a,x))
--       s2 = <a>mealy</a> mac 0 (<a>bundle</a> (b,y))
--   </pre>
mealy :: (s -> i -> (s, o)) -> s -> (Signal i -> Signal o)

-- | A version of <a>mealy</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool, Int) -&gt; (Int, (Int, Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>mealy</a> f 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>mealy</a> f 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mealyB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB</a> f 0 (a,b)
--       (i2,b2) = <a>mealyB</a> f 3 (i1,c)
--   </pre>
mealyB :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Infix version of <a>mealyB</a>
(<^>) :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; Int        -- Updated state
--   mac s (x,y) = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>moore</a> mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore</a> mac id 0 (<a>bundle</a> (a,x))
--       s2 = <a>moore</a> mac id 0 (<a>bundle</a> (b,y))
--   </pre>
moore :: (s -> i -> s) -> (s -> o) -> s -> (Signal i -> Signal o)

-- | A version of <a>moore</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>moore</a> t o 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>moore</a> t o 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mooreB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB</a> t o 0 (a,b)
--       (i2,b2) = <a>mooreB</a> t o 3 (i1,c)
--   </pre>
mooreB :: (Bundle i, Bundle o) => (s -> i -> s) -> (s -> o) -> s -> (Unbundled i -> Unbundled o)

-- | Create a <a>register</a> function for product-type like signals (e.g.
--   '(Signal a, Signal b)')
--   
--   <pre>
--   rP :: (Signal Int,Signal Int) -&gt; (Signal Int, Signal Int)
--   rP = registerB (8,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB rP [(1,1),(2,2),(3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
registerB :: Bundle a => a -> Unbundled a -> Unbundled a

-- | An asynchronous/combinational ROM with space for <tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRom :: (KnownNat n, Enum addr) => Vec n a -> addr -> a

-- | An asynchronous/combinational ROM with space for 2^<tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRomPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Unsigned n -> a

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom :: (KnownNat n, KnownNat m) => Vec n a -> Signal (Unsigned m) -> Signal a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal a

-- | Create a RAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam :: (KnownNat n, Enum addr) => SNat n -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram40 :: <a>Signal</a> (<a>Unsigned</a> 6) -&gt; Signal (<a>Unsigned</a> 6) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; Signal <a>Bit</a>
--   bram40 = <a>blockRam</a> (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam :: (KnownNat n, Enum addr) => Vec n a -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram32 :: <a>Signal</a> (<a>Unsigned</a> 5) -&gt; Signal (<a>Unsigned</a> 5) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; <a>Signal</a> <a>Bit</a>
--   bram32 = <a>blockRamPow2</a> (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Give a pulse when the <a>Signal</a> goes from <a>minBound</a> to
--   <a>maxBound</a>
isRising :: (Bounded a, Eq a) => a -> Signal a -> Signal Bool

-- | Give a pulse when the <a>Signal</a> goes from <a>maxBound</a> to
--   <a>minBound</a>
isFalling :: (Bounded a, Eq a) => a -> Signal a -> Signal Bool


-- | CλaSH (pronounced ‘clash’) is a functional hardware description
--   language that borrows both its syntax and semantics from the
--   functional programming language Haskell. The merits of using a
--   functional language to describe hardware comes from the fact that
--   combinational circuits can be directly modeled as mathematical
--   functions and that functional languages lend themselves very well at
--   describing and (de-)composing mathematical functions.
--   
--   This package provides:
--   
--   <ul>
--   <li>Prelude library containing datatypes and functions for circuit
--   design</li>
--   </ul>
--   
--   To use the library:
--   
--   <ul>
--   <li>Import <a>CLaSH.Prelude</a></li>
--   <li>Additionally import <a>CLaSH.Prelude.Explicit</a> if you want to
--   design explicitly clocked circuits in a multi-clock setting</li>
--   </ul>
--   
--   For now, <a>CLaSH.Prelude</a> is also the best starting point for
--   exploring the library. A preliminary version of a tutorial can be
--   found in <a>CLaSH.Tutorial</a>. Some circuit examples can be found in
--   <a>CLaSH.Examples</a>.
module CLaSH.Prelude

-- | Create a synchronous function from a combinational function describing
--   a mealy machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; (Int,Int)  -- (Updated state, output)
--   mac s (x,y) = (s',s)
--     where
--       s' = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>mealy</a> mac 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>mealy</a> mac 0 (<a>bundle</a> (a,x))
--       s2 = <a>mealy</a> mac 0 (<a>bundle</a> (b,y))
--   </pre>
mealy :: (s -> i -> (s, o)) -> s -> (Signal i -> Signal o)

-- | A version of <a>mealy</a> that does automatic <a>Bundle</a>ing
--   
--   Given a function <tt>f</tt> of type:
--   
--   <pre>
--   <b>f</b> :: Int -&gt; (Bool, Int) -&gt; (Int, (Int, Bool))
--   </pre>
--   
--   When we want to make compositions of <tt>f</tt> in <tt>g</tt> using
--   <a>mealy</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>mealy</a> f 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>mealy</a> f 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mealyB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mealyB</a> f 0 (a,b)
--       (i2,b2) = <a>mealyB</a> f 3 (i1,c)
--   </pre>
mealyB :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Infix version of <a>mealyB</a>
(<^>) :: (Bundle i, Bundle o) => (s -> i -> (s, o)) -> s -> (Unbundled i -> Unbundled o)

-- | Create a synchronous function from a combinational function describing
--   a moore machine
--   
--   <pre>
--   mac :: Int        -- Current state
--       -&gt; (Int,Int)  -- Input
--       -&gt; Int        -- Updated state
--   mac s (x,y) = x * y + s
--   
--   topEntity :: <a>Signal</a> (Int, Int) -&gt; <a>Signal</a> Int
--   topEntity = <a>moore</a> mac id 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulate topEntity [(1,1),(2,2),(3,3),(4,4)]
--   [0,1,5,14...
--   </pre>
--   
--   Synchronous sequential functions can be composed just like their
--   combinational counterpart:
--   
--   <pre>
--   dualMac :: (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; (<a>Signal</a> Int, <a>Signal</a> Int)
--           -&gt; <a>Signal</a> Int
--   dualMac (a,b) (x,y) = s1 + s2
--     where
--       s1 = <a>moore</a> mac id 0 (<a>bundle</a> (a,x))
--       s2 = <a>moore</a> mac id 0 (<a>bundle</a> (b,y))
--   </pre>
moore :: (s -> i -> s) -> (s -> o) -> s -> (Signal i -> Signal o)

-- | A version of <a>moore</a> that does automatic <a>Bundle</a>ing
--   
--   Given a functions <tt>t</tt> and <tt>o</tt> of types:
--   
--   <pre>
--   <b>t</b> :: Int -&gt; (Bool, Int) -&gt; Int
--   <b>o</b> :: Int -&gt; (Int, Bool)
--   </pre>
--   
--   When we want to make compositions of <tt>t</tt> and <tt>o</tt> in
--   <tt>g</tt> using <a>moore</a>, we have to write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>unbundle</a> (<a>moore</a> t o 0 (<a>bundle</a> (a,b)))
--       (i2,b2) = <a>unbundle</a> (<a>moore</a> t o 3 (<a>bundle</a> (i1,c)))
--   </pre>
--   
--   Using <a>mooreB</a> however we can write:
--   
--   <pre>
--   g a b c = (b1,b2,i2)
--     where
--       (i1,b1) = <a>mooreB</a> t o 0 (a,b)
--       (i2,b2) = <a>mooreB</a> t o 3 (i1,c)
--   </pre>
mooreB :: (Bundle i, Bundle o) => (s -> i -> s) -> (s -> o) -> s -> (Unbundled i -> Unbundled o)

-- | Create a <a>register</a> function for product-type like signals (e.g.
--   '(Signal a, Signal b)')
--   
--   <pre>
--   rP :: (Signal Int,Signal Int) -&gt; (Signal Int, Signal Int)
--   rP = registerB (8,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB rP [(1,1),(2,2),(3,3)] :: [(Int,Int)]
--   [(8,8),(1,1),(2,2),(3,3)...
--   </pre>
registerB :: Bundle a => a -> Unbundled a -> Unbundled a

-- | An asynchronous/combinational ROM with space for <tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRom :: (KnownNat n, Enum addr) => Vec n a -> addr -> a

-- | An asynchronous/combinational ROM with space for 2^<tt>n</tt> elements
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
asyncRomPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Unsigned n -> a

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
rom :: (KnownNat n, KnownNat m) => Vec n a -> Signal (Unsigned m) -> Signal a

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> and
--   <a>CLaSH.Prelude.BlockRam#usingrams</a> for ideas on how to use ROMs
--   and RAMs</li>
--   </ul>
romPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal a

-- | An asynchronous/combinational ROM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
asyncRomFile :: (KnownNat m, Enum addr) => SNat n -> FilePath -> addr -> BitVector m

-- | An asynchronous/combinational ROM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
asyncRomFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Unsigned n -> BitVector m

-- | A ROM with a synchronous read port, with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFile :: (KnownNat m, KnownNat k) => SNat n -> FilePath -> Signal (Unsigned k) -> Signal (BitVector m)

-- | A ROM with a synchronous read port, with space for 2^<tt>n</tt>
--   elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.ROM.File#usingromfiles</a> for more
--   information on how to instantiate a ROM with the contents of a data
--   file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
romFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Signal (Unsigned n) -> Signal (BitVector m)

-- | Create a RAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRam :: (KnownNat n, Enum addr) => SNat n -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a RAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Initial content of the RAM is <a>undefined</a></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a RAM.</li>
--   </ul>
asyncRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for <tt>n</tt> elements.
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram40 :: <a>Signal</a> (<a>Unsigned</a> 6) -&gt; Signal (<a>Unsigned</a> 6) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; Signal <a>Bit</a>
--   bram40 = <a>blockRam</a> (<a>replicate</a> d40 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRam :: (KnownNat n, Enum addr) => Vec n a -> Signal addr -> Signal addr -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   </ul>
--   
--   <pre>
--   bram32 :: <a>Signal</a> (<a>Unsigned</a> 5) -&gt; Signal (<a>Unsigned</a> 5) -&gt; <a>Signal</a> Bool
--          -&gt; <a>Signal</a> <a>Bit</a> -&gt; <a>Signal</a> <a>Bit</a>
--   bram32 = <a>blockRamPow2</a> (<a>replicate</a> d32 1)
--   </pre>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   </ul>
blockRamPow2 :: (KnownNat (2 ^ n), KnownNat n) => Vec (2 ^ n) a -> Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal a -> Signal a

-- | Create a blockRAM with space for <tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFile :: (KnownNat m, Enum addr) => SNat n -> FilePath -> Signal addr -> Signal addr -> Signal Bool -> Signal (BitVector m) -> Signal (BitVector m)

-- | Create a blockRAM with space for 2^<tt>n</tt> elements
--   
--   <ul>
--   <li><b>NB</b>: Read value is delayed by 1 cycle</li>
--   <li><b>NB</b>: Initial output value is <a>undefined</a></li>
--   <li><b>NB</b>: This function might not work for specific combinations
--   of code-generation backends and hardware targets. Please check the
--   support table below:<pre> | VHDL | Verilog | SystemVerilog |
--   ===============+==========+==========+===============+ Altera/Quartus
--   | Broken | Works | Works | Xilinx/ISE | Works | Works | Works | ASIC |
--   Untested | Untested | Untested |
--   ===============+==========+==========+===============+ </pre></li>
--   </ul>
--   
--   Additional helpful information:
--   
--   <ul>
--   <li>See <a>CLaSH.Prelude.BlockRam#usingrams</a> for more information
--   on how to use a Block RAM.</li>
--   <li>See <a>CLaSH.Prelude.BlockRam.File#usingramfiles</a> for more
--   information on how to instantiate a Block RAM with the contents of a
--   data file.</li>
--   <li>See <a>CLaSH.Sized.Fixed#creatingdatafiles</a> for ideas on how to
--   create your own data files.</li>
--   </ul>
blockRamFilePow2 :: (KnownNat m, KnownNat n, KnownNat (2 ^ n)) => FilePath -> Signal (Unsigned n) -> Signal (Unsigned n) -> Signal Bool -> Signal (BitVector m) -> Signal (BitVector m)

-- | Give a window over a <a>Signal</a>
--   
--   <pre>
--   window4 :: Signal Int -&gt; Vec 4 (Signal Int)
--   window4 = window
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB window4 [1::Int,2,3,4,5] :: [Vec 4 Int]
--   [&lt;1,0,0,0&gt;,&lt;2,1,0,0&gt;,&lt;3,2,1,0&gt;,&lt;4,3,2,1&gt;,&lt;5,4,3,2&gt;...
--   </pre>
window :: (KnownNat n, Default a) => Signal a -> Vec (n + 1) (Signal a)

-- | Give a delayed window over a <a>Signal</a>
--   
--   <pre>
--   windowD3 :: Signal Int -&gt; Vec 3 (Signal Int)
--   windowD3 = windowD
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; simulateB windowD3 [1::Int,2,3,4] :: [Vec 3 Int]
--   [&lt;0,0,0&gt;,&lt;1,0,0&gt;,&lt;2,1,0&gt;,&lt;3,2,1&gt;,&lt;4,3,2&gt;...
--   </pre>
windowD :: (KnownNat (n + 1), Default a) => Signal a -> Vec (n + 1) (Signal a)

-- | Give a pulse when the <a>Signal</a> goes from <a>minBound</a> to
--   <a>maxBound</a>
isRising :: (Bounded a, Eq a) => a -> Signal a -> Signal Bool

-- | Give a pulse when the <a>Signal</a> goes from <a>maxBound</a> to
--   <a>minBound</a>
isFalling :: (Bounded a, Eq a) => a -> Signal a -> Signal Bool

-- | Compares the first two <a>Signal</a>s for equality and logs a warning
--   when they are not equal. The second <a>Signal</a> is considered the
--   expected value. This function simply returns the third <a>Signal</a>
--   unaltered as its result. This function is used by
--   <a>outputVerifier</a>.
--   
--   <b>NB</b>: This function is <i>can</i> be used in synthesizable
--   designs.
assert :: (Eq a, Show a) => String -> Signal a -> Signal a -> Signal b -> Signal b

-- | To be used as a one of the functions to create the "magical"
--   <tt>testInput</tt> value, which the CλaSH compilers looks for to
--   create the stimulus generator for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   testInput :: <a>Signal</a> Int
--   testInput = <a>stimuliGenerator</a> $(<a>v</a> [(1::Int),3..21])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sampleN 13 testInput
--   [1,3,5,7,9,11,13,15,17,19,21,21,21]
--   </pre>
stimuliGenerator :: KnownNat l => Vec l a -> Signal a

-- | To be used as a functions to generate the "magical"
--   <tt>expectedOutput</tt> function, which the CλaSH compilers looks for
--   to create the signal verifier for the generated VHDL testbench.
--   
--   Example:
--   
--   <pre>
--   expectedOutput :: <a>Signal</a> Int -&gt; <a>Signal</a> Bool
--   expectedOutput = <a>outputVerifier</a> $(<a>v</a> ([70,99,2,3,4,5,7,8,9,10]::[Int]))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.List as List
--   
--   &gt;&gt;&gt; sampleN 12 (expectedOutput (fromList ([0..10] List.++ [10,10,10])))
--   [
--   cycle(system1000): 0, outputVerifier
--   expected value: 70, not equal to actual value: 0
--   False,
--   cycle(system1000): 1, outputVerifier
--   expected value: 99, not equal to actual value: 1
--   False,False,False,False,False,
--   cycle(system1000): 6, outputVerifier
--   expected value: 7, not equal to actual value: 6
--   False,
--   cycle(system1000): 7, outputVerifier
--   expected value: 8, not equal to actual value: 7
--   False,
--   cycle(system1000): 8, outputVerifier
--   expected value: 9, not equal to actual value: 8
--   False,
--   cycle(system1000): 9, outputVerifier
--   expected value: 10, not equal to actual value: 9
--   False,True,True]
--   </pre>
outputVerifier :: (KnownNat l, Eq a, Show a) => Vec l a -> Signal a -> Signal Bool
class Lift t
lift :: Lift t => t -> Q Exp

-- | Derive Lift instances for the given datatype.
deriveLift :: Name -> Q [Dec]


module CLaSH.Tutorial


module CLaSH.Examples
