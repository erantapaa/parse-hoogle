-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common text/parsing tools for Razom language packages.
--   
@package razom-text-util
@version 0.1.2.0

module Text.Razom.Types

-- | A regular expression over Unicode characters.
type Regex a = RE Char a

-- | A position-aware regular expression over Unicode characters.
type PosRegex a = PosRE Char a

-- | An error returned when applying a regex fails. Parameters:
--   
--   <ol>
--   <li>Location of the error</li>
--   <li>Previous tokens parsed successfully</li>
--   <li>The rest of the text</li>
--   </ol>
data LexError t
LexError :: Position -> [t] -> String -> LexError t

-- | What is returned by lexical analyzer.
type LexResult t = Either (LexError t) [t]
instance Show t => Show (LexError t)

module Text.Razom.Number

-- | Selects ASCII binary digits, i.e. <tt>'0'</tt> and <tt>'1</tt>'.
isBinDigit :: Char -> Bool

-- | Given the radix and an integer represented as a list of digits,
--   construct a number of the represented value.
--   
--   <pre>
--   &gt;&gt;&gt; digitsToNum 2 [1, 0, 1, 1, 0, 1]
--   45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; digitsToNum 16 [15, 15]
--   255
--   </pre>
digitsToNum :: Num a => a -> [a] -> a
binit :: Num a => Regex a
octit :: Num a => Regex a

-- | Decimal digit, i.e. <tt>'0'</tt>..<tt>'9'</tt>
digit :: Num a => RE Char a
hexit :: RE Char Integer
binary :: Num a => Regex a
octal :: Num a => Regex a

-- | Parse decimal number without sign.
decimal :: Num a => RE Char a

-- | Parse decimal number without sign.
hexadecimal :: Num a => RE Char a

-- | Add optional sign
signed :: Num a => RE Char a -> RE Char a

-- | Read a decimal number string into a <a>RealNum</a> value. The
--   parameters are the digits before the decimal point (integer part) and
--   after it (fraction part). Example with the number 142.857:
--   
--   <pre>
--   &gt;&gt;&gt; fromDigits [1, 4, 2] [8, 5, 7]
--   RealNum 142857 -3
--   </pre>
fromDigits :: [Int] -> [Int] -> RealNum

module Text.Razom.Lexer
tokenizeString :: Advance Char -> Regex t -> String -> LexResult t
tokenizeText :: Advance Char -> Regex t -> Text -> LexResult t
tokenizeFile :: Advance Char -> Regex t -> FilePath -> IO (LexResult t)

module Text.Razom.Char

-- | Selects Unicode characters with basic type Graphical.
isGraphical :: Char -> Bool

module Text.Razom.Uid

-- | Regex which matches and returns a Uid, unescaped and with delimiters
--   removed.
--   
--   <pre>
--   &gt;&gt;&gt; match uid "&lt;12&lt;34\\&gt;56\\\\7&gt;"
--   Just "12&lt;34&gt;56\\7"
--   </pre>
uid :: Regex String

-- | Regex which matches and returns a Uid generator, without delimiters
--   and the leading prefix character.
--   
--   <pre>
--   &gt;&gt;&gt; match generator "&lt;%&gt;"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; match generator "&lt;%mylabel&gt;"
--   Just "mylabel"
--   </pre>
generator :: Regex String

-- | Convert a Uid string into a form which can be put in a semantic
--   document. It doesn't add delimiters.
--   
--   <pre>
--   &gt;&gt;&gt; escapeUid "1&gt;2\\3"
--   "1\\&gt;2\\\\3"
--   </pre>
--   
--   To prevent confusion, the above is the same as:
--   
--   <pre>
--   ['1', '\\', '&gt;', '2', '\\', '\\', '3']
--   </pre>
escapeUid :: String -> String

-- | Convert a Uid as encoded in a semantic document into normal form, i.e.
--   converting escape sequences to their target characters.
--   
--   <pre>
--   &gt;&gt;&gt; unescapeUid "1\\&gt;2\\\\3"
--   "1&gt;2\\3"
--   </pre>
unescapeUid :: String -> String

module Text.Razom.Value

-- | Matches a delimited generic value literal and returns it, without
--   delimiters and still escaped (since unescaping may be type-specific).
--   
--   <pre>
--   &gt;&gt;&gt; match literal "{{1\\}2\\\\3}}"
--   Just "1\\}2\\\\3"
--   </pre>
literal :: Regex String

-- | Given a value literal in unescaped form, do minimal default escapes:
--   for the escape character itself (backslash) and for the closing
--   delimiter character (<tt>'{'</tt>).
escapeMinimal :: String -> String

-- | Given an escaped value literal, do minimal default unescapes: for the
--   escape character and for the closing delimiter.
unescapeMinimal :: String -> String

module Text.Razom
