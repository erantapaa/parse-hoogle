-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Limit operations for converging sequences
--   
--   Limit operations for converging sequences. This is fairly simple right
--   now.
--   
--   Changes in 0.1.0.1: Nothing except to enable -XSafe under GHC 7.2.1
@package converge
@version 0.1.0.1

module Math.Sequence.Converge

-- | Take items from the list until two successive items are equal and
--   return the second of them (or an item is not equal to itself, to
--   handle NaN without a <a>RealFloat</a> context. In this case, the first
--   item of the pair is returned) . If the list ends before a match is
--   found, returns the last element of the list.
converge :: Eq a => [a] -> a

-- | <tt>convergeTo absEps relEps xs</tt> takes items from <tt>xs</tt>
--   until two successive items <tt>x</tt> and <tt>y</tt> are within either
--   <tt>absEps</tt> or <tt>relEps * max (abs x) (abs y)</tt> of each
--   other, in which case the second of the pair is returned, or until an
--   item is found that does not equal itself (which would typically be a
--   NaN), in which case the preceding item is returned. If the list ends
--   before a match is found, the last element of the list is returned.
--   
--   For example, approximating the golden mean by applying Newton's method
--   to find a root of <tt>x^2 - x - 1</tt>:
--   
--   <pre>
--   phi :: Rational
--   phi = convergeTo 1e-100 0 (iterate (\x -&gt; (x*x + 1) / (2*x-1)) 1)
--   </pre>
convergeTo :: (Fractional a, Ord a) => a -> a -> [a] -> a

-- | <tt>convergeBy f end xs</tt> looks through <tt>xs</tt> for the first
--   segment for which <tt>f</tt> returns a value, and returns that value.
--   Typically <tt>f</tt> would be something like:
--   
--   <pre>
--   f (a:b:_)
--      | abs(a-b) &lt;= eps
--      = Just (0.5 * (a + b))
--   f _ = Nothing
--   </pre>
--   
--   If no such segment is found, applies <tt>end</tt> to the last item in
--   the list and returns the result. If the list was empty, returns
--   <a>Nothing</a>.
convergeBy :: ([a] -> Maybe b) -> (a -> Maybe b) -> [a] -> Maybe b
