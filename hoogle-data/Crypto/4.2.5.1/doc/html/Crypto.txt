-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collects together existing Haskell cryptographic functions into a package
--   
--   DES, Blowfish, AES, TEA, SHA1, MD5, RSA, BubbleBabble, Hexdump,
--   Support for Word128, Word192 and Word256 and Beyond, PKCS5 Padding,
--   Various Encryption Modes e.g. Cipher Block Chaining all in one
--   package, with HUnit and QuickCheck tests, and examples.
@package Crypto
@version 4.2.5.1


-- | Implements SHA-256, SHA-384, SHA-512, and SHA-224 as defined in FIPS
--   180-2
--   <a>http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.
module Data.Digest.SHA2

-- | <a>sha256</a> currently requires that the bitSize of <tt>a</tt> divide
--   32
sha256 :: (Bits a, Integral a) => [a] -> Hash256

-- | <tt>shaXXXAscii</tt> assumes that all characters of the strings are
--   ISO-latin-1 characters. ie. each characters fits in one octet.
sha256Ascii :: String -> Hash256
type Hash256 = Hash8 Word32

-- | <a>sha384</a> currently requires that the bitSize of <tt>a</tt> divide
--   64
sha512 :: (Bits a, Integral a) => [a] -> Hash512
sha512Ascii :: String -> Hash512
type Hash512 = Hash8 Word64

-- | <a>sha384</a> currently requires that the bitSize of <tt>a</tt> divide
--   64
sha384 :: (Bits a, Integral a) => [a] -> Hash384
sha384Ascii :: String -> Hash384
data Hash384

-- | <a>sha224</a> currently requires that the bitSize of <tt>a</tt> divide
--   32
sha224 :: (Bits a, Integral a) => [a] -> Hash224
sha224Ascii :: String -> Hash224
data Hash224
toOctets :: Hash h => h -> [Word8]
instance Eq w => Eq (Hash8 w)
instance Ord w => Ord (Hash8 w)
instance Eq Hash384
instance Ord Hash384
instance Eq Hash224
instance Ord Hash224
instance Hash Hash224
instance Hash Hash384
instance (Integral h, Bits h, Show h) => Hash (Hash8 h)
instance Show Hash224
instance Show Hash384
instance (Integral a, Show a) => Show (Hash8 a)
instance ShaData Word64
instance ShaData Word32


-- | This module currently supports Cipher Block Chaining (CBC) mode. See
--   <a>http://www.itl.nist.gov/fipspubs/fip81.htm</a> for further details.
module Codec.Encryption.Modes

-- | In CBC or Cipher Block Chaining mode each block is XORed with the
--   previous enciphered block before encryption. For the first block,
--   start with an initialization vector. Take an encryption function, an
--   initialisation vector, a key and a list of blocks and return the
--   encrypted blocks using CBC.
cbc :: Bits block => (key -> block -> block) -> block -> key -> [block] -> [block]

-- | To decipher in CBC or Cipher Block Chaining mode, decipher each block,
--   then XOR the result with the previous block of plaintext result. Note
--   that the initialization vector is treated as the zeroth block of
--   plaintext. Take a decryption function, an initialisation vector, a key
--   and a list of encrypted blocks using CBC and return plaintext blocks.
unCbc :: Bits block => (key -> block -> block) -> block -> key -> [block] -> [block]


-- | Implementation of the TEA tiny encryption algorithm
module Codec.Encryption.TEA
data TEAKey
TEAKey :: {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> TEAKey
encrypt :: TEAKey -> Word64 -> Word64
decrypt :: TEAKey -> Word64 -> Word64


-- | Provides Word128, Word192 and Word256 and a way of producing other
--   large words if required.
module Data.LargeWord
data LargeKey a b
type Word96 = LargeKey Word32 Word64
type Word128 = LargeKey Word64 Word64
type Word160 = LargeKey Word32 Word128
type Word192 = LargeKey Word64 Word128
type Word224 = LargeKey Word32 Word192
type Word256 = LargeKey Word64 Word192
instance (Eq a, Eq b) => Eq (LargeKey a b)
instance (Ord a, Ord b) => Ord (LargeKey a b)
instance Enum (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Ord b, Bits b, LargeWord b) => Real (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Ord b, Bits b, LargeWord b) => Integral (LargeKey a b)
instance (Ord a, Bits a, Bounded a, Integral a, LargeWord a, Bits b, Bounded b, Integral b, LargeWord b) => Bounded (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Bits b, LargeWord b) => Bits (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Bits b, LargeWord b) => Num (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Bits b, LargeWord b) => Show (LargeKey a b)
instance (Ord a, Bits a, LargeWord a, Bits b, LargeWord b) => LargeWord (LargeKey a b)
instance LargeWord Word64
instance LargeWord Word32


-- | Takes the DES module supplied by Ian Lynagh and wraps it so it can
--   used with the standard modes.
--   
--   See <a>http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/</a>.
module Codec.Encryption.DES

-- | Basic DES encryption which takes a key and a block of plaintext and
--   returns the encrypted block of ciphertext according to the standard.
encrypt :: Word64 -> Word64 -> Word64

-- | Basic DES decryption which takes a key and a block of ciphertext and
--   returns the decrypted block of plaintext according to the standard.
decrypt :: Word64 -> Word64 -> Word64

module Codec.Encryption.RSA.NumberTheory
inverse :: Integer -> Integer -> Integer
extEuclGcd :: Integer -> Integer -> (Integer, Integer)
simplePrimalityTest :: Integer -> Bool
getPrime :: Int -> IO Integer
pg :: Integer -> Integer -> Integer -> IO (Integer)
isPrime :: Integer -> IO Bool
rabinMillerPrimalityTest :: Integer -> IO Bool
expmod :: Integer -> Integer -> Integer -> Integer
factor :: Integer -> [Int]
testInverse :: Integer -> Integer -> Bool
primes :: [Integer]
(/|) :: Integer -> Integer -> Bool
randomOctet :: Int -> IO (String)


-- | Utilities for coding and decoding.
module Codec.Utils

-- | The basic type for encoding and decoding.
type Octet = Word8

-- | The most significant bit of an <a>Octet</a>.
msb :: Int

-- | Convert from twos complement.
fromTwosComp :: Integral a => [Octet] -> a
toTwosComp :: Integral a => a -> [Octet]

-- | Take a number a convert it to base n as a list of octets.
toOctets :: (Integral a, Integral b) => a -> b -> [Octet]

-- | Take a list of octets (a number expressed in base n) and convert it to
--   a number.
fromOctets :: (Integral a, Integral b) => a -> [Octet] -> b

-- | See <a>listToOctets</a>.
listFromOctets :: (Integral a, Bits a) => [Octet] -> [a]

-- | Converts a list of numbers into a list of octets. The resultant list
--   has nulls trimmed from the end to make this the dual of listFromOctets
--   (except when the original octet list ended with nulls; see
--   <a>trimNulls</a>).
listToOctets :: (Bits a, Integral a) => [a] -> [Octet]

-- | Take the length of the required number of octets and convert the
--   number to base 256 padding it out to the required length. If the
--   required length is less than the number of octets of the converted
--   number then return the converted number. NB this is different from the
--   standard
--   <a>ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf</a> but
--   mimics how replicate behaves.
i2osp :: Integral a => Int -> a -> [Octet]


-- | A modified version of the RSA module supplied by David J. Sankel
--   (<a>http://www.electronconsulting.com/rsa-haskell</a>).
--   
--   As the original code is GPL, this has to be. This code is free
--   software; you can redistribute it and/or modify it under the terms of
--   the GNU General Public License as published by the Free Software
--   Foundation; either version 2 of the License, or (at your option) any
--   later version.
--   
--   This code is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   General Public License for more details.
--   
--   You should have received a copy of the GNU General Public License
--   along with this code; if not, write to the Free Software Foundation,
--   Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
module Codec.Encryption.RSA

-- | Take the modulus of the RSA key and the public exponent expressed as
--   lists of octets and the plaintext also expressed as a list of octets
--   and return the ciphertext as a list of octets. Of course, these are
--   all large integers but using lists of octets makes everything easier.
--   See <a>http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/index.html</a>
--   for more details.
encrypt :: ([Octet], [Octet]) -> [Octet] -> [Octet]

-- | Take the modulus of the RSA key and the private exponent expressed as
--   lists of octets and the ciphertext also expressed as a list of octets
--   and return the plaintext as a list of octets.
decrypt :: ([Octet], [Octet]) -> [Octet] -> [Octet]


-- | A modified version of the EMEOAEP module supplied by David J. Sankel
--   (<a>http://www.electronconsulting.com/rsa-haskell</a>).
--   
--   As the original code is GPL, this has to be. This code is free
--   software; you can redistribute it and/or modify it under the terms of
--   the GNU General Public License as published by the Free Software
--   Foundation; either version 2 of the License, or (at your option) any
--   later version.
--   
--   This code is distributed in the hope that it will be useful, but
--   WITHOUT ANY WARRANTY; without even the implied warranty of
--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
--   General Public License for more details.
--   
--   You should have received a copy of the GNU General Public License
--   along with this code; if not, write to the Free Software Foundation,
--   Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
module Codec.Encryption.RSA.EMEOAEP

-- | Take a mask generating function, a hash function, a label (which may
--   be null), a random seed, the modulus of the key and the message and
--   returns an encoded message. NB you could pass in the length of the
--   modulus but it seems safer to pass in the modulus itself and calculate
--   the length when required. See
--   <a>ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf</a> for
--   more details.
encode :: (([Octet] -> [Octet]) -> [Octet] -> Int -> [Octet]) -> ([Octet] -> [Octet]) -> [Octet] -> [Octet] -> [Octet] -> [Octet] -> [Octet]

-- | Take a mask generating function, a hash function, a label (which may
--   be null) and the message and returns the decoded.
decode :: (([Octet] -> [Octet]) -> [Octet] -> Int -> [Octet]) -> ([Octet] -> [Octet]) -> [Octet] -> [Octet] -> [Octet]


-- | Implements the mask generation function as specified in:
--   <a>ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf</a>
module Codec.Encryption.RSA.MGF

-- | Take a hash function, a seed and the intended length of the the mask
--   and deliver a mask of the requested length.
mgf :: ([Octet] -> [Octet]) -> [Octet] -> Int -> [Octet]


-- | Takes the AES module supplied by Lukasz Anforowicz and wraps it so it
--   can used with the standard modes.
module Codec.Encryption.AES

-- | Basic AES encryption which takes a key and a block of plaintext and
--   returns the encrypted block of ciphertext according to the standard.
encrypt :: AESKey a => a -> Word128 -> Word128

-- | Basic AES decryption which takes a key and a block of ciphertext and
--   returns the decrypted block of plaintext according to the standard.
decrypt :: AESKey a => a -> Word128 -> Word128
class AESKeyIndirection a => AESKey a
instance AESKey Word256
instance AESKey Word192
instance AESKey Word128
instance AESKeyIndirection Word256
instance AESKeyIndirection Word192
instance AESKeyIndirection Word128


-- | Takes the Blowfish module supplied by Doug Hoyte and wraps it so it
--   can used with the standard modes.
module Codec.Encryption.Blowfish

-- | Basic Blowfish encryption which takes a key and a block of plaintext
--   and returns the encrypted block of ciphertext according to the
--   standard. Typical keys are Word8, Word16, Word32, Word64, Word128. See
--   <a>http://www.counterpane.com/vectors.txt</a>.
encrypt :: Integral a => a -> Word64 -> Word64

-- | Basic Blowfish decryption which takes a key and a block of ciphertext
--   and returns the decrypted block of plaintext.
decrypt :: Integral a => a -> Word64 -> Word64


-- | Padding algorithms for use with block ciphers.
--   
--   This module currently supports:
--   
--   <ul>
--   <li>PKCS5 padding and unpadding.</li>
--   <li>Null padding and unpadding.</li>
--   </ul>
module Codec.Encryption.Padding

-- | When the last block of plaintext is shorter than the block size then
--   it must be padded. PKCS5 specifies that the padding octets should each
--   contain the number of octets which must be stripped off. So, for
--   example, with a block size of 8, "0a0b0c" will be padded with "05"
--   resulting in "0a0b0c0505050505". If the final block is a full block of
--   8 octets then a whole block of "0808080808080808" is appended.
pkcs5 :: (Integral a, Bits a) => [Octet] -> [a]

-- | Take a list of blocks padded using the method described in PKCS5 (see
--   <a>http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5</a>) and return the
--   list of unpadded octets. NB this function does not currently check
--   that the padded block is correctly formed and should only be used for
--   blocks that have been padded correctly.
unPkcs5 :: (Bits a, Integral a) => [a] -> [Octet]

-- | When the last block of plaintext is shorter than the block size then
--   it must be padded. Nulls padding specifies that the padding octets
--   should each contain a null. So, for example, with a block size of 8,
--   "0a0b0c" will be padded to "0a0b0c0000000000". If the final block is a
--   full block of 8 octets then a whole block of "0000000000000000" is
--   appended. NB this is only suitable for data which does not contain
--   nulls, for example, ASCII.
padNulls :: (Integral a, Bits a) => [Octet] -> [a]

-- | Take a list of blocks padded with nulls and return the list of
--   unpadded octets. NB if the blocks contain a null then the result is
--   unpredictable.
unPadNulls :: (Bits a, Integral a) => [a] -> [Octet]


module Codec.Text.Raw
hexdump :: OctetsPerLine -> [Octet] -> Doc
hexdumpBy :: String -> OctetsPerLine -> [Octet] -> Doc


-- | Takes the MD5 module supplied by Ian Lynagh and wraps it so it takes
--   [Octet] and returns [Octet] where the length of the result is always
--   16. See <a>http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/</a> and
--   <a>http://www.ietf.org/rfc/rfc1321.txt</a>.
module Data.Digest.MD5

-- | Take [Octet] and return [Octet] according to the standard. The length
--   of the result is always 16 octets or 128 bits as required by the
--   standard.
hash :: [Octet] -> [Octet]


-- | Take [Word8] and return Word160. See
--   <a>http://www.itl.nist.gov/fipspubs/fip180-1.htm</a> for the
--   specification.
module Data.Digest.SHA1
data Word160
Word160 :: {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> Word160
hash :: [Word8] -> Word160
lift2 :: (Word32 -> Word32 -> Word32) -> Word160 -> Word160 -> Word160
toInteger :: Word160 -> Integer
instance Eq Word160
instance Show Word160


-- | Takes the SHA2 module supplied and wraps it so it takes [Octet] and
--   returns [Octet] where the length of the result is always 28. and
--   <a>http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.
module Data.Digest.SHA224

-- | Take [Octet] and return [Octet] according to the standard. The length
--   of the result is always 28 octets or 224 bits as required by the
--   standard.
hash :: [Octet] -> [Octet]


-- | Takes the SHA2 module supplied and wraps it so it takes [Octet] and
--   returns [Octet] where the length of the result is always 32. and
--   <a>http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.
module Data.Digest.SHA256

-- | Take [Octet] and return [Octet] according to the standard. The length
--   of the result is always 32 octets or 256 bits as required by the
--   standard.
hash :: [Octet] -> [Octet]


-- | Takes the SHA2 module supplied and wraps it so it takes [Octet] and
--   returns [Octet] where the length of the result is always 48. and
--   <a>http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.
module Data.Digest.SHA384

-- | Take [Octet] and return [Octet] according to the standard. The length
--   of the result is always 48 octets or 384 bits as required by the
--   standard.
hash :: [Octet] -> [Octet]


-- | Takes the SHA2 module supplied and wraps it so it takes [Octet] and
--   returns [Octet] where the length of the result is always 64. and
--   <a>http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf</a>.
module Data.Digest.SHA512

-- | Take [Octet] and return [Octet] according to the standard. The length
--   of the result is always 64 octets or 512 bits as required by the
--   standard.
hash :: [Octet] -> [Octet]


-- | Implements HMAC (hashed message authentication code) as defined in
--   FIPS 198
--   <a>http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf</a>.
module Data.HMAC

-- | Generalized function for creating HMACs on a specified hash function.
hmac :: HashMethod -> [Octet] -> [Octet] -> [Octet]

-- | Compute an HMAC using SHA-1 as the underlying hash function.
hmac_sha1 :: [Octet] -> [Octet] -> [Octet]

-- | Compute an HMAC using MD5 as the underlying hash function.
hmac_md5 :: [Octet] -> [Octet] -> [Octet]

-- | HMAC works over any hash function, which is represented by HashMethod.
--   A hash function and input block size must be specified.
data HashMethod
HashMethod :: ([Octet] -> [Octet]) -> Int -> HashMethod

-- | An arbitrary hash function
digest :: HashMethod -> [Octet] -> [Octet]

-- | Bit size of an input block to the hash function
input_blocksize :: HashMethod -> Int

module Codec.Binary.BubbleBabble

-- | Encode binary data into the bubble babble human readable encoding.
--   Bubble Babble is an encoding that represents binary data as
--   psuedowords which are more pronouncable and memorable than standard
--   hexadecimal encoding.
--   
--   It is mainly used for representing cryptographic fingerprints. In
--   addition, there is an amount of redundancy and error correction built
--   into the representation so that transcription errors can be more
--   readily identified.
--   
--   see: http:<i></i>en.wikipedia.org<i>wiki</i>Bubble_Babble
encode :: [Octet] -> String
