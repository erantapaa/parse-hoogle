-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | hsc3 re-writing
--   
--   hsc3 re-writing
@package hsc3-rw
@version 0.15


-- | Rewrite expressions and modules attaching tags to numeric literals.
module Sound.SC3.RW.Tag

-- | Make <a>Var</a> <a>Exp</a> for <a>String</a>.
--   
--   <pre>
--   mk_var "tag" == Var (UnQual (Ident "tag"))
--   </pre>
mk_var :: String -> Exp

-- | Make <a>String</a> <a>Lit</a>.
--   
--   <pre>
--   mk_str_lit "c1" == Lit (String "c1")
--   </pre>
mk_str_lit :: String -> Exp

-- | Make <a>Int</a> <a>Lit</a>.
mk_int_lit :: Integral n => n -> Exp

-- | Make <a>Frac</a> <a>Lit</a>.
mk_frac_lit :: Real n => n -> Exp

-- | Numeric literal at <a>Exp</a> else <a>Nothing</a>
exp_num_lit :: Exp -> Maybe Literal

-- | Tag an <a>Exp</a> with <a>String</a>.
tag_exp :: String -> Exp -> Exp

-- | Apply <i>f</i> at <a>Exp</a> <i>e</i> if it is tagged, else <i>g</i>.
--   If the tag is within a <a>Paren</a> then it is discarded.
at_tagged :: (String -> Exp -> Exp) -> (Exp -> Exp) -> Exp -> Exp

-- | Inverse of <a>tag_exp</a>.
--   
--   <pre>
--   let z = mk_int_lit (0::Integer)
--   in untag_exp (Paren (tag_exp "c1" z)) == z
--   </pre>
untag_exp :: Exp -> Exp

-- | Empty source location.
nil_src_loc :: SrcLoc
mk_span_id :: String -> [Exp] -> Exp
tag_to_span :: Exp -> Exp

-- | Variant of <a>tag_exp</a> that derives the the tag name using a
--   <tt>State</tt> counter.
tag_exp_auto :: Exp -> State Int Exp
span_exp_auto :: Exp -> State Int Exp

-- | Apply <i>f</i> at numeric literals, else <i>g</i>.
at_num_lit :: (Exp -> t) -> (Exp -> t) -> Exp -> t

-- | <a>at_num_lit</a> of <a>tag_exp_auto</a>.
tag_num_lit :: Exp -> State Int Exp

-- | <a>at_num_lit</a> of <a>tag_exp_auto</a>.
span_num_lit :: Exp -> State Int Exp
type Parser r = String -> ParseResult r
type RW t m a = t -> m a
type RW_st t a = t -> State Int a
type Tr = String -> String
type Tr_m m = String -> m String
type RW_Opt = (PPLayout, Int)

-- | Parse <a>String</a> using <a>Parser</a> and apply <a>RW</a>.
apply_rw :: (Monad m, Pretty a) => RW_Opt -> Parser t -> RW t m a -> Tr_m m
apply_rw_pure :: Pretty a => RW_Opt -> Parser t -> (t -> a) -> Tr
apply_rw_st :: Pretty a => RW_Opt -> Parser t -> RW_st t a -> Tr

-- | Rewrite <a>Exp</a>.
--   
--   <pre>
--   let r = "sinOsc AR (tag \"c1\" 440) (tag \"c2\" 0) * tag \"c3\" 0.1"
--   in exp_rw "sinOsc AR 440 0 * 0.1" == r
--   </pre>
exp_rw :: String -> String

-- | Rewrite <a>Module</a>.
--   
--   <pre>
--   let m = ["import Sound.SC3"
--           ,"o = sinOsc AR (midiCPS 65.00) 0.00"
--           ,"a = dbAmp (-12.00)"
--           ,"main = audition (out 0.00 (o * a))"]
--   in module_rw (unlines m)
--   </pre>
module_rw :: String -> String

-- | Inverse of <a>exp_rw</a>.
exp_un_rw :: String -> String

-- | <a>RW_Opt</a> for html. The <i>span</i> code generates long lines...
rw_html_opt :: RW_Opt

-- | Transform re-written form to <tt>HTML</tt>.
--   
--   <pre>
--   let e = "sinOsc AR 440 0 * 0.1"
--   in exp_rw_html (exp_rw e)
--   </pre>
exp_rw_html :: String -> String

-- | <a>Module</a> variant of <a>exp_rw_html</a>.
--   
--   <pre>
--   let m = "o = sinOsc AR 440 0 * 0.1\nmain = audition (out 0 o)"
--   in module_rw_html (module_rw m)
--   </pre>
module_rw_html :: String -> String
exp_html :: String -> String
module_html :: String -> String
html_framework :: String -> String -> String


-- | Rewriter for <tt>psynth</tt> directives and related functions.
module Sound.SC3.RW.PSynth

-- | A SynthDef parameter.
type Param = (String, Double)

-- | Name of <tt>SynthDef</tt> and associated <a>Param</a>.
type PSynth = (String, [Param])

-- | Printer for control and trigger parameters.
--   
--   <pre>
--   map param_pp [("freq",440),("t_gate",1)]
--   </pre>
param_pp :: Param -> String
add_braces :: String -> String
params_pp :: [Param] -> String
uparam_pp :: [Param] -> String
psynth_pp :: PSynth -> String
type P a = ParsecT String () Identity a
promote :: Either Integer Double -> Double
assign :: P Param
param_list :: P [Param]
uparam :: P [Param]
psynth :: P PSynth

-- | Parse <a>PSynth</a> pre-amble.
--   
--   <pre>
--   parse_psynth "gr = psynth {freq = 440,phase = 0,amp = 0.1,loc = 0} where"
--   </pre>
parse_psynth :: String -> PSynth

-- | Rewrite <a>PSynth</a> pre-amble.
--   
--   <pre>
--   rewrite_psynth "gr = psynth {freq = 440,phase = 0,amp = 0.1,loc = 0} where"
--   </pre>
rewrite_psynth :: String -> String
parse_param_list :: String -> [Param]

-- | Rewrite plaine <a>Param</a> list, ie. SC3 argument list.
--   
--   <pre>
--   rewrite_param_list "freq=440,amp=0.1,t_gate=1"
--   </pre>
rewrite_param_list :: String -> String
parse_uparam :: String -> [Param]
rewrite_uparam :: String -> String
lexer :: GenTokenParser String u Identity
braces :: P a -> P a
identifier :: P String
symbol :: String -> P String
naturalOrFloat :: P (Either Integer Double)
equals :: P String
comma :: P String
semi :: P String
begins_psynth :: String -> Bool
ends_psynth :: String -> Bool
psynth_rewrite :: [String] -> [String]

-- | Arguments as required by <tt>ghc -F -pgmF</tt>.
psynth_rewrite_ghcF :: IO ()

-- | Rewrite uparam pre-amble.
--   
--   <pre>
--   uparam_rewrite "    let uparam = {amp = 0.1, freq = 129.897, rise = 0.1, fall = 0.5}"
--   </pre>
uparam_rewrite :: String -> String

-- | Arguments as required by <tt>ghc -F -pgmF</tt>.
uparam_rewrite_ghcF :: IO ()


-- | Rewrite character identifiers for <tt>UGen.ID</tt> graphs.
module Sound.SC3.RW.ID

-- | Table of greek letters (upper-case,lower-case,name).
--   
--   <pre>
--   length greek_letters == 24
--   (['
--   </pre>
greek_letters :: [(Char, Char, String)]

-- | Indefinite sequence of character identifiers.
type Name_Supply = [Char]

-- | <a>greek_letters</a> as <a>Name_Supply</a>.
--   
--   <pre>
--   take 4 greek_letters_nm == ['
--   </pre>
greek_letters_nm :: Name_Supply

-- | Rewrite each haskell <i>letter</i> character literal at string
--   <i>l</i> with values from the character supply <i>s</i>.
--   
--   <pre>
--   rewrite ['
--   </pre>
rewrite :: Name_Supply -> String -> String

-- | <a>rewrite</a> <a>greek_letters_nm</a>.
--   
--   <pre>
--   hsc3_id_rewrite "'a','.','a'" == "'
--   </pre>
hsc3_id_rewrite :: String -> String
hsc3_id_clear :: String -> String

-- | File based (haskell pre-processor) variant of <a>hsc3_id_rewrite</a>.
hsc3_id_rewrite_preprocessor :: FilePath -> FilePath -> FilePath -> IO ()

-- | File based (inplace) variant of <a>hsc3_id_rewrite</a>. Copies file to
--   <tt>~</tt> suffix and replaces initial file.
--   
--   <pre>
--   let fn = "/home/rohan/sw/hsc3-graphs/gr/resonant-dust.hs"
--   in hsc3_id_rewrite_file fn
--   </pre>
hsc3_id_rewrite_inplace :: FilePath -> IO ()

module Sound.SC3.RW.HP.Polyparse
type Binding = (String, String)
type Name_Supply = [String]
type HP_Char = (Char, Maybe Int)
type HP_String = [HP_Char]
type ST = (Int, [Int])
type HP = Parser ST Char
hp_st :: ST
safe_head :: [a] -> Maybe a

-- | Only count parens in #().
hp_next :: HP (Char, Maybe Int)
hp_hash_paren :: HP HP_String
hp_parse :: String -> HP_String

-- | Left biased <a>max</a> variant.
--   
--   <pre>
--   max_by last "cat" "mouse" == "cat"
--   max_by last "aa" "za" == "aa"
--   </pre>
max_by :: Ord a => (t -> a) -> t -> t -> t
replace_first :: Eq a => a -> a -> [a] -> [a]
un_hash_paren :: String -> String
hp_next_binding :: Name_Supply -> HP_String -> Maybe (Name_Supply, Binding, HP_String)
hp_print :: HP_String -> String

module Sound.SC3.RW.HP.Parsec
data HP
S :: String -> HP
H :: HP -> HP
J :: HP -> HP -> HP
type Binding = (String, String)
type Name_Supply = [String]

-- | Simplifying constructor (do not use <a>J</a> directly).
hp_cons :: HP -> HP -> HP
from_list1 :: [HP] -> HP
hp_parser :: Parser HP
hp_parse :: String -> HP
hp_print :: HP -> String
hp_simplify :: HP -> HP
next_nm :: Name_Supply -> (String, Name_Supply)
hp_find_next_binding :: Name_Supply -> HP -> Maybe (Name_Supply, Binding)
hp_replace :: Binding -> HP -> HP
hp_do_next_binding :: Name_Supply -> HP -> Maybe (Name_Supply, Binding, HP)
instance Eq HP
instance Show HP


-- | Hash parentheses. A simple minded haskell pre-processor that extends
--   the haskell <i>do</i> syntax by rewriting <tt>#</tt> parenthesised
--   elements of a right hand side expression as monadic bindings. The
--   basic pre-processor is <a>hp_rewrite</a>.
module Sound.SC3.RW.HP

-- | Return indentation of line.
--   
--   <pre>
--   indent_of "  a &lt;- b" == "  "
--   </pre>
indent_of :: String -> String

-- | Delete indentation of line.
--   
--   <pre>
--   remove_indent "  a &lt;- b"  == "a &lt;- b"
--   </pre>
remove_indent :: String -> String

-- | Variant of <tt>splitOn</tt> requiring one match only.
--   
--   <pre>
--   split_on_1 " &lt;- " "  a &lt;- f #(b) #(c)" == Just ("  a","f #(b) #(c)")
--   split_on_1 " do " "  let a = do f #(b) #(c)" == Just ("  let a =","f #(b) #(c)")
--   </pre>
split_on_1 :: Eq a => [a] -> [a] -> Maybe ([a], [a])

-- | Split inline <i>do</i> line into separate lines.
--   
--   <pre>
--   let r = ["  let a = do "
--           ,"             f #(b) #(c)"]
--   in hp_remove_inline_do "  let a = do f #(b) #(c)" == r
--   </pre>
hp_remove_inline_do :: String -> [String]

-- | Return indent of <i>s</i> if it <a>has_hash_paren</a>.
--   
--   <pre>
--   hp_indent "  a &lt;- f #(b) #(c)" == Just 2
--   </pre>
hp_indent :: String -> Maybe Int

-- | Note which lines are <i>continued</i> hash parenethsis lines.
--   
--   <pre>
--   hp_non_inline ["f = do"
--                 ,"  a #(b)"
--                 ,"    #(c)"
--                 ,"    #(d)"
--                 ,"  p #(q) #(r)"] == [False,False,True,True,False]
--   </pre>
hp_non_inline :: [String] -> [Bool]

-- | Re-layout to put broken <i>hash parenthesis</i> lines onto one line.
--   
--   <pre>
--   let r = ["f = do"
--           ,"  a #(b) #(c) #(d)"
--           ,"  p #(q) #(r)"]
--   in hp_uncontinue ["f = do"
--                    ,"  a #(b)"
--                    ,"    #(c)"
--                    ,"    #(d)"
--                    ,"  p #(q) #(r)"] == r
--   </pre>
hp_uncontinue :: [String] -> [String]

-- | Name supply for introduced variables.
--   
--   <pre>
--   hp_names !! 9 == "_hp_9"
--   </pre>
hp_names :: Name_Supply

-- | Does <i>s</i> have a <i>hash parenthesis</i> expression.
--   
--   <pre>
--   has_hash_paren "  a &lt;- f #(b) #(c)" == True
--   </pre>
has_hash_paren :: String -> Bool

-- | Process one line of <i>hash-parenthesis</i> re-writes.
hp_analyse :: Name_Supply -> String -> (Name_Supply, ([Binding], HP))

-- | Variant of <a>hp_analyse</a> for examining intermediate state.
--   
--   <pre>
--   let r = ([("_hp_0","b"),("_hp_1","c (d e)")],"  a &lt;- f _hp_0 _hp_1")
--   in hp_analyse' hp_names "  a &lt;- f #(b) #(c (d e))" == r
--   </pre>
--   
--   <pre>
--   let r = ([("_hp_0","a")],"  return (f _hp_0)")
--   in hp_analyse' hp_names "  return (f #(a))" == r
--   </pre>
--   
--   <pre>
--   let r = ([("_hp_0","a"),("_hp_1","d e"),("_hp_2","c _hp_1 f"),("_hp_3","b _hp_2 g")]
--           ,"c &lt;- f (_hp_0,_hp_3) h")
--   in hp_analyse' hp_names "c &lt;- f (#(a),#(b #(c #(d e) f) g)) h" == r
--   </pre>
--   
--   <pre>
--   let r = ([("_hp_0","v w")],"  return (h (_hp_0 * 2))")
--   in hp_analyse' hp_names "  return (h (#(v w) * 2))" == r
--   </pre>
hp_analyse' :: Name_Supply -> String -> ([Binding], String)

-- | Re-construct <a>hp_analyse</a> output.
hp_build :: ([Binding], HP) -> [String]

-- | Process a line for <i>hash parentheses</i>.
hp_process :: Name_Supply -> String -> (Name_Supply, [String])

-- | Run <i>hash parenthesis</i> rewriter.
--   
--   <pre>
--   let {i = ["main = do"
--            ,"  let a = f #(b) (#(c) * 2)"
--            ,"  d &lt;- e"
--            ,"  p &lt;- g #(q r)"
--            ,"         #(s #(t u))"
--            ,"  return (h (#(v w) * 2))"]
--       ;r = ["main = do"
--            ,"  _hp_0 &lt;- b"
--            ,"  _hp_1 &lt;- c"
--            ,"  let a = f _hp_0 (_hp_1 * 2)"
--            ,"  d &lt;- e"
--            ,"  _hp_2 &lt;- q r"
--            ,"  _hp_3 &lt;- t u"
--            ,"  _hp_4 &lt;- s _hp_3"
--            ,"  p &lt;- g _hp_2 _hp_4"
--            ,"  _hp_5 &lt;- v w"
--            ,"  return (h (_hp_5 * 2))"]}
--   in hp_rewrite i == r
--   </pre>
hp_rewrite :: [String] -> [String]

-- | Arguments as required by <tt>ghc -F -pgmF</tt>.
hp_rewrite_ghcF :: IO ()


-- | Hash at-sign. A simple minded haskell pre-processor that extends the
--   haskell syntax by rewriting <tt>#@</tt> sequences with a string
--   indicating the line and column number of the occurence. The basic
--   pre-processor is <a>ha_rewrite</a>.
module Sound.SC3.RW.HA

-- | Find next <i>hash-at</i>, if there is one.
--   
--   <pre>
--   ha_split 0 "let o = sinOsc AR (rand #@ 220 440) 0 * 0.1"
--   </pre>
ha_split :: Integer -> String -> (Integer, String, String)

-- | Generate replacement for <i>hash-at</i> given line and column numbers.
--   
--   <pre>
--   ha_insert 14 23 == "(hash \"14:21\")"
--   </pre>
ha_insert :: Integer -> Integer -> String

-- | Process line given line number.
--   
--   <pre>
--   putStrLn$ha_process_ln 1 "let o = sinOsc AR (rand #@ 220 440) (rand2 #@ pi) * 0.1"
--   </pre>
ha_process_ln :: Integer -> String -> String

-- | Re-write lines, starting at <tt>1</tt>.
ha_rewrite :: [String] -> [String]

-- | Arguments as required by <tt>ghc -F -pgmF</tt>.
ha_rewrite_ghcF :: IO ()
