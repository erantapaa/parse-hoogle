-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | realtime resource handling with manual concurrency
--   
@package future-resource
@version 0.4.0.0


-- | Similar to async package, however, suitable for manual threading and
--   go without exceptions.
module Control.Future
data Progress a b
Making :: Progress a b
Fixme :: a -> Progress a b
Finished :: b -> Progress a b

-- | Two kinds of future is possible: (i) A pile of failures (Monoid a) and
--   (ii) Successful result b.
newtype Future a b
Future :: IO (Progress a b) -> Future a b
runFuture :: Future a b -> IO (Progress a b)
type Future' = Future [String]

-- | Wait until future comes, and modify failure history.
desire :: MonadIO m => Future a b -> (a -> IO b) -> m b

-- | Just wait for the future honestly.
waitFor :: MonadIO m => Future a b -> m (Progress a b)

-- | Return <a>Just</a> when it is time. The history may be modified.
maybeChance :: MonadIO m => Future a b -> (a -> IO b) -> m (Maybe b)

-- | If it is too early, immediately returns <a>Making</a>.
getProgress :: MonadIO m => Future a b -> m (Progress a b)

-- | <pre>
--   mkFuture $ \updateProgress -&gt; forkIO (doSth &gt;&gt;= updateProgress)
--   </pre>
mkFuture :: MonadIO m => ((Progress a b -> IO ()) -> IO ()) -> m (Future a b)

-- | Run <a>Future</a> action immediately.
expect :: Show a => Future a b -> IO b
instance Functor (Progress a)
instance (Show a, Show b) => Show (Progress a b)
instance Monoid a => Monad (Future a)
instance Monoid a => Alternative (Future a)
instance Monoid a => Applicative (Future a)
instance Functor (Future a)
