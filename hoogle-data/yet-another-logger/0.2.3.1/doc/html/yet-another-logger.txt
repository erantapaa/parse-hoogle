-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Yet Another Logger
--   
@package yet-another-logger
@version 0.2.3.1


module System.Logger.Internal.Queue
class BoundedCloseableQueue q a | q -> a
newQueue :: BoundedCloseableQueue q a => Natural -> IO q
closeQueue :: BoundedCloseableQueue q a => q -> IO ()
writeQueue :: BoundedCloseableQueue q a => q -> a -> IO Bool
tryWriteQueue :: BoundedCloseableQueue q a => q -> a -> IO (Maybe Bool)
readQueue :: BoundedCloseableQueue q a => q -> IO (Maybe a)
data FairTBMQueue α

-- | <tt>TBMQueue</tt> is an abstract type representing a bounded closeable
--   FIFO queue.
data TBMQueue a :: * -> *

-- | <tt>TBMChan</tt> is an abstract type representing a bounded closeable
--   FIFO channel.
data TBMChan a :: * -> *
instance BoundedCloseableQueue (FairTBMQueue a) a
instance BoundedCloseableQueue (TBMChan a) a
instance BoundedCloseableQueue (TBMQueue a) a


module System.Logger.Internal
sshow :: (Show a, IsString b) => a -> b

-- | Format <a>TimeSpec</a> as ISO8601 date-time string with the given
--   sub-second precision.
--   
--   @since 0.2
formatIso8601 :: IsString a => Natural -> TimeSpec -> a

-- | Format <a>TimeSpec</a> as ISO8601 date-time string with milliseconds
--   precision.
--   
--   @since 0.2
formatIso8601Milli :: IsString a => TimeSpec -> a

-- | Format <a>TimeSpec</a> as ISO8601 date-time string with microseconds
--   precision.
--   
--   @since 0.2
formatIso8601Micro :: IsString a => TimeSpec -> a

-- | Convert a <a>TimeSpec</a> value into <a>UTCTime</a>
--   
--   @since 0.2
timeSpecToUtc :: TimeSpec -> UTCTime


-- | An option that indicates whether ANSI color escapes shall be used in
--   textual output.
module System.Logger.Backend.ColorOption

-- | Color Option
data ColorOption
ColorAuto :: ColorOption
ColorFalse :: ColorOption
ColorTrue :: ColorOption
readColorOption :: (Monad m, Eq a, Show a, FoldCase a, IsString a, IsString e, Monoid e, MonadError e m) => a -> m ColorOption
colorOptionText :: IsString a => ColorOption -> a
defaultColorOption :: ColorOption
pColorOption :: Parser ColorOption

-- | A version of <a>pColorOption</a> that takes a prefix for the command
--   line option.
--   
--   @since 0.2
pColorOption_ :: Text -> Parser ColorOption
useColor :: ColorOption -> Handle -> IO Bool
instance Typeable ColorOption
instance Show ColorOption
instance Read ColorOption
instance Eq ColorOption
instance Ord ColorOption
instance Enum ColorOption
instance Bounded ColorOption
instance Generic ColorOption
instance Datatype D1ColorOption
instance Constructor C1_0ColorOption
instance Constructor C1_1ColorOption
instance Constructor C1_2ColorOption
instance FromJSON ColorOption
instance ToJSON ColorOption
instance NFData ColorOption


module System.Logger.Types
data LogLevel
Quiet :: LogLevel
Error :: LogLevel
Warn :: LogLevel
Info :: LogLevel
Debug :: LogLevel
logLevelText :: IsString a => LogLevel -> a
readLogLevel :: (MonadError e m, Eq a, Show a, FoldCase a, IsString a, IsString e, Monoid e) => a -> m LogLevel
pLogLevel :: Parser LogLevel

-- | A version of <a>pLogLevel</a> that takes a prefix for the command line
--   option.
--   
--   @since 0.2
pLogLevel_ :: Text -> Parser LogLevel

-- | Policy that determines how the case of a congested logging pipeline is
--   addressed.
data LogPolicy
LogPolicyDiscard :: LogPolicy
LogPolicyRaise :: LogPolicy
LogPolicyBlock :: LogPolicy
logPolicyText :: IsString s => LogPolicy -> s
readLogPolicy :: (MonadError e m, Eq a, Show a, FoldCase a, IsText a, IsString e, Monoid e) => a -> m LogPolicy
pLogPolicy :: Parser LogPolicy

-- | A version of <a>pLogPolicy</a> that takes a prefix for the command
--   line option.
--   
--   @since 0.2
pLogPolicy_ :: Text -> Parser LogPolicy
type LogLabel = (Text, Text)
type LogScope = [LogLabel]

-- | Exceptions that are thrown by the logger
--   
--   <ul>
--   <li><i><a>QueueFullException</a></i> thrown when the queue is full and
--   the logger policy is set to throw exceptions on a full queue</li>
--   <li><i><a>BackendTerminatedException</a></i> a backend can throw this
--   exception to force the logger immediately</li>
--   <li><i><a>BackendTooManyExceptions</a></i> thrown when the backend has
--   thrown unexpected exceptions more than
--   <tt>loggerConfigExceptionLimit</tt> times</li>
--   </ul>
--   
--   @since 0.2
data LoggerException a
QueueFullException :: LogMessage a -> LoggerException a
BackendTerminatedException :: SomeException -> LoggerException Void
BackendTooManyExceptions :: [SomeException] -> LoggerException Void

-- | The Internal log message type.
--   
--   The type parameter <tt>a</tt> is expected to provide intances of
--   <a>Show</a>, <a>Typeable</a>, and <a>NFData</a>.
--   
--   If we need to support different backends, we may consider including
--   the backend here...
data LogMessage a
LogMessage :: !a -> !LogLevel -> !LogScope -> !TimeSpec -> LogMessage a
_logMsg :: LogMessage a -> !a
_logMsgLevel :: LogMessage a -> !LogLevel

-- | efficiency of this depends on whether this is shared between log
--   messsages. Usually this should be just a pointer to a shared list.
_logMsgScope :: LogMessage a -> !LogScope

-- | a POSIX timestamp
--   
--   UTC seconds elapsed since UNIX Epoch as returned by
--   <tt>clock_gettime</tt> on the respective system. NOTE that POSIX is
--   ambigious with regard to treatment of leap seconds, and some
--   implementations may actually return TAI.
--   
--   @since 0.2
_logMsgTime :: LogMessage a -> !TimeSpec
logMsg :: Lens (LogMessage a) (LogMessage b) a b
logMsgLevel :: Lens' (LogMessage a) LogLevel
logMsgScope :: Lens' (LogMessage a) LogScope

-- | @since 0.2
logMsgTime :: Lens' (LogMessage a) TimeSpec

-- | This is given to logger when it is created. It formats and delivers
--   individual log messages synchronously. The backend is called once for
--   each log message (that meets the required log level).
--   
--   The type parameter <tt>a</tt> is expected to provide instances for
--   <a>Show</a> <a>Typeable</a>, and <a>NFData</a>.
--   
--   The <a>Left</a> values of the argument allows the generation of log
--   messages that are independent of the parameter <tt>a</tt>. The
--   motivation for this is reporting issues in Logging system itself, like
--   a full logger queue or providing statistics about the fill level of
--   the queue. There may be other uses of this, too.
--   
--   Backends that can fail are encouraged (but not forced) to take into
--   account the <a>LogPolicy</a> that is effective for a message. For
--   instance, a backend may implement a reasonable retry logic for each
--   message and then raise a <a>BackendTerminatedException</a> in case the
--   policy is <a>LogPolicyBlock</a> or <a>LogPolicyRaise</a> (thus causing
--   the logger to exit immediately) and raise some other exception
--   otherwise (thus discarding the message without causing the logger to
--   not exit immediately). In addition a backend might retry harder in
--   case of <a>LogPolicyBlock</a>.
--   
--   TODO there may be scenarios where chunked processing is beneficial.
--   While this can be done in a closure of this function, more direct
--   support might be desirable.
type LoggerBackend a = Either (LogMessage Text) (LogMessage a) -> IO ()
type LogFunction a m = LogLevel -> a -> m ()

-- | This function is provided by the logger.
type LogFunctionIO a = LogLevel -> a -> IO ()

-- | Abstraction of a logger context that can be used without dependening
--   on a specific monadic context.
--   
--   The <a>loggerFunIO</a> incorporates a <a>LoggerBackend</a>. An
--   instance of a <a>LoggerCtx</a> is free to use a hard coded
--   <a>LoggerBackend</a> or to be usable with different
--   <a>LoggerBackend</a> functions. The latter is recommended but not
--   required.
--   
--   You don't have to provide an instance of this for your logger. Instead
--   you may just provide an instance of <a>MonadLog</a> directly.
--   
--   If this doesn't fit your needs you may use a newtype wrapper and
--   define your own instances.
class LoggerCtx ctx msg | ctx -> msg where withLoggerLevel level ctx f = f $ ctx & setLoggerLevel .~ level withLoggerLabel label ctx f = f $ ctx & setLoggerScope %~ (:) label withLoggerPolicy policy ctx f = f $ ctx & setLoggerPolicy .~ policy
loggerFunIO :: (LoggerCtx ctx msg, Show msg, Typeable msg, NFData msg) => ctx -> LogFunctionIO msg
setLoggerLevel :: LoggerCtx ctx msg => Setter' ctx LogLevel
setLoggerScope :: LoggerCtx ctx msg => Setter' ctx LogScope
setLoggerPolicy :: LoggerCtx ctx msg => Setter' ctx LogPolicy
withLoggerLevel :: LoggerCtx ctx msg => LogLevel -> ctx -> (ctx -> α) -> α
withLoggerLabel :: LoggerCtx ctx msg => LogLabel -> ctx -> (ctx -> α) -> α
withLoggerPolicy :: LoggerCtx ctx msg => LogPolicy -> ctx -> (ctx -> α) -> α
data LoggerCtxT ctx m α
runLoggerCtxT :: LoggerCtxT ctx m α -> ctx -> m α
class Monad m => MonadLog a m | m -> a
logg :: MonadLog a m => LogFunction a m
withLevel :: MonadLog a m => LogLevel -> m α -> m α
withPolicy :: MonadLog a m => LogPolicy -> m α -> m α
localScope :: MonadLog a m => (LogScope -> LogScope) -> m α -> m α

-- | Append a <a>LogLabel</a> to the current <a>LogScope</a> when executing
--   the inner computation. The <a>LogScope</a> of the outer computation is
--   unchanged.
--   
--   @since 0.1
withLabel :: MonadLog a m => LogLabel -> m α -> m α

-- | Executing the inner computation with an empty <a>LogScope</a>. The
--   <a>LogScope</a> of the outer computation is unchanged.
--   
--   @since 0.1
clearScope :: MonadLog a m => m α -> m α

-- | Remove the last <a>LogLabel</a> from the current <a>LogScope</a> when
--   executing the inner computation. The <a>LogScope</a> of the outer
--   computation is unchanged.
--   
--   @since 0.1
popLabel :: MonadLog a m => m α -> m α
instance Typeable LogLevel
instance Typeable LogPolicy
instance Typeable LogMessage
instance Typeable LoggerException
instance Show a => Show (LoggerException a)
instance Show LogLevel
instance Read LogLevel
instance Eq LogLevel
instance Ord LogLevel
instance Enum LogLevel
instance Bounded LogLevel
instance Generic LogLevel
instance Show LogPolicy
instance Read LogPolicy
instance Eq LogPolicy
instance Ord LogPolicy
instance Bounded LogPolicy
instance Enum LogPolicy
instance Generic LogPolicy
instance Show a => Show (LogMessage a)
instance Read a => Read (LogMessage a)
instance Eq a => Eq (LogMessage a)
instance Ord a => Ord (LogMessage a)
instance Generic (LogMessage a)
instance Functor m => Functor (LoggerCtxT ctx m)
instance Applicative m => Applicative (LoggerCtxT ctx m)
instance Monad m => Monad (LoggerCtxT ctx m)
instance MonadIO m => MonadIO (LoggerCtxT ctx m)
instance MonadTrans (LoggerCtxT ctx)
instance Monad m => MonadReader ctx (LoggerCtxT ctx m)
instance MonadError a m => MonadError a (LoggerCtxT ctx m)
instance MonadState a m => MonadState a (LoggerCtxT ctx m)
instance MonadWriter a m => MonadWriter a (LoggerCtxT ctx m)
instance MonadBase a m => MonadBase a (LoggerCtxT ctx m)
instance MonadTrace t m => MonadTrace t (LoggerCtxT ctx m)
instance Datatype D1LogLevel
instance Constructor C1_0LogLevel
instance Constructor C1_1LogLevel
instance Constructor C1_2LogLevel
instance Constructor C1_3LogLevel
instance Constructor C1_4LogLevel
instance Datatype D1LogPolicy
instance Constructor C1_0LogPolicy
instance Constructor C1_1LogPolicy
instance Constructor C1_2LogPolicy
instance Datatype D1LogMessage
instance Constructor C1_0LogMessage
instance Selector S1_0_0LogMessage
instance Selector S1_0_1LogMessage
instance Selector S1_0_2LogMessage
instance Selector S1_0_3LogMessage
instance (Show a, Typeable a, NFData a, MonadIO m, LoggerCtx ctx a) => MonadLog a (LoggerCtxT ctx m)
instance MonadBaseControl b m => MonadBaseControl b (LoggerCtxT ctx m)
instance MonadTransControl (LoggerCtxT ctx)
instance MonadLog a m => MonadLog a (EitherT σ m)
instance MonadLog a m => MonadLog a (TraceT t e m)
instance MonadLog a m => MonadLog a (StateT σ m)
instance MonadLog a m => MonadLog a (ExceptT ε m)
instance (Monoid σ, MonadLog a m) => MonadLog a (WriterT σ m)
instance NFData a => NFData (LogMessage a)
instance NFData TimeSpec
instance (Typeable a, Show a) => Exception (LoggerException a)
instance FromJSON LogPolicy
instance ToJSON LogPolicy
instance NFData LogPolicy
instance FromJSON LogLevel
instance ToJSON LogLevel
instance NFData LogLevel


module System.Logger.Backend.Handle
data LoggerHandleConfig
StdOut :: LoggerHandleConfig
StdErr :: LoggerHandleConfig
FileHandle :: FilePath -> LoggerHandleConfig
loggerHandleConfigText :: (IsString a, Monoid a) => LoggerHandleConfig -> a
readLoggerHandleConfig :: (MonadError e m, Eq a, Show a, FoldCase a, IsText a, IsString e, Monoid e) => a -> m LoggerHandleConfig
validateLoggerHandleConfig :: ConfigValidation LoggerHandleConfig λ
pLoggerHandleConfig :: Parser LoggerHandleConfig

-- | A version of <a>pLoggerHandleConfig</a> that takes a prefix for the
--   command line option.
--   
--   @since 0.2
pLoggerHandleConfig_ :: Text -> Parser LoggerHandleConfig

-- | HandleBackendConfig
data HandleBackendConfig
HandleBackendConfig :: !ColorOption -> !LoggerHandleConfig -> HandleBackendConfig
_handleBackendConfigColor :: HandleBackendConfig -> !ColorOption
_handleBackendConfigHandle :: HandleBackendConfig -> !LoggerHandleConfig
handleBackendConfigHandle :: Lens' HandleBackendConfig LoggerHandleConfig
handleBackendConfigColor :: Lens' HandleBackendConfig ColorOption
defaultHandleBackendConfig :: HandleBackendConfig
validateHandleBackendConfig :: ConfigValidation HandleBackendConfig []
pHandleBackendConfig :: MParser HandleBackendConfig

-- | A version of <tt>pLoggerHandleBackendConfig</tt> that takes a prefix
--   for the command line option.
--   
--   @since 0.2
pHandleBackendConfig_ :: Text -> MParser HandleBackendConfig
withHandleBackend :: (MonadIO m, MonadBaseControl IO m) => HandleBackendConfig -> (LoggerBackend Text -> m α) -> m α

-- | A version of <a>withHandleBackend</a> that is generic in the type of
--   the log message.
--   
--   @since 0.2.2
withHandleBackend_ :: (MonadIO m, MonadBaseControl IO m) => (msg -> Text) -> HandleBackendConfig -> (LoggerBackend msg -> m α) -> m α
handleBackend :: Handle -> Bool -> LoggerBackend Text

-- | A version of <a>handleBackend</a> that is generic in the type of the
--   log message.
--   
--   @since 0.2.2
handleBackend_ :: (msg -> Text) -> Handle -> Bool -> LoggerBackend msg
instance Typeable LoggerHandleConfig
instance Typeable HandleBackendConfig
instance Show LoggerHandleConfig
instance Read LoggerHandleConfig
instance Eq LoggerHandleConfig
instance Ord LoggerHandleConfig
instance Generic LoggerHandleConfig
instance Show HandleBackendConfig
instance Read HandleBackendConfig
instance Eq HandleBackendConfig
instance Ord HandleBackendConfig
instance Generic HandleBackendConfig
instance Datatype D1LoggerHandleConfig
instance Constructor C1_0LoggerHandleConfig
instance Constructor C1_1LoggerHandleConfig
instance Constructor C1_2LoggerHandleConfig
instance Datatype D1HandleBackendConfig
instance Constructor C1_0HandleBackendConfig
instance Selector S1_0_0HandleBackendConfig
instance Selector S1_0_1HandleBackendConfig
instance FromJSON (HandleBackendConfig -> HandleBackendConfig)
instance ToJSON HandleBackendConfig
instance NFData HandleBackendConfig
instance FromJSON LoggerHandleConfig
instance ToJSON LoggerHandleConfig
instance NFData LoggerHandleConfig


-- | This module provides a logger that implements the logger interface
--   that is defined in <a>System.Logger.Types</a>.
--   
--   If you want to roll your own implementation you may use the code in
--   this module as an example and starting point.
module System.Logger.Logger.Internal

-- | Logger Configuration
data LoggerConfig
LoggerConfig :: !Natural -> !LogLevel -> !LogScope -> !LogPolicy -> !(Maybe Natural) -> !(Maybe Natural) -> !(Maybe Natural) -> LoggerConfig
_loggerConfigQueueSize :: LoggerConfig -> !Natural

-- | initial log threshold, can be changed later on
_loggerConfigThreshold :: LoggerConfig -> !LogLevel

-- | initial stack of log labels, can be extended later on
_loggerConfigScope :: LoggerConfig -> !LogScope

-- | how to deal with a congested logging pipeline
_loggerConfigPolicy :: LoggerConfig -> !LogPolicy

-- | number of consecutive backend exception that can occur before the
--   logger raises an <a>BackendTooManyExceptions</a> exception. If this is
--   <a>Nothing</a> the logger will discard all exceptions. For instance a
--   value of <tt>1</tt> means that an exception is raised when the second
--   exception occurs. A value of <tt>0</tt> means that an exception is
--   raised for each exception.
--   
--   @since 0.2
_loggerConfigExceptionLimit :: LoggerConfig -> !(Maybe Natural)

-- | number of microseconds to wait after an exception from the backend. If
--   this is <a>Nothing</a> the logger won't wait at all after an
--   exception.
--   
--   @since 0.2
_loggerConfigExceptionWait :: LoggerConfig -> !(Maybe Natural)

-- | timeout in microseconds for the logger to flush the queue and deliver
--   all remaining log messages on termination. If this is <a>Nothing</a>
--   termination of the logger blogs until all mesages are delivered.
--   
--   @since 0.2
_loggerConfigExitTimeout :: LoggerConfig -> !(Maybe Natural)
loggerConfigQueueSize :: Lens' LoggerConfig Natural
loggerConfigThreshold :: Lens' LoggerConfig LogLevel
loggerConfigScope :: Lens' LoggerConfig LogScope
loggerConfigPolicy :: Lens' LoggerConfig LogPolicy
loggerConfigExceptionLimit :: Lens' LoggerConfig (Maybe Natural)
loggerConfigExceptionWait :: Lens' LoggerConfig (Maybe Natural)
loggerConfigExitTimeout :: Lens' LoggerConfig (Maybe Natural)

-- | Default Logger configuration
--   
--   The exception limit for backend exceptions is 10 and the wait time
--   between exceptions is 1000. This means that in case of a defunctioned
--   backend the logger will exist by throwing an exception after at least
--   one second. When the logger is terminated it is granted 1 second to
--   flush the queue and deliver all remaining log messages.
defaultLoggerConfig :: LoggerConfig
validateLoggerConfig :: ConfigValidation LoggerConfig λ
pLoggerConfig :: MParser LoggerConfig

-- | A version of <a>pLoggerConfig</a> that takes a prefix for the command
--   line option.
--   
--   @since 0.2
pLoggerConfig_ :: Text -> MParser LoggerConfig
data Logger a
loggerScope :: Lens' (Logger a) LogScope
loggerThreshold :: Lens' (Logger a) LogLevel

-- | Create a new logger. A logger created with this function must be
--   released with a call to <a>releaseLogger</a> and must not be used
--   after it is released.
--   
--   The logger calls the backend function exactly once for each log
--   message. If the backend throws an exception, the message is discarded
--   and the exception is dealt with as follows:
--   
--   <ol>
--   <li>The exception is logged. First it is attempt to log to the backend
--   itself. If that fails, due to another exception, the incident is
--   logged to an alternate log sink, usually <tt>T.putStrLn</tt> or just
--   <tt>const (return ())</tt>.</li>
--   <li>The message is discarded. If the backend exception is of type
--   <a>BackendTerminatedException</a> the exception is rethrown by the
--   logger which causes the logger to exit. Otherwise the exception is
--   appended to the exception list.</li>
--   <li>If the length of the exception list exceeds a configurable
--   threshold a <a>BackendTooManyExceptions</a> exception is thrown (which
--   causes the logger to terminate).</li>
--   <li>Otherwise the logger waits for a configurable amount of time
--   before proceeding.</li>
--   <li>The next time the backend returns without throwing an exception
--   the exception list is reset to <tt>[]</tt>.</li>
--   </ol>
--   
--   Backends are expected to implement there own retry logic if required.
--   Backends may base their behavoir on the <a>LogPolicy</a> that is
--   effective for a given message. Please refer to the documentation of
--   <a>LoggerBackend</a> for more details about how to implement and
--   backend.
--   
--   Backends are called synchronously. Backends authors must thus ensure
--   that a backend returns promptly in accordance with the
--   <a>LogPolicy</a> and the size of the logger queue. For more elaborate
--   failover strategies, such as batching retried messages with the
--   delivery of new messages, backends may implement there only internal
--   queue.
--   
--   Exceptions of type <a>BlockedIndefinitelyOnSTM</a> and
--   <a>NestedAtomically</a> are rethrown immediately. Those exceptions
--   indicate a bug in the code due to unsafe usage of <a>createLogger</a>.
--   This exceptions shouldn't be possible when <a>withLogger</a> is used
--   to provide the logger and the reference to the logger isn't used
--   outside the scope of the bracket.
createLogger :: MonadIO μ => LoggerConfig -> LoggerBackend a -> μ (Logger a)

-- | A version of <a>createLogger</a> that takes as an extra argument a
--   function for logging errors in the logging system.
--   
--   @since 0.2
createLogger_ :: MonadIO μ => (Text -> IO ()) -> LoggerConfig -> LoggerBackend a -> μ (Logger a)
releaseLogger :: MonadIO μ => Logger a -> μ ()

-- | Provide a computation with a <a>Logger</a>.
--   
--   Here is an example how this can be used to run a computation with a
--   <a>MonadLog</a> constraint:
--   
--   <pre>
--   withConsoleLogger
--       ∷ (MonadIO m, MonadBaseControl IO m)
--       ⇒ LogLevel
--       → LoggerT T.Text m α
--       → m α
--   withConsoleLogger level inner = do
--      withHandleBackend (config ^. logConfigBackend) $ \backend →
--          withLogger (config ^. logConfigLogger) backend $ runLoggerT inner
--    where
--      config = defaultLogConfig
--          &amp; logConfigLogger ∘ loggerConfigThreshold .~ level
--   </pre>
--   
--   For detailed information about how backends are executed refer to the
--   documentation of <a>createLogger</a>.
withLogger :: (MonadIO μ, MonadBaseControl IO μ) => LoggerConfig -> LoggerBackend a -> (Logger a -> μ α) -> μ α

-- | A version of <a>withLogger</a> that takes as an extra argument a
--   function for logging errors in the logging system.
--   
--   @since 0.2
withLogger_ :: (MonadIO μ, MonadBaseControl IO μ) => (Text -> IO ()) -> LoggerConfig -> LoggerBackend a -> (Logger a -> μ α) -> μ α
loggCtx :: (Show a, Typeable a, NFData a) => Logger a -> LogFunctionIO a

-- | For simple cases, when the logger threshold and the logger scope is
--   constant this function can be used to directly initialize a log
--   function.
withLogFunction :: (Show a, Typeable a, NFData a, MonadIO μ, MonadBaseControl IO μ) => LoggerConfig -> LoggerBackend a -> (LogFunctionIO a -> μ α) -> μ α

-- | For simple cases, when the logger threshold and the logger scope is
--   constant this function can be used to directly initialize a log
--   function.
--   
--   @since 0.2
withLogFunction_ :: (Show a, Typeable a, NFData a, MonadIO μ, MonadBaseControl IO μ) => (Text -> IO ()) -> LoggerConfig -> LoggerBackend a -> (LogFunctionIO a -> μ α) -> μ α
type LoggerT a = LoggerCtxT (Logger a)
runLoggerT :: LoggerT a m α -> Logger a -> m α

-- | Convenience function that unwraps a <a>MonadLog</a> computation over a
--   newly created <a>Logger</a>
runLogT :: (MonadBaseControl IO m, MonadIO m) => LoggerConfig -> LoggerBackend msg -> LoggerT msg m α -> m α
instance Typeable LoggerConfig
instance Typeable Logger
instance Typeable LoggerKilled
instance Show LoggerConfig
instance Read LoggerConfig
instance Eq LoggerConfig
instance Ord LoggerConfig
instance Generic LoggerConfig
instance Generic (Logger a)
instance Show LoggerKilled
instance Datatype D1LoggerConfig
instance Constructor C1_0LoggerConfig
instance Selector S1_0_0LoggerConfig
instance Selector S1_0_1LoggerConfig
instance Selector S1_0_2LoggerConfig
instance Selector S1_0_3LoggerConfig
instance Selector S1_0_4LoggerConfig
instance Selector S1_0_5LoggerConfig
instance Selector S1_0_6LoggerConfig
instance Datatype D1Logger
instance Constructor C1_0Logger
instance Selector S1_0_0Logger
instance Selector S1_0_1Logger
instance Selector S1_0_2Logger
instance Selector S1_0_3Logger
instance Selector S1_0_4Logger
instance Selector S1_0_5Logger
instance Selector S1_0_6Logger
instance Selector S1_0_7Logger
instance LoggerCtx (Logger a) a
instance Exception LoggerKilled
instance FromJSON (LoggerConfig -> LoggerConfig)
instance ToJSON LoggerConfig
instance NFData LoggerConfig
instance NFData Natural
instance FromJSON Natural
instance ToJSON Natural


-- | This module provides a logger that implements the logger interface
--   that is defined in <a>System.Logger.Types</a>.
--   
--   All the code of this module is in
--   <a>System.Logger.Logger.Internal</a>.
--   
--   The definitions in <a>System.Logger.Types</a> are re-exported by this
--   module.
module System.Logger.Logger
data Logger a

-- | Provide a computation with a <a>Logger</a>.
--   
--   Here is an example how this can be used to run a computation with a
--   <a>MonadLog</a> constraint:
--   
--   <pre>
--   withConsoleLogger
--       ∷ (MonadIO m, MonadBaseControl IO m)
--       ⇒ LogLevel
--       → LoggerT T.Text m α
--       → m α
--   withConsoleLogger level inner = do
--      withHandleBackend (config ^. logConfigBackend) $ \backend →
--          withLogger (config ^. logConfigLogger) backend $ runLoggerT inner
--    where
--      config = defaultLogConfig
--          &amp; logConfigLogger ∘ loggerConfigThreshold .~ level
--   </pre>
--   
--   For detailed information about how backends are executed refer to the
--   documentation of <a>createLogger</a>.
withLogger :: (MonadIO μ, MonadBaseControl IO μ) => LoggerConfig -> LoggerBackend a -> (Logger a -> μ α) -> μ α

-- | A version of <a>withLogger</a> that takes as an extra argument a
--   function for logging errors in the logging system.
--   
--   @since 0.2
withLogger_ :: (MonadIO μ, MonadBaseControl IO μ) => (Text -> IO ()) -> LoggerConfig -> LoggerBackend a -> (Logger a -> μ α) -> μ α

-- | For simple cases, when the logger threshold and the logger scope is
--   constant this function can be used to directly initialize a log
--   function.
withLogFunction :: (Show a, Typeable a, NFData a, MonadIO μ, MonadBaseControl IO μ) => LoggerConfig -> LoggerBackend a -> (LogFunctionIO a -> μ α) -> μ α

-- | For simple cases, when the logger threshold and the logger scope is
--   constant this function can be used to directly initialize a log
--   function.
--   
--   @since 0.2
withLogFunction_ :: (Show a, Typeable a, NFData a, MonadIO μ, MonadBaseControl IO μ) => (Text -> IO ()) -> LoggerConfig -> LoggerBackend a -> (LogFunctionIO a -> μ α) -> μ α
type LoggerT a = LoggerCtxT (Logger a)
runLoggerT :: LoggerT a m α -> Logger a -> m α

-- | Convenience function that unwraps a <a>MonadLog</a> computation over a
--   newly created <a>Logger</a>
runLogT :: (MonadBaseControl IO m, MonadIO m) => LoggerConfig -> LoggerBackend msg -> LoggerT msg m α -> m α

-- | Logger Configuration
data LoggerConfig
LoggerConfig :: !Natural -> !LogLevel -> !LogScope -> !LogPolicy -> !(Maybe Natural) -> !(Maybe Natural) -> !(Maybe Natural) -> LoggerConfig
_loggerConfigQueueSize :: LoggerConfig -> !Natural

-- | initial log threshold, can be changed later on
_loggerConfigThreshold :: LoggerConfig -> !LogLevel

-- | initial stack of log labels, can be extended later on
_loggerConfigScope :: LoggerConfig -> !LogScope

-- | how to deal with a congested logging pipeline
_loggerConfigPolicy :: LoggerConfig -> !LogPolicy

-- | number of consecutive backend exception that can occur before the
--   logger raises an <a>BackendTooManyExceptions</a> exception. If this is
--   <a>Nothing</a> the logger will discard all exceptions. For instance a
--   value of <tt>1</tt> means that an exception is raised when the second
--   exception occurs. A value of <tt>0</tt> means that an exception is
--   raised for each exception.
--   
--   @since 0.2
_loggerConfigExceptionLimit :: LoggerConfig -> !(Maybe Natural)

-- | number of microseconds to wait after an exception from the backend. If
--   this is <a>Nothing</a> the logger won't wait at all after an
--   exception.
--   
--   @since 0.2
_loggerConfigExceptionWait :: LoggerConfig -> !(Maybe Natural)

-- | timeout in microseconds for the logger to flush the queue and deliver
--   all remaining log messages on termination. If this is <a>Nothing</a>
--   termination of the logger blogs until all mesages are delivered.
--   
--   @since 0.2
_loggerConfigExitTimeout :: LoggerConfig -> !(Maybe Natural)
loggerConfigQueueSize :: Lens' LoggerConfig Natural
loggerConfigThreshold :: Lens' LoggerConfig LogLevel
loggerConfigScope :: Lens' LoggerConfig LogScope
loggerConfigPolicy :: Lens' LoggerConfig LogPolicy
loggerConfigExceptionLimit :: Lens' LoggerConfig (Maybe Natural)
loggerConfigExceptionWait :: Lens' LoggerConfig (Maybe Natural)
loggerConfigExitTimeout :: Lens' LoggerConfig (Maybe Natural)

-- | Default Logger configuration
--   
--   The exception limit for backend exceptions is 10 and the wait time
--   between exceptions is 1000. This means that in case of a defunctioned
--   backend the logger will exist by throwing an exception after at least
--   one second. When the logger is terminated it is granted 1 second to
--   flush the queue and deliver all remaining log messages.
defaultLoggerConfig :: LoggerConfig
validateLoggerConfig :: ConfigValidation LoggerConfig λ
pLoggerConfig :: MParser LoggerConfig

-- | A version of <a>pLoggerConfig</a> that takes a prefix for the command
--   line option.
--   
--   @since 0.2
pLoggerConfig_ :: Text -> MParser LoggerConfig


-- | This module re-exports the logger interface from
--   <a>System.Logger.Types</a> and the implementation of that interface
--   from <a>System.Logger.Logger</a> and
--   <a>System.Logger.Backend.Handle</a>.
module System.Logger

-- | A simple console logger
--   
--   <pre>
--   import System.Logger
--   
--   main ∷ IO ()
--   main = withConsoleLogger Info $ do
--       logg Info "moin"
--       withLabel ("function", "f") f
--       logg Warn "tschüss"
--     where
--       f = withLevel Debug $ do
--           logg Debug "debug f"
--   </pre>
withConsoleLogger :: (MonadIO m, MonadBaseControl IO m) => LogLevel -> LoggerT Text m α -> m α

-- | A simple file logger
withFileLogger :: (MonadIO m, MonadBaseControl IO m) => FilePath -> LogLevel -> LoggerT Text m α -> m α
data LogConfig
LogConfig :: !LoggerConfig -> !HandleBackendConfig -> LogConfig
_logConfigLogger :: LogConfig -> !LoggerConfig
_logConfigBackend :: LogConfig -> !HandleBackendConfig
logConfigLogger :: Lens' LogConfig LoggerConfig
logConfigBackend :: Lens' LogConfig HandleBackendConfig
defaultLogConfig :: LogConfig
validateLogConfig :: ConfigValidation LogConfig []
pLogConfig :: MParser LogConfig

-- | A version of <a>pLogConfig</a> that takes a prefix for the command
--   line option.
--   
--   @since 0.2
pLogConfig_ :: Text -> MParser LogConfig
instance Typeable LogConfig
instance Show LogConfig
instance Read LogConfig
instance Eq LogConfig
instance Ord LogConfig
instance Generic LogConfig
instance Datatype D1LogConfig
instance Constructor C1_0LogConfig
instance Selector S1_0_0LogConfig
instance Selector S1_0_1LogConfig
instance FromJSON (LogConfig -> LogConfig)
instance ToJSON LogConfig
