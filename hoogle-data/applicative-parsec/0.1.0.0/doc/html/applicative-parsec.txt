-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An applicative parser combinator library
--   
@package applicative-parsec
@version 0.1.0.0

module Text.Parsec.Applicative.Types
data SourcePos
SourcePos :: Maybe Text -> Integer -> Integer -> SourcePos
spName :: Lens' SourcePos (Maybe Text)
spLine :: Lens' SourcePos Integer
spColumn :: Lens' SourcePos Integer
initialPos :: Maybe Text -> SourcePos
noPos :: SourcePos
class HasSourcePos a
sourcePos :: HasSourcePos a => a -> SourcePos
data WithSourcePos a
WithSourcePos :: a -> SourcePos -> WithSourcePos a
wspValue :: Lens (WithSourcePos a_a76h) (WithSourcePos a_a7JE) a_a76h a_a7JE
wspSourcePos :: Lens' (WithSourcePos a_a76h) SourcePos
data ParseState tt td
psConsumed :: Lens' (ParseState tt_a7JT td_a7JU) Bool
psTokens :: Lens (ParseState tt_a7JT td_a7JU) (ParseState tt_a7ME td_a7MF) [(tt_a7JT, td_a7JU)] [(tt_a7ME, td_a7MF)]
emptyParseState :: HasSourcePos td => [(tt, td)] -> ParseState tt td
instance (Show tt, Show td) => Show (ParseState tt td)
instance HasSourcePos (WithSourcePos a)
instance HasSourcePos SourcePos
instance Eq a => Eq (WithSourcePos a)
instance Ord a => Ord (WithSourcePos a)
instance Show a => Show (WithSourcePos a)
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos

module Text.Parsec.Applicative.Internal
data Parser s tt td a
PEnd :: Parser s tt td ()
PConst :: a -> Parser s tt td a
PToken :: tt -> Parser s tt td (tt, td)
PSkip :: Parser s tt td a -> Parser s tt td b -> Parser s tt td b
PApp :: Parser s tt td (a -> b) -> Parser s tt td a -> Parser s tt td b
PTry :: Parser s tt td a -> Parser s tt td a
PRepeat :: Parser s tt td a -> Parser s tt td [a]
PFail :: Maybe String -> Parser s tt td a
PChoice :: Parser s tt td a -> Parser s tt td a -> Parser s tt td a
PLabel :: s -> Parser s tt td a -> Parser s tt td a
PGetPos :: Parser s tt td SourcePos
parens :: ShowS -> ShowS
listed :: [ShowS] -> ShowS
map1 :: (a -> a) -> [a] -> [a]
eof :: Parser s tt td ()
token :: Eq tt => tt -> Parser s tt td (tt, td)
try :: Parser s tt td a -> Parser s tt td a
label :: s -> Parser s tt td a -> Parser s tt td a
data ParseErrorType
EUnexpected :: ParseErrorType
EEnd :: ParseErrorType
ENotEnd :: ParseErrorType
data ParseError
ParseError :: Maybe ParseErrorType -> Maybe Text -> Maybe SourcePos -> ParseError
peType :: ParseError -> Maybe ParseErrorType
peMessage :: ParseError -> Maybe Text
peSourcePos :: ParseError -> Maybe SourcePos
noMsg :: ParseError
strMsg :: [Char] -> ParseError
data ParserError
ERepeatEmpty :: ParserError
EUnknown :: ParserError
parse :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Either ParseError a
parse' :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> (Either ParseError a, [(tt, td)])
runM :: (Eq tt, HasSourcePos td) => M tt td a -> [(tt, td)] -> (Either ParseError a, ParseState tt td)
accept :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Bool
accept' :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Maybe ParseError
data Ex f
Ex :: (f a) -> Ex f
acceptEmpty :: Ex (Parser s tt td) -> Bool
validate :: Parser s tt td a -> [(ParserError, String)]
localConsumption :: M tt td a -> M tt td a
type M tt td = ExceptT ParseError (State (ParseState tt td))
mp :: (Eq tt, HasSourcePos td) => Parser s tt td a -> M tt td a
instance Eq ParseErrorType
instance Ord ParseErrorType
instance Enum ParseErrorType
instance Bounded ParseErrorType
instance Show ParseErrorType
instance Eq ParseError
instance Show ParseError
instance Eq ParserError
instance Show ParserError
instance Alternative (Parser s tt td)
instance Applicative (Parser s tt td)
instance Functor (Parser s tt td)
instance (Show s, Show tt, Show td) => Show (Parser s tt td a)

module Text.Parsec.Applicative.Grammar
data Grammar s t
Grammar :: s -> Map s (Expr s t) -> Grammar s t
start :: Grammar s t -> s
productions :: Grammar s t -> Map s (Expr s t)
data Expr s t
End :: Expr s t
Empty :: Expr s t
Terminal :: t -> Expr s t
NonTerminal :: s -> Expr s t
Sequence :: [Expr s t] -> Expr s t
Choice :: [Expr s t] -> Expr s t
Repeat :: (Expr s t) -> Expr s t
Try :: (Expr s t) -> Expr s t
Fail :: (Maybe String) -> Expr s t
nonTerminals :: Eq s => [(s, Parser s tt td ())] -> Parser s tt td a -> [(s, Parser s tt td ())]
parserToGrammar :: Ord s => Parser s tt td a -> Maybe (Grammar s tt)
ce :: Parser s tt td a -> Expr s tt
isFail :: Expr s t -> Bool
flatten :: Expr s t -> Expr s t
flattenSequence :: Expr s t -> [Expr s t]
flattenChoice :: Expr s t -> [Expr s t]
instance (Show s, Show t) => Show (Grammar s t)
instance (Show s, Show t) => Show (Expr s t)

module Text.Parsec.Applicative.BNF
newtype BNF
BNF :: (Int -> ShowS) -> BNF
showsPrecBNF :: BNF -> Int -> ShowS
grammarToBNF :: (Show s, Show t) => Grammar s t -> BNF
parserToBNF :: (Show s, Show tt, Ord s) => Parser s tt td a -> Maybe BNF
showsGrammarBNF :: (Show s, Show t) => Grammar s t -> ShowS
showsBNFStart :: Show s => s -> ShowS
showsBNFProds :: (Show s, Show t) => Map s (Expr s t) -> ShowS
showsBNFExp :: (Show s, Show t) => Bool -> Expr s t -> ShowS
showsParens :: ShowS -> ShowS
showsSepBy :: Bool -> [ShowS] -> ShowS -> ShowS
instance Show BNF

module Text.Parsec.Applicative
data Parser s tt td a
data ParseError
ParseError :: Maybe ParseErrorType -> Maybe Text -> Maybe SourcePos -> ParseError
peType :: ParseError -> Maybe ParseErrorType
peMessage :: ParseError -> Maybe Text
peSourcePos :: ParseError -> Maybe SourcePos
eof :: Parser s tt td ()
token :: Eq tt => tt -> Parser s tt td (tt, td)
try :: Parser s tt td a -> Parser s tt td a
label :: s -> Parser s tt td a -> Parser s tt td a
parse :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Either ParseError a
parse' :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> (Either ParseError a, [(tt, td)])
accept :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Bool
accept' :: (Eq tt, HasSourcePos td) => Parser s tt td a -> [(tt, td)] -> Maybe ParseError
between :: Applicative f => f a -> f b -> f c -> f c
choice :: Alternative f => [f a] -> f a
option :: Alternative f => a -> f a -> f a
sepBy :: Alternative f => f a -> f b -> f [a]
updatePosString :: SourcePos -> String -> SourcePos
getPosition :: HasSourcePos td => Parser s tt td SourcePos
