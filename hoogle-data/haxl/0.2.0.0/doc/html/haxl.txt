-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell library for efficient, concurrent,
and concise data access.
--   
@package haxl
@version 0.2.0.0

module Haxl.Core.Show1

-- | A class of type constructors for which we can show all
--   parameterizations.
class Show1 f
show1 :: Show1 f => f a -> String

module Haxl.Core.StateStore

-- | <a>StateKey</a> maps one type to another type. A type that is an
--   instance of <a>StateKey</a> can store and retrieve information from a
--   <a>StateStore</a>.
class Typeable f => StateKey (f :: * -> *) where data family State f

-- | The <a>StateStore</a> maps a <a>StateKey</a> to the <a>State</a> for
--   that type.
data StateStore

-- | Retrieves a <a>State</a> from the <a>StateStore</a> container.
stateGet :: StateKey r => StateStore -> Maybe (State r)

-- | Inserts a <a>State</a> in the <a>StateStore</a> container.
stateSet :: StateKey f => State f -> StateStore -> StateStore

-- | A <a>StateStore</a> with no entries.
stateEmpty :: StateStore


-- | An exception hierarchy that can be used with the <tt>Haxl</tt> monad.
--   
--   The Haxl framework may throw exceptions from this hierarchy: for
--   example, a misbehaving data source causes <tt>dataFetch</tt> to throw
--   a <a>DataSourceError</a>. The combinator <tt>withDefault</tt> from
--   <a>Haxl.Core.Prelude</a> uses this hierarchy to provide default values
--   for expressions that raise <a>TransientError</a> or <a>LogicError</a>
--   exceptions.
--   
--   You are under no obligations to use this hierarchy for your own
--   exceptions, but you might find it useful nonetheless; for
--   <tt>withDefault</tt> to be useful, for example, you'll want your
--   exceptions to be children of <a>LogicError</a> or
--   <a>TransientError</a> as appropriate.
module Haxl.Core.Exception

-- | We have a 3-tiered hierarchy of exceptions, with <a>HaxlException</a>
--   at the top, and all Haxl exceptions as children of this. Users should
--   never deal directly with <a>HaxlException</a>s.
--   
--   The main types of exceptions are:
--   
--   <ul>
--   <li><i><a>InternalError</a></i> Something is wrong with Haxl
--   core.</li>
--   <li><i><a>LogicError</a></i> Something is wrong with Haxl client
--   code.</li>
--   <li><i><a>TransientError</a></i> Something is temporarily failing
--   (usually in a fetch).</li>
--   </ul>
--   
--   These are not meant to be thrown (but likely be caught). Thrown
--   exceptions should be a subclass of one of these. There are some
--   generic leaf exceptions defined below this, such as <a>FetchError</a>
--   (generic transient failure) or <a>CriticalError</a> (internal
--   failure).
data HaxlException
HaxlException :: e -> HaxlException

-- | For errors in Haxl core code.
data InternalError
InternalError :: e -> InternalError
internalErrorToException :: Exception e => e -> SomeException
internalErrorFromException :: Exception e => SomeException -> Maybe e

-- | For errors in Haxl client code.
data LogicError
LogicError :: e -> LogicError
logicErrorToException :: Exception e => e -> SomeException
logicErrorFromException :: Exception e => SomeException -> Maybe e

-- | For transient failures.
data TransientError
TransientError :: e -> TransientError
transientErrorToException :: Exception e => e -> SomeException
transientErrorFromException :: Exception e => SomeException -> Maybe e

-- | Generic "critical" exception. Something internal is borked. Panic.
data CriticalError
CriticalError :: Text -> CriticalError

-- | A data source did something wrong
data DataSourceError
DataSourceError :: Text -> DataSourceError

-- | Generic "something was not found" exception.
data NotFound
NotFound :: Text -> NotFound

-- | Generic "something had the wrong type" exception.
data UnexpectedType
UnexpectedType :: Text -> UnexpectedType

-- | Generic "input list was empty" exception.
data EmptyList
EmptyList :: Text -> EmptyList

-- | Generic "Incorrect assumptions about JSON data" exception.
data JSONError
JSONError :: Text -> JSONError

-- | Generic "passing some invalid parameter" exception.
data InvalidParameter
InvalidParameter :: Text -> InvalidParameter

-- | Generic transient fetching exceptions.
data FetchError
FetchError :: Text -> FetchError

-- | Converts all exceptions that are not derived from <a>HaxlException</a>
--   into <a>CriticalError</a>, using <a>show</a>.
asHaxlException :: SomeException -> HaxlException
instance Typeable HaxlException
instance Typeable TransientError
instance Typeable InternalError
instance Typeable LogicError
instance Typeable CriticalError
instance Typeable NotFound
instance Typeable UnexpectedType
instance Typeable EmptyList
instance Typeable JSONError
instance Typeable InvalidParameter
instance Typeable FetchError
instance Typeable DataSourceError
instance Show LogicError
instance Show InternalError
instance Show TransientError
instance Show CriticalError
instance Show NotFound
instance Show UnexpectedType
instance Show EmptyList
instance Show JSONError
instance Show InvalidParameter
instance Eq FetchError
instance Show FetchError
instance Eq DataSourceError
instance Show DataSourceError
instance Exception DataSourceError
instance Exception FetchError
instance Exception InvalidParameter
instance Exception JSONError
instance Exception EmptyList
instance Exception UnexpectedType
instance Exception NotFound
instance Exception CriticalError
instance MiddleException LogicError
instance Exception LogicError
instance MiddleException InternalError
instance Exception InternalError
instance MiddleException TransientError
instance Exception TransientError
instance ToJSON HaxlException
instance Exception HaxlException
instance Show HaxlException


-- | Base types used by all of Haxl.
module Haxl.Core.Types

-- | Initialization strategy. <a>FullInit</a> will do as much
--   initialization as possible. <a>FastInit</a> will postpone part of
--   initialization or omit part of initialization by sharing more
--   resources. Use <a>FastInit</a> if you want fast initialization but
--   don't care much about performance, for example, in interactive
--   environment.
data InitStrategy
FullInit :: InitStrategy
FastInit :: InitStrategy

-- | Flags that control the operation of the engine.
data Flags
Flags :: Int -> Int -> Flags

-- | Tracing level (0 = quiet, 3 = very verbose).
trace :: Flags -> Int

-- | Report level (0 = quiet, 1 = of errors)
report :: Flags -> Int
defaultFlags :: Flags

-- | Runs an action if the tracing level is above the given threshold.
ifTrace :: (Functor m, Monad m) => Flags -> Int -> m a -> m ()

-- | Runs an action if the report level is above the given threshold.
ifReport :: (Functor m, Monad m) => Flags -> Int -> m a -> m ()

-- | Stats that we collect along the way.
newtype Stats
Stats :: [RoundStats] -> Stats

-- | Maps data source name to the number of requests made in that round.
--   The map only contains entries for sources that made requests in that
--   round.
data RoundStats
RoundStats :: Microseconds -> HashMap Text DataSourceRoundStats -> RoundStats
roundTime :: RoundStats -> Microseconds
roundDataSources :: RoundStats -> HashMap Text DataSourceRoundStats

-- | Detailed stats of each data source in each round.
data DataSourceRoundStats
DataSourceRoundStats :: Int -> Maybe Microseconds -> DataSourceRoundStats
dataSourceFetches :: DataSourceRoundStats -> Int
dataSourceTime :: DataSourceRoundStats -> Maybe Microseconds
type Microseconds = Int
emptyStats :: Stats
numRounds :: Stats -> Int
numFetches :: Stats -> Int

-- | Pretty-print Stats.
ppStats :: Stats -> String

-- | Pretty-print RoundStats.
ppRoundStats :: RoundStats -> String

-- | Pretty-print DataSourceRoundStats
ppDataSourceRoundStats :: DataSourceRoundStats -> String

-- | The class of data sources, parameterised over the request type for
--   that data source. Every data source must implement this class.
--   
--   A data source keeps track of its state by creating an instance of
--   <a>StateKey</a> to map the request type to its state. In this case,
--   the type of the state should probably be a reference type of some
--   kind, such as <tt>IORef</tt>.
--   
--   For a complete example data source, see <a>Examples</a>.
class (DataSourceName req, StateKey req, Show1 req) => DataSource u req
fetch :: DataSource u req => State req -> Flags -> u -> [BlockedFetch req] -> PerformFetch
class DataSourceName req
dataSourceName :: DataSourceName req => req a -> Text

-- | A convenience only: package up <a>Eq</a>, <a>Hashable</a>,
--   <a>Typeable</a>, and <a>Show</a> for requests into a single
--   constraint.
type Request req a = (Eq (req a), Hashable (req a), Typeable (req a), Show (req a), Show a)

-- | A <a>BlockedFetch</a> is a pair of
--   
--   <ul>
--   <li>The request to fetch (with result type <tt>a</tt>)</li>
--   <li>An <a>MVar</a> to store either the result or an error</li>
--   </ul>
--   
--   We often want to collect together multiple requests, but they return
--   different types, and the type system wouldn't let us put them together
--   in a list because all the elements of the list must have the same
--   type. So we wrap up these types inside the <a>BlockedFetch</a> type,
--   so that they all look the same and we can put them in a list.
--   
--   When we unpack the <a>BlockedFetch</a> and get the request and the
--   <a>MVar</a> out, the type system knows that the result type of the
--   request matches the type parameter of the <a>MVar</a>, so it will let
--   us take the result of the request and store it in the <a>MVar</a>.
data BlockedFetch r
BlockedFetch :: (r a) -> (ResultVar a) -> BlockedFetch r

-- | A data source can fetch data in one of two ways.
--   
--   <ul>
--   <li>Synchronously (<a>SyncFetch</a>): the fetching operation is an
--   <tt><a>IO</a> ()</tt> that fetches all the data and then returns.</li>
--   <li>Asynchronously (<a>AsyncFetch</a>): we can do something else while
--   the data is being fetched. The fetching operation takes an
--   <tt><a>IO</a> ()</tt> as an argument, which is the operation to
--   perform while the data is being fetched.</li>
--   </ul>
--   
--   See <a>syncFetch</a> and <a>asyncFetch</a> for example usage.
data PerformFetch
SyncFetch :: (IO ()) -> PerformFetch
AsyncFetch :: (IO () -> IO ()) -> PerformFetch

-- | A sink for the result of a data fetch, used by <a>BlockedFetch</a> and
--   the <tt>DataCache</tt>. Why do we need an <a>MVar</a> here? The reason
--   is that the cache serves two purposes:
--   
--   <ol>
--   <li>To cache the results of requests that were submitted in a previous
--   round.</li>
--   <li>To remember requests that have been encountered in the current
--   round but are not yet submitted, so that if we see the request again
--   we can make sure that we only submit it once.</li>
--   </ol>
--   
--   Storing the result as an <a>MVar</a> gives two benefits:
--   
--   <ul>
--   <li>We can tell the difference between (1) and (2) by testing whether
--   the <a>MVar</a> is empty. See <a>cached</a>.</li>
--   <li>In the case of (2), we don't have to update the cache again after
--   the current round, and after the round we can read the result of each
--   request from its <a>MVar</a>. All instances of identical requests will
--   share the same <a>MVar</a> to obtain the result.</li>
--   </ul>
newtype ResultVar a
ResultVar :: (MVar (Either SomeException a)) -> ResultVar a
newEmptyResult :: IO (ResultVar a)
newResult :: a -> IO (ResultVar a)
putFailure :: Exception e => ResultVar a -> e -> IO ()
putResult :: ResultVar a -> Either SomeException a -> IO ()
putSuccess :: ResultVar a -> a -> IO ()
takeResult :: ResultVar a -> IO (Either SomeException a)
tryReadResult :: ResultVar a -> IO (Maybe (Either SomeException a))
tryTakeResult :: ResultVar a -> IO (Maybe (Either SomeException a))
asyncFetch :: ((service -> IO ()) -> IO ()) -> (service -> IO ()) -> (forall a. service -> request a -> IO (IO (Either SomeException a))) -> State request -> Flags -> u -> [BlockedFetch request] -> PerformFetch

-- | Common implementation templates for <a>fetch</a> of <a>DataSource</a>.
--   
--   Example usage:
--   
--   <pre>
--   fetch = syncFetch MyDS.withService MyDS.retrieve
--     $ \service request -&gt; case request of
--       This x -&gt; MyDS.fetchThis service x
--       That y -&gt; MyDS.fetchThat service y
--   </pre>
asyncFetchWithDispatch :: ((service -> IO ()) -> IO ()) -> (service -> IO ()) -> (service -> IO ()) -> (forall a. service -> request a -> IO (IO (Either SomeException a))) -> State request -> Flags -> u -> [BlockedFetch request] -> PerformFetch
stubFetch :: Exception e => (forall a. r a -> e) -> State r -> Flags -> u -> [BlockedFetch r] -> PerformFetch
syncFetch :: ((service -> IO ()) -> IO ()) -> (service -> IO ()) -> (forall a. service -> request a -> IO (IO (Either SomeException a))) -> State request -> Flags -> u -> [BlockedFetch request] -> PerformFetch
except :: Exception e => e -> Either SomeException a

-- | Function for easily setting a fetch to a particular exception
setError :: Exception e => (forall a. r a -> e) -> BlockedFetch r -> IO ()
instance Enum InitStrategy
instance Eq InitStrategy
instance Show InitStrategy
instance ToJSON Stats
instance ToJSON DataSourceRoundStats
instance ToJSON RoundStats


-- | A cache mapping data requests to their results.
module Haxl.Core.DataCache

-- | The <a>DataCache</a> maps things of type <tt>f a</tt> to
--   <tt><a>ResultVar</a> a</tt>, for any <tt>f</tt> and <tt>a</tt>
--   provided <tt>f a</tt> is an instance of <a>Typeable</a>. In practice
--   <tt>f a</tt> will be a request type parameterised by its result.
--   
--   See the definition of <a>ResultVar</a> for more details.
data DataCache res

-- | A new, empty <a>DataCache</a>.
empty :: DataCache res

-- | Inserts a request-result pair into the <a>DataCache</a>.
insert :: (Hashable (req a), Typeable (req a), Eq (req a), Show (req a), Show a) => req a -> res a -> DataCache res -> DataCache res

-- | Looks up the cached result of a request.
lookup :: Typeable (req a) => req a -> DataCache res -> Maybe (res a)

-- | Dumps the contents of the cache, with requests and responses converted
--   to <a>String</a>s using <a>show</a>. The entries are grouped by
--   <a>TypeRep</a>.
showCache :: DataCache ResultVar -> IO [(TypeRep, [(String, Either SomeException String)])]


-- | Bucketing requests by <a>DataSource</a>.
--   
--   When a request is issued by the client via <tt>dataFetch</tt>, it is
--   placed in the <a>RequestStore</a>. When we are ready to fetch the
--   current batch of requests, the <a>contents</a> operation extracts the
--   fetches, bucketed by <a>DataSource</a>.
module Haxl.Core.RequestStore

-- | A batch of <a>BlockedFetch</a> objects for a single <a>DataSource</a>
data BlockedFetches u
BlockedFetches :: [BlockedFetch r] -> BlockedFetches u

-- | A container for multiple <a>BlockedFetch</a> objects.
data RequestStore u

-- | A new empty <a>RequestStore</a>.
noRequests :: RequestStore u

-- | Adds a <a>BlockedFetch</a> to a <a>RequestStore</a>.
addRequest :: DataSource u r => BlockedFetch r -> RequestStore u -> RequestStore u

-- | Retrieves the whole contents of the <a>RequestStore</a>.
contents :: RequestStore u -> [BlockedFetches u]


-- | The implementation of the <tt>Haxl</tt> monad.
module Haxl.Core.Monad

-- | The Haxl monad, which does several things:
--   
--   <ul>
--   <li>It is a reader monad for <a>Env</a> and <a>IORef</a>
--   <a>RequestStore</a>, The latter is the current batch of unsubmitted
--   data fetch requests.</li>
--   <li>It is a concurrency, or resumption, monad. A computation may run
--   partially and return <a>Blocked</a>, in which case the framework
--   should perform the outstanding requests in the <a>RequestStore</a>,
--   and then resume the computation.</li>
--   <li>The Applicative combinator <a>&lt;*&gt;</a> explores <i>both</i>
--   branches in the event that the left branch is <a>Blocked</a>, so that
--   we can collect multiple requests and submit them as a batch.</li>
--   <li>It contains IO, so that we can perform real data fetching.</li>
--   </ul>
newtype GenHaxl u a
GenHaxl :: (Env u -> IORef (RequestStore u) -> IO (Result u a)) -> GenHaxl u a
unHaxl :: GenHaxl u a -> Env u -> IORef (RequestStore u) -> IO (Result u a)

-- | Runs a <tt>Haxl</tt> computation in an <a>Env</a>.
runHaxl :: Env u -> GenHaxl u a -> IO a

-- | Extracts data from the <a>Env</a>.
env :: (Env u -> a) -> GenHaxl u a

-- | The data we carry around in the Haxl monad.
data Env u
Env :: IORef (DataCache ResultVar) -> IORef (DataCache (MemoVar u)) -> Flags -> u -> IORef Stats -> StateStore -> Env u
cacheRef :: Env u -> IORef (DataCache ResultVar)
memoRef :: Env u -> IORef (DataCache (MemoVar u))
flags :: Env u -> Flags
userEnv :: Env u -> u
statsRef :: Env u -> IORef Stats

-- | Data sources and other components can store their state in here. Items
--   in this store must be instances of <a>StateKey</a>.
states :: Env u -> StateStore
caches :: Env u -> Caches u

-- | Initialize an environment with a <a>StateStore</a>, an input map, a
--   preexisting <a>DataCache</a>, and a seed for the random number
--   generator.
initEnvWithData :: StateStore -> u -> Caches u -> IO (Env u)

-- | Initializes an environment with <tt>DataStates</tt> and an input map.
initEnv :: StateStore -> u -> IO (Env u)

-- | A new, empty environment.
emptyEnv :: u -> IO (Env u)

-- | Throw an exception in the Haxl monad
throw :: Exception e => e -> GenHaxl u a

-- | Catch an exception in the Haxl monad
catch :: Exception e => GenHaxl u a -> (e -> GenHaxl u a) -> GenHaxl u a

-- | Catch exceptions that satisfy a predicate
catchIf :: Exception e => (e -> Bool) -> GenHaxl u a -> (e -> GenHaxl u a) -> GenHaxl u a

-- | Returns <tt><a>Left</a> e</tt> if the computation throws an exception
--   <tt>e</tt>, or <tt><a>Right</a> a</tt> if it returns a result
--   <tt>a</tt>.
try :: Exception e => GenHaxl u a -> GenHaxl u (Either e a)

-- | Like <a>try</a>, but lifts all exceptions into the
--   <a>HaxlException</a> hierarchy. Uses <a>unsafeToHaxlException</a>
--   internally. Typically this is used at the top level of a Haxl
--   computation, to ensure that all exceptions are caught.
tryToHaxlException :: GenHaxl u a -> GenHaxl u (Either HaxlException a)

-- | Performs actual fetching of data for a <a>Request</a> from a
--   <a>DataSource</a>.
dataFetch :: (DataSource u r, Request r a) => r a -> GenHaxl u a

-- | A data request that is not cached. This is not what you want for
--   normal read requests, because then multiple identical requests may
--   return different results, and this invalidates some of the properties
--   that we expect Haxl computations to respect: that data fetches can be
--   aribtrarily reordered, and identical requests can be commoned up, for
--   example.
--   
--   <a>uncachedRequest</a> is useful for performing writes, provided those
--   are done in a safe way - that is, not mixed with reads that might
--   conflict in the same Haxl computation.
uncachedRequest :: (DataSource u r, Request r a) => r a -> GenHaxl u a

-- | Inserts a request/result pair into the cache. Throws an exception if
--   the request has already been issued, either via <a>dataFetch</a> or
--   <a>cacheRequest</a>.
--   
--   This can be used to pre-populate the cache when running tests, to
--   avoid going to the actual data source and ensure that results are
--   deterministic.
cacheRequest :: Request req a => req a -> Either SomeException a -> GenHaxl u ()

-- | Transparently provides caching. Useful for datasources that can return
--   immediately, but also caches values. Exceptions thrown by the IO
--   operation (except for asynchronous exceptions) are propagated into the
--   Haxl monad and can be caught by <a>catch</a> and <a>try</a>.
cacheResult :: Request r a => r a -> IO a -> GenHaxl u a

-- | <a>cachedComputation</a> memoizes a Haxl computation. The key is a
--   request.
--   
--   <i>Note:</i> These cached computations will <i>not</i> be included in
--   the output of <a>dumpCacheAsHaskell</a>.
cachedComputation :: Request req a => req a -> GenHaxl u a -> GenHaxl u a

-- | Dump the contents of the cache as Haskell code that, when compiled and
--   run, will recreate the same cache contents. For example, the generated
--   code looks something like this:
--   
--   <pre>
--   loadCache :: GenHaxl u ()
--   loadCache = do
--     cacheRequest (ListWombats 3) (Right ([1,2,3]))
--     cacheRequest (CountAardvarks "abcabc") (Right (2))
--   </pre>
dumpCacheAsHaskell :: GenHaxl u String

-- | Under ordinary circumstances this is unnecessary; users of the Haxl
--   monad should generally <i>not</i> perform arbitrary IO.
unsafeLiftIO :: IO a -> GenHaxl u a

-- | Convert exceptions in the underlying IO monad to exceptions in the
--   Haxl monad. This is morally unsafe, because you could then catch those
--   exceptions in Haxl and observe the underlying execution order. Not to
--   be exposed to user code.
unsafeToHaxlException :: GenHaxl u a -> GenHaxl u a
instance IsString a => IsString (GenHaxl u a)
instance Applicative (GenHaxl u)
instance Functor (GenHaxl u)
instance Monad (GenHaxl u)
instance Show a => Show (Result u a)


-- | Support for using Haxl as a DSL. This module provides most of the
--   standard Prelude, plus a selection of stuff that makes it Haxl client
--   code cleaner and more concise.
--   
--   We intend Haxl client code to:
--   
--   <ul>
--   <li>Import <tt>Haxl.Prelude</tt></li>
--   <li>Use <tt>RebindableSyntax</tt>. This implies
--   <tt>NoImplicitPrelude</tt>, and allows
--   <tt>if</tt>-<tt>then</tt>-<tt>else</tt> to be used with a monadic
--   condition.</li>
--   <li>Use <tt>OverloadedStrings</tt> (we use <tt>Text</tt> a lot)</li>
--   </ul>
module Haxl.Prelude

-- | The Haxl monad, which does several things:
--   
--   <ul>
--   <li>It is a reader monad for <a>Env</a> and <a>IORef</a>
--   <a>RequestStore</a>, The latter is the current batch of unsubmitted
--   data fetch requests.</li>
--   <li>It is a concurrency, or resumption, monad. A computation may run
--   partially and return <a>Blocked</a>, in which case the framework
--   should perform the outstanding requests in the <a>RequestStore</a>,
--   and then resume the computation.</li>
--   <li>The Applicative combinator <a>&lt;*&gt;</a> explores <i>both</i>
--   branches in the event that the left branch is <a>Blocked</a>, so that
--   we can collect multiple requests and submit them as a batch.</li>
--   <li>It contains IO, so that we can perform real data fetching.</li>
--   </ul>
data GenHaxl u a

-- | Performs actual fetching of data for a <a>Request</a> from a
--   <a>DataSource</a>.
dataFetch :: (DataSource u r, Request r a) => r a -> GenHaxl u a

-- | The class of data sources, parameterised over the request type for
--   that data source. Every data source must implement this class.
--   
--   A data source keeps track of its state by creating an instance of
--   <a>StateKey</a> to map the request type to its state. In this case,
--   the type of the state should probably be a reference type of some
--   kind, such as <tt>IORef</tt>.
--   
--   For a complete example data source, see <a>Examples</a>.
class (DataSourceName req, StateKey req, Show1 req) => DataSource u req

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: * -> *)
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | We don't want the monadic <a>mapM</a>, because that doesn't do
--   batching. There doesn't seem to be a way to make <a>mapM</a> have the
--   right behaviour when used with Haxl, so instead we define <a>mapM</a>
--   to be <a>traverse</a> in Haxl code.
mapM :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | See <a>mapM</a>.
mapM_ :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | See <a>mapM</a>.
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | See <a>mapM</a>.
sequence_ :: (Traversable t, Applicative f) => t (f a) -> f ()

-- | See <a>mapM</a>.
filterM :: (Applicative f, Monad f) => (a -> f Bool) -> [a] -> f [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
forM :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
forM_ :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | A strict version of <a>foldl</a>.
foldl' :: (b -> a -> b) -> b -> [a] -> b

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m (m a) -> m a
class IfThenElse a b
ifThenElse :: IfThenElse a b => a -> b -> b -> b
(.>) :: Ord a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(.<) :: Ord a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(.>=) :: Ord a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(.<=) :: Ord a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(.==) :: Eq a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(./=) :: Eq a => GenHaxl u a -> GenHaxl u a -> GenHaxl u Bool
(.&&) :: GenHaxl u Bool -> GenHaxl u Bool -> GenHaxl u Bool
(.||) :: GenHaxl u Bool -> GenHaxl u Bool -> GenHaxl u Bool
(.++) :: GenHaxl u [a] -> GenHaxl u [a] -> GenHaxl u [a]
pair :: GenHaxl u a -> GenHaxl u b -> GenHaxl u (a, b)

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | Throw an exception in the Haxl monad
throw :: Exception e => e -> GenHaxl u a

-- | Catch an exception in the Haxl monad
catch :: Exception e => GenHaxl u a -> (e -> GenHaxl u a) -> GenHaxl u a

-- | Returns <tt><a>Left</a> e</tt> if the computation throws an exception
--   <tt>e</tt>, or <tt><a>Right</a> a</tt> if it returns a result
--   <tt>a</tt>.
try :: Exception e => GenHaxl u a -> GenHaxl u (Either e a)

-- | Runs the given <a>GenHaxl</a> computation, and if it throws a
--   <a>TransientError</a> or <a>LogicError</a> exception (see
--   <a>Haxl.Core.Exception</a>), the exception is ignored and the supplied
--   default value is returned instead.
withDefault :: a -> GenHaxl u a -> GenHaxl u a

-- | Catch <a>LogicError</a>s and <a>TransientError</a>s and perform an
--   alternative action
catchAny :: GenHaxl u a -> GenHaxl u a -> GenHaxl u a

-- | We have a 3-tiered hierarchy of exceptions, with <a>HaxlException</a>
--   at the top, and all Haxl exceptions as children of this. Users should
--   never deal directly with <a>HaxlException</a>s.
--   
--   The main types of exceptions are:
--   
--   <ul>
--   <li><i><a>InternalError</a></i> Something is wrong with Haxl
--   core.</li>
--   <li><i><a>LogicError</a></i> Something is wrong with Haxl client
--   code.</li>
--   <li><i><a>TransientError</a></i> Something is temporarily failing
--   (usually in a fetch).</li>
--   </ul>
--   
--   These are not meant to be thrown (but likely be caught). Thrown
--   exceptions should be a subclass of one of these. There are some
--   generic leaf exceptions defined below this, such as <a>FetchError</a>
--   (generic transient failure) or <a>CriticalError</a> (internal
--   failure).
data HaxlException
HaxlException :: e -> HaxlException

-- | For transient failures.
data TransientError
TransientError :: e -> TransientError

-- | For errors in Haxl client code.
data LogicError
LogicError :: e -> LogicError

-- | Generic "something was not found" exception.
data NotFound
NotFound :: Text -> NotFound

-- | Generic "something had the wrong type" exception.
data UnexpectedType
UnexpectedType :: Text -> UnexpectedType

-- | Generic transient fetching exceptions.
data FetchError
FetchError :: Text -> FetchError

-- | Generic "input list was empty" exception.
data EmptyList
EmptyList :: Text -> EmptyList

-- | Generic "passing some invalid parameter" exception.
data InvalidParameter
InvalidParameter :: Text -> InvalidParameter
instance Fractional a => Fractional (GenHaxl u a)
instance Num a => Num (GenHaxl u a)
instance u1 ~ u2 => IfThenElse (GenHaxl u1 Bool) (GenHaxl u2 a)
instance IfThenElse Bool a


-- | Everything needed to define data sources and to invoke the engine.
--   This module should not be imported by user code.
module Haxl.Core
