-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An alternating list of two types
--   
@package ABList
@version 0.0.3

module Data.AbList
data AbList a b
AbNil :: AbList a b
(:/) :: a -> AbList b a -> AbList a b
abSingle :: a -> AbList a b
abShallowFold :: t -> (a -> AbList b a -> t) -> (AbList a b) -> t
abToListEither :: AbList a b -> [Either a b]
abFromListEither :: [Either a b] -> Maybe (AbList a b)
abHead :: AbList a b -> Maybe a
abTail :: AbList a b -> Maybe (AbList b a)
abInit :: AbList a b -> Maybe (AbList a b)
aaToList :: AbList a a -> [a]
aaMap :: (a -> b) -> AbList a a -> AbList b b
aaFromList :: [a] -> AbList a a
abFoldr :: (Either a b -> t -> t) -> t -> (AbList a b) -> t
abFoldr' :: (a -> t -> t) -> (b -> t -> t) -> t -> (AbList a b) -> t
abFoldl :: (t -> Either a b -> t) -> t -> (AbList a b) -> t
abFoldl' :: (t -> a -> t) -> (t -> b -> t) -> t -> (AbList a b) -> t
abZip :: [a] -> [b] -> AbList a b
abFromPairs :: [(a, b)] -> AbList a b
abToPairs :: AbList a b -> [(a, b)]
abMap :: (a -> a') -> (b -> b') -> AbList a b -> AbList a' b'
abMerge :: (a -> t) -> (b -> t) -> AbList a b -> [t]
abReverse :: AbList a b -> Either (AbList a b) (AbList b a)
abMapLefts :: (a -> a') -> AbList a b -> AbList a' b
abMapRights :: (b -> b') -> AbList a b -> AbList a b'
instance (Eq a, Eq b) => Eq (AbList a b)
instance (Ord a, Ord b) => Ord (AbList a b)
instance (Show a, Show b) => Show (AbList a b)
instance Functor (AbList a)

module Data.AbneList
data AbneList a b
(://) :: a -> AbList b a -> AbneList a b
abneHead :: AbneList a b -> a
abneTail :: AbneList a b -> AbList b a
abneShallowFold :: (a -> AbList b a -> t) -> AbneList a b -> t
toAbList :: AbneList a b -> AbList a b
fromAbList :: AbList a b -> Maybe (AbneList a b)
abneToListEither :: AbneList a b -> [Either a b]
abneFromListEither :: [Either a b] -> Maybe (AbneList a b)
abneInit :: AbneList a b -> AbList a b
aaneToList :: AbneList a a -> [a]
aaneMap :: (a -> b) -> AbneList a a -> AbneList b b
aaneFromList :: [a] -> Maybe (AbneList a a)
abneFoldr :: (Either a b -> t -> t) -> t -> (AbneList a b) -> t
abneFoldr' :: (a -> t -> t) -> (b -> t -> t) -> t -> (AbneList a b) -> t
abneFoldl :: (t -> Either a b -> t) -> t -> (AbneList a b) -> t
abneFoldl' :: (t -> a -> t) -> (t -> b -> t) -> t -> (AbneList a b) -> t
abneZip :: [a] -> [b] -> Maybe (AbneList a b)
abneFromPairs :: [(a, b)] -> Maybe (AbneList a b)
instance (Eq a, Eq b) => Eq (AbneList a b)
instance (Ord a, Ord b) => Ord (AbneList a b)
instance (Show a, Show b) => Show (AbneList a b)
