-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Composable monad transformers
--   
--   A version of monad transformers that (a) allows one to convince the
--   type checker that transformer application is a monad, and (b) doesn't
--   need lots of boilerplate to add a new transformer. It's supposed to
--   play nicely with <tt>Control.Monad.Trans</tt>.
--   
--   In order to make a new transformer (say, <tt>T</tt>) an instance of
--   <tt>TransM</tt> (<tt>TransP</tt>, <tt>TransF</tt>) class, all you have
--   to do is:
--   
--   <ul>
--   <li>define <tt>instance MonadTrans T</tt> — which you've probably done
--   already</li>
--   <li>define <tt>instance Monad m =&gt; Monad (T m)</tt> — also
--   something quite common (for <tt>TransP</tt> and <tt>TransF</tt> you'd
--   need another instance for <tt>MonadPlus</tt> and <tt>MonadFix</tt>,
--   respectively).</li>
--   <li>write <tt>instance Trans T where transMInst = instM</tt> — which
--   is exactly one line of boilerplate. Sorry about that.</li>
--   </ul>
--   
--   After that, you can use your new and shiny transformer in
--   compositions, like <tt>ReaderT Char :. T :. WriterT String</tt> — and
--   such a composition would automagically become a monad transformer.
@package compose-trans
@version 0.1


-- | Basic definitions in the category <tt>(* -&gt; *)</tt>.
module Control.Monad.Trans.Category

-- | <tt>m :-&gt; n</tt> is the set of morphisms (from <tt>m</tt> to
--   <tt>n</tt>, naturally) in our category.
type :-> m n = forall a. m a -> n a

-- | If <tt>t</tt> is an endofunctor in our category, then <tt>t :$ m</tt>
--   is basically the same as <tt>t m</tt>.
newtype (:$) t m :: (* -> *) a
ApplyF :: t m a -> :$ t a
runApplyF :: :$ t a -> t m a

-- | If <tt>t1</tt> and <tt>t2</tt> are endofunctorsm then <tt>t2 :.
--   t1</tt> is their composition (which is also an endofunctor)
newtype (:.) t2 t1 m a
ComposeF :: (t2 :$ (t1 :$ m)) a -> :. t2 t1 m a
runComposeF :: :. t2 t1 m a -> (t2 :$ (t1 :$ m)) a

-- | If <tt>m</tt> is an algebra over an endofunctor <tt>t</tt>, then it's
--   structure morphism has the type <tt>Inst t m</tt>.
type Inst c m = c m :-> m


-- | <tt>Monad</tt> transformers. There are also <tt>MonadPlus</tt> and
--   <tt>MonadFix</tt> transformes, see the corresponding modules.
module Control.Monad.Trans.Monad

-- | <tt>MonadM m</tt> is actually a free monad generated by <tt>m</tt>.
--   <tt>MonadM</tt> is a monad itself (on the <tt>(* -&gt; *)</tt>
--   category), as usually happens with free structures.
data MonadM m x

-- | A composable monad transformer.
class MonadTrans t => TransM t
transMInst :: (TransM t, Monad m) => Inst MonadM (t m)

-- | A monad is nothing but an algebra over the <tt>MonadM</tt> monad.
--   <tt>instM</tt> provides it's structure map.
instM :: Monad m => Inst MonadM m

-- | Sometimes we need an <tt>instance Monad T</tt>, while everything we've
--   got is <tt>Inst MonadP T</tt>. In this case, <tt>return'</tt> serves
--   as a <tt>return</tt> substitution.
return' :: Inst MonadM m -> x -> m x

-- | Sometimes we need an <tt>instance Monad T</tt>, while everything we've
--   got is <tt>Inst MonadP T</tt>. In this case, <tt>bind'</tt> serves as
--   a <tt>&gt;&gt;=</tt> substitution.
bind' :: Inst MonadM m -> m x -> (x -> m y) -> m y
instance (Monad m, TransM t1, TransM t2) => Monad ((:.) t2 t1 m)
instance MonadTrans t => MonadTrans ((:$) t)
instance Monoid w => TransM (WriterT w)
instance TransM (StateT s)
instance TransM (ReaderT r)
instance TransM ListT
instance TransM (ContT c)
instance (TransM t1, TransM t2) => TransM (t2 :. t1)
instance (TransM t1, MonadTrans t2) => MonadTrans (t2 :. t1)
instance (Monad m, TransM t) => Monad (t :$ m)


-- | <tt>MonadFix</tt> transformers. There are also <tt>Monad</tt> and
--   <tt>MonadPlus</tt> transformes, see the corresponding modules.
--   
--   Note that each <tt>MonadFix</tt> transformer is also a <tt>Monad</tt>
--   transformer.
module Control.Monad.Trans.MonadFix

-- | <tt>MonadF m</tt> is actually a free <tt>MonadFix</tt> generated by
--   <tt>m</tt>. <tt>MonadF</tt> is a monad itself (on the <tt>(* -&gt;
--   *)</tt> category), as usually happens with free structures.
data MonadF m x

-- | A composable <tt>MonadFix</tt> transformer.
class TransM t => TransF t
transFInst :: (TransF t, MonadFix m) => Inst MonadF (t m)

-- | A <tt>MonadFix</tt> is nothing but an algebra over the <tt>MonadF</tt>
--   monad. <tt>instF</tt> provides it's structure map.
instF :: MonadFix m => Inst MonadF m

-- | Sometimes we need an <tt>instance MonadFix T</tt>, while everything
--   we've got is <tt>InstP MonadF T</tt>. In this case, <tt>mfix'</tt>
--   serves as a <tt>mfix</tt> substitution.
mfix' :: Inst MonadF m -> (x -> m x) -> m x
instance (MonadFix m, TransF t1, TransF t2) => MonadFix ((:.) t2 t1 m)
instance Monoid w => TransF (WriterT w)
instance TransF (StateT s)
instance TransF (ReaderT r)
instance (TransF t1, TransF t2) => TransF (t2 :. t1)
instance (MonadFix m, TransF t) => MonadFix (t :$ m)


-- | <tt>MonadPlus</tt> transformers. There are also <tt>Monad</tt> and
--   <tt>MonadFix</tt> transformes, see the corresponding modules.
--   
--   Note that each <tt>MonadPlus</tt> transformer is also a <tt>Monad</tt>
--   transformer.
module Control.Monad.Trans.MonadPlus

-- | <tt>MonadP m</tt> is actually a free <tt>MonadPlus</tt> generated by
--   <tt>m</tt>. <tt>MonadP</tt> is a monad itself (on the <tt>(* -&gt;
--   *)</tt> category), as usually happens with free structures.
data MonadP m x

-- | A composable <tt>MonadPlus</tt> transformer.
class TransM t => TransP t
transPInst :: (TransP t, MonadPlus m) => Inst MonadP (t m)

-- | A <tt>MonadPlus</tt> is nothing but an algebra over the
--   <tt>MonadP</tt> monad. <tt>instP</tt> provides it's structure map.
instP :: MonadPlus m => Inst MonadP m

-- | Sometimes we need an <tt>instance MonadPlus T</tt>, while everything
--   we've got is <tt>InstP MonadP T</tt>. In this case, <tt>mzero'</tt>
--   serves as a <tt>mzero</tt> substitution.
mzero' :: Inst MonadP m -> m x

-- | Sometimes we need an <tt>instance Monad T</tt>, while everything we've
--   got is <tt>Inst MonadP T</tt>. In this case, <tt>mplus'</tt> serves as
--   a <tt>mplus</tt> substitution.
mplus' :: Inst MonadP m -> m x -> m x -> m x
instance (MonadPlus m, TransP t1, TransP t2) => MonadPlus ((:.) t2 t1 m)
instance Monoid w => TransP (WriterT w)
instance TransP (StateT s)
instance TransP (ReaderT r)
instance TransP ListT
instance (TransP t1, TransP t2) => TransP (t2 :. t1)
instance (MonadPlus m, TransP t) => MonadPlus (t :$ m)
