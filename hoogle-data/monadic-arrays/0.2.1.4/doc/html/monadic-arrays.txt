-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Boxed and unboxed arrays for monad transformers
--   
@package monadic-arrays
@version 0.2.1.4


-- | A higher-order MArray class.
module Data.Array.MArray.Extras
class Monad m => MArray1 a f m
getBounds1 :: (MArray1 a f m, Ix i) => a i (f e) -> m (i, i)
getNumElements1 :: (MArray1 a f m, Ix i) => a i (f e) -> m Int
newArray1 :: (MArray1 a f m, Ix i) => (i, i) -> f e -> m (a i (f e))
newArray1_ :: (MArray1 a f m, Ix i) => (i, i) -> m (a i (f e))
unsafeNewArray1_ :: (MArray1 a f m, Ix i) => (i, i) -> m (a i (f e))
unsafeRead1 :: (MArray1 a f m, Ix i) => a i (f e) -> Int -> m (f e)
unsafeWrite1 :: (MArray1 a f m, Ix i) => a i (f e) -> Int -> f e -> m ()
instance MArray1 (STUArray s) FunPtr (ST s)
instance MArray1 (STUArray s) StablePtr (ST s)
instance MArray1 (STUArray s) Ptr (ST s)
instance MArray1 IOUArray FunPtr IO
instance MArray1 IOUArray StablePtr IO
instance MArray1 IOUArray Ptr IO


module Control.Monad.Array.Class

-- | Arr m serves as a canonical choice of boxed MArray
class Monad m => MonadArray m where data family Arr m :: * -> * -> *
getBoundsM :: (MonadArray m, Ix i) => Arr m i e -> m (i, i)
getNumElementsM :: (MonadArray m, Ix i) => Arr m i e -> m Int
newArrayM :: (MonadArray m, Ix i) => (i, i) -> e -> m (Arr m i e)
newArrayM_ :: (MonadArray m, Ix i) => (i, i) -> m (Arr m i e)
unsafeNewArrayM_ :: (MonadArray m, Ix i) => (i, i) -> m (Arr m i e)
unsafeReadM :: (MonadArray m, Ix i) => Arr m i e -> Int -> m e
unsafeWriteM :: (MonadArray m, Ix i) => Arr m i e -> Int -> e -> m ()

-- | UArr m provides unboxed arrays, and can be used on the primitive data
--   types:
--   
--   <a>Bool</a>, <a>Char</a>, <a>Int</a>, <a>Word</a>, <a>Double</a>,
--   <a>Float</a>, <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>,
--   <a>Word8</a>, <a>Word16</a>, <a>Word32</a>, and <a>Word64</a>
--   
--   It can be used via <a>MArray1</a> to store values of types
--   <tt><a>StablePtr</a> a</tt>, <tt><a>FunPtr</a> a</tt> and <tt>'Ptr
--   a'</tt> as well.
class (MonadArray m, MArray (UArr m) Bool m, MArray (UArr m) Char m, MArray (UArr m) Int m, MArray (UArr m) Word m, MArray (UArr m) Double m, MArray (UArr m) Float m, MArray (UArr m) Int8 m, MArray (UArr m) Int16 m, MArray (UArr m) Int32 m, MArray (UArr m) Int64 m, MArray (UArr m) Word8 m, MArray (UArr m) Word16 m, MArray (UArr m) Word32 m, MArray (UArr m) Word64 m, MArray1 (UArr m) StablePtr m, MArray1 (UArr m) FunPtr m, MArray1 (UArr m) Ptr m) => MonadUArray m where data family UArr m :: * -> * -> *
instance (MonadTrans t, Monad (t m), MonadUArray m) => MonadUArray (t m)
instance (MonadTrans t, Monad (t m), MonadUArray m, MArray1 (UArr m) f m) => MArray1 (UArr (t m)) f (t m)
instance (MonadTrans t, Monad (t m), MonadUArray m, MArray (UArr m) e m) => MArray (UArr (t m)) e (t m)
instance MonadUArray (ST s)
instance MArray1 (STUArray s) e (ST s) => MArray1 (UArr (ST s)) e (ST s)
instance MArray (STUArray s) e (ST s) => MArray (UArr (ST s)) e (ST s)
instance MonadUArray IO
instance MArray1 IOUArray e IO => MArray1 (UArr IO) e IO
instance MArray IOUArray e IO => MArray (UArr IO) e IO
instance (MonadTrans t, Monad (t m), MonadArray m) => MonadArray (t m)
instance MonadArray STM
instance MonadArray (ST s)
instance MonadArray IO
instance MonadArray m => MArray (Arr m) e m
