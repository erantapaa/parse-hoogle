-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Computational combinatorial species
--   
@package species
@version 0.3.4.2


-- | A simple implementation of intervals of natural numbers, for use in
--   tracking the possible sizes of structures of a species. For example,
--   the species <tt>x + x^2 + x^3</tt> will correspond to the interval
--   [1,3].
module Math.Combinatorics.Species.Util.Interval

-- | <a>NatO</a> is an explicit representation of the co-inductive Nat type
--   which admits an infinite value, omega. Our intuition for the semantics
--   of <a>NatO</a> comes from thinking of it as an efficient
--   representation of lazy unary natural numbers, except that we can
--   actually test for omega in finite time.
data NatO

-- | The infinite <a>NatO</a> value.
omega :: NatO

-- | Eliminator for <a>NatO</a> values.
natO :: (Integer -> a) -> a -> NatO -> a

-- | An <a>Interval</a> is a closed range of consecutive integers. Both
--   endpoints are represented as <a>NatO</a> values. For example, [2,5]
--   represents the values 2,3,4,5; [2,omega] represents all integers
--   greater than 1; intervals where the first endpoint is greater than the
--   second also represent the empty interval.
data Interval

-- | Get the lower endpoint of an <a>Interval</a>
iLow :: Interval -> NatO

-- | Get the upper endpoint of an <a>Interval</a>
iHigh :: Interval -> NatO

-- | Decrement both endpoints of an interval.
decrI :: Interval -> Interval

-- | The union of two intervals is the smallest interval containing both.
union :: Interval -> Interval -> Interval

-- | The intersection of two intervals is the largest interval contained in
--   both.
intersect :: Interval -> Interval -> Interval

-- | Test a given integer for interval membership.
elem :: Integer -> Interval -> Bool

-- | Convert an interval to a list of Integers.
toList :: Interval -> [Integer]

-- | The range [0,omega] containing all natural numbers.
natsI :: Interval

-- | Construct an open range [n,omega].
fromI :: NatO -> Interval

-- | The empty interval.
emptyI :: Interval

-- | The interval which contains only omega.
omegaI :: Interval
instance Eq NatO
instance Ord NatO
instance Show NatO
instance Show Interval
instance C Interval
instance C Interval
instance C NatO
instance C NatO


-- | Some common types used by the species library, along with some utility
--   functions.
module Math.Combinatorics.Species.Types

-- | A representation of the cycle type of a permutation. If <tt>c ::
--   CycleType</tt> and <tt>(k,n) ``elem`` c</tt>, then the permutation has
--   <tt>n</tt> cycles of size <tt>k</tt>.
type CycleType = [(Integer, Integer)]

-- | Exponential generating functions, for counting labeled species.
newtype EGF
EGF :: T Rational -> EGF
unEGF :: EGF -> T Rational
egfFromCoeffs :: [Rational] -> EGF
liftEGF :: (T Rational -> T Rational) -> EGF -> EGF
liftEGF2 :: (T Rational -> T Rational -> T Rational) -> EGF -> EGF -> EGF

-- | Ordinary generating functions, for counting unlabeled species.
newtype GF
GF :: (T Integer) -> GF
gfFromCoeffs :: [Integer] -> GF
liftGF :: (T Integer -> T Integer) -> GF -> GF
liftGF2 :: (T Integer -> T Integer -> T Integer) -> GF -> GF -> GF

-- | Cycle index series.
newtype CycleIndex
CI :: (T Rational) -> CycleIndex
ciFromMonomials :: [T Rational] -> CycleIndex
liftCI :: (T Rational -> T Rational) -> CycleIndex -> CycleIndex
liftCI2 :: (T Rational -> T Rational -> T Rational) -> CycleIndex -> CycleIndex -> CycleIndex

-- | Filter the coefficients of a series according to a predicate.
filterCoeffs :: C a => (Integer -> Bool) -> [a] -> [a]

-- | Set every coefficient of a series to 0 except the selected index.
--   Truncate any trailing zeroes.
selectIndex :: (C a, Eq a) => Integer -> [a] -> [a]
instance C EGF
instance C EGF
instance C EGF
instance Show EGF
instance C GF
instance C GF
instance Show GF
instance C CycleIndex
instance C CycleIndex
instance C CycleIndex
instance Show CycleIndex


-- | Types used for expressing generic structures when enumerating species.
module Math.Combinatorics.Species.Structures

-- | The (constantly) void functor.
data Void a

-- | The (constantly) unit functor.
data Unit a
Unit :: Unit a

-- | The constant functor.
newtype Const x a
Const :: x -> Const x a

-- | The identity functor.
newtype Id a
Id :: a -> Id a

-- | Functor coproduct.
data (:+:) f g a
Inl :: (f a) -> (:+:) f g a
Inr :: (g a) -> (:+:) f g a

-- | Functor product.
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a

-- | Functor composition.
data (:.:) f g a
Comp :: (f (g a)) -> (:.:) f g a
unComp :: (:.:) f g a -> (f (g a))

-- | Cycle structure. A value of type <tt><a>Cycle</a> a</tt> is
--   implemented as <tt>[a]</tt>, but thought of as a directed cycle.
newtype Cycle a
Cycle :: [a] -> Cycle a
getCycle :: Cycle a -> [a]

-- | Bracelet structure. A value of type <tt><a>Bracelet</a> a</tt> is
--   implemented as <tt>[a]</tt>, but thought of as an undirected cycle
--   (i.e. equivalent up to rotations as well as flips/reversals).
newtype Bracelet a
Bracelet :: [a] -> Bracelet a
getBracelet :: Bracelet a -> [a]

-- | Set structure. A value of type <tt><a>Set</a> a</tt> is implemented as
--   <tt>[a]</tt>, but thought of as an unordered set.
newtype Set a
Set :: [a] -> Set a
getSet :: Set a -> [a]

-- | <a>Star</a> is isomorphic to <a>Maybe</a>, but with a more useful
--   <a>Show</a> instance for our purposes. Used to implement species
--   differentiation.
data Star a
Star :: Star a
Original :: a -> Star a

-- | Higher-order fixpoint. <tt><a>Mu</a> f a</tt> is morally isomorphic to
--   <tt>f (<a>Mu</a> f) a</tt>, except that we actually need a level of
--   indirection. In fact <tt><a>Mu</a> f a</tt> is isomorphic to
--   <tt><a>Interp</a> f (<a>Mu</a> f) a</tt>; <tt>f</tt> is a code which
--   is interpreted by the <a>Interp</a> type function.
data Mu f a
Mu :: Interp f (Mu f) a -> Mu f a
unMu :: Mu f a -> Interp f (Mu f) a

-- | Interpretation type function for codes for higher-order type
--   constructors, used as arguments to the higher-order fixpoint
--   <a>Mu</a>.
instance Typeable Void
instance Typeable Unit
instance Typeable Const
instance Typeable Id
instance Typeable (:+:)
instance Typeable (:*:)
instance Typeable (:.:)
instance Typeable Cycle
instance Typeable Bracelet
instance Typeable Set
instance Typeable Star
instance Typeable Mu
instance Show (Unit a)
instance Functor Cycle
instance Functor Bracelet
instance Functor Set
instance Show a => Show (Star a)
instance Functor Star
instance Eq a => Eq (Set a)
instance Show a => Show (Set a)
instance Eq a => Eq (Bracelet a)
instance Show a => Show (Bracelet a)
instance Eq a => Eq (Cycle a)
instance Show a => Show (Cycle a)
instance Show (f (g a)) => Show ((:.:) f g a)
instance (Functor f, Functor g) => Functor (f :.: g)
instance (Show (f a), Show (g a)) => Show ((:*:) f g a)
instance (Functor f, Functor g) => Functor (f :*: g)
instance (Show (f a), Show (g a)) => Show ((:+:) f g a)
instance (Functor f, Functor g) => Functor (f :+: g)
instance Show a => Show (Id a)
instance Functor Id
instance Show x => Show (Const x a)
instance Functor (Const x)
instance Functor Unit
instance Show (Void a)
instance Functor Void


-- | Various data structures representing reified combinatorial species
--   expressions. See also <a>Math.Combinatorics.Species.AST.Instances</a>.
module Math.Combinatorics.Species.AST

-- | A basic, untyped AST type for species expressions, for easily doing
--   things like analysis, simplification, deriving isomorphisms, and so
--   on. Converting between <a>SpeciesAST</a> and the typed variant
--   <a>ESpeciesAST</a> can be done with <a>annotate</a> and <a>erase</a>.
data SpeciesAST
Zero :: SpeciesAST
One :: SpeciesAST
N :: Integer -> SpeciesAST
X :: SpeciesAST
E :: SpeciesAST
C :: SpeciesAST
B :: SpeciesAST
L :: SpeciesAST
Subset :: SpeciesAST
KSubset :: Integer -> SpeciesAST
Elt :: SpeciesAST
(:+) :: SpeciesAST -> SpeciesAST -> SpeciesAST
(:*) :: SpeciesAST -> SpeciesAST -> SpeciesAST
(:.) :: SpeciesAST -> SpeciesAST -> SpeciesAST
(:><) :: SpeciesAST -> SpeciesAST -> SpeciesAST
(:@) :: SpeciesAST -> SpeciesAST -> SpeciesAST
Der :: SpeciesAST -> SpeciesAST
OfSize :: SpeciesAST -> (Integer -> Bool) -> SpeciesAST
OfSizeExactly :: SpeciesAST -> Integer -> SpeciesAST
NonEmpty :: SpeciesAST -> SpeciesAST
Rec :: f -> SpeciesAST
Omega :: SpeciesAST

-- | A variant of <a>SpeciesAST</a> with a phantom type parameter which
--   also reflects the structure, so we can write quasi-dependently-typed
--   functions over species, in particular for species enumeration.
--   
--   Of course, the non-uniform type parameter means that
--   <a>TSpeciesAST</a> cannot be an instance of the <tt>Species</tt>
--   class; for that purpose the existential wrapper <a>ESpeciesAST</a> is
--   provided.
--   
--   <a>TSpeciesAST</a> is defined via mutual recursion with
--   <a>SizedSpeciesAST</a>, which pairs a <a>TSpeciesAST</a> with an
--   interval annotation indicating (a conservative approximation of) the
--   label set sizes for which the species actually yields any structures;
--   this information makes enumeration faster and also prevents it from
--   getting stuck in infinite recursion in some cases. A value of
--   <a>SizedSpeciesAST</a> is thus an annotated species expression tree
--   with interval annotations at every node.
data TSpeciesAST (s :: * -> *)
TZero :: TSpeciesAST Void
TOne :: TSpeciesAST Unit
TN :: Integer -> TSpeciesAST (Const Integer)
TX :: TSpeciesAST Id
TE :: TSpeciesAST Set
TC :: TSpeciesAST Cycle
TB :: TSpeciesAST Bracelet
TL :: TSpeciesAST []
TSubset :: TSpeciesAST Set
TKSubset :: Integer -> TSpeciesAST Set
TElt :: TSpeciesAST Id
(:+::) :: SizedSpeciesAST f -> SizedSpeciesAST g -> TSpeciesAST (f :+: g)
(:*::) :: SizedSpeciesAST f -> SizedSpeciesAST g -> TSpeciesAST (f :*: g)
(:.::) :: SizedSpeciesAST f -> SizedSpeciesAST g -> TSpeciesAST (f :.: g)
(:><::) :: SizedSpeciesAST f -> SizedSpeciesAST g -> TSpeciesAST (f :*: g)
(:@::) :: SizedSpeciesAST f -> SizedSpeciesAST g -> TSpeciesAST (f :.: g)
TDer :: SizedSpeciesAST f -> TSpeciesAST (f :.: Star)
TOfSize :: SizedSpeciesAST f -> (Integer -> Bool) -> TSpeciesAST f
TOfSizeExactly :: SizedSpeciesAST f -> Integer -> TSpeciesAST f
TNonEmpty :: SizedSpeciesAST f -> TSpeciesAST f
TRec :: f -> TSpeciesAST (Mu f)
TOmega :: TSpeciesAST Void
data SizedSpeciesAST (s :: * -> *)
Sized :: Interval -> TSpeciesAST s -> SizedSpeciesAST s

-- | Given a <a>TSpeciesAST</a>, compute (a conservative approximation of)
--   the interval of label set sizes on which the species yields any
--   structures.
interval :: TSpeciesAST s -> Interval

-- | Annotate a <a>TSpeciesAST</a> with the interval of label set sizes for
--   which it yields structures.
annI :: TSpeciesAST s -> SizedSpeciesAST s

-- | Retrieve the interval annotation from a <a>SizedSpeciesAST</a>.
getI :: SizedSpeciesAST s -> Interval

-- | Strip the interval annotation from a <a>SizedSpeciesAST</a>.
stripI :: SizedSpeciesAST s -> TSpeciesAST s

-- | An existential wrapper to hide the phantom type parameter to
--   <a>SizedSpeciesAST</a>, so we can make it an instance of
--   <tt>Species</tt>.
data ESpeciesAST
Wrap :: SizedSpeciesAST s -> ESpeciesAST

-- | Construct an <a>ESpeciesAST</a> from a <a>TSpeciesAST</a> by adding an
--   appropriate interval annotation and hiding the type.
wrap :: Typeable s => TSpeciesAST s -> ESpeciesAST

-- | Unwrap an existential wrapper to get out a typed AST. You can get out
--   any type you like as long as it is the right one.
--   
--   CAUTION: Don't try this at home!
unwrap :: Typeable s => ESpeciesAST -> TSpeciesAST s

-- | Erase the type and interval information from an existentially wrapped
--   species AST.
erase :: ESpeciesAST -> SpeciesAST

-- | Erase the type and interval information from a typed species AST.
erase' :: TSpeciesAST f -> SpeciesAST

-- | Reconstruct the type and interval annotations on a species AST.
annotate :: SpeciesAST -> ESpeciesAST

-- | <a>ASTFunctor</a> is a type class for codes which can be interpreted
--   (via the <a>Interp</a> type family) as higher-order functors over
--   species expressions. The <a>apply</a> method allows such codes to be
--   applied to a species AST. The indirection is needed to implement
--   recursive species.
class (Typeable f, Show f, Typeable (Interp f (Mu f))) => ASTFunctor f
apply :: (ASTFunctor f, Typeable g) => f -> TSpeciesAST g -> TSpeciesAST (Interp f g)

-- | <a>needsCI</a> is a predicate which checks whether a species
--   expression uses any of the operations which are not supported directly
--   by ordinary generating functions (composition, differentiation,
--   cartesian product, and functor composition), and hence need cycle
--   index series.
needsCI :: SpeciesAST -> Bool

-- | Substitute an expression for recursive occurrences.
substRec :: ASTFunctor f => f -> SpeciesAST -> SpeciesAST -> SpeciesAST


-- | The Species type class, which defines a small DSL for describing
--   combinatorial species. Other modules in this library provide specific
--   instances which allow computing various properties of combinatorial
--   species.
module Math.Combinatorics.Species.Class

-- | The Species type class. Note that the <tt>Differential</tt> constraint
--   requires s to be a differentiable ring, which means that every
--   instance must also implement instances for <a>Algebra.Additive</a>
--   (the species 0 and species addition, i.e. disjoint sum),
--   <a>Algebra.Ring</a> (the species 1 and species multiplication, i.e.
--   partitional product), and <a>Algebra.Differential</a> (species
--   differentiation, i.e. adjoining a distinguished element).
--   
--   Note that the <a>o</a> operation can be used infix to suggest common
--   notation for composition, and also to be read as an abbreviation for
--   "of", as in "top o' the mornin'": <tt>set `o` nonEmpty sets</tt>.
class C s => Species s where linOrd = oneHole cycle subset = set * set ksubset k = (set `ofSizeExactly` k) * set element = singleton * set ofSizeExactly s n = s `ofSize` (== n) nonEmpty = flip ofSize (> 0)
singleton :: Species s => s
set :: Species s => s
cycle :: Species s => s
bracelet :: Species s => s
linOrd :: Species s => s
subset :: Species s => s
ksubset :: Species s => Integer -> s
element :: Species s => s
o :: Species s => s -> s -> s
(><) :: Species s => s -> s -> s
(@@) :: Species s => s -> s -> s
ofSize :: Species s => s -> (Integer -> Bool) -> s
ofSizeExactly :: Species s => s -> Integer -> s
nonEmpty :: Species s => s -> s
rec :: (Species s, ASTFunctor f) => f -> s
omega :: Species s => s

-- | A convenient synonym for differentiation. <tt><a>oneHole</a>
--   f</tt>-structures look like <tt>f</tt>-structures on a set formed by
--   adjoining a distinguished "hole" element to the underlying set.
oneHole :: Species s => s -> s

-- | A synonym for <a>singleton</a>.
x :: Species s => s
sets :: Species s => s
cycles :: Species s => s

-- | A synonym for <a>cycle</a>.
necklace :: Species s => s

-- | A synonym for <a>cycle</a>.
necklaces :: Species s => s
bracelets :: Species s => s
linOrds :: Species s => s
subsets :: Species s => s
ksubsets :: Species s => Integer -> s
elements :: Species s => s
bag :: Species s => s
bags :: Species s => s

-- | Intuitively, the operation of pointing picks out a distinguished
--   element from an underlying set. It is equivalent to the operator <tt>x
--   d/dx</tt>: <tt><a>pointed</a> s = <a>singleton</a> *
--   <tt>differentiate</tt> s</tt>.
pointed :: Species s => s -> s

-- | An octopus is a cyclic arrangement of lists, so called because the
--   lists look like "tentacles" attached to the cyclic "body":
--   <tt><a>octopus</a> = <a>cycle</a> `o` <a>nonEmpty</a>
--   <a>linOrds</a></tt>.
octopus :: Species s => s

-- | An octopus is a cyclic arrangement of lists, so called because the
--   lists look like "tentacles" attached to the cyclic "body":
--   <tt><a>octopus</a> = <a>cycle</a> `o` <a>nonEmpty</a>
--   <a>linOrds</a></tt>.
octopi :: Species s => s

-- | The species of set partitions is just the composition <tt><a>set</a>
--   `o` <a>nonEmpty</a> <a>sets</a></tt>.
partition :: Species s => s

-- | The species of set partitions is just the composition <tt><a>set</a>
--   `o` <a>nonEmpty</a> <a>sets</a></tt>.
partitions :: Species s => s

-- | A permutation is a set of disjoint cycles: <tt><a>permutation</a> =
--   <a>set</a> `o` <a>cycles</a></tt>.
permutation :: Species s => s

-- | A permutation is a set of disjoint cycles: <tt><a>permutation</a> =
--   <a>set</a> `o` <a>cycles</a></tt>.
permutations :: Species s => s

-- | The species of ballots consists of linear orderings of nonempty sets:
--   <tt><a>ballot</a> = <a>linOrd</a> `o` <a>nonEmpty</a>
--   <a>sets</a></tt>.
ballot :: Species s => s

-- | The species of ballots consists of linear orderings of nonempty sets:
--   <tt><a>ballot</a> = <a>linOrd</a> `o` <a>nonEmpty</a>
--   <a>sets</a></tt>.
ballots :: Species s => s

-- | Simple graphs (undirected, without loops). A simple graph is a subset
--   of the set of all size-two subsets of the vertices:
--   <tt><a>simpleGraph</a> = <a>subset</a> @@ (<a>ksubset</a> 2)</tt>.
simpleGraph :: Species s => s

-- | Simple graphs (undirected, without loops). A simple graph is a subset
--   of the set of all size-two subsets of the vertices:
--   <tt><a>simpleGraph</a> = <a>subset</a> @@ (<a>ksubset</a> 2)</tt>.
simpleGraphs :: Species s => s

-- | A directed graph (with loops) is a subset of all pairs drawn (with
--   replacement) from the set of vertices: <tt><a>subset</a> @@
--   (<a>element</a> <a>&gt;&lt;</a> <a>element</a>)</tt>. It can also be
--   thought of as the species of binary relations.
directedGraph :: Species s => s

-- | A directed graph (with loops) is a subset of all pairs drawn (with
--   replacement) from the set of vertices: <tt><a>subset</a> @@
--   (<a>element</a> <a>&gt;&lt;</a> <a>element</a>)</tt>. It can also be
--   thought of as the species of binary relations.
directedGraphs :: Species s => s


-- | Type class instances for <a>TSpeciesAST</a>, <a>ESpeciesAST</a>, and
--   <a>SpeciesAST</a>, in a separate module to avoid a dependency cycle
--   between <a>Math.Combinatorics.Species.AST</a> and
--   <a>Math.Combinatorics.Species.Class</a>.
--   
--   This module also contains functions for reifying species expressions
--   to ASTs and reflecting ASTs back into other species instances, which
--   are in this module since they depend on the AST type class instances.
module Math.Combinatorics.Species.AST.Instances

-- | Reify a species expression into an AST. (Actually, this is just the
--   identity function with a usefully restricted type.) For example:
--   
--   <pre>
--   &gt; reify octopus
--   C . TL+
--   &gt; reify (ksubset 3)
--   E3 * TE
--   </pre>
reify :: SpeciesAST -> SpeciesAST

-- | The same as reify, but produce a typed, size-annotated AST.
reifyE :: ESpeciesAST -> ESpeciesAST

-- | Reflect an AST back into any instance of the <a>Species</a> class.
reflect :: Species s => SpeciesAST -> s

-- | Reflect a typed AST back into any instance of the <a>Species</a>
--   class.
reflectT :: Species s => TSpeciesAST f -> s

-- | Reflect an existentially wrapped typed AST back into any instance of
--   the <a>Species</a> class.
reflectE :: Species s => ESpeciesAST -> s
instance Species ESpeciesAST
instance C ESpeciesAST
instance C ESpeciesAST
instance C ESpeciesAST
instance Show ESpeciesAST
instance Show (TSpeciesAST s)
instance Species SpeciesAST
instance C SpeciesAST
instance C SpeciesAST
instance C SpeciesAST
instance Show SpeciesAST
instance Ord SpeciesAST
instance Eq SpeciesAST


-- | Enumeration (i.e. exhaustive generation of structures) of both labeled
--   and unlabeled species.
module Math.Combinatorics.Species.Enumerate

-- | <tt>enumerate s ls</tt> computes a complete list of distinct
--   <tt>s</tt>-structures over the underlying multiset of labels
--   <tt>ls</tt>. For example:
--   
--   <pre>
--   &gt; enumerate octopi [1,2,3] :: [Comp Cycle [] Int]
--   [&lt;[3,2,1]&gt;,&lt;[3,1,2]&gt;,&lt;[2,3,1]&gt;,&lt;[2,1,3]&gt;,&lt;[1,3,2]&gt;,&lt;[1,2,3]&gt;,
--    &lt;[1],[3,2]&gt;,&lt;[1],[2,3]&gt;,&lt;[3,1],[2]&gt;,&lt;[1,3],[2]&gt;,&lt;[2,1],[3]&gt;,
--    &lt;[1,2],[3]&gt;,&lt;[2],[1],[3]&gt;,&lt;[1],[2],[3]&gt;]
--   
--   &gt; enumerate octopi [1,1,2] :: [Comp Cycle [] Int]
--   [&lt;[2,1,1]&gt;,&lt;[1,2,1]&gt;,&lt;[1,1,2]&gt;,&lt;[2,1],[1]&gt;,&lt;[1,2],[1]&gt;,
--    &lt;[1,1],[2]&gt;,&lt;[1],[1],[2]&gt;]
--   
--   &gt; enumerate subsets "abc" :: [Set Int]
--   [{'a','b','c'},{'a','b'},{'a','c'},{'a'},{'b','c'},{'b'},{'c'},{}]
--   
--   &gt; enumerate simpleGraphs [1,2,3] :: [Comp Set Set Int]
--   [{{1,2},{1,3},{2,3}},{{1,2},{1,3}},{{1,2},{2,3}},{{1,2}},{{1,3},{2,3}},
--    {{1,3}},{{2,3}},{}]
--   </pre>
--   
--   There is one caveat: since the type of the generated structures is
--   different for each species, they must be cast (using the magic of
--   <a>Data.Typeable</a>) out of an existential wrapper; this is why type
--   annotations are required in all the examples above. Of course, if a
--   call to <a>enumerate</a> is used in the context of some larger
--   program, a type annotation will probably not be needed, due to the
--   magic of type inference.
--   
--   For help in knowing what type annotation you can give when enumerating
--   the structures of a particular species at the <tt>ghci</tt> prompt,
--   see the <a>structureType</a> function. To be able to use your own
--   custom data type in an enumeration, just make your data type an
--   instance of the <a>Enumerable</a> type class; this can be done for you
--   automatically by <a>Math.Combinatorics.Species.TH</a>.
--   
--   If an invalid type annotation is given, <a>enumerate</a> will call
--   <a>error</a> with a helpful error message. This should not be much of
--   an issue in practice, since usually <a>enumerate</a> will be used at a
--   specific type; it's hard to imagine a usage of <a>enumerate</a> which
--   will sometimes work and sometimes fail. However, those who like their
--   functions total can use <a>extractStructure</a> to make a version of
--   <a>enumerate</a> (or the other variants) with a return type of
--   <tt>[<a>Either</a> <a>String</a> (f a)]</tt> (which will return an
--   annoying ton of duplicate error messages) or <tt><a>Either</a>
--   <a>String</a> [f a]</tt> (which has the unfortunate property of being
--   much less lazy than the current versions, since it must compute the
--   entire list before deciding whether to return <tt><a>Left</a></tt> or
--   <tt><a>Right</a></tt>).
--   
--   For slight variants on <a>enumerate</a>, see <a>enumerateL</a>,
--   <a>enumerateU</a>, and <a>enumerateM</a>.
enumerate :: (Enumerable f, Typeable a, Eq a) => SpeciesAST -> [a] -> [f a]

-- | Labeled enumeration: given a species expression and a list of labels
--   (which are assumed to be distinct), compute the list of all structures
--   built from the given labels. If the type given for the enumeration
--   does not match the species expression (via an <a>Enumerable</a>
--   instance), call <a>error</a> with an error message explaining the
--   mismatch. This is slightly more efficient than <a>enumerate</a> for
--   lists of labels which are known to be distinct, since it doesn't have
--   to waste time checking for duplicates. (However, it probably doesn't
--   really make much difference, since the time to do the actual
--   enumeration will usually dwarf the time to process the list of labels
--   anyway.)
--   
--   For example:
--   
--   <pre>
--   &gt; enumerateL ballots [1,2,3] :: [Comp [] Set Int]
--   [[{1,2,3}],[{2,3},{1}],[{1},{2,3}],[{2},{1,3}],[{1,3},{2}],[{3},{1,2}]
--   ,[{1,2},{3}],[{3},{2},{1}],[{3},{1},{2}],[{2},{3},{1}],[{2},{1},{3}]
--   ,[{1},{3},{2}],[{1},{2},{3}]]
--   </pre>
enumerateL :: (Enumerable f, Typeable a) => SpeciesAST -> [a] -> [f a]

-- | Unlabeled enumeration: given a species expression and an integer
--   indicating the number of labels to use, compute the list of all
--   unlabeled structures of the given size. If the type given for the
--   enumeration does not match the species expression, call <a>error</a>
--   with an error message explaining the mismatch.
--   
--   Note that <tt><a>enumerateU</a> s n</tt> is equivalent to
--   <tt><a>enumerate</a> s (replicate n ())</tt>.
--   
--   For example:
--   
--   <pre>
--   &gt; enumerateU octopi 4 :: [Comp Cycle [] ()]
--   [&lt;[(),(),(),()]&gt;,&lt;[(),()],[(),()]&gt;,&lt;[(),(),()],[()]&gt;
--   ,&lt;[(),()],[()],[()]&gt;,&lt;[()],[()],[()],[()]&gt;]
--   </pre>
enumerateU :: Enumerable f => SpeciesAST -> Int -> [f ()]

-- | General enumeration: given a species expression and a multiset of
--   labels, compute the list of all distinct structures built from the
--   given labels. If the type given for the enumeration does not match the
--   species expression, call <a>error</a> with a message explaining the
--   mismatch.
enumerateM :: (Enumerable f, Typeable a) => SpeciesAST -> Multiset a -> [f a]

-- | Lazily enumerate all labeled structures, using [1..] as the labels.
--   
--   For example:
--   
--   <pre>
--   &gt; take 10 $ enumerateAll ballots :: [Comp [] Set Int]
--   [[],[{1}],[{1,2}],[{2},{1}],[{1},{2}],[{1,2,3}],[{2,3},{1}]
--   ,[{1},{2,3}],[{2},{1,3}],[{1,3},{2}]]
--   </pre>
enumerateAll :: Enumerable f => SpeciesAST -> [f Int]

-- | Lazily enumerate all unlabeled structures.
--   
--   For example:
--   
--   <pre>
--   &gt; take 10 $ enumerateAllU octopi :: [Comp Cycle [] ()]
--   [&lt;[()]&gt;,&lt;[(),()]&gt;,&lt;[()],[()]&gt;,&lt;[(),(),()]&gt;,&lt;[(),()],[()]&gt;
--   ,&lt;[()],[()],[()]&gt;,&lt;[(),(),(),()]&gt;,&lt;[(),()],[(),()]&gt;
--   ,&lt;[(),(),()],[()]&gt;,&lt;[(),()],[()],[()]&gt;]
--   </pre>
enumerateAllU :: Enumerable f => SpeciesAST -> [f ()]

-- | The <a>Enumerable</a> class allows you to enumerate structures of any
--   type, by declaring an instance of <a>Enumerable</a>. The
--   <a>Enumerable</a> instance requires you to declare a standard
--   structure type (see <a>Math.Combinatorics.Species.Structures</a>)
--   associated with your type, and a mapping <a>iso</a> from the standard
--   type to your custom one. Instances are provided for all the standard
--   structure types so you can enumerate species without having to provide
--   your own custom data type as the target of the enumeration if you
--   don't want to.
--   
--   You should only rarely have to explicitly make an instance of
--   <a>Enumerable</a> yourself; Template Haskell code to derive instances
--   for you is provided in <a>Math.Combinatorics.Species.TH</a>.
class Typeable (StructTy f) => Enumerable (f :: * -> *) where type family StructTy f :: * -> *
iso :: Enumerable f => StructTy f a -> f a

-- | An existential wrapper for structures, hiding the structure functor
--   and ensuring that it is <a>Typeable</a>.
data Structure a
Structure :: f a -> Structure a

-- | Extract the contents from a <a>Structure</a> wrapper, if we know the
--   type, and map it into an isomorphic type. If the type doesn't match,
--   return a helpful error message instead.
extractStructure :: (Enumerable f, Typeable a) => Structure a -> Either String (f a)

-- | A version of <a>extractStructure</a> which calls <a>error</a> with the
--   message in the case of a type mismatch, instead of returning an
--   <a>Either</a>.
unsafeExtractStructure :: (Enumerable f, Typeable a) => Structure a -> f a

-- | <tt><a>structureType</a> s</tt> returns a String representation of the
--   functor type which represents the structure of the species <tt>s</tt>.
--   In particular, if <tt>structureType s</tt> prints <tt>"T"</tt>, then
--   you can safely use <a>enumerate</a> and friends by writing
--   
--   <pre>
--   enumerate s ls :: [T a]
--   </pre>
--   
--   where <tt>ls :: [a]</tt>.
--   
--   For example,
--   
--   <pre>
--   &gt; structureType octopus
--   "Comp Cycle []"
--   &gt; enumerate octopus [1,2,3] :: [Comp Cycle [] Int]
--   [&lt;[3,2,1]&gt;,&lt;[3,1,2]&gt;,&lt;[2,3,1]&gt;,&lt;[2,1,3]&gt;,&lt;[1,3,2]&gt;
--   ,&lt;[1,2,3]&gt;,&lt;[1],[3,2]&gt;,&lt;[1],[2,3]&gt;,&lt;[3,1],[2]&gt;
--   ,&lt;[1,3],[2]&gt;,&lt;[2,1],[3]&gt;,&lt;[1,2],[3]&gt;,&lt;[2],[1],[3]&gt;
--   ,&lt;[1],[2],[3]&gt;]
--   </pre>
--   
--   Note, however, that providing a type annotation on <a>enumerate</a> in
--   this way is usually only necessary at the <tt>ghci</tt> prompt; when
--   used in the context of a larger program the type of a call to
--   <a>enumerate</a> can often be inferred.
structureType :: ESpeciesAST -> String

-- | Show a <a>TypeRep</a> while stripping off qualifier portions of
--   <a>TyCon</a> names. This is essentially copied and pasted from the
--   <a>Data.Typeable</a> source, with a number of cases taken out that we
--   don't care about (special cases for <tt>(-&gt;)</tt>, tuples, etc.).
showStructureType :: TypeRep -> String

-- | Given an AST describing a species, with a phantom type parameter
--   representing the structure of the species, and an underlying multiset
--   of elements, compute a list of all possible structures built over the
--   underlying multiset. (Of course, it would be really nice to have a
--   real dependently-typed language for this!)
--   
--   Unfortunately, <a>TSpeciesAST</a> cannot be made an instance of
--   <tt>Species</tt>, so if we want to be able to enumerate structures
--   given an expression of the <tt>Species</tt> DSL as input, the output
--   must be existentially quantified; see <a>enumerateE</a>.
--   
--   Generating structures over base elements from a <i>multiset</i>
--   unifies labeled and unlabeled generation into one framework. To
--   enumerate labeled structures, use a multiset where each element occurs
--   exactly once; to enumerate unlabeled structures, use a multiset with
--   the desired number of copies of a single element. To do labeled
--   generation we could get away without the generality of multisets, but
--   to do unlabeled generation we need the full generality anyway.
--   
--   <a>enumerate'</a> does all the actual work, but is not meant to be
--   used directly; use one of the specialized <tt>enumerateXX</tt>
--   methods.
enumerate' :: TSpeciesAST s -> Multiset a -> [s a]

-- | <a>enumerateE</a> is a variant of <a>enumerate'</a> which takes an
--   (existentially quantified) typed AST and returns a list of
--   existentially quantified structures. This is also not meant to be used
--   directly. Instead, you should use one of the other <tt>enumerateX</tt>
--   methods.
enumerateE :: ESpeciesAST -> Multiset a -> [Structure a]
instance Enumerable Maybe
instance Typeable f => Enumerable (Mu f)
instance Enumerable Star
instance Enumerable Set
instance Enumerable Bracelet
instance Enumerable Cycle
instance Enumerable []
instance (Enumerable f, Functor f, Enumerable g) => Enumerable (f :.: g)
instance (Enumerable f, Enumerable g) => Enumerable (f :*: g)
instance (Enumerable f, Enumerable g) => Enumerable (f :+: g)
instance Enumerable Id
instance Typeable a => Enumerable (Const a)
instance Enumerable Unit
instance Enumerable Void


-- | Functions to manipulate and simplify species expressions according to
--   algebraic species isomorphisms.
module Math.Combinatorics.Species.Simplify

-- | Given a species expression <tt>s</tt>, return a species expression in
--   normal form which represents a species isomorphic to <tt>s</tt>.
simplify :: SpeciesAST -> SpeciesAST

-- | Simplify a species and decompose it into a sum of products.
sumOfProducts :: SpeciesAST -> [[SpeciesAST]]


-- | The Newton-Raphson iterative method for computing with recursive
--   species. Any species <tt>T</tt> which can be written in the form <tt>T
--   = X*R(T)</tt> (the species of "<tt>R</tt>-enriched rooted trees") may
--   be computed by a quadratically converging iterative process. In fact
--   we may also compute species of the form <tt>T = N + X*R(T)</tt> for
--   any integer species <tt>N</tt>, by iteratively computing <tt>T' =
--   X*R(T' + N)</tt> and then adding <tt>N</tt>.
module Math.Combinatorics.Species.NewtonRaphson

-- | A single iteration of the Newton-Raphson method. <tt>newtonRaphsonIter
--   r k a</tt> assumes that <tt>a</tt> is a species having contact of
--   order <tt>k</tt> with species <tt>t = x <a>*</a> (r ``o`` t)</tt>
--   (that is, <tt>a</tt> and <tt>t</tt> agree on all label sets of size up
--   to and including <tt>k</tt>), and returns a new species with contact
--   of order <tt>2k+2</tt> with <tt>t</tt>.
--   
--   See BLL section 3.3.
newtonRaphsonIter :: Species s => s -> Integer -> s -> s

-- | Given a species <tt>r</tt> and a desired accuracy <tt>k</tt>,
--   <tt><a>newtonRaphson</a> r k</tt> computes a species which has contact
--   at least <tt>k</tt> with the species <tt>t = x <a>*</a> (r ``o``
--   t)</tt>.
newtonRaphson :: Species s => s -> Integer -> s

-- | <tt><a>newtonRaphsonRec</a> f k</tt> tries to compute the recursive
--   species represented by the code <tt>f</tt> up to order at least
--   <tt>k</tt>, using Newton-Raphson iteration. Returns <a>Nothing</a> if
--   <tt>f</tt> cannot be written in the form <tt>f = X*R(f)</tt> for some
--   species <tt>R</tt>.
newtonRaphsonRec :: (ASTFunctor f, Species s) => f -> Integer -> Maybe s

-- | Given a code <tt>f</tt> representing a recursive species, try to find
--   an integer species N and species R such that <tt>f = N + X*R(f)</tt>.
--   If such species can be found, return <tt><a>Just</a> (N,R)</tt>;
--   otherwise return <a>Nothing</a>.
solveForR :: (ASTFunctor f, Species s) => f -> Maybe (s, s)


-- | An interpretation of species as exponential generating functions,
--   which count labeled structures.
module Math.Combinatorics.Species.Labeled

-- | Extract the coefficients of an exponential generating function as a
--   list of <a>Integer</a>s. Since <a>EGF</a> is an instance of
--   <a>Species</a>, the idea is that <a>labeled</a> can be applied
--   directly to an expression of the species DSL. In particular,
--   <tt><a>labeled</a> s <a>!!</a> n</tt> is the number of labeled
--   <tt>s</tt>-structures on an underlying set of size <tt>n</tt> (note
--   that <tt><a>labeled</a> s</tt> is guaranteed to be an infinite list).
--   For example:
--   
--   <pre>
--   &gt; take 10 $ labeled octopi
--   [0,1,3,14,90,744,7560,91440,1285200,20603520]
--   </pre>
--   
--   gives the number of labeled octopi on 0, 1, 2, 3, ... 9 labels.
labeled :: EGF -> [Integer]

-- | A synonym for <a>labeled</a>, since both spellings are acceptable and
--   it's annoying to have to remember which is correct.
labelled :: EGF -> [Integer]
instance Species EGF


-- | An interpretation of species expressions as cycle index series. For
--   details on cycle index series, see "Combinatorial Species and
--   Tree-Like Structures", chapter 1.
module Math.Combinatorics.Species.CycleIndex

-- | Convert a cycle index series to an exponential generating function:
--   F(x) = Z_F(x,0,0,0,...).
zToEGF :: CycleIndex -> EGF

-- | Convert a cycle index series to an ordinary generating function: F~(x)
--   = Z_F(x,x^2,x^3,...).
zToGF :: CycleIndex -> GF

-- | Extract a particular coefficient from a cycle index series.
zCoeff :: CycleIndex -> CycleType -> Rational

-- | Compute <tt>fix F[n]</tt>, i.e. the number of F-structures fixed by a
--   permutation with cycle type n, given the cycle index series Z_F.
--   
--   In particular, <tt>fix F[n] = aut(n) * zCoeff Z_F n</tt>.
zFix :: CycleIndex -> CycleType -> Integer

-- | <tt>aut js</tt> is is the number of automorphisms of a permutation
--   with cycle type <tt>js</tt> (i.e. a permutation which has <tt>n</tt>
--   cycles of size <tt>i</tt> for each <tt>(i,n)</tt> in <tt>js</tt>).
--   Another way to look at it is that there are <tt>n!/aut js</tt>
--   permutations on n elements with cycle type <tt>js</tt>. The result
--   type is a <tt><a>T</a></tt>.
aut :: CycleType -> T

-- | Enumerate all partitions of an integer. In particular, if <tt>p</tt>
--   is an element of the list output by <tt>intPartitions n</tt>, then
--   <tt>sum . map (uncurry (*)) $ p == n</tt>. The result type is
--   <tt>[CycleType]</tt> since each integer partition of <tt>n</tt>
--   corresponds to the cycle type of a permutation on <tt>n</tt> elements.
--   
--   The partitions are generated in an order corresponding to the Ord
--   instance for <tt>Monomial</tt>.
intPartitions :: Integer -> [CycleType]

-- | <tt>cyclePower s n</tt> computes the cycle type of sigma^n, where
--   sigma is any permutation of cycle type s.
--   
--   In particular, if s = (s_1, s_2, s_3, ...) (i.e. sigma has s_1 fixed
--   points, s_2 2-cycles, ... s_k k-cycles), then
--   
--   sigma^n_j = sum_{j*gcd(n,k) = k} gcd(n,k)*s_k
cyclePower :: CycleType -> Integer -> CycleType
instance Species CycleIndex


-- | Use Template Haskell to automatically derive species instances for
--   user-defined data types.
module Math.Combinatorics.Species.TH

-- | Generate default species declarations for the given user-defined data
--   type. To use it:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell,
--                TypeFamilies,
--                DeriveDataTypeable,
--                FlexibleInstances,
--                UndecidableInstances #-}
--   
--   data MyType = ...
--   
--   $(deriveDefaultSpecies ''MyType)
--   </pre>
--   
--   Yes, you really do need all those extensions. And don't panic about
--   the <tt>UndecidableInstances</tt>; the instances generated actually
--   are decidable, but GHC just can't tell.
--   
--   This is what you get:
--   
--   <ul>
--   <li>An <a>Enumerable</a> instance for <tt>MyType</tt> (and various
--   other supporting things like a code and an <a>ASTFunctor</a> instance
--   if your data type is recursive)</li>
--   <li>A declaration of <tt>myType :: Species s =&gt; s</tt> (the same
--   name as the type constructor but with the first letter
--   lowercased)</li>
--   </ul>
--   
--   You can then use <tt>myType</tt> in any species expression, or as
--   input to any function expecting a species. For example, to count your
--   data type's distinct shapes, you can do
--   
--   <pre>
--   take 10 . unlabeled $ myType
--   </pre>
deriveDefaultSpecies :: Name -> Q [Dec]

-- | Like <a>deriveDefaultSpecies</a>, except that you specify the species
--   expression that your data type should be isomorphic to. Note: this is
--   currently experimental (read: bug-ridden).
deriveSpecies :: Name -> SpeciesAST -> Q [Dec]
instance Show Struct


-- | An interpretation of species as ordinary generating functions, which
--   count unlabeled structures.
module Math.Combinatorics.Species.Unlabeled

-- | Extract the coefficients of an ordinary generating function as a list
--   of Integers. In particular, <tt><a>unlabeled</a> s <a>!!</a> n</tt> is
--   the number of unlabeled <tt>s</tt>-structures on an underlying set of
--   size <tt>n</tt> (<tt>unlabeled s</tt> is guaranteed to be infinite).
--   For example:
--   
--   <pre>
--   &gt; take 10 $ unlabeled octopi
--   [0,1,2,3,5,7,13,19,35,59]
--   </pre>
--   
--   gives the number of unlabeled octopi on 0, 1, 2, 3, ... 9 elements.
--   
--   Actually, the above is something of a white lie, as you may have
--   already realized by looking at the input type of <a>unlabeled</a>,
--   which is <a>SpeciesAST</a> rather than the expected <a>GF</a>. The
--   reason is that although products and sums of unlabeled species
--   correspond to products and sums of ordinary generating functions,
--   other operations such as composition and differentiation do not! In
--   order to compute an ordinary generating function for a species defined
--   in terms of composition and/or differentiation, we must compute the
--   cycle index series for the species and then convert it to an ordinary
--   generating function. So <a>unlabeled</a> actually works by first
--   reifying the species to an AST and checking which operations are used
--   in its definition, and then choosing to work with cycle index series
--   or directly with (much faster) ordinary generating functions as
--   appropriate.
unlabeled :: SpeciesAST -> [Integer]

-- | A synonym for <a>unlabeled</a>, since both spellings are acceptable.
unlabelled :: SpeciesAST -> [Integer]
instance Species GF
instance C GF


-- | A DSL for describing and computing with combinatorial species. This
--   module re-exports the most generally useful functionality; for more
--   specialized functionality (for example, computing directly with cycle
--   index series), see the various sub-modules.
--   
--   Note that this library makes extensive use of the numeric-prelude
--   library; to use it you will want to use -XNoImplicitPrelude, and
--   import NumericPrelude and PreludeBase.
--   
--   For a friendly introduction to combinatorial species in general and
--   this library in particular, see my series of blog posts:
--   
--   <ul>
--   
--   <li><a>http://byorgey.wordpress.com/2009/07/24/introducing-math-combinatorics-species/</a></li>
--   
--   <li><a>http://byorgey.wordpress.com/2009/07/30/primitive-species-and-species-operations/</a></li>
--   
--   <li><a>http://byorgey.wordpress.com/2009/07/31/primitive-species-and-species-operations-part-ii/</a></li>
--   </ul>
--   
--   For a good reference (really, the only English-language reference!) on
--   combinatorial species, see Bergeron, Labelle, and Leroux,
--   "Combinatorial Species and Tree-Like Structures", Vol. 67 of the
--   Encyclopedia of Mathematics and its Applications, Gian-Carlo Rota,
--   ed., Cambridge University Press, 1998.
module Math.Combinatorics.Species

-- | The Species type class. Note that the <tt>Differential</tt> constraint
--   requires s to be a differentiable ring, which means that every
--   instance must also implement instances for <a>Algebra.Additive</a>
--   (the species 0 and species addition, i.e. disjoint sum),
--   <a>Algebra.Ring</a> (the species 1 and species multiplication, i.e.
--   partitional product), and <a>Algebra.Differential</a> (species
--   differentiation, i.e. adjoining a distinguished element).
--   
--   Note that the <a>o</a> operation can be used infix to suggest common
--   notation for composition, and also to be read as an abbreviation for
--   "of", as in "top o' the mornin'": <tt>set `o` nonEmpty sets</tt>.
class C s => Species s where linOrd = oneHole cycle subset = set * set ksubset k = (set `ofSizeExactly` k) * set element = singleton * set ofSizeExactly s n = s `ofSize` (== n) nonEmpty = flip ofSize (> 0)
singleton :: Species s => s
set :: Species s => s
cycle :: Species s => s
bracelet :: Species s => s
linOrd :: Species s => s
subset :: Species s => s
ksubset :: Species s => Integer -> s
element :: Species s => s
o :: Species s => s -> s -> s
(><) :: Species s => s -> s -> s
(@@) :: Species s => s -> s -> s
ofSize :: Species s => s -> (Integer -> Bool) -> s
ofSizeExactly :: Species s => s -> Integer -> s
nonEmpty :: Species s => s -> s
rec :: (Species s, ASTFunctor f) => f -> s

-- | A convenient synonym for differentiation. <tt><a>oneHole</a>
--   f</tt>-structures look like <tt>f</tt>-structures on a set formed by
--   adjoining a distinguished "hole" element to the underlying set.
oneHole :: Species s => s -> s

-- | A synonym for <a>singleton</a>.
x :: Species s => s
sets :: Species s => s
cycles :: Species s => s
bracelets :: Species s => s
linOrds :: Species s => s
subsets :: Species s => s
ksubsets :: Species s => Integer -> s
elements :: Species s => s

-- | Intuitively, the operation of pointing picks out a distinguished
--   element from an underlying set. It is equivalent to the operator <tt>x
--   d/dx</tt>: <tt><a>pointed</a> s = <a>singleton</a> *
--   <tt>differentiate</tt> s</tt>.
pointed :: Species s => s -> s

-- | An octopus is a cyclic arrangement of lists, so called because the
--   lists look like "tentacles" attached to the cyclic "body":
--   <tt><a>octopus</a> = <a>cycle</a> `o` <a>nonEmpty</a>
--   <a>linOrds</a></tt>.
octopus :: Species s => s

-- | An octopus is a cyclic arrangement of lists, so called because the
--   lists look like "tentacles" attached to the cyclic "body":
--   <tt><a>octopus</a> = <a>cycle</a> `o` <a>nonEmpty</a>
--   <a>linOrds</a></tt>.
octopi :: Species s => s

-- | The species of set partitions is just the composition <tt><a>set</a>
--   `o` <a>nonEmpty</a> <a>sets</a></tt>.
partition :: Species s => s

-- | The species of set partitions is just the composition <tt><a>set</a>
--   `o` <a>nonEmpty</a> <a>sets</a></tt>.
partitions :: Species s => s

-- | A permutation is a set of disjoint cycles: <tt><a>permutation</a> =
--   <a>set</a> `o` <a>cycles</a></tt>.
permutation :: Species s => s

-- | A permutation is a set of disjoint cycles: <tt><a>permutation</a> =
--   <a>set</a> `o` <a>cycles</a></tt>.
permutations :: Species s => s

-- | The species of ballots consists of linear orderings of nonempty sets:
--   <tt><a>ballot</a> = <a>linOrd</a> `o` <a>nonEmpty</a>
--   <a>sets</a></tt>.
ballot :: Species s => s

-- | The species of ballots consists of linear orderings of nonempty sets:
--   <tt><a>ballot</a> = <a>linOrd</a> `o` <a>nonEmpty</a>
--   <a>sets</a></tt>.
ballots :: Species s => s

-- | Simple graphs (undirected, without loops). A simple graph is a subset
--   of the set of all size-two subsets of the vertices:
--   <tt><a>simpleGraph</a> = <a>subset</a> @@ (<a>ksubset</a> 2)</tt>.
simpleGraph :: Species s => s

-- | Simple graphs (undirected, without loops). A simple graph is a subset
--   of the set of all size-two subsets of the vertices:
--   <tt><a>simpleGraph</a> = <a>subset</a> @@ (<a>ksubset</a> 2)</tt>.
simpleGraphs :: Species s => s

-- | A directed graph (with loops) is a subset of all pairs drawn (with
--   replacement) from the set of vertices: <tt><a>subset</a> @@
--   (<a>element</a> <a>&gt;&lt;</a> <a>element</a>)</tt>. It can also be
--   thought of as the species of binary relations.
directedGraph :: Species s => s

-- | A directed graph (with loops) is a subset of all pairs drawn (with
--   replacement) from the set of vertices: <tt><a>subset</a> @@
--   (<a>element</a> <a>&gt;&lt;</a> <a>element</a>)</tt>. It can also be
--   thought of as the species of binary relations.
directedGraphs :: Species s => s

-- | Extract the coefficients of an exponential generating function as a
--   list of <a>Integer</a>s. Since <a>EGF</a> is an instance of
--   <a>Species</a>, the idea is that <a>labeled</a> can be applied
--   directly to an expression of the species DSL. In particular,
--   <tt><a>labeled</a> s <a>!!</a> n</tt> is the number of labeled
--   <tt>s</tt>-structures on an underlying set of size <tt>n</tt> (note
--   that <tt><a>labeled</a> s</tt> is guaranteed to be an infinite list).
--   For example:
--   
--   <pre>
--   &gt; take 10 $ labeled octopi
--   [0,1,3,14,90,744,7560,91440,1285200,20603520]
--   </pre>
--   
--   gives the number of labeled octopi on 0, 1, 2, 3, ... 9 labels.
labeled :: EGF -> [Integer]

-- | A synonym for <a>labeled</a>, since both spellings are acceptable and
--   it's annoying to have to remember which is correct.
labelled :: EGF -> [Integer]

-- | Extract the coefficients of an ordinary generating function as a list
--   of Integers. In particular, <tt><a>unlabeled</a> s <a>!!</a> n</tt> is
--   the number of unlabeled <tt>s</tt>-structures on an underlying set of
--   size <tt>n</tt> (<tt>unlabeled s</tt> is guaranteed to be infinite).
--   For example:
--   
--   <pre>
--   &gt; take 10 $ unlabeled octopi
--   [0,1,2,3,5,7,13,19,35,59]
--   </pre>
--   
--   gives the number of unlabeled octopi on 0, 1, 2, 3, ... 9 elements.
--   
--   Actually, the above is something of a white lie, as you may have
--   already realized by looking at the input type of <a>unlabeled</a>,
--   which is <a>SpeciesAST</a> rather than the expected <a>GF</a>. The
--   reason is that although products and sums of unlabeled species
--   correspond to products and sums of ordinary generating functions,
--   other operations such as composition and differentiation do not! In
--   order to compute an ordinary generating function for a species defined
--   in terms of composition and/or differentiation, we must compute the
--   cycle index series for the species and then convert it to an ordinary
--   generating function. So <a>unlabeled</a> actually works by first
--   reifying the species to an AST and checking which operations are used
--   in its definition, and then choosing to work with cycle index series
--   or directly with (much faster) ordinary generating functions as
--   appropriate.
unlabeled :: SpeciesAST -> [Integer]

-- | A synonym for <a>unlabeled</a>, since both spellings are acceptable.
unlabelled :: SpeciesAST -> [Integer]

-- | The <a>Enumerable</a> class allows you to enumerate structures of any
--   type, by declaring an instance of <a>Enumerable</a>. The
--   <a>Enumerable</a> instance requires you to declare a standard
--   structure type (see <a>Math.Combinatorics.Species.Structures</a>)
--   associated with your type, and a mapping <a>iso</a> from the standard
--   type to your custom one. Instances are provided for all the standard
--   structure types so you can enumerate species without having to provide
--   your own custom data type as the target of the enumeration if you
--   don't want to.
--   
--   You should only rarely have to explicitly make an instance of
--   <a>Enumerable</a> yourself; Template Haskell code to derive instances
--   for you is provided in <a>Math.Combinatorics.Species.TH</a>.
class Typeable (StructTy f) => Enumerable (f :: * -> *) where type family StructTy f :: * -> *
iso :: Enumerable f => StructTy f a -> f a

-- | <tt><a>structureType</a> s</tt> returns a String representation of the
--   functor type which represents the structure of the species <tt>s</tt>.
--   In particular, if <tt>structureType s</tt> prints <tt>"T"</tt>, then
--   you can safely use <a>enumerate</a> and friends by writing
--   
--   <pre>
--   enumerate s ls :: [T a]
--   </pre>
--   
--   where <tt>ls :: [a]</tt>.
--   
--   For example,
--   
--   <pre>
--   &gt; structureType octopus
--   "Comp Cycle []"
--   &gt; enumerate octopus [1,2,3] :: [Comp Cycle [] Int]
--   [&lt;[3,2,1]&gt;,&lt;[3,1,2]&gt;,&lt;[2,3,1]&gt;,&lt;[2,1,3]&gt;,&lt;[1,3,2]&gt;
--   ,&lt;[1,2,3]&gt;,&lt;[1],[3,2]&gt;,&lt;[1],[2,3]&gt;,&lt;[3,1],[2]&gt;
--   ,&lt;[1,3],[2]&gt;,&lt;[2,1],[3]&gt;,&lt;[1,2],[3]&gt;,&lt;[2],[1],[3]&gt;
--   ,&lt;[1],[2],[3]&gt;]
--   </pre>
--   
--   Note, however, that providing a type annotation on <a>enumerate</a> in
--   this way is usually only necessary at the <tt>ghci</tt> prompt; when
--   used in the context of a larger program the type of a call to
--   <a>enumerate</a> can often be inferred.
structureType :: ESpeciesAST -> String

-- | <tt>enumerate s ls</tt> computes a complete list of distinct
--   <tt>s</tt>-structures over the underlying multiset of labels
--   <tt>ls</tt>. For example:
--   
--   <pre>
--   &gt; enumerate octopi [1,2,3] :: [Comp Cycle [] Int]
--   [&lt;[3,2,1]&gt;,&lt;[3,1,2]&gt;,&lt;[2,3,1]&gt;,&lt;[2,1,3]&gt;,&lt;[1,3,2]&gt;,&lt;[1,2,3]&gt;,
--    &lt;[1],[3,2]&gt;,&lt;[1],[2,3]&gt;,&lt;[3,1],[2]&gt;,&lt;[1,3],[2]&gt;,&lt;[2,1],[3]&gt;,
--    &lt;[1,2],[3]&gt;,&lt;[2],[1],[3]&gt;,&lt;[1],[2],[3]&gt;]
--   
--   &gt; enumerate octopi [1,1,2] :: [Comp Cycle [] Int]
--   [&lt;[2,1,1]&gt;,&lt;[1,2,1]&gt;,&lt;[1,1,2]&gt;,&lt;[2,1],[1]&gt;,&lt;[1,2],[1]&gt;,
--    &lt;[1,1],[2]&gt;,&lt;[1],[1],[2]&gt;]
--   
--   &gt; enumerate subsets "abc" :: [Set Int]
--   [{'a','b','c'},{'a','b'},{'a','c'},{'a'},{'b','c'},{'b'},{'c'},{}]
--   
--   &gt; enumerate simpleGraphs [1,2,3] :: [Comp Set Set Int]
--   [{{1,2},{1,3},{2,3}},{{1,2},{1,3}},{{1,2},{2,3}},{{1,2}},{{1,3},{2,3}},
--    {{1,3}},{{2,3}},{}]
--   </pre>
--   
--   There is one caveat: since the type of the generated structures is
--   different for each species, they must be cast (using the magic of
--   <a>Data.Typeable</a>) out of an existential wrapper; this is why type
--   annotations are required in all the examples above. Of course, if a
--   call to <a>enumerate</a> is used in the context of some larger
--   program, a type annotation will probably not be needed, due to the
--   magic of type inference.
--   
--   For help in knowing what type annotation you can give when enumerating
--   the structures of a particular species at the <tt>ghci</tt> prompt,
--   see the <a>structureType</a> function. To be able to use your own
--   custom data type in an enumeration, just make your data type an
--   instance of the <a>Enumerable</a> type class; this can be done for you
--   automatically by <a>Math.Combinatorics.Species.TH</a>.
--   
--   If an invalid type annotation is given, <a>enumerate</a> will call
--   <a>error</a> with a helpful error message. This should not be much of
--   an issue in practice, since usually <a>enumerate</a> will be used at a
--   specific type; it's hard to imagine a usage of <a>enumerate</a> which
--   will sometimes work and sometimes fail. However, those who like their
--   functions total can use <a>extractStructure</a> to make a version of
--   <a>enumerate</a> (or the other variants) with a return type of
--   <tt>[<a>Either</a> <a>String</a> (f a)]</tt> (which will return an
--   annoying ton of duplicate error messages) or <tt><a>Either</a>
--   <a>String</a> [f a]</tt> (which has the unfortunate property of being
--   much less lazy than the current versions, since it must compute the
--   entire list before deciding whether to return <tt><a>Left</a></tt> or
--   <tt><a>Right</a></tt>).
--   
--   For slight variants on <a>enumerate</a>, see <a>enumerateL</a>,
--   <a>enumerateU</a>, and <a>enumerateM</a>.
enumerate :: (Enumerable f, Typeable a, Eq a) => SpeciesAST -> [a] -> [f a]

-- | Labeled enumeration: given a species expression and a list of labels
--   (which are assumed to be distinct), compute the list of all structures
--   built from the given labels. If the type given for the enumeration
--   does not match the species expression (via an <a>Enumerable</a>
--   instance), call <a>error</a> with an error message explaining the
--   mismatch. This is slightly more efficient than <a>enumerate</a> for
--   lists of labels which are known to be distinct, since it doesn't have
--   to waste time checking for duplicates. (However, it probably doesn't
--   really make much difference, since the time to do the actual
--   enumeration will usually dwarf the time to process the list of labels
--   anyway.)
--   
--   For example:
--   
--   <pre>
--   &gt; enumerateL ballots [1,2,3] :: [Comp [] Set Int]
--   [[{1,2,3}],[{2,3},{1}],[{1},{2,3}],[{2},{1,3}],[{1,3},{2}],[{3},{1,2}]
--   ,[{1,2},{3}],[{3},{2},{1}],[{3},{1},{2}],[{2},{3},{1}],[{2},{1},{3}]
--   ,[{1},{3},{2}],[{1},{2},{3}]]
--   </pre>
enumerateL :: (Enumerable f, Typeable a) => SpeciesAST -> [a] -> [f a]

-- | Unlabeled enumeration: given a species expression and an integer
--   indicating the number of labels to use, compute the list of all
--   unlabeled structures of the given size. If the type given for the
--   enumeration does not match the species expression, call <a>error</a>
--   with an error message explaining the mismatch.
--   
--   Note that <tt><a>enumerateU</a> s n</tt> is equivalent to
--   <tt><a>enumerate</a> s (replicate n ())</tt>.
--   
--   For example:
--   
--   <pre>
--   &gt; enumerateU octopi 4 :: [Comp Cycle [] ()]
--   [&lt;[(),(),(),()]&gt;,&lt;[(),()],[(),()]&gt;,&lt;[(),(),()],[()]&gt;
--   ,&lt;[(),()],[()],[()]&gt;,&lt;[()],[()],[()],[()]&gt;]
--   </pre>
enumerateU :: Enumerable f => SpeciesAST -> Int -> [f ()]

-- | General enumeration: given a species expression and a multiset of
--   labels, compute the list of all distinct structures built from the
--   given labels. If the type given for the enumeration does not match the
--   species expression, call <a>error</a> with a message explaining the
--   mismatch.
enumerateM :: (Enumerable f, Typeable a) => SpeciesAST -> Multiset a -> [f a]

-- | Lazily enumerate all labeled structures, using [1..] as the labels.
--   
--   For example:
--   
--   <pre>
--   &gt; take 10 $ enumerateAll ballots :: [Comp [] Set Int]
--   [[],[{1}],[{1,2}],[{2},{1}],[{1},{2}],[{1,2,3}],[{2,3},{1}]
--   ,[{1},{2,3}],[{2},{1,3}],[{1,3},{2}]]
--   </pre>
enumerateAll :: Enumerable f => SpeciesAST -> [f Int]

-- | Lazily enumerate all unlabeled structures.
--   
--   For example:
--   
--   <pre>
--   &gt; take 10 $ enumerateAllU octopi :: [Comp Cycle [] ()]
--   [&lt;[()]&gt;,&lt;[(),()]&gt;,&lt;[()],[()]&gt;,&lt;[(),(),()]&gt;,&lt;[(),()],[()]&gt;
--   ,&lt;[()],[()],[()]&gt;,&lt;[(),(),(),()]&gt;,&lt;[(),()],[(),()]&gt;
--   ,&lt;[(),(),()],[()]&gt;,&lt;[(),()],[()],[()]&gt;]
--   </pre>
enumerateAllU :: Enumerable f => SpeciesAST -> [f ()]

-- | The (constantly) void functor.
data Void a

-- | The (constantly) unit functor.
data Unit a
Unit :: Unit a

-- | The identity functor.
newtype Id a
Id :: a -> Id a

-- | The constant functor.
newtype Const x a
Const :: x -> Const x a

-- | Functor coproduct.
data (:+:) f g a
Inl :: (f a) -> (:+:) f g a
Inr :: (g a) -> (:+:) f g a

-- | Functor product.
data (:*:) f g a
(:*:) :: f a -> g a -> (:*:) f g a

-- | Functor composition.
data (:.:) f g a
Comp :: (f (g a)) -> (:.:) f g a
unComp :: (:.:) f g a -> (f (g a))

-- | <a>Star</a> is isomorphic to <a>Maybe</a>, but with a more useful
--   <a>Show</a> instance for our purposes. Used to implement species
--   differentiation.
data Star a
Star :: Star a
Original :: a -> Star a

-- | Cycle structure. A value of type <tt><a>Cycle</a> a</tt> is
--   implemented as <tt>[a]</tt>, but thought of as a directed cycle.
newtype Cycle a
Cycle :: [a] -> Cycle a
getCycle :: Cycle a -> [a]

-- | Bracelet structure. A value of type <tt><a>Bracelet</a> a</tt> is
--   implemented as <tt>[a]</tt>, but thought of as an undirected cycle
--   (i.e. equivalent up to rotations as well as flips/reversals).
newtype Bracelet a
Bracelet :: [a] -> Bracelet a
getBracelet :: Bracelet a -> [a]

-- | Set structure. A value of type <tt><a>Set</a> a</tt> is implemented as
--   <tt>[a]</tt>, but thought of as an unordered set.
newtype Set a
Set :: [a] -> Set a
getSet :: Set a -> [a]

-- | A basic, untyped AST type for species expressions, for easily doing
--   things like analysis, simplification, deriving isomorphisms, and so
--   on. Converting between <a>SpeciesAST</a> and the typed variant
--   <a>ESpeciesAST</a> can be done with <a>annotate</a> and <a>erase</a>.
data SpeciesAST

-- | Reify a species expression into an AST. (Actually, this is just the
--   identity function with a usefully restricted type.) For example:
--   
--   <pre>
--   &gt; reify octopus
--   C . TL+
--   &gt; reify (ksubset 3)
--   E3 * TE
--   </pre>
reify :: SpeciesAST -> SpeciesAST

-- | Reflect an AST back into any instance of the <a>Species</a> class.
reflect :: Species s => SpeciesAST -> s

-- | A variant of <a>SpeciesAST</a> with a phantom type parameter which
--   also reflects the structure, so we can write quasi-dependently-typed
--   functions over species, in particular for species enumeration.
--   
--   Of course, the non-uniform type parameter means that
--   <a>TSpeciesAST</a> cannot be an instance of the <tt>Species</tt>
--   class; for that purpose the existential wrapper <a>ESpeciesAST</a> is
--   provided.
--   
--   <a>TSpeciesAST</a> is defined via mutual recursion with
--   <a>SizedSpeciesAST</a>, which pairs a <a>TSpeciesAST</a> with an
--   interval annotation indicating (a conservative approximation of) the
--   label set sizes for which the species actually yields any structures;
--   this information makes enumeration faster and also prevents it from
--   getting stuck in infinite recursion in some cases. A value of
--   <a>SizedSpeciesAST</a> is thus an annotated species expression tree
--   with interval annotations at every node.
data TSpeciesAST (s :: * -> *)

-- | An existential wrapper to hide the phantom type parameter to
--   <a>SizedSpeciesAST</a>, so we can make it an instance of
--   <tt>Species</tt>.
data ESpeciesAST

-- | Construct an <a>ESpeciesAST</a> from a <a>TSpeciesAST</a> by adding an
--   appropriate interval annotation and hiding the type.
wrap :: Typeable s => TSpeciesAST s -> ESpeciesAST

-- | Unwrap an existential wrapper to get out a typed AST. You can get out
--   any type you like as long as it is the right one.
--   
--   CAUTION: Don't try this at home!
unwrap :: Typeable s => ESpeciesAST -> TSpeciesAST s

-- | Erase the type and interval information from an existentially wrapped
--   species AST.
erase :: ESpeciesAST -> SpeciesAST

-- | Erase the type and interval information from a typed species AST.
erase' :: TSpeciesAST f -> SpeciesAST

-- | Reconstruct the type and interval annotations on a species AST.
annotate :: SpeciesAST -> ESpeciesAST

-- | Given a species expression <tt>s</tt>, return a species expression in
--   normal form which represents a species isomorphic to <tt>s</tt>.
simplify :: SpeciesAST -> SpeciesAST

-- | Simplify a species and decompose it into a sum of products.
sumOfProducts :: SpeciesAST -> [[SpeciesAST]]

-- | <a>ASTFunctor</a> is a type class for codes which can be interpreted
--   (via the <a>Interp</a> type family) as higher-order functors over
--   species expressions. The <a>apply</a> method allows such codes to be
--   applied to a species AST. The indirection is needed to implement
--   recursive species.
class (Typeable f, Show f, Typeable (Interp f (Mu f))) => ASTFunctor f
apply :: (ASTFunctor f, Typeable g) => f -> TSpeciesAST g -> TSpeciesAST (Interp f g)

-- | Interpretation type function for codes for higher-order type
--   constructors, used as arguments to the higher-order fixpoint
--   <a>Mu</a>.

-- | <tt><a>newtonRaphsonRec</a> f k</tt> tries to compute the recursive
--   species represented by the code <tt>f</tt> up to order at least
--   <tt>k</tt>, using Newton-Raphson iteration. Returns <a>Nothing</a> if
--   <tt>f</tt> cannot be written in the form <tt>f = X*R(f)</tt> for some
--   species <tt>R</tt>.
newtonRaphsonRec :: (ASTFunctor f, Species s) => f -> Integer -> Maybe s

-- | Given a species <tt>r</tt> and a desired accuracy <tt>k</tt>,
--   <tt><a>newtonRaphson</a> r k</tt> computes a species which has contact
--   at least <tt>k</tt> with the species <tt>t = x <a>*</a> (r ``o``
--   t)</tt>.
newtonRaphson :: Species s => s -> Integer -> s

-- | Generate default species declarations for the given user-defined data
--   type. To use it:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell,
--                TypeFamilies,
--                DeriveDataTypeable,
--                FlexibleInstances,
--                UndecidableInstances #-}
--   
--   data MyType = ...
--   
--   $(deriveDefaultSpecies ''MyType)
--   </pre>
--   
--   Yes, you really do need all those extensions. And don't panic about
--   the <tt>UndecidableInstances</tt>; the instances generated actually
--   are decidable, but GHC just can't tell.
--   
--   This is what you get:
--   
--   <ul>
--   <li>An <a>Enumerable</a> instance for <tt>MyType</tt> (and various
--   other supporting things like a code and an <a>ASTFunctor</a> instance
--   if your data type is recursive)</li>
--   <li>A declaration of <tt>myType :: Species s =&gt; s</tt> (the same
--   name as the type constructor but with the first letter
--   lowercased)</li>
--   </ul>
--   
--   You can then use <tt>myType</tt> in any species expression, or as
--   input to any function expecting a species. For example, to count your
--   data type's distinct shapes, you can do
--   
--   <pre>
--   take 10 . unlabeled $ myType
--   </pre>
deriveDefaultSpecies :: Name -> Q [Dec]

-- | Like <a>deriveDefaultSpecies</a>, except that you specify the species
--   expression that your data type should be isomorphic to. Note: this is
--   currently experimental (read: bug-ridden).
deriveSpecies :: Name -> SpeciesAST -> Q [Dec]
