-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An extensible log effect using extensible-effects
--   
--   Any help (especially documentation) is very welcome,
@package log-effect
@version 0.4.0.1

module Control.Eff.Log
data Log a v
Log :: a -> v -> Log a v

-- | a monadic action that does the real logging
type Logger m l = forall v. Log l v -> m ()

-- | Log something.
logE :: (Typeable l, Member (Log l) r) => l -> Eff r ()

-- | Filter Log entries with a predicate.
--   
--   Note that, most of the time an explicit type signature for the
--   predicate will be required.
filterLog :: (Typeable l, Member (Log l) r) => (l -> Bool) -> Eff r a -> Eff r a

-- | Filter Log entries with a predicate and a proxy.
--   
--   This is the same as <a>filterLog</a> but with a proxy l for type
--   inference.
filterLog' :: (Typeable l, Member (Log l) r) => (l -> Bool) -> proxy l -> Eff r a -> Eff r a

-- | Collect log messages in a list.
runLogPure :: Typeable l => Eff (Log l :> r) a -> Eff r (a, [l])

-- | Log to stdout.
runLogStdout :: (Typeable l, ToLogStr l, SetMember Lift (Lift IO) r) => proxy l -> Eff (Log l :> r) a -> Eff r a

-- | Log to stderr.
runLogStderr :: (Typeable l, ToLogStr l, SetMember Lift (Lift IO) r) => proxy l -> Eff (Log l :> r) a -> Eff r a

-- | Log to file.
runLogFile :: (Typeable l, ToLogStr l, SetMember Lift (Lift IO) r) => FilePath -> proxy l -> Eff (Log l :> r) a -> Eff r a

-- | Log to a file using a <a>LoggerSet</a>.
--   
--   Note, that you will still have to call <a>flushLogStr</a> on the
--   <a>LoggerSet</a> at one point.
--   
--   With that function you can combine a logger in a surrounding IO action
--   with a logger in the <a>Eff</a> effect.
--   
--   <pre>
--   data Proxy a = Proxy
--   
--    main :: IO ()
--    main = do
--        loggerSet &lt;- newStderrLoggerSet defaultBufSize
--        pushLogStr loggerSet "logging from outer space^WIO\n"
--        runLift $ runLogWithLoggerSet loggerSet (Proxy :: Proxy String) $
--            logE ("logging from within Eff" :: String)
--        flushLogStr loggerSet
--   </pre>
runLogWithLoggerSet :: (Typeable l, ToLogStr l, SetMember Lift (Lift IO) r) => LoggerSet -> proxy l -> Eff (Log l :> r) a -> Eff r a

-- | Run the <a>Logger</a> action in the base monad for every log line.
runLog :: (Typeable l, Typeable1 m, SetMember Lift (Lift m) r) => Logger m l -> Eff (Log l :> r) a -> Eff r a
instance Typeable2 Log
instance Functor (Log a)

module Control.Eff.Log.Simple
type SimpleLog a = Log (Severity, a)
data Severity
DEBUG :: Severity
INFO :: Severity
NOTICE :: Severity
WARNING :: Severity
ERROR :: Severity
CRITICAL :: Severity
ALERT :: Severity
PANIC :: Severity
logTo :: (Typeable l, Member (Log (Severity, l)) r) => Severity -> l -> Eff r ()
debug :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
info :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
notice :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
warning :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
error :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
critical :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
alert :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
panic :: (Typeable l, Member (Log (Severity, l)) r) => l -> Eff r ()
instance Typeable Severity
instance Bounded Severity
instance Enum Severity
instance Eq Severity
instance Ord Severity
instance Read Severity
instance Show Severity
instance ToLogStr a => ToLogStr (Severity, a)
instance ToLogStr Severity
