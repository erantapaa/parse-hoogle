-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sized types in Haskell using the GHC Nat kind.
--   
@package sized-types
@version 0.5.1


-- | Fin types
--   
--   Copyright: (c) 2013 University of Kansas License: BSD3
--   
--   Maintainer: Andy Gill <a>andygill@ku.edu</a> Stability: unstable
--   Portability: ghc
module Data.Sized.Fin
data Fin (n :: Nat)
fromNat :: Sing (n :: Nat) -> Integer
corners :: Bounded i => (i, i)

-- | A list of all possible values of a type.
universe :: (Bounded ix, Ix ix) => [ix]
size :: (Bounded ix, Ix ix) => ix -> Int

-- | (Kind) This is the kind of type-level natural numbers.
data Nat :: *
instance Typeable Fin
instance Eq (Fin n)
instance Ord (Fin n)
instance SingI a => Integral (Fin a)
instance SingI a => Real (Fin a)
instance Enum (Fin a)
instance SingI a => Bounded (Fin a)
instance SingI a => Ix (Fin a)
instance SingI a => Num (Fin a)
instance SingI a => Read (Fin a)
instance Show (Fin a)


-- | Sized matrixes.
--   
--   Copyright: (c) 2013 University of Kansas License: BSD3
--   
--   Maintainer: Andy Gill <a>andygill@ku.edu</a> Stability: unstable
--   Portability: ghc
module Data.Sized.Matrix

-- | A <a>Matrix</a> is an array with the size determined uniquely by the
--   <i>type</i> of the index type, <tt>ix</tt>, with every type in
--   <tt>ix</tt> used.
newtype Matrix ix a
Matrix :: (Array ix a) -> Matrix ix a

-- | A <a>Vector</a> is a 1D Matrix, using a TypeNat to define its length.
type Vector (ix :: Nat) a = Matrix (Fin ix) a

-- | A <a>Vector2</a> is a 2D Matrix, using a TypeNat's to define its size.
type Vector2 (ix :: Nat) (iy :: Nat) a = Matrix (Fin ix, Fin iy) a

-- | <a>matrix</a> turns a finite list into a matrix. You often need to
--   give the type of the result.
matrix :: (Bounded i, Ix i) => [a] -> Matrix i a

-- | what is the population of a matrix?
population :: (Bounded i, Ix i) => Matrix i a -> Int
allIndices :: (Bounded i, Ix i) => Matrix i a -> [i]

-- | <a>zeroOf</a> is for use to force typing issues, and is 0.
zeroOf :: (Bounded i, Ix i) => Matrix i a -> i

-- | <a>coord</a> returns a matrix filled with indexes.
coord :: (Bounded i, Ix i) => Matrix i i

-- | Same as for lists.
zipWith :: (Bounded i, Ix i) => (a -> b -> c) -> Matrix i a -> Matrix i b -> Matrix i c

-- | <a>forEach</a> takes a matrix, and calls a function for each element,
--   to give a new matrix of the same size.
forEach :: (Bounded i, Ix i) => Matrix i a -> (i -> a -> b) -> Matrix i b

-- | <a>forAll</a> creates a matrix out of a mapping from the coordinates.
forAll :: (Bounded i, Ix i) => (i -> a) -> Matrix i a

-- | <a>mm</a> is the 2D matrix multiply.
mm :: (Bounded m, Ix m, Bounded n, Ix n, Bounded o, Ix o, Num a) => Matrix (m, n) a -> Matrix (n, o) a -> Matrix (m, o) a

-- | <a>transpose</a> a 2D matrix.
transpose :: (Bounded x, Ix x, Bounded y, Ix y) => Matrix (x, y) a -> Matrix (y, x) a

-- | return the identity for a specific matrix size.
identity :: (Bounded x, Ix x, Num a) => Matrix (x, x) a

-- | append to 1D vectors
append :: (SingI left, SingI right, SingI (left + right)) => Vector left a -> Vector right a -> Vector (left + right) a

-- | stack two matrixes <a>above</a> each other.
above :: (SingI top, SingI bottom, SingI y, SingI (top + bottom)) => Vector2 top y a -> Vector2 bottom y a -> Vector2 (top + bottom) y a

-- | stack two matrixes <a>beside</a> each other.
beside :: (SingI left, SingI right, SingI x, SingI (left + right)) => Vector2 x left a -> Vector2 x right a -> Vector2 x (left + right) a

-- | look at a matrix through a functor lens, to another matrix.
ixfmap :: (Bounded i, Ix i, Bounded j, Ix j, Functor f) => (i -> f j) -> Matrix j a -> Matrix i (f a)

-- | grab <i>part</i> of a matrix. cropAt :: (Index i ~ Index ix, Bounded
--   i, Ix i, Bounded ix, Ix ix) =&gt; Matrix ix a -&gt; ix -&gt; Matrix i
--   a cropAt m corner = ixmap ( i -&gt; (addIndex corner (toIndex i))) m
--   
--   slice a 2D matrix into rows.
rows :: (Bounded n, Ix n, Bounded m, Ix m) => Matrix (m, n) a -> Matrix m (Matrix n a)

-- | slice a 2D matrix into columns.
columns :: (Bounded n, Ix n, Bounded m, Ix m) => Matrix (m, n) a -> Matrix n (Matrix m a)

-- | join a matrix of matrixes into a single matrix.
joinRows :: (Bounded n, Ix n, Bounded m, Ix m) => Matrix m (Matrix n a) -> Matrix (m, n) a

-- | join a matrix of matrixes into a single matrix.
joinColumns :: (Bounded n, Ix n, Bounded m, Ix m) => Matrix n (Matrix m a) -> Matrix (m, n) a

-- | <a>show2D</a> displays a 2D matrix, and is the worker for <a>show</a>.
--   
--   <pre>
--   GHCi&gt; matrix [1..42] :: Matrix (Fin 7, Fin 6) Int
--   [  1,  2,  3,  4,  5,  6,
--      7,  8,  9, 10, 11, 12,
--     13, 14, 15, 16, 17, 18,
--     19, 20, 21, 22, 23, 24,
--     25, 26, 27, 28, 29, 30,
--     31, 32, 33, 34, 35, 36,
--     37, 38, 39, 40, 41, 42 ]
--   </pre>
show2D :: (Bounded n, Ix n, Bounded m, Ix m, Show a) => Matrix (m, n) a -> String

-- | <a>S</a> is shown as the contents, without the quotes. One use is a
--   matrix of S, so that you can do show-style functions using fmap.
newtype S
S :: String -> S
showAsE :: RealFloat a => Int -> a -> S
showAsF :: RealFloat a => Int -> a -> S
instance Typeable Matrix
instance (Eq a, Ix ix) => Eq (Matrix ix a)
instance (Ord a, Ix ix) => Ord (Matrix ix a)
instance Show S
instance (Show a, Show ix, Bounded ix, Ix ix) => Show (Matrix ix a)
instance (Bounded ix, Ix ix) => Foldable (Matrix ix)
instance (Bounded ix, Ix ix) => Traversable (Matrix ix)
instance (Bounded i, Ix i) => Applicative (Matrix i)
instance IArray Matrix a
instance Ix ix => Functor (Matrix ix)


-- | Sparse Matrix.
--   
--   Copyright: (c) 2009 University of Kansas License: BSD3
--   
--   Maintainer: Andy Gill <a>andygill@ku.edu</a> Stability: unstable
--   Portability: ghc
module Data.Sized.Sparse.Matrix
data SpMatrix ix a
SpMatrix :: a -> (Map ix a) -> SpMatrix ix a
fromAssocList :: (Ord i, Eq a) => a -> [(i, a)] -> SpMatrix i a
toAssocList :: (SpMatrix i a) -> (a, [(i, a)])

-- | <a>getElem</a> looks up an element in the sparse matrix. If the
--   element is not found in the sparse matrix, <a>getElem</a> returns the
--   default value.
getElem :: Ord ix => SpMatrix ix a -> ix -> a
fill :: (Bounded ix, Ix ix) => SpMatrix ix a -> Matrix ix a
prune :: (Bounded ix, Ix ix, Eq a) => a -> SpMatrix ix a -> SpMatrix ix a

-- | Make a Matrix sparse, with a default <tt>zero</tt> value.
sparse :: (Bounded ix, Ix ix, Eq a) => a -> Matrix ix a -> SpMatrix ix a
mm :: (Bounded m, Ix m, Bounded n, Ix n, Bounded m', Ix m', Bounded n', Ix n', n ~ m', Num a, Eq a) => SpMatrix (m, n) a -> SpMatrix (m', n') a -> SpMatrix (m, n') a
rowSets :: (Bounded a, Ix a, Ord b) => Set (a, b) -> Matrix a (Set b)
columnSets :: (Bounded b, Ix b, Ord a) => Set (a, b) -> Matrix b (Set a)
transpose :: (Bounded x, Ix x, Bounded y, Ix y, Eq a) => SpMatrix (x, y) a -> SpMatrix (y, x) a
zipWith :: (Bounded x, Ix x) => (a -> b -> c) -> SpMatrix x a -> SpMatrix x b -> SpMatrix x c
instance (Show a, Show ix, Bounded ix, Ix ix) => Show (SpMatrix ix a)
instance (Bounded i, Ix i) => Applicative (SpMatrix i)
instance Functor (SpMatrix ix)


-- | Signed, fixed sized numbers.
--   
--   Copyright: (c) 2009 University of Kansas License: BSD3
--   
--   Maintainer: Andy Gill <a>andygill@ku.edu</a> Stability: unstable
--   Portability: ghc
module Data.Sized.Signed
data Signed (ix :: Nat)
toVector :: SingI ix => Signed ix -> Vector ix Bool
fromVector :: SingI ix => Vector ix Bool -> Signed ix
type S2 = Signed 2
type S3 = Signed 3
type S4 = Signed 4
type S5 = Signed 5
type S6 = Signed 6
type S7 = Signed 7
type S8 = Signed 8
type S9 = Signed 9
type S10 = Signed 10
type S11 = Signed 11
type S12 = Signed 12
type S13 = Signed 13
type S14 = Signed 14
type S15 = Signed 15
type S16 = Signed 16
type S17 = Signed 17
type S18 = Signed 18
type S19 = Signed 19
type S20 = Signed 20
type S21 = Signed 21
type S22 = Signed 22
type S23 = Signed 23
type S24 = Signed 24
type S25 = Signed 25
type S26 = Signed 26
type S27 = Signed 27
type S28 = Signed 28
type S29 = Signed 29
type S30 = Signed 30
type S31 = Signed 31
type S32 = Signed 32
instance Typeable Signed
instance Eq (Signed ix)
instance Ord (Signed ix)
instance SingI ix => Bounded (Signed ix)
instance SingI ix => FiniteBits (Signed ix)
instance SingI ix => Bits (Signed ix)
instance SingI ix => Enum (Signed ix)
instance SingI ix => Real (Signed ix)
instance SingI ix => Num (Signed ix)
instance SingI ix => Integral (Signed ix)
instance SingI ix => Read (Signed ix)
instance SingI ix => Show (Signed ix)


-- | Unsigned, fixed sized numbers.
--   
--   Copyright: (c) 2009 University of Kansas License: BSD3
--   
--   Maintainer: Andy Gill <a>andygill@ku.edu</a> Stability: unstable
--   Portability: ghc
module Data.Sized.Unsigned
data Unsigned (ix :: Nat)
toVector :: SingI ix => Unsigned ix -> Vector ix Bool
fromVector :: SingI ix => Vector ix Bool -> Unsigned ix
showBits :: SingI ix => Unsigned ix -> String

-- | common; numerically boolean.
type U1 = Unsigned 1
type U2 = Unsigned 2
type U3 = Unsigned 3
type U4 = Unsigned 4
type U5 = Unsigned 5
type U6 = Unsigned 6
type U7 = Unsigned 7
type U8 = Unsigned 8
type U9 = Unsigned 9
type U10 = Unsigned 10
type U11 = Unsigned 11
type U12 = Unsigned 12
type U13 = Unsigned 13
type U14 = Unsigned 14
type U15 = Unsigned 15
type U16 = Unsigned 16
type U17 = Unsigned 17
type U18 = Unsigned 18
type U19 = Unsigned 19
type U20 = Unsigned 20
type U21 = Unsigned 21
type U22 = Unsigned 22
type U23 = Unsigned 23
type U24 = Unsigned 24
type U25 = Unsigned 25
type U26 = Unsigned 26
type U27 = Unsigned 27
type U28 = Unsigned 28
type U29 = Unsigned 29
type U30 = Unsigned 30
type U31 = Unsigned 31
type U32 = Unsigned 32
instance Typeable Unsigned
instance Eq (Unsigned ix)
instance Ord (Unsigned ix)
instance SingI ix => Ix (Unsigned ix)
instance SingI ix => Bounded (Unsigned ix)
instance SingI ix => FiniteBits (Unsigned ix)
instance SingI ix => Bits (Unsigned ix)
instance SingI ix => Enum (Unsigned ix)
instance SingI ix => Real (Unsigned ix)
instance SingI ix => Num (Unsigned ix)
instance SingI ix => Integral (Unsigned ix)
instance SingI ix => Read (Unsigned ix)
instance Show (Unsigned ix)

module Data.Sized.Sampled
data Sampled (m :: Nat) (n :: Nat)
Sampled :: (Signed n) -> Rational -> Sampled
toVector :: (SingI m, SingI n) => Sampled m n -> Vector n Bool
fromVector :: (SingI n, SingI m) => Vector n Bool -> Sampled m n
mkSampled :: (SingI n, SingI m) => Rational -> Sampled m n
instance (SingI ix, SingI m) => Enum (Sampled m ix)
instance (SingI ix, SingI m) => Fractional (Sampled m ix)
instance (SingI ix, SingI m) => Real (Sampled m ix)
instance (SingI ix, SingI m) => Num (Sampled m ix)
instance (SingI ix, SingI m) => Read (Sampled m ix)
instance SingI ix => Show (Sampled m ix)
instance SingI ix => Ord (Sampled m ix)
instance SingI ix => Eq (Sampled m ix)
