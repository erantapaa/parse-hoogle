-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A low-dimensional linear algebra library, operating on the Num typeclass
--   
@package linear-vect
@version 0.1.1.0


-- | class declarations
module Linear.Class
class AbelianGroup g
(&+) :: AbelianGroup g => g -> g -> g
(&-) :: AbelianGroup g => g -> g -> g
neg :: AbelianGroup g => g -> g
zero :: AbelianGroup g => g
vecSum :: AbelianGroup g => [g] -> g
class MultSemiGroup r
(.*.) :: MultSemiGroup r => r -> r -> r
one :: MultSemiGroup r => r
class (AbelianGroup r, MultSemiGroup r) => Ring r
semigroupProduct :: MultSemiGroup r => [r] -> r
class LeftModule r m where (*.) = lmul
lmul :: LeftModule r m => r -> m -> m
(*.) :: LeftModule r m => r -> m -> m
class RightModule m r | m -> r, r -> m where (.*) = rmul
rmul :: RightModule m r => m -> r -> m
(.*) :: RightModule m r => m -> r -> m
class AbelianGroup (v a) => Vector a v where (*&) s v = scalarMul s v (&*) v s = scalarMul s v
mapVec :: Vector a v => (a -> a) -> v a -> v a
scalarMul :: Vector a v => a -> v a -> v a
(*&) :: Vector a v => a -> v a -> v a
(&*) :: Vector a v => v a -> a -> v a
class Num a => DotProd a v where dotprod = (&.) normsqr v = (v &. v) lensqr = normsqr
(&.) :: DotProd a v => v a -> v a -> a
dotprod :: DotProd a v => v a -> v a -> a
normsqr :: DotProd a v => v a -> a
lensqr :: DotProd a v => v a -> a
class (Floating a, DotProd a v) => Norm a v where norm = sqrt . lensqr vlen = norm
norm :: Norm a v => v a -> a
vlen :: Norm a v => v a -> a

-- | Cross product
class CrossProd v where (&^) = crossprod
crossprod :: CrossProd v => v -> v -> v
(&^) :: CrossProd v => v -> v -> v
normalize :: (Vector a v, Norm a v) => v a -> v a
distance :: (Vector a v, Norm a v) => v a -> v a -> a

-- | the angle between two vectors
angle :: (Vector a v, Norm a v) => v a -> v a -> a

-- | the angle between two unit vectors
angle' :: (Floating a, Vector a v, UnitVector a v u, DotProd a v) => u a -> u a -> a
class (Vector a v, Norm a v) => UnitVector a v u | u -> v, v -> u where fromNormalRadius t n = t *& fromNormal n
mkNormal :: UnitVector a v u => v a -> u a
toNormalUnsafe :: UnitVector a v u => v a -> u a
fromNormal :: UnitVector a v u => u a -> v a
fromNormalRadius :: UnitVector a v u => a -> u a -> v a

-- | Pointwise multiplication
class Pointwise v where (&!) = pointwise
pointwise :: Pointwise v => v -> v -> v
(&!) :: Pointwise v => v -> v -> v

-- | conversion between vectors (and matrices) of different dimensions
class Extend a u v
extendZero :: Extend a u v => u a -> v a
extendWith :: Extend a u v => a -> u a -> v a
trim :: Extend a u v => v a -> u a
class Dimension a
dim :: Dimension a => a -> Int
class Transpose m n | m -> n, n -> m
transpose :: Transpose m n => m -> n
class SquareMatrix m
inverse :: SquareMatrix m => m -> m
idmtx :: SquareMatrix m => m

-- | Outer product (could be unified with Diagonal?)
class Tensor t v | t -> v
outer :: Tensor t v => v -> v -> t

-- | makes a diagonal matrix from a vector
class Diagonal s t | t -> s
diag :: Diagonal s t => s -> t
class Determinant a m
det :: Determinant a m => m -> a
class SquareMatrix (m a) => Orthogonal a m o | m -> o, o -> m
fromOrtho :: Orthogonal a m o => o a -> m a
toOrthoUnsafe :: Orthogonal a m o => m a -> o a

-- | "Projective" matrices have the following form: the top left corner is
--   an any matrix, the bottom right corner is 1, and the top-right column
--   is zero. These describe the affine orthogonal transformation of the
--   space one dimension less.
class (Vector a v, Orthogonal a n o, Diagonal (v a) (n a)) => Projective a v n o m p | m -> p, p -> m, p -> o, o -> p, p -> n, n -> p, p -> v, v -> p, n -> o, n -> v, v -> n
fromProjective :: Projective a v n o m p => p a -> m a
toProjectiveUnsafe :: Projective a v n o m p => m a -> p a
orthogonal :: Projective a v n o m p => o a -> p a
linear :: Projective a v n o m p => n a -> p a
translation :: Projective a v n o m p => v a -> p a
scaling :: Projective a v n o m p => v a -> p a
class (AbelianGroup m, SquareMatrix m) => MatrixNorms a m where matrixDistance m n = frobeniusNorm (n &- m) operatorNorm = error "operatorNorm: not implemented yet"
frobeniusNorm :: MatrixNorms a m => m -> a
matrixDistance :: MatrixNorms a m => m -> m -> a
operatorNorm :: MatrixNorms a m => m -> a
project :: (Fractional a, Vector a v, DotProd a v) => v a -> v a -> v a

-- | Projects the first vector down to the hyperplane orthogonal to the
--   second (unit) vector
project' :: (Vector a v, UnitVector a v u, Norm a v) => v a -> u a -> v a

-- | Direction (second argument) is assumed to be a <i>unit</i> vector!
projectUnsafe :: (Vector a v, DotProd a v) => v a -> v a -> v a

-- | Since unit vectors are not a group, we need a separate function.
flipNormal :: UnitVector a v n => n a -> n a

-- | Householder matrix, see
--   <a>http://en.wikipedia.org/wiki/Householder_transformation</a>. In
--   plain words, it is the reflection to the hyperplane orthogonal to the
--   input vector.
householder :: (Vector a v, UnitVector a v u, SquareMatrix (m a), Vector a m, Tensor (m a) (v a)) => u a -> m a
householderOrtho :: (Vector a v, UnitVector a v u, SquareMatrix (m a), Vector a m, Tensor (m a) (v a), Orthogonal a m o) => u a -> o a

module Linear.Vect
data V2 a
V2 :: !a -> !a -> V2 a
data V3 a
V3 :: !a -> !a -> !a -> V3 a
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a

-- | The assumption when dealing with these is always that they are of unit
--   length. Also, interpolation works differently.
data Normal2 a
data Normal3 a
data Normal4 a
mkV2 :: (a, a) -> V2 a
mkV3 :: (a, a, a) -> V3 a
mkV4 :: (a, a, a, a) -> V4 a
class HasV2 v
class HasV3 v
class HasV4 v
_x :: V2 a -> a
_y :: V2 a -> a
_z :: V3 a -> a
_w :: V4 a -> a
instance Floating a => Norm a Normal4
instance Floating a => Norm a Normal3
instance Floating a => Norm a Normal2
instance Floating a => DotProd a Normal4
instance Floating a => DotProd a Normal3
instance Floating a => DotProd a Normal2
instance Read a => Read (V2 a)
instance Show a => Show (V2 a)
instance Read a => Read (V3 a)
instance Show a => Show (V3 a)
instance Read a => Read (V4 a)
instance Show a => Show (V4 a)
instance Read a => Read (Normal2 a)
instance Show a => Show (Normal2 a)
instance (Num a, Storable a) => Storable (Normal2 a)
instance Num a => Dimension (Normal2 a)
instance Read a => Read (Normal3 a)
instance Show a => Show (Normal3 a)
instance (Num a, Storable a) => Storable (Normal3 a)
instance Num a => Dimension (Normal3 a)
instance Read a => Read (Normal4 a)
instance Show a => Show (Normal4 a)
instance (Num a, Storable a) => Storable (Normal4 a)
instance Num a => Dimension (Normal4 a)
instance Num a => Extend a V3 V4
instance Num a => Extend a V2 V4
instance Num a => Extend a V2 V3
instance Num a => Dimension (V4 a)
instance (Num a, Storable a) => Storable (V4 a)
instance (Num a, Random a) => Random (V4 a)
instance Num a => Pointwise (V4 a)
instance Floating a => Norm a V4
instance Num a => DotProd a V4
instance Num a => Vector a V4
instance Num a => AbelianGroup (V4 a)
instance HasV4 V4
instance HasV3 V4
instance HasV2 V4
instance Num a => Dimension (V3 a)
instance (Num a, Storable a) => Storable (V3 a)
instance Num a => Determinant a (V3 a, V3 a, V3 a)
instance Num a => CrossProd (V3 a)
instance (Num a, Random a) => Random (V3 a)
instance Num a => Pointwise (V3 a)
instance Floating a => Norm a V3
instance Num a => DotProd a V3
instance Num a => Vector a V3
instance Num a => AbelianGroup (V3 a)
instance HasV3 V3
instance HasV2 V3
instance Num a => Dimension (V2 a)
instance (Num a, Storable a) => Storable (V2 a)
instance (Num a, Random a) => Random (V2 a)
instance Num a => Determinant a (V2 a, V2 a)
instance Num a => Pointwise (V2 a)
instance Floating a => Norm a V2
instance Num a => DotProd a V2
instance Num a => Vector a V2
instance Num a => AbelianGroup (V2 a)
instance HasV2 V2
instance Floating a => CrossProd (Normal3 a)
instance (Floating a, Random a, Ord a) => Random (Normal4 a)
instance (Floating a, Random a, Ord a) => Random (Normal3 a)
instance (Floating a, Random a, Ord a) => Random (Normal2 a)
instance Floating a => UnitVector a V4 Normal4
instance Floating a => UnitVector a V3 Normal3
instance Floating a => UnitVector a V2 Normal2

module Linear.Mat

-- | The components are <i>row</i> vectors
data M2 a
M2 :: !(V2 a) -> !(V2 a) -> M2 a
data M3 a
M3 :: !(V3 a) -> !(V3 a) -> !(V3 a) -> M3 a
data M4 a
M4 :: !(V4 a) -> !(V4 a) -> !(V4 a) -> !(V4 a) -> M4 a
data M2x3 a
M2x3 :: !a -> !a -> !a -> !a -> !a -> !a -> M2x3 a
data M2x4 a
M2x4 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> M2x4 a
data M3x2 a
M3x2 :: !a -> !a -> !a -> !a -> !a -> !a -> M3x2 a
data M3x4 a
M3x4 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> M3x4 a
data M4x2 a
M4x2 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> M4x2 a
data M4x3 a
M4x3 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> M4x3 a

-- | Orthogonal matrices.
--   
--   Note: the <a>Random</a> instances generates orthogonal matrices with
--   determinant 1 (that is, orientation-preserving orthogonal
--   transformations)!
data Ortho2 a
data Ortho3 a
data Ortho4 a

-- | Projective matrices, encoding affine transformations in dimension one
--   less.
data Proj3 a
data Proj4 a
instance Read a => Read (M2 a)
instance Show a => Show (M2 a)
instance Read a => Read (M3 a)
instance Show a => Show (M3 a)
instance Read a => Read (M4 a)
instance Show a => Show (M4 a)
instance Read a => Read (M2x3 a)
instance Show a => Show (M2x3 a)
instance Read a => Read (M2x4 a)
instance Show a => Show (M2x4 a)
instance Read a => Read (M3x2 a)
instance Show a => Show (M3x2 a)
instance Read a => Read (M3x4 a)
instance Show a => Show (M3x4 a)
instance Read a => Read (M4x2 a)
instance Show a => Show (M4x2 a)
instance Read a => Read (M4x3 a)
instance Show a => Show (M4x3 a)
instance Read a => Read (Ortho2 a)
instance Show a => Show (Ortho2 a)
instance (Num a, Storable a) => Storable (Ortho2 a)
instance Fractional a => MultSemiGroup (Ortho2 a)
instance Num a => Determinant a (Ortho2 a)
instance Num a => Dimension (Ortho2 a)
instance Read a => Read (Ortho3 a)
instance Show a => Show (Ortho3 a)
instance (Num a, Storable a) => Storable (Ortho3 a)
instance Fractional a => MultSemiGroup (Ortho3 a)
instance Num a => Determinant a (Ortho3 a)
instance Num a => Dimension (Ortho3 a)
instance Read a => Read (Ortho4 a)
instance Show a => Show (Ortho4 a)
instance (Num a, Storable a) => Storable (Ortho4 a)
instance Num a => MultSemiGroup (Ortho4 a)
instance Num a => Determinant a (Ortho4 a)
instance Num a => Dimension (Ortho4 a)
instance Read a => Read (Proj3 a)
instance Show a => Show (Proj3 a)
instance (Num a, Storable a) => Storable (Proj3 a)
instance Fractional a => MultSemiGroup (Proj3 a)
instance Read a => Read (Proj4 a)
instance Show a => Show (Proj4 a)
instance (Num a, Storable a) => Storable (Proj4 a)
instance Num a => MultSemiGroup (Proj4 a)
instance Storable a => Storable (M4x3 a)
instance Storable a => Storable (M4x2 a)
instance Storable a => Storable (M3x4 a)
instance Storable a => Storable (M3x2 a)
instance Storable a => Storable (M2x4 a)
instance Storable a => Storable (M2x3 a)
instance Transpose (M4x3 a) (M3x4 a)
instance Transpose (M4x2 a) (M2x4 a)
instance Transpose (M3x4 a) (M4x3 a)
instance Transpose (M3x2 a) (M2x3 a)
instance Transpose (M2x4 a) (M4x2 a)
instance Transpose (M2x3 a) (M3x2 a)
instance Num a => Extend a M3 M4
instance Num a => Extend a M2 M4
instance Num a => Extend a M2 M3
instance Num a => Pointwise (M4 a)
instance Floating a => MatrixNorms a (M4 a)
instance Num a => Dimension (M4 a)
instance (Num a, Random a) => Random (M4 a)
instance (Num a, Storable a) => Storable (M4 a)
instance Num a => Determinant a (M4 a)
instance Num a => Tensor (M4 a) (V4 a)
instance Num a => Diagonal (V4 a) (M4 a)
instance Num a => RightModule (V4 a) (M4 a)
instance Num a => LeftModule (M4 a) (V4 a)
instance Num a => Ring (M4 a)
instance Num a => MultSemiGroup (M4 a)
instance Num a => Vector a M4
instance Num a => AbelianGroup (M4 a)
instance Num a => SquareMatrix (M4 a)
instance Transpose (M4 a) (M4 a)
instance Num a => Pointwise (M3 a)
instance Floating a => MatrixNorms a (M3 a)
instance Num a => Dimension (M3 a)
instance (Num a, Random a) => Random (M3 a)
instance (Num a, Storable a) => Storable (M3 a)
instance Num a => Determinant a (M3 a)
instance Num a => Tensor (M3 a) (V3 a)
instance Num a => Diagonal (V3 a) (M3 a)
instance Fractional a => RightModule (V3 a) (M3 a)
instance Num a => LeftModule (M3 a) (V3 a)
instance Fractional a => Ring (M3 a)
instance Fractional a => MultSemiGroup (M3 a)
instance Num a => Vector a M3
instance Num a => AbelianGroup (M3 a)
instance Fractional a => SquareMatrix (M3 a)
instance Transpose (M3 a) (M3 a)
instance Num a => Pointwise (M2 a)
instance Floating a => MatrixNorms a (M2 a)
instance Num a => Dimension (M2 a)
instance (Num a, Random a) => Random (M2 a)
instance (Num a, Storable a) => Storable (M2 a)
instance Num a => Determinant a (M2 a)
instance Num a => Tensor (M2 a) (V2 a)
instance Num a => Diagonal (V2 a) (M2 a)
instance Fractional a => RightModule (V2 a) (M2 a)
instance Num a => LeftModule (M2 a) (V2 a)
instance Fractional a => Ring (M2 a)
instance Fractional a => MultSemiGroup (M2 a)
instance Num a => Vector a M2
instance Num a => AbelianGroup (M2 a)
instance Fractional a => SquareMatrix (M2 a)
instance Transpose (M2 a) (M2 a)
instance Fractional a => SquareMatrix (Proj4 a)
instance Transpose (Proj4 a) (Proj4 a)
instance Fractional a => SquareMatrix (Proj3 a)
instance Transpose (Proj3 a) (Proj3 a)
instance Fractional a => Projective a V3 M3 Ortho3 M4 Proj4
instance Fractional a => Projective a V2 M2 Ortho2 M3 Proj3
instance (Floating a, Ord a, Random a) => Random (Ortho4 a)
instance (Floating a, Ord a, Random a) => Random (Ortho3 a)
instance (Floating a, Ord a, Random a) => Random (Ortho2 a)
instance Fractional a => SquareMatrix (Ortho4 a)
instance Transpose (Ortho4 a) (Ortho4 a)
instance Fractional a => SquareMatrix (Ortho3 a)
instance Transpose (Ortho3 a) (Ortho3 a)
instance Fractional a => SquareMatrix (Ortho2 a)
instance Transpose (Ortho2 a) (Ortho2 a)
instance Fractional a => Orthogonal a M4 Ortho4
instance Fractional a => Orthogonal a M3 Ortho3
instance Fractional a => Orthogonal a M2 Ortho2
