-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | f-lite compiler, interpreter and libraries
--   
--   The f-lite language is a subset of Haskell 98 and Clean consisting of
--   function definitions, pattern matching, limited let expressions,
--   function applications and constructor applications expressed in the
--   explicit <a>braces</a> layout-insensitive format. See README for more
--   information. Example flite programs included in source distribution.
@package flite
@version 0.1.2

module Flite.Fresh
data Fresh a
Fresh :: (String -> Int -> (Int, a)) -> Fresh a
runFresh :: Fresh a -> String -> Int -> (Int, a)
fresh :: Fresh String
instance Monad Fresh

module Flite.Writer
data Writer w a
W :: [w] -> a -> Writer w a
runWriter :: Writer w a -> ([w], a)
write :: w -> Writer w ()
writeMany :: [w] -> Writer w ()
instance Monad (Writer w)

module Flite.Identity
newtype Identity a
I :: a -> Identity a
runIdentity :: Identity a -> a
instance Monad Identity

module Flite.Descend
class Descend a
descendM :: (Descend a, Monad m) => (a -> m a) -> a -> m a
descend :: Descend a => (a -> a) -> a -> a
extract :: Descend a => (a -> [b]) -> a -> [b]
universe :: Descend a => a -> [a]

module Flite.Syntax
type Prog = [Decl]
data Decl
Func :: Id -> [Pat] -> Exp -> Decl
funcName :: Decl -> Id
funcArgs :: Decl -> [Pat]
funcRhs :: Decl -> Exp
type Id = String
data Exp
App :: Exp -> [Exp] -> Exp
Case :: Exp -> [Alt] -> Exp
Let :: [Binding] -> Exp -> Exp
Var :: Id -> Exp
Con :: Id -> Exp
Fun :: Id -> Exp
Int :: Int -> Exp
Bottom :: Exp
Alts :: [Id] -> Int -> Exp
Ctr :: Id -> Int -> Int -> Exp
Lam :: [Id] -> Exp -> Exp
PrimApp :: Id -> [Exp] -> Exp
Prim :: Id -> Exp
type Pat = Exp
type Alt = (Pat, Exp)
type Binding = (Id, Exp)
type App = [Exp]
isPrimId :: Id -> Bool
isBinaryPrim :: Id -> Bool
isUnaryPrim :: Id -> Bool
isPredexId :: Id -> Bool
instance Eq Exp

module Flite.Traversals
funcs :: Prog -> [String]
onExp :: (Exp -> Exp) -> Prog -> Prog
onExpM :: Monad m => (Exp -> m Exp) -> Prog -> m Prog
fromExp :: (Exp -> [a]) -> Prog -> [a]
subst :: Exp -> Id -> Exp -> Exp
substMany :: Exp -> [(Exp, Id)] -> Exp
patVars :: Pat -> [Id]
caseAlts :: Exp -> [[Alt]]
freeVarsExcept :: [Id] -> Exp -> [Id]
freeVarsExcept' :: [Id] -> Exp -> [Id]
freeVars :: Exp -> [Id]
varRefs :: Id -> Exp -> Int
calls :: Exp -> [Id]
lookupFuncs :: Id -> Prog -> [Decl]
freshen :: Exp -> Fresh Exp
freshenPat :: Pat -> Fresh Pat
freshenAlt :: (Pat, Exp) -> Fresh (Pat, Exp)
freshBody :: ([Id], Exp) -> Fresh ([Id], Exp)
instance Descend Exp

module Flite.Case
caseElim :: Prog -> Prog
caseElimWithCaseStack :: Prog -> Prog

module Flite.ConcatApp
concatApps :: Prog -> Prog
concatNonPrims :: Prog -> Prog

module Flite.Identify
identifyFuncs :: Prog -> Prog

module Flite.Let
inlineLinearLet :: Prog -> Fresh Prog
inlineSimpleLet :: Prog -> Fresh Prog
liftLet :: Prog -> Fresh Prog

module Flite.Inline
data InlineFlag
NoInline :: InlineFlag
InlineAll :: InlineFlag
InlineSmall :: Int -> InlineFlag
inline :: InlineFlag -> Prog -> Fresh Prog
inlineTop :: InlineFlag -> Prog -> Fresh Prog

module Flite.Matching
desugarEqn :: Prog -> Fresh Prog
desugarCase :: Prog -> Fresh Prog

module Flite.Pretty
consperse :: [a] -> [[a]] -> [a]
pretty :: Prog -> String
showArg :: Exp -> String
showBlock :: (a -> String) -> [a] -> String
showAlt :: Alt -> String
showBind :: Binding -> String
instance Show Exp
instance Show Decl

module Flite.Parsec.Parse
prog :: Parser Prog
block :: Parser a -> Parser [a]
prim :: Parser Id
var :: Parser Id
con :: Parser Id
defn :: Parser Decl
pat :: Parser Exp
pat' :: Parser Exp
expr :: Parser Exp
expr' :: Parser Exp
ifthenelse :: Exp -> Exp -> Exp -> Exp
stringExp :: String -> Exp
alt :: Parser Alt
bind :: Parser Binding
parseProgFile :: SourceName -> IO Prog
instance Alternative (GenParser s a)
instance Applicative (GenParser s a)

module Flite.CallGraph
type CallGraph = [(Id, [Id])]
callReachableGraph :: Prog -> CallGraph
reachable :: CallGraph -> Id -> [Id]
