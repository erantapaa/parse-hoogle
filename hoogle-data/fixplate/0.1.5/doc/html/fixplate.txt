-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Uniplate-style generic traversals for optionally annotated fixed-point types.
--   
--   Uniplate-style generic traversals for fixed-point types, which can be
--   optionally annotated with attributes. We also provide recursion
--   schemes, and a generic zipper. See the module
--   <a>Data.Generics.Fixplate</a> and then the individual modules for more
--   detailed information.
@package fixplate
@version 0.1.5


-- | The core types of Fixplate.
module Data.Generics.Fixplate.Base

-- | The fixed-point type.
newtype Mu f
Fix :: f (Mu f) -> Mu f
unFix :: Mu f -> f (Mu f)

-- | We call a tree "atomic" if it has no subtrees.
isAtom :: Foldable f => Mu f -> Bool

-- | Type of annotations
data Ann f a b
Ann :: a -> f b -> Ann f a b

-- | the annotation
attr :: Ann f a b -> a

-- | the original functor
unAnn :: Ann f a b -> f b

-- | Annotated fixed-point type. Equivalent to <tt>CoFree f a</tt>
type Attr f a = Mu (Ann f a)

-- | Lifting natural transformations to annotations.
liftAnn :: (f e -> g e) -> Ann f a e -> Ann g a e

-- | Categorical dual of <a>Ann</a>.
data CoAnn f a b
Pure :: a -> CoAnn f a b
CoAnn :: (f b) -> CoAnn f a b

-- | Categorical dual of <a>Attr</a>. Equivalent to <tt>Free f a</tt>
type CoAttr f a = Mu (CoAnn f a)

-- | Lifting natural transformations to annotations.
liftCoAnn :: (f e -> g e) -> CoAnn f a e -> CoAnn g a e

-- | The attribute of the root node.
attribute :: Attr f a -> a

-- | A function forgetting all the attributes from an annotated tree.
forget :: Functor f => Attr f a -> Mu f

-- | This a data type defined to be a place-holder for childs. It is used
--   in tree drawing, hashing, and <tt>Shape</tt>.
--   
--   It is deliberately not made an instance of <a>Show</a>, so that you
--   can choose your preferred style. For example, an acceptable choice is
--   
--   <pre>
--   instance Show Hole where show _ = "_"
--   </pre>
data Hole
Hole :: Hole

-- | "Functorised" versions of standard type classes. If you have your a
--   structure functor, for example
--   
--   <pre>
--   Expr e 
--     = Kst Int 
--     | Var String 
--     | Add e e 
--     deriving (Eq,Ord,Read,Show,Functor,Foldable,Traversable)
--   </pre>
--   
--   you should make it an instance of these, so that the fixed-point type
--   <tt>Mu Expr</tt> can be an instance of <tt>Eq</tt>, <tt>Ord</tt> and
--   <tt>Show</tt>. Doing so is very easy:
--   
--   <pre>
--   instance EqF   Expr where equalF     = (==)
--   instance OrdF  Expr where compareF   = compare
--   instance ShowF Expr where showsPrecF = showsPrec
--   </pre>
--   
--   The <tt>Read</tt> instance depends on whether we are using GHC or not.
--   The Haskell98 version is
--   
--   <pre>
--   instance ReadF Expr where readsPrecF = readsPrec
--   </pre>
--   
--   while the GHC version is
--   
--   <pre>
--   instance ReadF Expr where readPrecF  = readPrec
--   </pre>
class EqF f
equalF :: (EqF f, Eq a) => f a -> f a -> Bool
class EqF f => OrdF f
compareF :: (OrdF f, Ord a) => f a -> f a -> Ordering
class ShowF f
showsPrecF :: (ShowF f, Show a) => Int -> f a -> ShowS
class ReadF f
readPrecF :: (ReadF f, Read a) => ReadPrec (f a)
showF :: (ShowF f, Show a) => f a -> String
showsF :: (ShowF f, Show a) => f a -> ShowS

-- | A newtype wrapper around <tt>Attr f a</tt> so that we can make
--   <tt>Attr f</tt> an instance of Functor, Foldable and Traversable (and
--   Comonad). This is necessary since Haskell does not allow partial
--   application of type synonyms.
--   
--   Equivalent to the co-free comonad.
newtype Attrib f a
Attrib :: Attr f a -> Attrib f a
unAttrib :: Attrib f a -> Attr f a

-- | Categorial dual of <a>Attrib</a>. Equivalent to the free monad.
newtype CoAttrib f a
CoAttrib :: CoAttr f a -> CoAttrib f a
unCoAttrib :: CoAttrib f a -> CoAttr f a
instance (Eq a, Eq (f b)) => Eq (Ann f a b)
instance (Ord a, Ord (f b)) => Ord (Ann f a b)
instance (Show a, Show (f b)) => Show (Ann f a b)
instance (Eq a, Eq (f b)) => Eq (CoAnn f a b)
instance (Ord a, Ord (f b)) => Ord (CoAnn f a b)
instance (Show a, Show (f b)) => Show (CoAnn f a b)
instance Eq Hole
instance Ord Hole
instance Functor f => Monad (CoAttrib f)
instance Traversable f => Traversable (CoAttrib f)
instance Foldable f => Foldable (CoAttrib f)
instance Functor f => Functor (CoAttrib f)
instance (ShowF f, Show a) => Show (CoAttrib f a)
instance Traversable f => Traversable (Attrib f)
instance Foldable f => Foldable (Attrib f)
instance Functor f => Functor (Attrib f)
instance (ShowF f, Show a) => Show (Attrib f a)
instance Traversable f => Traversable (CoAnn f a)
instance Foldable f => Foldable (CoAnn f a)
instance Functor f => Functor (CoAnn f a)
instance Traversable f => Traversable (Ann f a)
instance Foldable f => Foldable (Ann f a)
instance Functor f => Functor (Ann f a)
instance (Show a, ShowF f) => ShowF (CoAnn f a)
instance (Ord a, OrdF f) => OrdF (CoAnn f a)
instance (Eq a, EqF f) => EqF (CoAnn f a)
instance (Read a, ReadF f) => ReadF (Ann f a)
instance (Show a, ShowF f) => ShowF (Ann f a)
instance (Ord a, OrdF f) => OrdF (Ann f a)
instance (Eq a, EqF f) => EqF (Ann f a)
instance ReadF f => Read (Mu f)
instance ShowF f => Show (Mu f)
instance OrdF f => Ord (Mu f)
instance EqF f => Eq (Mu f)


-- | Recursion schemes, also known as scary named folds...
module Data.Generics.Fixplate.Morphisms

-- | A <i>catamorphism</i> is the generalization of right fold from lists
--   to trees.
cata :: Functor f => (f a -> a) -> Mu f -> a

-- | A <i>paramorphism</i> is a more general version of the catamorphism.
para :: Functor f => (f (Mu f, a) -> a) -> Mu f -> a

-- | Another version of <a>para</a> (a bit less natural in some sense).
para' :: Functor f => (Mu f -> f a -> a) -> Mu f -> a

-- | A list version of <a>para</a> (compare with Uniplate)
paraList :: (Functor f, Foldable f) => (Mu f -> [a] -> a) -> Mu f -> a

-- | An <i>anamorphism</i> is simply an unfold. Probably not very useful in
--   this context.
ana :: Functor f => (a -> f a) -> a -> Mu f

-- | An <i>apomorphism</i> is a generalization of the anamorphism.
apo :: Functor f => (a -> f (Either (Mu f) a)) -> a -> Mu f

-- | A <i>hylomorphism</i> is the composition of a catamorphism and an
--   anamorphism.
hylo :: Functor f => (f a -> a) -> (b -> f b) -> (b -> a)

-- | A <i>zygomorphism</i> is a basically a catamorphism inside another
--   catamorphism. It could be implemented (somewhat wastefully) by first
--   annotating each subtree with the corresponding values of the inner
--   catamorphism (<tt>synthCata</tt>), then running a paramorphims on the
--   annotated tree:
--   
--   <pre>
--   zygo_ g h == para u . synthCata g 
--     where
--       u = h . fmap (first attribute) . unAnn
--       first f (x,y) = (f x, y)
--   </pre>
zygo_ :: Functor f => (f b -> b) -> (f (b, a) -> a) -> Mu f -> a
zygo :: Functor f => (f b -> b) -> (f (b, a) -> a) -> Mu f -> (b, a)

-- | Histomorphism. This is a kind of glorified cata/paramorphism, after
--   all:
--   
--   <pre>
--   cata f == histo (f . fmap attribute)
--   para f == histo (f . fmap (\t -&gt; (forget t, attribute t)))
--   </pre>
histo :: Functor f => (f (Attr f a) -> a) -> Mu f -> a

-- | Futumorphism. This is a more interesting unfold.
futu :: Functor f => (a -> f (CoAttr f a)) -> a -> Mu f

-- | Monadic catamorphism.
cataM :: (Monad m, Traversable f) => (f a -> m a) -> Mu f -> m a
cataM_ :: (Monad m, Traversable f) => (f a -> m a) -> Mu f -> m ()

-- | Monadic paramorphism.
paraM :: (Monad m, Traversable f) => (f (Mu f, a) -> m a) -> Mu f -> m a
paraM_ :: (Monad m, Traversable f) => (f (Mu f, a) -> m a) -> Mu f -> m ()

-- | Another version of <a>paraM</a>.
paraM' :: (Monad m, Traversable f) => (Mu f -> f a -> m a) -> Mu f -> m a


-- | "Open" functions, working on functors instead of trees.
module Data.Generics.Fixplate.Open

-- | List of elements of a structure.
toList :: Foldable t => t a -> [a]

-- | Equivalent to <tt>reverse . toList</tt>.
toRevList :: Foldable f => f a -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapAccumL_ :: Traversable f => (a -> b -> (a, c)) -> a -> f b -> f c
mapAccumR_ :: Traversable f => (a -> b -> (a, c)) -> a -> f b -> f c

-- | The children together with functions replacing that particular child.
holes :: Traversable f => f a -> f (a, a -> f a)
holesList :: Traversable f => f a -> [(a, a -> f a)]

-- | Apply the given function to each child in turn.
apply :: Traversable f => (a -> a) -> f a -> f (f a)

-- | Builds up a structure from a list of the children. It is unsafe in the
--   sense that it will throw an exception if there are not enough elements
--   in the list.
builder :: Traversable f => f a -> [b] -> f b

-- | Extracts the ith child.
project :: Foldable f => Int -> f a -> Maybe a
unsafeProject :: Foldable f => Int -> f a -> a

-- | Number of children. This is the generalization of <a>length</a> to
--   foldable functors:
--   
--   <pre>
--   sizeF x = length (toList x)
--   </pre>
sizeF :: Foldable f => f a -> Int

-- | Enumerates children from the left to the right, starting with zero.
--   Also returns the number of children. This is just a simple application
--   of <a>mapAccumL</a>.
enumerate :: Traversable f => f a -> (Int, f (Int, a))
enumerateWith :: Traversable f => (Int -> a -> b) -> f a -> (Int, f b)
enumerateWith_ :: Traversable f => (Int -> a -> b) -> f a -> f b

-- | This a data type defined to be a place-holder for childs. It is used
--   in tree drawing, hashing, and <tt>Shape</tt>.
--   
--   It is deliberately not made an instance of <a>Show</a>, so that you
--   can choose your preferred style. For example, an acceptable choice is
--   
--   <pre>
--   instance Show Hole where show _ = "_"
--   </pre>
data Hole
Hole :: Hole

-- | A type encoding the "shape" of the functor data: We ignore all the
--   fields whose type is the parameter type, but remember the rest:
--   
--   <pre>
--   newtype Shape f = Shape { unShape :: f Hole }
--   </pre>
--   
--   This can be used to decide whether two realizations are compatible.
data Shape f

-- | Extracting the "shape" of the functor
shape :: Functor f => f a -> Shape f

-- | Zips two structures if they are compatible.
zipF :: (Traversable f, EqF f) => f a -> f b -> Maybe (f (a, b))
unzipF :: Functor f => f (a, b) -> (f a, f b)

-- | Zipping two structures using a function.
zipWithF :: (Traversable f, EqF f) => (a -> b -> c) -> f a -> f b -> Maybe (f c)

-- | Unsafe version of <a>zipWithF</a>: does not check if the two
--   structures are compatible. It is left-biased in the sense that the
--   structure of the second argument is retained.
unsafeZipWithF :: Traversable f => (a -> b -> c) -> f a -> f b -> f c

-- | Monadic version of <a>zipWithF</a>. TODO: better name?
zipWithFM :: (Traversable f, EqF f, Monad m) => (a -> b -> m c) -> f a -> f b -> m (Maybe (f c))
unsafeZipWithFM :: (Traversable f, Monad m) => (a -> b -> m c) -> f a -> f b -> m (f c)
instance (Functor f, ShowF f) => Show (Shape f)
instance Show Void
instance OrdF f => Ord (Shape f)
instance EqF f => Eq (Shape f)


-- | Uniplate-style traversals.
--   
--   Toy example: Consider our favourite data type
--   
--   <pre>
--   data Expr e 
--     = Kst Int 
--     | Var String 
--     | Add e e 
--     deriving (Eq,Show,Functor,Foldable,Traversable)
--   
--   instance ShowF Expr where showsPrecF = showsPrec
--   </pre>
--   
--   and write a function simplifying additions with zero:
--   
--   <pre>
--   simplifyAdd :: Mu Expr -&gt; Mu Expr
--   simplifyAdd = transform worker where
--     worker expr = case expr of
--       Fix (Add x (Fix (Kst 0))) -&gt; x    -- 0+x = x
--       Fix (Add (Fix (Kst 0)) y) -&gt; y    -- x+0 = 0
--       _ -&gt; expr
--   </pre>
--   
--   Unfortunately, all these <a>Fix</a> wrappers are rather ugly; but they
--   are straightforward to put in, and in principle one could use Template
--   Haskell quasi-quotation to generate patterns.
module Data.Generics.Fixplate.Traversals

-- | The list of direct descendants.
children :: Foldable f => Mu f -> [Mu f]

-- | The list of all substructures. Together with list-comprehension syntax
--   this is a powerful query tool. For example the following is how you
--   get the list of all variable names in an expression:
--   
--   <pre>
--   variables expr = [ s | Fix (Var s) &lt;- universe expr ]
--   </pre>
universe :: Foldable f => Mu f -> [Mu f]

-- | Bottom-up transformation.
transform :: Functor f => (Mu f -> Mu f) -> Mu f -> Mu f
transformM :: (Traversable f, Monad m) => (Mu f -> m (Mu f)) -> Mu f -> m (Mu f)

-- | Top-down transformation. This provided only for completeness; usually,
--   it is <a>transform</a> what you want use instead.
topDownTransform :: Functor f => (Mu f -> Mu f) -> Mu f -> Mu f
topDownTransformM :: (Traversable f, Monad m) => (Mu f -> m (Mu f)) -> Mu f -> m (Mu f)

-- | Non-recursive top-down transformation. This is basically just
--   <a>fmap</a>.
descend :: Functor f => (Mu f -> Mu f) -> Mu f -> Mu f

-- | Similarly, this is basically just <a>mapM</a>.
descendM :: (Traversable f, Monad m) => (Mu f -> m (Mu f)) -> Mu f -> m (Mu f)

-- | Bottom-up transformation until a normal form is reached.
rewrite :: Functor f => (Mu f -> Maybe (Mu f)) -> Mu f -> Mu f
rewriteM :: (Traversable f, Monad m) => (Mu f -> m (Maybe (Mu f))) -> Mu f -> m (Mu f)

-- | Bottom-up transformation (typically "shallow", that is, restricted to
--   a single level) which can change the structure functor (actually
--   <a>transform</a> is a special case of this).
restructure :: Functor f => (f (Mu g) -> g (Mu g)) -> Mu f -> Mu g
restructureM :: (Traversable f, Monad m) => (f (Mu g) -> m (g (Mu g))) -> Mu f -> m (Mu g)

-- | We <i>annotate</i> the nodes of the tree with functions which replace
--   that particular subtree.
context :: Traversable f => Mu f -> Attr f (Mu f -> Mu f)

-- | Flattened version of <a>context</a>.
contextList :: Traversable f => Mu f -> [(Mu f, Mu f -> Mu f)]

-- | (Strict) left fold. Since <tt>Mu f</tt> is not a functor, but a data
--   type, we cannot make it an instance of the <tt>Foldable</tt> type
--   class.
foldLeft :: Foldable f => (a -> Mu f -> a) -> a -> Mu f -> a
foldLeftLazy :: Foldable f => (a -> Mu f -> a) -> a -> Mu f -> a
foldRight :: Foldable f => (Mu f -> a -> a) -> a -> Mu f -> a


-- | Synthetising attributes, partly motivated by Attribute Grammars, and
--   partly by recursion schemes.
module Data.Generics.Fixplate.Attributes

-- | A newtype wrapper around <tt>Attr f a</tt> so that we can make
--   <tt>Attr f</tt> an instance of Functor, Foldable and Traversable (and
--   Comonad). This is necessary since Haskell does not allow partial
--   application of type synonyms.
--   
--   Equivalent to the co-free comonad.
newtype Attrib f a
Attrib :: Attr f a -> Attrib f a
unAttrib :: Attrib f a -> Attr f a

-- | Map over annotations
--   
--   <pre>
--   annMap f = unAttrib . fmap f . Attrib
--   </pre>
annMap :: Functor f => (a -> b) -> Attr f a -> Attr f b

-- | <i>Synthetised</i> attributes are created in a bottom-up manner. As an
--   example, the <tt>sizes</tt> function computes the sizes of all
--   subtrees:
--   
--   <pre>
--   sizes :: (Functor f, Foldable f) =&gt; Mu f -&gt; Attr f Int
--   sizes = synthetise (\t -&gt; 1 + sum t)
--   </pre>
--   
--   (note that <tt>sum</tt> here is <tt>Data.Foldable.sum == Prelude.sum .
--   Data.Foldable.toList</tt>)
--   
--   See also <a>synthCata</a>.
synthetise :: Functor f => (f a -> a) -> Mu f -> Attr f a

-- | Generalization of <tt>scanr</tt> for trees. See also <a>scanCata</a>.
synthetise' :: Functor f => (a -> f b -> b) -> Attr f a -> Attr f b

-- | List version of <a>synthetise</a> (compare with Uniplate)
synthetiseList :: (Functor f, Foldable f) => ([a] -> a) -> Mu f -> Attr f a

-- | Monadic version of <a>synthetise</a>.
synthetiseM :: (Traversable f, Monad m) => (f a -> m a) -> Mu f -> m (Attr f a)

-- | Synonym for <a>synthetise</a>, motivated by the equation
--   
--   <pre>
--   attribute . synthCata f == cata f
--   </pre>
--   
--   That is, it attributes all subtrees with the result of the
--   corresponding catamorphism.
synthCata :: Functor f => (f a -> a) -> Mu f -> Attr f a

-- | Synonym for <a>synthetise'</a>. Note that this could be a special case
--   of <a>synthCata</a>:
--   
--   <pre>
--   scanCata f == annZipWith (flip const) . synthCata (\(Ann a x) -&gt; f a x)
--   </pre>
--   
--   Catamorphim (<tt>cata</tt>) is the generalization of <tt>foldr</tt>
--   from lists to trees; <a>synthCata</a> is one generalization of
--   <tt>scanr</tt>, and <a>scanCata</a> is another generalization.
scanCata :: Functor f => (a -> f b -> b) -> Attr f a -> Attr f b

-- | Attributes all subtrees with the result of the corresponding
--   paramorphism.
--   
--   <pre>
--   attribute . synthPara f == para f
--   </pre>
synthPara :: Functor f => (f (Mu f, a) -> a) -> Mu f -> Attr f a

-- | Another version of <a>synthPara</a>.
--   
--   <pre>
--   attribute . synthPara' f == para' f
--   </pre>
synthPara' :: Functor f => (Mu f -> f a -> a) -> Mu f -> Attr f a
scanPara :: Functor f => (Attr f a -> f b -> b) -> Attr f a -> Attr f b

-- | Synthetising zygomorphism.
--   
--   <pre>
--   attribute . synthZygo_ g h == zygo_ g h
--   </pre>
synthZygo_ :: Functor f => (f b -> b) -> (f (b, a) -> a) -> Mu f -> Attr f a
synthZygo :: Functor f => (f b -> b) -> (f (b, a) -> a) -> Mu f -> Attr f (b, a)
synthZygoWith :: Functor f => (b -> a -> c) -> (f b -> b) -> (f (b, a) -> a) -> Mu f -> Attr f c

-- | Accumulating catamorphisms. Generalization of <a>mapAccumR</a> from
--   lists to trees.
synthAccumCata :: Functor f => (f acc -> (acc, b)) -> Mu f -> (acc, Attr f b)

-- | Accumulating paramorphisms.
synthAccumPara' :: Functor f => (Mu f -> f acc -> (acc, b)) -> Mu f -> (acc, Attr f b)

-- | Could be a special case of <a>synthAccumCata</a>:
--   
--   <pre>
--   mapAccumCata f == second (annZipWith (flip const)) . synthAccumCata (\(Ann b t) -&gt; f b t) 
--     where second g (x,y) = (x, g y)
--   </pre>
mapAccumCata :: Functor f => (f acc -> b -> (acc, c)) -> Attr f b -> (acc, Attr f c)

-- | Synonym for <a>synthetiseM</a>. If you don't need the result, use
--   <tt>cataM_</tt> instead.
synthCataM :: (Traversable f, Monad m) => (f a -> m a) -> Mu f -> m (Attr f a)

-- | Monadic version of <a>synthPara</a>. If you don't need the result, use
--   <tt>paraM_</tt> instead.
synthParaM :: (Traversable f, Monad m) => (f (Mu f, a) -> m a) -> Mu f -> m (Attr f a)

-- | Monadic version of <a>synthPara'</a>.
synthParaM' :: (Traversable f, Monad m) => (Mu f -> f a -> m a) -> Mu f -> m (Attr f a)

-- | <i>Inherited</i> attributes are created in a top-down manner. As an
--   example, the <tt>depths</tt> function computes the depth (the distance
--   from the root, incremented by 1) of all subtrees:
--   
--   <pre>
--   depths :: Functor f =&gt; Mu f -&gt; Attr f Int
--   depths = inherit (\_ i -&gt; i+1) 0
--   </pre>
inherit :: Functor f => (Mu f -> a -> a) -> a -> Mu f -> Attr f a

-- | Generalization of <tt>scanl</tt> from lists to trees.
inherit' :: Functor f => (a -> b -> a) -> a -> Attr f b -> Attr f a

-- | Generalization of <a>inherit</a>. TODO: better name?
inherit2 :: Functor f => (Mu f -> a -> (b, a)) -> a -> Mu f -> Attr f b

-- | Monadic version of <a>inherit</a>.
inheritM :: (Traversable f, Monad m) => (Mu f -> a -> m a) -> a -> Mu f -> m (Attr f a)
inheritM_ :: (Traversable f, Monad m) => (Mu f -> a -> m a) -> a -> Mu f -> m ()

-- | Monadic top-down "sweep" of a tree. It's kind of a more complicated
--   folding version of <a>inheritM</a>. This is unsafe in the sense that
--   the user is responsible to retain the shape of the node. TODO: better
--   name?
topDownSweepM :: (Traversable f, Monad m) => (f () -> a -> m (f a)) -> a -> Mu f -> m ()

-- | An attributed version of <a>topDownSweepM</a>. Probably more useful.
topDownSweepM' :: (Traversable f, Monad m) => (b -> f b -> a -> m (f a)) -> a -> Attr f b -> m ()

-- | Synthetising attributes via an accumulating map in a left-to-right
--   fashion (the order is the same as in <tt>foldl</tt>).
synthAccumL :: Traversable f => (a -> Mu f -> (a, b)) -> a -> Mu f -> (a, Attr f b)

-- | Synthetising attributes via an accumulating map in a right-to-left
--   fashion (the order is the same as in <tt>foldr</tt>).
synthAccumR :: Traversable f => (a -> Mu f -> (a, b)) -> a -> Mu f -> (a, Attr f b)
synthAccumL_ :: Traversable f => (a -> Mu f -> (a, b)) -> a -> Mu f -> Attr f b
synthAccumR_ :: Traversable f => (a -> Mu f -> (a, b)) -> a -> Mu f -> Attr f b

-- | We use <a>synthAccumL</a> to number the nodes from <tt>0</tt> to
--   <tt>(n-1)</tt> in a left-to-right traversal fashion, where <tt>n ==
--   length (universe tree)</tt> is the number of substructures, which is
--   also returned.
enumerateNodes :: Traversable f => Mu f -> (Int, Attr f Int)
enumerateNodes_ :: Traversable f => Mu f -> Attr f Int

-- | Bottom-up transformations which automatically resynthetise attributes
--   in case of changes.
synthTransform :: Traversable f => (f a -> a) -> (Attr f a -> Maybe (f (Attr f a))) -> Attr f a -> Attr f a
synthTransform' :: Traversable f => (f (Attr f a) -> a) -> (Attr f a -> Maybe (f (Attr f a))) -> Attr f a -> Attr f a

-- | Bottom-up transformations to normal form (applying transformation
--   exhaustively) which automatically resynthetise attributes in case of
--   changes.
synthRewrite :: Traversable f => (f a -> a) -> (Attr f a -> Maybe (f (Attr f a))) -> Attr f a -> Attr f a
synthRewrite' :: Traversable f => (f (Attr f a) -> a) -> (Attr f a -> Maybe (f (Attr f a))) -> Attr f a -> Attr f a

-- | Merges two layers of annotations into a single one.
annZip :: Functor f => Mu (Ann (Ann f a) b) -> Attr f (a, b)
annZipWith :: Functor f => (a -> b -> c) -> Mu (Ann (Ann f a) b) -> Attr f c

-- | Merges three layers of annotations into a single one.
annZip3 :: Functor f => Mu (Ann (Ann (Ann f a) b) c) -> Attr f (a, b, c)
annZipWith3 :: Functor f => (a -> b -> c -> d) -> Mu (Ann (Ann (Ann f a) b) c) -> Attr f d


-- | Generic ascii art / graphviz drawing of trees.
--   
--   Suggestions for drawing styles are welcome.
--   
--   TODO:
--   
--   <ul>
--   <li>make the style customizable</li>
--   <li>the same for graphviz</li>
--   </ul>
module Data.Generics.Fixplate.Draw

-- | Prints a tree. It is defined simply as
--   
--   <pre>
--   drawTree = putStrLn . showTree
--   </pre>
drawTree :: (Functor f, Foldable f, ShowF f) => Mu f -> IO ()

-- | Creates a string representation which can be printed with
--   <a>putStrLn</a>.
showTree :: (Functor f, Foldable f, ShowF f) => Mu f -> String

-- | Generate a graphviz <tt>.dot</tt> file
graphvizTree :: (Traversable f, ShowF f) => Mu f -> String
drawTreeWith :: (Functor f, Foldable f) => (f Hole -> String) -> Mu f -> IO ()
showTreeWith :: (Functor f, Foldable f) => (f Hole -> String) -> Mu f -> String
graphvizTreeWith :: Traversable f => (f Hole -> String) -> Mu f -> String
instance Show Void


-- | The Zipper is a data structure which maintains a location in a tree,
--   and allows O(1) movement and local changes (to be more precise, in our
--   case it is O(k) where k is the number of children of the node at
--   question; typically this is a very small number).
module Data.Generics.Fixplate.Zipper

-- | A context node.
type Node f = Either (Mu f) (Path f)

-- | The context or path type. The invariant we must respect is that there
--   is exactly one child with the <a>Right</a> constructor.
data Path f
Top :: Path f
Path :: f (Node f) -> Path f
unPath :: Path f -> f (Node f)

-- | The zipper type itself, which encodes a locations in thre tree <tt>Mu
--   f</tt>.
data Loc f
Loc :: Mu f -> Path f -> Loc f
focus :: Loc f -> Mu f
path :: Loc f -> Path f

-- | Creates a zipper from a tree, with the focus at the root.
root :: Mu f -> Loc f

-- | Restores a tree from a zipper.
defocus :: Traversable f => Loc f -> Mu f

-- | We attribute all nodes with a zipper focused at that location.
locations :: Traversable f => Mu f -> Attr f (Loc f)

-- | The list of all locations.
locationsList :: Traversable f => Mu f -> [Loc f]

-- | The zipper version of <a>forget</a>.
locForget :: Functor f => Loc (Ann f a) -> Loc f

-- | Extracts the subtree at focus. Synonym of <a>focus</a>.
extract :: Loc f -> Mu f

-- | Replaces the subtree at focus.
replace :: Mu f -> Loc f -> Loc f

-- | Modifies the subtree at focus.
modify :: (Mu f -> Mu f) -> Loc f -> Loc f

-- | Moves down to the child with the given index. The leftmost children
--   has index <tt>0</tt>.
moveDown :: Traversable f => Int -> Loc f -> Maybe (Loc f)

-- | Moves down to the leftmost child.
moveDownL :: Traversable f => Loc f -> Maybe (Loc f)

-- | Moves down to the rightmost child.
moveDownR :: Traversable f => Loc f -> Maybe (Loc f)

-- | Moves up.
moveUp :: Traversable f => Loc f -> Maybe (Loc f)
moveRight :: Traversable f => Loc f -> Maybe (Loc f)
moveLeft :: Traversable f => Loc f -> Maybe (Loc f)

-- | Checks whether we are at the top (root).
isTop :: Loc f -> Bool

-- | Checks whether we cannot move down.
isBottom :: Traversable f => Loc f -> Bool
isLeftmost :: Traversable f => Loc f -> Bool
isRightmost :: Traversable f => Loc f -> Bool

-- | Gives back the index of the given location among the children of its
--   parent. Indexing starts from zero. In case of root node (no parent),
--   we also return zero.
horizontalPos :: Foldable f => Loc f -> Int

-- | We return the full path from the root as a sequence of child indices.
--   This means that
--   
--   <pre>
--   loc == foldl (flip unsafeMoveDown) (moveTop loc) (fullPathDown loc)
--   </pre>
fullPathDown :: Foldable f => Loc f -> [Int]

-- | The following equations hold for <a>fullPathUp</a> and
--   <a>fullPathDown</a>:
--   
--   <pre>
--   fullPathUp == reverse . fullPathDown
--   loc == foldr unsafeMoveDown (moveTop loc) (fullPathUp loc)
--   </pre>
fullPathUp :: Foldable f => Loc f -> [Int]

-- | Moves to the top, by repeatedly moving up.
moveTop :: Traversable f => Loc f -> Loc f

-- | Moves left until it can. It should be faster than repeated left steps.
leftmost :: Traversable f => Loc f -> Loc f

-- | Moves right until it can. It should be faster than repeated right
--   steps.
rightmost :: Traversable f => Loc f -> Loc f
unsafeMoveDown :: Traversable f => Int -> Loc f -> Loc f
unsafeMoveDownL :: Traversable f => Loc f -> Loc f
unsafeMoveDownR :: Traversable f => Loc f -> Loc f
unsafeMoveUp :: Traversable f => Loc f -> Loc f
unsafeMoveLeft, unsafeMoveRight :: Traversable f => Loc f -> Loc f
instance ReadF f => Read (Loc f)
instance ReadF f => Read (Path f)
instance ShowF f => Show (Loc f)
instance ShowF f => Show (Path f)
instance EqF f => Eq (Loc f)
instance EqF f => Eq (Path f)


-- | Generalized tries. "Normal" tries encode finite maps from lists to
--   arbitrary values, where the common prefixes are shared. Here we do the
--   same for trees, generically.
--   
--   See also
--   
--   <ul>
--   <li>Connelly, Morris: A generalization of the trie data structure</li>
--   <li>Ralf Hinze: Generalizing Generalized Tries</li>
--   </ul>
--   
--   This module should be imported qualified.
module Data.Generics.Fixplate.Trie

-- | <a>Trie</a> is an efficient(?) implementation of finite maps from
--   <tt>(Mu f)</tt> to an arbitrary type <tt>v</tt>.
data Trie f v
empty :: (Functor f, Foldable f, OrdF f) => Trie f a
singleton :: (Functor f, Foldable f, OrdF f) => Mu f -> a -> Trie f a

-- | TODO: more efficient implementation?
fromList :: (Traversable f, OrdF f) => [(Mu f, a)] -> Trie f a
toList :: (Traversable f, OrdF f) => Trie f a -> [(Mu f, a)]

-- | Creates a trie-multiset from a list of trees.
bag :: (Functor f, Foldable f, OrdF f) => [Mu f] -> Trie f Int

-- | This is equivalent to
--   
--   <pre>
--   universeBag == bag . universe
--   </pre>
--   
--   TODO: more efficient implementation?
universeBag :: (Functor f, Foldable f, OrdF f) => Mu f -> Trie f Int
lookup :: (Functor f, Foldable f, OrdF f) => Mu f -> Trie f a -> Maybe a
insert :: (Functor f, Foldable f, OrdF f) => Mu f -> a -> Trie f a -> Trie f a
insertWith :: (Functor f, Foldable f, OrdF f) => (a -> b) -> (a -> b -> b) -> Mu f -> a -> Trie f b -> Trie f b
delete :: (Functor f, Foldable f, OrdF f) => Mu f -> Trie f a -> Trie f a
update :: (Functor f, Foldable f, OrdF f) => (a -> Maybe a) -> Mu f -> Trie f a -> Trie f a
intersection :: (Functor f, Foldable f, OrdF f) => Trie f a -> Trie f b -> Trie f a
intersectionWith :: (Functor f, Foldable f, OrdF f) => (a -> b -> c) -> Trie f a -> Trie f b -> Trie f c

-- | Union is left-biased:
--   
--   <pre>
--   union == unionWith const
--   </pre>
union :: (Functor f, Foldable f, OrdF f) => Trie f a -> Trie f a -> Trie f a
unionWith :: (Functor f, Foldable f, OrdF f) => (a -> a -> a) -> Trie f a -> Trie f a -> Trie f a
difference :: (Functor f, Foldable f, OrdF f) => Trie f a -> Trie f b -> Trie f a
differenceWith :: (Functor f, Foldable f, OrdF f) => (a -> b -> Maybe a) -> Trie f a -> Trie f b -> Trie f a
instance OrdF f => Ord (HoleF f)
instance EqF f => Eq (HoleF f)


-- | This library provides Uniplate-style generic traversals and other
--   recursion schemes for fixed-point types. There are many advantages of
--   using fixed-point types instead of explicit recursion:
--   
--   <ul>
--   <li>we can easily add attributes to the nodes of an existing
--   tree;</li>
--   <li>there is no need for a custom type class, we can build everything
--   on the top of <a>Functor</a>, <a>Foldable</a> and <a>Traversable</a>,
--   for which GHC can derive the instances for us;</li>
--   <li>we can provide interesting recursion schemes</li>
--   <li>some operations can retain the structure of the tree, instead
--   flattening it into a list;</li>
--   <li>it is relatively straightforward to provide generic
--   implementations of the zipper, tries, tree drawing, hashing,
--   etc...</li>
--   </ul>
--   
--   The main disadvantage is that it does not work well for mutually
--   recursive data types, and that pattern matching becomes more tedious
--   (but there are partial solutions for the latter).
--   
--   Consider as an example the following simple expression language,
--   encoded by a recursive algebraic data type:
--   
--   <pre>
--   data Expr 
--     = Kst Int 
--     | Var String 
--     | Add Expr Expr
--     deriving (Eq,Show)
--   </pre>
--   
--   We can open up the recursion, and obtain a <i>functor</i> instead:
--   
--   <pre>
--   data Expr1 e 
--     = Kst Int 
--     | Var String 
--     | Add e e 
--     deriving (Eq,Show,Functor,Foldable,Traversable)
--   </pre>
--   
--   The fixed-point type <a>Mu</a><tt> Expr1</tt> is isomorphic to
--   <tt>Expr</tt>. However, we can also add some attributes to the nodes:
--   The type <a>Attr</a> <tt>Expr1 a = </tt><a>Mu</a><tt>
--   (</tt><a>Ann</a><tt> Expr1 a)</tt> is the type of with the same
--   structure, but with each node having an extra field of type
--   <tt>a</tt>.
--   
--   The functions in this library work on types like that: <a>Mu</a><tt>
--   f</tt>, where <tt>f</tt> is a functor, and sometimes explicitely on
--   <a>Attr</a><tt> f a</tt>.
--   
--   The organization of the modules (excluding Util.*) is the following:
--   
--   <ul>
--   <li><a>Data.Generics.Fixplate.Base</a> - core types and type
--   classes</li>
--   <li><a>Data.Generics.Fixplate.Traversals</a> - Uniplate-style
--   traversals</li>
--   <li><a>Data.Generics.Fixplate.Morphisms</a> - recursion schemes</li>
--   <li><a>Data.Generics.Fixplate.Attributes</a> - annotated trees</li>
--   <li><a>Data.Generics.Fixplate.Open</a> - functions operating on
--   functors</li>
--   <li><a>Data.Generics.Fixplate.Zipper</a> - generic zipper</li>
--   <li><a>Data.Generics.Fixplate.Draw</a> - generic tree drawing (both
--   ASCII and graphviz)</li>
--   <li><a>Data.Generics.Fixplate.Trie</a> - generic generalized
--   tries</li>
--   <li><a>Data.Generics.Fixplate.Hash</a> - annotating trees with their
--   hashes</li>
--   </ul>
--   
--   This module re-exports the most common functionality present in the
--   library (but not for example the zipper, tries, hashing).
--   
--   The library itself should be fully Haskell98 compatible; no language
--   extensions are used. Note: to obtain <a>Eq</a>, <a>Ord</a>,
--   <a>Show</a>, <a>Read</a> and other instances for fixed point types
--   like <tt>Mu Expr1</tt>, consult the documentation of the <a>EqF</a>
--   type class (cf. the related <a>OrdF</a>, <a>ShowF</a> and <a>ReadF</a>
--   classes)
module Data.Generics.Fixplate

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Data structures that can be folded.
--   
--   Minimal complete definition: <a>foldMap</a> or <a>foldr</a>.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
class Foldable (t :: * -> *)
fold :: (Foldable t, Monoid m) => t m -> m
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   Minimal complete definition: <a>traverse</a> or <a>sequenceA</a>.
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: * -> *)
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)


-- | Generic hashing on trees. We recursively compute hashes of all
--   subtrees, giving fast inequality testing, and a fast, but meaningless
--   (more-or-less random) ordering on the set of trees (so that we can put
--   them into Map-s).
--   
--   The way it works is that when we compute the hash of a node, we use
--   the hashes of the children directly; this way, you can also
--   incrementally build up a hashed tree.
module Data.Generics.Fixplate.Hash

-- | Hash annotation (question: should the Hash field be strict? everything
--   else in the library is lazy...)
--   
--   This is custom datatype instead of reusing <a>Ann</a> because of the
--   different Eq/Ord instances we need.
data HashAnn hash f a
HashAnn :: hash -> (f a) -> HashAnn hash f a
getHash :: HashAnn hash f a -> hash
unHashAnn :: HashAnn hash f a -> f a

-- | A tree annotated with hashes of all subtrees. This gives us fast
--   inequality testing, and fast (but meaningless!) ordering for
--   <tt>Map</tt>-s.
type HashMu hash f = Mu (HashAnn hash f)

-- | The hash of the complete tree.
topHash :: HashMu hash f -> hash
forgetHash :: Functor f => HashMu hash f -> Mu f

-- | A concrete hash implementation. We don't use type classes since
--   
--   <ul>
--   <li>a hash type class does not belong to this library;</li>
--   <li>we don't want to restrict the user's design space</li>
--   </ul>
--   
--   Thus we simulate type classes with record types.
data HashValue hash
HashValue :: hash -> (Char -> hash -> hash) -> (hash -> hash -> hash) -> HashValue hash

-- | the hash of an empty byte sequence
_emptyHash :: HashValue hash -> hash

-- | digest a (unicode) character
_hashChar :: HashValue hash -> Char -> hash -> hash

-- | digest a hash value
_hashHash :: HashValue hash -> hash -> hash -> hash

-- | This function uses the <a>ShowF</a> instance to compute the hash of a
--   node; this way you always have a working version without writing any
--   additional code.
--   
--   However, you can also supply your own hash implementation (which can
--   be more efficient, for example), if you use <a>hashTreeWith</a>
--   instead.
hashTree :: (Foldable f, Functor f, ShowF f) => HashValue hash -> Mu f -> HashMu hash f
hashTreeWith :: (Foldable f, Functor f) => HashValue hash -> (f Hole -> hash -> hash) -> Mu f -> HashMu hash f

-- | Build a hashed node from the children.
hashNode :: (Foldable f, Functor f, ShowF f) => HashValue hash -> f (HashMu hash f) -> HashMu hash f
hashNodeWith :: (Foldable f, Functor f) => HashValue hash -> (f Hole -> hash -> hash) -> f (HashMu hash f) -> HashMu hash f
instance (Show hash, Show (f a)) => Show (HashAnn hash f a)
instance Show Void
instance (ShowF f, Show hash) => ShowF (HashAnn hash f)
instance (Ord hash, OrdF f) => OrdF (HashAnn hash f)
instance (Eq hash, EqF f) => EqF (HashAnn hash f)
instance Traversable f => Traversable (HashAnn hash f)
instance Foldable f => Foldable (HashAnn hash f)
instance Functor f => Functor (HashAnn hash f)


-- | Hash tables, implemented as a structure similar to <tt>Map hash (Map
--   key value)]</tt>.
--   
--   What this data structure can also give you is a unique value (a
--   <tt>(hash,Int)</tt> pair) for each key, even during building the
--   table: It is guaranteed to be unique in the past and future lifetime
--   of a single hashtable (that is, one realization of the world-line),
--   among all the keys appearing in that history.
--   
--   Set operations (union, intersection) clearly break this principle;
--   this is resolved by declaring these operations to be
--   <i>left-biased</i>, in the sense that they retain the unique values of
--   the left table (so <tt>union t1 t2</tt> belongs to to <tt>t1</tt>'s
--   world-line, but not to <tt>t2</tt>'s one).
--   
--   If a key is first removed then added back again, it will get a new
--   value.
--   
--   To be Haskell98 compatible (no multi-param type classes), when
--   constructing a new hash table, we have to support the function
--   computing (or just fetching, if it is cached) the hash value. This
--   function is then stored in the data type.
module Data.Generics.Fixplate.Util.Hash.Table
data HashTable hash k v
data Bucket k v
Bucket :: {-# UNPACK #-} !Int -> !Map k (Leaf v) -> Bucket k v
data Leaf v
Leaf :: {-# UNPACK #-} !Int -> v -> Leaf v
getHashValue :: HashTable hash k v -> k -> hash
unHashTable :: HashTable hash k v -> Map hash (Bucket k v)
empty :: (Ord hash, Ord k) => (k -> hash) -> HashTable hash k v
singleton :: (Ord hash, Ord k) => (k -> hash) -> k -> v -> HashTable hash k v
fromList :: (Ord hash, Ord k) => (k -> hash) -> [(k, v)] -> HashTable hash k v

-- | Note that the returned list is ordered by hash, <i>not</i> by keys
--   like <a>Map</a>!
toList :: Ord k => HashTable hash k v -> [(k, v)]
null :: (Ord hash, Ord k) => HashTable hash k v -> Bool

-- | Creates a multi-set from a list.
bag :: (Ord hash, Ord k) => (k -> hash) -> [k] -> HashTable hash k Int
lookup :: (Ord hash, Ord k) => k -> HashTable hash k v -> Maybe v
member :: (Ord hash, Ord k) => k -> HashTable hash k v -> Bool
insert :: (Ord hash, Ord k) => k -> v -> HashTable hash k v -> HashTable hash k v
insertWith :: (Ord hash, Ord k) => (a -> v) -> (a -> v -> v) -> k -> a -> HashTable hash k v -> HashTable hash k v
delete :: (Ord hash, Ord k) => k -> HashTable hash k v -> HashTable hash k v

-- | <pre>
--   union == unionWith const
--   </pre>
union :: (Ord hash, Ord k) => HashTable hash k a -> HashTable hash k a -> HashTable hash k a

-- | This is unsafe in the sense that the two <tt>getHash</tt> functions
--   (supplied when the hash tables were created) must agree. The same
--   applies for all the set operations.
--   
--   It is also left-biased in the sense that the unique indices from the
--   left hashtable are retained, while the unique indices from the right
--   hashtable are <i>changed</i>.
unionWith :: (Ord hash, Ord k) => (v -> v -> v) -> HashTable hash k v -> HashTable hash k v -> HashTable hash k v

-- | This is unsafe both in the above sense and also that it does not
--   accepts the empty list (for the same reason). The result belongs to
--   the world-line of the first table.
unionsWith :: (Ord hash, Ord k) => (v -> v -> v) -> [HashTable hash k v] -> HashTable hash k v

-- | This one accepts the empty list. The empty imput creates a new
--   world-line.
unionsWith' :: (Ord hash, Ord k) => (k -> hash) -> (v -> v -> v) -> [HashTable hash k v] -> HashTable hash k v

-- | <pre>
--   intersection == intersectionWith const
--   </pre>
intersection :: (Ord hash, Ord k) => HashTable hash k a -> HashTable hash k b -> HashTable hash k a
intersectionWith :: (Ord hash, Ord k) => (a -> b -> c) -> HashTable hash k a -> HashTable hash k b -> HashTable hash k c
intersectionsWith :: (Ord hash, Ord k) => (v -> v -> v) -> [HashTable hash k v] -> HashTable hash k v
intersectionsWith' :: (Ord hash, Ord k) => (k -> hash) -> (v -> v -> v) -> [HashTable hash k v] -> HashTable hash k v
difference :: (Ord hash, Ord k) => HashTable hash k a -> HashTable hash k b -> HashTable hash k a
differenceWith :: (Ord hash, Ord k) => (a -> b -> Maybe a) -> HashTable hash k a -> HashTable hash k b -> HashTable hash k a

-- | Look up a unique index, in the form of a <tt>(hash,Int)</tt> pair, for
--   any key. If the user-supplied function is <i>injective</i>, then the
--   result is guaranteed to be uniquely associated to the given key in the
--   past and future history of this table (but of course not unique among
--   different future histories).
getUniqueIndex :: (Ord hash, Ord k) => (hash -> Int -> a) -> k -> HashTable hash k v -> Maybe a

-- | Keys together with their associated unique values
keysWith :: Ord k => (k -> hash -> Int -> a) -> HashTable hash k v -> [a]
mapWithUniqueIndices :: (Ord hash, Ord k) => (hash -> Int -> a -> b) -> HashTable hash k a -> HashTable hash k b


-- | Haskell98 polymorphic Hash interface
module Data.Generics.Fixplate.Util.Hash.Class

-- | A type class for hashes. Minimal complete definition:
--   <a>emptyHash</a>, <a>hashWord8</a>, <a>hashHash</a> and
--   <a>showHex</a>.
class (Eq hash, Ord hash, Hashable hash) => HashValue hash where hashWord32 w = hashWord8 a . hashWord8 b . hashWord8 c . hashWord8 d where a = fromIntegral (255 .&. (w)) b = fromIntegral (255 .&. (shiftR w 8)) c = fromIntegral (255 .&. (shiftR w 16)) d = fromIntegral (255 .&. (shiftR w 24)) hashWord16 w = hashWord8 a . hashWord8 b where a = fromIntegral (255 .&. (w)) b = fromIntegral (255 .&. (shiftR w 8)) hashWord64 w = hashWord32 a . hashWord32 b where a = fromIntegral (4294967295 .&. (w)) b = fromIntegral (4294967295 .&. (shiftR w 32))
hashWord8 :: HashValue hash => Word8 -> hash -> hash
hashWord16 :: HashValue hash => Word16 -> hash -> hash
hashWord32 :: HashValue hash => Word32 -> hash -> hash
hashWord64 :: HashValue hash => Word64 -> hash -> hash
emptyHash :: HashValue hash => hash
hashHash :: HashValue hash => hash -> hash -> hash
showHex :: HashValue hash => hash -> String

-- | A type class of hashable objects. An instance has to compute the hash
--   for <i>any</i> hash function, using the "base" types (eg. Word32).
--   
--   Minimal complete definition: <a>hashDigest</a>. The default for
--   <a>computeHash</a> is
--   
--   <pre>
--   computeHash x = hashDigest x emptyHash
--   </pre>
class Hashable a where computeHash x = hashDigest x emptyHash
hashDigest :: (Hashable a, HashValue hash) => a -> hash -> hash
computeHash :: (Hashable a, HashValue hash) => a -> hash
hashInt :: HashValue hash => Int -> hash -> hash
hashWord :: HashValue hash => Word -> hash -> hash
hashBool :: HashValue hash => Bool -> hash -> hash
hashChar :: HashValue hash => Char -> hash -> hash
instance (Hashable a, Hashable b, Hashable c, Hashable d, Hashable e) => Hashable (a, b, c, d, e)
instance (Hashable a, Hashable b, Hashable c, Hashable d) => Hashable (a, b, c, d)
instance (Hashable a, Hashable b, Hashable c) => Hashable (a, b, c)
instance (Hashable a, Hashable b) => Hashable (a, b)
instance Hashable a => Hashable [a]
instance Hashable Char
instance Hashable Bool
instance Hashable Word
instance Hashable Int
instance Hashable Word64
instance Hashable Word32
instance Hashable Word16
instance Hashable Word8


-- | 32-bit FNV-1a (Fowler-Noll-Vo) hash
module Data.Generics.Fixplate.Util.Hash.FNV.FNV32
newtype FNV32
FNV32 :: Word32 -> FNV32
unFNV32 :: FNV32 -> Word32
instance Eq FNV32
instance Ord FNV32
instance Show FNV32
instance HashValue FNV32
instance Hashable FNV32


-- | 64-bit FNV-1a (Fowler-Noll-Vo) hash
module Data.Generics.Fixplate.Util.Hash.FNV.FNV64
newtype FNV64
FNV64 :: Word64 -> FNV64
unFNV64 :: FNV64 -> Word64
instance Eq FNV64
instance Ord FNV64
instance Show FNV64
instance HashValue FNV64
instance Hashable FNV64
