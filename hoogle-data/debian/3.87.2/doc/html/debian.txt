-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Modules for working with the Debian package system
--   
@package debian
@version 3.87.2


-- | There are old index files that have funky characters like 'Ã¸' that are
--   not properly UTF8 encoded. As far as I can tell, these files are
--   otherwise plain ascii, so just naivelyinsert the character into the
--   output stream.
module Debian.UTF8
decode :: ByteString -> Text
readFile :: FilePath -> IO Text


-- | Domain independent functions used by the haskell-debian package.
module Debian.Extra.Files
withTemporaryFile :: MonadIO m => (FilePath -> m a) -> String -> m a

module Debian.Loc
__LOC__ :: Q Exp
mapExn :: (MonadCatch m, Exception e) => m a -> (e -> e) -> m a


-- | A constructor we can wrap around values to avoid any built in Pretty
--   instance - for example, instance Pretty [a].
--   
--   <ul>
--   <li>display is now prettyShow</li>
--   <li>display' is now prettyText</li>
--   <li>ppDisplay is now ppShow</li>
--   <li>ppDisplay' is now ppText</li>
--   </ul>
module Debian.Pretty

-- | This type is wrapped around values before we pretty print them so we
--   can write our own Pretty instances for common types without polluting
--   the name space of clients of this package with instances they don't
--   want.
newtype PP a
PP :: a -> PP a
unPP :: PP a -> a

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String
prettyText :: Pretty a => a -> Text
ppPrint :: Pretty (PP a) => a -> Doc
ppShow :: Pretty (PP a) => a -> String
ppText :: Pretty (PP a) => a -> Text
instance Functor PP
instance Pretty (PP a) => Pretty (PP (Maybe a))
instance Pretty (PP String)
instance Pretty (PP Text)


-- | A module for parsing, comparing, and (eventually) modifying debian
--   version numbers.
--   <a>http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version</a>
module Debian.Version.Common
data DebianVersion
prettyDebianVersion :: DebianVersion -> Doc
class ParseDebianVersion a
parseDebianVersion :: ParseDebianVersion a => a -> DebianVersion

-- | Split a DebianVersion into its three components: epoch, version,
--   revision. It is not safe to use the parsed version number for this
--   because you will lose information, such as leading zeros.
evr :: DebianVersion -> (Maybe Int, String, Maybe String)
epoch :: DebianVersion -> Maybe Int
version :: DebianVersion -> String
revision :: DebianVersion -> Maybe String
buildDebianVersion :: Maybe Int -> String -> Maybe String -> DebianVersion

-- | Convert a string to a debian version number. May throw an exception if
--   the string is unparsable -- but I am not sure if that can currently
--   happen. Are there any invalid version strings? Perhaps ones with
--   underscore, or something?
parseDV :: CharParser () (Found Int, NonNumeric, Found NonNumeric)
instance Ord Numeric
instance Eq Numeric
instance Ord NonNumeric
instance Eq NonNumeric
instance Show DebianVersion
instance Ord DebianVersion
instance Eq DebianVersion
instance Pretty (PP DebianVersion)

module Debian.Version.String
class ParseDebianVersion a
parseDebianVersion :: ParseDebianVersion a => a -> DebianVersion
instance Read DebianVersion
instance ParseDebianVersion String

module Debian.Version.ByteString
class ParseDebianVersion a
parseDebianVersion :: ParseDebianVersion a => a -> DebianVersion
instance ParseDebianVersion ByteString

module Debian.Version.Text
class ParseDebianVersion a
parseDebianVersion :: ParseDebianVersion a => a -> DebianVersion
instance ParseDebianVersion Text

module Debian.Arch
data Arch
Source :: Arch
All :: Arch
Binary :: ArchOS -> ArchCPU -> Arch
data ArchOS
ArchOS :: String -> ArchOS
ArchOSAny :: ArchOS
data ArchCPU
ArchCPU :: String -> ArchCPU
ArchCPUAny :: ArchCPU
prettyArch :: Arch -> Doc
parseArch :: String -> Arch
instance Typeable ArchOS
instance Typeable ArchCPU
instance Typeable Arch
instance Eq ArchOS
instance Ord ArchOS
instance Read ArchOS
instance Show ArchOS
instance Data ArchOS
instance Eq ArchCPU
instance Ord ArchCPU
instance Read ArchCPU
instance Show ArchCPU
instance Data ArchCPU
instance Eq Arch
instance Ord Arch
instance Read Arch
instance Show Arch
instance Data Arch

module Debian.Time
rfc822DateFormat' :: String
epochTimeToUTCTime :: EpochTime -> UTCTime
formatTimeRFC822 :: FormatTime t => t -> String
parseTimeRFC822 :: ParseTime t => String -> Maybe t
getCurrentLocalRFC822Time :: IO String

module Debian.URI

-- | A wrapper around a String containing a known parsable URI. Not
--   absolutely safe, because you could say read "URI' "bogus string"" ::
--   URI'. But enough to save me from myself.
data URI'

-- | Using the bogus Show instance of URI here. If it ever gets fixed this
--   will stop working. Worth noting that show will obscure any password
--   info embedded in the URI, so that's nice.
toURI' :: URI -> URI'
fromURI' :: URI' -> URI
readURI' :: String -> Maybe URI'
uriToString' :: URI -> String
fileFromURI :: URI -> IO (Either SomeException ByteString)
fileFromURIStrict :: URI -> IO (Either SomeException ByteString)
dirFromURI :: URI -> IO (Either SomeException [String])
instance Read URI'
instance Show URI'
instance Eq URI'
instance Ord URI'

module Debian.Release

-- | A distribution (aka release) name. This type is expected to refer to a
--   subdirectory of the dists directory which is at the top level of a
--   repository.
data ReleaseName
ReleaseName :: String -> ReleaseName
relName :: ReleaseName -> String
parseReleaseName :: String -> ReleaseName
releaseName' :: ReleaseName -> String

-- | A section of a repository such as main, contrib, non-free, restricted.
--   The indexes for a section are located below the distribution
--   directory.
newtype Section
Section :: String -> Section

-- | A package's subsection is only evident in its control information,
--   packages from different subsections all reside in the same index.
data SubSection
SubSection :: Section -> String -> SubSection
section :: SubSection -> Section
subSectionName :: SubSection -> String
sectionName :: SubSection -> String
sectionName' :: Section -> String
sectionNameOfSubSection :: SubSection -> String

-- | Parse the value that appears in the <tt>Section</tt> field of a
--   .changes file. (Does this need to be unesacped?)
parseSection :: String -> SubSection
parseSection' :: String -> Section
instance Typeable ReleaseName
instance Eq ReleaseName
instance Ord ReleaseName
instance Read ReleaseName
instance Show ReleaseName
instance Data ReleaseName
instance Read Section
instance Show Section
instance Eq Section
instance Ord Section
instance Read SubSection
instance Show SubSection
instance Eq SubSection
instance Ord SubSection

module Debian.Sources
data SourceType
Deb :: SourceType
DebSrc :: SourceType
data DebSource
DebSource :: SourceType -> URI -> Either String (ReleaseName, [Section]) -> DebSource
sourceType :: DebSource -> SourceType
sourceUri :: DebSource -> URI
sourceDist :: DebSource -> Either String (ReleaseName, [Section])

-- | This is a name given to a combination of parts of one or more releases
--   that can be specified by a sources.list file.
type SliceName = ReleaseName

-- | quoteWords - similar to words, but with special handling of
--   double-quotes and brackets.
--   
--   The handling double quotes and [] is supposed to match:
--   apt-0.6.44.2/apt-pkg/contrib/strutl.cc:ParseQuoteWord()
--   
--   The behaviour can be defined as:
--   
--   Break the string into space seperated words ignoring spaces that
--   appear between "" or []. Strip trailing and leading white space around
--   words. Strip out double quotes, but leave the square brackets intact.
quoteWords :: String -> [String]
stripLine :: String -> String
sourceLines :: String -> [String]

-- | parseSourceLine -- parses a source line the argument must be a
--   non-empty, valid source line with comments stripped see:
--   <a>sourceLines</a>
parseSourceLine :: String -> DebSource
parseSourceLine' :: String -> Maybe DebSource
parseSourcesList :: String -> [DebSource]
instance Eq SourceType
instance Ord SourceType
instance Show SourceType
instance Eq DebSource
instance Ord DebSource
instance Show DebSource
instance Pretty (PP [DebSource])
instance Pretty DebSource
instance Pretty SourceType

module Debian.Control.Common
newtype Control' a
Control :: [Paragraph' a] -> Control' a
unControl :: Control' a -> [Paragraph' a]
newtype Paragraph' a
Paragraph :: [Field' a] -> Paragraph' a

-- | NOTE: we do not strip the leading or trailing whitespace in the name
--   or value
data Field' a
Field :: (a, a) -> Field' a

-- | Lines beginning with #
Comment :: a -> Field' a
class ControlFunctions a
parseControlFromFile :: ControlFunctions a => FilePath -> IO (Either ParseError (Control' a))
parseControlFromHandle :: ControlFunctions a => String -> Handle -> IO (Either ParseError (Control' a))
parseControl :: ControlFunctions a => String -> a -> (Either ParseError (Control' a))
lookupP :: ControlFunctions a => String -> (Paragraph' a) -> Maybe (Field' a)
stripWS :: ControlFunctions a => a -> a
protectFieldText :: ControlFunctions a => a -> a
asString :: ControlFunctions a => a -> String
mergeControls :: [Control' a] -> Control' a
fieldValue :: ControlFunctions a => String -> Paragraph' a -> Maybe a
removeField :: Eq a => a -> Paragraph' a -> Paragraph' a
prependFields :: [Field' a] -> Paragraph' a -> Paragraph' a
appendFields :: [Field' a] -> Paragraph' a -> Paragraph' a
renameField :: Eq a => a -> a -> Paragraph' a -> Paragraph' a
modifyField :: Eq a => a -> (a -> a) -> Paragraph' a -> Paragraph' a

-- | Move selected fields to the beginning of a paragraph.
raiseFields :: Eq a => (a -> Bool) -> Paragraph' a -> Paragraph' a

-- | Run a command and parse its output as a control file.
parseControlFromCmd :: ControlFunctions a => String -> IO (Either String (Control' a))

-- | look up the md5sum file in a paragraph Tries several different
--   variations: MD5Sum: Md5Sum: MD5sum:
md5sumField :: ControlFunctions a => Paragraph' a -> Maybe a

-- | This can usually be used as the implementation of protectFieldText
protectFieldText' :: (StringLike a, ListLike a Char) => ControlFunctions a => a -> a
instance Eq a => Eq (Field' a)
instance Ord a => Ord (Field' a)
instance Read a => Read (Field' a)
instance Show a => Show (Field' a)
instance Eq a => Eq (Paragraph' a)
instance Ord a => Ord (Paragraph' a)
instance Read a => Read (Paragraph' a)
instance Show a => Show (Paragraph' a)
instance Eq a => Eq (Control' a)
instance Ord a => Ord (Control' a)
instance Read a => Read (Control' a)
instance Show a => Show (Control' a)
instance (ControlFunctions a, Pretty (PP a)) => Pretty (Field' a)
instance (ControlFunctions a, Pretty (PP a)) => Pretty (Paragraph' a)
instance (ControlFunctions a, Pretty (PP a)) => Pretty (Control' a)

module Debian.Control.String
newtype Control' a
Control :: [Paragraph' a] -> Control' a
newtype Paragraph' a
Paragraph :: [Field' a] -> Paragraph' a

-- | NOTE: we do not strip the leading or trailing whitespace in the name
--   or value
data Field' a
Field :: (a, a) -> Field' a

-- | Lines beginning with #
Comment :: a -> Field' a
type Control = Control' String
type Paragraph = Paragraph' String
type Field = Field' String
type ControlParser a = CharParser () a
class ControlFunctions a
parseControlFromFile :: ControlFunctions a => FilePath -> IO (Either ParseError (Control' a))
parseControlFromHandle :: ControlFunctions a => String -> Handle -> IO (Either ParseError (Control' a))
parseControl :: ControlFunctions a => String -> a -> (Either ParseError (Control' a))
lookupP :: ControlFunctions a => String -> (Paragraph' a) -> Maybe (Field' a)
stripWS :: ControlFunctions a => a -> a
protectFieldText :: ControlFunctions a => a -> a
asString :: ControlFunctions a => a -> String

-- | A parser for debian control file. This parser handles control files
--   that end without a newline as well as ones that have several blank
--   lines at the end. It is very liberal and does not attempt validate the
--   fields in any way. All trailing, leading, and folded whitespace is
--   preserved in the field values. See <a>stripWS</a>.
pControl :: ControlParser Control
mergeControls :: [Control' a] -> Control' a
fieldValue :: ControlFunctions a => String -> Paragraph' a -> Maybe a
removeField :: Eq a => a -> Paragraph' a -> Paragraph' a
prependFields :: [Field' a] -> Paragraph' a -> Paragraph' a
appendFields :: [Field' a] -> Paragraph' a -> Paragraph' a
renameField :: Eq a => a -> a -> Paragraph' a -> Paragraph' a
modifyField :: Eq a => a -> (a -> a) -> Paragraph' a -> Paragraph' a

-- | Move selected fields to the beginning of a paragraph.
raiseFields :: Eq a => (a -> Bool) -> Paragraph' a -> Paragraph' a
instance ControlFunctions String

module Debian.Deb
fields :: ControlFunctions a => FilePath -> IO (Control' a)


-- | an interface for using the methods in <i>var</i>lib<i>apt</i>methods
module Debian.Apt.Methods

-- | withMethod - run |methodPath| bracketed with openMethod/closeMethod.
--   |f| gets the open handle.
withMethodPath :: FilePath -> (MethodHandle -> IO a) -> IO a
withMethodURI :: URI -> (MethodHandle -> IO a) -> IO a

-- | whichMethodBinary - find the method executable associated with a URI
--   throws an exception on failure
whichMethodPath :: URI -> IO (Maybe FilePath)
openMethod :: FilePath -> IO MethodHandle
closeMethod :: MethodHandle -> IO ExitCode
recvStatus :: MethodHandle -> IO Status
sendCommand :: MethodHandle -> Command -> IO ()
getLastModified :: FilePath -> IO (Maybe UTCTime)
simpleFetch :: [ConfigItem] -> URI -> FilePath -> Maybe UTCTime -> IO Bool

-- | fetch a single item, show console output see also: getLastModified
fetch :: FetchCallbacks -> [ConfigItem] -> URI -> FilePath -> Maybe UTCTime -> IO Bool
data FetchCallbacks
FetchCallbacks :: (Message -> IO ()) -> (URI -> Message -> IO ()) -> (URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> IO ()) -> (URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> Maybe FilePath -> Hashes -> Bool -> IO ()) -> (URI -> Message -> IO ()) -> (Message -> IO ()) -> (Site -> IO (Maybe (User, Password))) -> (Media -> Drive -> IO ()) -> (String -> IO ()) -> FetchCallbacks
logCB :: FetchCallbacks -> Message -> IO ()
statusCB :: FetchCallbacks -> URI -> Message -> IO ()
uriStartCB :: FetchCallbacks -> URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> IO ()
uriDoneCB :: FetchCallbacks -> URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> Maybe FilePath -> Hashes -> Bool -> IO ()
uriFailureCB :: FetchCallbacks -> URI -> Message -> IO ()
generalFailureCB :: FetchCallbacks -> Message -> IO ()
authorizationRequiredCB :: FetchCallbacks -> Site -> IO (Maybe (User, Password))
mediaFailureCB :: FetchCallbacks -> Media -> Drive -> IO ()
debugCB :: FetchCallbacks -> String -> IO ()

-- | set of callbacks which do nothing. suitable for non-interactive usage.
--   In the case authorization is required, no credentials will be supplied
--   and the download should abort.
emptyFetchCallbacks :: FetchCallbacks
cliFetchCallbacks :: FetchCallbacks
data Command
URIAcquire :: URI -> FilePath -> (Maybe UTCTime) -> Command
Configuration :: [ConfigItem] -> Command
AuthorizationCredentials :: Site -> User -> Password -> Command
MediaChanged :: Media -> (Maybe Bool) -> Command
data Status
Capabilities :: String -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Status
version :: Status -> String
singleInstance :: Status -> Bool
preScan :: Status -> Bool
pipeline :: Status -> Bool
sendConfig :: Status -> Bool
needsCleanup :: Status -> Bool
localOnly :: Status -> Bool
LogMsg :: Message -> Status
Status :: URI -> Message -> Status
URIStart :: URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> Status
uri :: Status -> URI
size :: Status -> Maybe Integer
lastModified :: Status -> Maybe UTCTime
resumePoint :: Status -> Maybe Integer
URIDone :: URI -> Maybe Integer -> Maybe UTCTime -> Maybe Integer -> Maybe FilePath -> Hashes -> Bool -> Status
uri :: Status -> URI
size :: Status -> Maybe Integer
lastModified :: Status -> Maybe UTCTime
resumePoint :: Status -> Maybe Integer
filename :: Status -> Maybe FilePath
hashes :: Status -> Hashes
imsHit :: Status -> Bool
URIFailure :: URI -> Message -> Status
uri :: Status -> URI
message :: Status -> Message
GeneralFailure :: Message -> Status
AuthorizationRequired :: Site -> Status
MediaFailure :: Media -> Drive -> Status
type Message = String
type Site = String
type User = String
type Password = String
type Media = String
type Drive = String
type Header = (String, String)
type ConfigItem = (String, String)
instance Show Hashes
instance Eq Hashes
instance Show Status
instance Eq Status
instance Show Command
instance Eq Command


-- | A module for parsing, comparing, and (eventually) modifying debian
--   version numbers.
--   <a>http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version</a>
module Debian.Version
data DebianVersion
prettyDebianVersion :: DebianVersion -> Doc
parseDebianVersion :: ParseDebianVersion a => a -> DebianVersion
epoch :: DebianVersion -> Maybe Int
version :: DebianVersion -> String
revision :: DebianVersion -> Maybe String
buildDebianVersion :: Maybe Int -> String -> Maybe String -> DebianVersion

-- | Split a DebianVersion into its three components: epoch, version,
--   revision. It is not safe to use the parsed version number for this
--   because you will lose information, such as leading zeros.
evr :: DebianVersion -> (Maybe Int, String, Maybe String)


-- | Changelog and changes file support.
module Debian.Changes

-- | A file generated by dpkg-buildpackage describing the result of a
--   package build
data ChangesFile
Changes :: FilePath -> String -> DebianVersion -> ReleaseName -> Arch -> Paragraph' Text -> ChangeLogEntry -> [ChangedFileSpec] -> ChangesFile

-- | The full pathname of the directory holding the .changes file.
changeDir :: ChangesFile -> FilePath

-- | The package name parsed from the .changes file name
changePackage :: ChangesFile -> String

-- | The version number parsed from the .changes file name
changeVersion :: ChangesFile -> DebianVersion

-- | The Distribution field of the .changes file
changeRelease :: ChangesFile -> ReleaseName

-- | The architecture parsed from the .changes file name
changeArch :: ChangesFile -> Arch

-- | The contents of the .changes file
changeInfo :: ChangesFile -> Paragraph' Text

-- | The value of the Changes field of the .changes file
changeEntry :: ChangesFile -> ChangeLogEntry

-- | The parsed value of the Files attribute
changeFiles :: ChangesFile -> [ChangedFileSpec]

-- | An entry in the list of files generated by the build.
data ChangedFileSpec
ChangedFileSpec :: String -> String -> String -> FileOffset -> SubSection -> String -> FilePath -> ChangedFileSpec
changedFileMD5sum :: ChangedFileSpec -> String
changedFileSHA1sum :: ChangedFileSpec -> String
changedFileSHA256sum :: ChangedFileSpec -> String
changedFileSize :: ChangedFileSpec -> FileOffset
changedFileSection :: ChangedFileSpec -> SubSection
changedFilePriority :: ChangedFileSpec -> String
changedFileName :: ChangedFileSpec -> FilePath
changesFileName :: ChangesFile -> String
newtype ChangeLog
ChangeLog :: [ChangeLogEntry] -> ChangeLog

-- | A changelog is a series of ChangeLogEntries
data ChangeLogEntry
Entry :: String -> DebianVersion -> [ReleaseName] -> String -> String -> String -> String -> ChangeLogEntry
logPackage :: ChangeLogEntry -> String
logVersion :: ChangeLogEntry -> DebianVersion
logDists :: ChangeLogEntry -> [ReleaseName]
logUrgency :: ChangeLogEntry -> String
logComments :: ChangeLogEntry -> String
logWho :: ChangeLogEntry -> String
logDate :: ChangeLogEntry -> String

-- | The parser here never returns this
WhiteSpace :: String -> ChangeLogEntry

-- | Parse the entries of a debian changelog and verify they are all valid.
parseChangeLog :: String -> ChangeLog

-- | Parse a Debian Changelog and return a lazy list of entries
parseEntries :: String -> [Either [String] ChangeLogEntry]

-- | Parse a single changelog entry, returning the entry and the remaining
--   text.
parseEntry :: String -> Either [String] (ChangeLogEntry, String)

-- | Parse the changelog information that shows up in the .changes file,
--   i.e. a changelog entry with no signature.
parseChanges :: Text -> Maybe ChangeLogEntry
instance Eq ChangedFileSpec
instance Read ChangedFileSpec
instance Show ChangedFileSpec
instance Eq ChangeLogEntry
instance Read ChangeLogEntry
instance Show ChangeLogEntry
instance Eq ChangesFile
instance Read ChangesFile
instance Show ChangesFile
instance Eq ChangeLog
instance Read ChangeLog
instance Show ChangeLog
instance Pretty (PP ChangeLog)
instance Pretty (PP [ChangeLogEntry])
instance Pretty (PP ChangeLogEntry)
instance Pretty (PP ChangedFileSpec)
instance Pretty (PP ChangesFile)

module Debian.Relation.Common
type Relations = AndRelation
type AndRelation = [OrRelation]
type OrRelation = [Relation]
data Relation
Rel :: BinPkgName -> (Maybe VersionReq) -> (Maybe ArchitectureReq) -> Relation
newtype SrcPkgName
SrcPkgName :: String -> SrcPkgName
unSrcPkgName :: SrcPkgName -> String
newtype BinPkgName
BinPkgName :: String -> BinPkgName
unBinPkgName :: BinPkgName -> String
class Pretty (PP a) => PkgName a
pkgNameFromString :: PkgName a => String -> a
class ParseRelations a
parseRelations :: ParseRelations a => a -> Either ParseError Relations

-- | This needs to be indented for use in a control file: intercalate "n "
--   . lines . show
prettyRelations :: [[Relation]] -> Doc
prettyOrRelation :: [Relation] -> Doc
prettyRelation :: Relation -> Doc
data ArchitectureReq
ArchOnly :: (Set Arch) -> ArchitectureReq
ArchExcept :: (Set Arch) -> ArchitectureReq
prettyArchitectureReq :: ArchitectureReq -> Doc
data VersionReq
SLT :: DebianVersion -> VersionReq
LTE :: DebianVersion -> VersionReq
EEQ :: DebianVersion -> VersionReq
GRE :: DebianVersion -> VersionReq
SGR :: DebianVersion -> VersionReq
prettyVersionReq :: VersionReq -> Doc

-- | The sort order is based on version number first, then on the kind of
--   relation, sorting in the order

-- | Check if a version number satisfies a version requirement.
checkVersionReq :: Maybe VersionReq -> Maybe DebianVersion -> Bool

-- | Wrap <a>PP</a> around type synonyms that might overlap with the
--   `Pretty [a]` instance.
instance Typeable SrcPkgName
instance Typeable BinPkgName
instance Read SrcPkgName
instance Show SrcPkgName
instance Eq SrcPkgName
instance Ord SrcPkgName
instance Data SrcPkgName
instance Read BinPkgName
instance Show BinPkgName
instance Eq BinPkgName
instance Ord BinPkgName
instance Data BinPkgName
instance Eq ArchitectureReq
instance Ord ArchitectureReq
instance Read ArchitectureReq
instance Show ArchitectureReq
instance Eq VersionReq
instance Read VersionReq
instance Show VersionReq
instance Eq Relation
instance Read Relation
instance Show Relation
instance Pretty (PP ArchitectureReq)
instance Pretty (PP VersionReq)
instance Pretty (PP Relation)
instance Pretty (PP OrRelation)
instance Pretty (PP Relations)
instance Pretty (PP SrcPkgName)
instance Pretty (PP BinPkgName)
instance Ord VersionReq
instance Ord Relation
instance PkgName SrcPkgName
instance PkgName BinPkgName


-- | A module for working with debian relationships
--   <a>http://www.debian.org/doc/debian-policy/ch-relationships.html</a>
module Debian.Relation.String
type AndRelation = [OrRelation]
type OrRelation = [Relation]
type Relations = AndRelation
data Relation
Rel :: BinPkgName -> (Maybe VersionReq) -> (Maybe ArchitectureReq) -> Relation
data ArchitectureReq
ArchOnly :: (Set Arch) -> ArchitectureReq
ArchExcept :: (Set Arch) -> ArchitectureReq
data VersionReq
SLT :: DebianVersion -> VersionReq
LTE :: DebianVersion -> VersionReq
EEQ :: DebianVersion -> VersionReq
GRE :: DebianVersion -> VersionReq
SGR :: DebianVersion -> VersionReq

-- | Check if a version number satisfies a version requirement.
checkVersionReq :: Maybe VersionReq -> Maybe DebianVersion -> Bool
type RelParser a = CharParser () a
class ParseRelations a
parseRelations :: ParseRelations a => a -> Either ParseError Relations
pRelations :: RelParser Relations
instance ParseRelations String


-- | A module for working with debian relationships
--   <a>http://www.debian.org/doc/debian-policy/ch-relationships.html</a>
module Debian.Relation.Text
type AndRelation = [OrRelation]
type OrRelation = [Relation]
type Relations = AndRelation
data Relation
Rel :: BinPkgName -> (Maybe VersionReq) -> (Maybe ArchitectureReq) -> Relation
data ArchitectureReq
ArchOnly :: (Set Arch) -> ArchitectureReq
ArchExcept :: (Set Arch) -> ArchitectureReq
data VersionReq
SLT :: DebianVersion -> VersionReq
LTE :: DebianVersion -> VersionReq
EEQ :: DebianVersion -> VersionReq
GRE :: DebianVersion -> VersionReq
SGR :: DebianVersion -> VersionReq

-- | Check if a version number satisfies a version requirement.
checkVersionReq :: Maybe VersionReq -> Maybe DebianVersion -> Bool
type RelParser a = CharParser () a
class ParseRelations a
parseRelations :: ParseRelations a => a -> Either ParseError Relations
instance ParseRelations Text


-- | A module for working with debian relationships
--   <a>http://www.debian.org/doc/debian-policy/ch-relationships.html</a>
module Debian.Relation.ByteString
type AndRelation = [OrRelation]
type OrRelation = [Relation]
type Relations = AndRelation
data Relation
Rel :: BinPkgName -> (Maybe VersionReq) -> (Maybe ArchitectureReq) -> Relation
data ArchitectureReq
ArchOnly :: (Set Arch) -> ArchitectureReq
ArchExcept :: (Set Arch) -> ArchitectureReq
data VersionReq
SLT :: DebianVersion -> VersionReq
LTE :: DebianVersion -> VersionReq
EEQ :: DebianVersion -> VersionReq
GRE :: DebianVersion -> VersionReq
SGR :: DebianVersion -> VersionReq

-- | Check if a version number satisfies a version requirement.
checkVersionReq :: Maybe VersionReq -> Maybe DebianVersion -> Bool
type RelParser a = CharParser () a
class ParseRelations a
parseRelations :: ParseRelations a => a -> Either ParseError Relations
instance ParseRelations ByteString


-- | A module for working with debian relationships
--   <a>http://www.debian.org/doc/debian-policy/ch-relationships.html</a>
module Debian.Relation
class Pretty (PP a) => PkgName a
pkgNameFromString :: PkgName a => String -> a
newtype SrcPkgName
SrcPkgName :: String -> SrcPkgName
unSrcPkgName :: SrcPkgName -> String
newtype BinPkgName
BinPkgName :: String -> BinPkgName
unBinPkgName :: BinPkgName -> String
type Relations = AndRelation
type AndRelation = [OrRelation]
type OrRelation = [Relation]
data Relation
Rel :: BinPkgName -> (Maybe VersionReq) -> (Maybe ArchitectureReq) -> Relation
data ArchitectureReq
ArchOnly :: (Set Arch) -> ArchitectureReq
ArchExcept :: (Set Arch) -> ArchitectureReq
data Arch
Source :: Arch
All :: Arch
Binary :: ArchOS -> ArchCPU -> Arch
data ArchOS
ArchOS :: String -> ArchOS
ArchOSAny :: ArchOS
data ArchCPU
ArchCPU :: String -> ArchCPU
ArchCPUAny :: ArchCPU
data VersionReq
SLT :: DebianVersion -> VersionReq
LTE :: DebianVersion -> VersionReq
EEQ :: DebianVersion -> VersionReq
GRE :: DebianVersion -> VersionReq
SGR :: DebianVersion -> VersionReq

-- | Check if a version number satisfies a version requirement.
checkVersionReq :: Maybe VersionReq -> Maybe DebianVersion -> Bool
type RelParser a = CharParser () a
class ParseRelations a
parseRelations :: ParseRelations a => a -> Either ParseError Relations

module Debian.Control.ByteString
newtype Control' a
Control :: [Paragraph' a] -> Control' a
unControl :: Control' a -> [Paragraph' a]
newtype Paragraph' a
Paragraph :: [Field' a] -> Paragraph' a

-- | NOTE: we do not strip the leading or trailing whitespace in the name
--   or value
data Field' a
Field :: (a, a) -> Field' a

-- | Lines beginning with #
Comment :: a -> Field' a
type Control = Control' ByteString
type Paragraph = Paragraph' ByteString
type Field = Field' ByteString
class ControlFunctions a
parseControlFromFile :: ControlFunctions a => FilePath -> IO (Either ParseError (Control' a))
parseControlFromHandle :: ControlFunctions a => String -> Handle -> IO (Either ParseError (Control' a))
parseControl :: ControlFunctions a => String -> a -> (Either ParseError (Control' a))
lookupP :: ControlFunctions a => String -> (Paragraph' a) -> Maybe (Field' a)
stripWS :: ControlFunctions a => a -> a
protectFieldText :: ControlFunctions a => a -> a
asString :: ControlFunctions a => a -> String
mergeControls :: [Control' a] -> Control' a
fieldValue :: ControlFunctions a => String -> Paragraph' a -> Maybe a
removeField :: Eq a => a -> Paragraph' a -> Paragraph' a
prependFields :: [Field' a] -> Paragraph' a -> Paragraph' a
appendFields :: [Field' a] -> Paragraph' a -> Paragraph' a
renameField :: Eq a => a -> a -> Paragraph' a -> Paragraph' a
modifyField :: Eq a => a -> (a -> a) -> Paragraph' a -> Paragraph' a

-- | Move selected fields to the beginning of a paragraph.
raiseFields :: Eq a => (a -> Bool) -> Paragraph' a -> Paragraph' a
instance Show a => Show (Result a)
instance MonadPlus (Parser state)
instance Monad (Parser state)
instance Alternative (Parser state)
instance Applicative (Parser state)
instance Functor (Parser state)
instance ControlFunctions ByteString

module Debian.Control.Text
newtype Control' a
Control :: [Paragraph' a] -> Control' a
unControl :: Control' a -> [Paragraph' a]
newtype Paragraph' a
Paragraph :: [Field' a] -> Paragraph' a

-- | NOTE: we do not strip the leading or trailing whitespace in the name
--   or value
data Field' a
Field :: (a, a) -> Field' a

-- | Lines beginning with #
Comment :: a -> Field' a
type Control = Control' Text
type Paragraph = Paragraph' Text

-- | <tt>parseFromFile p filePath</tt> runs a string parser <tt>p</tt> on
--   the input read from <tt>filePath</tt> using <a>readFile</a>. Returns
--   either a <tt>ParseError</tt> (<a>Left</a>) or a value of type
--   <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
type Field = Field' Text
class ControlFunctions a
parseControlFromFile :: ControlFunctions a => FilePath -> IO (Either ParseError (Control' a))
parseControlFromHandle :: ControlFunctions a => String -> Handle -> IO (Either ParseError (Control' a))
parseControl :: ControlFunctions a => String -> a -> (Either ParseError (Control' a))
lookupP :: ControlFunctions a => String -> (Paragraph' a) -> Maybe (Field' a)
stripWS :: ControlFunctions a => a -> a
protectFieldText :: ControlFunctions a => a -> a
asString :: ControlFunctions a => a -> String
mergeControls :: [Control' a] -> Control' a
fieldValue :: ControlFunctions a => String -> Paragraph' a -> Maybe a
removeField :: Eq a => a -> Paragraph' a -> Paragraph' a
prependFields :: [Field' a] -> Paragraph' a -> Paragraph' a
appendFields :: [Field' a] -> Paragraph' a -> Paragraph' a
renameField :: Eq a => a -> a -> Paragraph' a -> Paragraph' a
modifyField :: Eq a => a -> (a -> a) -> Paragraph' a -> Paragraph' a

-- | Move selected fields to the beginning of a paragraph.
raiseFields :: Eq a => (a -> Bool) -> Paragraph' a -> Paragraph' a
decodeControl :: Control -> Control
decodeParagraph :: Paragraph -> Paragraph
decodeField :: Field' ByteString -> Field' Text
instance ControlFunctions Text


-- | Access to things that Debian policy says should be in a valid control
--   file. The pure functions will not throw ControlFileError if they are
--   operating on a DebianControl value returned by validateDebianControl.
--   However, they might if they are created using unsafeDebianControl.
module Debian.Control.Policy

-- | Opaque (constructor not exported) type to hold a validated Debian
--   Control File
data DebianControl

-- | Validate and return a control file in an opaque wrapper. May throw a
--   ControlFileError. Currently we only verify that it has a Source field
--   in the first paragraph and one or more subsequent paragraphs each with
--   a Package field, and no syntax errors in the build dependencies
--   (though they may be absent.)
validateDebianControl :: MonadCatch m => Control' Text -> m (Either ControlFileError DebianControl)
unsafeDebianControl :: Control' Text -> DebianControl
parseDebianControlFromFile :: FilePath -> IO (Either ControlFileError DebianControl)
parseDebianControl :: MonadCatch m => String -> Text -> m (Either ControlFileError DebianControl)

-- | Errors that control files might throw, with source file name and line
--   number generated by template haskell.
data ControlFileError
NoParagraphs :: [Loc] -> ControlFileError
locs :: ControlFileError -> [Loc]
NoBinaryParagraphs :: [Loc] -> ControlFileError
locs :: ControlFileError -> [Loc]
MissingField :: [Loc] -> String -> ControlFileError
locs :: ControlFileError -> [Loc]
field :: ControlFileError -> String
ParseRelationsError :: [Loc] -> ParseError -> ControlFileError
locs :: ControlFileError -> [Loc]
parseError :: ControlFileError -> ParseError
ParseControlError :: [Loc] -> ParseError -> ControlFileError
locs :: ControlFileError -> [Loc]
parseError :: ControlFileError -> ParseError
IOError :: [Loc] -> IOError -> ControlFileError
locs :: ControlFileError -> [Loc]
ioError :: ControlFileError -> IOError

-- | Class of things that contain a validated Debian control file.
class HasDebianControl a
debianControl :: HasDebianControl a => a -> DebianControl
debianSourceParagraph :: HasDebianControl a => a -> Paragraph' Text
debianBinaryParagraphs :: HasDebianControl a => a -> [Paragraph' Text]
debianPackageParagraphs :: HasDebianControl a => a -> (Paragraph' Text, [Paragraph' Text])
debianPackageNames :: HasDebianControl a => a -> (SrcPkgName, [BinPkgName])
debianSourcePackageName :: HasDebianControl a => a -> SrcPkgName
debianBinaryPackageNames :: HasDebianControl a => a -> [BinPkgName]

-- | This could access fields we haven't validated, so it can return an
--   error. Additionally, the field might be absent, in which case it
--   returns Nothing.
debianRelations :: HasDebianControl a => String -> a -> Either ControlFileError (Maybe Relations)
debianBuildDeps :: HasDebianControl a => a -> Maybe Relations
debianBuildDepsIndep :: HasDebianControl a => a -> Maybe Relations
instance Typeable ControlFileError
instance Eq ControlFileError
instance Exception ControlFileError
instance Show ControlFileError
instance HasControl DebianControl
instance HasControl (Control' Text)
instance HasDebianControl DebianControl
instance Show DebianControl


-- | A module for working with Debian control files
--   <a>http://www.debian.org/doc/debian-policy/ch-controlfields.html</a>
module Debian.Control
newtype Control' a
Control :: [Paragraph' a] -> Control' a
unControl :: Control' a -> [Paragraph' a]
newtype Paragraph' a
Paragraph :: [Field' a] -> Paragraph' a

-- | NOTE: we do not strip the leading or trailing whitespace in the name
--   or value
data Field' a
Field :: (a, a) -> Field' a

-- | Lines beginning with #
Comment :: a -> Field' a
type Control = Control' String
type Paragraph = Paragraph' String
type Field = Field' String
type ControlParser a = CharParser () a
class ControlFunctions a
parseControlFromFile :: ControlFunctions a => FilePath -> IO (Either ParseError (Control' a))
parseControlFromHandle :: ControlFunctions a => String -> Handle -> IO (Either ParseError (Control' a))
parseControl :: ControlFunctions a => String -> a -> (Either ParseError (Control' a))
lookupP :: ControlFunctions a => String -> (Paragraph' a) -> Maybe (Field' a)
stripWS :: ControlFunctions a => a -> a
protectFieldText :: ControlFunctions a => a -> a
asString :: ControlFunctions a => a -> String

-- | A parser for debian control file. This parser handles control files
--   that end without a newline as well as ones that have several blank
--   lines at the end. It is very liberal and does not attempt validate the
--   fields in any way. All trailing, leading, and folded whitespace is
--   preserved in the field values. See <a>stripWS</a>.
pControl :: ControlParser Control
mergeControls :: [Control' a] -> Control' a
fieldValue :: ControlFunctions a => String -> Paragraph' a -> Maybe a
removeField :: Eq a => a -> Paragraph' a -> Paragraph' a
prependFields :: [Field' a] -> Paragraph' a -> Paragraph' a
appendFields :: [Field' a] -> Paragraph' a -> Paragraph' a
renameField :: Eq a => a -> a -> Paragraph' a -> Paragraph' a
modifyField :: Eq a => a -> (a -> a) -> Paragraph' a -> Paragraph' a

-- | Move selected fields to the beginning of a paragraph.
raiseFields :: Eq a => (a -> Bool) -> Paragraph' a -> Paragraph' a
packParagraph :: Paragraph -> Paragraph
packField :: Field' String -> Field' Text
formatControl :: Control' Text -> [Text]
formatParagraph :: Paragraph' Text -> Text
formatField :: Field' Text -> Text

-- | Class of things that contain a validated Debian control file.
class HasDebianControl a
debianControl :: HasDebianControl a => a -> DebianControl

-- | Errors that control files might throw, with source file name and line
--   number generated by template haskell.
data ControlFileError
NoParagraphs :: [Loc] -> ControlFileError
locs :: ControlFileError -> [Loc]
NoBinaryParagraphs :: [Loc] -> ControlFileError
locs :: ControlFileError -> [Loc]
MissingField :: [Loc] -> String -> ControlFileError
locs :: ControlFileError -> [Loc]
field :: ControlFileError -> String
ParseRelationsError :: [Loc] -> ParseError -> ControlFileError
locs :: ControlFileError -> [Loc]
parseError :: ControlFileError -> ParseError
ParseControlError :: [Loc] -> ParseError -> ControlFileError
locs :: ControlFileError -> [Loc]
parseError :: ControlFileError -> ParseError
IOError :: [Loc] -> IOError -> ControlFileError
locs :: ControlFileError -> [Loc]
ioError :: ControlFileError -> IOError
parseDebianControlFromFile :: FilePath -> IO (Either ControlFileError DebianControl)

-- | Validate and return a control file in an opaque wrapper. May throw a
--   ControlFileError. Currently we only verify that it has a Source field
--   in the first paragraph and one or more subsequent paragraphs each with
--   a Package field, and no syntax errors in the build dependencies
--   (though they may be absent.)
validateDebianControl :: MonadCatch m => Control' Text -> m (Either ControlFileError DebianControl)
unsafeDebianControl :: Control' Text -> DebianControl
debianSourceParagraph :: HasDebianControl a => a -> Paragraph' Text
debianBinaryParagraphs :: HasDebianControl a => a -> [Paragraph' Text]
debianPackageParagraphs :: HasDebianControl a => a -> (Paragraph' Text, [Paragraph' Text])
debianPackageNames :: HasDebianControl a => a -> (SrcPkgName, [BinPkgName])
debianSourcePackageName :: HasDebianControl a => a -> SrcPkgName
debianBinaryPackageNames :: HasDebianControl a => a -> [BinPkgName]

-- | This could access fields we haven't validated, so it can return an
--   error. Additionally, the field might be absent, in which case it
--   returns Nothing.
debianRelations :: HasDebianControl a => String -> a -> Either ControlFileError (Maybe Relations)
debianBuildDeps :: HasDebianControl a => a -> Maybe Relations
debianBuildDepsIndep :: HasDebianControl a => a -> Maybe Relations

module Debian.Apt.Index

-- | update - similar to apt-get update
update :: Fetcher -> FilePath -> String -> [DebSource] -> IO [Maybe (FilePath, Compression)]

-- | function-type for a function that downloads a file The timestamp is
--   optional. If the local file is as new or newer than the remote copy,
--   the download may be skipped.
--   
--   A good choice might be a partially parameterized call to <a>fetch</a>
type Fetcher = URI -> FilePath -> Maybe UTCTime -> IO Bool
data CheckSums
CheckSums :: Maybe String -> Maybe String -> Maybe String -> CheckSums
md5sum :: CheckSums -> Maybe String
sha1 :: CheckSums -> Maybe String
sha256 :: CheckSums -> Maybe String

-- | Package indexes on the server are uncompressed or compressed with gzip
--   or bzip2. We do not know what will exist on the server until we
--   actually look. This type is used to mark the compression status of
--   what was actually found.
data Compression
BZ2 :: Compression
GZ :: Compression
Uncompressed :: Compression
type FileTuple = (CheckSums, Size, FilePath)
type Size = Integer

-- | Parse a possibly compressed index file.
controlFromIndex :: Compression -> FilePath -> ByteString -> Either ParseError (Control' Text)

-- | parse an index possibly compressed file
controlFromIndex' :: Compression -> FilePath -> IO (Either ParseError (Control' Text))

-- | find the Contents-* files. These are not listed in the Release file
findContentsFiles :: (FilePath -> Bool) -> FilePath -> IO [FilePath]
findIndexes :: FilePath -> String -> [FileTuple] -> IO [(FileTuple, Compression)]
indexesInRelease :: (FilePath -> Bool) -> Control' Text -> [(CheckSums, Integer, FilePath)]

-- | make a FileTuple for a file found on the local disk returns
--   <a>Nothing</a> if the file does not exist.
tupleFromFilePath :: FilePath -> FilePath -> IO (Maybe FileTuple)
instance Read Compression
instance Show Compression
instance Eq Compression
instance Ord Compression
instance Enum Compression
instance Bounded Compression
instance Read CheckSums
instance Show CheckSums
instance Eq CheckSums

module Debian.Report

-- | create a map of (package name, extracted field) from a list of index
--   files
--   
--   NOTE: we could merge all the files into a single control and then run
--   packageMap over that. We currently do it one control file at a time to
--   avoid having all the control files loaded in memory at once. However,
--   I am not sure that property is actually occuring anyway. So, this
--   should be revisited.
makePackageMap :: (Paragraph -> a) -> (a -> a -> a) -> [(FilePath, Compression)] -> IO (Map Text a)

-- | create a map of (package name, max version) from a single control file
packageMap :: (Paragraph -> a) -> (a -> a -> a) -> Control' Text -> Map Text a

-- | extract the version number from a control paragraph
extractVersion :: Paragraph -> Maybe DebianVersion

-- | compare two sources.list and find all the packages in the second that
--   trump packages in the first see also: |trumpedMap|
trumped :: Fetcher -> FilePath -> String -> [DebSource] -> [DebSource] -> IO (Map Text (DebianVersion, DebianVersion))

-- | calculate all the trumped packages
trumpedMap :: Map Text DebianVersion -> Map Text DebianVersion -> Map Text (DebianVersion, DebianVersion)

-- | create <a>/</a> XML element and children from a trumped Map
trumpedXML :: Map Text (DebianVersion, DebianVersion) -> CFilter Posn


-- | Figure out the dependency relation between debianized source
--   directories. The code to actually solve these dependency relations for
--   a particular set of binary packages is in Debian.Repo.Dependency.
module Debian.GenBuildDeps

-- | This type describes the build dependencies of a source package.
data DepInfo
DepInfo :: SrcPkgName -> Relations -> [BinPkgName] -> DepInfo

-- | source package name
sourceName :: DepInfo -> SrcPkgName

-- | dependency relations
relations :: DepInfo -> Relations

-- | binary dependency names (is this a function of relations?)
binaryNames :: DepInfo -> [BinPkgName]

-- | source package name
sourceName' :: HasDebianControl control => control -> SrcPkgName

-- | dependency relations
relations' :: HasDebianControl control => control -> Relations

-- | binary dependency names (is this a function of relations?)
binaryNames' :: HasDebianControl control => control -> [BinPkgName]

-- | Return the dependency info for a source package with the given
--   dependency relaxation. |According to debian policy, only the first
--   paragraph in debian/control can be a source package
--   <a>http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-sourcecontrolfiles</a>
buildDependencies :: HasDebianControl control => control -> DepInfo

-- | Given a source package name and a binary package name, return False if
--   the binary package should be ignored hwen deciding whether to build
--   the source package. This is used to prevent build dependency cycles
--   from triggering unnecessary rebuilds. (This is a replacement for the
--   RelaxInfo type, which we temporarily rename OldRelaxInfo.)
type RelaxInfo = SrcPkgName -> BinPkgName -> Bool

-- | Remove any dependencies that are designated "relaxed" by relaxInfo.
relaxDeps :: RelaxInfo -> [DepInfo] -> [DepInfo]
data BuildableInfo a
BuildableInfo :: [ReadyTarget a] -> [a] -> BuildableInfo a
readyTargets :: BuildableInfo a -> [ReadyTarget a]
allBlocked :: BuildableInfo a -> [a]
CycleInfo :: [(a, a)] -> BuildableInfo a
depPairs :: BuildableInfo a -> [(a, a)]
data ReadyTarget a
ReadyTarget :: a -> [a] -> [a] -> ReadyTarget a

-- | Some target whose build dependencies are all satisfied
ready :: ReadyTarget a -> a

-- | The targets that are waiting for the ready target
waiting :: ReadyTarget a -> [a]

-- | The rest of the targets that need to be built
other :: ReadyTarget a -> [a]

-- | Given an ordering function representing the dependencies on a list of
--   packages, return a ReadyTarget triple: One ready package, the packages
--   that depend on the ready package directly or indirectly, and all the
--   other packages.
buildable :: (a -> DepInfo) -> [a] -> BuildableInfo a

-- | This is a nice start. It ignores circular build depends and takes a
--   pretty simplistic approach to <a>or</a> build depends. However, I
--   think this should work pretty nicely in practice.
compareSource :: DepInfo -> DepInfo -> Ordering

-- | Given a list of packages, sort them according to their apparant build
--   dependencies so that the first element doesn't depend on any of the
--   other packages.
orderSource :: (a -> a -> Ordering) -> [a] -> [a]

-- | Return the dependency info for a list of control files.
genDeps :: [FilePath] -> IO [DebianControl]

-- | Remove any packages which can't be built given that a package has
--   failed.
failPackage :: Eq a => (a -> a -> Ordering) -> a -> [a] -> ([a], [a])

-- | One example of how to tie the below functions together. In this case
--   <tt>fp</tt> is the path to a directory that contains a bunch of
--   checked out source packages. The code will automatically look for
--   debian/control. It returns a list with the packages in the order they
--   should be built.
getSourceOrder :: FilePath -> IO [SrcPkgName]
instance Show DepInfo
instance Show OldRelaxInfo
instance Eq DepInfo

module Debian.Util.FakeChanges
fakeChanges :: [FilePath] -> IO (FilePath, String)
instance Typeable Error
instance Read Error
instance Show Error
instance Eq Error
instance Data Error


-- | Functions for dealing with source and binary packages in an
--   abstract-way
module Debian.Apt.Package
type PackageNameMap a = Map BinPkgName [a]

-- | <a>packageNameMap</a> creates a map from a package name to all the
--   versions of that package NOTE: Provides are not included in the map
--   NOTE: the sort order is random -- this is perhaps a bug see also:
--   <a>addProvides</a>
packageNameMap :: (a -> BinPkgName) -> [a] -> PackageNameMap a

-- | <a>addProvides</a> finds packages that Provide other packages and adds
--   them to the PackageNameMap. They will be adde to the end of the list,
--   so that real packages have 'higher priority' than virtual packages.
--   NOTE: Does not check for duplication or multiple use
addProvides :: (p -> [BinPkgName]) -> [p] -> PackageNameMap p -> PackageNameMap p

-- | <a>findProvides</a>
findProvides :: (p -> [BinPkgName]) -> [p] -> [(BinPkgName, p)]

-- | <a>lookupPackageByRel</a> returns all the packages that satisfy the
--   specified relation TODO: Add architecture check
lookupPackageByRel :: PackageNameMap a -> (a -> (BinPkgName, DebianVersion)) -> Relation -> [a]

module Debian.Apt.Dependencies
data Status
Remaining :: AndRelation -> Status
MissingDep :: Relation -> Status
Complete :: Status
type State a = (Status, [a])
complete :: State a -> Bool
data CSP a
CSP :: PackageNameMap a -> Relations -> (a -> Relations) -> (a -> Relations) -> (a -> (BinPkgName, DebianVersion)) -> CSP a
pnm :: CSP a -> PackageNameMap a
relations :: CSP a -> Relations
depFunction :: CSP a -> (a -> Relations)
conflicts :: CSP a -> a -> Relations
packageVersion :: CSP a -> a -> (BinPkgName, DebianVersion)

-- | TODO addProvides -- see DQL.Exec
controlCSP :: Control -> Relations -> (Paragraph -> Relations) -> CSP Paragraph
testCSP :: FilePath -> (Paragraph -> Relations) -> String -> (CSP Paragraph -> IO a) -> IO a
depF :: Paragraph -> Relations
sidPackages :: [Char]
gutsyPackages :: [Char]
test :: FilePath -> String -> Labeler Paragraph -> IO ()
packageVersionParagraph :: Paragraph -> (BinPkgName, DebianVersion)
conflict :: CSP p -> p -> p -> Bool

-- | JAS: deal with <tt>Provides</tt> (can a package provide more than one
--   package?)
conflict' :: (BinPkgName, DebianVersion) -> Relation -> Bool
mkTree :: a -> [Tree a] -> Tree a
label :: Tree a -> a
initTree :: (a -> [a]) -> a -> Tree a
mapTree :: (a -> b) -> Tree a -> Tree b
foldTree :: (a -> [b] -> b) -> Tree a -> b
zipTreesWith :: (a -> b -> c) -> Tree a -> Tree b -> Tree c
prune :: (a -> Bool) -> Tree a -> Tree a
leaves :: Tree a -> [a]
inhTree :: (b -> a -> b) -> b -> Tree a -> Tree b
distrTree :: (a -> [b]) -> b -> Tree a -> Tree b
mkSearchTree :: CSP a -> Tree (State a)

-- | earliestInconsistency does what it sounds like the 'reverse as' is
--   because the vars are order high to low, but we want to find the lowest
--   numbered (aka, eariest) inconsistency ??
earliestInconsistency :: CSP a -> State a -> Maybe ((BinPkgName, DebianVersion), (BinPkgName, DebianVersion))

-- | conflicting packages and relations that require non-existant packages
type ConflictSet = ([(BinPkgName, DebianVersion)], [Relation])
isConflict :: ConflictSet -> Bool
solutions :: Tree (State a, ConflictSet) -> [State a]
type Labeler a = CSP a -> Tree (State a) -> Tree (State a, ConflictSet)
search :: Labeler a -> CSP a -> [State a]
bt :: Labeler a

-- | bj - backjumping labeler
--   
--   If the node already has a conflict set, then leave it alone.
--   
--   Otherwise, the conflictset for the node is the combination of the
--   conflict sets of its direct children.
bj :: CSP p -> Tree (State p, ConflictSet) -> Tree (State p, ConflictSet)
unionCS :: [ConflictSet] -> ConflictSet
combine :: CSP p -> [(State p, ConflictSet)] -> [ConflictSet] -> ConflictSet
instance Eq Status
