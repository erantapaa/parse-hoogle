-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Another pure-haskell CDB (Constant Database) implementation
--   
--   A library for reading and writing CDB (Constant Database) files.
--   
--   CDB files are immutable key-value stores, designed for extremely fast
--   and memory-efficient construction and lookup. They can be as large as
--   4GB, and at no point in their construction or use must all data be
--   loaded into memory. CDB files can contain multiple values for a given
--   key.
--   
--   For more information on the CDB file format, please see:
--   <a>http://cr.yp.to/cdb.html</a>
--   
--   Please note, that there is another pure Haskell CDB library on
--   Hackage: <a>http://hackage.haskell.org/package/hs-cdb</a>, using
--   memory mapped bytestrings for IO. It served as an inspiration for this
--   package.
@package pure-cdb
@version 0.1.1

module Database.PureCDB.Internal
data TOCHash
TOCHash :: Word32 -> Word32 -> TOCHash
hPosition :: TOCHash -> Word32
hLength :: TOCHash -> Word32

-- | Read handle for the database.
data ReadCDB
ReadCDB :: Handle -> Vector TOCHash -> ReadCDB
rHandle :: ReadCDB -> Handle
rTOC :: ReadCDB -> Vector TOCHash
cdbHash :: ByteString -> Word32
tocIndex :: Integral a => a -> Int
tocFind :: ReadCDB -> ByteString -> (TOCHash, Word32)
layoutHash :: Int -> IntMap [a] -> Maybe [(Int, a)]
coalesceHash :: Integral a => a -> [(a, b)] -> IntMap [(a, b)]
createHashVector :: Integral a => a -> (a, b) -> [(a, b)] -> Vector (a, b)
hashSlot :: Integral a => a -> a -> a
instance Show TOCHash


-- | A library for reading and writing CDB (Constant Database) files.
--   
--   CDB files are immutable key-value stores, designed for extremely fast
--   and memory-efficient construction and lookup. They can be as large as
--   4GB, and at no point in their construction or use must all data be
--   loaded into memory. CDB files can contain multiple values for a given
--   key.
--   
--   For more information on the CDB file format, please see:
--   <a>http://cr.yp.to/cdb.html</a>
--   
--   Here's how you make new CDB file:
--   
--   <pre>
--   import qualified Data.ByteString.Char8 as B
--   import Database.PureCDB
--   
--   makeIt :: IO ()
--   makeIt = makeCDB (do
--         addBS (B.pack "foo") (B.pack "bar")
--         addBS (B.pack "foo") (B.pack "baz")) "foo.cdb"
--   </pre>
--   
--   You can later use it as in:
--   
--   <pre>
--   getIt :: IO [ByteString]
--   getIt = do
--         f &lt;- openCDB "foo.cdb"
--         bs &lt;- getBS f (B.pack "foo")
--         closeCDB "foo.cdb"
--         return bs
--   </pre>
--   
--   <tt>getIt</tt> returns [ "bar", "baz" ] in unspecified order.
--   
--   Note that <tt>pure-cdb</tt> works on strict <tt>ByteString'</tt>s only
--   for now.
module Database.PureCDB

-- | Write context monad transformer.
data WriteCDB m a

-- | Runs WriteCDB monad transformer to make the database.
makeCDB :: MonadIO m => WriteCDB m a -> FilePath -> m a

-- | Adds key and value to the CDB database.
addBS :: MonadIO m => ByteString -> ByteString -> WriteCDB m ()

-- | Read handle for the database.
data ReadCDB

-- | Opens CDB database.
openCDB :: FilePath -> IO ReadCDB

-- | Closes the database.
closeCDB :: ReadCDB -> IO ()

-- | Fetches key from the database.
getBS :: ReadCDB -> ByteString -> IO [ByteString]
instance Functor m => Functor (WriteCDB m)
instance Monad m => Monad (WriteCDB m)
instance (Monad m, Functor m) => Applicative (WriteCDB m)
instance MonadTrans WriteCDB
instance MonadIO m => MonadIO (WriteCDB m)
