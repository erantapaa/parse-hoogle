-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of forkIO for monad stacks.
--   
--   This module defines a more generic version of Control.Concurrent's
--   forkIO, which can directly run some complex monadic actions as well as
--   plain IO actions.
@package forkable-monad
@version 0.1.1


-- | This module defines a generic version of <tt>Control.Concurrent</tt>'s
--   <a>forkIO</a>, which can directly run some complex monadic actions as
--   well as plain <a>IO</a> actions.
--   
--   <tt>Control.Concurrent</tt>'s <a>forkIO</a> accepts an <a>IO</a>
--   computation only, and requires the caller to reconstruct the full
--   monadic stack by hand in the new thread. In contrast, this module's
--   <a>forkIO</a> runs a computation in the same monad as the parent
--   thread, transparently transplanting the monad stack to the new thread.
--   
--   For example, the following code which uses
--   <tt>Control.Concurrent</tt>'s <a>forkIO</a>:
--   
--   <pre>
--   type MyMonad = ReaderT Int (StateT String IO)
--   
--   forkAndDo :: MyMonad ThreadId
--   forkAndDo = do
--       r &lt;- ask
--       s &lt;- lift get
--       liftIO $ forkIO $ (runStateT (runReaderT forkedDo r) s &gt;&gt; return ())
--   
--   forkedDo :: MyMonad ()
--   forkedDo = liftIO $ putStrLn "forkedDo running"
--   </pre>
--   
--   can be reexpressed with this module's <a>forkIO</a> as:
--   
--   <pre>
--   type MyMonad = ReaderT Int (StateT String IO)
--   
--   forkAndDo :: MyMonad ThreadId
--   forkAndDo = forkIO forkedDo
--   
--   forkedDo :: MyMonad ()
--   forkedDo = liftIO $ putStrLn "forkedDo running"
--   </pre>
--   
--   <a>forkIO</a> can operate on any monad that is an instance of
--   <a>ForkableMonad</a>. <a>ForkableMonad</a> instances are defined for
--   <a>ReaderT</a> and <a>StateT</a>, as well as <a>IO</a>. Here is the
--   precise meaning of "transplant" for each of these:
--   
--   <ul>
--   <li><a>IO</a> requires no special work, since
--   <tt>Control.Concurrent</tt>'s <a>forkIO</a> already provides the
--   "transplanting" of an <a>IO</a> action to a new thread.</li>
--   <li><a>ReaderT</a> makes the parent thread's environment available for
--   consultation in the new thread.</li>
--   <li><a>StateT</a> makes a <i>copy</i> of the parent thread's state
--   available in the new thread. The states in the two threads are not
--   linked, so it is expected that they will diverge as each thread
--   updates its own copy of the state.</li>
--   </ul>
--   
--   Other standard transformers (notably <tt>WriterT</tt>, <tt>ErrorT</tt>
--   and <tt>RWST</tt>) do not have an instance defined, because those
--   instances can only be defined through data loss.
--   
--   For example, the current output of a <tt>Writer</tt> cannot be
--   accessed from within the monad, so the best that can be done is to
--   create a new pristine <tt>Writer</tt> state for the new thread, and to
--   discard all data written in that thread when the thread terminates.
--   
--   If you want to use <a>forkIO</a> on a monad stack that includes one of
--   these lossy monads, you will need to define the <a>ForkableMonad</a>
--   instances yourself. The same goes for any custom monads you may have
--   in the stack.
--   
--   This module reexports <tt>Control.Concurrent</tt> overlayed with the
--   generic <a>forkIO</a>, so you can simply change your import from
--   <tt>Control.Concurrent</tt> to <tt>Control.Concurrent.Forkable</tt> to
--   use this module's <a>forkIO</a> in your existing concurrent code.
module Control.Concurrent.Forkable
class Monad m => ForkableMonad m
forkIO :: ForkableMonad m => m a -> m ThreadId
instance ForkableMonad m => ForkableMonad (StateT s m)
instance ForkableMonad m => ForkableMonad (ReaderT r m)
instance ForkableMonad IO
