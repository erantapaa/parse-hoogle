-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Remotely controlling Java Swing applications
--   
--   This is a library for remotely controlling Java Swing desktop
--   applications that have been instrumented with a special pianola agent.
--   The agent exposes the Swing component hierarchy over the network, and
--   accepts requests for generating GUI events. The library handles the
--   interaction on the Haskell side.
@package pianola
@version 0.1.1

module Pianola.Protocol
data ServerError

-- | Client targeted obsolete snapshot.
SnapshotError :: Int -> Int -> ServerError

-- | Server couldn't perform the requested operation.
ServerError :: Text -> ServerError

-- | A <a>Functor</a> which models a RPC call as a pair in which the first
--   component is a list of bytestrings (the arguments of the call) and the
--   second is a pure <tt>Iteratee</tt> that consumes the bytes sent from
--   the server and returns the response of the call.
type ProtocolF = Compose ((,) [ByteString]) (Iteratee ByteString Identity)

-- | A monad to represent interactions with a remote server. A free monad
--   over a RPC call functor, augmented with some error conditions.
type Protocol = EitherT ServerError (Free ProtocolF)

-- | Constructs a RPC call from a packed list of arguments and a pure
--   <tt>Iteratee</tt> to consume the response.
call :: [ByteString] -> (Iteratee ByteString Identity x) -> Protocol x
instance Show ServerError
instance Unpackable ServerError

module Pianola.Protocol.IO
data RunInIOError
CommError :: IOException -> RunInIOError
ParseError :: Text -> RunInIOError
data Endpoint
Endpoint :: HostName -> PortID -> Endpoint
hostName :: Endpoint -> HostName
portID :: Endpoint -> PortID

-- | Runs a sequence of RPC calls in a base monad which has access to an
--   <a>Endpoint</a> value which identifies the server. An accessor
--   function must be provided to extract the Endpoint from the base
--   monad's environment, which may be more general.
runProtocol :: (MonadIO m, MonadReader r m) => (r -> Endpoint) -> Protocol a -> EitherT ServerError (EitherT RunInIOError m) a
instance Show RunInIOError

module Pianola.Geometry
type Interval = (Int, Int)
type Point1d = Int
inside1d :: Interval -> Point1d -> Bool
before1d :: Interval -> Point1d -> Bool
after1d :: Interval -> Point1d -> Bool

-- | (x,y)
type Point2d = (Int, Int)

-- | (width,height)
type Dimensions2d = (Int, Int)
mid :: Interval -> Point1d

-- | Class of objects with rectangular shape and located in a
--   two-dimensional plane.
class Geometrical g where width = fst . dimensions height = snd . dimensions minX = fst . nwcorner midX = mid . yband minY = snd . nwcorner midY = mid . yband xband g = let gminX = minX g in (gminX, gminX + (fst . dimensions) g) yband g = let gminY = minY g in (gminY, gminY + (snd . dimensions) g) area g = width g * height g midpoint g = (midX g, midY g)
nwcorner :: Geometrical g => g -> Point2d
dimensions :: Geometrical g => g -> Dimensions2d
width :: Geometrical g => g -> Int
height :: Geometrical g => g -> Int
minX :: Geometrical g => g -> Int
midX :: Geometrical g => g -> Int
minY :: Geometrical g => g -> Int
midY :: Geometrical g => g -> Int
xband :: Geometrical g => g -> Interval
yband :: Geometrical g => g -> Interval
area :: Geometrical g => g -> Int
midpoint :: Geometrical g => g -> Point2d

-- | True if the second object is roughly at the same height and to the
--   right of the first object.
sameLevelRightOf :: (Geometrical g1, Geometrical g2) => g1 -> g2 -> Bool


-- | This module should not be imported by clients unless for the purpose
--   of extending the library.
--   
--   The constructors of the data types defined in this module are meant to
--   be hidden from the client.
module Pianola.Internal

-- | Wraps a monad in order to tag those operations which don't actually
--   change the state of the remote system. For example: taking a
--   screenshot doesn't change the state of a GUI, as opposed to clicking a
--   button.
newtype Nullipotent m a
Nullipotent :: m a -> Nullipotent m a
runNullipotent :: Nullipotent m a -> m a
type Tag = Text

-- | Encapsulates a monadic action so that clients can't manipulate it in
--   any way, only dispatch it to some function.
--   
--   There may be tags attached that describe the action. Clients should be
--   able to inspect the tags.
data Sealed m
Sealed :: [Tag] -> m () -> Sealed m
tags :: Sealed m -> [Tag]
unseal :: Sealed m -> m ()
addTag :: Tag -> Sealed m -> Sealed m
instance Eq (m a) => Eq (Nullipotent m a)
instance Ord (m a) => Ord (Nullipotent m a)
instance Read (m a) => Read (Nullipotent m a)
instance Show (m a) => Show (Nullipotent m a)
instance Functor m => Functor (Nullipotent m)
instance Foldable m => Foldable (Nullipotent m)
instance Traversable m => Traversable (Nullipotent m)
instance Monad m => Monad (Nullipotent m)

module Pianola.Util

-- | Convenience function to transform a list into any <a>MonadPlus</a>.
replusify :: MonadPlus m => [a] -> m a

-- | Transforms a zero-or-many result into a zero-or-one result.
tomaybet :: Monad m => LogicT m a -> MaybeT m a

-- | Class of types whose values have children of the same type as
--   themselves.
class Treeish l
children :: (Treeish l, MonadPlus m) => l -> m l
descendants :: (Treeish l, MonadPlus m) => l -> m l
type Produ t = Producer t
type Consu t = Consumer t
class Functor l => Loggy l where logmsg = logentry . TextEntry logimg = logentry . ImageEntry logmsgK msg = (<$ logmsg msg)
logentry :: Loggy l => LogEntry -> l ()
logmsg :: Loggy l => Text -> l ()
logimg :: Loggy l => Image -> l ()
logmsgK :: Loggy l => Text -> a -> l a
data LogEntry
TextEntry :: Text -> LogEntry
ImageEntry :: Image -> LogEntry
type Image = ByteString

-- | Wraps a monad in order to tag those operations which don't actually
--   change the state of the remote system. For example: taking a
--   screenshot doesn't change the state of a GUI, as opposed to clicking a
--   button.
data Nullipotent m a
type Tag = Text

-- | Encapsulates a monadic action so that clients can't manipulate it in
--   any way, only dispatch it to some function.
--   
--   There may be tags attached that describe the action. Clients should be
--   able to inspect the tags.
data Sealed m
addTag :: Tag -> Sealed m -> Sealed m
instance (Monad l, Loggy l) => Loggy (MaybeT l)
instance (Monad l, Loggy l) => Loggy (LogicT l)
instance Monad m => Loggy (Produ LogEntry m)
instance Unpackable a => Unpackable (Tree a)
instance (Unpackable a, Unpackable b) => Unpackable (Either a b)
instance Treeish (EnvT e Tree a)
instance Treeish (Tree a)

module Pianola.Pianola

-- | A Glance is just a kleisli arrow used to locate and extract particular
--   elements of type <i>a</i> in a data structure of type <i>o</i>.
--   
--   The following effects are allowed:
--   
--   <ul>
--   <li>Nondeterminism and failure. A Glance can return more than one
--   value (or zero values, with <a>mzero</a>). See the <a>replusify</a>
--   function, which is a valid Glance.</li>
--   <li>Logging. A Glance can log messages of type <i>l</i> about the
--   elements it encounters during search, even elements visited in search
--   branches which ultimately fail to produce any results. See
--   <a>logmsg</a>.</li>
--   <li>Interactions with the server through the monad <i>m</i>, but only
--   interactions that don't change the state of the GUI. For example,
--   getting a image capture of a window. See <a>Nullipotent</a>.</li>
--   </ul>
--   
--   The following effects are forbidden:
--   
--   <ul>
--   <li>Any kind of delay effect. Glances must return as soon as
--   possible.</li>
--   <li>Interactions with the server which <i>do</i> change the state of
--   the GUI. Note that you can target and return the actions of type
--   <a>Sealed</a> which dangle on the branches of the source data
--   structure. You just can't execute them inside a Glance. To actually
--   execute them, pass the glance as an argument to <a>poke</a>.</li>
--   </ul>
type Glance m l o a = o -> LogicT (Produ l (Nullipotent m)) a

-- | When the <a>Glance</a> passed as argument finds nothing, the returned
--   glance finds a single (). When the Glance passed as argument finds one
--   or more values, the returned Glance finds zero results.
--   
--   This function can be used in combination with <a>retryPeek1s</a> to
--   wait for the dissapearance of a component on screen.
missing :: Monad m => Glance m l o a -> Glance m l o ()

-- | Takes all the values returned by a <a>Glance</a> and returns a new
--   Glance in which those values have been collected in a <a>MonadPlus</a>
--   (often a list). This is useful when we want to recover a list of
--   components which meet certain criteria in order to compare them among
--   themselves. For example, getting all the buttons present in a window
--   and sorting them left to right by their position on the screen.
collect :: (Monad m, MonadPlus n) => Glance m l o a -> Glance m l o (n a)

-- | Executes a <a>Nullipotent</a> action in the context of a
--   <a>Glance</a>.
liftN :: Monad m => Glance m l (Nullipotent m a) a

-- | A computation which interacts which an external system represented
--   locally by the type <i>o</i>, using actions on the monad <i>m</i>,
--   emitting log messages of type <i>l</i>, and returning a value of type
--   <i>a</i>.
--   
--   The following effects are allowed:
--   
--   <ul>
--   <li>Purely observational interactions with the external system. See
--   <a>peek</a>.</li>
--   <li>Logging. Log messages are emitted in the middle of the
--   computation, unlike in a Writer monad. See <a>logmsg</a> and
--   <a>logimg</a>.</li>
--   <li>Failure. See <a>pfail</a>.</li>
--   <li>Delays. See <a>sleep</a>.</li>
--   <li>Actions in the <i>m</i> monad which actually change the external
--   system, like clicking on a button of a GUI. See <a>poke</a>.</li>
--   </ul>
--   
--   Instead of baking all possible effects into the base free monad,
--   Pianola takes the approach of representing each effect using the
--   <a>Proxy</a> type from the pipes package.
--   
--   The order of the trasformers in the monad stack is not arbitrary. For
--   example: it does not make sense for a log message to make the
--   computation fail or to trigger actions against the external system, so
--   the log producer is colocated closest to the base monad, where it
--   doesn't have access to those kind of effects.
--   
--   Another example: it can be conveniento to automatically introduce a
--   delay after every action (see <a>ralentize</a>) or to automatically
--   log each action (see <a>autolog</a>). Therefore, the <a>Sealed</a>
--   action producer is in the outermost position, having access to all the
--   effects.
--   
--   To actually execute a Pianola, use a driver function like
--   <a>simpleDriver</a> or a specialization of it.
newtype Pianola m l o a
Pianola :: Produ (Sealed m) (Produ Delay (MaybeT (Produ l (Observer m l o)))) a -> Pianola m l o a
unPianola :: Pianola m l o a -> Produ (Sealed m) (Produ Delay (MaybeT (Produ l (Observer m l o)))) a
type Delay = Int

-- | Aborts a <a>Pianola</a> computation.
pfail :: Monad m => Pianola m l o a

-- | If the second <a>Pianola</a> argument returns Nothing, the first one
--   is executed. Often used in combination with <a>pfail</a>.
pmaybe :: Monad m => Pianola m l o a -> Pianola m l o (Maybe a) -> Pianola m l o a

-- | Lifts a <a>Glance</a> into the <a>Pianola</a> monad.
peek :: Monad m => Glance m l o a -> Pianola m l o a

-- | Like <a>peek</a>, but if the <a>Glance</a> returns zero results then
--   Nothing is returned instead of failing and halting the whole
--   computation.
peekMaybe :: Monad m => Glance m l o a -> Pianola m l o (Maybe a)

-- | Like <a>peekMaybe</a>, but the specified number of retries is
--   performed before returning Nothing. There is an sleep of 1 second
--   between each retry.
retryPeek1s :: Monad m => Int -> Glance m l o a -> Pianola m l o (Maybe a)

-- | A more general version of <a>retryPeek1s</a> which intersperses any
--   <a>Pianola</a> action between retries.
retryPeek :: Monad m => Pianola m l o u -> Int -> Glance m l o a -> Pianola m l o (Maybe a)

-- | Takes a glance that extracts an action of type <a>Sealed</a> from a
--   data structure, and returns a <a>Pianola</a> executing the action
--   (when the Pianola is interpreted by some driver-like fuction like
--   <a>simpleDriver</a>.)
poke :: Monad m => Glance m l o (Sealed m) -> Pianola m l o ()

-- | Like <a>poke</a>, but if the <a>Glance</a> returns zero results then
--   Nothing is returned instead of failing and halting the whole
--   computation.
pokeMaybe :: Monad m => Glance m l o (Sealed m) -> Pianola m l o (Maybe ())

-- | Like <a>pokeMaybe</a>, but the specified number of retries is
--   performed before returning Nothing. There is an sleep of 1 second
--   between each retry.
retryPoke1s :: Monad m => Int -> Glance m l o (Sealed m) -> Pianola m l o (Maybe ())

-- | A more general version of <a>retryPoke1s</a> which intersperses any
--   <a>Pianola</a> action between retries.
retryPoke :: Monad m => Pianola m l o u -> Int -> Glance m l o (Sealed m) -> Pianola m l o (Maybe ())

-- | Sleeps for the specified number of seconds
sleep :: Monad m => Delay -> Pianola m l o ()

-- | Expands the context of a <a>Pianola</a> using a <a>Glance</a>. Typical
--   use: transform a Pianola whose context is a particular window to a
--   Pianola whose context is the whole GUI, using a Glance which locates
--   the window in the GUI.
--   
--   <pre>
--   with glance1 $ peek glance2 
--   </pre>
--   
--   is equal to
--   
--   <pre>
--   peek $ glance1 &gt;=&gt; glance2
--   </pre>
--   
--   <a>with</a> can be used to group peeks and pokes whose glances share
--   part of thir paths in common:
--   
--   <pre>
--   do
--       poke $ glance1 &gt;=&gt; glance2
--       poke $ glance1 &gt;=&gt; glance3
--   </pre>
--   
--   is equal to
--   
--   <pre>
--   with glance1 $ do
--       poke glance2
--       poke glance3
--   </pre>
with :: Monad m => Glance m l o' o -> Pianola m l o a -> Pianola m l o' a

-- | Like <a>with</a>, but when the element targeted by the <a>Glance</a>
--   doens't exist, the Pianola argument is not executed and <a>Nothing</a>
--   is returned.
withMaybe :: Monad m => Glance m l o' o -> Pianola m l o a -> Pianola m l o' (Maybe a)

-- | Like <a>withMaybe</a>, but several attempts to locate the target of
--   the glance are performed, with a separation of 1 second.
withRetry1s :: Monad m => Int -> Glance m l o' o -> Pianola m l o a -> Pianola m l o' (Maybe a)

-- | A more general <a>withMaybe</a> for which any <a>Pianola</a> action
--   can be interstpersed between retries.
withRetry :: Monad m => Pianola m l o' u -> Int -> Glance m l o' o -> Pianola m l o a -> Pianola m l o' (Maybe a)

-- | Takes a delay in seconds and a <a>Pianola</a> as parameters, and
--   returns a ralentized Pianola in which the delay has been inserted
--   after every action.
ralentize :: Delay -> Pianola m l o a -> Pianola m l o a
ralentizeByTag :: ([Tag] -> Bool) -> Delay -> Pianola m l o a -> Pianola m l o a

-- | Modifies a <a>Pianola</a> so that the default tags associated to an
--   action are logged automatically when the action is executed.
autolog :: Pianola m LogEntry o a -> Pianola m LogEntry o a

-- | Unwinds all the Glances contained in a <a>Pianola</a> by supplying
--   them with the monadic value passed as the first argument. When a
--   <a>Glance</a> returns with more than one result, one of the results is
--   selected in order to continue (<i>TO DO</i>: emit a warning when this
--   happens). The log messages of the glances are fused with the Pianola's
--   own log stream. All the <a>Sealed</a> actions are injected into the
--   base monad. The delay and log effects remain uninjected.
--   
--   Usually, clients should not call this function directly, but use a
--   driver function like <a>simpleDriver</a>.
play :: Monad m => m o -> Pianola m l o a -> Produ Delay (MaybeT (Produ l m)) a
instance Functor (Pianola m l o)
instance Monad (Pianola m l o)
instance Monad m => Loggy (Pianola m LogEntry o)

module Pianola.Pianola.Driver

-- | Runs a pianola computation. Receives as argument a monadic action to
--   obtain snapshots of type <i>o</i> of a remote system, a connection
--   endpoint to the remote system, a <a>Pianola</a> computation with
--   context of type <i>o</i> and return value of type <i>a</i>, and an
--   infinite stream of filenames to store the screenshots. Textual log
--   messages are written to standard output. The computation may fail with
--   an error of type <a>DriverError</a>.
--   
--   See also <a>simpleSwingDriver</a>.
simpleDriver :: Protocol o -> Endpoint -> Pianola Protocol LogEntry o a -> Stream FilePath -> EitherT DriverError IO a

-- | Possible failure outcomes when running a pianola computation.
data DriverError

-- | Local exception while storing screenshots or log messages.
DriverIOError :: IOException -> DriverError

-- | Exception when connecting the remote system.
PianolaIOError :: IOException -> DriverError

-- | Remote system returns unparseable data.
PianolaParseError :: Text -> DriverError

-- | An operation was requested on an obsolete snapshot (first integer) of
--   the remote system (whose current snapshot number is the second
--   integer).
PianolaSnapshotError :: Int -> Int -> DriverError

-- | Server couldn't complete requested operation (either because it
--   doesn't support the operation or because of an internal error.)
PianolaServerError :: Text -> DriverError

-- | Failure from a call to <a>pfail</a> or from a <a>Glance</a> without
--   results.
PianolaFailure :: DriverError

-- | A more general version of <a>screenshotStream</a>, which allows the
--   client to specify the prefix before the file number, the amount of
--   padding for the file number, and the suffix after the file number.
filePathStream :: String -> Int -> String -> FilePath -> Stream FilePath

-- | Returns an infinite stream of filenames for storing screenshots,
--   located in the directory supplied as a parameter.
screenshotStream :: FilePath -> Stream FilePath
instance Show DriverError

module Pianola.Model.Swing

-- | A client-side representation of the state of a remote Swing GUI.
--   Interaction with the GUI is through actions in the monad <i>m</i>.
type GUI m = [Window m]
newtype Window m
Window :: Tree (WindowInfo m) -> Window m
unWindow :: Window m -> Tree (WindowInfo m)
data WindowInfo m
WindowInfo :: Text -> (Int, Int) -> [Component m] -> [Component m] -> Component m -> Nullipotent m Image -> Sealed m -> Sealed m -> Sealed m -> Sealed m -> WindowInfo m
_windowTitle :: WindowInfo m -> Text

-- | Width, height.
_windowDim :: WindowInfo m -> (Int, Int)

-- | List of components in the menu bar. See <a>selectInMenuBar</a>.
_menu :: WindowInfo m -> [Component m]

-- | List of components in the popup layer.
_popupLayer :: WindowInfo m -> [Component m]

-- | The contents pane. All non-popup components of the window are
--   descendants of the contents pane. See <a>contentPane</a> and
--   <a>descendants</a>.
_contentPane :: WindowInfo m -> Component m

-- | Action which returns a screenshot capture of the window. See
--   <a>logcapture</a>.
_capture :: WindowInfo m -> Nullipotent m Image

-- | See <a>escape</a>.
_escape :: WindowInfo m -> Sealed m

-- | See <a>enter</a>.
_enter :: WindowInfo m -> Sealed m

-- | See <a>close</a>.
_close :: WindowInfo m -> Sealed m

-- | See <a>toFront</a>.
_toFront :: WindowInfo m -> Sealed m

-- | Typeclass which provides convenience functions to supplement the bare
--   fields of a <a>WindowInfo</a> record.
class Windowed w => WindowLike w where title = return . _windowTitle . wInfo hasTitle f w = do { guard . f $ _windowTitle . wInfo $ w; return w } popupLayer = replusify . _popupLayer . wInfo logcapture = (peek $ liftN . _capture . wInfo) >>= logimg contentPane win = let concrete = runIdentity $ window win in return . ComponentW . EnvT concrete . unComponent . _contentPane . wInfo $ win toFront = return . _toFront . wInfo escape = return . _escape . wInfo enter = return . _enter . wInfo close = return . _close . wInfo
wInfo :: WindowLike w => w m -> WindowInfo m
title :: (WindowLike w, Monad m, Monad n) => (w m) -> n Text
hasTitle :: (WindowLike w, MonadPlus n) => (Text -> Bool) -> w m -> n (w m)
popupLayer :: (WindowLike w, Monad m) => Glance m l (w m) (Component m)
logcapture :: (WindowLike w, Monad m) => Pianola m LogEntry (w m) ()
contentPane :: (WindowLike w, Monad m) => Glance m l (w m) (ComponentW m)
toFront :: (WindowLike w, Monad m) => Glance m l (w m) (Sealed m)
escape :: (WindowLike w, Monad m) => Glance m l (w m) (Sealed m)
enter :: (WindowLike w, Monad m) => Glance m l (w m) (Sealed m)
close :: (WindowLike w, Monad m) => Glance m l (w m) (Sealed m)

-- | Typeclass instantiated by windows and components aware of belonging to
--   a window.
class Windowed w
window :: (Windowed w, Monad n) => w m -> n (Window m)

-- | A component which carries a reference to the window to which it
--   belongs. See <a>Windowed</a>.
newtype ComponentW m
ComponentW :: EnvT (Window m) Tree (ComponentInfo m) -> ComponentW m
unComponentW :: ComponentW m -> EnvT (Window m) Tree (ComponentInfo m)
newtype Component m
Component :: Tree (ComponentInfo m) -> Component m
unComponent :: Component m -> Tree (ComponentInfo m)
data ComponentInfo m
ComponentInfo :: (Int, Int) -> (Int, Int) -> Maybe Text -> Maybe Text -> Maybe Text -> Bool -> ComponentType m -> Sealed m -> Sealed m -> Sealed m -> ComponentInfo m

-- | The position of the component within the containing window.
_pos :: ComponentInfo m -> (Int, Int)

-- | Width and height.
_dim :: ComponentInfo m -> (Int, Int)
_name :: ComponentInfo m -> Maybe Text
_tooltip :: ComponentInfo m -> Maybe Text

-- | The textual value of the component.
_text :: ComponentInfo m -> Maybe Text
_enabled :: ComponentInfo m -> Bool
_componentType :: ComponentInfo m -> ComponentType m
_click :: ComponentInfo m -> Sealed m
_doubleClick :: ComponentInfo m -> Sealed m
_rightClick :: ComponentInfo m -> Sealed m

-- | Represents data specific to each subclass of Swing components.
data ComponentType m
Panel :: ComponentType m

-- | A check box, either in a window or in a popup menu. The bool value is
--   the current selection state.
Toggleable :: Bool -> (Bool -> Sealed m) -> ComponentType m

-- | A button with its selection action. Menu items in popup menus are also
--   treated as buttons.
Button :: (Sealed m) -> ComponentType m

-- | <a>Nothing</a> when the textfield is not editable.
TextField :: (Maybe (Text -> Sealed m)) -> ComponentType m
Label :: ComponentType m

-- | A combo box which may already have a selection, and which offers a
--   click action which shows the drop-down list. See
--   <a>selectInComboBox</a>.
ComboBox :: (Maybe (Component m)) -> (Sealed m) -> ComponentType m

-- | See <a>listCellByText</a>.
List :: [Cell m] -> ComponentType m

-- | Tables are represented as lists of columns. See
--   <a>tableCellByText</a>.
Table :: [[Cell m]] -> ComponentType m

-- | A list of trees of <a>Cell</a>. It is a list of trees instead of a
--   single tree so that JTrees which do not show the root can be
--   represented. See <a>treeCellByText</a>.
Treegui :: (Forest (Cell m)) -> ComponentType m

-- | In Swing, popup menus reside in the popup layer of a window or, if the
--   popup extends beyond the window, in the contents pane of a child
--   window created to hold the popup. See <a>popupItem</a>.
PopupMenu :: ComponentType m

-- | See <a>selectTabByText</a>.
TabbedPane :: [Tab m] -> ComponentType m

-- | The text value holds the name of the class.
Other :: Text -> ComponentType m

-- | Typeclass which provides convenience functions to supplement the bare
--   fields of a <a>ComponentInfo</a> record.
class ComponentLike c where cType = _componentType . cInfo text = justZ . _text . cInfo hasText f c = do { t <- text $ c; guard $ f t; return c } tooltip = justZ . _tooltip . cInfo hasToolTip f c = do { t <- tooltip $ c; guard $ f t; return c } hasName f c = do { t <- justZ . _name . cInfo $ c; guard $ f t; return c } toggle b (cType -> Toggleable _ f) = return $ f b toggle _ _ = mzero click = return . _click . cInfo doubleClick = return . _doubleClick . cInfo rightClick = return . _rightClick . cInfo clickButton (cType -> Button a) = return a clickButton _ = mzero clickCombo (cType -> ComboBox _ a) = return a clickCombo _ = mzero listCellByText f (cType -> List l) = do { cell <- replusify l; let renderer = _renderer cell; descendants >=> hasText f $ renderer; return cell } listCellByText _ _ = mzero tableCellByText colIndex f (cType -> Table listOfCols) = do { column <- atZ listOfCols colIndex; (rowfocus, row) <- replusify $ zip column $ transpose listOfCols; let renderer = _renderer rowfocus; descendants >=> hasText f $ renderer; return (rowfocus, row) } tableCellByText _ _ _ = mzero treeCellByText depth f (cType -> Treegui cellForest) = do { tree <- replusify cellForest; level <- flip atZ depth . levels . duplicate $ tree; subtree <- replusify level; let renderer = _renderer . rootLabel $ subtree; descendants >=> hasText f $ renderer; return subtree } treeCellByText _ _ _ = mzero tab (cType -> TabbedPane p) = replusify p tab _ = mzero setText txt c = case (cType c) of { TextField (Just f) -> return $ f txt _ -> mzero }
cInfo :: ComponentLike c => c m -> ComponentInfo m
cType :: ComponentLike c => c m -> ComponentType m
text :: (ComponentLike c, MonadPlus n) => c m -> n Text
hasText :: (ComponentLike c, MonadPlus n) => (Text -> Bool) -> c m -> n (c m)
tooltip :: (ComponentLike c, MonadPlus n) => c m -> n Text
hasToolTip :: (ComponentLike c, MonadPlus n) => (Text -> Bool) -> c m -> n (c m)
hasName :: (ComponentLike c, MonadPlus n) => (Text -> Bool) -> c m -> n (c m)
toggle :: (ComponentLike c, MonadPlus n) => Bool -> c m -> n (Sealed m)
click :: (ComponentLike c, Monad n) => c m -> n (Sealed m)
doubleClick :: (ComponentLike c, Monad n) => c m -> n (Sealed m)
rightClick :: (ComponentLike c, Monad n) => c m -> n (Sealed m)
clickButton :: (ComponentLike c, MonadPlus n) => c m -> n (Sealed m)
clickCombo :: (ComponentLike c, MonadPlus n) => c m -> n (Sealed m)
listCellByText :: (ComponentLike c, MonadPlus n) => (Text -> Bool) -> c m -> n (Cell m)
tableCellByText :: (ComponentLike c, MonadPlus n) => Int -> (Text -> Bool) -> c m -> n (Cell m, [Cell m])
treeCellByText :: (ComponentLike c, MonadPlus n) => Int -> (Text -> Bool) -> c m -> n (Tree (Cell m))
tab :: (ComponentLike c, MonadPlus n) => c m -> n (Tab m)
setText :: (ComponentLike c, MonadPlus n) => Text -> c m -> n (Sealed m)

-- | Complex gui components like lists, tables and trees are represented as
--   list of cells, list of lists (list of columns) of cells, and trees of
--   cells, respectively.
--   
--   Bear in mind that in Swing the renderer sub-components of a complex
--   component do <i>not</i> count as children of the component. However,
--   editor components <i>do</i> count as children of the component.
--   
--   A common case is to double click on a table cell to activate the
--   cell's editor, and then having to look for that editor among the
--   descendants of the table.
data Cell m
Cell :: Component m -> Sealed m -> Sealed m -> Sealed m -> Maybe (Bool -> Sealed m) -> Cell m

-- | The rendering component. Clients should not try to invoke actions on
--   rendering components, as they are inert and only used for display
--   purposes.
_renderer :: Cell m -> Component m
_clickCell :: Cell m -> Sealed m
_doubleClickCell :: Cell m -> Sealed m
_rightClickCell :: Cell m -> Sealed m

-- | Always <a>Nothing</a> for cells not belonging to trees.
_expand :: Cell m -> Maybe (Bool -> Sealed m)
data Tab m
Tab :: Text -> Maybe Text -> Bool -> Sealed m -> Tab m
_tabText :: Tab m -> Text
_tabToolTip :: Tab m -> Maybe Text
_isTabSelected :: Tab m -> Bool
_selectTab :: Tab m -> Sealed m

-- | Returns the main window of the application. Only works properly when
--   there is only one top-level window.
mainWindow :: Glance m l (GUI m) (Window m)

-- | Returns the children of a window.
childWindow :: Glance m l (Window m) (Window m)

-- | Returns all visible windows whose title satisfies the predicate.
windowTitled :: (Text -> Bool) -> Glance m l (GUI m) (Window m)

-- | If the component or *any of its descendants* is a button whose text
--   satisfies the predicate, returns the click action. Otherwise
--   <a>mzero</a>.
clickButtonByText :: (Monad m, ComponentLike c, Treeish (c m)) => (Text -> Bool) -> Glance m l (c m) (Sealed m)

-- | Similar to <a>clickButtonByText</a>.
clickButtonByToolTip :: (Monad m, ComponentLike c, Treeish (c m)) => (Text -> Bool) -> Glance m l (c m) (Sealed m)

-- | Similar to <a>clickButtonByText</a>.
rightClickByText :: (Monad m, ComponentLike c, Treeish (c m)) => (Text -> Bool) -> Glance m l (c m) (Sealed m)

-- | Returns all the visible popup items belonging to a window (that is,
--   not only the popup components themselves, but all their clickable
--   children). Clients should use this function instead of trying to
--   access the popup layer directly.
popupItem :: Monad m => Glance m l (Window m) (Component m)

-- | Performs a sequence of selections in a window menu, based to the text
--   of the options. Pass it something like
--   
--   <pre>
--   map (==) ["menuitem1","menuitem2',...]
--   </pre>
--   
--   To match the exact names of the options.
selectInMenuBar :: Monad m => [Text -> Bool] -> Pianola m l (Window m) ()

-- | Like <a>selectInMenuBar</a>, but for when the last item is a
--   toggleable component. The boolean paramenter is the desired selection
--   state.
toggleInMenuBar :: Monad m => Bool -> [Text -> Bool] -> Pianola m l (Window m) ()

-- | If the component is a combo box, clicks on it and selects an option by
--   its text. Otherwise fails.
selectInComboBox :: (Monad m, ComponentLike c, Windowed c) => (Text -> Bool) -> Pianola m l (c m) ()

-- | If the component is a tabbed pane returns the select action of a tab
--   whose text matches the predicate. Returns <a>mzero</a> if the
--   component is not a tabbed pane.
selectTabByText :: (Monad m, ComponentLike c) => (Text -> Bool) -> Glance m l (c m) (Sealed m)

-- | Similar to <tt>selecTabByText</tt>.
selectTabByToolTip :: (Monad m, ComponentLike c) => (Text -> Bool) -> Glance m l (c m) (Sealed m)

-- | Returns the expand/collapse action of the root node of a tree of
--   cells, depending on a boolean parameter. Useful with gui trees.
expand :: Monad m => Bool -> Glance m l (Tree (Cell m)) (Sealed m)

-- | Takes a component, searches its descendants to find a label whose text
--   matches the predicate, finds the component to which the label applies,
--   and returns it.
--   
--   Useful for targeting text fields in form-like dialogs.
labeledBy :: (Monad m, ComponentLike c, Treeish (c m)) => (Text -> Bool) -> Glance m l (c m) (c m)
instance ComponentLike c => Geometrical (c m)
instance ComponentLike Component
instance Treeish (Component m)
instance Windowed ComponentW
instance ComponentLike ComponentW
instance Treeish (ComponentW m)
instance Windowed Window
instance WindowLike Window
instance Treeish (Window m)

module Pianola.Model.Swing.Protocol

-- | Monadic action to obtain a local representation of the state of a
--   remote Swing GUI.
snapshot :: Protocol (GUI Protocol)
instance Unpackable (Tab Protocol)
instance Unpackable (Cell Protocol)
instance Unpackable (ComponentType Protocol)
instance Unpackable (Component Protocol)
instance Unpackable (ComponentInfo Protocol)
instance Unpackable (WindowInfo Protocol)
instance Unpackable (Window Protocol)

module Pianola.Model.Swing.Driver

-- | Specialization of <a>simpleDriver</a> which doesn't require the client
--   to provide the snapshot action.
simpleSwingDriver :: Endpoint -> Pianola Protocol LogEntry (GUI Protocol) a -> Stream FilePath -> EitherT DriverError IO a

module Pianola.Tutorial
