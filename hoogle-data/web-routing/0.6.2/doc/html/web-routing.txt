-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | simple routing library
--   
@package web-routing
@version 0.6.2

module Network.Routing.Dict
data Store kvs
emptyStore :: Store []

-- | 'not elem key' constraint(ghc &gt;= 7.8)
type (</) k v = HasKey k v ~ AlreadyHasKey k

-- | O(1) add key value pair to dictionary.
--   
--   <pre>
--   &gt;&gt;&gt; let a = add (Proxy :: Proxy "foo") (12 :: Int) emptyStore
--   
--   &gt;&gt;&gt; a
--   Store {foo = 12 :: Int}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; add (Proxy :: Proxy "bar") "baz" a
--   Store {bar = "baz" :: [Char], foo = 12 :: Int}
--   </pre>
add :: k </ kvs => proxy k -> v -> Store kvs -> Store ((k := v) : kvs)

-- | O(n) convert <a>Store</a> to <a>Dictionary</a>.
mkDict :: Store kvs -> Dict kvs

-- | heterogeneous dictionary
--   
--   <a>get</a> operation only allowed.
data Dict (kvs :: [KV *])
emptyDict :: Dict []
class Member (k :: Symbol) (v :: *) (kvs :: [KV *]) | k kvs -> v

-- | O(1) (&gt;= ghc-7.8), O(n) (&lt; ghc-7.8) get key from dictionary
--   
--   <pre>
--   &gt;&gt;&gt; let d = mkDict $ add (Proxy :: Proxy "foo") 12 $ add (Proxy :: Proxy "bar") "baz" emptyStore
--   
--   &gt;&gt;&gt; get (Proxy :: Proxy "foo") d
--   12
--   
--   &gt;&gt;&gt; get (Proxy :: Proxy "bar") d
--   "baz"
--   </pre>
get :: Member k v kvs => proxy k -> Dict kvs -> v
class ShowDict (kvs :: [KV *])

-- | (kind) key-value pair
data KV v
(:=) :: Symbol -> v -> KV v

-- | type family to constraint multi kvs.
--   
--   <pre>
--   Members ["foo" := Int, "bar" := Double] prms == (Member "foo" Int prms, Member "bar" Double prms)
--   </pre>

-- | (kind) pretty print type error of <a>get</a>
--   
--   used only &gt;= ghc-7.8
--   
--   <pre>
--   &gt; get (Proxy :: Proxy "b") (mkDict $ add (Proxy :: Proxy "a") "a" emptyStore)
--   Couldn't match type ‘'Key "b"’ with ‘'NotInDicrionary i’
--   </pre>
data GetResult
NotInDicrionary :: Nat -> GetResult
Key :: Symbol -> GetResult

-- | (kind) pretty print type error of <a>add</a>.
--   
--   <pre>
--   &gt; add (Proxy :: Proxy "a") 12 $ add (Proxy :: Proxy "a") "a" emptyStore
--   Couldn't match type ‘'Dictionary’ with ‘'AlreadyHasKey "a"’
--   </pre>
data AddResult
AlreadyHasKey :: Symbol -> AddResult
Dictionary :: AddResult


-- | <pre>
--   &gt;&gt;&gt; :set -XDataKinds -XPolyKinds -XOverloadedStrings
--   
--   &gt;&gt;&gt; data Proxy s = Proxy
--   
--   &gt;&gt;&gt; import Text.Read(readMaybe)
--   
--   &gt;&gt;&gt; import qualified Data.Text as T
--   </pre>
--   
--   <ol>
--   <li>create path</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; data Result = A | B T.Text | C | D Int | E T.Text deriving Show
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let key = Proxy :: Proxy "key"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = root $ exact "foo" $ action Nothing (\_ -&gt; Just A)
--   
--   &gt;&gt;&gt; let b = root $ exact "bar" $ fetch key Just $ action Nothing (\d -&gt; Just . B $ D.get key d)
--   
--   &gt;&gt;&gt; let c = root $ exact "bar" $ any $ action (Just "GET") (\_ -&gt; Just C)
--   
--   &gt;&gt;&gt; let d = root $ exact "bar" $ fetch key (\t -&gt; readMaybe (T.unpack t) :: Maybe Int) $ action Nothing (\d -&gt; Just . D $ D.get key d)
--   
--   &gt;&gt;&gt; let e = root $ exact "foo" $ fetch key Just $ exact "qux" $ action (Just "POST") (\d -&gt; Just . E $ D.get key d)
--   
--   &gt;&gt;&gt; a
--   * /foo
--   
--   &gt;&gt;&gt; b
--   * /bar/:key
--   
--   &gt;&gt;&gt; c
--   GET /bar/**
--   
--   &gt;&gt;&gt; d
--   * /bar/:key
--   
--   &gt;&gt;&gt; e
--   POST /foo/:key/qux
--   </pre>
--   
--   <ol>
--   <li>create router</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let r = e +| d +| a +| b +| c +| empty
--   </pre>
--   
--   <ol>
--   <li>execute router</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let run = execute r
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run "GET" ["foo"]
--   Just A
--   
--   &gt;&gt;&gt; run "GET" ["foo", "bar"]
--   Nothing
--   
--   &gt;&gt;&gt; run "GET" ["bar", "12"]
--   Just (D 12)
--   
--   &gt;&gt;&gt; run "GET" ["bar", "baz"]
--   Just (B "baz")
--   
--   &gt;&gt;&gt; run "GET" ["bar", "baz", "qux"]
--   Just C
--   
--   &gt;&gt;&gt; run "POST" ["bar", "baz", "qux"]
--   Nothing
--   
--   &gt;&gt;&gt; run "POST" ["foo", "bar", "baz"]
--   Nothing
--   
--   &gt;&gt;&gt; run "POST" ["foo", "bar", "qux"]
--   Just (E "bar")
--   </pre>
module Network.Routing
type Method = ByteString

-- | routing path
data Path d m a

-- | show path. since v0.6.0.
showPath :: Path d m a -> String

-- | get method. since v0.6.0.
getMethod :: Path d m a -> Maybe Method

-- | root
--   
--   <pre>
--   root == id
--   </pre>
root :: Path [] m a -> Path [] m a

-- | exact matching path
exact :: Text -> Path d m a -> Path d m a

-- | action
action :: Maybe Method -> (Dict d -> m a) -> Path d m a
type Raw m d d' = Store d -> [Text] -> m (Store d', [Text])

-- | get one directory as parameter.
--   
--   raw get parameter function
--   
--   if you want matching exact path, use <a>exact</a> for performance
raw :: String -> Raw m d d' -> Path d' m a -> Path d m a
fetch :: (MonadPlus m, KnownSymbol k, k </ d) => proxy k -> (Text -> Maybe v) -> Path ((k := v) : d) m a -> Path d m a

-- | drop any pathes
any :: Monad m => Path d m a -> Path d m a

-- | take any pathes as [Text]
rest :: (KnownSymbol k, Monad m, k </ d) => proxy k -> Path ((k := [Text]) : d) m a -> Path d m a

-- | router
data Router d m a

-- | empty router
empty :: MonadPlus m => Router [] m a

-- | insert path to router
insert :: MonadPlus m => Path [] m a -> Router [] m a -> Router [] m a

-- | infix version of <a>insert</a>
(+|) :: MonadPlus m => Path [] m a -> Router [] m a -> Router [] m a

-- | execute router
execute :: MonadPlus m => Router [] m a -> Method -> [Text] -> m a
instance Show (Path d m a)
