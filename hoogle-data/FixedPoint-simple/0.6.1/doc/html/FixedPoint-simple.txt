-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fixed point, large word, and large int numerical representations (types and common class instances)
--   
@package FixedPoint-simple
@version 0.6.1

module Data.FixedPoint.TH

-- | <tt>$(mkWord X)</tt> Makes a type alias named <tt>WordX</tt> for a
--   word of <tt>X</tt> bits. Notice <tt>X</tt> must be a multiple of 8,
--   <a>Word8</a> must be in scope, <a>BigWord</a> must be in scope, and
--   this splice will add all smaller <tt>WordY</tt> type aliases needed
--   that aren't already in scope.
mkWord :: Int -> DecsQ

-- | <tt>$(mkInt X)</tt> Makes a type alias named <tt>IntX</tt> for an int
--   of X bits. See the requirements under <a>mkWord</a> for additional
--   information.
mkInt :: Int -> DecsQ
mkFixedPoint :: Int -> Int -> DecsQ


-- | This FixedPoint module implements arbitrary sized fixed point types
--   and computations. This module intentionally avoids converting to
--   <a>Integer</a> for computations because one purpose is to allow easy
--   translation to other languages to produce stand-alone fixed point
--   libraries. Instead of using <a>Integer</a>, elementary long
--   multiplication and long division are implemented explicitly along with
--   sqrt, exp, and erf functions that are implemented using only primitive
--   operations.
module Data.FixedPoint
type FixedPoint4816 = GenericFixedPoint Int64 Word128 Word16
type FixedPoint3232 = GenericFixedPoint Int64 Word128 Word32
type FixedPoint6464 = GenericFixedPoint Int128 Word256 Word64
type FixedPoint128128 = GenericFixedPoint Int256 Word512 Word128
type FixedPoint256256 = GenericFixedPoint Int512 Word1024 Word256
type FixedPoint512512 = GenericFixedPoint Int1024 Word2048 Word512
type FixedPoint10241024 = GenericFixedPoint Int2048 Word4096 Word1024
erf' :: (Show a, Eq a, Ord a, Num a, Fractional a) => Int -> a -> a
exp' :: (Show a, Ord a, Fractional a, Eq a) => Int -> a -> a

-- | The square root operation converges in O(bitSize input).
sqrt' :: (Ord b, Integral b, Bits b, Integral a, Num a, Bits a, Bits c, FiniteBits b, FiniteBits c) => GenericFixedPoint a b c -> GenericFixedPoint a b c
pi' :: (Integral a, Bits a, Integral b, Num a, Bits b, Bits c, FiniteBits c) => GenericFixedPoint a b c

-- | A 128 bit int (signed)
type Int128 = BigInt Word128

-- | A 256 bit int (signed)
type Int256 = BigInt Word256

-- | A 512 bit int (signed)
type Int512 = BigInt Word512

-- | A 1024 bit int (signed)
type Int1024 = BigInt Word1024

-- | A 2048 bit int (signed)
type Int2048 = BigInt Word2048

-- | A 4096 bit int (signed)
type Int4096 = BigInt Word4096

-- | A 8192 bit int (signed)
type Int8192 = BigInt Word8192
data Word128
W128 :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Word128

-- | A 72 bit unsigned word
type Word72 = BigWord Word8 Word64

-- | A 256 bit unsigned word
type Word256 = BigWord Word128 Word128

-- | A 512 bit unsigned word
type Word512 = BigWord Word256 Word256

-- | A 576 bit unsigned word
type Word576 = BigWord Word64 Word512

-- | A 584 bit unsigned word
type Word584 = BigWord Word72 Word512

-- | A 1024 bit unsigned word
type Word1024 = BigWord Word512 Word512

-- | A 1280 bit unsigned word
type Word1280 = BigWord Word1024 Word256

-- | A 2048 bit unsigned word
type Word2048 = BigWord Word1024 Word1024

-- | A 2632 bit unsigned word
type Word2632 = BigWord Word584 Word2048

-- | A 4096 bit unsigned word
type Word4096 = BigWord Word2048 Word2048

-- | A 8192 bit unsigned word
type Word8192 = BigWord Word4096 Word4096

-- | GenericFixedPoint is a type constructor for arbitrarily-sized fixed
--   point tyes. Take note the first type variable, <tt>flat</tt>, should
--   be a signed int equal to the size of the fixed point integral plus
--   fractional bits. The second type variable, <tt>internal</tt>, should
--   be unsigned and twice as large a bit size as the <tt>flat</tt> type.
--   The final type variable, <tt>fracBitRepr</tt>, should be a data
--   structure of equal bit size to the fractional bits in the fixed point
--   type. See the existing type aliases, such as <tt>FixedPoint4816</tt>,
--   for examples.
data GenericFixedPoint flat internal fracBitRepr
FixedPoint :: flat -> GenericFixedPoint flat internal fracBitRepr
toFlat :: GenericFixedPoint flat internal fracBitRepr -> flat

-- | A type constructor for building 2^n bit signed ints. BigInt is
--   normally just used as a wrapper around BigWord since twos-complement
--   arithmatic is the same, we simply need to provide alternate show,
--   read, and comparison operations.
newtype BigInt a
BigInt :: a -> BigInt a
unBI :: BigInt a -> a

-- | A type constuctor allowing construction of <tt>2^n</tt> bit unsigned
--   words The type variable represents half the underlying representation,
--   so <tt>type Foo = BigWord Word13</tt> would have a bit size of <tt>26
--   (2*13)</tt>.
data BigWord a b
BigWord :: !a -> !b -> BigWord a b
fromInternal :: (Integral b, Num a) => b -> GenericFixedPoint a b c
toInternal :: (Integral a, Num b) => GenericFixedPoint a b c -> b

-- | Obtain the number of bits used to represent the fractional component
--   of this fixed point.
fracBits :: FiniteBits c => GenericFixedPoint a b c -> Int
instance Eq flat => Eq (GenericFixedPoint flat internal fracBitRepr)
instance Ord flat => Ord (GenericFixedPoint flat internal fracBitRepr)
instance Storable flat => Storable (GenericFixedPoint flat i r)
instance Storable Word128
instance (Storable a, Storable b) => Storable (BigWord a b)
instance NFData flat => NFData (GenericFixedPoint flat i r)
instance NFData Word128
instance (NFData a, NFData b) => NFData (BigWord a b)
instance NFData a => NFData (BigInt a)
instance Storable a => Storable (BigInt a)
instance (Bounded a, Ord a, Bits a, Num a, FiniteBits a) => Bounded (BigInt a)
instance (FiniteBits a, Real a, Bounded a, Integral a, Bits a) => Real (BigInt a)
instance (Integral a, Bits a, Bounded a, FiniteBits a) => Integral (BigInt a)
instance (Bits a, Ord a, Integral a, Bounded a, Num a, FiniteBits a) => Enum (BigInt a)
instance (Bits a, Num a, Ord a, FiniteBits a) => Bits (BigInt a)
instance (FiniteBits a, Num a, Bits a, Ord a) => Num (BigInt a)
instance (Num a, Bits a, Ord a, FiniteBits a) => Read (BigInt a)
instance (FiniteBits a, Show a, Num a, Bits a, Ord a) => Show (BigInt a)
instance Eq a => Eq (BigInt a)
instance (Ord a, Bits a, FiniteBits a) => Ord (BigInt a)
instance (Ord a, Num a, FiniteBits a) => FiniteBits (BigInt a)
instance (Integral a, Num a, Bits a, Ord a, Bounded a, Integral b, Num b, Bits b, Ord b, Bounded b, FiniteBits a, FiniteBits b) => Read (BigWord a b)
instance (Bounded a, Bits a, Integral a, FiniteBits a, Bounded b, Bits b, Integral b, FiniteBits b) => Show (BigWord a b)
instance (Bounded a, Integral a, Bits a, FiniteBits a, Bounded b, Integral b, Bits b, FiniteBits b) => Integral (BigWord a b)
instance (Bits a, Real a, Bounded a, Integral a, Bits b, Real b, Bounded b, Integral b, FiniteBits a, FiniteBits b) => Real (BigWord a b)
instance (Ord a, Ord b) => Ord (BigWord a b)
instance (Bounded a, Bounded b) => Bounded (BigWord a b)
instance (Bounded a, Eq a, Num a, Enum a, Bounded b, Eq b, Num b, Enum b) => Enum (BigWord a b)
instance (Ord a, Bits a, Integral a, Bounded a, Ord b, Bits b, Integral b, Bounded b, FiniteBits b, FiniteBits a) => Bits (BigWord a b)
instance (Ord a, Ord b) => Eq (BigWord a b)
instance (Bounded a, Bounded b, FiniteBits a, FiniteBits b, Ord b, Ord a, Integral b, Integral a) => FiniteBits (BigWord a b)
instance (Integral a, Bits a, Num a, Ord a, Bounded a, Bits b, Num b, Ord b, Integral b, Bounded b, FiniteBits a, FiniteBits b) => Num (BigWord a b)
instance Bounded Word128
instance Read Word128
instance Show Word128
instance Integral Word128
instance Real Word128
instance Ord Word128
instance Enum Word128
instance Bits Word128
instance FiniteBits Word128
instance Eq Word128
instance Num Word128
instance (Ord a, Bits a, Bits b, Integral a, Integral b, Bits c, FiniteBits c) => Bits (GenericFixedPoint a b c)
instance (Bits b, Bits c, Bits a, Integral a, Integral b, FiniteBits c) => RealFrac (GenericFixedPoint a b c)
instance (Integral a, Bits a, Integral b, Num a, Bits b, Bits c, FiniteBits c) => Read (GenericFixedPoint a b c)
instance (Integral a, Ord a, Num a, Bits a, Bits b, Integral b, Bits c, FiniteBits c) => Real (GenericFixedPoint a b c)
instance (Ord a, Integral a, Bits a, Num a, Bits b, Integral b, Bits c, FiniteBits c) => Fractional (GenericFixedPoint a b c)
instance (Ord a, Num a, Bits a, Bits b, Integral a, Integral b, Bits c, FiniteBits c) => Num (GenericFixedPoint a b c)
instance (Enum a, Num a, Bits a, Bits c, FiniteBits c) => Enum (GenericFixedPoint a b c)
instance (Integral a, Integral b, Bits a, Bits b, Bits c, FiniteBits c) => Show (GenericFixedPoint a b c)
