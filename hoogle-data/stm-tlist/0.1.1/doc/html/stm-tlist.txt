-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mutable, singly-linked list in STM
--   
--   This package provides a mutable, singly-linked list type for use in
--   <a>STM</a>. It is based on the design of
--   <tt>Control.Concurrent.TChan</tt>, and can be used to implement a wide
--   variety of channel types.
@package stm-tlist
@version 0.1.1


-- | This module uses many names from Prelude, so consider importing it
--   qualified:
--   
--   <pre>
--   import Data.STM.TList (TList)
--   import qualified Data.STM.TList as TList
--   </pre>
module Data.STM.TList

-- | A <a>TList</a> is a mutable linked list node. A <a>TList</a> node
--   containing <a>TNil</a> is usually called a "hole" or "write end", and
--   can be "filled" using <a>append</a>.
type TList a = TVar (TCell a)
data TCell a
TNil :: TCell a
TCons :: a -> !TList a -> TCell a

-- | <i>O(1)</i>. Construct a new, empty <a>TList</a>.
empty :: STM (TList a)

-- | <i>O(1)</i>. <a>IO</a> variant of <a>empty</a>. See <a>newTVarIO</a>
--   for the rationale.
emptyIO :: IO (TList a)

-- | <i>O(1)</i>. Prepend an item to the list, returning the new beginning
--   of the list.
cons :: a -> TList a -> STM (TList a)

-- | <i>O(1)</i>. Append an item to the list, returning the new write end.
--   
--   The <a>TList</a> normally points to a <a>TNil</a>, a "hole" into which
--   the next item will be written. However, if it doesn't, <a>append</a>
--   will silently overwrite the next item. It is up to the application to
--   ensure that the <a>TList</a> points to a <a>TNil</a>, or that
--   overwriting an item in this case is desirable.
append :: TList a -> a -> STM (TList a)

-- | <i>O(n)</i>. Append a list of items, returning the new write end.
appendList :: TList a -> [a] -> STM (TList a)

-- | <i>O(n)</i>. Convert a pure list to a <a>TList</a>, returning the head
--   (read end) and tail (write end) of the list.
fromList :: [a] -> STM (TList a, TList a)

-- | <i>O(1)</i>. Get the next item of the list (if available). Handle
--   <a>TNil</a> (no items available) or <a>TCons</a> (next item) using the
--   appropriate continuation.
--   
--   The <a>TList</a> argument being at the end means <a>uncons</a> can be
--   partially applied in many situations.
uncons :: STM b -> (a -> TList a -> STM b) -> TList a -> STM b

-- | <i>O(1)</i>. Return <a>True</a> if the list is empty.
null :: TList a -> STM Bool

-- | <i>O(n)</i>. Skip the given number of items. Return the end of the
--   list if a <a>TNil</a> is reached.
drop :: Int -> TList a -> STM (TList a)

-- | <i>O(n)</i>. Traverse the list, stopping when a <a>TNil</a> is
--   reached.
--   
--   Bear in mind that <a>TList</a>s are mutable. In particular, the
--   <a>end</a> of a <a>TList</a> is not as boring as the end of a pure
--   list (<tt>[]</tt>, a.k.a. "nil"). It is usually the write end, to
--   which additional items may be <a>append</a>ed.
end :: TList a -> STM (TList a)

-- | <i>O(n)</i>. Traverse the list, returning its length.
length :: TList a -> STM Int

-- | <i>O(n)</i>. Traverse the list with an accumulator function and
--   initial value.
foldl' :: (a -> b -> a) -> a -> TList b -> STM a

-- | <i>O(n)</i>. Traverse a <a>TList</a>, returning its items as a pure
--   list.
toList :: TList a -> STM [a]
instance Typeable1 TCell


-- | This module provides an API very similar to
--   <a>Control.Concurrent.STM.TChan</a>. However, unlike <a>TChan</a>:
--   
--   <ul>
--   <li>It is based on <a>Data.STM.TList</a>, rather than using an
--   abstract internal representation.</li>
--   <li>It separates the read end and write end. This means if the channel
--   has no readers, items written with <a>writeTCursor</a> can be garbage
--   collected.</li>
--   </ul>
--   
--   Here is an implementation of <a>TChan</a> based on <a>TCursor</a>:
--   
--   <pre>
--   type TChan a = (TCursor a, TCursor a)
--   
--   newTChan = newTCursorPair
--   
--   newTChanIO = newTCursorPairIO
--   
--   readTChan = readTCursor . fst
--   
--   writeTChan = writeTCursor . snd
--   
--   dupTChan (_, writeEnd) = do
--       newReadEnd &lt;- dupTCursor writeEnd
--       return (newReadEnd, writeEnd)
--   
--   unGetTChan = unGetTCursor . fst
--   
--   isEmptyTChan = isEmptyTCursor . fst
--   </pre>
module Data.STM.TCursor

-- | A <a>TCursor</a> is a mutable cursor used for traversing items. While
--   <a>uncons</a> and <a>append</a> return the subsequent <a>TList</a>,
--   <a>readTCursor</a> and <a>writeTCursor</a> modify the cursor in-place,
--   and thus behave more like <a>readTChan</a> and <a>writeTChan</a>.
type TCursor a = TVar (TList a)

-- | <i>O(1)</i>. Construct an empty channel, returning the read cursor
--   (<a>fst</a>) and write cursor (<a>snd</a>).
newTCursorPair :: STM (TCursor a, TCursor a)

-- | <i>O(1)</i>. <a>IO</a> variant of <tt>newCursorPair</tt>. See
--   <a>newTVarIO</a> for the rationale.
newTCursorPairIO :: IO (TCursor a, TCursor a)

-- | <i>O(1)</i>. Make a copy of a <a>TCursor</a>. Modifying the old cursor
--   with <a>readTCursor</a> or <a>writeTCursor</a> will not affect the new
--   cursor, and vice versa.
dupTCursor :: TCursor a -> STM (TCursor a)

-- | <i>O(1)</i>. Read the next item and advance the cursor. <a>retry</a>
--   if the channel is currently empty.
--   
--   This should be called on the <i>read</i> cursor of the channel.
readTCursor :: TCursor a -> STM a

-- | <i>O(1)</i>. Like <a>readTCursor</a>, but return <a>Nothing</a>,
--   rather than <a>retry</a>ing, if the list is currently empty.
tryReadTCursor :: TCursor a -> STM (Maybe a)

-- | <i>O(1)</i>. Append an item and advance the cursor.
--   
--   This should be called on the <i>write</i> cursor of the channel. See
--   <a>append</a> for more details.
writeTCursor :: TCursor a -> a -> STM ()

-- | <i>O(1)</i>. Put an item back on the channel, where it will be the
--   next item read by <a>readTCursor</a>.
--   
--   This should be called on the <i>read</i> cursor of the channel.
unGetTCursor :: TCursor a -> a -> STM ()

-- | <i>O(1)</i>. Return <a>True</a> if the channel is empty.
--   
--   This should be called on the <i>read</i> cursor of the channel.
isEmptyTCursor :: TCursor a -> STM Bool
