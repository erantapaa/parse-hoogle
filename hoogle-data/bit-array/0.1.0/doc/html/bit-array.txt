-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A bit array (aka bitset, bitmap, bit vector) API for numeric types
--   
--   The library extends the numeric types with an array-like interface
--   over individual set bits. It also provides an API for conversion to
--   and from the binary notation.
@package bit-array
@version 0.1.0

module BitArray

-- | A <tt>newtype</tt> wrapper which provides an array-like interface to a
--   type, which has instances of <a>Bits</a> and <a>Num</a>.
--   
--   You can construct bit arrays by wrapping numeric values:
--   
--   <pre>
--   &gt;&gt;&gt; BitArray (7 :: Int8)
--   [qq|00000111|]
--   </pre>
--   
--   or directly from numeric literals:
--   
--   <pre>
--   &gt;&gt;&gt; 7 :: BitArray Int8
--   [qq|00000111|]
--   </pre>
--   
--   or using a binary notation quasi-quoter, assuming you have the
--   <tt>QuasiQuotes</tt> pragma turned on:
--   
--   <pre>
--   &gt;&gt;&gt; [qq|0111|] :: BitArray Int8
--   [qq|00000111|]
--   </pre>
--   
--   <tt>BitArray</tt> derives the <a>Bits</a> instance from the base type,
--   so it supports all the standard bitwise operations as well.
--   
--   Note that this library does not support the <a>Integer</a> type, since
--   <a>Integer</a> has no implementation of the <a>bitSize</a> function,
--   which this library heavily relies on. You will get a runtime exception
--   if you use it with <a>Integer</a>.
newtype BitArray a
BitArray :: a -> BitArray a

-- | A binary number quasi-quoter. Produces a numeric literal at compile
--   time. Can be used to construct both bit arrays and integral numbers.
--   
--   <pre>
--   &gt;&gt;&gt; [qq|011|] :: Int
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [qq|011|] :: BitArray Int8
--   [qq|00000011|]
--   </pre>
qq :: QuasiQuoter

-- | Unwrap the underlying value of a bit array.
unwrap :: BitArray a -> a

-- | Convert into a binary notation string.
--   
--   <pre>
--   &gt;&gt;&gt; toString (BitArray (5 :: Int8))
--   "00000101"
--   </pre>
toString :: Bits a => BitArray a -> String

-- | Parse a binary notation string.
--   
--   <pre>
--   &gt;&gt;&gt; parseString "123" :: Maybe (BitArray Int8)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseString "101" :: Maybe (BitArray Int8)
--   Just [qq|00000101|]
--   </pre>
parseString :: (Bits a, Num a) => String -> Maybe (BitArray a)

-- | Convert into a list of set bits.
--   
--   The list is ordered from least significant to most significant bit.
toList :: (Bits a, Num a) => BitArray a -> [a]

-- | Construct from a list of set bits.
fromList :: (Bits a, Num a) => [a] -> BitArray a

-- | Convert into a list of boolean values, which represent the "set" flags
--   of each bit.
--   
--   The list is ordered from least significant to most significant bit.
toBoolList :: Bits a => BitArray a -> [Bool]

-- | Construct from a list of boolean flags for the <a>set</a> status of
--   each bit.
--   
--   The list must be ordered from least significant to most significant
--   bit.
fromBoolList :: (Bits a, Num a) => [Bool] -> BitArray a

-- | Map over the set bits.
map :: (Bits a, Num a, Bits b, Num b) => (a -> b) -> BitArray a -> BitArray b

-- | Perform a right-associative fold over the set bits.
foldr :: (Bits a, Num a) => (a -> b -> b) -> b -> BitArray a -> b

-- | Traverse thru set bits.
mapM_ :: (Bits a, Num a, Monad m) => (a -> m b) -> BitArray a -> m ()

-- | Traverse thru set bits.
traverse_ :: (Bits a, Num a, Applicative f) => (a -> f b) -> BitArray a -> f ()
instance Typeable1 BitArray
instance Bounded a => Bounded (BitArray a)
instance Enum a => Enum (BitArray a)
instance Eq a => Eq (BitArray a)
instance Integral a => Integral (BitArray a)
instance Data a => Data (BitArray a)
instance Num a => Num (BitArray a)
instance Ord a => Ord (BitArray a)
instance Real a => Real (BitArray a)
instance Ix a => Ix (BitArray a)
instance Generic (BitArray a)
instance Bits a => Bits (BitArray a)
instance Datatype D1BitArray
instance Constructor C1_0BitArray
instance (Bits a, Num a) => IsString (BitArray a)
instance (Bits a, Num a) => Read (BitArray a)
instance Bits a => Show (BitArray a)
