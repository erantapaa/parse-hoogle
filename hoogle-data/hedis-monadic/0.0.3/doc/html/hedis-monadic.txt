-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A la MonadReader for Redis connection
--   
@package hedis-monadic
@version 0.0.3

module Database.Redis.Monadic

-- | Monad which has access to Redis connection
class MonadBase IO m => HasRedis m
getRedis :: HasRedis m => m (Connection)
newtype RedisReaderT m a
RedisReaderT :: ReaderT Connection m a -> RedisReaderT m a
getRedisReader :: RedisReaderT m a -> ReaderT Connection m a
runRedisReaderT :: Connection -> RedisReaderT m a -> m a
queryRedis :: HasRedis m => Redis a -> m a

-- | Run redis transaction and try rerun it if it was aborted. Perform
--   random delay between retries.
--   
--   <pre>
--   runRedisTrans con (randomRIO (100, 1000)) 10 $ do
--       watch [key1, key2, key3]
--       lIndex key3 0 &gt;&gt;= case
--           Nothing -&gt; unwatch *&gt; pure TxAborted
--           Just val -&gt; multiExec $ do
--               lRem  key3 1
--               lPush key1 [val]
--               lPush key2 [val]
--   </pre>
--   
--   In next example we copy first value to two different lists and remove
--   it from original list transactionally. If any value in either key1,
--   key2, or key3 was changed between <a>watch</a> command and
--   <tt>exec</tt> (inside <a>multiExec</a>) then transaction will be
--   aboretd, then thread will wait for between 100 and 1000 microseconds,
--   then whole action will be relaunched.
--   
--   <b> User responsible do not perform mutating actions outside of
--   <a>multiExec</a> because this actions can be launched multiple times.
--   </b>
--   
--   Look at next example:
--   
--   <pre>
--   runRedisTrans con (randomRIO (100, 1000)) 10 $ do
--       watch [key1, key2, key3]
--       lPop key3 &gt;&gt;= case
--           Nothing -&gt; unwatch *&gt; pure TxAborted
--           Just val -&gt; multiExec $ do
--               lPush key1 [val]
--               lPush key2 [val]
--   </pre>
--   
--   It is highly unrecommended to do that, because if transaction aborted
--   <tt>lPop</tt> will be performed several times (up to 10).
runRedisTrans :: Connection -> IO Int -> Int -> Redis (TxResult a) -> IO (TxResult a)

-- | Same as <a>runRedisTrans</a> but for <a>HasRedis</a> monad instances.
queryRedisTrans :: HasRedis m => IO Int -> Int -> Redis (TxResult a) -> m (TxResult a)
instance Monad m => Monad (RedisReaderT m)
instance MonadWriter w m => MonadWriter w (RedisReaderT m)
instance MonadState s m => MonadState s (RedisReaderT m)
instance MonadError e m => MonadError e (RedisReaderT m)
instance MonadTrans RedisReaderT
instance Functor m => Functor (RedisReaderT m)
instance MonadFix m => MonadFix (RedisReaderT m)
instance MonadPlus m => MonadPlus (RedisReaderT m)
instance Applicative m => Applicative (RedisReaderT m)
instance Alternative m => Alternative (RedisReaderT m)
instance MonadIO m => MonadIO (RedisReaderT m)
instance MonadCont m => MonadCont (RedisReaderT m)
instance MonadBase b m => MonadBase b (RedisReaderT m)
instance MonadTransControl RedisReaderT
instance MonadBaseControl b m => MonadBaseControl b (RedisReaderT m)
instance MonadReader r m => MonadReader r (RedisReaderT m)
instance (HasRedis m, Monoid w) => HasRedis (WriterT w m)
instance (HasRedis m, Monoid w) => HasRedis (WriterT w m)
instance HasRedis m => HasRedis (ContT r m)
instance HasRedis m => HasRedis (StateT s m)
instance HasRedis m => HasRedis (StateT s m)
instance HasRedis m => HasRedis (ReaderT r m)
instance HasRedis m => HasRedis (MaybeT m)
instance HasRedis m => HasRedis (IdentityT m)
instance HasRedis m => HasRedis (ExceptT e m)
