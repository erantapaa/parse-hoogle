-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalised permutation parser combinator
--   
--   General permutation parser combinators that will work with any parser
--   combinator library.
@package permute
@version 1.0


-- | This module implements permutation parsers, and is a generalisation of
--   <tt>Text.Parsec.Perm</tt> that will work with any parser combinator
--   library. The algorithm is described in:
--   
--   <i>Parsing Permutation Phrases,</i> by Arthur Baars, Andres Loh and
--   Doaitse Swierstra.
module Text.ParserCombinators.Perm

-- | The type <tt>PermParser p a</tt> denotes a permutation parser that,
--   when converted by the <a>permute</a> function, parses <tt>s</tt>
--   streams with user state <tt>st</tt> and returns a value of type
--   <tt>a</tt> on success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>permute</a>.
data PermParser p a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",many1 (char 'a'))
--                          &lt;||&gt; char 'b' 
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: (Alternative p, Monad p) => PermParser p a -> p a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: PermParser p (a -> b) -> p a -> PermParser p b

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: (a -> b) -> p a -> PermParser p b

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: PermParser p (a -> b) -> (a, p a) -> PermParser p b

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: (a -> b) -> (a, p a) -> PermParser p b
