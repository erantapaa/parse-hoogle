-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Windows service applications
--   
--   This package provides a partial binding to the Win32 System Services
--   API. It makes it easy to write Windows service applications using
--   Haskell. _Only 32-bit versions of GHC are supported at this time._
--   
--   The binding is partial. Here are a few ways in which it differs from
--   the official API:
--   
--   <ul>
--   <li>Only services running within their own process are supported.
--   These are processes of the <a>WIN32_OWN_PROCESS</a> type.</li>
--   <li>In cases where multiple versions of the same function exist (for
--   compatibility), this binding only offers one of them.</li>
--   <li>None of the extended control codes are supported. Handlers you
--   write will automatically report this to the operating system when such
--   controls are received.</li>
--   <li>Only facilities for writing services are supported; not
--   controlling them.</li>
--   </ul>
--   
--   Effort has been made to simplify using the API without hiding what is
--   happening behind the scenes. Users are encouraged to read Microsoft's
--   documentation under 'Dev Center - Desktop &gt; Docs &gt; Desktop app
--   development documentation &gt; System Services &gt; Services'. The
--   official example has been ported to Haskell. This can be found in the
--   <a>examples</a> directory of the source tree.
--   
--   <i>Simple Example and Usage</i>
--   
--   <pre>
--   module Main where
--   
--   import Control.Concurrent.MVar
--   import System.Win32.SystemServices.Services
--   
--   main = do
--       mStop &lt;- newEmptyMVar
--       startServiceCtrlDispatcher "Test" 3000 (handler mStop) $ \_ _ h -&gt; do
--           setServiceStatus h running
--           takeMVar mStop
--           setServiceStatus h stopped
--   
--   handler mStop hStatus STOP = do
--       setServiceStatus hStatus stopPending
--       putMVar mStop ()
--       return True
--   handler _ _ INTERROGATE = return True
--   handler _ _ _           = return False
--   
--   running = SERVICE_STATUS WIN32_OWN_PROCESS RUNNING [ACCEPT_STOP] nO_ERROR 0 0 0
--   stopped = SERVICE_STATUS WIN32_OWN_PROCESS STOPPED [] nO_ERROR 0 0 0
--   stopPending = SERVICE_STATUS WIN32_OWN_PROCESS STOP_PENDING [ACCEPT_STOP] nO_ERROR 0 0 0
--   </pre>
--   
--   <pre>
--   C:programmingtest&gt;ghc --make -threaded Main.hs
--   [1 of 1] Compiling Main             ( Main.hs, Main.o )
--   Linking Main.exe ...
--   &lt;linker warnings omitted&gt;
--   C:\programming\test&gt;copy Main.exe c:\svc\Test.exe
--   1 file(s) copied.
--   </pre>
--   
--   Execute the following from an elevated command prompt to register the
--   service:
--   
--   <pre>
--   C:\svc&gt;sc create Test binPath= c:\svc\Test.exe
--   [SC] CreateService SUCCESS
--   </pre>
--   
--   The service can now be started and stopped from the services console.
--   
--   Installation Notes:
--   
--   Depending on which version of Windows and the Windows SDK you are
--   using the .cabal file will need to be modified before installing. A
--   simple `cabal install Win32-services` may not work. For example, If
--   you are building on Windows 8 64-bit with the Windows 8 SDK the
--   'extra-lib-dirs' field will need to be changed to read as follows:
--   
--   <pre>
--   Extra-Lib-Dirs: "C:\\Program Files (x86)\\Windows Kits\\8.0\\Lib\\win8\\um\\x86"
--   </pre>
@package Win32-services
@version 0.2.5.1

module System.Win32.SystemServices.Services

-- | A handler function is registered with the service dispatcher thread
--   from a <a>ServiceMainFunction</a>. The first argument is a
--   <a>HANDLE</a> returned from calling
--   <tt>registerServiceCtrlHandler</tt>. The second argument represents
--   the command this service has been directed to perform.
type HandlerFunction = HANDLE -> SERVICE_CONTROL -> IO Bool

-- | The service dispatcher thread will call each function of this type
--   that you provide. The first argument will be the name of the service.
--   Any additional command-line parameters will appear in the second
--   argument.
--   
--   Each of these functions should call
--   <tt>registerServiceCtrlHandler</tt> to register a function to handle
--   incoming commands. It should then set the service's status to
--   <a>START_PENDING</a>, and specify that no controls will be accepted.
--   At this point the function may perform any other initialization steps
--   before setting the service's status to <a>RUNNING</a>. All of this
--   should take no more than 100ms.
type ServiceMainFunction = String -> [String] -> HANDLE -> IO ()

-- | The control codes the service accepts and processes in its handler
--   function (See <tt>HandlerFunction</tt>). By default, all services
--   accept the <a>INTERROGATE</a> value. To accept the
--   <tt>DEVICEEVENT</tt> value, the service must register to receive
--   device events by using the <tt>registerDeviceNotification</tt>
--   function.
data SERVICE_ACCEPT

-- | The service is a network component that can accept changes in its
--   binding without being stopped and restarted. This control code allows
--   the service to receive <a>NETBINDADD</a>, <a>NETBINDREMOVE</a>,
--   <a>NETBINDENABLE</a>, and <a>NETBINDDISABLE</a> notifications.
[ACCEPT_NETBINDCHANGE] :: SERVICE_ACCEPT

-- | The service can reread its startup parameters without being stopped
--   and restarted. This control code allows the service to receive
--   <a>PARAMCHANGE</a> notifications.
[ACCEPT_PARAMCHANGE] :: SERVICE_ACCEPT

-- | The service can be paused and continued. This control code allows the
--   service to receive <a>PAUSE</a> and <a>CONTINUE</a> notifications.
[ACCEPT_PAUSE_CONTINUE] :: SERVICE_ACCEPT

-- | MSDN documentation says that this function is not supported on Windows
--   Server 2003 or Windows XP/2000. The support status on other versions
--   is unknown to me.
--   
--   The service can perform preshutdown tasks. This control code enables
--   the service to receive <a>PRESHUTDOWN</a> notifications. Note that
--   only the system can send it.
[ACCEPT_PRESHUTDOWN] :: SERVICE_ACCEPT

-- | The service is notified when system shutdown occurs. This control code
--   allows the service to receive <a>SHUTDOWN</a> notifications. Note that
--   only the system can send it.
[ACCEPT_SHUTDOWN] :: SERVICE_ACCEPT

-- | The service can be stopped. This control code allows the service to
--   receive <a>STOP</a> notifications.
[ACCEPT_STOP] :: SERVICE_ACCEPT

-- | A SERVICE_CONTROL is used in Handler functions. All control codes are
--   defined here, but some can only be used with a <tt>HandlerEx</tt>
--   callback. Use <tt>convertSuccess</tt> to translate from a
--   <a>SERVICE_CONTROL</a> to a <a>DWORD</a>. Use <tt>convertAttempt</tt>
--   to translate from a <a>DWORD</a> to a <a>SERVICE_CONTROL</a>.
data SERVICE_CONTROL
[CONTINUE] :: SERVICE_CONTROL
[INTERROGATE] :: SERVICE_CONTROL
[NETBINDADD] :: SERVICE_CONTROL
[NETBINDDISABLE] :: SERVICE_CONTROL
[NETBINDENABLE] :: SERVICE_CONTROL
[NETBINDREMOVE] :: SERVICE_CONTROL
[PARAMCHANGE] :: SERVICE_CONTROL
[PAUSE] :: SERVICE_CONTROL
[PRESHUTDOWN] :: SERVICE_CONTROL
[SHUTDOWN] :: SERVICE_CONTROL
[STOP] :: SERVICE_CONTROL

-- | The current state of a service.
data SERVICE_STATE
[CONTINUE_PENDING] :: SERVICE_STATE
[PAUSE_PENDING] :: SERVICE_STATE
[PAUSED] :: SERVICE_STATE
[RUNNING] :: SERVICE_STATE
[START_PENDING] :: SERVICE_STATE
[STOP_PENDING] :: SERVICE_STATE
[STOPPED] :: SERVICE_STATE

-- | Contains status information for a service.
data SERVICE_STATUS
[SERVICE_STATUS] :: SERVICE_TYPE -> SERVICE_STATE -> [SERVICE_ACCEPT] -> DWORD -> DWORD -> DWORD -> DWORD -> SERVICE_STATUS

-- | The type of service. This binding only supports the WIN32_OWN_PROCESS
--   type.
[serviceType] :: SERVICE_STATUS -> SERVICE_TYPE

-- | The current state of the service.
[currentState] :: SERVICE_STATUS -> SERVICE_STATE

-- | See <a>SERVICE_ACCEPT</a> for details on this field.
[controlsAccepted] :: SERVICE_STATUS -> [SERVICE_ACCEPT]

-- | The error code the service uses to report an error that occurs when it
--   is starting or stopping. To return an error code specific to the
--   service, the service must set this value to
--   <a>eRROR_SERVICE_SPECIFIC_ERROR</a> to indicate that the
--   <a>serviceSpecificExitCode</a> member contains the error code. The
--   service should set this value to <a>nO_ERROR</a> when it is running
--   and on normal termination.
[win32ExitCode] :: SERVICE_STATUS -> DWORD

-- | A service-specific error code that the service returns when an error
--   occurs while the service is starting or stopping. This value is
--   ignored unless the <a>win32ExitCode</a> member is set to
--   <a>eRROR_SERVICE_SPECIFIC_ERROR</a>.
--   
--   This binding does not support service-specific error codes.
[serviceSpecificExitCode] :: SERVICE_STATUS -> DWORD

-- | The check-point value the service increments periodically to report
--   its progress during a lengthy start, stop, pause, or continue
--   operation. For example, the service should increment this value as it
--   completes each step of its initialization when it is starting up. The
--   user interface program that invoked the operation on the service uses
--   this value to track the progress of the service during a lengthy
--   operation. This value is not valid and should be zero when the service
--   does not have a start, stop, pause, or continue operation pending.
[checkPoint] :: SERVICE_STATUS -> DWORD

-- | The estimated time required for a pending start, stop, pause, or
--   continue operation, in milliseconds. Before the specified amount of
--   time has elapsed, the service should make its next call to the
--   SetServiceStatus function with either an incremented dwCheckPoint
--   value or a change in <a>currentState</a>. If the amount of time
--   specified by <a>waitHint</a> passes, and <a>checkPoint</a> has not
--   been incremented or <a>currentState</a> has not changed, the service
--   control manager or service control program can assume that an error
--   has occurred and the service should be stopped. However, if the
--   service shares a process with other services, the service control
--   manager cannot terminate the service application because it would have
--   to terminate the other services sharing the process as well.
[waitHint] :: SERVICE_STATUS -> DWORD

-- | Win32 defines many types of services, but this binding only supports
--   WIN32_OWN_PROCESS.
data SERVICE_TYPE

-- | The service is a file system driver.
[FILE_SYSTEM_DRIVER] :: SERVICE_TYPE

-- | The service is a device driver.
[KERNEL_DRIVER] :: SERVICE_TYPE

-- | The service runs in its own process.
[WIN32_OWN_PROCESS] :: SERVICE_TYPE

-- | The service shares a process with other services.
[WIN32_SHARE_PROCESS] :: SERVICE_TYPE

-- | Do no write your own services of this type. Windows Vista and above
--   prevent service processes from directly interacting with users.
--   
--   A <a>SERVICE_INTERACTIVE_PROCESS</a> is either a
--   <a>WIN32_OWN_PROCESS</a> or a <a>WIN32_SHARE_PROCESS</a> running in
--   the context of the LocalSystem account which is allowed to directly
--   interact with users.
[SERVICE_INTERACTIVE_PROCESS] :: SERVICE_TYPE
nO_ERROR :: ErrCode
eRROR_SERVICE_SPECIFIC_ERROR :: ErrCode

-- | Retrieves the current status of the specified service.
queryServiceStatus :: HANDLE -> IO SERVICE_STATUS

-- | Updates the service control manager's status information for the
--   calling service.
setServiceStatus :: HANDLE -> SERVICE_STATUS -> IO ()

-- | Register a callback function to initialize the service, which will be
--   called by the operating system immediately. startServiceCtrlDispatcher
--   will block until the provided callback function returns.
--   
--   MSDN documentation: Connects the main thread of a service process to
--   the service control manager, which causes the thread to be the service
--   control dispatcher thread for the calling process.
startServiceCtrlDispatcher :: String -> DWORD -> HandlerFunction -> ServiceMainFunction -> IO ()
