-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An EDSL for embedded hard realtime applications.
--   
@package atom
@version 1.0.13


-- | Definitions for Atom expressions, variables, and types
module Language.Atom.Expressions

-- | A typed expression.
data E a
VRef :: V a -> E a
Const :: a -> E a
Cast :: E a -> E b
Add :: E a -> E a -> E a
Sub :: E a -> E a -> E a
Mul :: E a -> E a -> E a
Div :: E a -> E a -> E a
Mod :: E a -> E a -> E a
Not :: E Bool -> E Bool
And :: E Bool -> E Bool -> E Bool
BWNot :: E a -> E a
BWAnd :: E a -> E a -> E a
BWOr :: E a -> E a -> E a
BWXor :: E a -> E a -> E a
BWShiftL :: E a -> E b -> E a
BWShiftR :: E a -> E b -> E a
Eq :: E a -> E a -> E Bool
Lt :: E a -> E a -> E Bool
Mux :: E Bool -> E a -> E a -> E a
F2B :: E Float -> E Word32
D2B :: E Double -> E Word64
B2F :: E Word32 -> E Float
B2D :: E Word64 -> E Double
Retype :: UE -> E a
Pi :: E a
Exp :: E a -> E a
Log :: E a -> E a
Sqrt :: E a -> E a
Pow :: E a -> E a -> E a
Sin :: E a -> E a
Asin :: E a -> E a
Cos :: E a -> E a
Acos :: E a -> E a
Sinh :: E a -> E a
Cosh :: E a -> E a
Asinh :: E a -> E a
Acosh :: E a -> E a
Atan :: E a -> E a
Atanh :: E a -> E a

-- | Variables updated by state transition rules.
data V a
V :: UV -> V a

-- | An untyped term.
data UE
UVRef :: UV -> UE
UConst :: Const -> UE
UCast :: Type -> UE -> UE
UAdd :: UE -> UE -> UE
USub :: UE -> UE -> UE
UMul :: UE -> UE -> UE
UDiv :: UE -> UE -> UE
UMod :: UE -> UE -> UE
UNot :: UE -> UE
UAnd :: [UE] -> UE
UBWNot :: UE -> UE
UBWAnd :: UE -> UE -> UE
UBWOr :: UE -> UE -> UE
UBWXor :: UE -> UE -> UE
UBWShiftL :: UE -> UE -> UE
UBWShiftR :: UE -> UE -> UE
UEq :: UE -> UE -> UE
ULt :: UE -> UE -> UE
UMux :: UE -> UE -> UE -> UE
UF2B :: UE -> UE
UD2B :: UE -> UE
UB2F :: UE -> UE
UB2D :: UE -> UE
UPi :: UE
UExp :: UE -> UE
ULog :: UE -> UE
USqrt :: UE -> UE
UPow :: UE -> UE -> UE
USin :: UE -> UE
UAsin :: UE -> UE
UCos :: UE -> UE
UAcos :: UE -> UE
USinh :: UE -> UE
UCosh :: UE -> UE
UAsinh :: UE -> UE
UAcosh :: UE -> UE
UAtan :: UE -> UE
UAtanh :: UE -> UE

-- | Untyped variables.
data UV
UV :: Int -> String -> Const -> UV
UVArray :: UA -> UE -> UV
UVExtern :: String -> Type -> UV

-- | A typed array.
data A a
A :: UA -> A a

-- | An untyped array.
data UA
UA :: Int -> String -> [Const] -> UA
UAExtern :: String -> Type -> UA

-- | Typed expression:
class Eq a => Expr a
eType :: Expr a => E a -> Type
constant :: Expr a => a -> Const
expression :: Expr a => E a -> Expression
variable :: Expr a => V a -> Variable
rawBits :: Expr a => E a -> E Word64

-- | Typed expression
data Expression
EBool :: (E Bool) -> Expression
EInt8 :: (E Int8) -> Expression
EInt16 :: (E Int16) -> Expression
EInt32 :: (E Int32) -> Expression
EInt64 :: (E Int64) -> Expression
EWord8 :: (E Word8) -> Expression
EWord16 :: (E Word16) -> Expression
EWord32 :: (E Word32) -> Expression
EWord64 :: (E Word64) -> Expression
EFloat :: (E Float) -> Expression
EDouble :: (E Double) -> Expression

-- | Typed variable
data Variable
VBool :: (V Bool) -> Variable
VInt8 :: (V Int8) -> Variable
VInt16 :: (V Int16) -> Variable
VInt32 :: (V Int32) -> Variable
VInt64 :: (V Int64) -> Variable
VWord8 :: (V Word8) -> Variable
VWord16 :: (V Word16) -> Variable
VWord32 :: (V Word32) -> Variable
VWord64 :: (V Word64) -> Variable
VFloat :: (V Float) -> Variable
VDouble :: (V Double) -> Variable

-- | The type of a <a>E</a>.
data Type
Bool :: Type
Int8 :: Type
Int16 :: Type
Int32 :: Type
Int64 :: Type
Word8 :: Type
Word16 :: Type
Word32 :: Type
Word64 :: Type
Float :: Type
Double :: Type

-- | Typed constant
data Const
CBool :: Bool -> Const
CInt8 :: Int8 -> Const
CInt16 :: Int16 -> Const
CInt32 :: Int32 -> Const
CInt64 :: Int64 -> Const
CWord8 :: Word8 -> Const
CWord16 :: Word16 -> Const
CWord32 :: Word32 -> Const
CWord64 :: Word64 -> Const
CFloat :: Float -> Const
CDouble :: Double -> Const

-- | Types with a defined width in bits
class Width a
width :: Width a => a -> Int

-- | Types which have a defined <a>Type</a>
class TypeOf a
typeOf :: TypeOf a => a -> Type

-- | The number of bytes that an object occupies
bytes :: Width a => a -> Int

-- | Converts an typed expression (E a) to an untyped expression (UE).
ue :: Expr a => E a -> UE

-- | Convert a typed variable to an untyped one
uv :: V a -> UV

-- | Expression of numerical type
class (Num a, Expr a, EqE a, OrdE a) => NumE a

-- | Expression of integral type
class (NumE a, Integral a) => IntegralE a

-- | Floating-point typed expression
class (RealFloat a, NumE a, OrdE a) => FloatingE a

-- | Expressions which can be compared for equality
class (Eq a, Expr a) => EqE a

-- | Expressions which can be ordered
class (Eq a, Ord a, EqE a) => OrdE a

-- | True term.
true :: E Bool

-- | False term.
false :: E Bool

-- | Returns the value of a <a>V</a>.
value :: V a -> E a

-- | Logical negation.
not_ :: E Bool -> E Bool

-- | Logical AND.
(&&.) :: E Bool -> E Bool -> E Bool

-- | Logical OR.
(||.) :: E Bool -> E Bool -> E Bool

-- | The conjunction of a E Bool list.
and_ :: [E Bool] -> E Bool

-- | The disjunction of a E Bool list.
or_ :: [E Bool] -> E Bool

-- | True iff the predicate is true for any element.
any_ :: (a -> E Bool) -> [a] -> E Bool

-- | True iff the predicate is true for all elements.
all_ :: (a -> E Bool) -> [a] -> E Bool

-- | Logical implication (if a then b).
imply :: E Bool -> E Bool -> E Bool

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Bitwise left-shifting.
(.<<.) :: (Bits a, IntegralE a, IntegralE n) => E a -> E n -> E a

-- | Bitwise right-shifting.
(.>>.) :: (Bits a, IntegralE a, IntegralE n) => E a -> E n -> E a

-- | Bitwise left-rotation.
rol :: (IntegralE a, IntegralE n, Bits a) => E a -> E n -> E a

-- | Bitwise right-rotation.
ror :: (IntegralE a, IntegralE n, Bits a) => E a -> E n -> E a

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Equal.
(==.) :: EqE a => E a -> E a -> E Bool

-- | Not equal.
(/=.) :: EqE a => E a -> E a -> E Bool

-- | Less than.
(<.) :: OrdE a => E a -> E a -> E Bool

-- | Less than or equal.
(<=.) :: OrdE a => E a -> E a -> E Bool

-- | Greater than.
(>.) :: OrdE a => E a -> E a -> E Bool

-- | Greater than or equal.
(>=.) :: OrdE a => E a -> E a -> E Bool

-- | Returns the minimum of two numbers.
min_ :: OrdE a => E a -> E a -> E a

-- | Returns the minimum of a list of numbers.
minimum_ :: OrdE a => [E a] -> E a

-- | Returns the maximum of two numbers.
max_ :: OrdE a => E a -> E a -> E a

-- | Returns the maximum of a list of numbers.
maximum_ :: OrdE a => [E a] -> E a

-- | Limits between min and max.
limit :: OrdE a => E a -> E a -> E a -> E a

-- | Division. If both the dividend and divisor are constants, a
--   compile-time check is made for divide-by-zero. Otherwise, if the
--   divisor ever evaluates to <tt>0</tt>, a runtime exception will occur,
--   even if the division occurs within the scope of a <tt>cond</tt> or
--   <a>mux</a> that tests for <tt>0</tt> (because Atom generates
--   deterministic-time code, every branch of a <tt>cond</tt> or <a>mux</a>
--   is executed).
div_ :: IntegralE a => E a -> E a -> E a

-- | Division, where the C code is instrumented with a runtime check to
--   ensure the divisor does not equal <tt>0</tt>. If it is equal to
--   <tt>0</tt>, the 3rd argument is a user-supplied non-zero divsor.
div0_ :: IntegralE a => E a -> E a -> a -> E a

-- | Modulo. If both the dividend and modulus are constants, a compile-time
--   check is made for divide-by-zero. Otherwise, if the modulus ever
--   evaluates to <tt>0</tt>, a runtime exception will occur, even if the
--   division occurs within the scope of a <tt>cond</tt> or <a>mux</a> that
--   tests for <tt>0</tt> (because Atom generates deterministic-time code,
--   every branch of a <tt>cond</tt> or <a>mux</a> is executed).
mod_ :: IntegralE a => E a -> E a -> E a

-- | Modulus, where the C code is instrumented with a runtime check to
--   ensure the modulus does not equal <tt>0</tt>. If it is equal to
--   <tt>0</tt>, the 3rd argument is a user-supplied non-zero divsor.
mod0_ :: IntegralE a => E a -> E a -> a -> E a

-- | Conditional expression. Note, both branches are evaluated!
--   
--   <pre>
--   mux test onTrue onFalse
--   </pre>
mux :: Expr a => E Bool -> E a -> E a -> E a

-- | Array index to variable.
(!) :: (Expr a, IntegralE b) => A a -> E b -> V a

-- | Array index to expression.
(!.) :: (Expr a, IntegralE b) => A a -> E b -> E a

-- | Produced an untyped expression from a constant <a>Bool</a>
ubool :: Bool -> UE

-- | Logical NOT of an untyped expression
unot :: UE -> UE

-- | Logical AND of two untyped expressions
uand :: UE -> UE -> UE

-- | Logical OR of two untyped expressions
uor :: UE -> UE -> UE

-- | Check equality on two untyped expressions
ueq :: UE -> UE -> UE

-- | 2-to-1 multiplexer. If selector is true, this returns input 1; if
--   selector is false, this returns input 2.
umux :: UE -> UE -> UE -> UE
instance Typeable Type
instance Typeable Const
instance Typeable UA
instance Typeable UE
instance Typeable UV
instance Show Type
instance Read Type
instance Eq Type
instance Ord Type
instance Enum Type
instance Data Type
instance Eq Const
instance Ord Const
instance Data Const
instance Show UA
instance Eq UA
instance Ord UA
instance Data UA
instance Eq (A a)
instance Show UE
instance Eq UE
instance Ord UE
instance Data UE
instance Show UV
instance Eq UV
instance Ord UV
instance Data UV
instance Eq (V a)
instance Eq Variable
instance (Expr a, OrdE a, EqE a, IntegralE a, Bits a) => Bits (E a)
instance (Num a, Fractional a, Floating a, FloatingE a) => Floating (E a)
instance (OrdE a, NumE a, Num a, Fractional a) => Fractional (E a)
instance (Num a, NumE a, OrdE a) => Num (E a)
instance FloatingE Double
instance FloatingE Float
instance OrdE Double
instance OrdE Float
instance OrdE Word64
instance OrdE Word32
instance OrdE Word16
instance OrdE Word8
instance OrdE Int64
instance OrdE Int32
instance OrdE Int16
instance OrdE Int8
instance EqE Double
instance EqE Float
instance EqE Word64
instance EqE Word32
instance EqE Word16
instance EqE Word8
instance EqE Int64
instance EqE Int32
instance EqE Int16
instance EqE Int8
instance EqE Bool
instance IntegralE Word64
instance IntegralE Word32
instance IntegralE Word16
instance IntegralE Word8
instance IntegralE Int64
instance IntegralE Int32
instance IntegralE Int16
instance IntegralE Int8
instance NumE Double
instance NumE Float
instance NumE Word64
instance NumE Word32
instance NumE Word16
instance NumE Word8
instance NumE Int64
instance NumE Int32
instance NumE Int16
instance NumE Int8
instance Expr Double
instance Expr Float
instance Expr Word64
instance Expr Word32
instance Expr Word16
instance Expr Word8
instance Expr Int64
instance Expr Int32
instance Expr Int16
instance Expr Int8
instance Expr Bool
instance Expr a => TypeOf (E a)
instance TypeOf UE
instance TypeOf (A a)
instance TypeOf UA
instance TypeOf (V a)
instance TypeOf UV
instance TypeOf Const
instance Width UV
instance Width UE
instance Expr a => Width (V a)
instance Expr a => Width (E a)
instance Width Const
instance Width Type
instance Expr a => Eq (E a)
instance Show (E a)
instance Show Const


-- | Sharing for <a>UE</a>s, based on IntMaps. The idea is to share
--   subexpressions of <a>UE</a>s.
module Language.Atom.UeMap

-- | Corresponds to <a>UE</a>s --- the elements in the sharing structure.
data UeElem
MUVRef :: !MUV -> UeElem
MUConst :: !Const -> UeElem
MUCast :: !Type -> !Hash -> UeElem
MUAdd :: !Hash -> !Hash -> UeElem
MUSub :: !Hash -> !Hash -> UeElem
MUMul :: !Hash -> !Hash -> UeElem
MUDiv :: !Hash -> !Hash -> UeElem
MUMod :: !Hash -> !Hash -> UeElem
MUNot :: !Hash -> UeElem
MUAnd :: [Hash] -> UeElem
MUBWNot :: !Hash -> UeElem
MUBWAnd :: !Hash -> !Hash -> UeElem
MUBWOr :: !Hash -> !Hash -> UeElem
MUBWXor :: !Hash -> !Hash -> UeElem
MUBWShiftL :: !Hash -> !Hash -> UeElem
MUBWShiftR :: !Hash -> !Hash -> UeElem
MUEq :: !Hash -> !Hash -> UeElem
MULt :: !Hash -> !Hash -> UeElem
MUMux :: !Hash -> !Hash -> !Hash -> UeElem
MUF2B :: !Hash -> UeElem
MUD2B :: !Hash -> UeElem
MUB2F :: !Hash -> UeElem
MUB2D :: !Hash -> UeElem
MUPi :: UeElem
MUExp :: !Hash -> UeElem
MULog :: !Hash -> UeElem
MUSqrt :: !Hash -> UeElem
MUPow :: !Hash -> !Hash -> UeElem
MUSin :: !Hash -> UeElem
MUAsin :: !Hash -> UeElem
MUCos :: !Hash -> UeElem
MUAcos :: !Hash -> UeElem
MUSinh :: !Hash -> UeElem
MUCosh :: !Hash -> UeElem
MUAsinh :: !Hash -> UeElem
MUAcosh :: !Hash -> UeElem
MUAtan :: !Hash -> UeElem
MUAtanh :: !Hash -> UeElem

-- | Untyped variables map.
data MUV
MUV :: Int -> String -> Const -> MUV
MUVArray :: UA -> Hash -> MUV
MUVExtern :: String -> Type -> MUV

-- | An entry in the Map.
type UeMap = (Hash, Bimap Int UeElem)
emptyMap :: UeMap
type Hash = Int
typeOf :: Hash -> UeMap -> Type

-- | Wrapped in the State Monad.
type UeState a = State UeMap a

-- | Get a <a>UE</a> back out of the <a>UeMap</a>.
recoverUE :: UeMap -> Hash -> UE

-- | Get the element associated with a <a>Hash</a> value. It's an error if
--   the element is not in the map.
getUE :: Hash -> UeMap -> UeElem

-- | Put a new <a>UE</a> in the map, unless it's already in there, and
--   return the hash pointing to the <a>UE</a> and a new map.
newUE :: UE -> UeMap -> (Hash, UeMap)

-- | Transforms a <a>UV</a> into a <a>MUV</a>, returning the possibly
--   updated map.
newUV :: UV -> UeMap -> (MUV, UeMap)

-- | Lookup an element in the map, and if it's in there, do nothing, but
--   return its hash value. Otherwise, update the map and return the new
--   hash value for the inserted element.
maybeUpdate :: UeElem -> UeState Hash

-- | The list of Hashes to adjacent upstream of a UE.
ueUpstream :: Hash -> UeMap -> [Hash]

-- | The list of all UVs that directly control the value of an expression.
nearestUVs :: Hash -> UeMap -> [MUV]

-- | All array indexing subexpressions.
arrayIndices :: Hash -> UeMap -> [(UA, Hash)]
isMathHCall :: UeElem -> Bool
instance Show MUV
instance Eq MUV
instance Ord MUV
instance Show UeElem
instance Eq UeElem
instance Ord UeElem


module Language.Atom.Elaboration

-- | The Atom monad holds variable and rule declarations.
data Atom a
data AtomDB
AtomDB :: Int -> Name -> [Name] -> Hash -> [AtomDB] -> Int -> Phase -> [(MUV, Hash)] -> [([String] -> String, [Hash])] -> [(Name, Hash)] -> [(Name, Hash)] -> AtomDB
atomId :: AtomDB -> Int
atomName :: AtomDB -> Name
atomNames :: AtomDB -> [Name]
atomEnable :: AtomDB -> Hash
atomSubs :: AtomDB -> [AtomDB]
atomPeriod :: AtomDB -> Int
atomPhase :: AtomDB -> Phase
atomAssigns :: AtomDB -> [(MUV, Hash)]
atomActions :: AtomDB -> [([String] -> String, [Hash])]
atomAsserts :: AtomDB -> [(Name, Hash)]
atomCovers :: AtomDB -> [(Name, Hash)]
data Global
Global :: Int -> Int -> Int -> [StateHierarchy] -> [(String, Hash)] -> Int -> Phase -> Global
gRuleId :: Global -> Int
gVarId :: Global -> Int
gArrayId :: Global -> Int
gState :: Global -> [StateHierarchy]
gProbes :: Global -> [(String, Hash)]
gPeriod :: Global -> Int
gPhase :: Global -> Phase
data Rule
Rule :: Int -> Name -> Hash -> [(MUV, Hash)] -> [([String] -> String, [Hash])] -> Int -> Phase -> Rule
ruleId :: Rule -> Int
ruleName :: Rule -> Name
ruleEnable :: Rule -> Hash
ruleAssigns :: Rule -> [(MUV, Hash)]
ruleActions :: Rule -> [([String] -> String, [Hash])]
rulePeriod :: Rule -> Int
rulePhase :: Rule -> Phase
Assert :: Name -> Hash -> Hash -> Rule
ruleName :: Rule -> Name
ruleEnable :: Rule -> Hash
ruleAssert :: Rule -> Hash
Cover :: Name -> Hash -> Hash -> Rule
ruleName :: Rule -> Name
ruleEnable :: Rule -> Hash
ruleCover :: Rule -> Hash
data StateHierarchy
StateHierarchy :: Name -> [StateHierarchy] -> StateHierarchy
StateVariable :: Name -> Const -> StateHierarchy
StateArray :: Name -> [Const] -> StateHierarchy
buildAtom :: UeMap -> Global -> Name -> Atom a -> IO (a, AtomSt)
type UID = Int

-- | A name.
type Name = String

-- | A phase is either the minimum phase or the exact phase.
data Phase
MinPhase :: Int -> Phase
ExactPhase :: Int -> Phase

-- | A hierarchical name.
type Path = [Name]

-- | A Relation is used for relative performance constraints between
--   <tt>Action</tt>s. data Relation = Higher UID | Lower UID deriving
--   (Show, Eq)
--   
--   Given a top level name and design, elaborates design and returns a
--   design database.
elaborate :: UeMap -> Name -> Atom () -> IO (Maybe (UeMap, (StateHierarchy, [Rule], [Name], [Name], [(Name, Type)])))

-- | Generic local variable declaration.
var :: Expr a => Name -> a -> Atom (V a)

-- | Generic external variable declaration.
var' :: Name -> Type -> V a

-- | Generic array declaration.
array :: Expr a => Name -> [a] -> Atom (A a)

-- | Generic external array declaration.
array' :: Expr a => Name -> Type -> A a
addName :: Name -> Atom Name
get :: Atom AtomSt
put :: AtomSt -> Atom ()

-- | All the variables that directly and indirectly control the value of an
--   expression.
allUVs :: UeMap -> [Rule] -> Hash -> [MUV]

-- | All primary expressions used in a rule.
allUEs :: Rule -> [Hash]
instance MonadIO Atom
instance Monad Atom
instance Functor Atom
instance Applicative Atom
instance Show Rule
instance Ord AtomDB
instance Eq AtomDB
instance Show AtomDB


module Language.Atom.Analysis

-- | Topologically sorts a list of expressions and subexpressions.
topo :: UeMap -> [Hash] -> [(Hash, String)]

-- | Number of UE's computed in rule.
ruleComplexity :: UeMap -> Rule -> Int


-- | Algorithms for scheduling rules in Atom
module Language.Atom.Scheduling
schedule :: [Rule] -> UeMap -> Schedule

-- | Schedule expressed as a <a>UeMap</a> and a list of (period, phase,
--   rules).
type Schedule = (UeMap, [(Int, Int, [Rule])])

-- | Generate a rule scheduling report for the given schedule.
reportSchedule :: Schedule -> String
instance Eq Usage
instance Ord Usage


-- | Definitions for the Atom EDSL itself
module Language.Atom.Language

-- | The Atom monad captures variable and transition rule declarations.
type Atom = Atom

-- | Creates a hierarchical node, where each node could be an atomic rule.
atom :: Name -> Atom a -> Atom a

-- | Defines the period of execution of sub-rules as a factor of the base
--   rate of the system. Rule period is bound by the closest period
--   assertion. For example: &gt; period 10 $ period 2 a -- Rules in
--   <tt>a</tt> have a period of 2, not 10.
period :: Int -> Atom a -> Atom a

-- | Returns the execution period of the current scope.
getPeriod :: Atom Int

-- | Defines the earliest phase within the period at which the rule should
--   execute; the scheduler attempt to find an optimal phase from 0 &lt;=
--   <tt>n</tt> &lt; period (thus, the <a>phase</a> must be at least zero
--   and less than the current <a>period</a>.).
phase :: Int -> Atom a -> Atom a

-- | Ensures an atom is scheduled only at phase <tt>n</tt>.
exactPhase :: Int -> Atom a -> Atom a

-- | Returns the phase of the current scope.
getPhase :: Atom Int

-- | Adds an enabling condition to an atom subtree of rules. This condition
--   must be true before any rules in hierarchy are allowed to execute.
cond :: E Bool -> Atom ()
class Expr a => Assign a where v <== e = do { (st, (g, atom')) <- get; let (h, st0) = newUE (ue e) st; let (muv, st1) = newUV (uv v) st0; put (st1, (g, atom' {atomAssigns = (muv, h) : atomAssigns atom'})) }
(<==) :: Assign a => V a -> E a -> Atom ()

-- | Increments a <a>NumE</a> <a>V</a>.
incr :: (Assign a, NumE a) => V a -> Atom ()

-- | Decrements a <a>NumE</a> <a>V</a>.
decr :: (Assign a, NumE a) => V a -> Atom ()

-- | Generic local variable declaration.
var :: Expr a => Name -> a -> Atom (V a)

-- | Generic external variable declaration.
var' :: Name -> Type -> V a

-- | Generic array declaration.
array :: Expr a => Name -> [a] -> Atom (A a)

-- | Generic external array declaration.
array' :: Expr a => Name -> Type -> A a

-- | Local boolean variable declaration.
bool :: Name -> Bool -> Atom (V Bool)

-- | External boolean variable declaration.
bool' :: Name -> V Bool

-- | Local int8 variable declaration.
int8 :: Name -> Int8 -> Atom (V Int8)

-- | External int8 variable declaration.
int8' :: Name -> V Int8

-- | Local int16 variable declaration.
int16 :: Name -> Int16 -> Atom (V Int16)

-- | External int16 variable declaration.
int16' :: Name -> V Int16

-- | Local int32 variable declaration.
int32 :: Name -> Int32 -> Atom (V Int32)

-- | External int32 variable declaration.
int32' :: Name -> V Int32

-- | Local int64 variable declaration.
int64 :: Name -> Int64 -> Atom (V Int64)

-- | External int64 variable declaration.
int64' :: Name -> V Int64

-- | Local word8 variable declaration.
word8 :: Name -> Word8 -> Atom (V Word8)

-- | External word8 variable declaration.
word8' :: Name -> V Word8

-- | Local word16 variable declaration.
word16 :: Name -> Word16 -> Atom (V Word16)

-- | External word16 variable declaration.
word16' :: Name -> V Word16

-- | Local word32 variable declaration.
word32 :: Name -> Word32 -> Atom (V Word32)

-- | External word32 variable declaration.
word32' :: Name -> V Word32

-- | Local word64 variable declaration.
word64 :: Name -> Word64 -> Atom (V Word64)

-- | External word64 variable declaration.
word64' :: Name -> V Word64

-- | Local float variable declaration.
float :: Name -> Float -> Atom (V Float)

-- | External float variable declaration.
float' :: Name -> V Float

-- | Local double variable declaration.
double :: Name -> Double -> Atom (V Double)

-- | External double variable declaration.
double' :: Name -> V Double

-- | Declares an action, which executes C code that is optionally passed
--   some parameters.
action :: ([String] -> String) -> [UE] -> Atom ()

-- | Calls an external C function of type 'void f(void)'.
call :: Name -> Atom ()

-- | Declares a probe. A probe allows inspecting any expression, remotely
--   to its context, at any desired rate.
probe :: Expr a => Name -> E a -> Atom ()

-- | Fetches all declared probes to current design point. The list
--   contained therein is (probe name, untyped expression). See
--   <a>printProbe</a>.
probes :: Atom [(String, UE)]

-- | An assertions checks that an 'E Bool' is true. Assertions are checked
--   between the execution of every rule. Parent enabling conditions can
--   disable assertions, but period and phase constraints do not. Assertion
--   names should be globally unique.
assert :: Name -> E Bool -> Atom ()

-- | A functional coverage point tracks if an event has occured (true).
--   Coverage points are checked at the same time as assertions. Coverage
--   names should be globally unique.
cover :: Name -> E Bool -> Atom ()

-- | Implication assertions. Creates an implicit coverage point for the
--   precondition.
assertImply :: Name -> E Bool -> E Bool -> Atom ()

-- | A name.
type Name = String

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Returns the current atom hierarchical path.
path :: Atom String

-- | Reference to the 64-bit free running clock.
clock :: E Word64

-- | Rule coverage information. (current coverage index, coverage data)
nextCoverage :: Atom (E Word32, E Word32)
instance Assign Double
instance Assign Float
instance Assign Word64
instance Assign Word32
instance Assign Word16
instance Assign Word8
instance Assign Int64
instance Assign Int32
instance Assign Int16
instance Assign Int8
instance Assign Bool


-- | Capturing data that can either be valid or invalid.
module Language.Atom.Common.ValidData

-- | <a>ValidData</a> captures the data and its validity condition.
--   <a>ValidData</a> is abstract to prevent rules from using invalid data.
data ValidData a

-- | Create <a>ValidData</a> given the data and validity condition.
validData :: a -> E Bool -> ValidData a

-- | Get a valid data. Action is disabled if data is invalid.
getValidData :: ValidData a -> Atom a

-- | Action enabled if <a>ValidData</a> is valid.
whenValid :: ValidData a -> Atom ()

-- | Action enabled if <a>ValidData</a> is not valid.
whenInvalid :: ValidData a -> Atom ()


-- | Time integrated threshold functions typically used in condition
--   monitoring.
module Language.Atom.Common.Threshold

-- | Boolean thresholding over time. Output is set when internal counter
--   hits limit, and cleared when counter is 0.
boolThreshold :: Name -> Int32 -> Bool -> E Bool -> Atom (E Bool)

-- | Integrating threshold. Output is set with integral reaches limit, and
--   cleared when integral reaches 0.
doubleThreshold :: Name -> Double -> E Double -> Atom (E Bool)


-- | Fades one signal to another.
module Language.Atom.Common.Fader

-- | Fader object.
data Fader

-- | Fader initalization.
data FaderInit

-- | Start at signal A
OnA :: FaderInit

-- | Start at signal B
OnB :: FaderInit

-- | Start at average of A and B
OnCenter :: FaderInit

-- | Fader construction
fader :: Name -> Double -> FaderInit -> E Double -> E Double -> Atom (Fader, E Double)

-- | Fade to signal A.
fadeToA :: Fader -> Atom ()

-- | Fade to signal B.
fadeToB :: Fader -> Atom ()

-- | Fade to center, i.e. average of signal A and B.
fadeToCenter :: Fader -> Atom ()


-- | Common Atom functions
module Language.Atom.Common

-- | A Timer.
data Timer

-- | Creates a new timer.
timer :: Name -> Atom Timer

-- | Starts a Timer. A timer can be restarted at any time.
startTimer :: Timer -> E Word64 -> Atom ()

-- | Conditionally start a Timer.
startTimerIf :: Timer -> E Bool -> E Word64 -> Atom ()

-- | <a>True</a> when a timer has completed. Note that this remains
--   <a>True</a> until the timer is restarted.
timerDone :: Timer -> E Bool

-- | One-shot on a rising transition.
oneShotRise :: E Bool -> Atom (E Bool)

-- | One-shot on a falling transition.
oneShotFall :: E Bool -> Atom (E Bool)

-- | Debounces a boolean given an on and off time (ticks) and an initial
--   state.
debounce :: Name -> E Word64 -> E Word64 -> Bool -> E Bool -> Atom (E Bool)

-- | 1-D lookup table. <tt>x</tt> values out of table range are clipped at
--   end <tt>y</tt> values. Input table must be monotonically increasing in
--   <tt>x</tt>.
lookupTable :: FloatingE a => [(E a, E a)] -> E a -> E a

-- | Linear extrapolation and interpolation on a line with 2 points. The
--   two <tt>x</tt> points must be different to prevent a divide-by-zero.
linear :: FloatingE a => (E a, E a) -> (E a, E a) -> E a -> E a

-- | Hysteresis returns <a>True</a> when the input exceeds <tt>max</tt> and
--   <a>False</a> when the input is less than <tt>min</tt>. The state is
--   held when the input is between <tt>min</tt> and <tt>max</tt>.
hysteresis :: OrdE a => E a -> E a -> E a -> Atom (E Bool)

-- | A channel is a uni-directional communication link that ensures one
--   read for every write.
data Channel a
Channel :: a -> (V Bool) -> Channel a

-- | Creates a new channel, with a given name and data.
channel :: a -> Atom (Channel a)

-- | Write data to a <a>Channel</a>. A write will only suceed if the
--   <a>Channel</a> is empty.
writeChannel :: Channel a -> Atom ()

-- | Read data from a <a>Channel</a>. A read will only suceed if the
--   <a>Channel</a> has data to be read.
readChannel :: Channel a -> Atom a


-- | Atom C code configuration and generation
module Language.Atom.Code

-- | C code configuration parameters.
data Config
Config :: String -> String -> ([Name] -> [Name] -> [(Name, Type)] -> (String, String)) -> ([Name] -> [Name] -> [(Name, Type)] -> (String, String)) -> Bool -> Bool -> String -> String -> Maybe Clock -> Config

-- | Alternative primary function name. If this is empty, then it will
--   default to the name passed to <a>compile</a>.
cFuncName :: Config -> String

-- | Name of state variable structure. Default: <tt>state</tt>
cStateName :: Config -> String

-- | Custom C code to insert above and below the functions, given assertion
--   names, coverage names, and probe names and types.
cCode :: Config -> [Name] -> [Name] -> [(Name, Type)] -> (String, String)

-- | Custom C code to insert above and below the state definition in the
--   header file, given assertion names, coverage names, and probe names
--   and types.
hCode :: Config -> [Name] -> [Name] -> [(Name, Type)] -> (String, String)

-- | Enable rule coverage tracking.
cRuleCoverage :: Config -> Bool

-- | Enable assertions and functional coverage.
cAssert :: Config -> Bool

-- | Name of assertion function. Prototype: <tt>void assert(int, bool,
--   uint64_t);</tt>
cAssertName :: Config -> String

-- | Name of coverage function. Prototype: <tt>void cover(int, bool,
--   uint64_t);</tt>
cCoverName :: Config -> String

-- | Hardware counter to schedule rules, or <a>Nothing</a> (the default).
hardwareClock :: Config -> Maybe Clock

-- | Data associated with sampling a hardware clock. For the clock to work
--   correctly, you MUST assign <tt>__global_clock</tt> the current time
--   (according to <tt>clockName</tt>) the first time you enter the main
--   Atom-generated function calling your rules.
data Clock
Clock :: String -> Type -> Integer -> String -> Maybe String -> Clock

-- | C function to sample the clock. The function is assumed to have the
--   prototype: <tt>clockType clockName(void)</tt>.
clockName :: Clock -> String

-- | Clock type. Assumed to be one of <a>Word8</a>, <a>Word16</a>,
--   <a>Word32</a>, or <a>Word64</a>. It is permissible for the clock to
--   roll over.
clockType :: Clock -> Type

-- | Number of ticks in a phase. Must be greater than 0.
delta :: Clock -> Integer

-- | C function to delay/sleep. The function is assumed to have the
--   prototype: <tt>void delay(clockType i)</tt>, where <tt>i</tt> is the
--   duration of delay/sleep.
delay :: Clock -> String

-- | <a>Nothing</a>, or a user-defined error-reporting function if the
--   period duration is violated, e.g., the execution time was greater than
--   <tt>delta</tt>. Assumed to have prototype: <tt>void err(void)</tt>.
err :: Clock -> Maybe String
writeC :: Name -> Config -> StateHierarchy -> [Rule] -> Schedule -> [Name] -> [Name] -> [(Name, Type)] -> IO RuleCoverage

-- | Default C code configuration parameters (default function name, no
--   pre/post code, ANSI C types).
defaults :: Config

-- | Default hardware clock parameters (name "<tt>clk</tt>", Word64, delta
--   1, delay function is "<tt>delay</tt>", no error function).
defaultClock :: Clock

-- | C99 type naming rules.
cType :: Type -> String
type RuleCoverage = [(Name, Int, Int)]


-- | Atom compilation functions
module Language.Atom.Compile

-- | Compiles an atom description to C.
compile :: Name -> Config -> Atom () -> IO (Schedule, RuleCoverage, [Name], [Name], [(Name, Type)])

-- | Generate a rule scheduling report for the given schedule.
reportSchedule :: Schedule -> String

-- | Schedule expressed as a <a>UeMap</a> and a list of (period, phase,
--   rules).
type Schedule = (UeMap, [(Int, Int, [Rule])])


-- | Unit testing, coverage, reporting &amp; debugging for Atom
module Language.Atom.Unit

-- | Parameters for a test simulation
data Test
Test :: String -> Int -> Atom () -> [FilePath] -> [FilePath] -> String -> String -> String -> String -> Test

-- | Name for test (used in log file, state name, and output)
name :: Test -> String

-- | Number of simulation cycles to run
cycles :: Test -> Int

-- | Atom specification to test
testbench :: Test -> Atom ()

-- | Other C files to build in
modules :: Test -> [FilePath]

-- | Other C headers to include
includes :: Test -> [FilePath]

-- | C declarations and definitions inserted prior to the <tt>main</tt>
--   function
declCode :: Test -> String

-- | C code executed inside the <tt>main</tt> function, prior to
--   <a>loopCode</a>
initCode :: Test -> String

-- | C code executed inside the loop running the test
loopCode :: Test -> String

-- | C code executed after that loop, but still in <tt>main</tt>
endCode :: Test -> String

-- | Default test parameters
defaultTest :: Test
class Expr a => Random a
random :: Random a => E a

-- | Run a list of tests, output a report on test passes and coverage.
runTests :: Int -> [IO Test] -> IO ()

-- | Print a string in C using <tt>printf</tt>, appending a newline.
printStrLn :: String -> Atom ()

-- | Print an integral value in C using <tt>printf</tt>.
printIntegralE :: IntegralE a => String -> E a -> Atom ()

-- | Print a floating point value in C using <tt>printf</tt>.
printFloatingE :: FloatingE a => String -> E a -> Atom ()

-- | Print the value of a probe to the console (along with its name).
printProbe :: (String, UE) -> Atom ()
instance Random Int64
instance Random Int32
instance Random Int16
instance Random Int8
instance Random Word64
instance Random Word32
instance Random Word16
instance Random Word8
instance Random Bool


-- | Atom is a Haskell DSL for designing hard realtime embedded software.
--   
--   Based on guarded atomic actions (similar to STM), Atom enables highly
--   concurrent programming without the need for mutex locking. In
--   addition, Atom performs compile-time task scheduling and generates
--   code with deterministic execution time and constant memory use,
--   simplifying the process of timing verification and memory consumption
--   in hard realtime applications. Without mutex locking and run-time task
--   scheduling, Atom eliminates the need and overhead of RTOSes for many
--   embedded applications.
module Language.Atom

-- | C code configuration parameters.
data Config
Config :: String -> String -> ([Name] -> [Name] -> [(Name, Type)] -> (String, String)) -> ([Name] -> [Name] -> [(Name, Type)] -> (String, String)) -> Bool -> Bool -> String -> String -> Maybe Clock -> Config

-- | Alternative primary function name. If this is empty, then it will
--   default to the name passed to <a>compile</a>.
cFuncName :: Config -> String

-- | Name of state variable structure. Default: <tt>state</tt>
cStateName :: Config -> String

-- | Custom C code to insert above and below the functions, given assertion
--   names, coverage names, and probe names and types.
cCode :: Config -> [Name] -> [Name] -> [(Name, Type)] -> (String, String)

-- | Custom C code to insert above and below the state definition in the
--   header file, given assertion names, coverage names, and probe names
--   and types.
hCode :: Config -> [Name] -> [Name] -> [(Name, Type)] -> (String, String)

-- | Enable rule coverage tracking.
cRuleCoverage :: Config -> Bool

-- | Enable assertions and functional coverage.
cAssert :: Config -> Bool

-- | Name of assertion function. Prototype: <tt>void assert(int, bool,
--   uint64_t);</tt>
cAssertName :: Config -> String

-- | Name of coverage function. Prototype: <tt>void cover(int, bool,
--   uint64_t);</tt>
cCoverName :: Config -> String

-- | Hardware counter to schedule rules, or <a>Nothing</a> (the default).
hardwareClock :: Config -> Maybe Clock

-- | Default C code configuration parameters (default function name, no
--   pre/post code, ANSI C types).
defaults :: Config

-- | Data associated with sampling a hardware clock. For the clock to work
--   correctly, you MUST assign <tt>__global_clock</tt> the current time
--   (according to <tt>clockName</tt>) the first time you enter the main
--   Atom-generated function calling your rules.
data Clock
Clock :: String -> Type -> Integer -> String -> Maybe String -> Clock

-- | C function to sample the clock. The function is assumed to have the
--   prototype: <tt>clockType clockName(void)</tt>.
clockName :: Clock -> String

-- | Clock type. Assumed to be one of <a>Word8</a>, <a>Word16</a>,
--   <a>Word32</a>, or <a>Word64</a>. It is permissible for the clock to
--   roll over.
clockType :: Clock -> Type

-- | Number of ticks in a phase. Must be greater than 0.
delta :: Clock -> Integer

-- | C function to delay/sleep. The function is assumed to have the
--   prototype: <tt>void delay(clockType i)</tt>, where <tt>i</tt> is the
--   duration of delay/sleep.
delay :: Clock -> String

-- | <a>Nothing</a>, or a user-defined error-reporting function if the
--   period duration is violated, e.g., the execution time was greater than
--   <tt>delta</tt>. Assumed to have prototype: <tt>void err(void)</tt>.
err :: Clock -> Maybe String

-- | Default hardware clock parameters (name "<tt>clk</tt>", Word64, delta
--   1, delay function is "<tt>delay</tt>", no error function).
defaultClock :: Clock
writeC :: Name -> Config -> StateHierarchy -> [Rule] -> Schedule -> [Name] -> [Name] -> [(Name, Type)] -> IO RuleCoverage

-- | C99 type naming rules.
cType :: Type -> String
type RuleCoverage = [(Name, Int, Int)]

-- | Compiles an atom description to C.
compile :: Name -> Config -> Atom () -> IO (Schedule, RuleCoverage, [Name], [Name], [(Name, Type)])

-- | Generate a rule scheduling report for the given schedule.
reportSchedule :: Schedule -> String

-- | Schedule expressed as a <a>UeMap</a> and a list of (period, phase,
--   rules).
type Schedule = (UeMap, [(Int, Int, [Rule])])

-- | A Timer.
data Timer

-- | Creates a new timer.
timer :: Name -> Atom Timer

-- | Starts a Timer. A timer can be restarted at any time.
startTimer :: Timer -> E Word64 -> Atom ()

-- | Conditionally start a Timer.
startTimerIf :: Timer -> E Bool -> E Word64 -> Atom ()

-- | <a>True</a> when a timer has completed. Note that this remains
--   <a>True</a> until the timer is restarted.
timerDone :: Timer -> E Bool

-- | One-shot on a rising transition.
oneShotRise :: E Bool -> Atom (E Bool)

-- | One-shot on a falling transition.
oneShotFall :: E Bool -> Atom (E Bool)

-- | Debounces a boolean given an on and off time (ticks) and an initial
--   state.
debounce :: Name -> E Word64 -> E Word64 -> Bool -> E Bool -> Atom (E Bool)

-- | 1-D lookup table. <tt>x</tt> values out of table range are clipped at
--   end <tt>y</tt> values. Input table must be monotonically increasing in
--   <tt>x</tt>.
lookupTable :: FloatingE a => [(E a, E a)] -> E a -> E a

-- | Linear extrapolation and interpolation on a line with 2 points. The
--   two <tt>x</tt> points must be different to prevent a divide-by-zero.
linear :: FloatingE a => (E a, E a) -> (E a, E a) -> E a -> E a

-- | Hysteresis returns <a>True</a> when the input exceeds <tt>max</tt> and
--   <a>False</a> when the input is less than <tt>min</tt>. The state is
--   held when the input is between <tt>min</tt> and <tt>max</tt>.
hysteresis :: OrdE a => E a -> E a -> E a -> Atom (E Bool)

-- | A channel is a uni-directional communication link that ensures one
--   read for every write.
data Channel a
Channel :: a -> (V Bool) -> Channel a

-- | Creates a new channel, with a given name and data.
channel :: a -> Atom (Channel a)

-- | Write data to a <a>Channel</a>. A write will only suceed if the
--   <a>Channel</a> is empty.
writeChannel :: Channel a -> Atom ()

-- | Read data from a <a>Channel</a>. A read will only suceed if the
--   <a>Channel</a> has data to be read.
readChannel :: Channel a -> Atom a

-- | Fader object.
data Fader

-- | Fader initalization.
data FaderInit

-- | Start at signal A
OnA :: FaderInit

-- | Start at signal B
OnB :: FaderInit

-- | Start at average of A and B
OnCenter :: FaderInit

-- | Fader construction
fader :: Name -> Double -> FaderInit -> E Double -> E Double -> Atom (Fader, E Double)

-- | Fade to signal A.
fadeToA :: Fader -> Atom ()

-- | Fade to signal B.
fadeToB :: Fader -> Atom ()

-- | Fade to center, i.e. average of signal A and B.
fadeToCenter :: Fader -> Atom ()

-- | Boolean thresholding over time. Output is set when internal counter
--   hits limit, and cleared when counter is 0.
boolThreshold :: Name -> Int32 -> Bool -> E Bool -> Atom (E Bool)

-- | Integrating threshold. Output is set with integral reaches limit, and
--   cleared when integral reaches 0.
doubleThreshold :: Name -> Double -> E Double -> Atom (E Bool)

-- | <a>ValidData</a> captures the data and its validity condition.
--   <a>ValidData</a> is abstract to prevent rules from using invalid data.
data ValidData a

-- | Create <a>ValidData</a> given the data and validity condition.
validData :: a -> E Bool -> ValidData a

-- | Get a valid data. Action is disabled if data is invalid.
getValidData :: ValidData a -> Atom a

-- | Action enabled if <a>ValidData</a> is valid.
whenValid :: ValidData a -> Atom ()

-- | Action enabled if <a>ValidData</a> is not valid.
whenInvalid :: ValidData a -> Atom ()

-- | The Atom monad captures variable and transition rule declarations.
type Atom = Atom

-- | Creates a hierarchical node, where each node could be an atomic rule.
atom :: Name -> Atom a -> Atom a

-- | Defines the period of execution of sub-rules as a factor of the base
--   rate of the system. Rule period is bound by the closest period
--   assertion. For example: &gt; period 10 $ period 2 a -- Rules in
--   <tt>a</tt> have a period of 2, not 10.
period :: Int -> Atom a -> Atom a

-- | Returns the execution period of the current scope.
getPeriod :: Atom Int

-- | Defines the earliest phase within the period at which the rule should
--   execute; the scheduler attempt to find an optimal phase from 0 &lt;=
--   <tt>n</tt> &lt; period (thus, the <a>phase</a> must be at least zero
--   and less than the current <a>period</a>.).
phase :: Int -> Atom a -> Atom a

-- | Ensures an atom is scheduled only at phase <tt>n</tt>.
exactPhase :: Int -> Atom a -> Atom a

-- | Returns the phase of the current scope.
getPhase :: Atom Int

-- | Adds an enabling condition to an atom subtree of rules. This condition
--   must be true before any rules in hierarchy are allowed to execute.
cond :: E Bool -> Atom ()
class Expr a => Assign a where v <== e = do { (st, (g, atom')) <- get; let (h, st0) = newUE (ue e) st; let (muv, st1) = newUV (uv v) st0; put (st1, (g, atom' {atomAssigns = (muv, h) : atomAssigns atom'})) }
(<==) :: Assign a => V a -> E a -> Atom ()

-- | Increments a <a>NumE</a> <a>V</a>.
incr :: (Assign a, NumE a) => V a -> Atom ()

-- | Decrements a <a>NumE</a> <a>V</a>.
decr :: (Assign a, NumE a) => V a -> Atom ()

-- | Generic local variable declaration.
var :: Expr a => Name -> a -> Atom (V a)

-- | Generic external variable declaration.
var' :: Name -> Type -> V a

-- | Generic array declaration.
array :: Expr a => Name -> [a] -> Atom (A a)

-- | Generic external array declaration.
array' :: Expr a => Name -> Type -> A a

-- | Local boolean variable declaration.
bool :: Name -> Bool -> Atom (V Bool)

-- | External boolean variable declaration.
bool' :: Name -> V Bool

-- | Local int8 variable declaration.
int8 :: Name -> Int8 -> Atom (V Int8)

-- | External int8 variable declaration.
int8' :: Name -> V Int8

-- | Local int16 variable declaration.
int16 :: Name -> Int16 -> Atom (V Int16)

-- | External int16 variable declaration.
int16' :: Name -> V Int16

-- | Local int32 variable declaration.
int32 :: Name -> Int32 -> Atom (V Int32)

-- | External int32 variable declaration.
int32' :: Name -> V Int32

-- | Local int64 variable declaration.
int64 :: Name -> Int64 -> Atom (V Int64)

-- | External int64 variable declaration.
int64' :: Name -> V Int64

-- | Local word8 variable declaration.
word8 :: Name -> Word8 -> Atom (V Word8)

-- | External word8 variable declaration.
word8' :: Name -> V Word8

-- | Local word16 variable declaration.
word16 :: Name -> Word16 -> Atom (V Word16)

-- | External word16 variable declaration.
word16' :: Name -> V Word16

-- | Local word32 variable declaration.
word32 :: Name -> Word32 -> Atom (V Word32)

-- | External word32 variable declaration.
word32' :: Name -> V Word32

-- | Local word64 variable declaration.
word64 :: Name -> Word64 -> Atom (V Word64)

-- | External word64 variable declaration.
word64' :: Name -> V Word64

-- | Local float variable declaration.
float :: Name -> Float -> Atom (V Float)

-- | External float variable declaration.
float' :: Name -> V Float

-- | Local double variable declaration.
double :: Name -> Double -> Atom (V Double)

-- | External double variable declaration.
double' :: Name -> V Double

-- | Declares an action, which executes C code that is optionally passed
--   some parameters.
action :: ([String] -> String) -> [UE] -> Atom ()

-- | Calls an external C function of type 'void f(void)'.
call :: Name -> Atom ()

-- | Declares a probe. A probe allows inspecting any expression, remotely
--   to its context, at any desired rate.
probe :: Expr a => Name -> E a -> Atom ()

-- | Fetches all declared probes to current design point. The list
--   contained therein is (probe name, untyped expression). See
--   <a>printProbe</a>.
probes :: Atom [(String, UE)]

-- | An assertions checks that an 'E Bool' is true. Assertions are checked
--   between the execution of every rule. Parent enabling conditions can
--   disable assertions, but period and phase constraints do not. Assertion
--   names should be globally unique.
assert :: Name -> E Bool -> Atom ()

-- | A functional coverage point tracks if an event has occured (true).
--   Coverage points are checked at the same time as assertions. Coverage
--   names should be globally unique.
cover :: Name -> E Bool -> Atom ()

-- | Implication assertions. Creates an implicit coverage point for the
--   precondition.
assertImply :: Name -> E Bool -> E Bool -> Atom ()

-- | A name.
type Name = String

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Returns the current atom hierarchical path.
path :: Atom String

-- | Reference to the 64-bit free running clock.
clock :: E Word64

-- | Rule coverage information. (current coverage index, coverage data)
nextCoverage :: Atom (E Word32, E Word32)

-- | A typed expression.
data E a
VRef :: V a -> E a
Const :: a -> E a
Cast :: E a -> E b
Add :: E a -> E a -> E a
Sub :: E a -> E a -> E a
Mul :: E a -> E a -> E a
Div :: E a -> E a -> E a
Mod :: E a -> E a -> E a
Not :: E Bool -> E Bool
And :: E Bool -> E Bool -> E Bool
BWNot :: E a -> E a
BWAnd :: E a -> E a -> E a
BWOr :: E a -> E a -> E a
BWXor :: E a -> E a -> E a
BWShiftL :: E a -> E b -> E a
BWShiftR :: E a -> E b -> E a
Eq :: E a -> E a -> E Bool
Lt :: E a -> E a -> E Bool
Mux :: E Bool -> E a -> E a -> E a
F2B :: E Float -> E Word32
D2B :: E Double -> E Word64
B2F :: E Word32 -> E Float
B2D :: E Word64 -> E Double
Retype :: UE -> E a
Pi :: E a
Exp :: E a -> E a
Log :: E a -> E a
Sqrt :: E a -> E a
Pow :: E a -> E a -> E a
Sin :: E a -> E a
Asin :: E a -> E a
Cos :: E a -> E a
Acos :: E a -> E a
Sinh :: E a -> E a
Cosh :: E a -> E a
Asinh :: E a -> E a
Acosh :: E a -> E a
Atan :: E a -> E a
Atanh :: E a -> E a

-- | Variables updated by state transition rules.
data V a
V :: UV -> V a

-- | An untyped term.
data UE
UVRef :: UV -> UE
UConst :: Const -> UE
UCast :: Type -> UE -> UE
UAdd :: UE -> UE -> UE
USub :: UE -> UE -> UE
UMul :: UE -> UE -> UE
UDiv :: UE -> UE -> UE
UMod :: UE -> UE -> UE
UNot :: UE -> UE
UAnd :: [UE] -> UE
UBWNot :: UE -> UE
UBWAnd :: UE -> UE -> UE
UBWOr :: UE -> UE -> UE
UBWXor :: UE -> UE -> UE
UBWShiftL :: UE -> UE -> UE
UBWShiftR :: UE -> UE -> UE
UEq :: UE -> UE -> UE
ULt :: UE -> UE -> UE
UMux :: UE -> UE -> UE -> UE
UF2B :: UE -> UE
UD2B :: UE -> UE
UB2F :: UE -> UE
UB2D :: UE -> UE
UPi :: UE
UExp :: UE -> UE
ULog :: UE -> UE
USqrt :: UE -> UE
UPow :: UE -> UE -> UE
USin :: UE -> UE
UAsin :: UE -> UE
UCos :: UE -> UE
UAcos :: UE -> UE
USinh :: UE -> UE
UCosh :: UE -> UE
UAsinh :: UE -> UE
UAcosh :: UE -> UE
UAtan :: UE -> UE
UAtanh :: UE -> UE

-- | Untyped variables.
data UV
UV :: Int -> String -> Const -> UV
UVArray :: UA -> UE -> UV
UVExtern :: String -> Type -> UV

-- | A typed array.
data A a
A :: UA -> A a

-- | An untyped array.
data UA
UA :: Int -> String -> [Const] -> UA
UAExtern :: String -> Type -> UA

-- | Typed expression:
class Eq a => Expr a
eType :: Expr a => E a -> Type
constant :: Expr a => a -> Const
expression :: Expr a => E a -> Expression
variable :: Expr a => V a -> Variable
rawBits :: Expr a => E a -> E Word64

-- | Typed expression
data Expression
EBool :: (E Bool) -> Expression
EInt8 :: (E Int8) -> Expression
EInt16 :: (E Int16) -> Expression
EInt32 :: (E Int32) -> Expression
EInt64 :: (E Int64) -> Expression
EWord8 :: (E Word8) -> Expression
EWord16 :: (E Word16) -> Expression
EWord32 :: (E Word32) -> Expression
EWord64 :: (E Word64) -> Expression
EFloat :: (E Float) -> Expression
EDouble :: (E Double) -> Expression

-- | Typed variable
data Variable
VBool :: (V Bool) -> Variable
VInt8 :: (V Int8) -> Variable
VInt16 :: (V Int16) -> Variable
VInt32 :: (V Int32) -> Variable
VInt64 :: (V Int64) -> Variable
VWord8 :: (V Word8) -> Variable
VWord16 :: (V Word16) -> Variable
VWord32 :: (V Word32) -> Variable
VWord64 :: (V Word64) -> Variable
VFloat :: (V Float) -> Variable
VDouble :: (V Double) -> Variable

-- | The type of a <a>E</a>.
data Type
Bool :: Type
Int8 :: Type
Int16 :: Type
Int32 :: Type
Int64 :: Type
Word8 :: Type
Word16 :: Type
Word32 :: Type
Word64 :: Type
Float :: Type
Double :: Type

-- | Typed constant
data Const
CBool :: Bool -> Const
CInt8 :: Int8 -> Const
CInt16 :: Int16 -> Const
CInt32 :: Int32 -> Const
CInt64 :: Int64 -> Const
CWord8 :: Word8 -> Const
CWord16 :: Word16 -> Const
CWord32 :: Word32 -> Const
CWord64 :: Word64 -> Const
CFloat :: Float -> Const
CDouble :: Double -> Const

-- | Types with a defined width in bits
class Width a
width :: Width a => a -> Int

-- | Types which have a defined <a>Type</a>
class TypeOf a
typeOf :: TypeOf a => a -> Type

-- | The number of bytes that an object occupies
bytes :: Width a => a -> Int

-- | Converts an typed expression (E a) to an untyped expression (UE).
ue :: Expr a => E a -> UE

-- | Convert a typed variable to an untyped one
uv :: V a -> UV

-- | Expression of numerical type
class (Num a, Expr a, EqE a, OrdE a) => NumE a

-- | Expression of integral type
class (NumE a, Integral a) => IntegralE a

-- | Floating-point typed expression
class (RealFloat a, NumE a, OrdE a) => FloatingE a

-- | Expressions which can be compared for equality
class (Eq a, Expr a) => EqE a

-- | Expressions which can be ordered
class (Eq a, Ord a, EqE a) => OrdE a

-- | True term.
true :: E Bool

-- | False term.
false :: E Bool

-- | Returns the value of a <a>V</a>.
value :: V a -> E a

-- | Logical negation.
not_ :: E Bool -> E Bool

-- | Logical AND.
(&&.) :: E Bool -> E Bool -> E Bool

-- | Logical OR.
(||.) :: E Bool -> E Bool -> E Bool

-- | The conjunction of a E Bool list.
and_ :: [E Bool] -> E Bool

-- | The disjunction of a E Bool list.
or_ :: [E Bool] -> E Bool

-- | True iff the predicate is true for any element.
any_ :: (a -> E Bool) -> [a] -> E Bool

-- | True iff the predicate is true for all elements.
all_ :: (a -> E Bool) -> [a] -> E Bool

-- | Logical implication (if a then b).
imply :: E Bool -> E Bool -> E Bool

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Bitwise left-shifting.
(.<<.) :: (Bits a, IntegralE a, IntegralE n) => E a -> E n -> E a

-- | Bitwise right-shifting.
(.>>.) :: (Bits a, IntegralE a, IntegralE n) => E a -> E n -> E a

-- | Bitwise left-rotation.
rol :: (IntegralE a, IntegralE n, Bits a) => E a -> E n -> E a

-- | Bitwise right-rotation.
ror :: (IntegralE a, IntegralE n, Bits a) => E a -> E n -> E a

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Equal.
(==.) :: EqE a => E a -> E a -> E Bool

-- | Not equal.
(/=.) :: EqE a => E a -> E a -> E Bool

-- | Less than.
(<.) :: OrdE a => E a -> E a -> E Bool

-- | Less than or equal.
(<=.) :: OrdE a => E a -> E a -> E Bool

-- | Greater than.
(>.) :: OrdE a => E a -> E a -> E Bool

-- | Greater than or equal.
(>=.) :: OrdE a => E a -> E a -> E Bool

-- | Returns the minimum of two numbers.
min_ :: OrdE a => E a -> E a -> E a

-- | Returns the minimum of a list of numbers.
minimum_ :: OrdE a => [E a] -> E a

-- | Returns the maximum of two numbers.
max_ :: OrdE a => E a -> E a -> E a

-- | Returns the maximum of a list of numbers.
maximum_ :: OrdE a => [E a] -> E a

-- | Limits between min and max.
limit :: OrdE a => E a -> E a -> E a -> E a

-- | Division. If both the dividend and divisor are constants, a
--   compile-time check is made for divide-by-zero. Otherwise, if the
--   divisor ever evaluates to <tt>0</tt>, a runtime exception will occur,
--   even if the division occurs within the scope of a <tt>cond</tt> or
--   <a>mux</a> that tests for <tt>0</tt> (because Atom generates
--   deterministic-time code, every branch of a <tt>cond</tt> or <a>mux</a>
--   is executed).
div_ :: IntegralE a => E a -> E a -> E a

-- | Division, where the C code is instrumented with a runtime check to
--   ensure the divisor does not equal <tt>0</tt>. If it is equal to
--   <tt>0</tt>, the 3rd argument is a user-supplied non-zero divsor.
div0_ :: IntegralE a => E a -> E a -> a -> E a

-- | Modulo. If both the dividend and modulus are constants, a compile-time
--   check is made for divide-by-zero. Otherwise, if the modulus ever
--   evaluates to <tt>0</tt>, a runtime exception will occur, even if the
--   division occurs within the scope of a <tt>cond</tt> or <a>mux</a> that
--   tests for <tt>0</tt> (because Atom generates deterministic-time code,
--   every branch of a <tt>cond</tt> or <a>mux</a> is executed).
mod_ :: IntegralE a => E a -> E a -> E a

-- | Modulus, where the C code is instrumented with a runtime check to
--   ensure the modulus does not equal <tt>0</tt>. If it is equal to
--   <tt>0</tt>, the 3rd argument is a user-supplied non-zero divsor.
mod0_ :: IntegralE a => E a -> E a -> a -> E a

-- | Conditional expression. Note, both branches are evaluated!
--   
--   <pre>
--   mux test onTrue onFalse
--   </pre>
mux :: Expr a => E Bool -> E a -> E a -> E a

-- | Array index to variable.
(!) :: (Expr a, IntegralE b) => A a -> E b -> V a

-- | Array index to expression.
(!.) :: (Expr a, IntegralE b) => A a -> E b -> E a

-- | Produced an untyped expression from a constant <a>Bool</a>
ubool :: Bool -> UE

-- | Logical NOT of an untyped expression
unot :: UE -> UE

-- | Logical AND of two untyped expressions
uand :: UE -> UE -> UE

-- | Logical OR of two untyped expressions
uor :: UE -> UE -> UE

-- | Check equality on two untyped expressions
ueq :: UE -> UE -> UE

-- | 2-to-1 multiplexer. If selector is true, this returns input 1; if
--   selector is false, this returns input 2.
umux :: UE -> UE -> UE -> UE

-- | Parameters for a test simulation
data Test
Test :: String -> Int -> Atom () -> [FilePath] -> [FilePath] -> String -> String -> String -> String -> Test

-- | Name for test (used in log file, state name, and output)
name :: Test -> String

-- | Number of simulation cycles to run
cycles :: Test -> Int

-- | Atom specification to test
testbench :: Test -> Atom ()

-- | Other C files to build in
modules :: Test -> [FilePath]

-- | Other C headers to include
includes :: Test -> [FilePath]

-- | C declarations and definitions inserted prior to the <tt>main</tt>
--   function
declCode :: Test -> String

-- | C code executed inside the <tt>main</tt> function, prior to
--   <a>loopCode</a>
initCode :: Test -> String

-- | C code executed inside the loop running the test
loopCode :: Test -> String

-- | C code executed after that loop, but still in <tt>main</tt>
endCode :: Test -> String

-- | Default test parameters
defaultTest :: Test
class Expr a => Random a
random :: Random a => E a

-- | Run a list of tests, output a report on test passes and coverage.
runTests :: Int -> [IO Test] -> IO ()

-- | Print a string in C using <tt>printf</tt>, appending a newline.
printStrLn :: String -> Atom ()

-- | Print an integral value in C using <tt>printf</tt>.
printIntegralE :: IntegralE a => String -> E a -> Atom ()

-- | Print a floating point value in C using <tt>printf</tt>.
printFloatingE :: FloatingE a => String -> E a -> Atom ()

-- | Print the value of a probe to the console (along with its name).
printProbe :: (String, UE) -> Atom ()


-- | This demonstrates the use of <a>word16'</a> to reference an external
--   variable, and the use of <a>call</a> to call an external function.
module Language.Atom.Example.External

-- | Invoke the Atom compiler
main :: IO ()

-- | Top-level rule
extern :: Atom ()
prePostCode :: [Name] -> [Name] -> [(Name, Type)] -> (String, String)


module Language.Atom.Example.Gcd

-- | Invoke the Atom compiler
compileExample :: IO ()

-- | An example design that computes the greatest common divisor.
example :: Atom ()


-- | This demonstrates the usage of Atom's probe functionality. In this
--   case, it simply uses <tt>printf</tt> to log a probe's value. Most
--   POSIX systems should be able to build and run the generated C code.
module Language.Atom.Example.Probes

-- | Invoke the Atom compiler
main :: IO ()

-- | Generate a code comment about the given probe.
probeStr :: (Name, Type) -> String

-- | Use <a>action</a> to call <tt>PROBE_PRINTF</tt> on a probe given as
--   (name, value). This will work only on integer-valued probes.
logProbe :: (String, UE) -> Atom ()

-- | Top-level rule
example :: Atom ()
prePostCode :: [Name] -> [Name] -> [(Name, Type)] -> (String, String)

-- | Count up seconds of runtime, assuming our base rate is 1 millisecond:
tickSecond :: Atom (V Word64)
