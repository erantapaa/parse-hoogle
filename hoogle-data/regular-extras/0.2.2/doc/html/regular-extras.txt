-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Additional functions for regular: arbitrary,
coarbitrary, and binary get/put.
--   
--   Additional functions for the regular [1] generic programming library,
--   such as arbitrary, coarbitrary, and binary get/put. These are not
--   bundled with the library because they introduce dependencies on
--   additional packages.
--   
--   [1] <a>http://hackage.haskell.org/package/regular</a>
@package regular-extras
@version 0.2.2


-- | Summary: Deep generic seq. Used to fully evaluate a term.
module Generics.Regular.Functions.Seq

-- | The class for generic deep seq.
class Seq f
gseq :: Seq f => (a -> b -> b) -> f a -> b -> b

-- | Deep, generic version of seq.
gdseq :: (Regular a, Seq (PF a)) => a -> b -> b
instance Seq f => Seq (S s f)
instance Seq f => Seq (C c f)
instance (Seq f, Seq g) => Seq (f :*: g)
instance (Seq f, Seq g) => Seq (f :+: g)
instance Seq U
instance NFData a => Seq (K a)
instance Seq I


-- | Generic Data.Binary instances.
--   
--   These generic functions can be used to create a <a>Data.Binary</a>
--   instance. For example, for a user-defined type <tt>MyType</tt>, the
--   following code is necessary:
--   
--   <pre>
--   import Data.Binary
--   import Generics.Regular.Base
--   import Generics.Regular.Binary
--   
--   data MyType = ...
--   
--   $(deriveAll ''MyType "PFMyType")
--   type instance PF MyType = PFMyType
--   
--   instance Binary MyType where
--     put = gput
--     get = gget
--   </pre>
module Generics.Regular.Functions.Binary
class Binary f

-- | Generic binary <tt>put</tt> to be used with <a>Data.Binary.Put</a>.
gput :: (Regular a, Binary (PF a)) => a -> Put

-- | Generic binary <tt>get</tt> to be used with <a>Data.Binary.Get</a>.
gget :: (Regular a, Binary (PF a)) => Get a
instance Binary f => Binary (S s f)
instance Binary f => Binary (C c f)
instance (Binary f, Binary g) => Binary (f :*: g)
instance (Binary f, Binary g) => Binary (f :+: g)
instance Binary U
instance Binary a => Binary (K a)
instance Binary I


-- | Summary: Generic <a>Test.QuickCheck</a> instances.
module Generics.Regular.Functions.Arbitrary

-- | A frequency table detailing how often certain constructors should be
--   picked. The <a>String</a> corresponds to the constructor name, as
--   returned by <a>conNames</a>.
type FrequencyTable = [(String, Int)]

-- | Generic Arbitrary class
class Arbitrary f
harbitrary :: Arbitrary f => (Int -> Gen a) -> FrequencyTable -> Int -> Int -> Maybe (Gen (f a))

-- | Generic arbitrary function, sized and with custom constructor
--   frequencies.
arbitraryWith :: (Regular a, Arbitrary (PF a)) => FrequencyTable -> Int -> Gen a

-- | Generic arbitrary function with default sizes and constructor
--   frequencies.
arbitrary :: (Regular a, Arbitrary (PF a)) => Gen a

-- | Generic CoArbitrary class
class CoArbitrary f
hcoarbitrary :: CoArbitrary f => (b -> Gen a -> Gen a) -> Int -> f b -> Gen a -> Gen a

-- | Generic coarbitrary function.
corbitrary :: (Regular b, CoArbitrary (PF b)) => b -> Gen a -> Gen a
instance [overlap ok] (CoArbitrary f, CoArbitrary g) => CoArbitrary (f :*: g)
instance [overlap ok] CoArbitrary a => CoArbitrary (K a)
instance [overlap ok] CoArbitrary U
instance [overlap ok] CoArbitrary I
instance [overlap ok] (CoArbitrary f, Constructor c) => CoArbitrary (C c f)
instance [overlap ok] (CoArbitrary f, CoArbitrary g, ConNames g) => CoArbitrary (f :+: g)
instance [overlap ok] (Arbitrary f, Arbitrary g) => Arbitrary (f :*: g)
instance [overlap ok] Arbitrary a => Arbitrary (K a)
instance [overlap ok] Arbitrary U
instance [overlap ok] Arbitrary I
instance [overlap ok] (Arbitrary f, Constructor c) => Arbitrary (C c f)
instance [overlap ok] (Fixpoints f, Fixpoints g, ConNames f, Arbitrary f, ConNames g, Arbitrary g) => Arbitrary (f :+: g)
