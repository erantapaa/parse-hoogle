-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fixpoint data types
--   
--   Fixpoint types and recursion schemes. If you define your AST as
--   fixpoint type, you get fold and unfold operations for free.
@package data-fix
@version 0.0.1


-- | Fix-point type. It allows to define generic recurion schemes.
--   
--   <pre>
--   Fix f = f (Fix f)
--   </pre>
--   
--   Type <tt>f</tt> should be a <a>Functor</a> if you want to use simple
--   recursion schemes or <a>Traversable</a> if you want to use monadic
--   recursion schemes. This style allows you to express recursive
--   functions in non-recursive manner. You can imagine that a
--   non-recursive function holds values of the previous iteration.
--   
--   Little example:
--   
--   <pre>
--   type List a = Fix (L a)
--   
--   data L a b = Nil | Cons a b
--   
--   instance Functor (L a) where
--      fmap f x = case x of
--          Nil      -&gt; Nil
--          Cons a b -&gt; Cons a (f b)
--   
--   length :: List a -&gt; Int
--   length = cata $ \x -&gt; case x of
--      Nil      -&gt; 0
--      Cons _ n -&gt; n + 1
--   
--   sum :: Num a =&gt; List a -&gt; a
--   sum = cata $ \x -&gt; case x of
--      Nil      -&gt; 0
--      Cons a s -&gt; a + s
--   </pre>
module Data.Fix

-- | A fix-point type.
newtype Fix f
Fix :: f (Fix f) -> Fix f
unFix :: Fix f -> f (Fix f)

-- | Catamorphism or generic function fold.
cata :: Functor f => (f a -> a) -> (Fix f -> a)

-- | Anamorphism or generic function unfold.
ana :: Functor f => (a -> f a) -> (a -> Fix f)

-- | Hylomorphism is anamorphism followed by catamorphism.
hylo :: Functor f => (f b -> b) -> (a -> f a) -> (a -> b)

-- | Infix version of <tt>hylo</tt>.
(~>) :: Functor f => (a -> f a) -> (f b -> b) -> (a -> b)

-- | Monadic catamorphism.
cataM :: (Applicative m, Monad m, Traversable t) => (t a -> m a) -> Fix t -> m a

-- | Monadic anamorphism.
anaM :: (Applicative m, Monad m, Traversable t) => (a -> m (t a)) -> (a -> m (Fix t))

-- | Monadic hylomorphism.
hyloM :: (Applicative m, Monad m, Traversable t) => (t b -> m b) -> (a -> m (t a)) -> (a -> m b)
instance Ord (f (Fix f)) => Ord (Fix f)
instance Eq (f (Fix f)) => Eq (Fix f)
instance Show (f (Fix f)) => Show (Fix f)
