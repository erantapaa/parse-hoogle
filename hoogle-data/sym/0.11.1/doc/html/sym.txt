-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Permutations, patterns, and statistics
--   
@package sym
@version 0.11.1

module Sym.Internal.Size
class Size a
size :: Size a => a -> Int
instance Size a => Size (Maybe a)
instance Size (Set a)
instance Size [a]


module Sym.Internal.Util

-- | The list of minimal sets with respect to inclusion.
minima :: Ord a => [Set a] -> [Set a]

-- | The list of maximal sets with respect to inclusion.
maxima :: Ord a => [Set a] -> [Set a]

-- | A list of all k element subsets of the given set.
kSubsets :: Ord a => Int -> Set a -> [Set a]

-- | A list of all subsets of the given set.
powerset :: Ord a => Set a -> [Set a]

-- | Sort and remove duplicates.
nubSort :: Ord a => [a] -> [a]


-- | Convenience functions for dealing with arrays of <a>CLong</a>s.
module Sym.Internal.CLongArray

-- | An array of <a>CLong</a>s
data CLongArray

-- | Construct an array from a list of elements.
fromList :: [Int] -> CLongArray

-- | The list of elements.
toList :: CLongArray -> [Int]

-- | Slice a <a>CLongArray</a> into contiguous segments of the given sizes.
--   Each segment size must be positive and they must sum to the size of
--   the array.
slice :: [Int] -> CLongArray -> [CLongArray]

-- | Like <a>slice</a> but without range checking.
unsafeSlice :: [Int] -> CLongArray -> [CLongArray]
size :: Size a => a -> Int

-- | <tt>w `at` i</tt> is the value of <tt>w</tt> at <tt>i</tt>, where
--   <tt>i</tt> is in <tt>[0..size w-1]</tt>.
at :: CLongArray -> Int -> Int

-- | Like <a>at</a> but without range checking.
unsafeAt :: CLongArray -> Int -> Int

-- | The indices of all elements equal to the query element, in ascending
--   order.
elemIndices :: CLong -> CLongArray -> [Int]

-- | Apply a function to every element of an array and its index.
imap :: (Int -> CLong -> CLong) -> CLongArray -> CLongArray

-- | Apply a function to corresponding pairs of elements and their (shared)
--   index.
izipWith :: (Int -> CLong -> CLong -> CLong) -> CLongArray -> CLongArray -> CLongArray

-- | Create a new array of the given size that is initialized through an IO
--   action.
unsafeNew :: Int -> (Ptr CLong -> IO ()) -> IO CLongArray

-- | Pass a pointer to the array to an IO action; the array may not be
--   modified through the pointer.
unsafeWith :: CLongArray -> (Ptr CLong -> IO a) -> IO a
instance Size CLongArray
instance Ord CLongArray
instance Eq CLongArray
instance Show CLongArray


module Sym.Internal.SubSeq

-- | A SubSeq is represented by an increasing array of non-negative
--   integers.
type SubSeq = CLongArray

-- | <tt>n `choose` k</tt> is the list of subsequences of <tt>[0..n-1]</tt>
--   with <tt>k</tt> elements.
choose :: Int -> Int -> [SubSeq]
instance Bitmask Integer
instance Bitmask CLong


-- | Generating permutations: rank and unrank
module Sym.Perm

-- | A permutation is just a <a>CLongArray</a>. By convention a permutation
--   of size <tt>n</tt> is understood to be a permutation of
--   <tt>[0..n-1]</tt>.
type Perm = CLongArray

-- | The unique permutation length zero.
emptyperm :: Perm

-- | The unique permutation length one.
one :: Perm

-- | The identity permutation.
idperm :: Int -> Perm

-- | The reverse of the identity permutation.
ebb :: Int -> Perm

-- | Construct a permutation from a list of elements. As opposed to
--   <a>fromList</a> this is a safe function in the sense that the output
--   of <tt>mkPerm xs</tt> is guaranteed to be a permutation of
--   <tt>[0..length xs-1]</tt>. E.g., <tt>mkPerm "baxa" == fromList
--   [2,0,3,1]</tt>.
mkPerm :: Ord a => [a] -> Perm

-- | The rank of the given permutation, where the rank is defined as in [W.
--   Myrvold and F. Ruskey, Ranking and Unranking Permutations in Linear
--   Time, Information Processing Letters, 79 (2001) 281-284].
rank :: Perm -> Integer

-- | The permutation of size <tt>n</tt> whose rank is <tt>r</tt>, where the
--   rank is defined as in [W. Myrvold and F. Ruskey, Ranking and Unranking
--   Permutations in Linear Time, Information Processing Letters, 79 (2001)
--   281-284].
unrank :: Int -> Integer -> Perm

-- | All permutations of a given size.
perms :: Int -> [Perm]


-- | Data types for Semistandard Young Tableaux (SSYT) and functions for
--   converting between (generalized) permutataions and SSYT. In other
--   words, this module implements the Robinson-Schensted-Knuth (RSK)
--   correspondence.
module Sym.Perm.SSYT

-- | A <i>Generalized Permutation</i> is a lexicographically sorted list of
--   pairs of non-negative integers.
type GeneralizedPerm = [(Int, Int)]

-- | An entry is a non-negative integer
type Entry = Int

-- | A <i>Semistandard Young Tableau (SSYT)</i>: the entries weakly
--   increase along each row and strictly increase down each column.
type SSYT = [[Entry]]

-- | A pair of Semistandard Young Tableaux.
data SSYTPair
SSYTPair :: SSYT -> SSYT -> SSYTPair
insertionTableau :: SSYTPair -> SSYT
recordingTableau :: SSYTPair -> SSYT
class Shape a
shape :: Shape a => a -> [Int]

-- | A pair of empty Young tableaux.
empty :: SSYTPair

-- | Check if a given pair of Young tableaux are empty.
null :: SSYTPair -> Bool

-- | Produce a string for pretty printing SSYT pairs.
display :: SSYTPair -> String

-- | The Robinson-Schensted algorithm.
fromPerm :: Perm -> SSYTPair

-- | The Robinson-Schensted-Knuth (RSK) algorithm.
fromGeneralizedPerm :: GeneralizedPerm -> SSYTPair

-- | The inverse of the Robinson-Schensted algorithm.
toPerm :: SSYTPair -> Perm

-- | The inverse of the Robinson-Schensted-Knuth algorithm.
toGeneralizedPerm :: SSYTPair -> GeneralizedPerm
instance Eq SSYTPair
instance Show SSYTPair
instance Shape SSYTPair
instance Shape SSYT


module Sym.Perm.D8

-- | Ration by 0 degrees, i.e. the identity map.
r0 :: Perm -> Perm

-- | Ration by 90 degrees clockwise.
r1 :: Perm -> Perm

-- | Ration by 2*90 = 180 degrees clockwise.
r2 :: Perm -> Perm

-- | Ration by 3*90 = 270 degrees clockwise.
r3 :: Perm -> Perm

-- | Reflection through a horizontal axis (also called <a>complement</a>).
s0 :: Perm -> Perm

-- | Reflection through a vertical axis (also called <a>reverse</a>).
s1 :: Perm -> Perm

-- | Reflection through the main diagonal (also called <a>inverse</a>).
s2 :: Perm -> Perm

-- | Reflection through the anti-diagonal.
s3 :: Perm -> Perm

-- | The dihedral group of order 8 (the symmetries of a square); that is,
--   
--   <pre>
--   d8 = [r0, r1, r2, r3, s0, s1, s2, s3]
--   </pre>
d8 :: [Perm -> Perm]

-- | The Klein four-group (the symmetries of a non-equilateral rectangle);
--   that is,
--   
--   <pre>
--   klein4 = [r0, r2, s0, s1]
--   </pre>
klein4 :: [Perm -> Perm]

-- | <tt>orbit fs x</tt> is the orbit of <tt>x</tt> under the <i>group</i>
--   of function <tt>fs</tt>. E.g.,
--   
--   <pre>
--   orbit klein4 "2314" == ["1423","2314","3241","4132"]
--   </pre>
orbit :: [Perm -> Perm] -> Perm -> [Perm]

-- | <tt>symmetryClasses fs xs</tt> is the list of equivalence classes
--   under the action of the <i>group</i> of functions <tt>fs</tt>.
symmetryClasses :: [Perm -> Perm] -> [Perm] -> [[Perm]]

-- | Symmetry classes with respect to D8.
d8Classes :: [Perm] -> [[Perm]]

-- | Symmetry classes with respect to Klein4
klein4Classes :: [Perm] -> [[Perm]]

-- | <pre>
--   rotate = r1 = inverse . reverse
--   </pre>
rotate :: Perm -> Perm

-- | The complement of the given permutation: if <tt>v = complement u</tt>
--   then <tt>v `at` i = n - 1 - u `at` i</tt>.
complement :: Perm -> Perm

-- | The reverse of the given permutation: if <tt>v = reverse u</tt> then
--   <tt>v `at` i = u `at` (n-1-i)</tt>.
reverse :: Perm -> Perm

-- | The group theoretical inverse: if <tt>v = inverse u</tt> then <tt>v
--   `at` (u `at` i) = i</tt>.
inverse :: Perm -> Perm


-- | Components of permutations.
module Sym.Perm.Component

-- | The list of (plus) components.
components :: Perm -> [Perm]

-- | The list of skew components, also called minus components.
skewComponents :: Perm -> [Perm]

-- | For each position, left-to-right, records the largest value seen thus
--   far.
leftMaxima :: Perm -> [Int]

-- | For each position, left-to-right, records the smallest value seen thus
--   far.
leftMinima :: Perm -> [Int]

-- | For each position, <i>right-to-left</i>, records the largest value
--   seen thus far.
rightMaxima :: Perm -> [Int]

-- | For each position, <i>right-to-left</i>, records the smallest value
--   seen thus far.
rightMinima :: Perm -> [Int]


module Sym.Perm.Bijection

-- | The Simion-Schmidt bijection from Av(123) onto Av(132).
simionSchmidt :: Perm -> Perm

-- | The inverse of the Simion-Schmidt bijection. It is a function from
--   Av(132) to Av(123).
simionSchmidt' :: Perm -> Perm


module Sym.Perm.Group

-- | The product/composition of <tt>u</tt> and <tt>v</tt>: if <tt>w = u
--   <a>compose</a> v</tt> then <tt>w `at ` i = v `at` (u `at` i)</tt>.
compose :: Perm -> Perm -> Perm

-- | The (left) group action of Perm on itself: if <tt>w = u <a>act</a>
--   v</tt> then <tt>w `at ` (u `at` i) = v `at` i</tt>.
act :: Perm -> Perm -> Perm


module Sym.Perm.Pattern

-- | Pattern is just an alias for permutation.
type Pattern = Perm

-- | A SubSeq is represented by an increasing array of non-negative
--   integers.
type SubSeq = CLongArray

-- | <tt>ordiso u v m</tt> determines whether the subword in <tt>v</tt>
--   specified by <tt>m</tt> is order isomorphic to <tt>u</tt>.
ordiso :: Pattern -> Perm -> SubSeq -> Bool

-- | <tt>n `choose` k</tt> is the list of subsequences of <tt>[0..n-1]</tt>
--   with <tt>k</tt> elements.
choose :: Int -> Int -> [SubSeq]

-- | <tt>copiesOf p w</tt> is the list of sets that represent copies of
--   <tt>p</tt> in <tt>w</tt>.
copiesOf :: Pattern -> Perm -> [SubSeq]

-- | <tt>w <a>contains</a> p</tt> is a predicate determining if <tt>w</tt>
--   contains the pattern <tt>p</tt>.
contains :: Perm -> Pattern -> Bool

-- | <tt>w <a>avoids</a> p</tt> is a predicate determining if <tt>w</tt>
--   avoids the pattern <tt>p</tt>.
avoids :: Perm -> Pattern -> Bool

-- | <tt>w <a>avoidsAll</a> ps</tt> is a predicate determining if
--   <tt>w</tt> avoids the patterns <tt>ps</tt>.
avoidsAll :: Perm -> [Pattern] -> Bool

-- | <tt>avoiders ps ws</tt> is the list of permutations in <tt>ws</tt>
--   avoiding the patterns in <tt>ps</tt>.
avoiders :: [Pattern] -> [Perm] -> [Perm]

-- | The set of minimal elements with respect to containment. FIX: Poor
--   implementation
minima :: [Pattern] -> [Pattern]

-- | The set of maximal elements with respect to containment. FIX: Poor
--   implementation
maxima :: [Pattern] -> [Pattern]

-- | <tt>coeff f v</tt> is the coefficient of <tt>v</tt> when expanding the
--   permutation statistic <tt>f</tt> as a sum of permutations/patterns.
--   See Petter Brändén and Anders Claesson: Mesh patterns and the
--   expansion of permutation statistics as sums of permutation patterns,
--   The Electronic Journal of Combinatorics 18(2) (2011),
--   <a>http://www.combinatorics.org/ojs/index.php/eljc/article/view/v18i2p5</a>.
coeff :: (Pattern -> Int) -> Pattern -> Int


module Sym.Perm.Simple

-- | Is the permutation simple?
simple :: Perm -> Bool


module Sym.Perm.Sort

-- | One pass of stack-sort.
stackSort :: Perm -> Perm

-- | One pass of bubble-sort.
bubbleSort :: Perm -> Perm


-- | Permutation diagrams, or permutations as monads.
module Sym.Permgram

-- | The purpose of this data type is to assign labels to the indices of a
--   given permutation.
type Label a = Array Int a

-- | A permgram consists of a permutation together with a label for each
--   index of the permutation.
data Permgram a

-- | The underlying permutation.
perm :: Permgram a -> Perm

-- | The assignment of labels to indices.
label :: Permgram a -> Label a

-- | The size of a permgram is the size of the underlying permutation.
size :: Permgram a -> Int

-- | Construct a permgram from an underlying permutation and a list of
--   labels.
permgram :: Perm -> [a] -> Permgram a

-- | The inverse permgram. It's obtained by mirroring the permgram in the
--   <i>x=y</i> diagonal.
inverse :: Permgram a -> Permgram a
instance Applicative Permgram
instance Monad Permgram
instance Functor Permgram
instance Ord a => Ord (Permgram a)
instance Eq a => Eq (Permgram a)
instance Show a => Show (Permgram a)


-- | Sum, skew sum, etc
module Sym.Perm.Constructions

-- | The <i>direct sum</i> of two permutations.
(/+/) :: Perm -> Perm -> Perm

-- | The <i>skew sum</i> of two permutations.
(\-\) :: Perm -> Perm -> Perm

-- | The direct sum of a list of permutations.
directSum :: [Perm] -> Perm

-- | The skew sum of a list of permutations.
skewSum :: [Perm] -> Perm

-- | <tt>inflate w vs</tt> is the <i>inflation</i> of <tt>w</tt> by
--   <tt>vs</tt>. It is the permutation of length <tt>sum (map size
--   vs)</tt> obtained by replacing each entry <tt>w!i</tt> by an interval
--   that is order isomorphic to <tt>vs!i</tt> in such a way that the
--   intervals are order isomorphic to <tt>w</tt>. In particular,
--   
--   <pre>
--   u /+/ v == inflate (mkPerm "12") [u,v]
--   u \-\ v == inflate (mkPerm "21") [u,v]
--   </pre>
inflate :: Perm -> [Perm] -> Perm


module Sym.Perm.Class

-- | The class of increasing permutations.
inc :: Int -> [Perm]

-- | The class of decreasing permutations.
dec :: Int -> [Perm]

-- | Av(1)
av1 :: Int -> [Perm]

-- | Av(12)
av12 :: Int -> [Perm]

-- | Av(21)
av21 :: Int -> [Perm]

-- | Av(123)
av123 :: Int -> [Perm]

-- | Av(132)
av132 :: Int -> [Perm]

-- | Av(213)
av213 :: Int -> [Perm]

-- | Av(231); also know as the stack sortable permutations.
av231 :: Int -> [Perm]

-- | Av(312)
av312 :: Int -> [Perm]

-- | Av(321)
av321 :: Int -> [Perm]

-- | Av(1243)
av1243 :: Int -> [Perm]

-- | Av(1324)
av1324 :: Int -> [Perm]

-- | Av(2134)
av2134 :: Int -> [Perm]

-- | Av(s) where s is a string of one or more patterns, using space as a
--   seperator.
av :: String -> Int -> [Perm]

-- | The V-class is Av(132, 231). It is so named because the diagram of a
--   typical permutation in this class is shaped like a V.
vee :: Int -> [Perm]

-- | The ∧-class is Av(213, 312). It is so named because the diagram of a
--   typical permutation in this class is shaped like a ∧.
caret :: Int -> [Perm]

-- | The &gt;-class is Av(132, 312). It is so named because the diagram of
--   a typical permutation in this class is shaped like a &gt;.
gt :: Int -> [Perm]

-- | The &lt;-class is Av(213, 231). It is so named because the diagram of
--   a typical permutation in this class is shaped like a &lt;.
lt :: Int -> [Perm]

-- | The union of <a>vee</a>, <a>caret</a>, <a>gt</a> and <a>lt</a>.
wedges :: Int -> [Perm]

-- | The class of separable permutations; it is identical to Av(2413,3142).
separables :: Int -> [Perm]

-- | The class of layered permutations with <i>k</i> layers.
kLayered :: Int -> Int -> [Perm]

-- | The class of layered permutations.
layered :: Int -> [Perm]

-- | The class of Fibonacci permutations with <i>k</i> layers. A
--   <i>Fibonacci permutation</i> is a layered permutation whose layers are
--   all of size 1 or 2.
kFibonacci :: Int -> Int -> [Perm]

-- | The class of Fibonacci permutations. A <i>Fibonacci permutation</i> is
--   a layered permutation whose layers are all of size 1 or 2.
fibonacci :: Int -> [Perm]


-- | A meta module collecting all Perm-modules, except those that are best
--   imported "qualified".
module Sym.Perm.Meta


-- | Common permutation statistics. To avoid name clashes this module is
--   best imported <tt>qualified</tt>; e.g.
--   
--   <pre>
--   import qualified Sym.Perm.Stat as S
--   </pre>
module Sym.Perm.Stat

-- | The number of ascents. An <i>ascent</i> in <tt>w</tt> is an index
--   <tt>i</tt> such that <tt>w[i] &lt; w[i+1]</tt>.
asc :: Perm -> Int

-- | The number of descents. A <i>descent</i> in <tt>w</tt> is an index
--   <tt>i</tt> such that <tt>w[i] &gt; w[i+1]</tt>.
des :: Perm -> Int

-- | The number of <i>excedances</i>: positions <tt>i</tt> such that
--   <tt>w[i] &gt; i</tt>.
exc :: Perm -> Int

-- | The number of <i>fixed points</i>: positions <tt>i</tt> such that
--   <tt>w[i] == i</tt>.
fp :: Perm -> Int

-- | The number of <i>strong fixed points</i> (also called splitters):
--   positions <tt>i</tt> such that <tt>w[j] &lt; i</tt> for <tt>j &lt;
--   i</tt> and <tt>w[j] &gt; i</tt> for <tt>j &gt; i</tt>.
sfp :: Perm -> Int

-- | The number of <i>cycles</i>: orbits of the permutation when viewed as
--   a function.
cyc :: Perm -> Int

-- | The number of <i>inversions</i>: pairs <tt>(i,j)</tt> such that <tt>i
--   &lt; j</tt> and <tt>w[i] &gt; w[j]</tt>.
inv :: Perm -> Int

-- | <i>The major index</i> is the sum of descents.
maj :: Perm -> Int

-- | <i>The co-major index</i> is the sum of descents.
comaj :: Perm -> Int

-- | The number of <i>peaks</i>: positions <tt>i</tt> such that <tt>w[i-1]
--   &lt; w[i]</tt> and <tt>w[i] &gt; w[i+1]</tt>.
peak :: Perm -> Int

-- | The number of <i>valleys</i>: positions <tt>i</tt> such that
--   <tt>w[i-1] &gt; w[i]</tt> and <tt>w[i] &lt; w[i+1]</tt>.
vall :: Perm -> Int

-- | The number of <i>double ascents</i>: positions <tt>i</tt> such that
--   <tt>w[i-1] &lt; w[i] &lt; w[i+1]</tt>.
dasc :: Perm -> Int

-- | The number of <i>double descents</i>: positions <tt>i</tt> such that
--   <tt>w[i-1] &gt; w[i] &gt; w[i+1]</tt>.
ddes :: Perm -> Int

-- | The number of <i>left-to-right minima</i>: positions <tt>i</tt> such
--   that <tt>w[i] &lt; w[j]</tt> for all <tt>j &lt; i</tt>.
lmin :: Perm -> Int

-- | The number of <i>left-to-right maxima</i>: positions <tt>i</tt> such
--   that <tt>w[i] &gt; w[j]</tt> for all <tt>j &lt; i</tt>.
lmax :: Perm -> Int

-- | The number of <i>right-to-left minima</i>: positions <tt>i</tt> such
--   that <tt>w[i] &lt; w[j]</tt> for all <tt>j &gt; i</tt>.
rmin :: Perm -> Int

-- | The number of <i>right-to-left maxima</i>: positions <tt>i</tt> such
--   that <tt>w[i] &gt; w[j]</tt> for all <tt>j &gt; i</tt>.
rmax :: Perm -> Int

-- | The first (left-most) element in the standardization. E.g., <tt>head
--   "231" = head (fromList [1,2,0]) = 1</tt>.
head :: Perm -> Int

-- | The last (right-most) element in the standardization. E.g., <tt>last
--   "231" = last (fromList [1,2,0]) = 0</tt>.
last :: Perm -> Int

-- | Length of the left-most increasing run: largest <tt>i</tt> such that
--   <tt>w[0] &lt; w[1] &lt; ... &lt; w[i-1]</tt>.
lir :: Perm -> Int

-- | Length of the left-most decreasing run: largest <tt>i</tt> such that
--   <tt>w[0] &gt; w[1] &gt; ... &gt; w[i-1]</tt>.
ldr :: Perm -> Int

-- | Length of the right-most increasing run: largest <tt>i</tt> such that
--   <tt>w[n-i] &lt; ... &lt; w[n-2] &lt; w[n-1]</tt>.
rir :: Perm -> Int

-- | Length of the right-most decreasing run: largest <tt>i</tt> such that
--   <tt>w[n-i] &gt; ... &gt; w[n-2] &gt; w[n-1]</tt>.
rdr :: Perm -> Int

-- | The number of components. E.g., <tt>[2,0,3,1,4,6,7,5]</tt> has three
--   components: <tt>[2,0,3,1]</tt>, <tt>[4]</tt> and <tt>[6,7,5]</tt>.
comp :: Perm -> Int

-- | The number of skew components. E.g., <tt>[5,7,4,6,3,1,0,2]</tt> has
--   three skew components: <tt>[5,7,4,6]</tt>, <tt>[3]</tt> and
--   <tt>[1,0,2]</tt>.
scomp :: Perm -> Int

-- | The rank as defined by Elizalde and Pak [Bijections for refined
--   restricted permutations, <i>J. Comb. Theory, Ser. A</i>, 2004]:
--   
--   <pre>
--   maximum [ k | k &lt;- [0..n-1], w[i] &gt;= k for all i &lt; k ]
--   </pre>
ep :: Perm -> Int

-- | The dimension of a permutation is defined as the largest
--   non-fixed-point, or zero if all points are fixed.
dim :: Perm -> Int

-- | The number of small ascents. A <i>small ascent</i> in <tt>w</tt> is an
--   index <tt>i</tt> such that <tt>w[i] + 1 == w[i+1]</tt>.
asc0 :: Perm -> Int

-- | The number of small descents. A <i>small descent</i> in <tt>w</tt> is
--   an index <tt>i</tt> such that <tt>w[i] == w[i+1] + 1</tt>.
des0 :: Perm -> Int

-- | The longest increasing subsequence.
lis :: Perm -> Int

-- | The longest decreasing subsequence.
lds :: Perm -> Int


module Sym.Perm.MeshPattern
data MeshPattern
MP :: Perm -> Mesh -> MeshPattern
getPerm :: MeshPattern -> Perm
getMesh :: MeshPattern -> Mesh

-- | A mesh is a, possibly empty, set of shaded boxes.
type Mesh = Set Box

-- | A box is represented by the coordinates of its southwest corner.
type Box = (Int, Int)
mkPattern :: Ord a => [a] -> MeshPattern
pattern :: Perm -> MeshPattern
mesh :: [Box] -> MeshPattern -> MeshPattern
cols :: [Int] -> MeshPattern -> MeshPattern
rows :: [Int] -> MeshPattern -> MeshPattern
col :: Int -> MeshPattern -> MeshPattern
row :: Int -> MeshPattern -> MeshPattern
box :: Box -> MeshPattern -> MeshPattern

-- | <tt>copiesOf p w</tt> is the list of sets that represent copies of
--   <tt>p</tt> in <tt>w</tt>.
copiesOf :: MeshPattern -> Perm -> [SubSeq]

-- | <tt>w <a>contains</a> p</tt> is a predicate determining if <tt>w</tt>
--   contains the pattern <tt>p</tt>.
contains :: Perm -> MeshPattern -> Bool

-- | <tt>w <a>avoids</a> p</tt> is a predicate determining if <tt>w</tt>
--   avoids the pattern <tt>p</tt>.
avoids :: Perm -> MeshPattern -> Bool

-- | <tt>w <a>avoidsAll</a> ps</tt> is a predicate determining if
--   <tt>w</tt> avoids the patterns <tt>ps</tt>.
avoidsAll :: Perm -> [MeshPattern] -> Bool

-- | <tt>avoiders ps ws</tt> is the list of permutations in <tt>ws</tt>
--   avoiding the patterns in <tt>ps</tt>.
avoiders :: [MeshPattern] -> [Perm] -> [Perm]
kVincular :: Int -> Perm -> [MeshPattern]
vincular :: Perm -> [MeshPattern]
bivincular :: Perm -> [MeshPattern]
meshPatterns :: Perm -> [MeshPattern]
instance Show MeshPattern
instance Eq MeshPattern
instance Ord MeshPattern
instance Size MeshPattern


module Sym

-- | The class of permutations. Minimal complete definition: <a>st</a>,
--   <a>act</a> and <a>idperm</a>. The default implementation of
--   <a>size</a> can be somewhat slow, so you may want to implement it as
--   well.
class Permutation a where size = size . st inverse = unst . inverse . st ordiso u v = u == st v unst w = w `act` idperm (size w)
st :: Permutation a => a -> Perm
act :: Permutation a => Perm -> a -> a
size :: Permutation a => a -> Int
idperm :: Permutation a => Int -> a
inverse :: Permutation a => a -> a
ordiso :: Permutation a => Perm -> a -> Bool
unst :: (Permutation a, Permutation a) => Perm -> a

-- | The list of all permutations of the given size.
perms :: Permutation a => Int -> [a]

-- | Lifts a function on <a>Perm</a>s to one on any permutations.
lift :: Permutation a => (Perm -> Perm) -> a -> a

-- | Like <a>lift</a> but for functions of two variables.
lift2 :: Permutation a => (Perm -> Perm -> Perm) -> a -> a -> a
instance Permutation SSYTPair
instance Permutation String
instance Permutation Perm
