-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HAppS data manipulation libraries
--   
--   This package provides libraries for:
--   
--   <ul>
--   <li>Deriving instances for your datatypes.</li>
--   <li>Producing default values of Haskell datatypes.</li>
--   <li>Normalizing values of Haskell datatypes.</li>
--   <li>Marshalling Haskell values to and from XML.</li>
--   <li>Marshalling Haskell values to and from HTML forms.</li>
--   </ul>
@package HAppS-Data
@version 0.9.3

module HAppS.Data.GOps


-- | Normalizing Haskell values.
module HAppS.Data.Normalize

-- | The <a>Normalize</a> class provides a <a>normalize</a> function, which
--   is intended to normalize values only at the top-level constructor, and
--   a <a>normalizeRecursively</a> function, which is intended to normalize
--   all the subvalues and then normalize the top-level constructor.
--   
--   There is a default instance that matches all types, where
--   <a>normalize</a> is <a>id</a> and <a>normalizeRecursively</a> applies
--   <a>normalizeRecursively</a> to all of its children and then
--   <a>normalize</a> to the result.
--   
--   If you want to actually do some normalization for a certain type, then
--   just define an instance for that type; this will take precedence over
--   the default instance.
class (Data NormalizeD a) => Normalize a
normalize :: (Normalize a) => a -> a
normalizeRecursively :: (Normalize a) => a -> a

-- | This is the <a>normalize</a> function in the default <a>Normalize</a>
--   instance. It may be a useful building block when writing your own
--   instances.
defaultNormalize :: (Normalize a) => a -> a

-- | This is the <a>normalizeRecursively</a> function in the default
--   <a>Normalize</a> instance. It may be a useful building block when
--   writing your own instances.
defaultNormalizeRecursively :: (Normalize a) => a -> a

-- | When writing your own generic functions for <a>Normalize</a> you may
--   need to access the class methods through this datatype rather than
--   directly.
data NormalizeD a
NormalizeD :: (a -> a) -> (a -> a) -> NormalizeD a
normalizeD :: NormalizeD a -> a -> a
normalizeRecursivelyD :: NormalizeD a -> a -> a

-- | When writing your own generic functions for <a>Normalize</a> you may
--   need this, the proxy value.
normalizeProxy :: Proxy NormalizeD
instance [overlap ok] (Data NormalizeD a) => Normalize a
instance [overlap ok] (Normalize t) => Sat (NormalizeD t)

module HAppS.Data.Migrate
class Migrate a b
migrate :: (Migrate a b) => a -> b


-- | Provides default values for Haskell datatypes.
module HAppS.Data.Default

-- | The <a>Default</a> class provides a <a>defaultValue</a> value, which
--   is the default value for that type.
--   
--   There is no instance for arbitrary types by default, but if you
--   declare an instance without providing the value then one will be built
--   using the first constructor. <a>defaultValue</a> is used to provide
--   values for any arguments of the constructor.
--   
--   If you want an instance for all types then import
--   <a>HAppS.Data.Default.Generic</a>.
class (Data DefaultD a) => Default a
defaultValue :: (Default a) => a

-- | This is the <a>defaultValue</a> that is used in an instance if you
--   don't specify one. It may be a useful building block when writing your
--   own instances.
defaultDefaultValue :: (Data DefaultD a, Default a) => a

-- | When writing your own generic functions for <a>Default</a> you may
--   need to access the class method through this datatype rather than
--   directly.
data DefaultD a
DefaultD :: a -> DefaultD a
defaultValueD :: DefaultD a -> a

-- | When writing your own generic functions for <a>Default</a> you may
--   need this, the proxy value.
defaultProxy :: Proxy DefaultD
instance [overlap ok] (Default a) => Default (ForeignPtr a)
instance [overlap ok] Default ByteString
instance [overlap ok] (Default a) => Default (Maybe a)
instance [overlap ok] Default Char
instance [overlap ok] (Default a, Default b, Default c, Default d) => Default (a, b, c, d)
instance [overlap ok] (Default a, Default b, Default c) => Default (a, b, c)
instance [overlap ok] (Default a, Default b) => Default (a, b)
instance [overlap ok] Default ()
instance [overlap ok] (Default a, Default b) => Default (Either a b)
instance [overlap ok] Default Double
instance [overlap ok] Default Float
instance [overlap ok] Default Integer
instance [overlap ok] Default Word64
instance [overlap ok] Default Word32
instance [overlap ok] Default Word16
instance [overlap ok] Default Word8
instance [overlap ok] Default Word
instance [overlap ok] Default Int64
instance [overlap ok] Default Int32
instance [overlap ok] Default Int16
instance [overlap ok] Default Int8
instance [overlap ok] Default Int
instance [overlap ok] (Default a) => Default [a]
instance [overlap ok] (Default t) => Sat (DefaultD t)


-- | Provides a <a>Default</a> instance for all types.
--   <a>defaultDefaultValue</a> is used for <a>defaultValue</a>.
module HAppS.Data.Default.Generic
instance [overlap ok] (Data DefaultD a) => Default a


-- | Concisely specify which classes to derive for your datatypes. As well
--   as the standard derivable classes, it can also derive syb-with-class's
--   New.Data class and HAppS.Data.Default's <a>Default</a> class.
module HAppS.Data.DeriveAll

-- | The <a>deriveAll</a> function takes a list of classes to derive and a
--   block of declarations. It will additionally derive instances for
--   Typeable, <a>Data</a> and New.Data.
--   
--   Example:
--   
--   <pre>
--   $( deriveAll [''Show, ''Eq, ''Default] [d|
--          data Foo a = Foo a
--          data Bar = Baz | Quux
--    |] )
--   </pre>
deriveAll :: [Name] -> Q [Dec] -> Q [Dec]
deriveNewData :: [Name] -> Q [Dec]
deriveNewDataNoDefault :: [Name] -> Q [Dec]

module HAppS.Data.Xml.HaXml
isAttr :: Element -> Bool
toHaXmls :: [Element] -> [Content]
toHaXml :: Element -> Content
toAttribute :: Element -> Attribute
fromHaXmls :: [Content] -> [Element]
fromHaXml :: Content -> Element
fromAttributes :: [Attribute] -> [Element]
fromAttribute :: Attribute -> Element

module HAppS.Data.Xml
data Element
Elem :: String -> [Element] -> Element
CData :: String -> Element
Attr :: String -> String -> Element
dataType[a63M] :: DataType
constr[a63P] :: Constr
constr[a63O] :: Constr
constr[a63N] :: Constr
fromXml :: (Monad m, Xml a) => Rigidity m -> [Element] -> m a
data Other b
Other :: a -> Other b
NoOther :: Other b
toPublicXml :: (Xml a) => a -> [Element]
data Rigidity m
Rigid :: Rigidity Maybe
Flexible :: Rigidity Identity
class (Data XmlD a, Default a, Normalize a) => Xml a
toXml :: (Xml a) => a -> [Element]
readXml :: (Xml a, Monad m) => Rigidity m -> [Element] -> Maybe ([Element], a)
readXml' :: (Xml a, Monad m) => Rigidity m -> [Element] -> Maybe ([Element], a)
normalizeXml :: (Xml a) => a -> [Element] -> [Element]
version :: (Xml a) => a -> Maybe String
otherVersion :: (Xml a) => a -> Other a
typ :: (Xml a) => a -> String
data XmlD a
XmlD :: (a -> [Element]) -> (forall m. (Monad m) => Rigidity m -> ReadM m a) -> (forall m. (Monad m) => Rigidity m -> ReadM Maybe a) -> XmlD a
toXmlD :: XmlD a -> a -> [Element]
readMXmlD :: XmlD a -> forall m. (Monad m) => Rigidity m -> ReadM m a
readMXmlNoRootDefaultD :: XmlD a -> forall m. (Monad m) => Rigidity m -> ReadM Maybe a
xmlProxy :: Proxy XmlD
first :: (a -> a) -> [a] -> [a]
defaultToXml :: (Xml t) => t -> [Element]
transparentToXml :: (Xml t) => t -> [Element]
transparentReadXml :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)
transparentXml :: Name -> Q [Dec]
defaultReadXml :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)
defaultReadXml' :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)
readXmlWith :: (Xml t) => (Rigidity m -> Element -> Maybe t) -> Rigidity m -> [Element] -> Maybe ([Element], t)
readVersionedElement :: (Monad m, Xml t) => Rigidity m -> Element -> Maybe t
isTheAttr :: String -> Element -> Bool
getAttr :: String -> [Element] -> Maybe (String, [Element])
versionAttr :: String
typeAttr :: String
readElement :: (Monad m, Xml t) => Rigidity m -> Element -> Maybe t
aConstrFromElements :: (Monad m, Xml t) => Rigidity m -> [Constr] -> [Element] -> Maybe ([Element], t)
constrFromElementsNoRootDefault :: (Monad m, Xml t) => Rigidity m -> Constr -> [Element] -> Maybe ([Element], t)
constrFromElements :: (Monad m, Xml t) => Rigidity m -> Constr -> [Element] -> m ([Element], t)
type ReadM m = StateT ReadState m
data ReadState
ReadState :: [Element] -> ReadState
xmls :: ReadState -> [Element]
getXmls :: (Monad m) => ReadM m [Element]
putXmls :: (Monad m) => [Element] -> ReadM m ()
readMXml :: (Monad m, Xml a) => Rigidity m -> ReadM m a
readMXmlNoRootDefault :: (Monad m, Xml a) => Rigidity m -> ReadM Maybe a
xmlAttr :: Name -> Q [Dec]
xmlShowCDatas :: [Name] -> Q [Dec]
xmlShowCData :: Name -> Q [Dec]
xmlCDataLists :: [Name] -> Q [Dec]
xmlCDataList :: Name -> Q [Dec]
noCommas :: String -> String
typeNotValue :: (Xml a) => a -> a
data K
K :: String -> K
data W
W :: [K] -> W
dataType[adTk] :: DataType
constr[adTl] :: Constr
dataType[adTa] :: DataType
constr[adTb] :: Constr
class ToString a
toString :: (ToString a) => a -> String
class FromString a
fromString :: (FromString a, Monad m) => Rigidity m -> String -> m a

module HAppS.Data.Pairs
type Pairs = [(String, String)]
class (Xml x, Show x, Data x) => AsPairs x
toPairs :: (AsPairs x) => x -> Pairs
fromPairs :: (AsPairs x) => Pairs -> Maybe x
instance [overlap ok] Data Pass
instance [overlap ok] Show Pass
instance [overlap ok] Eq Pass
instance [overlap ok] Data User
instance [overlap ok] Show User
instance [overlap ok] Eq User
instance [overlap ok] Data UserInfo
instance [overlap ok] Show UserInfo
instance [overlap ok] Eq UserInfo
instance [overlap ok] (Data ctx String, Sat (ctx Pass), Sat (ctx String)) => Data ctx Pass
instance [overlap ok] Typeable Pass
instance [overlap ok] (Data ctx String, Sat (ctx User), Sat (ctx String)) => Data ctx User
instance [overlap ok] Typeable User
instance [overlap ok] (Data ctx User, Data ctx Pass, Sat (ctx UserInfo), Sat (ctx User), Sat (ctx Pass)) => Data ctx UserInfo
instance [overlap ok] Typeable UserInfo
instance [overlap ok] Default Pass
instance [overlap ok] Default User
instance [overlap ok] Default UserInfo
instance [overlap ok] (Xml a, Show a, Data a, Eq a) => AsPairs a

module HAppS.Data.HList
class HasT a b
hlextract :: (HasT a b) => a -> b
hlupdate :: (HasT a b) => a -> b -> a
(.&.) :: a -> b -> Couple a b
type :&: a b = Couple b a
data Couple a[a4NS] b[a4NT]
Couple :: a[a4NS] -> b[a4NT] -> Couple a[a4NS] b[a4NT]
data Nil
Nil :: Nil
class CoupleClass a
hMap :: (HMap a b) => a -> b
trans :: (Trans ft a) => ft -> a -> a
instance [overlap ok] HMap (Couple a Nil) (Couple [a] Nil)
instance [overlap ok] (HMap b d, CoupleClass b) => HMap (Couple a b) (Couple [a] d)
instance [overlap ok] (Trans ft b) => Trans' ft (Couple a b)
instance [overlap ok] (Trans' ft a) => Trans ft a
instance [overlap ok] Trans (b -> b) (Couple a b)
instance [overlap ok] Trans (a -> a) (Couple a b)
instance [overlap ok] (HasT c a) => HasT' (Couple b c) a
instance [overlap ok] (HasT' a b) => HasT a b
instance [overlap ok] HasT (Couple a b) b
instance [overlap ok] HasT (Couple a b) a
instance [overlap ok] (Xml a, Xml b) => Xml (Couple a b)
instance [overlap ok] CoupleClass Nil
instance [overlap ok] (Eq a, Xml a, Show a, Data a, CoupleClass b) => CoupleClass (Couple a b)

module HAppS.Data.Proxy
data Proxy t[aiaw]
Proxy :: Proxy t[aiaw]
dataType[aiax] :: DataType
constr[aiay] :: Constr
proxy :: t -> Proxy t
unProxy :: Proxy t -> t
asProxyType :: t -> Proxy t -> t
instance [overlap ok] (Typeable t[aiaw]) => Data (Proxy t[aiaw])
instance [overlap ok] Read (Proxy t[aiaw])
instance [overlap ok] Show (Proxy t[aiaw])
instance [overlap ok] (Data ctx t[aiaw], Sat (ctx (Proxy t[aiaw]))) => Data ctx (Proxy t[aiaw])
instance [overlap ok] Typeable1 Proxy
instance [overlap ok] (Default t[aiaw]) => Default (Proxy t[aiaw])

module HAppS.Data.Serialize
class (Typeable a, Version a) => Serialize a
getCopy :: (Serialize a) => Contained (Get a)
putCopy :: (Serialize a) => a -> Contained Put
class Version a
mode :: (Version a) => Mode a
class Migrate a b
migrate :: (Migrate a b) => a -> b
data Mode a

-- | Data layout won't change. Used for types like Int and Char.
Primitive :: Mode a
Versioned :: (VersionId a) -> (Maybe (Previous a)) -> Mode a
data Contained a
contain :: a -> Contained a
extension :: (Serialize b, Migrate b a) => VersionId a -> Proxy b -> Mode a
safeGet :: (Serialize a) => Get a
safePut :: (Serialize a) => a -> Put
serialize :: (Serialize a) => a -> ByteString
deserialize :: (Serialize a) => ByteString -> (a, ByteString)
collectVersions :: (Typeable a, Version a) => Proxy a -> [ByteString]
data Object
mkObject :: (Serialize a) => a -> Object
deserializeObject :: ByteString -> (Object, ByteString)
parseObject :: (Serialize a) => Object -> a
instance [overlap ok] Typeable Object
instance [overlap ok] Show Object
instance [overlap ok] Num (VersionId a)
instance [overlap ok] Read (VersionId a)
instance [overlap ok] Show (VersionId a)
instance [overlap ok] Eq (VersionId a)
instance [overlap ok] Serialize Object
instance [overlap ok] Version Object
instance [overlap ok] (Serialize a) => Serialize (IntMap a)
instance [overlap ok] Version (IntMap a)
instance [overlap ok] (Serialize a, Serialize b, Ord a) => Serialize (Map a b)
instance [overlap ok] Version (Map a b)
instance [overlap ok] (Serialize a, Ord a) => Serialize (Set a)
instance [overlap ok] Version (Set a)
instance [overlap ok] (Serialize a) => Serialize (Maybe a)
instance [overlap ok] Version (Maybe a)
instance [overlap ok] (Serialize a) => Serialize [a]
instance [overlap ok] Version [a]
instance [overlap ok] (Typeable a) => Serialize (Proxy a)
instance [overlap ok] Version (Proxy a)
instance [overlap ok] (Serialize a, Serialize b, Serialize c, Serialize d, Serialize e) => Serialize (a, b, c, d, e)
instance [overlap ok] Version (a, b, c, d, e)
instance [overlap ok] (Serialize a, Serialize b, Serialize c, Serialize d) => Serialize (a, b, c, d)
instance [overlap ok] Version (a, b, c, d)
instance [overlap ok] (Serialize a, Serialize b, Serialize c) => Serialize (a, b, c)
instance [overlap ok] Version (a, b, c)
instance [overlap ok] (Serialize a, Serialize b) => Serialize (a, b)
instance [overlap ok] Version (a, b)
instance [overlap ok] (Serialize a, Serialize b) => Serialize (Either a b)
instance [overlap ok] Version (Either a b)
instance [overlap ok] Serialize Bool
instance [overlap ok] Version Bool
instance [overlap ok] Serialize ()
instance [overlap ok] Version ()
instance [overlap ok] Serialize Int64
instance [overlap ok] Version Int64
instance [overlap ok] Serialize Int32
instance [overlap ok] Version Int32
instance [overlap ok] Serialize Int16
instance [overlap ok] Version Int16
instance [overlap ok] Serialize Int8
instance [overlap ok] Version Int8
instance [overlap ok] Serialize Ordering
instance [overlap ok] Version Ordering
instance [overlap ok] Serialize Word64
instance [overlap ok] Version Word64
instance [overlap ok] Serialize Word32
instance [overlap ok] Version Word32
instance [overlap ok] Serialize Word16
instance [overlap ok] Version Word16
instance [overlap ok] Serialize Word8
instance [overlap ok] Version Word8
instance [overlap ok] Serialize Char
instance [overlap ok] Version Char
instance [overlap ok] Serialize ByteString
instance [overlap ok] Version ByteString
instance [overlap ok] Serialize ByteString
instance [overlap ok] Version ByteString
instance [overlap ok] Serialize Double
instance [overlap ok] Version Double
instance [overlap ok] Serialize Float
instance [overlap ok] Version Float
instance [overlap ok] Serialize Integer
instance [overlap ok] Version Integer
instance [overlap ok] Serialize Int
instance [overlap ok] Version Int
instance [overlap ok] Binary (VersionId a)

module HAppS.Data.SerializeTH
deriveSerialize :: Name -> Q [Dec]
deriveSerializeFor :: [Name] -> Q [Dec]

module HAppS.Data

module HAppS.Data.Atom
data Entry
Entry :: [Author] -> [Category] -> Maybe Content -> [Contributor] -> Id -> Maybe Published -> Maybe Summary -> Title -> Updated -> Entry
data Feed
Feed :: [Entry] -> Feed
data Author
Author :: PersonConstruct -> Author
data Contributor
Contributor :: PersonConstruct -> Contributor
data Category
Category :: Term -> Maybe Scheme -> Maybe Label -> Category
newtype Id
Id :: Integer -> Id
data Title
Title :: TextConstruct -> Title
newtype Published
Published :: DateConstruct -> Published
newtype Updated
Updated :: DateConstruct -> Updated
newtype Summary
Summary :: TextConstruct -> Summary
newtype Content
Content :: TextConstruct -> Content
newtype Word
Word :: String -> Word
newtype Email
Email :: String -> Email
instance [overlap ok] Serialize Id
instance [overlap ok] Serialize Label
instance [overlap ok] Serialize Scheme
instance [overlap ok] Serialize Term
instance [overlap ok] Serialize Category
instance [overlap ok] Serialize Name
instance [overlap ok] Serialize Contributor
instance [overlap ok] Serialize Author
instance [overlap ok] Serialize Content
instance [overlap ok] Serialize Summary
instance [overlap ok] Serialize Subtitle
instance [overlap ok] Serialize Title
instance [overlap ok] Serialize Published
instance [overlap ok] Serialize Updated
instance [overlap ok] Serialize Email
instance [overlap ok] Serialize Uri
instance [overlap ok] Data Word
instance [overlap ok] Ord Word
instance [overlap ok] Eq Word
instance [overlap ok] Read Word
instance [overlap ok] Show Word
instance [overlap ok] Data Published
instance [overlap ok] Ord Published
instance [overlap ok] Eq Published
instance [overlap ok] Read Published
instance [overlap ok] Show Published
instance [overlap ok] Data Updated
instance [overlap ok] Ord Updated
instance [overlap ok] Eq Updated
instance [overlap ok] Read Updated
instance [overlap ok] Show Updated
instance [overlap ok] Data Email
instance [overlap ok] Ord Email
instance [overlap ok] Eq Email
instance [overlap ok] Read Email
instance [overlap ok] Show Email
instance [overlap ok] Data Uri
instance [overlap ok] Ord Uri
instance [overlap ok] Eq Uri
instance [overlap ok] Read Uri
instance [overlap ok] Show Uri
instance [overlap ok] Data Content
instance [overlap ok] Ord Content
instance [overlap ok] Eq Content
instance [overlap ok] Read Content
instance [overlap ok] Show Content
instance [overlap ok] Data Summary
instance [overlap ok] Ord Summary
instance [overlap ok] Eq Summary
instance [overlap ok] Read Summary
instance [overlap ok] Show Summary
instance [overlap ok] Data Subtitle
instance [overlap ok] Ord Subtitle
instance [overlap ok] Eq Subtitle
instance [overlap ok] Read Subtitle
instance [overlap ok] Show Subtitle
instance [overlap ok] Data Title
instance [overlap ok] Ord Title
instance [overlap ok] Eq Title
instance [overlap ok] Read Title
instance [overlap ok] Show Title
instance [overlap ok] Data Id
instance [overlap ok] Ord Id
instance [overlap ok] Eq Id
instance [overlap ok] Read Id
instance [overlap ok] Show Id
instance [overlap ok] Data Label
instance [overlap ok] Ord Label
instance [overlap ok] Eq Label
instance [overlap ok] Read Label
instance [overlap ok] Show Label
instance [overlap ok] Data Scheme
instance [overlap ok] Ord Scheme
instance [overlap ok] Eq Scheme
instance [overlap ok] Read Scheme
instance [overlap ok] Show Scheme
instance [overlap ok] Data Term
instance [overlap ok] Ord Term
instance [overlap ok] Eq Term
instance [overlap ok] Read Term
instance [overlap ok] Show Term
instance [overlap ok] Data Category
instance [overlap ok] Ord Category
instance [overlap ok] Eq Category
instance [overlap ok] Read Category
instance [overlap ok] Show Category
instance [overlap ok] Data Name
instance [overlap ok] Ord Name
instance [overlap ok] Eq Name
instance [overlap ok] Read Name
instance [overlap ok] Show Name
instance [overlap ok] Data Contributor
instance [overlap ok] Ord Contributor
instance [overlap ok] Eq Contributor
instance [overlap ok] Read Contributor
instance [overlap ok] Show Contributor
instance [overlap ok] Data Author
instance [overlap ok] Ord Author
instance [overlap ok] Eq Author
instance [overlap ok] Read Author
instance [overlap ok] Show Author
instance [overlap ok] Data Entry
instance [overlap ok] Ord Entry
instance [overlap ok] Eq Entry
instance [overlap ok] Read Entry
instance [overlap ok] Show Entry
instance [overlap ok] Data Feed
instance [overlap ok] Ord Feed
instance [overlap ok] Eq Feed
instance [overlap ok] Read Feed
instance [overlap ok] Show Feed
instance [overlap ok] Version Id
instance [overlap ok] Version Label
instance [overlap ok] Version Scheme
instance [overlap ok] Version Term
instance [overlap ok] Version Category
instance [overlap ok] Version Name
instance [overlap ok] Version Contributor
instance [overlap ok] Version Author
instance [overlap ok] Version Content
instance [overlap ok] Version Summary
instance [overlap ok] Version Subtitle
instance [overlap ok] Version Title
instance [overlap ok] Version Published
instance [overlap ok] Version Updated
instance [overlap ok] Version Email
instance [overlap ok] Version Uri
instance [overlap ok] (Data ctx String, Sat (ctx Word), Sat (ctx String)) => Data ctx Word
instance [overlap ok] Typeable Word
instance [overlap ok] (Data ctx DateConstruct, Sat (ctx Published), Sat (ctx DateConstruct)) => Data ctx Published
instance [overlap ok] Typeable Published
instance [overlap ok] (Data ctx DateConstruct, Sat (ctx Updated), Sat (ctx DateConstruct)) => Data ctx Updated
instance [overlap ok] Typeable Updated
instance [overlap ok] (Data ctx String, Sat (ctx Email), Sat (ctx String)) => Data ctx Email
instance [overlap ok] Typeable Email
instance [overlap ok] (Data ctx String, Sat (ctx Uri), Sat (ctx String)) => Data ctx Uri
instance [overlap ok] Typeable Uri
instance [overlap ok] (Data ctx TextConstruct, Sat (ctx Content), Sat (ctx TextConstruct)) => Data ctx Content
instance [overlap ok] Typeable Content
instance [overlap ok] (Data ctx TextConstruct, Sat (ctx Summary), Sat (ctx TextConstruct)) => Data ctx Summary
instance [overlap ok] Typeable Summary
instance [overlap ok] (Data ctx TextConstruct, Sat (ctx Subtitle), Sat (ctx TextConstruct)) => Data ctx Subtitle
instance [overlap ok] Typeable Subtitle
instance [overlap ok] (Data ctx TextConstruct, Sat (ctx Title), Sat (ctx TextConstruct)) => Data ctx Title
instance [overlap ok] Typeable Title
instance [overlap ok] (Data ctx Integer, Sat (ctx Id), Sat (ctx Integer)) => Data ctx Id
instance [overlap ok] Typeable Id
instance [overlap ok] (Data ctx String, Sat (ctx Label), Sat (ctx String)) => Data ctx Label
instance [overlap ok] Typeable Label
instance [overlap ok] (Data ctx String, Sat (ctx Scheme), Sat (ctx String)) => Data ctx Scheme
instance [overlap ok] Typeable Scheme
instance [overlap ok] (Data ctx String, Sat (ctx Term), Sat (ctx String)) => Data ctx Term
instance [overlap ok] Typeable Term
instance [overlap ok] (Data ctx Term, Data ctx (Maybe Scheme), Data ctx (Maybe Label), Sat (ctx Category), Sat (ctx Term), Sat (ctx (Maybe Scheme)), Sat (ctx (Maybe Label))) => Data ctx Category
instance [overlap ok] Typeable Category
instance [overlap ok] (Data ctx Text, Sat (ctx Name), Sat (ctx Text)) => Data ctx Name
instance [overlap ok] Typeable Name
instance [overlap ok] (Data ctx PersonConstruct, Sat (ctx Contributor), Sat (ctx PersonConstruct)) => Data ctx Contributor
instance [overlap ok] Typeable Contributor
instance [overlap ok] (Data ctx PersonConstruct, Sat (ctx Author), Sat (ctx PersonConstruct)) => Data ctx Author
instance [overlap ok] Typeable Author
instance [overlap ok] (Data ctx [Author], Data ctx [Category], Data ctx (Maybe Content), Data ctx [Contributor], Data ctx Id, Data ctx (Maybe Published), Data ctx (Maybe Summary), Data ctx Title, Data ctx Updated, Sat (ctx Entry), Sat (ctx [Author]), Sat (ctx [Category]), Sat (ctx (Maybe Content)), Sat (ctx [Contributor]), Sat (ctx Id), Sat (ctx (Maybe Published)), Sat (ctx (Maybe Summary)), Sat (ctx Title), Sat (ctx Updated)) => Data ctx Entry
instance [overlap ok] Typeable Entry
instance [overlap ok] (Data ctx [Entry], Sat (ctx Feed), Sat (ctx [Entry])) => Data ctx Feed
instance [overlap ok] Typeable Feed
instance [overlap ok] Default Word
instance [overlap ok] Default Published
instance [overlap ok] Default Updated
instance [overlap ok] Default Email
instance [overlap ok] Default Uri
instance [overlap ok] Default Content
instance [overlap ok] Default Summary
instance [overlap ok] Default Subtitle
instance [overlap ok] Default Title
instance [overlap ok] Default Id
instance [overlap ok] Default Label
instance [overlap ok] Default Scheme
instance [overlap ok] Default Term
instance [overlap ok] Default Category
instance [overlap ok] Default Name
instance [overlap ok] Default Contributor
instance [overlap ok] Default Author
instance [overlap ok] Default Entry
instance [overlap ok] Default Feed
