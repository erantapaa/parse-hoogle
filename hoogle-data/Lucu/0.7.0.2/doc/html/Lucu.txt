-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP Daemonic Library
--   
--   Lucu is an HTTP daemonic library. It can be embedded in any Haskell
--   program and runs in an independent thread. Lucu is not a replacement
--   for Apache or lighttpd. It is intended to be used to create an
--   efficient web-based RESTful application without messing around
--   FastCGI. It is also intended to be run behind a reverse-proxy so it
--   doesn't have some facilities like logging, client filtering or such
--   like.
@package Lucu
@version 0.7.0.2


-- | Utility functions used internally in the Lucu httpd. These functions
--   may be useful too for something else.
module Network.HTTP.Lucu.Utils

-- | <pre>
--   splitBy (== ':') "ab:c:def"
--   ==&gt; ["ab", "c", "def"]
--   </pre>
splitBy :: (a -> Bool) -> [a] -> [[a]]

-- | <pre>
--   joinWith ":" ["ab", "c", "def"]
--   ==&gt; "ab:c:def"
--   </pre>
joinWith :: [a] -> [[a]] -> [a]

-- | <pre>
--   trim (== '_') "__ab_c__def___"
--   ==&gt; "ab_c__def"
--   </pre>
trim :: (a -> Bool) -> [a] -> [a]

-- | <tt><a>isWhiteSpace</a> c</tt> is <a>True</a> iff c is one of SP, HT,
--   CR and LF.
isWhiteSpace :: Char -> Bool

-- | <pre>
--   quoteStr "abc"
--   ==&gt; "\"abc\""
--   </pre>
--   
--   <pre>
--   quoteStr "ab\"c"
--   ==&gt; "\"ab\\\"c\""
--   </pre>
quoteStr :: String -> String

-- | <pre>
--   parseWWWFormURLEncoded "aaa=bbb&amp;ccc=ddd"
--   ==&gt; [("aaa", "bbb"), ("ccc", "ddd")]
--   </pre>
parseWWWFormURLEncoded :: String -> [(String, String)]


-- | Yet another parser combinator. This is mostly a subset of
--   <a>Text.ParserCombinators.Parsec</a> but there are some differences:
--   
--   <ul>
--   <li>This parser works on <tt>Data.ByteString.Base.LazyByteString</tt>
--   instead of <a>String</a>.</li>
--   <li>Backtracking is the only possible behavior so there is no "try"
--   action.</li>
--   <li>On success, the remaining string is returned as well as the parser
--   result.</li>
--   <li>You can choose whether to treat reaching EOF (trying to eat one
--   more letter at the end of string) a fatal error or to treat it a
--   normal failure. If a fatal error occurs, the entire parsing process
--   immediately fails without trying any backtracks. The default behavior
--   is to treat EOF fatal.</li>
--   </ul>
--   
--   In general, you don't have to use this module directly.
module Network.HTTP.Lucu.Parser

-- | <tt><a>Parser</a> a</tt> is obviously a parser which parses and
--   returns <tt>a</tt>.
data Parser a
data ParserResult a
Success :: !a -> ParserResult a
IllegalInput :: ParserResult a
ReachedEOF :: ParserResult a

-- | <tt><a>failP</a></tt> is just a synonym for <tt><a>fail</a>
--   <a>undefined</a></tt>.
failP :: Parser a

-- | <tt><a>parse</a> p bstr</tt> parses <tt>bstr</tt> with <tt>p</tt> and
--   returns <tt>(# result, remaining #)</tt>.
parse :: Parser a -> ByteString -> (# ParserResult a, ByteString #)

-- | <tt><a>parseStr</a> p str</tt> packs <tt>str</tt> and parses it.
parseStr :: Parser a -> String -> (# ParserResult a, ByteString #)
anyChar :: Parser Char
eof :: Parser ()

-- | <tt><a>allowEOF</a> p</tt> makes <tt>p</tt> treat reaching EOF a
--   normal failure.
allowEOF :: Parser a -> Parser a
satisfy :: (Char -> Bool) -> Parser Char
char :: Char -> Parser Char
string :: String -> Parser String

-- | This is the backtracking alternation. There is no non-backtracking
--   equivalent.
(<|>) :: Parser a -> Parser a -> Parser a
choice :: [Parser a] -> Parser a
oneOf :: [Char] -> Parser Char
digit :: Parser Char
hexDigit :: Parser Char
notFollowedBy :: Parser a -> Parser ()
many :: Parser a -> Parser [a]
manyChar :: Parser Char -> Parser ByteString
many1 :: Parser a -> Parser [a]
count :: Int -> Parser a -> Parser [a]
option :: a -> Parser a -> Parser a
sepBy :: Parser a -> Parser sep -> Parser [a]
sepBy1 :: Parser a -> Parser sep -> Parser [a]
sp :: Parser Char
ht :: Parser Char
crlf :: Parser String
instance Eq ParserState
instance Show ParserState
instance Eq a => Eq (ParserResult a)
instance Show a => Show (ParserResult a)
instance Functor Parser
instance Monad Parser


-- | This is an auxiliary parser utilities for parsing things related on
--   HTTP protocol.
--   
--   In general you don't have to use this module directly.
module Network.HTTP.Lucu.Parser.Http

-- | <tt><a>isCtl</a> c</tt> is <a>False</a> iff <tt>0x20 &lt;= </tt>c<tt>
--   &lt; 0x7F</tt>.
isCtl :: Char -> Bool

-- | <tt><a>isSeparator</a> c</tt> is <a>True</a> iff c is one of HTTP
--   separators.
isSeparator :: Char -> Bool

-- | <tt><a>isChar</a> c</tt> is <a>True</a> iff <tt>c &lt;= 0x7f</tt>.
isChar :: Char -> Bool

-- | <tt><a>isToken</a> c</tt> is equivalent to <tt>not (<a>isCtl</a> c ||
--   <a>isSeparator</a> c)</tt>
isToken :: Char -> Bool

-- | <tt><a>listOf</a> p</tt> is similar to <tt><a>sepBy</a> p (<a>char</a>
--   ',')</tt> but it allows any occurrences of LWS before and after each
--   tokens.
listOf :: Parser a -> Parser [a]

-- | <a>token</a> is equivalent to <tt><a>many1</a> $ <a>satisfy</a>
--   <a>isToken</a></tt>
token :: Parser String

-- | <a>lws</a> is an HTTP LWS: <tt><a>crlf</a>? (<a>sp</a> |
--   <a>ht</a>)+</tt>
lws :: Parser String

-- | <a>text</a> accepts one character which doesn't satisfy <a>isCtl</a>.
text :: Parser Char

-- | <a>separator</a> accepts one character which satisfies
--   <a>isSeparator</a>.
separator :: Parser Char

-- | <a>quotedStr</a> accepts a string surrounded by double quotation
--   marks. Quotes can be escaped by backslashes.
quotedStr :: Parser String

-- | <a>qvalue</a> accepts a so-called qvalue.
qvalue :: Parser Double


-- | Manipulation of HTTP version string.
module Network.HTTP.Lucu.HttpVersion

-- | <tt><a>HttpVersion</a> major minor</tt> represents "HTTP/major.minor".
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
instance Eq HttpVersion
instance Ord HttpVersion
instance Show HttpVersion


-- | Definition of things related on HTTP request.
--   
--   In general you don't have to use this module directly.
module Network.HTTP.Lucu.Request

-- | This is the definition of HTTP request methods, which shouldn't
--   require any description.
data Method
OPTIONS :: Method
GET :: Method
HEAD :: Method
POST :: Method
PUT :: Method
DELETE :: Method
TRACE :: Method
CONNECT :: Method
ExtensionMethod :: !String -> Method

-- | This is the definition of HTTP reqest.
data Request
Request :: !Method -> !URI -> !HttpVersion -> !Headers -> Request
reqMethod :: Request -> !Method
reqURI :: Request -> !URI
reqVersion :: Request -> !HttpVersion
reqHeaders :: Request -> !Headers
instance Eq Method
instance Show Method
instance Show Request
instance Eq Request
instance HasHeaders Request


-- | Definition of things related on HTTP response.
module Network.HTTP.Lucu.Response

-- | This is the definition of HTTP status code.
--   <tt>Network.HTTP.Lucu.Resource.setStatus</tt> accepts these named
--   statuses so you don't have to memorize, for instance, that "Gateway
--   Timeout" is 504.
data StatusCode
Continue :: StatusCode
SwitchingProtocols :: StatusCode
Processing :: StatusCode
Ok :: StatusCode
Created :: StatusCode
Accepted :: StatusCode
NonAuthoritativeInformation :: StatusCode
NoContent :: StatusCode
ResetContent :: StatusCode
PartialContent :: StatusCode
MultiStatus :: StatusCode
MultipleChoices :: StatusCode
MovedPermanently :: StatusCode
Found :: StatusCode
SeeOther :: StatusCode
NotModified :: StatusCode
UseProxy :: StatusCode
TemporaryRedirect :: StatusCode
BadRequest :: StatusCode
Unauthorized :: StatusCode
PaymentRequired :: StatusCode
Forbidden :: StatusCode
NotFound :: StatusCode
MethodNotAllowed :: StatusCode
NotAcceptable :: StatusCode
ProxyAuthenticationRequired :: StatusCode
RequestTimeout :: StatusCode
Conflict :: StatusCode
Gone :: StatusCode
LengthRequired :: StatusCode
PreconditionFailed :: StatusCode
RequestEntityTooLarge :: StatusCode
RequestURITooLarge :: StatusCode
UnsupportedMediaType :: StatusCode
RequestRangeNotSatisfiable :: StatusCode
ExpectationFailed :: StatusCode
UnprocessableEntitiy :: StatusCode
Locked :: StatusCode
FailedDependency :: StatusCode
InternalServerError :: StatusCode
NotImplemented :: StatusCode
BadGateway :: StatusCode
ServiceUnavailable :: StatusCode
GatewayTimeout :: StatusCode
HttpVersionNotSupported :: StatusCode
InsufficientStorage :: StatusCode

-- | <tt><a>isInformational</a> sc</tt> is <a>True</a> iff <tt>sc &lt;
--   200</tt>.
isInformational :: StatusCode -> Bool

-- | <tt><a>isSuccessful</a> sc</tt> is <a>True</a> iff <tt>200 &lt;= sc
--   &lt; 300</tt>.
isSuccessful :: StatusCode -> Bool

-- | <tt><a>isRedirection</a> sc</tt> is <a>True</a> iff <tt>300 &lt;= sc
--   &lt; 400</tt>.
isRedirection :: StatusCode -> Bool

-- | <tt><a>isError</a> sc</tt> is <a>True</a> iff <tt>400 &lt;= sc</tt>
isError :: StatusCode -> Bool

-- | <tt><a>isClientError</a> sc</tt> is <a>True</a> iff <tt>400 &lt;= sc
--   &lt; 500</tt>.
isClientError :: StatusCode -> Bool

-- | <tt><a>isServerError</a> sc</tt> is <a>True</a> iff <tt>500 &lt;=
--   sc</tt>.
isServerError :: StatusCode -> Bool

-- | <tt><a>statusCode</a> sc</tt> returns an unboxed tuple of numeric and
--   textual representation of <tt>sc</tt>.
statusCode :: StatusCode -> (# Int, ByteString #)
instance Typeable StatusCode
instance Eq StatusCode
instance Show Response
instance Eq Response
instance HasHeaders Response
instance Show StatusCode


-- | Manipulation of MIME Types.
module Network.HTTP.Lucu.MIMEType

-- | <tt><a>MIMEType</a> "major" "minor" [("name", "value")]</tt>
--   represents "major/minor; name=value".
data MIMEType
MIMEType :: !String -> !String -> ![(String, String)] -> MIMEType
mtMajor :: MIMEType -> !String
mtMinor :: MIMEType -> !String
mtParams :: MIMEType -> ![(String, String)]

-- | Parse <a>MIMEType</a> from a <a>String</a>. This function throws an
--   exception for parse error.
parseMIMEType :: String -> MIMEType
instance Eq MIMEType
instance Read MIMEType
instance Show MIMEType


-- | MIME Type guessing by a file extension. This is a poor man's way of
--   guessing MIME Types. It is simple and fast.
--   
--   In general you don't have to use this module directly.
module Network.HTTP.Lucu.MIMEType.Guess

-- | <a>Map</a> from extension to MIME Type.
type ExtMap = Map String MIMEType

-- | Guess the MIME Type of file.
guessTypeByFileName :: ExtMap -> FilePath -> Maybe MIMEType

-- | Read an Apache mime.types and parse it.
parseExtMapFile :: FilePath -> IO ExtMap

-- | <tt><a>serializeExtMap</a> extMap moduleName variableName</tt>
--   generates a Haskell source code which contains the following things:
--   
--   <ul>
--   <li>A definition of module named <tt>moduleName</tt>.</li>
--   <li><tt>variableName :: <a>ExtMap</a></tt> whose content is a
--   serialization of <tt>extMap</tt>.</li>
--   </ul>
--   
--   The module <a>Network.HTTP.Lucu.MIMEType.DefaultExtensionMap</a> is
--   surely generated using this function.
serializeExtMap :: ExtMap -> String -> String -> String


-- | This module is automatically generated from data/mime.types.
--   <a>defaultExtensionMap</a> contains every possible pairs of an
--   extension and a MIME Type.
module Network.HTTP.Lucu.MIMEType.DefaultExtensionMap
defaultExtensionMap :: ExtMap


-- | Manipulation of entity tags.
module Network.HTTP.Lucu.ETag

-- | An entity tag is made of a weakness flag and a opaque string.
data ETag
ETag :: !Bool -> !String -> ETag

-- | The weakness flag. Weak tags looks like W/"blahblah" and strong tags
--   are like "blahblah".
etagIsWeak :: ETag -> !Bool

-- | An opaque string. Only characters from 0x20 (sp) to 0x7e (~) are
--   allowed.
etagToken :: ETag -> !String

-- | This is equivalent to <tt><a>ETag</a> <a>False</a></tt>. If you want
--   to generate an ETag from a file, try using
--   <tt>Network.HTTP.Lucu.StaticFile.generateETagFromFile</tt>.
strongETag :: String -> ETag

-- | This is equivalent to <tt><a>ETag</a> <a>True</a></tt>.
weakETag :: String -> ETag
instance Eq ETag
instance Show ETag


-- | Manipulation of WWW authorization.
module Network.HTTP.Lucu.Authorization

-- | Authorization challenge to be sent to client with "WWW-Authenticate"
--   header. See <tt>Network.HTTP.Lucu.Resource.setWWWAuthenticate</tt>.
data AuthChallenge
BasicAuthChallenge :: Realm -> AuthChallenge

-- | Authorization credential to be sent by client with "Authorization"
--   header. See <tt>Network.HTTP.Lucu.Resource.getAuthorization</tt>.
data AuthCredential
BasicAuthCredential :: UserID -> Password -> AuthCredential

-- | <a>Realm</a> is just a string which must not contain any non-ASCII
--   letters.
type Realm = String

-- | <a>UserID</a> is just a string which must not contain colon and any
--   non-ASCII letters.
type UserID = String

-- | <a>Password</a> is just a string which must not contain any non-ASCII
--   letters.
type Password = String
instance Eq AuthChallenge
instance Show AuthCredential
instance Eq AuthCredential
instance Show AuthChallenge


-- | Configurations for the Lucu httpd like a port to listen.
module Network.HTTP.Lucu.Config

-- | Configuration record for the Lucu httpd. You need to use
--   <a>defaultConfig</a> or setup your own configuration to run the httpd.
data Config
Config :: !ByteString -> !ByteString -> !ServiceName -> !Maybe HostName -> !Maybe HostName -> !Maybe SSLConfig -> !Int -> !Int -> !Int -> !Bool -> !ExtMap -> Config

-- | A string which will be sent to clients as "Server" field.
cnfServerSoftware :: Config -> !ByteString

-- | The host name of the server. This value will be used in built-in pages
--   like "404 Not Found".
cnfServerHost :: Config -> !ByteString

-- | A port number (or service name) to listen to HTTP clients.
cnfServerPort :: Config -> !ServiceName

-- | Local IPv4 address to listen to both HTTP and HTTPS clients. Set this
--   to <tt>(<a>Just</a> <a>0.0.0.0</a>)</tt> if you want to accept any
--   IPv4 connections. Set this to <a>Nothing</a> to disable IPv4.
cnfServerV4Addr :: Config -> !Maybe HostName

-- | Local IPv6 address to listen to both HTTP and HTTPS clients. Set this
--   to <tt>(<a>Just</a> <a>::</a>)</tt> if you want to accept any IPv6
--   connections. Set this to <a>Nothing</a> to disable IPv6. Note that
--   there is currently no way to assign separate ports to IPv4 and IPv6
--   server sockets.
cnfServerV6Addr :: Config -> !Maybe HostName

-- | Configuration for HTTPS connections. Set this <a>Nothing</a> to
--   disable HTTPS.
cnfSSLConfig :: Config -> !Maybe SSLConfig

-- | The maximum number of requests to accept in one connection
--   simultaneously. If a client exceeds this limitation, its last request
--   won't be processed until a response for its earliest pending request
--   is sent back to the client.
cnfMaxPipelineDepth :: Config -> !Int

-- | The maximum length of request entity to accept in bytes. Note that
--   this is nothing but the default value which is used when
--   <tt>Network.HTTP.Lucu.Resource.input</tt> and such like are applied to
--   <tt>Network.HTTP.Lucu.Resource.defaultLimit</tt>, so there is no
--   guarantee that this value always constrains all the requests.
cnfMaxEntityLength :: Config -> !Int

-- | The maximum length of chunk to output. This value is used by
--   <tt>Network.HTTP.Lucu.Resource.output</tt> and such like to limit the
--   chunk length so you can safely output an infinite string (like a lazy
--   stream of /dev/random) using those actions.
cnfMaxOutputChunkLength :: Config -> !Int

-- | Whether to dump too late abortion to the stderr or not. See
--   <tt>Network.HTTP.Lucu.Abortion.abort</tt>.
cnfDumpTooLateAbortionToStderr :: Config -> !Bool

-- | A mapping from extension to MIME Type. This value is used by
--   <tt>Network.HTTP.Lucu.StaticFile.staticFile</tt> to guess the MIME
--   Type of static files. Note that MIME Types are currently guessed only
--   by file name.
--   
--   Guessing by file magic is indeed a wonderful idea but that is not
--   implemented (yet). But, don't you think it's better a file system got
--   a MIME Type as a part of inode? Or it might be a good idea to use
--   GnomeVFS
--   (<a>http://developer.gnome.org/doc/API/2.0/gnome-vfs-2.0/</a>) instead
--   of vanilla FS.
cnfExtToMIMEType :: Config -> !ExtMap

-- | Configuration record for HTTPS connections.
data SSLConfig
SSLConfig :: !ServiceName -> !SSLContext -> SSLConfig

-- | A port ID to listen to HTTPS clients. Local addresses (both for IPv4
--   and IPv6) will be derived from the parent <a>Config</a>.
sslServerPort :: SSLConfig -> !ServiceName

-- | An SSL context for accepting connections.
sslContext :: SSLConfig -> !SSLContext

-- | The default configuration. Generally you can use this value as-is, or
--   possibly you just want to replace the <a>cnfServerSoftware</a> and
--   <a>cnfServerPort</a>. SSL connections are disabled by default.
defaultConfig :: Config


-- | Aborting the computation of
--   <tt>Network.HTTP.Lucu.Resource.Resource</tt> in any <a>IO</a> monads
--   or arrows.
module Network.HTTP.Lucu.Abortion

-- | Computation of <tt><a>abort</a> status headers msg</tt> aborts the
--   <tt>Network.HTTP.Lucu.Resource.Resource</tt> monad with given status,
--   additional response headers, and optional message string.
--   
--   What this really does is to throw a special <a>Exception</a>. The
--   exception will be caught by the Lucu system.
--   
--   <ol>
--   <li>If the <tt>Network.HTTP.Lucu.Resource.Resource</tt> is in the
--   /Deciding Header/ or any precedent states, it is possible to use the
--   <tt>status</tt> and such like as a HTTP response to be sent to the
--   client.</li>
--   <li>Otherwise the HTTP response can't be modified anymore so the only
--   possible thing the system can do is to dump it to the stderr. See
--   <a>cnfDumpTooLateAbortionToStderr</a>.</li>
--   </ol>
--   
--   Note that the status code doesn't have to be an error code so you can
--   use this action for redirection as well as error reporting e.g.
--   
--   <pre>
--   abort MovedPermanently
--         [("Location", "http://example.net/")]
--         (Just "It has been moved to example.net")
--   </pre>
abort :: MonadIO m => StatusCode -> [(String, String)] -> Maybe String -> m a

-- | This is similar to <a>abort</a> but computes it with
--   <a>unsafePerformIO</a>.
abortPurely :: StatusCode -> [(String, String)] -> Maybe String -> a

-- | Computation of <tt><a>abortSTM</a> status headers msg</tt> just
--   computes <a>abort</a> in a <tt>Control.Monad.STM.STM</tt> monad.
abortSTM :: StatusCode -> [(String, String)] -> Maybe String -> STM a

-- | Computation of <tt><a>abortA</a> -&lt; (status, (headers, msg))</tt>
--   just computes <a>abort</a> in an <a>ArrowIO</a>.
abortA :: ArrowIO a => a (StatusCode, ([(String, String)], Maybe String)) c
instance Typeable Abortion
instance Show Abortion
instance Exception Abortion


-- | This is the Resource Monad; monadic actions to define the behavior of
--   each resources. The <a>Resource</a> Monad is a kind of <a>IO</a> Monad
--   thus it implements <tt>Control.Monad.Trans.MonadIO</tt> class. It is
--   also a state machine.
--   
--   Request Processing Flow:
--   
--   <ol>
--   <li>A client issues an HTTP request.</li>
--   <li>If the URI of it matches to any resource, the corresponding
--   <a>Resource</a> Monad starts running on a newly spawned thread.</li>
--   <li>The <a>Resource</a> Monad looks at the request header, find (or
--   not find) an entity, receive the request body (if any), decide the
--   response header, and decide the response body. This process will be
--   discussed later.</li>
--   <li>The <a>Resource</a> Monad and its thread stops running. The client
--   may or may not be sending us the next request at this point.</li>
--   </ol>
--   
--   <a>Resource</a> Monad takes the following states. The initial state is
--   <i>Examining Request</i> and the final state is <i>Done</i>.
--   
--   <ul>
--   <li><i><i>Examining Request</i></i> In this state, a <a>Resource</a>
--   looks at the request header and thinks about an entity for it. If
--   there is a suitable entity, the <a>Resource</a> tells the system an
--   entity tag and its last modification time (<a>foundEntity</a>). If it
--   found no entity, it tells the system so (<a>foundNoEntity</a>). In
--   case it is impossible to decide the existence of entity, which is a
--   typical case for POST requests, <a>Resource</a> does nothing in this
--   state.</li>
--   <li><i><i>Getting Body</i></i> A <a>Resource</a> asks the system to
--   receive a request body from client. Before actually reading from the
--   socket, the system sends "100 Continue" to the client if need be. When
--   a <a>Resource</a> transits to the next state without receiving all or
--   part of request body, the system still reads it and just throws it
--   away.</li>
--   <li><i><i>Deciding Header</i></i> A <a>Resource</a> makes a decision
--   of status code and response header. When it transits to the next
--   state, the system checks the validness of response header and then
--   write them to the socket.</li>
--   <li><i><i>Deciding Body</i></i> In this state, a <a>Resource</a> asks
--   the system to write some response body to the socket. When it transits
--   to the next state without writing any response body, the system
--   completes it depending on the status code.</li>
--   <li><i><i>Done</i></i> Everything is over. A <a>Resource</a> can do
--   nothing for the HTTP interaction anymore.</li>
--   </ul>
--   
--   Note that the state transition is one-way: for instance, it is an
--   error to try to read a request body after writing some response. This
--   limitation is for efficiency. We don't want to read the entire request
--   before starting <a>Resource</a>, nor we don't want to postpone writing
--   the entire response till the end of <a>Resource</a> computation.
module Network.HTTP.Lucu.Resource

-- | The <a>Resource</a> monad. This monad implements
--   <tt>Control.Monad.Trans.MonadIO</tt> so it can do any <a>IO</a>
--   actions.
data Resource a

-- | This data type represents a form value and possibly an uploaded file
--   name.
data FormData
FormData :: Maybe String -> ByteString -> FormData
fdFileName :: FormData -> Maybe String
fdContent :: FormData -> ByteString

-- | Get the <a>Config</a> value which is used for the httpd.
getConfig :: Resource Config

-- | Get the <a>SockAddr</a> of the remote host. If you want a string
--   representation instead of <a>SockAddr</a>, use <a>getRemoteAddr'</a>.
getRemoteAddr :: Resource SockAddr

-- | Get the string representation of the address of remote host. If you
--   want a <a>SockAddr</a> instead of <a>String</a>, use
--   <a>getRemoteAddr</a>.
getRemoteAddr' :: Resource String

-- | Resolve an address to the remote host.
getRemoteHost :: Resource String

-- | Return the X.509 certificate of the client, or <a>Nothing</a> if:
--   
--   <ul>
--   <li>This request didn't came through an SSL stream.</li>
--   <li>The client didn't send us its certificate.</li>
--   <li>The <tt>OpenSSL.Session.VerificationMode</tt> of
--   <tt>OpenSSL.Session.SSLContext</tt> in <a>SSLConfig</a> has not been
--   set to <tt>OpenSSL.Session.VerifyPeer</tt>.</li>
--   </ul>
getRemoteCertificate :: Resource (Maybe X509)

-- | Get the <a>Request</a> value which represents the request header. In
--   general you don't have to use this action.
getRequest :: Resource Request

-- | Get the <a>Method</a> value of the request.
getMethod :: Resource Method

-- | Get the URI of the request.
getRequestURI :: Resource URI

-- | Get the HTTP version of the request.
getRequestVersion :: Resource HttpVersion

-- | Get the path of this <a>Resource</a> (to be exact,
--   <tt>Network.HTTP.Lucu.Resource.Tree.ResourceDef</tt>) in the
--   <tt>Network.HTTP.Lucu.Resource.Tree.ResTree</tt>. The result of this
--   action is the exact path in the tree even if the
--   <tt>Network.HTTP.Lucu.Resource.Tree.ResourceDef</tt> is greedy.
--   
--   Example:
--   
--   <pre>
--   main = let tree = mkResTree [ (["foo"], resFoo) ]
--          in runHttpd defaultConfig tree
--   
--   resFoo = ResourceDef {
--       resIsGreedy = True
--     , resGet = Just $ do requestURI   &lt;- getRequestURI
--                          resourcePath &lt;- getResourcePath
--                          pathInfo     &lt;- getPathInfo
--                          -- uriPath requestURI == "/foo/bar/baz"
--                          -- resourcePath       == ["foo"]
--                          -- pathInfo           == ["bar", "baz"]
--                          ...
--     , ...
--     }
--   </pre>
getResourcePath :: Resource [String]

-- | This is an analogy of CGI PATH_INFO. The result is URI-unescaped. It
--   is always <tt>[]</tt> if the
--   <tt>Network.HTTP.Lucu.Resource.Tree.ResourceDef</tt> is not greedy.
--   See <a>getResourcePath</a>.
getPathInfo :: Resource [String]

-- | Assume the query part of request URI as
--   application/x-www-form-urlencoded, and parse it to pairs of <tt>(name,
--   formData)</tt>. This action doesn't parse the request body. See
--   <a>inputForm</a>.
getQueryForm :: Resource [(String, FormData)]

-- | Get a value of given request header. Comparison of header name is
--   case-insensitive. Note that this action is not intended to be used so
--   frequently: there should be actions like <a>getContentType</a> for
--   every common headers.
getHeader :: ByteString -> Resource (Maybe ByteString)

-- | Get a list of <a>MIMEType</a> enumerated on header "Accept".
getAccept :: Resource [MIMEType]

-- | Get a list of <tt>(contentCoding, qvalue)</tt> enumerated on header
--   "Accept-Encoding". The list is sorted in descending order by qvalue.
getAcceptEncoding :: Resource [(String, Maybe Double)]

-- | Check whether a given content-coding is acceptable.
isEncodingAcceptable :: String -> Resource Bool

-- | Get the header "Content-Type" as <a>MIMEType</a>.
getContentType :: Resource (Maybe MIMEType)

-- | Get the header "Authorization" as <a>AuthCredential</a>.
getAuthorization :: Resource (Maybe AuthCredential)

-- | Tell the system that the <a>Resource</a> found an entity for the
--   request URI. If this is a GET or HEAD request, a found entity means a
--   datum to be replied. If this is a PUT or DELETE request, it means a
--   datum which was stored for the URI until now. It is an error to
--   compute <a>foundEntity</a> if this is a POST request.
--   
--   Computation of <a>foundEntity</a> performs "If-Match" test or
--   "If-None-Match" test if possible. When those tests fail, the
--   computation of <a>Resource</a> immediately aborts with status "412
--   Precondition Failed" or "304 Not Modified" depending on the situation.
--   
--   If this is a GET or HEAD request, <a>foundEntity</a> automatically
--   puts "ETag" and "Last-Modified" headers into the response.
foundEntity :: ETag -> UTCTime -> Resource ()

-- | Tell the system that the <a>Resource</a> found an entity for the
--   request URI. The only difference from <a>foundEntity</a> is that
--   <a>foundETag</a> doesn't (and can't) put "Last-Modified" header into
--   the response.
--   
--   This action is not preferred. You should use <a>foundEntity</a>
--   whenever possible.
foundETag :: ETag -> Resource ()

-- | Tell the system that the <a>Resource</a> found an entity for the
--   request URI. The only difference from <a>foundEntity</a> is that
--   <a>foundTimeStamp</a> performs "If-Modified-Since" test or
--   "If-Unmodified-Since" test instead of "If-Match" test or
--   "If-None-Match" test. Be aware that any tests based on last
--   modification time are unsafe because it is possible to mess up such
--   tests by modifying the entity twice in a second.
--   
--   This action is not preferred. You should use <a>foundEntity</a>
--   whenever possible.
foundTimeStamp :: UTCTime -> Resource ()

-- | Computation of <tt><a>foundNoEntity</a> mStr</tt> tells the system
--   that the <a>Resource</a> found no entity for the request URI.
--   <tt>mStr</tt> is an optional error message to be replied to the
--   client.
--   
--   If this is a PUT request, <a>foundNoEntity</a> performs "If-Match"
--   test and aborts with status "412 Precondition Failed" when it failed.
--   If this is a GET, HEAD, POST or DELETE request, <a>foundNoEntity</a>
--   always aborts with status "404 Not Found".
foundNoEntity :: Maybe String -> Resource ()

-- | Computation of <tt><a>input</a> limit</tt> attempts to read the
--   request body up to <tt>limit</tt> bytes, and then make the
--   <a>Resource</a> transit to <i>Deciding Header</i> state. When the
--   actual size of body is larger than <tt>limit</tt> bytes, computation
--   of <a>Resource</a> immediately aborts with status "413 Request Entity
--   Too Large". When the request has no body, <a>input</a> returns an
--   empty string.
--   
--   <tt>limit</tt> may be less than or equal to zero. In this case, the
--   default limitation value (<a>cnfMaxEntityLength</a>) is used. See
--   <a>defaultLimit</a>.
--   
--   Note that <a>inputLBS</a> is more efficient than <a>input</a> so you
--   should use it whenever possible.
input :: Int -> Resource String

-- | Computation of <tt><a>inputChunk</a> limit</tt> attempts to read a
--   part of request body up to <tt>limit</tt> bytes. You can read any
--   large request by repeating computation of this action. When you've
--   read all the request body, <a>inputChunk</a> returns an empty string
--   and then make the <a>Resource</a> transit to <i>Deciding Header</i>
--   state.
--   
--   <tt>limit</tt> may be less than or equal to zero. In this case, the
--   default limitation value (<a>cnfMaxEntityLength</a>) is used. See
--   <a>defaultLimit</a>.
--   
--   Note that <a>inputChunkLBS</a> is more efficient than
--   <a>inputChunk</a> so you should use it whenever possible.
inputChunk :: Int -> Resource String

-- | This is mostly the same as <a>input</a> but is more efficient.
--   <a>inputLBS</a> returns a <tt>Data.ByteString.Lazy.ByteString</tt> but
--   it's not really lazy: reading from the socket just happens at the
--   computation of <a>inputLBS</a>, not at the evaluation of the
--   <tt>Data.ByteString.Lazy.ByteString</tt>. The same goes for
--   <a>inputChunkLBS</a>.
inputLBS :: Int -> Resource ByteString

-- | This is mostly the same as <a>inputChunk</a> but is more efficient.
--   See <a>inputLBS</a>.
inputChunkLBS :: Int -> Resource ByteString

-- | Computation of <tt><a>inputForm</a> limit</tt> attempts to read the
--   request body with <a>input</a> and parse it as
--   application/x-www-form-urlencoded or multipart/form-data. If the
--   request header "Content-Type" is neither of them, <a>inputForm</a>
--   makes <a>Resource</a> abort with status "415 Unsupported Media Type".
--   If the request has no "Content-Type", it aborts with "400 Bad
--   Request".
inputForm :: Int -> Resource [(String, FormData)]

-- | This is just a constant <tt>-1</tt>. It's better to say
--   <tt><a>input</a> <a>defaultLimit</a></tt> than to say <tt><a>input</a>
--   (-1)</tt> but these are exactly the same.
defaultLimit :: Int

-- | Set the response status code. If you omit to compute this action, the
--   status code will be defaulted to "200 OK".
setStatus :: StatusCode -> Resource ()

-- | Set a value of given resource header. Comparison of header name is
--   case-insensitive. Note that this action is not intended to be used so
--   frequently: there should be actions like <a>setContentType</a> for
--   every common headers.
--   
--   Some important headers (especially "Content-Length" and
--   "Transfer-Encoding") may be silently dropped or overwritten by the
--   system not to corrupt the interaction with client at the viewpoint of
--   HTTP protocol layer. For instance, if we are keeping the connection
--   alive, without this process it causes a catastrophe to send a header
--   "Content-Length: 10" and actually send a body of 20 bytes long. In
--   this case the client shall only accept the first 10 bytes of response
--   body and thinks that the residual 10 bytes is a part of header of the
--   next response.
setHeader :: ByteString -> ByteString -> Resource ()

-- | Computation of <tt><a>redirect</a> code uri</tt> sets the response
--   status to <tt>code</tt> and "Location" header to <tt>uri</tt>. The
--   <tt>code</tt> must satisfy <a>isRedirection</a> or it causes an error.
redirect :: StatusCode -> URI -> Resource ()

-- | Computation of <tt><a>setContentType</a> mType</tt> sets the response
--   header "Content-Type" to <tt>mType</tt>.
setContentType :: MIMEType -> Resource ()

-- | Computation of <tt><a>setLocation</a> uri</tt> sets the response
--   header "Location" to <tt>uri</tt>.
setLocation :: URI -> Resource ()

-- | Computation of <tt><a>setContentEncoding</a> codings</tt> sets the
--   response header "Content-Encoding" to <tt>codings</tt>.
setContentEncoding :: [String] -> Resource ()

-- | Computation of <tt><a>setWWWAuthenticate</a> challenge</tt> sets the
--   response header "WWW-Authenticate" to <tt>challenge</tt>.
setWWWAuthenticate :: AuthChallenge -> Resource ()

-- | Computation of <tt><a>output</a> str</tt> writes <tt>str</tt> as a
--   response body, and then make the <a>Resource</a> transit to
--   <i>Done</i> state. It is safe to apply <a>output</a> to an infinite
--   string, such as a lazy stream of /dev/random.
--   
--   Note that <a>outputLBS</a> is more efficient than <a>output</a> so you
--   should use it whenever possible.
output :: String -> Resource ()

-- | Computation of <tt><a>outputChunk</a> str</tt> writes <tt>str</tt> as
--   a part of response body. You can compute this action multiple times to
--   write a body little at a time. It is safe to apply <a>outputChunk</a>
--   to an infinite string.
--   
--   Note that <a>outputChunkLBS</a> is more efficient than
--   <a>outputChunk</a> so you should use it whenever possible.
outputChunk :: String -> Resource ()

-- | This is mostly the same as <a>output</a> but is more efficient.
outputLBS :: ByteString -> Resource ()

-- | This is mostly the same as <a>outputChunk</a> but is more efficient.
outputChunkLBS :: ByteString -> Resource ()
instance MonadIO Resource
instance Monad Resource
instance Functor Resource


-- | Repository of the resources in httpd.
module Network.HTTP.Lucu.Resource.Tree

-- | <a>ResourceDef</a> is basically a set of <a>Resource</a> monads for
--   each HTTP methods.
data ResourceDef
ResourceDef :: !Bool -> !Bool -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> ResourceDef

-- | Whether to run a <a>Resource</a> on a native thread (spawned by
--   <a>forkOS</a>) or to run it on a user thread (spanwed by
--   <a>forkIO</a>). Generally you don't need to set this field to
--   <a>True</a>.
resUsesNativeThread :: ResourceDef -> !Bool

-- | Whether to be greedy or not.
--   
--   Say a client is trying to access /aaa/bbb/ccc. If there is a greedy
--   resource at /aaa/bbb, it is always chosen even if there is another
--   resource at /aaa/bbb/ccc. If the resource at /aaa/bbb is not greedy,
--   it is just ignored. Greedy resources are like CGI scripts.
resIsGreedy :: ResourceDef -> !Bool

-- | A <a>Resource</a> to be run when a GET request comes for the resource
--   path. If <a>resGet</a> is Nothing, the system responds "405 Method Not
--   Allowed" for GET requests.
--   
--   It also runs for HEAD request if the <a>resHead</a> is Nothing. In
--   this case <a>output</a> and such like don't actually write a response
--   body.
resGet :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a HEAD request comes for the resource
--   path. If <a>resHead</a> is Nothing, the system runs <a>resGet</a>
--   instead. If <a>resGet</a> is also Nothing, the system responds "405
--   Method Not Allowed" for HEAD requests.
resHead :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a POST request comes for the resource
--   path. If <a>resPost</a> is Nothing, the system responds "405 Method
--   Not Allowed" for POST requests.
resPost :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a PUT request comes for the resource
--   path. If <a>resPut</a> is Nothing, the system responds "405 Method Not
--   Allowed" for PUT requests.
resPut :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a DELETE request comes for the
--   resource path. If <a>resDelete</a> is Nothing, the system responds
--   "405 Method Not Allowed" for DELETE requests.
resDelete :: ResourceDef -> !Maybe (Resource ())

-- | <a>emptyResource</a> is a resource definition with no actual handlers.
--   You can construct a <a>ResourceDef</a> by selectively overriding
--   <a>emptyResource</a>. It is defined as follows:
--   
--   <pre>
--   emptyResource = ResourceDef {
--                     resUsesNativeThread = False
--                   , resIsGreedy         = False
--                   , resGet              = Nothing
--                   , resHead             = Nothing
--                   , resPost             = Nothing
--                   , resPut              = Nothing
--                   , resDelete           = Nothing
--                   }
--   </pre>
emptyResource :: ResourceDef

-- | <a>ResTree</a> is an opaque structure which is a map from resource
--   path to <a>ResourceDef</a>.
data ResTree

-- | <a>FallbackHandler</a> is an extra resource handler for resources
--   which can't be statically located somewhere in the resource tree. The
--   Lucu httpd first search for a resource in the tree, and then call
--   fallback handlers to ask them for a resource. If all of the handlers
--   returned <a>Nothing</a>, the httpd responds with 404 Not Found.
type FallbackHandler = [String] -> IO (Maybe ResourceDef)

-- | <a>mkResTree</a> converts a list of <tt>(path, def)</tt> to a
--   <a>ResTree</a> e.g.
--   
--   <pre>
--   mkResTree [ ([]        , <tt>Network.HTTP.Lucu.StaticFile.staticFile</tt> "/usr/include/stdio.h" ) -- /
--             , (["unistd"], <tt>Network.HTTP.Lucu.StaticFile.staticFile</tt> "/usr/include/unistd.h") -- /unistd
--             ]
--   </pre>
mkResTree :: [([String], ResourceDef)] -> ResTree


-- | Handling static files on the filesystem.
module Network.HTTP.Lucu.StaticFile

-- | <tt><a>staticFile</a> fpath</tt> is a <a>ResourceDef</a> which serves
--   the file at <tt>fpath</tt> on the filesystem.
staticFile :: FilePath -> ResourceDef

-- | Computation of <tt><a>handleStaticFile</a> fpath</tt> serves the file
--   at <tt>fpath</tt> on the filesystem. The <a>Resource</a> must be in
--   the /Examining Request<i> state before the computation. It will be in
--   the </i>Done/ state after the computation.
--   
--   If you just want to place a static file on the <a>ResTree</a>, you had
--   better use <a>staticFile</a> instead of this.
handleStaticFile :: FilePath -> Resource ()

-- | <tt><a>staticDir</a> dir</tt> is a <a>ResourceDef</a> which maps all
--   files in <tt>dir</tt> and its subdirectories on the filesystem to the
--   <a>ResTree</a>.
staticDir :: FilePath -> ResourceDef

-- | Computation of <tt><a>handleStaticDir</a> dir</tt> maps all files in
--   <tt>dir</tt> and its subdirectories on the filesystem to the
--   <a>ResTree</a>. The <a>Resource</a> must be in the /Examining
--   Request<i> state before the computation. It will be in the </i>Done/
--   state after the computation.
--   
--   If you just want to place a static directory tree on the
--   <a>ResTree</a>, you had better use <a>staticDir</a> instead of this.
handleStaticDir :: FilePath -> Resource ()

-- | Computation of <tt><a>generateETagFromFile</a> fpath</tt> generates a
--   strong entity tag from a file. The file doesn't necessarily have to be
--   a regular file; it may be a FIFO or a device file. The tag is made of
--   inode ID, size and modification time.
--   
--   Note that the tag is not strictly strong because the file could be
--   modified twice at a second without changing inode ID or size, but it's
--   not really possible to generate a strict strong ETag from a file since
--   we don't want to simply grab the entire file and use it as an ETag. It
--   is indeed possible to hash it with SHA-1 or MD5 to increase
--   strictness, but it's too inefficient if the file is really large (say,
--   1 TiB).
generateETagFromFile :: FilePath -> IO ETag


-- | The entry point of Lucu httpd.
module Network.HTTP.Lucu.Httpd

-- | <a>FallbackHandler</a> is an extra resource handler for resources
--   which can't be statically located somewhere in the resource tree. The
--   Lucu httpd first search for a resource in the tree, and then call
--   fallback handlers to ask them for a resource. If all of the handlers
--   returned <a>Nothing</a>, the httpd responds with 404 Not Found.
type FallbackHandler = [String] -> IO (Maybe ResourceDef)

-- | This is the entry point of Lucu httpd. It listens to a socket and
--   waits for clients. Computation of <a>runHttpd</a> never stops by
--   itself so the only way to stop it is to raise an exception in the
--   thread computing it.
--   
--   Note that <a>runHttpd</a> automatically makes SIGPIPE be ignored by
--   computing <tt><a>installHandler</a> <a>sigPIPE</a> <a>Ignore</a>
--   <a>Nothing</a></tt>. This can hardly cause a problem but it may do.
--   
--   Example:
--   
--   <pre>
--   module Main where
--   import Network.HTTP.Lucu
--   
--   main :: IO ()
--   main = let config    = defaultConfig
--              resources = mkResTree [ ([], helloWorld) ]
--          in
--            runHttpd config resourcees []
--   
--   helloWorld :: ResourceDef
--   helloWorld = ResourceDef {
--                  resUsesNativeThread = False
--                , resIsGreedy         = False
--                , resGet
--                    = Just $ do setContentType $ read "text/plain"
--                                output "Hello, world!"
--                , resHead   = Nothing
--                , resPost   = Nothing
--                , resPut    = Nothing
--                , resDelete = Nothing
--                }
--   </pre>
runHttpd :: Config -> ResTree -> [FallbackHandler] -> IO ()


-- | Lucu is an HTTP daemonic library. It can be embedded in any Haskell
--   program and runs in an independent thread.
--   
--   Features:
--   
--   <ul>
--   <li><i><i>Full support of HTTP\</i>1.1/</i> Lucu supports request
--   pipelining, chunked I/O, ETag comparison and "100 Continue".</li>
--   <li><i><i>Performance</i></i> Lucu doesn't fork/exec to handle
--   requests like CGI. It just spawns a new thread. Inter-process
--   communication is done with STM.</li>
--   <li><i><i>Affinity for RESTafarians</i></i> Lucu is a carefully
--   designed web server for RESTful applications.</li>
--   <li><i><i>SSL connections</i></i> Lucu can handle HTTP connections
--   over SSL layer.</li>
--   </ul>
--   
--   Lucu is not a replacement for Apache or lighttpd. It is intended to be
--   used to create an efficient web-based RESTful application without
--   messing around FastCGI. It is also intended to be run behind a
--   reverse-proxy so it doesn't have the following (otherwise essential)
--   facilities:
--   
--   <ul>
--   <li><i><i>Logging</i></i> Lucu doesn't log any requests from any
--   clients.</li>
--   <li><i><i>Client Filtering</i></i> Lucu always accepts any clients. No
--   IP filter is implemented.</li>
--   <li><i><i>Bandwidth Limitting</i></i> Lucu doesn't limit bandwidth it
--   consumes.</li>
--   <li><i><i>Protection Against Wicked Clients</i></i> Lucu is fragile
--   against wicked clients. No attacker should be able to cause a
--   buffer-overflow but can possibly DoS it.</li>
--   </ul>
module Network.HTTP.Lucu

-- | This is the entry point of Lucu httpd. It listens to a socket and
--   waits for clients. Computation of <a>runHttpd</a> never stops by
--   itself so the only way to stop it is to raise an exception in the
--   thread computing it.
--   
--   Note that <a>runHttpd</a> automatically makes SIGPIPE be ignored by
--   computing <tt><a>installHandler</a> <a>sigPIPE</a> <a>Ignore</a>
--   <a>Nothing</a></tt>. This can hardly cause a problem but it may do.
--   
--   Example:
--   
--   <pre>
--   module Main where
--   import Network.HTTP.Lucu
--   
--   main :: IO ()
--   main = let config    = defaultConfig
--              resources = mkResTree [ ([], helloWorld) ]
--          in
--            runHttpd config resourcees []
--   
--   helloWorld :: ResourceDef
--   helloWorld = ResourceDef {
--                  resUsesNativeThread = False
--                , resIsGreedy         = False
--                , resGet
--                    = Just $ do setContentType $ read "text/plain"
--                                output "Hello, world!"
--                , resHead   = Nothing
--                , resPost   = Nothing
--                , resPut    = Nothing
--                , resDelete = Nothing
--                }
--   </pre>
runHttpd :: Config -> ResTree -> [FallbackHandler] -> IO ()

-- | <a>ResourceDef</a> is basically a set of <a>Resource</a> monads for
--   each HTTP methods.
data ResourceDef
ResourceDef :: !Bool -> !Bool -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> !Maybe (Resource ()) -> ResourceDef

-- | Whether to run a <a>Resource</a> on a native thread (spawned by
--   <a>forkOS</a>) or to run it on a user thread (spanwed by
--   <a>forkIO</a>). Generally you don't need to set this field to
--   <a>True</a>.
resUsesNativeThread :: ResourceDef -> !Bool

-- | Whether to be greedy or not.
--   
--   Say a client is trying to access /aaa/bbb/ccc. If there is a greedy
--   resource at /aaa/bbb, it is always chosen even if there is another
--   resource at /aaa/bbb/ccc. If the resource at /aaa/bbb is not greedy,
--   it is just ignored. Greedy resources are like CGI scripts.
resIsGreedy :: ResourceDef -> !Bool

-- | A <a>Resource</a> to be run when a GET request comes for the resource
--   path. If <a>resGet</a> is Nothing, the system responds "405 Method Not
--   Allowed" for GET requests.
--   
--   It also runs for HEAD request if the <a>resHead</a> is Nothing. In
--   this case <a>output</a> and such like don't actually write a response
--   body.
resGet :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a HEAD request comes for the resource
--   path. If <a>resHead</a> is Nothing, the system runs <a>resGet</a>
--   instead. If <a>resGet</a> is also Nothing, the system responds "405
--   Method Not Allowed" for HEAD requests.
resHead :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a POST request comes for the resource
--   path. If <a>resPost</a> is Nothing, the system responds "405 Method
--   Not Allowed" for POST requests.
resPost :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a PUT request comes for the resource
--   path. If <a>resPut</a> is Nothing, the system responds "405 Method Not
--   Allowed" for PUT requests.
resPut :: ResourceDef -> !Maybe (Resource ())

-- | A <a>Resource</a> to be run when a DELETE request comes for the
--   resource path. If <a>resDelete</a> is Nothing, the system responds
--   "405 Method Not Allowed" for DELETE requests.
resDelete :: ResourceDef -> !Maybe (Resource ())

-- | <a>emptyResource</a> is a resource definition with no actual handlers.
--   You can construct a <a>ResourceDef</a> by selectively overriding
--   <a>emptyResource</a>. It is defined as follows:
--   
--   <pre>
--   emptyResource = ResourceDef {
--                     resUsesNativeThread = False
--                   , resIsGreedy         = False
--                   , resGet              = Nothing
--                   , resHead             = Nothing
--                   , resPost             = Nothing
--                   , resPut              = Nothing
--                   , resDelete           = Nothing
--                   }
--   </pre>
emptyResource :: ResourceDef

-- | <a>ResTree</a> is an opaque structure which is a map from resource
--   path to <a>ResourceDef</a>.
data ResTree

-- | <a>mkResTree</a> converts a list of <tt>(path, def)</tt> to a
--   <a>ResTree</a> e.g.
--   
--   <pre>
--   mkResTree [ ([]        , <tt>Network.HTTP.Lucu.StaticFile.staticFile</tt> "/usr/include/stdio.h" ) -- /
--             , (["unistd"], <tt>Network.HTTP.Lucu.StaticFile.staticFile</tt> "/usr/include/unistd.h") -- /unistd
--             ]
--   </pre>
mkResTree :: [([String], ResourceDef)] -> ResTree

-- | This is the definition of HTTP status code.
--   <tt>Network.HTTP.Lucu.Resource.setStatus</tt> accepts these named
--   statuses so you don't have to memorize, for instance, that "Gateway
--   Timeout" is 504.
data StatusCode
Continue :: StatusCode
SwitchingProtocols :: StatusCode
Processing :: StatusCode
Ok :: StatusCode
Created :: StatusCode
Accepted :: StatusCode
NonAuthoritativeInformation :: StatusCode
NoContent :: StatusCode
ResetContent :: StatusCode
PartialContent :: StatusCode
MultiStatus :: StatusCode
MultipleChoices :: StatusCode
MovedPermanently :: StatusCode
Found :: StatusCode
SeeOther :: StatusCode
NotModified :: StatusCode
UseProxy :: StatusCode
TemporaryRedirect :: StatusCode
BadRequest :: StatusCode
Unauthorized :: StatusCode
PaymentRequired :: StatusCode
Forbidden :: StatusCode
NotFound :: StatusCode
MethodNotAllowed :: StatusCode
NotAcceptable :: StatusCode
ProxyAuthenticationRequired :: StatusCode
RequestTimeout :: StatusCode
Conflict :: StatusCode
Gone :: StatusCode
LengthRequired :: StatusCode
PreconditionFailed :: StatusCode
RequestEntityTooLarge :: StatusCode
RequestURITooLarge :: StatusCode
UnsupportedMediaType :: StatusCode
RequestRangeNotSatisfiable :: StatusCode
ExpectationFailed :: StatusCode
UnprocessableEntitiy :: StatusCode
Locked :: StatusCode
FailedDependency :: StatusCode
InternalServerError :: StatusCode
NotImplemented :: StatusCode
BadGateway :: StatusCode
ServiceUnavailable :: StatusCode
GatewayTimeout :: StatusCode
HttpVersionNotSupported :: StatusCode
InsufficientStorage :: StatusCode

-- | Computation of <tt><a>abort</a> status headers msg</tt> aborts the
--   <tt>Network.HTTP.Lucu.Resource.Resource</tt> monad with given status,
--   additional response headers, and optional message string.
--   
--   What this really does is to throw a special <a>Exception</a>. The
--   exception will be caught by the Lucu system.
--   
--   <ol>
--   <li>If the <tt>Network.HTTP.Lucu.Resource.Resource</tt> is in the
--   /Deciding Header/ or any precedent states, it is possible to use the
--   <tt>status</tt> and such like as a HTTP response to be sent to the
--   client.</li>
--   <li>Otherwise the HTTP response can't be modified anymore so the only
--   possible thing the system can do is to dump it to the stderr. See
--   <a>cnfDumpTooLateAbortionToStderr</a>.</li>
--   </ol>
--   
--   Note that the status code doesn't have to be an error code so you can
--   use this action for redirection as well as error reporting e.g.
--   
--   <pre>
--   abort MovedPermanently
--         [("Location", "http://example.net/")]
--         (Just "It has been moved to example.net")
--   </pre>
abort :: MonadIO m => StatusCode -> [(String, String)] -> Maybe String -> m a

-- | This is similar to <a>abort</a> but computes it with
--   <a>unsafePerformIO</a>.
abortPurely :: StatusCode -> [(String, String)] -> Maybe String -> a

-- | Computation of <tt><a>abortA</a> -&lt; (status, (headers, msg))</tt>
--   just computes <a>abort</a> in an <a>ArrowIO</a>.
abortA :: ArrowIO a => a (StatusCode, ([(String, String)], Maybe String)) c

-- | An entity tag is made of a weakness flag and a opaque string.
data ETag
ETag :: !Bool -> !String -> ETag

-- | The weakness flag. Weak tags looks like W/"blahblah" and strong tags
--   are like "blahblah".
etagIsWeak :: ETag -> !Bool

-- | An opaque string. Only characters from 0x20 (sp) to 0x7e (~) are
--   allowed.
etagToken :: ETag -> !String

-- | This is equivalent to <tt><a>ETag</a> <a>False</a></tt>. If you want
--   to generate an ETag from a file, try using
--   <tt>Network.HTTP.Lucu.StaticFile.generateETagFromFile</tt>.
strongETag :: String -> ETag

-- | This is equivalent to <tt><a>ETag</a> <a>True</a></tt>.
weakETag :: String -> ETag

-- | <tt><a>MIMEType</a> "major" "minor" [("name", "value")]</tt>
--   represents "major/minor; name=value".
data MIMEType
MIMEType :: !String -> !String -> ![(String, String)] -> MIMEType
mtMajor :: MIMEType -> !String
mtMinor :: MIMEType -> !String
mtParams :: MIMEType -> ![(String, String)]

-- | Authorization challenge to be sent to client with "WWW-Authenticate"
--   header. See <tt>Network.HTTP.Lucu.Resource.setWWWAuthenticate</tt>.
data AuthChallenge
BasicAuthChallenge :: Realm -> AuthChallenge

-- | Authorization credential to be sent by client with "Authorization"
--   header. See <tt>Network.HTTP.Lucu.Resource.getAuthorization</tt>.
data AuthCredential
BasicAuthCredential :: UserID -> Password -> AuthCredential
