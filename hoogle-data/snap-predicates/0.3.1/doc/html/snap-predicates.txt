-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Declarative routing for Snap.
--   
--   Provides the definition of a predicate type-class together with
--   several concrete implementations which are used to constrain the set
--   of possible Snap handlers in a type-safe way.
@package snap-predicates
@version 0.3.1

module Snap.Predicate.Types
data CSV a
list :: CSV a -> [a]
instance Typeable1 CSV
instance Eq a => Eq (CSV a)
instance Ord a => Ord (CSV a)
instance Read a => Read (CSV a)
instance Show a => Show (CSV a)
instance Functor CSV
instance Monad CSV
instance MonadPlus CSV
instance Applicative CSV
instance Alternative CSV
instance Monoid (CSV a)
instance Readable a => Readable (CSV a)

module Snap.Predicate.Tutorial

module Snap.Predicate.MediaType

-- | Type-class for converting a <a>ByteString</a> to a media-type.
class (Show a, Eq a) => MType a
toType :: MType a => a -> ByteString -> Maybe a

-- | Type-class for converting a <a>ByteString</a> to a media-subtype.
class (Show a, Eq a) => MSubType a
toSubType :: MSubType a => a -> ByteString -> Maybe a

-- | The Media-type representation.
data MediaType t s
MediaType :: !t -> !s -> !Double -> ![(ByteString, ByteString)] -> MediaType t s
_type :: MediaType t s -> !t
_subtype :: MediaType t s -> !s
_quality :: MediaType t s -> !Double
_params :: MediaType t s -> ![(ByteString, ByteString)]

-- | Generic media-type.
data Type
Type :: ByteString -> Type

-- | media-type and sub-type "*".
data All
All :: All
data Application
Application :: Application
data Audio
Audio :: Audio
data Image
Image :: Image
data Message
Message :: Message
data Multipart
Multipart :: Multipart
data Text
Text :: Text
data Video
Video :: Video

-- | Generic media-subtype.
data SubType
SubType :: ByteString -> SubType
data AtomXml
AtomXml :: AtomXml
data Css
Css :: Css
data Csv
Csv :: Csv
data Encrypted
Encrypted :: Encrypted
data FormData
FormData :: FormData
data FormUrlEncoded
FormUrlEncoded :: FormUrlEncoded
data Gif
Gif :: Gif
data Gzip
Gzip :: Gzip
data Javascript
Javascript :: Javascript
data Jpeg
Jpeg :: Jpeg
data Json
Json :: Json
data Mixed
Mixed :: Mixed
data Mp4
Mp4 :: Mp4
data Mpeg
Mpeg :: Mpeg
data OctetStream
OctetStream :: OctetStream
data Ogg
Ogg :: Ogg
data Partial
Partial :: Partial
data Pkcs12
Pkcs12 :: Pkcs12
data Pkcs7Cert
Pkcs7Cert :: Pkcs7Cert
data Pkcs7Sig
Pkcs7Sig :: Pkcs7Sig
data Pkcs7Mime
Pkcs7Mime :: Pkcs7Mime
data Pkcs7CertRqRs
Pkcs7CertRqRs :: Pkcs7CertRqRs
data Plain
Plain :: Plain
data Png
Png :: Png
data Postscript
Postscript :: Postscript
data Protobuf
Protobuf :: Protobuf
data RdfXml
RdfXml :: RdfXml
data RssXml
RssXml :: RssXml
data Tar
Tar :: Tar
data Tiff
Tiff :: Tiff
data Thrift
Thrift :: Thrift
data Vorbis
Vorbis :: Vorbis
data Webm
Webm :: Webm
data XhtmlXml
XhtmlXml :: XhtmlXml
data Xml
Xml :: Xml
instance (Eq t, Eq s) => Eq (MediaType t s)
instance (Show t, Show s) => Show (MediaType t s)
instance Eq Type
instance Eq Application
instance Eq Audio
instance Eq Image
instance Eq Message
instance Eq Multipart
instance Eq Text
instance Eq Video
instance Eq SubType
instance Eq AtomXml
instance Eq Css
instance Eq Csv
instance Eq Encrypted
instance Eq FormData
instance Eq FormUrlEncoded
instance Eq Gif
instance Eq Gzip
instance Eq Javascript
instance Eq Jpeg
instance Eq Json
instance Eq Mixed
instance Eq Mp4
instance Eq Mpeg
instance Eq OctetStream
instance Eq Ogg
instance Eq Partial
instance Eq Pkcs12
instance Eq Pkcs7Cert
instance Eq Pkcs7Sig
instance Eq Pkcs7Mime
instance Eq Pkcs7CertRqRs
instance Eq Plain
instance Eq Png
instance Eq Postscript
instance Eq Protobuf
instance Eq RdfXml
instance Eq RssXml
instance Eq Tar
instance Eq Tiff
instance Eq Thrift
instance Eq Vorbis
instance Eq Webm
instance Eq XhtmlXml
instance Eq Xml
instance Eq All
instance Show All
instance MSubType All
instance MType All
instance Show Xml
instance MSubType Xml
instance Show XhtmlXml
instance MSubType XhtmlXml
instance Show Webm
instance MSubType Webm
instance Show Vorbis
instance MSubType Vorbis
instance Show Thrift
instance MSubType Thrift
instance Show Tiff
instance MSubType Tiff
instance Show Tar
instance MSubType Tar
instance Show RssXml
instance MSubType RssXml
instance Show RdfXml
instance MSubType RdfXml
instance Show Protobuf
instance MSubType Protobuf
instance Show Postscript
instance MSubType Postscript
instance Show Png
instance MSubType Png
instance Show Plain
instance MSubType Plain
instance Show Pkcs7CertRqRs
instance MSubType Pkcs7CertRqRs
instance Show Pkcs7Mime
instance MSubType Pkcs7Mime
instance Show Pkcs7Sig
instance MSubType Pkcs7Sig
instance Show Pkcs7Cert
instance MSubType Pkcs7Cert
instance Show Pkcs12
instance MSubType Pkcs12
instance Show Partial
instance MSubType Partial
instance Show Ogg
instance MSubType Ogg
instance Show OctetStream
instance MSubType OctetStream
instance Show Mpeg
instance MSubType Mpeg
instance Show Mp4
instance MSubType Mp4
instance Show Mixed
instance MSubType Mixed
instance Show Json
instance MSubType Json
instance Show Jpeg
instance MSubType Jpeg
instance Show Javascript
instance MSubType Javascript
instance Show Gzip
instance MSubType Gzip
instance Show Gif
instance MSubType Gif
instance Show FormUrlEncoded
instance MSubType FormUrlEncoded
instance Show FormData
instance MSubType FormData
instance Show Encrypted
instance MSubType Encrypted
instance Show Csv
instance MSubType Csv
instance Show Css
instance MSubType Css
instance Show AtomXml
instance MSubType AtomXml
instance Show SubType
instance MSubType SubType
instance Show Video
instance MType Video
instance Show Text
instance MType Text
instance Show Multipart
instance MType Multipart
instance Show Message
instance MType Message
instance Show Image
instance MType Image
instance Show Audio
instance MType Audio
instance Show Application
instance MType Application
instance Show Type
instance MType Type

module Snap.Predicate.Error

-- | The error type used as <tt>F</tt> meta-data in all snap predicates.
data Error
Error :: !Word -> !(Maybe ByteString) -> Error

-- | (HTTP) status code
_status :: Error -> !Word

-- | optional status message
_message :: Error -> !(Maybe ByteString)

-- | Convenience function to construct <a>Error</a> values from status code
--   and status message.
err :: Word -> ByteString -> Error
instance Eq Error
instance Show Error

module Data.Predicate.Env

-- | An environment for predicates, consisting of mappings form
--   <a>ByteString</a>s to <a>Dynamic</a> values.
data Env

-- | An empty environment.
empty :: Env

-- | Try to get the associated value for the given key. Only successful
--   iff, (i) <a>Env</a> contains a binding for <tt>k</tt> and (ii) the
--   type of value and target match.
lookup :: (MonadState m, StateType m ~ Env, Typeable a) => ByteString -> m (Maybe a)

-- | Add a binding from key to value to <a>Env</a>, overriding previous
--   bindings if existing.
insert :: (MonadState m, StateType m ~ Env, Typeable a) => ByteString -> a -> m ()

module Data.Predicate

-- | <a>Delta</a> is a measure of distance. It is (optionally) used in
--   predicates that evaluate to <a>T</a> but not uniquely so, i.e.
--   different evaluations of <a>T</a> are possible and they may have a
--   different "fitness".
--   
--   An example is content-negotiation. A HTTP request may specify a
--   preference list of various media-types. A predicate matching one
--   specific media-type evaluates to <a>T</a>, but other media-types may
--   match even better. To represent this ambivalence, the predicate will
--   include a delta value which can be used to decide which of the
--   matching predicates should be preferred.
type Delta = Double

-- | A <a>Bool</a>-like type where each branch <a>T</a>rue or <a>F</a>alse
--   carries some meta-data which is threaded through <a>Predicate</a>
--   evaluation.
data Boolean f t

-- | logical False with some meta-data
F :: f -> Boolean f t

-- | logical True with some meta-data
T :: Delta -> t -> Boolean f t

-- | The <a>Predicate</a> class declares the function <a>apply</a> which
--   evaluates the predicate against some value, returning a value of type
--   <a>Boolean</a>. Besides being parameterised over predicate type and
--   predicate parameter, the class is also parameterised over the actual
--   types of T's and F's meta-data.
class Predicate p a where type family FVal p type family TVal p
apply :: Predicate p a => p -> a -> State Env (Boolean (FVal p) (TVal p))

-- | A <a>Predicate</a> instance which always returns <a>T</a> with the
--   given value as T's meta-data.
data Const f t
Const :: t -> Const f t

-- | A <a>Predicate</a> instance which always returns <a>F</a> with the
--   given value as F's meta-data.
data Fail f t
Fail :: f -> Fail f t

-- | A <a>Predicate</a> instance corresponding to the logical OR connective
--   of two <a>Predicate</a>s. It requires the meta-data of each
--   <a>T</a>rue branch to be of the same type.
--   
--   If both arguments evaluate to <a>T</a> the one with the smaller
--   <a>Delta</a> will be preferred, or--if equal--the left-hand argument.
data (:|:) a b
(:|:) :: a -> b -> :|: a b
type (:+:) a b = Either a b

-- | A <a>Predicate</a> instance corresponding to the logical OR connective
--   of two <a>Predicate</a>s. The meta-data of each <a>T</a>rue branch can
--   be of different types.
--   
--   If both arguments evaluate to <a>T</a> the one with the smaller
--   <a>Delta</a> will be preferred, or--if equal--the left-hand argument.
data (:||:) a b
(:||:) :: a -> b -> :||: a b

-- | Data-type used for tupling-up the results of <a>:&amp;:</a>.
data (:*:) a b
(:*:) :: a -> b -> :*: a b

-- | A <a>Predicate</a> instance corresponding to the logical AND
--   connective of two <a>Predicate</a>s.
data (:&:) a b
(:&:) :: a -> b -> :&: a b

-- | Evaluate the given predicate <tt>p</tt> against the given value
--   <tt>a</tt>.
eval :: Predicate p a => p -> a -> Boolean (FVal p) (TVal p)

-- | The <a>with</a> function will invoke the given function only if the
--   predicate <tt>p</tt> applied to the test value <tt>a</tt> evaluates to
--   <a>T</a>.
with :: (Monad m, Predicate p a) => p -> a -> (TVal p -> m ()) -> m ()
instance (Eq f, Eq t) => Eq (Boolean f t)
instance (Show f, Show t) => Show (Boolean f t)
instance (Eq a, Eq b) => Eq (a :*: b)
instance (Show a, Show b) => Show (a :*: b)
instance (Show a, Show b) => Show (a :&: b)
instance (Predicate a c, Predicate b c, FVal a ~ FVal b) => Predicate (a :&: b) c
instance (Show a, Show b) => Show (a :||: b)
instance (Predicate a c, Predicate b c, FVal a ~ FVal b) => Predicate (a :||: b) c
instance (Show a, Show b) => Show (a :|: b)
instance (Predicate a c, Predicate b c, TVal a ~ TVal b, FVal a ~ FVal b) => Predicate (a :|: b) c
instance Show f => Show (Fail f t)
instance Predicate (Fail f t) a
instance Show t => Show (Const f t)
instance Predicate (Const f t) a

module Snap.Predicate.Param

-- | The most generic request parameter predicate provided. It will get all
--   request parameter values of <tt>_name</tt> and pass them on to the
--   conversion function <tt>_read</tt>, which might either yield an error
--   message or a value. If the parameter is not present, an optional
--   default may be returned instead, if nothing is provided, the error
--   message will be used when construction the 400 status.
data Parameter a
Parameter :: !ByteString -> ([ByteString] -> Either ByteString a) -> !(Maybe a) -> Parameter a

-- | request parameter name
_pName :: Parameter a -> !ByteString

-- | conversion function
_pRead :: Parameter a -> [ByteString] -> Either ByteString a

-- | (optional) default value
_pDefault :: Parameter a -> !(Maybe a)

-- | Specialisation of <a>Parameter</a> which returns the first request
--   parameter which could be converted to the target type. Relies on
--   <a>Readable</a> type-class for the actual conversion.
data Param a
Param :: ByteString -> Param a

-- | Predicate which returns the first request parameter which could be
--   converted to the target type wrapped in a Maybe. If the parameter is
--   not present, <a>Nothing</a> will be returned. Relies on
--   <a>Readable</a> type-class for the actual conversion.
data ParamOpt a
ParamOpt :: ByteString -> ParamOpt a

-- | Specialisation of <a>Parameter</a> which returns the first request
--   parameter which could be converted to the target type. If the
--   parameter is not present, the provided default will be used. Relies on
--   <a>Readable</a> type-class for the actual conversion.
data ParamDef a
ParamDef :: ByteString -> a -> ParamDef a

-- | Predicate which is true if the request has a parameter with the given
--   name.
data HasParam
HasParam :: ByteString -> HasParam
instance Show HasParam
instance Predicate HasParam Request
instance Show (ParamOpt a)
instance (Typeable a, Readable a) => Predicate (ParamOpt a) Request
instance Show a => Show (ParamDef a)
instance (Typeable a, Readable a) => Predicate (ParamDef a) Request
instance Show (Param a)
instance (Typeable a, Readable a) => Predicate (Param a) Request
instance Show (Parameter a)
instance Typeable a => Predicate (Parameter a) Request

module Snap.Predicate.Header

-- | The most generic request header predicate provided. It will get all
--   request header values of <tt>_name</tt> and pass them on to the
--   conversion function <tt>_read</tt>, which might either yield an error
--   message or a value. If the header is not present, an optional default
--   may be returned instead, if nothing is provided, the error message
--   will be used when construction the 400 status.
data Header a
Header :: !ByteString -> ([ByteString] -> Either ByteString a) -> !(Maybe a) -> Header a

-- | request header name
_hdrName :: Header a -> !ByteString

-- | conversion function
_hdrRead :: Header a -> [ByteString] -> Either ByteString a

-- | (optional) default value
_hdrDefault :: Header a -> !(Maybe a)

-- | Specialisation of <a>Header</a> which returns the first request header
--   value which could be converted to the target type. Relies on
--   <a>Readable</a> type-class for the actual conversion.
data Hdr a
Hdr :: ByteString -> Hdr a

-- | Predicate which returns the first request header which could be
--   converted to the target type wrapped in a Maybe. If the header is not
--   present, <a>Nothing</a> will be returned. Relies on <a>Readable</a>
--   type-class for the actual conversion.
data HdrOpt a
HdrOpt :: ByteString -> HdrOpt a

-- | Specialisation of <a>Header</a> which returns the first request header
--   value which could be converted to the target type. If the header is
--   not present, the provided default will be used. Relies on
--   <a>Readable</a> type-class for the actual conversion.
data HdrDef a
HdrDef :: ByteString -> a -> HdrDef a

-- | Predicate which is true if the request has a header with the given
--   name.
data HasHdr
HasHdr :: ByteString -> HasHdr
instance Show HasHdr
instance Predicate HasHdr Request
instance Show (HdrOpt a)
instance (Typeable a, Readable a) => Predicate (HdrOpt a) Request
instance Show a => Show (HdrDef a)
instance (Typeable a, Readable a) => Predicate (HdrDef a) Request
instance Show (Hdr a)
instance (Typeable a, Readable a) => Predicate (Hdr a) Request
instance Show (Header a)
instance Typeable a => Predicate (Header a) Request

module Snap.Predicate.Accept

-- | A <a>Predicate</a> against the <a>Request</a>s "Accept" header.
data Accept t s
Accept :: t -> s -> Accept t s
instance (Eq t, Eq s) => Eq (Accept t s)
instance (Show t, Show s) => Show (Accept t s)
instance (MType t, MSubType s) => Predicate (Accept t s) Request

module Snap.Predicate.Content
type Content x y = MediaType x y

-- | A <a>Predicate</a> against the <a>Request</a>s "Content-Type" header.
data ContentType t s
ContentType :: t -> s -> ContentType t s
instance (Eq t, Eq s) => Eq (ContentType t s)
instance (Show t, Show s) => Show (ContentType t s)
instance (MType t, MSubType s) => Predicate (ContentType t s) Request

module Snap.Predicate

module Snap.Route

-- | The Routes monad is used to add routing declarations via
--   <a>addRoute</a> or one of <a>get</a>, <a>post</a>, etc. Routing
--   declarations can then be turned into the ordinary snap format, i.e.
--   <tt>MonadSnap m =&gt; [(ByteString, m a)]</tt> or into strings.
data Routes m a

-- | Turn route definitions into a list of <a>String</a>s.
showRoutes :: Routes m () -> [String]

-- | Turn route definitions into "snapable" format, i.e. Routes are grouped
--   per path and selection evaluates routes against the given Snap
--   <a>Request</a>.
expandRoutes :: MonadSnap m => Routes m () -> [(ByteString, m ())]
renderErrorWith :: Monad m => Renderer -> Routes m ()

-- | Add a route for some <a>Method</a> and path (potentially with variable
--   captures), and constrained the some <a>Predicate</a>.
addRoute :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => Method -> ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
get :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
get_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
head :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
head_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
post :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
post_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
put :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
put_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
delete :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
delete_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
trace :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
trace_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
options :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
options_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>.
connect :: (MonadSnap m, Show p, Predicate p Request, FVal p ~ Error) => ByteString -> (TVal p -> m ()) -> p -> Routes m ()

-- | Specialisation of <a>addRoute</a> for a specific HTTP <a>Method</a>
--   taking no <a>Predicate</a> into consideration.
connect_ :: MonadSnap m => ByteString -> (() -> m ()) -> Routes m ()
instance Monad (Routes m)
