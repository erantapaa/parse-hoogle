-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tools for specifying and parsing configurations
--   
@package configuration-tools
@version 0.2.13


-- | This module contains a <tt>Setup.hs</tt> script that hooks into the
--   cabal build process at the end of the configuration phase and
--   generates a module with package information for each component of the
--   cabal package.
--   
--   The modules are created in the <i>autogen</i> build directory where
--   also the <tt>Path_</tt> module is created by cabal's simple build
--   setup. This is usually the directory <tt>./dist/build/autogen</tt>.
--   
--   For a library component the module is named just <tt>PkgInfo</tt>. For
--   all other components the module is named
--   <tt>PkgInfo_COMPONENT_NAME</tt> where <tt>COMPONENT_NAME</tt> is the
--   name of the component with <tt>-</tt> characters replaced by
--   <tt>_</tt>.
--   
--   For instance, if a cabal package contains a library and an executable
--   that is called <i>my-app</i>, the following modules are created:
--   <tt>PkgInfo</tt> and <tt>PkgInfo_my_app</tt>.
--   
--   <h1>Usage as Setup Script</h1>
--   
--   There are three ways how this module can be used:
--   
--   <ol>
--   <li>Copy the code of this module into a file called <tt>Setup.hs</tt>
--   in the root directory of your package.</li>
--   <li>If the <i>configuration-tools</i> package is already installed in
--   the system where the build is done, following code can be used as
--   <tt>Setup.hs</tt> script:<pre>module Main (main) where import
--   Configuration.Utils.Setup</pre></li>
--   <li>For usage within a more complex <tt>Setup.hs</tt> script you shall
--   import this module qualified and use the <a>mkPkgInfoModules</a>
--   function. For example:<pre>module Main (main) where import qualified
--   Configuration.Utils.Setup as ConfTools main :: IO () main =
--   defaultMainWithHooks (ConfTools.mkPkgInfoModules simpleUserHooks)
--   </pre></li>
--   </ol>
--   
--   With all methods the field <tt>Build-Type</tt> in the package
--   description (cabal) file must be set to <tt>Custom</tt>:
--   
--   <pre>
--   Build-Type: Custom
--   </pre>
--   
--   <h1>Integration With <a>Configuration.Utils</a></h1>
--   
--   You can integrate the information provided by the <tt>PkgInfo</tt>
--   modules with the command line interface of an application by importing
--   the respective module for the component and using the
--   <a>runWithPkgInfoConfiguration</a> function from the module
--   <a>Configuration.Utils</a> as show in the following example:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE FlexibleInstances #-}
--   
--   module Main
--   ( main
--   ) where
--   
--   import Configuration.Utils
--   import PkgInfo
--   
--   instance FromJSON (() -&gt; ()) where parseJSON _ = pure id
--   
--   mainInfo :: ProgramInfo ()
--   mainInfo = programInfo "Hello World" (pure id) ()
--   
--   main :: IO ()
--   main = runWithPkgInfoConfiguration mainInfo pkgInfo . const $ putStrLn "hello world"
--   </pre>
--   
--   With that the resulting application supports the following additional
--   command line options:
--   
--   <ul>
--   <li><i><tt>--version</tt>, <tt>-v</tt></i> prints the version of the
--   application and exits.</li>
--   <li><i><tt>--info</tt>, <tt>-i</tt></i> prints a short info message
--   for the application and exits.</li>
--   <li><i><tt>--long-info</tt></i> print a detailed info message for the
--   application and exits. Beside component name, package name, version,
--   revision, and copyright the message also contain information about the
--   compiler that was used for the build, the build architecture, build
--   flags, the author, the license type, and a list of all direct and
--   indirect dependencies along with their licenses and copyrights.</li>
--   <li><i><tt>--license</tt></i> prints the text of the lincense of the
--   application and exits.</li>
--   </ul>
module Configuration.Utils.Setup

-- | Include this function when your setup doesn't contain any extra
--   functionality.
main :: IO ()

-- | Modifies the given record of hooks by adding functionality that
--   creates a package info module for each component of the cabal package.
--   
--   This function is intended for usage in more complex <tt>Setup.hs</tt>
--   scripts. If your setup doesn't contain any other function you can just
--   import the <a>main</a> function from this module.
--   
--   The modules are created in the <i>autogen</i> build directory where
--   also the <tt>Path_</tt> module is created by cabal's simple build
--   setup. This is usually the directory <tt>./dist/build/autogen</tt>.
--   
--   For a library component the module is named just <tt>PkgInfo</tt>. For
--   all other components the module is named
--   <tt>PkgInfo_COMPONENT_NAME</tt> where <tt>COMPONENT_NAME</tt> is the
--   name of the component with <tt>-</tt> characters replaced by
--   <tt>_</tt>.
mkPkgInfoModules :: UserHooks -> UserHooks


module Configuration.Utils.Internal
lens :: (σ -> α) -> (σ -> β -> τ) -> Lens σ τ α β
over :: ((α -> Identity β) -> σ -> Identity τ) -> (α -> β) -> σ -> τ
set :: ((α -> Identity β) -> σ -> Identity τ) -> β -> σ -> τ
view :: MonadReader σ μ => ((α -> Const α α) -> σ -> Const α σ) -> μ α

-- | This is the same type as the type from the lens library with the same
--   name.
--   
--   In case it is already import from the lens package this should be
--   hidden from the import.
type Lens' σ α = Lens σ σ α α

-- | This is the same type as the type from the lens library with the same
--   name.
--   
--   In case it is already import from the lens package this should be
--   hidden from the import.
type Lens σ τ α β = forall φ. Functor φ => (α -> φ β) -> σ -> φ τ
type Iso' σ α = Iso σ σ α α

-- | This is the same type as the type from the lens library with the same
--   name.
--   
--   In case it is already import from the lens package this should be
--   hidden from the import.
type Iso σ τ α β = forall π φ. (Profunctor π, Functor φ) => π α (φ β) -> π σ (φ τ)
iso :: (σ -> α) -> (β -> τ) -> Iso σ τ α β
(&) :: α -> (α -> β) -> β
(<&>) :: Functor φ => φ α -> (α -> β) -> φ β
sshow :: (Show α, IsString τ) => α -> τ
exceptT :: Monad μ => (ε -> μ β) -> (α -> μ β) -> ExceptT ε μ α -> μ β
errorT :: Monad μ => ExceptT Text μ α -> μ α
fmapL :: (α -> β) -> Either α γ -> Either β γ


-- | Utilities for validating configuration values
module Configuration.Utils.Validation

-- | A validation function. The type in the <a>MonadWriter</a> is excpected
--   to be a <tt>Foldable</tt> structure for collecting warnings.
type ConfigValidation α λ = forall μ. (MonadIO μ, Functor μ, Applicative μ, MonadError Text μ, MonadWriter (λ Text) μ) => α -> μ ()

-- | Validates that a value is an HTTP or HTTPS URL
validateHttpOrHttpsUrl :: MonadError Text m => Text -> String -> m ()

-- | Validates that a value is an HTTP URL
validateHttpUrl :: MonadError Text m => Text -> String -> m ()

-- | Validates that a value is an HTTPS URL
validateHttpsUrl :: MonadError Text m => Text -> String -> m ()

-- | Validates that a value is an URI without a fragment identifier
validateUri :: MonadError Text m => Text -> String -> m ()

-- | Validates that a value is an absolute URI without a fragment
--   identifier
validateAbsoluteUri :: MonadError Text m => Text -> String -> m ()

-- | Validates that a value is an absolute URI with an optional fragment
--   identifier
validateAbsoluteUriFragment :: MonadError Text m => Text -> String -> m ()
validateIPv4 :: MonadError Text m => Text -> String -> m ()
validateIPv6 :: MonadError Text m => Text -> String -> m ()
validatePort :: (MonadError Text m, Integral n, Show n) => Text -> n -> m ()
validateNonEmpty :: (MonadError Text m, Eq α, Monoid α) => Text -> α -> m ()
validateLength :: (MonadError Text m, Foldable φ) => Text -> Int -> φ α -> m ()
validateMinLength :: (MonadError Text m, Foldable φ) => Text -> Int -> φ α -> m ()
validateMaxLength :: (MonadError Text m, Foldable φ) => Text -> Int -> φ α -> m ()
validateMinMaxLength :: (MonadError Text m, Foldable φ) => Text -> Int -> Int -> φ α -> m ()
validateFilePath :: MonadError Text m => Text -> FilePath -> m ()
validateFile :: (MonadError Text m, MonadIO m) => Text -> FilePath -> m ()
validateFileReadable :: (MonadError Text m, MonadIO m) => Text -> FilePath -> m ()
validateFileWritable :: (MonadError Text m, MonadIO m) => Text -> FilePath -> m ()

-- | Validates if the given executable name can be found in the system and
--   can be executed.
validateExecutable :: (Functor m, MonadError Text m, MonadIO m) => Text -> FilePath -> m ()
validateDirectory :: (MonadError Text m, MonadIO m) => Text -> FilePath -> m ()

-- | Validate that the input is a config file
validateConfigFile :: (MonadIO m, MonadError Text m) => String -> m ()
validateFalse :: MonadError Text m => Text -> Bool -> m ()
validateTrue :: MonadError Text m => Text -> Bool -> m ()
validateBool :: MonadError Text m => Text -> Bool -> Bool -> m ()
validateNonNegative :: (MonadError Text m, Ord α, Num α) => Text -> α -> m ()
validatePositive :: (MonadError Text m, Ord α, Num α) => Text -> α -> m ()
validateNonPositive :: (MonadError Text m, Ord α, Num α) => Text -> α -> m ()
validateNegative :: (MonadError Text m, Ord α, Num α) => Text -> α -> m ()
validateNonNull :: (MonadError Text m, Eq α, Num α) => Text -> α -> m ()
validateLess :: (MonadError Text m, Ord α, Show α) => Text -> α -> α -> m ()
validateLessEq :: (MonadError Text m, Ord α, Show α) => Text -> α -> α -> m ()
validateGreater :: (MonadError Text m, Ord α, Show α) => Text -> α -> α -> m ()
validateGreaterEq :: (MonadError Text m, Ord α, Show α) => Text -> α -> α -> m ()
validateRange :: (MonadError Text m, Ord α, Show α) => Text -> (α, α) -> α -> m ()


-- | This module provides tools for defining Maybe configuration types.
module Configuration.Utils.Maybe

-- | Command line parser for record <a>Maybe</a> values
--   
--   <h2>Example:</h2>
--   
--   <pre>
--   data Setting = Setting
--       { _setA ∷ !Int
--       , _setB ∷ !String
--       }
--       deriving (Show, Read, Eq, Ord, Typeable)
--   
--   $(makeLenses ''Setting)
--   
--   defaultSetting ∷ Setting
--   defaultSetting = Setting
--       { _setA = 0
--       , _setB = 1
--       }
--   
--   instance ToJSON Setting where
--       toJSON setting = object
--          [ "a" .= _setA setting
--          , "b" .= _setB setting
--          ]
--   
--   instance FromJSON (Setting → Setting) where
--       parseJSON = withObject "Setting" $ \o → id
--           &lt;$&lt; setA ..: "a" % o
--           &lt;*&lt; setB ..: "b" % o
--   
--   instance FromJSON Setting where
--      parseJSON v = parseJSON v &lt;*&gt; pure defaultSetting
--   
--   pSetting ∷ MParser Setting
--   pSetting = id
--       &lt;$&lt; setA .:: option auto
--           % short 'a'
--           &lt;&gt; metavar "INT"
--           &lt;&gt; help "set a"
--       &lt;*&lt; setB .:: option auto
--           % short 'b'
--           &lt;&gt; metavar "INT"
--           &lt;&gt; help "set b"
--   
--   -- | Use 'Setting' as 'Maybe' in a configuration:
--   --
--   data Config = Config
--       { _maybeSetting ∷ !(Maybe Setting)
--       }
--       deriving (Show, Read, Eq, Ord, Typeable)
--   
--   $(makeLenses ''Config)
--   
--   defaultConfig ∷ Config
--   defaultConfig = Config
--       { _maybeSetting = defaultSetting
--       }
--   
--   instance ToJSON Config where
--       toJSON config = object
--           [ "setting" .= maybeSetting
--           ]
--   
--   instance FromJSON (Config → Config) where
--       parseJSON = withObject "Config" $ \o → id
--           &lt;$&lt; maybeSetting %.: "setting" % o
--   
--   pConfig ∷ MParser Config
--   pConfig = id
--       &lt;$&lt; maybeSetting %:: (maybeOption defaultSetting
--           &lt;$&gt; pEnableSetting
--           &lt;*&gt; pSetting)
--     where
--       pEnableSetting = boolOption
--           % long "setting-enable"
--           &lt;&gt; value False
--           &lt;&gt; help "Enable configuration flags for setting"
--   </pre>
maybeOption :: a -> Bool -> (a -> a) -> Maybe a -> Maybe a
instance (FromJSON (a -> a), FromJSON a) => FromJSON (Maybe a -> Maybe a)


-- | Useful operators for defining functions in an applicative context
module Configuration.Utils.Operators

-- | This operator is an alternative for <a>$</a> with a higher precedence.
--   It is suitable for usage within applicative style code without the
--   need to add parenthesis.
(%) :: (α -> β) -> α -> β

-- | This operator is a UTF-8 version of <a>%</a> which is an alternative
--   for <a>$</a> with a higher precedence. It is suitable for usage within
--   applicative style code without the need to add parenthesis.
--   
--   The hex value of the UTF-8 character × is 0x00d7.
--   
--   In VIM type: <tt>Ctrl-V u 00d7</tt>
--   
--   You may also define a key binding by adding something like the
--   following line to your vim configuration file:
--   
--   <pre>
--   iabbrev &lt;buffer&gt; &gt;&lt; ×
--   </pre>
(×) :: (α -> β) -> α -> β

-- | Functional composition for applicative functors.
(<*<) :: Applicative φ => φ (β -> γ) -> φ (α -> β) -> φ (α -> γ)

-- | Functional composition for applicative functors with its arguments
--   flipped.
(>*>) :: Applicative φ => φ (α -> β) -> φ (β -> γ) -> φ (α -> γ)

-- | Applicative functional composition between a pure function and an
--   applicative function.
(<$<) :: Functor φ => (β -> γ) -> φ (α -> β) -> φ (α -> γ)

-- | Applicative functional composition between a pure function and an
--   applicative function with its arguments flipped.
(>$>) :: Functor φ => φ (α -> β) -> (β -> γ) -> φ (α -> γ)

-- | Functional composition for applicative functors.
--   
--   This is a rather popular operator. Due to conflicts (for instance with
--   the lens package) it may have to be imported qualified.

-- | <i>Deprecated: use <a>&lt;*&lt;</a> instead</i>
(<.>) :: Applicative φ => φ (β -> γ) -> φ (α -> β) -> φ (α -> γ)

-- | For people who like nicely aligned code and do not mind messing with
--   editor key-maps: here a version of <a>&lt;.&gt;</a> that uses a
--   unicode symbol
--   
--   The hex value of the UTF-8 character ⊙ is 0x2299.
--   
--   A convenient VIM key-map is:
--   
--   <pre>
--   iabbrev &lt;buffer&gt; ../ ⊙
--   </pre>

-- | <i>Deprecated: use <a>&lt;*&lt;</a> instead</i>
(⊙) :: Applicative φ => φ (β -> γ) -> φ (α -> β) -> φ (α -> γ)


-- | This module provides tools for defining command line parsers for
--   configuration types.
--   
--   Unlike <i>normal</i> command line parsers the parsers for
--   configuration types are expected to yield an update function that
--   takes a value and updates the value with the settings from the command
--   line.
--   
--   Assuming that
--   
--   <ul>
--   <li>all configuration types are nested Haskell records or simple types
--   and</li>
--   <li>that there are lenses for all record fields</li>
--   </ul>
--   
--   usually the operators <a>.::</a> and <a>%::</a> are all that is needed
--   from this module.
--   
--   The module <a>Configuration.Utils.Monoid</a> provides tools for the
--   case that a <i>simple type</i> is a container with a monoid instance,
--   such as <tt>List</tt> or <tt>HashMap</tt>.
--   
--   The module <a>Configuration.Utils.Maybe</a> explains the usage of
--   optional <a>Maybe</a> values in configuration types.
module Configuration.Utils.CommandLine

-- | Type of option parsers that yield a modification function.
type MParser α = Parser (α -> α)

-- | An operator for applying a setter to an option parser that yields a
--   value.
--   
--   Example usage:
--   
--   <pre>
--   data Auth = Auth
--       { _user ∷ !String
--       , _pwd ∷ !String
--       }
--   
--   user ∷ Functor φ ⇒ (String → φ String) → Auth → φ Auth
--   user f s = (\u → s { _user = u }) &lt;$&gt; f (_user s)
--   
--   pwd ∷ Functor φ ⇒ (String → φ String) → Auth → φ Auth
--   pwd f s = (\p → s { _pwd = p }) &lt;$&gt; f (_pwd s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''Auth)
--   
--   pAuth ∷ MParser Auth
--   pAuth = id
--      &lt;$&lt; user .:: strOption
--          × long "user"
--          ⊕ short 'u'
--          ⊕ help "user name"
--      &lt;*&lt; pwd .:: strOption
--          × long "pwd"
--          ⊕ help "password for user"
--   </pre>
(.::) :: (Alternative φ, Applicative φ) => Lens' α β -> φ β -> φ (α -> α)

-- | An operator for applying a setter to an option parser that yields a
--   modification function.
--   
--   Example usage:
--   
--   <pre>
--   data HttpURL = HttpURL
--       { _auth ∷ !Auth
--       , _domain ∷ !String
--       }
--   
--   auth ∷ Functor φ ⇒ (Auth → φ Auth) → HttpURL → φ HttpURL
--   auth f s = (\u → s { _auth = u }) &lt;$&gt; f (_auth s)
--   
--   domain ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   domain f s = (\u → s { _domain = u }) &lt;$&gt; f (_domain s)
--   
--   path ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   path f s = (\u → s { _path = u }) &lt;$&gt; f (_path s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''HttpURL)
--   
--   pHttpURL ∷ MParser HttpURL
--   pHttpURL = id
--       &lt;$&lt; auth %:: pAuth
--       &lt;*&lt; domain .:: strOption
--           × long "domain"
--           ⊕ short 'd'
--           ⊕ help "HTTP domain"
--   </pre>
(%::) :: (Alternative φ, Applicative φ) => Lens' α β -> φ (β -> β) -> φ (α -> α)
boolReader :: (Eq a, Show a, FoldCase a, IsString a, IsString e, Monoid e) => a -> Either e Bool

-- | The <a>boolOption</a> is an alternative to <a>switch</a>.
--   
--   Using <a>switch</a> with command line parsers that overwrite settings
--   from a configuration file is problematic: the absence of the
--   <a>switch</a> is interpreted as setting the respective configuration
--   value to <a>False</a>. So there is no way to specify on the command
--   line that the value from the configuration file shall be used. Some
--   command line UIs use two different options for those values, for
--   instance <tt>--enable-feature</tt> and <tt>--disable-feature</tt>.
--   This option instead expects a Boolean value. Beside that it behaves
--   like any other option.
boolOption :: Mod OptionFields Bool -> Parser Bool

-- | An alternative syntax for <a>boolOption</a> for options with long
--   names.
--   
--   Instead of taking a boolean argument the presence of the option acts
--   as a switch to set the respective configuration setting to
--   <a>True</a>. If the option is not present the setting is left
--   unchanged.
--   
--   In addition for long option names a respective <i>unset flag</i> is
--   provided. For instance for a flag <tt>--verbose</tt> there will also
--   be a flag <tt>--no-verbose</tt>.
--   
--   This can still be used with short option names only, but no <i>unset
--   flag</i> would be provided.
boolOption_ :: Mod FlagFields Bool -> Parser Bool

-- | An option parser for flags that are enabled via the flag name prefixed
--   with <tt>--enable-</tt> and disabled via the flag name prefix
--   <tt>--disable-</tt>. The prefixes are applied to all long option
--   names. Short option names are parsed unchanged and and cause the flag
--   to be enabled.
--   
--   This resembles the style of flags that is used for instances with
--   Cabal.
enableDisableFlag :: Mod FlagFields Bool -> Parser Bool
fileOption :: Mod OptionFields String -> Parser FilePath
eitherReadP :: Text -> ReadP a -> Text -> Either Text a


-- | The distinction between appending on the left and appending on the
--   right is important for monoids that are sensitive to ordering such as
--   <tt>List</tt>. It is also of relevance for monoids with set semantics
--   with non-extensional equality such as <tt>HashMap</tt>.
module Configuration.Utils.Monoid

-- | Update a value by appending on the left. Under normal circumstances
--   you'll never use this type directly but only its <a>FromJSON</a>
--   instance. See the <a>leftMonoidalUpdate</a> for an example.
data LeftMonoidalUpdate α

-- | Update a value by appending on the left.
--   
--   <pre>
--   newtype RoutingTable = RoutingTable { _routingTableMap ∷ HashMap T.Text T.Text }
--   
--   $(makeLenses ''RoutingTable)
--   
--   instance FromJSON (RoutingTable → RoutingTable) where
--       parseJSON = withObject "RoutingTable" $ \o → id
--           &lt;$&lt; routingTableMap . from leftMonoidalUpdate %.: "route_map" % o
--   </pre>
leftMonoidalUpdate :: Iso (LeftMonoidalUpdate α) (LeftMonoidalUpdate β) α β

-- | This is the same as <tt>from leftMonoidalUpdate</tt> but doesn't
--   depend on the lens Library.
fromLeftMonoidalUpdate :: Iso α β (LeftMonoidalUpdate α) (LeftMonoidalUpdate β)

-- | Update a value by appending on the left.
--   
--   <pre>
--   newtype RoutingTable = RoutingTable { _routingTableMap ∷ HashMap T.Text T.Text }
--   
--   $(makeLenses ''RoutingTable)
--   
--   pRoutingTable ∷ MParser RoutingTable
--   pRoutingTable = routingTableMap %:: pLeftMonoidalUpdate pRoute
--     where
--       pRoute = option (eitherReader readRoute)
--           % long "route"
--           &lt;&gt; help "add a route to the routing table; the APIROUTE part must not contain a colon character"
--           &lt;&gt; metavar "APIROUTE:APIURL"
--   
--       readRoute s = case break (== ':') s of
--           (a,':':b) → fmapL T.unpack $ do
--               validateNonEmpty "APIROUTE" a
--               validateHttpOrHttpsUrl "APIURL" b
--               return $ HM.singleton (T.pack a) (T.pack b)
--           _ → Left "missing colon between APIROUTE and APIURL"
--   
--       fmapL f = either (Left . f) Right
--   </pre>
pLeftMonoidalUpdate :: Monoid α => Parser α -> MParser α

-- | Update a value by appending on the right. Under normal circumstances
--   you'll never use this type directly but only its <a>FromJSON</a>
--   instance. See the <a>leftMonoidalUpdate</a> for an example.
data RightMonoidalUpdate α

-- | Update a value by appending on the right. See
--   <a>leftMonoidalUpdate</a> for an usage example.
rightMonoidalUpdate :: Iso (RightMonoidalUpdate α) (RightMonoidalUpdate β) α β

-- | This is the same as <tt>from rightMonoidalUpdate</tt> but doesn't
--   depend on the lens Library.
fromRightMonoidalUpdate :: Iso α β (RightMonoidalUpdate α) (RightMonoidalUpdate β)

-- | Update a value by appending on the right. See
--   <a>pLeftMonoidalUpdate</a> for an usage example.
pRightMonoidalUpdate :: Monoid α => Parser α -> MParser α
instance Monoid α => Monoid (LeftMonoidalUpdate α)
instance Monoid α => Monoid (RightMonoidalUpdate α)
instance (FromJSON α, Monoid α) => FromJSON (RightMonoidalUpdate α -> RightMonoidalUpdate α)
instance (FromJSON α, Monoid α) => FromJSON (LeftMonoidalUpdate α -> LeftMonoidalUpdate α)


-- | This module provides means for defining and using HTTPS certificate
--   validation polices for HTTPS requests.
module Configuration.Utils.Internal.HttpsCertPolicy
data HttpsCertPolicy
HttpsCertPolicy :: !Bool -> !(HashMap ServiceID Fingerprint) -> HttpsCertPolicy

-- | disable certificate validation
_certPolicyInsecure :: HttpsCertPolicy -> !Bool

-- | a whitelist for services with trusted certificates
_certPolicyHostFingerprints :: HttpsCertPolicy -> !(HashMap ServiceID Fingerprint)
certPolicyInsecure :: Lens' HttpsCertPolicy Bool
certPolicyHostFingerprints :: Lens' HttpsCertPolicy (HashMap ServiceID Fingerprint)
defaultHttpsCertPolicy :: HttpsCertPolicy
pHttpsCertPolicy :: Text -> MParser HttpsCertPolicy

-- | Make an HTTP request with a given certificate validation policy.
--   
--   NOTE that the HTTP request is strictly loaded into memory.
--   
--   NOTE that this implementation opens a new TCP connection for each
--   single request. HTTPS certificates validation results are not cached
--   between different requests.
simpleHttpWithValidationPolicy :: Text -> HttpsCertPolicy -> IO (Response ByteString)
httpWithValidationPolicy :: Request -> HttpsCertPolicy -> IO (Response ByteString)

-- | The Haskell <tt>tls</tt> library provides only limited means for
--   providing user friendly error messages. In particular we'd like to
--   provide the user with fingerprints of the reject certificate for
--   self-signed certificates. Also we want to provide the user with some
--   guidance what a particular failure may indicate with respect to
--   security of the connection.
--   
--   Here we employ a <i>hack</i> for better error handling: Based on the
--   assumption that we initialize a new connection <tt>Manager</tt> and
--   also a new certificate cache for each request, we write the
--   certificate that is received from the server in the TLS handshake to
--   an <a>IORef</a>. If the handshakes fails later on because the
--   certificate is rejected we can recover the rejected certificate from
--   the <a>IORef</a>.
--   
--   What we really want are exceptions that can be consumed
--   programatically. In particular exceptions should include rejected
--   certificates.
newtype VerboseTlsException
VerboseTlsException :: Text -> VerboseTlsException
instance Typeable HttpsCertPolicy
instance Typeable VerboseTlsException
instance Show HttpsCertPolicy
instance Eq HttpsCertPolicy
instance Eq VerboseTlsException
instance Ord VerboseTlsException
instance Exception VerboseTlsException
instance Show VerboseTlsException


-- | This module provides tools for defining configuration file parsers via
--   instances of <a>FromJSON</a>.
--   
--   Unlike <i>normal</i> <a>FromJSON</a> instances the parsers for
--   configuration files are expected to yield an update function that
--   takes a value and updates the value with the settings from the
--   configuration file.
--   
--   Assuming that
--   
--   <ul>
--   <li>all configuration types are nested Haskell records or simple types
--   and</li>
--   <li>that there are lenses for all record fields</li>
--   </ul>
--   
--   usually the operators <a>..:</a> and <a>%.:</a> are all that is needed
--   from this module.
--   
--   The module <a>Configuration.Utils.Monoid</a> provides tools for the
--   case that a <i>simple type</i> is a container with a monoid instance,
--   such as <tt>List</tt> or <tt>HashMap</tt>.
--   
--   The module <a>Configuration.Utils.Maybe</a> explains the usage of
--   optional <a>Maybe</a> values in configuration types.
module Configuration.Utils.ConfigFile

-- | A JSON <a>Value</a> parser for a property of a given <a>Object</a>
--   that updates a setter with the parsed value.
--   
--   <pre>
--   data Auth = Auth
--       { _userId ∷ !Int
--       , _pwd ∷ !String
--       }
--   
--   userId ∷ Functor φ ⇒ (Int → φ Int) → Auth → φ Auth
--   userId f s = (\u → s { _userId = u }) &lt;$&gt; f (_userId s)
--   
--   pwd ∷ Functor φ ⇒ (String → φ String) → Auth → φ Auth
--   pwd f s = (\p → s { _pwd = p }) &lt;$&gt; f (_pwd s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''Auth)
--   
--   instance FromJSON (Auth → Auth) where
--       parseJSON = withObject "Auth" $ \o → id
--           &lt;$&lt; setProperty user "user" p o
--           &lt;*&lt; setProperty pwd "pwd" parseJSON o
--         where
--           p = withText "user" $ \case
--               "alice" → pure (0 ∷ Int)
--               "bob" → pure 1
--               e → fail $ "unrecognized user " ⊕ e
--   </pre>
setProperty :: Lens' α β -> Text -> (Value -> Parser β) -> Object -> Parser (α -> α)

-- | A variant of the <a>setProperty</a> that uses the default
--   <a>parseJSON</a> method from the <a>FromJSON</a> instance to parse the
--   value of the property. Its usage pattern mimics the usage pattern of
--   the <a>.:</a> operator from the aeson library.
--   
--   <pre>
--   data Auth = Auth
--       { _user ∷ !String
--       , _pwd ∷ !String
--       }
--   
--   user ∷ Functor φ ⇒ (String → φ String) → Auth → φ Auth
--   user f s = (\u → s { _user = u }) &lt;$&gt; f (_user s)
--   
--   pwd ∷ Functor φ ⇒ (String → φ String) → Auth → φ Auth
--   pwd f s = (\p → s { _pwd = p }) &lt;$&gt; f (_pwd s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''Auth)
--   
--   instance FromJSON (Auth → Auth) where
--       parseJSON = withObject "Auth" $ \o → id
--           &lt;$&lt; user ..: "user" × o
--           &lt;*&lt; pwd ..: "pwd" × o
--   </pre>
(..:) :: FromJSON β => Lens' α β -> Text -> Object -> Parser (α -> α)

-- | This operator requires that a value is explicitly provided in a
--   configuration file, thus preventing the default value from being used.
--   Otherwise this operator does the same as '(..:)'.
(!..:) :: FromJSON β => Lens' α β -> Text -> Object -> Parser (α -> α)

-- | A JSON parser for a function that modifies a property of a given
--   <a>Object</a> and updates a setter with the parsed function.
--   
--   <pre>
--   data HttpURL = HttpURL
--       { _auth ∷ !Auth
--       , _domain ∷ !String
--       }
--   
--   auth ∷ Functor φ ⇒ (Auth → φ Auth) → HttpURL → φ HttpURL
--   auth f s = (\u → s { _auth = u }) &lt;$&gt; f (_auth s)
--   
--   domain ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   domain f s = (\u → s { _domain = u }) &lt;$&gt; f (_domain s)
--   
--   path ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   path f s = (\u → s { _path = u }) &lt;$&gt; f (_path s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''HttpURL)
--   
--   instance FromJSON (HttpURL → HttpURL) where
--       parseJSON = withObject "HttpURL" $ \o → id
--           &lt;$&lt; auth %.: "auth" × o
--           &lt;*&lt; domain ..: "domain" × o
--   </pre>
updateProperty :: Lens' α β -> Text -> (Value -> Parser (β -> β)) -> Object -> Parser (α -> α)

-- | A variant of <a>updateProperty</a> that used the <a>FromJSON</a>
--   instance for the update function. It mimics the aeson operator
--   <a>.:</a>. It creates a parser that modifies a setter with a parsed
--   function.
--   
--   <pre>
--   data HttpURL = HttpURL
--       { _auth ∷ !Auth
--       , _domain ∷ !String
--       }
--   
--   auth ∷ Functor φ ⇒ (Auth → φ Auth) → HttpURL → φ HttpURL
--   auth f s = (\u → s { _auth = u }) &lt;$&gt; f (_auth s)
--   
--   domain ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   domain f s = (\u → s { _domain = u }) &lt;$&gt; f (_domain s)
--   
--   path ∷ Functor φ ⇒ (String → φ String) → HttpURL → φ HttpURL
--   path f s = (\u → s { _path = u }) &lt;$&gt; f (_path s)
--   
--   -- or with lenses and TemplateHaskell just:
--   -- $(makeLenses ''HttpURL)
--   
--   instance FromJSON (HttpURL → HttpURL) where
--       parseJSON = withObject "HttpURL" $ \o → id
--           &lt;$&lt; auth %.: "auth" × o
--           &lt;*&lt; domain ..: "domain" × o
--   </pre>
(%.:) :: FromJSON (β -> β) => Lens' α β -> Text -> Object -> Parser (α -> α)
data ConfigFile
ConfigFileRequired :: !Text -> ConfigFile
getConfigFile :: ConfigFile -> !Text
ConfigFileOptional :: !Text -> ConfigFile
getConfigFile :: ConfigFile -> !Text

-- | An <i>internal</i> type for the meta configuration that specifies how
--   the configuration files are loaded and parsed.
data ConfigFilesConfig
ConfigFilesConfig :: !HttpsCertPolicy -> ConfigFilesConfig
_cfcHttpsPolicy :: ConfigFilesConfig -> !HttpsCertPolicy
cfcHttpsPolicy :: Lens' ConfigFilesConfig HttpsCertPolicy
defaultConfigFilesConfig :: ConfigFilesConfig
pConfigFilesConfig :: MParser ConfigFilesConfig
dropAndUncaml :: Int -> String -> String
instance Typeable ConfigFile
instance Typeable ConfigFilesConfig
instance Show ConfigFile
instance Read ConfigFile
instance Eq ConfigFile
instance Ord ConfigFile
instance Show ConfigFilesConfig
instance Eq ConfigFilesConfig


module Configuration.Utils.Internal.ConfigFileReader
parseConfigFiles :: (ConfigFileParser μ, FromJSON (α -> α)) => ConfigFilesConfig -> α -> [ConfigFile] -> μ α
readConfigFile :: (ConfigFileParser μ, FromJSON (α -> α)) => ConfigFilesConfig -> ConfigFile -> μ (α -> α)
data ConfigFileFormat
Yaml :: ConfigFileFormat
Json :: ConfigFileFormat
Other :: ConfigFileFormat
loadLocal :: (Functor μ, MonadIO μ, MonadError Text μ, FromJSON (α -> α)) => ConfigFile -> μ (α -> α)
isRemote :: ConfigFile -> Bool
loadRemote :: (ConfigFileParser μ, FromJSON (α -> α)) => ConfigFilesConfig -> ConfigFile -> μ (α -> α)
yamlMimeType :: IsString s => [s]

-- | Defined in RFC 4627
jsonMimeType :: IsString s => [s]
contentType :: ByteString -> ConfigFileFormat
requestHeaders :: Lens' Request RequestHeaders
instance Typeable ConfigFileFormat
instance Show ConfigFileFormat
instance Read ConfigFileFormat
instance Eq ConfigFileFormat
instance Ord ConfigFileFormat
instance Enum ConfigFileFormat
instance Bounded ConfigFileFormat
instance Generic ConfigFileFormat
instance Datatype D1ConfigFileFormat
instance Constructor C1_0ConfigFileFormat
instance Constructor C1_1ConfigFileFormat
instance Constructor C1_2ConfigFileFormat
instance NFData ConfigFileFormat


-- | This module provides a collection of utilities on top of the packages
--   optparse-applicative, aeson, and yaml, for configuring libraries and
--   applications in a composable way.
--   
--   The main feature is the integration of command line option parsing and
--   configuration files.
--   
--   The purpose is to make management of configurations easy by providing
--   an idiomatic style of defining and deploying configurations in a
--   modular and composable way.
--   
--   <h1>Usage</h1>
--   
--   The module provides operators and functions that make the
--   implementation of these entities easy for the common case that the
--   configurations are encoded mainly as nested records.
--   
--   For each data type that is used as as component in a configuration
--   type the following must be provided:
--   
--   <ol>
--   <li>a <i>default value</i>,</li>
--   <li>a <i><a>FromJSON</a> instance</i> that yields a function that
--   takes a value and updates that value with the parsed values,</li>
--   <li>a <i><a>ToJSON</a> instance</i>, and</li>
--   <li>a <i>command line options parser</i> that yields a function that
--   takes a value and updates that value with the values provided as
--   command line options.</li>
--   </ol>
--   
--   In addition to the above optionally a <i>validation function</i> may
--   be provided that (recursively) validates a configuration value and
--   returns either an error or a (possibly empty) list-like structure of
--   warnings.
--   
--   The modules
--   
--   <ul>
--   <li><a>Configuration.Utils.CommandLine</a>,</li>
--   <li><a>Configuration.Utils.ConfigFile</a>, and</li>
--   <li><a>Configuration.Utils.Operators</a></li>
--   </ul>
--   
--   contain tools and examples for defining above prerequisites for using
--   a type in a configuration type.
--   
--   The provided functions and operators assume that lenses for the
--   configuration record types are provided.
--   
--   The module <a>Configuration.Utils.Monoid</a> provides tools for the
--   case that a <i>simple type</i> is a container with a monoid instance,
--   such as <tt>List</tt> or <tt>HashMap</tt>.
--   
--   The module <a>Configuration.Utils.Maybe</a> explains the usage of
--   optional <a>Maybe</a> values in configuration types.
--   
--   <h1>Usage Example</h1>
--   
--   Beside the examples that are provided in the haddock documentation
--   there is a complete usage example in the file
--   <a>example/Example.hs</a> of the cabal package.
module Configuration.Utils
type ProgramInfo α = ProgramInfoValidate α []

-- | Smart constructor for <a>ProgramInfo</a>.
--   
--   <a>piHelpHeader</a> and <a>piHelpFooter</a> are set to <a>Nothing</a>.
--   The function <a>piValidateConfiguration</a> is set to <tt>const
--   (return [])</tt>
programInfo :: String -> MParser α -> α -> ProgramInfo α

-- | Program Description
piDescription :: Lens' (ProgramInfoValidate α λ) String

-- | Help header
piHelpHeader :: Lens' (ProgramInfoValidate α λ) (Maybe String)

-- | Help footer
piHelpFooter :: Lens' (ProgramInfoValidate α λ) (Maybe String)

-- | Options parser for configuration
piOptionParser :: Lens' (ProgramInfoValidate α λ) (MParser α)

-- | Default configuration
piDefaultConfiguration :: Lens' (ProgramInfoValidate α λ) α

-- | Configuration files that are loaded in order before any command line
--   argument is evaluated.
piConfigurationFiles :: Lens' (ProgramInfoValidate α λ) [ConfigFile]

-- | A validation function. The type in the <a>MonadWriter</a> is excpected
--   to be a <tt>Foldable</tt> structure for collecting warnings.
type ConfigValidation α λ = forall μ. (MonadIO μ, Functor μ, Applicative μ, MonadError Text μ, MonadWriter (λ Text) μ) => α -> μ ()

-- | Smart constructor for <a>ProgramInfo</a>.
--   
--   <a>piHelpHeader</a> and <a>piHelpFooter</a> are set to <a>Nothing</a>.
programInfoValidate :: String -> MParser α -> α -> ConfigValidation α λ -> ProgramInfoValidate α λ

-- | Run an IO action with a configuration that is obtained by updating the
--   given default configuration the values defined via command line
--   arguments.
--   
--   In addition to the options defined by the given options parser the
--   following options are recognized:
--   
--   <ul>
--   <li><i><tt>--config-file, -c</tt></i> Parse the given file path as a
--   (partial) configuration in YAML or JSON format.</li>
--   <li><i><tt>--print-config, -p</tt></i> Print the final parsed
--   configuration to standard out and exit.</li>
--   <li><i><tt>--help, -h</tt></i> Print a help message and exit.</li>
--   </ul>
--   
--   As long as the package wasn't build with <tt>-f-remote-configs</tt>
--   the following two options are available. They affect how configuration
--   files are loaded from remote URLs.
--   
--   <ul>
--   <li><i><tt>--config-https-insecure=true|false</tt></i> Bypass
--   certificate validation for all HTTPS connections to all services.</li>
--   
--   <li><i><tt>--config-https-allow-cert=HOSTNAME:PORT:FINGERPRINT</tt></i>
--   Unconditionally trust the certificate for connecting to the
--   service.</li>
--   </ul>
runWithConfiguration :: (FromJSON (α -> α), ToJSON α, Foldable λ, Monoid (λ Text)) => ProgramInfoValidate α λ -> (α -> IO ()) -> IO ()

-- | Information about the cabal package. The format is:
--   
--   <pre>
--   (info message, detailed info message, version string, license text)
--   </pre>
--   
--   See the documentation of <a>Configuration.Utils.Setup</a> for a way
--   how to generate this information automatically from the package
--   description during the build process.
type PkgInfo = (String, String, String, String)

-- | Run an IO action with a configuration that is obtained by updating the
--   given default configuration the values defined via command line
--   arguments.
--   
--   In addition to the options defined by the given options parser the
--   following options are recognized:
--   
--   <ul>
--   <li><i><tt>--config-file, -c</tt></i> Parse the given file path as a
--   (partial) configuration in YAML or JSON format.</li>
--   <li><i><tt>--print-config, -p</tt></i> Print the final parsed
--   configuration to standard out and exit.</li>
--   <li><i><tt>--help, -h</tt></i> Print a help message and exit.</li>
--   <li><i><tt>--version, -v</tt></i> Print the version of the application
--   and exit.</li>
--   <li><i><tt>--info, -i</tt></i> Print a short info message for the
--   application and exit.</li>
--   <li><i><tt>--long-info</tt></i> Print a detailed info message for the
--   application and exit.</li>
--   <li><i><tt>--license</tt></i> Print the text of the license of the
--   application and exit.</li>
--   </ul>
--   
--   As long as the package wasn't build with <tt>-f-remote-configs</tt>
--   the following two options are available. They affect how configuration
--   files are loaded from remote URLs.
--   
--   <ul>
--   <li><i><tt>--config-https-insecure=true|false</tt></i> Bypass
--   certificate validation for all HTTPS connections to all services.</li>
--   
--   <li><i><tt>--config-https-allow-cert=HOSTNAME:PORT:FINGERPRINT</tt></i>
--   Unconditionally trust the certificate for connecting to the
--   service.</li>
--   </ul>
runWithPkgInfoConfiguration :: (FromJSON (α -> α), ToJSON α, Foldable λ, Monoid (λ Text)) => ProgramInfoValidate α λ -> PkgInfo -> (α -> IO ()) -> IO ()

-- | Parse the command line arguments.
--   
--   Any warnings from the configuration function are discarded. The
--   options <tt>--print-config</tt> and <tt>--help</tt> are just ignored.
parseConfiguration :: (Applicative m, MonadIO m, MonadBaseControl IO m, MonadError Text m, FromJSON (α -> α), ToJSON α, Foldable λ, Monoid (λ Text)) => Text -> ProgramInfoValidate α λ -> [String] -> m α

-- | This is the same type as the type from the lens library with the same
--   name.
--   
--   In case it is already import from the lens package this should be
--   hidden from the import.
type Lens' σ α = Lens σ σ α α

-- | This is the same type as the type from the lens library with the same
--   name.
--   
--   In case it is already import from the lens package this should be
--   hidden from the import.
type Lens σ τ α β = forall φ. Functor φ => (α -> φ β) -> σ -> φ τ
data ProgramInfoValidate α λ

-- | Validation Function
--   
--   The <a>Right</a> result is interpreted as a <a>Foldable</a> structure
--   of warnings.
piValidateConfiguration :: Lens' (ProgramInfoValidate α λ) (ConfigValidationFunction α λ)

-- | A newtype wrapper around a validation function. The only purpose of
--   this type is to avoid <tt>ImpredicativeTypes</tt> when storing the
--   function in the <a>ProgramInfoValidate</a> record.
newtype ConfigValidationFunction α λ
ConfigValidationFunction :: ConfigValidation α λ -> ConfigValidationFunction α λ
runConfigValidation :: ConfigValidationFunction α λ -> ConfigValidation α λ

-- | <a>Lens</a> for simultaneous query and update of <a>piOptionParser</a>
--   and <a>piDefaultConfiguration</a>. This supports to change the type of
--   <a>ProgramInfo</a> with <a>over</a> and <a>set</a>.
piOptionParserAndDefaultConfiguration :: Lens (ProgramInfoValidate α λ) (ProgramInfoValidate β γ) (MParser α, α, ConfigValidationFunction α λ) (MParser β, β, ConfigValidationFunction β γ)

module Configuration.Utils.Http

-- | In order to make TLS optional this type should be used wrapped into a
--   Maybe.
data HttpServiceTLSConfiguration
hstcCertFile :: Lens' HttpServiceTLSConfiguration FilePath
hstcKeyFile :: Lens' HttpServiceTLSConfiguration FilePath
defaultHttpServiceTLSConfiguration :: HttpServiceTLSConfiguration

-- | This option parser does not allow to enable or disable usage of TLS.
--   The option will have effect only when TLS usage is configured in the
--   configuration file or the default configuration.
--   
--   FIXME: print a warning and exit when one of these options is provided
--   even though TLS is turned off.
pHttpServiceTLSConfiguration :: String -> MParser HttpServiceTLSConfiguration
validateHttpServiceTLSConfiguration :: ConfigValidation HttpServiceTLSConfiguration λ

-- | We restrict services to use either HTTP or HTTPS but not both.
--   
--   TLS can be turned off explicitely in the configuration file by setting
--   the respective section to <tt>null</tt>. It can not be turned on or
--   off via command line options. But once it is turned on the values for
--   the certificate and key file can be changed by command line options.
data HttpServiceConfiguration
hscHost :: Lens' HttpServiceConfiguration ByteString
hscPort :: Lens' HttpServiceConfiguration Int
hscUseTLS :: Lens' HttpServiceConfiguration (Maybe HttpServiceTLSConfiguration)
defaultHttpServiceConfiguration :: HttpServiceConfiguration
pHttpServiceConfiguration :: String -> MParser HttpServiceConfiguration
validateHttpServiceConfiguration :: ConfigValidation HttpServiceConfiguration DList
data HttpClientConfiguration
hccHost :: Lens' HttpClientConfiguration ByteString
hccPort :: Lens' HttpClientConfiguration Int
hccUseTLS :: Lens' HttpClientConfiguration Bool
defaultHttpClientConfiguration :: HttpClientConfiguration
pHttpClientConfiguration :: String -> MParser HttpClientConfiguration
validateHttpClientConfiguration :: ConfigValidation HttpClientConfiguration λ
httpService2clientConfiguration :: HttpServiceConfiguration -> HttpClientConfiguration
instance Show HttpServiceTLSConfiguration
instance Read HttpServiceTLSConfiguration
instance Eq HttpServiceTLSConfiguration
instance Ord HttpServiceTLSConfiguration
instance Show HttpServiceConfiguration
instance Read HttpServiceConfiguration
instance Eq HttpServiceConfiguration
instance Ord HttpServiceConfiguration
instance Show HttpClientConfiguration
instance Read HttpClientConfiguration
instance Eq HttpClientConfiguration
instance Ord HttpClientConfiguration
instance ToJSON HttpClientConfiguration
instance FromJSON (HttpClientConfiguration -> HttpClientConfiguration)
instance ToJSON HttpServiceConfiguration
instance FromJSON (HttpServiceConfiguration -> HttpServiceConfiguration)
instance ToJSON HttpServiceTLSConfiguration
instance FromJSON HttpServiceTLSConfiguration
instance FromJSON (HttpServiceTLSConfiguration -> HttpServiceTLSConfiguration)
