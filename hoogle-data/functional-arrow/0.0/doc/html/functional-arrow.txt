-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators that allow for a more functional/monadic style of Arrow programming
--   
--   If you program with Arrows you have two choices: Use the plain Arrow
--   combinators, that are cumbersome to use, or use special Arrow syntax,
--   that is built into all Haskell compilers and is still not very
--   functional programming style. The arrow syntax still forces you to
--   introduce temporary names, that you would not need in a functional
--   notation.
--   
--   Where you would write things like
--   
--   <pre>
--   mix &lt;&lt;&lt; (id &amp;&amp;&amp; delay) &lt;&lt;&lt; lowpass
--   </pre>
--   
--   using plain Arrow combinators, you can now write
--   
--   <pre>
--   lowpass &gt;&gt;&gt;= \x -&gt;
--      mix &lt;&lt;&lt; (listen x &amp;&amp;&amp; (delay &lt;&lt;&lt; listen x))
--   </pre>
--   
--   where the <tt>(&gt;&gt;&gt;=)</tt> resembles the monadic bind and
--   allows you for shared access to an arrow result. Thus it can be used
--   like a <tt>let</tt>.
@package functional-arrow
@version 0.0


-- | This module is an attempt to simplify the use of arrow combinators. If
--   I have <tt>f :: arrow a b</tt>, then subsequent arrows can only access
--   the <tt>b</tt>, but often I also want to access the <tt>a</tt>. Thus I
--   often write
--   
--   <pre>
--   f &amp;&amp;&amp; arr id :: arrow a (b,a)  .
--   </pre>
--   
--   If I repeat this, it yields
--   
--   <pre>
--   g &amp;&amp;&amp; arr id &lt;&lt;&lt; f &amp;&amp;&amp; arr id :: arrow a (c,(b,a))
--   h &amp;&amp;&amp; arr id &lt;&lt;&lt; g &amp;&amp;&amp; arr id &lt;&lt;&lt; f &amp;&amp;&amp; arr id :: arrow a (d,(c,(b,a)))  .
--   </pre>
--   
--   However accessing the particular inputs of type <tt>d</tt>,
--   <tt>c</tt>, <tt>b</tt> from within <tt>h</tt> and <tt>g</tt> is
--   cumbersome. Thus I wrote a little support for this style of arrow
--   programming. First I use <tt>HList</tt> instead of nested pairs. Using
--   type level Peano numbers and reverse <tt>HList</tt> index access I can
--   use the same expression (say <tt>listen x</tt>) in both <tt>g</tt> and
--   <tt>h</tt> although in both contexts they refer to different
--   <tt>HLists</tt>. E.g. <tt>g</tt> expects the <tt>b</tt> input at the
--   <tt>HList</tt> head, whereas <tt>h</tt> gets it one position later.
module Control.Arrow.Monad

-- | This <tt>bind</tt>-like operator allows you to a share an interim
--   arrow result between various following arrow inputs.
--   
--   Instead of
--   
--   <pre>
--   mix &lt;&lt;&lt;  id &amp;&amp;&amp; delay  &lt;&lt;&lt; lowpass
--   </pre>
--   
--   you can write
--   
--   <pre>
--   (\x -&gt; HL.hCons x HL.hNil) ^&gt;&gt;
--   ((HL.hHead ^&gt;&gt; lowpass) &gt;&gt;&gt;= \x -&gt;
--        mix &lt;&lt;&lt;  listen x &amp;&amp;&amp; (delay &lt;&lt;&lt; listen x))
--   </pre>
(>>>=) :: (Arrow arrow, HLength list n) => arrow list a -> (n -> arrow (HCons a list) b) -> arrow list b
(=<<<) :: (Arrow arrow, HLength list n) => (n -> arrow (HCons a list) b) -> arrow list a -> arrow list b
class (HNat x, HNat y, HNat z) => HAdd x y z | x y -> z, x z -> y
listen :: (Arrow arrow, HLength list len, HAdd n m len, HLookupByHNat m list a) => n -> arrow list a
instance HAdd x y z => HAdd (HSucc x) y (HSucc z)
instance HNat x => HAdd HZero x x

module Control.Arrow.Let
class Index t envi envo
ref :: (Index t envi envo, Arrow arr) => arr envi t -> arr envo t
(<<<&) :: Arrow arrow => arrow (b, a) c -> arrow a b -> arrow a c
input :: Arrow arrow => arrow () Int
f :: Arrow arrow => arrow (Int, ()) Char
g :: Arrow arrow => arrow (Char, (Int, ())) Bool
c1 :: Arrow arrow => arrow (Int, ()) Bool
c2 :: Arrow arrow => arrow (Int, ()) Bool
instance [overlap ok] Index t envi envo => Index t envi (h, envo)
instance [overlap ok] Index t envi (t, envi)
