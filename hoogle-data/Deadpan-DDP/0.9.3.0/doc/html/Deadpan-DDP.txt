-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Write clients for Meteor's DDP Protocol
--   
--   The Deadpan-DDP project includes a debugging-tool, as well as a
--   general purpose library.
--   
--   <a>DDP</a> is the protocol that <a>Meteor</a> speaks between client
--   and server.
--   
--   The DDP tech-stack is: Websockets -&gt; JSON -&gt; EJson -&gt;
--   Collections -&gt; Subscriptions + RPC.
--   
--   In order to use the debugging tool, install this package and run
--   <a>deadpan</a> for a usage statement.
--   
--   In order to use the library, simply import <a>Web.DDP.Deadpan</a>.
--   
--   The DSL monad is largely based around RPC calls and callbacks. In
--   order to write an application you would call
--   <a>Web.DDP.Deadpan.runClient</a> with
--   
--   <ul>
--   <li>An initial application state (this includes initial
--   callbacks)</li>
--   <li>A set of connection parameters</li>
--   <li>A <a>Web.DDP.Deadpan.DSL.Deadpan</a> application</li>
--   </ul>
--   
--   There are several callback-sets provided in <a>Web.DDP.Deadpan</a>,
--   however, if you want to pick in a more granular fashion, look inside
--   <a>Web.DDP.Deadpan.Callbacks</a>.
--   
--   The connection parameters are the triple (Domain, Port, Path)...
--   
--   For convenience the function getURI is provided to turn a URI of the
--   form <a>websocket://localhost:3000/websocket</a> into the triple
--   (Right ("localhost", 3000, "websocket"))... or an error (Left "error
--   message").
--   
--   Refer to the <a>README.md</a> on Github for more information.
@package Deadpan-DDP
@version 0.9.3.0


-- | and a Deadpan app into an IO result.
--   
--   A collection of Websocket functions to ease converting a URI and a
--   Deadpan app into an IO result.
--   
--   Intended for internal use.
module Web.DDP.Deadpan.Websockets
type URL = String
type Domain = String
type Port = Int
type Path = String
type Error = String
type Params = (Domain, Port, Path)
(?>>>) :: Maybe x -> Error -> Either Error x
getURI :: String -> Either Error Params

-- | <pre>
--   prop_getURI_full
--   </pre>
prop_getURI_full :: Bool

-- | <pre>
--   prop_getURI_full
--   </pre>
prop_getURI_missingPort :: Bool
execURI :: ClientApp a -> (String, Int, String) -> IO a
setupApp :: ClientApp a -> ClientApp a


-- | Currently EJson functionality is built on top of the <a>Value</a>
--   type.
--   
--   Functions are written to convert back and forth between
--   <a>EJsonValue</a> and <a>Value</a>.
--   
--   The conversion functions from EJsonValue to Value are in a seperate
--   module: <a>Data.EJson.EJson2Value</a>.
--   
--   This has some negative impact on performance, but aids simplicity.
module Data.EJson.EJson
data EJsonValue
EJObject :: !(HashMap Text EJsonValue) -> EJsonValue
EJArray :: !(Vector EJsonValue) -> EJsonValue
EJString :: !Text -> EJsonValue
EJNumber :: !Scientific -> EJsonValue
EJBool :: !Bool -> EJsonValue
EJDate :: !UTCTime -> EJsonValue
EJBinary :: !ByteString -> EJsonValue
EJUser :: !Text -> !EJsonValue -> EJsonValue
EJNull :: EJsonValue
value2EJson :: Value -> EJsonValue
ejobject :: [(Text, EJsonValue)] -> EJsonValue
ejarray :: [EJsonValue] -> EJsonValue
ejstring :: Text -> EJsonValue
ejnumber :: Scientific -> EJsonValue
ejbool :: Bool -> EJsonValue
ejdate :: Scientific -> EJsonValue
ejbinary :: ByteString -> EJsonValue
ejuser :: Text -> EJsonValue -> EJsonValue
ejnull :: EJsonValue
_EJObject :: Prism' EJsonValue (HashMap Text EJsonValue)
_EJObjectKey :: Text -> Traversal' EJsonValue (Maybe EJsonValue)

-- | A helpful prism that looks up values of type EJ{"foo" : "bar", ...}
--   with a Text key "foo" and returns Just "bar", or Nothing. Used
--   frequently for checking message types and ids.
_EJObjectKeyString :: Applicative f => Text -> (Text -> f Text) -> EJsonValue -> f EJsonValue
_EJArray :: Prism' EJsonValue (Vector EJsonValue)
_EJAraryIndex :: Applicative f => Int -> (EJsonValue -> f EJsonValue) -> EJsonValue -> f EJsonValue
_EJString :: Prism' EJsonValue Text
_EJNumber :: Prism' EJsonValue Scientific
_EJBool :: Prism' EJsonValue Bool
_EJDate :: Prism' EJsonValue UTCTime
_EJBinary :: Prism' EJsonValue ByteString
_EJUser :: Prism' EJsonValue (Text, EJsonValue)
_EJNull :: Prism' EJsonValue ()
instance Num EJsonValue
instance Monoid EJsonValue
instance IsString EJsonValue
instance Eq EJsonValue

module Data.EJson.EJson2Value
ejson2value :: EJsonValue -> Value
instance Show EJsonValue


-- | Piggybacks off the <a>Value</a> type.
--   
--   This module provided for the convenience of users who wish to use the
--   EJsonValue datatype in their own projects.
module Data.EJson.Aeson

-- | A FromJSON instance is provided for EJsonValue in order to be able to
--   take advantage of the Aeson functionality.
--   
--   This is not used internally.

-- | A ToJSON instance is provided for EJsonValue in order to be able to
--   take advantage of the Aeson functionality.
--   
--   This is not used internally.
instance ToJSON EJsonValue
instance FromJSON EJsonValue


-- | The DDP protocol uses an extended JSON format called EJSON. This is
--   embedded inside JSON, so that all JSON is valid EJSON, but with
--   certain object structures representing the extended types:
--   
--   <a>https://github.com/meteor/meteor/blob/devel/packages/ddp/DDP.md</a>
--   
--   This module provides a pair of functions, <a>value2EJson</a> and
--   <a>ejson2value</a> that convert back and forth between these
--   datatypes. It also provides the <a>EJsonValue</a> datatype itself.
--   
--   Currently there is no implementation of the usual Aeson conversion
--   classes, but this may change in the future.
--   
--   There are several smart-constructors made available to construct
--   instances of EJsonValue more easily. These match the constructors
--   exactly, except for substituting lists for vectors, etc... These
--   definitions are inlined.
--   
--   EJson functionality is intended to be used simply by importing
--   <a>EJson</a>.
--   
--   The internals of EJson are defined in <a>EJson</a>.
--   
--   Aeson instances are defined in <a>Aeson</a>.
--   
--   This module tests examples and properties using DocTest.
module Data.EJson
decodeText :: Text -> Maybe EJsonValue
decodeString :: String -> Maybe EJsonValue
decodeByteString :: ByteString -> Maybe EJsonValue

-- | A function to check if all of the values in <tt>a</tt> match values
--   that exist in <tt>b</tt>. Not the same as equality.
--   
--   <pre>
--   { x = L             ==  { x = L
--   , y = M     <a>=</a>     ==  , y = M
--   , z = N             ==  , z = N
--   }                  ...  , a = ... }
--   
--   </pre>
--   
--   is still considered as matching.
--   
--   Matching is applied recursively.
--   
--   Items that are not EJObjects are compared for equality directly.
matches :: EJsonValue -> EJsonValue -> Bool

-- | getInPath fetches a value from an EJsonValue object at a point
--   indicated by a path.
--   
--   The path is a list of text values indicating successive object keys.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; getInPath ["a"] (ejobject [("a","b"),("x","y")])
--   Just "b"
--   </pre>
--   
--   If you attempt to retrieve a value that does not exist, then you will
--   get Nothing.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; getInPath ["a","q","r"] (ejobject [("x","y")])
--   Nothing
--   </pre>
getInPath :: [Text] -> EJsonValue -> Maybe EJsonValue

-- | putInPath is a method for placing a value into an EJsonValue object at
--   a point indicated by a path The path is a list of text values
--   indicating successive object keys. This can't be done with simple
--   lenses, as the nested obects may not exist. If they do exist, then it
--   is simply an update. However, if they don't exist then EJObjects are
--   created during the traversal.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; putInPath ["a"] "b" (ejobject [("x","y")])
--   Right {"a":"b","x":"y"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putInPath ["a","q","r"] (ejobject [("s","t")]) (ejobject [("x","y")])
--   Right {"a":{"q":{"r":{"s":"t"}}},"x":"y"}
--   </pre>
--   
--   If you attempt to update a value as if it were an EJObject when
--   in-fact it is something else, then you will receive an Error.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; putInPath ["a", "b"] "c" (ejobject [("a","hello")])
--   Left "Value \"hello\" does not match path [\"b\"]."
--   </pre>
putInPath :: [Text] -> EJsonValue -> EJsonValue -> Either String EJsonValue

-- | A variatnt of putInPath that leaves the EJsonValue unchanged if the
--   update is not sensible
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; putInPath' ["a"] "b" "hello"
--   "hello"
--   </pre>
putInPath' :: [Text] -> EJsonValue -> EJsonValue -> EJsonValue

-- | modifyInPath modifies values in an EJsonValue object at a point
--   indicated by a path.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; modifyInPath [] (ejobject [("q","r")]) (ejobject [("x","y")])
--   Right {"q":"r","x":"y"}
--   </pre>
--   
--   If you attempt to update a value as if it were an EJObject when
--   in-fact it is something else, then you will receive an Error.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; modifyInPath ["a", "b"] "c" (ejobject [("a","hello")])
--   Left "Path [\"a\",\"b\"] not present in object {\"a\":\"hello\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; modifyInPath ["a", "b"] (ejobject [("a","hello")]) "c"
--   Left "Path [\"a\",\"b\"] not present in object \"c\""
--   </pre>
modifyInPath :: [Text] -> EJsonValue -> EJsonValue -> Either String EJsonValue

-- | A variatnt of modifyInPath that leaves the EJsonValue unchanged if the
--   update is not sensible.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; modifyInPath' ["a", "b"] "c" (ejobject [("a","hello")])
--   {"a":"hello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; modifyInPath' ["a", "b"] (ejobject [("a","hello")]) "c"
--   "c"
--   </pre>
modifyInPath' :: [Text] -> EJsonValue -> EJsonValue -> EJsonValue

-- | removeFromPath removes values from an EJsonValue object at a point
--   indicated by a path.
--   
--   The path is a list of text values indicating successive object keys.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; removeFromPath ["a"] (ejobject [("a","b"),("x","y")])
--   Right {"x":"y"}
--   </pre>
--   
--   If you attempt to update a value as if it were an EJObject when
--   in-fact it is something else, then you will receive an Error.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; removeFromPath ["a","q","r"] (ejobject [("x","y")])
--   Left "Path [\"a\",\"q\",\"r\"] not present in object {\"x\":\"y\"}"
--   </pre>
removeFromPath :: [Text] -> EJsonValue -> Either String EJsonValue

-- | A variatnt of removeFromPath that leaves the EJsonValue unchanged if
--   the update is not sensible
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; removeFromPath' ["a","b"] (ejobject [("a", ejobject [("b","c")]), ("d","e")])
--   {"a":{},"d":"e"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; removeFromPath' ["a"] "hello"
--   "hello"
--   </pre>
removeFromPath' :: [Text] -> EJsonValue -> EJsonValue

-- | Constructs a Traversal' along a path of EJObject keys.
--   
--   Both ends of the traversal are maybes in order to allow
--   self-composition, and to allow the insertion/deletion of values at a
--   point in the path.
pathToTraversal' :: [Text] -> Traversal' (Maybe EJsonValue) (Maybe EJsonValue)

-- | Construct a simple message object with no data.
makeMsg :: Text -> EJsonValue

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJObject :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJArray :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJString :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJNumber :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJBool :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJDate :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJBinary :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJUser :: EJsonValue -> Bool

-- | Examples:
--   
--   <pre>
--   &gt;&gt;&gt; isEJObject EJNull
--   False
--   </pre>
--   
--   Constructor tests...
isEJNull :: EJsonValue -> Bool


-- | This module includes the two basic communication primitives required
--   for a DDP client:
--   
--   <ul>
--   <li>Sending (sendEJ)</li>
--   <li>Recieving (getEJ)</li>
--   </ul>
--   
--   These functions are included in a seperate module in order to avoid
--   recursive moldule import issues.
--   
--   This module is intended for internal use.
module Web.DDP.Deadpan.Comms

-- | Sends an EJsonValue to the server over the connection provided.
sendEJ :: Connection -> EJsonValue -> IO ()

-- | Possibly gets an EJsonValue from the server over the connection
--   provided
getEJ :: Connection -> IO (Maybe EJsonValue)


-- | A small helper to generate GUIDs.
--   
--   Provides functions to generate simple GUIDs.
module Web.DDP.Deadpan.GUID
data GUID
newGuid :: IO GUID
hashTriple :: IO (Integer, UTCTime, Integer)
newGuidInt :: IO Int
newGuidString :: IO String
newGuidText :: IO Text
makeEJsonId :: GUID -> EJsonValue
ejson2guid :: EJsonValue -> Maybe GUID

-- | Construct a matcher for subscription-ready based on ID.
--   
--   TODO: Allow for propper matcher behavior and abstraction a-la
--   clojure's midje methods. This is important as there could be multiple
--   subscription ids listed here...
guid2SubReady :: GUID -> EJsonValue

-- | Construct a matcher for subscription failure based on ID.
guid2NoSub :: GUID -> EJsonValue
instance Generic UTCTime
instance Generic Day
instance Eq GUID
instance Ord GUID
instance Generic GUID
instance Hashable GUID
instance Datatype D1GUID
instance Constructor C1_0GUID
instance Selector S1_0_0GUID
instance Datatype D1UTCTime
instance Constructor C1_0UTCTime
instance Selector S1_0_0UTCTime
instance Selector S1_0_1UTCTime
instance Datatype D1Day
instance Constructor C1_0Day
instance Selector S1_0_0Day
instance Show GUID
instance Hashable UTCTime
instance Hashable Day
instance Hashable DiffTime


-- | An EDSL designed to make writing deadpan applications easy!
--   
--   This DSL is a simple decoration of some application specific functions
--   arround a ReaderT monad instance.
--   
--   A core cabal of functions are exported from this module which are then
--   put to use in web.ddp.deadpan to create an expressive dsl for creating
--   ddp applications.
--   
--   The main functions exported are...
--   
--   TODO: Ensure these are up to date...
--   
--   <ul>
--   <li>rundeadpan</li>
--   <li>sethandler</li>
--   <li>deletehandler</li>
--   <li>setdefaulthandler</li>
--   <li>senddata</li>
--   <li>sendmessage</li>
--   </ul>
--   
--   these allow you to...
--   
--   <ul>
--   <li>run a deadpan application with some initial set of callbacks</li>
--   <li>set new values for response handlers</li>
--   <li>delete existing response handlers</li>
--   <li>set a handler to act when no existing handler matches the
--   incomming message</li>
--   <li>send an ejsonvalue to the server (low-level)</li>
--   <li>send messages to be interpreted as rpc calls</li>
--   </ul>
--   
--   ... respectively.
--   
--   There is also a `control.lens.lens` <a>collections</a> provided into a
--   single ejsonvalue.
--   
--   This can be used to...
--   
--   <ul>
--   <li>Retrieve any current collection data</li>
--   <li>Set collection data manually</li>
--   <li>Perform actions on collection data in callbacks</li>
--   </ul>
module Web.DDP.Deadpan.DSL

-- | The LookupItem data-type is used to store a set of callbacks.
--   
--   _ident is a reference to the callback, not the expected message id.
data LookupItem a
LI :: GUID -> a -> LookupItem a
_ident :: LookupItem a -> GUID
_body :: LookupItem a -> a
ident :: Lens' (LookupItem a_ajLX) GUID
body :: Lens (LookupItem a_ajLX) (LookupItem a_ajMW) a_ajLX a_ajMW
type Lookup a = Seq (LookupItem a)
data AppState cb
AppState :: Lookup cb -> EJsonValue -> Connection -> AppState cb

-- | Callbacks to match against by message
_callbackSet :: AppState cb -> Lookup cb

-- | Shared data Expected to be an EJObject
_collections :: AppState cb -> EJsonValue

-- | Network connection to server
_connection :: AppState cb -> Connection
connection :: Lens' (AppState cb_ajNd) Connection
collections :: Lens' (AppState cb_ajNd) EJsonValue
callbackSet :: Lens (AppState cb_ajNd) (AppState cb_ajOF) (Lookup cb_ajNd) (Lookup cb_ajOF)
type Callback = EJsonValue -> DeadpanApp ()
newtype DeadpanApp a
DeadpanApp :: ReaderT (TVar (AppState Callback)) IO a -> DeadpanApp a
_deadpanApp :: DeadpanApp a -> ReaderT (TVar (AppState Callback)) IO a
deadpanApp :: Iso (DeadpanApp a_ajP6) (DeadpanApp a_ajTA) (ReaderT (TVar (AppState Callback)) IO a_ajP6) (ReaderT (TVar (AppState Callback)) IO a_ajTA)
data Version
Vpre1 :: Version
Vpre2 :: Version
V1 :: Version
version2string :: Version -> EJsonValue
reverseVersions :: [EJsonValue]

-- | The order of these args match that of runReaderT
runDeadpan :: DeadpanApp a -> TVar (AppState Callback) -> IO a
newID :: DeadpanApp GUID
addHandler :: LookupItem Callback -> DeadpanApp ()
setHandler :: GUID -> Callback -> DeadpanApp GUID
onMatches :: EJsonValue -> Callback -> Callback
setMatchHandler :: EJsonValue -> Callback -> DeadpanApp GUID
setIdHandler :: GUID -> Callback -> DeadpanApp GUID
setMsgHandler :: Text -> Callback -> DeadpanApp GUID
setCatchAllHandler :: Callback -> DeadpanApp GUID
deleteHandlerID :: GUID -> DeadpanApp ()
modifyAppState :: (AppState Callback -> AppState Callback) -> DeadpanApp ()

-- | Get the raw app state. Reads the value out of the TVar container.
getAppState :: DeadpanApp (AppState Callback)

-- | Get the app state in conjunction with a Prism, allowing for more
--   succing state access
getAppStateL :: Prism' (AppState Callback) x -> DeadpanApp (Maybe x)
getCollections :: DeadpanApp EJsonValue

-- | A low-level function intended to be able to send any arbitrary data to
--   the server. Given that all messages to the server are intended to fit
--   the "message" format, You should probably use <a>sendMessage</a>
--   instead.
sendData :: EJsonValue -> DeadpanApp ()

-- | Send a particular type of message (indicated by the key) to the
--   server. This should be the primary means of [client -&gt; server]
--   communication by a client application.
sendMessage :: Text -> EJsonValue -> DeadpanApp ()

-- | Send a connection message to the server and specify the DDP API
--   version that you wish to use.
connectVersion :: Version -> DeadpanApp ()

-- | Send a generic connection message to the server.
connect :: DeadpanApp ()

-- | Provides a way to fork a background thread running the app provided
fork :: DeadpanApp a -> DeadpanApp ThreadId

-- | Runs fetchMessages and kills the thread when the supplied app
--   finishes.
--   
--   Note: Any DeadpanApp calls made after this one will not be able to
--   interact with server-sent messages.
fetchMessagesThenExit :: DeadpanApp a -> DeadpanApp a

-- | Continuously pull down messages from the server in a background thread
--   and respond to each message with the callback set. Returns a ThreadId
--   so that this can be killed explicitly before the program exits in
--   order to avoid the "recv: invalid argument (Bad file descriptor)"
--   error.
fetchMessages :: DeadpanApp ThreadId
getServerMessage :: DeadpanApp (Maybe EJsonValue)

-- | Loop through all callbacks
--   
--   Each callback is responsible for discarding messages that it doesn't
--   care about...
respondToMessage :: Lookup Callback -> Maybe EJsonValue -> DeadpanApp ()

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>Text</a>. Subject to
--   fusion. Performs replacement on invalid scalar values.
pack :: String -> Text
instance Eq Version
instance Ord Version
instance Enum Version
instance Bounded Version
instance Read Version
instance Show Version
instance MonadIO DeadpanApp
instance Applicative DeadpanApp
instance Functor DeadpanApp
instance Monad DeadpanApp


-- | This module is intended to provide a set of callbacks for various
--   server events.
--   
--   The set of callbacks provided fulfills the functionality require to be
--   able to implement a local data-store reflecting server-sent
--   data-update messages.
--   
--   <a>Web.DDP.Deadpan.Callbacks</a> is used frequently in
--   <a>Web.DDP.Deadpan</a>.
module Web.DDP.Deadpan.Callbacks
pingCallback :: Callback

-- | Initiate a subscription to a named collection on the server.
--   
--   Provide an id to refer to the subscription in future.
--   
--   <pre>
--   sub (client -&gt; server):
--     id:     string                        (an arbitrary client-determined
--                                               identifier for this subscription)
--     name:   string                        (the name of the subscription)
--     params: optional array of EJSON items (parameters to the subscription)
--   </pre>
clientDataSub :: GUID -> Text -> [EJsonValue] -> DeadpanApp GUID

-- | Activates a subscription with an auto-generated ID, returning the ID.
subscribe :: Text -> [EJsonValue] -> DeadpanApp GUID
subscribeWaitId :: Text -> [EJsonValue] -> DeadpanApp (Either EJsonValue (GUID, EJsonValue))
subscribeWait :: Text -> [EJsonValue] -> DeadpanApp (Either EJsonValue EJsonValue)

-- | Unsubscribe from an existing subscription indicated by its ID.
--   
--   <pre>
--   unsub (client -&gt; server):
--     id: string (the id passed to <tt>sub</tt>)
--   </pre>
clientDataUnsub :: GUID -> DeadpanApp ()

-- | Synonym for <a>clientDataUnsub</a>
unsubscribe :: GUID -> DeadpanApp ()

-- | As explained in the Meteor DDP documentation:
--   
--   <pre>
--   method:     string                        (method name)
--   params:     optional array of EJSON items (parameters to the method)
--   id:         string                        (an arbitrary client-determined identifier for this method call)
--   randomSeed: optional JSON value           (an arbitrary client-determined seed for pseudo-random generators)
--   
--   </pre>
clientRPCMethod :: Text -> [EJsonValue] -> GUID -> Maybe Text -> DeadpanApp GUID
rpc :: Text -> [EJsonValue] -> DeadpanApp GUID

-- | Like clientRPCMethod, except that it blocks, returning the response
--   from the server.
--   
--   TODO: Should we use the seed?
rpcWait :: Text -> [EJsonValue] -> DeadpanApp (Either EJsonValue EJsonValue)


-- | A collection of utilities to provide a way to create and run Deadpan
--   apps.
--   
--   This should be the only Deadpan module imported by users intending to
--   use Deadpan as a library in order to write DDP applications.
module Web.DDP.Deadpan

-- | Run a DeadpanApp against a set of connection parameters
--   
--   Only runs the app. Does not send connection request. Does not respond
--   to ping!
runBareClient :: Params -> DeadpanApp a -> IO a

-- | Run a DeadpanApp after establishing a server conncetion
--   
--   Does not respond to ping!
runConnectClient :: Params -> DeadpanApp a -> IO a
runConnectClientVersion :: Params -> Version -> DeadpanApp a -> IO a

-- | Run a DeadpanApp after registering a ping handler, then establishing a
--   server conncetion.
runPingClient :: Params -> DeadpanApp a -> IO a

-- | Same as runPingClient above but allows specifying version
runPingClientVersion :: Params -> Version -> DeadpanApp a -> IO a

-- | Automatically respond to server pings
handlePings :: DeadpanApp GUID

-- | Log all incomming messages to STDOUT
--   
--   Passes all messages through a Chan in order to not intermingle output
--   lines.
--   
--   Returns the chan so that it can be used by other sections of the app.
--   
--   Alternatively just set LineBuffering on your output handle.
logEverything :: DeadpanApp (Chan String)

-- | A variant of log-everything returning a chan to recieve messages on
--   instead of STDOUT.
logEverythingVia :: DeadpanApp (Chan String)

-- | A client that responds to server collection messages.
--   
--   Warning: this overwrites the "subscription-data" key of the
--   collections field of the AppState.
collect :: DeadpanApp ()
dataOver :: ([Text] -> EJsonValue -> EJsonValue -> EJsonValue) -> Callback

-- | An app to handle the addition of subscription data items...
--   
--   For Example:
--   {"collection":"lists","msg":"added","id":<a>F73xFyAuKrqsb2J3m</a>,"fields":{"incompleteCount":6,"name":"Favorite
--   Scientists"}}
--   
--   Not especially useful on its own. You would usually use <a>collect</a>
--   instead.
dataAdded :: Callback

-- | An app to handle the modification of subscription data items...
--   
--   For Example:
--   {"collection":"lists","msg":"changed","id":<a>TThFzYerrZaxmgjA7</a>,"fields":{"name":"List
--   Aasdf"}}
--   
--   Not especially useful on its own. You would usually use <a>collect</a>
--   instead.
dataChanged :: Callback

-- | An app to handle the removal of subscription data items...
--   
--   For Example:
--   {"collection":"lists","msg":"removed","id":<a>By8CtgWGvbZfJPFsd</a>}
--   
--   Not especially useful on its own. You would usually use <a>collect</a>
--   instead.
dataRemoved :: Callback

-- | A helper lens into the subscription data inside the collections
--   section of the dynamic app state.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; _collections $ set (subscriptions . _EJObjectKey "songs") (Just ejnull) (AppState undefined ejnull undefined)
--   null
--   </pre>
subscriptions :: Traversal' (AppState a) EJsonValue

-- | A client that sets the session id if the server sends it
--   {"server_id":"83752cf1-a9bf-a15e-b06a-91f110383550"}
--   
--   The handler deletes itself when the session is set.
setServerID :: DeadpanApp ()
putInBase :: Text -> EJsonValue -> DeadpanApp ()

-- | A client that sets the server_id if the server sends it
--   {"msg":"connected","session":<a>T6gBRv5RpCTwKcMSW</a>}
--   
--   TODO: The handler deletes itself when the session is set.
setSession :: DeadpanApp GUID
getURI :: String -> Either Error Params
type Error = String
type Params = (Domain, Port, Path)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
