-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | List arrows for Haskell.
--   
--   This small Haskell library provides some type class, types and
--   functions to work with list (and list-like) arrows. List arrows
--   represent computations that may return multiple outputs. Making
--   functions that return lists an instance of both the <a>Category</a>
--   and <a>Arrow</a> type class allow you to easily compose multiple
--   computations into one with standard building blocks.
@package arrow-list
@version 0.7

module Control.Monad.Sequence

-- | Parameterizable <tt>Sequence</tt> monad, with an inner monad. The
--   semantics of <a>SeqT</a> are comparable to that of <tt>ListT</tt>.
--   
--   <i>Note:</i> Like the ListT monad, this does not yield a monad unless
--   the argument monad is commutative.
newtype SeqT m a
SeqT :: m (Seq a) -> SeqT m a
runSeqT :: SeqT m a -> m (Seq a)
instance MonadIO m => MonadIO (SeqT m)
instance MonadTrans SeqT
instance Monad m => MonadPlus (SeqT m)
instance Monad m => Monad (SeqT m)
instance Applicative m => Alternative (SeqT m)
instance Applicative m => Applicative (SeqT m)
instance Functor m => Functor (SeqT m)


-- | The <a>ArrowList</a> type class, and a collection of list arrow
--   related functions. This typeclass can be used to embed functions
--   producing multiple outputs into a an arrow.
module Control.Arrow.List.Class

-- | The <a>ArrowList</a> class represents two possible actions:
--   
--   <ol>
--   <li>Lifting functions from one value to a list of values into a list
--   arrow.</li>
--   <li>Mapping a function over the result list of a list arrow.</li>
--   </ol>
class Arrow arr => ArrowList arr
arrL :: ArrowList arr => (a -> [b]) -> a `arr` b
mapL :: ArrowList arr => ([b] -> [c]) -> (a `arr` b) -> (a `arr` c)

-- | Create a list arrow of an input list.
unlist :: ArrowList arr => [b] `arr` b

-- | Take the output of an arrow producing two results and concatenate them
--   into the result of the list arrow.
unite :: ArrowList arr => (a `arr` (b, b)) -> a `arr` b

-- | Ignore the input and produce no results. Like <a>zeroArrow</a>.
none :: ArrowList arr => a `arr` b

-- | Collect the results of applying multiple arrows to the same input.
concatA :: ArrowPlus arr => [a `arr` b] -> a `arr` b

-- | Collect the entire results of an list arrow as a singleton value in
--   the result list.
list :: ArrowList arr => (a `arr` b) -> a `arr` [b]

-- | Returns a <a>Bool</a> indicating whether the input arrow produce any
--   results.
empty :: ArrowList arr => (a `arr` b) -> a `arr` Bool

-- | Create a filtering list arrow by mapping a predicate function over the
--   input. When the predicate returns <a>True</a> the input will be
--   returned in the output list, when <a>False</a> the empty list is
--   returned.
isA :: ArrowList arr => (a -> Bool) -> a `arr` a

-- | Use the result a list arrow as a conditional, like an if-then-else
--   arrow. When the first arrow produces any results the <i>then</i> arrow
--   will be used, when the first arrow produces no results the <i>else</i>
--   arrow will be used.
ifA :: (ArrowList arr, ArrowChoice arr) => (a `arr` c) -> (a `arr` b) -> (a `arr` b) -> a `arr` b

-- | Apply a list arrow only when a conditional arrow produces any results.
--   When the conditional produces no results the output arrow <i>behaves
--   like the identity</i>. The <i>second</i> input arrow is used as the
--   conditional, this allow you to write: <tt> a `when` c </tt>
when :: (ArrowList arr, ArrowChoice arr) => (a `arr` a) -> (a `arr` b) -> a `arr` a

-- | Apply a list arrow only when a conditional arrow produces any results.
--   When the conditional produces no results the output arrow <i>produces
--   no results</i>. The <i>first</i> input arrow is used as the
--   conditional, this allow you to write: <tt> c `guards` a </tt>
guards :: (ArrowList arr, ArrowChoice arr) => (a `arr` c) -> (a `arr` b) -> a `arr` b

-- | Filter the results of an arrow with a predicate arrow, when the filter
--   condition produces results the input is accepted otherwise it is
--   excluded.
filterA :: (ArrowChoice arr, ArrowList arr) => (a `arr` c) -> a `arr` a

-- | Negation list arrow. Only accept the input when the condition produces
--   no output.
notA :: (ArrowList arr, ArrowChoice arr) => (a `arr` c) -> a `arr` a

-- | Apply the input arrow, when the arrow does not produces any results
--   the second fallback arrow is applied. Likely written infix like this
--   <tt> a `orElse` b </tt>
orElse :: (ArrowList arr, ArrowChoice arr) => (a `arr` b) -> (a `arr` b) -> a `arr` b

-- | Map a <a>Maybe</a> input to a list output. When the Maybe is a
--   <a>Nothing</a> an empty list will be returned, <a>Just</a> will result
--   in a singleton list.
maybeL :: ArrowList arr => Maybe a `arr` a

-- | Apply a list arrow, when there are no results a <a>Nothing</a> will be
--   returned, otherwise the results will be wrapped in a <a>Just</a>. This
--   function always produces result.
optional :: (ArrowChoice arr, ArrowList arr) => (a `arr` b) -> a `arr` Maybe b


-- | The <a>ArrowKleisli</a> type class allows for embedding monadic
--   operations in Kleisli arrows.
module Control.Arrow.Kleisli.Class
class (Monad m, Arrow arr) => ArrowKleisli m arr | arr -> m
arrM :: ArrowKleisli m arr => (a -> m b) -> a `arr` b
constM :: ArrowKleisli m arr => m b -> a `arr` b
effect :: ArrowKleisli m arr => m () -> a `arr` a
arrIO :: (MonadIO m, ArrowKleisli m arr) => (a -> IO b) -> a `arr` b
instance Monad m => ArrowKleisli m (Kleisli m)

module Control.Arrow.ListLike.Class

-- | A type class for arrows that produce containers of results. The
--   container arrow can be seen as a generalization for list arrows. Most
--   operations assume the container type has an <a>Applicative</a>, an
--   <a>Alternative</a> and a <a>Foldable</a> instance.
class Arrow arr => ArrowListLike f arr | arr -> f
embed :: ArrowListLike f arr => f a `arr` a
observe :: ArrowListLike f arr => (a `arr` b) -> a `arr` f b

-- | Map a function over the result collection of a container arrow.
mapF :: ArrowListLike f arr => (f b -> f c) -> a `arr` b -> a `arr` c

-- | Embed a monadic function returning an ordered list into a container
--   arrow.
arrMF :: (ArrowListLike f arr, ArrowKleisli m arr) => (a -> m (f c)) -> a `arr` c

-- | Take the output of an arrow producing two results and concatenate them
--   into the result of the container arrow.
unite :: ArrowPlus arr => (b, b) `arr` b

-- | Skip the input and produce a constant output.
const :: Arrow arr => b -> a `arr` b

-- | Collect the results of applying multiple arrows to the same input.
concatA :: ArrowPlus arr => [a `arr` b] -> a `arr` b

-- | Join the results of two arrows, like (<a>+</a>) from ArrowPlus.
plus :: (Alternative f, ArrowListLike f arr) => (a `arr` b) -> (a `arr` b) -> a `arr` b

-- | Skip the input and produce a constant output specified as a container.
constF :: ArrowListLike f arr => f c -> a `arr` c

-- | Ignore the input and produce no results. Like <a>zeroArrow</a>.
none :: (Alternative f, ArrowListLike f arr) => a `arr` b

-- | Returns a <a>Bool</a> indicating whether the input arrow produces a
--   container with any results.
results :: (Foldable f, ArrowListLike f arr) => (a `arr` b) -> (a `arr` Bool)

-- | Create a filtering container arrow by mapping a predicate function
--   over the input. When the predicate returns <a>True</a> the input will
--   be returned in the output container, when <a>False</a> the empty
--   container is returned.
isA :: (Alternative f, ArrowListLike f arr) => (a -> Bool) -> a `arr` a

-- | Use the result of a container arrow as a conditional, like an
--   if-then-else arrow. When the first arrow produces any results the
--   <i>then</i> arrow will be used, when the first arrow produces no
--   results the <i>else</i> arrow will be used.
ifA :: (Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` b) -> (a `arr` t) -> (a `arr` t) -> a `arr` t

-- | Apply a container arrow only when a conditional arrow produces any
--   results. When the conditional produces no results the output arrow
--   /behaves like the identity<i>. The </i>second/ input arrow is used as
--   the conditional, this allow you to write: <tt> a `when` condition
--   </tt>
when :: (Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` a) -> (a `arr` c) -> a `arr` a

-- | Apply a container arrow only when a conditional arrow produces any
--   results. When the conditional produces no results the output arrow
--   <i>produces no results</i>. The <i>first</i> input arrow is used as
--   the conditional, this allow you to write: <tt> condition `guards` a
--   </tt>
guards :: (Alternative f, Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` c) -> (a `arr` b) -> (a `arr` b)

-- | Filter the results of an arrow with a predicate arrow, when the filter
--   condition produces results the input is accepted otherwise it is
--   excluded.
filterA :: (Alternative f, Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` c) -> a `arr` a

-- | Negation container arrow. Only accept the input when the condition
--   produces no output.
notA :: (Alternative f, Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` c) -> a `arr` a

-- | Apply the input arrow, when the arrow does not produces any results
--   the second fallback arrow is applied. Likely written infix like this
--   <tt> a `orElse` b </tt>
orElse :: (Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` b) -> (a `arr` b) -> a `arr` b

-- | Map a <a>Maybe</a> input to a container output. When the Maybe is a
--   <a>Nothing</a> an empty container will be returned, <a>Just</a> will
--   result in a singleton container.
maybeA :: (Alternative f, ArrowListLike f arr) => Maybe a `arr` a

-- | Apply a container arrow, when there are no results a <a>Nothing</a>
--   will be returned, otherwise the results will be wrapped in a
--   <a>Just</a>. This function always produces result.
optional :: (Foldable f, ArrowListLike f arr, ArrowChoice arr) => (a `arr` b) -> a `arr` Maybe b

module Control.Arrow.List
newtype ListTArrow m a b
ListTArrow :: Kleisli (ListT m) a b -> ListTArrow m a b
runListTArrow' :: ListTArrow m a b -> Kleisli (ListT m) a b
runListTArrow :: ListTArrow m a b -> a -> m [b]
type ListArrow a b = ListTArrow Identity a b
runListArrow :: ListArrow a b -> a -> [b]
arrML :: (ArrowList arr, ArrowKleisli m arr) => (a -> m [b]) -> a `arr` b
instance Monad m => Category (ListTArrow m)
instance Monad m => Arrow (ListTArrow m)
instance Monad m => ArrowZero (ListTArrow m)
instance Monad m => ArrowPlus (ListTArrow m)
instance Monad m => ArrowApply (ListTArrow m)
instance Monad m => ArrowChoice (ListTArrow m)
instance Monad m => ArrowListLike [] (ListTArrow m)
instance Monad m => ArrowList (ListTArrow m)
instance Monad m => ArrowKleisli m (ListTArrow m)

module Control.Arrow.Sequence
newtype SeqTArrow m a b
SeqTArrow :: Kleisli (SeqT m) a b -> SeqTArrow m a b
runSeqTArrow' :: SeqTArrow m a b -> Kleisli (SeqT m) a b
runSeqTArrow :: SeqTArrow m a b -> a -> m (Seq b)
type SeqArrow a b = SeqTArrow Identity a b
runSeqArrow :: SeqArrow a b -> a -> Seq b
instance Monad m => Category (SeqTArrow m)
instance Monad m => Arrow (SeqTArrow m)
instance Monad m => ArrowZero (SeqTArrow m)
instance Monad m => ArrowPlus (SeqTArrow m)
instance Monad m => ArrowApply (SeqTArrow m)
instance Monad m => ArrowChoice (SeqTArrow m)
instance Monad m => ArrowListLike Seq (SeqTArrow m)
instance Monad m => ArrowKleisli m (SeqTArrow m)
