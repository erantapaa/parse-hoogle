-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deriving Parsers and Quasi-Quoters from BNF Grammars
--   
@package BNFC-meta
@version 0.4.0.3


-- | Contains things that are typically needed in modules that use
--   languages defined using BNFC-meta.
module Language.LBNF.Runtime
data ParseMonad a
Ok :: a -> ParseMonad a
Bad :: String -> ParseMonad a
err :: (String -> a) -> ParseMonad a -> a
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
concatD :: [Doc] -> Doc
class Print a where prtList = concatD . map (prt 0)
prt :: Print a => Int -> a -> Doc
prtList :: Print a => [a] -> Doc
prPrec :: Int -> Int -> Doc -> Doc
newtype PrintPlain
MkPrintPlain :: String -> PrintPlain
instance Read a => Read (ParseMonad a)
instance Show a => Show (ParseMonad a)
instance Eq a => Eq (ParseMonad a)
instance Ord a => Ord (ParseMonad a)
instance Print PrintPlain
instance Print Double
instance Print Integer
instance Print Char
instance Print a => Print [a]
instance Applicative ParseMonad
instance Functor ParseMonad
instance Monad ParseMonad


-- | Contains things needed by BNFC-meta language definitions and by the
--   code generated from those. Typical users don't need to browse this
--   module.
module Language.LBNF.Compiletime
data HappyStk a :: * -> *
HappyStk :: a -> HappyStk a -> HappyStk a
utf8Encode :: Char -> [Word8]
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
type AlexInput = (Posn, Char, [Word8], String)
alexGetByte :: AlexInput -> Maybe (Word8, AlexInput)

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Construct an array from a pair of bounds and a list of values in index
--   order.
listArray :: Ix i => (i, i) -> [e] -> Array i e

-- | The value at the given index in an array.
(!) :: Ix i => Array i e -> i -> e

-- | The type of immutable non-strict (boxed) arrays with indices in
--   <tt>i</tt> and elements in <tt>e</tt>.
data Array i e :: * -> * -> *
printTree :: Print a => a -> String
doc :: ShowS -> Doc
concatD :: [Doc] -> Doc
class Print a where prtList = concatD . map (prt 0)
prt :: Print a => Int -> a -> Doc
prtList :: Print a => [a] -> Doc
prPrec :: Int -> Int -> Doc -> Doc
newtype PrintPlain
MkPrintPlain :: String -> PrintPlain
parseToQuoter :: (String -> ParseMonad BNFC_QQType) -> QuasiQuoter
parseToMonQuoter :: (String -> ParseMonad BNFC_QQType) -> QuasiQuoter
data ParseMonad a
Ok :: a -> ParseMonad a
Bad :: String -> ParseMonad a
errq :: (String -> a) -> ParseMonad a -> Q a
data Q a :: * -> *
data BNFC_QQType
QQApp :: (String, LocType) -> [BNFC_QQType] -> BNFC_QQType
QQAq :: (Q Exp, Q Pat) -> BNFC_QQType
QQList :: [BNFC_QQType] -> BNFC_QQType
QQLit :: Lit -> BNFC_QQType
QQPosT :: (Int, Int) -> (String, LocType) -> String -> BNFC_QQType
appEPAll :: LocType -> String -> [BNFC_QQType] -> BNFC_QQType
appEPAllL :: LocType -> [BNFC_QQType] -> BNFC_QQType
fromString :: Literal a => LocType -> a -> BNFC_QQType
fromLit :: Literal a => LocType -> a -> BNFC_QQType
fromToken :: Literal a => LocType -> String -> a -> BNFC_QQType
fromPositionToken :: LocType -> String -> ((Int, Int), String) -> BNFC_QQType
class Lift t
lift :: Lift t => t -> Q Exp
type LocType = (String, String)
class Literal a
lit :: Literal a => a -> Lit
class IsChar a
toChar :: IsChar a => a -> Char
printAq :: Print a => a -> BNFC_QQType
stringAq :: String -> BNFC_QQType
instance Eq Posn
instance Show Posn
instance Ord Posn
instance IsChar a => Literal [a]
instance IsChar Char
instance Literal Char
instance Literal Integer
instance Literal Double

module Language.LBNF.Grammar
myLexer :: String -> [Token]
tokens :: String -> [Token]
pGrammar :: [Token] -> ParseMonad Grammar
pListDef :: [Token] -> ParseMonad [Def]
pListItem :: [Token] -> ParseMonad [Item]
pDef :: [Token] -> ParseMonad Def
pRHS :: [Token] -> ParseMonad RHS
pListRHS :: [Token] -> ParseMonad [RHS]
pItem :: [Token] -> ParseMonad Item
pCat :: [Token] -> ParseMonad Cat
pCat1 :: [Token] -> ParseMonad Cat
pLabel :: [Token] -> ParseMonad Label
pMIdent :: [Token] -> ParseMonad MIdent
pHsTyp :: [Token] -> ParseMonad HsTyp
pHsTyp1 :: [Token] -> ParseMonad HsTyp
pListHsTyp :: [Token] -> ParseMonad [HsTyp]
pArg :: [Token] -> ParseMonad Arg
pListArg :: [Token] -> ParseMonad [Arg]
pExp :: [Token] -> ParseMonad Exp
pExp1 :: [Token] -> ParseMonad Exp
pExp2 :: [Token] -> ParseMonad Exp
pListExp2 :: [Token] -> ParseMonad [Exp]
pListExp :: [Token] -> ParseMonad [Exp]
pListString :: [Token] -> ParseMonad [String]
pMinimumSize :: [Token] -> ParseMonad MinimumSize
pReg2 :: [Token] -> ParseMonad Reg
pReg1 :: [Token] -> ParseMonad Reg
pReg3 :: [Token] -> ParseMonad Reg
pReg :: [Token] -> ParseMonad Reg
pListIdent :: [Token] -> ParseMonad [Ident]
qGrammar :: [Token] -> ParseMonad BNFC_QQType
qListDef :: [Token] -> ParseMonad BNFC_QQType
qListItem :: [Token] -> ParseMonad BNFC_QQType
qDef :: [Token] -> ParseMonad BNFC_QQType
qRHS :: [Token] -> ParseMonad BNFC_QQType
qListRHS :: [Token] -> ParseMonad BNFC_QQType
qItem :: [Token] -> ParseMonad BNFC_QQType
qCat :: [Token] -> ParseMonad BNFC_QQType
qCat1 :: [Token] -> ParseMonad BNFC_QQType
qLabel :: [Token] -> ParseMonad BNFC_QQType
qMIdent :: [Token] -> ParseMonad BNFC_QQType
qHsTyp :: [Token] -> ParseMonad BNFC_QQType
qHsTyp1 :: [Token] -> ParseMonad BNFC_QQType
qListHsTyp :: [Token] -> ParseMonad BNFC_QQType
qArg :: [Token] -> ParseMonad BNFC_QQType
qListArg :: [Token] -> ParseMonad BNFC_QQType
qExp :: [Token] -> ParseMonad BNFC_QQType
qExp1 :: [Token] -> ParseMonad BNFC_QQType
qExp2 :: [Token] -> ParseMonad BNFC_QQType
qListExp2 :: [Token] -> ParseMonad BNFC_QQType
qListExp :: [Token] -> ParseMonad BNFC_QQType
qListString :: [Token] -> ParseMonad BNFC_QQType
qMinimumSize :: [Token] -> ParseMonad BNFC_QQType
qReg2 :: [Token] -> ParseMonad BNFC_QQType
qReg1 :: [Token] -> ParseMonad BNFC_QQType
qReg3 :: [Token] -> ParseMonad BNFC_QQType
qReg :: [Token] -> ParseMonad BNFC_QQType
qListIdent :: [Token] -> ParseMonad BNFC_QQType
grammar :: QuasiQuoter
listDef :: QuasiQuoter
listItem :: QuasiQuoter
def :: QuasiQuoter
rHS :: QuasiQuoter
listRHS :: QuasiQuoter
item :: QuasiQuoter
cat :: QuasiQuoter
cat1 :: QuasiQuoter
label :: QuasiQuoter
mIdent :: QuasiQuoter
hsTyp :: QuasiQuoter
hsTyp1 :: QuasiQuoter
listHsTyp :: QuasiQuoter
arg :: QuasiQuoter
listArg :: QuasiQuoter
exp :: QuasiQuoter
exp1 :: QuasiQuoter
exp2 :: QuasiQuoter
listExp2 :: QuasiQuoter
listExp :: QuasiQuoter
listString :: QuasiQuoter
minimumSize :: QuasiQuoter
reg2 :: QuasiQuoter
reg1 :: QuasiQuoter
reg3 :: QuasiQuoter
reg :: QuasiQuoter
listIdent :: QuasiQuoter
data Grammar
Grammar :: ([Def]) -> Grammar
data Def
Rule :: Label -> Cat -> RHS -> Def
Comment :: String -> Def
Comments :: String -> String -> Def
Internal :: Label -> Cat -> ([Item]) -> Def
Token :: Ident -> Reg -> Def
PosToken :: Ident -> Reg -> Def
Entryp :: ([Ident]) -> Def
Separator :: MinimumSize -> Cat -> String -> Def
Terminator :: MinimumSize -> Cat -> String -> Def
Coercions :: Ident -> Integer -> Def
Rules :: Ident -> ([RHS]) -> Def
Function :: Ident -> ([Arg]) -> Exp -> Def
External :: Ident -> HsTyp -> Def
AntiQuote :: String -> String -> String -> Def
Derive :: ([Ident]) -> Def
Layout :: ([String]) -> Def
LayoutStop :: ([String]) -> Def
LayoutTop :: Def
data RHS
RHS :: ([Item]) -> RHS
TRHS :: Reg -> RHS
data Item
Terminal :: String -> Item
NTerminal :: Cat -> Item
data Cat
OptCat :: Cat -> Cat
ListCat :: Cat -> Cat
IdCat :: Ident -> Cat
data Label
Id :: Ident -> Label
Wild :: Label
ListE :: Label
ListCons :: Label
ListOne :: Label
Aq :: MIdent -> Label
data MIdent
JIdent :: Ident -> MIdent
NIdent :: MIdent
data HsTyp
HsApp :: HsTyp -> HsTyp -> HsTyp
HsCon :: Ident -> HsTyp
HsTup :: ([HsTyp]) -> HsTyp
HsList :: HsTyp -> HsTyp
data Arg
Arg :: Ident -> Arg
data Exp
Cons :: Exp -> Exp -> Exp
App :: Ident -> ([Exp]) -> Exp
Var :: Ident -> Exp
LitInt :: Integer -> Exp
LitChar :: Char -> Exp
LitString :: String -> Exp
LitDouble :: Double -> Exp
List :: ([Exp]) -> Exp
data MinimumSize
MNonempty :: MinimumSize
MEmpty :: MinimumSize
data Reg
RSeq :: Reg -> Reg -> Reg
RAlt :: Reg -> Reg -> Reg
RMinus :: Reg -> Reg -> Reg
RStar :: Reg -> Reg
RPlus :: Reg -> Reg
ROpt :: Reg -> Reg
REps :: Reg
RChar :: Char -> Reg
RAlts :: String -> Reg
RSeqs :: String -> Reg
RDigit :: Reg
RLetter :: Reg
RUpper :: Reg
RLower :: Reg
RAny :: Reg
newtype Ident
Ident :: String -> Ident
instance Show MinimumSize
instance Eq MinimumSize
instance Ord MinimumSize
instance Show Reg
instance Eq Reg
instance Ord Reg
instance Show Ident
instance Eq Ident
instance Ord Ident
instance Show Exp
instance Eq Exp
instance Ord Exp
instance Show Arg
instance Eq Arg
instance Ord Arg
instance Show HsTyp
instance Eq HsTyp
instance Ord HsTyp
instance Show MIdent
instance Eq MIdent
instance Ord MIdent
instance Show Label
instance Eq Label
instance Ord Label
instance Show Cat
instance Eq Cat
instance Ord Cat
instance Show Item
instance Eq Item
instance Ord Item
instance Show RHS
instance Eq RHS
instance Ord RHS
instance Show Def
instance Eq Def
instance Ord Def
instance Show Grammar
instance Eq Grammar
instance Ord Grammar
instance Eq Tok
instance Show Tok
instance Ord Tok
instance Eq Token
instance Show Token
instance Ord Token
instance Show BTree
instance Functor AlexLastAcc
instance Print Reg
instance Print MinimumSize
instance Print Exp
instance Print Arg
instance Print HsTyp
instance Print MIdent
instance Print Label
instance Print Cat
instance Print Item
instance Print RHS
instance Print Def
instance Print Grammar
instance Print Ident


-- | Contains the main language definition routines of BNFC-meta.
module Language.LBNF

-- | QuasiQuoter for LBNF. Usage: <tt>[lbnf| &lt;grammar for your
--   language&gt;|]</tt>
--   
--   The spliced code is an expression of type <a>Grammar</a>.
lbnf :: QuasiQuoter

-- | Typical usage (as a top level declaration): <tt>bnfc
--   [lbnf|&lt;grammar&gt;|]</tt>
--   
--   The spliced code contains a parser, a pretty-printer and a
--   Quasi-Quoter for the language defined by the grammar.
bnfc :: Grammar -> Q [Dec]

-- | Equivalent to <a>bnfc</a> with the side-effect of dumping ALL the
--   spliced code into a file named dump.hs
dumpCode :: Grammar -> Q [Dec]

-- | Computes the Haskell source code that would be spliced by a grammar
--   and wraps it into a compilable Haskell module.
getCode :: String -> Grammar -> IO String

-- | Equivalent to <a>bnfc</a> with the side-effect of dumping the lexer
--   definition into a file named dump.x
dumpAlex :: Grammar -> Q [Dec]

-- | Equivalent to <a>bnfc</a> with the side-effect of dumping the parser
--   definition into a file named "dump.y"
dumpHappy :: Grammar -> Q [Dec]
